{"sha": "028d409252058d88805341a3f6dc0ff1553f5bdc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI4ZDQwOTI1MjA1OGQ4ODgwNTM0MWEzZjZkYzBmZjE1NTNmNWJkYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-11-12T10:08:40Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-11-12T10:08:40Z"}, "message": "Apply mechanical replacement (generated patch).\n\n2019-11-12  Martin Liska  <mliska@suse.cz>\n\n\t* asan.c (asan_sanitize_stack_p): Replace old parameter syntax\n\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n\tmacro.\n\t(asan_sanitize_allocas_p): Likewise.\n\t(asan_emit_stack_protection): Likewise.\n\t(asan_protect_global): Likewise.\n\t(instrument_derefs): Likewise.\n\t(instrument_builtin_call): Likewise.\n\t(asan_expand_mark_ifn): Likewise.\n\t* auto-profile.c (auto_profile): Likewise.\n\t* bb-reorder.c (copy_bb_p): Likewise.\n\t(duplicate_computed_gotos): Likewise.\n\t* builtins.c (inline_expand_builtin_string_cmp): Likewise.\n\t* cfgcleanup.c (try_crossjump_to_edge): Likewise.\n\t(try_crossjump_bb): Likewise.\n\t* cfgexpand.c (defer_stack_allocation): Likewise.\n\t(stack_protect_classify_type): Likewise.\n\t(pass_expand::execute): Likewise.\n\t* cfgloopanal.c (expected_loop_iterations_unbounded): Likewise.\n\t(estimate_reg_pressure_cost): Likewise.\n\t* cgraph.c (cgraph_edge::maybe_hot_p): Likewise.\n\t* combine.c (combine_instructions): Likewise.\n\t(record_value_for_reg): Likewise.\n\t* common/config/aarch64/aarch64-common.c (aarch64_option_validate_param): Likewise.\n\t(aarch64_option_default_params): Likewise.\n\t* common/config/ia64/ia64-common.c (ia64_option_default_params): Likewise.\n\t* common/config/powerpcspe/powerpcspe-common.c (rs6000_option_default_params): Likewise.\n\t* common/config/rs6000/rs6000-common.c (rs6000_option_default_params): Likewise.\n\t* common/config/sh/sh-common.c (sh_option_default_params): Likewise.\n\t* config/aarch64/aarch64.c (aarch64_output_probe_stack_range): Likewise.\n\t(aarch64_allocate_and_probe_stack_space): Likewise.\n\t(aarch64_expand_epilogue): Likewise.\n\t(aarch64_override_options_internal): Likewise.\n\t* config/alpha/alpha.c (alpha_option_override): Likewise.\n\t* config/arm/arm.c (arm_option_override): Likewise.\n\t(arm_valid_target_attribute_p): Likewise.\n\t* config/i386/i386-options.c (ix86_option_override_internal): Likewise.\n\t* config/i386/i386.c (get_probe_interval): Likewise.\n\t(ix86_adjust_stack_and_probe_stack_clash): Likewise.\n\t(ix86_max_noce_ifcvt_seq_cost): Likewise.\n\t* config/ia64/ia64.c (ia64_adjust_cost): Likewise.\n\t* config/rs6000/rs6000-logue.c (get_stack_clash_protection_probe_interval): Likewise.\n\t(get_stack_clash_protection_guard_size): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Likewise.\n\t* config/s390/s390.c (allocate_stack_space): Likewise.\n\t(s390_emit_prologue): Likewise.\n\t(s390_option_override_internal): Likewise.\n\t* config/sparc/sparc.c (sparc_option_override): Likewise.\n\t* config/visium/visium.c (visium_option_override): Likewise.\n\t* coverage.c (get_coverage_counts): Likewise.\n\t(coverage_compute_profile_id): Likewise.\n\t(coverage_begin_function): Likewise.\n\t(coverage_end_function): Likewise.\n\t* cse.c (cse_find_path): Likewise.\n\t(cse_extended_basic_block): Likewise.\n\t(cse_main): Likewise.\n\t* cselib.c (cselib_invalidate_mem): Likewise.\n\t* dse.c (dse_step1): Likewise.\n\t* emit-rtl.c (set_new_first_and_last_insn): Likewise.\n\t(get_max_insn_count): Likewise.\n\t(make_debug_insn_raw): Likewise.\n\t(init_emit): Likewise.\n\t* explow.c (compute_stack_clash_protection_loop_data): Likewise.\n\t* final.c (compute_alignments): Likewise.\n\t* fold-const.c (fold_range_test): Likewise.\n\t(fold_truth_andor): Likewise.\n\t(tree_single_nonnegative_warnv_p): Likewise.\n\t(integer_valued_real_single_p): Likewise.\n\t* gcse.c (want_to_gcse_p): Likewise.\n\t(prune_insertions_deletions): Likewise.\n\t(hoist_code): Likewise.\n\t(gcse_or_cprop_is_too_expensive): Likewise.\n\t* ggc-common.c: Likewise.\n\t* ggc-page.c (ggc_collect): Likewise.\n\t* gimple-loop-interchange.cc (MAX_NUM_STMT): Likewise.\n\t(MAX_DATAREFS): Likewise.\n\t(OUTER_STRIDE_RATIO): Likewise.\n\t* gimple-loop-jam.c (tree_loop_unroll_and_jam): Likewise.\n\t* gimple-loop-versioning.cc (loop_versioning::max_insns_for_loop): Likewise.\n\t* gimple-ssa-split-paths.c (is_feasible_trace): Likewise.\n\t* gimple-ssa-store-merging.c (imm_store_chain_info::try_coalesce_bswap): Likewise.\n\t(imm_store_chain_info::coalesce_immediate_stores): Likewise.\n\t(imm_store_chain_info::output_merged_store): Likewise.\n\t(pass_store_merging::process_store): Likewise.\n\t* gimple-ssa-strength-reduction.c (find_basis_for_base_expr): Likewise.\n\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple): Likewise.\n\t(scop_to_isl_ast): Likewise.\n\t* graphite-optimize-isl.c (get_schedule_for_node_st): Likewise.\n\t(optimize_isl): Likewise.\n\t* graphite-scop-detection.c (build_scops): Likewise.\n\t* haifa-sched.c (set_modulo_params): Likewise.\n\t(rank_for_schedule): Likewise.\n\t(model_add_to_worklist): Likewise.\n\t(model_promote_insn): Likewise.\n\t(model_choose_insn): Likewise.\n\t(queue_to_ready): Likewise.\n\t(autopref_multipass_dfa_lookahead_guard): Likewise.\n\t(schedule_block): Likewise.\n\t(sched_init): Likewise.\n\t* hsa-gen.c (init_prologue): Likewise.\n\t* ifcvt.c (bb_ok_for_noce_convert_multiple_sets): Likewise.\n\t(cond_move_process_if_block): Likewise.\n\t* ipa-cp.c (ipcp_lattice::add_value): Likewise.\n\t(merge_agg_lats_step): Likewise.\n\t(devirtualization_time_bonus): Likewise.\n\t(hint_time_bonus): Likewise.\n\t(incorporate_penalties): Likewise.\n\t(good_cloning_opportunity_p): Likewise.\n\t(ipcp_propagate_stage): Likewise.\n\t* ipa-fnsummary.c (decompose_param_expr): Likewise.\n\t(set_switch_stmt_execution_predicate): Likewise.\n\t(analyze_function_body): Likewise.\n\t(compute_fn_summary): Likewise.\n\t* ipa-inline-analysis.c (estimate_growth): Likewise.\n\t* ipa-inline.c (caller_growth_limits): Likewise.\n\t(inline_insns_single): Likewise.\n\t(inline_insns_auto): Likewise.\n\t(can_inline_edge_by_limits_p): Likewise.\n\t(want_early_inline_function_p): Likewise.\n\t(big_speedup_p): Likewise.\n\t(want_inline_small_function_p): Likewise.\n\t(want_inline_self_recursive_call_p): Likewise.\n\t(edge_badness): Likewise.\n\t(recursive_inlining): Likewise.\n\t(compute_max_insns): Likewise.\n\t(early_inliner): Likewise.\n\t* ipa-polymorphic-call.c (csftc_abort_walking_p): Likewise.\n\t* ipa-profile.c (ipa_profile): Likewise.\n\t* ipa-prop.c (determine_known_aggregate_parts): Likewise.\n\t(ipa_analyze_node): Likewise.\n\t(ipcp_transform_function): Likewise.\n\t* ipa-split.c (consider_split): Likewise.\n\t* ipa-sra.c (allocate_access): Likewise.\n\t(process_scan_results): Likewise.\n\t(ipa_sra_summarize_function): Likewise.\n\t(pull_accesses_from_callee): Likewise.\n\t* ira-build.c (loop_compare_func): Likewise.\n\t(mark_loops_for_removal): Likewise.\n\t* ira-conflicts.c (build_conflict_bit_table): Likewise.\n\t* loop-doloop.c (doloop_optimize): Likewise.\n\t* loop-invariant.c (gain_for_invariant): Likewise.\n\t(move_loop_invariants): Likewise.\n\t* loop-unroll.c (decide_unroll_constant_iterations): Likewise.\n\t(decide_unroll_runtime_iterations): Likewise.\n\t(decide_unroll_stupid): Likewise.\n\t(expand_var_during_unrolling): Likewise.\n\t* lra-assigns.c (spill_for): Likewise.\n\t* lra-constraints.c (EBB_PROBABILITY_CUTOFF): Likewise.\n\t* modulo-sched.c (sms_schedule): Likewise.\n\t(DFA_HISTORY): Likewise.\n\t* opts.c (default_options_optimization): Likewise.\n\t(finish_options): Likewise.\n\t(common_handle_option): Likewise.\n\t* postreload-gcse.c (eliminate_partially_redundant_load): Likewise.\n\t(if): Likewise.\n\t* predict.c (get_hot_bb_threshold): Likewise.\n\t(maybe_hot_count_p): Likewise.\n\t(probably_never_executed): Likewise.\n\t(predictable_edge_p): Likewise.\n\t(predict_loops): Likewise.\n\t(expr_expected_value_1): Likewise.\n\t(tree_predict_by_opcode): Likewise.\n\t(handle_missing_profiles): Likewise.\n\t* reload.c (find_equiv_reg): Likewise.\n\t* reorg.c (redundant_insn): Likewise.\n\t* resource.c (mark_target_live_regs): Likewise.\n\t(incr_ticks_for_insn): Likewise.\n\t* sanopt.c (pass_sanopt::execute): Likewise.\n\t* sched-deps.c (sched_analyze_1): Likewise.\n\t(sched_analyze_2): Likewise.\n\t(sched_analyze_insn): Likewise.\n\t(deps_analyze_insn): Likewise.\n\t* sched-ebb.c (schedule_ebbs): Likewise.\n\t* sched-rgn.c (find_single_block_region): Likewise.\n\t(too_large): Likewise.\n\t(haifa_find_rgns): Likewise.\n\t(extend_rgns): Likewise.\n\t(new_ready): Likewise.\n\t(schedule_region): Likewise.\n\t(sched_rgn_init): Likewise.\n\t* sel-sched-ir.c (make_region_from_loop): Likewise.\n\t* sel-sched-ir.h (MAX_WS): Likewise.\n\t* sel-sched.c (process_pipelined_exprs): Likewise.\n\t(sel_setup_region_sched_flags): Likewise.\n\t* shrink-wrap.c (try_shrink_wrapping): Likewise.\n\t* targhooks.c (default_max_noce_ifcvt_seq_cost): Likewise.\n\t* toplev.c (print_version): Likewise.\n\t(process_options): Likewise.\n\t* tracer.c (tail_duplicate): Likewise.\n\t* trans-mem.c (tm_log_add): Likewise.\n\t* tree-chrec.c (chrec_fold_plus_1): Likewise.\n\t* tree-data-ref.c (split_constant_offset): Likewise.\n\t(compute_all_dependences): Likewise.\n\t* tree-if-conv.c (MAX_PHI_ARG_NUM): Likewise.\n\t* tree-inline.c (remap_gimple_stmt): Likewise.\n\t* tree-loop-distribution.c (MAX_DATAREFS_NUM): Likewise.\n\t* tree-parloops.c (MIN_PER_THREAD): Likewise.\n\t(create_parallel_loop): Likewise.\n\t* tree-predcom.c (determine_unroll_factor): Likewise.\n\t* tree-scalar-evolution.c (instantiate_scev_r): Likewise.\n\t* tree-sra.c (analyze_all_variable_accesses): Likewise.\n\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Likewise.\n\t* tree-ssa-dse.c (setup_live_bytes_from_ref): Likewise.\n\t(dse_optimize_redundant_stores): Likewise.\n\t(dse_classify_store): Likewise.\n\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n\t* tree-ssa-loop-ch.c (ch_base::copy_headers): Likewise.\n\t* tree-ssa-loop-im.c (LIM_EXPENSIVE): Likewise.\n\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n\t(try_peel_loop): Likewise.\n\t(tree_unroll_loops_completely): Likewise.\n\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Likewise.\n\t(CONSIDER_ALL_CANDIDATES_BOUND): Likewise.\n\t(MAX_CONSIDERED_GROUPS): Likewise.\n\t(ALWAYS_PRUNE_CAND_SET_BOUND): Likewise.\n\t* tree-ssa-loop-manip.c (can_unroll_loop_p): Likewise.\n\t* tree-ssa-loop-niter.c (MAX_ITERATIONS_TO_TRACK): Likewise.\n\t* tree-ssa-loop-prefetch.c (PREFETCH_BLOCK): Likewise.\n\t(L1_CACHE_SIZE_BYTES): Likewise.\n\t(L2_CACHE_SIZE_BYTES): Likewise.\n\t(should_issue_prefetch_p): Likewise.\n\t(schedule_prefetches): Likewise.\n\t(determine_unroll_factor): Likewise.\n\t(volume_of_references): Likewise.\n\t(add_subscript_strides): Likewise.\n\t(self_reuse_distance): Likewise.\n\t(mem_ref_count_reasonable_p): Likewise.\n\t(insn_to_prefetch_ratio_too_small_p): Likewise.\n\t(loop_prefetch_arrays): Likewise.\n\t(tree_ssa_prefetch_arrays): Likewise.\n\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Likewise.\n\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Likewise.\n\t(convert_mult_to_fma): Likewise.\n\t(math_opts_dom_walker::after_dom_children): Likewise.\n\t* tree-ssa-phiopt.c (cond_if_else_store_replacement): Likewise.\n\t(hoist_adjacent_loads): Likewise.\n\t(gate_hoist_loads): Likewise.\n\t* tree-ssa-pre.c (translate_vuse_through_block): Likewise.\n\t(compute_partial_antic_aux): Likewise.\n\t* tree-ssa-reassoc.c (get_reassociation_width): Likewise.\n\t* tree-ssa-sccvn.c (vn_reference_lookup_pieces): Likewise.\n\t(vn_reference_lookup): Likewise.\n\t(do_rpo_vn): Likewise.\n\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr): Likewise.\n\t* tree-ssa-sink.c (select_best_block): Likewise.\n\t* tree-ssa-strlen.c (new_stridx): Likewise.\n\t(new_addr_stridx): Likewise.\n\t(get_range_strlen_dynamic): Likewise.\n\t(class ssa_name_limit_t): Likewise.\n\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Likewise.\n\t(create_variable_info_for_1): Likewise.\n\t(init_alias_vars): Likewise.\n\t* tree-ssa-tail-merge.c (find_clusters_1): Likewise.\n\t(tail_merge_optimize): Likewise.\n\t* tree-ssa-threadbackward.c (thread_jumps::profitable_jump_thread_path): Likewise.\n\t(thread_jumps::fsm_find_control_statement_thread_paths): Likewise.\n\t(thread_jumps::find_jump_threads_backwards): Likewise.\n\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_stmts_at_dest): Likewise.\n\t* tree-ssa-uninit.c (compute_control_dep_chain): Likewise.\n\t* tree-switch-conversion.c (switch_conversion::check_range): Likewise.\n\t(jump_table_cluster::can_be_handled): Likewise.\n\t* tree-switch-conversion.h (jump_table_cluster::case_values_threshold): Likewise.\n\t(SWITCH_CONVERSION_BRANCH_RATIO): Likewise.\n\t(param_switch_conversion_branch_ratio): Likewise.\n\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test): Likewise.\n\t(vect_enhance_data_refs_alignment): Likewise.\n\t(vect_prune_runtime_alias_test_list): Likewise.\n\t* tree-vect-loop.c (vect_analyze_loop_costing): Likewise.\n\t(vect_get_datarefs_in_loop): Likewise.\n\t(vect_analyze_loop): Likewise.\n\t* tree-vect-slp.c (vect_slp_bb): Likewise.\n\t* tree-vectorizer.h: Likewise.\n\t* tree-vrp.c (find_switch_asserts): Likewise.\n\t(vrp_prop::check_mem_ref): Likewise.\n\t* tree.c (wide_int_to_tree_1): Likewise.\n\t(cache_integer_cst): Likewise.\n\t* var-tracking.c (EXPR_USE_DEPTH): Likewise.\n\t(reverse_op): Likewise.\n\t(vt_find_locations): Likewise.\n2019-11-12  Martin Liska  <mliska@suse.cz>\n\n\t* gimple-parser.c (c_parser_parse_gimple_body): Replace old parameter syntax\n\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n\tmacro.\n2019-11-12  Martin Liska  <mliska@suse.cz>\n\n\t* name-lookup.c (namespace_hints::namespace_hints): Replace old parameter syntax\n\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n\tmacro.\n\t* typeck.c (comptypes): Likewise.\n2019-11-12  Martin Liska  <mliska@suse.cz>\n\n\t* lto-partition.c (lto_balanced_map): Replace old parameter syntax\n\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n\tmacro.\n\t* lto.c (do_whole_program_analysis): Likewise.\n\nFrom-SVN: r278085", "tree": {"sha": "9b1290038426396fe9c71c5e3d0b890845146767", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9b1290038426396fe9c71c5e3d0b890845146767"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/028d409252058d88805341a3f6dc0ff1553f5bdc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d409252058d88805341a3f6dc0ff1553f5bdc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/028d409252058d88805341a3f6dc0ff1553f5bdc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/028d409252058d88805341a3f6dc0ff1553f5bdc/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e1792c953ec544e4bc0182b50026b41720fce2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e1792c953ec544e4bc0182b50026b41720fce2e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e1792c953ec544e4bc0182b50026b41720fce2e"}], "stats": {"total": 1699, "additions": 960, "deletions": 739}, "files": [{"sha": "80986936e1bccb42b97ba543a8692ac0cca3cec1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 282, "deletions": 0, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1,3 +1,285 @@\n+2019-11-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* asan.c (asan_sanitize_stack_p): Replace old parameter syntax\n+\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n+\tmacro.\n+\t(asan_sanitize_allocas_p): Likewise.\n+\t(asan_emit_stack_protection): Likewise.\n+\t(asan_protect_global): Likewise.\n+\t(instrument_derefs): Likewise.\n+\t(instrument_builtin_call): Likewise.\n+\t(asan_expand_mark_ifn): Likewise.\n+\t* auto-profile.c (auto_profile): Likewise.\n+\t* bb-reorder.c (copy_bb_p): Likewise.\n+\t(duplicate_computed_gotos): Likewise.\n+\t* builtins.c (inline_expand_builtin_string_cmp): Likewise.\n+\t* cfgcleanup.c (try_crossjump_to_edge): Likewise.\n+\t(try_crossjump_bb): Likewise.\n+\t* cfgexpand.c (defer_stack_allocation): Likewise.\n+\t(stack_protect_classify_type): Likewise.\n+\t(pass_expand::execute): Likewise.\n+\t* cfgloopanal.c (expected_loop_iterations_unbounded): Likewise.\n+\t(estimate_reg_pressure_cost): Likewise.\n+\t* cgraph.c (cgraph_edge::maybe_hot_p): Likewise.\n+\t* combine.c (combine_instructions): Likewise.\n+\t(record_value_for_reg): Likewise.\n+\t* common/config/aarch64/aarch64-common.c (aarch64_option_validate_param): Likewise.\n+\t(aarch64_option_default_params): Likewise.\n+\t* common/config/ia64/ia64-common.c (ia64_option_default_params): Likewise.\n+\t* common/config/powerpcspe/powerpcspe-common.c (rs6000_option_default_params): Likewise.\n+\t* common/config/rs6000/rs6000-common.c (rs6000_option_default_params): Likewise.\n+\t* common/config/sh/sh-common.c (sh_option_default_params): Likewise.\n+\t* config/aarch64/aarch64.c (aarch64_output_probe_stack_range): Likewise.\n+\t(aarch64_allocate_and_probe_stack_space): Likewise.\n+\t(aarch64_expand_epilogue): Likewise.\n+\t(aarch64_override_options_internal): Likewise.\n+\t* config/alpha/alpha.c (alpha_option_override): Likewise.\n+\t* config/arm/arm.c (arm_option_override): Likewise.\n+\t(arm_valid_target_attribute_p): Likewise.\n+\t* config/i386/i386-options.c (ix86_option_override_internal): Likewise.\n+\t* config/i386/i386.c (get_probe_interval): Likewise.\n+\t(ix86_adjust_stack_and_probe_stack_clash): Likewise.\n+\t(ix86_max_noce_ifcvt_seq_cost): Likewise.\n+\t* config/ia64/ia64.c (ia64_adjust_cost): Likewise.\n+\t* config/rs6000/rs6000-logue.c (get_stack_clash_protection_probe_interval): Likewise.\n+\t(get_stack_clash_protection_guard_size): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_option_override_internal): Likewise.\n+\t* config/s390/s390.c (allocate_stack_space): Likewise.\n+\t(s390_emit_prologue): Likewise.\n+\t(s390_option_override_internal): Likewise.\n+\t* config/sparc/sparc.c (sparc_option_override): Likewise.\n+\t* config/visium/visium.c (visium_option_override): Likewise.\n+\t* coverage.c (get_coverage_counts): Likewise.\n+\t(coverage_compute_profile_id): Likewise.\n+\t(coverage_begin_function): Likewise.\n+\t(coverage_end_function): Likewise.\n+\t* cse.c (cse_find_path): Likewise.\n+\t(cse_extended_basic_block): Likewise.\n+\t(cse_main): Likewise.\n+\t* cselib.c (cselib_invalidate_mem): Likewise.\n+\t* dse.c (dse_step1): Likewise.\n+\t* emit-rtl.c (set_new_first_and_last_insn): Likewise.\n+\t(get_max_insn_count): Likewise.\n+\t(make_debug_insn_raw): Likewise.\n+\t(init_emit): Likewise.\n+\t* explow.c (compute_stack_clash_protection_loop_data): Likewise.\n+\t* final.c (compute_alignments): Likewise.\n+\t* fold-const.c (fold_range_test): Likewise.\n+\t(fold_truth_andor): Likewise.\n+\t(tree_single_nonnegative_warnv_p): Likewise.\n+\t(integer_valued_real_single_p): Likewise.\n+\t* gcse.c (want_to_gcse_p): Likewise.\n+\t(prune_insertions_deletions): Likewise.\n+\t(hoist_code): Likewise.\n+\t(gcse_or_cprop_is_too_expensive): Likewise.\n+\t* ggc-common.c: Likewise.\n+\t* ggc-page.c (ggc_collect): Likewise.\n+\t* gimple-loop-interchange.cc (MAX_NUM_STMT): Likewise.\n+\t(MAX_DATAREFS): Likewise.\n+\t(OUTER_STRIDE_RATIO): Likewise.\n+\t* gimple-loop-jam.c (tree_loop_unroll_and_jam): Likewise.\n+\t* gimple-loop-versioning.cc (loop_versioning::max_insns_for_loop): Likewise.\n+\t* gimple-ssa-split-paths.c (is_feasible_trace): Likewise.\n+\t* gimple-ssa-store-merging.c (imm_store_chain_info::try_coalesce_bswap): Likewise.\n+\t(imm_store_chain_info::coalesce_immediate_stores): Likewise.\n+\t(imm_store_chain_info::output_merged_store): Likewise.\n+\t(pass_store_merging::process_store): Likewise.\n+\t* gimple-ssa-strength-reduction.c (find_basis_for_base_expr): Likewise.\n+\t* graphite-isl-ast-to-gimple.c (class translate_isl_ast_to_gimple): Likewise.\n+\t(scop_to_isl_ast): Likewise.\n+\t* graphite-optimize-isl.c (get_schedule_for_node_st): Likewise.\n+\t(optimize_isl): Likewise.\n+\t* graphite-scop-detection.c (build_scops): Likewise.\n+\t* haifa-sched.c (set_modulo_params): Likewise.\n+\t(rank_for_schedule): Likewise.\n+\t(model_add_to_worklist): Likewise.\n+\t(model_promote_insn): Likewise.\n+\t(model_choose_insn): Likewise.\n+\t(queue_to_ready): Likewise.\n+\t(autopref_multipass_dfa_lookahead_guard): Likewise.\n+\t(schedule_block): Likewise.\n+\t(sched_init): Likewise.\n+\t* hsa-gen.c (init_prologue): Likewise.\n+\t* ifcvt.c (bb_ok_for_noce_convert_multiple_sets): Likewise.\n+\t(cond_move_process_if_block): Likewise.\n+\t* ipa-cp.c (ipcp_lattice::add_value): Likewise.\n+\t(merge_agg_lats_step): Likewise.\n+\t(devirtualization_time_bonus): Likewise.\n+\t(hint_time_bonus): Likewise.\n+\t(incorporate_penalties): Likewise.\n+\t(good_cloning_opportunity_p): Likewise.\n+\t(ipcp_propagate_stage): Likewise.\n+\t* ipa-fnsummary.c (decompose_param_expr): Likewise.\n+\t(set_switch_stmt_execution_predicate): Likewise.\n+\t(analyze_function_body): Likewise.\n+\t(compute_fn_summary): Likewise.\n+\t* ipa-inline-analysis.c (estimate_growth): Likewise.\n+\t* ipa-inline.c (caller_growth_limits): Likewise.\n+\t(inline_insns_single): Likewise.\n+\t(inline_insns_auto): Likewise.\n+\t(can_inline_edge_by_limits_p): Likewise.\n+\t(want_early_inline_function_p): Likewise.\n+\t(big_speedup_p): Likewise.\n+\t(want_inline_small_function_p): Likewise.\n+\t(want_inline_self_recursive_call_p): Likewise.\n+\t(edge_badness): Likewise.\n+\t(recursive_inlining): Likewise.\n+\t(compute_max_insns): Likewise.\n+\t(early_inliner): Likewise.\n+\t* ipa-polymorphic-call.c (csftc_abort_walking_p): Likewise.\n+\t* ipa-profile.c (ipa_profile): Likewise.\n+\t* ipa-prop.c (determine_known_aggregate_parts): Likewise.\n+\t(ipa_analyze_node): Likewise.\n+\t(ipcp_transform_function): Likewise.\n+\t* ipa-split.c (consider_split): Likewise.\n+\t* ipa-sra.c (allocate_access): Likewise.\n+\t(process_scan_results): Likewise.\n+\t(ipa_sra_summarize_function): Likewise.\n+\t(pull_accesses_from_callee): Likewise.\n+\t* ira-build.c (loop_compare_func): Likewise.\n+\t(mark_loops_for_removal): Likewise.\n+\t* ira-conflicts.c (build_conflict_bit_table): Likewise.\n+\t* loop-doloop.c (doloop_optimize): Likewise.\n+\t* loop-invariant.c (gain_for_invariant): Likewise.\n+\t(move_loop_invariants): Likewise.\n+\t* loop-unroll.c (decide_unroll_constant_iterations): Likewise.\n+\t(decide_unroll_runtime_iterations): Likewise.\n+\t(decide_unroll_stupid): Likewise.\n+\t(expand_var_during_unrolling): Likewise.\n+\t* lra-assigns.c (spill_for): Likewise.\n+\t* lra-constraints.c (EBB_PROBABILITY_CUTOFF): Likewise.\n+\t* modulo-sched.c (sms_schedule): Likewise.\n+\t(DFA_HISTORY): Likewise.\n+\t* opts.c (default_options_optimization): Likewise.\n+\t(finish_options): Likewise.\n+\t(common_handle_option): Likewise.\n+\t* postreload-gcse.c (eliminate_partially_redundant_load): Likewise.\n+\t(if): Likewise.\n+\t* predict.c (get_hot_bb_threshold): Likewise.\n+\t(maybe_hot_count_p): Likewise.\n+\t(probably_never_executed): Likewise.\n+\t(predictable_edge_p): Likewise.\n+\t(predict_loops): Likewise.\n+\t(expr_expected_value_1): Likewise.\n+\t(tree_predict_by_opcode): Likewise.\n+\t(handle_missing_profiles): Likewise.\n+\t* reload.c (find_equiv_reg): Likewise.\n+\t* reorg.c (redundant_insn): Likewise.\n+\t* resource.c (mark_target_live_regs): Likewise.\n+\t(incr_ticks_for_insn): Likewise.\n+\t* sanopt.c (pass_sanopt::execute): Likewise.\n+\t* sched-deps.c (sched_analyze_1): Likewise.\n+\t(sched_analyze_2): Likewise.\n+\t(sched_analyze_insn): Likewise.\n+\t(deps_analyze_insn): Likewise.\n+\t* sched-ebb.c (schedule_ebbs): Likewise.\n+\t* sched-rgn.c (find_single_block_region): Likewise.\n+\t(too_large): Likewise.\n+\t(haifa_find_rgns): Likewise.\n+\t(extend_rgns): Likewise.\n+\t(new_ready): Likewise.\n+\t(schedule_region): Likewise.\n+\t(sched_rgn_init): Likewise.\n+\t* sel-sched-ir.c (make_region_from_loop): Likewise.\n+\t* sel-sched-ir.h (MAX_WS): Likewise.\n+\t* sel-sched.c (process_pipelined_exprs): Likewise.\n+\t(sel_setup_region_sched_flags): Likewise.\n+\t* shrink-wrap.c (try_shrink_wrapping): Likewise.\n+\t* targhooks.c (default_max_noce_ifcvt_seq_cost): Likewise.\n+\t* toplev.c (print_version): Likewise.\n+\t(process_options): Likewise.\n+\t* tracer.c (tail_duplicate): Likewise.\n+\t* trans-mem.c (tm_log_add): Likewise.\n+\t* tree-chrec.c (chrec_fold_plus_1): Likewise.\n+\t* tree-data-ref.c (split_constant_offset): Likewise.\n+\t(compute_all_dependences): Likewise.\n+\t* tree-if-conv.c (MAX_PHI_ARG_NUM): Likewise.\n+\t* tree-inline.c (remap_gimple_stmt): Likewise.\n+\t* tree-loop-distribution.c (MAX_DATAREFS_NUM): Likewise.\n+\t* tree-parloops.c (MIN_PER_THREAD): Likewise.\n+\t(create_parallel_loop): Likewise.\n+\t* tree-predcom.c (determine_unroll_factor): Likewise.\n+\t* tree-scalar-evolution.c (instantiate_scev_r): Likewise.\n+\t* tree-sra.c (analyze_all_variable_accesses): Likewise.\n+\t* tree-ssa-ccp.c (fold_builtin_alloca_with_align): Likewise.\n+\t* tree-ssa-dse.c (setup_live_bytes_from_ref): Likewise.\n+\t(dse_optimize_redundant_stores): Likewise.\n+\t(dse_classify_store): Likewise.\n+\t* tree-ssa-ifcombine.c (ifcombine_ifandif): Likewise.\n+\t* tree-ssa-loop-ch.c (ch_base::copy_headers): Likewise.\n+\t* tree-ssa-loop-im.c (LIM_EXPENSIVE): Likewise.\n+\t* tree-ssa-loop-ivcanon.c (try_unroll_loop_completely): Likewise.\n+\t(try_peel_loop): Likewise.\n+\t(tree_unroll_loops_completely): Likewise.\n+\t* tree-ssa-loop-ivopts.c (avg_loop_niter): Likewise.\n+\t(CONSIDER_ALL_CANDIDATES_BOUND): Likewise.\n+\t(MAX_CONSIDERED_GROUPS): Likewise.\n+\t(ALWAYS_PRUNE_CAND_SET_BOUND): Likewise.\n+\t* tree-ssa-loop-manip.c (can_unroll_loop_p): Likewise.\n+\t* tree-ssa-loop-niter.c (MAX_ITERATIONS_TO_TRACK): Likewise.\n+\t* tree-ssa-loop-prefetch.c (PREFETCH_BLOCK): Likewise.\n+\t(L1_CACHE_SIZE_BYTES): Likewise.\n+\t(L2_CACHE_SIZE_BYTES): Likewise.\n+\t(should_issue_prefetch_p): Likewise.\n+\t(schedule_prefetches): Likewise.\n+\t(determine_unroll_factor): Likewise.\n+\t(volume_of_references): Likewise.\n+\t(add_subscript_strides): Likewise.\n+\t(self_reuse_distance): Likewise.\n+\t(mem_ref_count_reasonable_p): Likewise.\n+\t(insn_to_prefetch_ratio_too_small_p): Likewise.\n+\t(loop_prefetch_arrays): Likewise.\n+\t(tree_ssa_prefetch_arrays): Likewise.\n+\t* tree-ssa-loop-unswitch.c (tree_unswitch_single_loop): Likewise.\n+\t* tree-ssa-math-opts.c (gimple_expand_builtin_pow): Likewise.\n+\t(convert_mult_to_fma): Likewise.\n+\t(math_opts_dom_walker::after_dom_children): Likewise.\n+\t* tree-ssa-phiopt.c (cond_if_else_store_replacement): Likewise.\n+\t(hoist_adjacent_loads): Likewise.\n+\t(gate_hoist_loads): Likewise.\n+\t* tree-ssa-pre.c (translate_vuse_through_block): Likewise.\n+\t(compute_partial_antic_aux): Likewise.\n+\t* tree-ssa-reassoc.c (get_reassociation_width): Likewise.\n+\t* tree-ssa-sccvn.c (vn_reference_lookup_pieces): Likewise.\n+\t(vn_reference_lookup): Likewise.\n+\t(do_rpo_vn): Likewise.\n+\t* tree-ssa-scopedtables.c (avail_exprs_stack::lookup_avail_expr): Likewise.\n+\t* tree-ssa-sink.c (select_best_block): Likewise.\n+\t* tree-ssa-strlen.c (new_stridx): Likewise.\n+\t(new_addr_stridx): Likewise.\n+\t(get_range_strlen_dynamic): Likewise.\n+\t(class ssa_name_limit_t): Likewise.\n+\t* tree-ssa-structalias.c (push_fields_onto_fieldstack): Likewise.\n+\t(create_variable_info_for_1): Likewise.\n+\t(init_alias_vars): Likewise.\n+\t* tree-ssa-tail-merge.c (find_clusters_1): Likewise.\n+\t(tail_merge_optimize): Likewise.\n+\t* tree-ssa-threadbackward.c (thread_jumps::profitable_jump_thread_path): Likewise.\n+\t(thread_jumps::fsm_find_control_statement_thread_paths): Likewise.\n+\t(thread_jumps::find_jump_threads_backwards): Likewise.\n+\t* tree-ssa-threadedge.c (record_temporary_equivalences_from_stmts_at_dest): Likewise.\n+\t* tree-ssa-uninit.c (compute_control_dep_chain): Likewise.\n+\t* tree-switch-conversion.c (switch_conversion::check_range): Likewise.\n+\t(jump_table_cluster::can_be_handled): Likewise.\n+\t* tree-switch-conversion.h (jump_table_cluster::case_values_threshold): Likewise.\n+\t(SWITCH_CONVERSION_BRANCH_RATIO): Likewise.\n+\t(param_switch_conversion_branch_ratio): Likewise.\n+\t* tree-vect-data-refs.c (vect_mark_for_runtime_alias_test): Likewise.\n+\t(vect_enhance_data_refs_alignment): Likewise.\n+\t(vect_prune_runtime_alias_test_list): Likewise.\n+\t* tree-vect-loop.c (vect_analyze_loop_costing): Likewise.\n+\t(vect_get_datarefs_in_loop): Likewise.\n+\t(vect_analyze_loop): Likewise.\n+\t* tree-vect-slp.c (vect_slp_bb): Likewise.\n+\t* tree-vectorizer.h: Likewise.\n+\t* tree-vrp.c (find_switch_asserts): Likewise.\n+\t(vrp_prop::check_mem_ref): Likewise.\n+\t* tree.c (wide_int_to_tree_1): Likewise.\n+\t(cache_integer_cst): Likewise.\n+\t* var-tracking.c (EXPR_USE_DEPTH): Likewise.\n+\t(reverse_op): Likewise.\n+\t(vt_find_locations): Likewise.\n+\n 2019-11-12  Martin Liska  <mliska@suse.cz>\n \n \t* Makefile.in: Include params.opt."}, {"sha": "5ae669429415bdd73cbce2918b88c8152f0e053d", "filename": "gcc/asan.c", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fasan.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fasan.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fasan.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -309,13 +309,13 @@ asan_mark_p (gimple *stmt, enum asan_mark_flags flag)\n bool\n asan_sanitize_stack_p (void)\n {\n-  return (sanitize_flags_p (SANITIZE_ADDRESS) && ASAN_STACK);\n+  return (sanitize_flags_p (SANITIZE_ADDRESS) && param_asan_stack);\n }\n \n bool\n asan_sanitize_allocas_p (void)\n {\n-  return (asan_sanitize_stack_p () && ASAN_PROTECT_ALLOCAS);\n+  return (asan_sanitize_stack_p () && param_asan_protect_allocas);\n }\n \n /* Checks whether section SEC should be sanitized.  */\n@@ -1429,7 +1429,7 @@ asan_emit_stack_protection (rtx base, rtx pbase, unsigned int alignb,\n \n   /* Emit the prologue sequence.  */\n   if (asan_frame_size > 32 && asan_frame_size <= 65536 && pbase\n-      && ASAN_USE_AFTER_RETURN)\n+      && param_asan_use_after_return)\n     {\n       use_after_return_class = floor_log2 (asan_frame_size - 1) - 5;\n       /* __asan_stack_malloc_N guarantees alignment\n@@ -1750,7 +1750,7 @@ is_odr_indicator (tree decl)\n bool\n asan_protect_global (tree decl, bool ignore_decl_rtl_set_p)\n {\n-  if (!ASAN_GLOBALS)\n+  if (!param_asan_globals)\n     return false;\n \n   rtx rtl, symbol;\n@@ -2190,9 +2190,9 @@ static void\n instrument_derefs (gimple_stmt_iterator *iter, tree t,\n \t\t   location_t location, bool is_store)\n {\n-  if (is_store && !ASAN_INSTRUMENT_WRITES)\n+  if (is_store && !param_asan_instrument_writes)\n     return;\n-  if (!is_store && !ASAN_INSTRUMENT_READS)\n+  if (!is_store && !param_asan_instrument_reads)\n     return;\n \n   tree type, base;\n@@ -2253,7 +2253,7 @@ instrument_derefs (gimple_stmt_iterator *iter, tree t,\n     {\n       if (DECL_THREAD_LOCAL_P (inner))\n \treturn;\n-      if (!ASAN_GLOBALS && is_global_var (inner))\n+      if (!param_asan_globals && is_global_var (inner))\n         return;\n       if (!TREE_STATIC (inner))\n \t{\n@@ -2346,7 +2346,7 @@ instrument_mem_region_access (tree base, tree len,\n static bool\n instrument_builtin_call (gimple_stmt_iterator *iter)\n {\n-  if (!ASAN_MEMINTRIN)\n+  if (!param_asan_memintrin)\n     return false;\n \n   bool iter_advanced_p = false;\n@@ -3219,7 +3219,8 @@ asan_expand_mark_ifn (gimple_stmt_iterator *iter)\n   tree base_addr = gimple_assign_lhs (g);\n \n   /* Generate direct emission if size_in_bytes is small.  */\n-  if (size_in_bytes <= ASAN_PARAM_USE_AFTER_SCOPE_DIRECT_EMISSION_THRESHOLD)\n+  if (size_in_bytes\n+      <= (unsigned)param_use_after_scope_direct_emission_threshold)\n     {\n       const unsigned HOST_WIDE_INT shadow_size\n \t= shadow_mem_size (size_in_bytes);"}, {"sha": "92e980f68a204cd598e65aa80badbbdda48c5f95", "filename": "gcc/auto-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fauto-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fauto-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fauto-profile.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1629,7 +1629,7 @@ auto_profile (void)\n        function before annotation, so the profile inside bar@loc_foo2\n        will be useful.  */\n     autofdo::stmt_set promoted_stmts;\n-    for (int i = 0; i < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS); i++)\n+    for (int i = 0; i < param_early_inliner_max_iterations; i++)\n       {\n         if (!flag_value_profile_transformations\n             || !autofdo::afdo_vpt_for_early_inline (&promoted_stmts))"}, {"sha": "6a85c2a7fc0e1ffca0d22a50c2630d3269ccb02d", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1371,7 +1371,7 @@ copy_bb_p (const_basic_block bb, int code_may_grow)\n     return false;\n \n   if (code_may_grow && optimize_bb_for_speed_p (bb))\n-    max_size *= PARAM_VALUE (PARAM_MAX_GROW_COPY_BB_INSNS);\n+    max_size *= param_max_grow_copy_bb_insns;\n \n   FOR_BB_INSNS (bb, insn)\n     {\n@@ -2751,7 +2751,7 @@ duplicate_computed_gotos (function *fun)\n \n   /* Never copy a block larger than this.  */\n   int max_size\n-    = uncond_jump_length * PARAM_VALUE (PARAM_MAX_GOTO_DUPLICATION_INSNS);\n+    = uncond_jump_length * param_max_goto_duplication_insns;\n \n   bool changed = false;\n "}, {"sha": "68baeb9bbe9dfc4f64079c532592d78b07ace3b0", "filename": "gcc/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -7214,7 +7214,7 @@ inline_expand_builtin_string_cmp (tree exp, rtx target)\n   /* If the length of the comparision is larger than the threshold,\n      do nothing.  */\n   if (length > (unsigned HOST_WIDE_INT)\n-\t       PARAM_VALUE (BUILTIN_STRING_CMP_INLINE_LENGTH))\n+\t       param_builtin_string_cmp_inline_length)\n     return NULL_RTX;\n \n   machine_mode mode = TYPE_MODE (TREE_TYPE (exp));"}, {"sha": "abd104824ed4b97649976f134e4db7b32c4baf5a", "filename": "gcc/c/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2FChangeLog?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1,3 +1,9 @@\n+2019-11-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* gimple-parser.c (c_parser_parse_gimple_body): Replace old parameter syntax\n+\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n+\tmacro.\n+\n 2019-11-12  Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Frederik Harwath  <frederik@codesourcery.com>\n "}, {"sha": "e40cfa2ec01af4e3fe199d7bec6d33bc21a8de2b", "filename": "gcc/c/gimple-parser.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fc%2Fgimple-parser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fc%2Fgimple-parser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc%2Fgimple-parser.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -354,7 +354,7 @@ c_parser_parse_gimple_body (c_parser *cparser, char *gimple_pass,\n   if (cfun->curr_properties & PROP_cfg)\n     {\n       ENTRY_BLOCK_PTR_FOR_FN (cfun)->count = entry_bb_count;\n-      gcov_type t = PARAM_VALUE (PARAM_GIMPLE_FE_COMPUTED_HOT_BB_THRESHOLD);\n+      gcov_type t = param_gimple_fe_computed_hot_bb_threshold;\n       set_hot_bb_threshold (t);\n       update_max_bb_count ();\n       cgraph_node::get_create (cfun->decl);"}, {"sha": "7b1dd245487eedc01171891f4648a4e31fb3f2b5", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2022,7 +2022,7 @@ try_crossjump_to_edge (int mode, edge e1, edge e2,\n      of matching instructions or the 'from' block was totally matched\n      (such that its predecessors will hopefully be redirected and the\n      block removed).  */\n-  if ((nmatch < PARAM_VALUE (PARAM_MIN_CROSSJUMP_INSNS))\n+  if ((nmatch < param_min_crossjump_insns)\n       && (newpos1 != BB_HEAD (src1)))\n     return false;\n \n@@ -2215,7 +2215,7 @@ try_crossjump_bb (int mode, basic_block bb)\n      a block that falls through into BB, as that adds no branches to the\n      program.  We'll try that combination first.  */\n   fallthru = NULL;\n-  max = PARAM_VALUE (PARAM_MAX_CROSSJUMP_EDGES);\n+  max = param_max_crossjump_edges;\n \n   if (EDGE_COUNT (bb->preds) > max)\n     return false;"}, {"sha": "5fed0738211f8017e22a1d46d903c9ff11fe76f5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1548,7 +1548,7 @@ defer_stack_allocation (tree var, bool toplevel)\n   bool smallish\n     = (poly_int_tree_p (size_unit, &size)\n        && (estimated_poly_value (size)\n-\t   < PARAM_VALUE (PARAM_MIN_SIZE_FOR_STACK_SHARING)));\n+\t   < param_min_size_for_stack_sharing));\n \n   /* If stack protection is enabled, *all* stack variables must be deferred,\n      so that we can re-order the strings to the top of the frame.\n@@ -1788,7 +1788,7 @@ stack_protect_classify_type (tree type)\n \t  || t == signed_char_type_node\n \t  || t == unsigned_char_type_node)\n \t{\n-\t  unsigned HOST_WIDE_INT max = PARAM_VALUE (PARAM_SSP_BUFFER_SIZE);\n+\t  unsigned HOST_WIDE_INT max = param_ssp_buffer_size;\n \t  unsigned HOST_WIDE_INT len;\n \n \t  if (!TYPE_SIZE_UNIT (type)\n@@ -6435,7 +6435,7 @@ pass_expand::execute (function *fun)\n \twarning (OPT_Wstack_protector,\n \t\t \"stack protector not protecting function: \"\n \t\t \"all local arrays are less than %d bytes long\",\n-\t\t (int) PARAM_VALUE (PARAM_SSP_BUFFER_SIZE));\n+\t\t (int) param_ssp_buffer_size);\n     }\n \n   /* Set up parameters and prepare for return, for the function.  */\n@@ -6545,7 +6545,7 @@ pass_expand::execute (function *fun)\n \n   /* If the function has too many markers, drop them while expanding.  */\n   if (cfun->debug_marker_count\n-      >= PARAM_VALUE (PARAM_MAX_DEBUG_MARKER_COUNT))\n+      >= param_max_debug_marker_count)\n     cfun->debug_nonbind_markers = false;\n \n   lab_rtx_for_bb = new hash_map<basic_block, rtx_code_label *>;"}, {"sha": "84516efcfb6d32be15932a004caae3e84be8deb8", "filename": "gcc/cfgloopanal.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgloopanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcfgloopanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopanal.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -256,7 +256,7 @@ expected_loop_iterations_unbounded (const class loop *loop,\n     {\n       if (by_profile_only)\n \treturn -1;\n-      expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+      expected = param_avg_loop_niter;\n     }\n   else if (loop->latch && (loop->latch->count.initialized_p ()\n \t\t\t   || loop->header->count.initialized_p ()))\n@@ -274,7 +274,7 @@ expected_loop_iterations_unbounded (const class loop *loop,\n \t{\n           if (by_profile_only)\n \t    return -1;\n-\t  expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+\t  expected = param_avg_loop_niter;\n \t}\n       else if (!count_in.nonzero_p ())\n \t{\n@@ -295,7 +295,7 @@ expected_loop_iterations_unbounded (const class loop *loop,\n     {\n       if (by_profile_only)\n \treturn -1;\n-      expected = PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+      expected = param_avg_loop_niter;\n     }\n \n   if (!by_profile_only)\n@@ -427,7 +427,7 @@ estimate_reg_pressure_cost (unsigned n_new, unsigned n_old, bool speed,\n \n   if (optimize && (flag_ira_region == IRA_REGION_ALL\n \t\t   || flag_ira_region == IRA_REGION_MIXED)\n-      && number_of_loops (cfun) <= (unsigned) IRA_MAX_LOOPS_NUM)\n+      && number_of_loops (cfun) <= (unsigned) param_ira_max_loops_num)\n     /* IRA regional allocation deals with high register pressure\n        better.  So decrease the cost (to do more accurate the cost\n        calculation for IRA, we need to know how many registers lives"}, {"sha": "5497235b7d43b95d976f262ba554d932e6f16c2d", "filename": "gcc/cgraph.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2707,7 +2707,7 @@ cgraph_edge::maybe_hot_p (void)\n       if (count.apply_scale (2, 1) < where->count.apply_scale (3, 1))\n \treturn false;\n     }\n-  else if (count.apply_scale (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION), 1)\n+  else if (count.apply_scale (param_hot_bb_frequency_fraction , 1)\n \t   < where->count)\n     return false;\n   return true;"}, {"sha": "ae3bc468910d1b2edc7794471fa3c49ca0be2791", "filename": "gcc/combine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1251,7 +1251,7 @@ combine_instructions (rtx_insn *f, unsigned int nregs)\n   init_reg_last ();\n   setup_incoming_promotions (first);\n   last_bb = ENTRY_BLOCK_PTR_FOR_FN (cfun);\n-  int max_combine = PARAM_VALUE (PARAM_MAX_COMBINE_INSNS);\n+  int max_combine = param_max_combine_insns;\n \n   FOR_EACH_BB_FN (this_basic_block, cfun)\n     {\n@@ -13282,7 +13282,7 @@ record_value_for_reg (rtx reg, rtx_insn *insn, rtx value)\n \t    {\n \t      /* If there are two or more occurrences of REG in VALUE,\n \t\t prevent the value from growing too much.  */\n-\t      if (count_rtxs (tem) > MAX_LAST_VALUE_RTL)\n+\t      if (count_rtxs (tem) > param_max_last_value_rtl)\n \t\ttem = gen_rtx_CLOBBER (GET_MODE (tem), const0_rtx);\n \t    }\n "}, {"sha": "adb3ff71af8e3094eb66bf4e02023a3dd41d98d3", "filename": "gcc/common/config/aarch64/aarch64-common.c", "status": "modified", "additions": 6, "deletions": 9, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Faarch64%2Faarch64-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -73,7 +73,7 @@ static bool\n aarch64_option_validate_param (const int value, const int param)\n {\n   /* Check that both parameters are the same.  */\n-  if (param == (int) PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE)\n+  if (param == param_stack_clash_protection_guard_size)\n     {\n       if (value != 12 && value != 16)\n \t{\n@@ -93,18 +93,15 @@ static void\n aarch64_option_default_params (void)\n {\n   /* We assume the guard page is 64k.  */\n-  int index = (int) PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE;\n-  set_default_param_value (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE,\n-\t\t\t   DEFAULT_STK_CLASH_GUARD_SIZE == 0\n-\t\t\t     ? 16 : DEFAULT_STK_CLASH_GUARD_SIZE);\n+  int index = (int) param_stack_clash_protection_guard_size;\n+  param_stack_clash_protection_guard_size\n+    = (DEFAULT_STK_CLASH_GUARD_SIZE == 0 ? 16 : DEFAULT_STK_CLASH_GUARD_SIZE);\n \n-  int guard_size\n-    = default_param_value (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+  int guard_size = param_stack_clash_protection_guard_size;\n \n   /* Set the interval parameter to be the same as the guard size.  This way the\n      mid-end code does the right thing for us.  */\n-  set_default_param_value (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL,\n-\t\t\t   guard_size);\n+  param_stack_clash_protection_probe_interval = guard_size;\n \n   /* Validate the options.  */\n   aarch64_option_validate_param (guard_size, index);"}, {"sha": "0a187160fd246193946d8469c29d59ce798915e4", "filename": "gcc/common/config/ia64/ia64-common.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fia64%2Fia64-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fia64%2Fia64-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fia64%2Fia64-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -88,13 +88,13 @@ static void\n ia64_option_default_params (void)\n {\n   /* Let the scheduler form additional regions.  */\n-  set_default_param_value (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS, 2);\n+  param_max_sched_extend_regions_iters = 2;\n \n   /* Set the default values for cache-related parameters.  */\n-  set_default_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 6);\n-  set_default_param_value (PARAM_L1_CACHE_LINE_SIZE, 32);\n+  param_simultaneous_prefetches = 6;\n+  param_l1_cache_line_size = 32;\n \n-  set_default_param_value (PARAM_SCHED_MEM_TRUE_DEP_COST, 4);\n+  param_sched_mem_true_dep_cost = 4;\n }\n \n #undef TARGET_OPTION_OPTIMIZATION_TABLE"}, {"sha": "7043a4bda31d078aacbff9abc36790e848a915ac", "filename": "gcc/common/config/powerpcspe/powerpcspe-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fpowerpcspe%2Fpowerpcspe-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -57,7 +57,7 @@ static void\n rs6000_option_default_params (void)\n {\n   /* Double growth factor to counter reduced min jump length.  */\n-  set_default_param_value (PARAM_MAX_GROW_COPY_BB_INSNS, 16);\n+  param_max_grow_copy_bb_insns = 16;\n }\n \n /* If not otherwise specified by a target, make 'long double' equivalent to"}, {"sha": "1d39912443b61092c2e93fafaae7a0feaef2ca4d", "filename": "gcc/common/config/rs6000/rs6000-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Frs6000%2Frs6000-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -76,7 +76,7 @@ static void\n rs6000_option_default_params (void)\n {\n   /* Double growth factor to counter reduced min jump length.  */\n-  set_default_param_value (PARAM_MAX_GROW_COPY_BB_INSNS, 16);\n+  param_max_grow_copy_bb_insns = 16;\n }\n \n /* If not otherwise specified by a target, make 'long double' equivalent to"}, {"sha": "e6ecc3a632a0ccc3d322e32b7a90d61e8448562f", "filename": "gcc/common/config/sh/sh-common.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fsh%2Fsh-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -149,7 +149,7 @@ sh_handle_option (struct gcc_options *opts,\n static void\n sh_option_default_params (void)\n {\n-  set_default_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 2);\n+  param_simultaneous_prefetches = 2;\n }\n \n #undef TARGET_OPTION_OPTIMIZATION_TABLE"}, {"sha": "c4783861c5d7db5de85854b6160568d2d549a2d4", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 34, "deletions": 45, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5589,7 +5589,7 @@ aarch64_output_probe_stack_range (rtx reg1, rtx reg2)\n   ASM_OUTPUT_INTERNAL_LABEL (asm_out_file, loop_lab);\n \n   HOST_WIDE_INT stack_clash_probe_interval\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+    = 1 << param_stack_clash_protection_guard_size;\n \n   /* TEST_ADDR = TEST_ADDR + PROBE_INTERVAL.  */\n   xops[0] = reg1;\n@@ -6842,7 +6842,7 @@ aarch64_allocate_and_probe_stack_space (rtx temp1, rtx temp2,\n \t\t\t\t\tbool final_adjustment_p)\n {\n   HOST_WIDE_INT guard_size\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+    = 1 << param_stack_clash_protection_guard_size;\n   HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n   HOST_WIDE_INT min_probe_threshold\n     = (final_adjustment_p\n@@ -7364,7 +7364,7 @@ aarch64_expand_epilogue (bool for_sibcall)\n      for each allocation.  For stack clash we are in a usable state if\n      the adjustment is less than GUARD_SIZE - GUARD_USED_BY_CALLER.  */\n   HOST_WIDE_INT guard_size\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+    = 1 << param_stack_clash_protection_guard_size;\n   HOST_WIDE_INT guard_used_by_caller = STACK_CLASH_CALLER_GUARD;\n \n   /* We can re-use the registers when:\n@@ -13306,73 +13306,62 @@ aarch64_override_options_internal (struct gcc_options *opts)\n \n   /* We don't mind passing in global_options_set here as we don't use\n      the *options_set structs anyway.  */\n-  maybe_set_param_value (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH,\n-\t\t\t queue_depth,\n-\t\t\t opts->x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t       param_sched_autopref_queue_depth, queue_depth);\n \n   /* Set up parameters to be used in prefetching algorithm.  Do not\n      override the defaults unless we are tuning for a core we have\n      researched values for.  */\n   if (aarch64_tune_params.prefetch->num_slots > 0)\n-    maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t   aarch64_tune_params.prefetch->num_slots,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_simultaneous_prefetches,\n+\t\t\t aarch64_tune_params.prefetch->num_slots);\n   if (aarch64_tune_params.prefetch->l1_cache_size >= 0)\n-    maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n-\t\t\t   aarch64_tune_params.prefetch->l1_cache_size,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_l1_cache_size,\n+\t\t\t aarch64_tune_params.prefetch->l1_cache_size);\n   if (aarch64_tune_params.prefetch->l1_cache_line_size >= 0)\n-    maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t   aarch64_tune_params.prefetch->l1_cache_line_size,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_l1_cache_line_size,\n+\t\t\t aarch64_tune_params.prefetch->l1_cache_line_size);\n   if (aarch64_tune_params.prefetch->l2_cache_size >= 0)\n-    maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n-\t\t\t   aarch64_tune_params.prefetch->l2_cache_size,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_l2_cache_size,\n+\t\t\t aarch64_tune_params.prefetch->l2_cache_size);\n   if (!aarch64_tune_params.prefetch->prefetch_dynamic_strides)\n-    maybe_set_param_value (PARAM_PREFETCH_DYNAMIC_STRIDES,\n-\t\t\t   0,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_prefetch_dynamic_strides, 0);\n   if (aarch64_tune_params.prefetch->minimum_stride >= 0)\n-    maybe_set_param_value (PARAM_PREFETCH_MINIMUM_STRIDE,\n-\t\t\t   aarch64_tune_params.prefetch->minimum_stride,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t\t param_prefetch_minimum_stride,\n+\t\t\t aarch64_tune_params.prefetch->minimum_stride);\n \n   /* Use the alternative scheduling-pressure algorithm by default.  */\n-  maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, SCHED_PRESSURE_MODEL,\n-\t\t\t opts->x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t       param_sched_pressure_algorithm,\n+\t\t       SCHED_PRESSURE_MODEL);\n \n   /* If the user hasn't changed it via configure then set the default to 64 KB\n      for the backend.  */\n-  maybe_set_param_value (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE,\n-\t\t\t DEFAULT_STK_CLASH_GUARD_SIZE == 0\n-\t\t\t   ? 16 : DEFAULT_STK_CLASH_GUARD_SIZE,\n-\t\t\t opts->x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t       param_stack_clash_protection_guard_size,\n+\t\t       (DEFAULT_STK_CLASH_GUARD_SIZE == 0\n+\t\t\t? 16 : DEFAULT_STK_CLASH_GUARD_SIZE));\n \n   /* Validate the guard size.  */\n-  int guard_size = PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+  int guard_size = param_stack_clash_protection_guard_size;\n \n   /* Enforce that interval is the same size as size so the mid-end does the\n      right thing.  */\n-  maybe_set_param_value (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL,\n-\t\t\t guard_size,\n-\t\t\t opts->x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (opts, &global_options_set,\n+\t\t       param_stack_clash_protection_probe_interval,\n+\t\t       guard_size);\n \n   /* The maybe_set calls won't update the value if the user has explicitly set\n      one.  Which means we need to validate that probing interval and guard size\n      are equal.  */\n   int probe_interval\n-    = PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+    = param_stack_clash_protection_probe_interval;\n   if (guard_size != probe_interval)\n     error (\"stack clash guard size %<%d%> must be equal to probing interval \"\n \t   \"%<%d%>\", guard_size, probe_interval);"}, {"sha": "8f389ead32d16d7fad215fe17005a8e718c6844f", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -68,6 +68,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"builtins.h\"\n #include \"rtl-iter.h\"\n #include \"flags.h\"\n+#include \"opts.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -484,17 +485,14 @@ alpha_option_override (void)\n     }\n \n   if (line_size)\n-    maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE, line_size,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_l1_cache_line_size, line_size);\n   if (l1_size)\n-    maybe_set_param_value (PARAM_L1_CACHE_SIZE, l1_size,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_l1_cache_size, l1_size);\n   if (l2_size)\n-    maybe_set_param_value (PARAM_L2_CACHE_SIZE, l2_size,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_l2_cache_size, l2_size);\n \n   /* Do some sanity checks on the above options.  */\n "}, {"sha": "ca7fd9020b89fdba4e8af9cf6e16fa7f6c2b02fd", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 18, "deletions": 25, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3524,9 +3524,8 @@ arm_option_override (void)\n        but measurable, size reduction for PIC code.  Therefore, we decrease\n        the bar for unrestricted expression hoisting to the cost of PIC address\n        calculation, which is 2 instructions.  */\n-    maybe_set_param_value (PARAM_GCSE_UNRESTRICTED_COST, 2,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_gcse_unrestricted_cost, 2);\n \n   /* ARM EABI defaults to strict volatile bitfields.  */\n   if (TARGET_AAPCS_BASED && flag_strict_volatile_bitfields < 0\n@@ -3546,47 +3545,43 @@ arm_option_override (void)\n      override the defaults unless we are tuning for a core we have\n      researched values for.  */\n   if (current_tune->prefetch.num_slots > 0)\n-    maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t   current_tune->prefetch.num_slots,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_simultaneous_prefetches,\n+\t\t\t current_tune->prefetch.num_slots);\n   if (current_tune->prefetch.l1_cache_line_size >= 0)\n-    maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t   current_tune->prefetch.l1_cache_line_size,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_l1_cache_line_size,\n+\t\t\t current_tune->prefetch.l1_cache_line_size);\n   if (current_tune->prefetch.l1_cache_size >= 0)\n-    maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n-\t\t\t   current_tune->prefetch.l1_cache_size,\n-\t\t\t   global_options.x_param_values,\n-\t\t\t   global_options_set.x_param_values);\n+    SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t param_l1_cache_size,\n+\t\t\t current_tune->prefetch.l1_cache_size);\n \n   /* Look through ready list and all of queue for instructions\n      relevant for L2 auto-prefetcher.  */\n-  int param_sched_autopref_queue_depth;\n+  int sched_autopref_queue_depth;\n \n   switch (current_tune->sched_autopref)\n     {\n     case tune_params::SCHED_AUTOPREF_OFF:\n-      param_sched_autopref_queue_depth = -1;\n+      sched_autopref_queue_depth = -1;\n       break;\n \n     case tune_params::SCHED_AUTOPREF_RANK:\n-      param_sched_autopref_queue_depth = 0;\n+      sched_autopref_queue_depth = 0;\n       break;\n \n     case tune_params::SCHED_AUTOPREF_FULL:\n-      param_sched_autopref_queue_depth = max_insn_queue_index + 1;\n+      sched_autopref_queue_depth = max_insn_queue_index + 1;\n       break;\n \n     default:\n       gcc_unreachable ();\n     }\n \n-  maybe_set_param_value (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH,\n-\t\t\t param_sched_autopref_queue_depth,\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t       param_sched_autopref_queue_depth,\n+\t\t       sched_autopref_queue_depth);\n \n   /* Currently, for slow flash data, we just disable literal pools.  We also\n      disable it for pure-code.  */\n@@ -31748,8 +31743,6 @@ arm_valid_target_attribute_p (tree fndecl, tree ARG_UNUSED (name),\n \n   DECL_FUNCTION_SPECIFIC_OPTIMIZATION (fndecl) = new_optimize;\n \n-  finalize_options_struct (&func_options);\n-\n   return ret;\n }\n "}, {"sha": "72cd6dcc98ce7148ff8350f6fa153ebb35d15693", "filename": "gcc/config/i386/i386-options.c", "status": "modified", "additions": 10, "deletions": 22, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fi386%2Fi386-options.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fi386%2Fi386-options.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-options.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2618,22 +2618,14 @@ ix86_option_override_internal (bool main_args_p,\n   if (!TARGET_SCHEDULE)\n     opts->x_flag_schedule_insns_after_reload = opts->x_flag_schedule_insns = 0;\n \n-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t ix86_tune_cost->simultaneous_prefetches,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t ix86_tune_cost->prefetch_block,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n-\t\t\t ix86_tune_cost->l1_cache_size,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n-\t\t\t ix86_tune_cost->l2_cache_size,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_simultaneous_prefetches,\n+\t\t       ix86_tune_cost->simultaneous_prefetches);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l1_cache_line_size,\n+\t\t       ix86_tune_cost->prefetch_block);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l1_cache_size,\n+\t\t       ix86_tune_cost->l1_cache_size);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l2_cache_size,\n+\t\t       ix86_tune_cost->l2_cache_size);\n \n   /* Enable sw prefetching at -O3 for CPUS that prefetching is helpful.  */\n   if (opts->x_flag_prefetch_loop_arrays < 0\n@@ -2868,13 +2860,9 @@ ix86_option_override_internal (bool main_args_p,\n       = (cf_protection_level) (opts->x_flag_cf_protection | CF_SET);\n \n   if (ix86_tune_features [X86_TUNE_AVOID_256FMA_CHAINS])\n-    maybe_set_param_value (PARAM_AVOID_FMA_MAX_BITS, 256,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   opts_set->x_param_values);\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_avoid_fma_max_bits, 256);\n   else if (ix86_tune_features [X86_TUNE_AVOID_128FMA_CHAINS])\n-    maybe_set_param_value (PARAM_AVOID_FMA_MAX_BITS, 128,\n-\t\t\t   opts->x_param_values,\n-\t\t\t   opts_set->x_param_values);\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_avoid_fma_max_bits, 128);\n \n   /* PR86952: jump table usage with retpolines is slow.\n      The PR provides some numbers about the slowness.  */"}, {"sha": "f775697f982671529a0becdca3942ce60a98ef21", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5773,7 +5773,7 @@ get_probe_interval (void)\n {\n   if (flag_stack_clash_protection)\n     return (HOST_WIDE_INT_1U\n-\t    << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n+\t    << param_stack_clash_protection_probe_interval);\n   else\n     return (HOST_WIDE_INT_1U << STACK_CHECK_PROBE_INTERVAL_EXP);\n }\n@@ -6942,7 +6942,7 @@ ix86_adjust_stack_and_probe_stack_clash (HOST_WIDE_INT size,\n   /* If we allocate less than the size of the guard statically,\n      then no probing is necessary, but we do need to allocate\n      the stack.  */\n-  if (size < (1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE)))\n+  if (size < (1 << param_stack_clash_protection_guard_size))\n     {\n       pro_epilogue_adjust_stack (stack_pointer_rtx, stack_pointer_rtx,\n \t\t\t         GEN_INT (-size), -1,\n@@ -21468,18 +21468,18 @@ static unsigned int\n ix86_max_noce_ifcvt_seq_cost (edge e)\n {\n   bool predictable_p = predictable_edge_p (e);\n-\n-  enum compiler_param param\n-    = (predictable_p\n-       ? PARAM_MAX_RTL_IF_CONVERSION_PREDICTABLE_COST\n-       : PARAM_MAX_RTL_IF_CONVERSION_UNPREDICTABLE_COST);\n-\n-  /* If we have a parameter set, use that, otherwise take a guess using\n-     BRANCH_COST.  */\n-  if (global_options_set.x_param_values[param])\n-    return PARAM_VALUE (param);\n+  if (predictable_p)\n+    {\n+      if (global_options_set.x_param_max_rtl_if_conversion_predictable_cost)\n+\treturn param_max_rtl_if_conversion_predictable_cost;\n+    }\n   else\n-    return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (2);\n+    {\n+      if (global_options_set.x_param_max_rtl_if_conversion_unpredictable_cost)\n+\treturn param_max_rtl_if_conversion_unpredictable_cost;\n+    }\n+\n+  return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (2);\n }\n \n /* Return true if SEQ is a good candidate as a replacement for the"}, {"sha": "44f7f2eea06d4a74ece28cba96921a135dc7ef3d", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -7307,7 +7307,7 @@ ia64_adjust_cost (rtx_insn *insn, int dep_type1, rtx_insn *dep_insn,\n \n   if (dw == MIN_DEP_WEAK)\n     /* Store and load are likely to alias, use higher cost to avoid stall.  */\n-    return PARAM_VALUE (PARAM_SCHED_MEM_TRUE_DEP_COST);\n+    return param_sched_mem_true_dep_cost;\n   else if (dw > MIN_DEP_WEAK)\n     {\n       /* Store and load are less likely to alias.  */"}, {"sha": "f0fd2065c02218647f7a79a3e418428ec0ba31fd", "filename": "gcc/config/rs6000/rs6000-logue.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000-logue.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1515,14 +1515,14 @@ static HOST_WIDE_INT\n get_stack_clash_protection_probe_interval (void)\n {\n   return (HOST_WIDE_INT_1U\n-\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL));\n+\t  << param_stack_clash_protection_probe_interval);\n }\n \n static HOST_WIDE_INT\n get_stack_clash_protection_guard_size (void)\n {\n   return (HOST_WIDE_INT_1U\n-\t  << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE));\n+\t  << param_stack_clash_protection_guard_size);\n }\n \n /* Allocate ORIG_SIZE bytes on the stack and probe the newly"}, {"sha": "4c830fcfba3954592f0161cc7c02f15975988ff7", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 20, "deletions": 24, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -80,6 +80,7 @@\n #include \"tree-vrp.h\"\n #include \"tree-ssanames.h\"\n #include \"rs6000-internal.h\"\n+#include \"opts.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -4514,34 +4515,29 @@ rs6000_option_override_internal (bool global_init_p)\n \n   if (global_init_p)\n     {\n-      maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t     rs6000_cost->simultaneous_prefetches,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_L1_CACHE_SIZE, rs6000_cost->l1_cache_size,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t     rs6000_cost->cache_line_size,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_L2_CACHE_SIZE, rs6000_cost->l2_cache_size,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_simultaneous_prefetches,\n+\t\t\t   rs6000_cost->simultaneous_prefetches);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_l1_cache_size,\n+\t\t\t   rs6000_cost->l1_cache_size);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_l1_cache_line_size,\n+\t\t\t   rs6000_cost->cache_line_size);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_l2_cache_size,\n+\t\t\t   rs6000_cost->l2_cache_size);\n \n       /* Increase loop peeling limits based on performance analysis. */\n-      maybe_set_param_value (PARAM_MAX_PEELED_INSNS, 400,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n-      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEELED_INSNS, 400,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_max_peeled_insns, 400);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_max_completely_peeled_insns, 400);\n \n       /* Use the 'model' -fsched-pressure algorithm by default.  */\n-      maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM,\n-\t\t\t     SCHED_PRESSURE_MODEL,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_sched_pressure_algorithm,\n+\t\t\t   SCHED_PRESSURE_MODEL);\n \n       /* Explicit -funroll-loops turns -munroll-only-small-loops off.  */\n       if (((global_options_set.x_flag_unroll_loops && flag_unroll_loops)"}, {"sha": "b3a75222ac2ef5978540c270d9b6199cedb87235", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 26, "deletions": 53, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -10968,9 +10968,9 @@ allocate_stack_space (rtx size, HOST_WIDE_INT last_probe_offset,\n {\n   bool temp_reg_clobbered_p = false;\n   HOST_WIDE_INT probe_interval\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+    = 1 << param_stack_clash_protection_probe_interval;\n   HOST_WIDE_INT guard_size\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_GUARD_SIZE);\n+    = 1 << param_stack_clash_protection_guard_size;\n \n   if (flag_stack_clash_protection)\n     {\n@@ -11086,7 +11086,7 @@ s390_emit_prologue (void)\n      only exception is when TARGET_BACKCHAIN is active, in which case\n      we know *sp (offset 0) was written.  */\n   HOST_WIDE_INT probe_interval\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+    = 1 << param_stack_clash_protection_probe_interval;\n   HOST_WIDE_INT last_probe_offset\n     = (TARGET_BACKCHAIN\n        ? (TARGET_PACKED_STACK ? STACK_POINTER_OFFSET - UNITS_PER_LONG : 0)\n@@ -15264,10 +15264,8 @@ s390_option_override_internal (struct gcc_options *opts,\n      displacements.  Trim that value down to 4k if that happens.  This\n      might result in too many probes being generated only on the\n      oldest supported machine level z900.  */\n-  if (!DISP_IN_RANGE ((1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL))))\n-    set_param_value (\"stack-clash-protection-probe-interval\", 12,\n-\t\t     opts->x_param_values,\n-\t\t     opts_set->x_param_values);\n+  if (!DISP_IN_RANGE ((1 << param_stack_clash_protection_probe_interval)))\n+    param_stack_clash_protection_probe_interval = 12;\n \n #ifdef TARGET_DEFAULT_LONG_DOUBLE_128\n   if (!TARGET_LONG_DOUBLE_128_P (opts_set->x_target_flags))\n@@ -15276,62 +15274,37 @@ s390_option_override_internal (struct gcc_options *opts,\n \n   if (opts->x_s390_tune >= PROCESSOR_2097_Z10)\n     {\n-      maybe_set_param_value (PARAM_MAX_UNROLLED_INSNS, 100,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n-      maybe_set_param_value (PARAM_MAX_UNROLL_TIMES, 32,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n-      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEELED_INSNS, 2000,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n-      maybe_set_param_value (PARAM_MAX_COMPLETELY_PEEL_TIMES, 64,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n-    }\n-\n-  maybe_set_param_value (PARAM_MAX_PENDING_LIST_LENGTH, 256,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_max_unrolled_insns,\n+\t\t\t   100);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_max_unroll_times, 32);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_max_completely_peeled_insns,\n+\t\t\t   2000);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_max_completely_peel_times,\n+\t\t\t   64);\n+    }\n+\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_max_pending_list_length,\n+\t\t       256);\n   /* values for loop prefetching */\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE, 256,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_L1_CACHE_SIZE, 128,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l1_cache_line_size, 256);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l1_cache_size, 128);\n   /* s390 has more than 2 levels and the size is much larger.  Since\n      we are always running virtualized assume that we only get a small\n      part of the caches above l1.  */\n-  maybe_set_param_value (PARAM_L2_CACHE_SIZE, 1500,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_PREFETCH_MIN_INSN_TO_MEM_RATIO, 2,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES, 6,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_l2_cache_size, 1500);\n+  SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t       param_prefetch_min_insn_to_mem_ratio, 2);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_simultaneous_prefetches, 6);\n \n   /* Use the alternative scheduling-pressure algorithm by default.  */\n-  maybe_set_param_value (PARAM_SCHED_PRESSURE_ALGORITHM, 2,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n-\n-  maybe_set_param_value (PARAM_MIN_VECT_LOOP_BOUND, 2,\n-\t\t\t opts->x_param_values,\n-\t\t\t opts_set->x_param_values);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_sched_pressure_algorithm, 2);\n+  SET_OPTION_IF_UNSET (opts, opts_set, param_min_vect_loop_bound, 2);\n \n   /* Use aggressive inlining parameters.  */\n   if (opts->x_s390_tune >= PROCESSOR_2964_Z13)\n     {\n-      maybe_set_param_value (PARAM_INLINE_MIN_SPEEDUP, 2,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n-\n-      maybe_set_param_value (PARAM_MAX_INLINE_INSNS_AUTO, 80,\n-\t\t\t     opts->x_param_values,\n-\t\t\t     opts_set->x_param_values);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_inline_min_speedup, 2);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_max_inline_insns_auto, 80);\n     }\n \n   /* Set the default alignment.  */"}, {"sha": "50385518b1bd6a73309be397b1a7ce498f282620", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 39, "deletions": 44, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -61,6 +61,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"context.h\"\n #include \"builtins.h\"\n #include \"tree-vector-builder.h\"\n+#include \"opts.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -2010,7 +2011,7 @@ sparc_option_override (void)\n       gcc_unreachable ();\n     };\n \n-  /* PARAM_SIMULTANEOUS_PREFETCHES is the number of prefetches that\n+  /* param_simultaneous_prefetches is the number of prefetches that\n      can run at the same time.  More important, it is the threshold\n      defining when additional prefetches will be dropped by the\n      hardware.\n@@ -2033,21 +2034,20 @@ sparc_option_override (void)\n      single-threaded program.  Experimental results show that setting\n      this parameter to 32 works well when the number of threads is not\n      high.  */\n-  maybe_set_param_value (PARAM_SIMULTANEOUS_PREFETCHES,\n-\t\t\t ((sparc_cpu == PROCESSOR_ULTRASPARC\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA2\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA3\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4)\n-\t\t\t  ? 2\n-\t\t\t  : (sparc_cpu == PROCESSOR_ULTRASPARC3\n-\t\t\t     ? 8 : ((sparc_cpu == PROCESSOR_NIAGARA7\n-\t\t\t\t     || sparc_cpu == PROCESSOR_M8)\n-\t\t\t\t    ? 32 : 3))),\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-\n-  /* PARAM_L1_CACHE_LINE_SIZE is the size of the L1 cache line, in\n+  SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t       param_simultaneous_prefetches,\n+\t\t       ((sparc_cpu == PROCESSOR_ULTRASPARC\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA2\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA3\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA4)\n+\t\t\t? 2\n+\t\t\t: (sparc_cpu == PROCESSOR_ULTRASPARC3\n+\t\t\t   ? 8 : ((sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t\t   || sparc_cpu == PROCESSOR_M8)\n+\t\t\t\t  ? 32 : 3))));\n+\n+  /* param_l1_cache_line_size is the size of the L1 cache line, in\n      bytes.\n \n      The Oracle SPARC Architecture (previously the UltraSPARC\n@@ -2064,38 +2064,33 @@ sparc_option_override (void)\n      L2 and L3, but only 32B are brought into the L1D$. (Assuming it\n      is a read_n prefetch, which is the only type which allocates to\n      the L1.)  */\n-  maybe_set_param_value (PARAM_L1_CACHE_LINE_SIZE,\n-\t\t\t (sparc_cpu == PROCESSOR_M8\n-\t\t\t  ? 64 : 32),\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t       param_l1_cache_line_size,\n+\t\t       (sparc_cpu == PROCESSOR_M8 ? 64 : 32));\n \n-  /* PARAM_L1_CACHE_SIZE is the size of the L1D$ (most SPARC chips use\n+  /* param_l1_cache_size is the size of the L1D$ (most SPARC chips use\n      Hardvard level-1 caches) in kilobytes.  Both UltraSPARC and\n      Niagara processors feature a L1D$ of 16KB.  */\n-  maybe_set_param_value (PARAM_L1_CACHE_SIZE,\n-\t\t\t ((sparc_cpu == PROCESSOR_ULTRASPARC\n-\t\t\t   || sparc_cpu == PROCESSOR_ULTRASPARC3\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA2\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA3\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA4\n-\t\t\t   || sparc_cpu == PROCESSOR_NIAGARA7\n-\t\t\t   || sparc_cpu == PROCESSOR_M8)\n-\t\t\t  ? 16 : 64),\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n-\n-\n-  /* PARAM_L2_CACHE_SIZE is the size fo the L2 in kilobytes.  Note\n+  SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t       param_l1_cache_size,\n+\t\t       ((sparc_cpu == PROCESSOR_ULTRASPARC\n+\t\t\t || sparc_cpu == PROCESSOR_ULTRASPARC3\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA2\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA3\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t || sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t || sparc_cpu == PROCESSOR_M8)\n+\t\t\t? 16 : 64));\n+\n+  /* param_l2_cache_size is the size fo the L2 in kilobytes.  Note\n      that 512 is the default in params.def.  */\n-  maybe_set_param_value (PARAM_L2_CACHE_SIZE,\n-\t\t\t ((sparc_cpu == PROCESSOR_NIAGARA4\n-\t\t\t   || sparc_cpu == PROCESSOR_M8)\n-\t\t\t  ? 128 : (sparc_cpu == PROCESSOR_NIAGARA7\n-\t\t\t\t   ? 256 : 512)),\n-\t\t\t global_options.x_param_values,\n-\t\t\t global_options_set.x_param_values);\n+  SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t       param_l2_cache_size,\n+\t\t       ((sparc_cpu == PROCESSOR_NIAGARA4\n+\t\t\t || sparc_cpu == PROCESSOR_M8)\n+\t\t\t? 128 : (sparc_cpu == PROCESSOR_NIAGARA7\n+\t\t\t\t ? 256 : 512)));\n   \n \n   /* Disable save slot sharing for call-clobbered registers by default."}, {"sha": "b1ace70b5f77bef8ffb81c2b48cbfac30029add7", "filename": "gcc/config/visium/visium.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fvisium%2Fvisium.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fconfig%2Fvisium%2Fvisium.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvisium%2Fvisium.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -57,6 +57,7 @@\n #include \"tree-pass.h\"\n #include \"context.h\"\n #include \"builtins.h\"\n+#include \"opts.h\"\n \n /* This file should be included last.  */\n #include \"target-def.h\"\n@@ -457,9 +458,8 @@ visium_option_override (void)\n       /* Allow the size of compilation units to double because of inlining.\n \t In practice the global size of the object code is hardly affected\n \t because the additional instructions will take up the padding.  */\n-      maybe_set_param_value (PARAM_INLINE_UNIT_GROWTH, 100,\n-\t\t\t     global_options.x_param_values,\n-\t\t\t     global_options_set.x_param_values);\n+      SET_OPTION_IF_UNSET (&global_options, &global_options_set,\n+\t\t\t   param_inline_unit_growth, 100);\n     }\n \n   /* Likewise for loops.  */"}, {"sha": "ebe27a323b21104355f8c9d680b17ac91ed045f8", "filename": "gcc/coverage.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -324,7 +324,7 @@ get_coverage_counts (unsigned counter, unsigned cfg_checksum,\n \t}\n       return NULL;\n     }\n-  if (PARAM_VALUE (PARAM_PROFILE_FUNC_INTERNAL_ID))\n+  if (param_profile_func_internal_id)\n     elt.ident = current_function_funcdef_no + 1;\n   else\n     {\n@@ -560,7 +560,7 @@ coverage_compute_profile_id (struct cgraph_node *n)\n     {\n       expanded_location xloc\n \t= expand_location (DECL_SOURCE_LOCATION (n->decl));\n-      bool use_name_only = (PARAM_VALUE (PARAM_PROFILE_FUNC_INTERNAL_ID) == 0);\n+      bool use_name_only = (param_profile_func_internal_id == 0);\n \n       chksum = (use_name_only ? 0 : xloc.line);\n       if (xloc.file)\n@@ -628,7 +628,7 @@ coverage_begin_function (unsigned lineno_checksum, unsigned cfg_checksum)\n \n   /* Announce function */\n   offset = gcov_write_tag (GCOV_TAG_FUNCTION);\n-  if (PARAM_VALUE (PARAM_PROFILE_FUNC_INTERNAL_ID))\n+  if (param_profile_func_internal_id)\n     gcov_write_unsigned (current_function_funcdef_no + 1);\n   else\n     {\n@@ -682,7 +682,7 @@ coverage_end_function (unsigned lineno_checksum, unsigned cfg_checksum)\n \n       item = ggc_alloc<coverage_data> ();\n \n-      if (PARAM_VALUE (PARAM_PROFILE_FUNC_INTERNAL_ID))\n+      if (param_profile_func_internal_id)\n \titem->ident = current_function_funcdef_no + 1;\n       else\n \t{"}, {"sha": "754d66c432699b004b60df2bb83a315c7b53a1da", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1,3 +1,10 @@\n+2019-11-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* name-lookup.c (namespace_hints::namespace_hints): Replace old parameter syntax\n+\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n+\tmacro.\n+\t* typeck.c (comptypes): Likewise.\n+\n 2019-11-12  Maciej W. Rozycki  <macro@codesourcery.com>\n \t    Frederik Harwath  <frederik@codesourcery.com>\n "}, {"sha": "be846a121419ac4cad71d80d362a53096599bf9e", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5358,7 +5358,7 @@ namespace_hints::namespace_hints (location_t loc, tree name)\n \n   m_candidates = vNULL;\n   m_limited = false;\n-  m_limit = PARAM_VALUE (CXX_MAX_NAMESPACES_FOR_DIAGNOSTIC_HELP);\n+  m_limit = param_cxx_max_namespaces_for_diagnostic_help;\n \n   /* Breadth-first search of namespaces.  Up to limit namespaces\n      searched (limit zero == unlimited).  */"}, {"sha": "d3e70311229683c04e2d7fda134730bcfd2358fb", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1498,7 +1498,7 @@ comptypes (tree t1, tree t2, int strict)\n \t   perform a deep check. */\n \treturn structural_comptypes (t1, t2, strict);\n \n-      if (flag_checking && USE_CANONICAL_TYPES)\n+      if (flag_checking && param_use_canonical_types)\n \t{\n \t  bool result = structural_comptypes (t1, t2, strict);\n \t  \n@@ -1519,7 +1519,7 @@ comptypes (tree t1, tree t2, int strict)\n \t  \n \t  return result;\n \t}\n-      if (!flag_checking && USE_CANONICAL_TYPES)\n+      if (!flag_checking && param_use_canonical_types)\n \treturn TYPE_CANONICAL (t1) == TYPE_CANONICAL (t2);\n       else\n \treturn structural_comptypes (t1, t2, strict);"}, {"sha": "b1c0276b0f717c776d182d8ee1f16fa61d6a44f3", "filename": "gcc/cse.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -6414,7 +6414,7 @@ cse_find_path (basic_block first_bb, struct cse_basic_block_data *data,\n   if (follow_jumps)\n     {\n       bb = data->path[path_size - 1].bb;\n-      while (bb && path_size < PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH))\n+      while (bb && path_size < param_max_cse_path_length)\n \t{\n \t  if (single_succ_p (bb))\n \t    e = single_succ_edge (bb);\n@@ -6592,7 +6592,7 @@ cse_extended_basic_block (struct cse_basic_block_data *ebb_data)\n \t     FIXME: This is a real kludge and needs to be done some other\n \t\t    way.  */\n \t  if (NONDEBUG_INSN_P (insn)\n-\t      && num_insns++ > PARAM_VALUE (PARAM_MAX_CSE_INSNS))\n+\t      && num_insns++ > param_max_cse_insns)\n \t    {\n \t      flush_hash_table ();\n \t      num_insns = 0;\n@@ -6736,7 +6736,7 @@ cse_main (rtx_insn *f ATTRIBUTE_UNUSED, int nregs)\n   init_cse_reg_info (nregs);\n \n   ebb_data.path = XNEWVEC (struct branch_path,\n-\t\t\t   PARAM_VALUE (PARAM_MAX_CSE_PATH_LENGTH));\n+\t\t\t   param_max_cse_path_length);\n \n   cse_cfg_altered = false;\n   cse_jumps_altered = false;"}, {"sha": "1745256944a7943f1ed772d77a23a0148750d3a1", "filename": "gcc/cselib.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcselib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fcselib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcselib.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2297,7 +2297,7 @@ cselib_invalidate_mem (rtx mem_rtx)\n \t      p = &(*p)->next;\n \t      continue;\n \t    }\n-\t  if (num_mems < PARAM_VALUE (PARAM_MAX_CSELIB_MEMORY_LOCATIONS)\n+\t  if (num_mems < param_max_cselib_memory_locations\n \t      && ! canon_anti_dependence (x, false, mem_rtx,\n \t\t\t\t\t  GET_MODE (mem_rtx), mem_addr))\n \t    {"}, {"sha": "76abd873c78dbadbfa0535d125a8d54b4fbeec1a", "filename": "gcc/dse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fdse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fdse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdse.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2657,7 +2657,7 @@ dse_step1 (void)\n \n   /* For -O1 reduce the maximum number of active local stores for RTL DSE\n      since this can consume huge amounts of memory (PR89115).  */\n-  int max_active_local_stores = PARAM_VALUE (PARAM_MAX_DSE_ACTIVE_LOCAL_STORES);\n+  int max_active_local_stores = param_max_dse_active_local_stores;\n   if (optimize < 2)\n     max_active_local_stores /= 10;\n "}, {"sha": "5f3e549a7fed1b38b3d864a59b0dec65896b54f2", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2762,15 +2762,15 @@ set_new_first_and_last_insn (rtx_insn *first, rtx_insn *last)\n   set_last_insn (last);\n   cur_insn_uid = 0;\n \n-  if (MIN_NONDEBUG_INSN_UID || MAY_HAVE_DEBUG_INSNS)\n+  if (param_min_nondebug_insn_uid || MAY_HAVE_DEBUG_INSNS)\n     {\n       int debug_count = 0;\n \n-      cur_insn_uid = MIN_NONDEBUG_INSN_UID - 1;\n+      cur_insn_uid = param_min_nondebug_insn_uid - 1;\n       cur_debug_insn_uid = 0;\n \n       for (insn = first; insn; insn = NEXT_INSN (insn))\n-\tif (INSN_UID (insn) < MIN_NONDEBUG_INSN_UID)\n+\tif (INSN_UID (insn) < param_min_nondebug_insn_uid)\n \t  cur_debug_insn_uid = MAX (cur_debug_insn_uid, INSN_UID (insn));\n \telse\n \t  {\n@@ -2780,7 +2780,7 @@ set_new_first_and_last_insn (rtx_insn *first, rtx_insn *last)\n \t  }\n \n       if (debug_count)\n-\tcur_debug_insn_uid = MIN_NONDEBUG_INSN_UID + debug_count;\n+\tcur_debug_insn_uid = param_min_nondebug_insn_uid + debug_count;\n       else\n \tcur_debug_insn_uid++;\n     }\n@@ -3445,10 +3445,10 @@ get_max_insn_count (void)\n      differences due to debug insns, and not be affected by\n      -fmin-insn-uid, to avoid excessive table size and to simplify\n      debugging of -fcompare-debug failures.  */\n-  if (cur_debug_insn_uid > MIN_NONDEBUG_INSN_UID)\n+  if (cur_debug_insn_uid > param_min_nondebug_insn_uid)\n     n -= cur_debug_insn_uid;\n   else\n-    n -= MIN_NONDEBUG_INSN_UID;\n+    n -= param_min_nondebug_insn_uid;\n \n   return n;\n }\n@@ -4085,7 +4085,7 @@ make_debug_insn_raw (rtx pattern)\n \n   insn = as_a <rtx_debug_insn *> (rtx_alloc (DEBUG_INSN));\n   INSN_UID (insn) = cur_debug_insn_uid++;\n-  if (cur_debug_insn_uid > MIN_NONDEBUG_INSN_UID)\n+  if (cur_debug_insn_uid > param_min_nondebug_insn_uid)\n     INSN_UID (insn) = cur_insn_uid++;\n \n   PATTERN (insn) = pattern;\n@@ -5860,8 +5860,8 @@ init_emit (void)\n {\n   set_first_insn (NULL);\n   set_last_insn (NULL);\n-  if (MIN_NONDEBUG_INSN_UID)\n-    cur_insn_uid = MIN_NONDEBUG_INSN_UID;\n+  if (param_min_nondebug_insn_uid)\n+    cur_insn_uid = param_min_nondebug_insn_uid;\n   else\n     cur_insn_uid = 1;\n   cur_debug_insn_uid = 1;"}, {"sha": "93e31cc3ba18cbbe98354f2bda0f054652936701", "filename": "gcc/explow.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1837,7 +1837,7 @@ compute_stack_clash_protection_loop_data (rtx *rounded_size, rtx *last_addr,\n {\n   /* Round SIZE down to STACK_CLASH_PROTECTION_PROBE_INTERVAL */\n   *probe_interval\n-    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+    = 1 << param_stack_clash_protection_probe_interval;\n   *rounded_size = simplify_gen_binary (AND, Pmode, size,\n \t\t\t\t        GEN_INT (-*probe_interval));\n "}, {"sha": "3b9a88dc8a78992bf8210cd472f4e52e0928b87e", "filename": "gcc/final.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -657,7 +657,7 @@ compute_alignments (void)\n     }\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n   profile_count count_threshold = cfun->cfg->count_max.apply_scale\n-\t\t (1, PARAM_VALUE (PARAM_ALIGN_THRESHOLD));\n+\t\t (1, param_align_threshold);\n \n   if (dump_file)\n     {\n@@ -743,7 +743,7 @@ compute_alignments (void)\n \t  && branch_count + fallthru_count > count_threshold\n \t  && (branch_count\n \t      > fallthru_count.apply_scale\n-\t\t    (PARAM_VALUE (PARAM_ALIGN_LOOP_ITERATIONS), 1)))\n+\t\t    (param_align_loop_iterations, 1)))\n \t{\n \t  align_flags alignment = LOOP_ALIGN (label);\n \t  if (dump_file)"}, {"sha": "542cc01865624ab31cfe0c61c39b62163f995e12", "filename": "gcc/fold-const.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5929,9 +5929,9 @@ fold_range_test (location_t loc, enum tree_code code, tree type,\n      short-circuited branch and the underlying object on both sides\n      is the same, make a non-short-circuit operation.  */\n   bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;\n-  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)\n+  if (param_logical_op_non_short_circuit != -1)\n     logical_op_non_short_circuit\n-      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);\n+      = param_logical_op_non_short_circuit;\n   if (logical_op_non_short_circuit\n       && !flag_sanitize_coverage\n       && lhs != 0 && rhs != 0\n@@ -8600,9 +8600,9 @@ fold_truth_andor (location_t loc, enum tree_code code, tree type,\n     return tem;\n \n   bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;\n-  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)\n+  if (param_logical_op_non_short_circuit != -1)\n     logical_op_non_short_circuit\n-      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);\n+      = param_logical_op_non_short_circuit;\n   if (logical_op_non_short_circuit\n       && !flag_sanitize_coverage\n       && (code == TRUTH_AND_EXPR\n@@ -13365,7 +13365,7 @@ tree_single_nonnegative_warnv_p (tree t, bool *strict_overflow_p, int depth)\n \t would not, passes that need this information could be revised\n \t to provide it through dataflow propagation.  */\n       return (!name_registered_for_update_p (t)\n-\t      && depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH)\n+\t      && depth < param_max_ssa_name_query_depth\n \t      && gimple_stmt_nonnegative_warnv_p (SSA_NAME_DEF_STMT (t),\n \t\t\t\t\t\t  strict_overflow_p, depth));\n \n@@ -14013,7 +14013,7 @@ integer_valued_real_single_p (tree t, int depth)\n \t would not, passes that need this information could be revised\n \t to provide it through dataflow propagation.  */\n       return (!name_registered_for_update_p (t)\n-\t      && depth < PARAM_VALUE (PARAM_MAX_SSA_NAME_QUERY_DEPTH)\n+\t      && depth < param_max_ssa_name_query_depth\n \t      && gimple_stmt_integer_valued_real_p (SSA_NAME_DEF_STMT (t),\n \t\t\t\t\t\t    depth));\n "}, {"sha": "0ae39e44b01f2aa7c91d57458b75bb5b14799057", "filename": "gcc/gcse.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -799,10 +799,10 @@ want_to_gcse_p (rtx x, machine_mode mode, HOST_WIDE_INT *max_distance_ptr)\n \t\t      && optimize_function_for_size_p (cfun));\n \t  cost = set_src_cost (x, mode, 0);\n \n-\t  if (cost < COSTS_N_INSNS (GCSE_UNRESTRICTED_COST))\n+\t  if (cost < COSTS_N_INSNS (param_gcse_unrestricted_cost))\n \t    {\n \t      max_distance\n-\t\t= ((HOST_WIDE_INT)GCSE_COST_DISTANCE_RATIO * cost) / 10;\n+\t\t= ((HOST_WIDE_INT)param_gcse_cost_distance_ratio * cost) / 10;\n \t      if (max_distance == 0)\n \t\treturn 0;\n \n@@ -1844,7 +1844,7 @@ prune_insertions_deletions (int n_elems)\n      PRUNE_EXPRS.  */\n   for (j = 0; j < (unsigned) n_elems; j++)\n     if (deletions[j]\n-\t&& ((unsigned) insertions[j] / deletions[j]) > MAX_GCSE_INSERTION_RATIO)\n+\t&& (insertions[j] / deletions[j]) > param_max_gcse_insertion_ratio)\n       bitmap_set_bit (prune_exprs, j);\n \n   /* Now prune PRE_INSERT_MAP and PRE_DELETE_MAP based on PRUNE_EXPRS.  */\n@@ -3133,7 +3133,8 @@ hoist_code (void)\n      expressions, nothing gets hoisted from the entry block.  */\n   FOR_EACH_VEC_ELT (dom_tree_walk, dom_tree_walk_index, bb)\n     {\n-      domby = get_dominated_to_depth (CDI_DOMINATORS, bb, MAX_HOIST_DEPTH);\n+      domby = get_dominated_to_depth (CDI_DOMINATORS, bb,\n+\t\t\t\t      param_max_hoist_depth);\n \n       if (domby.length () == 0)\n \tcontinue;\n@@ -3982,9 +3983,9 @@ update_ld_motion_stores (struct gcse_expr * expr)\n bool\n gcse_or_cprop_is_too_expensive (const char *pass)\n {\n-  unsigned int memory_request = (n_basic_blocks_for_fn (cfun)\n-\t\t\t\t * SBITMAP_SET_SIZE (max_reg_num ())\n-\t\t\t\t * sizeof (SBITMAP_ELT_TYPE));\n+  int memory_request = (n_basic_blocks_for_fn (cfun)\n+\t\t\t* SBITMAP_SET_SIZE (max_reg_num ())\n+\t\t\t* sizeof (SBITMAP_ELT_TYPE));\n   \n   /* Trying to perform global optimizations on flow graphs which have\n      a high connectivity will take a long time and is unlikely to be\n@@ -4007,7 +4008,7 @@ gcse_or_cprop_is_too_expensive (const char *pass)\n \n   /* If allocating memory for the dataflow bitmaps would take up too much\n      storage it's better just to disable the optimization.  */\n-  if (memory_request > MAX_GCSE_MEMORY)\n+  if (memory_request > param_max_gcse_memory)\n     {\n       warning (OPT_Wdisabled_optimization,\n \t       \"%s: %d basic blocks and %d registers; \""}, {"sha": "cf7a4f6840534f76f2fc78324fc4931986893291", "filename": "gcc/ggc-common.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fggc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fggc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-common.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -814,8 +814,8 @@ void\n init_ggc_heuristics (void)\n {\n #if !defined ENABLE_GC_CHECKING && !defined ENABLE_GC_ALWAYS_COLLECT\n-  set_default_param_value (GGC_MIN_EXPAND, ggc_min_expand_heuristic ());\n-  set_default_param_value (GGC_MIN_HEAPSIZE, ggc_min_heapsize_heuristic ());\n+  param_ggc_min_expand = ggc_min_expand_heuristic ();\n+  param_ggc_min_heapsize = ggc_min_heapsize_heuristic ();\n #endif\n }\n "}, {"sha": "b0d26256072c577743e7b7fc36bf31822a33233f", "filename": "gcc/ggc-page.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fggc-page.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fggc-page.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fggc-page.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2185,9 +2185,9 @@ ggc_collect (void)\n      total allocations haven't expanded much since the last\n      collection.  */\n   float allocated_last_gc =\n-    MAX (G.allocated_last_gc, (size_t)PARAM_VALUE (GGC_MIN_HEAPSIZE) * 1024);\n+    MAX (G.allocated_last_gc, (size_t)param_ggc_min_heapsize * 1024);\n \n-  float min_expand = allocated_last_gc * PARAM_VALUE (GGC_MIN_EXPAND) / 100;\n+  float min_expand = allocated_last_gc * param_ggc_min_expand / 100;\n   if (G.allocated < allocated_last_gc + min_expand && !ggc_force_collect)\n     return;\n "}, {"sha": "2a0cf6e41d8121ac44e9ec46165cbf967cc572a3", "filename": "gcc/gimple-loop-interchange.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-interchange.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-interchange.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-interchange.cc?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -78,14 +78,14 @@ along with GCC; see the file COPYING3.  If not see\n    simple reduction of inner loop and double reduction of the loop nest.  */\n \n /* Maximum number of stmts in each loop that should be interchanged.  */\n-#define MAX_NUM_STMT    (PARAM_VALUE (PARAM_LOOP_INTERCHANGE_MAX_NUM_STMTS))\n+#define MAX_NUM_STMT    (param_loop_interchange_max_num_stmts)\n /* Maximum number of data references in loop nest.  */\n-#define MAX_DATAREFS    (PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+#define MAX_DATAREFS    (param_loop_max_datarefs_for_datadeps)\n \n /* Comparison ratio of access stride between inner/outer loops to be\n    interchanged.  This is the minimum stride ratio for loop interchange\n    to be profitable.  */\n-#define OUTER_STRIDE_RATIO  (PARAM_VALUE (PARAM_LOOP_INTERCHANGE_STRIDE_RATIO))\n+#define OUTER_STRIDE_RATIO  (param_loop_interchange_stride_ratio)\n /* The same as above, but we require higher ratio for interchanging the\n    innermost two loops.  */\n #define INNER_STRIDE_RATIO  ((OUTER_STRIDE_RATIO) + 1)"}, {"sha": "c1fc9ba99166f9d60b859b4c6819c421cc671cd1", "filename": "gcc/gimple-loop-jam.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-jam.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-jam.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-jam.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -572,15 +572,15 @@ tree_loop_unroll_and_jam (void)\n       /* We regard a user-specified minimum percentage of zero as a request\n \t to ignore all profitability concerns and apply the transformation\n \t always.  */\n-      if (!PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n+      if (!param_unroll_jam_min_percent)\n \tprofit_unroll = MAX(2, profit_unroll);\n       else if (removed * 100 / datarefs.length ()\n-\t  < (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MIN_PERCENT))\n+\t  < (unsigned)param_unroll_jam_min_percent)\n \tprofit_unroll = 1;\n       if (unroll_factor > profit_unroll)\n \tunroll_factor = profit_unroll;\n-      if (unroll_factor > (unsigned)PARAM_VALUE (PARAM_UNROLL_JAM_MAX_UNROLL))\n-\tunroll_factor = PARAM_VALUE (PARAM_UNROLL_JAM_MAX_UNROLL);\n+      if (unroll_factor > (unsigned)param_unroll_jam_max_unroll)\n+\tunroll_factor = param_unroll_jam_max_unroll;\n       unroll = (unroll_factor > 1\n \t\t&& can_unroll_loop_p (outer, unroll_factor, &desc));\n "}, {"sha": "18456e879582c217223c09dea9df8a27fd7950c1", "filename": "gcc/gimple-loop-versioning.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-versioning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-loop-versioning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-loop-versioning.cc?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -605,8 +605,8 @@ unsigned int\n loop_versioning::max_insns_for_loop (class loop *loop)\n {\n   return (loop->inner\n-\t  ? PARAM_VALUE (PARAM_LOOP_VERSIONING_MAX_OUTER_INSNS)\n-\t  : PARAM_VALUE (PARAM_LOOP_VERSIONING_MAX_INNER_INSNS));\n+\t  ? param_loop_versioning_max_outer_insns\n+\t  : param_loop_versioning_max_inner_insns);\n }\n \n /* Return true if for cost reasons we should avoid versioning any loop"}, {"sha": "49a0834d6473cc511a14d22431d8d62459cbd97f", "filename": "gcc/gimple-ssa-split-paths.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-split-paths.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-split-paths.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-split-paths.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -366,7 +366,7 @@ is_feasible_trace (basic_block bb)\n \n   /* Upper Hard limit on the number statements to copy.  */\n   if (num_stmts_in_join\n-      >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS))\n+      >= param_max_jump_thread_duplication_stmts)\n     return false;\n \n   return true;"}, {"sha": "fbab13c59a03036c047dcf82371e500d742f17ca", "filename": "gcc/gimple-ssa-store-merging.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-store-merging.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-store-merging.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-store-merging.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2502,7 +2502,7 @@ imm_store_chain_info::try_coalesce_bswap (merged_store_group *merged_store,\n     return false;\n \n   bool allow_unaligned\n-    = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n+    = !STRICT_ALIGNMENT && param_store_merging_allow_unaligned;\n   /* Punt if the combined store would not be aligned and we need alignment.  */\n   if (!allow_unaligned)\n     {\n@@ -2762,7 +2762,7 @@ imm_store_chain_info::coalesce_immediate_stores ()\n \n       if (info->order >= merged_store->first_nonmergeable_order\n \t  || (((new_bitregion_end - new_bitregion_start + 1) / BITS_PER_UNIT)\n-\t      > (unsigned) PARAM_VALUE (PARAM_STORE_MERGING_MAX_SIZE)))\n+\t      > (unsigned) param_store_merging_max_size))\n \t;\n \n       /* |---store 1---|\n@@ -3710,7 +3710,7 @@ imm_store_chain_info::output_merged_store (merged_store_group *group)\n \n   auto_vec<class split_store *, 32> split_stores;\n   bool allow_unaligned_store\n-    = !STRICT_ALIGNMENT && PARAM_VALUE (PARAM_STORE_MERGING_ALLOW_UNALIGNED);\n+    = !STRICT_ALIGNMENT && param_store_merging_allow_unaligned;\n   bool allow_unaligned_load = allow_unaligned_store;\n   bool bzero_first = false;\n   store_immediate_info *store;\n@@ -4890,7 +4890,7 @@ pass_store_merging::process_store (gimple *stmt)\n       /* If we reach the limit of stores to merge in a chain terminate and\n \t process the chain now.  */\n       if ((*chain_info)->m_store_info.length ()\n-\t  == (unsigned int) PARAM_VALUE (PARAM_MAX_STORES_TO_MERGE))\n+\t  == (unsigned int) param_max_stores_to_merge)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file,"}, {"sha": "ab5011a7a1e33bab5a09a6b6974b883bfddc12bc", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -546,7 +546,7 @@ find_basis_for_base_expr (slsr_cand_t c, tree base_expr)\n \n   // Limit potential of N^2 behavior for long candidate chains.\n   int iters = 0;\n-  int max_iters = PARAM_VALUE (PARAM_MAX_SLSR_CANDIDATE_SCAN);\n+  int max_iters = param_max_slsr_candidate_scan;\n \n   mapping_key.base_expr = base_expr;\n   chain = base_cand_map->find (&mapping_key);"}, {"sha": "11a4da0a623b75ed12ee5a26d96c973542a4feaa", "filename": "gcc/graphite-isl-ast-to-gimple.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-isl-ast-to-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-isl-ast-to-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-isl-ast-to-gimple.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -203,7 +203,7 @@ class translate_isl_ast_to_gimple\n   {\n     codegen_error = true;\n     gcc_assert (! flag_checking\n-\t\t|| PARAM_VALUE (PARAM_GRAPHITE_ALLOW_CODEGEN_ERRORS));\n+\t\t|| param_graphite_allow_codegen_errors);\n   }\n \n   bool is_constant (tree op) const\n@@ -1383,7 +1383,7 @@ scop_to_isl_ast (scop_p scop)\n {\n   int old_err = isl_options_get_on_error (scop->isl_context);\n   int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n-  int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n+  int max_operations = param_max_isl_operations;\n   if (max_operations)\n     isl_ctx_set_max_operations (scop->isl_context, max_operations);\n   isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);"}, {"sha": "1dc9c3cb7be179456bf4145e34f3f1159b289695", "filename": "gcc/graphite-optimize-isl.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-optimize-isl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-optimize-isl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-optimize-isl.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -64,7 +64,7 @@ get_schedule_for_node_st (__isl_take isl_schedule_node *node, void *user)\n   if (type != isl_schedule_node_leaf)\n     return node;\n \n-  long tile_size = PARAM_VALUE (PARAM_LOOP_BLOCK_TILE_SIZE);\n+  long tile_size = param_loop_block_tile_size;\n   if (dims <= 1\n       || tile_size == 0\n       || !isl_schedule_node_band_get_permutable (node))\n@@ -115,7 +115,7 @@ optimize_isl (scop_p scop)\n {\n   int old_err = isl_options_get_on_error (scop->isl_context);\n   int old_max_operations = isl_ctx_get_max_operations (scop->isl_context);\n-  int max_operations = PARAM_VALUE (PARAM_MAX_ISL_OPERATIONS);\n+  int max_operations = param_max_isl_operations;\n   if (max_operations)\n     isl_ctx_set_max_operations (scop->isl_context, max_operations);\n   isl_options_set_on_error (scop->isl_context, ISL_ON_ERROR_CONTINUE);"}, {"sha": "1505a13b8602dbf3e8aa50d0ec4a99b86839ae7e", "filename": "gcc/graphite-scop-detection.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-scop-detection.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fgraphite-scop-detection.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgraphite-scop-detection.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1639,7 +1639,7 @@ build_scops (vec<scop_p> *scops)\n \t  continue;\n \t}\n \n-      unsigned max_arrays = PARAM_VALUE (PARAM_GRAPHITE_MAX_ARRAYS_PER_SCOP);\n+      unsigned max_arrays = param_graphite_max_arrays_per_scop;\n       if (max_arrays > 0\n \t  && scop->drs.length () >= max_arrays)\n \t{\n@@ -1652,7 +1652,7 @@ build_scops (vec<scop_p> *scops)\n \t}\n \n       find_scop_parameters (scop);\n-      graphite_dim_t max_dim = PARAM_VALUE (PARAM_GRAPHITE_MAX_NB_SCOP_PARAMS);\n+      graphite_dim_t max_dim = param_graphite_max_nb_scop_params;\n       if (max_dim > 0\n \t  && scop_nb_params (scop) > max_dim)\n \t{"}, {"sha": "58bf704ea15974a11459649ffb5fdc2f8b0b5cbb", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -584,7 +584,7 @@ set_modulo_params (int ii, int max_stages, int insns, int max_uid)\n   modulo_max_stages = max_stages;\n   modulo_n_insns = insns;\n   modulo_iter0_max_uid = max_uid;\n-  modulo_backtracks_left = PARAM_VALUE (PARAM_MAX_MODULO_BACKTRACK_ATTEMPTS);\n+  modulo_backtracks_left = param_max_modulo_backtrack_attempts;\n }\n \n /* A structure to record a pair of insns where the first one is a real\n@@ -2712,7 +2712,7 @@ rank_for_schedule (const void *x, const void *y)\n   if (flag_sched_critical_path_heuristic && priority_val)\n     return rfs_result (RFS_PRIORITY, priority_val, tmp, tmp2);\n \n-  if (PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) >= 0)\n+  if (param_sched_autopref_queue_depth >= 0)\n     {\n       int autopref = autopref_rank_for_schedule (tmp, tmp2);\n       if (autopref != 0)\n@@ -3413,7 +3413,7 @@ model_remove_from_worklist (struct model_insn_info *insn)\n }\n \n /* Add INSN to the model worklist.  Start looking for a suitable position\n-   between neighbors PREV and NEXT, testing at most MAX_SCHED_READY_INSNS\n+   between neighbors PREV and NEXT, testing at most param_max_sched_ready_insns\n    insns either side.  A null PREV indicates the beginning of the list and\n    a null NEXT indicates the end.  */\n \n@@ -3424,7 +3424,7 @@ model_add_to_worklist (struct model_insn_info *insn,\n {\n   int count;\n \n-  count = MAX_SCHED_READY_INSNS;\n+  count = param_max_sched_ready_insns;\n   if (count > 0 && prev && model_order_p (insn, prev))\n     do\n       {\n@@ -3452,7 +3452,7 @@ model_promote_insn (struct model_insn_info *insn)\n   int count;\n \n   prev = insn->prev;\n-  count = MAX_SCHED_READY_INSNS;\n+  count = param_max_sched_ready_insns;\n   while (count > 0 && prev && model_order_p (insn, prev))\n     {\n       count--;\n@@ -3738,7 +3738,7 @@ model_choose_insn (void)\n     {\n       fprintf (sched_dump, \";;\\t+--- worklist:\\n\");\n       insn = model_worklist;\n-      count = MAX_SCHED_READY_INSNS;\n+      count = param_max_sched_ready_insns;\n       while (count > 0 && insn)\n \t{\n \t  fprintf (sched_dump, \";;\\t+---   %d [%d, %d, %d, %d]\\n\",\n@@ -3770,7 +3770,7 @@ model_choose_insn (void)\n \n      Failing that, just pick the highest-priority instruction in the\n      worklist.  */\n-  count = MAX_SCHED_READY_INSNS;\n+  count = param_max_sched_ready_insns;\n   insn = model_worklist;\n   fallback = 0;\n   for (;;)\n@@ -5147,12 +5147,12 @@ queue_to_ready (struct ready_list *ready)\n       /* If the ready list is full, delay the insn for 1 cycle.\n \t See the comment in schedule_block for the rationale.  */\n       if (!reload_completed\n-\t  && (ready->n_ready - ready->n_debug > MAX_SCHED_READY_INSNS\n+\t  && (ready->n_ready - ready->n_debug > param_max_sched_ready_insns\n \t      || (sched_pressure == SCHED_PRESSURE_MODEL\n-\t\t  /* Limit pressure recalculations to MAX_SCHED_READY_INSNS\n-\t\t     instructions too.  */\n+\t\t  /* Limit pressure recalculations to\n+\t\t     param_max_sched_ready_insns instructions too.  */\n \t\t  && model_index (insn) > (model_curr_point\n-\t\t\t\t\t   + MAX_SCHED_READY_INSNS)))\n+\t\t\t\t\t   + param_max_sched_ready_insns)))\n \t  && !(sched_pressure == SCHED_PRESSURE_MODEL\n \t       && model_curr_point < model_num_insns\n \t       /* Always allow the next model instruction to issue.  */\n@@ -5743,7 +5743,7 @@ autopref_multipass_dfa_lookahead_guard (rtx_insn *insn1, int ready_index)\n   /* Exit early if the param forbids this or if we're not entering here through\n      normal haifa scheduling.  This can happen if selective scheduling is\n      explicitly enabled.  */\n-  if (!insn_queue || PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) <= 0)\n+  if (!insn_queue || param_sched_autopref_queue_depth <= 0)\n     return 0;\n \n   if (sched_verbose >= 2 && ready_index == 0)\n@@ -5796,14 +5796,14 @@ autopref_multipass_dfa_lookahead_guard (rtx_insn *insn1, int ready_index)\n \t    }\n \t}\n \n-      if (PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) == 1)\n+      if (param_sched_autopref_queue_depth == 1)\n \tcontinue;\n \n       /* Everything from the current queue slot should have been moved to\n \t the ready list.  */\n       gcc_assert (insn_queue[NEXT_Q_AFTER (q_ptr, 0)] == NULL_RTX);\n \n-      int n_stalls = PARAM_VALUE (PARAM_SCHED_AUTOPREF_QUEUE_DEPTH) - 1;\n+      int n_stalls = param_sched_autopref_queue_depth - 1;\n       if (n_stalls > max_insn_queue_index)\n \tn_stalls = max_insn_queue_index;\n \n@@ -6552,14 +6552,15 @@ schedule_block (basic_block *target_bb, state_t init_state)\n      time in the worst case.  Before reload we are more likely to have\n      big lists so truncate them to a reasonable size.  */\n   if (!reload_completed\n-      && ready.n_ready - ready.n_debug > MAX_SCHED_READY_INSNS)\n+      && ready.n_ready - ready.n_debug > param_max_sched_ready_insns)\n     {\n       ready_sort_debug (&ready);\n       ready_sort_real (&ready);\n \n-      /* Find first free-standing insn past MAX_SCHED_READY_INSNS.\n+      /* Find first free-standing insn past param_max_sched_ready_insns.\n          If there are debug insns, we know they're first.  */\n-      for (i = MAX_SCHED_READY_INSNS + ready.n_debug; i < ready.n_ready; i++)\n+      for (i = param_max_sched_ready_insns + ready.n_debug; i < ready.n_ready;\n+\t   i++)\n \tif (!SCHED_GROUP_P (ready_element (&ready, i)))\n \t  break;\n \n@@ -7258,7 +7259,7 @@ sched_init (void)\n \t   && !reload_completed\n \t   && common_sched_info->sched_pass_id == SCHED_RGN_PASS)\n     sched_pressure = ((enum sched_pressure_algorithm)\n-\t\t      PARAM_VALUE (PARAM_SCHED_PRESSURE_ALGORITHM));\n+\t\t      param_sched_pressure_algorithm);\n   else\n     sched_pressure = SCHED_PRESSURE_NONE;\n \n@@ -7273,11 +7274,10 @@ sched_init (void)\n \n       if (spec_info->mask != 0)\n         {\n-          spec_info->data_weakness_cutoff =\n-            (PARAM_VALUE (PARAM_SCHED_SPEC_PROB_CUTOFF) * MAX_DEP_WEAK) / 100;\n-          spec_info->control_weakness_cutoff =\n-            (PARAM_VALUE (PARAM_SCHED_SPEC_PROB_CUTOFF)\n-             * REG_BR_PROB_BASE) / 100;\n+\t  spec_info->data_weakness_cutoff\n+\t    = (param_sched_spec_prob_cutoff * MAX_DEP_WEAK) / 100;\n+\t  spec_info->control_weakness_cutoff\n+\t    = (param_sched_spec_prob_cutoff * REG_BR_PROB_BASE) / 100;\n         }\n       else\n \t/* So we won't read anything accidentally.  */"}, {"sha": "c4a03f938cf438ea2e5329c6ae17cdc2058a4c44", "filename": "gcc/hsa-gen.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fhsa-gen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fhsa-gen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhsa-gen.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5940,7 +5940,7 @@ init_prologue (void)\n   unsigned index = hsa_get_number_decl_kernel_mappings ();\n \n   /* Emit store to debug argument.  */\n-  if (PARAM_VALUE (PARAM_HSA_GEN_DEBUG_STORES) > 0)\n+  if (param_hsa_gen_debug_stores > 0)\n     set_debug_value (prologue, new hsa_op_immed (1000 + index, BRIG_TYPE_U64));\n }\n "}, {"sha": "5df8a43a5f7e31b1e6d10a5e9216dd1280efb95c", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3311,7 +3311,7 @@ bb_ok_for_noce_convert_multiple_sets (basic_block test_bb)\n {\n   rtx_insn *insn;\n   unsigned count = 0;\n-  unsigned param = PARAM_VALUE (PARAM_MAX_RTL_IF_CONVERSION_INSNS);\n+  unsigned param = param_max_rtl_if_conversion_insns;\n \n   FOR_BB_INSNS (test_bb, insn)\n     {\n@@ -3838,7 +3838,7 @@ cond_move_process_if_block (struct noce_if_info *if_info)\n   vec<rtx> else_regs = vNULL;\n   unsigned int i;\n   int success_p = FALSE;\n-  int limit = PARAM_VALUE (PARAM_MAX_RTL_IF_CONVERSION_INSNS);\n+  int limit = param_max_rtl_if_conversion_insns;\n \n   /* Build a mapping for each block to the value used for each\n      register.  */"}, {"sha": "345f1792ad6c7dcbb155ac5f95aadf80162d8720", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1612,7 +1612,7 @@ ipcp_lattice<valtype>::add_value (valtype newval, cgraph_edge *cs,\n \treturn false;\n       }\n \n-  if (values_count == PARAM_VALUE (PARAM_IPA_CP_VALUE_LIST_SIZE))\n+  if (values_count == param_ipa_cp_value_list_size)\n     {\n       /* We can only free sources, not the values themselves, because sources\n \t of other values in this SCC might point to them.   */\n@@ -2089,7 +2089,7 @@ merge_agg_lats_step (class ipcp_param_lattices *dest_plats,\n \t  set_agg_lats_to_bottom (dest_plats);\n \t  return false;\n \t}\n-      if (dest_plats->aggs_count == PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS))\n+      if (dest_plats->aggs_count == param_ipa_max_agg_items)\n \treturn false;\n       dest_plats->aggs_count++;\n       new_al = ipcp_agg_lattice_pool.allocate ();\n@@ -2644,11 +2644,11 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       int size = ipa_size_summaries->get (callee)->size;\n       /* FIXME: The values below need re-considering and perhaps also\n \t integrating into the cost metrics, at lest in some very basic way.  */\n-      if (size <= MAX_INLINE_INSNS_AUTO / 4)\n+      if (size <= param_max_inline_insns_auto / 4)\n \tres += 31 / ((int)speculative + 1);\n-      else if (size <= MAX_INLINE_INSNS_AUTO / 2)\n+      else if (size <= param_max_inline_insns_auto / 2)\n \tres += 15 / ((int)speculative + 1);\n-      else if (size <= MAX_INLINE_INSNS_AUTO\n+      else if (size <= param_max_inline_insns_auto\n \t       || DECL_DECLARED_INLINE_P (callee->decl))\n \tres += 7 / ((int)speculative + 1);\n     }\n@@ -2663,7 +2663,7 @@ hint_time_bonus (ipa_hints hints)\n {\n   int result = 0;\n   if (hints & (INLINE_HINT_loop_iterations | INLINE_HINT_loop_stride))\n-    result += PARAM_VALUE (PARAM_IPA_CP_LOOP_HINT_BONUS);\n+    result += param_ipa_cp_loop_hint_bonus;\n   return result;\n }\n \n@@ -2675,11 +2675,11 @@ incorporate_penalties (ipa_node_params *info, int64_t evaluation)\n {\n   if (info->node_within_scc)\n     evaluation = (evaluation\n-\t\t  * (100 - PARAM_VALUE (PARAM_IPA_CP_RECURSION_PENALTY))) / 100;\n+\t\t  * (100 - param_ipa_cp_recursion_penalty)) / 100;\n \n   if (info->node_calling_single_call)\n     evaluation = (evaluation\n-\t\t  * (100 - PARAM_VALUE (PARAM_IPA_CP_SINGLE_CALL_PENALTY)))\n+\t\t  * (100 - param_ipa_cp_single_call_penalty))\n       / 100;\n \n   return evaluation;\n@@ -2719,10 +2719,10 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t \", threshold: %i\\n\",\n \t\t info->node_within_scc ? \", scc\" : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n+\t\t evaluation, param_ipa_cp_eval_threshold);\n \t}\n \n-      return evaluation >= PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD);\n+      return evaluation >= param_ipa_cp_eval_threshold;\n     }\n   else\n     {\n@@ -2737,9 +2737,9 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n \t\t time_benefit, size_cost, freq_sum,\n \t\t info->node_within_scc ? \", scc\" : \"\",\n \t\t info->node_calling_single_call ? \", single_call\" : \"\",\n-\t\t evaluation, PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD));\n+\t\t evaluation, param_ipa_cp_eval_threshold);\n \n-      return evaluation >= PARAM_VALUE (PARAM_IPA_CP_EVAL_THRESHOLD);\n+      return evaluation >= param_ipa_cp_eval_threshold;\n     }\n }\n \n@@ -3364,9 +3364,9 @@ ipcp_propagate_stage (class ipa_topo_info *topo)\n   }\n \n   max_new_size = overall_size;\n-  if (max_new_size < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n-    max_new_size = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n-  max_new_size += max_new_size * PARAM_VALUE (PARAM_IPCP_UNIT_GROWTH) / 100 + 1;\n+  if (max_new_size < param_large_unit_insns)\n+    max_new_size = param_large_unit_insns;\n+  max_new_size += max_new_size * param_ipcp_unit_growth / 100 + 1;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\noverall_size: %li, max_new_size: %li\\n\","}, {"sha": "fe619d1dbb6dd9fae6a24012ef9e407bf9a50fa6", "filename": "gcc/ipa-fnsummary.c", "status": "modified", "additions": 9, "deletions": 11, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-fnsummary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-fnsummary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-fnsummary.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1204,7 +1204,7 @@ decompose_param_expr (struct ipa_func_body_info *fbi,\n \t\t      struct agg_position_info *aggpos,\n \t\t      expr_eval_ops *param_ops_p = NULL)\n {\n-  int op_limit = PARAM_VALUE (PARAM_IPA_MAX_PARAM_EXPR_OPS);\n+  int op_limit = param_ipa_max_param_expr_ops;\n   int op_count = 0;\n \n   if (param_ops_p)\n@@ -1435,7 +1435,7 @@ set_switch_stmt_execution_predicate (struct ipa_func_body_info *fbi,\n \n   auto_vec<std::pair<tree, tree> > ranges;\n   tree type = TREE_TYPE (op);\n-  int bound_limit = PARAM_VALUE (PARAM_IPA_MAX_SWITCH_PREDICATE_BOUNDS);\n+  int bound_limit = param_ipa_max_switch_predicate_bounds;\n   int bound_count = 0;\n   wide_int vr_wmin, vr_wmax;\n   value_range_kind vr_type = get_range_info (op, &vr_wmin, &vr_wmax);\n@@ -2280,9 +2280,9 @@ fp_expression_p (gimple *stmt)\n static void\n analyze_function_body (struct cgraph_node *node, bool early)\n {\n-  sreal time = PARAM_VALUE (PARAM_UNINLINED_FUNCTION_TIME);\n+  sreal time = param_uninlined_function_time;\n   /* Estimate static overhead for function prologue/epilogue and alignment. */\n-  int size = PARAM_VALUE (PARAM_UNINLINED_FUNCTION_INSNS);\n+  int size = param_uninlined_function_insns;\n   /* Benefits are scaled by probability of elimination that is in range\n      <0,2>.  */\n   basic_block bb;\n@@ -2331,7 +2331,7 @@ analyze_function_body (struct cgraph_node *node, bool early)\n \t  fbi.bb_infos = vNULL;\n \t  fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n \t  fbi.param_count = count_formal_params (node->decl);\n-\t  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+\t  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n \n \t  nonconstant_names.safe_grow_cleared\n \t    (SSANAMES (my_function)->length ());\n@@ -2348,9 +2348,9 @@ analyze_function_body (struct cgraph_node *node, bool early)\n   info->account_size_time (0, 0, bb_predicate, bb_predicate);\n \n   bb_predicate = predicate::not_inlined ();\n-  info->account_size_time (PARAM_VALUE (PARAM_UNINLINED_FUNCTION_INSNS)\n+  info->account_size_time (param_uninlined_function_insns\n \t\t\t   * ipa_fn_summary::size_scale,\n-\t\t\t   PARAM_VALUE (PARAM_UNINLINED_FUNCTION_TIME),\n+\t\t\t   param_uninlined_function_time,\n \t\t\t   bb_predicate,\n \t\t           bb_predicate);\n \n@@ -2748,10 +2748,8 @@ compute_fn_summary (struct cgraph_node *node, bool early)\n       es->call_stmt_size = eni_size_weights.call_cost;\n       es->call_stmt_time = eni_time_weights.call_cost;\n       info->account_size_time (ipa_fn_summary::size_scale\n-\t\t\t       * PARAM_VALUE\n-\t\t\t\t (PARAM_UNINLINED_FUNCTION_THUNK_INSNS),\n-\t\t\t       PARAM_VALUE\n-\t\t\t\t (PARAM_UNINLINED_FUNCTION_THUNK_TIME), t, t);\n+\t\t\t       * param_uninlined_function_thunk_insns,\n+\t\t\t       param_uninlined_function_thunk_time, t, t);\n       t = predicate::not_inlined ();\n       info->account_size_time (2 * ipa_fn_summary::size_scale, 0, t, t);\n       ipa_update_overall_fn_summary (node);"}, {"sha": "d5a9fb0682ef282141a9348aa641959af1a763c3", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -442,8 +442,8 @@ offline_size (struct cgraph_node *node, ipa_size_summary *info)\n       else if (DECL_COMDAT (node->decl)\n \t       && node->can_remove_if_no_direct_calls_p ())\n \treturn (info->size\n-\t        * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n-\t        + 50) / 100;\n+\t\t* (100 - param_comdat_sharing_probability)\n+\t\t+ 50) / 100;\n     }\n   return 0;\n }"}, {"sha": "b159f440e91d8d902dda9c73fa05775fdc59c5ca", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 41, "deletions": 43, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -179,13 +179,13 @@ caller_growth_limits (struct cgraph_edge *e)\n   if (limit < what_size_info->self_size)\n     limit = what_size_info->self_size;\n \n-  limit += limit * PARAM_VALUE (PARAM_LARGE_FUNCTION_GROWTH) / 100;\n+  limit += limit * param_large_function_growth / 100;\n \n   /* Check the size after inlining against the function limits.  But allow\n      the function to shrink if it went over the limits by forced inlining.  */\n   newsize = estimate_size_after_inlining (to, e);\n   if (newsize >= ipa_size_summaries->get (what)->size\n-      && newsize > PARAM_VALUE (PARAM_LARGE_FUNCTION_INSNS)\n+      && newsize > param_large_function_insns\n       && newsize > limit)\n     {\n       e->inline_failed = CIF_LARGE_FUNCTION_GROWTH_LIMIT;\n@@ -201,7 +201,7 @@ caller_growth_limits (struct cgraph_edge *e)\n      on every invocation of the caller (i.e. its call statement dominates\n      exit block).  We do not track this information, yet.  */\n   stack_size_limit += ((gcov_type)stack_size_limit\n-\t\t       * PARAM_VALUE (PARAM_STACK_FRAME_GROWTH) / 100);\n+\t\t       * param_stack_frame_growth / 100);\n \n   inlined_stack = (ipa_get_stack_frame_offset (to)\n \t\t   + outer_info->estimated_self_stack_size\n@@ -214,7 +214,7 @@ caller_growth_limits (struct cgraph_edge *e)\n \t This bit overoptimistically assume that we are good at stack\n \t packing.  */\n       && inlined_stack > ipa_fn_summaries->get (to)->estimated_stack_size\n-      && inlined_stack > PARAM_VALUE (PARAM_LARGE_STACK_FRAME))\n+      && inlined_stack > param_large_stack_frame)\n     {\n       e->inline_failed = CIF_LARGE_STACK_FRAME_GROWTH_LIMIT;\n       return false;\n@@ -399,16 +399,16 @@ inline_insns_single (cgraph_node *n, bool hint)\n   if (opt_for_fn (n->decl, optimize) >= 3)\n     {\n       if (hint)\n-\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE)\n-\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT) / 100;\n-      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE);\n+\treturn param_max_inline_insns_single\n+\t       * param_inline_heuristics_hint_percent / 100;\n+      return param_max_inline_insns_single;\n     }\n   else\n     {\n       if (hint)\n-\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2)\n-\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT_O2) / 100;\n-      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SINGLE_O2);\n+\treturn param_max_inline_insns_single_o2\n+\t       * param_inline_heuristics_hint_percent_o2 / 100;\n+      return param_max_inline_insns_single_o2;\n     }\n }\n \n@@ -421,16 +421,16 @@ inline_insns_auto (cgraph_node *n, bool hint)\n   if (opt_for_fn (n->decl, optimize) >= 3)\n     {\n       if (hint)\n-\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO)\n-\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT) / 100;\n-      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO);\n+\treturn param_max_inline_insns_auto\n+\t       * param_inline_heuristics_hint_percent / 100;\n+      return param_max_inline_insns_auto;\n     }\n   else\n     {\n       if (hint)\n-\treturn PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2)\n-\t       * PARAM_VALUE (PARAM_INLINE_HEURISTICS_HINT_PERCENT_O2) / 100;\n-      return PARAM_VALUE (PARAM_MAX_INLINE_INSNS_AUTO_O2);\n+\treturn param_max_inline_insns_auto_o2\n+\t       * param_inline_heuristics_hint_percent_o2 / 100;\n+      return param_max_inline_insns_auto_o2;\n     }\n }\n \n@@ -567,14 +567,14 @@ can_inline_edge_by_limits_p (struct cgraph_edge *e, bool report,\n \t  inlinable = false;\n \t}\n       /* If callee is optimized for size and caller is not, allow inlining if\n-\t code shrinks or we are in MAX_INLINE_INSNS_SINGLE limit and callee\n-\t is inline (and thus likely an unified comdat).  This will allow caller\n-\t to run faster.  */\n+\t code shrinks or we are in param_max_inline_insns_single limit and\n+\t callee is inline (and thus likely an unified comdat).\n+\t This will allow caller to run faster.  */\n       else if (opt_for_fn (callee->decl, optimize_size)\n \t       > opt_for_fn (caller->decl, optimize_size))\n \t{\n \t  int growth = estimate_edge_growth (e);\n-\t  if (growth > PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE)\n+\t  if (growth > param_max_inline_insns_size\n \t      && (!DECL_DECLARED_INLINE_P (callee->decl)\n \t\t  && growth >= MAX (inline_insns_single (caller, false),\n \t\t\t\t    inline_insns_auto (caller, false))))\n@@ -686,11 +686,11 @@ want_early_inline_function_p (struct cgraph_edge *e)\n       int growth = estimate_edge_growth (e);\n       int n;\n       int early_inlining_insns = opt_for_fn (e->caller->decl, optimize) >= 3\n-\t\t\t\t ? PARAM_VALUE (PARAM_EARLY_INLINING_INSNS)\n-\t\t\t\t : PARAM_VALUE (PARAM_EARLY_INLINING_INSNS_O2);\n+\t\t\t\t ? param_early_inlining_insns\n+\t\t\t\t : param_early_inlining_insns_o2;\n \n \n-      if (growth <= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE))\n+      if (growth <= param_max_inline_insns_size)\n \t;\n       else if (!e->maybe_hot_p ())\n \t{\n@@ -794,8 +794,8 @@ big_speedup_p (struct cgraph_edge *e)\n \t\t\t ? e->caller->inlined_to\n \t\t\t : e->caller);\n   int limit = opt_for_fn (caller->decl, optimize) >= 3\n-\t      ? PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP)\n-\t      : PARAM_VALUE (PARAM_INLINE_MIN_SPEEDUP_O2);\n+\t      ? param_inline_min_speedup\n+\t      : param_inline_min_speedup_o2;\n \n   if ((time - inlined_time) * 100 > time * limit)\n     return true;\n@@ -862,9 +862,9 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t\t\t   | INLINE_HINT_loop_iterations\n \t\t\t\t   | INLINE_HINT_loop_stride));\n \n-      if (growth <= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SIZE))\n+      if (growth <= param_max_inline_insns_size)\n \t;\n-      /* Apply MAX_INLINE_INSNS_SINGLE limit.  Do not do so when\n+      /* Apply param_max_inline_insns_single limit.  Do not do so when\n \t hints suggests that inlining given function is very profitable.\n \t Avoid computation of big_speedup_p when not necessary to change\n \t outcome of decision.  */\n@@ -882,7 +882,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t}\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && !opt_for_fn (e->caller->decl, flag_inline_functions)\n-\t       && growth >= PARAM_VALUE (PARAM_MAX_INLINE_INSNS_SMALL))\n+\t       && growth >= param_max_inline_insns_small)\n \t{\n \t  /* growth_positive_p is expensive, always test it last.  */\n           if (growth >= inline_insns_single (e->caller, false)\n@@ -892,8 +892,8 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t      want_inline = false;\n  \t    }\n \t}\n-      /* Apply MAX_INLINE_INSNS_AUTO limit for functions not declared inline.\n-\t Bypass the limit when speedup seems big.  */\n+      /* Apply param_max_inline_insns_auto limit for functions not declared\n+\t inline.  Bypass the limit when speedup seems big.  */\n       else if (!DECL_DECLARED_INLINE_P (callee->decl)\n \t       && growth >= inline_insns_auto (e->caller, apply_hints)\n \t       && (apply_hints\n@@ -945,10 +945,10 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   char const *reason = NULL;\n   bool want_inline = true;\n   sreal caller_freq = 1;\n-  int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n+  int max_depth = param_max_inline_recursive_depth_auto;\n \n   if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n-    max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n+    max_depth = param_max_inline_recursive_depth;\n \n   if (!edge->maybe_hot_p ())\n     {\n@@ -1010,7 +1010,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n     {\n       if (edge->sreal_frequency () * 100\n           <= caller_freq\n-\t     * PARAM_VALUE (PARAM_MIN_INLINE_RECURSIVE_PROBABILITY))\n+\t     * param_min_inline_recursive_probability)\n \t{\n \t  reason = \"frequency of recursive call is too small\";\n \t  want_inline = false;\n@@ -1207,9 +1207,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t      /* ... or when early optimizers decided to split and edge\n \t\t frequency still indicates splitting is a win ... */\n \t      || (callee->split_part && !caller->split_part\n-\t\t  && freq * 100\n-\t\t     < PARAM_VALUE\n-\t\t\t  (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY)\n+\t\t  && freq * 100 < param_partial_inlining_entry_probability\n \t\t  /* ... and do not overwrite user specified hints.   */\n \t\t  && (!DECL_DECLARED_INLINE_P (edge->callee->decl)\n \t\t      || DECL_DECLARED_INLINE_P (caller->decl)))))\n@@ -1539,7 +1537,7 @@ static bool\n recursive_inlining (struct cgraph_edge *edge,\n \t\t    vec<cgraph_edge *> *new_edges)\n {\n-  int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n+  int limit = param_max_inline_insns_recursive_auto;\n   edge_heap_t heap (sreal::min ());\n   struct cgraph_node *node;\n   struct cgraph_edge *e;\n@@ -1552,7 +1550,7 @@ recursive_inlining (struct cgraph_edge *edge,\n     node = node->inlined_to;\n \n   if (DECL_DECLARED_INLINE_P (node->decl))\n-    limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE);\n+    limit = param_max_inline_insns_recursive;\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n   if (estimate_size_after_inlining (node, edge)  >= limit)\n@@ -1677,11 +1675,11 @@ static int\n compute_max_insns (int insns)\n {\n   int max_insns = insns;\n-  if (max_insns < PARAM_VALUE (PARAM_LARGE_UNIT_INSNS))\n-    max_insns = PARAM_VALUE (PARAM_LARGE_UNIT_INSNS);\n+  if (max_insns < param_large_unit_insns)\n+    max_insns = param_large_unit_insns;\n \n   return ((int64_t) max_insns\n-\t  * (100 + PARAM_VALUE (PARAM_INLINE_UNIT_GROWTH)) / 100);\n+\t  * (100 + param_inline_unit_growth) / 100);\n }\n \n \n@@ -2897,7 +2895,7 @@ early_inliner (function *fun)\n \t}\n       /* We iterate incremental inlining to get trivial cases of indirect\n \t inlining.  */\n-      while (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS)\n+      while (iterations < param_early_inliner_max_iterations\n \t     && early_inline_small_functions (node))\n \t{\n \t  timevar_push (TV_INTEGRATION);\n@@ -2916,7 +2914,7 @@ early_inliner (function *fun)\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n \t    }\n-\t  if (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS) - 1)\n+\t  if (iterations < param_early_inliner_max_iterations - 1)\n \t    ipa_update_overall_fn_summary (node);\n \t  timevar_pop (TV_INTEGRATION);\n \t  iterations++;"}, {"sha": "7c2b4c795fab93de12ff6c99a958714fd8ddb312", "filename": "gcc/ipa-polymorphic-call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-polymorphic-call.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-polymorphic-call.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-polymorphic-call.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1400,7 +1400,7 @@ record_known_type (struct type_change_info *tci, tree type, HOST_WIDE_INT offset\n static inline bool\n csftc_abort_walking_p (unsigned speculative)\n {\n-  unsigned max = PARAM_VALUE (PARAM_MAX_SPECULATIVE_DEVIRT_MAYDEFS);\n+  unsigned max = param_max_speculative_devirt_maydefs;\n   return speculative > max ? true : false;\n }\n "}, {"sha": "cd34ae628547ba9e44e24f4881308e4a769b546a", "filename": "gcc/ipa-profile.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-profile.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -506,7 +506,7 @@ ipa_profile (void)\n \n       gcc_assert (overall_size);\n \n-      cutoff = (overall_time * PARAM_VALUE (HOT_BB_COUNT_WS_PERMILLE) + 500) / 1000;\n+      cutoff = (overall_time * param_hot_bb_count_ws_permille + 500) / 1000;\n       threshold = 0;\n       for (i = 0; cumulated < cutoff; i++)\n \t{"}, {"sha": "3e78321bf16e7c455948affb37aa6b543d20507b", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1601,7 +1601,7 @@ determine_known_aggregate_parts (gcall *call, tree arg,\n   struct ipa_known_agg_contents_list *list = NULL, *all_list = NULL;\n   bitmap visited = NULL;\n   int item_count = 0, const_count = 0;\n-  int ipa_max_agg_items = PARAM_VALUE (PARAM_IPA_MAX_AGG_ITEMS);\n+  int ipa_max_agg_items = param_ipa_max_agg_items;\n   HOST_WIDE_INT arg_offset, arg_size;\n   tree arg_base;\n   bool check_ref, by_ref;\n@@ -2632,7 +2632,7 @@ ipa_analyze_node (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = ipa_get_param_count (info);\n-  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n \n   for (struct cgraph_edge *cs = node->callees; cs; cs = cs->next_callee)\n     {\n@@ -5314,7 +5314,7 @@ ipcp_transform_function (struct cgraph_node *node)\n   fbi.bb_infos = vNULL;\n   fbi.bb_infos.safe_grow_cleared (last_basic_block_for_fn (cfun));\n   fbi.param_count = param_count;\n-  fbi.aa_walk_budget = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+  fbi.aa_walk_budget = param_ipa_max_aa_steps;\n \n   vec_safe_grow_cleared (descriptors, param_count);\n   ipa_populate_param_decls (node, *descriptors);"}, {"sha": "c73b257ca7f9051d10b539fad5314e48712ad0f7", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -453,7 +453,7 @@ consider_split (class split_point *current, bitmap non_ssa_vars,\n      is unknown.  */\n   if (!(current->count\n        < (ENTRY_BLOCK_PTR_FOR_FN (cfun)->count.apply_scale\n-\t   (PARAM_VALUE (PARAM_PARTIAL_INLINING_ENTRY_PROBABILITY), 100))))\n+\t   (param_partial_inlining_entry_probability, 100))))\n     {\n       /* When profile is guessed, we cannot expect it to give us\n \t realistic estimate on likelyness of function taking the\n@@ -563,8 +563,8 @@ consider_split (class split_point *current, bitmap non_ssa_vars,\n      that.  Next stage1 we should try to be more meaningful here.  */\n   if (current->header_size + call_overhead\n       >= (unsigned int)(DECL_DECLARED_INLINE_P (current_function_decl)\n-\t\t\t? MAX_INLINE_INSNS_SINGLE\n-\t\t\t: MAX_INLINE_INSNS_AUTO) + 10)\n+\t\t\t? param_max_inline_insns_single\n+\t\t\t: param_max_inline_insns_auto) + 10)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -577,7 +577,7 @@ consider_split (class split_point *current, bitmap non_ssa_vars,\n      Limit this duplication.  This is consistent with limit in tree-sra.c  \n      FIXME: with LTO we ought to be able to do better!  */\n   if (DECL_ONE_ONLY (current_function_decl)\n-      && current->split_size >= (unsigned int) MAX_INLINE_INSNS_AUTO + 10)\n+      && current->split_size >= (unsigned int) param_max_inline_insns_auto + 10)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -589,7 +589,7 @@ consider_split (class split_point *current, bitmap non_ssa_vars,\n      FIXME: with LTO we ought to be able to do better!  */\n   if (DECL_ONE_ONLY (current_function_decl)\n       && current->split_size\n-\t <= (unsigned int) PARAM_VALUE (PARAM_EARLY_INLINING_INSNS) / 2)\n+\t <= (unsigned int) param_early_inlining_insns / 2)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,"}, {"sha": "303e4a7028ae8c25bb911c7da5f1794b4de6426a", "filename": "gcc/ipa-sra.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fipa-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-sra.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1266,7 +1266,7 @@ allocate_access (gensum_param_desc *desc,\n \t\t HOST_WIDE_INT offset, HOST_WIDE_INT size)\n {\n   if (desc->access_count\n-      == (unsigned) PARAM_VALUE (PARAM_IPA_SRA_MAX_REPLACEMENTS))\n+      == (unsigned) param_ipa_sra_max_replacements)\n     {\n       disqualify_split_candidate (desc, \"Too many replacement candidates\");\n       return NULL;\n@@ -2280,8 +2280,7 @@ process_scan_results (cgraph_node *node, struct function *fun,\n       if (!desc->by_ref || optimize_function_for_size_p (fun))\n \tparam_size_limit = cur_param_size;\n       else\n-\tparam_size_limit = (PARAM_VALUE (PARAM_IPA_SRA_PTR_GROWTH_FACTOR)\n-\t\t\t   * cur_param_size);\n+\tparam_size_limit = param_ipa_sra_ptr_growth_factor * cur_param_size;\n       if (nonarg_acc_size > param_size_limit\n \t  || (!desc->by_ref && nonarg_acc_size == param_size_limit))\n \t{\n@@ -2501,7 +2500,7 @@ ipa_sra_summarize_function (cgraph_node *node)\n \t  bb_dereferences = XCNEWVEC (HOST_WIDE_INT,\n \t\t\t\t      by_ref_count\n \t\t\t\t      * last_basic_block_for_fn (fun));\n-\t  aa_walking_limit = PARAM_VALUE (PARAM_IPA_MAX_AA_STEPS);\n+\t  aa_walking_limit = param_ipa_max_aa_steps;\n \t  scan_function (node, fun);\n \n \t  if (dump_file)\n@@ -3337,7 +3336,7 @@ pull_accesses_from_callee (isra_param_desc *param_desc,\n       return NULL;\n \n     if ((prop_count + pclen\n-\t > (unsigned) PARAM_VALUE (PARAM_IPA_SRA_MAX_REPLACEMENTS))\n+\t > (unsigned) param_ipa_sra_max_replacements)\n \t|| size_would_violate_limit_p (param_desc,\n \t\t\t\t       param_desc->size_reached + prop_size))\n       return \"propagating accesses would violate the count or size limit\";"}, {"sha": "e53bb813f37520af155ca0e9e29aab18b9b229d3", "filename": "gcc/ira-build.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fira-build.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fira-build.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-build.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2217,7 +2217,7 @@ loop_compare_func (const void *v1p, const void *v2p)\n    hardly helps (for irregular register file architecture it could\n    help by choosing a better hard register in the loop but we prefer\n    faster allocation even in this case).  We also remove cheap loops\n-   if there are more than IRA_MAX_LOOPS_NUM of them.  Loop with EH\n+   if there are more than param_ira_max_loops_num of them.  Loop with EH\n    exit or enter edges are removed too because the allocation might\n    require put pseudo moves on the EH edges (we could still do this\n    for pseudos with caller saved hard registers in some cases but it\n@@ -2253,7 +2253,7 @@ mark_loops_for_removal (void)\n \t     );\n       }\n   qsort (sorted_loops, n, sizeof (ira_loop_tree_node_t), loop_compare_func);\n-  for (i = 0; i < n - IRA_MAX_LOOPS_NUM; i++)\n+  for (i = 0; i < n - param_ira_max_loops_num; i++)\n     {\n       sorted_loops[i]->to_remove_p = true;\n       if (internal_flag_ira_verbose > 1 && ira_dump_file != NULL)"}, {"sha": "8e7c0c41f2fbf5b19e99919ccd14d8dd997ade0a", "filename": "gcc/ira-conflicts.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fira-conflicts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fira-conflicts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-conflicts.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -113,13 +113,13 @@ build_conflict_bit_table (void)\n \t     / IRA_INT_BITS);\n \tallocated_words_num += conflict_bit_vec_words_num;\n \tif ((uint64_t) allocated_words_num * sizeof (IRA_INT_TYPE)\n-\t    > (uint64_t) IRA_MAX_CONFLICT_TABLE_SIZE * 1024 * 1024)\n+\t    > (uint64_t) param_ira_max_conflict_table_size * 1024 * 1024)\n \t  {\n \t    if (internal_flag_ira_verbose > 0 && ira_dump_file != NULL)\n \t      fprintf\n \t\t(ira_dump_file,\n \t\t \"+++Conflict table will be too big(>%dMB) -- don't use it\\n\",\n-\t\t IRA_MAX_CONFLICT_TABLE_SIZE);\n+\t\t param_ira_max_conflict_table_size);\n \t    return false;\n \t  }\n       }"}, {"sha": "6a956a03b03870bdc798ba93ab1f4fe832c14b3f", "filename": "gcc/loop-doloop.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-doloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-doloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-doloop.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -651,7 +651,7 @@ doloop_optimize (class loop *loop)\n     }\n \n   max_cost\n-    = COSTS_N_INSNS (PARAM_VALUE (PARAM_MAX_ITERATIONS_COMPUTATION_COST));\n+    = COSTS_N_INSNS (param_max_iterations_computation_cost);\n   if (set_src_cost (desc->niter_expr, mode, optimize_loop_for_speed_p (loop))\n       > max_cost)\n     {"}, {"sha": "d40ad37cced300d89b7b2a72598cf68de3caa79f", "filename": "gcc/loop-invariant.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-invariant.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-invariant.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-invariant.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1491,7 +1491,7 @@ gain_for_invariant (struct invariant *inv, unsigned *regs_needed,\n \t  if ((int) new_regs[pressure_class]\n \t      + (int) regs_needed[pressure_class]\n \t      + LOOP_DATA (curr_loop)->max_reg_pressure[pressure_class]\n-\t      + IRA_LOOP_RESERVED_REGS\n+\t      + param_ira_loop_reserved_regs\n \t      > ira_class_hard_regs_num[pressure_class])\n \t    break;\n \t}\n@@ -2279,7 +2279,7 @@ move_loop_invariants (void)\n       /* move_single_loop_invariants for very large loops is time consuming\n \t and might need a lot of memory.  For -O1 only do loop invariant\n \t motion for very small loops.  */\n-      unsigned max_bbs = LOOP_INVARIANT_MAX_BBS_IN_LOOP;\n+      unsigned max_bbs = param_loop_invariant_max_bbs_in_loop;\n       if (optimize < 2)\n \tmax_bbs /= 10;\n       if (loop->num_nodes <= max_bbs)"}, {"sha": "551405ad0d1778c76c4e121b39fcd7ff3917c9cd", "filename": "gcc/loop-unroll.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-unroll.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Floop-unroll.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop-unroll.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -364,13 +364,13 @@ decide_unroll_constant_iterations (class loop *loop, int flags)\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once).  */\n-  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n+  nunroll = param_max_unrolled_insns / loop->ninsns;\n   nunroll_by_av\n-    = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+    = param_max_average_unrolled_insns / loop->av_ninsns;\n   if (nunroll > nunroll_by_av)\n     nunroll = nunroll_by_av;\n-  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n-    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+  if (nunroll > (unsigned) param_max_unroll_times)\n+    nunroll = param_max_unroll_times;\n \n   if (targetm.loop_unroll_adjust)\n     nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n@@ -684,12 +684,12 @@ decide_unroll_runtime_iterations (class loop *loop, int flags)\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n-  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n-  nunroll_by_av = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+  nunroll = param_max_unrolled_insns / loop->ninsns;\n+  nunroll_by_av = param_max_average_unrolled_insns / loop->av_ninsns;\n   if (nunroll > nunroll_by_av)\n     nunroll = nunroll_by_av;\n-  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n-    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+  if (nunroll > (unsigned) param_max_unroll_times)\n+    nunroll = param_max_unroll_times;\n \n   if (targetm.loop_unroll_adjust)\n     nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n@@ -1167,13 +1167,13 @@ decide_unroll_stupid (class loop *loop, int flags)\n \n   /* nunroll = total number of copies of the original loop body in\n      unrolled loop (i.e. if it is 2, we have to duplicate loop body once.  */\n-  nunroll = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / loop->ninsns;\n+  nunroll = param_max_unrolled_insns / loop->ninsns;\n   nunroll_by_av\n-    = PARAM_VALUE (PARAM_MAX_AVERAGE_UNROLLED_INSNS) / loop->av_ninsns;\n+    = param_max_average_unrolled_insns / loop->av_ninsns;\n   if (nunroll > nunroll_by_av)\n     nunroll = nunroll_by_av;\n-  if (nunroll > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLL_TIMES))\n-    nunroll = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+  if (nunroll > (unsigned) param_max_unroll_times)\n+    nunroll = param_max_unroll_times;\n \n   if (targetm.loop_unroll_adjust)\n     nunroll = targetm.loop_unroll_adjust (nunroll, loop);\n@@ -1824,7 +1824,7 @@ expand_var_during_unrolling (struct var_to_expand *ve, rtx_insn *insn)\n \n   /* Generate a new register only if the expansion limit has not been\n      reached.  Else reuse an already existing expansion.  */\n-  if (PARAM_VALUE (PARAM_MAX_VARIABLE_EXPANSIONS) > ve->expansion_count)\n+  if (param_max_variable_expansions > ve->expansion_count)\n     {\n       really_new_expansion = true;\n       new_reg = gen_reg_rtx (GET_MODE (ve->reg));"}, {"sha": "56ab96310899bb59ce72b005a521aaebaabf066f", "filename": "gcc/lra-assigns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flra-assigns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flra-assigns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-assigns.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1008,7 +1008,7 @@ spill_for (int regno, bitmap spilled_pseudo_bitmap, bool first_p)\n \t}\n       n = 0;\n       if (sparseset_cardinality (live_range_reload_inheritance_pseudos)\n-\t  <= (unsigned)LRA_MAX_CONSIDERED_RELOAD_PSEUDOS)\n+\t  <= (unsigned)param_lra_max_considered_reload_pseudos)\n \tEXECUTE_IF_SET_IN_SPARSESET (live_range_reload_inheritance_pseudos,\n \t\t\t\t     reload_regno)\n \t  if ((int) reload_regno != regno"}, {"sha": "ced7be79017702638adff846298fe7b250189010", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -6682,7 +6682,7 @@ inherit_in_ebb (rtx_insn *head, rtx_insn *tail)\n    a BB is not greater than the following value, we don't add the BB\n    to EBB.  */\n #define EBB_PROBABILITY_CUTOFF \\\n-  ((REG_BR_PROB_BASE * LRA_INHERITANCE_EBB_PROBABILITY_CUTOFF) / 100)\n+  ((REG_BR_PROB_BASE * param_lra_inheritance_ebb_probability_cutoff) / 100)\n \n /* Current number of inheritance/split iteration.  */\n int lra_inheritance_iter;"}, {"sha": "01b86f4e9574bd26157fb1bbba0abb2613833b8d", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1,3 +1,10 @@\n+2019-11-12  Martin Liska  <mliska@suse.cz>\n+\n+\t* lto-partition.c (lto_balanced_map): Replace old parameter syntax\n+\twith the new one, include opts.h if needed.  Use SET_OPTION_IF_UNSET\n+\tmacro.\n+\t* lto.c (do_whole_program_analysis): Likewise.\n+\n 2019-11-11  Martin Liska  <mliska@suse.cz>\n \n \t* Make-lang.in: Relax dependency of lto-dump.o to"}, {"sha": "5354350378b3ee0b946a033214ae87e964aa519b", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -560,13 +560,13 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n   varpool_order.qsort (varpool_node_cmp);\n \n   /* Compute partition size and create the first partition.  */\n-  if (PARAM_VALUE (MIN_PARTITION_SIZE) > max_partition_size)\n+  if (param_min_partition_size > max_partition_size)\n     fatal_error (input_location, \"min partition size cannot be greater \"\n \t\t \"than max partition size\");\n \n   partition_size = total_size / n_lto_partitions;\n-  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n-    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+  if (partition_size < param_min_partition_size)\n+    partition_size = param_min_partition_size;\n   npartitions = 1;\n   partition = new_partition (\"\");\n   if (dump_file)\n@@ -816,8 +816,8 @@ lto_balanced_map (int n_lto_partitions, int max_partition_size)\n \t    fprintf (dump_file,\n \t\t     \"Total size: %\" PRId64 \" partition_size: %\" PRId64 \"\\n\",\n \t\t     total_size, partition_size);\n-\t  if (partition_size < PARAM_VALUE (MIN_PARTITION_SIZE))\n-\t    partition_size = PARAM_VALUE (MIN_PARTITION_SIZE);\n+\t  if (partition_size < param_min_partition_size)\n+\t    partition_size = param_min_partition_size;\n \t  npartitions ++;\n \t}\n     }"}, {"sha": "1d2d52754c7c65f75be9971267e47279c00f4b2b", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -436,14 +436,14 @@ do_whole_program_analysis (void)\n \n   /* TODO: jobserver communication is not supported, yet.  */\n   if (!strcmp (flag_wpa, \"jobserver\"))\n-    lto_parallelism = PARAM_VALUE (PARAM_MAX_LTO_STREAMING_PARALLELISM);\n+    lto_parallelism = param_max_lto_streaming_parallelism;\n   else\n     {\n       lto_parallelism = atoi (flag_wpa);\n       if (lto_parallelism <= 0)\n \tlto_parallelism = 0;\n-      if (lto_parallelism >= PARAM_VALUE (PARAM_MAX_LTO_STREAMING_PARALLELISM))\n-\tlto_parallelism = PARAM_VALUE (PARAM_MAX_LTO_STREAMING_PARALLELISM);\n+      if (lto_parallelism >= param_max_lto_streaming_parallelism)\n+\tlto_parallelism = param_max_lto_streaming_parallelism;\n     }\n \n   timevar_start (TV_PHASE_OPT_GEN);\n@@ -496,8 +496,8 @@ do_whole_program_analysis (void)\n   else if (flag_lto_partition == LTO_PARTITION_ONE)\n     lto_balanced_map (1, INT_MAX);\n   else if (flag_lto_partition == LTO_PARTITION_BALANCED)\n-    lto_balanced_map (PARAM_VALUE (PARAM_LTO_PARTITIONS),\n-\t\t      PARAM_VALUE (MAX_PARTITION_SIZE));\n+    lto_balanced_map (param_lto_partitions,\n+\t\t      param_max_partition_size);\n   else\n     gcc_unreachable ();\n "}, {"sha": "3127fb1481ea8ab48ad7b16e7724c94f048935dc", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1433,7 +1433,7 @@ sms_schedule (void)\n       if ( latch_edge->count () > profile_count::zero ()\n           && (latch_edge->count()\n \t      < single_exit (loop)->count ().apply_scale\n-\t\t\t\t (SMS_LOOP_AVERAGE_COUNT_THRESHOLD, 1)))\n+\t\t\t\t (param_sms_loop_average_count_threshold, 1)))\n \t{\n \t  if (dump_file)\n \t    {\n@@ -1640,7 +1640,7 @@ sms_schedule (void)\n \t  /* The default value of PARAM_SMS_MIN_SC is 2 as stage count of\n \t     1 means that there is no interleaving between iterations thus\n \t     we let the scheduling passes do the job in this case.  */\n-\t  if (stage_count < PARAM_VALUE (PARAM_SMS_MIN_SC)\n+\t  if (stage_count < param_sms_min_sc\n \t      || (count_init && (loop_count <= stage_count))\n \t      || (max_trip_count >= 0 && max_trip_count <= stage_count)\n \t      || (trip_count >= 0 && trip_count <= stage_count))\n@@ -1832,7 +1832,7 @@ sms_schedule (void)\n /* A limit on the number of cycles that resource conflicts can span.  ??? Should\n    be provided by DFA, and be dependent on the type of insn scheduled.  Currently\n    set to 0 to save compile time.  */\n-#define DFA_HISTORY SMS_DFA_HISTORY\n+#define DFA_HISTORY param_sms_dfa_history\n \n /* A threshold for the number of repeated unsuccessful attempts to insert\n    an empty row, before we flush the partial schedule and start over.  */"}, {"sha": "a47517df80e31fffba3d736ce14b93b5e6688254", "filename": "gcc/opts.c", "status": "modified", "additions": 16, "deletions": 32, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -667,25 +667,18 @@ default_options_optimization (struct gcc_options *opts,\n     opts->x_flag_ipa_pta = true;\n \n   /* Track fields in field-sensitive alias analysis.  */\n-  maybe_set_param_value\n-    (PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE,\n-     opt2 ? 100 : default_param_value (PARAM_MAX_FIELDS_FOR_FIELD_SENSITIVE),\n-     opts->x_param_values, opts_set->x_param_values);\n+  if (opt2)\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_max_fields_for_field_sensitive,\n+\t\t\t 100);\n \n   if (opts->x_optimize_size)\n     /* We want to crossjump as much as possible.  */\n-    maybe_set_param_value (PARAM_MIN_CROSSJUMP_INSNS, 1,\n-\t\t\t   opts->x_param_values, opts_set->x_param_values);\n-  else\n-    maybe_set_param_value (PARAM_MIN_CROSSJUMP_INSNS,\n-\t\t\t   default_param_value (PARAM_MIN_CROSSJUMP_INSNS),\n-\t\t\t   opts->x_param_values, opts_set->x_param_values);\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_min_crossjump_insns, 1);\n \n   /* Restrict the amount of work combine does at -Og while retaining\n      most of its useful transforms.  */\n   if (opts->x_optimize_debug)\n-    maybe_set_param_value (PARAM_MAX_COMBINE_INSNS, 2,\n-\t\t\t   opts->x_param_values, opts_set->x_param_values);\n+    SET_OPTION_IF_UNSET (opts, opts_set, param_max_combine_insns, 2);\n \n   /* Allow default optimizations to be specified on a per-machine basis.  */\n   maybe_default_options (opts, opts_set,\n@@ -1036,10 +1029,8 @@ finish_options (struct gcc_options *opts, struct gcc_options *opts_set,\n \n   if (opts->x_flag_conserve_stack)\n     {\n-      maybe_set_param_value (PARAM_LARGE_STACK_FRAME, 100,\n-\t\t\t     opts->x_param_values, opts_set->x_param_values);\n-      maybe_set_param_value (PARAM_STACK_FRAME_GROWTH, 40,\n-\t\t\t     opts->x_param_values, opts_set->x_param_values);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_large_stack_frame, 100);\n+      SET_OPTION_IF_UNSET (opts, opts_set, param_stack_frame_growth, 40);\n     }\n \n   if (opts->x_flag_lto)\n@@ -2272,19 +2263,13 @@ common_handle_option (struct gcc_options *opts,\n \t all features.  */\n       if (opts->x_flag_sanitize & SANITIZE_KERNEL_ADDRESS)\n \t{\n-\t  maybe_set_param_value (PARAM_ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD,\n-\t\t\t\t 0, opts->x_param_values,\n-\t\t\t\t opts_set->x_param_values);\n-\t  maybe_set_param_value (PARAM_ASAN_GLOBALS, 0, opts->x_param_values,\n-\t\t\t\t opts_set->x_param_values);\n-\t  maybe_set_param_value (PARAM_ASAN_STACK, 0, opts->x_param_values,\n-\t\t\t\t opts_set->x_param_values);\n-\t  maybe_set_param_value (PARAM_ASAN_PROTECT_ALLOCAS, 0,\n-\t\t\t\t opts->x_param_values,\n-\t\t\t\t opts_set->x_param_values);\n-\t  maybe_set_param_value (PARAM_ASAN_USE_AFTER_RETURN, 0,\n-\t\t\t\t opts->x_param_values,\n-\t\t\t\t opts_set->x_param_values);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t\t       param_asan_instrumentation_with_call_threshold,\n+\t\t\t       0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_globals, 0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_stack, 0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_protect_allocas, 0);\n+\t  SET_OPTION_IF_UNSET (opts, opts_set, param_asan_use_after_return, 0);\n \t}\n       break;\n \n@@ -2586,9 +2571,8 @@ common_handle_option (struct gcc_options *opts,\n       enable_fdo_optimizations (opts, opts_set, value);\n       if (!opts_set->x_flag_profile_correction)\n \topts->x_flag_profile_correction = value;\n-      maybe_set_param_value (\n-\tPARAM_EARLY_INLINER_MAX_ITERATIONS, 10,\n-\topts->x_param_values, opts_set->x_param_values);\n+      SET_OPTION_IF_UNSET (opts, opts_set,\n+\t\t\t   param_early_inliner_max_iterations, 10);\n       break;\n \n     case OPT_fprofile_generate_:"}, {"sha": "161e6d926b52b8369cea63bcfdcd5f2609523e87", "filename": "gcc/postreload-gcse.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fpostreload-gcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fpostreload-gcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpostreload-gcse.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1146,17 +1146,18 @@ eliminate_partially_redundant_load (basic_block bb, rtx_insn *insn,\n \n   /* Check if it's worth applying the partial redundancy elimination.  */\n   if (ok_count.to_gcov_type ()\n-      < GCSE_AFTER_RELOAD_PARTIAL_FRACTION * not_ok_count.to_gcov_type ())\n+      < param_gcse_after_reload_partial_fraction * not_ok_count.to_gcov_type ())\n     goto cleanup;\n \n   gcov_type threshold;\n #if (GCC_VERSION >= 5000)\n-  if (__builtin_mul_overflow (GCSE_AFTER_RELOAD_CRITICAL_FRACTION,\n+  if (__builtin_mul_overflow (param_gcse_after_reload_critical_fraction,\n \t\t\t      critical_count.to_gcov_type (), &threshold))\n     threshold = profile_count::max_count;\n #else\n   threshold\n-    = GCSE_AFTER_RELOAD_CRITICAL_FRACTION * critical_count.to_gcov_type ();\n+    = (param_gcse_after_reload_critical_fraction\n+       * critical_count.to_gcov_type ());\n #endif\n \n   if (ok_count.to_gcov_type () < threshold)"}, {"sha": "5ee56a33fd78cc5d286439b033d56380d28deea1", "filename": "gcc/predict.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -132,7 +132,7 @@ get_hot_bb_threshold ()\n {\n   if (min_count == -1)\n     {\n-      const int hot_frac = PARAM_VALUE (HOT_BB_COUNT_FRACTION);\n+      const int hot_frac = param_hot_bb_count_fraction;\n       const gcov_type min_hot_count\n \t= hot_frac\n \t  ? profile_info->sum_max / hot_frac\n@@ -177,7 +177,7 @@ maybe_hot_count_p (struct function *fun, profile_count count)\n       if (node->frequency == NODE_FREQUENCY_EXECUTED_ONCE\n \t  && count < (ENTRY_BLOCK_PTR_FOR_FN (fun)->count.apply_scale (2, 3)))\n \treturn false;\n-      if (count.apply_scale (PARAM_VALUE (HOT_BB_FREQUENCY_FRACTION), 1)\n+      if (count.apply_scale (param_hot_bb_frequency_fraction, 1)\n \t  < ENTRY_BLOCK_PTR_FOR_FN (fun)->count)\n \treturn false;\n       return true;\n@@ -223,7 +223,7 @@ probably_never_executed (struct function *fun, profile_count count)\n      desirable.  */\n   if (count.precise_p () && profile_status_for_fn (fun) == PROFILE_READ)\n     {\n-      const int unlikely_frac = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n+      const int unlikely_frac = param_unlikely_bb_count_fraction;\n       if (count.apply_scale (unlikely_frac, 1) >= profile_info->runs)\n \treturn false;\n       return true;\n@@ -412,9 +412,9 @@ predictable_edge_p (edge e)\n   if (!e->probability.initialized_p ())\n     return false;\n   if ((e->probability.to_reg_br_prob_base ()\n-       <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100)\n+       <= param_predictable_branch_outcome * REG_BR_PROB_BASE / 100)\n       || (REG_BR_PROB_BASE - e->probability.to_reg_br_prob_base ()\n-          <= PARAM_VALUE (PARAM_PREDICTABLE_BRANCH_OUTCOME) * REG_BR_PROB_BASE / 100))\n+\t  <= param_predictable_branch_outcome * REG_BR_PROB_BASE / 100))\n     return true;\n   return false;\n }\n@@ -1963,7 +1963,7 @@ predict_loops (void)\n \t{\n \t  tree niter = NULL;\n \t  HOST_WIDE_INT nitercst;\n-\t  int max = PARAM_VALUE (PARAM_MAX_PREDICTED_ITERATIONS);\n+\t  int max = param_max_predicted_iterations;\n \t  int probability;\n \t  enum br_predictor predictor;\n \t  widest_int nit;\n@@ -2443,7 +2443,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t  *predictor = (enum br_predictor) tree_to_uhwi (val2);\n \t\t  if (*predictor == PRED_BUILTIN_EXPECT)\n \t\t    *probability\n-\t\t      = HITRATE (PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY));\n+\t\t      = HITRATE (param_builtin_expect_probability);\n \t\t  return gimple_call_arg (def, 1);\n \t\t}\n \t      return NULL;\n@@ -2469,7 +2469,7 @@ expr_expected_value_1 (tree type, tree op0, enum tree_code code,\n \t\t    return val;\n \t\t  *predictor = PRED_BUILTIN_EXPECT;\n \t\t  *probability\n-\t\t    = HITRATE (PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY));\n+\t\t    = HITRATE (param_builtin_expect_probability);\n \t\t  return gimple_call_arg (def, 1);\n \t\t}\n \t      case BUILT_IN_EXPECT_WITH_PROBABILITY:\n@@ -2660,7 +2660,7 @@ tree_predict_by_opcode (basic_block bb)\n \t  edge e = find_taken_edge_switch_expr (sw, val);\n \t  if (predictor == PRED_BUILTIN_EXPECT)\n \t    {\n-\t      int percent = PARAM_VALUE (BUILTIN_EXPECT_PROBABILITY);\n+\t      int percent = param_builtin_expect_probability;\n \t      gcc_assert (percent >= 0 && percent <= 100);\n \t      predict_edge (e, PRED_BUILTIN_EXPECT,\n \t\t\t    HITRATE (percent));\n@@ -3531,7 +3531,7 @@ drop_profile (struct cgraph_node *node, profile_count call_count)\n void\n handle_missing_profiles (void)\n {\n-  const int unlikely_frac = PARAM_VALUE (UNLIKELY_BB_COUNT_FRACTION);\n+  const int unlikely_frac = param_unlikely_bb_count_fraction;\n   struct cgraph_node *node;\n   auto_vec<struct cgraph_node *, 64> worklist;\n "}, {"sha": "b8178238ff9ab94b70395f5603f25f43c68f9130", "filename": "gcc/reload.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -6717,7 +6717,7 @@ find_equiv_reg (rtx goal, rtx_insn *insn, enum reg_class rclass, int other,\n \tcontinue;\n       num++;\n       if (p == 0 || LABEL_P (p)\n-\t  || num > PARAM_VALUE (PARAM_MAX_RELOAD_SEARCH_INSNS))\n+\t  || num > param_max_reload_search_insns)\n \treturn 0;\n \n       /* Don't reuse register contents from before a setjmp-type"}, {"sha": "460741213f2b591dca8f89aa54fd1416f5fe8b98", "filename": "gcc/reorg.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1489,7 +1489,7 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n \n   /* Scan backwards looking for a match.  */\n   for (trial = PREV_INSN (target),\n-\t insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;\n+\t insns_to_search = param_max_delay_slot_insn_search;\n        trial && insns_to_search > 0;\n        trial = PREV_INSN (trial))\n     {\n@@ -1593,7 +1593,7 @@ redundant_insn (rtx insn, rtx_insn *target, const vec<rtx_insn *> &delay_list)\n      INSN sets or sets something insn uses or sets.  */\n \n   for (trial = PREV_INSN (target),\n-\t insns_to_search = MAX_DELAY_SLOT_INSN_SEARCH;\n+\t insns_to_search = param_max_delay_slot_insn_search;\n        trial && !LABEL_P (trial) && insns_to_search > 0;\n        trial = PREV_INSN (trial))\n     {"}, {"sha": "5d16100ef4875fedb21efc888e0ec6361af9ef08", "filename": "gcc/resource.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fresource.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -928,7 +928,7 @@ mark_target_live_regs (rtx_insn *insns, rtx target_maybe_return, struct resource\n     }\n \n   if (b == -1)\n-    b = find_basic_block (target, MAX_DELAY_SLOT_LIVE_SEARCH);\n+    b = find_basic_block (target, param_max_delay_slot_live_search);\n \n   if (target_hash_table != NULL)\n     {\n@@ -1289,7 +1289,7 @@ clear_hashed_info_for_insn (rtx_insn *insn)\n void\n incr_ticks_for_insn (rtx_insn *insn)\n {\n-  int b = find_basic_block (insn, MAX_DELAY_SLOT_LIVE_SEARCH);\n+  int b = find_basic_block (insn, param_max_delay_slot_live_search);\n \n   if (b != -1)\n     bb_ticks[b]++;"}, {"sha": "7a4daeaf4588b1ae3d58e1de3720b5a45469788b", "filename": "gcc/sanopt.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsanopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsanopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsanopt.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1289,8 +1289,8 @@ pass_sanopt::execute (function *fun)\n   if (asan_sanitize_stack_p ())\n     sanitize_rewrite_addressable_params (fun);\n \n-  bool use_calls = ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD < INT_MAX\n-    && asan_num_accesses >= ASAN_INSTRUMENTATION_WITH_CALL_THRESHOLD;\n+  bool use_calls = param_asan_instrumentation_with_call_threshold < INT_MAX\n+    && asan_num_accesses >= param_asan_instrumentation_with_call_threshold;\n \n   hash_map<tree, tree> shadow_vars_mapping;\n   bool need_commit_edge_insert = false;"}, {"sha": "7cd2e65ccac01c86f51b0b83d9b20b1c4920f329", "filename": "gcc/sched-deps.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-deps.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-deps.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-deps.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2480,7 +2480,7 @@ sched_analyze_1 (class deps_desc *deps, rtx x, rtx_insn *insn)\n       /* Pending lists can't get larger with a readonly context.  */\n       if (!deps->readonly\n           && ((deps->pending_read_list_length + deps->pending_write_list_length)\n-              >= MAX_PENDING_LIST_LENGTH))\n+\t      >= param_max_pending_list_length))\n \t{\n \t  /* Flush all pending reads and writes to prevent the pending lists\n \t     from getting any larger.  Insn scheduling runs too slowly when\n@@ -2697,7 +2697,7 @@ sched_analyze_2 (class deps_desc *deps, rtx x, rtx_insn *insn)\n \t  {\n \t    if ((deps->pending_read_list_length\n \t\t + deps->pending_write_list_length)\n-\t\t>= MAX_PENDING_LIST_LENGTH\n+\t\t>= param_max_pending_list_length\n \t\t&& !DEBUG_INSN_P (insn))\n \t      flush_pending_lists (deps, insn, true, true);\n \t    add_insn_mem_dependence (deps, true, insn, x);\n@@ -3222,8 +3222,8 @@ sched_analyze_insn (class deps_desc *deps, rtx x, rtx_insn *insn)\n \t  EXECUTE_IF_SET_IN_REG_SET (reg_pending_clobbers, 0, i, rsi)\n \t    {\n \t      struct deps_reg *reg_last = &deps->reg_last[i];\n-\t      if (reg_last->uses_length >= MAX_PENDING_LIST_LENGTH\n-\t\t  || reg_last->clobbers_length >= MAX_PENDING_LIST_LENGTH)\n+\t      if (reg_last->uses_length >= param_max_pending_list_length\n+\t\t  || reg_last->clobbers_length >= param_max_pending_list_length)\n \t\t{\n \t\t  add_dependence_list_and_free (deps, insn, &reg_last->sets, 0,\n \t\t\t\t\t\tREG_DEP_OUTPUT, false);\n@@ -3679,8 +3679,8 @@ deps_analyze_insn (class deps_desc *deps, rtx_insn *insn)\n                && sel_insn_is_speculation_check (insn)))\n         {\n           /* Keep the list a reasonable size.  */\n-          if (deps->pending_flush_length++ >= MAX_PENDING_LIST_LENGTH)\n-            flush_pending_lists (deps, insn, true, true);\n+\t  if (deps->pending_flush_length++ >= param_max_pending_list_length)\n+\t    flush_pending_lists (deps, insn, true, true);\n           else\n \t    deps->pending_jump_insns\n               = alloc_INSN_LIST (insn, deps->pending_jump_insns);"}, {"sha": "c60afa340e7122b1a66b9810069c6e27b1b374e0", "filename": "gcc/sched-ebb.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-ebb.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-ebb.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-ebb.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -620,9 +620,9 @@ schedule_ebbs (void)\n     return;\n \n   if (profile_info && profile_status_for_fn (cfun) == PROFILE_READ)\n-    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n+    probability_cutoff = param_tracer_min_branch_probability_feedback;\n   else\n-    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n+    probability_cutoff = param_tracer_min_branch_probability;\n   probability_cutoff = REG_BR_PROB_BASE / 100 * probability_cutoff;\n \n   schedule_ebbs_init ();"}, {"sha": "6321692ed0004e71e0a12741e418c2c1d9cc6f48", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -485,9 +485,9 @@ find_single_block_region (bool ebbs_p)\n   if (ebbs_p) {\n     int probability_cutoff;\n     if (profile_info && profile_status_for_fn (cfun) == PROFILE_READ)\n-      probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n+      probability_cutoff = param_tracer_min_branch_probability_feedback;\n     else\n-      probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n+      probability_cutoff = param_tracer_min_branch_probability;\n     probability_cutoff = REG_BR_PROB_BASE / 100 * probability_cutoff;\n \n     FOR_EACH_BB_FN (ebb_start, cfun)\n@@ -569,8 +569,8 @@ too_large (int block, int *num_bbs, int *num_insns)\n   (*num_insns) += (common_sched_info->estimate_number_of_insns\n                    (BASIC_BLOCK_FOR_FN (cfun, block)));\n \n-  return ((*num_bbs > PARAM_VALUE (PARAM_MAX_SCHED_REGION_BLOCKS))\n-\t  || (*num_insns > PARAM_VALUE (PARAM_MAX_SCHED_REGION_INSNS)));\n+  return ((*num_bbs > param_max_sched_region_blocks)\n+\t  || (*num_insns > param_max_sched_region_insns));\n }\n \n /* Update_loop_relations(blk, hdr): Check if the loop headed by max_hdr[blk]\n@@ -800,7 +800,7 @@ haifa_find_rgns (void)\n \n       queue = XNEWVEC (int, n_basic_blocks_for_fn (cfun));\n \n-      extend_regions_p = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS) > 0;\n+      extend_regions_p = param_max_sched_extend_regions_iters > 0;\n       if (extend_regions_p)\n         {\n           degree1 = XNEWVEC (int, last_basic_block_for_fn (cfun));\n@@ -1161,7 +1161,7 @@ extend_rgns (int *degree, int *idxp, sbitmap header, int *loop_hdr)\n   int *order, i, rescan = 0, idx = *idxp, iter = 0, max_iter, *max_hdr;\n   int nblocks = n_basic_blocks_for_fn (cfun) - NUM_FIXED_BLOCKS;\n \n-  max_iter = PARAM_VALUE (PARAM_MAX_SCHED_EXTEND_REGIONS_ITERS);\n+  max_iter = param_max_sched_extend_regions_iters;\n \n   max_hdr = XNEWVEC (int, last_basic_block_for_fn (cfun));\n \n@@ -2224,7 +2224,7 @@ new_ready (rtx_insn *next, ds_t ts)\n \t  || (IS_SPECULATIVE_INSN (next)\n \t      && ((recog_memoized (next) >= 0\n \t\t   && min_insn_conflict_delay (curr_state, next, next)\n-                   > PARAM_VALUE (PARAM_MAX_SCHED_INSN_CONFLICT_DELAY))\n+\t\t   > param_max_sched_insn_conflict_delay)\n                   || IS_SPECULATION_CHECK_P (next)\n \t\t  || !check_live (next, INSN_BB (next))\n \t\t  || (not_ex_free = !is_exception_free (next, INSN_BB (next),\n@@ -3188,8 +3188,9 @@ schedule_region (int rgn)\n \t  f = find_fallthru_edge (last_bb->succs);\n \t  if (f\n \t      && (!f->probability.initialized_p ()\n-\t\t  || f->probability.to_reg_br_prob_base () * 100 / REG_BR_PROB_BASE >=\n-\t             PARAM_VALUE (PARAM_SCHED_STATE_EDGE_PROB_CUTOFF)))\n+\t\t  || (f->probability.to_reg_br_prob_base () * 100\n+\t\t      / REG_BR_PROB_BASE\n+\t\t      >= param_sched_state_edge_prob_cutoff)))\n \t    {\n \t      memcpy (bb_state[f->dest->index], curr_state,\n \t\t      dfa_state_size);\n@@ -3229,7 +3230,7 @@ schedule_region (int rgn)\n void\n sched_rgn_init (bool single_blocks_p)\n {\n-  min_spec_prob = ((PARAM_VALUE (PARAM_MIN_SPEC_PROB) * REG_BR_PROB_BASE)\n+  min_spec_prob = ((param_min_spec_prob * REG_BR_PROB_BASE)\n \t\t    / 100);\n \n   nr_inter = 0;"}, {"sha": "d6513b136a0c132d835451dc87dd7471fe42656b", "filename": "gcc/sel-sched-ir.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched-ir.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched-ir.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -6012,7 +6012,7 @@ make_region_from_loop (class loop *loop)\n   basic_block preheader_block;\n \n   if (loop->num_nodes\n-      > (unsigned) PARAM_VALUE (PARAM_MAX_PIPELINE_REGION_BLOCKS))\n+      > (unsigned) param_max_pipeline_region_blocks)\n     return -1;\n \n   /* Don't pipeline loops whose latch belongs to some of its inner loops.  */\n@@ -6021,7 +6021,7 @@ make_region_from_loop (class loop *loop)\n       return -1;\n \n   loop->ninsns = num_loop_insns (loop);\n-  if ((int) loop->ninsns > PARAM_VALUE (PARAM_MAX_PIPELINE_REGION_INSNS))\n+  if ((int) loop->ninsns > param_max_pipeline_region_insns)\n     return -1;\n \n   loop_blocks = get_loop_body_in_custom_order (loop, bb_top_order_comparator);"}, {"sha": "531b0129cd9a4f104ef52d512b17e7ef799ec118", "filename": "gcc/sel-sched-ir.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched-ir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched-ir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched-ir.h?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -969,7 +969,7 @@ extern bool preheader_removed;\n /* Software lookahead window size.\n    According to the results in Nakatani and Ebcioglu [1993], window size of 16\n    is enough to extract most ILP in integer code.  */\n-#define MAX_WS (PARAM_VALUE (PARAM_SELSCHED_MAX_LOOKAHEAD))\n+#define MAX_WS (param_selsched_max_lookahead)\n \n extern regset sel_all_regs;\n \f"}, {"sha": "2ecc06d0f173a11642cddcdd866e56c348afc28e", "filename": "gcc/sel-sched.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fsel-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsel-sched.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3454,7 +3454,7 @@ process_pipelined_exprs (av_set_t *av_ptr)\n   FOR_EACH_EXPR_1 (expr, si, av_ptr)\n     {\n       if (EXPR_SCHED_TIMES (expr)\n-\t  >= PARAM_VALUE (PARAM_SELSCHED_MAX_SCHED_TIMES))\n+\t  >= param_selsched_max_sched_times)\n \tav_set_iter_remove (&si);\n     }\n }\n@@ -6806,7 +6806,7 @@ sel_setup_region_sched_flags (void)\n                   && (flag_sel_sched_pipelining != 0)\n \t\t  && current_loop_nest != NULL\n \t\t  && loop_has_exit_edges (current_loop_nest));\n-  max_insns_to_rename = PARAM_VALUE (PARAM_SELSCHED_INSNS_TO_RENAME);\n+  max_insns_to_rename = param_selsched_insns_to_rename;\n   max_ws = MAX_WS;\n }\n "}, {"sha": "e612f85c15ad77f1182680778e70d1d06828e44c", "filename": "gcc/shrink-wrap.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fshrink-wrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fshrink-wrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fshrink-wrap.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -775,7 +775,7 @@ try_shrink_wrapping (edge *entry_edge, rtx_insn *prologue_seq)\n   vec.quick_push (pro);\n \n   unsigned max_grow_size = get_uncond_jump_length ();\n-  max_grow_size *= PARAM_VALUE (PARAM_MAX_GROW_COPY_BB_INSNS);\n+  max_grow_size *= param_max_grow_copy_bb_insns;\n \n   while (!vec.is_empty () && pro != entry)\n     {"}, {"sha": "2f26e468b8abf285b61eb0868cfdf592feb530fe", "filename": "gcc/targhooks.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2274,17 +2274,18 @@ default_max_noce_ifcvt_seq_cost (edge e)\n {\n   bool predictable_p = predictable_edge_p (e);\n \n-  enum compiler_param param\n-    = (predictable_p\n-       ? PARAM_MAX_RTL_IF_CONVERSION_PREDICTABLE_COST\n-       : PARAM_MAX_RTL_IF_CONVERSION_UNPREDICTABLE_COST);\n-\n-  /* If we have a parameter set, use that, otherwise take a guess using\n-     BRANCH_COST.  */\n-  if (global_options_set.x_param_values[param])\n-    return PARAM_VALUE (param);\n+  if (predictable_p)\n+    {\n+      if (global_options_set.x_param_max_rtl_if_conversion_predictable_cost)\n+\treturn param_max_rtl_if_conversion_predictable_cost;\n+    }\n   else\n-    return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (3);\n+    {\n+      if (global_options_set.x_param_max_rtl_if_conversion_unpredictable_cost)\n+\treturn param_max_rtl_if_conversion_unpredictable_cost;\n+    }\n+\n+  return BRANCH_COST (true, predictable_p) * COSTS_N_INSNS (3);\n }\n \n /* Default implementation of TARGET_MIN_ARITHMETIC_PRECISION.  */"}, {"sha": "a836646f8a116765ba9dfa250e859298f7328a91", "filename": "gcc/toplev.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -679,7 +679,7 @@ print_version (FILE *file, const char *indent, bool show_global_state)\n       fprintf (file,\n \t       file == stderr ? _(fmt4) : fmt4,\n \t       indent, *indent != 0 ? \" \" : \"\",\n-\t       PARAM_VALUE (GGC_MIN_EXPAND), PARAM_VALUE (GGC_MIN_HEAPSIZE));\n+\t       param_ggc_min_expand, param_ggc_min_heapsize);\n \n       print_plugins_versions (file, indent);\n     }\n@@ -1863,7 +1863,7 @@ process_options (void)\n \n   if (flag_checking >= 2)\n     hash_table_sanitize_eq_limit\n-      = PARAM_VALUE (PARAM_HASH_TABLE_VERIFICATION_LIMIT);\n+      = param_hash_table_verification_limit;\n \n   /* Please don't change global_options after this point, those changes won't\n      be reflected in optimization_{default,current}_node.  */"}, {"sha": "02203923369423946618f342433fcaa6b722a155", "filename": "gcc/tracer.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftracer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftracer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftracer.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -276,13 +276,13 @@ tail_duplicate (void)\n   initialize_original_copy_tables ();\n \n   if (profile_info && profile_status_for_fn (cfun) == PROFILE_READ)\n-    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY_FEEDBACK);\n+    probability_cutoff = param_tracer_min_branch_probability_feedback;\n   else\n-    probability_cutoff = PARAM_VALUE (TRACER_MIN_BRANCH_PROBABILITY);\n+    probability_cutoff = param_tracer_min_branch_probability;\n   probability_cutoff = REG_BR_PROB_BASE / 100 * probability_cutoff;\n \n   branch_ratio_cutoff =\n-    (REG_BR_PROB_BASE / 100 * PARAM_VALUE (TRACER_MIN_BRANCH_RATIO));\n+    (REG_BR_PROB_BASE / 100 * param_tracer_min_branch_ratio);\n \n   FOR_EACH_BB_FN (bb, cfun)\n     {\n@@ -296,11 +296,11 @@ tail_duplicate (void)\n     }\n \n   if (profile_info && profile_status_for_fn (cfun) == PROFILE_READ)\n-    cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE_FEEDBACK);\n+    cover_insns = param_tracer_dynamic_coverage_feedback;\n   else\n-    cover_insns = PARAM_VALUE (TRACER_DYNAMIC_COVERAGE);\n+    cover_insns = param_tracer_dynamic_coverage;\n   cover_insns = (weighted_insns * cover_insns + 50) / 100;\n-  max_dup_insns = (ninsns * PARAM_VALUE (TRACER_MAX_CODE_GROWTH) + 50) / 100;\n+  max_dup_insns = (ninsns * param_tracer_max_code_growth + 50) / 100;\n \n   while (traced_insns < cover_insns && nduplicated < max_dup_insns\n          && !heap.empty ())"}, {"sha": "4a0f6e7dee97135a5a973f480fde318f8c501a28", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1108,7 +1108,7 @@ tm_log_add (basic_block entry_block, tree addr, gimple *stmt)\n \t  && TYPE_SIZE_UNIT (type) != NULL\n \t  && tree_fits_uhwi_p (TYPE_SIZE_UNIT (type))\n \t  && ((HOST_WIDE_INT) tree_to_uhwi (TYPE_SIZE_UNIT (type))\n-\t      < PARAM_VALUE (PARAM_TM_MAX_AGGREGATE_SIZE))\n+\t      < param_tm_max_aggregate_size)\n \t  /* We must be able to copy this type normally.  I.e., no\n \t     special constructors and the like.  */\n \t  && !TREE_ADDRESSABLE (type))"}, {"sha": "8d5fce30289b0bff2d3c620ecb72fe281b1a922d", "filename": "gcc/tree-chrec.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-chrec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-chrec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-chrec.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -333,9 +333,9 @@ chrec_fold_plus_1 (enum tree_code code, tree type,\n \t    int size = 0;\n \t    if ((tree_contains_chrecs (op0, &size)\n \t\t || tree_contains_chrecs (op1, &size))\n-\t\t&& size < PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n+\t\t&& size < param_scev_max_expr_size)\n \t      return build2 (code, type, op0, op1);\n-\t    else if (size < PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n+\t    else if (size < param_scev_max_expr_size)\n \t      {\n \t\tif (code == POINTER_PLUS_EXPR)\n \t\t  return fold_build_pointer_plus (fold_convert (type, op0),"}, {"sha": "e9fa4ae69c3591dc229ae83a07fd2d57efb26719", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -836,7 +836,7 @@ split_constant_offset (tree exp, tree *var, tree *off,\n void\n split_constant_offset (tree exp, tree *var, tree *off)\n {\n-  unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n+  unsigned limit = param_ssa_name_def_chain_limit;\n   static hash_map<tree, std::pair<tree, tree> > *cache;\n   if (!cache)\n     cache = new hash_map<tree, std::pair<tree, tree> > (37);\n@@ -4917,7 +4917,7 @@ compute_all_dependences (vec<data_reference_p> datarefs,\n   unsigned int i, j;\n \n   if ((int) datarefs.length ()\n-      > PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+      > param_loop_max_datarefs_for_datadeps)\n     {\n       struct data_dependence_relation *ddr;\n "}, {"sha": "09560198539477274b5b8ea92e092712be1f7622", "filename": "gcc/tree-if-conv.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-if-conv.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-if-conv.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-if-conv.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -125,7 +125,7 @@ along with GCC; see the file COPYING3.  If not see\n /* Only handle PHIs with no more arguments unless we are asked to by\n    simd pragma.  */\n #define MAX_PHI_ARG_NUM \\\n-  ((unsigned) PARAM_VALUE (PARAM_MAX_TREE_IF_CONVERSION_PHI_ARGS))\n+  ((unsigned) param_max_tree_if_conversion_phi_args)\n \n /* True if we've converted a statement that was only executed when some\n    condition C was true, and if for correctness we need to predicate the"}, {"sha": "b05f05d446a61da35ea1cf0d3bce7f24aac46aac", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1812,7 +1812,7 @@ remap_gimple_stmt (gimple *stmt, copy_body_data *id)\n \t  /* If the inlined function has too many debug markers,\n \t     don't copy them.  */\n \t  if (id->src_cfun->debug_marker_count\n-\t      > PARAM_VALUE (PARAM_MAX_DEBUG_MARKER_COUNT))\n+\t      > param_max_debug_marker_count)\n \t    return stmts;\n \n \t  gdebug *copy = as_a <gdebug *> (gimple_copy (stmt));"}, {"sha": "9930daaafa995e0dd1367e2d2bedbda0c6dac158", "filename": "gcc/tree-loop-distribution.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-loop-distribution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-loop-distribution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-loop-distribution.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -119,7 +119,7 @@ along with GCC; see the file COPYING3.  If not see\n \n \n #define MAX_DATAREFS_NUM \\\n-\t((unsigned) PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+\t((unsigned) param_loop_max_datarefs_for_datadeps)\n \n /* Threshold controlling number of distributed partitions.  Given it may\n    be unnecessary if a memory stream cost model is invented in the future,"}, {"sha": "1a35c7dbdc3a59ea9942f944f1d6052ef6ee877e", "filename": "gcc/tree-parloops.c", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-parloops.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-parloops.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-parloops.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -890,7 +890,7 @@ parloops_force_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info\n \n /* Minimal number of iterations of a loop that should be executed in each\n    thread.  */\n-#define MIN_PER_THREAD PARAM_VALUE (PARAM_PARLOOPS_MIN_PER_THREAD)\n+#define MIN_PER_THREAD param_parloops_min_per_thread\n \n /* Element of the hashtable, representing a\n    reduction in the current loop.  */\n@@ -2875,25 +2875,23 @@ create_parallel_loop (class loop *loop, tree loop_fn, tree data,\n   else\n     {\n       t = build_omp_clause (loc, OMP_CLAUSE_SCHEDULE);\n-      int chunk_size = PARAM_VALUE (PARAM_PARLOOPS_CHUNK_SIZE);\n-      enum PARAM_PARLOOPS_SCHEDULE_KIND schedule_type \\\n-\t= (enum PARAM_PARLOOPS_SCHEDULE_KIND) PARAM_VALUE (PARAM_PARLOOPS_SCHEDULE);\n-      switch (schedule_type)\n+      int chunk_size = param_parloops_chunk_size;\n+      switch (param_parloops_schedule)\n \t{\n-\tcase PARAM_PARLOOPS_SCHEDULE_KIND_static:\n+\tcase PARLOOPS_SCHEDULE_STATIC:\n \t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_STATIC;\n \t  break;\n-\tcase PARAM_PARLOOPS_SCHEDULE_KIND_dynamic:\n+\tcase PARLOOPS_SCHEDULE_DYNAMIC:\n \t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_DYNAMIC;\n \t  break;\n-\tcase PARAM_PARLOOPS_SCHEDULE_KIND_guided:\n+\tcase PARLOOPS_SCHEDULE_GUIDED:\n \t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_GUIDED;\n \t  break;\n-\tcase PARAM_PARLOOPS_SCHEDULE_KIND_auto:\n+\tcase PARLOOPS_SCHEDULE_AUTO:\n \t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_AUTO;\n \t  chunk_size = 0;\n \t  break;\n-\tcase PARAM_PARLOOPS_SCHEDULE_KIND_runtime:\n+\tcase PARLOOPS_SCHEDULE_RUNTIME:\n \t  OMP_CLAUSE_SCHEDULE_KIND (t) = OMP_CLAUSE_SCHEDULE_RUNTIME;\n \t  chunk_size = 0;\n \t  break;"}, {"sha": "3fe2a6dcb0ae22f53750a937c03d2a78c645b7af", "filename": "gcc/tree-predcom.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-predcom.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-predcom.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-predcom.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2194,7 +2194,7 @@ determine_unroll_factor (vec<chain_p> chains)\n {\n   chain_p chain;\n   unsigned factor = 1, af, nfactor, i;\n-  unsigned max = PARAM_VALUE (PARAM_MAX_UNROLL_TIMES);\n+  unsigned max = param_max_unroll_times;\n \n   FOR_EACH_VEC_ELT (chains, i, chain)\n     {"}, {"sha": "ed5d5663a3a85bcacbce6ebf66a98064297a3c4e", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1149,7 +1149,7 @@ follow_ssa_edge_expr (class loop *loop, gimple *at_stmt, tree expr,\n \treturn t_false;\n \n       /* Give up if the path is longer than the MAX that we allow.  */\n-      if (limit > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_COMPLEXITY))\n+      if (limit > param_scev_max_expr_complexity)\n \t{\n \t  *evolution_of_loop = chrec_dont_know;\n \t  return t_dont_know;\n@@ -2623,7 +2623,7 @@ instantiate_scev_r (edge instantiate_below,\n \t\t    bool *fold_conversions, int size_expr)\n {\n   /* Give up if the expression is larger than the MAX that we allow.  */\n-  if (size_expr++ > PARAM_VALUE (PARAM_SCEV_MAX_EXPR_SIZE))\n+  if (size_expr++ > param_scev_max_expr_size)\n     return chrec_dont_know;\n \n   if (chrec == NULL_TREE"}, {"sha": "d739aed9e446d0d099f470d37af04dec5cda054b", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2787,16 +2787,21 @@ analyze_all_variable_accesses (void)\n   unsigned i;\n   bool optimize_speed_p = !optimize_function_for_size_p (cfun);\n \n-  enum compiler_param param = optimize_speed_p\n-\t\t\t? PARAM_SRA_MAX_SCALARIZATION_SIZE_SPEED\n-\t\t\t: PARAM_SRA_MAX_SCALARIZATION_SIZE_SIZE;\n-\n   /* If the user didn't set PARAM_SRA_MAX_SCALARIZATION_SIZE_<...>,\n      fall back to a target default.  */\n   unsigned HOST_WIDE_INT max_scalarization_size\n-    = global_options_set.x_param_values[param]\n-      ? PARAM_VALUE (param)\n-      : get_move_ratio (optimize_speed_p) * UNITS_PER_WORD;\n+    = get_move_ratio (optimize_speed_p) * UNITS_PER_WORD;\n+\n+  if (optimize_speed_p)\n+    {\n+      if (global_options_set.x_param_sra_max_scalarization_size_speed)\n+\tmax_scalarization_size = param_sra_max_scalarization_size_speed;\n+    }\n+  else\n+    {\n+      if (global_options_set.x_param_sra_max_scalarization_size_size)\n+\tmax_scalarization_size = param_sra_max_scalarization_size_size;\n+    }\n \n   max_scalarization_size *= BITS_PER_UNIT;\n "}, {"sha": "335787e0517c750e6cf82820a67c3d194f3f0adf", "filename": "gcc/tree-ssa-ccp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-ccp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-ccp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ccp.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2195,7 +2195,7 @@ fold_builtin_alloca_with_align (gimple *stmt)\n   size = tree_to_uhwi (arg);\n \n   /* Heuristic: don't fold large allocas.  */\n-  threshold = (unsigned HOST_WIDE_INT)PARAM_VALUE (PARAM_LARGE_STACK_FRAME);\n+  threshold = (unsigned HOST_WIDE_INT)param_large_stack_frame;\n   /* In case the alloca is located at function entry, it has the same lifetime\n      as a declared array, so we allow a larger size.  */\n   block = gimple_block (stmt);"}, {"sha": "1b060d9e408f6f75af9906f3af49c2042bf98f55", "filename": "gcc/tree-ssa-dse.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-dse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-dse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dse.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -238,7 +238,7 @@ setup_live_bytes_from_ref (ao_ref *ref, sbitmap live_bytes)\n   if (valid_ao_ref_for_dse (ref)\n       && ref->size.is_constant (&const_size)\n       && (const_size / BITS_PER_UNIT\n-\t  <= PARAM_VALUE (PARAM_DSE_MAX_OBJECT_SIZE)))\n+\t  <= param_dse_max_object_size))\n     {\n       bitmap_clear (live_bytes);\n       bitmap_set_range (live_bytes, 0, const_size / BITS_PER_UNIT);\n@@ -611,7 +611,7 @@ dse_optimize_redundant_stores (gimple *stmt)\n   FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n     {\n       /* Limit stmt walking.  */\n-      if (++cnt > PARAM_VALUE (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE))\n+      if (++cnt > param_dse_max_alias_queries_per_store)\n \tBREAK_FROM_IMM_USE_STMT (ui);\n \n       /* If USE_STMT stores 0 into one or more of the same locations\n@@ -704,7 +704,7 @@ dse_classify_store (ao_ref *ref, gimple *stmt,\n       FOR_EACH_IMM_USE_STMT (use_stmt, ui, defvar)\n \t{\n \t  /* Limit stmt walking.  */\n-\t  if (++cnt > PARAM_VALUE (PARAM_DSE_MAX_ALIAS_QUERIES_PER_STORE))\n+\t  if (++cnt > param_dse_max_alias_queries_per_store)\n \t    {\n \t      fail = true;\n \t      BREAK_FROM_IMM_USE_STMT (ui);\n@@ -853,7 +853,7 @@ class dse_dom_walker : public dom_walker\n public:\n   dse_dom_walker (cdi_direction direction)\n     : dom_walker (direction),\n-    m_live_bytes (PARAM_VALUE (PARAM_DSE_MAX_OBJECT_SIZE)),\n+    m_live_bytes (param_dse_max_object_size),\n     m_byte_tracking_enabled (false) {}\n \n   virtual edge before_dom_children (basic_block);"}, {"sha": "fa3bc0a437773f9c6aa3247c1b7b60884fb1cadf", "filename": "gcc/tree-ssa-ifcombine.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-ifcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-ifcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-ifcombine.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -565,9 +565,9 @@ ifcombine_ifandif (basic_block inner_cond_bb, bool inner_inv,\n \t  tree t1, t2;\n \t  gimple_stmt_iterator gsi;\n \t  bool logical_op_non_short_circuit = LOGICAL_OP_NON_SHORT_CIRCUIT;\n-\t  if (PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT) != -1)\n+\t  if (param_logical_op_non_short_circuit != -1)\n \t    logical_op_non_short_circuit\n-\t      = PARAM_VALUE (PARAM_LOGICAL_OP_NON_SHORT_CIRCUIT);\n+\t      = param_logical_op_non_short_circuit;\n \t  if (!logical_op_non_short_circuit || flag_sanitize_coverage)\n \t    return false;\n \t  /* Only do this optimization if the inner bb contains only the conditional. */"}, {"sha": "fd6d74d589136f264e5108a1081f8bc498d3f603", "filename": "gcc/tree-ssa-loop-ch.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ch.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -368,7 +368,7 @@ ch_base::copy_headers (function *fun)\n \n   FOR_EACH_LOOP (loop, 0)\n     {\n-      int initial_limit = PARAM_VALUE (PARAM_MAX_LOOP_HEADER_INSNS);\n+      int initial_limit = param_max_loop_header_insns;\n       int remaining_limit = initial_limit;\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,"}, {"sha": "cd1aa563e21b1df45c1a2e04b496f2e0e36dabe4", "filename": "gcc/tree-ssa-loop-im.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-im.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-im.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-im.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -230,7 +230,7 @@ static bool ref_indep_loop_p (class loop *, im_mem_ref *);\n static bool ref_always_accessed_p (class loop *, im_mem_ref *, bool);\n \n /* Minimum cost of an expensive expression.  */\n-#define LIM_EXPENSIVE ((unsigned) PARAM_VALUE (PARAM_LIM_EXPENSIVE))\n+#define LIM_EXPENSIVE ((unsigned) param_lim_expensive)\n \n /* The outermost loop for which execution of the header guarantees that the\n    block will be executed.  */"}, {"sha": "7b3524312259d8657be54ba479d706084ed93d86", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -739,7 +739,7 @@ try_unroll_loop_completely (class loop *loop,\n     return false;\n \n   if (!loop->unroll\n-      && n_unroll > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEEL_TIMES))\n+      && n_unroll > (unsigned) param_max_completely_peel_times)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"Not unrolling loop %d \"\n@@ -780,7 +780,7 @@ try_unroll_loop_completely (class loop *loop,\n \t  bool large\n \t    = tree_estimate_loop_size\n \t\t(loop, remove_exit ? exit : NULL, edge_to_cancel, &size,\n-\t\t PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS));\n+\t\t param_max_completely_peeled_insns);\n \t  if (large)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -864,7 +864,7 @@ try_unroll_loop_completely (class loop *loop,\n \t     blow the branch predictor tables.  Limit number of\n \t     branches on the hot path through the peeled sequence.  */\n \t  else if (size.num_branches_on_hot_path * (int)n_unroll\n-\t\t   > PARAM_VALUE (PARAM_MAX_PEEL_BRANCHES))\n+\t\t   > param_max_peel_branches)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n@@ -874,7 +874,7 @@ try_unroll_loop_completely (class loop *loop,\n \t      return false;\n \t    }\n \t  else if (unr_insns\n-\t\t   > (unsigned) PARAM_VALUE (PARAM_MAX_COMPLETELY_PEELED_INSNS))\n+\t\t   > (unsigned) param_max_completely_peeled_insns)\n \t    {\n \t      if (dump_file && (dump_flags & TDF_DETAILS))\n \t\tfprintf (dump_file, \"Not unrolling loop %d: \"\n@@ -998,7 +998,7 @@ try_peel_loop (class loop *loop,\n   int peeled_size;\n \n   if (!flag_peel_loops\n-      || PARAM_VALUE (PARAM_MAX_PEEL_TIMES) <= 0\n+      || param_max_peel_times <= 0\n       || !peeled_loops)\n     return false;\n \n@@ -1057,7 +1057,7 @@ try_peel_loop (class loop *loop,\n   /* We want to peel estimated number of iterations + 1 (so we never\n      enter the loop on quick path).  Check against PARAM_MAX_PEEL_TIMES\n      and be sure to avoid overflows.  */\n-  if (npeel > PARAM_VALUE (PARAM_MAX_PEEL_TIMES) - 1)\n+  if (npeel > param_max_peel_times - 1)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not peeling: rolls too much \"\n@@ -1068,9 +1068,9 @@ try_peel_loop (class loop *loop,\n \n   /* Check peeled loops size.  */\n   tree_estimate_loop_size (loop, exit, NULL, &size,\n-\t\t\t   PARAM_VALUE (PARAM_MAX_PEELED_INSNS));\n+\t\t\t   param_max_peeled_insns);\n   if ((peeled_size = estimated_peeled_sequence_size (&size, (int) npeel))\n-      > PARAM_VALUE (PARAM_MAX_PEELED_INSNS))\n+      > param_max_peeled_insns)\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not peeling: peeled sequence size is too large \"\n@@ -1502,7 +1502,7 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n         BITMAP_FREE (loop_closed_ssa_invalidated);\n     }\n   while (changed\n-\t && ++iteration <= PARAM_VALUE (PARAM_MAX_UNROLL_ITERATIONS));\n+\t && ++iteration <= param_max_unroll_iterations);\n \n   BITMAP_FREE (father_bbs);\n "}, {"sha": "78efd62a9a5afc647fdae5a7d627a81c5ab19463", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -152,8 +152,8 @@ avg_loop_niter (class loop *loop)\n     {\n       niter = likely_max_stmt_executions_int (loop);\n \n-      if (niter == -1 || niter > PARAM_VALUE (PARAM_AVG_LOOP_NITER))\n-\treturn PARAM_VALUE (PARAM_AVG_LOOP_NITER);\n+      if (niter == -1 || niter > param_avg_loop_niter)\n+\treturn param_avg_loop_niter;\n     }\n \n   return niter;\n@@ -716,19 +716,19 @@ struct iv_ca_delta\n /* Bound on number of candidates below that all candidates are considered.  */\n \n #define CONSIDER_ALL_CANDIDATES_BOUND \\\n-  ((unsigned) PARAM_VALUE (PARAM_IV_CONSIDER_ALL_CANDIDATES_BOUND))\n+  ((unsigned) param_iv_consider_all_candidates_bound)\n \n /* If there are more iv occurrences, we just give up (it is quite unlikely that\n    optimizing such a loop would help, and it would take ages).  */\n \n #define MAX_CONSIDERED_GROUPS \\\n-  ((unsigned) PARAM_VALUE (PARAM_IV_MAX_CONSIDERED_USES))\n+  ((unsigned) param_iv_max_considered_uses)\n \n /* If there are at most this number of ivs in the set, try removing unnecessary\n    ivs from the set always.  */\n \n #define ALWAYS_PRUNE_CAND_SET_BOUND \\\n-  ((unsigned) PARAM_VALUE (PARAM_IV_ALWAYS_PRUNE_CAND_SET_BOUND))\n+  ((unsigned) param_iv_always_prune_cand_set_bound)\n \n /* The list of trees for that the decl_rtl field must be reset is stored\n    here.  */"}, {"sha": "06f9016004739d8df75f2b3c47dea7a7cae99fd0", "filename": "gcc/tree-ssa-loop-manip.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-manip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-manip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-manip.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -984,7 +984,7 @@ can_unroll_loop_p (class loop *loop, unsigned factor,\n \n   /* The final loop should be small enough.  */\n   if (tree_num_loop_insns (loop, &eni_size_weights) * factor\n-      > (unsigned) PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS))\n+      > (unsigned) param_max_unrolled_insns)\n     return false;\n \n   return true;"}, {"sha": "fe24a70451d350bd69fb4821b4cfbd7c78035bde", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2863,7 +2863,7 @@ finite_loop_p (class loop *loop)\n /* Bound on the number of iterations we try to evaluate.  */\n \n #define MAX_ITERATIONS_TO_TRACK \\\n-  ((unsigned) PARAM_VALUE (PARAM_MAX_ITERATIONS_TO_TRACK))\n+  ((unsigned) param_max_iterations_to_track)\n \n /* Returns the loop phi node of LOOP such that ssa name X is derived from its\n    result by a chain of operations such that all but exactly one of their"}, {"sha": "cb22657c309364c9c73029362b1bd9757dea299b", "filename": "gcc/tree-ssa-loop-prefetch.c", "status": "modified", "additions": 27, "deletions": 23, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-prefetch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-prefetch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-prefetch.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -167,7 +167,7 @@ along with GCC; see the file COPYING3.  If not see\n    of cache hierarchy).  */\n \n #ifndef PREFETCH_BLOCK\n-#define PREFETCH_BLOCK L1_CACHE_LINE_SIZE\n+#define PREFETCH_BLOCK param_l1_cache_line_size\n #endif\n \n /* Do we have a forward hardware sequential prefetching?  */\n@@ -191,8 +191,8 @@ along with GCC; see the file COPYING3.  If not see\n #define ACCEPTABLE_MISS_RATE 50\n #endif\n \n-#define L1_CACHE_SIZE_BYTES ((unsigned) (L1_CACHE_SIZE * 1024))\n-#define L2_CACHE_SIZE_BYTES ((unsigned) (L2_CACHE_SIZE * 1024))\n+#define L1_CACHE_SIZE_BYTES ((unsigned) (param_l1_cache_size * 1024))\n+#define L2_CACHE_SIZE_BYTES ((unsigned) (param_l2_cache_size * 1024))\n \n /* We consider a memory access nontemporal if it is not reused sooner than\n    after L2_CACHE_SIZE_BYTES of memory are accessed.  However, we ignore\n@@ -993,7 +993,8 @@ static bool\n should_issue_prefetch_p (struct mem_ref *ref)\n {\n   /* Do we want to issue prefetches for non-constant strides?  */\n-  if (!cst_and_fits_in_hwi (ref->group->step) && PREFETCH_DYNAMIC_STRIDES == 0)\n+  if (!cst_and_fits_in_hwi (ref->group->step)\n+      && param_prefetch_dynamic_strides == 0)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -1008,14 +1009,14 @@ should_issue_prefetch_p (struct mem_ref *ref)\n      range.  */\n   if (cst_and_fits_in_hwi (ref->group->step)\n       && abs_hwi (int_cst_value (ref->group->step))\n-\t  < (HOST_WIDE_INT) PREFETCH_MINIMUM_STRIDE)\n+\t  < (HOST_WIDE_INT) param_prefetch_minimum_stride)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n \t\t \"Step for reference %u:%u (\" HOST_WIDE_INT_PRINT_DEC\n \t\t \") is less than the mininum required stride of %d\\n\",\n \t\t ref->group->uid, ref->uid, int_cst_value (ref->group->step),\n-\t\t PREFETCH_MINIMUM_STRIDE);\n+\t\t param_prefetch_minimum_stride);\n       return false;\n     }\n \n@@ -1055,8 +1056,9 @@ schedule_prefetches (struct mem_ref_group *groups, unsigned unroll_factor,\n   struct mem_ref *ref;\n   bool any = false;\n \n-  /* At most SIMULTANEOUS_PREFETCHES should be running at the same time.  */\n-  remaining_prefetch_slots = SIMULTANEOUS_PREFETCHES;\n+  /* At most param_simultaneous_prefetches should be running\n+     at the same time.  */\n+  remaining_prefetch_slots = param_simultaneous_prefetches;\n \n   /* The prefetch will run for AHEAD iterations of the original loop, i.e.,\n      AHEAD / UNROLL_FACTOR iterations of the unrolled loop.  In each iteration,\n@@ -1406,7 +1408,7 @@ determine_unroll_factor (class loop *loop, struct mem_ref_group *refs,\n      us from unrolling the loops too many times in cases where we only expect\n      gains from better scheduling and decreasing loop overhead, which is not\n      the case here.  */\n-  upper_bound = PARAM_VALUE (PARAM_MAX_UNROLLED_INSNS) / ninsns;\n+  upper_bound = param_max_unrolled_insns / ninsns;\n \n   /* If we unrolled the loop more times than it iterates, the unrolled version\n      of the loop would be never entered.  */\n@@ -1459,7 +1461,7 @@ volume_of_references (struct mem_ref_group *refs)\n \t   accessed in each iteration.  TODO -- in the latter case, we should\n \t   take the size of the reference into account, rounding it up on cache\n \t   line size multiple.  */\n-\tvolume += L1_CACHE_LINE_SIZE / ref->prefetch_mod;\n+\tvolume += param_l1_cache_line_size / ref->prefetch_mod;\n       }\n   return volume;\n }\n@@ -1512,7 +1514,7 @@ add_subscript_strides (tree access_fn, unsigned stride,\n       if (tree_fits_shwi_p (step))\n \tastep = tree_to_shwi (step);\n       else\n-\tastep = L1_CACHE_LINE_SIZE;\n+\tastep = param_l1_cache_line_size;\n \n       strides[n - 1 - loop_depth (loop) + loop_depth (aloop)] += astep * stride;\n \n@@ -1562,7 +1564,7 @@ self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n \t  if (tree_fits_uhwi_p (stride))\n \t    astride = tree_to_uhwi (stride);\n \t  else\n-\t    astride = L1_CACHE_LINE_SIZE;\n+\t    astride = param_l1_cache_line_size;\n \n \t  ref = TREE_OPERAND (ref, 0);\n \t}\n@@ -1578,7 +1580,7 @@ self_reuse_distance (data_reference_p dr, unsigned *loop_sizes, unsigned n,\n \n       s = strides[i] < 0 ?  -strides[i] : strides[i];\n \n-      if (s < (unsigned) L1_CACHE_LINE_SIZE\n+      if (s < (unsigned) param_l1_cache_line_size\n \t  && (loop_sizes[i]\n \t      > (unsigned) (L1_CACHE_SIZE_BYTES / NONTEMPORAL_FRACTION)))\n \t{\n@@ -1825,7 +1827,7 @@ mem_ref_count_reasonable_p (unsigned ninsns, unsigned mem_ref_count)\n      should account for cache misses.  */\n   insn_to_mem_ratio = ninsns / mem_ref_count;\n \n-  if (insn_to_mem_ratio < PREFETCH_MIN_INSN_TO_MEM_RATIO)\n+  if (insn_to_mem_ratio < param_prefetch_min_insn_to_mem_ratio)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n         fprintf (dump_file,\n@@ -1862,7 +1864,7 @@ insn_to_prefetch_ratio_too_small_p (unsigned ninsns, unsigned prefetch_count,\n      and the exit branches will get eliminated), so it might be better to use\n      tree_estimate_loop_size + estimated_unrolled_size.  */\n   insn_to_prefetch_ratio = (unroll_factor * ninsns) / prefetch_count;\n-  if (insn_to_prefetch_ratio < MIN_INSN_TO_PREFETCH_RATIO)\n+  if (insn_to_prefetch_ratio < param_min_insn_to_prefetch_ratio)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n         fprintf (dump_file,\n@@ -1902,7 +1904,7 @@ loop_prefetch_arrays (class loop *loop)\n   if (time == 0)\n     return false;\n \n-  ahead = (PREFETCH_LATENCY + time - 1) / time;\n+  ahead = (param_prefetch_latency + time - 1) / time;\n   est_niter = estimated_stmt_executions_int (loop);\n   if (est_niter == -1)\n     est_niter = likely_max_stmt_executions_int (loop);\n@@ -1998,17 +2000,19 @@ tree_ssa_prefetch_arrays (void)\n     {\n       fprintf (dump_file, \"Prefetching parameters:\\n\");\n       fprintf (dump_file, \"    simultaneous prefetches: %d\\n\",\n-\t       SIMULTANEOUS_PREFETCHES);\n-      fprintf (dump_file, \"    prefetch latency: %d\\n\", PREFETCH_LATENCY);\n+\t       param_simultaneous_prefetches);\n+      fprintf (dump_file, \"    prefetch latency: %d\\n\", param_prefetch_latency);\n       fprintf (dump_file, \"    prefetch block size: %d\\n\", PREFETCH_BLOCK);\n       fprintf (dump_file, \"    L1 cache size: %d lines, %d kB\\n\",\n-\t       L1_CACHE_SIZE_BYTES / L1_CACHE_LINE_SIZE, L1_CACHE_SIZE);\n-      fprintf (dump_file, \"    L1 cache line size: %d\\n\", L1_CACHE_LINE_SIZE);\n-      fprintf (dump_file, \"    L2 cache size: %d kB\\n\", L2_CACHE_SIZE);\n+\t       L1_CACHE_SIZE_BYTES / param_l1_cache_line_size,\n+\t       param_l1_cache_size);\n+      fprintf (dump_file, \"    L1 cache line size: %d\\n\",\n+\t       param_l1_cache_line_size);\n+      fprintf (dump_file, \"    L2 cache size: %d kB\\n\", param_l2_cache_size);\n       fprintf (dump_file, \"    min insn-to-prefetch ratio: %d \\n\",\n-\t       MIN_INSN_TO_PREFETCH_RATIO);\n+\t       param_min_insn_to_prefetch_ratio);\n       fprintf (dump_file, \"    min insn-to-mem ratio: %d \\n\",\n-\t       PREFETCH_MIN_INSN_TO_MEM_RATIO);\n+\t       param_prefetch_min_insn_to_mem_ratio);\n       fprintf (dump_file, \"\\n\");\n     }\n "}, {"sha": "57dbc8769dc3953f0d1cd16f8c4dd98ac8f07ea8", "filename": "gcc/tree-ssa-loop-split.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-split.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1404,15 +1404,14 @@ get_cond_branch_to_split_loop (struct loop *loop, gcond *cond)\n   profile_probability prob = invar_branch->probability;\n   if (prob.reliable_p ())\n     {\n-      int thres = PARAM_VALUE (PARAM_MIN_LOOP_COND_SPLIT_PROB);\n+      int thres = param_min_loop_cond_split_prob;\n \n       if (prob < profile_probability::always ().apply_scale (thres, 100))\n \treturn NULL;\n     }\n \n   /* Add a threshold for increased code size to disable loop split.  */\n-  if (compute_added_num_insns (loop, invar_branch)\n-      > PARAM_VALUE (PARAM_MAX_PEELED_INSNS))\n+  if (compute_added_num_insns (loop, invar_branch) > param_max_peeled_insns)\n     return NULL;\n \n   return invar_branch;"}, {"sha": "4e3aa7c41b7be6235d73a364c665bcfee2662577", "filename": "gcc/tree-ssa-loop-unswitch.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-unswitch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-loop-unswitch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-unswitch.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -288,7 +288,7 @@ tree_unswitch_single_loop (class loop *loop, int num)\n \n       /* The loop should not be too large, to limit code growth. */\n       if (tree_num_loop_insns (loop, &eni_size_weights)\n-\t  > (unsigned) PARAM_VALUE (PARAM_MAX_UNSWITCH_INSNS))\n+\t  > (unsigned) param_max_unswitch_insns)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \";; Not unswitching, loop too big\\n\");\n@@ -323,7 +323,7 @@ tree_unswitch_single_loop (class loop *loop, int num)\n       if (i == loop->num_nodes)\n \t{\n \t  if (dump_file\n-\t      && num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL)\n+\t      && num > param_max_unswitch_level\n \t      && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \";; Not unswitching anymore, hit max level\\n\");\n \n@@ -352,7 +352,7 @@ tree_unswitch_single_loop (class loop *loop, int num)\n \t  changed = true;\n \t}\n       /* Do not unswitch too much.  */\n-      else if (num > PARAM_VALUE (PARAM_MAX_UNSWITCH_LEVEL))\n+      else if (num > param_max_unswitch_level)\n \t{\n \t  i++;\n \t  continue;"}, {"sha": "8b5f3149cbc85c5f844eb9366bd38f0a9e5f39d2", "filename": "gcc/tree-ssa-math-opts.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-math-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-math-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-math-opts.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1975,7 +1975,7 @@ gimple_expand_builtin_pow (gimple_stmt_iterator *gsi, location_t loc,\n       && !HONOR_SIGNED_ZEROS (mode))\n     {\n       unsigned int max_depth = speed_p\n-\t\t\t\t? PARAM_VALUE (PARAM_MAX_POW_SQRT_DEPTH)\n+\t\t\t\t? param_max_pow_sqrt_depth\n \t\t\t\t: 2;\n \n       tree expand_with_sqrts\n@@ -3089,7 +3089,7 @@ convert_mult_to_fma (gimple *mul_stmt, tree op1, tree op2,\n   bool check_defer\n     = (state->m_deferring_p\n        && (tree_to_shwi (TYPE_SIZE (type))\n-\t   <= PARAM_VALUE (PARAM_AVOID_FMA_MAX_BITS)));\n+\t   <= param_avoid_fma_max_bits));\n   bool defer = check_defer;\n   bool seen_negate_p = false;\n   /* Make sure that the multiplication statement becomes dead after\n@@ -3744,7 +3744,7 @@ math_opts_dom_walker::after_dom_children (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n \n-  fma_deferring_state fma_state (PARAM_VALUE (PARAM_AVOID_FMA_MAX_BITS) > 0);\n+  fma_deferring_state fma_state (param_avoid_fma_max_bits > 0);\n \n   for (gsi = gsi_after_labels (bb); !gsi_end_p (gsi);)\n     {"}, {"sha": "43990b796448e99e60591ac3ccdba5a13137d1fa", "filename": "gcc/tree-ssa-phiopt.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-phiopt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-phiopt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phiopt.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -2469,7 +2469,7 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n \n   /* If either vectorization or if-conversion is disabled then do\n      not sink any stores.  */\n-  if (MAX_STORES_TO_SINK == 0\n+  if (param_max_stores_to_sink == 0\n       || (!flag_tree_loop_vectorize && !flag_tree_slp_vectorize)\n       || !flag_tree_loop_if_convert)\n     return false;\n@@ -2528,7 +2528,7 @@ cond_if_else_store_replacement (basic_block then_bb, basic_block else_bb,\n \n   /* No pairs of stores found.  */\n   if (!then_stores.length ()\n-      || then_stores.length () > (unsigned) MAX_STORES_TO_SINK)\n+      || then_stores.length () > (unsigned) param_max_stores_to_sink)\n     {\n       free_data_refs (then_datarefs);\n       free_data_refs (else_datarefs);\n@@ -2658,7 +2658,7 @@ static void\n hoist_adjacent_loads (basic_block bb0, basic_block bb1,\n \t\t      basic_block bb2, basic_block bb3)\n {\n-  int param_align = PARAM_VALUE (PARAM_L1_CACHE_LINE_SIZE);\n+  int param_align = param_l1_cache_line_size;\n   unsigned param_align_bits = (unsigned) (param_align * BITS_PER_UNIT);\n   gphi_iterator gsi;\n \n@@ -2808,7 +2808,7 @@ static bool\n gate_hoist_loads (void)\n {\n   return (flag_hoist_adjacent_loads == 1\n-\t  && PARAM_VALUE (PARAM_L1_CACHE_LINE_SIZE)\n+\t  && param_l1_cache_line_size\n \t  && HAVE_conditional_move);\n }\n "}, {"sha": "58a147036af900dc5f32fcf556dfe66274499fd8", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1156,7 +1156,7 @@ translate_vuse_through_block (vec<vn_reference_op_s> operands,\n   if (gimple_bb (phi) != phiblock)\n     return vuse;\n \n-  unsigned int cnt = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n+  unsigned int cnt = param_sccvn_max_alias_queries_per_access;\n   use_oracle = ao_ref_init_from_vn_reference (&ref, set, type, operands);\n \n   /* Use the alias-oracle to find either the PHI node in this block,\n@@ -2235,7 +2235,7 @@ compute_partial_antic_aux (basic_block block,\n   bitmap_set_t PA_OUT;\n   edge e;\n   edge_iterator ei;\n-  unsigned long max_pa = PARAM_VALUE (PARAM_MAX_PARTIAL_ANTIC_LENGTH);\n+  unsigned long max_pa = param_max_partial_antic_length;\n \n   old_PA_IN = PA_OUT = NULL;\n "}, {"sha": "9e5b5290b55b83a5a739f21eb0e0ad09d52a91af", "filename": "gcc/tree-ssa-reassoc.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-reassoc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-reassoc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-reassoc.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -4945,7 +4945,7 @@ static int\n get_reassociation_width (int ops_num, enum tree_code opc,\n \t\t\t machine_mode mode)\n {\n-  int param_width = PARAM_VALUE (PARAM_TREE_REASSOC_WIDTH);\n+  int param_width = param_tree_reassoc_width;\n   int width;\n   int width_min;\n   int cycles_best;"}, {"sha": "429f09d40177b9867241a25d45007e7cdfd4c7ce", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3074,7 +3074,7 @@ vn_reference_lookup_pieces (tree vuse, alias_set_type set, tree type,\n       && vr1.vuse)\n     {\n       ao_ref r;\n-      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n+      unsigned limit = param_sccvn_max_alias_queries_per_access;\n       vn_walk_cb_data data (&vr1, NULL_TREE, NULL, kind, true);\n       if (ao_ref_init_from_vn_reference (&r, set, type, vr1.operands))\n \t*vnresult =\n@@ -3125,7 +3125,7 @@ vn_reference_lookup (tree op, tree vuse, vn_lookup_kind kind,\n     {\n       vn_reference_t wvnresult;\n       ao_ref r;\n-      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n+      unsigned limit = param_sccvn_max_alias_queries_per_access;\n       /* Make sure to use a valueized reference if we valueized anything.\n          Otherwise preserve the full reference for advanced TBAA.  */\n       if (!valuezied_anything\n@@ -6985,7 +6985,7 @@ do_rpo_vn (function *fn, edge entry, bitmap exit_bbs,\n   if (iterate)\n     {\n       loop_p loop;\n-      unsigned max_depth = PARAM_VALUE (PARAM_RPO_VN_MAX_LOOP_DEPTH);\n+      unsigned max_depth = param_rpo_vn_max_loop_depth;\n       FOR_EACH_LOOP (loop, LI_ONLY_INNERMOST)\n \tif (loop_depth (loop) > max_depth)\n \t  for (unsigned i = 2;"}, {"sha": "9fb2f500f4696507da933f229542d62f16ed169f", "filename": "gcc/tree-ssa-scopedtables.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-scopedtables.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-scopedtables.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-scopedtables.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -292,7 +292,7 @@ avail_exprs_stack::lookup_avail_expr (gimple *stmt, bool insert, bool tbaa_p)\n \t up the virtual use-def chain using walk_non_aliased_vuses.\n \t But don't do this when removing expressions from the hash.  */\n       ao_ref ref;\n-      unsigned limit = PARAM_VALUE (PARAM_SCCVN_MAX_ALIAS_QUERIES_PER_ACCESS);\n+      unsigned limit = param_sccvn_max_alias_queries_per_access;\n       if (!(vuse1 && vuse2\n \t    && gimple_assign_single_p (stmt)\n \t    && TREE_CODE (gimple_assign_lhs (stmt)) == SSA_NAME"}, {"sha": "cbad34b26de00ed27fac628ac7342618623286eb", "filename": "gcc/tree-ssa-sink.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-sink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-sink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sink.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -215,7 +215,7 @@ select_best_block (basic_block early_bb,\n   /* Get the sinking threshold.  If the statement to be moved has memory\n      operands, then increase the threshold by 7% as those are even more\n      profitable to avoid, clamping at 100%.  */\n-  threshold = PARAM_VALUE (PARAM_SINK_FREQUENCY_THRESHOLD);\n+  threshold = param_sink_frequency_threshold;\n   if (gimple_vuse (stmt) || gimple_vdef (stmt))\n     {\n       threshold += 7;"}, {"sha": "54f9bcf05f2a38bb43ff1e0f2c5af7af1add23f5", "filename": "gcc/tree-ssa-strlen.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-strlen.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-strlen.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-strlen.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -528,7 +528,7 @@ static int\n new_stridx (tree exp)\n {\n   int idx;\n-  if (max_stridx >= PARAM_VALUE (PARAM_MAX_TRACKED_STRLENS))\n+  if (max_stridx >= param_max_tracked_strlens)\n     return 0;\n   if (TREE_CODE (exp) == SSA_NAME)\n     {\n@@ -557,7 +557,7 @@ static int\n new_addr_stridx (tree exp)\n {\n   int *pidx;\n-  if (max_stridx >= PARAM_VALUE (PARAM_MAX_TRACKED_STRLENS))\n+  if (max_stridx >= param_max_tracked_strlens)\n     return 0;\n   pidx = addr_stridxptr (exp);\n   if (pidx != NULL)\n@@ -1082,7 +1082,7 @@ get_range_strlen_dynamic (tree src, c_strlen_data *pdata,\n   bitmap visited = NULL;\n   tree maxbound = pdata->maxbound;\n \n-  unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n+  unsigned limit = param_ssa_name_def_chain_limit;\n   if (!get_range_strlen_dynamic (src, pdata, &visited, rvals, &limit))\n     {\n       /* On failure extend the length range to an impossible maximum\n@@ -3972,7 +3972,7 @@ class ssa_name_limit_t\n \n   ssa_name_limit_t ()\n     : visited (NULL),\n-    ssa_def_max (PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT)) { }\n+    ssa_def_max (param_ssa_name_def_chain_limit) { }\n \n   int next_ssa_name (tree);\n "}, {"sha": "74edcd4458f5f486413fd8b2758a864d423c2721", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5691,9 +5691,9 @@ push_fields_onto_fieldstack (tree type, vec<fieldoff_s> *fieldstack,\n     return false;\n \n   /* If the vector of fields is growing too big, bail out early.\n-     Callers check for vec::length <= MAX_FIELDS_FOR_FIELD_SENSITIVE, make\n+     Callers check for vec::length <= param_max_fields_for_field_sensitive, make\n      sure this fails.  */\n-  if (fieldstack->length () > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n+  if (fieldstack->length () > (unsigned)param_max_fields_for_field_sensitive)\n     return false;\n \n   for (field = TYPE_FIELDS (type); field; field = DECL_CHAIN (field))\n@@ -6114,7 +6114,7 @@ create_variable_info_for_1 (tree decl, const char *name, bool add_id,\n   /* If we didn't end up collecting sub-variables create a full\n      variable for the decl.  */\n   if (fieldstack.length () == 0\n-      || fieldstack.length () > MAX_FIELDS_FOR_FIELD_SENSITIVE)\n+      || fieldstack.length () > (unsigned)param_max_fields_for_field_sensitive)\n     {\n       vi = new_var_info (decl, name, add_id);\n       vi->offset = 0;\n@@ -7179,7 +7179,7 @@ init_base_vars (void)\n static void\n init_alias_vars (void)\n {\n-  use_field_sensitive = (MAX_FIELDS_FOR_FIELD_SENSITIVE > 1);\n+  use_field_sensitive = (param_max_fields_for_field_sensitive > 1);\n \n   bitmap_obstack_initialize (&pta_obstack);\n   bitmap_obstack_initialize (&oldpta_obstack);"}, {"sha": "ddf7449d945ab4b729bc0ab939fa4a7e10d0d609", "filename": "gcc/tree-ssa-tail-merge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-tail-merge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-tail-merge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-tail-merge.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1469,7 +1469,7 @@ find_clusters_1 (same_succ *same_succ)\n   unsigned int i, j;\n   bitmap_iterator bi, bj;\n   int nr_comparisons;\n-  int max_comparisons = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_COMPARISONS);\n+  int max_comparisons = param_max_tail_merge_comparisons;\n \n   EXECUTE_IF_SET_IN_BITMAP (same_succ->bbs, 0, i, bi)\n     {\n@@ -1731,7 +1731,7 @@ tail_merge_optimize (unsigned int todo)\n   int nr_bbs_removed;\n   bool loop_entered = false;\n   int iteration_nr = 0;\n-  int max_iterations = PARAM_VALUE (PARAM_MAX_TAIL_MERGE_ITERATIONS);\n+  int max_iterations = param_max_tail_merge_iterations;\n \n   if (!flag_tree_tail_merge\n       || max_iterations == 0)"}, {"sha": "6d534647c60493da889c000309f63a85efdd019c", "filename": "gcc/tree-ssa-threadbackward.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-threadbackward.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-threadbackward.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadbackward.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -157,7 +157,7 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n       return NULL;\n \n   if (m_path.length () + 1\n-      > (unsigned) PARAM_VALUE (PARAM_MAX_FSM_THREAD_LENGTH))\n+      > (unsigned) param_max_fsm_thread_length)\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -367,7 +367,7 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n      as in PR 78407 this leads to noticeable improvements.  */\n   if (m_speed_p && (optimize_edge_for_speed_p (taken_edge) || contains_hot_bb))\n     {\n-      if (n_insns >= PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATH_INSNS))\n+      if (n_insns >= param_max_fsm_thread_path_insns)\n \t{\n \t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t    fprintf (dump_file, \"FSM jump-thread path not considered: \"\n@@ -397,9 +397,9 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n      optimizer would have done anyway, so an irreducible loop is not\n      so bad.  */\n   if (!threaded_multiway_branch && *creates_irreducible_loop\n-      && (n_insns * (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n+      && (n_insns * (unsigned) param_fsm_scale_path_stmts\n \t  > (m_path.length () *\n-\t     (unsigned) PARAM_VALUE (PARAM_FSM_SCALE_PATH_BLOCKS))))\n+\t     (unsigned) param_fsm_scale_path_blocks)))\n \n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -419,8 +419,8 @@ thread_jumps::profitable_jump_thread_path (basic_block bbi, tree name,\n      So for that case, drastically reduce the number of statements\n      we are allowed to copy.  */\n   if (!(threaded_through_latch && threaded_multiway_branch)\n-      && (n_insns * PARAM_VALUE (PARAM_FSM_SCALE_PATH_STMTS)\n-\t  >= PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS)))\n+      && (n_insns * param_fsm_scale_path_stmts\n+\t  >= param_max_jump_thread_duplication_stmts))\n     {\n       if (dump_file && (dump_flags & TDF_DETAILS))\n \tfprintf (dump_file,\n@@ -683,7 +683,7 @@ thread_jumps::fsm_find_control_statement_thread_paths (tree name)\n \n   if (gimple_code (def_stmt) == GIMPLE_PHI\n       && (gimple_phi_num_args (def_stmt)\n-\t  >= (unsigned) PARAM_VALUE (PARAM_FSM_MAXIMUM_PHI_ARGUMENTS)))\n+\t  >= (unsigned) param_fsm_maximum_phi_arguments))\n     return;\n \n   if (is_gimple_assign (def_stmt)\n@@ -771,7 +771,7 @@ thread_jumps::find_jump_threads_backwards (basic_block bb, bool speed_p)\n   m_visited_bbs.empty ();\n   m_seen_loop_phi = false;\n   m_speed_p = speed_p;\n-  m_max_threaded_paths = PARAM_VALUE (PARAM_MAX_FSM_THREAD_PATHS);\n+  m_max_threaded_paths = param_max_fsm_thread_paths;\n \n   fsm_find_control_statement_thread_paths (name);\n }"}, {"sha": "c43d7c5c39e980c6f438e06fcd7a90734687f79a", "filename": "gcc/tree-ssa-threadedge.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-threadedge.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-threadedge.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-threadedge.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -234,7 +234,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n   gimple_stmt_iterator gsi;\n   int max_stmt_count;\n \n-  max_stmt_count = PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS);\n+  max_stmt_count = param_max_jump_thread_duplication_stmts;\n \n   /* Walk through each statement in the block recording equivalences\n      we discover.  Note any equivalences we discover are context\n@@ -275,7 +275,7 @@ record_temporary_equivalences_from_stmts_at_dest (edge e,\n \t     killed due to threading, grow the max count\n \t     accordingly.  */\n \t  if (max_stmt_count\n-\t      == PARAM_VALUE (PARAM_MAX_JUMP_THREAD_DUPLICATION_STMTS))\n+\t      == param_max_jump_thread_duplication_stmts)\n \t    {\n \t      max_stmt_count += estimate_threading_killed_stmts (e->dest);\n \t      if (dump_file)"}, {"sha": "ae441067789abf1291333c0d8487fb7810debd85", "filename": "gcc/tree-ssa-uninit.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-uninit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-ssa-uninit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-uninit.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -545,7 +545,7 @@ compute_control_dep_chain (basic_block bb, basic_block dep_bb,\n   bool found_cd_chain = false;\n   size_t cur_chain_len = 0;\n \n-  if (*num_calls > PARAM_VALUE (PARAM_UNINIT_CONTROL_DEP_ATTEMPTS))\n+  if (*num_calls > param_uninit_control_dep_attempts)\n     return false;\n   ++*num_calls;\n "}, {"sha": "166e40c3931201504a06157767b220b506179df2", "filename": "gcc/tree-switch-conversion.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-switch-conversion.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-switch-conversion.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -194,7 +194,7 @@ switch_conversion::check_range ()\n     }\n \n   if (tree_to_uhwi (m_range_size)\n-      > ((unsigned) m_count * SWITCH_CONVERSION_BRANCH_RATIO))\n+      > ((unsigned) m_count * param_switch_conversion_branch_ratio))\n     {\n       m_reason = \"the maximum range-branch ratio exceeded\";\n       return false;\n@@ -1268,8 +1268,8 @@ jump_table_cluster::can_be_handled (const vec<cluster *> &clusters,\n \n   unsigned HOST_WIDE_INT max_ratio\n     = (optimize_insn_for_size_p ()\n-       ? PARAM_VALUE (PARAM_JUMP_TABLE_MAX_GROWTH_RATIO_FOR_SIZE)\n-       : PARAM_VALUE (PARAM_JUMP_TABLE_MAX_GROWTH_RATIO_FOR_SPEED));\n+       ? param_jump_table_max_growth_ratio_for_size\n+       : param_jump_table_max_growth_ratio_for_speed);\n   unsigned HOST_WIDE_INT range = get_range (clusters[start]->get_low (),\n \t\t\t\t\t    clusters[end]->get_high ());\n   /* Check overflow.  */"}, {"sha": "c58bccea7f1f60aae5e07a78b0a7177bbe0c581c", "filename": "gcc/tree-switch-conversion.h", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-switch-conversion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-switch-conversion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-switch-conversion.h?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -476,7 +476,7 @@ case_tree_node::case_tree_node ():\n unsigned int\n jump_table_cluster::case_values_threshold (void)\n {\n-  unsigned int threshold = PARAM_VALUE (PARAM_CASE_VALUES_THRESHOLD);\n+  unsigned int threshold = param_case_values_threshold;\n \n   if (threshold == 0)\n     threshold = targetm.case_values_threshold ();\n@@ -683,8 +683,8 @@ is changed into:\n \tb_b = PHI <b_6, b_7>\n \n There are further constraints.  Specifically, the range of values across all\n-case labels must not be bigger than SWITCH_CONVERSION_BRANCH_RATIO (default\n-eight) times the number of the actual switch branches.\n+case labels must not be bigger than param_switch_conversion_branch_ratio\n+(default eight) times the number of the actual switch branches.\n \n This transformation was contributed by Martin Jambor, see this e-mail:\n    http://gcc.gnu.org/ml/gcc-patches/2008-07/msg00011.html  */"}, {"sha": "5abbdc747f48958a6a385e9b5bf3550c3ad5de4f", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -185,7 +185,7 @@ vect_mark_for_runtime_alias_test (ddr_p ddr, loop_vec_info loop_vinfo)\n {\n   class loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n \n-  if ((unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) == 0)\n+  if ((unsigned) param_vect_max_version_for_alias_checks == 0)\n     return opt_result::failure_at (vect_location,\n \t\t\t\t   \"will not create alias checks, as\"\n \t\t\t\t   \" --param vect-max-version-for-alias-checks\"\n@@ -2086,7 +2086,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n       if (do_peeling)\n         {\n           unsigned max_allowed_peel\n-            = PARAM_VALUE (PARAM_VECT_MAX_PEELING_FOR_ALIGNMENT);\n+\t    = param_vect_max_peeling_for_alignment;\n \t  if (flag_vect_cost_model == VECT_COST_MODEL_CHEAP)\n \t    max_allowed_peel = 0;\n           if (max_allowed_peel != (unsigned)-1)\n@@ -2227,7 +2227,7 @@ vect_enhance_data_refs_alignment (loop_vec_info loop_vinfo)\n \n               if (known_alignment_for_access_p (dr_info)\n                   || LOOP_VINFO_MAY_MISALIGN_STMTS (loop_vinfo).length ()\n-                     >= (unsigned) PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIGNMENT_CHECKS))\n+\t\t  >= (unsigned) param_vect_max_version_for_alignment_checks)\n                 {\n                   do_versioning = false;\n                   break;\n@@ -3656,10 +3656,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n     dump_printf_loc (MSG_NOTE, vect_location,\n \t\t     \"improved number of alias checks from %d to %d\\n\",\n \t\t     may_alias_ddrs.length (), count);\n-  unsigned limit = PARAM_VALUE (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS);\n+  unsigned limit = param_vect_max_version_for_alias_checks;\n   if (flag_simd_cost_model == VECT_COST_MODEL_CHEAP)\n-    limit = default_param_value\n-\t      (PARAM_VECT_MAX_VERSION_FOR_ALIAS_CHECKS) * 6 / 10;\n+    limit = param_vect_max_version_for_alias_checks * 6 / 10;\n   if (count > limit)\n     return opt_result::failure_at\n       (vect_location,"}, {"sha": "db58a2f7c8182992e7e975cf4f59cf1f87664ce3", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1665,7 +1665,7 @@ vect_analyze_loop_costing (loop_vec_info loop_vinfo)\n       return -1;\n     }\n \n-  int min_scalar_loop_bound = (PARAM_VALUE (PARAM_MIN_VECT_LOOP_BOUND)\n+  int min_scalar_loop_bound = (param_min_vect_loop_bound\n \t\t\t       * assumed_vf);\n \n   /* Use the cost model only if it is more conservative than user specified\n@@ -1775,7 +1775,7 @@ vect_get_datarefs_in_loop (loop_p loop, basic_block *bbs,\n \t/* If dependence analysis will give up due to the limit on the\n \t   number of datarefs stop here and fail fatally.  */\n \tif (datarefs->length ()\n-\t    > (unsigned)PARAM_VALUE (PARAM_LOOP_MAX_DATAREFS_FOR_DATADEPS))\n+\t    > (unsigned)param_loop_max_datarefs_for_datadeps)\n \t  return opt_result::failure_at (stmt, \"exceeded param \"\n \t\t\t\t\t \"loop-max-datarefs-for-datadeps\\n\");\n       }\n@@ -2461,7 +2461,7 @@ vect_analyze_loop (class loop *loop, vec_info_shared *shared)\n \t     TODO: Enable epilogue vectorization for loops with SIMDUID set.  */\n \t  vect_epilogues = (!simdlen\n \t\t\t    && loop->inner == NULL\n-\t\t\t    && PARAM_VALUE (PARAM_VECT_EPILOGUES_NOMASK)\n+\t\t\t    && param_vect_epilogues_nomask\n \t\t\t    && LOOP_VINFO_PEELING_FOR_NITER (first_loop_vinfo)\n \t\t\t    && !loop->simduid\n \t\t\t    /* For now only allow one epilogue loop.  */"}, {"sha": "9d3d991e516326ee35ee52ab64c063143567d9f2", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3289,7 +3289,7 @@ vect_slp_bb (basic_block bb)\n \n       gimple_stmt_iterator region_end = gsi;\n \n-      if (insns > PARAM_VALUE (PARAM_SLP_MAX_INSNS_IN_BB))\n+      if (insns > param_slp_max_insns_in_bb)\n \t{\n \t  if (dump_enabled_p ())\n \t    dump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,"}, {"sha": "e556e0e98886de5de81eb44e013e31ff09136021", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -489,7 +489,7 @@ typedef class _loop_vec_info : public vec_info {\n \n   /* Threshold of number of iterations below which vectorization will not be\n      performed. It is calculated from MIN_PROFITABLE_ITERS and\n-     PARAM_MIN_VECT_LOOP_BOUND.  */\n+     param_min_vect_loop_bound.  */\n   unsigned int th;\n \n   /* When applying loop versioning, the vector form should only be used"}, {"sha": "399c33324529e9121949f854506dc54861bbd77f", "filename": "gcc/tree-vrp.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vrp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree-vrp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vrp.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -3391,7 +3391,7 @@ find_switch_asserts (basic_block bb, gswitch *last)\n \n   /* Now register along the default label assertions that correspond to the\n      anti-range of each label.  */\n-  int insertion_limit = PARAM_VALUE (PARAM_MAX_VRP_SWITCH_ASSERTIONS);\n+  int insertion_limit = param_max_vrp_switch_assertions;\n   if (insertion_limit == 0)\n     return;\n \n@@ -4305,7 +4305,7 @@ vrp_prop::check_mem_ref (location_t location, tree ref,\n      The loop computes the range of the final offset for expressions such\n      as (A + i0 + ... + iN)[CSTOFF] where i0 through iN are SSA_NAMEs in\n      some range.  */\n-  const unsigned limit = PARAM_VALUE (PARAM_SSA_NAME_DEF_CHAIN_LIMIT);\n+  const unsigned limit = param_ssa_name_def_chain_limit;\n   for (unsigned n = 0; TREE_CODE (arg) == SSA_NAME && n < limit; ++n)\n     {\n       gimple *def = SSA_NAME_DEF_STMT (arg);"}, {"sha": "c3cd527e14a753c6c2c1a2a88a9d00cc117910aa", "filename": "gcc/tree.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -1553,15 +1553,15 @@ wide_int_to_tree_1 (tree type, const wide_int_ref &pcst)\n \t  if (TYPE_SIGN (type) == UNSIGNED)\n \t    {\n \t      /* Cache [0, N).  */\n-\t      limit = INTEGER_SHARE_LIMIT;\n-\t      if (IN_RANGE (hwi, 0, INTEGER_SHARE_LIMIT - 1))\n+\t      limit = param_integer_share_limit;\n+\t      if (IN_RANGE (hwi, 0, param_integer_share_limit - 1))\n \t\tix = hwi;\n \t    }\n \t  else\n \t    {\n \t      /* Cache [-1, N).  */\n-\t      limit = INTEGER_SHARE_LIMIT + 1;\n-\t      if (IN_RANGE (hwi, -1, INTEGER_SHARE_LIMIT - 1))\n+\t      limit = param_integer_share_limit + 1;\n+\t      if (IN_RANGE (hwi, -1, param_integer_share_limit - 1))\n \t\tix = hwi + 1;\n \t    }\n \t  break;\n@@ -1737,34 +1737,35 @@ cache_integer_cst (tree t)\n       if (TYPE_UNSIGNED (type))\n \t{\n \t  /* Cache 0..N */\n-\t  limit = INTEGER_SHARE_LIMIT;\n+\t  limit = param_integer_share_limit;\n \n \t  /* This is a little hokie, but if the prec is smaller than\n-\t     what is necessary to hold INTEGER_SHARE_LIMIT, then the\n+\t     what is necessary to hold param_integer_share_limit, then the\n \t     obvious test will not get the correct answer.  */\n \t  if (prec < HOST_BITS_PER_WIDE_INT)\n \t    {\n-\t      if (tree_to_uhwi (t) < (unsigned HOST_WIDE_INT) INTEGER_SHARE_LIMIT)\n+\t      if (tree_to_uhwi (t)\n+\t\t  < (unsigned HOST_WIDE_INT) param_integer_share_limit)\n \t\tix = tree_to_uhwi (t);\n \t    }\n-\t  else if (wi::ltu_p (wi::to_wide (t), INTEGER_SHARE_LIMIT))\n+\t  else if (wi::ltu_p (wi::to_wide (t), param_integer_share_limit))\n \t    ix = tree_to_uhwi (t);\n \t}\n       else\n \t{\n \t  /* Cache -1..N */\n-\t  limit = INTEGER_SHARE_LIMIT + 1;\n+\t  limit = param_integer_share_limit + 1;\n \n \t  if (integer_minus_onep (t))\n \t    ix = 0;\n \t  else if (!wi::neg_p (wi::to_wide (t)))\n \t    {\n \t      if (prec < HOST_BITS_PER_WIDE_INT)\n \t\t{\n-\t\t  if (tree_to_shwi (t) < INTEGER_SHARE_LIMIT)\n+\t\t  if (tree_to_shwi (t) < param_integer_share_limit)\n \t\t    ix = tree_to_shwi (t) + 1;\n \t\t}\n-\t      else if (wi::ltu_p (wi::to_wide (t), INTEGER_SHARE_LIMIT))\n+\t      else if (wi::ltu_p (wi::to_wide (t), param_integer_share_limit))\n \t\tix = tree_to_shwi (t) + 1;\n \t    }\n \t}"}, {"sha": "c80a06c92b73d02d0875d38da650637eecac27a4", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/028d409252058d88805341a3f6dc0ff1553f5bdc/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=028d409252058d88805341a3f6dc0ff1553f5bdc", "patch": "@@ -5844,7 +5844,7 @@ add_uses_1 (rtx *x, void *cui)\n    compile time for ridiculously complex expressions, although they're\n    seldom useful, and they may often have to be discarded as not\n    representable anyway.  */\n-#define EXPR_USE_DEPTH (PARAM_VALUE (PARAM_MAX_VARTRACK_EXPR_DEPTH))\n+#define EXPR_USE_DEPTH (param_max_vartrack_expr_depth)\n \n /* Attempt to reverse the EXPR operation in the debug info and record\n    it in the cselib table.  Say for reg1 = reg2 + 6 even when reg2 is\n@@ -5904,7 +5904,7 @@ reverse_op (rtx val, const_rtx expr, rtx_insn *insn)\n \t&& (GET_CODE (l->loc) != CONST || !references_value_p (l->loc, 0)))\n       return;\n     /* Avoid creating too large locs lists.  */\n-    else if (count == PARAM_VALUE (PARAM_MAX_VARTRACK_REVERSE_OP_SIZE))\n+    else if (count == param_max_vartrack_reverse_op_size)\n       return;\n \n   switch (GET_CODE (src))\n@@ -7054,7 +7054,7 @@ vt_find_locations (void)\n   int *rc_order;\n   int i;\n   int htabsz = 0;\n-  int htabmax = PARAM_VALUE (PARAM_MAX_VARTRACK_SIZE);\n+  int htabmax = param_max_vartrack_size;\n   bool success = true;\n \n   timevar_push (TV_VAR_TRACKING_DATAFLOW);"}]}