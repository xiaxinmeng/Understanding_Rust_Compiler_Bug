{"sha": "d92b44865fab81d50fc2db997387f92448d7611a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDkyYjQ0ODY1ZmFiODFkNTBmYzJkYjk5NzM4N2Y5MjQ0OGQ3NjExYQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2002-05-18T15:16:25Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2002-05-18T15:16:25Z"}, "message": "timevar.c: Fix formatting.\n\n\t* timevar.c: Fix formatting.\n\t* tlink.c: Likewise.\n\t* toplev.c: Likewise.\n\t* tree-dump.c: Likewise.\n\t* tree-inline.c: Likewise.\n\nFrom-SVN: r53591", "tree": {"sha": "3c686422c3e4f85de25c693a6d75526ea9a7a011", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c686422c3e4f85de25c693a6d75526ea9a7a011"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d92b44865fab81d50fc2db997387f92448d7611a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d92b44865fab81d50fc2db997387f92448d7611a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d92b44865fab81d50fc2db997387f92448d7611a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d92b44865fab81d50fc2db997387f92448d7611a/comments", "author": null, "committer": null, "parents": [{"sha": "770dc0c5b9dd4e0b77f3a350388e016ef723dbbf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/770dc0c5b9dd4e0b77f3a350388e016ef723dbbf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/770dc0c5b9dd4e0b77f3a350388e016ef723dbbf"}], "stats": {"total": 170, "additions": 89, "deletions": 81}, "files": [{"sha": "8e3b2c00caf653dcdf0323e3ee6facb03d43f18f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -1,3 +1,11 @@\n+2002-05-18  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* timevar.c: Fix formatting.\n+\t* tlink.c: Likewise.\n+\t* toplev.c: Likewise.\n+\t* tree-dump.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\n 2002-05-18  Neil Booth  <neil@daikokuya.demon.co.uk>\n \n \t* cppinit.c (cpp_post_options): If preprocessed, turn off"}, {"sha": "9b8c9fc9b8cd2388738d8f298754692e7ff083b7", "filename": "gcc/timevar.c", "status": "modified", "additions": 17, "deletions": 17, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftimevar.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftimevar.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftimevar.c?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -171,7 +171,7 @@ static struct timevar_time_def start_time;\n static void get_time\n   PARAMS ((struct timevar_time_def *));\n static void timevar_accumulate\n-  PARAMS ((struct timevar_time_def *, struct timevar_time_def *, \n+  PARAMS ((struct timevar_time_def *, struct timevar_time_def *,\n \t   struct timevar_time_def *));\n \n /* Fill the current times into TIME.  The definition of this function\n@@ -210,11 +210,11 @@ get_time (now)\n \n /* Add the difference between STOP_TIME and START_TIME to TIMER.  */\n \n-static void \n+static void\n timevar_accumulate (timer, start_time, stop_time)\n-  struct timevar_time_def *timer;\n-  struct timevar_time_def *start_time;\n-  struct timevar_time_def *stop_time;\n+     struct timevar_time_def *timer;\n+     struct timevar_time_def *start_time;\n+     struct timevar_time_def *stop_time;\n {\n   timer->user += stop_time->user - start_time->user;\n   timer->sys += stop_time->sys - start_time->sys;\n@@ -249,7 +249,7 @@ init_timevar ()\n /* Push TIMEVAR onto the timing stack.  No further elapsed time is\n    attributed to the previous topmost timing variable on the stack;\n    subsequent elapsed time is attributed to TIMEVAR, until it is\n-   popped or another element is pushed on top. \n+   popped or another element is pushed on top.\n \n    TIMEVAR cannot be running as a standalone timer.  */\n \n@@ -285,13 +285,13 @@ timevar_push (timevar)\n \n   /* See if we have a previously-allocated stack instance.  If so,\n      take it off the list.  If not, malloc a new one.  */\n-  if (unused_stack_instances != NULL) \n+  if (unused_stack_instances != NULL)\n     {\n       context = unused_stack_instances;\n       unused_stack_instances = unused_stack_instances->next;\n     }\n   else\n-    context = (struct timevar_stack_def *) \n+    context = (struct timevar_stack_def *)\n       xmalloc (sizeof (struct timevar_stack_def));\n \n   /* Fill it in and put it on the stack.  */\n@@ -396,7 +396,7 @@ timevar_get (timevar, elapsed)\n   struct timevar_time_def now;\n \n   *elapsed = tv->elapsed;\n-  \n+\n   /* Is TIMEVAR currently running as a standalone timer?  */\n   if (tv->standalone)\n     {\n@@ -472,21 +472,21 @@ timevar_print (fp)\n \n #ifdef HAVE_USER_TIME\n       /* Print user-mode time for this process.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) usr\", \n+      fprintf (fp, \"%7.2f (%2.0f%%) usr\",\n \t       tv->elapsed.user,\n \t       (total->user == 0 ? 0 : tv->elapsed.user / total->user) * 100);\n #endif /* HAVE_USER_TIME */\n \n #ifdef HAVE_SYS_TIME\n       /* Print system-mode time for this process.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) sys\", \n+      fprintf (fp, \"%7.2f (%2.0f%%) sys\",\n \t       tv->elapsed.sys,\n \t       (total->sys == 0 ? 0 : tv->elapsed.sys / total->sys) * 100);\n #endif /* HAVE_SYS_TIME */\n \n #ifdef HAVE_WALL_TIME\n       /* Print wall clock time elapsed.  */\n-      fprintf (fp, \"%7.2f (%2.0f%%) wall\", \n+      fprintf (fp, \"%7.2f (%2.0f%%) wall\",\n \t       tv->elapsed.wall,\n \t       (total->wall == 0 ? 0 : tv->elapsed.wall / total->wall) * 100);\n #endif /* HAVE_WALL_TIME */\n@@ -498,15 +498,15 @@ timevar_print (fp)\n   fputs (_(\" TOTAL                 :\"), fp);\n #ifdef HAVE_USER_TIME\n   fprintf (fp, \"%7.2f          \", total->user);\n-#endif \n+#endif\n #ifdef HAVE_SYS_TIME\n   fprintf (fp, \"%7.2f          \", total->sys);\n #endif\n #ifdef HAVE_WALL_TIME\n   fprintf (fp, \"%7.2f\\n\", total->wall);\n #endif\n-  \n-#endif /* defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME) \n+\n+#endif /* defined (HAVE_USER_TIME) || defined (HAVE_SYS_TIME)\n \t  || defined (HAVE_WALL_TIME) */\n }\n \n@@ -533,6 +533,6 @@ print_time (str, total)\n   fprintf (stderr,\n \t   _(\"time in %s: %ld.%06ld (%ld%%)\\n\"),\n \t   str, total / 1000000, total % 1000000,\n- \t   all_time == 0 ? 0\n- \t   : (long) (((100.0 * (double) total) / (double) all_time) + .5));\n+\t   all_time == 0 ? 0\n+\t   : (long) (((100.0 * (double) total) / (double) all_time) + .5));\n }"}, {"sha": "55d23bee672e2131bd0b18aa158167e6d6ebb828", "filename": "gcc/tlink.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftlink.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftlink.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftlink.c?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -132,7 +132,7 @@ symbol_hash_lookup (string, create)\n      int create;\n {\n   return ((struct symbol_hash_entry *)\n-\t  hash_lookup (&symbol_table, (const hash_table_key) string, \n+\t  hash_lookup (&symbol_table, (const hash_table_key) string,\n \t\t       create, string_copy));\n }\n \n@@ -169,7 +169,7 @@ file_hash_lookup (string)\n      const char *string;\n {\n   return ((struct file_hash_entry *)\n-\t  hash_lookup (&file_table, (const hash_table_key) string, true, \n+\t  hash_lookup (&file_table, (const hash_table_key) string, true,\n \t\t       string_copy));\n }\n \n@@ -204,7 +204,7 @@ demangled_hash_lookup (string, create)\n      int create;\n {\n   return ((struct demangled_hash_entry *)\n-\t  hash_lookup (&demangled_table, (const hash_table_key) string, \n+\t  hash_lookup (&demangled_table, (const hash_table_key) string,\n \t\t       create, string_copy));\n }\n \f\n@@ -292,7 +292,7 @@ tlink_init ()\n \n   hash_table_init (&symbol_table, symbol_hash_newfunc, string_hash,\n \t\t   string_compare);\n-  hash_table_init (&file_table, file_hash_newfunc, string_hash, \n+  hash_table_init (&file_table, file_hash_newfunc, string_hash,\n \t\t   string_compare);\n   hash_table_init (&demangled_table, demangled_hash_newfunc,\n \t\t   string_hash, string_compare);\n@@ -320,7 +320,7 @@ tlink_execute (prog, argv, redir)\n {\n   collect_execute (prog, argv, redir);\n   return collect_wait (prog);\n-} \n+}\n \n static char *\n frob_extension (s, ext)\n@@ -425,7 +425,7 @@ read_repo_file (f)\n   FILE *stream = fopen ((char*) f->root.key, \"r\");\n \n   if (tlink_verbose >= 2)\n-    fprintf (stderr, _(\"collect: reading %s\\n\"), \n+    fprintf (stderr, _(\"collect: reading %s\\n\"),\n \t     (char*) f->root.key);\n \n   while (fscanf (stream, \"%c \", &c) == 1)\n@@ -497,7 +497,7 @@ recompile_files ()\n \n   putenv (xstrdup (\"COMPILER_PATH\"));\n   putenv (xstrdup (\"LIBRARY_PATH\"));\n-  \n+\n   while ((f = file_pop ()) != NULL)\n     {\n       char *line, *command;\n@@ -587,7 +587,7 @@ demangle_new_symbols ()\n   while ((sym = symbol_pop ()) != NULL)\n     {\n       demangled *dem;\n-      const char *p = cplus_demangle ((char*) sym->root.key, \n+      const char *p = cplus_demangle ((char*) sym->root.key,\n \t\t\t\tDMGL_PARAMS | DMGL_ANSI);\n \n       if (! p)\n@@ -613,7 +613,7 @@ scan_linker_output (fname)\n       char *p = line, *q;\n       symbol *sym;\n       int end;\n-      \n+\n       while (*p && ISSPACE ((unsigned char)*p))\n \t++p;\n \n@@ -679,8 +679,8 @@ scan_linker_output (fname)\n \t      if (dem)\n \t\tsym = symbol_hash_lookup (dem->mangled, false);\n \t      else\n-\t        {\n-\t          if (*p == '_' && prepends_underscore)\n+\t\t{\n+\t\t  if (*p == '_' && prepends_underscore)\n \t\t    ++p;\n \t\t  sym = symbol_hash_lookup (p, false);\n \t\t}\n@@ -700,7 +700,7 @@ scan_linker_output (fname)\n \t  sym->tweaking = 1;\n \t  file_push (sym->file);\n \t}\n-\t\n+\n       obstack_free (&temporary_obstack, temporary_firstobj);\n     }\n "}, {"sha": "cedfbc290625e2366a23e4f1f1b4a7cff6f20823", "filename": "gcc/toplev.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftoplev.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftoplev.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftoplev.c?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -2512,7 +2512,7 @@ rest_of_compilation (decl)\n   rebuild_jump_labels (insns);\n   find_exception_handler_labels ();\n   find_basic_blocks (insns, max_reg_num (), rtl_dump_file);\n-  \n+\n   delete_unreachable_blocks ();\n \n   /* Turn NOTE_INSN_PREDICTIONs into branch predictions.  */\n@@ -2528,7 +2528,7 @@ rest_of_compilation (decl)\n       /* There is pass ordering problem - we must lower NOTE_INSN_PREDICTION\n          notes before simplifying cfg and we must do lowering after sibcall\n          that unhides parts of RTL chain and cleans up the CFG.\n-        \n+\n          Until sibcall is replaced by tree-level optimizer, lets just\n          sweep away the NOTE_INSN_PREDICTION notes that leaked out.  */\n       for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n@@ -3868,7 +3868,7 @@ decode_f_option (arg)\n       stack_limit_rtx = gen_rtx_SYMBOL_REF (Pmode, nm);\n     }\n   else if ((option_value\n-            = skip_leading_substring (arg, \"message-length=\")))\n+\t    = skip_leading_substring (arg, \"message-length=\")))\n     output_set_maximum_length\n       (&global_dc->buffer, read_integral_parameter\n        (option_value, arg - 2, diagnostic_line_cutoff (global_dc)));"}, {"sha": "293a8d188ae2c5beae8c77774dc03d157ba7e702", "filename": "gcc/tree-dump.c", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftree-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftree-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-dump.c?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -65,7 +65,7 @@ queue (di, t, flags)\n   dni = (dump_node_info_p) xmalloc (sizeof (struct dump_node_info));\n   dni->index = index;\n   dni->binfo_p = ((flags & DUMP_BINFO) != 0);\n-  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t, \n+  dq->node = splay_tree_insert (di->nodes, (splay_tree_key) t,\n \t\t\t\t(splay_tree_value) dni);\n \n   /* Add it to the end of the queue.  */\n@@ -156,7 +156,7 @@ dump_maybe_newline (di)\n      dump_info_p di;\n {\n   int extra;\n-  \n+\n   /* See if we need a new line.  */\n   if (di->column > EOL_COLUMN)\n     dump_new_line (di);\n@@ -247,7 +247,7 @@ dump_next_stmt (di, t)\n \n /* Dump the next node in the queue.  */\n \n-static void \n+static void\n dequeue_and_dump (di)\n      dump_info_p di;\n {\n@@ -300,7 +300,7 @@ dequeue_and_dump (di)\n \tdump_string (di, \"priv\");\n       if (TREE_VIA_VIRTUAL (t))\n \tdump_string (di, \"virt\");\n-\t    \n+\n       dump_child (\"type\", BINFO_TYPE (t));\n       dump_child (\"base\", BINFO_BASETYPES (t));\n \n@@ -319,17 +319,17 @@ dequeue_and_dump (di)\n \tcase '1':\n \t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n \t  break;\n-\t      \n+\n \tcase '2':\n \tcase '<':\n \t  dump_child (\"op 0\", TREE_OPERAND (t, 0));\n \t  dump_child (\"op 1\", TREE_OPERAND (t, 1));\n \t  break;\n-\t      \n+\n \tcase 'e':\n \t  /* These nodes are handled explicitly below.  */\n \t  break;\n-\t      \n+\n \tdefault:\n \t  abort ();\n \t}\n@@ -339,7 +339,7 @@ dequeue_and_dump (di)\n       /* All declarations have names.  */\n       if (DECL_NAME (t))\n \tdump_child (\"name\", DECL_NAME (t));\n-      if (DECL_ASSEMBLER_NAME_SET_P (t) \n+      if (DECL_ASSEMBLER_NAME_SET_P (t)\n \t  && DECL_ASSEMBLER_NAME (t) != DECL_NAME (t))\n \tdump_child (\"mngl\", DECL_ASSEMBLER_NAME (t));\n       /* And types.  */\n@@ -356,7 +356,7 @@ dequeue_and_dump (di)\n \t    ++filename;\n \n \t  dump_maybe_newline (di);\n-\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename, \n+\t  fprintf (di->stream, \"srcp: %s:%-6d \", filename,\n \t\t   DECL_SOURCE_LINE (t));\n \t  di->column += 6 + strlen (filename) + 8;\n \t}\n@@ -370,7 +370,7 @@ dequeue_and_dump (di)\n     {\n       /* All types have qualifiers.  */\n       int quals = (*lang_hooks.tree_dump.type_quals) (t);\n-      \n+\n       if (quals != TYPE_UNQUALIFIED)\n \t{\n \t  fprintf (di->stream, \"qual: %c%c%c     \",\n@@ -386,7 +386,7 @@ dequeue_and_dump (di)\n       /* All types have a main variant.  */\n       if (TYPE_MAIN_VARIANT (t) != t)\n \tdump_child (\"unql\", TYPE_MAIN_VARIANT (t));\n-      \n+\n       /* And sizes.  */\n       dump_child (\"size\", TYPE_SIZE (t));\n \n@@ -473,10 +473,10 @@ dequeue_and_dump (di)\n \tdump_string (di, \"struct\");\n       else\n \tdump_string (di, \"union\");\n-      \n+\n       dump_child (\"flds\", TYPE_FIELDS (t));\n       dump_child (\"fncs\", TYPE_METHODS (t));\n-      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t), \n+      queue_and_dump_index (di, \"binf\", TYPE_BINFO (t),\n \t\t\t    DUMP_BINFO);\n       break;\n \n@@ -502,7 +502,7 @@ dequeue_and_dump (di)\n \t  if (DECL_FIELD_OFFSET (t))\n \t    dump_child (\"bpos\", bit_position (t));\n \t}\n-      else if (TREE_CODE (t) == VAR_DECL \n+      else if (TREE_CODE (t) == VAR_DECL\n \t       || TREE_CODE (t) == PARM_DECL)\n \t{\n \t  dump_int (di, \"used\", TREE_USED (t));\n@@ -566,7 +566,7 @@ dequeue_and_dump (di)\n       dump_child (\"decl\", DECL_STMT_DECL (t));\n       dump_next_stmt (di, t);\n       break;\n-      \n+\n     case DO_STMT:\n       dump_stmt (di, t);\n       dump_child (\"body\", DO_BODY (t));\n@@ -720,7 +720,7 @@ dequeue_and_dump (di)\n \t becomes NULL.  */\n       dump_child (\"init\", TREE_OPERAND (t, 3));\n       break;\n-      \n+\n     case EXPR_WITH_FILE_LOCATION:\n       dump_child (\"expr\", EXPR_WFL_NODE (t));\n       break;\n@@ -733,7 +733,7 @@ dequeue_and_dump (di)\n  done:\n   if (dump_flag (di, TDF_ADDRESS, NULL))\n     dump_pointer (di, \"addr\", (void *)t);\n-  \n+\n   /* Terminate the line.  */\n   fprintf (di->stream, \"\\n\");\n }\n@@ -770,7 +770,7 @@ dump_node (t, flags, stream)\n   di.free_list = 0;\n   di.flags = flags;\n   di.node = t;\n-  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0, \n+  di.nodes = splay_tree_new (splay_tree_compare_pointers, 0,\n \t\t\t     (splay_tree_delete_value_fn) &free);\n \n   /* Queue up the first node.  */\n@@ -838,10 +838,10 @@ dump_begin (phase, flag_ptr)\n {\n   FILE *stream;\n   char *name;\n-  \n+\n   if (!dump_files[phase].state)\n     return NULL;\n-  \n+\n   name = concat (dump_base_name, dump_files[phase].suffix, NULL);\n   stream = fopen (name, dump_files[phase].state < 0 ? \"w\" : \"a\");\n   if (!stream)\n@@ -851,7 +851,7 @@ dump_begin (phase, flag_ptr)\n   free (name);\n   if (flag_ptr)\n     *flag_ptr = dump_files[phase].flags;\n-  \n+\n   return stream;\n }\n \n@@ -893,26 +893,26 @@ dump_switch_p (arg)\n {\n   unsigned ix;\n   const char *option_value;\n-  \n+\n   for (ix = 0; ix != TDI_end; ix++)\n     if ((option_value = skip_leading_substring (arg, dump_files[ix].swtch)))\n       {\n \tconst char *ptr = option_value;\n \tint flags = 0;\n-\t\n+\n \twhile (*ptr)\n \t  {\n \t    const struct dump_option_value_info *option_ptr;\n \t    const char *end_ptr;\n \t    unsigned length;\n-\t    \n+\n \t    while (*ptr == '-')\n \t      ptr++;\n \t    end_ptr = strchr (ptr, '-');\n \t    if (!end_ptr)\n \t      end_ptr = ptr + strlen (ptr);\n \t    length = end_ptr - ptr;\n-\t    \n+\n \t    for (option_ptr = dump_options; option_ptr->name;\n \t\t option_ptr++)\n \t      if (strlen (option_ptr->name) == length\n@@ -926,10 +926,10 @@ dump_switch_p (arg)\n \t  found:;\n \t    ptr = end_ptr;\n \t  }\n-\t\n+\n \tdump_files[ix].state = -1;\n \tdump_files[ix].flags = flags;\n-\t\n+\n \treturn 1;\n       }\n   return 0;"}, {"sha": "5fcd8928af51d1d3fbf952e8f9b9d4c72c204a68", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d92b44865fab81d50fc2db997387f92448d7611a/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=d92b44865fab81d50fc2db997387f92448d7611a", "patch": "@@ -38,11 +38,11 @@ Boston, MA 02111-1307, USA.  */\n \n /* This should be eventually be generalized to other languages, but\n    this would require a shared function-as-trees infrastructure.  */\n-#include \"c-common.h\" \n+#include \"c-common.h\"\n \n /* 0 if we should not perform inlining.\n-   1 if we should expand functions calls inline at the tree level.  \n-   2 if we should consider *all* functions to be inline \n+   1 if we should expand functions calls inline at the tree level.\n+   2 if we should consider *all* functions to be inline\n    candidates.  */\n \n int flag_inline_trees = 0;\n@@ -166,7 +166,7 @@ remap_decl (decl, id)\n \t     DECL_ANON_UNION_ELEMS.  */\n \t  tree members = NULL;\n \t  tree src;\n-\t  \n+\n \t  for (src = DECL_ANON_UNION_ELEMS (t); src;\n \t       src = TREE_CHAIN (src))\n \t    {\n@@ -178,7 +178,7 @@ remap_decl (decl, id)\n \t    }\n \t  DECL_ANON_UNION_ELEMS (t) = nreverse (members);\n \t}\n-      \n+\n       /* Remember it, so that if we encounter this local entity\n \t again we can reuse this copy.  */\n       n = splay_tree_insert (id->decl_map,\n@@ -563,7 +563,7 @@ initialize_inlined_parameters (id, args, fn)\n \n       /* See if we need to clean up the declaration.  */\n       cleanup = (*lang_hooks.maybe_build_cleanup) (var);\n-      if (cleanup) \n+      if (cleanup)\n \t{\n \t  tree cleanup_stmt;\n \t  /* Build the cleanup statement.  */\n@@ -677,7 +677,7 @@ inlinable_function_p (fn, id)\n \n   /* Assume it is not inlinable.  */\n   inlinable = 0;\n-       \n+\n   /* The number of instructions (estimated) of current function.  */\n   currfn_insns = DECL_NUM_STMTS (fn) * INSNS_PER_STMT;\n \n@@ -693,7 +693,7 @@ inlinable_function_p (fn, id)\n   else if (! DECL_INLINE (fn))\n     ;\n   /* We can't inline functions that are too big.  Only allow a single\n-     function to be of MAX_INLINE_INSNS_SINGLE size.  Make special \n+     function to be of MAX_INLINE_INSNS_SINGLE size.  Make special\n      allowance for extern inline functions, though.  */\n   else if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n \t   && currfn_insns > MAX_INLINE_INSNS_SINGLE)\n@@ -712,7 +712,7 @@ inlinable_function_p (fn, id)\n      can inline this function, investigate further.  */\n   if (! (*lang_hooks.tree_inlining.disregard_inline_limits) (fn)\n       && inlinable)\n-    { \n+    {\n       int sum_insns = (id ? id->inlined_stmts : 0) * INSNS_PER_STMT\n \t\t     + currfn_insns;\n       /* In the extreme case that we have exceeded the recursive inlining\n@@ -726,7 +726,7 @@ inlinable_function_p (fn, id)\n          though.  */\n       else if ((sum_insns > MAX_INLINE_INSNS)\n \t       && (currfn_insns > MIN_INLINE_INSNS))\n-        {\n+\t{\n \t  int max_curr = MAX_INLINE_INSNS_SINGLE\n \t\t\t- (sum_insns - MAX_INLINE_INSNS) / MAX_INLINE_SLOPE;\n \t  if (currfn_insns > max_curr)\n@@ -736,7 +736,7 @@ inlinable_function_p (fn, id)\n \n   if (inlinable && (*lang_hooks.tree_inlining.cannot_inline_tree_fn) (&fn))\n     inlinable = 0;\n-  \n+\n   /* If we don't have the function body available, we can't inline\n      it.  */\n   if (! DECL_SAVED_TREE (fn))\n@@ -1034,7 +1034,7 @@ optimize_inline_calls (fn)\n {\n   inline_data id;\n   tree prev_fn;\n-  \n+\n   /* Clear out ID.  */\n   memset (&id, 0, sizeof (id));\n \n@@ -1051,7 +1051,7 @@ optimize_inline_calls (fn)\n \n   prev_fn = ((*lang_hooks.tree_inlining.add_pending_fn_decls)\n \t     (&id.fns, prev_fn));\n-  \n+\n   /* Create the stack of TARGET_EXPRs.  */\n   VARRAY_TREE_INIT (id.target_exprs, 32, \"target_exprs\");\n \n@@ -1075,7 +1075,7 @@ optimize_inline_calls (fn)\n   if (DECL_LANG_SPECIFIC (fn))\n     {\n       tree ifn = make_tree_vec (VARRAY_ACTIVE_SIZE (id.inlined_fns));\n-      \n+\n       memcpy (&TREE_VEC_ELT (ifn, 0), &VARRAY_TREE (id.inlined_fns, 0),\n \t      VARRAY_ACTIVE_SIZE (id.inlined_fns) * sizeof (tree));\n       DECL_INLINED_FNS (fn) = ifn;\n@@ -1122,7 +1122,7 @@ clone_body (clone, fn, arg_map)\n    to record the nodes visited, and to avoid visiting a node more than\n    once.  */\n \n-tree \n+tree\n walk_tree (tp, func, data, htab_)\n      tree *tp;\n      walk_tree_fn func;\n@@ -1133,7 +1133,7 @@ walk_tree (tp, func, data, htab_)\n   enum tree_code code;\n   int walk_subtrees;\n   tree result;\n-  \n+\n #define WALK_SUBTREE(NODE)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n@@ -1159,7 +1159,7 @@ walk_tree (tp, func, data, htab_)\n   if (htab)\n     {\n       void **slot;\n-      \n+\n       /* Don't walk the same tree twice, if the user has requested\n          that we avoid doing so.  */\n       if (htab_find (htab, *tp))\n@@ -1219,8 +1219,8 @@ walk_tree (tp, func, data, htab_)\n \t entire statement tree.  */\n       if (statement_code_p (code))\n \t{\n-\t  if (code == DECL_STMT \n-\t      && DECL_STMT_DECL (*tp) \n+\t  if (code == DECL_STMT\n+\t      && DECL_STMT_DECL (*tp)\n \t      && DECL_P (DECL_STMT_DECL (*tp)))\n \t    {\n \t      /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n@@ -1342,10 +1342,10 @@ walk_tree (tp, func, data, htab_)\n #undef WALK_SUBTREE\n }\n \n-/* Like walk_tree, but does not walk duplicate nodes more than \n+/* Like walk_tree, but does not walk duplicate nodes more than\n    once.  */\n \n-tree \n+tree\n walk_tree_without_duplicates (tp, func, data)\n      tree *tp;\n      walk_tree_fn func;\n@@ -1422,7 +1422,7 @@ remap_save_expr (tp, st_, fn, walk_subtrees)\n \n   /* See if we already encountered this SAVE_EXPR.  */\n   n = splay_tree_lookup (st, (splay_tree_key) *tp);\n-      \n+\n   /* If we didn't already remap this SAVE_EXPR, do so now.  */\n   if (!n)\n     {"}]}