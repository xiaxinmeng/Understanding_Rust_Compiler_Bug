{"sha": "960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYwYmZiNjkyOWZhNWM0NjMyNjdiOTYyYjlmZjlkYWJkYjZkZjNmMw==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2012-04-14T10:24:59Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2012-04-14T10:24:59Z"}, "message": "cgraph.h: Update copyrights;\n\n\n\t* cgraph.h: Update copyrights;\n\t(symtab_node): Turn to union typedef.\n\t(symtab_node_base): New structure.\n\t(symtab_type): Add SYMTAB_SYMBOL tag.\n\t* cgraph.c: Update references to fields\n\t(cgraph_hash, assembler_name_hash): Turn into symtab_node.\n\t(cgraph_local_info): Remove lto_file_data\n\tand externally_visible.\n\t(cgraph_node): Remove decl; same_comdat_group list;\n\taux; ref_list; order; address_taken; reachable_from_other_parittion,\n\tin_other_partition; resolution.\n\t(varpool_node): Remove decl; same_comdat_group;\n\tref_list; lto_file_data; aux; order; resolution; externally_visible;\n\tused_from_other_partition; in_other_partition.\n\t(symtab_node_def); New union.\n\t(cgraph, varpool): Update.\n\t(varpool_first_static_initializer, varpool_next_static_initializer,\n\tcgraph_only_called_directly_or_aliased_p,\n\tvarpool_can_remove_if_no_refs, varpool_can_remove_if_no_refs,\n\tvarpool_all_refs_explicit_p, cgraph_alias_aliased_node,\n\tvarpool_alias_aliased_node, cgraph_edge_recursive_p): Update\n\tfield references.\n\t* cgraph.c: Likewise.\n\t* cgraphbuild.c: Likewise.\n\t* lto-symtab.c: Likewise.\n\t* c-gimplify.c: Likewise.\n\t* value-prof.c: Likewise.\n\t* tree.c: Likewise.\n\t* ipa-cp.c: Likewise.\n\t* tree-emutls.c: Likewise.\n\t* ipa-inline-transform.c: Likwise.\n\t* ipa-reference.c: Likewise.\n\t* cgraphunit.c: Likewise.\n\t* ipa-ref.c: Likewise.\n\t* lto-cgraph.c: Likewise.\n\t* ipa-ref-inline.h: Likewise.\n\t* ipa-pure-const.c: Likewise.\n\t* lto-streamer-out.c: Likewise.\n\t* ipa-utils.c: Likewise.\n\t* ipa-inline.c: Likewise.\n\t* matrix-reorg.c: Likewise.\n\t* tree-eh.c: Likewise.\n\t* tree-vectorizer.c: Likewise.\n\t* ipa-split.c: Likewise.\n\t* ipa.c: Likewise.\n\t* trans-mem.c: Likewise.\n\t* ipa-inline-analysis.c: Likewise.\n\t* gimplify.c: Likewise.\n\t* cfgexpand.c: Likewise.\n\t* tree-sra.c: Likewise.\n\t* ipa-prop.c: Likewise.\n\t* varasm.c: Likewise.\n\t* tree-nested.c: Likewise.\n\t* tree-inline.c: Likewise.\n\t* tree-profile.c: Likewise.\n\t* tree-ssa-structalias.c: Likewise.\n\t* passes.c: Likewise.\n\t* varpool.c: Likewise.\n\n\t* tree.c: Update field referenced for new cgraph/varpool layout.\n\t* decl2.c: Likewise.\n\n\t* gcc-interface/trans.c (finalize_nrv): Update field referenced for new\n\tcgraph/varpool layout.\n\n\t* lto.c: Update field referenced for new cgraph/varpool layout.\n\t* lto-partition.c: Likewise.\n\nFrom-SVN: r186450", "tree": {"sha": "7b0127a94d4c70c75f4d133c7806c59bc61566c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7b0127a94d4c70c75f4d133c7806c59bc61566c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/comments", "author": null, "committer": null, "parents": [{"sha": "30d1ab7583da1d36deae5885fe9c92608cb6e929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d1ab7583da1d36deae5885fe9c92608cb6e929", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d1ab7583da1d36deae5885fe9c92608cb6e929"}], "stats": {"total": 2461, "additions": 1304, "deletions": 1157}, "files": [{"sha": "eede49f01bc91761338f080c6aa2bff557a1a7e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1,3 +1,65 @@\n+2012-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cgraph.h: Update copyrights;\n+\t(symtab_node): Turn to union typedef.\n+\t(symtab_node_base): New structure.\n+\t(symtab_type): Add SYMTAB_SYMBOL tag.\n+\t(cgraph_node): Annotate some pinters with nested_ptr.\n+\t(varpool_node): Likewise.\n+\t(cgraph_local_info): Remove lto_file_data\n+\tand externally_visible.\n+\t(cgraph_node): Remove decl; same_comdat_group list;\n+\taux; ref_list; order; address_taken; reachable_from_other_parittion,\n+\tin_other_partition; resolution.\n+\t(varpool_node): Remove decl; same_comdat_group;\n+\tref_list; lto_file_data; aux; order; resolution; externally_visible;\n+\tused_from_other_partition; in_other_partition.\n+\t(symtab_node_def); New union.\n+\t(cgraph, varpool): Update.\n+\t(varpool_first_static_initializer, varpool_next_static_initializer,\n+\tcgraph_only_called_directly_or_aliased_p,\n+\tvarpool_can_remove_if_no_refs, varpool_can_remove_if_no_refs,\n+\tvarpool_all_refs_explicit_p, cgraph_alias_aliased_node,\n+\tvarpool_alias_aliased_node, cgraph_edge_recursive_p): Update\n+\tfield references.\n+\t* cgraph.c: Likewise.\n+\t(cgraph_hash, assembler_name_hash): Turn into symtab_node.\n+\t* cgraphbuild.c: Likewise.\n+\t* lto-symtab.c: Likewise.\n+\t* c-gimplify.c: Likewise.\n+\t* value-prof.c: Likewise.\n+\t* tree.c: Likewise.\n+\t* ipa-cp.c: Likewise.\n+\t* tree-emutls.c: Likewise.\n+\t* ipa-inline-transform.c: Likwise.\n+\t* ipa-reference.c: Likewise.\n+\t* cgraphunit.c: Likewise.\n+\t* ipa-ref.c: Likewise.\n+\t* lto-cgraph.c: Likewise.\n+\t* ipa-ref-inline.h: Likewise.\n+\t* ipa-pure-const.c: Likewise.\n+\t* lto-streamer-out.c: Likewise.\n+\t* ipa-utils.c: Likewise.\n+\t* ipa-inline.c: Likewise.\n+\t* matrix-reorg.c: Likewise.\n+\t* tree-eh.c: Likewise.\n+\t* tree-vectorizer.c: Likewise.\n+\t* ipa-split.c: Likewise.\n+\t* ipa.c: Likewise.\n+\t* trans-mem.c: Likewise.\n+\t* ipa-inline-analysis.c: Likewise.\n+\t* gimplify.c: Likewise.\n+\t* cfgexpand.c: Likewise.\n+\t* tree-sra.c: Likewise.\n+\t* ipa-prop.c: Likewise.\n+\t* varasm.c: Likewise.\n+\t* tree-nested.c: Likewise.\n+\t* tree-inline.c: Likewise.\n+\t* tree-profile.c: Likewise.\n+\t* tree-ssa-structalias.c: Likewise.\n+\t* passes.c: Likewise.\n+\t* varpool.c: Likewise.\n+\n 2012-04-14  Tom de Vries  <tom@codesourcery.com>\n \n \t* tree-ssa-tail-merge.c (stmt_local_def): New function, factored out of"}, {"sha": "ef1214a9785e5054bc2883d9b42fd5cadd218a68", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1,3 +1,8 @@\n+2012-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc-interface/trans.c (finalize_nrv): Update field referenced for new\n+\tcgraph/varpool layout.\n+\n 2012-04-09  Mike Stump  <mikestump@comcast.net>\n \n \t* a-assert.ads: Remove execute permission."}, {"sha": "cdcc2172275b268d255dab7da1a9306a0ed784c0", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -3024,7 +3024,7 @@ finalize_nrv (tree fndecl, bitmap nrv, VEC(tree,gc) *other, Node_Id gnat_ret)\n   /* Prune also the candidates that are referenced by nested functions.  */\n   node = cgraph_get_create_node (fndecl);\n   for (node = node->nested; node; node = node->next_nested)\n-    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->decl), prune_nrv_r,\n+    walk_tree_without_duplicates (&DECL_SAVED_TREE (node->symbol.decl), prune_nrv_r,\n \t\t\t\t  &data);\n   if (bitmap_empty_p (nrv))\n     return;"}, {"sha": "b39201c215de84c55a5512160b8811201c0ba1ca", "filename": "gcc/c-family/c-gimplify.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fc-family%2Fc-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fc-family%2Fc-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-gimplify.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -100,7 +100,7 @@ c_genericize (tree fndecl)\n   /* Dump all nested functions now.  */\n   cgn = cgraph_get_create_node (fndecl);\n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n-    c_genericize (cgn->decl);\n+    c_genericize (cgn->symbol.decl);\n }\n \n static void"}, {"sha": "9de3e51c673f634cb6a1af4214525bac7e20d6c5", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1488,9 +1488,9 @@ estimated_stack_frame_size (struct cgraph_node *node)\n   tree var;\n   tree old_cur_fun_decl = current_function_decl;\n   referenced_var_iterator rvi;\n-  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n \n-  current_function_decl = node->decl;\n+  current_function_decl = node->symbol.decl;\n   push_cfun (fn);\n \n   gcc_checking_assert (gimple_referenced_vars (fn));"}, {"sha": "1a354b6596823dbf3970d00e064207bbd1640523", "filename": "gcc/cgraph.c", "status": "modified", "additions": 149, "deletions": 141, "changes": 290, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -120,15 +120,16 @@ static inline void cgraph_edge_remove_caller (struct cgraph_edge *e);\n static inline void cgraph_edge_remove_callee (struct cgraph_edge *e);\n \n /* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (struct cgraph_node))) htab_t cgraph_hash;\n+static GTY((param_is (union symtab_node_def))) htab_t cgraph_hash;\n /* Hash table used to convert assembler names into nodes.  */\n-static GTY((param_is (struct cgraph_node))) htab_t assembler_name_hash;\n+static GTY((param_is (union symtab_node_def))) htab_t assembler_name_hash;\n \n /* The linked list of cgraph nodes.  */\n-struct cgraph_node *cgraph_nodes;\n+symtab_node x_cgraph_nodes;\n \n /* Queue of cgraph nodes scheduled to be lowered.  */\n-struct cgraph_node *cgraph_nodes_queue;\n+symtab_node x_cgraph_nodes_queue;\n+#define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n \n /* Queue of cgraph nodes scheduled to be added into cgraph.  This is a\n    secondary queue used during optimization to accommodate passes that\n@@ -431,7 +432,7 @@ static hashval_t\n hash_node (const void *p)\n {\n   const struct cgraph_node *n = (const struct cgraph_node *) p;\n-  return (hashval_t) DECL_UID (n->decl);\n+  return (hashval_t) DECL_UID (n->symbol.decl);\n }\n \n \n@@ -442,7 +443,7 @@ eq_node (const void *p1, const void *p2)\n {\n   const struct cgraph_node *n1 = (const struct cgraph_node *) p1;\n   const struct cgraph_node *n2 = (const struct cgraph_node *) p2;\n-  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n+  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n }\n \n /* Allocate new callgraph node.  */\n@@ -475,14 +476,14 @@ cgraph_create_node_1 (void)\n \n   node->symbol.type = SYMTAB_FUNCTION;\n   node->next = cgraph_nodes;\n-  node->order = cgraph_order++;\n+  node->symbol.order = cgraph_order++;\n   if (cgraph_nodes)\n     cgraph_nodes->previous = node;\n   node->previous = NULL;\n   node->frequency = NODE_FREQUENCY_NORMAL;\n   node->count_materialization_scale = REG_BR_PROB_BASE;\n-  ipa_empty_ref_list (&node->ref_list);\n-  cgraph_nodes = node;\n+  ipa_empty_ref_list (&node->symbol.ref_list);\n+  x_cgraph_nodes = (symtab_node)node;\n   cgraph_n_nodes++;\n   return node;\n }\n@@ -499,12 +500,12 @@ cgraph_create_node (tree decl)\n   if (!cgraph_hash)\n     cgraph_hash = htab_create_ggc (10, hash_node, eq_node, NULL);\n \n-  key.decl = decl;\n+  key.symbol.decl = decl;\n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key, INSERT);\n   gcc_assert (!*slot);\n \n   node = cgraph_create_node_1 ();\n-  node->decl = decl;\n+  node->symbol.decl = decl;\n   *slot = node;\n   if (DECL_CONTEXT (decl) && TREE_CODE (DECL_CONTEXT (decl)) == FUNCTION_DECL)\n     {\n@@ -654,7 +655,7 @@ cgraph_get_node (const_tree decl)\n   if (!cgraph_hash)\n     return NULL;\n \n-  key.decl = CONST_CAST2 (tree, const_tree, decl);\n+  key.symbol.decl = CONST_CAST2 (tree, const_tree, decl);\n \n   slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, &key,\n \t\t\t\t\t\t NO_INSERT);\n@@ -683,7 +684,7 @@ static hashval_t\n hash_node_by_assembler_name (const void *p)\n {\n   const struct cgraph_node *n = (const struct cgraph_node *) p;\n-  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->decl));\n+  return (hashval_t) decl_assembler_name_hash (DECL_ASSEMBLER_NAME (n->symbol.decl));\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n@@ -693,7 +694,7 @@ eq_assembler_name (const void *p1, const void *p2)\n {\n   const struct cgraph_node *n1 = (const struct cgraph_node *) p1;\n   const_tree name = (const_tree)p2;\n-  return (decl_assembler_name_equal (n1->decl, name));\n+  return (decl_assembler_name_equal (n1->symbol.decl, name));\n }\n \n /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n@@ -713,7 +714,7 @@ cgraph_node_for_asm (tree asmname)\n       for (node = cgraph_nodes; node; node = node->next)\n         if (!node->global.inlined_to)\n \t  {\n-\t    tree name = DECL_ASSEMBLER_NAME (node->decl);\n+\t    tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n \t    slot = htab_find_slot_with_hash (assembler_name_hash, name,\n \t\t\t\t\t     decl_assembler_name_hash (name),\n \t\t\t\t\t     INSERT);\n@@ -841,7 +842,7 @@ cgraph_set_call_stmt (struct cgraph_edge *e, gimple new_stmt)\n       cgraph_make_edge_direct (e, new_callee);\n     }\n \n-  push_cfun (DECL_STRUCT_FUNCTION (e->caller->decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (e->caller->symbol.decl));\n   e->can_throw_external = stmt_can_throw_external (new_stmt);\n   pop_cfun ();\n   if (e->caller->call_site_hash)\n@@ -986,13 +987,13 @@ cgraph_create_edge_1 (struct cgraph_node *caller, struct cgraph_node *callee,\n   gcc_assert (freq <= CGRAPH_FREQ_MAX);\n \n   edge->call_stmt = call_stmt;\n-  push_cfun (DECL_STRUCT_FUNCTION (caller->decl));\n+  push_cfun (DECL_STRUCT_FUNCTION (caller->symbol.decl));\n   edge->can_throw_external\n     = call_stmt ? stmt_can_throw_external (call_stmt) : false;\n   pop_cfun ();\n   if (call_stmt\n-      && callee && callee->decl\n-      && !gimple_check_call_matching_types (call_stmt, callee->decl))\n+      && callee && callee->symbol.decl\n+      && !gimple_check_call_matching_types (call_stmt, callee->symbol.decl))\n     edge->call_stmt_cannot_inline_p = true;\n   else\n     edge->call_stmt_cannot_inline_p = false;\n@@ -1192,7 +1193,7 @@ cgraph_make_edge_direct (struct cgraph_edge *edge, struct cgraph_node *callee)\n \n   if (edge->call_stmt)\n     edge->call_stmt_cannot_inline_p\n-      = !gimple_check_call_matching_types (edge->call_stmt, callee->decl);\n+      = !gimple_check_call_matching_types (edge->call_stmt, callee->symbol.decl);\n \n   /* We need to re-determine the inlining status of the edge.  */\n   initialize_inline_failed (edge);\n@@ -1235,7 +1236,7 @@ cgraph_update_edges_for_call_stmt_node (struct cgraph_node *node,\n \t      struct cgraph_node *callee = e->callee;\n \t      while (callee)\n \t\t{\n-\t\t  if (callee->decl == new_call\n+\t\t  if (callee->symbol.decl == new_call\n \t\t      || callee->former_clone_of == new_call)\n \t\t    return;\n \t\t  callee = callee->clone_of;\n@@ -1361,10 +1362,10 @@ cgraph_node_remove_callers (struct cgraph_node *node)\n void\n cgraph_release_function_body (struct cgraph_node *node)\n {\n-  if (DECL_STRUCT_FUNCTION (node->decl))\n+  if (DECL_STRUCT_FUNCTION (node->symbol.decl))\n     {\n       tree old_decl = current_function_decl;\n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n       if (cfun->cfg\n \t  && current_loops)\n \t{\n@@ -1373,7 +1374,7 @@ cgraph_release_function_body (struct cgraph_node *node)\n \t}\n       if (cfun->gimple_df)\n \t{\n-\t  current_function_decl = node->decl;\n+\t  current_function_decl = node->symbol.decl;\n \t  delete_tree_ssa ();\n \t  delete_tree_cfg_annotations ();\n \t  cfun->eh = NULL;\n@@ -1388,20 +1389,20 @@ cgraph_release_function_body (struct cgraph_node *node)\n       if (cfun->value_histograms)\n \tfree_histograms ();\n       pop_cfun();\n-      gimple_set_body (node->decl, NULL);\n+      gimple_set_body (node->symbol.decl, NULL);\n       VEC_free (ipa_opt_pass, heap,\n       \t\tnode->ipa_transforms_to_apply);\n       /* Struct function hangs a lot of data that would leak if we didn't\n          removed all pointers to it.   */\n-      ggc_free (DECL_STRUCT_FUNCTION (node->decl));\n-      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+      ggc_free (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      DECL_STRUCT_FUNCTION (node->symbol.decl) = NULL;\n     }\n-  DECL_SAVED_TREE (node->decl) = NULL;\n+  DECL_SAVED_TREE (node->symbol.decl) = NULL;\n   /* If the node is abstract and needed, then do not clear DECL_INITIAL\n      of its associated function function declaration because it's\n      needed to emit debug info later.  */\n   if (!node->abstract_and_needed)\n-    DECL_INITIAL (node->decl) = error_mark_node;\n+    DECL_INITIAL (node->symbol.decl) = error_mark_node;\n }\n \n /* Remove the node from cgraph.  */\n@@ -1417,8 +1418,8 @@ cgraph_remove_node (struct cgraph_node *node)\n   cgraph_call_node_removal_hooks (node);\n   cgraph_node_remove_callers (node);\n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n-  ipa_remove_all_refering (&node->ref_list);\n+  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_refering (&node->symbol.ref_list);\n   VEC_free (ipa_opt_pass, heap,\n             node->ipa_transforms_to_apply);\n \n@@ -1439,7 +1440,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   if (node->previous)\n     node->previous->next = node->next;\n   else\n-    cgraph_nodes = node->next;\n+    x_cgraph_nodes = (symtab_node)node->next;\n   if (node->next)\n     node->next->previous = node->previous;\n   node->next = NULL;\n@@ -1450,7 +1451,8 @@ cgraph_remove_node (struct cgraph_node *node)\n       struct cgraph_node *next_inline_clone;\n \n       for (next_inline_clone = node->clones;\n-      \t   next_inline_clone && next_inline_clone->decl != node->decl;\n+      \t   next_inline_clone\n+\t   && next_inline_clone->symbol.decl != node->symbol.decl;\n \t   next_inline_clone = next_inline_clone->next_sibling_clone)\n \t;\n \n@@ -1565,18 +1567,18 @@ cgraph_remove_node (struct cgraph_node *node)\n \t}\n     }\n \n-  if (node->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n     {\n-      struct cgraph_node *prev;\n-      for (prev = node->same_comdat_group;\n-\t   prev->same_comdat_group != node;\n-\t   prev = prev->same_comdat_group)\n+      symtab_node prev;\n+      for (prev = node->symbol.same_comdat_group;\n+\t   prev->symbol.same_comdat_group != (symtab_node)node;\n+\t   prev = prev->symbol.same_comdat_group)\n \t;\n-      if (node->same_comdat_group == prev)\n-\tprev->same_comdat_group = NULL;\n+      if (node->symbol.same_comdat_group == prev)\n+\tprev->symbol.same_comdat_group = NULL;\n       else\n-\tprev->same_comdat_group = node->same_comdat_group;\n-      node->same_comdat_group = NULL;\n+\tprev->symbol.same_comdat_group = node->symbol.same_comdat_group;\n+      node->symbol.same_comdat_group = NULL;\n     }\n \n   /* While all the clones are removed after being proceeded, the function\n@@ -1588,13 +1590,14 @@ cgraph_remove_node (struct cgraph_node *node)\n       struct cgraph_node *n = (struct cgraph_node *) *slot;\n       if (!n->clones && !n->clone_of && !n->global.inlined_to\n \t  && (cgraph_global_info_ready\n-\t      && (TREE_ASM_WRITTEN (n->decl) || DECL_EXTERNAL (n->decl)\n-\t\t  || n->in_other_partition)))\n+\t      && (TREE_ASM_WRITTEN (n->symbol.decl)\n+\t\t  || DECL_EXTERNAL (n->symbol.decl)\n+\t\t  || n->symbol.in_other_partition)))\n \tkill_body = true;\n     }\n   if (assembler_name_hash)\n     {\n-      tree name = DECL_ASSEMBLER_NAME (node->decl);\n+      tree name = DECL_ASSEMBLER_NAME (node->symbol.decl);\n       slot = htab_find_slot_with_hash (assembler_name_hash, name,\n \t\t\t\t       decl_assembler_name_hash (name),\n \t\t\t\t       NO_INSERT);\n@@ -1605,7 +1608,7 @@ cgraph_remove_node (struct cgraph_node *node)\n \n   if (kill_body)\n     cgraph_release_function_body (node);\n-  node->decl = NULL;\n+  node->symbol.decl = NULL;\n   if (node->call_site_hash)\n     {\n       htab_delete (node->call_site_hash);\n@@ -1616,6 +1619,7 @@ cgraph_remove_node (struct cgraph_node *node)\n   /* Clear out the node to NULL all pointers and add the node to the free\n      list.  */\n   memset (node, 0, sizeof(*node));\n+  node->symbol.type = SYMTAB_FUNCTION;\n   node->uid = uid;\n   NEXT_FREE_NODE (node) = free_nodes;\n   free_nodes = node;\n@@ -1624,25 +1628,25 @@ cgraph_remove_node (struct cgraph_node *node)\n /* Add NEW_ to the same comdat group that OLD is in.  */\n \n void\n-cgraph_add_to_same_comdat_group (struct cgraph_node *new_,\n-\t\t\t\t struct cgraph_node *old)\n+cgraph_add_to_same_comdat_group (struct cgraph_node *new_node,\n+\t\t\t\t struct cgraph_node *old_node)\n {\n-  gcc_assert (DECL_ONE_ONLY (old->decl));\n-  gcc_assert (!new_->same_comdat_group);\n-  gcc_assert (new_ != old);\n+  gcc_assert (DECL_ONE_ONLY (old_node->symbol.decl));\n+  gcc_assert (!new_node->symbol.same_comdat_group);\n+  gcc_assert (new_node != old_node);\n \n-  DECL_COMDAT_GROUP (new_->decl) = DECL_COMDAT_GROUP (old->decl);\n-  new_->same_comdat_group = old;\n-  if (!old->same_comdat_group)\n-    old->same_comdat_group = new_;\n+  DECL_COMDAT_GROUP (new_node->symbol.decl) = DECL_COMDAT_GROUP (old_node->symbol.decl);\n+  new_node->symbol.same_comdat_group = (symtab_node)old_node;\n+  if (!old_node->symbol.same_comdat_group)\n+    old_node->symbol.same_comdat_group = (symtab_node)new_node;\n   else\n     {\n-      struct cgraph_node *n;\n-      for (n = old->same_comdat_group;\n-\t   n->same_comdat_group != old;\n-\t   n = n->same_comdat_group)\n+      symtab_node n;\n+      for (n = old_node->symbol.same_comdat_group;\n+\t   n->symbol.same_comdat_group != (symtab_node)old_node;\n+\t   n = n->symbol.same_comdat_group)\n \t;\n-      n->same_comdat_group = new_;\n+      n->symbol.same_comdat_group = (symtab_node)new_node;\n     }\n }\n \n@@ -1681,15 +1685,15 @@ cgraph_mark_reachable_node (struct cgraph_node *node)\n \t  /* Verify that function does not appear to be needed out of blue\n \t     during the optimization process.  This can happen for extern\n \t     inlines when bodies was removed after inlining.  */\n-\t  gcc_assert ((node->analyzed || node->in_other_partition\n-\t\t       || DECL_EXTERNAL (node->decl)));\n+\t  gcc_assert ((node->analyzed || node->symbol.in_other_partition\n+\t\t       || DECL_EXTERNAL (node->symbol.decl)));\n \t}\n       else\n-        notice_global_symbol (node->decl);\n+        notice_global_symbol (node->symbol.decl);\n       node->reachable = 1;\n \n       node->next_needed = cgraph_nodes_queue;\n-      cgraph_nodes_queue = node;\n+      x_cgraph_nodes_queue = (symtab_node)node;\n     }\n }\n \n@@ -1717,9 +1721,9 @@ cgraph_mark_address_taken_node (struct cgraph_node *node)\n      of the object was taken (and thus it should be set on node alias is\n      referring to).  We should remove the first use and the remove the\n      following set.  */\n-  node->address_taken = 1;\n+  node->symbol.address_taken = 1;\n   node = cgraph_function_or_thunk_node (node, NULL);\n-  node->address_taken = 1;\n+  node->symbol.address_taken = 1;\n }\n \n /* Return local info for the compiled function.  */\n@@ -1761,7 +1765,7 @@ cgraph_rtl_info (tree decl)\n   node = cgraph_get_node (decl);\n   if (!node\n       || (decl != current_function_decl\n-\t  && !TREE_ASM_WRITTEN (node->decl)))\n+\t  && !TREE_ASM_WRITTEN (node->symbol.decl)))\n     return NULL;\n   return &node->rtl;\n }\n@@ -1788,7 +1792,7 @@ cgraph_inline_failed_string (cgraph_inline_failed_t reason)\n const char *\n cgraph_node_name (struct cgraph_node *node)\n {\n-  return lang_hooks.decl_printable_name (node->decl, 2);\n+  return lang_hooks.decl_printable_name (node->symbol.decl, 2);\n }\n \n /* Names used to print out the availability enum.  */\n@@ -1806,16 +1810,17 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \n   fprintf (f, \"%s/%i\", cgraph_node_name (node), node->uid);\n   dump_addr (f, \" @\", (void *)node);\n-  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n-    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n+  if (DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl))\n+    fprintf (f, \" (asm: %s)\",\n+\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->symbol.decl)));\n   if (node->global.inlined_to)\n     fprintf (f, \" (inline copy in %s/%i)\",\n \t     cgraph_node_name (node->global.inlined_to),\n \t     node->global.inlined_to->uid);\n-  if (node->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n     fprintf (f, \" (same comdat group as %s/%i)\",\n-\t     cgraph_node_name (node->same_comdat_group),\n-\t     node->same_comdat_group->uid);\n+\t     cgraph_node_name (cgraph (node->symbol.same_comdat_group)),\n+\t     cgraph (node->symbol.same_comdat_group)->uid);\n   if (node->clone_of)\n     fprintf (f, \" (clone of %s/%i)\",\n \t     cgraph_node_name (node->clone_of),\n@@ -1825,7 +1830,7 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n \t     cgraph_availability_names [cgraph_function_body_availability (node)]);\n   if (node->analyzed)\n     fprintf (f, \" analyzed\");\n-  if (node->in_other_partition)\n+  if (node->symbol.in_other_partition)\n     fprintf (f, \" in_other_partition\");\n   if (node->count)\n     fprintf (f, \" executed \"HOST_WIDEST_INT_PRINT_DEC\"x\",\n@@ -1834,28 +1839,28 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     fprintf (f, \" nested in: %s\", cgraph_node_name (node->origin));\n   if (node->needed)\n     fprintf (f, \" needed\");\n-  if (node->address_taken)\n+  if (node->symbol.address_taken)\n     fprintf (f, \" address_taken\");\n   else if (node->reachable)\n     fprintf (f, \" reachable\");\n-  else if (node->reachable_from_other_partition)\n-    fprintf (f, \" reachable_from_other_partition\");\n-  if (gimple_has_body_p (node->decl))\n+  else if (node->symbol.used_from_other_partition)\n+    fprintf (f, \" used_from_other_partition\");\n+  if (gimple_has_body_p (node->symbol.decl))\n     fprintf (f, \" body\");\n   if (node->process)\n     fprintf (f, \" process\");\n   if (node->local.local)\n     fprintf (f, \" local\");\n-  if (node->local.externally_visible)\n+  if (node->symbol.externally_visible)\n     fprintf (f, \" externally_visible\");\n-  if (node->resolution != LDPR_UNKNOWN)\n+  if (node->symbol.resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n- \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n+ \t     ld_plugin_symbol_resolution_names[(int)node->symbol.resolution]);\n   if (node->local.finalized)\n     fprintf (f, \" finalized\");\n   if (node->local.redefined_extern_inline)\n     fprintf (f, \" redefined_extern_inline\");\n-  if (TREE_ASM_WRITTEN (node->decl))\n+  if (TREE_ASM_WRITTEN (node->symbol.decl))\n     fprintf (f, \" asm_written\");\n   if (node->only_called_at_startup)\n     fprintf (f, \" only_called_at_startup\");\n@@ -1928,9 +1933,9 @@ dump_cgraph_node (FILE *f, struct cgraph_node *node)\n     }\n   fprintf (f, \"\\n\");\n   fprintf (f, \"  References: \");\n-  ipa_dump_references (f, &node->ref_list);\n+  ipa_dump_references (f, &node->symbol.ref_list);\n   fprintf (f, \"  Refering this function: \");\n-  ipa_dump_refering (f, &node->ref_list);\n+  ipa_dump_refering (f, &node->symbol.ref_list);\n \n   for (edge = node->indirect_calls; edge; edge = edge->next_callee)\n     indirect_calls_count++;\n@@ -2128,7 +2133,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   gcov_type count_scale;\n   unsigned i;\n \n-  new_node->decl = decl;\n+  new_node->symbol.decl = decl;\n   new_node->origin = n->origin;\n   if (new_node->origin)\n     {\n@@ -2137,7 +2142,7 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n     }\n   new_node->analyzed = n->analyzed;\n   new_node->local = n->local;\n-  new_node->local.externally_visible = false;\n+  new_node->symbol.externally_visible = false;\n   new_node->local.local = true;\n   new_node->global = n->global;\n   new_node->rtl = n->rtl;\n@@ -2176,15 +2181,15 @@ cgraph_clone_node (struct cgraph_node *n, tree decl, gcov_type count, int freq,\n   for (e = n->indirect_calls; e; e = e->next_callee)\n     cgraph_clone_edge (e, new_node, e->call_stmt, e->lto_stmt_uid,\n \t\t       count_scale, freq, update_original);\n-  ipa_clone_references (new_node, NULL, &n->ref_list);\n+  ipa_clone_references (new_node, NULL, &n->symbol.ref_list);\n \n   new_node->next_sibling_clone = n->clones;\n   if (n->clones)\n     n->clones->prev_sibling_clone = new_node;\n   n->clones = new_node;\n   new_node->clone_of = n;\n \n-  if (n->decl != decl)\n+  if (n->symbol.decl != decl)\n     {\n       struct cgraph_node **slot;\n       slot = (struct cgraph_node **) htab_find_slot (cgraph_hash, new_node, INSERT);\n@@ -2246,7 +2251,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n \t\t\t     bitmap args_to_skip,\n \t\t\t     const char * suffix)\n {\n-  tree old_decl = old_node->decl;\n+  tree old_decl = old_node->symbol.decl;\n   struct cgraph_node *new_node = NULL;\n   tree new_decl;\n   size_t i;\n@@ -2277,15 +2282,15 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  DECL_EXTERNAL (new_node->decl) = 0;\n+  DECL_EXTERNAL (new_node->symbol.decl) = 0;\n   if (DECL_ONE_ONLY (old_decl))\n-    DECL_SECTION_NAME (new_node->decl) = NULL;\n-  DECL_COMDAT_GROUP (new_node->decl) = 0;\n-  TREE_PUBLIC (new_node->decl) = 0;\n-  DECL_COMDAT (new_node->decl) = 0;\n-  DECL_WEAK (new_node->decl) = 0;\n-  DECL_STATIC_CONSTRUCTOR (new_node->decl) = 0;\n-  DECL_STATIC_DESTRUCTOR (new_node->decl) = 0;\n+    DECL_SECTION_NAME (new_node->symbol.decl) = NULL;\n+  DECL_COMDAT_GROUP (new_node->symbol.decl) = 0;\n+  TREE_PUBLIC (new_node->symbol.decl) = 0;\n+  DECL_COMDAT (new_node->symbol.decl) = 0;\n+  DECL_WEAK (new_node->symbol.decl) = 0;\n+  DECL_STATIC_CONSTRUCTOR (new_node->symbol.decl) = 0;\n+  DECL_STATIC_DESTRUCTOR (new_node->symbol.decl) = 0;\n   new_node->clone.tree_map = tree_map;\n   new_node->clone.args_to_skip = args_to_skip;\n   FOR_EACH_VEC_ELT (ipa_replace_map_p, tree_map, i, map)\n@@ -2322,7 +2327,8 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n       struct cgraph_node *orig_node;\n       for (orig_node = old_node; orig_node->clone_of; orig_node = orig_node->clone_of)\n         ;\n-      for (arg = DECL_ARGUMENTS (orig_node->decl); arg; arg = DECL_CHAIN (arg), oldi++)\n+      for (arg = DECL_ARGUMENTS (orig_node->symbol.decl);\n+\t   arg; arg = DECL_CHAIN (arg), oldi++)\n \t{\n \t  if (bitmap_bit_p (old_node->clone.combined_args_to_skip, oldi))\n \t    {\n@@ -2337,7 +2343,7 @@ cgraph_create_virtual_clone (struct cgraph_node *old_node,\n     }\n   else\n     new_node->clone.combined_args_to_skip = args_to_skip;\n-  new_node->local.externally_visible = 0;\n+  new_node->symbol.externally_visible = 0;\n   new_node->local.local = 1;\n   new_node->lowered = true;\n   new_node->reachable = true;\n@@ -2372,12 +2378,12 @@ cgraph_function_body_availability (struct cgraph_node *node)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (node->local.local)\n     avail = AVAIL_LOCAL;\n-  else if (!node->local.externally_visible)\n+  else if (!node->symbol.externally_visible)\n     avail = AVAIL_AVAILABLE;\n   /* Inline functions are safe to be analyzed even if their symbol can\n      be overwritten at runtime.  It is not meaningful to enforce any sane\n      behaviour on replacing inline function by different body.  */\n-  else if (DECL_DECLARED_INLINE_P (node->decl))\n+  else if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n     avail = AVAIL_AVAILABLE;\n \n   /* If the function can be overwritten, return OVERWRITABLE.  Take\n@@ -2390,7 +2396,8 @@ cgraph_function_body_availability (struct cgraph_node *node)\n      AVAIL_AVAILABLE here?  That would be good reason to preserve this\n      bit.  */\n \n-  else if (decl_replaceable_p (node->decl) && !DECL_EXTERNAL (node->decl))\n+  else if (decl_replaceable_p (node->symbol.decl)\n+\t   && !DECL_EXTERNAL (node->symbol.decl))\n     avail = AVAIL_OVERWRITABLE;\n   else avail = AVAIL_AVAILABLE;\n \n@@ -2403,8 +2410,9 @@ cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n \t\t\t\t void *data ATTRIBUTE_UNUSED)\n {\n   return !(!node->needed\n-\t   && ((DECL_COMDAT (node->decl) && !node->same_comdat_group)\n-\t       || !node->local.externally_visible));\n+\t   && ((DECL_COMDAT (node->symbol.decl)\n+\t\t&& !node->symbol.same_comdat_group)\n+\t       || !node->symbol.externally_visible));\n }\n \n /* Return true if NODE can be made local for API change.\n@@ -2414,7 +2422,7 @@ cgraph_node_cannot_be_local_p_1 (struct cgraph_node *node,\n bool\n cgraph_node_can_be_local_p (struct cgraph_node *node)\n {\n-  return (!node->address_taken\n+  return (!node->symbol.address_taken\n \t  && !cgraph_for_node_and_aliases (node,\n \t\t\t\t\t   cgraph_node_cannot_be_local_p_1,\n \t\t\t\t\t   NULL, true));\n@@ -2447,8 +2455,8 @@ cgraph_make_decl_local (tree decl)\n \t      struct cgraph_node *node = cgraph_get_node (decl);\n \t      change_decl_assembler_name (decl,\n \t\t\t\t\t  clone_function_name (decl, \"local\"));\n-\t      if (node->local.lto_file_data)\n-\t\tlto_record_renamed_decl (node->local.lto_file_data,\n+\t      if (node->symbol.lto_file_data)\n+\t\tlto_record_renamed_decl (node->symbol.lto_file_data,\n \t\t\t\t\t old_name,\n \t\t\t\t\t IDENTIFIER_POINTER\n \t\t\t\t\t   (DECL_ASSEMBLER_NAME (decl)));\n@@ -2460,8 +2468,8 @@ cgraph_make_decl_local (tree decl)\n \t\t C++ frontend still sets TREE_SYMBOL_REFERENCED on them.  */\n \t      SET_DECL_ASSEMBLER_NAME (decl,\n \t\t\t\t       clone_function_name (decl, \"local\"));\n-\t      if (vnode->lto_file_data)\n-\t\tlto_record_renamed_decl (vnode->lto_file_data,\n+\t      if (vnode->symbol.lto_file_data)\n+\t\tlto_record_renamed_decl (vnode->symbol.lto_file_data,\n \t\t\t\t\t old_name,\n \t\t\t\t\t IDENTIFIER_POINTER\n \t\t\t\t\t   (DECL_ASSEMBLER_NAME (decl)));\n@@ -2514,7 +2522,7 @@ cgraph_for_node_thunks_and_aliases (struct cgraph_node *node,\n       if (cgraph_for_node_thunks_and_aliases (e->caller, callback, data,\n \t\t\t\t\t      include_overwritable))\n \treturn true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n@@ -2542,7 +2550,7 @@ cgraph_for_node_and_aliases (struct cgraph_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n@@ -2561,13 +2569,13 @@ static bool\n cgraph_make_node_local_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n   gcc_checking_assert (cgraph_node_can_be_local_p (node));\n-  if (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n+  if (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n     {\n-      cgraph_make_decl_local (node->decl);\n+      cgraph_make_decl_local (node->symbol.decl);\n \n-      node->local.externally_visible = false;\n+      node->symbol.externally_visible = false;\n       node->local.local = true;\n-      node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+      node->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n       gcc_assert (cgraph_function_body_availability (node) == AVAIL_LOCAL);\n     }\n   return false;\n@@ -2589,7 +2597,7 @@ cgraph_set_nothrow_flag_1 (struct cgraph_node *node, void *data)\n {\n   struct cgraph_edge *e;\n \n-  TREE_NOTHROW (node->decl) = data != NULL;\n+  TREE_NOTHROW (node->symbol.decl) = data != NULL;\n \n   if (data != NULL)\n     for (e = node->callers; e; e = e->next_caller)\n@@ -2616,13 +2624,13 @@ cgraph_set_const_flag_1 (struct cgraph_node *node, void *data)\n      optimized out.  */\n   if (data && !((size_t)data & 2))\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n-      if (DECL_STATIC_DESTRUCTOR (node->decl))\n-\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+\tDECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n     }\n-  TREE_READONLY (node->decl) = data != NULL;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n+  TREE_READONLY (node->symbol.decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->symbol.decl) = ((size_t)data & 2) != 0;\n   return false;\n }\n \n@@ -2646,13 +2654,13 @@ cgraph_set_pure_flag_1 (struct cgraph_node *node, void *data)\n      optimized out.  */\n   if (data && !((size_t)data & 2))\n     {\n-      if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n-      if (DECL_STATIC_DESTRUCTOR (node->decl))\n-\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+      if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n+\tDECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n+      if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+\tDECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n     }\n-  DECL_PURE_P (node->decl) = data != NULL;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n+  DECL_PURE_P (node->symbol.decl) = data != NULL;\n+  DECL_LOOPING_CONST_OR_PURE_P (node->symbol.decl) = ((size_t)data & 2) != 0;\n   return false;\n }\n \n@@ -2697,7 +2705,7 @@ cgraph_propagate_frequency_1 (struct cgraph_node *node, void *data)\n \t  /* It makes sense to put main() together with the static constructors.\n \t     It will be executed for sure, but rest of functions called from\n \t     main are definitely not at startup only.  */\n-\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->decl)))\n+\t  if (MAIN_NAME_P (DECL_NAME (edge->caller->symbol.decl)))\n \t    d->only_called_at_startup = 0;\n           d->only_called_at_exit &= edge->caller->only_called_at_exit;\n \t}\n@@ -2795,7 +2803,7 @@ cgraph_propagate_frequency (struct cgraph_node *node)\n bool\n cgraph_node_cannot_return (struct cgraph_node *node)\n {\n-  int flags = flags_from_decl_or_type (node->decl);\n+  int flags = flags_from_decl_or_type (node->symbol.decl);\n   if (!flag_exceptions)\n     return (flags & ECF_NORETURN) != 0;\n   else\n@@ -2834,17 +2842,17 @@ cgraph_can_remove_if_no_direct_calls_and_refs_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (node->symbol.decl))\n     return true;\n   /* When function is needed, we can not remove it.  */\n-  if (node->needed || node->reachable_from_other_partition)\n+  if (node->needed || node->symbol.used_from_other_partition)\n     return false;\n-  if (DECL_STATIC_CONSTRUCTOR (node->decl)\n-      || DECL_STATIC_DESTRUCTOR (node->decl))\n+  if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n+      || DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n     return false;\n   /* Only COMDAT functions can be removed if externally visible.  */\n-  if (node->local.externally_visible\n-      && (!DECL_COMDAT (node->decl)\n+  if (node->symbol.externally_visible\n+      && (!DECL_COMDAT (node->symbol.decl)\n \t  || cgraph_used_from_object_file_p (node)))\n     return false;\n   return true;\n@@ -2865,9 +2873,9 @@ bool\n cgraph_can_remove_if_no_direct_calls_p (struct cgraph_node *node)\n {\n   /* Extern inlines can always go, we will use the external definition.  */\n-  if (DECL_EXTERNAL (node->decl))\n+  if (DECL_EXTERNAL (node->symbol.decl))\n     return true;\n-  if (node->address_taken)\n+  if (node->symbol.address_taken)\n     return false;\n   return !cgraph_for_node_and_aliases (node, nonremovable_p, NULL, true);\n }\n@@ -2904,7 +2912,7 @@ cgraph_will_be_removed_from_program_if_no_direct_calls (struct cgraph_node *node\n     return cgraph_only_called_directly_p (node);\n   else\n     {\n-       if (DECL_EXTERNAL (node->decl))\n+       if (DECL_EXTERNAL (node->symbol.decl))\n          return true;\n       return cgraph_can_remove_if_no_direct_calls_p (node);\n     }\n@@ -2930,9 +2938,9 @@ bool\n cgraph_used_from_object_file_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  if (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n+  if (!TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n     return false;\n-  if (resolution_used_from_other_file_p (node->resolution))\n+  if (resolution_used_from_other_file_p (node->symbol.resolution))\n     return true;\n   return false;\n }"}, {"sha": "d5d9eb07ad3c3e2f99b1f4cda342d1b6dcf2e76a", "filename": "gcc/cgraph.h", "status": "modified", "additions": 104, "deletions": 84, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1,6 +1,6 @@\n /* Callgraph handling code.\n-   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011\n-   Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,\n+   2012 Free Software Foundation, Inc.\n    Contributed by Jan Hubicka\n \n This file is part of GCC.\n@@ -33,16 +33,43 @@ along with GCC; see the file COPYING3.  If not see\n    TODO: add labels, constant pool and aliases.  */\n enum symtab_type\n {\n+  SYMTAB_SYMBOL,\n   SYMTAB_FUNCTION,\n   SYMTAB_VARIABLE\n };\n \n+union symtab_node_def;\n+typedef union symtab_node_def *symtab_node;\n+\n /* Base of all entries in the symbol table.\n    The symtab_node is inherited by cgraph and varpol nodes.  */\n-struct GTY(()) symtab_node\n+struct GTY(()) symtab_node_base\n {\n   /* Type of the symbol.  */\n   enum symtab_type type;\n+  tree decl;\n+  struct ipa_ref_list ref_list;\n+  /* Circular list of nodes in the same comdat group if non-NULL.  */\n+  symtab_node same_comdat_group;\n+  /* Ordering of all symtab entries.  */\n+  int order;\n+  enum ld_plugin_symbol_resolution resolution;\n+  /* File stream where this node is being written to.  */\n+  struct lto_file_decl_data * lto_file_data;\n+\n+  PTR GTY ((skip)) aux;\n+\n+  /* Set when function has address taken.\n+     In current implementation it imply needed flag. */\n+  unsigned address_taken : 1;\n+  /* Set when variable is used from other LTRANS partition.  */\n+  unsigned used_from_other_partition : 1;\n+  /* Set when function is available in the other LTRANS partition.  \n+     During WPA output it is used to mark nodes that are present in\n+     multiple partitions.  */\n+  unsigned in_other_partition : 1;\n+  /* Set when function is visible by other units.  */\n+  unsigned externally_visible : 1;\n };\n \n enum availability\n@@ -91,16 +118,10 @@ struct GTY(()) cgraph_thunk_info {\n    Available after function is analyzed.  */\n \n struct GTY(()) cgraph_local_info {\n-  /* File stream where this node is being written to.  */\n-  struct lto_file_decl_data * lto_file_data;\n-\n   /* Set when function function is visible in current compilation unit only\n      and its address is never taken.  */\n   unsigned local : 1;\n \n-  /* Set when function is visible by other units.  */\n-  unsigned externally_visible : 1;\n-\n   /* Set once it has been finalized so we consider it to be output.  */\n   unsigned finalized : 1;\n \n@@ -165,45 +186,51 @@ struct GTY(()) cgraph_clone_info\n /* The cgraph data structure.\n    Each function decl has assigned cgraph_node listing callees and callers.  */\n \n-struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n-  struct symtab_node symbol;\n-  tree decl;\n+struct GTY(()) cgraph_node {\n+  struct symtab_node_base symbol;\n   struct cgraph_edge *callees;\n   struct cgraph_edge *callers;\n-  struct cgraph_node *next;\n-  struct cgraph_node *previous;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    next;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    previous;\n   /* List of edges representing indirect calls with a yet undetermined\n      callee.  */\n   struct cgraph_edge *indirect_calls;\n   /* For nested functions points to function the node is nested in.  */\n-  struct cgraph_node *origin;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    origin;\n   /* Points to first nested function, if any.  */\n-  struct cgraph_node *nested;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    nested;\n   /* Pointer to the next function with same origin, if any.  */\n-  struct cgraph_node *next_nested;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    next_nested;\n   /* Pointer to the next function in cgraph_nodes_queue.  */\n-  struct cgraph_node *next_needed;\n+  struct cgraph_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct cgraph_node *)(%h)\", \"(symtab_node)%h\")))\n+    next_needed;\n   /* Pointer to the next clone.  */\n   struct cgraph_node *next_sibling_clone;\n   struct cgraph_node *prev_sibling_clone;\n   struct cgraph_node *clones;\n   struct cgraph_node *clone_of;\n-  /* Circular list of nodes in the same comdat group if non-NULL.  */\n-  struct cgraph_node *same_comdat_group;\n   /* For functions with many calls sites it holds map from call expression\n      to the edge to speed up cgraph_edge function.  */\n   htab_t GTY((param_is (struct cgraph_edge))) call_site_hash;\n   /* Declaration node used to be clone of. */\n   tree former_clone_of;\n \n-  PTR GTY ((skip)) aux;\n-\n   /* Interprocedural passes scheduled to have their transform functions\n      applied next time we execute local pass on them.  We maintain it\n      per-function in order to allow IPA passes to introduce new functions.  */\n   VEC(ipa_opt_pass,heap) * GTY((skip)) ipa_transforms_to_apply;\n \n-  struct ipa_ref_list ref_list;\n   struct cgraph_local_info local;\n   struct cgraph_global_info global;\n   struct cgraph_rtl_info rtl;\n@@ -217,20 +244,13 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n   int count_materialization_scale;\n   /* Unique id of the node.  */\n   int uid;\n-  /* Ordering of all cgraph nodes.  */\n-  int order;\n-\n-  enum ld_plugin_symbol_resolution resolution;\n \n   /* Set when function must be output for some reason.  The primary\n      use of this flag is to mark functions needed to be output for\n      non-standard reason.  Functions that are externally visible\n      or reachable from functions needed to be output are marked\n      by specialized flags.  */\n   unsigned needed : 1;\n-  /* Set when function has address taken.\n-     In current implementation it imply needed flag. */\n-  unsigned address_taken : 1;\n   /* Set when decl is an abstract function pointed to by the\n      ABSTRACT_DECL_ORIGIN of a reachable function.  */\n   unsigned abstract_and_needed : 1;\n@@ -241,17 +261,11 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.previous\"))) cgraph_node {\n      cgraph_remove_unreachable_nodes cgraph still can contain unreachable\n      nodes when they are needed for virtual clone instantiation.  */\n   unsigned reachable : 1;\n-  /* Set when function is reachable by call from other LTRANS partition.  */\n-  unsigned reachable_from_other_partition : 1;\n   /* Set once the function is lowered (i.e. its CFG is built).  */\n   unsigned lowered : 1;\n   /* Set once the function has been instantiated and its callee\n      lists created.  */\n   unsigned analyzed : 1;\n-  /* Set when function is available in the other LTRANS partition.  \n-     During WPA output it is used to mark nodes that are present in\n-     multiple partitions.  */\n-  unsigned in_other_partition : 1;\n   /* Set when function is scheduled to be processed by local passes.  */\n   unsigned process : 1;\n   /* Set for aliases once they got through assemble_alias.  */\n@@ -404,23 +418,23 @@ DEF_VEC_ALLOC_P(cgraph_edge_p,heap);\n    Each static variable decl has assigned varpool_node.  */\n \n struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n-  struct symtab_node symbol;\n-  tree decl;\n+  struct symtab_node_base symbol;\n   /* For aliases points to declaration DECL is alias of.  */\n   tree alias_of;\n   /* Pointer to the next function in varpool_nodes.  */\n-  struct varpool_node *next, *prev;\n+  struct varpool_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n+    next;\n+  struct varpool_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n+    prev;\n   /* Pointer to the next function in varpool_nodes_queue.  */\n-  struct varpool_node *next_needed, *prev_needed;\n-  /* Circular list of nodes in the same comdat group if non-NULL.  */\n-  struct varpool_node *same_comdat_group;\n-  struct ipa_ref_list ref_list;\n-  /* File stream where this node is being written to.  */\n-  struct lto_file_decl_data * lto_file_data;\n-  PTR GTY ((skip)) aux;\n-  /* Ordering of all cgraph nodes.  */\n-  int order;\n-  enum ld_plugin_symbol_resolution resolution;\n+  struct varpool_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n+    next_needed;\n+  struct varpool_node *\n+    GTY ((nested_ptr (union symtab_node_def, \"(struct varpool_node *)(%h)\", \"(symtab_node)%h\")))\n+    prev_needed;\n \n   /* Set when function must be output - it is externally visible\n      or its address is taken.  */\n@@ -435,18 +449,10 @@ struct GTY((chain_next (\"%h.next\"), chain_prev (\"%h.prev\"))) varpool_node {\n   unsigned finalized : 1;\n   /* Set when variable is scheduled to be assembled.  */\n   unsigned output : 1;\n-  /* Set when function is visible by other units.  */\n-  unsigned externally_visible : 1;\n   /* Set for aliases once they got through assemble_alias.  Also set for\n      extra name aliases in varpool_extra_name_alias.  */\n   unsigned alias : 1;\n   unsigned extra_name_alias : 1;\n-  /* Set when variable is used from other LTRANS partition.  */\n-  unsigned used_from_other_partition : 1;\n-  /* Set when variable is available in the other LTRANS partition.\n-     During WPA output it is used to mark nodes that are present in\n-     multiple partitions.  */\n-  unsigned in_other_partition : 1;\n };\n \n /* Every top level asm statement is put into a cgraph_asm_node.  */\n@@ -460,7 +466,17 @@ struct GTY(()) cgraph_asm_node {\n   int order;\n };\n \n-extern GTY(()) struct cgraph_node *cgraph_nodes;\n+/* Symbol table entry.  */\n+union GTY((desc (\"%h.symbol.type\"))) symtab_node_def {\n+  struct symtab_node_base GTY ((tag (\"SYMTAB_SYMBOL\"))) symbol;\n+  /* Use cgraph (symbol) accessor to get cgraph_node.  */\n+  struct cgraph_node GTY ((tag (\"SYMTAB_FUNCTION\"))) x_function;\n+  /* Use varpool (symbol) accessor to get varpool_node.  */\n+  struct varpool_node GTY ((tag (\"SYMTAB_VARIABLE\"))) x_variable;\n+};\n+\n+extern GTY(()) symtab_node x_cgraph_nodes;\n+#define cgraph_nodes ((struct cgraph_node *)x_cgraph_nodes)\n extern GTY(()) int cgraph_n_nodes;\n extern GTY(()) int cgraph_max_uid;\n extern GTY(()) int cgraph_edge_max_uid;\n@@ -480,7 +496,8 @@ enum cgraph_state\n };\n extern enum cgraph_state cgraph_state;\n extern bool cgraph_function_flags_ready;\n-extern GTY(()) struct cgraph_node *cgraph_nodes_queue;\n+extern GTY(()) symtab_node x_cgraph_nodes_queue;\n+#define cgraph_nodes_queue ((struct cgraph_node *)x_cgraph_nodes_queue)\n extern GTY(()) struct cgraph_node *cgraph_new_nodes;\n \n extern GTY(()) struct cgraph_asm_node *cgraph_asm_nodes;\n@@ -666,8 +683,10 @@ bool cgraph_maybe_hot_edge_p (struct cgraph_edge *e);\n bool cgraph_optimize_for_size_p (struct cgraph_node *);\n \n /* In varpool.c  */\n-extern GTY(()) struct varpool_node *varpool_nodes_queue;\n-extern GTY(()) struct varpool_node *varpool_nodes;\n+extern GTY(()) symtab_node x_varpool_nodes_queue;\n+extern GTY(()) symtab_node x_varpool_nodes;\n+#define varpool_nodes_queue ((struct varpool_node *)x_varpool_nodes_queue)\n+#define varpool_nodes ((struct varpool_node *)x_varpool_nodes)\n \n struct varpool_node *varpool_node (tree);\n struct varpool_node *varpool_node_for_asm (tree asmname);\n@@ -708,18 +727,18 @@ void varpool_add_new_variable (tree);\n \n /* Return callgraph node for given symbol and check it is a function. */\n static inline struct cgraph_node *\n-cgraph (struct symtab_node *node)\n+cgraph (symtab_node node)\n {\n-  gcc_checking_assert (node->type == SYMTAB_FUNCTION);\n-  return (struct cgraph_node *)node;\n+  gcc_checking_assert (!node || node->symbol.type == SYMTAB_FUNCTION);\n+  return &node->x_function;\n }\n \n /* Return varpool node for given symbol and check it is a variable.  */\n static inline struct varpool_node *\n-varpool (struct symtab_node *node)\n+varpool (symtab_node node)\n {\n-  gcc_checking_assert (node->type == SYMTAB_FUNCTION);\n-  return (struct varpool_node *)node;\n+  gcc_checking_assert (!node || node->symbol.type == SYMTAB_VARIABLE);\n+  return &node->x_variable;\n }\n \n \n@@ -730,8 +749,8 @@ varpool_first_static_initializer (void)\n   struct varpool_node *node;\n   for (node = varpool_nodes_queue; node; node = node->next_needed)\n     {\n-      gcc_checking_assert (TREE_CODE (node->decl) == VAR_DECL);\n-      if (DECL_INITIAL (node->decl))\n+      gcc_checking_assert (TREE_CODE (node->symbol.decl) == VAR_DECL);\n+      if (DECL_INITIAL (node->symbol.decl))\n \treturn node;\n     }\n   return NULL;\n@@ -743,8 +762,8 @@ varpool_next_static_initializer (struct varpool_node *node)\n {\n   for (node = node->next_needed; node; node = node->next_needed)\n     {\n-      gcc_checking_assert (TREE_CODE (node->decl) == VAR_DECL);\n-      if (DECL_INITIAL (node->decl))\n+      gcc_checking_assert (TREE_CODE (node->symbol.decl) == VAR_DECL);\n+      if (DECL_INITIAL (node->symbol.decl))\n \treturn node;\n     }\n   return NULL;\n@@ -966,11 +985,11 @@ static inline bool\n cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n {\n   gcc_assert (!node->global.inlined_to);\n-  return (!node->needed && !node->address_taken\n-\t  && !node->reachable_from_other_partition\n-\t  && !DECL_STATIC_CONSTRUCTOR (node->decl)\n-\t  && !DECL_STATIC_DESTRUCTOR (node->decl)\n-\t  && !node->local.externally_visible);\n+  return (!node->needed && !node->symbol.address_taken\n+\t  && !node->symbol.used_from_other_partition\n+\t  && !DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n+\t  && !DECL_STATIC_DESTRUCTOR (node->symbol.decl)\n+\t  && !node->symbol.externally_visible);\n }\n \n /* Return true when function NODE can be removed from callgraph\n@@ -979,8 +998,9 @@ cgraph_only_called_directly_or_aliased_p (struct cgraph_node *node)\n static inline bool\n varpool_can_remove_if_no_refs (struct varpool_node *node)\n {\n-  return (!node->force_output && !node->used_from_other_partition\n-  \t  && (DECL_COMDAT (node->decl) || !node->externally_visible));\n+  return (!node->force_output && !node->symbol.used_from_other_partition\n+  \t  && (DECL_COMDAT (node->symbol.decl)\n+\t  || !node->symbol.externally_visible));\n }\n \n /* Return true when all references to VNODE must be visible in ipa_ref_list.\n@@ -992,8 +1012,8 @@ static inline bool\n varpool_all_refs_explicit_p (struct varpool_node *vnode)\n {\n   return (vnode->analyzed\n-\t  && !vnode->externally_visible\n-\t  && !vnode->used_from_other_partition\n+\t  && !vnode->symbol.externally_visible\n+\t  && !vnode->symbol.used_from_other_partition\n \t  && !vnode->force_output);\n }\n \n@@ -1010,7 +1030,7 @@ cgraph_alias_aliased_node (struct cgraph_node *n)\n {\n   struct ipa_ref *ref;\n \n-  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n+  ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   if (ref->refered_type == IPA_REF_CGRAPH)\n     return ipa_ref_node (ref);\n@@ -1024,7 +1044,7 @@ varpool_alias_aliased_node (struct varpool_node *n)\n {\n   struct ipa_ref *ref;\n \n-  ipa_ref_list_reference_iterate (&n->ref_list, 0, ref);\n+  ipa_ref_list_reference_iterate (&n->symbol.ref_list, 0, ref);\n   gcc_checking_assert (ref->use == IPA_REF_ALIAS);\n   if (ref->refered_type == IPA_REF_VARPOOL)\n     return ipa_ref_varpool_node (ref);\n@@ -1123,9 +1143,9 @@ cgraph_edge_recursive_p (struct cgraph_edge *e)\n {\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n   if (e->caller->global.inlined_to)\n-    return e->caller->global.inlined_to->decl == callee->decl;\n+    return e->caller->global.inlined_to->symbol.decl == callee->symbol.decl;\n   else\n-    return e->caller->decl == callee->decl;\n+    return e->caller->symbol.decl == callee->symbol.decl;\n }\n \n /* Return true if the TM_CLONE bit is set for a given FNDECL.  */"}, {"sha": "689cede526ddc787b45e3c9c402c9d2ffd85300e", "filename": "gcc/cgraphbuild.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraphbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraphbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphbuild.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -146,11 +146,11 @@ record_eh_tables (struct cgraph_node *node, struct function *fun)\n {\n   eh_region i;\n \n-  if (DECL_FUNCTION_PERSONALITY (node->decl))\n+  if (DECL_FUNCTION_PERSONALITY (node->symbol.decl))\n     {\n       struct cgraph_node *per_node;\n \n-      per_node = cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->decl));\n+      per_node = cgraph_get_create_node (DECL_FUNCTION_PERSONALITY (node->symbol.decl));\n       ipa_record_reference (node, NULL, per_node, NULL, IPA_REF_ADDR, NULL);\n       cgraph_mark_address_taken_node (per_node);\n     }\n@@ -427,7 +427,7 @@ rebuild_cgraph_edges (void)\n   gimple_stmt_iterator gsi;\n \n   cgraph_node_remove_callees (node);\n-  ipa_remove_all_references (&node->ref_list);\n+  ipa_remove_all_references (&node->symbol.ref_list);\n \n   node->count = ENTRY_BLOCK_PTR->count;\n \n@@ -475,7 +475,7 @@ cgraph_rebuild_references (void)\n   struct cgraph_node *node = cgraph_get_node (current_function_decl);\n   gimple_stmt_iterator gsi;\n \n-  ipa_remove_all_references (&node->ref_list);\n+  ipa_remove_all_references (&node->symbol.ref_list);\n \n   node->count = ENTRY_BLOCK_PTR->count;\n "}, {"sha": "8c27eb4d32cc6f130901496359ea075efff49a13", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 122, "deletions": 118, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -164,7 +164,7 @@ bool\n cgraph_decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n   /* If the user told us it is used, then it must be so.  */\n-  if (node->local.externally_visible)\n+  if (node->symbol.externally_visible)\n     return true;\n \n   /* ??? If the assembler name is set by hand, it is possible to assemble\n@@ -229,7 +229,7 @@ cgraph_process_new_functions (void)\n   while (cgraph_new_nodes)\n     {\n       node = cgraph_new_nodes;\n-      fndecl = node->decl;\n+      fndecl = node->symbol.decl;\n       cgraph_new_nodes = cgraph_new_nodes->next_needed;\n       switch (cgraph_state)\n \t{\n@@ -497,7 +497,7 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n       error (\"caller edge frequency is too large\");\n       error_found = true;\n     }\n-  if (gimple_has_body_p (e->caller->decl)\n+  if (gimple_has_body_p (e->caller->symbol.decl)\n       && !e->caller->global.inlined_to\n       /* FIXME: Inline-analysis sets frequency to 0 when edge is optimized out.\n \t Remove this once edges are actualy removed from the function at that time.  */\n@@ -507,12 +507,12 @@ verify_edge_count_and_frequency (struct cgraph_edge *e)\n \t\t  <= (unsigned) e->uid)\n \t          || !inline_edge_summary (e)->predicate)))\n       && (e->frequency\n-\t  != compute_call_stmt_bb_frequency (e->caller->decl,\n+\t  != compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt))))\n     {\n       error (\"caller edge frequency %i does not match BB frequency %i\",\n \t     e->frequency,\n-\t     compute_call_stmt_bb_frequency (e->caller->decl,\n+\t     compute_call_stmt_bb_frequency (e->caller->symbol.decl,\n \t\t\t\t\t     gimple_bb (e->call_stmt)));\n       error_found = true;\n     }\n@@ -543,11 +543,11 @@ verify_edge_corresponds_to_fndecl (struct cgraph_edge *e, tree decl)\n \n   /* We do not know if a node from a different partition is an alias or what it\n      aliases and therefore cannot do the former_clone_of check reliably.  */\n-  if (!node || node->in_other_partition)\n+  if (!node || node->symbol.in_other_partition)\n     return false;\n   node = cgraph_function_or_thunk_node (node, NULL);\n \n-  if ((e->callee->former_clone_of != node->decl\n+  if ((e->callee->former_clone_of != node->symbol.decl\n        && (!node->same_body_alias\n \t   || e->callee->former_clone_of != node->thunk.alias))\n       /* IPA-CP sometimes redirect edge to clone and then back to the former\n@@ -568,7 +568,7 @@ DEBUG_FUNCTION void\n verify_cgraph_node (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n-  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *this_cfun = DECL_STRUCT_FUNCTION (node->symbol.decl);\n   basic_block this_block;\n   gimple_stmt_iterator gsi;\n   bool error_found = false;\n@@ -590,12 +590,12 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"execution count is negative\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->local.externally_visible)\n+  if (node->global.inlined_to && node->symbol.externally_visible)\n     {\n       error (\"externally visible inline clone\");\n       error_found = true;\n     }\n-  if (node->global.inlined_to && node->address_taken)\n+  if (node->global.inlined_to && node->symbol.address_taken)\n     {\n       error (\"inline clone with address taken\");\n       error_found = true;\n@@ -663,7 +663,7 @@ verify_cgraph_node (struct cgraph_node *node)\n       error_found = true;\n     }\n \n-  if (!cgraph_get_node (node->decl))\n+  if (!cgraph_get_node (node->symbol.decl))\n     {\n       error (\"node not found in cgraph_hash\");\n       error_found = true;\n@@ -708,31 +708,31 @@ verify_cgraph_node (struct cgraph_node *node)\n       error (\"double linked list of clones corrupted\");\n       error_found = true;\n     }\n-  if (node->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n     {\n-      struct cgraph_node *n = node->same_comdat_group;\n+      symtab_node n = node->symbol.same_comdat_group;\n \n-      if (!DECL_ONE_ONLY (node->decl))\n+      if (!DECL_ONE_ONLY (n->symbol.decl))\n \t{\n \t  error (\"non-DECL_ONE_ONLY node in a same_comdat_group list\");\n \t  error_found = true;\n \t}\n-      if (n == node)\n+      if (n == (symtab_node)node)\n \t{\n \t  error (\"node is alone in a comdat group\");\n \t  error_found = true;\n \t}\n       do\n \t{\n-\t  if (!n->same_comdat_group)\n+\t  if (!n->symbol.same_comdat_group)\n \t    {\n \t      error (\"same_comdat_group is not a circular list\");\n \t      error_found = true;\n \t      break;\n \t    }\n-\t  n = n->same_comdat_group;\n+\t  n = n->symbol.same_comdat_group;\n \t}\n-      while (n != node);\n+      while (n != (symtab_node)node);\n     }\n \n   if (node->analyzed && node->alias)\n@@ -746,7 +746,8 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error (\"Alias has call edges\");\n           error_found = true;\n \t}\n-      for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+      for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t\t  i, ref); i++)\n \tif (ref->use != IPA_REF_ALIAS)\n \t  {\n \t    error (\"Alias has non-alias reference\");\n@@ -777,15 +778,15 @@ verify_cgraph_node (struct cgraph_node *node)\n \t  error (\"More than one edge out of thunk node\");\n           error_found = true;\n \t}\n-      if (gimple_has_body_p (node->decl))\n+      if (gimple_has_body_p (node->symbol.decl))\n         {\n \t  error (\"Thunk is not supposed to have body\");\n           error_found = true;\n         }\n     }\n-  else if (node->analyzed && gimple_has_body_p (node->decl)\n-           && !TREE_ASM_WRITTEN (node->decl)\n-           && (!DECL_EXTERNAL (node->decl) || node->global.inlined_to)\n+  else if (node->analyzed && gimple_has_body_p (node->symbol.decl)\n+           && !TREE_ASM_WRITTEN (node->symbol.decl)\n+           && (!DECL_EXTERNAL (node->symbol.decl) || node->global.inlined_to)\n            && !flag_wpa)\n     {\n       if (this_cfun->cfg)\n@@ -818,7 +819,7 @@ verify_cgraph_node (struct cgraph_node *node)\n \t\t\t    if (verify_edge_corresponds_to_fndecl (e, decl))\n \t\t\t      {\n \t\t\t\terror (\"edge points to wrong declaration:\");\n-\t\t\t\tdebug_tree (e->callee->decl);\n+\t\t\t\tdebug_tree (e->callee->symbol.decl);\n \t\t\t\tfprintf (stderr,\" Instead of:\");\n \t\t\t\tdebug_tree (decl);\n \t\t\t\terror_found = true;\n@@ -913,7 +914,7 @@ void\n cgraph_analyze_function (struct cgraph_node *node)\n {\n   tree save = current_function_decl;\n-  tree decl = node->decl;\n+  tree decl = node->symbol.decl;\n \n   if (node->alias && node->thunk.alias)\n     {\n@@ -924,51 +925,51 @@ cgraph_analyze_function (struct cgraph_node *node)\n \t   n = n->analyzed ? cgraph_alias_aliased_node (n) : NULL)\n \tif (n == node)\n \t  {\n-\t    error (\"function %q+D part of alias cycle\", node->decl);\n+\t    error (\"function %q+D part of alias cycle\", node->symbol.decl);\n \t    node->alias = false;\n \t    return;\n \t  }\n-      if (!VEC_length (ipa_ref_t, node->ref_list.references))\n+      if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n         ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n       if (node->same_body_alias)\n \t{ \n-\t  DECL_VIRTUAL_P (node->decl) = DECL_VIRTUAL_P (node->thunk.alias);\n-\t  DECL_DECLARED_INLINE_P (node->decl)\n+\t  DECL_VIRTUAL_P (node->symbol.decl) = DECL_VIRTUAL_P (node->thunk.alias);\n+\t  DECL_DECLARED_INLINE_P (node->symbol.decl)\n \t     = DECL_DECLARED_INLINE_P (node->thunk.alias);\n-\t  DECL_DISREGARD_INLINE_LIMITS (node->decl)\n+\t  DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl)\n \t     = DECL_DISREGARD_INLINE_LIMITS (node->thunk.alias);\n \t}\n \n       /* Fixup visibility nonsences C++ frontend produce on same body aliases.  */\n-      if (TREE_PUBLIC (node->decl) && node->same_body_alias)\n+      if (TREE_PUBLIC (node->symbol.decl) && node->same_body_alias)\n \t{\n-          DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (node->thunk.alias);\n+          DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->thunk.alias);\n \t  if (DECL_ONE_ONLY (node->thunk.alias))\n \t    {\n-\t      DECL_COMDAT (node->decl) = DECL_COMDAT (node->thunk.alias);\n-\t      DECL_COMDAT_GROUP (node->decl) = DECL_COMDAT_GROUP (node->thunk.alias);\n-\t      if (DECL_ONE_ONLY (node->thunk.alias) && !node->same_comdat_group)\n+\t      DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->thunk.alias);\n+\t      DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->thunk.alias);\n+\t      if (DECL_ONE_ONLY (node->thunk.alias) && !node->symbol.same_comdat_group)\n \t\t{\n \t\t  struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n-\t\t  node->same_comdat_group = tgt;\n-\t\t  if (!tgt->same_comdat_group)\n-\t\t    tgt->same_comdat_group = node;\n+\t\t  node->symbol.same_comdat_group = (symtab_node)tgt;\n+\t\t  if (!tgt->symbol.same_comdat_group)\n+\t\t    tgt->symbol.same_comdat_group = (symtab_node)node;\n \t\t  else\n \t\t    {\n-\t\t      struct cgraph_node *n;\n-\t\t      for (n = tgt->same_comdat_group;\n-\t\t\t   n->same_comdat_group != tgt;\n-\t\t\t   n = n->same_comdat_group)\n+\t\t      symtab_node n;\n+\t\t      for (n = tgt->symbol.same_comdat_group;\n+\t\t\t   n->symbol.same_comdat_group != (symtab_node)tgt;\n+\t\t\t   n = n->symbol.same_comdat_group)\n \t\t\t;\n-\t\t      n->same_comdat_group = node;\n+\t\t      n->symbol.same_comdat_group = (symtab_node)node;\n \t\t    }\n \t\t}\n \t    }\n \t}\n       cgraph_mark_reachable_node (cgraph_alias_aliased_node (node));\n-      if (node->address_taken)\n+      if (node->symbol.address_taken)\n \tcgraph_mark_address_taken_node (cgraph_alias_aliased_node (node));\n-      if (cgraph_decide_is_function_needed (node, node->decl))\n+      if (cgraph_decide_is_function_needed (node, node->symbol.decl))\n \tcgraph_mark_needed_node (node);\n     }\n   else if (node->thunk.thunk_p)\n@@ -981,7 +982,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n       current_function_decl = decl;\n       push_cfun (DECL_STRUCT_FUNCTION (decl));\n \n-      assign_assembler_name_if_neeeded (node->decl);\n+      assign_assembler_name_if_neeeded (node->symbol.decl);\n \n       /* Make sure to gimplify bodies only once.  During analyzing a\n \t function we lower it, which will require gimplified nested\n@@ -995,7 +996,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n       if (!node->lowered)\n \t{\n \t  if (node->nested)\n-\t    lower_nested_functions (node->decl);\n+\t    lower_nested_functions (node->symbol.decl);\n \t  gcc_assert (!node->nested);\n \n \t  gimple_register_cfg_hooks ();\n@@ -1027,7 +1028,7 @@ cgraph_process_same_body_aliases (void)\n   struct cgraph_node *node;\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->same_body_alias\n-\t&& !VEC_length (ipa_ref_t, node->ref_list.references))\n+\t&& !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n       {\n         struct cgraph_node *tgt = cgraph_get_node (node->thunk.alias);\n         ipa_record_reference (node, NULL, tgt, NULL, IPA_REF_ALIAS, NULL);\n@@ -1086,20 +1087,20 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \n   for (node = cgraph_nodes; node != first; node = node->next)\n     {\n-      tree decl = node->decl;\n+      tree decl = node->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n \tcgraph_mark_needed_node (node);\n       if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n \t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl))\n-\t  && TREE_PUBLIC (node->decl))\n+\t  && TREE_PUBLIC (node->symbol.decl))\n \t{\n \t  if (node->local.finalized)\n \t    cgraph_mark_needed_node (node);\n \t}\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n-\t  if (! TREE_PUBLIC (node->decl))\n-\t    warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n+\t  if (! TREE_PUBLIC (node->symbol.decl))\n+\t    warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n \t  else if (node->local.finalized)\n@@ -1108,7 +1109,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n       if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (decl))\n \t  && (node->local.finalized && !node->alias))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (node->decl), OPT_Wattributes,\n+\t  warning_at (DECL_SOURCE_LOCATION (node->symbol.decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n \t\t      \" because function is defined\");\n \t  DECL_WEAK (decl) = 0;\n@@ -1127,7 +1128,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n     }\n   for (vnode = varpool_nodes; vnode != first_var; vnode = vnode->next)\n     {\n-      tree decl = vnode->decl;\n+      tree decl = vnode->symbol.decl;\n       if (DECL_PRESERVE_P (decl))\n \t{\n \t  vnode->force_output = true;\n@@ -1136,15 +1137,15 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t}\n       if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n \t  && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (decl))\n-\t  && TREE_PUBLIC (vnode->decl))\n+\t  && TREE_PUBLIC (vnode->symbol.decl))\n \t{\n \t  if (vnode->finalized)\n \t    varpool_mark_needed_node (vnode);\n \t}\n       else if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (decl)))\n \t{\n-\t  if (! TREE_PUBLIC (vnode->decl))\n-\t    warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n+\t  if (! TREE_PUBLIC (vnode->symbol.decl))\n+\t    warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n \t\t\t\"%<externally_visible%>\"\n \t\t\t\" attribute have effect only on public objects\");\n \t  else if (vnode->finalized)\n@@ -1154,7 +1155,7 @@ process_function_and_variable_attributes (struct cgraph_node *first,\n \t  && vnode->finalized\n \t  && DECL_INITIAL (decl))\n \t{\n-\t  warning_at (DECL_SOURCE_LOCATION (vnode->decl), OPT_Wattributes,\n+\t  warning_at (DECL_SOURCE_LOCATION (vnode->symbol.decl), OPT_Wattributes,\n \t\t      \"%<weakref%> attribute ignored\"\n \t\t      \" because variable is initialized\");\n \t  DECL_WEAK (decl) = 0;\n@@ -1203,10 +1204,10 @@ cgraph_analyze_functions (void)\n   while (cgraph_nodes_queue)\n     {\n       struct cgraph_edge *edge;\n-      tree decl = cgraph_nodes_queue->decl;\n+      tree decl = cgraph_nodes_queue->symbol.decl;\n \n       node = cgraph_nodes_queue;\n-      cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n+      x_cgraph_nodes_queue = (symtab_node)cgraph_nodes_queue->next_needed;\n       node->next_needed = NULL;\n \n       /* ??? It is possible to create extern inline function and later using\n@@ -1231,11 +1232,11 @@ cgraph_analyze_functions (void)\n \tif (!edge->caller->reachable && edge->caller->thunk.thunk_p)\n \t  cgraph_mark_reachable_node (edge->caller);\n \n-      if (node->same_comdat_group)\n+      if (node->symbol.same_comdat_group)\n \t{\n-\t  for (next = node->same_comdat_group;\n+\t  for (next = cgraph (node->symbol.same_comdat_group);\n \t       next != node;\n-\t       next = next->same_comdat_group)\n+\t       next = cgraph (next->symbol.same_comdat_group))\n \t    cgraph_mark_reachable_node (next);\n \t}\n \n@@ -1277,7 +1278,7 @@ cgraph_analyze_functions (void)\n \n   for (node = cgraph_nodes; node != first_analyzed; node = next)\n     {\n-      tree decl = node->decl;\n+      tree decl = node->symbol.decl;\n       next = node->next;\n \n       if (node->local.finalized && !gimple_has_body_p (decl)\n@@ -1339,9 +1340,10 @@ handle_alias_pairs (void)\n \t     However for weakref we insist on EXTERNAL flag being set.\n \t     See gcc.dg/attr-alias-5.c  */\n \t  if (DECL_EXTERNAL (p->decl))\n-\t    DECL_EXTERNAL (p->decl) = lookup_attribute (\"weakref\",\n-\t\t\t\t\t\t\tDECL_ATTRIBUTES (p->decl)) != NULL;\n-\t  cgraph_create_function_alias (p->decl, target_node->decl);\n+\t    DECL_EXTERNAL (p->decl)\n+\t      = lookup_attribute (\"weakref\",\n+\t\t\t\t  DECL_ATTRIBUTES (p->decl)) != NULL;\n+\t  cgraph_create_function_alias (p->decl, target_node->symbol.decl);\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n       else if (TREE_CODE (p->decl) == VAR_DECL\n@@ -1353,9 +1355,10 @@ handle_alias_pairs (void)\n \t     However for weakref we insist on EXTERNAL flag being set.\n \t     See gcc.dg/attr-alias-5.c  */\n \t  if (DECL_EXTERNAL (p->decl))\n-\t    DECL_EXTERNAL (p->decl) = lookup_attribute (\"weakref\",\n-\t\t\t\t\t\t\tDECL_ATTRIBUTES (p->decl)) != NULL;\n-\t  varpool_create_variable_alias (p->decl, target_vnode->decl);\n+\t    DECL_EXTERNAL (p->decl)\n+\t      = lookup_attribute (\"weakref\",\n+\t\t\t          DECL_ATTRIBUTES (p->decl)) != NULL;\n+\t  varpool_create_variable_alias (p->decl, target_vnode->symbol.decl);\n \t  VEC_unordered_remove (alias_pair, alias_pairs, i);\n \t}\n       /* Weakrefs with target not defined in current unit are easy to handle; they\n@@ -1401,10 +1404,10 @@ cgraph_mark_functions_to_output (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      tree decl = node->decl;\n+      tree decl = node->symbol.decl;\n       struct cgraph_edge *e;\n \n-      gcc_assert (!node->process || node->same_comdat_group);\n+      gcc_assert (!node->process || node->symbol.same_comdat_group);\n       if (node->process)\n \tcontinue;\n \n@@ -1420,23 +1423,23 @@ cgraph_mark_functions_to_output (void)\n \t  && !node->alias\n \t  && !node->global.inlined_to\n \t  && (!cgraph_only_called_directly_p (node)\n-\t      || ((e || ipa_ref_has_aliases_p (&node->ref_list))\n+\t      || ((e || ipa_ref_has_aliases_p (&node->symbol.ref_list))\n \t\t  && node->reachable))\n \t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \t{\n \t  node->process = 1;\n-\t  if (node->same_comdat_group)\n+\t  if (node->symbol.same_comdat_group)\n \t    {\n \t      struct cgraph_node *next;\n-\t      for (next = node->same_comdat_group;\n+\t      for (next = cgraph (node->symbol.same_comdat_group);\n \t\t   next != node;\n-\t\t   next = next->same_comdat_group)\n+\t\t   next = cgraph (next->symbol.same_comdat_group))\n \t\tif (!next->thunk.thunk_p && !next->alias)\n \t\t  next->process = 1;\n \t    }\n \t}\n-      else if (node->same_comdat_group)\n+      else if (node->symbol.same_comdat_group)\n \t{\n #ifdef ENABLE_CHECKING\n \t  check_same_comdat_groups = true;\n@@ -1451,7 +1454,7 @@ cgraph_mark_functions_to_output (void)\n \t      /* FIXME: in ltrans unit when offline copy is outside partition but inline copies\n \t\t are inside partition, we can end up not removing the body since we no longer\n \t\t have analyzed node pointing to it.  */\n-\t      && !node->in_other_partition\n+\t      && !node->symbol.in_other_partition\n \t      && !node->alias\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n@@ -1461,7 +1464,7 @@ cgraph_mark_functions_to_output (void)\n #endif\n \t  gcc_assert (node->global.inlined_to\n \t\t      || !gimple_has_body_p (decl)\n-\t\t      || node->in_other_partition\n+\t\t      || node->symbol.in_other_partition\n \t\t      || DECL_EXTERNAL (decl));\n \n \t}\n@@ -1470,16 +1473,16 @@ cgraph_mark_functions_to_output (void)\n #ifdef ENABLE_CHECKING\n   if (check_same_comdat_groups)\n     for (node = cgraph_nodes; node; node = node->next)\n-      if (node->same_comdat_group && !node->process)\n+      if (node->symbol.same_comdat_group && !node->process)\n \t{\n-\t  tree decl = node->decl;\n+\t  tree decl = node->symbol.decl;\n \t  if (!node->global.inlined_to\n \t      && gimple_has_body_p (decl)\n \t      /* FIXME: in an ltrans unit when the offline copy is outside a\n \t\t partition but inline copies are inside a partition, we can\n \t\t end up not removing the body since we no longer have an\n \t\t analyzed node pointing to it.  */\n-\t      && !node->in_other_partition\n+\t      && !node->symbol.in_other_partition\n \t      && !DECL_EXTERNAL (decl))\n \t    {\n \t      dump_cgraph_node (stderr, node);\n@@ -1647,7 +1650,7 @@ assemble_thunk (struct cgraph_node *node)\n   HOST_WIDE_INT virtual_value = node->thunk.virtual_value;\n   tree virtual_offset = NULL;\n   tree alias = node->thunk.alias;\n-  tree thunk_fndecl = node->decl;\n+  tree thunk_fndecl = node->symbol.decl;\n   tree a = DECL_ARGUMENTS (thunk_fndecl);\n \n   current_function_decl = thunk_fndecl;\n@@ -1842,7 +1845,8 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n       }\n     else\n       e = e->next_caller;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n@@ -1851,7 +1855,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n \t/* Force assemble_alias to really output the alias this time instead\n \t   of buffering it in same alias pairs.  */\n \tTREE_ASM_WRITTEN (alias->thunk.alias) = 1;\n-\tassemble_alias (alias->decl,\n+\tassemble_alias (alias->symbol.decl,\n \t\t\tDECL_ASSEMBLER_NAME (alias->thunk.alias));\n \tassemble_thunks_and_aliases (alias);\n \tTREE_ASM_WRITTEN (alias->thunk.alias) = saved_written;\n@@ -1864,7 +1868,7 @@ assemble_thunks_and_aliases (struct cgraph_node *node)\n static void\n tree_rest_of_compilation (struct cgraph_node *node)\n {\n-  tree fndecl = node->decl;\n+  tree fndecl = node->symbol.decl;\n   location_t saved_loc;\n \n   timevar_push (TV_REST_OF_COMPILATION);\n@@ -1951,7 +1955,7 @@ tree_rest_of_compilation (struct cgraph_node *node)\n static void\n cgraph_expand_function (struct cgraph_node *node)\n {\n-  tree decl = node->decl;\n+  tree decl = node->symbol.decl;\n \n   /* We ought to not compile any inline clones.  */\n   gcc_assert (!node->global.inlined_to);\n@@ -2081,7 +2085,7 @@ cgraph_output_in_order (void)\n     {\n       if (pf->process && !pf->thunk.thunk_p && !pf->alias)\n \t{\n-\t  i = pf->order;\n+\t  i = pf->symbol.order;\n \t  gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n \t  nodes[i].kind = ORDER_FUNCTION;\n \t  nodes[i].u.f = pf;\n@@ -2090,7 +2094,7 @@ cgraph_output_in_order (void)\n \n   for (pv = varpool_nodes_queue; pv; pv = pv->next_needed)\n     {\n-      i = pv->order;\n+      i = pv->symbol.order;\n       gcc_assert (nodes[i].kind == ORDER_UNDEFINED);\n       nodes[i].kind = ORDER_VAR;\n       nodes[i].u.v = pv;\n@@ -2243,19 +2247,19 @@ output_weakrefs (void)\n   struct cgraph_node *node;\n   struct varpool_node *vnode;\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->alias && DECL_EXTERNAL (node->decl)\n-        && !TREE_ASM_WRITTEN (node->decl)\n-\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n-      assemble_alias (node->decl,\n+    if (node->alias && DECL_EXTERNAL (node->symbol.decl)\n+        && !TREE_ASM_WRITTEN (node->symbol.decl)\n+\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n+      assemble_alias (node->symbol.decl,\n \t\t      node->thunk.alias ? DECL_ASSEMBLER_NAME (node->thunk.alias)\n-\t\t      : get_alias_symbol (node->decl));\n+\t\t      : get_alias_symbol (node->symbol.decl));\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    if (vnode->alias && DECL_EXTERNAL (vnode->decl)\n-        && !TREE_ASM_WRITTEN (vnode->decl)\n-\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->decl)))\n-      assemble_alias (vnode->decl,\n+    if (vnode->alias && DECL_EXTERNAL (vnode->symbol.decl)\n+        && !TREE_ASM_WRITTEN (vnode->symbol.decl)\n+\t&& lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n+      assemble_alias (vnode->symbol.decl,\n \t\t      vnode->alias_of ? DECL_ASSEMBLER_NAME (vnode->alias_of)\n-\t\t      : get_alias_symbol (vnode->decl));\n+\t\t      : get_alias_symbol (vnode->symbol.decl));\n }\n \n \n@@ -2281,8 +2285,8 @@ update_call_expr (struct cgraph_node *new_version)\n   /* Update the call expr on the edges to call the new version.  */\n   for (e = new_version->callers; e; e = e->next_caller)\n     {\n-      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->decl);\n-      gimple_call_set_fndecl (e->call_stmt, new_version->decl);\n+      struct function *inner_function = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n+      gimple_call_set_fndecl (e->call_stmt, new_version->symbol.decl);\n       maybe_clean_eh_stmt_fn (inner_function, e->call_stmt);\n     }\n }\n@@ -2315,7 +2319,7 @@ cgraph_copy_node_for_versioning (struct cgraph_node *old_version,\n \n    new_version->analyzed = old_version->analyzed;\n    new_version->local = old_version->local;\n-   new_version->local.externally_visible = false;\n+   new_version->symbol.externally_visible = false;\n    new_version->local.local = true;\n    new_version->global = old_version->global;\n    new_version->rtl = old_version->rtl;\n@@ -2378,7 +2382,7 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n \t\t\t    basic_block new_entry_block,\n \t\t\t    const char *clone_name)\n {\n-  tree old_decl = old_version_node->decl;\n+  tree old_decl = old_version_node->symbol.decl;\n   struct cgraph_node *new_version_node = NULL;\n   tree new_decl;\n \n@@ -2418,9 +2422,9 @@ cgraph_function_versioning (struct cgraph_node *old_version_node,\n      that is not weak also.\n      ??? We cannot use COMDAT linkage because there is no\n      ABI support for this.  */\n-  cgraph_make_decl_local (new_version_node->decl);\n-  DECL_VIRTUAL_P (new_version_node->decl) = 0;\n-  new_version_node->local.externally_visible = 0;\n+  cgraph_make_decl_local (new_version_node->symbol.decl);\n+  DECL_VIRTUAL_P (new_version_node->symbol.decl) = 0;\n+  new_version_node->symbol.externally_visible = 0;\n   new_version_node->local.local = 1;\n   new_version_node->lowered = true;\n \n@@ -2436,18 +2440,18 @@ static void\n cgraph_materialize_clone (struct cgraph_node *node)\n {\n   bitmap_obstack_initialize (NULL);\n-  node->former_clone_of = node->clone_of->decl;\n+  node->former_clone_of = node->clone_of->symbol.decl;\n   if (node->clone_of->former_clone_of)\n     node->former_clone_of = node->clone_of->former_clone_of;\n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->clone_of->decl, node->decl,\n+  tree_function_versioning (node->clone_of->symbol.decl, node->symbol.decl,\n   \t\t\t    node->clone.tree_map, true,\n \t\t\t    node->clone.args_to_skip, false,\n \t\t\t    NULL, NULL);\n   if (cgraph_dump_file)\n     {\n-      dump_function_to_file (node->clone_of->decl, cgraph_dump_file, dump_flags);\n-      dump_function_to_file (node->decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->clone_of->symbol.decl, cgraph_dump_file, dump_flags);\n+      dump_function_to_file (node->symbol.decl, cgraph_dump_file, dump_flags);\n     }\n \n   /* Function is no longer clone.  */\n@@ -2463,7 +2467,7 @@ cgraph_materialize_clone (struct cgraph_node *node)\n     {\n       cgraph_release_function_body (node->clone_of);\n       cgraph_node_remove_callees (node->clone_of);\n-      ipa_remove_all_references (&node->clone_of->ref_list);\n+      ipa_remove_all_references (&node->clone_of->symbol.ref_list);\n     }\n   node->clone_of = NULL;\n   bitmap_obstack_release (NULL);\n@@ -2483,7 +2487,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n #endif\n \n   if (e->indirect_unknown_callee\n-      || decl == e->callee->decl)\n+      || decl == e->callee->symbol.decl)\n     return e->call_stmt;\n \n #ifdef ENABLE_CHECKING\n@@ -2515,7 +2519,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n       new_stmt\n \t= gimple_call_copy_skip_args (e->call_stmt,\n \t\t\t\t      e->callee->clone.combined_args_to_skip);\n-      gimple_call_set_fndecl (new_stmt, e->callee->decl);\n+      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n \n       if (gimple_vdef (new_stmt)\n \t  && TREE_CODE (gimple_vdef (new_stmt)) == SSA_NAME)\n@@ -2537,7 +2541,7 @@ cgraph_redirect_edge_call_stmt_to_callee (struct cgraph_edge *e)\n   else\n     {\n       new_stmt = e->call_stmt;\n-      gimple_call_set_fndecl (new_stmt, e->callee->decl);\n+      gimple_call_set_fndecl (new_stmt, e->callee->symbol.decl);\n       update_stmt (new_stmt);\n     }\n \n@@ -2576,10 +2580,10 @@ cgraph_materialize_all_clones (void)\n       stabilized = true;\n       for (node = cgraph_nodes; node; node = node->next)\n         {\n-\t  if (node->clone_of && node->decl != node->clone_of->decl\n-\t      && !gimple_has_body_p (node->decl))\n+\t  if (node->clone_of && node->symbol.decl != node->clone_of->symbol.decl\n+\t      && !gimple_has_body_p (node->symbol.decl))\n \t    {\n-\t      if (gimple_has_body_p (node->clone_of->decl))\n+\t      if (gimple_has_body_p (node->clone_of->symbol.decl))\n \t        {\n \t\t  if (cgraph_dump_file)\n \t\t    {\n@@ -2744,7 +2748,7 @@ cgraph_optimize (void)\n       for (node = cgraph_nodes; node; node = node->next)\n \tif (node->analyzed\n \t    && (node->global.inlined_to\n-\t\t|| gimple_has_body_p (node->decl)))\n+\t\t|| gimple_has_body_p (node->symbol.decl)))\n \t  {\n \t    error_found = true;\n \t    dump_cgraph_node (stderr, node);"}, {"sha": "a00d7815b61f9ba2bf34bb89af8a822ece26611b", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1,3 +1,8 @@\n+2012-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* tree.c: Update field referenced for new cgraph/varpool layout.\n+\t* decl2.c: Likewise.\n+\n 2012-04-13  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/52824"}, {"sha": "e7fb0f5235aab67e26e2da405679146a506970f4", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1898,15 +1898,15 @@ maybe_emit_vtables (tree ctype)\n \t{\n \t  current = varpool_node (vtbl);\n \t  if (last)\n-\t    last->same_comdat_group = current;\n+\t    last->symbol.same_comdat_group = (symtab_node) current;\n \t  last = current;\n \t  if (!first)\n \t    first = current;\n \t}\n     }\n \n   if (first != last)\n-    last->same_comdat_group = first;\n+    last->symbol.same_comdat_group = (symtab_node)first;\n \n   /* Since we're writing out the vtable here, also write the debug\n      info.  */\n@@ -3491,7 +3491,7 @@ collect_candidates_for_java_method_aliases (void)\n \n   for (node = cgraph_nodes; node ; node = node->next)\n     {\n-      tree fndecl = node->decl;\n+      tree fndecl = node->symbol.decl;\n \n       if (DECL_CONTEXT (fndecl)\n \t  && TYPE_P (DECL_CONTEXT (fndecl))\n@@ -3525,7 +3525,7 @@ build_java_method_aliases (struct pointer_set_t *candidates)\n \n   for (node = cgraph_nodes; node ; node = node->next)\n     {\n-      tree fndecl = node->decl;\n+      tree fndecl = node->symbol.decl;\n \n       if (TREE_ASM_WRITTEN (fndecl)\n \t  && pointer_set_contains (candidates, fndecl))\n@@ -3706,7 +3706,7 @@ collect_all_refs (const char *source_file)\n static bool\n clear_decl_external (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED)\n {\n-  DECL_EXTERNAL (node->decl) = 0;\n+  DECL_EXTERNAL (node->symbol.decl) = 0;\n   return false;\n }\n \n@@ -3945,10 +3945,10 @@ cp_write_global_declarations (void)\n \t      /* If we mark !DECL_EXTERNAL one of the symbols in some comdat\n \t\t group, we need to mark all symbols in the same comdat group\n \t\t that way.  */\n-\t      if (node->same_comdat_group)\n-\t\tfor (next = node->same_comdat_group;\n+\t      if (node->symbol.same_comdat_group)\n+\t\tfor (next = cgraph (node->symbol.same_comdat_group);\n \t\t     next != node;\n-\t\t     next = next->same_comdat_group)\n+\t\t     next = cgraph (next->symbol.same_comdat_group))\n \t          cgraph_for_node_and_aliases (next, clear_decl_external,\n \t\t\t\t\t       NULL, true);\n \t    }"}, {"sha": "96a403fce6b618581eabec986b857c05383e8a88", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -3508,7 +3508,7 @@ cp_fix_function_decl_p (tree decl)\n       /* Don't fix same_body aliases.  Although they don't have their own\n \t CFG, they share it with what they alias to.  */\n       if (!node || !node->alias\n-\t  || !VEC_length (ipa_ref_t, node->ref_list.references))\n+\t  || !VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n \treturn true;\n     }\n "}, {"sha": "8e353fe3737247f9b4d92dfa2ede714ab1ed2b49", "filename": "gcc/gimplify.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1003,7 +1003,7 @@ unshare_body (tree fndecl)\n \n   if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unshare_body (cgn->decl);\n+      unshare_body (cgn->symbol.decl);\n }\n \n /* Callback for walk_tree to unmark the visited trees rooted at *TP.\n@@ -1046,7 +1046,7 @@ unvisit_body (tree fndecl)\n \n   if (cgn)\n     for (cgn = cgn->nested; cgn; cgn = cgn->next_nested)\n-      unvisit_body (cgn->decl);\n+      unvisit_body (cgn->symbol.decl);\n }\n \n /* Unconditionally make an unshared copy of EXPR.  This is used when using"}, {"sha": "cd9afb8637061b27ec92aaa8214be29889983757", "filename": "gcc/ipa-cp.c", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-cp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-cp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-cp.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -247,11 +247,11 @@ ipa_lat_is_single_const (struct ipcp_lattice *lat)\n static inline bool\n edge_within_scc (struct cgraph_edge *cs)\n {\n-  struct ipa_dfs_info *caller_dfs = (struct ipa_dfs_info *) cs->caller->aux;\n+  struct ipa_dfs_info *caller_dfs = (struct ipa_dfs_info *) cs->caller->symbol.aux;\n   struct ipa_dfs_info *callee_dfs;\n   struct cgraph_node *callee = cgraph_function_node (cs->callee, NULL);\n \n-  callee_dfs = (struct ipa_dfs_info *) callee->aux;\n+  callee_dfs = (struct ipa_dfs_info *) callee->symbol.aux;\n   return (caller_dfs\n \t  && callee_dfs\n \t  && caller_dfs->scc_no == callee_dfs->scc_no);\n@@ -450,7 +450,7 @@ ipcp_cloning_candidate_p (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (!optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n+  if (!optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->symbol.decl)))\n     {\n       if (dump_file)\n         fprintf (dump_file, \"Not considering %s for cloning; \"\n@@ -1192,7 +1192,7 @@ devirtualization_time_bonus (struct cgraph_node *node,\n       else if (isummary->size <= MAX_INLINE_INSNS_AUTO / 2)\n \tres += 15;\n       else if (isummary->size <= MAX_INLINE_INSNS_AUTO\n-\t       || DECL_DECLARED_INLINE_P (callee->decl))\n+\t       || DECL_DECLARED_INLINE_P (callee->symbol.decl))\n \tres += 7;\n     }\n \n@@ -1209,7 +1209,7 @@ good_cloning_opportunity_p (struct cgraph_node *node, int time_benefit,\n {\n   if (time_benefit == 0\n       || !flag_ipa_cp_clone\n-      || !optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->decl)))\n+      || !optimize_function_for_speed_p (DECL_STRUCT_FUNCTION (node->symbol.decl)))\n     return false;\n \n   gcc_assert (size_cost > 0);\n@@ -1532,14 +1532,14 @@ propagate_constants_topo (struct topo_info *topo)\n       if (!cgraph_function_with_gimple_body_p (node))\n \tcontinue;\n \n-      node_dfs_info = (struct ipa_dfs_info *) node->aux;\n+      node_dfs_info = (struct ipa_dfs_info *) node->symbol.aux;\n       /* First, iteratively propagate within the strongly connected component\n \t until all lattices stabilize.  */\n       v = node_dfs_info->next_cycle;\n       while (v)\n \t{\n \t  push_node_to_stack (topo, v);\n-\t  v = ((struct ipa_dfs_info *) v->aux)->next_cycle;\n+\t  v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle;\n \t}\n \n       v = node;\n@@ -1568,7 +1568,7 @@ propagate_constants_topo (struct topo_info *topo)\n \t    if (!edge_within_scc (cs))\n \t      propagate_constants_accross_call (cs);\n \n-\t  v = ((struct ipa_dfs_info *) v->aux)->next_cycle;\n+\t  v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle;\n \t}\n     }\n }\n@@ -2384,20 +2384,20 @@ static void\n identify_dead_nodes (struct cgraph_node *node)\n {\n   struct cgraph_node *v;\n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n     if (cgraph_will_be_removed_from_program_if_no_direct_calls (v)\n \t&& !cgraph_for_node_and_aliases (v,\n \t\t\t\t\t has_undead_caller_from_outside_scc_p,\n \t\t\t\t\t NULL, true))\n       IPA_NODE_REF (v)->node_dead = 1;\n \n-  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n     if (!IPA_NODE_REF (v)->node_dead)\n       spread_undeadness (v);\n \n   if (dump_file && (dump_flags & TDF_DETAILS))\n     {\n-      for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+      for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n \tif (IPA_NODE_REF (v)->node_dead)\n \t  fprintf (dump_file, \"  Marking node as dead: %s/%i.\\n\",\n \t\t   cgraph_node_name (v), v->uid);\n@@ -2424,7 +2424,7 @@ ipcp_decision_stage (struct topo_info *topo)\n \t{\n \t  struct cgraph_node *v;\n \t  iterate = false;\n-\t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->aux)->next_cycle)\n+\t  for (v = node; v ; v = ((struct ipa_dfs_info *) v->symbol.aux)->next_cycle)\n \t    if (cgraph_function_with_gimple_body_p (v)\n \t\t&& ipcp_versionable_function_p (v))\n \t      iterate |= decide_whether_version_node (v);\n@@ -2496,7 +2496,8 @@ ipcp_generate_summary (void)\n       {\n \t/* Unreachable nodes should have been eliminated before ipcp.  */\n \tgcc_assert (node->needed || node->reachable);\n-\tnode->local.versionable = tree_versionable_function_p (node->decl);\n+\tnode->local.versionable\n+\t  = tree_versionable_function_p (node->symbol.decl);\n \tipa_analyze_node (node);\n       }\n }"}, {"sha": "40bbf340f761847a39fbb00e95bc6f31b6a5466d", "filename": "gcc/ipa-inline-analysis.c", "status": "modified", "additions": 13, "deletions": 13, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline-analysis.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline-analysis.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-analysis.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1186,7 +1186,7 @@ dump_inline_summary (FILE * f, struct cgraph_node *node)\n       int i;\n       fprintf (f, \"Inline summary for %s/%i\", cgraph_node_name (node),\n \t       node->uid);\n-      if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n+      if (DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n \tfprintf (f, \" always_inline\");\n       if (s->inlinable)\n \tfprintf (f, \" inlinable\");\n@@ -1583,7 +1583,7 @@ compute_bb_predicates (struct cgraph_node *node,\n \t\t       struct ipa_node_params *parms_info,\n \t\t       struct inline_summary *summary)\n {\n-  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->symbol.decl);\n   bool done = false;\n   basic_block bb;\n \n@@ -1871,7 +1871,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n      <0,2>.  */\n   basic_block bb;\n   gimple_stmt_iterator bsi;\n-  struct function *my_function = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *my_function = DECL_STRUCT_FUNCTION (node->symbol.decl);\n   int freq;\n   struct inline_summary *info = inline_summary (node);\n   struct predicate bb_predicate;\n@@ -1906,7 +1906,7 @@ estimate_function_body_sizes (struct cgraph_node *node, bool early)\n     compute_bb_predicates (node, parms_info, info);\n   FOR_EACH_BB_FN (bb, my_function)\n     {\n-      freq = compute_call_stmt_bb_frequency (node->decl, bb);\n+      freq = compute_call_stmt_bb_frequency (node->symbol.decl, bb);\n \n       /* TODO: Obviously predicates can be propagated down across CFG.  */\n       if (parms_info)\n@@ -2096,8 +2096,8 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n     }\n \n   /* Even is_gimple_min_invariant rely on current_function_decl.  */\n-  current_function_decl = node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->symbol.decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \n   /* Estimate the stack size for the function if we're optimizing.  */\n   self_stack_size = optimize ? estimated_stack_frame_size (node) : 0;\n@@ -2106,10 +2106,10 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n   info->stack_frame_offset = 0;\n \n   /* Can this function be inlined at all?  */\n-  info->inlinable = tree_inlinable_function_p (node->decl);\n+  info->inlinable = tree_inlinable_function_p (node->symbol.decl);\n \n   /* Type attributes can use parameter indices to describe them.  */\n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n+  if (TYPE_ATTRIBUTES (TREE_TYPE (node->symbol.decl)))\n     node->local.can_change_signature = false;\n   else\n     {\n@@ -2121,7 +2121,7 @@ compute_inline_parameters (struct cgraph_node *node, bool early)\n \t  /* Functions calling builtin_apply can not change signature.  */\n \t  for (e = node->callees; e; e = e->next_callee)\n \t    {\n-\t      tree cdecl = e->callee->decl;\n+\t      tree cdecl = e->callee->symbol.decl;\n \t      if (DECL_BUILT_IN (cdecl)\n \t\t  && DECL_BUILT_IN_CLASS (cdecl) == BUILT_IN_NORMAL\n \t\t  && (DECL_FUNCTION_CODE (cdecl) == BUILT_IN_APPLY_ARGS\n@@ -2879,13 +2879,13 @@ do_estimate_growth (struct cgraph_node *node)\n     d.growth = d.growth < info->size ? info->size : d.growth;\n   else\n     {\n-      if (!DECL_EXTERNAL (node->decl)\n+      if (!DECL_EXTERNAL (node->symbol.decl)\n \t  && cgraph_will_be_removed_from_program_if_no_direct_calls (node))\n \td.growth -= info->size;\n       /* COMDAT functions are very often not shared across multiple units\n \t since they come from various template instantiations.\n \t Take this into account.  */\n-      else  if (DECL_COMDAT (node->decl)\n+      else  if (DECL_COMDAT (node->symbol.decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (node))\n \td.growth -= (info->size\n \t\t     * (100 - PARAM_VALUE (PARAM_COMDAT_SHARING_PROBABILITY))\n@@ -2923,8 +2923,8 @@ inline_indirect_intraprocedural_analysis (struct cgraph_node *node)\n static void\n inline_analyze_function (struct cgraph_node *node)\n {\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  current_function_decl = node->decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  current_function_decl = node->symbol.decl;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nAnalyzing function: %s/%u\\n\","}, {"sha": "d875c78fa051259f4ad93ced415aa353d1f0fe8b", "filename": "gcc/ipa-inline-transform.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline-transform.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline-transform.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline-transform.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -88,16 +88,16 @@ can_remove_node_now_p_1 (struct cgraph_node *node)\n   /* FIXME: When address is taken of DECL_EXTERNAL function we still\n      can remove its offline copy, but we would need to keep unanalyzed node in\n      the callgraph so references can point to it.  */\n-  return (!node->address_taken\n-\t  && !ipa_ref_has_aliases_p (&node->ref_list)\n+  return (!node->symbol.address_taken\n+\t  && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n \t  && cgraph_can_remove_if_no_direct_calls_p (node)\n \t  /* Inlining might enable more devirtualizing, so we want to remove\n \t     those only after all devirtualizable virtual calls are processed.\n \t     Lacking may edges in callgraph we just preserve them post\n \t     inlining.  */\n-\t  && (!DECL_VIRTUAL_P (node->decl)\n-\t      || (!DECL_COMDAT (node->decl)\n-\t\t  && !DECL_EXTERNAL (node->decl)))\n+\t  && (!DECL_VIRTUAL_P (node->symbol.decl)\n+\t      || (!DECL_COMDAT (node->symbol.decl)\n+\t\t  && !DECL_EXTERNAL (node->symbol.decl)))\n \t  /* During early inlining some unanalyzed cgraph nodes might be in the\n \t     callgraph and they might reffer the function in question.  */\n \t  && !cgraph_new_nodes);\n@@ -116,10 +116,10 @@ can_remove_node_now_p (struct cgraph_node *node, struct cgraph_edge *e)\n \n   /* When we see same comdat group, we need to be sure that all\n      items can be removed.  */\n-  if (!node->same_comdat_group)\n+  if (!node->symbol.same_comdat_group)\n     return true;\n-  for (next = node->same_comdat_group;\n-       next != node; next = next->same_comdat_group)\n+  for (next = cgraph (node->symbol.same_comdat_group);\n+       next != node; next = cgraph (next->symbol.same_comdat_group))\n     if ((next->callers && next->callers != e)\n \t|| !can_remove_node_now_p_1 (next))\n       return false;\n@@ -157,20 +157,20 @@ clone_inlined_nodes (struct cgraph_edge *e, bool duplicate,\n \t     For now we keep the ohter functions in the group in program until\n \t     cgraph_remove_unreachable_functions gets rid of them.  */\n \t  gcc_assert (!e->callee->global.inlined_to);\n-\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->decl))\n+\t  if (e->callee->analyzed && !DECL_EXTERNAL (e->callee->symbol.decl))\n \t    {\n \t      if (overall_size)\n \t        *overall_size -= inline_summary (e->callee)->size;\n \t      nfunctions_inlined++;\n \t    }\n \t  duplicate = false;\n-\t  e->callee->local.externally_visible = false;\n+\t  e->callee->symbol.externally_visible = false;\n           update_noncloned_frequencies (e->callee, e->frequency);\n \t}\n       else\n \t{\n \t  struct cgraph_node *n;\n-\t  n = cgraph_clone_node (e->callee, e->callee->decl,\n+\t  n = cgraph_clone_node (e->callee, e->callee->symbol.decl,\n \t\t\t\t e->count, e->frequency,\n \t\t\t\t update_original, NULL, true);\n \t  cgraph_redirect_edge_callee (e, n);\n@@ -211,7 +211,7 @@ inline_call (struct cgraph_edge *e, bool update_original,\n   gcc_assert (!callee->global.inlined_to);\n \n   e->inline_failed = CIF_OK;\n-  DECL_POSSIBLY_INLINED (callee->decl) = true;\n+  DECL_POSSIBLY_INLINED (callee->symbol.decl) = true;\n \n   to = e->caller;\n   if (to->global.inlined_to)\n@@ -273,13 +273,13 @@ save_inline_function_body (struct cgraph_node *node)\n     fprintf (dump_file, \"\\nSaving body of %s for later reuse\\n\",\n \t     cgraph_node_name (node));\n  \n-  gcc_assert (node == cgraph_get_node (node->decl));\n+  gcc_assert (node == cgraph_get_node (node->symbol.decl));\n \n   /* first_clone will be turned into real function.  */\n   first_clone = node->clones;\n-  first_clone->decl = copy_node (node->decl);\n+  first_clone->symbol.decl = copy_node (node->symbol.decl);\n   cgraph_insert_node_to_hashtable (first_clone);\n-  gcc_assert (first_clone == cgraph_get_node (first_clone->decl));\n+  gcc_assert (first_clone == cgraph_get_node (first_clone->symbol.decl));\n \n   /* Now reshape the clone tree, so all other clones descends from\n      first_clone.  */\n@@ -307,8 +307,8 @@ save_inline_function_body (struct cgraph_node *node)\n   if (first_clone->clones)\n     for (n = first_clone->clones; n != first_clone;)\n       {\n-        gcc_assert (n->decl == node->decl);\n-\tn->decl = first_clone->decl;\n+        gcc_assert (n->symbol.decl == node->symbol.decl);\n+\tn->symbol.decl = first_clone->symbol.decl;\n \tif (n->clones)\n \t  n = n->clones;\n \telse if (n->next_sibling_clone)\n@@ -323,15 +323,15 @@ save_inline_function_body (struct cgraph_node *node)\n       }\n \n   /* Copy the OLD_VERSION_NODE function tree to the new version.  */\n-  tree_function_versioning (node->decl, first_clone->decl, NULL, true, NULL,\n-\t\t\t    false, NULL, NULL);\n+  tree_function_versioning (node->symbol.decl, first_clone->symbol.decl,\n+\t\t\t    NULL, true, NULL, false, NULL, NULL);\n \n   /* The function will be short lived and removed after we inline all the clones,\n      but make it internal so we won't confuse ourself.  */\n-  DECL_EXTERNAL (first_clone->decl) = 0;\n-  DECL_COMDAT_GROUP (first_clone->decl) = NULL_TREE;\n-  TREE_PUBLIC (first_clone->decl) = 0;\n-  DECL_COMDAT (first_clone->decl) = 0;\n+  DECL_EXTERNAL (first_clone->symbol.decl) = 0;\n+  DECL_COMDAT_GROUP (first_clone->symbol.decl) = NULL_TREE;\n+  TREE_PUBLIC (first_clone->symbol.decl) = 0;\n+  DECL_COMDAT (first_clone->symbol.decl) = 0;\n   VEC_free (ipa_opt_pass, heap,\n             first_clone->ipa_transforms_to_apply);\n   first_clone->ipa_transforms_to_apply = NULL;"}, {"sha": "ad728487ba1cb49043a148e22842a449f47f1437", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 61, "deletions": 59, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -240,18 +240,18 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n   enum availability avail;\n   struct cgraph_node *callee\n     = cgraph_function_or_thunk_node (e->callee, &avail);\n-  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->decl);\n+  tree caller_tree = DECL_FUNCTION_SPECIFIC_OPTIMIZATION (e->caller->symbol.decl);\n   tree callee_tree\n-    = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->decl) : NULL;\n-  struct function *caller_cfun = DECL_STRUCT_FUNCTION (e->caller->decl);\n+    = callee ? DECL_FUNCTION_SPECIFIC_OPTIMIZATION (callee->symbol.decl) : NULL;\n+  struct function *caller_cfun = DECL_STRUCT_FUNCTION (e->caller->symbol.decl);\n   struct function *callee_cfun\n-    = callee ? DECL_STRUCT_FUNCTION (callee->decl) : NULL;\n+    = callee ? DECL_STRUCT_FUNCTION (callee->symbol.decl) : NULL;\n \n   if (!caller_cfun && e->caller->clone_of)\n-    caller_cfun = DECL_STRUCT_FUNCTION (e->caller->clone_of->decl);\n+    caller_cfun = DECL_STRUCT_FUNCTION (e->caller->clone_of->symbol.decl);\n \n   if (!callee_cfun && callee && callee->clone_of)\n-    callee_cfun = DECL_STRUCT_FUNCTION (callee->clone_of->decl);\n+    callee_cfun = DECL_STRUCT_FUNCTION (callee->clone_of->symbol.decl);\n \n   gcc_assert (e->inline_failed);\n \n@@ -276,18 +276,18 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n       inlinable = false;\n     }\n   /* Don't inline if the functions have different EH personalities.  */\n-  else if (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n-\t   && DECL_FUNCTION_PERSONALITY (callee->decl)\n-\t   && (DECL_FUNCTION_PERSONALITY (e->caller->decl)\n-\t       != DECL_FUNCTION_PERSONALITY (callee->decl)))\n+  else if (DECL_FUNCTION_PERSONALITY (e->caller->symbol.decl)\n+\t   && DECL_FUNCTION_PERSONALITY (callee->symbol.decl)\n+\t   && (DECL_FUNCTION_PERSONALITY (e->caller->symbol.decl)\n+\t       != DECL_FUNCTION_PERSONALITY (callee->symbol.decl)))\n     {\n       e->inline_failed = CIF_EH_PERSONALITY;\n       inlinable = false;\n     }\n   /* TM pure functions should not be inlined into non-TM_pure\n      functions.  */\n-  else if (is_tm_pure (callee->decl)\n-\t   && !is_tm_pure (e->caller->decl))\n+  else if (is_tm_pure (callee->symbol.decl)\n+\t   && !is_tm_pure (e->caller->symbol.decl))\n     {\n       e->inline_failed = CIF_UNSPECIFIED;\n       inlinable = false;\n@@ -303,19 +303,19 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n       inlinable = false;\n     }\n   /* Check compatibility of target optimization options.  */\n-  else if (!targetm.target_option.can_inline_p (e->caller->decl,\n-\t\t\t\t\t\tcallee->decl))\n+  else if (!targetm.target_option.can_inline_p (e->caller->symbol.decl,\n+\t\t\t\t\t\tcallee->symbol.decl))\n     {\n       e->inline_failed = CIF_TARGET_OPTION_MISMATCH;\n       inlinable = false;\n     }\n   /* Check if caller growth allows the inlining.  */\n-  else if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl)\n+  else if (!DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl)\n \t   && !lookup_attribute (\"flatten\",\n \t\t\t\t DECL_ATTRIBUTES\n \t\t\t\t   (e->caller->global.inlined_to\n-\t\t\t\t    ? e->caller->global.inlined_to->decl\n-\t\t\t\t    : e->caller->decl))\n+\t\t\t\t    ? e->caller->global.inlined_to->symbol.decl\n+\t\t\t\t    : e->caller->symbol.decl))\n            && !caller_growth_limits (e))\n     inlinable = false;\n   /* Don't inline a function with a higher optimization level than the\n@@ -336,7 +336,7 @@ can_inline_edge_p (struct cgraph_edge *e, bool report)\n       if (((caller_opt->x_optimize > callee_opt->x_optimize)\n \t   || (caller_opt->x_optimize_size != callee_opt->x_optimize_size))\n \t  /* gcc.dg/pr43564.c.  Look at forced inline even in -O0.  */\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (e->callee->symbol.decl))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n@@ -359,7 +359,7 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n   /* Early inliner might get called at WPA stage when IPA pass adds new\n      function.  In this case we can not really do any of early inlining\n      because function bodies are missing.  */\n-  if (!gimple_has_body_p (callee->decl))\n+  if (!gimple_has_body_p (callee->symbol.decl))\n     {\n       e->inline_failed = CIF_BODY_NOT_AVAILABLE;\n       return false;\n@@ -368,8 +368,8 @@ can_early_inline_edge_p (struct cgraph_edge *e)\n      (i.e. the callgraph is cyclic and we did not process\n      the callee by early inliner, yet).  We don't have CIF code for this\n      case; later we will re-do the decision in the real inliner.  */\n-  if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->decl))\n-      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n+  if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->symbol.decl))\n+      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->symbol.decl)))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"  edge not inlinable: not in SSA form\\n\");\n@@ -389,7 +389,7 @@ leaf_node_p (struct cgraph_node *n)\n {\n   struct cgraph_edge *e;\n   for (e = n->callees; e; e = e->next_callee)\n-    if (!is_inexpensive_builtin (e->callee->decl))\n+    if (!is_inexpensive_builtin (e->callee->symbol.decl))\n       return false;\n   return true;\n }\n@@ -403,9 +403,9 @@ want_early_inline_function_p (struct cgraph_edge *e)\n   bool want_inline = true;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -462,9 +462,9 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n   bool want_inline = true;\n   struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n     ;\n-  else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+  else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t   && !flag_inline_small_functions)\n     {\n       e->inline_failed = CIF_FUNCTION_NOT_INLINE_CANDIDATE;\n@@ -476,7 +476,7 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \n       if (growth <= 0)\n \t;\n-      else if (DECL_DECLARED_INLINE_P (callee->decl)\n+      else if (DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && growth >= MAX_INLINE_INSNS_SINGLE)\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_SINGLE_LIMIT;\n@@ -514,17 +514,17 @@ want_inline_small_function_p (struct cgraph_edge *e, bool report)\n \t\t  Consequently we ask cgraph_can_remove_if_no_direct_calls_p\n \t\t  instead of\n \t\t  cgraph_will_be_removed_from_program_if_no_direct_calls  */\n-\t        && !DECL_EXTERNAL (callee->decl)\n+\t        && !DECL_EXTERNAL (callee->symbol.decl)\n \t\t&& cgraph_can_remove_if_no_direct_calls_p (callee)\n \t\t&& estimate_growth (callee) <= 0)\n \t;\n-      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && !flag_inline_functions)\n \t{\n           e->inline_failed = CIF_NOT_DECLARED_INLINED;\n \t  want_inline = false;\n \t}\n-      else if (!DECL_DECLARED_INLINE_P (callee->decl)\n+      else if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t       && growth >= MAX_INLINE_INSNS_AUTO)\n \t{\n           e->inline_failed = CIF_MAX_INLINE_INSNS_AUTO_LIMIT;\n@@ -564,7 +564,7 @@ want_inline_self_recursive_call_p (struct cgraph_edge *edge,\n   int caller_freq = CGRAPH_FREQ_BASE;\n   int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n \n-  if (DECL_DECLARED_INLINE_P (edge->caller->decl))\n+  if (DECL_DECLARED_INLINE_P (edge->caller->symbol.decl))\n     max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n \n   if (!cgraph_maybe_hot_edge_p (edge))\n@@ -690,7 +690,7 @@ want_inline_function_called_once_p (struct cgraph_node *node)\n      return false;\n    /* External functions are not really in the unit, so inlining\n       them when called once would just increase the program size.  */\n-   if (DECL_EXTERNAL (function->decl))\n+   if (DECL_EXTERNAL (function->symbol.decl))\n      return false;\n    /* Offline body must be optimized out.  */\n    if (!cgraph_will_be_removed_from_program_if_no_direct_calls (function))\n@@ -745,7 +745,7 @@ edge_badness (struct cgraph_edge *edge, bool dump)\n \t\t\t\t\t\t\t      NULL);\n   struct inline_summary *callee_info = inline_summary (callee);\n \n-  if (DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n     return INT_MIN;\n \n   growth = estimate_edge_growth (edge);\n@@ -957,7 +957,8 @@ reset_edge_caches (struct cgraph_node *node)\n   for (edge = where->callers; edge; edge = edge->next_caller)\n     if (edge->inline_failed)\n       reset_edge_growth_cache (edge);\n-  for (i = 0; ipa_ref_list_refering_iterate (&where->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&where->symbol.ref_list,\n+\t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       reset_edge_caches (ipa_ref_refering_node (ref));\n \n@@ -1008,7 +1009,8 @@ update_caller_keys (fibheap_t heap, struct cgraph_node *node,\n   if (!bitmap_set_bit (updated_nodes, node->uid))\n     return;\n \n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t      i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct cgraph_node *alias = ipa_ref_refering_node (ref);\n@@ -1178,7 +1180,7 @@ recursive_inlining (struct cgraph_edge *edge,\n   if (node->global.inlined_to)\n     node = node->global.inlined_to;\n \n-  if (DECL_DECLARED_INLINE_P (node->decl))\n+  if (DECL_DECLARED_INLINE_P (node->symbol.decl))\n     limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE);\n \n   /* Make sure that function is small enough to be considered for inlining.  */\n@@ -1213,8 +1215,8 @@ recursive_inlining (struct cgraph_edge *edge,\n       depth = 1;\n       for (cnode = curr->caller;\n \t   cnode->global.inlined_to; cnode = cnode->callers->caller)\n-\tif (node->decl\n-\t    == cgraph_function_or_thunk_node (curr->callee, NULL)->decl)\n+\tif (node->symbol.decl\n+\t    == cgraph_function_or_thunk_node (curr->callee, NULL)->symbol.decl)\n           depth++;\n \n       if (!want_inline_self_recursive_call_p (curr, node, false, depth))\n@@ -1234,7 +1236,7 @@ recursive_inlining (struct cgraph_edge *edge,\n       if (!master_clone)\n \t{\n \t  /* We need original clone to copy around.  */\n-\t  master_clone = cgraph_clone_node (node, node->decl,\n+\t  master_clone = cgraph_clone_node (node, node->symbol.decl,\n \t\t\t\t\t    node->count, CGRAPH_FREQ_BASE,\n \t\t\t\t\t    false, NULL, true);\n \t  for (e = master_clone->callees; e; e = e->next_callee)\n@@ -1349,7 +1351,7 @@ inline_small_functions (void)\n \t  {\n \t    struct inline_summary *info = inline_summary (node);\n \n-\t    if (!DECL_EXTERNAL (node->decl))\n+\t    if (!DECL_EXTERNAL (node->symbol.decl))\n \t      initial_size += info->size;\n \t  }\n \n@@ -1451,7 +1453,7 @@ inline_small_functions (void)\n \t}\n \n       if (overall_size + growth > max_size\n-\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+\t  && !DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n \t{\n \t  edge->inline_failed = CIF_INLINE_UNIT_GROWTH_LIMIT;\n \t  report_inline_failed_reason (edge);\n@@ -1497,7 +1499,7 @@ inline_small_functions (void)\n \t  where = edge->caller;\n \t  while (where->global.inlined_to)\n \t    {\n-\t      if (where->decl == callee->decl)\n+\t      if (where->symbol.decl == callee->symbol.decl)\n \t\touter_node = where, depth++;\n \t      where = where->callers->caller;\n \t    }\n@@ -1506,7 +1508,7 @@ inline_small_functions (void)\n \t\t\t\t\t\t     true, depth))\n \t    {\n \t      edge->inline_failed\n-\t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->decl)\n+\t\t= (DECL_DISREGARD_INLINE_LIMITS (edge->callee->symbol.decl)\n \t\t   ? CIF_RECURSIVE_INLINING : CIF_UNSPECIFIED);\n \t      continue;\n \t    }\n@@ -1593,17 +1595,17 @@ flatten_function (struct cgraph_node *node, bool early)\n   struct cgraph_edge *e;\n \n   /* We shouldn't be called recursively when we are being processed.  */\n-  gcc_assert (node->aux == NULL);\n+  gcc_assert (node->symbol.aux == NULL);\n \n-  node->aux = (void *) node;\n+  node->symbol.aux = (void *) node;\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *orig_callee;\n       struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n \n       /* We've hit cycle?  It is time to give up.  */\n-      if (callee->aux)\n+      if (callee->symbol.aux)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -1637,8 +1639,8 @@ flatten_function (struct cgraph_node *node, bool early)\n \t  continue;\n \t}\n \n-      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->decl)))\n+      if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->symbol.decl))\n+\t  != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (callee->symbol.decl)))\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n@@ -1654,13 +1656,13 @@ flatten_function (struct cgraph_node *node, bool early)\n       orig_callee = callee;\n       inline_call (e, true, NULL, NULL);\n       if (e->callee != orig_callee)\n-\torig_callee->aux = (void *) node;\n+\torig_callee->symbol.aux = (void *) node;\n       flatten_function (e->callee, early);\n       if (e->callee != orig_callee)\n-\torig_callee->aux = NULL;\n+\torig_callee->symbol.aux = NULL;\n     }\n \n-  node->aux = NULL;\n+  node->symbol.aux = NULL;\n }\n \n /* Decide on the inlining.  We do so in the topological order to avoid\n@@ -1684,7 +1686,7 @@ ipa_inline (void)\n   nnodes = ipa_reverse_postorder (order);\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = 0;\n+    node->symbol.aux = 0;\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nFlattening functions:\\n\");\n@@ -1701,7 +1703,7 @@ ipa_inline (void)\n \t try to flatten itself turning it into a self-recursive\n \t function.  */\n       if (lookup_attribute (\"flatten\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)) != NULL)\n+\t\t\t    DECL_ATTRIBUTES (node->symbol.decl)) != NULL)\n \t{\n \t  if (dump_file)\n \t    fprintf (dump_file,\n@@ -1798,7 +1800,7 @@ inline_always_inline_functions (struct cgraph_node *node)\n   for (e = node->callees; e; e = e->next_callee)\n     {\n       struct cgraph_node *callee = cgraph_function_or_thunk_node (e->callee, NULL);\n-      if (!DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+      if (!DECL_DISREGARD_INLINE_LIMITS (callee->symbol.decl))\n \tcontinue;\n \n       if (cgraph_edge_recursive_p (e))\n@@ -1841,7 +1843,7 @@ early_inline_small_functions (struct cgraph_node *node)\n \tcontinue;\n \n       /* Do not consider functions not declared inline.  */\n-      if (!DECL_DECLARED_INLINE_P (callee->decl)\n+      if (!DECL_DECLARED_INLINE_P (callee->symbol.decl)\n \t  && !flag_inline_small_functions\n \t  && !flag_inline_functions)\n \tcontinue;\n@@ -1917,10 +1919,10 @@ early_inliner (void)\n \t cycles of edges to be always inlined in the callgraph.\n \n \t We might want to be smarter and just avoid this type of inlining.  */\n-      || DECL_DISREGARD_INLINE_LIMITS (node->decl))\n+      || DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n     ;\n   else if (lookup_attribute (\"flatten\",\n-\t\t\t     DECL_ATTRIBUTES (node->decl)) != NULL)\n+\t\t\t     DECL_ATTRIBUTES (node->symbol.decl)) != NULL)\n     {\n       /* When the function is marked to be flattened, recursively inline\n \t all calls in it.  */\n@@ -1951,9 +1953,9 @@ early_inliner (void)\n \t\t= estimate_num_insns (edge->call_stmt, &eni_size_weights);\n \t      es->call_stmt_time\n \t\t= estimate_num_insns (edge->call_stmt, &eni_time_weights);\n-\t      if (edge->callee->decl\n+\t      if (edge->callee->symbol.decl\n \t\t  && !gimple_check_call_matching_types (edge->call_stmt,\n-\t\t\t\t\t\t\tedge->callee->decl))\n+\t\t\t\t\t\t\tedge->callee->symbol.decl))\n \t\tedge->call_stmt_cannot_inline_p = true;\n \t    }\n \t  timevar_pop (TV_INTEGRATION);"}, {"sha": "67f603beb6b23ad2784f0e02c5e25614935a8784", "filename": "gcc/ipa-prop.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-prop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-prop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-prop.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -91,7 +91,7 @@ ipa_populate_param_decls (struct cgraph_node *node,\n   tree parm;\n   int param_num;\n \n-  fndecl = node->decl;\n+  fndecl = node->symbol.decl;\n   fnargs = DECL_ARGUMENTS (fndecl);\n   param_num = 0;\n   for (parm = fnargs; parm; parm = DECL_CHAIN (parm))\n@@ -129,7 +129,7 @@ ipa_initialize_node_params (struct cgraph_node *node)\n     {\n       int param_count;\n \n-      param_count = count_formal_params (node->decl);\n+      param_count = count_formal_params (node->symbol.decl);\n       if (param_count)\n \t{\n \t  VEC_safe_grow_cleared (ipa_param_descriptor_t, heap,\n@@ -1590,7 +1590,7 @@ static void\n ipa_analyze_params_uses (struct cgraph_node *node,\n \t\t\t struct param_analysis_info *parms_ainfo)\n {\n-  tree decl = node->decl;\n+  tree decl = node->symbol.decl;\n   basic_block bb;\n   struct function *func;\n   gimple_stmt_iterator gsi;\n@@ -1606,7 +1606,7 @@ ipa_analyze_params_uses (struct cgraph_node *node,\n       /* For SSA regs see if parameter is used.  For non-SSA we compute\n \t the flag during modification analysis.  */\n       if (is_gimple_reg (parm)\n-\t  && gimple_default_def (DECL_STRUCT_FUNCTION (node->decl), parm))\n+\t  && gimple_default_def (DECL_STRUCT_FUNCTION (node->symbol.decl), parm))\n \tipa_set_param_used (info, i, true);\n     }\n \n@@ -1650,8 +1650,8 @@ ipa_analyze_node (struct cgraph_node *node)\n   ipa_check_create_node_params ();\n   ipa_check_create_edge_args ();\n   info = IPA_NODE_REF (node);\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  current_function_decl = node->decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  current_function_decl = node->symbol.decl;\n   ipa_initialize_node_params (node);\n \n   param_count = ipa_get_param_count (info);\n@@ -1906,7 +1906,7 @@ update_indirect_edges_after_inlining (struct cgraph_edge *cs,\n \t  if (new_direct_edge->call_stmt)\n \t    new_direct_edge->call_stmt_cannot_inline_p\n \t      = !gimple_check_call_matching_types (new_direct_edge->call_stmt,\n-\t\t\t\t\t\t   new_direct_edge->callee->decl);\n+\t\t\t\t\t\t   new_direct_edge->callee->symbol.decl);\n \t  if (new_edges)\n \t    {\n \t      VEC_safe_push (cgraph_edge_p, heap, *new_edges,\n@@ -2427,7 +2427,7 @@ ipa_modify_call_arguments (struct cgraph_edge *cs, gimple stmt,\n \n   len = VEC_length (ipa_parm_adjustment_t, adjustments);\n   vargs = VEC_alloc (tree, heap, len);\n-  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->decl;\n+  callee_decl = !cs ? gimple_call_fndecl (stmt) : cs->callee->symbol.decl;\n \n   gsi = gsi_for_stmt (stmt);\n   for (i = 0; i < len; i++)"}, {"sha": "ca36935d91624da651e7f13f4f7194dde5445567", "filename": "gcc/ipa-pure-const.c", "status": "modified", "additions": 19, "deletions": 19, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-pure-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-pure-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-pure-const.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -724,7 +724,7 @@ check_stmt (gimple_stmt_iterator *gsip, funct_state local, bool ipa)\n static funct_state\n analyze_function (struct cgraph_node *fn, bool ipa)\n {\n-  tree decl = fn->decl;\n+  tree decl = fn->symbol.decl;\n   tree old_decl = current_function_decl;\n   funct_state l;\n   basic_block this_block;\n@@ -736,7 +736,7 @@ analyze_function (struct cgraph_node *fn, bool ipa)\n   l->looping = false;\n   l->can_throw = false;\n   state_from_flags (&l->state_previously_known, &l->looping_previously_known,\n-\t\t    flags_from_decl_or_type (fn->decl),\n+\t\t    flags_from_decl_or_type (fn->symbol.decl),\n \t\t    cgraph_node_cannot_return (fn));\n \n   if (fn->thunk.thunk_p || fn->alias)\n@@ -1037,7 +1037,7 @@ pure_const_read_summary (void)\n \t      fs->can_throw = bp_unpack_value (&bp, 1);\n \t      if (dump_file)\n \t\t{\n-\t\t  int flags = flags_from_decl_or_type (node->decl);\n+\t\t  int flags = flags_from_decl_or_type (node->symbol.decl);\n \t\t  fprintf (dump_file, \"Read info for %s/%i \",\n \t\t\t   cgraph_node_name (node),\n \t\t\t   node->uid);\n@@ -1215,11 +1215,11 @@ propagate_pure_const (void)\n \t\t    }\n \t\t}\n \t      else if (special_builtin_state (&edge_state, &edge_looping,\n-\t\t\t\t\t       y->decl))\n+\t\t\t\t\t       y->symbol.decl))\n \t\t;\n \t      else\n \t\tstate_from_flags (&edge_state, &edge_looping,\n-\t\t\t\t  flags_from_decl_or_type (y->decl),\n+\t\t\t\t  flags_from_decl_or_type (y->symbol.decl),\n \t\t\t\t  cgraph_edge_cannot_lead_to_return (e));\n \n \t      /* Merge the results with what we already know.  */\n@@ -1258,15 +1258,15 @@ propagate_pure_const (void)\n \t    break;\n \n \t  /* And finally all loads and stores.  */\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&w->ref_list, i, ref); i++)\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&w->symbol.ref_list, i, ref); i++)\n \t    {\n \t      enum pure_const_state_e ref_state = IPA_CONST;\n \t      bool ref_looping = false;\n \t      switch (ref->use)\n \t\t{\n \t\tcase IPA_REF_LOAD:\n \t\t  /* readonly reads are safe.  */\n-\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->decl))\n+\t\t  if (TREE_READONLY (ipa_ref_varpool_node (ref)->symbol.decl))\n \t\t    break;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t    fprintf (dump_file, \"    nonreadonly global var read\\n\");\n@@ -1290,7 +1290,7 @@ propagate_pure_const (void)\n \t      if (pure_const_state == IPA_NEITHER)\n \t\tbreak;\n \t    }\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n       if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1325,9 +1325,9 @@ propagate_pure_const (void)\n \t  switch (this_state)\n \t    {\n \t    case IPA_CONST:\n-\t      if (!TREE_READONLY (w->decl))\n+\t      if (!TREE_READONLY (w->symbol.decl))\n \t\t{\n-\t\t  warn_function_const (w->decl, !this_looping);\n+\t\t  warn_function_const (w->symbol.decl, !this_looping);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %sconst: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n@@ -1337,9 +1337,9 @@ propagate_pure_const (void)\n \t      break;\n \n \t    case IPA_PURE:\n-\t      if (!DECL_PURE_P (w->decl))\n+\t      if (!DECL_PURE_P (w->symbol.decl))\n \t\t{\n-\t\t  warn_function_pure (w->decl, !this_looping);\n+\t\t  warn_function_pure (w->symbol.decl, !this_looping);\n \t\t  if (dump_file)\n \t\t    fprintf (dump_file, \"Function found to be %spure: %s\\n\",\n \t\t\t     this_looping ? \"looping \" : \"\",\n@@ -1351,7 +1351,7 @@ propagate_pure_const (void)\n \t    default:\n \t      break;\n \t    }\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -1418,17 +1418,17 @@ propagate_nothrow (void)\n \n \t\t  if (can_throw)\n \t\t    break;\n-\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->decl)\n+\t\t  if (y_l->can_throw && !TREE_NOTHROW (w->symbol.decl)\n \t\t      && e->can_throw_external)\n \t\t    can_throw = true;\n \t\t}\n-\t      else if (e->can_throw_external && !TREE_NOTHROW (y->decl))\n+\t      else if (e->can_throw_external && !TREE_NOTHROW (y->symbol.decl))\n \t        can_throw = true;\n \t    }\n           for (ie = node->indirect_calls; ie; ie = ie->next_callee)\n \t    if (ie->can_throw_external)\n \t      can_throw = true;\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n \n@@ -1438,16 +1438,16 @@ propagate_nothrow (void)\n       while (w)\n \t{\n \t  funct_state w_l = get_function_state (w);\n-\t  if (!can_throw && !TREE_NOTHROW (w->decl))\n+\t  if (!can_throw && !TREE_NOTHROW (w->symbol.decl))\n \t    {\n \t      cgraph_set_nothrow_flag (w, true);\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Function found to be nothrow: %s\\n\",\n \t\t\t cgraph_node_name (w));\n \t    }\n-\t  else if (can_throw && !TREE_NOTHROW (w->decl))\n+\t  else if (can_throw && !TREE_NOTHROW (w->symbol.decl))\n \t    w_l->can_throw = true;\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n     }"}, {"sha": "b9c3f5335341c308b3330c52d589be9947e34238", "filename": "gcc/ipa-ref-inline.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-ref-inline.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-ref-inline.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref-inline.h?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -60,9 +60,9 @@ static inline struct ipa_ref_list *\n ipa_ref_refering_ref_list (struct ipa_ref *ref)\n {\n   if (ref->refering_type == IPA_REF_CGRAPH)\n-    return &ipa_ref_refering_node (ref)->ref_list;\n+    return &ipa_ref_refering_node (ref)->symbol.ref_list;\n   else\n-    return &ipa_ref_refering_varpool_node (ref)->ref_list;\n+    return &ipa_ref_refering_varpool_node (ref)->symbol.ref_list;\n }\n \n /* Return reference list REF is in.  */\n@@ -71,9 +71,9 @@ static inline struct ipa_ref_list *\n ipa_ref_refered_ref_list (struct ipa_ref *ref)\n {\n   if (ref->refered_type == IPA_REF_CGRAPH)\n-    return &ipa_ref_node (ref)->ref_list;\n+    return &ipa_ref_node (ref)->symbol.ref_list;\n   else\n-    return &ipa_ref_varpool_node (ref)->ref_list;\n+    return &ipa_ref_varpool_node (ref)->symbol.ref_list;\n }\n \n /* Return first reference in LIST or NULL if empty.  */"}, {"sha": "4f4d7d013781127805f9ba5a6364d62648679896", "filename": "gcc/ipa-ref.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-ref.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -48,15 +48,15 @@ ipa_record_reference (struct cgraph_node *refering_node,\n   gcc_assert (!stmt || refering_node);\n   gcc_assert (use_type != IPA_REF_ALIAS || !stmt);\n \n-  list = (refering_node ? &refering_node->ref_list\n-\t  : &refering_varpool_node->ref_list);\n+  list = (refering_node ? &refering_node->symbol.ref_list\n+\t  : &refering_varpool_node->symbol.ref_list);\n   old_references = list->references;\n   VEC_safe_grow (ipa_ref_t, gc, list->references,\n \t\t VEC_length (ipa_ref_t, list->references) + 1);\n   ref = VEC_last (ipa_ref_t, list->references);\n \n-  list2 = (refered_node ? &refered_node->ref_list\n-\t   : &refered_varpool_node->ref_list);\n+  list2 = (refered_node ? &refered_node->symbol.ref_list\n+\t   : &refered_varpool_node->symbol.ref_list);\n   VEC_safe_push (ipa_ref_ptr, heap, list2->refering, ref);\n   ref->refered_index = VEC_length (ipa_ref_ptr, list2->refering) - 1;\n   if (refering_node)"}, {"sha": "e7950688b403291b817122ae3e2425edf3ef42b1", "filename": "gcc/ipa-reference.c", "status": "modified", "additions": 23, "deletions": 23, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-reference.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-reference.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-reference.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -200,7 +200,7 @@ ipa_reference_get_not_read_global (struct cgraph_node *fn)\n   info = get_reference_optimization_summary (cgraph_function_node (fn, NULL));\n   if (info)\n     return info->statics_not_read;\n-  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n+  else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n     return all_module_statics;\n   else\n     return NULL;\n@@ -219,7 +219,7 @@ ipa_reference_get_not_written_global (struct cgraph_node *fn)\n   info = get_reference_optimization_summary (fn);\n   if (info)\n     return info->statics_not_written;\n-  else if (flags_from_decl_or_type (fn->decl) & ECF_LEAF)\n+  else if (flags_from_decl_or_type (fn->symbol.decl) & ECF_LEAF)\n     return all_module_statics;\n   else\n     return NULL;\n@@ -310,9 +310,9 @@ propagate_bits (ipa_reference_global_vars_info_t x_global, struct cgraph_node *x\n       /* Only look into nodes we can propagate something.  */\n       if (avail > AVAIL_OVERWRITABLE\n \t  || (avail == AVAIL_OVERWRITABLE\n-\t      && (flags_from_decl_or_type (y->decl) & ECF_LEAF)))\n+\t      && (flags_from_decl_or_type (y->symbol.decl) & ECF_LEAF)))\n \t{\n-\t  int flags = flags_from_decl_or_type (y->decl);\n+\t  int flags = flags_from_decl_or_type (y->symbol.decl);\n \t  if (get_reference_vars_info (y))\n \t    {\n \t      ipa_reference_vars_info_t y_info\n@@ -433,12 +433,12 @@ analyze_function (struct cgraph_node *fn)\n   tree var;\n \n   local = init_function_info (fn);\n-  for (i = 0; ipa_ref_list_reference_iterate (&fn->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_reference_iterate (&fn->symbol.ref_list, i, ref); i++)\n     {\n       if (ref->refered_type != IPA_REF_VARPOOL)\n \tcontinue;\n-      var = ipa_ref_varpool_node (ref)->decl;\n-      if (ipa_ref_varpool_node (ref)->externally_visible\n+      var = ipa_ref_varpool_node (ref)->symbol.decl;\n+      if (ipa_ref_varpool_node (ref)->symbol.externally_visible\n \t  || !ipa_ref_varpool_node (ref)->analyzed\n \t  || !is_proper_for_analysis (var))\n \tcontinue;\n@@ -580,7 +580,7 @@ static void\n read_write_all_from_decl (struct cgraph_node *node, bool * read_all,\n \t\t\t  bool * write_all)\n {\n-  tree decl = node->decl;\n+  tree decl = node->symbol.decl;\n   int flags = flags_from_decl_or_type (decl);\n   if ((flags & ECF_LEAF)\n       && cgraph_function_body_availability (node) <= AVAIL_OVERWRITABLE)\n@@ -692,7 +692,7 @@ propagate (void)\n \n       /* If any node in a cycle is read_all or write_all\n \t they all are. */\n-      w_info = (struct ipa_dfs_info *) node->aux;\n+      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n       w = w_info->next_cycle;\n       while (w && (!read_all || !write_all))\n \t{\n@@ -727,7 +727,7 @@ propagate (void)\n \t\t  }\n \t      }\n \n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n \n@@ -751,14 +751,14 @@ propagate (void)\n \t}\n \n       propagate_bits (node_g, node);\n-      w_info = (struct ipa_dfs_info *) node->aux;\n+      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n       w = w_info->next_cycle;\n       while (w && (!read_all || !write_all))\n \t{\n \t  ipa_reference_vars_info_t w_ri =\n \t    get_reference_vars_info (w);\n \t  ipa_reference_local_vars_info_t w_l = &w_ri->local;\n-\t  int flags = flags_from_decl_or_type (w->decl);\n+\t  int flags = flags_from_decl_or_type (w->symbol.decl);\n \n \t  /* These global bitmaps are initialized from the local info\n \t     of all of the nodes in the region.  However there is no\n@@ -773,13 +773,13 @@ propagate (void)\n \t    bitmap_ior_into (node_g->statics_written,\n \t\t\t     w_l->statics_written);\n \t  propagate_bits (node_g, w);\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n \n       /* All nodes within a cycle have the same global info bitmaps.  */\n       node_info->global = *node_g;\n-      w_info = (struct ipa_dfs_info *) node->aux;\n+      w_info = (struct ipa_dfs_info *) node->symbol.aux;\n       w = w_info->next_cycle;\n       while (w)\n \t{\n@@ -788,7 +788,7 @@ propagate (void)\n \n           w_ri->global = *node_g;\n \n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  w = w_info->next_cycle;\n \t}\n     }\n@@ -830,7 +830,7 @@ propagate (void)\n \t\t\tget_static_name (index));\n \t      }\n \n-\t  w_info = (struct ipa_dfs_info *) node->aux;\n+\t  w_info = (struct ipa_dfs_info *) node->symbol.aux;\n \t  w = w_info->next_cycle;\n \t  while (w)\n \t    {\n@@ -857,7 +857,7 @@ propagate (void)\n \t\t\t     get_static_name (index));\n \t\t  }\n \n-\t      w_info = (struct ipa_dfs_info *) w->aux;\n+\t      w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t      w = w_info->next_cycle;\n \t    }\n \t  fprintf (dump_file, \"\\n  globals read: \");\n@@ -895,7 +895,7 @@ propagate (void)\n \n       node_info = get_reference_vars_info (node);\n       if (cgraph_function_body_availability (node) > AVAIL_OVERWRITABLE\n-\t  || (flags_from_decl_or_type (node->decl) & ECF_LEAF))\n+\t  || (flags_from_decl_or_type (node->symbol.decl) & ECF_LEAF))\n \t{\n \t  node_g = &node_info->global;\n \n@@ -968,7 +968,7 @@ write_node_summary_p (struct cgraph_node *node,\n      In future we might also want to include summaries of functions references\n      by initializers of constant variables references in current unit.  */\n   if (!reachable_from_this_partition_p (node, set)\n-      && !referenced_from_this_partition_p (&node->ref_list, set, vset))\n+      && !referenced_from_this_partition_p (&node->symbol.ref_list, set, vset))\n     return false;\n \n   /* See if the info has non-empty intersections with vars we want to encode.  */\n@@ -1035,12 +1035,12 @@ ipa_reference_write_optimization_summary (cgraph_node_set set,\n   for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n     {\n       struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n-      if (!vnode->externally_visible\n+      if (!vnode->symbol.externally_visible\n \t  && vnode->analyzed\n-\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->decl))\n-\t  && referenced_from_this_partition_p (&vnode->ref_list, set, vset))\n+\t  && bitmap_bit_p (all_module_statics, DECL_UID (vnode->symbol.decl))\n+\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset))\n \t{\n-\t  tree decl = vnode->decl;\n+\t  tree decl = vnode->symbol.decl;\n \t  bitmap_set_bit (ltrans_statics, DECL_UID (decl));\n \t  splay_tree_insert (reference_vars_to_consider,\n \t\t\t     DECL_UID (decl), (splay_tree_value)decl);"}, {"sha": "1997f62538bffd8ff8372745bf72e13473d10c3c", "filename": "gcc/ipa-split.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-split.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-split.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-split.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1203,16 +1203,16 @@ split_function (struct split_point *split_point)\n   /* For usual cloning it is enough to clear builtin only when signature\n      changes.  For partial inlining we however can not expect the part\n      of builtin implementation to have same semantic as the whole.  */\n-  if (DECL_BUILT_IN (node->decl))\n+  if (DECL_BUILT_IN (node->symbol.decl))\n     {\n-      DECL_BUILT_IN_CLASS (node->decl) = NOT_BUILT_IN;\n-      DECL_FUNCTION_CODE (node->decl) = (enum built_in_function) 0;\n+      DECL_BUILT_IN_CLASS (node->symbol.decl) = NOT_BUILT_IN;\n+      DECL_FUNCTION_CODE (node->symbol.decl) = (enum built_in_function) 0;\n     }\n   cgraph_node_remove_callees (cur_node);\n   if (!split_part_return_p)\n-    TREE_THIS_VOLATILE (node->decl) = 1;\n+    TREE_THIS_VOLATILE (node->symbol.decl) = 1;\n   if (dump_file)\n-    dump_function_to_file (node->decl, dump_file, dump_flags);\n+    dump_function_to_file (node->symbol.decl, dump_file, dump_flags);\n \n   /* Create the basic block we place call into.  It is the entry basic block\n      split after last label.  */\n@@ -1237,7 +1237,7 @@ split_function (struct split_point *split_point)\n \t\t\t\t\tfalse, GSI_CONTINUE_LINKING);\n \tVEC_replace (tree, args_to_pass, i, arg);\n       }\n-  call = gimple_build_call_vec (node->decl, args_to_pass);\n+  call = gimple_build_call_vec (node->symbol.decl, args_to_pass);\n   gimple_set_block (call, DECL_INITIAL (current_function_decl));\n \n   /* We avoid address being taken on any variable used by split part,\n@@ -1423,7 +1423,7 @@ execute_split_functions (void)\n \tfprintf (dump_file, \"Not splitting: not inlinable.\\n\");\n       return 0;\n     }\n-  if (DECL_DISREGARD_INLINE_LIMITS (node->decl))\n+  if (DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: disregarding inline limits.\\n\");\n@@ -1455,8 +1455,8 @@ execute_split_functions (void)\n      called once.  It is possible that the caller is called more then once and\n      then inlining would still benefit.  */\n   if ((!node->callers || !node->callers->next_caller)\n-      && !node->address_taken\n-      && (!flag_lto || !node->local.externally_visible))\n+      && !node->symbol.address_taken\n+      && (!flag_lto || !node->symbol.externally_visible))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Not splitting: not called directly \""}, {"sha": "0f4dd504fa736ae6d1f902a5800efeacc6708a39", "filename": "gcc/ipa-utils.c", "status": "modified", "additions": 20, "deletions": 20, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-utils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa-utils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-utils.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -86,7 +86,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n \t bool (*ignore_edge) (struct cgraph_edge *))\n {\n   struct cgraph_edge *edge;\n-  struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->aux;\n+  struct ipa_dfs_info *v_info = (struct ipa_dfs_info *) v->symbol.aux;\n \n   /* mark node as old */\n   v_info->new_node = false;\n@@ -107,11 +107,11 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n       if (!w || (ignore_edge && ignore_edge (edge)))\n         continue;\n \n-      if (w->aux\n+      if (w->symbol.aux\n \t  && (avail > AVAIL_OVERWRITABLE\n \t      || (env->allow_overwritable && avail == AVAIL_OVERWRITABLE)))\n \t{\n-\t  w_info = (struct ipa_dfs_info *) w->aux;\n+\t  w_info = (struct ipa_dfs_info *) w->symbol.aux;\n \t  if (w_info->new_node)\n \t    {\n \t      searchc (env, w, ignore_edge);\n@@ -136,7 +136,7 @@ searchc (struct searchc_env* env, struct cgraph_node *v,\n       struct ipa_dfs_info *x_info;\n       do {\n \tx = env->stack[--(env->stack_size)];\n-\tx_info = (struct ipa_dfs_info *) x->aux;\n+\tx_info = (struct ipa_dfs_info *) x->symbol.aux;\n \tx_info->on_stack = false;\n \tx_info->scc_no = v_info->dfn_number;\n \n@@ -187,20 +187,20 @@ ipa_reduced_postorder (struct cgraph_node **order,\n \t      && (avail == AVAIL_OVERWRITABLE)))\n \t{\n \t  /* Reuse the info if it is already there.  */\n-\t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->aux;\n+\t  struct ipa_dfs_info *info = (struct ipa_dfs_info *) node->symbol.aux;\n \t  if (!info)\n \t    info = XCNEW (struct ipa_dfs_info);\n \t  info->new_node = true;\n \t  info->on_stack = false;\n \t  info->next_cycle = NULL;\n-\t  node->aux = info;\n+\t  node->symbol.aux = info;\n \n \t  splay_tree_insert (env.nodes_marked_new,\n \t\t\t     (splay_tree_key)node->uid,\n \t\t\t     (splay_tree_value)node);\n \t}\n       else\n-\tnode->aux = NULL;\n+\tnode->symbol.aux = NULL;\n     }\n   result = splay_tree_min (env.nodes_marked_new);\n   while (result)\n@@ -225,10 +225,10 @@ ipa_free_postorder_info (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       /* Get rid of the aux information.  */\n-      if (node->aux)\n+      if (node->symbol.aux)\n \t{\n-\t  free (node->aux);\n-\t  node->aux = NULL;\n+\t  free (node->symbol.aux);\n+\t  node->symbol.aux = NULL;\n \t}\n     }\n }\n@@ -262,12 +262,12 @@ ipa_reverse_postorder (struct cgraph_node **order)\n      to be output and put them into order as well, so we get dependencies\n      right through inline functions.  */\n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n+    node->symbol.aux = NULL;\n   for (pass = 0; pass < 2; pass++)\n     for (node = cgraph_nodes; node; node = node->next)\n-      if (!node->aux\n+      if (!node->symbol.aux\n \t  && (pass\n-\t      || (!node->address_taken\n+\t      || (!node->symbol.address_taken\n \t\t  && !node->global.inlined_to\n \t\t  && !node->alias && !node->thunk.thunk_p\n \t\t  && !cgraph_only_called_directly_p (node))))\n@@ -276,7 +276,7 @@ ipa_reverse_postorder (struct cgraph_node **order)\n           stack[stack_size].node = node;\n \t  stack[stack_size].edge = node->callers;\n \t  stack[stack_size].ref = 0;\n-\t  node->aux = (void *)(size_t)1;\n+\t  node->symbol.aux = (void *)(size_t)1;\n \t  while (stack_size >= 0)\n \t    {\n \t      while (true)\n@@ -290,12 +290,12 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t      /* Break possible cycles involving always-inline\n \t\t\t functions by ignoring edges from always-inline\n \t\t\t functions to non-always-inline functions.  */\n-\t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->decl)\n+\t\t      if (DECL_DISREGARD_INLINE_LIMITS (edge->caller->symbol.decl)\n \t\t\t  && !DECL_DISREGARD_INLINE_LIMITS\n-\t\t\t    (cgraph_function_node (edge->callee, NULL)->decl))\n+\t\t\t    (cgraph_function_node (edge->callee, NULL)->symbol.decl))\n \t\t\tnode2 = NULL;\n \t\t    }\n-\t\t  for (;ipa_ref_list_refering_iterate (&stack[stack_size].node->ref_list,\n+\t\t  for (;ipa_ref_list_refering_iterate (&stack[stack_size].node->symbol.ref_list,\n \t\t\t\t\t\t       stack[stack_size].ref,\n \t\t\t\t\t\t       ref) && !node2;\n \t\t       stack[stack_size].ref++)\n@@ -305,20 +305,20 @@ ipa_reverse_postorder (struct cgraph_node **order)\n \t\t    }\n \t\t  if (!node2)\n \t\t    break;\n-\t\t  if (!node2->aux)\n+\t\t  if (!node2->symbol.aux)\n \t\t    {\n \t\t      stack[++stack_size].node = node2;\n \t\t      stack[stack_size].edge = node2->callers;\n \t\t      stack[stack_size].ref = 0;\n-\t\t      node2->aux = (void *)(size_t)1;\n+\t\t      node2->symbol.aux = (void *)(size_t)1;\n \t\t    }\n \t\t}\n \t      order[order_pos++] = stack[stack_size--].node;\n \t    }\n \t}\n   free (stack);\n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n+    node->symbol.aux = NULL;\n   return order_pos;\n }\n "}, {"sha": "c96fede1e8ed7e17a96c8ce40cbc203d2921ed2a", "filename": "gcc/ipa.c", "status": "modified", "additions": 166, "deletions": 151, "changes": 317, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -60,13 +60,13 @@ static void\n enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first)\n {\n   /* Node is still in queue; do nothing.  */\n-  if (node->aux && node->aux != (void *) 2)\n+  if (node->symbol.aux && node->symbol.aux != (void *) 2)\n     return;\n   /* Node was already processed as unreachable, re-enqueue\n      only if it became reachable now.  */\n-  if (node->aux == (void *)2 && !node->reachable)\n+  if (node->symbol.aux == (void *)2 && !node->reachable)\n     return;\n-  node->aux = *first;\n+  node->symbol.aux = *first;\n   *first = node;\n }\n \n@@ -75,7 +75,7 @@ enqueue_cgraph_node (struct cgraph_node *node, struct cgraph_node **first)\n static void\n enqueue_varpool_node (struct varpool_node *node, struct varpool_node **first)\n {\n-  node->aux = *first;\n+  node->symbol.aux = *first;\n   *first = node;\n }\n \n@@ -96,7 +96,7 @@ process_references (struct ipa_ref_list *list,\n \t  struct cgraph_node *node = ipa_ref_node (ref);\n \t  if (!node->reachable\n \t      && node->analyzed\n-\t      && (!DECL_EXTERNAL (node->decl)\n+\t      && (!DECL_EXTERNAL (node->symbol.decl)\n \t          || before_inlining_p))\n \t    node->reachable = true;\n \t  enqueue_cgraph_node (node, first);\n@@ -121,12 +121,12 @@ cgraph_non_local_node_p_1 (struct cgraph_node *node, void *data ATTRIBUTE_UNUSED\n {\n    /* FIXME: Aliases can be local, but i386 gets thunks wrong then.  */\n    return !(cgraph_only_called_directly_or_aliased_p (node)\n-\t    && !ipa_ref_has_aliases_p (&node->ref_list)\n+\t    && !ipa_ref_has_aliases_p (&node->symbol.ref_list)\n \t    && node->analyzed\n-\t    && !DECL_EXTERNAL (node->decl)\n-\t    && !node->local.externally_visible\n-\t    && !node->reachable_from_other_partition\n-\t    && !node->in_other_partition);\n+\t    && !DECL_EXTERNAL (node->symbol.decl)\n+\t    && !node->symbol.externally_visible\n+\t    && !node->symbol.used_from_other_partition\n+\t    && !node->symbol.in_other_partition);\n }\n \n /* Return true when function can be marked local.  */\n@@ -154,7 +154,8 @@ has_addr_references_p (struct cgraph_node *node,\n   int i;\n   struct ipa_ref *ref;\n \n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       return true;\n   return false;\n@@ -181,9 +182,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n     fprintf (file, \"\\nReclaiming functions:\");\n #ifdef ENABLE_CHECKING\n   for (node = cgraph_nodes; node; node = node->next)\n-    gcc_assert (!node->aux);\n+    gcc_assert (!node->symbol.aux);\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    gcc_assert (!vnode->aux);\n+    gcc_assert (!vnode->symbol.aux);\n #endif\n   varpool_reset_queue ();\n   /* Mark functions whose bodies are obviously needed.\n@@ -195,16 +196,16 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t&& (!cgraph_can_remove_if_no_direct_calls_and_refs_p (node)\n \t    /* Keep around virtual functions for possible devirtualization.  */\n \t    || (before_inlining_p\n-\t\t&& DECL_VIRTUAL_P (node->decl)\n-\t\t&& (DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl)))))\n+\t\t&& DECL_VIRTUAL_P (node->symbol.decl)\n+\t\t&& (DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl)))))\n       {\n         gcc_assert (!node->global.inlined_to);\n \tenqueue_cgraph_node (node, &first);\n \tnode->reachable = true;\n       }\n     else\n       {\n-        gcc_assert (!node->aux);\n+        gcc_assert (!node->symbol.aux);\n \tnode->reachable = false;\n       }\n \n@@ -238,9 +239,9 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t{\n \t  struct cgraph_edge *e;\n \t  node = first;\n-\t  first = (struct cgraph_node *) first->aux;\n+\t  first = (struct cgraph_node *) first->symbol.aux;\n \t  if (!node->reachable)\n-\t    node->aux = (void *)2;\n+\t    node->symbol.aux = (void *)2;\n \n \t  /* If we found this node reachable, first mark on the callees\n \t     reachable too, unless they are direct calls to extern inline functions\n@@ -252,24 +253,25 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t  if (!e->callee->reachable\n \t\t      && node->analyzed\n \t\t      && (!e->inline_failed\n-\t\t\t  || !DECL_EXTERNAL (e->callee->decl)\n+\t\t\t  || !DECL_EXTERNAL (e->callee->symbol.decl)\n \t\t\t  || before_inlining_p))\n \t\t    e->callee->reachable = true;\n \t\t  enqueue_cgraph_node (e->callee, &first);\n \t\t}\n-\t      process_references (&node->ref_list, &first, &first_varpool, before_inlining_p);\n+\t      process_references (&node->symbol.ref_list, &first,\n+\t\t\t\t  &first_varpool, before_inlining_p);\n \t    }\n \n \t  /* If any function in a comdat group is reachable, force\n \t     all other functions in the same comdat group to be\n \t     also reachable.  */\n-\t  if (node->same_comdat_group\n+\t  if (node->symbol.same_comdat_group\n \t      && node->reachable\n \t      && !node->global.inlined_to)\n \t    {\n-\t      for (next = node->same_comdat_group;\n+\t      for (next = cgraph (node->symbol.same_comdat_group);\n \t\t   next != node;\n-\t\t   next = next->same_comdat_group)\n+\t\t   next = cgraph (next->symbol.same_comdat_group))\n \t\tif (!next->reachable)\n \t\t  {\n \t\t    next->reachable = true;\n@@ -281,12 +283,12 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t     function is clone of real clone, we must keep it around in order to\n \t     make materialize_clones produce function body with the changes\n \t     applied.  */\n-\t  while (node->clone_of && !node->clone_of->aux\n-\t         && !gimple_has_body_p (node->decl))\n+\t  while (node->clone_of && !node->clone_of->symbol.aux\n+\t         && !gimple_has_body_p (node->symbol.decl))\n \t    {\n-\t      bool noninline = node->clone_of->decl != node->decl;\n+\t      bool noninline = node->clone_of->symbol.decl != node->symbol.decl;\n \t      node = node->clone_of;\n-\t      if (noninline && !node->reachable && !node->aux)\n+\t      if (noninline && !node->reachable && !node->symbol.aux)\n \t      \t{\n \t\t  enqueue_cgraph_node (node, &first);\n \t\t  break;\n@@ -296,18 +298,19 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n       if (first_varpool != (struct varpool_node *) (void *) 1)\n \t{\n \t  vnode = first_varpool;\n-\t  first_varpool = (struct varpool_node *)first_varpool->aux;\n-\t  vnode->aux = NULL;\n-\t  process_references (&vnode->ref_list, &first, &first_varpool, before_inlining_p);\n+\t  first_varpool = (struct varpool_node *)first_varpool->symbol.aux;\n+\t  vnode->symbol.aux = NULL;\n+\t  process_references (&vnode->symbol.ref_list, &first,\n+\t\t\t      &first_varpool, before_inlining_p);\n \t  /* If any function in a comdat group is reachable, force\n \t     all other functions in the same comdat group to be\n \t     also reachable.  */\n-\t  if (vnode->same_comdat_group)\n+\t  if (vnode->symbol.same_comdat_group)\n \t    {\n \t      struct varpool_node *next;\n-\t      for (next = vnode->same_comdat_group;\n+\t      for (next = varpool (vnode->symbol.same_comdat_group);\n \t\t   next != vnode;\n-\t\t   next = next->same_comdat_group)\n+\t\t   next = varpool (next->symbol.same_comdat_group))\n \t\tif (!next->needed)\n \t\t  {\n \t\t    varpool_mark_needed_node (next);\n@@ -329,13 +332,13 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   for (node = cgraph_nodes; node; node = next)\n     {\n       next = node->next;\n-      if (node->aux && !node->reachable)\n+      if (node->symbol.aux && !node->reachable)\n         {\n \t  cgraph_node_remove_callees (node);\n-\t  ipa_remove_all_references (&node->ref_list);\n+\t  ipa_remove_all_references (&node->symbol.ref_list);\n \t  node->analyzed = false;\n \t}\n-      if (!node->aux)\n+      if (!node->symbol.aux)\n \t{\n \t  struct cgraph_edge *e;\n \t  bool found = false;\n@@ -349,7 +352,8 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  for (e = node->callers; e && !found; e = e->next_caller)\n \t    if (e->caller->reachable)\n \t      found = true;\n-\t  for (i = 0; (ipa_ref_list_refering_iterate (&node->ref_list, i, ref)\n+\t  for (i = 0; (ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t\t      i, ref)\n \t\t       && !found); i++)\n \t    if (ref->refering_type == IPA_REF_CGRAPH\n \t\t&& ipa_ref_refering_node (ref)->reachable)\n@@ -369,7 +373,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t     Otherwise we can just remove the body but keep the clone.  */\n \t\t  for (clone = node->clones; clone;\n \t\t       clone = clone->next_sibling_clone)\n-\t\t    if (clone->aux)\n+\t\t    if (clone->symbol.aux)\n \t\t      break;\n \t\t  if (!clone)\n \t\t    {\n@@ -381,17 +385,17 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t\t      if (node->next_sibling_clone)\n \t\t\tnode->next_sibling_clone->prev_sibling_clone = node->prev_sibling_clone;\n \t\t      if (node->clone_of)\n-\t\t\tnode->former_clone_of = node->clone_of->decl;\n+\t\t\tnode->former_clone_of = node->clone_of->symbol.decl;\n \t\t      node->clone_of = NULL;\n \t\t      node->next_sibling_clone = NULL;\n \t\t      node->prev_sibling_clone = NULL;\n \t\t    }\n \t\t  else\n-\t\t    gcc_assert (!clone->in_other_partition);\n+\t\t    gcc_assert (!clone->symbol.in_other_partition);\n \t\t  node->analyzed = false;\n \t\t  changed = true;\n \t\t  cgraph_node_remove_callees (node);\n-\t\t  ipa_remove_all_references (&node->ref_list);\n+\t\t  ipa_remove_all_references (&node->symbol.ref_list);\n \t\t}\n \t    }\n \t  else\n@@ -413,7 +417,7 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n \t  node->global.inlined_to = NULL;\n \t  update_inlined_to_pointer (node, node);\n \t}\n-      node->aux = NULL;\n+      node->symbol.aux = NULL;\n     }\n \n   if (file)\n@@ -438,14 +442,14 @@ cgraph_remove_unreachable_nodes (bool before_inlining_p, FILE *file)\n   if (file)\n     fprintf (file, \"\\nClearing address taken flags:\");\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->address_taken\n-\t&& !node->reachable_from_other_partition)\n+    if (node->symbol.address_taken\n+\t&& !node->symbol.used_from_other_partition)\n       {\n \tif (!cgraph_for_node_and_aliases (node, has_addr_references_p, NULL, true))\n \t  {\n \t    if (file)\n \t      fprintf (file, \" %s\", cgraph_node_name (node));\n-\t    node->address_taken = false;\n+\t    node->symbol.address_taken = false;\n \t    changed = true;\n \t    if (cgraph_local_node_p (node))\n \t      {\n@@ -490,13 +494,15 @@ ipa_discover_readonly_nonaddressable_vars (void)\n     fprintf (dump_file, \"Clearing variable flags:\");\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     if (vnode->finalized && varpool_all_refs_explicit_p (vnode)\n-\t&& (TREE_ADDRESSABLE (vnode->decl) || !TREE_READONLY (vnode->decl)))\n+\t&& (TREE_ADDRESSABLE (vnode->symbol.decl)\n+\t    || !TREE_READONLY (vnode->symbol.decl)))\n       {\n \tbool written = false;\n \tbool address_taken = false;\n \tint i;\n         struct ipa_ref *ref;\n-        for (i = 0; ipa_ref_list_refering_iterate (&vnode->ref_list, i, ref)\n+        for (i = 0; ipa_ref_list_refering_iterate (&vnode->symbol.ref_list,\n+\t\t\t\t\t\t   i, ref)\n \t\t    && (!written || !address_taken); i++)\n \t  switch (ref->use)\n \t    {\n@@ -509,21 +515,21 @@ ipa_discover_readonly_nonaddressable_vars (void)\n \t      written = true;\n \t      break;\n \t    }\n-\tif (TREE_ADDRESSABLE (vnode->decl) && !address_taken)\n+\tif (TREE_ADDRESSABLE (vnode->symbol.decl) && !address_taken)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (addressable)\", varpool_node_name (vnode));\n-\t    TREE_ADDRESSABLE (vnode->decl) = 0;\n+\t    TREE_ADDRESSABLE (vnode->symbol.decl) = 0;\n \t  }\n-\tif (!TREE_READONLY (vnode->decl) && !address_taken && !written\n+\tif (!TREE_READONLY (vnode->symbol.decl) && !address_taken && !written\n \t    /* Making variable in explicit section readonly can cause section\n \t       type conflict. \n \t       See e.g. gcc.c-torture/compile/pr23237.c */\n-\t    && DECL_SECTION_NAME (vnode->decl) == NULL)\n+\t    && DECL_SECTION_NAME (vnode->symbol.decl) == NULL)\n \t  {\n \t    if (dump_file)\n \t      fprintf (dump_file, \" %s (read-only)\", varpool_node_name (vnode));\n-\t    TREE_READONLY (vnode->decl) = 1;\n+\t    TREE_READONLY (vnode->symbol.decl) = 1;\n \t  }\n       }\n   if (dump_file)\n@@ -536,14 +542,15 @@ cgraph_address_taken_from_non_vtable_p (struct cgraph_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t     i, ref); i++)\n     if (ref->use == IPA_REF_ADDR)\n       {\n \tstruct varpool_node *node;\n \tif (ref->refering_type == IPA_REF_CGRAPH)\n \t  return true;\n \tnode = ipa_ref_refering_varpool_node (ref);\n-\tif (!DECL_VIRTUAL_P (node->decl))\n+\tif (!DECL_VIRTUAL_P (node->symbol.decl))\n \t  return true;\n       }\n   return false;\n@@ -562,20 +569,20 @@ bool\n cgraph_comdat_can_be_unshared_p (struct cgraph_node *node)\n {\n   if ((cgraph_address_taken_from_non_vtable_p (node)\n-       && !DECL_VIRTUAL_P (node->decl))\n+       && !DECL_VIRTUAL_P (node->symbol.decl))\n       || !node->analyzed)\n     return false;\n-  if (node->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n     {\n       struct cgraph_node *next;\n \n       /* If more than one function is in the same COMDAT group, it must\n          be shared even if just one function in the comdat group has\n          address taken.  */\n-      for (next = node->same_comdat_group;\n-\t   next != node; next = next->same_comdat_group)\n+      for (next = cgraph (node->symbol.same_comdat_group);\n+\t   next != node; next = cgraph (next->symbol.same_comdat_group))\n \tif (cgraph_address_taken_from_non_vtable_p (next)\n-\t    && !DECL_VIRTUAL_P (next->decl))\n+\t    && !DECL_VIRTUAL_P (next->symbol.decl))\n \t  return false;\n     }\n   return true;\n@@ -589,8 +596,9 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n {\n   if (!node->local.finalized)\n     return false;\n-  if (!DECL_COMDAT (node->decl)\n-      && (!TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl)))\n+  if (!DECL_COMDAT (node->symbol.decl)\n+      && (!TREE_PUBLIC (node->symbol.decl)\n+\t  || DECL_EXTERNAL (node->symbol.decl)))\n     return false;\n \n   /* Do not even try to be smart about aliased nodes.  Until we properly\n@@ -603,42 +611,44 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n      using the implicit built-in declarations anymore.  Similarly this enables\n      us to remove them as unreachable before actual calls may appear during\n      expansion or folding.  */\n-  if (DECL_BUILT_IN (node->decl))\n+  if (DECL_BUILT_IN (node->symbol.decl))\n     return true;\n \n   /* If linker counts on us, we must preserve the function.  */\n   if (cgraph_used_from_object_file_p (node))\n     return true;\n-  if (DECL_PRESERVE_P (node->decl))\n+  if (DECL_PRESERVE_P (node->symbol.decl))\n     return true;\n-  if (lookup_attribute (\"externally_visible\", DECL_ATTRIBUTES (node->decl)))\n+  if (lookup_attribute (\"externally_visible\",\n+\t\t\tDECL_ATTRIBUTES (node->symbol.decl)))\n     return true;\n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n-      && lookup_attribute (\"dllexport\", DECL_ATTRIBUTES (node->decl)))\n+      && lookup_attribute (\"dllexport\",\n+\t\t\t   DECL_ATTRIBUTES (node->symbol.decl)))\n     return true;\n-  if (node->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (node->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n   /* When doing LTO or whole program, we can bring COMDAT functoins static.\n      This improves code quality and we know we will duplicate them at most twice\n      (in the case that we are not using plugin and link with object file\n       implementing same COMDAT)  */\n   if ((in_lto_p || whole_program)\n-      && DECL_COMDAT (node->decl)\n+      && DECL_COMDAT (node->symbol.decl)\n       && cgraph_comdat_can_be_unshared_p (node))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n-      && (DECL_VISIBILITY (node->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (node->decl) == VISIBILITY_INTERNAL)\n+      && (DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (node->symbol.decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n       && node->analyzed)\n     ;\n   else if (!whole_program)\n     return true;\n \n-  if (MAIN_NAME_P (DECL_NAME (node->decl)))\n+  if (MAIN_NAME_P (DECL_NAME (node->symbol.decl)))\n     return true;\n \n   return false;\n@@ -649,7 +659,7 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n bool\n varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n {\n-  if (!DECL_COMDAT (vnode->decl) && !TREE_PUBLIC (vnode->decl))\n+  if (!DECL_COMDAT (vnode->symbol.decl) && !TREE_PUBLIC (vnode->symbol.decl))\n     return false;\n \n   /* Do not even try to be smart about aliased nodes.  Until we properly\n@@ -661,16 +671,16 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n   if (varpool_used_from_object_file_p (vnode))\n     return true;\n \n-  if (DECL_HARD_REGISTER (vnode->decl))\n+  if (DECL_HARD_REGISTER (vnode->symbol.decl))\n     return true;\n-  if (DECL_PRESERVE_P (vnode->decl))\n+  if (DECL_PRESERVE_P (vnode->symbol.decl))\n     return true;\n   if (lookup_attribute (\"externally_visible\",\n-\t\t\tDECL_ATTRIBUTES (vnode->decl)))\n+\t\t\tDECL_ATTRIBUTES (vnode->symbol.decl)))\n     return true;\n   if (TARGET_DLLIMPORT_DECL_ATTRIBUTES\n       && lookup_attribute (\"dllexport\",\n-\t\t\t   DECL_ATTRIBUTES (vnode->decl)))\n+\t\t\t   DECL_ATTRIBUTES (vnode->symbol.decl)))\n     return true;\n \n   /* See if we have linker information about symbol not being used or\n@@ -681,7 +691,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n      This is needed for i.e. references from asm statements.   */\n   if (varpool_used_from_object_file_p (vnode))\n     return true;\n-  if (vnode->resolution == LDPR_PREVAILING_DEF_IRONLY)\n+  if (vnode->symbol.resolution == LDPR_PREVAILING_DEF_IRONLY)\n     return false;\n \n   /* As a special case, the COMDAT virutal tables can be unshared.\n@@ -691,13 +701,13 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n      from LTO symbol tables.  */\n   if ((in_lto_p || flag_whole_program)\n       && !vnode->force_output\n-      && DECL_COMDAT (vnode->decl) && DECL_VIRTUAL_P (vnode->decl))\n+      && DECL_COMDAT (vnode->symbol.decl) && DECL_VIRTUAL_P (vnode->symbol.decl))\n     return false;\n \n   /* When doing link time optimizations, hidden symbols become local.  */\n   if (in_lto_p\n-      && (DECL_VISIBILITY (vnode->decl) == VISIBILITY_HIDDEN\n-\t  || DECL_VISIBILITY (vnode->decl) == VISIBILITY_INTERNAL)\n+      && (DECL_VISIBILITY (vnode->symbol.decl) == VISIBILITY_HIDDEN\n+\t  || DECL_VISIBILITY (vnode->symbol.decl) == VISIBILITY_INTERNAL)\n       /* Be sure that node is defined in IR file, not in other object\n \t file.  In that case we don't set used_from_other_object_file.  */\n       && vnode->finalized)\n@@ -712,7 +722,7 @@ varpool_externally_visible_p (struct varpool_node *vnode, bool aliased)\n      FIXME: We can do so for readonly vars with no address taken and\n      possibly also for vtables since no direct pointer comparsion is done.\n      It might be interesting to do so to reduce linking overhead.  */\n-  if (DECL_COMDAT (vnode->decl) || DECL_WEAK (vnode->decl))\n+  if (DECL_COMDAT (vnode->symbol.decl) || DECL_WEAK (vnode->symbol.decl))\n     return true;\n   return false;\n }\n@@ -725,8 +735,8 @@ dissolve_same_comdat_group_list (struct cgraph_node *node)\n   struct cgraph_node *n = node, *next;\n   do\n     {\n-      next = n->same_comdat_group;\n-      n->same_comdat_group = NULL;\n+      next = cgraph (n->symbol.same_comdat_group);\n+      n->symbol.same_comdat_group = NULL;\n       n = next;\n     }\n   while (n != node);\n@@ -762,7 +772,7 @@ function_and_variable_visibility (bool whole_program)\n \t\tIDENTIFIER_POINTER (p->target));\n \t\t\n       if ((node = cgraph_node_for_asm (p->target)) != NULL\n-\t  && !DECL_EXTERNAL (node->decl))\n+\t  && !DECL_EXTERNAL (node->symbol.decl))\n         {\n \t  if (!node->analyzed)\n \t    continue;\n@@ -774,7 +784,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t     cgraph_node_name (node), node->uid);\n         }\n       else if ((vnode = varpool_node_for_asm (p->target)) != NULL\n-\t       && !DECL_EXTERNAL (vnode->decl))\n+\t       && !DECL_EXTERNAL (vnode->symbol.decl))\n         {\n \t  varpool_mark_needed_node (vnode);\n \t  gcc_assert (vnode->needed);\n@@ -789,65 +799,68 @@ function_and_variable_visibility (bool whole_program)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      int flags = flags_from_decl_or_type (node->decl);\n+      int flags = flags_from_decl_or_type (node->symbol.decl);\n \n       /* Optimize away PURE and CONST constructors and destructors.  */\n       if (optimize\n \t  && (flags & (ECF_CONST | ECF_PURE))\n \t  && !(flags & ECF_LOOPING_CONST_OR_PURE))\n \t{\n-\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n-\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t  DECL_STATIC_CONSTRUCTOR (node->symbol.decl) = 0;\n+\t  DECL_STATIC_DESTRUCTOR (node->symbol.decl) = 0;\n \t}\n \n       /* Frontends and alias code marks nodes as needed before parsing is finished.\n \t We may end up marking as node external nodes where this flag is meaningless\n \t strip it.  */\n       if (node->needed\n-\t  && (DECL_EXTERNAL (node->decl) || !node->analyzed))\n+\t  && (DECL_EXTERNAL (node->symbol.decl) || !node->analyzed))\n \tnode->needed = 0;\n \n       /* C++ FE on lack of COMDAT support create local COMDAT functions\n \t (that ought to be shared but can not due to object format\n \t limitations).  It is neccesary to keep the flag to make rest of C++ FE\n \t happy.  Clear the flag here to avoid confusion in middle-end.  */\n-      if (DECL_COMDAT (node->decl) && !TREE_PUBLIC (node->decl))\n-        DECL_COMDAT (node->decl) = 0;\n+      if (DECL_COMDAT (node->symbol.decl) && !TREE_PUBLIC (node->symbol.decl))\n+        DECL_COMDAT (node->symbol.decl) = 0;\n       /* For external decls stop tracking same_comdat_group, it doesn't matter\n \t what comdat group they are in when they won't be emitted in this TU,\n \t and simplifies later passes.  */\n-      if (node->same_comdat_group && DECL_EXTERNAL (node->decl))\n+      if (node->symbol.same_comdat_group && DECL_EXTERNAL (node->symbol.decl))\n \t{\n #ifdef ENABLE_CHECKING\n-\t  struct cgraph_node *n;\n+\t  symtab_node n;\n \n-\t  for (n = node->same_comdat_group;\n-\t       n != node;\n-\t       n = n->same_comdat_group)\n+\t  for (n = node->symbol.same_comdat_group;\n+\t       n != (symtab_node)node;\n+\t       n = n->symbol.same_comdat_group)\n \t      /* If at least one of same comdat group functions is external,\n \t\t all of them have to be, otherwise it is a front-end bug.  */\n-\t      gcc_assert (DECL_EXTERNAL (n->decl));\n+\t      gcc_assert (DECL_EXTERNAL (n->symbol.decl));\n #endif\n \t  dissolve_same_comdat_group_list (node);\n \t}\n-      gcc_assert ((!DECL_WEAK (node->decl) && !DECL_COMDAT (node->decl))\n-      \t          || TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl));\n+      gcc_assert ((!DECL_WEAK (node->symbol.decl)\n+\t\t  && !DECL_COMDAT (node->symbol.decl))\n+      \t          || TREE_PUBLIC (node->symbol.decl)\n+\t\t  || DECL_EXTERNAL (node->symbol.decl));\n       if (cgraph_externally_visible_p (node, whole_program,\n \t\t\t\t       pointer_set_contains (aliased_nodes,\n \t\t\t\t\t\t\t     node)))\n         {\n \t  gcc_assert (!node->global.inlined_to);\n-\t  node->local.externally_visible = true;\n+\t  node->symbol.externally_visible = true;\n \t}\n       else\n-\tnode->local.externally_visible = false;\n-      if (!node->local.externally_visible && node->analyzed\n-\t  && !DECL_EXTERNAL (node->decl))\n+\tnode->symbol.externally_visible = false;\n+      if (!node->symbol.externally_visible && node->analyzed\n+\t  && !DECL_EXTERNAL (node->symbol.decl))\n \t{\n-\t  gcc_assert (whole_program || in_lto_p || !TREE_PUBLIC (node->decl));\n-\t  cgraph_make_decl_local (node->decl);\n-\t  node->resolution = LDPR_PREVAILING_DEF_IRONLY;\n-\t  if (node->same_comdat_group)\n+\t  gcc_assert (whole_program || in_lto_p\n+\t\t      || !TREE_PUBLIC (node->symbol.decl));\n+\t  cgraph_make_decl_local (node->symbol.decl);\n+\t  node->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  if (node->symbol.same_comdat_group)\n \t    /* cgraph_externally_visible_p has already checked all other nodes\n \t       in the group and they will all be made local.  We need to\n \t       dissolve the group at once so that the predicate does not\n@@ -856,33 +869,34 @@ function_and_variable_visibility (bool whole_program)\n \t}\n \n       if (node->thunk.thunk_p\n-\t  && TREE_PUBLIC (node->decl))\n+\t  && TREE_PUBLIC (node->symbol.decl))\n \t{\n \t  struct cgraph_node *decl_node = node;\n \n \t  decl_node = cgraph_function_node (decl_node->callees->callee, NULL);\n \n \t  /* Thunks have the same visibility as function they are attached to.\n \t     Make sure the C++ front end set this up properly.  */\n-\t  if (DECL_ONE_ONLY (decl_node->decl))\n+\t  if (DECL_ONE_ONLY (decl_node->symbol.decl))\n \t    {\n-\t      gcc_checking_assert (DECL_COMDAT (node->decl)\n-\t\t\t\t   == DECL_COMDAT (decl_node->decl));\n-\t      gcc_checking_assert (DECL_COMDAT_GROUP (node->decl)\n-\t\t\t\t   == DECL_COMDAT_GROUP (decl_node->decl));\n-\t      gcc_checking_assert (node->same_comdat_group);\n+\t      gcc_checking_assert (DECL_COMDAT (node->symbol.decl)\n+\t\t\t\t   == DECL_COMDAT (decl_node->symbol.decl));\n+\t      gcc_checking_assert (DECL_COMDAT_GROUP (node->symbol.decl)\n+\t\t\t\t   == DECL_COMDAT_GROUP (decl_node->symbol.decl));\n+\t      gcc_checking_assert (node->symbol.same_comdat_group);\n \t    }\n-\t  if (DECL_EXTERNAL (decl_node->decl))\n-\t    DECL_EXTERNAL (node->decl) = 1;\n+\t  if (DECL_EXTERNAL (decl_node->symbol.decl))\n+\t    DECL_EXTERNAL (node->symbol.decl) = 1;\n \t}\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n     node->local.local = cgraph_local_node_p (node);\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n       /* weak flag makes no sense on local variables.  */\n-      gcc_assert (!DECL_WEAK (vnode->decl)\n-      \t\t  || TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl));\n+      gcc_assert (!DECL_WEAK (vnode->symbol.decl)\n+      \t\t  || TREE_PUBLIC (vnode->symbol.decl)\n+\t\t  || DECL_EXTERNAL (vnode->symbol.decl));\n       /* In several cases declarations can not be common:\n \n \t - when declaration has initializer\n@@ -896,15 +910,16 @@ function_and_variable_visibility (bool whole_program)\n \t     static int a __attribute__ ((common))\n \n \t Canonicalize things here and clear the redundant flag.  */\n-      if (DECL_COMMON (vnode->decl)\n-\t  && (!(TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl))\n-\t      || (DECL_INITIAL (vnode->decl)\n-\t\t  && DECL_INITIAL (vnode->decl) != error_mark_node)\n-\t      || DECL_WEAK (vnode->decl)\n-\t      || DECL_SECTION_NAME (vnode->decl) != NULL\n+      if (DECL_COMMON (vnode->symbol.decl)\n+\t  && (!(TREE_PUBLIC (vnode->symbol.decl)\n+\t      || DECL_EXTERNAL (vnode->symbol.decl))\n+\t      || (DECL_INITIAL (vnode->symbol.decl)\n+\t\t  && DECL_INITIAL (vnode->symbol.decl) != error_mark_node)\n+\t      || DECL_WEAK (vnode->symbol.decl)\n+\t      || DECL_SECTION_NAME (vnode->symbol.decl) != NULL\n \t      || ! (ADDR_SPACE_GENERIC_P\n-\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->decl))))))\n-\tDECL_COMMON (vnode->decl) = 0;\n+\t\t    (TYPE_ADDR_SPACE (TREE_TYPE (vnode->symbol.decl))))))\n+\tDECL_COMMON (vnode->symbol.decl) = 0;\n     }\n   for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n@@ -914,16 +929,16 @@ function_and_variable_visibility (bool whole_program)\n \t  && varpool_externally_visible_p\n \t      (vnode, \n \t       pointer_set_contains (aliased_vnodes, vnode)))\n-\tvnode->externally_visible = true;\n+\tvnode->symbol.externally_visible = true;\n       else\n-        vnode->externally_visible = false;\n-      if (!vnode->externally_visible)\n+        vnode->symbol.externally_visible = false;\n+      if (!vnode->symbol.externally_visible)\n \t{\n-\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n-\t  cgraph_make_decl_local (vnode->decl);\n-\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->symbol.decl));\n+\t  cgraph_make_decl_local (vnode->symbol.decl);\n+\t  vnode->symbol.resolution = LDPR_PREVAILING_DEF_IRONLY;\n \t}\n-     gcc_assert (TREE_STATIC (vnode->decl));\n+     gcc_assert (TREE_STATIC (vnode->symbol.decl));\n     }\n   pointer_set_destroy (aliased_nodes);\n   pointer_set_destroy (aliased_vnodes);\n@@ -937,12 +952,12 @@ function_and_variable_visibility (bool whole_program)\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible functions:\");\n       for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->local.externally_visible)\n+\tif (node->symbol.externally_visible)\n \t  fprintf (dump_file, \" %s\", cgraph_node_name (node));\n       fprintf (dump_file, \"\\n\\n\");\n       fprintf (dump_file, \"\\nMarking externally visible variables:\");\n       for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n-\tif (vnode->externally_visible)\n+\tif (vnode->symbol.externally_visible)\n \t  fprintf (dump_file, \" %s\", varpool_node_name (vnode));\n       fprintf (dump_file, \"\\n\\n\");\n     }\n@@ -998,11 +1013,11 @@ whole_program_function_and_variable_visibility (void)\n   function_and_variable_visibility (flag_whole_program);\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    if ((node->local.externally_visible && !DECL_COMDAT (node->decl))\n+    if ((node->symbol.externally_visible && !DECL_COMDAT (node->symbol.decl))\n         && node->local.finalized)\n       cgraph_mark_needed_node (node);\n   for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n-    if (vnode->externally_visible && !DECL_COMDAT (vnode->decl))\n+    if (vnode->symbol.externally_visible && !DECL_COMDAT (vnode->symbol.decl))\n       varpool_mark_needed_node (vnode);\n   if (dump_file)\n     {\n@@ -1064,30 +1079,30 @@ ipa_profile (void)\n       if (order[i]->local.local && cgraph_propagate_frequency (order[i]))\n \t{\n \t  for (e = order[i]->callees; e; e = e->next_callee)\n-\t    if (e->callee->local.local && !e->callee->aux)\n+\t    if (e->callee->local.local && !e->callee->symbol.aux)\n \t      {\n \t        something_changed = true;\n-\t        e->callee->aux = (void *)1;\n+\t        e->callee->symbol.aux = (void *)1;\n \t      }\n \t}\n-      order[i]->aux = NULL;\n+      order[i]->symbol.aux = NULL;\n     }\n \n   while (something_changed)\n     {\n       something_changed = false;\n       for (i = order_pos - 1; i >= 0; i--)\n \t{\n-\t  if (order[i]->aux && cgraph_propagate_frequency (order[i]))\n+\t  if (order[i]->symbol.aux && cgraph_propagate_frequency (order[i]))\n \t    {\n \t      for (e = order[i]->callees; e; e = e->next_callee)\n-\t\tif (e->callee->local.local && !e->callee->aux)\n+\t\tif (e->callee->local.local && !e->callee->symbol.aux)\n \t\t  {\n \t\t    something_changed = true;\n-\t\t    e->callee->aux = (void *)1;\n+\t\t    e->callee->symbol.aux = (void *)1;\n \t\t  }\n \t    }\n-\t  order[i]->aux = NULL;\n+\t  order[i]->symbol.aux = NULL;\n \t}\n     }\n   free (order);\n@@ -1232,12 +1247,12 @@ static VEC(tree, heap) *static_dtors;\n static void\n record_cdtor_fn (struct cgraph_node *node)\n {\n-  if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-    VEC_safe_push (tree, heap, static_ctors, node->decl);\n-  if (DECL_STATIC_DESTRUCTOR (node->decl))\n-    VEC_safe_push (tree, heap, static_dtors, node->decl);\n-  node = cgraph_get_node (node->decl);\n-  DECL_DISREGARD_INLINE_LIMITS (node->decl) = 1;\n+  if (DECL_STATIC_CONSTRUCTOR (node->symbol.decl))\n+    VEC_safe_push (tree, heap, static_ctors, node->symbol.decl);\n+  if (DECL_STATIC_DESTRUCTOR (node->symbol.decl))\n+    VEC_safe_push (tree, heap, static_dtors, node->symbol.decl);\n+  node = cgraph_get_node (node->symbol.decl);\n+  DECL_DISREGARD_INLINE_LIMITS (node->symbol.decl) = 1;\n }\n \n /* Define global constructors/destructor functions for the CDTORS, of\n@@ -1392,8 +1407,8 @@ ipa_cdtor_merge (void)\n   struct cgraph_node *node;\n   for (node = cgraph_nodes; node; node = node->next)\n     if (node->analyzed\n-\t&& (DECL_STATIC_CONSTRUCTOR (node->decl)\n-\t    || DECL_STATIC_DESTRUCTOR (node->decl)))\n+\t&& (DECL_STATIC_CONSTRUCTOR (node->symbol.decl)\n+\t    || DECL_STATIC_DESTRUCTOR (node->symbol.decl)))\n        record_cdtor_fn (node);\n   build_cdtor_fns ();\n   VEC_free (tree, heap, static_ctors);"}, {"sha": "69ddb0637b8ac6264108a85af3dece9f0e2dca33", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 92, "deletions": 87, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -290,7 +290,7 @@ lto_output_edge (struct lto_simple_output_block *ob, struct cgraph_edge *edge,\n   streamer_write_hwi_stream (ob->main_stream, edge->count);\n \n   bp = bitpack_create (ob->main_stream);\n-  uid = (!gimple_has_body_p (edge->caller->decl)\n+  uid = (!gimple_has_body_p (edge->caller->symbol.decl)\n \t ? edge->lto_stmt_uid : gimple_uid (edge->call_stmt));\n   bp_pack_enum (&bp, cgraph_inline_failed_enum,\n \t        CIF_N_REASONS, edge->inline_failed);\n@@ -330,13 +330,13 @@ referenced_from_other_partition_p (struct ipa_ref_list *list, cgraph_node_set se\n     {\n       if (ref->refering_type == IPA_REF_CGRAPH)\n \t{\n-\t  if (ipa_ref_refering_node (ref)->in_other_partition\n+\t  if (ipa_ref_refering_node (ref)->symbol.in_other_partition\n \t      || !cgraph_node_in_set_p (ipa_ref_refering_node (ref), set))\n \t    return true;\n \t}\n       else\n \t{\n-\t  if (ipa_ref_refering_varpool_node (ref)->in_other_partition\n+\t  if (ipa_ref_refering_varpool_node (ref)->symbol.in_other_partition\n \t      || !varpool_node_in_set_p (ipa_ref_refering_varpool_node (ref),\n \t\t\t\t         vset))\n \t    return true;\n@@ -356,7 +356,7 @@ reachable_from_other_partition_p (struct cgraph_node *node, cgraph_node_set set)\n   if (node->global.inlined_to)\n     return false;\n   for (e = node->callers; e; e = e->next_caller)\n-    if (e->caller->in_other_partition\n+    if (e->caller->symbol.in_other_partition\n \t|| !cgraph_node_in_set_p (e->caller, set))\n       return true;\n   return false;\n@@ -428,7 +428,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   streamer_write_enum (ob->main_stream, LTO_cgraph_tags, LTO_cgraph_last_tag,\n \t\t       tag);\n-  streamer_write_hwi_stream (ob->main_stream, node->order);\n+  streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n \n   /* In WPA mode, we only output part of the call-graph.  Also, we\n      fake cgraph node attributes.  There are two cases that we care.\n@@ -469,7 +469,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n     streamer_write_hwi_stream (ob->main_stream, ref);\n \n \n-  lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->decl);\n+  lto_output_fn_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n   streamer_write_hwi_stream (ob->main_stream, node->count);\n   streamer_write_hwi_stream (ob->main_stream, node->count_materialization_scale);\n \n@@ -486,9 +486,10 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_hwi_stream (ob->main_stream, ref);\n     }\n \n-  if (node->same_comdat_group && !boundary_p)\n+  if (node->symbol.same_comdat_group && !boundary_p)\n     {\n-      ref = lto_cgraph_encoder_lookup (encoder, node->same_comdat_group);\n+      ref = lto_cgraph_encoder_lookup (encoder,\n+\t\t\t\t       cgraph (node->symbol.same_comdat_group));\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n@@ -497,19 +498,20 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   bp = bitpack_create (ob->main_stream);\n   bp_pack_value (&bp, node->local.local, 1);\n-  bp_pack_value (&bp, node->local.externally_visible, 1);\n+  bp_pack_value (&bp, node->symbol.externally_visible, 1);\n   bp_pack_value (&bp, node->local.finalized, 1);\n   bp_pack_value (&bp, node->local.versionable, 1);\n   bp_pack_value (&bp, node->local.can_change_signature, 1);\n   bp_pack_value (&bp, node->local.redefined_extern_inline, 1);\n   bp_pack_value (&bp, node->needed, 1);\n-  bp_pack_value (&bp, node->address_taken, 1);\n+  bp_pack_value (&bp, node->symbol.address_taken, 1);\n   bp_pack_value (&bp, node->abstract_and_needed, 1);\n   bp_pack_value (&bp, tag == LTO_cgraph_analyzed_node\n-\t\t && !DECL_EXTERNAL (node->decl)\n-\t\t && !DECL_COMDAT (node->decl)\n+\t\t && !DECL_EXTERNAL (node->symbol.decl)\n+\t\t && !DECL_COMDAT (node->symbol.decl)\n \t\t && (reachable_from_other_partition_p (node, set)\n-\t\t     || referenced_from_other_partition_p (&node->ref_list, set, vset)), 1);\n+\t\t     || referenced_from_other_partition_p (&node->symbol.ref_list,\n+\t\t\t\t\t\t\t   set, vset)), 1);\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n   /* Real aliases in a boundary become non-aliases. However we still stream\n@@ -518,14 +520,14 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n      defined in other unit, we may use the info on aliases to resolve \n      symbol1 != symbol2 type tests that we can do only for locally defined objects\n      otherwise.  */\n-  bp_pack_value (&bp, node->alias && (!boundary_p || DECL_EXTERNAL (node->decl)), 1);\n+  bp_pack_value (&bp, node->alias && (!boundary_p || DECL_EXTERNAL (node->symbol.decl)), 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n   bp_pack_value (&bp, node->only_called_at_exit, 1);\n   bp_pack_value (&bp, node->tm_clone, 1);\n   bp_pack_value (&bp, node->thunk.thunk_p && !boundary_p, 1);\n   bp_pack_enum (&bp, ld_plugin_symbol_resolution,\n-\t        LDPR_NUM_KNOWN, node->resolution);\n+\t        LDPR_NUM_KNOWN, node->symbol.resolution);\n   streamer_write_bitpack (&bp);\n \n   if (node->thunk.thunk_p && !boundary_p)\n@@ -538,7 +540,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n       streamer_write_uhwi_stream (ob->main_stream, node->thunk.virtual_value);\n     }\n   if ((node->alias || node->thunk.thunk_p)\n-      && (!boundary_p || (node->alias && DECL_EXTERNAL (node->decl))))\n+      && (!boundary_p || (node->alias && DECL_EXTERNAL (node->symbol.decl))))\n     {\n       streamer_write_hwi_in_range (ob->main_stream, 0, 1,\n \t\t\t\t\tnode->thunk.alias != NULL);\n@@ -560,10 +562,10 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   struct bitpack_d bp;\n   int ref;\n \n-  streamer_write_hwi_stream (ob->main_stream, node->order);\n-  lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->decl);\n+  streamer_write_hwi_stream (ob->main_stream, node->symbol.order);\n+  lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->symbol.decl);\n   bp = bitpack_create (ob->main_stream);\n-  bp_pack_value (&bp, node->externally_visible, 1);\n+  bp_pack_value (&bp, node->symbol.externally_visible, 1);\n   bp_pack_value (&bp, node->force_output, 1);\n   bp_pack_value (&bp, node->finalized, 1);\n   bp_pack_value (&bp, node->alias, 1);\n@@ -573,32 +575,33 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, struct varpool_node\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n      labels and share them across LTRANS partitions.  */\n-  if (DECL_IN_CONSTANT_POOL (node->decl)\n-      && !DECL_COMDAT (node->decl))\n+  if (DECL_IN_CONSTANT_POOL (node->symbol.decl)\n+      && !DECL_COMDAT (node->symbol.decl))\n     {\n       bp_pack_value (&bp, 0, 1);  /* used_from_other_parition.  */\n       bp_pack_value (&bp, 0, 1);  /* in_other_partition.  */\n     }\n   else\n     {\n       bp_pack_value (&bp, node->analyzed\n-\t\t     && referenced_from_other_partition_p (&node->ref_list,\n+\t\t     && referenced_from_other_partition_p (&node->symbol.ref_list,\n \t\t\t\t\t\t\t   set, vset), 1);\n       bp_pack_value (&bp, boundary_p, 1);  /* in_other_partition.  */\n     }\n   streamer_write_bitpack (&bp);\n   if (node->alias_of)\n     lto_output_var_decl_index (ob->decl_state, ob->main_stream, node->alias_of);\n-  if (node->same_comdat_group && !boundary_p)\n+  if (node->symbol.same_comdat_group && !boundary_p)\n     {\n-      ref = lto_varpool_encoder_lookup (varpool_encoder, node->same_comdat_group);\n+      ref = lto_varpool_encoder_lookup (varpool_encoder,\n+\t\t\t\t\tvarpool (node->symbol.same_comdat_group));\n       gcc_assert (ref != LCC_NOT_FOUND);\n     }\n   else\n     ref = LCC_NOT_FOUND;\n   streamer_write_hwi_stream (ob->main_stream, ref);\n   streamer_write_enum (ob->main_stream, ld_plugin_symbol_resolution,\n-\t\t       LDPR_NUM_KNOWN, node->resolution);\n+\t\t       LDPR_NUM_KNOWN, node->symbol.resolution);\n }\n \n /* Output the varpool NODE to OB. \n@@ -719,13 +722,14 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n     {\n       struct cgraph_node *node = csi_node (csi);\n \n-      count = ipa_ref_list_nreferences (&node->ref_list);\n+      count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n       if (count)\n \t{\n \t  streamer_write_uhwi_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_cgraph_encoder_lookup (encoder, node));\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t\t      i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n \t}\n     }\n@@ -736,14 +740,15 @@ output_refs (cgraph_node_set set, varpool_node_set vset,\n     {\n       struct varpool_node *node = vsi_node (vsi);\n \n-      count = ipa_ref_list_nreferences (&node->ref_list);\n+      count = ipa_ref_list_nreferences (&node->symbol.ref_list);\n       if (count)\n \t{\n \t  streamer_write_uhwi_stream (ob->main_stream, count);\n \t  streamer_write_uhwi_stream (ob->main_stream,\n \t\t\t\t     lto_varpool_encoder_lookup (varpool_encoder,\n \t\t\t\t\t\t\t\t node));\n-\t  for (i = 0; ipa_ref_list_reference_iterate (&node->ref_list, i, ref); i++)\n+\t  for (i = 0; ipa_ref_list_reference_iterate (&node->symbol.ref_list,\n+\t\t\t\t\t\t      i, ref); i++)\n \t    lto_output_ref (ob, ref, encoder, varpool_encoder);\n \t}\n     }\n@@ -775,32 +780,32 @@ compute_ltrans_boundary (struct lto_out_decl_state *state,\n     {\n       node = csi_node (csi);\n       add_node_to (encoder, node, true);\n-      add_references (encoder, varpool_encoder, &node->ref_list);\n+      add_references (encoder, varpool_encoder, &node->symbol.ref_list);\n     }\n   for (vsi = vsi_start (vset); !vsi_end_p (vsi); vsi_next (&vsi))\n     {\n       struct varpool_node *vnode = vsi_node (vsi);\n       gcc_assert (!vnode->alias || vnode->alias_of);\n       lto_varpool_encoder_encode (varpool_encoder, vnode);\n       lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n-      add_references (encoder, varpool_encoder, &vnode->ref_list);\n+      add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n     }\n   /* Pickle in also the initializer of all referenced readonly variables\n      to help folding.  Constant pool variables are not shared, so we must\n      pickle those too.  */\n   for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n     {\n       struct varpool_node *vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n-      if (DECL_INITIAL (vnode->decl)\n+      if (DECL_INITIAL (vnode->symbol.decl)\n \t  && !lto_varpool_encoder_encode_initializer_p (varpool_encoder,\n \t\t\t\t\t\t        vnode)\n-\t  && const_value_known_p (vnode->decl))\n+\t  && const_value_known_p (vnode->symbol.decl))\n \t{\n \t  lto_set_varpool_encoder_encode_initializer (varpool_encoder, vnode);\n-\t  add_references (encoder, varpool_encoder, &vnode->ref_list);\n+\t  add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n \t}\n       else if (vnode->alias || vnode->alias_of)\n-        add_references (encoder, varpool_encoder, &vnode->ref_list);\n+        add_references (encoder, varpool_encoder, &vnode->symbol.ref_list);\n     }\n \n   /* Go over all the nodes again to include callees that are not in\n@@ -897,23 +902,23 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t\t      enum LTO_cgraph_tags tag,\n \t\t      struct bitpack_d *bp)\n {\n-  node->aux = (void *) tag;\n-  node->local.lto_file_data = file_data;\n+  node->symbol.aux = (void *) tag;\n+  node->symbol.lto_file_data = file_data;\n \n   node->local.local = bp_unpack_value (bp, 1);\n-  node->local.externally_visible = bp_unpack_value (bp, 1);\n+  node->symbol.externally_visible = bp_unpack_value (bp, 1);\n   node->local.finalized = bp_unpack_value (bp, 1);\n   node->local.versionable = bp_unpack_value (bp, 1);\n   node->local.can_change_signature = bp_unpack_value (bp, 1);\n   node->local.redefined_extern_inline = bp_unpack_value (bp, 1);\n   node->needed = bp_unpack_value (bp, 1);\n-  node->address_taken = bp_unpack_value (bp, 1);\n+  node->symbol.address_taken = bp_unpack_value (bp, 1);\n   node->abstract_and_needed = bp_unpack_value (bp, 1);\n-  node->reachable_from_other_partition = bp_unpack_value (bp, 1);\n+  node->symbol.used_from_other_partition = bp_unpack_value (bp, 1);\n   node->lowered = bp_unpack_value (bp, 1);\n   node->analyzed = tag == LTO_cgraph_analyzed_node;\n-  node->in_other_partition = bp_unpack_value (bp, 1);\n-  if (node->in_other_partition\n+  node->symbol.in_other_partition = bp_unpack_value (bp, 1);\n+  if (node->symbol.in_other_partition\n       /* Avoid updating decl when we are seeing just inline clone.\n \t When inlining function that has functions already inlined into it,\n \t we produce clones of inline clones.\n@@ -922,18 +927,18 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n \t we might end up streaming inline clone from other partition\n \t to support clone we are interested in. */\n       && (!node->clone_of\n-\t  || node->clone_of->decl != node->decl))\n+\t  || node->clone_of->symbol.decl != node->symbol.decl))\n     {\n-      DECL_EXTERNAL (node->decl) = 1;\n-      TREE_STATIC (node->decl) = 0;\n+      DECL_EXTERNAL (node->symbol.decl) = 1;\n+      TREE_STATIC (node->symbol.decl) = 0;\n     }\n   node->alias = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n   node->only_called_at_exit = bp_unpack_value (bp, 1);\n   node->tm_clone = bp_unpack_value (bp, 1);\n   node->thunk.thunk_p = bp_unpack_value (bp, 1);\n-  node->resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n+  node->symbol.resolution = bp_unpack_enum (bp, ld_plugin_symbol_resolution,\n \t\t\t\t     LDPR_NUM_KNOWN);\n }\n \n@@ -992,7 +997,7 @@ input_node (struct lto_file_decl_data *file_data,\n   else\n     node = cgraph_get_create_node (fn_decl);\n \n-  node->order = order;\n+  node->symbol.order = order;\n   if (order >= cgraph_order)\n     cgraph_order = order + 1;\n \n@@ -1008,7 +1013,7 @@ input_node (struct lto_file_decl_data *file_data,\n      have already been read will have their tag stored in the 'aux'\n      field.  Since built-in functions can be referenced in multiple\n      functions, they are expected to be read more than once.  */\n-  if (node->aux && !DECL_BUILT_IN (node->decl))\n+  if (node->symbol.aux && !DECL_BUILT_IN (node->symbol.decl))\n     internal_error (\"bytecode stream: found multiple instances of cgraph \"\n \t\t    \"node %d\", node->uid);\n \n@@ -1019,7 +1024,7 @@ input_node (struct lto_file_decl_data *file_data,\n   node->global.inlined_to = (cgraph_node_ptr) (intptr_t) ref;\n \n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (cgraph_node_ptr) (intptr_t) ref2;\n+  node->symbol.same_comdat_group = (symtab_node) (intptr_t) ref2;\n \n   if (node->thunk.thunk_p)\n     {\n@@ -1063,24 +1068,24 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   decl_index = streamer_read_uhwi (ib);\n   var_decl = lto_file_decl_data_get_var_decl (file_data, decl_index);\n   node = varpool_node (var_decl);\n-  node->order = order;\n+  node->symbol.order = order;\n   if (order >= cgraph_order)\n     cgraph_order = order + 1;\n-  node->lto_file_data = file_data;\n+  node->symbol.lto_file_data = file_data;\n \n   bp = streamer_read_bitpack (ib);\n-  node->externally_visible = bp_unpack_value (&bp, 1);\n+  node->symbol.externally_visible = bp_unpack_value (&bp, 1);\n   node->force_output = bp_unpack_value (&bp, 1);\n   node->finalized = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n   non_null_aliasof = bp_unpack_value (&bp, 1);\n   node->analyzed = node->finalized; \n-  node->used_from_other_partition = bp_unpack_value (&bp, 1);\n-  node->in_other_partition = bp_unpack_value (&bp, 1);\n-  if (node->in_other_partition)\n+  node->symbol.used_from_other_partition = bp_unpack_value (&bp, 1);\n+  node->symbol.in_other_partition = bp_unpack_value (&bp, 1);\n+  if (node->symbol.in_other_partition)\n     {\n-      DECL_EXTERNAL (node->decl) = 1;\n-      TREE_STATIC (node->decl) = 0;\n+      DECL_EXTERNAL (node->symbol.decl) = 1;\n+      TREE_STATIC (node->symbol.decl) = 0;\n     }\n   if (node->finalized)\n     varpool_mark_needed_node (node);\n@@ -1091,9 +1096,9 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n     }\n   ref = streamer_read_hwi (ib);\n   /* Store a reference for now, and fix up later to be a pointer.  */\n-  node->same_comdat_group = (struct varpool_node *) (intptr_t) ref;\n-  node->resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n-\t\t\t\t\t LDPR_NUM_KNOWN);\n+  node->symbol.same_comdat_group = (symtab_node) (intptr_t) ref;\n+  node->symbol.resolution = streamer_read_enum (ib, ld_plugin_symbol_resolution,\n+\t\t\t\t\t        LDPR_NUM_KNOWN);\n \n   return node;\n }\n@@ -1106,7 +1111,7 @@ input_ref (struct lto_input_block *ib,\n \t   struct cgraph_node *refering_node,\n \t   struct varpool_node *refering_varpool_node,\n \t   VEC(cgraph_node_ptr, heap) *nodes,\n-\t   VEC(varpool_node_ptr, heap) *varpool_nodes)\n+\t   VEC(varpool_node_ptr, heap) *varpool_nodes_vec)\n {\n   struct cgraph_node *node = NULL;\n   struct varpool_node *varpool_node = NULL;\n@@ -1120,7 +1125,7 @@ input_ref (struct lto_input_block *ib,\n   if (type == IPA_REF_CGRAPH)\n     node = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n   else\n-    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes,\n+    varpool_node = VEC_index (varpool_node_ptr, varpool_nodes_vec,\n \t\t\t      streamer_read_hwi (ib));\n   ipa_record_reference (refering_node, refering_varpool_node,\n \t\t        node, varpool_node, use, NULL);\n@@ -1145,13 +1150,13 @@ input_edge (struct lto_input_block *ib, VEC(cgraph_node_ptr, heap) *nodes,\n   int ecf_flags = 0;\n \n   caller = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n-  if (caller == NULL || caller->decl == NULL_TREE)\n+  if (caller == NULL || caller->symbol.decl == NULL_TREE)\n     internal_error (\"bytecode stream: no caller found while reading edge\");\n \n   if (!indirect)\n     {\n       callee = VEC_index (cgraph_node_ptr, nodes, streamer_read_hwi (ib));\n-      if (callee == NULL || callee->decl == NULL_TREE)\n+      if (callee == NULL || callee->symbol.decl == NULL_TREE)\n \tinternal_error (\"bytecode stream: no callee found while reading edge\");\n     }\n   else\n@@ -1215,7 +1220,7 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n       else\n \t{\n \t  node = input_node (file_data, ib, tag,nodes);\n-\t  if (node == NULL || node->decl == NULL_TREE)\n+\t  if (node == NULL || node->symbol.decl == NULL_TREE)\n \t    internal_error (\"bytecode stream: found empty cgraph node\");\n \t  VEC_safe_push (cgraph_node_ptr, heap, nodes, node);\n \t  lto_cgraph_encoder_encode (file_data->cgraph_node_encoder, node);\n@@ -1229,33 +1234,33 @@ input_cgraph_1 (struct lto_file_decl_data *file_data,\n   /* AUX pointers should be all non-zero for nodes read from the stream.  */\n #ifdef ENABLE_CHECKING\n   FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n-    gcc_assert (node->aux);\n+    gcc_assert (node->symbol.aux);\n #endif\n   FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n     {\n       int ref = (int) (intptr_t) node->global.inlined_to;\n \n       /* We share declaration of builtins, so we may read same node twice.  */\n-      if (!node->aux)\n+      if (!node->symbol.aux)\n \tcontinue;\n-      node->aux = NULL;\n+      node->symbol.aux = NULL;\n \n       /* Fixup inlined_to from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n \tnode->global.inlined_to = VEC_index (cgraph_node_ptr, nodes, ref);\n       else\n \tnode->global.inlined_to = NULL;\n \n-      ref = (int) (intptr_t) node->same_comdat_group;\n+      ref = (int) (intptr_t) node->symbol.same_comdat_group;\n \n       /* Fixup same_comdat_group from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n-\tnode->same_comdat_group = VEC_index (cgraph_node_ptr, nodes, ref);\n+\tnode->symbol.same_comdat_group = (symtab_node)VEC_index (cgraph_node_ptr, nodes, ref);\n       else\n-\tnode->same_comdat_group = NULL;\n+\tnode->symbol.same_comdat_group = NULL;\n     }\n   FOR_EACH_VEC_ELT (cgraph_node_ptr, nodes, i, node)\n-    node->aux = (void *)1;\n+    node->symbol.aux = (void *)1;\n   return nodes;\n }\n \n@@ -1279,24 +1284,24 @@ input_varpool_1 (struct lto_file_decl_data *file_data,\n     }\n #ifdef ENABLE_CHECKING\n   FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n-    gcc_assert (!node->aux);\n+    gcc_assert (!node->symbol.aux);\n #endif\n   FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n     {\n-      int ref = (int) (intptr_t) node->same_comdat_group;\n+      int ref = (int) (intptr_t) node->symbol.same_comdat_group;\n       /* We share declaration of builtins, so we may read same node twice.  */\n-      if (node->aux)\n+      if (node->symbol.aux)\n \tcontinue;\n-      node->aux = (void *)1;\n+      node->symbol.aux = (void *)1;\n \n       /* Fixup same_comdat_group from reference to pointer.  */\n       if (ref != LCC_NOT_FOUND)\n-\tnode->same_comdat_group = VEC_index (varpool_node_ptr, varpool, ref);\n+\tnode->symbol.same_comdat_group = (symtab_node)VEC_index (varpool_node_ptr, varpool, ref);\n       else\n-\tnode->same_comdat_group = NULL;\n+\tnode->symbol.same_comdat_group = NULL;\n     }\n   FOR_EACH_VEC_ELT (varpool_node_ptr, varpool, i, node)\n-    node->aux = NULL;\n+    node->symbol.aux = NULL;\n   return varpool;\n }\n \n@@ -1418,15 +1423,15 @@ merge_profile_summaries (struct lto_file_decl_data **file_data_vec)\n      During LTRANS we already have values of count_materialization_scale\n      computed, so just update them.  */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (node->local.lto_file_data\n-\t&& node->local.lto_file_data->profile_info.runs)\n+    if (node->symbol.lto_file_data\n+\t&& node->symbol.lto_file_data->profile_info.runs)\n       {\n \tint scale;\n \n \tscale =\n \t   ((node->count_materialization_scale * max_runs\n-\t     + node->local.lto_file_data->profile_info.runs / 2)\n-\t    / node->local.lto_file_data->profile_info.runs);\n+\t     + node->symbol.lto_file_data->profile_info.runs / 2)\n+\t    / node->symbol.lto_file_data->profile_info.runs);\n \tnode->count_materialization_scale = scale;\n \tif (scale < 0)\n \t  fatal_error (\"Profile information in %s corrupted\",\n@@ -1503,8 +1508,8 @@ input_cgraph (void)\n \t node for the parent function was never emitted to the gimple\n \t file, cgraph_node will create a node for it when setting the\n \t context of the nested function.  */\n-      if (node->local.lto_file_data)\n-\tnode->aux = NULL;\n+      if (node->symbol.lto_file_data)\n+\tnode->symbol.aux = NULL;\n     }\n }\n \n@@ -1564,7 +1569,7 @@ output_node_opt_summary (struct output_block *ob,\n       int parm_num;\n       tree parm;\n \n-      for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm;\n+      for (parm_num = 0, parm = DECL_ARGUMENTS (node->symbol.decl); parm;\n \t   parm = DECL_CHAIN (parm), parm_num++)\n \tif (map->old_tree == parm)\n \t  break;\n@@ -1666,7 +1671,7 @@ input_node_opt_summary (struct cgraph_node *node,\n       struct ipa_replace_map *map = ggc_alloc_ipa_replace_map ();\n \n       VEC_safe_push (ipa_replace_map_p, gc, node->clone.tree_map, map);\n-      for (parm_num = 0, parm = DECL_ARGUMENTS (node->decl); parm_num;\n+      for (parm_num = 0, parm = DECL_ARGUMENTS (node->symbol.decl); parm_num;\n \t   parm = DECL_CHAIN (parm))\n \tparm_num --;\n       map->parm_num = streamer_read_uhwi (ib_main);"}, {"sha": "fa6a3dcd73d764651909317354ce0e64b06d95ca", "filename": "gcc/lto-streamer-out.c", "status": "modified", "additions": 27, "deletions": 25, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-streamer-out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-streamer-out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-streamer-out.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -784,7 +784,7 @@ output_function (struct cgraph_node *node)\n   basic_block bb;\n   struct output_block *ob;\n \n-  function = node->decl;\n+  function = node->symbol.decl;\n   fn = DECL_STRUCT_FUNCTION (function);\n   ob = create_output_block (LTO_section_function_body);\n \n@@ -904,11 +904,13 @@ output_alias_pair_p (alias_pair *p, symbol_alias_set_t *defined,\n \t{\n \t  vnode = varpool_get_node (p->decl);\n \t  return (vnode\n-\t\t  && referenced_from_this_partition_p (&vnode->ref_list, set, vset));\n+\t\t  && referenced_from_this_partition_p (&vnode->symbol.ref_list,\n+\t\t\t\t\t\t      set, vset));\n \t}\n       node = cgraph_get_node (p->decl);\n       return (node\n-\t      && (referenced_from_this_partition_p (&node->ref_list, set, vset)\n+\t      && (referenced_from_this_partition_p (&node->symbol.ref_list,\n+\t\t\t\t\t\t    set, vset)\n \t\t  || reachable_from_this_partition_p (node, set)));\n     }\n   else\n@@ -1023,8 +1025,8 @@ lto_output_toplevel_asms (void)\n static void\n copy_function (struct cgraph_node *node)\n {\n-  tree function = node->decl;\n-  struct lto_file_decl_data *file_data = node->local.lto_file_data;\n+  tree function = node->symbol.decl;\n+  struct lto_file_decl_data *file_data = node->symbol.lto_file_data;\n   struct lto_output_stream *output_stream = XCNEW (struct lto_output_stream);\n   const char *data;\n   size_t len;\n@@ -1051,7 +1053,7 @@ copy_function (struct cgraph_node *node)\n \n   /* Copy decls. */\n   in_state =\n-    lto_get_function_in_decl_state (node->local.lto_file_data, function);\n+    lto_get_function_in_decl_state (node->symbol.lto_file_data, function);\n   gcc_assert (in_state);\n \n   for (i = 0; i < LTO_N_DECL_STREAMS; i++)\n@@ -1102,18 +1104,18 @@ lto_output (cgraph_node_set set, varpool_node_set vset)\n \t  && !node->thunk.thunk_p)\n \t{\n #ifdef ENABLE_CHECKING\n-\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->decl)));\n-\t  bitmap_set_bit (output, DECL_UID (node->decl));\n+\t  gcc_assert (!bitmap_bit_p (output, DECL_UID (node->symbol.decl)));\n+\t  bitmap_set_bit (output, DECL_UID (node->symbol.decl));\n #endif\n \t  decl_state = lto_new_out_decl_state ();\n \t  lto_push_out_decl_state (decl_state);\n-\t  if (gimple_has_body_p (node->decl))\n+\t  if (gimple_has_body_p (node->symbol.decl))\n \t    output_function (node);\n \t  else\n \t    copy_function (node);\n \t  gcc_assert (lto_get_out_decl_state () == decl_state);\n \t  lto_pop_out_decl_state ();\n-\t  lto_record_function_out_decl_state (node->decl, decl_state);\n+\t  lto_record_function_out_decl_state (node->symbol.decl, decl_state);\n \t}\n     }\n \n@@ -1417,64 +1419,64 @@ produce_symtab (struct output_block *ob,\n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n-      if (DECL_EXTERNAL (node->decl))\n+      if (DECL_EXTERNAL (node->symbol.decl))\n \tcontinue;\n-      if (DECL_COMDAT (node->decl)\n+      if (DECL_COMDAT (node->symbol.decl)\n \t  && cgraph_comdat_can_be_unshared_p (node))\n \tcontinue;\n       if ((node->alias && !node->thunk.alias) || node->global.inlined_to)\n \tcontinue;\n-      write_symbol (cache, &stream, node->decl, seen, false);\n+      write_symbol (cache, &stream, node->symbol.decl, seen, false);\n     }\n   for (i = 0; i < lto_cgraph_encoder_size (encoder); i++)\n     {\n       node = lto_cgraph_encoder_deref (encoder, i);\n-      if (!DECL_EXTERNAL (node->decl))\n+      if (!DECL_EXTERNAL (node->symbol.decl))\n \tcontinue;\n       /* We keep around unused extern inlines in order to be able to inline\n \t them indirectly or via vtables.  Do not output them to symbol\n \t table: they end up being undefined and just consume space.  */\n-      if (!node->address_taken && !node->callers)\n+      if (!node->symbol.address_taken && !node->callers)\n \tcontinue;\n-      if (DECL_COMDAT (node->decl)\n+      if (DECL_COMDAT (node->symbol.decl)\n \t  && cgraph_comdat_can_be_unshared_p (node))\n \tcontinue;\n       if ((node->alias && !node->thunk.alias) || node->global.inlined_to)\n \tcontinue;\n-      write_symbol (cache, &stream, node->decl, seen, false);\n+      write_symbol (cache, &stream, node->symbol.decl, seen, false);\n     }\n \n   /* Write all variables.  */\n   for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n     {\n       vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n-      if (DECL_EXTERNAL (vnode->decl))\n+      if (DECL_EXTERNAL (vnode->symbol.decl))\n \tcontinue;\n       /* COMDAT virtual tables can be unshared.  Do not declare them\n \t in the LTO symbol table to prevent linker from forcing them\n \t into the output. */\n-      if (DECL_COMDAT (vnode->decl)\n+      if (DECL_COMDAT (vnode->symbol.decl)\n \t  && !vnode->force_output\n \t  && vnode->finalized \n-\t  && DECL_VIRTUAL_P (vnode->decl))\n+\t  && DECL_VIRTUAL_P (vnode->symbol.decl))\n \tcontinue;\n       if (vnode->alias && !vnode->alias_of)\n \tcontinue;\n-      write_symbol (cache, &stream, vnode->decl, seen, false);\n+      write_symbol (cache, &stream, vnode->symbol.decl, seen, false);\n     }\n   for (i = 0; i < lto_varpool_encoder_size (varpool_encoder); i++)\n     {\n       vnode = lto_varpool_encoder_deref (varpool_encoder, i);\n-      if (!DECL_EXTERNAL (vnode->decl))\n+      if (!DECL_EXTERNAL (vnode->symbol.decl))\n \tcontinue;\n-      if (DECL_COMDAT (vnode->decl)\n+      if (DECL_COMDAT (vnode->symbol.decl)\n \t  && !vnode->force_output\n \t  && vnode->finalized \n-\t  && DECL_VIRTUAL_P (vnode->decl))\n+\t  && DECL_VIRTUAL_P (vnode->symbol.decl))\n \tcontinue;\n       if (vnode->alias && !vnode->alias_of)\n \tcontinue;\n-      write_symbol (cache, &stream, vnode->decl, seen, false);\n+      write_symbol (cache, &stream, vnode->symbol.decl, seen, false);\n     }\n \n   /* Write all aliases.  */"}, {"sha": "7d77f3565fe75e9ef64f774b042c518ce1907287", "filename": "gcc/lto-symtab.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-symtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto-symtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-symtab.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -219,24 +219,24 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \t       cgraph_node_name (prevailing_node),\n \t       prevailing_node->uid,\n \t       IDENTIFIER_POINTER ((*targetm.asm_out.mangle_assembler_name)\n-\t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)))));\n+\t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->symbol.decl)))));\n     }\n \n   /* Merge node flags.  */\n   if (node->needed)\n     cgraph_mark_needed_node (prevailing_node);\n   if (node->reachable)\n     cgraph_mark_reachable_node (prevailing_node);\n-  if (node->address_taken)\n+  if (node->symbol.address_taken)\n     {\n       gcc_assert (!prevailing_node->global.inlined_to);\n       cgraph_mark_address_taken_node (prevailing_node);\n     }\n \n   /* Redirect all incoming edges.  */\n   compatible_p\n-    = types_compatible_p (TREE_TYPE (TREE_TYPE (prevailing_node->decl)),\n-\t\t\t  TREE_TYPE (TREE_TYPE (node->decl)));\n+    = types_compatible_p (TREE_TYPE (TREE_TYPE (prevailing_node->symbol.decl)),\n+\t\t\t  TREE_TYPE (TREE_TYPE (node->symbol.decl)));\n   for (e = node->callers; e; e = next)\n     {\n       next = e->next_caller;\n@@ -249,7 +249,7 @@ lto_cgraph_replace_node (struct cgraph_node *node,\n \te->call_stmt_cannot_inline_p = 1;\n     }\n   /* Redirect incomming references.  */\n-  ipa_clone_refering (prevailing_node, NULL, &node->ref_list);\n+  ipa_clone_refering (prevailing_node, NULL, &node->symbol.ref_list);\n \n   /* Finally remove the replaced node.  */\n   cgraph_remove_node (node);\n@@ -271,11 +271,11 @@ lto_varpool_replace_node (struct varpool_node *vnode,\n   gcc_assert (!vnode->finalized || prevailing_node->finalized);\n   gcc_assert (!vnode->analyzed || prevailing_node->analyzed);\n \n-  ipa_clone_refering (NULL, prevailing_node, &vnode->ref_list);\n+  ipa_clone_refering (NULL, prevailing_node, &vnode->symbol.ref_list);\n \n   /* Be sure we can garbage collect the initializer.  */\n-  if (DECL_INITIAL (vnode->decl))\n-    DECL_INITIAL (vnode->decl) = error_mark_node;\n+  if (DECL_INITIAL (vnode->symbol.decl))\n+    DECL_INITIAL (vnode->symbol.decl) = error_mark_node;\n   /* Finally remove the replaced node.  */\n   varpool_remove_node (vnode);\n }\n@@ -693,9 +693,9 @@ lto_symtab_merge_decls_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n      First one would disable some whole program optimizations, while\n      ther second would imply to many whole program assumptions.  */\n   if (prevailing->node && !flag_ltrans && !prevailing->guessed)\n-    prevailing->node->resolution = prevailing->resolution;\n+    prevailing->node->symbol.resolution = prevailing->resolution;\n   else if (prevailing->vnode && !flag_ltrans && !prevailing->guessed)\n-    prevailing->vnode->resolution = prevailing->resolution;\n+    prevailing->vnode->symbol.resolution = prevailing->resolution;\n   return 1;\n }\n "}, {"sha": "4ff0882e1140a6d5d1d21f204c1acff3a592fb96", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1,3 +1,8 @@\n+2012-04-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* lto.c: Update field referenced for new cgraph/varpool layout.\n+\t* lto-partition.c: Likewise.\n+\n 2012-04-11  Jan Hubicka  <jh@suse.cz>\n \n \t* lto.c: Update copyright; remove params.h, ipa-inline.h"}, {"sha": "af36b1440b250b2c66683c70344bc4ff2d99efb8", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 80, "deletions": 75, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -74,19 +74,19 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n     {\n       if (ref->refered_type == IPA_REF_CGRAPH\n \t  && (DECL_COMDAT (cgraph_function_node (ipa_ref_node (ref),\n-\t\t\t   NULL)->decl)\n+\t\t\t   NULL)->symbol.decl)\n \t      || (ref->use == IPA_REF_ALIAS\n \t\t  && lookup_attribute\n-\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->decl))))\n+\t\t       (\"weakref\", DECL_ATTRIBUTES (ipa_ref_node (ref)->symbol.decl))))\n \t  && !cgraph_node_in_set_p (ipa_ref_node (ref), part->cgraph_set))\n \tadd_cgraph_node_to_partition (part, ipa_ref_node (ref));\n       else\n \tif (ref->refered_type == IPA_REF_VARPOOL\n-\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->decl)\n+\t    && (DECL_COMDAT (ipa_ref_varpool_node (ref)->symbol.decl)\n \t        || (ref->use == IPA_REF_ALIAS\n \t\t    && lookup_attribute\n \t\t         (\"weakref\",\n-\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->decl))))\n+\t\t\t  DECL_ATTRIBUTES (ipa_ref_varpool_node (ref)->symbol.decl))))\n \t    && !varpool_node_in_set_p (ipa_ref_varpool_node (ref),\n \t\t\t\t       part->varpool_set))\n \t  add_varpool_node_to_partition (part, ipa_ref_varpool_node (ref));\n@@ -99,7 +99,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n \t\t\t\t    part->cgraph_set)\n \t  && !lookup_attribute (\"weakref\",\n \t\t\t\tDECL_ATTRIBUTES\n-\t\t\t\t  (ipa_ref_refering_node (ref)->decl)))\n+\t\t\t\t  (ipa_ref_refering_node (ref)->symbol.decl)))\n \tadd_cgraph_node_to_partition (part, ipa_ref_refering_node (ref));\n       else\n \tif (ref->refering_type == IPA_REF_VARPOOL\n@@ -108,7 +108,7 @@ add_references_to_partition (ltrans_partition part, struct ipa_ref_list *refs)\n \t\t\t\t       part->varpool_set)\n \t    && !lookup_attribute (\"weakref\",\n \t\t\t\t  DECL_ATTRIBUTES\n-\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->decl)))\n+\t\t\t\t    (ipa_ref_refering_varpool_node (ref)->symbol.decl)))\n \t  add_varpool_node_to_partition (part,\n \t\t\t\t\t ipa_ref_refering_varpool_node (ref));\n     }\n@@ -122,22 +122,22 @@ add_cgraph_node_to_partition_1 (struct cgraph_node *node, void *data)\n   ltrans_partition part = (ltrans_partition) data;\n \n   /* non-COMDAT aliases of COMDAT functions needs to be output just once.  */\n-  if (!DECL_COMDAT (node->decl)\n+  if (!DECL_COMDAT (node->symbol.decl)\n       && !node->global.inlined_to\n-      && node->aux)\n+      && node->symbol.aux)\n     {\n       gcc_assert (node->thunk.thunk_p || node->alias);\n       return false;\n     }\n \n-  if (node->aux)\n+  if (node->symbol.aux)\n     {\n-      node->in_other_partition = 1;\n+      node->symbol.in_other_partition = 1;\n       if (cgraph_dump_file)\n         fprintf (cgraph_dump_file, \"Node %s/%i now used in multiple partitions\\n\",\n \t\t cgraph_node_name (node), node->uid);\n     }\n-  node->aux = (void *)((size_t)node->aux + 1);\n+  node->symbol.aux = (void *)((size_t)node->symbol.aux + 1);\n   cgraph_node_set_add (part->cgraph_set, node);\n   return false;\n }\n@@ -165,21 +165,22 @@ add_cgraph_node_to_partition (ltrans_partition part, struct cgraph_node *node)\n \n   for (e = node->callees; e; e = e->next_callee)\n     if ((!e->inline_failed\n-\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->decl))\n+\t || DECL_COMDAT (cgraph_function_node (e->callee, NULL)->symbol.decl))\n \t&& !cgraph_node_in_set_p (e->callee, part->cgraph_set))\n       add_cgraph_node_to_partition (part, e->callee);\n \n   /* The only way to assemble non-weakref alias is to add the aliased object into\n      the unit.  */\n-  add_references_to_partition (part, &node->ref_list);\n+  add_references_to_partition (part, &node->symbol.ref_list);\n   n = cgraph_function_node (node, NULL);\n   if (n != node\n       && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)))\n+\t\t\t    DECL_ATTRIBUTES (node->symbol.decl)))\n     add_cgraph_node_to_partition (part, n);\n \n-  if (node->same_comdat_group)\n-    for (n = node->same_comdat_group; n != node; n = n->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n+    for (n = cgraph (node->symbol.same_comdat_group);\n+\t n != node; n = cgraph (n->symbol.same_comdat_group))\n       add_cgraph_node_to_partition (part, n);\n }\n \n@@ -198,28 +199,29 @@ add_varpool_node_to_partition (ltrans_partition part, struct varpool_node *vnode\n \n   varpool_node_set_add (part->varpool_set, vnode);\n \n-  if (vnode->aux)\n+  if (vnode->symbol.aux)\n     {\n-      vnode->in_other_partition = 1;\n+      vnode->symbol.in_other_partition = 1;\n       if (cgraph_dump_file)\n         fprintf (cgraph_dump_file, \"Varpool node %s now used in multiple partitions\\n\",\n \t\t varpool_node_name (vnode));\n     }\n-  vnode->aux = (void *)((size_t)vnode->aux + 1);\n+  vnode->symbol.aux = (void *)((size_t)vnode->symbol.aux + 1);\n \n   /* The only way to assemble non-weakref alias is to add the aliased object into\n      the unit.  */\n   v = varpool_variable_node (vnode, NULL);\n   if (v != vnode\n       && !lookup_attribute (\"weakref\",\n-\t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n+\t\t\t    DECL_ATTRIBUTES (vnode->symbol.decl)))\n     add_varpool_node_to_partition (part, v);\n \n-  add_references_to_partition (part, &vnode->ref_list);\n+  add_references_to_partition (part, &vnode->symbol.ref_list);\n \n-  if (vnode->same_comdat_group\n-      && !varpool_node_in_set_p (vnode->same_comdat_group, part->varpool_set))\n-    add_varpool_node_to_partition (part, vnode->same_comdat_group);\n+  if (vnode->symbol.same_comdat_group\n+      && !varpool_node_in_set_p (varpool (vnode->symbol.same_comdat_group),\n+\t\t\t\t part->varpool_set))\n+    add_varpool_node_to_partition (part, varpool (vnode->symbol.same_comdat_group));\n }\n \n /* Undo all additions until number of cgraph nodes in PARITION is N_CGRAPH_NODES\n@@ -237,7 +239,7 @@ undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n \t\t\t\t\t    n_cgraph_nodes);\n       partition->insns -= inline_summary (node)->self_size;\n       cgraph_node_set_remove (partition->cgraph_set, node);\n-      node->aux = (void *)((size_t)node->aux - 1);\n+      node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n     }\n   while (VEC_length (varpool_node_ptr, partition->varpool_set->nodes) >\n \t n_varpool_nodes)\n@@ -246,7 +248,7 @@ undo_partition (ltrans_partition partition, unsigned int n_cgraph_nodes,\n \t\t\t\t\t     partition->varpool_set->nodes,\n \t\t\t\t\t     n_varpool_nodes);\n       varpool_node_set_remove (partition->varpool_set, node);\n-      node->aux = (void *)((size_t)node->aux - 1);\n+      node->symbol.aux = (void *)((size_t)node->symbol.aux - 1);\n     }\n }\n \n@@ -265,11 +267,11 @@ partition_cgraph_node_p (struct cgraph_node *node)\n   if (!node->analyzed)\n     return false;\n   /* Extern inlines and comdat are always only in partitions they are needed.  */\n-  if (DECL_EXTERNAL (node->decl)\n-      || (DECL_COMDAT (node->decl)\n+  if (DECL_EXTERNAL (node->symbol.decl)\n+      || (DECL_COMDAT (node->symbol.decl)\n \t  && !cgraph_used_from_object_file_p (node)))\n     return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->decl)))\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (node->symbol.decl)))\n     return false;\n   return true;\n }\n@@ -283,12 +285,12 @@ partition_varpool_node_p (struct varpool_node *vnode)\n   if (vnode->alias || !vnode->needed)\n     return false;\n   /* Constant pool and comdat are always only in partitions they are needed.  */\n-  if (DECL_IN_CONSTANT_POOL (vnode->decl)\n-      || (DECL_COMDAT (vnode->decl)\n+  if (DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n+      || (DECL_COMDAT (vnode->symbol.decl)\n \t  && !vnode->force_output\n \t  && !varpool_used_from_object_file_p (vnode)))\n     return false;\n-  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->decl)))\n+  if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (vnode->symbol.decl)))\n     return false;\n   return true;\n }\n@@ -314,10 +316,10 @@ lto_1_to_1_map (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!partition_cgraph_node_p (node)\n-\t  || node->aux)\n+\t  || node->symbol.aux)\n \tcontinue;\n \n-      file_data = node->local.lto_file_data;\n+      file_data = node->symbol.lto_file_data;\n \n       if (file_data)\n \t{\n@@ -349,9 +351,9 @@ lto_1_to_1_map (void)\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n     {\n       if (!partition_varpool_node_p (vnode)\n-\t  || vnode->aux)\n+\t  || vnode->symbol.aux)\n \tcontinue;\n-      file_data = vnode->lto_file_data;\n+      file_data = vnode->symbol.lto_file_data;\n       slot = pointer_map_contains (pmap, file_data);\n       if (slot)\n \tpartition = (ltrans_partition) *slot;\n@@ -366,9 +368,9 @@ lto_1_to_1_map (void)\n       add_varpool_node_to_partition (partition, vnode);\n     }\n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n+    node->symbol.aux = NULL;\n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    vnode->aux = NULL;\n+    vnode->symbol.aux = NULL;\n \n   /* If the cgraph is empty, create one cgraph node set so that there is still\n      an output file for any variables that need to be exported in a DSO.  */\n@@ -389,7 +391,7 @@ node_cmp (const void *pa, const void *pb)\n {\n   const struct cgraph_node *a = *(const struct cgraph_node * const *) pa;\n   const struct cgraph_node *b = *(const struct cgraph_node * const *) pb;\n-  return b->order - a->order;\n+  return b->symbol.order - a->symbol.order;\n }\n \n /* Helper function for qsort; sort nodes by order.  */\n@@ -398,7 +400,7 @@ varpool_node_cmp (const void *pa, const void *pb)\n {\n   const struct varpool_node *a = *(const struct varpool_node * const *) pa;\n   const struct varpool_node *b = *(const struct varpool_node * const *) pb;\n-  return b->order - a->order;\n+  return b->symbol.order - a->symbol.order;\n }\n \n /* Group cgraph nodes into equally-sized partitions.\n@@ -462,7 +464,7 @@ lto_balanced_map (void)\n   int current_order = -1;\n \n   for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-    gcc_assert (!vnode->aux);\n+    gcc_assert (!vnode->symbol.aux);\n   /* Until we have better ordering facility, use toplogical order.\n      Include only nodes we will partition and compute estimate of program\n      size.  Note that since nodes that are not partitioned might be put into\n@@ -510,15 +512,16 @@ lto_balanced_map (void)\n \n   for (i = 0; i < n_nodes; i++)\n     {\n-      if (order[i]->aux)\n+      if (order[i]->symbol.aux)\n \tcontinue;\n \n-      current_order = order[i]->order;\n+      current_order = order[i]->symbol.order;\n \n       if (!flag_toplevel_reorder)\n-\twhile (varpool_pos < n_varpool_nodes && varpool_order[varpool_pos]->order < current_order)\n+\twhile (varpool_pos < n_varpool_nodes\n+\t       && varpool_order[varpool_pos]->symbol.order < current_order)\n \t  {\n-\t    if (!varpool_order[varpool_pos]->aux)\n+\t    if (!varpool_order[varpool_pos]->symbol.aux)\n \t      add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n \t    varpool_pos++;\n \t  }\n@@ -558,7 +561,7 @@ lto_balanced_map (void)\n \t      cgraph_p = true;\n \t      node = VEC_index (cgraph_node_ptr, partition->cgraph_set->nodes,\n \t\t\t\tlast_visited_cgraph_node);\n-\t      refs = &node->ref_list;\n+\t      refs = &node->symbol.ref_list;\n \n \t      last_visited_cgraph_node++;\n \n@@ -602,7 +605,7 @@ lto_balanced_map (void)\n \t    {\n \t      refs =\n \t\t&VEC_index (varpool_node_ptr, partition->varpool_set->nodes,\n-\t\t\t    last_visited_varpool_node)->ref_list;\n+\t\t\t    last_visited_varpool_node)->symbol.ref_list;\n \t      last_visited_varpool_node++;\n \t    }\n \n@@ -616,7 +619,7 @@ lto_balanced_map (void)\n \t\tvnode = ipa_ref_varpool_node (ref);\n \t\tif (!vnode->finalized)\n \t\t  continue;\n-\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n \t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n \t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n@@ -647,7 +650,7 @@ lto_balanced_map (void)\n \n \t\tvnode = ipa_ref_refering_varpool_node (ref);\n \t\tgcc_assert (vnode->finalized);\n-\t\tif (!vnode->aux && flag_toplevel_reorder\n+\t\tif (!vnode->symbol.aux && flag_toplevel_reorder\n \t\t    && partition_varpool_node_p (vnode))\n \t\t  add_varpool_node_to_partition (partition, vnode);\n \t\tvsi = varpool_node_set_find (partition->varpool_set, vnode);\n@@ -706,7 +709,7 @@ lto_balanced_map (void)\n \t    }\n \t  i = best_i;\n  \t  /* When we are finished, avoid creating empty partition.  */\n-\t  while (i < n_nodes - 1 && order[i + 1]->aux)\n+\t  while (i < n_nodes - 1 && order[i + 1]->symbol.aux)\n \t    i++;\n \t  if (i == n_nodes - 1)\n \t    break;\n@@ -740,14 +743,14 @@ lto_balanced_map (void)\n   if (flag_toplevel_reorder)\n     {\n       for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-        if (partition_varpool_node_p (vnode) && !vnode->aux)\n+        if (partition_varpool_node_p (vnode) && !vnode->symbol.aux)\n \t  add_varpool_node_to_partition (partition, vnode);\n     }\n   else\n     {\n       while (varpool_pos < n_varpool_nodes)\n \t{\n-\t  if (!varpool_order[varpool_pos]->aux)\n+\t  if (!varpool_order[varpool_pos]->symbol.aux)\n \t    add_varpool_node_to_partition (partition, varpool_order[varpool_pos]);\n \t  varpool_pos++;\n \t}\n@@ -761,12 +764,12 @@ lto_balanced_map (void)\n static bool\n promote_var (struct varpool_node *vnode)\n {\n-  if (TREE_PUBLIC (vnode->decl) || DECL_EXTERNAL (vnode->decl))\n+  if (TREE_PUBLIC (vnode->symbol.decl) || DECL_EXTERNAL (vnode->symbol.decl))\n     return false;\n   gcc_assert (flag_wpa);\n-  TREE_PUBLIC (vnode->decl) = 1;\n-  DECL_VISIBILITY (vnode->decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (vnode->decl) = true;\n+  TREE_PUBLIC (vnode->symbol.decl) = 1;\n+  DECL_VISIBILITY (vnode->symbol.decl) = VISIBILITY_HIDDEN;\n+  DECL_VISIBILITY_SPECIFIED (vnode->symbol.decl) = true;\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n \t    \"Promoting var as hidden: %s\\n\", varpool_node_name (vnode));\n@@ -779,11 +782,11 @@ static bool\n promote_fn (struct cgraph_node *node)\n {\n   gcc_assert (flag_wpa);\n-  if (TREE_PUBLIC (node->decl) || DECL_EXTERNAL (node->decl))\n+  if (TREE_PUBLIC (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n     return false;\n-  TREE_PUBLIC (node->decl) = 1;\n-  DECL_VISIBILITY (node->decl) = VISIBILITY_HIDDEN;\n-  DECL_VISIBILITY_SPECIFIED (node->decl) = true;\n+  TREE_PUBLIC (node->symbol.decl) = 1;\n+  DECL_VISIBILITY (node->symbol.decl) = VISIBILITY_HIDDEN;\n+  DECL_VISIBILITY_SPECIFIED (node->symbol.decl) = true;\n   if (cgraph_dump_file)\n     fprintf (cgraph_dump_file,\n \t     \"Promoting function as hidden: %s/%i\\n\",\n@@ -822,12 +825,13 @@ lto_promote_cross_file_statics (void)\n       for (csi = csi_start (set); !csi_end_p (csi); csi_next (&csi))\n \t{\n \t  struct cgraph_node *node = csi_node (csi);\n-\t  if (node->local.externally_visible)\n+\t  if (node->symbol.externally_visible)\n \t    continue;\n \t  if (node->global.inlined_to)\n \t    continue;\n-\t  if ((!DECL_EXTERNAL (node->decl) && !DECL_COMDAT (node->decl))\n-\t      && (referenced_from_other_partition_p (&node->ref_list, set, vset)\n+\t  if ((!DECL_EXTERNAL (node->symbol.decl)\n+\t       && !DECL_COMDAT (node->symbol.decl))\n+\t      && (referenced_from_other_partition_p (&node->symbol.ref_list, set, vset)\n \t\t  || reachable_from_other_partition_p (node, set)))\n \t    promote_fn (node);\n \t}\n@@ -837,9 +841,10 @@ lto_promote_cross_file_statics (void)\n \t  /* Constant pool references use internal labels and thus can not\n \t     be made global.  It is sensible to keep those ltrans local to\n \t     allow better optimization.  */\n-\t  if (!DECL_IN_CONSTANT_POOL (vnode->decl) && !DECL_COMDAT (vnode->decl)\n-\t      && !vnode->externally_visible && vnode->analyzed\n-\t      && referenced_from_other_partition_p (&vnode->ref_list,\n+\t  if (!DECL_IN_CONSTANT_POOL (vnode->symbol.decl)\n+\t      && !DECL_COMDAT (vnode->symbol.decl)\n+\t      && !vnode->symbol.externally_visible && vnode->analyzed\n+\t      && referenced_from_other_partition_p (&vnode->symbol.ref_list,\n \t\t\t\t\t\t    set, vset))\n \t    promote_var (vnode);\n \t}\n@@ -854,10 +859,10 @@ lto_promote_cross_file_statics (void)\n \t from this partition that are not in this partition.  This needs\n \t to be done recursively.  */\n       for (vnode = varpool_nodes; vnode; vnode = vnode->next)\n-\tif (const_value_known_p (vnode->decl)\n-\t    && DECL_INITIAL (vnode->decl)\n+\tif (const_value_known_p (vnode->symbol.decl)\n+\t    && DECL_INITIAL (vnode->symbol.decl)\n \t    && !varpool_node_in_set_p (vnode, vset)\n-\t    && referenced_from_this_partition_p (&vnode->ref_list, set, vset)\n+\t    && referenced_from_this_partition_p (&vnode->symbol.ref_list, set, vset)\n \t    && !pointer_set_insert (inserted, vnode))\n \tVEC_safe_push (varpool_node_ptr, heap, promoted_initializers, vnode);\n \n@@ -868,14 +873,14 @@ lto_promote_cross_file_statics (void)\n \n \t  vnode = VEC_pop (varpool_node_ptr, promoted_initializers);\n \t  for (i = 0;\n-\t       ipa_ref_list_reference_iterate (&vnode->ref_list, i, ref);\n+\t       ipa_ref_list_reference_iterate (&vnode->symbol.ref_list, i, ref);\n \t       i++)\n \t    {\n \t      if (ref->refered_type == IPA_REF_CGRAPH)\n \t\t{\n \t\t  struct cgraph_node *n = ipa_ref_node (ref);\n \t\t  gcc_assert (!n->global.inlined_to);\n-\t\t  if (!n->local.externally_visible\n+\t\t  if (!n->symbol.externally_visible\n \t\t      && !cgraph_node_in_set_p (n, set))\n \t\t    promote_fn (n);\n \t\t}\n@@ -888,17 +893,17 @@ lto_promote_cross_file_statics (void)\n \t\t  /* Constant pool references use internal labels and thus\n \t\t     cannot be made global.  It is sensible to keep those\n \t\t     ltrans local to allow better optimization.  */\n-\t\t  if (DECL_IN_CONSTANT_POOL (v->decl))\n+\t\t  if (DECL_IN_CONSTANT_POOL (v->symbol.decl))\n \t\t    {\n \t\t      if (!pointer_set_insert (inserted, vnode))\n \t\t\tVEC_safe_push (varpool_node_ptr, heap,\n \t\t\t\t       promoted_initializers, v);\n \t\t    }\n-\t\t  else if (!v->externally_visible && v->analyzed)\n+\t\t  else if (!v->symbol.externally_visible && v->analyzed)\n \t\t    {\n \t\t      if (promote_var (v)\n-\t\t\t  && DECL_INITIAL (v->decl)\n-\t\t\t  && const_value_known_p (v->decl)\n+\t\t\t  && DECL_INITIAL (v->symbol.decl)\n+\t\t\t  && const_value_known_p (v->symbol.decl)\n \t\t\t  && !pointer_set_insert (inserted, vnode))\n \t\t\tVEC_safe_push (varpool_node_ptr, heap,\n \t\t\t\t       promoted_initializers, v);"}, {"sha": "0b48ce183e7f66aaa7876dd7a6075dd8f634087d", "filename": "gcc/lto/lto.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2Flto.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Flto%2Flto.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -208,7 +208,7 @@ lto_materialize_function (struct cgraph_node *node)\n   const char *data, *name;\n   size_t len;\n \n-  decl = node->decl;\n+  decl = node->symbol.decl;\n   /* Read in functions with body (analyzed nodes)\n      and also functions that are needed to produce virtual clones.  */\n   if (cgraph_function_with_gimple_body_p (node) || has_analyzed_clone_p (node))\n@@ -221,7 +221,7 @@ lto_materialize_function (struct cgraph_node *node)\n \t WPA mode, the body of the function is not needed.  */\n       if (!flag_wpa)\n \t{\n-\t  file_data = node->local.lto_file_data;\n+\t  file_data = node->symbol.lto_file_data;\n \t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \n \t  /* We may have renamed the declaration, e.g., a static function.  */\n@@ -1424,13 +1424,13 @@ cmp_partitions_order (const void *a, const void *b)\n   int ordera = -1, orderb = -1;\n \n   if (VEC_length (cgraph_node_ptr, pa->cgraph_set->nodes))\n-    ordera = VEC_index (cgraph_node_ptr, pa->cgraph_set->nodes, 0)->order;\n+    ordera = VEC_index (cgraph_node_ptr, pa->cgraph_set->nodes, 0)->symbol.order;\n   else if (VEC_length (varpool_node_ptr, pa->varpool_set->nodes))\n-    ordera = VEC_index (varpool_node_ptr, pa->varpool_set->nodes, 0)->order;\n+    ordera = VEC_index (varpool_node_ptr, pa->varpool_set->nodes, 0)->symbol.order;\n   if (VEC_length (cgraph_node_ptr, pb->cgraph_set->nodes))\n-    orderb = VEC_index (cgraph_node_ptr, pb->cgraph_set->nodes, 0)->order;\n+    orderb = VEC_index (cgraph_node_ptr, pb->cgraph_set->nodes, 0)->symbol.order;\n   else if (VEC_length (varpool_node_ptr, pb->varpool_set->nodes))\n-    orderb = VEC_index (varpool_node_ptr, pb->varpool_set->nodes, 0)->order;\n+    orderb = VEC_index (varpool_node_ptr, pb->varpool_set->nodes, 0)->symbol.order;\n   return orderb - ordera;\n }\n \n@@ -1925,7 +1925,7 @@ materialize_cgraph (void)\n \n   for (node = cgraph_nodes; node; node = node->next)\n     {\n-      if (node->local.lto_file_data)\n+      if (node->symbol.lto_file_data)\n \t{\n \t  lto_materialize_function (node);\n \t  lto_stats.num_input_cgraph_nodes++;"}, {"sha": "918fad2af6ec0fbc0f7dfdb3bf85ad8b8ed389c3", "filename": "gcc/matrix-reorg.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fmatrix-reorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fmatrix-reorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmatrix-reorg.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -446,7 +446,7 @@ may_flatten_matrices (struct cgraph_node *node)\n   basic_block bb;\n   gimple_stmt_iterator gsi;\n \n-  decl = node->decl;\n+  decl = node->symbol.decl;\n   if (node->analyzed)\n     {\n       func = DECL_STRUCT_FUNCTION (decl);\n@@ -550,7 +550,7 @@ find_matrices_decl (void)\n      Check to see if it's of a candidate type and record it.  */\n   for (vnode = varpool_nodes_queue; vnode; vnode = vnode->next_needed)\n     {\n-      tree var_decl = vnode->decl;\n+      tree var_decl = vnode->symbol.decl;\n \n       if (!var_decl || TREE_CODE (var_decl) != VAR_DECL)\n \tcontinue;\n@@ -2279,8 +2279,8 @@ matrix_reorg (void)\n \ttree temp_fn;\n \n \ttemp_fn = current_function_decl;\n-\tcurrent_function_decl = node->decl;\n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tcurrent_function_decl = node->symbol.decl;\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \tbitmap_obstack_initialize (NULL);\n \tgimple_register_cfg_hooks ();\n \n@@ -2347,8 +2347,8 @@ matrix_reorg (void)\n \ttree temp_fn;\n \n \ttemp_fn = current_function_decl;\n-\tcurrent_function_decl = node->decl;\n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tcurrent_function_decl = node->symbol.decl;\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \tbitmap_obstack_initialize (NULL);\n \tgimple_register_cfg_hooks ();\n \trecord_all_accesses_in_func ();"}, {"sha": "8c58710001bc891ea0ea5136122e157854e371dd", "filename": "gcc/passes.c", "status": "modified", "additions": 14, "deletions": 14, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -706,7 +706,7 @@ dump_passes (void)\n   n = cgraph_nodes;\n   while (n)\n     {\n-      if (DECL_STRUCT_FUNCTION (n->decl))\n+      if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n         {\n           node = n;\n           break;\n@@ -717,8 +717,8 @@ dump_passes (void)\n   if (!node)\n     return;\n \n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-  current_function_decl = node->decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+  current_function_decl = node->symbol.decl;\n \n   dump_pass_list (all_lowering_passes, 1);\n   dump_pass_list (all_small_ipa_passes, 1);\n@@ -1663,11 +1663,11 @@ do_per_function (void (*callback) (void *data), void *data)\n     {\n       struct cgraph_node *node;\n       for (node = cgraph_nodes; node; node = node->next)\n-\tif (node->analyzed && gimple_has_body_p (node->decl)\n-\t    && (!node->clone_of || node->decl != node->clone_of->decl))\n+\tif (node->analyzed && gimple_has_body_p (node->symbol.decl)\n+\t    && (!node->clone_of || node->symbol.decl != node->clone_of->symbol.decl))\n \t  {\n-\t    push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t    current_function_decl = node->decl;\n+\t    push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t    current_function_decl = node->symbol.decl;\n \t    callback (data);\n \t    if (!flag_wpa)\n \t      {\n@@ -1714,8 +1714,8 @@ do_per_function_toporder (void (*callback) (void *data), void *data)\n \t  node->process = 0;\n \t  if (cgraph_function_with_gimple_body_p (node))\n \t    {\n-\t      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-\t      current_function_decl = node->decl;\n+\t      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+\t      current_function_decl = node->symbol.decl;\n \t      callback (data);\n \t      free_dominance_info (CDI_DOMINATORS);\n \t      free_dominance_info (CDI_POST_DOMINATORS);\n@@ -2337,7 +2337,7 @@ ipa_write_summaries (void)\n \t     ordering then matches the one IPA-passes get in their stmt_fixup\n \t     hooks.  */\n \n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\t  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n@@ -2418,9 +2418,9 @@ ipa_write_optimization_summaries (cgraph_node_set set, varpool_node_set vset)\n \t For functions newly born at WPA stage we need to initialize\n \t the uids here.  */\n       if (node->analyzed\n-\t  && gimple_has_body_p (node->decl))\n+\t  && gimple_has_body_p (node->symbol.decl))\n \t{\n-\t  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\t  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \t  renumber_gimple_stmt_uids ();\n \t  pop_cfun ();\n \t}\n@@ -2658,11 +2658,11 @@ function_called_by_processed_nodes_p (void)\n        e;\n        e = e->next_caller)\n     {\n-      if (e->caller->decl == current_function_decl)\n+      if (e->caller->symbol.decl == current_function_decl)\n         continue;\n       if (!cgraph_function_with_gimple_body_p (e->caller))\n         continue;\n-      if (TREE_ASM_WRITTEN (e->caller->decl))\n+      if (TREE_ASM_WRITTEN (e->caller->symbol.decl))\n         continue;\n       if (!e->caller->process && !e->caller->global.inlined_to)\n       \tbreak;"}, {"sha": "97ec664fd96980dead10c554160363e1ae02b8e1", "filename": "gcc/trans-mem.c", "status": "modified", "additions": 35, "deletions": 35, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftrans-mem.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftrans-mem.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftrans-mem.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -3587,13 +3587,13 @@ get_cg_data (struct cgraph_node **node, bool traverse_aliases)\n   if (traverse_aliases && (*node)->alias)\n     *node = cgraph_get_node ((*node)->thunk.alias);\n \n-  d = (struct tm_ipa_cg_data *) (*node)->aux;\n+  d = (struct tm_ipa_cg_data *) (*node)->symbol.aux;\n \n   if (d == NULL)\n     {\n       d = (struct tm_ipa_cg_data *)\n \tobstack_alloc (&tm_obstack.obstack, sizeof (*d));\n-      (*node)->aux = (void *) d;\n+      (*node)->symbol.aux = (void *) d;\n       memset (d, 0, sizeof (*d));\n     }\n \n@@ -3689,7 +3689,7 @@ static void\n ipa_tm_scan_calls_clone (struct cgraph_node *node,\n \t\t\t cgraph_node_queue *callees_p)\n {\n-  struct function *fn = DECL_STRUCT_FUNCTION (node->decl);\n+  struct function *fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n   basic_block bb;\n \n   FOR_EACH_BB_FN (bb, fn)\n@@ -3718,7 +3718,7 @@ ipa_tm_note_irrevocable (struct cgraph_node *node,\n \tcontinue;\n       /* Even if we think we can go irrevocable, believe the user\n \t above all.  */\n-      if (is_tm_safe_or_pure (e->caller->decl))\n+      if (is_tm_safe_or_pure (e->caller->symbol.decl))\n \tcontinue;\n \n       caller = e->caller;\n@@ -3975,12 +3975,12 @@ ipa_tm_scan_irr_function (struct cgraph_node *node, bool for_clone)\n   bool ret = false;\n \n   /* Builtin operators (operator new, and such).  */\n-  if (DECL_STRUCT_FUNCTION (node->decl) == NULL\n-      || DECL_STRUCT_FUNCTION (node->decl)->cfg == NULL)\n+  if (DECL_STRUCT_FUNCTION (node->symbol.decl) == NULL\n+      || DECL_STRUCT_FUNCTION (node->symbol.decl)->cfg == NULL)\n     return false;\n \n-  current_function_decl = node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->symbol.decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   d = get_cg_data (&node, true);\n@@ -4067,7 +4067,7 @@ ipa_tm_mayenterirr_function (struct cgraph_node *node)\n   unsigned flags;\n \n   d = get_cg_data (&node, true);\n-  decl = node->decl;\n+  decl = node->symbol.decl;\n   flags = flags_from_decl_or_type (decl);\n \n   /* Handle some TM builtins.  Ordinarily these aren't actually generated\n@@ -4127,11 +4127,11 @@ ipa_tm_diagnose_tm_safe (struct cgraph_node *node)\n   struct cgraph_edge *e;\n \n   for (e = node->callees; e ; e = e->next_callee)\n-    if (!is_tm_callable (e->callee->decl)\n+    if (!is_tm_callable (e->callee->symbol.decl)\n \t&& e->callee->local.tm_may_enter_irr)\n       error_at (gimple_location (e->call_stmt),\n \t\t\"unsafe function call %qD within \"\n-\t\t\"%<transaction_safe%> function\", e->callee->decl);\n+\t\t\"%<transaction_safe%> function\", e->callee->symbol.decl);\n }\n \n /* Diagnose call from atomic transactions to unmarked functions\n@@ -4296,7 +4296,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n   if (!node->same_body_alias)\n     return false;\n \n-  old_decl = node->decl;\n+  old_decl = node->symbol.decl;\n   tm_name = tm_mangle (DECL_ASSEMBLER_NAME (old_decl));\n   new_decl = build_decl (DECL_SOURCE_LOCATION (old_decl),\n \t\t\t TREE_CODE (old_decl), tm_name,\n@@ -4322,7 +4322,7 @@ ipa_tm_create_version_alias (struct cgraph_node *node, void *data)\n \n   new_node = cgraph_same_body_alias (NULL, new_decl, info->new_decl);\n   new_node->tm_clone = true;\n-  new_node->local.externally_visible = info->old_node->local.externally_visible;\n+  new_node->symbol.externally_visible = info->old_node->symbol.externally_visible;\n   /* ?? Do not traverse aliases here.  */\n   get_cg_data (&node, false)->clone = new_node;\n \n@@ -4342,7 +4342,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n   tree new_decl, old_decl, tm_name;\n   struct cgraph_node *new_node;\n \n-  old_decl = old_node->decl;\n+  old_decl = old_node->symbol.decl;\n   new_decl = copy_node (old_decl);\n \n   /* DECL_ASSEMBLER_NAME needs to be set before we call\n@@ -4358,7 +4358,7 @@ ipa_tm_create_version (struct cgraph_node *old_node)\n     DECL_COMDAT_GROUP (new_decl) = tm_mangle (DECL_COMDAT_GROUP (old_decl));\n \n   new_node = cgraph_copy_node_for_versioning (old_node, new_decl, NULL, NULL);\n-  new_node->local.externally_visible = old_node->local.externally_visible;\n+  new_node->symbol.externally_visible = old_node->symbol.externally_visible;\n   new_node->lowered = true;\n   new_node->tm_clone = 1;\n   get_cg_data (&old_node, true)->clone = new_node;\n@@ -4416,7 +4416,7 @@ ipa_tm_insert_irr_call (struct cgraph_node *node, struct tm_region *region,\n \t       cgraph_get_create_node\n \t\t  (builtin_decl_explicit (BUILT_IN_TM_IRREVOCABLE)),\n \t\t      g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->decl,\n+\t\t      compute_call_stmt_bb_frequency (node->symbol.decl,\n \t\t\t\t\t\t      gimple_bb (g)));\n }\n \n@@ -4467,7 +4467,7 @@ ipa_tm_insert_gettmclone_call (struct cgraph_node *node,\n   gsi_insert_before (gsi, g, GSI_SAME_STMT);\n \n   cgraph_create_edge (node, cgraph_get_create_node (gettm_fn), g, 0,\n-\t\t      compute_call_stmt_bb_frequency (node->decl,\n+\t\t      compute_call_stmt_bb_frequency (node->symbol.decl,\n \t\t\t\t\t\t      gimple_bb(g)));\n \n   /* Cast return value from tm_gettmclone* into appropriate function\n@@ -4595,7 +4595,7 @@ ipa_tm_transform_calls_redirect (struct cgraph_node *node,\n \t  return;\n \t}\n \n-      fndecl = new_node->decl;\n+      fndecl = new_node->symbol.decl;\n     }\n \n   cgraph_redirect_edge_callee (e, new_node);\n@@ -4689,8 +4689,8 @@ ipa_tm_transform_transaction (struct cgraph_node *node)\n \n   d = get_cg_data (&node, true);\n \n-  current_function_decl = node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->symbol.decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n   for (region = d->all_tm_regions; region; region = region->next)\n@@ -4733,7 +4733,7 @@ ipa_tm_transform_clone (struct cgraph_node *node)\n   if (!node->callees && !d->irrevocable_blocks_clone)\n     return;\n \n-  current_function_decl = d->clone->decl;\n+  current_function_decl = d->clone->symbol.decl;\n   push_cfun (DECL_STRUCT_FUNCTION (current_function_decl));\n   calculate_dominance_info (CDI_DOMINATORS);\n \n@@ -4770,7 +4770,7 @@ ipa_tm_execute (void)\n \n   /* For all local functions marked tm_callable, queue them.  */\n   for (node = cgraph_nodes; node; node = node->next)\n-    if (is_tm_callable (node->decl)\n+    if (is_tm_callable (node->symbol.decl)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);\n@@ -4785,15 +4785,15 @@ ipa_tm_execute (void)\n \t/* ... marked tm_pure, record that fact for the runtime by\n \t   indicating that the pure function is its own tm_callable.\n \t   No need to do this if the function's address can't be taken.  */\n-\tif (is_tm_pure (node->decl))\n+\tif (is_tm_pure (node->symbol.decl))\n \t  {\n \t    if (!node->local.local)\n-\t      record_tm_clone_pair (node->decl, node->decl);\n+\t      record_tm_clone_pair (node->symbol.decl, node->symbol.decl);\n \t    continue;\n \t  }\n \n-\tcurrent_function_decl = node->decl;\n-\tpush_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+\tcurrent_function_decl = node->symbol.decl;\n+\tpush_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \tcalculate_dominance_info (CDI_DOMINATORS);\n \n \ttm_region_init (NULL);\n@@ -4831,14 +4831,14 @@ ipa_tm_execute (void)\n \n       /* Some callees cannot be arbitrarily cloned.  These will always be\n \t irrevocable.  Mark these now, so that we need not scan them.  */\n-      if (is_tm_irrevocable (node->decl))\n+      if (is_tm_irrevocable (node->symbol.decl))\n \tipa_tm_note_irrevocable (node, &irr_worklist);\n       else if (a <= AVAIL_NOT_AVAILABLE\n-\t       && !is_tm_safe_or_pure (node->decl))\n+\t       && !is_tm_safe_or_pure (node->symbol.decl))\n \tipa_tm_note_irrevocable (node, &irr_worklist);\n       else if (a >= AVAIL_OVERWRITABLE)\n \t{\n-\t  if (!tree_versionable_function_p (node->decl))\n+\t  if (!tree_versionable_function_p (node->symbol.decl))\n \t    ipa_tm_note_irrevocable (node, &irr_worklist);\n \t  else if (!d->is_irrevocable)\n \t    {\n@@ -4922,7 +4922,7 @@ ipa_tm_execute (void)\n       for (e = node->callers; e ; e = e->next_caller)\n \t{\n \t  caller = e->caller;\n-\t  if (!is_tm_safe_or_pure (caller->decl)\n+\t  if (!is_tm_safe_or_pure (caller->symbol.decl)\n \t      && !caller->local.tm_may_enter_irr)\n \t    {\n \t      d = get_cg_data (&caller, true);\n@@ -4931,7 +4931,7 @@ ipa_tm_execute (void)\n \t}\n \n       /* Propagate back to referring aliases as well.  */\n-      for (j = 0; ipa_ref_list_refering_iterate (&node->ref_list, j, ref); j++)\n+      for (j = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, j, ref); j++)\n \t{\n \t  caller = ref->refering.cgraph_node;\n \t  if (ref->use == IPA_REF_ALIAS\n@@ -4951,7 +4951,7 @@ ipa_tm_execute (void)\n \t&& cgraph_function_body_availability (node) >= AVAIL_OVERWRITABLE)\n       {\n \td = get_cg_data (&node, true);\n-\tif (is_tm_safe (node->decl))\n+\tif (is_tm_safe (node->symbol.decl))\n \t  ipa_tm_diagnose_tm_safe (node);\n \telse if (d->all_tm_regions)\n \t  ipa_tm_diagnose_transaction (node, d->all_tm_regions);\n@@ -4972,8 +4972,8 @@ ipa_tm_execute (void)\n       d = get_cg_data (&node, true);\n \n       if (a <= AVAIL_NOT_AVAILABLE)\n-\tdoit = is_tm_callable (node->decl);\n-      else if (a <= AVAIL_AVAILABLE && is_tm_callable (node->decl))\n+\tdoit = is_tm_callable (node->symbol.decl);\n+      else if (a <= AVAIL_AVAILABLE && is_tm_callable (node->symbol.decl))\n \tdoit = true;\n       else if (!d->is_irrevocable\n \t       && d->tm_callers_normal + d->tm_callers_clone > 0)\n@@ -5009,7 +5009,7 @@ ipa_tm_execute (void)\n   bitmap_obstack_release (&tm_obstack);\n \n   for (node = cgraph_nodes; node; node = node->next)\n-    node->aux = NULL;\n+    node->symbol.aux = NULL;\n \n #ifdef ENABLE_CHECKING\n   verify_cgraph ();"}, {"sha": "ba188d85a77d462ca5627d1d04c7f13e82cb50b6", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -2533,7 +2533,7 @@ tree_could_trap_p (tree expr)\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n \t  node = cgraph_function_node (cgraph_get_node (expr), NULL);\n-\t  if (node && node->in_other_partition)\n+\t  if (node && node->symbol.in_other_partition)\n \t    return false;\n \t  return true;\n \t}\n@@ -2549,7 +2549,7 @@ tree_could_trap_p (tree expr)\n \t  if (!DECL_EXTERNAL (expr))\n \t    return false;\n \t  node = varpool_variable_node (varpool_get_node (expr), NULL);\n-\t  if (node && node->in_other_partition)\n+\t  if (node && node->symbol.in_other_partition)\n \t    return false;\n \t  return true;\n \t}"}, {"sha": "cd9630f39c77911f2fd06f053ae7e9f8107de611", "filename": "gcc/tree-emutls.c", "status": "modified", "additions": 12, "deletions": 12, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-emutls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-emutls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-emutls.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -338,7 +338,7 @@ new_emutls_decl (tree decl, tree alias_of)\n   else \n     varpool_create_variable_alias (to,\n \t\t\t\t   varpool_node_for_asm\n-\t\t\t\t    (DECL_ASSEMBLER_NAME (alias_of))->decl);\n+\t\t\t\t    (DECL_ASSEMBLER_NAME (alias_of))->symbol.decl);\n   return to;\n }\n \n@@ -366,7 +366,7 @@ emutls_decl (tree decl)\n \n   i = emutls_index (decl);\n   var = VEC_index (varpool_node_ptr, control_vars, i);\n-  return var->decl;\n+  return var->symbol.decl;\n }\n \n /* Generate a call statement to initialize CONTROL_DECL for TLS_DECL.\n@@ -428,7 +428,7 @@ gen_emutls_addr (tree decl, struct lower_emutls_data *d)\n       gimple x;\n \n       cvar = VEC_index (varpool_node_ptr, control_vars, index);\n-      cdecl = cvar->decl;\n+      cdecl = cvar->symbol.decl;\n       TREE_ADDRESSABLE (cdecl) = 1;\n \n       addr = create_tmp_var (build_pointer_type (TREE_TYPE (decl)), NULL);\n@@ -619,8 +619,8 @@ lower_emutls_function_body (struct cgraph_node *node)\n   struct lower_emutls_data d;\n   bool any_edge_inserts = false;\n \n-  current_function_decl = node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n+  current_function_decl = node->symbol.decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n \n   d.cfun_node = node;\n   d.builtin_decl = builtin_decl_explicit (BUILT_IN_EMUTLS_GET_ADDRESS);\n@@ -703,7 +703,7 @@ create_emultls_var (struct varpool_node *var, void *data)\n   tree cdecl;\n   struct varpool_node *cvar;\n \n-  cdecl = new_emutls_decl (var->decl, var->alias_of);\n+  cdecl = new_emutls_decl (var->symbol.decl, var->alias_of);\n \n   cvar = varpool_get_node (cdecl);\n   VEC_quick_push (varpool_node_ptr, control_vars, cvar);\n@@ -713,7 +713,7 @@ create_emultls_var (struct varpool_node *var, void *data)\n       /* Make sure the COMMON block control variable gets initialized.\n \t Note that there's no point in doing this for aliases; we only\n \t need to do this once for the main variable.  */\n-      emutls_common_1 (var->decl, cdecl, (tree *)data);\n+      emutls_common_1 (var->symbol.decl, cdecl, (tree *)data);\n     }\n   if (var->alias && !var->alias_of)\n     cvar->alias = true;\n@@ -722,8 +722,8 @@ create_emultls_var (struct varpool_node *var, void *data)\n      preventing the variable from re-appearing in the GIMPLE.  We cheat\n      and use the control variable here (rather than a full call_expr),\n      which is special-cased inside the DWARF2 output routines.  */\n-  SET_DECL_VALUE_EXPR (var->decl, cdecl);\n-  DECL_HAS_VALUE_EXPR_P (var->decl) = 1;\n+  SET_DECL_VALUE_EXPR (var->symbol.decl, cdecl);\n+  DECL_HAS_VALUE_EXPR_P (var->symbol.decl) = 1;\n   return false;\n }\n \n@@ -742,10 +742,10 @@ ipa_lower_emutls (void)\n \n   /* Examine all global variables for TLS variables.  */\n   for (var = varpool_nodes; var ; var = var->next)\n-    if (DECL_THREAD_LOCAL_P (var->decl))\n+    if (DECL_THREAD_LOCAL_P (var->symbol.decl))\n       {\n-\tgcc_checking_assert (TREE_STATIC (var->decl)\n-\t\t\t     || DECL_EXTERNAL (var->decl));\n+\tgcc_checking_assert (TREE_STATIC (var->symbol.decl)\n+\t\t\t     || DECL_EXTERNAL (var->symbol.decl));\n \tvarpool_node_set_add (tls_vars, var);\n \tif (var->alias && var->analyzed)\n \t  varpool_node_set_add (tls_vars, varpool_variable_node (var, NULL));"}, {"sha": "a385c217ccea96a992ee5b5157c7e8e1b9521d83", "filename": "gcc/tree-inline.c", "status": "modified", "additions": 12, "deletions": 11, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-inline.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1702,7 +1702,7 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t         doing so would introduce roundoff errors and make\n \t\t\t verifier unhappy.  */\n \t\t      edge->frequency\n-\t\t        = compute_call_stmt_bb_frequency (id->dst_node->decl,\n+\t\t        = compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n \t\t\t\t\t\t\t  copy_basic_block);\n \t\t      if (dump_file\n \t\t      \t  && profile_status_for_function (cfun) != PROFILE_ABSENT\n@@ -1756,20 +1756,21 @@ copy_bb (copy_body_data *id, basic_block bb, int frequency_scale,\n \t\t     other cases we hit a bug (incorrect node sharing is the\n \t\t     most common reason for missing edges).  */\n \t\t  gcc_assert (dest->needed || !dest->analyzed\n-\t\t\t      || dest->address_taken\n+\t\t\t      || dest->symbol.address_taken\n \t\t  \t      || !id->src_node->analyzed\n \t\t\t      || !id->dst_node->analyzed);\n \t\t  if (id->transform_call_graph_edges == CB_CGE_MOVE_CLONES)\n \t\t    cgraph_create_edge_including_clones\n \t\t      (id->dst_node, dest, orig_stmt, stmt, bb->count,\n-\t\t       compute_call_stmt_bb_frequency (id->dst_node->decl,\n+\t\t       compute_call_stmt_bb_frequency (id->dst_node->symbol.decl,\n \t\t       \t\t\t\t       copy_basic_block),\n \t\t       CIF_ORIGINALLY_INDIRECT_CALL);\n \t\t  else\n \t\t    cgraph_create_edge (id->dst_node, dest, stmt,\n \t\t\t\t\tbb->count,\n \t\t\t\t\tcompute_call_stmt_bb_frequency\n-\t\t\t\t\t  (id->dst_node->decl, copy_basic_block))->inline_failed\n+\t\t\t\t\t  (id->dst_node->symbol.decl,\n+\t\t\t\t\t   copy_basic_block))->inline_failed\n \t\t      = CIF_ORIGINALLY_INDIRECT_CALL;\n \t\t  if (dump_file)\n \t\t    {\n@@ -3790,7 +3791,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      If we cannot, then there is no hope of inlining the function.  */\n   if (cg_edge->indirect_unknown_callee)\n     goto egress;\n-  fn = cg_edge->callee->decl;\n+  fn = cg_edge->callee->symbol.decl;\n   gcc_checking_assert (fn);\n \n   /* If FN is a declaration of a function in a nested scope that was\n@@ -3841,20 +3842,20 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n \t}\n       goto egress;\n     }\n-  fn = cg_edge->callee->decl;\n+  fn = cg_edge->callee->symbol.decl;\n \n #ifdef ENABLE_CHECKING\n-  if (cg_edge->callee->decl != id->dst_node->decl)\n+  if (cg_edge->callee->symbol.decl != id->dst_node->symbol.decl)\n     verify_cgraph_node (cg_edge->callee);\n #endif\n \n   /* We will be inlining this callee.  */\n   id->eh_lp_nr = lookup_stmt_eh_lp (stmt);\n \n   /* Update the callers EH personality.  */\n-  if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl))\n-    DECL_FUNCTION_PERSONALITY (cg_edge->caller->decl)\n-      = DECL_FUNCTION_PERSONALITY (cg_edge->callee->decl);\n+  if (DECL_FUNCTION_PERSONALITY (cg_edge->callee->symbol.decl))\n+    DECL_FUNCTION_PERSONALITY (cg_edge->caller->symbol.decl)\n+      = DECL_FUNCTION_PERSONALITY (cg_edge->callee->symbol.decl);\n \n   /* Split the block holding the GIMPLE_CALL.  */\n   e = split_block (bb, stmt);\n@@ -4066,7 +4067,7 @@ expand_call_inline (basic_block bb, gimple stmt, copy_body_data *id)\n      inlined.  If we don't do this now, we can lose the information about the\n      variables in the function when the blocks get blown away as soon as we\n      remove the cgraph node.  */\n-  (*debug_hooks->outlining_inline_function) (cg_edge->callee->decl);\n+  (*debug_hooks->outlining_inline_function) (cg_edge->callee->symbol.decl);\n \n   /* Update callgraph if needed.  */\n   cgraph_remove_node (cg_edge->callee);"}, {"sha": "042137f09ad9bc9ca690e2cf75be8b8514c4066f", "filename": "gcc/tree-nested.c", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-nested.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-nested.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-nested.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -698,11 +698,12 @@ check_for_nested_with_variably_modified (tree fndecl, tree orig_fndecl)\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n-      for (arg = DECL_ARGUMENTS (cgn->decl); arg; arg = DECL_CHAIN (arg))\n+      for (arg = DECL_ARGUMENTS (cgn->symbol.decl); arg; arg = DECL_CHAIN (arg))\n \tif (variably_modified_type_p (TREE_TYPE (arg), orig_fndecl))\n \t  return true;\n \n-      if (check_for_nested_with_variably_modified (cgn->decl, orig_fndecl))\n+      if (check_for_nested_with_variably_modified (cgn->symbol.decl,\n+\t\t\t\t\t\t   orig_fndecl))\n \treturn true;\n     }\n \n@@ -720,7 +721,7 @@ create_nesting_tree (struct cgraph_node *cgn)\n   info->var_map = pointer_map_create ();\n   info->mem_refs = pointer_set_create ();\n   info->suppress_expansion = BITMAP_ALLOC (&nesting_info_bitmap_obstack);\n-  info->context = cgn->decl;\n+  info->context = cgn->symbol.decl;\n \n   for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n     {\n@@ -2589,8 +2590,8 @@ static void\n gimplify_all_functions (struct cgraph_node *root)\n {\n   struct cgraph_node *iter;\n-  if (!gimple_body (root->decl))\n-    gimplify_function_tree (root->decl);\n+  if (!gimple_body (root->symbol.decl))\n+    gimplify_function_tree (root->symbol.decl);\n   for (iter = root->nested; iter; iter = iter->next_nested)\n     gimplify_all_functions (iter);\n }"}, {"sha": "2c1ad8a020f8574080174f8b6060a732be2b3414", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -482,16 +482,16 @@ tree_profiling (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!node->analyzed\n-\t  || !gimple_has_body_p (node->decl))\n+\t  || !gimple_has_body_p (node->symbol.decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n \tcontinue;\n \n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-      current_function_decl = node->decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      current_function_decl = node->symbol.decl;\n \n       /* Re-set global shared temporary variable for edge-counters.  */\n       gcov_type_tmp_var = NULL_TREE;\n@@ -523,13 +523,14 @@ tree_profiling (void)\n   for (node = cgraph_nodes; node; node = node->next)\n     {\n       if (!node->analyzed\n-\t  || !gimple_has_body_p (node->decl)\n-\t  || !(!node->clone_of || node->decl != node->clone_of->decl))\n+\t  || !gimple_has_body_p (node->symbol.decl)\n+\t  || !(!node->clone_of\n+\t  || node->symbol.decl != node->clone_of->symbol.decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n \tcontinue;\n \n       cgraph_set_const_flag (node, false, false);\n@@ -542,17 +543,18 @@ tree_profiling (void)\n       basic_block bb;\n \n       if (!node->analyzed\n-\t  || !gimple_has_body_p (node->decl)\n-\t  || !(!node->clone_of || node->decl != node->clone_of->decl))\n+\t  || !gimple_has_body_p (node->symbol.decl)\n+\t  || !(!node->clone_of\n+\t  || node->symbol.decl != node->clone_of->symbol.decl))\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n-      if (DECL_SOURCE_LOCATION (node->decl) == BUILTINS_LOCATION\n-\t  || DECL_STRUCT_FUNCTION (node->decl)->after_tree_profile)\n+      if (DECL_SOURCE_LOCATION (node->symbol.decl) == BUILTINS_LOCATION\n+\t  || DECL_STRUCT_FUNCTION (node->symbol.decl)->after_tree_profile)\n \tcontinue;\n \n-      push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n-      current_function_decl = node->decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (node->symbol.decl));\n+      current_function_decl = node->symbol.decl;\n \n       FOR_EACH_BB (bb)\n \t{"}, {"sha": "c9d01598b83821ec7b4da0e33c2006287868cbeb", "filename": "gcc/tree-sra.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-sra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-sra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-sra.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -4644,8 +4644,8 @@ convert_callers_for_node (struct cgraph_node *node,\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     {\n-      current_function_decl = cs->caller->decl;\n-      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->decl));\n+      current_function_decl = cs->caller->symbol.decl;\n+      push_cfun (DECL_STRUCT_FUNCTION (cs->caller->symbol.decl));\n \n       if (dump_file)\n \tfprintf (dump_file, \"Adjusting call (%i -> %i) %s -> %s\\n\",\n@@ -4660,7 +4660,7 @@ convert_callers_for_node (struct cgraph_node *node,\n \n   for (cs = node->callers; cs; cs = cs->next_caller)\n     if (bitmap_set_bit (recomputed_callers, cs->caller->uid)\n-\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->decl)))\n+\t&& gimple_in_ssa_p (DECL_STRUCT_FUNCTION (cs->caller->symbol.decl)))\n       compute_inline_parameters (cs->caller, true);\n   BITMAP_FREE (recomputed_callers);\n \n@@ -4699,7 +4699,7 @@ convert_callers (struct cgraph_node *node, tree old_decl,\n \t    {\n \t      if (dump_file)\n \t\tfprintf (dump_file, \"Adjusting recursive call\");\n-\t      gimple_call_set_fndecl (stmt, node->decl);\n+\t      gimple_call_set_fndecl (stmt, node->symbol.decl);\n \t      ipa_modify_call_arguments (NULL, stmt, adjustments);\n \t    }\n \t}\n@@ -4725,13 +4725,13 @@ modify_function (struct cgraph_node *node, ipa_parm_adjustment_vec adjustments)\n \n   new_node = cgraph_function_versioning (node, redirect_callers, NULL, NULL,\n \t\t\t\t\t false, NULL, NULL, \"isra\");\n-  current_function_decl = new_node->decl;\n-  push_cfun (DECL_STRUCT_FUNCTION (new_node->decl));\n+  current_function_decl = new_node->symbol.decl;\n+  push_cfun (DECL_STRUCT_FUNCTION (new_node->symbol.decl));\n \n   ipa_modify_formal_parameters (current_function_decl, adjustments, \"ISRA\");\n   cfg_changed = ipa_sra_modify_function_body (adjustments);\n   sra_ipa_reset_debug_stmts (adjustments);\n-  convert_callers (new_node, node->decl, adjustments);\n+  convert_callers (new_node, node->symbol.decl, adjustments);\n   cgraph_make_node_local (new_node);\n   return cfg_changed;\n }\n@@ -4757,7 +4757,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (!tree_versionable_function_p (node->decl))\n+  if (!tree_versionable_function_p (node->symbol.decl))\n     {\n       if (dump_file)\n \tfprintf (dump_file, \"Function is not versionable.\\n\");\n@@ -4771,7 +4771,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if ((DECL_COMDAT (node->decl) || DECL_EXTERNAL (node->decl))\n+  if ((DECL_COMDAT (node->symbol.decl) || DECL_EXTERNAL (node->symbol.decl))\n       && inline_summary(node)->size >= MAX_INLINE_INSNS_AUTO)\n     {\n       if (dump_file)\n@@ -4794,7 +4794,7 @@ ipa_sra_preliminary_function_checks (struct cgraph_node *node)\n       return false;\n     }\n \n-  if (TYPE_ATTRIBUTES (TREE_TYPE (node->decl)))\n+  if (TYPE_ATTRIBUTES (TREE_TYPE (node->symbol.decl)))\n     return false;\n \n   return true;"}, {"sha": "8eb440af49e4ad8ce35b2a5a0fb5f19962691f6a", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 16, "deletions": 15, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -2759,7 +2759,7 @@ get_constraint_for_ssa_var (tree t, VEC(ce_s, heap) **results, bool address_p)\n       if (node && node->alias)\n \t{\n \t  node = varpool_variable_node (node, NULL);\n-\t  t = node->decl;\n+\t  t = node->symbol.decl;\n \t}\n     }\n \n@@ -6839,7 +6839,7 @@ static bool\n associate_varinfo_to_alias (struct cgraph_node *node, void *data)\n {\n   if (node->alias || node->thunk.thunk_p)\n-    insert_vi_for_tree (node->decl, (varinfo_t)data);\n+    insert_vi_for_tree (node->symbol.decl, (varinfo_t)data);\n   return false;\n }\n \n@@ -6873,8 +6873,8 @@ ipa_pta_execute (void)\n \n       gcc_assert (!node->clone_of);\n \n-      vi = create_function_info_for (node->decl,\n-\t\t\t             alias_get_name (node->decl));\n+      vi = create_function_info_for (node->symbol.decl,\n+\t\t\t             alias_get_name (node->symbol.decl));\n       cgraph_for_node_and_aliases (node, associate_varinfo_to_alias, vi, true);\n     }\n \n@@ -6884,7 +6884,7 @@ ipa_pta_execute (void)\n       if (var->alias)\n \tcontinue;\n \n-      get_vi_for_tree (var->decl);\n+      get_vi_for_tree (var->symbol.decl);\n     }\n \n   if (dump_file)\n@@ -6910,33 +6910,34 @@ ipa_pta_execute (void)\n \t{\n \t  fprintf (dump_file,\n \t\t   \"Generating constraints for %s\", cgraph_node_name (node));\n-\t  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n+\t  if (DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl))\n \t    fprintf (dump_file, \" (%s)\",\n-\t\t     IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n+\t\t     IDENTIFIER_POINTER\n+\t\t       (DECL_ASSEMBLER_NAME (node->symbol.decl)));\n \t  fprintf (dump_file, \"\\n\");\n \t}\n \n-      func = DECL_STRUCT_FUNCTION (node->decl);\n+      func = DECL_STRUCT_FUNCTION (node->symbol.decl);\n       old_func_decl = current_function_decl;\n       push_cfun (func);\n-      current_function_decl = node->decl;\n+      current_function_decl = node->symbol.decl;\n \n       /* For externally visible or attribute used annotated functions use\n \t local constraints for their arguments.\n \t For local functions we see all callers and thus do not need initial\n \t constraints for parameters.  */\n-      if (node->reachable_from_other_partition\n-\t  || node->local.externally_visible\n+      if (node->symbol.used_from_other_partition\n+\t  || node->symbol.externally_visible\n \t  || node->needed)\n \t{\n \t  intra_create_variable_infos ();\n \n \t  /* We also need to make function return values escape.  Nothing\n \t     escapes by returning from main though.  */\n-\t  if (!MAIN_NAME_P (DECL_NAME (node->decl)))\n+\t  if (!MAIN_NAME_P (DECL_NAME (node->symbol.decl)))\n \t    {\n \t      varinfo_t fi, rvi;\n-\t      fi = lookup_vi_for_tree (node->decl);\n+\t      fi = lookup_vi_for_tree (node->symbol.decl);\n \t      rvi = first_vi_for_offset (fi, fi_result);\n \t      if (rvi && rvi->offset == fi_result)\n \t\t{\n@@ -7017,7 +7018,7 @@ ipa_pta_execute (void)\n       if (!cgraph_function_with_gimple_body_p (node))\n \tcontinue;\n \n-      fn = DECL_STRUCT_FUNCTION (node->decl);\n+      fn = DECL_STRUCT_FUNCTION (node->symbol.decl);\n \n       /* Compute the points-to sets for pointer SSA_NAMEs.  */\n       FOR_EACH_VEC_ELT (tree, fn->gimple_df->ssa_names, i, ptr)\n@@ -7028,7 +7029,7 @@ ipa_pta_execute (void)\n \t}\n \n       /* Compute the call-use and call-clobber sets for all direct calls.  */\n-      fi = lookup_vi_for_tree (node->decl);\n+      fi = lookup_vi_for_tree (node->symbol.decl);\n       gcc_assert (fi->is_fn_info);\n       find_what_var_points_to (first_vi_for_offset (fi, fi_clobbers),\n \t\t\t       &clobbers);"}, {"sha": "448dd1e26b72828e3cdce3da24b031faed25fd3c", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -324,7 +324,7 @@ increase_alignment (void)\n        vnode;\n        vnode = vnode->next_needed)\n     {\n-      tree vectype, decl = vnode->decl;\n+      tree vectype, decl = vnode->symbol.decl;\n       tree t;\n       unsigned int alignment;\n "}, {"sha": "97d78dcceb5c0ab110c947dda29d1b639023f591", "filename": "gcc/tree.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -5048,14 +5048,14 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n   unsigned ix;\n   tree t;\n \n-  find_decls_types (n->decl, fld);\n+  find_decls_types (n->symbol.decl, fld);\n \n-  if (!gimple_has_body_p (n->decl))\n+  if (!gimple_has_body_p (n->symbol.decl))\n     return;\n \n   gcc_assert (current_function_decl == NULL_TREE && cfun == NULL);\n \n-  fn = DECL_STRUCT_FUNCTION (n->decl);\n+  fn = DECL_STRUCT_FUNCTION (n->symbol.decl);\n \n   /* Traverse locals. */\n   FOR_EACH_LOCAL_DECL (fn, ix, t)\n@@ -5111,7 +5111,7 @@ find_decls_types_in_node (struct cgraph_node *n, struct free_lang_data_d *fld)\n static void\n find_decls_types_in_var (struct varpool_node *v, struct free_lang_data_d *fld)\n {\n-  find_decls_types (v->decl, fld);\n+  find_decls_types (v->symbol.decl, fld);\n }\n \n /* If T needs an assembler name, have one created for it.  */"}, {"sha": "e6c2310ac60dcd89b37bd17ed4f8829557aacaea", "filename": "gcc/value-prof.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -1075,9 +1075,9 @@ init_node_map (void)\n \n   for (n = cgraph_nodes; n; n = n->next)\n     {\n-      if (DECL_STRUCT_FUNCTION (n->decl))\n+      if (DECL_STRUCT_FUNCTION (n->symbol.decl))\n         VEC_replace (cgraph_node_ptr, cgraph_node_map,\n-                     DECL_STRUCT_FUNCTION (n->decl)->funcdef_no, n);\n+                     DECL_STRUCT_FUNCTION (n->symbol.decl)->funcdef_no, n);\n     }\n }\n \n@@ -1122,7 +1122,7 @@ static bool\n check_ic_target (gimple call_stmt, struct cgraph_node *target)\n {\n    location_t locus;\n-   if (gimple_check_call_matching_types (call_stmt, target->decl))\n+   if (gimple_check_call_matching_types (call_stmt, target->symbol.decl))\n      return true;\n \n    locus =  gimple_location (call_stmt);\n@@ -1162,7 +1162,7 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   SSA_NAME_DEF_STMT (tmp0) = load_stmt;\n   gsi_insert_before (&gsi, load_stmt, GSI_SAME_STMT);\n \n-  tmp = fold_convert (optype, build_addr (direct_call->decl,\n+  tmp = fold_convert (optype, build_addr (direct_call->symbol.decl,\n \t\t\t\t\t  current_function_decl));\n   load_stmt = gimple_build_assign (tmp1, tmp);\n   SSA_NAME_DEF_STMT (tmp1) = load_stmt;\n@@ -1175,8 +1175,8 @@ gimple_ic (gimple icall_stmt, struct cgraph_node *direct_call,\n   gimple_set_vuse (icall_stmt, NULL_TREE);\n   update_stmt (icall_stmt);\n   dcall_stmt = gimple_copy (icall_stmt);\n-  gimple_call_set_fndecl (dcall_stmt, direct_call->decl);\n-  dflags = flags_from_decl_or_type (direct_call->decl);\n+  gimple_call_set_fndecl (dcall_stmt, direct_call->symbol.decl);\n+  dflags = flags_from_decl_or_type (direct_call->symbol.decl);\n   if ((dflags & ECF_NORETURN) != 0)\n     gimple_call_set_lhs (dcall_stmt, NULL_TREE);\n   gsi_insert_before (&gsi, dcall_stmt, GSI_SAME_STMT);\n@@ -1341,7 +1341,7 @@ gimple_ic_transform (gimple stmt)\n       fprintf (dump_file, \"Indirect call -> direct call \");\n       print_generic_expr (dump_file, gimple_call_fn (stmt), TDF_SLIM);\n       fprintf (dump_file, \"=> \");\n-      print_generic_expr (dump_file, direct_call->decl, TDF_SLIM);\n+      print_generic_expr (dump_file, direct_call->symbol.decl, TDF_SLIM);\n       fprintf (dump_file, \" transformation on insn \");\n       print_gimple_stmt (dump_file, stmt, 0, TDF_SLIM);\n       fprintf (dump_file, \" to \");"}, {"sha": "dbcb1bfb56d35e3cf4d998dc84ff3198f5033733", "filename": "gcc/varasm.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -5431,13 +5431,13 @@ find_decl_and_mark_needed (tree decl, tree target)\n   if (fnode)\n     {\n       cgraph_mark_needed_node (fnode);\n-      return fnode->decl;\n+      return fnode->symbol.decl;\n     }\n   else if (vnode)\n     {\n       varpool_mark_needed_node (vnode);\n       vnode->force_output = 1;\n-      return vnode->decl;\n+      return vnode->symbol.decl;\n     }\n   else\n     return NULL_TREE;\n@@ -6900,20 +6900,20 @@ default_binds_local_p_1 (const_tree exp, int shlib)\n       && (TREE_STATIC (exp) || DECL_EXTERNAL (exp)))\n     {\n       struct varpool_node *vnode = varpool_get_node (exp);\n-      if (vnode && resolution_local_p (vnode->resolution))\n+      if (vnode && resolution_local_p (vnode->symbol.resolution))\n \tresolved_locally = true;\n       if (vnode\n-\t  && resolution_to_local_definition_p (vnode->resolution))\n+\t  && resolution_to_local_definition_p (vnode->symbol.resolution))\n \tresolved_to_local_def = true;\n     }\n   else if (TREE_CODE (exp) == FUNCTION_DECL && TREE_PUBLIC (exp))\n     {\n       struct cgraph_node *node = cgraph_get_node (exp);\n       if (node\n-\t  && resolution_local_p (node->resolution))\n+\t  && resolution_local_p (node->symbol.resolution))\n \tresolved_locally = true;\n       if (node\n-\t  && resolution_to_local_definition_p (node->resolution))\n+\t  && resolution_to_local_definition_p (node->symbol.resolution))\n \tresolved_to_local_def = true;\n     }\n \n@@ -6994,15 +6994,15 @@ decl_binds_to_current_def_p (tree decl)\n     {\n       struct varpool_node *vnode = varpool_get_node (decl);\n       if (vnode\n-\t  && vnode->resolution != LDPR_UNKNOWN)\n-\treturn resolution_to_local_definition_p (vnode->resolution);\n+\t  && vnode->symbol.resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (vnode->symbol.resolution);\n     }\n   else if (TREE_CODE (decl) == FUNCTION_DECL)\n     {\n       struct cgraph_node *node = cgraph_get_node (decl);\n       if (node\n-\t  && node->resolution != LDPR_UNKNOWN)\n-\treturn resolution_to_local_definition_p (node->resolution);\n+\t  && node->symbol.resolution != LDPR_UNKNOWN)\n+\treturn resolution_to_local_definition_p (node->symbol.resolution);\n     }\n   /* Otherwise we have to assume the worst for DECL_WEAK (hidden weaks\n      binds locally but still can be overwritten)."}, {"sha": "d81aec97e9cb2949174f29eec19dc33bf993498f", "filename": "gcc/varpool.c", "status": "modified", "additions": 101, "deletions": 98, "changes": 199, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/960bfb6929fa5c463267b962b9ff9dabdb6df3f3/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=960bfb6929fa5c463267b962b9ff9dabdb6df3f3", "patch": "@@ -49,11 +49,11 @@ along with GCC; see the file COPYING3.  If not see\n     explicitly marked by frontend via VARPOOL_FINALIZE_DECL function.  */\n \n /* Hash table used to convert declarations into nodes.  */\n-static GTY((param_is (struct varpool_node))) htab_t varpool_hash;\n+static GTY((param_is (union symtab_node_def))) htab_t varpool_hash;\n \n /* The linked list of cgraph varpool nodes.\n    Linked via node->next pointer.  */\n-struct varpool_node *varpool_nodes;\n+symtab_node x_varpool_nodes;\n \n /* Queue of cgraph nodes scheduled to be lowered and output.\n    The queue is maintained via mark_needed_node, linked via node->next_needed\n@@ -72,9 +72,11 @@ struct varpool_node *varpool_nodes;\n    FIRST_UNANALYZED_NODE points to first node in queue that was not analyzed\n    yet and is moved via VARPOOL_ANALYZE_PENDING_DECLS.  */\n \n-struct varpool_node *varpool_nodes_queue;\n-static GTY(()) struct varpool_node *varpool_last_needed_node;\n-static GTY(()) struct varpool_node *varpool_first_unanalyzed_node;\n+symtab_node x_varpool_nodes_queue;\n+static GTY(()) symtab_node x_varpool_last_needed_node;\n+#define varpool_last_needed_node ((struct varpool_node *)x_varpool_last_needed_node)\n+static GTY(()) symtab_node x_varpool_first_unanalyzed_node;\n+#define varpool_first_unanalyzed_node ((struct varpool_node *)x_varpool_first_unanalyzed_node)\n \n /* Lists all assembled variables to be sent to debugger output later on.  */\n static GTY(()) struct varpool_node *varpool_assembled_nodes_queue;\n@@ -83,15 +85,15 @@ static GTY(()) struct varpool_node *varpool_assembled_nodes_queue;\n const char *\n varpool_node_name (struct varpool_node *node)\n {\n-  return lang_hooks.decl_printable_name (node->decl, 2);\n+  return lang_hooks.decl_printable_name (node->symbol.decl, 2);\n }\n \n /* Returns a hash code for P.  */\n static hashval_t\n hash_varpool_node (const void *p)\n {\n   const struct varpool_node *n = (const struct varpool_node *) p;\n-  return (hashval_t) DECL_UID (n->decl);\n+  return (hashval_t) DECL_UID (n->symbol.decl);\n }\n \n /* Returns nonzero if P1 and P2 are equal.  */\n@@ -102,7 +104,7 @@ eq_varpool_node (const void *p1, const void *p2)\n     (const struct varpool_node *) p1;\n   const struct varpool_node *n2 =\n     (const struct varpool_node *) p2;\n-  return DECL_UID (n1->decl) == DECL_UID (n2->decl);\n+  return DECL_UID (n1->symbol.decl) == DECL_UID (n2->symbol.decl);\n }\n \n /* Return varpool node assigned to DECL without creating new one.  */\n@@ -116,7 +118,7 @@ varpool_get_node (const_tree decl)\n \n   if (!varpool_hash)\n     return NULL;\n-  key.decl = CONST_CAST2 (tree, const_tree, decl);\n+  key.symbol.decl = CONST_CAST2 (tree, const_tree, decl);\n   slot = (struct varpool_node **)\n     htab_find_slot (varpool_hash, &key, NO_INSERT);\n   if (!slot)\n@@ -136,20 +138,20 @@ varpool_node (tree decl)\n   if (!varpool_hash)\n     varpool_hash = htab_create_ggc (10, hash_varpool_node,\n \t\t\t\t\t   eq_varpool_node, NULL);\n-  key.decl = decl;\n+  key.symbol.decl = decl;\n   slot = (struct varpool_node **)\n     htab_find_slot (varpool_hash, &key, INSERT);\n   if (*slot)\n     return *slot;\n   node = ggc_alloc_cleared_varpool_node ();\n   node->symbol.type = SYMTAB_VARIABLE;\n-  node->decl = decl;\n-  node->order = cgraph_order++;\n+  node->symbol.decl = decl;\n+  node->symbol.order = cgraph_order++;\n   node->next = varpool_nodes;\n-  ipa_empty_ref_list (&node->ref_list);\n+  ipa_empty_ref_list (&node->symbol.ref_list);\n   if (varpool_nodes)\n-    varpool_nodes->prev = node;\n-  varpool_nodes = node;\n+    varpool (x_varpool_nodes)->prev = node;\n+  x_varpool_nodes = (symtab_node)node;\n   *slot = node;\n   return node;\n }\n@@ -170,39 +172,39 @@ varpool_remove_node (struct varpool_node *node)\n   else\n     {\n       gcc_assert (varpool_nodes == node);\n-      varpool_nodes = node->next;\n+      x_varpool_nodes = (symtab_node)node->next;\n     }\n   if (varpool_first_unanalyzed_node == node)\n-    varpool_first_unanalyzed_node = node->next_needed;\n+    x_varpool_first_unanalyzed_node = (symtab_node)node->next_needed;\n   if (node->next_needed)\n     node->next_needed->prev_needed = node->prev_needed;\n   else if (node->prev_needed)\n     {\n       gcc_assert (varpool_last_needed_node);\n-      varpool_last_needed_node = node->prev_needed;\n+      x_varpool_last_needed_node = (symtab_node)node->prev_needed;\n     }\n   if (node->prev_needed)\n     node->prev_needed->next_needed = node->next_needed;\n   else if (node->next_needed)\n     {\n       gcc_assert (varpool_nodes_queue == node);\n-      varpool_nodes_queue = node->next_needed;\n+      x_varpool_nodes_queue = (symtab_node)node->next_needed;\n     }\n-  if (node->same_comdat_group)\n+  if (node->symbol.same_comdat_group)\n     {\n-      struct varpool_node *prev;\n-      for (prev = node->same_comdat_group;\n-\t   prev->same_comdat_group != node;\n-\t   prev = prev->same_comdat_group)\n+      symtab_node prev;\n+      for (prev = node->symbol.same_comdat_group;\n+\t   prev->symbol.same_comdat_group != (symtab_node)node;\n+\t   prev = prev->symbol.same_comdat_group)\n \t;\n-      if (node->same_comdat_group == prev)\n-\tprev->same_comdat_group = NULL;\n+      if (node->symbol.same_comdat_group == prev)\n+\tprev->symbol.same_comdat_group = NULL;\n       else\n-\tprev->same_comdat_group = node->same_comdat_group;\n-      node->same_comdat_group = NULL;\n+\tprev->symbol.same_comdat_group = (symtab_node)node->symbol.same_comdat_group;\n+      node->symbol.same_comdat_group = NULL;\n     }\n-  ipa_remove_all_references (&node->ref_list);\n-  ipa_remove_all_refering (&node->ref_list);\n+  ipa_remove_all_references (&node->symbol.ref_list);\n+  ipa_remove_all_refering (&node->symbol.ref_list);\n   ggc_free (node);\n }\n \n@@ -215,11 +217,11 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n \t   cgraph_function_flags_ready\n \t   ? cgraph_availability_names[cgraph_variable_initializer_availability (node)]\n \t   : \"not-ready\");\n-  if (DECL_ASSEMBLER_NAME_SET_P (node->decl))\n-    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->decl)));\n-  if (DECL_INITIAL (node->decl))\n+  if (DECL_ASSEMBLER_NAME_SET_P (node->symbol.decl))\n+    fprintf (f, \" (asm: %s)\", IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (node->symbol.decl)));\n+  if (DECL_INITIAL (node->symbol.decl))\n     fprintf (f, \" initialized\");\n-  if (TREE_ASM_WRITTEN (node->decl))\n+  if (TREE_ASM_WRITTEN (node->symbol.decl))\n     fprintf (f, \" (asm written)\");\n   if (node->needed)\n     fprintf (f, \" needed\");\n@@ -229,20 +231,20 @@ dump_varpool_node (FILE *f, struct varpool_node *node)\n     fprintf (f, \" finalized\");\n   if (node->output)\n     fprintf (f, \" output\");\n-  if (node->externally_visible)\n+  if (node->symbol.externally_visible)\n     fprintf (f, \" externally_visible\");\n-  if (node->resolution != LDPR_UNKNOWN)\n+  if (node->symbol.resolution != LDPR_UNKNOWN)\n     fprintf (f, \" %s\",\n- \t     ld_plugin_symbol_resolution_names[(int)node->resolution]);\n-  if (node->in_other_partition)\n+ \t     ld_plugin_symbol_resolution_names[(int)node->symbol.resolution]);\n+  if (node->symbol.in_other_partition)\n     fprintf (f, \" in_other_partition\");\n-  else if (node->used_from_other_partition)\n+  else if (node->symbol.used_from_other_partition)\n     fprintf (f, \" used_from_other_partition\");\n   fprintf (f, \"\\n\");\n   fprintf (f, \"  References: \");\n-  ipa_dump_references (f, &node->ref_list);\n+  ipa_dump_references (f, &node->symbol.ref_list);\n   fprintf (f, \"  Refering this var: \");\n-  ipa_dump_refering (f, &node->ref_list);\n+  ipa_dump_refering (f, &node->symbol.ref_list);\n }\n \n /* Dump the variable pool.  */\n@@ -271,7 +273,7 @@ varpool_node_for_asm (tree asmname)\n   struct varpool_node *node;\n \n   for (node = varpool_nodes; node ; node = node->next)\n-    if (decl_assembler_name_equal (node->decl, asmname))\n+    if (decl_assembler_name_equal (node->symbol.decl, asmname))\n       return node;\n \n   return NULL;\n@@ -287,13 +289,13 @@ varpool_enqueue_needed_node (struct varpool_node *node)\n       varpool_last_needed_node->next_needed = node;\n       node->prev_needed = varpool_last_needed_node;\n     }\n-  varpool_last_needed_node = node;\n+  x_varpool_last_needed_node = (symtab_node)node;\n   node->next_needed = NULL;\n   if (!varpool_nodes_queue)\n-    varpool_nodes_queue = node;\n+    x_varpool_nodes_queue = (symtab_node)node;\n   if (!varpool_first_unanalyzed_node)\n-    varpool_first_unanalyzed_node = node;\n-  notice_global_symbol (node->decl);\n+    x_varpool_first_unanalyzed_node = (symtab_node)node;\n+  notice_global_symbol (node->symbol.decl);\n }\n \n /* Notify finalize_compilation_unit that given node is reachable\n@@ -302,7 +304,7 @@ void\n varpool_mark_needed_node (struct varpool_node *node)\n {\n   if (!node->needed && node->finalized\n-      && !TREE_ASM_WRITTEN (node->decl))\n+      && !TREE_ASM_WRITTEN (node->symbol.decl))\n     varpool_enqueue_needed_node (node);\n   node->needed = 1;\n }\n@@ -311,9 +313,9 @@ varpool_mark_needed_node (struct varpool_node *node)\n void\n varpool_reset_queue (void)\n {\n-  varpool_last_needed_node = NULL;\n-  varpool_nodes_queue = NULL;\n-  varpool_first_unanalyzed_node = NULL;\n+  x_varpool_last_needed_node = NULL;\n+  x_varpool_nodes_queue = NULL;\n+  x_varpool_first_unanalyzed_node = NULL;\n }\n \n /* Determine if variable DECL is needed.  That is, visible to something\n@@ -405,8 +407,8 @@ varpool_finalize_decl (tree decl)\n   if (TREE_THIS_VOLATILE (decl) || DECL_PRESERVE_P (decl)\n       /* Traditionally we do not eliminate static variables when not\n \t optimizing and when not doing toplevel reoder.  */\n-      || (!flag_toplevel_reorder && !DECL_COMDAT (node->decl)\n-\t  && !DECL_ARTIFICIAL (node->decl)))\n+      || (!flag_toplevel_reorder && !DECL_COMDAT (node->symbol.decl)\n+\t  && !DECL_ARTIFICIAL (node->symbol.decl)))\n     node->force_output = true;\n \n   if (decide_is_variable_needed (node, decl))\n@@ -426,7 +428,7 @@ varpool_add_new_variable (tree decl)\n   varpool_finalize_decl (decl);\n   node = varpool_node (decl);\n   if (varpool_externally_visible_p (node, false))\n-    node->externally_visible = true;\n+    node->symbol.externally_visible = true;\n }\n \n /* Return variable availability.  See cgraph.h for description of individual\n@@ -437,12 +439,12 @@ cgraph_variable_initializer_availability (struct varpool_node *node)\n   gcc_assert (cgraph_function_flags_ready);\n   if (!node->finalized)\n     return AVAIL_NOT_AVAILABLE;\n-  if (!TREE_PUBLIC (node->decl))\n+  if (!TREE_PUBLIC (node->symbol.decl))\n     return AVAIL_AVAILABLE;\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n      care of at least two notable extensions - the COMDAT variables\n      used to share template instantiations in C++.  */\n-  if (!decl_replaceable_p (node->decl))\n+  if (!decl_replaceable_p (node->symbol.decl))\n     return AVAIL_OVERWRITABLE;\n   return AVAIL_AVAILABLE;\n }\n@@ -458,12 +460,12 @@ varpool_analyze_pending_decls (void)\n   while (varpool_first_unanalyzed_node)\n     {\n       struct varpool_node *node = varpool_first_unanalyzed_node, *next;\n-      tree decl = node->decl;\n+      tree decl = node->symbol.decl;\n       bool analyzed = node->analyzed;\n \n       varpool_first_unanalyzed_node->analyzed = true;\n \n-      varpool_first_unanalyzed_node = varpool_first_unanalyzed_node->next_needed;\n+      x_varpool_first_unanalyzed_node = (symtab_node)varpool_first_unanalyzed_node->next_needed;\n \n       /* When reading back varpool at LTO time, we re-construct the queue in order\n          to have \"needed\" list right by inserting all needed nodes into varpool.\n@@ -484,48 +486,49 @@ varpool_analyze_pending_decls (void)\n \t       n = n->analyzed ? varpool_alias_aliased_node (n) : NULL)\n \t    if (n == node)\n \t      {\n-\t\terror (\"variable %q+D part of alias cycle\", node->decl);\n+\t\terror (\"variable %q+D part of alias cycle\", node->symbol.decl);\n \t\tnode->alias = false;\n \t\tcontinue;\n \t      }\n-\t  if (!VEC_length (ipa_ref_t, node->ref_list.references))\n+\t  if (!VEC_length (ipa_ref_t, node->symbol.ref_list.references))\n \t    ipa_record_reference (NULL, node, NULL, tgt, IPA_REF_ALIAS, NULL);\n \t  /* C++ FE sometimes change linkage flags after producing same body aliases.  */\n \t  if (node->extra_name_alias)\n \t    {\n-\t      DECL_WEAK (node->decl) = DECL_WEAK (node->alias_of);\n-\t      TREE_PUBLIC (node->decl) = TREE_PUBLIC (node->alias_of);\n-\t      DECL_EXTERNAL (node->decl) = DECL_EXTERNAL (node->alias_of);\n-\t      DECL_VISIBILITY (node->decl) = DECL_VISIBILITY (node->alias_of);\n-\t      if (TREE_PUBLIC (node->decl))\n+\t      DECL_WEAK (node->symbol.decl) = DECL_WEAK (node->alias_of);\n+\t      TREE_PUBLIC (node->symbol.decl) = TREE_PUBLIC (node->alias_of);\n+\t      DECL_EXTERNAL (node->symbol.decl) = DECL_EXTERNAL (node->alias_of);\n+\t      DECL_VISIBILITY (node->symbol.decl) = DECL_VISIBILITY (node->alias_of);\n+\t      if (TREE_PUBLIC (node->symbol.decl))\n \t\t{\n-\t\t  DECL_COMDAT (node->decl) = DECL_COMDAT (node->alias_of);\n-\t\t  DECL_COMDAT_GROUP (node->decl) = DECL_COMDAT_GROUP (node->alias_of);\n-\t\t  if (DECL_ONE_ONLY (node->alias_of) && !node->same_comdat_group)\n+\t\t  DECL_COMDAT (node->symbol.decl) = DECL_COMDAT (node->alias_of);\n+\t\t  DECL_COMDAT_GROUP (node->symbol.decl) = DECL_COMDAT_GROUP (node->alias_of);\n+\t\t  if (DECL_ONE_ONLY (node->alias_of)\n+\t\t      && !node->symbol.same_comdat_group)\n \t\t    {\n-\t\t      node->same_comdat_group = tgt;\n-\t\t      if (!tgt->same_comdat_group)\n-\t\t\ttgt->same_comdat_group = node;\n+\t\t      node->symbol.same_comdat_group = (symtab_node)tgt;\n+\t\t      if (!tgt->symbol.same_comdat_group)\n+\t\t\ttgt->symbol.same_comdat_group = (symtab_node)node;\n \t\t      else\n \t\t\t{\n-\t\t\t  struct varpool_node *n;\n-\t\t\t  for (n = tgt->same_comdat_group;\n-\t\t\t       n->same_comdat_group != tgt;\n-\t\t\t       n = n->same_comdat_group)\n+\t\t\t  symtab_node n;\n+\t\t\t  for (n = tgt->symbol.same_comdat_group;\n+\t\t\t       n->symbol.same_comdat_group != (symtab_node)tgt;\n+\t\t\t       n = n->symbol.same_comdat_group)\n \t\t\t    ;\n-\t\t\t  n->same_comdat_group = node;\n+\t\t\t  n->symbol.same_comdat_group = (symtab_node)node;\n \t\t\t}\n \t\t    }\n \t\t}\n \t    }\n \t}\n       else if (DECL_INITIAL (decl))\n \trecord_references_in_initializer (decl, analyzed);\n-      if (node->same_comdat_group)\n+      if (node->symbol.same_comdat_group)\n \t{\n-\t  for (next = node->same_comdat_group;\n+\t  for (next = varpool (node->symbol.same_comdat_group);\n \t       next != node;\n-\t       next = next->same_comdat_group)\n+\t       next = varpool (next->symbol.same_comdat_group))\n \t    varpool_mark_needed_node (next);\n \t}\n       changed = true;\n@@ -541,11 +544,11 @@ assemble_aliases (struct varpool_node *node)\n {\n   int i;\n   struct ipa_ref *ref;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);\n-\tassemble_alias (alias->decl,\n+\tassemble_alias (alias->symbol.decl,\n \t\t\tDECL_ASSEMBLER_NAME (alias->alias_of));\n \tassemble_aliases (alias);\n       }\n@@ -555,11 +558,11 @@ assemble_aliases (struct varpool_node *node)\n bool\n varpool_assemble_decl (struct varpool_node *node)\n {\n-  tree decl = node->decl;\n+  tree decl = node->symbol.decl;\n \n   if (!TREE_ASM_WRITTEN (decl)\n       && !node->alias\n-      && !node->in_other_partition\n+      && !node->symbol.in_other_partition\n       && !DECL_EXTERNAL (decl)\n       && (TREE_CODE (decl) != VAR_DECL || !DECL_HAS_VALUE_EXPR_P (decl)))\n     {\n@@ -606,7 +609,7 @@ varpool_remove_unreferenced_decls (void)\n \t  && (!varpool_can_remove_if_no_refs (node)\n \t      /* We just expanded all function bodies.  See if any of\n \t\t them needed the variable.  */\n-\t      || DECL_RTL_SET_P (node->decl)))\n+\t      || DECL_RTL_SET_P (node->symbol.decl)))\n \tvarpool_mark_needed_node (node);\n \n       node = next;\n@@ -623,14 +626,14 @@ varpool_remove_unreferenced_decls (void)\n void\n varpool_finalize_named_section_flags (struct varpool_node *node)\n {\n-  if (!TREE_ASM_WRITTEN (node->decl)\n+  if (!TREE_ASM_WRITTEN (node->symbol.decl)\n       && !node->alias\n-      && !node->in_other_partition\n-      && !DECL_EXTERNAL (node->decl)\n-      && TREE_CODE (node->decl) == VAR_DECL\n-      && !DECL_HAS_VALUE_EXPR_P (node->decl)\n-      && DECL_SECTION_NAME (node->decl))\n-    get_variable_section (node->decl, false);\n+      && !node->symbol.in_other_partition\n+      && !DECL_EXTERNAL (node->symbol.decl)\n+      && TREE_CODE (node->symbol.decl) == VAR_DECL\n+      && !DECL_HAS_VALUE_EXPR_P (node->symbol.decl)\n+      && DECL_SECTION_NAME (node->symbol.decl))\n+    get_variable_section (node->symbol.decl, false);\n }\n \n /* Output all variables enqueued to be assembled.  */\n@@ -656,7 +659,7 @@ varpool_assemble_pending_decls (void)\n     {\n       struct varpool_node *node = varpool_nodes_queue;\n \n-      varpool_nodes_queue = varpool_nodes_queue->next_needed;\n+      x_varpool_nodes_queue = (symtab_node)(varpool_nodes_queue->next_needed);\n       if (varpool_assemble_decl (node))\n \tchanged = true;\n       else\n@@ -667,7 +670,7 @@ varpool_assemble_pending_decls (void)\n     }\n   /* varpool_nodes_queue is now empty, clear the pointer to the last element\n      in the queue.  */\n-  varpool_last_needed_node = NULL;\n+  x_varpool_last_needed_node = NULL;\n   timevar_pop (TV_VAROUT);\n   return changed;\n }\n@@ -684,13 +687,13 @@ varpool_empty_needed_queue (void)\n   while (varpool_nodes_queue)\n     {\n       struct varpool_node *node = varpool_nodes_queue;\n-      varpool_nodes_queue = varpool_nodes_queue->next_needed;\n+      x_varpool_nodes_queue = (symtab_node)varpool_nodes_queue->next_needed;\n       node->next_needed = NULL;\n       node->prev_needed = NULL;\n     }\n   /* varpool_nodes_queue is now empty, clear the pointer to the last element\n      in the queue.  */\n-  varpool_last_needed_node = NULL;\n+  x_varpool_last_needed_node = NULL;\n }\n \n /* Create a new global variable of type TYPE.  */\n@@ -714,7 +717,7 @@ add_new_static_var (tree type)\n   add_referenced_var (new_decl);\n   varpool_finalize_decl (new_decl);\n \n-  return new_node->decl;\n+  return new_node->symbol.decl;\n }\n \n /* Attempt to mark ALIAS as an alias to DECL.  Return TRUE if successful.\n@@ -762,9 +765,9 @@ varpool_extra_name_alias (tree alias, tree decl)\n bool\n varpool_used_from_object_file_p (struct varpool_node *node)\n {\n-  if (!TREE_PUBLIC (node->decl))\n+  if (!TREE_PUBLIC (node->symbol.decl))\n     return false;\n-  if (resolution_used_from_other_file_p (node->resolution))\n+  if (resolution_used_from_other_file_p (node->symbol.resolution))\n     return true;\n   return false;\n }\n@@ -784,7 +787,7 @@ varpool_for_node_and_aliases (struct varpool_node *node,\n \n   if (callback (node, data))\n     return true;\n-  for (i = 0; ipa_ref_list_refering_iterate (&node->ref_list, i, ref); i++)\n+  for (i = 0; ipa_ref_list_refering_iterate (&node->symbol.ref_list, i, ref); i++)\n     if (ref->use == IPA_REF_ALIAS)\n       {\n \tstruct varpool_node *alias = ipa_ref_refering_varpool_node (ref);"}]}