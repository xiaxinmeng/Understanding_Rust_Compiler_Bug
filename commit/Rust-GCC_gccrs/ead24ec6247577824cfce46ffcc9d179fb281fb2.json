{"sha": "ead24ec6247577824cfce46ffcc9d179fb281fb2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWFkMjRlYzYyNDc1Nzc4MjRjZmNlNDZmZmNjOWQxNzlmYjI4MWZiMg==", "commit": {"author": {"name": "Philip Herron", "email": "phil@nebuloninc.com", "date": "2020-04-12T13:25:46Z"}, "committer": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2020-11-27T16:57:47Z"}, "message": "Rebase GCCRS against SimplyTheOthers c++11 AST.\n\nWe can use this as a common base to build upon. It contains a fully\nobject orientated c++11 AST.", "tree": {"sha": "14fca13cebe8cbf2b5c6c9313818b97abbc4d1e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/14fca13cebe8cbf2b5c6c9313818b97abbc4d1e8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ead24ec6247577824cfce46ffcc9d179fb281fb2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead24ec6247577824cfce46ffcc9d179fb281fb2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ead24ec6247577824cfce46ffcc9d179fb281fb2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ead24ec6247577824cfce46ffcc9d179fb281fb2/comments", "author": null, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "9ccce9982b37580c6d1232cb6224b44c1f46a978", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9ccce9982b37580c6d1232cb6224b44c1f46a978", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9ccce9982b37580c6d1232cb6224b44c1f46a978"}], "stats": {"total": 164201, "additions": 2484, "deletions": 161717}, "files": [{"sha": "e5b4d3d8261c61205d37a63ecc57d19f280ad23e", "filename": "gcc/rust/Make-lang.in", "status": "modified", "additions": 146, "deletions": 163, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FMake-lang.in?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -1,6 +1,6 @@\n-# Make-lang.in -- Top level -*- makefile -*- fragment for gcc Go frontend.\n+# Make-lang.in -- Top level -*- makefile -*- fragment for GCC Rust frontend.\n \n-# Copyright (C) 2009-2019 Free Software Foundation, Inc.\n+# Copyright (C) 2009-2013 Free Software Foundation, Inc.\n \n # This file is part of GCC.\n \n@@ -20,189 +20,171 @@\n \n # This file provides the language dependent support in the main Makefile.\n \n-# Installation name.\n+#RUST_EXES = rust\n \n-RSFLEXFLAGS=\n-RSBISONFLAGS=-v --debug\n+# Use strict warnings for this front end.\n+rust-warn = $(STRICT_WARN)\n \n-GCCRUST_INSTALL_NAME := $(shell echo gccrust|sed '$(program_transform_name)')\n-GCCRUST_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccrust|sed '$(program_transform_name)')\n+# Installation name. Useful for cross compilers and used during install.\n+GCCRS_INSTALL_NAME := $(shell echo gccrs|sed '$(program_transform_name)')\n+GCCRS_TARGET_INSTALL_NAME := $(target_noncanonical)-$(shell echo gccrs|sed '$(program_transform_name)')\n \n-# The name for selecting rust in LANGUAGES.\n-rust: rust1$(exeext)\n+# Define the names for selecting rust in LANGUAGES.\n+rust: gccrs$(exeext) grs1$(exeext)\n \n+# Tell GNU make to ignore files by these names if they exist.\n .PHONY: rust\n \n-CFLAGS-rust/rustspec.o += $(DRIVER_DEFINES)\n-\n-GCCRUST_OBJS = $(GCC_OBJS) rust/rustspec.o\n-gccrust$(exeext): $(GCCRUST_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)\n-\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t  $(GCCRUST_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n-\t  $(EXTRA_GCC_LIBS) $(LIBS)\n+# removed GRS_CFLAGS from here\n \n-# The cross-compiler version.  This is built mainly as a signal to the\n-# rust.install-common target.  If this executable exists, it means that\n-# rust.all.cross was run.\n-gccrust-cross$(exeext): gccrust$(exeext)\n-\t-rm -f gccrust-cross$(exeext)\n-\tcp gccrust$(exeext) gccrust-cross$(exeext)\n+CFLAGS-rust/rustspec.o += $(DRIVER_DEFINES)\n \n-# Use strict warnings.\n-rust-warn = $(STRICT_WARN)\n+# Create the compiler driver gccrs.\n+# A compiler driver is the program that interprets command argument and can be called from the command\n+# line - e.g. gcc or g++, and not cc1, which is the actual compiler\n \n-RUST_OBJS = \\\n-\trust/rust-lang.o \\\n-\trust/rust-backend.o \\\n-\trust/rust-linemap.o \\\n-\trust/rust-gcc-diagnostics.o \\\n-\trust/rust-gcc.o \\\n-\trust/node.o \\\n-\trust/rs-parser.o \\\n-\trust/rs-lexer.o \\\n-\trust/rustly.o\n+# Create driver objects\n+GCCRS_D_OBJS = \\\n+   $(GCC_OBJS) \\\n+   rust/rustspec.o \\\n+   $(END)\n \n-rust_OBJS = $(RUST_OBJS) rust/rustspec.o\n+gccrs$(exeext): $(GCCRS_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a $(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  $(GCCRS_D_OBJS) $(EXTRA_GCC_OBJS) libcommon-target.a \\\n+\t  $(EXTRA_GCC_LIBS) $(LIBS)\n \n-rust1$(exeext): $(RUST_OBJS) attribs.o $(BACKEND) $(LIBDEPS)\n+# List of host object files used by the rust language - files for translation from the parse tree \n+# to GENERIC\n+# The compiler proper, not driver\n+GRS_OBJS = \\\n+    rust/rust-lang.o \\\n+    rust/rust-object-export.o \\\n+    rust/rust-linemap.o \\\n+    rust/rust-gcc-diagnostics.o \\\n+    rust/rust-gcc.o \\\n+    rust/rust-token.o \\\n+    rust/rust-lex.o \\\n+    rust/rust-parse.o \\\n+    rust/rust-scope.o \\\n+    rust/rust-ast-full-test.o \\\n+    rust/rust-session-manager.o \\\n+    $(END)\n+# removed object files from here \n+\n+# The compiler itself is called grs1\n+grs1$(exeext): $(GRS_OBJS) attribs.o  $(BACKEND) $(LIBDEPS)\n \t+$(LLINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n-\t      $(RUST_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n+\t      $(GRS_OBJS) attribs.o $(BACKEND) $(LIBS) $(BACKENDLIBS)\n \n-# Documentation.\n+# Build hooks.\n \n-RUST_TEXI_FILES = \\\n-\trust/gccrust.texi \\\n-\t$(gcc_docdir)/include/fdl.texi \\\n-\t$(gcc_docdir)/include/gpl_v3.texi \\\n-\t$(gcc_docdir)/include/gcc-common.texi \\\n-\tgcc-vers.texi\n+# Copies its dependencies into the source directory. This generally should be used for generated files\n+# such as Bison output files which are not version-controlled, but should be included in any release \n+# tarballs. This target will be executed during a bootstrap if \u2018--enable-generated-files-in-srcdir\u2019 \n+# was specified as a configure option. \n+rust.srcextra: \n \n-doc/gccrust.info: $(RUST_TEXI_FILES)\n-\tif test \"x$(BUILD_INFO)\" = xinfo; then \\\n-\t  rm -f doc/gccrust.info*; \\\n-\t  $(MAKEINFO) $(MAKEINFOFLAGS) -I $(gcc_docdir) \\\n-\t\t-I $(gcc_docdir)/include -o $@ $<; \\\n-\telse true; fi\n+rust.all.cross:\n \n-doc/gccrust.dvi: $(RUST_TEXI_FILES)\n-\t$(TEXI2DVI) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+# idk what this does but someone used it\n+rust.start.encap: gccrs$(exeext)\n+rust.rest.encap:\n \n-doc/gccrust.pdf: $(RUST_TEXI_FILES)\n-\t$(TEXI2PDF) -I $(abs_docdir) -I $(abs_docdir)/include -o $@ $<\n+# Build generated man pages for the front end from Texinfo manuals (see Man Page Generation), in the \n+# build directory. This target is only called if the necessary tools are available, but should ignore \n+# errors so as not to stop the build if errors occur; man pages are optional and the tools involved \n+# may be installed in a broken way. \n+rust.man:\n \n-$(build_htmldir)/rust/index.html: $(RUST_TEXI_FILES)\n-\t$(mkinstalldirs) $(@D)\n-\trm -f $(@D)/*\n-\t$(TEXI2HTML) -I $(gcc_docdir) -I $(gcc_docdir)/include \\\n-\t\t-I $(srcdir)/rust -o $(@D) $<\n+# Copies its dependencies into the source directory. These targets will be executed during a bootstrap\n+# if \u2018--enable-generated-files-in-srcdir\u2019 was specified as a configure option. \n+rust.srcman:\n \n-# .INTERMEDIATE: gccrust.pod\n+# Clean hooks.\n \n-# gccrust.pod: rust/gccrust.texi\n-# \t-$(TEXI2POD) -D gccrust < $< > $@\n+rust.mostlyclean:\n+#\tcd $(srcdir)/rust; rm -f *.o y.tab.h y.tab.c lex.yy.c\n \n-# Build hooks.\n+rust.clean: rust.mostlyclean\n \n-rust.all.cross: gccrust-cross$(exeext)\n-rust.start.encap: gccrust$(exeext)\n-rust.rest.encap:\n-rust.info: doc/gccrust.info\n-rust.dvi: doc/gccrust.dvi\n-rust.pdf: doc/gccrust.pdf\n-rust.html: $(build_htmldir)/rust/index.html\n-rust.srcinfo: doc/gccrust.info\n-\t-cp -p $^ $(srcdir)/doc\n-rust.srcextra:\n+# Builds an etags TAGS file in the language subdirectory in the source tree.\n+# TODO: add more directories if I add more \n rust.tags: force\n \tcd $(srcdir)/rust; \\\n-\tetags -o TAGS.sub *.c *.h rustfrontend/*.h rustfrontend/*.cc; \\\n+\tetags -o TAGS.sub *.y *.l *.cc *.h ast/*.h ast/*.cc lex/*.h lex/*.cc parse/*.h parse/*.cc; \\\n \tetags --include TAGS.sub --include ../TAGS.sub\n-rust.man:\n-# rust.man: doc/gccrust.1\n-# rust.srcman: doc/gccrust.1\n-# \t-cp -p $^ $(srcdir)/doc\n \n-lang_checks += check-rust\n-lang_checks_parallelized += check-rust\n-check_rust_parallelize = 10\n+# Build documentation hooks.\n \n-# No rust-specific selftests\n-selftest-rust:\n+# Build info documentation for the front end, in the build directory. This target is only called by \n+# \u2018make bootstrap\u2019 if a suitable version of makeinfo is available, so does not need to check for this, \n+# and should fail if an error occurs. \n+rust.info: \n+\n+rust.srcinfo: \n+\n+# Build DVI documentation for the front end, in the build directory. This should be done using \n+# $(TEXI2DVI), with appropriate -I arguments pointing to directories of included files. \n+rust.dvi: \n+\n+# Build PDF documentation for the front end, in the build directory. This should be done using \n+# $(TEXI2PDF), with appropriate -I arguments pointing to directories of included files. \n+rust.pdf: \n+\n+doc/rust.info: \n+doc/rust.dvi: \n+doc/rust.pdf: \n+\n+# Build HTML documentation for the front end, in the build directory. \n+rust.html: \n \n # Install hooks.\n \n+# Install everything that is part of the front end, apart from the compiler executables listed in \n+# compilers in config-lang.in. \n rust.install-common: installdirs\n-\t-rm -f $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n-\t$(INSTALL_PROGRAM) gccrust$(exeext) $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n-\t-if test -f rust1$(exeext); then \\\n-\t  if test -f gccrust-cross$(exeext); then \\\n-\t    :; \\\n-\t  else \\\n-\t    rm -f $(DESTDIR)$(bindir)/$(GCCRUST_TARGET_INSTALL_NAME)$(exeext); \\\n-\t    ( cd $(DESTDIR)$(bindir) && \\\n-\t      $(LN) $(GCCRUST_INSTALL_NAME)$(exeext) $(GCCRUST_TARGET_INSTALL_NAME)$(exeext) ); \\\n-\t  fi; \\\n-\tfi\n-\n+#\t-rm -f $(DESTDIR)$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n+#\t-rm -f $(DESTDIR)$(bindir)/$(GCCRS_TARGET_INSTALL_NAME)$(exeext)\n+#\t$(INSTALL_PROGRAM) gccrs$(exeext) $(DESTDIR)$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n+#\tif test -f $(DESTDIR)$(bindir)$(GCCRS_TARGET_INSTALL_NAME)$(exeext); then \\\n+#\t  :; \\\n+#\telse \\\n+#\t  cd $(DESTDIR)$(bindir) && \\\n+#\t   $(LN) $(GCCRS_INSTALL_NAME)$(exeext) $(GCCRS_TARGET_INSTALL_NAME)$(exeext); \\\n+#\tfi\n+\t-rm -f $(DESTDIR)$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n+\t$(INSTALL_PROGRAM) gccrs$(exeext) $(DESTDIR)$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n+\trm -f $(DESTDIR)$(bindir)/$(GCCRS_TARGET_INSTALL_NAME)$(exeext); \\\n+\t( cd $(DESTDIR)$(bindir) && \\\n+      $(LN) $(GCCRS_INSTALL_NAME)$(exeext) $(GCCRS_TARGET_INSTALL_NAME)$(exeext) ); \\\n+\n+# Install headers needed for plugins. \n rust.install-plugin:\n \n-# rust.install-info: $(DESTDIR)$(infodir)/gccrust.info\n-rust.install-info:\n-\n-# rust.install-pdf: doc/gccrust.pdf\n-# \t@$(NORMAL_INSTALL)\n-# \ttest -z \"$(pdfdir)\" || $(mkinstalldirs) \"$(DESTDIR)$(pdfdir)/gcc\"\n-# \t@for p in doc/gccrust.pdf; do \\\n-# \t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n-# \t  f=$(pdf__strip_dir) \\\n-# \t  echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(pdfdir)/gcc/$$f'\"; \\\n-# \t  $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(pdfdir)/gcc/$$f\"; \\\n-# \tdone\n-rust.install-pdf:\n-\n-# rust.install-html: $(build_htmldir)/rust\n-# \t@$(NORMAL_INSTALL)\n-# \ttest -z \"$(htmldir)\" || $(mkinstalldirs) \"$(DESTDIR)$(htmldir)\"\n-# \t@for p in $(build_htmldir)/rust; do \\\n-# \t  if test -f \"$$p\" || test -d \"$$p\"; then d=\"\"; else d=\"$(srcdir)/\"; fi; \\\n-# \t  f=$(html__strip_dir) \\\n-# \t  if test -d \"$$d$$p\"; then \\\n-# \t    echo \" $(mkinstalldirs) '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-# \t    $(mkinstalldirs) \"$(DESTDIR)$(htmldir)/$$f\" || exit 1; \\\n-# \t    echo \" $(INSTALL_DATA) '$$d$$p'/* '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-# \t    $(INSTALL_DATA) \"$$d$$p\"/* \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-# \t  else \\\n-# \t    echo \" $(INSTALL_DATA) '$$d$$p' '$(DESTDIR)$(htmldir)/$$f'\"; \\\n-# \t    $(INSTALL_DATA) \"$$d$$p\" \"$(DESTDIR)$(htmldir)/$$f\"; \\\n-# \t  fi; \\\n-# \tdone\n-\n-# rust.install-man: $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n-rust.install-man:\n+# Uninstall files installed by installing the compiler. This is currently documented not to be \n+# supported, so the hook need not do anything. \n+rust.uninstall:\n+#\t-rm -rf $(DESTDIR)/$(bindir)/$(GCCRS_INSTALL_NAME)$(exeext)\n+\t-rm -f gccrs$(exeext) grs1$(exeext)\n+\t-rm -f $(GRS_OBJS)\n+# ^those two are a maybe\n \n-# $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext): doc/gccrust.1 installdirs\n-# \t-rm -f $@\n-# \t-$(INSTALL_DATA) $< $@\n-# \t-chmod a-x $@\n+# No rust-specific selftests\n+selftest-rust:\n \n-rust.uninstall:\n-\trm -rf $(DESTDIR)$(bindir)/$(GCCRUST_INSTALL_NAME)$(exeext)\n-\trm -rf $(DESTDIR)$(man1dir)/$(GCCRUST_INSTALL_NAME)$(man1ext)\n-\trm -rf $(DESTDIR)$(bindir)/$(GCCRUST_TARGET_INSTALL_NAME)$(exeext)\n-\trm -rf $(DESTDIR)$(infodir)/gccrust.info*\n+# Install info documentation for the front end, if it is present in the source directory. This target \n+# should have dependencies on info files that should be installed. \n+rust.install-info: \n \n-# Clean hooks.\n+rust.install-pdf: \n \n-rust.mostlyclean:\n-\t-rm -f rust/*$(objext)\n-\t-rm -f rust/*$(coverageexts)\n-\t-rm -f gccrust$(exeext) gccrust-cross$(exeext) rust1$(exeext)\n-rust.clean:\n-rust.distclean:\n-rust.maintainer-clean:\n-\t-rm -f $(docobjdir)/gccrust.1\n+# Install man pages for the front end. This target should ignore errors. \n+rust.install-man:\n \n-# Stage hooks.\n+# Stage hooks:\n+# The toplevel makefile has already created stage?/rust at this point.\n+# Used for handling bootstrap\n \n rust.stage1: stage1-start\n \t-mv rust/*$(objext) stage1/rust\n@@ -220,27 +202,28 @@ rust.stagefeedback: stagefeedback-start\n CFLAGS-rust/rust-lang.o += -DDEFAULT_TARGET_VERSION=\\\"$(version)\\\" \\\n \t-DDEFAULT_TARGET_MACHINE=\\\"$(target_noncanonical)\\\"\n \n-RUSTINCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/rustfrontend\n-\n-CFLAGS-rust/rust-gcc.o += $(RUSTINCLUDES)\n-CFLAGS-rust/rust-linemap.o += $(RUSTINCLUDES)\n-CFLAGS-rust/rust-gcc-diagnostics.o += $(RUSTINCLUDES)\n-CFLAGS-rust/rust-encode-id.o += $(RUSTINCLUDES)\n+# cross-folder includes - add new folders later\n+RUST_INCLUDES = -I $(srcdir)/rust -I $(srcdir)/rust/lex -I $(srcdir)/rust/parse -I $(srcdir)/rust/ast\n \n-rust/rs-parser.cc: rust/rustfrontend/rs-parser.y\n-\t$(BISON) $(RSBISONFLAGS) --defines=rust/rs-parser.h -o $@ $<\n+# add files that require cross-folder includes - currently rust-lang.o, rust-lex.o\n+CFLAGS-rust/rust-lang.o += $(RUST_INCLUDES)\n+CFLAGS-rust/rust-lex.o += $(RUST_INCLUDES)\n+CFLAGS-rust/rust-parse.o += $(RUST_INCLUDES)\n+CFLAGS-rust/rust-session-manager.o += $(RUST_INCLUDES)\n \n-rust/rs-lexer.cc: rust/rustfrontend/rs-lexer.l\n-\t$(FLEX) $(RSFLEXFLAGS) -o $@ $<\n+# TODO: possibly find a way to ensure C++11 compilation level here?\n \n-rust/rs-parser.o: rust/rs-parser.cc\n-\t$(COMPILE) $(RUSTINCLUDES) $<\n+# build all rust/lex files in rust folder, add cross-folder includes\n+rust/%.o: rust/lex/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n-rust/rs-lexer.o: rust/rs-lexer.cc\n-\t$(COMPILE) $(RUSTINCLUDES) $<\n+# build all rust/parse files in rust folder, add cross-folder includes\n+rust/%.o: rust/parse/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)\n \n-rust/%.o: rust/rustfrontend/%.cc\n-\t$(COMPILE) $(RUSTINCLUDES) $<\n+# build rust/ast files in rust folder\n+rust/%.o: rust/ast/%.cc\n+\t$(COMPILE) -std=c++11 $(RUST_INCLUDES) $<\n \t$(POSTCOMPILE)"}, {"sha": "2e290285e96a88a2950f4da3cc41e479676ca47f", "filename": "gcc/rust/TO_notes.txt", "status": "removed", "additions": 0, "deletions": 48, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2FTO_notes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2FTO_notes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2FTO_notes.txt?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,48 +0,0 @@\n-TO notes:\n-\n-This is the actual compiler frontend.\n-\n-What needs to occur in a frontend according to GCC docs:\n-\n-Parsing pass:\n--Language frontend is only invoked once via lang_hooks.parse_file (which parses any input)\n--Frontend may use any intermediate language representation deemed appropriate (i.e. could use MIR like in actual Rust, but GENERIC trees would probably be used)\n--At some point, the frontend must translate the intermediate language representation used inside it to a representation understood by the rest of the compiler (GIMPLE or maybe GENERIC). There are two current ways of doing this:\n-\t-C frontend manually invokes gimplifier on each function, and uses gimplifier callbacks to convert language-specific tree nodes directly to GIMPLE before passing function off to be compiled. \n-\t-Fortran frontend converts from private representation to GENERIC, which is later lowered to GIMPLE when the function is compiled.\n-\t-Also, a front end could generate GIMPLE directly, which is a \"moderately complex process\" but would maybe mean that more of the Rust LLVM frontend could be used without modification.\n-\t-Which route to choose depends on how well GENERIC (plus extensions) can be made to match up with the source language and necessary parsing data structures. The easiest seems to be the Fortran method, i.e. just make GENERIC. \n--Note that each function (and top level declaration) must be passed separately to the middle end or something. Function and data definitions must be passed to the middle-end, and for debug info, data and type declarations should also be passed.\n--Front end needs complete top-level function or data declaration, and each data definition should be passed to rest_of_decl_compilation . Each complete type definition should be passed to rest_of_type_compilation . Each function definition should be passed to cgraph_finalize_function .\n--Middle-end will either emit the function and data definitions immediately or queue them for later processing.\n-\n-Gimplification pass:\n--Consists of conversion of frontend's intermediate representation to GIMPLE\n--Main entry point is gimplify_function_tree in gimplify.c . From here, the entire function is processed, gimplifying each statement in turn. Main workhorse for this pass is gimplify_expr . Approximately everything passes through here at least once, and it is from here that we invoke lang_hooks.gimplify_expr callback.\n--Callback should examine the expression and return GS_UNHANDLED if the expression is not a language-specific construct that requires attention. Otherwise it should alter the expression in some way to progress towards it being valid GIMPLE. If callback is certain that transformation is complete and expression is valid GIMPLE, should return GS_ALL_DONE . Otherwise, return GS_OK , which causes expression to be processed again. If callback encounters error during transformation (because frontend relies on gimplification to finish semantic checks), return GS_ERROR .\n-\n-Pass manager:\n--Pass manager is located in passes.c, tree-optimize.c, and tree-pass.h . It processes passes as defined in passes.def . It runs all passes in correct order. etc. more stuff\n-\n-After this, the AST should be built in GIMPLE or whatever, so the middle-end and back-end of GCC take care of the rest of compilation, I hope. \n-\n-\n-\n-Notes on GENERIC:\n--A language-independent way of representing an entire _function_ in trees. If you can express it with gcc/tree.def, it's GENERIC.\n--A statement is defined as an expression whose value, if any, is ignored. A statement will always have TREE_SIDE_EFFECTS set, but a non-statement expression may also have side effects, e.g. CALL_EXPR (probably a function call).\n--Implication that frontends lower GENERIC to GIMPLE.\n-\n-Trees:\n--The central data structure, tree, is a node of C type tree. It is a pointer type, but the object it points to may be a variety of types.\n--Can tell what kind of a node a tree is by using TREE_CODE macro. Many macros take trees as input and return trees as output. Most require a certain kind of tree node as input, i.e. there is a particular type system for trees not reflected in C's type system.\n--For safety, useful to configure GCC with --enable-checking . All tree types are checked at runtime as a result, destroying performance but aiding debugging.\n--Many macros behave as predicates (a function used to test something about a supplied argument - e.g. lambda expression LINQ), and many, though not all, of these end in _P . Don't rely on result type of macros being of any particular type, but may rely on fact that type can be compared to 0, so statements like \"int i = (TEST_P(t) != 0);\" are legal. Macros that return int values now may be changed to return tree values, or other pointers in the future. Thus, should not write code like \"if (TEST_P(t) == 1)\".\n--\n-\n-\n-\n-Notes on basic outline:\n--rustc and mrustc appear to use a hand-written recursive-descent parser, not a bison-generated LALR parser.\n--I don't know if redbrain's original parser was bison LALR or handwritten recursive-descent - it seemed to have aspects of both. However, he mentioned using a bison-generated parser initially and then moving to a handwritten one later.\n--As such, own parser should probably be hand-written recursive-descent.\n\\ No newline at end of file"}, {"sha": "0c71c828e56c3eb422247026617e1014eb3b6b94", "filename": "gcc/rust/ast/clone-test.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Fclone-test.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Fclone-test.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Fclone-test.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/clone-test.h"}, {"sha": "81b01876288672bbe143668f3ae44506424aad42", "filename": "gcc/rust/ast/rust-ast-containers.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-containers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-containers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-containers.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-ast-containers.h"}, {"sha": "a76a59938f63304d5ead3e4598e31ee10268fb27", "filename": "gcc/rust/ast/rust-ast-full-decls.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full-decls.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-decls.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-ast-full-decls.h"}, {"sha": "216299d381bf0bb748978dfe0a93d7c96d97b0a8", "filename": "gcc/rust/ast/rust-ast-full-test.cc", "status": "renamed", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full-test.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -3921,7 +3921,7 @@ namespace Rust {\n             auto it = session.options.target_data.features.find(ident);\n             if (it != session.options.target_data.features.end()) {\n                 // value must also be the same, not just the name existing\n-                if (str == it->second) {\n+                if (it->second.find(str) != it->second.end()) {\n                     return true;\n                 }\n             }\n@@ -3932,7 +3932,7 @@ namespace Rust {\n             auto it = session.options.target_data.features.find(path.as_string());\n             if (it != session.options.target_data.features.end()) {\n                 // value must also be the same, not just the name existing\n-                if (lit.as_string() == it->second) {\n+                if (it->second.find(lit.as_string()) != it->second.end()) {\n                     return true;\n                 }\n             }\n@@ -4607,4 +4607,4 @@ namespace Rust {\n             vis.visit(*this);\n         }\n     }\n-}\n\\ No newline at end of file\n+}", "previous_filename": "gcc/rust/test3/ast/rust-ast-full-test.cc"}, {"sha": "53782362a52b75f8e947d08f5d25163edba2c04f", "filename": "gcc/rust/ast/rust-ast-full.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-full.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-full.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-ast-full.h"}, {"sha": "b8e92c208e1447d074624160d736e5768862cb63", "filename": "gcc/rust/ast/rust-ast-visitor.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast-visitor.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-ast-visitor.h"}, {"sha": "ebcbd258af42dd2f29051a79367e86ff622942eb", "filename": "gcc/rust/ast/rust-ast.h", "status": "renamed", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-ast.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-ast.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -10,8 +10,7 @@\n #include \"coretypes.h\" // order: config, INCLUDE, system, coretypes\n \n // STL imports\n-#include <string>\n-#include <vector>\n+#include \"rust-system.h\"\n // with C++11, now can use actual std::unique_ptr\n #include <memory>\n \n@@ -1373,4 +1372,4 @@ namespace Rust {\n     }\n }\n \n-#endif\n\\ No newline at end of file\n+#endif", "previous_filename": "gcc/rust/test3/ast/rust-ast.h"}, {"sha": "4fa6a0bde4ece23672137ffd24362452c878c29c", "filename": "gcc/rust/ast/rust-cond-compilation.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-cond-compilation.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-cond-compilation.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-cond-compilation.h"}, {"sha": "1842da927910f4f882c3fcfe434ab1353d508267", "filename": "gcc/rust/ast/rust-expr.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-expr.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-expr.h"}, {"sha": "c5154f530a6f88598222499864264e17f56cc442", "filename": "gcc/rust/ast/rust-item.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-item.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-item.h"}, {"sha": "4c8237e6efc53bcba3f21e055e89031d5a746929", "filename": "gcc/rust/ast/rust-macro.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-macro.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-macro.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-macro.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-macro.h"}, {"sha": "cddd06290ae1173f96cc43150069781805f51b49", "filename": "gcc/rust/ast/rust-path.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-path.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-path.h"}, {"sha": "f0cabee1b220c7a68ab2a288626bbad4732188ab", "filename": "gcc/rust/ast/rust-pattern.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-pattern.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-pattern.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-pattern.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-pattern.h"}, {"sha": "ece0801b8e686783c58bb1b55925cb91f7e24875", "filename": "gcc/rust/ast/rust-stmt.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-stmt.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-stmt.h"}, {"sha": "4ca408d9e4993c32489d61409e86549961cc4c02", "filename": "gcc/rust/ast/rust-type.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fast%2Frust-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fast%2Frust-type.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/ast/rust-type.h"}, {"sha": "e7c360f06d93f17f0430ec8baf6ea9a490db102e", "filename": "gcc/rust/backend.h", "status": "renamed", "additions": 246, "deletions": 260, "changes": 506, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fbackend.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fbackend.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -1,4 +1,11 @@\n-#pragma once\n+// backend.h -- Rust frontend interface to backend  -*- C++ -*-\n+\n+// Copyright 2011 The Rust Authors. All rights reserved.\n+// Use of this source code is rustverned by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+#ifndef RUST_BACKEND_H\n+#define RUST_BACKEND_H\n \n #include <gmp.h>\n #include <mpfr.h>\n@@ -31,161 +38,150 @@ class Bvariable;\n // The backend representation of a label.\n class Blabel;\n \n-\n // The backend interface.  This is a pure abstract class that a\n // specific backend will implement.\n \n class Backend\n {\n- public:\n-  virtual ~Backend() { }\n+public:\n+  virtual ~Backend () {}\n \n   // Name/type/location.  Used for function parameters, struct fields,\n   // interface methods.\n   struct Btyped_identifier\n   {\n     std::string name;\n-    Btype* btype;\n+    Btype *btype;\n     Location location;\n \n-    Btyped_identifier()\n-        : name(), btype(NULL), location(Linemap::unknown_location())\n-    { }\n+    Btyped_identifier ()\n+      : name (), btype (NULL), location (Linemap::unknown_location ())\n+    {}\n \n-    Btyped_identifier(const std::string& a_name, Btype* a_btype,\n-\t\t     Location a_location)\n-      : name(a_name), btype(a_btype), location(a_location)\n-    { }\n+    Btyped_identifier (const std::string &a_name, Btype *a_btype,\n+\t\t       Location a_location)\n+      : name (a_name), btype (a_btype), location (a_location)\n+    {}\n   };\n \n   // Types.\n \n   // Produce an error type.  Actually the backend could probably just\n   // crash if this is called.\n-  virtual Btype*\n-  error_type() = 0;\n+  virtual Btype *error_type () = 0;\n \n   // Get a void type.  This is used in (at least) two ways: 1) as the\n   // return type of a function with no result parameters; 2)\n   // unsafe.Pointer is represented as *void.\n-  virtual Btype*\n-  void_type() = 0;\n+  virtual Btype *void_type () = 0;\n \n   // Get the unnamed boolean type.\n-  virtual Btype*\n-  bool_type() = 0;\n+  virtual Btype *bool_type () = 0;\n \n   // Get an unnamed integer type with the given signedness and number\n   // of bits.\n-  virtual Btype*\n-  integer_type(bool is_unsigned, int bits) = 0;\n+  virtual Btype *integer_type (bool is_unsigned, int bits) = 0;\n \n   // Get an unnamed floating point type with the given number of bits\n   // (32 or 64).\n-  virtual Btype*\n-  float_type(int bits) = 0;\n+  virtual Btype *float_type (int bits) = 0;\n \n   // Get an unnamed complex type with the given number of bits (64 or 128).\n-  virtual Btype*\n-  complex_type(int bits) = 0;\n+  virtual Btype *complex_type (int bits) = 0;\n \n   // Get a pointer type.\n-  virtual Btype*\n-  pointer_type(Btype* to_type) = 0;\n+  virtual Btype *pointer_type (Btype *to_type) = 0;\n \n   // Get a function type.  The receiver, parameter, and results are\n   // generated from the types in the Function_type.  The Function_type\n   // is provided so that the names are available.  This should return\n-  // not the type of a Go function (which is a pointer to a struct)\n+  // not the type of a Rust function (which is a pointer to a struct)\n   // but the type of a C function pointer (which will be used as the\n   // type of the first field of the struct).  If there is more than\n   // one result, RESULT_STRUCT is a struct type to hold the results,\n   // and RESULTS may be ignored; if there are zero or one results,\n   // RESULT_STRUCT is NULL.\n-  virtual Btype*\n-  function_type(const Btyped_identifier& receiver,\n-\t\tconst std::vector<Btyped_identifier>& parameters,\n-\t\tconst std::vector<Btyped_identifier>& results,\n-\t\tBtype* result_struct,\n-\t\tLocation location) = 0;\n+  virtual Btype *\n+  function_type (const Btyped_identifier &receiver,\n+\t\t const std::vector<Btyped_identifier> &parameters,\n+\t\t const std::vector<Btyped_identifier> &results,\n+\t\t Btype *result_struct, Location location)\n+    = 0;\n \n   // Get a struct type.\n-  virtual Btype*\n-  struct_type(const std::vector<Btyped_identifier>& fields) = 0;\n+  virtual Btype *struct_type (const std::vector<Btyped_identifier> &fields) = 0;\n \n   // Get an array type.\n-  virtual Btype*\n-  array_type(Btype* element_type, Bexpression* length) = 0;\n+  virtual Btype *array_type (Btype *element_type, Bexpression *length) = 0;\n \n   // Create a placeholder pointer type.  This is used for a named\n-  // pointer type, since in Go a pointer type may refer to itself.\n+  // pointer type, since in Rust a pointer type may refer to itself.\n   // NAME is the name of the type, and the location is where the named\n   // type is defined.  This function is also used for unnamed function\n   // types with multiple results, in which case the type has no name\n   // and NAME will be empty.  FOR_FUNCTION is true if this is for a C\n-  // pointer to function type.  A Go func type is represented as a\n+  // pointer to function type.  A Rust func type is represented as a\n   // pointer to a struct, and the first field of the struct is a C\n   // pointer to function.  The return value will later be passed as\n   // the first parameter to set_placeholder_pointer_type or\n   // set_placeholder_function_type.\n-  virtual Btype*\n-  placeholder_pointer_type(const std::string& name, Location,\n-\t\t\t   bool for_function) = 0;\n+  virtual Btype *placeholder_pointer_type (const std::string &name, Location,\n+\t\t\t\t\t   bool for_function)\n+    = 0;\n \n   // Fill in a placeholder pointer type as a pointer.  This takes a\n   // type returned by placeholder_pointer_type and arranges for it to\n   // point to the type that TO_TYPE points to (that is, PLACEHOLDER\n   // becomes the same type as TO_TYPE).  Returns true on success,\n   // false on failure.\n-  virtual bool\n-  set_placeholder_pointer_type(Btype* placeholder, Btype* to_type) = 0;\n+  virtual bool set_placeholder_pointer_type (Btype *placeholder, Btype *to_type)\n+    = 0;\n \n   // Fill in a placeholder pointer type as a function.  This takes a\n   // type returned by placeholder_pointer_type and arranges for it to\n-  // become a real Go function type (which corresponds to a C/C++\n+  // become a real Rust function type (which corresponds to a C/C++\n   // pointer to function type).  FT will be something returned by the\n   // function_type method.  Returns true on success, false on failure.\n-  virtual bool\n-  set_placeholder_function_type(Btype* placeholder, Btype* ft) = 0;\n+  virtual bool set_placeholder_function_type (Btype *placeholder, Btype *ft)\n+    = 0;\n \n   // Create a placeholder struct type.  This is used for a named\n   // struct type, as with placeholder_pointer_type.  It is also used\n   // for interface types, in which case NAME will be the empty string.\n-  virtual Btype*\n-  placeholder_struct_type(const std::string& name, Location) = 0;\n+  virtual Btype *placeholder_struct_type (const std::string &name, Location)\n+    = 0;\n \n   // Fill in a placeholder struct type.  This takes a type returned by\n   // placeholder_struct_type and arranges for it to become a real\n   // struct type.  The parameter is as for struct_type.  Returns true\n   // on success, false on failure.\n   virtual bool\n-  set_placeholder_struct_type(Btype* placeholder,\n-\t\t\t      const std::vector<Btyped_identifier>& fields)\n-  \t\t\t= 0;\n+  set_placeholder_struct_type (Btype *placeholder,\n+\t\t\t       const std::vector<Btyped_identifier> &fields)\n+    = 0;\n \n   // Create a placeholder array type.  This is used for a named array\n   // type, as with placeholder_pointer_type, to handle cases like\n   // type A []*A.\n-  virtual Btype*\n-  placeholder_array_type(const std::string& name, Location) = 0;\n+  virtual Btype *placeholder_array_type (const std::string &name, Location) = 0;\n \n   // Fill in a placeholder array type.  This takes a type returned by\n   // placeholder_array_type and arranges for it to become a real array\n   // type.  The parameters are as for array_type.  Returns true on\n   // success, false on failure.\n-  virtual bool\n-  set_placeholder_array_type(Btype* placeholder, Btype* element_type,\n-\t\t\t     Bexpression* length) = 0;\n+  virtual bool set_placeholder_array_type (Btype *placeholder,\n+\t\t\t\t\t   Btype *element_type,\n+\t\t\t\t\t   Bexpression *length)\n+    = 0;\n \n   // Return a named version of a type.  The location is the location\n   // of the type definition.  This will not be called for a type\n   // created via placeholder_pointer_type, placeholder_struct_type, or\n   // placeholder_array_type..  (It may be called for a pointer,\n   // struct, or array type in a case like \"type P *byte; type Q P\".)\n-  virtual Btype*\n-  named_type(const std::string& name, Btype*, Location) = 0;\n+  virtual Btype *named_type (const std::string &name, Btype *, Location) = 0;\n \n-  // Create a marker for a circular pointer type.  Go pointer and\n+  // Create a marker for a circular pointer type.  Rust pointer and\n   // function types can refer to themselves in ways that are not\n   // permitted in C/C++.  When a circular type is found, this function\n   // is called for the circular reference.  This permits the backend\n@@ -199,214 +195,207 @@ class Backend\n   //   bt1 = placeholder_pointer_type();\n   //   bt2 = circular_pointer_type(bt1, false);\n   //   set_placeholder_pointer_type(bt1, bt2);\n-  virtual Btype*\n-  circular_pointer_type(Btype* placeholder, bool for_function) = 0;\n+  virtual Btype *circular_pointer_type (Btype *placeholder, bool for_function)\n+    = 0;\n \n   // Return whether the argument could be a special type created by\n   // circular_pointer_type.  This is used to introduce explicit type\n   // conversions where needed.  If circular_pointer_type returns its\n   // PLACEHOLDER parameter, this may safely always return false.\n-  virtual bool\n-  is_circular_pointer_type(Btype*) = 0;\n+  virtual bool is_circular_pointer_type (Btype *) = 0;\n \n   // Return the size of a type.\n-  virtual int64_t\n-  type_size(Btype*) = 0;\n+  virtual int64_t type_size (Btype *) = 0;\n \n   // Return the alignment of a type.\n-  virtual int64_t\n-  type_alignment(Btype*) = 0;\n+  virtual int64_t type_alignment (Btype *) = 0;\n \n   // Return the alignment of a struct field of this type.  This is\n   // normally the same as type_alignment, but not always.\n-  virtual int64_t\n-  type_field_alignment(Btype*) = 0;\n+  virtual int64_t type_field_alignment (Btype *) = 0;\n \n   // Return the offset of field INDEX in a struct type.  INDEX is the\n   // entry in the FIELDS std::vector parameter of struct_type or\n   // set_placeholder_struct_type.\n-  virtual int64_t\n-  type_field_offset(Btype*, size_t index) = 0;\n+  virtual int64_t type_field_offset (Btype *, size_t index) = 0;\n \n   // Expressions.\n \n   // Return an expression for a zero value of the given type.  This is\n   // used for cases such as local variable initialization and\n   // converting nil to other types.\n-  virtual Bexpression*\n-  zero_expression(Btype*) = 0;\n+  virtual Bexpression *zero_expression (Btype *) = 0;\n \n   // Create an error expression. This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual Bexpression*\n-  error_expression() = 0;\n+  // rusting without crashing.\n+  virtual Bexpression *error_expression () = 0;\n \n   // Create a nil pointer expression.\n-  virtual Bexpression*\n-  nil_pointer_expression() = 0;\n+  virtual Bexpression *nil_pointer_expression () = 0;\n \n   // Create a reference to a variable.\n-  virtual Bexpression*\n-  var_expression(Bvariable* var, Location) = 0;\n+  virtual Bexpression *var_expression (Bvariable *var, Location) = 0;\n \n   // Create an expression that indirects through the pointer expression EXPR\n   // (i.e., return the expression for *EXPR). KNOWN_VALID is true if the pointer\n   // is known to point to a valid memory location.  BTYPE is the expected type\n   // of the indirected EXPR.\n-  virtual Bexpression*\n-  indirect_expression(Btype* btype, Bexpression* expr, bool known_valid,\n-\t\t      Location) = 0;\n+  virtual Bexpression *indirect_expression (Btype *btype, Bexpression *expr,\n+\t\t\t\t\t    bool known_valid, Location)\n+    = 0;\n \n   // Return an expression that declares a constant named NAME with the\n   // constant value VAL in BTYPE.\n-  virtual Bexpression*\n-  named_constant_expression(Btype* btype, const std::string& name,\n-                             Bexpression* val, Location) = 0;\n+  virtual Bexpression *named_constant_expression (Btype *btype,\n+\t\t\t\t\t\t  const std::string &name,\n+\t\t\t\t\t\t  Bexpression *val, Location)\n+    = 0;\n \n   // Return an expression for the multi-precision integer VAL in BTYPE.\n-  virtual Bexpression*\n-  integer_constant_expression(Btype* btype, mpz_t val) = 0;\n+  virtual Bexpression *integer_constant_expression (Btype *btype, mpz_t val)\n+    = 0;\n \n   // Return an expression for the floating point value VAL in BTYPE.\n-  virtual Bexpression*\n-  float_constant_expression(Btype* btype, mpfr_t val) = 0;\n+  virtual Bexpression *float_constant_expression (Btype *btype, mpfr_t val) = 0;\n \n   // Return an expression for the complex value VAL in BTYPE.\n-  virtual Bexpression*\n-  complex_constant_expression(Btype* btype, mpc_t val) = 0;\n+  virtual Bexpression *complex_constant_expression (Btype *btype, mpc_t val)\n+    = 0;\n \n   // Return an expression for the string value VAL.\n-  virtual Bexpression*\n-  string_constant_expression(const std::string& val) = 0;\n+  virtual Bexpression *string_constant_expression (const std::string &val) = 0;\n \n   // Return an expression for the boolean value VAL.\n-  virtual Bexpression*\n-  boolean_constant_expression(bool val) = 0;\n+  virtual Bexpression *boolean_constant_expression (bool val) = 0;\n \n   // Return an expression for the real part of BCOMPLEX.\n-  virtual Bexpression*\n-  real_part_expression(Bexpression* bcomplex, Location) = 0;\n+  virtual Bexpression *real_part_expression (Bexpression *bcomplex, Location)\n+    = 0;\n \n   // Return an expression for the imaginary part of BCOMPLEX.\n-  virtual Bexpression*\n-  imag_part_expression(Bexpression* bcomplex, Location) = 0;\n+  virtual Bexpression *imag_part_expression (Bexpression *bcomplex, Location)\n+    = 0;\n \n   // Return an expression for the complex number (BREAL, BIMAG).\n-  virtual Bexpression*\n-  complex_expression(Bexpression* breal, Bexpression* bimag, Location) = 0;\n+  virtual Bexpression *complex_expression (Bexpression *breal,\n+\t\t\t\t\t   Bexpression *bimag, Location)\n+    = 0;\n \n   // Return an expression that converts EXPR to TYPE.\n-  virtual Bexpression*\n-  convert_expression(Btype* type, Bexpression* expr, Location) = 0;\n+  virtual Bexpression *convert_expression (Btype *type, Bexpression *expr,\n+\t\t\t\t\t   Location)\n+    = 0;\n \n   // Create an expression for the address of a function.  This is used to\n   // get the address of the code for a function.\n-  virtual Bexpression*\n-  function_code_expression(Bfunction*, Location) = 0;\n+  virtual Bexpression *function_code_expression (Bfunction *, Location) = 0;\n \n   // Create an expression that takes the address of an expression.\n-  virtual Bexpression*\n-  address_expression(Bexpression*, Location) = 0;\n+  virtual Bexpression *address_expression (Bexpression *, Location) = 0;\n \n   // Return an expression for the field at INDEX in BSTRUCT.\n-  virtual Bexpression*\n-  struct_field_expression(Bexpression* bstruct, size_t index, Location) = 0;\n+  virtual Bexpression *struct_field_expression (Bexpression *bstruct,\n+\t\t\t\t\t\tsize_t index, Location)\n+    = 0;\n \n   // Create an expression that executes BSTAT before BEXPR.\n-  virtual Bexpression*\n-  compound_expression(Bstatement* bstat, Bexpression* bexpr, Location) = 0;\n+  virtual Bexpression *compound_expression (Bstatement *bstat,\n+\t\t\t\t\t    Bexpression *bexpr, Location)\n+    = 0;\n \n   // Return an expression that executes THEN_EXPR if CONDITION is true, or\n   // ELSE_EXPR otherwise and returns the result as type BTYPE, within the\n   // specified function FUNCTION.  ELSE_EXPR may be NULL.  BTYPE may be NULL.\n-  virtual Bexpression*\n-  conditional_expression(Bfunction* function, Btype* btype,\n-                         Bexpression* condition, Bexpression* then_expr,\n-                         Bexpression* else_expr, Location) = 0;\n+  virtual Bexpression *\n+  conditional_expression (Bfunction *function, Btype *btype,\n+\t\t\t  Bexpression *condition, Bexpression *then_expr,\n+\t\t\t  Bexpression *else_expr, Location)\n+    = 0;\n \n   // Return an expression for the unary operation OP EXPR.\n   // Supported values of OP are (from operators.h):\n   //    MINUS, NOT, XOR.\n-  virtual Bexpression*\n-  unary_expression(Operator op, Bexpression* expr, Location) = 0;\n+  virtual Bexpression *unary_expression (Operator op, Bexpression *expr,\n+\t\t\t\t\t Location)\n+    = 0;\n \n   // Return an expression for the binary operation LEFT OP RIGHT.\n   // Supported values of OP are (from operators.h):\n   //    EQEQ, NOTEQ, LT, LE, GT, GE, PLUS, MINUS, OR, XOR, MULT, DIV, MOD,\n   //    LSHIFT, RSHIFT, AND, NOT.\n-  virtual Bexpression*\n-  binary_expression(Operator op, Bexpression* left, Bexpression* right,\n-                    Location) = 0;\n+  virtual Bexpression *binary_expression (Operator op, Bexpression *left,\n+\t\t\t\t\t  Bexpression *right, Location)\n+    = 0;\n \n   // Return an expression that constructs BTYPE with VALS.  BTYPE must be the\n   // backend representation a of struct.  VALS must be in the same order as the\n   // corresponding fields in BTYPE.\n-  virtual Bexpression*\n-  constructor_expression(Btype* btype, const std::vector<Bexpression*>& vals,\n-                         Location) = 0;\n+  virtual Bexpression *\n+  constructor_expression (Btype *btype, const std::vector<Bexpression *> &vals,\n+\t\t\t  Location)\n+    = 0;\n \n   // Return an expression that constructs an array of BTYPE with INDEXES and\n   // VALS.  INDEXES and VALS must have the same amount of elements. Each index\n   // in INDEXES must be in the same order as the corresponding value in VALS.\n-  virtual Bexpression*\n-  array_constructor_expression(Btype* btype,\n-                               const std::vector<unsigned long>& indexes,\n-                               const std::vector<Bexpression*>& vals,\n-                               Location) = 0;\n+  virtual Bexpression *array_constructor_expression (\n+    Btype *btype, const std::vector<unsigned long> &indexes,\n+    const std::vector<Bexpression *> &vals, Location)\n+    = 0;\n \n   // Return an expression for the address of BASE[INDEX].\n   // BASE has a pointer type.  This is used for slice indexing.\n-  virtual Bexpression*\n-  pointer_offset_expression(Bexpression* base, Bexpression* index,\n-                            Location) = 0;\n+  virtual Bexpression *pointer_offset_expression (Bexpression *base,\n+\t\t\t\t\t\t  Bexpression *index, Location)\n+    = 0;\n \n   // Return an expression for ARRAY[INDEX] as an l-value.  ARRAY is a valid\n   // fixed-length array, not a slice.\n-  virtual Bexpression*\n-  array_index_expression(Bexpression* array, Bexpression* index, Location) = 0;\n+  virtual Bexpression *array_index_expression (Bexpression *array,\n+\t\t\t\t\t       Bexpression *index, Location)\n+    = 0;\n \n   // Create an expression for a call to FN with ARGS, taking place within\n   // caller CALLER.\n-  virtual Bexpression*\n-  call_expression(Bfunction *caller, Bexpression* fn,\n-                  const std::vector<Bexpression*>& args,\n-\t\t  Bexpression* static_chain, Location) = 0;\n+  virtual Bexpression *call_expression (Bfunction *caller, Bexpression *fn,\n+\t\t\t\t\tconst std::vector<Bexpression *> &args,\n+\t\t\t\t\tBexpression *static_chain, Location)\n+    = 0;\n \n   // Statements.\n \n   // Create an error statement.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual Bstatement*\n-  error_statement() = 0;\n+  // rusting without crashing.\n+  virtual Bstatement *error_statement () = 0;\n \n   // Create an expression statement within the specified function.\n-  virtual Bstatement*\n-  expression_statement(Bfunction*, Bexpression*) = 0;\n+  virtual Bstatement *expression_statement (Bfunction *, Bexpression *) = 0;\n \n   // Create a variable initialization statement in the specified\n   // function.  This initializes a local variable at the point in the\n   // program flow where it is declared.\n-  virtual Bstatement*\n-  init_statement(Bfunction*, Bvariable* var, Bexpression* init) = 0;\n+  virtual Bstatement *init_statement (Bfunction *, Bvariable *var,\n+\t\t\t\t      Bexpression *init)\n+    = 0;\n \n   // Create an assignment statement within the specified function.\n-  virtual Bstatement*\n-  assignment_statement(Bfunction*, Bexpression* lhs, Bexpression* rhs,\n-\t\t       Location) = 0;\n+  virtual Bstatement *assignment_statement (Bfunction *, Bexpression *lhs,\n+\t\t\t\t\t    Bexpression *rhs, Location)\n+    = 0;\n \n   // Create a return statement, passing the representation of the\n   // function and the list of values to return.\n-  virtual Bstatement*\n-  return_statement(Bfunction*, const std::vector<Bexpression*>&,\n-\t\t   Location) = 0;\n+  virtual Bstatement *\n+  return_statement (Bfunction *, const std::vector<Bexpression *> &, Location)\n+    = 0;\n \n   // Create an if statement within a function.  ELSE_BLOCK may be NULL.\n-  virtual Bstatement*\n-  if_statement(Bfunction*, Bexpression* condition,\n-               Bblock* then_block, Bblock* else_block,\n-\t       Location) = 0;\n+  virtual Bstatement *if_statement (Bfunction *, Bexpression *condition,\n+\t\t\t\t    Bblock *then_block, Bblock *else_block,\n+\t\t\t\t    Location)\n+    = 0;\n \n   // Create a switch statement where the case values are constants.\n   // CASES and STATEMENTS must have the same number of entries.  If\n@@ -415,28 +404,27 @@ class Backend\n   // either end with a goto statement or will fall through into\n   // STATEMENTS[i + 1].  CASES[i] is empty for the default clause,\n   // which need not be last.  FUNCTION is the current function.\n-  virtual Bstatement*\n-  switch_statement(Bfunction* function, Bexpression* value,\n-\t\t   const std::vector<std::vector<Bexpression*> >& cases,\n-\t\t   const std::vector<Bstatement*>& statements,\n-\t\t   Location) = 0;\n+  virtual Bstatement *\n+  switch_statement (Bfunction *function, Bexpression *value,\n+\t\t    const std::vector<std::vector<Bexpression *> > &cases,\n+\t\t    const std::vector<Bstatement *> &statements, Location)\n+    = 0;\n \n   // Create a single statement from two statements.\n-  virtual Bstatement*\n-  compound_statement(Bstatement*, Bstatement*) = 0;\n+  virtual Bstatement *compound_statement (Bstatement *, Bstatement *) = 0;\n \n   // Create a single statement from a list of statements.\n-  virtual Bstatement*\n-  statement_list(const std::vector<Bstatement*>&) = 0;\n+  virtual Bstatement *statement_list (const std::vector<Bstatement *> &) = 0;\n \n   // Create a statement that attempts to execute BSTAT and calls EXCEPT_STMT if\n   // an exception occurs. EXCEPT_STMT may be NULL.  FINALLY_STMT may be NULL and\n   // if not NULL, it will always be executed.  This is used for handling defers\n-  // in Go functions.  In C++, the resulting code is of this form:\n+  // in Rust functions.  In C++, the resulting code is of this form:\n   //   try { BSTAT; } catch { EXCEPT_STMT; } finally { FINALLY_STMT; }\n-  virtual Bstatement*\n-  exception_handler_statement(Bstatement* bstat, Bstatement* except_stmt,\n-                              Bstatement* finally_stmt, Location) = 0;\n+  virtual Bstatement *\n+  exception_handler_statement (Bstatement *bstat, Bstatement *except_stmt,\n+\t\t\t       Bstatement *finally_stmt, Location)\n+    = 0;\n \n   // Blocks.\n \n@@ -450,30 +438,29 @@ class Backend\n   // the initial curly brace.  END_LOCATION is the location of the end\n   // of the block, more or less the location of the final curly brace.\n   // The statements will be added after the block is created.\n-  virtual Bblock*\n-  block(Bfunction* function, Bblock* enclosing,\n-\tconst std::vector<Bvariable*>& vars,\n-\tLocation start_location, Location end_location) = 0;\n+  virtual Bblock *block (Bfunction *function, Bblock *enclosing,\n+\t\t\t const std::vector<Bvariable *> &vars,\n+\t\t\t Location start_location, Location end_location)\n+    = 0;\n \n   // Add the statements to a block.  The block is created first.  Then\n   // the statements are created.  Then the statements are added to the\n   // block.  This will called exactly once per block.  The vector may\n   // be empty if there are no statements.\n-  virtual void\n-  block_add_statements(Bblock*, const std::vector<Bstatement*>&) = 0;\n+  virtual void block_add_statements (Bblock *,\n+\t\t\t\t     const std::vector<Bstatement *> &)\n+    = 0;\n \n   // Return the block as a statement.  This is used to include a block\n   // in a list of statements.\n-  virtual Bstatement*\n-  block_statement(Bblock*) = 0;\n+  virtual Bstatement *block_statement (Bblock *) = 0;\n \n   // Variables.\n \n   // Create an error variable.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual Bvariable*\n-  error_variable() = 0;\n+  // rusting without crashing.\n+  virtual Bvariable *error_variable () = 0;\n \n   // Create a global variable. NAME is the package-qualified name of\n   // the variable.  ASM_NAME is the encoded identifier for the\n@@ -485,23 +472,19 @@ class Backend\n   // be put into a unique section if possible; this is intended to\n   // permit the linker to garbage collect the variable if it is not\n   // referenced.  LOCATION is where the variable was defined.\n-  virtual Bvariable*\n-  global_variable(const std::string& name,\n-                  const std::string& asm_name,\n-\t\t  Btype* btype,\n-\t\t  bool is_external,\n-\t\t  bool is_hidden,\n-\t\t  bool in_unique_section,\n-\t\t  Location location) = 0;\n+  virtual Bvariable *global_variable (const std::string &name,\n+\t\t\t\t      const std::string &asm_name, Btype *btype,\n+\t\t\t\t      bool is_external, bool is_hidden,\n+\t\t\t\t      bool in_unique_section, Location location)\n+    = 0;\n \n   // A global variable will 1) be initialized to zero, or 2) be\n   // initialized to a constant value, or 3) be initialized in the init\n   // function.  In case 2, the frontend will call\n   // global_variable_set_init to set the initial value.  If this is\n   // not called, the backend should initialize a global variable to 0.\n   // The init function may then assign a value to it.\n-  virtual void\n-  global_variable_set_init(Bvariable*, Bexpression*) = 0;\n+  virtual void global_variable_set_init (Bvariable *, Bexpression *) = 0;\n \n   // Create a local variable.  The frontend will create the local\n   // variables first, and then create the block which contains them.\n@@ -515,22 +498,24 @@ class Backend\n   // the function, as otherwise the variable would be on the heap).\n   // LOCATION is where the variable is defined.  For each local variable\n   // the frontend will call init_statement to set the initial value.\n-  virtual Bvariable*\n-  local_variable(Bfunction* function, const std::string& name, Btype* type,\n-\t\t Bvariable* decl_var, bool is_address_taken, Location location) = 0;\n+  virtual Bvariable *\n+  local_variable (Bfunction *function, const std::string &name, Btype *type,\n+\t\t  Bvariable *decl_var, bool is_address_taken, Location location)\n+    = 0;\n \n   // Create a function parameter.  This is an incoming parameter, not\n   // a result parameter (result parameters are treated as local\n   // variables).  The arguments are as for local_variable.\n-  virtual Bvariable*\n-  parameter_variable(Bfunction* function, const std::string& name,\n-\t\t     Btype* type, bool is_address_taken,\n-\t\t     Location location) = 0;\n+  virtual Bvariable *\n+  parameter_variable (Bfunction *function, const std::string &name, Btype *type,\n+\t\t      bool is_address_taken, Location location)\n+    = 0;\n \n   // Create a static chain parameter.  This is the closure parameter.\n-  virtual Bvariable*\n-  static_chain_variable(Bfunction* function, const std::string& name,\n-\t\t        Btype* type, Location location) = 0;\n+  virtual Bvariable *static_chain_variable (Bfunction *function,\n+\t\t\t\t\t    const std::string &name,\n+\t\t\t\t\t    Btype *type, Location location)\n+    = 0;\n \n   // Create a temporary variable.  A temporary variable has no name,\n   // just a type.  We pass in FUNCTION and BLOCK in case they are\n@@ -543,10 +528,11 @@ class Backend\n   // variable, and may not be very useful.  This function should\n   // return a variable which can be referenced later and should set\n   // *PSTATEMENT to a statement which initializes the variable.\n-  virtual Bvariable*\n-  temporary_variable(Bfunction*, Bblock*, Btype*, Bexpression* init,\n-\t\t     bool address_is_taken, Location location,\n-\t\t     Bstatement** pstatement) = 0;\n+  virtual Bvariable *\n+  temporary_variable (Bfunction *, Bblock *, Btype *, Bexpression *init,\n+\t\t      bool address_is_taken, Location location,\n+\t\t      Bstatement **pstatement)\n+    = 0;\n \n   // Create an implicit variable that is compiler-defined.  This is\n   // used when generating GC data and roots, when storing the values\n@@ -574,11 +560,11 @@ class Backend\n   // the zero value.  IS_HIDDEN and IS_COMMON will never both be true.\n   //\n   // If ALIGNMENT is not zero, it is the desired alignment of the variable.\n-  virtual Bvariable*\n-  implicit_variable(const std::string& name, const std::string& asm_name,\n-                    Btype* type, bool is_hidden, bool is_constant,\n-                    bool is_common, int64_t alignment) = 0;\n-\n+  virtual Bvariable *\n+  implicit_variable (const std::string &name, const std::string &asm_name,\n+\t\t     Btype *type, bool is_hidden, bool is_constant,\n+\t\t     bool is_common, int64_t alignment)\n+    = 0;\n \n   // Set the initial value of a variable created by implicit_variable.\n   // This must be called even if there is no initializer, i.e., INIT is NULL.\n@@ -590,20 +576,21 @@ class Backend\n   //\n   // If IS_COMMON is true, INIT will be NULL, and the\n   // variable should be initialized to all zeros.\n-  virtual void\n-  implicit_variable_set_init(Bvariable*, const std::string& name, Btype* type,\n-\t\t\t     bool is_hidden, bool is_constant, bool is_common,\n-\t\t\t     Bexpression* init) = 0;\n+  virtual void implicit_variable_set_init (Bvariable *, const std::string &name,\n+\t\t\t\t\t   Btype *type, bool is_hidden,\n+\t\t\t\t\t   bool is_constant, bool is_common,\n+\t\t\t\t\t   Bexpression *init)\n+    = 0;\n \n   // Create a reference to a named implicit variable defined in some\n   // other package.  This will be a variable created by a call to\n   // implicit_variable with the same NAME, ASM_NAME and TYPE and with\n   // IS_COMMON passed as false.  This corresponds to an extern global\n   // variable in C.\n-  virtual Bvariable*\n-  implicit_variable_reference(const std::string& name,\n-                              const std::string& asm_name,\n-                              Btype* type) = 0;\n+  virtual Bvariable *implicit_variable_reference (const std::string &name,\n+\t\t\t\t\t\t  const std::string &asm_name,\n+\t\t\t\t\t\t  Btype *type)\n+    = 0;\n \n   // Create a named immutable initialized data structure.  This is\n   // used for type descriptors, map descriptors, and function\n@@ -633,11 +620,10 @@ class Backend\n   // initializer, because the initializer may refer to its own\n   // address.  After calling this the frontend will call\n   // immutable_struct_set_init.\n-  virtual Bvariable*\n-  immutable_struct(const std::string& name,\n-                   const std::string& asm_name,\n-                   bool is_hidden, bool is_common,\n-\t\t   Btype* type, Location) = 0;\n+  virtual Bvariable *\n+  immutable_struct (const std::string &name, const std::string &asm_name,\n+\t\t    bool is_hidden, bool is_common, Btype *type, Location)\n+    = 0;\n \n   // Set the initial value of a variable created by immutable_struct.\n   // The NAME, IS_HIDDEN, IS_COMMON, TYPE, and location parameters are\n@@ -646,52 +632,48 @@ class Backend\n   // calls or anything else that can not be put into a read-only data\n   // section.  It may contain the address of variables created by\n   // immutable_struct.\n-  virtual void\n-  immutable_struct_set_init(Bvariable*, const std::string& name,\n-\t\t\t    bool is_hidden, bool is_common, Btype* type,\n-\t\t\t    Location, Bexpression* initializer) = 0;\n+  virtual void immutable_struct_set_init (Bvariable *, const std::string &name,\n+\t\t\t\t\t  bool is_hidden, bool is_common,\n+\t\t\t\t\t  Btype *type, Location,\n+\t\t\t\t\t  Bexpression *initializer)\n+    = 0;\n \n   // Create a reference to a named immutable initialized data\n   // structure defined in some other package.  This will be a\n   // structure created by a call to immutable_struct with the same\n   // NAME, ASM_NAME and TYPE and with IS_COMMON passed as false.  This\n   // corresponds to an extern const global variable in C.\n-  virtual Bvariable*\n-  immutable_struct_reference(const std::string& name,\n-                             const std::string& asm_name,\n-                             Btype* type, Location) = 0;\n+  virtual Bvariable *immutable_struct_reference (const std::string &name,\n+\t\t\t\t\t\t const std::string &asm_name,\n+\t\t\t\t\t\t Btype *type, Location)\n+    = 0;\n \n   // Labels.\n \n   // Create a new label.  NAME will be empty if this is a label\n   // created by the frontend for a loop construct.  The location is\n   // where the label is defined.\n-  virtual Blabel*\n-  label(Bfunction*, const std::string& name, Location) = 0;\n+  virtual Blabel *label (Bfunction *, const std::string &name, Location) = 0;\n \n   // Create a statement which defines a label.  This statement will be\n   // put into the codestream at the point where the label should be\n   // defined.\n-  virtual Bstatement*\n-  label_definition_statement(Blabel*) = 0;\n+  virtual Bstatement *label_definition_statement (Blabel *) = 0;\n \n   // Create a goto statement to a label.\n-  virtual Bstatement*\n-  goto_statement(Blabel*, Location) = 0;\n+  virtual Bstatement *goto_statement (Blabel *, Location) = 0;\n \n   // Create an expression for the address of a label.  This is used to\n   // get the return address of a deferred function which may call\n   // recover.\n-  virtual Bexpression*\n-  label_address(Blabel*, Location) = 0;\n+  virtual Bexpression *label_address (Blabel *, Location) = 0;\n \n   // Functions.\n \n   // Create an error function.  This is used for cases which should\n   // not occur in a correct program, in order to keep the compilation\n-  // going without crashing.\n-  virtual Bfunction*\n-  error_function() = 0;\n+  // rusting without crashing.\n+  virtual Bfunction *error_function () = 0;\n \n   // Bit flags to pass to the function method.\n \n@@ -728,51 +710,55 @@ class Backend\n   static const unsigned int function_only_inline = 1 << 6;\n \n   // Declare or define a function of FNTYPE.\n-  // NAME is the Go name of the function.  ASM_NAME, if not the empty\n+  // NAME is the Rust name of the function.  ASM_NAME, if not the empty\n   // string, is the name that should be used in the symbol table; this\n   // will be non-empty if a magic extern comment is used.  FLAGS is\n   // bit flags described above.\n-  virtual Bfunction*\n-  function(Btype* fntype, const std::string& name, const std::string& asm_name,\n-\t   unsigned int flags, Location) = 0;\n+  virtual Bfunction *function (Btype *fntype, const std::string &name,\n+\t\t\t       const std::string &asm_name, unsigned int flags,\n+\t\t\t       Location)\n+    = 0;\n \n   // Create a statement that runs all deferred calls for FUNCTION.  This should\n   // be a statement that looks like this in C++:\n   //   finish:\n   //     try { DEFER_RETURN; } catch { CHECK_DEFER; goto finish; }\n-  virtual Bstatement*\n-  function_defer_statement(Bfunction* function, Bexpression* undefer,\n-                           Bexpression* check_defer, Location) = 0;\n+  virtual Bstatement *\n+  function_defer_statement (Bfunction *function, Bexpression *undefer,\n+\t\t\t    Bexpression *check_defer, Location)\n+    = 0;\n \n   // Record PARAM_VARS as the variables to use for the parameters of FUNCTION.\n   // This will only be called for a function definition.  Returns true on\n   // success, false on failure.\n   virtual bool\n-  function_set_parameters(Bfunction* function,\n-                         const std::vector<Bvariable*>& param_vars) = 0;\n+  function_set_parameters (Bfunction *function,\n+\t\t\t   const std::vector<Bvariable *> &param_vars)\n+    = 0;\n \n   // Set the function body for FUNCTION using the code in CODE_STMT.  Returns\n   // true on success, false on failure.\n-  virtual bool\n-  function_set_body(Bfunction* function, Bstatement* code_stmt) = 0;\n+  virtual bool function_set_body (Bfunction *function, Bstatement *code_stmt)\n+    = 0;\n \n   // Look up a named built-in function in the current backend implementation.\n   // Returns NULL if no built-in function by that name exists.\n-  virtual Bfunction*\n-  lookup_builtin(const std::string&) = 0;\n+  virtual Bfunction *lookup_builtin (const std::string &) = 0;\n \n   // Utility.\n \n   // Write the definitions for all TYPE_DECLS, CONSTANT_DECLS,\n   // FUNCTION_DECLS, and VARIABLE_DECLS declared globally.\n   virtual void\n-  write_global_definitions(const std::vector<Btype*>& type_decls,\n-                           const std::vector<Bexpression*>& constant_decls,\n-                           const std::vector<Bfunction*>& function_decls,\n-                           const std::vector<Bvariable*>& variable_decls) = 0;\n+  write_global_definitions (const std::vector<Btype *> &type_decls,\n+\t\t\t    const std::vector<Bexpression *> &constant_decls,\n+\t\t\t    const std::vector<Bfunction *> &function_decls,\n+\t\t\t    const std::vector<Bvariable *> &variable_decls)\n+    = 0;\n \n   // Write SIZE bytes of export data from BYTES to the proper\n   // section in the output object file.\n-  virtual void\n-  write_export_data(const char* bytes, unsigned int size) = 0;\n+  virtual void write_export_data (const char *bytes, unsigned int size) = 0;\n };\n+\n+#endif // !defined(RUST_BACKEND_H)", "previous_filename": "gcc/rust/rustfrontend/backend.h"}, {"sha": "c50b72153c2672099e9c3b2e42a9279e2f27f81c", "filename": "gcc/rust/config-lang.in", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fconfig-lang.in?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -31,4 +31,4 @@ build_by_default=\"no\"\n \n target_libs=\"target-libffi target-libbacktrace\"\n \n-gtfiles=\"\\$(srcdir)/rust/rust-lang.c \\$(srcdir)/rust/rust-c.h\"\n+gtfiles=\"\\$(srcdir)/rust/rust-lang.cc\""}, {"sha": "613d94f18f21e2d3b9648c1c7497cdcad9334961", "filename": "gcc/rust/expand/rust-macro-expand.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/expand/rust-macro-expand.cc"}, {"sha": "a252a4197c23c11e9464061ced423eac059775e8", "filename": "gcc/rust/expand/rust-macro-expand.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fexpand%2Frust-macro-expand.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fexpand%2Frust-macro-expand.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/expand/rust-macro-expand.h"}, {"sha": "4757dfbba2df0c21efc5e52e36b73ba6debe396f", "filename": "gcc/rust/lang.opt", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flang.opt?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "patch": "@@ -22,6 +22,8 @@\n \n ; Please try to keep this file in ASCII collating order.\n \n+; Describes command-line options used by this frontend\n+\n Language\n Rust\n \n@@ -33,6 +35,10 @@ L\n Rust Joined Separate\n ; Not documented\n \n+frust-dump-\n+Rust Joined RejectNegative\n+-frust-dump-<type>\tDump Rust frontend internal information.\n+\n o\n Rust Joined Separate\n ; Documented in common.opt"}, {"sha": "a00edb38873f076fc25922ed534016e02a316c71", "filename": "gcc/rust/lex/rust-codepoint.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-codepoint.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-codepoint.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-codepoint.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/lex/rust-codepoint.h"}, {"sha": "5a7b0cb402d35166c2aca0a46571683000f047c7", "filename": "gcc/rust/lex/rust-lex.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/lex/rust-lex.cc"}, {"sha": "b16cfeb6dec5e2bef2258e7b6a053f8614ccef74", "filename": "gcc/rust/lex/rust-lex.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-lex.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/lex/rust-lex.h"}, {"sha": "47bf75013f6711a5cf541c23db79d06897b42cbf", "filename": "gcc/rust/lex/rust-token.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/lex/rust-token.cc"}, {"sha": "bf65ed3b084a0cf22300189d782883c259df52f5", "filename": "gcc/rust/lex/rust-token.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Flex%2Frust-token.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/lex/rust-token.h"}, {"sha": "e4fe49daea2c8a8dd1d2d8537864c6a1d2d6f2cf", "filename": "gcc/rust/mrustc_parser/ast/ast.cpp", "status": "removed", "additions": 0, "deletions": 440, "changes": 440, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,440 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/ast.cpp\n- * - Implementation of the various AST classes\n- */\n-#include \"ast.hpp\"\n-#include \"crate.hpp\"\n-#include \"types.hpp\"\n-#include \"expr.hpp\"\n-#include \"../common.hpp\"\n-#include <iostream>\n-#include \"../parse/parseerror.hpp\"\n-#include <algorithm>\n-\n-namespace AST {\n-\n-\n-namespace {\n-    ::std::vector<Attribute> clone_mivec(const ::std::vector<Attribute>& v) {\n-        ::std::vector<Attribute>    ri;\n-        ri.reserve(v.size());\n-        for(const auto& i : v)\n-            ri.push_back( i.clone() );\n-        return ri;\n-    }\n-}\n-\n-AttributeList AttributeList::clone() const\n-{\n-    return AttributeList( clone_mivec(m_items) );\n-}\n-\n-void AttributeList::push_back(Attribute i)\n-{\n-    m_items.push_back( ::std::move(i) );\n-}\n-const Attribute* AttributeList::get(const char *name) const\n-{\n-    for( auto& i : m_items ) {\n-        if(i.name() == name) {\n-            //i.mark_used();\n-            return &i;\n-        }\n-    }\n-    return 0;\n-}\n-\n-Attribute Attribute::clone() const\n-{\n-    TU_MATCHA( (m_data), (e),\n-    (None,\n-        return Attribute(m_span, m_name);\n-        ),\n-    (String,\n-        return Attribute(m_span, m_name, e.val);\n-        ),\n-    (List,\n-        return Attribute(m_span, m_name, clone_mivec(e.sub_items));\n-        )\n-    )\n-    throw ::std::runtime_error(\"Attribute::clone - Fell off end\");\n-}\n-\n-StructItem StructItem::clone() const\n-{\n-    return StructItem(m_attrs.clone(), m_is_public, m_name, m_type.clone());\n-}\n-TupleItem TupleItem::clone() const\n-{\n-    return TupleItem(m_attrs.clone(), m_is_public, m_type.clone());\n-}\n-\n-\n-TypeAlias TypeAlias::clone() const\n-{\n-    return TypeAlias( m_params.clone(), m_type.clone() );\n-}\n-Static Static::clone() const\n-{\n-    return Static( m_class, m_type.clone(), m_value.is_valid() ? AST::Expr( m_value.node().clone() ) : AST::Expr() );\n-}\n-\n-Function::Function(Span sp, GenericParams params, ::std::string abi, bool is_unsafe, bool is_const, bool is_variadic, TypeRef ret_type, Arglist args):\n-    m_span(sp),\n-    m_params( move(params) ),\n-    m_rettype( move(ret_type) ),\n-    m_args( move(args) ),\n-    m_abi( mv$(abi) ),\n-    m_is_const(is_const),\n-    m_is_unsafe(is_unsafe),\n-    m_is_variadic(is_variadic)\n-{\n-}\n-Function Function::clone() const\n-{\n-    decltype(m_args)    new_args;\n-    for(const auto& arg : m_args)\n-        new_args.push_back( ::std::make_pair( arg.first.clone(), arg.second.clone() ) );\n-\n-    auto rv = Function( m_span, m_params.clone(), m_abi, m_is_unsafe, m_is_const, m_is_variadic, m_rettype.clone(), mv$(new_args) );\n-    if( m_code.is_valid() )\n-    {\n-        rv.m_code = AST::Expr( m_code.node().clone() );\n-    }\n-    return rv;\n-}\n-\n-void Trait::add_type(::std::string name, AttributeList attrs, TypeRef type) {\n-    m_items.push_back( Named<Item>(mv$(name), Item::make_Type({TypeAlias(GenericParams(), mv$(type))}), true) );\n-    m_items.back().data.attrs = mv$(attrs);\n-}\n-void Trait::add_function(::std::string name, AttributeList attrs, Function fcn) {\n-    DEBUG(\"trait fn \" << name);\n-    m_items.push_back( Named<Item>(mv$(name), Item::make_Function({mv$(fcn)}), true) );\n-    m_items.back().data.attrs = mv$(attrs);\n-}\n-void Trait::add_static(::std::string name, AttributeList attrs, Static v) {\n-    m_items.push_back( Named<Item>(mv$(name), Item::make_Static({mv$(v)}), true) );\n-    m_items.back().data.attrs = mv$(attrs);\n-}\n-void Trait::set_is_marker() {\n-    m_is_marker = true;\n-}\n-bool Trait::is_marker() const {\n-    return m_is_marker;\n-}\n-bool Trait::has_named_item(const ::std::string& name, bool& out_is_fcn) const\n-{\n-    for( const auto& i : m_items )\n-    {\n-        if( i.name == name ) {\n-            out_is_fcn = i.data.is_Function();\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-Trait Trait::clone() const\n-{\n-    auto rv = Trait(m_params.clone(), m_supertraits);\n-    for(const auto& item : m_items)\n-    {\n-        rv.m_items.push_back( Named<Item> { item.name, item.data.clone(), item.is_pub } );\n-    }\n-    return rv;\n-}\n-\n-Enum Enum::clone() const\n-{\n-    decltype(m_variants)    new_variants;\n-    for(const auto& var : m_variants)\n-    {\n-        TU_MATCHA( (var.m_data), (e),\n-        (Value,\n-            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, e.m_value.clone()) );\n-            ),\n-        (Tuple,\n-            decltype(e.m_sub_types) new_st;\n-            for(const auto& f : e.m_sub_types)\n-                new_st.push_back( f.clone() );\n-            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, mv$(new_st)) );\n-            ),\n-        (Struct,\n-            decltype(e.m_fields)    new_fields;\n-            for(const auto& f : e.m_fields)\n-                new_fields.push_back( f.clone() );\n-            new_variants.push_back( EnumVariant(var.m_attrs.clone(), var.m_name, mv$(new_fields)) );\n-            )\n-        )\n-    }\n-    return Enum(m_params.clone(), mv$(new_variants));\n-}\n-Struct Struct::clone() const\n-{\n-    TU_MATCHA( (m_data), (e),\n-    (Unit,\n-        return Struct(m_params.clone());\n-        ),\n-    (Tuple,\n-        decltype(e.ents)    new_fields;\n-        for(const auto& f : e.ents)\n-            new_fields.push_back( f.clone() );\n-        return Struct(m_params.clone(), mv$(new_fields));\n-        ),\n-    (Struct,\n-        decltype(e.ents)    new_fields;\n-        for(const auto& f : e.ents)\n-            new_fields.push_back( f.clone() );\n-        return Struct(m_params.clone(), mv$(new_fields));\n-        )\n-    )\n-    throw \"\";\n-}\n-\n-Union Union::clone() const\n-{\n-    decltype(m_variants)    new_vars;\n-    for(const auto& f : m_variants)\n-        new_vars.push_back( f.clone() );\n-    return Union(m_params.clone(), mv$(new_vars));\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const ImplDef& impl)\n-{\n-    return os << \"impl<\" << impl.m_params << \"> \" << impl.m_trait.ent << \" for \" << impl.m_type << \"\";\n-}\n-\n-void Impl::add_function(bool is_public, bool is_specialisable, ::std::string name, Function fcn)\n-{\n-    DEBUG(\"impl fn \" << name);\n-    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Function(mv$(fcn)) ) } );\n-}\n-void Impl::add_type(bool is_public, bool is_specialisable, ::std::string name, TypeRef type)\n-{\n-    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Type(TypeAlias(GenericParams(), mv$(type))) ) } );\n-}\n-void Impl::add_static(bool is_public, bool is_specialisable, ::std::string name, Static v)\n-{\n-    m_items.push_back( ImplItem { is_public, is_specialisable, mv$(name), box$( Item::make_Static(mv$(v)) ) } );\n-}\n-void Impl::add_macro_invocation(MacroInvocation item) {\n-    m_items.push_back( ImplItem { false, false, \"\", box$( Item::make_MacroInv(mv$(item)) ) } );\n-}\n-\n-bool Impl::has_named_item(const ::std::string& name) const\n-{\n-    for( const auto& it : this->items() )\n-    {\n-        if( it.name == name ) {\n-            return true;\n-        }\n-    }\n-    return false;\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const Impl& impl)\n-{\n-    return os << impl.m_def;\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const UseStmt& x)\n-{\n-    os << \"Use(\" << x.path << \")\";\n-    return os;\n-}\n-\n-\n-\n-MacroInvocation MacroInvocation::clone() const\n-{\n-    return MacroInvocation(m_span, m_macro_name, m_ident, m_input.clone());\n-}\n-\n-\n-UseStmt UseStmt::clone() const\n-{\n-    return UseStmt(sp, path);\n-}\n-\n-void ExternBlock::add_item(Named<Item> named_item)\n-{\n-    ASSERT_BUG(named_item.data.span, named_item.data.is_Function() || named_item.data.is_Static(), \"Incorrect item type for ExternBlock\");\n-    m_items.push_back( mv$(named_item) );\n-}\n-ExternBlock ExternBlock::clone() const\n-{\n-    TODO(Span(), \"Clone an extern block\");\n-}\n-\n-::std::shared_ptr<AST::Module> Module::add_anon() {\n-    auto rv = ::std::shared_ptr<AST::Module>( new Module(m_my_path + FMT(\"#\" << m_anon_modules.size())) );\n-    DEBUG(\"New anon \" << rv->m_my_path);\n-    rv->m_file_info = m_file_info;\n-\n-    m_anon_modules.push_back( rv );\n-\n-    return rv;\n-}\n-\n-void Module::add_item( Named<Item> named_item ) {\n-    m_items.push_back( mv$(named_item) );\n-    const auto& i = m_items.back();\n-    if( i.name == \"\" ) {\n-    }\n-    else {\n-        DEBUG(m_my_path << \"::\" << i.name << \" = \" << i.data.tag_str() << \", attrs = \" << i.data.attrs);\n-    }\n-}\n-void Module::add_item(bool is_pub, ::std::string name, Item it, AttributeList attrs) {\n-    it.attrs = mv$(attrs);\n-    add_item( Named<Item>( mv$(name), mv$(it), is_pub ) );\n-}\n-void Module::add_ext_crate(bool is_public, ::std::string ext_name, ::std::string imp_name, AttributeList attrs) {\n-    this->add_item( is_public, imp_name, Item::make_Crate({mv$(ext_name)}), mv$(attrs) );\n-}\n-void Module::add_alias(bool is_public, UseStmt us, ::std::string name, AttributeList attrs) {\n-    this->add_item( is_public, mv$(name), Item(mv$(us)), mv$(attrs) );\n-}\n-void Module::add_macro_invocation(MacroInvocation item) {\n-    this->add_item( false, \"\", Item( mv$(item) ), ::AST::AttributeList {} );\n-}\n-void Module::add_macro(bool is_exported, ::std::string name, MacroRulesPtr macro) {\n-    m_macros.push_back( Named<MacroRulesPtr>( mv$(name), mv$(macro), is_exported ) );\n-}\n-void Module::add_macro_import(::std::string name, const MacroRules& mr) {\n-    m_macro_import_res.push_back( Named<const MacroRules*>( mv$(name), &mr, false ) );\n-}\n-\n-Item Item::clone() const\n-{\n-    TU_MATCHA( (*this), (e),\n-    (None,\n-        return AST::Item(e);\n-        ),\n-    (MacroInv,\n-        TODO(this->span, \"Clone on Item::MacroInv\");\n-        ),\n-    (Use,\n-        return AST::Item(e.clone());\n-        ),\n-    (ExternBlock,\n-        TODO(this->span, \"Clone on Item::\" << this->tag_str());\n-        ),\n-    (Impl,\n-        TODO(this->span, \"Clone on Item::Impl\");\n-        ),\n-    (NegImpl,\n-        TODO(this->span, \"Clone on Item::NegImpl\");\n-        ),\n-    (Module,\n-        TODO(this->span, \"Clone on Item::Module\");\n-        ),\n-    (Crate,\n-        return AST::Item(e);\n-        ),\n-    (Type,\n-        return AST::Item(e.clone());\n-        ),\n-    (Struct,\n-        return AST::Item(e.clone());\n-        ),\n-    (Enum,\n-        return AST::Item(e.clone());\n-        ),\n-    (Union,\n-        return AST::Item(e.clone());\n-        ),\n-    (Trait,\n-        return AST::Item(e.clone());\n-        ),\n-\n-    (Function,\n-        return AST::Item(e.clone());\n-        ),\n-    (Static,\n-        return AST::Item(e.clone());\n-        )\n-    )\n-    throw \"\";\n-}\n-\n-\n-\n-::std::ostream& operator<<(::std::ostream& os, const TypeParam& tp)\n-{\n-    //os << \"TypeParam(\";\n-    os << tp.m_name;\n-    os << \" = \";\n-    os << tp.m_default;\n-    //os << \")\";\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const LifetimeParam& p)\n-{\n-    os << \"'\" << p.m_name;\n-    return os;\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const HigherRankedBounds& x)\n-{\n-    if( x.m_lifetimes.empty() ) {\n-        return os;\n-    }\n-    os << \"for<\";\n-    for(const auto& l : x.m_lifetimes)\n-        os << \"'\" << l << \",\";\n-    os << \"> \";\n-    return os;\n-}\n-\n-\n-::std::ostream& operator<<(::std::ostream& os, const GenericBound& x)\n-{\n-    TU_MATCH(GenericBound, (x), (ent),\n-    (None,\n-        os << \"/*-*/\";\n-        ),\n-    (Lifetime,\n-        os << \"'\" << ent.test << \": '\" << ent.bound;\n-        ),\n-    (TypeLifetime,\n-        os << ent.type << \": '\" << ent.bound;\n-        ),\n-    (IsTrait,\n-        os << ent.outer_hrbs << ent.type << \": \" << ent.inner_hrbs << ent.trait;\n-        ),\n-    (MaybeTrait,\n-        os << ent.type << \": ?\" << ent.trait;\n-        ),\n-    (NotTrait,\n-        os << ent.type << \": !\" << ent.trait;\n-        ),\n-    (Equality,\n-        os << ent.type << \" = \" << ent.replacement;\n-        )\n-    )\n-    return os;\n-}\n-\n-\n-int GenericParams::find_name(const char* name) const\n-{\n-    for( unsigned int i = 0; i < m_type_params.size(); i ++ )\n-    {\n-        if( m_type_params[i].name() == name )\n-            return i;\n-    }\n-    DEBUG(\"Type param '\" << name << \"' not in list\");\n-    return -1;\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const GenericParams& tps)\n-{\n-    return os << \"<\" << tps.m_lifetime_params << \",\" << tps.m_type_params << \"> where {\" << tps.m_bounds << \"}\";\n-}\n-\n-}    // namespace AST"}, {"sha": "0a43cc713bf83f734810dd40bc190225da05d257", "filename": "gcc/rust/mrustc_parser/ast/ast.hpp", "status": "removed", "additions": 0, "deletions": 638, "changes": 638, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fast.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,638 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/ast.hpp\n- * - Core AST header\n- */\n-#ifndef AST_HPP_INCLUDED\n-#define AST_HPP_INCLUDED\n-\n-#include <string>\n-#include <vector>\n-#include <stdexcept>\n-#include \"../coretypes.hpp\"\n-#include <memory>\n-#include <map>\n-#include <unordered_map>\n-#include <algorithm>\n-\n-#include \"../parse/tokentree.hpp\"\n-#include \"types.hpp\"\n-\n-#include <ast/pattern.hpp>\n-#include <ast/attrs.hpp>\n-#include <ast/expr_ptr.hpp>\n-#include <ast/item.hpp>\n-#include <ast/macro.hpp>    // MacroInvocation\n-\n-#include \"generics.hpp\"\n-\n-#include <macro_rules/macro_rules_ptr.hpp>\n-\n-namespace AST {\n-\n-class Crate;\n-\n-class Module;\n-class Item;\n-\n-using ::std::unique_ptr;\n-using ::std::move;\n-\n-enum eItemType\n-{\n-    ITEM_TRAIT,\n-    ITEM_STRUCT,\n-    ITEM_FN,\n-    ITEM_STATIC,\n-};\n-\n-struct StructItem\n-{\n-    ::AST::AttributeList   m_attrs;\n-    bool    m_is_public;\n-    ::std::string   m_name;\n-    TypeRef m_type;\n-\n-    //StructItem() {}\n-\n-    StructItem(::AST::AttributeList attrs, bool is_pub, ::std::string name, TypeRef ty):\n-        m_attrs( mv$(attrs) ),\n-        m_is_public(is_pub),\n-        m_name( mv$(name) ),\n-        m_type( mv$(ty) )\n-    {\n-    }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const StructItem& x) {\n-        return os << (x.m_is_public ? \"pub \" : \"\") << x.m_name << \": \" << x.m_type;\n-    }\n-\n-    StructItem clone() const;\n-};\n-\n-struct TupleItem\n-{\n-    ::AST::AttributeList    m_attrs;\n-    bool    m_is_public;\n-    TypeRef m_type;\n-\n-    //TupleItem() {}\n-\n-    TupleItem(::AST::AttributeList attrs, bool is_pub, TypeRef ty):\n-        m_attrs( mv$(attrs) ),\n-        m_is_public(is_pub),\n-        m_type( mv$(ty) )\n-    {\n-    }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const TupleItem& x) {\n-        return os << (x.m_is_public ? \"pub \" : \"\") << x.m_type;\n-    }\n-\n-    TupleItem clone() const;\n-};\n-\n-class TypeAlias\n-{\n-    GenericParams  m_params;\n-    TypeRef m_type;\n-public:\n-    //TypeAlias() {}\n-    TypeAlias(GenericParams params, TypeRef type):\n-        m_params( move(params) ),\n-        m_type( move(type) )\n-    {}\n-\n-    const GenericParams& params() const { return m_params; }\n-    const TypeRef& type() const { return m_type; }\n-\n-    GenericParams& params() { return m_params; }\n-    TypeRef& type() { return m_type; }\n-\n-    TypeAlias clone() const;\n-};\n-\n-class Static\n-{\n-public:\n-    enum Class\n-    {\n-        CONST,\n-        STATIC,\n-        MUT,\n-    };\n-private:\n-    Class   m_class;\n-    TypeRef m_type;\n-    Expr    m_value;\n-public:\n-    Static(Class s_class, TypeRef type, Expr value):\n-        m_class(s_class),\n-        m_type( move(type) ),\n-        m_value( move(value) )\n-    {}\n-\n-    const Class& s_class() const { return m_class; }\n-    const TypeRef& type() const { return m_type; }\n-    const Expr& value() const { return m_value; }\n-\n-    TypeRef& type() { return m_type; }\n-    Expr& value() { return m_value; }\n-\n-    Static clone() const;\n-};\n-\n-class Function\n-{\n-public:\n-    typedef ::std::vector< ::std::pair<AST::Pattern,TypeRef> >   Arglist;\n-\n-private:\n-    Span    m_span;\n-    GenericParams  m_params;\n-    Expr    m_code;\n-    TypeRef m_rettype;\n-    Arglist m_args;\n-\n-    ::std::string   m_abi;\n-    bool    m_is_const;\n-    bool    m_is_unsafe;\n-    bool    m_is_variadic;  // extern only\n-public:\n-    Function(const Function&) = delete;\n-    Function& operator=(const Function&) = delete;\n-    Function(Function&&) = default;\n-    Function& operator=(Function&&) = default;\n-\n-    Function(Span sp, GenericParams params, ::std::string abi, bool is_unsafe, bool is_const, bool is_variadic, TypeRef ret_type, Arglist args);\n-\n-    void set_code(Expr code) { m_code = ::std::move(code); }\n-\n-    const ::std::string& abi() const { return m_abi; };\n-    bool is_const() const { return m_is_const; }\n-    bool is_unsafe() const { return m_is_unsafe; }\n-    bool is_variadic() const { return m_is_variadic; }\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-    const Expr& code() const { return m_code; }\n-          Expr& code()       { return m_code; }\n-    const TypeRef& rettype() const { return m_rettype; }\n-          TypeRef& rettype()       { return m_rettype; }\n-    const Arglist& args() const { return m_args; }\n-          Arglist& args()       { return m_args; }\n-\n-    Function clone() const;\n-};\n-\n-class Trait\n-{\n-    GenericParams  m_params;\n-    ::std::vector< Spanned<Type_TraitPath> > m_supertraits;\n-\n-    bool m_is_marker;\n-    bool m_is_unsafe;\n-    NamedList<Item> m_items;\n-public:\n-    Trait():\n-        m_is_marker(false),\n-        m_is_unsafe(false)\n-    {}\n-    Trait(GenericParams params, ::std::vector< Spanned<Type_TraitPath> > supertraits):\n-        m_params( mv$(params) ),\n-        m_supertraits( mv$(supertraits) ),\n-        m_is_marker(false),\n-        m_is_unsafe(false)\n-    {\n-    }\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-    const ::std::vector<Spanned<Type_TraitPath> >& supertraits() const { return m_supertraits; }\n-          ::std::vector<Spanned<Type_TraitPath> >& supertraits()       { return m_supertraits; }\n-\n-    const NamedList<Item>& items() const { return m_items; }\n-          NamedList<Item>& items()       { return m_items; }\n-\n-    void add_type(::std::string name, AttributeList attrs, TypeRef type);\n-    void add_function(::std::string name, AttributeList attrs, Function fcn);\n-    void add_static(::std::string name, AttributeList attrs, Static v);\n-\n-    void set_is_marker();\n-    bool is_marker() const;\n-    void set_is_unsafe() { m_is_unsafe = true; }\n-    bool is_unsafe() const { return m_is_unsafe; }\n-\n-    bool has_named_item(const ::std::string& name, bool& out_is_fcn) const;\n-\n-    Trait clone() const;\n-};\n-\n-TAGGED_UNION_EX(EnumVariantData, (), Value,\n-    (\n-    (Value, struct {\n-        ::AST::Expr m_value;\n-        }),\n-    (Tuple, struct {\n-        ::std::vector<TypeRef>  m_sub_types;\n-        }),\n-    (Struct, struct {\n-        ::std::vector<StructItem>   m_fields;\n-        })\n-    ),\n-    (), (),\n-    (\n-    public:\n-    )\n-    );\n-\n-struct EnumVariant\n-{\n-    AttributeList   m_attrs;\n-    ::std::string   m_name;\n-    EnumVariantData m_data;\n-\n-    EnumVariant()\n-    {\n-    }\n-\n-    EnumVariant(AttributeList attrs, ::std::string name, Expr&& value):\n-        m_attrs( mv$(attrs) ),\n-        m_name( mv$(name) ),\n-        m_data( EnumVariantData::make_Value({mv$(value)}) )\n-    {\n-    }\n-\n-    EnumVariant(AttributeList attrs, ::std::string name, ::std::vector<TypeRef> sub_types):\n-        m_attrs( mv$(attrs) ),\n-        m_name( ::std::move(name) ),\n-        m_data( EnumVariantData::make_Tuple( {mv$(sub_types)} ) )\n-    {\n-    }\n-\n-    EnumVariant(AttributeList attrs, ::std::string name, ::std::vector<StructItem> fields):\n-        m_attrs( mv$(attrs) ),\n-        m_name( ::std::move(name) ),\n-        m_data( EnumVariantData::make_Struct( {mv$(fields)} ) )\n-    {\n-    }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const EnumVariant& x)\n-    {\n-        os << \"EnumVariant(\" << x.m_name;\n-        TU_MATCH(EnumVariantData, (x.m_data), (e),\n-        (Value,\n-            os << \" = \" << e.m_value;\n-            ),\n-        (Tuple,\n-            os << \"(\" << e.m_sub_types << \")\";\n-            ),\n-        (Struct,\n-            os << \" { \" << e.m_fields << \" }\";\n-            )\n-        )\n-        return os << \")\";\n-    }\n-};\n-\n-class Enum\n-{\n-    GenericParams    m_params;\n-    ::std::vector<EnumVariant>   m_variants;\n-public:\n-    Enum() {}\n-    Enum( GenericParams params, ::std::vector<EnumVariant> variants ):\n-        m_params( move(params) ),\n-        m_variants( move(variants) )\n-    {}\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-    const ::std::vector<EnumVariant>& variants() const { return m_variants; }\n-          ::std::vector<EnumVariant>& variants()       { return m_variants; }\n-\n-    Enum clone() const;\n-};\n-\n-TAGGED_UNION_EX(StructData, (), Struct,\n-    (\n-    (Unit, struct {}),\n-    (Tuple, struct {\n-        ::std::vector<TupleItem>    ents;\n-        }),\n-    (Struct, struct {\n-        ::std::vector<StructItem>   ents;\n-        })\n-    ),\n-    (),(),\n-    (\n-    public:\n-        )\n-    );\n-\n-class Struct\n-{\n-    GenericParams    m_params;\n-public:\n-    StructData  m_data;\n-\n-    Struct() {}\n-    Struct(GenericParams params):\n-        m_params( mv$(params) ),\n-        m_data( StructData::make_Unit({}) )\n-    {\n-    }\n-    Struct( GenericParams params, ::std::vector<StructItem> fields ):\n-        m_params( move(params) ),\n-        m_data( StructData::make_Struct({mv$(fields)}) )\n-    {}\n-    Struct( GenericParams params, ::std::vector<TupleItem> fields ):\n-        m_params( move(params) ),\n-        m_data( StructData::make_Tuple({mv$(fields)}) )\n-    {}\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-\n-    Struct clone() const;\n-};\n-\n-class Union\n-{\n-public:\n-    GenericParams   m_params;\n-    ::std::vector<StructItem>   m_variants;\n-\n-    Union( GenericParams params, ::std::vector<StructItem> fields ):\n-        m_params( move(params) ),\n-        m_variants( mv$(fields) )\n-    {}\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-\n-    Union clone() const;\n-};\n-\n-class ImplDef\n-{\n-    AttributeList   m_attrs;\n-    bool    m_is_unsafe;\n-    GenericParams  m_params;\n-    Spanned<Path>   m_trait;\n-    TypeRef m_type;\n-public:\n-    ImplDef(AttributeList attrs, GenericParams params, Spanned<Path> trait_type, TypeRef impl_type):\n-        m_attrs( mv$(attrs) ),\n-        m_is_unsafe( false ),\n-        m_params( mv$(params) ),\n-        m_trait( mv$(trait_type) ),\n-        m_type( mv$(impl_type) )\n-    {}\n-\n-    ImplDef(ImplDef&&) /*noexcept*/ = default;\n-    ImplDef& operator=(ImplDef&&) = default;\n-\n-    void set_is_unsafe() { m_is_unsafe = true; }\n-    bool is_unsafe() const { return m_is_unsafe; }\n-\n-    // Accessors\n-    const AttributeList& attrs() const { return m_attrs; }\n-          AttributeList& attrs()       { return m_attrs; }\n-\n-    const GenericParams& params() const { return m_params; }\n-          GenericParams& params()       { return m_params; }\n-    const Spanned<Path>& trait() const { return m_trait; }\n-          Spanned<Path>& trait()       { return m_trait; }\n-    const TypeRef& type() const { return m_type; }\n-          TypeRef& type()       { return m_type; }\n-\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const ImplDef& impl);\n-};\n-\n-class Impl\n-{\n-public:\n-    struct ImplItem {\n-        bool    is_pub; // Ignored for trait impls\n-        bool    is_specialisable;\n-        ::std::string   name;\n-\n-        ::std::unique_ptr<Item> data;\n-    };\n-\n-private:\n-    ImplDef m_def;\n-\n-    ::std::vector< ImplItem >   m_items;\n-    //NamedList<TypeRef>   m_types;\n-    //NamedList<Function>  m_functions;\n-    //NamedList<Static>    m_statics;\n-\n-public:\n-    Impl(Impl&&) /*noexcept*/ = default;\n-    Impl(ImplDef def):\n-        m_def( mv$(def) )\n-    {}\n-    Impl& operator=(Impl&&) = default;\n-\n-    void add_function(bool is_public, bool is_specialisable, ::std::string name, Function fcn);\n-    void add_type(bool is_public, bool is_specialisable, ::std::string name, TypeRef type);\n-    void add_static(bool is_public, bool is_specialisable, ::std::string name, Static v);\n-    void add_macro_invocation( MacroInvocation inv );\n-\n-    const ImplDef& def() const { return m_def; }\n-          ImplDef& def()       { return m_def; }\n-    const ::std::vector<ImplItem>& items() const { return m_items; }\n-          ::std::vector<ImplItem>& items()       { return m_items; }\n-\n-    bool has_named_item(const ::std::string& name) const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Impl& impl);\n-\n-private:\n-};\n-\n-struct UseStmt\n-{\n-    Span    sp;\n-    ::AST::Path path;\n-    ::AST::PathBinding  alt_binding;\n-\n-    UseStmt(Span sp, Path p):\n-        sp(sp),\n-        path(p)\n-    {\n-    }\n-\n-    UseStmt clone() const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const UseStmt& x);\n-};\n-\n-class ExternBlock\n-{\n-    ::std::string   m_abi;\n-    ::std::vector< Named<Item>> m_items;\n-public:\n-    ExternBlock(::std::string abi):\n-        m_abi( mv$(abi) )\n-    {}\n-\n-    const ::std::string& abi() const { return m_abi; }\n-\n-    void add_item(Named<Item> named_item);\n-\n-    // NOTE: Only Function and Static are valid.\n-          ::std::vector<Named<Item>>& items()       { return m_items; }\n-    const ::std::vector<Named<Item>>& items() const { return m_items; }\n-\n-    ExternBlock clone() const;\n-};\n-\n-/// Representation of a parsed (and being converted) function\n-class Module\n-{\n-    ::AST::Path m_my_path;\n-\n-    // Module-level items\n-    /// General items\n-    ::std::vector<Named<Item>>  m_items;\n-\n-    // --- Runtime caches and state ---\n-    ::std::vector< ::std::shared_ptr<Module> >  m_anon_modules;\n-\n-    ::std::vector< Named<const MacroRules*> >   m_macro_import_res;\n-    ::std::vector< Named<MacroRulesPtr> >  m_macros;\n-\n-public:\n-    struct FileInfo\n-    {\n-        bool    controls_dir = false;\n-        ::std::string   path = \"!\";\n-    };\n-\n-    FileInfo    m_file_info;\n-\n-    bool    m_insert_prelude = true;    // Set to false by `#[no_prelude]` handler\n-    char    m_index_populated = 0;  // 0 = no, 1 = partial, 2 = complete\n-    struct IndexEnt {\n-        bool is_pub;    // Used as part of glob import checking\n-        bool is_import; // Set if this item has a path that isn't `mod->path() + name`\n-        ::AST::Path path;\n-    };\n-\n-    // TODO: Document difference between namespace and Type\n-    ::std::unordered_map< ::std::string, IndexEnt >    m_namespace_items;\n-    ::std::unordered_map< ::std::string, IndexEnt >    m_type_items;\n-    ::std::unordered_map< ::std::string, IndexEnt >    m_value_items;\n-\n-    // List of macros imported from other modules (via #[macro_use], includes proc macros)\n-    // - First value is an absolute path to the macro (including crate name)\n-    ::std::vector<::std::pair< ::std::vector<::std::string>, const MacroRules* >>  m_macro_imports;\n-\n-public:\n-    Module() {}\n-    Module(::AST::Path path):\n-        m_my_path( mv$(path) )\n-    {\n-    }\n-\n-    bool is_anon() const {\n-        return m_my_path.nodes().size() > 0 && m_my_path.nodes().back().name()[0] == '#';\n-    }\n-\n-    /// Create an anon module (for use inside expressions)\n-    ::std::shared_ptr<AST::Module> add_anon();\n-\n-    void add_item(Named<Item> item);\n-    void add_item(bool is_pub, ::std::string name, Item it, AttributeList attrs);\n-    void add_ext_crate(bool is_public, ::std::string ext_name, ::std::string imp_name, AttributeList attrs);\n-    void add_alias(bool is_public, UseStmt path, ::std::string name, AttributeList attrs);\n-    void add_macro_invocation(MacroInvocation item);\n-\n-    void add_macro(bool is_exported, ::std::string name, MacroRulesPtr macro);\n-    void add_macro_import(::std::string name, const MacroRules& mr);\n-\n-\n-\n-    const ::AST::Path& path() const { return m_my_path; }\n-\n-          ::std::vector<Named<Item>>& items()       { return m_items; }\n-    const ::std::vector<Named<Item>>& items() const { return m_items; }\n-\n-          ::std::vector< ::std::shared_ptr<Module> >&   anon_mods()       { return m_anon_modules; }\n-    const ::std::vector< ::std::shared_ptr<Module> >&   anon_mods() const { return m_anon_modules; }\n-\n-\n-          NamedList<MacroRulesPtr>&    macros()        { return m_macros; }\n-    const NamedList<MacroRulesPtr>&    macros()  const { return m_macros; }\n-    const ::std::vector<Named<const MacroRules*> >  macro_imports_res() const { return m_macro_import_res; }\n-\n-private:\n-    void resolve_macro_import(const Crate& crate, const ::std::string& modname, const ::std::string& macro_name);\n-};\n-\n-TAGGED_UNION_EX(Item, (), None,\n-    (\n-    (None, struct {} ),\n-    (MacroInv, MacroInvocation),\n-    (Use, UseStmt),\n-\n-    // Nameless items\n-    (ExternBlock, ExternBlock),\n-    (Impl, Impl),\n-    (NegImpl, ImplDef),\n-\n-    (Module, Module),\n-    (Crate, struct {\n-        ::std::string   name;\n-        }),\n-\n-    (Type, TypeAlias),\n-    (Struct, Struct),\n-    (Enum, Enum),\n-    (Union, Union),\n-    (Trait, Trait),\n-\n-    (Function, Function),\n-    (Static, Static)\n-    ),\n-\n-    (, attrs(mv$(x.attrs))), (attrs = mv$(x.attrs);),\n-    (\n-    public:\n-        AttributeList  attrs;\n-        Span    span;\n-\n-        Item clone() const;\n-    )\n-    );\n-\n-} // namespace AST\n-\n-class GenericResolveClosure\n-{\n-    const ::AST::GenericParams&  m_params;\n-    const ::std::vector<TypeRef>&   m_args;\n-public:\n-    GenericResolveClosure(const AST::GenericParams& params, const ::std::vector<TypeRef>& args):\n-        m_params(params),\n-        m_args(args)\n-    {}\n-    const TypeRef& operator()(const char *argname) {\n-        for(unsigned int i = 0; i < m_params.ty_params().size(); i ++)\n-        {\n-            if( m_params.ty_params()[i].name() == argname ) {\n-                return m_args.at(i);\n-            }\n-        }\n-        throw ::std::runtime_error(\"BUGCHECK - Unknown arg in field type\");\n-    }\n-};\n-\n-\n-#endif // AST_HPP_INCLUDED"}, {"sha": "0e1c8149dc35b81bfa5b90fd1f8ebbed8ce76b37", "filename": "gcc/rust/mrustc_parser/ast/attrs.hpp", "status": "removed", "additions": 0, "deletions": 157, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fattrs.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,157 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/attrs.hpp\n- * - AST Attributes (#[foo] and #![foo])\n- */\n-#ifndef _AST_ATTRS_HPP_\n-#define _AST_ATTRS_HPP_\n-\n-\n-namespace AST {\n-\n-//\n-class Attribute;\n-::std::ostream& operator<<(::std::ostream& os, const Attribute& x);\n-\n-/// A list of attributes on an item (searchable by the attribute name)\n-class AttributeList\n-{\n-public:\n-    ::std::vector<Attribute> m_items;\n-\n-    AttributeList() {}\n-    AttributeList(::std::vector<Attribute> items):\n-        m_items( mv$(items) )\n-    {\n-    }\n-\n-    // Move present\n-    AttributeList(AttributeList&&) = default;\n-    AttributeList& operator=(AttributeList&&) = default;\n-    // No copy assign, but explicit copy\n-    explicit AttributeList(const AttributeList&) = default;\n-    AttributeList& operator=(const AttributeList&) = delete;\n-    // Explicit clone\n-    AttributeList clone() const;\n-\n-    void push_back(Attribute i);\n-\n-    const Attribute* get(const char *name) const;\n-    Attribute* get(const char *name) {\n-        return const_cast<Attribute*>( const_cast<const AttributeList*>(this)->get(name));\n-    }\n-    bool has(const char *name) const {\n-        return get(name) != 0;\n-    }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const AttributeList& x) {\n-        for(const auto& i : x.m_items) {\n-            os << \"#[\" << i << \"]\";\n-        }\n-        return os;\n-    }\n-};\n-\n-\n-TAGGED_UNION(AttributeData, None,\n-    (None, struct {}),\n-    (String, struct {\n-        ::std::string   val;\n-        }),\n-    (List, struct {\n-        ::std::vector<Attribute> sub_items;\n-        })\n-    );\n-\n-// An attribute can has a name, and optional data:\n-// Data can be:\n-// - A parenthesised token tree\n-//   > In 1.19 this was actually just sub-attributes\n-// - an associated (string) literal\n-\n-class Attribute\n-{\n-    Span    m_span;\n-    ::std::string   m_name;\n-    AttributeData   m_data;\n-    mutable bool    m_is_used;\n-public:\n-    Attribute(Span sp, ::std::string name):\n-        m_span(::std::move(sp)),\n-        m_name(name),\n-        m_data( AttributeData::make_None({}) )\n-    {\n-    }\n-    Attribute(Span sp, ::std::string name, ::std::string str_val):\n-        m_span(::std::move(sp)),\n-        m_name(name),\n-        m_data( AttributeData::make_String({mv$(str_val)}) )\n-    {\n-    }\n-    Attribute(Span sp, ::std::string name, ::std::vector<Attribute> items):\n-        m_span(::std::move(sp)),\n-        m_name(name),\n-        m_data( AttributeData::make_List({mv$(items)}) )\n-    {\n-    }\n-\n-    explicit Attribute(const Attribute& x):\n-        m_span(x.m_span),\n-        m_name(x.m_name),\n-        m_is_used(x.m_is_used)\n-    {\n-        TU_MATCHA( (x.m_data), (e),\n-        (None,\n-            ),\n-        (String,\n-            m_data = AttributeData::make_String({ e.val });\n-            ),\n-        (List,\n-            m_data = AttributeData::make_List({ ::std::vector<Attribute>(e.sub_items) });\n-            )\n-        )\n-    }\n-    Attribute& operator=(const Attribute& ) = delete;\n-    Attribute(Attribute&& ) = default;\n-    Attribute& operator=(Attribute&& ) = default;\n-    Attribute clone() const;\n-\n-    void mark_used() const { m_is_used = true; }\n-    bool is_used() const { return m_is_used; }\n-\n-    const Span& span() const { return m_span; }\n-    const ::std::string& name() const { return m_name; }\n-    const AttributeData& data() const { return m_data; }\n-\n-    // Legacy accessors/checkers\n-    bool has_noarg() const { return m_data.is_None(); }\n-\n-    bool has_string() const { return m_data.is_String(); }\n-    const ::std::string& string() const { return m_data.as_String().val; }\n-\n-    bool has_sub_items() const { return m_data.is_List(); }\n-    const ::std::vector<Attribute>& items() const { return m_data.as_List().sub_items; }\n-          ::std::vector<Attribute>& items()       { return m_data.as_List().sub_items; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Attribute& x) {\n-        os << x.m_name;\n-        TU_MATCHA( (x.m_data), (e),\n-        (None,\n-            ),\n-        (String,\n-            os << \"=\\\"\" << e.val << \"\\\"\";\n-            ),\n-        (List,\n-            os << \"(\" << e.sub_items << \")\";\n-            )\n-        )\n-        return os;\n-    }\n-};\n-\n-}   // namespace AST\n-\n-#endif\n-"}, {"sha": "3db09f1b9e21cd98c7fe7fad8ace9e2a3b58991a", "filename": "gcc/rust/mrustc_parser/ast/crate.cpp", "status": "removed", "additions": 0, "deletions": 209, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,209 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/crate.cpp\n- * - Helper functions for the AST::Crate type (includes loading `extern crate`s)\n- */\n-#include \"crate.hpp\"\n-#include \"ast.hpp\"\n-#include \"../parse/parseerror.hpp\"\n-#include \"../expand/cfg.hpp\"\n-#include <hir/hir.hpp>  // HIR::Crate\n-#include <hir/main_bindings.hpp>    // HIR_Deserialise\n-#include <fstream>\n-\n-::std::vector<::std::string>    AST::g_crate_load_dirs = { };\n-::std::map<::std::string, ::std::string>    AST::g_crate_overrides;\n-\n-namespace {\n-    bool check_item_cfg(const ::AST::AttributeList& attrs)\n-    {\n-        for(const auto& at : attrs.m_items) {\n-            if( at.name() == \"cfg\" && !check_cfg(at.span(), at) ) {\n-                return false;\n-            }\n-        }\n-        return true;\n-    }\n-    void iterate_module(::AST::Module& mod, ::std::function<void(::AST::Module& mod)> fcn)\n-    {\n-        fcn(mod);\n-        for( auto& sm : mod.items() )\n-        {\n-            TU_IFLET(::AST::Item, sm.data, Module, e,\n-                if( check_item_cfg(sm.data.attrs) )\n-                {\n-                    iterate_module(e, fcn);\n-                }\n-            )\n-        }\n-        // TODO: What about if an anon mod has been #[cfg]-d out?\n-        // - For now, disable\n-        //for(const auto& anon : mod.anon_mods() ) {\n-        //    iterate_module(*anon, fcn);\n-        //}\n-    }\n-}\n-\n-\n-namespace AST {\n-\n-Crate::Crate():\n-    m_root_module(::AST::Path(\"\",{})),\n-    m_load_std(LOAD_STD)\n-{\n-}\n-\n-void Crate::load_externs()\n-{\n-    auto cb = [this](Module& mod) {\n-        for( /*const*/ auto& it : mod.items() )\n-        {\n-            TU_IFLET(AST::Item, it.data, Crate, c,\n-                if( check_item_cfg(it.data.attrs) )\n-                {\n-                    c.name = load_extern_crate( it.data.span, c.name );\n-                }\n-            )\n-        }\n-        };\n-    iterate_module(m_root_module, cb);\n-\n-    // Check for no_std or no_core, and load libstd/libcore\n-    // - Duplicates some of the logic in \"Expand\", but also helps keep crate loading separate to most of expand\n-    // NOTE: Not all crates are loaded here, any crates loaded by macro invocations will be done during expand.\n-    bool no_std  = false;\n-    bool no_core = false;\n-\n-    for( const auto& a : this->m_attrs.m_items )\n-    {\n-        if( a.name() == \"no_std\" )\n-            no_std = true;\n-        if( a.name() == \"no_core\" )\n-            no_core = true;\n-        if( a.name() == \"cfg_attr\" && a.items().size() == 2 ) {\n-            if( check_cfg(a.span(), a.items().at(0)) )\n-            {\n-                const auto& a2 = a.items().at(1);\n-                if( a2.name() == \"no_std\" )\n-                    no_std = true;\n-                if( a2.name() == \"no_core\" )\n-                    no_core = true;\n-            }\n-        }\n-    }\n-\n-    if( no_core ) {\n-        // Don't load anything\n-    }\n-    else if( no_std ) {\n-        auto n = this->load_extern_crate(Span(), \"core\");\n-        ASSERT_BUG(Span(), n == \"core\", \"libcore wasn't loaded as `core`, instead `\" << n << \"`\");\n-    }\n-    else {\n-        auto n = this->load_extern_crate(Span(), \"std\");\n-        ASSERT_BUG(Span(), n == \"std\", \"libstd wasn't loaded as `std`, instead `\" << n << \"`\");\n-    }\n-}\n-// TODO: Handle disambiguating crates with the same name (e.g. libc in std and crates.io libc)\n-// - Crates recorded in rlibs should specify a hash/tag that's passed in to this function.\n-::std::string Crate::load_extern_crate(Span sp, const ::std::string& name, const ::std::string& basename/*=\"\"*/)\n-{\n-    DEBUG(\"Loading crate '\" << name << \"'\");\n-\n-    ::std::string   path;\n-    auto it = g_crate_overrides.find(name);\n-    if(basename == \"\" && it != g_crate_overrides.end())\n-    {\n-        path = it->second;\n-        if( !::std::ifstream(path).good() ) {\n-            ERROR(sp, E0000, \"Unable to open crate '\" << name << \"' at path \" << path);\n-        }\n-    }\n-    else\n-    {\n-        // Search a list of load paths for the crate\n-        for(const auto& p : g_crate_load_dirs)\n-        {\n-            if( basename == \"\" )\n-            {\n-                path = p + \"/lib\" + name + \".hir\";\n-                // TODO: Search for `p+\"/lib\"+name+\"-*.hir\" (which would match e.g. libnum-0.11.hir)\n-            }\n-            else\n-            {\n-                path = p + \"/\" + basename;\n-            }\n-\n-            if( ::std::ifstream(path).good() ) {\n-                break ;\n-            }\n-        }\n-        if( !::std::ifstream(path).good() ) {\n-            if( basename.empty() )\n-                ERROR(sp, E0000, \"Unable to locate crate '\" << name << \"' in search directories\");\n-            else\n-                ERROR(sp, E0000, \"Unable to locate crate '\" << name << \"' with filename \" << basename << \" in search directories\");\n-        }\n-    }\n-\n-    // NOTE: Creating `ExternCrate` loads the crate from the specified path\n-    auto ec = ExternCrate { name, path };\n-    auto real_name = ec.m_hir->m_crate_name;\n-    assert(!real_name.empty());\n-    auto res = m_extern_crates.insert(::std::make_pair( real_name, mv$(ec) ));\n-    if( !res.second ) {\n-        // Crate already loaded?\n-    }\n-    auto& ext_crate = res.first->second;\n-    // Move the external list out (doesn't need to be kept in the nested crate)\n-    auto crate_ext_list = mv$( ext_crate.m_hir->m_ext_crates );\n-\n-    // Load referenced crates\n-    for( const auto& ext : crate_ext_list )\n-    {\n-        if( m_extern_crates.count(ext.first) == 0 )\n-        {\n-            const auto load_name = this->load_extern_crate(sp, ext.first, ext.second.m_basename);\n-            if( load_name != ext.first )\n-            {\n-                // ERROR - The crate loaded wasn't the one that was used when compiling this crate.\n-                ERROR(sp, E0000, \"The crate file `\" << ext.second.m_basename << \"` didn't load the expected crate - have \" << load_name << \" != exp \" << ext.first);\n-            }\n-        }\n-    }\n-\n-    DEBUG(\"Loaded '\" << name << \"' from '\" << basename << \"' (actual name is '\" << real_name << \"')\");\n-    return real_name;\n-}\n-\n-ExternCrate::ExternCrate(const ::std::string& name, const ::std::string& path):\n-    m_name(name),\n-    m_filename(path)\n-{\n-    TRACE_FUNCTION_F(\"name=\" << name << \", path='\" << path << \"'\");\n-    m_hir = HIR_Deserialise(path, name);\n-\n-    m_hir->post_load_update(name);\n-    m_name = m_hir->m_crate_name;\n-}\n-\n-void ExternCrate::with_all_macros(::std::function<void(const ::std::string& , const MacroRules&)> cb) const\n-{\n-    for(const auto& m : m_hir->m_exported_macros)\n-    {\n-        cb(m.first, *m.second);\n-    }\n-}\n-const MacroRules* ExternCrate::find_macro_rules(const ::std::string& name) const\n-{\n-    auto i = m_hir->m_exported_macros.find(name);\n-    if(i != m_hir->m_exported_macros.end())\n-        return &*i->second;\n-    return nullptr;\n-}\n-\n-\n-}   // namespace AST\n-"}, {"sha": "87a9f867b9ece1512518fe63a5c9811ce6b70a93", "filename": "gcc/rust/mrustc_parser/ast/crate.hpp", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fcrate.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,118 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/crate.hpp\n- * - AST::Crate type, and other top-level AST definitions\n- */\n-#pragma once\n-\n-#include \"ast.hpp\"\n-#include \"types.hpp\"\n-#include <hir/crate_ptr.hpp>\n-\n-namespace AST {\n-\n-\n-class ExternCrate;\n-\n-class TestDesc\n-{\n-public:\n-    ::AST::Path path;\n-    ::std::string   name;\n-    bool    ignore = false;\n-    bool    is_benchmark = false;\n-\n-    enum class ShouldPanic {\n-        No,\n-        Yes,\n-        YesWithMessage,\n-    } panic_type = ShouldPanic::No;\n-\n-    ::std::string   expected_panic_message;\n-};\n-\n-class ProcMacroDef\n-{\n-public:\n-    ::std::string   name;\n-    ::AST::Path path;\n-    ::std::vector<::std::string>    attributes;\n-};\n-\n-class Crate\n-{\n-public:\n-    ::AST::AttributeList    m_attrs;\n-\n-    ::std::map< ::std::string, ::AST::Path> m_lang_items;\n-public:\n-    Module  m_root_module;\n-    ::std::map< ::std::string, ExternCrate> m_extern_crates;\n-    // Mapping filled by searching for (?visible) macros with is_pub=true\n-    ::std::map< ::std::string, const MacroRules*> m_exported_macros;\n-\n-    // List of tests (populated in expand if --test is passed)\n-    bool    m_test_harness = false;\n-    ::std::vector<TestDesc>   m_tests;\n-\n-    //::std::vector<::std::string>    m_extra_files;\n-\n-    // Procedural macros!\n-    ::std::vector<ProcMacroDef> m_proc_macros;\n-\n-    enum class Type {\n-        Unknown,\n-        RustLib,\n-        RustDylib,\n-        CDylib,\n-        Executable,\n-        ProcMacro,   // Procedural macro\n-    } m_crate_type = Type::Unknown;\n-    enum LoadStd {\n-        LOAD_STD,\n-        LOAD_CORE,\n-        LOAD_NONE,\n-    } m_load_std = LOAD_STD;\n-    ::std::string   m_crate_name_suffix;\n-    ::std::string   m_crate_name;\n-    AST::Path   m_prelude_path;\n-\n-\n-    Crate();\n-\n-    const Module& root_module() const { return m_root_module; }\n-          Module& root_module()       { return m_root_module; }\n-\n-    /// Load referenced crates\n-    void load_externs();\n-\n-    /// Load the named crate and returns the crate's unique name\n-    /// If the parameter `file` is non-empty, only that particular filename will be loaded (from any of the search paths)\n-    ::std::string load_extern_crate(Span sp, const ::std::string& name, const ::std::string& file=\"\");\n-};\n-\n-/// Representation of an imported crate\n-class ExternCrate\n-{\n-public:\n-    ::std::string   m_name;\n-    ::std::string   m_filename;\n-    ::HIR::CratePtr m_hir;\n-\n-    ExternCrate(const ::std::string& name, const ::std::string& path);\n-\n-    ExternCrate(ExternCrate&&) = default;\n-    ExternCrate& operator=(ExternCrate&&) = default;\n-    ExternCrate(const ExternCrate&) = delete;\n-    ExternCrate& operator=(const ExternCrate& ) = delete;\n-\n-    void with_all_macros(::std::function<void(const ::std::string& , const MacroRules&)> cb) const;\n-    const MacroRules* find_macro_rules(const ::std::string& name) const;\n-};\n-\n-extern ::std::vector<::std::string>    g_crate_load_dirs;\n-extern ::std::map<::std::string, ::std::string>    g_crate_overrides;\n-\n-}   // namespace AST"}, {"sha": "f1481abff816733eeb6f1ce29f63b797ba607873", "filename": "gcc/rust/mrustc_parser/ast/dump.cpp", "status": "removed", "additions": 0, "deletions": 1179, "changes": 1179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fdump.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,1179 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/dump.cpp\n- * - Dumps the AST of a crate as rust code (annotated)\n- */\n-#include <ast/crate.hpp>\n-#include <ast/ast.hpp>\n-#include <ast/expr.hpp>\n-#include <main_bindings.hpp>\n-#include <hir/hir.hpp>  // ABI_RUST - TODO: Move elsewhere?\n-#include <fstream>\n-\n-#include <cpp_unpack.h>\n-\n-#define IS(v, c)    (dynamic_cast<c*>(&v) != 0)\n-#define WRAPIF_CMD(v, t)  || IS(v, t)\n-#define WRAPIF(uniq_ptr, class1, ...) do { auto& _v = *(uniq_ptr); if( IS(_v, class1) CC_ITERATE(WRAPIF_CMD, (_v), __VA_ARGS__) ) { paren_wrap(uniq_ptr); } else { AST::NodeVisitor::visit(uniq_ptr); } } while(0)\n-\n-class RustPrinter:\n-    public AST::NodeVisitor\n-{\n-    ::std::ostream& m_os;\n-    int m_indent_level;\n-    bool m_expr_root;   //!< used to allow 'if' and 'match' to behave differently as standalone exprs\n-public:\n-    RustPrinter(::std::ostream& os):\n-        m_os(os),\n-        m_indent_level(0),\n-        m_expr_root(false)\n-    {}\n-\n-    void handle_module(const AST::Module& mod);\n-    void handle_struct(const AST::Struct& s);\n-    void handle_enum(const AST::Enum& s);\n-    void handle_trait(const AST::Trait& s);\n-\n-    void handle_function(bool is_pub, const ::std::string& name, const AST::Function& f);\n-\n-    virtual bool is_const() const override { return true; }\n-    virtual void visit(AST::ExprNode_Block& n) override {\n-        if( n.m_is_unsafe ) {\n-            m_os << \"unsafe \";\n-        }\n-        m_os << \"{\";\n-        inc_indent();\n-        if( n.m_local_mod )\n-        {\n-            handle_module(*n.m_local_mod);\n-        }\n-        bool is_first = true;\n-        for( auto& child : n.m_nodes )\n-        {\n-            if(is_first) {\n-                is_first = false;\n-            } else {\n-                m_os << \";\";\n-            }\n-            m_os << \"\\n\";\n-            m_os << indent();\n-            m_expr_root = true;\n-            if( !child.get() )\n-                m_os << \"/* nil */\";\n-            else\n-                AST::NodeVisitor::visit(child);\n-        }\n-        if( !n.m_yields_final_value )\n-            m_os << \";\";\n-        m_os << \"\\n\";\n-        dec_indent();\n-        m_os << indent() << \"}\";\n-    }\n-    virtual void visit(AST::ExprNode_Macro& n) override {\n-        m_expr_root = false;\n-        m_os << n.m_name << \"!( /* TODO: Macro TT */ )\";\n-    }\n-    virtual void visit(AST::ExprNode_Asm& n) override {\n-        m_os << \"asm!( \\\"\" << n.m_text << \"\\\"\";\n-        m_os << \" :\";\n-        for(const auto& v : n.m_output)\n-        {\n-            m_os << \" \\\"\" << v.name << \"\\\" (\";\n-            AST::NodeVisitor::visit(v.value);\n-            m_os << \"),\";\n-        }\n-        m_os << \" :\";\n-        for(const auto& v : n.m_input)\n-        {\n-            m_os << \" \\\"\" << v.name << \"\\\" (\";\n-            AST::NodeVisitor::visit(v.value);\n-            m_os << \"),\";\n-        }\n-        m_os << \" :\";\n-        for(const auto& v : n.m_clobbers)\n-            m_os << \" \\\"\" << v << \"\\\",\";\n-        m_os << \" :\";\n-        for(const auto& v : n.m_flags)\n-            m_os << \" \\\"\" << v << \"\\\",\";\n-        m_os << \" )\";\n-    }\n-    virtual void visit(AST::ExprNode_Flow& n) override {\n-        m_expr_root = false;\n-        switch(n.m_type)\n-        {\n-        case AST::ExprNode_Flow::RETURN:    m_os << \"return \";  break;\n-        case AST::ExprNode_Flow::BREAK:     m_os << \"break \";  break;\n-        case AST::ExprNode_Flow::CONTINUE:  m_os << \"continue \";  break;\n-        }\n-        AST::NodeVisitor::visit(n.m_value);\n-    }\n-    virtual void visit(AST::ExprNode_LetBinding& n) override {\n-        m_expr_root = false;\n-        m_os << \"let \";\n-        print_pattern(n.m_pat, false);\n-        m_os << \": \";\n-        print_type(n.m_type);\n-        m_os << \" = \";\n-        AST::NodeVisitor::visit(n.m_value);\n-    }\n-    virtual void visit(AST::ExprNode_Assign& n) override {\n-        m_expr_root = false;\n-        AST::NodeVisitor::visit(n.m_slot);\n-        switch(n.m_op)\n-        {\n-        case AST::ExprNode_Assign::NONE:    m_os << \"  = \";  break;\n-        case AST::ExprNode_Assign::ADD:     m_os << \" += \";  break;\n-        case AST::ExprNode_Assign::SUB:     m_os << \" -= \";  break;\n-        case AST::ExprNode_Assign::MUL:     m_os << \" *= \";  break;\n-        case AST::ExprNode_Assign::DIV:     m_os << \" /= \";  break;\n-        case AST::ExprNode_Assign::MOD:     m_os << \" %= \";  break;\n-        case AST::ExprNode_Assign::AND:     m_os << \" &= \";  break;\n-        case AST::ExprNode_Assign::OR:      m_os << \" |= \";  break;\n-        case AST::ExprNode_Assign::XOR:     m_os << \" ^= \";  break;\n-        case AST::ExprNode_Assign::SHR:     m_os << \" >>= \";  break;\n-        case AST::ExprNode_Assign::SHL:     m_os << \" <<= \";  break;\n-        }\n-        AST::NodeVisitor::visit(n.m_value);\n-    }\n-    virtual void visit(AST::ExprNode_CallPath& n) override {\n-        m_expr_root = false;\n-        m_os << n.m_path;\n-        m_os << \"(\";\n-        bool is_first = true;\n-        for( auto& arg : n.m_args )\n-        {\n-            if(is_first) {\n-                is_first = false;\n-            } else {\n-                m_os << \", \";\n-            }\n-            AST::NodeVisitor::visit(arg);\n-        }\n-        m_os << \")\";\n-    }\n-    virtual void visit(AST::ExprNode_CallMethod& n) override {\n-        m_expr_root = false;\n-        WRAPIF( n.m_val\n-            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n-            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n-            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n-            );\n-        m_os << \".\" << n.m_method;\n-        m_os << \"(\";\n-        bool is_first = true;\n-        for( auto& arg : n.m_args )\n-        {\n-            if(is_first) {\n-                is_first = false;\n-            } else {\n-                m_os << \", \";\n-            }\n-            AST::NodeVisitor::visit(arg);\n-        }\n-        m_os << \")\";\n-    }\n-    virtual void visit(AST::ExprNode_CallObject& n) override {\n-        m_expr_root = false;\n-        m_os << \"(\";\n-        AST::NodeVisitor::visit(n.m_val);\n-        m_os << \")(\";\n-        bool is_first = true;\n-        for( auto& arg : n.m_args )\n-        {\n-            if(is_first) {\n-                is_first = false;\n-            } else {\n-                m_os << \", \";\n-            }\n-            AST::NodeVisitor::visit(arg);\n-        }\n-        m_os << \")\";\n-    }\n-    virtual void visit(AST::ExprNode_Loop& n) override {\n-        bool expr_root = m_expr_root;\n-        m_expr_root = false;\n-\n-        switch(n.m_type)\n-        {\n-        case AST::ExprNode_Loop::LOOP:\n-            m_os << \"loop\";\n-            break;\n-        case AST::ExprNode_Loop::WHILE:\n-            m_os << \"while \";\n-            AST::NodeVisitor::visit(n.m_cond);\n-            break;\n-        case AST::ExprNode_Loop::WHILELET:\n-            m_os << \"while let \";\n-            print_pattern(n.m_pattern, true);\n-            m_os << \" = \";\n-            AST::NodeVisitor::visit(n.m_cond);\n-            break;\n-        case AST::ExprNode_Loop::FOR:\n-            m_os << \"while for \";\n-            print_pattern(n.m_pattern, true);\n-            m_os << \" in \";\n-            AST::NodeVisitor::visit(n.m_cond);\n-            break;\n-        }\n-\n-        if( expr_root )\n-        {\n-            m_os << \"\\n\";\n-            m_os << indent();\n-        }\n-        else\n-        {\n-            m_os << \" \";\n-        }\n-\n-        AST::NodeVisitor::visit(n.m_code);\n-    }\n-    virtual void visit(AST::ExprNode_Match& n) override {\n-        bool expr_root = m_expr_root;\n-        m_expr_root = false;\n-        m_os << \"match \";\n-        AST::NodeVisitor::visit(n.m_val);\n-\n-        if(expr_root)\n-        {\n-            m_os << \"\\n\";\n-            m_os << indent() << \"{\\n\";\n-        }\n-        else\n-        {\n-            m_os << \" {\\n\";\n-            inc_indent();\n-        }\n-\n-        for( auto& arm : n.m_arms )\n-        {\n-            m_os << indent();\n-            bool is_first = true;\n-            for( const auto& pat : arm.m_patterns ) {\n-                if(!is_first)\n-                    m_os << \"|\";\n-                is_first = false;\n-                print_pattern(pat, true);\n-            }\n-            if( arm.m_cond )\n-            {\n-                m_os << \" if \";\n-                AST::NodeVisitor::visit(arm.m_cond);\n-            }\n-            m_os << \" => \";\n-            // Increase indent, but don't print. Causes nested blocks to be indented above the match\n-            inc_indent();\n-            AST::NodeVisitor::visit(arm.m_code);\n-            dec_indent();\n-            m_os << \",\\n\";\n-        }\n-\n-        if(expr_root)\n-        {\n-            m_os << indent() << \"}\";\n-        }\n-        else\n-        {\n-            m_os << indent() << \"}\";\n-            dec_indent();\n-        }\n-    }\n-    virtual void visit(AST::ExprNode_If& n) override {\n-        bool expr_root = m_expr_root;\n-        m_expr_root = false;\n-        m_os << \"if \";\n-        AST::NodeVisitor::visit(n.m_cond);\n-\n-        visit_if_common(expr_root, n.m_true, n.m_false);\n-    }\n-    virtual void visit(AST::ExprNode_IfLet& n) override {\n-        bool expr_root = m_expr_root;\n-        m_expr_root = false;\n-        m_os << \"if let \";\n-        print_pattern(n.m_pattern, true);\n-        m_os << \" = \";\n-        AST::NodeVisitor::visit(n.m_value);\n-\n-        visit_if_common(expr_root, n.m_true, n.m_false);\n-    }\n-    void visit_if_common(bool expr_root, const ::std::unique_ptr<AST::ExprNode>& tv, const ::std::unique_ptr<AST::ExprNode>& fv)\n-    {\n-        if( expr_root )\n-        {\n-            m_os << \"\\n\";\n-            m_os << indent();\n-        }\n-        else\n-        {\n-            m_os << \" \";\n-        }\n-\n-        bool is_block = (dynamic_cast<const AST::ExprNode_Block*>(&*tv) != nullptr);\n-        if( !is_block ) m_os << \"{ \";\n-        AST::NodeVisitor::visit(tv);\n-        if( !is_block ) m_os << \" }\";\n-        if(fv.get())\n-        {\n-            if( expr_root )\n-            {\n-                m_os << \"\\n\";\n-                m_os << indent() << \"else\";\n-                // handle chained if statements nicely\n-                if( IS(*fv, AST::ExprNode_If) || IS(*fv, AST::ExprNode_IfLet) ) {\n-                    m_expr_root = true;\n-                    m_os << \" \";\n-                }\n-                else\n-                    m_os << \"\\n\" << indent();\n-            }\n-            else\n-            {\n-                m_os << \" else \";\n-            }\n-            AST::NodeVisitor::visit(fv);\n-        }\n-    }\n-    virtual void visit(AST::ExprNode_Closure& n) override {\n-        m_expr_root = false;\n-        m_os << \"|\";\n-        bool is_first = true;\n-        for( const auto& arg : n.m_args )\n-        {\n-            if(!is_first)   m_os << \", \";\n-            is_first = false;\n-            print_pattern(arg.first, false);\n-            m_os << \": \";\n-            print_type(arg.second);\n-        }\n-        m_os << \"| ->\";\n-        print_type(n.m_return);\n-        m_os << \" \";\n-        AST::NodeVisitor::visit(n.m_code);\n-    }\n-    virtual void visit(AST::ExprNode_Integer& n) override {\n-        m_expr_root = false;\n-        switch(n.m_datatype)\n-        {\n-        case CORETYPE_INVAL:\n-            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec << \"_/*INVAL*/\";\n-            break;\n-        case CORETYPE_BOOL:\n-        case CORETYPE_STR:\n-            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec << \"_/*bool/str*/\";\n-            break;\n-        case CORETYPE_CHAR:\n-            m_os << \"'\\\\u{\" << ::std::hex << n.m_value << ::std::dec << \"}'\";\n-            break;\n-        case CORETYPE_F32:\n-        case CORETYPE_F64:\n-            break;\n-        case CORETYPE_U8:\n-        case CORETYPE_U16:\n-        case CORETYPE_U32:\n-        case CORETYPE_U64:\n-        case CORETYPE_U128:\n-        case CORETYPE_UINT:\n-        case CORETYPE_ANY:\n-            m_os << \"0x\" << ::std::hex << n.m_value << ::std::dec;\n-            break;\n-        case CORETYPE_I8:\n-        case CORETYPE_I16:\n-        case CORETYPE_I32:\n-        case CORETYPE_I64:\n-        case CORETYPE_I128:\n-        case CORETYPE_INT:\n-            m_os << (int64_t)n.m_value;\n-            break;\n-        }\n-    }\n-    virtual void visit(AST::ExprNode_Float& n) override {\n-        m_expr_root = false;\n-        switch(n.m_datatype)\n-        {\n-        case CORETYPE_ANY:\n-        case CORETYPE_F32:\n-        case CORETYPE_F64:\n-            m_os.precision(10);\n-            m_os << n.m_value;\n-            break;\n-        default:\n-            break;\n-        }\n-    }\n-    virtual void visit(AST::ExprNode_Bool& n) override {\n-        m_expr_root = false;\n-        if( n.m_value )\n-            m_os << \"true\";\n-        else\n-            m_os << \"false\";\n-    }\n-    virtual void visit(AST::ExprNode_String& n) override {\n-        m_expr_root = false;\n-        m_os << \"\\\"\" << n.m_value << \"\\\"\";\n-    }\n-    virtual void visit(AST::ExprNode_ByteString& n) override {\n-        m_expr_root = false;\n-        m_os << \"b\\\"\" << n.m_value << \"\\\"\";\n-    }\n-\n-    virtual void visit(AST::ExprNode_StructLiteral& n) override {\n-        m_expr_root = false;\n-        m_os << n.m_path << \" {\\n\";\n-        inc_indent();\n-        for( const auto& i : n.m_values )\n-        {\n-            // TODO: Attributes\n-            m_os << indent() << i.name << \": \";\n-            AST::NodeVisitor::visit(i.value);\n-            m_os << \",\\n\";\n-        }\n-        if( n.m_base_value.get() )\n-        {\n-            m_os << indent() << \".. \";\n-            AST::NodeVisitor::visit(n.m_base_value);\n-            m_os << \"\\n\";\n-        }\n-        m_os << indent() << \"}\";\n-        dec_indent();\n-    }\n-    virtual void visit(AST::ExprNode_Array& n) override {\n-        m_expr_root = false;\n-        m_os << \"[\";\n-        if( n.m_size.get() )\n-        {\n-            AST::NodeVisitor::visit(n.m_values[0]);\n-            m_os << \"; \";\n-            AST::NodeVisitor::visit(n.m_size);\n-        }\n-        else {\n-            for( auto& item : n.m_values )\n-            {\n-                AST::NodeVisitor::visit(item);\n-                m_os << \", \";\n-            }\n-        }\n-        m_os << \"]\";\n-    }\n-    virtual void visit(AST::ExprNode_Tuple& n) override {\n-        m_expr_root = false;\n-        m_os << \"(\";\n-        for( auto& item : n.m_values )\n-        {\n-            AST::NodeVisitor::visit(item);\n-            m_os << \", \";\n-        }\n-        m_os << \")\";\n-    }\n-    virtual void visit(AST::ExprNode_NamedValue& n) override {\n-        m_expr_root = false;\n-        m_os << n.m_path;\n-    }\n-    virtual void visit(AST::ExprNode_Field& n) override {\n-        m_expr_root = false;\n-        WRAPIF( n.m_obj\n-            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n-            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n-            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n-            );\n-        m_os << \".\" << n.m_name;\n-    }\n-    virtual void visit(AST::ExprNode_Index& n) override {\n-        m_expr_root = false;\n-        WRAPIF( n.m_obj\n-            , AST::ExprNode_Deref, AST::ExprNode_UniOp\n-            , AST::ExprNode_Cast, AST::ExprNode_BinOp, AST::ExprNode_Assign\n-            , AST::ExprNode_Match, AST::ExprNode_If, AST::ExprNode_IfLet, AST::ExprNode_Match\n-            );\n-        m_os << \"[\";\n-        AST::NodeVisitor::visit(n.m_idx);\n-        m_os << \"]\";\n-    }\n-    virtual void visit(AST::ExprNode_Deref& n) override {\n-        m_expr_root = false;\n-        m_os << \"*(\";\n-        AST::NodeVisitor::visit(n.m_value);\n-        m_os << \")\";\n-    }\n-    virtual void visit(AST::ExprNode_Cast& n) override {\n-        m_expr_root = false;\n-        AST::NodeVisitor::visit(n.m_value);\n-        m_os << \" as \" << n.m_type;\n-    }\n-    virtual void visit(AST::ExprNode_TypeAnnotation& n) override {\n-        m_expr_root = false;\n-        AST::NodeVisitor::visit(n.m_value);\n-        m_os << \": \" << n.m_type;\n-    }\n-    virtual void visit(AST::ExprNode_BinOp& n) override {\n-        m_expr_root = false;\n-        if( IS(*n.m_left, AST::ExprNode_BinOp) && dynamic_cast<AST::ExprNode_BinOp&>(*n.m_left).m_type == n.m_type ) {\n-            AST::NodeVisitor::visit(n.m_left);\n-        }\n-        else {\n-            WRAPIF(n.m_left\n-                , AST::ExprNode_Cast, AST::ExprNode_BinOp\n-                );\n-        }\n-        m_os << \" \";\n-        switch(n.m_type)\n-        {\n-        case AST::ExprNode_BinOp::CMPEQU: m_os << \"==\"; break;\n-        case AST::ExprNode_BinOp::CMPNEQU:m_os << \"!=\"; break;\n-        case AST::ExprNode_BinOp::CMPLT:  m_os << \"<\";  break;\n-        case AST::ExprNode_BinOp::CMPLTE: m_os << \"<=\"; break;\n-        case AST::ExprNode_BinOp::CMPGT:  m_os << \">\";  break;\n-        case AST::ExprNode_BinOp::CMPGTE: m_os << \">=\"; break;\n-        case AST::ExprNode_BinOp::BOOLAND:m_os << \"&&\"; break;\n-        case AST::ExprNode_BinOp::BOOLOR: m_os << \"||\"; break;\n-        case AST::ExprNode_BinOp::BITAND: m_os << \"&\";  break;\n-        case AST::ExprNode_BinOp::BITOR:  m_os << \"|\";  break;\n-        case AST::ExprNode_BinOp::BITXOR: m_os << \"^\";  break;\n-        case AST::ExprNode_BinOp::SHL:    m_os << \"<<\"; break;\n-        case AST::ExprNode_BinOp::SHR:    m_os << \">>\"; break;\n-        case AST::ExprNode_BinOp::MULTIPLY: m_os << \"*\"; break;\n-        case AST::ExprNode_BinOp::DIVIDE:   m_os << \"/\"; break;\n-        case AST::ExprNode_BinOp::MODULO:   m_os << \"%\"; break;\n-        case AST::ExprNode_BinOp::ADD:   m_os << \"+\"; break;\n-        case AST::ExprNode_BinOp::SUB:   m_os << \"-\"; break;\n-        case AST::ExprNode_BinOp::RANGE: m_os << \"..\"; break;\n-        case AST::ExprNode_BinOp::RANGE_INC: m_os << \"...\"; break;\n-        case AST::ExprNode_BinOp::PLACE_IN: m_os << \"<-\"; break;\n-        }\n-        m_os << \" \";\n-        if( IS(*n.m_right, AST::ExprNode_BinOp) && dynamic_cast<AST::ExprNode_BinOp&>(*n.m_right).m_type != n.m_type ) {\n-            paren_wrap(n.m_right);\n-        }\n-        else\n-            AST::NodeVisitor::visit(n.m_right);\n-    }\n-    virtual void visit(AST::ExprNode_UniOp& n) override {\n-        m_expr_root = false;\n-        switch(n.m_type)\n-        {\n-        case AST::ExprNode_UniOp::NEGATE:   m_os << \"-\";    break;\n-        case AST::ExprNode_UniOp::INVERT:   m_os << \"!\";    break;\n-        case AST::ExprNode_UniOp::BOX:      m_os << \"box \";    break;\n-        case AST::ExprNode_UniOp::REF:    m_os << \"&\";    break;\n-        case AST::ExprNode_UniOp::REFMUT: m_os << \"&mut \";    break;\n-        case AST::ExprNode_UniOp::QMARK: break;\n-        }\n-\n-        if( IS(*n.m_value, AST::ExprNode_BinOp) )\n-            m_os << \"(\";\n-        AST::NodeVisitor::visit(n.m_value);\n-        if( IS(*n.m_value, AST::ExprNode_BinOp) )\n-            m_os << \")\";\n-        switch(n.m_type)\n-        {\n-        case AST::ExprNode_UniOp::QMARK: m_os << \"?\"; break;\n-        default:    break;\n-        }\n-    }\n-\n-\n-private:\n-    void paren_wrap(::std::unique_ptr<AST::ExprNode>& node) {\n-        m_os << \"(\";\n-        AST::NodeVisitor::visit(node);\n-        m_os << \")\";\n-    }\n-\n-    void print_attrs(const AST::AttributeList& attrs);\n-    void print_params(const AST::GenericParams& params);\n-    void print_bounds(const AST::GenericParams& params);\n-    void print_pattern_tuple(const AST::Pattern::TuplePat& v, bool is_refutable);\n-    void print_pattern(const AST::Pattern& p, bool is_refutable);\n-    void print_type(const TypeRef& t);\n-\n-    void inc_indent();\n-    RepeatLitStr indent();\n-    void dec_indent();\n-};\n-\n-void Dump_Rust(const char *filename, const AST::Crate& crate)\n-{\n-    ::std::ofstream os(filename);\n-    RustPrinter printer(os);\n-    printer.handle_module(crate.root_module());\n-}\n-\n-void RustPrinter::print_attrs(const AST::AttributeList& attrs)\n-{\n-    for(const auto& a : attrs.m_items)\n-    {\n-        m_os << indent() << \"#[\" << a << \"]\\n\";\n-    }\n-}\n-\n-void RustPrinter::handle_module(const AST::Module& mod)\n-{\n-    bool need_nl = true;\n-\n-    for( const auto& i : mod.items() )\n-    {\n-        if( !i.data.is_Use() )  continue ;\n-        const auto& i_data = i.data.as_Use();\n-        //if(need_nl) {\n-        //    m_os << \"\\n\";\n-        //    need_nl = false;\n-        //}\n-        if( i_data.path == AST::Path() ) {\n-            continue ;\n-        }\n-        m_os << indent() << (i.is_pub ? \"pub \" : \"\") << \"use \" << i_data;\n-        if( i.name == \"\" )\n-        {\n-            m_os << \"::*\";\n-        }\n-        else if( i_data.path.nodes().back().name() != i.name )\n-        {\n-            m_os << \" as \" << i.name;\n-        }\n-        m_os << \";\\n\";\n-    }\n-    need_nl = true;\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Crate() )    continue ;\n-        const auto& e = item.data.as_Crate();\n-\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << \"extern crate \\\"\" << e.name << \"\\\" as \" << item.name << \";\\n\";\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_ExternBlock() )    continue ;\n-        const auto& e = item.data.as_ExternBlock();\n-\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << \"extern \\\"\" << e.abi() << \"\\\" {}\\n\";\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Module() )    continue ;\n-        const auto& e = item.data.as_Module();\n-\n-        m_os << \"\\n\";\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"mod \" << item.name << \"\\n\";\n-        m_os << indent() << \"{\\n\";\n-        inc_indent();\n-        handle_module(e);\n-        dec_indent();\n-        m_os << indent() << \"}\\n\";\n-        m_os << \"\\n\";\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Type() )    continue ;\n-        const auto& e = item.data.as_Type();\n-\n-        if(need_nl) {\n-            m_os << \"\\n\";\n-            need_nl = false;\n-        }\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"type \" << item.name;\n-        print_params(e.params());\n-        m_os << \" = \" << e.type();\n-        print_bounds(e.params());\n-        m_os << \";\\n\";\n-    }\n-    need_nl = true;\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Struct() )    continue ;\n-        const auto& e = item.data.as_Struct();\n-\n-        m_os << \"\\n\";\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"struct \" << item.name;\n-        handle_struct(e);\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Enum() )    continue ;\n-        const auto& e = item.data.as_Enum();\n-\n-        m_os << \"\\n\";\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"enum \" << item.name;\n-        handle_enum(e);\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Trait() )    continue ;\n-        const auto& e = item.data.as_Trait();\n-\n-        m_os << \"\\n\";\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\") << \"trait \" << item.name;\n-        handle_trait(e);\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Static() )    continue ;\n-        const auto& e = item.data.as_Static();\n-\n-        if(need_nl) {\n-            m_os << \"\\n\";\n-            need_nl = false;\n-        }\n-        print_attrs(item.data.attrs);\n-        m_os << indent() << (item.is_pub ? \"pub \" : \"\");\n-        switch( e.s_class() )\n-        {\n-        case AST::Static::CONST:  m_os << \"const \";   break;\n-        case AST::Static::STATIC: m_os << \"static \";   break;\n-        case AST::Static::MUT:    m_os << \"static mut \";   break;\n-        }\n-        m_os << item.name << \": \" << e.type() << \" = \";\n-        e.value().visit_nodes(*this);\n-        m_os << \";\\n\";\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Function() )    continue ;\n-        const auto& e = item.data.as_Function();\n-\n-        m_os << \"\\n\";\n-        print_attrs(item.data.attrs);\n-        handle_function(item.is_pub, item.name, e);\n-    }\n-\n-    for( const auto& item : mod.items() )\n-    {\n-        if( !item.data.is_Impl() )    continue ;\n-        const auto& i = item.data.as_Impl();\n-\n-        m_os << \"\\n\";\n-        m_os << indent() << \"impl\";\n-        print_params(i.def().params());\n-        if( i.def().trait().ent != AST::Path() )\n-        {\n-                m_os << \" \" << i.def().trait().ent << \" for\";\n-        }\n-        m_os << \" \" << i.def().type() << \"\\n\";\n-\n-        print_bounds(i.def().params());\n-        m_os << indent() << \"{\\n\";\n-        inc_indent();\n-        for( const auto& it : i.items() )\n-        {\n-            TU_MATCH_DEF(AST::Item, (*it.data), (e),\n-            (\n-                throw ::std::runtime_error(FMT(\"Unexpected item type in impl block - \" << it.data->tag_str()));\n-                ),\n-            (None,\n-                // Ignore, it's been deleted by #[cfg]\n-                ),\n-            (MacroInv,\n-                // TODO: Dump macro invocations\n-                ),\n-            (Static,\n-                m_os << indent();\n-                switch(e.s_class())\n-                {\n-                case ::AST::Static::CONST:  m_os << \"const \";   break;\n-                case ::AST::Static::STATIC: m_os << \"static \";  break;\n-                case ::AST::Static::MUT:    m_os << \"static mut \";  break;\n-                }\n-                m_os << it.name << \": \" << e.type() << \" = \";\n-                e.value().visit_nodes(*this);\n-                m_os << \";\\n\";\n-                ),\n-            (Type,\n-                m_os << indent() << \"type \" << it.name << \" = \" << e.type() << \";\\n\";\n-                ),\n-            (Function,\n-                handle_function(it.is_pub, it.name, e);\n-                )\n-            )\n-        }\n-        dec_indent();\n-        m_os << indent() << \"}\\n\";\n-    }\n-}\n-\n-void RustPrinter::print_params(const AST::GenericParams& params)\n-{\n-    if( params.ty_params().size() > 0 || params.lft_params().size() > 0 )\n-    {\n-        bool is_first = true;\n-        m_os << \"<\";\n-        // Lifetimes\n-        for( const auto& p : params.lft_params() )\n-        {\n-            if( !is_first )\n-                m_os << \", \";\n-            m_os << \"'\" << p;\n-            is_first = false;\n-        }\n-        // Types\n-        for( const auto& p : params.ty_params() )\n-        {\n-            if( !is_first )\n-                m_os << \", \";\n-            m_os << p.name();\n-            if( !p.get_default().is_wildcard() )\n-                m_os << \" = \" << p.get_default();\n-            is_first = false;\n-        }\n-        m_os << \">\";\n-    }\n-}\n-\n-void RustPrinter::print_bounds(const AST::GenericParams& params)\n-{\n-    if( params.bounds().size() )\n-    {\n-        m_os << indent() << \"where\\n\";\n-        inc_indent();\n-        bool is_first = true;\n-\n-        for( const auto& b : params.bounds() )\n-        {\n-            if( !is_first )\n-                m_os << \",\\n\";\n-            is_first = false;\n-\n-            m_os << indent();\n-            TU_MATCH(AST::GenericBound, (b), (ent),\n-            (None,\n-                m_os << \"/*-*/\";\n-                ),\n-            (Lifetime,\n-                m_os << \"'\" << ent.test << \": '\" << ent.bound;\n-                ),\n-            (TypeLifetime,\n-                m_os << ent.type << \": '\" << ent.bound;\n-                ),\n-            (IsTrait,\n-                m_os << ent.outer_hrbs << ent.type << \": \" << ent.inner_hrbs << ent.trait;\n-                ),\n-            (MaybeTrait,\n-                m_os << ent.type << \": ?\" << ent.trait;\n-                ),\n-            (NotTrait,\n-                m_os << ent.type << \": !\" << ent.trait;\n-                ),\n-            (Equality,\n-                m_os << ent.type << \": =\" << ent.replacement;\n-                )\n-            )\n-        }\n-        m_os << \"\\n\";\n-\n-        dec_indent();\n-    }\n-}\n-\n-void RustPrinter::print_pattern_tuple(const AST::Pattern::TuplePat& v, bool is_refutable)\n-{\n-    for(const auto& sp : v.start) {\n-        print_pattern(sp, is_refutable);\n-        m_os << \", \";\n-    }\n-    if( v.has_wildcard )\n-    {\n-        m_os << \".., \";\n-        for(const auto& sp : v.end) {\n-            print_pattern(sp, is_refutable);\n-            m_os << \", \";\n-        }\n-    }\n-}\n-void RustPrinter::print_pattern(const AST::Pattern& p, bool is_refutable)\n-{\n-    if( p.binding().is_valid() ) {\n-        if( p.binding().m_mutable )\n-            m_os << \"mut \";\n-        switch(p.binding().m_type)\n-        {\n-        case ::AST::PatternBinding::Type::MOVE:\n-            break;\n-        case ::AST::PatternBinding::Type::REF:\n-            m_os << \"ref \";\n-            break;\n-        case ::AST::PatternBinding::Type::MUTREF:\n-            m_os << \"ref mut \";\n-            break;\n-        }\n-        m_os << p.binding().m_name << \"/*\"<<p.binding().m_slot<<\"*/\";\n-        // If binding is irrefutable, and would be binding against a wildcard, just emit the name\n-        if( !is_refutable && p.data().is_Any() )\n-        {\n-            return ;\n-        }\n-        m_os << \" @ \";\n-    }\n-    TU_MATCH(AST::Pattern::Data, (p.data()), (v),\n-    (Any,\n-        m_os << \"_\";\n-        ),\n-    (MaybeBind,\n-        m_os << \"_ /*?*/\";\n-        ),\n-    (Macro,\n-        m_os << *v.inv;\n-        ),\n-    (Box, {\n-        const auto& v = p.data().as_Box();\n-        m_os << \"& \";\n-        print_pattern(*v.sub, is_refutable);\n-        }),\n-    (Ref, {\n-        const auto& v = p.data().as_Ref();\n-        if(v.mut)\n-            m_os << \"&mut \";\n-        else\n-            m_os << \"& \";\n-        print_pattern(*v.sub, is_refutable);\n-        }),\n-    (Value,\n-        m_os << v.start;\n-        if( ! v.end.is_Invalid() ) {\n-            m_os << \" ... \" << v.end;\n-        }\n-        ),\n-    (StructTuple,\n-        m_os << v.path << \"(\";\n-        this->print_pattern_tuple(v.tup_pat, is_refutable);\n-        m_os << \")\";\n-        ),\n-    (Struct, {\n-        const auto& v = p.data().as_Struct();\n-        m_os << v.path << \"(\";\n-        for(const auto& sp : v.sub_patterns) {\n-            m_os << sp.first << \": \";\n-            print_pattern(sp.second, is_refutable);\n-            m_os << \",\";\n-        }\n-        m_os << \")\";\n-        }),\n-    (Tuple,\n-        m_os << \"(\";\n-        this->print_pattern_tuple(v, is_refutable);\n-        m_os << \")\";\n-        ),\n-    (Slice,\n-        m_os << \"[\";\n-        m_os << v.sub_pats;\n-        m_os << \"]\";\n-        ),\n-    (SplitSlice,\n-        m_os << \"[\";\n-        bool needs_comma = false;\n-        if(v.leading.size()) {\n-            m_os << v.leading;\n-            m_os << \", \";\n-        }\n-\n-        if(v.extra_bind.is_valid())\n-        {\n-            const auto& b = v.extra_bind;\n-            if( b.m_mutable )\n-                m_os << \"mut \";\n-            switch(b.m_type)\n-            {\n-            case ::AST::PatternBinding::Type::MOVE:\n-                break;\n-            case ::AST::PatternBinding::Type::REF:\n-                m_os << \"ref \";\n-                break;\n-            case ::AST::PatternBinding::Type::MUTREF:\n-                m_os << \"ref mut \";\n-                break;\n-            }\n-            m_os << b.m_name << \"/*\"<<b.m_slot<<\"*/\";\n-        }\n-        m_os << \"..\";\n-        needs_comma = true;\n-\n-        if(v.trailing.size()) {\n-            if( needs_comma ) {\n-                m_os << \", \";\n-            }\n-            m_os << v.trailing;\n-        }\n-        m_os << \"]\";\n-        )\n-    )\n-}\n-\n-void RustPrinter::print_type(const TypeRef& t)\n-{\n-    m_os << t;\n-}\n-\n-void RustPrinter::handle_struct(const AST::Struct& s)\n-{\n-    print_params(s.params());\n-\n-    TU_MATCH(AST::StructData, (s.m_data), (e),\n-    (Unit,\n-        m_os << \" /* unit-like */\\n\";\n-        print_bounds(s.params());\n-        m_os << indent() << \";\\n\";\n-        ),\n-    (Tuple,\n-        m_os << \"(\";\n-        for( const auto& i : e.ents )\n-            m_os << i.m_type << \", \";\n-        m_os << \")\\n\";\n-        print_bounds(s.params());\n-        m_os << indent() << \";\\n\";\n-        ),\n-    (Struct,\n-        m_os << \"\\n\";\n-        print_bounds(s.params());\n-\n-        m_os << indent() << \"{\\n\";\n-        inc_indent();\n-        for( const auto& i : e.ents )\n-        {\n-            m_os << indent() << (i.m_is_public ? \"pub \" : \"\") << i.m_name << \": \" << i.m_type.print_pretty() << \"\\n\";\n-        }\n-        dec_indent();\n-        m_os << indent() << \"}\\n\";\n-        )\n-    )\n-    m_os << \"\\n\";\n-}\n-\n-void RustPrinter::handle_enum(const AST::Enum& s)\n-{\n-    print_params(s.params());\n-    m_os << \"\\n\";\n-    print_bounds(s.params());\n-\n-    m_os << indent() << \"{\\n\";\n-    inc_indent();\n-    unsigned int idx = 0;\n-    for( const auto& i : s.variants() )\n-    {\n-        m_os << indent() << \"/*\"<<idx<<\"*/\" << i.m_name;\n-        TU_MATCH(AST::EnumVariantData, (i.m_data), (e),\n-        (Value,\n-            m_os << \" = \" << e.m_value;\n-            ),\n-        (Tuple,\n-            m_os << \"(\";\n-            for( const auto& t : e.m_sub_types )\n-                m_os << t.print_pretty() << \", \";\n-            m_os << \")\";\n-            ),\n-        (Struct,\n-            m_os << \"{\\n\";\n-            inc_indent();\n-            for( const auto& i : e.m_fields )\n-            {\n-                m_os << indent() << i.m_name << \": \" << i.m_type.print_pretty() << \"\\n\";\n-            }\n-            dec_indent();\n-            m_os << indent() << \"}\";\n-            )\n-        )\n-        m_os << \",\\n\";\n-        idx ++;\n-    }\n-    dec_indent();\n-    m_os << indent() << \"}\\n\";\n-    m_os << \"\\n\";\n-}\n-\n-void RustPrinter::handle_trait(const AST::Trait& s)\n-{\n-    print_params(s.params());\n-    m_os << \"\\n\";\n-    print_bounds(s.params());\n-\n-    m_os << indent() << \"{\\n\";\n-    inc_indent();\n-\n-    for( const auto& i : s.items() )\n-    {\n-        TU_MATCH_DEF(AST::Item, (i.data), (e),\n-        (\n-            ),\n-        (Type,\n-            m_os << indent() << \"type \" << i.name << \";\\n\";\n-            ),\n-        (Function,\n-            handle_function(false, i.name, e);\n-            )\n-        )\n-    }\n-\n-    dec_indent();\n-    m_os << indent() << \"}\\n\";\n-    m_os << \"\\n\";\n-}\n-\n-void RustPrinter::handle_function(bool is_pub, const ::std::string& name, const AST::Function& f)\n-{\n-    m_os << indent();\n-    m_os << (is_pub ? \"pub \" : \"\");\n-    if( f.is_const() )\n-        m_os << \"const \";\n-    if( f.is_unsafe() )\n-        m_os << \"unsafe \";\n-    if( f.abi() != ABI_RUST )\n-        m_os << \"extern \\\"\" << f.abi() << \"\\\" \";\n-    m_os << \"fn \" << name;\n-    print_params(f.params());\n-    m_os << \"(\";\n-    bool is_first = true;\n-    for( const auto& a : f.args() )\n-    {\n-        if( !is_first )\n-            m_os << \", \";\n-        print_pattern( a.first, false );\n-        m_os << \": \" << a.second.print_pretty();\n-        is_first = false;\n-    }\n-    m_os << \")\";\n-    if( !f.rettype().is_unit() )\n-    {\n-        m_os << \" -> \" << f.rettype().print_pretty();\n-    }\n-\n-    if( f.code().is_valid() )\n-    {\n-        m_os << \"\\n\";\n-        print_bounds(f.params());\n-\n-        m_os << indent();\n-        f.code().visit_nodes(*this);\n-        m_os << \"\\n\";\n-        //m_os << indent() << f.data.code() << \"\\n\";\n-    }\n-    else\n-    {\n-        print_bounds(f.params());\n-        m_os << \";\\n\";\n-    }\n-}\n-\n-void RustPrinter::inc_indent()\n-{\n-    m_indent_level ++;\n-}\n-RepeatLitStr RustPrinter::indent()\n-{\n-    return RepeatLitStr { \"    \", m_indent_level };\n-}\n-void RustPrinter::dec_indent()\n-{\n-    m_indent_level --;\n-}"}, {"sha": "1525ed1263a68622f6c1a2e90ff99de9e8eeff22", "filename": "gcc/rust/mrustc_parser/ast/expr.cpp", "status": "removed", "additions": 0, "deletions": 625, "changes": 625, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,625 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/expr.cpp\n- * - AST Expression nodes\n- */\n-#include \"expr.hpp\"\n-#include \"ast.hpp\"\n-\n-namespace AST {\n-\n-\n-Expr::Expr(unique_ptr<ExprNode> node):\n-    m_node(node.release())\n-{\n-}\n-Expr::Expr(ExprNode* node):\n-    m_node(node)\n-{\n-}\n-Expr::Expr():\n-    m_node(nullptr)\n-{\n-}\n-void Expr::visit_nodes(NodeVisitor& v)\n-{\n-    if( m_node )\n-    {\n-        m_node->visit(v);\n-    }\n-}\n-void Expr::visit_nodes(NodeVisitor& v) const\n-{\n-    if( m_node )\n-    {\n-        assert(v.is_const());\n-        //const_cast<const ExprNode*>(m_node.get())->visit(v);\n-        m_node->visit(v);\n-    }\n-}\n-\n-Expr Expr::clone() const\n-{\n-    if( m_node ) {\n-        return Expr( m_node->clone() );\n-    }\n-    else {\n-        return Expr();\n-    }\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const Expr& pat)\n-{\n-    if( pat.m_node.get() )\n-        return os << *pat.m_node;\n-    else\n-        return os << \"/* null */\";\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const ExprNode& node)\n-{\n-    assert( static_cast<const void*>(&node) != nullptr );\n-    node.print(os);\n-    return os;\n-}\n-ExprNode::~ExprNode() {\n-}\n-\n-#define NODE(class, _print, _clone)\\\n-    void class::visit(NodeVisitor& nv) { nv.visit(*this); } \\\n-    void class::print(::std::ostream& os) const _print \\\n-    ::std::unique_ptr<ExprNode> class::clone() const _clone\n-#define OPT_CLONE(node) (node.get() ? node->clone() : ::AST::ExprNodeP())\n-\n-namespace {\n-    static inline ExprNodeP mk_exprnodep(const Span& pos, AST::ExprNode* en) {\n-        en->set_span(pos);\n-        return ExprNodeP(en);\n-    }\n-    #define NEWNODE(type, ...)  mk_exprnodep(span(), new type(__VA_ARGS__))\n-}\n-\n-NODE(ExprNode_Block, {\n-    os << \"{\";\n-    for(const auto& n : m_nodes)\n-        os << *n << \";\";\n-    os << \"}\";\n-},{\n-    ::std::vector<ExprNodeP>    nodes;\n-    for(const auto& n : m_nodes)\n-        nodes.push_back( n->clone() );\n-    return NEWNODE(ExprNode_Block, m_is_unsafe, m_yields_final_value, mv$(nodes), m_local_mod);\n-})\n-\n-NODE(ExprNode_Macro, {\n-    os << m_name << \"!\";\n-    if( m_ident.size() > 0 )\n-    {\n-        os << \" \" << m_ident << \" \";\n-    }\n-    os << \"(\" << \" /*TODO*/ \" << \")\";\n-},{\n-    return NEWNODE(ExprNode_Macro, m_name, m_ident, m_tokens.clone());\n-})\n-\n-NODE(ExprNode_Asm, {\n-    os << \"asm!( \\\"\" << m_text << \"\\\"\";\n-    os << \" :\";\n-    for(const auto& v : m_output)\n-        os << \" \\\"\" << v.name << \"\\\" (\" << *v.value << \"),\";\n-    os << \" :\";\n-    for(const auto& v : m_input)\n-        os << \" \\\"\" << v.name << \"\\\" (\" << *v.value << \"),\";\n-    os << \" :\";\n-    for(const auto& v : m_clobbers)\n-        os << \" \\\"\" << v << \"\\\",\";\n-    os << \" :\";\n-    for(const auto& v : m_flags)\n-        os << \" \\\"\" << v << \"\\\",\";\n-    os << \" )\";\n-},{\n-    ::std::vector<ExprNode_Asm::ValRef> outputs;\n-    for(const auto& v : m_output)\n-        outputs.push_back( ExprNode_Asm::ValRef { v.name, v.value->clone() });\n-    ::std::vector<ExprNode_Asm::ValRef> inputs;\n-    for(const auto& v : m_input)\n-        inputs.push_back( ExprNode_Asm::ValRef { v.name, v.value->clone() });\n-    return NEWNODE(ExprNode_Asm, m_text, mv$(outputs), mv$(inputs), m_clobbers, m_flags);\n-})\n-\n-NODE(ExprNode_Flow, {\n-    switch(m_type)\n-    {\n-    case RETURN:    os << \"return\"; break;\n-    case BREAK:     os << \"break\"; break;\n-    case CONTINUE:  os << \"continue\"; break;\n-    }\n-    if(m_value)\n-        os << \" \" << *m_value;\n-},{\n-    return NEWNODE(ExprNode_Flow, m_type, m_target, m_value ? m_value->clone() : nullptr);\n-})\n-\n-\n-NODE(ExprNode_LetBinding, {\n-    os << \"let \" << m_pat << \": \" << m_type;\n-    if(m_value)\n-        os << \" = \" << *m_value;\n-},{\n-    return NEWNODE(ExprNode_LetBinding, m_pat.clone(), m_type.clone(), OPT_CLONE(m_value));\n-})\n-\n-NODE(ExprNode_Assign, {\n-    os << *m_slot << \" = \" << *m_value;\n-},{\n-    return NEWNODE(ExprNode_Assign, m_op, m_slot->clone(), m_value->clone());\n-})\n-\n-NODE(ExprNode_CallPath, {\n-    os << m_path << \"(\";\n-    for(const auto& a : m_args) {\n-        os << *a << \",\";\n-    }\n-    os << \")\";\n-},{\n-    ::std::vector<ExprNodeP>    args;\n-    for(const auto& a : m_args) {\n-        args.push_back( a->clone() );\n-    }\n-    return NEWNODE(ExprNode_CallPath, AST::Path(m_path), mv$(args));\n-})\n-\n-NODE(ExprNode_CallMethod, {\n-    os << \"(\" << *m_val << \").\" << m_method << \"(\";\n-    for(const auto& a : m_args) {\n-        os << *a << \",\";\n-    }\n-    os << \")\";\n-},{\n-    ::std::vector<ExprNodeP>    args;\n-    for(const auto& a : m_args) {\n-        args.push_back( a->clone() );\n-    }\n-    return NEWNODE(ExprNode_CallMethod, m_val->clone(), m_method, mv$(args));\n-})\n-\n-NODE(ExprNode_CallObject, {\n-    os << \"(\" << *m_val << \")(\";\n-    for(const auto& a : m_args) {\n-        os << *a << \",\";\n-    }\n-    os << \")\";\n-},{\n-    ::std::vector<ExprNodeP>    args;\n-    for(const auto& a : m_args) {\n-        args.push_back( a->clone() );\n-    }\n-    return NEWNODE(ExprNode_CallObject, m_val->clone(), mv$(args));\n-})\n-\n-NODE(ExprNode_Loop, {\n-    os << \"LOOP [\" << m_label << \"] \" << m_pattern;\n-    if(m_cond)\n-        os << \" in/= \" << *m_cond;\n-    os << \" \" << *m_code;\n-},{\n-    return NEWNODE(ExprNode_Loop, m_label, m_type, m_pattern.clone(), OPT_CLONE(m_cond), m_code->clone());\n-})\n-\n-NODE(ExprNode_Match, {\n-    os << \"match (\"<<*m_val<<\") {\";\n-    for(const auto& arm : m_arms)\n-    {\n-        for( const auto& pat : arm.m_patterns )\n-            os << \" \" << pat;\n-        if( arm.m_cond )\n-            os << \" if \" << *arm.m_cond;\n-\n-        os << \" => \" << *arm.m_code << \",\";\n-    }\n-    os << \"}\";\n-},{\n-    ::std::vector< ExprNode_Match_Arm>  arms;\n-    for(const auto& arm : m_arms) {\n-        ::std::vector< AST::Pattern>    patterns;\n-        for( const auto& pat : arm.m_patterns ) {\n-            patterns.push_back( pat.clone() );\n-        }\n-        arms.push_back( ExprNode_Match_Arm( mv$(patterns), OPT_CLONE(arm.m_cond), arm.m_code->clone() ) );\n-        arms.back().m_attrs = arm.m_attrs.clone();\n-    }\n-    return NEWNODE(ExprNode_Match, m_val->clone(), mv$(arms));\n-})\n-\n-NODE(ExprNode_If, {\n-    os << \"if \" << *m_cond << \" { \" << *m_true << \" }\";\n-    if(m_false)\n-        os << \" else { \" << *m_false << \" }\";\n-},{\n-    return NEWNODE(ExprNode_If, m_cond->clone(), m_true->clone(), OPT_CLONE(m_false));\n-})\n-NODE(ExprNode_IfLet, {\n-    os << \"if let \" << m_pattern << \" = (\" << *m_value << \") { \" << *m_true << \" }\";\n-    if(m_false) os << \" else { \" << *m_false << \" }\";\n-},{\n-    return NEWNODE(ExprNode_IfLet, m_pattern.clone(), m_value->clone(), m_true->clone(), OPT_CLONE(m_false));\n-})\n-\n-NODE(ExprNode_Integer, {\n-    if( m_datatype == CORETYPE_CHAR )\n-        os << \"'\\\\u{\" << ::std::hex << m_value << ::std::dec << \"}'\";\n-    else\n-    {\n-        os << m_value;\n-        if( m_datatype == CORETYPE_ANY )\n-            ;\n-        else\n-            os << \"_\" << coretype_name(m_datatype);\n-    }\n-},{\n-    return NEWNODE(ExprNode_Integer, m_value, m_datatype);\n-})\n-NODE(ExprNode_Float, {\n-    os << m_value << \"_\" << m_datatype;\n-},{\n-    return NEWNODE(ExprNode_Float, m_value, m_datatype);\n-})\n-NODE(ExprNode_Bool, {\n-    os << m_value;\n-},{\n-    return NEWNODE(ExprNode_Bool, m_value);\n-})\n-NODE(ExprNode_String, {\n-    os << \"\\\"\" << m_value << \"\\\"\";\n-},{\n-    return NEWNODE(ExprNode_String, m_value);\n-})\n-NODE(ExprNode_ByteString, {\n-    os << \"b\\\"\" << m_value << \"\\\"\";\n-},{\n-    return NEWNODE(ExprNode_ByteString, m_value);\n-})\n-\n-NODE(ExprNode_Closure, {\n-    if( m_is_move )\n-        os << \"move \";\n-    os << \"|\";\n-    for(const auto& a : m_args)\n-    {\n-        os << a.first << \": \" << a.second << \",\";\n-    }\n-    os << \"|\";\n-    os << \"->\" << m_return;\n-    os << \" \" << *m_code;\n-},{\n-    ExprNode_Closure::args_t    args;\n-    for(const auto& a : m_args) {\n-        args.push_back( ::std::make_pair(a.first.clone(), a.second.clone()) );\n-    }\n-    return NEWNODE(ExprNode_Closure, mv$(args), m_return.clone(), m_code->clone(), m_is_move);\n-});\n-\n-NODE(ExprNode_StructLiteral, {\n-    os << m_path << \" { \";\n-    for(const auto& v : m_values)\n-    {\n-        os << v.name << \": \" << *v.value << \", \";\n-    }\n-    if(m_base_value)\n-    {\n-        os << \"..\" << *m_base_value;\n-    }\n-    os << \"}\";\n-},{\n-    ExprNode_StructLiteral::t_values    vals;\n-\n-    for(const auto& v : m_values) {\n-        vals.push_back({ v.attrs.clone(), v.name, v.value->clone() });\n-    }\n-\n-    return NEWNODE(ExprNode_StructLiteral, AST::Path(m_path), OPT_CLONE(m_base_value), mv$(vals) );\n-})\n-\n-NODE(ExprNode_Array, {\n-    os << \"[\";\n-    if( m_size.get() )\n-        os << *m_values[0] << \"; \" << *m_size;\n-    else\n-        for(const auto& a : m_values)\n-            os << *a << \",\";\n-    os << \"]\";\n-},{\n-    if( m_size.get() )\n-    {\n-        return NEWNODE(ExprNode_Array, m_values[0]->clone(), m_size->clone());\n-    }\n-    else\n-    {\n-        ::std::vector<ExprNodeP>    nodes;\n-        for(const auto& n : m_values)\n-            nodes.push_back( n->clone() );\n-        return NEWNODE(ExprNode_Array, mv$(nodes));\n-    }\n-})\n-\n-NODE(ExprNode_Tuple, {\n-    os << \"(\";\n-    for(const auto& a : m_values) {\n-        os << *a << \",\";\n-    }\n-    os << \")\";\n-},{\n-    ::std::vector<ExprNodeP>    nodes;\n-    for(const auto& n : m_values)\n-        nodes.push_back( n->clone() );\n-    return NEWNODE(ExprNode_Tuple, mv$(nodes));\n-})\n-\n-NODE(ExprNode_NamedValue, {\n-    os << m_path;\n-},{\n-    return NEWNODE(ExprNode_NamedValue, AST::Path(m_path));\n-})\n-\n-NODE(ExprNode_Field, {\n-    os << \"(\" << *m_obj << \").\" << m_name;\n-},{\n-    return NEWNODE(ExprNode_Field, m_obj->clone(), m_name);\n-})\n-\n-NODE(ExprNode_Index, {\n-    os << \"(\" << *m_obj << \")[\" << *m_idx << \"]\";\n-},{\n-    return NEWNODE(ExprNode_Index, m_obj->clone(), m_idx->clone());\n-})\n-\n-NODE(ExprNode_Deref, {\n-    os << \"*(\" << *m_value << \")\";\n-},{\n-    return NEWNODE(ExprNode_Deref, m_value->clone());\n-});\n-\n-NODE(ExprNode_Cast, {\n-    os << \"(\" << *m_value << \" as \" << m_type << \")\";\n-},{\n-    return NEWNODE(ExprNode_Cast, m_value->clone(), m_type.clone());\n-})\n-NODE(ExprNode_TypeAnnotation, {\n-    os << \"(\" << *m_value << \": \" << m_type << \")\";\n-},{\n-    return NEWNODE(ExprNode_TypeAnnotation, m_value->clone(), m_type.clone());\n-})\n-\n-NODE(ExprNode_BinOp, {\n-    if( m_type == RANGE_INC ) {\n-        os << \"(\";\n-        if( m_left ) {\n-            os << *m_left << \" \";\n-        }\n-        os << \"... \" << *m_right;\n-        os << \")\";\n-        return ;\n-    }\n-    if( m_type == RANGE ) {\n-        os << \"(\";\n-        if( m_left ) {\n-            os << *m_left;\n-        }\n-        os << \"..\";\n-        if( m_right ) {\n-            os << \" \" << *m_right;\n-        }\n-        os << \")\";\n-        return ;\n-    }\n-    os << \"(\" << *m_left << \" \";\n-    switch(m_type)\n-    {\n-    case CMPEQU:    os << \"==\"; break;\n-    case CMPNEQU:   os << \"!=\"; break;\n-    case CMPLT:     os << \"<\";  break;\n-    case CMPLTE:    os << \"<=\"; break;\n-    case CMPGT:     os << \">\";  break;\n-    case CMPGTE:    os << \">=\"; break;\n-    case BOOLAND:   os << \"&&\"; break;\n-    case BOOLOR:    os << \"||\"; break;\n-    case BITAND:    os << \"&\"; break;\n-    case BITOR:     os << \"|\"; break;\n-    case BITXOR:    os << \"^\"; break;\n-    case SHR:    os << \">>\"; break;\n-    case SHL:    os << \"<<\"; break;\n-    case MULTIPLY: os << \"*\"; break;\n-    case DIVIDE:   os << \"/\"; break;\n-    case MODULO:   os << \"%\"; break;\n-    case ADD:   os << \"+\"; break;\n-    case SUB:   os << \"-\"; break;\n-    case RANGE:   os << \"..\"; break;\n-    case RANGE_INC:   os << \"...\"; break;\n-    case PLACE_IN:  os << \"<-\"; break;\n-    }\n-    os << \" \" << *m_right << \")\";\n-},{\n-    return NEWNODE(ExprNode_BinOp, m_type, OPT_CLONE(m_left), OPT_CLONE(m_right));\n-})\n-\n-NODE(ExprNode_UniOp, {\n-    switch(m_type)\n-    {\n-    case NEGATE: os << \"(-\"; break;\n-    case INVERT: os << \"(!\"; break;\n-    case BOX: os << \"(box \"; break;\n-    case REF: os << \"(&\"; break;\n-    case REFMUT: os << \"(&mut \"; break;\n-    case QMARK: os << \"(\" << *m_value << \"?)\"; return;\n-    }\n-    os << *m_value << \")\";\n-},{\n-    return NEWNODE(ExprNode_UniOp, m_type, m_value->clone());\n-})\n-\n-\n-#define NV(type, actions)\\\n-    void NodeVisitorDef::visit(type& node) { /*DEBUG(\"DEF - \"#type);*/ actions }\n-//  void NodeVisitorDef::visit(const type& node) { DEBUG(\"DEF - \"#type\" (const)\"); actions }\n-\n-NV(ExprNode_Block, {\n-    //INDENT();\n-    for( auto& child : node.m_nodes )\n-        visit(child);\n-    //UNINDENT();\n-})\n-NV(ExprNode_Macro,\n-{\n-    BUG(node.span(), \"Hit unexpanded macro in expression - \" << node);\n-})\n-NV(ExprNode_Asm,\n-{\n-    for(auto& v : node.m_output)\n-        visit(v.value);\n-    for(auto& v : node.m_input)\n-        visit(v.value);\n-})\n-NV(ExprNode_Flow,\n-{\n-    visit(node.m_value);\n-})\n-NV(ExprNode_LetBinding,\n-{\n-    // TODO: Handle recurse into Let pattern?\n-    visit(node.m_value);\n-})\n-NV(ExprNode_Assign,\n-{\n-    INDENT();\n-    visit(node.m_slot);\n-    visit(node.m_value);\n-    UNINDENT();\n-})\n-NV(ExprNode_CallPath,\n-{\n-    INDENT();\n-    for( auto& arg : node.m_args )\n-        visit(arg);\n-    UNINDENT();\n-})\n-NV(ExprNode_CallMethod,\n-{\n-    INDENT();\n-    visit(node.m_val);\n-    for( auto& arg : node.m_args )\n-        visit(arg);\n-    UNINDENT();\n-})\n-NV(ExprNode_CallObject,\n-{\n-    INDENT();\n-    visit(node.m_val);\n-    for( auto& arg : node.m_args )\n-        visit(arg);\n-    UNINDENT();\n-})\n-NV(ExprNode_Loop,\n-{\n-    INDENT();\n-    visit(node.m_cond);\n-    visit(node.m_code);\n-    UNINDENT();\n-})\n-NV(ExprNode_Match,\n-{\n-    INDENT();\n-    visit(node.m_val);\n-    for( auto& arm : node.m_arms )\n-    {\n-        visit(arm.m_cond);\n-        visit(arm.m_code);\n-    }\n-    UNINDENT();\n-})\n-NV(ExprNode_If,\n-{\n-    INDENT();\n-    visit(node.m_cond);\n-    visit(node.m_true);\n-    visit(node.m_false);\n-    UNINDENT();\n-})\n-NV(ExprNode_IfLet,\n-{\n-    INDENT();\n-    visit(node.m_value);\n-    visit(node.m_true);\n-    visit(node.m_false);\n-    UNINDENT();\n-})\n-\n-NV(ExprNode_Integer, {(void)node;})\n-NV(ExprNode_Float, {(void)node;})\n-NV(ExprNode_Bool, {(void)node;})\n-NV(ExprNode_String, {(void)node;})\n-NV(ExprNode_ByteString, {(void)node;})\n-\n-NV(ExprNode_Closure,\n-{\n-    visit(node.m_code);\n-});\n-NV(ExprNode_StructLiteral,\n-{\n-    visit(node.m_base_value);\n-    for( auto& val : node.m_values )\n-        visit(val.value);\n-})\n-NV(ExprNode_Array,\n-{\n-    visit(node.m_size);\n-    for( auto& val : node.m_values )\n-        visit(val);\n-})\n-NV(ExprNode_Tuple,\n-{\n-    for( auto& val : node.m_values )\n-        visit(val);\n-})\n-NV(ExprNode_NamedValue,\n-{\n-    (void)node;\n-    // LEAF\n-})\n-\n-NV(ExprNode_Field,\n-{\n-    visit(node.m_obj);\n-})\n-NV(ExprNode_Index,\n-{\n-    visit(node.m_obj);\n-    visit(node.m_idx);\n-})\n-NV(ExprNode_Deref,\n-{\n-    visit(node.m_value);\n-})\n-NV(ExprNode_Cast,\n-{\n-    visit(node.m_value);\n-})\n-NV(ExprNode_TypeAnnotation,\n-{\n-    visit(node.m_value);\n-})\n-NV(ExprNode_BinOp,\n-{\n-    visit(node.m_left);\n-    visit(node.m_right);\n-})\n-NV(ExprNode_UniOp,\n-{\n-    visit(node.m_value);\n-})\n-#undef NV\n-\n-\n-};\n-"}, {"sha": "264b37e92a0a48f6901881123472689da8c21b34", "filename": "gcc/rust/mrustc_parser/ast/expr.hpp", "status": "removed", "additions": 0, "deletions": 719, "changes": 719, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,719 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/expr.hpp\n- * - AST Expression Nodes\n- */\n-#ifndef AST_EXPR_INCLUDED\n-#define AST_EXPR_INCLUDED\n-\n-#include <ostream>\n-#include <memory>   // unique_ptr\n-#include <vector>\n-\n-#include \"../parse/tokentree.hpp\"\n-#include \"types.hpp\"\n-#include \"pattern.hpp\"\n-#include \"attrs.hpp\"\n-\n-namespace AST {\n-\n-using ::std::unique_ptr;\n-\n-class NodeVisitor;\n-\n-class ExprNode\n-{\n-    AttributeList   m_attrs;\n-    Span    m_span;\n-public:\n-    virtual ~ExprNode() = 0;\n-\n-    virtual void visit(NodeVisitor& nv) = 0;\n-    virtual void print(::std::ostream& os) const = 0;\n-    virtual ::std::unique_ptr<ExprNode> clone() const = 0;\n-\n-    void set_span(Span s) { m_span = ::std::move(s); }\n-    const Span& span() const { return m_span; }\n-\n-    void set_attrs(AttributeList&& mi) {\n-        m_attrs = mv$(mi);\n-    }\n-    AttributeList& attrs() { return m_attrs; }\n-};\n-typedef ::std::unique_ptr<ExprNode> ExprNodeP;\n-\n-#define NODE_METHODS()  \\\n-    void visit(NodeVisitor& nv) override;\\\n-    void print(::std::ostream& os) const override; \\\n-    ::std::unique_ptr<ExprNode> clone() const override;\n-\n-struct ExprNode_Block:\n-    public ExprNode\n-{\n-    bool m_is_unsafe;\n-    bool m_yields_final_value;\n-    ::std::shared_ptr<AST::Module> m_local_mod;\n-    ::std::vector<ExprNodeP>    m_nodes;\n-\n-    ExprNode_Block(::std::vector<ExprNodeP> nodes={}):\n-        m_is_unsafe(false),\n-        m_yields_final_value(true),\n-        m_local_mod(),\n-        m_nodes( mv$(nodes) )\n-    {}\n-    ExprNode_Block(bool is_unsafe, bool yields_final_value, ::std::vector<ExprNodeP> nodes, ::std::shared_ptr<AST::Module> local_mod):\n-        m_is_unsafe(is_unsafe),\n-        m_yields_final_value(yields_final_value),\n-        m_local_mod( move(local_mod) ),\n-        m_nodes( move(nodes) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-\n-struct ExprNode_Macro:\n-    public ExprNode\n-{\n-    ::std::string   m_name;\n-    ::std::string   m_ident;\n-    ::TokenTree m_tokens;\n-\n-    ExprNode_Macro(::std::string name, ::std::string ident, ::TokenTree&& tokens):\n-        m_name(name),\n-        m_ident(ident),\n-        m_tokens( move(tokens) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-\n-// asm! macro\n-struct ExprNode_Asm:\n-    public ExprNode\n-{\n-    struct ValRef\n-    {\n-        ::std::string   name;\n-        unique_ptr<ExprNode>    value;\n-    };\n-\n-    ::std::string   m_text;\n-    ::std::vector<ValRef>   m_output;\n-    ::std::vector<ValRef>   m_input;\n-    ::std::vector<::std::string>    m_clobbers;\n-    ::std::vector<::std::string>    m_flags;\n-\n-    ExprNode_Asm(::std::string text, ::std::vector<ValRef> output, ::std::vector<ValRef> input, ::std::vector<::std::string> clobbers, ::std::vector<::std::string> flags):\n-        m_text( move(text) ),\n-        m_output( move(output) ),\n-        m_input( move(input) ),\n-        m_clobbers( move(clobbers) ),\n-        m_flags( move(flags) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-\n-// Break/Continue/Return\n-struct ExprNode_Flow:\n-    public ExprNode\n-{\n-    enum Type {\n-        RETURN,\n-        CONTINUE,\n-        BREAK,\n-    } m_type;\n-    ::std::string   m_target;\n-    unique_ptr<ExprNode>    m_value;\n-\n-    ExprNode_Flow(Type type, ::std::string target, unique_ptr<ExprNode>&& value):\n-        m_type(type),\n-        m_target( move(target) ),\n-        m_value( move(value) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-struct ExprNode_LetBinding:\n-    public ExprNode\n-{\n-    Pattern m_pat;\n-    TypeRef m_type;\n-    unique_ptr<ExprNode>    m_value;\n-\n-    ExprNode_LetBinding(Pattern pat, TypeRef type, unique_ptr<ExprNode>&& value):\n-        m_pat( move(pat) ),\n-        m_type( move(type) ),\n-        m_value( move(value) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-struct ExprNode_Assign:\n-    public ExprNode\n-{\n-    enum Operation {\n-        NONE,\n-        ADD, SUB,\n-        MUL, DIV, MOD,\n-        AND, OR , XOR,\n-        SHR, SHL,\n-    } m_op;\n-    unique_ptr<ExprNode>    m_slot;\n-    unique_ptr<ExprNode>    m_value;\n-\n-    ExprNode_Assign(): m_op(NONE) {}\n-    ExprNode_Assign(Operation op, unique_ptr<ExprNode>&& slot, unique_ptr<ExprNode>&& value):\n-        m_op(op),\n-        m_slot( move(slot) ),\n-        m_value( move(value) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-struct ExprNode_CallPath:\n-    public ExprNode\n-{\n-    Path    m_path;\n-    ::std::vector<unique_ptr<ExprNode>> m_args;\n-\n-    ExprNode_CallPath(Path&& path, ::std::vector<unique_ptr<ExprNode>>&& args):\n-        m_path( move(path) ),\n-        m_args( move(args) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-struct ExprNode_CallMethod:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_val;\n-    PathNode    m_method;\n-    ::std::vector<unique_ptr<ExprNode>> m_args;\n-\n-    ExprNode_CallMethod(unique_ptr<ExprNode> obj, PathNode method, ::std::vector<unique_ptr<ExprNode>> args):\n-        m_val( move(obj) ),\n-        m_method( move(method) ),\n-        m_args( move(args) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-// Call an object (Fn/FnMut/FnOnce)\n-struct ExprNode_CallObject:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_val;\n-    ::std::vector<unique_ptr<ExprNode>> m_args;\n-\n-    ExprNode_CallObject(unique_ptr<ExprNode>&& val, ::std::vector< unique_ptr<ExprNode> >&& args):\n-        m_val( move(val) ),\n-        m_args( move(args) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-\n-struct ExprNode_Loop:\n-    public ExprNode\n-{\n-    enum Type {\n-        LOOP,\n-        WHILE,\n-        WHILELET,\n-        FOR,\n-    } m_type;\n-    ::std::string   m_label;\n-    AST::Pattern    m_pattern;\n-    unique_ptr<ExprNode>    m_cond; // if NULL, loop is a 'loop'\n-    unique_ptr<ExprNode>    m_code;\n-\n-    ExprNode_Loop(): m_type(LOOP) {}\n-    ExprNode_Loop(::std::string label, unique_ptr<ExprNode> code):\n-        m_type(LOOP),\n-        m_label( ::std::move(label) ),\n-        m_code( ::std::move(code) )\n-    {}\n-    ExprNode_Loop(::std::string label, unique_ptr<ExprNode> cond, unique_ptr<ExprNode> code):\n-        m_type(WHILE),\n-        m_label( ::std::move(label) ),\n-        m_cond( ::std::move(cond) ),\n-        m_code( ::std::move(code) )\n-    {}\n-    ExprNode_Loop(::std::string label, Type type, AST::Pattern pattern, unique_ptr<ExprNode> val, unique_ptr<ExprNode> code):\n-        m_type(type),\n-        m_label( ::std::move(label) ),\n-        m_pattern( ::std::move(pattern) ),\n-        m_cond( ::std::move(val) ),\n-        m_code( ::std::move(code) )\n-    {}\n-    NODE_METHODS();\n-};\n-\n-struct ExprNode_Match_Arm\n-{\n-    AttributeList   m_attrs;\n-    ::std::vector<Pattern>  m_patterns;\n-    unique_ptr<ExprNode>    m_cond;\n-\n-    unique_ptr<ExprNode>    m_code;\n-\n-\n-    ExprNode_Match_Arm()\n-    {}\n-    ExprNode_Match_Arm(::std::vector<Pattern> patterns, unique_ptr<ExprNode> cond, unique_ptr<ExprNode> code):\n-        m_patterns( mv$(patterns) ),\n-        m_cond( mv$(cond) ),\n-        m_code( mv$(code) )\n-    {}\n-};\n-\n-struct ExprNode_Match:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_val;\n-    ::std::vector<ExprNode_Match_Arm>  m_arms;\n-\n-    ExprNode_Match(unique_ptr<ExprNode> val, ::std::vector<ExprNode_Match_Arm> arms):\n-        m_val( ::std::move(val) ),\n-        m_arms( ::std::move(arms) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-\n-struct ExprNode_If:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_cond;\n-    unique_ptr<ExprNode>    m_true;\n-    unique_ptr<ExprNode>    m_false;\n-\n-    ExprNode_If(unique_ptr<ExprNode>&& cond, unique_ptr<ExprNode>&& true_code, unique_ptr<ExprNode>&& false_code):\n-        m_cond( ::std::move(cond) ),\n-        m_true( ::std::move(true_code) ),\n-        m_false( ::std::move(false_code) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-struct ExprNode_IfLet:\n-    public ExprNode\n-{\n-    AST::Pattern    m_pattern;\n-    unique_ptr<ExprNode>    m_value;\n-    unique_ptr<ExprNode>    m_true;\n-    unique_ptr<ExprNode>    m_false;\n-\n-    ExprNode_IfLet(AST::Pattern pattern, unique_ptr<ExprNode>&& cond, unique_ptr<ExprNode>&& true_code, unique_ptr<ExprNode>&& false_code):\n-        m_pattern( ::std::move(pattern) ),\n-        m_value( ::std::move(cond) ),\n-        m_true( ::std::move(true_code) ),\n-        m_false( ::std::move(false_code) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-// Literal integer\n-struct ExprNode_Integer:\n-    public ExprNode\n-{\n-    enum eCoreType  m_datatype;\n-    uint64_t    m_value;\n-\n-    ExprNode_Integer(uint64_t value, enum eCoreType datatype):\n-        m_datatype(datatype),\n-        m_value(value)\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-// Literal float\n-struct ExprNode_Float:\n-    public ExprNode\n-{\n-    enum eCoreType  m_datatype;\n-    double  m_value;\n-\n-    ExprNode_Float(double value, enum eCoreType datatype):\n-        m_datatype(datatype),\n-        m_value(value)\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-// Literal boolean\n-struct ExprNode_Bool:\n-    public ExprNode\n-{\n-    bool    m_value;\n-\n-    ExprNode_Bool(bool value):\n-        m_value(value)\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-// Literal string\n-struct ExprNode_String:\n-    public ExprNode\n-{\n-    ::std::string   m_value;\n-\n-    ExprNode_String(::std::string value):\n-        m_value( ::std::move(value) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-// Literal byte string\n-struct ExprNode_ByteString:\n-    public ExprNode\n-{\n-    ::std::string   m_value;\n-\n-    ExprNode_ByteString(::std::string value):\n-        m_value( ::std::move(value) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-\n-// Closure / Lambda\n-struct ExprNode_Closure:\n-    public ExprNode\n-{\n-    typedef ::std::vector< ::std::pair<AST::Pattern, TypeRef> > args_t;\n-\n-    args_t  m_args;\n-    TypeRef m_return;\n-    unique_ptr<ExprNode>    m_code;\n-    bool m_is_move;\n-\n-    ExprNode_Closure(args_t args, TypeRef rv, unique_ptr<ExprNode> code, bool is_move):\n-        m_args( ::std::move(args) ),\n-        m_return( ::std::move(rv) ),\n-        m_code( ::std::move(code) ),\n-        m_is_move( is_move )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-// Literal structure\n-struct ExprNode_StructLiteral:\n-    public ExprNode\n-{\n-    struct Ent {\n-        AttributeList   attrs;\n-        ::std::string   name;\n-        unique_ptr<ExprNode>    value;\n-    };\n-    typedef ::std::vector<Ent> t_values;\n-    Path    m_path;\n-    unique_ptr<ExprNode>    m_base_value;\n-    t_values    m_values;\n-\n-    ExprNode_StructLiteral(Path path, unique_ptr<ExprNode>&& base_value, t_values&& values ):\n-        m_path( move(path) ),\n-        m_base_value( move(base_value) ),\n-        m_values( move(values) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-// Array\n-struct ExprNode_Array:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_size; // if non-NULL, it's a sized array\n-    ::std::vector< unique_ptr<ExprNode> >   m_values;\n-\n-    ExprNode_Array(::std::vector< unique_ptr<ExprNode> > vals):\n-        m_values( ::std::move(vals) )\n-    {}\n-    ExprNode_Array(unique_ptr<ExprNode> val, unique_ptr<ExprNode> size):\n-        m_size( ::std::move(size) )\n-    {\n-        m_values.push_back( ::std::move(val) );\n-    }\n-\n-    NODE_METHODS();\n-};\n-// Tuple\n-struct ExprNode_Tuple:\n-    public ExprNode\n-{\n-    ::std::vector< unique_ptr<ExprNode> >   m_values;\n-\n-    ExprNode_Tuple(::std::vector< unique_ptr<ExprNode> > vals):\n-        m_values( ::std::move(vals) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-// Variable / Constant\n-struct ExprNode_NamedValue:\n-    public ExprNode\n-{\n-    Path    m_path;\n-\n-    ExprNode_NamedValue(Path&& path):\n-        m_path( ::std::move(path) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-// Field dereference\n-struct ExprNode_Field:\n-    public ExprNode\n-{\n-    ::std::unique_ptr<ExprNode> m_obj;\n-    ::std::string   m_name;\n-\n-    ExprNode_Field(::std::unique_ptr<ExprNode>&& obj, ::std::string name):\n-        m_obj( ::std::move(obj) ),\n-        m_name( ::std::move(name) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-struct ExprNode_Index:\n-    public ExprNode\n-{\n-    ::std::unique_ptr<ExprNode> m_obj;\n-    ::std::unique_ptr<ExprNode> m_idx;\n-\n-    ExprNode_Index(::std::unique_ptr<ExprNode> obj, ::std::unique_ptr<ExprNode> idx):\n-        m_obj( ::std::move(obj) ),\n-        m_idx( ::std::move(idx) )\n-    {}\n-\n-    NODE_METHODS();\n-};\n-\n-// Pointer dereference\n-struct ExprNode_Deref:\n-    public ExprNode\n-{\n-    ::std::unique_ptr<ExprNode>    m_value;\n-\n-    ExprNode_Deref(::std::unique_ptr<ExprNode> value):\n-        m_value( ::std::move(value) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-\n-// Type cast ('as')\n-struct ExprNode_Cast:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_value;\n-    TypeRef m_type;\n-\n-    ExprNode_Cast(unique_ptr<ExprNode>&& value, TypeRef&& dst_type):\n-        m_value( move(value) ),\n-        m_type( move(dst_type) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-\n-// Type annotation (': _')\n-struct ExprNode_TypeAnnotation:\n-    public ExprNode\n-{\n-    unique_ptr<ExprNode>    m_value;\n-    TypeRef m_type;\n-\n-    ExprNode_TypeAnnotation(unique_ptr<ExprNode>&& value, TypeRef&& dst_type):\n-        m_value( move(value) ),\n-        m_type( move(dst_type) )\n-    {\n-    }\n-    NODE_METHODS();\n-};\n-\n-// Binary operation\n-struct ExprNode_BinOp:\n-    public ExprNode\n-{\n-    enum Type {\n-        CMPEQU,\n-        CMPNEQU,\n-        CMPLT,\n-        CMPLTE,\n-        CMPGT,\n-        CMPGTE,\n-\n-        RANGE,\n-        RANGE_INC,\n-        BOOLAND,\n-        BOOLOR,\n-\n-        BITAND,\n-        BITOR,\n-        BITXOR,\n-\n-        SHL,\n-        SHR,\n-\n-        MULTIPLY,\n-        DIVIDE,\n-        MODULO,\n-        ADD,\n-        SUB,\n-\n-        PLACE_IN,   // `in PLACE { expr }` or `PLACE <- expr`\n-    };\n-\n-    Type    m_type;\n-    ::std::unique_ptr<ExprNode> m_left;\n-    ::std::unique_ptr<ExprNode> m_right;\n-\n-    ExprNode_BinOp(Type type, ::std::unique_ptr<ExprNode> left, ::std::unique_ptr<ExprNode> right):\n-        m_type(type),\n-        m_left( ::std::move(left) ),\n-        m_right( ::std::move(right) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-\n-struct ExprNode_UniOp:\n-    public ExprNode\n-{\n-    enum Type {\n-        REF,    // '& <expr>'\n-        REFMUT, // '&mut <expr>'\n-        BOX,    // 'box <expr>'\n-        INVERT, // '!<expr>'\n-        NEGATE, // '-<expr>'\n-        QMARK, // '<expr>?'\n-    };\n-\n-    enum Type   m_type;\n-    ::std::unique_ptr<ExprNode> m_value;\n-\n-    ExprNode_UniOp(Type type, ::std::unique_ptr<ExprNode> value):\n-        m_type(type),\n-        m_value( ::std::move(value) )\n-    {\n-    }\n-\n-    NODE_METHODS();\n-};\n-\n-#undef NODE_METHODS\n-\n-class NodeVisitor\n-{\n-public:\n-    virtual ~NodeVisitor() = default;\n-    inline void visit(const unique_ptr<ExprNode>& cnode) {\n-        if(cnode.get())\n-            cnode->visit(*this);\n-    }\n-    virtual bool is_const() const { return false; }\n-\n-    #define NT(nt) \\\n-        virtual void visit(nt& node) = 0/*; \\\n-        virtual void visit(const nt& node) = 0*/\n-    NT(ExprNode_Block);\n-    NT(ExprNode_Macro);\n-    NT(ExprNode_Asm);\n-    NT(ExprNode_Flow);\n-    NT(ExprNode_LetBinding);\n-    NT(ExprNode_Assign);\n-    NT(ExprNode_CallPath);\n-    NT(ExprNode_CallMethod);\n-    NT(ExprNode_CallObject);\n-    NT(ExprNode_Loop);\n-    NT(ExprNode_Match);\n-    NT(ExprNode_If);\n-    NT(ExprNode_IfLet);\n-\n-    NT(ExprNode_Integer);\n-    NT(ExprNode_Float);\n-    NT(ExprNode_Bool);\n-    NT(ExprNode_String);\n-    NT(ExprNode_ByteString);\n-    NT(ExprNode_Closure);\n-    NT(ExprNode_StructLiteral);\n-    NT(ExprNode_Array);\n-    NT(ExprNode_Tuple);\n-    NT(ExprNode_NamedValue);\n-\n-    NT(ExprNode_Field);\n-    NT(ExprNode_Index);\n-    NT(ExprNode_Deref);\n-    NT(ExprNode_Cast);\n-    NT(ExprNode_TypeAnnotation);\n-    NT(ExprNode_BinOp);\n-    NT(ExprNode_UniOp);\n-    #undef NT\n-};\n-class NodeVisitorDef:\n-    public NodeVisitor\n-{\n-public:\n-    inline void visit(const unique_ptr<ExprNode>& cnode) {\n-        if(cnode.get())\n-            cnode->visit(*this);\n-    }\n-    #define NT(nt) \\\n-        virtual void visit(nt& node) override;/* \\\n-        virtual void visit(const nt& node) override*/\n-    NT(ExprNode_Block);\n-    NT(ExprNode_Macro);\n-    NT(ExprNode_Asm);\n-    NT(ExprNode_Flow);\n-    NT(ExprNode_LetBinding);\n-    NT(ExprNode_Assign);\n-    NT(ExprNode_CallPath);\n-    NT(ExprNode_CallMethod);\n-    NT(ExprNode_CallObject);\n-    NT(ExprNode_Loop);\n-    NT(ExprNode_Match);\n-    NT(ExprNode_If);\n-    NT(ExprNode_IfLet);\n-\n-    NT(ExprNode_Integer);\n-    NT(ExprNode_Float);\n-    NT(ExprNode_Bool);\n-    NT(ExprNode_String);\n-    NT(ExprNode_ByteString);\n-    NT(ExprNode_Closure);\n-    NT(ExprNode_StructLiteral);\n-    NT(ExprNode_Array);\n-    NT(ExprNode_Tuple);\n-    NT(ExprNode_NamedValue);\n-\n-    NT(ExprNode_Field);\n-    NT(ExprNode_Index);\n-    NT(ExprNode_Deref);\n-    NT(ExprNode_Cast);\n-    NT(ExprNode_TypeAnnotation);\n-    NT(ExprNode_BinOp);\n-    NT(ExprNode_UniOp);\n-    #undef NT\n-};\n-\n-}\n-\n-#endif\n-"}, {"sha": "cae519ccc3a381bbb89e9f17cd27268d298035c1", "filename": "gcc/rust/mrustc_parser/ast/expr_ptr.hpp", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fexpr_ptr.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,38 +0,0 @@\n-/*\n-  * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/expr_ptr.hpp\n- * - Pointer type wrapping AST::ExprNode (prevents need to know the full definition)\n- */\n-#include <memory>\n-\n-namespace AST {\n-\n-class ExprNode;\n-class NodeVisitor;\n-\n-typedef ::std::unique_ptr<AST::ExprNode>    ExprNodeP;\n-extern ::std::ostream& operator<<(::std::ostream& os, const ExprNode& node);\n-\n-class Expr\n-{\n-    ::std::shared_ptr<ExprNode> m_node;\n-public:\n-    Expr(unique_ptr<ExprNode> node);\n-    Expr(ExprNode* node);\n-    Expr();\n-\n-    bool is_valid() const { return m_node.get() != nullptr; }\n-    const ExprNode& node() const { assert(m_node.get()); return *m_node; }\n-          ExprNode& node()       { assert(m_node.get()); return *m_node; }\n-    ::std::shared_ptr<ExprNode> take_node() { assert(m_node.get()); return ::std::move(m_node); }\n-    void visit_nodes(NodeVisitor& v);\n-    void visit_nodes(NodeVisitor& v) const;\n-\n-    Expr clone() const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Expr& pat);\n-};\n-\n-}"}, {"sha": "c222044cabe188b7d5117de76ca0d6a53aa85a7c", "filename": "gcc/rust/mrustc_parser/ast/generics.hpp", "status": "removed", "additions": 0, "deletions": 181, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fgenerics.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,181 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/generics.hpp\n- * - AST Generics (type parameters, bounds, ...)\n- */\n-#pragma once\n-\n-#include <string>\n-#include \"types.hpp\"\n-\n-namespace AST {\n-\n-class TypeParam\n-{\n-    ::AST::AttributeList    m_attrs;\n-    Span    m_span;\n-    // TODO: use an Ident?\n-    ::std::string   m_name;\n-    ::TypeRef m_default;\n-public:\n-    TypeParam(TypeParam&& x) = default;\n-    TypeParam& operator=(TypeParam&& x) = default;\n-    explicit TypeParam(const TypeParam& x):\n-        m_attrs( x.m_attrs ),\n-        m_span( x.m_span ),\n-        m_name( x.m_name ),\n-        m_default( x.m_default.clone() )\n-    {\n-    }\n-\n-    TypeParam(Span sp, ::AST::AttributeList attrs, ::std::string name):\n-        m_attrs( ::std::move(attrs) ),\n-        m_span( ::std::move(sp) ),\n-        m_name( ::std::move(name) ),\n-        m_default(m_span)\n-    {}\n-\n-    void setDefault(TypeRef type) {\n-        assert(m_default.is_wildcard());\n-        m_default = ::std::move(type);\n-    }\n-\n-    const ::AST::AttributeList& attrs() const { return m_attrs; }\n-    const Span& span() const { return m_span; }\n-    const ::std::string& name() const { return m_name; }\n-\n-    const TypeRef& get_default() const { return m_default; }\n-          TypeRef& get_default()       { return m_default; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const TypeParam& tp);\n-};\n-class LifetimeParam\n-{\n-    ::AST::AttributeList    m_attrs;\n-    Span    m_span;\n-    Ident   m_name;\n-public:\n-    LifetimeParam(Span sp, ::AST::AttributeList attrs, Ident name):\n-        m_attrs( ::std::move(attrs) ),\n-        m_span( ::std::move(sp) ),\n-        m_name( ::std::move(name) )\n-    {\n-    }\n-    LifetimeParam(LifetimeParam&&) = default;\n-    LifetimeParam& operator=(LifetimeParam&&) = default;\n-    explicit LifetimeParam(const LifetimeParam&) = default;\n-\n-    const ::AST::AttributeList& attrs() const { return m_attrs; }\n-    const Span& span() const { return m_span; }\n-    const Ident& name() const { return m_name; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const LifetimeParam& p);\n-};\n-\n-// HigherRankedBounds is defined in `types.hpp`\n-\n-TAGGED_UNION_EX( GenericBound, (), None,\n-    (\n-    (None, struct{}),\n-    // Lifetime bound: 'test must be valid for 'bound\n-    (Lifetime, struct {\n-        LifetimeRef test;\n-        LifetimeRef bound;\n-        }),\n-    // Type lifetime bound\n-    (TypeLifetime, struct {\n-        TypeRef type;\n-        LifetimeRef bound;\n-        }),\n-    // Standard trait bound: \"Type: [for<'a>] Trait\"\n-    (IsTrait, struct {\n-        HigherRankedBounds  outer_hrbs;\n-        TypeRef type;\n-        HigherRankedBounds  inner_hrbs;\n-        AST::Path   trait;\n-        }),\n-    // Removed trait bound: \"Type: ?Trait\"\n-    (MaybeTrait, struct {\n-        TypeRef type;\n-        AST::Path   trait;\n-        }),\n-    // Negative trait bound: \"Type: !Trait\"\n-    (NotTrait, struct {\n-        TypeRef type;\n-        AST::Path   trait;\n-        }),\n-    // Type equality: \"Type = Replacement\"\n-    (Equality, struct {\n-        TypeRef type;\n-        TypeRef replacement;\n-        })\n-    ),\n-\n-    (, span(x.span) ), ( span = x.span; ),\n-    (\n-    public:\n-\n-        Span    span;\n-\n-        GenericBound clone() const {\n-            TU_MATCH(GenericBound, ( (*this) ), (ent),\n-            (None, return make_None({}); ),\n-            (Lifetime,     return make_Lifetime({ent.test, ent.bound});     ),\n-            (TypeLifetime, return make_TypeLifetime({ent.type.clone(), ent.bound}); ),\n-            (IsTrait,    return make_IsTrait({ent.outer_hrbs, ent.type.clone(), ent.inner_hrbs, ent.trait}); ),\n-            (MaybeTrait, return make_MaybeTrait({ent.type.clone(), ent.trait}); ),\n-            (NotTrait,   return make_NotTrait({ent.type.clone(), ent.trait}); ),\n-            (Equality,   return make_Equality({ent.type.clone(), ent.replacement.clone()}); )\n-            )\n-            return GenericBound();\n-        }\n-        )\n-    );\n-\n-::std::ostream& operator<<(::std::ostream& os, const GenericBound& x);\n-\n-class GenericParams\n-{\n-    ::std::vector<TypeParam>    m_type_params;\n-    ::std::vector<LifetimeParam>    m_lifetime_params;\n-    ::std::vector<GenericBound>    m_bounds;\n-public:\n-    GenericParams() {}\n-    GenericParams(GenericParams&& x) = default;\n-    GenericParams& operator=(GenericParams&& x) = default;\n-    GenericParams(const GenericParams& x) = delete;\n-\n-    GenericParams clone() const {\n-        GenericParams   rv;\n-        rv.m_type_params = ::std::vector<TypeParam>( m_type_params );   // Copy-constructable\n-        rv.m_lifetime_params = ::std::vector<LifetimeParam>(m_lifetime_params);\n-        rv.m_bounds.reserve( m_bounds.size() );\n-        for(auto& e: m_bounds)\n-            rv.m_bounds.push_back( e.clone() );\n-        return rv;\n-    }\n-\n-    const ::std::vector<TypeParam>& ty_params() const { return m_type_params; }\n-          ::std::vector<TypeParam>& ty_params()       { return m_type_params; }\n-    const ::std::vector<LifetimeParam>& lft_params() const { return m_lifetime_params; }\n-    const ::std::vector<GenericBound>& bounds() const { return m_bounds; }\n-          ::std::vector<GenericBound>& bounds()       { return m_bounds; }\n-\n-    void add_ty_param(TypeParam param) { m_type_params.push_back( ::std::move(param) ); }\n-    void add_lft_param(LifetimeParam lft) { m_lifetime_params.push_back( ::std::move(lft) ); }\n-    void add_bound(GenericBound bound) {\n-        m_bounds.push_back( ::std::move(bound) );\n-    }\n-\n-    int find_name(const char* name) const;\n-    bool check_params(Crate& crate, const ::std::vector<TypeRef>& types) const;\n-    bool check_params(Crate& crate, ::std::vector<TypeRef>& types, bool allow_infer) const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const GenericParams& tp);\n-};\n-\n-\n-}\n-"}, {"sha": "0074ce9adeff463dbc24f4b6d9e308558def1b9a", "filename": "gcc/rust/mrustc_parser/ast/item.hpp", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fitem.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,40 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/item.hpp\n- * - AST named item wrapper\n- */\n-#pragma once\n-\n-#include <string>\n-#include <vector>\n-\n-namespace AST {\n-\n-template <typename T>\n-struct Named\n-{\n-    ::std::string   name;\n-    T   data;\n-    bool    is_pub;\n-\n-    Named():\n-        is_pub(false)\n-    {}\n-    Named(Named&&) = default;\n-    Named(const Named&) = default;\n-    Named& operator=(Named&&) = default;\n-    Named(::std::string name, T data, bool is_pub):\n-        name( ::std::move(name) ),\n-        data( ::std::move(data) ),\n-        is_pub( is_pub )\n-    {\n-    }\n-};\n-\n-template <typename T>\n-using NamedList = ::std::vector<Named<T> >;\n-\n-}   // namespace AST\n-"}, {"sha": "5b2223ce9c1c9e292c3530694237dae9f28a2655", "filename": "gcc/rust/mrustc_parser/ast/macro.hpp", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fmacro.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,67 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/macro.hpp\n- * - AST representation of a macro invocation\n- */\n-#ifndef _AST_MACRO_HPP_\n-#define _AST_MACRO_HPP_\n-\n-#include \"../parse/tokentree.hpp\"\n-#include <span.hpp>\n-#include \"attrs.hpp\"\n-\n-namespace AST {\n-\n-class MacroInvocation\n-{\n-    Span    m_span;\n-\n-    ::std::string   m_macro_name;\n-    ::std::string   m_ident;\n-    TokenTree   m_input;\n-public:\n-    MacroInvocation(MacroInvocation&&) = default;\n-    MacroInvocation& operator=(MacroInvocation&&) = default;\n-    MacroInvocation(const MacroInvocation&) = delete;\n-    MacroInvocation& operator=(const MacroInvocation&) = delete;\n-\n-    MacroInvocation()\n-    {\n-    }\n-\n-    MacroInvocation(Span span, ::std::string macro, ::std::string ident, TokenTree input):\n-        m_span( mv$(span) ),\n-        m_macro_name( mv$(macro) ),\n-        m_ident( mv$(ident) ),\n-        m_input( mv$(input) )\n-    {\n-    }\n-\n-    MacroInvocation clone() const;\n-\n-    void clear() {\n-        m_macro_name = \"\";\n-        m_ident = \"\";\n-        m_input = TokenTree();\n-    }\n-\n-    const Span& span() const { return m_span; }\n-    const ::std::string& name() const { return m_macro_name; }\n-\n-    const ::std::string& input_ident() const { return m_ident; }\n-    const TokenTree& input_tt() const { return m_input; }\n-          TokenTree& input_tt()       { return m_input; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const MacroInvocation& x) {\n-        os << x.m_macro_name << \"! \" << x.m_ident << x.m_input;\n-        return os;\n-    }\n-};\n-\n-\n-}\n-\n-#endif\n-"}, {"sha": "6fdf1e40d177c57ac6c96ead1c93fb6df955ec4e", "filename": "gcc/rust/mrustc_parser/ast/path.cpp", "status": "removed", "additions": 0, "deletions": 347, "changes": 347, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,347 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/path.cpp\n- * - AST::Path and friends\n- */\n-#include \"path.hpp\"\n-#include \"ast.hpp\"\n-#include \"types.hpp\"\n-#include <iostream>\n-#include \"../parse/parseerror.hpp\"\n-#include <algorithm>\n-\n-#define PRETTY_PATH_PRINT   1\n-\n-namespace AST {\n-\n-// --- AST::PathBinding\n-::std::ostream& operator<<(::std::ostream& os, const PathBinding& x) {\n-    TU_MATCH(PathBinding, (x), (i),\n-    (Unbound, os << \"_\";   ),\n-    (Crate ,  os << \"Crate\";    ),\n-    (Module,  os << \"Module\";    ),\n-    (Trait,     os << \"Trait\";   ),\n-    (Struct,    os << \"Struct\";  ),\n-    (Enum,      os << \"Enum\";    ),\n-    (Union,     os << \"Union\";   ),\n-    (Static,    os << \"Static\";  ),\n-    (Function,  os << \"Function\";),\n-    (EnumVar,  os << \"EnumVar(\" << i.idx << \")\"; ),\n-    (TypeAlias, os << \"TypeAlias\";),\n-    (StructMethod, os << \"StructMethod\"; ),\n-    (TraitMethod,  os << \"TraitMethod\";  ),\n-\n-    (TypeParameter, os << \"TyParam(\" << i.level << \" # \" << i.idx << \")\"; ),\n-    (Variable, os << \"Var(\" << i.slot << \")\"; )\n-    )\n-    return os;\n-}\n-PathBinding PathBinding::clone() const\n-{\n-    TU_MATCH(::AST::PathBinding, (*this), (e),\n-    (Unbound , return PathBinding::make_Unbound({}); ),\n-    (Module  , return PathBinding::make_Module(e);   ),\n-    (Crate   , return PathBinding(e); ),\n-    (Trait   , return PathBinding(e); ),\n-    (Struct  , return PathBinding(e); ),\n-    (Enum    , return PathBinding(e); ),\n-    (Union   , return PathBinding(e); ),\n-    (Static  , return PathBinding(e); ),\n-    (Function, return PathBinding(e); ),\n-    (TypeAlias, return PathBinding::make_TypeAlias(e); ),\n-    (EnumVar , return PathBinding::make_EnumVar(e);  ),\n-    (StructMethod, return PathBinding::make_StructMethod(e); ),\n-    (TraitMethod, return PathBinding::make_TraitMethod(e); ),\n-\n-    (TypeParameter, return PathBinding::make_TypeParameter(e); ),\n-    (Variable, return PathBinding::make_Variable(e); )\n-    )\n-    throw \"BUG: Fell off the end of PathBinding::clone\";\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const PathParams& x)\n-{\n-    bool needs_comma = false;\n-    os << \"<\";\n-    for(const auto& v : x.m_lifetimes) {\n-        if(needs_comma) os << \", \";\n-        needs_comma = true;\n-        os << \"'\" << v;\n-    }\n-    for(const auto& v : x.m_types) {\n-        if(needs_comma) os << \", \";\n-        needs_comma = true;\n-        os << v;\n-    }\n-    for(const auto& v : x.m_assoc) {\n-        if(needs_comma) os << \", \";\n-        needs_comma = true;\n-        os << v.first << \"=\" << v.second;\n-    }\n-    os << \">\";\n-    return os;\n-}\n-PathParams::PathParams(const PathParams& x):\n-    m_lifetimes( x.m_lifetimes )\n-{\n-    m_types.reserve( x.m_types.size() );\n-    for(const auto& t : x.m_types)\n-        m_types.push_back(t.clone());\n-\n-    m_assoc.reserve( x.m_assoc.size() );\n-    for(const auto& t : x.m_assoc)\n-        m_assoc.push_back( ::std::make_pair(t.first, t.second.clone()) );\n-}\n-Ordering PathParams::ord(const PathParams& x) const\n-{\n-    Ordering rv;\n-    rv = ::ord(m_lifetimes, x.m_lifetimes);\n-    if(rv != OrdEqual)  return rv;\n-    rv = ::ord(m_types, x.m_types);\n-    if(rv != OrdEqual)  return rv;\n-    rv = ::ord(m_assoc, x.m_assoc);\n-    if(rv != OrdEqual)  return rv;\n-    return rv;\n-}\n-\n-// --- AST::PathNode\n-PathNode::PathNode(::std::string name, PathParams args):\n-    m_name( mv$(name) ),\n-    m_params( mv$(args) )\n-{\n-}\n-Ordering PathNode::ord(const PathNode& x) const\n-{\n-    Ordering    rv;\n-    rv = ::ord(m_name, x.m_name);\n-    if(rv != OrdEqual)  return rv;\n-    rv = m_params.ord(x.m_params);\n-    if(rv != OrdEqual)  return rv;\n-    return OrdEqual;\n-}\n-void PathNode::print_pretty(::std::ostream& os, bool is_type_context) const\n-{\n-    os << m_name;\n-    if( ! m_params.is_empty() )\n-    {\n-        if( ! is_type_context )\n-            os << \"::\";\n-        os << m_params;\n-    }\n-}\n-::std::ostream& operator<<(::std::ostream& os, const PathNode& pn) {\n-    pn.print_pretty(os, false);\n-    return os;\n-}\n-\n-/// Return an iterator to the named item\n-template<typename T>\n-typename ::std::vector<Named<T> >::const_iterator find_named(const ::std::vector<Named<T> >& vec, const ::std::string& name)\n-{\n-    return ::std::find_if(vec.begin(), vec.end(), [&name](const Named<T>& x) {\n-        return x.name == name;\n-    });\n-}\n-\n-// --- AST::Path\n-AST::Path::~Path()\n-{\n-}\n-AST::Path::Path(TagUfcs, TypeRef type, ::std::vector<AST::PathNode> nodes):\n-    m_class( AST::Path::Class::make_UFCS({box$(type), nullptr, nodes}) )\n-{\n-}\n-AST::Path::Path(TagUfcs, TypeRef type, Path trait, ::std::vector<AST::PathNode> nodes):\n-    m_class( AST::Path::Class::make_UFCS({box$(type), box$(trait), nodes}) )\n-{\n-}\n-AST::Path::Path(const Path& x):\n-    m_class()\n-    //m_binding(x.m_binding)\n-{\n-    TU_MATCH(Class, (x.m_class), (ent),\n-    (Invalid, m_class = Class::make_Invalid({});),\n-    (Local,\n-        m_class = Class::make_Local({ent.name});\n-        ),\n-    (Relative,\n-        m_class = Class::make_Relative({ent.hygiene, ent.nodes});\n-        ),\n-    (Self,\n-        m_class = Class::make_Self({ent.nodes});\n-        ),\n-    (Super,\n-        m_class = Class::make_Super({ent.count, ent.nodes});\n-        ),\n-    (Absolute,\n-        m_class = Class::make_Absolute({ent.crate, ent.nodes});\n-        ),\n-    (UFCS,\n-        if( ent.trait )\n-            m_class = Class::make_UFCS({ box$(ent.type->clone()), ::std::unique_ptr<Path>(new Path(*ent.trait)), ent.nodes });\n-        else\n-            m_class = Class::make_UFCS({ box$(ent.type->clone()), nullptr, ent.nodes });\n-        )\n-    )\n-\n-    memcpy(&m_binding, &x.m_binding, sizeof(PathBinding));\n-}\n-\n-void Path::bind_variable(unsigned int slot)\n-{\n-    m_binding = PathBinding::make_Variable({slot});\n-}\n-void Path::bind_enum_var(const Enum& ent, const ::std::string& name, const ::std::vector<TypeRef>& /*args*/)\n-{\n-    auto it = ::std::find_if(ent.variants().begin(), ent.variants().end(), [&](const auto& x) { return x.m_name == name; });\n-    if( it == ent.variants().end() )\n-    {\n-        throw ParseError::Generic(\"Enum variant not found\");\n-    }\n-    unsigned int idx = it - ent.variants().begin();\n-\n-    DEBUG(\"Bound to enum variant '\" << name << \"' (#\" << idx << \")\");\n-    ::AST::PathBinding::Data_EnumVar tmp = {};\n-    tmp.enum_ = &ent;\n-    tmp.idx = idx;\n-    m_binding = PathBinding::make_EnumVar( mv$(tmp) );\n-}\n-\n-Path& Path::operator+=(const Path& other)\n-{\n-    for(auto& node : other.nodes())\n-        append(node);\n-    // If the path is modified, clear the binding\n-    m_binding = PathBinding();\n-    return *this;\n-}\n-\n-Ordering Path::ord(const Path& x) const\n-{\n-    Ordering rv;\n-\n-    rv = ::ord( (unsigned)m_class.tag(), (unsigned)x.m_class.tag() );\n-    if( rv != OrdEqual )    return rv;\n-\n-    TU_MATCH(Path::Class, (m_class, x.m_class), (ent, x_ent),\n-    (Invalid,\n-        return OrdEqual;\n-        ),\n-    (Local,\n-        return ::ord(ent.name, x_ent.name);\n-        ),\n-    (Relative,\n-        return ::ord(ent.nodes, x_ent.nodes);\n-        ),\n-    (Self,\n-        return ::ord(ent.nodes, x_ent.nodes);\n-        ),\n-    (Super,\n-        return ::ord(ent.nodes, x_ent.nodes);\n-        ),\n-    (Absolute,\n-        rv = ::ord( ent.crate, x_ent.crate );\n-        if( rv != OrdEqual )    return rv;\n-        return ::ord(ent.nodes, x_ent.nodes);\n-        ),\n-    (UFCS,\n-        rv = ent.type->ord( *x_ent.type );\n-        if( rv != OrdEqual )    return rv;\n-        rv = ent.trait->ord( *x_ent.trait );\n-        if( rv != OrdEqual )    return rv;\n-        return ::ord(ent.nodes, x_ent.nodes);\n-        )\n-    )\n-\n-    return OrdEqual;\n-}\n-\n-void Path::print_pretty(::std::ostream& os, bool is_type_context, bool is_debug) const\n-{\n-    TU_MATCH(Path::Class, (m_class), (ent),\n-    (Invalid,\n-        os << \"/*inv*/\";\n-        // NOTE: Don't print the binding for invalid paths\n-        return ;\n-        ),\n-    (Local,\n-        // Only print comment if there's no binding\n-        if( m_binding.is_Unbound() )\n-        {\n-            if( is_debug )\n-                os << \"/*var*/\";\n-        }\n-        else\n-            assert( m_binding.is_Variable() );\n-        os << ent.name;\n-        ),\n-    (Relative,\n-        if( is_debug )\n-            os << ent.hygiene;\n-        for(const auto& n : ent.nodes)\n-        {\n-            if( &n != &ent.nodes[0] ) {\n-                os << \"::\";\n-            }\n-            n.print_pretty(os, is_type_context);\n-        }\n-        ),\n-    (Self,\n-        os << \"self\";\n-        for(const auto& n : ent.nodes)\n-        {\n-            os << \"::\";\n-            n.print_pretty(os, is_type_context);\n-        }\n-        ),\n-    (Super,\n-        os << \"super\";\n-        for(const auto& n : ent.nodes)\n-        {\n-            os << \"::\";\n-            n.print_pretty(os, is_type_context);\n-        }\n-        ),\n-    (Absolute,\n-        if( ent.crate != \"\" )\n-            os << \"::\\\"\" << ent.crate << \"\\\"\";\n-        for(const auto& n : ent.nodes)\n-        {\n-            os << \"::\";\n-            n.print_pretty(os, is_type_context);\n-        }\n-        ),\n-    (UFCS,\n-        //os << \"/*ufcs*/\";\n-        if( ent.trait ) {\n-            os << \"<\" << *ent.type << \" as \";\n-            if( ent.trait->m_class.is_Invalid() ) {\n-                os << \"_\";\n-            }\n-            else {\n-                os << *ent.trait;\n-            }\n-            os << \">\";\n-        }\n-        else {\n-            os << \"<\" << *ent.type << \">\";\n-        }\n-        for(const auto& n : ent.nodes) {\n-            os << \"::\";\n-            n.print_pretty(os, is_type_context);\n-        }\n-        )\n-    )\n-    if( is_debug )\n-        os << \"/*\" << m_binding << \"*/\";\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const Path& path)\n-{\n-    path.print_pretty(os, false, true);\n-    return os;\n-}\n-\n-}"}, {"sha": "c2d13d73e1b10bf267d01ab6ce68a6a071d2c473", "filename": "gcc/rust/mrustc_parser/ast/path.hpp", "status": "removed", "additions": 0, "deletions": 365, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpath.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,365 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/path.hpp\n- * - AST::Path and helper types\n- */\n-#ifndef AST_PATH_HPP_INCLUDED\n-#define AST_PATH_HPP_INCLUDED\n-\n-#include \"../common.hpp\"\n-#include <string>\n-#include <stdexcept>\n-#include <vector>\n-#include <initializer_list>\n-#include <cassert>\n-#include <tagged_union.hpp>\n-#include <string>\n-#include \"../include/span.hpp\"\n-#include \"../include/ident.hpp\"\n-\n-class TypeRef;\n-\n-namespace HIR {\n-class Module;\n-class Trait;\n-class Enum;\n-class Struct;\n-class Union;\n-class Static;\n-}   // namespace HIR\n-\n-namespace AST {\n-\n-class LifetimeRef;\n-class GenericParams;\n-class Crate;\n-class Module;\n-class TypeAlias;\n-class Enum;\n-class Struct;\n-class Union;\n-class Trait;\n-class Static;\n-class Function;\n-class ExternCrate;\n-\n-TAGGED_UNION_EX(PathBinding, (), Unbound, (\n-    (Unbound, struct {\n-        }),\n-    (Crate, struct {\n-        const ExternCrate* crate_;\n-        }),\n-    (Module, struct {\n-        const Module* module_;\n-        const ::HIR::Module* hir;\n-        }),\n-    (Struct, struct {\n-        const Struct* struct_;\n-        const ::HIR::Struct* hir;\n-        }),\n-    (Enum,   struct {\n-        const Enum* enum_;\n-        const ::HIR::Enum*  hir;\n-        }),\n-    (Union,   struct {\n-        const Union* union_;\n-        const ::HIR::Union*  hir;\n-        }),\n-    (Trait,  struct {\n-        const Trait* trait_;\n-        const ::HIR::Trait* hir;\n-        }),\n-    (Static, struct {\n-        const Static* static_;\n-        const ::HIR::Static* hir; // if nullptr and static_ == nullptr, points to a `const`\n-        }),\n-    (Function, struct {\n-        const Function* func_;\n-        }),\n-    (EnumVar, struct {\n-        const Enum* enum_;\n-        unsigned int idx;\n-        const ::HIR::Enum*  hir;\n-        }),\n-    (TypeAlias, struct {\n-        const TypeAlias* alias_;\n-        }),\n-    (StructMethod, struct {\n-        const Struct* struct_;\n-        ::std::string name;\n-        }),\n-    (TraitMethod, struct {\n-        const Trait* trait_;\n-        ::std::string name;\n-        }),\n-\n-    (TypeParameter, struct {\n-        unsigned int level;\n-        unsigned int idx;\n-        }),\n-    (Variable, struct {\n-        unsigned int slot;\n-        })\n-    ),\n-    (), (),\n-    (\n-    public:\n-        PathBinding clone() const;\n-        )\n-    );\n-\n-extern ::std::ostream& operator<<(::std::ostream& os, const PathBinding& x);\n-\n-struct PathParams\n-{\n-    ::std::vector< LifetimeRef >  m_lifetimes;\n-    ::std::vector< TypeRef >    m_types;\n-    ::std::vector< ::std::pair< ::std::string, TypeRef> >   m_assoc;\n-\n-    PathParams(PathParams&& x) = default;\n-    PathParams(const PathParams& x);\n-    PathParams() {}\n-    PathParams(::std::vector<LifetimeRef> lfts, ::std::vector<TypeRef> tys, ::std::vector<::std::pair<::std::string,TypeRef>> a):\n-        m_lifetimes(mv$(lfts)),\n-        m_types(mv$(tys)),\n-        m_assoc(mv$(a))\n-    {}\n-\n-    PathParams& operator=(PathParams&& x) = default;\n-    PathParams& operator=(const PathParams& x) = delete;\n-\n-    bool is_empty() const {\n-        return m_lifetimes.empty() && m_types.empty() && m_assoc.empty();\n-    }\n-\n-    Ordering ord(const PathParams& x) const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const PathParams& x);\n-};\n-\n-class PathNode\n-{\n-    ::std::string   m_name;\n-    PathParams  m_params;\n-public:\n-    PathNode() {}\n-    PathNode(::std::string name, PathParams args = {});\n-    const ::std::string& name() const { return m_name; }\n-\n-    const ::AST::PathParams& args() const { return m_params; }\n-          ::AST::PathParams& args()       { return m_params; }\n-\n-    Ordering ord(const PathNode& x) const;\n-    void print_pretty(::std::ostream& os, bool is_type_context) const;\n-\n-    bool operator==(const PathNode& x) const { return ord(x) == OrdEqual; }\n-    friend ::std::ostream& operator<<(::std::ostream& os, const PathNode& pn);\n-};\n-\n-class Path\n-{\n-public:\n-    TAGGED_UNION(Class, Invalid,\n-        (Invalid, struct {}),\n-        (Local, struct {   // Variable / Type param (resolved)\n-            ::std::string name;\n-            } ),\n-        (Relative, struct {    // General relative\n-            Ident::Hygiene hygiene;\n-            ::std::vector<PathNode> nodes;\n-            } ),\n-        (Self, struct {    // Module-relative\n-            ::std::vector<PathNode> nodes;\n-            } ),\n-        (Super, struct {   // Parent-relative\n-            unsigned int count; // Number of `super` keywords, must be >= 1\n-            ::std::vector<PathNode> nodes;\n-            } ),\n-        (Absolute, struct {    // Absolute\n-            ::std::string   crate;\n-            ::std::vector<PathNode> nodes;\n-            } ),\n-        (UFCS, struct {    // Type-relative\n-            ::std::unique_ptr<TypeRef> type;    // always non-null\n-            ::std::unique_ptr<Path> trait;   // nullptr = inherent, Invalid = unknown trait\n-            ::std::vector<PathNode> nodes;\n-            } )\n-        );\n-\n-public:\n-    Class   m_class;\n-\n-private:\n-    PathBinding m_binding;\n-public:\n-    virtual ~Path();\n-    // INVALID\n-    Path():\n-        m_class()\n-    {}\n-    Path(Path&&) = default;\n-    Path& operator=(AST::Path&& x) {\n-        m_class = mv$(x.m_class);\n-        m_binding = mv$(x.m_binding);\n-        //DEBUG(\"Path, \" << x);\n-        return *this;\n-    }\n-\n-    Path(const Path& x);\n-    Path& operator=(const AST::Path&) = delete;\n-\n-    // ABSOLUTE\n-    Path(::std::string crate, ::std::vector<PathNode> nodes):\n-        m_class( Class::make_Absolute({ mv$(crate), mv$(nodes)}) )\n-    {}\n-\n-    // UFCS\n-    struct TagUfcs {};\n-    Path(TagUfcs, TypeRef type, ::std::vector<PathNode> nodes={});\n-    Path(TagUfcs, TypeRef type, Path trait, ::std::vector<PathNode> nodes={});\n-\n-    // VARIABLE\n-    struct TagLocal {};\n-    Path(TagLocal, ::std::string name):\n-        m_class( Class::make_Local({ mv$(name) }) )\n-    {}\n-    Path(::std::string name):\n-        m_class( Class::make_Local({ mv$(name) }) )\n-    {}\n-\n-    // RELATIVE\n-    struct TagRelative {};\n-    Path(TagRelative, Ident::Hygiene hygiene, ::std::vector<PathNode> nodes):\n-        m_class( Class::make_Relative({ mv$(hygiene), mv$(nodes) }) )\n-    {}\n-    // SELF\n-    struct TagSelf {};\n-    Path(TagSelf, ::std::vector<PathNode> nodes):\n-        m_class( Class::make_Self({ mv$(nodes) }) )\n-    {}\n-    // SUPER\n-    struct TagSuper {};\n-    Path(TagSuper, unsigned int count, ::std::vector<PathNode> nodes):\n-        m_class( Class::make_Super({ count, mv$(nodes) }) )\n-    {}\n-\n-    //void set_crate(::std::string crate) {\n-    //    if( m_crate == \"\" ) {\n-    //        m_crate = crate;\n-    //        DEBUG(\"crate set to \" << m_crate);\n-    //    }\n-    //}\n-\n-\n-    Class::Tag class_tag() const {\n-        return m_class.tag();\n-    }\n-\n-    Path operator+(PathNode pn) const {\n-        Path tmp = Path(*this);\n-        tmp.nodes().push_back( mv$(pn) );\n-        return tmp;\n-    }\n-    Path operator+(const ::std::string& s) const {\n-        Path tmp = Path(*this);\n-        tmp.append(PathNode(s, {}));\n-        return tmp;\n-    }\n-    Path operator+(const Path& x) const {\n-        return Path(*this) += x;\n-    }\n-    Path& operator+=(const Path& x);\n-\n-    void append(PathNode node) {\n-        assert( !m_class.is_Invalid() );\n-        //if( m_class.is_Invalid() )\n-        //    m_class = Class::make_Relative({});\n-        nodes().push_back( mv$(node) );\n-        m_binding = PathBinding();\n-    }\n-\n-    bool is_trivial() const {\n-        TU_MATCH_DEF(Class, (m_class), (e),\n-        (\n-            return false;\n-            ),\n-        (Local,\n-            return true;\n-            ),\n-        (Relative,\n-            return e.nodes.size() == 1 && e.nodes[0].args().is_empty();\n-            )\n-        )\n-    }\n-\n-    bool is_valid() const { return !m_class.is_Invalid(); }\n-    bool is_absolute() const { return m_class.is_Absolute(); }\n-    bool is_relative() const { return m_class.is_Relative() || m_class.is_Super() || m_class.is_Self(); }\n-\n-    size_t size() const {\n-        TU_MATCH(Class, (m_class), (ent),\n-        (Invalid,  assert(!m_class.is_Invalid()); throw ::std::runtime_error(\"Path::nodes() on Invalid\"); ),\n-        (Local,    return 1;),\n-        (Relative, return ent.nodes.size();),\n-        (Self,     return ent.nodes.size();),\n-        (Super,    return ent.nodes.size();),\n-        (Absolute, return ent.nodes.size();),\n-        (UFCS,     return ent.nodes.size();)\n-        )\n-        throw ::std::runtime_error(\"Path::nodes() fell off\");\n-    }\n-    //const ::std::string& crate() const { return m_crate; }\n-\n-    bool is_concrete() const;\n-\n-    bool is_bound() const { return !m_binding.is_Unbound(); }\n-    const PathBinding& binding() const { return m_binding; }\n-    void bind_variable(unsigned int slot);\n-\n-    ::std::vector<PathNode>& nodes() {\n-        TU_MATCH(Class, (m_class), (ent),\n-        (Invalid,  assert(!m_class.is_Invalid()); throw ::std::runtime_error(\"Path::nodes() on Invalid\"); ),\n-        (Local,    assert(!m_class.is_Local()); throw ::std::runtime_error(\"Path::nodes() on Local\"); ),\n-        (Relative, return ent.nodes;),\n-        (Self,     return ent.nodes;),\n-        (Super,    return ent.nodes;),\n-        (Absolute, return ent.nodes;),\n-        (UFCS,     return ent.nodes;)\n-        )\n-        throw ::std::runtime_error(\"Path::nodes() fell off\");\n-    }\n-    const ::std::vector<PathNode>& nodes() const {\n-        return ((Path*)this)->nodes();\n-    }\n-\n-    PathNode& operator[](int idx) { if(idx>=0) return nodes()[idx]; else return nodes()[size()+idx]; }\n-    const PathNode& operator[](int idx) const { return (*(Path*)this)[idx]; }\n-\n-    Ordering ord(const Path& x) const;\n-    bool operator==(const Path& x) const { return ord(x) == OrdEqual; }\n-    bool operator!=(const Path& x) const { return ord(x) != OrdEqual; }\n-    bool operator<(const Path& x) const { return ord(x) != OrdLess; }\n-\n-    void print_pretty(::std::ostream& os, bool is_type_context, bool is_debug=false) const;\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Path& path);\n-private:\n-    static void resolve_args_nl(::std::vector<PathNode>& nodes, ::std::function<TypeRef(const char*)> fcn);\n-\n-    void check_param_counts(const GenericParams& params, bool expect_params, PathNode& node);\n-public:\n-    void bind_enum_var(const Enum& ent, const ::std::string& name, const ::std::vector<TypeRef>& args={});\n-    void bind_function(const Function& ent, const ::std::vector<TypeRef>& args={}) {\n-        (void)args;\n-        m_binding = PathBinding::make_Function({&ent});\n-    }\n-\n-    void bind(::AST::PathBinding pb) {\n-        m_binding = mv$(pb);\n-    }\n-};\n-\n-}   // namespace AST\n-\n-#endif"}, {"sha": "72087d95f3c7f86201603f0959d399a90b7b163d", "filename": "gcc/rust/mrustc_parser/ast/pattern.cpp", "status": "removed", "additions": 0, "deletions": 243, "changes": 243, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,243 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/pattern.cpp\n- * - AST::Pattern support/implementation code\n- */\n-#include \"../common.hpp\"\n-#include \"ast.hpp\"\n-#include \"pattern.hpp\"\n-\n-namespace AST {\n-\n-::std::ostream& operator<<(::std::ostream& os, const Pattern::Value& val)\n-{\n-    TU_MATCH(Pattern::Value, (val), (e),\n-    (Invalid,\n-        os << \"/*BAD PAT VAL*/\";\n-        ),\n-    (Integer,\n-        switch(e.type)\n-        {\n-        case CORETYPE_BOOL:\n-            os << (e.value ? \"true\" : \"false\");\n-            break;\n-        case CORETYPE_F32:\n-        case CORETYPE_F64:\n-            BUG(Span(), \"Hit F32/f64 in printing pattern literal\");\n-            break;\n-        default:\n-            os << e.value;\n-            break;\n-        }\n-        ),\n-    (Float,\n-        switch(e.type)\n-        {\n-        case CORETYPE_BOOL:\n-            os << (e.value ? \"true\" : \"false\");\n-            break;\n-        case CORETYPE_ANY:\n-        case CORETYPE_F32:\n-        case CORETYPE_F64:\n-            os << e.value;\n-            break;\n-        default:\n-            BUG(Span(), \"Hit integer in printing pattern literal\");\n-            break;\n-        }\n-        ),\n-    (String,\n-        os << \"\\\"\" << e << \"\\\"\";\n-        ),\n-    (ByteString,\n-        os << \"b\\\"\" << e.v << \"\\\"\";\n-        ),\n-    (Named,\n-        os << e;\n-        )\n-    )\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const Pattern::TuplePat& val)\n-{\n-    if( val.has_wildcard )\n-    {\n-        os << val.start;\n-        os << \".., \";\n-        os << val.end;\n-    }\n-    else\n-    {\n-        os << val.start;\n-        assert(val.end.size() == 0);\n-    }\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const PatternBinding& pb)\n-{\n-    if( pb.m_mutable )\n-        os << \"mut \";\n-    switch(pb.m_type)\n-    {\n-    case PatternBinding::Type::MOVE:    break;\n-    case PatternBinding::Type::REF:     os << \"ref \";   break;\n-    case PatternBinding::Type::MUTREF:  os << \"ref mut \";   break;\n-    }\n-    os << pb.m_name;\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const Pattern& pat)\n-{\n-    if( pat.m_binding.is_valid() ) {\n-        os << pat.m_binding << \" @ \";\n-    }\n-    TU_MATCH(Pattern::Data, (pat.m_data), (ent),\n-    (MaybeBind,\n-        os << ent.name << \"?\";\n-        ),\n-    (Macro,\n-        os << *ent.inv;\n-        ),\n-    (Any,\n-        os << \"_\";\n-        ),\n-    (Box,\n-        os << \"box \" << *ent.sub;\n-        ),\n-    (Ref,\n-        os << \"&\" << (ent.mut ? \"mut \" : \"\") << *ent.sub;\n-        ),\n-    (Value,\n-        os << ent.start;\n-        if( ! ent.end.is_Invalid() )\n-            os << \" ... \" << ent.end;\n-        ),\n-    (Tuple,\n-        os << \"(\" << ent << \")\";\n-        ),\n-    (StructTuple,\n-        os << ent.path << \" (\" << ent.tup_pat << \")\";\n-        ),\n-    (Struct,\n-        os << ent.path << \" {\" << ent.sub_patterns << \"}\";\n-        ),\n-    (Slice,\n-        os << \"[\";\n-        os << ent.sub_pats;\n-        os << \"]\";\n-        ),\n-    (SplitSlice,\n-        os << \"[\";\n-        bool needs_comma = false;\n-        if(ent.leading.size()) {\n-            os << ent.leading;\n-            needs_comma = true;\n-        }\n-\n-        if( needs_comma ) {\n-            os << \", \";\n-        }\n-        if( ent.extra_bind.is_valid() )\n-            os << ent.extra_bind;\n-        os << \"..\";\n-        needs_comma = true;\n-\n-        if(ent.trailing.size()) {\n-            if( needs_comma ) {\n-                os << \", \";\n-            }\n-            os << ent.trailing;\n-        }\n-        os << \"]\";\n-        )\n-    )\n-    return os;\n-}\n-\n-Pattern::~Pattern()\n-{\n-}\n-\n-AST::Pattern AST::Pattern::clone() const\n-{\n-    AST::Pattern    rv;\n-    rv.m_span = m_span;\n-    rv.m_binding = PatternBinding(m_binding);\n-\n-    struct H {\n-        static ::std::unique_ptr<Pattern> clone_sp(const ::std::unique_ptr<Pattern>& p) {\n-            return ::std::make_unique<Pattern>( p->clone() );\n-        }\n-        static ::std::vector<Pattern> clone_list(const ::std::vector<Pattern>& list) {\n-            ::std::vector<Pattern>  rv;\n-            rv.reserve(list.size());\n-            for(const auto& p : list)\n-                rv.push_back( p.clone() );\n-            return rv;\n-        }\n-        static TuplePat clone_tup(const TuplePat& p) {\n-            return TuplePat {\n-                H::clone_list(p.start),\n-                p.has_wildcard,\n-                H::clone_list(p.end)\n-                };\n-        }\n-        static AST::Pattern::Value clone_val(const AST::Pattern::Value& v) {\n-            TU_MATCH(::AST::Pattern::Value, (v), (e),\n-            (Invalid, return Value(e);),\n-            (Integer, return Value(e);),\n-            (Float, return Value(e);),\n-            (String, return Value(e);),\n-            (ByteString, return Value(e);),\n-            (Named, return Value::make_Named( AST::Path(e) );)\n-            )\n-            throw \"\";\n-        }\n-    };\n-\n-    TU_MATCH(Pattern::Data, (m_data), (e),\n-    (Any,\n-        rv.m_data = Data::make_Any(e);\n-        ),\n-    (MaybeBind,\n-        rv.m_data = Data::make_MaybeBind(e);\n-        ),\n-    (Macro,\n-        rv.m_data = Data::make_Macro({ ::std::make_unique<AST::MacroInvocation>( e.inv->clone() ) });\n-        ),\n-    (Box,\n-        rv.m_data = Data::make_Box({ H::clone_sp(e.sub) });\n-        ),\n-    (Ref,\n-        rv.m_data = Data::make_Ref({ e.mut, H::clone_sp(e.sub) });\n-        ),\n-    (Value,\n-        rv.m_data = Data::make_Value({ H::clone_val(e.start), H::clone_val(e.end) });\n-        ),\n-    (Tuple,\n-        rv.m_data = Data::make_Tuple( H::clone_tup(e) );\n-        ),\n-    (StructTuple,\n-        rv.m_data = Data::make_StructTuple({ ::AST::Path(e.path), H::clone_tup(e.tup_pat) });\n-        ),\n-    (Struct,\n-        ::std::vector< ::std::pair< ::std::string, Pattern> >   sps;\n-        for(const auto& sp : e.sub_patterns)\n-            sps.push_back( ::std::make_pair(sp.first, sp.second.clone()) );\n-        rv.m_data = Data::make_Struct({ ::AST::Path(e.path), mv$(sps) });\n-        ),\n-    (Slice,\n-        rv.m_data = Data::make_Slice({ H::clone_list(e.sub_pats) });\n-        ),\n-    (SplitSlice,\n-        rv.m_data = Data::make_SplitSlice({ H::clone_list(e.leading), e.extra_bind, H::clone_list(e.trailing) });\n-        )\n-    )\n-\n-    return rv;\n-}\n-\n-}   // namespace AST\n-"}, {"sha": "40cfa927b1f88b7df63f049a53ac61bd23e1a347", "filename": "gcc/rust/mrustc_parser/ast/pattern.hpp", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Fpattern.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,205 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/pattern.hpp\n- * - AST Pattern representation\n- */\n-\n-#ifndef _AST__PATTERN_HPP_INCLUDED_\n-#define _AST__PATTERN_HPP_INCLUDED_\n-\n-#include <vector>\n-#include <memory>\n-#include <string>\n-#include <tagged_union.hpp>\n-#include <ident.hpp>\n-#include \"path.hpp\"\n-\n-namespace AST {\n-\n-using ::std::unique_ptr;\n-using ::std::move;\n-class MacroInvocation;\n-\n-class PatternBinding\n-{\n-public:\n-    enum class Type {\n-        MOVE,\n-        REF,\n-        MUTREF,\n-    };\n-    Ident   m_name;\n-    Type    m_type;\n-    bool    m_mutable;\n-    unsigned int    m_slot;\n-\n-    PatternBinding():\n-        m_name({}, \"\"),\n-        m_type(Type::MOVE),\n-        m_mutable(false),\n-        m_slot( ~0u )\n-    {}\n-    PatternBinding(Ident name, Type ty, bool ismut):\n-        m_name(::std::move(name)),\n-        m_type(ty),\n-        m_mutable(ismut),\n-        m_slot( ~0u )\n-    {}\n-\n-    PatternBinding(PatternBinding&& x) = default;\n-    PatternBinding(const PatternBinding& x) = default;\n-    PatternBinding& operator=(PatternBinding&& x) = default;\n-\n-    bool is_valid() const { return m_name.name != \"\"; }\n-};\n-\n-class Pattern\n-{\n-public:\n-    TAGGED_UNION(Value, Invalid,\n-        (Invalid, struct {}),\n-        (Integer, struct {\n-            enum eCoreType type;\n-            uint64_t value; // Signed numbers are encoded as 2's complement\n-            }),\n-        (Float, struct {\n-            enum eCoreType type;\n-            double value;\n-            }),\n-        (String, ::std::string),\n-        (ByteString, struct { ::std::string v; }),\n-        (Named, Path)\n-        );\n-\n-    struct TuplePat {\n-        ::std::vector<Pattern>  start;\n-        bool has_wildcard;\n-        ::std::vector<Pattern>  end;\n-    };\n-\n-    TAGGED_UNION(Data, Any,\n-        (MaybeBind, struct { Ident name; } ),\n-        (Macro,     struct { unique_ptr<::AST::MacroInvocation> inv; } ),\n-        (Any,       struct { } ),\n-        (Box,       struct { unique_ptr<Pattern> sub; } ),\n-        (Ref,       struct { bool mut; unique_ptr<Pattern> sub; } ),\n-        (Value,     struct { Value start; Value end; } ),\n-        (Tuple,     TuplePat ),\n-        (StructTuple, struct { Path path; TuplePat tup_pat; } ),\n-        (Struct,    struct { Path path; ::std::vector< ::std::pair< ::std::string, Pattern> > sub_patterns; bool is_exhaustive; } ),\n-        (Slice,     struct { ::std::vector<Pattern> sub_pats; }),\n-        (SplitSlice, struct { ::std::vector<Pattern> leading; PatternBinding extra_bind; ::std::vector<Pattern> trailing; } )\n-        );\n-private:\n-    Span    m_span;\n-    PatternBinding  m_binding;\n-    Data m_data;\n-\n-public:\n-    virtual ~Pattern();\n-\n-    Pattern()\n-    {}\n-    Pattern(Pattern&&) = default;\n-    Pattern& operator=(Pattern&&) = default;\n-\n-    Pattern(Span sp, Data dat):\n-        m_span( mv$(sp) ),\n-        m_data( mv$(dat) )\n-    {};\n-\n-    struct TagMaybeBind {};\n-    Pattern(TagMaybeBind, Span sp, Ident name):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_MaybeBind({ mv$(name) }) )\n-    {}\n-\n-    struct TagMacro {};\n-    Pattern(TagMacro, Span sp, unique_ptr<::AST::MacroInvocation> inv):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Macro({ mv$(inv) }) )\n-    {}\n-\n-    struct TagBind {};\n-    Pattern(TagBind, Span sp, Ident name, PatternBinding::Type ty = PatternBinding::Type::MOVE, bool is_mut=false):\n-        m_span( mv$(sp) ),\n-        m_binding( PatternBinding(mv$(name), ty, is_mut) )\n-    {}\n-\n-    struct TagBox {};\n-    Pattern(TagBox, Span sp, Pattern sub):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Box({ unique_ptr<Pattern>(new Pattern(mv$(sub))) }) )\n-    {}\n-\n-    struct TagValue {};\n-    Pattern(TagValue, Span sp, Value val, Value end = Value()):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Value({ ::std::move(val), ::std::move(end) }) )\n-    {}\n-\n-\n-    struct TagReference {};\n-    Pattern(TagReference, Span sp, bool is_mutable, Pattern sub_pattern):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Ref( /*Data::Data_Ref */ {\n-            is_mutable, unique_ptr<Pattern>(new Pattern(::std::move(sub_pattern)))\n-            }) )\n-    {\n-    }\n-\n-    struct TagTuple {};\n-    Pattern(TagTuple, Span sp, ::std::vector<Pattern> pats):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Tuple( TuplePat { mv$(pats), false, {} } ) )\n-    {}\n-    Pattern(TagTuple, Span sp, TuplePat pat):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Tuple( mv$(pat) ) )\n-    {}\n-\n-    struct TagNamedTuple {};\n-    Pattern(TagNamedTuple, Span sp, Path path, ::std::vector<Pattern> pats):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_StructTuple( { mv$(path), TuplePat { mv$(pats), false, {} } } ) )\n-    {}\n-    Pattern(TagNamedTuple, Span sp, Path path, TuplePat pat = TuplePat { {}, false, {} }):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_StructTuple( { ::std::move(path), ::std::move(pat) } ) )\n-    {}\n-\n-    struct TagStruct {};\n-    Pattern(TagStruct, Span sp, Path path, ::std::vector< ::std::pair< ::std::string,Pattern> > sub_patterns, bool is_exhaustive):\n-        m_span( mv$(sp) ),\n-        m_data( Data::make_Struct( { ::std::move(path), ::std::move(sub_patterns), is_exhaustive } ) )\n-    {}\n-\n-    // Mutators\n-    void set_bind(Ident name, PatternBinding::Type type, bool is_mut) {\n-        m_binding = PatternBinding(mv$(name), type, is_mut);\n-    }\n-\n-\n-    const Span& span() const { return m_span; }\n-\n-    Pattern clone() const;\n-\n-    // Accessors\n-          PatternBinding& binding()       { return m_binding; }\n-    const PatternBinding& binding() const { return m_binding; }\n-          Data& data()       { return m_data; }\n-    const Data& data() const { return m_data; }\n-          Path& path()       { return m_data.as_StructTuple().path; }\n-    const Path& path() const { return m_data.as_StructTuple().path; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Pattern& pat);\n-};\n-\n-extern ::std::ostream& operator<<(::std::ostream& os, const Pattern::Value& val);\n-extern ::std::ostream& operator<<(::std::ostream& os, const Pattern::TuplePat& val);\n-\n-};\n-\n-#endif"}, {"sha": "98bc6ee13bfdf9cdf699a85633e80504668c8c46", "filename": "gcc/rust/mrustc_parser/ast/types.cpp", "status": "removed", "additions": 0, "deletions": 334, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,334 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * types.cpp\n- * - Backing code for the TypeRef class\n- *\n- * Handles a chunk of type resolution (merging) and matching/comparing types\n- */\n-#include \"types.hpp\"\n-#include \"ast/ast.hpp\"\n-#include <ast/crate.hpp>\n-#include <ast/expr.hpp>\n-\n-/// Mappings from internal type names to the core type enum\n-static const struct {\n-    const char* name;\n-    enum eCoreType  type;\n-} CORETYPES[] = {\n-    // NOTE: Sorted\n-    {\"_\", CORETYPE_ANY},\n-    {\"bool\", CORETYPE_BOOL},\n-    {\"char\", CORETYPE_CHAR},\n-    {\"f32\", CORETYPE_F32},\n-    {\"f64\", CORETYPE_F64},\n-    {\"i128\", CORETYPE_I128},\n-    {\"i16\", CORETYPE_I16},\n-    {\"i32\", CORETYPE_I32},\n-    {\"i64\", CORETYPE_I64},\n-    {\"i8\", CORETYPE_I8},\n-    {\"int\", CORETYPE_INT},\n-    {\"isize\", CORETYPE_INT},\n-    {\"str\", CORETYPE_STR},\n-    {\"u128\", CORETYPE_U128},\n-    {\"u16\", CORETYPE_U16},\n-    {\"u32\", CORETYPE_U32},\n-    {\"u64\", CORETYPE_U64},\n-    {\"u8\",  CORETYPE_U8},\n-    {\"uint\", CORETYPE_UINT},\n-    {\"usize\", CORETYPE_UINT},\n-};\n-\n-enum eCoreType coretype_fromstring(const ::std::string& name)\n-{\n-    for(unsigned int i = 0; i < sizeof(CORETYPES)/sizeof(CORETYPES[0]); i ++)\n-    {\n-        if( name < CORETYPES[i].name )\n-            break;\n-        if( name == CORETYPES[i].name )\n-            return CORETYPES[i].type;\n-    }\n-    return CORETYPE_INVAL;\n-}\n-\n-const char* coretype_name(const eCoreType ct ) {\n-    switch(ct)\n-    {\n-    case CORETYPE_INVAL:return \"INVAL\";\n-    case CORETYPE_ANY:  return \"_\";\n-    case CORETYPE_CHAR: return \"char\";\n-    case CORETYPE_STR:  return \"str\";\n-    case CORETYPE_BOOL: return \"bool\";\n-    case CORETYPE_UINT: return \"usize\";\n-    case CORETYPE_INT:  return \"isize\";\n-    case CORETYPE_U8:   return \"u8\";\n-    case CORETYPE_I8:   return \"i8\";\n-    case CORETYPE_U16:  return \"u16\";\n-    case CORETYPE_I16:  return \"i16\";\n-    case CORETYPE_U32:  return \"u32\";\n-    case CORETYPE_I32:  return \"i32\";\n-    case CORETYPE_U64:  return \"u64\";\n-    case CORETYPE_I64:  return \"i64\";\n-    case CORETYPE_U128: return \"u128\";\n-    case CORETYPE_I128: return \"i128\";\n-    case CORETYPE_F32:  return \"f32\";\n-    case CORETYPE_F64:  return \"f64\";\n-    }\n-    DEBUG(\"Unknown core type?! \" << ct);\n-    return \"NFI\";\n-}\n-\n-Type_Function::Type_Function(const Type_Function& other):\n-    is_unsafe(other.is_unsafe),\n-    m_abi(other.m_abi),\n-    m_rettype( box$( other.m_rettype->clone() ) )\n-{\n-    for( const auto& at : other.m_arg_types )\n-        m_arg_types.push_back( at.clone() );\n-}\n-\n-Ordering Type_Function::ord(const Type_Function& x) const\n-{\n-    Ordering rv;\n-\n-    rv = ::ord(m_abi, x.m_abi);\n-    if(rv != OrdEqual)  return rv;\n-    rv = ::ord(m_arg_types, x.m_arg_types);\n-    if(rv != OrdEqual)  return rv;\n-    return (*m_rettype).ord( *x.m_rettype );\n-}\n-\n-TypeRef::~TypeRef()\n-{\n-}\n-\n-TypeRef TypeRef::clone() const\n-{\n-    struct H {\n-        static ::std::vector< ::TypeRef> clone_ty_vec(const ::std::vector<TypeRef>& x) {\n-            ::std::vector<TypeRef>  rv;\n-            rv.reserve(x.size());\n-            for(const auto& t : x)\n-                rv.push_back( t.clone() );\n-            return rv;\n-        }\n-    };\n-    switch( m_data.tag() )\n-    {\n-    case TypeData::TAGDEAD: assert(!\"Copying a destructed type\");\n-    #define _COPY(VAR)  case TypeData::TAG_##VAR: return TypeRef(m_span, TypeData::make_##VAR(m_data.as_##VAR()) ); break;\n-    #define _CLONE(VAR, ...)    case TypeData::TAG_##VAR: { auto& old = m_data.as_##VAR(); return TypeRef(m_span, TypeData::make_##VAR(__VA_ARGS__) ); } break;\n-    _COPY(None)\n-    _COPY(Any)\n-    _COPY(Bang)\n-    _CLONE(Macro, { old.inv.clone() })\n-    //case TypeData::TAG_Macro:   assert( !\"Copying an unexpanded type macro\" );\n-    _COPY(Unit)\n-    _COPY(Primitive)\n-    _COPY(Function)\n-    _CLONE(Tuple, { H::clone_ty_vec(old.inner_types) })\n-    _CLONE(Borrow,  { AST::LifetimeRef(old.lifetime), old.is_mut, box$(old.inner->clone()) })\n-    _CLONE(Pointer, { old.is_mut, box$(old.inner->clone()) })\n-    _CLONE(Array, { box$(old.inner->clone()), old.size })\n-    _COPY(Generic)\n-    _COPY(Path)\n-    _COPY(TraitObject)\n-    _COPY(ErasedType)\n-    #undef _COPY\n-    #undef _CLONE\n-    }\n-    throw \"\";\n-}\n-\n-Ordering Type_TraitPath::ord(const Type_TraitPath& x) const\n-{\n-    Ordering    rv;\n-\n-    rv = ::ord( this->path, x.path );\n-    if(rv != OrdEqual)  return rv;\n-\n-    return rv;\n-}\n-Ordering TypeRef::ord(const TypeRef& x) const\n-{\n-    Ordering    rv;\n-\n-    rv = ::ord( (unsigned)m_data.tag(), (unsigned)x.m_data.tag() );\n-    if(rv != OrdEqual)  return rv;\n-\n-    TU_MATCH(TypeData, (m_data, x.m_data), (ent, x_ent),\n-    (None, return OrdEqual;),\n-    (Macro, throw CompileError::BugCheck(\"TypeRef::ord - unexpanded macro\");),\n-    (Any,  return OrdEqual;),\n-    (Unit, return OrdEqual;),\n-    (Bang, return OrdEqual;),\n-    (Primitive,\n-        return ::ord( (unsigned)ent.core_type, (unsigned)x_ent.core_type );\n-        ),\n-    (Function,\n-        return ent.info.ord( x_ent.info );\n-        ),\n-    (Tuple,\n-        return ::ord(ent.inner_types, x_ent.inner_types);\n-        ),\n-    (Borrow,\n-        rv = ::ord(ent.is_mut, x_ent.is_mut);\n-        if(rv != OrdEqual)  return rv;\n-        return (*ent.inner).ord(*x_ent.inner);\n-        ),\n-    (Pointer,\n-        rv = ::ord(ent.is_mut, x_ent.is_mut);\n-        if(rv != OrdEqual)  return rv;\n-        return (*ent.inner).ord(*x_ent.inner);\n-        ),\n-    (Array,\n-        rv = (*ent.inner).ord( *x_ent.inner );\n-        if(rv != OrdEqual)  return rv;\n-        if(ent.size.get())\n-        {\n-            throw ::std::runtime_error(\"TODO: Sized array comparisons\");\n-        }\n-        return OrdEqual;\n-        ),\n-    (Generic,\n-        return ::ord(ent.name, x_ent.name);\n-        ),\n-    (Path,\n-        return ent.path.ord( x_ent.path );\n-        ),\n-    (TraitObject,\n-        return ::ord(ent.traits, x_ent.traits);\n-        ),\n-    (ErasedType,\n-        return ::ord(ent.traits, x_ent.traits);\n-        )\n-    )\n-    throw ::std::runtime_error(FMT(\"BUGCHECK - Unhandled TypeRef class '\" << m_data.tag() << \"'\"));\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const eCoreType ct) {\n-    return os << coretype_name(ct);\n-}\n-\n-void TypeRef::print(::std::ostream& os, bool is_debug/*=false*/) const\n-{\n-    //os << \"TypeRef(\";\n-    #define _(VAR, ...) case TypeData::TAG_##VAR: { const auto &ent = this->m_data.as_##VAR(); (void)&ent; __VA_ARGS__ } break;\n-    switch(this->m_data.tag())\n-    {\n-    case TypeData::TAGDEAD: throw \"\";\n-    _(None,\n-        os << \"!!\";\n-        )\n-    _(Any,\n-        os << \"_\";\n-        )\n-    _(Bang,\n-        os << \"!\";\n-        )\n-    _(Macro,\n-        os << ent.inv;\n-        )\n-    _(Unit,\n-        os << \"()\";\n-        )\n-    _(Primitive,\n-        os << ent.core_type;\n-        )\n-    _(Function,\n-        if( ent.info.m_abi != \"\" )\n-            os << \"extern \\\"\" << ent.info.m_abi << \"\\\" \";\n-        os << \"fn (\";\n-        for( const auto& arg : ent.info.m_arg_types )\n-        {\n-            arg.print(os, is_debug);\n-            os << \", \";\n-        }\n-        os << \") -> \" << *ent.info.m_rettype;\n-        )\n-    _(Tuple,\n-        os << \"( \";\n-        for( const auto& it : ent.inner_types )\n-        {\n-            it.print(os, is_debug);\n-            os << \", \";\n-        }\n-        os << \")\";\n-        )\n-    _(Borrow,\n-        os << \"&\" << (ent.is_mut ? \"mut \" : \"\");\n-        ent.inner->print(os, is_debug);\n-        )\n-    _(Pointer,\n-        os << \"*\" << (ent.is_mut ? \"mut\" : \"const\");\n-        ent.inner->print(os, is_debug);\n-        )\n-    _(Array,\n-        os << \"[\";\n-        ent.inner->print(os, is_debug);\n-        if( ent.size.get() )\n-            os << \"; \" << *ent.size;\n-        os << \"]\";\n-        )\n-    _(Generic,\n-        if(is_debug)\n-            os << \"/* arg */ \";\n-        os << ent.name;\n-        if(is_debug)\n-            os << \"/*\"<<ent.index<<\"*/\";\n-        )\n-    _(Path,\n-        ent.path.print_pretty(os, true, is_debug);\n-        )\n-    _(TraitObject,\n-        os << \"(\";\n-        for( const auto& it : ent.traits ) {\n-            if( &it != &ent.traits.front() )\n-                os << \"+\";\n-            os << it.hrbs;\n-            it.path.print_pretty(os, true, is_debug);\n-        }\n-        os << \")\";\n-        )\n-    _(ErasedType,\n-        os << \"impl \";\n-        for( const auto& it : ent.traits ) {\n-            if( &it != &ent.traits.front() )\n-                os << \"+\";\n-            os << it.hrbs;\n-            it.path.print_pretty(os, true, is_debug);\n-        }\n-        os << \"\";\n-        )\n-    }\n-    #undef _\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const TypeRef& tr) {\n-    tr.print(os, true);\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const PrettyPrintType& x) {\n-    x.m_type.print(os, false);\n-    return os;\n-}\n-\n-namespace AST {\n-    ::std::ostream& operator<<(::std::ostream& os, const LifetimeRef& x) {\n-        if( x.m_binding == LifetimeRef::BINDING_STATIC ) {\n-            os << \"'static\";\n-        }\n-        else if( x.m_binding == LifetimeRef::BINDING_INFER ) {\n-            os << \"'_\";\n-        }\n-        else {\n-            os << \"'\" << x.m_name;\n-            if( x.m_binding != LifetimeRef::BINDING_UNBOUND ) {\n-                os << \"/*\" << x.m_binding << \"*/\";\n-            }\n-        }\n-        return os;\n-    }\n-}\n-"}, {"sha": "af07ba2dc6f777c8b81715830516f09b2060aa5e", "filename": "gcc/rust/mrustc_parser/ast/types.hpp", "status": "removed", "additions": 0, "deletions": 354, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fast%2Ftypes.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,354 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * ast/types.hpp\n- * - AST Type reference (and helpers)\n- */\n-#ifndef TYPES_HPP_INCLUDED\n-#define TYPES_HPP_INCLUDED\n-\n-#include <memory>\n-\n-#include \"../common.hpp\"\n-#include \"coretypes.hpp\"\n-#include \"ast/path.hpp\"\n-#include \"ast/macro.hpp\"\n-#include <tagged_union.hpp>\n-\n-namespace AST {\n-class ExprNode;\n-class Expr;\n-class LifetimeParam;\n-}\n-\n-namespace AST {\n-\n-    // Defined here for dependency reasons\n-    class HigherRankedBounds\n-    {\n-    public:\n-        ::std::vector<LifetimeParam>    m_lifetimes;\n-        //::std::vector<TypeParam>    m_types;\n-        //::std::vector<GenericBound>    m_bounds;\n-\n-        bool empty() const {\n-            return m_lifetimes.empty();\n-        }\n-\n-        friend ::std::ostream& operator<<(::std::ostream& os, const HigherRankedBounds& x);\n-    };\n-\n-    class LifetimeRef\n-    {\n-        static const uint16_t BINDING_STATIC = 0xFFFF;\n-        static const uint16_t BINDING_UNBOUND = 0xFFFE;\n-        static const uint16_t BINDING_INFER = 0xFFFD;\n-\n-        Ident   m_name;\n-        uint16_t  m_binding;\n-\n-        LifetimeRef(Ident name, uint32_t binding):\n-            m_name( ::std::move(name) ),\n-            m_binding( binding )\n-        {\n-        }\n-    public:\n-        LifetimeRef():\n-            LifetimeRef(\"\", BINDING_INFER)\n-        {\n-        }\n-        LifetimeRef(Ident name):\n-            LifetimeRef(::std::move(name), BINDING_UNBOUND)\n-        {\n-        }\n-        static LifetimeRef new_static() {\n-            return LifetimeRef(\"static\", BINDING_STATIC);\n-        }\n-\n-        void set_binding(uint16_t b) { assert(m_binding == BINDING_UNBOUND); m_binding = b; }\n-        bool is_unbound() const { return m_binding == BINDING_UNBOUND; }\n-        bool is_infer() const { return m_binding == BINDING_INFER; }\n-\n-        const Ident& name() const { return m_name; }\n-        Ordering ord(const LifetimeRef& x) const { return ::ord(m_name.name, x.m_name.name); }\n-        bool operator==(const LifetimeRef& x) const { return ord(x) == OrdEqual; }\n-        bool operator!=(const LifetimeRef& x) const { return ord(x) != OrdEqual; }\n-        bool operator<(const LifetimeRef& x) const { return ord(x) == OrdLess; };\n-\n-        friend ::std::ostream& operator<<(::std::ostream& os, const LifetimeRef& x);\n-    };\n-}\n-\n-class PrettyPrintType\n-{\n-    const TypeRef&  m_type;\n-public:\n-    PrettyPrintType(const TypeRef& ty):\n-        m_type(ty)\n-    {}\n-\n-    void print(::std::ostream& os) const;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const PrettyPrintType& v);\n-};\n-\n-struct TypeArgRef\n-{\n-    ::std::string   name;\n-    unsigned int    level;\n-    const AST::GenericParams*  params;\n-};\n-\n-struct Type_Function\n-{\n-    AST::HigherRankedBounds hrbs;\n-    bool    is_unsafe;\n-    ::std::string   m_abi;\n-    ::std::unique_ptr<TypeRef>  m_rettype;\n-    ::std::vector<TypeRef>  m_arg_types;\n-    bool is_variadic;\n-\n-    Type_Function() {}\n-    Type_Function(AST::HigherRankedBounds hrbs, bool is_unsafe, ::std::string abi, ::std::unique_ptr<TypeRef> ret, ::std::vector<TypeRef> args, bool is_variadic):\n-        hrbs(mv$(hrbs)),\n-        is_unsafe(is_unsafe),\n-        m_abi(mv$(abi)),\n-        m_rettype(mv$(ret)),\n-        m_arg_types(mv$(args)),\n-        is_variadic(is_variadic)\n-    {}\n-    Type_Function(Type_Function&& other) = default;\n-    Type_Function(const Type_Function& other);\n-\n-    Ordering ord(const Type_Function& x) const;\n-};\n-\n-struct Type_TraitPath\n-{\n-    AST::HigherRankedBounds hrbs;\n-    AST::Path   path;\n-\n-    Ordering ord(const Type_TraitPath& x) const;\n-};\n-\n-TAGGED_UNION(TypeData, None,\n-    (None, struct { }),\n-    (Any,  struct { }),\n-    (Bang, struct { }),\n-    (Unit, struct { }),\n-    (Macro, struct {\n-        ::AST::MacroInvocation inv;\n-        }),\n-    (Primitive, struct {\n-        enum eCoreType core_type;\n-        }),\n-    (Function, struct {\n-        Type_Function   info;\n-        }),\n-    (Tuple, struct {\n-        ::std::vector<TypeRef> inner_types;\n-        }),\n-    (Borrow, struct {\n-        AST::LifetimeRef lifetime;\n-        bool is_mut;\n-        ::std::unique_ptr<TypeRef> inner;\n-        }),\n-    (Pointer, struct {\n-        bool is_mut;\n-        ::std::unique_ptr<TypeRef> inner;\n-        }),\n-    (Array, struct {\n-        ::std::unique_ptr<TypeRef> inner;\n-        ::std::shared_ptr<AST::ExprNode> size;\n-        }),\n-    (Generic, struct {\n-        ::std::string name;\n-        unsigned int index;\n-        }),\n-    (Path, struct {\n-        AST::Path path;\n-        }),\n-    (TraitObject, struct {\n-        ::std::vector<Type_TraitPath>   traits;\n-        ::std::vector<AST::LifetimeRef> lifetimes;\n-        }),\n-    (ErasedType, struct {\n-        ::std::vector<Type_TraitPath>   traits;\n-        ::std::vector<AST::LifetimeRef> lifetimes;\n-        })\n-    );\n-\n-/// A type\n-class TypeRef\n-{\n-    Span    m_span;\n-public:\n-    TypeData    m_data;\n-\n-    ~TypeRef();\n-\n-    TypeRef(TypeRef&& other) = default;\n-    TypeRef& operator=(TypeRef&& other) = default;\n-\n-    #if 1\n-    TypeRef(const TypeRef& other) = delete;\n-    TypeRef& operator=(const TypeRef& other) = delete;\n-    #else\n-    TypeRef(const TypeRef& other): m_span(other.m_span) {\n-        *this = other.clone();\n-    }\n-    TypeRef& operator=(const TypeRef& other) {\n-        m_data = mv$(other.clone().m_data);\n-        return *this;\n-    }\n-    #endif\n-\n-    TypeRef(Span sp):\n-        m_span( mv$(sp) ),\n-        m_data( TypeData::make_Any({}) )\n-    {}\n-    TypeRef(Span sp, TypeData data):\n-        m_span( mv$(sp) ),\n-        m_data( mv$(data) )\n-    {}\n-\n-    struct TagInvalid {};\n-    TypeRef(TagInvalid, Span sp):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_None({}))\n-    {}\n-\n-    struct TagMacro {};\n-    TypeRef(TagMacro, ::AST::MacroInvocation inv):\n-        m_span(inv.span()),\n-        m_data(TypeData::make_Macro({mv$(inv)}))\n-    {}\n-\n-    struct TagUnit {};  // unit maps to a zero-length tuple, just easier to type\n-    TypeRef(TagUnit, Span sp):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Unit({}))\n-    {}\n-\n-    struct TagPrimitive {};\n-    TypeRef(TagPrimitive, Span sp, enum eCoreType type):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Primitive({type}))\n-    {}\n-    TypeRef(Span sp, enum eCoreType type):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Primitive({type}))\n-    {}\n-\n-    struct TagTuple {};\n-    TypeRef(TagTuple , Span sp, ::std::vector<TypeRef> inner_types):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Tuple({::std::move(inner_types)}))\n-    {}\n-    struct TagFunction {};\n-    TypeRef(TagFunction, Span sp, AST::HigherRankedBounds hrbs, bool is_unsafe, ::std::string abi, ::std::vector<TypeRef> args, bool is_variadic, TypeRef ret):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Function({ Type_Function( mv$(hrbs), is_unsafe, abi, box$(ret), mv$(args), is_variadic ) }))\n-    {}\n-\n-    struct TagReference {};\n-    TypeRef(TagReference , Span sp, AST::LifetimeRef lft, bool is_mut, TypeRef inner_type):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Borrow({ ::std::move(lft), is_mut, ::make_unique_ptr(mv$(inner_type)) }))\n-    {}\n-    struct TagPointer {};\n-    TypeRef(TagPointer , Span sp, bool is_mut, TypeRef inner_type):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Pointer({ is_mut, ::make_unique_ptr(mv$(inner_type)) }))\n-    {}\n-    struct TagSizedArray {};\n-    TypeRef(TagSizedArray , Span sp, TypeRef inner_type, ::std::shared_ptr<AST::ExprNode> size):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Array({ ::make_unique_ptr(mv$(inner_type)), mv$(size) }))\n-    {}\n-    struct TagUnsizedArray {};\n-    TypeRef(TagUnsizedArray , Span sp, TypeRef inner_type):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Array({ ::make_unique_ptr(mv$(inner_type)), ::std::shared_ptr<AST::ExprNode>() }))\n-    {}\n-\n-    struct TagArg {};\n-    TypeRef(TagArg, Span sp, ::std::string name, unsigned int binding = ~0u):\n-        m_span( mv$(sp) ),\n-        m_data(TypeData::make_Generic({ name, binding }))\n-    {}\n-    TypeRef(Span sp, ::std::string name, unsigned int binding = ~0u):\n-        TypeRef(TagArg(), mv$(sp), mv$(name), binding)\n-    {}\n-\n-    struct TagPath {};\n-    TypeRef(TagPath, Span sp, AST::Path path):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_Path({ ::std::move(path) }))\n-    {}\n-    TypeRef(Span sp, AST::Path path):\n-        TypeRef(TagPath(), mv$(sp), mv$(path))\n-    {}\n-\n-    TypeRef( Span sp, ::std::vector<Type_TraitPath> traits, ::std::vector<AST::LifetimeRef> lifetimes ):\n-        m_span(mv$(sp)),\n-        m_data(TypeData::make_TraitObject({ ::std::move(traits), mv$(lifetimes) }))\n-    {}\n-\n-\n-    const Span& span() const { return m_span; }\n-\n-    bool is_valid() const { return ! m_data.is_None(); }\n-\n-    bool is_unbounded() const { return m_data.is_Any(); }\n-    bool is_wildcard() const { return m_data.is_Any(); }\n-\n-    bool is_unit() const { return m_data.is_Unit(); }\n-    bool is_primitive() const { return m_data.is_Primitive(); }\n-\n-    bool is_path() const { return m_data.is_Path(); }\n-    const AST::Path& path() const { return m_data.as_Path().path; }\n-    AST::Path& path() { return m_data.as_Path().path; }\n-\n-    bool is_type_param() const { return m_data.is_Generic(); }\n-    const ::std::string& type_param() const { return m_data.as_Generic().name; }\n-\n-    bool is_reference() const { return m_data.is_Borrow(); }\n-    bool is_pointer() const { return m_data.is_Pointer(); }\n-    bool is_tuple() const { return m_data.is_Tuple(); }\n-\n-    TypeRef clone() const;\n-\n-    const TypeRef& inner_type() const {\n-        TU_MATCH_DEF(TypeData, (m_data), (e),\n-        ( throw ::std::runtime_error(\"Called inner_type on non-wrapper\"); ),\n-        (Borrow,  return *e.inner; ),\n-        (Pointer, return *e.inner; ),\n-        (Array,   return *e.inner; )\n-        )\n-    }\n-    TypeRef& inner_type() {\n-        TU_MATCH_DEF(TypeData, (m_data), (e),\n-        ( throw ::std::runtime_error(\"Called inner_type on non-wrapper\"); ),\n-        (Borrow,  return *e.inner; ),\n-        (Pointer, return *e.inner; ),\n-        (Array,   return *e.inner; )\n-        )\n-    }\n-\n-    Ordering ord(const TypeRef& x) const;\n-    bool operator==(const TypeRef& x) const { return ord(x) == OrdEqual; }\n-    bool operator!=(const TypeRef& x) const { return ord(x) != OrdEqual; }\n-    bool operator<(const TypeRef& x) const { return ord(x) == OrdLess; };\n-\n-    void print(::std::ostream& os, bool is_debug=false) const;\n-\n-    PrettyPrintType print_pretty() const { return PrettyPrintType(*this); }\n-\n-    friend class PrettyPrintType;\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const TypeRef& tr);\n-};\n-\n-#endif // TYPES_HPP_INCLUDED"}, {"sha": "31a212ad3c31c5e2de2dac1d0a97be0e025b85e2", "filename": "gcc/rust/mrustc_parser/gcc-interface-test/gcc-interface.cc", "status": "removed", "additions": 0, "deletions": 434, "changes": 434, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Fgcc-interface.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,434 +0,0 @@\n-// gcc interface main - do stuff here\n-\n-#include \"common/common-target.h\"\n-#include \"config.h\"\n-#include \"convert.h\"\n-#include \"coretypes.h\"\n-#include \"debug.h\"\n-#include \"diagnostic.h\"\n-#include \"fold-const.h\"\n-#include \"gimple-expr.h\"\n-#include \"gimplify.h\"\n-#include \"langhooks-def.h\"\n-#include \"langhooks.h\"\n-#include \"opts.h\"\n-#include \"stor-layout.h\"\n-#include \"system.h\"\n-#include \"target.h\"\n-#include \"tree.h\"\n-\n-#include <mpfr.h>\n-\n-#include \"rust-c-interface.h\"\n-\n-/* Language-dependent contents of a type.  */\n-// seems to be a \"gengtype\" of some kind\n-struct GTY(()) lang_type {\n-    char dummy;\n-};\n-\n-/* Language-dependent contents of a decl.  */\n-\n-struct GTY(()) lang_decl {\n-    char dummy;\n-};\n-\n-/* Language-dependent contents of an identifier.  This must include a\n-   tree_identifier.  */\n-\n-struct GTY(()) lang_identifier {\n-    struct tree_identifier common;\n-};\n-\n-/* The resulting tree type.  */\n-union GTY((desc(\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-           chain_next(\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), TS_COMMON) ? \n-           ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n-  lang_tree_node {\n-    union tree_node GTY((tag(\"0\"),\n-                         desc(\"tree_node_structure (&%h)\"))) generic;\n-    struct lang_identifier GTY((tag(\"1\"))) identifier;\n-};\n-\n-/* We don't use language_function.  */\n-struct GTY(()) language_function {\n-    int dummy;\n-};\n-\n-/* Option information we need to pass to rust_create_grs.  */\n-\n-static const char* rust_pkgpath = NULL;\n-static const char* rust_prefix = NULL;\n-static const char* rust_relative_import_path = NULL;\n-static const char* rust_c_header = NULL;\n-\n-/* Language hooks.  */\n-\n-static bool grs_langhook_init(void) {\n-    build_common_tree_nodes(false);\n-\n-    /* I don't know why this has to be done explicitly.  */\n-    void_list_node = build_tree_list(NULL_TREE, void_type_node);\n-\n-    // not currently relevant\n-    /* We must create the grs IR after calling build_common_tree_nodes\n-     (because Gorust::define_builtin_function_trees refers indirectly\n-     to, e.g., unsigned_char_type_node) but before calling\n-     build_common_builtin_nodes (because it calls, indirectly,\n-     rust_type_for_size).  */\n-    /* struct rust_create_grs_args args;\n-    args.int_type_size = INT_TYPE_SIZE;\n-    args.pointer_size = POINTER_SIZE;\n-    args.pkgpath = rust_pkgpath;\n-    args.prefix = rust_prefix;\n-    args.relative_import_path = rust_relative_import_path;\n-    args.c_header = rust_c_header;\n-    args.check_divide_by_zero = rust_check_divide_zero;\n-    args.check_divide_overflow = rust_check_divide_overflow;\n-    args.compiling_runtime = rust_compiling_runtime;\n-    args.debug_escape_level = rust_debug_escape_level;\n-    args.debug_escape_hash = rust_debug_escape_hash;\n-    args.nil_check_size_threshold = TARGET_AIX ? -1 : 4096;\n-    args.debug_optimization = rust_debug_optimization;\n-    args.linemap = rust_get_linemap();\n-    args.backend = rust_get_backend();\n-    rust_create_grs(&args);*/\n-\n-    build_common_builtin_nodes();\n-\n-    /* The default precision for floating point numbers.  This is used\n-     for floating point constants with abstract type.  This may\n-     eventually be controllable by a command line option.  */\n-    mpfr_set_default_prec(128);\n-\n-    /* Rust uses exceptions.  */\n-    using_eh_for_cleanups();\n-\n-    // maybe get rid of this?\n-    rdot_init();\n-\n-    return true;\n-}\n-\n-/* Initialize the options structure before parsing options.  */\n-static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n-    /* Go says that signed overflow is precisely defined.  */\n-    opts->x_flag_wrapv = 1;\n-\n-    /* We default to using strict aliasing, since Go pointers are safe.\n-     This is turned off for code that imports the \"unsafe\" package,\n-     because using unsafe.pointer violates C style aliasing\n-     requirements.  */\n-    opts->x_flag_strict_aliasing = 1;\n-\n-    /* Default to avoiding range issues for complex multiply and\n-     divide.  */\n-    opts->x_flag_complex_method = 2;\n-\n-    /* The builtin math functions should not set errno.  */\n-    opts->x_flag_errno_math = 0;\n-    opts->frontend_set_flag_errno_math = true;\n-\n-    /* Turn on stack splitting if possible? */\n-    // no definition for that anymore, apparently\n-    /* if (targetm_common.supports_split_stack(false, opts))\n-        opts->x_flag_split_stack = 1; */\n-\n-    /* Exceptions are used to handle recovering from panics.  */\n-    opts->x_flag_exceptions = 1;\n-    opts->x_flag_non_call_exceptions = 1;\n-\n-    // nope, don't need this because no gc\n-    /* We need to keep pointers live for the garbage collector.  */\n-    //opts->x_flag_keep_gc_roots_live = 1;\n-\n-    /* Go programs expect runtime.Callers to work, and that uses\n-     libbacktrace that uses debug info.  Set the debug info level to 1\n-     by default.  In post_options we will set the debug type if the\n-     debug info level was not set back to 0 on the command line.  */\n-    opts->x_debug_info_level = DINFO_LEVEL_TERSE;\n-}\n-\n-// doesn't seem to be needed, currently\n-/*  Infrastructure for a vector of char * pointers.  */\n-/* typedef const char* rust_char_p;*/\n-\n-/* The list of directories to search after all the Go specific\n-   directories have been searched.  */\n-/* static vec<rust_char_p> rust_search_dirs;*/\n-\n-/* Handle grs specific options.  Return 0 if we didn't do anything.  */\n-static bool grs_langhook_handle_option(size_t scode, const char* arg ATTRIBUTE_UNUSED, \n-    int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED, location_t loc ATTRIBUTE_UNUSED, \n-    const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n-    enum opt_code code = (enum opt_code)scode;\n-    bool ret = true;\n-\n-    // ignore options...\n-    switch (code) {\n-\n-        default:\n-            /* Just return 1 to indicate that the option is valid.  */\n-            break;\n-    }\n-\n-    return ret;\n-}\n-\n-/* Run after parsing options.  */\n-static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n-\n-    if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n-        flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n-\n-    /* We turn on stack splitting if we can.  */\n-    if (!global_options_set.x_flag_split_stack && targetm_common.supports_split_stack(false, \n-        &global_options))\n-        global_options.x_flag_split_stack = 1;\n-\n-    /* If stack splitting is turned on, and the user did not explicitly\n-     request function partitioning, turn off partitioning, as it\n-     confuses the linker when trying to handle partitioned split-stack\n-     code that calls a non-split-stack function.  */\n-    if (global_options.x_flag_split_stack && global_options.x_flag_reorder_blocks_and_partition \n-        && !global_options_set.x_flag_reorder_blocks_and_partition)\n-        global_options.x_flag_reorder_blocks_and_partition = 0;\n-\n-    /* Returning false means that the backend should be used.  */\n-    return false;\n-}\n-\n-static void grs_langhook_parse_file(void) {\n-    //grs_parse_input_files(in_fnames, num_in_fnames, flag_syntax_only, rust_require_return_statement);\n-\n-    /* Final processing of globals and early debug info generation.  */\n-    //rust_write_globals();\n-\n-    // loop through all input file names\n-    for (size_t idx = 0; idx < num_in_fnames; idx++) {\n-        // get input file string for index\n-        const char* in = in_fnames[idx];\n-        GRS_current_infname = xstrdup(in);\n-        GRS_current_infile = basename(GRS_current_infname);\n-        grs_do_compile(in); // calls lexer?\n-    }\n-}\n-\n-static tree grs_langhook_type_for_size(unsigned int bits ATTRIBUTE_UNUSED,\n-                                       int unsignedp ATTRIBUTE_UNUSED) {\n-    /* tree type;\n-    if (unsignedp) {\n-        if (bits == INT_TYPE_SIZE)\n-            type = unsigned_type_node;\n-        else if (bits == CHAR_TYPE_SIZE)\n-            type = unsigned_char_type_node;\n-        else if (bits == SHORT_TYPE_SIZE)\n-            type = short_unsigned_type_node;\n-        else if (bits == LONG_TYPE_SIZE)\n-            type = long_unsigned_type_node;\n-        else if (bits == LONG_LONG_TYPE_SIZE)\n-            type = long_long_unsigned_type_node;\n-        else\n-            type = make_unsigned_type(bits);\n-    } else {\n-        if (bits == INT_TYPE_SIZE)\n-            type = integer_type_node;\n-        else if (bits == CHAR_TYPE_SIZE)\n-            type = signed_char_type_node;\n-        else if (bits == SHORT_TYPE_SIZE)\n-            type = short_integer_type_node;\n-        else if (bits == LONG_TYPE_SIZE)\n-            type = long_integer_type_node;\n-        else if (bits == LONG_LONG_TYPE_SIZE)\n-            type = long_long_integer_type_node;\n-        else\n-            type = make_signed_type(bits);\n-    }\n-    return type;*/\n-\n-    gcc_unreachable();\n-\n-    return NULL_TREE;\n-}\n-\n-static tree grs_langhook_type_for_mode(enum machine_mode mode, int unsignedp) {\n-    if (mode == TYPE_MODE(float_type_node))\n-        return float_type_node;\n-\n-    if (mode == TYPE_MODE(double_type_node))\n-        return double_type_node;\n-\n-    if (mode == TYPE_MODE(integer_type_node))\n-        return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-    if (mode == TYPE_MODE(long_integer_type_node))\n-        return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-    if (COMPLEX_MODE_P(mode)) {\n-        if (mode == TYPE_MODE(complex_float_type_node))\n-            return complex_float_type_node;\n-\n-        if (mode == TYPE_MODE(complex_double_type_node))\n-            return complex_double_type_node;\n-\n-        if (mode == TYPE_MODE(complex_long_double_type_node))\n-            return complex_long_double_type_node;\n-\n-        if (mode == TYPE_MODE(complex_integer_type_node) && !unsignedp)\n-            return complex_integer_type_node;\n-    }\n-\n-    /* gcc unreachable */\n-    return NULL;\n-}\n-\n-/* Record a builtin function.  We just ignore builtin functions.  */\n-static tree grs_langhook_builtin_function(tree decl) {\n-    return decl;\n-}\n-\n-/* Return true if we are in the global binding level.  */\n-static bool grs_langhook_global_bindings_p(void) {\n-    return current_function_decl == NULL_TREE;\n-}\n-\n-/* Push a declaration into the current binding level.  We can't\n-   usefully implement this since we don't want to convert from tree\n-   back to one of our internal data structures.  I think the only way\n-   this is used is to record a decl which is to be returned by\n-   getdecls, and we could implement it for that purpose if\n-   necessary.  */\n-static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n-    gcc_unreachable();\n-    return NULL;\n-}\n-\n-/* This hook is used to get the current list of declarations as trees.\n-   We don't support that; instead we use the write_globals hook.  This\n-   can't simply crash because it is called by -gstabs.  */\n-static tree grs_langhook_getdecls(void) {\n-    gcc_unreachable();\n-    return NULL;\n-}\n-\n-/* Write out globals. */\n-static void grs_langhook_write_globals(void) {\n-    // pass off to middle-end function, basically\n-    dot_pass_WriteGlobals();\n-}\n-\n-static unsigned int grs_langhook_option_lang_mask(void) {\n-    return CL_Rust;\n-}\n-\n-/* Return a decl for the exception personality function.  The function\n-   itself is implemented in librust/runtime/rust-unwind.c.  */\n-static tree grs_langhook_eh_personality(void) {\n-    static tree personality_decl;\n-\n-    if (personality_decl == NULL_TREE) {\n-        personality_decl = build_personality_function(\"gccrs\");\n-        grs_preserve_from_gc(personality_decl);\n-    }\n-\n-    return personality_decl;\n-}\n-\n-/* Rust-specific gimplification.  We need to gimplify\n-   CALL_EXPR_STATIC_CHAIN, because the gimplifier doesn't handle\n-   it.  */\n-static int grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED, \n-    gimple_seq* pre_p ATTRIBUTE_UNUSED, gimple_seq* post_p ATTRIBUTE_UNUSED) {\n-    if (TREE_CODE(*expr_p) == CALL_EXPR && CALL_EXPR_STATIC_CHAIN(*expr_p) != NULL_TREE)\n-        gimplify_expr(&CALL_EXPR_STATIC_CHAIN(*expr_p), pre_p, post_p, is_gimple_val, fb_rvalue);\n-\n-    /* Often useful to use debug_tree here to see what's going on because every gimplification calls\n-       this. */\n-    //debug_tree(*expr_p)\n-    return GS_UNHANDLED;\n-}\n-\n-/* Functions called directly by the generic backend.  */\n-tree convert(tree type, tree expr) {\n-    if (type == error_mark_node || expr == error_mark_node || TREE_TYPE(expr) == error_mark_node)\n-        return error_mark_node;\n-\n-    if (type == TREE_TYPE(expr))\n-        return expr;\n-\n-    if (TYPE_MAIN_VARIANT(type) == TYPE_MAIN_VARIANT(TREE_TYPE(expr)))\n-        return fold_convert(type, expr);\n-\n-    switch (TREE_CODE(type)) {\n-        case VOID_TYPE:\n-        case BOOLEAN_TYPE:\n-            return fold_convert(type, expr);\n-        case INTEGER_TYPE:\n-            return fold(convert_to_integer(type, expr));\n-        case POINTER_TYPE:\n-            return fold(convert_to_pointer(type, expr));\n-        case REAL_TYPE:\n-            return fold(convert_to_real(type, expr));\n-        case COMPLEX_TYPE:\n-            return fold(convert_to_complex(type, expr));\n-        default:\n-            break;\n-    }\n-\n-    gcc_unreachable();\n-}\n-\n-static GTY(()) tree grs_gc_root;\n-void grs_preserve_from_gc(tree t) {\n-    grs_gc_root = tree_cons(NULL_TREE, t, grs_gc_root);\n-}\n-\n-// seems to be unused\n-/* Convert an identifier for use in an error message.  */\n-/* const char* rust_localize_identifier(const char* ident) {\n-    return identifier_to_locale(ident);\n-}*/\n-\n-/* The language hooks data structure. This is the main interface between the GCC front-end\n- * and the GCC middle-end/back-end. A list of language hooks could be found in\n- * <gcc>/langhooks.h\n- */\n-#undef LANG_HOOKS_NAME\n-#undef LANG_HOOKS_INIT\n-#undef LANG_HOOKS_OPTION_LANG_MASK\n-#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n-#undef LANG_HOOKS_HANDLE_OPTION\n-#undef LANG_HOOKS_POST_OPTIONS\n-#undef LANG_HOOKS_PARSE_FILE\n-#undef LANG_HOOKS_TYPE_FOR_MODE\n-#undef LANG_HOOKS_TYPE_FOR_SIZE\n-#undef LANG_HOOKS_BUILTIN_FUNCTION\n-#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n-#undef LANG_HOOKS_PUSHDECL\n-#undef LANG_HOOKS_GETDECLS\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#undef LANG_HOOKS_GIMPLIFY_EXPR\n-#undef LANG_HOOKS_EH_PERSONALITY\n-\n-#define LANG_HOOKS_NAME                 \"GNU Rust\"\n-#define LANG_HOOKS_INIT                 grs_langhook_init\n-#define LANG_HOOKS_OPTION_LANG_MASK     grs_langhook_option_lang_mask\n-#define LANG_HOOKS_INIT_OPTIONS_STRUCT  grs_langhook_init_options_struct\n-#define LANG_HOOKS_HANDLE_OPTION        grs_langhook_handle_option\n-#define LANG_HOOKS_POST_OPTIONS         grs_langhook_post_options\n-#define LANG_HOOKS_PARSE_FILE           grs_langhook_parse_file\n-#define LANG_HOOKS_TYPE_FOR_MODE        grs_langhook_type_for_mode\n-#define LANG_HOOKS_TYPE_FOR_SIZE        grs_langhook_type_for_size\n-#define LANG_HOOKS_BUILTIN_FUNCTION     grs_langhook_builtin_function\n-#define LANG_HOOKS_GLOBAL_BINDINGS_P    grs_langhook_global_bindings_p\n-#define LANG_HOOKS_PUSHDECL             grs_langhook_pushdecl\n-#define LANG_HOOKS_GETDECLS             grs_langhook_getdecls\n-#define LANG_HOOKS_WRITE_GLOBALS        grs_langhook_write_globals\n-#define LANG_HOOKS_GIMPLIFY_EXPR        grs_langhook_gimplify_expr\n-#define LANG_HOOKS_EH_PERSONALITY       grs_langhook_eh_personality\n-\n-struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n-\n-#include \"gt-rust-rs-lang.h\"\n-#include \"gtype-rust.h\"\n-// TODO: something to do with this, maybe"}, {"sha": "2a8eecf1ec60cfa511b73eb9a270124bdcb71462", "filename": "gcc/rust/mrustc_parser/gcc-interface-test/rust-c-interface.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fgcc-interface-test%2Frust-c-interface.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,58 +0,0 @@\n-// mrustc-GCC interface header\n-\n-#ifndef RUST_C_INT_H\n-#define RUST_C_INT_H\n-\n-/* Functions defined in the Rust frontend proper called by the GCC\n-   interface. TODO move around */\n-\n-extern int rust_enable_dump(const char*);\n-extern int rust_enable_optimize(const char*, int);\n-\n-extern void grs_add_search_path(const char*);\n-\n-struct rust_create_grs_args {\n-    int int_type_size;\n-    int pointer_size;\n-    const char* pkgpath;\n-    const char* prefix;\n-    const char* relative_import_path;\n-    const char* c_header;\n-    //Backend* backend;\n-    //Linemap* linemap;\n-    bool check_divide_by_zero;\n-    bool check_divide_overflow;\n-    bool compiling_runtime;\n-    int debug_escape_level;\n-    const char* debug_escape_hash;\n-    int64_t nil_check_size_threshold;\n-    bool debug_optimization;\n-};\n-\n-extern void rust_create_gsr(const struct rust_create_grs_args*);\n-\n-extern void grs_parse_input_files(const char**, unsigned int, bool only_check_syntax, \n-    bool require_return_statement);\n-extern void grs_write_globals(void);\n-\n-/* Functions defined in the GCC interface called by the Rust frontend\n-   proper. TODO: move around */\n-\n-extern void grs_preserve_from_gc(tree);\n-\n-extern bool saw_errors(void);\n-\n-extern const char* rust_localize_identifier(const char*);\n-\n-extern unsigned int rust_field_alignment(tree);\n-\n-extern void rust_imported_unsafe(void);\n-\n-extern void rust_write_export_data(const char*, unsigned int);\n-\n-extern const char* rust_read_export_data(int, off_t, char**, size_t*, int*);\n-\n-extern GTY(()) tree rust_non_zero_struct;\n-\n-\n-#endif\n\\ No newline at end of file"}, {"sha": "49499c861b2d35a353cc976422e8c61b7882d216", "filename": "gcc/rust/mrustc_parser/parse/common.hpp", "status": "removed", "additions": 0, "deletions": 72, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fcommon.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,72 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/common.hpp\n- * - Common definitions used by the parser\n- */\n-#ifndef PARSE_COMMON_HPP_INCLUDED\n-#define PARSE_COMMON_HPP_INCLUDED\n-#include <iostream>\n-#include \"tokenstream.hpp\"\n-#include \"../ast/ast.hpp\"\n-\n-#define GET_TOK(tok, lex) ((tok = lex.getToken()).type())\n-#define PUTBACK(tok, lex) lex.putback( ::std::move(tok) )\n-#define LOOK_AHEAD(lex) (lex.lookahead(0))\n-#define GET_CHECK_TOK(tok, lex, exp) do {\\\n-    if((tok = lex.getToken()).type() != exp) { \\\n-        DEBUG(\"GET_CHECK_TOK \" << __FILE__ << \":\" << __LINE__); \\\n-        throw ParseError::Unexpected(lex, tok, Token(exp));\\\n-    }\\\n-} while(0)\n-#define CHECK_TOK(tok, exp) do {\\\n-    if(tok.type() != exp) { \\\n-        DEBUG(\"CHECK_TOK \" << __FILE__ << \":\" << __LINE__); \\\n-        throw ParseError::Unexpected(lex, tok, Token(exp));\\\n-    } \\\n-} while(0)\n-\n-// --- path.cpp\n-enum eParsePathGenericMode\n-{\n-    PATH_GENERIC_NONE,\n-    PATH_GENERIC_EXPR,\n-    PATH_GENERIC_TYPE\n-};\n-extern AST::Path   Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode);    // Auto-determines\n-extern AST::Path   Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode);\n-extern ::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode);\n-extern AST::PathParams Parse_Path_GenericList(TokenStream& lex);\n-\n-\n-extern AST::HigherRankedBounds Parse_HRB(TokenStream& lex);\n-extern AST::AttributeList  Parse_ItemAttrs(TokenStream& lex);\n-extern void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out);\n-extern AST::Attribute   Parse_MetaItem(TokenStream& lex);\n-extern ::AST::MacroInvocation Parse_MacroInvocation(ProtoSpan ps, ::std::string name, TokenStream& lex);\n-extern TypeRef     Parse_Type(TokenStream& lex, bool allow_trait_list = true);\n-extern AST::Pattern Parse_Pattern(TokenStream& lex, bool is_refutable);\n-\n-extern void Parse_Impl_Item(TokenStream& lex, AST::Impl& impl);\n-extern void Parse_Mod_Item(TokenStream& lex, AST::Module& mod, AST::AttributeList meta_items);\n-extern ::AST::Named<::AST::Item> Parse_Mod_Item_S(TokenStream& lex, const AST::Module::FileInfo& mod_fileinfo, const ::AST::Path& mod_path, AST::AttributeList meta_items);\n-extern void Parse_ModRoot_Items(TokenStream& lex, AST::Module& mod);\n-\n-\n-extern AST::Expr   Parse_Expr(TokenStream& lex);\n-extern AST::Expr   Parse_ExprBlock(TokenStream& lex);\n-extern AST::ExprNodeP   Parse_Expr0(TokenStream& lex);\n-extern AST::ExprNodeP   Parse_ExprVal(TokenStream& lex);\n-extern AST::ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe=false);\n-extern AST::ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence);\n-extern AST::ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end);\n-extern AST::ExprNodeP Parse_Stmt(TokenStream& lex);\n-\n-// unwrapped = Exclude the enclosing brackets (used by macro parse code)\n-extern TokenTree Parse_TT(TokenStream& lex, bool unwrapped);\n-\n-\n-extern bool Parse_IsTokValue(eTokenType tok_type);\n-\n-#endif // PARSE_COMMON_HPP_INCLUDED"}, {"sha": "5104142b33fafd09cdacd9d11afd1f4e365e82ed", "filename": "gcc/rust/mrustc_parser/parse/eTokenType.enum.h", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2FeTokenType.enum.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,154 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/eTokenType.enum.h\n- * - Multi-include file for defining the eTokenType enum\n- */\n-_(TOK_NULL)\n-_(TOK_EOF)\n-\n-_(TOK_NEWLINE)\n-_(TOK_WHITESPACE)\n-_(TOK_COMMENT)\n-\n-_(TOK_INTERPOLATED_IDENT)\n-_(TOK_INTERPOLATED_PATH)\n-_(TOK_INTERPOLATED_TYPE)\n-_(TOK_INTERPOLATED_PATTERN)\n-_(TOK_INTERPOLATED_EXPR)\n-_(TOK_INTERPOLATED_STMT)\n-_(TOK_INTERPOLATED_BLOCK)\n-_(TOK_INTERPOLATED_META)\n-_(TOK_INTERPOLATED_ITEM)\n-\n-// Value tokens\n-_(TOK_IDENT)\n-_(TOK_LIFETIME)\n-_(TOK_INTEGER)\n-_(TOK_CHAR)\n-_(TOK_FLOAT)\n-_(TOK_STRING)\n-_(TOK_BYTESTRING)\n-\n-_(TOK_HASH)\n-\n-_(TOK_UNDERSCORE)\n-\n-// Symbols\n-_(TOK_PAREN_OPEN)   _(TOK_PAREN_CLOSE)\n-_(TOK_BRACE_OPEN)   _(TOK_BRACE_CLOSE)\n-_(TOK_LT)           _(TOK_GT)\n-_(TOK_SQUARE_OPEN)  _(TOK_SQUARE_CLOSE)\n-_(TOK_COMMA)\n-_(TOK_SEMICOLON)\n-_(TOK_COLON)\n-_(TOK_DOUBLE_COLON)\n-_(TOK_STAR)     _(TOK_AMP)\n-_(TOK_PIPE)\n-\n-_(TOK_FATARROW)   // =>\n-_(TOK_THINARROW)  // ->\n-_(TOK_THINARROW_LEFT)   // <-\n-\n-_(TOK_PLUS) _(TOK_DASH)\n-_(TOK_EXCLAM)\n-_(TOK_PERCENT)\n-_(TOK_SLASH)\n-\n-_(TOK_DOT)\n-_(TOK_DOUBLE_DOT)\n-_(TOK_TRIPLE_DOT)\n-\n-_(TOK_EQUAL)\n-_(TOK_PLUS_EQUAL)\n-_(TOK_DASH_EQUAL)\n-_(TOK_PERCENT_EQUAL)\n-_(TOK_SLASH_EQUAL)\n-_(TOK_STAR_EQUAL)\n-_(TOK_AMP_EQUAL)\n-_(TOK_PIPE_EQUAL)\n-\n-_(TOK_DOUBLE_EQUAL)\n-_(TOK_EXCLAM_EQUAL)\n-_(TOK_GTE)\n-_(TOK_LTE)\n-\n-_(TOK_DOUBLE_AMP)\n-_(TOK_DOUBLE_PIPE)\n-_(TOK_DOUBLE_LT)\n-_(TOK_DOUBLE_GT)\n-_(TOK_DOUBLE_LT_EQUAL)\n-_(TOK_DOUBLE_GT_EQUAL)\n-\n-_(TOK_DOLLAR)\n-\n-_(TOK_QMARK)\n-_(TOK_AT)\n-_(TOK_TILDE)\n-_(TOK_BACKSLASH)\n-_(TOK_CARET)\n-_(TOK_CARET_EQUAL)\n-_(TOK_BACKTICK)\n-\n-// Reserved Words\n-// NOTE: ORDERING MATTERS! _PUB must be the first, and no non-rword tokens should follow\n-_(TOK_RWORD_PUB)\n-_(TOK_RWORD_PRIV)\n-_(TOK_RWORD_MUT)\n-_(TOK_RWORD_CONST)\n-_(TOK_RWORD_STATIC)\n-_(TOK_RWORD_UNSAFE)\n-_(TOK_RWORD_EXTERN)\n-\n-_(TOK_RWORD_CRATE)\n-_(TOK_RWORD_MOD)\n-_(TOK_RWORD_STRUCT)\n-_(TOK_RWORD_ENUM)\n-_(TOK_RWORD_TRAIT)\n-_(TOK_RWORD_FN)\n-_(TOK_RWORD_USE)\n-_(TOK_RWORD_IMPL)\n-_(TOK_RWORD_TYPE)\n-\n-_(TOK_RWORD_WHERE)\n-_(TOK_RWORD_AS)\n-\n-_(TOK_RWORD_LET)\n-_(TOK_RWORD_MATCH)\n-_(TOK_RWORD_IF)\n-_(TOK_RWORD_ELSE)\n-_(TOK_RWORD_LOOP)\n-_(TOK_RWORD_WHILE)\n-_(TOK_RWORD_FOR)\n-_(TOK_RWORD_IN)\n-_(TOK_RWORD_DO)\n-\n-_(TOK_RWORD_CONTINUE)\n-_(TOK_RWORD_BREAK)\n-_(TOK_RWORD_RETURN)\n-_(TOK_RWORD_YIELD)\n-_(TOK_RWORD_BOX)\n-_(TOK_RWORD_REF)\n-\n-_(TOK_RWORD_FALSE)\n-_(TOK_RWORD_TRUE)\n-_(TOK_RWORD_SELF)\n-_(TOK_RWORD_SUPER)\n-\n-_(TOK_RWORD_PROC)\n-_(TOK_RWORD_MOVE)\n-\n-_(TOK_RWORD_ABSTRACT)\n-_(TOK_RWORD_FINAL)\n-_(TOK_RWORD_PURE)\n-_(TOK_RWORD_OVERRIDE)\n-_(TOK_RWORD_VIRTUAL)\n-\n-_(TOK_RWORD_ALIGNOF)\n-_(TOK_RWORD_OFFSETOF)\n-_(TOK_RWORD_SIZEOF)\n-_(TOK_RWORD_TYPEOF)\n-\n-_(TOK_RWORD_BE)\n-_(TOK_RWORD_UNSIZED)"}, {"sha": "5194e1d87e390505541b5fcace7c0828ca5ab1d1", "filename": "gcc/rust/mrustc_parser/parse/expr.cpp", "status": "removed", "additions": 0, "deletions": 1338, "changes": 1338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fexpr.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,1338 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/expr.cpp\n- * - Expression (i.e. code) parsing\n- *\n- * Start points:\n- * - Parse_ExprBlockNode : Parses a block\n- * - Parse_Stmt : Parse a single statement\n- * - Parse_Expr0 : Parse a single expression\n- */\n-#include \"parseerror.hpp\"\n-#include <ast/ast.hpp>\n-#include <ast/expr.hpp>\n-#include \"common.hpp\"\n-#include <iostream>\n-#include \"tokentree.hpp\"\n-#include \"interpolated_fragment.hpp\"\n-\n-using AST::ExprNode;\n-using AST::ExprNodeP;\n-// TODO: Use a ProtoSpan instead of a point span?\n-static inline ExprNodeP mk_exprnodep(const TokenStream& lex, AST::ExprNode* en){en->set_span(lex.point_span()); return ExprNodeP(en); }\n-#define NEWNODE(type, ...)  mk_exprnodep(lex, new type(__VA_ARGS__))\n-\n-//ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe=false);    // common.hpp\n-//ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end);\n-//ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence);\n-ExprNodeP Parse_ExprBlockLine_Stmt(TokenStream& lex, bool& has_semicolon);\n-//ExprNodeP Parse_Stmt(TokenStream& lex);   // common.hpp\n-ExprNodeP Parse_Stmt_Let(TokenStream& lex);\n-ExprNodeP Parse_Expr0(TokenStream& lex);\n-ExprNodeP Parse_IfStmt(TokenStream& lex);\n-ExprNodeP Parse_WhileStmt(TokenStream& lex, ::std::string lifetime);\n-ExprNodeP Parse_ForStmt(TokenStream& lex, ::std::string lifetime);\n-ExprNodeP Parse_Expr_Match(TokenStream& lex);\n-ExprNodeP Parse_Expr1(TokenStream& lex);\n-ExprNodeP Parse_ExprMacro(TokenStream& lex, AST::Path tok);\n-\n-AST::Expr Parse_Expr(TokenStream& lex)\n-{\n-    return ::AST::Expr( Parse_Expr0(lex) );\n-}\n-\n-AST::Expr Parse_ExprBlock(TokenStream& lex)\n-{\n-    return ::AST::Expr( Parse_ExprBlockNode(lex) );\n-}\n-\n-ExprNodeP Parse_ExprBlockNode(TokenStream& lex, bool is_unsafe/*=false*/)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    ::std::vector<ExprNodeP> nodes;\n-\n-    ::std::shared_ptr<AST::Module> local_mod;\n-\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n-\n-    bool last_value_yielded = false;\n-    while( LOOK_AHEAD(lex) != TOK_BRACE_CLOSE )\n-    {\n-        last_value_yielded = false;\n-        DEBUG(\"tok = \" << tok);\n-\n-        // NOTE: Doc comments can appear within a function and apply to the function\n-        if( lex.parse_state().parent_attrs )\n-        {\n-            Parse_ParentAttrs(lex, *lex.parse_state().parent_attrs);\n-        }\n-        if( LOOK_AHEAD(lex) == TOK_BRACE_CLOSE )\n-            break;\n-\n-        bool    add_silence_if_end = false;\n-        // `add_silence_if_end` indicates that the statement had a semicolon.\n-        auto rv = Parse_ExprBlockLine_WithItems(lex, local_mod, add_silence_if_end);\n-        if( rv )\n-        {\n-            // Set to TRUE if there was no semicolon after a statement\n-            last_value_yielded = !add_silence_if_end;\n-            nodes.push_back( mv$(rv) );\n-        }\n-        else {\n-            assert( !add_silence_if_end );\n-            last_value_yielded = false;\n-        }\n-    }\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-\n-    return NEWNODE( AST::ExprNode_Block, is_unsafe, last_value_yielded, mv$(nodes), mv$(local_mod) );\n-}\n-\n-/// Parse a single line in a block, handling items added to the local module\n-///\n-/// - If an item was parsed, this returns an empty ExprNodeP\n-ExprNodeP Parse_ExprBlockLine_WithItems(TokenStream& lex, ::std::shared_ptr<AST::Module>& local_mod, bool& add_silence_if_end)\n-{\n-    Token   tok;\n-\n-    auto item_attrs = Parse_ItemAttrs(lex);\n-    GET_TOK(tok, lex);\n-\n-    // `union Ident` - contextual keyword\n-    if( tok.type() == TOK_IDENT && tok.str() == \"union\" && lex.lookahead(0) == TOK_IDENT ) {\n-        PUTBACK(tok, lex);\n-        if( !local_mod ) {\n-            local_mod = lex.parse_state().get_current_mod().add_anon();\n-        }\n-        Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n-        return ExprNodeP();\n-    }\n-\n-    if( tok.type() == TOK_IDENT && tok.str() == \"macro_rules\" && lex.lookahead(0) == TOK_EXCLAM )\n-    {\n-        // Special case - create a local module if macro_rules! is seen\n-        // - Allows correct scoping of defined macros\n-        if( !local_mod ) {\n-            local_mod = lex.parse_state().get_current_mod().add_anon();\n-        }\n-    }\n-\n-    switch(tok.type())\n-    {\n-    // Items:\n-    case TOK_RWORD_PUB:\n-        // NOTE: Allowed, but doesn't do much\n-    case TOK_RWORD_TYPE:\n-    case TOK_RWORD_USE:\n-    case TOK_RWORD_EXTERN:\n-    case TOK_RWORD_CONST:\n-    case TOK_RWORD_STATIC:\n-    case TOK_RWORD_STRUCT:\n-    case TOK_RWORD_ENUM:\n-    case TOK_RWORD_TRAIT:\n-    case TOK_RWORD_IMPL:\n-    case TOK_RWORD_FN:\n-    case TOK_RWORD_MOD:\n-        PUTBACK(tok, lex);\n-        if( !local_mod ) {\n-            local_mod = lex.parse_state().get_current_mod().add_anon();\n-        }\n-        Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n-        return ExprNodeP();\n-    // 'unsafe' - Check if the next token isn't a `{`, if so it's an item. Otherwise, fall through\n-    case TOK_RWORD_UNSAFE:\n-        if( LOOK_AHEAD(lex) != TOK_BRACE_OPEN )\n-        {\n-            PUTBACK(tok, lex);\n-            if( !local_mod ) {\n-                local_mod = lex.parse_state().get_current_mod().add_anon();\n-            }\n-            Parse_Mod_Item(lex, *local_mod, mv$(item_attrs));\n-            return ExprNodeP();\n-        }\n-        // fall\n-    default: {\n-        PUTBACK(tok, lex);\n-        auto rv = Parse_ExprBlockLine(lex, &add_silence_if_end);\n-        if( rv ) {\n-            rv->set_attrs( mv$(item_attrs) );\n-        }\n-        else if( item_attrs.m_items.size() > 0 ) {\n-            // TODO: Is this an error? - Attributes on a expression that didn't yeild a node.\n-            // - They should have applied to the item that was parsed?\n-        }\n-        else {\n-        }\n-        return rv;\n-        } break;\n-    }\n-}\n-\n-/// Parse a single line from a block\n-///\n-/// Handles:\n-/// - Block-level constructs (with lifetime annotations)\n-/// - use/extern/const/let\n-ExprNodeP Parse_ExprBlockLine(TokenStream& lex, bool *add_silence)\n-{\n-    Token tok;\n-    ExprNodeP   ret;\n-\n-    if( GET_TOK(tok, lex) == TOK_LIFETIME )\n-    {\n-        // Lifetimes can only precede loops... and blocks?\n-        ::std::string lifetime = tok.str();\n-        GET_CHECK_TOK(tok, lex, TOK_COLON);\n-\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_RWORD_LOOP:\n-            return NEWNODE( AST::ExprNode_Loop, lifetime, Parse_ExprBlockNode(lex) );\n-        case TOK_RWORD_WHILE:\n-            return Parse_WhileStmt(lex, lifetime);\n-        case TOK_RWORD_FOR:\n-            return Parse_ForStmt(lex, lifetime);\n-        //case TOK_RWORD_IF:\n-        //    return Parse_IfStmt(lex);\n-        //case TOK_RWORD_MATCH:\n-        //    return Parse_Expr_Match(lex);\n-        //case TOK_BRACE_OPEN:\n-        //    PUTBACK(tok, lex);\n-        //    return Parse_ExprBlockNode(lex);\n-\n-        default:\n-            throw ParseError::Unexpected(lex, tok);\n-        }\n-    }\n-    else\n-    {\n-        switch( tok.type() )\n-        {\n-        case TOK_INTERPOLATED_BLOCK:\n-            return tok.take_frag_node();\n-        case TOK_SEMICOLON:\n-            // Return a NULL expression, nothing here.\n-            return nullptr;\n-\n-        // let binding\n-        case TOK_RWORD_LET:\n-            ret = Parse_Stmt_Let(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-            return ret;\n-\n-        // Blocks that don't need semicolons\n-        // NOTE: If these are followed by a small set of tokens (`.` and `?`) then they are actually the start of an expression\n-        // HACK: Parse here, but if the next token is one of the set store in a TOK_INTERPOLATED_EXPR and invoke the statement parser\n-        case TOK_RWORD_LOOP:\n-            ret = NEWNODE( AST::ExprNode_Loop, \"\", Parse_ExprBlockNode(lex) );\n-            if(0)\n-        case TOK_RWORD_WHILE:\n-            ret = Parse_WhileStmt(lex, \"\");\n-            if(0)\n-        case TOK_RWORD_FOR:\n-            ret = Parse_ForStmt(lex, \"\");\n-            if(0)\n-        case TOK_RWORD_IF:\n-            ret = Parse_IfStmt(lex);\n-            if(0)\n-        case TOK_RWORD_MATCH:\n-            ret = Parse_Expr_Match(lex);\n-            if(0)\n-        case TOK_RWORD_UNSAFE:\n-            ret = Parse_ExprBlockNode(lex, true);\n-            if(0)\n-        case TOK_BRACE_OPEN:\n-            { PUTBACK(tok, lex); ret = Parse_ExprBlockNode(lex); }\n-\n-            if( lex.lookahead(0) == TOK_DOT || lex.lookahead(0) == TOK_QMARK ) {\n-                lex.putback( Token(Token::TagTakeIP(), InterpolatedFragment(InterpolatedFragment::EXPR, ret.release())) );\n-                return Parse_ExprBlockLine_Stmt(lex, *add_silence);\n-            }\n-\n-            if( LOOK_AHEAD(lex) == TOK_SEMICOLON ) {\n-                GET_TOK(tok, lex);\n-                *add_silence = true;\n-            }\n-\n-            return ret;\n-\n-        // Flow control\n-        case TOK_RWORD_RETURN:\n-        case TOK_RWORD_CONTINUE:\n-        case TOK_RWORD_BREAK: {\n-            PUTBACK(tok, lex);\n-            auto ret = Parse_Stmt(lex);\n-            if( LOOK_AHEAD(lex) == TOK_EOF ) {\n-            }\n-            else if( GET_TOK(tok, lex) != TOK_SEMICOLON ) {\n-                CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-                PUTBACK(tok, lex);\n-            }\n-            else {\n-                // return/continue/break don't need silencing\n-            }\n-            return ret;\n-            }\n-\n-        case TOK_IDENT:\n-            if( lex.lookahead(0) == TOK_EXCLAM )\n-            {\n-                // If a braced macro invocation is the first part of a statement, don't expect a semicolon\n-                if( lex.lookahead(1) == TOK_BRACE_OPEN || (lex.lookahead(1) == TOK_IDENT && lex.lookahead(2) == TOK_BRACE_OPEN) ) {\n-                    lex.getToken();\n-                    return Parse_ExprMacro(lex, tok.str());\n-                }\n-            }\n-        // Fall through to the statement code\n-        default:\n-            PUTBACK(tok, lex);\n-            return Parse_ExprBlockLine_Stmt(lex, *add_silence);\n-        }\n-    }\n-}\n-\n-ExprNodeP Parse_ExprBlockLine_Stmt(TokenStream& lex, bool& has_semicolon)\n-{\n-    Token tok;\n-    auto ret = Parse_Stmt(lex);\n-    // If this expression statement wasn't followed by a semicolon, then it's yielding its value out of the block.\n-    // - I.e. The block should be ending\n-    if( GET_TOK(tok, lex) != TOK_SEMICOLON ) {\n-        // - Allow TOK_EOF for macro expansion.\n-        if( tok.type() == TOK_EOF )\n-            ;\n-        else\n-            CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-        PUTBACK(tok, lex);\n-    }\n-    else {\n-        has_semicolon = true;\n-    }\n-    return ret;\n-}\n-\n-/// While loop (either as a statement, or as part of an expression)\n-ExprNodeP Parse_WhileStmt(TokenStream& lex, ::std::string lifetime)\n-{\n-    Token   tok;\n-\n-    if( GET_TOK(tok, lex) == TOK_RWORD_LET ) {\n-        auto pat = Parse_Pattern(lex, true);    // Refutable pattern\n-        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-        ExprNodeP val;\n-        {\n-            SET_PARSE_FLAG(lex, disallow_struct_literal);\n-            val = Parse_Expr0(lex);\n-        }\n-        return NEWNODE( AST::ExprNode_Loop, lifetime, AST::ExprNode_Loop::WHILELET,\n-            ::std::move(pat), ::std::move(val), Parse_ExprBlockNode(lex) );\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-        ExprNodeP cnd;\n-        {\n-            SET_PARSE_FLAG(lex, disallow_struct_literal);\n-            cnd = Parse_Expr1(lex);\n-        }\n-        return NEWNODE( AST::ExprNode_Loop, lifetime, ::std::move(cnd), Parse_ExprBlockNode(lex) );\n-    }\n-}\n-/// For loop (either as a statement, or as part of an expression)\n-ExprNodeP Parse_ForStmt(TokenStream& lex, ::std::string lifetime)\n-{\n-    Token   tok;\n-\n-    // Irrefutable pattern\n-    AST::Pattern    pat = Parse_Pattern(lex, false);\n-    GET_CHECK_TOK(tok, lex, TOK_RWORD_IN);\n-    ExprNodeP val;\n-    {\n-        SET_PARSE_FLAG(lex, disallow_struct_literal);\n-        val = Parse_Expr0(lex);\n-    }\n-    return NEWNODE( AST::ExprNode_Loop, lifetime, AST::ExprNode_Loop::FOR,\n-            ::std::move(pat), ::std::move(val), Parse_ExprBlockNode(lex) );\n-}\n-/// Parse an 'if' statement\n-// Note: TOK_RWORD_IF has already been eaten\n-ExprNodeP Parse_IfStmt(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-    ExprNodeP cond;\n-    AST::Pattern    pat;\n-    bool if_let = false;\n-\n-    {\n-        SET_PARSE_FLAG(lex, disallow_struct_literal);\n-        if( GET_TOK(tok, lex) == TOK_RWORD_LET ) {\n-            if_let = true;\n-            // Refutable pattern\n-            pat = Parse_Pattern(lex, true);\n-            GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-            cond = Parse_Expr0(lex);\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-            cond = Parse_Expr0(lex);\n-        }\n-    }\n-\n-    // Contents\n-    ExprNodeP code = Parse_ExprBlockNode(lex);\n-\n-    // Handle else:\n-    ExprNodeP altcode;\n-    if( GET_TOK(tok, lex) == TOK_RWORD_ELSE )\n-    {\n-        // Recurse for 'else if'\n-        if( GET_TOK(tok, lex) == TOK_RWORD_IF ) {\n-            altcode = Parse_IfStmt(lex);\n-        }\n-        // - or get block\n-        else {\n-            PUTBACK(tok, lex);\n-            altcode = Parse_ExprBlockNode(lex);\n-        }\n-    }\n-    // - or nothing\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    if( if_let )\n-        return NEWNODE( AST::ExprNode_IfLet, ::std::move(pat), ::std::move(cond), ::std::move(code), ::std::move(altcode) );\n-    else\n-        return NEWNODE( AST::ExprNode_If, ::std::move(cond), ::std::move(code), ::std::move(altcode) );\n-}\n-/// \"match\" block\n-ExprNodeP Parse_Expr_Match(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token tok;\n-\n-    CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n-    // 1. Get expression\n-    ExprNodeP   switch_val;\n-    {\n-        SET_PARSE_FLAG(lex, disallow_struct_literal);\n-        switch_val = Parse_Expr1(lex);\n-    }\n-    //ASSERT(lex, !CHECK_PARSE_FLAG(lex, disallow_struct_literal) );\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n-\n-    ::std::vector< AST::ExprNode_Match_Arm >    arms;\n-    do {\n-        if( GET_TOK(tok, lex) == TOK_BRACE_CLOSE )\n-            break;\n-        PUTBACK(tok, lex);\n-        AST::ExprNode_Match_Arm    arm;\n-\n-        arm.m_attrs = Parse_ItemAttrs(lex);\n-\n-        do {\n-            // Refutable pattern\n-            arm.m_patterns.push_back( Parse_Pattern(lex, true) );\n-        } while( GET_TOK(tok, lex) == TOK_PIPE );\n-\n-        if( tok.type() == TOK_RWORD_IF )\n-        {\n-            arm.m_cond = Parse_Expr1(lex);\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_FATARROW);\n-\n-        arm.m_code = Parse_Stmt(lex);\n-\n-        arms.push_back( ::std::move(arm) );\n-\n-        if( GET_TOK(tok, lex) == TOK_COMMA )\n-            continue;\n-        PUTBACK(tok, lex);\n-\n-    } while( 1 );\n-    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-    return NEWNODE( AST::ExprNode_Match, ::std::move(switch_val), ::std::move(arms) );\n-}\n-\n-/// Parses the 'stmt' fragment specifier\n-/// - Flow control\n-/// - Expressions\n-ExprNodeP Parse_Stmt(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    switch(GET_TOK(tok, lex))\n-    {\n-    case TOK_INTERPOLATED_STMT:\n-        return tok.take_frag_node();\n-    // Duplicated here for the :stmt pattern fragment.\n-    case TOK_RWORD_LET:\n-        return Parse_Stmt_Let(lex);\n-    case TOK_RWORD_RETURN: {\n-        ExprNodeP   val;\n-        switch(LOOK_AHEAD(lex))\n-        {\n-        case TOK_EOF:\n-        case TOK_SEMICOLON:\n-        case TOK_COMMA:\n-        case TOK_BRACE_CLOSE:\n-        case TOK_PAREN_CLOSE:\n-        case TOK_SQUARE_CLOSE:\n-            break;\n-        default:\n-            val = Parse_Expr0(lex);\n-            break;\n-        }\n-        return NEWNODE( AST::ExprNode_Flow, AST::ExprNode_Flow::RETURN, \"\", ::std::move(val) );\n-        }\n-    case TOK_RWORD_CONTINUE:\n-    case TOK_RWORD_BREAK:\n-        {\n-        AST::ExprNode_Flow::Type    type;\n-        switch(tok.type())\n-        {\n-        case TOK_RWORD_CONTINUE: type = AST::ExprNode_Flow::CONTINUE; break;\n-        case TOK_RWORD_BREAK:    type = AST::ExprNode_Flow::BREAK;    break;\n-        default:    throw ParseError::BugCheck(/*lex,*/ \"continue/break\");\n-        }\n-        ::std::string   lifetime;\n-        if( GET_TOK(tok, lex) == TOK_LIFETIME )\n-        {\n-            lifetime = tok.str();\n-            GET_TOK(tok, lex);\n-        }\n-        ExprNodeP   val;\n-        switch(tok.type())\n-        {\n-        case TOK_EOF:\n-        case TOK_SEMICOLON:\n-        case TOK_COMMA:\n-        case TOK_BRACE_OPEN:\n-        case TOK_BRACE_CLOSE:\n-        case TOK_PAREN_CLOSE:\n-        case TOK_SQUARE_CLOSE:\n-            PUTBACK(tok, lex);\n-            break;\n-        default:\n-            PUTBACK(tok, lex);\n-            val = Parse_Expr1(lex);\n-            break;\n-        }\n-        return NEWNODE( AST::ExprNode_Flow, type, lifetime, ::std::move(val) );\n-        }\n-    case TOK_BRACE_OPEN:\n-        PUTBACK(tok, lex);\n-        return Parse_ExprBlockNode(lex);\n-    default:\n-        PUTBACK(tok, lex);\n-        return Parse_Expr0(lex);\n-    }\n-}\n-\n-ExprNodeP Parse_Stmt_Let(TokenStream& lex)\n-{\n-    Token   tok;\n-    AST::Pattern pat = Parse_Pattern(lex, false);   // irrefutable\n-    TypeRef type { lex.point_span() };\n-    if( GET_TOK(tok, lex) == TOK_COLON ) {\n-        type = Parse_Type(lex);\n-        GET_TOK(tok, lex);\n-    }\n-    ExprNodeP val;\n-    if( tok.type() == TOK_EQUAL ) {\n-        val = Parse_Expr0(lex);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-    return NEWNODE( AST::ExprNode_LetBinding, ::std::move(pat), mv$(type), ::std::move(val) );\n-}\n-\n-::std::vector<ExprNodeP> Parse_ParenList(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n-\n-    ::std::vector<ExprNodeP> rv;\n-    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n-    if( GET_TOK(tok, lex) != TOK_PAREN_CLOSE )\n-    {\n-        PUTBACK(tok, lex);\n-        do {\n-            if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE ) {\n-                GET_TOK(tok, lex);\n-                break;\n-            }\n-            rv.push_back( Parse_Expr0(lex) );\n-        } while( GET_TOK(tok, lex) == TOK_COMMA );\n-        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-    }\n-    return rv;\n-}\n-\n-// 0: Assign\n-ExprNodeP Parse_Expr0(TokenStream& lex)\n-{\n-    //TRACE_FUNCTION;\n-    Token tok;\n-\n-    auto expr_attrs = Parse_ItemAttrs(lex);\n-\n-    ExprNodeP rv = Parse_Expr1(lex);\n-    auto op = AST::ExprNode_Assign::NONE;\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_PLUS_EQUAL:\n-        op = AST::ExprNode_Assign::ADD; if(0)\n-    case TOK_DASH_EQUAL:\n-        op = AST::ExprNode_Assign::SUB; if(0)\n-    case TOK_STAR_EQUAL:\n-        op = AST::ExprNode_Assign::MUL; if(0)\n-    case TOK_SLASH_EQUAL:\n-        op = AST::ExprNode_Assign::DIV; if(0)\n-    case TOK_PERCENT_EQUAL:\n-        op = AST::ExprNode_Assign::MOD; if(0)\n-\n-    case TOK_AMP_EQUAL:\n-        op = AST::ExprNode_Assign::AND; if(0)\n-    case TOK_PIPE_EQUAL:\n-        op = AST::ExprNode_Assign::OR ; if(0)\n-    case TOK_CARET_EQUAL:\n-        op = AST::ExprNode_Assign::XOR; if(0)\n-\n-    case TOK_DOUBLE_GT_EQUAL:\n-        op = AST::ExprNode_Assign::SHR; if(0)\n-    case TOK_DOUBLE_LT_EQUAL:\n-        op = AST::ExprNode_Assign::SHL; if(0)\n-\n-    case TOK_EQUAL:\n-        op = AST::ExprNode_Assign::NONE;\n-        rv = NEWNODE( AST::ExprNode_Assign, op, ::std::move(rv), Parse_Expr0(lex) );\n-        rv->set_attrs(mv$(expr_attrs));\n-        return rv;\n-\n-    default:\n-        PUTBACK(tok, lex);\n-        rv->set_attrs(mv$(expr_attrs));\n-        return rv;\n-    }\n-}\n-\n-\n-#define LEFTASSOC(cur, _next, cases) \\\n-ExprNodeP _next(TokenStream& lex); \\\n-ExprNodeP cur(TokenStream& lex) \\\n-{ \\\n-    ExprNodeP (*next)(TokenStream&) = _next;\\\n-    ExprNodeP rv = next(lex); \\\n-    while(true) \\\n-    { \\\n-        Token   tok; \\\n-        switch((tok = lex.getToken()).type()) \\\n-        { \\\n-        cases \\\n-        default: \\\n-            /*::std::cout << \"<<\" << #cur << ::std::endl; */\\\n-            PUTBACK(tok, lex); \\\n-            return rv; \\\n-        } \\\n-    } \\\n-}\n-bool Parse_IsTokValue(eTokenType tok_type)\n-{\n-    switch( tok_type )\n-    {\n-    case TOK_DOUBLE_COLON:\n-    case TOK_IDENT:\n-    case TOK_INTEGER:\n-    case TOK_FLOAT:\n-    case TOK_STRING:\n-    case TOK_RWORD_TRUE:\n-    case TOK_RWORD_FALSE:\n-    case TOK_RWORD_SELF:\n-    case TOK_RWORD_SUPER:\n-    case TOK_RWORD_BOX:\n-    case TOK_RWORD_IN:\n-    case TOK_PAREN_OPEN:\n-    case TOK_SQUARE_OPEN:\n-\n-    case TOK_INTERPOLATED_PATH:\n-    case TOK_INTERPOLATED_EXPR:\n-\n-    case TOK_PIPE:\n-    case TOK_EXCLAM:\n-    case TOK_DASH:\n-    case TOK_STAR:\n-    case TOK_AMP:\n-        return true;\n-    default:\n-        return false;\n-    }\n-}\n-ExprNodeP Parse_Expr1_1(TokenStream& lex);\n-ExprNodeP Parse_Expr1(TokenStream& lex)\n-{\n-    Token   tok;\n-    ExprNodeP (*next)(TokenStream&) = Parse_Expr1_1;\n-\n-    auto dest = next(lex);\n-    if( lex.lookahead(0) == TOK_THINARROW_LEFT )\n-    {\n-        GET_TOK(tok, lex);\n-        auto val = Parse_Expr1(lex);\n-        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::PLACE_IN, mv$(dest), mv$(val));\n-    }\n-    else\n-    {\n-        return dest;\n-    }\n-}\n-ExprNodeP Parse_Expr1_2(TokenStream& lex);\n-// Very evil handling for '..'\n-ExprNodeP Parse_Expr1_1(TokenStream& lex)\n-{\n-    Token   tok;\n-    ExprNodeP (*next)(TokenStream&) = Parse_Expr1_2;\n-    ExprNodeP   left, right;\n-\n-    // Inclusive range to a value\n-    if( GET_TOK(tok, lex) == TOK_TRIPLE_DOT ) {\n-        right = next(lex);\n-        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE_INC, nullptr, mv$(right) );\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    // Exclusive ranges\n-    // - If NOT `.. <VAL>`, parse a leading value\n-    if( GET_TOK(tok, lex) != TOK_DOUBLE_DOT )\n-    {\n-        PUTBACK(tok, lex);\n-\n-        left = next(lex);\n-\n-        // - If NOT `<VAL> ..`, return the value\n-        if( GET_TOK(tok, lex) != TOK_DOUBLE_DOT )\n-        {\n-            PUTBACK(tok, lex);\n-            return ::std::move(left);\n-        }\n-    }\n-    assert( tok.type() == TOK_DOUBLE_DOT );\n-    // If the next token is part of a value, parse that value\n-    if( Parse_IsTokValue( LOOK_AHEAD(lex) ) )\n-    {\n-        right = next(lex);\n-    }\n-    else\n-    {\n-        // Otherwise, leave `right` as nullptr\n-    }\n-\n-    return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE, ::std::move(left), ::std::move(right) );\n-}\n-LEFTASSOC(Parse_Expr1_2, Parse_Expr1_5,\n-    case TOK_TRIPLE_DOT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::RANGE_INC, mv$(rv), next(lex) );\n-        break;\n-)\n-// 1: Bool OR\n-LEFTASSOC(Parse_Expr1_5, Parse_Expr2,\n-    case TOK_DOUBLE_PIPE:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BOOLOR, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 2: Bool AND\n-LEFTASSOC(Parse_Expr2, Parse_Expr3,\n-    case TOK_DOUBLE_AMP:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BOOLAND, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 3: (In)Equality\n-LEFTASSOC(Parse_Expr3, Parse_Expr4,\n-    case TOK_DOUBLE_EQUAL:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPEQU, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_EXCLAM_EQUAL:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPNEQU, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 4: Comparisons\n-LEFTASSOC(Parse_Expr4, Parse_Expr5,\n-    case TOK_LT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPLT, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_GT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPGT, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_LTE:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPLTE, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_GTE:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::CMPGTE, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 5: Bit OR\n-LEFTASSOC(Parse_Expr5, Parse_Expr6,\n-    case TOK_PIPE:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITOR, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 6: Bit XOR\n-LEFTASSOC(Parse_Expr6, Parse_Expr7,\n-    case TOK_CARET:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITXOR, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 7: Bit AND\n-LEFTASSOC(Parse_Expr7, Parse_Expr8,\n-    case TOK_AMP:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::BITAND, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 8: Bit Shifts\n-LEFTASSOC(Parse_Expr8, Parse_Expr9,\n-    case TOK_DOUBLE_LT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SHL, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_DOUBLE_GT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SHR, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 9: Add / Subtract\n-LEFTASSOC(Parse_Expr9, Parse_Expr10,\n-    case TOK_PLUS:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::ADD, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_DASH:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::SUB, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 10: Times / Divide / Modulo\n-LEFTASSOC(Parse_Expr10, Parse_Expr11,\n-    case TOK_STAR:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::MULTIPLY, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_SLASH:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::DIVIDE, ::std::move(rv), next(lex));\n-        break;\n-    case TOK_PERCENT:\n-        rv = NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::MODULO, ::std::move(rv), next(lex));\n-        break;\n-)\n-// 11: Cast\n-LEFTASSOC(Parse_Expr11, Parse_Expr12,\n-    case TOK_RWORD_AS:\n-        rv = NEWNODE( AST::ExprNode_Cast, ::std::move(rv), Parse_Type(lex, false) );\n-        break;\n-)\n-// 12: Type Ascription\n-ExprNodeP Parse_Expr13(TokenStream& lex);\n-ExprNodeP Parse_Expr12(TokenStream& lex)\n-{\n-    Token   tok;\n-    auto rv = Parse_Expr13(lex);\n-    if(GET_TOK(tok, lex) == TOK_COLON)\n-    {\n-        rv = NEWNODE( AST::ExprNode_TypeAnnotation, mv$(rv), Parse_Type(lex) );\n-    }\n-    else\n-    {\n-        PUTBACK(tok, lex);\n-    }\n-    return rv;\n-}\n-// 13: Unaries\n-ExprNodeP Parse_ExprFC(TokenStream& lex);\n-ExprNodeP Parse_Expr13(TokenStream& lex)\n-{\n-    Token   tok;\n-    switch(GET_TOK(tok, lex))\n-    {\n-    case TOK_DASH:\n-        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::NEGATE, Parse_Expr12(lex) );\n-    case TOK_EXCLAM:\n-        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::INVERT, Parse_Expr12(lex) );\n-    case TOK_STAR:\n-        return NEWNODE( AST::ExprNode_Deref, Parse_Expr12(lex) );\n-    case TOK_RWORD_BOX:\n-        return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::BOX, Parse_Expr12(lex) );\n-    case TOK_RWORD_IN: {\n-        ExprNodeP   dest;\n-        {\n-            SET_PARSE_FLAG(lex, disallow_struct_literal);\n-            dest = Parse_Expr1(lex);\n-        }\n-        auto val = Parse_ExprBlockNode(lex);\n-        return NEWNODE( AST::ExprNode_BinOp, AST::ExprNode_BinOp::PLACE_IN, mv$(dest), mv$(val));\n-        }\n-    case TOK_DOUBLE_AMP:\n-        // HACK: Split && into & &\n-        lex.putback( Token(TOK_AMP) );\n-    case TOK_AMP:\n-        if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n-            return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::REFMUT, Parse_Expr12(lex) );\n-        else {\n-            PUTBACK(tok, lex);\n-            return NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::REF, Parse_Expr12(lex) );\n-        }\n-    default:\n-        PUTBACK(tok, lex);\n-        return Parse_ExprFC(lex);\n-    }\n-}\n-\n-ExprNodeP Parse_ExprVal(TokenStream& lex);\n-ExprNodeP Parse_ExprFC(TokenStream& lex)\n-{\n-    ExprNodeP   val = Parse_ExprVal(lex);\n-    while(true)\n-    {\n-        Token   tok;\n-        switch(GET_TOK(tok, lex))\n-        {\n-        case TOK_QMARK:\n-            val = NEWNODE( AST::ExprNode_UniOp, AST::ExprNode_UniOp::QMARK, mv$(val) );\n-            break;\n-\n-        case TOK_PAREN_OPEN:\n-            // Expression method call\n-            PUTBACK(tok, lex);\n-            val = NEWNODE( AST::ExprNode_CallObject, ::std::move(val), Parse_ParenList(lex) );\n-            break;\n-        case TOK_SQUARE_OPEN:\n-            val = NEWNODE( AST::ExprNode_Index, ::std::move(val), Parse_Expr0(lex) );\n-            GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-            break;\n-        case TOK_DOT:\n-            // Field access / method call / tuple index\n-            switch(GET_TOK(tok, lex))\n-            {\n-            case TOK_IDENT: {\n-                AST::PathNode   path( mv$(tok.str()) , {});\n-                switch( GET_TOK(tok, lex) )\n-                {\n-                case TOK_PAREN_OPEN:\n-                    PUTBACK(tok, lex);\n-                    val = NEWNODE( AST::ExprNode_CallMethod, ::std::move(val), ::std::move(path), Parse_ParenList(lex) );\n-                    break;\n-                case TOK_DOUBLE_COLON:\n-                    GET_CHECK_TOK(tok, lex, TOK_LT);\n-                    path.args() = Parse_Path_GenericList(lex);\n-                    val = NEWNODE( AST::ExprNode_CallMethod, ::std::move(val), ::std::move(path), Parse_ParenList(lex) );\n-                    break;\n-                default:\n-                    val = NEWNODE( AST::ExprNode_Field, ::std::move(val), ::std::string(path.name()) );\n-                    PUTBACK(tok, lex);\n-                    break;\n-                }\n-                break; }\n-            case TOK_INTEGER:\n-                val = NEWNODE( AST::ExprNode_Field, ::std::move(val), FMT(tok.intval()) );\n-                break;\n-            default:\n-                throw ParseError::Unexpected(lex, mv$(tok));\n-            }\n-            break;\n-        default:\n-            PUTBACK(tok, lex);\n-            return val;\n-        }\n-    }\n-}\n-\n-ExprNodeP Parse_ExprVal_StructLiteral(TokenStream& lex, AST::Path path)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    // #![feature(relaxed_adts)]\n-    if( LOOK_AHEAD(lex) == TOK_INTEGER )\n-    {\n-        ::std::map<unsigned int, ExprNodeP> nodes;\n-        while( GET_TOK(tok, lex) == TOK_INTEGER )\n-        {\n-            unsigned int ofs = static_cast<unsigned int>(tok.intval());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            ExprNodeP   val = Parse_Stmt(lex);\n-            if( ! nodes.insert( ::std::make_pair(ofs, mv$(val)) ).second ) {\n-                ERROR(lex.point_span(), E0000, \"Duplicate index\");\n-            }\n-\n-            if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n-                break;\n-            CHECK_TOK(tok, TOK_COMMA);\n-        }\n-        CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-        ::std::vector<ExprNodeP>    items;\n-        unsigned int i = 0;\n-        for(auto& p : nodes)\n-        {\n-            if( p.first != i ) {\n-                ERROR(lex.point_span(), E0000, \"Missing index \" << i);\n-            }\n-            items.push_back( mv$(p.second) );\n-            i ++;\n-        }\n-\n-        return NEWNODE( AST::ExprNode_CallPath, mv$(path), mv$(items) );\n-    }\n-\n-    // Braced structure literal\n-    // - A series of 0 or more pairs of <ident>: <expr>,\n-    // - '..' <expr>\n-    ::AST::ExprNode_StructLiteral::t_values items;\n-    while( GET_TOK(tok, lex) == TOK_IDENT || tok.type() == TOK_HASH )\n-    {\n-        ::AST::AttributeList attrs;    // Note: Parse_ItemAttrs uses lookahead, so can't use it here.\n-        if( tok.type() == TOK_HASH )\n-        {\n-            PUTBACK(tok, lex);\n-            attrs = Parse_ItemAttrs(lex);\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_IDENT);\n-        auto h = lex.getHygiene();\n-        auto name = mv$(tok.str());\n-\n-        ExprNodeP   val;\n-        if( lex.lookahead(0) != TOK_COLON )\n-        {\n-            val = NEWNODE( AST::ExprNode_NamedValue, ::AST::Path(::AST::Path::TagRelative{}, h, { ::AST::PathNode(name) }) );\n-        }\n-        else\n-        {\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            val = Parse_Stmt(lex);\n-        }\n-        items.push_back(::AST::ExprNode_StructLiteral::Ent { mv$(attrs), mv$(name), mv$(val) });\n-\n-        if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n-            break;\n-        CHECK_TOK(tok, TOK_COMMA);\n-    }\n-    ExprNodeP    base_val;\n-    if( tok.type() == TOK_DOUBLE_DOT )\n-    {\n-        // default\n-        base_val = Parse_Expr0(lex);\n-        GET_TOK(tok, lex);\n-    }\n-    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-    return NEWNODE( AST::ExprNode_StructLiteral, path, ::std::move(base_val), ::std::move(items) );\n-}\n-\n-ExprNodeP Parse_ExprVal_Closure(TokenStream& lex, bool is_move)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    ::std::vector< ::std::pair<AST::Pattern, TypeRef> > args;\n-\n-    while( GET_TOK(tok, lex) != TOK_PIPE )\n-    {\n-        PUTBACK(tok, lex);\n-        // Irrefutable pattern\n-        AST::Pattern    pat = Parse_Pattern(lex, false);\n-\n-        TypeRef type { lex.point_span() };\n-        if( GET_TOK(tok, lex) == TOK_COLON )\n-            type = Parse_Type(lex);\n-        else\n-            PUTBACK(tok, lex);\n-\n-        args.push_back( ::std::make_pair( ::std::move(pat), ::std::move(type) ) );\n-\n-        if( GET_TOK(tok, lex) != TOK_COMMA )\n-            break;\n-    }\n-    CHECK_TOK(tok, TOK_PIPE);\n-\n-    auto rt = TypeRef(lex.point_span());\n-    if( GET_TOK(tok, lex) == TOK_THINARROW ) {\n-\n-        if( GET_TOK(tok, lex) == TOK_EXCLAM ) {\n-            rt = TypeRef(TypeRef::TagInvalid(), Span(tok.get_pos()));\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-            rt = Parse_Type(lex);\n-        }\n-    }\n-    else\n-        PUTBACK(tok, lex);\n-\n-    auto code = Parse_Expr0(lex);\n-\n-    return NEWNODE( AST::ExprNode_Closure, ::std::move(args), ::std::move(rt), ::std::move(code), is_move );\n-}\n-\n-ExprNodeP Parse_ExprVal(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-    AST::Path   path;\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_BRACE_OPEN:\n-        PUTBACK(tok, lex);\n-        return Parse_ExprBlockNode(lex);\n-\n-    case TOK_INTERPOLATED_EXPR:\n-    case TOK_INTERPOLATED_BLOCK:\n-        return tok.take_frag_node();\n-\n-\n-    // Return/break/continue/... also parsed here (but recurses back up to actually handle them)\n-    case TOK_RWORD_RETURN:\n-    case TOK_RWORD_CONTINUE:\n-    case TOK_RWORD_BREAK:\n-        PUTBACK(tok, lex);\n-        return Parse_Stmt(lex);\n-\n-    case TOK_RWORD_LOOP:\n-        return NEWNODE( AST::ExprNode_Loop, \"\", Parse_ExprBlockNode(lex) );\n-    case TOK_RWORD_WHILE:\n-        return Parse_WhileStmt(lex, \"\");\n-    case TOK_RWORD_FOR:\n-        return Parse_ForStmt(lex, \"\");\n-    case TOK_RWORD_MATCH:\n-        return Parse_Expr_Match(lex);\n-    case TOK_RWORD_IF:\n-        return Parse_IfStmt(lex);\n-    case TOK_RWORD_UNSAFE:\n-        return Parse_ExprBlockNode(lex, true);\n-\n-    // UFCS\n-    case TOK_DOUBLE_LT:\n-    case TOK_LT:\n-        PUTBACK(tok, lex);\n-        path = Parse_Path(lex, PATH_GENERIC_EXPR);\n-        // Skip down to method\n-        if(0)\n-    case TOK_RWORD_SELF:\n-        {\n-            if( LOOK_AHEAD(lex) != TOK_DOUBLE_COLON ) {\n-                return NEWNODE( AST::ExprNode_NamedValue, AST::Path(AST::Path::TagLocal(), \"self\") );\n-            }\n-            else\n-            {\n-                PUTBACK(tok, lex);\n-                path = Parse_Path(lex, PATH_GENERIC_EXPR);\n-            }\n-        }\n-        if(0)\n-    case TOK_RWORD_SUPER:\n-        {\n-            PUTBACK(tok, lex);\n-            path = Parse_Path(lex, PATH_GENERIC_EXPR);\n-        }\n-        if(0)\n-    case TOK_IDENT:\n-        // Get path\n-        {\n-            PUTBACK(tok, lex);\n-            path = Parse_Path(lex, false, PATH_GENERIC_EXPR);\n-        }\n-        if(0)\n-    case TOK_INTERPOLATED_PATH:\n-        {\n-            path = mv$(tok.frag_path());\n-        }\n-        if(0)\n-    case TOK_DOUBLE_COLON:\n-        path = Parse_Path(lex, true, PATH_GENERIC_EXPR);\n-        DEBUG(\"path = \" << path << \", lookahead=\" << Token::typestr(lex.lookahead(0)));\n-        // SKIP TARGET\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_EXCLAM:\n-            return Parse_ExprMacro(lex, mv$(path));\n-        case TOK_PAREN_OPEN:\n-            // Function call\n-            PUTBACK(tok, lex);\n-            return NEWNODE( AST::ExprNode_CallPath, ::std::move(path), Parse_ParenList(lex) );\n-        case TOK_BRACE_OPEN:\n-            if( !CHECK_PARSE_FLAG(lex, disallow_struct_literal) )\n-                return Parse_ExprVal_StructLiteral(lex, ::std::move(path));\n-            else\n-                DEBUG(\"Not parsing struct literal\");\n-        default:\n-            // Value\n-            PUTBACK(tok, lex);\n-            return NEWNODE( AST::ExprNode_NamedValue, ::std::move(path) );\n-        }\n-    case TOK_RWORD_MOVE:\n-        GET_TOK(tok, lex);\n-        if(tok.type() == TOK_PIPE)\n-            return Parse_ExprVal_Closure(lex, true);\n-        else if(tok.type() == TOK_DOUBLE_PIPE) {\n-            lex.putback(Token(TOK_PIPE));\n-            return Parse_ExprVal_Closure(lex, true);\n-        }\n-        else {\n-            CHECK_TOK(tok, TOK_PIPE);\n-        }\n-    case TOK_DOUBLE_PIPE:\n-        lex.putback(Token(TOK_PIPE));\n-    case TOK_PIPE:\n-        return Parse_ExprVal_Closure(lex, false);\n-    case TOK_INTEGER:\n-        return NEWNODE( AST::ExprNode_Integer, tok.intval(), tok.datatype() );\n-    case TOK_FLOAT:\n-        return NEWNODE( AST::ExprNode_Float, tok.floatval(), tok.datatype() );\n-    case TOK_STRING:\n-        return NEWNODE( AST::ExprNode_String, tok.str() );\n-    case TOK_BYTESTRING:\n-        return NEWNODE( AST::ExprNode_ByteString, tok.str() );\n-    case TOK_RWORD_TRUE:\n-        return NEWNODE( AST::ExprNode_Bool, true );\n-    case TOK_RWORD_FALSE:\n-        return NEWNODE( AST::ExprNode_Bool, false );\n-    case TOK_PAREN_OPEN:\n-        if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n-        {\n-            DEBUG(\"Unit\");\n-            return NEWNODE( AST::ExprNode_Tuple, ::std::vector<ExprNodeP>() );\n-        }\n-        else\n-        {\n-            CLEAR_PARSE_FLAG(lex, disallow_struct_literal);\n-            PUTBACK(tok, lex);\n-\n-            ExprNodeP rv = Parse_Expr0(lex);\n-            if( GET_TOK(tok, lex) == TOK_COMMA ) {\n-                ::std::vector<ExprNodeP> ents;\n-                ents.push_back( ::std::move(rv) );\n-                do {\n-                    if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n-                        break;\n-                    PUTBACK(tok, lex);\n-                    ents.push_back( Parse_Expr0(lex) );\n-                } while( GET_TOK(tok, lex) == TOK_COMMA );\n-                rv = NEWNODE( AST::ExprNode_Tuple, ::std::move(ents) );\n-            }\n-            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-            return rv;\n-        }\n-    case TOK_SQUARE_OPEN:\n-        if( GET_TOK(tok, lex) == TOK_SQUARE_CLOSE )\n-        {\n-            // Empty literal\n-            return NEWNODE( AST::ExprNode_Array, ::std::vector<ExprNodeP>() );\n-        }\n-        else\n-        {\n-            PUTBACK(tok, lex);\n-            auto first = Parse_Expr0(lex);\n-            if( GET_TOK(tok, lex) == TOK_SEMICOLON )\n-            {\n-                // Repetiion\n-                auto count = Parse_Expr0(lex);\n-                GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-                return NEWNODE( AST::ExprNode_Array, ::std::move(first), ::std::move(count) );\n-            }\n-            else\n-            {\n-                ::std::vector<ExprNodeP>    items;\n-                items.push_back( ::std::move(first) );\n-                while( tok.type() == TOK_COMMA )\n-                {\n-                    if( GET_TOK(tok, lex) == TOK_SQUARE_CLOSE )\n-                        break;\n-                    else\n-                        PUTBACK(tok, lex);\n-                    items.push_back( Parse_Expr0(lex) );\n-                    GET_TOK(tok, lex);\n-                }\n-                CHECK_TOK(tok, TOK_SQUARE_CLOSE);\n-                return NEWNODE( AST::ExprNode_Array, ::std::move(items) );\n-            }\n-        }\n-        throw ParseError::BugCheck(lex, \"Array literal fell\");\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-}\n-ExprNodeP Parse_ExprMacro(TokenStream& lex, AST::Path path)\n-{\n-    if( !path.is_trivial() ) {\n-        TODO(lex.point_span(), \"Support path macros - \" << path);\n-    }\n-\n-    Token   tok;\n-    ::std::string name = path.m_class.is_Local() ? path.m_class.as_Local().name : path.nodes()[0].name();\n-    ::std::string ident;\n-    if( GET_TOK(tok, lex) == TOK_IDENT ) {\n-        ident = mv$(tok.str());\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-    TokenTree tt = Parse_TT(lex, true);\n-    if( tt.is_token() ) {\n-        throw ParseError::Unexpected(lex, tt.tok());\n-    }\n-    return NEWNODE(AST::ExprNode_Macro, mv$(name), mv$(ident), mv$(tt));\n-}\n-\n-// Token Tree Parsing\n-TokenTree Parse_TT(TokenStream& lex, bool unwrapped)\n-{\n-    TokenTree   rv;\n-    TRACE_FUNCTION_FR(\"\", rv);\n-\n-    Token tok = lex.getToken();\n-    eTokenType  closer = TOK_PAREN_CLOSE;\n-    switch(tok.type())\n-    {\n-    case TOK_PAREN_OPEN:\n-        closer = TOK_PAREN_CLOSE;\n-        break;\n-    case TOK_SQUARE_OPEN:\n-        closer = TOK_SQUARE_CLOSE;\n-        break;\n-    case TOK_BRACE_OPEN:\n-        closer = TOK_BRACE_CLOSE;\n-        break;\n-\n-    case TOK_EOF:\n-    case TOK_NULL:\n-    case TOK_PAREN_CLOSE:\n-    case TOK_SQUARE_CLOSE:\n-    case TOK_BRACE_CLOSE:\n-        throw ParseError::Unexpected(lex, tok);\n-    default:\n-        rv = TokenTree(lex.getHygiene(), mv$(tok) );\n-        return rv;\n-    }\n-\n-    ::std::vector<TokenTree>   items;\n-    if( !unwrapped )\n-        items.push_back( TokenTree(lex.getHygiene(), mv$(tok)) );\n-    while(GET_TOK(tok, lex) != closer && tok.type() != TOK_EOF)\n-    {\n-        if( tok.type() == TOK_NULL )\n-            throw ParseError::Unexpected(lex, tok);\n-        PUTBACK(tok, lex);\n-        items.push_back(Parse_TT(lex, false));\n-    }\n-    if( !unwrapped )\n-        items.push_back( TokenTree(lex.getHygiene(), mv$(tok)) );\n-    rv = TokenTree(lex.getHygiene(), mv$(items));\n-    return rv;\n-}"}, {"sha": "d8a8bc43330ecac22677b939b9b11aea33272692", "filename": "gcc/rust/mrustc_parser/parse/interpolated_fragment.cpp", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,123 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/interpolated_fragment.cpp\n- * - An \"interpolated fragment\", result of parsing e.g. :expr in a macro invocation\n- */\n-#include <iostream>\n-#include \"interpolated_fragment.hpp\"\n-#include <ast/ast.hpp>\n-#include <ast/expr.hpp> // For definition of ExprNode\n-\n-InterpolatedFragment::~InterpolatedFragment()\n-{\n-    if( m_ptr )\n-    {\n-        switch(m_type)\n-        {\n-        case InterpolatedFragment::TT:  delete reinterpret_cast<TokenTree*>(m_ptr);  break;\n-        case InterpolatedFragment::PAT: delete reinterpret_cast<AST::Pattern*>(m_ptr); break;\n-        case InterpolatedFragment::PATH:delete reinterpret_cast<AST::Path*>(m_ptr);    break;\n-        case InterpolatedFragment::TYPE:delete reinterpret_cast<TypeRef*>(m_ptr);    break;\n-        case InterpolatedFragment::EXPR:\n-        case InterpolatedFragment::STMT:\n-        case InterpolatedFragment::BLOCK:\n-            delete reinterpret_cast<AST::ExprNode*>(m_ptr);\n-            break;\n-        case InterpolatedFragment::META:\n-            delete reinterpret_cast<AST::Attribute*>(m_ptr);\n-            break;\n-        case InterpolatedFragment::ITEM:\n-            delete reinterpret_cast<AST::Named<AST::Item>*>(m_ptr);\n-            break;\n-        }\n-    }\n-}\n-\n-InterpolatedFragment::InterpolatedFragment(InterpolatedFragment&& x):\n-    m_type( x.m_type )\n-{\n-    m_ptr = x.m_ptr, x.m_ptr = nullptr;\n-}\n-InterpolatedFragment& InterpolatedFragment::operator=(InterpolatedFragment&& x)\n-{\n-    m_type = x.m_type;\n-    m_ptr = x.m_ptr, x.m_ptr = nullptr;\n-    return *this;\n-}\n-\n-InterpolatedFragment::InterpolatedFragment(InterpolatedFragment::Type type, AST::ExprNode* ptr):\n-    m_type( type ),\n-    m_ptr( ptr )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(AST::Attribute v):\n-    m_type( InterpolatedFragment::META ),\n-    m_ptr( new AST::Attribute(mv$(v)) )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(::AST::Named<::AST::Item> v):\n-    m_type( InterpolatedFragment::ITEM ),\n-    m_ptr( new ::AST::Named<::AST::Item>( mv$(v) ) )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(TokenTree v):\n-    m_type( InterpolatedFragment::TT ),\n-    m_ptr( new TokenTree(mv$(v)) )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(AST::Path v):\n-    m_type( InterpolatedFragment::PATH ),\n-    m_ptr( new AST::Path(mv$(v)) )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(AST::Pattern v):\n-    m_type( InterpolatedFragment::PAT ),\n-    m_ptr( new AST::Pattern(mv$(v)) )\n-{\n-}\n-InterpolatedFragment::InterpolatedFragment(TypeRef v):\n-    m_type( InterpolatedFragment::TYPE ),\n-    m_ptr( new TypeRef(mv$(v)) )\n-{\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, InterpolatedFragment const& x)\n-{\n-    switch(x.m_type)\n-    {\n-    case InterpolatedFragment::TT:\n-        os << \"tt[\" << x.as_tt() << \"]\";\n-        break;\n-    case InterpolatedFragment::PAT:\n-        os << \"pat[\" << *reinterpret_cast<AST::Pattern*>(x.m_ptr) << \"]\";\n-        break;\n-    case InterpolatedFragment::PATH:\n-        os << \"path[\" << *reinterpret_cast<AST::Path*>(x.m_ptr) << \"]\";\n-        break;\n-    case InterpolatedFragment::TYPE:\n-        os << \"type[\" << *reinterpret_cast<TypeRef*>(x.m_ptr) << \"]\";\n-        break;\n-\n-    case InterpolatedFragment::EXPR:\n-        os << \"expr[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n-        break;\n-    case InterpolatedFragment::STMT:\n-        os << \"stmt[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n-        break;\n-    case InterpolatedFragment::BLOCK:\n-        os << \"block[\" << *reinterpret_cast<const AST::ExprNode*>(x.m_ptr) << \"]\";\n-        break;\n-\n-    case InterpolatedFragment::META:\n-        os << \"meta[\" << *reinterpret_cast<const AST::Attribute*>(x.m_ptr) << \"]\";\n-        break;\n-    case InterpolatedFragment::ITEM: {\n-        const auto& named_item = *reinterpret_cast<const AST::Named<AST::Item>*>(x.m_ptr);\n-        os << \"item[\" << named_item.data.tag_str() << \"(\" << named_item.name << \")]\";\n-        } break;\n-    }\n-    return os;\n-}\n-"}, {"sha": "36539fb0e0ac3b14dfaf0249f0baab4a1c7c3a55", "filename": "gcc/rust/mrustc_parser/parse/interpolated_fragment.hpp", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Finterpolated_fragment.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,61 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/interpolated_fragment.hpp\n- * - An \"interpolated fragment\", result of parsing e.g. :expr in a macro invocation\n- */\n-#pragma once\n-\n-#include <cassert>\n-\n-class TypeRef;\n-class TokenTree;\n-namespace AST {\n-    class Pattern;\n-    class Path;\n-    class ExprNode;\n-    class Attribute;\n-    template<typename T> struct Named;\n-    class Item;\n-};\n-\n-\n-class InterpolatedFragment\n-{\n-public:\n-    enum Type\n-    {\n-        TT,\n-        PAT,\n-        PATH,\n-        TYPE,\n-\n-        EXPR,\n-        STMT,\n-        BLOCK,\n-\n-        META,\n-        ITEM,\n-    } m_type;\n-\n-    // Owned type-pruned pointer\n-    void*   m_ptr;\n-\n-    InterpolatedFragment(InterpolatedFragment&& );\n-    InterpolatedFragment& operator=(InterpolatedFragment&& );\n-    //InterpolatedFragment(const InterpolatedFragment& );\n-    InterpolatedFragment(TokenTree );\n-    InterpolatedFragment(::AST::Pattern);\n-    InterpolatedFragment(::AST::Path);\n-    InterpolatedFragment(::TypeRef);\n-    InterpolatedFragment(::AST::Attribute );\n-    InterpolatedFragment(::AST::Named<AST::Item> );\n-    ~InterpolatedFragment();\n-    InterpolatedFragment(Type , ::AST::ExprNode*);\n-\n-    TokenTree& as_tt() { assert(m_type == TT); return *reinterpret_cast<TokenTree*>(m_ptr); }\n-    const TokenTree& as_tt() const { assert(m_type == TT); return *reinterpret_cast<TokenTree*>(m_ptr); }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const InterpolatedFragment& x);\n-};"}, {"sha": "a71289ee21582147c6bebac9557a006e1d23d6db", "filename": "gcc/rust/mrustc_parser/parse/lex.cpp", "status": "removed", "additions": 0, "deletions": 1071, "changes": 1071, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,1071 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/lex.cpp\n- * - Lexer (converts input file to token stream)\n- */\n-#include \"lex.hpp\"\n-#include \"../common.hpp\"\n-#include \"parseerror.hpp\"\n-#include \"tokentree.hpp\"\n-#include <algorithm> // std::count\n-#include <cassert>\n-#include <cctype>\n-#include <cstdlib> // strtol\n-#include <iostream>\n-#include <typeinfo>\n-//#define TRACE_CHARS\n-//#define TRACE_RAW_TOKENS\n-\n-Lexer::Lexer(const ::std::string& filename)\n-  : m_path(filename.c_str())\n-  , m_line(1)\n-  , m_line_ofs(0)\n-  , m_istream(filename.c_str())\n-  , m_last_char_valid(false)\n-  , m_hygiene(Ident::Hygiene::new_scope()) {\n-    if (!m_istream.is_open()) {\n-        throw ::std::runtime_error(\"Unable to open file '\" + filename + \"'\");\n-    }\n-    // Consume the BOM\n-    if (this->getc_byte() == '\\xef') {\n-        if (this->getc_byte() != '\\xbb') {\n-            throw ::std::runtime_error(\"Incomplete BOM - missing \\\\xBB in second position\");\n-        }\n-        if (this->getc_byte() != '\\xbf') {\n-            throw ::std::runtime_error(\"Incomplete BOM - missing \\\\xBF in second position\");\n-        }\n-        m_line_ofs = 0;\n-    } else {\n-        m_istream.unget();\n-    }\n-}\n-\n-#define LINECOMMENT -1\n-#define BLOCKCOMMENT -2\n-#define SINGLEQUOTE -3\n-#define DOUBLEQUOTE -4\n-#define SHEBANG -5\n-\n-// NOTE: This array must be kept sorted, or symbols are will be skipped\n-#define TOKENT(str, sym) \\\n-    { sizeof(str) - 1, str, sym }\n-static const struct {\n-    unsigned char len;\n-    const char* chars;\n-    signed int type;\n-} TOKENMAP[] = {\n-    TOKENT(\"!\", TOK_EXCLAM),\n-    TOKENT(\"!=\", TOK_EXCLAM_EQUAL),\n-    TOKENT(\"\\\"\", DOUBLEQUOTE),\n-    TOKENT(\"#\", TOK_HASH),\n-    TOKENT(\"$\", TOK_DOLLAR),\n-    TOKENT(\"%\", TOK_PERCENT),\n-    TOKENT(\"%=\", TOK_PERCENT_EQUAL),\n-    TOKENT(\"&\", TOK_AMP),\n-    TOKENT(\"&&\", TOK_DOUBLE_AMP),\n-    TOKENT(\"&=\", TOK_AMP_EQUAL),\n-    TOKENT(\"'\", SINGLEQUOTE),\n-    TOKENT(\"(\", TOK_PAREN_OPEN),\n-    TOKENT(\")\", TOK_PAREN_CLOSE),\n-    TOKENT(\"*\", TOK_STAR),\n-    TOKENT(\"*=\", TOK_STAR_EQUAL),\n-    TOKENT(\"+\", TOK_PLUS),\n-    TOKENT(\"+=\", TOK_PLUS_EQUAL),\n-    TOKENT(\",\", TOK_COMMA),\n-    TOKENT(\"-\", TOK_DASH),\n-    TOKENT(\"-=\", TOK_DASH_EQUAL),\n-    TOKENT(\"->\", TOK_THINARROW),\n-    TOKENT(\".\", TOK_DOT),\n-    TOKENT(\"..\", TOK_DOUBLE_DOT),\n-    TOKENT(\"...\", TOK_TRIPLE_DOT),\n-    TOKENT(\"/\", TOK_SLASH),\n-    TOKENT(\"/*\", BLOCKCOMMENT),\n-    TOKENT(\"//\", LINECOMMENT),\n-    TOKENT(\"/=\", TOK_SLASH_EQUAL),\n-    // 0-9 :: Elsewhere\n-    TOKENT(\":\", TOK_COLON),\n-    TOKENT(\"::\", TOK_DOUBLE_COLON),\n-    TOKENT(\";\", TOK_SEMICOLON),\n-    TOKENT(\"<\", TOK_LT),\n-    TOKENT(\"<-\", TOK_THINARROW_LEFT),\n-    TOKENT(\"<<\", TOK_DOUBLE_LT),\n-    TOKENT(\"<<=\", TOK_DOUBLE_LT_EQUAL),\n-    TOKENT(\"<=\", TOK_LTE),\n-    TOKENT(\"=\", TOK_EQUAL),\n-    TOKENT(\"==\", TOK_DOUBLE_EQUAL),\n-    TOKENT(\"=>\", TOK_FATARROW),\n-    TOKENT(\">\", TOK_GT),\n-    TOKENT(\">=\", TOK_GTE),\n-    TOKENT(\">>\", TOK_DOUBLE_GT),\n-    TOKENT(\">>=\", TOK_DOUBLE_GT_EQUAL),\n-    TOKENT(\"?\", TOK_QMARK),\n-    TOKENT(\"@\", TOK_AT),\n-    // A-Z :: Elsewhere\n-    TOKENT(\"[\", TOK_SQUARE_OPEN),\n-    TOKENT(\"\\\\\", TOK_BACKSLASH),\n-    TOKENT(\"]\", TOK_SQUARE_CLOSE),\n-    TOKENT(\"^\", TOK_CARET),\n-    TOKENT(\"^=\", TOK_CARET_EQUAL),\n-    TOKENT(\"`\", TOK_BACKTICK),\n-    // a-z :: Elsewhere\n-    //TOKENT(\"b\\\"\", DOUBLEQUOTE),\n-\n-    TOKENT(\"{\", TOK_BRACE_OPEN),\n-    TOKENT(\"|\", TOK_PIPE),\n-    TOKENT(\"|=\", TOK_PIPE_EQUAL),\n-    TOKENT(\"||\", TOK_DOUBLE_PIPE),\n-    TOKENT(\"}\", TOK_BRACE_CLOSE),\n-    TOKENT(\"~\", TOK_TILDE),\n-};\n-#define LEN(arr) (sizeof(arr) / sizeof(arr[0]))\n-static const struct {\n-    unsigned char len;\n-    const char* chars;\n-    signed int type;\n-} RWORDS[] = {\n-    TOKENT(\"_\", TOK_UNDERSCORE),\n-    TOKENT(\"abstract\", TOK_RWORD_ABSTRACT),\n-    TOKENT(\"alignof\", TOK_RWORD_ALIGNOF),\n-    TOKENT(\"as\", TOK_RWORD_AS),\n-    TOKENT(\"be\", TOK_RWORD_BE),\n-    TOKENT(\"box\", TOK_RWORD_BOX),\n-    TOKENT(\"break\", TOK_RWORD_BREAK),\n-    TOKENT(\"const\", TOK_RWORD_CONST),\n-    TOKENT(\"continue\", TOK_RWORD_CONTINUE),\n-    TOKENT(\"crate\", TOK_RWORD_CRATE),\n-    TOKENT(\"do\", TOK_RWORD_DO),\n-    TOKENT(\"else\", TOK_RWORD_ELSE),\n-    TOKENT(\"enum\", TOK_RWORD_ENUM),\n-    TOKENT(\"extern\", TOK_RWORD_EXTERN),\n-    TOKENT(\"false\", TOK_RWORD_FALSE),\n-    TOKENT(\"final\", TOK_RWORD_FINAL),\n-    TOKENT(\"fn\", TOK_RWORD_FN),\n-    TOKENT(\"for\", TOK_RWORD_FOR),\n-    TOKENT(\"if\", TOK_RWORD_IF),\n-    TOKENT(\"impl\", TOK_RWORD_IMPL),\n-    TOKENT(\"in\", TOK_RWORD_IN),\n-    TOKENT(\"let\", TOK_RWORD_LET),\n-    TOKENT(\"loop\", TOK_RWORD_LOOP),\n-    TOKENT(\"match\", TOK_RWORD_MATCH),\n-    TOKENT(\"mod\", TOK_RWORD_MOD),\n-    TOKENT(\"move\", TOK_RWORD_MOVE),\n-    TOKENT(\"mut\", TOK_RWORD_MUT),\n-    TOKENT(\"offsetof\", TOK_RWORD_OFFSETOF),\n-    TOKENT(\"override\", TOK_RWORD_OVERRIDE),\n-    TOKENT(\"priv\", TOK_RWORD_PRIV),\n-    TOKENT(\"proc\", TOK_RWORD_PROC),\n-    TOKENT(\"pub\", TOK_RWORD_PUB),\n-    TOKENT(\"pure\", TOK_RWORD_PURE),\n-    TOKENT(\"ref\", TOK_RWORD_REF),\n-    TOKENT(\"return\", TOK_RWORD_RETURN),\n-    TOKENT(\"self\", TOK_RWORD_SELF),\n-    TOKENT(\"sizeof\", TOK_RWORD_SIZEOF),\n-    TOKENT(\"static\", TOK_RWORD_STATIC),\n-    TOKENT(\"struct\", TOK_RWORD_STRUCT),\n-    TOKENT(\"super\", TOK_RWORD_SUPER),\n-    TOKENT(\"trait\", TOK_RWORD_TRAIT),\n-    TOKENT(\"true\", TOK_RWORD_TRUE),\n-    TOKENT(\"type\", TOK_RWORD_TYPE),\n-    TOKENT(\"typeof\", TOK_RWORD_TYPEOF),\n-    TOKENT(\"unsafe\", TOK_RWORD_UNSAFE),\n-    TOKENT(\"unsized\", TOK_RWORD_UNSIZED),\n-    TOKENT(\"use\", TOK_RWORD_USE),\n-    TOKENT(\"virtual\", TOK_RWORD_VIRTUAL),\n-    TOKENT(\"where\", TOK_RWORD_WHERE),\n-    TOKENT(\"while\", TOK_RWORD_WHILE),\n-    TOKENT(\"yield\", TOK_RWORD_YIELD),\n-};\n-\n-signed int Lexer::getSymbol() {\n-    Codepoint ch = this->getc();\n-    // 1. lsearch for character\n-    // 2. Consume as many characters as currently match\n-    // 3. IF: a smaller character or, EOS is hit - Return current best\n-    unsigned ofs = 0;\n-    signed int best = 0;\n-    bool hit_eof = false;\n-    for (unsigned i = 0; i < LEN(TOKENMAP); i++) {\n-        const char* const chars = TOKENMAP[i].chars;\n-        const size_t len = TOKENMAP[i].len;\n-\n-        if (ofs >= len || static_cast<uint32_t>(chars[ofs]) > ch.v) {\n-            break;\n-        }\n-\n-        while (chars[ofs] && ch == chars[ofs]) {\n-            try {\n-                ch = this->getc();\n-            } catch (Lexer::EndOfFile) {\n-                ch = 0;\n-                // Prevent `ungetc` if EOF was hit\n-                hit_eof = true;\n-            }\n-            ofs++;\n-        }\n-        if (chars[ofs] == 0) {\n-            best = TOKENMAP[i].type;\n-        }\n-    }\n-\n-    if (!hit_eof) {\n-        this->ungetc();\n-    }\n-    \n-    return best;\n-}\n-\n-bool issym(Codepoint ch) {\n-    if ('0' <= ch.v && ch.v <= '9')\n-        return true;\n-    if (::std::isalpha(ch.v))\n-        return true;\n-    if (ch == '_')\n-        return true;\n-    if (ch.v >= 128)\n-        return !ch.isspace();\n-    return false;\n-}\n-\n-Position Lexer::getPosition() const {\n-    return Position(m_path, m_line, m_line_ofs);\n-}\n-\n-Ident::Hygiene Lexer::realGetHygiene() const {\n-    return m_hygiene;\n-}\n-\n-Token Lexer::realGetToken() {\n-    while (true) {\n-        Token tok = getTokenInt();\n-#ifdef TRACE_RAW_TOKENS\n-        ::std::cout << \"getTokenInt: tok = \" << tok << ::std::endl;\n-#endif\n-        switch (tok.type()) {\n-            case TOK_NEWLINE:\n-                continue;\n-            case TOK_WHITESPACE:\n-                continue;\n-            case TOK_COMMENT: {\n-                continue;\n-            }\n-            default:\n-                return tok;\n-        }\n-    }\n-}\n-\n-Token Lexer::getTokenInt() {\n-    if (!this->m_next_tokens.empty()) {\n-        auto rv = ::std::move(this->m_next_tokens.back());\n-        m_next_tokens.pop_back();\n-        return rv;\n-    }\n-    try {\n-        Codepoint ch = this->getc();\n-\n-        if (m_line == 1 && m_line_ofs == 1 && ch == '#') {\n-            switch ((ch = this->getc()).v) {\n-                case '!':\n-                    switch ((ch = this->getc()).v) {\n-                        case '/':\n-                            // SHEBANG!\n-                            while (ch != '\\n')\n-                                ch = this->getc();\n-                            return Token(TOK_NEWLINE);\n-                        case '[':\n-                            this->ungetc();\n-                            this->m_next_tokens.push_back(TOK_EXCLAM);\n-                            return Token(TOK_HASH);\n-                        default:\n-                            throw ParseError::BadChar(*this, ch.v);\n-                    }\n-                case '[':\n-                    this->ungetc();\n-                    return Token(TOK_HASH);\n-                default:\n-                    this->ungetc();\n-                    //return Token(TOK_HASH);\n-                    throw ParseError::BadChar(*this, ch.v);\n-            }\n-        }\n-\n-        if (ch == '\\n')\n-            return Token(TOK_NEWLINE);\n-        if (ch.isspace()) {\n-            while ((ch = this->getc()).isspace() && ch != '\\n')\n-                ;\n-            this->ungetc();\n-            return Token(TOK_WHITESPACE);\n-        }\n-        this->ungetc();\n-\n-        const signed int sym = this->getSymbol();\n-        if (sym == 0) {\n-            // No match at all, check for symbol\n-            auto ch = this->getc();\n-            if (ch.isdigit()) {\n-                enum eCoreType num_type = CORETYPE_ANY;\n-                enum {\n-                    BIN,\n-                    OCT,\n-                    DEC,\n-                    HEX,\n-                } num_mode = DEC;\n-\n-                // Handle integers/floats\n-                uint64_t val = 0;\n-                if (ch == '0') {\n-                    // Octal/hex handling\n-                    ch = this->getc_num();\n-                    if (ch == 'x') {\n-                        num_mode = HEX;\n-                        while ((ch = this->getc_num()).isxdigit()) {\n-                            val *= 16;\n-                            if (ch.v <= '9')\n-                                val += ch.v - '0';\n-                            else if (ch.v <= 'F')\n-                                val += ch.v - 'A' + 10;\n-                            else if (ch.v <= 'f')\n-                                val += ch.v - 'a' + 10;\n-                        }\n-                    } else if (ch == 'b') {\n-                        num_mode = BIN;\n-                        while ((ch = this->getc_num()).isdigit()) {\n-                            val *= 2;\n-                            if (ch.v == '0')\n-                                val += 0;\n-                            else if (ch.v == '1')\n-                                val += 1;\n-                            else\n-                                throw ParseError::Generic(\"Invalid digit in binary literal\");\n-                        }\n-                    } else if (ch == 'o') {\n-                        num_mode = OCT;\n-                        while ((ch = this->getc_num()).isdigit()) {\n-                            val *= 8;\n-                            if ('0' <= ch.v && ch.v <= '7')\n-                                val += ch.v - '0';\n-                            else\n-                                throw ParseError::Generic(\"Invalid digit in octal literal\");\n-                        }\n-                    } else {\n-                        num_mode = DEC;\n-                        while (ch.isdigit()) {\n-                            val *= 10;\n-                            val += ch.v - '0';\n-                            ch = this->getc_num();\n-                        }\n-                    }\n-                } else {\n-                    while (ch.isdigit()) {\n-                        val *= 10;\n-                        val += ch.v - '0';\n-                        ch = this->getc_num();\n-                    }\n-                }\n-\n-                if (ch == 'e' || ch == 'E' || ch == '.') {\n-                    if (ch == '.') {\n-                        ch = this->getc();\n-\n-                        // Double/Triple Dot\n-                        if (ch == '.') {\n-                            if (this->getc() == '.') {\n-                                this->m_next_tokens.push_back(TOK_TRIPLE_DOT);\n-                            } else {\n-                                this->ungetc();\n-                                this->m_next_tokens.push_back(TOK_DOUBLE_DOT);\n-                            }\n-                            return Token(val, CORETYPE_ANY);\n-                        }\n-\n-                        // Single dot followed by a non-digit, could be a float or an integer with a method/field access\n-                        if (!ch.isdigit()) {\n-                            this->ungetc();\n-                            if (issym(ch)) {\n-                                this->m_next_tokens.push_back(TOK_DOT);\n-                                return Token(val, CORETYPE_ANY);\n-                            } else {\n-                                double fval = static_cast<double>(val);\n-                                return Token(fval, CORETYPE_ANY);\n-                            }\n-                        } else {\n-                            // Digit, continue\n-                            // NOTE: parseFloat assumes that the '.' has been consumed, and reads digits until it hits a non-digit and then parses exponents\n-                            // - Thus, continuing here and letting the below 'ungetc' push a digit back is correct.\n-                        }\n-                    }\n-                    if (num_mode != DEC)\n-                        TODO(this->getPosition(), \"Non-decimal floats\");\n-\n-                    this->ungetc();\n-                    double fval = this->parseFloat(val);\n-                    if (issym(ch = this->getc())) {\n-                        ::std::string suffix;\n-                        while (issym(ch)) {\n-                            suffix += ch;\n-                            ch = this->getc();\n-                        }\n-                        this->ungetc();\n-\n-                        if (0)\n-                            ;\n-                        else if (suffix == \"f32\")\n-                            num_type = CORETYPE_F32;\n-                        else if (suffix == \"f64\")\n-                            num_type = CORETYPE_F64;\n-                        else\n-                            throw ParseError::Generic(FMT(\"Unknown number suffix \" << suffix));\n-                    } else {\n-                        this->ungetc();\n-                    }\n-                    return Token(fval, num_type);\n-\n-                } else if (issym(ch)) {\n-                    // Unsigned\n-                    ::std::string suffix;\n-                    while (issym(ch)) {\n-                        suffix += ch;\n-                        ch = this->getc();\n-                    }\n-                    this->ungetc();\n-\n-                    if (0)\n-                        ;\n-                    else if (suffix == \"i8\")\n-                        num_type = CORETYPE_I8;\n-                    else if (suffix == \"i16\")\n-                        num_type = CORETYPE_I16;\n-                    else if (suffix == \"i32\")\n-                        num_type = CORETYPE_I32;\n-                    else if (suffix == \"i64\")\n-                        num_type = CORETYPE_I64;\n-                    else if (suffix == \"i128\")\n-                        num_type = CORETYPE_I128;\n-                    else if (suffix == \"isize\")\n-                        num_type = CORETYPE_INT;\n-                    else if (suffix == \"u8\")\n-                        num_type = CORETYPE_U8;\n-                    else if (suffix == \"u16\")\n-                        num_type = CORETYPE_U16;\n-                    else if (suffix == \"u32\")\n-                        num_type = CORETYPE_U32;\n-                    else if (suffix == \"u64\")\n-                        num_type = CORETYPE_U64;\n-                    else if (suffix == \"u128\")\n-                        num_type = CORETYPE_U128;\n-                    else if (suffix == \"usize\")\n-                        num_type = CORETYPE_UINT;\n-                    else if (suffix == \"f32\")\n-                        num_type = CORETYPE_F32;\n-                    else if (suffix == \"f64\")\n-                        num_type = CORETYPE_F64;\n-                    else\n-                        throw ParseError::Generic(*this, FMT(\"Unknown integer suffix '\" << suffix << \"'\"));\n-                    return Token(val, num_type);\n-                } else {\n-                    this->ungetc();\n-                    return Token(val, num_type);\n-                }\n-            }\n-            // Byte/Raw strings\n-            else if (ch == 'b' || ch == 'r') {\n-                bool is_byte = false;\n-                if (ch == 'b') {\n-                    is_byte = true;\n-                    ch = this->getc();\n-                }\n-\n-                if (ch == 'r') {\n-                    return this->getTokenInt_RawString(is_byte);\n-                } else {\n-                    assert(is_byte);\n-\n-                    // Byte string\n-                    if (ch == '\"') {\n-                        ::std::string str;\n-                        while ((ch = this->getc()) != '\"') {\n-                            if (ch == '\\\\') {\n-                                auto v = this->parseEscape('\"');\n-                                if (v != ~0u) {\n-                                    if (v > 256)\n-                                        throw ParseError::Generic(*this, \"Value out of range for byte literal\");\n-                                    str += (char)v;\n-                                }\n-                            } else {\n-                                str += ch;\n-                            }\n-                        }\n-                        return Token(TOK_BYTESTRING, str);\n-                    }\n-                    // Byte constant\n-                    else if (ch == '\\'') {\n-                        // Byte constant\n-                        ch = this->getc();\n-                        if (ch == '\\\\') {\n-                            uint32_t val = this->parseEscape('\\'');\n-                            if (this->getc() != '\\'')\n-                                throw ParseError::Generic(*this, \"Multi-byte character literal\");\n-                            return Token((uint64_t)val, CORETYPE_U8);\n-                        } else {\n-                            if (this->getc() != '\\'')\n-                                throw ParseError::Generic(*this, \"Multi-byte character literal\");\n-                            return Token((uint64_t)ch.v, CORETYPE_U8);\n-                        }\n-                    } else {\n-                        assert(is_byte);\n-                        this->ungetc();\n-                        return this->getTokenInt_Identifier('b');\n-                    }\n-                }\n-            }\n-            // Symbols\n-            else if (issym(ch)) {\n-                return this->getTokenInt_Identifier(ch);\n-            } else {\n-                throw ParseError::BadChar(*this, ch.v);\n-            }\n-        } else if (sym > 0) {\n-            return Token((enum eTokenType)sym);\n-        } else {\n-            switch (sym) {\n-                case LINECOMMENT: {\n-                    // Line comment\n-                    ::std::string str;\n-                    auto ch = this->getc();\n-                    bool is_doc = false;\n-                    bool is_pdoc = false;\n-                    if (ch == '/') {\n-                        ch = this->getc();\n-                        if (ch == '/')\n-                            str += \"/\";\n-                        else\n-                            is_doc = true;\n-                    } else if (ch == '!') {\n-                        is_pdoc = true;\n-                        ch = this->getc();\n-                    }\n-                    while (ch != '\\n' && ch != '\\r') {\n-                        str += ch;\n-                        ch = this->getc();\n-                    }\n-                    this->ungetc();\n-                    if (is_doc || is_pdoc) {\n-                        //# [ doc = \"commment data\" ]\n-                        m_next_tokens.push_back(TOK_SQUARE_CLOSE);\n-                        m_next_tokens.push_back(Token(TOK_STRING, mv$(str)));\n-                        m_next_tokens.push_back(TOK_EQUAL);\n-                        m_next_tokens.push_back(Token(TOK_IDENT, \"doc\"));\n-                        m_next_tokens.push_back(TOK_SQUARE_OPEN);\n-                        if (is_pdoc)\n-                            m_next_tokens.push_back(TOK_EXCLAM);\n-                        return TOK_HASH;\n-                    }\n-                    return Token(TOK_COMMENT, str);\n-                }\n-                case BLOCKCOMMENT: {\n-                    ::std::string str;\n-                    bool is_doc = false;\n-                    bool is_pdoc = false;\n-                    ch = this->getc();\n-                    if (ch == '*') {\n-                        ch = this->getc();\n-                        if (ch == '*') {\n-                            str += \"*\";\n-                        } else\n-                            is_doc = true;\n-                    } else if (ch == '!') {\n-                        is_pdoc = true;\n-                        ch = this->getc();\n-                    }\n-                    unsigned int level = 0;\n-                    while (true) {\n-                        if (ch == '/') {\n-                            str += ch;\n-                            ch = this->getc();\n-                            if (ch == '*') {\n-                                level++;\n-                            }\n-                            str += ch;\n-                        } else {\n-                            if (ch == '*') {\n-                                ch = this->getc();\n-                                if (ch == '/') {\n-                                    if (level == 0)\n-                                        break;\n-                                    level--;\n-                                    str.push_back('*');\n-                                    str.push_back('/');\n-                                } else {\n-                                    str.push_back('*');\n-                                    str += ch;\n-                                }\n-                            } else {\n-                                str += ch;\n-                            }\n-                        }\n-                        ch = this->getc();\n-                    }\n-                    if (is_doc || is_pdoc) {\n-                        //# [ doc = \"commment data\" ]\n-                        m_next_tokens.push_back(TOK_SQUARE_CLOSE);\n-                        m_next_tokens.push_back(Token(TOK_STRING, mv$(str)));\n-                        m_next_tokens.push_back(TOK_EQUAL);\n-                        m_next_tokens.push_back(Token(TOK_IDENT, \"doc\"));\n-                        m_next_tokens.push_back(TOK_SQUARE_OPEN);\n-                        if (is_pdoc)\n-                            m_next_tokens.push_back(TOK_EXCLAM);\n-                        return TOK_HASH;\n-                    }\n-                    return Token(TOK_COMMENT, str);\n-                }\n-                case SINGLEQUOTE: {\n-                    auto firstchar = this->getc();\n-                    if (firstchar.v == '\\\\') {\n-                        // Character constant with an escape code\n-                        uint32_t val = this->parseEscape('\\'');\n-                        if (this->getc() != '\\'') {\n-                            throw ParseError::Todo(\"Proper error for lex failures\");\n-                        }\n-                        return Token((uint64_t)val, CORETYPE_CHAR);\n-                    } else {\n-                        ch = this->getc();\n-                        if (ch == '\\'') {\n-                            // Character constant\n-                            return Token((uint64_t)firstchar.v, CORETYPE_CHAR);\n-                        } else if (issym(firstchar.v)) {\n-                            // Lifetime name\n-                            ::std::string str;\n-                            str += firstchar;\n-                            while (issym(ch)) {\n-                                str += ch;\n-                                ch = this->getc();\n-                            }\n-                            this->ungetc();\n-                            return Token(TOK_LIFETIME, str);\n-                        } else {\n-                            throw ParseError::Todo(\"Lex Fail - Expected ' after character constant\");\n-                        }\n-                    }\n-                    break;\n-                }\n-                case DOUBLEQUOTE: {\n-                    ::std::string str;\n-                    while ((ch = this->getc()) != '\"') {\n-                        if (ch == '\\\\') {\n-                            auto v = this->parseEscape('\"');\n-                            if (v != ~0u) {\n-                                str += Codepoint(v);\n-                            }\n-                        } else {\n-                            str += ch;\n-                        }\n-                    }\n-                    return Token(TOK_STRING, str);\n-                }\n-                default:\n-                    assert(!\"bugcheck\");\n-            }\n-        }\n-    } catch (const Lexer::EndOfFile& /*e*/) {\n-        return Token(TOK_EOF);\n-    }\n-\n-    throw \"Fell off the end of getTokenInt\";\n-}\n-\n-Token Lexer::getTokenInt_RawString(bool is_byte) {\n-    // Raw string (possibly byte)\n-    Codepoint ch = this->getc();\n-    unsigned int hashes = 0;\n-    while (ch == '#') {\n-        hashes++;\n-        ch = this->getc();\n-    }\n-\n-    if (hashes == 0 && ch != '\"') {\n-        this->ungetc(); // Unget the not '\"'\n-        if (is_byte)\n-            return this->getTokenInt_Identifier('b', 'r');\n-        else\n-            return this->getTokenInt_Identifier('r');\n-    }\n-    auto terminator = ch;\n-    ::std::string val;\n-    DEBUG(\"terminator = '\" << terminator << \"', hashes = \" << hashes);\n-\n-    unsigned terminating_hashes = 0;\n-\n-    for (;;) {\n-        try {\n-            ch = this->getc();\n-        } catch (const Lexer::EndOfFile& /*e*/) {\n-            throw ParseError::Generic(*this, \"EOF reached in raw string\");\n-        }\n-\n-        if (terminating_hashes > 0) {\n-            assert(terminating_hashes > 0);\n-            if (ch != '#') {\n-                val += terminator;\n-                while (terminating_hashes < hashes) {\n-                    val += '#';\n-                    terminating_hashes += 1;\n-                }\n-                terminating_hashes = 0;\n-\n-                this->ungetc();\n-            } else {\n-                terminating_hashes -= 1;\n-                if (terminating_hashes == 0) {\n-                    break;\n-                }\n-            }\n-        } else {\n-            if (ch == terminator) {\n-                if (hashes == 0) {\n-                    break;\n-                }\n-                terminating_hashes = hashes;\n-            } else {\n-                val += ch;\n-            }\n-        }\n-    }\n-\n-    return Token(is_byte ? TOK_BYTESTRING : TOK_STRING, val);\n-}\n-Token Lexer::getTokenInt_Identifier(Codepoint leader, Codepoint leader2) {\n-    ::std::string str;\n-    \n-    if (leader2 != '\\0')\n-        str += leader;\n-\n-    auto ch = leader2 == '\\0' ? leader : leader2;\n-\n-    while (issym(ch)) {\n-        str += ch;\n-        ch = this->getc();\n-    }\n-\n-    this->ungetc();\n-    for (unsigned int i = 0; i < LEN(RWORDS); i++) {\n-        if (str < RWORDS[i].chars)\n-            break;\n-        if (str == RWORDS[i].chars)\n-            return Token((enum eTokenType)RWORDS[i].type);\n-    }\n-    return Token(TOK_IDENT, mv$(str));\n-}\n-\n-// Takes the VERY lazy way of reading the float into a string then passing to strtod\n-double Lexer::parseFloat(uint64_t whole) {\n-    const int MAX_LEN = 63;\n-    const int MAX_SIG = MAX_LEN - 1 - 4;\n-    char buf[MAX_LEN + 1];\n-    int ofs = snprintf(buf, MAX_LEN + 1, \"%llu.\", (unsigned long long)whole);\n-\n-    auto ch = this->getc_num();\n-#define PUTC(ch)                                          \\\n-    do {                                                  \\\n-        if (ofs < MAX_SIG) {                              \\\n-            assert(ch.v < 127);                           \\\n-            buf[ofs] = ch.v;                              \\\n-            ofs++;                                        \\\n-        } else {                                          \\\n-            throw ParseError::Generic(\"Oversized float\"); \\\n-        }                                                 \\\n-    } while (0)\n-    while (ch.isdigit()) {\n-        PUTC(ch);\n-        ch = this->getc_num();\n-    }\n-\n-    if (ch == 'e' || ch == 'E') {\n-        PUTC(ch);\n-        ch = this->getc_num();\n-        if (ch == '-' || ch == '+') {\n-            PUTC(ch);\n-            ch = this->getc_num();\n-        }\n-        if (!ch.isdigit())\n-            throw ParseError::Generic(FMT(\"Non-numeric '\" << ch << \"' in float exponent\"));\n-        do {\n-            PUTC(ch);\n-            ch = this->getc_num();\n-        } while (ch.isdigit());\n-    }\n-\n-    this->ungetc();\n-    buf[ofs] = 0;\n-\n-    DEBUG(\"buf = \" << buf << \", ch = '\" << ch << \"'\");\n-\n-    return ::std::strtod(buf, NULL);\n-}\n-\n-uint32_t Lexer::parseEscape(char enclosing) {\n-    auto ch = this->getc();\n-\n-    switch (ch.v) {\n-        case 'x': {\n-            ch = this->getc();\n-            if (!ch.isxdigit())\n-                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n-            char tmp[3] = { static_cast<char>(ch.v), 0, 0 };\n-            ch = this->getc();\n-            if (!ch.isxdigit())\n-                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n-            tmp[1] = static_cast<char>(ch.v);\n-            return ::std::strtol(tmp, NULL, 16);\n-        } break;\n-        case 'u': {\n-            // Unicode (up to six hex digits)\n-            uint32_t val = 0;\n-            ch = this->getc();\n-            bool req_close_brace = false;\n-            if (ch == '{') {\n-                req_close_brace = true;\n-                ch = this->getc();\n-            }\n-            if (!ch.isxdigit())\n-                throw ParseError::Generic(*this, FMT(\"Found invalid character '\\\\x\" << ::std::hex << ch.v << \"' in \\\\u sequence\"));\n-            while (ch.isxdigit()) {\n-                char tmp[2] = { static_cast<char>(ch.v), 0 };\n-                val *= 16;\n-                val += ::std::strtol(tmp, NULL, 16);\n-                ch = this->getc();\n-            }\n-            if (!req_close_brace)\n-                this->ungetc();\n-            else if (ch != '}')\n-                throw ParseError::Generic(*this, \"Expected terminating } in \\\\u sequence\");\n-            else {\n-            }\n-            return val;\n-        }\n-\n-        case '0':\n-            return '\\0';\n-        case '\\\\':\n-            return '\\\\';\n-        case '\\'':\n-            return '\\'';\n-        case '\"':\n-            return '\"';\n-        case 'r':\n-            return '\\r';\n-        case 'n':\n-            return '\\n';\n-        case 't':\n-            return '\\t';\n-        case '\\r':\n-        case '\\n':\n-            while (ch.isspace())\n-                ch = this->getc();\n-            if (ch == '\\\\')\n-                return parseEscape(enclosing);\n-            else if (ch == enclosing) {\n-                this->ungetc();\n-                return ~0;\n-            } else\n-                return ch.v;\n-        default:\n-            throw ParseError::Todo(FMT(\"Unknown escape sequence \\\\\" << ch));\n-    }\n-}\n-\n-char Lexer::getc_byte() {\n-    int rv = m_istream.get();\n-    if (rv == EOF || m_istream.eof())\n-        throw Lexer::EndOfFile();\n-\n-    if (rv == '\\n') {\n-        m_line++;\n-        m_line_ofs = 0;\n-    }\n-\n-    return rv;\n-}\n-\n-Codepoint Lexer::getc() {\n-    if (m_last_char_valid) {\n-        m_last_char_valid = false;\n-#ifdef TRACE_CHARS\n-        ::std::cout << \"getc(): U+\" << ::std::hex << m_last_char.v << \" (cached)\" << ::std::endl;\n-#endif\n-    } else {\n-        m_last_char = this->getc_cp();\n-        m_line_ofs += 1;\n-#ifdef TRACE_CHARS\n-        ::std::cout << \"getc(): U+\" << ::std::hex << m_last_char.v << ::std::endl;\n-#endif\n-    }\n-\n-    return m_last_char;\n-}\n-\n-Codepoint Lexer::getc_num() {\n-    Codepoint ch;\n-\n-    do {\n-        ch = this->getc();\n-    } while (ch == '_');\n-\n-    return ch;\n-}\n-Codepoint Lexer::getc_cp() {\n-    uint8_t v1 = this->getc_byte();\n-\n-    if (v1 < 128) {\n-        return { v1 };\n-    } else if ((v1 & 0xC0) == 0x80) {\n-        // Invalid (continuation)\n-        return { 0xFFFE };\n-    } else if ((v1 & 0xE0) == 0xC0) {\n-        // Two bytes\n-        uint8_t e1 = this->getc_byte();\n-        if ((e1 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-\n-        uint32_t outval = ((v1 & 0x1F) << 6) | ((e1 & 0x3F) << 0);\n-        return { outval };\n-    } else if ((v1 & 0xF0) == 0xE0) {\n-        // Three bytes\n-        uint8_t e1 = this->getc_byte();\n-        if ((e1 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-        uint8_t e2 = this->getc_byte();\n-        if ((e2 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-\n-        uint32_t outval = ((v1 & 0x0F) << 12) | ((e1 & 0x3F) << 6) | ((e2 & 0x3F) << 0);\n-        return { outval };\n-    } else if ((v1 & 0xF8) == 0xF0) {\n-        // Four bytes\n-        uint8_t e1 = this->getc_byte();\n-        if ((e1 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-        uint8_t e2 = this->getc_byte();\n-        if ((e2 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-        uint8_t e3 = this->getc_byte();\n-        if ((e3 & 0xC0) != 0x80)\n-            return { 0xFFFE };\n-\n-        uint32_t outval = ((v1 & 0x07) << 18) | ((e1 & 0x3F) << 12) | ((e2 & 0x3F) << 6) | ((e3 & 0x3F) << 0);\n-        return { outval };\n-    } else {\n-        throw ParseError::Generic(\"Invalid UTF-8 (too long)\");\n-    }\n-}\n-\n-void Lexer::ungetc() {\n-#ifdef TRACE_CHARS\n-    ::std::cout << \"ungetc(): cache U+\" << ::std::hex << m_last_char.v << ::std::endl;\n-#endif\n-    assert(!m_last_char_valid);\n-    m_last_char_valid = true;\n-}\n-\n-// --------------------------------------------------------------------\n-// Codepoint - Unicode codepoint.\n-// --------------------------------------------------------------------\n-\n-bool Codepoint::isspace() const {\n-    switch (this->v) {\n-        case '\\t':\n-        case '\\r':\n-        case '\\n':\n-        case ' ':\n-        case 0xC: // ^L\n-        case 0x85:\n-        case 0x200E:\n-        case 0x200F: // LTR / RTL markers\n-        case 0x2028: // Line Separator\n-        case 0x2029: // Paragrah Separator\n-            return true;\n-        default:\n-            return false;\n-    }\n-}\n-\n-bool Codepoint::isdigit() const {\n-    return this->v < 128 && std::isdigit(static_cast<int>(this->v));\n-}\n-\n-bool Codepoint::isxdigit() const {\n-    return this->v < 128 && std::isxdigit(static_cast<int>(this->v));\n-}\n-\n-::std::string& operator+=(::std::string& s, const Codepoint& cp) {\n-    if (cp.v < 0x80) {\n-        s += (char)cp.v;\n-    } else if (cp.v < (0x1F + 1) << (1 * 6)) {\n-\n-        s += (char)(0xC0 | ((cp.v >> 6) & 0x1F));\n-        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else if (cp.v < (0x0F + 1) << (2 * 6)) {\n-        s += (char)(0xE0 | ((cp.v >> 12) & 0x0F));\n-        s += (char)(0x80 | ((cp.v >> 6) & 0x3F));\n-        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else if (cp.v < (0x07 + 1) << (3 * 6)) {\n-        s += (char)(0xF0 | ((cp.v >> 18) & 0x07));\n-        s += (char)(0x80 | ((cp.v >> 12) & 0x3F));\n-        s += (char)(0x80 | ((cp.v >> 6) & 0x3F));\n-        s += (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else {\n-        throw ::std::runtime_error(FMT(\"BUGCHECK: Bad unicode codepoint encountered - \" << ::std::hex << cp.v));\n-    }\n-    return s;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const Codepoint& cp) {\n-    if (cp.v < 0x80) {\n-        os << (char)cp.v;\n-    } else if (cp.v < (0x1F + 1) << (1 * 6)) {\n-        os << (char)(0xC0 | ((cp.v >> 6) & 0x1F));\n-        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else if (cp.v < (0x0F + 1) << (2 * 6)) {\n-        os << (char)(0xE0 | ((cp.v >> 12) & 0x0F));\n-        os << (char)(0x80 | ((cp.v >> 6) & 0x3F));\n-        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else if (cp.v < (0x07 + 1) << (2 * 6)) {\n-        os << (char)(0xF0 | ((cp.v >> 18) & 0x07));\n-        os << (char)(0x80 | ((cp.v >> 12) & 0x3F));\n-        os << (char)(0x80 | ((cp.v >> 6) & 0x3F));\n-        os << (char)(0x80 | ((cp.v >> 0) & 0x3F));\n-    } else {\n-        throw ::std::runtime_error(\"BUGCHECK: Bad unicode codepoint encountered\");\n-    }\n-    return os;\n-}\n-\n-Token Lex_FindOperator(const ::std::string& s) {\n-    if (s == \"_\")\n-        return TOK_UNDERSCORE;\n-    for (size_t i = 0; i < LEN(TOKENMAP); i++) {\n-        const auto& e = TOKENMAP[i];\n-        if (s < e.chars)\n-            break;\n-        if (s == e.chars) {\n-            if (e.type < 0)\n-                break;\n-            return static_cast<eTokenType>(e.type);\n-        }\n-    }\n-    return TOK_NULL;\n-}\n-\n-Token Lex_FindReservedWord(const ::std::string& s) {\n-    for (size_t i = 0; i < LEN(RWORDS); i++) {\n-        const auto& e = RWORDS[i];\n-        if (s < e.chars)\n-            break;\n-        if (s == e.chars) {\n-            assert(e.type > 0);\n-            return static_cast<eTokenType>(e.type);\n-        }\n-    }\n-    return TOK_NULL;\n-}"}, {"sha": "7ff0003e1f570cc36a2d040c299163fb080a5b2a", "filename": "gcc/rust/mrustc_parser/parse/lex.hpp", "status": "removed", "additions": 0, "deletions": 80, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Flex.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,80 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/lex.hpp\n- * - Lexer header\n- */\n-#ifndef LEX_HPP_INCLUDED\n-#define LEX_HPP_INCLUDED\n-\n-#include <string>\n-#include <fstream>\n-#include \"tokenstream.hpp\"\n-\n-struct Codepoint {\n-    uint32_t    v;\n-    Codepoint(): v(0) { }\n-    Codepoint(uint32_t v): v(v) { }\n-    bool isspace() const;\n-    bool isdigit() const;\n-    bool isxdigit() const;\n-    bool operator==(char x) { return v == static_cast<uint32_t>(x); }\n-    bool operator!=(char x) { return v != static_cast<uint32_t>(x); }\n-    bool operator==(Codepoint x) { return v == x.v; }\n-    bool operator!=(Codepoint x) { return v != x.v; }\n-};\n-extern ::std::string& operator+=(::std::string& s, const Codepoint& cp);\n-extern ::std::ostream& operator<<(::std::ostream& s, const Codepoint& cp);\n-\n-extern Token Lex_FindOperator(const ::std::string& s);\n-extern Token Lex_FindReservedWord(const ::std::string& s);\n-\n-typedef Codepoint   uchar;\n-\n-class Lexer:\n-    public TokenStream\n-{\n-    RcString    m_path;\n-    unsigned int m_line;\n-    unsigned int m_line_ofs;\n-\n-    ::std::ifstream m_istream;\n-    bool    m_last_char_valid;\n-    Codepoint   m_last_char;\n-    ::std::vector<Token>    m_next_tokens;\n-\n-    Ident::Hygiene m_hygiene;\n-public:\n-    Lexer(const ::std::string& filename);\n-\n-    Position getPosition() const override;\n-    Ident::Hygiene realGetHygiene() const override;\n-    Token realGetToken() override;\n-\n-private:\n-    Token getTokenInt();\n-\n-    signed int getSymbol();\n-    Token getTokenInt_RawString(bool is_byte);\n-    Token getTokenInt_Identifier(Codepoint ch, Codepoint ch2='\\0');\n-    double parseFloat(uint64_t whole);\n-    uint32_t parseEscape(char enclosing);\n-\n-    void push_hygine() override {\n-        m_hygiene = Ident::Hygiene::new_scope_chained(m_hygiene);\n-    }\n-    void pop_hygine() override {\n-        m_hygiene = m_hygiene.get_parent();\n-    }\n-\n-    void ungetc();\n-    Codepoint getc_num();\n-    Codepoint getc();\n-    Codepoint getc_cp();\n-    char getc_byte();\n-\n-    class EndOfFile {};\n-};\n-\n-#endif // LEX_HPP_INCLUDED"}, {"sha": "1bb309857b5b5e6293d567fdf285471c9b620263", "filename": "gcc/rust/mrustc_parser/parse/parseerror.cpp", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,91 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/parseerror.cpp\n- * - Exceptions thrown for different types of parsing errors\n- */\n-#include \"parseerror.hpp\"\n-#include <iostream>\n-\n-CompileError::Base::~Base() throw()\n-{\n-}\n-\n-CompileError::Generic::Generic(::std::string message):\n-    m_message(message)\n-{\n-    ::std::cout << \"Generic(\" << message << \")\" << ::std::endl;\n-}\n-CompileError::Generic::Generic(const TokenStream& lex, ::std::string message)\n-{\n-    ::std::cout << lex.point_span() << \": Generic(\" << message << \")\" << ::std::endl;\n-}\n-\n-CompileError::BugCheck::BugCheck(const TokenStream& lex, ::std::string message):\n-    m_message(message)\n-{\n-    ::std::cout << lex.point_span() << \"BugCheck(\" << message << \")\" << ::std::endl;\n-}\n-CompileError::BugCheck::BugCheck(::std::string message):\n-    m_message(message)\n-{\n-    ::std::cout << \"BugCheck(\" << message << \")\" << ::std::endl;\n-}\n-\n-CompileError::Todo::Todo(::std::string message):\n-    m_message(message)\n-{\n-    ::std::cout << \"Todo(\" << message << \")\" << ::std::endl;\n-}\n-CompileError::Todo::Todo(const TokenStream& lex, ::std::string message):\n-    m_message(message)\n-{\n-    ::std::cout << lex.point_span() << \": Todo(\" << message << \")\" << ::std::endl;\n-}\n-CompileError::Todo::~Todo() throw()\n-{\n-}\n-\n-ParseError::BadChar::BadChar(const TokenStream& lex, char character)\n-{\n-    ::std::cout << lex.point_span() << \": BadChar(\" << character << \")\" << ::std::endl;\n-}\n-ParseError::BadChar::~BadChar() throw()\n-{\n-}\n-\n-ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok)//:\n-//    m_tok( mv$(tok) )\n-{\n-    Span pos = tok.get_pos();\n-    if(pos.filename == \"\")\n-        pos = lex.point_span();\n-    ::std::cout << pos << \": Unexpected(\" << tok << \")\" << ::std::endl;\n-}\n-ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok, Token exp)//:\n-//    m_tok( mv$(tok) )\n-{\n-    Span pos = tok.get_pos();\n-    if(pos.filename == \"\")\n-        pos = lex.point_span();\n-    ::std::cout << pos << \": Unexpected(\" << tok << \", \" << exp << \")\" << ::std::endl;\n-}\n-ParseError::Unexpected::Unexpected(const TokenStream& lex, const Token& tok, ::std::vector<eTokenType> exp)\n-{\n-    Span pos = tok.get_pos();\n-    if(pos.filename == \"\")\n-        pos = lex.point_span();\n-    ::std::cout << pos << \": Unexpected \" << tok << \", expected \";\n-    bool f = true;\n-    for(auto v: exp) {\n-        if(!f)\n-            ::std::cout << \" or \";\n-        f = false;\n-        ::std::cout << Token::typestr(v);\n-    }\n-    ::std::cout << ::std::endl;\n-}\n-ParseError::Unexpected::~Unexpected() throw()\n-{\n-}"}, {"sha": "d6e2b03e3b6f6e2db7dbbfdbcd923e1a081ed1a9", "filename": "gcc/rust/mrustc_parser/parse/parseerror.hpp", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fparseerror.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,47 +0,0 @@\n-/*\n- * MRustC - Mutabah's Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/parseerror.hpp\n- * - Exception classes for parsing/lexing errors\n- */\n-#ifndef PARSEERROR_HPP_INCLUDED\n-#define PARSEERROR_HPP_INCLUDED\n-\n-#include <stdexcept>\n-#include \"tokenstream.hpp\"\n-#include <compile_error.hpp>\n-\n-namespace ParseError {\n-\n-using CompileError::Generic;\n-using CompileError::BugCheck;\n-using CompileError::Todo;\n-\n-class BadChar:\n-    public CompileError::Base\n-{\n-    //char    m_char;\n-public:\n-    BadChar(const TokenStream& lex, char character);\n-    virtual ~BadChar() throw ();\n-\n-};\n-\n-class Unexpected:\n-    public CompileError::Base\n-{\n-    Token   m_tok;\n-public:\n-    Unexpected(const TokenStream& lex, const Token& tok);\n-    Unexpected(const TokenStream& lex, const Token& tok, Token exp);\n-    Unexpected(const TokenStream& lex, const Token& tok, ::std::vector<eTokenType> exp);\n-    virtual ~Unexpected() throw ();\n-\n-};\n-\n-#define ASSERT(lex, cnd)    do { if( !(cnd) ) throw CompileError::BugCheck(lex, \"Assertion failed: \" __FILE__ \" - \" #cnd); } while(0)\n-\n-}\n-\n-#endif // PARSEERROR_HPP_INCLUDED"}, {"sha": "d103840e9e9ff832557bca02eb64496f3d68cc11", "filename": "gcc/rust/mrustc_parser/parse/paths.cpp", "status": "removed", "additions": 0, "deletions": 254, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpaths.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,254 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/paths.cpp\n- * - Parsing for module paths\n- */\n-#include \"parseerror.hpp\"\n-#include \"common.hpp\"\n-#include \"../ast/ast.hpp\"\n-\n-AST::Path   Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode);\n-AST::Path   Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode);\n-::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode);\n-AST::PathParams Parse_Path_GenericList(TokenStream& lex);\n-\n-AST::Path Parse_Path(TokenStream& lex, eParsePathGenericMode generic_mode)\n-{\n-    TRACE_FUNCTION_F(\"generic_mode=\"<<generic_mode);\n-\n-    Token   tok;\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_INTERPOLATED_PATH:\n-        return mv$(tok.frag_path());\n-\n-    case TOK_RWORD_SELF:\n-        GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-        return AST::Path(AST::Path::TagSelf(), Parse_PathNodes(lex, generic_mode));\n-\n-    case TOK_RWORD_SUPER: {\n-        GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-        unsigned int count = 1;\n-        while( LOOK_AHEAD(lex) == TOK_RWORD_SUPER ) {\n-            count += 1;\n-            GET_TOK(tok, lex);\n-            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-        }\n-        return AST::Path(AST::Path::TagSuper(), count, Parse_PathNodes(lex, generic_mode));\n-        }\n-\n-    case TOK_DOUBLE_COLON:\n-        return Parse_Path(lex, true, generic_mode);\n-\n-    case TOK_DOUBLE_LT:\n-        lex.putback( Token(TOK_LT) );\n-    case TOK_LT: {\n-        TypeRef ty = Parse_Type(lex, true);  // Allow trait objects without parens\n-        if( GET_TOK(tok, lex) == TOK_RWORD_AS ) {\n-            ::AST::Path trait;\n-            if( GET_TOK(tok, lex) == TOK_DOUBLE_COLON ) {\n-                trait = Parse_Path(lex, true, PATH_GENERIC_TYPE);\n-            }\n-            else {\n-                PUTBACK(tok, lex);\n-                trait = Parse_Path(lex, false, PATH_GENERIC_TYPE);\n-            }\n-            GET_CHECK_TOK(tok, lex, TOK_GT);\n-            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-            return AST::Path(AST::Path::TagUfcs(), mv$(ty), mv$(trait), Parse_PathNodes(lex, generic_mode));\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-            GET_CHECK_TOK(tok, lex, TOK_GT);\n-            // TODO: Terminating the \"path\" here is sometimes valid?\n-            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-            // NOTE: <Foo>::BAR is actually `<Foo as _>::BAR` (in mrustc parleance)\n-            //return AST::Path(AST::Path::TagUfcs(), mv$(ty), Parse_PathNodes(lex, generic_mode));\n-            return AST::Path(AST::Path::TagUfcs(), mv$(ty), AST::Path(), Parse_PathNodes(lex, generic_mode));\n-        }\n-        throw \"\"; }\n-\n-    default:\n-        PUTBACK(tok, lex);\n-        return Parse_Path(lex, false, generic_mode);\n-    }\n-}\n-AST::Path Parse_Path(TokenStream& lex, bool is_abs, eParsePathGenericMode generic_mode)\n-{\n-    Token   tok;\n-    if( is_abs )\n-    {\n-        if( GET_TOK(tok, lex) == TOK_STRING ) {\n-            ::std::string   cratename = tok.str();\n-            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-            return AST::Path(cratename, Parse_PathNodes(lex, generic_mode));\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-            return AST::Path(\"\", Parse_PathNodes(lex, generic_mode));\n-        }\n-    }\n-    else {\n-        // TODO: TOK_INTERPOLATED_IDENT?\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        auto hygine = lex.getHygiene();\n-        PUTBACK(tok, lex);\n-        return AST::Path(AST::Path::TagRelative(), mv$(hygine), Parse_PathNodes(lex, generic_mode));\n-    }\n-}\n-\n-::std::vector<AST::PathNode> Parse_PathNodes(TokenStream& lex, eParsePathGenericMode generic_mode)\n-{\n-    TRACE_FUNCTION_F(\"generic_mode=\"<<generic_mode);\n-\n-    Token tok;\n-    ::std::vector<AST::PathNode>    ret;\n-\n-    tok = lex.getToken();\n-    while(true)\n-    {\n-        ::AST::PathParams   params;\n-\n-        CHECK_TOK(tok, TOK_IDENT);\n-        auto component = mv$( tok.str() );\n-\n-        GET_TOK(tok, lex);\n-        if( generic_mode == PATH_GENERIC_TYPE )\n-        {\n-            if( tok.type() == TOK_LT || tok.type() == TOK_DOUBLE_LT )\n-            {\n-                // HACK! Handle breaking << into < <\n-                if( tok.type() == TOK_DOUBLE_LT )\n-                    lex.putback( Token(TOK_LT) );\n-\n-                // Type-mode generics \"::path::to::Type<A,B>\"\n-                params = Parse_Path_GenericList(lex);\n-                GET_TOK(tok, lex);\n-            }\n-            // HACK - 'Fn*(...) -> ...' notation\n-            else if( tok.type() == TOK_PAREN_OPEN )\n-            {\n-                auto ps = lex.start_span();\n-                DEBUG(\"Fn() hack\");\n-                ::std::vector<TypeRef>  args;\n-                if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n-                {\n-                    // Empty list\n-                }\n-                else\n-                {\n-                    PUTBACK(tok, lex);\n-                    do {\n-                        // TODO: Trailing commas\n-                        args.push_back( Parse_Type(lex) );\n-                    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-                }\n-                CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-\n-                TypeRef ret_type = TypeRef( TypeRef::TagUnit(), Span(tok.get_pos()) );\n-                if( GET_TOK(tok, lex) == TOK_THINARROW ) {\n-                    ret_type = Parse_Type(lex, false);\n-                }\n-                else {\n-                    PUTBACK(tok, lex);\n-                }\n-                DEBUG(\"- Fn(\"<<args<<\")->\"<<ret_type<<\"\");\n-\n-                // Encode into path, by converting Fn(A,B)->C into Fn<(A,B),Ret=C>\n-                params = ::AST::PathParams {\n-                    {},\n-                    ::make_vec1( TypeRef(TypeRef::TagTuple(), lex.end_span(ps), mv$(args)) ),\n-                    ::make_vec1( ::std::make_pair( ::std::string(\"Output\"), mv$(ret_type) ) )\n-                    };\n-\n-                GET_TOK(tok, lex);\n-            }\n-            else\n-            {\n-            }\n-        }\n-        if( tok.type() != TOK_DOUBLE_COLON ) {\n-            ret.push_back( AST::PathNode(component, mv$(params)) );\n-            break;\n-        }\n-        tok = lex.getToken();\n-        if( generic_mode == PATH_GENERIC_EXPR && (tok.type() == TOK_LT || tok.type() == TOK_DOUBLE_LT) )\n-        {\n-            // HACK! Handle breaking << into < <\n-            if( tok.type() == TOK_DOUBLE_LT )\n-                lex.putback( Token(TOK_LT) );\n-\n-            // Expr-mode generics \"::path::to::function::<Type1,Type2>(arg1, arg2)\"\n-            params = Parse_Path_GenericList(lex);\n-            if( GET_TOK(tok, lex) != TOK_DOUBLE_COLON ) {\n-                ret.push_back( AST::PathNode(component, mv$(params)) );\n-                // Break out of loop down to return\n-                break;\n-            }\n-            // Match with CHECK_TOK at start of loop\n-            GET_TOK(tok, lex);\n-        }\n-        ret.push_back( AST::PathNode(component, mv$(params)) );\n-    }\n-    PUTBACK(tok, lex);\n-    DEBUG(\"ret = \" << ret);\n-    return ret;\n-}\n-/// Parse a list of parameters within a path\n-::AST::PathParams Parse_Path_GenericList(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    ::std::vector<TypeRef>  types;\n-    ::std::vector<AST::LifetimeRef>   lifetimes;\n-    ::std::vector< ::std::pair< ::std::string, TypeRef > > assoc_bounds;\n-\n-    do {\n-        if( LOOK_AHEAD(lex) == TOK_GT || LOOK_AHEAD(lex) == TOK_DOUBLE_GT || LOOK_AHEAD(lex) == TOK_GTE || LOOK_AHEAD(lex) == TOK_DOUBLE_GT_EQUAL ) {\n-            GET_TOK(tok, lex);\n-            break;\n-        }\n-        switch(GET_TOK(tok, lex))\n-        {\n-        case TOK_LIFETIME:\n-            lifetimes.push_back(AST::LifetimeRef(/*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n-            break;\n-        case TOK_IDENT:\n-            if( LOOK_AHEAD(lex) == TOK_EQUAL )\n-            {\n-                ::std::string name = mv$(tok.str());\n-                GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-                assoc_bounds.push_back( ::std::make_pair( mv$(name), Parse_Type(lex,false) ) );\n-                break;\n-            }\n-        default:\n-            PUTBACK(tok, lex);\n-            types.push_back( Parse_Type(lex) );\n-            break;\n-        }\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-\n-    // HACK: Split >> into >\n-    if(tok.type() == TOK_DOUBLE_GT_EQUAL) {\n-        lex.putback(Token(TOK_GTE));\n-    }\n-    else if(tok.type() == TOK_GTE) {\n-        lex.putback(Token(TOK_EQUAL));\n-    }\n-    else if(tok.type() == TOK_DOUBLE_GT) {\n-        lex.putback(Token(TOK_GT));\n-    }\n-    else {\n-        CHECK_TOK(tok, TOK_GT);\n-    }\n-\n-    return ::AST::PathParams {\n-        mv$( lifetimes ),\n-        mv$( types ),\n-        mv$( assoc_bounds )\n-        };\n-}\n-"}, {"sha": "e2949a632ea80327447b5cfd0f19aad6436a59d0", "filename": "gcc/rust/mrustc_parser/parse/pattern.cpp", "status": "removed", "additions": 0, "deletions": 526, "changes": 526, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fpattern.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,526 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/pattern.cpp\n- * - Parsing for patterns\n- */\n-#include \"common.hpp\"\n-#include \"parseerror.hpp\"\n-#include <ast/expr.hpp> // To convert :expr\n-\n-// NEWNODE is needed for the Value pattern type\n-typedef ::std::unique_ptr<AST::ExprNode>    ExprNodeP;\n-#define NEWNODE(type, ...)  ExprNodeP(new type(__VA_ARGS__))\n-using AST::ExprNode;\n-\n-\n-\n-::AST::Pattern::TuplePat Parse_PatternTuple(TokenStream& lex, bool is_refutable);\n-AST::Pattern Parse_PatternReal_Slice(TokenStream& lex, bool is_refutable);\n-AST::Pattern Parse_PatternReal_Path(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable);\n-AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable);\n-AST::Pattern Parse_PatternStruct(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable);\n-\n-AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable);\n-AST::Pattern Parse_PatternReal1(TokenStream& lex, bool is_refutable);\n-\n-\n-/// Parse a pattern\n-///\n-/// Examples:\n-/// - `Enum::Variant(a)`\n-/// - `(1, a)`\n-/// - `1 ... 2`\n-/// - `\"string\"`\n-/// - `mut x`\n-/// - `mut x @ 1 ... 2`\n-AST::Pattern Parse_Pattern(TokenStream& lex, bool is_refutable)\n-{\n-    TRACE_FUNCTION;\n-    auto ps = lex.start_span();\n-\n-    Token   tok;\n-    tok = lex.getToken();\n-\n-    if( tok.type() == TOK_IDENT && lex.lookahead(0) == TOK_EXCLAM )\n-    {\n-        lex.getToken();\n-        return AST::Pattern( AST::Pattern::TagMacro(), lex.end_span(ps), box$(Parse_MacroInvocation(ps, tok.str(), lex)));\n-    }\n-    if( tok.type() == TOK_INTERPOLATED_PATTERN )\n-    {\n-        return mv$(tok.frag_pattern());\n-    }\n-\n-    bool expect_bind = false;\n-    auto bind_type = AST::PatternBinding::Type::MOVE;\n-    bool is_mut = false;\n-    // 1. Mutablity + Reference\n-    if( tok.type() == TOK_RWORD_REF )\n-    {\n-        expect_bind = true;\n-        tok = lex.getToken();\n-        if( tok.type() == TOK_RWORD_MUT )\n-        {\n-            bind_type = AST::PatternBinding::Type::MUTREF;\n-            GET_TOK(tok, lex);\n-        }\n-        else\n-        {\n-            bind_type = AST::PatternBinding::Type::REF;\n-        }\n-    }\n-    else if( tok.type() == TOK_RWORD_MUT )\n-    {\n-        is_mut = true;\n-        expect_bind = true;\n-        GET_TOK(tok, lex);\n-    }\n-    else\n-    {\n-        // Fall through\n-    }\n-\n-    AST::PatternBinding binding;\n-    // If a 'ref' or 'mut' annotation was seen, the next name must be a binding name\n-    if( expect_bind )\n-    {\n-        CHECK_TOK(tok, TOK_IDENT);\n-        auto bind_name = Ident(lex.getHygiene(), mv$(tok.str()));\n-        // If there's no '@' after it, it's a name binding only (_ pattern)\n-        if( GET_TOK(tok, lex) != TOK_AT )\n-        {\n-            PUTBACK(tok, lex);\n-            return AST::Pattern(AST::Pattern::TagBind(), lex.end_span(mv$(ps)), mv$(bind_name), bind_type, is_mut);\n-        }\n-        binding = AST::PatternBinding( mv$(bind_name), bind_type, is_mut );\n-\n-        // '@' consumed, move on to next token\n-        GET_TOK(tok, lex);\n-    }\n-    // Otherwise, handle MaybeBind\n-    else if( tok.type() == TOK_IDENT )\n-    {\n-        switch( LOOK_AHEAD(lex) )\n-        {\n-        // Known path `ident::`\n-        case TOK_DOUBLE_COLON:\n-            break;\n-        // Known struct `Ident {` or `Ident (`\n-        case TOK_BRACE_OPEN:\n-        case TOK_PAREN_OPEN:\n-            break;\n-        // Known value `IDENT ...`\n-        case TOK_TRIPLE_DOT:\n-            break;\n-        // Known binding `ident @`\n-        case TOK_AT:\n-            binding = AST::PatternBinding( Ident(lex.getHygiene(), mv$(tok.str())), bind_type/*MOVE*/, is_mut/*false*/ );\n-            GET_TOK(tok, lex);  // '@'\n-            GET_TOK(tok, lex);  // Match lex.putback() below\n-            break;\n-        default: {  // Maybe bind\n-            Ident   name = Ident(lex.getHygiene(), mv$(tok.str()));\n-            // if the pattern can be refuted (i.e this could be an enum variant), return MaybeBind\n-            if( is_refutable ) {\n-                assert(bind_type == ::AST::PatternBinding::Type::MOVE);\n-                assert(is_mut == false);\n-                return AST::Pattern(AST::Pattern::TagMaybeBind(), lex.end_span(mv$(ps)), mv$(name));\n-            }\n-            // Otherwise, it IS a binding\n-            else {\n-                return AST::Pattern(AST::Pattern::TagBind(), lex.end_span(mv$(ps)), mv$(name), bind_type, is_mut);\n-            }\n-            break;}\n-        }\n-    }\n-    else\n-    {\n-        // Otherwise, fall through\n-    }\n-\n-    PUTBACK(tok, lex);\n-    auto pat = Parse_PatternReal(lex, is_refutable);\n-    pat.binding() = mv$(binding);\n-    return pat;\n-}\n-\n-AST::Pattern Parse_PatternReal(TokenStream& lex, bool is_refutable)\n-{\n-    Token   tok;\n-    if( LOOK_AHEAD(lex) == TOK_INTERPOLATED_PATTERN )\n-    {\n-        GET_TOK(tok, lex);\n-        return mv$(tok.frag_pattern());\n-    }\n-    auto ps = lex.start_span();\n-    AST::Pattern    ret = Parse_PatternReal1(lex, is_refutable);\n-    if( GET_TOK(tok, lex) == TOK_TRIPLE_DOT )\n-    {\n-        if( !ret.data().is_Value() )\n-            throw ParseError::Generic(lex, \"Using '...' with a non-value on left\");\n-        auto& ret_v = ret.data().as_Value();\n-\n-        auto    right_pat = Parse_PatternReal1(lex, is_refutable);\n-        if( !right_pat.data().is_Value() )\n-            throw ParseError::Generic(lex, \"Using '...' with a non-value on right\");\n-        auto    rightval = mv$( right_pat.data().as_Value().start );\n-        ret_v.end = mv$(rightval);\n-        // TODO: use `ps` here?\n-\n-        return ret;\n-    }\n-    else\n-    {\n-        PUTBACK(tok, lex);\n-        return ret;\n-    }\n-}\n-AST::Pattern Parse_PatternReal1(TokenStream& lex, bool is_refutable)\n-{\n-    TRACE_FUNCTION;\n-    auto ps = lex.start_span();\n-\n-    Token   tok;\n-    AST::Path   path;\n-\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_UNDERSCORE:\n-        return AST::Pattern( lex.end_span(mv$(ps)), AST::Pattern::Data() );\n-    //case TOK_DOUBLE_DOT:\n-    //    return AST::Pattern( AST::Pattern::TagWildcard() );\n-    case TOK_RWORD_BOX:\n-        return AST::Pattern( AST::Pattern::TagBox(), lex.end_span(mv$(ps)), Parse_Pattern(lex, is_refutable) );\n-    case TOK_DOUBLE_AMP:\n-        lex.putback(TOK_AMP);\n-    case TOK_AMP: {\n-        DEBUG(\"Ref\");\n-        // NOTE: Falls back into \"Pattern\" not \"PatternReal\" to handle MaybeBind again\n-        bool is_mut = false;\n-        if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n-            is_mut = true;\n-        else\n-            PUTBACK(tok, lex);\n-        return AST::Pattern( AST::Pattern::TagReference(), lex.end_span(mv$(ps)), is_mut, Parse_Pattern(lex, is_refutable) );\n-        }\n-    case TOK_RWORD_SELF:\n-    case TOK_RWORD_SUPER:\n-    case TOK_IDENT:\n-    case TOK_LT:\n-    case TOK_DOUBLE_LT:\n-    case TOK_INTERPOLATED_PATH:\n-        PUTBACK(tok, lex);\n-        return Parse_PatternReal_Path( lex, ps, Parse_Path(lex, PATH_GENERIC_EXPR), is_refutable );\n-    case TOK_DOUBLE_COLON:\n-        // 2. Paths are enum/struct names\n-        return Parse_PatternReal_Path( lex, ps, Parse_Path(lex, true, PATH_GENERIC_EXPR), is_refutable );\n-    case TOK_DASH:\n-        if(GET_TOK(tok, lex) == TOK_INTEGER)\n-        {\n-            auto dt = tok.datatype();\n-            // TODO: Ensure that the type is ANY or a signed integer\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({dt, -tok.intval()}) );\n-        }\n-        else if( tok.type() == TOK_FLOAT )\n-        {\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({tok.datatype(), -tok.floatval()}) );\n-        }\n-        else\n-        {\n-            throw ParseError::Unexpected(lex, tok, {TOK_INTEGER, TOK_FLOAT});\n-        }\n-    case TOK_FLOAT:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({tok.datatype(), tok.floatval()}) );\n-    case TOK_INTEGER:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({tok.datatype(), tok.intval()}) );\n-    case TOK_RWORD_TRUE:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, 1}) );\n-    case TOK_RWORD_FALSE:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, 0}) );\n-    case TOK_STRING:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_String( mv$(tok.str()) ) );\n-    case TOK_BYTESTRING:\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_ByteString({ mv$(tok.str()) }) );\n-    case TOK_INTERPOLATED_EXPR: {\n-        auto e = tok.take_frag_node();\n-        if( auto* n = dynamic_cast<AST::ExprNode_String*>(e.get()) ) {\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_String( mv$(n->m_value) ) );\n-        }\n-        //else if( auto* n = dynamic_cast<AST::ExprNode_ByteString*>(e.get()) ) {\n-        //    return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_ByteString( mv$(n->m_value) ) );\n-        //}\n-        else if( auto* n = dynamic_cast<AST::ExprNode_Bool*>(e.get()) ) {\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({CORETYPE_BOOL, n->m_value}) );\n-        }\n-        else if( auto* n = dynamic_cast<AST::ExprNode_Integer*>(e.get()) ) {\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Integer({n->m_datatype, n->m_value}) );\n-        }\n-        else if( auto* n = dynamic_cast<AST::ExprNode_Float*>(e.get()) ) {\n-            return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Float({n->m_datatype, n->m_value}) );\n-        }\n-        else {\n-            TODO(lex.point_span(), \"Convert :expr into a pattern value - \" << *e);\n-        }\n-        } break;\n-\n-    case TOK_PAREN_OPEN:\n-        return AST::Pattern( AST::Pattern::TagTuple(), lex.end_span(mv$(ps)), Parse_PatternTuple(lex, is_refutable) );\n-    case TOK_SQUARE_OPEN:\n-        return Parse_PatternReal_Slice(lex, is_refutable);\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-}\n-AST::Pattern Parse_PatternReal_Path(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable)\n-{\n-    Token   tok;\n-\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_PAREN_OPEN:\n-        return AST::Pattern( AST::Pattern::TagNamedTuple(), lex.end_span(mv$(ps)), mv$(path), Parse_PatternTuple(lex, is_refutable) );\n-    case TOK_BRACE_OPEN:\n-        return Parse_PatternStruct(lex, ps, mv$(path), is_refutable);\n-    default:\n-        PUTBACK(tok, lex);\n-        return AST::Pattern( AST::Pattern::TagValue(), lex.end_span(mv$(ps)), AST::Pattern::Value::make_Named(mv$(path)) );\n-    }\n-}\n-\n-AST::Pattern Parse_PatternReal_Slice(TokenStream& lex, bool is_refutable)\n-{\n-    auto ps = lex.start_span();\n-    Token   tok;\n-\n-    ::std::vector< ::AST::Pattern>  leading;\n-    ::std::vector< ::AST::Pattern>  trailing;\n-    ::AST::PatternBinding   inner_binding;\n-    bool is_split = false;\n-\n-    while(GET_TOK(tok, lex) != TOK_SQUARE_CLOSE)\n-    {\n-        bool has_binding = true;\n-        ::AST::PatternBinding  binding;\n-        if( tok.type() == TOK_RWORD_REF && lex.lookahead(0) == TOK_IDENT && lex.lookahead(1) == TOK_DOUBLE_DOT ) {\n-            GET_TOK(tok, lex);\n-            binding = ::AST::PatternBinding( lex.get_ident(mv$(tok)), ::AST::PatternBinding::Type::REF, false );\n-        }\n-        else if( tok.type() == TOK_IDENT && lex.lookahead(0) == TOK_DOUBLE_DOT) {\n-            binding = ::AST::PatternBinding( lex.get_ident(mv$(tok)), ::AST::PatternBinding::Type::MOVE, false );\n-        }\n-        else if( tok.type() == TOK_UNDERSCORE && lex.lookahead(0) == TOK_DOUBLE_DOT) {\n-            // No binding, but switching to trailing\n-        }\n-        else if( tok.type() == TOK_DOUBLE_DOT ) {\n-            // No binding, but switching to trailing\n-            PUTBACK(tok, lex);\n-        }\n-        else {\n-            has_binding = false;\n-        }\n-\n-        if( has_binding ) {\n-            if(is_split)\n-                ERROR(lex.end_span(mv$(ps)), E0000, \"Multiple instances of .. in a slice pattern\");\n-\n-            inner_binding = mv$(binding);\n-            is_split = true;\n-            GET_TOK(tok, lex);  // TOK_DOUBLE_DOT\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-            if(!is_split) {\n-                leading.push_back( Parse_Pattern(lex, is_refutable) );\n-            }\n-            else {\n-                trailing.push_back( Parse_Pattern(lex, is_refutable) );\n-            }\n-        }\n-\n-        if( GET_TOK(tok, lex) != TOK_COMMA )\n-            break;\n-    }\n-    CHECK_TOK(tok, TOK_SQUARE_CLOSE);\n-\n-    if( is_split )\n-    {\n-        return ::AST::Pattern( lex.end_span(mv$(ps)), ::AST::Pattern::Data::make_SplitSlice({ mv$(leading), mv$(inner_binding), mv$(trailing) }) );\n-    }\n-    else\n-    {\n-        assert( !inner_binding.is_valid() );\n-        assert( trailing.empty() );\n-        return ::AST::Pattern( lex.end_span(mv$(ps)), ::AST::Pattern::Data::make_Slice({ mv$(leading) }) );\n-    }\n-}\n-\n-::AST::Pattern::TuplePat Parse_PatternTuple(TokenStream& lex, bool is_refutable)\n-{\n-    TRACE_FUNCTION;\n-    auto sp = lex.start_span();\n-    Token tok;\n-\n-    ::std::vector<AST::Pattern> leading;\n-    while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE && LOOK_AHEAD(lex) != TOK_DOUBLE_DOT )\n-    {\n-        leading.push_back( Parse_Pattern(lex, is_refutable) );\n-\n-        if( GET_TOK(tok, lex) != TOK_COMMA ) {\n-            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-            return AST::Pattern::TuplePat { mv$(leading), false, {} };\n-        }\n-    }\n-\n-    if( LOOK_AHEAD(lex) != TOK_DOUBLE_DOT )\n-    {\n-        GET_TOK(tok, lex);\n-\n-        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-        return AST::Pattern::TuplePat { mv$(leading), false, {} };\n-    }\n-    GET_CHECK_TOK(tok, lex, TOK_DOUBLE_DOT);\n-\n-    ::std::vector<AST::Pattern> trailing;\n-    if( GET_TOK(tok, lex) == TOK_COMMA )\n-    {\n-        while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE )\n-        {\n-            trailing.push_back( Parse_Pattern(lex, is_refutable) );\n-\n-            if( GET_TOK(tok, lex) != TOK_COMMA ) {\n-                PUTBACK(tok, lex);\n-                break;\n-            }\n-        }\n-        GET_TOK(tok, lex);\n-    }\n-\n-    CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-    return ::AST::Pattern::TuplePat { mv$(leading), true, mv$(trailing) };\n-}\n-\n-AST::Pattern Parse_PatternStruct(TokenStream& lex, ProtoSpan ps, AST::Path path, bool is_refutable)\n-{\n-    TRACE_FUNCTION;\n-    Token tok;\n-\n-    // #![feature(relaxed_adts)]\n-    if( LOOK_AHEAD(lex) == TOK_INTEGER )\n-    {\n-        bool split_allowed = false;\n-        ::std::map<unsigned int, AST::Pattern> pats;\n-        while( GET_TOK(tok, lex) == TOK_INTEGER )\n-        {\n-            unsigned int ofs = static_cast<unsigned int>(tok.intval());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            auto val = Parse_Pattern(lex, is_refutable);\n-            if( ! pats.insert( ::std::make_pair(ofs, mv$(val)) ).second ) {\n-                ERROR(lex.point_span(), E0000, \"Duplicate index\");\n-            }\n-\n-            if( GET_TOK(tok,lex) == TOK_BRACE_CLOSE )\n-                break;\n-            CHECK_TOK(tok, TOK_COMMA);\n-        }\n-        if( tok.type() == TOK_DOUBLE_DOT ) {\n-            split_allowed = true;\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-        bool has_split = false;\n-        ::std::vector<AST::Pattern> leading;\n-        ::std::vector<AST::Pattern> trailing;\n-        unsigned int i = 0;\n-        for(auto& p : pats)\n-        {\n-            if( p.first != i ) {\n-                if( has_split || !split_allowed ) {\n-                    ERROR(lex.point_span(), E0000, \"Missing index \" << i);\n-                }\n-                has_split = true;\n-                i = p.first;\n-            }\n-            if( ! has_split ) {\n-                leading.push_back( mv$(p.second) );\n-            }\n-            else {\n-                trailing.push_back( mv$(p.second) );\n-            }\n-            i ++;\n-        }\n-\n-        return AST::Pattern(AST::Pattern::TagNamedTuple(), lex.end_span(mv$(ps)), mv$(path),  AST::Pattern::TuplePat { mv$(leading), has_split, mv$(trailing) });\n-    }\n-\n-    bool is_exhaustive = true;\n-    ::std::vector< ::std::pair< ::std::string, AST::Pattern> >  subpats;\n-    do {\n-        GET_TOK(tok, lex);\n-        DEBUG(\"tok = \" << tok);\n-        if( tok.type() == TOK_BRACE_CLOSE )\n-            break;\n-        if( tok.type() == TOK_DOUBLE_DOT ) {\n-            is_exhaustive = false;\n-            GET_TOK(tok, lex);\n-            break;\n-        }\n-\n-        auto inner_ps = lex.start_span();\n-        bool is_short_bind = false;\n-        bool is_box = false;\n-        auto bind_type = AST::PatternBinding::Type::MOVE;\n-        bool is_mut = false;\n-        if( tok.type() == TOK_RWORD_BOX ) {\n-            is_box = true;\n-            is_short_bind = true;\n-            GET_TOK(tok, lex);\n-        }\n-        if( tok.type() == TOK_RWORD_REF ) {\n-            is_short_bind = true;\n-            GET_TOK(tok, lex);\n-            if( tok.type() == TOK_RWORD_MUT ) {\n-                bind_type = AST::PatternBinding::Type::MUTREF;\n-                GET_TOK(tok, lex);\n-            }\n-            else {\n-                bind_type = AST::PatternBinding::Type::REF;\n-            }\n-        }\n-        else if( tok.type() == TOK_RWORD_MUT ) {\n-            is_mut = true;\n-            is_short_bind = true;\n-            GET_TOK(tok, lex);\n-        }\n-\n-        CHECK_TOK(tok, TOK_IDENT);\n-        auto field_ident = lex.get_ident(mv$(tok));\n-        ::std::string field_name;\n-        GET_TOK(tok, lex);\n-\n-        AST::Pattern    pat;\n-        if( is_short_bind || tok.type() != TOK_COLON ) {\n-            PUTBACK(tok, lex);\n-            pat = AST::Pattern(lex.end_span(inner_ps), {});\n-            field_name = field_ident.name;\n-            pat.set_bind(mv$(field_ident), bind_type, is_mut);\n-            if( is_box )\n-            {\n-                pat = AST::Pattern(AST::Pattern::TagBox(), lex.end_span(inner_ps), mv$(pat));\n-            }\n-        }\n-        else {\n-            CHECK_TOK(tok, TOK_COLON);\n-            field_name = mv$(field_ident.name);\n-            pat = Parse_Pattern(lex, is_refutable);\n-        }\n-\n-        subpats.push_back( ::std::make_pair(mv$(field_name), mv$(pat)) );\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-    return AST::Pattern(AST::Pattern::TagStruct(), lex.end_span(mv$(ps)), ::std::move(path), ::std::move(subpats), is_exhaustive);\n-}\n-"}, {"sha": "d799f09dfad283d7231f530e2f56806fcb7b2a94", "filename": "gcc/rust/mrustc_parser/parse/root.cpp", "status": "removed", "additions": 0, "deletions": 1999, "changes": 1999, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Froot.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,1999 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/root.cpp\n- * - Parsing at the module level (highest-level parsing)\n- *\n- * Entrypoint:\n- * - Parse_Crate : Handles crate attrbutes, and passes on to Parse_ModRoot\n- * - Parse_ModRoot\n- */\n-#include <ast/ast.hpp>\n-#include <ast/crate.hpp>\n-#include \"parseerror.hpp\"\n-#include \"common.hpp\"\n-#include <cassert>\n-#include <hir/hir.hpp>  // ABI_RUST - TODO: Move elsewhere?\n-#include <expand/cfg.hpp>   // check_cfg - for `mod nonexistant;`\n-#include <fstream>  // Used by directory path\n-#include \"lex.hpp\"  // New file lexer\n-#include <ast/expr.hpp>\n-\n-template<typename T>\n-Spanned<T> get_spanned(TokenStream& lex, ::std::function<T()> f) {\n-    auto ps = lex.start_span();\n-    auto v = f();\n-    return Spanned<T> {\n-        lex.end_span( mv$(ps) ),\n-        mv$(v)\n-        };\n-}\n-#define GET_SPANNED(type, lex, val) get_spanned< type >(lex, [&](){ return val; })\n-\n-// Check the next two tokens\n-#define LOOKAHEAD2(lex, tok1, tok2) ((lex).lookahead(0) == (tok1) && (lex).lookahead(1) == (tok2))\n-\n-::std::string dirname(::std::string input) {\n-    while( input.size() > 0 && input.back() != '/' && input.back() != '\\\\' ) {\n-        input.pop_back();\n-    }\n-    return input;\n-}\n-\n-AST::AttributeList Parse_ItemAttrs(TokenStream& lex);\n-void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out);\n-AST::Attribute  Parse_MetaItem(TokenStream& lex);\n-void Parse_ModRoot(TokenStream& lex, AST::Module& mod, AST::AttributeList& mod_attrs);\n-bool Parse_MacroInvocation_Opt(TokenStream& lex,  AST::MacroInvocation& out_inv);\n-\n-//::AST::Path Parse_Publicity(TokenStream& lex)\n-bool Parse_Publicity(TokenStream& lex, bool allow_restricted=true)\n-{\n-    Token   tok;\n-    if( LOOK_AHEAD(lex) == TOK_RWORD_PUB )\n-    {\n-        GET_TOK(tok, lex);\n-        if( LOOK_AHEAD(lex) == TOK_PAREN_OPEN )\n-        {\n-            // HACK: tuple structs have a parsing ambiguity around `pub (self::Type,)`\n-            if( !allow_restricted )\n-            {\n-                if( lex.lookahead(1) == TOK_RWORD_IN )\n-                    ;\n-                else if( lex.lookahead(1) == TOK_RWORD_CRATE && lex.lookahead(2) == TOK_PAREN_CLOSE )\n-                    ;\n-                else if( lex.lookahead(1) == TOK_RWORD_SUPER && lex.lookahead(2) == TOK_PAREN_CLOSE )\n-                    ;\n-                else if( lex.lookahead(1) == TOK_RWORD_SELF && lex.lookahead(2) == TOK_PAREN_CLOSE )\n-                    ;\n-                else\n-                    return true;\n-            }\n-            auto    path = AST::Path(\"\", {});\n-            // Restricted publicity.\n-            GET_TOK(tok, lex);  // '('\n-\n-            switch(GET_TOK(tok, lex))\n-            {\n-            case TOK_RWORD_CRATE:\n-                // Crate visibility\n-                break;\n-            case TOK_RWORD_SELF:\n-                // Private!\n-                path = AST::Path( lex.parse_state().get_current_mod().path() );\n-                break;\n-            case TOK_RWORD_SUPER:\n-                path = AST::Path( lex.parse_state().get_current_mod().path() );\n-                path.nodes().pop_back();\n-                while( lex.lookahead(0) == TOK_DOUBLE_COLON && lex.lookahead(1) == TOK_RWORD_SUPER )\n-                {\n-                    GET_TOK(tok, lex);\n-                    GET_TOK(tok, lex);\n-                    path.nodes().pop_back();\n-                }\n-                if( lex.lookahead(0) != TOK_DOUBLE_COLON )\n-                    break;\n-                GET_TOK(tok, lex);\n-                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            case TOK_RWORD_IN:\n-                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                path.nodes().push_back( AST::PathNode(tok.str()) );\n-                while( LOOK_AHEAD(lex) == TOK_DOUBLE_COLON )\n-                {\n-                    GET_TOK(tok, lex);\n-                    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                    path.nodes().push_back( AST::PathNode(tok.str()) );\n-                }\n-                break;\n-            default:\n-                throw ParseError::Unexpected(lex, tok);\n-            }\n-            GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n-        }\n-        return true;\n-    }\n-    else\n-    {\n-        return false;\n-    }\n-}\n-\n-::AST::HigherRankedBounds Parse_HRB(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    ::AST::HigherRankedBounds   rv;\n-    GET_CHECK_TOK(tok, lex, TOK_LT);\n-    do {\n-        // Support empty lists and comma-terminated lists\n-        if( lex.lookahead(0) == TOK_GT ) {\n-            GET_TOK(tok, lex);\n-            break;\n-        }\n-        auto attrs = Parse_ItemAttrs(lex);\n-\n-        switch(GET_TOK(tok, lex))\n-        {\n-        case TOK_LIFETIME:\n-            rv.m_lifetimes.push_back(::AST::LifetimeParam(lex.point_span(), ::std::move(attrs), Ident(lex.getHygiene(), tok.str())));\n-            break;\n-        default:\n-            throw ParseError::Unexpected(lex, tok, Token(TOK_LIFETIME));\n-        }\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-    CHECK_TOK(tok, TOK_GT);\n-    return rv;\n-}\n-::AST::HigherRankedBounds Parse_HRB_Opt(TokenStream& lex)\n-{\n-    if( lex.lookahead(0) == TOK_RWORD_FOR )\n-    {\n-        lex.getToken(); // Consume\n-        return Parse_HRB(lex);\n-    }\n-    else\n-    {\n-        return ::AST::HigherRankedBounds();\n-    }\n-}\n-\n-namespace {\n-    AST::LifetimeRef get_LifetimeRef(TokenStream& lex, Token tok)\n-    {\n-        CHECK_TOK(tok, TOK_LIFETIME);\n-        return AST::LifetimeRef(/*lex.point_span(), */Ident(lex.getHygiene(), mv$(tok.str())));\n-    }\n-}\n-/// Parse type parameters in a definition\n-void Parse_TypeBound(TokenStream& lex, AST::GenericParams& ret, TypeRef checked_type, \n-    AST::HigherRankedBounds outer_hrbs = {})\n-{\n-    TRACE_FUNCTION;\n-    Token tok;\n-\n-    do\n-    {\n-        // If an item terminator is seen (end of item, start of body, list separator), return early.\n-        //if( LOOK_AHEAD(lex) == TOK_SEMICOLON || LOOK_AHEAD(lex) == TOK_COMMA )\n-        //{\n-        //    return;\n-        //}\n-\n-        if(GET_TOK(tok, lex) == TOK_LIFETIME) {\n-            ret.add_bound(AST::GenericBound::make_TypeLifetime( {\n-                checked_type.clone(), get_LifetimeRef(lex, mv$(tok))\n-                } ));\n-        }\n-        else if( tok.type() == TOK_QMARK ) {\n-            auto hrbs = Parse_HRB_Opt(lex);\n-            (void)hrbs; // The only valid ?Trait is Sized, which doesn't have any generics\n-            ret.add_bound(AST::GenericBound::make_MaybeTrait( {\n-                checked_type.clone(), Parse_Path(lex, PATH_GENERIC_TYPE)\n-                } ));\n-        }\n-        else {\n-            ::AST::HigherRankedBounds inner_hrls;\n-            if( tok.type() == TOK_RWORD_FOR )\n-            {\n-                inner_hrls = Parse_HRB(lex);\n-            }\n-            else {\n-                PUTBACK(tok, lex);\n-            }\n-            auto trait_path = Parse_Path(lex, PATH_GENERIC_TYPE);\n-\n-            auto this_outer_hrbs = (lex.lookahead(0) == TOK_PLUS ? \n-                AST::HigherRankedBounds(outer_hrbs) : mv$(outer_hrbs));\n-            ret.add_bound( AST::GenericBound::make_IsTrait({\n-                mv$(this_outer_hrbs), checked_type.clone(), mv$(inner_hrls), mv$(trait_path)\n-                }) );\n-        }\n-    } while( GET_TOK(tok, lex) == TOK_PLUS );\n-    PUTBACK(tok, lex);\n-}\n-\n-/// Parse type parameters within '<' and '>' (definition)\n-AST::GenericParams Parse_GenericParams(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-\n-    AST::GenericParams ret;\n-    Token tok;\n-    do {\n-        if( GET_TOK(tok, lex) == TOK_GT ) {\n-            break ;\n-        }\n-\n-        PUTBACK(tok, lex);\n-        auto attrs = Parse_ItemAttrs(lex);\n-\n-        GET_TOK(tok, lex);\n-        if( tok.type() == TOK_IDENT )\n-        {\n-            ::std::string param_name = mv$(tok.str());\n-            ret.add_ty_param( AST::TypeParam( lex.point_span(), ::std::move(attrs), param_name ) );\n-\n-            auto param_ty = TypeRef(lex.point_span(), param_name);\n-            if( GET_TOK(tok, lex) == TOK_COLON )\n-            {\n-                Parse_TypeBound(lex, ret, mv$(param_ty));\n-                GET_TOK(tok, lex);\n-            }\n-\n-            if( tok.type() == TOK_EQUAL )\n-            {\n-                ret.ty_params().back().setDefault( Parse_Type(lex) );\n-                GET_TOK(tok, lex);\n-            }\n-        }\n-        else if( tok.type() == TOK_LIFETIME )\n-        {\n-            auto param_name = tok.str();\n-            auto ref = get_LifetimeRef(lex, mv$(tok));\n-            ret.add_lft_param(::AST::LifetimeParam(lex.point_span(), ::std::move(attrs), \n-                Ident(lex.getHygiene(), param_name) ));\n-            if( GET_TOK(tok, lex) == TOK_COLON )\n-            {\n-                do {\n-                    GET_CHECK_TOK(tok, lex, TOK_LIFETIME);\n-                    ret.add_bound(AST::GenericBound::make_Lifetime({ AST::LifetimeRef(ref), \n-                        get_LifetimeRef(lex, mv$(tok)) }));\n-                } while( GET_TOK(tok, lex) == TOK_PLUS );\n-            }\n-        }\n-        else\n-        {\n-            throw ParseError::Unexpected(lex, tok, {TOK_IDENT, TOK_LIFETIME});\n-        }\n-    } while( tok.type() == TOK_COMMA );\n-    PUTBACK(tok, lex);\n-    return ret;\n-}\n-\n-\n-/// Parse the contents of a 'where' clause\n-void Parse_WhereClause(TokenStream& lex, AST::GenericParams& params)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    do {\n-        GET_TOK(tok, lex);\n-        if( tok.type() == TOK_BRACE_OPEN ) {\n-            break;\n-        }\n-\n-        if( tok.type() == TOK_LIFETIME )\n-        {\n-            auto lhs = get_LifetimeRef(lex, mv$(tok));\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            do {\n-                GET_CHECK_TOK(tok, lex, TOK_LIFETIME);\n-                auto rhs = get_LifetimeRef(lex, mv$(tok));\n-                params.add_bound( AST::GenericBound::make_Lifetime({lhs, rhs}) );\n-            } while( GET_TOK(tok, lex) == TOK_PLUS );\n-            PUTBACK(tok, lex);\n-        }\n-        // Higher-ranked types/lifetimes\n-        else if( tok.type() == TOK_RWORD_FOR )\n-        {\n-            auto hrbs = Parse_HRB(lex);\n-\n-            TypeRef type = Parse_Type(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            Parse_TypeBound(lex,params, mv$(type), mv$(hrbs));\n-        }\n-        else\n-        {\n-            PUTBACK(tok, lex);\n-            TypeRef type = Parse_Type(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            Parse_TypeBound(lex, params, mv$(type));\n-        }\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-    PUTBACK(tok, lex);\n-}\n-\n-// Parse a single function argument\n-::std::pair< AST::Pattern, TypeRef> Parse_Function_Arg(TokenStream& lex, bool expect_named)\n-{\n-    TRACE_FUNCTION_F(\"expect_named = \" << expect_named);\n-    Token   tok;\n-\n-    AST::Pattern pat;\n-\n-    // If any of the following\n-    // - Expecting a named parameter (i.e. defining a function in root or impl)\n-    // - Next token is an underscore (only valid as a pattern here)\n-    // - Next token is 'mut' (a mutable parameter slot)\n-    // - Next two are <ident> ':' (a trivial named parameter)\n-    // NOTE: When not expecting a named param, destructuring patterns are not allowed\n-    if( expect_named\n-      || LOOK_AHEAD(lex) == TOK_UNDERSCORE\n-      || LOOK_AHEAD(lex) == TOK_RWORD_MUT\n-      || (LOOK_AHEAD(lex) == TOK_IDENT && lex.lookahead(1) == TOK_COLON)\n-      )\n-    {\n-        // Function args can't be refuted\n-        pat = Parse_Pattern(lex, false);\n-        GET_CHECK_TOK(tok, lex, TOK_COLON);\n-    }\n-\n-    TypeRef type = Parse_Type(lex);\n-\n-\n-    return ::std::make_pair( ::std::move(pat), ::std::move(type) );\n-}\n-\n-/// Parse a function definition (after the 'fn <name>')\n-AST::Function Parse_FunctionDef(TokenStream& lex, ::std::string abi, bool allow_self, \n-    bool can_be_prototype,  bool is_unsafe, bool is_const)\n-{\n-    TRACE_FUNCTION;\n-    ProtoSpan   ps = lex.start_span();\n-\n-    Token   tok;\n-\n-    // Parameters\n-    AST::GenericParams params;\n-    if( GET_TOK(tok, lex) == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    AST::Function::Arglist  args;\n-\n-    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n-    GET_TOK(tok, lex);\n-\n-    // Handle self\n-    if( tok.type() == TOK_AMP )\n-    {\n-        // By-reference method?\n-\n-        unsigned int ofs = 0;\n-        // Handle a lifetime parameter name\n-        if( lex.lookahead(0) == TOK_LIFETIME )\n-            ofs ++;\n-\n-        if( lex.lookahead(ofs) == TOK_RWORD_SELF || (lex.lookahead(ofs) == TOK_RWORD_MUT \n-            && lex.lookahead(ofs+1) == TOK_RWORD_SELF) )\n-        {\n-            auto ps = lex.start_span();\n-            AST::LifetimeRef lifetime;\n-            if( GET_TOK(tok, lex) == TOK_LIFETIME ) {\n-                lifetime = get_LifetimeRef(lex, mv$(tok));\n-                GET_TOK(tok, lex);\n-            }\n-\n-            bool is_mut = false;\n-            if( tok.type() == TOK_RWORD_MUT )\n-            {\n-                is_mut = true;\n-                GET_TOK(tok, lex);\n-            }\n-            CHECK_TOK(tok, TOK_RWORD_SELF);\n-            auto sp = lex.end_span(ps);\n-            args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), sp, \"self\"), \n-                TypeRef(TypeRef::TagReference(), sp, ::std::move(lifetime), is_mut, \n-                TypeRef(sp, \"Self\", 0xFFFF))) );\n-            if( allow_self == false )\n-                throw ParseError::Generic(lex, \"Self binding not expected\");\n-\n-            // Prime tok for next step\n-            GET_TOK(tok, lex);\n-        }\n-        else\n-        {\n-            // Unbound method\n-        }\n-    }\n-    else if( tok.type() == TOK_RWORD_MUT )\n-    {\n-        if( LOOK_AHEAD(lex) == TOK_RWORD_SELF )\n-        {\n-            GET_TOK(tok, lex);\n-            if( allow_self == false )\n-                throw ParseError::Generic(lex, \"Self binding not expected\");\n-            auto binding_sp = lex.end_span(ps);\n-            TypeRef ty = TypeRef( lex.point_span(), \"Self\", 0xFFFF );\n-            if( GET_TOK(tok, lex) == TOK_COLON ) {\n-                // Typed mut self\n-                ty = Parse_Type(lex);\n-            }\n-            else {\n-                PUTBACK(tok, lex);\n-            }\n-            args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), binding_sp, \n-                \"self\"), mv$(ty)) );\n-            GET_TOK(tok, lex);\n-        }\n-    }\n-    else if( tok.type() == TOK_RWORD_SELF )\n-    {\n-        // By-value method\n-        if( allow_self == false )\n-            throw ParseError::Generic(lex, \"Self binding not expected\");\n-        auto binding_sp = lex.end_span(ps);\n-        TypeRef ty = TypeRef( lex.point_span(), \"Self\", 0xFFFF );\n-        if( GET_TOK(tok, lex) == TOK_COLON ) {\n-            // Typed mut self\n-            ty = Parse_Type(lex);\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-        }\n-        args.push_back( ::std::make_pair( AST::Pattern(AST::Pattern::TagBind(), binding_sp, \"self\"), \n-            mv$(ty)) );\n-        GET_TOK(tok, lex);\n-    }\n-    else\n-    {\n-        // Unbound method\n-    }\n-\n-    bool    is_variadic = false;\n-    if( tok.type() != TOK_PAREN_CLOSE )\n-    {\n-        // Comma after self\n-        if( args.size() )\n-        {\n-            CHECK_TOK(tok, TOK_COMMA);\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-        }\n-\n-        // Argument list\n-        do {\n-            if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE ) {\n-                GET_TOK(tok, lex);\n-                break;\n-            }\n-            if( LOOK_AHEAD(lex) == TOK_TRIPLE_DOT ) {\n-                GET_TOK(tok, lex);\n-                is_variadic = true;\n-                GET_TOK(tok, lex);\n-                break;\n-            }\n-            args.push_back( Parse_Function_Arg(lex, !can_be_prototype) );\n-        } while( GET_TOK(tok, lex) == TOK_COMMA );\n-        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-    }\n-    else {\n-        // Eat 'tok', negative comparison\n-    }\n-\n-    TypeRef ret_type = TypeRef(TypeRef::TagUnit(), Span(tok.get_pos()));\n-    if( GET_TOK(tok, lex) == TOK_THINARROW )\n-    {\n-        // Return type\n-        ret_type = Parse_Type(lex);\n-    }\n-    else\n-    {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n-    {\n-        Parse_WhereClause(lex, params);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    return AST::Function(lex.end_span( mv$(ps) ), mv$(params), mv$(abi), is_unsafe, is_const, \n-        is_variadic, mv$(ret_type), mv$(args));\n-}\n-\n-AST::Function Parse_FunctionDefWithCode(TokenStream& lex, ::std::string abi, bool allow_self, \n-    bool is_unsafe, bool is_const)\n-{\n-    Token   tok;\n-    auto ret = Parse_FunctionDef(lex, abi, allow_self, false,  is_unsafe, is_const);\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n-    // Enter a new hygine scope for the function (TODO: Should this be in Parse_ExprBlock?)\n-    lex.push_hygine();\n-    PUTBACK(tok, lex);\n-    ret.set_code( Parse_ExprBlock(lex) );\n-    lex.pop_hygine();\n-    return ret;\n-}\n-\n-AST::TypeAlias Parse_TypeAlias(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-\n-    // Params\n-    AST::GenericParams params;\n-    if( GET_TOK(tok, lex) == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-        GET_TOK(tok, lex);\n-    }\n-\n-    if( tok.type() == TOK_RWORD_WHERE )\n-    {\n-        Parse_WhereClause(lex, params);\n-        GET_TOK(tok, lex);\n-    }\n-    CHECK_TOK(tok, TOK_EQUAL);\n-\n-    // Type\n-    TypeRef type = Parse_Type(lex);\n-    GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-\n-    return AST::TypeAlias( ::std::move(params), ::std::move(type) );\n-}\n-\n-AST::Struct Parse_Struct(TokenStream& lex, const AST::AttributeList& meta_items)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-\n-    tok = lex.getToken();\n-    AST::GenericParams params;\n-    if( tok.type() == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n-        {\n-            Parse_WhereClause(lex, params);\n-            tok = lex.getToken();\n-        }\n-    }\n-    if(tok.type() == TOK_PAREN_OPEN)\n-    {\n-        // Tuple structs\n-        ::std::vector<AST::TupleItem>  refs;\n-        while(lex.lookahead(0) != TOK_PAREN_CLOSE)\n-        {\n-            auto item_attrs = Parse_ItemAttrs(lex);\n-            SET_ATTRS(lex, item_attrs);\n-\n-            bool    is_pub = Parse_Publicity(lex, /*allow_restricted=*/false);  // HACK: Disable `pub(restricted)` syntax in tuple structs, due to ambiguity\n-\n-            refs.push_back( AST::TupleItem( mv$(item_attrs), is_pub, Parse_Type(lex) ) );\n-            if( GET_TOK(tok, lex) != TOK_COMMA ) {\n-                PUTBACK(tok, lex);\n-                break;\n-            }\n-        }\n-        GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n-\n-        if(LOOK_AHEAD(lex) == TOK_RWORD_WHERE)\n-        {\n-            GET_TOK(tok, lex);\n-            Parse_WhereClause(lex, params);\n-        }\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-        //if( refs.size() == 0 )\n-        //    WARNING( , W000, \"Use 'struct Name;' instead of 'struct Name();' ... ning-nong\");\n-        return AST::Struct(mv$(params), mv$(refs));\n-    }\n-    else if(tok.type() == TOK_SEMICOLON)\n-    {\n-        // Unit-like struct\n-        return AST::Struct(mv$(params));\n-    }\n-    else if(tok.type() == TOK_BRACE_OPEN)\n-    {\n-        ::std::vector<AST::StructItem>  items;\n-        while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n-        {\n-            PUTBACK(tok, lex);\n-\n-            auto item_attrs = Parse_ItemAttrs(lex);\n-            SET_ATTRS(lex, item_attrs);\n-\n-            bool is_pub = Parse_Publicity(lex);\n-\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            TypeRef type = Parse_Type(lex);\n-\n-            items.push_back( AST::StructItem( mv$(item_attrs), is_pub, mv$(name), mv$(type) ) );\n-            if(GET_TOK(tok, lex) == TOK_BRACE_CLOSE)\n-                break;\n-            CHECK_TOK(tok, TOK_COMMA);\n-        }\n-        //if( items.size() == 0 )\n-        //    WARNING( , W000, \"Use 'struct Name;' instead of 'struct Nam { };' ... ning-nong\");\n-        return AST::Struct(mv$(params), mv$(items));\n-    }\n-    else\n-    {\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-}\n-\n-AST::Trait Parse_TraitDef(TokenStream& lex, const AST::AttributeList& meta_items)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-\n-    AST::GenericParams params;\n-    if( GET_TOK(tok, lex) == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-        tok = lex.getToken();\n-    }\n-\n-    // Trait bounds \"trait Trait : 'lifetime + OtherTrait + OtherTrait2\"\n-    ::std::vector<Spanned<Type_TraitPath> >    supertraits;\n-    if(tok.type() == TOK_COLON)\n-    {\n-        // TODO: Just add these as `where Self: <foo>` (would that break typecheck?)\n-        do {\n-            if( GET_TOK(tok, lex) == TOK_LIFETIME ) {\n-                // TODO: Need a better way of indiciating 'static than just an invalid path\n-                ASSERT_BUG(lex.point_span(), tok.str() == \"static\", \n-                    \"TODO: Support lifetimes other than 'static in trait bounds\");\n-                supertraits.push_back( make_spanned( Span(tok.get_pos()), Type_TraitPath{ {}, \n-                    AST::Path() } ) );\n-            }\n-            else if( tok.type() == TOK_BRACE_OPEN ) {\n-                break;\n-            }\n-            else {\n-                PUTBACK(tok, lex);\n-                auto hrbs = Parse_HRB_Opt(lex);\n-                supertraits.push_back( GET_SPANNED(Type_TraitPath, lex, (Type_TraitPath{ mv$(hrbs), \n-                    Parse_Path(lex, PATH_GENERIC_TYPE) })) );\n-            }\n-        } while( GET_TOK(tok, lex) == TOK_PLUS );\n-    }\n-\n-    if(tok.type() == TOK_RWORD_WHERE)\n-    {\n-        //if( params.ty_params().size() == 0 )\n-        //    throw ParseError::Generic(\"Where clause with no generic params\");\n-        Parse_WhereClause(lex, params);\n-        tok = lex.getToken();\n-    }\n-\n-\n-    AST::Trait trait( mv$(params), mv$(supertraits) );\n-\n-    CHECK_TOK(tok, TOK_BRACE_OPEN);\n-    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n-    {\n-        PUTBACK(tok, lex);\n-\n-        auto item_attrs = Parse_ItemAttrs(lex);\n-        SET_ATTRS(lex, item_attrs);\n-\n-        auto ps = lex.start_span();\n-        {\n-            ::AST::MacroInvocation  inv;\n-            if( Parse_MacroInvocation_Opt(lex, inv) )\n-            {\n-                trait.items().push_back( AST::Named<AST::Item>(\"\", AST::Item(mv$(inv)), false) );\n-                continue ;\n-            }\n-            GET_TOK(tok, lex);\n-        }\n-\n-        bool is_specialisable = false;\n-        if( tok.type() == TOK_IDENT && tok.str() == \"default\" ) {\n-            is_specialisable = true;\n-            GET_TOK(tok, lex);\n-        }\n-        // TODO: Mark specialisation\n-        (void)is_specialisable;\n-\n-        bool fn_is_const = false;\n-        bool fn_is_unsafe = false;\n-        ::std::string   abi = ABI_RUST;\n-        switch(tok.type())\n-        {\n-        case TOK_RWORD_STATIC: {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            auto ty = Parse_Type(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-\n-            ::AST::Expr val;\n-            if(GET_TOK(tok, lex) == TOK_EQUAL) {\n-                val = Parse_Expr(lex);\n-                GET_TOK(tok, lex);\n-            }\n-            CHECK_TOK(tok, TOK_SEMICOLON);\n-\n-            trait.add_static( mv$(name), mv$(item_attrs), ::AST::Static(AST::Static::STATIC, mv$(ty), \n-                val) );\n-            break; }\n-        case TOK_RWORD_CONST: {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            auto ty = Parse_Type(lex);\n-\n-            ::AST::Expr val;\n-            if(GET_TOK(tok, lex) == TOK_EQUAL) {\n-                val = Parse_Expr(lex);\n-                GET_TOK(tok, lex);\n-            }\n-            CHECK_TOK(tok, TOK_SEMICOLON);\n-\n-            trait.add_static( mv$(name), mv$(item_attrs), ::AST::Static(AST::Static::CONST, mv$(ty), \n-                val) );\n-            break; }\n-        // Associated type\n-        case TOK_RWORD_TYPE: {\n-            auto atype_params = ::AST::GenericParams { };\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            if( GET_TOK(tok, lex) == TOK_COLON )\n-            {\n-                // Bounded associated type\n-                Parse_TypeBound(lex, atype_params, TypeRef(lex.point_span(), \"Self\", 0xFFFF));\n-                GET_TOK(tok, lex);\n-            }\n-            if( tok.type() == TOK_RWORD_WHERE ) {\n-                throw ParseError::Todo(lex, \"Where clause on associated type\");\n-            }\n-\n-            TypeRef default_type = TypeRef( lex.point_span() );\n-            if( tok.type() == TOK_EQUAL ) {\n-                default_type = Parse_Type(lex);\n-                GET_TOK(tok, lex);\n-            }\n-\n-            CHECK_TOK(tok, TOK_SEMICOLON);\n-            trait.add_type( ::std::move(name), mv$(item_attrs), ::std::move(default_type) );\n-            trait.items().back().data.as_Type().params() = mv$(atype_params);\n-            break; }\n-\n-        // Functions (possibly unsafe)\n-        case TOK_RWORD_UNSAFE:\n-            fn_is_unsafe = true;\n-            if( GET_TOK(tok, lex) == TOK_RWORD_EXTERN )\n-        case TOK_RWORD_EXTERN:\n-            {\n-                abi = \"C\";\n-                if( GET_TOK(tok, lex) == TOK_STRING )\n-                    abi = tok.str();\n-                else\n-                    PUTBACK(tok, lex);\n-\n-                GET_TOK(tok, lex);\n-            }\n-            CHECK_TOK(tok, TOK_RWORD_FN);\n-        case TOK_RWORD_FN: {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            ::std::string name = mv$(tok.str());\n-            // Self allowed, prototype-form allowed (optional names and no code)\n-            auto fcn = Parse_FunctionDef(lex, abi, true, true,  fn_is_unsafe, fn_is_const);\n-            if( GET_TOK(tok, lex) == TOK_BRACE_OPEN )\n-            {\n-                PUTBACK(tok, lex);\n-                // Enter a new hygine scope for the function body. (TODO: Should this be in Parse_ExprBlock?)\n-                lex.push_hygine();\n-                fcn.set_code( Parse_ExprBlock(lex) );\n-                lex.pop_hygine();\n-            }\n-            else if( tok.type() == TOK_SEMICOLON )\n-            {\n-                // Accept it\n-            }\n-            else\n-            {\n-                throw ParseError::Unexpected(lex, tok);\n-            }\n-            trait.add_function( ::std::move(name), mv$(item_attrs), ::std::move(fcn) );\n-            break; }\n-        default:\n-            throw ParseError::Unexpected(lex, tok);\n-        }\n-    }\n-\n-    return trait;\n-}\n-\n-AST::Enum Parse_EnumDef(TokenStream& lex, const AST::AttributeList& meta_items)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-\n-    tok = lex.getToken();\n-    // Type params supporting \"where\"\n-    AST::GenericParams params;\n-    if( tok.type() == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n-        {\n-            Parse_WhereClause(lex, params);\n-            tok = lex.getToken();\n-        }\n-    }\n-\n-    // Body\n-    CHECK_TOK(tok, TOK_BRACE_OPEN);\n-    ::std::vector<AST::EnumVariant>   variants;\n-    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n-    {\n-        auto sp = lex.start_span();\n-        PUTBACK(tok, lex);\n-\n-        auto item_attrs = Parse_ItemAttrs(lex);\n-        SET_ATTRS(lex, item_attrs);\n-\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        ::std::string   name = mv$(tok.str());\n-        // Tuple-like variants\n-        if( GET_TOK(tok, lex) == TOK_PAREN_OPEN )\n-        {\n-            ::std::vector<TypeRef>  types;\n-            // Get type list\n-            do\n-            {\n-                if(LOOK_AHEAD(lex) == TOK_PAREN_CLOSE)\n-                {\n-                    GET_TOK(tok, lex);\n-                    break;\n-                }\n-\n-                auto field_attrs = Parse_ItemAttrs(lex);\n-                (void)field_attrs;  // TODO: Store field_attrs\n-\n-                types.push_back( Parse_Type(lex) );\n-            } while( GET_TOK(tok, lex) == TOK_COMMA );\n-            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-            GET_TOK(tok, lex);\n-            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(types)) );\n-        }\n-        // Struct-like variants\n-        else if( tok.type() == TOK_BRACE_OPEN )\n-        {\n-            ::std::vector<::AST::StructItem>   fields;\n-            do\n-            {\n-                if(LOOK_AHEAD(lex) == TOK_BRACE_CLOSE)\n-                {\n-                    GET_TOK(tok, lex);\n-                    break;\n-                }\n-\n-                auto field_attrs = Parse_ItemAttrs(lex);\n-\n-                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                auto name = mv$(tok.str());\n-                GET_CHECK_TOK(tok, lex, TOK_COLON);\n-                auto ty = Parse_Type(lex);\n-                fields.push_back( ::AST::StructItem(mv$(field_attrs), true, mv$(name), mv$(ty)) );\n-            } while( GET_TOK(tok, lex) == TOK_COMMA );\n-            CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-            GET_TOK(tok, lex);\n-\n-            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(fields)) );\n-        }\n-        // Value variants\n-        else if( tok.type() == TOK_EQUAL )\n-        {\n-            auto node = Parse_Expr(lex);\n-            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), mv$(node)) );\n-            GET_TOK(tok, lex);\n-        }\n-        // Unit variants\n-        else\n-        {\n-            variants.push_back( AST::EnumVariant(mv$(item_attrs), mv$(name), ::AST::Expr()) );\n-        }\n-\n-        if( tok.type() != TOK_COMMA )\n-            break;\n-    }\n-    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-\n-    return AST::Enum( mv$(params), mv$(variants) );\n-}\n-\n-::AST::Union Parse_Union(TokenStream& lex, AST::AttributeList& meta_items)\n-{\n-    Token   tok;\n-\n-    TRACE_FUNCTION;\n-\n-    AST::GenericParams params;\n-    if( GET_TOK(tok, lex) == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-        if(GET_TOK(tok, lex) == TOK_RWORD_WHERE)\n-        {\n-            Parse_WhereClause(lex, params);\n-            tok = lex.getToken();\n-        }\n-    }\n-\n-    ::std::vector< ::AST::StructItem>   variants;\n-\n-    CHECK_TOK(tok, TOK_BRACE_OPEN);\n-    do {\n-        if( LOOK_AHEAD(lex) == TOK_BRACE_CLOSE ) {\n-            GET_TOK(tok, lex);\n-            break ;\n-        }\n-\n-        auto item_attrs = Parse_ItemAttrs(lex);\n-        SET_ATTRS(lex, item_attrs);\n-\n-        bool is_pub = Parse_Publicity(lex);\n-\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        auto name = mv$(tok.str());\n-        GET_CHECK_TOK(tok, lex, TOK_COLON);\n-\n-        auto ty = Parse_Type(lex);\n-\n-        variants.push_back( ::AST::StructItem( mv$(item_attrs), is_pub, mv$(name), mv$(ty) ) );\n-\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-    CHECK_TOK(tok, TOK_BRACE_CLOSE);\n-\n-    return ::AST::Union( mv$(params), mv$(variants) );\n-}\n-\n-AST::AttributeList Parse_ItemAttrs(TokenStream& lex)\n-{\n-    AST::AttributeList  rv;\n-    Token   tok;\n-    while( lex.lookahead(0) == TOK_HASH )\n-    {\n-        GET_CHECK_TOK(tok, lex, TOK_HASH);\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n-        rv.push_back( Parse_MetaItem(lex) );\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-    }\n-    return rv;\n-}\n-void Parse_ParentAttrs(TokenStream& lex, AST::AttributeList& out)\n-{\n-    Token   tok;\n-    while( lex.lookahead(0) == TOK_HASH && lex.lookahead(1) == TOK_EXCLAM )\n-    {\n-        GET_CHECK_TOK(tok, lex, TOK_HASH);\n-        GET_CHECK_TOK(tok, lex, TOK_EXCLAM);\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n-        out.push_back( Parse_MetaItem(lex) );\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-    }\n-}\n-/// Parse a meta-item declaration (either #![ or #[)\n-AST::Attribute Parse_MetaItem(TokenStream& lex)\n-{\n-    TRACE_FUNCTION;\n-    Token tok;\n-    GET_TOK(tok, lex);\n-\n-    if( tok.type() == TOK_INTERPOLATED_META ) {\n-        return mv$(tok.frag_meta());\n-    }\n-\n-    auto ps = lex.start_span();\n-    CHECK_TOK(tok, TOK_IDENT);\n-    ::std::string   name = mv$(tok.str());\n-    switch(GET_TOK(tok, lex))\n-    {\n-    case TOK_EQUAL:\n-        switch(GET_TOK(tok, lex))\n-        {\n-        case TOK_STRING:\n-            return AST::Attribute(lex.end_span(mv$(ps)), name, tok.str());\n-        case TOK_INTERPOLATED_EXPR: {\n-            auto n = tok.take_frag_node();\n-            if( auto* v = dynamic_cast<::AST::ExprNode_String*>(&*n) )\n-            {\n-                return AST::Attribute(lex.end_span(mv$(ps)), name, mv$(v->m_value));\n-            }\n-            else\n-            {\n-                // - Force an error.\n-                CHECK_TOK(tok, TOK_STRING);\n-            }\n-            break; }\n-        default:\n-            // - Force an error.\n-            CHECK_TOK(tok, TOK_STRING);\n-        }\n-        throw \"\";\n-    case TOK_PAREN_OPEN: {\n-        ::std::vector<AST::Attribute>    items;\n-        do {\n-            if(LOOK_AHEAD(lex) == TOK_PAREN_CLOSE) {\n-                GET_TOK(tok, lex);\n-                break;\n-            }\n-            items.push_back(Parse_MetaItem(lex));\n-        } while(GET_TOK(tok, lex) == TOK_COMMA);\n-        CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-        return AST::Attribute(lex.end_span(mv$(ps)), name, mv$(items)); }\n-    default:\n-        PUTBACK(tok, lex);\n-        return AST::Attribute(lex.end_span(mv$(ps)), name);\n-    }\n-}\n-\n-::AST::Item Parse_Impl(TokenStream& lex, AST::AttributeList attrs, bool is_unsafe=false)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-    auto ps = lex.start_span();\n-\n-    AST::GenericParams params;\n-    // 1. (optional) type parameters\n-    if( GET_TOK(tok, lex) == TOK_LT )\n-    {\n-        params = Parse_GenericParams(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_GT);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-    // 2. Either a trait name (with type params), or the type to impl\n-\n-    Spanned<AST::Path>   trait_path;\n-\n-    // - Handle negative impls specially, which must be a trait\n-    // \"impl !Trait for Type {}\"\n-    if( GET_TOK(tok, lex) == TOK_EXCLAM )\n-    {\n-        trait_path = GET_SPANNED(::AST::Path, lex, Parse_Path(lex, PATH_GENERIC_TYPE));\n-        GET_CHECK_TOK(tok, lex, TOK_RWORD_FOR);\n-        auto impl_type = Parse_Type(lex, true);\n-\n-        if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n-        {\n-            Parse_WhereClause(lex, params);\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_BRACE_OPEN);\n-        // negative impls can't have any content\n-        GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-\n-        return ::AST::Item::make_NegImpl(AST::ImplDef( mv$(attrs), mv$(params), mv$(trait_path), \n-            mv$(impl_type) ));\n-    }\n-\n-    // - Don't care which at this stage\n-    PUTBACK(tok, lex);\n-\n-    auto impl_type = Parse_Type(lex, true);\n-\n-    if( GET_TOK(tok, lex) == TOK_RWORD_FOR )\n-    {\n-        // Trickery! All traits parse as valid types, so this works.\n-        if( !impl_type.is_path() )\n-            throw ParseError::Generic(lex, \"Trait was not a path\");\n-        trait_path = Spanned< AST::Path> {\n-            impl_type.span(),\n-            mv$(impl_type.path())\n-            };\n-        // Implementing a trait for another type, get the target type\n-        if( GET_TOK(tok, lex) == TOK_DOUBLE_DOT )\n-        {\n-            // Default impl\n-            impl_type = TypeRef(TypeRef::TagInvalid(), lex.point_span());\n-        }\n-        else\n-        {\n-            PUTBACK(tok, lex);\n-            impl_type = Parse_Type(lex, true);\n-        }\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    // Where clause\n-    if( GET_TOK(tok, lex) == TOK_RWORD_WHERE )\n-    {\n-        Parse_WhereClause(lex, params);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_OPEN);\n-\n-    Parse_ParentAttrs(lex,  attrs);\n-\n-    auto impl = AST::Impl(AST::ImplDef( mv$(attrs), mv$(params), mv$(trait_path), mv$(impl_type) ));\n-\n-    // A sequence of method implementations\n-    while( lex.lookahead(0) != TOK_BRACE_CLOSE )\n-    {\n-        Parse_Impl_Item(lex, impl);\n-    }\n-    GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-\n-    return ::AST::Item::make_Impl( mv$(impl) );\n-}\n-\n-void Parse_Impl_Item(TokenStream& lex, AST::Impl& impl)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    auto item_attrs = Parse_ItemAttrs(lex);\n-    SET_ATTRS(lex, item_attrs);\n-\n-    {\n-        ::AST::MacroInvocation  inv;\n-        if( Parse_MacroInvocation_Opt(lex,  inv) )\n-        {\n-            impl.add_macro_invocation( mv$(inv) );\n-            impl.items().back().data->attrs = mv$(item_attrs);\n-            return ;\n-        }\n-    }\n-\n-    auto ps = lex.start_span();\n-\n-    bool is_public = Parse_Publicity(lex);\n-    GET_TOK(tok, lex);\n-\n-    bool is_specialisable = false;\n-    if( tok.type() == TOK_IDENT && tok.str() == \"default\" ) {\n-        is_specialisable = true;\n-        GET_TOK(tok, lex);\n-    }\n-\n-    ::std::string   abi = ABI_RUST;\n-    bool fn_is_unsafe = false;\n-    bool fn_is_const = false;\n-    switch(tok.type())\n-    {\n-    case TOK_RWORD_TYPE: {\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        auto name = mv$(tok.str());\n-        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-        impl.add_type(is_public, is_specialisable, name, Parse_Type(lex));\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-        break; }\n-    case TOK_RWORD_UNSAFE:\n-        fn_is_unsafe = true;\n-        GET_TOK(tok, lex);\n-        if( tok.type() == TOK_RWORD_CONST )\n-    case TOK_RWORD_CONST:\n-        {\n-            GET_TOK(tok, lex);\n-            if( tok.type() != TOK_RWORD_FN && tok.type() != TOK_RWORD_UNSAFE && !fn_is_unsafe )\n-            {\n-                CHECK_TOK(tok, TOK_IDENT);\n-                auto name = mv$(tok.str());\n-                GET_CHECK_TOK(tok, lex, TOK_COLON);\n-                auto ty = Parse_Type(lex);\n-                GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-                auto val = Parse_Expr(lex);\n-                GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-\n-                auto i = ::AST::Static(AST::Static::CONST, mv$(ty), mv$(val));\n-                impl.add_static( is_public, is_specialisable, mv$(name),  mv$(i) );\n-                break ;\n-            }\n-            else if( tok.type() == TOK_RWORD_UNSAFE )\n-            {\n-                fn_is_unsafe = true;\n-                GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n-            }\n-            fn_is_const = true;\n-        }\n-        if( tok.type() == TOK_RWORD_EXTERN )\n-        // FALL\n-    case TOK_RWORD_EXTERN:\n-        {\n-            abi = \"C\";\n-            if( GET_TOK(tok, lex) == TOK_STRING )\n-                abi = tok.str();\n-            else\n-                PUTBACK(tok, lex);\n-\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_RWORD_FN);\n-        // FALL\n-    case TOK_RWORD_FN: {\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        // TODO: Hygine on function names? - Not in impl blocks?\n-        ::std::string name = mv$(tok.str());\n-        DEBUG(\"Function \" << name);\n-        // - Self allowed, can't be prototype-form\n-        auto fcn = Parse_FunctionDefWithCode(lex, abi, true,  fn_is_unsafe, fn_is_const);\n-        impl.add_function(is_public, is_specialisable, mv$(name), mv$(fcn));\n-        break; }\n-\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-\n-    impl.items().back().data->span = lex.end_span(mv$(ps));\n-    impl.items().back().data->attrs = mv$(item_attrs);    // Empty for functions\n-}\n-\n-AST::ExternBlock Parse_ExternBlock(TokenStream& lex, ::std::string abi, \n-    ::AST::AttributeList& block_attrs)\n-{\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    Parse_ParentAttrs(lex,  block_attrs);\n-\n-    AST::ExternBlock    rv { abi };\n-\n-    while( GET_TOK(tok, lex) != TOK_BRACE_CLOSE )\n-    {\n-        PUTBACK(tok, lex);\n-        auto meta_items = Parse_ItemAttrs(lex);\n-        SET_ATTRS(lex, meta_items);\n-\n-        auto ps = lex.start_span();\n-\n-        bool is_public = Parse_Publicity(lex);\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_RWORD_FN: {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            // parse function as prototype\n-            // - no self, is prototype, is unsafe and not const\n-            auto i = ::AST::Item( Parse_FunctionDef(lex, abi, false, true,  true,false) );\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-\n-            i.attrs = mv$(meta_items);\n-            i.span = lex.end_span(mv$(ps));\n-\n-            rv.add_item( AST::Named<AST::Item> { mv$(name), mv$(i), is_public } );\n-            break; }\n-        case TOK_RWORD_STATIC: {\n-            bool is_mut = false;\n-            if( GET_TOK(tok, lex) == TOK_RWORD_MUT )\n-                is_mut = true;\n-            else\n-                PUTBACK(tok, lex);\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            auto name = mv$(tok.str());\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            auto type = Parse_Type(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-\n-            auto i = ::AST::Item(::AST::Static( (is_mut ? ::AST::Static::MUT : ::AST::Static::STATIC),  \n-                mv$(type), ::AST::Expr() ));\n-            i.attrs = mv$(meta_items);\n-            i.span = lex.end_span(mv$(ps));\n-            rv.add_item( AST::Named<AST::Item> { mv$(name), mv$(i), is_public } );\n-            break; }\n-        default:\n-            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_RWORD_STATIC});\n-        }\n-    }\n-\n-    return rv;\n-}\n-\n-void Parse_Use_Wildcard(Span sp, AST::Path base_path, ::std::function<void(AST::UseStmt, \n-    ::std::string)> fcn)\n-{\n-    fcn( AST::UseStmt(mv$(sp), mv$(base_path)), \"\" ); // HACK! Empty path indicates wilcard import\n-}\n-void Parse_Use_Set(TokenStream& lex, const ProtoSpan& ps, const AST::Path& base_path, \n-    ::std::function<void(AST::UseStmt, ::std::string)> fcn)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-    do {\n-        AST::Path   path;\n-        ::std::string   name;\n-        if( GET_TOK(tok, lex) == TOK_RWORD_SELF ) {\n-            path = ::AST::Path(base_path);\n-            name = base_path[base_path.size()-1].name();\n-        }\n-        else if( tok.type() == TOK_BRACE_CLOSE ) {\n-            break ;\n-        }\n-        else {\n-            CHECK_TOK(tok, TOK_IDENT);\n-            path = base_path + AST::PathNode(tok.str(), {});\n-            name = mv$(tok.str());\n-        }\n-\n-        if( GET_TOK(tok, lex) == TOK_RWORD_AS ) {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            name = mv$(tok.str());\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-        }\n-        fcn(AST::UseStmt(lex.end_span(ps), mv$(path)), mv$(name));\n-    } while( GET_TOK(tok, lex) == TOK_COMMA );\n-    PUTBACK(tok, lex);\n-}\n-\n-void Parse_Use(TokenStream& lex, ::std::function<void(AST::UseStmt, ::std::string)> fcn)\n-{\n-    TRACE_FUNCTION;\n-\n-    Token   tok;\n-    AST::Path   path = AST::Path(\"\", {});\n-    ::std::vector<AST::PathNode>    nodes;\n-    ProtoSpan   span_start = lex.start_span();\n-\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_RWORD_SELF:\n-        path = AST::Path( AST::Path::TagSelf(), {} );    // relative path\n-        break;\n-    case TOK_RWORD_SUPER: {\n-        unsigned int count = 1;\n-        while( LOOK_AHEAD(lex) == TOK_DOUBLE_COLON && lex.lookahead(1) == TOK_RWORD_SUPER ) {\n-            GET_CHECK_TOK(tok, lex, TOK_DOUBLE_COLON);\n-            GET_CHECK_TOK(tok, lex, TOK_RWORD_SUPER);\n-            count += 1;\n-        }\n-        path = AST::Path( AST::Path::TagSuper(), count, {} );\n-        break; }\n-    case TOK_IDENT:\n-        path.append( AST::PathNode(mv$(tok.str()), {}) );\n-        break;\n-    // Leading :: is allowed and ignored for the $crate feature\n-    case TOK_DOUBLE_COLON:\n-        // Absolute path\n-        // HACK! mrustc emits $crate as `::\"crate-name\"`\n-        if( LOOK_AHEAD(lex) == TOK_STRING )\n-        {\n-            GET_CHECK_TOK(tok, lex, TOK_STRING);\n-            path = ::AST::Path(tok.str(), {});\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-        }\n-        break;\n-    case TOK_BRACE_OPEN:\n-        Parse_Use_Set(lex, span_start, path, fcn);\n-        GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-        return;\n-    case TOK_STAR:\n-        Parse_Use_Wildcard( lex.end_span(span_start), mv$(path), fcn );\n-        return;\n-    case TOK_INTERPOLATED_PATH:\n-        path = mv$(tok.frag_path());\n-        break;\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-    while( GET_TOK(tok, lex) == TOK_DOUBLE_COLON )\n-    {\n-        if( GET_TOK(tok, lex) == TOK_IDENT )\n-        {\n-            path.append( AST::PathNode( mv$(tok.str()), {}) );\n-        }\n-        else\n-        {\n-            //path.set_span( lex.end_span(span_start) );\n-            switch( tok.type() )\n-            {\n-            case TOK_BRACE_OPEN:\n-                Parse_Use_Set(lex, span_start, mv$(path), fcn);\n-                GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-                break ;\n-            case TOK_STAR:\n-                Parse_Use_Wildcard( lex.end_span(span_start), mv$(path), fcn );\n-                break ;\n-            default:\n-                throw ParseError::Unexpected(lex, tok);\n-            }\n-            // early return - This branch is either the end of the use statement, or a syntax error\n-            return ;\n-        }\n-    }\n-    //path.set_span( lex.end_span(span_start) );\n-\n-    ::std::string name;\n-    // This should only be allowed if the last token was an ident\n-    // - Above checks ensure this\n-    if( tok.type() == TOK_RWORD_AS )\n-    {\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        name = mv$(tok.str());\n-    }\n-    else\n-    {\n-        PUTBACK(tok, lex);\n-        ASSERT_BUG(lex.point_span(), path.nodes().size() > 0, \"`use` with no path\");\n-        name = path.nodes().back().name();\n-    }\n-\n-    fcn( AST::UseStmt(lex.end_span(span_start), mv$(path)), name);\n-}\n-\n-\n-::AST::MacroInvocation Parse_MacroInvocation(ProtoSpan span_start, ::std::string name, \n-    TokenStream& lex)\n-{\n-    Token   tok;\n-    ::std::string   ident;\n-    if( GET_TOK(tok, lex) == TOK_IDENT ) {\n-        ident = mv$(tok.str());\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-    DEBUG(\"name=\" << name << \", ident=\" << ident);\n-    TokenTree tt = Parse_TT(lex, true);\n-    return ::AST::MacroInvocation( lex.end_span(span_start), mv$(name), mv$(ident), mv$(tt));\n-}\n-\n-bool Parse_MacroInvocation_Opt(TokenStream& lex,  AST::MacroInvocation& out_inv)\n-{\n-    Token   tok;\n-    if( lex.lookahead(0) == TOK_IDENT && lex.lookahead(1) == TOK_EXCLAM )\n-    {\n-        // Good\n-    }\n-    else\n-    {\n-        return false;\n-    }\n-\n-    auto ps = lex.start_span();\n-    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-    auto name = tok.str();\n-    GET_CHECK_TOK(tok, lex, TOK_EXCLAM);\n-\n-    bool is_braced = (lex.lookahead(0) == TOK_BRACE_OPEN || (lex.lookahead(0) == TOK_IDENT \n-        && lex.lookahead(1) == TOK_BRACE_OPEN));\n-\n-    out_inv = Parse_MacroInvocation(ps, name, lex);\n-\n-    if(!is_braced )\n-    {\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-    }\n-    return true;\n-}\n-\n-::AST::Named<::AST::Item> Parse_Mod_Item_S(TokenStream& lex, const AST::Module::FileInfo& mod_fileinfo, \n-    const ::AST::Path& mod_path, AST::AttributeList meta_items)\n-{\n-    TRACE_FUNCTION_F(\"mod_path=\"<<mod_path<<\", meta_items=\"<<meta_items);\n-    Token   tok;\n-\n-    // NOTE: This assigns into a parameter, so can't use Parse_ItemAttrs\n-    while( LOOKAHEAD2(lex, TOK_HASH, TOK_SQUARE_OPEN) )\n-    {\n-        // Attributes!\n-        GET_CHECK_TOK(tok, lex, TOK_HASH);\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_OPEN);\n-        meta_items.push_back( Parse_MetaItem(lex) );\n-        GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-    }\n-\n-    if( LOOK_AHEAD(lex) == TOK_INTERPOLATED_ITEM ) {\n-        GET_TOK(tok, lex);\n-        auto rv = tok.take_frag_item();\n-        // Transfer new attributes onto the item\n-        for(auto& mi : meta_items.m_items)\n-            rv.data.attrs.m_items.push_back( mv$(mi) );\n-        return rv;\n-    }\n-\n-    auto ps = lex.start_span();\n-\n-    ::std::string   item_name;\n-    ::AST::Item item_data;\n-\n-    {\n-        ::AST::MacroInvocation  inv;\n-        if( Parse_MacroInvocation_Opt(lex, inv) )\n-        {\n-            item_data = ::AST::Item( mv$(inv) );\n-            item_data.attrs = mv$(meta_items);\n-            item_data.span = lex.end_span(mv$(ps));\n-\n-            return ::AST::Named< ::AST::Item> { \"\", mv$(item_data), false };\n-        }\n-    }\n-\n-    bool    is_public = Parse_Publicity(lex);\n-\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_RWORD_USE:\n-        // NOTE: The only problem here is with things like `use foo::{a, b, c}` - all others are a single statement.\n-        // - These are caught by the condition in the closure\n-        Parse_Use(lex, [&](AST::UseStmt p, std::string s) {\n-                DEBUG(mod_path << \" - use \" << p << \" as '\" << s << \"'\");\n-                if( !item_data.is_None() )\n-                    TODO(lex.point_span(), \"Encode multi-item use statements as a single Item\");\n-                item_data = ::AST::Item(mv$(p));\n-                item_name = mv$(s);\n-            });\n-        assert( !item_data.is_None() );\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-        break;\n-\n-    case TOK_RWORD_EXTERN:\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        // `extern \"<ABI>\" fn ...`\n-        // `extern \"<ABI>\" { ...`\n-        case TOK_STRING: {\n-            ::std::string abi = tok.str();\n-            switch(GET_TOK(tok, lex))\n-            {\n-            // `extern \"<ABI>\" fn ...`\n-            case TOK_RWORD_FN: {\n-                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                item_name = mv$(tok.str());\n-                item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, abi, false,  false,false) );\n-                break; }\n-            // `extern \"ABI\" {`\n-            case TOK_BRACE_OPEN:\n-                item_name = \"\";\n-                item_data = ::AST::Item( Parse_ExternBlock(lex, mv$(abi), meta_items) );\n-                break;\n-            default:\n-                throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_BRACE_OPEN});\n-            }\n-            break; }\n-        // `extern fn ...`\n-        case TOK_RWORD_FN:\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, \"C\", false,  false,false) );\n-            break;\n-\n-        // NOTE: `extern { ...` is handled in caller\n-        case TOK_BRACE_OPEN:\n-            item_name = \"\";\n-            item_data = ::AST::Item( Parse_ExternBlock(lex, \"C\", meta_items) );\n-            break;\n-\n-        // `extern crate \"crate-name\" as crate_name;`\n-        // `extern crate crate_name;`\n-        // `extern crate crate_name as other_name;`\n-        case TOK_RWORD_CRATE:\n-            switch( GET_TOK(tok, lex) )\n-            {\n-            // `extern crate \"crate-name\" as crate_name;`\n-            // NOTE: rustc doesn't allow this, keep in mrustc for for reparse support\n-            case TOK_STRING:\n-                item_data = ::AST::Item::make_Crate({ tok.str() });\n-                GET_CHECK_TOK(tok, lex, TOK_RWORD_AS);\n-                GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                item_name = mv$(tok.str());\n-                break;\n-            // `extern crate crate_name;`\n-            // `extern crate crate_name as other_name;`\n-            case TOK_IDENT:\n-                item_name = mv$(tok.str());\n-                if(GET_TOK(tok, lex) == TOK_RWORD_AS) {\n-                    item_data = ::AST::Item::make_Crate({ mv$(item_name) });\n-\n-                    GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-                    item_name = mv$(tok.str());\n-                }\n-                else {\n-                    PUTBACK(tok, lex);\n-                    item_data = ::AST::Item::make_Crate({ item_name });\n-                }\n-                break;\n-            default:\n-                throw ParseError::Unexpected(lex, tok, {TOK_STRING, TOK_IDENT});\n-            }\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-            break;\n-        default:\n-            throw ParseError::Unexpected(lex, tok, {TOK_STRING, TOK_RWORD_FN, TOK_BRACE_OPEN, \n-                TOK_RWORD_CRATE});\n-        }\n-        break;\n-\n-    // `const NAME`\n-    // `const [unsafe] fn`\n-    case TOK_RWORD_CONST:\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_IDENT: {\n-            item_name = mv$(tok.str());\n-\n-            GET_CHECK_TOK(tok, lex, TOK_COLON);\n-            TypeRef type = Parse_Type(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-            AST::Expr val = Parse_Expr(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-            item_data = ::AST::Item( ::AST::Static(AST::Static::CONST, mv$(type), mv$(val)) );\n-            break; }\n-        case TOK_RWORD_UNSAFE:\n-            GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n-                true,true/*unsafe,const*/) );\n-            break;\n-        case TOK_RWORD_FN:\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            // - self not allowed, not prototype\n-            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n-                false,true/*unsafe,const*/) );\n-            break;\n-        default:\n-            throw ParseError::Unexpected(lex, tok, {TOK_IDENT, TOK_RWORD_FN});\n-        }\n-        break;\n-    // `static NAME`\n-    // `static mut NAME`\n-    case TOK_RWORD_STATIC: {\n-        bool is_mut = false;\n-        if(GET_TOK(tok, lex) == TOK_RWORD_MUT) {\n-            is_mut = true;\n-            GET_TOK(tok, lex);\n-        }\n-        CHECK_TOK(tok, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-\n-        GET_CHECK_TOK(tok, lex, TOK_COLON);\n-        TypeRef type = Parse_Type(lex);\n-\n-        GET_CHECK_TOK(tok, lex, TOK_EQUAL);\n-\n-        AST::Expr val = Parse_Expr(lex);\n-\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-        item_data = ::AST::Item( ::AST::Static( (is_mut ? AST::Static::MUT : AST::Static::STATIC), \n-            mv$(type), mv$(val)) );\n-        break; }\n-\n-    // `unsafe fn`\n-    // `unsafe trait`\n-    // `unsafe impl`\n-    case TOK_RWORD_UNSAFE:\n-        switch(GET_TOK(tok, lex))\n-        {\n-        // `unsafe extern fn`\n-        case TOK_RWORD_EXTERN: {\n-            ::std::string   abi = \"C\";\n-            if(GET_TOK(tok, lex) == TOK_STRING) {\n-                abi = mv$(tok.str());\n-            }\n-            else {\n-                PUTBACK(tok, lex);\n-            }\n-            GET_CHECK_TOK(tok, lex, TOK_RWORD_FN);\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, abi, false,  \n-                true,false/*unsafe,const*/) );\n-            break; }\n-        // `unsafe fn`\n-        case TOK_RWORD_FN:\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            // - self not allowed, not prototype\n-            item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n-                true,false/*unsafe,const*/) );\n-            break;\n-        // `unsafe trait`\n-        case TOK_RWORD_TRAIT: {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            auto tr = Parse_TraitDef(lex, meta_items);\n-            tr.set_is_unsafe();\n-            item_data = ::AST::Item( ::std::move(tr) );\n-            break; }\n-        // `unsafe impl`\n-        case TOK_RWORD_IMPL: {\n-            auto impl = Parse_Impl(lex, mv$(meta_items), true);\n-            if( impl.is_Impl() ) {\n-                impl.as_Impl().def().set_is_unsafe();\n-            }\n-            else if( impl.is_NegImpl() ) {\n-                impl.as_NegImpl().set_is_unsafe();\n-            }\n-            else {\n-                BUG(lex.point_span(), \"Parse_Impl returned a variant other than Impl or NegImpl\");\n-            }\n-            return ::AST::Named< ::AST::Item> { \"\", mv$(impl), false };\n-            }\n-        default:\n-            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_FN, TOK_RWORD_TRAIT, TOK_RWORD_IMPL});\n-        }\n-        break;\n-    // `fn`\n-    case TOK_RWORD_FN:\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-        // - self not allowed, not prototype\n-        item_data = ::AST::Item( Parse_FunctionDefWithCode(lex, ABI_RUST, false,  \n-            false,false/*unsafe,const*/) );\n-        break;\n-    // `type`\n-    case TOK_RWORD_TYPE:\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-        item_data = ::AST::Item( Parse_TypeAlias(lex) );\n-        break;\n-    // `struct`\n-    case TOK_RWORD_STRUCT:\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-        item_data = ::AST::Item( Parse_Struct(lex, meta_items) );\n-        break;\n-    // `enum`\n-    case TOK_RWORD_ENUM:\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-        item_data = ::AST::Item( Parse_EnumDef(lex, meta_items) );\n-        break;\n-    // Contextual keywords\n-    case TOK_IDENT:\n-        if( tok.str() == \"union\" ) {\n-            GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-            item_name = mv$(tok.str());\n-            item_data = ::AST::Item( Parse_Union(lex, meta_items) );\n-        }\n-        else {\n-            throw ParseError::Unexpected(lex, tok);\n-        }\n-        break;\n-    // `impl`\n-    case TOK_RWORD_IMPL:\n-        return ::AST::Named< ::AST::Item> { \"\", Parse_Impl(lex, mv$(meta_items)), false };\n-    // `trait`\n-    case TOK_RWORD_TRAIT:\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        item_name = mv$(tok.str());\n-        item_data = ::AST::Item( Parse_TraitDef(lex, meta_items) );\n-        break;\n-\n-    case TOK_RWORD_MOD: {\n-        GET_CHECK_TOK(tok, lex, TOK_IDENT);\n-        auto name = mv$(tok.str());\n-        DEBUG(\"Sub module '\" << name << \"'\");\n-        AST::Module submod( mod_path + name );\n-\n-        // Rules for external files (/ path handling):\n-        // - IF using stdin (path='-') - Disallow and propagate '-' as path\n-        // - IF a #[path] attribute was passed, allow\n-        // - IF in crate root or mod.rs, allow (input flag)\n-        // - else, disallow and set flag\n-        ::std::string path_attr = (meta_items.has(\"path\") ? meta_items.get(\"path\")->string() : \"\");\n-\n-        //submod.m_file_info = get_submod_file(lex.end_span(ps), mod_fileinfo,  name, path_attr, LOOK_AHEAD(lex) == TOK_SEMICOLON);\n-\n-        ::std::string   sub_path;\n-        bool    sub_file_controls_dir = true;\n-        if( mod_fileinfo.path == \"-\" ) {\n-            if( path_attr.size() ) {\n-                ERROR(lex.point_span(), E0000, \"Cannot load module from file when reading stdin\");\n-            }\n-            sub_path = \"-\";\n-        }\n-        else if( path_attr.size() > 0 )\n-        {\n-            sub_path = dirname(mod_fileinfo.path) + path_attr;\n-        }\n-        else if( mod_fileinfo.controls_dir )\n-        {\n-            sub_path = dirname(mod_fileinfo.path) + name;\n-        }\n-        else\n-        {\n-            sub_path = mod_fileinfo.path;\n-            sub_file_controls_dir = false;\n-        }\n-        DEBUG(\"Mod '\" << name << \"', sub_path = \" << sub_path);\n-\n-        submod.m_file_info.path = sub_path;\n-        submod.m_file_info.controls_dir = sub_file_controls_dir;\n-\n-        // Check #[cfg] and don't load if it fails\n-        struct H {\n-            static bool check_item_cfg(const ::AST::AttributeList& attrs)\n-            {\n-                for(const auto& at : attrs.m_items) {\n-                    if( at.name() == \"cfg\" && !check_cfg(at.span(), at) ) {\n-                        return false;\n-                    }\n-                }\n-                return true;\n-            }\n-        };\n-\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_BRACE_OPEN:\n-            submod.m_file_info.path = sub_path + \"/\";\n-            Parse_ModRoot(lex, submod, meta_items);\n-            GET_CHECK_TOK(tok, lex, TOK_BRACE_CLOSE);\n-            break;\n-        case TOK_SEMICOLON:\n-            if( sub_path == \"-\" ) {\n-                ERROR(lex.point_span(), E0000, \"Cannot load module from file when reading stdin\");\n-            }\n-            else if( path_attr.size() == 0 && ! mod_fileinfo.controls_dir )\n-            {\n-                ERROR(lex.point_span(), E0000, \"Can't load from files outside of mod.rs or crate root\");\n-            }\n-            else if( !H::check_item_cfg(meta_items) ) {\n-                // Ignore - emit Item::None\n-                item_name = mv$(name);\n-                item_data = ::AST::Item( );\n-                break ;\n-            }\n-            else\n-            {\n-                ::std::string newpath_dir  = sub_path + \"/\";\n-                ::std::string newpath_file = path_attr.size() > 0 ? sub_path : sub_path + \".rs\";\n-                DEBUG(\"newpath_dir = '\" << newpath_dir << \"', newpath_file = '\" << newpath_file << \"'\");\n-                ::std::ifstream ifs_dir (newpath_dir + \"mod.rs\");\n-                ::std::ifstream ifs_file(newpath_file);\n-                if( ifs_dir.is_open() && ifs_file.is_open() )\n-                {\n-                    // Collision\n-                    ERROR(lex.point_span(), E0000, \"Both modname.rs and modname/mod.rs exist\");\n-                }\n-                else if( ifs_dir.is_open() )\n-                {\n-                    // Load from dir\n-                    submod.m_file_info.path = newpath_dir + \"mod.rs\";\n-                }\n-                else if( ifs_file.is_open() )\n-                {\n-                    submod.m_file_info.path = newpath_file;\n-                }\n-                else\n-                {\n-                    // Can't find file\n-                    ERROR(lex.point_span(), E0000, \"Can't find file for '\" << name << \"' in '\" << mod_fileinfo.path << \"'\");\n-                }\n-                DEBUG(\"- path = \" << submod.m_file_info.path);\n-                Lexer sub_lex(submod.m_file_info.path);\n-                Parse_ModRoot(sub_lex, submod, meta_items);\n-                GET_CHECK_TOK(tok, sub_lex, TOK_EOF);\n-            }\n-            break;\n-        default:\n-            throw ParseError::Generic(\"Expected { or ; after module name\");\n-        }\n-        item_name = mv$(name);\n-        item_data = ::AST::Item( mv$(submod) );\n-        break; }\n-\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-\n-    item_data.attrs = mv$(meta_items);\n-    item_data.span = lex.end_span(mv$(ps));\n-\n-    return ::AST::Named< ::AST::Item> { mv$(item_name), mv$(item_data), is_public };\n-}\n-\n-void Parse_Mod_Item(TokenStream& lex, AST::Module& mod, AST::AttributeList meta_items)\n-{\n-    SET_MODULE(lex, mod);\n-    lex.parse_state().parent_attrs = &meta_items;\n-\n-    //TRACE_FUNCTION;\n-    Token   tok;\n-\n-    // `use ...`\n-    // TODO: This doesn't spot `pub(path) use`.\n-    if( LOOK_AHEAD(lex) == TOK_RWORD_USE || (lex.lookahead(0) == TOK_RWORD_PUB \n-        && lex.lookahead(1) == TOK_RWORD_USE) )\n-    {\n-        bool    is_public = Parse_Publicity(lex);\n-        GET_CHECK_TOK(tok, lex, TOK_RWORD_USE);\n-\n-        Parse_Use(lex, [&mod,is_public,&meta_items](AST::UseStmt p, std::string s) {\n-                DEBUG(mod.path() << \" - use \" << p << \" as '\" << s << \"'\");\n-                mod.add_alias(is_public, mv$(p), s, meta_items.clone());\n-            });\n-        GET_CHECK_TOK(tok, lex, TOK_SEMICOLON);\n-    }\n-    else\n-    {\n-        mod.add_item( Parse_Mod_Item_S(lex, mod.m_file_info, mod.path(), mv$(meta_items)) );\n-    }\n-}\n-\n-void Parse_ModRoot_Items(TokenStream& lex, AST::Module& mod)\n-{\n-    Token   tok;\n-\n-    for(;;)\n-    {\n-        // Check 1 - End of module (either via a closing brace, or EOF)\n-        switch(GET_TOK(tok, lex))\n-        {\n-        case TOK_BRACE_CLOSE:\n-        case TOK_EOF:\n-            PUTBACK(tok, lex);\n-            return;\n-        default:\n-            PUTBACK(tok, lex);\n-            break;\n-        }\n-\n-        // Attributes on the following item\n-        auto meta_items = Parse_ItemAttrs(lex);\n-        DEBUG(\"meta_items = \" << meta_items);\n-\n-        Parse_Mod_Item(lex, mod, mv$(meta_items));\n-    }\n-}\n-\n-void Parse_ModRoot(TokenStream& lex, AST::Module& mod, AST::AttributeList& mod_attrs)\n-{\n-    TRACE_FUNCTION;\n-\n-    // Attributes on module/crate (will continue loop)\n-    Parse_ParentAttrs(lex,  mod_attrs);\n-\n-    Parse_ModRoot_Items(lex, mod);\n-}\n-\n-AST::Crate Parse_Crate(::std::string mainfile)\n-{\n-    Token   tok;\n-\n-    Lexer lex(mainfile);\n-\n-    size_t p = mainfile.find_last_of('/');\n-    p = (p == ::std::string::npos ? mainfile.find_last_of('\\\\') : p);\n-    ::std::string mainpath = (p != ::std::string::npos ? ::std::string(mainfile.begin(), \n-        mainfile.begin()+p+1) : \"./\");\n-\n-    AST::Crate  crate;\n-\n-    //crate.root_module().m_file_info.file_path = mainfile;\n-    crate.root_module().m_file_info.path = mainpath;\n-    crate.root_module().m_file_info.controls_dir = true;\n-\n-    Parse_ModRoot(lex, crate.root_module(), crate.m_attrs);\n-\n-    return crate;\n-}"}, {"sha": "2e5a61d4d9e16978cdc9c26b06d48da50283e070", "filename": "gcc/rust/mrustc_parser/parse/token.cpp", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,512 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- */\n-#include \"token.hpp\"\n-#include <common.hpp>\n-#include <parse/parseerror.hpp>\n-#include \"interpolated_fragment.hpp\"\n-#include <ast/types.hpp>\n-#include <ast/ast.hpp>\n-#include <ast/expr.hpp> // for reasons\n-\n-Token::~Token()\n-{\n-    switch(m_type)\n-    {\n-    case TOK_INTERPOLATED_TYPE:\n-        delete reinterpret_cast<TypeRef*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_PATTERN:\n-        delete reinterpret_cast<AST::Pattern*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_PATH:\n-        delete reinterpret_cast<AST::Path*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_EXPR:\n-        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_STMT:\n-        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_BLOCK:\n-        delete reinterpret_cast<AST::ExprNode*>(m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_META:\n-        delete reinterpret_cast<AST::Attribute*>(m_data.as_Fragment());\n-        break;\n-    default:\n-        break;\n-    }\n-\n-}\n-\n-Token::Token():\n-    m_type(TOK_NULL)\n-{\n-}\n-Token::Token(enum eTokenType type):\n-    m_type(type)\n-{\n-}\n-Token::Token(enum eTokenType type, ::std::string str):\n-    m_type(type),\n-    m_data(Data::make_String(mv$(str)))\n-{\n-}\n-Token::Token(uint64_t val, enum eCoreType datatype):\n-    m_type(TOK_INTEGER),\n-    m_data( Data::make_Integer({datatype, val}) )\n-{\n-}\n-Token::Token(double val, enum eCoreType datatype):\n-    m_type(TOK_FLOAT),\n-    m_data( Data::make_Float({datatype, val}) )\n-{\n-}\n-Token::Token(const InterpolatedFragment& frag)\n-{\n-    switch(frag.m_type)\n-    {\n-    case InterpolatedFragment::TT:  throw \"\";\n-    case InterpolatedFragment::TYPE:\n-        m_type = TOK_INTERPOLATED_TYPE;\n-        m_data = new TypeRef( reinterpret_cast<const TypeRef*>(frag.m_ptr)->clone() );\n-        break;\n-    case InterpolatedFragment::PAT:\n-        m_type = TOK_INTERPOLATED_PATTERN;\n-        m_data = new AST::Pattern( reinterpret_cast<const AST::Pattern*>(frag.m_ptr)->clone() );\n-        break;\n-    case InterpolatedFragment::PATH:\n-        m_type = TOK_INTERPOLATED_PATH;\n-        m_data = new AST::Path( *reinterpret_cast<const AST::Path*>(frag.m_ptr) );\n-        break;\n-    case InterpolatedFragment::EXPR:\n-        m_type = TOK_INTERPOLATED_EXPR; if(0)\n-    case InterpolatedFragment::STMT:\n-        m_type = TOK_INTERPOLATED_STMT; if(0)\n-    case InterpolatedFragment::BLOCK:\n-        m_type = TOK_INTERPOLATED_BLOCK;\n-\n-        m_data = reinterpret_cast<const AST::ExprNode*>(frag.m_ptr)->clone().release();\n-        break;\n-    case InterpolatedFragment::META:\n-        m_type = TOK_INTERPOLATED_META;\n-        m_data = new AST::Attribute( reinterpret_cast<const AST::Attribute*>(frag.m_ptr)->clone() );\n-        break;\n-    case InterpolatedFragment::ITEM: {\n-        m_type = TOK_INTERPOLATED_ITEM;\n-        const auto& named = *reinterpret_cast<const AST::Named<AST::Item>*>(frag.m_ptr);\n-        ::AST::Item item = named.data.clone();\n-        m_data = new AST::Named<AST::Item>( named.name, mv$(item), named.is_pub );\n-        break; }\n-    }\n-}\n-Token::Token(TagTakeIP, InterpolatedFragment frag)\n-{\n-    switch(frag.m_type)\n-    {\n-    case InterpolatedFragment::TT:  throw \"\";\n-    case InterpolatedFragment::TYPE:\n-        m_type = TOK_INTERPOLATED_TYPE;\n-        m_data = new TypeRef( mv$(*reinterpret_cast<TypeRef*>(frag.m_ptr)) );\n-        break;\n-    case InterpolatedFragment::PAT:\n-        m_type = TOK_INTERPOLATED_PATTERN;\n-        m_data = new AST::Pattern( mv$(*reinterpret_cast<AST::Pattern*>(frag.m_ptr)) );\n-        break;\n-    case InterpolatedFragment::PATH:\n-        m_type = TOK_INTERPOLATED_PATH;\n-        m_data = new AST::Path( mv$(*reinterpret_cast<AST::Path*>(frag.m_ptr)) );\n-        break;\n-    case InterpolatedFragment::EXPR:\n-        m_type = TOK_INTERPOLATED_EXPR; if(0)\n-    case InterpolatedFragment::STMT:\n-        m_type = TOK_INTERPOLATED_STMT; if(0)\n-    case InterpolatedFragment::BLOCK:\n-        m_type = TOK_INTERPOLATED_BLOCK;\n-\n-        m_data = reinterpret_cast<AST::ExprNode*>(frag.m_ptr);\n-        frag.m_ptr = nullptr;\n-        break;\n-    case InterpolatedFragment::ITEM:\n-        m_type = TOK_INTERPOLATED_ITEM;\n-        m_data = frag.m_ptr;\n-        frag.m_ptr = nullptr;\n-        break;\n-    case InterpolatedFragment::META:\n-        m_type = TOK_INTERPOLATED_META;\n-        m_data = frag.m_ptr;\n-        frag.m_ptr = nullptr;\n-        break;\n-    }\n-}\n-\n-Token::Token(const Token& t):\n-    m_type(t.m_type),\n-    m_data( Data::make_None({}) ),\n-    m_pos( t.m_pos )\n-{\n-    assert( t.m_data.tag() != Data::TAGDEAD );\n-    TU_MATCH(Data, (t.m_data), (e),\n-    (None,  ),\n-    (String,    m_data = Data::make_String(e); ),\n-    (Integer,   m_data = Data::make_Integer(e);),\n-    (Float, m_data = Data::make_Float(e);),\n-    (Fragment, BUG(t.m_pos, \"Attempted to copy a fragment - \" << t);)\n-    )\n-}\n-Token Token::clone() const\n-{\n-    Token   rv(m_type);\n-    rv.m_pos = m_pos;\n-\n-    assert( m_data.tag() != Data::TAGDEAD );\n-    TU_MATCH(Data, (m_data), (e),\n-    (None,\n-        ),\n-    (String,\n-        rv.m_data = Data::make_String(e);\n-        ),\n-    (Integer,\n-        rv.m_data = Data::make_Integer(e);\n-        ),\n-    (Float,\n-        rv.m_data = Data::make_Float(e);\n-        ),\n-    (Fragment,\n-        assert(e);\n-        switch(m_type)\n-        {\n-        case TOK_INTERPOLATED_TYPE:\n-            rv.m_data = new TypeRef( reinterpret_cast<TypeRef*>(e)->clone() );\n-            break;\n-        case TOK_INTERPOLATED_PATTERN:\n-            rv.m_data = new AST::Pattern( reinterpret_cast<AST::Pattern*>(e)->clone() );\n-            break;\n-        case TOK_INTERPOLATED_PATH:\n-            rv.m_data = new AST::Path( *reinterpret_cast<AST::Path*>(e) );\n-            break;\n-        case TOK_INTERPOLATED_EXPR:\n-            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n-            break;\n-        case TOK_INTERPOLATED_STMT:\n-            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n-            break;\n-        case TOK_INTERPOLATED_BLOCK:\n-            rv.m_data = reinterpret_cast<AST::ExprNode*>(e)->clone().release();\n-            break;\n-        case TOK_INTERPOLATED_META:\n-            rv.m_data = new AST::Attribute( reinterpret_cast<AST::Attribute*>(e)->clone() );\n-            break;\n-        case TOK_INTERPOLATED_ITEM:\n-            TODO(m_pos, \"clone interpolated item\");\n-            //rv.m_data = new AST::Named( AST::Item( reinterpret_cast<AST::Attribute*>(e)->clone() ) );\n-            break;\n-        default:\n-            BUG(m_pos, \"Fragment with invalid token type (\" << *this << \")\");\n-            break;\n-        }\n-        assert(rv.m_data.is_Fragment());\n-        )\n-    )\n-    return rv;\n-}\n-\n-::std::unique_ptr<AST::ExprNode> Token::take_frag_node()\n-{\n-    assert( m_type == TOK_INTERPOLATED_EXPR || m_type == TOK_INTERPOLATED_STMT || m_type == TOK_INTERPOLATED_BLOCK );\n-    auto ptr = m_data.as_Fragment();\n-    m_data.as_Fragment() = nullptr;\n-    return ::std::unique_ptr<AST::ExprNode>( reinterpret_cast<AST::ExprNode*>( ptr ) );\n-}\n-::AST::Named<AST::Item> Token::take_frag_item()\n-{\n-    assert( m_type == TOK_INTERPOLATED_ITEM );\n-    auto ptr = reinterpret_cast<AST::Named<AST::Item>*>(m_data.as_Fragment());\n-    m_data.as_Fragment() = nullptr;\n-    auto rv = mv$( *ptr );\n-    delete ptr;\n-    return mv$(rv);\n-}\n-\n-const char* Token::typestr(enum eTokenType type)\n-{\n-    switch(type)\n-    {\n-    #define _(t)    case t: return #t;\n-    #include \"eTokenType.enum.h\"\n-    #undef _\n-    }\n-    return \">>BUGCHECK: BADTOK<<\";\n-}\n-\n-enum eTokenType Token::typefromstr(const ::std::string& s)\n-{\n-    if(s == \"\")\n-        return TOK_NULL;\n-    #define _(t)    if( s == #t ) return t;\n-    #include \"eTokenType.enum.h\"\n-    #undef _\n-    return TOK_NULL;\n-}\n-\n-struct EscapedString {\n-    const ::std::string& s;\n-    EscapedString(const ::std::string& s): s(s) {}\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const EscapedString& x) {\n-        for(auto b : x.s) {\n-            switch(b)\n-            {\n-            case '\"':\n-                os << \"\\\\\\\"\";\n-                break;\n-            case '\\\\':\n-                os << \"\\\\\\\\\";\n-                break;\n-            case '\\n':\n-                os << \"\\\\n\";\n-                break;\n-            default:\n-                if( ' ' <= b && b < 0x7F )\n-                    os << b;\n-                else\n-                    os << \"\\\\u{\" << ::std::hex << (unsigned int)b << \"}\";\n-                break;\n-            }\n-        }\n-        return os;\n-    }\n-};\n-\n-::std::string Token::to_str() const\n-{\n-    ::std::stringstream ss;\n-    switch(m_type)\n-    {\n-    case TOK_NULL:  return \"/*null*/\";\n-    case TOK_EOF:   return \"/*eof*/\";\n-\n-    case TOK_NEWLINE:    return \"\\n\";\n-    case TOK_WHITESPACE: return \" \";\n-    case TOK_COMMENT:    return \"/*\" + m_data.as_String() + \"*/\";\n-    case TOK_INTERPOLATED_TYPE:\n-        reinterpret_cast<const ::TypeRef*>(m_data.as_Fragment())->print(ss, false);\n-        return ss.str();\n-    case TOK_INTERPOLATED_PATH:\n-        reinterpret_cast<const ::AST::Path*>(m_data.as_Fragment())->print_pretty(ss, true);\n-        return ss.str();\n-    case TOK_INTERPOLATED_PATTERN:\n-        // TODO: Use a pretty printer too?\n-        return FMT( *reinterpret_cast<const ::AST::Pattern*>(m_data.as_Fragment()) );\n-    case TOK_INTERPOLATED_STMT:\n-    case TOK_INTERPOLATED_BLOCK:\n-    case TOK_INTERPOLATED_EXPR: {\n-        ::std::stringstream ss;\n-        reinterpret_cast<const ::AST::ExprNode*>(m_data.as_Fragment())->print(ss);\n-        return ss.str();\n-        }\n-    case TOK_INTERPOLATED_META: return \"/*:meta*/\";\n-    case TOK_INTERPOLATED_ITEM: return \"/*:item*/\";\n-    case TOK_INTERPOLATED_IDENT: return \"/*:ident*/\";\n-    // Value tokens\n-    case TOK_IDENT:     return m_data.as_String();\n-    case TOK_LIFETIME:  return \"'\" + m_data.as_String();\n-    case TOK_INTEGER:\n-        if( m_data.as_Integer().m_datatype == CORETYPE_ANY ) {\n-            return FMT(m_data.as_Integer().m_intval);\n-        }\n-        else {\n-            return FMT(m_data.as_Integer().m_intval << \"_\" << m_data.as_Integer().m_datatype);\n-        }\n-    case TOK_CHAR:      return FMT(\"'\\\\u{\"<< ::std::hex << m_data.as_Integer().m_intval << \"}\");\n-    case TOK_FLOAT:\n-        if( m_data.as_Float().m_datatype == CORETYPE_ANY ) {\n-            return FMT(m_data.as_Float().m_floatval);\n-        }\n-        else {\n-            return FMT(m_data.as_Float().m_floatval << \"_\" << m_data.as_Float().m_datatype);\n-        }\n-    case TOK_STRING:    return FMT(\"\\\"\" << EscapedString(m_data.as_String()) << \"\\\"\");\n-    case TOK_BYTESTRING:return FMT(\"b\\\"\" << m_data.as_String() << \"\\\"\");\n-    case TOK_HASH:  return \"#\";\n-    case TOK_UNDERSCORE:return \"_\";\n-    // Symbols\n-    case TOK_PAREN_OPEN:    return \"(\";\n-    case TOK_PAREN_CLOSE:   return \")\";\n-    case TOK_BRACE_OPEN:    return \"{\";\n-    case TOK_BRACE_CLOSE:   return \"}\";\n-    case TOK_LT:    return \"<\";\n-    case TOK_GT:    return \">\";\n-    case TOK_SQUARE_OPEN:   return \"[\";\n-    case TOK_SQUARE_CLOSE:  return \"]\";\n-    case TOK_COMMA:     return \",\";\n-    case TOK_SEMICOLON: return \";\";\n-    case TOK_COLON:     return \":\";\n-    case TOK_DOUBLE_COLON:  return \"::\";\n-    case TOK_STAR:  return \"*\";\n-    case TOK_AMP:   return \"&\";\n-    case TOK_PIPE:  return \"|\";\n-\n-    case TOK_FATARROW:  return \"=>\";\n-    case TOK_THINARROW: return \"->\";\n-    case TOK_THINARROW_LEFT: return \"<-\";\n-\n-    case TOK_PLUS:  return \"+\";\n-    case TOK_DASH:  return \"-\";\n-    case TOK_EXCLAM:    return \"!\";\n-    case TOK_PERCENT:   return \"%\";\n-    case TOK_SLASH:     return \"/\";\n-\n-    case TOK_DOT:   return \".\";\n-    case TOK_DOUBLE_DOT:    return \"...\";\n-    case TOK_TRIPLE_DOT:    return \"..\";\n-\n-    case TOK_EQUAL: return \"=\";\n-    case TOK_PLUS_EQUAL:    return \"+=\";\n-    case TOK_DASH_EQUAL:    return \"-\";\n-    case TOK_PERCENT_EQUAL: return \"%=\";\n-    case TOK_SLASH_EQUAL:   return \"/=\";\n-    case TOK_STAR_EQUAL:    return \"*=\";\n-    case TOK_AMP_EQUAL:     return \"&=\";\n-    case TOK_PIPE_EQUAL:    return \"|=\";\n-\n-    case TOK_DOUBLE_EQUAL:  return \"==\";\n-    case TOK_EXCLAM_EQUAL:  return \"!=\";\n-    case TOK_GTE:    return \">=\";\n-    case TOK_LTE:    return \"<=\";\n-\n-    case TOK_DOUBLE_AMP:    return \"&&\";\n-    case TOK_DOUBLE_PIPE:   return \"||\";\n-    case TOK_DOUBLE_LT:     return \"<<\";\n-    case TOK_DOUBLE_GT:     return \">>\";\n-    case TOK_DOUBLE_LT_EQUAL:   return \"<=\";\n-    case TOK_DOUBLE_GT_EQUAL:   return \">=\";\n-\n-    case TOK_DOLLAR:    return \"$\";\n-\n-    case TOK_QMARK: return \"?\";\n-    case TOK_AT:    return \"@\";\n-    case TOK_TILDE:     return \"~\";\n-    case TOK_BACKSLASH: return \"\\\\\";\n-    case TOK_CARET:     return \"^\";\n-    case TOK_CARET_EQUAL:   return \"^=\";\n-    case TOK_BACKTICK:  return \"`\";\n-\n-    // Reserved Words\n-    case TOK_RWORD_PUB:     return \"pub\";\n-    case TOK_RWORD_PRIV:    return \"priv\";\n-    case TOK_RWORD_MUT:     return \"mut\";\n-    case TOK_RWORD_CONST:   return \"const\";\n-    case TOK_RWORD_STATIC:  return \"static\";\n-    case TOK_RWORD_UNSAFE:  return \"unsafe\";\n-    case TOK_RWORD_EXTERN:  return \"extern\";\n-\n-    case TOK_RWORD_CRATE:   return \"crate\";\n-    case TOK_RWORD_MOD:     return \"mod\";\n-    case TOK_RWORD_STRUCT:  return \"struct\";\n-    case TOK_RWORD_ENUM:    return \"enum\";\n-    case TOK_RWORD_TRAIT:   return \"trait\";\n-    case TOK_RWORD_FN:      return \"fn\";\n-    case TOK_RWORD_USE:     return \"use\";\n-    case TOK_RWORD_IMPL:    return \"impl\";\n-    case TOK_RWORD_TYPE:    return \"type\";\n-\n-    case TOK_RWORD_WHERE:   return \"where\";\n-    case TOK_RWORD_AS:      return \"as\";\n-\n-    case TOK_RWORD_LET:     return \"let\";\n-    case TOK_RWORD_MATCH:   return \"match\";\n-    case TOK_RWORD_IF:      return \"if\";\n-    case TOK_RWORD_ELSE:    return \"else\";\n-    case TOK_RWORD_LOOP:    return \"loop\";\n-    case TOK_RWORD_WHILE:   return \"while\";\n-    case TOK_RWORD_FOR:     return \"for\";\n-    case TOK_RWORD_IN:      return \"in\";\n-    case TOK_RWORD_DO:      return \"do\";\n-\n-    case TOK_RWORD_CONTINUE:return \"continue\";\n-    case TOK_RWORD_BREAK:   return \"break\";\n-    case TOK_RWORD_RETURN:  return \"return\";\n-    case TOK_RWORD_YIELD:   return \"yeild\";\n-    case TOK_RWORD_BOX:     return \"box\";\n-    case TOK_RWORD_REF:     return \"ref\";\n-\n-    case TOK_RWORD_FALSE:   return \"false\";\n-    case TOK_RWORD_TRUE:    return \"true\";\n-    case TOK_RWORD_SELF:    return \"self\";\n-    case TOK_RWORD_SUPER:   return \"super\";\n-\n-    case TOK_RWORD_PROC:    return \"proc\";\n-    case TOK_RWORD_MOVE:    return \"move\";\n-\n-    case TOK_RWORD_ABSTRACT:return \"abstract\";\n-    case TOK_RWORD_FINAL:   return \"final\";\n-    case TOK_RWORD_PURE:    return \"pure\";\n-    case TOK_RWORD_OVERRIDE:return \"override\";\n-    case TOK_RWORD_VIRTUAL: return \"virtual\";\n-\n-    case TOK_RWORD_ALIGNOF: return \"alignof\";\n-    case TOK_RWORD_OFFSETOF:return \"offsetof\";\n-    case TOK_RWORD_SIZEOF:  return \"sizeof\";\n-    case TOK_RWORD_TYPEOF:  return \"typeof\";\n-\n-    case TOK_RWORD_BE:      return \"be\";\n-    case TOK_RWORD_UNSIZED: return \"unsized\";\n-    }\n-    throw ParseError::BugCheck(\"Reached end of Token::to_str\");\n-}\n-\n-\n-::std::ostream&  operator<<(::std::ostream& os, const Token& tok)\n-{\n-    os << Token::typestr(tok.type());\n-    switch(tok.type())\n-    {\n-    case TOK_STRING:\n-    case TOK_BYTESTRING:\n-    case TOK_IDENT:\n-    case TOK_LIFETIME:\n-        if( tok.m_data.is_String() )\n-            os << \"\\\"\" << EscapedString(tok.str()) << \"\\\"\";\n-        break;\n-    case TOK_INTEGER:\n-        if( tok.m_data.is_Integer() )\n-            os << \":\" << tok.intval();\n-        break;\n-    case TOK_INTERPOLATED_TYPE:\n-        os << \":\" << *reinterpret_cast<TypeRef*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_PATTERN:\n-        os << \":\" << *reinterpret_cast<AST::Pattern*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_PATH:\n-        os << \":\" << *reinterpret_cast<AST::Path*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_EXPR:\n-        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_STMT:\n-        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_BLOCK:\n-        os << \":\" << *reinterpret_cast<AST::ExprNode*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_META:\n-        os << \":\" << *reinterpret_cast<AST::Attribute*>(tok.m_data.as_Fragment());\n-        break;\n-    case TOK_INTERPOLATED_ITEM: {\n-        const auto& named_item = *reinterpret_cast<const AST::Named<AST::Item>*>(tok.m_data.as_Fragment());\n-        os << \":\" << named_item.data.tag_str() << \"(\" << named_item.name << \")\";\n-        } break;\n-    default:\n-        break;\n-    }\n-    return os;\n-}\n-::std::ostream& operator<<(::std::ostream& os, const Position& p)\n-{\n-    return os << ::std::dec << p.filename << \":\" << p.line;\n-}\n-"}, {"sha": "af27804f1b89d446785bda5e1af0f66faec6600f", "filename": "gcc/rust/mrustc_parser/parse/token.hpp", "status": "removed", "additions": 0, "deletions": 158, "changes": 158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftoken.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,158 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/token.hpp\n- * - Lexer Tokens\n- */\n-#pragma once\n-\n-#include \"../coretypes.hpp\"\n-#include <ident.hpp>\n-#include <memory>\n-#include <rc_string.hpp>\n-#include <tagged_union.hpp>\n-\n-enum eTokenType {\n-#define _(t) t,\n-#include \"eTokenType.enum.h\"\n-#undef _\n-};\n-\n-class Position {\n-  public:\n-    RcString filename;\n-    unsigned int line;\n-    unsigned int ofs;\n-\n-    Position()\n-      : filename(\"\")\n-      , line(0)\n-      , ofs(0) {}\n-    Position(RcString filename, unsigned int line, unsigned int ofs)\n-      : filename(filename)\n-      , line(line)\n-      , ofs(ofs) {\n-    }\n-};\n-extern ::std::ostream& operator<<(::std::ostream& os, const Position& p);\n-\n-class TypeRef;\n-class TokenTree;\n-namespace AST {\n-    class Pattern;\n-    class Path;\n-    class ExprNode;\n-    class Attribute;\n-    class Item;\n-\n-    template<typename T>\n-    struct Named;\n-};\n-\n-class InterpolatedFragment;\n-\n-class Token {\n-    friend class HirSerialiser;\n-    friend class HirDeserialiser;\n-\n-    TAGGED_UNION(Data, None, (None, struct {}), (String, ::std::string), (Integer, struct {\n-                     enum eCoreType m_datatype;\n-                     uint64_t m_intval;\n-                 }),\n-                 (Float, struct {\n-                     enum eCoreType m_datatype;\n-                     double m_floatval;\n-                 }),\n-                 (Fragment, void*));\n-\n-    enum eTokenType m_type;\n-    Data m_data;\n-    Position m_pos;\n-\n-    Token(enum eTokenType t, Data d, Position p)\n-      : m_type(t)\n-      , m_data(::std::move(d))\n-      , m_pos(::std::move(p)) {\n-    }\n-\n-  public:\n-    virtual ~Token();\n-    Token();\n-    Token& operator=(Token&& t) {\n-        m_type = t.m_type;\n-        t.m_type = TOK_NULL;\n-        m_data = ::std::move(t.m_data);\n-        m_pos = ::std::move(t.m_pos);\n-        return *this;\n-    }\n-    Token(Token&& t)\n-      : m_type(t.m_type)\n-      , m_data(::std::move(t.m_data))\n-      , m_pos(::std::move(t.m_pos)) {\n-        t.m_type = TOK_NULL;\n-    }\n-    Token(const Token& t);\n-    Token clone() const;\n-\n-    Token(enum eTokenType type);\n-    Token(enum eTokenType type, ::std::string str);\n-    Token(uint64_t val, enum eCoreType datatype);\n-    Token(double val, enum eCoreType datatype);\n-    Token(const InterpolatedFragment&);\n-    struct TagTakeIP {};\n-    Token(TagTakeIP, InterpolatedFragment);\n-\n-    enum eTokenType type() const { return m_type; }\n-    ::std::string& str() { return m_data.as_String(); }\n-    const ::std::string& str() const { return m_data.as_String(); }\n-    enum eCoreType datatype() const { \n-        TU_MATCH_DEF(Data, (m_data), (e), (assert(!\"Getting datatype of invalid token type\");), \n-        (Integer, return e.m_datatype;), (Float, return e.m_datatype;)) throw \"\"; }\n-    uint64_t intval() const { return m_data.as_Integer().m_intval; }\n-    double floatval() const { return m_data.as_Float().m_floatval; }\n-\n-    TypeRef& frag_type() {\n-        assert(m_type == TOK_INTERPOLATED_TYPE);\n-        return *reinterpret_cast<TypeRef*>(m_data.as_Fragment());\n-    }\n-    \n-    AST::Path& frag_path() {\n-        assert(m_type == TOK_INTERPOLATED_PATH);\n-        return *reinterpret_cast<AST::Path*>(m_data.as_Fragment());\n-    }\n-    \n-    AST::Pattern& frag_pattern() {\n-        assert(m_type == TOK_INTERPOLATED_PATTERN);\n-        return *reinterpret_cast<AST::Pattern*>(m_data.as_Fragment());\n-    }\n-    \n-    AST::Attribute& frag_meta() {\n-        assert(m_type == TOK_INTERPOLATED_META);\n-        return *reinterpret_cast<AST::Attribute*>(m_data.as_Fragment());\n-    }\n-    \n-    ::std::unique_ptr<AST::ExprNode> take_frag_node();\n-    ::AST::Named<AST::Item> take_frag_item();\n-\n-    bool operator==(const Token& r) const {\n-        if (type() != r.type())\n-            return false;\n-        TU_MATCH(Data, (m_data, r.m_data), (e, re), (None, return true;), (String, return e == re;), (Integer, return e.m_datatype == re.m_datatype && e.m_intval == re.m_intval;), (Float, return e.m_datatype == re.m_datatype && e.m_floatval == re.m_floatval;), (Fragment, assert(!\"Token equality on Fragment\");))\n-        throw \"\";\n-    }\n-    \n-    bool operator!=(const Token& r) const { return !(*this == r); }\n-\n-    ::std::string to_str() const;\n-\n-    void set_pos(Position pos) { m_pos = pos; }\n-    const Position& get_pos() const { return m_pos; }\n-\n-    static const char* typestr(enum eTokenType type);\n-    static eTokenType typefromstr(const ::std::string& s);\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const Token& tok);\n-};\n-\n-extern ::std::ostream& operator<<(::std::ostream& os, const Token& tok);"}, {"sha": "889c626c6477a05104f1a81dd1ba91ff86102a16", "filename": "gcc/rust/mrustc_parser/parse/tokenstream.cpp", "status": "removed", "additions": 0, "deletions": 153, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,153 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/tokenstream.cpp\n- * - TokenStream - Parser token source interface\n- */\n-#include \"tokenstream.hpp\"\n-#include <common.hpp>\n-#include \"parseerror.hpp\"\n-\n-const bool DEBUG_PRINT_TOKENS = false;\n-//const bool DEBUG_PRINT_TOKENS = true;\n-//#define DEBUG_PRINT_TOKENS  debug_enabled(\"Lexer Tokens\")\n-//#define FULL_TRACE\n-\n-TokenStream::TokenStream():\n-    m_cache_valid(false)\n-{\n-}\n-TokenStream::~TokenStream()\n-{\n-}\n-\n-Token TokenStream::innerGetToken()\n-{\n-    Token ret = this->realGetToken();\n-    if( ret != TOK_EOF && ret.get_pos().filename == \"\" )\n-        ret.set_pos( this->getPosition() );\n-    //DEBUG(\"ret.get_pos() = \" << ret.get_pos());\n-    return ret;\n-}\n-Token TokenStream::getToken()\n-{\n-    if( m_cache_valid )\n-    {\n-#ifdef FULL_TRACE\n-        DEBUG(\"<<< \" << m_cache << \" (cache)\");\n-#endif\n-        m_cache_valid = false;\n-        return mv$(m_cache);\n-    }\n-    else if( m_lookahead.size() )\n-    {\n-        Token ret = mv$( m_lookahead.front().first );\n-        m_hygiene = m_lookahead.front().second;\n-        m_lookahead.erase(m_lookahead.begin());\n-#ifdef FULL_TRACE\n-        DEBUG(\"<<< \" << ret << \" (lookahead)\");\n-#endif\n-        if( DEBUG_PRINT_TOKENS ) {\n-            ::std::cout << \"getToken[\" << typeid(*this).name() << \"] - \" << ret.get_pos() << \"-\" << ret << ::std::endl;\n-        }\n-        return ret;\n-    }\n-    else\n-    {\n-        Token ret = this->innerGetToken();\n-        m_hygiene = this->realGetHygiene();\n-#ifdef FULL_TRACE\n-        DEBUG(\"<<< \" << ret << \" (new)\");\n-#endif\n-        if( DEBUG_PRINT_TOKENS ) {\n-            ::std::cout << \"getToken[\" << typeid(*this).name() << \"] - \" << ret.get_pos() << \"-\" << ret << ::std::endl;\n-        }\n-        return ret;\n-    }\n-}\n-void TokenStream::putback(Token tok)\n-{\n-    if( m_cache_valid )\n-    {\n-        DEBUG(\"\" << getPosition() << \" - Double putback: \" << tok << \" but \" << m_cache);\n-        throw ParseError::BugCheck(\"Double putback\");\n-    }\n-    else\n-    {\n-#ifdef FULL_TRACE\n-        DEBUG(\">>> \" << tok);\n-#endif\n-        m_cache_valid = true;\n-        m_cache = mv$(tok);\n-    }\n-}\n-\n-eTokenType TokenStream::lookahead(unsigned int i)\n-{\n-    const unsigned int MAX_LOOKAHEAD = 3;\n-\n-    if( m_cache_valid )\n-    {\n-        if( i == 0 )\n-            return m_cache.type();\n-        i --;\n-    }\n-\n-    if( i >= MAX_LOOKAHEAD )\n-        throw ParseError::BugCheck(\"Excessive lookahead\");\n-\n-    while( i >= m_lookahead.size() )\n-    {\n-        DEBUG(\"lookahead - read #\" << m_lookahead.size());\n-        auto tok = this->innerGetToken();\n-        auto hygiene = this->realGetHygiene();\n-        m_lookahead.push_back( ::std::make_pair(mv$(tok), mv$(hygiene)) );\n-    }\n-\n-    DEBUG(\"lookahead(\" << i << \") = \" << m_lookahead[i]);\n-    return m_lookahead[i].first.type();\n-}\n-\n-Ident::Hygiene TokenStream::getHygiene() const\n-{\n-    return m_hygiene;\n-}\n-\n-ProtoSpan TokenStream::start_span() const\n-{\n-    auto p = this->getPosition();\n-    return ProtoSpan {\n-        p.filename,\n-        p.line, p.ofs\n-        };\n-}\n-Span TokenStream::end_span(ProtoSpan ps) const\n-{\n-    auto p = this->getPosition();\n-    auto rv = Span( ::std::move(ps.filename),  ps.start_line, ps.start_ofs,  p.line, p.ofs );\n-    rv.outer_span = this->outerSpan();\n-    return rv;\n-}\n-Span TokenStream::point_span() const\n-{\n-    Span rv = this->getPosition();\n-    rv.outer_span = this->outerSpan();\n-    return rv;\n-}\n-Ident TokenStream::get_ident(Token tok) const\n-{\n-    if(tok.type() == TOK_IDENT) {\n-        return Ident(getHygiene(), tok.str());\n-    }\n-    else if(tok.type() == TOK_LIFETIME) {\n-        // TODO: Maybe only when it's explicitly asked for?\n-        return Ident(getHygiene(), tok.str());\n-    }\n-    else if( tok.type() == TOK_INTERPOLATED_IDENT ) {\n-        TODO(getPosition(), \"get_ident from TOK_INTERPOLATED_IDENT\");\n-    }\n-    else {\n-        throw ParseError::Unexpected(*this, tok);\n-    }\n-}"}, {"sha": "a9d325c23c3015c538d71f828a9a007187e9894c", "filename": "gcc/rust/mrustc_parser/parse/tokenstream.hpp", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokenstream.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,105 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/tokenstream.hpp\n- * - Parser stream (TokenStream) header\n- */\n-#pragma once\n-\n-#include <iostream>\n-#include <vector>\n-#include <span.hpp>\n-#include <debug.hpp>\n-#include <ident.hpp>\n-#include \"token.hpp\"\n-\n-namespace AST {\n-    class Module;\n-    class AttributeList;\n-}\n-\n-/// State the parser needs to pass down via a second channel.\n-struct ParseState\n-{\n-    // Used for \"for/if/while\" to handle ambiguity\n-    bool disallow_struct_literal = false;\n-    // A debugging hook that disables expansion of macros\n-    bool no_expand_macros = false;\n-\n-    ::AST::Module*  module = nullptr;\n-    ::AST::AttributeList*   parent_attrs = nullptr;\n-\n-    ::AST::Module& get_current_mod() {\n-        assert(this->module);\n-        return *this->module;\n-    }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const ParseState& ps) {\n-        os << \"ParseState {\";\n-        if(ps.disallow_struct_literal)  os << \" disallow_struct_literal\";\n-        if(ps.no_expand_macros)  os << \" no_expand_macros\";\n-        os << \" }\";\n-        return os;\n-    }\n-};\n-\n-class TokenStream\n-{\n-    friend class TTLexer;   // needs access to internals to know what was consumed\n-\n-    bool    m_cache_valid;\n-    Token   m_cache;\n-    Ident::Hygiene  m_hygiene;\n-    ::std::vector< ::std::pair<Token, Ident::Hygiene> > m_lookahead;\n-    ParseState  m_parse_state;\n-public:\n-    TokenStream();\n-    virtual ~TokenStream();\n-    Token   getToken();\n-    void    putback(Token tok);\n-    eTokenType  lookahead(unsigned int count);\n-\n-    Ident::Hygiene getHygiene() const;\n-    virtual void push_hygine() {}\n-    virtual void pop_hygine() {}\n-\n-    ParseState& parse_state() { return m_parse_state; }\n-\n-    ProtoSpan   start_span() const;\n-    Span    end_span(ProtoSpan ps) const;\n-    Span    point_span() const;\n-\n-    Ident get_ident(Token tok) const;\n-\n-protected:\n-    virtual Position getPosition() const = 0;\n-    virtual ::std::shared_ptr<Span> outerSpan() const { return ::std::shared_ptr<Span>(0); }\n-    virtual Token   realGetToken() = 0;\n-    virtual Ident::Hygiene realGetHygiene() const = 0;\n-private:\n-    Token innerGetToken();\n-};\n-\n-class SavedParseState\n-{\n-    TokenStream&    m_lex;\n-    ParseState  m_state;\n-public:\n-    SavedParseState(TokenStream& lex, ParseState state):\n-        m_lex(lex),\n-        m_state(state)\n-    {\n-    }\n-    ~SavedParseState()\n-    {\n-        DEBUG(\"Restoring \" << m_state);\n-        m_lex.parse_state() = m_state;\n-    }\n-};\n-\n-#define SET_MODULE(lex, mod)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().module = &(mod)\n-#define SET_ATTRS(lex, attrs)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().parent_attrs = &(attrs)\n-#define SET_PARSE_FLAG(lex, flag)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().flag = true\n-#define CLEAR_PARSE_FLAG(lex, flag)    SavedParseState _sps(lex, lex.parse_state()); lex.parse_state().flag = false\n-#define CHECK_PARSE_FLAG(lex, flag) (lex.parse_state().flag == true)"}, {"sha": "2d807f7d8f8cd62be5dd18bce6484e679ee2e80f", "filename": "gcc/rust/mrustc_parser/parse/tokentree.cpp", "status": "removed", "additions": 0, "deletions": 55, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,55 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/tokentree.cpp\n- * - Token Tree (collection of tokens)\n- */\n-#include \"tokentree.hpp\"\n-#include <common.hpp>\n-\n-TokenTree TokenTree::clone() const\n-{\n-    if( m_subtrees.size() == 0 ) {\n-        return TokenTree(m_hygiene, m_tok.clone());\n-    }\n-    else {\n-        ::std::vector< TokenTree>   ents;\n-        ents.reserve( m_subtrees.size() );\n-        for(const auto& sub : m_subtrees)\n-            ents.push_back( sub.clone() );\n-        return TokenTree( m_hygiene, mv$(ents) );\n-    }\n-}\n-\n-::std::ostream& operator<<(::std::ostream& os, const TokenTree& tt)\n-{\n-    if( tt.m_subtrees.size() == 0 )\n-    {\n-        switch(tt.m_tok.type())\n-        {\n-        case TOK_IDENT:\n-        case TOK_LIFETIME:\n-            os << \"/*\" << tt.m_hygiene << \"*/\";\n-            break;\n-        default:\n-            if( TOK_INTERPOLATED_IDENT <= tt.m_tok.type() && tt.m_tok.type() <= TOK_INTERPOLATED_ITEM ) {\n-                os << \"/*int*/\";\n-            }\n-            break;\n-        }\n-        return os << tt.m_tok.to_str();\n-    }\n-    else {\n-        os << \"/*\" << tt.m_hygiene << \" TT*/\";\n-        // NOTE: All TTs (except the outer tt on a macro invocation) include the grouping\n-        bool first = true;\n-        for(const auto& i : tt.m_subtrees) {\n-            if(!first)\n-                os << \" \";\n-            os << i;\n-            first = false;\n-        }\n-        return os;\n-    }\n-}"}, {"sha": "3d6e63deef3c952da772243f072ed29a594a7a6e", "filename": "gcc/rust/mrustc_parser/parse/tokentree.hpp", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftokentree.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,61 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/tokentree.hpp\n- * - Token Trees (groups of tokens\n- */\n-#ifndef TOKENTREE_HPP_INCLUDED\n-#define TOKENTREE_HPP_INCLUDED\n-\n-#include \"token.hpp\"\n-#include <ident.hpp>\n-#include <vector>\n-\n-class TokenTree\n-{\n-    Ident::Hygiene m_hygiene;\n-    Token   m_tok;\n-    ::std::vector<TokenTree>    m_subtrees;\n-public:\n-    virtual ~TokenTree() {}\n-    TokenTree() {}\n-    TokenTree(TokenTree&&) = default;\n-    TokenTree& operator=(TokenTree&&) = default;\n-    TokenTree(enum eTokenType ty):\n-        m_tok( Token(ty) )\n-    {\n-    }\n-    TokenTree(Token tok):\n-        m_tok( ::std::move(tok) )\n-    {\n-    }\n-    TokenTree(Ident::Hygiene hygiene, Token tok):\n-        m_hygiene( ::std::move(hygiene) ),\n-        m_tok( ::std::move(tok) )\n-    {\n-    }\n-    TokenTree(Ident::Hygiene hygiene, ::std::vector<TokenTree> subtrees):\n-        m_hygiene( ::std::move(hygiene) ),\n-        m_subtrees( ::std::move(subtrees) )\n-    {\n-    }\n-\n-    TokenTree clone() const;\n-\n-    bool is_token() const {\n-        return m_tok.type() != TOK_NULL;\n-    }\n-    unsigned int size() const {\n-        return m_subtrees.size();\n-    }\n-    const TokenTree& operator[](unsigned int idx) const { assert(idx < m_subtrees.size()); return m_subtrees[idx]; }\n-          TokenTree& operator[](unsigned int idx)       { assert(idx < m_subtrees.size()); return m_subtrees[idx]; }\n-    const Token& tok() const { return m_tok; }\n-          Token& tok()       { return m_tok; }\n-    const Ident::Hygiene& hygiene() const { return m_hygiene; }\n-\n-    friend ::std::ostream& operator<<(::std::ostream& os, const TokenTree& tt);\n-};\n-\n-#endif // TOKENTREE_HPP_INCLUDED"}, {"sha": "32c9a90ac19546b7dc8e3b62b6f434f24c7ddfef", "filename": "gcc/rust/mrustc_parser/parse/ttstream.cpp", "status": "removed", "additions": 0, "deletions": 121, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,121 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/ttstream.cpp\n- * - Token-Tree backed token streams\n- */\n-#include \"ttstream.hpp\"\n-#include <common.hpp>\n-\n-TTStream::TTStream(Span parent, const TokenTree& input_tt):\n-    m_parent_span( new Span(mv$(parent)) )\n-{\n-    DEBUG(\"input_tt = [\" << input_tt << \"]\");\n-    m_stack.push_back( ::std::make_pair(0, &input_tt) );\n-}\n-TTStream::~TTStream()\n-{\n-}\n-Token TTStream::realGetToken()\n-{\n-    while(m_stack.size() > 0)\n-    {\n-        // If current index is above TT size, go up\n-        unsigned int& idx = m_stack.back().first;\n-        assert( m_stack.back().second );\n-        const TokenTree& tree = *m_stack.back().second;\n-\n-        if(idx == 0 && tree.is_token()) {\n-            idx ++;\n-            m_hygiene_ptr = &tree.hygiene();\n-            return tree.tok();\n-        }\n-\n-        if(idx < tree.size())\n-        {\n-            const TokenTree&    subtree = tree[idx];\n-            idx ++;\n-            if( subtree.size() == 0 ) {\n-                m_hygiene_ptr = &subtree.hygiene();\n-                return subtree.tok().clone();\n-            }\n-            else {\n-                m_stack.push_back( ::std::make_pair(0, &subtree) );\n-            }\n-        }\n-        else {\n-            m_stack.pop_back();\n-        }\n-    }\n-    //m_hygiene = nullptr;\n-    return Token(TOK_EOF);\n-}\n-Position TTStream::getPosition() const\n-{\n-    // TODO: Position associated with the previous/next token?\n-    return Position(\"TTStream\", 0,0);\n-}\n-Ident::Hygiene TTStream::realGetHygiene() const\n-{\n-    // Empty.\n-    if(!m_hygiene_ptr)\n-        return Ident::Hygiene();\n-    return *m_hygiene_ptr;\n-}\n-\n-\n-TTStreamO::TTStreamO(Span parent, TokenTree input_tt):\n-    m_input_tt( mv$(input_tt) ),\n-    m_parent_span( new Span(mv$(parent)) )\n-{\n-    m_stack.push_back( ::std::make_pair(0, nullptr) );\n-}\n-TTStreamO::~TTStreamO()\n-{\n-}\n-Token TTStreamO::realGetToken()\n-{\n-    while(m_stack.size() > 0)\n-    {\n-        // If current index is above TT size, go up\n-        unsigned int& idx = m_stack.back().first;\n-        TokenTree& tree = (m_stack.back().second ? *m_stack.back().second : m_input_tt);\n-\n-        if(idx == 0 && tree.is_token()) {\n-            idx ++;\n-            m_last_pos = tree.tok().get_pos();\n-            m_hygiene_ptr = &tree.hygiene();\n-            return mv$(tree.tok());\n-        }\n-\n-        if(idx < tree.size())\n-        {\n-            TokenTree& subtree = tree[idx];\n-            idx ++;\n-            if( subtree.size() == 0 ) {\n-                m_last_pos = subtree.tok().get_pos();\n-                m_hygiene_ptr = &subtree.hygiene();\n-                return mv$( subtree.tok() );\n-            }\n-            else {\n-                m_stack.push_back( ::std::make_pair(0, &subtree) );\n-            }\n-        }\n-        else {\n-            m_stack.pop_back();\n-        }\n-    }\n-    return Token(TOK_EOF);\n-}\n-Position TTStreamO::getPosition() const\n-{\n-    return m_last_pos;\n-}\n-Ident::Hygiene TTStreamO::realGetHygiene() const\n-{\n-    // Empty.\n-    if(!m_hygiene_ptr)\n-        return Ident::Hygiene();\n-    return *m_hygiene_ptr;\n-}"}, {"sha": "530a177bef395b09c177a6783a5feefbfb512cb0", "filename": "gcc/rust/mrustc_parser/parse/ttstream.hpp", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Fttstream.hpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,57 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/ttstrea.hpp\n- * - Token tree streams (for post-lex parsing)\n- */\n-#pragma once\n-\n-#include \"tokentree.hpp\"\n-#include \"tokenstream.hpp\"\n-\n-/// Borrowed TTStream\n-class TTStream:\n-    public TokenStream\n-{\n-    ::std::vector< ::std::pair<unsigned int, const TokenTree*> > m_stack;\n-    ::std::shared_ptr<Span> m_parent_span;\n-    const Ident::Hygiene*   m_hygiene_ptr = nullptr;\n-public:\n-    TTStream(Span parent, const TokenTree& input_tt);\n-    ~TTStream();\n-\n-    TTStream& operator=(const TTStream& x) { m_stack = x.m_stack; return *this; }\n-\n-    Position getPosition() const override;\n-    ::std::shared_ptr<Span> outerSpan() const override { return m_parent_span; }\n-\n-protected:\n-    Ident::Hygiene realGetHygiene() const override;\n-    Token realGetToken() override;\n-};\n-\n-/// Owned TTStream\n-class TTStreamO:\n-    public TokenStream\n-{\n-    Position    m_last_pos;\n-    TokenTree   m_input_tt;\n-    ::std::vector< ::std::pair<unsigned int, TokenTree*> > m_stack;\n-    const Ident::Hygiene*   m_hygiene_ptr = nullptr;\n-public:\n-    ::std::shared_ptr<Span> m_parent_span;\n-    TTStreamO(Span parent, TokenTree input_tt);\n-    TTStreamO(TTStreamO&& x) = default;\n-    ~TTStreamO();\n-\n-    TTStreamO& operator=(const TTStreamO& x) { m_stack = x.m_stack; return *this; }\n-    TTStreamO& operator=(TTStreamO&& x) = default;\n-\n-    Position getPosition() const override;\n-    ::std::shared_ptr<Span> outerSpan() const override { return m_parent_span; }\n-\n-protected:\n-    Ident::Hygiene realGetHygiene() const override;\n-    Token realGetToken() override;\n-};"}, {"sha": "ca5b78923c44b307f967071ef4a8cb62c1858835", "filename": "gcc/rust/mrustc_parser/parse/types.cpp", "status": "removed", "additions": 0, "deletions": 340, "changes": 340, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fmrustc_parser%2Fparse%2Ftypes.cpp?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,340 +0,0 @@\n-/*\n- * MRustC - Rust Compiler\n- * - By John Hodge (Mutabah/thePowersGang)\n- *\n- * parse/types.cpp\n- * - Parsing for type usages\n- */\n-#include \"common.hpp\"\n-#include \"parseerror.hpp\"\n-#include <ast/types.hpp>\n-#include <ast/ast.hpp>\n-\n-// === PROTOTYPES ===\n-//TypeRef Parse_Type(TokenStream& lex, bool allow_trait_list);\n-TypeRef Parse_Type_Int(TokenStream& lex, bool allow_trait_list);\n-TypeRef Parse_Type_Fn(TokenStream& lex, AST::HigherRankedBounds hrbs = {});\n-TypeRef Parse_Type_Path(TokenStream& lex, AST::HigherRankedBounds hrbs, bool allow_trait_list);\n-TypeRef Parse_Type_ErasedType(TokenStream& lex, bool allow_trait_list);\n-\n-// === CODE ===\n-TypeRef Parse_Type(TokenStream& lex, bool allow_trait_list)\n-{\n-    ProtoSpan ps = lex.start_span();\n-    TypeRef rv = Parse_Type_Int(lex, allow_trait_list);\n-    //rv.set_span(lex.end_span(ps));\n-    return rv;\n-}\n-\n-TypeRef Parse_Type_Int(TokenStream& lex, bool allow_trait_list)\n-{\n-    //TRACE_FUNCTION;\n-    auto ps = lex.start_span();\n-\n-    Token tok;\n-\n-    switch( GET_TOK(tok, lex) )\n-    {\n-    case TOK_INTERPOLATED_TYPE:\n-        return mv$(tok.frag_type());\n-    // '!' - Only ever used as part of function prototypes, but is kinda a type... not allowed here though\n-    case TOK_EXCLAM:\n-        return TypeRef( Span(tok.get_pos()), TypeData::make_Bang({}) );\n-    // '_' = Wildcard (type inferrence variable)\n-    case TOK_UNDERSCORE:\n-        return TypeRef(Span(tok.get_pos()));\n-\n-    // 'unsafe' - An unsafe function type\n-    case TOK_RWORD_UNSAFE:\n-    // 'extern' - A function type with an ABI\n-    case TOK_RWORD_EXTERN:\n-    // 'fn' - Rust function\n-    case TOK_RWORD_FN:\n-        PUTBACK(tok, lex);\n-        return Parse_Type_Fn(lex);\n-\n-    case TOK_RWORD_IMPL:\n-        return Parse_Type_ErasedType(lex, allow_trait_list);\n-\n-    // '<' - An associated type cast\n-    case TOK_LT:\n-    case TOK_DOUBLE_LT: {\n-        PUTBACK(tok, lex);\n-        auto path = Parse_Path(lex, PATH_GENERIC_TYPE);\n-        return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), mv$(path));\n-        }\n-    //\n-    case TOK_RWORD_FOR: {\n-        auto hrls = Parse_HRB(lex);\n-        switch(LOOK_AHEAD(lex))\n-        {\n-        case TOK_RWORD_UNSAFE:\n-        case TOK_RWORD_EXTERN:\n-        case TOK_RWORD_FN:\n-            return Parse_Type_Fn(lex, hrls);\n-        default:\n-            return Parse_Type_Path(lex, hrls, true);\n-        }\n-        }\n-    // <ident> - Either a primitive, or a path\n-    case TOK_IDENT:\n-        if( lex.lookahead(0) == TOK_EXCLAM )\n-        {\n-            lex.getToken();\n-            // TODO: path macros\n-            return TypeRef(TypeRef::TagMacro(), Parse_MacroInvocation(ps, mv$(tok.str()), lex));\n-        }\n-        // or a primitive\n-        //if( auto ct = coretype_fromstring(tok.str()) )\n-        //{\n-        //    return TypeRef(TypeRef::TagPrimitive(), Span(tok.get_pos()), ct);\n-        //}\n-        PUTBACK(tok, lex);\n-        return Parse_Type_Path(lex, {}, allow_trait_list);\n-        // - Fall through to path handling\n-    // '::' - Absolute path\n-    case TOK_DOUBLE_COLON:\n-    // 'self' - This relative path\n-    case TOK_RWORD_SELF:\n-    // 'super' - Parent relative path\n-    case TOK_RWORD_SUPER:\n-    // ':path' fragment\n-    case TOK_INTERPOLATED_PATH:\n-        PUTBACK(tok, lex);\n-        return Parse_Type_Path(lex, {}, allow_trait_list);\n-\n-    // HACK! Convert && into & &\n-    case TOK_DOUBLE_AMP:\n-        lex.putback(Token(TOK_AMP));\n-    // '&' - Reference type\n-    case TOK_AMP: {\n-        AST::LifetimeRef lifetime;\n-        // Reference\n-        tok = lex.getToken();\n-        if( tok.type() == TOK_LIFETIME ) {\n-            lifetime = AST::LifetimeRef(/*lex.point_span(), */lex.get_ident(::std::move(tok)));\n-            tok = lex.getToken();\n-        }\n-        bool is_mut = false;\n-        if( tok.type() == TOK_RWORD_MUT ) {\n-            is_mut = true;\n-        }\n-        else {\n-            PUTBACK(tok, lex);\n-        }\n-        return TypeRef(TypeRef::TagReference(), lex.end_span(mv$(ps)), ::std::move(lifetime), is_mut, Parse_Type(lex, false));\n-        }\n-    // '*' - Raw pointer\n-    case TOK_STAR:\n-        // Pointer\n-        switch( GET_TOK(tok, lex) )\n-        {\n-        case TOK_RWORD_MUT:\n-            // Mutable pointer\n-            return TypeRef(TypeRef::TagPointer(), lex.end_span(mv$(ps)), true, Parse_Type(lex, false));\n-        case TOK_RWORD_CONST:\n-            // Immutable pointer\n-            return TypeRef(TypeRef::TagPointer(), lex.end_span(mv$(ps)), false, Parse_Type(lex, false));\n-        default:\n-            throw ParseError::Unexpected(lex, tok, {TOK_RWORD_CONST, TOK_RWORD_MUT});\n-        }\n-        throw ParseError::BugCheck(\"Reached end of Parse_Type:STAR\");\n-    // '[' - Array type\n-    case TOK_SQUARE_OPEN: {\n-        // Array\n-        TypeRef inner = Parse_Type(lex);\n-        if( GET_TOK(tok, lex)  == TOK_SEMICOLON ) {\n-            // Sized array\n-            AST::Expr array_size = Parse_Expr(lex);\n-            GET_CHECK_TOK(tok, lex, TOK_SQUARE_CLOSE);\n-            return TypeRef(TypeRef::TagSizedArray(), lex.end_span(mv$(ps)), mv$(inner), array_size.take_node());\n-        }\n-        else if( tok.type() == TOK_SQUARE_CLOSE )\n-        {\n-            return TypeRef(TypeRef::TagUnsizedArray(), lex.end_span(mv$(ps)), mv$(inner));\n-        }\n-        else {\n-            throw ParseError::Unexpected(lex, tok/*, \"; or ]\"*/);\n-        }\n-        }\n-\n-    // '(' - Tuple (or lifetime bounded trait)\n-    case TOK_PAREN_OPEN: {\n-        DEBUG(\"Tuple\");\n-        if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n-            return TypeRef(TypeRef::TagTuple(), lex.end_span(mv$(ps)), {});\n-        PUTBACK(tok, lex);\n-\n-        TypeRef inner = Parse_Type(lex, true);\n-        if( LOOK_AHEAD(lex) == TOK_PAREN_CLOSE )\n-        {\n-            // Type in parens, NOT a tuple\n-            GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n-            return inner;\n-        }\n-        else\n-        {\n-            ::std::vector<TypeRef>  types;\n-            types.push_back( mv$(inner) );\n-            while( GET_TOK(tok, lex) == TOK_COMMA )\n-            {\n-                if( GET_TOK(tok, lex) == TOK_PAREN_CLOSE )\n-                    break;\n-                else\n-                    PUTBACK(tok, lex);\n-                types.push_back( Parse_Type(lex) );\n-            }\n-            CHECK_TOK(tok, TOK_PAREN_CLOSE);\n-            return TypeRef(TypeRef::TagTuple(), lex.end_span(mv$(ps)), mv$(types)); }\n-        }\n-    default:\n-        throw ParseError::Unexpected(lex, tok);\n-    }\n-    throw ParseError::BugCheck(\"Reached end of Parse_Type\");\n-}\n-\n-TypeRef Parse_Type_Fn(TokenStream& lex, ::AST::HigherRankedBounds hrbs)\n-{\n-    auto ps = lex.start_span();\n-    TRACE_FUNCTION;\n-    Token   tok;\n-\n-    ::std::string   abi = \"\";\n-    bool    is_unsafe = false;\n-\n-    GET_TOK(tok, lex);\n-\n-    // `unsafe`\n-    if( tok.type() == TOK_RWORD_UNSAFE )\n-    {\n-        is_unsafe = true;\n-        GET_TOK(tok, lex);\n-    }\n-    // `exern`\n-    if( tok.type() == TOK_RWORD_EXTERN )\n-    {\n-        if( GET_TOK(tok, lex) == TOK_STRING ) {\n-            abi = tok.str();\n-            if( abi == \"\" )\n-                ERROR(lex.point_span(), E0000, \"Empty ABI\");\n-            GET_TOK(tok, lex);\n-        }\n-        else {\n-            abi = \"C\";\n-        }\n-    }\n-    // `fn`\n-    CHECK_TOK(tok, TOK_RWORD_FN);\n-\n-    ::std::vector<TypeRef>  args;\n-    bool is_variadic = false;\n-    GET_CHECK_TOK(tok, lex, TOK_PAREN_OPEN);\n-    while( LOOK_AHEAD(lex) != TOK_PAREN_CLOSE )\n-    {\n-        if( LOOK_AHEAD(lex) == TOK_TRIPLE_DOT ) {\n-            GET_TOK(tok, lex);\n-            is_variadic = true;\n-            break;\n-        }\n-        // Handle `ident: `\n-        if( (lex.lookahead(0) == TOK_IDENT || lex.lookahead(0) == TOK_UNDERSCORE) && lex.lookahead(1) == TOK_COLON ) {\n-            GET_TOK(tok, lex);\n-            GET_TOK(tok, lex);\n-        }\n-        args.push_back( Parse_Type(lex) );\n-        if( GET_TOK(tok, lex) != TOK_COMMA ) {\n-            PUTBACK(tok, lex);\n-            break;\n-        }\n-    }\n-    GET_CHECK_TOK(tok, lex, TOK_PAREN_CLOSE);\n-\n-    // `-> RetType`\n-    TypeRef ret_type = TypeRef(TypeRef::TagUnit(), Span(tok.get_pos()));\n-    if( GET_TOK(tok, lex) == TOK_THINARROW )\n-    {\n-        ret_type = Parse_Type(lex, false);\n-    }\n-    else {\n-        PUTBACK(tok, lex);\n-    }\n-\n-    return TypeRef(TypeRef::TagFunction(), lex.end_span(mv$(ps)), mv$(hrbs), is_unsafe, mv$(abi), mv$(args), is_variadic, mv$(ret_type));\n-}\n-\n-TypeRef Parse_Type_Path(TokenStream& lex, ::AST::HigherRankedBounds hrbs, bool allow_trait_list)\n-{\n-    Token   tok;\n-\n-    auto ps = lex.start_span();\n-\n-    if( hrbs.empty() && !allow_trait_list )\n-    {\n-        return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), Parse_Path(lex, PATH_GENERIC_TYPE));\n-    }\n-    else\n-    {\n-        ::std::vector<Type_TraitPath>   traits;\n-        ::std::vector<AST::LifetimeRef> lifetimes;\n-\n-        traits.push_back(Type_TraitPath { mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n-\n-        if( allow_trait_list )\n-        {\n-            while( GET_TOK(tok, lex) == TOK_PLUS )\n-            {\n-                if( LOOK_AHEAD(lex) == TOK_LIFETIME ) {\n-                    GET_TOK(tok, lex);\n-                    lifetimes.push_back(AST::LifetimeRef( /*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n-                }\n-                else\n-                {\n-                    if( lex.lookahead(0) == TOK_RWORD_FOR )\n-                    {\n-                        hrbs = Parse_HRB(lex);\n-                    }\n-                    traits.push_back({ mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n-                }\n-            }\n-            PUTBACK(tok, lex);\n-        }\n-\n-        if( !traits[0].hrbs.empty() || traits.size() > 1 || lifetimes.size() > 0 )\n-        {\n-            if( lifetimes.empty())\n-                lifetimes.push_back(AST::LifetimeRef());\n-            return TypeRef(lex.end_span(mv$(ps)), mv$(traits), mv$(lifetimes));\n-        }\n-        else\n-        {\n-            return TypeRef(TypeRef::TagPath(), lex.end_span(mv$(ps)), mv$(traits.at(0).path));\n-        }\n-    }\n-}\n-TypeRef Parse_Type_ErasedType(TokenStream& lex, bool allow_trait_list)\n-{\n-    Token   tok;\n-\n-    auto ps = lex.start_span();\n-    ::std::vector<Type_TraitPath>   traits;\n-    ::std::vector<AST::LifetimeRef>   lifetimes;\n-    do {\n-        if( LOOK_AHEAD(lex) == TOK_LIFETIME ) {\n-            GET_TOK(tok, lex);\n-            lifetimes.push_back(AST::LifetimeRef( /*lex.point_span(),*/ lex.get_ident(mv$(tok)) ));\n-        }\n-        else\n-        {\n-            AST::HigherRankedBounds hrbs;\n-            if( lex.lookahead(0) == TOK_RWORD_FOR )\n-            {\n-                hrbs = Parse_HRB(lex);\n-            }\n-            traits.push_back({ mv$(hrbs), Parse_Path(lex, PATH_GENERIC_TYPE) });\n-        }\n-    } while( GET_TOK(tok, lex) == TOK_PLUS );\n-    PUTBACK(tok, lex);\n-\n-    return TypeRef(lex.end_span(mv$(ps)), TypeData::make_ErasedType({ mv$(traits), mv$(lifetimes) }));\n-}\n-"}, {"sha": "7ac9301ca1986dd20853ea6505c8677b8f980156", "filename": "gcc/rust/old/lang-specs.h", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Flang-specs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,19 +0,0 @@\n-/* This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify it under\n-the terms of the GNU General Public License as published by the Free\n-Software Foundation; either version 3, or (at your option) any later\n-version.\n-\n-GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-{\".rs\",  \"@rs\", 0, 1, 0},\n-{\"@rs\",  \"grs1 %i %(cc1_options) %{I*} %{L*} %D %{!fsyntax-only:%(invoke_as)}\",\n-    0, 1, 0},"}, {"sha": "f63afb8e707e605e441b67b4977f29afe5e051e9", "filename": "gcc/rust/old/rdot-dataflow.cc", "status": "removed", "additions": 0, "deletions": 883, "changes": 883, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-dataflow.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-dataflow.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,883 +0,0 @@\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>. */\n-\n-#include \"rust.h\"\n-\n-static std::vector<std::map<std::string, rdot> *> context;\n-static rdot dot_pass_typeifyExprNode (rdot);\n-static bool dot_pass_typeCompare (const rdot, const rdot);\n-static rdot impl_master = NULL_DOT;\n-\n-static\n-void dot_pass_dataFlow_pushCtx (void)\n-{\n-  std::map<std::string, rdot> * ctx = new std::map<std::string, rdot>;\n-  context.push_back (ctx);\n-}\n-\n-static\n-void dot_pass_dataFlow_popCtx (void)\n-{\n-  std::map<std::string, rdot> * ctx = context.back ();\n-  context.pop_back ();\n-  delete ctx;\n-}\n-\n-static\n-rdot dot_pass_dataFlow_lookup (const char * id)\n-{\n-  rdot retval = NULL_DOT;\n-  std::vector<std::map<std::string, rdot> *>::reverse_iterator it;\n-  for (it = context.rbegin (); it != context.rend (); ++it)\n-    {\n-      std::map<std::string, rdot> * ctx = *it;\n-      if (ctx->count (std::string (id)))\n-        {\n-          retval = (*ctx)[std::string (id)];\n-          break;\n-        }\n-    }\n-  return retval;\n-}\n-\n-static\n-bool dot_pass_dataFlow_pushDecl (rdot node, const char * id)\n-{\n-  rdot check = dot_pass_dataFlow_lookup (id);\n-  if (check != NULL_DOT)\n-    {\n-      error (\"DataFlow duplicate declaration [%s]\\n\", id);\n-      return true;\n-    }\n-\n-  bool retval = false;\n-  if ((RDOT_TYPE (node) == D_VAR_DECL)\n-      || (RDOT_TYPE (node) == D_STRUCT_METHOD)\n-      || (RDOT_TYPE (node) == D_STRUCT_TYPE))\n-    {\n-      std::map<std::string, rdot> * ctx = context.back ();\n-      (*ctx) [std::string (id)] = node;\n-    }\n-  else\n-    {\n-      error (\"Invalid dataflow declaration pushing to context [%s]\\n\",\n-             RDOT_OPCODE_STR (node));\n-      retval = true;\n-    }\n-  return retval;\n-}\n-\n-static void dot_pass_dataFlowToplevel (rdot);\n-static void dot_pass_dataFlowFunction (rdot);\n-static void dot_pass_dataFlowBlock (rdot);\n-\n-static\n-bool verifyType (rdot node)\n-{\n-  bool retval = false;\n-  switch (RDOT_TYPE (node))\n-    {\n-    case RTYPE_BOOL:\n-    case RTYPE_INT:\n-    case RTYPE_FLOAT:\n-    case RTYPE_UINT:\n-      retval = true;\n-      break;\n-        \n-    default:\n-      break;\n-    }\n-  return retval;\n-}\n-\n-static\n-rdot dot_pass_dataFlow_getDecl (rdot node)\n-{\n-  rdot retval = NULL_DOT;\n-  if (RDOT_T_FIELD (node) == D_D_EXPR)\n-    {\n-      // only if its a modify expr\n-      if (RDOT_TYPE (node) == D_MODIFY_EXPR)\n-        {\n-          rdot decl = RDOT_lhs_TT (node);\n-          if (RDOT_TYPE (decl) == D_VAR_DECL)\n-            retval = decl;\n-        }\n-      else if (RDOT_TYPE (node) == D_VAR_DECL)\n-        retval = node;\n-    }\n-  return retval;\n-}\n-\n-static\n-void dot_pass_dataFlowBlock_retvals (rdot suite, std::vector<rdot> * retval)\n-{\n-  rdot next;\n-  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      if (RDOT_T_FIELD (next) == D_D_EXPR)\n-\t{\n-\t  if (DOT_RETVAL (next))\n-\t    retval->push_back (next);\n-\t}\n-      else\n-\t{\n-\t  switch (RDOT_TYPE (next))\n-\t    {\n-\t    case D_STRUCT_WHILE:\n-\t      dot_pass_dataFlowBlock_retvals (RDOT_rhs_TT (next), retval);\n-\t      break;\n-\n-\t    case D_STRUCT_IF:\n-\t      {\n-\t\trdot ifblock = RDOT_lhs_TT (next);\n-\t\trdot elseblock = RDOT_rhs_TT (next);\n-\t\tdot_pass_dataFlowBlock_retvals (RDOT_rhs_TT (ifblock), retval);\n-\t\tif (elseblock != NULL_DOT)\n-\t\t  dot_pass_dataFlowBlock_retvals (RDOT_lhs_TT (elseblock), retval);\n-\t      }\n-\t      break;\n-\n-\t    default:\n-\t      error (\"unable to figure out what to do with [%s]\",\n-\t\t     RDOT_OPCODE_STR (next));\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-/*\n-  Takes a var_decl and returns the rhs of assignment to try and infer a type on.\n-  eg1 :\n-  let x;\n-  x = 1 + 2\n-  will return the NULL on the decl and RDOT (1+2) on the expression\n-\n-  eg2:\n-  let x = 1;\n-  ruturns RDOT (1)\n-*/\n-static\n-rdot dot_pass_dataFlow_getRef (rdot decl, rdot var_decl)\n-{\n-  rdot retval = NULL_DOT;\n-  if (RDOT_TYPE (decl) == D_MODIFY_EXPR)\n-    {\n-      rdot lhs = RDOT_lhs_TT (decl);\n-      rdot rhs = RDOT_rhs_TT (decl);\n-\n-      switch (RDOT_TYPE (lhs))\n-        {\n-        case D_VAR_DECL:\n-          {\n-            if (var_decl == lhs)\n-              retval = rhs;\n-          }\n-          break;\n-\n-        case D_IDENTIFIER:\n-          {\n-            const char * vid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (var_decl));\n-            const char * cid = RDOT_IDENTIFIER_POINTER (lhs);\n-            // we found a reference assignment...\n-            if (strcmp (vid, cid) == 0)\n-              retval = rhs;\n-          }\n-          break;\n-\n-        default:\n-          break;\n-        }\n-    }\n-  return retval;\n-}\n-\n-static\n-std::vector<rdot> * dot_pass_getReferences (rdot vDecl, rdot suite)\n-{\n-  std::vector<rdot> * retval = new std::vector<rdot>;\n-  rdot node;\n-  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n-    {\n-      switch (RDOT_TYPE (node))\n-\t{\n-\tcase D_PRIMITIVE:\n-\tcase D_CALL_EXPR:\n-\tcase D_ATTRIB_REF:\n-\t  break;\n-\n-\tcase D_MODIFY_EXPR:\n-\t  {\n-\t    rdot ref = dot_pass_dataFlow_getRef (node, vDecl);\n-\t    if (ref != NULL_DOT)\n-\t      retval->push_back (ref);\n-\t  }\n-\t  break;\n-\n-\tcase D_STRUCT_WHILE:\n-\t  {\n-\t    rdot wsuite = RDOT_rhs_TT (node);\n-\t    std::vector<rdot> * refs = dot_pass_getReferences (vDecl, wsuite);\n-            // append to the list\n-\t    std::vector<rdot>::iterator it;\n-\t    for (it = refs->begin (); it != refs->end (); ++it)\n-              retval->push_back (*it);\n-\t    delete refs;\n-\t  }\n-\t  break;\n-\n-\tcase D_STRUCT_IF:\n-\t  {\n-\t    rdot ifb = RDOT_lhs_TT (node);\n-\t    rdot elb = RDOT_rhs_TT (node);\n-\n-\t    rdot ifsuite = RDOT_rhs_TT (ifb);\n-\t    std::vector<rdot> * refs = dot_pass_getReferences (vDecl, ifsuite);\n-\n-\t    // append to the list\n-\t    std::vector<rdot>::iterator it;\n-\t    for (it = refs->begin (); it != refs->end (); ++it)\n-              retval->push_back (*it);\n-\t    delete refs;\n-\n-\t    if (elb != NULL_DOT)\n-\t      {\n-\t\trefs = dot_pass_getReferences (vDecl, RDOT_lhs_TT (elb));\n-\t\tfor (it = refs->begin (); it != refs->end (); ++it)\n-\t\t  retval->push_back (*it);\n-\t\tdelete refs;\n-\t      }\n-\t  }\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-  return retval;\n-}\n-\n-static bool\n-dot_pass_typeCompare (const rdot x, const rdot y)\n-{\n-  bool retval = false;\n-  if (RDOT_TYPE (x) == RDOT_TYPE (y))\n-    if (RDOT_MEM_MODIFIER (x)->size () == RDOT_MEM_MODIFIER (y)->size ())\n-      {\n-        retval = true;\n-        std::vector<ALLOCA_>::iterator xit;\n-        std::vector<ALLOCA_>::iterator yit;\n-        for (xit = RDOT_MEM_MODIFIER (x)->begin (),\n-               yit = RDOT_MEM_MODIFIER (y)->begin ();\n-             xit != RDOT_MEM_MODIFIER (x)->end ();\n-             ++xit, ++yit)\n-          {\n-            if (*xit != *yit)\n-              {\n-                retval = false;\n-                break;\n-              }\n-          }\n-      }\n-  return retval;\n-}\n-\n-static char *\n-dot_pass_typeString (const rdot node)\n-{\n-  char buffer [128];\n-  size_t offset = 0;\n-\n-  std::vector<ALLOCA_>::iterator it;\n-  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-       it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n-    {\n-      switch (*it)\n-\t{\n-\tcase ALLOC_DEREF:\n-\t  buffer [offset++] = '*';\n-\t  break;\n-\tcase ALLOC_HEAP:\n-\t  buffer [offset++] = '~';\n-\t  break;\n-\tcase ALLOC_REF:\n-\t  buffer [offset++] = '&';\n-\t  break;\n-\t}\n-    }\n-  strcpy (buffer+offset, RDOT_OPCODE_STR (node));\n-  return xstrdup (buffer);\n-}\n-\n-/**\n- * WARN:\n- *   This really needs more analysis on why, if you have : infered something has:\n- *   infer, int, string\n- *   infer, int, infer. Does it mean its an int probably.\n- *   Currently it drops any possible type to be an int\n- **/\n-static\n-rdot dot_pass_inferTheType (std::vector<rdot> * refs, const char * id)\n-{\n-  rdot retval = NULL_DOT;\n-  rdot _retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n-  gcc_assert (refs->size () > 0);\n-\n-  std::vector<rdot> possible_types;\n-  std::vector<rdot>::iterator it;\n-  for (it = refs->begin (); it != refs->end (); ++it)\n-    {\n-      rdot pos = dot_pass_typeifyExprNode (*it);\n-      if (RDOT_TYPE (pos) != RTYPE_INFER)\n-\tpossible_types.push_back (pos);\n-    }\n-\n-  if (possible_types.size () == 0)\n-    retval = _retval;\n-  else\n-    {\n-      bool first = true;\n-      std::vector<rdot>::iterator pit;\n-      for (pit = possible_types.begin (); pit != possible_types.end (); ++pit)\n-\t{\n-\t  if (first == true)\n-\t    {\n-\t      retval = *pit;\n-\t      first = false;\n-\t    }          \n-\t  if (!dot_pass_typeCompare (retval, *pit))\n-\t    {\n-              char * t1 = dot_pass_typeString (retval);\n-              char * t2 = dot_pass_typeString (*pit);\n-              error (\"Ambigious types found for [%s] -> [%s] OR [%s]\", id, t1, t2);\n-\t      retval = _retval;\n-              free (t1);\n-              free (t2);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  return retval;\n-}\n-\n-static\n-rdot dot_pass_typeifyPrimitive (rdot node)\n-{\n-  rdot retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n-  gcc_assert (RDOT_TYPE (node) == D_PRIMITIVE);\n-\n-  switch (node->opa.tc.T == D_T_INTEGER)\n-    {\n-    case D_T_INTEGER:\n-      RDOT_TYPE (retval) = RTYPE_INT;\n-      break;\n-\n-    default:\n-      error (\"Unable to figure out type for this primitive [%s]!\",\n-             RDOT_CODE_STR (node->opa.tc.T));\n-      break;\n-    }\n-  std::vector<ALLOCA_>::iterator it;\n-  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-       it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n-    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-  return retval;\n-}\n-\n-/* FIXME maybe i feel this isn't done very well at all here */\n-static\n-rdot dot_pass_typeifyExprNode (rdot node)\n-{\n-  rdot retval = rdot_build_decl1 (RTYPE_INFER, NULL_DOT);\n-  switch (RDOT_TYPE (node))\n-    {\n-    case D_PRIMITIVE:\n-      retval = dot_pass_typeifyPrimitive (node);\n-      break;\n-\n-    case D_IDENTIFIER:\n-      {\n-        rdot lookup = dot_pass_dataFlow_lookup (RDOT_IDENTIFIER_POINTER (node));\n-        if (lookup == NULL_DOT)\n-          error (\"unable to find declaration of [%s] in current scope\",\n-                 RDOT_IDENTIFIER_POINTER (node));\n-        else\n-          {\n-            gcc_assert (RDOT_TYPE (lookup) == D_VAR_DECL);\n-            RDOT_TYPE (retval) = RDOT_TYPE (RDOT_rhs_TT (lookup));\n-            if (RDOT_TYPE (retval) == RTYPE_USER_STRUCT)\n-              {\n-                RDOT_lhs_TT (retval) = RDOT_lhs_TT (RDOT_rhs_TT (lookup));\n-                RDOT_rhs_TT (retval) = RDOT_rhs_TT (RDOT_rhs_TT (lookup));\n-              }\n-            std::vector<ALLOCA_>::iterator it;\n-            if (RDOT_MEM_MODIFIER (node))\n-              for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-                   it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n-                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-            if (RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup)))\n-              for (it = RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup))->begin ();\n-                   it != RDOT_MEM_MODIFIER (RDOT_rhs_TT (lookup))->end (); ++it)\n-                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-          }\n-      }\n-      break;\n-\n-    case D_STRUCT_INIT:\n-      {\n-\tconst char * slookup = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-\trdot lookup = dot_pass_dataFlow_lookup (slookup);\n-\tif (lookup != NULL_DOT)\n-\t  {\n-\t    if (RDOT_TYPE (lookup) == D_STRUCT_TYPE)\n-\t      {\n-                RDOT_TYPE (retval) = RTYPE_USER_STRUCT;\n-                RDOT_lhs_TT (retval) = RDOT_lhs_TT (lookup); // identifier node\n-                RDOT_rhs_TT (retval) = RDOT_rhs_TT (lookup); // struct layout\n-                std::vector<ALLOCA_>::iterator it;\n-                if (RDOT_MEM_MODIFIER (node))\n-                  for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-                       it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n-                    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-                if (RDOT_MEM_MODIFIER (lookup))\n-                  for (it = RDOT_MEM_MODIFIER (lookup)->begin ();\n-                       it != RDOT_MEM_MODIFIER (lookup)->end (); ++it)\n-                    RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-\t      }\n-\t    else\n-\t      error (\"unable to determine type of [%s] struct initilization, \"\n-\t\t     \"[%s] was found in this scope\",\n-\t\t     slookup, RDOT_OPCODE_STR (lookup));\n-\t  }\n-\telse\n-\t  error (\"[%s] does not name a type in scope\", slookup);\n-      }\n-      break;\n-\n-    case D_CALL_EXPR:\n-      {\n-        const char * callid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-        rdot lookup = dot_pass_dataFlow_lookup (callid);\n-        if (lookup != NULL_DOT)\n-          {\n-            gcc_assert (RDOT_TYPE (lookup) == D_STRUCT_METHOD);\n-            RDOT_TYPE (retval) = RDOT_TYPE (RDOT_FIELD2 (lookup));\n-            std::vector<ALLOCA_> * mods = RDOT_MEM_MODIFIER (RDOT_FIELD2 (lookup));\n-            std::vector<ALLOCA_>::iterator it;\n-            if (RDOT_MEM_MODIFIER (node))\n-              for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-                   it != RDOT_MEM_MODIFIER (node)->end (); ++it)\n-                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-            if (mods)\n-              for (it = mods->begin (); it != mods->end (); ++it)\n-                RDOT_MEM_MODIFIER (retval)->push_back (*it);\n-          }\n-        else\n-          error (\"unable to find declaration of [%s] in current scope\",\n-                 callid);\n-      }\n-      break;\n-\n-    case D_ATTRIB_REF:\n-      {\n-        rdot lhs = RDOT_lhs_TT (node);\n-        rdot base_type = dot_pass_typeifyExprNode (lhs);\n-        gcc_assert (RDOT_TYPE (base_type) == RTYPE_USER_STRUCT);\n-      }\n-      break;\n-\n-    case D_ACC_EXPR:\n-      {\n-\trdot impl = RDOT_lhs_TT (node);\n-\tchar * implid = RDOT_IDENTIFIER_POINTER (impl);\n-\trdot lookup = dot_pass_dataFlow_lookup (implid);\n-\n-\tbool found = false;\n-\trdot next;\n-\tfor (next = RDOT_rhs_TT (RDOT_FIELD (lookup));\n-\t     next != NULL_DOT; next = RDOT_CHAIN (next))\n-\t  {\n-\t    switch (RDOT_TYPE (next))\n-\t      {\n-\t      case D_STRUCT_METHOD:\n-\t\tRDOT_TYPE (retval) = RDOT_TYPE (RDOT_FIELD2 (next));\n-\t\tbreak;\n-\n-\t      default:\n-\t\terror_at (RDOT_LOCATION (next), \"unable to identify [%s] for type inferance\",\n-\t\t\t  RDOT_OPCODE_STR (next));\n-\t\tbreak;\n-\t      }\n-\t  }\n-\tif (!found)\n-\t  break;\n-      }\n-      break;\n-\n-    case D_ADD_EXPR:\n-    case D_MINUS_EXPR:\n-    case D_MULT_EXPR:\n-    case D_DIVD_EXPR:\n-      {\n-        rdot lhs = RDOT_lhs_TT (node);\n-        rdot rhs = RDOT_rhs_TT (node);\n-\n-\trdot lt = dot_pass_typeifyExprNode (lhs);\n-\trdot rt = dot_pass_typeifyExprNode (rhs);\n-\n-\tif (RDOT_TYPE (lt) != RTYPE_INFER\n-\t    || RDOT_TYPE (rt) != RTYPE_INFER)\n-\t  {\n-            if (RDOT_TYPE (lt) == RDOT_TYPE (rt))\n-              retval = lt;\n-            else\n-              {\n-                if (RDOT_TYPE (lt) == RTYPE_INFER || RDOT_TYPE (rt) == RTYPE_INFER)\n-                  retval = RDOT_TYPE (lt) == RTYPE_INFER ? rt : lt;\n-                else\n-                  error (\"unable to coerce types [%s] and [%s]\",\n-                         RDOT_OPCODE_STR (lt), RDOT_OPCODE_STR (rt));\n-              }\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      error (\"Unable to figure out the type of this [%s]\",\n-\t     RDOT_OPCODE_STR (node));\n-      break;\n-    }\n-\n-  bool skip_next = false;\n-  std::vector<ALLOCA_> nmods;\n-  std::vector<ALLOCA_> * pmods = RDOT_MEM_MODIFIER (retval);\n-  \n-  std::vector<ALLOCA_>::iterator it;\n-  for (it = pmods->begin (); it != pmods->end (); ++it)\n-    {\n-      switch (*it)\n-\t{\n-\tcase ALLOC_DEREF:\n-\t  skip_next = true;\n-\t  break;\n-              \n-\tdefault:\n-\t  {\n-\t    if (!skip_next)\n-\t      {\n-\t\tnmods.push_back (*it);\n-\t\tskip_next = false;\n-\t      }\n-\t  }\n-\t  break;\n-\t}\n-    }\n-  RDOT_MMEM_COPY ((&nmods), RDOT_MEM_MODIFIER (retval));\n-  return retval;\n-}\n-\n-static\n-void dot_pass_mutability (const rdot node)\n-{\n-  rdot lhs = RDOT_lhs_TT (node);\n-  if (RDOT_TYPE (lhs) != D_VAR_DECL)\n-    {\n-      // check the nodes mutability\n-      switch (RDOT_TYPE (lhs))\n-\t{\n-\tcase D_IDENTIFIER:\n-\t  {\n-\t    const char * ident = RDOT_IDENTIFIER_POINTER (lhs);\n-\t    const rdot node = dot_pass_dataFlow_lookup (ident);\n-\t    if (node == NULL_DOT)\n-\t      error_at (RDOT_LOCATION (node), \"Unable to find decl [%s] in current scope\", ident);\n-\t    else if (RDOT_qual (node) == true)\n-\t      error_at (RDOT_LOCATION (node), \"Unable to modify [%s] it is immutable\", ident);\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  {\n-\t    const char * nstr = RDOT_OPCODE_STR (lhs);\n-\t    warning_at (RDOT_LOCATION (node), 0, \"TODO unable to verify assignment\"\n-\t\t\t\"mutability for [%s]\", nstr);\n-\t  }\n-\t  break;\n-\t}\n-    }\n-}\n-\n-static\n-void dot_pass_dataFlowBlock_ (rdot suite, std::vector<rdot> * decls)\n-{\n-  rdot node;\n-  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n-    {\n-      if (RDOT_T_FIELD (node) == D_D_EXPR)\n-        {\n-\t  if (RDOT_TYPE (node) == D_MODIFY_EXPR)\n-\t    dot_pass_mutability (node);\n-\n-          const char * id = NULL;\n-          rdot decl = dot_pass_dataFlow_getDecl (node);\n-          if (decl != NULL_DOT)\n-            {\n-\t      gcc_assert (RDOT_TYPE (decl) == D_VAR_DECL);\n-\t      id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (decl));\n-\t      decls->push_back (decl);\n-\n-              // push it into the current context...\n-              rdot lookup = dot_pass_dataFlow_lookup (id);\n-              if (lookup != NULL_DOT)\n-                error (\"Duplicate declaration of [%s] to [%s]\",\n-                       id, RDOT_OPCODE_STR (lookup));\n-              else\n-                gcc_assert (!dot_pass_dataFlow_pushDecl (decl, id));\n-            }\n-        }\n-      else\n-\t{\n-\t  switch (RDOT_TYPE (node))\n-\t    {\n-\t    case D_STRUCT_IF:\n-\t      {\n-\t\trdot sif = RDOT_lhs_TT (node);\n-\t\trdot ses = RDOT_rhs_TT (node);\n-\n-\t\tdot_pass_dataFlowBlock_ (RDOT_rhs_TT (sif), decls);\n-\t\tif (ses != NULL_DOT)\n-\t\t  dot_pass_dataFlowBlock_ (RDOT_lhs_TT (ses), decls);\n-\t      }\n-\t      break;\n-\n-\t    case D_STRUCT_WHILE:\n-\t      dot_pass_dataFlowBlock_ (RDOT_rhs_TT (node), decls);\n-\t      break;\n-\n-            case D_STRUCT_LOOP:\n-              dot_pass_dataFlowBlock_ (RDOT_lhs_TT (node), decls);\n-              break;\n-\n-            case C_BREAK_STMT:\n-            case C_CONT_STMT:\n-              break;\n-\n-\t    default:\n-\t      error (\"Unhandled data flow in block on [%s]\\n\", RDOT_OPCODE_STR (node));\n-\t      break;\n-\t    }\n-\t}\n-    }\n-}\n-\n-static\n-void dot_pass_dataFlowBlock (rdot suite)\n-{\n-  std::vector<rdot> block_decls;\n-  dot_pass_dataFlowBlock_ (suite, &block_decls);\n-\n-  // now we have all defined block declarations now need to get all\n-  // references in their use if they have an undefined type.\n-  std::vector<rdot>::iterator it;\n-  for (it = block_decls.begin (); it != block_decls.end (); ++it)\n-    {\n-      rdot decl = *it;\n-      gcc_assert (RDOT_TYPE (decl) == D_VAR_DECL);\n-      rdot idecl = RDOT_lhs_TT (decl);\n-      const char * ident = RDOT_IDENTIFIER_POINTER (idecl);\n-      if (RDOT_TYPE (RDOT_rhs_TT (decl)) == RTYPE_INFER)\n-\t{\n-\t  std::vector<rdot> * refs = dot_pass_getReferences (decl, suite);\n-\t  if (refs->size () == 0)\n-\t    {\n-\t      error (\"Unable to infer type of [%s] it looks to \"\n-\t\t     \"be unused in this scope\", ident);\n-\t      continue;\n-\t    }\n-\t  RDOT_rhs_TT (decl) = dot_pass_inferTheType (refs, ident);\n-\t  if (RDOT_TYPE (RDOT_rhs_TT (decl)) == RTYPE_INFER)\n-\t    error (\"Compiler was unable to infer the type for [%s]\", ident);\n-\t  delete refs;\n-\t}\n-    }\n-}\n-\n-static\n-void dot_pass_dataFlowFunction (rdot node)\n-{\n-  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-  rdot type = RDOT_FIELD2 (node);\n-\n-  // rust does not infer function types empty types are default void\n-  // and parameters are synatically required to be typed\n-  dot_pass_dataFlow_pushCtx ();\n-\n-  // fill up the parameters here\n-  rdot params;\n-  for (params = RDOT_lhs_TT (node); params != NULL_DOT;\n-       params = RDOT_CHAIN (params))\n-    {\n-      rdot pident = RDOT_lhs_TT (params);\n-      rdot ptype = RDOT_rhs_TT (params);\n-\n-      const char * cpid = RDOT_IDENTIFIER_POINTER (pident);\n-      if (strcmp (cpid, \"self\") == 0)\n-\t{\n-\t  gcc_assert (impl_master != NULL_DOT);\n-\t  rdot stid = RDOT_lhs_TT (impl_master);\n-\t  ptype = rdot_build_decl1 (RTYPE_USER_STRUCT, stid);\n-\t}\n-      rdot vpdecl = rdot_build_varDecl (ptype, RDOT_qual (params), pident);\n-      bool chk = dot_pass_dataFlow_pushDecl (vpdecl,\n-\t\t\t\t\t     RDOT_IDENTIFIER_POINTER (pident));\n-      gcc_assert (chk == false);\n-    }\n-\n-  rdot suite = RDOT_rhs_TT (node);\n-  dot_pass_dataFlowBlock (suite);\n-\n-  // now check the return type is correct\n-  /* make sure its a valid type! */\n-  if (type != NULL)\n-    {\n-      bool verify = verifyType (type);\n-      if (verify == false)\n-        error (\"unable to verify return type of %s [%s]\\n\",\n-               method_id, RDOT_OPCODE_STR (type));\n-      else\n-\t{\n-\t  std::vector<rdot> retvals;\n-\t  dot_pass_dataFlowBlock_retvals (suite, &retvals);\n-\n-\t  if (retvals.size () == 0)\n-\t    error (\"Function [%s] does not seem to return anything!\", method_id);\n-\t  else\n-\t    {\n-\t      rdot retype = dot_pass_inferTheType (&retvals, method_id);\n-\t      if (RDOT_TYPE (retype) == RTYPE_INFER)\n-\t\terror (\"gcc rust was unable to verify the return type of [%s]\",\n-\t\t       method_id);\n-\t    }\n-\t}\n-    }\n-  dot_pass_dataFlow_popCtx ();\n-}\n-\n-static\n-void dot_pass_dataFlowToplevel (rdot node)\n-{\n-  switch (RDOT_TYPE (node))\n-    {\n-    case D_STRUCT_METHOD:\n-      dot_pass_dataFlowFunction (node);\n-      break;\n-\n-      /* need to dataflow the layout to check the types eventually */\n-    case D_STRUCT_TYPE:\n-      break;\n-\n-    case D_STRUCT_IMPL:\n-      {\n-\t// look up to make sure the impl name is available...\n-\tconst char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-\trdot lookup = dot_pass_dataFlow_lookup (implid);\n-\tif (lookup == NULL_DOT)\n-\t  error (\"impl [%s] does not reference a type in scope\", implid);\n-\telse\n-\t  {\n-\t    if (RDOT_TYPE (lookup) != D_STRUCT_TYPE)\n-\t      error (\"impl [%s] does not reference a struct points to [%s]\",\n-\t\t     implid, RDOT_OPCODE_STR (lookup));\n-\t    else\n-\t      {\n-\t\tRDOT_FIELD (lookup) = node;\n-\t\timpl_master = lookup;\n-\t\trdot next;\n-\t\tfor (next = RDOT_rhs_TT (node); next != NULL_DOT;\n-\t\t     next = RDOT_CHAIN (next))\n-                  dot_pass_dataFlowFunction (next);\n-\t\timpl_master = NULL_DOT;\n-\t      }\n-\t  }\n-      }\n-      break;\n-\n-    default:\n-      error (\"Unable to dataflow %s\\n\", RDOT_OPCODE_STR (node));\n-      break;\n-    }\n-}\n-\n-vec<rdot,va_gc> * dot_pass_inferTypes (vec<rdot,va_gc> * decls)\n-{\n-  dot_pass_dataFlow_pushCtx ();\n-\n-  rdot idtx = NULL_DOT;\n-  size_t i;\n-  for (i = 0; decls->iterate (i, &idtx); ++i)\n-    {\n-      rdot node = idtx;\n-      switch (RDOT_TYPE (node))\n-\t{\n-\tcase D_STRUCT_METHOD:\n-\t  {\n-\t    const char * id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-\t    if (dot_pass_dataFlow_lookup (id))\n-\t      error (\"Duplicate declaration against this function [%s]\\n\", id);\n-\t    else\n-\t      dot_pass_dataFlow_pushDecl (node, id);\n-\t  }\n-\t  break;\n-\n-\tcase D_STRUCT_TYPE:\n-\t  {\n-\t    const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-\t    if (dot_pass_dataFlow_lookup (id))\n-\t      error (\"Duplicate declaration against this type [%s]\\n\", id);\n-\t    else\n-\t      dot_pass_dataFlow_pushDecl (node, id);\n-\t  }\n-\t  break;\n-\n-\tcase D_STRUCT_IMPL:\n-\t  {\n-\t    // look up to make sure the impl name is available...\n-\t    const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-\t    rdot lookup = dot_pass_dataFlow_lookup (implid);\n-\t    if (lookup == NULL_DOT)\n-\t      error (\"impl [%s] does not reference a type in scope\", implid);\n-\t    else\n-\t      {\n-\t\tif (RDOT_TYPE (lookup) != D_STRUCT_TYPE)\n-\t\t  error (\"impl [%s] does not reference a struct points to [%s]\",\n-\t\t\t implid, RDOT_OPCODE_STR (lookup));\n-\t\telse\n-\t\t  RDOT_FIELD (lookup) = node;\n-\t      }\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  for (i = 0; decls->iterate (i, &idtx); ++i)\n-    dot_pass_dataFlowToplevel (idtx);\n-\n-  dot_pass_dataFlow_popCtx ();\n-  return decls;\n-}"}, {"sha": "13b09a480d87b1fc3436ce88ff8247d724d671fe", "filename": "gcc/rust/old/rdot-generic-compiler.cc", "status": "removed", "additions": 0, "deletions": 1202, "changes": 1202, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-generic-compiler.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,1202 +0,0 @@\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>. */\n-\n-#include \"rust.h\"\n-\n-#define RUST_TMP \"RUST_TMP\"\n-\n-static std::vector<std::map<std::string, tree> *> context;\n-\n-static tree dot_pass_genFndecl_Basic (location_t, const char *, tree);\n-static tree dot_pass_lookupCTU (const char *);\n-static std::vector<tree> * dot_pass_popContext (void);\n-static void dot_pass_pushContext (void);\n-static void dot_pass_genMethodProto (rdot);\n-static void dot_pass_compileSuite (rdot, tree *);\n-\n-#define RDOT_ALLOCA_MODIFIERS_DO(_X, _Y)                                \\\n-  if (RDOT_MEM_MODIFIER (_Y))\t\t\t\t\t\t\\\n-    do {\t\t\t\t\t\t\t\t\\\n-      gcc_assert (_X != error_mark_node);\t\t\t\t\\\n-      std::vector<ALLOCA_>::reverse_iterator __rit;\t\t\t\\\n-      for (__rit = RDOT_MEM_MODIFIER (_Y)->rbegin ();\t\t\t\\\n-\t   __rit != RDOT_MEM_MODIFIER (_Y)->rend (); ++__rit)\t\t\\\n-\t{\t\t\t\t\t\t\t\t\\\n-\t  switch (*__rit)\t\t\t\t\t\t\\\n-\t    {\t\t\t\t\t\t\t\t\\\n-\t    case ALLOC_HEAP:\t\t\t\t\t\t\\\n-\t      _X = dot_pass_heapify (_X, TREE_TYPE (_X),\t\t\\\n-\t\t\t\t     TYPE_SIZE_UNIT (TREE_TYPE (_X)));\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    case ALLOC_REF:\t\t\t\t\t\t\\\n-\t      _X = build_fold_addr_expr (_X);\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    case ALLOC_DEREF:\t\t\t\t\t\t\\\n-\t      {\t\t\t\t\t\t\t\t\\\n-\t\t_X = build_fold_indirect_ref_loc (RDOT_LOCATION (_Y),\t\\\n-\t\t\t\t\t\t  _X);\t\t\t\\\n-\t\tTREE_THIS_NOTRAP (_X) = 1;\t\t\t\t\\\n-\t      }\t\t\t\t\t\t\t\t\\\n-\t      break;\t\t\t\t\t\t\t\\\n-\t    }\t\t\t\t\t\t\t\t\\\n-\t}\t\t\t\t\t\t\t\t\\\n-    } while (0)\n-\n-/* NOTE: this isn't global in the sense of the generated code,\n-   This just makes it easier for expression compilation to access\n-   the return decl */\n-static tree global_retDecl;\n-static tree * current_function_block;\n-static bool global_retDecl_;\n-static tree __impl_type_decl = error_mark_node;\n-static std::vector<tree> __loopContexts;\n-#define dot_pass_rustToGccType(_x, _y) dot_pass_rustToGccType__ (_x, _y, false, NULL)\n-\n-static\n-char * dot_pass_demangleImpl (const char * val)\n-{\n-  // has form of type.method_name\n-  size_t i;\n-  size_t last_dot = 0;\n-  for (i = 0; i < strlen (val); ++i)\n-    {\n-      if (val [i] == '.')\n-\tlast_dot = i;\n-    }\n-  size_t bsize = (strlen (val) - last_dot) * sizeof (char);\n-  char * buffer = (char *) xmalloc (bsize);\n-  memset (buffer, 0, bsize);\n-  strncpy (buffer, val + last_dot + 1, strlen (val) - last_dot);\n-\n-  return buffer;\n-}\n-\n-static\n-char * dot_pass_mangle (const char * val)\n-{\n-  // just for now pre-append __rust_[id] will do ok for now\n-  const char * stuff = \"__rust_\";\n-  size_t blen = (strlen (stuff) + strlen (val) + 1) * sizeof (char);\n-  char * retval = (char *) xmalloc (blen);\n-  memset (retval, 0, blen);\n-  snprintf (retval, blen, \"%s%s\", stuff, val);\n-  return retval;\n-}\n-\n-static\n-tree dot_pass_rustToGccType__ (rdot type, bool consty, bool rset, tree * record)\n-{\n-  tree retval = error_mark_node;\n-  switch (RDOT_TYPE (type))\n-    {\n-    case RTYPE_INT:\n-      retval = integer_type_node;\n-      break;\n-\n-    case D_STRUCT_TYPE:\n-    case D_STRUCT_INIT:\n-    case RTYPE_USER_STRUCT:\n-      {\n-\tconst char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (type));\n-\tretval = dot_pass_lookupCTU (id);\n-        if (rset)\n-          *record = retval;\n-        \n-\tif (retval == error_mark_node)\n-\t  error (\"Unable to find struct type [%s]\\n\", id);\n-      }\n-      break;\n-\n-    default:\n-      error (\"Unable to figure out gcc type for [%s]\\n\",\n-             RDOT_OPCODE_STR (type));\n-      break;\n-    }\n-  if (RDOT_MEM_MODIFIER (type))\n-    {\n-      std::vector<ALLOCA_>::reverse_iterator rit;\n-      for (rit = RDOT_MEM_MODIFIER (type)->rbegin ();\n-\t   rit != RDOT_MEM_MODIFIER (type)->rend (); ++rit)\n-\t{\n-\t  switch (*rit)\n-\t    {\n-\t    case ALLOC_REF:\n-\t    case ALLOC_HEAP:\n-\t      retval = build_pointer_type (retval);\n-\t      break;\n-\t    default:\n-\t      fatal_error (\"cannot figure out modifier applied to type [%i]\", *rit);\n-\t      break;\n-\t    }\n-\t}\n-    }\n-  if (consty)\n-    retval = build_qualified_type (retval, TYPE_QUAL_CONST);\n-  return retval;\n-}\n-\n-static\n-tree dot_pass_genFndecl_Basic (location_t loc, const char * ident, tree fntype)\n-{\n-  tree fndecl = build_decl (loc, FUNCTION_DECL,\n-                            get_identifier (ident), fntype);\n-  TREE_STATIC (fndecl) = 0;\n-  TREE_USED (fndecl) = 1;\n-  TREE_PUBLIC (fndecl) = 1;\n-\n-  tree argslist = NULL_TREE;\n-  DECL_ARGUMENTS (fndecl) = argslist;\n-\n-  tree resdecl = build_decl (BUILTINS_LOCATION, RESULT_DECL,\n-                             NULL_TREE, TREE_TYPE (fntype));\n-  DECL_CONTEXT (resdecl) = fndecl;\n-  DECL_ARTIFICIAL (resdecl) = true;\n-  DECL_IGNORED_P (resdecl) = true;\n-  DECL_RESULT (fndecl) = resdecl;\n-\n-  if (DECL_STRUCT_FUNCTION (fndecl) == NULL)\n-    push_struct_function (fndecl);\n-  else\n-    push_cfun (DECL_STRUCT_FUNCTION (fndecl));\n-  return fndecl;\n-}\n-\n-static\n-tree dot_pass_generateCString (const char * str)\n-{\n-  tree index_type = build_index_type (size_int (strlen (str)));\n-  tree const_char_type = build_qualified_type (char_type_node, TYPE_QUAL_CONST);\n-  tree string_type = build_array_type (const_char_type, index_type);\n-  string_type = build_variant_type_copy (string_type);\n-\n-  TYPE_STRING_FLAG (string_type) = 1;\n-  tree string_val = build_string (strlen (str), str);\n-  TREE_TYPE (string_val) = string_type;\n-\n-  return string_val;\n-}\n-\n-static\n-tree dot_pass_lookupCTU (const char * id)\n-{\n-  tree retval = error_mark_node;\n-\n-  std::vector<std::map<std::string, tree> *>::reverse_iterator it;\n-  for (it = context.rbegin (); it != context.rend (); ++it)\n-    {\n-      std::map<std::string, tree> * ctx = *it;\n-      if (ctx->count (std::string (id)) > 0)\n-\t{\n-          retval = ctx->at (std::string (id));\n-          break;\n-        }\n-    }\n-\n-  return retval;\n-}\n-\n-static\n-void dot_pass_pushDecl (const char * id, tree decl)\n-{\n-  tree test = dot_pass_lookupCTU (id);\n-  if (test == error_mark_node)\n-    {\n-      std::map<std::string, tree> * ctx = context.back ();\n-      (*ctx) [std::string (id)] = decl;\n-    }\n-  else\n-    error (\"duplicate declaration of [%s]\\n\", id);\n-}\n-\n-static tree\n-dot_pass_rust_RR_alloc (tree size)\n-{\n-  tree fntype = build_function_type_list (ptr_type_node,\n-                                          size_type_node,\n-                                          NULL_TREE);\n-  tree fndecl = build_decl (BUILTINS_LOCATION, FUNCTION_DECL,\n-                            get_identifier (\"__rust_heap_alloc\"),\n-                            fntype);\n-  tree restype = TREE_TYPE (fndecl);\n-  tree resdecl = build_decl (BUILTINS_LOCATION, RESULT_DECL, NULL_TREE,\n-                             restype);\n-  DECL_CONTEXT (resdecl) = fndecl;\n-  DECL_RESULT (fndecl) = resdecl;\n-  DECL_EXTERNAL (fndecl) = 1;\n-  TREE_PUBLIC (fndecl) = 1;\n-  return build_call_expr (fndecl, 1, size);\n-}\n-\n-static tree\n-dot_pass_heap_alloc (tree size, tree type)\n-{\n-  tree ptype = build_pointer_type (type);\n-  tree heap_tmp = build_decl (UNKNOWN_LOCATION, VAR_DECL,\n-                              create_tmp_var_name (RUST_TMP),\n-                              ptype);\n-  dot_pass_pushDecl (IDENTIFIER_POINTER (DECL_NAME (heap_tmp)), heap_tmp);\n-  append_to_statement_list (fold_build2 (MODIFY_EXPR, ptype, heap_tmp,\n-                                         dot_pass_rust_RR_alloc (size)),\n-                            current_function_block);\n-  return heap_tmp;\n-}\n-\n-static tree\n-dot_pass_heapify (tree value, tree type, tree size)\n-{\n-  tree alloc = dot_pass_heap_alloc (size, type);\n-  tree gmemcpy = builtin_decl_implicit (BUILT_IN_MEMCPY);\n-  vec<tree,va_gc> * args;\n-  vec_alloc (args, 0);\n-  vec_safe_push (args, alloc);\n-  vec_safe_push (args, build_fold_addr_expr (value));\n-  vec_safe_push (args, size);\n-  append_to_statement_list (build_call_expr_loc_vec (UNKNOWN_LOCATION, gmemcpy, args),\n-                            current_function_block);\n-  return alloc;\n-}\n-\n-static\n-tree dot_pass_genScalar (rdot decl)\n-{\n-  tree retval = error_mark_node;\n-  gcc_assert (RDOT_TYPE (decl) == D_PRIMITIVE);\n-  gcc_assert (RDOT_lhs_T (decl) == D_TD_COM);\n-\n-  switch (RDOT_lhs_TC (decl).T)\n-    {\n-    case D_T_INTEGER:\n-      retval = build_int_cst (integer_type_node, RDOT_lhs_TC (decl).o.integer);\n-      break;\n-      \n-    default:\n-      fatal_error (\"invalid scalar type %s!\\n\", RDOT_CODE_STR (RDOT_lhs_TC (decl).T));\n-      break;\n-    }\n-  return retval;\n-}\n-\n-static\n-tree dot_pass_genifyCall (tree mfndecl, vec<tree,va_gc> * arguments)\n-{\n-  tree retval = error_mark_node;\n-  if (TREE_CODE (mfndecl) == FUNCTION_DECL)\n-    {\n-      // size_t len = arguments->length ();\n-      // size_t lparms = 0;\n-      // tree types = TYPE_ARG_TYPES (mfndecl);\n-\n-      /* really need to check the calling types and number of arguments */\n-      retval = build_call_expr_loc_vec (UNKNOWN_LOCATION, mfndecl, arguments);\n-    }\n-  else\n-    error (\"trying to call a function which isn't callable [%s]\",\n-\t   IDENTIFIER_POINTER (mfndecl));\n-  return retval;\n-}\n-\n-static\n-tree dot_pass_lowerExpr (rdot dot, tree * block)\n-{\n-  tree retval = error_mark_node;\n-  switch (RDOT_TYPE (dot))\n-    {\n-    case D_PRIMITIVE:\n-      {\n-        retval = dot_pass_genScalar (dot);\n-        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n-      }\n-      break;\n-\n-    case D_IDENTIFIER:\n-      {\n-\tconst char * id = RDOT_IDENTIFIER_POINTER (dot);\n-\tretval = dot_pass_lookupCTU (id);\n-\tif (retval == error_mark_node)\n-\t  fatal_error (\"no such id [%s] in scope\", id);\n-        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n-      }\n-      break;\n-\n-    case D_STRUCT_INIT:\n-      {\n-\t// need to go fetch the type and build the constructor...\n-\tsize_t count = 0;\n-        tree root_type = error_mark_node;\n-\tdot_pass_rustToGccType__ (dot, false, true, &root_type);\n-        gcc_assert (root_type != error_mark_node);\n-\ttree fields = TYPE_FIELDS (root_type);\n-\n-\ttree fnext;\n-\tfor (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN (fnext))\n-\t  count++;\n-\tfnext = error_mark_node;\n-        \n-        vec<constructor_elt, va_gc> *init;\n-\tvec_alloc (init, count + 1);\n-\n-\t/*\n-\t  FIXME this is all very buggy:\n-\t  eg:\n-\t  struct test {\n-\t    x : int\n-            y : int\n-\t  }\n-\n-\t  initilize with test { x: 1, x: 1} will pass but it should fail\n-\t  needs more validation at dataflow level and here\n-\t */\n-        tree rid = create_tmp_var_name (RUST_TMP);\n-        retval = build_decl (RDOT_LOCATION (dot), VAR_DECL, rid, root_type);\n-        dot_pass_pushDecl (IDENTIFIER_POINTER (rid), retval);\n-\n-        constructor_elt empty = {NULL, NULL};\n-\trdot next;\n-\tsize_t valid = 0;\n-\tfor (next = RDOT_rhs_TT (dot); next != NULL_DOT; next = RDOT_CHAIN (next))\n-\t  {\n-            constructor_elt* elt = init->quick_push (empty);\n-            gcc_assert (RDOT_TYPE (next) == D_STRUCT_PARAM);\n-\t    bool found = false;\n-\t    for (fnext = fields; fnext != NULL_TREE; fnext = DECL_CHAIN (fnext))\n-\t      {\n-\t\tconst char * pid = IDENTIFIER_POINTER (DECL_NAME (fnext));\n-\t\tconst char * sid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n-\t\tif (strcmp (pid, sid) == 0)\n-\t\t  {\n-\t\t    found = true;\n-\t\t    break;\n-\t\t  }\n-\t      }\n-\t    if (!found)\n-\t      {\n-\t\terror (\"Unable to find field [%s] in struct [%s]\",\n-\t\t       IDENTIFIER_POINTER (TYPE_NAME (root_type)),\n-\t\t       RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next)));\n-\t\tbreak;\n-\t      }\n-\n-            elt->index = fnext;\n-            elt->value = fold_convert (TREE_TYPE (fnext),\n-                                       dot_pass_lowerExpr (RDOT_rhs_TT (next),\n-                                                           block));\n-\t    valid++;\n-\t  }\n-\tif (valid == count)\n-          {\n-            tree cons = build_constructor (root_type, init);\n-            append_to_statement_list (fold_build2_loc (RDOT_LOCATION (dot), INIT_EXPR,\n-                                                       root_type, retval, cons), block);\n-          }\n-        else\n-          {\n-            fatal_error (\"Cannot initilize struct required [%lu] fields got [%lu]\",\n-                         valid, count);\n-\t    // TODO better diagnostic make a map of the initilized so\n-\t    // we can display the un initilized to the user\n-\t  }\n-\tRDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n-      }\n-      break;\n-\n-    case D_CALL_EXPR:\n-      {\n-        const char * fnid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (dot));\n-        rdot ptr;\n-        vec<tree,va_gc> * arguments;\n-        vec_alloc (arguments, 0);\n-        for (ptr = RDOT_rhs_TT (dot); ptr != NULL_DOT;\n-             ptr = RDOT_CHAIN (ptr))\n-          vec_safe_push (arguments, dot_pass_lowerExpr (ptr, block));\n-        /* lookup the function prototype */\n-        tree lookup = dot_pass_lookupCTU (fnid);\n-        if (lookup != error_mark_node)\n-          retval = dot_pass_genifyCall (lookup, arguments);\n-        else\n-          {\n-            fatal_error (\"Unable to find callable %s\\n\", fnid);\n-            retval = error_mark_node;\n-          }\n-        RDOT_ALLOCA_MODIFIERS_DO (retval, dot);\n-      }\n-      break;\n-\n-    case D_ATTRIB_REF:\n-      {\n-\trdot lhs = RDOT_lhs_TT (dot);\n-\trdot rhs = RDOT_rhs_TT (dot);\n-\n-\ttree lookup = dot_pass_lowerExpr (lhs, block);\n-\tswitch (RDOT_TYPE (rhs))\n-\t  {\n-\t  case D_CALL_EXPR:\n-\t    {\n-\t      rdot crid = RDOT_lhs_TT (rhs);\n-\t      const char * rlookup = RDOT_IDENTIFIER_POINTER (crid);\n-\t      tree tid = TYPE_NAME (TREE_TYPE (lookup));\n-\t      const char * ctid = IDENTIFIER_POINTER (tid);\n-\n-\t      tree type_decl = dot_pass_lookupCTU (ctid);\n-\t      // just to be sure but we will have already error'd at this point..\n-\t      gcc_assert (type_decl != error_mark_node);\n-\n-\t      tree mths = TYPE_METHODS (type_decl);\n-\t      tree next;\n-\t      for (next = mths; next != NULL_TREE; next = DECL_CHAIN (next))\n-\t\t{\n-\t\t  const char * mid = IDENTIFIER_POINTER (DECL_NAME (next));\n-\t\t  char * demangle = dot_pass_demangleImpl (mid);\n-\t\t  if (strcmp (rlookup, demangle) == 0)\n-\t\t    {\n-\t\t      vec<tree,va_gc> * cargs;\n-\t\t      vec_alloc (cargs, 0);\n-\t\t      vec_safe_push (cargs, lookup);\n-\n-\t\t      rdot pnext;\n-\t\t      for (pnext = RDOT_rhs_TT (rhs); pnext != NULL_DOT;\n-\t\t\t   pnext = RDOT_CHAIN (pnext))\n-\t\t\tvec_safe_push (cargs, dot_pass_lowerExpr (pnext, block));\n-\n-\t\t      retval = dot_pass_genifyCall (next, cargs);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t    break;\n-\n-\t  case D_IDENTIFIER:\n-\t    {\n-\t      const char * rlookup = RDOT_IDENTIFIER_POINTER (rhs);\n-\t      tree fields = TYPE_FIELDS (TREE_TYPE (lookup));\n-\t      tree next;\n-\t      for (next = fields; next != NULL_TREE; next = DECL_CHAIN (next))\n-\t\t{\n-\t\t  const char * fid = IDENTIFIER_POINTER (DECL_NAME (next));\n-\t\t  if (strcmp (rlookup, fid) == 0)\n-\t\t    {\n-\t\t      /* no idea why we need build3 here but build2 fails... */\n-\t\t      retval = build3 (COMPONENT_REF, TREE_TYPE (next),\n-\t\t\t\t       lookup, next, NULL_TREE);\n-\t\t      break;\n-\t\t    }\n-\t\t}\n-\t    }\n-\t    break;\n-\n-\t  default:\n-\t    fatal_error (\"Really don't know what happened here!\\n\");\n-\t    break;\n-\t  }\n-      }\n-      break;\n-\n-    case D_MODIFY_EXPR:\n-      {\n-\ttree assignment = dot_pass_lowerExpr (RDOT_rhs_TT (dot), block);\n-\ttree decl = dot_pass_lowerExpr (RDOT_lhs_TT (dot), block);\n-        retval = build2 (MODIFY_EXPR, TREE_TYPE (decl), decl, assignment);\n-      }\n-      break;\n-\n-    case D_ADD_EXPR:\n-      {\n-\trdot lhs = RDOT_lhs_TT (dot);\n-        rdot rhs = RDOT_rhs_TT (dot);\n-\n-        tree xlhs = dot_pass_lowerExpr (lhs, block);\n-        tree xrhs = dot_pass_lowerExpr (rhs, block);\n-\n-\tretval = build2 (PLUS_EXPR, TREE_TYPE (xlhs),\n-\t\t\t xlhs, xrhs);\n-      }\n-      break;\n-\n-    case D_MINUS_EXPR:\n-      {\n-\trdot lhs = RDOT_lhs_TT (dot);\n-        rdot rhs = RDOT_rhs_TT (dot);\n-\n-        tree xlhs = dot_pass_lowerExpr (lhs, block);\n-        tree xrhs = dot_pass_lowerExpr (rhs, block);\n-\n-\tretval = build2 (MINUS_EXPR, TREE_TYPE (xlhs),\n-\t\t\t xlhs, xrhs);\n-      }\n-      break;\n-\n-      case D_MULT_EXPR:\n-      {\n-\trdot lhs = RDOT_lhs_TT (dot);\n-        rdot rhs = RDOT_rhs_TT (dot);\n-\n-        tree xlhs = dot_pass_lowerExpr (lhs, block);\n-        tree xrhs = dot_pass_lowerExpr (rhs, block);\n-\n-\tretval = build2 (MULT_EXPR, TREE_TYPE (xlhs),\n-\t\t\t xlhs, xrhs);\n-      }\n-      break;\n-\n-      case D_LESS_EQ_EXPR:\n-      {\n-\trdot lhs = RDOT_lhs_TT (dot);\n-        rdot rhs = RDOT_rhs_TT (dot);\n-\n-        tree xlhs = dot_pass_lowerExpr (lhs, block);\n-        tree xrhs = dot_pass_lowerExpr (rhs, block);\n-\n-\tretval = build2 (LE_EXPR, TREE_TYPE (xlhs),\n-\t\t\t xlhs, xrhs);\n-      }\n-      break;\n-\n-    case D_EQ_EQ_EXPR:\n-      {\n-        rdot lhs = RDOT_lhs_TT (dot);\n-        rdot rhs = RDOT_rhs_TT (dot);\n-\n-        tree xlhs = dot_pass_lowerExpr (lhs, block);\n-        tree xrhs = dot_pass_lowerExpr (rhs, block);\n-\n-\tretval = build2 (EQ_EXPR, TREE_TYPE (xlhs),\n-\t\t\t xlhs, xrhs);\n-      }\n-      break;\n-\n-    case D_VAR_DECL:\n-        {\n-          const char * varID = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (dot));\n-          bool consty = RDOT_qual (dot);\n-          tree gcc_type = dot_pass_rustToGccType (RDOT_rhs_TT (dot), consty);\n-          tree decl = build_decl (RDOT_LOCATION (dot),\n-                                  VAR_DECL, get_identifier (varID),\n-                                  gcc_type);\n-          if (dot_pass_lookupCTU (varID) == error_mark_node)\n-            dot_pass_pushDecl (varID, decl);\n-          retval = decl;\n-        }\n-      break;\n-\n-    case D_ACC_EXPR:\n-      {\n-\trdot impl = RDOT_lhs_TT (dot);\n-\tchar * implid = RDOT_IDENTIFIER_POINTER (impl);\n-\tprintf (\"implid = %s\\n\", implid);\n-      }\n-      break;\n-\n-    default:\n-      error (\"unhandled binary operation type [%s]!\\n\", RDOT_OPCODE_STR (dot));\n-      break;\n-    }\n-\n-  if (DOT_RETVAL (dot))\n-    {\n-      if (global_retDecl != error_mark_node)\n-        {\n-          tree retass = fold_build2_loc (RDOT_LOCATION (dot),\n-                                         MODIFY_EXPR, TREE_TYPE (global_retDecl),\n-                                         global_retDecl, retval);\n-          append_to_statement_list (retass, block);\n-          global_retDecl_ = true;\n-          retval = global_retDecl;\n-        }\n-    }\n-\n-  return retval;\n-}\n-\n-static\n-void dot_pass_compileCond (rdot node, tree * block)\n-{\n-  rdot ifblock = RDOT_lhs_TT (node);\n-  rdot elseblock = RDOT_rhs_TT (node);\n-\n-  tree endif_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t      create_tmp_var_name (\"ENDIF\"),\n-\t\t\t\t      void_type_node);\n-  tree endif_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t   void_type_node, endif_label_decl);\n-  DECL_CONTEXT (endif_label_decl) = current_function_decl;\n-\n-  tree else_label_expr = error_mark_node;\n-  tree else_label_decl = error_mark_node;\n-  if (elseblock != NULL_DOT)\n-    {\n-      else_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t    create_tmp_var_name (\"ELSE\"),\n-\t\t\t\t    void_type_node);\n-      else_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t void_type_node, else_label_decl);\n-      DECL_CONTEXT (else_label_decl) = current_function_decl;\n-    }\n-  else\n-    {\n-      else_label_expr = endif_label_expr;\n-      else_label_decl = endif_label_decl;\n-    }\n-\n-  tree cond = dot_pass_lowerExpr (RDOT_lhs_TT (ifblock), block);\n-  tree conditional = build3_loc (RDOT_LOCATION (node), COND_EXPR, void_type_node,\n-\t\t\t\t cond,\n-\t\t\t\t NULL_TREE,\n-\t\t\t\t build1 (GOTO_EXPR, void_type_node, else_label_decl));\n-\n-  append_to_statement_list (conditional, block);\n-  dot_pass_compileSuite (RDOT_rhs_TT (ifblock), block);\n-  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, endif_label_decl),\n-\t\t\t    block);\n-  if (elseblock)\n-    {\n-      append_to_statement_list (else_label_expr, block);\n-      dot_pass_compileSuite (RDOT_lhs_TT (elseblock), block);\n-      append_to_statement_list (endif_label_expr, block);\n-    }\n-  else\n-    append_to_statement_list (endif_label_expr, block);\n-}\n-\n-static\n-void dot_pass_compileBreak (rdot node, tree * block)\n-{\n-  size_t lts = __loopContexts.size ();\n-  if (lts > 0)\n-    append_to_statement_list (fold_build1_loc (RDOT_LOCATION (node), GOTO_EXPR,\n-                                               void_type_node,\n-                                               __loopContexts.back ()),\n-                              block);\n-  else\n-    error (\"break outside of loop context\");\n-}\n-\n-static\n-void dot_pass_compileLoop (rdot node, tree * block)\n-{\n-  tree start_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t      create_tmp_var_name (\"START\"),\n-\t\t\t\t      void_type_node);\n-  tree start_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t   void_type_node, start_label_decl);\n-  DECL_CONTEXT (start_label_decl) = current_function_decl;\n-\n-  tree end_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t    create_tmp_var_name (\"END\"),\n-\t\t\t\t    void_type_node);\n-  tree end_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t void_type_node, end_label_decl);\n-  DECL_CONTEXT (end_label_decl) = current_function_decl;\n-  __loopContexts.push_back (end_label_decl);\n-\n-  /* -- -- -- */\n-  append_to_statement_list (start_label_expr, block);\n-\n-  dot_pass_compileSuite (RDOT_lhs_TT (node), block);\n-  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, start_label_decl), block);\n-  append_to_statement_list (end_label_expr, block);\n-  \n-  __loopContexts.pop_back ();\n-  \n-}\n-\n-static\n-void dot_pass_compileWhile (rdot node, tree * block)\n-{\n-  rdot condition = RDOT_lhs_TT (node);\n-  rdot suite = RDOT_rhs_TT (node);\n-\n-  tree start_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t      create_tmp_var_name (\"START\"),\n-\t\t\t\t      void_type_node);\n-  tree start_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t   void_type_node, start_label_decl);\n-  DECL_CONTEXT (start_label_decl) = current_function_decl;\n-\n-  tree end_label_decl = build_decl (BUILTINS_LOCATION, LABEL_DECL,\n-\t\t\t\t    create_tmp_var_name (\"END\"),\n-\t\t\t\t    void_type_node);\n-  tree end_label_expr = fold_build1_loc (BUILTINS_LOCATION, LABEL_EXPR,\n-\t\t\t\t\t void_type_node, end_label_decl);\n-  DECL_CONTEXT (end_label_decl) = current_function_decl;\n-  __loopContexts.push_back (end_label_decl);\n-\n-  /* -- -- -- */\n-  append_to_statement_list (start_label_expr, block);\n-\n-  tree cond = dot_pass_lowerExpr (condition, block);\n-  tree conditional = build3_loc (RDOT_LOCATION (node), COND_EXPR, void_type_node,\n-\t\t\t\t cond, NULL_TREE,\n-\t\t\t\t build1 (GOTO_EXPR, void_type_node, end_label_decl));\n-  append_to_statement_list (conditional, block);\n-  dot_pass_compileSuite (suite, block);\n-  append_to_statement_list (build1 (GOTO_EXPR, void_type_node, start_label_decl), block);\n-  append_to_statement_list (end_label_expr, block);\n-  \n-  __loopContexts.pop_back ();\n-}\n-\n-static\n-void dot_pass_compileSuite (rdot suite, tree * block)\n-{\n-  rdot node;\n-  for (node = suite; node != NULL_DOT; node = RDOT_CHAIN (node))\n-    {\n-      if (RDOT_T_FIELD (node) ==  D_D_EXPR)\n-\tappend_to_statement_list (dot_pass_lowerExpr (node, block), block);\n-      else\n-        {\n-          switch (RDOT_TYPE (node))\n-            {\n-            case D_STRUCT_IF:\n-              dot_pass_compileCond (node, block);\n-              break;\n-              \n-\t    case D_STRUCT_WHILE:\n-\t      dot_pass_compileWhile (node, block);\n-\t      break;\n-              \n-            case D_STRUCT_LOOP:\n-              dot_pass_compileLoop (node, block);\n-              break;\n-\n-            case C_BREAK_STMT:\n-              dot_pass_compileBreak (node, block);\n-              break;\n-\n-            default:\n-              error (\"Unhandled statement [%s]\\n\", RDOT_OPCODE_STR (node));\n-              break;\n-            }\n-        }\n-    }\n-}\n-\n-static\n-void dot_pass_genMethodProto (rdot node)\n-{\n-  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-  if (dot_pass_lookupCTU (method_id) != error_mark_node)\n-    {\n-      error (\"Duplicate declaration of function [%s]\\n\", method_id);\n-      return;\n-    }\n-  tree rtype = void_type_node;\n-  if (RDOT_FIELD2 (node))\n-    rtype = dot_pass_rustToGccType (RDOT_FIELD2 (node), false);\n-\n-  rdot parameters = RDOT_lhs_TT (node);\n-  tree fntype = error_mark_node;\n-  if (parameters != NULL_DOT)\n-    {\n-      size_t nparams = 0;\n-      rdot prm;\n-      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n-\tnparams++;\n-\n-      tree * gccparams = XALLOCAVEC (tree, nparams);\n-      size_t i = 0;\n-      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n-\t{\n-\t  bool mut = false;\n-\t  if (RDOT_qual (prm))\n-\t    mut = true;\n-\t  gccparams [i] = dot_pass_rustToGccType (RDOT_rhs_TT (prm), mut);\n-\t  i++;\n-\t}\n-      fntype = build_function_type_array (rtype, nparams, gccparams);\n-    }\n-  else\n-    fntype = build_function_type_list (rtype, NULL_TREE);\n-\n-  tree fndecl = dot_pass_genFndecl_Basic (RDOT_LOCATION (node), method_id, fntype);\n-  SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier (dot_pass_mangle (method_id)));\n-  dot_pass_pushDecl (method_id, fndecl);\n-}\n-\n-static\n-tree dot_pass_genifyTopFndecl (rdot node)\n-{\n-  const char * method_id;\n-  if (__impl_type_decl != error_mark_node)\n-    {\n-      char * mid = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-      tree spfx = TYPE_NAME (__impl_type_decl);\n-      const char *pfx = IDENTIFIER_POINTER (spfx);\n-\n-      size_t len = strlen (mid) + strlen (pfx) + 2;\n-      size_t bsize = len * sizeof (char);\n-      char * buffer = (char *) alloca (bsize);\n-      gcc_assert (buffer);\n-      memset (buffer, 0, bsize);\n-\n-      snprintf (buffer, bsize, \"%s.%s\", pfx, mid);\n-      method_id = buffer;\n-    }\n-  else\n-    method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-\n-  tree rtype = void_type_node;\n-  if (RDOT_FIELD2 (node))\n-    rtype = dot_pass_rustToGccType (RDOT_FIELD2 (node), false);\n-\n-  rdot parameters = RDOT_lhs_TT (node);\n-  tree fntype = error_mark_node;\n-  if (parameters != NULL_DOT)\n-    {\n-      size_t nparams = 0;\n-      rdot prm;\n-      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n-\tnparams++;\n-\n-      tree * gccparams = XALLOCAVEC (tree, nparams);\n-      size_t i = 0;\n-      for (prm = parameters; prm != NULL_DOT; prm = RDOT_CHAIN (prm))\n-\t{\n-\t  bool mut = false;\n-\t  if (RDOT_qual (prm))\n-\t    mut = true;\n-\n-\t  const char * pid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (prm));\n-\t  if (strcmp (pid, \"self\") == 0)\n-\t    {\n-              fatal_error (\"unhandled self argument!\");\n-\t    }\n-\t  else\n-\t    gccparams [i] = dot_pass_rustToGccType (RDOT_rhs_TT (prm), mut);\n-\t  i++;\n-\t}\n-      fntype = build_function_type_array (rtype, nparams, gccparams);\n-    }\n-  else\n-    fntype = build_function_type_list (rtype, NULL_TREE);\n-\n-  tree fndecl = dot_pass_genFndecl_Basic (RDOT_LOCATION (node), method_id, fntype);\n-  SET_DECL_ASSEMBLER_NAME (fndecl, get_identifier (dot_pass_mangle (method_id)));\n-  dot_pass_pushContext ();\n-  \n-  rdot rdot_params = RDOT_lhs_TT (node);\n-  if (rdot_params != NULL_DOT)\n-    {\n-      tree argslist = NULL_TREE;\n-      rdot next;\n-      for (next = rdot_params; next != NULL_DOT; next = RDOT_CHAIN (next))\n-\t{\n-\t  const char * pid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n-\t  if (dot_pass_lookupCTU (pid) != error_mark_node)\n-\t    error (\"paramater [%s] is already declared\", pid);\n-\n-\t  tree ptype = error_mark_node;\n-\t  if (strcmp (pid, \"self\") == 0)\n-\t    {\n-              fatal_error (\"unhandled self param!\");\n-\t    }\n-\t  else\n-\t    ptype = dot_pass_rustToGccType (RDOT_rhs_TT (next), false);\n-\n-\t  tree param = build_decl (RDOT_LOCATION (node), PARM_DECL,\n-\t\t\t\t   get_identifier (pid), ptype);\n-\t  DECL_CONTEXT (param) = fndecl;\n-\t  DECL_ARG_TYPE (param) = ptype;\n-\t  TREE_READONLY (param) = true;\n-\t  TREE_USED (param) = true;\n-\t  argslist = chainon (argslist, param);\n-\n-\t  dot_pass_pushDecl (pid, param);\n-\t}\n-      DECL_ARGUMENTS (fndecl) = argslist;\n-    }\n-\n-  current_function_decl = fndecl;\n-  tree block = alloc_stmt_list ();\n-  current_function_block = &block;\n-\n-  global_retDecl_ = false;\n-  if (rtype == void_type_node)\n-    global_retDecl = error_mark_node;\n-  else\n-    global_retDecl = DECL_RESULT (fndecl);\n-\n-  // compile the block...\n-  dot_pass_compileSuite (RDOT_rhs_TT (node), &block);\n-\n-  // make sure it returns something!!!\n-  if (rtype != void_type_node)\n-    {\n-      if (global_retDecl_ == false)\n-        {\n-          error (\"Function [%s] doesn't seem to return anything!!\\n\", method_id);\n-          return error_mark_node;\n-        }\n-      tree returnVal = build1 (RETURN_EXPR, rtype, global_retDecl);\n-      append_to_statement_list (returnVal, &block);\n-    }\n-\n-  tree bind = NULL_TREE;\n-  tree declare_vars = DECL_RESULT (fndecl);\n-\n-  tree head = declare_vars;\n-  std::vector<tree> * decl_vars = dot_pass_popContext ();\n-  std::vector<tree>::iterator it;\n-  for (it = decl_vars->begin (); it != decl_vars->end (); ++it)\n-    {\n-      if (TREE_CODE (*it) != PARM_DECL)\n-\t{\n-\t  DECL_CHAIN (head) = *it;\n-\t  head = *it;\n-\t}\n-    }\n-  delete decl_vars;\n-\n-  tree bl = make_node (BLOCK);\n-  BLOCK_SUPERCONTEXT (bl) = fndecl;\n-  DECL_INITIAL (fndecl) = bl;\n-  BLOCK_VARS(bl) = declare_vars;\n-  TREE_USED (bl) = true;\n-\n-  bind = build3 (BIND_EXPR, void_type_node, BLOCK_VARS (bl),\n-                 NULL_TREE, bl);\n-  TREE_SIDE_EFFECTS (bind) = 1;\n-  /* Finalize the main function */\n-  BIND_EXPR_BODY (bind) = block;\n-  block = bind;\n-  DECL_SAVED_TREE (fndecl) = block;\n-\n-  gimplify_function_tree (fndecl);\n-  cgraph_finalize_function (fndecl, false);\n-\n-  pop_cfun ();\n-\n-  // reset them\n-  global_retDecl = error_mark_node;\n-  global_retDecl_ = false;\n-\n-  return fndecl;\n-}\n-\n-static\n-tree dot_pass_genifyStruct (rdot node)\n-{\n-  rdot layout = RDOT_rhs_TT (node);\n-  tree userStruct = make_node (RECORD_TYPE);\n-\n-  bool first = true;\n-  tree head_chain = NULL_TREE;\n-  tree curr = head_chain;\n-\n-  rdot next;\n-  for (next = layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      gcc_assert (RDOT_TYPE (next) == D_PARAMETER);\n-      tree name = get_identifier (RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next)));\n-      tree type = dot_pass_rustToGccType (RDOT_rhs_TT (next), false);\n-      tree field = build_decl (RDOT_LOCATION (node),\n-\t\t\t       FIELD_DECL, name, type);\n-      DECL_CONTEXT (field) = userStruct;\n-      if (first == true)\n-\t{\n-\t  head_chain = curr = field;\n-\t  first = false;\n-\t}\n-      else\n-        {\n-          DECL_CHAIN (curr) = field;\n-          curr = field;\n-        }\n-    }\n-\n-  TYPE_FIELDS (userStruct) = head_chain;\n-  layout_type (userStruct);\n-\n-  const char * struct_id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-  tree type_decl = build_decl (RDOT_LOCATION (node), TYPE_DECL,\n-\t\t\t       get_identifier (struct_id), userStruct);\n-  TYPE_NAME (userStruct) = get_identifier (struct_id);\n-  grs_preserve_from_gc (type_decl);\n-  rest_of_decl_compilation (type_decl, 1, 0);\n-  dot_pass_pushDecl (struct_id, userStruct);\n-  return type_decl;\n-}\n-\n-static\n-std::vector<tree> * dot_pass_genifyImplBlock (rdot node)\n-{\n-  std::vector<tree> * retval = new std::vector<tree>;\n-  // look up the struct type to set TYPE_METHODS on it...\n-  const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-  tree type_decl = dot_pass_lookupCTU (implid);\n-  if (type_decl == error_mark_node)\n-    error (\"type [%s] does not exist for impl block\", implid);\n-  else\n-    {\n-      __impl_type_decl = type_decl;\n-      rdot decl;\n-      tree fndecl_chain = error_mark_node, curr = error_mark_node;\n-      bool first = true;\n-      for (decl = RDOT_rhs_TT (node); decl != NULL_DOT; decl = RDOT_CHAIN (decl))\n-\t{\n-\t  tree fndecl = dot_pass_genifyTopFndecl (decl);\n-\t  retval->push_back (fndecl);\n-\t  if (first == true)\n-\t    {\n-\t      fndecl_chain = fndecl;\n-\t      curr = fndecl_chain;\n-\t      first = false;\n-\t    }\n-\t  else\n-\t    {\n-\t      DECL_CHAIN (curr) = fndecl;\n-\t      curr = fndecl;\n-\t    }\n-\t}\n-      TYPE_METHODS (__impl_type_decl) = fndecl_chain;\n-      __impl_type_decl = error_mark_node;\n-    }\n-  return retval;\n-}\n-\n-static\n-std::vector<tree> * dot_pass_genifyTopNode (rdot node)\n-{\n-  std::vector<tree> * retval = NULL;\n-  switch (RDOT_TYPE (node))\n-    {\n-    case D_STRUCT_METHOD:\n-      {\n-\tretval = new std::vector<tree>;\n-\tretval->push_back (dot_pass_genifyTopFndecl (node));\n-      }\n-      break;\n-\n-      // nothing to do here...\n-    case D_STRUCT_TYPE:\n-    case D_STRUCT_IMPL:\n-      break;\n-\n-    default:\n-      error (\"Unhandled Toplevel declaration [%s]\\n\", RDOT_OPCODE_STR (node));\n-      break;\n-    }\n-  return retval;\n-}\n-\n-static\n-void dot_pass_setupContext (void)\n-{\n-  std::map<std::string, tree> * lgrs = new std::map<std::string, tree>();\n-  rs_fill_runtime_decls (lgrs);\n-  context.push_back (lgrs);\n-}\n-\n-static\n-void dot_pass_pushContext (void)\n-{\n-  std::map<std::string, tree> * nctx = new std::map<std::string, tree>;\n-  context.push_back (nctx);\n-}\n-\n-static\n-std::vector<tree> * dot_pass_popContext (void)\n-{\n-  std::vector<tree> * retval = new std::vector<tree>;\n-  if (context.size () > 0)\n-    {\n-      std::map<std::string, tree> * popd = context.back ();\n-      context.pop_back ();\n-\n-      std::map<std::string, tree>::iterator it;\n-      for (it = popd->begin (); it != popd->end (); ++it)\n-        retval->push_back (it->second);\n-\n-      delete popd;\n-    }\n-  return retval;\n-}\n-\n-vec<tree,va_gc> * dot_pass_Genericify (vec<rdot,va_gc> * decls)\n-{\n-  vec<tree,va_gc> * retval;\n-  vec_alloc (retval, 0);\n-\n-  dot_pass_setupContext ();\n-  dot_pass_pushContext ();\n-\n-  size_t i;\n-  rdot idtx = NULL_DOT;\n-\n-  /* fill up the prototypes now ... */\n-  for (i = 0; decls->iterate (i, &idtx); ++i)\n-    {\n-      rdot node = idtx;\n-      switch (RDOT_TYPE (node))\n-\t{\n-\tcase D_STRUCT_METHOD:\n-\t  dot_pass_genMethodProto (node);\n-\t  break;\n-\n-\tcase D_STRUCT_TYPE:\n-\t  {\n-\t    tree gen = dot_pass_genifyStruct (node);\n-\t    vec_safe_push (retval, gen);\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  if (seen_error ())\n-    goto exit;\n-\n-  for (i = 0; decls->iterate (i, &idtx); ++i)\n-    {\n-      rdot node = idtx;\n-      switch (RDOT_TYPE (node))\n-\t{\n-\tcase D_STRUCT_IMPL:\n-\t  {\n-\t    std::vector<tree> * gdecls = dot_pass_genifyImplBlock (node);\n-\t    std::vector<tree>::iterator it;\n-\t    for (it = gdecls->begin (); it != gdecls->end (); ++it)\n-\t      vec_safe_push (retval, *it);\n-\t    delete gdecls;\n-\t  }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n-    }\n-\n-  if (seen_error ())\n-    goto exit;\n-\n-  __impl_type_decl = error_mark_node;\n-  for (i = 0; decls->iterate (i, &idtx); ++i)\n-    {\n-      std::vector<tree> * gdecls = dot_pass_genifyTopNode (idtx);\n-      if (gdecls != NULL)\n-\t{\n-\t  std::vector<tree>::iterator it;\n-\t  for (it = gdecls->begin (); it != gdecls->end (); ++it)\n-\t    vec_safe_push (retval, *it);\n-\t  delete gdecls;\n-\t}\n-    }\n-\n- exit:\n-  dot_pass_popContext ();\n-  return retval;\n-}"}, {"sha": "be4421b52a1b36aa7e993bddd6df77b9c76bdac9", "filename": "gcc/rust/old/rdot-impl.cc", "status": "removed", "additions": 0, "deletions": 267, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,267 +0,0 @@\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>. */\n-\n-#include \"rust.h\"\n-\n-static bool initilized = false;\n-\n-static const char * opcodeStrings [] = {\n-  /* [D_IDENTIFIER] */         \"identifier\",\n-  /* [D_T_INTEGER] */          \"literal_integer\",\n-  /* [D_T_FLOAT] */            \"literal_float\",\n-  /* [D_T_STRING] */           \"literal_string\",\n-  /* [D_T_LIST] */             \"liteal_list\",\n-  /* [D_VAR_DECL] */           \"var_decl\",\n-  /* [D_MODIFY_EXPR] */        \"modify_expr\",\n-  /* [D_MULT_EXPR] */          \"multiply_expr\",\n-  /* [D_DIVD_EXPR] */          \"divide_expr\",\n-  /* [D_ADD_EXPR] */           \"plus_expr\",\n-  /* [D_MINUS_EXPR] */         \"minus_expr\",\n-  /* [D_EQ_EQ_EXPR] */         \"equivilant_expr\",\n-  /* [D_LESS_EXPR] */          \"less_than_expr\",\n-  /* [D_LESS_EQ_EXPR] */       \"less_eq_expr\",\n-  /* [D_GREATER_EXPR] */       \"greater_expr\",\n-  /* [D_GREATER_EQ_EXPR] */    \"greater_eq_expr\",\n-  /* [D_NOT_EQ_EXPR] */        \"not_equal_expr\",\n-  /* [D_CALL_EXPR] */          \"call_expr\",\n-  /* [D_ATTRIB_EXPR] */        \"attribute_reference\",\n-  /* [D_ACC_EXPR] */           \"accessor_reference\",\n-  /* [D_STRUCT_METHOD] */      \"struct_method\",\n-  /* [D_STRUCT_WHILE] */       \"struct_while\",\n-  /* [D_STRUCT_LOOP] */        \"struct_loop\",\n-  /* [D_D_EXPR] */             \"enc_expression\",\n-  /* [D_TD_COM] */             \"TD_COM\",\n-  /* [D_TD_DOT] */             \"TD_DOT\",\n-  /* [D_TD_NULL] */            \"TD_NULL\",\n-  /* [D_PRIMITIVE] */          \"primitive\",\n-  /* [D_STRUCT_IF] */          \"struct_if\",\n-  /* [D_STRUCT_ELIF] */        \"struct_elif\",\n-  /* [D_STRUCT_ELSE] */        \"struct_else\",\n-  /* [D_STRUCT_CONDITIONAL] */ \"struct_conditional\",\n-  /* [RTYPE_BOOL] */           \"type_bool\",\n-  /* [RTYPE_INT] */            \"type_int\",\n-  /* [RTYPE_FLOAT] */          \"type_float\",\n-  /* [RTYPE_UINT] */           \"type_uint\",\n-  /* [RTYPE_INFER] */          \"type_infer\",\n-  /* [D_PARAMETER] */          \"parameter\",\n-  /* [D_STRUCT_TYPE] */        \"struct_definition\",\n-  /* [D_STRUCT_PARAM] */       \"struct_init_param\",\n-  /* [D_STRUCT_INIT] */        \"struct_initilization\",\n-  /* [RTYPE_USER_STRUCT] */    \"user_struct_type\",\n-  /* [D_STRUCT_ENUM] */        \"struct_enum\",\n-  /* [D_STRUCT_IMPL] */        \"impl_block\",\n-  /* [D_BOOLEAN] */            \"d_boolean\",\n-  /* [D_T_BOOL] */             \"d_t_bool\",\n-  /* [C_BREAK_STMT] */         \"break_stmt\",\n-  /* [C_CONT_STMT] */          \"continue_stmt\",\n-  /* [C_RETURN_STMT] */        \"return_stmt\",\n-};\n-\n-const char *\n-rdot_getOpString_T (const opcode_t o)\n-{\n-  return opcodeStrings [o];\n-}\n-\n-const char *\n-rdot_getOpString (const rdot dot)\n-{\n-  return rdot_getOpString_T (RDOT_TYPE (dot));\n-}\n-\n-void rdot_init (void)\n-{\n-  if (initilized)\n-    return;\n-  //... probably should get rid of this function ...\n-  initilized = true;\n-}\n-\n-rdot rdot_build_varDecl (rdot type, bool final, rdot id)\n-{\n-  rdot decl = rdot_build_decl2 (D_VAR_DECL, id, type);\n-  RDOT_qual (decl) = final;\n-  return decl;\n-}\n-\n-rdot rdot_alloc (void)\n-{\n-  rdot retval = (struct grs_tree_dot *)\n-    xmalloc (sizeof (struct grs_tree_dot));\n-  gcc_assert (retval);\n-  memset (retval, 0, sizeof (struct grs_tree_dot));\n-  RDOT_LOCATION (retval) = UNKNOWN_LOCATION;\n-  return retval;\n-}\n-\n-rdot rdot_build_decl1 (opcode_t o, rdot t1)\n-{\n-  rdot decl = RDOT_alloc;\n-\n-  RDOT_TYPE(decl) = o;\n-  RDOT_T_FIELD(decl) = D_TD_NULL;\n-  RDOT_FIELD(decl) = NULL_DOT;\n-\n-  decl->opaT = D_TD_DOT;\n-  decl->opa.t = t1;\n-  decl->opbT = D_TD_NULL;\n-\n-  RDOT_CHAIN(decl) = NULL_DOT;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_decl2 (opcode_t o, rdot t1, rdot t2)\n-{\n-  rdot decl = RDOT_alloc;\n-\n-  RDOT_TYPE (decl) = o;\n-  if ((o == D_VAR_DECL)\n-      || (o == D_MODIFY_EXPR)\n-      || (o == D_ADD_EXPR)\n-      || (o == D_MINUS_EXPR)\n-      || (o == D_MULT_EXPR)\n-      || (o == D_DIVD_EXPR)\n-      || (o == D_CALL_EXPR)\n-      || (o == D_EQ_EQ_EXPR)\n-      || (o == D_LESS_EXPR)\n-      || (o == D_LESS_EQ_EXPR)\n-      || (o == D_GREATER_EXPR)\n-      || (o == D_GREATER_EQ_EXPR)\n-      || (o == D_NOT_EQ_EXPR)\n-      || (o == D_ATTRIB_REF)\n-      || (o == D_ACC_EXPR)\n-      || (o == D_STRUCT_INIT)\n-      )\n-    RDOT_T_FIELD(decl) = D_D_EXPR;\n-  else\n-    RDOT_T_FIELD(decl) = D_TD_NULL;\n-\n-  RDOT_FIELD (decl) = NULL_DOT;\n-\n-  decl->opaT = D_TD_DOT;\n-  decl->opa.t = t1;\n-  decl->opbT = D_TD_DOT;\n-  decl->opb.t = t2;\n-\n-  RDOT_CHAIN(decl) = NULL_DOT;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_fndecl (rdot ident, bool pub, rdot params, rdot rtype, rdot suite)\n-{\n-  rdot decl = RDOT_alloc;\n-\n-  RDOT_TYPE (decl) = D_STRUCT_METHOD;\n-  RDOT_T_FIELD (decl) = D_TD_NULL;\n-\n-  RDOT_FIELD (decl) = ident;\n-  RDOT_FIELD2 (decl) = rtype;\n-  DOT_RETVAL (decl) = pub;\n-\n-  decl->opaT = D_TD_DOT;\n-  decl->opa.t = params;\n-  decl->opbT = D_TD_DOT;\n-  decl->opb.t = suite;\n-\n-  RDOT_CHAIN(decl) = NULL_DOT;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_integer (const int i)\n-{\n-  rdot decl = RDOT_alloc;\n-  RDOT_TYPE(decl) = D_PRIMITIVE;\n-\n-  RDOT_FIELD(decl) = NULL_DOT;\n-  RDOT_T_FIELD(decl) = D_D_EXPR;\n-\n-  decl->opaT = D_TD_COM;\n-  decl->opa.tc.T = D_T_INTEGER;\n-  decl->opa.tc.o.integer = i;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_float (const float f)\n-{\n-  rdot decl = RDOT_alloc;\n-  RDOT_TYPE(decl) = D_PRIMITIVE;\n-\n-  RDOT_FIELD(decl) = NULL_DOT;\n-  RDOT_T_FIELD(decl) = D_D_EXPR;\n-\n-  decl->opaT = D_TD_COM;\n-  decl->opa.tc.T = D_T_FLOAT;\n-  decl->opa.tc.o.ffloat = f;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_string (const char * s)\n-{\n-  rdot decl = RDOT_alloc;\n-  RDOT_TYPE (decl) = D_PRIMITIVE;\n-\n-  RDOT_FIELD (decl) = NULL_DOT;\n-  RDOT_T_FIELD (decl) = D_D_EXPR;\n-\n-  decl->opaT = D_TD_COM;\n-  decl->opa.tc.T = D_T_STRING;\n-  decl->opa.tc.o.string = xstrdup (s);\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_identifier (const char * s)\n-{\n-  rdot decl = RDOT_alloc;\n-\n-  RDOT_TYPE(decl) = D_IDENTIFIER;\n-  RDOT_FIELD(decl) = NULL_DOT;\n-  RDOT_T_FIELD(decl) = D_D_EXPR;\n-\n-  decl->opaT = D_TD_COM;\n-  decl->opa.tc.T = D_T_STRING;\n-  decl->opa.tc.o.string = xstrdup (s);\n-\n-  decl->opbT = D_TD_NULL;\n-\n-  RDOT_CHAIN(decl) = NULL_DOT;\n-\n-  return decl;\n-}\n-\n-rdot rdot_build_bool (bool val)\n-{\n-  rdot decl = RDOT_alloc;\n-\n-  RDOT_TYPE(decl) = D_BOOLEAN;\n-  RDOT_FIELD(decl) = NULL_DOT;\n-  RDOT_T_FIELD(decl) = D_D_EXPR;\n-\n-  decl->opaT = D_TD_COM;\n-  decl->opa.tc.T = D_T_BOOL;\n-  decl->opa.tc.o.boolean = val;\n-\n-  decl->opbT = D_TD_NULL;\n-\n-  RDOT_CHAIN(decl) = NULL_DOT;\n-\n-  return decl;\n-}"}, {"sha": "8f7d71d1ec9101bc198bb55b71ece7e13fd4843d", "filename": "gcc/rust/old/rdot-impl.h", "status": "removed", "additions": 0, "deletions": 166, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-impl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-impl.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,166 +0,0 @@\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>. */\n-\n-#ifndef __GCC_RDOT_IMPL_H__\n-#define __GCC_RDOT_IMPL_H__\n-\n-typedef enum {\n-  D_IDENTIFIER = 0,\n-  D_T_INTEGER,\n-  D_T_FLOAT,\n-  D_T_STRING,\n-  D_T_LIST,\n-\n-  D_VAR_DECL,\n-  D_MODIFY_EXPR,\n-  D_MULT_EXPR,\n-  D_DIVD_EXPR,\n-  D_ADD_EXPR,\n-  D_MINUS_EXPR,\n-\n-  D_EQ_EQ_EXPR,\n-  D_LESS_EXPR,\n-  D_LESS_EQ_EXPR,\n-  D_GREATER_EXPR,\n-  D_GREATER_EQ_EXPR,\n-  D_NOT_EQ_EXPR,\n-\n-  D_CALL_EXPR,\n-  D_ATTRIB_REF,\n-  D_ACC_EXPR,\n-    \n-  D_STRUCT_METHOD,\n-  D_STRUCT_WHILE,\n-  D_STRUCT_LOOP,\n-\n-  D_D_EXPR,\n-  D_TD_COM,\n-  D_TD_DOT,\n-  D_TD_NULL,\n-\n-  D_PRIMITIVE,\n-\n-  D_STRUCT_IF,\n-  D_STRUCT_ELIF,\n-  D_STRUCT_ELSE,\n-  D_STRUCT_CONDITIONAL,\n-\n-  RTYPE_BOOL,\n-  RTYPE_INT,\n-  RTYPE_FLOAT,\n-  RTYPE_UINT,\n-  RTYPE_INFER,\n-\n-  D_PARAMETER,\n-  D_STRUCT_TYPE,\n-  D_STRUCT_PARAM,\n-  D_STRUCT_INIT,\n-\n-  RTYPE_USER_STRUCT,\n-\n-  D_STRUCT_ENUM,\n-  D_STRUCT_IMPL,\n-\n-  D_BOOLEAN,\n-  D_T_BOOL,\n-\n-  C_BREAK_STMT,\n-  C_CONT_STMT,\n-  C_RETURN_STMT\n-} opcode_t ;\n-\n-typedef enum {\n-  ALLOC_HEAP,\n-  ALLOC_REF,\n-  ALLOC_DEREF\n-} ALLOCA_;\n-\n-typedef struct grs_rdot_tree_common {\n-  opcode_t T;\n-  union {\n-    int integer;\n-    float ffloat;\n-    unsigned char c;\n-    char * string;\n-    bool boolean;\n-  } o;\n-} rdot_tree_common ;\n-\n-typedef struct GTY(()) grs_tree_dot {\n-  opcode_t T, FT, opaT, opbT;\n-  bool retval, qual;\n-  std::vector<ALLOCA_> alloca_modifier;\n-  location_t loc;\n-  struct grs_tree_dot * field1;\n-  struct grs_tree_dot * field2;\n-  union {\n-    rdot_tree_common tc;\n-    struct grs_tree_dot * t;\n-  } opa;\n-  union {\n-    rdot_tree_common tc;\n-    struct grs_tree_dot * t;\n-  } opb;\n-  struct grs_tree_dot * next;\n-} * rdot;\n-\n-#define NULL_DOT                     ((rdot) 0)\n-#define RDOT_alloc                   rdot_alloc ()\n-#define RDOT_TYPE(x_)                x_->T\n-#define RDOT_LOCATION(x_)            x_->loc\n-#define RDOT_T_FIELD(x_)             x_->FT\n-#define RDOT_CHAIN(x_)               x_->next\n-#define RDOT_FIELD(x_)               x_->field1\n-#define RDOT_FIELD2(x_)              x_->field2\n-#define RDOT_lhs_T(x_)               x_->opaT\n-#define RDOT_rhs_T(x_)               x_->opbT\n-#define RDOT_lhs_TT(x_)              x_->opa.t\n-#define RDOT_rhs_TT(x_)              x_->opb.t\n-#define RDOT_lhs_TC(x_)              x_->opa.tc\n-#define RDOT_rhs_TC(x_)              x_->opb.tc\n-#define RDOT_qual(x_)                x_->qual\n-#define DOT_RETVAL(x_)               x_->retval\n-#define RDOT_MEM_MODIFIER(x_)        (&(x_->alloca_modifier))\n-#define RDOT_IDENTIFIER_POINTER(x_)  RDOT_lhs_TC (x_).o.string\n-#define RDOT_BOOLEAN_VAL(x_)         RDOT_lhs_TC (x_).o.boolean\n-#define RDOT_CODE_STR(x_)            rdot_getOpString_T (x_)\n-#define RDOT_OPCODE_STR(x_)          rdot_getOpString (x_)\n-\n-// destination is cleared before copy\n-// copy a vector (source, destination)\n-#define RDOT_MMEM_COPY(x_, y_)\t\t\t\t  \\\n-  do {\t\t\t\t\t\t\t  \\\n-    y_->clear ();\t\t\t\t\t  \\\n-    std::vector<ALLOCA_>::iterator __it;\t\t  \\\n-    for (__it = x_->begin (); __it != x_->end (); ++__it) \\\n-      y_->push_back (*__it);\t\t\t\t  \\\n-  } while (0)\n-\n-extern rdot rdot_alloc (void);\n-extern void rdot_init (void);\n-extern rdot rdot_build_decl1 (opcode_t, rdot);\n-extern rdot rdot_build_decl2 (opcode_t, rdot, rdot);\n-extern rdot rdot_build_fndecl (rdot, bool, rdot, rdot, rdot);\n-extern rdot rdot_build_float (const float);\n-extern rdot rdot_build_integer (const int);\n-extern rdot rdot_build_string (const char *);\n-extern rdot rdot_build_identifier (const char *);\n-extern rdot rdot_build_bool (bool);\n-extern rdot rdot_build_varDecl (rdot, bool, rdot);\n-extern const char * rdot_getOpString (const rdot);\n-extern const char * rdot_getOpString_T (const opcode_t);\n-\n-#endif //__GCC_RDOT_IMPL_H__"}, {"sha": "51330e318abd958b5f85650d9187e844135950d5", "filename": "gcc/rust/old/rdot-pretty-print.cc", "status": "removed", "additions": 0, "deletions": 664, "changes": 664, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frdot-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frdot-pretty-print.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,664 +0,0 @@\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>. */\n-\n-#include \"rust.h\"\n-\n-static bool _no_infer = false;\n-static bool first = true;\n-\n-#define RDOT_PREFIX_PRE      \".pre-rdot\"\n-#define RDOT_PREFIX_POST     \".pst-rdot\"\n-\n-static const char * typeStrings [] = {\n-  \"bool\",\n-  \"int\",\n-  \"float\",\n-  \"unsigned_int\",\n-  \"__infer_me\",\n-  \"__user_struct\",\n-  \"void\"\n-};\n-\n-static char *\n-typeStringNode (const rdot node)\n-{\n-  char buffer [128];\n-  size_t offset = 0;\n-  if (RDOT_MEM_MODIFIER (node))\n-    {\n-      std::vector<ALLOCA_>::iterator it;\n-      for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-           it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n-        {\n-          switch (*it)\n-            {\n-            case ALLOC_HEAP:\n-              {\n-                buffer [offset] = '~';\n-                offset++;\n-              }\n-              break;\n-            case ALLOC_REF:\n-              {\n-                buffer [offset] = '&';\n-                offset++;\n-              }\n-              break;\n-            case ALLOC_DEREF:\n-              {\n-                buffer [offset] = '*';\n-                offset++;\n-              }\n-              break;\n-            }\n-        }\n-    }\n-  if (node != NULL_DOT)\n-    {\n-      switch (RDOT_TYPE (node))\n-        {\n-        case RTYPE_BOOL:\n-          strcpy (buffer+offset, typeStrings [0]);\n-          break;\n-\n-        case RTYPE_INT:\n-          strcpy (buffer+offset, typeStrings [1]);\n-          break;\n-\n-        case RTYPE_FLOAT:\n-          strcpy (buffer+offset, typeStrings [2]);\n-          break;\n-\n-        case RTYPE_UINT:\n-          strcpy (buffer+offset, typeStrings [3]);\n-          break;\n-          \n-        case RTYPE_INFER:\n-          {\n-            if (_no_infer)\n-              fatal_error (\"gcc-rust has failed to infer a type and cannot continue\");\n-            else\n-              strcpy (buffer+offset, typeStrings [4]);\n-          }\n-          break;\n-\n-        case RTYPE_USER_STRUCT:\n-          strcpy (buffer+offset, RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node)));\n-          break;\n-\n-        default:\n-          fatal_error (\"unhandled type [%s]\", RDOT_OPCODE_STR (node));\n-          break;\n-        }\n-    }\n-  return xstrdup (buffer);\n-}\n-\n-static void dot_pass_dump_node (FILE *, rdot, size_t);\n-static void dot_pass_dump_method (FILE *, rdot, size_t);\n-static void dot_pass_dump_struct (FILE *, rdot, size_t);\n-\n-static void dot_pass_dumpPrimitive (FILE *, rdot);\n-static void dot_pass_dumpExprNode (FILE *, rdot);\n-static void dot_pass_dump_expr (FILE *, rdot);\n-\n-static\n-void dot_pass_dump_struct (FILE * fd, rdot node, size_t indents)\n-{\n-  size_t i;\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"  \");\n-\n-  rdot ident = RDOT_lhs_TT (node);\n-  rdot layout = RDOT_rhs_TT (node);\n-\n-  fprintf (fd, \"struct %s {\\n\", RDOT_IDENTIFIER_POINTER (ident));\n-  rdot next;\n-  for (next = layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      gcc_assert (RDOT_TYPE (next) = D_PARAMETER);\n-      const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n-      const char * typestr = typeStringNode (RDOT_rhs_TT (next));\n-\n-      for (i = 0; i < (indents + 1); ++i)\n-\tfprintf (fd, \"  \");\n-      fprintf (fd, \"%s %s;\\n\", typestr, id);\n-    }\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"  \");\n-  fprintf (fd, \"}\\n\");\n-}\n-\n-static\n-void dot_pass_dump_method (FILE * fd, rdot node, size_t indents)\n-{\n-  size_t i;\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"  \");\n-\n-  const char * method_id = RDOT_IDENTIFIER_POINTER (RDOT_FIELD (node));\n-  char * rtype = NULL;\n-  if (RDOT_FIELD2 (node))\n-    rtype = typeStringNode (RDOT_FIELD2 (node));\n-  else\n-    rtype = xstrdup (\"void\");\n-  rdot parameters = RDOT_lhs_TT (node);\n-\n-  if (DOT_RETVAL (node))\n-    fprintf (fd, \"pub fn %s ( \", method_id);\n-  else\n-    fprintf (fd, \"fn %s ( \", method_id);\n-  \n-  if (parameters == NULL_DOT)\n-    fprintf (fd, \"void\");\n-  else\n-    {\n-      rdot next;\n-      for (next = parameters; next != NULL_DOT; next = RDOT_CHAIN (next))\n-        {\n-          gcc_assert (RDOT_TYPE (next) = D_PARAMETER);\n-\t  bool iself = false;\n-\t  bool muta = RDOT_qual (next);\n-          const char * id = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n-\n-\t  if (strcmp (id, \"self\") == 0)\n-\t    iself = true;\n-\n-\t  const char *smuta;\n-\t  if (muta) {\n-\t    smuta = \"mut\";\n-\t  }\n-\t  else {\n-\t    smuta = \"final\";\n-\t  }\n-\n-\t  if (iself)\n-\t    fprintf (fd, \"[%s] _self_\", smuta);\n-\t  else\n-\t    {\n-\t      const char * typestr = typeStringNode (RDOT_rhs_TT (next));\n-\t      fprintf (fd, \"[%s] %s:%s\", smuta, typestr, id);\n-\t    }\n-          if (RDOT_CHAIN (next) != NULL_DOT)\n-            fprintf (fd, \", \");\n-        }\n-    }\n-  fprintf (fd, \" ) -> %s {\\n\", rtype);\n-  free (rtype);\n-\n-  rdot suite;\n-  for (suite = RDOT_rhs_TT (node); suite != NULL_DOT; suite = RDOT_CHAIN (suite))\n-    {\n-      dot_pass_dump_node (fd, suite, indents + 1);\n-      fprintf (fd, \"\\n\");\n-    }\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"  \");\n-  fprintf (fd, \"}\\n\");\n-}\n-\n-static\n-void dot_pass_dumpPrimitive (FILE * fd, rdot node)\n-{\n-  /* Handle other primitive literal types here ... */\n-  switch (RDOT_lhs_TC (node).T)\n-    {\n-    case D_T_INTEGER:\n-      fprintf (fd, \"%i\", RDOT_lhs_TC (node).o.integer);\n-      break;\n-\n-    case D_T_FLOAT:\n-      fprintf (fd, \"%f\", RDOT_lhs_TC (node).o.ffloat);\n-      break;\n-\n-    case D_T_STRING:\n-      fprintf (fd, \"\\\"%s\\\"\", RDOT_lhs_TC (node).o.string);\n-      break;\n-\n-    default:\n-      fatal_error (\"Unable to dump primitive [%s]\",\n-\t\t   rdot_getOpString_T (RDOT_lhs_TC (node).T));\n-      break;\n-    }\n-}\n-\n-static\n-void dot_pass_dumpExprNode (FILE * fd, rdot node)\n-{\n-  if (RDOT_MEM_MODIFIER (node))\n-    {\n-      std::vector<ALLOCA_>::iterator it;\n-      for (it = RDOT_MEM_MODIFIER (node)->begin ();\n-           it != RDOT_MEM_MODIFIER (node)->end (); ++it )\n-        {\n-          switch (*it)\n-            {\n-            case ALLOC_DEREF:\n-              fprintf (fd, \"*\");\n-              break;\n-            case ALLOC_HEAP:\n-              fprintf (fd, \"~\");\n-              break;\n-            case ALLOC_REF:\n-              fprintf (fd, \"&\");\n-              break;\n-            }\n-        }\n-    }\n-  switch (RDOT_TYPE (node))\n-    {\n-    case D_PRIMITIVE:\n-      dot_pass_dumpPrimitive (fd, node);\n-      break;\n-\n-    case D_IDENTIFIER:\n-      fprintf (fd, \"%s\", RDOT_IDENTIFIER_POINTER (node));\n-      break;\n-\n-    case D_BOOLEAN:\n-      {\n-\tbool val = RDOT_BOOLEAN_VAL (node);\n-\tif (val)\n-\t  fprintf (fd, \"true\");\n-\telse\n-\t  fprintf (fd, \"false\");\n-      }\n-      break;\n-\n-    case D_CALL_EXPR:\n-      {\n-        rdot id = RDOT_lhs_TT (node);\n-        dot_pass_dump_expr (fd, id);\n-        fprintf (fd, \" (\");\n-\n-        rdot p;\n-        for (p = RDOT_rhs_TT (node); p != NULL_DOT; p = RDOT_CHAIN (p))\n-\t  {\n-\t    dot_pass_dump_expr (fd, p);\n-\t    if (RDOT_CHAIN (p) != NULL_DOT)\n-\t      fprintf (fd, \", \");\n-\t  }\n-        fprintf (fd, \")\");\n-      }\n-      break;\n-\n-    case D_VAR_DECL:\n-      {\n-        const char * mut;\n-        if (RDOT_qual (node))\n-          mut = \"_final_\";\n-        else\n-          mut = \"_mut_\";\n-\n-        fprintf (fd, \"let [%s] \", mut);\n-        dot_pass_dumpExprNode (fd, RDOT_lhs_TT (node));\n-        fprintf (fd, \" -> [%s]\", typeStringNode (RDOT_rhs_TT (node)));\n-      }\n-      break;\n-\n-    case D_STRUCT_INIT:\n-      {\n-\trdot ident = RDOT_lhs_TT (node);\n-\trdot init = RDOT_rhs_TT (node);\n-\n-\tfprintf (fd, \"%s { \", RDOT_IDENTIFIER_POINTER (ident));\n-\trdot next;\n-\tfor (next = init; next != NULL_DOT; next = RDOT_CHAIN (next))\n-\t  {\n-\t    gcc_assert (RDOT_TYPE (next) == D_STRUCT_PARAM);\n-\t    const char * name = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (next));\n-\t    \n-\t    fprintf (fd, \"%s:(\", name);\n-\t    dot_pass_dump_expr (fd, RDOT_rhs_TT (next));\n-\t    fprintf (fd, \")\");\n-\t    if (RDOT_CHAIN (next) != NULL_DOT)\n-\t      fprintf (fd, \", \");\n-\t  }\n-\tfprintf (fd, \" }\");\n-      }\n-      break;\n-\n-    default:\n-      error (\"unhandled dumpExprNode [%s]\\n\", RDOT_OPCODE_STR (node));\n-      break;\n-    }\n-}\n-\n-static\n-void dot_pass_dump_expr (FILE * fd, rdot node)\n-{\n-  if (DOT_RETVAL (node)) {\n-    fprintf (fd, \"[_rust_retval]: \");\n-  }\n-\n-  switch (RDOT_TYPE (node))\n-    {\n-    case D_PRIMITIVE:\n-    case D_IDENTIFIER:\n-    case D_CALL_EXPR:\n-    case D_BOOLEAN:\n-    case D_VAR_DECL:\n-    case D_STRUCT_INIT:\n-      dot_pass_dumpExprNode (fd, node);\n-      break;\n-        \n-    default:\n-      {\n-        /* print expr tree ... */\n-        rdot lhs = RDOT_lhs_TT (node);\n-        rdot rhs = RDOT_rhs_TT (node);\n-        \n-        dot_pass_dump_expr (fd, lhs);\n-        switch (RDOT_TYPE (node))\n-          {\n-          case D_MODIFY_EXPR:\n-            fprintf (fd, \" = \");\n-            break;\n-\n-          case D_ADD_EXPR:\n-            fprintf (fd, \" + \");\n-            break;\n-\n-          case D_MINUS_EXPR:\n-            fprintf (fd, \" - \");\n-            break;\n-\n-          case D_MULT_EXPR:\n-            fprintf (fd, \" * \");\n-            break;\n-\n-          case D_LESS_EXPR:\n-            fprintf (fd, \" < \");\n-            break;\n-\n-\t  case D_LESS_EQ_EXPR:\n-\t    fprintf (fd, \" <= \");\n-\t    break;\n-            \n-          case D_GREATER_EXPR:\n-            fprintf (fd, \" > \");\n-            break;\n-\n-\t  case D_GREATER_EQ_EXPR:\n-\t    fprintf (fd, \" >= \");\n-\t    break;\n-\n-          case D_EQ_EQ_EXPR:\n-            fprintf (fd, \" == \");\n-            break;\n-\n-          case D_NOT_EQ_EXPR:\n-            fprintf (fd, \" != \");\n-            break;\n-\t    \n-\t  case D_ATTRIB_REF:\n-\t    fprintf (fd, \".\");\n-\t    break;\n-\n-\t  case D_ACC_EXPR:\n-\t    fprintf (fd, \"::\");\n-\t    break;\n-\n-          default:\n-            fatal_error (\"unhandled dump [%s]!\\n\", RDOT_OPCODE_STR (node));\n-            break;\n-          }\n-        dot_pass_dump_expr (fd, rhs);\n-      }\n-      break;\n-    }\n-}\n-\n-static\n-void dot_pass_dump_enum (FILE * fd, rdot node, size_t indents)\n-{\n-  rdot enum_id = RDOT_lhs_TT (node);\n-  rdot enum_layout = RDOT_rhs_TT (node);\n-\n-  size_t i;\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  const char * id = RDOT_IDENTIFIER_POINTER (enum_id);\n-  fprintf (fd, \"enum %s {\\n\", id);\n-\n-  indents++;\n-  rdot next;\n-  for (next = enum_layout; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      for (i = 0; i < indents; ++i)\n-\tfprintf (fd, \"    \");\n-      const char *enumit = RDOT_IDENTIFIER_POINTER (next);\n-      fprintf (fd, \"[%s],\\n\", enumit);\n-    }\n-  indents--;\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"}\\n\");\n-}\n-\n-static\n-void dot_pass_dump_cond (FILE * fd, rdot node, size_t indents)\n-{\n-  size_t i;\n-  rdot ifb = RDOT_lhs_TT (node);\n-  rdot elb = RDOT_rhs_TT (node);\n-\n-  gcc_assert (RDOT_TYPE (ifb) == D_STRUCT_IF);\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-\n-  fprintf (fd, \"if (\");\n-  dot_pass_dump_expr (fd, RDOT_lhs_TT (ifb));\n-  fprintf (fd, \") {\\n\");\n-  \n-  rdot next;\n-  for (next = RDOT_rhs_TT (ifb) ; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      dot_pass_dump_node (fd, next, indents + 1);\n-      fprintf (fd, \"\\n\");\n-    }\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"}\");\n-\n-  if (elb != NULL_DOT)\n-    {\n-      fprintf (fd, \" else {\\n\");\n-      for (next = RDOT_lhs_TT (elb); next != NULL_DOT; next = RDOT_CHAIN (next))\n-\t{\n-\t  dot_pass_dump_node (fd, next, indents + 1);\n-\t  fprintf (fd, \"\\n\");\n-\t} \n-      for (i = 0; i < indents; ++i)\n-\tfprintf (fd, \"    \");\n-      fprintf (fd, \"}\\n\");\n-    }\n-}\n-\n-static\n-void dot_pass_dump_break (FILE * fd, const rdot node, size_t indents)\n-{\n-  size_t i;\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"break;\");\n-}\n-\n-static\n-void dot_pass_dump_loop (FILE * fd, const rdot node, size_t indents)\n-{\n-  const rdot suite = RDOT_lhs_TT (node);\n-  size_t i;\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"loop {\\n\");\n-  \n-  rdot next;\n-  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      dot_pass_dump_node (fd, next, indents + 1);\n-      fprintf (fd, \"\\n\");\n-    }\n-  \n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"}\\n\");\n-}\n-\n-static\n-void dot_pass_dump_while (FILE * fd, const rdot node, size_t indents)\n-{\n-  size_t i;\n-  rdot expr = RDOT_lhs_TT (node);\n-  rdot suite = RDOT_rhs_TT (node);\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"while (\");\n-  dot_pass_dump_expr (fd, expr);\n-  fprintf (fd, \") {\\n\");\n-\n-  rdot next;\n-  for (next = suite; next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      dot_pass_dump_node (fd, next, indents + 1);\n-      fprintf (fd, \"\\n\");\n-    }\n-\n-  for (i = 0; i < indents; ++i)\n-    fprintf (fd, \"    \");\n-  fprintf (fd, \"}\");\n-}\n-\n-static\n-void dot_pass_dump_impl (FILE * fd, rdot node, size_t indents)\n-{\n-  const char * implid = RDOT_IDENTIFIER_POINTER (RDOT_lhs_TT (node));\n-  fprintf (fd, \"impl %s {\\n\", implid);\n-\n-  rdot next;\n-  for (next = RDOT_rhs_TT (node); next != NULL_DOT; next = RDOT_CHAIN (next))\n-    {\n-      dot_pass_dump_node (fd, next, indents + 1);\n-      fprintf (fd, \"\\n\");\n-    }\n-\n-  fprintf (fd, \"}\\n\");\n-}\n-\n-static\n-void dot_pass_dump_node (FILE * fd, rdot node, size_t indents)\n-{\n-  if (RDOT_T_FIELD (node) ==  D_D_EXPR)\n-    {\n-      size_t i;\n-      for (i = 0; i < indents; ++i)\n-        fprintf (fd, \"    \");\n-      dot_pass_dump_expr (fd, node);\n-      fprintf (fd, \";\");\n-    }\n-  else\n-    {\n-      switch (RDOT_TYPE (node))\n-        {\n-        case D_PRIMITIVE:\n-          dot_pass_dump_expr (fd, node);\n-          break;\n-\n-\tcase D_STRUCT_IMPL:\n-\t  dot_pass_dump_impl (fd, node, indents);\n-\t  break;\n-\n-        case D_STRUCT_METHOD:\n-          dot_pass_dump_method (fd, node, indents);\n-          break;\n-        \n-\tcase D_STRUCT_TYPE:\n-\t  dot_pass_dump_struct (fd, node, indents);\n-\t  break;\n-     \n-\tcase D_STRUCT_ENUM:\n-\t  dot_pass_dump_enum (fd, node, indents);\n-\t  break;\n-\n-\tcase D_STRUCT_IF:\n-\t  dot_pass_dump_cond (fd, node, indents);\n-\t  break;\n-\n-\tcase D_STRUCT_WHILE:\n-\t  dot_pass_dump_while (fd, node, indents);\n-\t  break;\n-\n-        case D_STRUCT_LOOP:\n-          dot_pass_dump_loop (fd, node, indents);\n-          break;\n-\n-        case C_BREAK_STMT:\n-          dot_pass_dump_break (fd, node, indents);\n-          break;\n-\n-        default:\n-\t  error (\"unhandled node [%s]\\n\", RDOT_OPCODE_STR (node));\n-          break;\n-        }\n-    }\n-}\n-\n-vec<rdot,va_gc> * dot_pass_PrettyPrint (vec<rdot,va_gc> * decls)\n-{\n-  if (GRS_OPT_dump_dot)\n-    {\n-      size_t bsize = 128;\n-      char * outfile =  (char *) alloca (bsize);\n-      gcc_assert (outfile);\n-      memset (outfile, 0, bsize);\n-\n-      strncpy (outfile, GRS_current_infile, strlen (GRS_current_infile));\n-      if (first == true)\n-        {\n-          strncat (outfile, RDOT_PREFIX_PRE, sizeof (RDOT_PREFIX_PRE));\n-          first = false;\n-        }\n-      else\n-        {\n-          strncat (outfile, RDOT_PREFIX_POST, sizeof (RDOT_PREFIX_POST));\n-          _no_infer = true;\n-        }\n-\n-      FILE * fd = fopen (outfile, \"w\");\n-      if (!fd)\n-        {\n-          error (\"Unable to open %s for write\\n\", outfile);\n-          goto exit;\n-        }\n-\n-      rdot idtx = NULL_DOT;\n-      size_t i;\n-      for (i = 0; decls->iterate (i, &idtx); ++i)\n-        {\n-          dot_pass_dump_node (fd, idtx, 0);\n-          fprintf (fd, \"\\n\");\n-        }\n-\n-      fclose (fd);\n-    }\n- exit:\n-  return decls;\n-}"}, {"sha": "924584748bff0d9963e5155ca87215c333f63eea", "filename": "gcc/rust/old/rs-lang.c", "status": "removed", "additions": 0, "deletions": 326, "changes": 326, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-lang.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,326 +0,0 @@\n-// rs-lang.cc - frontend interface or something\n-// NOTE: should be mentioned in gtfiles in config-lang.in\n-/* This file is part of GCC.\n-\n-   GCC is free software; you can redistribute it and/or modify\n-   it under the terms of the GNU General Public License as published by\n-   the Free Software Foundation; either version 3, or (at your option)\n-   any later version.\n-\n-   GCC is distributed in the hope that it will be useful,\n-   but WITHOUT ANY WARRANTY; without even the implied warranty of\n-   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-   GNU General Public License for more details.\n-\n-   You should have received a copy of the GNU General Public License\n-   along with GCC; see the file COPYING3.  If not see\n-   <http://www.gnu.org/licenses/>.\n-*/\n-#include \"rust.h\"\n-\n-// May not need this?\n-char* GRS_current_infname;\n-char* GRS_current_infile;\n-\n-/* Language-dependent contents of a type. GTY() mark used for garbage collector. */\n-struct GTY(()) lang_type {\n-    char dummy;\n-};\n-\n-/* Language-dependent contents of a decl.  */\n-struct GTY(()) lang_decl {\n-    char dummy;\n-};\n-\n-/* Language-dependent contents of an identifier.  This must include a\n-   tree_identifier.\n-*/\n-struct GTY(()) lang_identifier {\n-    struct tree_identifier common;\n-};\n-\n-/* The resulting tree type.  */\n-union GTY((desc(\"TREE_CODE (&%h.generic) == IDENTIFIER_NODE\"),\n-           chain_next(\"CODE_CONTAINS_STRUCT (TREE_CODE (&%h.generic), \"\n-           \"TS_COMMON) ? ((union lang_tree_node *) TREE_CHAIN (&%h.generic)) : NULL\")))\n-  lang_tree_node {\n-    union tree_node GTY((tag(\"0\"),\n-                         desc(\"tree_node_structure (&%h)\"))) generic;\n-    struct lang_identifier GTY((tag(\"1\"))) identifier;\n-};\n-\n-/* We don't use language_function.  */\n-struct GTY(()) language_function {\n-    int dummy;\n-};\n-\n-/* Language hooks.  */\n-\n-/* Initial lang hook called (possibly), used for initialisation. \n- * Must call build_common_tree_nodes, set_sizetype, build_common_tree_nodes_2, and \n- * build_common_builtin_nodes, as well as set global variable void_list_node. */\n-static bool grs_langhook_init(void) {\n-    /* Something to do with this: \n-     This allows the code in d-builtins.cc to not have to worry about\n-     converting (C signed char *) to (D char *) for string arguments of\n-     built-in functions. The parameter (signed_char = false) specifies\n-     whether char is signed.  */\n-    build_common_tree_nodes(false);\n-\n-    // Creates a new TREE_LIST node with purpose NULL_TREE and value void_type_node\n-    void_list_node = build_tree_list(NULL_TREE, void_type_node);\n-\n-    // Builds built-ins for middle-end after all front-end built-ins are already instantiated\n-    build_common_builtin_nodes();\n-\n-    mpfr_set_default_prec(128);\n-    using_eh_for_cleanups();\n-\n-    rdot_init();\n-    return true;\n-}\n-\n-/* Initialize before parsing options.  */\n-static void grs_langhook_init_options_struct(struct gcc_options* opts) {\n-    /* Go says that signed overflow is precisely defined.  */\n-    opts->x_flag_wrapv = 1;\n-\n-    /* We default to using strict aliasing, since Go pointers are safe.\n-     This is turned off for code that imports the \"unsafe\" package,\n-     because using unsafe.pointer violates C style aliasing\n-     requirements.  */\n-    opts->x_flag_strict_aliasing = 1;\n-\n-    /* Default to avoiding range issues for complex multiply and\n-     divide.  */\n-    opts->x_flag_complex_method = 2;\n-\n-    /* The builtin math functions should not set errno.  */\n-    opts->x_flag_errno_math = 0;\n-    opts->frontend_set_flag_errno_math = true;\n-\n-    /* We turn on stack splitting if we can.  */\n-    if (targetm_common.supports_split_stack(false, opts))\n-        opts->x_flag_split_stack = 1;\n-\n-    /* Exceptions are used to handle recovering from panics.  */\n-    opts->x_flag_exceptions = 1;\n-    opts->x_flag_non_call_exceptions = 1;\n-}\n-\n-/* Handle grs specific options.  Return 0 if we didn't do anything.  */\n-static bool grs_langhook_handle_option(size_t scode, const char* arg ATTRIBUTE_UNUSED, \n-    int value ATTRIBUTE_UNUSED, int kind ATTRIBUTE_UNUSED, location_t l ATTRIBUTE_UNUSED, \n-    const struct cl_option_handlers* handlers ATTRIBUTE_UNUSED) {\n-    enum opt_code code = (enum opt_code)scode;\n-    int retval = 1;\n-\n-    switch (code) {\n-            /* ignore options for now... */\n-\n-        default:\n-            break;\n-    }\n-\n-    return retval;\n-}\n-\n-/* Run after parsing options.  */\n-static bool grs_langhook_post_options(const char** pfilename ATTRIBUTE_UNUSED) {\n-    if (flag_excess_precision_cmdline == EXCESS_PRECISION_DEFAULT)\n-        flag_excess_precision_cmdline = EXCESS_PRECISION_STANDARD;\n-\n-    /* Returning false means that the backend should be used.  */\n-    return false;\n-}\n-\n-/* Main entry point for front-end, apparently. Finds input file names in global vars in_fnames and \n- * num_in_fnames. From this, frontend can take over and do actual parsing and initial compilation.\n- * This function must create a complete parse tree in a global var, and then return. \n- * \n- * Some consider this the \"start of compilation\". */ \n-static void grs_langhook_parse_file(void) {\n-    size_t idx;\n-\n-    // loop through all files in in_fnames array\n-    for (idx = 0; idx < num_in_fnames; ++idx) {\n-        const char* in = in_fnames[idx];\n-        GRS_current_infname = xstrdup(in);\n-        GRS_current_infile = basename(GRS_current_infname);\n-\n-        // parse file. seems to call flex-generated lexer, which then calls bison-generated parser\n-        grs_do_compile(in);\n-        // seems very coupled to old gccrs' lexer - e.g. rustc lexer handles parsing outside of the lexer\n-        // note that apparently bison generates the \"yyparse\" automatically - perhaps the rs-parser.cc was actually generated using bison\n-    }\n-}\n-\n-static tree grs_langhook_type_for_mode(enum machine_mode mode, int unsignedp) {\n-    if (mode == TYPE_MODE(float_type_node))\n-        return float_type_node;\n-\n-    if (mode == TYPE_MODE(double_type_node))\n-        return double_type_node;\n-\n-    // More code about other type_nodes here? intQI, intHI, intSI, intDI, intTI?\n-    // Don't know what they mean, but one site has them here in a similar fashion of selections\n-\n-    if (mode == TYPE_MODE(integer_type_node))\n-        return unsignedp ? unsigned_type_node : integer_type_node;\n-\n-    if (mode == TYPE_MODE(long_integer_type_node))\n-        return unsignedp ? long_unsigned_type_node : long_integer_type_node;\n-\n-    if (COMPLEX_MODE_P(mode)) {\n-        if (mode == TYPE_MODE(complex_float_type_node))\n-            return complex_float_type_node;\n-        if (mode == TYPE_MODE(complex_double_type_node))\n-            return complex_double_type_node;\n-        if (mode == TYPE_MODE(complex_long_double_type_node))\n-            return complex_long_double_type_node;\n-        if (mode == TYPE_MODE(complex_integer_type_node) && !unsignedp)\n-            return complex_integer_type_node;\n-    }\n-    /* gcc_unreachable */\n-    return NULL;\n-}\n-\n-static tree grs_langhook_type_for_size(unsigned int bits ATTRIBUTE_UNUSED, \n-    int unsignedp ATTRIBUTE_UNUSED) {\n-    gcc_unreachable();\n-    return NULL_TREE;\n-}\n-\n-/* Record a builtin function.  We just ignore builtin functions.  */\n-static tree grs_langhook_builtin_function(tree decl ATTRIBUTE_UNUSED) {\n-    return decl;\n-}\n-\n-static bool grs_langhook_global_bindings_p(void) {\n-    return current_function_decl == NULL_TREE;\n-}\n-\n-static tree grs_langhook_pushdecl(tree decl ATTRIBUTE_UNUSED) {\n-    gcc_unreachable();\n-    return NULL;\n-}\n-\n-static tree grs_langhook_getdecls(void) {\n-    gcc_unreachable();\n-    return NULL;\n-}\n-\n-/* Write out globals.  */\n-static void grs_langhook_write_globals(void) {\n-    // pass off to middle end function basically.\n-    dot_pass_WriteGlobals();\n-}\n-\n-static unsigned int grs_langhook_option_lang_mask(void) {\n-    return CL_Rust;\n-}\n-\n-/* Return a decl for the exception personality function.  The function\n-   itself is implemented in libgo/runtime/go-unwind.c.  */\n-static tree grs_langhook_eh_personality(void) {\n-    static tree personality_decl;\n-    if (personality_decl == NULL_TREE) {\n-        personality_decl = build_personality_function(\"gccrs\");\n-        grs_preserve_from_gc(personality_decl);\n-    }\n-    return personality_decl;\n-}\n-\n-static int\n-grs_langhook_gimplify_expr(tree* expr_p ATTRIBUTE_UNUSED,\n-                           gimple_seq* pre_p ATTRIBUTE_UNUSED,\n-                           gimple_seq* post_p ATTRIBUTE_UNUSED) {\n-    if (TREE_CODE(*expr_p) == CALL_EXPR && CALL_EXPR_STATIC_CHAIN(*expr_p) != NULL_TREE)\n-        gimplify_expr(&CALL_EXPR_STATIC_CHAIN(*expr_p), pre_p, post_p, is_gimple_val, fb_rvalue);\n-    /* Often useful to use debug_tree here to see whats going on because\n-     ever gimplication calls this. */\n-    // debug_tree (*expr_p)\n-    return GS_UNHANDLED;\n-}\n-\n-/* Functions called directly by the generic backend.  */\n-tree convert(tree type, tree expr) {\n-    if (type == error_mark_node || expr == error_mark_node || TREE_TYPE(expr) == error_mark_node)\n-        return error_mark_node;\n-\n-    if (type == TREE_TYPE(expr))\n-        return expr;\n-\n-    if (TYPE_MAIN_VARIANT(type) == TYPE_MAIN_VARIANT(TREE_TYPE(expr)))\n-        return fold_convert(type, expr);\n-\n-    switch (TREE_CODE(type)) {\n-        case VOID_TYPE:\n-        case BOOLEAN_TYPE:\n-            return fold_convert(type, expr);\n-        case INTEGER_TYPE:\n-            return fold(convert_to_integer(type, expr));\n-        case POINTER_TYPE:\n-            return fold(convert_to_pointer(type, expr));\n-        case REAL_TYPE:\n-            return fold(convert_to_real(type, expr));\n-        case COMPLEX_TYPE:\n-            return fold(convert_to_complex(type, expr));\n-        default:\n-            break;\n-    }\n-\n-    gcc_unreachable();\n-}\n-\n-static GTY(()) tree grs_gc_root;\n-void grs_preserve_from_gc(tree t) {\n-    grs_gc_root = tree_cons(NULL_TREE, t, grs_gc_root);\n-}\n-\n-/* The language hooks data structure. This is the main interface between the GCC front-end\n- * and the GCC middle-end/back-end. A list of language hooks could be found in\n- * <gcc>/langhooks.h\n- */\n-#undef LANG_HOOKS_NAME\n-#undef LANG_HOOKS_INIT\n-#undef LANG_HOOKS_OPTION_LANG_MASK\n-#undef LANG_HOOKS_INIT_OPTIONS_STRUCT\n-#undef LANG_HOOKS_HANDLE_OPTION\n-#undef LANG_HOOKS_POST_OPTIONS\n-#undef LANG_HOOKS_PARSE_FILE\n-#undef LANG_HOOKS_TYPE_FOR_MODE\n-#undef LANG_HOOKS_TYPE_FOR_SIZE\n-#undef LANG_HOOKS_BUILTIN_FUNCTION\n-#undef LANG_HOOKS_GLOBAL_BINDINGS_P\n-#undef LANG_HOOKS_PUSHDECL\n-#undef LANG_HOOKS_GETDECLS\n-#undef LANG_HOOKS_WRITE_GLOBALS\n-#undef LANG_HOOKS_GIMPLIFY_EXPR\n-#undef LANG_HOOKS_EH_PERSONALITY\n-\n-#define LANG_HOOKS_NAME \"GNU Rust\"\n-#define LANG_HOOKS_INIT grs_langhook_init\n-#define LANG_HOOKS_OPTION_LANG_MASK grs_langhook_option_lang_mask\n-#define LANG_HOOKS_INIT_OPTIONS_STRUCT grs_langhook_init_options_struct\n-#define LANG_HOOKS_HANDLE_OPTION grs_langhook_handle_option\n-#define LANG_HOOKS_POST_OPTIONS grs_langhook_post_options\n-/* Main lang-hook, apparently. Finds input file names in global vars in_fnames and num_in_fnames\n- * From this, frontend can take over and do actual parsing and initial compilation.\n- * This hook must create a complete parse tree in a global var, and then return. */ \n-#define LANG_HOOKS_PARSE_FILE grs_langhook_parse_file\n-#define LANG_HOOKS_TYPE_FOR_MODE grs_langhook_type_for_mode\n-#define LANG_HOOKS_TYPE_FOR_SIZE grs_langhook_type_for_size\n-#define LANG_HOOKS_BUILTIN_FUNCTION grs_langhook_builtin_function\n-#define LANG_HOOKS_GLOBAL_BINDINGS_P grs_langhook_global_bindings_p\n-#define LANG_HOOKS_PUSHDECL grs_langhook_pushdecl\n-#define LANG_HOOKS_GETDECLS grs_langhook_getdecls\n-#define LANG_HOOKS_WRITE_GLOBALS grs_langhook_write_globals\n-#define LANG_HOOKS_GIMPLIFY_EXPR grs_langhook_gimplify_expr\n-#define LANG_HOOKS_EH_PERSONALITY grs_langhook_eh_personality\n-\n-struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n-\n-// These are for GCC's garbage collector to work properly or something\n-#include \"gt-rust-rs-lang.h\"\n-#include \"gtype-rust.h\"\n\\ No newline at end of file"}, {"sha": "b45f9317476b5a40aeae96c13e3a001920409736", "filename": "gcc/rust/old/rs-lexer.l", "status": "removed", "additions": 0, "deletions": 161, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-lexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-lexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978", "patch": "@@ -1,161 +0,0 @@\n-%{\n-  /* This file is part of GCC.\n-\n-     GCC is free software; you can redistribute it and/or modify it under\n-     the terms of the GNU General Public License as published by the Free\n-     Software Foundation; either version 3, or (at your option) any later\n-     version.\n-\n-     GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-     WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-     FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-     for more details.\n-\n-     You should have received a copy of the GNU General Public License\n-     along with GCC; see the file COPYING3.  If not see\n-     <http://www.gnu.org/licenses/>.  */\n-\n-#include \"rust.h\"\n-#include \"y.rs.h\"\n-\n-extern int yydebug;\n-extern int yyparse (void);\n-%}\n-\n-DIGIT        [0-9]\n-ID           [_a-zA-Z][a-zA_Z0-9_$]*\n-QSTRING      \\\"[^\\\"\\n]*[\\\"\\n]\n-\n-%x comment\n-%option yylineno noyywrap nounput 8bit never-interactive\n-%%\n-\n-\"/*\"                    {  BEGIN (comment); }\n-<comment>[^*\\n]*        {  /* eat it up flex you be le hungry maybe? */ }\n-<comment>\"*\"+[^*/\\n]*   {  /* eat up boyo */ }\n-<comment>\\n             {  ++yylineno; }\n-<comment>\"*\"+\"/\"        {  BEGIN (INITIAL); }\n-\n-as                      {  return AS; }\n-pub                     {  return PUB; }\n-break                   {  return BREAK; }\n-return                  {  return RETURN; }\n-continue                {  return CONTINUE; }\n-do                      {  return DO; }\n-fn                      {  return DEFUN; }\n-let                     {  return LET; }\n-mut                     {  return MUT; }\n-while                   {  return WHILE; }\n-loop                    {  return LOOP; }\n-static                  {  return STATIC; }\n-struct                  {  return STRUCT; }\n-if                      {  return IF; }\n-\"else if\"               {  return ELIF; }\n-else                    {  return ELSE; }\n-impl                    {  return IMPL; }\n-self                    {  return SELF; }\n-bool                    {  return TYPE_BOOL; }\n-int                     {  return TYPE_INT; }\n-float                   {  return TYPE_FLOAT; }\n-uint                    {  return TYPE_UINT; }\n-enum                    {  return ENUM; }\n-match                   {  return MATCH; }\n-true                    {  return XTRUE; }\n-false                   {  return XFALSE; }\n-trait                   {  return TRAIT; }\n-for                     {  return FOR; }\n-\\[                      {  return '['; }\n-\\]                      {  return ']'; }\n-\\(                      {  return '('; }\n-\\)                      {  return ')'; }\n-\\{                      {  return '{'; }\n-\\}                      {  return '}'; }\n-\"->\"                    {  return RTYPE; }\n-\"=>\"                    {  return GOES; }\n-\";\"                     { return ';'; }\n-\",\"                     { return ','; }\n-\".\"                     { return '.'; }\n-\":\"                     { return ':'; }\n-\"::\"                    { return ACC; }\n-\"=\"                     { return '='; }\n-\"+\"                     { return '+'; }\n-\"-\"                     { return '-'; }\n-\"/\"                     { return '/'; }\n-\"*\"                     { return '*'; }\n-\"|\"                     { return '|'; }\n-\"~\"                     { return '~'; }\n-\"&\"                     { return '&'; }\n-\"==\"                    { return EQUAL_EQUAL; }\n-\"!=\"                    { return NOT_EQUAL; }\n-\"<\"                     { return '<'; }\n-\"<=\"                    { return LESS_EQUAL; }\n-\">\"                     { return '>'; }\n-\">=\"                    { return GREATER_EQUAL; }\n-\n-\\/\\/.*                  ;  /* // style comment */\n-\n-{QSTRING}               {\n-  yylval.string = xstrdup (yytext + 1);\n-  if (yylval.string [yyleng - 2] != '\\\"')\n-    error (\"Un-termintated character string!\\n\");\n-  else\n-    yylval.string [yyleng - 2] = '\\0';\n-  return STRING;\n-}\n-\n-{DIGIT}+                {\n-  mpfr_t x;\n-  mpfr_init2 (x, 32);\n-  if (mpfr_set_str (x, yytext, 10, GMP_RNDU))\n-    {\n-      fatal_error (\"error initilizing integer value <%s>!\\n\", yytext);\n-    }\n-  yylval.integer = mpfr_get_si (x, GMP_RNDU);\n-  mpfr_clear (x);\n-  return INTEGER;\n-}\n-\n-{DIGIT}+\".\"{DIGIT}+    {\n-  mpfr_t x;\n-  mpfr_init2 (x, 32);\n-  if (mpfr_set_str (x, yytext, 10, GMP_RNDU))\n-    {\n-      fatal_error (\"error initilizing float value <%s>!\\n\", yytext);\n-    }\n-  yylval.ffloat = mpfr_get_flt (x, GMP_RNDU);\n-  mpfr_clear (x);\n-  return FLOAT;\n-}\n-\n-{ID}                    {\n-  yylval.string = xstrdup (yytext);\n-  return IDENTIFIER;\n-}\n-\n-.           {  }\n-\\n          {  }\n-\n-%%\n-\n-bool grs_do_compile (const char * in)\n-{\n-    bool retval = true;\n-    FILE * fd = fopen (in, \"rb\");\n-    if (fd)\n-    {\n-\tyyin = fd;\n-        // yydebug = 1;\n-        linemap_add (line_table, LC_ENTER, 0, in, 0);\n-\tretval = yyparse ();\n-\tfclose (fd);\n-        linemap_add (line_table, LC_LEAVE, 0, NULL, 0);\n-\tyylex_destroy ();\n-    }\n-    else\n-    {\n-\tfprintf (stderr, \"error opening file %s\\n\", in);\n-\tretval = false;\n-    }\n-    return retval;\n-}\n-"}, {"sha": "c3c8c2cea35a5bbb7b96f003a5ef189cc16e89af", "filename": "gcc/rust/old/rs-parser.cc", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-parser.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-parser.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-parser.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9ffac6e5b6bcb2052de3f1a6ea90beb94072abb7", "filename": "gcc/rust/old/rs-pass-manager.cc", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-pass-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-pass-manager.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "7e7c868bab3843dff3fd0430063fb79ce168950b", "filename": "gcc/rust/old/rs-runtime-hooks.cc", "status": "removed", "additions": 0, "deletions": 57, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frs-runtime-hooks.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c5dde9bc71a04a09ae107f4fa8b3730c804876e8", "filename": "gcc/rust/old/rsspec.cc", "status": "removed", "additions": 0, "deletions": 401, "changes": 401, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frsspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4a1a6d1b901c6b5954a14b6d7f94b6c9fa5d6026", "filename": "gcc/rust/old/rust.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frust.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Frust.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Frust.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d0246a27de435ad51fee166601f9e01ed14f0d5a", "filename": "gcc/rust/old/y.rs.h", "status": "removed", "additions": 0, "deletions": 58, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Fy.rs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Fold%2Fy.rs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fold%2Fy.rs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f3e0fd0743469622cee5d5a56f3775b8f6618122", "filename": "gcc/rust/operator.h", "status": "renamed", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Foperator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Foperator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Foperator.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/rustfrontend/operator.h"}, {"sha": "ad7b920bc28a7af0bd8f0248dce56fb6f7e7fb54", "filename": "gcc/rust/parse/rust-parse-includes.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse-includes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse-includes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse-includes.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/parse/rust-parse-includes.h"}, {"sha": "1eac8a17696cf455a109e1fbe3808e1610e2df35", "filename": "gcc/rust/parse/rust-parse.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/parse/rust-parse.cc"}, {"sha": "94d1eabbd8cda31ad781f0ad8fb5fe07e90620d4", "filename": "gcc/rust/parse/rust-parse.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-parse.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/parse/rust-parse.h"}, {"sha": "d38a07801cc0280c501b04ea6499d61f6403581e", "filename": "gcc/rust/parse/rust-scope.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-scope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-scope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-scope.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3-tiny/parse/rust-scope.cc"}, {"sha": "7ac38c998b6a9506981bea5b0f635ae1eb6938d4", "filename": "gcc/rust/parse/rust-scope.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-scope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-scope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-scope.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/parse/rust-scope.h"}, {"sha": "439325b68feef10fde45cc76c4a4bf58b761f143", "filename": "gcc/rust/parse/rust-symbol.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-symbol.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-symbol.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-symbol.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/parse/rust-symbol.h"}, {"sha": "6318a50d31468955dfe42dd314696cd2aa2bf0ed", "filename": "gcc/rust/parse/rust-tree.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Fparse%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fparse%2Frust-tree.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3-tiny/parse/rust-tree.h"}, {"sha": "ac0ea1ac0025d6a44154911cd3b85db00f3186b6", "filename": "gcc/rust/rust-buffered-queue.h", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-buffered-queue.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/rust-buffered-queue.h"}, {"sha": "d75d9e7a26bd2ffcea1099ce3f5ad767a14c7bf6", "filename": "gcc/rust/rust-c.h", "status": "removed", "additions": 0, "deletions": 45, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-c.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "feecba93b97f1a162d945c647e23cc6d6b636da3", "filename": "gcc/rust/rust-gcc.cc", "status": "modified", "additions": 1761, "deletions": 1997, "changes": 3758, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-gcc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-gcc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-gcc.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2"}, {"sha": "6e1be89e2befc3efc039c5742673f484040e16b0", "filename": "gcc/rust/rust-lang.c", "status": "removed", "additions": 0, "deletions": 567, "changes": 567, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frust-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "28cddde0bd2412fbcd882cb91f2b46cf5a5b0acd", "filename": "gcc/rust/rust-lang.cc", "status": "renamed", "additions": 78, "deletions": 23, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-lang.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/rust-lang.cc"}, {"sha": "3d09aa707ad8b638bfff4cb052777028f23be96d", "filename": "gcc/rust/rust-object-export.c", "status": "added", "additions": 193, "deletions": 0, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-object-export.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-object-export.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.c?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2"}, {"sha": "4e84895317ba9923692f15aa49e82323c2755508", "filename": "gcc/rust/rust-object-export.h", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-object-export.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-object-export.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-object-export.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2"}, {"sha": "443818c18463c6a95924570aa07580d1104dd4c5", "filename": "gcc/rust/rust-session-manager.cc", "status": "renamed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/rust-session-manager.cc"}, {"sha": "38eb4940c20bb5e5f5cca71c2ee37f4d692e5914", "filename": "gcc/rust/rust-session-manager.h", "status": "renamed", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-session-manager.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-session-manager.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2", "previous_filename": "gcc/rust/test3/rust-session-manager.h"}, {"sha": "f424a4b3169610818f778df7c79fc16ad8230856", "filename": "gcc/rust/rust-system.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-system.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frust-system.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-system.h?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2"}, {"sha": "cecc84f14756be40937ac71eb145bb1cd4fd1614", "filename": "gcc/rust/rustc_parser/RustCNotes.txt", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2FRustCNotes.txt?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "3e4498759434f92723f6a9665fb1fa7bc6d9997c", "filename": "gcc/rust/rustc_parser/grammar/.gitignore", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2F.gitignore?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "gcc/rust/rustc_parser/grammar/lexer.l", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Flexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6348190cc140bc8ae496ec99a9000ef4d934c334", "filename": "gcc/rust/rustc_parser/grammar/parser-lalr-main.c", "status": "removed", "additions": 0, "deletions": 193, "changes": 193, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr-main.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "gcc/rust/rustc_parser/grammar/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fparser-lalr.y?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c909f2333148a99d3482373c91e279a2dad2a1ce", "filename": "gcc/rust/rustc_parser/grammar/raw-string-literal-ambiguity.md", "status": "removed", "additions": 0, "deletions": 64, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Fraw-string-literal-ambiguity.md?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4b5a7fb9e10b5c4ce4f6d6f52932787194713d5d", "filename": "gcc/rust/rustc_parser/grammar/testparser.py", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftestparser.py?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "297e3dc841e871502e2270c95fdf6565806f0f5a", "filename": "gcc/rust/rustc_parser/grammar/tokens.h", "status": "removed", "additions": 0, "deletions": 99, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Fgrammar%2Ftokens.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c5daa6564767e617511bbaf61b8c9e43532d2cc8", "filename": "gcc/rust/rustc_parser/libsyntax/Cargo.toml", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FCargo.toml?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "daa252ef4551b38715776b9a1a71a862c17727c9", "filename": "gcc/rust/rustc_parser/libsyntax/README.md", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2FREADME.md?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c627596bbdf20ea7720e5175660b07787c8f5a09", "filename": "gcc/rust/rustc_parser/libsyntax/ast.rs", "status": "removed", "additions": 0, "deletions": 2409, "changes": 2409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fast.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b41f1047fcba3765c952f4d3197b5e19a926a472", "filename": "gcc/rust/rustc_parser/libsyntax/attr/builtin.rs", "status": "removed", "additions": 0, "deletions": 903, "changes": 903, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fbuiltin.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a9f2429560ad288ff68901812df07c5ad3e04737", "filename": "gcc/rust/rustc_parser/libsyntax/attr/mod.rs", "status": "removed", "additions": 0, "deletions": 753, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fattr%2Fmod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9b861f9640904b51bdc7ef32d294f40d054ebb26", "filename": "gcc/rust/rustc_parser/libsyntax/build.rs", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fbuild.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1ab367f73c1b31a1da288c8a293fc999d5ee150a", "filename": "gcc/rust/rustc_parser/libsyntax/config.rs", "status": "removed", "additions": 0, "deletions": 369, "changes": 369, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fconfig.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6f7493ad59726d4003f8b63067adf1863b894ade", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/macros.rs", "status": "removed", "additions": 0, "deletions": 188, "changes": 188, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmacros.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "53f37bb10bdc0ecfb61bb228826c27c66fea896d", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/metadata.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fmetadata.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ee640a1603a6ca688c54a648102efa6b7bee3d7a", "filename": "gcc/rust/rustc_parser/libsyntax/diagnostics/plugin.rs", "status": "removed", "additions": 0, "deletions": 213, "changes": 213, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fdiagnostics%2Fplugin.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b26a1165fed1db27ffc68657322ae91c86182d48", "filename": "gcc/rust/rustc_parser/libsyntax/early_buffered_lints.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fearly_buffered_lints.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "0b6cf30bd27d248207397ef3338ae9f62e4faff9", "filename": "gcc/rust/rustc_parser/libsyntax/entry.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fentry.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e2d212eb721ff9cadcbb26ef5eb0e58a8b091d87", "filename": "gcc/rust/rustc_parser/libsyntax/error_codes.rs", "status": "removed", "additions": 0, "deletions": 450, "changes": 450, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ferror_codes.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "15c0b6ca5aa81248b7d149e78d7ee701565b37db", "filename": "gcc/rust/rustc_parser/libsyntax/ext/base.rs", "status": "removed", "additions": 0, "deletions": 1013, "changes": 1013, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbase.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "baf1031de1e7c40ddbe0f5f84be5bfa792f25ed6", "filename": "gcc/rust/rustc_parser/libsyntax/ext/build.rs", "status": "removed", "additions": 0, "deletions": 1210, "changes": 1210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fbuild.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "2a56f3dd7566bc2fa06b0994097c312b868eaf28", "filename": "gcc/rust/rustc_parser/libsyntax/ext/derive.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fderive.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "74ef5cbe9177ebf767c6206fa87e95acdbfaf7d2", "filename": "gcc/rust/rustc_parser/libsyntax/ext/expand.rs", "status": "removed", "additions": 0, "deletions": 1471, "changes": 1471, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fexpand.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b2b8bfb09b45e9206603929424642976a6390644", "filename": "gcc/rust/rustc_parser/libsyntax/ext/placeholders.rs", "status": "removed", "additions": 0, "deletions": 203, "changes": 203, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fplaceholders.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c2ba8b983f5a84b2393bd7a948183ddc162023f4", "filename": "gcc/rust/rustc_parser/libsyntax/ext/source_util.rs", "status": "removed", "additions": 0, "deletions": 187, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Fsource_util.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "fc8aa4793bc6111eba60d007e077c69ac1d7be7c", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/macro_parser.rs", "status": "removed", "additions": 0, "deletions": 954, "changes": 954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_parser.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "665c794422d49cc51433835a3d163d47fba09135", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/macro_rules.rs", "status": "removed", "additions": 0, "deletions": 1206, "changes": 1206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fmacro_rules.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ccf9db842ab6e467acbe3446d0938916dfeaa341", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/quoted.rs", "status": "removed", "additions": 0, "deletions": 418, "changes": 418, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Fquoted.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e04fd2ddc05bce62332409adbd00515ad3de7069", "filename": "gcc/rust/rustc_parser/libsyntax/ext/tt/transcribe.rs", "status": "removed", "additions": 0, "deletions": 372, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fext%2Ftt%2Ftranscribe.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "fd1cb3d803b0916cf74a49c16427ac8039ff3239", "filename": "gcc/rust/rustc_parser/libsyntax/feature_gate.rs", "status": "removed", "additions": 0, "deletions": 2646, "changes": 2646, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ffeature_gate.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "767ab74355e66213ff8c27fbec2ba22be41f7302", "filename": "gcc/rust/rustc_parser/libsyntax/json.rs", "status": "removed", "additions": 0, "deletions": 412, "changes": 412, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fjson.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a7c5ed158e0287158e3118869365ed8d6c0e360f", "filename": "gcc/rust/rustc_parser/libsyntax/lib.rs", "status": "removed", "additions": 0, "deletions": 189, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Flib.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "11a1de13fc217874cef8fb8d67eed2fefc9bd50b", "filename": "gcc/rust/rustc_parser/libsyntax/mut_visit.rs", "status": "removed", "additions": 0, "deletions": 1334, "changes": 1334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fmut_visit.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b28d48b9445fdcd6c66a9db199bd988f0ee2dbef", "filename": "gcc/rust/rustc_parser/libsyntax/parse/attr.rs", "status": "removed", "additions": 0, "deletions": 305, "changes": 305, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fattr.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6ebfab3a133ef80da61e6f8d75be0c8afa8314c4", "filename": "gcc/rust/rustc_parser/libsyntax/parse/classify.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fclassify.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "edcdb18a037d863f5b08fff410fce9c6e4c6bebc", "filename": "gcc/rust/rustc_parser/libsyntax/parse/diagnostics.rs", "status": "removed", "additions": 0, "deletions": 1273, "changes": 1273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fdiagnostics.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "988f1aa38d926e814e9df631d7b4b1f118cb3e6a", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/comments.rs", "status": "removed", "additions": 0, "deletions": 433, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fcomments.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d0c4e8d6a5634b6bbbc09b8f252605141423bdc7", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/mod.rs", "status": "removed", "additions": 0, "deletions": 1609, "changes": 1609, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Fmod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "830fbec58ded952c109184007741491d7a17aaa2", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/tokentrees.rs", "status": "removed", "additions": 0, "deletions": 230, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Ftokentrees.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6a870685938a04bb8463baf75a5c22b463b5e234", "filename": "gcc/rust/rustc_parser/libsyntax/parse/lexer/unicode_chars.rs", "status": "removed", "additions": 0, "deletions": 393, "changes": 393, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Flexer%2Funicode_chars.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ef55bf6b929336511e4dc5f3fb5d0317e500535f", "filename": "gcc/rust/rustc_parser/libsyntax/parse/literal.rs", "status": "removed", "additions": 0, "deletions": 470, "changes": 470, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fliteral.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4c4551b1757acefd44615353243d9ae937f961ea", "filename": "gcc/rust/rustc_parser/libsyntax/parse/mod.rs", "status": "removed", "additions": 0, "deletions": 680, "changes": 680, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fmod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a95b6891fb9d5876d243bfabc8cfe545be4102eb", "filename": "gcc/rust/rustc_parser/libsyntax/parse/parser.rs", "status": "removed", "additions": 0, "deletions": 7852, "changes": 7852, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Fparser.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ebd0decacb59fff2032d61444af8d801f78a6cc4", "filename": "gcc/rust/rustc_parser/libsyntax/parse/token.rs", "status": "removed", "additions": 0, "deletions": 827, "changes": 827, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Ftoken.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "87cc9c1c9e323efd1b9dee8bc763eb1400889d20", "filename": "gcc/rust/rustc_parser/libsyntax/parse/unescape.rs", "status": "removed", "additions": 0, "deletions": 602, "changes": 602, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "71b41161ad8c6fd00553ad0f21e526a818e04c42", "filename": "gcc/rust/rustc_parser/libsyntax/parse/unescape_error_reporting.rs", "status": "removed", "additions": 0, "deletions": 210, "changes": 210, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fparse%2Funescape_error_reporting.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f64e95aee5bca91ee5ac4382bdf997db165a519e", "filename": "gcc/rust/rustc_parser/libsyntax/print/pp.rs", "status": "removed", "additions": 0, "deletions": 661, "changes": 661, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpp.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "67646cce69b4f47d2addf5753ad5c20a98845fba", "filename": "gcc/rust/rustc_parser/libsyntax/print/pprust.rs", "status": "removed", "additions": 0, "deletions": 3069, "changes": 3069, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fprint%2Fpprust.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "be580dc2e6a7e4aaff0ae4ef00ef235ee9842020", "filename": "gcc/rust/rustc_parser/libsyntax/ptr.rs", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fptr.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5e0cf9eea78b85a6f330e7edd5d27c84d7af1f26", "filename": "gcc/rust/rustc_parser/libsyntax/show_span.rs", "status": "removed", "additions": 0, "deletions": 75, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fshow_span.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ac30cbb471aeab3bf53e948dd37960d4b3a1c241", "filename": "gcc/rust/rustc_parser/libsyntax/source_map.rs", "status": "removed", "additions": 0, "deletions": 1244, "changes": 1244, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fsource_map.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6630bf9081546de2a712a73d7355e09debf9465a", "filename": "gcc/rust/rustc_parser/libsyntax/std_inject.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fstd_inject.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c717f140ca368e36a8536c3debf526873832b7eb", "filename": "gcc/rust/rustc_parser/libsyntax/test.rs", "status": "removed", "additions": 0, "deletions": 437, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "107cbe70a23d7aef0d4a1058f41da25bf3bd9be2", "filename": "gcc/rust/rustc_parser/libsyntax/test_snippet.rs", "status": "removed", "additions": 0, "deletions": 1164, "changes": 1164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftest_snippet.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b32049b1da8c365992d1b284701b4553b654b331", "filename": "gcc/rust/rustc_parser/libsyntax/tokenstream.rs", "status": "removed", "additions": 0, "deletions": 665, "changes": 665, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Ftokenstream.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "885b5a4f333b8fc74177f76f3c118e31ac2a70e4", "filename": "gcc/rust/rustc_parser/libsyntax/util/lev_distance.rs", "status": "removed", "additions": 0, "deletions": 136, "changes": 136, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Flev_distance.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5724b540a0dcfb51206bb69300296c419dcc40cc", "filename": "gcc/rust/rustc_parser/libsyntax/util/map_in_place.rs", "status": "removed", "additions": 0, "deletions": 102, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fmap_in_place.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f17eb3b39432efccb2d5e87eec22f4f70033558a", "filename": "gcc/rust/rustc_parser/libsyntax/util/node_count.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fnode_count.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1e52186a106c12f80753be3b183139b4bc78dbb7", "filename": "gcc/rust/rustc_parser/libsyntax/util/parser.rs", "status": "removed", "additions": 0, "deletions": 402, "changes": 402, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f850960624ce7eec4b8c5502c7b60e1a896b6022", "filename": "gcc/rust/rustc_parser/libsyntax/util/parser_testing.rs", "status": "removed", "additions": 0, "deletions": 160, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Futil%2Fparser_testing.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9ec9550f93ab93f1d42c44ade154f630c80ac6ec", "filename": "gcc/rust/rustc_parser/libsyntax/visit.rs", "status": "removed", "additions": 0, "deletions": 857, "changes": 857, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax%2Fvisit.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "eafbe6371a3c56f3332f983227643a74025edaf4", "filename": "gcc/rust/rustc_parser/libsyntax_ext/Cargo.toml", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2FCargo.toml?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c1c2732605c46d5c199c1142527bee315d41c211", "filename": "gcc/rust/rustc_parser/libsyntax_ext/asm.rs", "status": "removed", "additions": 0, "deletions": 282, "changes": 282, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fasm.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "637614a18bcc339a07f76cfd40bff8927a0e8171", "filename": "gcc/rust/rustc_parser/libsyntax_ext/assert.rs", "status": "removed", "additions": 0, "deletions": 141, "changes": 141, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fassert.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e952515bfe0ebf978b68d3fb0f40ec6a14cd65e4", "filename": "gcc/rust/rustc_parser/libsyntax_ext/cfg.rs", "status": "removed", "additions": 0, "deletions": 56, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcfg.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "59d3f2c9c7813a0901097227b18546ead73315f8", "filename": "gcc/rust/rustc_parser/libsyntax_ext/compile_error.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fcompile_error.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "68d5178372eba7b774b61dca11a1faa607937a4f", "filename": "gcc/rust/rustc_parser/libsyntax_ext/concat.rs", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "df9191416038d7f825671f642e6f1aba83705d63", "filename": "gcc/rust/rustc_parser/libsyntax_ext/concat_idents.rs", "status": "removed", "additions": 0, "deletions": 66, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fconcat_idents.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d5b8a00c75b834ad8862ba66c0d4a2adc99eca66", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/bounds.rs", "status": "removed", "additions": 0, "deletions": 27, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fbounds.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b3b6328e2ca7306536dff1787ca2ac07fcd8d2bb", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/clone.rs", "status": "removed", "additions": 0, "deletions": 216, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fclone.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1d981e0ff7906ba8b4788c6bb9cbcdbfa84c19d6", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/eq.rs", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Feq.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "844865d57c7ad04102534e86736abd736c2fabe2", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/ord.rs", "status": "removed", "additions": 0, "deletions": 118, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Ford.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "732bb234389a0aedd1ccf474f36d27ec3621d8b2", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/partial_eq.rs", "status": "removed", "additions": 0, "deletions": 103, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_eq.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a30a7d78222f47202e348f5a53b6ee694e67c242", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/cmp/partial_ord.rs", "status": "removed", "additions": 0, "deletions": 301, "changes": 301, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcmp%2Fpartial_ord.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "98465d75e4680e9d31beb6665f871e22e0ade22b", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/custom.rs", "status": "removed", "additions": 0, "deletions": 119, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fcustom.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "44ddbb98809b4f0d217bc234df31b15071520e35", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/debug.rs", "status": "removed", "additions": 0, "deletions": 138, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdebug.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8009f42b8cf95b8650839101d50d1facb5139fac", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/decodable.rs", "status": "removed", "additions": 0, "deletions": 205, "changes": 205, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdecodable.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "fd8e87e2fefd17fc0674a7f096d4deb45e58a2ff", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/default.rs", "status": "removed", "additions": 0, "deletions": 81, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fdefault.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "cd89a42cf82703a083fb0bcfa47b9abe0a7f1eba", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/encodable.rs", "status": "removed", "additions": 0, "deletions": 277, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fencodable.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "12482f7248e90b5eb43a71ea90ecde045eb96ead", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/generic/mod.rs", "status": "removed", "additions": 0, "deletions": 1831, "changes": 1831, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fmod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "02b02e9b836957336bc51e566dc7d3aa211ef711", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/generic/ty.rs", "status": "removed", "additions": 0, "deletions": 297, "changes": 297, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fgeneric%2Fty.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "7ad04aebf6e2ea6e4d5bfc2c5c49b0d3f5165216", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/hash.rs", "status": "removed", "additions": 0, "deletions": 93, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fhash.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e491e93256d1cf776d509b7910ebf11d3cf5e578", "filename": "gcc/rust/rustc_parser/libsyntax_ext/deriving/mod.rs", "status": "removed", "additions": 0, "deletions": 182, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fderiving%2Fmod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "b7f2ecf0f9137b9931b40aecca232d8df3a18f5f", "filename": "gcc/rust/rustc_parser/libsyntax_ext/env.rs", "status": "removed", "additions": 0, "deletions": 87, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fenv.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9bbd9fdec17d69d8951703488ba5c228e2d37d0c", "filename": "gcc/rust/rustc_parser/libsyntax_ext/error_codes.rs", "status": "removed", "additions": 0, "deletions": 123, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ferror_codes.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c3dbd48cc6e4e8bbebcfd83138c2e8b7fcc2e9c7", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format.rs", "status": "removed", "additions": 0, "deletions": 1090, "changes": 1090, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "3d4f82764413a0021fd93b3dfb194b259ad18264", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign.rs", "status": "removed", "additions": 0, "deletions": 836, "changes": 836, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "87021f1ef5a52857e55023624abb719b71b2113e", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign/printf/tests.rs", "status": "removed", "additions": 0, "deletions": 151, "changes": 151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fprintf%2Ftests.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8ef58b8387e5a5f9cedcf24bd26ed9dc99e0020d", "filename": "gcc/rust/rustc_parser/libsyntax_ext/format_foreign/shell/tests.rs", "status": "removed", "additions": 0, "deletions": 59, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fformat_foreign%2Fshell%2Ftests.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "112192fac5d26dd79531eaf808eb0e6a479561d7", "filename": "gcc/rust/rustc_parser/libsyntax_ext/global_asm.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fglobal_asm.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "62530f4fe7b336dd11524db94418faff18b6610e", "filename": "gcc/rust/rustc_parser/libsyntax_ext/lib.rs", "status": "removed", "additions": 0, "deletions": 168, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flib.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "cbdfd08b4977f2f5a6c946f4f516adef6aa5d0eb", "filename": "gcc/rust/rustc_parser/libsyntax_ext/log_syntax.rs", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Flog_syntax.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "45e65288a24ee6a3b7614f24ef77d961812cb321", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_decls.rs", "status": "removed", "additions": 0, "deletions": 432, "changes": 432, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_decls.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f0fc6392cd73f593f7e963e8c4342f8ce2182b37", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_impl.rs", "status": "removed", "additions": 0, "deletions": 68, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_impl.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e502735452735d8dca8264ae20b834953a2acdfd", "filename": "gcc/rust/rustc_parser/libsyntax_ext/proc_macro_server.rs", "status": "removed", "additions": 0, "deletions": 717, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Fproc_macro_server.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "24d3055e7114087192cb2ccfa784ac31ebe96425", "filename": "gcc/rust/rustc_parser/libsyntax_ext/test.rs", "status": "removed", "additions": 0, "deletions": 309, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "186673c142f14b13db8daeb72df7155548329bcc", "filename": "gcc/rust/rustc_parser/libsyntax_ext/test_case.rs", "status": "removed", "additions": 0, "deletions": 51, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftest_case.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "0dce8a36f4c7b24c39b769eb58c1dbeba3913c07", "filename": "gcc/rust/rustc_parser/libsyntax_ext/trace_macros.rs", "status": "removed", "additions": 0, "deletions": 21, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_ext%2Ftrace_macros.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "eebd25d1fafd82e37c53277f66474313255db5b1", "filename": "gcc/rust/rustc_parser/libsyntax_pos/Cargo.toml", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2FCargo.toml?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "353b4e4ab36b3a4095b860542897aa0d076cca6f", "filename": "gcc/rust/rustc_parser/libsyntax_pos/analyze_source_file.rs", "status": "removed", "additions": 0, "deletions": 425, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fanalyze_source_file.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "20216568426fed72d2938c8d0fdcbee129df52e7", "filename": "gcc/rust/rustc_parser/libsyntax_pos/edition.rs", "status": "removed", "additions": 0, "deletions": 77, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fedition.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a6c8c76cf23f7375b2bdc13cd0d75d3c2c984a3c", "filename": "gcc/rust/rustc_parser/libsyntax_pos/hygiene.rs", "status": "removed", "additions": 0, "deletions": 763, "changes": 763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fhygiene.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "07b9f60932024db20a488398270f7a42e4afdc03", "filename": "gcc/rust/rustc_parser/libsyntax_pos/lib.rs", "status": "removed", "additions": 0, "deletions": 1446, "changes": 1446, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Flib.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "525ec13623289e50c3f6921cdeabac851a1f3612", "filename": "gcc/rust/rustc_parser/libsyntax_pos/span_encoding.rs", "status": "removed", "additions": 0, "deletions": 140, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fspan_encoding.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "89fcf3b1f8f190845213d7f55d709e50c5f22498", "filename": "gcc/rust/rustc_parser/libsyntax_pos/symbol.rs", "status": "removed", "additions": 0, "deletions": 1380, "changes": 1380, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustc_parser%2Flibsyntax_pos%2Fsymbol.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "00ef2327251d26f8816594de78f1045c81f29b73", "filename": "gcc/rust/rustfrontend/main.cc", "status": "removed", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fmain.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fmain.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fmain.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "24393a5d60de111956f9589a3b15e1903b0d70e1", "filename": "gcc/rust/rustfrontend/node.cc", "status": "removed", "additions": 0, "deletions": 862, "changes": 862, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fnode.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "7d83c2d9d7bcf4d47266c6d08be2d362b9d4d092", "filename": "gcc/rust/rustfrontend/node.h", "status": "removed", "additions": 0, "deletions": 378, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Fnode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Fnode.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "76bbed3c5fc510bd6c62813947d58b28a4ea345a", "filename": "gcc/rust/rustfrontend/rs-lexer.l", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-lexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-lexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frs-lexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "17fff376834480be3735f5270022607a07dc4466", "filename": "gcc/rust/rustfrontend/rs-parser.y", "status": "removed", "additions": 0, "deletions": 1977, "changes": 1977, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-parser.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frs-parser.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frs-parser.y?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "eb14194bec42a0d8b0651ae5102ce00170da4525", "filename": "gcc/rust/rustfrontend/rustly.cc", "status": "removed", "additions": 0, "deletions": 83, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frustly.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "db7455f5ae3f266d6300fde287a02fc6ff96bee7", "filename": "gcc/rust/rustfrontend/rustly.h", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Frustfrontend%2Frustly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustfrontend%2Frustly.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8a765da9bd12a8a3d1f5c99149a5a5bfebd42760", "filename": "gcc/rust/rustspec.cc", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frustspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ead24ec6247577824cfce46ffcc9d179fb281fb2/gcc%2Frust%2Frustspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frustspec.cc?ref=ead24ec6247577824cfce46ffcc9d179fb281fb2"}, {"sha": "d0b6693491fa73f19a51ae0511322f307c723e4f", "filename": "gcc/rust/test/rustc_bison_test/lex.yy.c", "status": "removed", "additions": 0, "deletions": 3389, "changes": 3389, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "934c28e2526b60090388fdc45c85c7c655235ec4", "filename": "gcc/rust/test/rustc_bison_test/lex.yy.cc", "status": "removed", "additions": 0, "deletions": 3151, "changes": 3151, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flex.yy.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1feb781b2b39ff4984156ca9fd695b61dcd41da1", "filename": "gcc/rust/test/rustc_bison_test/lexer.l", "status": "removed", "additions": 0, "deletions": 350, "changes": 350, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Flexer.l?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a0cab12704e6aa4512697788dfba26c7aaa067fb", "filename": "gcc/rust/test/rustc_bison_test/parser-interface.c", "status": "removed", "additions": 0, "deletions": 200, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-interface.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5585c95a5a63a828558a6a9073b57458d1220fbc", "filename": "gcc/rust/test/rustc_bison_test/parser-lalr.y", "status": "removed", "additions": 0, "deletions": 1982, "changes": 1982, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser-lalr.y?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "795ff6a110cec52614c560e0fcad6fcb731b1819", "filename": "gcc/rust/test/rustc_bison_test/parser.tab.c", "status": "removed", "additions": 0, "deletions": 9173, "changes": 9173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Fparser.tab.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d3bec021655681031f840581dec8c1d7755165aa", "filename": "gcc/rust/test/rustc_bison_test/token.h", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Frustc_bison_test%2Ftoken.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "32e351ad53b451472e89a28f5427d39869c0a97c", "filename": "gcc/rust/test/test1..s", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1..s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1..s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1..s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e6cfaaea5bd46f52ea998b02a4d673816dab7838", "filename": "gcc/rust/test/test1.rs", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d3126f9e76835aaa3ceb001b627c382899492354", "filename": "gcc/rust/test/test1.s", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest1.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest1.s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "3999215544e80487651da99a199a1d29e570218b", "filename": "gcc/rust/test/test2-minimal.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2-minimal.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2-minimal.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2-minimal.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "976f1f37c3e83eb523e46b24bab07e836c0a2da2", "filename": "gcc/rust/test/test2.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "75ff5c45494014a52826d50907712745ebe4bc29", "filename": "gcc/rust/test/test2.s", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.s", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest2.s", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest2.s?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f35de3a1e480b52c7b965ae8e244d7c708de8831", "filename": "gcc/rust/test/test_jit.c", "status": "removed", "additions": 0, "deletions": 331, "changes": 331, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest_jit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest%2Ftest_jit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest%2Ftest_jit.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "718040bc616ffc4dea894d06abce5b6beb6aff57", "filename": "gcc/rust/test2/rust-c.h", "status": "removed", "additions": 0, "deletions": 65, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frust-c.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frust-c.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frust-c.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a21984ca036b5e153186959e905cf7462bc2f0d3", "filename": "gcc/rust/test2/rust-lang.c", "status": "removed", "additions": 0, "deletions": 512, "changes": 512, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frust-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frust-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frust-lang.c?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5104142b33fafd09cdacd9d11afd1f4e365e82ed", "filename": "gcc/rust/test2/rustfrontend/eTokenType.enum.h", "status": "removed", "additions": 0, "deletions": 154, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2FeTokenType.enum.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4d2958ae8c1394093693d28a71119c381249921c", "filename": "gcc/rust/test2/rustfrontend/rs-generic-converter.cc", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-generic-converter.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "309c83fdecd97292001a4ca25dee117771c14a33", "filename": "gcc/rust/test2/rustfrontend/rs-lex.cc", "status": "removed", "additions": 0, "deletions": 2884, "changes": 2884, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5835f42d067b9e658b0f685762794f4a2e1117d1", "filename": "gcc/rust/test2/rustfrontend/rs-lex.h", "status": "removed", "additions": 0, "deletions": 361, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-lex.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e3c4d394ebf56878192182410c8691e24b7fa751", "filename": "gcc/rust/test2/rustfrontend/rs-token.h", "status": "removed", "additions": 0, "deletions": 284, "changes": 284, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frs-token.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "989c99209f1a4d28a324b526e2b0abb6699431fc", "filename": "gcc/rust/test2/rustfrontend/rust.cc", "status": "removed", "additions": 0, "deletions": 179, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest2%2Frustfrontend%2Frust.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "500960c3b61a7249eb3e30ef4facbf8956b3ea05", "filename": "gcc/rust/test3-tiny/Make-lang.in", "status": "removed", "additions": 0, "deletions": 226, "changes": 226, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2FMake-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "823f626a44f8135070ef4b7bbe5f1cbeb95ede6b", "filename": "gcc/rust/test3-tiny/config-lang.in", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fconfig-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c36a9e7e55bafb5df7ebcf7bf127e0d28eed9092", "filename": "gcc/rust/test3-tiny/lang-specs.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flang-specs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e620b8443cc09e7a10c87510d05a44f3f4ecb654", "filename": "gcc/rust/test3-tiny/lex/rust-lex.cc", "status": "removed", "additions": 0, "deletions": 314, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4d0bdbb2a55cdf0d298466d92f96b77fee57fadf", "filename": "gcc/rust/test3-tiny/lex/rust-lex.h", "status": "removed", "additions": 0, "deletions": 98, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-lex.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1a4fe388dc8ed67801fda549f95dd827b41c36e8", "filename": "gcc/rust/test3-tiny/lex/rust-token.cc", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "68c8d63d1d5164b78fa7ed15d6c1f3bed6a023b0", "filename": "gcc/rust/test3-tiny/lex/rust-token.h", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Flex%2Frust-token.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "a38f0c4e996d718563dc3a0b250386cf5b6aa733", "filename": "gcc/rust/test3-tiny/parse/rust-misc-convert.cc", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-misc-convert.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ec9c2122503e9701cbfa657f98082d1fbd12b134", "filename": "gcc/rust/test3-tiny/parse/rust-parse.cc", "status": "removed", "additions": 0, "deletions": 1806, "changes": 1806, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "60768cfd022fce0e2a3f686f8fc39e72f62ec17c", "filename": "gcc/rust/test3-tiny/parse/rust-parse.h", "status": "removed", "additions": 0, "deletions": 149, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-parse.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "1d1f6e2959ff843df2a951920166a7ffd6230dfd", "filename": "gcc/rust/test3-tiny/parse/rust-scope.h", "status": "removed", "additions": 0, "deletions": 112, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Fparse%2Frust-scope.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "69a14ada3fe585ee2340dc17b5384474b8d1f0ee", "filename": "gcc/rust/test3-tiny/rsspec.cc", "status": "removed", "additions": 0, "deletions": 354, "changes": 354, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frsspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "bfd36be88fb7d10ce87fc570ddfd7bee74d5a59c", "filename": "gcc/rust/test3-tiny/rust-buffered-queue.h", "status": "removed", "additions": 0, "deletions": 106, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frust-buffered-queue.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d8f85ca6caa4a7b61db5a567ecabebae674d57ee", "filename": "gcc/rust/test3-tiny/rust-lang.cc", "status": "removed", "additions": 0, "deletions": 262, "changes": 262, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3-tiny%2Frust-lang.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "36d908ccb3aaf6f56185ac1f7c0b615b798d5387", "filename": "gcc/rust/test3/Make-lang.in", "status": "removed", "additions": 0, "deletions": 240, "changes": 240, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2FMake-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "55913405597efd6f43950f3aa91a87166d9f7052", "filename": "gcc/rust/test3/config-lang.in", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fconfig-lang.in?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c36a9e7e55bafb5df7ebcf7bf127e0d28eed9092", "filename": "gcc/rust/test3/lang-specs.h", "status": "removed", "additions": 0, "deletions": 30, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flang-specs.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "4757dfbba2df0c21efc5e52e36b73ba6debe396f", "filename": "gcc/rust/test3/lang.opt", "status": "removed", "additions": 0, "deletions": 46, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Flang.opt?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "68dbc595910a93c7fd8b906448b1930d2431b822", "filename": "gcc/rust/test3/parse/rust-misc-convert.cc", "status": "removed", "additions": 0, "deletions": 37, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-misc-convert.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d38a07801cc0280c501b04ea6499d61f6403581e", "filename": "gcc/rust/test3/parse/rust-scope.cc", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-scope.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6318a50d31468955dfe42dd314696cd2aa2bf0ed", "filename": "gcc/rust/test3/parse/rust-tree.h", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Fparse%2Frust-tree.h?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8f16e6c052eed185896f73fdb96a3f6dc286e7c5", "filename": "gcc/rust/test3/rsspec.cc", "status": "removed", "additions": 0, "deletions": 358, "changes": 358, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frsspec.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Frust%2Ftest3%2Frsspec.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftest3%2Frsspec.cc?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ab395466afcf73a6f6f8637edf00d7091db5f7fd", "filename": "gcc/testsuite/rust.test/alias-uninit-value.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falias-uninit-value.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "873eb66e52e6f97e8503a6ba56e85c6f7589d060", "filename": "gcc/testsuite/rust.test/alignment-gep-tup-like-1.rs", "status": "removed", "additions": 0, "deletions": 42, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-1.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "7c43385ed616784f37278fff771004caba8fa859", "filename": "gcc/testsuite/rust.test/alignment-gep-tup-like-2.rs", "status": "removed", "additions": 0, "deletions": 61, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falignment-gep-tup-like-2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ddaa38223ecae07a9cb723c0ac9dc1d47d2575d3", "filename": "gcc/testsuite/rust.test/alloca-from-derived-tydesc.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Falloca-from-derived-tydesc.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "45e544cef8c8a21c74e2bd8577eb345d7d69e855", "filename": "gcc/testsuite/rust.test/anon-extern-mod-cross-crate-2.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod-cross-crate-2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "343e9b9b8ad1f103018198a25b0650b2ae5304cb", "filename": "gcc/testsuite/rust.test/anon-extern-mod.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-extern-mod.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "843e9436229ec67473ec8c4ece823c117da41325", "filename": "gcc/testsuite/rust.test/anon-trait-static-method.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon-trait-static-method.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5780a4e97aed62567b8d7a719e7255f267b5c106", "filename": "gcc/testsuite/rust.test/anon_trait_static_method_exe.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fanon_trait_static_method_exe.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6d6ae3da62fef1b599524d7be3e24bdcc865b2a2", "filename": "gcc/testsuite/rust.test/argument-passing.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fargument-passing.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9944241836b58241ed16ad68afff5d9773138290", "filename": "gcc/testsuite/rust.test/arith-0.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-0.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "db8f0eac4f6b38ca60d8e44663aefe33f04373af", "filename": "gcc/testsuite/rust.test/arith-1.rs", "status": "removed", "additions": 0, "deletions": 33, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-1.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "70df6e46e59d7c4c115214193bdaf126cb12cd55", "filename": "gcc/testsuite/rust.test/arith-2.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ae94ad379d01257d34ba66da107911fcd4389cf0", "filename": "gcc/testsuite/rust.test/arith-unsigned.rs", "status": "removed", "additions": 0, "deletions": 35, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Farith-unsigned.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "7bc1354c3cefe9ee817e8e401dc47c2e6cffd94a", "filename": "gcc/testsuite/rust.test/artificial-block.rs", "status": "removed", "additions": 0, "deletions": 13, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fartificial-block.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "2e1fc65d2baefce02b4fd968f1ce2fac836152b8", "filename": "gcc/testsuite/rust.test/asm-out-assign.rs", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fasm-out-assign.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "3ea1f896dff3125b745ba4c39e59060fbafb6fe3", "filename": "gcc/testsuite/rust.test/assert-approx-eq-macro-success.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassert-approx-eq-macro-success.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "047c339fafb3c85ccc6d0470b1bae09e32667c1b", "filename": "gcc/testsuite/rust.test/assert-eq-macro-success.rs", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassert-eq-macro-success.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "0f5d27015fb747a7709a6b3b908eeccf5a11eecb", "filename": "gcc/testsuite/rust.test/assign-assign.rs", "status": "removed", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassign-assign.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "5269f7dab5aad92570635f8608b7adf0924674b5", "filename": "gcc/testsuite/rust.test/assignability-trait.rs", "status": "removed", "additions": 0, "deletions": 53, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fassignability-trait.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "316f8fa0f61f439ae6ee70a5a4b5385a635fbd1c", "filename": "gcc/testsuite/rust.test/attr-before-view-item.rs", "status": "removed", "additions": 0, "deletions": 17, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "0721544aa0dc8a861c78362d69bef11a028ccaf9", "filename": "gcc/testsuite/rust.test/attr-before-view-item2.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-before-view-item2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6078698ebd6b6fa7046ee04bcea943964dba9222", "filename": "gcc/testsuite/rust.test/attr-main-2.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-main-2.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "10de96c2c5387f77f7cc7e4d710e8c13aa20d272", "filename": "gcc/testsuite/rust.test/attr-main.rs", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-main.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "48768a1c6fd27600f7c7707842d93a2bd3240162", "filename": "gcc/testsuite/rust.test/attr-no-drop-flag-size.rs", "status": "removed", "additions": 0, "deletions": 25, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-no-drop-flag-size.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "ca75af901295ce0a2c49906d27dc4506af3c5648", "filename": "gcc/testsuite/rust.test/attr-start.rs", "status": "removed", "additions": 0, "deletions": 16, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fattr-start.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "c1629851c5fb00224a47ea6df4618f120f1338f1", "filename": "gcc/testsuite/rust.test/auto-encode.rs", "status": "removed", "additions": 0, "deletions": 185, "changes": 185, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-encode.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d8399848e09e300b0ce33e153ded210d88f884bb", "filename": "gcc/testsuite/rust.test/auto-instantiate.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-instantiate.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "33aee55b8c7387a6c461af49ecc9a04b3ec7d6e7", "filename": "gcc/testsuite/rust.test/auto-loop.rs", "status": "removed", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-loop.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "bb01c27fa0d5c17490774cd27fadf6b52d4a090a", "filename": "gcc/testsuite/rust.test/auto-ref-bounded-ty-param.rs", "status": "removed", "additions": 0, "deletions": 40, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-bounded-ty-param.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8adc2cfd571906595a3322ca25cce7d602566eaf", "filename": "gcc/testsuite/rust.test/auto-ref-newtype.rs", "status": "removed", "additions": 0, "deletions": 23, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-newtype.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "d35341516f2a73d5b3ab86420cdd5e65587e2d9e", "filename": "gcc/testsuite/rust.test/auto-ref-slice-plus-ref.rs", "status": "removed", "additions": 0, "deletions": 43, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-slice-plus-ref.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "8e2b3b56736e2a1da329d3455583756c9c6025b7", "filename": "gcc/testsuite/rust.test/auto-ref-sliceable.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref-sliceable.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "6dc679054275fbe47206761b2f861be9611466e5", "filename": "gcc/testsuite/rust.test/auto-ref.rs", "status": "removed", "additions": 0, "deletions": 28, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fauto-ref.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "440ad723a12ce38ed34fa12a4223552c5e2569a6", "filename": "gcc/testsuite/rust.test/autobind.rs", "status": "removed", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautobind.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "fc643ec594089a4cc62f9eca2343f6e4afc6ee01", "filename": "gcc/testsuite/rust.test/autoderef-and-borrow-method-receiver.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-and-borrow-method-receiver.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "e3a19b23e91bf34ed25fcc646464ed12c1cf18bc", "filename": "gcc/testsuite/rust.test/autoderef-method-newtype.rs", "status": "removed", "additions": 0, "deletions": 24, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-newtype.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "9bc71517c1fb876463752e9b850141ab46a57fa3", "filename": "gcc/testsuite/rust.test/autoderef-method-on-trait.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-on-trait.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f9f78aa4882b415d785e319998a73a7996b0afe0", "filename": "gcc/testsuite/rust.test/autoderef-method-priority.rs", "status": "removed", "additions": 0, "deletions": 26, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-priority.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "299760289c2b3468a0c62a70863c725f1a47aba1", "filename": "gcc/testsuite/rust.test/autoderef-method-twice-but-not-thrice.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice-but-not-thrice.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "f93f0605269a443c70ea1df8613a75fc2104b16b", "filename": "gcc/testsuite/rust.test/autoderef-method-twice.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method-twice.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}, {"sha": "eb173e3d5f8ec2afa9928f3ec140b30b25bdadcc", "filename": "gcc/testsuite/rust.test/autoderef-method.rs", "status": "removed", "additions": 0, "deletions": 22, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9ccce9982b37580c6d1232cb6224b44c1f46a978/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fautoderef-method.rs?ref=9ccce9982b37580c6d1232cb6224b44c1f46a978"}]}