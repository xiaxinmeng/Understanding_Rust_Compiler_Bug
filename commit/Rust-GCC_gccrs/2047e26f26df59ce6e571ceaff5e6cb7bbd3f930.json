{"sha": "2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA0N2UyNmYyNmRmNTljZTZlNTcxY2VhZmY1ZTZjYjdiYmQzZjkzMA==", "commit": {"author": {"name": "Neil Booth", "email": "neilb@earthling.net", "date": "2000-09-21T18:01:22Z"}, "committer": {"name": "Neil Booth", "email": "neil@gcc.gnu.org", "date": "2000-09-21T18:01:22Z"}, "message": "cppfiles.c (lookup_include_file): Rename to open_file.\n\n\t* cppfiles.c (lookup_include_file): Rename to open_file.\n\tAlways create a splay tree value, even on syscall failures.\n\tNegative entries indicated by fd == -2.\n\tRe-open files closed in the meantime.\n\t(_cpp_fake_include): Create a negative splay tree entry.\n\t(find_include_file, cpp_read_file): Update for function name\n\tchange.\n\t* gcc.gd/cpp/mi4.c: Testcase.\n\nFrom-SVN: r36564", "tree": {"sha": "f92210f664cc3073db2b19b2e57ad36a07dae659", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f92210f664cc3073db2b19b2e57ad36a07dae659"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/comments", "author": null, "committer": null, "parents": [{"sha": "2359a5e1f978a43a821da7c814280fe34d33698d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2359a5e1f978a43a821da7c814280fe34d33698d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2359a5e1f978a43a821da7c814280fe34d33698d"}], "stats": {"total": 113, "additions": 74, "deletions": 39}, "files": [{"sha": "0d11086ea96cf3c78fa21ada58580aaa55e65e62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "patch": "@@ -1,3 +1,14 @@\n+Thu 21-Sep-2000 18:19:05 BST  Neil Booth  <NeilB@earthling.net>\n+\n+\t* cppfiles.c (lookup_include_file): Rename to open_file.\n+\tAlways create a splay tree value, even on syscall failures.\n+\tNegative entries indicated by fd == -2.\n+\tRe-open files closed in the meantime.\n+\t(_cpp_fake_include): Create a negative splay tree entry.\n+\t(find_include_file, cpp_read_file): Update for function name\n+\tchange.\n+\t* gcc.gd/cpp/mi4.c: Testcase.\n+\n 2000-09-21  Nick Clifton  <nickc@redhat.com>\n \n \t* config/arm/t-arm-elf (MULTILIB_DIRNAMES): Enable multilibs for"}, {"sha": "3110f00720711a001ec1936005cf7c5321974b16", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 53, "deletions": 39, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "patch": "@@ -73,8 +73,7 @@ static struct file_name_list *actual_directory\n static struct include_file *find_include_file\n \t\t\t\tPARAMS ((cpp_reader *, const char *,\n \t\t\t\t\t struct file_name_list *));\n-static struct include_file *lookup_include_file\n-\t\t\t\tPARAMS ((cpp_reader *, const char *));\n+static struct include_file *open_file PARAMS ((cpp_reader *, const char *));\n static int read_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static int stack_include_file\tPARAMS ((cpp_reader *, struct include_file *));\n static void purge_cache \tPARAMS ((struct include_file *));\n@@ -98,7 +97,7 @@ destroy_include_file_node (v)\n   if (f)\n     {\n       purge_cache (f);\n-      free (f);\n+      free (f);  /* The tree is registered with free to free f->name.  */\n     }\n }\n \n@@ -120,23 +119,44 @@ _cpp_cleanup_includes (pfile)\n }\n \n /* Given a file name, look it up in the cache; if there is no entry,\n-   create one.  Returns 0 if the file doesn't exist or is\n-   inaccessible, otherwise the cache entry.  */\n+   create one with a non-NULL value (regardless of success in opening\n+   the file).  If the file doesn't exist or is inaccessible, this\n+   entry is flagged so we don't attempt to open it again in the\n+   future.  If the file isn't open, open it.\n+\n+   Returns an include_file structure with an open file descriptor on\n+   success, or NULL on failure.  */\n \n static struct include_file *\n-lookup_include_file (pfile, filename)\n+open_file (pfile, filename)\n      cpp_reader *pfile;\n      const char *filename;\n-{     \n+{\n   splay_tree_node nd;\n-  struct include_file *file = 0;\n-  int fd;\n-  struct stat st;\n+  struct include_file *file;\n \n   nd = splay_tree_lookup (pfile->all_include_files, (splay_tree_key) filename);\n \n   if (nd)\n-    return (struct include_file *)nd->value;\n+    {\n+      file = (struct include_file *) nd->value;\n+\n+      /* Don't retry opening if we failed previously.  */\n+      if (file->fd == -2)\n+\treturn 0;\n+\n+      /* -1 indicates a file we've opened previously, and since closed.  */\n+      if (file->fd != -1)\n+\treturn file;\n+    }\n+  else\n+    {\n+      file = xcnew (struct include_file);\n+      file->name = xstrdup (filename);\n+      splay_tree_insert (pfile->all_include_files,\n+\t\t\t (splay_tree_key) file->name,\n+\t\t\t (splay_tree_value) file);\n+    }\n \n   /* We used to open files in nonblocking mode, but that caused more\n      problems than it solved.  Do take care not to acquire a\n@@ -153,37 +173,26 @@ lookup_include_file (pfile, filename)\n      Special case: the empty string is translated to stdin.  */\n \n   if (filename[0] == '\\0')\n-    fd = 0;\n+    file->fd = 0;\n   else\n-    fd = open (filename, O_RDONLY|O_NOCTTY|O_BINARY, 0666);\n-  if (fd == -1)\n-    goto fail;\n+    file->fd = open (filename, O_RDONLY | O_NOCTTY | O_BINARY, 0666);\n \n-  if (fstat (fd, &st) < 0)\n-    goto fail;\n-  \n-  file = xcnew (struct include_file);\n-  file->name = xstrdup (filename);\n-  file->st = st;\n-  file->fd = fd;\n-\n-  /* If the file is plain and zero length, mark it never-reread now.  */\n-  if (S_ISREG (st.st_mode) && st.st_size == 0)\n-    file->cmacro = NEVER_REREAD;\n-\n-  splay_tree_insert (pfile->all_include_files,\n-\t\t     (splay_tree_key) file->name, (splay_tree_value) file);\n-  return file;\n+  if (file->fd != -1 && fstat (file->fd, &file->st) == 0)\n+    {\n+      /* Mark a regular, zero-length file never-reread now.  */\n+      if (S_ISREG (file->st.st_mode) && file->st.st_size == 0)\n+\tfile->cmacro = NEVER_REREAD;\n \n- fail:\n+      return file;\n+    }\n \n   /* Don't issue an error message if the file doesn't exist.  */\n   if (errno != ENOENT && errno != ENOTDIR)\n     cpp_error_from_errno (pfile, filename);\n \n-  /* Create a negative node for this path.  */\n-  splay_tree_insert (pfile->all_include_files,\n-\t\t     (splay_tree_key) xstrdup (filename), 0);\n+  /* Create a negative node for this path, and return null.  */\n+  file->fd = -2;\n+\n   return 0;\n }\n \n@@ -419,7 +428,7 @@ find_include_file (pfile, fname, search_start)\n   struct include_file *file;\n \n   if (fname[0] == '/')\n-    return lookup_include_file (pfile, fname);\n+    return open_file (pfile, fname);\n       \n   /* Search directory path for the file.  */\n   name = (char *) alloca (strlen (fname) + pfile->max_include_len\n@@ -433,7 +442,7 @@ find_include_file (pfile, fname, search_start)\n       if (CPP_OPTION (pfile, remap))\n \tname = remap_filename (pfile, name, path);\n \n-      file = lookup_include_file (pfile, name);\n+      file = open_file (pfile, name);\n       if (file)\n \t{\n \t  file->sysp = path->sysp;\n@@ -479,8 +488,13 @@ _cpp_fake_include (pfile, fname)\n       return (const char *) nd->key;\n     }\n \n-  splay_tree_insert (pfile->all_include_files, (splay_tree_key) name, 0);\n-  return (const char *)name;\n+  file = xcnew (struct include_file);\n+  file->name = name;\n+  file->fd = -2;\n+  splay_tree_insert (pfile->all_include_files, (splay_tree_key) name,\n+\t\t     (splay_tree_value) file);\n+\n+  return file->name;\n }\n \n /* Not everyone who wants to set system-header-ness on a buffer can\n@@ -701,7 +715,7 @@ cpp_read_file (pfile, fname)\n   if (fname == NULL)\n     fname = \"\";\n \n-  f = lookup_include_file (pfile, fname);\n+  f = open_file (pfile, fname);\n \n   if (f == NULL)\n     {"}, {"sha": "c886cc2c8e5a1a78475b351157f0a092dafd5f03", "filename": "gcc/testsuite/gcc.dg/cpp/mi4.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmi4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2047e26f26df59ce6e571ceaff5e6cb7bbd3f930/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmi4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcpp%2Fmi4.c?ref=2047e26f26df59ce6e571ceaff5e6cb7bbd3f930", "patch": "@@ -0,0 +1,10 @@\n+/* Copyright (C) 2000 Free Software Foundation, Inc.  */\n+\n+/* { dg-do preprocess } */\n+\n+/* Undefining a macro guard and re-including the file used to confuse\n+   file caching in cppfiles.c, and attempt to open a bad fd.  */\n+\n+#include \"mi1c.h\"\n+#undef CPP_MIC_H\n+#include \"mi1c.h\""}]}