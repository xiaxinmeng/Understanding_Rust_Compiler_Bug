{"sha": "7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NkYzY3MmI3N2I0N2M5YzQ3OTRlZDliMjRiOGRjOTIzZWEzNmJhYg==", "commit": {"author": {"name": "Matthew Heaney", "email": "heaney@adacore.com", "date": "2005-12-09T17:16:22Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2005-12-09T17:16:22Z"}, "message": "a-convec.adb (Merge): Added assertions to check whether vector params are sorted.\n\n2005-12-05  Matthew Heaney  <heaney@adacore.com>\n\n\t* a-convec.adb (Merge): Added assertions to check whether vector params\n\tare sorted.\n\n\t* a-coinve.adb (Merge): Added assertions to check whether vector params\n\tare sorted.\n\n\t* a-cohama.ads (Cursor'Write): raises Program_Error per latest AI-302\n\tdraft.\n\t(Cursor'Read): raises PE\n\n\t* a-cohama.adb (Insert.New_Node): Uses box-style syntax to init elem\n\tto its default value.\n\n\t* a-cihama.adb: Manually check whether cursor's key and elem are\n\tnon-null\n\n\t* a-cidlli.ads, a-cidlli.adb (Splice): Changed param name and param mode\n\t(Merge): Assert that target and source lists are in order\n\t(Swap): Declare non-const temporaries, to pass to Splice\n\n\t* a-cdlili.ads: (Splice): Changed param name and param mode\n\n\t* a-cdlili.adb: (Splice): Changed param name and param mode\n\t(Merge): Assert that target and source lists are in order\n\t(Swap): Declare non-const temporaries, to pass to Splice\n\n\t* a-ciorma.ads, a-coorma.ads: (Read): declare Stream param as not null\n\t(Write): declare Stream param as not null\n\n\t* a-ciorma.adb, a-coorma.adb: All explicit raise statements now include\n\tan exception message.\n\nFrom-SVN: r108287", "tree": {"sha": "3d8042f676028733216495b35bc6bac0d717a751", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3d8042f676028733216495b35bc6bac0d717a751"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/comments", "author": null, "committer": null, "parents": [{"sha": "9582a3cd55cfe9218f3fd8c80808d816c8774897", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9582a3cd55cfe9218f3fd8c80808d816c8774897", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9582a3cd55cfe9218f3fd8c80808d816c8774897"}], "stats": {"total": 584, "additions": 351, "deletions": 233}, "files": [{"sha": "c6d7dbff0fe9388e71baa85aa9bcd3f584cc97e0", "filename": "gcc/ada/a-cdlili.adb", "status": "modified", "additions": 46, "deletions": 36, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cdlili.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cdlili.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -466,11 +466,19 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          end if;\n \n          while RI.Node /= null loop\n+            pragma Assert (RI.Node.Next = null\n+                             or else not (RI.Node.Next.Element <\n+                                          RI.Node.Element));\n+\n             if LI.Node = null then\n                Splice (Target, No_Element, Source);\n                return;\n             end if;\n \n+            pragma Assert (LI.Node.Next = null\n+                             or else not (LI.Node.Next.Element <\n+                                          LI.Node.Element));\n+\n             if RI.Node.Element < LI.Node.Element then\n                declare\n                   RJ : Cursor := RI;\n@@ -1289,13 +1297,13 @@ package body Ada.Containers.Doubly_Linked_Lists is\n    end Splice;\n \n    procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Position : Cursor)\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor)\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Target'Unchecked_Access then\n+         if Before.Container /= Container'Unchecked_Access then\n             raise Program_Error;\n          end if;\n \n@@ -1306,7 +1314,7 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          raise Constraint_Error;\n       end if;\n \n-      if Position.Container /= Target'Unrestricted_Access then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n@@ -1318,59 +1326,59 @@ package body Ada.Containers.Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Target.Length >= 2);\n+      pragma Assert (Container.Length >= 2);\n \n-      if Target.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n \n       if Before.Node = null then\n-         pragma Assert (Position.Node /= Target.Last);\n+         pragma Assert (Position.Node /= Container.Last);\n \n-         if Position.Node = Target.First then\n-            Target.First := Position.Node.Next;\n-            Target.First.Prev := null;\n+         if Position.Node = Container.First then\n+            Container.First := Position.Node.Next;\n+            Container.First.Prev := null;\n          else\n             Position.Node.Prev.Next := Position.Node.Next;\n             Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.Last.Next := Position.Node;\n-         Position.Node.Prev := Target.Last;\n+         Container.Last.Next := Position.Node;\n+         Position.Node.Prev := Container.Last;\n \n-         Target.Last := Position.Node;\n-         Target.Last.Next := null;\n+         Container.Last := Position.Node;\n+         Container.Last.Next := null;\n \n          return;\n       end if;\n \n-      if Before.Node = Target.First then\n-         pragma Assert (Position.Node /= Target.First);\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n \n-         if Position.Node = Target.Last then\n-            Target.Last := Position.Node.Prev;\n-            Target.Last.Next := null;\n+         if Position.Node = Container.Last then\n+            Container.Last := Position.Node.Prev;\n+            Container.Last.Next := null;\n          else\n             Position.Node.Prev.Next := Position.Node.Next;\n             Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.First.Prev := Position.Node;\n-         Position.Node.Next := Target.First;\n+         Container.First.Prev := Position.Node;\n+         Position.Node.Next := Container.First;\n \n-         Target.First := Position.Node;\n-         Target.First.Prev := null;\n+         Container.First := Position.Node;\n+         Container.First.Prev := null;\n \n          return;\n       end if;\n \n-      if Position.Node = Target.First then\n-         Target.First := Position.Node.Next;\n-         Target.First.Prev := null;\n+      if Position.Node = Container.First then\n+         Container.First := Position.Node.Next;\n+         Container.First.Prev := null;\n \n-      elsif Position.Node = Target.Last then\n-         Target.Last := Position.Node.Prev;\n-         Target.Last.Next := null;\n+      elsif Position.Node = Container.Last then\n+         Container.Last := Position.Node.Prev;\n+         Container.Last.Next := null;\n \n       else\n          Position.Node.Prev.Next := Position.Node.Next;\n@@ -1383,8 +1391,8 @@ package body Ada.Containers.Doubly_Linked_Lists is\n       Before.Node.Prev := Position.Node;\n       Position.Node.Next := Before.Node;\n \n-      pragma Assert (Target.First.Prev = null);\n-      pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n    end Splice;\n \n    procedure Splice\n@@ -1570,24 +1578,26 @@ package body Ada.Containers.Doubly_Linked_Lists is\n \n       declare\n          I_Next : constant Cursor := Next (I);\n+         J_Copy : Cursor := J;\n \n       begin\n          if I_Next = J then\n-            Splice (Container, Before => I, Position => J);\n+            Splice (Container, Before => I, Position => J_Copy);\n \n          else\n             declare\n                J_Next : constant Cursor := Next (J);\n+               I_Copy : Cursor := I;\n \n             begin\n                if J_Next = I then\n-                  Splice (Container, Before => J, Position => I);\n+                  Splice (Container, Before => J, Position => I_Copy);\n \n                else\n                   pragma Assert (Container.Length >= 3);\n \n-                  Splice (Container, Before => I_Next, Position => J);\n-                  Splice (Container, Before => J_Next, Position => I);\n+                  Splice (Container, Before => I_Next, Position => J_Copy);\n+                  Splice (Container, Before => J_Next, Position => I_Copy);\n                end if;\n             end;\n          end if;"}, {"sha": "41f8606079b511f5ba616315445e97d28cf8549b", "filename": "gcc/ada/a-cdlili.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cdlili.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cdlili.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cdlili.ads?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -145,9 +145,9 @@ package Ada.Containers.Doubly_Linked_Lists is\n       Position : in out Cursor);\n \n    procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Position : Cursor);\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor);\n \n    function First (Container : List) return Cursor;\n "}, {"sha": "0752f9fa09c6ae884c4334f4ec634918d5c7cab5", "filename": "gcc/ada/a-cidlli.adb", "status": "modified", "additions": 47, "deletions": 36, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cidlli.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cidlli.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -514,11 +514,19 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          LI := First (Target);\n          RI := First (Source);\n          while RI.Node /= null loop\n+            pragma Assert (RI.Node.Next = null\n+                             or else not (RI.Node.Next.Element.all <\n+                                          RI.Node.Element.all));\n+\n             if LI.Node = null then\n                Splice (Target, No_Element, Source);\n                return;\n             end if;\n \n+            pragma Assert (LI.Node.Next = null\n+                             or else not (LI.Node.Next.Element.all <\n+                                          LI.Node.Element.all));\n+\n             if RI.Node.Element.all < LI.Node.Element.all then\n                declare\n                   RJ : Cursor := RI;\n@@ -1333,13 +1341,13 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n    end Splice;\n \n    procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Position : Cursor)\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor)\n    is\n    begin\n       if Before.Container /= null then\n-         if Before.Container /= Target'Unchecked_Access then\n+         if Before.Container /= Container'Unchecked_Access then\n             raise Program_Error;\n          end if;\n \n@@ -1360,7 +1368,7 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          raise Program_Error;\n       end if;\n \n-      if Position.Container /= Target'Unrestricted_Access then\n+      if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n \n@@ -1372,59 +1380,59 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n          return;\n       end if;\n \n-      pragma Assert (Target.Length >= 2);\n+      pragma Assert (Container.Length >= 2);\n \n-      if Target.Busy > 0 then\n+      if Container.Busy > 0 then\n          raise Program_Error;\n       end if;\n \n       if Before.Node = null then\n-         pragma Assert (Position.Node /= Target.Last);\n+         pragma Assert (Position.Node /= Container.Last);\n \n-         if Position.Node = Target.First then\n-            Target.First := Position.Node.Next;\n-            Target.First.Prev := null;\n+         if Position.Node = Container.First then\n+            Container.First := Position.Node.Next;\n+            Container.First.Prev := null;\n          else\n             Position.Node.Prev.Next := Position.Node.Next;\n             Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.Last.Next := Position.Node;\n-         Position.Node.Prev := Target.Last;\n+         Container.Last.Next := Position.Node;\n+         Position.Node.Prev := Container.Last;\n \n-         Target.Last := Position.Node;\n-         Target.Last.Next := null;\n+         Container.Last := Position.Node;\n+         Container.Last.Next := null;\n \n          return;\n       end if;\n \n-      if Before.Node = Target.First then\n-         pragma Assert (Position.Node /= Target.First);\n+      if Before.Node = Container.First then\n+         pragma Assert (Position.Node /= Container.First);\n \n-         if Position.Node = Target.Last then\n-            Target.Last := Position.Node.Prev;\n-            Target.Last.Next := null;\n+         if Position.Node = Container.Last then\n+            Container.Last := Position.Node.Prev;\n+            Container.Last.Next := null;\n          else\n             Position.Node.Prev.Next := Position.Node.Next;\n             Position.Node.Next.Prev := Position.Node.Prev;\n          end if;\n \n-         Target.First.Prev := Position.Node;\n-         Position.Node.Next := Target.First;\n+         Container.First.Prev := Position.Node;\n+         Position.Node.Next := Container.First;\n \n-         Target.First := Position.Node;\n-         Target.First.Prev := null;\n+         Container.First := Position.Node;\n+         Container.First.Prev := null;\n \n          return;\n       end if;\n \n-      if Position.Node = Target.First then\n-         Target.First := Position.Node.Next;\n-         Target.First.Prev := null;\n+      if Position.Node = Container.First then\n+         Container.First := Position.Node.Next;\n+         Container.First.Prev := null;\n \n-      elsif Position.Node = Target.Last then\n-         Target.Last := Position.Node.Prev;\n-         Target.Last.Next := null;\n+      elsif Position.Node = Container.Last then\n+         Container.Last := Position.Node.Prev;\n+         Container.Last.Next := null;\n \n       else\n          Position.Node.Prev.Next := Position.Node.Next;\n@@ -1437,8 +1445,8 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Before.Node.Prev := Position.Node;\n       Position.Node.Next := Before.Node;\n \n-      pragma Assert (Target.First.Prev = null);\n-      pragma Assert (Target.Last.Next = null);\n+      pragma Assert (Container.First.Prev = null);\n+      pragma Assert (Container.Last.Next = null);\n    end Splice;\n \n    procedure Splice\n@@ -1631,23 +1639,26 @@ package body Ada.Containers.Indefinite_Doubly_Linked_Lists is\n \n       declare\n          I_Next : constant Cursor := Next (I);\n+         J_Copy : Cursor := J;\n \n       begin\n          if I_Next = J then\n-            Splice (Container, Before => I, Position => J);\n+            Splice (Container, Before => I, Position => J_Copy);\n \n          else\n             declare\n                J_Next : constant Cursor := Next (J);\n+               I_Copy : Cursor := I;\n+\n             begin\n                if J_Next = I then\n-                  Splice (Container, Before => J, Position => I);\n+                  Splice (Container, Before => J, Position => I_Copy);\n \n                else\n                   pragma Assert (Container.Length >= 3);\n \n-                  Splice (Container, Before => I_Next, Position => J);\n-                  Splice (Container, Before => J_Next, Position => I);\n+                  Splice (Container, Before => I_Next, Position => J_Copy);\n+                  Splice (Container, Before => J_Next, Position => I_Copy);\n                end if;\n             end;\n          end if;"}, {"sha": "e6fbf7694cff2b7a44e03e84b2332985f30b4374", "filename": "gcc/ada/a-cidlli.ads", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cidlli.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cidlli.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cidlli.ads?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -136,9 +136,9 @@ package Ada.Containers.Indefinite_Doubly_Linked_Lists is\n       Position : in out Cursor);\n \n    procedure Splice\n-     (Target   : in out List;\n-      Before   : Cursor;\n-      Position : Cursor);\n+     (Container : in out List;\n+      Before    : Cursor;\n+      Position  : in out Cursor);\n \n    function First (Container : List) return Cursor;\n "}, {"sha": "3a78e8eab0da3321672ffb7af9a2b3f1cbdd130a", "filename": "gcc/ada/a-cihama.adb", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cihama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cihama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cihama.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -237,6 +237,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Element = null then\n+         raise Program_Error;\n+      end if;\n+\n       return Position.Node.Element.all;\n    end Element;\n \n@@ -267,6 +271,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Left.Node.Key = null\n+        or else Right.Node.Key = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -281,6 +291,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Left.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left.Node.Key.all, Right);\n    end Equivalent_Keys;\n \n@@ -295,6 +309,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Right.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n       return Equivalent_Keys (Left, Right.Node.Key.all);\n    end Equivalent_Keys;\n \n@@ -595,6 +613,10 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Key = null then\n+         raise Program_Error;\n+      end if;\n+\n       return Position.Node.Key.all;\n    end Key;\n \n@@ -641,6 +663,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          return No_Element;\n       end if;\n \n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          HT   : Hash_Table_Type renames Position.Container.HT;\n          Node : constant Node_Access := HT_Ops.Next (HT, Position.Node);\n@@ -670,6 +698,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       declare\n          M  : Map renames Position.Container.all;\n          HT : Hash_Table_Type renames M.HT'Unrestricted_Access.all;\n@@ -807,6 +841,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;\n@@ -862,6 +902,12 @@ package body Ada.Containers.Indefinite_Hashed_Maps is\n          raise Constraint_Error;\n       end if;\n \n+      if Position.Node.Key = null\n+        or else Position.Node.Element = null\n+      then\n+         raise Program_Error;\n+      end if;\n+\n       if Position.Container /= Container'Unrestricted_Access then\n          raise Program_Error;\n       end if;"}, {"sha": "fda5c3971de103f6d4b6695277ac10c54d074fe4", "filename": "gcc/ada/a-ciorma.adb", "status": "modified", "additions": 97, "deletions": 72, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-ciorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-ciorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -135,55 +135,59 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null\n-        or else Right.Node.Key = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Key = null then\n+         raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n+      end if;\n+\n+      if Right.Node.Key = null then\n+         raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\"<\"\"\");\n+                     \"Left cursor in \"\"<\"\" is bad\");\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\"<\"\"\");\n+                     \"Right cursor in \"\"<\"\" is bad\");\n \n       return Left.Node.Key.all < Right.Node.Key.all;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n       if Left.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\"<\"\"\");\n+                     \"Left cursor in \"\"<\"\" is bad\");\n \n       return Left.Node.Key.all < Right;\n    end \"<\";\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n       if Right.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\"<\"\"\");\n+                     \"Right cursor in \"\"<\"\" is bad\");\n \n       return Left < Right.Node.Key.all;\n    end \"<\";\n@@ -203,55 +207,59 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n-      if Left.Node.Key = null\n-        or else Right.Node.Key = null\n-      then\n-         raise Program_Error;\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      if Left.Node.Key = null then\n+         raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n+      end if;\n+\n+      if Right.Node.Key = null then\n+         raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\">\"\"\");\n+                     \"Left cursor in \"\">\"\" is bad\");\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\">\"\"\");\n+                     \"Right cursor in \"\">\"\" is bad\");\n \n       return Right.Node.Key.all < Left.Node.Key.all;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n       if Left.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Left cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\">\"\"\");\n+                     \"Left cursor in \"\">\"\" is bad\");\n \n       return Right < Left.Node.Key.all;\n    end \">\";\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n       if Right.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with \"Right cursor in \"\"<\"\" is bad\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\">\"\"\");\n+                     \"Right cursor in \"\">\"\" is bad\");\n \n       return Right.Node.Key.all < Left;\n    end \">\";\n@@ -346,21 +354,23 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with \"Position cursor of Delete is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n-                     \"bad cursor in Delete\");\n+                     \"Position cursor of Delete is bad\");\n \n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, Position.Node);\n       Free (Position.Node);\n@@ -373,7 +383,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       Delete_Node_Sans_Free (Container.Tree, X);\n@@ -415,15 +425,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n       end if;\n \n       if Position.Node.Element = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of function Element is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Element\");\n+                     \"Position cursor of function Element is bad\");\n \n       return Position.Node.Element.all;\n    end Element;\n@@ -433,7 +445,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       return Node.Element.all;\n@@ -507,7 +519,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if T.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.First.Element.all;\n@@ -522,7 +534,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if T.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.First.Key.all;\n@@ -619,7 +631,8 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n       if not Inserted then\n          if Container.Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (map is locked)\";\n          end if;\n \n          K := Position.Node.Key;\n@@ -706,7 +719,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key already in map\";\n       end if;\n    end Insert;\n \n@@ -810,15 +823,17 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    function Key (Position : Cursor) return Key_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of function Key is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Key\");\n+                     \"Position cursor of function Key is bad\");\n \n       return Position.Node.Key.all;\n    end Key;\n@@ -847,7 +862,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if T.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.Last.Element.all;\n@@ -862,7 +877,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if T.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.Last.Key.all;\n@@ -912,7 +927,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       pragma Assert (Position.Node.Key /= null);\n       pragma Assert (Position.Node.Element /= null);\n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Next\");\n+                     \"Position cursor of Next is bad\");\n \n       declare\n          Node : constant Node_Access :=\n@@ -955,7 +970,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n       pragma Assert (Position.Node.Key /= null);\n       pragma Assert (Position.Node.Element /= null);\n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Previous\");\n+                     \"Position cursor of Previous is bad\");\n \n       declare\n          Node : constant Node_Access :=\n@@ -986,17 +1001,19 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Query_Element is bad\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Query_Element\");\n+                     \"Position cursor of Query_Element is bad\");\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n@@ -1031,7 +1048,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    ----------\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Map)\n    is\n       function Read_Node\n@@ -1066,11 +1083,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    end Read;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Read;\n \n    -------------\n@@ -1090,11 +1107,12 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (map is locked)\";\n       end if;\n \n       K := Node.Key;\n@@ -1125,25 +1143,29 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (map is locked)\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n-                     \"bad cursor in Replace_Element\");\n+                     \"Position cursor of Replace_Element is bad\");\n \n       declare\n          X : Element_Access := Position.Node.Element;\n@@ -1252,21 +1274,24 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n       if Position.Node.Key = null\n         or else Position.Node.Element = null\n       then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element is bad\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n-                     \"bad cursor in Update_Element\");\n+                     \"Position cursor of Update_Element is bad\");\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n@@ -1301,7 +1326,7 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    -----------\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Map)\n    is\n       procedure Write_Node\n@@ -1332,11 +1357,11 @@ package body Ada.Containers.Indefinite_Ordered_Maps is\n    end Write;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Write;\n \n end Ada.Containers.Indefinite_Ordered_Maps;"}, {"sha": "7d16b2b4c1a21ac7ee1233a8277e0cdea1cdac9e", "filename": "gcc/ada/a-ciorma.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-ciorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-ciorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ciorma.ads?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -215,27 +215,27 @@ private\n    end record;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n \n    for Cursor'Write use Write;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);\n \n    for Cursor'Read use Read;\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Map);\n \n    for Map'Write use Write;\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Map);\n \n    for Map'Read use Read;"}, {"sha": "a29784bdb451cd542aa573e6e3f60a44bfba0f60", "filename": "gcc/ada/a-cohama.adb", "status": "modified", "additions": 4, "deletions": 13, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cohama.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cohama.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -438,18 +438,10 @@ package body Ada.Containers.Hashed_Maps is\n       --------------\n \n       function New_Node (Next : Node_Access) return Node_Access is\n-         Node : Node_Access := new Node_Type; --  Ada 2005 aggregate possible?\n-\n       begin\n-         Node.Key := Key;\n-         Node.Next := Next;\n-\n-         return Node;\n-\n-      exception\n-         when others =>\n-            Free (Node);\n-            raise;\n+         return new Node_Type'(Key     => Key,\n+                               Element => <>,\n+                               Next    => Next);\n       end New_Node;\n \n       HT : Hash_Table_Type renames Container.HT;\n@@ -490,9 +482,8 @@ package body Ada.Containers.Hashed_Maps is\n       --------------\n \n       function New_Node (Next : Node_Access) return Node_Access is\n-         Node : constant Node_Access := new Node_Type'(Key, New_Item, Next);\n       begin\n-         return Node;\n+         return new Node_Type'(Key, New_Item, Next);\n       end New_Node;\n \n       HT : Hash_Table_Type renames Container.HT;"}, {"sha": "d65401f01ebf129a60c2ff725a074f54e4069dff", "filename": "gcc/ada/a-cohama.ads", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cohama.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-cohama.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-cohama.ads?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -212,18 +212,18 @@ private\n          Node      : Node_Access;\n       end record;\n \n-   procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n-      Item   : Cursor);\n-\n-   for Cursor'Write use Write;\n-\n    procedure Read\n      (Stream : access Root_Stream_Type'Class;\n       Item   : out Cursor);\n \n    for Cursor'Read use Read;\n \n+   procedure Write\n+     (Stream : access Root_Stream_Type'Class;\n+      Item   : Cursor);\n+\n+   for Cursor'Write use Write;\n+\n    No_Element : constant Cursor := (Container => null, Node => null);\n \n end Ada.Containers.Hashed_Maps;"}, {"sha": "6aee444e1b03c3a2c44df79ac6c4f09be13f9069", "filename": "gcc/ada/a-coinve.adb", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coinve.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coinve.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coinve.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -895,6 +895,12 @@ package body Ada.Containers.Indefinite_Vectors is\n \n          J := Target.Last;\n          while Source.Last >= Index_Type'First loop\n+            pragma Assert\n+              (Source.Last <= Index_Type'First\n+                 or else not (Is_Less\n+                                (Source.Elements (Source.Last),\n+                                 Source.Elements (Source.Last - 1))));\n+\n             if I < Index_Type'First then\n                declare\n                   Src : Elements_Type renames\n@@ -909,6 +915,12 @@ package body Ada.Containers.Indefinite_Vectors is\n                return;\n             end if;\n \n+            pragma Assert\n+              (I <= Index_Type'First\n+                 or else not (Is_Less\n+                                (Target.Elements (I),\n+                                 Target.Elements (I - 1))));\n+\n             declare\n                Src : Element_Access renames Source.Elements (Source.Last);\n                Tgt : Element_Access renames Target.Elements (I);"}, {"sha": "2a60303474975bb0ec8bfcaab88af4a8820f0a58", "filename": "gcc/ada/a-convec.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-convec.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-convec.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-convec.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -660,6 +660,10 @@ package body Ada.Containers.Vectors is\n \n          J := Target.Last;\n          while Source.Last >= Index_Type'First loop\n+            pragma Assert (Source.Last <= Index_Type'First\n+                             or else not (Source.Elements (Source.Last) <\n+                                          Source.Elements (Source.Last - 1)));\n+\n             if I < Index_Type'First then\n                Target.Elements (Index_Type'First .. J) :=\n                  Source.Elements (Index_Type'First .. Source.Last);\n@@ -668,6 +672,10 @@ package body Ada.Containers.Vectors is\n                return;\n             end if;\n \n+            pragma Assert (I <= Index_Type'First\n+                             or else not (Target.Elements (I) <\n+                                          Target.Elements (I - 1)));\n+\n             if Source.Elements (Source.Last) < Target.Elements (I) then\n                Target.Elements (J) := Target.Elements (I);\n                I := I - 1;\n@@ -1923,7 +1931,6 @@ package body Ada.Containers.Vectors is\n       B : Natural renames V.Busy;\n \n    begin\n-\n       B := B + 1;\n \n       begin\n@@ -1937,7 +1944,6 @@ package body Ada.Containers.Vectors is\n       end;\n \n       B := B - 1;\n-\n    end Reverse_Iterate;\n \n    ----------------"}, {"sha": "95b8796c8d42ea15d8133a4046cf4a282d8df1da", "filename": "gcc/ada/a-coorma.adb", "status": "modified", "additions": 71, "deletions": 54, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coorma.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coorma.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.adb?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -127,41 +127,43 @@ package body Ada.Containers.Ordered_Maps is\n \n    function \"<\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\"<\"\"\");\n+                     \"Left cursor of \"\"<\"\" is bad\");\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\"<\"\"\");\n+                     \"Right cursor of \"\"<\"\" is bad\");\n \n       return Left.Node.Key < Right.Node.Key;\n    end \"<\";\n \n    function \"<\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\"<\"\"\");\n+                     \"Left cursor of \"\"<\"\" is bad\");\n \n       return Left.Node.Key < Right;\n    end \"<\";\n \n    function \"<\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor of \"\"<\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\"<\"\"\");\n+                     \"Right cursor of \"\"<\"\" is bad\");\n \n       return Left < Right.Node.Key;\n    end \"<\";\n@@ -181,41 +183,43 @@ package body Ada.Containers.Ordered_Maps is\n \n    function \">\" (Left, Right : Cursor) return Boolean is\n    begin\n-      if Left.Node = null\n-        or else Right.Node = null\n-      then\n-         raise Constraint_Error;\n+      if Left.Node = null then\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n+      end if;\n+\n+      if Right.Node = null then\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\">\"\"\");\n+                     \"Left cursor of \"\">\"\" is bad\");\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\">\"\"\");\n+                     \"Right cursor of \"\">\"\" is bad\");\n \n       return Right.Node.Key < Left.Node.Key;\n    end \">\";\n \n    function \">\" (Left : Cursor; Right : Key_Type) return Boolean is\n    begin\n       if Left.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Left cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Left.Container.Tree, Left.Node),\n-                     \"bad Left cursor in \"\">\"\"\");\n+                     \"Left cursor of \"\">\"\" is bad\");\n \n       return Right < Left.Node.Key;\n    end \">\";\n \n    function \">\" (Left : Key_Type; Right : Cursor) return Boolean is\n    begin\n       if Right.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"Right cursor of \"\">\"\" equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Right.Container.Tree, Right.Node),\n-                     \"bad Right cursor in \"\">\"\"\");\n+                     \"Right cursor of \"\">\"\" is bad\");\n \n       return Right.Node.Key < Left;\n    end \">\";\n@@ -302,14 +306,17 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Delete equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Delete designates wrong map\";\n       end if;\n \n-      pragma Assert (Vet (Tree, Position.Node), \"bad cursor in Delete\");\n+      pragma Assert (Vet (Tree, Position.Node),\n+                     \"Position cursor of Delete is bad\");\n \n       Tree_Operations.Delete_Node_Sans_Free (Tree, Position.Node);\n       Free (Position.Node);\n@@ -322,7 +329,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if X = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       Tree_Operations.Delete_Node_Sans_Free (Container.Tree, X);\n@@ -364,11 +371,12 @@ package body Ada.Containers.Ordered_Maps is\n    function Element (Position : Cursor) return Element_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Element equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Element\");\n+                     \"Position cursor of function Element is bad\");\n \n       return Position.Node.Element;\n    end Element;\n@@ -378,7 +386,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       return Node.Element;\n@@ -452,7 +460,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if T.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.First.Element;\n@@ -467,7 +475,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if T.First = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.First.Key;\n@@ -534,7 +542,8 @@ package body Ada.Containers.Ordered_Maps is\n \n       if not Inserted then\n          if Container.Tree.Lock > 0 then\n-            raise Program_Error;\n+            raise Program_Error with\n+              \"attempt to tamper with cursors (map is locked)\";\n          end if;\n \n          Position.Node.Key := Key;\n@@ -596,7 +605,7 @@ package body Ada.Containers.Ordered_Maps is\n       Insert (Container, Key, New_Item, Position, Inserted);\n \n       if not Inserted then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key already in map\";\n       end if;\n    end Insert;\n \n@@ -746,11 +755,12 @@ package body Ada.Containers.Ordered_Maps is\n    function Key (Position : Cursor) return Key_Type is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of function Key equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Key\");\n+                     \"Position cursor of function Key is bad\");\n \n       return Position.Node.Key;\n    end Key;\n@@ -779,7 +789,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if T.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.Last.Element;\n@@ -794,7 +804,7 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if T.Last = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"map is empty\";\n       end if;\n \n       return T.Last.Key;\n@@ -846,7 +856,7 @@ package body Ada.Containers.Ordered_Maps is\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Next\");\n+                     \"Position cursor of Next is bad\");\n \n       declare\n          Node : constant Node_Access :=\n@@ -886,7 +896,7 @@ package body Ada.Containers.Ordered_Maps is\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Previous\");\n+                     \"Position cursor of Previous is bad\");\n \n       declare\n          Node : constant Node_Access :=\n@@ -912,11 +922,12 @@ package body Ada.Containers.Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Query_Element equals No_Element\";\n       end if;\n \n       pragma Assert (Vet (Position.Container.Tree, Position.Node),\n-                     \"bad cursor in Query_Element\");\n+                     \"Position cursor of Query_Element is bad\");\n \n       declare\n          T : Tree_Type renames Position.Container.Tree;\n@@ -951,7 +962,7 @@ package body Ada.Containers.Ordered_Maps is\n    ----------\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Map)\n    is\n       function Read_Node\n@@ -986,11 +997,11 @@ package body Ada.Containers.Ordered_Maps is\n    end Read;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Read;\n \n    -------------\n@@ -1006,11 +1017,12 @@ package body Ada.Containers.Ordered_Maps is\n \n    begin\n       if Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with \"key not in map\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (map is locked)\";\n       end if;\n \n       Node.Key := Key;\n@@ -1028,19 +1040,22 @@ package body Ada.Containers.Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Replace_Element equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Replace_Element designates wrong map\";\n       end if;\n \n       if Container.Tree.Lock > 0 then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"attempt to tamper with cursors (map is locked)\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n-                     \"bad cursor in Replace_Element\");\n+                     \"Position cursor of Replace_Element is bad\");\n \n       Position.Node.Element := New_Item;\n    end Replace_Element;\n@@ -1146,15 +1161,17 @@ package body Ada.Containers.Ordered_Maps is\n    is\n    begin\n       if Position.Node = null then\n-         raise Constraint_Error;\n+         raise Constraint_Error with\n+           \"Position cursor of Update_Element equals No_Element\";\n       end if;\n \n       if Position.Container /= Container'Unrestricted_Access then\n-         raise Program_Error;\n+         raise Program_Error with\n+           \"Position cursor of Update_Element designates wrong map\";\n       end if;\n \n       pragma Assert (Vet (Container.Tree, Position.Node),\n-                     \"bad cursor in Update_Element\");\n+                     \"Position cursor of Update_Element is bad\");\n \n       declare\n          T : Tree_Type renames Container.Tree;\n@@ -1189,7 +1206,7 @@ package body Ada.Containers.Ordered_Maps is\n    -----------\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Map)\n    is\n       procedure Write_Node\n@@ -1220,11 +1237,11 @@ package body Ada.Containers.Ordered_Maps is\n    end Write;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor)\n    is\n    begin\n-      raise Program_Error;\n+      raise Program_Error with \"attempt to stream map cursor\";\n    end Write;\n \n end Ada.Containers.Ordered_Maps;"}, {"sha": "f07b07373d0aff68d519aee90e8c0fe505f9ae2e", "filename": "gcc/ada/a-coorma.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coorma.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cdc672b77b47c9c4794ed9b24b8dc923ea36bab/gcc%2Fada%2Fa-coorma.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-coorma.ads?ref=7cdc672b77b47c9c4794ed9b24b8dc923ea36bab", "patch": "@@ -217,27 +217,27 @@ private\n    end record;\n \n    procedure Write\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : Cursor);\n \n    for Cursor'Write use Write;\n \n    procedure Read\n-     (Stream : access Root_Stream_Type'Class;\n+     (Stream : not null access Root_Stream_Type'Class;\n       Item   : out Cursor);\n \n    for Cursor'Read use Read;\n \n    No_Element : constant Cursor := Cursor'(null, null);\n \n    procedure Write\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : Map);\n \n    for Map'Write use Write;\n \n    procedure Read\n-     (Stream    : access Root_Stream_Type'Class;\n+     (Stream    : not null access Root_Stream_Type'Class;\n       Container : out Map);\n \n    for Map'Read use Read;"}]}