{"sha": "83dcc2bd35e5dc981a13959b9bb6750736cd6544", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODNkY2MyYmQzNWU1ZGM5ODFhMTM5NTliOWJiNjc1MDczNmNkNjU0NA==", "commit": {"author": {"name": "Bob Duff", "email": "duff@adacore.com", "date": "2020-07-14T21:10:19Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-10-20T07:21:35Z"}, "message": "[Ada] Flexible AST node structure\n\ngcc/ada/\n\n\t* atree.ads: Make Default_Node a constant.  Remove the\n\tmodification of Comes_From_Source, and use a separate flag for\n\tthat.  Change Sloc to 0; it always overwritten, and never left\n\tas the No_Location value.\n\t(Print_Statistics): Move to spec so we can call it from\n\tgnat1drv.\n\t(Num_Nodes): Rename to clarify that this is approximate.\n\tCorrect comment: nodes and entities are never deleted, the count\n\tis never decremented, and this is not used by Xref.\n\t(Initialize): Correct comment: Error_List is not created here.\n\tOther minor naming and comment changes.\n\t* atree.adb (Extend_Node, New_Copy, New_Entity, New_Node):\n\tStreamline these. Simplify and improve efficiency.  Move code\n\tfrom Allocate_Initialize_Node to these, where it can be executed\n\tunconditionally.  Take advantage of automatic zeroing of the\n\tNodes table.\n\t(Allocate_Initialize_Node): Remove this. It was an efficiency\n\tbottleneck, and somewhat complicated, because it was called from\n\t4 places, and had all sorts of conditionals to check where it\n\twas called from. Better to move most of that code to the call\n\tsites, where it can be executed (or not) unconditionally.\n\t(Allocate_New_Node): New procedure to partly replace\n\tAllocate_Initialize_Node (called from just 2 of those 4 places).\n\t(Comes_From_Source_Default): New flag written/read by\n\tSet_Comes_From_Source_Default/Get_Comes_From_Source_Default.\n\tThis allows us to make Default_Node into a constant with\n\tall-zeros value.\n\t(Set_Paren_Count_Of_Copy): New procedure to avoid duplicated\n\tcode.\n\t(Report): New procedure to encapsulate the call to the reporting\n\tprocedure.\n\t(Atree_Private_Part): We now need a body for this package, to\n\tcontain package body Nodes.\n\t(Approx_Num_Nodes_And_Entities): Was Num_Nodes.  For efficiency,\n\tcompute the answer from Nodes.Last. That way we don't need to\n\tincrement a counter on every node creation. Other minor naming\n\tand comment changes.\n\t* gnat1drv.adb: Call Atree.Print_Statistics if -gnatd.A switch\n\twas given.  Add comment documenting the new order dependency (we\n\tmust process the command line before calling Atree.Initialize).\n\t* debug.adb: Document -gnatd.A.\n\t* einfo.adb, sinfo.adb: Remove useless Style_Checks pragmas.\n\t* nlists.ads (Allocate_List_Tables): Inline makes node creation\n\ta little faster.\n\t* nlists.adb (Initialize): Remove local constant E, which didn't\n\tseem to add clarity.\n\t* treepr.adb (Print_Init): Use renamed\n\tApprox_Num_Nodes_And_Entities function.\n\t* types.ads: Change the Low and High bounds as described above.\n\t* types.h: Change Low and High bounds to match types.ads.\n\t* sem_ch8.adb, namet.adb, namet.ads: Move the computation of\n\tLast_Name_Id from sem_ch8 to namet, and correct it to not assume\n\tName_Ids are positive.\n\t* ali.adb, ali-util.adb, bindo-writers.adb, exp_dist.adb,\n\tfmap.adb, fname-uf.adb, osint.adb: Fix various hash functions to\n\tavoid assuming the various ranges are positive. Note that \"mod\"\n\treturns a nonnegative result when the second operand is\n\tpositive. \"rem\" can return negative values in that case (in\n\tparticular, if the first operand is negative, which it now is).\n\t* switch-c.adb: Allow switch -gnaten to control the value of\n\tNodes_Size_In_Meg.\n\t* doc/gnat_ugn/building_executable_programs_with_gnat.rst:\n\tRemove traling whitespaces.\n\t* opt.ads (Nodes_Size_In_Meg): New Variable.", "tree": {"sha": "b2ecadbe1434218ceaec2b21a0539708482a3755", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b2ecadbe1434218ceaec2b21a0539708482a3755"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83dcc2bd35e5dc981a13959b9bb6750736cd6544", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83dcc2bd35e5dc981a13959b9bb6750736cd6544", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83dcc2bd35e5dc981a13959b9bb6750736cd6544", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83dcc2bd35e5dc981a13959b9bb6750736cd6544/comments", "author": {"login": "bobduff", "id": 29099567, "node_id": "MDQ6VXNlcjI5MDk5NTY3", "avatar_url": "https://avatars.githubusercontent.com/u/29099567?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bobduff", "html_url": "https://github.com/bobduff", "followers_url": "https://api.github.com/users/bobduff/followers", "following_url": "https://api.github.com/users/bobduff/following{/other_user}", "gists_url": "https://api.github.com/users/bobduff/gists{/gist_id}", "starred_url": "https://api.github.com/users/bobduff/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bobduff/subscriptions", "organizations_url": "https://api.github.com/users/bobduff/orgs", "repos_url": "https://api.github.com/users/bobduff/repos", "events_url": "https://api.github.com/users/bobduff/events{/privacy}", "received_events_url": "https://api.github.com/users/bobduff/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1b93e420fc10f0eaeb2b09d9b86c8defb5b459a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b93e420fc10f0eaeb2b09d9b86c8defb5b459a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b93e420fc10f0eaeb2b09d9b86c8defb5b459a4"}], "stats": {"total": 587, "additions": 317, "deletions": 270}, "files": [{"sha": "9dcc656c2bb762836129219683713bbdf8135126", "filename": "gcc/ada/ali-util.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fali-util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fali-util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali-util.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -179,7 +179,7 @@ package body ALI.Util is\n \n    function Hash (F : File_Name_Type) return Header_Num is\n    begin\n-      return Header_Num (Int (F) rem Header_Num'Range_Length);\n+      return Header_Num (Int (F) mod Header_Num'Range_Length);\n    end Hash;\n \n    ---------------------------"}, {"sha": "3bf12578b73d04e677082fc8cbac41850021c030", "filename": "gcc/ada/ali.adb", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fali.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fali.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fali.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -590,7 +590,8 @@ package body ALI is\n       --         scope__name__line_column__locations\n       --\n       --    * The String is converted into a Name_Id\n-      --    * The Name_Id is used as the hash\n+      --\n+      --    * The absolute value of the Name_Id is used as the hash\n \n       Append (Buffer, IS_Rec.Scope);\n       Append (Buffer, \"__\");\n@@ -606,7 +607,7 @@ package body ALI is\n       end if;\n \n       IS_Nam := Name_Find (Buffer);\n-      return Bucket_Range_Type (IS_Nam);\n+      return Bucket_Range_Type (abs IS_Nam);\n    end Hash;\n \n    --------------------"}, {"sha": "982742c76b92a67e77adbbb27ed0c5735d526b55", "filename": "gcc/ada/atree.adb", "status": "modified", "additions": 179, "deletions": 150, "changes": 329, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fatree.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fatree.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -57,7 +57,8 @@ package body Atree is\n    --  assertions this lock has no effect.\n \n    Reporting_Proc : Report_Proc := null;\n-   --  Record argument to last call to Set_Reporting_Proc\n+   --  Set_Reporting_Proc sets this. Set_Reporting_Proc must be called only\n+   --  once.\n \n    Rewriting_Proc : Rewrite_Proc := null;\n    --  This soft link captures the procedure invoked during a node rewrite\n@@ -113,16 +114,11 @@ package body Atree is\n    procedure Node_Debug_Output (Op : String; N : Node_Id);\n    --  Called by nnd; writes Op followed by information about N\n \n-   procedure Print_Statistics;\n-   pragma Export (Ada, Print_Statistics);\n-   --  Print various statistics on the tables maintained by the package\n-\n    -----------------------------\n    -- Local Objects and Types --\n    -----------------------------\n \n-   Node_Count : Nat;\n-   --  Count allocated nodes for Num_Nodes function\n+   Comes_From_Source_Default : Boolean := False;\n \n    use Unchecked_Access;\n    --  We are allowed to see these from within our own body\n@@ -504,7 +500,7 @@ package body Atree is\n \n    --  Note: eventually, this should be a field in the Node directly, but\n    --  for now we do not want to disturb the efficiency of a power of 2\n-   --  for the node size\n+   --  for the node size. ????We are planning to get rid of power-of-2.\n \n    package Orig_Nodes is new Table.Table (\n       Table_Component_Type => Node_Id,\n@@ -541,15 +537,19 @@ package body Atree is\n      Table_Increment      => 200,\n      Table_Name           => \"Paren_Counts\");\n \n+   procedure Set_Paren_Count_Of_Copy (Target, Source : Node_Id);\n+   pragma Inline (Set_Paren_Count_Of_Copy);\n+   --  Called when copying a node. Makes sure the Paren_Count of the copy is\n+   --  correct.\n+\n    -----------------------\n    -- Local Subprograms --\n    -----------------------\n \n-   function Allocate_Initialize_Node\n-     (Src            : Node_Id;\n-      With_Extension : Boolean) return Node_Id;\n-   --  Allocate a new node or node extension. If Src is not empty, the\n-   --  information for the newly-allocated node is copied from it.\n+   function Allocate_New_Node return Node_Id;\n+   pragma Inline (Allocate_New_Node);\n+   --  Allocate a new node or first part of a node extension. Initialize the\n+   --  Nodes.Table entry, Flags, Orig_Nodes, and List tables.\n \n    procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id);\n    --  Fix up parent pointers for the syntactic children of Fix_Node after a\n@@ -559,79 +559,28 @@ package body Atree is\n    --  Mark arbitrary node or entity N as Ghost when it is created within a\n    --  Ghost region.\n \n-   ------------------------------\n-   -- Allocate_Initialize_Node --\n-   ------------------------------\n+   procedure Report (Target, Source : Node_Id);\n+   pragma Inline (Report);\n+   --  Invoke the reporting procedure if available\n \n-   function Allocate_Initialize_Node\n-     (Src            : Node_Id;\n-      With_Extension : Boolean) return Node_Id\n-   is\n-      New_Id : Node_Id;\n+   -----------------------\n+   -- Allocate_New_Node --\n+   -----------------------\n \n+   function Allocate_New_Node return Node_Id is\n+      New_Id : Node_Id;\n    begin\n-      if Present (Src)\n-        and then not Has_Extension (Src)\n-        and then With_Extension\n-        and then Src = Nodes.Last\n-      then\n-         New_Id := Src;\n-\n-      --  We are allocating a new node, or extending a node other than\n-      --  Nodes.Last.\n-\n-      else\n-         if Present (Src) then\n-            Nodes.Append (Nodes.Table (Src));\n-            Flags.Append (Flags.Table (Src));\n-         else\n-            Nodes.Append (Default_Node);\n-            Flags.Append (Default_Flags);\n-         end if;\n-\n-         New_Id := Nodes.Last;\n-         Orig_Nodes.Append (New_Id);\n-         Node_Count := Node_Count + 1;\n-      end if;\n-\n-      --  Clear Check_Actuals to False\n-\n-      Set_Check_Actuals (New_Id, False);\n-\n-      --  Specifically copy Paren_Count to deal with creating new table entry\n-      --  if the parentheses count is at the maximum possible value already.\n-\n-      if Present (Src) and then Nkind (Src) in N_Subexpr then\n-         Set_Paren_Count (New_Id, Paren_Count (Src));\n-      end if;\n-\n-      --  Set extension nodes if required\n-\n-      if With_Extension then\n-         if Present (Src) and then Has_Extension (Src) then\n-            for J in 1 .. Num_Extension_Nodes loop\n-               Nodes.Append (Nodes.Table (Src + J));\n-               Flags.Append (Flags.Table (Src + J));\n-            end loop;\n-         else\n-            for J in 1 .. Num_Extension_Nodes loop\n-               Nodes.Append (Default_Node_Extension);\n-               Flags.Append (Default_Flags);\n-            end loop;\n-         end if;\n-      end if;\n-\n-      Orig_Nodes.Set_Last (Nodes.Last);\n+      Nodes.Append (Default_Node);\n+      New_Id := Nodes.Last;\n+      Flags.Append (Default_Flags);\n+      Orig_Nodes.Append (New_Id);\n+      Nodes.Table (Nodes.Last).Comes_From_Source :=\n+        Comes_From_Source_Default;\n       Allocate_List_Tables (Nodes.Last);\n-\n-      --  Invoke the reporting procedure (if available)\n-\n-      if Reporting_Proc /= null then\n-         Reporting_Proc.all (Target => New_Id, Source => Src);\n-      end if;\n+      Report (Target => New_Id, Source => Empty);\n \n       return New_Id;\n-   end Allocate_Initialize_Node;\n+   end Allocate_New_Node;\n \n    --------------\n    -- Analyzed --\n@@ -762,12 +711,7 @@ package body Atree is\n \n       Flags.Table (Destination) := Flags.Table (Source);\n \n-      --  Specifically set Paren_Count to make sure auxiliary table entry\n-      --  gets correctly made if the parentheses count is at the max value.\n-\n-      if Nkind (Destination) in N_Subexpr then\n-         Set_Paren_Count (Destination, Paren_Count (Source));\n-      end if;\n+      Set_Paren_Count_Of_Copy (Target => Destination, Source => Source);\n \n       --  Deal with copying extension nodes if present. No need to copy flags\n       --  table entries, since they are always zero for extending components.\n@@ -1056,12 +1000,14 @@ package body Atree is\n    -- Extend_Node --\n    -----------------\n \n-   function Extend_Node (Node : Node_Id) return Entity_Id is\n-      Result : Entity_Id;\n+   function Extend_Node (Source : Node_Id) return Entity_Id is\n+      pragma Assert (Present (Source));\n+      pragma Assert (not Has_Extension (Source));\n+      New_Id : Entity_Id;\n \n       procedure Debug_Extend_Node;\n       pragma Inline (Debug_Extend_Node);\n-      --  Debug routine for debug flag N\n+      --  Debug routine for -gnatdn\n \n       -----------------------\n       -- Debug_Extend_Node --\n@@ -1071,13 +1017,13 @@ package body Atree is\n       begin\n          if Debug_Flag_N then\n             Write_Str (\"Extend node \");\n-            Write_Int (Int (Node));\n+            Write_Int (Int (Source));\n \n-            if Result = Node then\n+            if New_Id = Source then\n                Write_Str (\" in place\");\n             else\n                Write_Str (\" copied to \");\n-               Write_Int (Int (Result));\n+               Write_Int (Int (New_Id));\n             end if;\n \n             --  Write_Eol;\n@@ -1087,19 +1033,43 @@ package body Atree is\n    --  Start of processing for Extend_Node\n \n    begin\n-      pragma Assert (not (Has_Extension (Node)));\n+      --  Optimize the case where Source happens to be the last node; in that\n+      --  case, we don't need to move it.\n+\n+      if Source = Nodes.Last then\n+         New_Id := Source;\n+      else\n+         Nodes.Append (Nodes.Table (Source));\n+         Flags.Append (Flags.Table (Source));\n+         New_Id := Nodes.Last;\n+         Orig_Nodes.Append (New_Id);\n+      end if;\n+\n+      Set_Check_Actuals (New_Id, False);\n+\n+      --  Set extension nodes\n+\n+      for J in 1 .. Num_Extension_Nodes loop\n+         Nodes.Append (Default_Node_Extension);\n+         Flags.Append (Default_Flags);\n+      end loop;\n+\n+      Orig_Nodes.Set_Last (Nodes.Last);\n+      Allocate_List_Tables (Nodes.Last);\n+      Report (Target => New_Id, Source => Source);\n \n-      Result := Allocate_Initialize_Node (Node, With_Extension => True);\n       pragma Debug (Debug_Extend_Node);\n \n-      return Result;\n+      return New_Id;\n    end Extend_Node;\n \n    -----------------\n    -- Fix_Parents --\n    -----------------\n \n    procedure Fix_Parents (Ref_Node, Fix_Node : Node_Id) is\n+      pragma Assert (Nkind (Ref_Node) = Nkind (Fix_Node));\n+\n       procedure Fix_Parent (Field : Union_Id);\n       --  Fix up one parent pointer. Field is checked to see if it points to\n       --  a node, list, or element list that has a parent that points to\n@@ -1157,7 +1127,7 @@ package body Atree is\n \n    function Get_Comes_From_Source_Default return Boolean is\n    begin\n-      return Default_Node.Comes_From_Source;\n+      return Comes_From_Source_Default;\n    end Get_Comes_From_Source_Default;\n \n    -----------------\n@@ -1188,7 +1158,6 @@ package body Atree is\n       pragma Warnings (Off, Dummy);\n \n    begin\n-      Node_Count := 0;\n       Atree_Private_Part.Nodes.Init;\n       Atree_Private_Part.Flags.Init;\n       Orig_Nodes.Init;\n@@ -1252,9 +1221,8 @@ package body Atree is\n       --  We used to Release the tables, as in the comments below, but that is\n       --  a waste of time. We're only wasting virtual memory here, and the\n       --  release calls copy large amounts of data.\n+      --  ???Get rid of Release?\n \n-      --  Nodes.Release;\n-      Nodes.Locked := True;\n       --  Flags.Release;\n       Flags.Locked := True;\n       --  Orig_Nodes.Release;\n@@ -1314,38 +1282,60 @@ package body Atree is\n    --------------\n \n    function New_Copy (Source : Node_Id) return Node_Id is\n-      New_Id : Node_Id := Source;\n-\n+      New_Id : Node_Id;\n    begin\n-      if Source > Empty_Or_Error then\n-         New_Id := Allocate_Initialize_Node (Source, Has_Extension (Source));\n+      if Source <= Empty_Or_Error then\n+         return Source;\n+      end if;\n \n-         Nodes.Table (New_Id).In_List := False;\n-         Nodes.Table (New_Id).Link    := Empty_List_Or_Node;\n+      Nodes.Append (Nodes.Table (Source));\n+      Flags.Append (Flags.Table (Source));\n+      New_Id := Nodes.Last;\n+      Orig_Nodes.Append (New_Id);\n+      Set_Check_Actuals (New_Id, False);\n+      Set_Paren_Count_Of_Copy (Target => New_Id, Source => Source);\n \n-         --  If the original is marked as a rewrite insertion, then unmark the\n-         --  copy, since we inserted the original, not the copy.\n+      --  Set extension nodes if required\n \n-         Nodes.Table (New_Id).Rewrite_Ins := False;\n-         pragma Debug (New_Node_Debugging_Output (New_Id));\n+      if Has_Extension (Source) then\n+         for J in 1 .. Num_Extension_Nodes loop\n+            Nodes.Append (Nodes.Table (Source + J));\n+            Flags.Append (Flags.Table (Source + J));\n+         end loop;\n+         Orig_Nodes.Set_Last (Nodes.Last);\n+      else\n+         pragma Assert (Orig_Nodes.Table (Orig_Nodes.Last) = Nodes.Last);\n+      end if;\n \n-         --  Clear Is_Overloaded since we cannot have semantic interpretations\n-         --  of this new node.\n+      Allocate_List_Tables (Nodes.Last);\n+      Report (Target => New_Id, Source => Source);\n \n-         if Nkind (Source) in N_Subexpr then\n-            Set_Is_Overloaded (New_Id, False);\n-         end if;\n+      Nodes.Table (New_Id).In_List := False;\n+      Nodes.Table (New_Id).Link    := Empty_List_Or_Node;\n \n-         --  Always clear Has_Aspects, the caller must take care of copying\n-         --  aspects if this is required for the particular situation.\n+      --  If the original is marked as a rewrite insertion, then unmark the\n+      --  copy, since we inserted the original, not the copy.\n \n-         Set_Has_Aspects (New_Id, False);\n+      Nodes.Table (New_Id).Rewrite_Ins := False;\n+      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n-         --  Mark the copy as Ghost depending on the current Ghost region\n+      --  Clear Is_Overloaded since we cannot have semantic interpretations\n+      --  of this new node.\n \n-         Mark_New_Ghost_Node (New_Id);\n+      if Nkind (Source) in N_Subexpr then\n+         Set_Is_Overloaded (New_Id, False);\n       end if;\n \n+      --  Always clear Has_Aspects, the caller must take care of copying\n+      --  aspects if this is required for the particular situation.\n+\n+      Set_Has_Aspects (New_Id, False);\n+\n+      --  Mark the copy as Ghost depending on the current Ghost region\n+\n+      Mark_New_Ghost_Node (New_Id);\n+\n+      pragma Assert (New_Id /= Source);\n       return New_Id;\n    end New_Copy;\n \n@@ -1357,30 +1347,35 @@ package body Atree is\n      (New_Node_Kind : Node_Kind;\n       New_Sloc      : Source_Ptr) return Entity_Id\n    is\n-      Ent : Entity_Id;\n-\n-   begin\n       pragma Assert (New_Node_Kind in N_Entity);\n+      New_Id : constant Entity_Id := Allocate_New_Node;\n+   begin\n+      --  Set extension nodes\n \n-      Ent := Allocate_Initialize_Node (Empty, With_Extension => True);\n+      for J in 1 .. Num_Extension_Nodes loop\n+         Nodes.Append (Default_Node_Extension);\n+         Flags.Append (Default_Flags);\n+      end loop;\n+\n+      Orig_Nodes.Set_Last (Nodes.Last);\n \n       --  If this is a node with a real location and we are generating\n       --  source nodes, then reset Current_Error_Node. This is useful\n       --  if we bomb during parsing to get a error location for the bomb.\n \n-      if Default_Node.Comes_From_Source and then New_Sloc > No_Location then\n-         Current_Error_Node := Ent;\n+      if  New_Sloc > No_Location and then Comes_From_Source_Default then\n+         Current_Error_Node := New_Id;\n       end if;\n \n-      Nodes.Table (Ent).Nkind := New_Node_Kind;\n-      Nodes.Table (Ent).Sloc  := New_Sloc;\n-      pragma Debug (New_Node_Debugging_Output (Ent));\n+      Nodes.Table (New_Id).Nkind := New_Node_Kind;\n+      Nodes.Table (New_Id).Sloc  := New_Sloc;\n+      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n       --  Mark the new entity as Ghost depending on the current Ghost region\n \n-      Mark_New_Ghost_Node (Ent);\n+      Mark_New_Ghost_Node (New_Id);\n \n-      return Ent;\n+      return New_Id;\n    end New_Entity;\n \n    --------------\n@@ -1391,29 +1386,27 @@ package body Atree is\n      (New_Node_Kind : Node_Kind;\n       New_Sloc      : Source_Ptr) return Node_Id\n    is\n-      Nod : Node_Id;\n-\n-   begin\n       pragma Assert (New_Node_Kind not in N_Entity);\n-\n-      Nod := Allocate_Initialize_Node (Empty, With_Extension => False);\n-      Nodes.Table (Nod).Nkind := New_Node_Kind;\n-      Nodes.Table (Nod).Sloc  := New_Sloc;\n-      pragma Debug (New_Node_Debugging_Output (Nod));\n+      New_Id : constant Node_Id := Allocate_New_Node;\n+      pragma Assert (Orig_Nodes.Table (Orig_Nodes.Last) = Nodes.Last);\n+   begin\n+      Nodes.Table (New_Id).Nkind := New_Node_Kind;\n+      Nodes.Table (New_Id).Sloc  := New_Sloc;\n+      pragma Debug (New_Node_Debugging_Output (New_Id));\n \n       --  If this is a node with a real location and we are generating source\n       --  nodes, then reset Current_Error_Node. This is useful if we bomb\n       --  during parsing to get an error location for the bomb.\n \n-      if Default_Node.Comes_From_Source and then New_Sloc > No_Location then\n-         Current_Error_Node := Nod;\n+      if Comes_From_Source_Default and then New_Sloc > No_Location then\n+         Current_Error_Node := New_Id;\n       end if;\n \n       --  Mark the new node as Ghost depending on the current Ghost region\n \n-      Mark_New_Ghost_Node (Nod);\n+      Mark_New_Ghost_Node (New_Id);\n \n-      return Nod;\n+      return New_Id;\n    end New_Node;\n \n    -------------------------\n@@ -1494,14 +1487,18 @@ package body Atree is\n       return Nodes.Table (First_Node_Id)'Address;\n    end Nodes_Address;\n \n-   ---------------\n-   -- Num_Nodes --\n-   ---------------\n+   -----------------------------------\n+   -- Approx_Num_Nodes_And_Entities --\n+   -----------------------------------\n \n-   function Num_Nodes return Nat is\n+   function Approx_Num_Nodes_And_Entities return Nat is\n    begin\n-      return Node_Count;\n-   end Num_Nodes;\n+      --  This is an overestimate, because entities take up more space, but\n+      --  that really doesn't matter; it's not worth subtracting out the\n+      --  \"extra\".\n+\n+      return Nat (Nodes.Last - First_Node_Id);\n+   end Approx_Num_Nodes_And_Entities;\n \n    -------------------\n    -- Original_Node --\n@@ -1763,6 +1760,17 @@ package body Atree is\n       end if;\n    end Replace;\n \n+   ------------\n+   -- Report --\n+   ------------\n+\n+   procedure Report (Target, Source : Node_Id) is\n+   begin\n+      if Reporting_Proc /= null then\n+         Reporting_Proc.all (Target, Source);\n+      end if;\n+   end Report;\n+\n    -------------\n    -- Rewrite --\n    -------------\n@@ -1895,7 +1903,7 @@ package body Atree is\n \n    procedure Set_Comes_From_Source_Default (Default : Boolean) is\n    begin\n-      Default_Node.Comes_From_Source := Default;\n+      Comes_From_Source_Default := Default;\n    end Set_Comes_From_Source_Default;\n \n    ---------------\n@@ -1983,17 +1991,39 @@ package body Atree is\n          Nodes.Table (N).Pflag1 := True;\n          Nodes.Table (N).Pflag2 := True;\n \n+         --  Search for existing table entry\n+\n          for J in Paren_Counts.First .. Paren_Counts.Last loop\n             if N = Paren_Counts.Table (J).Nod then\n                Paren_Counts.Table (J).Count := Val;\n                return;\n             end if;\n          end loop;\n \n+         --  No existing table entry; make a new one\n+\n          Paren_Counts.Append ((Nod => N, Count => Val));\n       end if;\n    end Set_Paren_Count;\n \n+   -----------------------------\n+   -- Set_Paren_Count_Of_Copy --\n+   -----------------------------\n+\n+   procedure Set_Paren_Count_Of_Copy (Target, Source : Node_Id) is\n+   begin\n+      --  We already copied the two Pflags. We need to update the Paren_Counts\n+      --  table only if greater than 2.\n+\n+      if Nkind (Source) in N_Subexpr\n+        and then Paren_Count (Source) > 2\n+      then\n+         Set_Paren_Count (Target, Paren_Count (Source));\n+      end if;\n+\n+      pragma Assert (Paren_Count (Target) = Paren_Count (Source));\n+   end Set_Paren_Count_Of_Copy;\n+\n    ----------------\n    -- Set_Parent --\n    ----------------\n@@ -8756,7 +8786,6 @@ package body Atree is\n \n    procedure Unlock is\n    begin\n-      Nodes.Locked := False;\n       Flags.Locked := False;\n       Orig_Nodes.Locked := False;\n    end Unlock;"}, {"sha": "278753519afa2907bb38938bb90d9b89dbf8a52a", "filename": "gcc/ada/atree.ads", "status": "modified", "additions": 27, "deletions": 26, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fatree.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fatree.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fatree.ads?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -70,7 +70,7 @@ package Atree is\n \n    --  Currently entities are composed of 7 sequentially allocated 32-byte\n    --  nodes, considered as a single record. The following definition gives\n-   --  the number of extension nodes.\n+   --  the number of extension nodes. ????We plan to change this.\n \n    Num_Extension_Nodes : Node_Id := 6;\n    --  This value is increased by one if debug flag -gnatd.N is set. This is\n@@ -81,6 +81,10 @@ package Atree is\n    --  2.01 for the nodes/entities ratio and a 2% increase in compilation time\n    --  on average for the GCC-based compiler at -O0 on a 32-bit x86 host.\n \n+   procedure Print_Statistics;\n+   pragma Export (Ada, Print_Statistics);\n+   --  Print various statistics on the tables maintained by the package\n+\n    ----------------------------------------\n    -- Definitions of Fields in Tree Node --\n    ----------------------------------------\n@@ -231,12 +235,9 @@ package Atree is\n    function Flags_Address return System.Address;\n    --  Return address of Flags table (used in Back_End for Gigi call)\n \n-   function Num_Nodes return Nat;\n-   --  Total number of nodes allocated, where an entity counts as a single\n-   --  node. This count is incremented every time a node or entity is\n-   --  allocated, and decremented every time a node or entity is deleted.\n-   --  This value is used by Xref and by Treepr to allocate hash tables of\n-   --  suitable size for hashing Node_Id values.\n+   function Approx_Num_Nodes_And_Entities return Nat;\n+   --  This is an approximation to the number of nodes and entities allocated,\n+   --  used to determine sizes of hash tables.\n \n    -----------------------\n    -- Use of Empty Node --\n@@ -404,9 +405,8 @@ package Atree is\n    --  place, and then for subsequent modifications as required.\n \n    procedure Initialize;\n-   --  Called at the start of compilation to initialize the allocation of\n-   --  the node and list tables and make the standard entries for Empty,\n-   --  Error and Error_List.\n+   --  Called at the start of compilation to initialize the allocation of the\n+   --  node and list tables and make the entries for Empty and Error.\n \n    procedure Lock;\n    --  Called before the back end is invoked to lock the nodes table\n@@ -551,7 +551,7 @@ package Atree is\n    --  semantic chains: Homonym and Next_Entity: the corresponding links must\n    --  be adjusted by the caller, according to context.\n \n-   function Extend_Node (Node : Node_Id) return Entity_Id;\n+   function Extend_Node (Source : Node_Id) return Entity_Id;\n    --  This function returns a copy of its input node with an extension added.\n    --  The fields of the extension are set to Empty. Due to the way extensions\n    --  are handled (as four consecutive array elements), it may be necessary\n@@ -3843,7 +3843,8 @@ package Atree is\n             --    Field6-11     Holds Field36-Field41\n \n          end case;\n-      end record;\n+      end record; -- Node_Record\n+      pragma Suppress_Initialization (Node_Record); -- see package Nodes below\n \n       pragma Pack (Node_Record);\n       for Node_Record'Size use 8 * 32;\n@@ -3855,7 +3856,7 @@ package Atree is\n       --  Default value used to initialize default nodes. Note that some of the\n       --  fields get overwritten, and in particular, Nkind always gets reset.\n \n-      Default_Node : Node_Record := (\n+      Default_Node : constant Node_Record := (\n          Is_Extension      => False,\n          Pflag1            => False,\n          Pflag2            => False,\n@@ -3864,7 +3865,6 @@ package Atree is\n          Rewrite_Ins       => False,\n          Analyzed          => False,\n          Comes_From_Source => False,\n-         --  modified by Set_Comes_From_Source_Default\n          Error_Posted      => False,\n          Flag4             => False,\n \n@@ -3886,7 +3886,7 @@ package Atree is\n \n          Nkind             => N_Unused_At_Start,\n \n-         Sloc              => No_Location,\n+         Sloc              => 0,\n          Link              => Empty_List_Or_Node,\n          Field1            => Empty_List_Or_Node,\n          Field2            => Empty_List_Or_Node,\n@@ -3938,17 +3938,18 @@ package Atree is\n          Field11           => Empty_List_Or_Node,\n          Field12           => Empty_List_Or_Node);\n \n-      --  The following defines the extendable array used for the nodes table\n-      --  Nodes with extensions use six consecutive entries in the array\n-\n-      package Nodes is new Table.Table (\n-        Table_Component_Type => Node_Record,\n-        Table_Index_Type     => Node_Id'Base,\n-        Table_Low_Bound      => First_Node_Id,\n-        Table_Initial        => Alloc.Nodes_Initial,\n-        Table_Increment      => Alloc.Nodes_Increment,\n-        Release_Threshold    => Alloc.Nodes_Release_Threshold,\n-        Table_Name           => \"Nodes\");\n+      --  The following defines the extendable array used for the nodes table.\n+      --  Nodes with extensions use multiple consecutive entries in the array\n+      --  (see Num_Extension_Nodes).\n+\n+      package Nodes is new Table.Table\n+        (Table_Component_Type => Node_Record,\n+         Table_Index_Type     => Node_Id'Base,\n+         Table_Low_Bound      => First_Node_Id,\n+         Table_Initial        => Alloc.Nodes_Initial,\n+         Table_Increment      => Alloc.Nodes_Increment,\n+         Release_Threshold    => Alloc.Nodes_Release_Threshold,\n+         Table_Name           => \"Nodes\");\n \n       --  The following is a parallel table to Nodes, which provides 8 more\n       --  bits of space that logically belong to the corresponding node. This"}, {"sha": "cca6687f5f4817a24a5ee834633eaf52e2878f2b", "filename": "gcc/ada/bindo-writers.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fbindo-writers.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fbindo-writers.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindo-writers.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -1561,7 +1561,7 @@ package body Bindo.Writers is\n       begin\n          pragma Assert (Present (Nam));\n \n-         return Bucket_Range_Type (Nam);\n+         return Bucket_Range_Type (abs Nam);\n       end Hash_File_Name;\n \n       ---------------------"}, {"sha": "e8556543eef3842d4182fedf79744b49668f5958", "filename": "gcc/ada/debug.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fdebug.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fdebug.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdebug.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -118,7 +118,7 @@ package body Debug is\n    --  d.y  Disable implicit pragma Elaborate_All on task bodies\n    --  d.z  Restore previous support for frontend handling of Inline_Always\n \n-   --  d.A\n+   --  d.A  Print Atree statistics\n    --  d.B  Generate a bug box on abort_statement\n    --  d.C  Generate concatenation call, do not generate inline code\n    --  d.D  Disable errors on use of overriding keyword in Ada 95 mode\n@@ -841,6 +841,8 @@ package body Debug is\n    --       handling of Inline_Always by the front end on such targets. For the\n    --       targets that do not use the GCC back end, this switch is ignored.\n \n+   --  d.A  Print Atree statistics\n+\n    --  d.B  Generate a bug box when we see an abort_statement, even though\n    --       there is no bug. Useful for testing Comperr.Compiler_Abort: write\n    --       some code containing an abort_statement, and compile it with"}, {"sha": "7afe76df10ca36bbce7ebec036df5d0262d8818e", "filename": "gcc/ada/doc/gnat_ugn/building_executable_programs_with_gnat.rst", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_ugn%2Fbuilding_executable_programs_with_gnat.rst?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -6499,8 +6499,8 @@ be presented in subsequent sections.\n   limitations:\n \n   * Starting the program's execution in the debugger will cause it to\n-    stop at the start of the ``main`` function instead of the main subprogram. \n-    This can be worked around by manually inserting a breakpoint on that \n+    stop at the start of the ``main`` function instead of the main subprogram.\n+    This can be worked around by manually inserting a breakpoint on that\n     subprogram and resuming the program's execution until reaching that breakpoint.\n   * Programs using GNAT.Compiler_Version will not link.\n "}, {"sha": "9ea261683c456acaa2cf0966c82749f441a70f2c", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -29,9 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Style_Checks (All_Checks);\n---  Turn off subprogram ordering, not used for this unit\n-\n with Atree;   use Atree;\n with Elists;  use Elists;\n with Namet;   use Namet;"}, {"sha": "760a4123216c14a0625271a3e3d1f4939c9d244a", "filename": "gcc/ada/exp_dist.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fexp_dist.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fexp_dist.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_dist.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -5296,7 +5296,7 @@ package body Exp_Dist is\n \n    function Hash (F : Name_Id) return Hash_Index is\n    begin\n-      return Hash_Index (Natural (F) mod Positive (Hash_Index'Last + 1));\n+      return Hash_Index (Integer (F) mod Positive (Hash_Index'Last + 1));\n    end Hash;\n \n    --------------------------"}, {"sha": "40aeef151115bc79627d9e283daf381617945076", "filename": "gcc/ada/fmap.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ffmap.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ffmap.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffmap.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -162,12 +162,12 @@ package body Fmap is\n \n    function Hash (F : File_Name_Type) return Header_Num is\n    begin\n-      return Header_Num (Int (F) rem Header_Num'Range_Length);\n+      return Header_Num (Int (F) mod Header_Num'Range_Length);\n    end Hash;\n \n    function Hash (F : Unit_Name_Type) return Header_Num is\n    begin\n-      return Header_Num (Int (F) rem Header_Num'Range_Length);\n+      return Header_Num (Int (F) mod Header_Num'Range_Length);\n    end Hash;\n \n    ----------------"}, {"sha": "48e2bc24a52ddf67ca5c54181cd6d11a5674aa34", "filename": "gcc/ada/fname-uf.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ffname-uf.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ffname-uf.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffname-uf.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -598,7 +598,7 @@ package body Fname.UF is\n \n    function SFN_Hash (F : Unit_Name_Type) return SFN_Header_Num is\n    begin\n-      return SFN_Header_Num (Int (F) rem SFN_Header_Num'Range_Length);\n+      return SFN_Header_Num (Int (F) mod SFN_Header_Num'Range_Length);\n    end SFN_Hash;\n \n begin"}, {"sha": "1a9cef554491f8819e7f02f9b11bf3a447e7074d", "filename": "gcc/ada/gnat1drv.adb", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fgnat1drv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fgnat1drv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat1drv.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -1067,9 +1067,13 @@ begin\n       --  Initialize all packages. For the most part, these initialization\n       --  calls can be made in any order. Exceptions are as follows:\n \n-      --  Lib.Initialize need to be called before Scan_Compiler_Arguments,\n+      --  Lib.Initialize needs to be called before Scan_Compiler_Arguments,\n       --  because it initializes a table filled by Scan_Compiler_Arguments.\n \n+      --  Atree.Initialize needs to be called after Scan_Compiler_Arguments,\n+      --  because the value specified by the -gnaten switch is used by\n+      --  Atree.Initialize.\n+\n       Osint.Initialize;\n       Fmap.Reset_Tables;\n       Lib.Initialize;\n@@ -1692,7 +1696,10 @@ begin\n    end;\n \n    <<End_Of_Program>>\n-   null;\n+\n+   if Debug_Flag_Dot_AA then\n+      Atree.Print_Statistics;\n+   end if;\n \n --  The outer exception handler handles an unrecoverable error\n "}, {"sha": "99fd23f8c6773692912805c25576efce17e95ea4", "filename": "gcc/ada/namet.adb", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnamet.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnamet.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -1094,6 +1094,15 @@ package body Namet is\n       return Id in Name_Entries.First .. Name_Entries.Last;\n    end Is_Valid_Name;\n \n+   ------------------\n+   -- Last_Name_Id --\n+   ------------------\n+\n+   function Last_Name_Id return Name_Id is\n+   begin\n+      return Name_Id (Int (First_Name_Id) + Name_Entries_Count - 1);\n+   end Last_Name_Id;\n+\n    --------------------\n    -- Length_Of_Name --\n    --------------------"}, {"sha": "8e83eb91eeec378c0fecef63f604c3371e85fae6", "filename": "gcc/ada/namet.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnamet.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnamet.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnamet.ads?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -437,6 +437,10 @@ package Namet is\n    function Name_Entries_Count return Nat;\n    --  Return current number of entries in the names table\n \n+   function Last_Name_Id return Name_Id;\n+   --  Return the last Name_Id in the table. This information is valid until\n+   --  new names have been added.\n+\n    --------------------------\n    -- Obsolete Subprograms --\n    --------------------------"}, {"sha": "ef39ed4d7807bed51e9082f378cb87cbca4de153", "filename": "gcc/ada/nlists.adb", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnlists.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnlists.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -338,8 +338,6 @@ package body Nlists is\n    ----------------\n \n    procedure Initialize is\n-      E : constant List_Id := Error_List;\n-\n    begin\n       Lists.Init;\n       Next_Node.Init;\n@@ -348,9 +346,9 @@ package body Nlists is\n       --  Allocate Error_List list header\n \n       Lists.Increment_Last;\n-      Set_Parent (E, Empty);\n-      Set_First  (E, Empty);\n-      Set_Last   (E, Empty);\n+      Set_Parent (Error_List, Empty);\n+      Set_First  (Error_List, Empty);\n+      Set_Last   (Error_List, Empty);\n    end Initialize;\n \n    ------------------"}, {"sha": "5afe27226ddffca34723175ed05ae7b2030796fa", "filename": "gcc/ada/nlists.ads", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnlists.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fnlists.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fnlists.ads?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -377,6 +377,7 @@ package Nlists is\n    --  \"if Present (Statements)\" as opposed to \"if Statements /= No_List\".\n \n    procedure Allocate_List_Tables (N : Node_Or_Entity_Id);\n+   pragma Inline (Allocate_List_Tables);\n    --  Called when nodes table is expanded to include node N. This call\n    --  makes sure that list structures internal to Nlists are adjusted\n    --  appropriately to reflect this increase in the size of the nodes table."}, {"sha": "1377de8450c69f9e7e0646021be9aef94cf24311", "filename": "gcc/ada/opt.ads", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fopt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fopt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fopt.ads?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -1199,6 +1199,12 @@ package Opt is\n    --  If a pragma No_Tagged_Streams is active for the current scope, this\n    --  points to the corresponding pragma.\n \n+   Nodes_Size_In_Meg : Nat := 0;\n+   --  GNAT\n+   --  Amount of memory to allocate for all nodes, in units of 2**20 bytes.\n+   --  Set by the -gnaten switch; 0 means -gnaten was not given, and a default\n+   --  value should be used.\n+\n    Normalize_Scalars : Boolean := False;\n    --  GNAT, GNATBIND\n    --  Set True if a pragma Normalize_Scalars applies to the current unit."}, {"sha": "e935c2b50ad7f24431cf6068c0e1d157f9f27807", "filename": "gcc/ada/osint.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fosint.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fosint.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fosint.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -1072,7 +1072,7 @@ package body Osint is\n \n    function File_Hash (F : File_Name_Type) return File_Hash_Num is\n    begin\n-      return File_Hash_Num (Int (F) rem File_Hash_Num'Range_Length);\n+      return File_Hash_Num (Int (F) mod File_Hash_Num'Range_Length);\n    end File_Hash;\n \n    -----------------"}, {"sha": "430af2ded2fea8f6b9284e41094c65c51d3cff6e", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -5553,11 +5553,6 @@ package body Sem_Ch8 is\n             declare\n                E      : Entity_Id;\n                Ematch : Entity_Id := Empty;\n-\n-               Last_Name_Id : constant Name_Id :=\n-                                Name_Id (Nat (First_Name_Id) +\n-                                           Name_Entries_Count - 1);\n-\n             begin\n                for Nam in First_Name_Id .. Last_Name_Id loop\n                   E := Get_Name_Entity_Id (Nam);"}, {"sha": "065d3c6509bee9b0401ae1c941e6412c592923ee", "filename": "gcc/ada/sinfo.adb", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fsinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fsinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsinfo.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -29,9 +29,6 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-pragma Style_Checks (All_Checks);\n---  No subprogram ordering check, due to logical grouping\n-\n with Atree; use Atree;\n \n package body Sinfo is"}, {"sha": "e086a5d9d2bca703b47646b918ac0deffecc5975", "filename": "gcc/ada/switch-c.adb", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fswitch-c.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Fswitch-c.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fswitch-c.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -673,6 +673,13 @@ package body Switch.C is\n                        new String'(Switch_Chars (Ptr .. Max));\n                      return;\n \n+                  --  -gnaten (memory to allocate for nodes)\n+\n+                  when 'n' =>\n+                     Ptr := Ptr + 1;\n+                     Scan_Pos\n+                       (Switch_Chars, Max, Ptr, Nodes_Size_In_Meg, C);\n+\n                   --  -gnateO= (object path file)\n \n                   --  This is an internal switch"}, {"sha": "d902ab820dfab8a48b547b642379d79f4a825d75", "filename": "gcc/ada/treepr.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftreepr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftreepr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftreepr.adb?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -869,6 +869,8 @@ package body Treepr is\n    ----------------\n \n    procedure Print_Init is\n+      Max_Hash_Entries : constant Nat :=\n+        Approx_Num_Nodes_And_Entities + Num_Lists + Num_Elists;\n    begin\n       Printing_Descendants := True;\n       Write_Eol;\n@@ -877,7 +879,7 @@ package body Treepr is\n       --  the maximum possible number of entries, so that the hash table\n       --  cannot get significantly overloaded.\n \n-      Hash_Table_Len := (150 * (Num_Nodes + Num_Lists + Num_Elists)) / 100;\n+      Hash_Table_Len := (150 * Max_Hash_Entries) / 100;\n       Hash_Table := new Hash_Table_Type  (0 .. Hash_Table_Len - 1);\n \n       for J in Hash_Table'Range loop"}, {"sha": "4e917cd26ea36149afbec05138b452d6c2543295", "filename": "gcc/ada/types.ads", "status": "modified", "additions": 37, "deletions": 48, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftypes.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftypes.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.ads?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -265,97 +265,86 @@ package Types is\n \n    --  These types are represented as integer indices into various tables.\n    --  However, they should be treated as private, except in a few documented\n-   --  cases. In particular it is never appropriate to perform arithmetic\n-   --  operations using these types.\n+   --  cases. In particular it is usually inappropriate to perform arithmetic\n+   --  operations using these types. One exception is in computing hash\n+   --  functions of these types.\n \n    --  In most contexts, the strongly typed interface determines which of these\n    --  types is present. However, there are some situations (involving untyped\n    --  traversals of the tree), where it is convenient to be easily able to\n    --  distinguish these values. The underlying representation in all cases is\n    --  an integer type Union_Id, and we ensure that the range of the various\n-   --  possible values for each of the above types is disjoint so that this\n-   --  distinction is possible.\n+   --  possible values for each of the above types is disjoint (except that\n+   --  List_Id and Node_Id overlap at Empty) so that this distinction is\n+   --  possible.\n \n    --  Note: it is also helpful for debugging purposes to make these ranges\n    --  distinct. If a bug leads to misidentification of a value, then it will\n    --  typically result in an out of range value and a Constraint_Error.\n \n+   --  The range of Node_Id is most of the nonnegative integers. The other\n+   --  ranges are negative. Uint has a very large range, because a substantial\n+   --  part of this range is used to store direct values; see Uintp for\n+   --  details. The other types have 100 million values, which should be\n+   --  plenty.\n+\n    type Union_Id is new Int;\n    --  The type in the tree for a union of possible ID values\n \n-   List_Low_Bound : constant := -100_000_000;\n+   --  Following are the Low and High bounds of the various ranges.\n+\n+   List_Low_Bound : constant := -099_999_999;\n    --  The List_Id values are subscripts into an array of list headers which\n-   --  has List_Low_Bound as its lower bound. This value is chosen so that all\n-   --  List_Id values are negative, and the value zero is in the range of both\n-   --  List_Id and Node_Id values (see further description below).\n+   --  has List_Low_Bound as its lower bound.\n \n    List_High_Bound : constant := 0;\n-   --  Maximum List_Id subscript value. This allows up to 100 million list Id\n-   --  values, which is in practice infinite, and there is no need to check the\n-   --  range. The range overlaps the node range by one element (with value\n-   --  zero), which is used both for the Empty node, and for indicating no\n-   --  list. The fact that the same value is used is convenient because it\n-   --  means that the default value of Empty applies to both nodes and lists,\n-   --  and also is more efficient to test for.\n+   --  Maximum List_Id subscript value. The ranges of List_Id and Node_Id\n+   --  overlap by one element (with value zero), which is used both for the\n+   --  Empty node, and for No_List. The fact that the same value is used is\n+   --  convenient because it means that the default value of Empty applies to\n+   --  both nodes and lists, and also is more efficient to test for.\n \n    Node_Low_Bound : constant := 0;\n    --  The tree Id values start at zero, because we use zero for Empty (to\n-   --  allow a zero test for Empty). Actual tree node subscripts start at 0\n-   --  since Empty is a legitimate node value.\n+   --  allow a zero test for Empty).\n \n-   Node_High_Bound : constant := 099_999_999;\n-   --  Maximum number of nodes that can be allocated is 100 million, which\n-   --  is in practice infinite, and there is no need to check the range.\n+   Node_High_Bound : constant :=\n+     (if Standard'Address_Size = 32 then 299_999_999 else 1_999_999_999);\n \n-   Elist_Low_Bound : constant := 100_000_000;\n+   Elist_Low_Bound : constant := -199_999_999;\n    --  The Elist_Id values are subscripts into an array of elist headers which\n    --  has Elist_Low_Bound as its lower bound.\n \n-   Elist_High_Bound : constant := 199_999_999;\n-   --  Maximum Elist_Id subscript value. This allows up to 100 million Elists,\n-   --  which is in practice infinite and there is no need to check the range.\n+   Elist_High_Bound : constant := -100_000_000;\n \n-   Elmt_Low_Bound : constant := 200_000_000;\n+   Elmt_Low_Bound : constant := -299_999_999;\n    --  Low bound of element Id values. The use of these values is internal to\n    --  the Elists package, but the definition of the range is included here\n    --  since it must be disjoint from other Id values. The Elmt_Id values are\n    --  subscripts into an array of list elements which has this as lower bound.\n \n-   Elmt_High_Bound : constant := 299_999_999;\n-   --  Upper bound of Elmt_Id values. This allows up to 100 million element\n-   --  list members, which is in practice infinite (no range check needed).\n+   Elmt_High_Bound : constant := -200_000_000;\n \n-   Names_Low_Bound : constant := 300_000_000;\n-   --  Low bound for name Id values\n+   Names_Low_Bound : constant := -399_999_999;\n \n-   Names_High_Bound : constant := 399_999_999;\n-   --  Maximum number of names that can be allocated is 100 million, which is\n-   --  in practice infinite and there is no need to check the range.\n+   Names_High_Bound : constant := -300_000_000;\n \n-   Strings_Low_Bound : constant := 400_000_000;\n-   --  Low bound for string Id values\n+   Strings_Low_Bound : constant := -499_999_999;\n \n-   Strings_High_Bound : constant := 499_999_999;\n-   --  Maximum number of strings that can be allocated is 100 million, which\n-   --  is in practice infinite and there is no need to check the range.\n+   Strings_High_Bound : constant := -400_000_000;\n \n-   Ureal_Low_Bound : constant := 500_000_000;\n-   --  Low bound for Ureal values\n+   Ureal_Low_Bound : constant := -599_999_999;\n \n-   Ureal_High_Bound : constant := 599_999_999;\n-   --  Maximum number of Ureal values stored is 100_000_000 which is in\n-   --  practice infinite so that no check is required.\n+   Ureal_High_Bound : constant := -500_000_000;\n \n-   Uint_Low_Bound : constant := 600_000_000;\n+   Uint_Low_Bound : constant := -2_100_000_000;\n    --  Low bound for Uint values\n \n-   Uint_Table_Start : constant := 2_000_000_000;\n+   Uint_Table_Start : constant := -699_999_999;\n    --  Location where table entries for universal integers start (see\n    --  Uintp spec for details of the representation of Uint values).\n \n-   Uint_High_Bound : constant := 2_099_999_999;\n-   --  The range of Uint values is very large, since a substantial part\n-   --  of this range is used to store direct values, see Uintp for details.\n+   Uint_High_Bound : constant := -600_000_000;\n \n    --  The following subtype definitions are used to provide convenient names\n    --  for membership tests on Int values to see what data type range they"}, {"sha": "76cf950ae93042608698d9bb130b43045e28f14b", "filename": "gcc/ada/types.h", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83dcc2bd35e5dc981a13959b9bb6750736cd6544/gcc%2Fada%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ftypes.h?ref=83dcc2bd35e5dc981a13959b9bb6750736cd6544", "patch": "@@ -150,30 +150,32 @@ typedef int Union_Id;\n \n /* Range definitions for Tree Data:  */\n \n-#define List_Low_Bound\t\t-100000000\n+#define List_Low_Bound\t\t-99999999\n #define List_High_Bound\t\t0\n \n #define Node_Low_Bound\t\t0\n-#define Node_High_Bound\t\t99999999\n+#define Node_High_Bound\t\t1999999999\n+/* Above is the correct value of Node_High_Bound for 64-bit machines. It is\n+   wrong for 32-bit machines, but that doesn't matter. */\n \n-#define Elist_Low_Bound\t\t100000000\n-#define Elist_High_Bound\t199999999\n+#define Elist_Low_Bound\t\t-199999999\n+#define Elist_High_Bound\t-100000000\n \n-#define Elmt_Low_Bound\t\t200000000\n-#define Elmt_High_Bound\t\t299999999\n+#define Elmt_Low_Bound\t\t-299999999\n+#define Elmt_High_Bound\t\t-200000000\n \n-#define Names_Low_Bound\t\t300000000\n-#define Names_High_Bound\t399999999\n+#define Names_Low_Bound\t\t-399999999\n+#define Names_High_Bound\t-300000000\n \n-#define Strings_Low_Bound\t400000000\n-#define Strings_High_Bound\t499999999\n+#define Strings_Low_Bound\t-499999999\n+#define Strings_High_Bound\t-400000000\n \n-#define Ureal_Low_Bound\t\t500000000\n-#define Ureal_High_Bound        599999999\n+#define Ureal_Low_Bound\t\t-599999999\n+#define Ureal_High_Bound        -500000000\n \n-#define Uint_Low_Bound\t\t600000000\n-#define Uint_Table_Start        2000000000\n-#define Uint_High_Bound\t        2099999999\n+#define Uint_Low_Bound\t\t-2100000000\n+#define Uint_Table_Start        -699999999\n+#define Uint_High_Bound\t        -600000000\n \n SUBTYPE (List_Range,      Int, List_Low_Bound,    List_High_Bound)\n SUBTYPE (Node_Range,      Int, Node_Low_Bound,    Node_High_Bound)"}]}