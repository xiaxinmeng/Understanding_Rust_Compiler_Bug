{"sha": "227a2ecf663d69972b851f51f1934d18927b62cd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI3YTJlY2Y2NjNkNjk5NzJiODUxZjUxZjE5MzRkMTg5MjdiNjJjZA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-03-12T10:53:47Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2021-05-12T09:47:08Z"}, "message": "lto-wrapper: Use vec<cl_decoded_option> data type.\n\ngcc/ChangeLog:\n\n\t* lto-wrapper.c (get_options_from_collect_gcc_options): Change\n\treturn type.\n\t(append_option): Remove.\n\t(find_option): Rework to use the vector type.\n\t(remove_option): Remove.\n\t(merge_and_complain): Use vectors for cl_decoded_option data\n\ttype arguments.\n\t(append_compiler_options): Likewise.\n\t(append_diag_options): Likewise.\n\t(append_linker_options): Likewise.\n\t(append_offload_options): Likewise.\n\t(compile_offload_image): Likewise.\n\t(compile_images_for_offload_targets): Likewise.\n\t(find_and_merge_options): Likewise.\n\t(run_gcc): Likewise.", "tree": {"sha": "b800b44fd5d863310d3f8c0c82c4f411da124dab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b800b44fd5d863310d3f8c0c82c4f411da124dab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/227a2ecf663d69972b851f51f1934d18927b62cd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227a2ecf663d69972b851f51f1934d18927b62cd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/227a2ecf663d69972b851f51f1934d18927b62cd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/227a2ecf663d69972b851f51f1934d18927b62cd/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "1ecd1e6c894fbdbc10fdcfee419922b24e1115ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ecd1e6c894fbdbc10fdcfee419922b24e1115ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ecd1e6c894fbdbc10fdcfee419922b24e1115ee"}], "stats": {"total": 396, "additions": 176, "deletions": 220}, "files": [{"sha": "11d4d20c494299c730cb9bad93df42a257a5ba73", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 176, "deletions": 220, "changes": 396, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/227a2ecf663d69972b851f51f1934d18927b62cd/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/227a2ecf663d69972b851f51f1934d18927b62cd/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=227a2ecf663d69972b851f51f1934d18927b62cd", "patch": "@@ -139,12 +139,12 @@ maybe_unlink (const char *file)\n /* Create decoded options from the COLLECT_GCC and COLLECT_GCC_OPTIONS\n    environment.  */\n \n-static void\n+static vec<cl_decoded_option>\n get_options_from_collect_gcc_options (const char *collect_gcc,\n-\t\t\t\t      const char *collect_gcc_options,\n-\t\t\t\t      struct cl_decoded_option **decoded_options,\n-\t\t\t\t      unsigned int *decoded_options_count)\n+\t\t\t\t      const char *collect_gcc_options)\n {\n+  cl_decoded_option *decoded_options;\n+  unsigned int decoded_options_count;\n   struct obstack argv_obstack;\n   const char **argv;\n   int argc;\n@@ -157,57 +157,49 @@ get_options_from_collect_gcc_options (const char *collect_gcc,\n   argv = XOBFINISH (&argv_obstack, const char **);\n \n   decode_cmdline_options_to_array (argc, (const char **)argv, CL_DRIVER,\n-\t\t\t\t   decoded_options, decoded_options_count);\n+\t\t\t\t   &decoded_options, &decoded_options_count);\n+  vec<cl_decoded_option> decoded;\n+  decoded.create (decoded_options_count);\n+  for (unsigned i = 0; i < decoded_options_count; ++i)\n+    decoded.quick_push (decoded_options[i]);\n+  free (decoded_options);\n+\n   obstack_free (&argv_obstack, NULL);\n+\n+  return decoded;\n }\n \n-/* Append OPTION to the options array DECODED_OPTIONS with size\n-   DECODED_OPTIONS_COUNT.  */\n+/* Find option in OPTIONS based on OPT_INDEX.  -1 value is returned\n+   if the option is not present.  */\n \n-static void\n-append_option (struct cl_decoded_option **decoded_options,\n-\t       unsigned int *decoded_options_count,\n-\t       struct cl_decoded_option *option)\n+static int\n+find_option (vec<cl_decoded_option> &options, size_t opt_index)\n {\n-  ++*decoded_options_count;\n-  *decoded_options\n-    = (struct cl_decoded_option *)\n-\txrealloc (*decoded_options,\n-\t\t  (*decoded_options_count\n-\t\t   * sizeof (struct cl_decoded_option)));\n-  memcpy (&(*decoded_options)[*decoded_options_count - 1], option,\n-\t  sizeof (struct cl_decoded_option));\n-}\n+  for (unsigned i = 0; i < options.length (); ++i)\n+    if (options[i].opt_index == opt_index)\n+      return i;\n \n-/* Remove option number INDEX from DECODED_OPTIONS, update\n-   DECODED_OPTIONS_COUNT.  */\n+  return -1;\n+}\n \n-static void\n-remove_option (struct cl_decoded_option **decoded_options,\n-\t       int index, unsigned int *decoded_options_count)\n+static int\n+find_option (vec<cl_decoded_option> &options, cl_decoded_option *option)\n {\n-  --*decoded_options_count;\n-  memmove (&(*decoded_options)[index + 1],\n-\t   &(*decoded_options)[index],\n-\t   sizeof (struct cl_decoded_option)\n-\t   * (*decoded_options_count - index));\n+  return find_option (options, option->opt_index);\n }\n \n /* Try to merge and complain about options FDECODED_OPTIONS when applied\n    ontop of DECODED_OPTIONS.  */\n \n static void\n-merge_and_complain (struct cl_decoded_option **decoded_options,\n-\t\t    unsigned int *decoded_options_count,\n-\t\t    struct cl_decoded_option *fdecoded_options,\n-\t\t    unsigned int fdecoded_options_count,\n-\t\t    struct cl_decoded_option *decoded_cl_options,\n-\t\t    unsigned int decoded_cl_options_count)\n+merge_and_complain (vec<cl_decoded_option> decoded_options,\n+\t\t    vec<cl_decoded_option> fdecoded_options,\n+\t\t    vec<cl_decoded_option> decoded_cl_options)\n {\n   unsigned int i, j;\n-  struct cl_decoded_option *pic_option = NULL;\n-  struct cl_decoded_option *pie_option = NULL;\n-  struct cl_decoded_option *cf_protection_option = NULL;\n+  cl_decoded_option *pic_option = NULL;\n+  cl_decoded_option *pie_option = NULL;\n+  cl_decoded_option *cf_protection_option = NULL;\n \n   /* ???  Merge options from files.  Most cases can be\n      handled by either unioning or intersecting\n@@ -224,9 +216,9 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \n   /* Look for a -fcf-protection option in the link-time options\n      which overrides any -fcf-protection from the lto sections.  */\n-  for (i = 0; i < decoded_cl_options_count; ++i)\n+  for (i = 0; i < decoded_cl_options.length (); ++i)\n     {\n-      struct cl_decoded_option *foption = &decoded_cl_options[i];\n+      cl_decoded_option *foption = &decoded_cl_options[i];\n       if (foption->opt_index == OPT_fcf_protection_)\n \t{\n \t  cf_protection_option = foption;\n@@ -235,9 +227,10 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n   \n   /* The following does what the old LTO option code did,\n      union all target and a selected set of common options.  */\n-  for (i = 0; i < fdecoded_options_count; ++i)\n+  for (i = 0; i < fdecoded_options.length (); ++i)\n     {\n-      struct cl_decoded_option *foption = &fdecoded_options[i];\n+      cl_decoded_option *foption = &fdecoded_options[i];\n+      int existing_opt = find_option (decoded_options, foption);\n       switch (foption->opt_index)\n \t{\n \tcase OPT_SPECIAL_unknown:\n@@ -265,11 +258,8 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t     setting per OPT code, we pick the first we encounter.\n \t     ???  This doesn't make too much sense, but when it doesn't\n \t     then we should complain.  */\n-\t  for (j = 0; j < *decoded_options_count; ++j)\n-\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n-\t      break;\n-\t  if (j == *decoded_options_count)\n-\t    append_option (decoded_options, decoded_options_count, foption);\n+\t  if (existing_opt == -1)\n+\t    decoded_options.safe_push (*foption);\n \t  break;\n \n \t/* Figure out what PIC/PIE level wins and merge the results.  */\n@@ -285,25 +275,19 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \tcase OPT_fopenmp:\n \tcase OPT_fopenacc:\n \t  /* For selected options we can merge conservatively.  */\n-\t  for (j = 0; j < *decoded_options_count; ++j)\n-\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n-\t      break;\n-\t  if (j == *decoded_options_count)\n-\t    append_option (decoded_options, decoded_options_count, foption);\n+\t  if (existing_opt == -1)\n+\t    decoded_options.safe_push (*foption);\n \t  /* -fopenmp > -fno-openmp,\n \t     -fopenacc > -fno-openacc  */\n-\t  else if (foption->value > (*decoded_options)[j].value)\n-\t    (*decoded_options)[j] = *foption;\n+\t  else if (foption->value > decoded_options[existing_opt].value)\n+\t    decoded_options[existing_opt] = *foption;\n \t  break;\n \n \tcase OPT_fopenacc_dim_:\n \t  /* Append or check identical.  */\n-\t  for (j = 0; j < *decoded_options_count; ++j)\n-\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n-\t      break;\n-\t  if (j == *decoded_options_count)\n-\t    append_option (decoded_options, decoded_options_count, foption);\n-\t  else if (strcmp ((*decoded_options)[j].arg, foption->arg))\n+\t  if (existing_opt == -1)\n+\t    decoded_options.safe_push (*foption);\n+\t  else if (strcmp (decoded_options[existing_opt].arg, foption->arg))\n \t    fatal_error (input_location,\n \t\t\t \"option %s with different values\",\n \t\t\t foption->orig_option_with_args_text);\n@@ -314,35 +298,33 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t  if (!cf_protection_option\n \t      || cf_protection_option->value == CF_CHECK)\n \t    {\n-\t      for (j = 0; j < *decoded_options_count; ++j)\n-\t\tif ((*decoded_options)[j].opt_index == foption->opt_index)\n-\t\t  break;\n-\t      if (j == *decoded_options_count)\n-\t\tappend_option (decoded_options, decoded_options_count, foption);\n-\t      else if ((*decoded_options)[j].value != foption->value)\n+\t      if (existing_opt == -1)\n+\t\tdecoded_options.safe_push (*foption);\n+\t      else if (decoded_options[existing_opt].value != foption->value)\n \t\t{\n \t\t  if (cf_protection_option\n \t\t      && cf_protection_option->value == CF_CHECK)\n \t\t    fatal_error (input_location,\n \t\t\t\t \"option %qs with mismatching values\"\n \t\t\t\t \" (%s, %s)\",\n \t\t\t\t \"-fcf-protection\",\n-\t\t\t\t (*decoded_options)[j].arg, foption->arg);\n+\t\t\t\t decoded_options[existing_opt].arg,\n+\t\t\t\t foption->arg);\n \t\t  else\n \t\t    {\n \t\t      /* Merge and update the -fcf-protection option.  */\n-\t\t      (*decoded_options)[j].value &= (foption->value\n-\t\t\t\t\t\t      & CF_FULL);\n-\t\t      switch ((*decoded_options)[j].value)\n+\t\t      decoded_options[existing_opt].value\n+\t\t\t&= (foption->value & CF_FULL);\n+\t\t      switch (decoded_options[existing_opt].value)\n \t\t\t{\n \t\t\tcase CF_NONE:\n-\t\t\t  (*decoded_options)[j].arg = \"none\";\n+\t\t\t  decoded_options[existing_opt].arg = \"none\";\n \t\t\t  break;\n \t\t\tcase CF_BRANCH:\n-\t\t\t  (*decoded_options)[j].arg = \"branch\";\n+\t\t\t  decoded_options[existing_opt].arg = \"branch\";\n \t\t\t  break;\n \t\t\tcase CF_RETURN:\n-\t\t\t  (*decoded_options)[j].arg = \"return\";\n+\t\t\t  decoded_options[existing_opt].arg = \"return\";\n \t\t\t  break;\n \t\t\tdefault:\n \t\t\t  gcc_unreachable ();\n@@ -356,15 +338,19 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \tcase OPT_Ofast:\n \tcase OPT_Og:\n \tcase OPT_Os:\n-\t  for (j = 0; j < *decoded_options_count; ++j)\n-\t    if ((*decoded_options)[j].opt_index == OPT_O\n-\t\t|| (*decoded_options)[j].opt_index == OPT_Ofast\n-\t\t|| (*decoded_options)[j].opt_index == OPT_Og\n-\t\t|| (*decoded_options)[j].opt_index == OPT_Os)\n-\t      break;\n-\t  if (j == *decoded_options_count)\n-\t    append_option (decoded_options, decoded_options_count, foption);\n-\t  else if ((*decoded_options)[j].opt_index == foption->opt_index\n+\t  existing_opt = -1;\n+\t  for (j = 0; j < decoded_options.length (); ++j)\n+\t    if (decoded_options[j].opt_index == OPT_O\n+\t\t|| decoded_options[j].opt_index == OPT_Ofast\n+\t\t|| decoded_options[j].opt_index == OPT_Og\n+\t\t|| decoded_options[j].opt_index == OPT_Os)\n+\t      {\n+\t\texisting_opt = j;\n+\t\tbreak;\n+\t      }\n+\t  if (existing_opt == -1)\n+\t    decoded_options.safe_push (*foption);\n+\t  else if (decoded_options[existing_opt].opt_index == foption->opt_index\n \t\t   && foption->opt_index != OPT_O)\n \t    /* Exact same options get merged.  */\n \t    ;\n@@ -394,13 +380,14 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      switch ((*decoded_options)[j].opt_index)\n+\t      switch (decoded_options[existing_opt].opt_index)\n \t\t{\n \t\tcase OPT_O:\n-\t\t  if ((*decoded_options)[j].arg[0] == '\\0')\n+\t\t  if (decoded_options[existing_opt].arg[0] == '\\0')\n \t\t    level = MAX (level, 1);\n \t\t  else\n-\t\t    level = MAX (level, atoi ((*decoded_options)[j].arg));\n+\t\t    level = MAX (level,\n+\t\t\t\t atoi (decoded_options[existing_opt].arg));\n \t\t  break;\n \t\tcase OPT_Ofast:\n \t\t  level = MAX (level, 3);\n@@ -414,31 +401,28 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n-\t      (*decoded_options)[j].opt_index = OPT_O;\n+\t      decoded_options[existing_opt].opt_index = OPT_O;\n \t      char *tem;\n \t      tem = xasprintf (\"-O%d\", level);\n-\t      (*decoded_options)[j].arg = &tem[2];\n-\t      (*decoded_options)[j].canonical_option[0] = tem;\n-\t      (*decoded_options)[j].value = 1;\n+\t      decoded_options[existing_opt].arg = &tem[2];\n+\t      decoded_options[existing_opt].canonical_option[0] = tem;\n+\t      decoded_options[existing_opt].value = 1;\n \t    }\n \t  break;\n  \n \n \tcase OPT_foffload_abi_:\n-\t  for (j = 0; j < *decoded_options_count; ++j)\n-\t    if ((*decoded_options)[j].opt_index == foption->opt_index)\n-\t      break;\n-\t  if (j == *decoded_options_count)\n-\t    append_option (decoded_options, decoded_options_count, foption);\n-\t  else if (foption->value != (*decoded_options)[j].value)\n+\t  if (existing_opt == -1)\n+\t    decoded_options.safe_push (*foption);\n+\t  else if (foption->value != decoded_options[existing_opt].value)\n \t    fatal_error (input_location,\n \t\t\t \"option %s not used consistently in all LTO input\"\n \t\t\t \" files\", foption->orig_option_with_args_text);\n \t  break;\n \n \n \tcase OPT_foffload_:\n-\t  append_option (decoded_options, decoded_options_count, foption);\n+\t  decoded_options.safe_push (*foption);\n \t  break;\n \t}\n     }\n@@ -458,12 +442,12 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n      It would be good to warn on mismatches, but it is bit hard to do as\n      we do not know what nothing translates to.  */\n     \n-  for (unsigned int j = 0; j < *decoded_options_count;)\n-    if ((*decoded_options)[j].opt_index == OPT_fPIC\n-        || (*decoded_options)[j].opt_index == OPT_fpic)\n+  for (unsigned int j = 0; j < decoded_options.length ();)\n+    if (decoded_options[j].opt_index == OPT_fPIC\n+\t|| decoded_options[j].opt_index == OPT_fpic)\n       {\n \t/* -fno-pic in one unit implies -fno-pic everywhere.  */\n-\tif ((*decoded_options)[j].value == 0)\n+\tif (decoded_options[j].value == 0)\n \t  j++;\n \t/* If we have no pic option or merge in -fno-pic, we still may turn\n \t   existing pic/PIC mode into pie/PIE if -fpie/-fPIE is present.  */\n@@ -472,41 +456,41 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t  {\n \t    if (pie_option)\n \t      {\n-\t\tbool big = (*decoded_options)[j].opt_index == OPT_fPIC\n+\t\tbool big = decoded_options[j].opt_index == OPT_fPIC\n \t\t\t   && pie_option->opt_index == OPT_fPIE;\n-\t        (*decoded_options)[j].opt_index = big ? OPT_fPIE : OPT_fpie;\n+\t\tdecoded_options[j].opt_index = big ? OPT_fPIE : OPT_fpie;\n \t\tif (pie_option->value)\n-\t          (*decoded_options)[j].canonical_option[0]\n+\t\t  decoded_options[j].canonical_option[0]\n \t\t    = big ? \"-fPIE\" : \"-fpie\";\n \t\telse\n-\t          (*decoded_options)[j].canonical_option[0] = \"-fno-pie\";\n-\t\t(*decoded_options)[j].value = pie_option->value;\n-\t        j++;\n+\t\t  decoded_options[j].canonical_option[0] = \"-fno-pie\";\n+\t\tdecoded_options[j].value = pie_option->value;\n+\t\tj++;\n \t      }\n \t    else if (pic_option)\n \t      {\n-\t        (*decoded_options)[j] = *pic_option;\n-\t        j++;\n+\t\tdecoded_options[j] = *pic_option;\n+\t\tj++;\n \t      }\n \t    /* We do not know if target defaults to pic or not, so just remove\n \t       option if it is missing in one unit but enabled in other.  */\n \t    else\n-\t      remove_option (decoded_options, j, decoded_options_count);\n+\t      decoded_options.ordered_remove (j);\n \t  }\n \telse if (pic_option->opt_index == OPT_fpic\n-\t\t && (*decoded_options)[j].opt_index == OPT_fPIC)\n+\t\t && decoded_options[j].opt_index == OPT_fPIC)\n \t  {\n-\t    (*decoded_options)[j] = *pic_option;\n+\t    decoded_options[j] = *pic_option;\n \t    j++;\n \t  }\n \telse\n \t  j++;\n       }\n-   else if ((*decoded_options)[j].opt_index == OPT_fPIE\n-            || (*decoded_options)[j].opt_index == OPT_fpie)\n+   else if (decoded_options[j].opt_index == OPT_fPIE\n+\t    || decoded_options[j].opt_index == OPT_fpie)\n       {\n \t/* -fno-pie in one unit implies -fno-pie everywhere.  */\n-\tif ((*decoded_options)[j].value == 0)\n+\tif (decoded_options[j].value == 0)\n \t  j++;\n \t/* If we have no pie option or merge in -fno-pie, we still preserve\n \t   PIE/pie if pic/PIC is present.  */\n@@ -517,32 +501,32 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n \t    if (pic_option)\n \t      {\n \t\tif (pic_option->opt_index == OPT_fpic\n-\t\t    && (*decoded_options)[j].opt_index == OPT_fPIE)\n+\t\t    && decoded_options[j].opt_index == OPT_fPIE)\n \t\t  {\n-\t            (*decoded_options)[j].opt_index = OPT_fpie;\n-\t            (*decoded_options)[j].canonical_option[0]\n+\t\t    decoded_options[j].opt_index = OPT_fpie;\n+\t\t    decoded_options[j].canonical_option[0]\n \t\t      = pic_option->value ? \"-fpie\" : \"-fno-pie\";\n \t\t  }\n \t\telse if (!pic_option->value)\n-\t\t  (*decoded_options)[j].canonical_option[0] = \"-fno-pie\";\n-\t\t(*decoded_options)[j].value = pic_option->value;\n+\t\t  decoded_options[j].canonical_option[0] = \"-fno-pie\";\n+\t\tdecoded_options[j].value = pic_option->value;\n \t\tj++;\n \t      }\n \t    else if (pie_option)\n \t      {\n-\t        (*decoded_options)[j] = *pie_option;\n+\t\tdecoded_options[j] = *pie_option;\n \t\tj++;\n \t      }\n \t    /* Because we always append pic/PIE options this code path should\n \t       not happen unless the LTO object was built by old lto1 which\n \t       did not contain that logic yet.  */\n \t    else\n-\t      remove_option (decoded_options, j, decoded_options_count);\n+\t      decoded_options.ordered_remove (j);\n \t  }\n \telse if (pie_option->opt_index == OPT_fpie\n-\t\t && (*decoded_options)[j].opt_index == OPT_fPIE)\n+\t\t && decoded_options[j].opt_index == OPT_fPIE)\n \t  {\n-\t    (*decoded_options)[j] = *pie_option;\n+\t    decoded_options[j] = *pie_option;\n \t    j++;\n \t  }\n \telse\n@@ -554,37 +538,41 @@ merge_and_complain (struct cl_decoded_option **decoded_options,\n   if (!xassembler_options_error)\n     for (i = j = 0; ; i++, j++)\n       {\n-\tfor (; i < *decoded_options_count; i++)\n-\t  if ((*decoded_options)[i].opt_index == OPT_Xassembler)\n-\t    break;\n-\n-\tfor (; j < fdecoded_options_count; j++)\n-\t  if (fdecoded_options[j].opt_index == OPT_Xassembler)\n-\t    break;\n-\n-\tif (i == *decoded_options_count && j == fdecoded_options_count)\n+\tint existing_opt_index\n+\t  = find_option (decoded_options, OPT_Xassembler);\n+\tint existing_opt2_index\n+\t  = find_option (fdecoded_options, OPT_Xassembler);\n+\n+\tcl_decoded_option *existing_opt = NULL;\n+\tcl_decoded_option *existing_opt2 = NULL;\n+\tif (existing_opt_index != -1)\n+\t  existing_opt = &decoded_options[existing_opt_index];\n+\tif (existing_opt2_index != -1)\n+\t  existing_opt2 = &fdecoded_options[existing_opt2_index];\n+\n+\tif (existing_opt == NULL && existing_opt2 == NULL)\n \t  break;\n-\telse if (i < *decoded_options_count && j == fdecoded_options_count)\n+\telse if (existing_opt != NULL && existing_opt2 == NULL)\n \t  {\n \t    warning (0, \"Extra option to %<-Xassembler%>: %s,\"\n \t\t     \" dropping all %<-Xassembler%> and %<-Wa%> options.\",\n-\t\t     (*decoded_options)[i].arg);\n+\t\t     existing_opt->arg);\n \t    xassembler_options_error = true;\n \t    break;\n \t  }\n-\telse if (i == *decoded_options_count && j < fdecoded_options_count)\n+\telse if (existing_opt == NULL && existing_opt2 != NULL)\n \t  {\n \t    warning (0, \"Extra option to %<-Xassembler%>: %s,\"\n \t\t     \" dropping all %<-Xassembler%> and %<-Wa%> options.\",\n-\t\t     fdecoded_options[j].arg);\n+\t\t     existing_opt2->arg);\n \t    xassembler_options_error = true;\n \t    break;\n \t  }\n-\telse if (strcmp ((*decoded_options)[i].arg, fdecoded_options[j].arg))\n+\telse if (strcmp (existing_opt->arg, existing_opt2->arg) != 0)\n \t  {\n \t    warning (0, \"Options to %<-Xassembler%> do not match: %s, %s,\"\n \t\t     \" dropping all %<-Xassembler%> and %<-Wa%> options.\",\n-\t\t     (*decoded_options)[i].arg, fdecoded_options[j].arg);\n+\t\t     existing_opt->arg, existing_opt2->arg);\n \t    xassembler_options_error = true;\n \t    break;\n \t  }\n@@ -655,13 +643,12 @@ parse_env_var (const char *str, char ***pvalues, const char *append)\n /* Append options OPTS from lto or offload_lto sections to ARGV_OBSTACK.  */\n \n static void\n-append_compiler_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n-\t\t\t unsigned int count)\n+append_compiler_options (obstack *argv_obstack, vec<cl_decoded_option> opts)\n {\n   /* Append compiler driver arguments as far as they were merged.  */\n-  for (unsigned int j = 1; j < count; ++j)\n+  for (unsigned int j = 1; j < opts.length (); ++j)\n     {\n-      struct cl_decoded_option *option = &opts[j];\n+      cl_decoded_option *option = &opts[j];\n \n       /* File options have been properly filtered by lto-opts.c.  */\n       switch (option->opt_index)\n@@ -722,16 +709,15 @@ append_compiler_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n     }\n }\n \n-/* Append diag options in OPTS with length COUNT to ARGV_OBSTACK.  */\n+/* Append diag options in OPTS to ARGV_OBSTACK.  */\n \n static void\n-append_diag_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n-\t\t     unsigned int count)\n+append_diag_options (obstack *argv_obstack, vec<cl_decoded_option> opts)\n {\n   /* Append compiler driver arguments as far as they were merged.  */\n-  for (unsigned int j = 1; j < count; ++j)\n+  for (unsigned int j = 1; j < opts.length (); ++j)\n     {\n-      struct cl_decoded_option *option = &opts[j];\n+      cl_decoded_option *option = &opts[j];\n \n       switch (option->opt_index)\n \t{\n@@ -758,14 +744,13 @@ append_diag_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n /* Append linker options OPTS to ARGV_OBSTACK.  */\n \n static void\n-append_linker_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n-\t\t       unsigned int count)\n+append_linker_options (obstack *argv_obstack, vec<cl_decoded_option> opts)\n {\n   /* Append linker driver arguments.  Compiler options from the linker\n      driver arguments will override / merge with those from the compiler.  */\n-  for (unsigned int j = 1; j < count; ++j)\n+  for (unsigned int j = 1; j < opts.length (); ++j)\n     {\n-      struct cl_decoded_option *option = &opts[j];\n+      cl_decoded_option *option = &opts[j];\n \n       /* Do not pass on frontend specific flags not suitable for lto.  */\n       if (!(cl_options[option->opt_index].flags\n@@ -803,15 +788,14 @@ append_linker_options (obstack *argv_obstack, struct cl_decoded_option *opts,\n \n static void\n append_offload_options (obstack *argv_obstack, const char *target,\n-\t\t\tstruct cl_decoded_option *options,\n-\t\t\tunsigned int options_count)\n+\t\t\tvec<cl_decoded_option> options)\n {\n-  for (unsigned i = 0; i < options_count; i++)\n+  for (unsigned i = 0; i < options.length (); i++)\n     {\n       const char *cur, *next, *opts;\n       char **argv;\n       unsigned argc;\n-      struct cl_decoded_option *option = &options[i];\n+      cl_decoded_option *option = &options[i];\n \n       if (option->opt_index != OPT_foffload_)\n \tcontinue;\n@@ -883,10 +867,8 @@ access_check (const char *name, int mode)\n static char *\n compile_offload_image (const char *target, const char *compiler_path,\n \t\t       unsigned in_argc, char *in_argv[],\n-\t\t       struct cl_decoded_option *compiler_opts,\n-\t\t       unsigned int compiler_opt_count,\n-\t\t       struct cl_decoded_option *linker_opts,\n-\t\t       unsigned int linker_opt_count)\n+\t\t       vec<cl_decoded_option> compiler_opts,\n+\t\t       vec<cl_decoded_option> linker_opts)\n {\n   char *filename = NULL;\n   char *dumpbase;\n@@ -943,19 +925,16 @@ compile_offload_image (const char *target, const char *compiler_path,\n     obstack_ptr_grow (&argv_obstack, in_argv[i]);\n \n   /* Append options from offload_lto sections.  */\n-  append_compiler_options (&argv_obstack, compiler_opts,\n-\t\t\t   compiler_opt_count);\n-  append_diag_options (&argv_obstack, linker_opts, linker_opt_count);\n+  append_compiler_options (&argv_obstack, compiler_opts);\n+  append_diag_options (&argv_obstack, linker_opts);\n \n   obstack_ptr_grow (&argv_obstack, \"-dumpbase\");\n   obstack_ptr_grow (&argv_obstack, dumpbase);\n \n   /* Append options specified by -foffload last.  In case of conflicting\n      options we expect offload compiler to choose the latest.  */\n-  append_offload_options (&argv_obstack, target, compiler_opts,\n-\t\t\t  compiler_opt_count);\n-  append_offload_options (&argv_obstack, target, linker_opts,\n-\t\t\t  linker_opt_count);\n+  append_offload_options (&argv_obstack, target, compiler_opts);\n+  append_offload_options (&argv_obstack, target, linker_opts);\n \n   obstack_ptr_grow (&argv_obstack, NULL);\n   argv = XOBFINISH (&argv_obstack, char **);\n@@ -974,10 +953,8 @@ compile_offload_image (const char *target, const char *compiler_path,\n \n static void\n compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n-\t\t\t\t    struct cl_decoded_option *compiler_opts,\n-\t\t\t\t    unsigned int compiler_opt_count,\n-\t\t\t\t    struct cl_decoded_option *linker_opts,\n-\t\t\t\t    unsigned int linker_opt_count)\n+\t\t\t\t    vec<cl_decoded_option> compiler_opts,\n+\t\t\t\t    vec<cl_decoded_option> linker_opts)\n {\n   char **names = NULL;\n   const char *target_names = getenv (OFFLOAD_TARGET_NAMES_ENV);\n@@ -997,8 +974,7 @@ compile_images_for_offload_targets (unsigned in_argc, char *in_argv[],\n     {\n       offload_names[next_name_entry]\n \t= compile_offload_image (names[i], compiler_path, in_argc, in_argv,\n-\t\t\t\t compiler_opts, compiler_opt_count,\n-\t\t\t\t linker_opts, linker_opt_count);\n+\t\t\t\t compiler_opts, linker_opts);\n       if (!offload_names[next_name_entry])\n #if OFFLOAD_DEFAULTED\n \tcontinue;\n@@ -1080,25 +1056,22 @@ find_crtoffloadtable (int save_temps, const char *dumppfx)\n }\n \n /* A subroutine of run_gcc.  Examine the open file FD for lto sections with\n-   name prefix PREFIX, at FILE_OFFSET, and store any options we find in OPTS\n-   and OPT_COUNT.  Return true if we found a matching section, false\n+   name prefix PREFIX, at FILE_OFFSET, and store any options we find in OPTS.\n+   Return true if we found a matching section, false\n    otherwise.  COLLECT_GCC holds the value of the environment variable with\n    the same name.  */\n \n static bool\n find_and_merge_options (int fd, off_t file_offset, const char *prefix,\n-\t\t\tstruct cl_decoded_option *decoded_cl_options,\n-\t\t\tunsigned int decoded_cl_options_count,\n-\t\t\tstruct cl_decoded_option **opts,\n-\t\t\tunsigned int *opt_count, const char *collect_gcc)\n+\t\t\tvec<cl_decoded_option> decoded_cl_options,\n+\t\t\tvec<cl_decoded_option> *opts, const char *collect_gcc)\n {\n   off_t offset, length;\n   char *data;\n   char *fopts;\n   const char *errmsg;\n   int err;\n-  struct cl_decoded_option *fdecoded_options = *opts;\n-  unsigned int fdecoded_options_count = *opt_count;\n+  vec<cl_decoded_option> fdecoded_options;\n \n   simple_object_read *sobj;\n   sobj = simple_object_start_read (fd, file_offset, \"__GNU_LTO\",\n@@ -1120,24 +1093,19 @@ find_and_merge_options (int fd, off_t file_offset, const char *prefix,\n   data = (char *)xmalloc (length);\n   read (fd, data, length);\n   fopts = data;\n+  bool first = true;\n   do\n     {\n-      struct cl_decoded_option *f2decoded_options;\n-      unsigned int f2decoded_options_count;\n-      get_options_from_collect_gcc_options (collect_gcc, fopts,\n-\t\t\t\t\t    &f2decoded_options,\n-\t\t\t\t\t    &f2decoded_options_count);\n-      if (!fdecoded_options)\n-       {\n-\t fdecoded_options = f2decoded_options;\n-\t fdecoded_options_count = f2decoded_options_count;\n-       }\n+      vec<cl_decoded_option> f2decoded_options\n+\t= get_options_from_collect_gcc_options (collect_gcc, fopts);\n+      if (first)\n+\t{\n+\t  fdecoded_options = f2decoded_options;\n+\t  first = false;\n+\t}\n       else\n-\tmerge_and_complain (&fdecoded_options,\n-\t\t\t    &fdecoded_options_count,\n-\t\t\t    f2decoded_options, f2decoded_options_count,\n-\t\t\t    decoded_cl_options,\n-\t\t\t    decoded_cl_options_count);\n+\tmerge_and_complain (fdecoded_options, f2decoded_options,\n+\t\t\t    decoded_cl_options);\n \n       fopts += strlen (fopts) + 1;\n     }\n@@ -1146,7 +1114,6 @@ find_and_merge_options (int fd, off_t file_offset, const char *prefix,\n   free (data);\n   simple_object_release_read (sobj);\n   *opts = fdecoded_options;\n-  *opt_count = fdecoded_options_count;\n   return true;\n }\n \n@@ -1391,12 +1358,9 @@ run_gcc (unsigned argc, char *argv[])\n   int jobserver = 0;\n   int auto_parallel = 0;\n   bool no_partition = false;\n-  struct cl_decoded_option *fdecoded_options = NULL;\n-  struct cl_decoded_option *offload_fdecoded_options = NULL;\n-  unsigned int fdecoded_options_count = 0;\n-  unsigned int offload_fdecoded_options_count = 0;\n-  struct cl_decoded_option *decoded_options;\n-  unsigned int decoded_options_count;\n+  vec<cl_decoded_option> fdecoded_options;\n+  fdecoded_options.create (16);\n+  vec<cl_decoded_option> offload_fdecoded_options = vNULL;\n   struct obstack argv_obstack;\n   int new_head_argc;\n   bool have_lto = false;\n@@ -1438,9 +1402,8 @@ run_gcc (unsigned argc, char *argv[])\n \t\t\t\t    NULL);\n     }\n \n-  get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options,\n-\t\t\t\t\t&decoded_options,\n-\t\t\t\t\t&decoded_options_count);\n+  vec<cl_decoded_option> decoded_options\n+    = get_options_from_collect_gcc_options (collect_gcc, collect_gcc_options);\n \n   /* Allocate array for input object files with LTO IL,\n      and for possible preceding arguments.  */\n@@ -1489,8 +1452,7 @@ run_gcc (unsigned argc, char *argv[])\n \t}\n \n       if (find_and_merge_options (fd, file_offset, LTO_SECTION_NAME_PREFIX,\n-\t\t\t\t  decoded_options, decoded_options_count,\n-\t\t\t\t  &fdecoded_options, &fdecoded_options_count,\n+\t\t\t\t  decoded_options, &fdecoded_options,\n \t\t\t\t  collect_gcc))\n \t{\n \t  have_lto = true;\n@@ -1505,14 +1467,13 @@ run_gcc (unsigned argc, char *argv[])\n   obstack_ptr_grow (&argv_obstack, \"-xlto\");\n   obstack_ptr_grow (&argv_obstack, \"-c\");\n \n-  append_compiler_options (&argv_obstack, fdecoded_options,\n-\t\t\t   fdecoded_options_count);\n-  append_linker_options (&argv_obstack, decoded_options, decoded_options_count);\n+  append_compiler_options (&argv_obstack, fdecoded_options);\n+  append_linker_options (&argv_obstack, decoded_options);\n \n   /* Scan linker driver arguments for things that are of relevance to us.  */\n-  for (j = 1; j < decoded_options_count; ++j)\n+  for (j = 1; j < decoded_options.length (); ++j)\n     {\n-      struct cl_decoded_option *option = &decoded_options[j];\n+      cl_decoded_option *option = &decoded_options[j];\n       switch (option->opt_index)\n \t{\n \tcase OPT_o:\n@@ -1731,9 +1692,7 @@ run_gcc (unsigned argc, char *argv[])\n \t    fatal_error (input_location, \"cannot open %s: %m\", filename);\n \t  if (!find_and_merge_options (fd, file_offset,\n \t\t\t\t       OFFLOAD_SECTION_NAME_PREFIX,\n-\t\t\t\t       decoded_options, decoded_options_count,\n-\t\t\t\t       &offload_fdecoded_options,\n-\t\t\t\t       &offload_fdecoded_options_count,\n+\t\t\t\t       decoded_options, &offload_fdecoded_options,\n \t\t\t\t       collect_gcc))\n \t    fatal_error (input_location, \"cannot read %s: %m\", filename);\n \t  close (fd);\n@@ -1742,10 +1701,7 @@ run_gcc (unsigned argc, char *argv[])\n \t}\n \n       compile_images_for_offload_targets (num_offload_files, offload_argv,\n-\t\t\t\t\t  offload_fdecoded_options,\n-\t\t\t\t\t  offload_fdecoded_options_count,\n-\t\t\t\t\t  decoded_options,\n-\t\t\t\t\t  decoded_options_count);\n+\t\t\t\t\t  offload_fdecoded_options, decoded_options);\n \n       free_array_of_ptrs ((void **) offload_argv, num_offload_files);\n "}]}