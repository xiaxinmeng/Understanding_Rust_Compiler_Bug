{"sha": "7fe4336e989ab447811231573647ef15f871c093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZlNDMzNmU5ODlhYjQ0NzgxMTIzMTU3MzY0N2VmMTVmODcxYzA5Mw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T21:06:37Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1992-08-19T21:06:37Z"}, "message": "(alloc_qty_for_scratch, block_alloc): Provide alternate code in some cases when REGISTER_CONSTRAINTS is not defined.\n\n(alloc_qty_for_scratch, block_alloc): Provide alternate code in some cases\nwhen REGISTER_CONSTRAINTS is not defined.\n(requires_inout_p): Only used when REGISTER_CONSTRAINTS is defined.\n\nFrom-SVN: r1899", "tree": {"sha": "29f1a4d7ad1d9106729fa22fcd087b138d837929", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/29f1a4d7ad1d9106729fa22fcd087b138d837929"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fe4336e989ab447811231573647ef15f871c093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fe4336e989ab447811231573647ef15f871c093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fe4336e989ab447811231573647ef15f871c093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fe4336e989ab447811231573647ef15f871c093/comments", "author": null, "committer": null, "parents": [{"sha": "26d970a5b93d150689f84c0649143959db4dd40e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/26d970a5b93d150689f84c0649143959db4dd40e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/26d970a5b93d150689f84c0649143959db4dd40e"}], "stats": {"total": 38, "additions": 36, "deletions": 2}, "files": [{"sha": "918f13fc982f418d159809a9baf3c90cf227e529", "filename": "gcc/local-alloc.c", "status": "modified", "additions": 36, "deletions": 2, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fe4336e989ab447811231573647ef15f871c093/gcc%2Flocal-alloc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fe4336e989ab447811231573647ef15f871c093/gcc%2Flocal-alloc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flocal-alloc.c?ref=7fe4336e989ab447811231573647ef15f871c093", "patch": "@@ -279,6 +279,7 @@ alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n   char *p, c;\n   int i;\n \n+#ifdef REGISTER_CONSTRAINTS\n   /* If we haven't yet computed which alternative will be used, do so now.\n      Then set P to the constraints for that alternative.  */\n   if (which_alternative == -1)\n@@ -335,6 +336,12 @@ alloc_qty_for_scratch (scratch, n, insn, insn_code_num, insn_number)\n   if (class == NO_REGS || reg_class_size[(int) class] == 1)\n     return;\n \n+#else /* REGISTER_CONSTRAINTS */\n+\n+  class = GENERAL_REGS;\n+#endif\n+  \n+\n   qty = next_qty++;\n \n   qty_first_reg[qty] = -1;\n@@ -1099,17 +1106,29 @@ block_alloc (b)\n \t     If tying is done, WIN is set nonzero.  */\n \n \t  if (insn_code_number >= 0\n+#ifdef REGISTER_CONSTRAINTS\n \t      && insn_n_operands[insn_code_number] > 1\n \t      && insn_operand_constraint[insn_code_number][0][0] == '='\n-\t      && insn_operand_constraint[insn_code_number][0][1] != '&')\n+\t      && insn_operand_constraint[insn_code_number][0][1] != '&'\n+#else\n+\t      && GET_CODE (PATTERN (insn)) == SET\n+\t      && rtx_equal_p (SET_DEST (PATTERN (insn)), recog_operand[0])\n+#endif\n+\t      )\n \t    {\n \t      r0 = recog_operand[0];\n \t      r1 = recog_operand[1];\n \n \t      /* If the first operand is an address, find a register in it.\n \t\t There may be more than one register, but we only try one of\n \t\t them.  */\n-\t      if (insn_operand_constraint[insn_code_number][1][0] == 'p')\n+\t      if (\n+#ifdef REGISTER_CONSTRAINTS\n+\t\t  insn_operand_constraint[insn_code_number][1][0] == 'p'\n+#else\n+\t\t  insn_operand_address_p[insn_code_number][1]\n+#endif\n+\t\t  )\n \t\twhile (GET_CODE (r1) == PLUS || GET_CODE (r1) == MULT)\n \t\t  r1 = XEXP (r1, 0);\n \n@@ -1119,18 +1138,30 @@ block_alloc (b)\n \t\t     If we have a move insn or an insn whose first input can\n \t\t     only be in the same register as the output, give\n \t\t     priority to an equivalence found from that insn.  */\n+#ifdef REGISTER_CONSTRAINTS\n \t\t  int may_save_copy\n \t\t    = ((SET_DEST (body) == r0 && SET_SRC (body) == r1)\n \t\t       || (r1 == recog_operand[1]\n \t\t\t   && (requires_inout_p (insn_operand_constraint[insn_code_number][1]))));\n+#else\n+\t\t  int may_save_copy = 0;\n+#endif\n \n \t\t  if (GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG)\n \t\t    win = combine_regs (r1, r0, may_save_copy,\n \t\t\t\t\tinsn_number, insn, 0);\n \n \t\t  if (win == 0\n \t\t      && insn_n_operands[insn_code_number] > 2\n+#ifdef REGISTER_CONSTRAINTS\n \t\t      && insn_operand_constraint[insn_code_number][1][0] == '%'\n+#else\n+\t\t      && GET_CODE (PATTERN (insn)) == SET\n+\t\t      && (GET_RTX_CLASS (GET_CODE (SET_SRC (PATTERN (insn))))\n+\t\t\t  == 'c')\n+\t\t      && rtx_equal_p (recog_operand[2],\n+\t\t\t\t      XEXP (SET_SRC (PATTERN (insn)), 0))\n+#endif\n \t\t      && (r1 = recog_operand[2],\n \t\t\t  GET_CODE (r1) == REG || GET_CODE (r1) == SUBREG))\n \t\t    win = combine_regs (r1, r0, may_save_copy,\n@@ -2017,6 +2048,8 @@ no_conflict_p (insn, r0, r1)\n   return ok;\n }\n \f\n+#ifdef REGISTER_CONSTRAINTS\n+\n /* Return 1 if the constraint string P indicates that the a the operand\n    must be equal to operand 0 and that no register is acceptable.  */\n \n@@ -2059,6 +2092,7 @@ requires_inout_p (p)\n \n   return found_zero;\n }\n+#endif /* REGISTER_CONSTRAINTS */\n \f\n void\n dump_local_alloc (file)"}]}