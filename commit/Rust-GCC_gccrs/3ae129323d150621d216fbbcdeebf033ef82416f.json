{"sha": "3ae129323d150621d216fbbcdeebf033ef82416f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FlMTI5MzIzZDE1MDYyMWQyMTZmYmJjZGVlYmYwMzNlZjgyNDE2Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-02-01T14:17:07Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-02-01T14:17:07Z"}, "message": "Use range info in split_constant_offset (PR 81635)\n\nThis patch implements the original suggestion for fixing PR 81635:\nuse range info in split_constant_offset to see whether a conversion\nof a wrapping type can be split.  The range info problem described in:\n\n    https://gcc.gnu.org/ml/gcc-patches/2017-08/msg01002.html\n\nseems to have been fixed.\n\nThe patch is part 1.  There needs to be a follow-on patch to handle:\n\n  for (unsigned int i = 0; i < n; i += 4)\n    {\n      ...[i + 2]...\n      ...[i + 3]...\n\nwhich the old SCEV test handles, but which the range check doesn't.\nAt the moment we record that the low two bits of \"i\" are clear,\nbut we still end up with a maximum range of 0xffffffff rather than\n0xfffffffc.\n\n2018-01-31  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\tPR tree-optimization/81635\n\t* tree-data-ref.c (split_constant_offset_1): For types that\n\twrap on overflow, try to use range info to prove that wrapping\n\tcannot occur.\n\ngcc/testsuite/\n\tPR tree-optimization/81635\n\t* gcc.dg/vect/bb-slp-pr81635-1.c: New test.\n\t* gcc.dg/vect/bb-slp-pr81635-2.c: Likewise.\n\nFrom-SVN: r257296", "tree": {"sha": "8f337d98834feaf4ab484aa6f606a11157bea238", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f337d98834feaf4ab484aa6f606a11157bea238"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ae129323d150621d216fbbcdeebf033ef82416f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae129323d150621d216fbbcdeebf033ef82416f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ae129323d150621d216fbbcdeebf033ef82416f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ae129323d150621d216fbbcdeebf033ef82416f/comments", "author": null, "committer": null, "parents": [{"sha": "d677263e6c6ce0b40ca791e97f7b2f4ab0718f03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d677263e6c6ce0b40ca791e97f7b2f4ab0718f03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d677263e6c6ce0b40ca791e97f7b2f4ab0718f03"}], "stats": {"total": 208, "additions": 206, "deletions": 2}, "files": [{"sha": "e62b93d9a38a5db38bbc5f0689f5ed81da08258a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3ae129323d150621d216fbbcdeebf033ef82416f", "patch": "@@ -1,3 +1,10 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81635\n+\t* tree-data-ref.c (split_constant_offset_1): For types that\n+\twrap on overflow, try to use range info to prove that wrapping\n+\tcannot occur.\n+\n 2018-02-01  Renlin Li  <renlin.li@arm.com>\n \n \tPR target/83370"}, {"sha": "3f2f44736115bc2e2cfc9adedc0b67331a77bae2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3ae129323d150621d216fbbcdeebf033ef82416f", "patch": "@@ -1,3 +1,9 @@\n+2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\tPR tree-optimization/81635\n+\t* gcc.dg/vect/bb-slp-pr81635-1.c: New test.\n+\t* gcc.dg/vect/bb-slp-pr81635-2.c: Likewise.\n+\n 2018-02-01  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \tPR target/83370"}, {"sha": "f024dc781112504fb99812a103ba4fb8bc6948c4", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-1.c", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-1.c?ref=3ae129323d150621d216fbbcdeebf033ef82416f", "patch": "@@ -0,0 +1,92 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-require-effective-target vect_double } */\n+/* { dg-require-effective-target lp64 } */\n+\n+void\n+f1 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < 1000; i += 4)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f2 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 2; i < ~0U - 4; i += 4)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+void\n+f3 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < ~0U - 3; i += 4)\n+    {\n+      double a = q[i + 2] + p[i + 2];\n+      double b = q[i + 3] + p[i + 3];\n+      q[i + 2] = a;\n+      q[i + 3] = b;\n+    }\n+}\n+\n+void\n+f4 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < 500; i += 6)\n+    for (unsigned int j = 0; j < 500; j += 4)\n+      {\n+\tdouble a = q[j] + p[i];\n+\tdouble b = q[j + 1] + p[i + 1];\n+\tq[i] = a;\n+\tq[i + 1] = b;\n+      }\n+}\n+\n+void\n+f5 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 2; i < 1000; i += 4)\n+    {\n+      double a = q[i - 2] + p[i - 2];\n+      double b = q[i - 1] + p[i - 1];\n+      q[i - 2] = a;\n+      q[i - 1] = b;\n+    }\n+}\n+\n+double p[1000];\n+double q[1000];\n+\n+void\n+f6 (int n)\n+{\n+  for (unsigned int i = 0; i < n; i += 4)\n+    {\n+      double a = q[i] + p[i];\n+      double b = q[i + 1] + p[i + 1];\n+      q[i] = a;\n+      q[i + 1] = b;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 6 \"slp1\" } } */"}, {"sha": "11e8f0f8526fbf1c108e168d51951a457935e996", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-pr81635-2.c", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-pr81635-2.c?ref=3ae129323d150621d216fbbcdeebf033ef82416f", "patch": "@@ -0,0 +1,64 @@\n+/* { dg-do compile } */\n+/* { dg-additional-options \"-fno-tree-loop-vectorize\" } */\n+/* { dg-require-effective-target lp64 } */\n+\n+double p[1000];\n+double q[1000];\n+\n+void\n+f1 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 2; i < ~0U - 4; i += 4)\n+    {\n+      double a = q[i + 2] + p[i + 2];\n+      double b = q[i + 3] + p[i + 3];\n+      q[i + 2] = a;\n+      q[i + 3] = b;\n+    }\n+}\n+\n+void\n+f2 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < ~0U - 3; i += 4)\n+    {\n+      double a = q[i + 4] + p[i + 4];\n+      double b = q[i + 5] + p[i + 5];\n+      q[i + 4] = a;\n+      q[i + 5] = b;\n+    }\n+}\n+\n+void\n+f3 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 0; i < 1000; i += 4)\n+    {\n+      double a = q[i - 2] + p[i - 2];\n+      double b = q[i - 1] + p[i - 1];\n+      q[i - 2] = a;\n+      q[i - 1] = b;\n+    }\n+}\n+\n+void\n+f4 (double *p, double *q)\n+{\n+  p = (double *) __builtin_assume_aligned (p, sizeof (double) * 2);\n+  q = (double *) __builtin_assume_aligned (q, sizeof (double) * 2);\n+  for (unsigned int i = 2; i < 1000; i += 4)\n+    {\n+      double a = q[i - 4] + p[i - 4];\n+      double b = q[i - 3] + p[i - 3];\n+      q[i - 4] = a;\n+      q[i - 3] = b;\n+    }\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"basic block vectorized\" \"slp1\" } } */"}, {"sha": "f3070d3a1188c9bc2821580ab5905cf1a55ab0c7", "filename": "gcc/tree-data-ref.c", "status": "modified", "additions": 37, "deletions": 2, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftree-data-ref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ae129323d150621d216fbbcdeebf033ef82416f/gcc%2Ftree-data-ref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-data-ref.c?ref=3ae129323d150621d216fbbcdeebf033ef82416f", "patch": "@@ -705,11 +705,46 @@ split_constant_offset_1 (tree type, tree op0, enum tree_code code, tree op1,\n \t   and the outer precision is at least as large as the inner.  */\n \ttree itype = TREE_TYPE (op0);\n \tif ((POINTER_TYPE_P (itype)\n-\t     || (INTEGRAL_TYPE_P (itype) && TYPE_OVERFLOW_UNDEFINED (itype)))\n+\t     || (INTEGRAL_TYPE_P (itype) && !TYPE_OVERFLOW_TRAPS (itype)))\n \t    && TYPE_PRECISION (type) >= TYPE_PRECISION (itype)\n \t    && (POINTER_TYPE_P (type) || INTEGRAL_TYPE_P (type)))\n \t  {\n-\t    split_constant_offset (op0, &var0, off);\n+\t    if (INTEGRAL_TYPE_P (itype) && TYPE_OVERFLOW_WRAPS (itype))\n+\t      {\n+\t\t/* Split the unconverted operand and try to prove that\n+\t\t   wrapping isn't a problem.  */\n+\t\ttree tmp_var, tmp_off;\n+\t\tsplit_constant_offset (op0, &tmp_var, &tmp_off);\n+\n+\t\t/* See whether we have an SSA_NAME whose range is known\n+\t\t   to be [A, B].  */\n+\t\tif (TREE_CODE (tmp_var) != SSA_NAME)\n+\t\t  return false;\n+\t\twide_int var_min, var_max;\n+\t\tif (get_range_info (tmp_var, &var_min, &var_max) != VR_RANGE)\n+\t\t  return false;\n+\n+\t\t/* See whether the range of OP0 (i.e. TMP_VAR + TMP_OFF)\n+\t\t   is known to be [A + TMP_OFF, B + TMP_OFF], with all\n+\t\t   operations done in ITYPE.  The addition must overflow\n+\t\t   at both ends of the range or at neither.  */\n+\t\tbool overflow[2];\n+\t\tsignop sgn = TYPE_SIGN (itype);\n+\t\tunsigned int prec = TYPE_PRECISION (itype);\n+\t\twide_int woff = wi::to_wide (tmp_off, prec);\n+\t\twide_int op0_min = wi::add (var_min, woff, sgn, &overflow[0]);\n+\t\twi::add (var_max, woff, sgn, &overflow[1]);\n+\t\tif (overflow[0] != overflow[1])\n+\t\t  return false;\n+\n+\t\t/* Calculate (ssizetype) OP0 - (ssizetype) TMP_VAR.  */\n+\t\twidest_int diff = (widest_int::from (op0_min, sgn)\n+\t\t\t\t   - widest_int::from (var_min, sgn));\n+\t\tvar0 = tmp_var;\n+\t\t*off = wide_int_to_tree (ssizetype, diff);\n+\t      }\n+\t    else\n+\t      split_constant_offset (op0, &var0, off);\n \t    *var = fold_convert (type, var0);\n \t    return true;\n \t  }"}]}