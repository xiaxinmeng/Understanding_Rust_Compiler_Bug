{"sha": "225e4f43cc46d861d30a3612e41dc935d95f36ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjI1ZTRmNDNjYzQ2ZDg2MWQzMGEzNjEyZTQxZGM5MzVkOTVmMzZiYQ==", "commit": {"author": {"name": "J\"orn Rennecke", "email": "amylaar@cygnus.co.uk", "date": "1998-11-23T08:50:42Z"}, "committer": {"name": "Joern Rennecke", "email": "amylaar@gcc.gnu.org", "date": "1998-11-23T08:50:42Z"}, "message": "Add SH4 support:\n\n\t* config/sh/lib1funcs.asm (___movstr_i4_even, ___movstr_i4_odd): Define.\n\t(___movstrSI12_i4, ___sdivsi3_i4, ___udivsi3_i4): Define.\n\t* sh.c (reg_class_from_letter, regno_reg_class): Add DF_REGS.\n\t(fp_reg_names, assembler_dialect): New variables.\n\t(print_operand_address): Handle SUBREGs.\n\t(print_operand): Added 'o' case.\n\tDon't use adj_offsettable_operand on PRE_DEC / POST_INC.\n\tName of FP registers depends on mode.\n\t(expand_block_move): Emit different code for SH4 hardware.\n\t(prepare_scc_operands): Use emit_sf_insn / emit_df_insn as appropriate.\n\t(from_compare): Likewise.\n\t(add_constant): New argument last_value.  Changed all callers.\n\t(find_barrier): Don't try HImode load for FPUL_REG.\n\t(machine_dependent_reorg): Likewise.\n\t(sfunc_uses_reg): A CLOBBER cannot be the address register use.\n\t(gen_far_branch): Emit a barrier after the new jump.\n\t(barrier_align): Don't trust instruction lengths before\n\tfixing up pcloads.\n\t(machine_dependent_reorg): Add support for FIRST_XD_REG .. LAST_XD_REG.\n\tUse auto-inc addressing for fp registers if doubles need to\n\tbe loaded in two steps.\n\tSet sh_flag_remove_dead_before_cse.\n\t(push): Support for TARGET_FMOVD.  Use gen_push_fpul for fpul.\n\t(pop): Support for TARGET_FMOVD.  Use gen_pop_fpul for fpul.\n\t(calc_live_regs): Support for TARGET_FMOVD.  Don't save FPSCR.\n\tSupport for FIRST_XD_REG .. LAST_XD_REG.\n\t(sh_expand_prologue): Support for FIRST_XD_REG .. LAST_XD_REG.\n\t(sh_expand_epilogue): Likewise.\n\t(sh_builtin_saveregs): Use DFmode moves for fp regs on SH4.\n\t(initial_elimination_offset): Take TARGET_ALIGN_DOUBLE into account.\n\t(arith_reg_operand): FPUL_REG is OK for SH4.\n\t(fp_arith_reg_operand, fp_extended_operand) New functions.\n\t(tertiary_reload_operand, fpscr_operand): Likewise.\n\t(commutative_float_operator, noncommutative_float_operator): Likewise.\n\t(binary_float_operator, get_fpscr_rtx, emit_sf_insn): Likewise.\n\t(emit_df_insn, expand_sf_unop, expand_sf_binop): Likewise.\n\t(expand_df_unop, expand_df_binop, expand_fp_branch): Likewise.\n\t(emit_fpscr_use, mark_use, remove_dead_before_cse): Likewise.\n\t* sh.h (CPP_SPEC): Add support for -m4, m4-single, m4-single-only.\n\t(CONDITIONAL_REGISTER_USAGE): Likewise.\n\t(HARD_SH4_BIT, FPU_SINGLE_BIT, SH4_BIT, FMOVD_BIT): Define.\n\t(TARGET_CACHE32, TARGET_SUPERSCALAR, TARGET_HARWARD): Define.\n\t(TARGET_HARD_SH4, TARGET_FPU_SINGLE, TARGET_SH4, TARGET_FMOVD): Define.\n\t(target_flag): Add -m4, m4-single, m4-single-only, -mfmovd.\n\t(OPTIMIZATION_OPTIONS): If optimizing, set flag_omit_frame_pointer\n\tto -1 and sh_flag_remove_dead_before_cse to 1.\n\t(ASSEMBLER_DIALECT): Define to assembler_dialect.\n\t(assembler_dialect, fp_reg_names): Declare.\n\t(OVERRIDE_OPTIONS): Add code for TARGET_SH4.\n\tHide names of registers that are not accessible.\n\t(CACHE_LOG): Take TARGET_CACHE32 into account.\n\t(LOOP_ALIGN): Take TARGET_HARWARD into account.\n\t(FIRST_XD_REG, LAST_XD_REG, FPSCR_REG): Define.\n\t(FIRST_PSEUDO_REGISTER: Now 49.\n\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Include values for registers.\n\t(HARD_REGNO_NREGS): Special treatment of FIRST_XD_REG .. LAST_XD_REG.\n\t(HARD_REGNO_MODE_OK): Update.\n\t(enum reg_class): Add DF_REGS and FPSCR_REGS.\n\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS, REG_ALLOC_ORDER): Likewise.\n\t(SECONDARY_OUTPUT_RELOAD_CLASS, SECONDARY_INPUT_RELOAD_CLASS): Update.\n\t(CLASS_CANNOT_CHANGE_SIZE, DEBUG_REGISTER_NAMES): Define.\n\t(NPARM_REGS): Eight floating point parameter registers on SH4.\n\t(BASE_RETURN_VALUE_REG): SH4 also passes double values\n\tin floating point registers.\n\t(GET_SH_ARG_CLASS) Likewise.\n\tComplex float types are also returned in float registers.\n\t(BASE_ARG_REG): Complex float types are also passes in float registers.\n\t(FUNCTION_VALUE): Change mode like PROMOTE_MODE does.\n\t(LIBCALL_VALUE): Remove trailing semicolon.\n\t(ROUND_REG): Round when double precision value is passed in floating\n\tpoint register(s).\n\t(FUNCTION_ARG_ADVANCE): No change wanted for SH4 when things are\n\tpassed on the stack.\n\t(FUNCTION_ARG): Little endian adjustment for SH4 SFmode.\n\t(FUNCTION_ARG_PARTIAL_NREGS): Zero for SH4.\n\t(TRAMPOLINE_ALIGNMENT): Take TARGET_HARWARD into account.\n\t(INITIALIZE_TRAMPOLINE): Emit ic_invalidate_line for TARGET_HARWARD.\n\t(MODE_DISP_OK_8): Not for SH4 DFmode.\n\t(GO_IF_LEGITIMATE_ADDRESS): No base reg + index reg for SH4 DFmode.\n\tAllow indexed addressing for PSImode after reload.\n\t(LEGITIMIZE_ADDRESS): Not for SH4 DFmode.\n\t(LEGITIMIZE_RELOAD_ADDRESS): Handle SH3E SFmode.\n\tDon't change SH4 DFmode nor PSImode RELOAD_FOR_INPUT_ADDRESS.\n\t(DOUBLE_TYPE_SIZE): 64 for SH4.\n\t(RTX_COSTS): Add PLUS case.\n\tIncreae cost of ASHIFT, ASHIFTRT, LSHIFTRT case.\n\t(REGISTER_MOVE_COST): Add handling of R0_REGS, FPUL_REGS, T_REGS,\n\tMAC_REGS, PR_REGS, DF_REGS.\n\t(REGISTER_NAMES): Use fp_reg_names.\n\t(enum processor_type): Add PROCESSOR_SH4.\n\t(sh_flag_remove_dead_before_cse): Declare.\n\t(rtx_equal_function_value_matters, fpscr_rtx, get_fpscr_rtx): Declare.\n\t(PREDICATE_CODES): Add binary_float_operator,\n\tcommutative_float_operator, fp_arith_reg_operand, fp_extended_operand,\n\tfpscr_operand, noncommutative_float_operator.\n\t(ADJUST_COST): Use different scale for TARGET_SUPERSCALAR.\n\t(SH_DYNAMIC_SHIFT_COST): Cheaper for SH4.\n\t* sh.md (attribute cpu): Add value sh4.\n\t(attrbutes fmovd, issues): Define.\n\t(attribute type): Add values dfp_arith, dfp_cmp, dfp_conv, dfdiv.\n\t(function units memory, int, mpy, fp): Make dependent on issue rate.\n\t(function units issue, single_issue, load_si, load): Define.\n\t(function units load_store, fdiv, gp_fpul): Define.\n\t(attribute hit_stack): Provide proper default.\n\t(use_sfunc_addr+1, udivsi3): Predicated on ! TARGET_SH4.\n\t(udivsi3_i4, udivsi3_i4_single, divsi3_i4, divsi3_i4_single): New insns.\n\t(udivsi3, divsi3): Emit special patterns for SH4 hardware,\n\t(mulsi3_call): Now uses match_operand for function address.\n\t(mulsi3): Also emit code for SH1 case.  Wrap result in REG_LIBCALL /\n\tREG_RETVAL notes.\n\t(push, pop, push_e, pop_e): Now define_expands.\n\t(push_fpul, push_4, pop_fpul, pop_4, ic_invalidate_line): New expanders.\n\t(movsi_ie): Added y/i alternative.\n\t(ic_invalidate_line_i, movdf_i4): New insns.\n\t(movdf_i4+[123], reload_outdf+[12345], movsi_y+[12]): New splitters.\n\t(reload_indf, reload_outdf, reload_outsf, reload_insi): New expanders.\n\t(movdf): Add special code for SH4.\n\t(movsf_ie, movsf_ie+1, reload_insf, calli): Make use of fpscr visible.\n\t(call_valuei, calli, call_value): Likewise.\n\t(movsf): Emit no-op move.\n\t(mov_nop, movsi_y): New insns.\n\t(blt, sge): generalize to handle DFmode.\n\t(return predicate): Call emit_fpscr_use and remove_dead_before_cse.\n\t(block_move_real, block_lump_real): Predicate on ! TARGET_HARD_SH4.\n\t(block_move_real_i4, block_lump_real_i4, fpu_switch): New insns.\n\t(fpu_switch0, fpu_switch1, movpsi): New expanders.\n\t(fpu_switch+[12], fix_truncsfsi2_i4_2+1): New splitters.\n\t(toggle_sz): New insn.\n\t(addsf3, subsf3, mulsf3, divsf3): Now define_expands.\n\t(addsf3_i, subsf3_i, mulsf3_i4, mulsf3_ie, divsf3_i): New insns.\n\t(macsf3): Make use of fpscr visible.  Disable for SH4.\n\t(floatsisf2): Make use of fpscr visible.\n\t(floatsisf2_i4): New insn.\n\t(floatsisf2_ie, fixsfsi, cmpgtsf_t, cmpeqsf_t): Disable for SH4.\n\t(ieee_ccmpeqsf_t): Likewise.\n\t(fix_truncsfsi2): Emit different code for SH4.\n\t(fix_truncsfsi2_i4, fix_truncsfsi2_i4_2, cmpgtsf_t_i4): New insns.\n\t(cmpeqsf_t_i4, ieee_ccmpeqsf_t_4): New insns.\n\t(negsf2, sqrtsf2, abssf2): Now expanders.\n\t(adddf3, subdf3i, muldf2, divdf3, floatsidf2): New expanders.\n\t(negsf2_i, sqrtsf2_i, abssf2_i, adddf3_i, subdf3_i): New insns.\n\t(muldf3_i, divdf3_i, floatsidf2_i, fix_truncdfsi2_i): New insns.\n\t(fix_truncdfsi2, cmpdf, negdf2, sqrtdf2, absdf2): New expanders.\n\t(fix_truncdfsi2_i4, cmpgtdf_t, cmpeqdf_t, ieee_ccmpeqdf_t): New insns.\n\t(fix_truncdfsi2_i4_2+1): New splitters.\n\t(negdf2_i, sqrtdf2_i, absdf2_i, extendsfdf2_i4): New insns.\n\t(extendsfdf2, truncdfsf2): New expanders.\n\t(truncdfsf2_i4): New insn.\n\t* t-sh (LIB1ASMFUNCS): Add _movstr_i4, _sdivsi3_i4, _udivsi3_i4.\n\t(MULTILIB_OPTIONS): Add m4-single-only/m4-single/m4.\n\t* float-sh.h: When testing for __SH3E__, also test for\n\t__SH4_SINGLE_ONLY__ .\n\t* va-sh.h (__va_freg): Define to float.\n\t(__va_greg, __fa_freg, __gnuc_va_list, va_start):\n        Define for __SH4_SINGLE_ONLY__ like for __SH3E__ .\n        (__PASS_AS_FLOAT, __TARGET_SH4_P): Likewise.\n\t(__PASS_AS_FLOAT): Use different definition for __SH4__ and\n\t __SH4_SINGLE__.\n\t(TARGET_SH4_P): Define.\n\t(va_arg): Use it.\n\t* sh.md (movdf_k, movsf_i): Tweak the condition so that\n\tinit_expr_once is satisfied about the existence of load / store insns.\n\t* sh.md (movsi_i, movsi_ie, movsi_i_lowpart, movsf_i, movsf_ie):\n        change m constraint in source operand to mr / mf .\n\t* va-sh.h (__va_arg_sh1): Use __asm instead of asm.\n\t* (__VA_REEF): Define.\n\t(__va_arg_sh1): Use it.\n\t* va-sh.h (va_start, va_arg, va_copy): Add parenteses.\n\nFrom-SVN: r23777", "tree": {"sha": "3b031571902a9a59de5eb52fde630438f4a30f90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b031571902a9a59de5eb52fde630438f4a30f90"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/225e4f43cc46d861d30a3612e41dc935d95f36ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225e4f43cc46d861d30a3612e41dc935d95f36ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/225e4f43cc46d861d30a3612e41dc935d95f36ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/225e4f43cc46d861d30a3612e41dc935d95f36ba/comments", "author": null, "committer": null, "parents": [{"sha": "57cfc5dd861a5807349c2ab5d590183a745a7a32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/57cfc5dd861a5807349c2ab5d590183a745a7a32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/57cfc5dd861a5807349c2ab5d590183a745a7a32"}], "stats": {"total": 3083, "additions": 2805, "deletions": 278}, "files": [{"sha": "89127e96afefdbfe1ab781ba38dc0441db516876", "filename": "gcc/ChangeLog", "status": "modified", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -1,3 +1,181 @@\n+Mon Nov 23 16:46:46 1998  J\"orn Rennecke <amylaar@cygnus.co.uk>\n+\n+\tAdd SH4 support:\n+\n+\t* config/sh/lib1funcs.asm (___movstr_i4_even, ___movstr_i4_odd): Define.\n+\t(___movstrSI12_i4, ___sdivsi3_i4, ___udivsi3_i4): Define.\n+\t* sh.c (reg_class_from_letter, regno_reg_class): Add DF_REGS.\n+\t(fp_reg_names, assembler_dialect): New variables.\n+\t(print_operand_address): Handle SUBREGs.\n+\t(print_operand): Added 'o' case.\n+\tDon't use adj_offsettable_operand on PRE_DEC / POST_INC.\n+\tName of FP registers depends on mode.\n+\t(expand_block_move): Emit different code for SH4 hardware.\n+\t(prepare_scc_operands): Use emit_sf_insn / emit_df_insn as appropriate.\n+\t(from_compare): Likewise.\n+\t(add_constant): New argument last_value.  Changed all callers.\n+\t(find_barrier): Don't try HImode load for FPUL_REG.\n+\t(machine_dependent_reorg): Likewise.\n+\t(sfunc_uses_reg): A CLOBBER cannot be the address register use.\n+\t(gen_far_branch): Emit a barrier after the new jump.\n+\t(barrier_align): Don't trust instruction lengths before\n+\tfixing up pcloads.\n+\t(machine_dependent_reorg): Add support for FIRST_XD_REG .. LAST_XD_REG.\n+\tUse auto-inc addressing for fp registers if doubles need to\n+\tbe loaded in two steps.\n+\tSet sh_flag_remove_dead_before_cse.\n+\t(push): Support for TARGET_FMOVD.  Use gen_push_fpul for fpul.\n+\t(pop): Support for TARGET_FMOVD.  Use gen_pop_fpul for fpul.\n+\t(calc_live_regs): Support for TARGET_FMOVD.  Don't save FPSCR.\n+\tSupport for FIRST_XD_REG .. LAST_XD_REG.\n+\t(sh_expand_prologue): Support for FIRST_XD_REG .. LAST_XD_REG.\n+\t(sh_expand_epilogue): Likewise.\n+\t(sh_builtin_saveregs): Use DFmode moves for fp regs on SH4.\n+\t(initial_elimination_offset): Take TARGET_ALIGN_DOUBLE into account.\n+\t(arith_reg_operand): FPUL_REG is OK for SH4.\n+\t(fp_arith_reg_operand, fp_extended_operand) New functions.\n+\t(tertiary_reload_operand, fpscr_operand): Likewise.\n+\t(commutative_float_operator, noncommutative_float_operator): Likewise.\n+\t(binary_float_operator, get_fpscr_rtx, emit_sf_insn): Likewise.\n+\t(emit_df_insn, expand_sf_unop, expand_sf_binop): Likewise.\n+\t(expand_df_unop, expand_df_binop, expand_fp_branch): Likewise.\n+\t(emit_fpscr_use, mark_use, remove_dead_before_cse): Likewise.\n+\t* sh.h (CPP_SPEC): Add support for -m4, m4-single, m4-single-only.\n+\t(CONDITIONAL_REGISTER_USAGE): Likewise.\n+\t(HARD_SH4_BIT, FPU_SINGLE_BIT, SH4_BIT, FMOVD_BIT): Define.\n+\t(TARGET_CACHE32, TARGET_SUPERSCALAR, TARGET_HARWARD): Define.\n+\t(TARGET_HARD_SH4, TARGET_FPU_SINGLE, TARGET_SH4, TARGET_FMOVD): Define.\n+\t(target_flag): Add -m4, m4-single, m4-single-only, -mfmovd.\n+\t(OPTIMIZATION_OPTIONS): If optimizing, set flag_omit_frame_pointer\n+\tto -1 and sh_flag_remove_dead_before_cse to 1.\n+\t(ASSEMBLER_DIALECT): Define to assembler_dialect.\n+\t(assembler_dialect, fp_reg_names): Declare.\n+\t(OVERRIDE_OPTIONS): Add code for TARGET_SH4.\n+\tHide names of registers that are not accessible.\n+\t(CACHE_LOG): Take TARGET_CACHE32 into account.\n+\t(LOOP_ALIGN): Take TARGET_HARWARD into account.\n+\t(FIRST_XD_REG, LAST_XD_REG, FPSCR_REG): Define.\n+\t(FIRST_PSEUDO_REGISTER: Now 49.\n+\t(FIXED_REGISTERS, CALL_USED_REGISTERS): Include values for registers.\n+\t(HARD_REGNO_NREGS): Special treatment of FIRST_XD_REG .. LAST_XD_REG.\n+\t(HARD_REGNO_MODE_OK): Update.\n+\t(enum reg_class): Add DF_REGS and FPSCR_REGS.\n+\t(REG_CLASS_NAMES, REG_CLASS_CONTENTS, REG_ALLOC_ORDER): Likewise.\n+\t(SECONDARY_OUTPUT_RELOAD_CLASS, SECONDARY_INPUT_RELOAD_CLASS): Update.\n+\t(CLASS_CANNOT_CHANGE_SIZE, DEBUG_REGISTER_NAMES): Define.\n+\t(NPARM_REGS): Eight floating point parameter registers on SH4.\n+\t(BASE_RETURN_VALUE_REG): SH4 also passes double values\n+\tin floating point registers.\n+\t(GET_SH_ARG_CLASS) Likewise.\n+\tComplex float types are also returned in float registers.\n+\t(BASE_ARG_REG): Complex float types are also passes in float registers.\n+\t(FUNCTION_VALUE): Change mode like PROMOTE_MODE does.\n+\t(LIBCALL_VALUE): Remove trailing semicolon.\n+\t(ROUND_REG): Round when double precision value is passed in floating\n+\tpoint register(s).\n+\t(FUNCTION_ARG_ADVANCE): No change wanted for SH4 when things are\n+\tpassed on the stack.\n+\t(FUNCTION_ARG): Little endian adjustment for SH4 SFmode.\n+\t(FUNCTION_ARG_PARTIAL_NREGS): Zero for SH4.\n+\t(TRAMPOLINE_ALIGNMENT): Take TARGET_HARWARD into account.\n+\t(INITIALIZE_TRAMPOLINE): Emit ic_invalidate_line for TARGET_HARWARD.\n+\t(MODE_DISP_OK_8): Not for SH4 DFmode.\n+\t(GO_IF_LEGITIMATE_ADDRESS): No base reg + index reg for SH4 DFmode.\n+\tAllow indexed addressing for PSImode after reload.\n+\t(LEGITIMIZE_ADDRESS): Not for SH4 DFmode.\n+\t(LEGITIMIZE_RELOAD_ADDRESS): Handle SH3E SFmode.\n+\tDon't change SH4 DFmode nor PSImode RELOAD_FOR_INPUT_ADDRESS.\n+\t(DOUBLE_TYPE_SIZE): 64 for SH4.\n+\t(RTX_COSTS): Add PLUS case.\n+\tIncreae cost of ASHIFT, ASHIFTRT, LSHIFTRT case.\n+\t(REGISTER_MOVE_COST): Add handling of R0_REGS, FPUL_REGS, T_REGS,\n+\tMAC_REGS, PR_REGS, DF_REGS.\n+\t(REGISTER_NAMES): Use fp_reg_names.\n+\t(enum processor_type): Add PROCESSOR_SH4.\n+\t(sh_flag_remove_dead_before_cse): Declare.\n+\t(rtx_equal_function_value_matters, fpscr_rtx, get_fpscr_rtx): Declare.\n+\t(PREDICATE_CODES): Add binary_float_operator,\n+\tcommutative_float_operator, fp_arith_reg_operand, fp_extended_operand,\n+\tfpscr_operand, noncommutative_float_operator.\n+\t(ADJUST_COST): Use different scale for TARGET_SUPERSCALAR.\n+\t(SH_DYNAMIC_SHIFT_COST): Cheaper for SH4.\n+\t* sh.md (attribute cpu): Add value sh4.\n+\t(attrbutes fmovd, issues): Define.\n+\t(attribute type): Add values dfp_arith, dfp_cmp, dfp_conv, dfdiv.\n+\t(function units memory, int, mpy, fp): Make dependent on issue rate.\n+\t(function units issue, single_issue, load_si, load): Define.\n+\t(function units load_store, fdiv, gp_fpul): Define.\n+\t(attribute hit_stack): Provide proper default.\n+\t(use_sfunc_addr+1, udivsi3): Predicated on ! TARGET_SH4.\n+\t(udivsi3_i4, udivsi3_i4_single, divsi3_i4, divsi3_i4_single): New insns.\n+\t(udivsi3, divsi3): Emit special patterns for SH4 hardware,\n+\t(mulsi3_call): Now uses match_operand for function address.\n+\t(mulsi3): Also emit code for SH1 case.  Wrap result in REG_LIBCALL /\n+\tREG_RETVAL notes.\n+\t(push, pop, push_e, pop_e): Now define_expands.\n+\t(push_fpul, push_4, pop_fpul, pop_4, ic_invalidate_line): New expanders.\n+\t(movsi_ie): Added y/i alternative.\n+\t(ic_invalidate_line_i, movdf_i4): New insns.\n+\t(movdf_i4+[123], reload_outdf+[12345], movsi_y+[12]): New splitters.\n+\t(reload_indf, reload_outdf, reload_outsf, reload_insi): New expanders.\n+\t(movdf): Add special code for SH4.\n+\t(movsf_ie, movsf_ie+1, reload_insf, calli): Make use of fpscr visible.\n+\t(call_valuei, calli, call_value): Likewise.\n+\t(movsf): Emit no-op move.\n+\t(mov_nop, movsi_y): New insns.\n+\t(blt, sge): generalize to handle DFmode.\n+\t(return predicate): Call emit_fpscr_use and remove_dead_before_cse.\n+\t(block_move_real, block_lump_real): Predicate on ! TARGET_HARD_SH4.\n+\t(block_move_real_i4, block_lump_real_i4, fpu_switch): New insns.\n+\t(fpu_switch0, fpu_switch1, movpsi): New expanders.\n+\t(fpu_switch+[12], fix_truncsfsi2_i4_2+1): New splitters.\n+\t(toggle_sz): New insn.\n+\t(addsf3, subsf3, mulsf3, divsf3): Now define_expands.\n+\t(addsf3_i, subsf3_i, mulsf3_i4, mulsf3_ie, divsf3_i): New insns.\n+\t(macsf3): Make use of fpscr visible.  Disable for SH4.\n+\t(floatsisf2): Make use of fpscr visible.\n+\t(floatsisf2_i4): New insn.\n+\t(floatsisf2_ie, fixsfsi, cmpgtsf_t, cmpeqsf_t): Disable for SH4.\n+\t(ieee_ccmpeqsf_t): Likewise.\n+\t(fix_truncsfsi2): Emit different code for SH4.\n+\t(fix_truncsfsi2_i4, fix_truncsfsi2_i4_2, cmpgtsf_t_i4): New insns.\n+\t(cmpeqsf_t_i4, ieee_ccmpeqsf_t_4): New insns.\n+\t(negsf2, sqrtsf2, abssf2): Now expanders.\n+\t(adddf3, subdf3i, muldf2, divdf3, floatsidf2): New expanders.\n+\t(negsf2_i, sqrtsf2_i, abssf2_i, adddf3_i, subdf3_i): New insns.\n+\t(muldf3_i, divdf3_i, floatsidf2_i, fix_truncdfsi2_i): New insns.\n+\t(fix_truncdfsi2, cmpdf, negdf2, sqrtdf2, absdf2): New expanders.\n+\t(fix_truncdfsi2_i4, cmpgtdf_t, cmpeqdf_t, ieee_ccmpeqdf_t): New insns.\n+\t(fix_truncdfsi2_i4_2+1): New splitters.\n+\t(negdf2_i, sqrtdf2_i, absdf2_i, extendsfdf2_i4): New insns.\n+\t(extendsfdf2, truncdfsf2): New expanders.\n+\t(truncdfsf2_i4): New insn.\n+\t* t-sh (LIB1ASMFUNCS): Add _movstr_i4, _sdivsi3_i4, _udivsi3_i4.\n+\t(MULTILIB_OPTIONS): Add m4-single-only/m4-single/m4.\n+\t* float-sh.h: When testing for __SH3E__, also test for\n+\t__SH4_SINGLE_ONLY__ .\n+\t* va-sh.h (__va_freg): Define to float.\n+\t(__va_greg, __fa_freg, __gnuc_va_list, va_start):\n+        Define for __SH4_SINGLE_ONLY__ like for __SH3E__ .\n+        (__PASS_AS_FLOAT, __TARGET_SH4_P): Likewise.\n+\t(__PASS_AS_FLOAT): Use different definition for __SH4__ and\n+\t __SH4_SINGLE__.\n+\t(TARGET_SH4_P): Define.\n+\t(va_arg): Use it.\n+\n+\t* sh.md (movdf_k, movsf_i): Tweak the condition so that\n+\tinit_expr_once is satisfied about the existence of load / store insns.\n+\n+\t* sh.md (movsi_i, movsi_ie, movsi_i_lowpart, movsf_i, movsf_ie):\n+        change m constraint in source operand to mr / mf .\n+\n+\t* va-sh.h (__va_arg_sh1): Use __asm instead of asm.\n+\n+\t* (__VA_REEF): Define.\n+\t(__va_arg_sh1): Use it.\n+\n+\t* va-sh.h (va_start, va_arg, va_copy): Add parenteses.\n+\n Sun Nov 22 21:34:02 1998  Jeffrey A Law  (law@cygnus.com)\n \n \t* i386/dgux.c (struct option): Add new \"description field\"."}, {"sha": "446692428c2e42d521d4e1e1bff67e101846da4c", "filename": "gcc/config/float-sh.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Ffloat-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Ffloat-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffloat-sh.h?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -37,7 +37,7 @@\n #undef FLT_MAX_10_EXP\n #define FLT_MAX_10_EXP 38\n \n-#ifdef __SH3E__\n+#if defined (__SH3E__) || defined (__SH4_SINGLE_ONLY__)\n \n    /* Number of base-FLT_RADIX digits in the significand of a double */\n #undef DBL_MANT_DIG"}, {"sha": "06017e6e873a1f9bd3fe59a373f586d52e712e04", "filename": "gcc/config/sh/lib1funcs.asm", "status": "modified", "additions": 216, "deletions": 4, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Flib1funcs.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Flib1funcs.asm?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -770,6 +770,64 @@ ___movstr:\n \tadd\t#64,r4\n #endif\n \n+#ifdef L_movstr_i4\n+#if defined(__SH4__) || defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n+\t.text\n+\t.global\t___movstr_i4_even\n+\t.global\t___movstr_i4_odd\n+\t.global\t___movstrSI12_i4\n+\n+\t.p2align\t5\n+L_movstr_2mod4_end:\n+\tmov.l\tr0,@(16,r4)\n+\trts\n+\tmov.l\tr1,@(20,r4)\n+\n+\t.p2align\t2\n+\n+___movstr_i4_odd:\n+\tmov.l\t@r5+,r1\n+\tadd\t#-4,r4\n+\tmov.l\t@r5+,r2\n+\tmov.l\t@r5+,r3\n+\tmov.l\tr1,@(4,r4)\n+\tmov.l\tr2,@(8,r4)\n+\n+L_movstr_loop:\n+\tmov.l\tr3,@(12,r4)\n+\tdt\tr6\n+\tmov.l\t@r5+,r0\n+\tbt/s\tL_movstr_2mod4_end\n+\tmov.l\t@r5+,r1\n+\tadd\t#16,r4\n+L_movstr_start_even:\n+\tmov.l\t@r5+,r2\n+\tmov.l\t@r5+,r3\n+\tmov.l\tr0,@r4\n+\tdt\tr6\n+\tmov.l\tr1,@(4,r4)\n+\tbf/s\tL_movstr_loop\n+\tmov.l\tr2,@(8,r4)\n+\trts\n+\tmov.l\tr3,@(12,r4)\n+\n+___movstr_i4_even:\n+\tmov.l\t@r5+,r0\n+\tbra\tL_movstr_start_even\n+\tmov.l\t@r5+,r1\n+\n+\t.p2align\t4\n+___movstrSI12_i4:\n+\tmov.l\t@r5,r0\n+\tmov.l\t@(4,r5),r1\n+\tmov.l\t@(8,r5),r2\n+\tmov.l\tr0,@r4\n+\tmov.l\tr1,@(4,r4)\n+\trts\n+\tmov.l\tr2,@(8,r4)\n+#endif /* ! __SH4__ */\n+#endif\n+\n #ifdef L_mulsi3\n \n \n@@ -808,9 +866,47 @@ hiset:\tsts\tmacl,r0\t\t! r0 = bb*dd\n \n \n #endif\n-#ifdef L_sdivsi3\n+#ifdef L_sdivsi3_i4\n \t.title \"SH DIVIDE\"\n !! 4 byte integer Divide code for the Hitachi SH\n+#ifdef __SH4__\n+!! args in r4 and r5, result in fpul, clobber dr0, dr2\n+\n+\t.global\t___sdivsi3_i4\n+___sdivsi3_i4:\n+\tlds r4,fpul\n+\tfloat fpul,dr0\n+\tlds r5,fpul\n+\tfloat fpul,dr2\n+\tfdiv dr2,dr0\n+\trts\n+\tftrc dr0,fpul\n+\n+#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n+!! args in r4 and r5, result in fpul, clobber r2, dr0, dr2\n+\n+\t.global\t___sdivsi3_i4\n+___sdivsi3_i4:\n+\tsts.l fpscr,@-r15\n+\tmov #8,r2\n+\tswap.w r2,r2\n+\tlds r2,fpscr\n+\tlds r4,fpul\n+\tfloat fpul,dr0\n+\tlds r5,fpul\n+\tfloat fpul,dr2\n+\tfdiv dr2,dr0\n+\tftrc dr0,fpul\n+\trts\n+\tlds.l @r15+,fpscr\n+\n+#endif /* ! __SH4__ */\n+#endif\n+\n+#ifdef L_sdivsi3\n+/* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with\n+   sh3e code.  */\n+#if ! defined(__SH4__) && ! defined (__SH4_SINGLE__)\n !!\n !! Steve Chamberlain\n !! sac@cygnus.com\n@@ -904,11 +1000,109 @@ ___sdivsi3:\n div0:\trts\n \tmov\t#0,r0\n \n+#endif /* ! __SH4__ */\n #endif\n-#ifdef L_udivsi3\n+#ifdef L_udivsi3_i4\n \n \t.title \"SH DIVIDE\"\n !! 4 byte integer Divide code for the Hitachi SH\n+#ifdef __SH4__\n+!! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4\n+\n+\t.global\t___udivsi3_i4\n+___udivsi3_i4:\n+\tmov #1,r1\n+\tcmp/hi r1,r5\n+\tbf trivial\n+\trotr r1\n+\txor r1,r4\n+\tlds r4,fpul\n+\tmova L1,r0\n+#ifdef FMOVD_WORKS\n+\tfmov.d @r0+,dr4\n+#else\n+#ifdef __LITTLE_ENDIAN__\n+\tfmov.s @r0+,fr5\n+\tfmov.s @r0,fr4\n+#else\n+\tfmov.s @r0+,fr4\n+\tfmov.s @r0,fr5\n+#endif\n+#endif\n+\tfloat fpul,dr0\n+\txor r1,r5\n+\tlds r5,fpul\n+\tfloat fpul,dr2\n+\tfadd dr4,dr0\n+\tfadd dr4,dr2\n+\tfdiv dr2,dr0\n+\trts\n+\tftrc dr0,fpul\n+\n+trivial:\n+\trts\n+\tlds r4,fpul\n+\n+\t.align 2\n+L1:\n+\t.double 2147483648\n+\n+#elif defined(__SH4_SINGLE__) || defined(__SH4_SINGLE_ONLY__)\n+!! args in r4 and r5, result in fpul, clobber r0, r1, r4, r5, dr0, dr2, dr4\n+\n+\t.global\t___udivsi3_i4\n+___udivsi3_i4:\n+\tmov #1,r1\n+\tcmp/hi r1,r5\n+\tbf trivial\n+\tsts.l fpscr,@-r15\n+\tmova L1,r0\n+\tlds.l @r0+,fpscr\n+\trotr r1\n+\txor r1,r4\n+\tlds r4,fpul\n+#ifdef FMOVD_WORKS\n+\tfmov.d @r0+,dr4\n+#else\n+#ifdef __LITTLE_ENDIAN__\n+\tfmov.s @r0+,fr5\n+\tfmov.s @r0,fr4\n+#else\n+\tfmov.s @r0+,fr4\n+\tfmov.s @r0,fr5\n+#endif\n+#endif\n+\tfloat fpul,dr0\n+\txor r1,r5\n+\tlds r5,fpul\n+\tfloat fpul,dr2\n+\tfadd dr4,dr0\n+\tfadd dr4,dr2\n+\tfdiv dr2,dr0\n+\tftrc dr0,fpul\n+\trts\n+\tlds.l @r15+,fpscr\n+\n+trivial:\n+\trts\n+\tlds r4,fpul\n+\n+\t.align 2\n+L1:\n+#ifdef __LITTLE_ENDIAN__\n+\t.long 0x80000\n+#else\n+\t.long 0x180000\n+#endif\n+\t.double 2147483648\n+\n+#endif /* ! __SH4__ */\n+#endif\n+\n+#ifdef L_udivsi3\n+/* __SH4_SINGLE_ONLY__ keeps this part for link compatibility with\n+   sh3e code.  */\n+#if ! defined(__SH4__) && ! defined (__SH4_SINGLE__)\n !!\n !! Steve Chamberlain\n !! sac@cygnus.com\n@@ -966,22 +1160,40 @@ vshortway:\n ret:\trts\n \tmov\tr4,r0\n \n+#endif /* __SH4__ */\n #endif\n #ifdef L_set_fpscr\n-#if defined (__SH3E__)\n+#if defined (__SH3E__) || defined(__SH4_SINGLE__) || defined(__SH4__) || defined(__SH4_SINGLE_ONLY__)\n \t.global ___set_fpscr\n ___set_fpscr:\n \tlds r4,fpscr\n \tmov.l ___set_fpscr_L1,r1\n \tswap.w r4,r0\n \tor #24,r0\n+#ifndef FMOVD_WORKS\n \txor #16,r0\n+#endif\n+#if defined(__SH4__)\n+\tswap.w r0,r3\n+\tmov.l r3,@(4,r1)\n+#else /* defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n \tswap.w r0,r2\n \tmov.l r2,@r1\n+#endif\n+#ifndef FMOVD_WORKS\n \txor #8,r0\n+#else\n+\txor #24,r0\n+#endif\n+#if defined(__SH4__)\n+\tswap.w r0,r2\n+\trts\n+\tmov.l r2,@r1\n+#else /* defined(__SH3E__) || defined(__SH4_SINGLE*__) */\n \tswap.w r0,r3\n \trts\n \tmov.l r3,@(4,r1)\n+#endif\n \t.align 2\n ___set_fpscr_L1:\n \t.long ___fpscr_values\n@@ -990,5 +1202,5 @@ ___set_fpscr_L1:\n #else\n         .comm   ___fpscr_values,8\n #endif /* ELF */\n-#endif /* SH3E */\n+#endif /* SH3E / SH4 */\n #endif /* L_set_fpscr */"}, {"sha": "9184528933bf26f9e13f68532381e90fa53c56a1", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 689, "deletions": 60, "changes": 749, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -1,5 +1,5 @@\n /* Output routines for GCC for Hitachi Super-H.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1998 Free Software Foundation, Inc.\n \n This file is part of GNU CC.\n \n@@ -103,14 +103,25 @@ int regno_reg_class[FIRST_PSEUDO_REGISTER] =\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n   FP_REGS, FP_REGS, FP_REGS, FP_REGS,\n+  DF_REGS, DF_REGS, DF_REGS, DF_REGS,\n+  DF_REGS, DF_REGS, DF_REGS, DF_REGS,\n+  FPSCR_REGS,\n+};\n+\n+char fp_reg_names[][5] =\n+{\n+  \"fr0\", \"fr1\", \"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\",\n+  \"fr8\", \"fr9\", \"fr10\", \"fr11\", \"fr12\", \"fr13\", \"fr14\", \"fr15\",\n+  \"fpul\",\n+  \"xd0\",\"xd2\",\"xd4\", \"xd6\", \"xd8\", \"xd10\", \"xd12\", \"xd14\",\n };\n \n /* Provide reg_class from a letter such as appears in the machine\n    description.  */\n \n enum reg_class reg_class_from_letter[] =\n {\n-  /* a */ NO_REGS, /* b */ NO_REGS, /* c */ NO_REGS, /* d */ NO_REGS,\n+  /* a */ ALL_REGS, /* b */ NO_REGS, /* c */ FPSCR_REGS, /* d */ DF_REGS,\n   /* e */ NO_REGS, /* f */ FP_REGS, /* g */ NO_REGS, /* h */ NO_REGS,\n   /* i */ NO_REGS, /* j */ NO_REGS, /* k */ NO_REGS, /* l */ PR_REGS,\n   /* m */ NO_REGS, /* n */ NO_REGS, /* o */ NO_REGS, /* p */ NO_REGS,\n@@ -119,6 +130,12 @@ enum reg_class reg_class_from_letter[] =\n   /* y */ FPUL_REGS, /* z */ R0_REGS\n };\n \n+int assembler_dialect;\n+\n+rtx get_fpscr_rtx ();\n+void emit_sf_insn ();\n+void emit_df_insn ();\n+\n static void split_branches PROTO ((rtx));\n \f\n /* Print the operand address in x to the stream.  */\n@@ -131,7 +148,8 @@ print_operand_address (stream, x)\n   switch (GET_CODE (x))\n     {\n     case REG:\n-      fprintf (stream, \"@%s\", reg_names[REGNO (x)]);\n+    case SUBREG:\n+      fprintf (stream, \"@%s\", reg_names[true_regnum (x)]);\n       break;\n \n     case PLUS:\n@@ -143,13 +161,19 @@ print_operand_address (stream, x)\n \t  {\n \t  case CONST_INT:\n \t    fprintf (stream, \"@(%d,%s)\", INTVAL (index),\n-\t\t     reg_names[REGNO (base)]);\n+\t\t     reg_names[true_regnum (base)]);\n \t    break;\n \n \t  case REG:\n-\t    fprintf (stream, \"@(r0,%s)\",\n-\t\t     reg_names[MAX (REGNO (base), REGNO (index))]);\n-\t    break;\n+\t  case SUBREG:\n+\t    {\n+\t      int base_num = true_regnum (base);\n+\t      int index_num = true_regnum (index);\n+\n+\t      fprintf (stream, \"@(r0,%s)\",\n+\t\t       reg_names[MAX (base_num, index_num)]);\n+\t      break;\n+\t    }\n \n \t  default:\n \t    debug_rtx (x);\n@@ -159,11 +183,11 @@ print_operand_address (stream, x)\n       break;\n \n     case PRE_DEC:\n-      fprintf (stream, \"@-%s\", reg_names[REGNO (XEXP (x, 0))]);\n+      fprintf (stream, \"@-%s\", reg_names[true_regnum (XEXP (x, 0))]);\n       break;\n \n     case POST_INC:\n-      fprintf (stream, \"@%s+\", reg_names[REGNO (XEXP (x, 0))]);\n+      fprintf (stream, \"@%s+\", reg_names[true_regnum (XEXP (x, 0))]);\n       break;\n \n     default:\n@@ -182,7 +206,8 @@ print_operand_address (stream, x)\n    'O'  print a constant without the #\n    'R'  print the LSW of a dp value - changes if in little endian\n    'S'  print the MSW of a dp value - changes if in little endian\n-   'T'  print the next word of a dp value - same as 'R' in big endian mode.  */\n+   'T'  print the next word of a dp value - same as 'R' in big endian mode.\n+   'o'  output an operator.  */\n \n void\n print_operand (stream, x, code)\n@@ -230,16 +255,31 @@ print_operand (stream, x, code)\n \t  fputs (reg_names[REGNO (x) + 1], (stream));\n \t  break;\n \tcase MEM:\n-\t  print_operand_address (stream,\n-\t\t\t\t XEXP (adj_offsettable_operand (x, 4), 0));\n+\t  if (GET_CODE (XEXP (x, 0)) != PRE_DEC\n+\t      && GET_CODE (XEXP (x, 0)) != POST_INC)\n+\t    x = adj_offsettable_operand (x, 4);\n+\t  print_operand_address (stream, XEXP (x, 0));\n \t  break;\n \t}\n       break;\n+    case 'o':\n+      switch (GET_CODE (x))\n+\t{\n+\tcase PLUS:  fputs (\"add\", stream); break;\n+\tcase MINUS: fputs (\"sub\", stream); break;\n+\tcase MULT:  fputs (\"mul\", stream); break;\n+\tcase DIV:   fputs (\"div\", stream); break;\n+\t}\n+      break;\n     default:\n       switch (GET_CODE (x))\n \t{\n \tcase REG:\n-\t  fputs (reg_names[REGNO (x)], (stream));\n+\t  if (REGNO (x) >= FIRST_FP_REG && REGNO (x) <= LAST_FP_REG\n+\t      && GET_MODE_SIZE (GET_MODE (x)) > 4)\n+\t    fprintf ((stream), \"d%s\", reg_names[REGNO (x)]+1);\n+\t  else\n+\t    fputs (reg_names[REGNO (x)], (stream));\n \t  break;\n \tcase MEM:\n \t  output_address (XEXP (x, 0));\n@@ -273,6 +313,55 @@ expand_block_move (operands)\n   if (! constp || align < 4 || (bytes % 4 != 0))\n     return 0;\n \n+  if (TARGET_HARD_SH4)\n+    {\n+      if (bytes < 12)\n+\treturn 0;\n+      else if (bytes == 12)\n+\t{\n+\t  tree entry_name;\n+\t  rtx func_addr_rtx;\n+\t  rtx r4 = gen_rtx (REG, SImode, 4);\n+\t  rtx r5 = gen_rtx (REG, SImode, 5);\n+\n+\t  entry_name = get_identifier (\"__movstrSI12_i4\");\n+\n+\t  func_addr_rtx\n+\t    = copy_to_mode_reg (Pmode,\n+\t\t\t\tgen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t    IDENTIFIER_POINTER (entry_name)));\n+\t  emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n+\t  emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n+\t  emit_insn (gen_block_move_real_i4 (func_addr_rtx));\n+\t  return 1;\n+\t}\n+      else if (! TARGET_SMALLCODE)\n+\t{\n+\t  tree entry_name;\n+\t  rtx func_addr_rtx;\n+\t  int dwords;\n+\t  rtx r4 = gen_rtx (REG, SImode, 4);\n+\t  rtx r5 = gen_rtx (REG, SImode, 5);\n+\t  rtx r6 = gen_rtx (REG, SImode, 6);\n+\n+\t  entry_name = get_identifier (bytes & 4\n+\t\t\t\t       ? \"__movstr_i4_odd\"\n+\t\t\t\t       : \"__movstr_i4_even\");\n+\t  func_addr_rtx\n+\t    = copy_to_mode_reg (Pmode,\n+\t\t\t\tgen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t\t\t\t    IDENTIFIER_POINTER (entry_name)));\n+\t  emit_insn (gen_move_insn (r4, XEXP (operands[0], 0)));\n+\t  emit_insn (gen_move_insn (r5, XEXP (operands[1], 0)));\n+\n+\t  dwords = bytes >> 3;\n+\t  emit_insn (gen_move_insn (r6, GEN_INT (dwords - 1)));\n+\t  emit_insn (gen_block_lump_real_i4 (func_addr_rtx));\n+\t  return 1;\n+\t}\n+      else\n+\treturn 0;\n+    }\n   if (bytes < 64)\n     {\n       char entry[30];\n@@ -405,9 +494,17 @@ prepare_scc_operands (code)\n       || TARGET_SH3E && GET_MODE_CLASS (mode) == MODE_FLOAT)\n     sh_compare_op1 = force_reg (mode, sh_compare_op1);\n \n-  emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n-\t\t      gen_rtx (code, SImode, sh_compare_op0,\n-\t\t\t       sh_compare_op1)));\n+  if (TARGET_SH4 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    (mode == SFmode ? emit_sf_insn : emit_df_insn)\n+     (gen_rtx (PARALLEL, VOIDmode, gen_rtvec (2,\n+\t\tgen_rtx (SET, VOIDmode, t_reg,\n+\t\t\t gen_rtx (code, SImode,\n+\t\t\t\t  sh_compare_op0, sh_compare_op1)),\n+\t\tgen_rtx (USE, VOIDmode, get_fpscr_rtx ()))));\n+  else\n+    emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n+\t\t\tgen_rtx (code, SImode, sh_compare_op0,\n+\t\t\t\t sh_compare_op1)));\n \n   return t_reg;\n }\n@@ -443,7 +540,15 @@ from_compare (operands, code)\n     insn = gen_rtx (SET, VOIDmode,\n \t\t    gen_rtx (REG, SImode, 18),\n \t\t    gen_rtx (code, SImode, sh_compare_op0, sh_compare_op1));\n-  emit_insn (insn);\n+  if (TARGET_SH4 && GET_MODE_CLASS (mode) == MODE_FLOAT)\n+    {\n+      insn = gen_rtx (PARALLEL, VOIDmode,\n+\t\t      gen_rtvec (2, insn,\n+\t\t\t\t gen_rtx (USE, VOIDmode, get_fpscr_rtx ())));\n+      (mode == SFmode ? emit_sf_insn : emit_df_insn) (insn);\n+    }\n+  else\n+    emit_insn (insn);\n }\n \f\n /* Functions to output assembly code.  */\n@@ -1722,7 +1827,8 @@ static int pool_size;\n /* Add a constant to the pool and return its label.  */\n \n static rtx\n-add_constant (x, mode)\n+add_constant (x, mode, last_value)\n+     rtx last_value;\n      rtx x;\n      enum machine_mode mode;\n {\n@@ -1741,13 +1847,27 @@ add_constant (x, mode)\n \t\tcontinue;\n \t    }\n \t  if (rtx_equal_p (x, pool_vector[i].value))\n-\t    return pool_vector[i].label;\n+\t    {\n+\t      lab = 0;\n+\t      if (! last_value\n+\t\t  || ! i\n+\t\t  || ! rtx_equal_p (last_value, pool_vector[i-1].value))\n+\t\t{\n+\t\t  lab = pool_vector[i].label;\n+\t\t  if (! lab)\n+\t\t    pool_vector[i].label = lab = gen_label_rtx ();\n+\t\t}\n+\t      return lab;\n+\t    }\n \t}\n     }\n \n   /* Need a new one.  */\n   pool_vector[pool_size].value = x;\n-  lab = gen_label_rtx ();\n+  if (last_value && rtx_equal_p (last_value, pool_vector[pool_size - 1].value))\n+    lab = 0;\n+  else\n+    lab = gen_label_rtx ();\n   pool_vector[pool_size].mode = mode;\n   pool_vector[pool_size].label = lab;\n   pool_size++;\n@@ -1965,7 +2085,8 @@ find_barrier (num_mova, mova, from)\n \t  /* We must explicitly check the mode, because sometimes the\n \t     front end will generate code to load unsigned constants into\n \t     HImode targets without properly sign extending them.  */\n-\t  if (mode == HImode || (mode == SImode && hi_const (src)))\n+\t  if (mode == HImode\n+\t      || (mode == SImode && hi_const (src) && REGNO (dst) != FPUL_REG))\n \t    {\n \t      found_hi += 2;\n \t      /* We put the short constants before the long constants, so\n@@ -2130,7 +2251,7 @@ sfunc_uses_reg (insn)\n   for (i = XVECLEN (pattern, 0) - 1; i >= 0; i--)\n     {\n       part = XVECEXP (pattern, 0, i);\n-      if (part == reg_part)\n+      if (part == reg_part || GET_CODE (part) == CLOBBER)\n \tcontinue;\n       if (reg_mentioned_p (reg, ((GET_CODE (part) == SET\n \t\t\t\t  && GET_CODE (SET_DEST (part)) == REG)\n@@ -2470,6 +2591,13 @@ gen_far_branch (bp)\n     }\n   else\n     jump = emit_jump_insn_after (gen_return (), insn);\n+  /* Emit a barrier so that reorg knows that any following instructions\n+     are not reachable via a fall-through path.\n+     But don't do this when not optimizing, since we wouldn't supress the\n+     alignment for the barrier then, and could end up with out-of-range\n+     pc-relative loads.  */\n+  if (optimize)\n+    emit_barrier_after (jump);\n   emit_label_after (bp->near_label, insn);\n   JUMP_LABEL (jump) = bp->far_label;\n   if (! invert_jump (insn, label))\n@@ -2556,36 +2684,42 @@ barrier_align (barrier_or_label)\n   if (! TARGET_SH3 || ! optimize)\n     return CACHE_LOG;\n \n-  /* Check if there is an immediately preceding branch to the insn beyond\n-     the barrier.  We must weight the cost of discarding useful information\n-     from the current cache line when executing this branch and there is\n-     an alignment, against that of fetching unneeded insn in front of the\n-     branch target when there is no alignment.  */\n-\n-  /* PREV is presumed to be the JUMP_INSN for the barrier under\n-     investigation.  Skip to the insn before it.  */\n-  prev = prev_real_insn (prev);\n-\n-  for (slot = 2, credit = 1 << (CACHE_LOG - 2) + 2;\n-       credit >= 0 && prev && GET_CODE (prev) == INSN;\n-       prev = prev_real_insn (prev))\n+  /* When fixing up pcloads, a constant table might be inserted just before\n+     the basic block that ends with the barrier.  Thus, we can't trust the\n+     instruction lengths before that.  */\n+  if (mdep_reorg_phase > SH_FIXUP_PCLOAD)\n     {\n-      if (GET_CODE (PATTERN (prev)) == USE\n-          || GET_CODE (PATTERN (prev)) == CLOBBER)\n-        continue;\n-      if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n-\tprev = XVECEXP (PATTERN (prev), 0, 1);\n-      if (slot &&\n-          get_attr_in_delay_slot (prev) == IN_DELAY_SLOT_YES)\n-        slot = 0;\n-      credit -= get_attr_length (prev);\n+      /* Check if there is an immediately preceding branch to the insn beyond\n+\t the barrier.  We must weight the cost of discarding useful information\n+\t from the current cache line when executing this branch and there is\n+\t an alignment, against that of fetching unneeded insn in front of the\n+\t branch target when there is no alignment.  */\n+\n+      /* PREV is presumed to be the JUMP_INSN for the barrier under\n+\t investigation.  Skip to the insn before it.  */\n+      prev = prev_real_insn (prev);\n+\n+      for (slot = 2, credit = 1 << (CACHE_LOG - 2) + 2;\n+\t   credit >= 0 && prev && GET_CODE (prev) == INSN;\n+\t   prev = prev_real_insn (prev))\n+\t{\n+\t  if (GET_CODE (PATTERN (prev)) == USE\n+\t      || GET_CODE (PATTERN (prev)) == CLOBBER)\n+\t    continue;\n+\t  if (GET_CODE (PATTERN (prev)) == SEQUENCE)\n+\t    prev = XVECEXP (PATTERN (prev), 0, 1);\n+\t  if (slot &&\n+\t      get_attr_in_delay_slot (prev) == IN_DELAY_SLOT_YES)\n+\t    slot = 0;\n+\t  credit -= get_attr_length (prev);\n+\t}\n+      if (prev\n+\t  && GET_CODE (prev) == JUMP_INSN\n+\t  && JUMP_LABEL (prev)\n+\t  && next_real_insn (JUMP_LABEL (prev)) == next_real_insn (barrier_or_label)\n+\t  && (credit - slot >= (GET_CODE (SET_SRC (PATTERN (prev))) == PC ? 2 : 0)))\n+\treturn 0;\n     }\n-  if (prev\n-      && GET_CODE (prev) == JUMP_INSN\n-      && JUMP_LABEL (prev)\n-      && next_real_insn (JUMP_LABEL (prev)) == next_real_insn (barrier_or_label)\n-      && (credit - slot >= (GET_CODE (SET_SRC (PATTERN (prev))) == PC ? 2 : 0)))\n-    return 0;\n \n   return CACHE_LOG;\n }\n@@ -2914,7 +3048,8 @@ machine_dependent_reorg (first)\n \t\t  dst = SET_DEST (pat);\n \t\t  mode = GET_MODE (dst);\n \n-\t\t  if (mode == SImode && hi_const (src))\n+\t\t  if (mode == SImode && hi_const (src)\n+\t\t      && REGNO (dst) != FPUL_REG)\n \t\t    {\n \t\t      int offset = 0;\n \n@@ -2929,7 +3064,7 @@ machine_dependent_reorg (first)\n \n \t\t  if (GET_CODE (dst) == REG\n \t\t      && ((REGNO (dst) >= FIRST_FP_REG\n-\t\t\t   && REGNO (dst) <= LAST_FP_REG)\n+\t\t\t   && REGNO (dst) <= LAST_XD_REG)\n \t\t\t  || REGNO (dst) == FPUL_REG))\n \t\t    {\n \t\t      if (last_float\n@@ -2943,7 +3078,8 @@ machine_dependent_reorg (first)\n \t\t      last_float_move = scan;\n \t\t      last_float = src;\n \t\t      newsrc = gen_rtx (MEM, mode,\n-\t\t\t\t\t(REGNO (dst) == FPUL_REG\n+\t\t\t\t\t((TARGET_SH4 && ! TARGET_FMOVD\n+\t\t\t\t\t  || REGNO (dst) == FPUL_REG)\n \t\t\t\t\t ? r0_inc_rtx\n \t\t\t\t\t : r0_rtx));\n \t\t      last_float_addr = &XEXP (newsrc, 0);\n@@ -2983,6 +3119,16 @@ machine_dependent_reorg (first)\n \t  emit_insn_before (gen_use_sfunc_addr (reg), insn);\n \t}\n     }\n+#if 0\n+  /* fpscr is not actually a user variable, but we pretend it is for the\n+     sake of the previous optimization passes, since we want it handled like\n+     one.  However, we don't have eny debugging information for it, so turn\n+     it into a non-user variable now.  */\n+  if (TARGET_SH4)\n+    REG_USERVAR_P (get_fpscr_rtx ()) = 0;\n+#endif\n+  if (optimize)\n+    sh_flag_remove_dead_before_cse = 1;\n   mdep_reorg_phase = SH_AFTER_MDEP_REORG;\n }\n \n@@ -3386,8 +3532,16 @@ push (rn)\n      int rn;\n {\n   rtx x;\n-  if ((rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n-      || rn == FPUL_REG)\n+  if (rn == FPUL_REG)\n+    x = gen_push_fpul ();\n+  else if (TARGET_SH4 && TARGET_FMOVD && ! TARGET_FPU_SINGLE\n+\t   && rn >= FIRST_FP_REG && rn <= LAST_XD_REG)\n+    {\n+      if ((rn - FIRST_FP_REG) & 1 && rn <= LAST_FP_REG)\n+\treturn;\n+      x = gen_push_4 (gen_rtx (REG, DFmode, rn));\n+    }\n+  else if (TARGET_SH3E && rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n     x = gen_push_e (gen_rtx (REG, SFmode, rn));\n   else\n     x = gen_push (gen_rtx (REG, SImode, rn));\n@@ -3404,8 +3558,16 @@ pop (rn)\n      int rn;\n {\n   rtx x;\n-  if ((rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n-      || rn == FPUL_REG)\n+  if (rn == FPUL_REG)\n+    x = gen_pop_fpul ();\n+  else if (TARGET_SH4 && TARGET_FMOVD && ! TARGET_FPU_SINGLE\n+\t   && rn >= FIRST_FP_REG && rn <= LAST_XD_REG)\n+    {\n+      if ((rn - FIRST_FP_REG) & 1 && rn <= LAST_FP_REG)\n+\treturn;\n+      x = gen_pop_4 (gen_rtx (REG, DFmode, rn));\n+    }\n+  else if (TARGET_SH3E && rn >= FIRST_FP_REG && rn <= LAST_FP_REG)\n     x = gen_pop_e (gen_rtx (REG, SFmode, rn));\n   else\n     x = gen_pop (gen_rtx (REG, SImode, rn));\n@@ -3453,6 +3615,16 @@ calc_live_regs (count_ptr, live_regs_mask2)\n   int count;\n \n   *live_regs_mask2 = 0;\n+  /* If we can save a lot of saves by switching to double mode, do that.  */\n+  if (TARGET_SH4 && TARGET_FMOVD && TARGET_FPU_SINGLE)\n+    for (count = 0, reg = FIRST_FP_REG; reg <= LAST_FP_REG; reg += 2)\n+      if (regs_ever_live[reg] && regs_ever_live[reg+1]\n+\t  && (! call_used_regs[reg] || (pragma_interrupt && ! pragma_trapa))\n+\t  && ++count > 2)\n+\t{\n+\t  target_flags &= ~FPU_SINGLE_BIT;\n+\t  break;\n+\t}\n   for (count = 0, reg = FIRST_PSEUDO_REGISTER - 1; reg >= 0; reg--)\n     {\n       if ((pragma_interrupt && ! pragma_trapa)\n@@ -3463,7 +3635,7 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t\t  && regs_ever_live[PR_REG]))\n \t     && reg != STACK_POINTER_REGNUM && reg != ARG_POINTER_REGNUM\n \t     && reg != RETURN_ADDRESS_POINTER_REGNUM\n-\t     && reg != T_REG && reg != GBR_REG)\n+\t     && reg != T_REG && reg != GBR_REG && reg != FPSCR_REG)\n \t  : (/* Only push those regs which are used and need to be saved.  */\n \t     regs_ever_live[reg] && ! call_used_regs[reg]))\n \t{\n@@ -3472,6 +3644,24 @@ calc_live_regs (count_ptr, live_regs_mask2)\n \t  else\n \t    live_regs_mask |= 1 << reg;\n \t  count++;\n+\t  if (TARGET_SH4 && TARGET_FMOVD && reg >= FIRST_FP_REG)\n+\t    if (reg <= LAST_FP_REG)\n+\t      {\n+\t\tif (! TARGET_FPU_SINGLE && ! regs_ever_live[reg ^ 1])\n+\t\t  {\n+\t\t    if (reg >= 32)\n+\t\t      *live_regs_mask2 |= 1 << ((reg ^ 1) - 32);\n+\t\t    else\n+\t\t      live_regs_mask |= 1 << (reg ^ 1);\n+\t\t    count++;\n+\t\t  }\n+\t      }\n+\t    else if (reg <= LAST_XD_REG)\n+\t      {\n+\t\t/* Must switch to double mode to access these registers.  */\n+\t\ttarget_flags &= ~FPU_SINGLE_BIT;\n+\t\tcount++;\n+\t      }\n \t}\n     }\n \n@@ -3487,6 +3677,7 @@ sh_expand_prologue ()\n   int live_regs_mask;\n   int d, i;\n   int live_regs_mask2;\n+  int save_flags = target_flags;\n   int double_align = 0;\n \n   /* We have pretend args if we had an object sent partially in registers\n@@ -3524,11 +3715,19 @@ sh_expand_prologue ()\n     emit_insn (gen_sp_switch_1 ());\n \n   live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n+  /* ??? Maybe we could save some switching if we can move a mode switch\n+     that already happens to be at the function start into the prologue.  */\n+  if (target_flags != save_flags)\n+    emit_insn (gen_toggle_sz ());\n   push_regs (live_regs_mask, live_regs_mask2);\n+  if (target_flags != save_flags)\n+    emit_insn (gen_toggle_sz ());\n \n   if (TARGET_ALIGN_DOUBLE && d & 1)\n     double_align = 4;\n \n+  target_flags = save_flags;\n+\n   output_stack_adjust (-get_frame_size () - double_align,\n \t\t       stack_pointer_rtx, 3);\n \n@@ -3543,6 +3742,7 @@ sh_expand_epilogue ()\n   int d, i;\n \n   int live_regs_mask2;\n+  int save_flags = target_flags;\n   int frame_size = get_frame_size ();\n \n   live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n@@ -3573,7 +3773,8 @@ sh_expand_epilogue ()\n \n   /* Pop all the registers.  */\n \n-  live_regs_mask = calc_live_regs (&d, &live_regs_mask2);\n+  if (target_flags != save_flags)\n+    emit_insn (gen_toggle_sz ());\n   if (live_regs_mask & (1 << PR_REG))\n     pop (PR_REG);\n   for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n@@ -3584,6 +3785,9 @@ sh_expand_epilogue ()\n       else if (j >= 32 && (live_regs_mask2 & (1 << (j - 32))))\n \tpop (j);\n     }\n+  if (target_flags != save_flags)\n+    emit_insn (gen_toggle_sz ());\n+  target_flags = save_flags;\n \n   output_stack_adjust (extra_push + current_function_pretend_args_size,\n \t\t       stack_pointer_rtx, 7);\n@@ -3651,6 +3855,25 @@ sh_builtin_saveregs (arglist)\n   emit_move_insn (fpregs, XEXP (regbuf, 0));\n   emit_insn (gen_addsi3 (fpregs, fpregs,\n \t\t\t GEN_INT (n_floatregs * UNITS_PER_WORD)));\n+  if (TARGET_SH4)\n+    {\n+      for (regno = NPARM_REGS (DFmode) - 2; regno >= first_floatreg; regno -= 2)\n+\t{\n+\t  emit_insn (gen_addsi3 (fpregs, fpregs,\n+\t\t\t\t GEN_INT (-2 * UNITS_PER_WORD)));\n+\t  emit_move_insn (gen_rtx (MEM, DFmode, fpregs),\n+\t\t\t  gen_rtx (REG, DFmode, BASE_ARG_REG (DFmode) + regno));\n+\t}\n+      regno = first_floatreg;\n+      if (regno & 1)\n+\t{\n+\t  emit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n+\t  emit_move_insn (gen_rtx (MEM, SFmode, fpregs),\n+\t\t\t  gen_rtx (REG, SFmode, BASE_ARG_REG (SFmode) + regno\n+\t\t\t\t\t\t- (TARGET_LITTLE_ENDIAN != 0)));\n+\t}\n+    }\n+  else\n     for (regno = NPARM_REGS (SFmode) - 1; regno >= first_floatreg; regno--)\n       {\n \temit_insn (gen_addsi3 (fpregs, fpregs, GEN_INT (- UNITS_PER_WORD)));\n@@ -3677,6 +3900,8 @@ initial_elimination_offset (from, to)\n \n   int live_regs_mask, live_regs_mask2;\n   live_regs_mask = calc_live_regs (&regs_saved, &live_regs_mask2);\n+  if (TARGET_ALIGN_DOUBLE && regs_saved & 1)\n+    total_auto_space += 4;\n   target_flags = save_flags;\n \n   total_saved_regs_space = (regs_saved) * 4;\n@@ -3885,12 +4110,48 @@ arith_reg_operand (op, mode)\n       else\n \treturn 1;\n \n-      return (regno != T_REG && regno != PR_REG && regno != FPUL_REG\n+      return (regno != T_REG && regno != PR_REG\n+\t      && (regno != FPUL_REG || TARGET_SH4)\n+\t      && regno != MACH_REG && regno != MACL_REG);\n+    }\n+  return 0;\n+}\n+\n+int\n+fp_arith_reg_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (register_operand (op, mode))\n+    {\n+      int regno;\n+\n+      if (GET_CODE (op) == REG)\n+\tregno = REGNO (op);\n+      else if (GET_CODE (op) == SUBREG && GET_CODE (SUBREG_REG (op)) == REG)\n+\tregno = REGNO (SUBREG_REG (op));\n+      else\n+\treturn 1;\n+\n+      return (regno != T_REG && regno != PR_REG && regno > 15\n \t      && regno != MACH_REG && regno != MACL_REG);\n     }\n   return 0;\n }\n \n+int\n+fp_extended_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_CODE (op) == FLOAT_EXTEND && GET_MODE (op) == mode)\n+    {\n+      op = XEXP (op, 0);\n+      mode = GET_MODE (op);\n+    }\n+  return fp_arith_reg_operand (op, mode);\n+}\n+\n /* Returns 1 if OP is a valid source operand for an arithmetic insn.  */\n \n int\n@@ -3991,6 +4252,73 @@ braf_label_ref_operand(op, mode)\n   if (GET_CODE (prev) != PLUS || XEXP (prev, 1) != op)\n     return 0;\n }\n+\n+int\n+tertiary_reload_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  enum rtx_code code = GET_CODE (op);\n+  return code == MEM || (TARGET_SH4 && code == CONST_DOUBLE);\n+}\n+\n+int\n+fpscr_operand (op)\n+     rtx op;\n+{\n+  return (GET_CODE (op) == REG && REGNO (op) == FPSCR_REG\n+\t  && GET_MODE (op) == PSImode);\n+}\n+\n+int\n+commutative_float_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MULT:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+noncommutative_float_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case MINUS:\n+    case DIV:\n+      return 1;\n+    }\n+  return 0;\n+}\n+\n+int\n+binary_float_operator (op, mode)\n+     rtx op;\n+     enum machine_mode mode;\n+{\n+  if (GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case PLUS:\n+    case MINUS:\n+    case MULT:\n+    case DIV:\n+      return 1;\n+    }\n+  return 0;\n+}\n \f\n /* Return the destination address of a branch.  */\n    \n@@ -4102,3 +4430,304 @@ reg_unused_after (reg, insn)\n     }\n   return 1;\n }\n+\f\n+extern struct obstack permanent_obstack;\n+\n+rtx\n+get_fpscr_rtx ()\n+{\n+  static rtx fpscr_rtx;\n+\n+  if (! fpscr_rtx)\n+    {\n+      push_obstacks (&permanent_obstack, &permanent_obstack);\n+      fpscr_rtx = gen_rtx (REG, PSImode, 48);\n+      REG_USERVAR_P (fpscr_rtx) = 1;\n+      pop_obstacks ();\n+      mark_user_reg (fpscr_rtx);\n+    }\n+  if (! reload_completed || mdep_reorg_phase != SH_AFTER_MDEP_REORG)\n+    mark_user_reg (fpscr_rtx);\n+  return fpscr_rtx;\n+}\n+\n+void\n+emit_sf_insn (pat)\n+     rtx pat;\n+{\n+  rtx addr;\n+  /* When generating reload insns,  we must not create new registers.  FPSCR\n+     should already have the correct value, so do nothing to change it.  */\n+  if (! TARGET_FPU_SINGLE && ! reload_in_progress)\n+    {\n+      addr = gen_reg_rtx (SImode);\n+      emit_insn (gen_fpu_switch0 (addr));\n+    }\n+  emit_insn (pat);\n+  if (! TARGET_FPU_SINGLE && ! reload_in_progress)\n+    {\n+      addr = gen_reg_rtx (SImode);\n+      emit_insn (gen_fpu_switch1 (addr));\n+    }\n+}\n+\n+void\n+emit_df_insn (pat)\n+     rtx pat;\n+{\n+  rtx addr;\n+  if (TARGET_FPU_SINGLE && ! reload_in_progress)\n+    {\n+      addr = gen_reg_rtx (SImode);\n+      emit_insn (gen_fpu_switch0 (addr));\n+    }\n+  emit_insn (pat);\n+  if (TARGET_FPU_SINGLE && ! reload_in_progress)\n+    {\n+      addr = gen_reg_rtx (SImode);\n+      emit_insn (gen_fpu_switch1 (addr));\n+    }\n+}\n+\n+void\n+expand_sf_unop (fun, operands)\n+     rtx (*fun)();\n+     rtx *operands;\n+{\n+  emit_sf_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n+}\n+\n+void\n+expand_sf_binop (fun, operands)\n+     rtx (*fun)();\n+     rtx *operands;\n+{\n+  emit_sf_insn ((*fun) (operands[0], operands[1], operands[2],\n+\t\t\t get_fpscr_rtx ()));\n+}\n+\n+void\n+expand_df_unop (fun, operands)\n+     rtx (*fun)();\n+     rtx *operands;\n+{\n+  emit_df_insn ((*fun) (operands[0], operands[1], get_fpscr_rtx ()));\n+}\n+\n+void\n+expand_df_binop (fun, operands)\n+     rtx (*fun)();\n+     rtx *operands;\n+{\n+  emit_df_insn ((*fun) (operands[0], operands[1], operands[2],\n+\t\t\t get_fpscr_rtx ()));\n+}\n+\n+void\n+expand_fp_branch (compare, branch)\n+     rtx (*compare) (), (*branch) ();\n+{\n+  (GET_MODE (sh_compare_op0)  == SFmode ? emit_sf_insn : emit_df_insn)\n+    ((*compare) ());\n+  emit_jump_insn ((*branch) ());\n+}\n+\f\n+/* We don't want to make fpscr call-saved, because that would prevent\n+   channging it, and it would also cost an exstra instruction to save it.\n+   We don't want it to be known as a global register either, because\n+   that disables all flow analysis.  But it has to be live at the function\n+   return.  Thus, we need to insert a USE at the end of the function.  */\n+/* This should best be called at about the time FINALIZE_PIC is called,\n+   but not dependent on flag_pic.  Alas, there is no suitable hook there,\n+   so this gets called from HAVE_RETURN.  */\n+int\n+emit_fpscr_use ()\n+{\n+  static int fpscr_uses = 0;\n+\n+  if (rtx_equal_function_value_matters)\n+    {\n+      emit_insn (gen_rtx (USE, VOIDmode, get_fpscr_rtx ()));\n+      fpscr_uses++;\n+    }\n+  else\n+    {\n+      if (fpscr_uses > 1)\n+\t{\n+\t  /* Due to he crude way we emit the USEs, we might end up with\n+\t     some extra ones.  Delete all but the last one.  */\n+\t  rtx insn;\n+\n+\t  for (insn = get_last_insn(); insn; insn = PREV_INSN (insn))\n+\t    if (GET_CODE (insn) == INSN\n+\t\t&& GET_CODE (PATTERN (insn)) == USE\n+\t\t&& GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n+\t\t&& REGNO (XEXP (PATTERN (insn), 0)) == FPSCR_REG)\n+\t      {\n+\t\tinsn = PREV_INSN (insn);\n+\t\tbreak;\n+\t      }\n+\t  for (; insn; insn = PREV_INSN (insn))\n+\t    if (GET_CODE (insn) == INSN\n+\t\t&& GET_CODE (PATTERN (insn)) == USE\n+\t\t&& GET_CODE (XEXP (PATTERN (insn), 0)) == REG\n+\t\t&& REGNO (XEXP (PATTERN (insn), 0)) == FPSCR_REG)\n+\t      {\n+\t\tPUT_CODE (insn, NOTE);\n+\t\tNOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t\tNOTE_SOURCE_FILE (insn) = 0;\n+\t      }\n+\t}\n+      fpscr_uses = 0;\n+    }\n+}\n+\f\n+/* ??? gcc does flow analysis strictly after common subexpression\n+   elimination.  As a result, common subespression elimination fails\n+   when there are some intervening statements setting the same register.\n+   If we did nothing about this, this would hurt the precision switching\n+   for SH4 badly.  There is some cse after reload, but it is unable to\n+   undo the extra register pressure from the unused instructions, and\n+   it cannot remove auto-increment loads.\n+\n+   A C code example that shows this flow/cse weakness for (at least) SH\n+   and sparc (as of gcc ss-970706) is this:\n+\n+double\n+f(double a)\n+{\n+  double d;\n+  d = 0.1;\n+  a += d;\n+  d = 1.1;\n+  d = 0.1;\n+  a *= d;\n+  return a;\n+}\n+\n+   So we add another pass before common subexpression elimination, to\n+   remove assignments that are dead due to a following assignment in the\n+   same basic block.  */\n+\n+int sh_flag_remove_dead_before_cse;\n+\n+static void \n+mark_use (x, reg_set_block)\n+     rtx x, *reg_set_block;\n+{\n+  enum rtx_code code;\n+\n+  if (! x)\n+    return;\n+  code = GET_CODE (x);\n+  switch (code)\n+    {\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tint nregs = (regno < FIRST_PSEUDO_REGISTER\n+\t\t     ? HARD_REGNO_NREGS (regno, GET_MODE (x))\n+\t\t     : 1);\n+\tdo\n+\t  {\n+\t    reg_set_block[regno + nregs - 1] = 0;\n+\t  }\n+\twhile (--nregs);\n+\tbreak;\n+      }\n+    case SET:\n+      {\n+\trtx dest = SET_DEST (x);\n+\n+\tif (GET_CODE (dest) == SUBREG)\n+\t  dest = SUBREG_REG (dest);\n+\tif (GET_CODE (dest) != REG)\n+\t  mark_use (dest, reg_set_block);\n+\tmark_use (SET_SRC (x), reg_set_block);\n+\tbreak;\n+      }\n+    case CLOBBER:\n+      break;\n+    default:\n+      {\n+\tchar *fmt = GET_RTX_FORMAT (code);\n+\tint i, j;\n+\tfor (i = GET_RTX_LENGTH (code) - 1; i >= 0; i--)\n+\t  {\n+\t    if (fmt[i] == 'e')\n+\t      mark_use (XEXP (x, i), reg_set_block);\n+\t    else if (fmt[i] == 'E')\n+\t      for (j = XVECLEN (x, i) - 1; j >= 0; j--)\n+\t\tmark_use (XVECEXP (x, i, j), reg_set_block);\n+\t  }\n+\tbreak;\n+      }\n+    }\n+}\n+\n+int\n+remove_dead_before_cse ()\n+{\n+  rtx *reg_set_block, last, last_call, insn, set;\n+  int in_libcall = 0;\n+\n+  /* This pass should run just once, after rtl generation.  */\n+\n+  if (! sh_flag_remove_dead_before_cse\n+      || rtx_equal_function_value_matters\n+      || reload_completed)\n+    return;\n+\n+  sh_flag_remove_dead_before_cse = 0;\n+\n+  reg_set_block = (rtx *)alloca (max_reg_num () * sizeof (rtx));\n+  bzero ((char *)reg_set_block, max_reg_num () * sizeof (rtx));\n+  last_call = last = get_last_insn ();\n+  for (insn = last; insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_RTX_CLASS (GET_CODE (insn)) != 'i')\n+\tcontinue;\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  last_call = last = insn;\n+\t  continue;\n+\t}\n+      set = single_set (insn);\n+\n+      /* Don't delete parts of libcalls, since that would confuse cse, loop\n+\t and flow.  */\n+      if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n+\tin_libcall = 1;\n+      else if (in_libcall)\n+\t{\n+\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n+\t    in_libcall = 0;\n+\t}\n+      else if (set && GET_CODE (SET_DEST (set)) == REG)\n+\t{\n+\t  int regno = REGNO (SET_DEST (set));\n+\t  rtx ref_insn = (regno < FIRST_PSEUDO_REGISTER && call_used_regs[regno]\n+\t\t\t  ? last_call\n+\t\t\t  : last);\n+\t  if (reg_set_block[regno] == ref_insn\n+\t      && (regno >= FIRST_PSEUDO_REGISTER\n+\t\t  || HARD_REGNO_NREGS (regno, GET_MODE (SET_DEST (set))) == 1)\n+\t      && (GET_CODE (insn) != CALL_INSN || CONST_CALL_P (insn)))\n+\t    {\n+\t      PUT_CODE (insn, NOTE);\n+\t      NOTE_LINE_NUMBER (insn) = NOTE_INSN_DELETED;\n+\t      NOTE_SOURCE_FILE (insn) = 0;\n+\t      continue;\n+\t    }\n+\t  else\n+\t    reg_set_block[REGNO (SET_DEST (set))] = ref_insn;\n+\t}\n+      if (GET_CODE (insn) == CALL_INSN)\n+\t{\n+\t  last_call = insn;\n+\t  mark_use (CALL_INSN_FUNCTION_USAGE (insn), reg_set_block);\n+\t}\n+      mark_use (PATTERN (insn), reg_set_block);\n+    }\n+  return 0;\n+}"}, {"sha": "c32b13a000d92bae50c03ffaf418932788d8cb4d", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 314, "deletions": 73, "changes": 387, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -1,5 +1,5 @@\n /* Definitions of target machine for GNU compiler for Hitachi Super-H.\n-   Copyright (C) 1993, 1994, 1995, 1996, 1997 Free Software Foundation, Inc.\n+   Copyright (C) 1993-1998 Free Software Foundation, Inc.\n    Contributed by Steve Chamberlain (sac@cygnus.com).\n    Improved by Jim Wilson (wilson@cygnus.com).\n \n@@ -43,7 +43,10 @@ extern int code_for_indirect_jump_scratch;\n %{m2:-D__sh2__} \\\n %{m3:-D__sh3__} \\\n %{m3e:-D__SH3E__} \\\n-%{!m1:%{!m2:%{!m3:%{!m3e:-D__sh1__}}}}\"\n+%{m4-single-only:-D__SH4_SINGLE_ONLY__} \\\n+%{m4-single:-D__SH4_SINGLE__} \\\n+%{m4:-D__SH4__} \\\n+%{!m1:%{!m2:%{!m3:%{!m3e:%{!m4:%{!m4-single:%{!m4-single-only:-D__sh1__}}}}}}}\"\n \n #define CPP_PREDEFINES \"-D__sh__ -Acpu(sh) -Amachine(sh)\"\n \n@@ -54,19 +57,28 @@ extern int code_for_indirect_jump_scratch;\n /* We can not debug without a frame pointer.  */\n /* #define CAN_DEBUG_WITHOUT_FP */\n \n-#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\\\n-  if (! TARGET_SH3E)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      int regno;\t\t\t\t\t\t\\\n-      for (regno = FIRST_FP_REG; regno <= LAST_FP_REG; regno++)\t\\\n-\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n-      fixed_regs[FPUL_REG] = call_used_regs[FPUL_REG] = 1;\t\\\n-    }\t\t\t\t\t\t\t\t\\\n-  /* Hitachi saves and restores mac registers on call.  */\t\\\n-  if (TARGET_HITACHI)\t\t\t\t\t\t\\\n-    {\t\t\t\t\t\t\t\t\\\n-      call_used_regs[MACH_REG] = 0;\t\t\t\t\\\n-      call_used_regs[MACL_REG] = 0;\t\t\t\t\\\n+#define CONDITIONAL_REGISTER_USAGE\t\t\t\t\t\\\n+  if (! TARGET_SH4 || ! TARGET_FMOVD)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\t\\\n+      for (regno = FIRST_XD_REG; regno <= LAST_XD_REG; regno++)\t\t\\\n+\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\t\\\n+      if (! TARGET_SH4)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (! TARGET_SH3E)\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      int regno;\t\t\t\t\t\t\\\n+\t      for (regno = FIRST_FP_REG; regno <= LAST_FP_REG; regno++)\t\\\n+\t\tfixed_regs[regno] = call_used_regs[regno] = 1;\t\t\\\n+\t      fixed_regs[FPUL_REG] = call_used_regs[FPUL_REG] = 1;\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  /* Hitachi saves and restores mac registers on call.  */\t\t\\\n+  if (TARGET_HITACHI)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      call_used_regs[MACH_REG] = 0;\t\t\t\t\t\\\n+      call_used_regs[MACL_REG] = 0;\t\t\t\t\t\\\n     }\n \f\n /* ??? Need to write documentation for all SH options and add it to the\n@@ -81,6 +93,10 @@ extern int target_flags;\n #define SH2_BIT\t       \t(1<<9)\n #define SH3_BIT\t       \t(1<<10)\n #define SH3E_BIT\t(1<<11)\n+#define HARD_SH4_BIT\t(1<<5)\n+#define FPU_SINGLE_BIT\t(1<<7)\n+#define SH4_BIT\t       \t(1<<12)\n+#define FMOVD_BIT\t(1<<4)\n #define SPACE_BIT \t(1<<13)\n #define BIGTABLE_BIT  \t(1<<14)\n #define RELAX_BIT\t(1<<15)\n@@ -107,6 +123,27 @@ extern int target_flags;\n /* Nonzero if we should generate code using type 3E insns.  */\n #define TARGET_SH3E (target_flags & SH3E_BIT)\n \n+/* Nonzero if the cache line size is 32. */\n+#define TARGET_CACHE32 (target_flags & HARD_SH4_BIT)\n+\n+/* Nonzero if we schedule for a superscalar implementation. */\n+#define TARGET_SUPERSCALAR (target_flags & HARD_SH4_BIT)\n+\n+/* Nonzero if the target has separate instruction and data caches.  */\n+#define TARGET_HARWARD (target_flags & HARD_SH4_BIT)\n+\n+/* Nonzero if compiling for SH4 hardware (to be used for insn costs etc.)  */\n+#define TARGET_HARD_SH4 (target_flags & HARD_SH4_BIT)\n+\n+/* Nonzero if the default precision of th FPU is single */\n+#define TARGET_FPU_SINGLE (target_flags & FPU_SINGLE_BIT)\n+\n+/* Nonzero if we should generate code using type 4 insns.  */\n+#define TARGET_SH4 (target_flags & SH4_BIT)\n+\n+/* Nonzero if we should generate fmovd.  */\n+#define TARGET_FMOVD (target_flags & FMOVD_BIT)\n+\n /* Nonzero if we respect NANs.  */\n #define TARGET_IEEE (target_flags & IEEE_BIT)\n \n@@ -137,10 +174,14 @@ extern int target_flags;\n { {\"1\",\t        SH1_BIT},\t\t\t\\\n   {\"2\",\t        SH2_BIT},\t\t\t\\\n   {\"3\",\t        SH3_BIT|SH2_BIT},\t\t\\\n-  {\"3e\",\tSH3E_BIT|SH3_BIT|SH2_BIT},\t\\\n+  {\"3e\",\tSH3E_BIT|SH3_BIT|SH2_BIT|FPU_SINGLE_BIT},\t\\\n+  {\"4-single-only\",\tSH3E_BIT|SH3_BIT|SH2_BIT|SH3E_BIT|HARD_SH4_BIT|FPU_SINGLE_BIT},\t\\\n+  {\"4-single\",\tSH4_BIT|SH3E_BIT|SH3_BIT|SH2_BIT|HARD_SH4_BIT|FPU_SINGLE_BIT},\\\n+  {\"4\",\t        SH4_BIT|SH3E_BIT|SH3_BIT|SH2_BIT|HARD_SH4_BIT},\t\\\n   {\"b\",\t\t-LITTLE_ENDIAN_BIT},  \t\t\\\n   {\"bigtable\", \tBIGTABLE_BIT},\t\t\t\\\n   {\"dalign\",  \tDALIGN_BIT},\t\t\t\\\n+  {\"fmovd\",  \tFMOVD_BIT},\t\t\t\\\n   {\"hitachi\",\tHITACHI_BIT},\t\t\t\\\n   {\"ieee\",  \tIEEE_BIT},\t\t\t\\\n   {\"isize\", \tISIZE_BIT},\t\t\t\\\n@@ -160,26 +201,58 @@ extern int target_flags;\n \n #define OPTIMIZATION_OPTIONS(LEVEL,SIZE)\t\t\t\t\\\n do {\t\t\t\t\t\t\t\t\t\\\n+  if (LEVEL)\t\t\t\t\t\t\t\t\\\n+    flag_omit_frame_pointer = -1;\t\t\t\t\t\\\n+  if (LEVEL)\t\t\t\t\t\t\t\t\\\n+    sh_flag_remove_dead_before_cse = 1;\t\t\t\t\t\\\n   if (SIZE)\t\t\t\t\t\t\t\t\\\n     target_flags |= SPACE_BIT;\t\t\t\t\t\t\\\n } while (0)\n \n-#define ASSEMBLER_DIALECT 0 /* will allow to distinguish b[tf].s and b[tf]/s .  */\n-#define OVERRIDE_OPTIONS \t\t\t\t\t\\\n-do {\t\t\t\t\t\t\t\t\\\n-  sh_cpu = CPU_SH1;\t\t\t\t\t\t\\\n-  if (TARGET_SH2)\t\t\t\t\t\t\\\n-    sh_cpu = CPU_SH2;\t\t\t\t\t\t\\\n-  if (TARGET_SH3)\t\t\t\t\t\t\\\n-    sh_cpu = CPU_SH3;\t\t\t\t\t\t\\\n-  if (TARGET_SH3E)\t\t\t\t\t\t\\\n-    sh_cpu = CPU_SH3E;\t\t\t\t\t\t\\\n-\t\t\t\t\t\t\t\t\\\n-  /* Never run scheduling before reload, since that can\t\t\\\n-     break global alloc, and generates slower code anyway due\t\\\n-     to the pressure on R0.  */\t\t\t\t\t\\\n-  flag_schedule_insns = 0;\t\t\t\t\t\\\n-  sh_addr_diff_vec_mode = TARGET_BIGTABLE ? SImode : HImode;\t\\\n+#define ASSEMBLER_DIALECT assembler_dialect\n+\n+extern int assembler_dialect;\n+\n+#define OVERRIDE_OPTIONS \t\t\t\t\t\t\\\n+do {\t\t\t\t\t\t\t\t\t\\\n+  sh_cpu = CPU_SH1;\t\t\t\t\t\t\t\\\n+  assembler_dialect = 0;\t\t\t\t\t\t\\\n+  if (TARGET_SH2)\t\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH2;\t\t\t\t\t\t\t\\\n+  if (TARGET_SH3)\t\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH3;\t\t\t\t\t\t\t\\\n+  if (TARGET_SH3E)\t\t\t\t\t\t\t\\\n+    sh_cpu = CPU_SH3E;\t\t\t\t\t\t\t\\\n+  if (TARGET_SH4)\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      assembler_dialect = 1;\t\t\t\t\t\t\\\n+      sh_cpu = CPU_SH4;\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (! TARGET_SH4 || ! TARGET_FMOVD)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      /* Prevent usage of explicit register names for variables\t\t\\\n+\t for registers not present / not addressable in the\t\t\\\n+\t target architecture.  */\t\t\t\t\t\\\n+      int regno;\t\t\t\t\t\t\t\\\n+      for (regno = (TARGET_SH3E) ? 17 : 0; \t\t\t\t\\\n+\t   regno <= 24; regno++)\t\t\t\t\t\\\n+\tfp_reg_names[regno][0] = 0;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (flag_omit_frame_pointer < 0)\t\t\t\t\t\\\n+   /* The debugging information is sufficient,\t\t\t\t\\\n+      but gdb doesn't implement this yet */\t\t\t\t\\\n+   if (0)\t\t\t\t\t\t\t\t\\\n+    flag_omit_frame_pointer\t\t\t\t\t\t\\\n+      = (PREFERRED_DEBUGGING_TYPE == DWARF_DEBUG\t\t\t\\\n+\t || PREFERRED_DEBUGGING_TYPE == DWARF2_DEBUG);\t\t\t\\\n+   else\t\t\t\t\t\t\t\t\t\\\n+    flag_omit_frame_pointer = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* Never run scheduling before reload, since that can\t\t\t\\\n+     break global alloc, and generates slower code anyway due\t\t\\\n+     to the pressure on R0.  */\t\t\t\t\t\t\\\n+  flag_schedule_insns = 0;\t\t\t\t\t\t\\\n+  sh_addr_diff_vec_mode = TARGET_BIGTABLE ? SImode : HImode;\t\t\\\n } while (0)\n \f\n /* Target machine storage layout.  */\n@@ -233,7 +306,7 @@ do {\t\t\t\t\t\t\t\t\\\n \n /* The log (base 2) of the cache line size, in bytes.  Processors prior to\n    SH3 have no actual cache, but they fetch code in chunks of 4 bytes.  */\n-#define CACHE_LOG (TARGET_SH3 ? 4 : 2)\n+#define CACHE_LOG (TARGET_CACHE32 ? 5 : TARGET_SH3 ? 4 : 2)\n \n /* Allocation boundary (in *bits*) for the code of a function.\n    32 bit alignment is faster, because instructions are always fetched as a\n@@ -279,7 +352,7 @@ do {\t\t\t\t\t\t\t\t\\\n   barrier_align (LABEL_AFTER_BARRIER)\n \n #define LOOP_ALIGN(A_LABEL) \\\n-  ((! optimize || TARGET_SMALLCODE) ? 0 : 2)\n+  ((! optimize || TARGET_HARWARD || TARGET_SMALLCODE) ? 0 : 2)\n \n #define LABEL_ALIGN(A_LABEL) \\\n (\t\t\t\t\t\t\t\t\t\\\n@@ -341,8 +414,11 @@ do {\t\t\t\t\t\t\t\t\\\n #define RAP_REG 23\n #define FIRST_FP_REG 24\n #define LAST_FP_REG 39\n+#define FIRST_XD_REG 40\n+#define LAST_XD_REG 47\n+#define FPSCR_REG 48\n \n-#define FIRST_PSEUDO_REGISTER 40\n+#define FIRST_PSEUDO_REGISTER 49\n \n /* 1 for registers that have pervasive standard uses\n    and are not available for the register allocator.\n@@ -361,6 +437,9 @@ do {\t\t\t\t\t\t\t\t\\\n     0,  0,  0,  0,\t\t\\\n     0,  0,  0,  0,\t\t\\\n     0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    0,  0,  0,  0,\t\t\\\n+    1,\t\t\t\t\\\n }\n \n /* 1 for registers not available across function calls.\n@@ -381,27 +460,49 @@ do {\t\t\t\t\t\t\t\t\\\n     1,  1,  1,  1,\t\t\\\n     1,  1,  1,  1,\t\t\\\n     0,  0,  0,  0,\t\t\\\n+    1,  1,  1,  1,\t\t\\\n+    1,  1,  0,  0,\t\t\\\n+    1,\t\t\t\t\\\n }\n \n /* Return number of consecutive hard regs needed starting at reg REGNO\n    to hold something of mode MODE.\n    This is ordinarily the length in words of a value of mode MODE\n    but can be less for certain modes in special long registers.\n \n-   On the SH regs are UNITS_PER_WORD bits wide.  */\n+   On the SH all but the XD regs are UNITS_PER_WORD bits wide.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE) \\\n-   (((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+   ((REGNO) >= FIRST_XD_REG && (REGNO) <= LAST_XD_REG \\\n+    ? (GET_MODE_SIZE (MODE) / (2 * UNITS_PER_WORD)) \\\n+    : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)) \\\n \n /* Value is 1 if hard register REGNO can hold a value of machine-mode MODE.\n    We can allow any mode in any general register.  The special registers\n    only allow SImode.  Don't allow any mode in the PR.  */\n \n+/* We cannot hold DCmode values in the XD registers because alter_reg\n+   handles subregs of them incorrectly.  We could work around this by\n+   spacing the XD registers like the DR registers, but this would require\n+   additional memory in every compilation to hold larger register vectors.\n+   We could hold SFmode / SCmode values in XD registers, but that\n+   would require a tertiary reload when reloading from / to memory,\n+   and a secondary reload to reload from / to general regs; that\n+   seems to be a loosing proposition.  */\n #define HARD_REGNO_MODE_OK(REGNO, MODE)\t\t\\\n   (SPECIAL_REG (REGNO) ? (MODE) == SImode\t\\\n    : (REGNO) == FPUL_REG ? (MODE) == SImode || (MODE) == SFmode\t\\\n-   : (REGNO) >= FIRST_FP_REG && (REGNO) <= LAST_FP_REG ? (MODE) == SFmode \\\n+   : (REGNO) >= FIRST_FP_REG && (REGNO) <= LAST_FP_REG && (MODE) == SFmode \\\n+   ? 1 \\\n+   : (REGNO) >= FIRST_FP_REG && (REGNO) <= LAST_FP_REG \\\n+   ? ((MODE) == SFmode \\\n+      || (TARGET_SH3E && (MODE) == SCmode) \\\n+      || (((TARGET_SH4 && (MODE) == DFmode) || (MODE) == DCmode) \\\n+\t  && (((REGNO) - FIRST_FP_REG) & 1) == 0)) \\\n+   : (REGNO) >= FIRST_XD_REG && (REGNO) <= LAST_XD_REG \\\n+   ? (MODE) == DFmode \\\n    : (REGNO) == PR_REG ? 0\t\t\t\\\n+   : (REGNO) == FPSCR_REG ? (MODE) == PSImode \\\n    : 1)\n \n /* Value is 1 if it is a good idea to tie two pseudo registers\n@@ -541,6 +642,8 @@ enum reg_class\n   GENERAL_REGS,\n   FP0_REGS,\n   FP_REGS,\n+  DF_REGS,\n+  FPSCR_REGS,\n   GENERAL_FP_REGS,\n   ALL_REGS,\n   LIM_REG_CLASSES\n@@ -560,6 +663,8 @@ enum reg_class\n   \"GENERAL_REGS\",\t\\\n   \"FP0_REGS\",\t\t\\\n   \"FP_REGS\",\t\t\\\n+  \"DF_REGS\",\t\t\\\n+  \"FPSCR_REGS\",\t\t\\\n   \"GENERAL_FP_REGS\",\t\\\n   \"ALL_REGS\",\t\t\\\n }\n@@ -579,8 +684,10 @@ enum reg_class\n   { 0x0081FFFF, 0x00000000 }, /* GENERAL_REGS\t*/\t\\\n   { 0x01000000, 0x00000000 }, /* FP0_REGS\t*/\t\\\n   { 0xFF000000, 0x000000FF }, /* FP_REGS\t*/\t\\\n-  { 0xFF81FFFF, 0x000000FF }, /* GENERAL_FP_REGS */\t\\\n-  { 0xFFFFFFFF, 0x000000FF }, /* ALL_REGS\t*/\t\\\n+  { 0xFF000000, 0x0000FFFF }, /* DF_REGS\t*/\t\\\n+  { 0x00000000, 0x00010000 }, /* FPSCR_REGS\t*/\t\\\n+  { 0xFF81FFFF, 0x0000FFFF }, /* GENERAL_FP_REGS */\t\\\n+  { 0xFFFFFFFF, 0x0001FFFF }, /* ALL_REGS\t*/\t\\\n }\n \n /* The same information, inverted:\n@@ -603,6 +710,7 @@ extern int regno_reg_class[];\n    spilled or used otherwise, we better have the FP_REGS allocated first.  */\n #define REG_ALLOC_ORDER \\\n   { 25,26,27,28,29,30,31,24,32,33,34,35,36,37,38,39,\t\\\n+    40,41,42,43,44,45,46,47,48,\t\t\t\t\\\n     1,2,3,7,6,5,4,0,8,9,10,11,12,13,14,\t\t\t\\\n     22,15,16,17,18,19,20,21,23 }\n \n@@ -657,7 +765,8 @@ extern enum reg_class reg_class_from_letter[];\n #define PREFERRED_RELOAD_CLASS(X, CLASS) (CLASS)\n \n #define SECONDARY_OUTPUT_RELOAD_CLASS(CLASS,MODE,X) \\\n-  ((((((CLASS) == FP_REGS || (CLASS) == FP0_REGS)\t\t\t\\\n+  ((((((CLASS) == FP_REGS || (CLASS) == FP0_REGS\t\t\t\\\n+\t|| (CLASS) == DF_REGS)\t\t\t\t\t\t\\\n       && (GET_CODE (X) == REG && REGNO (X) <= AP_REG))\t\t\t\\\n      || (((CLASS) == GENERAL_REGS || (CLASS) == R0_REGS)\t\t\\\n \t && GET_CODE (X) == REG\t\t\t\t\t\t\\\n@@ -666,25 +775,39 @@ extern enum reg_class reg_class_from_letter[];\n    ? FPUL_REGS\t\t\t\t\t\t\t\t\\\n    : ((CLASS) == FPUL_REGS\t\t\t\t\t\t\\\n       && (GET_CODE (X) == MEM\t\t\t\t\t\t\\\n-\t  || GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER))\\\n+\t  || (GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)))\\\n    ? GENERAL_REGS\t\t\t\t\t\t\t\\\n    : (((CLASS) == MAC_REGS || (CLASS) == PR_REGS)\t\t\t\\\n       && GET_CODE (X) == REG && REGNO (X) > 15\t\t\t\t\\\n       && (CLASS) != REGNO_REG_CLASS (REGNO (X)))\t\t\t\\\n    ? GENERAL_REGS : NO_REGS)\n \n #define SECONDARY_INPUT_RELOAD_CLASS(CLASS,MODE,X)  \\\n-  ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS)\t\t\t\t\\\n+  ((((CLASS) == FP_REGS || (CLASS) == FP0_REGS || (CLASS) == DF_REGS)\t\\\n     && immediate_operand ((X), (MODE))\t\t\t\t\t\\\n-    && ! (fp_zero_operand (X) || fp_one_operand (X)))\t\t\t\\\n-   ? R0_REGS : SECONDARY_OUTPUT_RELOAD_CLASS((CLASS),(MODE),(X)))\n+    && ! ((fp_zero_operand (X) || fp_one_operand (X)) && (MODE) == SFmode))\\\n+   ? R0_REGS\t\t\t\t\t\t\t\t\\\n+   : CLASS == FPUL_REGS && immediate_operand ((X), (MODE))\t\t\\\n+   ? (GET_CODE (X) == CONST_INT && CONST_OK_FOR_I (INTVAL (X))\t\t\\\n+      ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+      : R0_REGS)\t\t\t\t\t\t\t\\\n+   : (CLASS == FPSCR_REGS\t\t\t\t\t\t\\\n+      && ((GET_CODE (X) == REG && REGNO (X) >= FIRST_PSEUDO_REGISTER)\t\\\n+\t  || GET_CODE (X) == MEM && GET_CODE (XEXP ((X), 0)) == PLUS))\t\\\n+   ? GENERAL_REGS\t\t\t\t\t\t\t\\\n+   : SECONDARY_OUTPUT_RELOAD_CLASS((CLASS),(MODE),(X)))\n \n /* Return the maximum number of consecutive registers\n    needed to represent mode MODE in a register of class CLASS.\n \n    On SH this is the size of MODE in words.  */\n #define CLASS_MAX_NREGS(CLASS, MODE) \\\n      ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n+\n+/* If defined, gives a class of registers that cannot be used as the\n+   operand of a SUBREG that changes the size of the object.  */\n+\n+#define CLASS_CANNOT_CHANGE_SIZE\tDF_REGS\n \f\n /* Stack layout; function entry, exit and calling.  */\n \n@@ -694,6 +817,9 @@ extern enum reg_class reg_class_from_letter[];\n #define NPARM_REGS(MODE) \\\n   (TARGET_SH3E && (MODE) == SFmode \\\n    ? 8 \\\n+   : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n+   ? 8 \\\n    : 4)\n \n #define FIRST_PARM_REG 4\n@@ -752,25 +878,48 @@ extern enum reg_class reg_class_from_letter[];\n #define BASE_RETURN_VALUE_REG(MODE) \\\n   ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n    ? FIRST_FP_RET_REG\t\t\t\t\t\\\n+   : TARGET_SH3E && (MODE) == SCmode\t\t\\\n+   ? FIRST_FP_RET_REG\t\t\t\t\t\\\n+   : (TARGET_SH4\t\t\t\t\t\\\n+      && ((MODE) == DFmode || (MODE) == SFmode\t\t\\\n+\t  || (MODE) == DCmode || (MODE) == SCmode ))\t\\\n+   ? FIRST_FP_RET_REG\t\t\t\t\t\\\n    : FIRST_RET_REG)\n \n #define BASE_ARG_REG(MODE) \\\n   ((TARGET_SH3E && ((MODE) == SFmode))\t\t\t\\\n    ? FIRST_FP_PARM_REG\t\t\t\t\t\\\n+   : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT\t\\\n+\t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT)\\\n+   ? FIRST_FP_PARM_REG\t\t\t\t\t\\\n    : FIRST_PARM_REG)\n \n /* Define how to find the value returned by a function.\n    VALTYPE is the data type of the value (as a tree).\n    If the precise function being called is known, FUNC is its FUNCTION_DECL;\n-   otherwise, FUNC is 0.  */\n-\n-#define FUNCTION_VALUE(VALTYPE, FUNC) \\\n-  LIBCALL_VALUE (TYPE_MODE (VALTYPE))\n+   otherwise, FUNC is 0.\n+   For the SH, this is like LIBCALL_VALUE, except that we must change the\n+   mode like PROMOTE_MODE does.\n+   ??? PROMOTE_MODE is ignored for non-scalar types.  The set of types\n+   tested here has to be kept in sync with the one in explow.c:promote_mode.  */\n+\n+#define FUNCTION_VALUE(VALTYPE, FUNC)\t\t\t\t\t\\\n+  gen_rtx (REG,\t\t\t\t\t\t\t\t\\\n+\t   ((GET_MODE_CLASS (TYPE_MODE (VALTYPE)) == MODE_INT\t\t\\\n+\t     && GET_MODE_SIZE (TYPE_MODE (VALTYPE)) < UNITS_PER_WORD\t\\\n+\t     && (TREE_CODE (VALTYPE) == INTEGER_TYPE\t\t\t\\\n+\t\t || TREE_CODE (VALTYPE) == ENUMERAL_TYPE\t\t\\\n+\t\t || TREE_CODE (VALTYPE) == BOOLEAN_TYPE\t\t\t\\\n+\t\t || TREE_CODE (VALTYPE) == CHAR_TYPE\t\t\t\\\n+\t\t || TREE_CODE (VALTYPE) == REAL_TYPE\t\t\t\\\n+\t\t || TREE_CODE (VALTYPE) == OFFSET_TYPE))\t\t\\\n+\t    ? SImode : TYPE_MODE (VALTYPE)),\t\t\t\t\\\n+\t   BASE_RETURN_VALUE_REG (TYPE_MODE (VALTYPE)))\n      \n /* Define how to find the value returned by a library function\n    assuming the value has mode MODE.  */\n #define LIBCALL_VALUE(MODE) \\\n-  gen_rtx (REG, (MODE), BASE_RETURN_VALUE_REG (MODE));\n+  gen_rtx (REG, (MODE), BASE_RETURN_VALUE_REG (MODE))\n \n /* 1 if N is a possible register number for a function value. */\n #define FUNCTION_VALUE_REGNO_P(REGNO) \\\n@@ -801,7 +950,11 @@ struct sh_args {\n #define CUMULATIVE_ARGS  struct sh_args\n \n #define GET_SH_ARG_CLASS(MODE) \\\n-  ((TARGET_SH3E && ((MODE) == SFmode)) ? SH_ARG_FLOAT : SH_ARG_INT)\n+  ((TARGET_SH3E && (MODE) == SFmode) \\\n+   ? SH_ARG_FLOAT \\\n+   : TARGET_SH4 && (GET_MODE_CLASS (MODE) == MODE_FLOAT \\\n+\t\t    || GET_MODE_CLASS (MODE) == MODE_COMPLEX_FLOAT) \\\n+   ? SH_ARG_FLOAT : SH_ARG_INT)\n \n #define ROUND_ADVANCE(SIZE) \\\n   (((SIZE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n@@ -813,7 +966,9 @@ struct sh_args {\n    round doubles to even regs when asked to explicitly.  */\n \n #define ROUND_REG(CUM, MODE) \\\n-   ((TARGET_ALIGN_DOUBLE\t\t\t\t\t\\\n+   (((TARGET_ALIGN_DOUBLE\t\t\t\t\t\\\n+      || (TARGET_SH4 && ((MODE) == DFmode || (MODE) == DCmode)\t\\\n+\t  && (CUM).arg_count[(int) SH_ARG_FLOAT] < NPARM_REGS (MODE)))\\\n      && GET_MODE_UNIT_SIZE ((MODE)) > UNITS_PER_WORD)\t\t\\\n     ? ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\t\\\n        + ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] & 1))\t\\\n@@ -838,11 +993,12 @@ struct sh_args {\n    available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)] =\t\\\n-\t  (ROUND_REG ((CUM), (MODE))\t\t\t\\\n-\t   + ((MODE) != BLKmode\t\t\t\t\\\n-\t      ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n-\t      : ROUND_ADVANCE (int_size_in_bytes (TYPE)))))\n+ if (! TARGET_SH4 || PASS_IN_REG_P ((CUM), (MODE), (TYPE))) \\\n+   ((CUM).arg_count[(int) GET_SH_ARG_CLASS (MODE)]\t\\\n+    = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n+       + ((MODE) == BLKmode\t\t\t\t\\\n+\t  ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\\\n+\t  : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))))\n \n /* Return boolean indicating arg of mode MODE will be passed in a reg.\n    This macro is only used in this file. */\n@@ -883,7 +1039,9 @@ extern int current_function_varargs;\n   ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\t\\\n     && ((NAMED) || TARGET_SH3E || ! current_function_varargs))\t\t\\\n    ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t      (BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE)))) \\\n+\t      ((BASE_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))) \t\\\n+\t       ^ ((MODE) == SFmode && TARGET_SH4\t\t\t\\\n+\t\t  && TARGET_LITTLE_ENDIAN != 0)))\t\t\t\\\n    : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n@@ -894,8 +1052,9 @@ extern int current_function_varargs;\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \\\n   ((PASS_IN_REG_P ((CUM), (MODE), (TYPE))\t\t\t\\\n+    && ! TARGET_SH4\t\t\t\t\t\t\\\n     && (ROUND_REG ((CUM), (MODE))\t\t\t\t\\\n-\t+ (MODE != BLKmode\t\t\t\t\t\\\n+\t+ ((MODE) != BLKmode\t\t\t\t\t\\\n \t   ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\t\\\n \t   : ROUND_ADVANCE (int_size_in_bytes (TYPE)))\t\t\\\n \t- NPARM_REGS (MODE) > 0))\t\t\t\t\\\n@@ -955,7 +1114,7 @@ extern int current_function_anonymous_args;\n \n /* Alignment required for a trampoline in bits .  */\n #define TRAMPOLINE_ALIGNMENT \\\n-  ((CACHE_LOG < 3 || TARGET_SMALLCODE) ? 32 : 64) \\\n+  ((CACHE_LOG < 3 || TARGET_SMALLCODE && ! TARGET_HARWARD) ? 32 : 64)\n \n /* Emit RTL insns to initialize the variable parts of a trampoline.\n    FNADDR is an RTX for the address of the function's pure code.\n@@ -971,6 +1130,8 @@ extern int current_function_anonymous_args;\n \t\t  (CXT));\t\t\t\t\t\t\\\n   emit_move_insn (gen_rtx (MEM, SImode, plus_constant ((TRAMP), 12)),\t\\\n \t\t  (FNADDR));\t\t\t\t\t\t\\\n+  if (TARGET_HARWARD)\t\t\t\t\t\t\t\\\n+    emit_insn (gen_ic_invalidate_line (TRAMP));\t\t\t\t\\\n }\n \n /* A C expression whose value is RTL representing the value of the return\n@@ -1086,7 +1247,10 @@ extern struct rtx_def *sh_builtin_saveregs ();\n #define MODE_DISP_OK_4(X,MODE) \\\n (GET_MODE_SIZE (MODE) == 4 && (unsigned) INTVAL (X) < 64\t\\\n  && ! (INTVAL (X) & 3) && ! (TARGET_SH3E && (MODE) == SFmode))\n-#define MODE_DISP_OK_8(X,MODE) ((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60) && (!(INTVAL(X) &3)))\n+\n+#define MODE_DISP_OK_8(X,MODE) \\\n+((GET_MODE_SIZE(MODE)==8) && ((unsigned)INTVAL(X)<60)\t\\\n+ && ! (INTVAL(X) & 3) && ! (TARGET_SH4 && (MODE) == DFmode))\n \n #define BASE_REGISTER_RTX_P(X)\t\t\t\t\\\n   ((GET_CODE (X) == REG && REG_OK_FOR_BASE_P (X))\t\\\n@@ -1141,13 +1305,15 @@ extern struct rtx_def *sh_builtin_saveregs ();\n   else if ((GET_CODE (X) == POST_INC || GET_CODE (X) == PRE_DEC)\t\\\n \t   && BASE_REGISTER_RTX_P (XEXP ((X), 0)))\t\t\t\\\n     goto LABEL;\t\t\t\t\t\t\t\t\\\n-  else if (GET_CODE (X) == PLUS && MODE != PSImode)\t\t\t\\\n+  else if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+\t   && ((MODE) != PSImode || reload_completed))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx xop0 = XEXP ((X), 0);\t\t\t\t\t\t\\\n       rtx xop1 = XEXP ((X), 1);\t\t\t\t\t\t\\\n       if (GET_MODE_SIZE (MODE) <= 8 && BASE_REGISTER_RTX_P (xop0))\t\\\n \tGO_IF_LEGITIMATE_INDEX ((MODE), xop1, LABEL);\t\t\t\\\n-      if (GET_MODE_SIZE (MODE) <= 4)\t\t\t\t\t\\\n+      if (GET_MODE_SIZE (MODE) <= 4\t\t\t\t\t\\\n+\t  || TARGET_SH4 && TARGET_FMOVD && MODE == DFmode)\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t  if (BASE_REGISTER_RTX_P (xop1) && INDEX_REGISTER_RTX_P (xop0))\\\n \t    goto LABEL;\t\t\t\t\t\t\t\\\n@@ -1181,6 +1347,7 @@ extern struct rtx_def *sh_builtin_saveregs ();\n \t  || GET_MODE_SIZE (MODE) == 8)\t\t\t\t\\\n       && GET_CODE (XEXP ((X), 1)) == CONST_INT\t\t\t\\\n       && BASE_REGISTER_RTX_P (XEXP ((X), 0))\t\t\t\\\n+      && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\\\n       && ! (TARGET_SH3E && (MODE) == SFmode))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n       rtx index_rtx = XEXP ((X), 1);\t\t\t\t\\\n@@ -1228,12 +1395,21 @@ extern struct rtx_def *sh_builtin_saveregs ();\n       && (GET_MODE_SIZE (MODE) == 4 || GET_MODE_SIZE (MODE) == 8)\t\\\n       && GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n       && BASE_REGISTER_RTX_P (XEXP (X, 0))\t\t\t\t\\\n-      && ! (TARGET_SH3E && MODE == SFmode))\t\t\t\t\\\n+      && ! (TARGET_SH4 && (MODE) == DFmode)\t\t\t\t\\\n+      && ! ((MODE) == PSImode && (TYPE) == RELOAD_FOR_INPUT_ADDRESS))\t\\\n     {\t\t\t\t\t\t\t\t\t\\\n       rtx index_rtx = XEXP (X, 1);\t\t\t\t\t\\\n       HOST_WIDE_INT offset = INTVAL (index_rtx), offset_base;\t\t\\\n       rtx sum;\t\t\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_SH3E && MODE == SFmode)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  X = copy_rtx (X);\t\t\t\t\t\t\\\n+\t  push_reload (index_rtx, NULL_RTX, &XEXP (X, 1), NULL_PTR,\t\\\n+\t\t       INDEX_REG_CLASS, Pmode, VOIDmode, 0, 0, (OPNUM),\t\\\n+\t\t       (TYPE));\t\t\t\t\t\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       /* Instead of offset_base 128..131 use 124..127, so that\t\t\\\n \t simple add suffices.  */\t\t\t\t\t\\\n       if (offset > 127)\t\t\t\t\t\t\t\\\n@@ -1315,7 +1491,7 @@ extern struct rtx_def *sh_builtin_saveregs ();\n \n /* Since the SH3e has only `float' support, it is desirable to make all\n    floating point types equivalent to `float'.  */\n-#define DOUBLE_TYPE_SIZE (TARGET_SH3E ? 32 : 64)\n+#define DOUBLE_TYPE_SIZE ((TARGET_SH3E && ! TARGET_SH4) ? 32 : 64)\n \n /* 'char' is signed by default.  */\n #define DEFAULT_SIGNED_CHAR  1\n@@ -1407,14 +1583,25 @@ extern struct rtx_def *sh_builtin_saveregs ();\n       return 10;\n \n #define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\\\n+  case PLUS:\t\t\t\t\t\t\\\n+    return (COSTS_N_INSNS (1)\t\t\t\t\\\n+\t    + rtx_cost (XEXP ((X), 0), PLUS)\t\t\\\n+\t    + (rtx_equal_p (XEXP ((X), 0), XEXP ((X), 1))\\\n+\t       ? 0 : rtx_cost (XEXP ((X), 1), PLUS)));\\\n   case AND:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (andcosts (X));\t\t\\\n   case MULT:\t\t\t\t\t\t\\\n     return COSTS_N_INSNS (multcosts (X));\t\t\\\n   case ASHIFT:\t\t\t\t\t\t\\\n   case ASHIFTRT:\t\t\t\t\t\\\n   case LSHIFTRT:\t\t\t\t\t\\\n-    return COSTS_N_INSNS (shiftcosts (X)) ;\t\t\\\n+    /* Add one extra unit for the matching constraint.\t\\\n+       Otherwise loop strength reduction would think that\\\n+       a shift with different sourc and destination is\t\\\n+       as cheap as adding a constant to a register.  */\t\\\n+    return (COSTS_N_INSNS (shiftcosts (X))\t\t\\\n+\t    + rtx_cost (XEXP ((X), 0), (CODE))\t\t\\\n+\t    + 1);\t\t\t\t\t\\\n   case DIV:\t\t\t\t\t\t\\\n   case UDIV:\t\t\t\t\t\t\\\n   case MOD:\t\t\t\t\t\t\\\n@@ -1462,11 +1649,29 @@ extern struct rtx_def *sh_builtin_saveregs ();\n /* Compute extra cost of moving data between one register class\n    and another.  */\n \n+/* Regclass always uses 2 for moves in the same register class;\n+   If SECONDARY*_RELOAD_CLASS says something about the src/dst pair,\n+   it uses this information.  Hence, the general register <-> floating point\n+   register information here is not used for SFmode.  */\n #define REGISTER_MOVE_COST(SRCCLASS, DSTCLASS) \\\n-  ((DSTCLASS) == PR_REG ? 10\t\t\\\n-   : (((DSTCLASS) == FP_REGS && (SRCCLASS) == GENERAL_REGS)\t\t\\\n-      || ((DSTCLASS) == GENERAL_REGS && (SRCCLASS) == FP_REGS)) ? 4\t\\\n-   : 1)\n+  ((((DSTCLASS) == T_REGS) || ((DSTCLASS) == PR_REG)) ? 10\t\t\\\n+   : ((((DSTCLASS) == FP0_REGS || (DSTCLASS) == FP_REGS || (DSTCLASS) == DF_REGS) \\\n+       && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n+      || (((DSTCLASS) == GENERAL_REGS || (DSTCLASS) == R0_REGS)\t\t\\\n+\t  && ((SRCCLASS) == FP0_REGS || (SRCCLASS) == FP_REGS\t\t\\\n+\t      || (SRCCLASS) == DF_REGS)))\t\t\t\t\\\n+   ? TARGET_FMOVD ? 8 : 12\t\t\t\t\t\t\\\n+   : (((DSTCLASS) == FPUL_REGS\t\t\t\t\t\t\\\n+       && ((SRCCLASS) == GENERAL_REGS || (SRCCLASS) == R0_REGS))\t\\\n+      || (SRCCLASS == FPUL_REGS\t\t\t\t\t\t\\\n+\t  && ((DSTCLASS) == GENERAL_REGS || (DSTCLASS) == R0_REGS)))\t\\\n+   ? 5\t\t\t\t\t\t\t\t\t\\\n+   : (((DSTCLASS) == FPUL_REGS\t\t\t\t\t\t\\\n+       && ((SRCCLASS) == PR_REGS || (SRCCLASS) == MAC_REGS))\t\t\\\n+      || ((SRCCLASS) == FPUL_REGS\t\t\t\t\t\\\n+\t  && ((DSTCLASS) == PR_REGS || (DSTCLASS) == MAC_REGS)))\t\\\n+   ? 7\t\t\t\t\t\t\t\t\t\\\n+   : 2)\n \n /* ??? Perhaps make MEMORY_MOVE_COST depend on compiler option?  This\n    would be so that people would slow memory systems could generate\n@@ -1573,13 +1778,32 @@ dtors_section()\t\t\t\t\t\t\t\\\n    the Real framepointer; it can also be used as a normal general register.\n    Note that the name `fp' is horribly misleading since `fp' is in fact only\n    the argument-and-return-context pointer.  */\n+\n+extern char fp_reg_names[][5];\n+\n #define REGISTER_NAMES  \t\t\t\t\\\n+{\t\t\t\t                   \t\\\n+  \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n+  \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n+  \"ap\", \"pr\", \"t\",   \"gbr\", \"mach\",\"macl\", fp_reg_names[16], \"rap\", \\\n+  fp_reg_names[0],  fp_reg_names[1] , fp_reg_names[2],  fp_reg_names[3], \\\n+  fp_reg_names[4],  fp_reg_names[5],  fp_reg_names[6],  fp_reg_names[7], \\\n+  fp_reg_names[8],  fp_reg_names[9],  fp_reg_names[10], fp_reg_names[11], \\\n+  fp_reg_names[12], fp_reg_names[13], fp_reg_names[14], fp_reg_names[15], \\\n+  fp_reg_names[17], fp_reg_names[18], fp_reg_names[19], fp_reg_names[20], \\\n+  fp_reg_names[21], fp_reg_names[22], fp_reg_names[23], fp_reg_names[24], \\\n+  \"fpscr\", \\\n+}\n+\n+#define DEBUG_REGISTER_NAMES  \t\t\t\t\\\n {\t\t\t\t                   \t\\\n   \"r0\", \"r1\", \"r2\",  \"r3\",  \"r4\",  \"r5\",  \"r6\",  \"r7\", \t\\\n   \"r8\", \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"r14\", \"r15\",\t\\\n   \"ap\", \"pr\", \"t\",  \"gbr\", \"mach\",\"macl\", \"fpul\",\"rap\", \\\n   \"fr0\",\"fr1\",\"fr2\", \"fr3\", \"fr4\", \"fr5\", \"fr6\", \"fr7\", \\\n   \"fr8\",\"fr9\",\"fr10\",\"fr11\",\"fr12\",\"fr13\",\"fr14\",\"fr15\",\\\n+  \"xd0\",\"xd2\",\"xd4\", \"xd6\", \"xd8\", \"xd10\",\"xd12\",\"xd14\", \\\n+  \"fpscr\", \\\n }\n \n /* DBX register number for a given compiler register number.  */\n@@ -1773,7 +1997,8 @@ enum processor_type {\n   PROCESSOR_SH1,\n   PROCESSOR_SH2,\n   PROCESSOR_SH3,\n-  PROCESSOR_SH3E\n+  PROCESSOR_SH3E,\n+  PROCESSOR_SH4\n };\n \n #define sh_cpu_attr ((enum attr_cpu)sh_cpu)\n@@ -1837,6 +2062,11 @@ extern int sh_valid_machine_decl_attribute ();\n #define VALID_MACHINE_DECL_ATTRIBUTE(DECL, ATTRIBUTES, IDENTIFIER, ARGS) \\\n sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n \n+extern int sh_flag_remove_dead_before_cse;\n+extern int rtx_equal_function_value_matters;\n+extern struct rtx_def *fpscr_rtx;\n+extern struct rtx_def *get_fpscr_rtx ();\n+\n \n #define MOVE_RATIO (TARGET_SMALLCODE ? 2 : 16)\n \f\n@@ -1860,10 +2090,16 @@ sh_valid_machine_decl_attribute (DECL, ATTRIBUTES, IDENTIFIER, ARGS)\n   {\"arith_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n   {\"arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\t\\\n   {\"arith_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"binary_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n   {\"braf_label_ref_operand\", {LABEL_REF}},\t\t\t\t\\\n+  {\"commutative_float_operator\", {PLUS, MULT}},\t\t\t\t\\\n+  {\"fp_arith_reg_operand\", {SUBREG, REG}},\t\t\t\t\\\n+  {\"fp_extended_operand\", {SUBREG, REG, FLOAT_EXTEND}},\t\t\t\\\n+  {\"fpscr_operand\", {REG}},\t\t\t\t\t\t\\\n   {\"general_movsrc_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\\\n   {\"general_movdst_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\\\n   {\"logical_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"noncommutative_float_operator\", {MINUS, DIV}},\t\t\t\\\n   {\"register_operand\", {SUBREG, REG}},\n \n /* Define this macro if it is advisable to hold scalars in registers\n@@ -1929,7 +2165,7 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t using their arguments pretty quickly.\t\t\t\t\\\n \t Assume a four cycle delay before they are needed.  */\t\t\\\n       if (! reg_set_p (reg, dep_insn))\t\t\t\t\t\\\n-\tcost -= 4;\t\t\t\t\t\t\t\\\n+\tcost -= TARGET_SUPERSCALAR ? 40 : 4;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\t\t\\\n   /* Adjust load_si / pcload_si type insns latency.  Use the known\t\\\n      nominal latency and form of the insn to speed up the check.  */\t\\\n@@ -1939,9 +2175,14 @@ do {\t\t\t\t\t\t\t\t\t\\\n \t      it's actually a move insn.  */\t\t\t\t\\\n \t   && general_movsrc_operand (SET_SRC (PATTERN (dep_insn)), SImode))\\\n     cost = 2;\t\t\t\t\t\t\t\t\\\n+  else if (cost == 30\t\t\t\t\t\t\t\\\n+\t   && GET_CODE (PATTERN (dep_insn)) == SET\t\t\t\\\n+\t   && GET_MODE (SET_SRC (PATTERN (dep_insn))) == SImode)\t\\\n+    cost = 20;\t\t\t\t\t\t\t\t\\\n } while (0)\t\t\t\t\t\t\t\t\\\n \n /* For the sake of libgcc2.c, indicate target supports atexit.  */\n #define HAVE_ATEXIT\n \n-#define SH_DYNAMIC_SHIFT_COST (TARGET_SH3 ? (TARGET_SMALLCODE ? 1 : 2) : 20)\n+#define SH_DYNAMIC_SHIFT_COST \\\n+  (TARGET_HARD_SH4 ? 1 : TARGET_SH3 ? (TARGET_SMALLCODE ? 1 : 2) : 20)"}, {"sha": "8dde68e856f5724db4d297c190d8df60ddf1443f", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 1342, "deletions": 102, "changes": 1444, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -70,13 +70,20 @@\n ;; Target CPU.\n \n (define_attr \"cpu\"\n- \"sh1,sh2,sh3,sh3e\"\n+ \"sh1,sh2,sh3,sh3e,sh4\"\n   (const (symbol_ref \"sh_cpu_attr\")))\n \n (define_attr \"endian\" \"big,little\"\n  (const (if_then_else (symbol_ref \"TARGET_LITTLE_ENDIAN\")\n \t\t      (const_string \"little\") (const_string \"big\"))))\n \n+(define_attr \"fmovd\" \"yes,no\"\n+  (const (if_then_else (symbol_ref \"TARGET_FMOVD\")\n+\t\t       (const_string \"yes\") (const_string \"no\"))))\n+;; issues/clock\n+(define_attr \"issues\" \"1,2\"\n+  (const (if_then_else (symbol_ref \"TARGET_SUPERSCALAR\") (const_string \"2\") (const_string \"1\"))))\n+\n ;; cbranch\tconditional branch instructions\n ;; jump\t\tunconditional jumps\n ;; arith\tordinary arithmetic\n@@ -101,10 +108,12 @@\n ;; fp\t\tfloating point\n ;; fdiv\t\tfloating point divide (or square root)\n ;; gp_fpul\tmove between general purpose register and fpul\n+;; dfp_arith, dfp_cmp,dfp_conv\n+;; dfdiv\tdouble precision floating point divide (or square root)\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,other,load,load_si,store,move,fmove,smpy,dmpy,return,pload,pstore,pcload,pcload_si,rte,sfunc,call,fp,fdiv,gp_fpul,nil\"\n+ \"cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,other,load,load_si,store,move,fmove,smpy,dmpy,return,pload,pstore,pcload,pcload_si,rte,sfunc,call,fp,fdiv,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,nil\"\n   (const_string \"other\"))\n \n ; If a conditional branch destination is within -252..258 bytes away\n@@ -252,34 +261,216 @@\n ;; We only do this for SImode loads of general registers, to make the work\n ;; for ADJUST_COST easier.\n (define_function_unit \"memory\" 1 0\n-  (eq_attr \"type\" \"load_si,pcload_si\")\n+  (and (eq_attr \"issues\" \"1\")\n+       (eq_attr \"type\" \"load_si,pcload_si\"))\n   3 2)\n (define_function_unit \"memory\" 1 0\n-  (eq_attr \"type\" \"load,pcload,pload,store,pstore\")\n+  (and (eq_attr \"issues\" \"1\")\n+       (eq_attr \"type\" \"load,pcload,pload,store,pstore\"))\n   2 2)\n \n (define_function_unit \"int\"    1 0\n-  (eq_attr \"type\" \"arith3,arith3b\") 3 3)\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"arith3,arith3b\")) 3 3)\n \n (define_function_unit \"int\"    1 0\n-  (eq_attr \"type\" \"dyn_shift\") 2 2)\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"dyn_shift\")) 2 2)\n \n (define_function_unit \"int\"    1 0\n-  (eq_attr \"type\" \"arith,arith3b,dyn_shift\") 2 2)\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"!arith3,arith3b,dyn_shift\")) 1 1)\n \n ;; ??? These are approximations.\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"smpy\") 2 2)\n-(define_function_unit \"mpy\"    1 0 (eq_attr \"type\" \"dmpy\") 3 3)\n+(define_function_unit \"mpy\"    1 0\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"smpy\")) 2 2)\n+(define_function_unit \"mpy\"    1 0\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"dmpy\")) 3 3)\n+\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"fp,fmove\")) 2 1)\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"1\") (eq_attr \"type\" \"fdiv\")) 13 12)\n+\n+\n+;; SH4 scheduling\n+;; The SH4 is a dual-issue implementation, thus we have to multiply all\n+;; costs by at least two.\n+;; There will be single increments of the modeled that don't correspond\n+;; to the actual target ;; whenever two insns to be issued depend one a\n+;; single resource, and the scheduler picks to be the first one.\n+;; If we multiplied the costs just by two, just two of these single\n+;; increments would amount to an actual cycle.  By picking a larger\n+;; factor, we can ameliorate the effect; However, we then have to make sure\n+;; that only two insns are modeled as issued per actual cycle.\n+;; Moreover, we need a way to specify the latency of insns that don't\n+;; use an actual function unit.\n+;; We use an 'issue' function unit to do that, and a cost factor of 10.\n+\n+(define_function_unit \"issue\" 2 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"!nil,arith3\"))\n+  10 10)\n+\n+(define_function_unit \"issue\" 2 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"arith3\"))\n+  30 30)\n+\n+;; There is no point in providing exact scheduling information about branches,\n+;; because they are at the starts / ends of basic blocks anyways.\n+\n+;; Some insns cannot be issued before/after another insn in the same cycle,\n+;; irrespective of the type of the other insn.\n+\n+;; default is dual-issue, but can't be paired with an insn that\n+;; uses multiple function units.\n+(define_function_unit \"single_issue\"     1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"!smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul,call,sfunc,arith3,arith3b\"))\n+  1 10\n+  [(eq_attr \"type\" \"smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul\")])\n+\n+(define_function_unit \"single_issue\"     1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"smpy,dmpy,pload,pstore,dfp_cmp,gp_fpul\"))\n+  10 10\n+  [(const_int 1)])\n+\n+;; arith3 insns are always pairable at the start, but not inecessarily at\n+;; the end; however, there doesn;t seem to be a way to express that.\n+(define_function_unit \"single_issue\"     1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"arith3\"))\n+  30 20\n+  [(const_int 1)])\n+\n+;; arith3b insn are pairable at the end and have latency that prevents pairing\n+;; with the following branch, but we don't want this latency be respected;\n+;; When the following branch is immediately adjacent, we can redirect the\n+;; internal branch, which is likly to be a larger win.\n+(define_function_unit \"single_issue\"     1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"arith3b\"))\n+  20 20\n+  [(const_int 1)])\n+\n+;; calls introduce a longisch delay that is likely to flush the pipelines.\n+(define_function_unit \"single_issue\"     1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"call,sfunc\"))\n+  160 160\n+  [(eq_attr \"type\" \"!call\") (eq_attr \"type\" \"call\")])\n+\n+;; Load and store instructions have no alignment peculiarities for the SH4,\n+;; but they use the load-store unit, which they share with the fmove type\n+;; insns (fldi[01]; fmov frn,frm; flds; fsts; fabs; fneg) .\n+;; Loads have a latency of two.\n+;; However, call insns can only paired with a preceding insn, and have\n+;; a delay slot, so that we want two more insns to be scheduled between the\n+;; load of the function address and the call.  This is equivalent to a\n+;; latency of three.\n+;; We cannot use a conflict list for this, because we need to distinguish\n+;; between the actual call address and the function arguments.\n+;; ADJUST_COST can only properly handle reductions of the cost, so we\n+;; use a latency of three here, which gets multiplied by 10 to yield 30.\n+;; We only do this for SImode loads of general registers, to make the work\n+;; for ADJUST_COST easier.\n \n-(define_function_unit \"fp\"     1 0 (eq_attr \"type\" \"fp,fmove\") 2 1)\n-(define_function_unit \"fp\"     1 0 (eq_attr \"type\" \"fdiv\") 13 12)\n+;; When specifying different latencies for different insns using the\n+;; the same function unit, genattrtab.c assumes a 'FIFO constraint'\n+;; so that the blockage is at least READY-COST (E) + 1 - READY-COST (C)\n+;; for an executing insn E and a candidate insn C.\n+;; Therefore, we define three different function units for load_store:\n+;; load_store, load and load_si.\n+\n+(define_function_unit \"load_si\" 1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"load_si,pcload_si\")) 30 10)\n+(define_function_unit \"load\" 1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"load,pcload,pload\")) 20 10)\n+(define_function_unit \"load_store\" 1 0\n+  (and (eq_attr \"issues\" \"2\")\n+       (eq_attr \"type\" \"load_si,pcload_si,load,pcload,pload,store,pstore,fmove\"))\n+  10 10)\n \n+(define_function_unit \"int\"    1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"arith,dyn_shift\")) 10 10)\n+\n+;; Again, we have to pretend a lower latency for the \"int\" unit to avoid a\n+;; spurious FIFO constraint; the multiply instructions use the \"int\"\n+;; unit actually only for two cycles.\n+(define_function_unit \"int\"    1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"smpy,dmpy\")) 20 20)\n+\n+;; We use a fictous \"mpy\" unit to express the actual latency.\n+(define_function_unit \"mpy\"    1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"smpy,dmpy\")) 40 20)\n+\n+;; Again, we have to pretend a lower latency for the \"int\" unit to avoid a\n+;; spurious FIFO constraint.\n+(define_function_unit \"int\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"gp_fpul\")) 10 10)\n+\n+;; We use a fictous \"gp_fpul\" unit to express the actual latency.\n+(define_function_unit \"gp_fpul\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"gp_fpul\")) 20 10)\n+\n+;; ??? multiply uses the floating point unit, but with a two cycle delay.\n+;; Thus, a simple single-precision fp operation could finish if issued in\n+;; the very next cycle, but stalls when issued two or three cycles later.\n+;; Similarily, a divide / sqrt can work without stalls if issued in\n+;; the very next cycle, while it would have to block if issued two or\n+;; three cycles later.\n+;; There is no way to model this with gcc's function units.  This problem is\n+;; actually mentioned in md.texi.  Tackling this problem requires first that\n+;; it is possible to speak about the target in an open discussion.\n+;; \n+;; However, simple double-precision operations always conflict.\n+\n+(define_function_unit \"fp\"    1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"smpy,dmpy\")) 40 40\n+  [(eq_attr \"type\" \"dfp_cmp,dfp_conv,dfp_arith\")])\n+\n+;; The \"fp\" unit is for pipeline stages F1 and F2.\n+\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"fp\")) 30 10)\n+\n+;; Again, we have to pretend a lower latency for the \"fp\" unit to avoid a\n+;; spurious FIFO constraint; the bulk of the fdiv type insns executes in\n+;; the F3 stage.\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"fdiv\")) 30 10)\n+\n+;; The \"fdiv\" function unit models the aggregate effect of the F1, F2 and F3\n+;; pipeline stages on the pipelining of fdiv/fsqrt insns.\n+;; We also use it to give the actual latency here.\n+;; fsqrt is actually one cycle faster than fdiv (and the value used here),\n+;; but that will hardly matter in practice for scheduling.\n+(define_function_unit \"fdiv\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"fdiv\")) 120 100)\n+\n+;; There is again a late use of the \"fp\" unit by [d]fdiv type insns\n+;; that we can't express.\n+\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"dfp_cmp,dfp_conv\")) 40 20)\n+\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"dfp_arith\")) 80 60)\n+\n+(define_function_unit \"fp\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"dfdiv\")) 230 10)\n+\n+(define_function_unit \"fdiv\"     1 0\n+  (and (eq_attr \"issues\" \"2\") (eq_attr \"type\" \"dfdiv\")) 230 210)\n \n ; Definitions for filling branch delay slots.\n \n (define_attr \"needs_delay_slot\" \"yes,no\" (const_string \"no\"))\n \n-(define_attr \"hit_stack\" \"yes,no\" (const_string \"no\"))\n+;; ??? This should be (nil) instead of (const_int 0)\n+(define_attr \"hit_stack\" \"yes,no\"\n+\t(cond [(eq (symbol_ref \"find_regno_note (insn, REG_INC, 15)\") (const_int 0))\n+\t       (const_string \"no\")]\n+\t      (const_string \"yes\")))\n \n (define_attr \"interrupt_function\" \"no,yes\"\n   (const (symbol_ref \"pragma_interrupt\")))\n@@ -668,7 +859,42 @@\n    (clobber (reg:SI 17))\n    (clobber (reg:SI 4))\n    (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n-  \"\"\n+  \"! TARGET_SH4\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"udivsi3_i4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(udiv:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:DF 24))\n+   (clobber (reg:DF 26))\n+   (clobber (reg:DF 28))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))\n+   (use (reg:PSI 48))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH4 && ! TARGET_FPU_SINGLE\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"udivsi3_i4_single\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(udiv:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:DF 24))\n+   (clobber (reg:DF 26))\n+   (clobber (reg:DF 28))\n+   (clobber (reg:SI 0))\n+   (clobber (reg:SI 1))\n+   (clobber (reg:SI 4))\n+   (clobber (reg:SI 5))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_HARD_SH4 && TARGET_FPU_SINGLE\"\n   \"jsr\t@%1%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n@@ -685,7 +911,22 @@\n \t      (clobber (reg:SI 4))\n \t      (use (match_dup 3))])]\n   \"\"\n-  \"operands[3] = gen_reg_rtx(SImode);\")\n+  \"\n+{\n+  operands[3] = gen_reg_rtx(SImode);\n+  if (TARGET_HARD_SH4)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 5), operands[2]);\n+      emit_move_insn (operands[3],\n+\t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__udivsi3_i4\\\"));\n+      if (TARGET_FPU_SINGLE)\n+\temit_insn (gen_udivsi3_i4_single (operands[0], operands[3]));\n+      else\n+\temit_insn (gen_udivsi3_i4 (operands[0], operands[3]));\n+      DONE;\n+    }\n+}\")\n \n (define_insn \"\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=z\")\n@@ -696,7 +937,33 @@\n    (clobber (reg:SI 2))\n    (clobber (reg:SI 3))\n    (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n-  \"\"\n+  \"! TARGET_SH4\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"divsi3_i4\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(div:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:DF 24))\n+   (clobber (reg:DF 26))\n+   (use (reg:PSI 48))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_SH4 && ! TARGET_FPU_SINGLE\"\n+  \"jsr\t@%1%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"divsi3_i4_single\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y\")\n+\t(div:SI (reg:SI 4) (reg:SI 5)))\n+   (clobber (reg:SI 17))\n+   (clobber (reg:DF 24))\n+   (clobber (reg:DF 26))\n+   (clobber (reg:SI 2))\n+   (use (match_operand:SI 1 \"arith_reg_operand\" \"r\"))]\n+  \"TARGET_HARD_SH4 && TARGET_FPU_SINGLE\"\n   \"jsr\t@%1%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n@@ -715,7 +982,22 @@\n \t      (clobber (reg:SI 3))\n \t      (use (match_dup 3))])]\n   \"\"\n-  \"operands[3] = gen_reg_rtx(SImode);\")\n+  \"\n+{\n+  operands[3] = gen_reg_rtx(SImode);\n+  if (TARGET_HARD_SH4)\n+    {\n+      emit_move_insn (gen_rtx (REG, SImode, 4), operands[1]);\n+      emit_move_insn (gen_rtx (REG, SImode, 5), operands[2]);\n+      emit_move_insn (operands[3],\n+\t\t      gen_rtx_SYMBOL_REF (SImode, \\\"__sdivsi3_i4\\\"));\n+      if (TARGET_FPU_SINGLE)\n+\temit_insn (gen_divsi3_i4_single (operands[0], operands[3]));\n+      else\n+\temit_insn (gen_divsi3_i4 (operands[0], operands[3]));\n+      DONE;\n+    }\n+}\")\n \f\n ;; -------------------------------------------------------------------------\n ;; Multiplication instructions\n@@ -782,7 +1064,6 @@\n (define_expand \"mulsi3_call\"\n   [(set (reg:SI 4) (match_operand:SI 1 \"general_operand\" \"\"))\n    (set (reg:SI 5) (match_operand:SI 2 \"general_operand\" \"\"))\n-   (set (match_dup 3) (symbol_ref:SI \"__mulsi3\"))\n    (parallel[(set (match_operand:SI 0 \"register_operand\" \"\")\n \t\t  (mult:SI (reg:SI 4)\n \t\t\t   (reg:SI 5)))\n@@ -792,9 +1073,9 @@\n \t     (clobber (reg:SI 3))\n \t     (clobber (reg:SI 2))\n \t     (clobber (reg:SI 1))\n-\t     (use (match_dup 3))])]\n+\t     (use (match_operand:SI 3 \"register_operand\" \"\"))])]\n   \"\"\n-  \"operands[3] = gen_reg_rtx(SImode);\")\n+  \"\")\n \n (define_insn \"mul_l\"\n   [(set (reg:SI 21)\n@@ -813,13 +1094,29 @@\n   \"\"\n   \"\n {\n+  rtx first, last;\n+\n   if (!TARGET_SH2)\n     {\n-      FAIL;\n-      /* ??? Does this give worse or better code?  */\n-      emit_insn (gen_mulsi3_call (operands[0], operands[1], operands[2]));\n-      DONE;\n+      /* The address must be set outside the libcall,\n+\t since it goes into a pseudo.  */\n+      rtx addr = force_reg (SImode, gen_rtx_SYMBOL_REF (SImode, \\\"__mulsi3\\\"));\n+      rtx insns = gen_mulsi3_call (operands[0], operands[1], operands[2], addr);\n+      first = XVECEXP (insns, 0, 0);\n+      last = XVECEXP (insns, 0, XVECLEN (insns, 0) - 1);\n+      emit_insn (insns);\n     }\n+  else\n+    {\n+      rtx macl = gen_rtx_REG (SImode, MACL_REG);\n+      first = emit_insn (gen_mul_l (operands[1], operands[2]));\n+      last = emit_insn (gen_movsi_i ((operands[0]), macl));\n+    }\n+  /* Wrap the sequence in REG_LIBCALL / REG_RETVAL notes so that loop\n+     invariant code motion can move it.  */\n+  REG_NOTES (first) = gen_rtx_INSN_LIST (REG_LIBCALL, last, REG_NOTES (first));\n+  REG_NOTES (last) = gen_rtx_INSN_LIST (REG_RETVAL, first, REG_NOTES (last));\n+  DONE;\n }\")\n \n (define_insn \"mulsidi3_i\"\n@@ -1767,50 +2064,65 @@\n \n ;; define push and pop so it is easy for sh.c\n \n-(define_insn \"push\"\n+(define_expand \"push\"\n   [(set (mem:SI (pre_dec:SI (reg:SI 15)))\n \t(match_operand:SI 0 \"register_operand\" \"r,l,x\"))]\n   \"\"\n-  \"@\n-\tmov.l\t%0,@-r15\n-\tsts.l\t%0,@-r15\n-\tsts.l\t%0,@-r15\"\n-  [(set_attr \"type\" \"store,pstore,store\")\n-   (set_attr \"hit_stack\" \"yes\")])\n+  \"\")\n \n-(define_insn \"pop\"\n+(define_expand \"pop\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r,l,x\")\n \t(mem:SI (post_inc:SI (reg:SI 15))))]\n   \"\"\n-  \"@\n-\tmov.l\t@r15+,%0\n-\tlds.l\t@r15+,%0\n-\tlds.l\t@r15+,%0\"\n-  [(set_attr \"type\" \"load,pload,load\")\n-   (set_attr \"hit_stack\" \"yes\")])\n+  \"\")\n+\n+(define_expand \"push_e\"\n+  [(parallel [(set (mem:SF (pre_dec:SI (reg:SI 15)))\n+\t\t   (match_operand:SF 0 \"\" \"\"))\n+\t      (use (reg:PSI 48))\n+\t      (clobber (scratch:SI))])]\n+  \"\"\n+  \"\")\n \n-(define_insn \"push_e\"\n-  [(set (mem:SF (pre_dec:SI (reg:SI 15)))\n-\t(match_operand:SF 0 \"register_operand\" \"r,f,y\"))]\n+(define_insn \"push_fpul\"\n+  [(set (mem:SF (pre_dec:SI (reg:SI 15))) (reg:SF 22))]\n   \"TARGET_SH3E\"\n-  \"@\n-\tmov.l\t%0,@-r15\n-\tfmov.s\t%0,@-r15\n-\tsts.l\t%0,@-r15\"\n+  \"sts.l\tfpul,@-r15\"\n   [(set_attr \"type\" \"store\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n-(define_insn \"pop_e\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=r,f,y\")\n-\t(mem:SF (post_inc:SI (reg:SI 15))))]\n+;; DFmode pushes for sh4 require a lot of what is defined for movdf_i4,\n+;; so use that.\n+(define_expand \"push_4\"\n+  [(parallel [(set (mem:DF (pre_dec:SI (reg:SI 15))) (match_operand:DF 0 \"\" \"\"))\n+\t      (use (reg:PSI 48))\n+\t      (clobber (scratch:SI))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"pop_e\"\n+  [(parallel [(set (match_operand:SF 0 \"\" \"\")\n+\t      (mem:SF (post_inc:SI (reg:SI 15))))\n+\t      (use (reg:PSI 48))\n+\t      (clobber (scratch:SI))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"pop_fpul\"\n+  [(set (reg:SF 22) (mem:SF (post_inc:SI (reg:SI 15))))]\n   \"TARGET_SH3E\"\n-  \"@\n-\tmov.l\t@r15+,%0\n-\tfmov.s\t@r15+,%0\n-\tlds.l\t@r15+,%0\"\n+  \"lds.l\t@r15+,fpul\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"hit_stack\" \"yes\")])\n \n+(define_expand \"pop_4\"\n+  [(parallel [(set (match_operand:DF 0 \"\" \"\")\n+\t\t   (mem:DF (post_inc:SI (reg:SI 15))))\n+\t      (use (reg:PSI 48))\n+\t      (clobber (scratch:SI))])]\n+  \"\"\n+  \"\")\n+\n ;; These two patterns can happen as the result of optimization, when\n ;; comparisons get simplified to a move of zero or 1 into the T reg.\n ;; They don't disappear completely, because the T reg is a fixed hard reg.\n@@ -1829,7 +2141,7 @@\n ;; of a pseudo-reg into the T reg\n (define_insn \"movsi_i\"\n   [(set (match_operand:SI 0 \"general_movdst_operand\" \"=t,r,r,r,r,r,m,<,<,xl,x,l,r\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"r,Q,rI,m,xl,t,r,x,l,r,>,>,i\"))]\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"r,Q,rI,mr,xl,t,r,x,l,r,>,>,i\"))]\n   \"\n    ! TARGET_SH3E\n    && (register_operand (operands[0], SImode)\n@@ -1856,8 +2168,8 @@\n ;; ??? This allows moves from macl to fpul to be recognized, but these moves\n ;; will require a reload.\n (define_insn \"movsi_ie\"\n-  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,m,<,<,xl,x,l,r,y,r,y\")\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,m,xl,t,r,x,l,r,>,>,i,r,y,y\"))]\n+  [(set (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,t,r,r,r,m,<,<,xl,x,l,y,r,y,r,y\")\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,r,mr,xl,t,r,x,l,r,>,>,>,i,r,y,y\"))]\n   \"TARGET_SH3E\n    && (register_operand (operands[0], SImode)\n        || register_operand (operands[1], SImode))\"\n@@ -1874,16 +2186,17 @@\n \tlds\t%1,%0\n \tlds.l\t%1,%0\n \tlds.l\t%1,%0\n+\tlds.l\t%1,%0\n \tfake\t%1,%0\n \tlds\t%1,%0\n \tsts\t%1,%0\n \t! move optimized away\"\n-  [(set_attr \"type\" \"pcload_si,move,*,load_si,move,move,store,store,pstore,move,load,pload,pcload_si,gp_fpul,gp_fpul,nil\")\n-   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n+  [(set_attr \"type\" \"pcload_si,move,*,load_si,move,move,store,store,pstore,move,load,pload,load,pcload_si,gp_fpul,gp_fpul,nil\")\n+   (set_attr \"length\" \"*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,*,0\")])\n \n (define_insn \"movsi_i_lowpart\"\n   [(set (strict_low_part (match_operand:SI 0 \"general_movdst_operand\" \"=r,r,r,r,r,m,r\"))\n-\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,m,xl,t,r,i\"))]\n+\t(match_operand:SI 1 \"general_movsrc_operand\" \"Q,rI,mr,xl,t,r,i\"))]\n    \"register_operand (operands[0], SImode)\n     || register_operand (operands[1], SImode)\"\n   \"@\n@@ -1901,6 +2214,30 @@\n   \"\"\n   \"{ if (prepare_move_operands (operands, SImode)) DONE; }\")\n \n+(define_expand \"ic_invalidate_line\"\n+  [(parallel [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"+r\")\n+\t\t\t\t(match_dup 1)] 12)\n+\t      (clobber (scratch:SI))])]\n+  \"TARGET_HARD_SH4\"\n+  \"\n+{\n+  operands[0] = force_reg (Pmode, operands[0]);\n+  operands[1] = force_reg (Pmode, GEN_INT (0xf0000008));\n+}\")\n+\n+;; The address %0 is assumed to be 4-aligned at least.  Thus, by ORing\n+;; 0xf0000008, we get the low-oder bits *1*00 (binary), ;; which fits\n+;; the requirement *0*00 for associative address writes.  The alignment of\n+;; %0 implies that its least significant bit is cleared,\n+;; thus we clear the V bit of a matching entry if there is one.\n+(define_insn \"ic_invalidate_line_i\"\n+  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r,r\")\n+\t\t     (match_operand:SI 1 \"register_operand\" \"r,r\")] 12)\n+   (clobber (match_scratch:SI 2 \"=&r,1\"))]\n+  \"TARGET_HARD_SH4\"\n+  \"ocbwb\\\\t@%0\\;extu.w\\\\t%0,%2\\;or\\\\t%r1,%r2\\;mov.l\\\\t%0,@%2\"\n+  [(set_attr \"length\" \"8\")])\n+\n (define_insn \"movqi_i\"\n   [(set (match_operand:QI 0 \"general_movdst_operand\" \"=r,r,m,r,r,l\")\n \t(match_operand:QI 1 \"general_movsrc_operand\"  \"ri,m,r,t,l,r\"))]\n@@ -2014,12 +2351,330 @@\n (define_insn \"movdf_k\"\n   [(set (match_operand:DF 0 \"general_movdst_operand\" \"=r,r,r,m\")\n \t(match_operand:DF 1 \"general_movsrc_operand\" \"r,FQ,m,r\"))]\n-  \"arith_reg_operand (operands[0], DFmode)\n-   || arith_reg_operand (operands[1], DFmode)\"\n+  \"(! TARGET_SH4 || reload_completed\n+    /* ??? We provide some insn so that direct_{load,store}[DFmode] get set */\n+    || GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3\n+    || GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3)\n+   && (arith_reg_operand (operands[0], DFmode)\n+       || arith_reg_operand (operands[1], DFmode))\"\n   \"* return output_movedouble (insn, operands, DFmode);\"\n   [(set_attr \"length\" \"4\")\n    (set_attr \"type\" \"move,pcload,load,store\")])\n \n+;; All alternatives of movdf_i4 are split for ! TARGET_FMOVD.\n+;; However, the d/F/c/z alternative cannot be split directly; it is converted\n+;; with special code in machine_dependent_reorg into a load of the R0_REG and\n+;; the d/m/c/X alternative, which is split later into single-precision\n+;; instructions.  And when not optimizing, no splits are done before fixing\n+;; up pcloads, so we need usable length information for that.\n+(define_insn \"movdf_i4\"\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"=d,r,d,d,m,r,r,m,!??r,!???d\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\" \"d,r,F,m,d,FQ,m,r,d,r\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c,c,c,c,c,c,c,c,c,c\"))\n+   (clobber (match_scratch:SI 3 \"=X,X,&z,X,X,X,X,X,X,X\"))]\n+  \"TARGET_SH4\n+   && (arith_reg_operand (operands[0], DFmode)\n+       || arith_reg_operand (operands[1], DFmode))\"\n+  \"@\n+\tfmov\t%1,%0\n+\t#\n+\t#\n+\tfmov.d\t%1,%0\n+\tfmov.d\t%1,%0\n+\t#\n+\t#\n+\t#\n+\t#\n+\t#\"\n+  [(set_attr_alternative \"length\"\n+     [(if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 2) (const_int 4))\n+      (const_int 4)\n+      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 4) (const_int 6))\n+      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 2) (const_int 6))\n+      (if_then_else (eq_attr \"fmovd\" \"yes\") (const_int 2) (const_int 6))\n+      (const_int 4)\n+      (const_int 8) (const_int 8) ;; these need only 8 bytes for @(r0,rn)\n+      (const_int 8) (const_int 8)])\n+   (set_attr \"type\" \"fmove,move,pcload,load,store,pcload,load,store,load,load\")])\n+\n+;; Moving DFmode between fp/general registers through memory\n+;; (the top of the stack) is faster than moving through fpul even for\n+;; little endian.  Because the type of an instruction is important for its\n+;; scheduling,  it is beneficial to split these operations, rather than\n+;; emitting them in one single chunk, even if this will expose a stack\n+;; use that will prevent scheduling of other stack accesses beyond this\n+;; instruction.\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"=X\"))]\n+  \"TARGET_SH4 && reload_completed\n+   && (true_regnum (operands[0]) < 16) != (true_regnum (operands[1]) < 16)\"\n+  [(const_int 0)]\n+  \"\n+{\n+  rtx insn, tos;\n+\n+  tos = gen_rtx (MEM, DFmode, gen_rtx (PRE_DEC, Pmode, stack_pointer_rtx));\n+  insn = emit_insn (gen_movdf_i4 (tos, operands[1], operands[2]));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, stack_pointer_rtx, NULL_RTX);\n+  tos = gen_rtx (MEM, DFmode, gen_rtx (POST_INC, Pmode, stack_pointer_rtx));\n+  insn = emit_insn (gen_movdf_i4 (operands[0], tos, operands[2]));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, stack_pointer_rtx, NULL_RTX);\n+  DONE;\n+}\")\n+\n+;; local-alloc sometimes allocates scratch registers even when not required,\n+;; so we must be prepared to handle these.\n+\n+;; Remove the use and clobber from a movdf_i4 so that we can use movdf_k.\n+(define_split\n+  [(set (match_operand:DF 0 \"general_movdst_operand\" \"\")\n+\t(match_operand:DF 1 \"general_movsrc_operand\"  \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH4\n+   && reload_completed\n+   && true_regnum (operands[0]) < 16\n+   && true_regnum (operands[1]) < 16\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\n+{\n+  /* If this was a reg <-> mem operation with base + index reg addressing,\n+     we have to handle this in a special way.  */\n+  rtx mem = operands[0];\n+  int store_p = 1;\n+  if (! memory_operand (mem, DFmode))\n+    {\n+      mem = operands[1];\n+      store_p = 0;\n+    }\n+  if (GET_CODE (mem) == SUBREG && SUBREG_WORD (mem) == 0)\n+    mem = SUBREG_REG (mem);\n+  if (GET_CODE (mem) == MEM)\n+    {\n+      rtx addr = XEXP (mem, 0);\n+      if (GET_CODE (addr) == PLUS\n+\t  && GET_CODE (XEXP (addr, 0)) == REG\n+\t  && GET_CODE (XEXP (addr, 1)) == REG)\n+\t{\n+\t  int offset;\n+\t  rtx reg0 = gen_rtx (REG, Pmode, 0);\n+\t  rtx regop = operands[store_p], word0 ,word1;\n+\n+\t  if (GET_CODE (regop) == SUBREG)\n+\t    regop = alter_subreg (regop);\n+\t  if (REGNO (XEXP (addr, 0)) == REGNO (XEXP (addr, 1)))\n+\t    offset = 2;\n+\t  else\n+\t    offset = 4;\n+\t  mem = copy_rtx (mem);\n+\t  PUT_MODE (mem, SImode);\n+\t  word0 = gen_rtx(SUBREG, SImode, regop, 0);\n+\t  emit_insn (store_p\n+\t\t     ? gen_movsi_ie (mem, word0) : gen_movsi_ie (word0, mem));\n+\t  emit_insn (gen_addsi3 (reg0, reg0, GEN_INT (offset)));\n+\t  mem = copy_rtx (mem);\n+\t  word1 = gen_rtx(SUBREG, SImode, regop, 1);\n+\t  emit_insn (store_p\n+\t\t     ? gen_movsi_ie (mem, word1) : gen_movsi_ie (word1, mem));\n+\t  emit_insn (gen_addsi3 (reg0, reg0, GEN_INT (-offset)));\n+\t  DONE;\n+\t}\n+    }\n+}\")\n+\n+;; Split away the clobber of r0 after machine_dependent_reorg has fixed pcloads.\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"memory_operand\"  \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (reg:SI 0))]\n+  \"TARGET_SH4 && reload_completed\"\n+  [(parallel [(set (match_dup 0) (match_dup 1))\n+\t      (use (match_dup 2))\n+\t      (clobber (scratch:SI))])]\n+  \"\")\n+\n+(define_expand \"reload_indf\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t\t   (match_operand:DF 1 \"immediate_operand\" \"FQ\"))\n+\t      (use (reg:PSI 48))\n+\t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outdf\"\n+  [(parallel [(set (match_operand:DF 0 \"register_operand\" \"=r,f\")\n+\t\t   (match_operand:DF 1 \"register_operand\" \"af,r\"))\n+\t      (clobber (match_operand:SI 2 \"register_operand\" \"=&y,y\"))])]\n+  \"\"\n+  \"\")\n+\n+;; Simplify no-op moves.\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(match_operand:SF 1 \"register_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH3E && reload_completed\n+   && true_regnum (operands[0]) == true_regnum (operands[1])\"\n+  [(set (match_dup 0) (match_dup 0))]\n+  \"\")\n+\n+;; fmovd substitute post-reload splits\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH4 && ! TARGET_FMOVD && reload_completed\n+   && true_regnum (operands[0]) >= FIRST_FP_REG\n+   && true_regnum (operands[1]) >= FIRST_FP_REG\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int dst = true_regnum (operands[0]), src = true_regnum (operands[1]);\n+  emit_insn (gen_movsf_ie (gen_rtx (REG, SFmode, dst),\n+\t\t\t   gen_rtx (REG, SFmode, src), operands[2]));\n+  emit_insn (gen_movsf_ie (gen_rtx (REG, SFmode, dst + 1),\n+\t\t\t   gen_rtx (REG, SFmode, src + 1), operands[2]));\n+  DONE;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(mem:DF (match_operand:SI 1 \"register_operand\" \"\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH4 && ! TARGET_FMOVD && reload_completed\n+   && true_regnum (operands[0]) >= FIRST_FP_REG\n+   && find_regno_note (insn, REG_DEAD, true_regnum (operands[1]))\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int regno = true_regnum (operands[0]);\n+  rtx insn;\n+  rtx mem2 = gen_rtx (MEM, SFmode, gen_rtx (POST_INC, Pmode, operands[1]));\n+\n+  insn = emit_insn (gen_movsf_ie (gen_rtx (REG, SFmode,\n+\t\t\t\t\t   regno + !! TARGET_LITTLE_ENDIAN),\n+\t\t\t\t  mem2, operands[2]));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, operands[1], NULL_RTX);\n+  insn = emit_insn (gen_movsf_ie (gen_rtx (REG, SFmode,\n+\t\t\t\t\t   regno + ! TARGET_LITTLE_ENDIAN),\n+\t\t\t\t  gen_rtx (MEM, SFmode, operands[1]),\n+\t\t\t\t  operands[2]));\n+  DONE;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(match_operand:DF 1 \"memory_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH4 && ! TARGET_FMOVD && reload_completed\n+   && true_regnum (operands[0]) >= FIRST_FP_REG\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int regno = true_regnum (operands[0]);\n+  rtx addr, insn, adjust = NULL_RTX;\n+  rtx mem2 = copy_rtx (operands[1]);\n+  rtx reg0 = gen_rtx_REG (SFmode, regno + !! TARGET_LITTLE_ENDIAN);\n+  rtx reg1 = gen_rtx_REG (SFmode, regno + ! TARGET_LITTLE_ENDIAN);\n+\n+  PUT_MODE (mem2, SFmode);\n+  operands[1] = copy_rtx (mem2);\n+  addr = XEXP (mem2, 0);\n+  if (GET_CODE (addr) != POST_INC)\n+    {\n+      /* If we have to modify the stack pointer, the value that we have\n+\t read with post-increment might be modified by an interrupt,\n+\t so write it back.  */\n+      if (REGNO (addr) == STACK_POINTER_REGNUM)\n+\tadjust = gen_push_e (reg0);\n+      else\n+\tadjust = gen_addsi3 (addr, addr, GEN_INT (-4));\n+      XEXP (mem2, 0) = addr = gen_rtx_POST_INC (SImode, addr);\n+    }\n+  addr = XEXP (addr, 0);\n+  insn = emit_insn (gen_movsf_ie (reg0, mem2, operands[2]));\n+  REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);\n+  insn = emit_insn (gen_movsf_ie (reg1, operands[1], operands[2]));\n+  if (adjust)\n+    emit_insn (adjust);\n+  else\n+    REG_NOTES (insn) = gen_rtx_EXPR_LIST (REG_INC, addr, NULL_RTX);\n+  DONE;\n+}\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"memory_operand\" \"\")\n+\t(match_operand:DF 1 \"register_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (match_scratch:SI 3 \"X\"))]\n+  \"TARGET_SH4 && ! TARGET_FMOVD && reload_completed\n+   && true_regnum (operands[1]) >= FIRST_FP_REG\"\n+  [(const_int 0)]\n+  \"\n+{\n+  int regno = true_regnum (operands[1]);\n+  rtx insn, addr, adjust = NULL_RTX;\n+\n+  operands[0] = copy_rtx (operands[0]);\n+  PUT_MODE (operands[0], SFmode);\n+  insn = emit_insn (gen_movsf_ie (operands[0],\n+\t\t\t\t  gen_rtx (REG, SFmode,\n+\t\t\t\t\t   regno + ! TARGET_LITTLE_ENDIAN),\n+\t\t\t\t  operands[2]));\n+  operands[0] = copy_rtx (operands[0]);\n+  addr = XEXP (operands[0], 0);\n+  if (GET_CODE (addr) != PRE_DEC)\n+    {\n+      adjust = gen_addsi3 (addr, addr, GEN_INT (4));\n+      emit_insn_before (adjust, insn);\n+      XEXP (operands[0], 0) = addr = gen_rtx (PRE_DEC, SImode, addr);\n+    }\n+  addr = XEXP (addr, 0);\n+  if (! adjust)\n+    REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, addr, NULL_RTX);\n+  insn = emit_insn (gen_movsf_ie (operands[0],\n+\t\t\t\t  gen_rtx (REG, SFmode,\n+\t\t\t\t\t   regno + !! TARGET_LITTLE_ENDIAN),\n+\t\t\t\t  operands[2]));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, addr, NULL_RTX);\n+  DONE;\n+}\")\n+\n+;; The '&' for operand 2 is not really true, but push_secondary_reload\n+;; insists on it.\n+;; Operand 1 must accept FPUL_REGS in case fpul is reloaded to memory,\n+;; to avoid a bogus tertiary reload.\n+;; We need a tertiary reload when a floating point register is reloaded\n+;; to memory, so the predicate for operand 0 must accept this, while the \n+;; constraint of operand 1 must reject the secondary reload register.\n+;; Thus, the secondary reload register for this case has to be GENERAL_REGS,\n+;; too.\n+;; By having the predicate for operand 0 reject any register, we make\n+;; sure that the ordinary moves that just need an intermediate register\n+;; won't get a bogus tertiary reload.\n+;; We use tertiary_reload_operand instead of memory_operand here because\n+;; memory_operand rejects operands that are not directly addressible, e.g.:\n+;; (mem:SF (plus:SI (reg:SI 14 r14)\n+;;         (const_int 132)))\n+\n+(define_expand \"reload_outsf\"\n+  [(parallel [(set (match_operand:SF 2 \"register_operand\" \"=&r\")\n+\t\t   (match_operand:SF 1 \"register_operand\" \"y\"))\n+\t      (clobber (scratch:SI))])\n+   (parallel [(set (match_operand:SF 0 \"tertiary_reload_operand\" \"=m\")\n+\t\t   (match_dup 2))\n+\t      (clobber (scratch:SI))])]\n+  \"\"\n+  \"\")\n+\n ;; If the output is a register and the input is memory or a register, we have\n ;; to be careful and see which word needs to be loaded first.  \n \n@@ -2129,14 +2784,26 @@\n   \"\n {\n   if (prepare_move_operands (operands, DFmode)) DONE;\n+  if (TARGET_SH4)\n+    {\n+      emit_df_insn (gen_movdf_i4 (operands[0], operands[1], get_fpscr_rtx ()));\n+      /* We need something to tag possible REG_LIBCALL notes on to.  */\n+      if (TARGET_FPU_SINGLE && rtx_equal_function_value_matters\n+\t  && GET_CODE (operands[0]) == REG)\n+\temit_insn (gen_mov_nop (operands[0]));\n+      DONE;\n+    }\n }\")\n \n \n (define_insn \"movsf_i\"\n   [(set (match_operand:SF 0 \"general_movdst_operand\" \"=r,r,r,r,m,l,r\")\n-\t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,I,FQ,m,r,r,l\"))]\n+\t(match_operand:SF 1 \"general_movsrc_operand\"  \"r,I,FQ,mr,r,r,l\"))]\n   \"\n-   ! TARGET_SH3E\n+   (! TARGET_SH3E\n+    /* ??? We provide some insn so that direct_{load,store}[SFmode] get set */\n+    || GET_CODE (operands[0]) == REG && REGNO (operands[0]) == 3\n+    || GET_CODE (operands[1]) == REG && REGNO (operands[1]) == 3)\n    && (arith_reg_operand (operands[0], SFmode)\n        || arith_reg_operand (operands[1], SFmode))\"\n   \"@\n@@ -2156,8 +2823,9 @@\n   [(set (match_operand:SF 0 \"general_movdst_operand\"\n \t \"=f,r,f,f,fy,f,m,r,r,m,f,y,y,rf,r,y,y\")\n \t(match_operand:SF 1 \"general_movsrc_operand\"\n-\t  \"f,r,G,H,FQ,m,f,FQ,m,r,y,f,>,fr,y,r,y\"))\n-   (clobber (match_scratch:SI 2 \"=X,X,X,X,&z,X,X,X,X,X,X,X,X,y,X,X,X\"))]\n+\t  \"f,r,G,H,FQ,mf,f,FQ,mr,r,y,f,>,fr,y,r,y\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c,c\"))\n+   (clobber (match_scratch:SI 3 \"=X,X,X,X,&z,X,X,X,X,X,X,X,X,y,X,X,X\"))]\n \n   \"TARGET_SH3E\n    && (arith_reg_operand (operands[0], SFmode)\n@@ -2181,16 +2849,19 @@\n \tlds\t%1,%0\n \t! move optimized away\"\n   [(set_attr \"type\" \"fmove,move,fmove,fmove,pcload,load,store,pcload,load,store,fmove,fmove,load,*,gp_fpul,gp_fpul,nil\")\n-   (set_attr \"length\" \"*,*,*,*,4,*,*,*,*,*,2,2,2,*,2,2,0\")])\n+   (set_attr \"length\" \"*,*,*,*,4,*,*,*,*,*,2,2,2,4,2,2,0\")])\n \n (define_split\n   [(set (match_operand:SF 0 \"register_operand\" \"\")\n \t(match_operand:SF 1 \"register_operand\" \"\"))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n    (clobber (reg:SI 22))]\n   \"\"\n   [(parallel [(set (reg:SF 22) (match_dup 1))\n+\t      (use (match_dup 2))\n \t      (clobber (scratch:SI))])\n    (parallel [(set (match_dup 0) (reg:SF 22))\n+\t      (use (match_dup 2))\n \t      (clobber (scratch:SI))])]\n   \"\")\n \n@@ -2204,17 +2875,63 @@\n     DONE;\n   if (TARGET_SH3E)\n     {\n-      emit_insn (gen_movsf_ie (operands[0], operands[1]));\n+      emit_sf_insn (gen_movsf_ie (operands[0], operands[1], get_fpscr_rtx ()));\n+      /* We need something to tag possible REG_LIBCALL notes on to.  */\n+      if (! TARGET_FPU_SINGLE && rtx_equal_function_value_matters\n+\t  && GET_CODE (operands[0]) == REG)\n+\temit_insn (gen_mov_nop (operands[0]));\n       DONE;\n     }\n }\")\n \n+(define_insn \"mov_nop\"\n+  [(set (match_operand 0 \"register_operand\" \"\") (match_dup 0))]\n+  \"TARGET_SH3E\"\n+  \"\"\n+  [(set_attr \"length\" \"0\")\n+   (set_attr \"type\" \"nil\")])\n+\n (define_expand \"reload_insf\"\n   [(parallel [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t\t   (match_operand:SF 1 \"immediate_operand\" \"FQ\"))\n+\t      (use (reg:PSI 48))\n \t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]\n   \"\"\n   \"\")\n+\n+(define_expand \"reload_insi\"\n+  [(parallel [(set (match_operand:SF 0 \"register_operand\" \"=y\")\n+\t\t   (match_operand:SF 1 \"immediate_operand\" \"FQ\"))\n+\t      (clobber (match_operand:SI 2 \"register_operand\" \"=&z\"))])]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"*movsi_y\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=y,y\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"Qi,I\"))\n+   (clobber (match_scratch:SI 3 \"=&z,r\"))]\n+  \"TARGET_SH3E\n+   && (reload_in_progress || reload_completed)\"\n+  \"#\"\n+  [(set_attr \"length\" \"4\")\n+   (set_attr \"type\" \"pcload,move\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"y\")\n+\t(match_operand:SI 1 \"immediate_operand\" \"I\"))\n+   (clobber (match_operand:SI 2 \"register_operand\" \"r\"))]\n+  \"\"\n+  [(set (match_dup 2) (match_dup 1))\n+   (set (match_dup 0) (match_dup 2))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"register_operand\" \"y\")\n+\t(match_operand:SI 1 \"memory_operand\" \">\"))\n+   (clobber (reg:SI 0))]\n+  \"\"\n+  [(set (match_dup 0) (match_dup 1))]\n+  \"\")\n \f\n ;; ------------------------------------------------------------------------\n ;; Define the real conditional branch instructions.\n@@ -2289,7 +3006,7 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sh_compare_op0) == SFmode)\n+  if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n     {\n       rtx tmp = sh_compare_op0;\n       sh_compare_op0 = sh_compare_op1;\n@@ -2396,6 +3113,7 @@\n (define_insn \"calli\"\n   [(call (mem:SI (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t (match_operand 1 \"\" \"\"))\n+   (use (reg:SI 48))\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%0%#\"\n@@ -2406,6 +3124,7 @@\n   [(set (match_operand 0 \"\" \"=rf\")\n \t(call (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t      (match_operand 2 \"\" \"\")))\n+   (use (reg:SI 48))\n    (clobber (reg:SI 17))]\n   \"\"\n   \"jsr\t@%1%#\"\n@@ -2415,6 +3134,7 @@\n (define_expand \"call\"\n   [(parallel [(call (mem:SI (match_operand 0 \"arith_reg_operand\" \"\"))\n \t\t\t    (match_operand 1 \"\" \"\"))\n+\t      (use (reg:SI 48))\n \t      (clobber (reg:SI 17))])]\n   \"\"\n   \"operands[0] = force_reg (SImode, XEXP (operands[0], 0));\")\n@@ -2423,6 +3143,7 @@\n   [(parallel [(set (match_operand 0 \"arith_reg_operand\" \"\")\n \t\t   (call (mem:SI (match_operand 1 \"arith_reg_operand\" \"\"))\n \t\t\t\t (match_operand 2 \"\" \"\")))\n+\t      (use (reg:SI 48))\n \t      (clobber (reg:SI 17))])]\n   \"\"\n   \"operands[1] = force_reg (SImode, XEXP (operands[1], 0));\")\n@@ -2656,9 +3377,16 @@\n }\"\n   [(set_attr \"length\" \"4\")])\n \n+;; ??? This is not the proper place to invoke another compiler pass;\n+;; Alas, there is no proper place to put it.\n+;; ??? This is also an odd place for the call to emit_fpscr_use.  It\n+;; would be all right if it were for an define_expand for return, but\n+;; that doesn't mix with emitting a prologue.\n (define_insn \"return\"\n   [(return)]\n-  \"reload_completed\"\n+  \"emit_fpscr_use (),\n+   remove_dead_before_cse (),\n+   reload_completed\"\n   \"%@\t%#\"\n   [(set_attr \"type\" \"return\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n@@ -2726,19 +3454,15 @@\n   \"\"\n   \"\n {\n-  if (GET_MODE (sh_compare_op0) == SFmode)\n+  if (GET_MODE_CLASS (GET_MODE (sh_compare_op0)) == MODE_FLOAT)\n     {\n       if (TARGET_IEEE)\n \t{\n \t  rtx t_reg = gen_rtx (REG, SImode, T_REG);\n \t  rtx lab = gen_label_rtx ();\n-\t  emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n-\t\t\t      gen_rtx (EQ, SImode, sh_compare_op0,\n-\t\t\t\t       sh_compare_op1)));\n+\t  prepare_scc_operands (EQ);\n \t  emit_jump_insn (gen_branch_true (lab));\n-\t  emit_insn (gen_rtx (SET, VOIDmode, t_reg,\n-\t\t\t      gen_rtx (GT, SImode, sh_compare_op0,\n-\t\t\t\t       sh_compare_op1)));\n+\t  prepare_scc_operands (GT);\n \t  emit_label (lab);\n \t  emit_insn (gen_movt (operands[0]));\n \t}\n@@ -2963,7 +3687,7 @@\n \t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n \t      (clobber (reg:SI 17))\n \t      (clobber (reg:SI 0))])]\n-  \"\"\n+  \"! TARGET_HARD_SH4\"\n   \"jsr\t@%0%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n@@ -2978,7 +3702,38 @@\n \t      (clobber (reg:SI 5))\n \t      (clobber (reg:SI 6))\n \t      (clobber (reg:SI 0))])]\n-  \"\"\n+  \"! TARGET_HARD_SH4\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"block_move_real_i4\"\n+  [(parallel [(set (mem:BLK (reg:SI 4))\n+\t\t   (mem:BLK (reg:SI 5)))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))])]\n+  \"TARGET_HARD_SH4\"\n+  \"jsr\t@%0%#\"\n+  [(set_attr \"type\" \"sfunc\")\n+   (set_attr \"needs_delay_slot\" \"yes\")])\n+\n+(define_insn \"block_lump_real_i4\"\n+  [(parallel [(set (mem:BLK (reg:SI 4))\n+\t\t   (mem:BLK (reg:SI 5)))\n+\t      (use (match_operand:SI 0 \"arith_reg_operand\" \"r\"))\n+\t      (use (reg:SI 6))\n+\t      (clobber (reg:SI 17))\n+\t      (clobber (reg:SI 4))\n+\t      (clobber (reg:SI 5))\n+\t      (clobber (reg:SI 6))\n+\t      (clobber (reg:SI 0))\n+\t      (clobber (reg:SI 1))\n+\t      (clobber (reg:SI 2))\n+\t      (clobber (reg:SI 3))])]\n+  \"TARGET_HARD_SH4\"\n   \"jsr\t@%0%#\"\n   [(set_attr \"type\" \"sfunc\")\n    (set_attr \"needs_delay_slot\" \"yes\")])\n@@ -2989,59 +3744,223 @@\n \n ;; ??? All patterns should have a type attribute.\n \n-(define_insn \"addsf3\"\n+(define_expand \"fpu_switch0\"\n+  [(set (match_operand:SI 0 \"\" \"\") (symbol_ref \"__fpscr_values\"))\n+   (set (match_dup 2) (match_dup 1))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_rtx (MEM, PSImode, operands[0]);\n+  RTX_UNCHANGING_P (operands[1]) = 1;\n+  operands[2] = get_fpscr_rtx ();\n+}\")\n+\n+(define_expand \"fpu_switch1\"\n+  [(set (match_operand:SI 0 \"\" \"\") (symbol_ref \"__fpscr_values\"))\n+   (set (match_dup 1) (plus:SI (match_dup 0) (const_int 4)))\n+   (set (match_dup 3) (match_dup 2))]\n+  \"\"\n+  \"\n+{\n+  operands[1] = gen_reg_rtx (SImode);\n+  operands[2] = gen_rtx (MEM, PSImode, operands[1]);\n+  RTX_UNCHANGING_P (operands[2]) = 1;\n+  operands[3] = get_fpscr_rtx ();\n+}\")\n+\n+(define_expand \"movpsi\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"\")\n+\t(match_operand:PSI 1 \"general_movsrc_operand\" \"\"))]\n+  \"\"\n+  \"\")\n+\n+;; The c / m alternative is a fake to guide reload to load directly into\n+;; fpscr, since reload doesn't know how to use post-increment.\n+;; GO_IF_LEGITIMATE_ADDRESS guards about bogus addresses before reload,\n+;; SECONDARY_INPUT_RELOAD_CLASS does this during reload, and the insn's\n+;; predicate after reload.\n+;; The gp_fpul type for r/!c might look a bit odd, but it actually schedules\n+;; like a gpr <-> fpul move.\n+(define_insn \"fpu_switch\"\n+  [(set (match_operand:PSI 0 \"register_operand\" \"c,c,r,c,c,r,m,r\")\n+\t(match_operand:PSI 1 \"general_movsrc_operand\" \"c,>,m,m,r,r,r,!c\"))]\n+  \"! reload_completed\n+   || true_regnum (operands[0]) != FPSCR_REG || GET_CODE (operands[1]) != MEM\n+   || GET_CODE (XEXP (operands[1], 0)) != PLUS\"\n+  \"@\n+\t! precision stays the same\n+\tlds.l\t%1,fpscr\n+\tmov.l\t%1,%0\n+\t#\n+\tlds\t%1,fpscr\n+\tmov\t%1,%0\n+\tmov.l\t%1,%0\n+\tsts\tfpscr,%0\"\n+  [(set_attr \"length\" \"0,2,2,4,2,2,2,2\")\n+   (set_attr \"type\" \"dfp_conv,dfp_conv,load,dfp_conv,dfp_conv,move,store,gp_fpul\")])\n+\n+(define_split\n+  [(set (reg:PSI 48) (mem:PSI (match_operand:SI 0 \"register_operand\" \"r\")))]\n+  \"find_regno_note (insn, REG_DEAD, true_regnum (operands[0]))\"\n+  [(set (match_dup 0) (match_dup 0))]\n+  \"\n+{\n+  rtx insn = emit_insn (gen_fpu_switch (get_fpscr_rtx (),\n+\t\t\t\t\tgen_rtx (MEM, PSImode,\n+\t\t\t\t\t\t gen_rtx (POST_INC, Pmode,\n+\t\t\t\t\t\t\t  operands[0]))));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, operands[0], NULL_RTX);\n+}\")\n+\n+(define_split\n+  [(set (reg:PSI 48) (mem:PSI (match_operand:SI 0 \"register_operand\" \"r\")))]\n+  \"\"\n+  [(set (match_dup 0) (plus:SI (match_dup 0) (const_int -4)))]\n+  \"\n+{\n+  rtx insn = emit_insn (gen_fpu_switch (get_fpscr_rtx (),\n+\t\t\t\t\tgen_rtx (MEM, PSImode,\n+\t\t\t\t\t\t gen_rtx (POST_INC, Pmode,\n+\t\t\t\t\t\t\t  operands[0]))));\n+  REG_NOTES (insn) = gen_rtx (EXPR_LIST, REG_INC, operands[0], NULL_RTX);\n+}\")\n+\n+;; ??? This uses the fp unit, but has no type indicating that.\n+;; If we did that, this would either give a bogus latency or introduce\n+;; a bogus FIFO constraint.\n+;; Since this insn is currently only used for prologues/epilogues,\n+;; it is probably best to claim no function unit, which matches the\n+;; current setting.\n+(define_insn \"toggle_sz\"\n+  [(set (reg:PSI 48) (xor:PSI (reg:PSI 48) (const_int 1048576)))]\n+  \"TARGET_SH4\"\n+  \"fschg\")\n+\n+(define_expand \"addsf3\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_binop (&gen_addsf3_i, operands); DONE; }\")\n+\n+(define_insn \"addsf3_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(plus:SF (match_operand:SF 1 \"arith_reg_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))]\n+\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fadd\t%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"subsf3\"\n+(define_expand \"subsf3\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_binop (&gen_subsf3_i, operands); DONE; }\")\n+\n+(define_insn \"subsf3_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(minus:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")\n-\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))]\n+\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fsub\t%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"mulsf3\"\n+;; Unfortunately, the combiner is unable to cope with the USE of the FPSCR\n+;; register in feeding fp instructions.  Thus, we cannot generate fmac for\n+;; mixed-precision SH4 targets.  To allow it to be still generated for the\n+;; SH3E, we use a separate insn for SH3E mulsf3.\n+\n+(define_expand \"mulsf3\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"\n+{\n+  if (TARGET_SH4)\n+    expand_sf_binop (&gen_mulsf3_i4, operands);\n+  else\n+    emit_insn (gen_mulsf3_ie (operands[0], operands[1], operands[2]));\n+  DONE;\n+}\")\n+\n+(define_insn \"mulsf3_i4\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(mult:SF (match_operand:SF 1 \"arith_reg_operand\" \"%0\")\n-\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))]\n+\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fmul\t%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n+(define_insn \"mulsf3_ie\"\n+  [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n+\t(mult:SF (match_operand:SF 1 \"arith_reg_operand\" \"%0\")\n+\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))]\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n+  \"fmul\t%2,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n (define_insn \"*macsf3\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(plus:SF (mult:SF (match_operand:SF 1 \"arith_reg_operand\" \"%w\")\n \t\t\t  (match_operand:SF 2 \"arith_reg_operand\" \"f\"))\n-\t\t (match_operand:SF 3 \"arith_reg_operand\" \"0\")))]\n-  \"TARGET_SH3E\"\n+\t\t (match_operand:SF 3 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 4 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n   \"fmac\tfr0,%2,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n-(define_insn \"divsf3\"\n+(define_expand \"divsf3\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_binop (&gen_divsf3_i, operands); DONE; }\")\n+\n+(define_insn \"divsf3_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(div:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")\n-\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))]\n+\t\t (match_operand:SF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fdiv\t%2,%0\"\n   [(set_attr \"type\" \"fdiv\")])\n \n (define_expand \"floatsisf2\"\n   [(set (reg:SI 22)\n \t(match_operand:SI 1 \"arith_reg_operand\" \"\"))\n-   (set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n-        (float:SF (reg:SI 22)))]\n+   (parallel [(set (match_operand:SF 0 \"arith_reg_operand\" \"\")\n+\t\t   (float:SF (reg:SI 22)))\n+\t      (use (match_dup 2))])]\n   \"TARGET_SH3E\"\n-  \"\")\n+  \"\n+{\n+  if (TARGET_SH4)\n+    {\n+      emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 22),\n+\t\t\t  operands[1]));\n+      emit_sf_insn (gen_floatsisf2_i4 (operands[0], get_fpscr_rtx ()));\n+      DONE;\n+    }\n+  operands[2] = get_fpscr_rtx ();\n+}\")\n+\n+(define_insn \"floatsisf2_i4\"\n+  [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n+\t(float:SF (reg:SI 22)))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH3E\"\n+  \"float\tfpul,%0\"\n+  [(set_attr \"type\" \"fp\")])\n \n (define_insn \"*floatsisf2_ie\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n \t(float:SF (reg:SI 22)))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n   \"float\tfpul,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n@@ -3051,38 +3970,99 @@\n    (set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n \t(reg:SI 22))]\n   \"TARGET_SH3E\"\n-  \"\")\n+  \"\n+{\n+  if (TARGET_SH4)\n+    {\n+      emit_sf_insn (gen_fix_truncsfsi2_i4 (operands[1], get_fpscr_rtx ()));\n+      emit_insn (gen_rtx (SET, VOIDmode, operands[0],\n+\t\t\t  gen_rtx (REG, SImode, 22)));\n+      DONE;\n+    }\n+}\")\n+\n+(define_insn \"fix_truncsfsi2_i4\"\n+  [(set (reg:SI 22)\n+\t(fix:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"ftrc\t%0,fpul\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"fix_truncsfsi2_i4_2\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:SF 1 \"arith_reg_operand\" \"f\")))\n+   (use (reg:SI 48))\n+   (clobber (reg:SI 22))]\n+  \"TARGET_SH4\"\n+  \"#\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:SF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (reg:SI 22))]\n+  \"TARGET_SH4\"\n+  [(parallel [(set (reg:SI 22) (fix:SI (match_dup 1)))\n+\t      (use (match_dup 2))])\n+   (set (match_dup 0) (reg:SI 22))])\n \n (define_insn \"*fixsfsi\"\n   [(set (reg:SI 22)\n \t(fix:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n   \"ftrc\t%0,fpul\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"cmpgtsf_t\"\n   [(set (reg:SI 18) (gt:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n \t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n   \"fcmp/gt\t%1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"cmpeqsf_t\"\n   [(set (reg:SI 18) (eq:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n \t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\")))]\n-  \"TARGET_SH3E\"\n+  \"TARGET_SH3E && ! TARGET_SH4\"\n   \"fcmp/eq\t%1,%0\"\n   [(set_attr \"type\" \"fp\")])\n \n (define_insn \"ieee_ccmpeqsf_t\"\n   [(set (reg:SI 18) (ior:SI (reg:SI 18)\n \t\t\t    (eq:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n \t\t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\"))))]\n-  \"TARGET_SH3E && TARGET_IEEE\"\n+  \"TARGET_SH3E && TARGET_IEEE && ! TARGET_SH4\"\n   \"* return output_ieee_ccmpeq (insn, operands);\"\n   [(set_attr \"length\" \"4\")])\n \n \n+(define_insn \"cmpgtsf_t_i4\"\n+  [(set (reg:SI 18) (gt:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcmp/gt\t%1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"cmpeqsf_t_i4\"\n+  [(set (reg:SI 18) (eq:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcmp/eq\t%1,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_insn \"*ieee_ccmpeqsf_t_4\"\n+  [(set (reg:SI 18) (ior:SI (reg:SI 18)\n+\t\t\t    (eq:SI (match_operand:SF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t\t   (match_operand:SF 1 \"arith_reg_operand\" \"f\"))))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_IEEE && TARGET_SH4\"\n+  \"* return output_ieee_ccmpeq (insn, operands);\"\n+  [(set_attr \"length\" \"4\")])\n+\n (define_expand \"cmpsf\"\n   [(set (reg:SI 18) (compare (match_operand:SF 0 \"arith_operand\" \"\")\n \t\t\t     (match_operand:SF 1 \"arith_operand\" \"\")))]\n@@ -3094,25 +4074,285 @@\n   DONE;\n }\")\n \n-(define_insn \"negsf2\"\n+(define_expand \"negsf2\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_unop (&gen_negsf2_i, operands); DONE; }\")\n+\n+(define_insn \"negsf2_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n-\t(neg:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))]\n+\t(neg:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fneg\t%0\"\n-  [(set_attr \"type\" \"fp\")])\n+  [(set_attr \"type\" \"fmove\")])\n \n-(define_insn \"sqrtsf2\"\n+(define_expand \"sqrtsf2\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_unop (&gen_sqrtsf2_i, operands); DONE; }\")\n+\n+(define_insn \"sqrtsf2_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n-\t(sqrt:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))]\n+\t(sqrt:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fsqrt\t%0\"\n   [(set_attr \"type\" \"fdiv\")])\n \n-(define_insn \"abssf2\"\n+(define_expand \"abssf2\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH3E\"\n+  \"{ expand_sf_unop (&gen_abssf2_i, operands); DONE; }\")\n+\n+(define_insn \"abssf2_i\"\n   [(set (match_operand:SF 0 \"arith_reg_operand\" \"=f\")\n-\t(abs:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))]\n+\t(abs:SF (match_operand:SF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n   \"TARGET_SH3E\"\n   \"fabs\t%0\"\n+  [(set_attr \"type\" \"fmove\")])\n+\n+(define_expand \"adddf3\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_binop (&gen_adddf3_i, operands); DONE; }\")\n+\n+(define_insn \"adddf3_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(plus:DF (match_operand:DF 1 \"arith_reg_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fadd\t%2,%0\"\n+  [(set_attr \"type\" \"dfp_arith\")])\n+\n+(define_expand \"subdf3\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_binop (&gen_subdf3_i, operands); DONE; }\")\n+\n+(define_insn \"subdf3_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(minus:DF (match_operand:DF 1 \"arith_reg_operand\" \"0\")\n+\t\t  (match_operand:DF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fsub\t%2,%0\"\n+  [(set_attr \"type\" \"dfp_arith\")])\n+\n+(define_expand \"muldf3\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_binop (&gen_muldf3_i, operands); DONE; }\")\n+\n+(define_insn \"muldf3_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(mult:DF (match_operand:DF 1 \"arith_reg_operand\" \"%0\")\n+\t\t (match_operand:DF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fmul\t%2,%0\"\n+  [(set_attr \"type\" \"dfp_arith\")])\n+\n+(define_expand \"divdf3\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 2 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_binop (&gen_divdf3_i, operands); DONE; }\")\n+\n+(define_insn \"divdf3_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(div:DF (match_operand:DF 1 \"arith_reg_operand\" \"0\")\n+\t\t(match_operand:DF 2 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 3 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fdiv\t%2,%0\"\n+  [(set_attr \"type\" \"dfdiv\")])\n+\n+(define_expand \"floatsidf2\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SI 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"\n+{\n+  emit_insn (gen_rtx (SET, VOIDmode, gen_rtx (REG, SImode, 22), operands[1]));\n+  emit_df_insn (gen_floatsidf2_i (operands[0], get_fpscr_rtx ()));\n+  DONE;\n+}\")\n+\n+(define_insn \"floatsidf2_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(float:DF (reg:SI 22)))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"float\tfpul,%0\"\n+  [(set_attr \"type\" \"dfp_conv\")])\n+\n+(define_expand \"fix_truncdfsi2\"\n+  [(match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"f\")]\n+  \"TARGET_SH4\"\n+  \"\n+{\n+  emit_df_insn (gen_fix_truncdfsi2_i (operands[1], get_fpscr_rtx ()));\n+  emit_insn (gen_rtx (SET, VOIDmode, operands[0], gen_rtx (REG, SImode, 22)));\n+  DONE;\n+}\")\n+\n+(define_insn \"fix_truncdfsi2_i\"\n+  [(set (reg:SI 22)\n+\t(fix:SI (match_operand:DF 0 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"ftrc\t%0,fpul\"\n+  [(set_attr \"type\" \"dfp_conv\")])\n+\n+(define_insn \"fix_truncdfsi2_i4\"\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (reg:SI 22))]\n+  \"TARGET_SH4\"\n+  \"#\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_split\n+  [(set (match_operand:SI 0 \"arith_reg_operand\" \"=r\")\n+\t(fix:SI (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))\n+   (clobber (reg:SI 22))]\n+  \"TARGET_SH4\"\n+  [(parallel [(set (reg:SI 22) (fix:SI (match_dup 1)))\n+\t      (use (match_dup 2))])\n+   (set (match_dup 0) (reg:SI 22))])\n+\n+(define_insn \"cmpgtdf_t\"\n+  [(set (reg:SI 18) (gt:SI (match_operand:DF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t   (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcmp/gt\t%1,%0\"\n+  [(set_attr \"type\" \"dfp_cmp\")])\n+\n+(define_insn \"cmpeqdf_t\"\n+  [(set (reg:SI 18) (eq:SI (match_operand:DF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t   (match_operand:DF 1 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcmp/eq\t%1,%0\"\n+  [(set_attr \"type\" \"dfp_cmp\")])\n+\n+(define_insn \"*ieee_ccmpeqdf_t\"\n+  [(set (reg:SI 18) (ior:SI (reg:SI 18)\n+\t\t\t    (eq:SI (match_operand:DF 0 \"arith_reg_operand\" \"f\")\n+\t\t\t\t   (match_operand:DF 1 \"arith_reg_operand\" \"f\"))))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_IEEE && TARGET_SH4\"\n+  \"* return output_ieee_ccmpeq (insn, operands);\"\n+  [(set_attr \"length\" \"4\")])\n+\n+(define_expand \"cmpdf\"\n+  [(set (reg:SI 18) (compare (match_operand:DF 0 \"arith_operand\" \"\")\n+\t\t\t     (match_operand:DF 1 \"arith_operand\" \"\")))]\n+  \"TARGET_SH4\"\n+  \"\n+{\n+  sh_compare_op0 = operands[0];\n+  sh_compare_op1 = operands[1];\n+  DONE;\n+}\")\n+\n+(define_expand \"negdf2\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_unop (&gen_negdf2_i, operands); DONE; }\")\n+\n+(define_insn \"negdf2_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(neg:DF (match_operand:DF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fneg\t%0\"\n+  [(set_attr \"type\" \"fmove\")])\n+\n+(define_expand \"sqrtdf2\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_unop (&gen_sqrtdf2_i, operands); DONE; }\")\n+\n+(define_insn \"sqrtdf2_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(sqrt:DF (match_operand:DF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fsqrt\t%0\"\n+  [(set_attr \"type\" \"dfdiv\")])\n+\n+(define_expand \"absdf2\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"{ expand_df_unop (&gen_absdf2_i, operands); DONE; }\")\n+\n+(define_insn \"absdf2_i\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(abs:DF (match_operand:DF 1 \"arith_reg_operand\" \"0\")))\n+   (use (match_operand:PSI 2 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fabs\t%0\"\n+  [(set_attr \"type\" \"fmove\")])\n+\n+(define_expand \"extendsfdf2\"\n+  [(match_operand:DF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:SF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"\n+{\n+  emit_sf_insn (gen_movsf_ie (gen_rtx (REG, SFmode, 22), operands[1],\n+\t\t\t      get_fpscr_rtx ()));\n+  emit_df_insn (gen_extendsfdf2_i4 (operands[0], get_fpscr_rtx ()));\n+  DONE;\n+}\")\n+\n+(define_insn \"extendsfdf2_i4\"\n+  [(set (match_operand:DF 0 \"arith_reg_operand\" \"=f\")\n+\t(float_extend:DF (reg:SF 22)))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcnvsd  fpul,%0\"\n+  [(set_attr \"type\" \"fp\")])\n+\n+(define_expand \"truncdfsf2\"\n+  [(match_operand:SF 0 \"arith_reg_operand\" \"\")\n+   (match_operand:DF 1 \"arith_reg_operand\" \"\")]\n+  \"TARGET_SH4\"\n+  \"\n+{\n+  emit_df_insn (gen_truncdfsf2_i4 (operands[1], get_fpscr_rtx ()));\n+  emit_sf_insn (gen_movsf_ie (operands[0], gen_rtx (REG, SFmode, 22),\n+\t\t\t   get_fpscr_rtx ()));\n+  DONE;\n+}\")\n+\n+(define_insn \"truncdfsf2_i4\"\n+  [(set (reg:SF 22)\n+\t(float_truncate:SF (match_operand:DF 0 \"arith_reg_operand\" \"f\")))\n+   (use (match_operand:PSI 1 \"fpscr_operand\" \"c\"))]\n+  \"TARGET_SH4\"\n+  \"fcnvds  %0,fpul\"\n   [(set_attr \"type\" \"fp\")])\n \f\n ;; Bit field extract patterns.  These give better code for packed bitfields,"}, {"sha": "bfbf45ea6a0e155a62d311e4fb4bc1c45fa8a78b", "filename": "gcc/config/sh/t-sh", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Ft-sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fconfig%2Fsh%2Ft-sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Ft-sh?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -1,7 +1,7 @@\n CROSS_LIBGCC1 = libgcc1-asm.a\n LIB1ASMSRC = sh/lib1funcs.asm\n LIB1ASMFUNCS = _ashiftrt _ashiftrt_n _ashiftlt _lshiftrt _movstr \\\n-  _mulsi3 _sdivsi3 _udivsi3 _set_fpscr\n+  _movstr_i4 _mulsi3 _sdivsi3 _sdivsi3_i4 _udivsi3 _udivsi3_i4 _set_fpscr\n \n # These are really part of libgcc1, but this will cause them to be\n # built correctly, so...\n@@ -21,7 +21,7 @@ fp-bit.c: $(srcdir)/config/fp-bit.c\n \techo '#endif' \t\t>> fp-bit.c\n \tcat $(srcdir)/config/fp-bit.c >> fp-bit.c\n \n-MULTILIB_OPTIONS= ml m2/m3e\n+MULTILIB_OPTIONS= ml m2/m3e/m4-single-only/m4-single/m4\n MULTILIB_DIRNAMES= \n MULTILIB_MATCHES = m2=m3\n "}, {"sha": "0bfc84c13506f613e308d0297fe989ae542467b0", "filename": "gcc/ginclude/va-sh.h", "status": "modified", "additions": 63, "deletions": 36, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fginclude%2Fva-sh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/225e4f43cc46d861d30a3612e41dc935d95f36ba/gcc%2Fginclude%2Fva-sh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fva-sh.h?ref=225e4f43cc46d861d30a3612e41dc935d95f36ba", "patch": "@@ -6,10 +6,10 @@\n #ifndef __GNUC_VA_LIST\n #define __GNUC_VA_LIST\n \n-#ifdef __SH3E__\n+#if defined (__SH3E__) || defined (__SH4_SINGLE__) || defined (__SH4__) || defined (__SH4_SINGLE_ONLY__)\n \n typedef long __va_greg;\n-typedef double __va_freg;\n+typedef float __va_freg;\n \n typedef struct {\n   __va_greg * __va_next_o;\t\t/* next available register */\n@@ -33,24 +33,24 @@ typedef void *__gnuc_va_list;\n \n #ifdef _STDARG_H\n \n-#ifdef __SH3E__\n+#if defined (__SH3E__) || defined (__SH4_SINGLE__) || defined (__SH4__) || defined (__SH4_SINGLE_ONLY__)\n \n #define va_start(AP, LASTARG) \\\n __extension__ \\\n   ({ \\\n-     AP.__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n-     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+     (AP).__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n+     (AP).__va_next_fp_limit = ((AP).__va_next_fp + \\\n \t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n-     AP.__va_next_o = (__va_greg *) AP.__va_next_fp_limit; \\\n-     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+     (AP).__va_next_o = (__va_greg *) (AP).__va_next_fp_limit; \\\n+     (AP).__va_next_o_limit = ((AP).__va_next_o + \\\n \t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n-     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (LASTARG); \\\n+     (AP).__va_next_stack = (__va_greg *) __builtin_next_arg (LASTARG); \\\n   })\n \n #else /* ! SH3E */\n \n #define va_start(AP, LASTARG) \t\t\t\t\t\t\\\n- (AP = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n+ ((AP) = ((__gnuc_va_list) __builtin_next_arg (LASTARG)))\n \n #endif /* ! SH3E */\n \n@@ -59,24 +59,26 @@ __extension__ \\\n #define va_alist  __builtin_va_alist\n #define va_dcl    int __builtin_va_alist;...\n \n-#ifdef __SH3E__\n+#if defined (__SH3E__) || defined (__SH4_SINGLE__) || defined (__SH4__) || defined (__SH4_SINGLE_ONLY__)\n \n #define va_start(AP) \\\n __extension__ \\\n   ({ \\\n-     AP.__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n-     AP.__va_next_fp_limit = (AP.__va_next_fp + \\\n+     (AP).__va_next_fp = (__va_freg *) __builtin_saveregs (); \\\n+     (AP).__va_next_fp_limit = ((AP).__va_next_fp + \\\n \t\t\t      (__builtin_args_info (1) < 8 ? 8 - __builtin_args_info (1) : 0)); \\\n-     AP.__va_next_o = (__va_greg *) AP.__va_next_fp_limit; \\\n-     AP.__va_next_o_limit = (AP.__va_next_o + \\\n+     (AP).__va_next_o = (__va_greg *) (AP).__va_next_fp_limit; \\\n+     (AP).__va_next_o_limit = ((AP).__va_next_o + \\\n \t\t\t     (__builtin_args_info (0) < 4 ? 4 - __builtin_args_info (0) : 0)); \\\n-     AP.__va_next_stack = (__va_greg *) __builtin_next_arg (__builtin_va_alist) \\\n-       - (__builtin_args_info (0) >= 4 || __builtin_args_info (1) >= 8 ? 1 : 0); \\\n+     (AP).__va_next_stack \\\n+       = ((__va_greg *) __builtin_next_arg (__builtin_va_alist) \\\n+\t  - (__builtin_args_info (0) >= 4 || __builtin_args_info (1) >= 8 \\\n+\t     ? 1 : 0)); \\\n   })\n \n #else /* ! SH3E */\n \n-#define va_start(AP)  AP=(char *) &__builtin_va_alist\n+#define va_start(AP)  ((AP) = (char *) &__builtin_va_alist)\n \n #endif /* ! SH3E */\n \n@@ -136,53 +138,78 @@ enum __va_type_classes {\n      We want the MEM_IN_STRUCT_P bit set in the emitted RTL, therefore we\n      use unions even when it would otherwise be unnecessary.  */\n \n+/* gcc has an extension that allows to use a casted lvalue as an lvalue,\n+   But it doesn't work in C++ with -pedantic - even in the presence of\n+   __extension__ .  We work around this problem by using a reference type.  */\n+#ifdef __cplusplus\n+#define __VA_REF &\n+#else\n+#define __VA_REF\n+#endif\n+\n #define __va_arg_sh1(AP, TYPE) __extension__ \t\t\t\t\\\n-__extension__\t\t\t\t\t\t\t\t\\\n ({(sizeof (TYPE) == 1\t\t\t\t\t\t\t\\\n    ? ({union {TYPE t; char c;} __t;\t\t\t\t\t\\\n-       asm(\"\"\t\t\t\t\t\t\t\t\\\n-\t   : \"=r\" (__t.c)\t\t\t\t\t\t\\\n-\t   : \"0\" ((((union { int i, j; } *) (AP))++)->i));\t\t\\\n+       __asm(\"\"\t\t\t\t\t\t\t\t\\\n+\t     : \"=r\" (__t.c)\t\t\t\t\t\t\\\n+\t     : \"0\" ((((union { int i, j; } *__VA_REF) (AP))++)->i));\t\\\n        __t.t;})\t\t\t\t\t\t\t\t\\\n    : sizeof (TYPE) == 2\t\t\t\t\t\t\t\\\n    ? ({union {TYPE t; short s;} __t;\t\t\t\t\t\\\n-       asm(\"\"\t\t\t\t\t\t\t\t\\\n-\t   : \"=r\" (__t.s)\t\t\t\t\t\t\\\n-\t   : \"0\" ((((union { int i, j; } *) (AP))++)->i));\t\t\\\n+       __asm(\"\"\t\t\t\t\t\t\t\t\\\n+\t     : \"=r\" (__t.s)\t\t\t\t\t\t\\\n+\t     : \"0\" ((((union { int i, j; } *__VA_REF) (AP))++)->i));\t\\\n        __t.t;})\t\t\t\t\t\t\t\t\\\n    : sizeof (TYPE) >= 4 || __LITTLE_ENDIAN_P\t\t\t\t\\\n-   ? (((union { TYPE t; int i;} *) (AP))++)->t\t\t\t\t\\\n-   : ((union {TYPE t;TYPE u;}*) ((char *)++(int *)(AP) - sizeof (TYPE)))->t);})\n+   ? (((union { TYPE t; int i;} *__VA_REF) (AP))++)->t\t\t\t\\\n+   : ((union {TYPE t;TYPE u;}*) ((char *)++(int *__VA_REF)(AP) - sizeof (TYPE)))->t);})\n \n-#ifdef __SH3E__\n+#if defined (__SH3E__) || defined (__SH4_SINGLE__) || defined (__SH4__) || defined (__SH4_SINGLE_ONLY__)\n \n #define __PASS_AS_FLOAT(TYPE_CLASS,SIZE) \\\n   (TYPE_CLASS == __real_type_class && SIZE == 4)\n \n+#define __TARGET_SH4_P 0\n+\n+#if defined(__SH4__) || defined(__SH4_SINGLE__)\n+#undef __PASS_AS_FLOAT\n+#define __PASS_AS_FLOAT(TYPE_CLASS,SIZE) \\\n+  (TYPE_CLASS == __real_type_class && SIZE <= 8 \\\n+   || TYPE_CLASS == __complex_type_class && SIZE <= 16)\n+#undef __TARGET_SH4_P\n+#define __TARGET_SH4_P 1\n+#endif\n+\n #define va_arg(pvar,TYPE)\t\t\t\t\t\\\n __extension__\t\t\t\t\t\t\t\\\n ({int __type = __builtin_classify_type (* (TYPE *) 0);\t\t\\\n   void * __result_p;\t\t\t\t\t\t\\\n   if (__PASS_AS_FLOAT (__type, sizeof(TYPE)))\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (pvar.__va_next_fp < pvar.__va_next_fp_limit)\t\t\\\n+      if ((pvar).__va_next_fp < (pvar).__va_next_fp_limit)\t\\\n \t{\t\t\t\t\t\t\t\\\n-\t  __result_p = &pvar.__va_next_fp;\t\t\t\\\n+\t  if (((__type == __real_type_class && sizeof (TYPE) > 4)\\\n+\t       || sizeof (TYPE) > 8)\t\t\t\t\\\n+\t      && (((int) (pvar).__va_next_fp ^ (int) (pvar).__va_next_fp_limit)\\\n+\t\t  & 4))\t\t\t\t\t\t\\\n+\t    (pvar).__va_next_fp++;\t\t\t\t\\\n+\t  __result_p = &(pvar).__va_next_fp;\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n-\t__result_p = &pvar.__va_next_stack;\t\t\t\\\n+\t__result_p = &(pvar).__va_next_stack;\t\t\t\\\n     }\t\t\t\t\t\t\t\t\\\n   else\t\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\t\\\n-      if (pvar.__va_next_o + ((sizeof (TYPE) + 3) / 4)\t\t\\\n-\t  <= pvar.__va_next_o_limit) \t\t\t\t\\\n-\t__result_p = &pvar.__va_next_o;\t\t\t\t\\\n+      if ((pvar).__va_next_o + ((sizeof (TYPE) + 3) / 4)\t\\\n+\t  <= (pvar).__va_next_o_limit) \t\t\t\t\\\n+\t__result_p = &(pvar).__va_next_o;\t\t\t\\\n       else\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\\\n \t  if (sizeof (TYPE) > 4)\t\t\t\t\\\n-\t    pvar.__va_next_o = pvar.__va_next_o_limit;\t\t\\\n+\t   if (! __TARGET_SH4_P)\t\t\t\t\\\n+\t    (pvar).__va_next_o = (pvar).__va_next_o_limit;\t\\\n \t\t\t\t\t\t\t\t\\\n-\t  __result_p = &pvar.__va_next_stack;\t\t\t\\\n+\t  __result_p = &(pvar).__va_next_stack;\t\t\t\\\n \t}\t\t\t\t\t\t\t\\\n     } \t\t\t\t\t\t\t\t\\\n   __va_arg_sh1(*(void **)__result_p, TYPE);})\n@@ -194,6 +221,6 @@ __extension__\t\t\t\t\t\t\t\\\n #endif /* SH3E */\n \n /* Copy __gnuc_va_list into another variable of this type.  */\n-#define __va_copy(dest, src) (dest) = (src)\n+#define __va_copy(dest, src) ((dest) = (src))\n \n #endif /* defined (_STDARG_H) || defined (_VARARGS_H) */"}]}