{"sha": "28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhlYTE2M2M0MWZjNWNhNThjNmU5MzY4ZWNlMTU1ZTQyZWNkOWNjNw==", "commit": {"author": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-08T12:12:50Z"}, "committer": {"name": "Steven Bosscher", "email": "steven@gcc.gnu.org", "date": "2012-12-08T12:12:50Z"}, "message": "re PR rtl-optimization/55158 (segfault in schedule_region at -O3)\n\n\tPR rtl-optimization/55158\n\t* sched-rgn.c (bb_state_array, bb_state): Add some explaining\n\tcomment, and initialize to NULL explicitly.\n\t(realloc_bb_state_array): New function.\n\t(free_bb_state_array): New function.\n\t(schedule_region): Call realloc_bb_state_array after schedule_block.\n\t(sched_rgn_init): Use realloc_bb_state_array to initialize bb_state.\n\t(sched_rgn_finish): Use free_bb_state_array to free it.\n\nFrom-SVN: r194322", "tree": {"sha": "3acf587d99ca8dc03d7815cf30f37b0b182d72de", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3acf587d99ca8dc03d7815cf30f37b0b182d72de"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7/comments", "author": null, "committer": null, "parents": [{"sha": "54625ca1213528d64717d1a95163a2613151beb7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54625ca1213528d64717d1a95163a2613151beb7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54625ca1213528d64717d1a95163a2613151beb7"}], "stats": {"total": 104, "additions": 79, "deletions": 25}, "files": [{"sha": "33f75979b0fae9993888f4af2909ebff2016da86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "patch": "@@ -1,3 +1,14 @@\n+2012-12-08  Steven Bosscher  <steven@gcc.gnu.org>\n+\n+\tPR rtl-optimization/55158\n+\t* sched-rgn.c (bb_state_array, bb_state): Add some explaining\n+\tcomment, and initialize to NULL explicitly.\n+\t(realloc_bb_state_array): New function.\n+\t(free_bb_state_array): New function.\n+\t(schedule_region): Call realloc_bb_state_array after schedule_block.\n+\t(sched_rgn_init): Use realloc_bb_state_array to initialize bb_state.\n+\t(sched_rgn_finish): Use free_bb_state_array to free it.\n+\n 2012-12-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* tree-ssa-loop-im.c (for_each_index) <CONST_DECL>: New case."}, {"sha": "7eed9ae19b7385727d49ea44deeafb0de6223b84", "filename": "gcc/sched-rgn.c", "status": "modified", "additions": 68, "deletions": 25, "changes": 93, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7/gcc%2Fsched-rgn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28ea163c41fc5ca58c6e9368ece155e42ecd9cc7/gcc%2Fsched-rgn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsched-rgn.c?ref=28ea163c41fc5ca58c6e9368ece155e42ecd9cc7", "patch": "@@ -124,8 +124,12 @@ int current_blocks;\n static basic_block *bblst_table;\n static int bblst_size, bblst_last;\n \n-static char *bb_state_array;\n-static state_t *bb_state;\n+/* Arrays that hold the DFA state at the end of a basic block, to re-use\n+   as the initial state at the start of successor blocks.  The BB_STATE\n+   array holds the actual DFA state, and BB_STATE_ARRAY[I] is a pointer\n+   into BB_STATE for basic block I.  FIXME: This should be a vec.  */\n+static char *bb_state_array = NULL;\n+static state_t *bb_state = NULL;\n \n /* Target info declarations.\n \n@@ -2903,6 +2907,61 @@ compute_priorities (void)\n   current_sched_info->sched_max_insns_priority++;\n }\n \n+/* (Re-)initialize the arrays of DFA states at the end of each basic block.\n+\n+   SAVED_LAST_BASIC_BLOCK is the previous length of the arrays.  It must be\n+   zero for the first call to this function, to allocate the arrays for the\n+   first time.\n+\n+   This function is called once during initialization of the scheduler, and\n+   called again to resize the arrays if new basic blocks have been created,\n+   for example for speculation recovery code.  */\n+\n+static void\n+realloc_bb_state_array (int saved_last_basic_block)\n+{\n+  char *old_bb_state_array = bb_state_array;\n+  size_t lbb = (size_t) last_basic_block;\n+  size_t slbb = (size_t) saved_last_basic_block;\n+\n+  /* Nothing to do if nothing changed since the last time this was called.  */\n+  if (saved_last_basic_block == last_basic_block)\n+    return;\n+\n+  /* The selective scheduler doesn't use the state arrays.  */\n+  if (sel_sched_p ())\n+    {\n+      gcc_assert (bb_state_array == NULL && bb_state == NULL);\n+      return;\n+    }\n+\n+  gcc_checking_assert (saved_last_basic_block == 0\n+\t\t       || (bb_state_array != NULL && bb_state != NULL));\n+\n+  bb_state_array = XRESIZEVEC (char, bb_state_array, lbb * dfa_state_size);\n+  bb_state = XRESIZEVEC (state_t, bb_state, lbb);\n+\n+  /* If BB_STATE_ARRAY has moved, fixup all the state pointers array.\n+     Otherwise only fixup the newly allocated ones.  For the state\n+     array itself, only initialize the new entries.  */\n+  bool bb_state_array_moved = (bb_state_array != old_bb_state_array);\n+  for (size_t i = bb_state_array_moved ? 0 : slbb; i < lbb; i++)\n+    bb_state[i] = (state_t) (bb_state_array + i * dfa_state_size);\n+  for (size_t i = slbb; i < lbb; i++)\n+    state_reset (bb_state[i]);\n+}\n+\n+/* Free the arrays of DFA states at the end of each basic block.  */\n+\n+static void\n+free_bb_state_array (void)\n+{\n+  free (bb_state_array);\n+  free (bb_state);\n+  bb_state_array = NULL;\n+  bb_state = NULL;\n+}\n+\n /* Schedule a region.  A region is either an inner loop, a loop-free\n    subroutine, or a single basic block.  Each bb in the region is\n    scheduled after its flow predecessors.  */\n@@ -2986,10 +3045,12 @@ schedule_region (int rgn)\n       if (dbg_cnt (sched_block))\n         {\n \t  edge f;\n+\t  int saved_last_basic_block = last_basic_block;\n \n-          schedule_block (&curr_bb, bb_state[first_bb->index]);\n-          gcc_assert (EBB_FIRST_BB (bb) == first_bb);\n-          sched_rgn_n_insns += sched_n_insns;\n+\t  schedule_block (&curr_bb, bb_state[first_bb->index]);\n+\t  gcc_assert (EBB_FIRST_BB (bb) == first_bb);\n+\t  sched_rgn_n_insns += sched_n_insns;\n+\t  realloc_bb_state_array (saved_last_basic_block);\n \t  f = find_fallthru_edge (last_bb->succs);\n \t  if (f && f->probability * 100 / REG_BR_PROB_BASE >=\n \t      PARAM_VALUE (PARAM_SCHED_STATE_EDGE_PROB_CUTOFF))\n@@ -3032,8 +3093,6 @@ schedule_region (int rgn)\n void\n sched_rgn_init (bool single_blocks_p)\n {\n-  int i;\n-\n   min_spec_prob = ((PARAM_VALUE (PARAM_MIN_SPEC_PROB) * REG_BR_PROB_BASE)\n \t\t    / 100);\n \n@@ -3045,22 +3104,7 @@ sched_rgn_init (bool single_blocks_p)\n   CONTAINING_RGN (ENTRY_BLOCK) = -1;\n   CONTAINING_RGN (EXIT_BLOCK) = -1;\n \n-  if (!sel_sched_p ())\n-    {\n-      bb_state_array = (char *) xmalloc (last_basic_block * dfa_state_size);\n-      bb_state = XNEWVEC (state_t, last_basic_block);\n-      for (i = 0; i < last_basic_block; i++)\n-\t{\n-\t  bb_state[i] = (state_t) (bb_state_array + i * dfa_state_size);\n-      \n-\t  state_reset (bb_state[i]);\n-\t}\n-    }\n-  else\n-    {\n-      bb_state_array = NULL;\n-      bb_state = NULL;\n-    }\n+  realloc_bb_state_array (0);\n \n   /* Compute regions for scheduling.  */\n   if (single_blocks_p\n@@ -3098,8 +3142,7 @@ sched_rgn_init (bool single_blocks_p)\n void\n sched_rgn_finish (void)\n {\n-  free (bb_state_array);\n-  free (bb_state);\n+  free_bb_state_array ();\n \n   /* Reposition the prologue and epilogue notes in case we moved the\n      prologue/epilogue insns.  */"}]}