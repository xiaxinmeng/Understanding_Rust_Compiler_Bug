{"sha": "364667a1ca156f8b6b5fb682cbd423108d6f223c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzY0NjY3YTFjYTE1NmY4YjZiNWZiNjgyY2JkNDIzMTA4ZDZmMjIzYw==", "commit": {"author": {"name": "Steven G. Kargl", "email": "kargls@comcast.net", "date": "2005-06-11T22:29:17Z"}, "committer": {"name": "Steven G. Kargl", "email": "kargl@gcc.gnu.org", "date": "2005-06-11T22:29:17Z"}, "message": "re PR fortran/17792 ([4.0 only] deallocate does not return stat)\n\nPR fortran/17792\nPR fortran/21375\n* trans-array.c (gfc_array_deallocate): pstat is new argument\n  (gfc_array_allocate): update gfc_array_deallocate() call.\n  (gfc_trans_deferred_array): ditto.\n* trans-array.h: update gfc_array_deallocate() prototype.\n* trans-decl.c (gfc_build_builtin_function_decls): update declaration\n* trans-stmt.c (gfc_trans_deallocate): Implement STAT= feature.\n\nFrom-SVN: r100845", "tree": {"sha": "3b719a5f0073b8b53e945c7881da1bea47e61c45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3b719a5f0073b8b53e945c7881da1bea47e61c45"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/364667a1ca156f8b6b5fb682cbd423108d6f223c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/364667a1ca156f8b6b5fb682cbd423108d6f223c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/364667a1ca156f8b6b5fb682cbd423108d6f223c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/364667a1ca156f8b6b5fb682cbd423108d6f223c/comments", "author": null, "committer": null, "parents": [{"sha": "c6bdf92e07201b58176521b96de36150aa092ea6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6bdf92e07201b58176521b96de36150aa092ea6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6bdf92e07201b58176521b96de36150aa092ea6"}], "stats": {"total": 99, "additions": 83, "deletions": 16}, "files": [{"sha": "af1d05f6fabe44e6459a2331cecb575f9b00447d", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=364667a1ca156f8b6b5fb682cbd423108d6f223c", "patch": "@@ -1,3 +1,14 @@\n+2005-06-11  Steven G. Kargl  <kargls@comcast.net>\n+        \n+\tPR fortran/17792\n+\tPR fortran/21375\n+\t* trans-array.c (gfc_array_deallocate): pstat is new argument\n+\t(gfc_array_allocate): update gfc_array_deallocate() call.\n+\t(gfc_trans_deferred_array): ditto.\n+\t* trans-array.h: update gfc_array_deallocate() prototype.\n+\t* trans-decl.c (gfc_build_builtin_function_decls): update declaration\n+\t* trans-stmt.c (gfc_trans_deallocate): Implement STAT= feature.\n+\n 2005-06-07  Jerry DeLisle <jvdelisle@verizon.net>\n \n \t* intrinsic.texi: Add documentation for\tdcmplx, digits,"}, {"sha": "ea5ec524fb57909eefbe64499c90a669c6850095", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=364667a1ca156f8b6b5fb682cbd423108d6f223c", "patch": "@@ -2778,7 +2778,7 @@ gfc_array_allocate (gfc_se * se, gfc_ref * ref, tree pstat)\n /*GCC ARRAYS*/\n \n tree\n-gfc_array_deallocate (tree descriptor)\n+gfc_array_deallocate (tree descriptor, tree pstat)\n {\n   tree var;\n   tree tmp;\n@@ -2793,7 +2793,7 @@ gfc_array_deallocate (tree descriptor)\n \n   /* Parameter is the address of the data component.  */\n   tmp = gfc_chainon_list (NULL_TREE, var);\n-  tmp = gfc_chainon_list (tmp, integer_zero_node);\n+  tmp = gfc_chainon_list (tmp, pstat);\n   tmp = gfc_build_function_call (gfor_fndecl_deallocate, tmp);\n   gfc_add_expr_to_block (&block, tmp);\n \n@@ -4026,7 +4026,7 @@ gfc_trans_deferred_array (gfc_symbol * sym, tree body)\n       gfc_start_block (&block);\n \n       /* Deallocate if still allocated at the end of the procedure.  */\n-      deallocate = gfc_array_deallocate (descriptor);\n+      deallocate = gfc_array_deallocate (descriptor, null_pointer_node);\n \n       tmp = gfc_conv_descriptor_data (descriptor);\n       tmp = build2 (NE_EXPR, boolean_type_node, tmp, "}, {"sha": "95a69f369b48ae6da0e5675139ec78d7866c0f77", "filename": "gcc/fortran/trans-array.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=364667a1ca156f8b6b5fb682cbd423108d6f223c", "patch": "@@ -20,7 +20,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n 02111-1307, USA.  */\n \n /* Generate code to free an array.  */\n-tree gfc_array_deallocate (tree);\n+tree gfc_array_deallocate (tree, tree);\n \n /* Generate code to initialize an allocate an array.  Statements are added to\n    se, which should contain an expression for the array descriptor.  */"}, {"sha": "5aca960d88399c512330dbc538a875b143c91f5b", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=364667a1ca156f8b6b5fb682cbd423108d6f223c", "patch": "@@ -1873,6 +1873,7 @@ gfc_build_builtin_function_decls (void)\n   tree gfc_int4_type_node = gfc_get_int_type (4);\n   tree gfc_int8_type_node = gfc_get_int_type (8);\n   tree gfc_logical4_type_node = gfc_get_logical_type (4);\n+  tree gfc_pint4_type_node = build_pointer_type (gfc_int4_type_node);\n \n   gfor_fndecl_internal_malloc =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"internal_malloc\")),\n@@ -1899,7 +1900,8 @@ gfc_build_builtin_function_decls (void)\n \n   gfor_fndecl_deallocate =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"deallocate\")),\n-\t\t\t\t     void_type_node, 1, ppvoid_type_node);\n+\t\t\t\t     void_type_node, 2, ppvoid_type_node,\n+\t\t\t\t     gfc_pint4_type_node);\n \n   gfor_fndecl_stop_numeric =\n     gfc_build_library_function_decl (get_identifier (PREFIX(\"stop_numeric\")),"}, {"sha": "55543182f8d32ec9e218a40633b76f22f4f46e2c", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 65, "deletions": 11, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/364667a1ca156f8b6b5fb682cbd423108d6f223c/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=364667a1ca156f8b6b5fb682cbd423108d6f223c", "patch": "@@ -3288,19 +3288,56 @@ gfc_trans_allocate (gfc_code * code)\n }\n \n \n+/* Translate a DEALLOCATE statement.\n+   There are two cases within the for loop:\n+   (1) deallocate(a1, a2, a3) is translated into the following sequence\n+       _gfortran_deallocate(a1, 0B)\n+       _gfortran_deallocate(a2, 0B)\n+       _gfortran_deallocate(a3, 0B)\n+       where the STAT= variable is passed a NULL pointer.\n+   (2) deallocate(a1, a2, a3, stat=i) is translated into the following\n+       astat = 0\n+       _gfortran_deallocate(a1, &stat)\n+       astat = astat + stat\n+       _gfortran_deallocate(a2, &stat)\n+       astat = astat + stat\n+       _gfortran_deallocate(a3, &stat)\n+       astat = astat + stat\n+    In case (1), we simply return at the end of the for loop.  In case (2)\n+    we set STAT= astat.  */\n tree\n gfc_trans_deallocate (gfc_code * code)\n {\n   gfc_se se;\n   gfc_alloc *al;\n   gfc_expr *expr;\n-  tree var;\n-  tree tmp;\n-  tree type;\n+  tree apstat, astat, parm, pstat, stat, tmp, type, var;\n   stmtblock_t block;\n \n   gfc_start_block (&block);\n \n+  /* Set up the optional STAT= */\n+  if (code->expr)\n+    {\n+      tree gfc_int4_type_node = gfc_get_int_type (4);\n+\n+      /* Variable used with the library call.  */\n+      stat = gfc_create_var (gfc_int4_type_node, \"stat\");\n+      pstat = gfc_build_addr_expr (NULL, stat);\n+\n+      /* Running total of possible deallocation failures.  */\n+      astat = gfc_create_var (gfc_int4_type_node, \"astat\");\n+      apstat = gfc_build_addr_expr (NULL, astat);\n+\n+      /* Initialize astat to 0.  */\n+      gfc_add_modify_expr (&block, astat, build_int_cst (TREE_TYPE (astat), 0));\n+    }\n+  else\n+    {\n+      pstat = apstat = null_pointer_node;\n+      stat = astat = NULL_TREE;\n+    }\n+\n   for (al = code->ext.alloc_list; al != NULL; al = al->next)\n     {\n       expr = al->expr;\n@@ -3314,24 +3351,41 @@ gfc_trans_deallocate (gfc_code * code)\n       gfc_conv_expr (&se, expr);\n \n       if (expr->symtree->n.sym->attr.dimension)\n-\t{\n-\t  tmp = gfc_array_deallocate (se.expr);\n-\t  gfc_add_expr_to_block (&se.pre, tmp);\n-\t}\n+\ttmp = gfc_array_deallocate (se.expr, pstat);\n       else\n \t{\n \t  type = build_pointer_type (TREE_TYPE (se.expr));\n \t  var = gfc_create_var (type, \"ptr\");\n \t  tmp = gfc_build_addr_expr (type, se.expr);\n \t  gfc_add_modify_expr (&se.pre, var, tmp);\n \n-\t  tmp = gfc_chainon_list (NULL_TREE, var);\n-\t  tmp = gfc_chainon_list (tmp, integer_zero_node);\n-\t  tmp = gfc_build_function_call (gfor_fndecl_deallocate, tmp);\n-\t  gfc_add_expr_to_block (&se.pre, tmp);\n+\t  parm = gfc_chainon_list (NULL_TREE, var);\n+\t  parm = gfc_chainon_list (parm, pstat);\n+\t  tmp = gfc_build_function_call (gfor_fndecl_deallocate, parm);\n \t}\n+\n+      gfc_add_expr_to_block (&se.pre, tmp);\n+\n+      /* Keep track of the number of failed deallocations by adding stat\n+\t of the last deallocation to the running total.  */\n+      if (code->expr)\n+\t{\n+\t  apstat = build2 (PLUS_EXPR, TREE_TYPE (stat), astat, stat);\n+\t  gfc_add_modify_expr (&se.pre, astat, apstat);\n+\t}\n+\n       tmp = gfc_finish_block (&se.pre);\n       gfc_add_expr_to_block (&block, tmp);\n+\n+    }\n+\n+  /* Assign the value to the status variable.  */\n+  if (code->expr)\n+    {\n+      gfc_init_se (&se, NULL);\n+      gfc_conv_expr_lhs (&se, code->expr);\n+      tmp = convert (TREE_TYPE (se.expr), astat);\n+      gfc_add_modify_expr (&block, se.expr, tmp);\n     }\n \n   return gfc_finish_block (&block);"}]}