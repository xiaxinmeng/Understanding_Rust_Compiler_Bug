{"sha": "1d5018955a37fa665acc8dcba8121dd365dbe9be", "node_id": "C_kwDOANBUbNoAKDFkNTAxODk1NWEzN2ZhNjY1YWNjOGRjYmE4MTIxZGQzNjVkYmU5YmU", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@adacore.com", "date": "2022-06-04T10:44:13Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2022-07-05T08:28:18Z"}, "message": "[Ada] Remove exception propagation during bootstrap\n\nTo help the bootstrap path, we want to keep the compiler free from any\nexception propagation during bootstrap. This has been broken recently in\nvarious places.\n\nAlso introduce a way to more easily detect such breakage via the\n-DNO_EXCEPTION_PROPAGATION which can now be used as part of BOOT_CFLAGS.\n\ngcc/ada/\n\n\t* exp_imgv.adb (Build_Enumeration_Image_Tables): Also disable\n\tperfect hash in GNAT_Mode.\n\t* raise-gcc.c (__gnat_Unwind_RaiseException): Add support for\n\tdisabling exception propagation.\n\t* sem_eval.adb (Compile_Time_Known_Value): Update comment and\n\tremove wrong call to Check_Error_Detected.\n\t* sem_prag.adb (Check_Loop_Pragma_Grouping, Analyze_Pragma):\n\tRemove exception propagation during bootstrap.", "tree": {"sha": "32b0bd301f6a92b6bddc0e8861edc175feedac0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/32b0bd301f6a92b6bddc0e8861edc175feedac0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1d5018955a37fa665acc8dcba8121dd365dbe9be", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5018955a37fa665acc8dcba8121dd365dbe9be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1d5018955a37fa665acc8dcba8121dd365dbe9be", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1d5018955a37fa665acc8dcba8121dd365dbe9be/comments", "author": {"login": "ArnaudCharlet", "id": 30291825, "node_id": "MDQ6VXNlcjMwMjkxODI1", "avatar_url": "https://avatars.githubusercontent.com/u/30291825?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ArnaudCharlet", "html_url": "https://github.com/ArnaudCharlet", "followers_url": "https://api.github.com/users/ArnaudCharlet/followers", "following_url": "https://api.github.com/users/ArnaudCharlet/following{/other_user}", "gists_url": "https://api.github.com/users/ArnaudCharlet/gists{/gist_id}", "starred_url": "https://api.github.com/users/ArnaudCharlet/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ArnaudCharlet/subscriptions", "organizations_url": "https://api.github.com/users/ArnaudCharlet/orgs", "repos_url": "https://api.github.com/users/ArnaudCharlet/repos", "events_url": "https://api.github.com/users/ArnaudCharlet/events{/privacy}", "received_events_url": "https://api.github.com/users/ArnaudCharlet/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4844a259b41b4f31940b478216d6dc9faa2bcbca", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4844a259b41b4f31940b478216d6dc9faa2bcbca", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4844a259b41b4f31940b478216d6dc9faa2bcbca"}], "stats": {"total": 54, "additions": 30, "deletions": 24}, "files": [{"sha": "51f1195a8c674dce0b16abd13aa08a552bbaef19", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=1d5018955a37fa665acc8dcba8121dd365dbe9be", "patch": "@@ -289,12 +289,14 @@ package body Exp_Imgv is\n          --  If the unit where the type is declared is the main unit, and the\n          --  number of literals is greater than Threshold_For_Size when we are\n          --  optimizing for size, and the restriction No_Implicit_Loops is not\n-         --  active, and -gnatd_h is not specified, generate the hash function.\n+         --  active, and -gnatd_h is not specified, and not GNAT_Mode, generate\n+         --  the hash function.\n \n          if In_Main_Unit\n            and then (Optimize_Size = 0 or else Nlit > Threshold_For_Size)\n            and then not Restriction_Active (No_Implicit_Loops)\n            and then not Debug_Flag_Underscore_H\n+           and then not GNAT_Mode\n          then\n             declare\n                LB : constant Positive := 2 * Positive (Nlit) + 1;"}, {"sha": "b03964cc019d5be39d7c1773ed5773b588d85f13", "filename": "gcc/ada/raise-gcc.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fraise-gcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fraise-gcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fraise-gcc.c?ref=1d5018955a37fa665acc8dcba8121dd365dbe9be", "patch": "@@ -1377,6 +1377,10 @@ __gnat_cleanupunwind_handler (int version ATTRIBUTE_UNUSED,\n _Unwind_Reason_Code\n __gnat_Unwind_RaiseException (_Unwind_Exception *e)\n {\n+#ifdef NO_EXCEPTION_PROPAGATION\n+  abort();\n+#endif\n+\n #ifdef __USING_SJLJ_EXCEPTIONS__\n   return _Unwind_SjLj_RaiseException (e);\n #else"}, {"sha": "2ba460889405d627a19310575c10ff875296704a", "filename": "gcc/ada/sem_eval.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fsem_eval.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fsem_eval.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_eval.adb?ref=1d5018955a37fa665acc8dcba8121dd365dbe9be", "patch": "@@ -1816,10 +1816,10 @@ package body Sem_Eval is\n \n    begin\n       --  Never known at compile time if bad type or raises Constraint_Error\n-      --  or empty (latter case occurs only as a result of a previous error).\n+      --  or empty (which can occur as a result of a previous error or in the\n+      --  case of e.g. an imported constant).\n \n       if No (Op) then\n-         Check_Error_Detected;\n          return False;\n \n       elsif Op = Error"}, {"sha": "3431e3f61019af4a71dfbdaebc834635662d0feb", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 21, "deletions": 21, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1d5018955a37fa665acc8dcba8121dd365dbe9be/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=1d5018955a37fa665acc8dcba8121dd365dbe9be", "patch": "@@ -6152,15 +6152,11 @@ package body Sem_Prag is\n          --------------------------------\n \n          procedure Check_Loop_Pragma_Grouping (Loop_Stmt : Node_Id) is\n-            Stop_Search : exception;\n-            --  This exception is used to terminate the recursive descent of\n-            --  routine Check_Grouping.\n-\n-            procedure Check_Grouping (L : List_Id);\n+            function Check_Grouping (L : List_Id) return Boolean;\n             --  Find the first group of pragmas in list L and if successful,\n             --  ensure that the current pragma is part of that group. The\n-            --  routine raises Stop_Search once such a check is performed to\n-            --  halt the recursive descent.\n+            --  routine returns True once such a check is performed to\n+            --  stop the analysis.\n \n             procedure Grouping_Error (Prag : Node_Id);\n             pragma No_Return (Grouping_Error);\n@@ -6171,7 +6167,7 @@ package body Sem_Prag is\n             -- Check_Grouping --\n             --------------------\n \n-            procedure Check_Grouping (L : List_Id) is\n+            function Check_Grouping (L : List_Id) return Boolean is\n                HSS  : Node_Id;\n                Stmt : Node_Id;\n                Prag : Node_Id := Empty; -- init to avoid warning\n@@ -6219,7 +6215,7 @@ package body Sem_Prag is\n                            --  Stop the search as the placement is legal.\n \n                            if Stmt = N then\n-                              raise Stop_Search;\n+                              return True;\n \n                            --  Skip group members, but keep track of the\n                            --  last pragma in the group.\n@@ -6266,15 +6262,21 @@ package body Sem_Prag is\n                   elsif Nkind (Stmt) = N_Block_Statement then\n                      HSS := Handled_Statement_Sequence (Stmt);\n \n-                     Check_Grouping (Declarations (Stmt));\n+                     if Check_Grouping (Declarations (Stmt)) then\n+                        return True;\n+                     end if;\n \n                      if Present (HSS) then\n-                        Check_Grouping (Statements (HSS));\n+                        if Check_Grouping (Statements (HSS)) then\n+                           return True;\n+                        end if;\n                      end if;\n                   end if;\n \n                   Next (Stmt);\n                end loop;\n+\n+               return False;\n             end Check_Grouping;\n \n             --------------------\n@@ -6287,17 +6289,16 @@ package body Sem_Prag is\n                Error_Pragma (\"pragma% must appear next to pragma#\");\n             end Grouping_Error;\n \n+            Ignore : Boolean;\n+\n          --  Start of processing for Check_Loop_Pragma_Grouping\n \n          begin\n             --  Inspect the statements of the loop or nested blocks housed\n             --  within to determine whether the current pragma is part of the\n             --  first topmost grouping of Loop_Invariant and Loop_Variant.\n \n-            Check_Grouping (Statements (Loop_Stmt));\n-\n-         exception\n-            when Stop_Search => null;\n+            Ignore := Check_Grouping (Statements (Loop_Stmt));\n          end Check_Loop_Pragma_Grouping;\n \n          --------------------\n@@ -24617,7 +24618,7 @@ package body Sem_Prag is\n             Check_First_Subtype (Task_Type);\n \n             if Rep_Item_Too_Late (Ent, N) then\n-               raise Pragma_Exit;\n+               return;\n             end if;\n          end Task_Storage;\n \n@@ -24879,7 +24880,7 @@ package body Sem_Prag is\n                  or else\n                Rep_Item_Too_Late (E, N)\n             then\n-               raise Pragma_Exit;\n+               return;\n             end if;\n \n             Set_Has_Pragma_Thread_Local_Storage (E);\n@@ -25642,16 +25643,15 @@ package body Sem_Prag is\n                      if CodePeer_Mode or GNATprove_Mode then\n                         Rewrite (N, Make_Null_Statement (Loc));\n                         Analyze (N);\n-                        raise Pragma_Exit;\n+                        return;\n                      end if;\n \n                   elsif Chars (Argx) = Name_Gnatprove then\n                      if not GNATprove_Mode then\n                         Rewrite (N, Make_Null_Statement (Loc));\n                         Analyze (N);\n-                        raise Pragma_Exit;\n+                        return;\n                      end if;\n-\n                   else\n                      raise Program_Error;\n                   end if;\n@@ -25679,7 +25679,7 @@ package body Sem_Prag is\n                       Chars                        => Name_Warnings,\n                       Pragma_Argument_Associations => Shifted_Args));\n                   Analyze (N);\n-                  raise Pragma_Exit;\n+                  return;\n                end if;\n \n                --  One argument case"}]}