{"sha": "3ad97789478df997e5194518abd159cd506f7293", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2FkOTc3ODk0NzhkZjk5N2U1MTk0NTE4YWJkMTU5Y2Q1MDZmNzI5Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2001-12-18T14:13:46Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2001-12-18T14:13:46Z"}, "message": "pt.c (instantiate_clone): Remove, fold into ...\n\n\t* pt.c (instantiate_clone): Remove, fold into ...\n\t(instantiate_template): ... here. Simplify by removing mutual\n\trecursion.\n\t* typeck2.c (build_m_component_ref): Don't cv qualify the function\n\tpointed to by a pointer to function.\n\t* class.c (delete_duplicate_fields_1): Typo.\n\nFrom-SVN: r48155", "tree": {"sha": "acdbcbe38b266b657ef2728e84fda5a59f8cb813", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/acdbcbe38b266b657ef2728e84fda5a59f8cb813"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3ad97789478df997e5194518abd159cd506f7293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad97789478df997e5194518abd159cd506f7293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3ad97789478df997e5194518abd159cd506f7293", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3ad97789478df997e5194518abd159cd506f7293/comments", "author": null, "committer": null, "parents": [{"sha": "f21add0737d299427da125d7b89ecfe89b5e11db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f21add0737d299427da125d7b89ecfe89b5e11db", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f21add0737d299427da125d7b89ecfe89b5e11db"}], "stats": {"total": 116, "additions": 50, "deletions": 66}, "files": [{"sha": "ff053dd1e487e3da9b1776e3d3f10031ee365312", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3ad97789478df997e5194518abd159cd506f7293", "patch": "@@ -1,3 +1,12 @@\n+2001-12-18  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* pt.c (instantiate_clone): Remove, fold into ...\n+\t(instantiate_template): ... here. Simplify by removing mutual\n+\trecursion.\n+\t* typeck2.c (build_m_component_ref): Don't cv qualify the function\n+\tpointed to by a pointer to function.\n+\t* class.c (delete_duplicate_fields_1): Typo.\n+\n 2001-12-18  Jason Merrill  <jason@redhat.com>\n \n \tC++ ABI change: destroy value arguments in caller."}, {"sha": "5201df71550013af213a1816cfa18326cbe67506", "filename": "gcc/cp/class.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=3ad97789478df997e5194518abd159cd506f7293", "patch": "@@ -1074,7 +1074,7 @@ delete_duplicate_fields_1 (field, fields)\n \t\t}\n \t    }\n \t  else if (TREE_CODE (field) == USING_DECL)\n-\t    /* A using declaration may is allowed to appear more than\n+\t    /* A using declaration is allowed to appear more than\n \t       once.  We'll prune these from the field list later, and\n \t       handle_using_decl will complain about invalid multiple\n \t       uses.  */"}, {"sha": "cd43d4cabd6889bf8317e718887217342914c182", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 46, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=3ad97789478df997e5194518abd159cd506f7293", "patch": "@@ -162,7 +162,6 @@ static tree determine_specialization PARAMS ((tree, tree, tree *, int));\n static int template_args_equal PARAMS ((tree, tree));\n static void tsubst_default_arguments PARAMS ((tree));\n static tree for_each_template_parm_r PARAMS ((tree *, int *, void *));\n-static tree instantiate_clone PARAMS ((tree, tree));\n static tree copy_default_args_to_explicit_spec_1 PARAMS ((tree, tree));\n static void copy_default_args_to_explicit_spec PARAMS ((tree));\n static int invalid_nontype_parm_type_p PARAMS ((tree, int));\n@@ -7533,51 +7532,13 @@ tsubst_expr (t, args, complain, in_decl)\n   return tsubst_expr (TREE_CHAIN (t), args, complain, in_decl);\n }\n \n-/* TMPL is a TEMPLATE_DECL for a cloned constructor or destructor.\n-   Instantiate it with the ARGS.  */\n-\n-static tree\n-instantiate_clone (tmpl, args)\n-     tree tmpl;\n-     tree args;\n-{\n-  tree spec;\n-  tree clone;\n-\n-  /* Instantiated the cloned function, rather than the clone.  */\n-  spec = instantiate_template (DECL_CLONED_FUNCTION (tmpl), args);\n-\n-  /* Then, see if we've already cloned the instantiation.  */\n-  for (clone = TREE_CHAIN (spec);\n-       clone && DECL_CLONED_FUNCTION_P (clone);\n-       clone = TREE_CHAIN (clone))\n-    if (DECL_NAME (clone) == DECL_NAME (tmpl))\n-      return clone;\n-\n-  /* If we haven't, do so know.  */\n-  if (!clone)\n-    clone_function_decl (spec, /*update_method_vec_p=*/0);\n-\n-  /* Look again.  */\n-  for (clone = TREE_CHAIN (spec);\n-       clone && DECL_CLONED_FUNCTION_P (clone);\n-       clone = TREE_CHAIN (clone))\n-    if (DECL_NAME (clone) == DECL_NAME (tmpl))\n-      return clone;\n-\n-  /* We should always have found the clone by now.  */\n-  my_friendly_abort (20000411);\n-  return NULL_TREE;\n-}\n-\n /* Instantiate the indicated variable or function template TMPL with\n    the template arguments in TARG_PTR.  */\n \n tree\n instantiate_template (tmpl, targ_ptr)\n      tree tmpl, targ_ptr;\n {\n-  tree clone;\n   tree fndecl;\n   tree gen_tmpl;\n   tree spec;\n@@ -7591,8 +7552,21 @@ instantiate_template (tmpl, targ_ptr)\n \n   /* If this function is a clone, handle it specially.  */\n   if (DECL_CLONED_FUNCTION_P (tmpl))\n-    return instantiate_clone (tmpl, targ_ptr);\n-\n+    {\n+      tree spec = instantiate_template (DECL_CLONED_FUNCTION (tmpl), targ_ptr);\n+      tree clone;\n+      \n+      /* Look for the clone. */\n+      for (clone = TREE_CHAIN (spec);\n+\t   clone && DECL_CLONED_FUNCTION_P (clone);\n+\t   clone = TREE_CHAIN (clone))\n+\tif (DECL_NAME (clone) == DECL_NAME (tmpl))\n+\t  return clone;\n+      /* We should always have found the clone by now.  */\n+      my_friendly_abort (20000411);\n+      return NULL_TREE;\n+    }\n+  \n   /* Check to see if we already have this specialization.  */\n   spec = retrieve_specialization (tmpl, targ_ptr);\n   if (spec != NULL_TREE)\n@@ -7642,11 +7616,11 @@ instantiate_template (tmpl, targ_ptr)\n     add_pending_template (fndecl);\n \n   /* If we've just instantiated the main entry point for a function,\n-     instantiate all the alternate entry points as well.  */\n-  for (clone = TREE_CHAIN (gen_tmpl);\n-       clone && DECL_CLONED_FUNCTION_P (clone);\n-       clone = TREE_CHAIN (clone))\n-    instantiate_template (clone, targ_ptr);\n+     instantiate all the alternate entry points as well.  We do this\n+     by cloning the instantiation of the main entry point, not by\n+     instantiating the template clones.  */\n+  if (TREE_CHAIN (gen_tmpl) && DECL_CLONED_FUNCTION_P (TREE_CHAIN (gen_tmpl)))\n+    clone_function_decl (fndecl, /*update_method_vec_p=*/0);\n \n   return fndecl;\n }"}, {"sha": "2ccd29ed53969f9b6d1a6689c6bd10185a830003", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 20, "deletions": 19, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3ad97789478df997e5194518abd159cd506f7293/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=3ad97789478df997e5194518abd159cd506f7293", "patch": "@@ -1128,6 +1128,24 @@ build_m_component_ref (datum, component)\n     {\n       type = TREE_TYPE (TREE_TYPE (component));\n       field_type = TREE_TYPE (type);\n+      \n+      /* Compute the type of the field, as described in [expr.ref].  */\n+      type_quals = TYPE_UNQUALIFIED;\n+      if (TREE_CODE (field_type) == REFERENCE_TYPE)\n+\t/* The standard says that the type of the result should be the\n+       \t   type referred to by the reference.  But for now, at least,\n+       \t   we do the conversion from reference type later.  */\n+\t;\n+      else\n+\t{\n+\t  type_quals = (cp_type_quals (field_type)  \n+\t\t\t| cp_type_quals (TREE_TYPE (datum)));\n+\n+\t  /* There's no such thing as a mutable pointer-to-member, so\n+\t     we don't need to deal with that here like we do in\n+\t     build_component_ref.  */\n+\t  field_type = cp_build_qualified_type (field_type, type_quals);\n+\t}\n     }\n   else\n     {\n@@ -1138,8 +1156,8 @@ build_m_component_ref (datum, component)\n \n   if (! IS_AGGR_TYPE (objtype))\n     {\n-      error (\"cannot apply member pointer `%E' to `%E'\", component, datum);\n-      error (\"which is of non-aggregate type `%T'\", objtype);\n+      error (\"cannot apply member pointer `%E' to `%E', which is of non-aggregate type `%T'\",\n+\t\tcomponent, datum, objtype);\n       return error_mark_node;\n     }\n \n@@ -1154,23 +1172,6 @@ build_m_component_ref (datum, component)\n   else if (binfo == error_mark_node)\n     return error_mark_node;\n \n-  /* Compute the type of the field, as described in [expr.ref].  */\n-  type_quals = TYPE_UNQUALIFIED;\n-  if (TREE_CODE (field_type) == REFERENCE_TYPE)\n-    /* The standard says that the type of the result should be the\n-       type referred to by the reference.  But for now, at least, we\n-       do the conversion from reference type later.  */\n-    ;\n-  else\n-    {\n-      type_quals = (cp_type_quals (field_type)  \n-\t\t    | cp_type_quals (TREE_TYPE (datum)));\n-\n-      /* There's no such thing as a mutable pointer-to-member, so we don't\n-\t need to deal with that here like we do in build_component_ref.  */\n-      field_type = cp_build_qualified_type (field_type, type_quals);\n-    }\n-\n   component = build (OFFSET_REF, field_type, datum, component);\n   if (TREE_CODE (type) == OFFSET_TYPE)\n     component = resolve_offset_ref (component);"}]}