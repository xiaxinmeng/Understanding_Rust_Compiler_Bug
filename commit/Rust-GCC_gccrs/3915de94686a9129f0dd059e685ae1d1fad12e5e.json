{"sha": "3915de94686a9129f0dd059e685ae1d1fad12e5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzkxNWRlOTQ2ODZhOTEyOWYwZGQwNTllNjg1YWUxZDFmYWQxMmU1ZQ==", "commit": {"author": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-13T12:45:29Z"}, "committer": {"name": "Tom Wood", "email": "wood@gnu.org", "date": "1992-07-13T12:45:29Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r1581", "tree": {"sha": "fcc5ffd0d91be324304a4fa513dc57db871aa349", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fcc5ffd0d91be324304a4fa513dc57db871aa349"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3915de94686a9129f0dd059e685ae1d1fad12e5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3915de94686a9129f0dd059e685ae1d1fad12e5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3915de94686a9129f0dd059e685ae1d1fad12e5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3915de94686a9129f0dd059e685ae1d1fad12e5e/comments", "author": null, "committer": null, "parents": [{"sha": "6f6547765e1283d7a76888fe0eb0c5b5318d9df9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f6547765e1283d7a76888fe0eb0c5b5318d9df9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f6547765e1283d7a76888fe0eb0c5b5318d9df9"}], "stats": {"total": 100, "additions": 75, "deletions": 25}, "files": [{"sha": "6de958df2377c47169f040c76d25432bd5abcfd7", "filename": "gcc/jump.c", "status": "modified", "additions": 75, "deletions": 25, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3915de94686a9129f0dd059e685ae1d1fad12e5e/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3915de94686a9129f0dd059e685ae1d1fad12e5e/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=3915de94686a9129f0dd059e685ae1d1fad12e5e", "patch": "@@ -544,7 +544,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t  rtx reallabelprev;\n \t  rtx temp, temp1, temp2, temp3, temp4, temp5;\n \t  rtx nlabel;\n-\t  int this_is_simplejump, this_is_condjump;\n+\t  int this_is_simplejump, this_is_condjump, reversep;\n #if 0\n \t  /* If NOT the first iteration, if this is the last jump pass\n \t     (just before final), do the special peephole optimizations.\n@@ -802,12 +802,19 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t}\n \t    }\n \n-\t  /* If we have  x = a; if (...) x = b;\n-\t     and either A or B is zero, or if we have  if (...) x = 0;\n-\t     and jumps are expensive, try to use a store-flag insn to\n-\t     avoid the jump.  (If the jump would be faster, the machine\n-\t     should not have defined the scc insns!).  These cases are often\n-\t     made by the previous optimization.\n+\t  /* We deal with four cases:\n+\n+\t     1) x = a; if (...) x = b; and either A or B is zero,\n+\t     2) if (...) x = 0; and jumps are expensive,\n+\t     3) x = a; if (...) x = b; and A and B are constants where all the\n+\t        set bits in A are also set in B and jumps are expensive, and\n+\t     4) x = a; if (...) x = b; and A and B non-zero, and jumps are\n+\t        more expensive.\n+\n+\t     In each of these try to use a store-flag insn to avoid the jump.\n+\t     (If the jump would be faster, the machine should not have\n+\t     defined the scc insns!).  These cases are often made by the\n+\t     previous optimization.\n \n \t     INSN here is the jump around the store.  We set:\n \n@@ -841,7 +848,7 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t\t)\n \t\t       || GET_CODE (temp3) == CONST_INT))\n \t\t  /* Make the latter case look like  x = x; if (...) x = 0;  */\n-\t\t  || ((temp3 = temp1, BRANCH_COST > 1)\n+\t\t  || ((temp3 = temp1, BRANCH_COST >= 2)\n \t\t      && temp2 == const0_rtx))\n \t      /* INSN must either branch to the insn after TEMP or the insn\n \t\t after TEMP must branch to the same place as INSN.  */\n@@ -851,33 +858,47 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t      && JUMP_LABEL (temp4) == JUMP_LABEL (insn)))\n \t      && (temp4 = get_condition (insn, &temp5)) != 0\n \n-\t      /* If B is zero, OK; if A is zero, can only do this if we\n-\t\t can reverse the condition.  */\n-\t      && (temp2 == const0_rtx\n+\t      /* If B is zero, OK; if A is zero, can only do (1) if we\n+\t\t can reverse the condition.  See if (3) applies possibly\n+\t\t by reversing the condition.  Prefer reversing to (4) when\n+\t\t branches are very expensive.  */\n+\t      && ((reversep = 0, temp2 == const0_rtx)\n \t\t  || (temp3 == const0_rtx\n-\t\t      && (can_reverse_comparison_p (temp4, insn)))))\n+\t\t      && (reversep = can_reverse_comparison_p (temp4, insn)))\n+\t\t  || (BRANCH_COST >= 2\n+\t\t      && GET_CODE (temp2) == CONST_INT\n+\t\t      && GET_CODE (temp3) == CONST_INT\n+\t\t      && ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp2)\n+\t\t\t  || ((INTVAL (temp2) & INTVAL (temp3)) == INTVAL (temp3)\n+\t\t\t      && (reversep = can_reverse_comparison_p (temp4,\n+\t\t\t\t\t\t\t\t       insn)))))\n+\t\t  || BRANCH_COST >= 3))\n \t    {\n \t      enum rtx_code code = GET_CODE (temp4);\n-\t      rtx yes = temp3, var = temp1;\n+\t      rtx uval, cval, var = temp1;\n \t      int normalizep;\n \t      rtx target;\n \n \t      /* If necessary, reverse the condition.  */\n-\t      if (temp3 == const0_rtx)\n-\t\tcode = reverse_condition (code), yes = temp2;\n+\t      if (reversep)\n+\t\tcode = reverse_condition (code), uval = temp2, cval = temp3;\n+\t      else\n+\t\tuval = temp3, cval = temp2;\n \n \t      /* See if we can do this with a store-flag insn. */\n \t      start_sequence ();\n \n-\t      /* If YES is the constant 1, it is best to just compute\n-\t\t the result directly.  If YES is constant and STORE_FLAG_VALUE\n+\t      /* If CVAL is non-zero, normalize to -1.  Otherwise,\n+\t\t if UVAL is the constant 1, it is best to just compute\n+\t\t the result directly.  If UVAL is constant and STORE_FLAG_VALUE\n \t\t includes all of its bits, it is best to compute the flag\n-\t\t value unnormalized and `and' it with YES.  Otherwise,\n-\t\t normalize to -1 and `and' with YES.  */\n-\t      normalizep = (yes == const1_rtx ? 1\n-\t\t\t    : (GET_CODE (yes) == CONST_INT\n-\t\t\t       && (INTVAL (yes) & ~ STORE_FLAG_VALUE) == 0) ? 0\n-\t\t\t    : -1);\n+\t\t value unnormalized and `and' it with UVAL.  Otherwise,\n+\t\t normalize to -1 and `and' with UVAL.  */\n+\t      normalizep = (cval != const0_rtx ? -1\n+\t\t\t    : (uval == const1_rtx ? 1\n+\t\t\t       : (GET_CODE (uval) == CONST_INT\n+\t\t\t\t  && (INTVAL (uval) & ~STORE_FLAG_VALUE) == 0)\n+\t\t\t       ? 0 : -1));\n \n \t      /* We will be putting the store-flag insn immediately in\n \t\t front of the comparison that was originally being done,\n@@ -899,10 +920,39 @@ jump_optimize (f, cross_jump, noop_moves, after_regscan)\n \t\t{\n \t\t  rtx seq;\n \n-\t\t  if (normalizep != 1)\n-\t\t    target = expand_and (yes, target,\n+\t\t  /* Both CVAL and UVAL are non-zero.  */\n+\t\t  if (cval != const0_rtx && uval != const0_rtx)\n+\t\t    {\n+\t\t      rtx tem1, tem2;\n+\n+\t\t      tem1 = expand_and (uval, target, NULL_RTX);\n+\t\t      if (GET_CODE (cval) == CONST_INT\n+\t\t\t  && GET_CODE (uval) == CONST_INT\n+\t\t\t  && (INTVAL (cval) & INTVAL (uval)) == INTVAL (cval))\n+\t\t\ttem2 = cval;\n+\t\t      else\n+\t\t\t{\n+\t\t\t  tem2 = expand_unop (GET_MODE (var), one_cmpl_optab,\n+\t\t\t\t\t      target, NULL_RTX, 0);\n+\t\t\t  tem2 = expand_and (cval, tem2, tem2);\n+\t\t\t}\n+\n+\t\t      /* If we usually make new pseudos, do so here.  This\n+\t\t\t turns out to help machines that have conditional\n+\t\t\t move insns.  */\n+\n+\t\t      if (flag_expensive_optimizations)\n+\t\t\ttarget = 0;\n+\n+\t\t      target = expand_binop (GET_MODE (var), ior_optab,\n+\t\t\t\t\t     tem1, tem2, target,\n+\t\t\t\t\t     1, OPTAB_WIDEN);\n+\t\t    }\n+\t\t  else if (normalizep != 1)\n+\t\t    target = expand_and (uval, target,\n \t\t\t\t\t (GET_CODE (target) == REG\n \t\t\t\t\t  ? target : NULL_RTX));\n+\t\t  \n \t\t  seq = gen_sequence ();\n \t\t  end_sequence ();\n \t\t  emit_insn_before (seq, temp5);"}]}