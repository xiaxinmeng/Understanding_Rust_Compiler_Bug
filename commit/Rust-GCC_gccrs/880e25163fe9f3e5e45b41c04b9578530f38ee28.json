{"sha": "880e25163fe9f3e5e45b41c04b9578530f38ee28", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODgwZTI1MTYzZmU5ZjNlNWU0NWI0MWMwNGI5NTc4NTMwZjM4ZWUyOA==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-24T19:51:26Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-24T19:51:26Z"}, "message": "(arm_gen_movstrqi): New function.\n\nFrom-SVN: r7558", "tree": {"sha": "071c73612611bcc198d740dfeeae42f65514f454", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/071c73612611bcc198d740dfeeae42f65514f454"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/880e25163fe9f3e5e45b41c04b9578530f38ee28", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880e25163fe9f3e5e45b41c04b9578530f38ee28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/880e25163fe9f3e5e45b41c04b9578530f38ee28", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/880e25163fe9f3e5e45b41c04b9578530f38ee28/comments", "author": null, "committer": null, "parents": [{"sha": "f0e1b9a9887363dc693310491da72bd22b061cf4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f0e1b9a9887363dc693310491da72bd22b061cf4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f0e1b9a9887363dc693310491da72bd22b061cf4"}], "stats": {"total": 124, "additions": 124, "deletions": 0}, "files": [{"sha": "cca368b912b28deefb811eba957834302d39c281", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/880e25163fe9f3e5e45b41c04b9578530f38ee28/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/880e25163fe9f3e5e45b41c04b9578530f38ee28/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=880e25163fe9f3e5e45b41c04b9578530f38ee28", "patch": "@@ -1542,6 +1542,130 @@ arm_gen_store_multiple (base_regno, count, to, up, write_back)\n   return result;\n }\n \n+int\n+arm_gen_movstrqi (operands)\n+     rtx *operands;\n+{\n+  HOST_WIDE_INT in_words_to_go, out_words_to_go, last_bytes;\n+  int i, r;\n+  rtx const_sxteen = gen_rtx (CONST_INT, SImode, 16);\n+  rtx src, dst;\n+  rtx st_src, st_dst, end_src, end_dst, fin_src, fin_dst;\n+  rtx part_bytes_reg = NULL;\n+  extern int optimize;\n+\n+  if (GET_CODE (operands[2]) != CONST_INT\n+      || GET_CODE (operands[3]) != CONST_INT\n+      || INTVAL (operands[2]) > 64\n+      || INTVAL (operands[3]) & 3)\n+    return 0;\n+\n+  st_dst = XEXP (operands[0], 0);\n+  st_src = XEXP (operands[1], 0);\n+  fin_dst = dst = copy_to_mode_reg (SImode, st_dst);\n+  fin_src = src = copy_to_mode_reg (SImode, st_src);\n+\n+  in_words_to_go = (INTVAL (operands[2]) + 3) / 4;\n+  out_words_to_go = INTVAL (operands[2]) / 4;\n+  last_bytes = INTVAL (operands[2]) & 3;\n+\n+  if (out_words_to_go != in_words_to_go && ((in_words_to_go - 1) & 3) != 0)\n+    part_bytes_reg = gen_rtx (REG, SImode, (in_words_to_go - 1) & 3);\n+\n+  for (i = 0; in_words_to_go >= 2; i+=4)\n+    {\n+      emit_insn (arm_gen_load_multiple (0, (in_words_to_go > 4 \n+\t\t\t\t\t    ? 4 : in_words_to_go),\n+                                        src, TRUE, TRUE));\n+      if (out_words_to_go)\n+\t{\n+\t  if (out_words_to_go != 1)\n+\t    emit_insn (arm_gen_store_multiple (0, (out_words_to_go > 4\n+\t\t\t\t\t\t   ? 4 : out_words_to_go),\n+\t\t\t\t\t       dst, TRUE, TRUE));\n+\t  else\n+\t    {\n+\t      emit_move_insn (gen_rtx (MEM, SImode, dst),\n+\t\t\t      gen_rtx (REG, SImode, 0));\n+\t      emit_insn (gen_addsi3 (dst, dst, GEN_INT (4)));\n+\t    }\n+\t}\n+\n+      in_words_to_go -= in_words_to_go < 4 ? in_words_to_go : 4;\n+      out_words_to_go -= out_words_to_go < 4 ? out_words_to_go : 4;\n+    }\n+\n+  /* OUT_WORDS_TO_GO will be zero here if there are byte stores to do.  */\n+  if (out_words_to_go)\n+  {\n+    rtx sreg;\n+\n+    emit_move_insn (sreg = gen_reg_rtx (SImode), gen_rtx (MEM, SImode, src));\n+    emit_move_insn (fin_src = gen_reg_rtx (SImode), plus_constant (src, 4));\n+    emit_move_insn (gen_rtx (MEM, SImode, dst), sreg);\n+    emit_move_insn (fin_dst = gen_reg_rtx (SImode), plus_constant (dst, 4));\n+    in_words_to_go--;\n+\n+    if (in_words_to_go)\t/* Sanity check */\n+      abort ();\n+  }\n+\n+  if (in_words_to_go)\n+    {\n+      if (in_words_to_go < 0)\n+\tabort ();\n+\n+      part_bytes_reg = copy_to_mode_reg (SImode, gen_rtx (MEM, SImode, src));\n+      emit_insn (gen_addsi3 (src, src, GEN_INT (4)));\n+    }\n+\n+  if (BYTES_BIG_ENDIAN && last_bytes)\n+    {\n+      rtx tmp = gen_reg_rtx (SImode);\n+\n+      if (part_bytes_reg == NULL)\n+\tabort ();\n+\n+      /* The bytes we want are in the top end of the word */\n+      emit_insn (gen_lshrsi3 (tmp, part_bytes_reg, 8 * (4 - last_bytes)));\n+      part_bytes_reg = tmp;\n+      \n+      while (last_bytes)\n+\t{\n+\t  emit_move_insn (gen_rtx (MEM, QImode, \n+\t\t\t\t   plus_constant (dst, last_bytes - 1)),\n+\t\t\t  gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n+\t  if (--last_bytes)\n+\t    {\n+\t      tmp = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_lshrsi3 (tmp, part_bytes_reg, GEN_INT (8)));\n+\t      part_bytes_reg = tmp;\n+\t    }\n+\t}\n+\t  \n+    }\n+  else\n+    {\n+      while (last_bytes)\n+\t{\n+\t  if (part_bytes_reg == NULL)\n+\t    abort ();\n+\n+\t  emit_move_insn (gen_rtx (MEM, QImode, dst),\n+\t\t\t  gen_rtx (SUBREG, QImode, part_bytes_reg, 0));\n+\t  emit_insn (gen_addsi3 (dst, dst, const1_rtx));\n+\t  if (--last_bytes)\n+\t    {\n+\t      rtx tmp = gen_reg_rtx (SImode);\n+\t      emit_insn (gen_lshrsi3 (tmp, part_bytes_reg, GEN_INT (8)));\n+\t      part_bytes_reg = tmp;\n+\t    }\n+\t}\n+    }\n+\n+  return 1;\n+}\n+\n /* X and Y are two things to compare using CODE.  Emit the compare insn and\n    return the rtx for register 0 in the proper mode.  FP means this is a\n    floating point compare: I don't think that it is needed on the arm.  */"}]}