{"sha": "da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGEwMWJmZWUxYWFmZTZjNjhjMmMyMWQ5ZDZkNzdhNTA2YzdlNTJjNw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2010-05-08T11:17:57Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2010-05-08T11:17:57Z"}, "message": "gigi.h (create_field_decl): Move PACKED parameter.\n\n\t* gcc-interface/gigi.h (create_field_decl): Move PACKED parameter.\n\t* gcc-interface/utils.c (create_field_decl): Move PACKED parameter.\n\t(rest_of_record_type_compilation): Adjust call to create_field_decl.\n\t(make_descriptor_field): Likewise and pass correctly typed constants.\n\t(build_unc_object_type): Likewise.\n\t(unchecked_convert): Likewise.\n\t* gcc-interface/decl.c (elaborate_expression_2): New static function.\n\t(gnat_to_gnu_entity): Use it to make alignment factors explicit.\n\tAdjust call to create_field_decl.\n\t(make_aligning_type): Likewise.\n\t(make_packable_type): Likewise.\n\t(maybe_pad_type): Likewise.\n\t(gnat_to_gnu_field): Likewise.\n\t(components_to_record): Likewise.\n\t(create_field_decl_from): Likewise.\n\t(create_variant_part_from): Remove superfluous test.\n\t* gcc-interface/trans.c (gigi): Adjust call to create_field_decl.\n\nFrom-SVN: r159181", "tree": {"sha": "00a25473a21da8c1d6a9ebf2f7542aa0fb082e4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/00a25473a21da8c1d6a9ebf2f7542aa0fb082e4b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/comments", "author": null, "committer": null, "parents": [{"sha": "928dfa4bd0a32e35a8366d7ef21323a76f54a97c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/928dfa4bd0a32e35a8366d7ef21323a76f54a97c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/928dfa4bd0a32e35a8366d7ef21323a76f54a97c"}], "stats": {"total": 328, "additions": 177, "deletions": 151}, "files": [{"sha": "6a7827885c48a9a633d4450cf1cc036886ea8f38", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "patch": "@@ -1,3 +1,23 @@\n+2010-05-08  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc-interface/gigi.h (create_field_decl): Move PACKED parameter.\n+\t* gcc-interface/utils.c (create_field_decl): Move PACKED parameter.\n+\t(rest_of_record_type_compilation): Adjust call to create_field_decl.\n+\t(make_descriptor_field): Likewise and pass correctly typed constants.\n+\t(build_unc_object_type): Likewise.\n+\t(unchecked_convert): Likewise.\n+\t* gcc-interface/decl.c (elaborate_expression_2): New static function.\n+\t(gnat_to_gnu_entity): Use it to make alignment factors explicit.\n+\tAdjust call to create_field_decl.\n+\t(make_aligning_type): Likewise.\n+\t(make_packable_type): Likewise.\n+\t(maybe_pad_type): Likewise.\n+\t(gnat_to_gnu_field): Likewise.\n+\t(components_to_record): Likewise.\n+\t(create_field_decl_from): Likewise.\n+\t(create_variant_part_from): Remove superfluous test.\n+\t* gcc-interface/trans.c (gigi): Adjust call to create_field_decl.\n+\n 2010-05-08  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* gcc-interface/gigi.h (build_unc_object_type): Add DEBUG_INFO_P param."}, {"sha": "3050475d6cf18417f8b405a2c90fa72a767b9a13", "filename": "gcc/ada/gcc-interface/decl.c", "status": "modified", "additions": 128, "deletions": 125, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fdecl.c?ref=da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "patch": "@@ -129,6 +129,8 @@ static void prepend_attributes (Entity_Id, struct attrib **);\n static tree elaborate_expression (Node_Id, Entity_Id, tree, bool, bool, bool);\n static bool is_variable_size (tree);\n static tree elaborate_expression_1 (tree, Entity_Id, tree, bool, bool);\n+static tree elaborate_expression_2 (tree, Entity_Id, tree, bool, bool,\n+\t\t\t\t    unsigned int);\n static tree make_packable_type (tree, bool);\n static tree gnat_to_gnu_component_type (Entity_Id, bool, bool);\n static tree gnat_to_gnu_param (Entity_Id, Mechanism_Type, Entity_Id, bool,\n@@ -1668,9 +1670,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n \t     bitfield.  */\n-\t  gnu_field = create_field_decl (get_identifier (\"OBJECT\"),\n-\t\t\t\t\t gnu_field_type, gnu_type, 1,\n-\t\t\t\t\t NULL_TREE, bitsize_zero_node, 0);\n+\t  gnu_field\n+\t    = create_field_decl (get_identifier (\"OBJECT\"), gnu_field_type,\n+\t\t\t\t gnu_type, NULL_TREE, bitsize_zero_node, 1, 0);\n \n \t  /* Do not emit debug info until after the parallel type is added.  */\n \t  finish_record_type (gnu_type, gnu_field, 2, false);\n@@ -1719,9 +1721,9 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  /* Don't notify the field as \"addressable\", since we won't be taking\n \t     it's address and it would prevent create_field_decl from making a\n \t     bitfield.  */\n-\t  gnu_field = create_field_decl (get_identifier (\"F\"),\n-\t\t\t\t\t gnu_field_type, gnu_type, 1,\n-\t\t\t\t\t NULL_TREE, bitsize_zero_node, 0);\n+\t  gnu_field\n+\t    = create_field_decl (get_identifier (\"F\"), gnu_field_type,\n+\t\t\t\t gnu_type, NULL_TREE, bitsize_zero_node, 1, 0);\n \n \t  finish_record_type (gnu_type, gnu_field, 2, debug_info_p);\n \t  compute_record_mode (gnu_type);\n@@ -1854,12 +1856,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \ttem = chainon (chainon (NULL_TREE,\n \t\t\t\tcreate_field_decl (get_identifier (\"P_ARRAY\"),\n \t\t\t\t\t\t   ptr_void_type_node,\n-\t\t\t\t\t\t   gnu_fat_type, 0,\n-\t\t\t\t\t\t   NULL_TREE, NULL_TREE, 0)),\n+\t\t\t\t\t\t   gnu_fat_type, NULL_TREE,\n+\t\t\t\t\t\t   NULL_TREE, 0, 0)),\n \t\t       create_field_decl (get_identifier (\"P_BOUNDS\"),\n \t\t\t\t\t  gnu_ptr_template,\n-\t\t\t\t\t  gnu_fat_type, 0,\n-\t\t\t\t\t  NULL_TREE, NULL_TREE, 0));\n+\t\t\t\t\t  gnu_fat_type, NULL_TREE,\n+\t\t\t\t\t  NULL_TREE, 0, 0));\n \n \t/* Make sure we can put this into a register.  */\n \tTYPE_ALIGN (gnu_fat_type) = MIN (BIGGEST_ALIGNMENT, 2 * POINTER_SIZE);\n@@ -1899,16 +1901,16 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    sprintf (field_name, \"LB%d\", index);\n \t    gnu_lb_field = create_field_decl (get_identifier (field_name),\n \t\t\t\t\t      gnu_index_base_type,\n-\t\t\t\t\t      gnu_template_type, 0,\n-\t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n+\t\t\t\t\t      gnu_template_type, NULL_TREE,\n+\t\t\t\t\t      NULL_TREE, 0, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_lb_field));\n \n \t    field_name[0] = 'U';\n \t    gnu_hb_field = create_field_decl (get_identifier (field_name),\n \t\t\t\t\t      gnu_index_base_type,\n-\t\t\t\t\t      gnu_template_type, 0,\n-\t\t\t\t\t      NULL_TREE, NULL_TREE, 0);\n+\t\t\t\t\t      gnu_template_type, NULL_TREE,\n+\t\t\t\t\t      NULL_TREE, 0, 0);\n \t    Sloc_to_locus (Sloc (gnat_entity),\n \t\t\t   &DECL_SOURCE_LOCATION (gnu_hb_field));\n \n@@ -2354,35 +2356,30 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t     inner dimensions.   */\n \t  if (global_bindings_p () && ndim > 1)\n \t    {\n-\t      tree gnu_str_name = get_identifier (\"ST\");\n+\t      tree gnu_st_name = get_identifier (\"ST\");\n \t      tree gnu_arr_type;\n \n \t      for (gnu_arr_type = TREE_TYPE (gnu_type);\n \t\t   TREE_CODE (gnu_arr_type) == ARRAY_TYPE;\n \t\t   gnu_arr_type = TREE_TYPE (gnu_arr_type),\n-\t\t   gnu_str_name = concat_name (gnu_str_name, \"ST\"))\n+\t\t   gnu_st_name = concat_name (gnu_st_name, \"ST\"))\n \t\t{\n \t\t  tree eltype = TREE_TYPE (gnu_arr_type);\n \n \t\t  TYPE_SIZE (gnu_arr_type)\n \t\t    = elaborate_expression_1 (TYPE_SIZE (gnu_arr_type),\n-\t\t\t\t\t      gnat_entity, gnu_str_name,\n+\t\t\t\t\t      gnat_entity, gnu_st_name,\n \t\t\t\t\t      definition, false);\n \n \t\t  /* ??? For now, store the size as a multiple of the\n \t\t     alignment of the element type in bytes so that we\n \t\t     can see the alignment from the tree.  */\n \t\t  TYPE_SIZE_UNIT (gnu_arr_type)\n-\t\t    = build_binary_op\n-\t\t      (MULT_EXPR, sizetype,\n-\t\t       elaborate_expression_1\n-\t\t       (build_binary_op (EXACT_DIV_EXPR, sizetype,\n-\t\t\t\t\t TYPE_SIZE_UNIT (gnu_arr_type),\n-\t\t\t\t\t size_int (TYPE_ALIGN (eltype)\n-\t\t\t\t\t\t   / BITS_PER_UNIT)),\n-\t\t\tgnat_entity, concat_name (gnu_str_name, \"A_U\"),\n-\t\t\tdefinition, false),\n-\t\t       size_int (TYPE_ALIGN (eltype) / BITS_PER_UNIT));\n+\t\t    = elaborate_expression_2 (TYPE_SIZE_UNIT (gnu_arr_type),\n+\t\t\t\t\t      gnat_entity,\n+\t\t\t\t\t      concat_name (gnu_st_name, \"A_U\"),\n+\t\t\t\t\t      definition, false,\n+\t\t\t\t\t      TYPE_ALIGN (eltype));\n \n \t\t  /* ??? create_type_decl is not invoked on the inner types so\n \t\t     the MULT_EXPR node built above will never be marked.  */\n@@ -2416,8 +2413,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  /* Make sure to reference the types themselves, and not just\n \t\t     their names, as the debugger may fall back on them.  */\n \t\t  gnu_field = create_field_decl (gnu_index_name, gnu_index,\n-\t\t\t\t\t\t gnu_bound_rec,\n-\t\t\t\t\t\t 0, NULL_TREE, NULL_TREE, 0);\n+\t\t\t\t\t\t gnu_bound_rec, NULL_TREE,\n+\t\t\t\t\t\t NULL_TREE, 0, 0);\n \t\t  TREE_CHAIN (gnu_field) = gnu_field_list;\n \t\t  gnu_field_list = gnu_field;\n \t\t}\n@@ -2849,11 +2846,12 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    /* ...and reference the _Parent field of this record.  */\n \t    gnu_field\n \t      = create_field_decl (parent_name_id,\n-\t\t\t\t   gnu_parent, gnu_type, 0,\n+\t\t\t\t   gnu_parent, gnu_type,\n \t\t\t\t   has_rep\n \t\t\t\t   ? TYPE_SIZE (gnu_parent) : NULL_TREE,\n \t\t\t\t   has_rep\n-\t\t\t\t   ? bitsize_zero_node : NULL_TREE, 1);\n+\t\t\t\t   ? bitsize_zero_node : NULL_TREE,\n+\t\t\t\t   0, 1);\n \t    DECL_INTERNAL_P (gnu_field) = 1;\n \t    TREE_OPERAND (gnu_get_parent, 1) = gnu_field;\n \t    TYPE_FIELDS (gnu_type) = gnu_field;\n@@ -3250,8 +3248,8 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t\t\t\t\t\t build_reference_type\n \t\t\t\t\t\t\t (gnu_unpad_base_type),\n \t\t\t\t\t\t\t gnu_subtype_marker,\n-\t\t\t\t\t\t\t 0, NULL_TREE,\n-\t\t\t\t\t\t\t NULL_TREE, 0),\n+\t\t\t\t\t\t\t NULL_TREE, NULL_TREE,\n+\t\t\t\t\t\t\t 0, 0),\n \t\t\t\t      0, true);\n \n \t\t  add_parallel_type (TYPE_STUB_DECL (gnu_type),\n@@ -3477,11 +3475,11 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t  = chainon (chainon (NULL_TREE,\n \t\t\t\t      create_field_decl\n \t\t\t\t      (get_identifier (\"P_ARRAY\"),\n-\t\t\t\t       gnu_ptr_array,\n-\t\t\t\t       gnu_type, 0, 0, 0, 0)),\n+\t\t\t\t       gnu_ptr_array, gnu_type,\n+\t\t\t\t       NULL_TREE, NULL_TREE, 0, 0)),\n \t\t\t     create_field_decl (get_identifier (\"P_BOUNDS\"),\n-\t\t\t\t\t\tgnu_ptr_template,\n-\t\t\t\t\t\tgnu_type, 0, 0, 0, 0));\n+\t\t\t\t\t\tgnu_ptr_template, gnu_type,\n+\t\t\t\t\t\tNULL_TREE, NULL_TREE, 0, 0));\n \n \t\t/* Make sure we can place this into a register.  */\n \t\tTYPE_ALIGN (gnu_type)\n@@ -4090,8 +4088,10 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t\t    has_copy_in_out = true;\n \t\t  }\n \n-\t\tgnu_field = create_field_decl (gnu_param_name, gnu_param_type,\n-\t\t\t\t\t       gnu_return_type, 0, 0, 0, 0);\n+\t\tgnu_field\n+\t\t  = create_field_decl (gnu_param_name, gnu_param_type,\n+\t\t\t\t       gnu_return_type, NULL_TREE, NULL_TREE,\n+\t\t\t\t       0, 0);\n \t\tSloc_to_locus (Sloc (gnat_param),\n \t\t\t       &DECL_SOURCE_LOCATION (gnu_field));\n \t\tTREE_CHAIN (gnu_field) = gnu_field_list;\n@@ -4495,45 +4495,38 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t  && !TREE_CONSTANT (TYPE_SIZE (gnu_type))\n \t  && !CONTAINS_PLACEHOLDER_P (TYPE_SIZE (gnu_type)))\n \t{\n-\t  if (TREE_CODE (gnu_type) == RECORD_TYPE\n-\t      && operand_equal_p (TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t  TYPE_SIZE (gnu_type), 0))\n-\t    {\n-\t      TYPE_SIZE (gnu_type)\n-\t\t= elaborate_expression_1 (TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  gnat_entity, get_identifier (\"SIZE\"),\n-\t\t\t\t\t  definition, false);\n-\t      SET_TYPE_ADA_SIZE (gnu_type, TYPE_SIZE (gnu_type));\n-\t    }\n-\t  else\n+\t  tree size = TYPE_SIZE (gnu_type);\n+\n+\t  TYPE_SIZE (gnu_type)\n+\t    = elaborate_expression_1 (size, gnat_entity,\n+\t\t\t\t      get_identifier (\"SIZE\"),\n+\t\t\t\t      definition, false);\n+\n+\t  /* ??? For now, store the size as a multiple of the alignment in\n+\t     bytes so that we can see the alignment from the tree.  */\n+\t  TYPE_SIZE_UNIT (gnu_type)\n+\t    = elaborate_expression_2 (TYPE_SIZE_UNIT (gnu_type), gnat_entity,\n+\t\t\t\t      get_identifier (\"SIZE_A_UNIT\"),\n+\t\t\t\t      definition, false,\n+\t\t\t\t      TYPE_ALIGN (gnu_type));\n+\n+\t  /* ??? gnu_type may come from an existing type so the MULT_EXPR node\n+\t     may not be marked by the call to create_type_decl below.  */\n+\t  MARK_VISITED (TYPE_SIZE_UNIT (gnu_type));\n+\n+\t  if (TREE_CODE (gnu_type) == RECORD_TYPE)\n \t    {\n-\t      TYPE_SIZE (gnu_type)\n-\t\t= elaborate_expression_1 (TYPE_SIZE (gnu_type),\n-\t\t\t\t\t  gnat_entity, get_identifier (\"SIZE\"),\n-\t\t\t\t\t  definition, false);\n+\t      tree ada_size = TYPE_ADA_SIZE (gnu_type);\n \n-\t      /* ??? For now, store the size as a multiple of the alignment\n-\t\t in bytes so that we can see the alignment from the tree.  */\n-\t      TYPE_SIZE_UNIT (gnu_type)\n-\t\t= build_binary_op\n-\t\t  (MULT_EXPR, sizetype,\n-\t\t   elaborate_expression_1\n-\t\t   (build_binary_op (EXACT_DIV_EXPR, sizetype,\n-\t\t\t\t     TYPE_SIZE_UNIT (gnu_type),\n-\t\t\t\t     size_int (TYPE_ALIGN (gnu_type)\n-\t\t\t\t\t       / BITS_PER_UNIT)),\n-\t\t    gnat_entity, get_identifier (\"SIZE_A_UNIT\"),\n-\t\t    definition, false),\n-\t\t   size_int (TYPE_ALIGN (gnu_type) / BITS_PER_UNIT));\n-\n-\t      if (TREE_CODE (gnu_type) == RECORD_TYPE)\n-\t\tSET_TYPE_ADA_SIZE\n-\t\t  (gnu_type,\n-\t\t   elaborate_expression_1 (TYPE_ADA_SIZE (gnu_type),\n-\t\t\t\t\t   gnat_entity,\n-\t\t\t\t\t   get_identifier (\"RM_SIZE\"),\n-\t\t\t\t\t   definition, false));\n-\t\t }\n+\t      if (operand_equal_p (ada_size, size, 0))\n+\t\tada_size = TYPE_SIZE (gnu_type);\n+\t      else\n+\t\tada_size\n+\t\t  = elaborate_expression_1 (ada_size, gnat_entity,\n+\t\t\t\t\t    get_identifier (\"RM_SIZE\"),\n+\t\t\t\t\t    definition, false);\n+\t      SET_TYPE_ADA_SIZE (gnu_type, ada_size);\n+\t    }\n \t}\n \n       /* If this is a record type or subtype, call elaborate_expression_1 on\n@@ -4547,30 +4540,22 @@ gnat_to_gnu_entity (Entity_Id gnat_entity, tree gnu_expr, int definition)\n \t    {\n \t      tree gnu_field = get_gnu_tree (gnat_temp);\n \n-\t      /* ??? Unfortunately, GCC needs to be able to prove the\n-\t\t alignment of this offset and if it's a variable, it can't.\n-\t\t In GCC 3.4, we'll use DECL_OFFSET_ALIGN in some way, but\n-\t\t right now, we have to put in an explicit multiply and\n-\t\t divide by that value.  */\n+\t      /* ??? For now, store the offset as a multiple of the alignment\n+\t\t in bytes so that we can see the alignment from the tree.  */\n \t      if (!CONTAINS_PLACEHOLDER_P (DECL_FIELD_OFFSET (gnu_field)))\n \t\t{\n-\t\tDECL_FIELD_OFFSET (gnu_field)\n-\t\t  = build_binary_op\n-\t\t    (MULT_EXPR, sizetype,\n-\t\t     elaborate_expression_1\n-\t\t     (build_binary_op (EXACT_DIV_EXPR, sizetype,\n-\t\t\t\t       DECL_FIELD_OFFSET (gnu_field),\n-\t\t\t\t       size_int (DECL_OFFSET_ALIGN (gnu_field)\n-\t\t\t\t\t\t / BITS_PER_UNIT)),\n-\t\t      gnat_temp, get_identifier (\"OFFSET\"),\n-\t\t      definition, false),\n-\t\t     size_int (DECL_OFFSET_ALIGN (gnu_field) / BITS_PER_UNIT));\n-\n-\t\t/* ??? The context of gnu_field is not necessarily gnu_type so\n-\t\t   the MULT_EXPR node built above may not be marked by the call\n-\t\t   to create_type_decl below.  */\n-\t\tif (global_bindings_p ())\n-\t\t  MARK_VISITED (DECL_FIELD_OFFSET (gnu_field));\n+\t\t  DECL_FIELD_OFFSET (gnu_field)\n+\t\t    = elaborate_expression_2 (DECL_FIELD_OFFSET (gnu_field),\n+\t\t\t\t\t      gnat_temp,\n+\t\t\t\t\t      get_identifier (\"OFFSET\"),\n+\t\t\t\t\t      definition, false,\n+\t\t\t\t\t      DECL_OFFSET_ALIGN (gnu_field));\n+\n+\t\t  /* ??? The context of gnu_field is not necessarily gnu_type\n+\t\t     so the MULT_EXPR node built above may not be marked by\n+\t\t     the call to create_type_decl below.  */\n+\t\t  if (global_bindings_p ())\n+\t\t    MARK_VISITED (DECL_FIELD_OFFSET (gnu_field));\n \t\t}\n \t    }\n \n@@ -5859,6 +5844,23 @@ elaborate_expression_1 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n \n   return expr_variable ? gnat_save_expr (gnu_expr) : gnu_expr;\n }\n+\n+/* Similar, but take an alignment factor and make it explicit in the tree.  */\n+\n+static tree\n+elaborate_expression_2 (tree gnu_expr, Entity_Id gnat_entity, tree gnu_name,\n+\t\t\tbool definition, bool need_debug, unsigned int align)\n+{\n+  tree unit_align = size_int (align / BITS_PER_UNIT);\n+  return\n+    size_binop (MULT_EXPR,\n+\t\telaborate_expression_1 (size_binop (EXACT_DIV_EXPR,\n+\t\t\t\t\t\t    gnu_expr,\n+\t\t\t\t\t\t    unit_align),\n+\t\t\t\t\tgnat_entity, gnu_name, definition,\n+\t\t\t\t\tneed_debug),\n+\t\tunit_align);\n+}\n \f\n /* Create a record type that contains a SIZE bytes long field of TYPE with a\n    starting bit position so that it is aligned to ALIGN bits, and leaving at\n@@ -5928,8 +5930,8 @@ make_aligning_type (tree type, unsigned int align, tree size,\n      consequences on the alignment computation, and create_field_decl would\n      make one without this special argument, for instance because of the\n      complex position expression.  */\n-  field = create_field_decl (get_identifier (\"F\"), type, record_type,\n-                             1, size, pos, -1);\n+  field = create_field_decl (get_identifier (\"F\"), type, record_type, size,\n+\t\t\t     pos, 1, -1);\n   TYPE_FIELDS (record_type) = field;\n \n   TYPE_ALIGN (record_type) = base_align;\n@@ -6050,10 +6052,11 @@ make_packable_type (tree type, bool in_record)\n       else\n \tnew_size = DECL_SIZE (old_field);\n \n-      new_field = create_field_decl (DECL_NAME (old_field), new_field_type,\n-\t\t\t\t     new_type, TYPE_PACKED (type), new_size,\n-\t\t\t\t     bit_position (old_field),\n-\t\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n+      new_field\n+\t= create_field_decl (DECL_NAME (old_field), new_field_type, new_type,\n+\t\t\t     new_size, bit_position (old_field),\n+\t\t\t     TYPE_PACKED (type),\n+\t\t\t     !DECL_NONADDRESSABLE_P (old_field));\n \n       DECL_INTERNAL_P (new_field) = DECL_INTERNAL_P (old_field);\n       SET_DECL_ORIGINAL_FIELD_TO_FIELD (new_field, old_field);\n@@ -6217,8 +6220,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n     }\n \n   /* Now create the field with the original size.  */\n-  field  = create_field_decl (get_identifier (\"F\"), type, record, 0,\n-\t\t\t      orig_size, bitsize_zero_node, 1);\n+  field  = create_field_decl (get_identifier (\"F\"), type, record, orig_size,\n+\t\t\t      bitsize_zero_node, 0, 1);\n   DECL_INTERNAL_P (field) = 1;\n \n   /* Do not emit debug info until after the auxiliary record is built.  */\n@@ -6251,8 +6254,8 @@ maybe_pad_type (tree type, tree size, unsigned int align,\n       finish_record_type (marker,\n \t\t\t  create_field_decl (orig_name,\n \t\t\t\t\t     build_reference_type (type),\n-\t\t\t\t\t     marker, 0, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t     0),\n+\t\t\t\t\t     marker, NULL_TREE, NULL_TREE,\n+\t\t\t\t\t     0, 0),\n \t\t\t  0, true);\n \n       add_parallel_type (TYPE_STUB_DECL (record), marker);\n@@ -6680,9 +6683,9 @@ gnat_to_gnu_field (Entity_Id gnat_field, tree gnu_record_type, int packed,\n \t      || !TYPE_CONTAINS_TEMPLATE_P (gnu_field_type));\n \n   /* Now create the decl for the field.  */\n-  gnu_field = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n-\t\t\t\t packed, gnu_size, gnu_pos,\n-\t\t\t\t Is_Aliased (gnat_field));\n+  gnu_field\n+    = create_field_decl (gnu_field_id, gnu_field_type, gnu_record_type,\n+\t\t\t gnu_size, gnu_pos, packed, Is_Aliased (gnat_field));\n   Sloc_to_locus (Sloc (gnat_field), &DECL_SOURCE_LOCATION (gnu_field));\n   TREE_THIS_VOLATILE (gnu_field) = Treat_As_Volatile (gnat_field);\n \n@@ -6934,14 +6937,14 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t      create_type_decl (TYPE_NAME (gnu_variant_type), gnu_variant_type,\n \t\t\t\tNULL, true, debug_info_p, gnat_component_list);\n \n-\t      gnu_field = create_field_decl (gnu_inner_name, gnu_variant_type,\n-\t\t\t\t\t     gnu_union_type, field_packed,\n-\t\t\t\t\t     (all_rep_and_size\n-\t\t\t\t\t      ? TYPE_SIZE (gnu_variant_type)\n-\t\t\t\t\t      : 0),\n-\t\t\t\t\t     (all_rep_and_size\n-\t\t\t\t\t      ? bitsize_zero_node : 0),\n-\t\t\t\t\t     0);\n+\t      gnu_field\n+\t\t= create_field_decl (gnu_inner_name, gnu_variant_type,\n+\t\t\t\t     gnu_union_type,\n+\t\t\t\t     all_rep_and_size\n+\t\t\t\t     ? TYPE_SIZE (gnu_variant_type) : 0,\n+\t\t\t\t     all_rep_and_size\n+\t\t\t\t     ? bitsize_zero_node : 0,\n+\t\t\t\t     field_packed, 0);\n \n \t      DECL_INTERNAL_P (gnu_field) = 1;\n \n@@ -6988,9 +6991,9 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \n \t  gnu_union_field\n \t    = create_field_decl (gnu_var_name, gnu_union_type, gnu_record_type,\n-\t\t\t\t union_field_packed,\n \t\t\t\t all_rep ? TYPE_SIZE (gnu_union_type) : 0,\n-\t\t\t\t all_rep ? bitsize_zero_node : 0, 0);\n+\t\t\t\t all_rep ? bitsize_zero_node : 0,\n+\t\t\t\t union_field_packed, 0);\n \n \t  DECL_INTERNAL_P (gnu_union_field) = 1;\n \t  TREE_CHAIN (gnu_union_field) = gnu_field_list;\n@@ -7061,7 +7064,7 @@ components_to_record (tree gnu_record_type, Node_Id gnat_component_list,\n \t  finish_record_type (gnu_rep_type, gnu_our_rep_list, 1, debug_info_p);\n \t  gnu_field\n \t    = create_field_decl (get_identifier (\"REP\"), gnu_rep_type,\n-\t\t\t\t gnu_record_type, 0, NULL_TREE, NULL_TREE, 1);\n+\t\t\t\t gnu_record_type, NULL_TREE, NULL_TREE, 0, 1);\n \t  DECL_INTERNAL_P (gnu_field) = 1;\n \t  gnu_field_list = chainon (gnu_field_list, gnu_field);\n \t}\n@@ -8003,7 +8006,7 @@ create_field_decl_from (tree old_field, tree field_type, tree record_type,\n \n   new_field\n     = create_field_decl (DECL_NAME (old_field), field_type, record_type,\n-\t\t\t DECL_PACKED (old_field), size, new_pos,\n+\t\t\t size, new_pos, DECL_PACKED (old_field),\n \t\t\t !DECL_NONADDRESSABLE_P (old_field));\n \n   if (!new_pos)\n@@ -8071,7 +8074,6 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n \t\t\t  tree record_type, tree pos_list, tree subst_list)\n {\n   tree offset = DECL_FIELD_OFFSET (old_variant_part);\n-  tree bitpos = DECL_FIELD_BIT_OFFSET (old_variant_part);\n   tree old_union_type = TREE_TYPE (old_variant_part);\n   tree new_union_type, new_variant_part, t;\n   tree union_field_list = NULL_TREE;\n@@ -8083,8 +8085,9 @@ create_variant_part_from (tree old_variant_part, tree variant_list,\n   /* If the position of the variant part is constant, subtract it from the\n      size of the type of the parent to get the new size.  This manual CSE\n      reduces the code size when not optimizing.  */\n-  if (TREE_CODE (offset) == INTEGER_CST && TREE_CODE (bitpos) == INTEGER_CST)\n+  if (TREE_CODE (offset) == INTEGER_CST)\n     {\n+      tree bitpos = DECL_FIELD_BIT_OFFSET (old_variant_part);\n       tree first_bit = bit_from_pos (offset, bitpos);\n       TYPE_SIZE (new_union_type)\n \t= size_binop (MINUS_EXPR, TYPE_SIZE (record_type), first_bit);"}, {"sha": "f3a0bdd3499192c00c58033fb14752916ff35366", "filename": "gcc/ada/gcc-interface/gigi.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Fgigi.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Fgigi.h?ref=da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "patch": "@@ -595,15 +595,15 @@ extern void record_global_renaming_pointer (tree decl);\n extern void invalidate_global_renaming_pointers (void);\n \n /* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n-   its type and RECORD_TYPE is the type of the enclosing record.  PACKED is\n-   1 if the enclosing record is packed, -1 if it has Component_Alignment of\n-   Storage_Unit.  If SIZE is nonzero, it is the specified size of the field.\n-   If POS is nonzero, it is the bit position.  If ADDRESSABLE is nonzero, it\n+   its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n+   nonzero, it is the specified size of the field.  If POS is nonzero, it is\n+   the bit position.  PACKED is 1 if the enclosing record is packed, -1 if it\n+   has Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n    means we are allowed to take the address of the field; if it is negative,\n    we should not make a bitfield, which is used by make_aligning_type.  */\n extern tree create_field_decl (tree field_name, tree field_type,\n-                               tree record_type, int packed, tree size,\n-                               tree pos, int addressable);\n+\t\t\t       tree record_type, tree size, tree pos,\n+\t\t\t       int packed, int addressable);\n \n /* Returns a PARM_DECL node. PARAM_NAME is the name of the parameter,\n    PARAM_TYPE is its type.  READONLY is true if the parameter is"}, {"sha": "c6bad4351e7e7e156129ec6654648ff4bce3f290", "filename": "gcc/ada/gcc-interface/trans.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Ftrans.c?ref=da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "patch": "@@ -559,8 +559,9 @@ gigi (Node_Id gnat_root, int max_gnat_node, int number_name ATTRIBUTE_UNUSED,\n \n       for (j = 0; j < TARGET_VTABLE_USES_DESCRIPTORS; j++)\n \t{\n-\t  tree field = create_field_decl (NULL_TREE, ptr_void_ftype,\n-\t\t\t\t\t  fdesc_type_node, 0, 0, 0, 1);\n+\t  tree field\n+\t    = create_field_decl (NULL_TREE, ptr_void_ftype, fdesc_type_node,\n+\t\t\t\t NULL_TREE, NULL_TREE, 0, 1);\n \t  TREE_CHAIN (field) = field_list;\n \t  field_list = field;\n \t  null_list = tree_cons (field, null_node, null_list);"}, {"sha": "4b11923db5598e8b12737d27e5460141ba8dabfa", "filename": "gcc/ada/gcc-interface/utils.c", "status": "modified", "additions": 20, "deletions": 18, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7/gcc%2Fada%2Fgcc-interface%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgcc-interface%2Futils.c?ref=da01bfee1aafe6c68c2c21d9d6d77a506c7e52c7", "patch": "@@ -915,9 +915,9 @@ rest_of_record_type_compilation (tree record_type)\n \t      field_name = concat_name (field_name, suffix);\n \t    }\n \n-\t  new_field = create_field_decl (field_name, field_type,\n-\t\t\t\t\t new_record_type, 0,\n-\t\t\t\t\t DECL_SIZE (old_field), pos, 0);\n+\t  new_field\n+\t    = create_field_decl (field_name, field_type, new_record_type,\n+\t\t\t\t DECL_SIZE (old_field), pos, 0, 0);\n \t  TREE_CHAIN (new_field) = TYPE_FIELDS (new_record_type);\n \t  TYPE_FIELDS (new_record_type) = new_field;\n \n@@ -1439,16 +1439,16 @@ aggregate_type_contains_array_p (tree type)\n }\n \n /* Return a FIELD_DECL node.  FIELD_NAME is the field's name, FIELD_TYPE is\n-   its type and RECORD_TYPE is the type of the enclosing record.  PACKED is\n-   1 if the enclosing record is packed, -1 if it has Component_Alignment of\n-   Storage_Unit.  If SIZE is nonzero, it is the specified size of the field.\n-   If POS is nonzero, it is the bit position.  If ADDRESSABLE is nonzero, it\n+   its type and RECORD_TYPE is the type of the enclosing record.  If SIZE is\n+   nonzero, it is the specified size of the field.  If POS is nonzero, it is\n+   the bit position.  PACKED is 1 if the enclosing record is packed, -1 if it\n+   has Component_Alignment of Storage_Unit.  If ADDRESSABLE is nonzero, it\n    means we are allowed to take the address of the field; if it is negative,\n    we should not make a bitfield, which is used by make_aligning_type.  */\n \n tree\n create_field_decl (tree field_name, tree field_type, tree record_type,\n-                   int packed, tree size, tree pos, int addressable)\n+                   tree size, tree pos, int packed, int addressable)\n {\n   tree field_decl = build_decl (input_location,\n \t\t\t\tFIELD_DECL, field_name, field_type);\n@@ -2919,7 +2919,8 @@ make_descriptor_field (const char *name, tree type,\n \t\t       tree rec_type, tree initial)\n {\n   tree field\n-    = create_field_decl (get_identifier (name), type, rec_type, 0, 0, 0, 0);\n+    = create_field_decl (get_identifier (name), type, rec_type, NULL_TREE,\n+\t\t\t NULL_TREE, 0, 0);\n \n   DECL_INITIAL (field) = initial;\n   return field;\n@@ -3311,10 +3312,12 @@ build_unc_object_type (tree template_type, tree object_type, tree name,\n \t\t       bool debug_info_p)\n {\n   tree type = make_node (RECORD_TYPE);\n-  tree template_field = create_field_decl (get_identifier (\"BOUNDS\"),\n-\t\t\t\t\t   template_type, type, 0, 0, 0, 1);\n-  tree array_field = create_field_decl (get_identifier (\"ARRAY\"), object_type,\n-\t\t\t\t\ttype, 0, 0, 0, 1);\n+  tree template_field\n+    = create_field_decl (get_identifier (\"BOUNDS\"), template_type, type,\n+\t\t\t NULL_TREE, NULL_TREE, 0, 1);\n+  tree array_field\n+    = create_field_decl (get_identifier (\"ARRAY\"), object_type, type,\n+\t\t\t NULL_TREE, NULL_TREE, 0, 1);\n \n   TYPE_NAME (type) = name;\n   TYPE_CONTAINS_TEMPLATE_P (type) = 1;\n@@ -4363,8 +4366,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t\t     GET_MODE_BITSIZE (TYPE_MODE (type))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      tree field = create_field_decl (get_identifier (\"OBJ\"), type,\n-\t\t\t\t      rec_type, 1, 0, 0, 0);\n+      tree field = create_field_decl (get_identifier (\"OBJ\"), type, rec_type,\n+\t\t\t\t      NULL_TREE, NULL_TREE, 1, 0);\n \n       TYPE_FIELDS (rec_type) = field;\n       layout_type (rec_type);\n@@ -4380,9 +4383,8 @@ unchecked_convert (tree type, tree expr, bool notrunc_p)\n \t\t\t\tGET_MODE_BITSIZE (TYPE_MODE (etype))))\n     {\n       tree rec_type = make_node (RECORD_TYPE);\n-      tree field\n-\t= create_field_decl (get_identifier (\"OBJ\"), etype, rec_type,\n-\t\t\t     1, 0, 0, 0);\n+      tree field = create_field_decl (get_identifier (\"OBJ\"), etype, rec_type,\n+\t\t\t\t      NULL_TREE, NULL_TREE, 1, 0);\n \n       TYPE_FIELDS (rec_type) = field;\n       layout_type (rec_type);"}]}