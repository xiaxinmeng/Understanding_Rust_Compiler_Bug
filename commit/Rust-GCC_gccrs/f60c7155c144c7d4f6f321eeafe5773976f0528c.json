{"sha": "f60c7155c144c7d4f6f321eeafe5773976f0528c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjYwYzcxNTVjMTQ0YzdkNGY2ZjMyMWVlYWZlNTc3Mzk3NmYwNTI4Yw==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2005-03-03T03:53:29Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2005-03-03T03:53:29Z"}, "message": "Describe special registers SRP and MOF as allocatable registers.\n\n\t* config/cris/cris.c (cris_md_asm_clobbers): New function.\n\t(TARGET_MD_ASM_CLOBBERS): Define to cris_md_asm_clobbers.\n\t(cris_conditional_register_usage): Enable CRIS_MOF_REGNUM if\n\tTARGET_HAS_MUL_INSNS.\n\t(cris_print_operand) <case 'd'>: New case.\n\t<case REG>: Allow CRIS_MOF_REGNUM and CRIS_SRP_REGNUM.\n\t* config/cris/cris.h (CRIS_PC_REGNUM, CRIS_SRP_REGNUM): Don't\n\tdefine.\n\t(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS)\n\t(REG_ALLOC_ORDER): Update for MOF.\n\t(enum reg_class): New members MOF_REGS, GENERAL_REGS and\n\tSPECIAL_REGS.\n\t(GENERAL_REGS): No longer a define of ALL_REGS.\n\t(REGNO_REG_CLASS, REG_CLASS_CONTENTS, REG_CLASS_NAMES)\n\t(PREFERRED_RELOAD_CLASS, REGISTER_NAMES, DBX_REGISTER_NUMBER):\n\tAdjust accordingly.\n\t(CRIS_SPECIAL_REGS_CONTENTS): New macro.\n\t(REG_CLASS_FROM_LETTER): Allocate 'h' and 'x'.\n\t(SECONDARY_RELOAD_CLASS): Define.\n\t(STACK_POINTER_REGNUM): Define as CRIS_SP_REGNUM.\n\t(FRAME_POINTER_REGNUM): Define as CRIS_FP_REGNUM.\n\t(ARG_POINTER_REGNUM): Define as CRIS_AP_REGNUM.\n\t(STATIC_CHAIN_REGNUM): Define as CRIS_STATIC_CHAIN_REGNUM.\n\t(REGISTER_MOVE_COST): Define.\n\t(PIC_OFFSET_TABLE_REGNUM): Define in terms of CRIS_GOT_REGNUM.\n\t* config/cris/cris.md (CRIS_GOT_REGNUM, CRIS_STATIC_CHAIN_REGNUM)\n\t(CRIS_FP_REGNUM, CRIS_SP_REGNUM, CRIS_SRP_REGNUM, CRIS_AP_REGNUM)\n\t(CRIS_MOF_REGNUM): New define_constants.\n\t(\"*movsi_internal\", \"movhi\", \"movqi\", \"movsf\"): Add alternatives for\n\tspecial registers.\n\t(\"reload_inhi\", \"reload_outhi\", \"reload_inqi\",\n\t(\"umulhisi3\", \"umulqihi3\", \"mulsi3\", \"mulqihi3\", \"mulhisi3\")\n\t(\"mulsidi3\", \"umulsidi3\", \"smulsi3_highpart\", \"umulsi3_highpart\"):\n\tAdjust for MOF being properly described as a register.\n\t(indir_to_reg_split): Name this split.  Conditionalize on the\n\tdestination register being a general register.\n\t(movei): Conditionalize on on operands 0 and 1 having the same\n\tregister class.\n\nFrom-SVN: r95823", "tree": {"sha": "79941ea418e91490baa9e14c4e6d7c7af887ba8c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79941ea418e91490baa9e14c4e6d7c7af887ba8c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f60c7155c144c7d4f6f321eeafe5773976f0528c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60c7155c144c7d4f6f321eeafe5773976f0528c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f60c7155c144c7d4f6f321eeafe5773976f0528c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f60c7155c144c7d4f6f321eeafe5773976f0528c/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "768875a86fdf0a487ba662404e04f1898ce88c1e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/768875a86fdf0a487ba662404e04f1898ce88c1e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/768875a86fdf0a487ba662404e04f1898ce88c1e"}], "stats": {"total": 376, "additions": 293, "deletions": 83}, "files": [{"sha": "b89ef0a9046b02b63a597acac72586f592fc7b32", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f60c7155c144c7d4f6f321eeafe5773976f0528c", "patch": "@@ -1,3 +1,45 @@\n+2005-03-03  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\tDescribe special registers SRP and MOF as allocatable registers.\n+\t* config/cris/cris.c (cris_md_asm_clobbers): New function.\n+\t(TARGET_MD_ASM_CLOBBERS): Define to cris_md_asm_clobbers.\n+\t(cris_conditional_register_usage): Enable CRIS_MOF_REGNUM if\n+\tTARGET_HAS_MUL_INSNS.\n+\t(cris_print_operand) <case 'd'>: New case.\n+\t<case REG>: Allow CRIS_MOF_REGNUM and CRIS_SRP_REGNUM.\n+\t* config/cris/cris.h (CRIS_PC_REGNUM, CRIS_SRP_REGNUM): Don't\n+\tdefine.\n+\t(FIRST_PSEUDO_REGISTER, FIXED_REGISTERS, CALL_USED_REGISTERS)\n+\t(REG_ALLOC_ORDER): Update for MOF.\n+\t(enum reg_class): New members MOF_REGS, GENERAL_REGS and\n+\tSPECIAL_REGS.\n+\t(GENERAL_REGS): No longer a define of ALL_REGS.\n+\t(REGNO_REG_CLASS, REG_CLASS_CONTENTS, REG_CLASS_NAMES)\n+\t(PREFERRED_RELOAD_CLASS, REGISTER_NAMES, DBX_REGISTER_NUMBER):\n+\tAdjust accordingly.\n+\t(CRIS_SPECIAL_REGS_CONTENTS): New macro.\n+\t(REG_CLASS_FROM_LETTER): Allocate 'h' and 'x'.\n+\t(SECONDARY_RELOAD_CLASS): Define.\n+\t(STACK_POINTER_REGNUM): Define as CRIS_SP_REGNUM.\n+\t(FRAME_POINTER_REGNUM): Define as CRIS_FP_REGNUM.\n+\t(ARG_POINTER_REGNUM): Define as CRIS_AP_REGNUM.\n+\t(STATIC_CHAIN_REGNUM): Define as CRIS_STATIC_CHAIN_REGNUM.\n+\t(REGISTER_MOVE_COST): Define.\n+\t(PIC_OFFSET_TABLE_REGNUM): Define in terms of CRIS_GOT_REGNUM.\n+\t* config/cris/cris.md (CRIS_GOT_REGNUM, CRIS_STATIC_CHAIN_REGNUM)\n+\t(CRIS_FP_REGNUM, CRIS_SP_REGNUM, CRIS_SRP_REGNUM, CRIS_AP_REGNUM)\n+\t(CRIS_MOF_REGNUM): New define_constants.\n+\t(\"*movsi_internal\", \"movhi\", \"movqi\", \"movsf\"): Add alternatives for\n+\tspecial registers.\n+\t(\"reload_inhi\", \"reload_outhi\", \"reload_inqi\", \n+\t(\"umulhisi3\", \"umulqihi3\", \"mulsi3\", \"mulqihi3\", \"mulhisi3\")\n+\t(\"mulsidi3\", \"umulsidi3\", \"smulsi3_highpart\", \"umulsi3_highpart\"):\n+\tAdjust for MOF being properly described as a register.\n+\t(indir_to_reg_split): Name this split.  Conditionalize on the\n+\tdestination register being a general register.\n+\t(movei): Conditionalize on on operands 0 and 1 having the same\n+\tregister class.\n+\n 2005-03-03  Alan Modra  <amodra@bigpond.net.au>\n \n \tPR target/20277"}, {"sha": "a4c61b41e6194b7739745de99471c2b9a0036a19", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=f60c7155c144c7d4f6f321eeafe5773976f0528c", "patch": "@@ -125,6 +125,7 @@ static bool cris_pass_by_reference (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t    tree, bool);\n static int cris_arg_partial_bytes (CUMULATIVE_ARGS *, enum machine_mode,\n \t\t\t\t   tree, bool);\n+static tree cris_md_asm_clobbers (tree);\n \n /* This is the argument from the \"-max-stack-stackframe=\" option.  */\n const char *cris_max_stackframe_str;\n@@ -196,6 +197,8 @@ int cris_cpu_version = CRIS_DEFAULT_CPU_VERSION;\n #define TARGET_PASS_BY_REFERENCE cris_pass_by_reference\n #undef TARGET_ARG_PARTIAL_BYTES\n #define TARGET_ARG_PARTIAL_BYTES cris_arg_partial_bytes\n+#undef TARGET_MD_ASM_CLOBBERS\n+#define TARGET_MD_ASM_CLOBBERS cris_md_asm_clobbers\n \n struct gcc_target targetm = TARGET_INITIALIZER;\n \n@@ -479,6 +482,9 @@ cris_conditional_register_usage (void)\n   if (flag_pic)\n     fixed_regs[PIC_OFFSET_TABLE_REGNUM]\n       = call_used_regs[PIC_OFFSET_TABLE_REGNUM] = 1;\n+\n+  if (TARGET_HAS_MUL_INSNS)\n+    fixed_regs[CRIS_MOF_REGNUM] = 0;\n }\n \n /* Return current_function_uses_pic_offset_table.  For use in cris.md,\n@@ -1454,6 +1460,16 @@ cris_print_operand (FILE *file, rtx x, int code)\n       fprintf (file, INTVAL (operand) < 0 ? \"adds.w\" : \"addq\");\n       return;\n \n+    case 'd':\n+      /* If this is a GOT symbol, print it as :GOT regardless of -fpic.  */\n+      if (flag_pic && CONSTANT_P (operand) && cris_got_symbol (operand))\n+\t{\n+\t  cris_output_addr_const (file, operand);\n+\t  fprintf (file, \":GOT\");\n+\t  return;\n+\t}\n+      break;\n+\n     case 'D':\n       /* When emitting an sub for the high part of a DImode constant, we\n \t want to use subq for 0 and subs.w for -1.  */\n@@ -1488,7 +1504,9 @@ cris_print_operand (FILE *file, rtx x, int code)\n   switch (GET_CODE (operand))\n     {\n     case REG:\n-      if (REGNO (operand) > 15)\n+      if (REGNO (operand) > 15\n+\t  && REGNO (operand) != CRIS_MOF_REGNUM\n+\t  && REGNO (operand) != CRIS_SRP_REGNUM)\n \tinternal_error (\"internal error: bad register: %d\", REGNO (operand));\n       fprintf (file, \"$%s\", reg_names[REGNO (operand)]);\n       return;\n@@ -3039,6 +3057,16 @@ cris_arg_partial_bytes (CUMULATIVE_ARGS *ca, enum machine_mode mode,\n     return 0;\n }\n \n+/* Worker function for TARGET_MD_ASM_CLOBBERS.  */\n+\n+static tree\n+cris_md_asm_clobbers (tree clobbers)\n+{\n+  return tree_cons (NULL_TREE,\n+\t\t    build_string (strlen (reg_names[CRIS_MOF_REGNUM]),\n+\t\t\t\t  reg_names[CRIS_MOF_REGNUM]),\n+\t\t    clobbers);\n+}\n \n #if 0\n /* Various small functions to replace macros.  Only called from a"}, {"sha": "f1dd5da1d99621e6fc6b3cc17aa03003815b7cf1", "filename": "gcc/config/cris/cris.h", "status": "modified", "additions": 90, "deletions": 33, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=f60c7155c144c7d4f6f321eeafe5773976f0528c", "patch": "@@ -50,12 +50,10 @@ Boston, MA 02111-1307, USA.  */\n #define CRIS_FIRST_ARG_REG 10\n #define CRIS_MAX_ARGS_IN_REGS 4\n \n-/* Other convenience definitions.  */\n-#define CRIS_PC_REGNUM 15\n-#define CRIS_SRP_REGNUM 16\n+/* See also *_REGNUM constants in cris.md.  */\n \n /* Most of the time, we need the index into the register-names array.\n-   When passing debug-info, we need the real register number.  */\n+   When passing debug-info, we need the real hardware register number.  */\n #define CRIS_CANONICAL_SRP_REGNUM (16 + 11)\n #define CRIS_CANONICAL_MOF_REGNUM (16 + 7)\n \n@@ -602,22 +600,22 @@ extern int target_flags;\n \n /* Node: Register Basics */\n \n-/*  We count all 16 non-special registers, SRP and a faked argument\n-    pointer register.  */\n-#define FIRST_PSEUDO_REGISTER (16 + 1 + 1)\n+/*  We count all 16 non-special registers, SRP, a faked argument\n+    pointer register and MOF.  */\n+#define FIRST_PSEUDO_REGISTER (16 + 1 + 1 + 1)\n \n /* For CRIS, these are r15 (pc) and r14 (sp). Register r8 is used as a\n    frame-pointer, but is not fixed.  SRP is not included in general\n    registers and will not be used automatically.  All other special\n    registers are fixed at the moment.  The faked argument pointer register\n    is fixed too.  */\n #define FIXED_REGISTERS \\\n- {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1}\n \n /* Register r9 is used for structure-address, r10-r13 for parameters,\n    r10- for return values.  */\n #define CALL_USED_REGISTERS \\\n- {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1}\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1, 1}\n \n #define CONDITIONAL_REGISTER_USAGE cris_conditional_register_usage ()\n \n@@ -643,7 +641,7 @@ extern int target_flags;\n     Use struct-return address first, since very few functions use\n    structure return values so it is likely to be available.  */\n #define REG_ALLOC_ORDER \\\n- {9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17}\n+ {9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 18, 16, 17}\n \n \n /* Node: Values in Registers */\n@@ -674,27 +672,46 @@ extern int target_flags;\n    class for special registers, and yet another class for the\n    multiply-overflow register in v10; then a class for the return\n    register also makes sense.  */\n-enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n+enum reg_class \n+  {\n+    NO_REGS,\n+    MOF_REGS, SPECIAL_REGS, GENERAL_REGS, ALL_REGS,\n+    LIM_REG_CLASSES\n+  };\n \n #define N_REG_CLASSES (int) LIM_REG_CLASSES\n \n-#define REG_CLASS_NAMES {\"NO_REGS\", \"ALL_REGS\"}\n+#define REG_CLASS_NAMES\t\t\t\t\t\t\t\\\n+  {\"NO_REGS\", \"MOF_REGS\", \"SPECIAL_REGS\", \"GENERAL_REGS\", \"ALL_REGS\"}\n \n-#define GENERAL_REGS ALL_REGS\n+#define CRIS_SPECIAL_REGS_CONTENTS\t\t\t\t\t\\\n+ ((1 << CRIS_SRP_REGNUM) | (1 << CRIS_MOF_REGNUM))\n \n /* Count in the faked argument register in GENERAL_REGS.  Keep out SRP.  */\n-#define REG_CLASS_CONTENTS {{0}, {0x2ffff}}\n-\n-#define REGNO_REG_CLASS(REGNO) GENERAL_REGS\n+#define REG_CLASS_CONTENTS\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+   {0},\t\t\t\t\t\t\\\n+   {1 << CRIS_MOF_REGNUM},\t\t\t\\\n+   {CRIS_SPECIAL_REGS_CONTENTS},\t\t\\\n+   {0x2ffff},\t\t\t\t\t\\\n+   {0x2ffff | CRIS_SPECIAL_REGS_CONTENTS}\t\\\n+  }\n+\n+#define REGNO_REG_CLASS(REGNO)\t\t\t\\\n+  ((REGNO) == CRIS_MOF_REGNUM ? MOF_REGS :\t\\\n+   (REGNO) == CRIS_SRP_REGNUM ? SPECIAL_REGS :\t\\\n+   GENERAL_REGS)\n \n #define BASE_REG_CLASS GENERAL_REGS\n \n #define INDEX_REG_CLASS GENERAL_REGS\n \n-/* Get reg_class from a letter such as appears in the machine\n-   description.  No letters are used, since 'r' is used for any\n-   register.  */\n-#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+#define REG_CLASS_FROM_LETTER(C)\t\t\\\n+  (\t\t\t\t\t\t\\\n+   (C) == 'h' ? MOF_REGS :\t\t\t\\\n+   (C) == 'x' ? SPECIAL_REGS :\t\t\t\\\n+   NO_REGS\t\t\t\t\t\\\n+  )\n \n /* Since it uses reg_renumber, it is safe only once reg_renumber\n    has been allocated, which happens in local-alloc.c.  */\n@@ -710,9 +727,23 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n /* It seems like gcc (2.7.2 and 2.9x of 2000-03-22) may send \"NO_REGS\" as\n    the class for a constant (testcase: __Mul in arit.c).  To avoid forcing\n    out a constant into the constant pool, we will trap this case and\n-   return something a bit more sane.  FIXME: Check if this is a bug.  */\n-#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n- ((CLASS) == NO_REGS ? GENERAL_REGS : (CLASS))\n+   return something a bit more sane.  FIXME: Check if this is a bug.\n+   Beware that we must not \"override\" classes that can be specified as\n+   constraint letters, or else asm operands using them will fail when\n+   they need to be reloaded.  FIXME: Investigate whether that constitutes\n+   a bug.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS)\t\\\n+ ((CLASS) != MOF_REGS\t\t\t\t\\\n+  && (CLASS) != SPECIAL_REGS\t\t\t\\\n+  ? GENERAL_REGS : (CLASS))\n+\n+/* We can't move special registers to and from memory in smaller than\n+   word_mode.  */\n+#define SECONDARY_RELOAD_CLASS(CLASS, MODE, X)\t\t\\\n+  (((CLASS) != SPECIAL_REGS && (CLASS) != MOF_REGS)\t\\\n+   || GET_MODE_SIZE (MODE) == 4\t\t\t\t\\\n+   || GET_CODE (X) != MEM\t\t\t\t\\\n+   ? NO_REGS : GENERAL_REGS)\n \n /* For CRIS, this is always the size of MODE in words,\n    since all registers are the same size.  To use omitted modes in\n@@ -884,17 +915,17 @@ enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n \n /* Node: Frame Registers */\n \n-#define STACK_POINTER_REGNUM 14\n+#define STACK_POINTER_REGNUM CRIS_SP_REGNUM\n \n /* Register used for frame pointer.  This is also the last of the saved\n    registers, when a frame pointer is not used.  */\n-#define FRAME_POINTER_REGNUM 8\n+#define FRAME_POINTER_REGNUM CRIS_FP_REGNUM\n \n /* Faked register, is always eliminated.  We need it to eliminate\n    allocating stack slots for the return address and the frame pointer.  */\n-#define ARG_POINTER_REGNUM 17\n+#define ARG_POINTER_REGNUM CRIS_AP_REGNUM\n \n-#define STATIC_CHAIN_REGNUM 7\n+#define STATIC_CHAIN_REGNUM CRIS_STATIC_CHAIN_REGNUM\n \n \n /* Node: Elimination */\n@@ -1288,8 +1319,32 @@ struct cum_args {int regs;};\n \n /* Node: Costs */\n \n-/* FIXME: Need to define REGISTER_MOVE_COST when more register classes are\n-   introduced.  */\n+/* Can't move to and from a SPECIAL_REGS register, so we have to say\n+   their move cost within that class is higher.  How about 7?  That's 3\n+   for a move to a GENERAL_REGS register, 3 for the move from the\n+   GENERAL_REGS register, and 1 for the increased register pressure.\n+   Also, it's higher than the memory move cost, which is in order.  \n+   We also do this for ALL_REGS, since we don't want that class to be\n+   preferred (even to memory) at all where GENERAL_REGS doesn't fit.\n+   Whenever it's about to be used, it's for SPECIAL_REGS.  If we don't\n+   present a higher cost for ALL_REGS than memory, a SPECIAL_REGS may be\n+   used when a GENERAL_REGS should be used, even if there are call-saved\n+   GENERAL_REGS left to allocate.  This is because the fall-back when\n+   the most preferred register class isn't available, isn't the next\n+   (or next good) wider register class, but the *most widest* register\n+   class.\n+   Give the cost 3 between a special register and a general register,\n+   because we want constraints verified.  */\n+\n+#define REGISTER_MOVE_COST(MODE, FROM, TO)\t\t\\\n+ ((((FROM) == SPECIAL_REGS || (FROM) == MOF_REGS)\t\\\n+   && ((TO) == SPECIAL_REGS || (TO) == MOF_REGS))\t\\\n+  || (FROM) == ALL_REGS\t\t\t\t\t\\\n+  || (TO) == ALL_REGS\t\t\t\t\t\\\n+  ? 7 :\t\t\t\t\t\t\t\\\n+  ((FROM) == SPECIAL_REGS || (FROM) == MOF_REGS\t\t\\\n+   || (TO) == SPECIAL_REGS || (TO) == MOF_REGS)\t\t\\\n+  ? 3 : 2)\n \n /* This isn't strictly correct for v0..3 in buswidth-8bit mode, but\n    should suffice.  */\n@@ -1323,7 +1378,7 @@ struct cum_args {int regs;};\n \n /* Node: PIC */\n \n-#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? 0 : INVALID_REGNUM)\n+#define PIC_OFFSET_TABLE_REGNUM (flag_pic ? CRIS_GOT_REGNUM : INVALID_REGNUM)\n \n #define LEGITIMATE_PIC_OPERAND_P(X) cris_legitimate_pic_operand (X)\n \n@@ -1439,7 +1494,7 @@ struct cum_args {int regs;};\n \n #define REGISTER_NAMES\t\t\t\t\t\\\n  {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\",\t\\\n-  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"pc\", \"srp\", \"faked_ap\"}\n+  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"pc\", \"srp\", \"faked_ap\", \"mof\"}\n \n #define ADDITIONAL_REGISTER_NAMES \\\n  {{\"r14\", 14}, {\"r15\", 15}}\n@@ -1525,8 +1580,10 @@ struct cum_args {int regs;};\n \n /* Node: All Debuggers */\n \n-#define DBX_REGISTER_NUMBER(REGNO) \\\n- ((REGNO) == CRIS_SRP_REGNUM ? CRIS_CANONICAL_SRP_REGNUM : (REGNO))\n+#define DBX_REGISTER_NUMBER(REGNO)\t\t\t\t\\\n+ ((REGNO) == CRIS_SRP_REGNUM ? CRIS_CANONICAL_SRP_REGNUM :\t\\\n+  (REGNO) == CRIS_MOF_REGNUM ? CRIS_CANONICAL_MOF_REGNUM :\t\\\n+ (REGNO))\n \n /* FIXME: Investigate DEBUGGER_AUTO_OFFSET, DEBUGGER_ARG_OFFSET.  */\n "}, {"sha": "0a9d41912aa36b91f50c7e06ba7cd3f37a71dce6", "filename": "gcc/config/cris/cris.md", "status": "modified", "additions": 132, "deletions": 49, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f60c7155c144c7d4f6f321eeafe5773976f0528c/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=f60c7155c144c7d4f6f321eeafe5773976f0528c", "patch": "@@ -59,6 +59,18 @@\n ;; 0 PLT reference from call expansion: operand 0 is the address,\n ;;   the mode is VOIDmode.  Always wrapped in CONST.\n \n+\n+;; Register numbers.\n+(define_constants\n+  [(CRIS_GOT_REGNUM 0)\n+   (CRIS_STATIC_CHAIN_REGNUM 7)\n+   (CRIS_FP_REGNUM 8)\n+   (CRIS_SP_REGNUM 14)\n+   (CRIS_SRP_REGNUM 16)\n+   (CRIS_AP_REGNUM 17)\n+   (CRIS_MOF_REGNUM 18)]\n+)\n+\n ;; We need an attribute to define whether an instruction can be put in\n ;; a branch-delay slot or not, and whether it has a delay slot.\n ;;\n@@ -994,11 +1006,11 @@\n \n (define_insn \"*movsi_internal\"\n   [(set\n-    (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,g,r,r,r,g\")\n+    (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,g,r,r, r,g,rQ>,x,  m,x\")\n     (match_operand:SI 1\n     ;; FIXME: We want to put S last, but apparently g matches S.\n     ;; It's a bug: an S is not a general_operand and shouldn't match g.\n-     \"cris_general_operand_or_gotless_symbol\"   \"r,Q>,M,M, I,r, M,n,!S,g,r\"))]\n+     \"cris_general_operand_or_gotless_symbol\"   \"r,Q>,M,M, I,r, M,n,!S,g,r,x,  rQ>,x,gi\"))]\n   \"\"\n   \"*\n {\n@@ -1014,6 +1026,12 @@\n     case 10:\n       return \\\"move.d %1,%0\\\";\n \n+    case 11:\n+    case 12:\n+    case 13:\n+    case 14:\n+      return \\\"move %d1,%0\\\";\n+\n     case 2:\n     case 3:\n     case 6:\n@@ -1059,7 +1077,8 @@\n       return \\\"BOGUS: %1 to %0\\\";\n     }\n }\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,no,no,no\")])\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,no,no,no,yes,yes,no,no\")\n+   (set_attr \"cc\" \"*,*,*,*,*,*,*,*,*,*,*,none,none,none,none\")])\n \f\n ;; Extend operations with side-effect from mem to register, using\n ;; MOVS/MOVU.  These are from mem to register only.\n@@ -1207,8 +1226,8 @@\n \n (define_insn \"movhi\"\n   [(set\n-    (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,r,r,r,g,g,r\")\n-    (match_operand:HI 1 \"general_operand\"\t\"r,Q>,M,M, I,r, L,O,n,M,r,g\"))]\n+    (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r, r,Q>,r,Q>,r,r,r,g,g,r,r,x\")\n+    (match_operand:HI 1 \"general_operand\"\t\"r,Q>,M,M, I,r, L,O,n,M,r,g,x,r\"))]\n   \"\"\n   \"*\n {\n@@ -1220,6 +1239,9 @@\n     case 10:\n     case 11:\n       return \\\"move.w %1,%0\\\";\n+    case 12:\n+    case 13:\n+      return \\\"move %1,%0\\\";\n     case 2:\n     case 3:\n     case 9:\n@@ -1241,11 +1263,8 @@\n       return \\\"BOGUS: %1 to %0\\\";\n   }\n }\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,yes,no,no,no,no\")\n-   (set (attr \"cc\")\n-\t(if_then_else (eq_attr \"alternative\" \"7\")\n-\t\t      (const_string \"clobber\")\n-\t\t      (const_string \"normal\")))])\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,yes,no,no,no,no,yes,yes\")\n+   (set_attr \"cc\" \"*,*,none,none,*,none,*,clobber,*,none,none,*,none,none\")])\n \n (define_insn \"movstricthi\"\n   [(set\n@@ -1263,10 +1282,26 @@\n    move.w %1,%0\n    move.w %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no\")])\n+\n+(define_expand \"reload_inhi\"\n+  [(set (match_operand:HI 2 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"memory_operand\" \"m\"))\n+   (set (match_operand:HI 0 \"register_operand\" \"=x\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outhi\"\n+  [(set (match_operand:HI 2 \"register_operand\" \"=r\")\n+\t(match_operand:HI 1 \"register_operand\" \"x\"))\n+   (set (match_operand:HI 0 \"memory_operand\" \"=m\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"\")\n \f\n (define_insn \"movqi\"\n-  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,Q>,r, r,Q>,r,g,g,r,r\")\n-\t(match_operand:QI 1 \"general_operand\"\t    \"r,r, Q>,M,M, I,M,r,O,g\"))]\n+  [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,Q>,r, r,Q>,r,g,g,r,r,r,x\")\n+\t(match_operand:QI 1 \"general_operand\"\t    \"r,r, Q>,M,M, I,M,r,O,g,x,r\"))]\n   \"\"\n   \"@\n    move.b %1,%0\n@@ -1278,12 +1313,11 @@\n    clear.b %0\n    move.b %1,%0\n    moveq %b1,%0\n-   move.b %1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,yes,no\")\n-   (set (attr \"cc\")\n-\t(if_then_else (eq_attr \"alternative\" \"8\")\n-\t\t      (const_string \"clobber\")\n-\t\t      (const_string \"normal\")))])\n+   move.b %1,%0\n+   move %1,%0\n+   move %1,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,yes,no,no,yes,no,yes,yes\")\n+   (set_attr \"cc\" \"*,*,*,*,*,*,*,*,clobber,*,none,none\")])\n \n (define_insn \"movstrictqi\"\n   [(set (strict_low_part\n@@ -1301,14 +1335,30 @@\n    move.b %1,%0\"\n   [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no\")])\n \n+(define_expand \"reload_inqi\"\n+  [(set (match_operand:QI 2 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"memory_operand\" \"m\"))\n+   (set (match_operand:QI 0 \"register_operand\" \"=x\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"reload_outqi\"\n+  [(set (match_operand:QI 2 \"register_operand\" \"=r\")\n+\t(match_operand:QI 1 \"register_operand\" \"x\"))\n+   (set (match_operand:QI 0 \"memory_operand\" \"=m\")\n+\t(match_dup 2))]\n+  \"\"\n+  \"\")\n+\n ;; The valid \"quick\" bit-patterns are, except for 0.0, denormalized\n ;; values REALLY close to 0, and some NaN:s (I think; their exponent is\n ;; all ones); the worthwhile one is \"0.0\".\n ;; It will use clear, so we know ALL types of immediate 0 never change cc.\n \n (define_insn \"movsf\"\n-  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,Q>,r, r,Q>,g,g,r\")\n-\t(match_operand:SF 1 \"general_operand\"\t    \"r,r, Q>,G,G, G,r,g\"))]\n+  [(set (match_operand:SF 0 \"nonimmediate_operand\" \"=r,Q>,r, r,Q>,g,g,r,r,x,Q>,m,x, x\")\n+\t(match_operand:SF 1 \"general_operand\"       \"r,r, Q>,G,G, G,r,g,x,r,x, x,Q>,g\"))]\n   \"\"\n   \"@\n    move.d %1,%0\n@@ -1318,8 +1368,14 @@\n    clear.d %0\n    clear.d %0\n    move.d %1,%0\n-   move.d %1,%0\"\n-  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no\")])\n+   move.d %1,%0\n+   move %1,%0\n+   move %1,%0\n+   move %1,%0\n+   move %1,%0\n+   move %1,%0\n+   move %1,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,yes,yes,yes,no,no,no,yes,yes,yes,no,yes,no\")])\n \f\n \n ;; Sign- and zero-extend insns with standard names.\n@@ -2472,7 +2528,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI\n \t (zero_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+\t (zero_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!mulu.w %2,%0\"\n   [(set (attr \"slottable\")\n@@ -2486,7 +2543,8 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI\n \t (zero_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+\t (zero_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!mulu.b %2,%0\"\n   [(set (attr \"slottable\")\n@@ -2505,7 +2563,8 @@\n (define_insn \"mulsi3\"\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI (match_operand:SI 1 \"register_operand\" \"%0\")\n-\t\t (match_operand:SI 2 \"register_operand\" \"r\")))]\n+\t\t (match_operand:SI 2 \"register_operand\" \"r\")))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!muls.d %2,%0\"\n   [(set (attr \"slottable\")\n@@ -2523,7 +2582,8 @@\n   [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n \t(mult:HI\n \t (sign_extend:HI (match_operand:QI 1 \"register_operand\" \"%0\"))\n-\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))]\n+\t (sign_extend:HI (match_operand:QI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!muls.b %2,%0\"\n   [(set (attr \"slottable\")\n@@ -2536,7 +2596,8 @@\n   [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n \t(mult:SI\n \t (sign_extend:SI (match_operand:HI 1 \"register_operand\" \"%0\"))\n-\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))]\n+\t (sign_extend:SI (match_operand:HI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!muls.w %2,%0\"\n   [(set (attr \"slottable\")\n@@ -2556,50 +2617,69 @@\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI\n \t (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+\t (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!muls.d %2,%M0\\;move $mof,%H0\")\n \n (define_insn \"umulsidi3\"\n   [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n \t(mult:DI\n \t (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0\"))\n-\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))]\n+\t (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r\"))))\n+   (clobber (match_scratch:SI 3 \"=h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n   \"%!mulu.d %2,%M0\\;move $mof,%H0\")\n \n-;; This pattern would probably not be needed if we add \"mof\" in its own\n-;; register class (and open a can of worms about /not/ pairing it with a\n-;; \"normal\" register).  Having multiple register classes here, and\n-;; applicable to the v10 variant only, seems worse than having these two\n-;; patterns with multi-insn contents for now (may change; having a free\n-;; call-clobbered register is worth some trouble).\n+;; These two patterns may be expressible by other means, perhaps by making\n+;; [u]?mulsidi3 a define_expand.\n+\n+;; Due to register allocation braindamage, the clobber 1,2 alternatives\n+;; cause a move into the clobbered register *before* the insn, then\n+;; after the insn, mof is moved too, rather than the clobber assigned\n+;; the last mof target.  This became apparent when making MOF and SRP\n+;; visible registers, with the necessary tweak to smulsi3_highpart.\n+;; Because these patterns are used in division by constants, that damage\n+;; is visible (ipps regression tests).  Therefore the last two\n+;; alternatives, \"helping\" reload to avoid an unnecessary move, but\n+;; punished by force of one \"?\".  Check code from \"int d (int a) {return\n+;; a / 1000;}\" and unsigned.  FIXME: Comment above was for 3.2, revisit.\n \n (define_insn \"smulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m\")\n+  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=h,h,?r,?r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,r\"))\n-\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n+\t   (sign_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r,0,r\"))\n+\t   (sign_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r,r,0\")))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=X,1,1\"))]\n+   (clobber (match_scratch:SI 3 \"=1,2,h,h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n-  \"%!muls.d %2,%1\\;move $mof,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n+  \"@\n+   %!muls.d %2,%1\n+   .error 'untested assembly generated by GCC (smulsi3_highpart): muls.d %1,%2'\n+   %!muls.d %2,%1\\;move $mof,%0\n+   %!muls.d %1,%2\\;move $mof,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,no,no\")\n+   (set_attr \"cc\" \"clobber\")])\n \n (define_insn \"umulsi3_highpart\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,r,m\")\n+  [(set (match_operand:SI 0 \"register_operand\" \"=h,h,?r,?r\")\n \t(truncate:SI\n \t (lshiftrt:DI\n \t  (mult:DI\n-\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"%0,r,r\"))\n-\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r,r\")))\n+\t   (zero_extend:DI (match_operand:SI 1 \"register_operand\" \"r,r,0,r\"))\n+\t   (zero_extend:DI (match_operand:SI 2 \"register_operand\" \"r,r,r,0\")))\n \t  (const_int 32))))\n-   (clobber (match_scratch:SI 3 \"=X,1,1\"))]\n+   (clobber (match_scratch:SI 3 \"=1,2,h,h\"))]\n   \"TARGET_HAS_MUL_INSNS\"\n-  \"%!mulu.d %2,%1\\;move $mof,%0\"\n-  [(set_attr \"cc\" \"clobber\")])\n+  \"@\n+   %!mulu.d %2,%1\n+   .error 'untested assembly generated by GCC (umulsi3_highpart): mulu.d %1,%2'\n+   %!mulu.d %2,%1\\;move $mof,%0\n+   %!mulu.d %1,%2\\;move $mof,%0\"\n+  [(set_attr \"slottable\" \"yes,yes,no,no\")\n+   (set_attr \"cc\" \"clobber\")])\n \f\n ;; Divide and modulus instructions.  CRIS only has a step instruction.\n \n@@ -4651,14 +4731,15 @@\n ;; 2001-08-24, unwind-dw2-fde.c, _Unwind_Find_FDE ICE in\n ;; cselib_invalidate_regno.\n \n-(define_split\n+(define_split ; indir_to_reg_split\n   [(set (match_operand 0 \"register_operand\" \"\")\n \t(match_operand 1 \"indirect_operand\" \"\"))]\n   \"reload_completed\n    && REG_P (operands[0])\n    && GET_MODE_SIZE (GET_MODE (operands[0])) <= UNITS_PER_WORD\n    && (GET_CODE (XEXP (operands[1], 0)) == MEM\n-       || CONSTANT_P (XEXP (operands[1], 0)))\"\n+       || CONSTANT_P (XEXP (operands[1], 0)))\n+   && REGNO (operands[0]) < CRIS_LAST_GENERAL_REGISTER\"\n   [(set (match_dup 2) (match_dup 4))\n    (set (match_dup 0) (match_dup 3))]\n   \"operands[2] = gen_rtx_REG (Pmode, REGNO (operands[0]));\n@@ -4993,6 +5074,8 @@\n    (set (match_operand 2 \"register_operand\" \"\")\n \t(match_operator 3 \"cris_mem_op\" [(match_dup 0)]))]\n   \"REGNO (operands[0]) == REGNO (operands[2])\n+   && (REGNO_REG_CLASS (REGNO (operands[0]))\n+       == REGNO_REG_CLASS (REGNO (operands[1])))\n    && GET_MODE_SIZE (GET_MODE (operands[2])) <= UNITS_PER_WORD\"\n   [(set (match_dup 2) (match_dup 4))]\n   \"operands[4] = replace_equiv_address (operands[3], operands[1]);\")"}]}