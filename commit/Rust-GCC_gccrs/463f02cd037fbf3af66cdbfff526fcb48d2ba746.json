{"sha": "463f02cd037fbf3af66cdbfff526fcb48d2ba746", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDYzZjAyY2QwMzdmYmYzYWY2NmNkYmZmZjUyNmZjYjQ4ZDJiYTc0Ng==", "commit": {"author": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2003-02-24T02:44:02Z"}, "committer": {"name": "Kaz Kojima", "email": "kkojima@gcc.gnu.org", "date": "2003-02-24T02:44:02Z"}, "message": "sh.c (TARGET_HAVE_TLS): Conditionally define.\n\n\t* config/sh/sh.c (TARGET_HAVE_TLS): Conditionally define.\n\t(prepare_move_operands): Handle TLS operands.\n\t(tls_symbolic_operand): New.\n\t(nonpic_symbol_mentioned_p): Handle TLS UNSPECs.\n\t(legitimize_pic_address): Do nothing for the TLS symbol.\n\t(sh_encode_section_info): Handle TLS case.\n\t(sh_strip_name_encoding): Drop TLS encoding.\n\t* config/sh/sh-protos.h (tls_symbolic_operand): Add prototype.\n\t* config/sh/sh.h (SH_TLS_ENCODING): Define.\n\t(TLS_SYMNAME_P, STRIP_TLS_ENCODING): Likewise.\n\t(ASM_OUTPUT_LABELREF): Drop TLS encoding.\n\t(OUTPUT_ADDR_CONST_EXTRA): Handle TLS UNSPECs.\n\t* config/sh/sh.md: Define TLS UNSPEC constants.\n\t(type): Add tls_load.\n\t(\"tls_global_dynamic\", \"tls_local_dynamic\"): New insns.\n\t(\"sym2DTPOFF\", \"symDTPOFF2reg\", \"sym2GOTTPOFF\"): New expanders.\n\t(\"tls_initial_exec\"): New insn.\n\t(\"sym2TPOFF\", \"symTPOFF2reg\"): New expanders.\n\t(\"load_gbr\"): New insn.\n\n\t* configure.in (HAVE_AS_TLS): Add sh-*-* and sh[34]*-*-* cases.\n        * configure: Regenerate.\n\nFrom-SVN: r63353", "tree": {"sha": "553894bde43b663f56ac150a268af18125866500", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/553894bde43b663f56ac150a268af18125866500"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/463f02cd037fbf3af66cdbfff526fcb48d2ba746", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/463f02cd037fbf3af66cdbfff526fcb48d2ba746", "html_url": "https://github.com/Rust-GCC/gccrs/commit/463f02cd037fbf3af66cdbfff526fcb48d2ba746", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/463f02cd037fbf3af66cdbfff526fcb48d2ba746/comments", "author": null, "committer": null, "parents": [{"sha": "cf88ede3d283f7ccab57c921204f855bb5b283a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cf88ede3d283f7ccab57c921204f855bb5b283a4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cf88ede3d283f7ccab57c921204f855bb5b283a4"}], "stats": {"total": 365, "additions": 363, "deletions": 2}, "files": [{"sha": "2efa9116bd18c2fc5f2da6b952aeef093eb0d4a2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=463f02cd037fbf3af66cdbfff526fcb48d2ba746", "patch": "@@ -1,3 +1,28 @@\n+2003-02-24  Kaz Kojima  <kkojima@gcc.gnu.org>\n+\n+\t* config/sh/sh.c (TARGET_HAVE_TLS): Conditionally define.\n+\t(prepare_move_operands): Handle TLS operands.\n+\t(tls_symbolic_operand): New.\n+\t(nonpic_symbol_mentioned_p): Handle TLS UNSPECs.\n+\t(legitimize_pic_address): Do nothing for the TLS symbol.\n+\t(sh_encode_section_info): Handle TLS case.\n+\t(sh_strip_name_encoding): Drop TLS encoding.\n+\t* config/sh/sh-protos.h (tls_symbolic_operand): Add prototype.\n+\t* config/sh/sh.h (SH_TLS_ENCODING): Define.\n+\t(TLS_SYMNAME_P, STRIP_TLS_ENCODING): Likewise.\n+\t(ASM_OUTPUT_LABELREF): Drop TLS encoding.\n+\t(OUTPUT_ADDR_CONST_EXTRA): Handle TLS UNSPECs.\n+\t* config/sh/sh.md: Define TLS UNSPEC constants.\n+\t(type): Add tls_load.\n+\t(\"tls_global_dynamic\", \"tls_local_dynamic\"): New insns.\n+\t(\"sym2DTPOFF\", \"symDTPOFF2reg\", \"sym2GOTTPOFF\"): New expanders.\n+\t(\"tls_initial_exec\"): New insn.\n+\t(\"sym2TPOFF\", \"symTPOFF2reg\"): New expanders.\n+\t(\"load_gbr\"): New insn.\n+\n+\t* configure.in (HAVE_AS_TLS): Add sh-*-* and sh[34]*-*-* cases.\n+        * configure: Regenerate.\n+\n 2003-02-24  Alan Modra  <amodra@bigpond.net.au>\n \n \t* calls.c (store_one_arg): Revert 1999-02-16 change.  Revert"}, {"sha": "f7758a15992c6a5441ef05dd3bb8190c22fe2142", "filename": "gcc/config/sh/sh-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh-protos.h?ref=463f02cd037fbf3af66cdbfff526fcb48d2ba746", "patch": "@@ -75,6 +75,7 @@ extern void fixup_addr_diff_vecs PARAMS ((rtx));\n extern int get_dest_uid PARAMS ((rtx, int));\n extern void final_prescan_insn PARAMS ((rtx, rtx *, int));\n extern int symbol_ref_operand PARAMS ((rtx, enum machine_mode));\n+extern int tls_symbolic_operand PARAMS ((rtx, enum machine_mode));\n extern int system_reg_operand PARAMS ((rtx, enum machine_mode));\n extern int general_movsrc_operand PARAMS ((rtx, enum machine_mode));\n extern int general_movdst_operand PARAMS ((rtx, enum machine_mode));"}, {"sha": "3c7549b29b51a0c52afc41be0926332ecd8d0b4d", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 166, "deletions": 1, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=463f02cd037fbf3af66cdbfff526fcb48d2ba746", "patch": "@@ -280,6 +280,11 @@ static int sh_address_cost PARAMS ((rtx));\n #undef TARGET_ADDRESS_COST\n #define TARGET_ADDRESS_COST sh_address_cost\n \n+#ifdef HAVE_AS_TLS\n+#undef TARGET_HAVE_TLS\n+#define TARGET_HAVE_TLS true\n+#endif\n+\n struct gcc_target targetm = TARGET_INITIALIZER;\n \f\n /* Print the operand address in x to the stream.  */\n@@ -708,7 +713,10 @@ prepare_move_operands (operands, mode)\n      rtx operands[];\n      enum machine_mode mode;\n {\n-  if ((mode == SImode || mode == DImode) && flag_pic)\n+  if ((mode == SImode || mode == DImode)\n+      && flag_pic\n+      && ! ((mode == Pmode || mode == ptr_mode)\n+\t    && tls_symbolic_operand (operands[1], Pmode) != 0))\n     {\n       rtx temp;\n       if (SYMBOLIC_CONST_P (operands[1]))\n@@ -758,6 +766,73 @@ prepare_move_operands (operands, mode)\n \toperands[1] = copy_to_mode_reg (mode, operands[1]);\n     }\n \n+  if (mode == Pmode || mode == ptr_mode)\n+    {\n+      rtx op0, op1;\n+      enum tls_model tls_kind;\n+\n+      op0 = operands[0];\n+      op1 = operands[1];\n+      if ((tls_kind = tls_symbolic_operand (op1, Pmode)))\n+\t{\n+\t  rtx tga_op1, tga_ret, tmp, tmp2;\n+\n+\t  \n+\t  switch (tls_kind)\n+\t    {\n+\t    case TLS_MODEL_GLOBAL_DYNAMIC:\n+\t      tga_ret = gen_rtx_REG (Pmode, R0_REG);\n+\t      emit_insn (gen_tls_global_dynamic (tga_ret, op1));\n+\t      op1 = tga_ret;\n+\t      break;\n+\n+\t    case TLS_MODEL_LOCAL_DYNAMIC:\n+\t      tga_ret = gen_rtx_REG (Pmode, R0_REG);\n+\t      emit_insn (gen_tls_local_dynamic (tga_ret, op1));\n+\n+\t      tmp = gen_reg_rtx (Pmode);\n+\t      emit_move_insn (tmp, tga_ret);\n+\n+\t      if (register_operand (op0, Pmode))\n+\t\ttmp2 = op0;\n+\t      else\n+\t\ttmp2 = gen_reg_rtx (Pmode);\n+\n+\t      emit_insn (gen_symDTPOFF2reg (tmp2, op1, tmp));\n+\t      op1 = tmp2;\n+\t      break;\n+\n+\t    case TLS_MODEL_INITIAL_EXEC:\n+\t      if (! flag_pic)\n+\t\temit_insn (gen_GOTaddr2picreg ());\n+\t      tga_op1 = gen_reg_rtx (Pmode);\n+\t      tmp = gen_sym2GOTTPOFF (op1);\n+\t      emit_insn (gen_tls_initial_exec (tga_op1, tmp));\n+\t      op1 = tga_op1;\n+\t      break;\n+\n+\t    case TLS_MODEL_LOCAL_EXEC:\n+\t      tmp2 = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_load_gbr (tmp2));\n+\t      tmp = gen_reg_rtx (Pmode);\n+\t      emit_insn (gen_symTPOFF2reg (tmp, op1));\n+\t      RTX_UNCHANGING_P (tmp) = 1;\n+\n+\t      if (register_operand (op0, Pmode))\n+\t\top1 = op0;\n+\t      else\n+\t\top1 = gen_reg_rtx (Pmode);\n+\n+\t      emit_insn (gen_addsi3 (op1, tmp, tmp2));\n+\t      break;\n+\n+\t    default:\n+\t      abort ();\n+\t    }\n+\t  operands[1] = op1;\n+\t}\n+    }\n+\n   return 0;\n }\n \n@@ -6429,6 +6504,36 @@ symbol_ref_operand (op, mode)\n   return (GET_CODE (op) == SYMBOL_REF);\n }\n \n+/* Return the TLS type for TLS symbols, 0 for otherwise.  */\n+int\n+tls_symbolic_operand (op, mode)\n+     rtx op;\n+     enum machine_mode mode ATTRIBUTE_UNUSED;\n+{\n+  const char *str;\n+\n+  if (GET_CODE (op) != SYMBOL_REF)\n+    return 0;\n+\n+  str = XSTR (op, 0);\n+  STRIP_DATALABEL_ENCODING(str, str);  \n+  if (! TLS_SYMNAME_P (str))\n+    return 0;\n+\n+  switch (str[1])\n+    {\n+    case 'G':\n+      return TLS_MODEL_GLOBAL_DYNAMIC;\n+    case 'L':\n+      return TLS_MODEL_LOCAL_DYNAMIC;\n+    case 'i':\n+      return TLS_MODEL_INITIAL_EXEC;\n+    case 'l':\n+      return TLS_MODEL_LOCAL_EXEC;\n+    }\n+  return 0;\n+}\n+\n int\n commutative_float_operator (op, mode)\n      rtx op;\n@@ -7174,6 +7279,8 @@ nonpic_symbol_mentioned_p (x)\n \t  || XINT (x, 1) == UNSPEC_GOT\n \t  || XINT (x, 1) == UNSPEC_GOTOFF\n \t  || XINT (x, 1) == UNSPEC_GOTPLT\n+\t  || XINT (x, 1) == UNSPEC_GOTTPOFF\n+\t  || XINT (x, 1) == UNSPEC_DTPOFF\n \t  || XINT (x, 1) == UNSPEC_PLT))\n       return 0;\n \n@@ -7203,6 +7310,9 @@ legitimize_pic_address (orig, mode, reg)\n      enum machine_mode mode ATTRIBUTE_UNUSED;\n      rtx reg;\n {\n+  if (tls_symbolic_operand (orig, Pmode))\n+    return orig;\n+\n   if (GET_CODE (orig) == LABEL_REF\n       || (GET_CODE (orig) == SYMBOL_REF\n \t  && (CONSTANT_POOL_ADDRESS_P (orig)\n@@ -7555,6 +7665,60 @@ sh_encode_section_info (decl, first)\n   if (flag_pic)\n     SYMBOL_REF_FLAG (symbol) = (*targetm.binds_local_p) (decl);\n \n+  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL (decl))\n+    {\n+      const char *symbol_str, *orig_str;\n+      bool is_local;\n+      enum tls_model kind;\n+      char encoding;\n+      char *newstr;\n+      size_t len, dlen;\n+\n+      orig_str = XSTR (symbol, 0);\n+      is_local = (*targetm.binds_local_p) (decl);\n+\n+      if (! flag_pic)\n+\t{\n+\t  if (is_local)\n+\t    kind = TLS_MODEL_LOCAL_EXEC;\n+\t  else\n+\t    kind = TLS_MODEL_INITIAL_EXEC;\n+\t}\n+      else if (is_local)\n+\tkind = TLS_MODEL_LOCAL_DYNAMIC;\n+      else\n+\tkind = TLS_MODEL_GLOBAL_DYNAMIC;\n+      if (kind < flag_tls_default)\n+\tkind = flag_tls_default;\n+\n+      STRIP_DATALABEL_ENCODING (symbol_str, orig_str);\n+      dlen = symbol_str - orig_str;\n+\n+      encoding = \" GLil\"[kind];\n+      if (TLS_SYMNAME_P (symbol_str))\n+\t{\n+\t  if (encoding == symbol_str[1])\n+\t    return;\n+\t  /* Handle the changes from initial-exec to local-exec and\n+\t     from global-dynamic to local-dynamic.  */\n+\t  if ((encoding == 'l' && symbol_str[1] == 'i')\n+\t      || (encoding == 'L' && symbol_str[1] == 'G'))\n+\t    symbol_str += 2;\n+\t  else\n+\t    abort ();\n+\t}\n+\n+      len = strlen (symbol_str);\n+      newstr = alloca (dlen + len + 3);\n+      if (dlen)\n+\tmemcpy (newstr, orig_str, dlen);\n+      newstr[dlen + 0] = SH_TLS_ENCODING[0];\n+      newstr[dlen + 1] = encoding;\n+      memcpy (newstr + dlen + 2, symbol_str, len + 1);\n+\n+      XSTR (symbol, 0) = ggc_alloc_string (newstr, dlen + len + 2);\n+    }\n+\n   if (TARGET_SH5 && first && TREE_CODE (decl) != FUNCTION_DECL)\n     XEXP (rtl, 0) = gen_datalabel_ref (symbol);\n }\n@@ -7566,6 +7730,7 @@ sh_strip_name_encoding (str)\n      const char *str;\n {\n   STRIP_DATALABEL_ENCODING (str, str);\n+  STRIP_TLS_ENCODING (str, str);\n   str += *str == '*';\n   return str;\n }"}, {"sha": "82325b89d81dd37013ab0f33031ec7432d939999", "filename": "gcc/config/sh/sh.h", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.h?ref=463f02cd037fbf3af66cdbfff526fcb48d2ba746", "patch": "@@ -2752,6 +2752,20 @@ while (0)\n ((GET_CODE (X) == SYMBOL_REF || GET_CODE (X) == LABEL_REF)\t\\\n   && nonpic_symbol_mentioned_p (X))\n \f\n+/* TLS.  */\n+\n+/* The prefix used to mark SYMBOL_REFs that refer to TLS symbols.  */\n+#define SH_TLS_ENCODING \"@\"\n+\n+/* Return true if SYM_NAME starts with SH_TLS_ENCODING.  */\n+#define TLS_SYMNAME_P(SYM_NAME) \\\n+  ((SYM_NAME)[0] == SH_TLS_ENCODING[0])\n+\n+/* Skip an optional SH_TLS_ENCODING in the beginning of SYM_NAME.  */\n+#define STRIP_TLS_ENCODING(VAR, SYM_NAME) \\\n+  (VAR) = (SYM_NAME) + (TLS_SYMNAME_P (SYM_NAME) \\\n+\t\t\t? strlen (SH_TLS_ENCODING) + 1 : 0)\n+\f\n /* Compute extra cost of moving data between one register class\n    and another.  */\n \n@@ -2915,6 +2929,7 @@ while (0)\n       const char * lname;\t\t\t\t\\\n \t\t\t\t\t\t\t\\\n       STRIP_DATALABEL_ENCODING (lname, (NAME));\t\t\\\n+      STRIP_TLS_ENCODING (lname, lname);\t\t\\\n       if (lname[0] == '*')\t\t\t\t\\\n \tfputs (lname + 1, (FILE));\t\t\t\\\n       else\t\t\t\t\t\t\\\n@@ -3053,6 +3068,18 @@ while (0)\n \t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n \t    fputs (\"@GOTPLT\", (STREAM));\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_DTPOFF:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@DTPOFF\", (STREAM));\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_GOTTPOFF:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@GOTTPOFF\", (STREAM));\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n+\t  case UNSPEC_TPOFF:\t\t\t\t\t\t\\\n+\t    output_addr_const ((STREAM), XVECEXP ((X), 0, 0));\t\t\\\n+\t    fputs (\"@TPOFF\", (STREAM));\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\t\\\n \t  case UNSPEC_CALLER:\t\t\t\t\t\t\\\n \t    {\t\t\t\t\t\t\t\t\\\n \t      char name[32];\t\t\t\t\t\t\\"}, {"sha": "f26d2b37e50af2aa4e835274a512e8660078eb26", "filename": "gcc/config/sh/sh.md", "status": "modified", "additions": 144, "deletions": 1, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/463f02cd037fbf3af66cdbfff526fcb48d2ba746/gcc%2Fconfig%2Fsh%2Fsh.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.md?ref=463f02cd037fbf3af66cdbfff526fcb48d2ba746", "patch": "@@ -136,6 +136,12 @@\n   (UNSPEC_NSB\t\t17)\n   (UNSPEC_ALLOCO\t18)\n   (UNSPEC_EH_RETURN\t19)\n+  (UNSPEC_TLSGD\t\t20)\n+  (UNSPEC_TLSLDM\t21)\n+  (UNSPEC_TLSIE\t\t22)\n+  (UNSPEC_DTPOFF\t23)\n+  (UNSPEC_GOTTPOFF\t24)\n+  (UNSPEC_TPOFF\t\t25)\n \n   ;; These are used with unspec_volatile.\n   (UNSPECV_BLOCKAGE\t0)\n@@ -211,6 +217,7 @@\n ;; ftrc_s\tfix_truncsfsi2_i4\n ;; dfdiv\tdouble precision floating point divide (or square root)\n ;; cwb\t\tic_invalidate_line_i\n+;; tls_load     load TLS related address \n ;; arith_media\tSHmedia arithmetic, logical, and shift instructions\n ;; cbranch_media SHmedia conditional branch instructions\n ;; cmp_media\tSHmedia compare instructions\n@@ -241,7 +248,7 @@\n ;; nil\t\tno-op move, will be deleted.\n \n (define_attr \"type\"\n- \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n+ \"mt_group,cbranch,jump,jump_ind,arith,arith3,arith3b,dyn_shift,load,load_si,fload,store,move,fmove,smpy,dmpy,return,pload,prset,pstore,prget,pcload,pcload_si,pcfload,rte,sfunc,call,fp,fdiv,ftrc_s,dfp_arith,dfp_cmp,dfp_conv,dfdiv,gp_fpul,fpul_gp,mac_gp,mem_fpscr,gp_fpscr,cwb,tls_load,arith_media,cbranch_media,cmp_media,dfdiv_media,dfmul_media,dfparith_media,dfpconv_media,dmpy_media,fcmp_media,fdiv_media,fload_media,fmove_media,fparith_media,fpconv_media,fstore_media,gettr_media,invalidate_line_media,jump_media,load_media,pt_media,ptabs_media,store_media,mcmp_media,mac_media,d2mpy_media,atrans_media,ustore_media,nil,other\"\n   (const_string \"other\"))\n \n ;; We define a new attribute namely \"insn_class\".We use\n@@ -6801,6 +6808,142 @@\n   \"\"\n   \"\")\n \n+;; TLS code generation.\n+;; ??? this should be a define_insn_and_split\n+;; See the thread [PATCH/RFA] SH TLS support on gcc-patches\n+;; <http://gcc.gnu.org/ml/gcc-patches/2003-02/msg01898.html>\n+;; for details.\n+\n+(define_insn \"tls_global_dynamic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+\t(unspec:SI [(match_operand:SI 1 \"\" \"\")]\n+\t\t    UNSPEC_TLSGD))\n+   (use (reg:PSI FPSCR_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (reg:SI PR_REG))\n+   (clobber (scratch:SI))]\n+  \"TARGET_SH1\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mov.l\\\\t1f,r4\\\\n\\\\\n+\\\\tmova\\\\t2f,r0\\\\n\\\\\n+\\\\tmov.l\\\\t2f,r1\\\\n\\\\\n+\\\\tadd\\\\tr0,r1\\\\n\\\\\n+\\\\tjsr\\\\t@r1\\\\n\\\\\n+\\\\tadd\\\\tr12,r4\\\\n\\\\\n+\\\\tbra\\\\t3f\\\\n\\\\\n+\\\\tnop\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\t.long\\\\t%a1@TLSGD\\\\n\\\\\n+2:\\\\t.long\\\\t__tls_get_addr@PLT\\\\n\\\\\n+3:\\\";\n+}\"\n+  [(set_attr \"type\" \"tls_load\")\n+   (set_attr \"length\" \"26\")])\n+\n+(define_insn \"tls_local_dynamic\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+\t(unspec:SI [(match_operand:SI 1 \"\" \"\")]\n+\t\t    UNSPEC_TLSLDM))\n+   (use (reg:PSI FPSCR_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (reg:SI PR_REG))\n+   (clobber (scratch:SI))]\n+  \"TARGET_SH1\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mov.l\\\\t1f,r4\\\\n\\\\\n+\\\\tmova\\\\t2f,r0\\\\n\\\\\n+\\\\tmov.l\\\\t2f,r1\\\\n\\\\\n+\\\\tadd\\\\tr0,r1\\\\n\\\\\n+\\\\tjsr\\\\t@r1\\\\n\\\\\n+\\\\tadd\\\\tr12,r4\\\\n\\\\\n+\\\\tbra\\\\t3f\\\\n\\\\\n+\\\\tnop\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\t.long\\\\t%a1@TLSLDM\\\\n\\\\\n+2:\\\\t.long\\\\t__tls_get_addr@PLT\\\\n\\\\\n+3:\\\";\n+}\"\n+  [(set_attr \"type\" \"tls_load\")\n+   (set_attr \"length\" \"26\")])\n+\n+(define_expand \"sym2DTPOFF\"\n+  [(const (unspec [(match_operand 0 \"\" \"\")] UNSPEC_DTPOFF))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"symDTPOFF2reg\"\n+  [(match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\") (match_operand 2 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx dtpoffsym, insn;\n+  rtx t = no_new_pseudos ? operands[0] : gen_reg_rtx (GET_MODE (operands[0]));\n+\n+  dtpoffsym = gen_sym2DTPOFF (operands[1]);\n+  PUT_MODE (dtpoffsym, Pmode);\n+  emit_move_insn (t, dtpoffsym);\n+  insn = emit_move_insn (operands[0],\n+\t\t\t gen_rtx_PLUS (Pmode, t, operands[2]));\n+  DONE;\n+}\")\n+\n+(define_expand \"sym2GOTTPOFF\"\n+  [(const (unspec [(match_operand 0 \"\" \"\")] UNSPEC_GOTTPOFF))]\n+  \"\"\n+  \"\")\n+\n+(define_insn \"tls_initial_exec\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+\t(unspec:SI [(match_operand:SI 1 \"\" \"\")]\n+\t\t    UNSPEC_TLSIE))\n+   (use (reg:SI GBR_REG))\n+   (use (reg:SI PIC_REG))\n+   (clobber (reg:SI R0_REG))]\n+  \"\"\n+  \"*\n+{\n+  return \\\"\\\\\n+mov.l\\\\t1f,r0\\\\n\\\\\n+\\\\tstc\\\\tgbr,%0\\\\n\\\\\n+\\\\tmov.l\\\\t@(r0,r12),r0\\\\n\\\\\n+\\\\tbra\\\\t2f\\\\n\\\\\n+\\\\tadd\\\\tr0,%0\\\\n\\\\\n+\\\\t.align\\\\t2\\\\n\\\\\n+1:\\\\t.long\\\\t%a1\\\\n\\\\\n+2:\\\";\n+}\"\n+  [(set_attr \"type\" \"tls_load\")\n+   (set_attr \"length\" \"16\")])\n+\n+(define_expand \"sym2TPOFF\"\n+  [(const (unspec [(match_operand 0 \"\" \"\")] UNSPEC_TPOFF))]\n+  \"\"\n+  \"\")\n+\n+(define_expand \"symTPOFF2reg\"\n+  [(match_operand 0 \"\" \"\") (match_operand 1 \"\" \"\")]\n+  \"\"\n+  \"\n+{\n+  rtx tpoffsym, insn;\n+\n+  tpoffsym = gen_sym2TPOFF (operands[1]);\n+  PUT_MODE (tpoffsym, Pmode);\n+  insn = emit_move_insn (operands[0], tpoffsym);\n+  DONE;\n+}\")\n+\n+(define_insn \"load_gbr\"\n+  [(set (match_operand:SI 0 \"register_operand\" \"\") (reg:SI GBR_REG))\n+   (use (reg:SI GBR_REG))]\n+  \"\"\n+  \"stc\tgbr,%0\"\n+  [(set_attr \"type\" \"tls_load\")])\n+\n ;; case instruction for switch statements.\n \n ;; Operand 0 is index"}]}