{"sha": "2b725155eca023573fb796baaf11e712227c85ae", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmI3MjUxNTVlY2EwMjM1NzNmYjc5NmJhYWYxMWU3MTIyMjdjODVhZQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2005-06-03T02:11:05Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2005-06-03T02:11:05Z"}, "message": "Makefile.in (tree-vect-generic.o): New.\n\n        * Makefile.in (tree-vect-generic.o): New.\n        (OBJS-common, GTFILES, s-gtype): Add it.\n        * tree-complex.c (build_replicated_const, vector_inner_type,\n        vector_last_type, vector_last_nunits, build_word_mode_vector_type,\n        elem_op_func, tree_vec_extract, do_unop, do_binop, do_plus_minus,\n        do_negate, expand_vector_piecewise, expand_vector_parallel,\n        expand_vector_addition, expand_vector_operation,\n        type_for_widest_vector_mode, expand_vector_operations_1,\n        gate_expand_vector_operations, expand_vector_operations,\n        pass_lower_vector_ssa): Move to tree-vect-generic.c.\n        (tree_lower_complex): Rename from tree_lower_operations.\n        (pass_lower_complex): Rename from pass_pre_expand.\n        * tree-vect-generic.c: New file.\n        * tree-pass.h (pass_lower_complex): Rename from pass_pre_expand.\n        (pass_lower_vector): New.\n        * tree-optimize.c (init_tree_optimization_passes): Update to match.\n\nFrom-SVN: r100529", "tree": {"sha": "d9da0c6302b4f68189c9d8dfea9876c99750367c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d9da0c6302b4f68189c9d8dfea9876c99750367c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2b725155eca023573fb796baaf11e712227c85ae", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b725155eca023573fb796baaf11e712227c85ae", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2b725155eca023573fb796baaf11e712227c85ae", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2b725155eca023573fb796baaf11e712227c85ae/comments", "author": null, "committer": null, "parents": [{"sha": "aeb556659b56f3489a11b57702a7a87b469856c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aeb556659b56f3489a11b57702a7a87b469856c2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aeb556659b56f3489a11b57702a7a87b469856c2"}], "stats": {"total": 1066, "additions": 573, "deletions": 493}, "files": [{"sha": "5dba8017a36b493627fc9f864aa070aefe21093e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -1,3 +1,22 @@\n+2005-06-02  Richard Henderson  <rth@redhat.com>\n+\n+\t* Makefile.in (tree-vect-generic.o): New.\n+\t(OBJS-common, GTFILES, s-gtype): Add it.\n+\t* tree-complex.c (build_replicated_const, vector_inner_type,\n+\tvector_last_type, vector_last_nunits, build_word_mode_vector_type,\n+\telem_op_func, tree_vec_extract, do_unop, do_binop, do_plus_minus,\n+\tdo_negate, expand_vector_piecewise, expand_vector_parallel, \n+\texpand_vector_addition, expand_vector_operation, \n+\ttype_for_widest_vector_mode, expand_vector_operations_1, \n+\tgate_expand_vector_operations, expand_vector_operations, \n+\tpass_lower_vector_ssa): Move to tree-vect-generic.c.\n+\t(tree_lower_complex): Rename from tree_lower_operations.\n+\t(pass_lower_complex): Rename from pass_pre_expand.\n+\t* tree-vect-generic.c: New file.\n+\t* tree-pass.h (pass_lower_complex): Rename from pass_pre_expand.\n+\t(pass_lower_vector): New.\n+\t* tree-optimize.c (init_tree_optimization_passes): Update to match.\n+\n 2005-06-02  Richard Henderson  <rth@redhat.com>\n \n \t* modulo-sched.c (doloop_register_get): Protect against "}, {"sha": "30bdf4fc6d1d74ed0b1ddaf2be38b656420e86df", "filename": "gcc/Makefile.in", "status": "modified", "additions": 13, "deletions": 8, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -925,14 +925,15 @@ C_OBJS = c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n OBJS-common = \\\n  tree-chrec.o tree-scalar-evolution.o tree-data-ref.o\t\t\t   \\\n  tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-gimple.o  \\\n- gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n+ gimplify.o tree-pretty-print.o tree-into-ssa.o\t\t\t\t   \\\n  tree-outof-ssa.o tree-ssa-ccp.o tree-vn.o tree-ssa-uncprop.o\t\t   \\\n- tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n+ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o\t   \\\n  tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n  tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n  tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n- tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n- tree-ssa-loop-niter.o tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t   \\\n+ tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o\t\t   \\\n+ tree-vect-generic.o tree-ssa-loop.o tree-ssa-loop-niter.o\t\t   \\\n+ tree-ssa-loop-manip.o tree-ssa-threadupdate.o\t\t\t\t   \\\n  tree-vectorizer.o tree-vect-analyze.o tree-vect-transform.o\t\t   \\\n  tree-ssa-loop-ivcanon.o tree-ssa-propagate.o tree-ssa-math-opts.o\t   \\\n  tree-ssa-loop-ivopts.o tree-if-conv.o tree-ssa-loop-unswitch.o\t\t   \\\n@@ -2115,7 +2116,12 @@ tree-sra.o : tree-sra.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(RTL_H) \\\n tree-complex.o : tree-complex.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n     $(TM_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) tree-iterator.h tree-pass.h \\\n     $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n-    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-complex.h $(GGC_H) \\\n+    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) $(GGC_H) \\\n+    coretypes.h insn-codes.h\n+tree-vect-generic.o : tree-vect-generic.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n+    $(TM_H) $(TREE_FLOW_H) $(TREE_GIMPLE_H) tree-iterator.h tree-pass.h \\\n+    $(FLAGS_H) $(OPTABS_H) $(RTL_H) $(MACHMODE_H) $(EXPR_H) \\\n+    langhooks.h $(FLAGS_H) $(DIAGNOSTIC_H) gt-tree-vect-generic.h $(GGC_H) \\\n     coretypes.h insn-codes.h\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n@@ -2611,7 +2617,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h \\\n   $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n   $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-propagate.c \\\n   $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n-  $(srcdir)/tree-chrec.h $(srcdir)/tree-complex.c \\\n+  $(srcdir)/tree-chrec.h $(srcdir)/tree-vect-generic.c \\\n   $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n   $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n   $(out_file) \\\n@@ -2630,8 +2636,7 @@ gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \\\n gt-dwarf2out.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parser.h \\\n gt-c-pragma.h gtype-c.h gt-cfglayout.h \\\n-gt-tree-mudflap.h gt-tree-complex.h \\\n-gt-tree-profile.h \\\n+gt-tree-mudflap.h gt-tree-vect-generic.h gt-tree-profile.h \\\n gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n gt-tree-phinodes.h gt-tree-nested.h \\\n gt-tree-ssa-operands.h gt-tree-ssa-propagate.h \\"}, {"sha": "4dd217ddcdb7c38bac06c991bd4968c34b74f903", "filename": "gcc/tree-complex.c", "status": "modified", "additions": 6, "deletions": 483, "changes": 489, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-complex.c?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -1,4 +1,4 @@\n-/* Lower complex number and vector operations to scalar operations.\n+/* Lower complex number operations to scalar operations.\n    Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n \n This file is part of GCC.\n@@ -563,462 +563,9 @@ expand_complex_operations_1 (block_stmt_iterator *bsi)\n     }\n   update_stmt_if_modified (stmt);\n }\n-\f\n-/* Build a constant of type TYPE, made of VALUE's bits replicated\n-   every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */\n-static tree\n-build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n-{\n-  int width = tree_low_cst (TYPE_SIZE (inner_type), 1);\n-  int n = HOST_BITS_PER_WIDE_INT / width;\n-  unsigned HOST_WIDE_INT low, high, mask;\n-  tree ret;\n-\n-  gcc_assert (n);\n-\n-  if (width == HOST_BITS_PER_WIDE_INT)\n-    low = value;\n-  else\n-    {\n-      mask = ((HOST_WIDE_INT)1 << width) - 1;\n-      low = (unsigned HOST_WIDE_INT) ~0 / mask * (value & mask);\n-    }\n-\n-  if (TYPE_PRECISION (type) < HOST_BITS_PER_WIDE_INT)\n-    low &= ((HOST_WIDE_INT)1 << TYPE_PRECISION (type)) - 1, high = 0;\n-  else if (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT)\n-    high = 0;\n-  else if (TYPE_PRECISION (type) == 2 * HOST_BITS_PER_WIDE_INT)\n-    high = low;\n-  else\n-    gcc_unreachable ();\n-\n-  ret = build_int_cst_wide (type, low, high);\n-  return ret;\n-}\n-\n-static GTY(()) tree vector_inner_type;\n-static GTY(()) tree vector_last_type;\n-static GTY(()) int vector_last_nunits;\n-\n-/* Return a suitable vector types made of SUBPARTS units each of mode\n-   \"word_mode\" (the global variable).  */\n-static tree\n-build_word_mode_vector_type (int nunits)\n-{\n-  if (!vector_inner_type)\n-    vector_inner_type = lang_hooks.types.type_for_mode (word_mode, 1);\n-  else if (vector_last_nunits == nunits)\n-    {\n-      gcc_assert (TREE_CODE (vector_last_type) == VECTOR_TYPE);\n-      return vector_last_type;\n-    }\n-\n-  /* We build a new type, but we canonicalize it nevertheless,\n-     because it still saves some memory.  */\n-  vector_last_nunits = nunits;\n-  vector_last_type = type_hash_canon (nunits,\n-\t\t\t\t      build_vector_type (vector_inner_type,\n-\t\t\t\t\t\t\t nunits));\n-  return vector_last_type;\n-}\n-\n-typedef tree (*elem_op_func) (block_stmt_iterator *,\n-\t\t\t      tree, tree, tree, tree, tree, enum tree_code);\n-\n-static inline tree\n-tree_vec_extract (block_stmt_iterator *bsi, tree type,\n-\t\t  tree t, tree bitsize, tree bitpos)\n-{\n-  if (bitpos)\n-    return gimplify_build3 (bsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n-\n-  /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n-     anyway be stored in memory, so prefer NOP_EXPR.  */\n-  else if (TYPE_MODE (type) == BLKmode)\n-    return gimplify_build1 (bsi, VIEW_CONVERT_EXPR, type, t);\n-  else\n-    return gimplify_build1 (bsi, NOP_EXPR, type, t);\n-}\n-\n-static tree\n-do_unop (block_stmt_iterator *bsi, tree inner_type, tree a,\n-\t tree b ATTRIBUTE_UNUSED, tree bitpos, tree bitsize,\n-\t enum tree_code code)\n-{\n-  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n-  return gimplify_build1 (bsi, code, inner_type, a);\n-}\n-\n-static tree\n-do_binop (block_stmt_iterator *bsi, tree inner_type, tree a, tree b,\n-\t  tree bitpos, tree bitsize, enum tree_code code)\n-{\n-  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n-  b = tree_vec_extract (bsi, inner_type, b, bitsize, bitpos);\n-  return gimplify_build2 (bsi, code, inner_type, a, b);\n-}\n-\n-/* Expand vector addition to scalars.  This does bit twiddling\n-   in order to increase parallelism:\n-\n-   a + b = (((int) a & 0x7f7f7f7f) + ((int) b & 0x7f7f7f7f)) ^\n-           (a ^ b) & 0x80808080\n-\n-   a - b =  (((int) a | 0x80808080) - ((int) b & 0x7f7f7f7f)) ^\n-            (a ^ ~b) & 0x80808080\n-\n-   -b = (0x80808080 - ((int) b & 0x7f7f7f7f)) ^ (~b & 0x80808080)\n-\n-   This optimization should be done only if 4 vector items or more\n-   fit into a word.  */\n-static tree\n-do_plus_minus (block_stmt_iterator *bsi, tree word_type, tree a, tree b,\n-\t       tree bitpos ATTRIBUTE_UNUSED, tree bitsize ATTRIBUTE_UNUSED,\n-\t       enum tree_code code)\n-{\n-  tree inner_type = TREE_TYPE (TREE_TYPE (a));\n-  unsigned HOST_WIDE_INT max;\n-  tree low_bits, high_bits, a_low, b_low, result_low, signs;\n-\n-  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n-  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n-  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n-\n-  a = tree_vec_extract (bsi, word_type, a, bitsize, bitpos);\n-  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n-\n-  signs = gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, a, b);\n-  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n-  if (code == PLUS_EXPR)\n-    a_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, a, low_bits);\n-  else\n-    {\n-      a_low = gimplify_build2 (bsi, BIT_IOR_EXPR, word_type, a, high_bits);\n-      signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, signs);\n-    }\n-\n-  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n-  result_low = gimplify_build2 (bsi, code, word_type, a_low, b_low);\n-  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n-}\n-\n-static tree\n-do_negate (block_stmt_iterator *bsi, tree word_type, tree b,\n-\t   tree unused ATTRIBUTE_UNUSED, tree bitpos ATTRIBUTE_UNUSED,\n-\t   tree bitsize ATTRIBUTE_UNUSED,\n-\t   enum tree_code code ATTRIBUTE_UNUSED)\n-{\n-  tree inner_type = TREE_TYPE (TREE_TYPE (b));\n-  HOST_WIDE_INT max;\n-  tree low_bits, high_bits, b_low, result_low, signs;\n-\n-  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n-  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n-  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n-\n-  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n-\n-  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n-  signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, b);\n-  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n-  result_low = gimplify_build2 (bsi, MINUS_EXPR, word_type, high_bits, b_low);\n-  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n-}\n-\n-/* Expand a vector operation to scalars, by using many operations\n-   whose type is the vector type's inner type.  */\n-static tree\n-expand_vector_piecewise (block_stmt_iterator *bsi, elem_op_func f,\n-\t\t\t tree type, tree inner_type,\n-\t\t\t tree a, tree b, enum tree_code code)\n-{\n-  tree head, *chain = &head;\n-  tree part_width = TYPE_SIZE (inner_type);\n-  tree index = bitsize_int (0);\n-  int nunits = TYPE_VECTOR_SUBPARTS (type);\n-  int delta = tree_low_cst (part_width, 1)\n-\t      / tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1);\n-  int i;\n-\n-  for (i = 0; i < nunits;\n-       i += delta, index = int_const_binop (PLUS_EXPR, index, part_width, 0))\n-    {\n-      tree result = f (bsi, inner_type, a, b, index, part_width, code);\n-      *chain = tree_cons (NULL_TREE, result, NULL_TREE);\n-      chain = &TREE_CHAIN (*chain);\n-    }\n-\n-  return build1 (CONSTRUCTOR, type, head);\n-}\n-\n-/* Expand a vector operation to scalars with the freedom to use\n-   a scalar integer type, or to use a different size for the items\n-   in the vector type.  */\n-static tree\n-expand_vector_parallel (block_stmt_iterator *bsi, elem_op_func f, tree type,\n-\t\t\ttree a, tree b,\n-\t\t\tenum tree_code code)\n-{\n-  tree result, compute_type;\n-  enum machine_mode mode;\n-  int n_words = tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n-\n-  /* We have three strategies.  If the type is already correct, just do\n-     the operation an element at a time.  Else, if the vector is wider than\n-     one word, do it a word at a time; finally, if the vector is smaller\n-     than one word, do it as a scalar.  */\n-  if (TYPE_MODE (TREE_TYPE (type)) == word_mode)\n-     return expand_vector_piecewise (bsi, f,\n-\t\t\t\t     type, TREE_TYPE (type),\n-\t\t\t\t     a, b, code);\n-  else if (n_words > 1)\n-    {\n-      tree word_type = build_word_mode_vector_type (n_words);\n-      result = expand_vector_piecewise (bsi, f,\n-\t\t\t\t        word_type, TREE_TYPE (word_type),\n-\t\t\t\t\ta, b, code);\n-      result = gimplify_val (bsi, word_type, result);\n-    }\n-  else\n-    {\n-      /* Use a single scalar operation with a mode no wider than word_mode.  */\n-      mode = mode_for_size (tree_low_cst (TYPE_SIZE (type), 1), MODE_INT, 0);\n-      compute_type = lang_hooks.types.type_for_mode (mode, 1);\n-      result = f (bsi, compute_type, a, b, NULL_TREE, NULL_TREE, code);\n-    }\n-\n-  return result;\n-}\n-\n-/* Expand a vector operation to scalars; for integer types we can use\n-   special bit twiddling tricks to do the sums a word at a time, using\n-   function F_PARALLEL instead of F.  These tricks are done only if\n-   they can process at least four items, that is, only if the vector\n-   holds at least four items and if a word can hold four items.  */\n-static tree\n-expand_vector_addition (block_stmt_iterator *bsi,\n-\t\t\telem_op_func f, elem_op_func f_parallel,\n-\t\t\ttree type, tree a, tree b, enum tree_code code)\n-{\n-  int parts_per_word = UNITS_PER_WORD\n-\t  \t       / tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (type)), 1);\n-\n-  if (INTEGRAL_TYPE_P (TREE_TYPE (type))\n-      && parts_per_word >= 4\n-      && TYPE_VECTOR_SUBPARTS (type) >= 4)\n-    return expand_vector_parallel (bsi, f_parallel,\n-\t\t\t\t   type, a, b, code);\n-  else\n-    return expand_vector_piecewise (bsi, f,\n-\t\t\t\t    type, TREE_TYPE (type),\n-\t\t\t\t    a, b, code);\n-}\n-\n-static tree\n-expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n-\t\t\t tree rhs, enum tree_code code)\n-{\n-  enum machine_mode compute_mode = TYPE_MODE (compute_type);\n-\n-  /* If the compute mode is not a vector mode (hence we are not decomposing\n-     a BLKmode vector to smaller, hardware-supported vectors), we may want\n-     to expand the operations in parallel.  */\n-  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n-      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n-    switch (code)\n-      {\n-      case PLUS_EXPR:\n-      case MINUS_EXPR:\n-        if (!TYPE_TRAP_SIGNED (type))\n-          return expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t TREE_OPERAND (rhs, 1), code);\n-\tbreak;\n-\n-      case NEGATE_EXPR:\n-        if (!TYPE_TRAP_SIGNED (type))\n-          return expand_vector_addition (bsi, do_unop, do_negate, type,\n-\t\t      \t\t         TREE_OPERAND (rhs, 0),\n-\t\t\t\t\t NULL_TREE, code);\n-\tbreak;\n-\n-      case BIT_AND_EXPR:\n-      case BIT_IOR_EXPR:\n-      case BIT_XOR_EXPR:\n-        return expand_vector_parallel (bsi, do_binop, type,\n-\t\t      \t\t       TREE_OPERAND (rhs, 0),\n-\t\t\t\t       TREE_OPERAND (rhs, 1), code);\n-\n-      case BIT_NOT_EXPR:\n-        return expand_vector_parallel (bsi, do_unop, type,\n-\t\t      \t\t       TREE_OPERAND (rhs, 0),\n-\t\t\t\t       NULL_TREE, code);\n-\n-      default:\n-\tbreak;\n-      }\n-\n-  if (TREE_CODE_CLASS (code) == tcc_unary)\n-    return expand_vector_piecewise (bsi, do_unop, type, compute_type,\n-\t\t\t\t    TREE_OPERAND (rhs, 0),\n-\t\t\t\t    NULL_TREE, code);\n-  else\n-    return expand_vector_piecewise (bsi, do_binop, type, compute_type,\n-\t\t\t\t    TREE_OPERAND (rhs, 0),\n-\t\t\t\t    TREE_OPERAND (rhs, 1), code);\n-}\n-\f\n-/* Return a type for the widest vector mode whose components are of mode\n-   INNER_MODE, or NULL_TREE if none is found.  */\n-static tree\n-type_for_widest_vector_mode (enum machine_mode inner_mode, optab op)\n-{\n-  enum machine_mode best_mode = VOIDmode, mode;\n-  int best_nunits = 0;\n-\n-  if (GET_MODE_CLASS (inner_mode) == MODE_FLOAT)\n-    mode = MIN_MODE_VECTOR_FLOAT;\n-  else\n-    mode = MIN_MODE_VECTOR_INT;\n-\n-  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n-    if (GET_MODE_INNER (mode) == inner_mode\n-        && GET_MODE_NUNITS (mode) > best_nunits\n-\t&& op->handlers[mode].insn_code != CODE_FOR_nothing)\n-      best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n-\n-  if (best_mode == VOIDmode)\n-    return NULL_TREE;\n-  else\n-    return lang_hooks.types.type_for_mode (best_mode, 1);\n-}\n-\n-/* Process one statement.  If we identify a vector operation, expand it.  */\n \n static void\n-expand_vector_operations_1 (block_stmt_iterator *bsi)\n-{\n-  tree stmt = bsi_stmt (*bsi);\n-  tree *p_lhs, *p_rhs, lhs, rhs, type, compute_type;\n-  enum tree_code code;\n-  enum machine_mode compute_mode;\n-  optab op;\n-\n-  switch (TREE_CODE (stmt))\n-    {\n-    case RETURN_EXPR:\n-      stmt = TREE_OPERAND (stmt, 0);\n-      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n-\treturn;\n-\n-      /* FALLTHRU */\n-\n-    case MODIFY_EXPR:\n-      p_lhs = &TREE_OPERAND (stmt, 0);\n-      p_rhs = &TREE_OPERAND (stmt, 1);\n-      lhs = *p_lhs;\n-      rhs = *p_rhs;\n-      break;\n-\n-    default:\n-      return;\n-    }\n-\n-  type = TREE_TYPE (rhs);\n-  if (TREE_CODE (type) != VECTOR_TYPE)\n-    return;\n-\n-  code = TREE_CODE (rhs);\n-  if (TREE_CODE_CLASS (code) != tcc_unary\n-      && TREE_CODE_CLASS (code) != tcc_binary)\n-    return;\n-\n-  if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n-    return;\n-  \n-  gcc_assert (code != CONVERT_EXPR);\n-  op = optab_for_tree_code (code, type);\n-\n-  /* Optabs will try converting a negation into a subtraction, so\n-     look for it as well.  TODO: negation of floating-point vectors\n-     might be turned into an exclusive OR toggling the sign bit.  */\n-  if (op == NULL\n-      && code == NEGATE_EXPR\n-      && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n-    op = optab_for_tree_code (MINUS_EXPR, type);\n-\n-  /* For very wide vectors, try using a smaller vector mode.  */\n-  compute_type = type;\n-  if (TYPE_MODE (type) == BLKmode && op)\n-    {\n-      tree vector_compute_type\n-        = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op);\n-      if (vector_compute_type != NULL_TREE)\n-        compute_type = vector_compute_type;\n-    }\n-\n-  /* If we are breaking a BLKmode vector into smaller pieces,\n-     type_for_widest_vector_mode has already looked into the optab,\n-     so skip these checks.  */\n-  if (compute_type == type)\n-    {\n-      compute_mode = TYPE_MODE (compute_type);\n-      if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n-\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT)\n-          && op != NULL\n-\t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n-\treturn;\n-      else\n-\t/* There is no operation in hardware, so fall back to scalars.  */\n-\tcompute_type = TREE_TYPE (type);\n-    }\n-\n-  rhs = expand_vector_operation (bsi, type, compute_type, rhs, code);\n-  if (lang_hooks.types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n-    *p_rhs = rhs;\n-  else\n-    {\n-      /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n-         be stored in memory anyway, so prefer NOP_EXPR.  We should also try\n-\t performing the VIEW_CONVERT_EXPR on the left side of the\n-\t assignment.  */\n-      if (TYPE_MODE (TREE_TYPE (rhs)) == BLKmode)\n-        *p_rhs = gimplify_build1 (bsi, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n-      else\n-\t*p_rhs = gimplify_build1 (bsi, NOP_EXPR, TREE_TYPE (lhs), rhs);\n-    }\n-\n-  mark_stmt_modified (bsi_stmt (*bsi));\n-}\n-\f\n-/* Use this to lower vector operations introduced by the vectorizer,\n-   if it may need the bit-twiddling tricks implemented in this file.  */\n-\n-static bool\n-gate_expand_vector_operations (void)\n-{\n-  return flag_tree_vectorize != 0;\n-}\n-\n-static void\n-expand_vector_operations (void)\n-{\n-  block_stmt_iterator bsi;\n-  basic_block bb;\n-\n-  FOR_EACH_BB (bb)\n-    {\n-      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  expand_vector_operations_1 (&bsi);\n-\t  update_stmt_if_modified (bsi_stmt (bsi));\n-\t}\n-    }\n-}\n-\n-static void\n-tree_lower_operations (void)\n+tree_lower_complex (void)\n {\n   int old_last_basic_block = last_basic_block;\n   block_stmt_iterator bsi;\n@@ -1029,38 +576,16 @@ tree_lower_operations (void)\n       if (bb->index >= old_last_basic_block)\n \tcontinue;\n       for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n-\t{\n-\t  expand_complex_operations_1 (&bsi);\n-\t  expand_vector_operations_1 (&bsi);\n-\t}\n+\texpand_complex_operations_1 (&bsi);\n     }\n }\n \n \n-struct tree_opt_pass pass_lower_vector_ssa = \n-{\n-  \"veclower\",\t\t\t\t/* name */\n-  gate_expand_vector_operations,\t/* gate */\n-  expand_vector_operations,\t\t/* execute */\n-  NULL,\t\t\t\t\t/* sub */\n-  NULL,\t\t\t\t\t/* next */\n-  0,\t\t\t\t\t/* static_pass_number */\n-  0,\t\t\t\t\t/* tv_id */\n-  PROP_cfg,\t\t\t\t/* properties_required */\n-  0,\t\t\t\t\t/* properties_provided */\n-  0,\t\t\t\t\t/* properties_destroyed */\n-  0,\t\t\t\t\t/* todo_flags_start */\n-  TODO_dump_func | TODO_update_ssa\t/* todo_flags_finish */\n-    | TODO_verify_ssa\n-    | TODO_verify_stmts | TODO_verify_flow,\n-  0\t\t\t\t\t/* letter */\n-};\n-\n-struct tree_opt_pass pass_pre_expand = \n+struct tree_opt_pass pass_lower_complex = \n {\n-  \"oplower\",\t\t\t\t/* name */\n+  \"cplxlower\",\t\t\t\t/* name */\n   0,\t\t\t\t\t/* gate */\n-  tree_lower_operations,\t\t/* execute */\n+  tree_lower_complex,\t\t\t/* execute */\n   NULL,\t\t\t\t\t/* sub */\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n@@ -1073,5 +598,3 @@ struct tree_opt_pass pass_pre_expand =\n     | TODO_verify_stmts,\t\t/* todo_flags_finish */\n   0\t\t\t\t\t/* letter */\n };\n-\n-#include \"gt-tree-complex.h\""}, {"sha": "8e02f458545824af5dd4ffaeccdad38a717b6662", "filename": "gcc/tree-optimize.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-optimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-optimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-optimize.c?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -375,7 +375,8 @@ init_tree_optimization_passes (void)\n   NEXT_PASS (pass_lower_cf); \n   NEXT_PASS (pass_lower_eh); \n   NEXT_PASS (pass_build_cfg); \n-  NEXT_PASS (pass_pre_expand);\n+  NEXT_PASS (pass_lower_complex);\n+  NEXT_PASS (pass_lower_vector);\n   NEXT_PASS (pass_warn_function_return);\n   NEXT_PASS (pass_tree_profile);\n   *p = NULL;"}, {"sha": "2c255ab33c232205d05d98a4544ba31af422fc12", "filename": "gcc/tree-pass.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-pass.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-pass.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-pass.h?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -192,7 +192,8 @@ extern struct tree_opt_pass pass_may_alias;\n extern struct tree_opt_pass pass_split_crit_edges;\n extern struct tree_opt_pass pass_pre;\n extern struct tree_opt_pass pass_profile;\n-extern struct tree_opt_pass pass_pre_expand;\n+extern struct tree_opt_pass pass_lower_complex;\n+extern struct tree_opt_pass pass_lower_vector;\n extern struct tree_opt_pass pass_lower_vector_ssa;\n extern struct tree_opt_pass pass_fold_builtins;\n extern struct tree_opt_pass pass_stdarg;"}, {"sha": "2da1ed2e936d7ca97a134ec77898e7c73cc929fd", "filename": "gcc/tree-vect-generic.c", "status": "added", "additions": 531, "deletions": 0, "changes": 531, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-vect-generic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2b725155eca023573fb796baaf11e712227c85ae/gcc%2Ftree-vect-generic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-generic.c?ref=2b725155eca023573fb796baaf11e712227c85ae", "patch": "@@ -0,0 +1,531 @@\n+/* Lower vector operations to scalar operations.\n+   Copyright (C) 2004, 2005 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+   \n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+   \n+GCC is distributed in the hope that it will be useful, but WITHOUT\n+ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+   \n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree.h\"\n+#include \"tm.h\"\n+#include \"rtl.h\"\n+#include \"expr.h\"\n+#include \"insn-codes.h\"\n+#include \"diagnostic.h\"\n+#include \"optabs.h\"\n+#include \"machmode.h\"\n+#include \"langhooks.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-gimple.h\"\n+#include \"tree-iterator.h\"\n+#include \"tree-pass.h\"\n+#include \"flags.h\"\n+#include \"ggc.h\"\n+\n+\n+/* Build a constant of type TYPE, made of VALUE's bits replicated\n+   every TYPE_SIZE (INNER_TYPE) bits to fit TYPE's precision.  */\n+static tree\n+build_replicated_const (tree type, tree inner_type, HOST_WIDE_INT value)\n+{\n+  int width = tree_low_cst (TYPE_SIZE (inner_type), 1);\n+  int n = HOST_BITS_PER_WIDE_INT / width;\n+  unsigned HOST_WIDE_INT low, high, mask;\n+  tree ret;\n+\n+  gcc_assert (n);\n+\n+  if (width == HOST_BITS_PER_WIDE_INT)\n+    low = value;\n+  else\n+    {\n+      mask = ((HOST_WIDE_INT)1 << width) - 1;\n+      low = (unsigned HOST_WIDE_INT) ~0 / mask * (value & mask);\n+    }\n+\n+  if (TYPE_PRECISION (type) < HOST_BITS_PER_WIDE_INT)\n+    low &= ((HOST_WIDE_INT)1 << TYPE_PRECISION (type)) - 1, high = 0;\n+  else if (TYPE_PRECISION (type) == HOST_BITS_PER_WIDE_INT)\n+    high = 0;\n+  else if (TYPE_PRECISION (type) == 2 * HOST_BITS_PER_WIDE_INT)\n+    high = low;\n+  else\n+    gcc_unreachable ();\n+\n+  ret = build_int_cst_wide (type, low, high);\n+  return ret;\n+}\n+\n+static GTY(()) tree vector_inner_type;\n+static GTY(()) tree vector_last_type;\n+static GTY(()) int vector_last_nunits;\n+\n+/* Return a suitable vector types made of SUBPARTS units each of mode\n+   \"word_mode\" (the global variable).  */\n+static tree\n+build_word_mode_vector_type (int nunits)\n+{\n+  if (!vector_inner_type)\n+    vector_inner_type = lang_hooks.types.type_for_mode (word_mode, 1);\n+  else if (vector_last_nunits == nunits)\n+    {\n+      gcc_assert (TREE_CODE (vector_last_type) == VECTOR_TYPE);\n+      return vector_last_type;\n+    }\n+\n+  /* We build a new type, but we canonicalize it nevertheless,\n+     because it still saves some memory.  */\n+  vector_last_nunits = nunits;\n+  vector_last_type = type_hash_canon (nunits,\n+\t\t\t\t      build_vector_type (vector_inner_type,\n+\t\t\t\t\t\t\t nunits));\n+  return vector_last_type;\n+}\n+\n+typedef tree (*elem_op_func) (block_stmt_iterator *,\n+\t\t\t      tree, tree, tree, tree, tree, enum tree_code);\n+\n+static inline tree\n+tree_vec_extract (block_stmt_iterator *bsi, tree type,\n+\t\t  tree t, tree bitsize, tree bitpos)\n+{\n+  if (bitpos)\n+    return gimplify_build3 (bsi, BIT_FIELD_REF, type, t, bitsize, bitpos);\n+\n+  /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n+     anyway be stored in memory, so prefer NOP_EXPR.  */\n+  else if (TYPE_MODE (type) == BLKmode)\n+    return gimplify_build1 (bsi, VIEW_CONVERT_EXPR, type, t);\n+  else\n+    return gimplify_build1 (bsi, NOP_EXPR, type, t);\n+}\n+\n+static tree\n+do_unop (block_stmt_iterator *bsi, tree inner_type, tree a,\n+\t tree b ATTRIBUTE_UNUSED, tree bitpos, tree bitsize,\n+\t enum tree_code code)\n+{\n+  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n+  return gimplify_build1 (bsi, code, inner_type, a);\n+}\n+\n+static tree\n+do_binop (block_stmt_iterator *bsi, tree inner_type, tree a, tree b,\n+\t  tree bitpos, tree bitsize, enum tree_code code)\n+{\n+  a = tree_vec_extract (bsi, inner_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (bsi, inner_type, b, bitsize, bitpos);\n+  return gimplify_build2 (bsi, code, inner_type, a, b);\n+}\n+\n+/* Expand vector addition to scalars.  This does bit twiddling\n+   in order to increase parallelism:\n+\n+   a + b = (((int) a & 0x7f7f7f7f) + ((int) b & 0x7f7f7f7f)) ^\n+           (a ^ b) & 0x80808080\n+\n+   a - b =  (((int) a | 0x80808080) - ((int) b & 0x7f7f7f7f)) ^\n+            (a ^ ~b) & 0x80808080\n+\n+   -b = (0x80808080 - ((int) b & 0x7f7f7f7f)) ^ (~b & 0x80808080)\n+\n+   This optimization should be done only if 4 vector items or more\n+   fit into a word.  */\n+static tree\n+do_plus_minus (block_stmt_iterator *bsi, tree word_type, tree a, tree b,\n+\t       tree bitpos ATTRIBUTE_UNUSED, tree bitsize ATTRIBUTE_UNUSED,\n+\t       enum tree_code code)\n+{\n+  tree inner_type = TREE_TYPE (TREE_TYPE (a));\n+  unsigned HOST_WIDE_INT max;\n+  tree low_bits, high_bits, a_low, b_low, result_low, signs;\n+\n+  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n+  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n+  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n+\n+  a = tree_vec_extract (bsi, word_type, a, bitsize, bitpos);\n+  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n+\n+  signs = gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, a, b);\n+  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n+  if (code == PLUS_EXPR)\n+    a_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, a, low_bits);\n+  else\n+    {\n+      a_low = gimplify_build2 (bsi, BIT_IOR_EXPR, word_type, a, high_bits);\n+      signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, signs);\n+    }\n+\n+  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n+  result_low = gimplify_build2 (bsi, code, word_type, a_low, b_low);\n+  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n+}\n+\n+static tree\n+do_negate (block_stmt_iterator *bsi, tree word_type, tree b,\n+\t   tree unused ATTRIBUTE_UNUSED, tree bitpos ATTRIBUTE_UNUSED,\n+\t   tree bitsize ATTRIBUTE_UNUSED,\n+\t   enum tree_code code ATTRIBUTE_UNUSED)\n+{\n+  tree inner_type = TREE_TYPE (TREE_TYPE (b));\n+  HOST_WIDE_INT max;\n+  tree low_bits, high_bits, b_low, result_low, signs;\n+\n+  max = GET_MODE_MASK (TYPE_MODE (inner_type));\n+  low_bits = build_replicated_const (word_type, inner_type, max >> 1);\n+  high_bits = build_replicated_const (word_type, inner_type, max & ~(max >> 1));\n+\n+  b = tree_vec_extract (bsi, word_type, b, bitsize, bitpos);\n+\n+  b_low = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, b, low_bits);\n+  signs = gimplify_build1 (bsi, BIT_NOT_EXPR, word_type, b);\n+  signs = gimplify_build2 (bsi, BIT_AND_EXPR, word_type, signs, high_bits);\n+  result_low = gimplify_build2 (bsi, MINUS_EXPR, word_type, high_bits, b_low);\n+  return gimplify_build2 (bsi, BIT_XOR_EXPR, word_type, result_low, signs);\n+}\n+\n+/* Expand a vector operation to scalars, by using many operations\n+   whose type is the vector type's inner type.  */\n+static tree\n+expand_vector_piecewise (block_stmt_iterator *bsi, elem_op_func f,\n+\t\t\t tree type, tree inner_type,\n+\t\t\t tree a, tree b, enum tree_code code)\n+{\n+  tree head, *chain = &head;\n+  tree part_width = TYPE_SIZE (inner_type);\n+  tree index = bitsize_int (0);\n+  int nunits = TYPE_VECTOR_SUBPARTS (type);\n+  int delta = tree_low_cst (part_width, 1)\n+\t      / tree_low_cst (TYPE_SIZE (TREE_TYPE (type)), 1);\n+  int i;\n+\n+  for (i = 0; i < nunits;\n+       i += delta, index = int_const_binop (PLUS_EXPR, index, part_width, 0))\n+    {\n+      tree result = f (bsi, inner_type, a, b, index, part_width, code);\n+      *chain = tree_cons (NULL_TREE, result, NULL_TREE);\n+      chain = &TREE_CHAIN (*chain);\n+    }\n+\n+  return build1 (CONSTRUCTOR, type, head);\n+}\n+\n+/* Expand a vector operation to scalars with the freedom to use\n+   a scalar integer type, or to use a different size for the items\n+   in the vector type.  */\n+static tree\n+expand_vector_parallel (block_stmt_iterator *bsi, elem_op_func f, tree type,\n+\t\t\ttree a, tree b,\n+\t\t\tenum tree_code code)\n+{\n+  tree result, compute_type;\n+  enum machine_mode mode;\n+  int n_words = tree_low_cst (TYPE_SIZE_UNIT (type), 1) / UNITS_PER_WORD;\n+\n+  /* We have three strategies.  If the type is already correct, just do\n+     the operation an element at a time.  Else, if the vector is wider than\n+     one word, do it a word at a time; finally, if the vector is smaller\n+     than one word, do it as a scalar.  */\n+  if (TYPE_MODE (TREE_TYPE (type)) == word_mode)\n+     return expand_vector_piecewise (bsi, f,\n+\t\t\t\t     type, TREE_TYPE (type),\n+\t\t\t\t     a, b, code);\n+  else if (n_words > 1)\n+    {\n+      tree word_type = build_word_mode_vector_type (n_words);\n+      result = expand_vector_piecewise (bsi, f,\n+\t\t\t\t        word_type, TREE_TYPE (word_type),\n+\t\t\t\t\ta, b, code);\n+      result = gimplify_val (bsi, word_type, result);\n+    }\n+  else\n+    {\n+      /* Use a single scalar operation with a mode no wider than word_mode.  */\n+      mode = mode_for_size (tree_low_cst (TYPE_SIZE (type), 1), MODE_INT, 0);\n+      compute_type = lang_hooks.types.type_for_mode (mode, 1);\n+      result = f (bsi, compute_type, a, b, NULL_TREE, NULL_TREE, code);\n+    }\n+\n+  return result;\n+}\n+\n+/* Expand a vector operation to scalars; for integer types we can use\n+   special bit twiddling tricks to do the sums a word at a time, using\n+   function F_PARALLEL instead of F.  These tricks are done only if\n+   they can process at least four items, that is, only if the vector\n+   holds at least four items and if a word can hold four items.  */\n+static tree\n+expand_vector_addition (block_stmt_iterator *bsi,\n+\t\t\telem_op_func f, elem_op_func f_parallel,\n+\t\t\ttree type, tree a, tree b, enum tree_code code)\n+{\n+  int parts_per_word = UNITS_PER_WORD\n+\t  \t       / tree_low_cst (TYPE_SIZE_UNIT (TREE_TYPE (type)), 1);\n+\n+  if (INTEGRAL_TYPE_P (TREE_TYPE (type))\n+      && parts_per_word >= 4\n+      && TYPE_VECTOR_SUBPARTS (type) >= 4)\n+    return expand_vector_parallel (bsi, f_parallel,\n+\t\t\t\t   type, a, b, code);\n+  else\n+    return expand_vector_piecewise (bsi, f,\n+\t\t\t\t    type, TREE_TYPE (type),\n+\t\t\t\t    a, b, code);\n+}\n+\n+static tree\n+expand_vector_operation (block_stmt_iterator *bsi, tree type, tree compute_type,\n+\t\t\t tree rhs, enum tree_code code)\n+{\n+  enum machine_mode compute_mode = TYPE_MODE (compute_type);\n+\n+  /* If the compute mode is not a vector mode (hence we are not decomposing\n+     a BLKmode vector to smaller, hardware-supported vectors), we may want\n+     to expand the operations in parallel.  */\n+  if (GET_MODE_CLASS (compute_mode) != MODE_VECTOR_INT\n+      && GET_MODE_CLASS (compute_mode) != MODE_VECTOR_FLOAT)\n+    switch (code)\n+      {\n+      case PLUS_EXPR:\n+      case MINUS_EXPR:\n+        if (!TYPE_TRAP_SIGNED (type))\n+          return expand_vector_addition (bsi, do_binop, do_plus_minus, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t TREE_OPERAND (rhs, 1), code);\n+\tbreak;\n+\n+      case NEGATE_EXPR:\n+        if (!TYPE_TRAP_SIGNED (type))\n+          return expand_vector_addition (bsi, do_unop, do_negate, type,\n+\t\t      \t\t         TREE_OPERAND (rhs, 0),\n+\t\t\t\t\t NULL_TREE, code);\n+\tbreak;\n+\n+      case BIT_AND_EXPR:\n+      case BIT_IOR_EXPR:\n+      case BIT_XOR_EXPR:\n+        return expand_vector_parallel (bsi, do_binop, type,\n+\t\t      \t\t       TREE_OPERAND (rhs, 0),\n+\t\t\t\t       TREE_OPERAND (rhs, 1), code);\n+\n+      case BIT_NOT_EXPR:\n+        return expand_vector_parallel (bsi, do_unop, type,\n+\t\t      \t\t       TREE_OPERAND (rhs, 0),\n+\t\t\t\t       NULL_TREE, code);\n+\n+      default:\n+\tbreak;\n+      }\n+\n+  if (TREE_CODE_CLASS (code) == tcc_unary)\n+    return expand_vector_piecewise (bsi, do_unop, type, compute_type,\n+\t\t\t\t    TREE_OPERAND (rhs, 0),\n+\t\t\t\t    NULL_TREE, code);\n+  else\n+    return expand_vector_piecewise (bsi, do_binop, type, compute_type,\n+\t\t\t\t    TREE_OPERAND (rhs, 0),\n+\t\t\t\t    TREE_OPERAND (rhs, 1), code);\n+}\n+\f\n+/* Return a type for the widest vector mode whose components are of mode\n+   INNER_MODE, or NULL_TREE if none is found.  */\n+static tree\n+type_for_widest_vector_mode (enum machine_mode inner_mode, optab op)\n+{\n+  enum machine_mode best_mode = VOIDmode, mode;\n+  int best_nunits = 0;\n+\n+  if (GET_MODE_CLASS (inner_mode) == MODE_FLOAT)\n+    mode = MIN_MODE_VECTOR_FLOAT;\n+  else\n+    mode = MIN_MODE_VECTOR_INT;\n+\n+  for (; mode != VOIDmode; mode = GET_MODE_WIDER_MODE (mode))\n+    if (GET_MODE_INNER (mode) == inner_mode\n+        && GET_MODE_NUNITS (mode) > best_nunits\n+\t&& op->handlers[mode].insn_code != CODE_FOR_nothing)\n+      best_mode = mode, best_nunits = GET_MODE_NUNITS (mode);\n+\n+  if (best_mode == VOIDmode)\n+    return NULL_TREE;\n+  else\n+    return lang_hooks.types.type_for_mode (best_mode, 1);\n+}\n+\n+/* Process one statement.  If we identify a vector operation, expand it.  */\n+\n+static void\n+expand_vector_operations_1 (block_stmt_iterator *bsi)\n+{\n+  tree stmt = bsi_stmt (*bsi);\n+  tree *p_lhs, *p_rhs, lhs, rhs, type, compute_type;\n+  enum tree_code code;\n+  enum machine_mode compute_mode;\n+  optab op;\n+\n+  switch (TREE_CODE (stmt))\n+    {\n+    case RETURN_EXPR:\n+      stmt = TREE_OPERAND (stmt, 0);\n+      if (!stmt || TREE_CODE (stmt) != MODIFY_EXPR)\n+\treturn;\n+\n+      /* FALLTHRU */\n+\n+    case MODIFY_EXPR:\n+      p_lhs = &TREE_OPERAND (stmt, 0);\n+      p_rhs = &TREE_OPERAND (stmt, 1);\n+      lhs = *p_lhs;\n+      rhs = *p_rhs;\n+      break;\n+\n+    default:\n+      return;\n+    }\n+\n+  type = TREE_TYPE (rhs);\n+  if (TREE_CODE (type) != VECTOR_TYPE)\n+    return;\n+\n+  code = TREE_CODE (rhs);\n+  if (TREE_CODE_CLASS (code) != tcc_unary\n+      && TREE_CODE_CLASS (code) != tcc_binary)\n+    return;\n+\n+  if (code == NOP_EXPR || code == VIEW_CONVERT_EXPR)\n+    return;\n+  \n+  gcc_assert (code != CONVERT_EXPR);\n+  op = optab_for_tree_code (code, type);\n+\n+  /* Optabs will try converting a negation into a subtraction, so\n+     look for it as well.  TODO: negation of floating-point vectors\n+     might be turned into an exclusive OR toggling the sign bit.  */\n+  if (op == NULL\n+      && code == NEGATE_EXPR\n+      && INTEGRAL_TYPE_P (TREE_TYPE (type)))\n+    op = optab_for_tree_code (MINUS_EXPR, type);\n+\n+  /* For very wide vectors, try using a smaller vector mode.  */\n+  compute_type = type;\n+  if (TYPE_MODE (type) == BLKmode && op)\n+    {\n+      tree vector_compute_type\n+        = type_for_widest_vector_mode (TYPE_MODE (TREE_TYPE (type)), op);\n+      if (vector_compute_type != NULL_TREE)\n+        compute_type = vector_compute_type;\n+    }\n+\n+  /* If we are breaking a BLKmode vector into smaller pieces,\n+     type_for_widest_vector_mode has already looked into the optab,\n+     so skip these checks.  */\n+  if (compute_type == type)\n+    {\n+      compute_mode = TYPE_MODE (compute_type);\n+      if ((GET_MODE_CLASS (compute_mode) == MODE_VECTOR_INT\n+\t   || GET_MODE_CLASS (compute_mode) == MODE_VECTOR_FLOAT)\n+          && op != NULL\n+\t  && op->handlers[compute_mode].insn_code != CODE_FOR_nothing)\n+\treturn;\n+      else\n+\t/* There is no operation in hardware, so fall back to scalars.  */\n+\tcompute_type = TREE_TYPE (type);\n+    }\n+\n+  rhs = expand_vector_operation (bsi, type, compute_type, rhs, code);\n+  if (lang_hooks.types_compatible_p (TREE_TYPE (lhs), TREE_TYPE (rhs)))\n+    *p_rhs = rhs;\n+  else\n+    {\n+      /* Build a conversion; VIEW_CONVERT_EXPR is very expensive unless T will\n+         be stored in memory anyway, so prefer NOP_EXPR.  We should also try\n+\t performing the VIEW_CONVERT_EXPR on the left side of the\n+\t assignment.  */\n+      if (TYPE_MODE (TREE_TYPE (rhs)) == BLKmode)\n+        *p_rhs = gimplify_build1 (bsi, VIEW_CONVERT_EXPR, TREE_TYPE (lhs), rhs);\n+      else\n+\t*p_rhs = gimplify_build1 (bsi, NOP_EXPR, TREE_TYPE (lhs), rhs);\n+    }\n+\n+  mark_stmt_modified (bsi_stmt (*bsi));\n+}\n+\f\n+/* Use this to lower vector operations introduced by the vectorizer,\n+   if it may need the bit-twiddling tricks implemented in this file.  */\n+\n+static bool\n+gate_expand_vector_operations (void)\n+{\n+  return flag_tree_vectorize != 0;\n+}\n+\n+static void\n+expand_vector_operations (void)\n+{\n+  block_stmt_iterator bsi;\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      for (bsi = bsi_start (bb); !bsi_end_p (bsi); bsi_next (&bsi))\n+\t{\n+\t  expand_vector_operations_1 (&bsi);\n+\t  update_stmt_if_modified (bsi_stmt (bsi));\n+\t}\n+    }\n+}\n+\n+struct tree_opt_pass pass_lower_vector = \n+{\n+  \"veclower\",\t\t\t\t/* name */\n+  0,\t\t\t\t\t/* gate */\n+  expand_vector_operations,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_ggc_collect\n+    | TODO_verify_stmts,\t\t/* todo_flags_finish */\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+struct tree_opt_pass pass_lower_vector_ssa = \n+{\n+  \"veclower2\",\t\t\t\t/* name */\n+  gate_expand_vector_operations,\t/* gate */\n+  expand_vector_operations,\t\t/* execute */\n+  NULL,\t\t\t\t\t/* sub */\n+  NULL,\t\t\t\t\t/* next */\n+  0,\t\t\t\t\t/* static_pass_number */\n+  0,\t\t\t\t\t/* tv_id */\n+  PROP_cfg,\t\t\t\t/* properties_required */\n+  0,\t\t\t\t\t/* properties_provided */\n+  0,\t\t\t\t\t/* properties_destroyed */\n+  0,\t\t\t\t\t/* todo_flags_start */\n+  TODO_dump_func | TODO_update_ssa\t/* todo_flags_finish */\n+    | TODO_verify_ssa\n+    | TODO_verify_stmts | TODO_verify_flow,\n+  0\t\t\t\t\t/* letter */\n+};\n+\n+#include \"gt-tree-vect-generic.h\""}]}