{"sha": "275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mjc1YjRiYWE3MTAzZjE4MWJmMGQ3YTdlM2I5NzQ5N2Q2YjY3OGNlNg==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-04-06T10:16:30Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-04-06T10:16:30Z"}, "message": "ipa-inline.c (enum inlining_mode): Remove.\n\n2011-04-06  Richard Guenther  <rguenther@suse.de>\n \n\t* ipa-inline.c (enum inlining_mode): Remove.\n\t(cgraph_flatten): Use some other token.\n\t(cgraph_edge_early_inlinable_p): New function, split out from ...\n\t(cgraph_perform_always_inlining): New function, split out from ...\n\t(cgraph_decide_inlining_incrementally): ... here.\n\t(cgraph_mark_inline_edge): Adjust.\n\t(cgraph_early_inlining): Re-structure.\n\t(pass_early_inline): Require SSA form.\n\nFrom-SVN: r172033", "tree": {"sha": "043ab711d364844f688000af0f85a685eafed6c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/043ab711d364844f688000af0f85a685eafed6c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/275b4baa7103f181bf0d7a7e3b97497d6b678ce6/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "9adc580c20178d9f9924b90a8f6b7ad22da31037", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9adc580c20178d9f9924b90a8f6b7ad22da31037", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9adc580c20178d9f9924b90a8f6b7ad22da31037"}], "stats": {"total": 363, "additions": 178, "deletions": 185}, "files": [{"sha": "bc8a0711157db82973f3ddd32280bccc7f545f41", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275b4baa7103f181bf0d7a7e3b97497d6b678ce6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275b4baa7103f181bf0d7a7e3b97497d6b678ce6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "patch": "@@ -1,3 +1,14 @@\n+2011-04-06  Richard Guenther  <rguenther@suse.de>\n+ \n+\t* ipa-inline.c (enum inlining_mode): Remove.\n+\t(cgraph_flatten): Use some other token.\n+\t(cgraph_edge_early_inlinable_p): New function, split out from ...\n+\t(cgraph_perform_always_inlining): New function, split out from ...\n+\t(cgraph_decide_inlining_incrementally): ... here.\n+\t(cgraph_mark_inline_edge): Adjust.\n+\t(cgraph_early_inlining): Re-structure.\n+\t(pass_early_inline): Require SSA form.\n+\n 2011-03-06  Andrew Stubbs  <ams@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>\n \t    Mark Shinwell  <shinwell@codesourcery.com>"}, {"sha": "c41c20bc9f1ead7e9dcc32f3346321ad109ea85c", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 167, "deletions": 185, "changes": 352, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/275b4baa7103f181bf0d7a7e3b97497d6b678ce6/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/275b4baa7103f181bf0d7a7e3b97497d6b678ce6/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=275b4baa7103f181bf0d7a7e3b97497d6b678ce6", "patch": "@@ -126,28 +126,6 @@ along with GCC; see the file COPYING3.  If not see\n \n #define MAX_TIME 1000000000\n \n-/* Mode incremental inliner operate on:\n-\n-   In ALWAYS_INLINE only functions marked\n-   always_inline are inlined.  This mode is used after detecting cycle during\n-   flattening.\n-\n-   In SIZE mode, only functions that reduce function body size after inlining\n-   are inlined, this is used during early inlining.\n-\n-   in ALL mode, everything is inlined.  This is used during flattening.  */\n-enum inlining_mode {\n-  INLINE_NONE = 0,\n-  INLINE_ALWAYS_INLINE,\n-  INLINE_SIZE_NORECURSIVE,\n-  INLINE_SIZE,\n-  INLINE_ALL\n-};\n-\n-static bool\n-cgraph_decide_inlining_incrementally (struct cgraph_node *, enum inlining_mode);\n-static void cgraph_flatten (struct cgraph_node *node);\n-\n \n /* Statistics we collect about inlining algorithm.  */\n static int ncalls_inlined;\n@@ -351,9 +329,9 @@ cgraph_mark_inline_edge (struct cgraph_edge *e, bool update_original,\n     {\n       to = e->caller;\n       old_size = e->caller->global.size;\n-      new_size = cgraph_estimate_size_after_inlining (to, e);\n+      new_size = cgraph_estimate_size_after_inlining (to, curr);\n       to->global.size = new_size;\n-      to->global.time = cgraph_estimate_time_after_inlining (to, e);\n+      to->global.time = cgraph_estimate_time_after_inlining (to, curr);\n     }\n   gcc_assert (curr->callee->global.inlined_to == to);\n   if (new_size > old_size)\n@@ -1319,7 +1297,7 @@ cgraph_flatten (struct cgraph_node *node)\n   /* We shouldn't be called recursively when we are being processed.  */\n   gcc_assert (node->aux == NULL);\n \n-  node->aux = (void *)(size_t) INLINE_ALL;\n+  node->aux = (void *) node;\n \n   for (e = node->callees; e; e = e->next_callee)\n     {\n@@ -1393,7 +1371,7 @@ cgraph_flatten (struct cgraph_node *node)\n       orig_callee = e->callee;\n       cgraph_mark_inline_edge (e, true, NULL);\n       if (e->callee != orig_callee)\n-\torig_callee->aux = (void *)(size_t) INLINE_ALL;\n+\torig_callee->aux = (void *) node;\n       cgraph_flatten (e->callee);\n       if (e->callee != orig_callee)\n \torig_callee->aux = NULL;\n@@ -1572,162 +1550,159 @@ leaf_node_p (struct cgraph_node *n)\n   return true;\n }\n \n+/* Return true if the edge E is inlinable during early inlining.  */\n+\n+static bool\n+cgraph_edge_early_inlinable_p (struct cgraph_edge *e, FILE *file)\n+{\n+  if (!e->callee->local.inlinable)\n+    {\n+      if (file)\n+\tfprintf (file, \"Not inlining: Function not inlinable.\\n\");\n+      return false;\n+    }\n+  if (!e->callee->analyzed)\n+    {\n+      if (file)\n+\tfprintf (file, \"Not inlining: Function body not available.\\n\");\n+      return false;\n+    }\n+  if (!tree_can_inline_p (e)\n+      || e->call_stmt_cannot_inline_p)\n+    {\n+      if (file)\n+\tfprintf (file, \"Not inlining: %s.\\n\",\n+\t\t cgraph_inline_failed_string (e->inline_failed));\n+      return false;\n+    }\n+  if (!gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->caller->decl))\n+      || !gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n+    {\n+      if (file)\n+\tfprintf (file, \"Not inlining: not in SSA form.\\n\");\n+      return false;\n+    }\n+  return true;\n+}\n+\n+/* Inline always-inline function calls in NODE.  */\n+\n+static bool\n+cgraph_perform_always_inlining (struct cgraph_node *node)\n+{\n+  struct cgraph_edge *e;\n+  bool inlined = false;\n+\n+  for (e = node->callees; e; e = e->next_callee)\n+    {\n+      if (!e->callee->local.disregard_inline_limits)\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Considering always-inline candidate %s.\\n\",\n+\t\t cgraph_node_name (e->callee));\n+\n+      if (cgraph_edge_recursive_p (e))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n+\t  e->inline_failed = CIF_RECURSIVE_INLINING;\n+\t  continue;\n+\t}\n+\n+      if (!cgraph_edge_early_inlinable_p (e, dump_file))\n+\tcontinue;\n+\n+      if (dump_file)\n+\tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n+\t\t cgraph_node_name (e->callee),\n+\t\t cgraph_node_name (e->caller));\n+      cgraph_mark_inline_edge (e, true, NULL);\n+      inlined = true;\n+    }\n+\n+  return inlined;\n+}\n+\n /* Decide on the inlining.  We do so in the topological order to avoid\n    expenses on updating data structures.  */\n \n static bool\n-cgraph_decide_inlining_incrementally (struct cgraph_node *node,\n-\t\t\t\t      enum inlining_mode mode)\n+cgraph_decide_inlining_incrementally (struct cgraph_node *node)\n {\n   struct cgraph_edge *e;\n   bool inlined = false;\n   cgraph_inline_failed_t failed_reason;\n \n-#ifdef ENABLE_CHECKING\n-  verify_cgraph_node (node);\n-#endif\n+  /* Never inline regular functions into always-inline functions\n+     during incremental inlining.  */\n+  if (node->local.disregard_inline_limits)\n+    return false;\n \n-  if (mode != INLINE_ALWAYS_INLINE && mode != INLINE_SIZE_NORECURSIVE\n-      && lookup_attribute (\"flatten\", DECL_ATTRIBUTES (node->decl)) != NULL)\n+  for (e = node->callees; e; e = e->next_callee)\n     {\n+      int allowed_growth = 0;\n+\n+      if (!e->callee->local.inlinable\n+\t  || !e->inline_failed\n+\t  || e->callee->local.disregard_inline_limits)\n+\tcontinue;\n+\n+      /* Do not consider functions not declared inline.  */\n+      if (!DECL_DECLARED_INLINE_P (e->callee->decl)\n+\t  && !flag_inline_small_functions\n+\t  && !flag_inline_functions)\n+\tcontinue;\n+\n       if (dump_file)\n-\tfprintf (dump_file, \"Incrementally flattening %s\\n\",\n-\t\t cgraph_node_name (node));\n-      mode = INLINE_ALL;\n-    }\n+\tfprintf (dump_file, \"Considering inline candidate %s.\\n\",\n+\t\t cgraph_node_name (e->callee));\n \n-  /* First of all look for always inline functions.  */\n-  if (mode != INLINE_SIZE_NORECURSIVE)\n-    for (e = node->callees; e; e = e->next_callee)\n-      {\n-\tif (!e->callee->local.disregard_inline_limits\n-\t    && (mode != INLINE_ALL || !e->callee->local.inlinable))\n+      if (cgraph_edge_recursive_p (e))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n \t  continue;\n-\tif (dump_file)\n-\t  fprintf (dump_file,\n-\t\t   \"Considering to always inline inline candidate %s.\\n\",\n-\t\t   cgraph_node_name (e->callee));\n-\tif (cgraph_edge_recursive_p (e))\n-\t  {\n-\t    if (dump_file)\n-\t      fprintf (dump_file, \"Not inlining: recursive call.\\n\");\n-\t    continue;\n-\t  }\n-\tif (!tree_can_inline_p (e)\n-\t    || e->call_stmt_cannot_inline_p)\n-\t  {\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"Not inlining: %s\",\n-\t\t       cgraph_inline_failed_string (e->inline_failed));\n-\t    continue;\n-\t  }\n-\tif (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t    != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t  {\n-\t    if (dump_file)\n-\t      fprintf (dump_file, \"Not inlining: SSA form does not match.\\n\");\n-\t    continue;\n-\t  }\n-\tif (!e->callee->analyzed)\n-\t  {\n-\t    if (dump_file)\n-\t      fprintf (dump_file,\n-\t\t       \"Not inlining: Function body no longer available.\\n\");\n-\t    continue;\n-\t  }\n+\t}\n \n-\tif (dump_file)\n-\t  fprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t   cgraph_node_name (e->callee),\n-\t\t   cgraph_node_name (e->caller));\n-\tcgraph_mark_inline_edge (e, true, NULL);\n-\tinlined = true;\n-      }\n+      if (!cgraph_edge_early_inlinable_p (e, dump_file))\n+\tcontinue;\n \n-  /* Now do the automatic inlining.  */\n-  if (mode != INLINE_ALL && mode != INLINE_ALWAYS_INLINE\n-      /* Never inline regular functions into always-inline functions\n-\t during incremental inlining.  */\n-      && !node->local.disregard_inline_limits)\n-    {\n-      for (e = node->callees; e; e = e->next_callee)\n+      if (cgraph_maybe_hot_edge_p (e) && leaf_node_p (e->callee)\n+\t  && optimize_function_for_speed_p (cfun))\n+\tallowed_growth = PARAM_VALUE (PARAM_EARLY_INLINING_INSNS);\n+\n+      /* When the function body would grow and inlining the function\n+\t won't eliminate the need for offline copy of the function,\n+\t don't inline.  */\n+      if (cgraph_estimate_edge_growth (e) > allowed_growth\n+\t  && cgraph_estimate_growth (e->callee) > allowed_growth)\n \t{\n-\t  int allowed_growth = 0;\n-\t  if (!e->callee->local.inlinable\n-\t      || !e->inline_failed\n-\t      || e->callee->local.disregard_inline_limits)\n-\t    continue;\n \t  if (dump_file)\n-\t    fprintf (dump_file, \"Considering inline candidate %s.\\n\",\n-\t\t     cgraph_node_name (e->callee));\n-\t  if (cgraph_edge_recursive_p (e))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Not inlining: recursive call.\\n\");\n-\t      continue;\n-\t    }\n-\t  if (gimple_in_ssa_p (DECL_STRUCT_FUNCTION (node->decl))\n-\t      != gimple_in_ssa_p (DECL_STRUCT_FUNCTION (e->callee->decl)))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: SSA form does not match.\\n\");\n-\t      continue;\n-\t    }\n-\n-\t  if (cgraph_maybe_hot_edge_p (e) && leaf_node_p (e->callee)\n-\t      && optimize_function_for_speed_p (cfun))\n-\t    allowed_growth = PARAM_VALUE (PARAM_EARLY_INLINING_INSNS);\n-\n-\t  /* When the function body would grow and inlining the function\n-\t     won't eliminate the need for offline copy of the function,\n-\t     don't inline.  */\n-\t  if (((mode == INLINE_SIZE || mode == INLINE_SIZE_NORECURSIVE)\n-\t       || (!flag_inline_functions\n-\t\t   && !DECL_DECLARED_INLINE_P (e->callee->decl)))\n-\t      && cgraph_estimate_edge_growth (e) > allowed_growth\n-\t      && cgraph_estimate_growth (e->callee) > allowed_growth)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: code size would grow by %i.\\n\",\n-\t\t\t cgraph_estimate_edge_growth (e));\n-\t      continue;\n-\t    }\n-\t  if (e->call_stmt_cannot_inline_p\n-\t      || !tree_can_inline_p (e))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: call site not inlinable.\\n\");\n-\t      continue;\n-\t    }\n-\t  if (!e->callee->analyzed)\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file,\n-\t\t\t \"Not inlining: Function body no longer available.\\n\");\n-\t      continue;\n-\t    }\n-\t  if (!cgraph_check_inline_limits (e, &e->inline_failed))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \"Not inlining: %s.\\n\",\n-\t\t\t cgraph_inline_failed_string (e->inline_failed));\n-\t      continue;\n-\t    }\n-\t  if (cgraph_default_inline_p (e->callee, &failed_reason))\n-\t    {\n-\t      if (dump_file)\n-\t\tfprintf (dump_file, \" Inlining %s into %s.\\n\",\n-\t\t\t cgraph_node_name (e->callee),\n-\t\t\t cgraph_node_name (e->caller));\n-\t      cgraph_mark_inline_edge (e, true, NULL);\n-\t      inlined = true;\n-\t    }\n+\t    fprintf (dump_file,\n+\t\t     \"Not inlining: code size would grow by %i.\\n\",\n+\t\t     cgraph_estimate_edge_growth (e));\n+\t  continue;\n+\t}\n+      if (!cgraph_check_inline_limits (e, &e->inline_failed))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \"Not inlining: %s.\\n\",\n+\t\t     cgraph_inline_failed_string (e->inline_failed));\n+\t  continue;\n+\t}\n+      if (cgraph_default_inline_p (e->callee, &failed_reason))\n+\t{\n+\t  if (dump_file)\n+\t    fprintf (dump_file, \" Inlining %s into %s.\\n\",\n+\t\t     cgraph_node_name (e->callee),\n+\t\t     cgraph_node_name (e->caller));\n+\t  cgraph_mark_inline_edge (e, true, NULL);\n+\t  inlined = true;\n \t}\n     }\n+\n   return inlined;\n }\n \n@@ -1746,51 +1721,58 @@ cgraph_early_inlining (void)\n   struct cgraph_node *node = cgraph_node (current_function_decl);\n   unsigned int todo = 0;\n   int iterations = 0;\n+  bool inlined = false;\n \n   if (seen_error ())\n     return 0;\n \n+#ifdef ENABLE_CHECKING\n+  verify_cgraph_node (node);\n+#endif\n+\n+  /* Even when not optimizing or not inlining inline always-inline\n+     functions.  */\n+  inlined = cgraph_perform_always_inlining (node);\n+\n   if (!optimize\n       || flag_no_inline\n       || !flag_early_inlining)\n+    ;\n+  else if (lookup_attribute (\"flatten\",\n+\t\t\t     DECL_ATTRIBUTES (node->decl)) != NULL)\n     {\n-      /* When not optimizing or not inlining inline only always-inline\n-\t functions.  */\n-      cgraph_decide_inlining_incrementally (node, INLINE_ALWAYS_INLINE);\n-      timevar_push (TV_INTEGRATION);\n-      todo |= optimize_inline_calls (current_function_decl);\n-      timevar_pop (TV_INTEGRATION);\n+      /* When the function is marked to be flattened, recursively inline\n+\t all calls in it.  */\n+      if (dump_file)\n+\tfprintf (dump_file,\n+\t\t \"Flattening %s\\n\", cgraph_node_name (node));\n+      cgraph_flatten (node);\n+      inlined = true;\n     }\n   else\n     {\n-      if (lookup_attribute (\"flatten\",\n-\t\t\t    DECL_ATTRIBUTES (node->decl)) != NULL)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file,\n-\t\t     \"Flattening %s\\n\", cgraph_node_name (node));\n-\t  cgraph_flatten (node);\n-\t  timevar_push (TV_INTEGRATION);\n-\t  todo |= optimize_inline_calls (current_function_decl);\n-\t  timevar_pop (TV_INTEGRATION);\n-\t}\n       /* We iterate incremental inlining to get trivial cases of indirect\n \t inlining.  */\n       while (iterations < PARAM_VALUE (PARAM_EARLY_INLINER_MAX_ITERATIONS)\n-\t     && cgraph_decide_inlining_incrementally (node,\n-\t\t\t\t\t\t      iterations\n-\t\t\t\t\t\t      ? INLINE_SIZE_NORECURSIVE\n-\t\t\t\t\t\t      : INLINE_SIZE))\n+\t     && cgraph_decide_inlining_incrementally (node))\n \t{\n \t  timevar_push (TV_INTEGRATION);\n \t  todo |= optimize_inline_calls (current_function_decl);\n-\t  iterations++;\n \t  timevar_pop (TV_INTEGRATION);\n+\t  iterations++;\n+\t  inlined = false;\n \t}\n       if (dump_file)\n \tfprintf (dump_file, \"Iterations: %i\\n\", iterations);\n     }\n \n+  if (inlined)\n+    {\n+      timevar_push (TV_INTEGRATION);\n+      todo |= optimize_inline_calls (current_function_decl);\n+      timevar_pop (TV_INTEGRATION);\n+    }\n+\n   cfun->always_inline_functions_inlined = true;\n \n   return todo;\n@@ -1807,7 +1789,7 @@ struct gimple_opt_pass pass_early_inline =\n   NULL,\t\t\t\t\t/* next */\n   0,\t\t\t\t\t/* static_pass_number */\n   TV_INLINE_HEURISTICS,\t\t\t/* tv_id */\n-  0,\t                                /* properties_required */\n+  PROP_ssa,                             /* properties_required */\n   0,\t\t\t\t\t/* properties_provided */\n   0,\t\t\t\t\t/* properties_destroyed */\n   0,\t\t\t\t\t/* todo_flags_start */"}]}