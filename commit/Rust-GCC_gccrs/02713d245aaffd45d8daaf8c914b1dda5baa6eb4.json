{"sha": "02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI3MTNkMjQ1YWFmZmQ0NWQ4ZGFhZjhjOTE0YjFkZGE1YmFhNmViNA==", "commit": {"author": {"name": "bors[bot]", "email": "26634292+bors[bot]@users.noreply.github.com", "date": "2021-07-20T08:17:09Z"}, "committer": {"name": "GitHub", "email": "noreply@github.com", "date": "2021-07-20T08:17:09Z"}, "message": "Merge #577\n\n577: Initial type coercion code r=philberty a=philberty\n\nThis is the initial type coercion code. Coercions are necessary to implement\r\nmutability on reference types and for raw pointers in general.\r\n\r\nFixes #576 #352 \r\nAddresses #434 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>", "tree": {"sha": "c9119796d4330f6dda5d93f85de80044de723cb4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c9119796d4330f6dda5d93f85de80044de723cb4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "comment_count": 0, "verification": {"verified": true, "reason": "valid", "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJg9oaFCRBK7hj4Ov3rIwAAiK8IAIF2dlqWTwCK8C0gZBsrRZud\nkBJSKlSV+XvDYEGYzkea6oUUY2IkOb50C62AyzyqL/anY53pt2t0/WkZtJ/R6LH4\n8COL4ybFdch791TVSw4y5DWkAWGk3n+X4NZv60ZIhA5zul6BRKr2LbVt+gqsKtyJ\nl+uVf1cepvieg1Va26Aqu9XiujlUy+qWcaq/eI/3ifhkuIkubRTPGe6T/V263JUz\nzzaXFnIrptPu69ySfZLbp5/Ss5ky/yJnp5mhz5wyuKvpYaweI4HAh3XsIq0Zdq63\nNJVbTGb7Yb/NbPIywriHLE4J5JQGIgaZP4yyaGo2RAXx6q86WX551lrR2ovDXmw=\n=qF9+\n-----END PGP SIGNATURE-----\n", "payload": "tree c9119796d4330f6dda5d93f85de80044de723cb4\nparent eea221e39ead0f45e9ef91aaf1b5ed855a4a5d8b\nparent f56781662f82dcbe1780cbe3e7eb4ac17f8156d0\nauthor bors[bot] <26634292+bors[bot]@users.noreply.github.com> 1626769029 +0000\ncommitter GitHub <noreply@github.com> 1626769029 +0000\n\nMerge #577\n\n577: Initial type coercion code r=philberty a=philberty\n\nThis is the initial type coercion code. Coercions are necessary to implement\r\nmutability on reference types and for raw pointers in general.\r\n\r\nFixes #576 #352 \r\nAddresses #434 \n\nCo-authored-by: Philip Herron <philip.herron@embecosm.com>\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/comments", "author": {"login": "bors[bot]", "id": 26634292, "node_id": "MDM6Qm90MjY2MzQyOTI=", "avatar_url": "https://avatars.githubusercontent.com/in/1847?v=4", "gravatar_id": "", "url": "https://api.github.com/users/bors%5Bbot%5D", "html_url": "https://github.com/apps/bors", "followers_url": "https://api.github.com/users/bors%5Bbot%5D/followers", "following_url": "https://api.github.com/users/bors%5Bbot%5D/following{/other_user}", "gists_url": "https://api.github.com/users/bors%5Bbot%5D/gists{/gist_id}", "starred_url": "https://api.github.com/users/bors%5Bbot%5D/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/bors%5Bbot%5D/subscriptions", "organizations_url": "https://api.github.com/users/bors%5Bbot%5D/orgs", "repos_url": "https://api.github.com/users/bors%5Bbot%5D/repos", "events_url": "https://api.github.com/users/bors%5Bbot%5D/events{/privacy}", "received_events_url": "https://api.github.com/users/bors%5Bbot%5D/received_events", "type": "Bot", "site_admin": false}, "committer": {"login": "web-flow", "id": 19864447, "node_id": "MDQ6VXNlcjE5ODY0NDQ3", "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4", "gravatar_id": "", "url": "https://api.github.com/users/web-flow", "html_url": "https://github.com/web-flow", "followers_url": "https://api.github.com/users/web-flow/followers", "following_url": "https://api.github.com/users/web-flow/following{/other_user}", "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}", "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions", "organizations_url": "https://api.github.com/users/web-flow/orgs", "repos_url": "https://api.github.com/users/web-flow/repos", "events_url": "https://api.github.com/users/web-flow/events{/privacy}", "received_events_url": "https://api.github.com/users/web-flow/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eea221e39ead0f45e9ef91aaf1b5ed855a4a5d8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eea221e39ead0f45e9ef91aaf1b5ed855a4a5d8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eea221e39ead0f45e9ef91aaf1b5ed855a4a5d8b"}, {"sha": "f56781662f82dcbe1780cbe3e7eb4ac17f8156d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f56781662f82dcbe1780cbe3e7eb4ac17f8156d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f56781662f82dcbe1780cbe3e7eb4ac17f8156d0"}], "stats": {"total": 1510, "additions": 1428, "deletions": 82}, "files": [{"sha": "efca267e7d4d26b0326248e55ea42f18ca56e836", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -537,6 +537,10 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     Btype *base_compiled_type\n       = TyTyResolveCompile::compile (ctx, type.get_base ());\n     translated = ctx->get_backend ()->reference_type (base_compiled_type);\n+    if (!type.is_mutable ())\n+      {\n+\ttranslated = ctx->get_backend ()->immutable_type (translated);\n+      }\n   }\n \n   void visit (TyTy::StrType &type) override"}, {"sha": "b53cd4689fc82ff1a755e74eeda028972c61c902", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -348,7 +348,7 @@ class TypeCheckExpr : public TypeCheckBase\n     auto lhs = TypeCheckExpr::Resolve (expr.get_lhs (), false);\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs (), false);\n \n-    auto result = lhs->unify (rhs);\n+    auto result = lhs->coerce (rhs);\n     if (result->get_kind () == TyTy::TypeKind::ERROR)\n       return;\n \n@@ -547,8 +547,9 @@ class TypeCheckExpr : public TypeCheckBase\n \t  auto ok = context->lookup_builtin (\"str\", &base);\n \t  rust_assert (ok);\n \n-\t  infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t\t     TyTy::TyVar (base->get_ref ()));\n+\t  infered\n+\t    = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       TyTy::TyVar (base->get_ref ()), false);\n \t}\n \tbreak;\n \n@@ -1088,7 +1089,8 @@ class TypeCheckExpr : public TypeCheckBase\n     // FIXME double_reference\n \n     infered = new TyTy::ReferenceType (expr.get_mappings ().get_hirid (),\n-\t\t\t\t       TyTy::TyVar (resolved_base->get_ref ()));\n+\t\t\t\t       TyTy::TyVar (resolved_base->get_ref ()),\n+\t\t\t\t       expr.get_is_mut ());\n   }\n \n   void visit (HIR::DereferenceExpr &expr) override"}, {"sha": "1b6f47c1595737a81b39e08b8a60256fb1bd2b67", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -80,7 +80,7 @@ class TypeCheckStmt : public TypeCheckBase\n     // let x:i32 = 123;\n     if (specified_ty != nullptr && init_expr_ty != nullptr)\n       {\n-\tauto unified_ty = specified_ty->unify (init_expr_ty);\n+\tauto unified_ty = specified_ty->coerce (init_expr_ty);\n \tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n \t  return;\n "}, {"sha": "567d482a13bf21a0393e9d640734854e2dc460e3", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -190,7 +190,8 @@ class TypeCheckType : public TypeCheckBase\n     TyTy::BaseType *base\n       = TypeCheckType::Resolve (type.get_base_type ().get ());\n     translated = new TyTy::ReferenceType (type.get_mappings ().get_hirid (),\n-\t\t\t\t\t  TyTy::TyVar (base->get_ref ()));\n+\t\t\t\t\t  TyTy::TyVar (base->get_ref ()),\n+\t\t\t\t\t  type.get_has_mut ());\n   }\n \n   void visit (HIR::InferredType &type) override"}, {"sha": "5c10b0404f2a6c799bf46835cfb1ad33ea1ee4e3", "filename": "gcc/rust/typecheck/rust-tyty-coercion.h", "status": "added", "additions": 1198, "deletions": 0, "changes": 1198, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-coercion.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -0,0 +1,1198 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYTY_COERCION_RULES\n+#define RUST_TYTY_COERCION_RULES\n+\n+#include \"rust-diagnostics.h\"\n+#include \"rust-tyty.h\"\n+#include \"rust-tyty-visitor.h\"\n+#include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n+\n+extern ::Backend *\n+rust_get_backend ();\n+\n+namespace Rust {\n+namespace TyTy {\n+\n+class BaseCoercionRules : public TyVisitor\n+{\n+public:\n+  virtual ~BaseCoercionRules () {}\n+\n+  virtual BaseType *coerce (BaseType *other)\n+  {\n+    if (other->get_kind () == TypeKind::PARAM)\n+      {\n+\tParamType *p = static_cast<ParamType *> (other);\n+\tif (p->can_resolve ())\n+\t  {\n+\t    other = p->resolve ();\n+\t  }\n+      }\n+\n+    other->accept_vis (*this);\n+    if (resolved->get_kind () == TyTy::TypeKind::ERROR)\n+      return resolved;\n+\n+    resolved->append_reference (get_base ()->get_ref ());\n+    resolved->append_reference (other->get_ref ());\n+    for (auto ref : get_base ()->get_combined_refs ())\n+      resolved->append_reference (ref);\n+    for (auto ref : other->get_combined_refs ())\n+      resolved->append_reference (ref);\n+\n+    bool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+    bool result_is_infer_var = resolved->get_kind () == TyTy::TypeKind::INFER;\n+    bool results_is_non_general_infer_var\n+      = (result_is_infer_var\n+\t && (static_cast<InferType *> (resolved))->get_infer_kind ()\n+\t      != TyTy::InferType::GENERAL);\n+    if (result_resolved || results_is_non_general_infer_var)\n+      {\n+\tfor (auto &ref : resolved->get_combined_refs ())\n+\t  {\n+\t    TyTy::BaseType *ref_tyty = nullptr;\n+\t    bool ok = context->lookup_type (ref, &ref_tyty);\n+\t    if (!ok)\n+\t      continue;\n+\n+\t    // if any of the types are inference variables lets fix them\n+\t    if (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t      {\n+\t\tcontext->insert_type (\n+\t\t  Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t UNKNOWN_NODEID, ref,\n+\t\t\t\t\t UNKNOWN_LOCAL_DEFID),\n+\t\t  resolved->clone ());\n+\t      }\n+\t  }\n+      }\n+    return resolved;\n+  }\n+\n+  virtual void visit (TupleType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ADTType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (InferType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FnPtr &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ArrayType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (BoolType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (IntType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (UintType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (USizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ISizeType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (FloatType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ErrorType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (CharType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ReferenceType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (ParamType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (StrType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (NeverType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+  virtual void visit (PlaceholderType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    Location base_locus = mappings->lookup_location (get_base ()->get_ref ());\n+    RichLocation r (ref_locus);\n+    r.add_range (base_locus);\n+    rust_error_at (r, \"expected [%s] got [%s]\",\n+\t\t   get_base ()->as_string ().c_str (),\n+\t\t   type.as_string ().c_str ());\n+  }\n+\n+protected:\n+  BaseCoercionRules (BaseType *base)\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()),\n+      resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n+  {}\n+\n+  Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n+  /* Temporary storage for the result of a unification.\n+     We could return the result directly instead of storing it in the rule\n+     object, but that involves modifying the visitor pattern to accommodate\n+     the return value, which is too complex. */\n+  BaseType *resolved;\n+\n+private:\n+  /* Returns a pointer to the ty that created this rule. */\n+  virtual BaseType *get_base () = 0;\n+};\n+\n+class InferCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  InferCoercionRules (InferType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (USizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (ISizeType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = type.clone ();\n+\treturn;\n+\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (CharType &type) override\n+  {\n+    {\n+      bool is_valid\n+\t= (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+      if (is_valid)\n+\t{\n+\t  resolved = type.clone ();\n+\t  return;\n+\t}\n+\n+      BaseCoercionRules::visit (type);\n+    }\n+  }\n+\n+  void visit (ReferenceType &type) override\n+\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  InferType *base;\n+};\n+\n+class FnCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  FnCoercionRules (FnType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto a = base->param_at (i).second;\n+\tauto b = type.param_at (i).second;\n+\n+\tauto unified_param = a->unify (b);\n+\tif (unified_param == nullptr)\n+\t  {\n+\t    BaseCoercionRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    auto unified_return\n+      = base->get_return_type ()->unify (type.get_return_type ());\n+    if (unified_return == nullptr)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnType *base;\n+};\n+\n+class FnptrCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  FnptrCoercionRules (FnPtr *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnPtr &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i);\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCoercionRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FnType &type) override\n+  {\n+    auto this_ret_type = base->get_return_type ();\n+    auto other_ret_type = type.get_return_type ();\n+    auto unified_result = this_ret_type->unify (other_ret_type);\n+    if (unified_result == nullptr\n+\t|| unified_result->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_params () != type.num_params ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < base->num_params (); i++)\n+      {\n+\tauto this_param = base->param_at (i);\n+\tauto other_param = type.param_at (i).second;\n+\tauto unified_param = this_param->unify (other_param);\n+\tif (unified_param == nullptr\n+\t    || unified_param->get_kind () == TypeKind::ERROR)\n+\t  {\n+\t    BaseCoercionRules::visit (type);\n+\t    return;\n+\t  }\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FnPtr *base;\n+};\n+\n+class ArrayCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  ArrayCoercionRules (ArrayType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (ArrayType &type) override\n+  {\n+    // check base type\n+    auto base_resolved\n+      = base->get_element_type ()->unify (type.get_element_type ());\n+    if (base_resolved == nullptr)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    auto backend = rust_get_backend ();\n+\n+    // need to check the base types and capacity\n+    if (!backend->const_values_equal (type.get_capacity (),\n+\t\t\t\t      base->get_capacity ()))\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new ArrayType (type.get_ref (), type.get_ty_ref (),\n+\t\t       type.get_capacity (), TyVar (base_resolved->get_ref ()));\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ArrayType *base;\n+};\n+\n+class BoolCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  BoolCoercionRules (BoolType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (BoolType &type) override\n+  {\n+    resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    switch (type.get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = base->clone ();\n+\tbreak;\n+\n+      default:\n+\tBaseCoercionRules::visit (type);\n+\tbreak;\n+      }\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  BoolType *base;\n+};\n+\n+class IntCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  IntCoercionRules (IntType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    if (type.get_int_kind () != base->get_int_kind ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved\n+      = new IntType (type.get_ref (), type.get_ty_ref (), type.get_int_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  IntType *base;\n+};\n+\n+class UintCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  UintCoercionRules (UintType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    if (type.get_uint_kind () != base->get_uint_kind ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new UintType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t     type.get_uint_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  UintType *base;\n+};\n+\n+class FloatCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  FloatCoercionRules (FloatType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    if (type.get_float_kind () != base->get_float_kind ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = new FloatType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t      type.get_float_kind ());\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  FloatType *base;\n+};\n+\n+class ADTCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  ADTCoercionRules (ADTType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (ADTType &type) override\n+  {\n+    if (base->get_identifier ().compare (type.get_identifier ()) != 0)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    for (size_t i = 0; i < type.num_fields (); ++i)\n+      {\n+\tTyTy::StructFieldType *base_field = base->get_field (i);\n+\tTyTy::StructFieldType *other_field = type.get_field (i);\n+\n+\tTyTy::BaseType *this_field_ty = base_field->get_field_type ();\n+\tTyTy::BaseType *other_field_ty = other_field->get_field_type ();\n+\n+\tBaseType *unified_ty = this_field_ty->unify (other_field_ty);\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ADTType *base;\n+};\n+\n+class TupleCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  TupleCoercionRules (TupleType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (TupleType &type) override\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<TyVar> fields;\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tBaseType *bo = base->get_field (i);\n+\tBaseType *fo = type.get_field (i);\n+\n+\tBaseType *unified_ty = bo->unify (fo);\n+\tif (unified_ty->get_kind () == TyTy::TypeKind::ERROR)\n+\t  return;\n+\n+\tfields.push_back (TyVar (unified_ty->get_ref ()));\n+      }\n+\n+    resolved\n+      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  TupleType *base;\n+};\n+\n+class USizeCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  USizeCoercionRules (USizeType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (USizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  USizeType *base;\n+};\n+\n+class ISizeCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  ISizeCoercionRules (ISizeType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (InferType &type) override\n+  {\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (ISizeType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ISizeType *base;\n+};\n+\n+class CharCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  CharCoercionRules (CharType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n+  }\n+\n+  void visit (CharType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  CharType *base;\n+};\n+\n+class ReferenceCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  ReferenceCoercionRules (ReferenceType *base)\n+    : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  void visit (ReferenceType &type) override\n+  {\n+    auto base_type = base->get_base ();\n+    auto other_base_type = type.get_base ();\n+\n+    TyTy::BaseType *base_resolved = base_type->unify (other_base_type);\n+    if (base_resolved == nullptr\n+\t|| base_resolved->get_kind () == TypeKind::ERROR)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    // we can allow for mutability changes here by casting down from mutability\n+    // eg:  mut vs const, we cant take a mutable reference from a const\n+    // eg:  const vs mut we can take a const reference from a mutable one\n+    if (!base->is_mutable () || (base->is_mutable () == type.is_mutable ()))\n+      {\n+\tresolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n+\t\t\t\t      TyVar (base_resolved->get_ref ()),\n+\t\t\t\t      base->is_mutable ());\n+\treturn;\n+      }\n+\n+    BaseCoercionRules::visit (type);\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ReferenceType *base;\n+};\n+\n+class ParamCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  ParamCoercionRules (ParamType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  // param types are a placeholder we shouldn't have cases where we unify\n+  // against it. eg: struct foo<T> { a: T }; When we invoke it we can do either:\n+  //\n+  // foo<i32>{ a: 123 }.\n+  // Then this enforces the i32 type to be referenced on the\n+  // field via an hirid.\n+  //\n+  // rust also allows for a = foo{a:123}; Where we can use an Inference Variable\n+  // to handle the typing of the struct\n+  BaseType *coerce (BaseType *other) override final\n+  {\n+    if (base->get_ref () == base->get_ty_ref ())\n+      return BaseCoercionRules::coerce (other);\n+\n+    auto context = Resolver::TypeCheckContext::get ();\n+    BaseType *lookup = nullptr;\n+    bool ok = context->lookup_type (base->get_ty_ref (), &lookup);\n+    rust_assert (ok);\n+\n+    return lookup->unify (other);\n+  }\n+\n+  void visit (ParamType &type) override\n+  {\n+    if (base->get_symbol ().compare (type.get_symbol ()) != 0)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = type.clone ();\n+  }\n+\n+  void visit (InferType &type) override\n+  {\n+    if (type.get_infer_kind () != InferType::InferTypeKind::GENERAL)\n+      {\n+\tBaseCoercionRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+  }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  ParamType *base;\n+};\n+\n+class StrCoercionRules : public BaseCoercionRules\n+{\n+  // FIXME we will need a enum for the StrType like ByteBuf etc..\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  StrCoercionRules (StrType *base) : BaseCoercionRules (base), base (base) {}\n+\n+  void visit (StrType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  StrType *base;\n+};\n+\n+class NeverCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  NeverCoercionRules (NeverType *base) : BaseCoercionRules (base), base (base)\n+  {}\n+\n+  virtual void visit (NeverType &type) override { resolved = type.clone (); }\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  NeverType *base;\n+};\n+\n+class PlaceholderCoercionRules : public BaseCoercionRules\n+{\n+  using Rust::TyTy::BaseCoercionRules::visit;\n+\n+public:\n+  PlaceholderCoercionRules (PlaceholderType *base)\n+    : BaseCoercionRules (base), base (base)\n+  {}\n+\n+private:\n+  BaseType *get_base () override { return base; }\n+\n+  PlaceholderType *base;\n+};\n+\n+} // namespace TyTy\n+} // namespace Rust\n+\n+#endif // RUST_TYTY_COERCION_RULES"}, {"sha": "31d7191c351d6bca85874ef8316b8120a2ee15e8", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -1081,8 +1081,15 @@ class ReferenceRules : public BaseRules\n \treturn;\n       }\n \n+    if (base->is_mutable () != type.is_mutable ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n     resolved = new ReferenceType (base->get_ref (), base->get_ty_ref (),\n-\t\t\t\t  TyVar (base_resolved->get_ref ()));\n+\t\t\t\t  TyVar (base_resolved->get_ref ()),\n+\t\t\t\t  base->is_mutable ());\n   }\n \n private:"}, {"sha": "16bb01bf57b19ff36dfcd5efdffb164364150c0d", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 136, "deletions": 2, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-tyty-rules.h\"\n #include \"rust-tyty-cmp.h\"\n+#include \"rust-tyty-coercion.h\"\n #include \"rust-hir-map.h\"\n #include \"rust-substitution-mapper.h\"\n \n@@ -110,6 +111,13 @@ InferType::can_eq (const BaseType *other, bool emit_errors) const\n   return r.can_eq (other);\n }\n \n+BaseType *\n+InferType::coerce (BaseType *other)\n+{\n+  InferCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n BaseType *\n InferType::clone ()\n {\n@@ -172,6 +180,12 @@ ErrorType::can_eq (const BaseType *other, bool emit_errors) const\n   return get_kind () == other->get_kind ();\n }\n \n+BaseType *\n+ErrorType::coerce (BaseType *other)\n+{\n+  return this;\n+}\n+\n BaseType *\n ErrorType::clone ()\n {\n@@ -438,6 +452,13 @@ ADTType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+ADTType::coerce (BaseType *other)\n+{\n+  ADTCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n ADTType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -605,6 +626,13 @@ TupleType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+TupleType::coerce (BaseType *other)\n+{\n+  TupleCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n TupleType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -695,6 +723,13 @@ FnType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+FnType::coerce (BaseType *other)\n+{\n+  FnCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n FnType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -896,6 +931,13 @@ FnPtr::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+FnPtr::coerce (BaseType *other)\n+{\n+  FnptrCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n FnPtr::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -969,6 +1011,13 @@ ArrayType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+ArrayType::coerce (BaseType *other)\n+{\n+  ArrayCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n ArrayType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1030,6 +1079,13 @@ BoolType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+BoolType::coerce (BaseType *other)\n+{\n+  BoolCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n BoolType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1082,6 +1138,13 @@ IntType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+IntType::coerce (BaseType *other)\n+{\n+  IntCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n IntType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1145,6 +1208,13 @@ UintType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+UintType::coerce (BaseType *other)\n+{\n+  UintCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n UintType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1202,6 +1272,13 @@ FloatType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+FloatType::coerce (BaseType *other)\n+{\n+  FloatCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n FloatType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1251,6 +1328,13 @@ USizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+USizeType::coerce (BaseType *other)\n+{\n+  USizeCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n USizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1289,6 +1373,13 @@ ISizeType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+ISizeType::coerce (BaseType *other)\n+{\n+  ISizeCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n ISizeType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1327,6 +1418,13 @@ CharType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+CharType::coerce (BaseType *other)\n+{\n+  CharCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n CharType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1355,7 +1453,8 @@ ReferenceType::accept_vis (TyConstVisitor &vis) const\n std::string\n ReferenceType::as_string () const\n {\n-  return \"&\" + get_base ()->as_string ();\n+  return std::string (\"&\") + (is_mutable () ? \"mut\" : \"\") + \" \"\n+\t + get_base ()->as_string ();\n }\n \n BaseType *\n@@ -1365,6 +1464,13 @@ ReferenceType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+ReferenceType::coerce (BaseType *other)\n+{\n+  ReferenceCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n ReferenceType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1391,7 +1497,7 @@ ReferenceType::get_base () const\n BaseType *\n ReferenceType::clone ()\n {\n-  return new ReferenceType (get_ref (), get_ty_ref (), base,\n+  return new ReferenceType (get_ref (), get_ty_ref (), base, is_mutable (),\n \t\t\t    get_combined_refs ());\n }\n \n@@ -1446,6 +1552,13 @@ ParamType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+ParamType::coerce (BaseType *other)\n+{\n+  ParamCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n ParamType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1552,6 +1665,13 @@ StrType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+StrType::coerce (BaseType *other)\n+{\n+  StrCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n StrType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1590,6 +1710,13 @@ NeverType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+NeverType::coerce (BaseType *other)\n+{\n+  NeverCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n NeverType::can_eq (const BaseType *other, bool emit_errors) const\n {\n@@ -1628,6 +1755,13 @@ PlaceholderType::unify (BaseType *other)\n   return r.unify (other);\n }\n \n+BaseType *\n+PlaceholderType::coerce (BaseType *other)\n+{\n+  PlaceholderCoercionRules r (this);\n+  return r.coerce (other);\n+}\n+\n bool\n PlaceholderType::can_eq (const BaseType *other, bool emit_errors) const\n {"}, {"sha": "c0af9f6f5510aeb0f404099d3f703e42cbcd79d8", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 57, "deletions": 73, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -156,9 +156,20 @@ class BaseType\n   virtual BaseType *unify (BaseType *other) = 0;\n \n   // similar to unify but does not actually perform type unification but\n-  // determines whether they are compatible\n+  // determines whether they are compatible. Consider the following\n+  //\n+  // fn foo<T>() -> T { ... }\n+  // fn foo() -> i32 { ... }\n+  //\n+  // when the function has been substituted they can be considered equal.\n+  //\n+  // It can also be used to optional emit errors for trait item compatibility\n+  // checks\n   virtual bool can_eq (const BaseType *other, bool emit_errors) const = 0;\n \n+  // this is the base coercion interface for types\n+  virtual BaseType *coerce (BaseType *other) = 0;\n+\n   // Check value equality between two ty. Type inference rules are ignored. Two\n   //   ty are considered equal if they're of the same kind, and\n   //     1. (For ADTs, arrays, tuples, refs) have the same underlying ty\n@@ -279,6 +290,8 @@ class InferType : public BaseType\n \n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n \n+  BaseType *coerce (BaseType *other) override;\n+\n   BaseType *clone () final override;\n \n   InferTypeKind get_infer_kind () const { return infer_kind; }\n@@ -313,6 +326,7 @@ class ErrorType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -342,6 +356,7 @@ class ParamType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -428,6 +443,7 @@ class TupleType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -861,6 +877,7 @@ class ADTType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -981,6 +998,7 @@ class FnType : public BaseType, public SubstitutionRef\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1081,6 +1099,7 @@ class FnPtr : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1124,6 +1143,7 @@ class ArrayType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1164,6 +1184,7 @@ class BoolType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1198,6 +1219,7 @@ class IntType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   IntKind get_int_kind () const { return int_kind; }\n \n@@ -1239,6 +1261,7 @@ class UintType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   UintKind get_uint_kind () const { return uint_kind; }\n \n@@ -1278,6 +1301,7 @@ class FloatType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   FloatKind get_float_kind () const { return float_kind; }\n \n@@ -1293,22 +1317,12 @@ class USizeType : public BaseType\n {\n public:\n   USizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::USIZE)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ref, TypeKind::USIZE, refs)\n+  {}\n \n   USizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::USIZE)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ty_ref, TypeKind::USIZE, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1319,6 +1333,7 @@ class USizeType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1327,22 +1342,12 @@ class ISizeType : public BaseType\n {\n public:\n   ISizeType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::ISIZE)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ref, TypeKind::ISIZE, refs)\n+  {}\n \n   ISizeType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::ISIZE)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ty_ref, TypeKind::ISIZE, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1353,6 +1358,7 @@ class ISizeType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n@@ -1361,22 +1367,12 @@ class CharType : public BaseType\n {\n public:\n   CharType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::CHAR)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ref, TypeKind::CHAR, refs)\n+  {}\n \n   CharType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::CHAR)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ty_ref, TypeKind::CHAR, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n   void accept_vis (TyConstVisitor &vis) const override;\n@@ -1387,32 +1383,23 @@ class CharType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n };\n \n class ReferenceType : public BaseType\n {\n public:\n-  ReferenceType (HirId ref, TyVar base,\n+  ReferenceType (HirId ref, TyVar base, bool is_mut,\n \t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::REF), base (base)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ref, TypeKind::REF, refs), base (base), is_mut (is_mut)\n+  {}\n \n-  ReferenceType (HirId ref, HirId ty_ref, TyVar base,\n+  ReferenceType (HirId ref, HirId ty_ref, TyVar base, bool is_mut,\n \t\t std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::REF), base (base)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ty_ref, TypeKind::REF, refs), base (base), is_mut (is_mut)\n+  {}\n \n   BaseType *get_base () const;\n \n@@ -1425,6 +1412,7 @@ class ReferenceType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1437,30 +1425,23 @@ class ReferenceType : public BaseType\n \n   ReferenceType *handle_substitions (SubstitutionArgumentMappings mappings);\n \n+  bool is_mutable () const { return is_mut; }\n+\n private:\n   TyVar base;\n+  bool is_mut;\n };\n \n class StrType : public BaseType\n {\n public:\n   StrType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ref, TypeKind::STR)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ref, TypeKind::STR, refs)\n+  {}\n \n   StrType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n-    : BaseType (ref, ty_ref, TypeKind::STR)\n-  {\n-    // TODO unused; should 'refs' be passed as the last argument to the\n-    // 'BaseType' constructor call?  Potential change in behavior (if 'refs' is\n-    // provided by caller)?\n-    (void) refs;\n-  }\n+    : BaseType (ref, ty_ref, TypeKind::STR, refs)\n+  {}\n \n   std::string get_name () const override final { return as_string (); }\n \n@@ -1471,6 +1452,7 @@ class StrType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   bool is_equal (const BaseType &other) const override;\n \n@@ -1505,6 +1487,7 @@ class NeverType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n \n@@ -1534,6 +1517,7 @@ class PlaceholderType : public BaseType\n \n   BaseType *unify (BaseType *other) override;\n   bool can_eq (const BaseType *other, bool emit_errors) const override final;\n+  BaseType *coerce (BaseType *other) override;\n \n   BaseType *clone () final override;\n "}, {"sha": "3d979269cf222cd5152060d185de9176a26bfcf1", "filename": "gcc/testsuite/rust/compile/reference1.rs", "status": "added", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Freference1.rs?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -0,0 +1,5 @@\n+fn main() {\n+    let a = &123;\n+    let b: &mut i32 = a;\n+    // { dg-error \"expected .&mut i32. got .& i32.\" \"\" { target *-*-* } .-1 }\n+}"}, {"sha": "3bfa938ffdcb1e7cda0c3a94c0583c7c28d06999", "filename": "gcc/testsuite/rust/compile/torture/coercion1.rs", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcoercion1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/02713d245aaffd45d8daaf8c914b1dda5baa6eb4/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcoercion1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust%2Fcompile%2Ftorture%2Fcoercion1.rs?ref=02713d245aaffd45d8daaf8c914b1dda5baa6eb4", "patch": "@@ -0,0 +1,11 @@\n+pub fn main() {\n+    let a: &i32 = &123;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+    let b: &mut i32 = &mut 123;\n+\n+    let c: &i32 = &mut 123;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+\n+    let d: &i32 = b;\n+    // { dg-warning \"unused name\" \"\" { target *-*-* } .-1 }\n+}"}]}