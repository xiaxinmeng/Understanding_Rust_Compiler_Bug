{"sha": "d7cca31ee73010e683e963b4f65c8163e176b1b3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDdjY2EzMWVlNzMwMTBlNjgzZTk2M2I0ZjY1YzgxNjNlMTc2YjFiMw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@casey.cygnus.com", "date": "2000-02-28T16:55:40Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2000-02-28T16:55:40Z"}, "message": "search.c (protected_accessible_p): Also allow the access if the member is public in DERIVED.\n\n        * search.c (protected_accessible_p): Also allow the access if\n        the member is public in DERIVED.  Lose TYPE parm.\n        (friend_accessible_p): Lose TYPE parm.\n        (accessible_p): Adjust.\n\nFrom-SVN: r32238", "tree": {"sha": "7263e0f1896a62f1b3d50a177d4bdb162a3c27c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7263e0f1896a62f1b3d50a177d4bdb162a3c27c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d7cca31ee73010e683e963b4f65c8163e176b1b3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cca31ee73010e683e963b4f65c8163e176b1b3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d7cca31ee73010e683e963b4f65c8163e176b1b3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d7cca31ee73010e683e963b4f65c8163e176b1b3/comments", "author": null, "committer": null, "parents": [{"sha": "0ca5aade1421135756a3263fbce9b6f2e37ac29c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0ca5aade1421135756a3263fbce9b6f2e37ac29c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0ca5aade1421135756a3263fbce9b6f2e37ac29c"}], "stats": {"total": 72, "additions": 37, "deletions": 35}, "files": [{"sha": "5c750f2fe468e3a67d31394bd38879c4203bc197", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cca31ee73010e683e963b4f65c8163e176b1b3/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cca31ee73010e683e963b4f65c8163e176b1b3/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=d7cca31ee73010e683e963b4f65c8163e176b1b3", "patch": "@@ -1,3 +1,10 @@\n+2000-02-28  Jason Merrill  <jason@casey.cygnus.com>\n+\n+\t* search.c (protected_accessible_p): Also allow the access if\n+\tthe member is public in DERIVED.  Lose TYPE parm.\n+\t(friend_accessible_p): Lose TYPE parm.\n+\t(accessible_p): Adjust.\n+\n Sun Feb 27 16:40:33 2000  Richard Kenner  <kenner@vlsi1.ultra.nyu.edu>\n \n \t* class.c (dfs_build_vtable_offset_vtbl_entries): Don't use size_binop"}, {"sha": "751b633ef21a20564a0ba53848888afeeb846470", "filename": "gcc/cp/search.c", "status": "modified", "additions": 30, "deletions": 35, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d7cca31ee73010e683e963b4f65c8163e176b1b3/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d7cca31ee73010e683e963b4f65c8163e176b1b3/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=d7cca31ee73010e683e963b4f65c8163e176b1b3", "patch": "@@ -140,8 +140,8 @@ static tree access_in_type PARAMS ((tree, tree));\n static tree dfs_canonical_queue PARAMS ((tree, void *));\n static tree dfs_assert_unmarked_p PARAMS ((tree, void *));\n static void assert_canonical_unmarked PARAMS ((tree));\n-static int protected_accessible_p PARAMS ((tree, tree, tree, tree));\n-static int friend_accessible_p PARAMS ((tree, tree, tree, tree));\n+static int protected_accessible_p PARAMS ((tree, tree, tree));\n+static int friend_accessible_p PARAMS ((tree, tree, tree));\n static void setup_class_bindings PARAMS ((tree, int));\n static int template_self_reference_p PARAMS ((tree, tree));\n static void fixup_all_virtual_upcast_offsets PARAMS ((tree, tree));\n@@ -969,12 +969,11 @@ dfs_accessible_p (binfo, data)\n   return NULL_TREE;\n }\n \n-/* Returns non-zero if it is OK to access DECL when named in TYPE\n-   through an object indiated by BINFO in the context of DERIVED.  */\n+/* Returns non-zero if it is OK to access DECL through an object\n+   indiated by BINFO in the context of DERIVED.  */\n \n static int\n-protected_accessible_p (type, decl, derived, binfo)\n-     tree type;\n+protected_accessible_p (decl, derived, binfo)\n      tree decl;\n      tree derived;\n      tree binfo;\n@@ -988,27 +987,31 @@ protected_accessible_p (type, decl, derived, binfo)\n        class P derived from N, where m as a member of P is private or\n        protected.  \n \n-    If DERIVED isn't derived from TYPE, then it certainly does not\n-    apply.  */\n-  if (!DERIVED_FROM_P (type, derived))\n+    Here DERIVED is a possible P and DECL is m.  accessible_p will\n+    iterate over various values of N, but the access to m in DERIVED\n+    does not change.\n+\n+    Note that I believe that the passage above is wrong, and should read\n+    \"...is private or protected or public\"; otherwise you get bizarre results\n+    whereby a public using-decl can prevent you from accessing a protected\n+    member of a base.  (jason 2000/02/28)  */\n+\n+  /* If DERIVED isn't derived from m's class, then it can't be a P.  */\n+  if (!DERIVED_FROM_P (DECL_CONTEXT (decl), derived))\n     return 0;\n \n   access = access_in_type (derived, decl);\n-  if (same_type_p (derived, type))\n-    {\n-      if (access != access_private_node)\n-\treturn 0;\n-    }\n-  else if (access != access_private_node\n-\t   && access != access_protected_node)\n+\n+  /* If m is inaccessible in DERIVED, then it's not a P.  */\n+  if (access == NULL_TREE)\n     return 0;\n   \n   /* [class.protected]\n \n      When a friend or a member function of a derived class references\n      a protected nonstatic member of a base class, an access check\n      applies in addition to those described earlier in clause\n-     _class.access_.4) Except when forming a pointer to member\n+     _class.access_) Except when forming a pointer to member\n      (_expr.unary.op_), the access must be through a pointer to,\n      reference to, or object of the derived class itself (or any class\n      derived from that class) (_expr.ref_).  If the access is to form\n@@ -1030,13 +1033,11 @@ protected_accessible_p (type, decl, derived, binfo)\n }\n \n /* Returns non-zero if SCOPE is a friend of a type which would be able\n-   to acces DECL, named in TYPE, through the object indicated by\n-   BINFO.  */\n+   to access DECL through the object indicated by BINFO.  */\n \n static int\n-friend_accessible_p (scope, type, decl, binfo)\n+friend_accessible_p (scope, decl, binfo)\n      tree scope;\n-     tree type;\n      tree decl;\n      tree binfo;\n {\n@@ -1055,14 +1056,14 @@ friend_accessible_p (scope, type, decl, binfo)\n     return 0;\n \n   for (t = befriending_classes; t; t = TREE_CHAIN (t))\n-    if (protected_accessible_p (type, decl, TREE_VALUE (t), binfo))\n+    if (protected_accessible_p (decl, TREE_VALUE (t), binfo))\n       return 1;\n \n   /* Nested classes are implicitly friends of their enclosing types, as\n      per core issue 45 (this is a change from the standard).  */\n   if (TYPE_P (scope))\n     for (t = TYPE_CONTEXT (scope); t && TYPE_P (t); t = TYPE_CONTEXT (t))\n-      if (protected_accessible_p (type, decl, t, binfo))\n+      if (protected_accessible_p (decl, t, binfo))\n \treturn 1;\n \n   if (TREE_CODE (scope) == FUNCTION_DECL\n@@ -1071,18 +1072,15 @@ friend_accessible_p (scope, type, decl, binfo)\n       /* Perhaps this SCOPE is a member of a class which is a \n \t friend.  */ \n       if (DECL_CLASS_SCOPE_P (decl)\n-\t  && friend_accessible_p (DECL_CONTEXT (scope), type,\n-\t\t\t\t  decl, binfo))\n+\t  && friend_accessible_p (DECL_CONTEXT (scope), decl, binfo))\n \treturn 1;\n \n       /* Or an instantiation of something which is a friend.  */\n       if (DECL_TEMPLATE_INFO (scope))\n-\treturn friend_accessible_p (DECL_TI_TEMPLATE (scope),\n-\t\t\t\t    type, decl, binfo);\n+\treturn friend_accessible_p (DECL_TI_TEMPLATE (scope), decl, binfo);\n     }\n   else if (CLASSTYPE_TEMPLATE_INFO (scope))\n-    return friend_accessible_p (CLASSTYPE_TI_TEMPLATE (scope),\n-\t\t\t\ttype, decl, binfo);\n+    return friend_accessible_p (CLASSTYPE_TI_TEMPLATE (scope), decl, binfo);\n \n   return 0;\n }\n@@ -1178,16 +1176,13 @@ accessible_p (type, decl)\n \n   /* Figure out where the reference is occurring.  Check to see if\n      DECL is private or protected in this scope, since that will\n-     determine whether protected access in TYPE allowed.  */\n+     determine whether protected access is allowed.  */\n   if (current_class_type)\n-    protected_ok \n-      = protected_accessible_p (type, decl, current_class_type,\n-\t\t\t\tbinfo);\n+    protected_ok = protected_accessible_p (decl, current_class_type, binfo);\n \n   /* Now, loop through the classes of which we are a friend.  */\n   if (!protected_ok)\n-    protected_ok = friend_accessible_p (current_scope (),\n-\t\t\t\t\ttype, decl, binfo);\n+    protected_ok = friend_accessible_p (current_scope (), decl, binfo);\n \n   /* Standardize the binfo that access_in_type will use.  We don't\n      need to know what path was chosen from this point onwards.  */"}]}