{"sha": "6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRlOWNkOWE4ODZlYTY5NWFhODkyYzNjN2MwNzgxOGE3YjdlOWU2Zg==", "commit": {"author": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-05-13T06:41:07Z"}, "committer": {"name": "Diego Novillo", "email": "dnovillo@gcc.gnu.org", "date": "2004-05-13T06:41:07Z"}, "message": "Merge tree-ssa-20020619-branch into mainline.\n\nFrom-SVN: r81764", "tree": {"sha": "a2568888a519c077427b133de9ece5879a8484a5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a2568888a519c077427b133de9ece5879a8484a5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/comments", "author": null, "committer": null, "parents": [{"sha": "ac1a20aec53364d77f3bdff94a2a0a06840e0fe9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ac1a20aec53364d77f3bdff94a2a0a06840e0fe9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ac1a20aec53364d77f3bdff94a2a0a06840e0fe9"}], "stats": {"total": 291591, "additions": 280216, "deletions": 11375}, "files": [{"sha": "34e409138dac7e5458948be9e4b1b61389f523af", "filename": "ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/ChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/ChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1,3 +1,28 @@\n+2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-ssa-20020619-branch.\n+\n+\t* Makefile.def: Add libbanshee, libmudflap and libgfortran.\n+\t* Makefile.tpl (BUILD_CONFIGDIRS): Add libbanshee.\n+\t(HOST_GMPLIBS): Define.\n+\t(HOST_GMPINC): Define.\n+\t(TARGET_LIB_PATH): Add libmudflap.\n+\t(GFORTRAN_FOR_TARGET): Define.\n+\t(configure-build*): Export GFORTRAN.\n+\t(configure-gcc): Export GMPLIBS and GMPINC.\n+\t(all-gcc): Add maybe-all-libbanshee.\n+\t(configure-target-libgfortran): Define.\n+\t* Makefile.in: Regenerate.\n+\t* configure.in (host_libs): Add libbanshee.\n+\t(target_libraries): Add target-libmudflap and target-libgfortran.\n+\tAdd --with-libbanshee.\n+\tHandle --disable-libmudflap.\n+\t(*-*-freebsd*): Use with_gmp.\n+\tAdd $(libgcj) to noconfigdirs.\n+\t* configure: Regenerate.\n+\t* depcomp: New file.\n+\t* MAINTAINERS: Add tree-ssa maintainers.\n+\n 2004-05-04  Vladimir Makarov  <vmakarov@redhat.com>\n \n         * MAINTAINERS (Various Maintainers): Add myself."}, {"sha": "9ada8f03e7fccc3d26d16893897de3532dcb4eb0", "filename": "ChangeLog.tree-ssa", "status": "added", "additions": 110, "deletions": 0, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/ChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/ChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/ChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,110 @@\n+2004-05-03  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\t* configure.in (GMP checking): s/save_CFLAGS/saved_CFLAGS.\n+\t* configure: Regenerate.\n+\n+2004-04-22  Loren J. Rittle <ljrittle@acm.org>\n+\n+\t* configure.in (*-*-freebsd*): Use with_gmp to \"Avoid crusty gmp.h.\"\n+\t* configure: Rebuilt (with autoconf version 2.13).\n+\n+2004-04-17  Paul Brook  <paul@codesourcery.com>\n+\n+\t* Makefile.tmp (EXTRA_HOST_FLAGS): Remove GMPLIBS and GMPINC.\n+\t(configure-gcc): Set GMPLIBS and GMPINC.\n+\t* Makefile.in: Regenerate.\n+\n+2004-04-14  Paul Brook  <paul@codesourcery.com>\n+\n+\t* Makefile.tmp (HOST_GMPLIBS, HOST_GMPINC): New variables.\n+\t(EXTRA_HOST_FLAGS): Pass them.\n+\t* configure.in: Add check for GMP.  Disable languages if not found.\n+\t* Makefile.in, configure: Regenrate.\n+\n+2004-03-29  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* configure.in: Set with_libbansshee to yes by default.\n+\t* configure: Regenerate.\n+\n+2004-03-28  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* configure.in: Fix handling of --without-libbanshee.\n+\t* configure: Regenerate.\n+\n+2004-03-26  Nathanael Nerode  <neroden@gcc.gnu.org>\n+\n+\t* configure.in: Add support for --without-libbanshee.\n+\t* configure: Regenerated.\n+\n+2004-02-17  Brian Booth  <bbooth@redhat.com>\n+\n+\t* MAINTAINERS.tree-ssa: Add self to write after approval.\n+\n+2004-02-13  Loren J. Rittle <ljrittle@acm.org>\n+\n+\t* configure.in (*-*-freebsd*): Avoid crusty gmp.h.\n+\t(alpha*-*-*freebsd*, i[[3456789]]86-*-*freebsd*): Merge into above.\n+\t* configure: Rebuilt (with autoconf version 2.13).\n+\n+2003-10-22  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* configure.in: Add support for \"--disable-libmudflap\" option.\n+\t* configure: Regenerated.\n+\n+2003-09-22  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* MAINTAINERS.tree-ssa: Add Andrew MacLeod as global maintainer for\n+\tthe branch.\n+\n+2003-08-23  Paul Brook  <paul@nowt.org>\n+\n+\t* Makefile.in: Regenerate.\n+\n+2003-07-26  Paul Brook  <paul@nowt.org>\n+\n+\t* Makefile.def: Add libgfortran and GFORTRAN_FOR_TARGET.\n+\t* Makefile.tmp: Ditto.\n+\t* configure.in: Ditto.\n+\t* depcomp: New file.\n+\t* maintainer-scripts/gcc_release: Add gcc-fortran.\n+\t* maintainer-scripts/snapshot-README: Ditto.\n+\t* maintainer-scripts/snapshot-index.html: Ditto.\n+\t* libgfortran: New target library.\n+\n+2003-06-05  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* Makefile.in: Regenerated to activate libmudflap builds.\n+\n+2003-04-25  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* MAINTAINERS.tree-ssa: New file.\n+\n+2003-01-29  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* configure.in: Use ac_configure_args for libbanshee option\n+\t* configure: regen.\n+\n+2002-11-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Makefile.tpl (all-gcc, all-bootstrap): Add dependency on \n+\tall-libbanshee.\n+\t* Makefile.in: Regenerate.\n+\n+2002-11-25  Daniel Berlin  <dberlin@dberlin.org>\n+\t\n+\t* Makefile.def: Diego already did the libmudflap moving in a merge,\n+\tso remove the extra i added.\n+\t* Makefile.in: Regenerate.\n+\n+2002-11-24  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* configure.in: Add libbanshee related stuff.\n+\t* Makefile.in: Regenerate from Makefile.def.\n+\t* Makefile.def: Move libmudflap stuff to here, where it belongs.\n+\tAdd libbanshee stuff.\n+\t* Makefile.tpl: Add libbanshee stuff.\n+\n+2002-08-12  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* Makefile.in (target-libmudflap): Add libmudflap-related targets.\n+\t* configure.in (target_libs): Ditto."}, {"sha": "14dac9b630e50c38ae768030d9b05aadb8d343f1", "filename": "MAINTAINERS", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/MAINTAINERS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/MAINTAINERS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/MAINTAINERS?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -170,6 +170,11 @@ gcov\t\t\tNathan Sidwell\t\tnathan@codesourcery.com\n option handling\t\tNeil Booth\t\tneil@daikokuya.co.uk\n libffi testsuite\tAndreas Tobler\t\tandreast@gcc.gnu.org\n middle-end\t\tRoger Sayle\t\troger@eyesopen.com\n+tree-ssa\t\tDiego Novillo\t\tdnovillo@redhat.com\n+tree-ssa\t\tAndrew MacLeod\t\tamacleod@redhat.com\n+PRE, points-to\t\tDaniel Berlin\t\tdberlin@dberlin.org\n+mudflap\t\t\tFrank Ch. Eigler\tfche@redhat.com\n+tree browser/unparser\tSebastian Pop\t\ts.pop@laposte.net\n \n Note individuals who maintain parts of the compiler need approval to check\n in changes outside of the parts of the compiler they maintain."}, {"sha": "5f293680ae269635234f7895dae7aae939da2130", "filename": "Makefile.def", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -25,6 +25,7 @@ AutoGen definitions Makefile.tpl;\n // that recursive target in its Makefile.\n \n build_modules= { module= libiberty; };\n+build_modules= { module= libbanshee; };\n \n host_modules= { module= ash; };\n host_modules= { module= autoconf; };\n@@ -59,6 +60,7 @@ host_modules= { module= tcl;\n host_modules= { module= itcl; };\n host_modules= { module= ld; bootstrap=true; };\n host_modules= { module= libgui; };\n+host_modules= { module= libbanshee; bootstrap=true; no_install=true; };\n host_modules= { module= libiberty; bootstrap=true; };\n host_modules= { module= libtool; };\n host_modules= { module= m4; };\n@@ -97,8 +99,10 @@ host_modules= { module= libtermcap; no_check=true;\n host_modules= { module= utils; no_check=true; };\n \n target_modules = { module= libstdc++-v3; raw_cxx=true; };\n+target_modules = { module= libmudflap; };\n target_modules = { module= newlib; };\n target_modules = { module= libf2c; };\n+target_modules = { module= libgfortran; };\n target_modules = { module= libobjc; };\n target_modules = { module= libtermcap; no_check=true; stage=true;\n                    missing=mostlyclean;\n@@ -202,6 +206,7 @@ flags_to_pass = { flag= CXX_FOR_TARGET ; };\n flags_to_pass = { flag= CXXFLAGS_FOR_TARGET ; };\n flags_to_pass = { flag= DLLTOOL_FOR_TARGET ; };\n flags_to_pass = { flag= GCJ_FOR_TARGET ; };\n+flags_to_pass = { flag= GFORTRAN_FOR_TARGET ; };\n flags_to_pass = { flag= LD_FOR_TARGET ; };\n flags_to_pass = { flag= LIBCFLAGS_FOR_TARGET ; };\n flags_to_pass = { flag= LIBCXXFLAGS_FOR_TARGET ; };"}, {"sha": "ff065ac1ce632affb9a52bc905bd654a0f5da92b", "filename": "Makefile.in", "status": "modified", "additions": 982, "deletions": 25, "changes": 1007, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -102,7 +102,7 @@ REALLY_SET_LIB_PATH = \\\n   $(RPATH_ENVVAR)=`echo \"$(HOST_LIB_PATH):$(TARGET_LIB_PATH):$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);\n \n # This is the list of directories to be built for the build system.\n-BUILD_CONFIGDIRS = libiberty\n+BUILD_CONFIGDIRS = libiberty libbanshee\n # Build programs are put under this directory.\n BUILD_SUBDIR = @build_subdir@\n # This is set by the configure script to the arguments to use when configuring\n@@ -124,6 +124,10 @@ TARGET_SUBDIR = @target_subdir@\n # directories built for the target.\n TARGET_CONFIGARGS = @target_configargs@\n \n+# Where to find GMP\n+HOST_GMPLIBS = @gmplibs@\n+HOST_GMPINC = @gmpinc@\n+\n # ----------------------------------------------\n # Programs producing files for the BUILD machine\n # ----------------------------------------------\n@@ -241,7 +245,7 @@ PICFLAG =\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that prorgams built for the target machine work.\n-TARGET_LIB_PATH = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n+TARGET_LIB_PATH = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:$$r/$(TARGET_SUBDIR)/libmudflap/.libs\n \n FLAGS_FOR_TARGET = @FLAGS_FOR_TARGET@\n \n@@ -308,6 +312,7 @@ USUAL_DLLTOOL_FOR_TARGET = ` \\\n   fi`\n \n GCJ_FOR_TARGET = @GCJ_FOR_TARGET@\n+GFORTRAN_FOR_TARGET = @GFORTRAN_FOR_TARGET@\n \n LD_FOR_TARGET=@LD_FOR_TARGET@\n CONFIGURED_LD_FOR_TARGET=@CONFIGURED_LD_FOR_TARGET@\n@@ -446,6 +451,7 @@ BASE_FLAGS_TO_PASS = \\\n \t\"CXXFLAGS_FOR_TARGET=$(CXXFLAGS_FOR_TARGET)\" \\\n \t\"DLLTOOL_FOR_TARGET=$(DLLTOOL_FOR_TARGET)\" \\\n \t\"GCJ_FOR_TARGET=$(GCJ_FOR_TARGET)\" \\\n+\t\"GFORTRAN_FOR_TARGET=$(GFORTRAN_FOR_TARGET)\" \\\n \t\"LD_FOR_TARGET=$(LD_FOR_TARGET)\" \\\n \t\"LIBCFLAGS_FOR_TARGET=$(LIBCFLAGS_FOR_TARGET)\" \\\n \t\"LIBCXXFLAGS_FOR_TARGET=$(LIBCXXFLAGS_FOR_TARGET)\" \\\n@@ -568,6 +574,7 @@ configure-host: maybe-configure-gcc  \\\n     maybe-configure-itcl \\\n     maybe-configure-ld \\\n     maybe-configure-libgui \\\n+    maybe-configure-libbanshee \\\n     maybe-configure-libiberty \\\n     maybe-configure-libtool \\\n     maybe-configure-m4 \\\n@@ -603,8 +610,10 @@ configure-host: maybe-configure-gcc  \\\n .PHONY: configure-target\n configure-target:  \\\n     maybe-configure-target-libstdc++-v3 \\\n+    maybe-configure-target-libmudflap \\\n     maybe-configure-target-newlib \\\n     maybe-configure-target-libf2c \\\n+    maybe-configure-target-libgfortran \\\n     maybe-configure-target-libobjc \\\n     maybe-configure-target-libtermcap \\\n     maybe-configure-target-winsup \\\n@@ -658,6 +667,7 @@ all-host: maybe-all-gcc  \\\n     maybe-all-itcl \\\n     maybe-all-ld \\\n     maybe-all-libgui \\\n+    maybe-all-libbanshee \\\n     maybe-all-libiberty \\\n     maybe-all-libtool \\\n     maybe-all-m4 \\\n@@ -693,8 +703,10 @@ all-host: maybe-all-gcc  \\\n .PHONY: all-target\n all-target:  \\\n     maybe-all-target-libstdc++-v3 \\\n+    maybe-all-target-libmudflap \\\n     maybe-all-target-newlib \\\n     maybe-all-target-libf2c \\\n+    maybe-all-target-libgfortran \\\n     maybe-all-target-libobjc \\\n     maybe-all-target-libtermcap \\\n     maybe-all-target-winsup \\\n@@ -752,6 +764,7 @@ info-host: maybe-info-gcc  \\\n     maybe-info-itcl \\\n     maybe-info-ld \\\n     maybe-info-libgui \\\n+    maybe-info-libbanshee \\\n     maybe-info-libiberty \\\n     maybe-info-libtool \\\n     maybe-info-m4 \\\n@@ -788,8 +801,10 @@ info-host: maybe-info-gcc  \\\n .PHONY: info-target\n info-target:  \\\n     maybe-info-target-libstdc++-v3 \\\n+    maybe-info-target-libmudflap \\\n     maybe-info-target-newlib \\\n     maybe-info-target-libf2c \\\n+    maybe-info-target-libgfortran \\\n     maybe-info-target-libobjc \\\n     maybe-info-target-libtermcap \\\n     maybe-info-target-winsup \\\n@@ -842,6 +857,7 @@ dvi-host: maybe-dvi-gcc  \\\n     maybe-dvi-itcl \\\n     maybe-dvi-ld \\\n     maybe-dvi-libgui \\\n+    maybe-dvi-libbanshee \\\n     maybe-dvi-libiberty \\\n     maybe-dvi-libtool \\\n     maybe-dvi-m4 \\\n@@ -878,8 +894,10 @@ dvi-host: maybe-dvi-gcc  \\\n .PHONY: dvi-target\n dvi-target:  \\\n     maybe-dvi-target-libstdc++-v3 \\\n+    maybe-dvi-target-libmudflap \\\n     maybe-dvi-target-newlib \\\n     maybe-dvi-target-libf2c \\\n+    maybe-dvi-target-libgfortran \\\n     maybe-dvi-target-libobjc \\\n     maybe-dvi-target-libtermcap \\\n     maybe-dvi-target-winsup \\\n@@ -932,6 +950,7 @@ TAGS-host: maybe-TAGS-gcc  \\\n     maybe-TAGS-itcl \\\n     maybe-TAGS-ld \\\n     maybe-TAGS-libgui \\\n+    maybe-TAGS-libbanshee \\\n     maybe-TAGS-libiberty \\\n     maybe-TAGS-libtool \\\n     maybe-TAGS-m4 \\\n@@ -968,8 +987,10 @@ TAGS-host: maybe-TAGS-gcc  \\\n .PHONY: TAGS-target\n TAGS-target:  \\\n     maybe-TAGS-target-libstdc++-v3 \\\n+    maybe-TAGS-target-libmudflap \\\n     maybe-TAGS-target-newlib \\\n     maybe-TAGS-target-libf2c \\\n+    maybe-TAGS-target-libgfortran \\\n     maybe-TAGS-target-libobjc \\\n     maybe-TAGS-target-libtermcap \\\n     maybe-TAGS-target-winsup \\\n@@ -1022,6 +1043,7 @@ install-info-host: maybe-install-info-gcc  \\\n     maybe-install-info-itcl \\\n     maybe-install-info-ld \\\n     maybe-install-info-libgui \\\n+    maybe-install-info-libbanshee \\\n     maybe-install-info-libiberty \\\n     maybe-install-info-libtool \\\n     maybe-install-info-m4 \\\n@@ -1058,8 +1080,10 @@ install-info-host: maybe-install-info-gcc  \\\n .PHONY: install-info-target\n install-info-target:  \\\n     maybe-install-info-target-libstdc++-v3 \\\n+    maybe-install-info-target-libmudflap \\\n     maybe-install-info-target-newlib \\\n     maybe-install-info-target-libf2c \\\n+    maybe-install-info-target-libgfortran \\\n     maybe-install-info-target-libobjc \\\n     maybe-install-info-target-libtermcap \\\n     maybe-install-info-target-winsup \\\n@@ -1112,6 +1136,7 @@ installcheck-host: maybe-installcheck-gcc  \\\n     maybe-installcheck-itcl \\\n     maybe-installcheck-ld \\\n     maybe-installcheck-libgui \\\n+    maybe-installcheck-libbanshee \\\n     maybe-installcheck-libiberty \\\n     maybe-installcheck-libtool \\\n     maybe-installcheck-m4 \\\n@@ -1148,8 +1173,10 @@ installcheck-host: maybe-installcheck-gcc  \\\n .PHONY: installcheck-target\n installcheck-target:  \\\n     maybe-installcheck-target-libstdc++-v3 \\\n+    maybe-installcheck-target-libmudflap \\\n     maybe-installcheck-target-newlib \\\n     maybe-installcheck-target-libf2c \\\n+    maybe-installcheck-target-libgfortran \\\n     maybe-installcheck-target-libobjc \\\n     maybe-installcheck-target-libtermcap \\\n     maybe-installcheck-target-winsup \\\n@@ -1202,6 +1229,7 @@ mostlyclean-host: maybe-mostlyclean-gcc  \\\n     maybe-mostlyclean-itcl \\\n     maybe-mostlyclean-ld \\\n     maybe-mostlyclean-libgui \\\n+    maybe-mostlyclean-libbanshee \\\n     maybe-mostlyclean-libiberty \\\n     maybe-mostlyclean-libtool \\\n     maybe-mostlyclean-m4 \\\n@@ -1238,8 +1266,10 @@ mostlyclean-host: maybe-mostlyclean-gcc  \\\n .PHONY: mostlyclean-target\n mostlyclean-target:  \\\n     maybe-mostlyclean-target-libstdc++-v3 \\\n+    maybe-mostlyclean-target-libmudflap \\\n     maybe-mostlyclean-target-newlib \\\n     maybe-mostlyclean-target-libf2c \\\n+    maybe-mostlyclean-target-libgfortran \\\n     maybe-mostlyclean-target-libobjc \\\n     maybe-mostlyclean-target-libtermcap \\\n     maybe-mostlyclean-target-winsup \\\n@@ -1292,6 +1322,7 @@ clean-host: maybe-clean-gcc  \\\n     maybe-clean-itcl \\\n     maybe-clean-ld \\\n     maybe-clean-libgui \\\n+    maybe-clean-libbanshee \\\n     maybe-clean-libiberty \\\n     maybe-clean-libtool \\\n     maybe-clean-m4 \\\n@@ -1328,8 +1359,10 @@ clean-host: maybe-clean-gcc  \\\n .PHONY: clean-target\n clean-target:  \\\n     maybe-clean-target-libstdc++-v3 \\\n+    maybe-clean-target-libmudflap \\\n     maybe-clean-target-newlib \\\n     maybe-clean-target-libf2c \\\n+    maybe-clean-target-libgfortran \\\n     maybe-clean-target-libobjc \\\n     maybe-clean-target-libtermcap \\\n     maybe-clean-target-winsup \\\n@@ -1382,6 +1415,7 @@ distclean-host: maybe-distclean-gcc  \\\n     maybe-distclean-itcl \\\n     maybe-distclean-ld \\\n     maybe-distclean-libgui \\\n+    maybe-distclean-libbanshee \\\n     maybe-distclean-libiberty \\\n     maybe-distclean-libtool \\\n     maybe-distclean-m4 \\\n@@ -1418,8 +1452,10 @@ distclean-host: maybe-distclean-gcc  \\\n .PHONY: distclean-target\n distclean-target:  \\\n     maybe-distclean-target-libstdc++-v3 \\\n+    maybe-distclean-target-libmudflap \\\n     maybe-distclean-target-newlib \\\n     maybe-distclean-target-libf2c \\\n+    maybe-distclean-target-libgfortran \\\n     maybe-distclean-target-libobjc \\\n     maybe-distclean-target-libtermcap \\\n     maybe-distclean-target-winsup \\\n@@ -1472,6 +1508,7 @@ maintainer-clean-host: maybe-maintainer-clean-gcc  \\\n     maybe-maintainer-clean-itcl \\\n     maybe-maintainer-clean-ld \\\n     maybe-maintainer-clean-libgui \\\n+    maybe-maintainer-clean-libbanshee \\\n     maybe-maintainer-clean-libiberty \\\n     maybe-maintainer-clean-libtool \\\n     maybe-maintainer-clean-m4 \\\n@@ -1508,8 +1545,10 @@ maintainer-clean-host: maybe-maintainer-clean-gcc  \\\n .PHONY: maintainer-clean-target\n maintainer-clean-target:  \\\n     maybe-maintainer-clean-target-libstdc++-v3 \\\n+    maybe-maintainer-clean-target-libmudflap \\\n     maybe-maintainer-clean-target-newlib \\\n     maybe-maintainer-clean-target-libf2c \\\n+    maybe-maintainer-clean-target-libgfortran \\\n     maybe-maintainer-clean-target-libobjc \\\n     maybe-maintainer-clean-target-libtermcap \\\n     maybe-maintainer-clean-target-winsup \\\n@@ -1619,6 +1658,7 @@ do-check: maybe-check-gcc  \\\n     maybe-check-itcl \\\n     maybe-check-ld \\\n     maybe-check-libgui \\\n+    maybe-check-libbanshee \\\n     maybe-check-libiberty \\\n     maybe-check-libtool \\\n     maybe-check-m4 \\\n@@ -1652,8 +1692,10 @@ do-check: maybe-check-gcc  \\\n     maybe-check-libtermcap \\\n     maybe-check-utils \\\n     maybe-check-target-libstdc++-v3 \\\n+    maybe-check-target-libmudflap \\\n     maybe-check-target-newlib \\\n     maybe-check-target-libf2c \\\n+    maybe-check-target-libgfortran \\\n     maybe-check-target-libobjc \\\n     maybe-check-target-libtermcap \\\n     maybe-check-target-winsup \\\n@@ -1729,6 +1771,7 @@ install-host-nogcc:  \\\n     maybe-install-itcl \\\n     maybe-install-ld \\\n     maybe-install-libgui \\\n+    maybe-install-libbanshee \\\n     maybe-install-libiberty \\\n     maybe-install-libtool \\\n     maybe-install-m4 \\\n@@ -1796,6 +1839,7 @@ install-host: maybe-install-gcc  \\\n     maybe-install-itcl \\\n     maybe-install-ld \\\n     maybe-install-libgui \\\n+    maybe-install-libbanshee \\\n     maybe-install-libiberty \\\n     maybe-install-libtool \\\n     maybe-install-m4 \\\n@@ -1832,8 +1876,10 @@ install-host: maybe-install-gcc  \\\n .PHONY: install-target\n install-target:  \\\n     maybe-install-target-libstdc++-v3 \\\n+    maybe-install-target-libmudflap \\\n     maybe-install-target-newlib \\\n     maybe-install-target-libf2c \\\n+    maybe-install-target-libgfortran \\\n     maybe-install-target-libobjc \\\n     maybe-install-target-libtermcap \\\n     maybe-install-target-winsup \\\n@@ -1918,6 +1964,7 @@ configure-build-libiberty:\n \tCXX=\"$(CXX_FOR_BUILD)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_BUILD)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_BUILD)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_BUILD)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_BUILD)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_BUILD)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_BUILD)\"; export LDFLAGS; \\\n@@ -1972,6 +2019,76 @@ all-build-libiberty: configure-build-libiberty\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t(cd $(BUILD_SUBDIR)/libiberty && $(MAKE) all)\n \n+.PHONY: configure-build-libbanshee maybe-configure-build-libbanshee\n+maybe-configure-build-libbanshee:\n+configure-build-libbanshee:\n+\t@test ! -f $(BUILD_SUBDIR)/libbanshee/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(BUILD_SUBDIR)/libbanshee ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tAR=\"$(AR_FOR_BUILD)\"; export AR; \\\n+\tAS=\"$(AS_FOR_BUILD)\"; export AS; \\\n+\tCC=\"$(CC_FOR_BUILD)\"; export CC; \\\n+\tCFLAGS=\"$(CFLAGS_FOR_BUILD)\"; export CFLAGS; \\\n+\tCONFIG_SHELL=\"$(SHELL)\"; export CONFIG_SHELL; \\\n+\tCXX=\"$(CXX_FOR_BUILD)\"; export CXX; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_BUILD)\"; export CXXFLAGS; \\\n+\tGCJ=\"$(GCJ_FOR_BUILD)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_BUILD)\"; export GFORTRAN; \\\n+\tDLLTOOL=\"$(DLLTOOL_FOR_BUILD)\"; export DLLTOOL; \\\n+\tLD=\"$(LD_FOR_BUILD)\"; export LD; \\\n+\tLDFLAGS=\"$(LDFLAGS_FOR_BUILD)\"; export LDFLAGS; \\\n+\tNM=\"$(NM_FOR_BUILD)\"; export NM; \\\n+\tRANLIB=\"$(RANLIB_FOR_BUILD)\"; export RANLIB; \\\n+\tWINDRES=\"$(WINDRES_FOR_BUILD)\"; export WINDRES; \\\n+\techo Configuring in $(BUILD_SUBDIR)/libbanshee; \\\n+\tcd \"$(BUILD_SUBDIR)/libbanshee\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) \\\n+\t    topdir=$(srcdir) ;; \\\n+\t  *) \\\n+\t    case \"$(BUILD_SUBDIR)\" in \\\n+\t      .) topdir=\"../$(srcdir)\" ;; \\\n+\t      *) topdir=\"../../$(srcdir)\" ;; \\\n+\t    esac ;; \\\n+\tesac; \\\n+\tif [ \"$(srcdir)\" = \".\" ] ; then \\\n+\t  if [ \"$(BUILD_SUBDIR)\" != \".\" ] ; then \\\n+\t    if $(SHELL) $$s/symlink-tree $${topdir}/libbanshee \"no-such-file\" ; then \\\n+\t      if [ -f Makefile ]; then \\\n+\t        if $(MAKE) distclean; then \\\n+\t          true; \\\n+\t        else \\\n+\t          exit 1; \\\n+\t        fi; \\\n+\t      else \\\n+\t        true; \\\n+\t      fi; \\\n+\t    else \\\n+\t      exit 1; \\\n+\t    fi; \\\n+\t  else \\\n+\t    true; \\\n+\t  fi; \\\n+\t  srcdiroption=\"--srcdir=.\"; \\\n+\t  libsrcdir=\".\"; \\\n+\telse \\\n+\t  srcdiroption=\"--srcdir=$${topdir}/libbanshee\"; \\\n+\t  libsrcdir=\"$$s/libbanshee\"; \\\n+\tfi; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(BUILD_CONFIGARGS) $${srcdiroption} \\\n+\t  --with-build-subdir=\"$(BUILD_SUBDIR)\" \\\n+\t  || exit 1\n+\n+.PHONY: all-build-libbanshee maybe-all-build-libbanshee\n+maybe-all-build-libbanshee:\n+all-build-libbanshee: configure-build-libbanshee\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t(cd $(BUILD_SUBDIR)/libbanshee && $(MAKE) all)\n+\n \n # --------------------------------------\n # Modules which run on the host machine\n@@ -10483,6 +10600,268 @@ maintainer-clean-libgui:\n \n \n \n+.PHONY: configure-libbanshee maybe-configure-libbanshee\n+maybe-configure-libbanshee:\n+configure-libbanshee:\n+\t@test ! -f libbanshee/Makefile || exit 0; \\\n+\t[ -d libbanshee ] || mkdir libbanshee; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\tCC=\"$(CC)\"; export CC; \\\n+\tCFLAGS=\"$(CFLAGS)\"; export CFLAGS; \\\n+\tCONFIG_SHELL=\"$(SHELL)\"; export CONFIG_SHELL; \\\n+\tCXX=\"$(CXX)\"; export CXX; \\\n+\tCXXFLAGS=\"$(CXXFLAGS)\"; export CXXFLAGS; \\\n+\tAR=\"$(AR)\"; export AR; \\\n+\tAS=\"$(AS)\"; export AS; \\\n+\tCC_FOR_BUILD=\"$(CC_FOR_BUILD)\"; export CC_FOR_BUILD; \\\n+\tDLLTOOL=\"$(DLLTOOL)\"; export DLLTOOL; \\\n+\tLD=\"$(LD)\"; export LD; \\\n+\tLDFLAGS=\"$(LDFLAGS)\"; export LDFLAGS; \\\n+\tNM=\"$(NM)\"; export NM; \\\n+\tRANLIB=\"$(RANLIB)\"; export RANLIB; \\\n+\tWINDRES=\"$(WINDRES)\"; export WINDRES; \\\n+\tOBJCOPY=\"$(OBJCOPY)\"; export OBJCOPY; \\\n+\tOBJDUMP=\"$(OBJDUMP)\"; export OBJDUMP; \\\n+\techo Configuring in libbanshee; \\\n+\tcd libbanshee || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  \\.) \\\n+\t    srcdiroption=\"--srcdir=.\"; \\\n+\t    libsrcdir=\".\";; \\\n+\t  /* | [A-Za-z]:[\\\\/]*) \\\n+\t    srcdiroption=\"--srcdir=$(srcdir)/libbanshee\"; \\\n+\t    libsrcdir=\"$$s/libbanshee\";; \\\n+\t  *) \\\n+\t    srcdiroption=\"--srcdir=../$(srcdir)/libbanshee\"; \\\n+\t    libsrcdir=\"$$s/libbanshee\";; \\\n+\tesac; \\\n+\t$(SHELL) $${libsrcdir}/configure \\\n+\t  $(HOST_CONFIGARGS) $${srcdiroption} \\\n+\t  || exit 1\n+\n+.PHONY: all-libbanshee maybe-all-libbanshee\n+maybe-all-libbanshee:\n+all-libbanshee: configure-libbanshee\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd libbanshee && $(MAKE) $(FLAGS_TO_PASS) all)\n+\n+.PHONY: check-libbanshee maybe-check-libbanshee\n+maybe-check-libbanshee:\n+\n+check-libbanshee:\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd libbanshee && $(MAKE) $(FLAGS_TO_PASS) check)\n+\n+\n+.PHONY: install-libbanshee maybe-install-libbanshee\n+maybe-install-libbanshee:\n+\n+install-libbanshee:\n+\n+\n+# Other targets (info, dvi, etc.)\n+\n+.PHONY: maybe-info-libbanshee info-libbanshee\n+maybe-info-libbanshee:\n+\n+info-libbanshee: \\\n+    configure-libbanshee \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing info in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-dvi-libbanshee dvi-libbanshee\n+maybe-dvi-libbanshee:\n+\n+dvi-libbanshee: \\\n+    configure-libbanshee \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing dvi in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          dvi) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-TAGS-libbanshee TAGS-libbanshee\n+maybe-TAGS-libbanshee:\n+\n+TAGS-libbanshee: \\\n+    configure-libbanshee \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing TAGS in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          TAGS) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-install-info-libbanshee install-info-libbanshee\n+maybe-install-info-libbanshee:\n+\n+install-info-libbanshee: \\\n+    configure-libbanshee \\\n+    info-libbanshee \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing install-info in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          install-info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-installcheck-libbanshee installcheck-libbanshee\n+maybe-installcheck-libbanshee:\n+\n+installcheck-libbanshee: \\\n+    configure-libbanshee \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing installcheck in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          installcheck) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-mostlyclean-libbanshee mostlyclean-libbanshee\n+maybe-mostlyclean-libbanshee:\n+\n+mostlyclean-libbanshee: \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing mostlyclean in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          mostlyclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-clean-libbanshee clean-libbanshee\n+maybe-clean-libbanshee:\n+\n+clean-libbanshee: \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing clean in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          clean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-distclean-libbanshee distclean-libbanshee\n+maybe-distclean-libbanshee:\n+\n+distclean-libbanshee: \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing distclean in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          distclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-maintainer-clean-libbanshee maintainer-clean-libbanshee\n+maybe-maintainer-clean-libbanshee:\n+\n+maintainer-clean-libbanshee: \n+\t@[ -f ./libbanshee/Makefile ] || exit 0; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tfor flag in $(EXTRA_HOST_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\techo \"Doing maintainer-clean in libbanshee\" ; \\\n+\t(cd libbanshee && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          maintainer-clean) \\\n+\t  || exit 1\n+\n+\n+\n .PHONY: configure-libiberty maybe-configure-libiberty\n maybe-configure-libiberty:\n configure-libiberty:\n@@ -18940,6 +19319,7 @@ configure-target-libstdc++-v3: $(TARGET_SUBDIR)/libstdc++-v3/multilib.out\n \tCXX=\"$(RAW_CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -19194,18 +19574,18 @@ maintainer-clean-target-libstdc++-v3:\n \n \n \n-.PHONY: configure-target-newlib maybe-configure-target-newlib\n-maybe-configure-target-newlib:\n+.PHONY: configure-target-libmudflap maybe-configure-target-libmudflap\n+maybe-configure-target-libmudflap:\n \n # There's only one multilib.out.  Cleverer subdirs shouldn't need it copied.\n-$(TARGET_SUBDIR)/newlib/multilib.out: multilib.out\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/newlib ; \\\n-\trm -f $(TARGET_SUBDIR)/newlib/Makefile || : ; \\\n-\tcp multilib.out $(TARGET_SUBDIR)/newlib/multilib.out\n+$(TARGET_SUBDIR)/libmudflap/multilib.out: multilib.out\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libmudflap ; \\\n+\trm -f $(TARGET_SUBDIR)/libmudflap/Makefile || : ; \\\n+\tcp multilib.out $(TARGET_SUBDIR)/libmudflap/multilib.out\n \n-configure-target-newlib: $(TARGET_SUBDIR)/newlib/multilib.out\n-\t@test ! -f $(TARGET_SUBDIR)/newlib/Makefile || exit 0; \\\n-\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/newlib ; \\\n+configure-target-libmudflap: $(TARGET_SUBDIR)/libmudflap/multilib.out\n+\t@test ! -f $(TARGET_SUBDIR)/libmudflap/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libmudflap ; \\\n \tr=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(SET_LIB_PATH) \\\n@@ -19218,14 +19598,15 @@ configure-target-newlib: $(TARGET_SUBDIR)/newlib/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n \tNM=\"$(NM_FOR_TARGET)\"; export NM; \\\n \tRANLIB=\"$(RANLIB_FOR_TARGET)\"; export RANLIB; \\\n \tWINDRES=\"$(WINDRES_FOR_TARGET)\"; export WINDRES; \\\n-\techo Configuring in $(TARGET_SUBDIR)/newlib; \\\n-\tcd \"$(TARGET_SUBDIR)/newlib\" || exit 1; \\\n+\techo Configuring in $(TARGET_SUBDIR)/libmudflap; \\\n+\tcd \"$(TARGET_SUBDIR)/libmudflap\" || exit 1; \\\n \tcase $(srcdir) in \\\n \t  /* | [A-Za-z]:[\\\\/]*) \\\n \t    topdir=$(srcdir) ;; \\\n@@ -19235,27 +19616,306 @@ configure-target-newlib: $(TARGET_SUBDIR)/newlib/multilib.out\n \t      *) topdir=\"../../$(srcdir)\" ;; \\\n \t    esac ;; \\\n \tesac; \\\n-\t  srcdiroption=\"--srcdir=$${topdir}/newlib\"; \\\n-\t  libsrcdir=\"$$s/newlib\"; \\\n+\t  srcdiroption=\"--srcdir=$${topdir}/libmudflap\"; \\\n+\t  libsrcdir=\"$$s/libmudflap\"; \\\n \trm -f no-such-file || : ; \\\n \tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n \t  $(TARGET_CONFIGARGS) $${srcdiroption} \\\n \t  --with-target-subdir=\"$(TARGET_SUBDIR)\" \\\n \t  || exit 1\n \n-.PHONY: all-target-newlib maybe-all-target-newlib\n-maybe-all-target-newlib:\n-all-target-newlib: configure-target-newlib\n+.PHONY: all-target-libmudflap maybe-all-target-libmudflap\n+maybe-all-target-libmudflap:\n+all-target-libmudflap: configure-target-libmudflap\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(SET_LIB_PATH) \\\n-\t(cd $(TARGET_SUBDIR)/newlib && \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n \t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  all)\n \n-.PHONY: check-target-newlib maybe-check-target-newlib\n-maybe-check-target-newlib:\n+.PHONY: check-target-libmudflap maybe-check-target-libmudflap\n+maybe-check-target-libmudflap:\n \n-check-target-newlib:\n+check-target-libmudflap:\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  check)\n+\n+\n+.PHONY: install-target-libmudflap maybe-install-target-libmudflap\n+maybe-install-target-libmudflap:\n+\n+install-target-libmudflap: installdirs\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS) install)\n+\n+\n+# Other targets (info, dvi, etc.)\n+\n+.PHONY: maybe-info-target-libmudflap info-target-libmudflap\n+maybe-info-target-libmudflap:\n+\n+info-target-libmudflap: \\\n+    configure-target-libmudflap \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-dvi-target-libmudflap dvi-target-libmudflap\n+maybe-dvi-target-libmudflap:\n+\n+dvi-target-libmudflap: \\\n+    configure-target-libmudflap \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          dvi) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-TAGS-target-libmudflap TAGS-target-libmudflap\n+maybe-TAGS-target-libmudflap:\n+\n+TAGS-target-libmudflap: \\\n+    configure-target-libmudflap \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          TAGS) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-install-info-target-libmudflap install-info-target-libmudflap\n+maybe-install-info-target-libmudflap:\n+\n+install-info-target-libmudflap: \\\n+    configure-target-libmudflap \\\n+    info-target-libmudflap \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          install-info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-installcheck-target-libmudflap installcheck-target-libmudflap\n+maybe-installcheck-target-libmudflap:\n+\n+installcheck-target-libmudflap: \\\n+    configure-target-libmudflap \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          installcheck) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-mostlyclean-target-libmudflap mostlyclean-target-libmudflap\n+maybe-mostlyclean-target-libmudflap:\n+\n+mostlyclean-target-libmudflap: \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          mostlyclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-clean-target-libmudflap clean-target-libmudflap\n+maybe-clean-target-libmudflap:\n+\n+clean-target-libmudflap: \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          clean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-distclean-target-libmudflap distclean-target-libmudflap\n+maybe-distclean-target-libmudflap:\n+\n+distclean-target-libmudflap: \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          distclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-maintainer-clean-target-libmudflap maintainer-clean-target-libmudflap\n+maybe-maintainer-clean-target-libmudflap:\n+\n+maintainer-clean-target-libmudflap: \n+\t@[ -f $(TARGET_SUBDIR)/libmudflap/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libmudflap\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libmudflap && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          maintainer-clean) \\\n+\t  || exit 1\n+\n+\n+\n+.PHONY: configure-target-newlib maybe-configure-target-newlib\n+maybe-configure-target-newlib:\n+\n+# There's only one multilib.out.  Cleverer subdirs shouldn't need it copied.\n+$(TARGET_SUBDIR)/newlib/multilib.out: multilib.out\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/newlib ; \\\n+\trm -f $(TARGET_SUBDIR)/newlib/Makefile || : ; \\\n+\tcp multilib.out $(TARGET_SUBDIR)/newlib/multilib.out\n+\n+configure-target-newlib: $(TARGET_SUBDIR)/newlib/multilib.out\n+\t@test ! -f $(TARGET_SUBDIR)/newlib/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/newlib ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tAR=\"$(AR_FOR_TARGET)\"; export AR; \\\n+\tAS=\"$(AS_FOR_TARGET)\"; export AS; \\\n+\tCC=\"$(CC_FOR_TARGET)\"; export CC; \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCONFIG_SHELL=\"$(SHELL)\"; export CONFIG_SHELL; \\\n+\tCPPFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CPPFLAGS; \\\n+\tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n+\tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n+\tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n+\tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n+\tNM=\"$(NM_FOR_TARGET)\"; export NM; \\\n+\tRANLIB=\"$(RANLIB_FOR_TARGET)\"; export RANLIB; \\\n+\tWINDRES=\"$(WINDRES_FOR_TARGET)\"; export WINDRES; \\\n+\techo Configuring in $(TARGET_SUBDIR)/newlib; \\\n+\tcd \"$(TARGET_SUBDIR)/newlib\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) \\\n+\t    topdir=$(srcdir) ;; \\\n+\t  *) \\\n+\t    case \"$(TARGET_SUBDIR)\" in \\\n+\t      .) topdir=\"../$(srcdir)\" ;; \\\n+\t      *) topdir=\"../../$(srcdir)\" ;; \\\n+\t    esac ;; \\\n+\tesac; \\\n+\t  srcdiroption=\"--srcdir=$${topdir}/newlib\"; \\\n+\t  libsrcdir=\"$$s/newlib\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) $${srcdiroption} \\\n+\t  --with-target-subdir=\"$(TARGET_SUBDIR)\" \\\n+\t  || exit 1\n+\n+.PHONY: all-target-newlib maybe-all-target-newlib\n+maybe-all-target-newlib:\n+all-target-newlib: configure-target-newlib\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/newlib && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  all)\n+\n+.PHONY: check-target-newlib maybe-check-target-newlib\n+maybe-check-target-newlib:\n+\n+check-target-newlib:\n \t@r=`${PWD_COMMAND}`; export r; \\\n \ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n \t$(SET_LIB_PATH) \\\n@@ -19496,6 +20156,7 @@ configure-target-libf2c: $(TARGET_SUBDIR)/libf2c/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -19750,6 +20411,285 @@ maintainer-clean-target-libf2c:\n \n \n \n+.PHONY: configure-target-libgfortran maybe-configure-target-libgfortran\n+maybe-configure-target-libgfortran:\n+\n+# There's only one multilib.out.  Cleverer subdirs shouldn't need it copied.\n+$(TARGET_SUBDIR)/libgfortran/multilib.out: multilib.out\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libgfortran ; \\\n+\trm -f $(TARGET_SUBDIR)/libgfortran/Makefile || : ; \\\n+\tcp multilib.out $(TARGET_SUBDIR)/libgfortran/multilib.out\n+\n+configure-target-libgfortran: $(TARGET_SUBDIR)/libgfortran/multilib.out\n+\t@test ! -f $(TARGET_SUBDIR)/libgfortran/Makefile || exit 0; \\\n+\t$(SHELL) $(srcdir)/mkinstalldirs $(TARGET_SUBDIR)/libgfortran ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\tAR=\"$(AR_FOR_TARGET)\"; export AR; \\\n+\tAS=\"$(AS_FOR_TARGET)\"; export AS; \\\n+\tCC=\"$(CC_FOR_TARGET)\"; export CC; \\\n+\tCFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CFLAGS; \\\n+\tCONFIG_SHELL=\"$(SHELL)\"; export CONFIG_SHELL; \\\n+\tCPPFLAGS=\"$(CFLAGS_FOR_TARGET)\"; export CPPFLAGS; \\\n+\tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n+\tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n+\tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n+\tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n+\tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n+\tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n+\tNM=\"$(NM_FOR_TARGET)\"; export NM; \\\n+\tRANLIB=\"$(RANLIB_FOR_TARGET)\"; export RANLIB; \\\n+\tWINDRES=\"$(WINDRES_FOR_TARGET)\"; export WINDRES; \\\n+\techo Configuring in $(TARGET_SUBDIR)/libgfortran; \\\n+\tcd \"$(TARGET_SUBDIR)/libgfortran\" || exit 1; \\\n+\tcase $(srcdir) in \\\n+\t  /* | [A-Za-z]:[\\\\/]*) \\\n+\t    topdir=$(srcdir) ;; \\\n+\t  *) \\\n+\t    case \"$(TARGET_SUBDIR)\" in \\\n+\t      .) topdir=\"../$(srcdir)\" ;; \\\n+\t      *) topdir=\"../../$(srcdir)\" ;; \\\n+\t    esac ;; \\\n+\tesac; \\\n+\t  srcdiroption=\"--srcdir=$${topdir}/libgfortran\"; \\\n+\t  libsrcdir=\"$$s/libgfortran\"; \\\n+\trm -f no-such-file || : ; \\\n+\tCONFIG_SITE=no-such-file $(SHELL) $${libsrcdir}/configure \\\n+\t  $(TARGET_CONFIGARGS) $${srcdiroption} \\\n+\t  --with-target-subdir=\"$(TARGET_SUBDIR)\" \\\n+\t  || exit 1\n+\n+.PHONY: all-target-libgfortran maybe-all-target-libgfortran\n+maybe-all-target-libgfortran:\n+all-target-libgfortran: configure-target-libgfortran\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  all)\n+\n+.PHONY: check-target-libgfortran maybe-check-target-libgfortran\n+maybe-check-target-libgfortran:\n+\n+check-target-libgfortran:\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS)  check)\n+\n+\n+.PHONY: install-target-libgfortran maybe-install-target-libgfortran\n+maybe-install-target-libgfortran:\n+\n+install-target-libgfortran: installdirs\n+\t@r=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(TARGET_FLAGS_TO_PASS) install)\n+\n+\n+# Other targets (info, dvi, etc.)\n+\n+.PHONY: maybe-info-target-libgfortran info-target-libgfortran\n+maybe-info-target-libgfortran:\n+\n+info-target-libgfortran: \\\n+    configure-target-libgfortran \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing info in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-dvi-target-libgfortran dvi-target-libgfortran\n+maybe-dvi-target-libgfortran:\n+\n+dvi-target-libgfortran: \\\n+    configure-target-libgfortran \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing dvi in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          dvi) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-TAGS-target-libgfortran TAGS-target-libgfortran\n+maybe-TAGS-target-libgfortran:\n+\n+TAGS-target-libgfortran: \\\n+    configure-target-libgfortran \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing TAGS in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          TAGS) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-install-info-target-libgfortran install-info-target-libgfortran\n+maybe-install-info-target-libgfortran:\n+\n+install-info-target-libgfortran: \\\n+    configure-target-libgfortran \\\n+    info-target-libgfortran \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing install-info in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          install-info) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-installcheck-target-libgfortran installcheck-target-libgfortran\n+maybe-installcheck-target-libgfortran:\n+\n+installcheck-target-libgfortran: \\\n+    configure-target-libgfortran \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing installcheck in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          installcheck) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-mostlyclean-target-libgfortran mostlyclean-target-libgfortran\n+maybe-mostlyclean-target-libgfortran:\n+\n+mostlyclean-target-libgfortran: \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing mostlyclean in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          mostlyclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-clean-target-libgfortran clean-target-libgfortran\n+maybe-clean-target-libgfortran:\n+\n+clean-target-libgfortran: \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing clean in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          clean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-distclean-target-libgfortran distclean-target-libgfortran\n+maybe-distclean-target-libgfortran:\n+\n+distclean-target-libgfortran: \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing distclean in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          distclean) \\\n+\t  || exit 1\n+\n+\n+.PHONY: maybe-maintainer-clean-target-libgfortran maintainer-clean-target-libgfortran\n+maybe-maintainer-clean-target-libgfortran:\n+\n+maintainer-clean-target-libgfortran: \n+\t@[ -f $(TARGET_SUBDIR)/libgfortran/Makefile ] || exit 0 ; \\\n+\tr=`${PWD_COMMAND}`; export r; \\\n+\ts=`cd $(srcdir); ${PWD_COMMAND}`; export s; \\\n+\t$(SET_LIB_PATH) \\\n+\techo \"Doing maintainer-clean in $(TARGET_SUBDIR)/libgfortran\" ; \\\n+\tfor flag in $(EXTRA_TARGET_FLAGS); do \\\n+\t  eval `echo \"$$flag\" | sed -e \"s|^\\([^=]*\\)=\\(.*\\)|\\1='\\2'; export \\1|\"`; \\\n+\tdone; \\\n+\t(cd $(TARGET_SUBDIR)/libgfortran && \\\n+\t  $(MAKE) $(BASE_FLAGS_TO_PASS) \"AR=$${AR}\" \"AS=$${AS}\" \\\n+\t          \"CC=$${CC}\" \"CXX=$${CXX}\" \"LD=$${LD}\" \"NM=$${NM}\" \\\n+\t          \"RANLIB=$${RANLIB}\" \\\n+\t          \"DLLTOOL=$${DLLTOOL}\" \"WINDRES=$${WINDRES}\" \\\n+\t          maintainer-clean) \\\n+\t  || exit 1\n+\n+\n+\n .PHONY: configure-target-libobjc maybe-configure-target-libobjc\n maybe-configure-target-libobjc:\n \n@@ -19774,6 +20714,7 @@ configure-target-libobjc: $(TARGET_SUBDIR)/libobjc/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -20052,6 +20993,7 @@ configure-target-libtermcap: $(TARGET_SUBDIR)/libtermcap/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -20292,6 +21234,7 @@ configure-target-winsup: $(TARGET_SUBDIR)/winsup/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -20570,6 +21513,7 @@ configure-target-libgloss: $(TARGET_SUBDIR)/libgloss/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -20844,6 +21788,7 @@ configure-target-libiberty: $(TARGET_SUBDIR)/libiberty/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -21122,6 +22067,7 @@ configure-target-gperf: $(TARGET_SUBDIR)/gperf/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -21400,6 +22346,7 @@ configure-target-examples: $(TARGET_SUBDIR)/examples/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -21670,6 +22617,7 @@ configure-target-libffi: $(TARGET_SUBDIR)/libffi/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -21949,6 +22897,7 @@ configure-target-libjava: $(TARGET_SUBDIR)/libjava/multilib.out\n \tCXX=\"$(RAW_CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -22227,6 +23176,7 @@ configure-target-zlib: $(TARGET_SUBDIR)/zlib/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -22527,6 +23477,7 @@ configure-target-boehm-gc: $(TARGET_SUBDIR)/boehm-gc/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -22805,6 +23756,7 @@ configure-target-qthreads: $(TARGET_SUBDIR)/qthreads/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -23083,6 +24035,7 @@ configure-target-rda: $(TARGET_SUBDIR)/rda/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -23361,6 +24314,7 @@ configure-target-libada: $(TARGET_SUBDIR)/libada/multilib.out\n \tCXX=\"$(CXX_FOR_TARGET)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -23655,6 +24609,8 @@ configure-gcc:\n \tWINDRES=\"$(WINDRES)\"; export WINDRES; \\\n \tOBJCOPY=\"$(OBJCOPY)\"; export OBJCOPY; \\\n \tOBJDUMP=\"$(OBJDUMP)\"; export OBJDUMP; \\\n+\tGMPLIBS=\"$(HOST_GMPLIBS)\"; export GMPLIBS; \\\n+\tGMPINC=\"$(HOST_GMPINC)\"; export GMPINC; \\\n \techo Configuring in gcc; \\\n \tcd gcc || exit 1; \\\n \tcase $(srcdir) in \\\n@@ -24335,11 +25291,11 @@ new-restage3: all-stage2-gcc\n # GCC needs to identify certain tools.\n # GCC also needs the information exported by the intl configure script.\n configure-gcc: maybe-configure-intl maybe-configure-binutils maybe-configure-gas maybe-configure-ld maybe-configure-bison maybe-configure-flex\n-all-gcc: maybe-all-libiberty maybe-all-intl maybe-all-bison maybe-all-byacc maybe-all-binutils maybe-all-gas maybe-all-ld maybe-all-zlib\n+all-gcc: maybe-all-libiberty maybe-all-intl maybe-all-bison maybe-all-byacc maybe-all-binutils maybe-all-gas maybe-all-ld maybe-all-zlib maybe-all-libbanshee\n # This is a slightly kludgy method of getting dependencies on \n # all-build-libiberty correct; it would be better to build it every time.\n-all-gcc: maybe-all-build-libiberty\n-all-bootstrap: maybe-all-binutils maybe-all-bison maybe-all-byacc maybe-all-gas maybe-all-intl maybe-all-ld maybe-all-libiberty maybe-all-texinfo maybe-all-zlib \n+all-gcc: maybe-all-build-libiberty maybe-all-libbanshee\n+all-bootstrap: maybe-all-binutils maybe-all-bison maybe-all-byacc maybe-all-gas maybe-all-intl maybe-all-ld maybe-all-libbanshee maybe-all-libiberty maybe-all-texinfo maybe-all-zlib \n \n # Host modules specific to gdb.\n # GDB needs to know that the simulator is being built.\n@@ -24414,6 +25370,7 @@ all-target-fastjar: maybe-all-target-zlib maybe-all-target-libiberty\n configure-target-libada: $(ALL_GCC_C)\n configure-target-libf2c: $(ALL_GCC_C)\n all-target-libf2c: maybe-all-target-libiberty\n+configure-target-libgfortran: $(ALL_GCC_C)\n configure-target-libffi: $(ALL_GCC_C) \n configure-target-libjava: $(ALL_GCC_C) maybe-configure-target-zlib maybe-configure-target-boehm-gc maybe-configure-target-qthreads maybe-configure-target-libffi\n all-target-libjava: maybe-all-fastjar maybe-all-target-zlib maybe-all-target-boehm-gc maybe-all-target-qthreads maybe-all-target-libffi"}, {"sha": "a8515bd6d56f7747758b5c152e078d6b5837f59d", "filename": "Makefile.tpl", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.tpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/Makefile.tpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/Makefile.tpl?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -105,7 +105,7 @@ REALLY_SET_LIB_PATH = \\\n   $(RPATH_ENVVAR)=`echo \"$(HOST_LIB_PATH):$(TARGET_LIB_PATH):$$$(RPATH_ENVVAR)\" | sed 's,::*,:,g;s,^:*,,;s,:*$$,,'`; export $(RPATH_ENVVAR);\n \n # This is the list of directories to be built for the build system.\n-BUILD_CONFIGDIRS = libiberty\n+BUILD_CONFIGDIRS = libiberty libbanshee\n # Build programs are put under this directory.\n BUILD_SUBDIR = @build_subdir@\n # This is set by the configure script to the arguments to use when configuring\n@@ -127,6 +127,10 @@ TARGET_SUBDIR = @target_subdir@\n # directories built for the target.\n TARGET_CONFIGARGS = @target_configargs@\n \n+# Where to find GMP\n+HOST_GMPLIBS = @gmplibs@\n+HOST_GMPINC = @gmpinc@\n+\n # ----------------------------------------------\n # Programs producing files for the BUILD machine\n # ----------------------------------------------\n@@ -244,7 +248,7 @@ PICFLAG =\n \n # This is the list of directories that may be needed in RPATH_ENVVAR\n # so that prorgams built for the target machine work.\n-TARGET_LIB_PATH = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:\n+TARGET_LIB_PATH = $$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs:$$r/$(TARGET_SUBDIR)/libmudflap/.libs\n \n FLAGS_FOR_TARGET = @FLAGS_FOR_TARGET@\n \n@@ -311,6 +315,7 @@ USUAL_DLLTOOL_FOR_TARGET = ` \\\n   fi`\n \n GCJ_FOR_TARGET = @GCJ_FOR_TARGET@\n+GFORTRAN_FOR_TARGET = @GFORTRAN_FOR_TARGET@\n \n LD_FOR_TARGET=@LD_FOR_TARGET@\n CONFIGURED_LD_FOR_TARGET=@CONFIGURED_LD_FOR_TARGET@\n@@ -705,6 +710,7 @@ configure-build-[+module+]:\n \tCXX=\"$(CXX_FOR_BUILD)\"; export CXX; \\\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_BUILD)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_BUILD)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_BUILD)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_BUILD)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_BUILD)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_BUILD)\"; export LDFLAGS; \\\n@@ -921,6 +927,7 @@ ELSE normal_cxx +]\n ENDIF raw_cxx +]\n \tCXXFLAGS=\"$(CXXFLAGS_FOR_TARGET)\"; export CXXFLAGS; \\\n \tGCJ=\"$(GCJ_FOR_TARGET)\"; export GCJ; \\\n+\tGFORTRAN=\"$(GFORTRAN_FOR_TARGET)\"; export GFORTRAN; \\\n \tDLLTOOL=\"$(DLLTOOL_FOR_TARGET)\"; export DLLTOOL; \\\n \tLD=\"$(LD_FOR_TARGET)\"; export LD; \\\n \tLDFLAGS=\"$(LDFLAGS_FOR_TARGET)\"; export LDFLAGS; \\\n@@ -1083,6 +1090,8 @@ configure-gcc:\n \tWINDRES=\"$(WINDRES)\"; export WINDRES; \\\n \tOBJCOPY=\"$(OBJCOPY)\"; export OBJCOPY; \\\n \tOBJDUMP=\"$(OBJDUMP)\"; export OBJDUMP; \\\n+\tGMPLIBS=\"$(HOST_GMPLIBS)\"; export GMPLIBS; \\\n+\tGMPINC=\"$(HOST_GMPINC)\"; export GMPINC; \\\n \techo Configuring in gcc; \\\n \tcd gcc || exit 1; \\\n \tcase $(srcdir) in \\\n@@ -1600,10 +1609,10 @@ new-restage3: all-stage2-gcc\n # GCC needs to identify certain tools.\n # GCC also needs the information exported by the intl configure script.\n configure-gcc: maybe-configure-intl maybe-configure-binutils maybe-configure-gas maybe-configure-ld maybe-configure-bison maybe-configure-flex\n-all-gcc: maybe-all-libiberty maybe-all-intl maybe-all-bison maybe-all-byacc maybe-all-binutils maybe-all-gas maybe-all-ld maybe-all-zlib\n+all-gcc: maybe-all-libiberty maybe-all-intl maybe-all-bison maybe-all-byacc maybe-all-binutils maybe-all-gas maybe-all-ld maybe-all-zlib maybe-all-libbanshee\n # This is a slightly kludgy method of getting dependencies on \n # all-build-libiberty correct; it would be better to build it every time.\n-all-gcc: maybe-all-build-libiberty\n+all-gcc: maybe-all-build-libiberty maybe-all-libbanshee\n all-bootstrap: [+ FOR host_modules +][+ IF bootstrap +]maybe-all-[+module+] [+ ENDIF bootstrap +][+ ENDFOR host_modules +]\n \n # Host modules specific to gdb.\n@@ -1679,6 +1688,7 @@ all-target-fastjar: maybe-all-target-zlib maybe-all-target-libiberty\n configure-target-libada: $(ALL_GCC_C)\n configure-target-libf2c: $(ALL_GCC_C)\n all-target-libf2c: maybe-all-target-libiberty\n+configure-target-libgfortran: $(ALL_GCC_C)\n configure-target-libffi: $(ALL_GCC_C) \n configure-target-libjava: $(ALL_GCC_C) maybe-configure-target-zlib maybe-configure-target-boehm-gc maybe-configure-target-qthreads maybe-configure-target-libffi\n all-target-libjava: maybe-all-fastjar maybe-all-target-zlib maybe-all-target-boehm-gc maybe-all-target-qthreads maybe-all-target-libffi"}, {"sha": "fd4f900547f833c8673fb925dc30761b9b8f0133", "filename": "configure", "status": "modified", "additions": 263, "deletions": 71, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/configure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/configure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -11,8 +11,14 @@\n ac_help=\n ac_default_prefix=/usr/local\n # Any additions from configure.in:\n+ac_help=\"$ac_help\n+  --without-libbanshee   Don't build with libbanshee\"\n ac_help=\"$ac_help\n   --enable-libada        Builds libada directory\"\n+ac_help=\"$ac_help\n+  --with-gmp-dir=PATH     Specify source directory for GMP library\"\n+ac_help=\"$ac_help\n+  --with-gmp=PATH         Specify directory for installed GMP library\"\n ac_help=\"$ac_help\n   --enable-serial-[{host,target,build}-]configure\n                           Force sequential configuration of\n@@ -581,7 +587,7 @@ else { echo \"configure: error: can not run $ac_config_sub\" 1>&2; exit 1; }\n fi\n \n echo $ac_n \"checking host system type\"\"... $ac_c\" 1>&6\n-echo \"configure:585: checking host system type\" >&5\n+echo \"configure:591: checking host system type\" >&5\n \n host_alias=$host\n case \"$host_alias\" in\n@@ -602,7 +608,7 @@ host_os=`echo $host | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$host\" 1>&6\n \n echo $ac_n \"checking target system type\"\"... $ac_c\" 1>&6\n-echo \"configure:606: checking target system type\" >&5\n+echo \"configure:612: checking target system type\" >&5\n \n target_alias=$target\n case \"$target_alias\" in\n@@ -620,7 +626,7 @@ target_os=`echo $target | sed 's/^\\([^-]*\\)-\\([^-]*\\)-\\(.*\\)$/\\3/'`\n echo \"$ac_t\"\"$target\" 1>&6\n \n echo $ac_n \"checking build system type\"\"... $ac_c\" 1>&6\n-echo \"configure:624: checking build system type\" >&5\n+echo \"configure:630: checking build system type\" >&5\n \n build_alias=$build\n case \"$build_alias\" in\n@@ -675,7 +681,7 @@ test \"$program_transform_name\" = \"\" && program_transform_name=\"s,x,x,\"\n # SVR4 /usr/ucb/install, which tries to use the nonexistent group \"staff\"\n # ./install, which can be erroneously created by make from ./install.sh.\n echo $ac_n \"checking for a BSD compatible install\"\"... $ac_c\" 1>&6\n-echo \"configure:679: checking for a BSD compatible install\" >&5\n+echo \"configure:685: checking for a BSD compatible install\" >&5\n if test -z \"$INSTALL\"; then\n if eval \"test \\\"`echo '$''{'ac_cv_path_install'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n@@ -880,7 +886,7 @@ fi\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl tix libgui zlib\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl tix libgui zlib libbanshee\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -903,7 +909,9 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libstdc++-v3 \\\n+\t\ttarget-libmudflap \\\n \t\ttarget-libf2c \\\n+\t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n \t\ttarget-libada\"\n@@ -1082,6 +1090,22 @@ case \"${host}\" in\n     ;;\n esac\n \n+# Check whether --with-libbanshee or --without-libbanshee was given.\n+if test \"${with_libbanshee+set}\" = set; then\n+  withval=\"$with_libbanshee\"\n+  :\n+fi\n+\n+case ${with_libbanshee} in\n+  no)\n+    noconfigdirs=\"$noconfigdirs libbanshee\" ;;\n+  yes|\"\")\n+    with_libbanshee=yes\n+    ;;\n+  *)\n+    { echo \"configure: error: --with-libbanshee can only be empty, \"yes\" or \"no\" (empty defaults to \"yes\".\" 1>&2; exit 1; }\n+esac\n+\n # Check whether --enable-libada or --disable-libada was given.\n if test \"${enable_libada+set}\" = set; then\n   enableval=\"$enable_libada\"\n@@ -1110,6 +1134,18 @@ no)\n   ;;\n esac\n \n+\n+# Allow --disable-libmudflap to exclude target-libmudflap\n+case $enable_libmudflap in\n+yes | \"\")\n+    # By default it's enabled\n+    ;;\n+no)\n+    noconfigdirs=\"$noconfigdirs target-libmudflap\"\n+    ;;\n+esac\n+\n+\n case \"${target}\" in\n   *-*-chorusos)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n@@ -1125,6 +1161,22 @@ case \"${target}\" in\n   *-*-freebsd[12] | *-*-freebsd[12].* | *-*-freebsd*aout*)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n     ;;\n+  *-*-freebsd* | *-*-kfreebsd*-gnu)\n+    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n+    if test \"x$with_gmp\" = x && test \"x$with_gmp_dir\" = x \\\n+\t&& test -f /usr/local/include/gmp.h; then\n+      with_gmp=/usr/local\n+    fi\n+\n+    # Skip some stuff that's unsupported on some FreeBSD configurations.\n+    case \"${target}\" in\n+      i*86-*-*) ;;\n+      alpha*-*-*) ;;\n+      *)\n+\tnoconfigdirs=\"$noconfigdirs ${libgcj}\"\n+\t;;\n+    esac\n+    ;;\n   *-*-kaos*)\n     # Remove unsupported stuff on all kaOS configurations.\n     skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-libf2c target-librx\"\n@@ -1176,9 +1228,6 @@ case \"${target}\" in\n     # newlib is not 64 bit ready\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n     ;;\n-  alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    ;;\n   alpha*-*-*)\n     # newlib is not 64 bit ready\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n@@ -1297,9 +1346,6 @@ case \"${target}\" in\n   i[3456789]86-*-coff | i[3456789]86-*-elf)\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n-  i[3456789]86-*-freebsd* | i[3456789]86-*-kfreebsd*-gnu)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    ;;\n   i[3456789]86-*-linux*)\n     # The GCC port for glibc1 has no MD_FALLBACK_FRAME_STATE_FOR, so let's\n     # not build java stuff by default.\n@@ -1855,7 +1901,7 @@ fi\n # Extract the first word of \"gcc\", so it can be a program name with args.\n set dummy gcc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1859: checking for $ac_word\" >&5\n+echo \"configure:1905: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1885,7 +1931,7 @@ if test -z \"$CC\"; then\n   # Extract the first word of \"cc\", so it can be a program name with args.\n set dummy cc; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1889: checking for $ac_word\" >&5\n+echo \"configure:1935: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1936,7 +1982,7 @@ fi\n       # Extract the first word of \"cl\", so it can be a program name with args.\n set dummy cl; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:1940: checking for $ac_word\" >&5\n+echo \"configure:1986: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -1968,7 +2014,7 @@ fi\n fi\n \n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\"\"... $ac_c\" 1>&6\n-echo \"configure:1972: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n+echo \"configure:2018: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) works\" >&5\n \n ac_ext=c\n # CFLAGS is not in ac_cpp because -g, -O, etc. are not valid cpp options.\n@@ -1979,12 +2025,12 @@ cross_compiling=$ac_cv_prog_cc_cross\n \n cat > conftest.$ac_ext << EOF\n \n-#line 1983 \"configure\"\n+#line 2029 \"configure\"\n #include \"confdefs.h\"\n \n main(){return(0);}\n EOF\n-if { (eval echo configure:1988: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+if { (eval echo configure:2034: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n   ac_cv_prog_cc_works=yes\n   # If we can't run a trivial program, we are probably using a cross compiler.\n   if (./conftest; exit) 2>/dev/null; then\n@@ -2010,12 +2056,12 @@ if test $ac_cv_prog_cc_works = no; then\n   { echo \"configure: error: installation or configuration problem: C compiler cannot create executables.\" 1>&2; exit 1; }\n fi\n echo $ac_n \"checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\"\"... $ac_c\" 1>&6\n-echo \"configure:2014: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n+echo \"configure:2060: checking whether the C compiler ($CC $CFLAGS $LDFLAGS) is a cross-compiler\" >&5\n echo \"$ac_t\"\"$ac_cv_prog_cc_cross\" 1>&6\n cross_compiling=$ac_cv_prog_cc_cross\n \n echo $ac_n \"checking whether we are using GNU C\"\"... $ac_c\" 1>&6\n-echo \"configure:2019: checking whether we are using GNU C\" >&5\n+echo \"configure:2065: checking whether we are using GNU C\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_gcc'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2024,7 +2070,7 @@ else\n   yes;\n #endif\n EOF\n-if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2028: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n+if { ac_try='${CC-cc} -E conftest.c'; { (eval echo configure:2074: \\\"$ac_try\\\") 1>&5; (eval $ac_try) 2>&5; }; } | egrep yes >/dev/null 2>&1; then\n   ac_cv_prog_gcc=yes\n else\n   ac_cv_prog_gcc=no\n@@ -2043,7 +2089,7 @@ ac_test_CFLAGS=\"${CFLAGS+set}\"\n ac_save_CFLAGS=\"$CFLAGS\"\n CFLAGS=\n echo $ac_n \"checking whether ${CC-cc} accepts -g\"\"... $ac_c\" 1>&6\n-echo \"configure:2047: checking whether ${CC-cc} accepts -g\" >&5\n+echo \"configure:2093: checking whether ${CC-cc} accepts -g\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_cc_g'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2079,7 +2125,7 @@ fi\n # Extract the first word of \"${ac_tool_prefix}gnatbind\", so it can be a program name with args.\n set dummy ${ac_tool_prefix}gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2083: checking for $ac_word\" >&5\n+echo \"configure:2129: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2111,7 +2157,7 @@ if test -n \"$ac_tool_prefix\"; then\n   # Extract the first word of \"gnatbind\", so it can be a program name with args.\n set dummy gnatbind; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2115: checking for $ac_word\" >&5\n+echo \"configure:2161: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_GNATBIND'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2144,7 +2190,7 @@ fi\n fi\n \n echo $ac_n \"checking whether compiler driver understands Ada\"\"... $ac_c\" 1>&6\n-echo \"configure:2148: checking whether compiler driver understands Ada\" >&5\n+echo \"configure:2194: checking whether compiler driver understands Ada\" >&5\n if eval \"test \\\"`echo '$''{'acx_cv_cc_gcc_supports_ada'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2177,7 +2223,7 @@ else\n fi\n \n echo $ac_n \"checking how to compare bootstrapped objects\"\"... $ac_c\" 1>&6\n-echo \"configure:2181: checking how to compare bootstrapped objects\" >&5\n+echo \"configure:2227: checking how to compare bootstrapped objects\" >&5\n if eval \"test \\\"`echo '$''{'gcc_cv_prog_cmp_skip'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2207,6 +2253,104 @@ do_compare=\"$gcc_cv_prog_cmp_skip\"\n \n \n \n+# Check for GMP\n+gmplibs=\n+gmpinc=\n+have_gmp=yes\n+# Specify a location for gmp\n+# Check whether --with-gmp-dir or --without-gmp-dir was given.\n+if test \"${with_gmp_dir+set}\" = set; then\n+  withval=\"$with_gmp_dir\"\n+  :\n+fi\n+\n+\n+if test \"x$with_gmp_dir\" != x && test -f \"$with_gmp_dir/gmp.h\"; then\n+  gmpinc=\"-I$with_gmp_dir\"\n+  if test -f \"$with_gmp_dir/.libs/libgmp.a\"; then\n+    gmplibs=\"$with_gmp_dir/.libs/libgmp.a\"\n+  elif test -f \"$with_gmp_dir/_libs/libgmp.a\"; then\n+    gmplibs=\"$with_gmp_dir/_libs/libgmp.a\"\n+  fi\n+  # One of the later tests will catch the error if neither library is present.\n+fi\n+\n+# Check whether --with-gmp or --without-gmp was given.\n+if test \"${with_gmp+set}\" = set; then\n+  withval=\"$with_gmp\"\n+  :\n+fi\n+\n+\n+if test \"x$with_gmp\" != x && test -d \"$with_gmp\"; then\n+  gmplibs=\"-L$with_gmp/lib -lgmp\"\n+  gmpinc=\"-I$with_gmp/include\"\n+fi\n+\n+# Use system gmp if nothing else specified\n+if test \"x$gmplibs\" = x; then\n+  gmplibs=\"-lgmp\"\n+fi\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $gmpinc\"\n+# Check GMP actually works\n+echo $ac_n \"checking for correct version of gmp.h\"\"... $ac_c\" 1>&6\n+echo \"configure:2300: checking for correct version of gmp.h\" >&5\n+cat > conftest.$ac_ext <<EOF\n+#line 2302 \"configure\"\n+#include \"confdefs.h\"\n+#include \"gmp.h\"\n+int main() {\n+\n+#if __GNU_MP_VERSION < 3\n+choke me\n+#endif\n+\n+; return 0; }\n+EOF\n+if { (eval echo configure:2313: \\\"$ac_compile\\\") 1>&5; (eval $ac_compile) 2>&5; }; then\n+  rm -rf conftest*\n+  echo \"$ac_t\"\"yes\" 1>&6\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  echo \"$ac_t\"\"no\" 1>&6; have_gmp=no\n+fi\n+rm -f conftest*\n+\n+if test x\"$have_gmp\" = xyes; then\n+  echo $ac_n \"checking for mpf_init in -lgmp\"\"... $ac_c\" 1>&6\n+echo \"configure:2326: checking for mpf_init in -lgmp\" >&5\n+\n+  saved_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS $gmplibs\"\n+  cat > conftest.$ac_ext <<EOF\n+#line 2331 \"configure\"\n+#include \"confdefs.h\"\n+#include <gmp.h>\n+int main() {\n+mpf_t n; mpf_init(n);\n+; return 0; }\n+EOF\n+if { (eval echo configure:2338: \\\"$ac_link\\\") 1>&5; (eval $ac_link) 2>&5; } && test -s conftest${ac_exeext}; then\n+  rm -rf conftest*\n+  echo \"$ac_t\"\"yes\" 1>&6\n+else\n+  echo \"configure: failed program was:\" >&5\n+  cat conftest.$ac_ext >&5\n+  rm -rf conftest*\n+  echo \"$ac_t\"\"no\" 1>&6; have_gmp=no\n+fi\n+rm -f conftest*\n+  LIBS=\"$saved_LIBS\"\n+  CFLAGS=\"$saved_CFLAGS\"\n+fi\n+\n+\n+\n+\n # By default, C is the only stage 1 language.\n stage1_languages=c\n \n@@ -2279,6 +2423,7 @@ if test -d ${srcdir}/gcc; then\n         lang_dirs=\n         boot_language=\n         build_by_default=\n+\tneed_gmp=\n         . ${lang_frag}\n         # This is quite sensitive to the ordering of the case statement arms.\n         case ,${enable_languages},:${language}:${have_gnat}:${build_by_default} in\n@@ -2307,7 +2452,13 @@ if test -d ${srcdir}/gcc; then\n             add_this_lang=no\n             ;;\n         esac\n-        case $add_this_lang in\n+\n+\t# Disable language that need GMP if it isn't available.\n+\tif test  x\"$need_gmp\" = xyes && test x\"$have_gmp\" = xno; then\n+\t  add_this_lang=no\n+\tfi\n+        \n+\tcase $add_this_lang in\n \t  no)\n             # Remove language-dependent dirs.\n             eval noconfigdirs='\"$noconfigdirs \"'\\\"$target_libs $lang_dirs\\\"\n@@ -2608,6 +2759,9 @@ if test x${with_newlib} != xno && echo \" ${target_configdirs} \" | grep \" target-\n   extra_host_args=\"$extra_host_args --with-newlib\"\n fi\n \n+if test x${with_libbanshee} = xyes && echo \" ${configdirs} \" | grep \" libbanshee \" >/dev/null 2>&1; then\n+  extra_host_args=\"$extra_host_args --with-libbanshee\"\n+fi\n \n # Default to using --with-stabs for certain targets.\n if test x${with_stabs} = x ; then\n@@ -2642,7 +2796,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2646: checking for $ac_word\" >&5\n+echo \"configure:2800: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_YACC'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2677,7 +2831,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2681: checking for $ac_word\" >&5\n+echo \"configure:2835: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_M4'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -2712,7 +2866,7 @@ do\n # Extract the first word of \"$ac_prog\", so it can be a program name with args.\n set dummy $ac_prog; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:2716: checking for $ac_word\" >&5\n+echo \"configure:2870: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DEFAULT_LEX'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3175,6 +3329,20 @@ else\n fi\n GCJ_FOR_TARGET=$GCJ_FOR_TARGET' $(FLAGS_FOR_TARGET)'\n \n+if test \"x${GFORTRAN_FOR_TARGET+set}\" = xset; then\n+  :\n+elif test -d ${srcdir}/gcc; then\n+  GFORTRAN_FOR_TARGET='$$r/gcc/gfortran -B$$r/gcc/'\n+elif test \"$host\" = \"$target\"; then\n+  GFORTRAN_FOR_TARGET='gfortran'\n+else\n+  GFORTRAN_FOR_TARGET=`echo gfortran | sed -e 's/x/x/' ${program_transform_name}`\n+fi\n+case $GFORTRAN_FOR_TARGET in\n+*' $(FLAGS_FOR_TARGET)') ;;\n+*) GFORTRAN_FOR_TARGET=$GFORTRAN_FOR_TARGET' $(FLAGS_FOR_TARGET)' ;;\n+esac\n+\n # Don't use libstdc++-v3's flags to configure/build itself.\n libstdcxx_flags='`test ! -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags || $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n raw_libstdcxx_flags='-L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n@@ -3216,6 +3384,7 @@ qqRAW_CXX_FOR_TARGET=`echo \"$qRAW_CXX_FOR_TARGET\" | sed -e 's,[$][$],$$$$,g'`\n # Wrap CC_FOR_TARGET and friends, for certain types of builds.\n CC_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${CC_FOR_TARGET}\"\n GCJ_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${GCJ_FOR_TARGET}\"\n+GFORTRAN_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${GFORTRAN_FOR_TARGET}\"\n CXX_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${qCXX_FOR_TARGET}\"\n RAW_CXX_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${qRAW_CXX_FOR_TARGET}\"\n CXX_FOR_TARGET_FOR_RECURSIVE_MAKE=\"\\$(STAGE_CC_WRAPPER) ${qqCXX_FOR_TARGET}\"\n@@ -3275,7 +3444,7 @@ test -n \"$target_alias\" && ncn_target_tool_prefix=$target_alias-\n   # Extract the first word of \"${ncn_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3279: checking for $ac_word\" >&5\n+echo \"configure:3448: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3308,7 +3477,7 @@ if test -z \"$ac_cv_prog_AR\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3312: checking for $ac_word\" >&5\n+echo \"configure:3481: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AR'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3347,7 +3516,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3351: checking for $ac_word\" >&5\n+echo \"configure:3520: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3380,7 +3549,7 @@ if test -z \"$ac_cv_prog_AS\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3384: checking for $ac_word\" >&5\n+echo \"configure:3553: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_AS'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3419,7 +3588,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3423: checking for $ac_word\" >&5\n+echo \"configure:3592: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3452,7 +3621,7 @@ if test -z \"$ac_cv_prog_DLLTOOL\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3456: checking for $ac_word\" >&5\n+echo \"configure:3625: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_DLLTOOL'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3491,7 +3660,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3495: checking for $ac_word\" >&5\n+echo \"configure:3664: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3524,7 +3693,7 @@ if test -z \"$ac_cv_prog_LD\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3528: checking for $ac_word\" >&5\n+echo \"configure:3697: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_LD'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3563,7 +3732,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3567: checking for $ac_word\" >&5\n+echo \"configure:3736: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3596,7 +3765,7 @@ if test -z \"$ac_cv_prog_NM\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3600: checking for $ac_word\" >&5\n+echo \"configure:3769: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_NM'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3635,7 +3804,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3639: checking for $ac_word\" >&5\n+echo \"configure:3808: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3668,7 +3837,7 @@ if test -z \"$ac_cv_prog_RANLIB\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3672: checking for $ac_word\" >&5\n+echo \"configure:3841: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_RANLIB'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3707,7 +3876,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3711: checking for $ac_word\" >&5\n+echo \"configure:3880: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3740,7 +3909,7 @@ if test -z \"$ac_cv_prog_WINDRES\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3744: checking for $ac_word\" >&5\n+echo \"configure:3913: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_WINDRES'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3779,7 +3948,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objcopy\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3783: checking for $ac_word\" >&5\n+echo \"configure:3952: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3812,7 +3981,7 @@ if test -z \"$ac_cv_prog_OBJCOPY\" ; then\n     # Extract the first word of \"objcopy\", so it can be a program name with args.\n set dummy objcopy; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3816: checking for $ac_word\" >&5\n+echo \"configure:3985: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJCOPY'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3851,7 +4020,7 @@ fi\n   # Extract the first word of \"${ncn_tool_prefix}objdump\", so it can be a program name with args.\n set dummy ${ncn_tool_prefix}objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3855: checking for $ac_word\" >&5\n+echo \"configure:4024: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3884,7 +4053,7 @@ if test -z \"$ac_cv_prog_OBJDUMP\" ; then\n     # Extract the first word of \"objdump\", so it can be a program name with args.\n set dummy objdump; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3888: checking for $ac_word\" >&5\n+echo \"configure:4057: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_OBJDUMP'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3933,7 +4102,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ar\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3937: checking for $ac_word\" >&5\n+echo \"configure:4106: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -3966,7 +4135,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AR_FOR_TARGET\" ; then\n     # Extract the first word of \"ar\", so it can be a program name with args.\n set dummy ar; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:3970: checking for $ac_word\" >&5\n+echo \"configure:4139: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AR_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4005,7 +4174,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}as\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4009: checking for $ac_word\" >&5\n+echo \"configure:4178: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4038,7 +4207,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_AS_FOR_TARGET\" ; then\n     # Extract the first word of \"as\", so it can be a program name with args.\n set dummy as; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4042: checking for $ac_word\" >&5\n+echo \"configure:4211: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_AS_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4077,7 +4246,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}dlltool\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4081: checking for $ac_word\" >&5\n+echo \"configure:4250: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4110,7 +4279,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_DLLTOOL_FOR_TARGET\" ; then\n     # Extract the first word of \"dlltool\", so it can be a program name with args.\n set dummy dlltool; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4114: checking for $ac_word\" >&5\n+echo \"configure:4283: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_DLLTOOL_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4149,7 +4318,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ld\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4153: checking for $ac_word\" >&5\n+echo \"configure:4322: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4182,7 +4351,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_LD_FOR_TARGET\" ; then\n     # Extract the first word of \"ld\", so it can be a program name with args.\n set dummy ld; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4186: checking for $ac_word\" >&5\n+echo \"configure:4355: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_LD_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4221,7 +4390,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}nm\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4225: checking for $ac_word\" >&5\n+echo \"configure:4394: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4254,7 +4423,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_NM_FOR_TARGET\" ; then\n     # Extract the first word of \"nm\", so it can be a program name with args.\n set dummy nm; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4258: checking for $ac_word\" >&5\n+echo \"configure:4427: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_NM_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4293,7 +4462,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}ranlib\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4297: checking for $ac_word\" >&5\n+echo \"configure:4466: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4326,7 +4495,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_RANLIB_FOR_TARGET\" ; then\n     # Extract the first word of \"ranlib\", so it can be a program name with args.\n set dummy ranlib; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4330: checking for $ac_word\" >&5\n+echo \"configure:4499: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_RANLIB_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4365,7 +4534,7 @@ fi\n   # Extract the first word of \"${ncn_target_tool_prefix}windres\", so it can be a program name with args.\n set dummy ${ncn_target_tool_prefix}windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4369: checking for $ac_word\" >&5\n+echo \"configure:4538: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4398,7 +4567,7 @@ if test -z \"$ac_cv_prog_CONFIGURED_WINDRES_FOR_TARGET\" ; then\n     # Extract the first word of \"windres\", so it can be a program name with args.\n set dummy windres; ac_word=$2\n echo $ac_n \"checking for $ac_word\"\"... $ac_c\" 1>&6\n-echo \"configure:4402: checking for $ac_word\" >&5\n+echo \"configure:4571: checking for $ac_word\" >&5\n if eval \"test \\\"`echo '$''{'ac_cv_prog_ncn_cv_CONFIGURED_WINDRES_FOR_TARGET'+set}'`\\\" = set\"; then\n   echo $ac_n \"(cached) $ac_c\" 1>&6\n else\n@@ -4443,6 +4612,7 @@ fi\n \n \n \n+\n # Fix up target tools.\n if test \"x${build}\" = \"x${host}\" ; then\n   # In this case, the newly built tools can and should be used,\n@@ -4482,7 +4652,7 @@ RANLIB_FOR_TARGET=${RANLIB_FOR_TARGET}${extra_ranlibflags_for_target}\n NM_FOR_TARGET=${NM_FOR_TARGET}${extra_nmflags_for_target}\n \n echo $ac_n \"checking whether to enable maintainer-specific portions of Makefiles\"\"... $ac_c\" 1>&6\n-echo \"configure:4486: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n+echo \"configure:4656: checking whether to enable maintainer-specific portions of Makefiles\" >&5\n # Check whether --enable-maintainer-mode or --disable-maintainer-mode was given.\n if test \"${enable_maintainer_mode+set}\" = set; then\n   enableval=\"$enable_maintainer_mode\"\n@@ -4607,15 +4777,34 @@ trap 'rm -f $CONFIG_STATUS conftest*; exit 1' 1 2 15\n # Transform confdefs.h into DEFS.\n # Protect against shell expansion while executing Makefile rules.\n # Protect against Makefile macro expansion.\n-cat > conftest.defs <<\\EOF\n-s%#define \\([A-Za-z_][A-Za-z0-9_]*\\) *\\(.*\\)%-D\\1=\\2%g\n-s%[ \t`~#$^&*(){}\\\\|;'\"<>?]%\\\\&%g\n-s%\\[%\\\\&%g\n-s%\\]%\\\\&%g\n-s%\\$%$$%g\n-EOF\n-DEFS=`sed -f conftest.defs confdefs.h | tr '\\012' ' '`\n-rm -f conftest.defs\n+#\n+# If the first sed substitution is executed (which looks for macros that\n+# take arguments), then we branch to the quote section.  Otherwise,\n+# look for a macro that doesn't take arguments.\n+cat >confdef2opt.sed <<\\_ACEOF\n+t clear\n+: clear\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t(][^ \t(]*([^)]*)\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+s,^[ \t]*#[ \t]*define[ \t][ \t]*\\([^ \t][^ \t]*\\)[ \t]*\\(.*\\),-D\\1=\\2,g\n+t quote\n+d\n+: quote\n+s,[ \t`~#$^&*(){}\\\\|;'\"<>?],\\\\&,g\n+s,\\[,\\\\&,g\n+s,\\],\\\\&,g\n+s,\\$,$$,g\n+p\n+_ACEOF\n+# We use echo to avoid assuming a particular line-breaking character.\n+# The extra dot is to prevent the shell from consuming trailing\n+# line-breaks from the sub-command output.  A line-break within\n+# single-quotes doesn't work because, if this script is created in a\n+# platform that uses two characters for line-breaks (e.g., DOS), tr\n+# would break.\n+ac_LF_and_DOT=`echo; echo .`\n+DEFS=`sed -n -f confdef2opt.sed confdefs.h | tr \"$ac_LF_and_DOT\" ' .'`\n+rm -f confdef2opt.sed\n \n \n # Without the \"./\", some shells look in PATH for config.status.\n@@ -4711,6 +4900,8 @@ s%@target_subdir@%$target_subdir%g\n s%@CC@%$CC%g\n s%@GNATBIND@%$GNATBIND%g\n s%@do_compare@%$do_compare%g\n+s%@gmplibs@%$gmplibs%g\n+s%@gmpinc@%$gmpinc%g\n s%@stage1_languages@%$stage1_languages%g\n s%@DEFAULT_YACC@%$DEFAULT_YACC%g\n s%@DEFAULT_M4@%$DEFAULT_M4%g\n@@ -4789,6 +4980,7 @@ s%@GCC_FOR_TARGET@%$GCC_FOR_TARGET%g\n s%@FLAGS_FOR_TARGET@%$FLAGS_FOR_TARGET%g\n s%@CC_FOR_TARGET@%$CC_FOR_TARGET%g\n s%@GCJ_FOR_TARGET@%$GCJ_FOR_TARGET%g\n+s%@GFORTRAN_FOR_TARGET@%$GFORTRAN_FOR_TARGET%g\n s%@CXX_FOR_TARGET@%$CXX_FOR_TARGET%g\n s%@RAW_CXX_FOR_TARGET@%$RAW_CXX_FOR_TARGET%g\n s%@CXX_FOR_TARGET_FOR_RECURSIVE_MAKE@%$CXX_FOR_TARGET_FOR_RECURSIVE_MAKE%g"}, {"sha": "a3e1f863445eda9278218d916d0b08d1f1a1acaf", "filename": "configure.in", "status": "modified", "additions": 124, "deletions": 8, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/configure.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/configure.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/configure.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -126,7 +126,7 @@ fi\n \n # these libraries are used by various programs built for the host environment\n #\n-host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl tix libgui zlib\"\n+host_libs=\"intl mmalloc libiberty opcodes bfd readline tcl tk itcl tix libgui zlib libbanshee\"\n \n # these tools are built for the host environment\n # Note, the powerpc-eabi build depends on sim occurring before gdb in order to\n@@ -149,7 +149,9 @@ target_libraries=\"target-libiberty \\\n \t\ttarget-libgloss \\\n \t\ttarget-newlib \\\n \t\ttarget-libstdc++-v3 \\\n+\t\ttarget-libmudflap \\\n \t\ttarget-libf2c \\\n+\t\ttarget-libgfortran \\\n \t\t${libgcj} \\\n \t\ttarget-libobjc \\\n \t\ttarget-libada\"\n@@ -307,6 +309,18 @@ case \"${host}\" in\n     ;;\n esac\n \n+AC_ARG_WITH(libbanshee,\n+[  --without-libbanshee   Don't build with libbanshee])\n+case ${with_libbanshee} in\n+  no)\n+    noconfigdirs=\"$noconfigdirs libbanshee\" ;;\n+  yes|\"\")\n+    with_libbanshee=yes\n+    ;;\n+  *)\n+    AC_MSG_ERROR([--with-libbanshee can only be empty, \"yes\" or \"no\" (empty defaults to \"yes\".])\n+esac\n+\n AC_ARG_ENABLE(libada,\n [  --enable-libada        Builds libada directory],\n ENABLE_LIBADA=$enableval,\n@@ -331,6 +345,18 @@ no)\n   ;;\n esac\n \n+\n+# Allow --disable-libmudflap to exclude target-libmudflap\n+case $enable_libmudflap in\n+yes | \"\")\n+    # By default it's enabled\n+    ;;\n+no)\n+    noconfigdirs=\"$noconfigdirs target-libmudflap\"\n+    ;;\n+esac\n+\n+\n case \"${target}\" in\n   *-*-chorusos)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n@@ -346,6 +372,22 @@ case \"${target}\" in\n   *-*-freebsd[[12]] | *-*-freebsd[[12]].* | *-*-freebsd*aout*)\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n     ;;\n+  *-*-freebsd* | *-*-kfreebsd*-gnu)\n+    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n+    if test \"x$with_gmp\" = x && test \"x$with_gmp_dir\" = x \\\n+\t&& test -f /usr/local/include/gmp.h; then\n+      with_gmp=/usr/local\n+    fi\n+\n+    # Skip some stuff that's unsupported on some FreeBSD configurations.\n+    case \"${target}\" in\n+      i*86-*-*) ;;\n+      alpha*-*-*) ;;\n+      *)\n+\tnoconfigdirs=\"$noconfigdirs ${libgcj}\"\n+\t;;\n+    esac\n+    ;;\n   *-*-kaos*)\n     # Remove unsupported stuff on all kaOS configurations.\n     skipdirs=\"target-libiberty ${libgcj} target-libstdc++-v3 target-libf2c target-librx\"\n@@ -397,9 +439,6 @@ case \"${target}\" in\n     # newlib is not 64 bit ready\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n     ;;\n-  alpha*-*-freebsd* | alpha*-*-kfreebsd*-gnu)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    ;;\n   alpha*-*-*)\n     # newlib is not 64 bit ready\n     noconfigdirs=\"$noconfigdirs target-newlib target-libgloss ${libgcj}\"\n@@ -518,9 +557,6 @@ case \"${target}\" in\n   i[[3456789]]86-*-coff | i[[3456789]]86-*-elf)\n     noconfigdirs=\"$noconfigdirs ${libgcj}\"\n     ;;\n-  i[[3456789]]86-*-freebsd* | i[[3456789]]86-*-kfreebsd*-gnu)\n-    noconfigdirs=\"$noconfigdirs target-newlib target-libgloss\"\n-    ;;\n   i[[3456789]]86-*-linux*)\n     # The GCC port for glibc1 has no MD_FALLBACK_FRAME_STATE_FOR, so let's\n     # not build java stuff by default.\n@@ -1070,6 +1106,60 @@ fi\n ACX_PROG_GNAT\n ACX_PROG_CMP_IGNORE_INITIAL\n \n+# Check for GMP\n+gmplibs=\n+gmpinc=\n+have_gmp=yes\n+# Specify a location for gmp\n+AC_ARG_WITH(gmp-dir, [  --with-gmp-dir=PATH     Specify source directory for GMP library])\n+\n+if test \"x$with_gmp_dir\" != x && test -f \"$with_gmp_dir/gmp.h\"; then\n+  gmpinc=\"-I$with_gmp_dir\"\n+  if test -f \"$with_gmp_dir/.libs/libgmp.a\"; then\n+    gmplibs=\"$with_gmp_dir/.libs/libgmp.a\"\n+  elif test -f \"$with_gmp_dir/_libs/libgmp.a\"; then\n+    gmplibs=\"$with_gmp_dir/_libs/libgmp.a\"\n+  fi\n+  # One of the later tests will catch the error if neither library is present.\n+fi\n+\n+AC_ARG_WITH(gmp, [  --with-gmp=PATH         Specify directory for installed GMP library])\n+\n+if test \"x$with_gmp\" != x && test -d \"$with_gmp\"; then\n+  gmplibs=\"-L$with_gmp/lib -lgmp\"\n+  gmpinc=\"-I$with_gmp/include\"\n+fi\n+\n+# Use system gmp if nothing else specified\n+if test \"x$gmplibs\" = x; then\n+  gmplibs=\"-lgmp\"\n+fi\n+\n+saved_CFLAGS=\"$CFLAGS\"\n+CFLAGS=\"$CFLAGS $gmpinc\"\n+# Check GMP actually works\n+AC_MSG_CHECKING([for correct version of gmp.h])\n+AC_TRY_COMPILE([#include \"gmp.h\"],[\n+#if __GNU_MP_VERSION < 3\n+choke me\n+#endif\n+], [AC_MSG_RESULT([yes])],\n+  [AC_MSG_RESULT([no]); have_gmp=no])\n+\n+if test x\"$have_gmp\" = xyes; then\n+  AC_MSG_CHECKING([for mpf_init in -lgmp])\n+\n+  saved_LIBS=\"$LIBS\"\n+  LIBS=\"$LIBS $gmplibs\"\n+  AC_TRY_LINK([#include <gmp.h>], [mpf_t n; mpf_init(n);],\n+    [AC_MSG_RESULT([yes])],  [AC_MSG_RESULT([no]); have_gmp=no])\n+  LIBS=\"$saved_LIBS\"\n+  CFLAGS=\"$saved_CFLAGS\"\n+fi\n+\n+AC_SUBST(gmplibs)\n+AC_SUBST(gmpinc)\n+\n # By default, C is the only stage 1 language.\n stage1_languages=c\n AC_SUBST(stage1_languages)\n@@ -1142,6 +1232,7 @@ if test -d ${srcdir}/gcc; then\n         lang_dirs=\n         boot_language=\n         build_by_default=\n+\tneed_gmp=\n         . ${lang_frag}\n         # This is quite sensitive to the ordering of the case statement arms.\n         case ,${enable_languages},:${language}:${have_gnat}:${build_by_default} in\n@@ -1170,7 +1261,13 @@ if test -d ${srcdir}/gcc; then\n             add_this_lang=no\n             ;;\n         esac\n-        case $add_this_lang in\n+\n+\t# Disable language that need GMP if it isn't available.\n+\tif test  x\"$need_gmp\" = xyes && test x\"$have_gmp\" = xno; then\n+\t  add_this_lang=no\n+\tfi\n+        \n+\tcase $add_this_lang in\n \t  no)\n             # Remove language-dependent dirs.\n             eval noconfigdirs='\"$noconfigdirs \"'\\\"$target_libs $lang_dirs\\\"\n@@ -1471,6 +1568,9 @@ if test x${with_newlib} != xno && echo \" ${target_configdirs} \" | grep \" target-\n   extra_host_args=\"$extra_host_args --with-newlib\"\n fi\n \n+if test x${with_libbanshee} = xyes && echo \" ${configdirs} \" | grep \" libbanshee \" >/dev/null 2>&1; then\n+  extra_host_args=\"$extra_host_args --with-libbanshee\"\n+fi\n \n # Default to using --with-stabs for certain targets.\n if test x${with_stabs} = x ; then\n@@ -1935,6 +2035,20 @@ else\n fi\n GCJ_FOR_TARGET=$GCJ_FOR_TARGET' $(FLAGS_FOR_TARGET)'\n \n+if test \"x${GFORTRAN_FOR_TARGET+set}\" = xset; then\n+  :\n+elif test -d ${srcdir}/gcc; then\n+  GFORTRAN_FOR_TARGET='$$r/gcc/gfortran -B$$r/gcc/'\n+elif test \"$host\" = \"$target\"; then\n+  GFORTRAN_FOR_TARGET='gfortran'\n+else\n+  GFORTRAN_FOR_TARGET=`echo gfortran | sed -e 's/x/x/' ${program_transform_name}`\n+fi\n+case $GFORTRAN_FOR_TARGET in\n+*' $(FLAGS_FOR_TARGET)') ;;\n+*) GFORTRAN_FOR_TARGET=$GFORTRAN_FOR_TARGET' $(FLAGS_FOR_TARGET)' ;;\n+esac\n+\n # Don't use libstdc++-v3's flags to configure/build itself.\n libstdcxx_flags='`test ! -f $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags || $(SHELL) $$r/$(TARGET_SUBDIR)/libstdc++-v3/scripts/testsuite_flags --build-includes` -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n raw_libstdcxx_flags='-L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src -L$$r/$(TARGET_SUBDIR)/libstdc++-v3/src/.libs'\n@@ -1976,6 +2090,7 @@ qqRAW_CXX_FOR_TARGET=`echo \"$qRAW_CXX_FOR_TARGET\" | sed -e 's,[[$]][[$]],$$$$,g'\n # Wrap CC_FOR_TARGET and friends, for certain types of builds.\n CC_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${CC_FOR_TARGET}\"\n GCJ_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${GCJ_FOR_TARGET}\"\n+GFORTRAN_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${GFORTRAN_FOR_TARGET}\"\n CXX_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${qCXX_FOR_TARGET}\"\n RAW_CXX_FOR_TARGET=\"\\$(STAGE_CC_WRAPPER) ${qRAW_CXX_FOR_TARGET}\"\n CXX_FOR_TARGET_FOR_RECURSIVE_MAKE=\"\\$(STAGE_CC_WRAPPER) ${qqCXX_FOR_TARGET}\"\n@@ -2057,6 +2172,7 @@ AC_SUBST(GCC_FOR_TARGET)\n AC_SUBST(FLAGS_FOR_TARGET)\n AC_SUBST(CC_FOR_TARGET)\n AC_SUBST(GCJ_FOR_TARGET)\n+AC_SUBST(GFORTRAN_FOR_TARGET)\n AC_SUBST(CXX_FOR_TARGET)\n AC_SUBST(RAW_CXX_FOR_TARGET)\n AC_SUBST(CXX_FOR_TARGET_FOR_RECURSIVE_MAKE)"}, {"sha": "6451d6f0e90fb03d5a01bdfba9137acde1546c0c", "filename": "contrib/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1,3 +1,14 @@\n+2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-ssa-20020619-branch.\n+\n+\t* filter_gcc_for_doxygen: New file.\n+\t* filter_knr2ansi.pl: New file.\n+\t* filter_params.pl: New file.\n+\t* tree-ssa.doxy: New file.\n+\t* contrib/gcc_update (files_and_dependencies): Handle\n+\tlibbanshee and libmudflap.\n+\n 2004-04-12  Kelley Cook  <kcook@gcc.gnu.org>\n             Andreas Jaeger  <aj@suse.de>\n "}, {"sha": "2c1165f79b2b5190bd18377c40e6685ce8389926", "filename": "contrib/ChangeLog.tree-ssa", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,46 @@\n+2004-03-25  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* gcc_update (files_and_dependencies): Add libbanshee and\n+\tlibmudflap dependencies.\n+\n+2003-11-27  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.doxy (FILE_PATTERNS): Update.\n+\n+2003-11-21  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.doxy: Do not generate latex output.\n+\n+2003-07-21  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.doxy: Include tree* files\n+\n+2003-07-15  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.doxy: Add tree-must-alias.c.\n+\n+2003-01-28  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* filter_params.pl: Surround comments in @verbatim/@endverbatim.\n+\n+2003-01-19  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* tree-ssa.doxy (OUTPUT_DIRECTORY, INPUT_FILTER): Replace\n+\thardwired values for with replaceable strings.\n+\n+2003-01-18  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* filter_params.pl: Change most comments to start with /**.\n+\n+2002-12-23  Steven Bosscher <Steven.Bosscher@usafa.af.mil>\n+\n+\t* filter_params.pl: Filter ATTRIBUTE_UNUSED.\n+\n+2002-12-12  Daniel Berlin  <dberlin@dberlin.org>\n+\t    Steven Bosscher <Steven.Bosscher@usafa.af.mil>\n+\t    Diego Novillo <dnovillo@redhat.com>\n+\n+\t* filter_gcc_for_doxygen: New file.\n+\t* filter_knr2ansi.pl: New file.\n+\t* filter_params.pl: New file.\n+\t* tree-ssa.doxy: New file."}, {"sha": "3787eebbf0e7435c021671aa2af8e1792499bfdd", "filename": "contrib/filter_gcc_for_doxygen", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_gcc_for_doxygen", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_gcc_for_doxygen", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ffilter_gcc_for_doxygen?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,12 @@\n+#!/bin/sh\n+\n+# This filters GCC source before Doxygen can get confused by it;\n+# this script is listed in the doxyfile. The output is not very\n+# pretty, but at least we get output that Doxygen can understand.\n+#\n+# $1 is a source file of some kind. The source we wish doxygen to\n+# process is put on stdout.\n+\n+dir=`dirname $0`\n+perl $dir/filter_params.pl < $1 | perl $dir/filter_knr2ansi.pl \n+exit 0"}, {"sha": "c05e8d2ed205a32ef4bcd08cdfb4ceac1ed194f6", "filename": "contrib/filter_knr2ansi.pl", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_knr2ansi.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_knr2ansi.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ffilter_knr2ansi.pl?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,45 @@\n+#!/usr/bin/perl\n+#\n+# Goes thourgh the input line by line to find K&R style function\n+# declarations, and replaces them with ANSI style declarations.\n+#\n+@blah = <>;\n+\n+for ($i = 0; $i < @blah; $i++)\n+{\n+\tif ($blah[$i] =~ /^([a-zA-Z_0-9]+)\\s*\\([^)]+\\)\\s*$/)\n+\t{\n+\t\t$name = $1;\n+\t\t$funci = $i;\n+\t\t$blah[$funci]=\"$name (\";\n+\t\t$i++;\n+\t\t$lastline = $i;\n+\t\twhile ($lastline < @blah && $blah[$lastline] !~ /^{/)\n+\t\t{\n+\t\t\t$lastline++;\n+\t\t}\n+\t\t$lastline--;\n+\t\twhile ($i < @blah && $blah[$i] !~ /^{/)\n+\t\t{\n+\t\t\t$arg = $blah[$i];\n+\t\t\tif ($i != $lastline)\n+\t\t\t{\n+\t\t\t\t$arg =~ s/;/,/g;\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\t$arg =~ s/;//g;\n+\t\t\t}\n+\t\t\t$blah[$i] = \"\";\n+\t\t\t$blah[$funci] = \"$blah[$funci]\" . \"$arg\";\n+\t\t\t$i++;\n+\t\t}\n+\t\t$blah[$funci] = \"$blah[$funci]\" . \")\\n\";\n+\t}\n+}\n+\n+for ($i = 0; $i < @blah; $i++)\n+{\n+\tprint $blah[$i];\n+}\n+"}, {"sha": "05861e376fe93aed3ab27a8898202fa2c5b9eea2", "filename": "contrib/filter_params.pl", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_params.pl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ffilter_params.pl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ffilter_params.pl?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,14 @@\n+#!/usr/bin/perl\n+\n+# Filters out some of the #defines used thourghout the GCC sources:\n+# - GTY(()) marks declarations for gengtype.c\n+# - PARAMS(()) is used for K&R compatibility. See ansidecl.h.\n+\n+while (<>) {\n+    s/^\\/\\* /\\/\\*\\* \\@verbatim /;\n+    s/\\*\\// \\@endverbatim \\*\\//;\n+    s/GTY[ \\t]*\\(\\(.*\\)\\)//g;\n+    s/[ \\t]ATTRIBUTE_UNUSED//g;\n+    s/PARAMS[ \\t]*\\(\\((.*?)\\)\\)/\\($1\\)/sg;\n+    print;\n+}"}, {"sha": "dda18afd5a49f55b3a21ff3b7657213f17e5a38b", "filename": "contrib/gcc_update", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Fgcc_update", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Fgcc_update", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc_update?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -80,6 +80,8 @@ libf2c/libI77/stamp-h.in: libf2c/libI77/configure.in\n libf2c/libI77/config.h.in: libf2c/libI77/configure.in libf2c/libI77/stamp-h.in\n libf2c/libU77/configure: libf2c/libU77/configure.in\n libf2c/libU77/stamp-h.in: libf2c/libU77/configure.in libf2c/libU77/acconfig.h\n+libbanshee/configure: libbanshee/configure.in\n+libmudflap/configure: libmudflap/configure.in\n libobjc/configure: libobjc/configure.ac\n zlib/aclocal.m4: zlib/configure.ac zlib/acinclude.m4\n zlib/Makefile.in: zlib/Makefile.am zlib/configure.ac zlib/aclocal.m4"}, {"sha": "68d8f205ef19f14933fe2700fcaeb4658c8cef73", "filename": "contrib/tree-ssa.doxy", "status": "added", "additions": 932, "deletions": 0, "changes": 932, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ftree-ssa.doxy", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/contrib%2Ftree-ssa.doxy", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Ftree-ssa.doxy?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,932 @@\n+# Doxyfile 1.2.18\n+\n+# This file describes the settings to be used by the documentation system\n+# doxygen (www.doxygen.org) for a project\n+#\n+# All text after a hash (#) is considered a comment and will be ignored\n+# The format is:\n+#       TAG = value [value, ...]\n+# For lists items can also be appended using:\n+#       TAG += value [value, ...]\n+# Values that contain spaces should be placed between quotes (\" \")\n+\n+\n+#-----------------------------------------------------------------------------\n+# NOTE: YOU MUST EDIT THE FOLLOWING HARDWIRED PATHS BEFORE USING THIS FILE.\n+#-----------------------------------------------------------------------------\n+\n+# The OUTPUT_DIRECTORY tag is used to specify the (relative or absolute) \n+# base path where the generated documentation will be put. \n+# If a relative path is entered, it will be relative to the location \n+# where doxygen was started. If left blank the current directory will be used.\n+\n+OUTPUT_DIRECTORY       = @OUTPUT_DIRECTORY@\n+\n+# The INPUT_FILTER tag can be used to specify a program that doxygen should \n+# invoke to filter for each input file. Doxygen will invoke the filter program \n+# by executing (via popen()) the command <filter> <input-file>, where <filter> \n+# is the value of the INPUT_FILTER tag, and <input-file> is the name of an \n+# input file. Doxygen will then use the output that the filter program writes \n+# to standard output.\n+\n+INPUT_FILTER           = @INPUT_FILTER@\n+\n+#-----------------------------------------------------------------------------\n+\n+\n+\n+\n+#---------------------------------------------------------------------------\n+# General configuration options\n+#---------------------------------------------------------------------------\n+\n+# The PROJECT_NAME tag is a single word (or a sequence of words surrounded \n+# by quotes) that should identify the project.\n+\n+PROJECT_NAME           = \"Tree SSA\"\n+\n+# The PROJECT_NUMBER tag can be used to enter a project or revision number. \n+# This could be handy for archiving the generated documentation or \n+# if some version control system is used.\n+\n+PROJECT_NUMBER         = \n+\n+\n+# The OUTPUT_LANGUAGE tag is used to specify the language in which all \n+# documentation generated by doxygen is written. Doxygen will use this \n+# information to generate all constant output in the proper language. \n+# The default language is English, other supported languages are: \n+# Brazilian, Chinese, Croatian, Czech, Danish, Dutch, Finnish, French, \n+# German, Greek, Hungarian, Italian, Japanese, Korean, Norwegian, Polish, \n+# Portuguese, Romanian, Russian, Slovak, Slovene, Spanish and Swedish.\n+\n+OUTPUT_LANGUAGE        = English\n+\n+# If the EXTRACT_ALL tag is set to YES doxygen will assume all entities in \n+# documentation are documented, even if no documentation was available. \n+# Private class members and static file members will be hidden unless \n+# the EXTRACT_PRIVATE and EXTRACT_STATIC tags are set to YES\n+\n+EXTRACT_ALL            = YES\n+\n+# If the EXTRACT_PRIVATE tag is set to YES all private members of a class \n+# will be included in the documentation.\n+\n+EXTRACT_PRIVATE        = YES\n+\n+# If the EXTRACT_STATIC tag is set to YES all static members of a file \n+# will be included in the documentation.\n+\n+EXTRACT_STATIC         = YES\n+\n+# If the EXTRACT_LOCAL_CLASSES tag is set to YES classes (and structs) \n+# defined locally in source files will be included in the documentation. \n+# If set to NO only classes defined in header files are included.\n+\n+EXTRACT_LOCAL_CLASSES  = YES\n+\n+# If the HIDE_UNDOC_MEMBERS tag is set to YES, Doxygen will hide all \n+# undocumented members of documented classes, files or namespaces. \n+# If set to NO (the default) these members will be included in the \n+# various overviews, but no documentation section is generated. \n+# This option has no effect if EXTRACT_ALL is enabled.\n+\n+HIDE_UNDOC_MEMBERS     = NO\n+\n+# If the HIDE_UNDOC_CLASSES tag is set to YES, Doxygen will hide all \n+# undocumented classes that are normally visible in the class hierarchy. \n+# If set to NO (the default) these class will be included in the various \n+# overviews. This option has no effect if EXTRACT_ALL is enabled.\n+\n+HIDE_UNDOC_CLASSES     = NO\n+\n+# If the BRIEF_MEMBER_DESC tag is set to YES (the default) Doxygen will \n+# include brief member descriptions after the members that are listed in \n+# the file and class documentation (similar to JavaDoc). \n+# Set to NO to disable this.\n+\n+BRIEF_MEMBER_DESC      = YES\n+\n+# If the REPEAT_BRIEF tag is set to YES (the default) Doxygen will prepend \n+# the brief description of a member or function before the detailed description. \n+# Note: if both HIDE_UNDOC_MEMBERS and BRIEF_MEMBER_DESC are set to NO, the \n+# brief descriptions will be completely suppressed.\n+\n+REPEAT_BRIEF           = YES\n+\n+# If the ALWAYS_DETAILED_SEC and REPEAT_BRIEF tags are both set to YES then \n+# Doxygen will generate a detailed section even if there is only a brief \n+# description.\n+\n+ALWAYS_DETAILED_SEC    = YES\n+\n+# If the INLINE_INHERITED_MEMB tag is set to YES, doxygen will show all inherited \n+# members of a class in the documentation of that class as if those members were \n+# ordinary class members. Constructors, destructors and assignment operators of \n+# the base classes will not be shown.\n+\n+INLINE_INHERITED_MEMB  = YES\n+\n+# If the FULL_PATH_NAMES tag is set to YES then Doxygen will prepend the full \n+# path before files name in the file list and in the header files. If set \n+# to NO the shortest path that makes the file name unique will be used.\n+\n+FULL_PATH_NAMES        = NO\n+\n+# If the FULL_PATH_NAMES tag is set to YES then the STRIP_FROM_PATH tag \n+# can be used to strip a user defined part of the path. Stripping is \n+# only done if one of the specified strings matches the left-hand part of \n+# the path. It is allowed to use relative paths in the argument list.\n+\n+STRIP_FROM_PATH        = \n+\n+# The INTERNAL_DOCS tag determines if documentation \n+# that is typed after a \\internal command is included. If the tag is set \n+# to NO (the default) then the documentation will be excluded. \n+# Set it to YES to include the internal documentation.\n+\n+INTERNAL_DOCS          = NO\n+\n+# Setting the STRIP_CODE_COMMENTS tag to YES (the default) will instruct \n+# doxygen to hide any special comment blocks from generated source code \n+# fragments. Normal C and C++ comments will always remain visible.\n+\n+STRIP_CODE_COMMENTS    = YES\n+\n+# If the CASE_SENSE_NAMES tag is set to NO then Doxygen will only generate \n+# file names in lower case letters. If set to YES upper case letters are also \n+# allowed. This is useful if you have classes or files whose names only differ \n+# in case and if your file system supports case sensitive file names. Windows \n+# users are adviced to set this option to NO.\n+\n+CASE_SENSE_NAMES       = YES\n+\n+# If the SHORT_NAMES tag is set to YES, doxygen will generate much shorter \n+# (but less readable) file names. This can be useful is your file systems \n+# doesn't support long names like on DOS, Mac, or CD-ROM.\n+\n+SHORT_NAMES            = NO\n+\n+# If the HIDE_SCOPE_NAMES tag is set to NO (the default) then Doxygen \n+# will show members with their full class and namespace scopes in the \n+# documentation. If set to YES the scope will be hidden.\n+\n+HIDE_SCOPE_NAMES       = NO\n+\n+# If the VERBATIM_HEADERS tag is set to YES (the default) then Doxygen \n+# will generate a verbatim copy of the header file for each class for \n+# which an include is specified. Set to NO to disable this.\n+\n+VERBATIM_HEADERS       = YES\n+\n+# If the SHOW_INCLUDE_FILES tag is set to YES (the default) then Doxygen \n+# will put list of the files that are included by a file in the documentation \n+# of that file.\n+\n+SHOW_INCLUDE_FILES     = YES\n+\n+# If the JAVADOC_AUTOBRIEF tag is set to YES then Doxygen \n+# will interpret the first line (until the first dot) of a JavaDoc-style \n+# comment as the brief description. If set to NO, the JavaDoc \n+# comments  will behave just like the Qt-style comments (thus requiring an \n+# explict @brief command for a brief description.\n+\n+JAVADOC_AUTOBRIEF      = NO\n+\n+# If the INHERIT_DOCS tag is set to YES (the default) then an undocumented \n+# member inherits the documentation from any documented member that it \n+# reimplements.\n+\n+INHERIT_DOCS           = YES\n+\n+# If the INLINE_INFO tag is set to YES (the default) then a tag [inline] \n+# is inserted in the documentation for inline members.\n+\n+INLINE_INFO            = YES\n+\n+# If the SORT_MEMBER_DOCS tag is set to YES (the default) then doxygen \n+# will sort the (detailed) documentation of file and class members \n+# alphabetically by member name. If set to NO the members will appear in \n+# declaration order.\n+\n+SORT_MEMBER_DOCS       = YES\n+\n+# If member grouping is used in the documentation and the DISTRIBUTE_GROUP_DOC \n+# tag is set to YES, then doxygen will reuse the documentation of the first \n+# member in the group (if any) for the other members of the group. By default \n+# all members of a group must be documented explicitly.\n+\n+DISTRIBUTE_GROUP_DOC   = NO\n+\n+# The TAB_SIZE tag can be used to set the number of spaces in a tab. \n+# Doxygen uses this value to replace tabs by spaces in code fragments.\n+\n+TAB_SIZE               = 8\n+\n+# The GENERATE_TODOLIST tag can be used to enable (YES) or \n+# disable (NO) the todo list. This list is created by putting \\todo \n+# commands in the documentation.\n+\n+GENERATE_TODOLIST      = YES\n+\n+# The GENERATE_TESTLIST tag can be used to enable (YES) or \n+# disable (NO) the test list. This list is created by putting \\test \n+# commands in the documentation.\n+\n+GENERATE_TESTLIST      = YES\n+\n+# The GENERATE_BUGLIST tag can be used to enable (YES) or \n+# disable (NO) the bug list. This list is created by putting \\bug \n+# commands in the documentation.\n+\n+GENERATE_BUGLIST       = YES\n+\n+# This tag can be used to specify a number of aliases that acts \n+# as commands in the documentation. An alias has the form \"name=value\". \n+# For example adding \"sideeffect=\\par Side Effects:\\n\" will allow you to \n+# put the command \\sideeffect (or @sideeffect) in the documentation, which \n+# will result in a user defined paragraph with heading \"Side Effects:\". \n+# You can put \\n's in the value part of an alias to insert newlines.\n+\n+ALIASES                = \n+\n+# The ENABLED_SECTIONS tag can be used to enable conditional \n+# documentation sections, marked by \\if sectionname ... \\endif.\n+\n+ENABLED_SECTIONS       = \n+\n+# The MAX_INITIALIZER_LINES tag determines the maximum number of lines \n+# the initial value of a variable or define consist of for it to appear in \n+# the documentation. If the initializer consists of more lines than specified \n+# here it will be hidden. Use a value of 0 to hide initializers completely. \n+# The appearance of the initializer of individual variables and defines in the \n+# documentation can be controlled using \\showinitializer or \\hideinitializer \n+# command in the documentation regardless of this setting.\n+\n+MAX_INITIALIZER_LINES  = 30\n+\n+# Set the OPTIMIZE_OUTPUT_FOR_C tag to YES if your project consists of C sources \n+# only. Doxygen will then generate output that is more tailored for C. \n+# For instance some of the names that are used will be different. The list \n+# of all members will be omitted, etc.\n+\n+OPTIMIZE_OUTPUT_FOR_C  = YES\n+\n+# Set the SHOW_USED_FILES tag to NO to disable the list of files generated \n+# at the bottom of the documentation of classes and structs. If set to YES the \n+# list will mention the files that were used to generate the documentation.\n+\n+SHOW_USED_FILES        = YES\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to warning and progress messages\n+#---------------------------------------------------------------------------\n+\n+# The QUIET tag can be used to turn on/off the messages that are generated \n+# by doxygen. Possible values are YES and NO. If left blank NO is used.\n+\n+QUIET                  = NO\n+\n+# The WARNINGS tag can be used to turn on/off the warning messages that are \n+# generated by doxygen. Possible values are YES and NO. If left blank \n+# NO is used.\n+\n+WARNINGS               = YES\n+\n+# If WARN_IF_UNDOCUMENTED is set to YES, then doxygen will generate warnings \n+# for undocumented members. If EXTRACT_ALL is set to YES then this flag will \n+# automatically be disabled.\n+\n+WARN_IF_UNDOCUMENTED   = YES\n+\n+# The WARN_FORMAT tag determines the format of the warning messages that \n+# doxygen can produce. The string should contain the $file, $line, and $text \n+# tags, which will be replaced by the file and line number from which the \n+# warning originated and the warning text.\n+\n+WARN_FORMAT            = \"$file:$line: $text\"\n+\n+# The WARN_LOGFILE tag can be used to specify a file to which warning \n+# and error messages should be written. If left blank the output is written \n+# to stderr.\n+\n+WARN_LOGFILE           = \n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the input files\n+#---------------------------------------------------------------------------\n+\n+# The INPUT tag can be used to specify the files and/or directories that contain \n+# documented source files. You may enter file names like \"myfile.cpp\" or \n+# directories like \"/usr/src/myproject\". Separate the files or directories \n+# with spaces.\n+\n+INPUT                  = .\n+\n+# If the value of the INPUT tag contains directories, you can use the \n+# FILE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp \n+# and *.h) to filter out the source-files in the directories. If left \n+# blank the following patterns are tested: \n+# *.c *.cc *.cxx *.cpp *.c++ *.java *.ii *.ixx *.ipp *.i++ *.inl *.h *.hh *.hxx *.hpp \n+# *.h++ *.idl *.odl\n+\n+FILE_PATTERNS          = tree* *mudflap* c-simplify.c gimpl* domwalk*\n+\n+# The RECURSIVE tag can be used to turn specify whether or not subdirectories \n+# should be searched for input files as well. Possible values are YES and NO. \n+# If left blank NO is used.\n+\n+RECURSIVE              = NO\n+\n+# The EXCLUDE tag can be used to specify files and/or directories that should \n+# excluded from the INPUT source files. This way you can easily exclude a \n+# subdirectory from a directory tree whose root is specified with the INPUT tag.\n+\n+EXCLUDE                = \n+\n+# The EXCLUDE_SYMLINKS tag can be used select whether or not files or directories \n+# that are symbolic links (a Unix filesystem feature) are excluded from the input.\n+\n+EXCLUDE_SYMLINKS       = NO\n+\n+# If the value of the INPUT tag contains directories, you can use the \n+# EXCLUDE_PATTERNS tag to specify one or more wildcard patterns to exclude \n+# certain files from those directories.\n+\n+EXCLUDE_PATTERNS       = \n+\n+# The EXAMPLE_PATH tag can be used to specify one or more files or \n+# directories that contain example code fragments that are included (see \n+# the \\include command).\n+\n+EXAMPLE_PATH           = \n+\n+# If the value of the EXAMPLE_PATH tag contains directories, you can use the \n+# EXAMPLE_PATTERNS tag to specify one or more wildcard pattern (like *.cpp \n+# and *.h) to filter out the source-files in the directories. If left \n+# blank all files are included.\n+\n+EXAMPLE_PATTERNS       = \n+\n+# If the EXAMPLE_RECURSIVE tag is set to YES then subdirectories will be \n+# searched for input files to be used with the \\include or \\dontinclude \n+# commands irrespective of the value of the RECURSIVE tag. \n+# Possible values are YES and NO. If left blank NO is used.\n+\n+EXAMPLE_RECURSIVE      = NO\n+\n+# The IMAGE_PATH tag can be used to specify one or more files or \n+# directories that contain image that are included in the documentation (see \n+# the \\image command).\n+\n+IMAGE_PATH             = \n+\n+# If the FILTER_SOURCE_FILES tag is set to YES, the input filter (if set using \n+# INPUT_FILTER) will be used to filter the input files when producing source \n+# files to browse.\n+\n+FILTER_SOURCE_FILES    = NO\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to source browsing\n+#---------------------------------------------------------------------------\n+\n+# If the SOURCE_BROWSER tag is set to YES then a list of source files will \n+# be generated. Documented entities will be cross-referenced with these sources.\n+\n+SOURCE_BROWSER         = YES\n+\n+# Setting the INLINE_SOURCES tag to YES will include the body \n+# of functions and classes directly in the documentation.\n+\n+INLINE_SOURCES         = YES\n+\n+# If the REFERENCED_BY_RELATION tag is set to YES (the default) \n+# then for each documented function all documented \n+# functions referencing it will be listed.\n+\n+REFERENCED_BY_RELATION = YES\n+\n+# If the REFERENCES_RELATION tag is set to YES (the default) \n+# then for each documented function all documented entities \n+# called/used by that function will be listed.\n+\n+REFERENCES_RELATION    = YES\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the alphabetical class index\n+#---------------------------------------------------------------------------\n+\n+# If the ALPHABETICAL_INDEX tag is set to YES, an alphabetical index \n+# of all compounds will be generated. Enable this if the project \n+# contains a lot of classes, structs, unions or interfaces.\n+\n+ALPHABETICAL_INDEX     = YES\n+\n+# If the alphabetical index is enabled (see ALPHABETICAL_INDEX) then \n+# the COLS_IN_ALPHA_INDEX tag can be used to specify the number of columns \n+# in which this list will be split (can be a number in the range [1..20])\n+\n+COLS_IN_ALPHA_INDEX    = 5\n+\n+# In case all classes in a project start with a common prefix, all \n+# classes will be put under the same header in the alphabetical index. \n+# The IGNORE_PREFIX tag can be used to specify one or more prefixes that \n+# should be ignored while generating the index headers.\n+\n+IGNORE_PREFIX          = \n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the HTML output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_HTML tag is set to YES (the default) Doxygen will \n+# generate HTML output.\n+\n+GENERATE_HTML          = YES\n+\n+# The HTML_OUTPUT tag is used to specify where the HTML docs will be put. \n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \n+# put in front of it. If left blank `html' will be used as the default path.\n+\n+HTML_OUTPUT            = html\n+\n+# The HTML_FILE_EXTENSION tag can be used to specify the file extension for \n+# each generated HTML page (for example: .htm,.php,.asp). If it is left blank \n+# doxygen will generate files with .html extension.\n+\n+HTML_FILE_EXTENSION    = .html\n+\n+# The HTML_HEADER tag can be used to specify a personal HTML header for \n+# each generated HTML page. If it is left blank doxygen will generate a \n+# standard header.\n+\n+HTML_HEADER            = \n+\n+# The HTML_FOOTER tag can be used to specify a personal HTML footer for \n+# each generated HTML page. If it is left blank doxygen will generate a \n+# standard footer.\n+\n+HTML_FOOTER            = \n+\n+# The HTML_STYLESHEET tag can be used to specify a user defined cascading \n+# style sheet that is used by each HTML page. It can be used to \n+# fine-tune the look of the HTML output. If the tag is left blank doxygen \n+# will generate a default style sheet\n+\n+HTML_STYLESHEET        = \n+\n+# If the HTML_ALIGN_MEMBERS tag is set to YES, the members of classes, \n+# files or namespaces will be aligned in HTML using tables. If set to \n+# NO a bullet list will be used.\n+\n+HTML_ALIGN_MEMBERS     = YES\n+\n+# If the GENERATE_HTMLHELP tag is set to YES, additional index files \n+# will be generated that can be used as input for tools like the \n+# Microsoft HTML help workshop to generate a compressed HTML help file (.chm) \n+# of the generated HTML documentation.\n+\n+GENERATE_HTMLHELP      = NO\n+\n+# If the GENERATE_HTMLHELP tag is set to YES, the GENERATE_CHI flag \n+# controls if a separate .chi index file is generated (YES) or that \n+# it should be included in the master .chm file (NO).\n+\n+GENERATE_CHI           = NO\n+\n+# If the GENERATE_HTMLHELP tag is set to YES, the BINARY_TOC flag \n+# controls whether a binary table of contents is generated (YES) or a \n+# normal table of contents (NO) in the .chm file.\n+\n+BINARY_TOC             = NO\n+\n+# The TOC_EXPAND flag can be set to YES to add extra items for group members \n+# to the contents of the Html help documentation and to the tree view.\n+\n+TOC_EXPAND             = NO\n+\n+# The DISABLE_INDEX tag can be used to turn on/off the condensed index at \n+# top of each HTML page. The value NO (the default) enables the index and \n+# the value YES disables it.\n+\n+DISABLE_INDEX          = NO\n+\n+# This tag can be used to set the number of enum values (range [1..20]) \n+# that doxygen will group on one line in the generated HTML documentation.\n+\n+ENUM_VALUES_PER_LINE   = 4\n+\n+# If the GENERATE_TREEVIEW tag is set to YES, a side panel will be\n+# generated containing a tree-like index structure (just like the one that \n+# is generated for HTML Help). For this to work a browser that supports \n+# JavaScript and frames is required (for instance Mozilla, Netscape 4.0+, \n+# or Internet explorer 4.0+). Note that for large projects the tree generation \n+# can take a very long time. In such cases it is better to disable this feature. \n+# Windows users are probably better off using the HTML help feature.\n+\n+GENERATE_TREEVIEW      = NO\n+\n+# If the treeview is enabled (see GENERATE_TREEVIEW) then this tag can be \n+# used to set the initial width (in pixels) of the frame in which the tree \n+# is shown.\n+\n+TREEVIEW_WIDTH         = 250\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the LaTeX output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_LATEX tag is set to YES (the default) Doxygen will \n+# generate Latex output.\n+\n+GENERATE_LATEX         = NO\n+\n+# The LATEX_OUTPUT tag is used to specify where the LaTeX docs will be put. \n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \n+# put in front of it. If left blank `latex' will be used as the default path.\n+\n+LATEX_OUTPUT           = latex\n+\n+# If the COMPACT_LATEX tag is set to YES Doxygen generates more compact \n+# LaTeX documents. This may be useful for small projects and may help to \n+# save some trees in general.\n+\n+COMPACT_LATEX          = NO\n+\n+# The PAPER_TYPE tag can be used to set the paper type that is used \n+# by the printer. Possible values are: a4, a4wide, letter, legal and \n+# executive. If left blank a4wide will be used.\n+\n+PAPER_TYPE             = letter\n+\n+# The EXTRA_PACKAGES tag can be to specify one or more names of LaTeX \n+# packages that should be included in the LaTeX output.\n+\n+EXTRA_PACKAGES         = \n+\n+# The LATEX_HEADER tag can be used to specify a personal LaTeX header for \n+# the generated latex document. The header should contain everything until \n+# the first chapter. If it is left blank doxygen will generate a \n+# standard header. Notice: only use this tag if you know what you are doing!\n+\n+LATEX_HEADER           = \n+\n+# If the PDF_HYPERLINKS tag is set to YES, the LaTeX that is generated \n+# is prepared for conversion to pdf (using ps2pdf). The pdf file will \n+# contain links (just like the HTML output) instead of page references \n+# This makes the output suitable for online browsing using a pdf viewer.\n+\n+PDF_HYPERLINKS         = YES\n+\n+# If the USE_PDFLATEX tag is set to YES, pdflatex will be used instead of \n+# plain latex in the generated Makefile. Set this option to YES to get a \n+# higher quality PDF documentation.\n+\n+USE_PDFLATEX           = YES\n+\n+# If the LATEX_BATCHMODE tag is set to YES, doxygen will add the \\\\batchmode. \n+# command to the generated LaTeX files. This will instruct LaTeX to keep \n+# running if errors occur, instead of asking the user for help. \n+# This option is also used when generating formulas in HTML.\n+\n+LATEX_BATCHMODE        = YES\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the RTF output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_RTF tag is set to YES Doxygen will generate RTF output \n+# The RTF output is optimised for Word 97 and may not look very pretty with \n+# other RTF readers or editors.\n+\n+GENERATE_RTF           = NO\n+\n+# The RTF_OUTPUT tag is used to specify where the RTF docs will be put. \n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \n+# put in front of it. If left blank `rtf' will be used as the default path.\n+\n+RTF_OUTPUT             = rtf\n+\n+# If the COMPACT_RTF tag is set to YES Doxygen generates more compact \n+# RTF documents. This may be useful for small projects and may help to \n+# save some trees in general.\n+\n+COMPACT_RTF            = NO\n+\n+# If the RTF_HYPERLINKS tag is set to YES, the RTF that is generated \n+# will contain hyperlink fields. The RTF file will \n+# contain links (just like the HTML output) instead of page references. \n+# This makes the output suitable for online browsing using WORD or other \n+# programs which support those fields. \n+# Note: wordpad (write) and others do not support links.\n+\n+RTF_HYPERLINKS         = NO\n+\n+# Load stylesheet definitions from file. Syntax is similar to doxygen's \n+# config file, i.e. a series of assigments. You only have to provide \n+# replacements, missing definitions are set to their default value.\n+\n+RTF_STYLESHEET_FILE    = \n+\n+# Set optional variables used in the generation of an rtf document. \n+# Syntax is similar to doxygen's config file.\n+\n+RTF_EXTENSIONS_FILE    = \n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the man page output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_MAN tag is set to YES (the default) Doxygen will \n+# generate man pages\n+\n+GENERATE_MAN           = NO\n+\n+# The MAN_OUTPUT tag is used to specify where the man pages will be put. \n+# If a relative path is entered the value of OUTPUT_DIRECTORY will be \n+# put in front of it. If left blank `man' will be used as the default path.\n+\n+MAN_OUTPUT             = man\n+\n+# The MAN_EXTENSION tag determines the extension that is added to \n+# the generated man pages (default is the subroutine's section .3)\n+\n+MAN_EXTENSION          = .3\n+\n+# If the MAN_LINKS tag is set to YES and Doxygen generates man output, \n+# then it will generate one additional man file for each entity \n+# documented in the real man page(s). These additional files \n+# only source the real man page, but without them the man command \n+# would be unable to find the correct page. The default is NO.\n+\n+MAN_LINKS              = NO\n+\n+#---------------------------------------------------------------------------\n+# configuration options related to the XML output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_XML tag is set to YES Doxygen will \n+# generate an XML file that captures the structure of \n+# the code including all documentation. Note that this \n+# feature is still experimental and incomplete at the \n+# moment.\n+\n+GENERATE_XML           = NO\n+\n+#---------------------------------------------------------------------------\n+# configuration options for the AutoGen Definitions output\n+#---------------------------------------------------------------------------\n+\n+# If the GENERATE_AUTOGEN_DEF tag is set to YES Doxygen will \n+# generate an AutoGen Definitions (see autogen.sf.net) file \n+# that captures the structure of the code including all \n+# documentation. Note that this feature is still experimental \n+# and incomplete at the moment.\n+\n+GENERATE_AUTOGEN_DEF   = NO\n+\n+#---------------------------------------------------------------------------\n+# Configuration options related to the preprocessor   \n+#---------------------------------------------------------------------------\n+\n+# If the ENABLE_PREPROCESSING tag is set to YES (the default) Doxygen will \n+# evaluate all C-preprocessor directives found in the sources and include \n+# files.\n+\n+ENABLE_PREPROCESSING   = YES\n+\n+# If the MACRO_EXPANSION tag is set to YES Doxygen will expand all macro \n+# names in the source code. If set to NO (the default) only conditional \n+# compilation will be performed. Macro expansion can be done in a controlled \n+# way by setting EXPAND_ONLY_PREDEF to YES.\n+\n+MACRO_EXPANSION        = NO\n+\n+# If the EXPAND_ONLY_PREDEF and MACRO_EXPANSION tags are both set to YES \n+# then the macro expansion is limited to the macros specified with the \n+# PREDEFINED and EXPAND_AS_PREDEFINED tags.\n+\n+EXPAND_ONLY_PREDEF     = NO\n+\n+# If the SEARCH_INCLUDES tag is set to YES (the default) the includes files \n+# in the INCLUDE_PATH (see below) will be search if a #include is found.\n+\n+SEARCH_INCLUDES        = YES\n+\n+# The INCLUDE_PATH tag can be used to specify one or more directories that \n+# contain include files that are not input files but should be processed by \n+# the preprocessor.\n+\n+INCLUDE_PATH           = \n+\n+# You can use the INCLUDE_FILE_PATTERNS tag to specify one or more wildcard \n+# patterns (like *.h and *.hpp) to filter out the header-files in the \n+# directories. If left blank, the patterns specified with FILE_PATTERNS will \n+# be used.\n+\n+INCLUDE_FILE_PATTERNS  = \n+\n+# The PREDEFINED tag can be used to specify one or more macro names that \n+# are defined before the preprocessor is started (similar to the -D option of \n+# gcc). The argument of the tag is a list of macros of the form: name \n+# or name=definition (no spaces). If the definition and the = are \n+# omitted =1 is assumed.\n+\n+PREDEFINED             = \n+\n+# If the MACRO_EXPANSION and EXPAND_PREDEF_ONLY tags are set to YES then \n+# this tag can be used to specify a list of macro names that should be expanded. \n+# The macro definition that is found in the sources will be used. \n+# Use the PREDEFINED tag if you want to use a different macro definition.\n+\n+EXPAND_AS_DEFINED      = \n+\n+# If the SKIP_FUNCTION_MACROS tag is set to YES (the default) then \n+# doxygen's preprocessor will remove all function-like macros that are alone \n+# on a line and do not end with a semicolon. Such function macros are typically \n+# used for boiler-plate code, and will confuse the parser if not removed.\n+\n+SKIP_FUNCTION_MACROS   = YES\n+\n+#---------------------------------------------------------------------------\n+# Configuration::addtions related to external references   \n+#---------------------------------------------------------------------------\n+\n+# The TAGFILES tag can be used to specify one or more tagfiles.\n+\n+TAGFILES               = \n+\n+# When a file name is specified after GENERATE_TAGFILE, doxygen will create \n+# a tag file that is based on the input files it reads.\n+\n+GENERATE_TAGFILE       = \n+\n+# If the ALLEXTERNALS tag is set to YES all external classes will be listed \n+# in the class index. If set to NO only the inherited external classes \n+# will be listed.\n+\n+ALLEXTERNALS           = NO\n+\n+# If the EXTERNAL_GROUPS tag is set to YES all external groups will be listed \n+# in the modules index. If set to NO, only the current project's groups will \n+# be listed.\n+\n+EXTERNAL_GROUPS        = YES\n+\n+# The PERL_PATH should be the absolute path and name of the perl script \n+# interpreter (i.e. the result of `which perl').\n+\n+PERL_PATH              = /usr/bin/perl\n+\n+#---------------------------------------------------------------------------\n+# Configuration options related to the dot tool   \n+#---------------------------------------------------------------------------\n+\n+# If the CLASS_DIAGRAMS tag is set to YES (the default) Doxygen will \n+# generate a inheritance diagram (in Html, RTF and LaTeX) for classes with base or \n+# super classes. Setting the tag to NO turns the diagrams off. Note that this \n+# option is superceded by the HAVE_DOT option below. This is only a fallback. It is \n+# recommended to install and use dot, since it yield more powerful graphs.\n+\n+CLASS_DIAGRAMS         = YES\n+\n+# If you set the HAVE_DOT tag to YES then doxygen will assume the dot tool is \n+# available from the path. This tool is part of Graphviz, a graph visualization \n+# toolkit from AT&T and Lucent Bell Labs. The other options in this section \n+# have no effect if this option is set to NO (the default)\n+\n+HAVE_DOT               = YES\n+\n+# If the CLASS_GRAPH and HAVE_DOT tags are set to YES then doxygen \n+# will generate a graph for each documented class showing the direct and \n+# indirect inheritance relations. Setting this tag to YES will force the \n+# the CLASS_DIAGRAMS tag to NO.\n+\n+CLASS_GRAPH            = YES\n+\n+# If the COLLABORATION_GRAPH and HAVE_DOT tags are set to YES then doxygen \n+# will generate a graph for each documented class showing the direct and \n+# indirect implementation dependencies (inheritance, containment, and \n+# class references variables) of the class with other documented classes.\n+\n+COLLABORATION_GRAPH    = YES\n+\n+# If set to YES, the inheritance and collaboration graphs will show the \n+# relations between templates and their instances.\n+\n+TEMPLATE_RELATIONS     = YES\n+\n+# If set to YES, the inheritance and collaboration graphs will hide \n+# inheritance and usage relations if the target is undocumented \n+# or is not a class.\n+\n+HIDE_UNDOC_RELATIONS   = YES\n+\n+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDE_GRAPH, and HAVE_DOT \n+# tags are set to YES then doxygen will generate a graph for each documented \n+# file showing the direct and indirect include dependencies of the file with \n+# other documented files.\n+\n+INCLUDE_GRAPH          = YES\n+\n+# If the ENABLE_PREPROCESSING, SEARCH_INCLUDES, INCLUDED_BY_GRAPH, and \n+# HAVE_DOT tags are set to YES then doxygen will generate a graph for each \n+# documented header file showing the documented files that directly or \n+# indirectly include this file.\n+\n+INCLUDED_BY_GRAPH      = YES\n+\n+# If the GRAPHICAL_HIERARCHY and HAVE_DOT tags are set to YES then doxygen \n+# will graphical hierarchy of all classes instead of a textual one.\n+\n+GRAPHICAL_HIERARCHY    = YES\n+\n+# The DOT_IMAGE_FORMAT tag can be used to set the image format of the images \n+# generated by dot. Possible values are gif, jpg, and png\n+# If left blank gif will be used.\n+\n+DOT_IMAGE_FORMAT       = png\n+\n+# The tag DOT_PATH can be used to specify the path where the dot tool can be \n+# found. If left blank, it is assumed the dot tool can be found on the path.\n+\n+DOT_PATH               = \n+\n+# The DOTFILE_DIRS tag can be used to specify one or more directories that \n+# contain dot files that are included in the documentation (see the \n+# \\dotfile command).\n+\n+DOTFILE_DIRS           = \n+\n+# The MAX_DOT_GRAPH_WIDTH tag can be used to set the maximum allowed width \n+# (in pixels) of the graphs generated by dot. If a graph becomes larger than \n+# this value, doxygen will try to truncate the graph, so that it fits within \n+# the specified constraint. Beware that most browsers cannot cope with very \n+# large images.\n+\n+MAX_DOT_GRAPH_WIDTH    = 1024\n+\n+# The MAX_DOT_GRAPH_HEIGHT tag can be used to set the maximum allows height \n+# (in pixels) of the graphs generated by dot. If a graph becomes larger than \n+# this value, doxygen will try to truncate the graph, so that it fits within \n+# the specified constraint. Beware that most browsers cannot cope with very \n+# large images.\n+\n+MAX_DOT_GRAPH_HEIGHT   = 1024\n+\n+# If the GENERATE_LEGEND tag is set to YES (the default) Doxygen will \n+# generate a legend page explaining the meaning of the various boxes and \n+# arrows in the dot generated graphs.\n+\n+GENERATE_LEGEND        = YES\n+\n+# If the DOT_CLEANUP tag is set to YES (the default) Doxygen will \n+# remove the intermedate dot files that are used to generate \n+# the various graphs.\n+\n+DOT_CLEANUP            = YES\n+\n+#---------------------------------------------------------------------------\n+# Configuration::addtions related to the search engine   \n+#---------------------------------------------------------------------------\n+\n+# The SEARCHENGINE tag specifies whether or not a search engine should be \n+# used. If set to NO the values of all tags below this one will be ignored.\n+\n+SEARCHENGINE           = NO\n+\n+# The CGI_NAME tag should be the name of the CGI script that \n+# starts the search engine (doxysearch) with the correct parameters. \n+# A script with this name will be generated by doxygen.\n+\n+CGI_NAME               = search.cgi\n+\n+# The CGI_URL tag should be the absolute URL to the directory where the \n+# cgi binaries are located. See the documentation of your http daemon for \n+# details.\n+\n+CGI_URL                = \n+\n+# The DOC_URL tag should be the absolute URL to the directory where the \n+# documentation is located. If left blank the absolute path to the \n+# documentation, with file:// prepended to it, will be used.\n+\n+DOC_URL                = \n+\n+# The DOC_ABSPATH tag should be the absolute path to the directory where the \n+# documentation is located. If left blank the directory on the local machine \n+# will be used.\n+\n+DOC_ABSPATH            = \n+\n+# The BIN_ABSPATH tag must point to the directory where the doxysearch binary \n+# is installed.\n+\n+BIN_ABSPATH            = /usr/local/bin/\n+\n+# The EXT_DOC_PATHS tag can be used to specify one or more paths to \n+# documentation generated for other projects. This allows doxysearch to search \n+# the documentation for these projects as well.\n+\n+EXT_DOC_PATHS          = "}, {"sha": "aea3d00785da3fd58e2a508e2153d43d02b215ab", "filename": "depcomp", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/depcomp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/depcomp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/depcomp?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,472 @@\n+#! /bin/sh\n+\n+# depcomp - compile a program generating dependencies as side-effects\n+# Copyright 1999, 2000 Free Software Foundation, Inc.\n+\n+# This program is free software; you can redistribute it and/or modify\n+# it under the terms of the GNU General Public License as published by\n+# the Free Software Foundation; either version 2, or (at your option)\n+# any later version.\n+\n+# This program is distributed in the hope that it will be useful,\n+# but WITHOUT ANY WARRANTY; without even the implied warranty of\n+# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+# GNU General Public License for more details.\n+\n+# You should have received a copy of the GNU General Public License\n+# along with this program; if not, write to the Free Software\n+# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA\n+# 02111-1307, USA.\n+\n+# As a special exception to the GNU General Public License, if you\n+# distribute this file as part of a program that contains a\n+# configuration script generated by Autoconf, you may include it under\n+# the same distribution terms that you use for the rest of that program.\n+\n+# Originally written by Alexandre Oliva <oliva@dcc.unicamp.br>.\n+\n+if test -z \"$depmode\" || test -z \"$source\" || test -z \"$object\"; then\n+  echo \"depcomp: Variables source, object and depmode must be set\" 1>&2\n+  exit 1\n+fi\n+# `libtool' can also be set to `yes' or `no'.\n+\n+if test -z \"$depfile\"; then\n+   base=`echo \"$object\" | sed -e 's,^.*/,,' -e 's,\\.\\([^.]*\\)$,.P\\1,'`\n+   dir=`echo \"$object\" | sed 's,/.*$,/,'`\n+   if test \"$dir\" = \"$object\"; then\n+      dir=\n+   fi\n+   # FIXME: should be _deps on DOS.\n+   depfile=\"$dir.deps/$base\"\n+fi\n+\n+tmpdepfile=${tmpdepfile-`echo \"$depfile\" | sed 's/\\.\\([^.]*\\)$/.T\\1/'`}\n+\n+rm -f \"$tmpdepfile\"\n+\n+# Some modes work just like other modes, but use different flags.  We\n+# parameterize here, but still list the modes in the big case below,\n+# to make depend.m4 easier to write.  Note that we *cannot* use a case\n+# here, because this file can only contain one case statement.\n+if test \"$depmode\" = hp; then\n+  # HP compiler uses -M and no extra arg.\n+  gccflag=-M\n+  depmode=gcc\n+fi\n+\n+if test \"$depmode\" = dashXmstdout; then\n+   # This is just like dashmstdout with a different argument.\n+   dashmflag=-xM\n+   depmode=dashmstdout\n+fi\n+\n+case \"$depmode\" in\n+gcc3)\n+## gcc 3 implements dependency tracking that does exactly what\n+## we want.  Yay!  Note: for some reason libtool 1.4 doesn't like\n+## it if -MD -MP comes after the -MF stuff.  Hmm.\n+  \"$@\" -MT \"$object\" -MD -MP -MF \"$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  mv \"$tmpdepfile\" \"$depfile\"\n+  ;;\n+\n+gcc)\n+## There are various ways to get dependency output from gcc.  Here's\n+## why we pick this rather obscure method:\n+## - Don't want to use -MD because we'd like the dependencies to end\n+##   up in a subdir.  Having to rename by hand is ugly.\n+##   (We might end up doing this anyway to support other compilers.)\n+## - The DEPENDENCIES_OUTPUT environment variable makes gcc act like\n+##   -MM, not -M (despite what the docs say).\n+## - Using -M directly means running the compiler twice (even worse\n+##   than renaming).\n+  if test -z \"$gccflag\"; then\n+    gccflag=-MD,\n+  fi\n+  \"$@\" -Wp,\"$gccflag$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  alpha=ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n+## The second -e expression handles DOS-style file names with drive letters.\n+  sed -e 's/^[^:]*: / /' \\\n+      -e 's/^['$alpha']:\\/[^:]*: / /' < \"$tmpdepfile\" >> \"$depfile\"\n+## This next piece of magic avoids the `deleted header file' problem.\n+## The problem is that when a header file which appears in a .P file\n+## is deleted, the dependency causes make to die (because there is\n+## typically no way to rebuild the header).  We avoid this by adding\n+## dummy dependencies for each header file.  Too bad gcc doesn't do\n+## this for us directly.\n+  tr ' ' '\n+' < \"$tmpdepfile\" |\n+## Some versions of gcc put a space before the `:'.  On the theory\n+## that the space means something, we add a space to the output as\n+## well.\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+hp)\n+  # This case exists only to let depend.m4 do its work.  It works by\n+  # looking at the text of this script.  This case will never be run,\n+  # since it is checked for above.\n+  exit 1\n+  ;;\n+\n+sgi)\n+  if test \"$libtool\" = yes; then\n+    \"$@\" \"-Wp,-MDupdate,$tmpdepfile\"\n+  else\n+    \"$@\" -MDupdate \"$tmpdepfile\"\n+  fi\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+\n+  if test -f \"$tmpdepfile\"; then  # yes, the sourcefile depend on other files\n+    echo \"$object : \\\\\" > \"$depfile\"\n+\n+    # Clip off the initial element (the dependent).  Don't try to be\n+    # clever and replace this with sed code, as IRIX sed won't handle\n+    # lines with more than a fixed number of characters (4096 in\n+    # IRIX 6.2 sed, 8192 in IRIX 6.5).  We also remove comment lines;\n+    # the IRIX cc adds comments like `#:fec' to the end of the\n+    # dependency line.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+    | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' | \\\n+    tr '\n+' ' ' >> $depfile\n+    echo >> $depfile\n+\n+    # The second pass generates a dummy entry for each header file.\n+    tr ' ' '\n+' < \"$tmpdepfile\" \\\n+   | sed -e 's/^.*\\.o://' -e 's/#.*$//' -e '/^$/ d' -e 's/$/:/' \\\n+   >> $depfile\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+aix)\n+  # The C for AIX Compiler uses -M and outputs the dependencies\n+  # in a .u file.  This file always lives in the current directory.\n+  # Also, the AIX compiler puts `$object:' at the start of each line;\n+  # $object doesn't have directory information.\n+  stripped=`echo \"$object\" | sed -e 's,^.*/,,' -e 's/\\(.*\\)\\..*$/\\1/'`\n+  tmpdepfile=\"$stripped.u\"\n+  outname=\"$stripped.o\"\n+  if test \"$libtool\" = yes; then\n+    \"$@\" -Wc,-M\n+  else\n+    \"$@\" -M\n+  fi\n+\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+\n+  if test -f \"$tmpdepfile\"; then\n+    # Each line is of the form `foo.o: dependent.h'.\n+    # Do two passes, one to just change these to\n+    # `$object: dependent.h' and one to simply `dependent.h:'.\n+    sed -e \"s,^$outname:,$object :,\" < \"$tmpdepfile\" > \"$depfile\"\n+    sed -e \"s,^$outname: \\(.*\\)$,\\1:,\" < \"$tmpdepfile\" >> \"$depfile\"\n+  else\n+    # The sourcefile does not contain any dependencies, so just\n+    # store a dummy comment line, to avoid errors with the Makefile\n+    # \"include basename.Plo\" scheme.\n+    echo \"#dummy\" > \"$depfile\"\n+  fi\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+icc)\n+  # Intel's C compiler understands `-MD -MF file'.  However on\n+  #    icc -MD -MF foo.d -c -o sub/foo.o sub/foo.c\n+  # ICC 7.0 will fill foo.d with something like\n+  #    foo.o: sub/foo.c\n+  #    foo.o: sub/foo.h\n+  # which is wrong.  We want:\n+  #    sub/foo.o: sub/foo.c\n+  #    sub/foo.o: sub/foo.h\n+  #    sub/foo.c:\n+  #    sub/foo.h:\n+  # ICC 7.1 will output\n+  #    foo.o: sub/foo.c sub/foo.h\n+  # and will wrap long lines using \\ :\n+  #    foo.o: sub/foo.c ... \\\n+  #     sub/foo.h ... \\\n+  #     ...\n+\n+  \"$@\" -MD -MF \"$tmpdepfile\"\n+  stat=$?\n+  if test $stat -eq 0; then :\n+  else\n+    rm -f \"$tmpdepfile\"\n+    exit $stat\n+  fi\n+  rm -f \"$depfile\"\n+  # Each line is of the form `foo.o: dependent.h',\n+  # or `foo.o: dep1.h dep2.h \\', or ` dep3.h dep4.h \\'.\n+  # Do two passes, one to just change these to\n+  # `$object: dependent.h' and one to simply `dependent.h:'.\n+  sed \"s,^[^:]*:,$object :,\" < \"$tmpdepfile\" > \"$depfile\"\n+  # Some versions of the HPUX 10.20 sed can't process this invocation\n+  # correctly.  Breaking it into two sed invocations is a workaround.\n+  sed 's,^[^:]*: \\(.*\\)$,\\1,;s/^\\\\$//;/^$/d;/:$/d' < \"$tmpdepfile\" |\n+    sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+tru64)\n+   # The Tru64 compiler uses -MD to generate dependencies as a side\n+   # effect.  `cc -MD -o foo.o ...' puts the dependencies into `foo.o.d'.\n+   # At least on Alpha/Redhat 6.1, Compaq CCC V6.2-504 seems to put\n+   # dependencies in `foo.d' instead, so we check for that too.\n+   # Subdirectories are respected.\n+   dir=`echo \"$object\" | sed -e 's|/[^/]*$|/|'`\n+   test \"x$dir\" = \"x$object\" && dir=\n+   base=`echo \"$object\" | sed -e 's|^.*/||' -e 's/\\.o$//' -e 's/\\.lo$//'`\n+\n+   if test \"$libtool\" = yes; then\n+      tmpdepfile1=\"$dir.libs/$base.lo.d\"\n+      tmpdepfile2=\"$dir.libs/$base.d\"\n+      \"$@\" -Wc,-MD\n+   else\n+      tmpdepfile1=\"$dir$base.o.d\"\n+      tmpdepfile2=\"$dir$base.d\"\n+      \"$@\" -MD\n+   fi\n+\n+   stat=$?\n+   if test $stat -eq 0; then :\n+   else\n+      rm -f \"$tmpdepfile1\" \"$tmpdepfile2\"\n+      exit $stat\n+   fi\n+\n+   if test -f \"$tmpdepfile1\"; then\n+      tmpdepfile=\"$tmpdepfile1\"\n+   else\n+      tmpdepfile=\"$tmpdepfile2\"\n+   fi\n+   if test -f \"$tmpdepfile\"; then\n+      sed -e \"s,^.*\\.[a-z]*:,$object:,\" < \"$tmpdepfile\" > \"$depfile\"\n+      # That's a space and a tab in the [].\n+      sed -e 's,^.*\\.[a-z]*:[ \t]*,,' -e 's,$,:,' < \"$tmpdepfile\" >> \"$depfile\"\n+   else\n+      echo \"#dummy\" > \"$depfile\"\n+   fi\n+   rm -f \"$tmpdepfile\"\n+   ;;\n+\n+#nosideeffect)\n+  # This comment above is used by automake to tell side-effect\n+  # dependency tracking mechanisms from slower ones.\n+\n+dashmstdout)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the proprocessed file to stdout, regardless of -o.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test $1 != '--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  test -z \"$dashmflag\" && dashmflag=-M\n+  # Require at least two characters before searching for `:'\n+  # in the target name.  This is to cope with DOS-style filenames:\n+  # a dependency such as `c:/foo/bar' could be seen as target `c' otherwise.\n+  \"$@\" $dashmflag |\n+    sed 's:^[  ]*[^: ][^:][^:]*\\:[    ]*:'\"$object\"'\\: :' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  tr ' ' '\n+' < \"$tmpdepfile\" | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+dashXmstdout)\n+  # This case only exists to satisfy depend.m4.  It is never actually\n+  # run, as this mode is specially recognized in the preamble.\n+  exit 1\n+  ;;\n+\n+makedepend)\n+  \"$@\" || exit $?\n+  # Remove any Libtool call\n+  if test \"$libtool\" = yes; then\n+    while test $1 != '--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+  # X makedepend\n+  shift\n+  cleared=no\n+  for arg in \"$@\"; do\n+    case $cleared in\n+    no)\n+      set \"\"; shift\n+      cleared=yes ;;\n+    esac\n+    case \"$arg\" in\n+    -D*|-I*)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    # Strip any option that makedepend may not understand.  Remove\n+    # the object too, otherwise makedepend will parse it as a source file.\n+    -*|$object)\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"; shift ;;\n+    esac\n+  done\n+  obj_suffix=\"`echo $object | sed 's/^.*\\././'`\"\n+  touch \"$tmpdepfile\"\n+  ${MAKEDEPEND-makedepend} -o\"$obj_suffix\" -f\"$tmpdepfile\" \"$@\"\n+  rm -f \"$depfile\"\n+  cat < \"$tmpdepfile\" > \"$depfile\"\n+  sed '1,2d' \"$tmpdepfile\" | tr ' ' '\n+' | \\\n+## Some versions of the HPUX 10.20 sed can't process this invocation\n+## correctly.  Breaking it into two sed invocations is a workaround.\n+    sed -e 's/^\\\\$//' -e '/^$/d' -e '/:$/d' | sed -e 's/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\" \"$tmpdepfile\".bak\n+  ;;\n+\n+cpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the proprocessed file to stdout.\n+  \"$@\" || exit $?\n+\n+  # Remove the call to Libtool.\n+  if test \"$libtool\" = yes; then\n+    while test $1 != '--mode=compile'; do\n+      shift\n+    done\n+    shift\n+  fi\n+\n+  # Remove `-o $object'.\n+  IFS=\" \"\n+  for arg\n+  do\n+    case $arg in\n+    -o)\n+      shift\n+      ;;\n+    $object)\n+      shift\n+      ;;\n+    *)\n+      set fnord \"$@\" \"$arg\"\n+      shift # fnord\n+      shift # $arg\n+      ;;\n+    esac\n+  done\n+\n+  \"$@\" -E |\n+    sed -n '/^# [0-9][0-9]* \"\\([^\"]*\\)\".*/ s:: \\1 \\\\:p' |\n+    sed '$ s: \\\\$::' > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  cat < \"$tmpdepfile\" >> \"$depfile\"\n+  sed < \"$tmpdepfile\" '/^$/d;s/^ //;s/ \\\\$//;s/$/ :/' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+msvisualcpp)\n+  # Important note: in order to support this mode, a compiler *must*\n+  # always write the proprocessed file to stdout, regardless of -o,\n+  # because we must use -o when running libtool.\n+  \"$@\" || exit $?\n+  IFS=\" \"\n+  for arg\n+  do\n+    case \"$arg\" in\n+    \"-Gm\"|\"/Gm\"|\"-Gi\"|\"/Gi\"|\"-ZI\"|\"/ZI\")\n+\tset fnord \"$@\"\n+\tshift\n+\tshift\n+\t;;\n+    *)\n+\tset fnord \"$@\" \"$arg\"\n+\tshift\n+\tshift\n+\t;;\n+    esac\n+  done\n+  \"$@\" -E |\n+  sed -n '/^#line [0-9][0-9]* \"\\([^\"]*\\)\"/ s::echo \"`cygpath -u \\\\\"\\1\\\\\"`\":p' | sort | uniq > \"$tmpdepfile\"\n+  rm -f \"$depfile\"\n+  echo \"$object : \\\\\" > \"$depfile\"\n+  . \"$tmpdepfile\" | sed 's% %\\\\ %g' | sed -n '/^\\(.*\\)$/ s::\t\\1 \\\\:p' >> \"$depfile\"\n+  echo \"\t\" >> \"$depfile\"\n+  . \"$tmpdepfile\" | sed 's% %\\\\ %g' | sed -n '/^\\(.*\\)$/ s::\\1\\::p' >> \"$depfile\"\n+  rm -f \"$tmpdepfile\"\n+  ;;\n+\n+none)\n+  exec \"$@\"\n+  ;;\n+\n+*)\n+  echo \"Unknown depmode $depmode\" 1>&2\n+  exit 1\n+  ;;\n+esac\n+\n+exit 0"}, {"sha": "46d8d2e8f680702e9b81b6f037c0e69fbcd7a274", "filename": "gcc/ChangeLog", "status": "modified", "additions": 1123, "deletions": 0, "changes": 1123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1,3 +1,1126 @@\n+2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-ssa-20020619-branch.\n+\n+\t* Makefile.in (reload1.o-warn): Add.\n+\t(tree-alias-ander.o-warn): Add.\n+\t(GMPLIBS): Define.\n+\t(GMPINC): Define.\n+\t(BANSHEELIB): Define.\n+\t(BANSHEEINC): Define.\n+\t(TREE_DUMP_H): Define.\n+\t(TREE_SIMPLE_H): Define.\n+\t(TREE_FLOW_H): Define.\n+\t(LIBDEPS): Add BANSHEELIB.\n+\t(INCLUDES): Add BANSHEEINC and GMPINC.\n+\t(C_AND_OBJC_OBJS): Add c-simplify.o, tree-mudflap.o,\n+\tc-mudflap.o and c-pretty-print.o.\n+\t(C_OBJS): Remove c-pretty-print.o.\n+\t(OBJS-common): Remove sibcall.o.\n+\tAdd tree-cfg.o, tree-dfa.o, tree-eh.o,\n+\ttree-ssa.o, tree-optimize.o, tree-simple.o,\n+\ttree-alias-type.o, gimplify.o, tree-pretty-print.o,\n+\ttree-into-ssa.o, tree-outof-ssa.o, tree-alias-common.o,\n+\ttree-ssa-ccp.o, @ANDER@, tree-ssa-dce.o, tree-ssa-copy.o,\n+\ttree-nrv.o, tree-ssa-copyrename.o, tree-ssa-pre.o,\n+\ttree-ssa-live.o, tree-ssa-operands.o, tree-ssa-alias.o,\n+\ttree-ssa-phiopt.o, tree-ssa-forwprop.o, tree-nested.o,\n+\ttree-ssa-dse.o, tree-ssa-dom.o, domwalk.o,\n+\ttree-tailcall.o, gimple-low.o, tree-iterator.o,\n+\ttree-phinodes.o, tree-ssanames.o, tree-sra.o,\n+\ttree-complex.o, tree-ssa-loop.o, rtl-profile.o and\n+\ttree-profile.o.\n+\t(OBJC-archive): Add tree-nomudflap.o.\n+\t(cc1): Add dependency on @TREEBROWSER@.\n+\t(c-decl.o): Add dependency on TREE_DUMP_H.\n+\t(c-dump.o): Likewise.\n+\t(c-common.o): Add dependency on tree-iterator.h\n+\t(c-pretty-print.o): Add dependency on DIAGNOSTIC_H.\n+\t(gtype-desc.o): Add dependency on TREE_FLOW_H.\n+\t(tree.o): Add dependency on tree-iterator.h,\n+\tBASIC_BLOCK_H and TREE_FLOW_H.\n+\t(tree-dump.o): Depend on TREE_DUMP_H instead of tree-dump.h.\n+\t(langhooks.o): Add dependency on TREE_SIMPLE_H.\n+\t(tree-alias-type.o, tree-alias-ander.o,\n+\ttree-alias-common.o, tree-ssa.o, tree-into-ssa.o,\n+\ttree-outof-ssa.o, tree-ssa-dse.o, tree-ssa-forwprop.o,\n+\ttree-ssa-phiopt.o, tree-nrv.o, tree-ssa-copy.o,\n+\ttree-ssa-dom.o, tree-ssanames.o, tree-phinodes.o,\n+\tdomwalk.o, tree-ssa-live.o, tree-ssa-copyrename.o,\n+\ttree-ssa-pre.o, tree-cfg.o, tree-tailcall.o,\n+\ttree-nested.o, tree-iterator.o, tree-dfa.o,\n+\ttree-ssa-operands.o, tree-eh.o, tree-ssa-loop.o,\n+\ttree-ssa-alias.o, tree-optimize.o, c-simplify.o,\n+\tgimplify.o, gimple-low.o, tree-browser.o, tree-simple.o,\n+\ttree-mudflap.o, c-mudflap.o, tree-nomudflap.o,\n+\ttree-pretty-print.o, tree-ssa-dce.o, tree-ssa-ccp.o,\n+\ttree-sra.o, tree-complex.o, tree-profile.o,\n+\trtl-profile.o): New rules.\n+\t(function.o): Add dependency on basic-block.h\n+\t(expr.o): Add dependency on tree-iterator.h.\n+\t(sibcall.o): Remove.\n+\t(profile.o): Depend on TREE_FLOW_H instead of TREE_H.\n+\t(cfg.o): Add dependency on TIMEVAR_H.\n+\t(cfghooks.o): Add dependency on TREE_FLOW_H.\n+\t(reg-stack.o): Add dependency on basic-block.h.\n+\t(GTFILES): Add hwint.h, tree-mudflaph.c, tree-flow.h,\n+\tc-objc-common.c, c-common.c, c-parse.in, tree-ssanames.c,\n+\ttree-eh.c, tree-phinodes.c, tree-cfg.c, tree-dfa.c,\n+\ttree-ssa-ccp.c, tree-iterator.c, gimplify.c,\n+\ttree-alias-type.h, tree-alias-common.h,\n+\ttree-alias-type.c, tree-alias-common.c,\n+\ttree-ssa-operands.h, tree-ssa-operands.c, tree-profile.c,\n+\trtl-profile.c and tree-nested.c.\n+\t(gt-tree-alias-common.h, gt-tree-mudflap.h,\n+\tgt-tree-ssa-ccp.h, gt-tree-eh.h, gt-tree-ssanames.h,\n+\tgt-tree-iterator.h, gt-gimplify.h, gt-tree-phinodes.h,\n+\tgt-tree-cfg.h, gt-tree-nested.h): New rules.\n+\t(TEXI_GCCINT_FILES): Add cfg.texi and tree-ssa.texi.\n+\t* basic-block.h: Include predict.h\n+\t(struct edge_def): Add GTY marker.\n+\tChange field 'insns' to be a union of tree and rtx.\n+\t(EDGE_TRUE_VALUE): Define.\n+\t(EDGE_FALSE_VALUE): Define.\n+\t(EDGE_EXECUTABLE): Define.\n+\t(struct bb_ann_d): Forward declare.\n+\t(struct basic_block_def): Add GTY marker.\n+\tRemove fields head_tree and end_tree.\n+\tAdd fields stmt_list, rbi and tree_annotations.\n+\t(struct reorder_block_def): Define.\n+\t(basic_block_info): Add GTY marker.\n+\t(ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR): Change to global\n+\tvariables instead of macros.\n+\t(flow_call_edges_add): Remove declaration.\n+\t(make_eh_edge): Remove declaration.\n+\t(brief_dump_cfg, find_edge, tree_predicted_by_p,\n+\trtl_predicted_by_p, tree_predict_edge, rtl_predict_edge,\n+\tpredict_edge_def, rtl_make_eh_edge, find_basic_blocks,\n+\tcleanup_cfg, delete_unreachable_blocks, merge_seq_blocks,\n+\talloc_rbi_pool, initialize_bb_rbi, free_rbi_pool): Declare.\n+\t(try_redirect_by_replacing_jump): Modfiy return type to\n+\tedge instead of bool.\n+\t* bb-reorder.c (copy_bb): Call duplicate_block\n+\tinstead of cfg_layout_duplicate_bb.\n+\t(copy_bb_p): Call can_duplicate_block_p instead of\n+\tcfg_layout_can_duplicate_bb_p.\n+\t* bitmap.c (bitmap_first_set_bit): Abort if word\n+\twasn't found.\n+\t(bitmap_last_set_bit): Likewise.\n+\t* builtin-types.def (DEF_FUNCTION_TYPE_2): Add\n+\t(DEF_FUNCTION_TYPE_3): Add.\n+\t* builtins.c (c_strlen): Make extern.\n+\t(builtin_save_expr): New.\n+\t(expand_builtin_nonlocal_goto): New.\n+\t(expand_builtin_constant_p): Remove.\n+\t(expand_builtin_mathfn): Call builtin_save_expr instead\n+\tof save_expr.\n+\t(expand_builtin_mathfn_2): Likewise.\n+\t(expand_builtin_strcmp): Likewise.\n+\t(expand_builtin_strncmp): Likewise.\n+\t(expand_builtin_strcat): Likewise.\n+\t(fold_builtin_cabs): Likewise.\n+\t(expand_builtin_alloca): Don't trigger if -fmudflap is\n+\tgiven.\n+\t(build_string_literal): Set TREE_INVARIANT on new node.\n+\t(expand_builtin_profile_fun): New.\n+\t(round_trampoline_addr): New.\n+\t(expand_builtin_init_trampoline): New.\n+\t(expand_builtin_adjust_trampoline): New.\n+\t(expand_builtin) <BUILT_IN_NEXT_ARG>: Call simplify_builtin_next_arg.\n+\t<BUILT_IN_CONSTANT_P>: Return const0_rtx;\n+\t<BUILT_IN_STACK_ALLOC, BUILT_IN_STACK_SAVE,\n+\tBUILT_IN_STACK_RESTORE, BUILT_IN_NONLOCAL_GOTO,\n+\tBUILT_IN_PROFILE_FUNC_ENTER, BUILT_IN_PROFILE_FUNC_EXIT,\n+\tBUILT_IN_INIT_TRAMPOLINE, BUILT_IN_ADJUST_TRAMPOLINE>:\n+\tHandle.\n+\t(fold_builtin_expect): New.\n+\t(fold_builtin_isascii): Don't return non-constant results\n+\tin GIMPLE form.\n+\t(fold_builtin_isdigit): Likewise.\n+\t(fold_builtin_1): New.\n+\t(fold_builtin): Call it.\n+\t(build_function_call_expr): Update call to build a new\n+\tCALL_EXPR.\n+\t(purge_builtin_constant_p): Remove.\n+\t(simplify_builtin, simplify_builtin_memcmp,\n+\tsimplify_builtin_strcmp, simplify_builtin_strncmp,\n+\tsimplify_builtin_strpbrk, simplify_builtin_strstr,\n+\tsimplify_builtin_strchr, simplify_builtin_strrchr,\n+\tsimplify_builtin_strcat, simplify_builtin_strncat,\n+\tsimplify_builtin_strspn, simplify_builtin_strcspn,\n+\tsimplify_builtin_next_arg, simplify_builtin_va_start,\n+\tsimplify_builtin_sprintf): New.\n+\t* builtins.def (BUILT_IN_STACK_ALLOC,\n+\tBUILT_IN_STACK_SAVE, BUILT_IN_STACK_RESTORE,\n+\tBUILT_IN_INIT_TRAMPOLINE, BUILT_IN_ADJUST_TRAMPOLINE,\n+\tBUILT_IN_NONLOCAL_GOTO, BUILT_IN_PROFILE_FUNC_ENTER,\n+\tBUILT_IN_PROFILE_FUNC_EXIT): Define.\n+\t* c-common.c: Include tree-iterator.h and hashtab.h.\n+\t(lang_statement_code_p): Declare.\n+\t(lang_gimplify_stmt): Declare.\n+\t(fix_string_type): Set TREE_INVARIANT for value.\n+\t(pointer_int_sum): Rely on build to set TREE_CONSTANT.\n+\t(c_type_hash): New.\n+\t(c_common_get_alias_set): Handle multiple type nodes\n+\treferring to \"the same\" type, currently for C90 only.\n+\t(c_add_case_label): Use create_artificial_label.\n+\t(finish_label_address_expr): Don't set TREE_CONSTANT on\n+\tresult.\n+\t(c_expand_expr): Don't handle STMT_EXPR.\n+\t(handle_alias_attribute): Marke aliased variables to be\n+\tTREE_STATIC.\n+\t(handle_nonnull_attribute): Initialize arg_num.\n+\t(check_function_nonnull): Likewise.\n+\t(c_walk_subtrees): New.\n+\t(c_estimate_num_insns_1): Don't handle\n+\tEXPR_WITH_FILE_LOCATION nor FILE_STMT.\n+\t(c_decl_uninit_1): Remove.\n+\t(c_decl_uninit): Remove.\n+\t(c_warn_unused_result): New.\n+\t* c-common.def (ASM_STMT): Change number of operands\n+\tto 4.\n+\t(FILE_STMT): Remove.\n+\t* c-common.h (lang_expand_stmt, lang_expand_decl_stmt):\n+\tRemove.\n+\t(lang_gimplify_stmt): Add.\n+\t(expand_stmt): Remove.\n+\t(ASM_CV_QUAL, ASM_STRING, ASM_OUTPUTS, ASM_INPUTS,\n+\tASM_CLOBBERS, STMT_EXPR_WARN_UNUSED_RESULT,\n+\tASM_VOLATILE_P, FILE_STMT_FILENAME_NODE,\n+\tFILE_STMT_FILENAME, STMT_LINENO, STMT_LINENO_FOR_FN_P,\n+\tASM_INPUT_P, DECL_C_HARD_REGISTER): Remove.\n+\t(genrtl_do_pushlevel, genrtl_goto_stmt, genrtl_expr_stmt,\n+\tgenrtl_expr_stmt_value, genrtl_decl_stmt, genrtl_if_stmt,\n+\tgenrtl_while_stmt, genrtl_do_stmt, genrtl_return_stmt,\n+\tgenrtl_for_stmt, genrtl_break_stmt, genrtl_continue_stmt,\n+\tgenrtl_scope_stmt, genrtl_switch_stmt, genrtl_case_label,\n+\tgenrtl_compound_stmt, genrtl_asm_stmt,\n+\tgenrtl_cleanup_stmt, c_decl_uninit): Remove.\n+\t(c_do_switch_warnings, c_gimplify_expr, c_walk_subtrees,\n+\tc_tree_chain_matters_p, c_warn_unused_result,\n+\tc_genericize, c_gimplify_stmt, stmt_expr_last_stmt):\n+\tDeclare.\n+\t* c-convert.c (convert): Make convert work when\n+\tconverting to compatible types across translation unit.\n+\t* c-decl.c: Include langhooks.h, tree-mudflap.h,\n+\ttree-simple.h, diagnostic.h and tree-dump.h\n+\t(merge_decls): Initialize oldtype to NULL.\n+\t(finish_decl): Use DECL_HARD_REGISTER instead of\n+\tDECL_C_HARD_REGISTER.\n+\t(check_bitfield_type_and_width): Check for null\n+\tlang_type_specific when check the precision of an enum.\n+\t(grokdeclarator): Immediately layout an ARRAY_TYPE used\n+\tin a pointer-to-array declarator.\n+\t(finish_struct): Clear allocated struct lang_type.\n+\t(finish_enum): Set enum_min and enum_max.  Set\n+\tTYPE_MIN/MAX_VALUE to the limits of the compatible type,\n+\tnot to the enumerators.\n+\t(set_decl_nonlocal): New.\n+\t(store_parm_decls): Use it via walk_tree.\n+\t(c_finalize): New.\n+\t(finish_function): When !targetm.have_ctors_dtors,\n+\trecord static constructors and destructors here...\n+\t(c_expand_body_1): ... not here.\n+\t(c_expand_decl): Rename from c_expand_decl_stmt.\n+\tHandle all C-specific expansion semantics.\n+\t* c-dump.c (dump_stmt): Use EXPR_LOCUS instead of\n+\tSTMT_LINENO.\n+\t* c-format.c (handle_format_arg_attribute): Initialize\n+\tformat_num.\n+\t* c-lang.c: Include tree-inline.h\n+\t(LANG_HOOKS_EXPAND_DECL,\n+\tLANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P,\n+\tLANG_HOOKS_TREE_INLINING_WALK_SUBTREES,\n+\tLANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P,\n+\tLANG_HOOKS_GIMPLIFY_EXPR, LANG_HOOKS_TYPES_COMPATIBLE_P): Define.\n+\t(LANG_HOOKS_DECL_UNINIT, LANG_HOOKS_RTL_EXPAND_STMT,\n+\tLANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS): Remove.\n+\t(c_types_compatible_p): New.\n+\t* c-mudflap.c: New file.\n+\t* c-objc-common.c: Include tree-mudflap.h\n+\t(start_cdtor, finish_cdtor): Collapse\n+\ttogether into\n+\t(build_cdtor): ...here.  Update to construct a complete tree\n+\tfor the function.  No need to call push_scope, pop_scope, or\n+\tclear_last_expr, or set current_function_cannot_inline.\n+\t(c_missing_noreturn_ok_p): Change prototype to return\n+\tbool.\n+\t(c_objc_common_init): Don't set lang_missing_noreturn_ok_p.\n+\t* c-opts.c (c_common_handle_option): Move handling of -fdump- to\n+\topts.c.\n+\t(c_common_post_options): Don't ever use rtl inlining.\n+\t* c-parse.in: Use EXPR_LOCUS instead of STMT_LINENO.\n+\t* c-pragma.c (handle_pragma_redefine_extname): Define\n+\talways.\n+\t(init_pragma): Activate #pragma redefine_extname for mudflap.\n+\t* c-pretty-print.c (pp_c_statement): Remove FILE_STMT.\n+\t(pp_c_initializer): Accept any type CONSTRUCTOR.\n+\t(pp_c_initializer_list): Fix code expectations for VECTOR_TYPE and\n+\tCOMPLEX_TYPE.\n+\t(decl_name_str): New local function.\n+\t(pp_c_direct_declarator): Call it.\n+\t(pp_c_primary_expression): Call it.\n+\t(pp_c_id_expression): Call it.\n+\t(pp_c_statement): Call it.\n+\t(print_c_tree): Create new pp object.\n+\t* c-pretty-print.h (pp_c_tree_decl_identifier,\n+\tprint_c_tree): Declare.\n+\t* c-semantics.c: Include langhooks.h\n+\t(lang_expand_stmt, lang_expand_decl_stmt,\n+\tfind_reachable_label_1, find_reachable_label,\n+\texpand_unreachable_if_stmt, expand_unreachable_stmt,\n+\tgenrtl_do_stmt_1): Remove.\n+\t(begin_stmt_tree): Don't check for changed filename.\n+\tCall annotate_with_locus.\n+\t(finish_stmt_tree): Don't set line for end of function.\n+\t(build_stmt): Don't check type nodes for\n+\tside effects.\n+\t(build_stmt): Set TREE_SIDE_EFFECTS.\n+\tSet EXPR_LOCUS instead of STMT_LINENO.\n+\t(lang_expand_stmt, lang_expand_decl_stmt,\n+\texpand_cond, genrtl_do_pushlevel, genrtl_goto_stmt, genrtl_expr_stmt,\n+\tgenrtl_expr_stmt_value, genrtl_decl_stmt, genrtl_if_stmt,\n+\tgenrtl_while_stmt, genrtl_do_stmt_1, genrtl_do_stmt,\n+\tgenrtl_return_stmt, genrtl_for_stmt, genrtl_break_stmt,\n+\tgenrtl_continue_stmt, genrtl_scope_stmt, genrtl_switch_stmt,\n+\tgenrtl_case_label, genrtl_compound_stmt, genrtl_asm_stmt,\n+\tgenrtl_cleanup_stmt, expand_stmt, find_reachable_label,\n+\tfind_reachable_label_1, expand_unreachable_if_stmt,\n+\texpand_unreachable_stmt): Remove.\n+\t(prep_stmt): Use EXPR_LOCUS instead of STMT_LINENO.\n+\t* c-simplify.c: New file.\n+\t* c-tree.h (C_LANG_TREE_NODE_CHAIN_NEXT): Define.\n+\t(struct lang_type): Add fields enum_min and enum_max.\n+\t(c_expand_decl_stmt, c_missing_noreturn_ok_p): Remove.\n+\t(c_expand_decl, c_missing_noreturn_ok_p,\n+\tc_types_compatible_p): Declare.\n+\t* c-typeck.c (tagged_types_tu_compatible_p): Allow for\n+\tcompiler-generated TYPE_DECLs without a DECL_ORIGINAL_TYPE.\n+\t(default_function_array_conversion): Rely on build to\n+\tset TREE_CONSTANT.\n+\t(parser_build_binary_op, pointer_diff): Likewise.\n+\t(build_unary_op, build_binary_op): Likewise.\n+\t(build_array_ref):\n+\t(build_external_ref): Set TREE_INVARIANT.\n+\t(build_c_cast, pop_init_level): Likewise.\n+\t(process_init_element): Use ASM_VOLATILE_P.\n+\t(build_asm_expr): Adapt to GENERIC/GIMPLE syntax.\n+\t(c_finish_case): Call c_do_switch_warnings.\n+\t* c.opt (fdump-): Remove.\n+\t* calls.c (try_to_integrate): Remove.\n+\t(prepare_call_address): Replace fndecl arg with a\n+\tprecomputed static chain value.\n+\t(emit_call_1): New argument for full call expr.\n+\t(flags_from_decl_or_type): Call special_function_p.\n+\t(initialize_argument_information): Add argument\n+\tmay_tailcall.\n+\t(purge_reg_equiv_notes): New.\n+\t(expand_call): Do not try to expand calls inline.\n+\t(fixup_tail_calls): New.\n+\t* cfg.c: Include timevar.h and ggc.h.\n+\t(bb_pool, edge_pool): Remove.\n+\t(ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR): Declare.\n+\t(entry_exit_blocks): Remove.\n+\t(rbi_pool): Declare.\n+\t(init_flow): Do not create pools.\n+\tAllocate entry/exit block.\n+\t(free_edge, alloc_block, expunge_block, unchecked_make_edge): Use GGC.\n+\t(alloc_rbi_pool, free_rbi_pool, initialize_bb_rbi): New.\n+\t(unlink_block): Clear b->prev_bb and b->next_bb.\n+\t(compact_blocks): Clear all slots of BASIC_BLOCK array.\n+\t(dump_flow_info): Work on trees too.\n+\t(dump_cfg_bb_info): New.\n+\t(brief_dump_cfg): New.\n+\t* cfganal.c (need_fake_edge_p, flow_call_edges_add): Remove.\n+\t(find_edge): New.\n+\t* cfgbuild.c (rtl_make_eh_edge): Rename from\n+\tmake_eh_edge.  Update all users.\n+\t(find_basic_blocks): Don't call VARRAY_FREE on\n+\tbasic_block_info.\n+\t* cfgcleanup.c (outgoing_edges_match): Initialize newpos1\n+\tand newpos2.\n+\t(delete_unreachable_blocks): Return changed status.\n+\t(merge_seq_blocks): New.\n+\t* cfghooks.c: Include tree-flow.h\n+\t(tree_register_cfg_hooks, ir_type): New.\n+\t(redirect_edge_and_branch): Change return type to edge.\n+\t(predict_edge, predicted_by_p, can_duplicate_block_p,\n+\tduplicate_block, block_ends_with_call_p,\n+\tblock_ends_with_condjump_p, flow_call_edges_add): New.\n+\t* cfghooks.h (redirect_edge_and_branch): Change return\n+\ttype to edge.\n+\t(predict_edge, predicted_by_p, can_duplicate_block_p,\n+\tduplicate_block, block_ends_with_call_p,\n+\tblock_ends_with_condjump_p, flow_call_edges_add): Declare.\n+\t(redirect_edge_and_branch): Change return type to edge.\n+\t(struct cfg_hooks): Add fields block_ends_with_call_p,\n+\tblock_ends_with_condjump_p, flow_call_edges_add,\n+\tpredict_edge, predicted_by_p, can_duplicate_block_p and\n+\tduplicate_block.\n+\t(tree_cfg_hooks, ir_type, tree_register_cfg_hooks): Declare.\n+\t* cfglayout.c (cfg_layout_pool, cfg_layout_initialize_rbi): Removed.\n+\t(fixup_reorder_chain): Use initialize_bb_rbi.\n+\t(cfg_layout_can_duplicate_bb_p, cfg_layout_duplicate_bb): Hookized.\n+\t(cfg_layout_initialize): Use cfg.c rbi pool manipulation functions.\n+\t(can_copy_bbs_p, copy_bbs): Use cfghooks for bb duplication.\n+\t(insn_locators_initialize): Use new info about blocks.\n+\t* cfglayout.h (typedef struct reorder_block_def): Moved to\n+\tbasic_block.h.\n+\t(cfg_layout_can_duplicate_bb_p, cfg_layout_duplicate_bb): Declaration\n+\tremoved.\n+\t* cfgloop.c: Include tree.h and tree-flow.h.\n+\t* cfgloop.h (create_loop_notes): Declare.\n+\t* cfgloopmanip.c (create_loop_notes): New.\n+\t* cfgrtl.c (cfg_layout_create_basic_block): Use initialize_bb_rbi.\n+\t(rtl_cfg_hooks, cfg_layout_rtl_cfg_hook): Fill in can_duplicate_block_p\n+\tand duplicate_block fields.\n+\t(create_basic_block_structure): Don't look at\n+\tRTX_INTEGRATED_P.\n+\t(rtl_block_ends_with_call_p): New.\n+\t(rtl_block_ends_with_condjump_p): New.\n+\t(need_fake_edge_p): Moved from cfganal.c.\n+\t(rtl_flow_call_edges_add): Moved from cfganal.c (flow_call_edges_add).\n+\t(rtl_cfg_hooks): Add rtl_block_ends_with_call_p,\n+\trtl_block_ends_with_condjump_p, rtl_flow_call_edges_add.\n+\t(cfg_layout_rtl_cfg_hooks): Ditto.\n+\t* cgraph.c (cgraph_mark_reachable_node): Don't force nested\n+\tfunctions to be reachable.\n+\t* cgraphunit.c (decide_is_function_needed):\n+\t* cgraphunit.c (decide_is_function_needed): Nested functions of extern\n+\tinline functions don't need to be output.\n+\t(cgraph_assemble_pending_functions): Don't do anything\n+\tspecial for nested functions.\n+\t(cgraph_mark_functions_to_output): Likewise.\n+\t(cgraph_finalize_function): Don't zap DECL_STRUCT_FUNCTION.\n+\t(cgraph_analyze_function): Use estimate_num_insns.\n+\t(cgraph_mark_functions_to_output): Likewise.\n+\t(cgraph_estimate_growth, cgraph_clone_inlined_nodes): Likewise.\n+\t(cgraph_expand_function): Allow functions to not be\n+\temitted.\n+\t(cgraph_remove_unreachable_nodes):\n+\t(cgraph_recursive_inlining_p): Simplify.\n+\t(lookup_recursive_calls,\n+\tcgraph_decide_recursive_inlining): New.\n+\t(cgraph_decide_inlining_*): Update calls of\n+\tcgraph_mark_inline.\n+\t* combine.c (get_pos_from_mask): Always set *plen.\n+\t* common.opt (fdump-, fmudflap, fmudflapth, fmudflapir,\n+\tftree-based-profiling, ftree-ccp, ftree-ch,\n+\tftree-combine-temps, ftree-copyrename, ftree-dce,\n+\tftree-dominator-opts, ftree-dse, ftree-loop-optimize,\n+\tftree-points-to, ftree-pre, ftree-sra, ftree-ter,\n+\tftree-lrs): Add.\n+\t* config.in (HAVE_LD_PIE, HAVE_BANSHEE, PREFIX_INCLUDE_DIR):\n+\tUndefine.\n+\t* configure.ac: Add --enable-tree-browser option.\n+\tAdd --with-libbanshee option.\n+\tAdd GMPLIBS and GMPINC.\n+\t* configure: Regenerate.\n+\t* coverage.c (tree_ctr_tables): New.\n+\t(coverage_counter_alloc): Use it.\n+\t(build_ctr_info_value): Ditto.\n+\t(coverage_counter_ref): Ditto.  Rename to rtl_coverage_counter_ref.\n+\t(tree_coverage_counter_ref): New.\n+\t* coverage.h (coverage_counter_ref): Remove declaration.\n+\t(rtl_coverage_counter_ref): Declare.\n+\t(tree_coverage_counter_ref): Declare.\n+\t* cppexp.c (append_digit): Rearrange unsignedp/overflow setting.\n+\t(eval_token, num_binary_op, num_part_mul, num_div_op): Likewise.\n+\t* cse.c (fold_rtx): Do not handle CONSTANT_P_RTX.\n+\t(struct cse_basic_block_data): Rename enum values to not\n+\tconflict with profile.h; update all uses.\n+\t* dbxout.c (dbxout_symbol_location): Don't mention integrate.c\n+\tin comments.\n+\t* defaults.h (TRAMPOLINE_ALIGNMENT): Move from function.c.\n+\t* diagnostic.h (debug_output_buffer, dump_generic_node,\n+\tprint_generic_stmt, print_generic_stmt_indented,\n+\tprint_generic_expr, print_generic_decl,\n+\tdebug_generic_expr, debug_generic_stmt, debug_c_tree):\n+\tDeclare.\n+\t* dominance.c: Cache immediate dominators.\n+\t* domwalk.c: New file.\n+\t* domwalk.h: New file.\n+\t* dwarf2out.c (is_fortran): Support DW_LANG_Fortran95.\n+\t(gen_subprogram_die): Generate a DIE for a named\n+\treturn value.\n+\t(loc_descriptor_from_tree): Treat RESULT_DECL like VAR_DECL.\n+\t(add_location_or_const_value_attribute): Likewise.\n+\t(add_bound_info): Likewise.\n+\t(gen_decl_die): Likewise.\n+\t* emit-rtl.c (maybe_set_first_label_num): New.\n+\t(copy_most_rtx): Don't copy the integrated flag.\n+\tCopy the new return_val flag.\n+\t* et-forest.c (MAX_NODES): Define.\n+\t(record_path_before_1): Abort if len is greater than\n+\tMAX_NODES.\n+\t* except.c (gen_eh_region, gen_eh_region_cleanup, gen_eh_region_try,\n+\tgen_eh_region_catch, gen_eh_region_allowed,\n+\tgen_eh_region_must_not_throw, get_eh_region_number,\n+\tget_eh_region_may_contain_throw, get_eh_region_tree_label,\n+\tset_eh_region_tree_label, expand_resx_expr): New.\n+\t(expand_eh_region_start, expand_start_catch): Use them.\n+\t(expand_end_catch): Tidy.\n+\t(note_eh_region_may_contain_throw): Take region argument.\n+\t(note_current_region_may_contain_throw): New.\n+\t(get_exception_filter): Export.\n+\t(collect_eh_region_array): Export.\n+\t(remove_unreachable_regions): Check ERT_TRY based on reachability\n+\tof catches, not reachability of continue_label.  Never remove\n+\tERT_MUST_NOT_THROW regions.\n+\t(collect_rtl_labels_from_trees): New.\n+\t(convert_from_eh_region_ranges): Use it.\n+\t(connect_post_landing_pads): Handle dying cleanups.\n+\t(struct reachable_info): Add callback data.\n+\t(add_reachable_handler): Invoke the callback.\n+\t(foreach_reachable_handler): New.\n+\t(reachable_handlers): Use it.\n+\t(arh_to_landing_pad, arh_to_label): New.\n+\t(can_throw_internal_1): Split out from can_throw_internal.\n+\t(can_throw_external_1): Similarly.\n+\t* except.h: Update.\n+\t* explow.c (emit_stack_save): Remove savearea mode check.\n+\t(update_nonlocal_goto_save_area): New.\n+\t(allocate_dynamic_stack_space): Use it.\n+\t(probe_stack_range): Never emit loop notes.\n+\t* expmed.c (extract_fixed_bit_field): Always propagate the\n+\ttarget for the shift if it is a REG.\n+\t* expr.c: Include tree-iterator.h\n+\t(is_zeros_p): Remove.\n+\t(categorize_ctor_elements_1, categorize_ctor_elements): New.\n+\t(count_type_elements): New.\n+\t(mostly_zeros_p): Use them.\n+\t(expr_wfl_stack): Remove.\n+\t(convert_move): Do nothing if to and from are the same.\n+\t(emit_block_move_via_loop): Don't emit LOOP notes.\n+\t(emit_move_insn): Don't handle CONSTANT_P_RTX.\n+\t(emit_move_insn_1): Don't generate inline warnings.\n+\t(expand_vars, expand_var): Split from ...\n+\t(expand_expr_1): ... here.\n+\t(expand_expr_real, expand_expr_real_1):  Use new macros\n+\tEXPR_LOCATION and EXPR_HAS_LOCATION.\n+\t* expr.h (simplify_builtin_fputs,\n+\tsimplify_builtin_strcpy, simplify_builtin_strncpy,\n+\texpand_var, fixup_tail_calls,\n+\tupdate_nonlocal_goto_save_area): Declare.\n+\t(lookup_static_chain, expand_inline_function,\n+\tmark_seen_cases): Remove.\n+\t(prepare_call_address): Change type of 2nd argument to\n+\trtx.\n+\t* final.c (profile_function): Update static chain test.\n+\t(final): Don't look at RTX_INTEGRATED_P.\n+\t* flags.h (flag_mudflap, flag_mudflap_threads,\n+\tflag_mudflap_ignore_reads, flag_tree_pre, flag_tree_ccp,\n+\tflag_tree_dce, flag_tree_combine_temps,\n+\tflag_tree_live_range_split, flag_tree_dom, flag_tree_ch,\n+\tflag_tree_dse, flag_tree_sra, flag_tree_copyrename,\n+\tflag_tree_points_to): Declare.\n+\t(enum pta_type): Declare.\n+\t* flow.c (lang_missing_noreturn_ok_p): Remove.\n+\t(check_function_return_warnings): Remove.\n+\t(update_life_info): Update comments.\n+\t(free_basic_block_vars): Don't call VARRAY_FREE for\n+\tbasic_block_info.\n+\t(regno_uninitialized): Remove.\n+\t* fold-const.c (int_const_binop): Make extern.\n+\t(non_lvalue): Rely on build to set TREE_CONSTANT.\n+\t(operand_equal_p): Replace only_const argument with\n+\tflags.  Allow pure functions if OEP_PURE_SAME.\n+\t(fold): Use OEP_ONLY_CONST.\n+\t(invert_truthvalue) <NOP_EXPR> Break if argument is of\n+\tboolean type.\n+\t(fold_relational_hi_lo,\n+\tnondestructive_fold_binary_to_constant,\n+\tnondestructive_fold_unary_to_constant,\n+\tfold_read_from_constant_string): New.\n+\t* function.c (struct function): Remove calls_constant_p.\n+\t(current_function_calls_constant_p): Remove.\n+\t(inline_function_decl): Remove.\n+\t(put_var_into_stack): Don't use it.\n+\t(fix_lexical_addr): Likewise.\n+\t(inline_function_decl): Remove extern declaration.\n+\t(TRAMPOLINE_ALIGNMENT): Move to defaults.h.\n+\t(trampolines_created): Move to varasm.c.\n+\t(free_after_compilation): Update for removed fields.\n+\t(allocate_struct_function): Likewise.\n+\t(delete_handlers, lookup_static_chain): Remove.\n+\t(fix_lexical_addr): Don't consider non-local variable refs.\n+\t(trampoline_address): Remove.\n+\t(round_trampoline_addr): Move to builtins.c.\n+\t(adjust_trampoline_addr): Remove.\n+\t(expand_function_start): Update for changes to static chain\n+\tand nonlocal goto handling.\n+\t(initial_trampoline): Move to varasm.c.\n+\t(expand_function_end): Don't build trampolines or kill\n+\tunreferenced nonlocal goto labels.\n+\t(free_after_compilation): Don't set it.\n+\t(expand_function_end): Likewise.\n+\t(setjmp_vars_warning): Rename from\n+\tuninitialized_vars_warning, remove uninitialized vars warning.\n+\t(uninitialized_vars_warning): Remove old comment\n+\tand check for DECL_INITIAL, replace with a check of TREE_NO_WARNING\n+\tand do not call the langhook.\n+\t(expand_function_start, expand_function_end): Don't do\n+\tfunction instrumentation here.\n+\t(clear_block_marks): Rename from reorder_blocks_0, export.\n+\t(blocks_nreverse): Export.\n+\t(uninitialized_vars_warning): Use DECL_RTL_SET_P to test for presence\n+\tof rtl.\n+\t(reset_block_changes, record_block_change, finalize_block_changes,\n+\tcheck_block_change, free_block_changes): New functions.\n+\t(assign_parms): Setting of current_function_stdarg\n+\tmoved ...\n+\t(allocate_struct_function): ... here.\n+\t* function.h (struct function): Remove x_nonlocal_labels,\n+\tx_nonlocal_goto_handler_slots, x_nonlocal_goto_stack_level,\n+\tx_context_display, x_trampoline_list, needs_context.\n+\tAdd static_chain_decl, nonlocal_goto_save_area.\n+\t(struct function): Remove x_clobber_return_insn.\n+\tAdd tail_call_emit field, last_label_uid,\n+\tunexpanded_var_list, dont_emit_block_notes,\n+\tib_boundaries_block, function_end_locus and saved_tree/saved_args.\n+\t(clear_block_marks): Declare.\n+\t* gcc.c (MFWRAP_SPEC, MFLIB_SPEC): Add -fmudflapth support.\n+\t(mfwrap_spec, mflib_spec): Declare.\n+\t(cpp_unique_options, cc1_options): Ditto.\n+\t(default_compilers): Add .F and .f90.\n+\t(static_specs): Add mfwrap and mflib.\n+\t* gcse.c (want_to_gcse_p, gcse_constant_p): Don't handle\n+\tCONSTANT_RTX_P.\n+\t(reg_used_on_edge, reg_killed_on_edge, bypass_block):\n+\tUpdate to match insns field in struct edge_def.\n+\t* gdbinit.in (pgs, pge): Define.\n+\t* genattrtab.c (ATTR_PERMANENT_P): Use the return_val flag\n+\tinstead of the integrated flag.\n+\t* gengtype-lex.l (IWOrD): Add HOST_WIDEST_INT\n+\t* gengtype-yacc.y (bitfieldlen): Add empty action.\n+\t(struct_fields): Accept unnamed bitfields.\n+\t(bitfieldlen): Split from ...\n+\t(bitfieldopt): ... here.\n+\t* gengtype.c (ifiles): Add tree-alias-type.h and\n+\ttree-flow.h.\n+\t* genrecog.c (validate_pattern): Do not handle\n+\tCONSTANT_P_RTX.\n+\t* gimple-low.c: New file.\n+\t* gimplify.c: New file.\n+\t* haifa-sched.c (priority): Do not handle CONSTANT_P_RTX.\n+\t(restore_line_notes): Do not set RTX_INTEGRATED_P.\n+\t* ifcvt.c (dead_or_predicable): Initialize local variable\n+\t'earliest'.\n+\t* input.h (expr_wfl_stack): Remove.\n+\t* integrate.c (INTEGRATE_THRESHOLD): Remove.\n+\t(setup_initial_hard_reg_value_integration): Likewise.\n+\t(initialize_for_inline): Likewise.\n+\t(note_modified_parmregs): Likewise.\n+\t(integrate_parm_decls): Likewise.\n+\t(process_reg_param): Likewise.\n+\t(save_parm_insns): Likewise.\n+\t(copy_insn_list): Likewise.\n+\t(copy_insn_notes): Likewise.\n+\t(compare_blocks): Likewise.\n+\t(find_block): Likewise.\n+\t(inlining): Likewise.\n+\t(function_cannot_inline_p): Likewise.\n+\t(parmdecl_map): Likewise.\n+\t(in_nonparam_insns): Likewise.\n+\t(save_for_inline): Likewise.\n+\t(FIXED_BASE_PLUS): Likewise.\n+\t(expand_inline_function): Likewise.\n+\t(copy_rtx_and_substitute): Don't look at map->integrating,\n+\tmap->inline_target, and inlining, since we are never copying\n+\tfor integrating.\n+\tDon't abort on RTX_INTEGRATED_P.\n+\t(old_fun): Remove.\n+\t(output_inline_function): Remove.\n+\t* integrate.h (struct inline_map): Remove fields integrating,\n+\tblock_map, leaf_reg_map, inline_target, and local_return_label.\n+\t* jump.c (next_nonnote_insn_in_loop, duplicate_loop_exit_test,\n+\tcopy_loop_headers, never_reached_warning): Removed.\n+\t(any_uncondjump_p): Reject nonlocal goto.\n+\t* langhooks-def.h (lhd_types_compatible_p,\n+\tlhd_expand_decl, lhd_gimplify_expr): Declare.\n+\t(LANG_HOOKS_EXPAND_DECL, LANG_HOOKS_TYPES_COMPATIBLE_P,\n+\tLANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P,\n+\tLANG_HOOKS_FUNCTION_LEAVE_NESTED,\n+\tLANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P,\n+\tLANG_HOOKS_GIMPLIFY_EXPR,\n+\tLANG_HOOKS_GIMPLE_BEFORE_INLINING,\n+\tLANG_HOOKS_EXPAND_DECL, LANG_HOOKS_TYPES_COMPATIBLE_P,\n+\tLANG_HOOKS_GIMPLIFY_EXPR,\n+\tLANG_HOOKS_GIMPLE_BEFORE_INLINING): Define.\n+\t(LANG_HOOKS_DECL_UNINIT, LANG_HOOKS_RTL_EXPAND_START,\n+\tLANG_HOOKS_RTL_EXPAND_STMT, LANG_HOOKS_RTL_EXPAND_END,\n+\tLANG_HOOKS_FUNCTION_LEAVE_NESTED,\n+\tLANG_HOOKS_RTL_EXPAND_INITIALIZER,\n+\tLANG_HOOKS_DECL_UNINIT,\n+\tLANG_HOOKS_RTL_EXPAND_INITIALIZER): Remove.\n+\t* langhooks.c: Include tree-simple.h.\n+\t(lhd_expand_decl): New.\n+\t(lhd_types_compatible_p): New.\n+\t(lhd_decl_uninit): Remove.\n+\t(lhd_gimplify_expr): New.\n+\t* langhooks.h (struct lang_hooks_for_rtl_expansion):\n+\tRemove.\n+\t(struct lang_hooks_for_functions): Add field\n+\tmissing_noreturn_ok_p.\n+\t(struct lang_hooks): Add field expand_decl,\n+\ttypes_compatible_p, gimplify_expr and\n+\tgimple_before_inlining.\n+\tRemove fields decl_uninit and rtl_expand\n+\t* opts.c (decode_options): Set flag_tree_ccp,\n+\tflag_tree_dce, flag_tree_dom, flag_tree_dse,\n+\tflag_tree_pre, flag_tree_ter,\n+\tflag_tree_live_range_split, flag_tree_sra,\n+\tflag_tree_copyrename and flag_tree_ch at -O1 and higher.\n+\t(common_handle_option): Handle OPT_fdump_, OPT_fmudflap,\n+\tOPT_fmudflapth, OPT_fmudflapir,\n+\tOPT_ftree_based_profiling, OPT_ftree_ccp, OPT_ftree_dce,\n+\tOPT_ftree_combine_temps, OPT_ftree_ter, OPT_ftree_lrs,\n+\tOPT_ftree_dominator_opts, OPT_ftree_copyrename,\n+\tOPT_ftree_ch, OPT_ftree_dse, OPT_ftree_sra,\n+\tOPT_ftree_points_to_ and OPT_ftree_pre.\n+\t* output.h (regno_uninitialized, find_basic_blocks,\n+\tcleanup_cfg, delete_unreachable_blocks,\n+\tcheck_function_return_warnings): Remove.\n+\t* params.def (PARAM_MAX_INLINE_INSNS_RECURSIVE,\n+\tPARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO,\n+\tPARAM_MAX_INLINE_RECURSIVE_DEPTH,\n+\tPARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO,\n+\tPARAM_GLOBAL_VAR_THRESHOLD, PARAM_MAX_ALIASED_VOPS):\n+\t* params.h (GLOBAL_VAR_THRESHOLD, MAX_ALIASED_VOPS):\n+\tDefine.\n+\t* passes.c (rest_of_decl_compilation):\n+\t(rest_of_handle_sibling_calls): Remove.\n+\t(rest_of_handle_inlining): Remove.\n+\t(rest_of_handle_gcse): Do not run\n+\tpurge_builtin_constant_p.\n+\t(rest_of_compilation): Update.\n+\tDo not call copy_loop_headers.\n+\tDo rtl-based profiling only when\n+\t!flag_tree_based_profiling.  Register rtl-based profiling\n+\thooks.\n+\t* predict.c:  Include tree-flow.h, ggc.h, tree-dump.h\n+\t(predicted_by_p): Rename to ...\n+\t(rtl_predicted_by_p): .. this one; make global\n+\t(tree_predicted_by_p): New.\n+\t(dump_prediction): Add FILE argument.\n+\t(predict_edge): Rename to ...\n+\t(rtl_predict_edge): .. this one.\n+\t(tree_predict_edge): New.\n+\t(combine_predictions_for_insn): Update calls of predict_edge.\n+\t(predict_loops): Break out from ...\n+\t(estimate_probability): ... here; update comments; move updating\n+\tof unknown probabilities from ...\n+\t(estimate_bb_frequencies): ... here.\n+\t(combine_predictions_for_bb): New.\n+\t(tree_predict_by_opcode): New.\n+\t(tree_estimate_probability): New.\n+\t* predict.def (PRED_TREE_POINTER, PRED_TREE_OPCODE_POSITIVE,\n+\tPRED_TREE_OPCODE_NONEQUAL, PRED_TREE_FPOPCODE): New predictors.\n+\t* predict.h: Add include guard.\n+\t(predict_edge, predict_edge_def): Move prototypes to basic_block.h\n+\t* pretty-print.c (pp_write_text_to_stream): Make extern.\n+\t* pretty-print.h (pp_write_text_to_stream): Declare.\n+\t* print-rtl.c (print_rtx): Don't print the integrated flag.\n+\tPrint the return_val flag.\n+\t* print-tree.c: Use TREE_FILENAME and TREE_LINENO instead\n+\tof DECL_SOURCE_FILE and DECL_SOURCE_LINE respectively.\n+\tRemove support for EXPR_WITH_FILE_LOCATION nodes.\n+\t(print_node): Print TREE_INVARIANT and TREE_VISITED.\n+\t* profile.c: Include cfghooks.h, tree-flow.h.\n+\t(profile_hooks): New.\n+\t(profile_dump_file): New.\n+\t(instrument_edges): Use hooks instead of RTL-specific code.\n+\t(instrument_values): Ditto.\n+\t(get_exec_counts): Ditto.\n+\t(compute_branch_probabilities): Ditto.\n+\t(compute_value_histograms): Ditto.\n+\t(branch_prob): Ditto.\n+\t(find_spanning_tree): Ditto.\n+\t(end_branch_prob): Ditto.\n+\t(gen_edge_profiler): Move to rtl-profile.c (rtl_gen_edge_profiler).\n+\t(gen_interval_profiler): Ditto (rtl_gen_interval_profiler).\n+\t(gen_pow2_profiler): Ditto (rtl_gen_pow2_profiler).\n+\t(gen_one_value_profiler): Ditto (rtl_gen_one_value_profiler).\n+\t(tree_register_profile_hooks): New.\n+\t(rtl_register_profile_hooks): New.\n+\t* ra-rewrite.c (rewrite_program): Clear variable info.\n+\t* recog.c (immediate_operand): Do not handle CONSTANT_P_RTX.\n+\t* regs.h: Add include guards.\n+\t* reload.c (decompose): Clear val using memset.\n+\t* rtl.def (CONSTANT_P_RTX): Remove.\n+\t* rtl.h (CONSTANT_P): Do not handle CONSTANT_P_RTX.\n+\t(copy_loop_headers): Remove.\n+\t(struct rtx_def): Replace the integrated flag with the\n+\treturn_val flag.\n+\t(maybe_set_first_label_num): Declare.\n+\t(init_branch_prob): Move declaration to value-prof.h.\n+\t(end_branch_prob): Ditto.\n+\t(branch_prob): Ditto.\n+\t(never_reached_warning): Don't declare it.\n+\t* rtlanal.c (get_related_value): Initialize get_jump_table_offset\n+\t(hoist_insn_to_edge): Update to match field insns in\n+\tstruct edge_def.\n+\t* sbitmap.c (sbitmap_realloc): New.\n+\t* sbitmap.h (sbitmap_realloc): Declare.\n+\t* sibcall.c: Remove file.\n+\t* simplify-rtx.c (simplify_rtx): Do not handle\n+\tCONSTANT_P_RTX.\n+\t* stmt.c (parse_output_constraint): Don't warn for read-write\n+        memory operand.\n+\t(tail_recursion_args): Use types_compatible_p langhook.\n+\t(force_label_rtx): Don't look at inline_function_decl.\n+\t(label_rtx): Set LABEL_PRESERVE_P appropriately.\n+\t(expand_label): Handle DECL_NONLOCAL and FORCED_LABEL.\n+\t(declare_nonlocal_label): Remove.\n+\t(expand_goto): Don't handle nonlocal gotos.\n+\t(expand_nl_handler_label): Remove.\n+\t(expand_nl_goto_receivers): Remove.\n+\t(expand_end_bindings): Don't expand_nl_goto_receivers.  Use\n+\tupdate_nonlocal_goto_save_area.\n+\t(expand_expr_stmt_value): Check TREE_NO_WARNING.\n+\t(warn_if_unused_value): Likewise.\n+\t(expand_start_loop, expand_loop_continue_here,\n+\texpand_end_loop): Don't create loop notes.\n+\t(all_cases_count, BITARRAY_TEST, BITARRAY_SET,\n+\tmark_seen_cases, check_for_full_enumeration_handling): Remove.\n+\t(expand_end_case_type): Don't do warn_switch handling.\n+\t(pushcase, pushcase_range) Update add_case_node calls.\n+\t(add_case_node): Add dont_expand_label argument.\n+\t(same_case_target_p): Don't search rtl.\n+\t(expand_start_bindings_and_block, expand_end_bindings):\n+\tDon't emit block notes when dont_emit_block_notes.\n+\t(using_eh_for_cleanups_p): Export.\n+\t(expand_return): Allow any typed rhs.\n+\t(expand_stack_alloc): New.\n+\t(expand_stack_save, expand_stack_restore): New.\n+\t(containing_blocks_have_cleanups_or_stack_level): New\n+\tfunction.\n+\t(asm_op_is_mem_input): New fn.\n+\t(expand_asm_expr): New fn.\n+\t(warn_if_unused_value): Check operand 0 of SAVE_EXPR\n+\tnodes.\n+\t* stor-layout.c (layout_type): Just return if type is\n+\terror_mark_node.\n+\t(update_alignment_for_field): Export.\n+\t(variable_size): We don't care about global_bindings_p if\n+\tthe frontend doesn't want a list of the expressions.\n+\t* system.h: Poison INTEGRATE_THRESHOLD.\n+\t* timevar.def (TV_TREE_GIMPLIFY, TV_TREE_EH, TV_TREE_CFG,\n+\tTV_TREE_CLEANUP_CFG, TV_TREE_PTA, TV_TREE_MAY_ALIAS,\n+\tTV_TREE_INSERT_PHI_NODES, TV_TREE_SSA_REWRITE_BLOCKS,\n+\tTV_TREE_SSA_OTHER, TV_TREE_OPS,\n+\tTV_TREE_SSA_DOMINATOR_OPTS, TV_TREE_SRA, TV_TREE_CCP,\n+\tTV_TREE_SPLIT_EDGES, TV_TREE_PRE, TV_TREE_PHIOPT,\n+\tTV_TREE_FORWPROP, TV_TREE_DCE, TV_TREE_CD_DCE,\n+\tTV_TREE_DSE, TV_TREE_LOOP, TV_TREE_CH,\n+\tTV_TREE_SSA_TO_NORMAL, TV_TREE_SSA_TO_NORMAL,\n+\tTV_TREE_NRV, TV_TREE_COPY_RENAME, TV_TREE_SSA_VERIFY,\n+\tTV_TREE_STMT_VERIFY, TV_DOM_FRONTIERS,\n+\tTV_CONTROL_DEPENDENCES): Define.\n+\t* toplev.c: Include tree-alias-common.h\n+\t(current_file_decl, flag_mudflap, flag_mudflap_threads,\n+\tflag_mudflap_ignore_reads, flag_tree_based_profiling,\n+\tflag_tree_gvn, flag_tree_points_to, flag_tree_ccp,\n+\tflag_tree_dce, flag_tree_ch, flag_tree_sra,\n+\tflag_tree_combine_temps, flag_tree_ter,\n+\tflag_tree_live_range_split, flag_tree_dom,\n+\tflag_tree_copyrename, flag_tree_dse): Declare.\n+\t(f_options): Add tree-based-profiling, tree-gvn,\n+\ttree-pre, tree-ccp, tree-dce,\n+\ttree-dominator-opts, tree-copyrename, tree-dse,\n+\ttree-combine-temps, tree-ter, tree-lrs and tree-ch.\n+\t(wrapup_global_declarations): Don't output nested inlined functions.\n+\t(general_init): Call init_tree_optimization_passes.\n+\t(process_options): Sorry for -ftree-based-profiling plus\n+\t-ftest-coverage or -fprofile-values.\n+\t* toplev.h (init_tree_optimization_passes,\n+\tflag_tree_based_profiling): Declare.\n+\t* tracer.c (tail_duplicate): Use cfghooks for bb duplication.\n+\t* tree-alias-ander.c: New file.\n+\t* tree-alias-ander.h: New file.\n+\t* tree-alias-common.c: New file.\n+\t* tree-alias-common.h: New file.\n+\t* tree-alias-type.c: New file.\n+\t* tree-alias-type.h: New file.\n+\t* tree-browser.c: New file.\n+\t* tree-browser.def: New file.\n+\t* tree-cfg.c: New file.\n+\t* tree-complex.c: New file.\n+\t* tree-dfa.c: New file.\n+\t* tree-dump.c (dump_enable_all): New.\n+\t(dequeue_and_dump): Do not handle EXPR_WITH_FILE_LOCATION.\n+\t(dump_node): Remove const from field suffix and swtch.\n+\t(dump_files): Add null entry, .generic, .nested, .vcg,\n+\t.xml and a match-all entry.\n+\t(extra_dump_files, extra_dump_files_in_use,\n+\textra_dump_files_alloced): Declare\n+\t(dump_option_value_info): Add raw, details, stats,\n+\tblocks, vops, lineno, uid and all.\n+\t(dump_register): New.\n+\t(get_dump_file_info): New.\n+\t(dump_begin): Call it.\n+\tDo nothing for TDI_none.\n+\t(dump_begin): Include phase number in dump filename.\n+\t(dump_enable_all): New.\n+\t(dump_switch_p_1): Split out from dump_switch_p.\n+\t(dump_switch_p): Handle extra_dump_files.\n+\tStart our scan at TDI_none + 1.\n+\tIf -fdump-tree-all was given, call dump_enable_all.\n+\t* tree-dump.h: Include splay-tree.h.\n+\t(dump_function, dump_function_to_file, dump_register):\n+\tDeclare.\n+\t* tree-eh.c: New file.\n+\t* tree-flow-inline.h: New file.\n+\t* tree-flow.h: New file.\n+\t* tree-inline.c: Re-write to handle inlining on GIMPLE.\n+\t* tree-inline.h (walk_tree,\n+\twalk_tree_without_duplicates): Move to tree.h.\n+\t(estimate_num_insns): Declare.\n+\t* tree-into-ssa.c: New file.\n+\t* tree-iterator.c: New file.\n+\t* tree-iterator.h: New file.\n+\t* tree-mudflap.c: New file.\n+\t* tree-mudflap.h: New file.\n+\t* tree-nested.c: New file.\n+\t* tree-nomudflap.c: New file.\n+\t* tree-nrv.c: New file.\n+\t* tree-optimize.c (dump_flags, vars_to_rename,\n+\tin_gimple_form, all_passes, pass_gimple,\n+\tpass_rebuild_bind, pass_all_optimizations, pass_del_cfg): Declare.\n+\t(execute_gimple, execute_rebuild_bind,\n+\tgate_all_optimizations, execute_del_cfg,\n+\tregister_one_dump_file, register_dump_files, dup_pass_1,\n+\tinit_tree_optimization_passes, execute_todo,\n+\texecute_one_pass, execute_pass_list): New.\n+\t(clear_decl_rtl): Remove.\n+\t(tree_rest_of_compilation): Update to use tree\n+\toptimizers.\n+\t* tree-outof-ssa.c: New file.\n+\t* tree-pass.h: New file.\n+\t* tree-phinodes.c: New file.\n+\t* tree-pretty-print.c: New file.\n+\t* tree-profile.c: New file.\n+\t* tree-simple.c: New file.\n+\t* tree-simple.h: New file.\n+\t* tree-sra.c: New file.\n+\t* tree-ssa-alias.c: New file.\n+\t* tree-ssa-ccp.c: New file.\n+\t* tree-ssa-copy.c: New file.\n+\t* tree-ssa-copyrename.c: New file.\n+\t* tree-ssa-dce.c: New file.\n+\t* tree-ssa-dom.c: New file.\n+\t* tree-ssa-dse.c: New file.\n+\t* tree-ssa-forwprop.c: New file.\n+\t* tree-ssa-live.c: New file.\n+\t* tree-ssa-live.h: New file.\n+\t* tree-ssa-loop.c: New file.\n+\t* tree-ssa-operands.c: New file.\n+\t* tree-ssa-operands.h: New file.\n+\t* tree-ssa-phiopt.c: New file.\n+\t* tree-ssa-pre.c: New file.\n+\t* tree-ssa.c: New file.\n+\t* tree-ssanames.c: New file.\n+\t* tree-tailcall.c: New file.\n+\t* tree.c: Include tree-iterator.h, basic-block.h and\n+\ttree-flow.h.\n+\t(tree_node_kind): Add phi_nodes and ssa names.\n+\t(tree_size): Handle PHI_NODE, EPHI_NODE, SSA_NAME,\n+\tEUSE_NODE, EKILL_NODE, EEXIT_NODE and STATEMENT_LIST.\n+\t(make_node_stat): Handle PHI_NODE and SSA_NAME.\n+\t<'c'> Set TREE_INVARIANT.\n+\t(copy_node_stat): Abort if trying to copy a\n+\tSTATEMENT_LIST.\n+\tClear TREE_VISITED.\n+\tClear annotation field.\n+\t(build_constructor): Copy TREE_INVARIANT from vals.\n+\tDon't clear TREE_CONSTANT.\n+\t(expr_first, expr_last, expr_length): Remove.\n+\t(staticp): Pass unknown component references to the language.\n+\t(save_expr): Check TREE_INVARIANT instead of TREE_CONSTANT.\n+\t(skip_simple_arithmetic): Likewise.\n+\t(stabilize_reference_1): Likewise.\n+\t(tree_node_structure): Handle PHI_NODE, EPHI_NODE,\n+\tEUSE_NODE, EKILL_NODE, EEXIT_NODE, SSA_NAME and\n+\tSTATEMENT_LIST.\n+\t(lhd_unsave_expr_now): Remove.\n+\t(unsafe_for_reeval): Handle LABEL_EXPR and BIND_EXPR.\n+\t(recompute_tree_invarant_for_addr_expr): New.\n+\t(build1_stat): Clear EXPR_LOCUS and TREE_BLOCK.\n+\tCall recompute_tree_invarant_for_addr_expr.\n+\tSet TREE_INVARIANT accordingly.\n+\t(build2_stat): Don't handle CALL_EXPR.\n+\t(build3_stat): Don't call build2_stat for CALL_EXPRs.\n+\t(build_expr_wfl): Remove.\n+\t(annotate_with_file_line, annotate_with_locus): New.\n+\t(simple_cst_equal): Call simple_cst_list_equal to compare\n+\tCONSTRUCTOR_ELTS pointers.\n+\t(iterative_hash_expr): Don't hash types associated\n+\twith conversions.  Instead hash on the signedness of the\n+\ttoplevel object and the operand of the conversion.\n+\t(dump_tree_statistics): Call ssanames_print_statistics\n+\tand phinodes_print_statistics.\n+\t(ephi_node_elt_check_failed, phi_node_elt_check_failed,\n+\tadd_var_to_bind_expr, build_empty_stmt, is_essa_node,\n+\tneeds_to_live_in_memory): New.\n+\t(initializer_zerop): Handle VECTOR_CST.  Don't check\n+\tAGGREGATE_TYPE_P for CONSTRUCTOR.\n+\t* tree.def (FILTER_EXPR, CASE_LABEL_EXPR, RESX_EXPR,\n+\tSSA_NAME, EUSE_NODE, EKILL_NODE, EPHI_NODE, EEXIT_NODE,\n+\tPHI_NODE, CATCH_EXPR, EH_FILTER_EXPR, STATEMENT_LIST): Define.\n+\t(GOTO_SUBROUTINE_EXPR): Change type to 's'.\n+\t(CALL_EXPR): Add another operand.\n+\t(EXPR_WITH_FILE_LOCATION): Remove.\n+\t(SWITCH_EXPR): Add another operand.\n+\t* tree.h: Update various comments.\n+\t(union tree_ann_d): Forward declare.\n+\t(struct tree_common): Add fields nowarning_flag,\n+\tinvariant_flag and visited.\n+\t(EREF_NODE_CHECK, EPHI_NODE_ELT_CHECK,\n+\tPHI_NODE_ELT_CHECK, EREF_NODE_CHECK, PHI_NODE_ELT_CHECK,\n+\tEPHI_NODE_ELT_CHECK, TREE_BLOCK,\n+\tSTRIP_USELESS_TYPE_CONVERSION, CALL_EXPR_TAILCALL,\n+\tTREE_NO_WARNING, FORCED_LABEL, TREE_INVARIANT,\n+\tIS_EMPTY_STMT, EXPR_LOCUS, SET_EXPR_LOCUS, EXPR_FILENAME,\n+\tEXPR_LINENO, EXPR_LOCATION, EXPR_HAS_LOCATION,\n+\tEXIT_EXPR_COND, SWITCH_COND, SWITCH_BODY, SWITCH_LABELS,\n+\tCASE_LOW, CASE_HIGH, CASE_LABEL, BIND_EXPR_VARS,\n+\tBIND_EXPR_BODY, BIND_EXPR_BLOCK, GOTO_DESTINATION,\n+\tASM_STRING, ASM_OUTPUTS, ASM_INPUTS, ASM_CLOBBERS,\n+\tASM_INPUT_P, ASM_VOLATILE_P, COND_EXPR_COND,\n+\tCOND_EXPR_THEN, COND_EXPR_ELSE, LABEL_EXPR_LABEL,\n+\tCATCH_TYPES, CATCH_BODY, EH_FILTER_TYPES,\n+\tEH_FILTER_FAILURE, EH_FILTER_MUST_NOT_THROW,\n+\tSSA_NAME_VAR, SSA_NAME_DEF_STMT, SSA_NAME_VERSION,\n+\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI, SSA_NAME_IN_FREE_LIST,\n+\tPHI_RESULT, PHI_REWRITTEN, PHI_NUM_ARGS,\n+\tPHI_ARG_CAPACITY, PHI_ARG_ELT, PHI_ARG_EDGE, PHI_ARG_DEF,\n+\tEREF_PROCESSED, EREF_ID, EREF_NAME, EREF_STMT,\n+\tEREF_RELOAD, EREF_SAVE, EREF_CLASS, EREF_INJURED,\n+\tEREF_TEMP, EUSE_DEF, EUSE_PHIOP, EUSE_INSERTED,\n+\tEUSE_LVAL, EPHI_NUM_ARGS, EPHI_ARG_CAPACITY,\n+\tEPHI_ARG_ELT, EPHI_ARG_EDGE, EPHI_ARG_PRED, EPHI_ARG_DEF,\n+\tEPHI_ARG_INJURED, EPHI_ARG_DELAYED_RENAME,\n+\tEPHI_ARG_HAS_REAL_USE, EPHI_ARG_STOPS,\n+\tEPHI_ARG_PROCESSED2, EPHI_IDENTITY, EPHI_IDENT_INJURED,\n+\tEPHI_REP_OCCUR_KNOWN, EPHI_IDENTICAL_TO, EPHI_DOWNSAFE,\n+\tEPHI_CANT_BE_AVAIL, EPHI_DEAD, EPHI_USES, EPHI_STOPS,\n+\tTREE_VISITED, SSA_VAR_P, DECL_NUM_STMTS,\n+\tDECL_HARD_REGISTER, DECL_PTA_ALIASVAR, LABEL_DECL_UID,\n+\tDECL_NEEDS_TO_LIVE_IN_MEMORY_INTERNAL,\n+\tSTATEMENT_LIST_HEAD, STATEMENT_LIST_TAIL, TDF_RAW,\n+\tTDF_DETAILS, TDF_STATS, TDF_BLOCKS, TDF_VOPS, TDF_LINENO,\n+\tTDF_UID,): Define.\n+\t(TREE_NO_UNUSED_WARNING, EXPR_WFL_EMIT_LINE_NOTE,\n+\tEXPR_WFL_NODE, EXPR_WFL_FILENAME_NODE, EXPR_WFL_FILENAME,\n+\tEXPR_WFL_LINECOL, EXPR_WFL_LINENO, EXPR_WFL_COLNO,\n+\tEXPR_WFL_SET_LINECOL): Remove.\n+\t(phi_node_elt_check_failed, ephi_node_elt_check_failed,\n+\tmake_phi_node, init_phinodes, fini_phinodes,\n+\trelease_phi_node, phinodes_print_statistics,\n+\tinit_ssanames, fini_ssanames, make_ssa_name,\n+\trelease_ssa_name, ssanames_print_statistics,\n+\tannotate_with_file_line, build_empty_stmt,\n+\tannotate_with_locus, expr_only, categorize_ctor_elements,\n+\tcount_type_elements, add_var_to_bind_expr, is_essa_node,\n+\texpand_stack_alloc, expand_stack_save,\n+\texpand_stack_restore, add_case_node, operand_equal_p,\n+\tnondestructive_fold_unary_to_constant,\n+\tnondestructive_fold_binary_to_constant,\n+\tfold_read_from_constant_string, int_const_binop,\n+\tstrip_float_extensions, simplify_builtin, c_strlen,\n+\trecompute_tree_invarant_for_addr_expr,\n+\tneeds_to_live_in_memory, make_vector,\n+\tsetjmp_vars_warning, update_alignment_for_field,\n+\texpand_asm_expr, asm_op_is_mem_input,\n+\tcontaining_blocks_have_cleanups_or_stack_level,\n+\tcreate_artificial_label, gimplify_function_tree,\n+\tget_name, unshare_expr, walk_tree,\n+\twalk_tree_without_duplicates, in_gimple_form): Declare.\n+\t(struct tree_exp): Add fields locus and block.\n+\t(struct tree_ssa_name, struct edge_def, struct\n+\ttree_phi_node, struct tree_eref_common, struct\n+\ttree_euse_node, struct ephi_arg_d, struct tree_ephi_node,\n+\tunion alias_var_def, struct tree_statement_list_node,\n+\tstruct tree_statement_list, enum operand_equal_flag): Declare.\n+\t(enum tree_node_structure_enum): Add TS_SSA_NAME,\n+\tTS_PHI_NODE, TS_EPHI_NODE, TS_EUSE_NODE, TS_EREF_NODE,\n+\tTS_STATEMENT_LIST.\n+\t(union tree_node): Add fields ssa_name, phi, eref, ephi,\n+\teuse and stmt_list.\n+\t(function_cannot_inline_p, uninitialized_vars_warning,\n+\tsave_for_inline, output_inline_function, all_cases_count,\n+\tcheck_for_full_enumeration_handling,\n+\tdeclare_nonlocal_label): Remove.\n+\t(enum tree_dump_index): Add TDI_none, TDI_tu,\n+\tTDI_generic, TDI_nested, TDI_vcg, TDI_xml.\n+\t* unroll.c (unroll_loop): Don't clear map->inline_target.\n+\t* unwind-sjlj.c (uw_install_context): Make a proper static inline\n+\tfunction.\n+\t* value-prof.c (value_prof_hooks): New.\n+\t(find_values_to_profile): Rename to rtl_find_values_to_profile.\n+\tMove rtl-specific bits in from branch_prob.\n+\t(value_profile_transformations): Rename to\n+\trtl_value_profile_transformations.\n+\t(struct value_prof_hooks): New.\n+\t(rtl_value_prof_hooks): New.\n+\t(rtl_register_value_prof_hooks): New.\n+\t(tree_find_values_to_profile): New stub.\n+\t(tree_value_profile_transformations): New stub.\n+\t(tree_value_prof_hooks): New stub.\n+\t(tree_register_value_prof_hooks): New stub.\n+\t(find_values_to_profile): New.\n+\t(value_profile_transformations): New.\n+\t* value-prof.h: Add multiple inclusion guard.\n+\t(struct histogram_value): Change rtx fields to void *.\n+\t(rtl_register_value_prof_hooks): New declaration.\n+\t(tree_register_value_prof_hooks): New declaration.\n+\t(find_values_to_profile): New declaration.\n+\t(free_profiled_values): New declaration.\n+\t(value_profile_transformations): New declaration.\n+\t(struct profile_hooks): New declaration.\n+\t(init_branch_prob): Declaration moved from rtl.h.\n+\t(branch_prob): Declaration moved from rtl.h.\n+\t(end_branch_prob): Declaration mooved from rtl.h.\n+\t(tree_register_profile_hooks): New declaration.\n+\t(rtl_register_profile_hooks): New declaration.\n+\t(tree_profile_hooks): New declaration.\n+\t(rtl_profile_hooks): New declaration.\n+\t* varasm.c: Include tree-mudflap.h.\n+\t(TRAMPOLINE_ALIGNMENT): Remove.\n+\t(make_decl_rtl): Call mudflap_enqueue_decl.\n+\t(assemble_static_space):\n+\t(assemble_trampoline_template): Set and return\n+\tTRAMPOLINE_ALIGNMENT.\n+\t* varray.c (element): Add GENERIC_PTR_NOGC entry.\n+\tAdd entry for 'tree *'.\n+\tAdd entry for struct edge_def *.\n+\t(varray_copy): New.\n+\t* varray.h (enum varray_data_enum): Add\n+\tVARRAY_DATA_GENERIC_NOGC, VARRAY_DATA_EDGE and\n+\tVARRAY_DATA_TREE_PTR.\n+\t(union varray_data_tag): Corresponding changes.\n+\t(VARRAY_GENERIC_PTR_NOGC_INIT, VARRAY_EDGE_INIT,\n+\tVARRAY_TREE_PTR_INIT, VARRAY_GENERIC_PTR_NOGC,\n+\tVARRAY_EDGE, VARRAY_TREE_PTR,\n+\tVARRAY_PUSH_GENERIC_PTR_NOGC, VARRAY_PUSH_EDGE,\n+\tVARRAY_PUSH_TREE_PTR, VARRAY_TOP_GENERIC_PTR_NOGC,\n+\tVARRAY_TOP_EDGE, VARRAY_TOP_TREE_PTR): Define.\n+\n+\t* config/*/*: Various updates for changed macros, tree\n+\tcodes, etc.  Check ChangeLog.tree-ssa.\n+\n+\t* doc/cfg.texi: New file.\n+\t* doc/tree-ssa.texi: New file.\n+\t* doc/c-tree.texi: Document new codes.\n+\t* doc/gccint.texi: Include new files.\n+\t* doc/install.texi: Document new features.\n+\t* doc/invoke.texi: Document new switches.\n+\t* doc/passes.texi: Document new passes.\n+\t* doc/rtl.texi: Update changed RTL codes.\n+\t* doc/sourcebuild.texi: Update build instructions.\n+\t* doc/standards.texi: Document Fortran changes.\n+\t* doc/tm.texi: Update.\n+\n 2004-05-12  Paolo Bonzini  <bonzini@gnu.org>\n \n \tReplace several arrays with a struct of arrays."}, {"sha": "cf077aa1e3694a84a4a961daa24688d74742625c", "filename": "gcc/ChangeLog.tree-ssa", "status": "added", "additions": 19338, "deletions": 0, "changes": 19338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "bfeaa0c37ca8996da90b6650ca8ac3d1486d837d", "filename": "gcc/Makefile.in", "status": "modified", "additions": 224, "deletions": 32, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -140,7 +140,7 @@ XCFLAGS =\n TCFLAGS =\n CFLAGS = -g\n STAGE1_CFLAGS = -g @stage1_cflags@\n-BOOT_CFLAGS = -g -O2\n+BOOT_CFLAGS = -g -O2 \n \n # Flags to determine code coverage. When coverage is disabled, this will\n # contain the optimization flags, as you normally want code coverage\n@@ -192,6 +192,14 @@ c-parse.o-warn = -Wno-error\n gengtype-lex.o-warn = -Wno-error\n # SYSCALLS.c misses prototypes\n SYSCALLS.c.X-warn = -Wno-strict-prototypes -Wno-error\n+# These files need -Wno-error because the gimplifier triggers hard to fix\n+# warnings when converting to GIMPLE form.  The warnings are triggered because\n+# moving the condition into the loop prevents the loop optimizer from\n+# recognizing that the loop will always be executed at least once.  We need\n+# a new loop optimizer.\n+reload1.o-warn = -Wno-error\n+# These warnings are due to libbanshee.\n+tree-alias-ander.o-warn = -Wno-error\n \n # All warnings have to be shut off in stage1 if the compiler used then\n # isn't gcc; configure determines that.  WARN_CFLAGS will be either\n@@ -270,6 +278,12 @@ OUTPUT_OPTION = @OUTPUT_OPTION@\n ZLIB = @zlibdir@ -lz\n ZLIBINC = @zlibinc@\n \n+# How to find GMP\n+GMPLIBS = @GMPLIBS@\n+GMPINC = @GMPINC@\n+\n+BANSHEELIB = @BANSHEELIB@\n+BANSHEEINC = @BANSHEEINC@\n # Substitution type for target's getgroups 2nd arg.\n TARGET_GETGROUPS_T = @TARGET_GETGROUPS_T@\n \n@@ -687,6 +701,11 @@ C_TREE_H = c-tree.h $(C_COMMON_H)\n SYSTEM_H = system.h hwint.h $(srcdir)/../include/libiberty.h\n PREDICT_H = predict.h predict.def\n CPPLIB_H = cpplib.h line-map.h\n+TREE_DUMP_H = tree-dump.h $(SPLAY_TREE_H)\n+TREE_SIMPLE_H = tree-simple.h tree-iterator.h\n+TREE_FLOW_H = tree-flow.h tree-flow-inline.h tree-ssa-operands.h \\\n+\t\tbitmap.h $(BASIC_BLOCK_H) hard-reg-set.h $(TREE_SIMPLE_H) \\\n+\t\t$(HASHTAB_H)\n PRETTY_PRINT_H = pretty-print.h input.h $(OBSTACK_H)\n DIAGNOSTIC_H = diagnostic.h diagnostic.def $(PRETTY_PRINT_H)\n C_PRETTY_PRINT_H = $(PRETTY_PRINT_H) $(C_COMMON_H) $(TREE_H)\n@@ -713,15 +732,15 @@ LIBIBERTY = ../libiberty/libiberty.a\n BUILD_LIBIBERTY = @FORBUILD@/libiberty/libiberty.a\n \n # Dependencies on the intl and portability libraries.\n-LIBDEPS= $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) libcpp.a\n+LIBDEPS= $(LIBIBERTY) $(LIBINTL_DEP) $(LIBICONV_DEP) libcpp.a $(BANSHEELIB)\n \n # Likewise, for use in the tools that must run on this machine\n # even if we are cross-building GCC.\n BUILD_LIBDEPS= $(BUILD_LIBIBERTY)\n \n # How to link with both our special library facilities\n # and the system's installed libraries.\n-LIBS = @LIBS@ libcpp.a $(LIBIBERTY) $(LIBINTL) $(LIBICONV)\n+LIBS = @LIBS@ libcpp.a $(LIBIBERTY) $(LIBINTL) $(LIBICONV) $(BANSHEELIB)\n \n # Any system libraries needed just for GNAT.\n SYSLIBS = @GNAT_LIBEXC@\n@@ -750,7 +769,8 @@ BUILD_VARRAY = $(BUILD_PREFIX)varray.o\n # currently being compiled, in both source trees, to be examined as well.\n # libintl.h will be found in ../intl if we are using the included libintl.\n INCLUDES = -I. -I$(@D) -I$(srcdir) -I$(srcdir)/$(@D) \\\n-\t   -I$(srcdir)/../include @INCINTL@\n+\t   -I$(srcdir)/../include @INCINTL@ \\\n+\t   $(BANSHEEINC) $(GMPINC)\n \n .c.o:\n \t$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) $< $(OUTPUT_OPTION)\n@@ -838,14 +858,23 @@ CXX_TARGET_OBJS=@cxx_target_objs@\n C_AND_OBJC_OBJS = attribs.o c-errors.o c-lex.o c-pragma.o c-decl.o c-typeck.o \\\n   c-convert.o c-aux-info.o c-common.o c-opts.o c-format.o c-semantics.o \\\n   c-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n-  c-objc-common.o c-dump.o c-pch.o $(C_TARGET_OBJS)\n+  c-objc-common.o c-dump.o c-pch.o $(C_TARGET_OBJS) \\\n+  c-simplify.o tree-mudflap.o c-mudflap.o c-pretty-print.o\n \n # Language-specific object files for C.\n-C_OBJS = c-parse.o c-lang.o c-pretty-print.o stub-objc.o $(C_AND_OBJC_OBJS)\n+C_OBJS = c-parse.o c-lang.o stub-objc.o $(C_AND_OBJC_OBJS)\n \n # Language-independent object files.\n \n OBJS-common = \\\n+ tree-cfg.o tree-dfa.o tree-eh.o tree-ssa.o tree-optimize.o tree-simple.o  \\\n+ tree-alias-type.o gimplify.o tree-pretty-print.o tree-into-ssa.o          \\\n+ tree-outof-ssa.o tree-alias-common.o tree-ssa-ccp.o\t\t\t   \\\n+ @ANDER@ tree-ssa-dce.o  tree-ssa-copy.o tree-nrv.o tree-ssa-copyrename.o  \\\n+ tree-ssa-pre.o tree-ssa-live.o tree-ssa-operands.o tree-ssa-alias.o       \\\n+ tree-ssa-phiopt.o tree-ssa-forwprop.o tree-nested.o tree-ssa-dse.o\t   \\\n+ tree-ssa-dom.o domwalk.o tree-tailcall.o gimple-low.o tree-iterator.o\t   \\\n+ tree-phinodes.o tree-ssanames.o tree-sra.o tree-complex.o tree-ssa-loop.o \\\n  alias.o bb-reorder.o bitmap.o builtins.o caller-save.o calls.o\t  \t   \\\n  cfg.o cfganal.o cfgbuild.o cfgcleanup.o cfglayout.o cfgloop.o\t\t   \\\n  cfgloopanal.o cfgloopmanip.o loop-init.o loop-unswitch.o loop-unroll.o\t   \\\n@@ -863,14 +892,15 @@ OBJS-common = \\\n  real.o recog.o reg-stack.o regclass.o regmove.o regrename.o\t\t   \\\n  reload.o reload1.o reorg.o resource.o rtl.o rtlanal.o rtl-error.o\t   \\\n  sbitmap.o sched-deps.o sched-ebb.o sched-rgn.o sched-vis.o sdbout.o\t   \\\n- sibcall.o simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o \t   \\\n+ simplify-rtx.o sreal.o stmt.o stor-layout.o stringpool.o \t \t  \\\n  targhooks.o timevar.o toplev.o tracer.o tree.o tree-dump.o unroll.o\t   \\\n  varasm.o varray.o version.o vmsdbgout.o xcoffout.o alloc-pool.o\t   \\\n- et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\n+ et-forest.o cfghooks.o bt-load.o pretty-print.o $(GGC) web.o passes.o\t   \\\n+ rtl-profile.o tree-profile.o\n \n OBJS-md = $(out_object_file)\n OBJS-archive = $(EXTRA_OBJS) $(host_hook_obj) hashtable.o tree-inline.o\t   \\\n-  tree-optimize.o cgraph.o cgraphunit.o\n+  cgraph.o cgraphunit.o tree-nomudflap.o\n \n OBJS = $(OBJS-common) $(out_object_file) $(OBJS-archive)\n \n@@ -1125,9 +1155,9 @@ $(SPECS): xgcc$(exeext)\n gcc-cross: xgcc$(exeext)\n \tcp xgcc$(exeext) gcc-cross$(exeext)\n \n-cc1$(exeext): $(C_OBJS) $(BACKEND) $(LIBDEPS)\n+cc1$(exeext): $(C_OBJS) $(BACKEND) $(LIBDEPS) @TREEBROWSER@\n \t$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o cc1$(exeext) \\\n-\t\t$(C_OBJS) $(BACKEND) $(LIBS)\n+\t\t$(C_OBJS) @TREEBROWSER@ $(BACKEND) $(LIBS)\n \n # Build the version of limits.h that we will install.\n xlimits.h: glimits.h limitx.h limity.h\n@@ -1308,7 +1338,7 @@ c-decl.o : c-decl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n     $(RTL_H) $(C_TREE_H) $(GGC_H) $(TARGET_H) flags.h function.h output.h \\\n     $(EXPR_H) debug.h toplev.h intl.h $(TM_P_H) tree-inline.h $(TIMEVAR_H) \\\n     opts.h c-pragma.h gt-c-decl.h cgraph.h $(HASHTAB_H) libfuncs.h except.h \\\n-    $(LANGHOOKS_DEF_H)\n+    $(LANGHOOKS_DEF_H) $(TREE_DUMP_H)\n c-typeck.o : c-typeck.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(C_TREE_H) \\\n     $(TARGET_H) flags.h intl.h output.h $(EXPR_H) $(RTL_H) toplev.h $(TM_P_H) \\\n     langhooks.h\n@@ -1361,9 +1391,10 @@ c-common.o : c-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n \t$(OBSTACK_H) $(C_COMMON_H) flags.h toplev.h output.h c-pragma.h intl.h \\\n \t$(GGC_H) $(EXPR_H) $(TM_P_H) builtin-types.def builtin-attrs.def \\\n \t$(DIAGNOSTIC_H) gt-c-common.h langhooks.h varray.h $(RTL_H) \\\n-\t$(TARGET_H) $(C_TREE_H) langhooks.h\n+\t$(TARGET_H) $(C_TREE_H) tree-iterator.h langhooks.h\n c-pretty-print.o : c-pretty-print.c $(C_PRETTY_PRINT_H) \\\n-\t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h\n+\t$(C_COMMON_H) $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) real.h \\\n+\t$(DIAGNOSTIC_H)\n \n c-opts.o : c-opts.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H)\t\t\\\n         $(TREE_H) c-pragma.h flags.h toplev.h langhooks.h\t\t\\\n@@ -1390,7 +1421,7 @@ c-semantics.o : c-semantics.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE\n \t$(EXPR_H) $(PREDICT_H) tree-inline.h\n \n c-dump.o : c-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n-\t$(C_TREE_H) tree-dump.h\n+\t$(C_TREE_H) $(TREE_DUMP_H)\n \n c-pch.o : c-pch.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(CPPLIB_H) $(TREE_H) \\\n \t$(C_COMMON_H) output.h toplev.h c-pragma.h $(GGC_H) debug.h \\\n@@ -1476,7 +1507,7 @@ version.o: version.c version.h\n gtype-desc.o: gtype-desc.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) varray.h \\\n \t$(HASHTAB_H) $(TREE_H) $(RTL_H) function.h insn-config.h $(EXPR_H) $(OPTABS_H) \\\n \tlibfuncs.h debug.h $(GGC_H) bitmap.h $(BASIC_BLOCK_H) hard-reg-set.h \\\n-\tcselib.h insn-addr.h\n+\tcselib.h insn-addr.h $(TREE_FLOW_H)\n \n ggc-common.o: ggc-common.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(GGC_H) \\\n \t$(HASHTAB_H) toplev.h $(PARAMS_H) hosthooks.h\n@@ -1506,22 +1537,149 @@ langhooks.o : langhooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H)\n    $(LANGHOOKS_DEF_H) flags.h $(GGC_H) gt-langhooks.h diagnostic.h\n tree.o : tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) flags.h function.h \\\n    toplev.h $(GGC_H) $(HASHTAB_H) $(TARGET_H) output.h $(TM_P_H) langhooks.h \\\n-   real.h gt-tree.h\n+   real.h gt-tree.h tree-iterator.h $(BASIC_BLOCK_H) $(TREE_FLOW_H)\n tree-dump.o: tree-dump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(C_TREE_H) flags.h langhooks.h toplev.h output.h c-pragma.h $(RTL_H) $(GGC_H) \\\n-   $(EXPR_H) $(SPLAY_TREE_H) tree-dump.h\n+   $(EXPR_H) $(SPLAY_TREE_H) $(TREE_DUMP_H)\n tree-inline.o : tree-inline.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) $(RTL_H) $(EXPR_H) flags.h $(PARAMS_H) input.h insn-config.h \\\n    $(INTEGRATE_H) $(VARRAY_H) $(HASHTAB_H) $(SPLAY_TREE_H) toplev.h \\\n-   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h function.h\n-tree-optimize.o : tree-optimize.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n-   $(TREE_H) toplev.h langhooks.h cgraph.h $(TIMEVAR_H) function.h $(GGC_H)\n-\n+   langhooks.h $(C_COMMON_H) tree-inline.h cgraph.h intl.h function.h \\\n+   $(TREE_SIMPLE_H)\n print-tree.o : print-tree.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(GGC_H) langhooks.h real.h\n stor-layout.o : stor-layout.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(RTL_H) toplev.h $(GGC_H) $(TM_P_H) $(TARGET_H) \\\n    langhooks.h\n+tree-alias-type.o: tree-alias-type.c tree-alias-type.h $(SYSTEM_H) $(CONFIG_H) \\\n+   $(GGC_H) $(TM_H) coretypes.h $(VARRAY_H)\n+tree-alias-ander.o: tree-alias-ander.c tree-alias-ander.h $(SYSTEM_H) \\\n+   $(CONFIG_H) $(GGC_H) $(TREE_H) $(TREE_FLOW_H) tree-alias-common.h \\\n+   $(TM_H) coretypes.h cgraph.h tree-pass.h\n+tree-alias-common.o: tree-alias-common.c tree-alias-common.h $(SYSTEM_H) \\\n+   $(CONFIG_H) $(GGC_H) $(TREE_H) gt-tree-alias-common.h $(TREE_FLOW_H) \\\n+   $(TM_H) coretypes.h cgraph.h tree-pass.h $(TIMEVAR_H)\n+tree-ssa.o : tree-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h cfgloop.h \\\n+   tree-pass.h\n+tree-into-ssa.o : tree-into-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h tree-pass.h\n+tree-outof-ssa.o : tree-outof-ssa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) output.h diagnostic.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) langhooks.h domwalk.h \\\n+   tree-pass.h tree-ssa-live.h\n+tree-ssa-dse.o : tree-ssa-dse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) domwalk.h flags.h\n+tree-ssa-forwprop.o : tree-ssa-forwprop.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H)\n+tree-ssa-phiopt.o : tree-ssa-phiopt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) errors.h $(GGC_H) $(TREE_H) $(RTL_H) $(TM_P_H) $(BASIC_BLOCK_H) \\\n+   $(TREE_FLOW_H) tree-pass.h $(TREE_DUMP_H) langhooks.h\n+tree-nrv.o : tree-nrv.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) $(RTL_H) function.h $(BASIC_BLOCK_H) $(EXPR_H) \\\n+   diagnostic.h $(TREE_FLOW_H) $(TIMEVAR_H) $(TREE_DUMP_H) tree-pass.h \\\n+   langhooks.h\n+tree-ssa-copy.o : tree-ssa-copy.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n+   errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(BASIC_BLOCK_H) tree-pass.h langhooks.h\n+tree-ssa-dom.o : tree-ssa-dom.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n+   errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   $(BASIC_BLOCK_H) domwalk.h real.h tree-pass.h flags.h langhooks.h\n+tree-ssanames.o : tree-ssanames.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) varray.h $(GGC_H) gt-tree-ssanames.h \n+tree-phinodes.o : tree-phinodes.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(TREE_H) varray.h $(GGC_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) \\\n+   gt-tree-phinodes.h $(RTL_H)\n+domwalk.o : domwalk.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n+   $(TREE_H) $(BASIC_BLOCK_H) $(TREE_FLOW_H) domwalk.h $(GGC_H)\n+tree-ssa-live.o : tree-ssa-live.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n+   errors.h toplev.h function.h $(TIMEVAR_H) tree-alias-common.h \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-ssa-live.h\n+tree-ssa-copyrename.o : tree-ssa-copyrename.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h \\\n+   diagnostic.h errors.h toplev.h function.h $(TIMEVAR_H) tree-pass.h \\\n+   tree-alias-common.h $(TM_H) coretypes.h $(TREE_DUMP_H) tree-ssa-live.h\n+tree-ssa-pre.o : tree-ssa-pre.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n+   $(GGC_H) output.h diagnostic.h errors.h toplev.h $(TIMEVAR_H) \\\n+   $(TM_H) coretypes.h $(TREE_DUMP_H) tree-pass.h flags.h\n+tree-cfg.o : tree-cfg.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) flags.h output.h \\\n+   diagnostic.h errors.h function.h $(TIMEVAR_H) $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) except.h langhooks.h cfgloop.h gt-tree-cfg.h tree-pass.h\n+tree-tailcall.o : tree-tailcall.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) function.h $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) diagnostic.h except.h tree-pass.h flags.h langhooks.h\n+tree-nested.o: tree-nested.c $(CONFIG_H) $(SYSTEM_H) $(TM_H) $(TREE_H) \\\n+   $(RTL_H) $(TM_P_H) function.h tree-dump.h tree-inline.h tree-iterator.h \\\n+   tree-simple.h cgraph.h $(EXPR_H) langhooks.h $(GGC_H) gt-tree-nested.h\n+tree-iterator.o : tree-iterator.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) \\\n+   coretypes.h $(GGC_H) tree-iterator.h tree-simple.h gt-tree-iterator.h\n+tree-dfa.o : tree-dfa.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) output.h diagnostic.h \\\n+   errors.h tree-inline.h $(HASHTAB_H) flags.h function.h $(TIMEVAR_H) \\\n+   tree-alias-common.h convert.h $(TM_H) coretypes.h langhooks.h \\\n+   $(TREE_DUMP_H) tree-pass.h params.h\n+tree-ssa-operands.o : tree-ssa-operands.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(GGC_H) diagnostic.h \\\n+   tree-inline.h flags.h function.h $(TM_H) $(TIMEVAR_H) tree-pass.h\n+tree-eh.o : tree-eh.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_H) flags.h function.h except.h langhooks.h \\\n+   $(GGC_H) tree-pass.h gt-tree-eh.h\n+tree-ssa-loop.o : tree-ssa-loop.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) cfgloop.h \\\n+   output.h diagnostic.h $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) \\\n+   tree-pass.h flags.h tree-inline.h\n+tree-ssa-alias.o : tree-ssa-alias.c $(TREE_FLOW_H) $(CONFIG_H) $(SYSTEM_H) \\\n+   $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) $(GGC_H) tree-inline.h flags.h \\\n+   function.h $(TIMEVAR_H) tree-alias-common.h convert.h $(TM_H) coretypes.h \\\n+   langhooks.h $(TREE_DUMP_H) tree-pass.h params.h\n+tree-optimize.o : tree-optimize.c $(TREE_FLOW_H) $(CONFIG_H) \\\n+   $(SYSTEM_H) $(RTL_H) $(TREE_H) $(TM_P_H) $(EXPR_H) \\\n+   $(GGC_H) output.h diagnostic.h errors.h flags.h tree-alias-common.h \\\n+   $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) toplev.h function.h \\\n+   langhooks.h flags.h cgraph.h tree-inline.h tree-mudflap.h $(GGC_H) \\\n+   cgraph.h tree-pass.h\n+c-simplify.o : c-simplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n+   $(C_TREE_H) $(C_COMMON_H) diagnostic.h $(TREE_SIMPLE_H) varray.h flags.h \\\n+   langhooks.h toplev.h rtl.h $(TREE_FLOW_H) langhooks-def.h \\\n+   $(TM_H) coretypes.h $(C_PRETTY_PRINT_H) cgraph.h\n+gimplify.o : gimplify.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n+   diagnostic.h $(TREE_SIMPLE_H) tree-inline.h varray.h langhooks.h \\\n+   langhooks-def.h $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h except.h \\\n+   flags.h $(RTL_H) function.h $(EXPR_H) output.h $(GGC_H) gt-gimplify.h\n+gimple-low.o : gimple-low.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) errors.h \\\n+   diagnostic.h $(TREE_SIMPLE_H) tree-inline.h varray.h langhooks.h \\\n+   langhooks-def.h $(TREE_FLOW_H) $(TIMEVAR_H) $(TM_H) coretypes.h except.h \\\n+   flags.h $(RTL_H) function.h tree-pass.h\n+tree-browser.o : tree-browser.c tree-browser.def $(CONFIG_H) $(SYSTEM_H) \\\n+   $(TREE_H) errors.h tree-inline.h diagnostic.h $(HASHTAB_H) \\\n+   $(TM_H) coretypes.h\n+tree-simple.o : tree-simple.c $(CONFIG_H) $(SYSTEM_H) $(TREE_H) $(EXPR_H) \\\n+\t$(RTL_H) $(TREE_SIMPLE_H) $(TM_H) coretypes.h bitmap.h $(GGC_H)\n+tree-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n+   $(C_TREE_H) $(C_COMMON_H) $(TREE_SIMPLE_H) diagnostic.h $(HASHTAB_H) \\\n+   output.h varray.h langhooks.h tree-mudflap.h $(TM_H) coretypes.h \\\n+   $(TREE_DUMP_H) tree-pass.h\n+c-mudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n+   $(C_TREE_H) $(C_COMMON_H) $(TREE_SIMPLE_H) diagnostic.h $(HASHTAB_H) \\\n+   output.h varray.h langhooks.h tree-mudflap.h $(TM_H) coretypes.h\n+tree-nomudflap.o : $(CONFIG_H) errors.h $(SYSTEM_H) $(TREE_H) tree-inline.h \\\n+   $(C_TREE_H) $(C_COMMON_H) $(TREE_SIMPLE_H) diagnostic.h $(HASHTAB_H) \\\n+   output.h varray.h langhooks.h tree-mudflap.h $(TM_H) coretypes.h\n+tree-pretty-print.o : tree-pretty-print.c $(CONFIG_H) $(SYSTEM_H) \\\n+   errors.h $(TREE_H) diagnostic.h real.h $(HASHTAB_H) $(TREE_FLOW_H) \\\n+   $(TM_H) coretypes.h tree-iterator.h\n fold-const.o : fold-const.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) \\\n    $(TREE_H) flags.h real.h toplev.h $(HASHTAB_H) $(EXPR_H) $(RTL_H) $(GGC_H) \\\n    $(TM_P_H) langhooks.h $(MD5_H)\n@@ -1584,7 +1742,7 @@ varasm.o : varasm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) $(RTL_\n function.o : function.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) libfuncs.h $(REGS_H) hard-reg-set.h \\\n    insn-config.h $(RECOG_H) output.h toplev.h except.h $(HASHTAB_H) $(GGC_H) \\\n-   $(TM_P_H) langhooks.h gt-function.h $(TARGET_H)\n+   $(TM_P_H) langhooks.h gt-function.h $(TARGET_H) basic-block.h\n stmt.o : stmt.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h insn-config.h hard-reg-set.h $(EXPR_H) libfuncs.h except.h \\\n    $(LOOP_H) $(RECOG_H) toplev.h output.h varray.h $(GGC_H) $(TM_P_H) \\\n@@ -1597,7 +1755,8 @@ except.o : except.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n expr.o : expr.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) flags.h \\\n    function.h $(REGS_H) $(EXPR_H) $(OPTABS_H) libfuncs.h $(INSN_ATTR_H) insn-config.h \\\n    $(RECOG_H) output.h typeclass.h hard-reg-set.h toplev.h hard-reg-set.h \\\n-   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H)\n+   except.h reload.h $(GGC_H) langhooks.h intl.h $(TM_P_H) real.h $(TARGET_H) \\\n+   tree-iterator.h\n dojump.o : dojump.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h function.h $(EXPR_H) $(OPTABS_H) $(INSN_ATTR_H) insn-config.h \\\n    langhooks.h $(GGC_H) gt-dojump.h\n@@ -1680,14 +1839,26 @@ gcse.o : gcse.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(GGC_H) $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) function.h output.h toplev.h $(TM_P_H) $(PARAMS_H) \\\n    except.h gt-gcse.h $(TREE_H) cselib.h\n-sibcall.o : sibcall.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n-   function.h hard-reg-set.h flags.h insn-config.h $(RECOG_H) $(BASIC_BLOCK_H)\n resource.o : resource.c $(CONFIG_H) $(RTL_H) hard-reg-set.h $(SYSTEM_H) coretypes.h \\\n    $(TM_H) $(BASIC_BLOCK_H) $(REGS_H) flags.h output.h resource.h function.h toplev.h \\\n    $(INSN_ATTR_H) except.h $(PARAMS_H) $(TM_P_H)\n lcm.o : lcm.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(REGS_H) \\\n    hard-reg-set.h flags.h real.h insn-config.h $(INSN_ATTR_H) $(RECOG_H) $(EXPR_H) \\\n    $(BASIC_BLOCK_H) $(TM_P_H) df.h function.h\n+tree-ssa-dce.o : tree-ssa-dce.c $(CONFIG_H) system.h errors.h $(TREE_H) \\\n+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) diagnostic.h $(TIMEVAR_H) $(TM_H) \\\n+    coretypes.h $(TREE_DUMP_H) tree-pass.h flags.h\n+tree-ssa-ccp.o : tree-ssa-ccp.c $(CONFIG_H) system.h errors.h $(TREE_H) \\\n+    $(RTL_H) $(TM_P_H) $(TREE_FLOW_H) diagnostic.h tree-inline.h \\\n+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SIMPLE_H) \\\n+    $(EXPR_H) tree-pass.h flags.h langhooks.h\n+tree-sra.o : tree-sra.c $(CONFIG_H) system.h errors.h $(TREE_H) $(RTL_H) \\\n+    $(TM_P_H) $(TREE_FLOW_H) diagnostic.h tree-inline.h \\\n+    $(TIMEVAR_H) $(TM_H) coretypes.h $(TREE_DUMP_H) $(TREE_SIMPLE_H) \\\n+    langhooks.h tree-pass.h flags.h\n+tree-complex.o : tree-complex.c $(CONFIG_H) system.h $(TREE_H) \\\n+    $(TM_H) $(TREE_FLOW_H) $(TREE_SIMPLE_H) tree-iterator.h tree-pass.h \\\n+    flags.h\n df.o : df.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    insn-config.h $(RECOG_H) function.h $(REGS_H) alloc-pool.h hard-reg-set.h \\\n    $(BASIC_BLOCK_H) df.h $(FIBHEAP_H)\n@@ -1698,7 +1869,14 @@ conflict.o : conflict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(OBSTACK_H)\n    $(HASHTAB_H) $(RTL_H) hard-reg-set.h $(BASIC_BLOCK_H)\n profile.o : profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n-   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h\n+tree-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_H) value-prof.h \\\n+   tree-pass.h $(TREE_FLOW_H) $(TIMEVAR_H)\n+rtl-profile.o : tree-profile.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n+   $(TM_H) $(RTL_H) $(TREE_H) flags.h output.h $(REGS_H) $(EXPR_H) function.h \\\n+   toplev.h $(BASIC_BLOCK_H) $(COVERAGE_H) $(TREE_FLOW_H) value-prof.h\n value-prof.o : value-prof.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) \\\n    $(BASIC_BLOCK_H) hard-reg-set.h value-prof.h $(EXPR_H) output.h flags.h \\\n    $(RECOG_H) insn-config.h $(OPTABS_H) $(REGS_H)\n@@ -1719,9 +1897,9 @@ flow.o : flow.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(RECOG_H) function.h except.h $(EXPR_H) $(GGC_H) $(TM_P_H)\n cfg.o : cfg.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h insn-config.h \\\n    $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n-   function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h\n+   function.h except.h $(GGC_H) $(TM_P_H) alloc-pool.h $(TIMEVAR_H) \n cfghooks.o: cfghooks.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n-   $(BASIC_BLOCK_H) cfglayout.h $(TIMEVAR_H) toplev.h\n+   $(BASIC_BLOCK_H) cfglayout.h $(TREE_FLOW_H) $(TIMEVAR_H) toplev.h\n cfgrtl.o : cfgrtl.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) flags.h \\\n    insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h $(RECOG_H) \\\n    function.h except.h $(GGC_H) $(TM_P_H) insn-config.h $(EXPR_H)\n@@ -1837,7 +2015,7 @@ recog.o : recog.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) function.\n    $(INSN_ATTR_H) real.h toplev.h output.h reload.h $(TM_P_H)\n reg-stack.o : reg-stack.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    $(RECOG_H) $(REGS_H) hard-reg-set.h flags.h insn-config.h toplev.h reload.h \\\n-   varray.h function.h $(TM_P_H) $(GGC_H) gt-reg-stack.h\n+   varray.h function.h $(TM_P_H) $(GGC_H) gt-reg-stack.h basic-block.h\n sreal.o: sreal.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) sreal.h\n predict.o: predict.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(RTL_H) $(TREE_H) \\\n    flags.h insn-config.h $(BASIC_BLOCK_H) $(REGS_H) hard-reg-set.h output.h toplev.h \\\n@@ -2085,7 +2263,7 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(host_xm_file_list) $(tm_file_list) $(HASHTAB_H) $(SPLAY_TREE_H) \\\n   $(srcdir)/bitmap.h $(srcdir)/coverage.c $(srcdir)/function.h  $(srcdir)/rtl.h \\\n   $(srcdir)/optabs.h $(srcdir)/tree.h $(srcdir)/libfuncs.h $(srcdir)/hashtable.h \\\n-  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h \\\n+  $(srcdir)/real.h $(srcdir)/varray.h $(srcdir)/insn-addr.h $(srcdir)/hwint.h \\\n   $(srcdir)/cselib.h $(srcdir)/basic-block.h  $(srcdir)/cgraph.h \\\n   $(srcdir)/c-common.h $(srcdir)/c-tree.h \\\n   $(srcdir)/alias.c $(srcdir)/bitmap.c $(srcdir)/cselib.c $(srcdir)/cgraph.c \\\n@@ -2098,6 +2276,16 @@ GTFILES = $(srcdir)/input.h $(srcdir)/coretypes.h $(srcdir)/cpplib.h \\\n   $(srcdir)/reg-stack.c $(srcdir)/cfglayout.c $(srcdir)/langhooks.c \\\n   $(srcdir)/sdbout.c $(srcdir)/stmt.c $(srcdir)/stor-layout.c \\\n   $(srcdir)/stringpool.c $(srcdir)/tree.c $(srcdir)/varasm.c \\\n+  $(srcdir)/tree-mudflap.c $(srcdir)/tree-flow.h \\\n+  $(srcdir)/c-objc-common.c $(srcdir)/c-common.c $(srcdir)/c-parse.in \\\n+  $(srcdir)/tree-ssanames.c $(srcdir)/tree-eh.c \\\n+  $(srcdir)/tree-phinodes.c $(srcdir)/tree-cfg.c \\\n+  $(srcdir)/tree-dfa.c $(srcdir)/tree-ssa-ccp.c \\\n+  $(srcdir)/tree-iterator.c $(srcdir)/gimplify.c \\\n+  $(srcdir)/tree-alias-type.h $(srcdir)/tree-alias-common.h \\\n+  $(srcdir)/tree-alias-type.c $(srcdir)/tree-alias-common.c \\\n+  $(srcdir)/tree-ssa-operands.h $(srcdir)/tree-ssa-operands.c \\\n+  $(srcdir)/tree-profile.c $(srcdir)/rtl-profile.c $(srcdir)/tree-nested.c \\\n   $(out_file) \\\n   @all_gtfiles@\n \n@@ -2114,6 +2302,10 @@ gt-expr.h gt-sdbout.h gt-optabs.h gt-bitmap.h gt-dojump.h \\\n gt-dwarf2out.h gt-ra-build.h gt-reg-stack.h gt-dwarf2asm.h \\\n gt-dbxout.h gt-c-common.h gt-c-decl.h gt-c-parse.h \\\n gt-c-pragma.h gtype-c.h gt-input.h gt-cfglayout.h \\\n+gt-tree-alias-common.h gt-tree-mudflap.h \\\n+gt-tree-ssa-ccp.h gt-tree-eh.h \\\n+gt-tree-ssanames.h gt-tree-iterator.h gt-gimplify.h \\\n+gt-tree-phinodes.h gt-tree-cfg.h gt-tree-nested.h \\\n gt-stringpool.h gt-langhooks.h : s-gtype ; @true\n \n gtyp-gen.h: s-gtyp-gen ; @true\n@@ -2670,7 +2862,7 @@ TEXI_GCCINT_FILES = gccint.texi gcc-common.texi contribute.texi makefile.texi \\\n \t c-tree.texi rtl.texi md.texi tm.texi hostconfig.texi fragments.texi \\\n \t configfiles.texi collect2.texi headerdirs.texi funding.texi gnu.texi \\\n \t gpl.texi fdl.texi contrib.texi languages.texi sourcebuild.texi \\\n-\t gty.texi libgcc.texi\n+\t gty.texi libgcc.texi cfg.texi tree-ssa.texi\n \n TEXI_GCCINSTALL_FILES = install.texi install-old.texi fdl.texi\n "}, {"sha": "3a057fab8f5cd9d993cb1ddca0fe5a600e564474", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1,3 +1,12 @@\n+2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-ssa-20020619-branch.\n+\n+\t* config-lang.in (boot_language, build_by_default): Set\n+\tto no.\n+\t* utils.c (unchecked_convert): Use OEP_ONLY_CONST.\n+\t(max_size): Add static chain op for call_expr.\n+\n 2004-05-12  Richard Sandiford  <rsandifo@redhat.com>\n \n \tPR target/15331"}, {"sha": "73524e5492bbdd7527aa9868f955ee0159b855b6", "filename": "gcc/ada/ChangeLog.tree-ssa", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,29 @@\n+2004-05-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* utils.c (unchecked_convert): Use OEP_ONLY_CONST.\n+\n+2004-03-25  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* config-lang.in: Disable Ada by default.\n+\n+2004-02-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* utils.c (max_size): Add static chain op for call_expr.\n+\n+2003-09-25  Jason Merrill  <jason@redhat.com>\n+\n+\t* trans.c, utils.c: Revert 2003-01-15 change.\n+\n+2003-01-15  Jeff Law <law@redhat.com>\n+\n+\t* trans.c (tree_transform): Use annotate_with_file_line to add\n+\tfile/line information to nodes.\n+\t(build_unit_elab): Use TREE_FILENAME and TREE_LINENO to \n+\tretrieve file/line information from a node.\n+\t* utils.c (create_label_decl): Use annotate_with_file_line to\n+\tadd file/line information to nodes.\n+\n+Local Variables:\n+mode: change-log\n+change-log-default-name: \"ChangeLog.tree-ssa\"\n+End:"}, {"sha": "eb044afdb81944f29fdab23818b7d71a12b83ec5", "filename": "gcc/ada/config-lang.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fconfig-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -27,7 +27,7 @@\n # stagestuff\t- files to add to $(STAGESTUFF)\n \n language=\"ada\"\n-boot_language=yes\n+boot_language=no\n boot_language_boot_flags='ADAFLAGS=\"$(BOOT_ADAFLAGS)\"'\n \n compilers=\"gnat1\\$(exeext)\"\n@@ -39,3 +39,6 @@ gtfiles=\"\\$(srcdir)/ada/ada-tree.h \\$(srcdir)/ada/gigi.h \\$(srcdir)/ada/decl.c \\\n outputs=ada/Makefile\n \n target_libs=\"target-libada\"\n+\n+# Ada will not work until the front end starts emitting GIMPLE trees.\n+build_by_default=no"}, {"sha": "f84907d383b97222e6c8df81ddba9d6fd0f89ce7", "filename": "gcc/ada/utils.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2Futils.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fada%2Futils.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Futils.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2220,7 +2220,7 @@ max_size (tree exp, int max_p)\n \t\t\t\tmax_size (TREE_OPERAND (exp, 2), max_p)));\n \t  else if (code == CALL_EXPR && TREE_OPERAND (exp, 1) != 0)\n \t    return build (CALL_EXPR, type, TREE_OPERAND (exp, 0),\n-\t\t\t  max_size (TREE_OPERAND (exp, 1), max_p));\n+\t\t\t  max_size (TREE_OPERAND (exp, 1), max_p), NULL);\n \t}\n     }\n \n@@ -3432,7 +3432,8 @@ unchecked_convert (tree type, tree expr, int notrunc_p)\n   /* If the sizes of the types differ and this is an VIEW_CONVERT_EXPR,\n      show no longer constant.  */\n   if (TREE_CODE (expr) == VIEW_CONVERT_EXPR\n-      && ! operand_equal_p (TYPE_SIZE_UNIT (type), TYPE_SIZE_UNIT (etype), 1))\n+      && ! operand_equal_p (TYPE_SIZE_UNIT (type), TYPE_SIZE_UNIT (etype),\n+\t\t\t    OEP_ONLY_CONST))\n     TREE_CONSTANT (expr) = 0;\n \n   return expr;"}, {"sha": "c64b7b0d556844f59be3881419f1adf6d7241e95", "filename": "gcc/basic-block.h", "status": "modified", "additions": 90, "deletions": 32, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbasic-block.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbasic-block.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbasic-block.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -27,9 +27,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"varray.h\"\n #include \"partition.h\"\n #include \"hard-reg-set.h\"\n+#include \"predict.h\"\n \n /* Head of register set linked list.  */\n typedef bitmap_head regset_head;\n+\n /* A pointer to a regset_head.  */\n typedef bitmap regset;\n \n@@ -121,26 +123,34 @@ do {\t\t\t\t\t\t\t\t\t\\\n typedef HOST_WIDEST_INT gcov_type;\n \n /* Control flow edge information.  */\n-typedef struct edge_def {\n+struct edge_def GTY((chain_next (\"%h.pred_next\")))\n+{\n   /* Links through the predecessor and successor lists.  */\n-  struct edge_def *pred_next, *succ_next;\n+  struct edge_def *pred_next;\n+  struct edge_def *succ_next;\n \n   /* The two blocks at the ends of the edge.  */\n-  struct basic_block_def *src, *dest;\n+  struct basic_block_def *src;\n+  struct basic_block_def *dest;\n \n   /* Instructions queued on the edge.  */\n-  rtx insns;\n+  union edge_def_insns {\n+    rtx GTY ((tag (\"0\"))) r;\n+    tree GTY ((tag (\"1\"))) t;\n+  } GTY ((desc (\"ir_type ()\"))) insns;\n \n   /* Auxiliary info specific to a pass.  */\n-  void *aux;\n+  PTR GTY ((skip (\"\"))) aux;\n \n   int flags;\t\t\t/* see EDGE_* below  */\n   int probability;\t\t/* biased by REG_BR_PROB_BASE */\n   gcov_type count;\t\t/* Expected number of executions calculated\n \t\t\t\t   in profile.c  */\n   bool crossing_edge;           /* Crosses between hot and cold sections, when\n \t\t\t\t   we do partitioning.  */\n-} *edge;\n+};\n+\n+typedef struct edge_def *edge;\n \n #define EDGE_FALLTHRU\t\t1\t/* 'Straight line' flow */\n #define EDGE_ABNORMAL\t\t2\t/* Strange flow, like computed\n@@ -155,7 +165,13 @@ typedef struct edge_def {\n #define EDGE_IRREDUCIBLE_LOOP\t128\t/* Part of irreducible loop.  */\n #define EDGE_SIBCALL\t\t256\t/* Edge from sibcall to exit.  */\n #define EDGE_LOOP_EXIT\t\t512\t/* Exit of a loop.  */\n-#define EDGE_ALL_FLAGS\t\t1023\n+#define EDGE_TRUE_VALUE\t\t1024\t/* Edge taken when controlling\n+\t\t\t\t\t   predicate is non zero.  */\n+#define EDGE_FALSE_VALUE\t2048\t/* Edge taken when controlling\n+\t\t\t\t\t   predicate is zero.  */\n+#define EDGE_EXECUTABLE\t\t4096\t/* Edge is executable.  Only\n+\t\t\t\t\t   valid during SSA-CCP.  */\n+#define EDGE_ALL_FLAGS\t\t8191\n \n #define EDGE_COMPLEX\t(EDGE_ABNORMAL | EDGE_ABNORMAL_CALL | EDGE_EH)\n \n@@ -167,6 +183,9 @@ extern const struct gcov_ctr_summary *profile_info;\n struct loop;\n struct loops;\n \n+/* Declared in tree-flow.h.  */\n+struct bb_ann_d;\n+\n /* A basic block is a sequence of instructions with only entry and\n    only one exit.  If any one of the instructions are executed, they\n    will all be executed, and in sequence from first to last.\n@@ -193,51 +212,54 @@ struct loops;\n    basic blocks.  */\n \n /* Basic block information indexed by block number.  */\n-typedef struct basic_block_def {\n+struct basic_block_def GTY((chain_next (\"%h.next_bb\"), chain_prev (\"%h.prev_bb\")))\n+{\n   /* The first and last insns of the block.  */\n-  rtx head_, end_;\n+  rtx head_;\n+  rtx end_;\n \n-  /* The first and last trees of the block.  */\n-  tree head_tree;\n-  tree end_tree;\n+  /* Pointers to the first and last trees of the block.  */\n+  tree stmt_list;\n \n   /* The edges into and out of the block.  */\n-  edge pred, succ;\n+  edge pred;\n+  edge succ;\n \n   /* Liveness info.  */\n \n   /* The registers that are modified within this in block.  */\n-  regset local_set;\n+  bitmap GTY ((skip (\"\"))) local_set;\n   /* The registers that are conditionally modified within this block.\n      In other words, registers that are set only as part of a\n      COND_EXEC.  */\n-  regset cond_local_set;\n+  bitmap GTY ((skip (\"\"))) cond_local_set;\n   /* The registers that are live on entry to this block.\n \n      Note that in SSA form, global_live_at_start does not reflect the\n      use of regs in phi functions, since the liveness of these regs\n      may depend on which edge was taken into the block.  */\n-  regset global_live_at_start;\n+  bitmap GTY ((skip (\"\"))) global_live_at_start;\n   /* The registers that are live on exit from this block.  */\n-  regset global_live_at_end;\n+  bitmap GTY ((skip (\"\"))) global_live_at_end;\n \n   /* Auxiliary info specific to a pass.  */\n-  void *aux;\n+  PTR GTY ((skip (\"\"))) aux;\n \n   /* The index of this block.  */\n   int index;\n \n   /* Previous and next blocks in the chain.  */\n-  struct basic_block_def *prev_bb, *next_bb;\n+  struct basic_block_def *prev_bb;\n+  struct basic_block_def *next_bb;\n \n   /* The loop depth of this block.  */\n   int loop_depth;\n \n-  /* Outermost loop containing the block.  */\n-  struct loop *loop_father;\n+  /* Innermost loop containing the block.  */\n+  struct loop * GTY ((skip (\"\"))) loop_father;\n \n   /* The dominance and postdominance information node.  */\n-  struct et_node *dom[2];\n+  struct et_node * GTY ((skip (\"\"))) dom[2];\n \n   /* Expected number of executions: calculated in profile.c.  */\n   gcov_type count;\n@@ -251,9 +273,31 @@ typedef struct basic_block_def {\n   /* Which section block belongs in, when partitioning basic blocks.  */\n   int partition;\n \n-  /* Additional data maintained by cfg_layout routines.  */\n-  struct reorder_block_def *rbi;\n-} *basic_block;\n+  /* The data used by basic block copying and reordering functions.  */\n+  struct reorder_block_def * GTY ((skip (\"\"))) rbi;\n+\n+  /* Annotations used at the tree level.  */\n+  struct bb_ann_d *tree_annotations;\n+};\n+\n+typedef struct basic_block_def *basic_block;\n+\n+/* Structure to hold information about the blocks during reordering and\n+   copying.  */\n+\n+typedef struct reorder_block_def\n+{\n+  rtx header;\n+  rtx footer;\n+  basic_block next;\n+  basic_block original;\n+  /* Used by loop copying.  */\n+  basic_block copy;\n+  int duplicated;\n+\n+  /* These fields are used by bb-reorder pass.  */\n+  int visited;\n+} *reorder_block_def;\n \n #define BB_FREQ_MAX 10000\n \n@@ -285,7 +329,7 @@ extern int n_edges;\n \n /* Index by basic block number, get basic block struct info.  */\n \n-extern varray_type basic_block_info;\n+extern GTY(()) varray_type basic_block_info;\n \n #define BASIC_BLOCK(N)  (VARRAY_BB (basic_block_info, (N)))\n \n@@ -352,9 +396,8 @@ extern struct obstack flow_obstack;\n #define INVALID_BLOCK (-3)\n \n /* Similarly, block pointers for the edge list.  */\n-extern struct basic_block_def entry_exit_blocks[2];\n-#define ENTRY_BLOCK_PTR\t(&entry_exit_blocks[0])\n-#define EXIT_BLOCK_PTR\t(&entry_exit_blocks[1])\n+extern GTY(()) basic_block ENTRY_BLOCK_PTR;\n+extern GTY(()) basic_block EXIT_BLOCK_PTR;\n \n #define BLOCK_NUM(INSN)\t      (BLOCK_FOR_INSN (INSN)->index + 0)\n #define set_block_for_insn(INSN, BB)  (BLOCK_FOR_INSN (INSN) = BB)\n@@ -374,7 +417,6 @@ extern void commit_edge_insertions_watch_calls (void);\n extern void remove_fake_edges (void);\n extern void add_noreturn_fake_exit_edges (void);\n extern void connect_infinite_loops_to_exit (void);\n-extern int flow_call_edges_add (sbitmap);\n extern edge unchecked_make_edge (basic_block, basic_block, int);\n extern edge cached_make_edge (sbitmap *, basic_block, basic_block, int);\n extern edge make_edge (basic_block, basic_block, int);\n@@ -392,6 +434,7 @@ extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(basic_block, void *),\n \t\t\t       basic_block *, int, void *);\n extern void dump_edge_info (FILE *, edge, int);\n+extern void brief_dump_cfg (FILE *);\n extern void clear_edges (void);\n extern void mark_critical_edges (void);\n extern rtx first_insn_after_basic_block_note (basic_block);\n@@ -472,6 +515,7 @@ void free_edge_list (struct edge_list *);\n void print_edge_list (FILE *, struct edge_list *);\n void verify_edge_list (FILE *, struct edge_list *);\n int find_edge_index (struct edge_list *, basic_block, basic_block);\n+edge find_edge (basic_block, basic_block);\n \n \n enum update_life_extent\n@@ -554,6 +598,11 @@ extern void expected_value_to_br_prob (void);\n extern bool maybe_hot_bb_p (basic_block);\n extern bool probably_cold_bb_p (basic_block);\n extern bool probably_never_executed_bb_p (basic_block);\n+extern bool tree_predicted_by_p (basic_block, enum br_predictor);\n+extern bool rtl_predicted_by_p (basic_block, enum br_predictor);\n+extern void tree_predict_edge (edge, enum br_predictor, int);\n+extern void rtl_predict_edge (edge, enum br_predictor, int);\n+extern void predict_edge_def (edge, enum br_predictor, enum prediction);\n \n /* In flow.c */\n extern void init_flow (void);\n@@ -577,7 +626,7 @@ extern bool purge_all_dead_edges (int);\n extern bool purge_dead_edges (basic_block);\n extern void find_sub_basic_blocks (basic_block);\n extern void find_many_sub_basic_blocks (sbitmap);\n-extern void make_eh_edge (sbitmap *, basic_block, rtx);\n+extern void rtl_make_eh_edge (sbitmap *, basic_block, rtx);\n extern bool can_fallthru (basic_block, basic_block);\n extern void flow_nodes_print (const char *, const sbitmap, FILE *);\n extern void flow_edge_list_print (const char *, const edge *, int, FILE *);\n@@ -589,6 +638,10 @@ extern void alloc_aux_for_edge (edge, int);\n extern void alloc_aux_for_edges (int);\n extern void clear_aux_for_edges (void);\n extern void free_aux_for_edges (void);\n+extern void find_basic_blocks (rtx, int, FILE *);\n+extern bool cleanup_cfg (int);\n+extern bool delete_unreachable_blocks (void);\n+extern bool merge_seq_blocks (void);\n \n typedef struct conflict_graph_def *conflict_graph;\n \n@@ -624,6 +677,11 @@ extern bool control_flow_insn_p (rtx);\n extern void reorder_basic_blocks (void);\n extern void partition_hot_cold_basic_blocks (void);\n \n+/* In cfg.c */\n+extern void alloc_rbi_pool (void);\n+extern void initialize_bb_rbi (basic_block bb);\n+extern void free_rbi_pool (void);\n+\n /* In dominance.c */\n \n enum cdi_direction\n@@ -661,7 +719,7 @@ extern void iterate_fix_dominators (enum cdi_direction, basic_block *, int);\n extern void verify_dominators (enum cdi_direction);\n extern basic_block first_dom_son (enum cdi_direction, basic_block);\n extern basic_block next_dom_son (enum cdi_direction, basic_block);\n-extern bool try_redirect_by_replacing_jump (edge, basic_block, bool);\n+extern edge try_redirect_by_replacing_jump (edge, basic_block, bool);\n extern void break_superblocks (void);\n \n #include \"cfghooks.h\""}, {"sha": "c461a160313a7d20e6df6ddd30ee11737ed42f70", "filename": "gcc/bb-reorder.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbb-reorder.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbb-reorder.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbb-reorder.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -749,7 +749,7 @@ copy_bb (basic_block old_bb, edge e, basic_block bb, int trace)\n {\n   basic_block new_bb;\n \n-  new_bb = cfg_layout_duplicate_bb (old_bb, e);\n+  new_bb = duplicate_block (old_bb, e);\n   if (e->dest != new_bb)\n     abort ();\n   if (e->dest->rbi->visited)\n@@ -1177,7 +1177,7 @@ copy_bb_p (basic_block bb, int code_may_grow)\n     return false;\n   if (!bb->pred || !bb->pred->pred_next)\n     return false;\n-  if (!cfg_layout_can_duplicate_bb_p (bb))\n+  if (!can_duplicate_block_p (bb))\n     return false;\n \n   /* Avoid duplicating blocks which have many successors (PR/13430).  */"}, {"sha": "ebbb6ee805ff4d8380b3e33fd5317e291aac6476", "filename": "gcc/bitmap.c", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbitmap.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -414,7 +414,9 @@ bitmap_first_set_bit (bitmap a)\n #else\n   for (word_num = 0; word_num < BITMAP_ELEMENT_WORDS; ++word_num)\n     if ((word = ptr->bits[word_num]) != 0)\n-      break;\n+      goto word_found;\n+  abort ();\n+ word_found:\n #endif\n \n   /* Binary search for the first set bit.  */\n@@ -469,7 +471,9 @@ bitmap_last_set_bit (bitmap a)\n #else\n   for (word_num = BITMAP_ELEMENT_WORDS; word_num-- > 0; )\n     if ((word = ptr->bits[word_num]) != 0)\n-      break;\n+      goto word_found;\n+  abort ();\n+ word_found:\n #endif\n \n   /* Binary search for the last set bit.  */"}, {"sha": "a809a477928c547505ff200edd07f65aac36872c", "filename": "gcc/builtin-types.def", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltin-types.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltin-types.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltin-types.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -227,6 +227,7 @@ DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_DOUBLE_COMPLEX_DOUBLE_COMPLEX_DOUBLE,\n \t\t     BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE, BT_COMPLEX_DOUBLE)\n DEF_FUNCTION_TYPE_2 (BT_FN_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE_COMPLEX_LONGDOUBLE, \n \t             BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE, BT_COMPLEX_LONGDOUBLE)\n+DEF_FUNCTION_TYPE_2 (BT_FN_VOID_PTR_PTR, BT_VOID, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_2 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING)\n \n@@ -270,6 +271,7 @@ DEF_FUNCTION_TYPE_3 (BT_FN_VOID_DOUBLE_DOUBLEPTR_DOUBLEPTR,\n \t\t     BT_VOID, BT_DOUBLE, BT_DOUBLE_PTR, BT_DOUBLE_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_VOID_LONGDOUBLE_LONGDOUBLEPTR_LONGDOUBLEPTR,\n \t\t     BT_VOID, BT_LONGDOUBLE, BT_LONGDOUBLE_PTR, BT_LONGDOUBLE_PTR)\n+DEF_FUNCTION_TYPE_3 (BT_FN_VOID_PTR_PTR_PTR, BT_VOID, BT_PTR, BT_PTR, BT_PTR)\n DEF_FUNCTION_TYPE_3 (BT_FN_INT_CONST_STRING_PTR_CONST_STRING_PTR_CONST_STRING,\n \t\t     BT_INT, BT_CONST_STRING, BT_PTR_CONST_STRING, BT_PTR_CONST_STRING)\n "}, {"sha": "b0375c377aa70bc87d05ad508a8f17127a53f2f7", "filename": "gcc/builtins.c", "status": "modified", "additions": 1441, "deletions": 80, "changes": 1521, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -68,11 +68,10 @@ const char *const built_in_names[(int) END_BUILTINS] =\n tree built_in_decls[(int) END_BUILTINS];\n /* Declarations used when constructing the builtin implicitly in the compiler.\n    It may be NULL_TREE when this is invalid (for instance runtime is not\n-   required to implement the function call in all cases.  */\n+   required to implement the function call in all cases).  */\n tree implicit_built_in_decls[(int) END_BUILTINS];\n \n static int get_pointer_alignment (tree, unsigned int);\n-static tree c_strlen (tree, int);\n static const char *c_getstr (tree);\n static rtx c_readstr (const char *, enum machine_mode);\n static int target_char_cast (tree, char *);\n@@ -96,7 +95,6 @@ static void expand_errno_check (tree, rtx);\n static rtx expand_builtin_mathfn (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n-static rtx expand_builtin_constant_p (tree, enum machine_mode);\n static rtx expand_builtin_args_info (tree);\n static rtx expand_builtin_next_arg (tree);\n static rtx expand_builtin_va_start (tree);\n@@ -163,6 +161,22 @@ static tree fold_builtin_strcmp (tree);\n static tree fold_builtin_strncmp (tree);\n static tree fold_builtin_signbit (tree);\n \n+static tree simplify_builtin_memcmp (tree);\n+static tree simplify_builtin_strcmp (tree);\n+static tree simplify_builtin_strncmp (tree);\n+static tree simplify_builtin_strpbrk (tree);\n+static tree simplify_builtin_strstr (tree);\n+static tree simplify_builtin_strchr (tree);\n+static tree simplify_builtin_strrchr (tree);\n+static tree simplify_builtin_strcat (tree);\n+static tree simplify_builtin_strncat (tree);\n+static tree simplify_builtin_strspn (tree);\n+static tree simplify_builtin_strcspn (tree);\n+static void simplify_builtin_next_arg (tree);\n+static void simplify_builtin_va_start (tree);\n+static tree simplify_builtin_sprintf (tree, int);\n+\n+\n /* Return the alignment in bits of EXP, a pointer valued expression.\n    But don't return more than MAX_ALIGN no matter what.\n    The alignment returned is, by default, the alignment of the thing that\n@@ -247,7 +261,7 @@ get_pointer_alignment (tree exp, unsigned int max_align)\n    Unfortunately, string_constant can't access the values of const char\n    arrays with initializers, so neither can we do so here.  */\n \n-static tree\n+tree\n c_strlen (tree src, int only_value)\n {\n   tree offset_node;\n@@ -407,6 +421,21 @@ target_char_cast (tree cst, char *p)\n   return 0;\n }\n \n+/* Similar to save_expr, but assumes that arbitrary code is not executed\n+   in between the multiple evaluations.  In particular, we assume that a\n+   non-addressable local variable will not be modified.  */\n+\n+static tree\n+builtin_save_expr (tree exp)\n+{\n+  if (TREE_ADDRESSABLE (exp) == 0\n+      && (TREE_CODE (exp) == PARM_DECL\n+\t  || (TREE_CODE (exp) == VAR_DECL && !TREE_STATIC (exp))))\n+    return exp;\n+\n+  return save_expr (exp);\n+}\n+\n /* Given TEM, a pointer to a stack frame, follow the dynamic chain COUNT\n    times to get the address of either a higher stack frame, or a return\n    address located within it (depending on FNDECL_CODE).  */\n@@ -739,6 +768,79 @@ expand_builtin_longjmp (rtx buf_addr, rtx value)\n     }\n }\n \n+/* Expand a call to __builtin_nonlocal_goto.  We're passed the target label\n+   and the address of the save area.  */\n+\n+static rtx\n+expand_builtin_nonlocal_goto (tree arglist)\n+{\n+  tree t_label, t_save_area;\n+  rtx r_label, r_save_area, r_fp, r_sp, insn;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  t_label = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  t_save_area = TREE_VALUE (arglist);\n+\n+  r_label = expand_expr (t_label, NULL_RTX, VOIDmode, 0);\n+  r_save_area = expand_expr (t_save_area, NULL_RTX, VOIDmode, 0);\n+  r_fp = gen_rtx_MEM (Pmode, r_save_area);\n+  r_sp = gen_rtx_MEM (STACK_SAVEAREA_MODE (SAVE_NONLOCAL),\n+\t\t      plus_constant (r_save_area, GET_MODE_SIZE (Pmode)));\n+\n+  current_function_has_nonlocal_goto = 1;\n+\n+#if HAVE_nonlocal_goto\n+  /* ??? We no longer need to pass the static chain value, afaik.  */\n+  if (HAVE_nonlocal_goto)\n+    emit_insn (gen_nonlocal_goto (const0_rtx, r_label, r_sp, r_fp));\n+  else\n+#endif\n+    {\n+      r_label = copy_to_reg (r_label);\n+\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t  gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t       gen_rtx_SCRATCH (VOIDmode))));\n+\n+      emit_insn (gen_rtx_CLOBBER (VOIDmode,\n+\t\t\t\t  gen_rtx_MEM (BLKmode,\n+\t\t\t\t\t       hard_frame_pointer_rtx)));\n+ \n+      /* Restore frame pointer for containing function.\n+\t This sets the actual hard register used for the frame pointer\n+\t to the location of the function's incoming static chain info.\n+\t The non-local goto handler will then adjust it to contain the\n+\t proper value and reload the argument pointer, if needed.  */\n+      emit_move_insn (hard_frame_pointer_rtx, r_fp);\n+      emit_stack_restore (SAVE_NONLOCAL, r_sp, NULL_RTX);\n+ \n+      /* USE of hard_frame_pointer_rtx added for consistency;\n+\t not clear if really needed.  */\n+      emit_insn (gen_rtx_USE (VOIDmode, hard_frame_pointer_rtx));\n+      emit_insn (gen_rtx_USE (VOIDmode, stack_pointer_rtx));\n+      emit_indirect_jump (r_label);\n+    }\n+ \n+  /* Search backwards to the jump insn and mark it as a\n+     non-local goto.  */\n+  for (insn = get_last_insn (); insn; insn = PREV_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == JUMP_INSN)\n+\t{\n+\t  REG_NOTES (insn) = alloc_EXPR_LIST (REG_NON_LOCAL_GOTO,\n+\t\t\t\t\t      const0_rtx, REG_NOTES (insn));\n+\t  break;\n+\t}\n+      else if (GET_CODE (insn) == CALL_INSN)\n+\tbreak;\n+    }\n+\n+  return const0_rtx;\n+}\n+\n /* __builtin_update_setjmp_buf is passed a pointer to an array of five words\n    (not all will be used on all machines) that was passed to __builtin_setjmp.\n    It updates the stack pointer in that block to correspond to the current\n@@ -1230,7 +1332,7 @@ expand_builtin_apply (rtx function, rtx arguments, rtx argsize)\n     }\n \n   /* All arguments and registers used for the call are set up by now!  */\n-  function = prepare_call_address (function, NULL_TREE, &call_fusage, 0, 0);\n+  function = prepare_call_address (function, NULL, &call_fusage, 0, 0);\n \n   /* Ensure address is valid.  SYMBOL_REF is already valid, so no need,\n      and we don't want to load it into a register as an optimization,\n@@ -1384,32 +1486,6 @@ expand_builtin_classify_type (tree arglist)\n   return GEN_INT (no_type_class);\n }\n \n-/* Expand expression EXP, which is a call to __builtin_constant_p.  */\n-\n-static rtx\n-expand_builtin_constant_p (tree arglist, enum machine_mode target_mode)\n-{\n-  rtx tmp;\n-\n-  if (arglist == 0)\n-    return const0_rtx;\n-  arglist = TREE_VALUE (arglist);\n-\n-  /* We have taken care of the easy cases during constant folding.  This\n-     case is not obvious, so emit (constant_p_rtx (ARGLIST)) and let CSE\n-     get a chance to see if it can deduce whether ARGLIST is constant.\n-     If CSE isn't going to run, of course, don't bother waiting.  */\n-\n-  if (cse_not_expected)\n-    return const0_rtx;\n-\n-  current_function_calls_constant_p = 1;\n-\n-  tmp = expand_expr (arglist, NULL_RTX, VOIDmode, 0);\n-  tmp = gen_rtx_CONSTANT_P_RTX (target_mode, tmp);\n-  return tmp;\n-}\n-\n /* This helper macro, meant to be used in mathfn_built_in below,\n    determines which among a set of three builtin math functions is\n    appropriate for a given type mode.  The `F' and `L' cases are\n@@ -1682,7 +1758,7 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n       /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n \t need to expand the argument again.  This way, we will not perform\n \t side-effects more the once.  */\n-      narg = save_expr (arg);\n+      narg = builtin_save_expr (arg);\n       if (narg != arg)\n \t{\n \t  arglist = build_tree_list (NULL_TREE, arg);\n@@ -1821,8 +1897,8 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   if (! flag_errno_math || ! HONOR_NANS (mode))\n     errno_set = false;\n \n-  /* Alway stabilize the argument list.  */\n-  narg = save_expr (arg1);\n+  /* Always stabilize the argument list.  */\n+  narg = builtin_save_expr (arg1);\n   if (narg != arg1)\n     {\n       temp = build_tree_list (NULL_TREE, narg);\n@@ -1831,7 +1907,7 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   else\n     temp = TREE_CHAIN (arglist);\n \n-  narg = save_expr (arg0);\n+  narg = builtin_save_expr (arg0);\n   if (narg != arg0)\n     {\n       arglist = tree_cons (NULL_TREE, narg, temp);\n@@ -3488,8 +3564,8 @@ expand_builtin_strcmp (tree exp, rtx target, enum machine_mode mode)\n       result = gen_reg_rtx (insn_mode);\n \n     /* Stabilize the arguments in case gen_cmpstrsi fails.  */\n-    arg1 = save_expr (arg1);\n-    arg2 = save_expr (arg2);\n+    arg1 = builtin_save_expr (arg1);\n+    arg2 = builtin_save_expr (arg2);\n \n     arg1_rtx = get_memory_rtx (arg1);\n     arg2_rtx = get_memory_rtx (arg2);\n@@ -3659,9 +3735,9 @@ expand_builtin_strncmp (tree exp, rtx target, enum machine_mode mode)\n       result = gen_reg_rtx (insn_mode);\n \n     /* Stabilize the arguments in case gen_cmpstrsi fails.  */\n-    arg1 = save_expr (arg1);\n-    arg2 = save_expr (arg2);\n-    len = save_expr (len);\n+    arg1 = builtin_save_expr (arg1);\n+    arg2 = builtin_save_expr (arg2);\n+    len = builtin_save_expr (len);\n \n     arg1_rtx = get_memory_rtx (arg1);\n     arg2_rtx = get_memory_rtx (arg2);\n@@ -3731,7 +3807,7 @@ expand_builtin_strcat (tree arglist, rtx target, enum machine_mode mode)\n \t      arglist = tree_cons (NULL_TREE, src, arglist);\n \n \t      /* We're going to use dst more than once.  */\n-\t      dst = save_expr (dst);\n+\t      dst = builtin_save_expr (dst);\n \n \t      /* Create strlen (dst).  */\n \t      newdst =\n@@ -4401,6 +4477,12 @@ expand_builtin_alloca (tree arglist, rtx target)\n   rtx op0;\n   rtx result;\n \n+  /* In -fmudflap-instrumented code, alloca() and __builtin_alloca()\n+     should always expand to function calls.  These can be intercepted\n+     in libmudflap.  */\n+  if (flag_mudflap)\n+    return 0;\n+\n   if (!validate_arglist (arglist, INTEGER_TYPE, VOID_TYPE))\n     return 0;\n \n@@ -4748,6 +4830,7 @@ build_string_literal (int len, const char *str)\n   type = build_array_type (elem, index);\n   TREE_TYPE (t) = type;\n   TREE_CONSTANT (t) = 1;\n+  TREE_INVARIANT (t) = 1;\n   TREE_READONLY (t) = 1;\n   TREE_STATIC (t) = 1;\n \n@@ -5041,6 +5124,111 @@ expand_builtin_sprintf (tree arglist, rtx target, enum machine_mode mode)\n   return 0;\n }\n \n+/* Expand a call to either the entry or exit function profiler.  */\n+\n+static rtx\n+expand_builtin_profile_func (bool exitp)\n+{\n+  rtx this, which;\n+\n+  this = DECL_RTL (current_function_decl);\n+  if (GET_CODE (this) == MEM)\n+    this = XEXP (this, 0);\n+  else\n+    abort ();\n+\n+  if (exitp)\n+    which = profile_function_exit_libfunc;\n+  else\n+    which = profile_function_entry_libfunc;\n+\n+  emit_library_call (which, LCT_NORMAL, VOIDmode, 2, this, Pmode,\n+\t\t     expand_builtin_return_addr (BUILT_IN_RETURN_ADDRESS,\n+\t\t\t\t\t\t 0, hard_frame_pointer_rtx),\n+\t\t     Pmode);\n+\n+  return const0_rtx;\n+}\n+\n+/* Given a trampoline address, make sure it satisfies TRAMPOLINE_ALIGNMENT.  */\n+\n+static rtx\n+round_trampoline_addr (rtx tramp)\n+{\n+  rtx temp, addend, mask;\n+\n+  /* If we don't need too much alignment, we'll have been guaranteed\n+     proper alignment by get_trampoline_type.  */\n+  if (TRAMPOLINE_ALIGNMENT <= STACK_BOUNDARY)\n+    return tramp;\n+\n+  /* Round address up to desired boundary.  */\n+  temp = gen_reg_rtx (Pmode);\n+  addend = GEN_INT (TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT - 1);\n+  mask = GEN_INT (-TRAMPOLINE_ALIGNMENT / BITS_PER_UNIT);\n+\n+  temp  = expand_simple_binop (Pmode, PLUS, tramp, addend,\n+\t\t\t       temp, 0, OPTAB_LIB_WIDEN);\n+  tramp = expand_simple_binop (Pmode, AND, temp, mask,\n+\t\t\t       temp, 0, OPTAB_LIB_WIDEN);\n+\n+  return tramp;\n+}\n+\n+static rtx\n+expand_builtin_init_trampoline (tree arglist)\n+{\n+  tree t_tramp, t_func, t_chain;\n+  rtx r_tramp, r_func, r_chain;\n+#ifdef TRAMPOLINE_TEMPLATE\n+  rtx blktramp;\n+#endif\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE,\n+\t\t\t POINTER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  t_tramp = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  t_func = TREE_VALUE (arglist);\n+  arglist = TREE_CHAIN (arglist);\n+  t_chain = TREE_VALUE (arglist);\n+\n+  r_tramp = expand_expr (t_tramp, NULL_RTX, VOIDmode, 0);\n+  r_func = expand_expr (t_func, NULL_RTX, VOIDmode, 0);\n+  r_chain = expand_expr (t_chain, NULL_RTX, VOIDmode, 0);\n+\n+  /* Generate insns to initialize the trampoline.  */\n+  r_tramp = round_trampoline_addr (r_tramp);\n+#ifdef TRAMPOLINE_TEMPLATE\n+  blktramp = gen_rtx_MEM (BLKmode, r_tramp);\n+  set_mem_align (blktramp, TRAMPOLINE_ALIGNMENT);\n+  emit_block_move (blktramp, assemble_trampoline_template (),\n+\t\t   GEN_INT (TRAMPOLINE_SIZE), BLOCK_OP_NORMAL);\n+#endif\n+  trampolines_created = 1;\n+  INITIALIZE_TRAMPOLINE (r_tramp, r_func, r_chain);\n+\n+  return const0_rtx;\n+}\n+\n+static rtx\n+expand_builtin_adjust_trampoline (tree arglist)\n+{\n+  rtx tramp;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, VOID_TYPE))\n+    return NULL_RTX;\n+\n+  tramp = expand_expr (TREE_VALUE (arglist), NULL_RTX, VOIDmode, 0);\n+  tramp = round_trampoline_addr (tramp);\n+#ifdef TRAMPOLINE_ADJUST_ADDRESS\n+  TRAMPOLINE_ADJUST_ADDRESS (tramp);\n+#endif\n+\n+  return tramp;\n+}\n+\n /* Expand a call to the built-in signbit, signbitf or signbitl function.\n    Return NULL_RTX if a normal call should be emitted rather than expanding\n    the function in-line.  EXP is the expression that is a call to the builtin\n@@ -5453,13 +5641,14 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \n       /* Return the address of the first anonymous stack arg.  */\n     case BUILT_IN_NEXT_ARG:\n+      simplify_builtin_next_arg (arglist);\n       return expand_builtin_next_arg (arglist);\n \n     case BUILT_IN_CLASSIFY_TYPE:\n       return expand_builtin_classify_type (arglist);\n \n     case BUILT_IN_CONSTANT_P:\n-      return expand_builtin_constant_p (arglist, target_mode);\n+      return const0_rtx;\n \n     case BUILT_IN_FRAME_ADDRESS:\n     case BUILT_IN_RETURN_ADDRESS:\n@@ -5481,6 +5670,18 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_STACK_ALLOC:\n+      expand_stack_alloc (TREE_VALUE (arglist),\n+\t\t\t  TREE_VALUE (TREE_CHAIN (arglist)));\n+      return const0_rtx;\n+\n+    case BUILT_IN_STACK_SAVE:\n+      return expand_stack_save ();\n+\n+    case BUILT_IN_STACK_RESTORE:\n+      expand_stack_restore (TREE_VALUE (arglist));\n+      return const0_rtx;\n+\n     case BUILT_IN_FFS:\n     case BUILT_IN_FFSL:\n     case BUILT_IN_FFSLL:\n@@ -5684,6 +5885,12 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \t  return const0_rtx;\n \t}\n \n+    case BUILT_IN_NONLOCAL_GOTO:\n+      target = expand_builtin_nonlocal_goto (arglist);\n+      if (target)\n+\treturn target;\n+      break;\n+\n       /* This updates the setjmp buffer that is its argument with the value\n \t of the current stack pointer.  */\n     case BUILT_IN_UPDATE_SETJMP_BUF:\n@@ -5718,7 +5925,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       if (target)\n \treturn target;\n       break;\n-\n     case BUILT_IN_FPUTS_UNLOCKED:\n       target = expand_builtin_fputs (arglist, target, true);\n       if (target)\n@@ -5792,6 +5998,16 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n       expand_builtin_prefetch (arglist);\n       return const0_rtx;\n \n+    case BUILT_IN_PROFILE_FUNC_ENTER:\n+      return expand_builtin_profile_func (false);\n+    case BUILT_IN_PROFILE_FUNC_EXIT:\n+      return expand_builtin_profile_func (true);\n+\n+    case BUILT_IN_INIT_TRAMPOLINE:\n+      return expand_builtin_init_trampoline (arglist);\n+    case BUILT_IN_ADJUST_TRAMPOLINE:\n+      return expand_builtin_adjust_trampoline (arglist);\n+\n     case BUILT_IN_FORK:\n     case BUILT_IN_EXECL:\n     case BUILT_IN_EXECV:\n@@ -5927,6 +6143,44 @@ fold_builtin_constant_p (tree arglist)\n   return 0;\n }\n \n+/* Fold a call to __builtin_expect, if we expect that a comparison against\n+   the argument will fold to a constant.  In practice, this means a true\n+   constant or the address of a non-weak symbol.  ARGLIST is the argument\n+   list of the call.  */\n+\n+static tree\n+fold_builtin_expect (tree arglist)\n+{\n+  tree arg, inner;\n+\n+  if (arglist == 0)\n+    return 0;\n+\n+  arg = TREE_VALUE (arglist);\n+\n+  /* If the argument isn't invariant, then there's nothing we can do.  */\n+  if (!TREE_INVARIANT (arg))\n+    return 0;\n+\n+  /* If we're looking at an address of a weak decl, then do not fold.  */\n+  inner = arg;\n+  STRIP_NOPS (inner);\n+  if (TREE_CODE (inner) == ADDR_EXPR)\n+    {\n+      do\n+\t{\n+\t  inner = TREE_OPERAND (inner, 0);\n+\t}\n+      while (TREE_CODE (inner) == COMPONENT_REF\n+\t     || TREE_CODE (inner) == ARRAY_REF);\n+      if (DECL_P (inner) && DECL_WEAK (inner))\n+\treturn 0;\n+    }\n+\n+  /* Otherwise, ARG already has the proper type for the return value.  */\n+  return arg;\n+}\n+\n /* Fold a call to __builtin_classify_type.  */\n \n static tree\n@@ -6196,13 +6450,13 @@ fold_builtin_cabs (tree arglist, tree type)\n \t{\n \t  tree rpart, ipart, result, arglist;\n \n-\t  arg = save_expr (arg);\n+\t  arg = builtin_save_expr (arg);\n \n \t  rpart = fold (build1 (REALPART_EXPR, type, arg));\n \t  ipart = fold (build1 (IMAGPART_EXPR, type, arg));\n \n-\t  rpart = save_expr (rpart);\n-\t  ipart = save_expr (ipart);\n+\t  rpart = builtin_save_expr (rpart);\n+\t  ipart = builtin_save_expr (ipart);\n \n \t  result = fold (build (PLUS_EXPR, type,\n \t\t\t\tfold (build (MULT_EXPR, type,\n@@ -6995,11 +7249,16 @@ fold_builtin_isascii (tree arglist)\n       /* Transform isascii(c) -> ((c & ~0x7f) == 0).  */\n       tree arg = TREE_VALUE (arglist);\n       \n-      return fold (build (EQ_EXPR, integer_type_node,\n-\t\t\t  build (BIT_AND_EXPR, integer_type_node, arg,\n-\t\t\t\t build_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n-\t\t\t\t\t      ~ (HOST_WIDE_INT) 0)),\n-\t\t\t  integer_zero_node));\n+      arg = fold (build (EQ_EXPR, integer_type_node,\n+\t\t\t build (BIT_AND_EXPR, integer_type_node, arg,\n+\t\t\t\tbuild_int_2 (~ (unsigned HOST_WIDE_INT) 0x7f,\n+\t\t\t\t\t     ~ (HOST_WIDE_INT) 0)),\n+\t\t\t integer_zero_node));\n+      \n+      if (in_gimple_form && !TREE_CONSTANT (arg))\n+        return NULL_TREE;\n+      else\n+        return arg;\n     }\n }\n \n@@ -7038,15 +7297,19 @@ fold_builtin_isdigit (tree arglist)\n \t\t\t\t build_int_2 (TARGET_DIGIT0, 0)));\n       arg = build (LE_EXPR, integer_type_node, arg,\n \t\t   fold_convert (unsigned_type_node, build_int_2 (9, 0)));\n-      return fold (arg);\n+      arg = fold (arg);\n+      if (in_gimple_form && !TREE_CONSTANT (arg))\n+        return NULL_TREE;\n+      else\n+        return arg;\n     }\n }\n \n /* Used by constant folding to eliminate some builtin calls early.  EXP is\n    the CALL_EXPR of a call to a builtin function.  */\n \n-tree\n-fold_builtin (tree exp)\n+static tree\n+fold_builtin_1 (tree exp)\n {\n   tree fndecl = get_callee_fndecl (exp);\n   tree arglist = TREE_OPERAND (exp, 1);\n@@ -7060,6 +7323,9 @@ fold_builtin (tree exp)\n     case BUILT_IN_CONSTANT_P:\n       return fold_builtin_constant_p (arglist);\n \n+    case BUILT_IN_EXPECT:\n+      return fold_builtin_expect (arglist);\n+\n     case BUILT_IN_CLASSIFY_TYPE:\n       return fold_builtin_classify_type (arglist);\n \n@@ -7557,6 +7823,24 @@ fold_builtin (tree exp)\n   return 0;\n }\n \n+/* A wrapper function for builtin folding that prevents warnings for\n+   \"statement without effect\" and the like, caused by removing the \n+   call node earlier than the warning is generated.  */\n+\n+tree\n+fold_builtin (tree exp)\n+{\n+  exp = fold_builtin_1 (exp);\n+  if (exp)\n+    {\n+      /* ??? Don't clobber shared nodes such as integer_zero_node.  */\n+      if (TREE_CODE_CLASS (TREE_CODE (exp)) == 'c')\n+\texp = build1 (NOP_EXPR, TREE_TYPE (exp), exp);\n+      TREE_NO_WARNING (exp) = 1;\n+    }\n+  return exp;\n+}\n+\n /* Conveniently construct a function call expression.  */\n \n tree\n@@ -7566,7 +7850,7 @@ build_function_call_expr (tree fn, tree arglist)\n \n   call_expr = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (fn)), fn);\n   call_expr = build (CALL_EXPR, TREE_TYPE (TREE_TYPE (fn)),\n-\t\t     call_expr, arglist);\n+\t\t     call_expr, arglist, NULL_TREE);\n   return fold (call_expr);\n }\n \n@@ -7631,31 +7915,6 @@ default_expand_builtin (tree exp ATTRIBUTE_UNUSED,\n   return NULL_RTX;\n }\n \n-/* Instantiate all remaining CONSTANT_P_RTX nodes.  */\n-\n-void\n-purge_builtin_constant_p (void)\n-{\n-  rtx insn, set, arg, new, note;\n-\n-  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n-    if (INSN_P (insn)\n-\t&& (set = single_set (insn)) != NULL_RTX\n-\t&& (GET_CODE (arg = SET_SRC (set)) == CONSTANT_P_RTX\n-\t    || (GET_CODE (arg) == SUBREG\n-\t\t&& (GET_CODE (arg = SUBREG_REG (arg))\n-\t\t    == CONSTANT_P_RTX))))\n-      {\n-\targ = XEXP (arg, 0);\n-\tnew = CONSTANT_P (arg) ? const1_rtx : const0_rtx;\n-\tvalidate_change (insn, &SET_SRC (set), new, 0);\n-\n-\t/* Remove the REG_EQUAL note from the insn.  */\n-\tif ((note = find_reg_note (insn, REG_EQUAL, NULL_RTX)) != 0)\n-\t  remove_note (insn, note);\n-      }\n-}\n-\n /* Returns true is EXP represents data that would potentially reside\n    in a readonly section.  */\n \n@@ -7669,3 +7928,1105 @@ readonly_data_expr (tree exp)\n   else\n     return false;\n }\n+\n+/* Front-end to the simplify_builtin_XXX routines.\n+\n+   EXP is a call to a builtin function.  If possible try to simplify\n+   that into a constant, expression or call to a more efficient\n+   builtin function.\n+\n+   If IGNORE is nonzero, then the result of this builtin function\n+   call is ignored.\n+\n+   If simplification is possible, return the simplified tree, otherwise\n+   return NULL_TREE.  */\n+\n+tree\n+simplify_builtin (tree exp, int ignore)\n+{\n+  tree fndecl = TREE_OPERAND (TREE_OPERAND (exp, 0), 0);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum built_in_function fcode = DECL_FUNCTION_CODE (fndecl);\n+  tree val;\n+\n+  switch (fcode)\n+    {\n+    case BUILT_IN_FPUTS:\n+      val = simplify_builtin_fputs (arglist, ignore, 0, NULL_TREE);\n+      break;\n+    case BUILT_IN_FPUTS_UNLOCKED:\n+      val = simplify_builtin_fputs (arglist, ignore, 1, NULL_TREE);\n+      break;\n+    case BUILT_IN_STRSTR:\n+      val = simplify_builtin_strstr (arglist);\n+      break;\n+    case BUILT_IN_STRCAT:\n+      val = simplify_builtin_strcat (arglist);\n+      break;\n+    case BUILT_IN_STRNCAT:\n+      val = simplify_builtin_strncat (arglist);\n+      break;\n+    case BUILT_IN_STRSPN:\n+      val = simplify_builtin_strspn (arglist);\n+      break;\n+    case BUILT_IN_STRCSPN:\n+      val = simplify_builtin_strcspn (arglist);\n+      break;\n+    case BUILT_IN_STRCHR:\n+    case BUILT_IN_INDEX:\n+      val = simplify_builtin_strchr (arglist);\n+      break;\n+    case BUILT_IN_STRRCHR:\n+    case BUILT_IN_RINDEX:\n+      val = simplify_builtin_strrchr (arglist);\n+      break;\n+    case BUILT_IN_STRCPY:\n+      val = simplify_builtin_strcpy (arglist, NULL_TREE);\n+      break;\n+    case BUILT_IN_STRNCPY:\n+      val = simplify_builtin_strncpy (arglist, NULL_TREE);\n+      break;\n+    case BUILT_IN_STRCMP:\n+      val = simplify_builtin_strcmp (arglist);\n+      break;\n+    case BUILT_IN_STRNCMP:\n+      val = simplify_builtin_strncmp (arglist);\n+      break;\n+    case BUILT_IN_STRPBRK:\n+      val = simplify_builtin_strpbrk (arglist);\n+      break;\n+    case BUILT_IN_BCMP:\n+    case BUILT_IN_MEMCMP:\n+      val = simplify_builtin_memcmp (arglist);\n+      break;\n+    case BUILT_IN_VA_START:\n+      simplify_builtin_va_start (arglist);\n+      val = NULL_TREE;\n+      break;\n+    case BUILT_IN_SPRINTF:\n+      val = simplify_builtin_sprintf (arglist, ignore);\n+      break;\n+    case BUILT_IN_CONSTANT_P:\n+      val = fold_builtin_constant_p (arglist);\n+      /* Gimplification will pull the CALL_EXPR for the builtin out of\n+\t an if condition.  When not optimizing, we'll not CSE it back.\n+\t To avoid link error types of regressions, return false now.  */\n+      if (!val && !optimize)\n+\tval = integer_zero_node;\n+      break;\n+    default:\n+      val = NULL_TREE;\n+      break;\n+    }\n+\n+  if (val)\n+    val = convert (TREE_TYPE (exp), val);\n+  return val;\n+}\n+\n+/* Simplify a call to the strstr builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strstr (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree fn;\n+      const char *p1, *p2;\n+\n+      p2 = c_getstr (s2);\n+      if (p2 == NULL)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strstr (p1, p2);\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  if (r == NULL)\n+\t    return integer_zero_node;\n+\t  else\n+\t    return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t\ts1, convert (TREE_TYPE (s1),\n+\t\t\t\t\t     ssize_int (r - p1))));\n+\t}\n+\n+      if (p2[0] == '\\0')\n+\treturn s1;\n+\n+      if (p2[1] != '\\0')\n+\treturn 0;\n+\n+      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* New argument list transforming strstr(s1, s2) to\n+\t strchr(s1, s2[0]).  */\n+      arglist = build_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = tree_cons (NULL_TREE, s1, arglist);\n+      return build_function_call_expr (fn, arglist);\n+    }\n+}\n+\n+/* Simplify a call to the strstr builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strchr (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      const char *p1;\n+\n+      if (TREE_CODE (s2) != INTEGER_CST)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  char c;\n+\t  const char *r;\n+\n+\t  if (target_char_cast (s2, &c))\n+\t    return 0;\n+\n+\t  r = strchr (p1, c);\n+\n+\t  if (r == NULL)\n+\t    return integer_zero_node;\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t      s1, convert (TREE_TYPE (s1),\n+\t\t\t\t\t   ssize_int (r - p1))));\n+\t}\n+\n+      /* FIXME: Should use here strchrM optab so that ports can optimize\n+\t this.  */\n+      return 0;\n+    }\n+}\n+\n+/* Simplify a call to the strrchr builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strrchr (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree fn;\n+      const char *p1;\n+\n+      if (TREE_CODE (s2) != INTEGER_CST)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  char c;\n+\t  const char *r;\n+\n+\t  if (target_char_cast (s2, &c))\n+\t    return 0;\n+\n+\t  r = strrchr (p1, c);\n+\n+\t  if (r == NULL)\n+\t    return integer_zero_node;\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t      s1, convert (TREE_TYPE (s1),\n+\t\t\t\t\t   ssize_int (r - p1))));\n+\t}\n+\n+      if (! integer_zerop (s2))\n+\treturn 0;\n+\n+      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* Transform strrchr(s1, '\\0') to strchr(s1, '\\0').  */\n+      return build_function_call_expr (fn, arglist);\n+    }\n+}\n+\n+/* Simplify a call to the strpbrk builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strpbrk (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree fn;\n+      const char *p1, *p2;\n+\n+      p2 = c_getstr (s2);\n+      if (p2 == NULL)\n+\treturn 0;\n+\n+      p1 = c_getstr (s1);\n+      if (p1 != NULL)\n+\t{\n+\t  const char *r = strpbrk (p1, p2);\n+\n+\t  if (r == NULL)\n+\t    return integer_zero_node;\n+\n+\t  /* Return an offset into the constant string argument.  */\n+\t  return fold (build (PLUS_EXPR, TREE_TYPE (s1),\n+\t\t\t      s1, convert (TREE_TYPE (s1),\n+\t\t\t\t\t   ssize_int (r - p1))));\n+\t}\n+\n+      if (p2[0] == '\\0')\n+\t{\n+\t  /* strpbrk(x, \"\") == NULL.\n+\t     Evaluate and ignore the arguments in case they had\n+\t     side-effects.  */\n+\t  return build (COMPOUND_EXPR, integer_type_node, s1,\n+\t\t\tinteger_zero_node);\n+\t}\n+\n+      if (p2[1] != '\\0')\n+\treturn 0;  /* Really call strpbrk.  */\n+\n+      fn = implicit_built_in_decls[BUILT_IN_STRCHR];\n+      if (!fn)\n+\treturn 0;\n+\n+      /* New argument list transforming strpbrk(s1, s2) to\n+\t strchr(s1, s2[0]).  */\n+      arglist =\n+\tbuild_tree_list (NULL_TREE, build_int_2 (p2[0], 0));\n+      arglist = tree_cons (NULL_TREE, s1, arglist);\n+      return build_function_call_expr (fn, arglist);\n+    }\n+}\n+\n+/* Simplify a call to the strcpy builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+tree\n+simplify_builtin_strcpy (tree arglist, tree len)\n+{\n+  tree fn;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+  if (!fn)\n+    return 0;\n+\n+  if (!len)\n+    {\n+      len = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 1);\n+      if (!len)\n+\treturn 0;\n+      if (TREE_SIDE_EFFECTS (len))\n+\treturn 0;\n+    }\n+\n+  len = size_binop (PLUS_EXPR, len, ssize_int (1));\n+  chainon (arglist, build_tree_list (NULL_TREE, len));\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+/* Simplify a call to the strncpy builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+tree\n+simplify_builtin_strncpy (tree arglist, tree slen)\n+{\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      tree fn;\n+\n+      /* We must be passed a constant len parameter.  */\n+      if (TREE_CODE (len) != INTEGER_CST)\n+\treturn 0;\n+\n+      /* If the len parameter is zero, return the dst parameter.  */\n+      if (integer_zerop (len))\n+\t{\n+\t  /* Evaluate and ignore the src argument in case it has\n+\t     side-effects and return the dst parameter.  */\n+\t  return build (COMPOUND_EXPR, TREE_TYPE (TREE_VALUE (arglist)),\n+\t\t\tTREE_VALUE (TREE_CHAIN (arglist)),\n+\t\t\tTREE_VALUE (arglist));\n+\t}\n+\n+      if (!slen)\n+        slen = c_strlen (TREE_VALUE (TREE_CHAIN (arglist)), 0);\n+\n+      /* Now, we must be passed a constant src ptr parameter.  */\n+      if (slen == 0 || TREE_CODE (slen) != INTEGER_CST)\n+\treturn 0;\n+\n+      slen = size_binop (PLUS_EXPR, slen, ssize_int (1));\n+\n+      /* We do not support simplification of this case, though we do\n+         support it when expanding trees into RTL.  */\n+      /* FIXME: generate a call to __builtin_memset.  */\n+      if (tree_int_cst_lt (slen, len))\n+\treturn 0;\n+\n+      /* OK transform into builtin memcpy.  */\n+      fn = implicit_built_in_decls[BUILT_IN_MEMCPY];\n+      if (!fn)\n+\treturn 0;\n+      return build_function_call_expr (fn, arglist);\n+    }\n+}\n+\n+/* Simplify a call to the memcmp builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_memcmp (tree arglist)\n+{\n+  tree arg1, arg2, len;\n+  const char *p1, *p2;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+  len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the len parameter is zero, return zero.  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 0)\n+    {\n+      /* Evaluate and ignore arg1 and arg2 in case they have\n+         side-effects.  */\n+      return build (COMPOUND_EXPR, integer_type_node, arg1,\n+\t\t    build (COMPOUND_EXPR, integer_type_node,\n+\t\t\t   arg2, integer_zero_node));\n+    }\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  /* If all arguments are constant, and the value of len is not greater\n+     than the lengths of arg1 and arg2, evaluate at compile-time.  */\n+  if (host_integerp (len, 1) && p1 && p2\n+      && compare_tree_int (len, strlen (p1) + 1) <= 0\n+      && compare_tree_int (len, strlen (p2) + 1) <= 0)\n+    {\n+      const int r = memcmp (p1, p2, tree_low_cst (len, 1));\n+\n+      return (r < 0\n+\t      ? integer_minus_one_node\n+\t      : (r > 0 ? integer_one_node : integer_zero_node));\n+    }\n+\n+  /* If len parameter is one, return an expression corresponding to\n+     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n+  if (host_integerp (len, 1) && tree_low_cst (len, 1) == 1)\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 =\n+      fold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n+      tree ind2 =\n+      fold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t    build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t    build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n+      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Simplify a call to the strcmp builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strcmp (tree arglist)\n+{\n+  tree arg1, arg2;\n+  const char *p1, *p2;\n+\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  /* If both arguments are equal (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    return integer_zero_node;\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  if (p1 && p2)\n+    {\n+      const int i = strcmp (p1, p2);\n+      return (i < 0\n+\t      ? integer_minus_one_node\n+\t      : (i > 0 ? integer_one_node : integer_zero_node));\n+    }\n+\n+  /* If either arg is \"\", return an expression corresponding to\n+     (*(const unsigned char*)arg1 - (const unsigned char*)arg2).  */\n+  if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 =\n+\tfold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n+      tree ind2 =\n+\tfold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n+      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Simplify a call to the strncmp builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strncmp (tree arglist)\n+{\n+  tree arg1, arg2, arg3;\n+  const char *p1, *p2;\n+\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg1 = TREE_VALUE (arglist);\n+  arg2 = TREE_VALUE (TREE_CHAIN (arglist));\n+  arg3 = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+\n+  /* If the len parameter is zero, return zero.  */\n+  if (integer_zerop (arg3))\n+    {\n+      /* Evaluate and ignore arg1 and arg2 in case they have\n+\t side-effects.  */\n+      return build (COMPOUND_EXPR, integer_type_node, arg1,\n+\t\t    build (COMPOUND_EXPR, integer_type_node,\n+\t\t\t   arg2, integer_zero_node));\n+    }\n+\n+  /* If arg1 and arg2 are equal (and not volatile), return zero.  */\n+  if (operand_equal_p (arg1, arg2, 0))\n+    {\n+      /* Evaluate and ignore arg3 in case it has side-effects.  */\n+      return build (COMPOUND_EXPR, integer_type_node, arg3, integer_zero_node);\n+    }\n+\n+  p1 = c_getstr (arg1);\n+  p2 = c_getstr (arg2);\n+\n+  /* If all arguments are constant, evaluate at compile-time.  */\n+  if (host_integerp (arg3, 1) && p1 && p2)\n+    {\n+      const int r = strncmp (p1, p2, tree_low_cst (arg3, 1));\n+      return (r < 0\n+\t      ? integer_minus_one_node\n+\t      : (r > 0 ? integer_one_node : integer_zero_node));\n+    }\n+\n+  /* If len == 1 or (either string parameter is \"\" and (len >= 1)),\n+      return (*(const u_char*)arg1 - *(const u_char*)arg2).  */\n+  if (host_integerp (arg3, 1)\n+      && (tree_low_cst (arg3, 1) == 1\n+\t  || (tree_low_cst (arg3, 1) > 1\n+\t      && ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0')))))\n+    {\n+      tree cst_uchar_node = build_type_variant (unsigned_char_type_node, 1, 0);\n+      tree cst_uchar_ptr_node = build_pointer_type (cst_uchar_node);\n+      tree ind1 =\n+\tfold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg1))));\n+      tree ind2 =\n+\tfold (build1 (CONVERT_EXPR, integer_type_node,\n+\t\t      build1 (INDIRECT_REF, cst_uchar_node,\n+\t\t\t      build1 (NOP_EXPR, cst_uchar_ptr_node, arg2))));\n+      return fold (build (MINUS_EXPR, integer_type_node, ind1, ind2));\n+    }\n+\n+  return 0;\n+}\n+\n+/* Simplify a call to the strcat builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strcat (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree dst = TREE_VALUE (arglist),\n+\tsrc = TREE_VALUE (TREE_CHAIN (arglist));\n+      const char *p = c_getstr (src);\n+\n+      /* If the string length is zero, return the dst parameter.  */\n+      if (p && *p == '\\0')\n+\treturn dst;\n+\n+      return 0;\n+    }\n+}\n+\n+/* Simplify a call to the strncat builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strncat (tree arglist)\n+{\n+  if (!validate_arglist (arglist,\n+\t\t\t POINTER_TYPE, POINTER_TYPE, INTEGER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree dst = TREE_VALUE (arglist);\n+      tree src = TREE_VALUE (TREE_CHAIN (arglist));\n+      tree len = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      const char *p = c_getstr (src);\n+\n+      /* If the requested length is zero, or the src parameter string\n+          length is zero, return the dst parameter.  */\n+      if (integer_zerop (len) || (p && *p == '\\0'))\n+\treturn build (COMPOUND_EXPR, TREE_TYPE (dst), src,\n+\t\t      build (COMPOUND_EXPR, integer_type_node, len, dst));\n+\n+      /* If the requested len is greater than or equal to the string\n+         length, call strcat.  */\n+      if (TREE_CODE (len) == INTEGER_CST && p\n+\t  && compare_tree_int (len, strlen (p)) >= 0)\n+\t{\n+\t  tree newarglist\n+\t    = tree_cons (NULL_TREE, dst, build_tree_list (NULL_TREE, src));\n+\t  tree fn = implicit_built_in_decls[BUILT_IN_STRCAT];\n+\n+\t  /* If the replacement _DECL isn't initialized, don't do the\n+\t     transformation.  */\n+\t  if (!fn)\n+\t    return 0;\n+\n+\t  return build_function_call_expr (fn, newarglist);\n+\t}\n+      return 0;\n+    }\n+}\n+\n+/* Simplify a call to the strspn builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strspn (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n+\n+      /* If both arguments are constants, evaluate at compile-time.  */\n+      if (p1 && p2)\n+\t{\n+\t  const size_t r = strspn (p1, p2);\n+\t  return size_int (r);\n+\t}\n+\n+      /* If either argument is \"\", return 0.  */\n+      if ((p1 && *p1 == '\\0') || (p2 && *p2 == '\\0'))\n+\t{\n+\t  /* Evaluate and ignore both arguments in case either one has\n+\t     side-effects.  */\n+\t  return build (COMPOUND_EXPR, integer_type_node, s1,\n+\t\t\tbuild (COMPOUND_EXPR, integer_type_node,\n+\t\t\t       s2, integer_zero_node));\n+\t}\n+      return 0;\n+    }\n+}\n+\n+/* Simplify a call to the strcspn builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.  */\n+\n+static tree\n+simplify_builtin_strcspn (tree arglist)\n+{\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+  else\n+    {\n+      tree s1 = TREE_VALUE (arglist), s2 = TREE_VALUE (TREE_CHAIN (arglist));\n+      const char *p1 = c_getstr (s1), *p2 = c_getstr (s2);\n+\n+      /* If both arguments are constants, evaluate at compile-time.  */\n+      if (p1 && p2)\n+\t{\n+\t  const size_t r = strcspn (p1, p2);\n+\t  return size_int (r);\n+\t}\n+\n+      /* If the first argument is \"\", return 0.  */\n+      if (p1 && *p1 == '\\0')\n+\t{\n+\t  /* Evaluate and ignore argument s2 in case it has\n+\t     side-effects.  */\n+\t  return build (COMPOUND_EXPR, integer_type_node,\n+\t\t\ts2, integer_zero_node);\n+\t}\n+\n+      /* If the second argument is \"\", return __builtin_strlen(s1).  */\n+      if (p2 && *p2 == '\\0')\n+\t{\n+\t  tree newarglist = build_tree_list (NULL_TREE, s1),\n+\t    fn = implicit_built_in_decls[BUILT_IN_STRLEN];\n+\n+\t  /* If the replacement _DECL isn't initialized, don't do the\n+\t     transformation.  */\n+\t  if (!fn)\n+\t    return 0;\n+\n+\t  return build_function_call_expr (fn, newarglist);\n+\t}\n+      return 0;\n+    }\n+}\n+\n+/* Simplify a call to the fputs builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.\n+\n+   The simplified form may be a constant or other expression which\n+   computes the same value, but in a more efficient manner (including\n+   calls to other builtin functions).\n+\n+   The call may contain arguments which need to be evaluated, but\n+   which are not useful to determine the result of the call.  In\n+   this case we return a chain of COMPOUND_EXPRs.  The LHS of each\n+   COMPOUND_EXPR will be an argument which must be evaluated.\n+   COMPOUND_EXPRs are chained through their RHS.  The RHS of the last\n+   COMPOUND_EXPR in the chain will contain the tree for the simplified\n+   form of the builtin function call.\n+\n+   If KNOWN_LEN is non-NULL, it represents the known length of the string.\n+   This is determined by SSA-CCP in cases where the string itself is not\n+   known to be constant but its length is always the same constant.  */\n+\n+tree\n+simplify_builtin_fputs (tree arglist, int ignore, int unlocked, tree known_len)\n+{\n+  tree len, fn;\n+  tree fn_fputc = unlocked ? implicit_built_in_decls[BUILT_IN_FPUTC_UNLOCKED]\n+    : implicit_built_in_decls[BUILT_IN_FPUTC];\n+  tree fn_fwrite = unlocked ? implicit_built_in_decls[BUILT_IN_FWRITE_UNLOCKED]\n+    : implicit_built_in_decls[BUILT_IN_FWRITE];\n+\n+  /* If the return value is used, or the replacement _DECL isn't\n+     initialized, don't do the transformation.  */\n+  if (!ignore || !fn_fputc || !fn_fwrite)\n+    return 0;\n+\n+  /* Verify the arguments in the original call.  */\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  len = (known_len) ? known_len : c_strlen (TREE_VALUE (arglist), 0);\n+\n+  /* Get the length of the string passed to fputs.  If the length\n+     can't be determined, punt.  */\n+  if (!len\n+      || TREE_CODE (len) != INTEGER_CST)\n+    return 0;\n+\n+  switch (compare_tree_int (len, 1))\n+    {\n+    case -1: /* length is 0, delete the call entirely .  */\n+      {\n+\treturn build (COMPOUND_EXPR, integer_type_node,\n+\t\t      TREE_VALUE (TREE_CHAIN (arglist)), integer_zero_node);\n+      }\n+    case 0: /* length is 1, call fputc.  */\n+      {\n+\tconst char *p = c_getstr (TREE_VALUE (arglist));\n+\n+\tif (p != NULL)\n+\t  {\n+\t    /* New argument list transforming fputs(string, stream) to\n+\t       fputc(string[0], stream).  */\n+\t    arglist =\n+\t      build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n+\t    arglist =\n+\t      tree_cons (NULL_TREE, build_int_2 (p[0], 0), arglist);\n+\t    fn = fn_fputc;\n+\t    break;\n+\t  }\n+      }\n+      /* FALLTHROUGH */\n+    case 1: /* length is greater than 1, call fwrite.  */\n+      {\n+\ttree string_arg;\n+\n+\t/* If optimizing for size keep fputs. */\n+\tif (optimize_size)\n+\t  return 0;\n+\tstring_arg = TREE_VALUE (arglist);\n+\t/* New argument list transforming fputs(string, stream) to\n+\t   fwrite(string, 1, len, stream).  */\n+\targlist = build_tree_list (NULL_TREE, TREE_VALUE (TREE_CHAIN (arglist)));\n+\targlist = tree_cons (NULL_TREE, len, arglist);\n+\targlist = tree_cons (NULL_TREE, size_one_node, arglist);\n+\targlist = tree_cons (NULL_TREE, string_arg, arglist);\n+\tfn = fn_fwrite;\n+\tbreak;\n+      }\n+    default:\n+      abort ();\n+    }\n+\n+  return build_function_call_expr (fn, arglist);\n+}\n+\n+static void\n+simplify_builtin_va_start (tree arglist)\n+{\n+  tree chain = TREE_CHAIN (arglist);\n+\n+  if (TREE_CHAIN (chain))\n+    error (\"too many arguments to function `va_start'\");\n+\n+  simplify_builtin_next_arg (chain);\n+}\n+\n+static void\n+simplify_builtin_next_arg (tree arglist)\n+{\n+  tree fntype = TREE_TYPE (current_function_decl);\n+\n+  if (TYPE_ARG_TYPES (fntype) == 0\n+      || (TREE_VALUE (tree_last (TYPE_ARG_TYPES (fntype)))\n+\t  == void_type_node))\n+    error (\"`va_start' used in function with fixed args\");\n+  else if (arglist)\n+    {\n+      tree last_parm = tree_last (DECL_ARGUMENTS (current_function_decl));\n+      tree arg = TREE_VALUE (arglist);\n+\n+      /* Strip off all nops for the sake of the comparison.  This\n+\t is not quite the same as STRIP_NOPS.  It does more.\n+\t We must also strip off INDIRECT_EXPR for C++ reference\n+\t parameters.  */\n+      while (TREE_CODE (arg) == NOP_EXPR\n+\t     || TREE_CODE (arg) == CONVERT_EXPR\n+\t     || TREE_CODE (arg) == NON_LVALUE_EXPR\n+\t     || TREE_CODE (arg) == INDIRECT_REF)\n+\targ = TREE_OPERAND (arg, 0);\n+      if (arg != last_parm)\n+\twarning (\"second parameter of `va_start' not last named argument\");\n+      TREE_VALUE (arglist) = arg;\n+    }\n+  else\n+    /* Evidently an out of date version of <stdarg.h>; can't validate\n+       va_start's second argument, but can still work as intended.  */\n+    warning (\"`__builtin_next_arg' called without an argument\");\n+}\n+\n+\n+/* Simplify a call to the sprintf builtin.\n+\n+   Return 0 if no simplification was possible, otherwise return the\n+   simplified form of the call as a tree.  If IGNORED is true, it means that\n+   the caller does not use the returned value of the function.  */\n+\n+static tree\n+simplify_builtin_sprintf (tree arglist, int ignored)\n+{\n+  tree call, retval, dest, fmt;\n+  const char *fmt_str = NULL;\n+\n+  /* Verify the required arguments in the original call.  We deal with two\n+     types of sprintf() calls: 'sprintf (str, fmt)' and\n+     'sprintf (dest, \"%s\", orig)'.  */\n+  if (!validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, VOID_TYPE)\n+      && !validate_arglist (arglist, POINTER_TYPE, POINTER_TYPE, POINTER_TYPE,\n+\t                    VOID_TYPE))\n+    return NULL_TREE;\n+\n+  /* Get the destination string and the format specifier.  */\n+  dest = TREE_VALUE (arglist);\n+  fmt = TREE_VALUE (TREE_CHAIN (arglist));\n+\n+  /* Check whether the format is a literal string constant.  */\n+  fmt_str = c_getstr (fmt);\n+  if (fmt_str == NULL)\n+    return NULL_TREE;\n+\n+  call = NULL_TREE;\n+  retval = NULL_TREE;\n+\n+  /* If the format doesn't contain % args or %%, use strcpy.  */\n+  if (strchr (fmt_str, '%') == NULL)\n+    {\n+      tree fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\n+      if (!fn)\n+\treturn NULL_TREE;\n+\n+      /* Convert sprintf (str, fmt) into strcpy (str, fmt) when\n+\t 'format' is known to contain no % formats.  */\n+      arglist = build_tree_list (NULL_TREE, fmt);\n+      arglist = tree_cons (NULL_TREE, dest, arglist);\n+      call = build_function_call_expr (fn, arglist);\n+      if (!ignored)\n+\tretval = build_int_2 (strlen (fmt_str), 0);\n+    }\n+\n+  /* If the format is \"%s\", use strcpy if the result isn't used.  */\n+  else if (fmt_str && strcmp (fmt_str, \"%s\") == 0)\n+    {\n+      tree fn, orig;\n+      fn = implicit_built_in_decls[BUILT_IN_STRCPY];\n+\n+      if (!fn)\n+\treturn NULL_TREE;\n+\n+      /* Convert sprintf (str1, \"%s\", str2) into strcpy (str1, str2).  */\n+      orig = TREE_VALUE (TREE_CHAIN (TREE_CHAIN (arglist)));\n+      arglist = build_tree_list (NULL_TREE, orig);\n+      arglist = tree_cons (NULL_TREE, dest, arglist);\n+      if (!ignored)\n+\t{\n+\t  retval = c_strlen (orig, 1);\n+\t  if (!retval || TREE_CODE (retval) != INTEGER_CST)\n+\t    return NULL_TREE;\n+\t}\n+      call = build_function_call_expr (fn, arglist);\n+    }\n+\n+  if (call && retval)\n+    {\n+      retval = convert\n+\t(TREE_TYPE (TREE_TYPE (implicit_built_in_decls[BUILT_IN_SPRINTF])),\n+\t retval);\n+      return build (COMPOUND_EXPR, TREE_TYPE (retval), call, retval);\n+    }\n+  else\n+    return call;\n+}"}, {"sha": "f52b128d2e54d224be58b1f7191e72aa8c4fb310", "filename": "gcc/builtins.def", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -593,6 +593,9 @@ DEF_GCC_BUILTIN        (BUILT_IN_RETURN, \"return\", BT_FN_VOID_PTR, ATTR_NORETURN\n DEF_GCC_BUILTIN        (BUILT_IN_RETURN_ADDRESS, \"return_address\", BT_FN_PTR_UNSIGNED, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_SAVEREGS, \"saveregs\", BT_FN_PTR_VAR, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_SETJMP, \"setjmp\", BT_FN_INT_PTR, ATTR_NULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_STACK_ALLOC, \"stack_alloc\", BT_FN_VOID_PTR_SIZE, ATTR_NULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_STACK_SAVE, \"stack_save\", BT_FN_PTR, ATTR_NULL)\n+DEF_GCC_BUILTIN        (BUILT_IN_STACK_RESTORE, \"stack_restore\", BT_FN_VOID_PTR, ATTR_NULL)\n DEF_GCC_BUILTIN        (BUILT_IN_STDARG_START, \"stdarg_start\", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN_STRFMON, \"strfmon\", BT_FN_SSIZE_STRING_SIZE_CONST_STRING_VAR, ATTR_FORMAT_STRFMON_3_4)\n DEF_LIB_BUILTIN        (BUILT_IN_STRFTIME, \"strftime\", BT_FN_SIZE_STRING_SIZE_CONST_STRING_CONST_PTR, ATTR_FORMAT_STRFTIME_3_0)\n@@ -604,3 +607,12 @@ DEF_GCC_BUILTIN        (BUILT_IN_VA_END, \"va_end\", BT_FN_VOID_VALIST_REF, ATTR_N\n DEF_GCC_BUILTIN        (BUILT_IN_VA_START, \"va_start\", BT_FN_VOID_VALIST_REF_VAR, ATTR_NULL)\n DEF_EXT_LIB_BUILTIN    (BUILT_IN__EXIT, \"_exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\n DEF_C99_BUILTIN        (BUILT_IN__EXIT2, \"_Exit\", BT_FN_VOID_INT, ATTR_NORETURN_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_INIT_TRAMPOLINE, \"init_trampoline\", BT_FN_VOID_PTR_PTR_PTR, ATTR_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_ADJUST_TRAMPOLINE, \"adjust_trampoline\", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_LIST)\n+DEF_GCC_BUILTIN        (BUILT_IN_NONLOCAL_GOTO, \"nonlocal_goto\", BT_FN_PTR_PTR, ATTR_NORETURN_NOTHROW_LIST)\n+\n+/* Profiling hooks.  */\n+DEF_GCC_BUILTIN (BUILT_IN_PROFILE_FUNC_ENTER, \"profile_func_enter\",\n+\t\t BT_FN_VOID, ATTR_NULL)\n+DEF_GCC_BUILTIN (BUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\", \n+\t\t BT_FN_VOID, ATTR_NULL)"}, {"sha": "9b7206a94c7421ea9d35439d9146396b6c79e0c5", "filename": "gcc/c-common.c", "status": "modified", "additions": 441, "deletions": 178, "changes": 619, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -42,6 +42,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tree-inline.h\"\n #include \"c-tree.h\"\n #include \"toplev.h\"\n+#include \"tree-iterator.h\"\n+#include \"hashtab.h\"\n \n cpp_reader *parse_in;\t\t/* Declared in c-pragma.h.  */\n \n@@ -681,6 +683,15 @@ tree *ridpointers;\n \n tree (*make_fname_decl) (tree, int);\n \n+/* If non-NULL, the address of a language-specific function that\n+   returns 1 for language-specific statement codes.  */\n+int (*lang_statement_code_p) (enum tree_code);\n+\n+/* If non-NULL, the address of a language-specific function that does any\n+   language-specific gimplification for _STMT nodes and returns 1 iff\n+   handled.  */\n+int (*lang_gimplify_stmt) (tree *, tree *);\n+\n /* If non-NULL, the address of a language-specific function that takes\n    any action required right before expand_function_end is called.  */\n void (*lang_expand_function_end) (void);\n@@ -918,7 +929,7 @@ c_expand_end_cond (void)\n   if_stack_pointer--;\n   if (if_stack[if_stack_pointer].needs_warning)\n     warning (\"%Hsuggest explicit braces to avoid ambiguous `else'\",\n-             &if_stack[if_stack_pointer].locus);\n+\t     &if_stack[if_stack_pointer].locus);\n   last_expr_type = NULL_TREE;\n }\n \n@@ -1183,6 +1194,7 @@ fix_string_type (tree value)\n \t\t\t  build_index_type (build_int_2 (nchars - 1, 0)));\n \n   TREE_CONSTANT (value) = 1;\n+  TREE_INVARIANT (value) = 1;\n   TREE_READONLY (value) = 1;\n   TREE_STATIC (value) = 1;\n   return value;\n@@ -1315,7 +1327,7 @@ convert_and_check (tree type, tree expr)\n \t\t || TYPE_UNSIGNED (type)\n \t\t || ! constant_fits_type_p (expr,\n \t\t\t\t\t    c_common_unsigned_type (type)))\n-\t        && skip_evaluation == 0)\n+\t\t&& skip_evaluation == 0)\n \t      warning (\"overflow in implicit constant conversion\");\n \t}\n       else\n@@ -1851,7 +1863,7 @@ c_common_type_for_mode (enum machine_mode mode, int unsignedp)\n \n   if (mode == TYPE_MODE (widest_integer_literal_type_node))\n     return unsignedp ? widest_unsigned_literal_type_node\n-                     : widest_integer_literal_type_node;\n+\t\t     : widest_integer_literal_type_node;\n \n   if (mode == QImode)\n     return unsignedp ? unsigned_intQI_type_node : intQI_type_node;\n@@ -2473,9 +2485,6 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n {\n   tree size_exp;\n \n-  tree result;\n-  tree folded;\n-\n   /* The result is a pointer of the same type that is being added.  */\n \n   tree result_type = TREE_TYPE (ptrop);\n@@ -2549,13 +2558,7 @@ pointer_int_sum (enum tree_code resultcode, tree ptrop, tree intop)\n \t\t\t\t    convert (TREE_TYPE (intop), size_exp), 1));\n \n   /* Create the sum or difference.  */\n-\n-  result = build (resultcode, result_type, ptrop, intop);\n-\n-  folded = fold (result);\n-  if (folded == result)\n-    TREE_CONSTANT (folded) = TREE_CONSTANT (ptrop) & TREE_CONSTANT (intop);\n-  return folded;\n+  return fold (build (resultcode, result_type, ptrop, intop));\n }\n \f\n /* Prepare expr to be an argument of a TRUTH_NOT_EXPR,\n@@ -2796,13 +2799,58 @@ c_apply_type_quals_to_decl (int type_quals, tree decl)\n     }\n }\n \n+/* Hash function for the problem of multiple type definitions in\n+   different files.  This must hash all types that will compare\n+   equal via comptypes to the same value.  In practice it hashes\n+   on some of the simple stuff and leaves the details to comptypes. */\n+\n+static hashval_t\n+c_type_hash (const void *p)\n+{\n+  int i = 0;\n+  int shift, size;\n+  tree t = (tree)p;\n+  tree t2;\n+  switch (TREE_CODE (t))\n+    {\n+      /* For pointers, hash on pointee type plus some swizzling. */\n+      case POINTER_TYPE:\n+  return c_type_hash (TREE_TYPE (t)) ^ 0x3003003;\n+      /* Hash on number of elements and total size.  */\n+      case ENUMERAL_TYPE:\n+  shift = 3;\n+  t2 = TYPE_VALUES (t);\n+  break;\n+      case RECORD_TYPE:\n+  shift = 0;\n+  t2 = TYPE_FIELDS (t);\n+  break;\n+      case QUAL_UNION_TYPE:\n+  shift = 1;\n+  t2 = TYPE_FIELDS (t);\n+  break;\n+      case UNION_TYPE:\n+  shift = 2;\n+  t2 = TYPE_FIELDS (t);\n+  break;\n+      default:\n+  abort ();\n+    }\n+  for (; t2; t2 = TREE_CHAIN (t2))\n+    i++;\n+  size = TREE_INT_CST_LOW (TYPE_SIZE (t));\n+  return ((size << 24) | (i << shift));\n+}\n+\n /* Return the typed-based alias set for T, which may be an expression\n    or a type.  Return -1 if we don't do anything special.  */\n \n HOST_WIDE_INT\n c_common_get_alias_set (tree t)\n {\n   tree u;\n+  PTR *slot;\n+  static htab_t type_hash_table;\n \n   /* Permit type-punning when accessing a union, provided the access\n      is directly through the union.  For example, this code does not\n@@ -2859,14 +2907,14 @@ c_common_get_alias_set (tree t)\n \t technically, an `int **' and `const int **' cannot point at\n \t the same thing.\n \n-         But, the standard is wrong.  In particular, this code is\n+\t But, the standard is wrong.  In particular, this code is\n \t legal C++:\n \n             int *ip;\n             int **ipp = &ip;\n             const int* const* cipp = ipp;\n \n-         And, it doesn't make sense for that to be legal unless you\n+\t And, it doesn't make sense for that to be legal unless you\n \t can dereference IPP and CIPP.  So, we ignore cv-qualifiers on\n \t the pointed-to types.  This issue has been reported to the\n \t C++ committee.  */\n@@ -2875,6 +2923,63 @@ c_common_get_alias_set (tree t)\n \treturn get_alias_set (t1);\n     }\n \n+  /* Handle the case of multiple type nodes referring to \"the same\" type,\n+     which occurs with IMA.  These share an alias set.  FIXME:  Currently only\n+     C90 is handled.  (In C99 type compatibility is not transitive, which\n+     complicates things mightily. The alias set splay trees can theoretically\n+     represent this, but insertion is tricky when you consider all the\n+     different orders things might arrive in.) */\n+\n+  if (c_language != clk_c || flag_isoc99)\n+    return -1;\n+\n+  /* Save time if there's only one input file. */\n+  if (!current_file_decl || TREE_CHAIN (current_file_decl) == NULL_TREE)\n+    return -1;\n+\n+  /* Pointers need special handling if they point to any type that\n+     needs special handling (below).  */\n+  if (TREE_CODE (t) == POINTER_TYPE)\n+    {\n+      tree t2;\n+      /* Find bottom type under any nested POINTERs.  */\n+      for (t2 = TREE_TYPE (t); \n+     TREE_CODE (t2) == POINTER_TYPE;\n+     t2 = TREE_TYPE (t2))\n+  ;\n+      if (TREE_CODE (t2) != RECORD_TYPE \n+    && TREE_CODE (t2) != ENUMERAL_TYPE\n+    && TREE_CODE (t2) != QUAL_UNION_TYPE\n+    && TREE_CODE (t2) != UNION_TYPE)\n+  return -1;\n+      if (TYPE_SIZE (t2) == 0)\n+  return -1;\n+    }\n+  /* These are the only cases that need special handling.  */\n+  if (TREE_CODE (t) != RECORD_TYPE \n+      && TREE_CODE (t) != ENUMERAL_TYPE\n+      && TREE_CODE (t) != QUAL_UNION_TYPE\n+      && TREE_CODE (t) != UNION_TYPE\n+      && TREE_CODE (t) != POINTER_TYPE)\n+    return -1;\n+  /* Undefined? */\n+  if (TYPE_SIZE (t) == 0)\n+    return -1;\n+\n+  /* Look up t in hash table.  Only one of the compatible types within each \n+     alias set is recorded in the table.  */\n+  if (!type_hash_table)\n+    type_hash_table = htab_create (1021, c_type_hash,\n+\t    (htab_eq) lang_hooks.types_compatible_p,\n+\t    NULL);\n+  slot = htab_find_slot (type_hash_table, t, INSERT);\n+  if (*slot != NULL)\n+    return TYPE_ALIAS_SET ((tree)*slot);\n+  else\n+    /* Our caller will assign and record (in t) a new alias set; all we need\n+       to do is remember t in the hash table.  */\n+    *slot = t;\n+\n   return -1;\n }\n \f\n@@ -3413,7 +3518,7 @@ c_common_nodes_and_builtins (void)\n \t\t\t\t\t\t\t\t\t\\\n       built_in_decls[(int) ENUM] = decl;\t\t\t\t\\\n       if (IMPLICIT)\t\t\t\t\t\t\t\\\n-        implicit_built_in_decls[(int) ENUM] = decl;\t\t\t\\\n+\timplicit_built_in_decls[(int) ENUM] = decl;\t\t\t\\\n     }\n #include \"builtins.def\"\n #undef DEF_BUILTIN\n@@ -3843,19 +3948,12 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n   splay_tree_node node;\n \n   /* Create the LABEL_DECL itself.  */\n-  label = build_decl (LABEL_DECL, NULL_TREE, NULL_TREE);\n-  DECL_CONTEXT (label) = current_function_decl;\n+  label = create_artificial_label ();\n \n   /* If there was an error processing the switch condition, bail now\n      before we get more confused.  */\n   if (!cond || cond == error_mark_node)\n-    {\n-      /* Add a label anyhow so that the back-end doesn't think that\n-\t the beginning of the switch is unreachable.  */\n-      if (!cases->root)\n-\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n-      return error_mark_node;\n-    }\n+    goto error_out;\n \n   if ((low_value && TREE_TYPE (low_value)\n        && POINTER_TYPE_P (TREE_TYPE (low_value)))\n@@ -3881,11 +3979,7 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n \n   /* If an error has occurred, bail out now.  */\n   if (low_value == error_mark_node || high_value == error_mark_node)\n-    {\n-      if (!cases->root)\n-\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n-      return error_mark_node;\n-    }\n+    goto error_out;\n \n   /* If the LOW_VALUE and HIGH_VALUE are the same, then this isn't\n      really a case range, even though it was written that way.  Remove\n@@ -3958,8 +4052,7 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n \t  error (\"multiple default labels in one switch\");\n \t  error (\"%Jthis is the first default label\", duplicate);\n \t}\n-      if (!cases->root)\n-\tadd_stmt (build_case_label (NULL_TREE, NULL_TREE, label));\n+      goto error_out;\n     }\n \n   /* Add a CASE_LABEL to the statement-tree.  */\n@@ -3970,6 +4063,160 @@ c_add_case_label (splay_tree cases, tree cond, tree low_value,\n \t\t     (splay_tree_value) case_label);\n \n   return case_label;\n+\n+ error_out:\n+  /* Add a label so that the back-end doesn't think that the beginning o\n+     the switch is unreachable.  Note that we do not add a case label, as\n+     that just leads to duplicates and thence to aborts later on.  */\n+  if (!cases->root)\n+    {\n+      tree t = create_artificial_label ();\n+      add_stmt (build_stmt (LABEL_STMT, t));\n+    }\n+  return error_mark_node;\n+}\n+\n+/* Subroutines of c_do_switch_warnings, called via splay_tree_foreach.\n+   Used to verify that case values match up with enumerator values.  */\n+\n+static void\n+match_case_to_enum_1 (tree key, tree type, tree label)\n+{\n+  char buf[2 + 2*HOST_BITS_PER_WIDE_INT/4 + 1];\n+\n+  /* ??? Not working too hard to print the double-word value.\n+     Should perhaps be done with %lwd in the diagnostic routines?  */\n+  if (TREE_INT_CST_HIGH (key) == 0)\n+    snprintf (buf, sizeof (buf), HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t      TREE_INT_CST_LOW (key));\n+  else if (!TYPE_UNSIGNED (type)\n+\t   && TREE_INT_CST_HIGH (key) == -1\n+\t   && TREE_INT_CST_LOW (key) != 0)\n+    snprintf (buf, sizeof (buf), \"-\" HOST_WIDE_INT_PRINT_UNSIGNED,\n+\t      -TREE_INT_CST_LOW (key));\n+  else\n+    snprintf (buf, sizeof (buf), HOST_WIDE_INT_PRINT_DOUBLE_HEX,\n+\t      TREE_INT_CST_HIGH (key), TREE_INT_CST_LOW (key));\n+\n+  if (TYPE_NAME (type) == 0)\n+    warning (\"%Jcase value `%s' not in enumerated type\",\n+\t     CASE_LABEL_DECL (label), buf);\n+  else\n+    warning (\"%Jcase value `%s' not in enumerated type `%T'\",\n+\t     CASE_LABEL_DECL (label), buf, type);\n+}\n+\n+static int\n+match_case_to_enum (splay_tree_node node, void *data)\n+{\n+  tree label = (tree) node->value;\n+  tree type = data;\n+\n+  /* Skip default case.  */\n+  if (!CASE_LOW (label))\n+    return 0;\n+\n+  /* If TREE_ADDRESSABLE is not set, that means CASE_LOW did not appear\n+     when we did our enum->case scan.  Reset our scratch bit after.  */\n+  if (!TREE_ADDRESSABLE (label))\n+    match_case_to_enum_1 (CASE_LOW (label), type, label);\n+  else\n+    TREE_ADDRESSABLE (label) = 0;\n+\n+  /* If CASE_HIGH is non-null, we have a range.  Here we must search.\n+     Note that the old code in stmt.c did not check for the values in\n+     the range either, just the endpoints.  */\n+  if (CASE_HIGH (label))\n+    {\n+      tree chain, key = CASE_HIGH (label);\n+\n+      for (chain = TYPE_VALUES (type);\n+\t   chain && !tree_int_cst_equal (key, TREE_VALUE (chain));\n+\t   chain = TREE_CHAIN (chain))\n+\tcontinue;\n+      if (!chain)\n+\tmatch_case_to_enum_1 (key, type, label);\n+    }\n+\n+  return 0;\n+}\n+\n+/* Handle -Wswitch*.  Called from the front end after parsing the switch\n+   construct.  */\n+/* ??? Should probably be somewhere generic, since other languages besides\n+   C and C++ would want this.  We'd want to agree on the datastructure,\n+   however, which is a problem.  Alternately, we operate on gimplified\n+   switch_exprs, which I don't especially like.  At the moment, however,\n+   C/C++ are the only tree-ssa languages that support enumerations at all,\n+   so the point is moot.  */\n+\n+void\n+c_do_switch_warnings (splay_tree cases, tree switch_stmt)\n+{\n+  splay_tree_node default_node;  \n+  location_t *switch_locus;\n+  tree type;\n+\n+  if (!warn_switch && !warn_switch_enum && !warn_switch_default)\n+    return;\n+\n+  switch_locus = EXPR_LOCUS (switch_stmt);\n+  if (!switch_locus)\n+    switch_locus = &input_location;\n+  type = SWITCH_TYPE (switch_stmt);\n+\n+  default_node = splay_tree_lookup (cases, (splay_tree_key) NULL);\n+  if (warn_switch_default && !default_node)\n+    warning (\"%Hswitch missing default case\", switch_locus);\n+\n+  /* If the switch expression was an enumerated type, check that\n+     exactly all enumeration literals are covered by the cases.\n+     The check is made when -Wswitch was specified and there is no\n+     default case, or when -Wswitch-enum was specified.  */\n+  if (((warn_switch && !default_node) || warn_switch_enum)\n+      && type && TREE_CODE (type) == ENUMERAL_TYPE\n+      && TREE_CODE (SWITCH_COND (switch_stmt)) != INTEGER_CST)\n+    {\n+      tree chain;\n+\n+      /* The time complexity here is O(N*lg(N)) worst case, but for the\n+\t common case of monotonically increasing enumerators, it is \n+\t O(N), since the nature of the splay tree will keep the next\n+\t element adjacent to the root at all times.  */\n+\n+      for (chain = TYPE_VALUES (type); chain; chain = TREE_CHAIN (chain))\n+\t{\n+\t  splay_tree_node node\n+\t    = splay_tree_lookup (cases, (splay_tree_key) TREE_VALUE (chain));\n+\n+\t  if (node)\n+\t    {\n+\t      /* Mark the CASE_LOW part of the case entry as seen, so\n+\t\t that we save time later.  Choose TREE_ADDRESSABLE \n+\t\t randomly as a bit that won't have been set to-date.  */\n+\t      tree label = (tree) node->value;\n+\t      TREE_ADDRESSABLE (label) = 1;\n+\t    }\n+\t  else\n+\t    {\n+\t      /* Warn if there are enumerators that don't correspond to\n+\t\t case expressions.  */\n+\t      warning (\"%Henumeration value `%E' not handled in switch\",\n+\t\t       switch_locus, TREE_PURPOSE (chain));\n+\t    }\n+\t}\n+\n+      /* Warn if there are case expressions that don't correspond to\n+\t enumerators.  This can occur since C and C++ don't enforce\n+\t type-checking of assignments to enumeration variables.\n+\n+\t The time complexity here is O(N**2) worst case, since we've\n+\t not sorted the enumeration values.  However, in the absence\n+\t of case ranges this is O(N), since all single cases that \n+\t corresponded to enumerations have been marked above.  */\n+\n+      splay_tree_foreach (cases, match_case_to_enum, type);\n+    }\n }\n \n /* Finish an expression taking the address of LABEL (an\n@@ -3993,7 +4240,6 @@ finish_label_address_expr (tree label)\n     {\n       TREE_USED (label) = 1;\n       result = build1 (ADDR_EXPR, ptr_type_node, label);\n-      TREE_CONSTANT (result) = 1;\n       /* The current function in not necessarily uninlinable.\n \t Computed gotos are incompatible with inlining, but the value\n \t here could be used only in a diagnostic, for example.  */\n@@ -4003,6 +4249,9 @@ finish_label_address_expr (tree label)\n }\n \n /* Hook used by expand_expr to expand language-specific tree codes.  */\n+/* The only things that should go here are bits needed to expand \n+   constant initalizers.  Everything else should be handled by the\n+   gimplification routines.  */\n \n rtx\n c_expand_expr (tree exp, rtx target, enum machine_mode tmode, \n@@ -4011,88 +4260,6 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n {\n   switch (TREE_CODE (exp))\n     {\n-    case STMT_EXPR:\n-      {\n-\ttree rtl_expr;\n-\trtx result;\n-\tbool preserve_result = false;\n-\n-\tif (STMT_EXPR_WARN_UNUSED_RESULT (exp) && target == const0_rtx)\n-\t  {\n-\t    tree stmt = STMT_EXPR_STMT (exp);\n-\t    tree scope;\n-\n-\t    for (scope = COMPOUND_BODY (stmt);\n-\t\t scope && TREE_CODE (scope) != SCOPE_STMT;\n-\t\t scope = TREE_CHAIN (scope));\n-\n-\t    if (scope && SCOPE_STMT_BLOCK (scope))\n-\t      warning (\"%Hignoring return value of `%D', \"\n-\t\t       \"declared with attribute warn_unused_result\",\n-\t\t       &expr_wfl_stack->location,\n-\t\t       BLOCK_ABSTRACT_ORIGIN (SCOPE_STMT_BLOCK (scope)));\n-\t    else\n-\t      warning (\"%Hignoring return value of function \"\n-\t\t       \"declared with attribute warn_unused_result\",\n-\t\t       &expr_wfl_stack->location);\n-\t  }\n-\n-\t/* Since expand_expr_stmt calls free_temp_slots after every\n-\t   expression statement, we must call push_temp_slots here.\n-\t   Otherwise, any temporaries in use now would be considered\n-\t   out-of-scope after the first EXPR_STMT from within the\n-\t   STMT_EXPR.  */\n-\tpush_temp_slots ();\n-\trtl_expr = expand_start_stmt_expr (!STMT_EXPR_NO_SCOPE (exp));\n-\n-\t/* If we want the result of this expression, find the last\n-           EXPR_STMT in the COMPOUND_STMT and mark it as addressable.  */\n-\tif (target != const0_rtx\n-\t    && TREE_CODE (STMT_EXPR_STMT (exp)) == COMPOUND_STMT\n-\t    && TREE_CODE (COMPOUND_BODY (STMT_EXPR_STMT (exp))) == SCOPE_STMT)\n-\t  {\n-\t    tree expr = COMPOUND_BODY (STMT_EXPR_STMT (exp));\n-\t    tree last = TREE_CHAIN (expr);\n-\n-\t    while (TREE_CHAIN (last))\n-\t      {\n-\t\texpr = last;\n-\t\tlast = TREE_CHAIN (last);\n-\t      }\n-\n-\t    if (TREE_CODE (last) == SCOPE_STMT\n-\t\t&& TREE_CODE (expr) == EXPR_STMT)\n-\t      {\n-\t\t/* Otherwise, note that we want the value from the last\n-\t\t   expression.  */\n-\t\tTREE_ADDRESSABLE (expr) = 1;\n-\t\tpreserve_result = true;\n-\t      }\n-\t  }\n-\n-\texpand_stmt (STMT_EXPR_STMT (exp));\n-\texpand_end_stmt_expr (rtl_expr);\n-\n-\tresult = expand_expr_real (rtl_expr, target, tmode, modifier, alt_rtl);\n-\tif (preserve_result && GET_CODE (result) == MEM)\n-\t  {\n-\t    if (GET_MODE (result) != BLKmode)\n-\t      result = copy_to_reg (result);\n-\t    else\n-\t      preserve_temp_slots (result);\n-\t  }\n-\n-\t/* If the statment-expression does not have a scope, then the\n-\t   new temporaries we created within it must live beyond the\n-\t   statement-expression.  */\n-\tif (STMT_EXPR_NO_SCOPE (exp))\n-\t  preserve_temp_slots (NULL_RTX);\n-\n-\tpop_temp_slots ();\n-\treturn result;\n-      }\n-      break;\n-\n     case COMPOUND_LITERAL_EXPR:\n       {\n \t/* Initialize the anonymous variable declared in the compound\n@@ -4105,9 +4272,6 @@ c_expand_expr (tree exp, rtx target, enum machine_mode tmode,\n     default:\n       abort ();\n     }\n-\n-  abort ();\n-  return NULL;\n }\n \n /* Hook used by safe_from_p to handle language-specific tree codes.  */\n@@ -4684,7 +4848,7 @@ handle_section_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n \t      && ! TREE_STATIC (decl))\n \t    {\n \t      error (\"%Jsection attribute cannot be specified for \"\n-                     \"local variables\", decl);\n+\t\t     \"local variables\", decl);\n \t      *no_add_attrs = true;\n \t    }\n \n@@ -4695,7 +4859,7 @@ handle_section_attribute (tree *node, tree name ATTRIBUTE_UNUSED, tree args,\n \t\t\t      TREE_STRING_POINTER (TREE_VALUE (args))) != 0)\n \t    {\n \t      error (\"%Jsection of '%D' conflicts with previous declaration\",\n-                     *node, *node);\n+\t\t     *node, *node);\n \t      *no_add_attrs = true;\n \t    }\n \t  else\n@@ -4848,7 +5012,10 @@ handle_alias_attribute (tree *node, tree name, tree args,\n       if (TREE_CODE (decl) == FUNCTION_DECL)\n \tDECL_INITIAL (decl) = error_mark_node;\n       else\n-\tDECL_EXTERNAL (decl) = 0;\n+\t{\n+\t  DECL_EXTERNAL (decl) = 0;\n+\t  TREE_STATIC (decl) = 1;\n+\t}\n     }\n   else\n     {\n@@ -5191,7 +5358,7 @@ handle_nonnull_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n       if (! TYPE_ARG_TYPES (type))\n \t{\n \t  error (\"nonnull attribute without arguments on a non-prototype\");\n-          *no_add_attrs = true;\n+\t  *no_add_attrs = true;\n \t}\n       return NULL_TREE;\n     }\n@@ -5201,7 +5368,7 @@ handle_nonnull_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n   for (attr_arg_num = 1; args; args = TREE_CHAIN (args))\n     {\n       tree argument;\n-      unsigned HOST_WIDE_INT arg_num, ck_num;\n+      unsigned HOST_WIDE_INT arg_num = 0, ck_num;\n \n       if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n \t{\n@@ -5221,7 +5388,7 @@ handle_nonnull_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n \t      argument = TREE_CHAIN (argument);\n \t    }\n \n-          if (! argument\n+\t  if (! argument\n \t      || TREE_CODE (TREE_VALUE (argument)) == VOID_TYPE)\n \t    {\n \t      error (\"nonnull argument with out-of-range operand number (arg %lu, operand %lu)\",\n@@ -5230,7 +5397,7 @@ handle_nonnull_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n \t      return NULL_TREE;\n \t    }\n \n-          if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n+\t  if (TREE_CODE (TREE_VALUE (argument)) != POINTER_TYPE)\n \t    {\n \t      error (\"nonnull argument references non-pointer operand (arg %lu, operand %lu)\",\n \t\t   (unsigned long) attr_arg_num, (unsigned long) arg_num);\n@@ -5256,22 +5423,22 @@ check_function_nonnull (tree attrs, tree params)\n     {\n       if (is_attribute_p (\"nonnull\", TREE_PURPOSE (a)))\n \t{\n-          args = TREE_VALUE (a);\n+\t  args = TREE_VALUE (a);\n \n-          /* Walk the argument list.  If we encounter an argument number we\n-             should check for non-null, do it.  If the attribute has no args,\n-             then every pointer argument is checked (in which case the check\n+\t  /* Walk the argument list.  If we encounter an argument number we\n+\t     should check for non-null, do it.  If the attribute has no args,\n+\t     then every pointer argument is checked (in which case the check\n \t     for pointer type is done in check_nonnull_arg).  */\n-          for (param = params, param_num = 1; ;\n-               param_num++, param = TREE_CHAIN (param))\n-            {\n-              if (! param)\n+\t  for (param = params, param_num = 1; ;\n+\t       param_num++, param = TREE_CHAIN (param))\n+\t    {\n+\t      if (! param)\n \tbreak;\n-              if (! args || nonnull_check_p (args, param_num))\n+\t      if (! args || nonnull_check_p (args, param_num))\n \tcheck_function_arguments_recurse (check_nonnull_arg, NULL,\n \t\t\t\t\t  TREE_VALUE (param),\n \t\t\t\t\t  param_num);\n-            }\n+\t    }\n \t}\n     }\n }\n@@ -5283,12 +5450,12 @@ check_function_nonnull (tree attrs, tree params)\n static bool\n nonnull_check_p (tree args, unsigned HOST_WIDE_INT param_num)\n {\n-  unsigned HOST_WIDE_INT arg_num;\n+  unsigned HOST_WIDE_INT arg_num = 0;\n \n   for (; args; args = TREE_CHAIN (args))\n     {\n       if (! get_nonnull_operand (TREE_VALUE (args), &arg_num))\n-        abort ();\n+\tabort ();\n \n       if (arg_num == param_num)\n \treturn true;\n@@ -5313,7 +5480,7 @@ check_nonnull_arg (void *ctx ATTRIBUTE_UNUSED, tree param,\n \n   if (integer_zerop (param))\n     warning (\"null argument where non-null required (arg %lu)\",\n-             (unsigned long) param_num);\n+\t     (unsigned long) param_num);\n }\n \n /* Helper for nonnull attribute handling; fetch the operand number\n@@ -5447,7 +5614,7 @@ check_function_arguments_recurse (void (*callback)\n     {\n       /* Strip coercion.  */\n       check_function_arguments_recurse (callback, ctx,\n-\t\t\t\t        TREE_OPERAND (param, 0), param_num);\n+\t\t\t\t\tTREE_OPERAND (param, 0), param_num);\n       return;\n     }\n \n@@ -5509,15 +5676,74 @@ check_function_arguments_recurse (void (*callback)\n     {\n       /* Check both halves of the conditional expression.  */\n       check_function_arguments_recurse (callback, ctx,\n-\t\t\t\t        TREE_OPERAND (param, 1), param_num);\n+\t\t\t\t\tTREE_OPERAND (param, 1), param_num);\n       check_function_arguments_recurse (callback, ctx,\n-\t\t\t\t        TREE_OPERAND (param, 2), param_num);\n+\t\t\t\t\tTREE_OPERAND (param, 2), param_num);\n       return;\n     }\n \n   (*callback) (ctx, param, param_num);\n }\n \n+/* C implementation of lang_hooks.tree_inlining.walk_subtrees.  Tracks the\n+   locus from EXPR_LOCUS and handles DECL_STMT specially.  */\n+\n+tree \n+c_walk_subtrees (tree *tp, int *walk_subtrees_p ATTRIBUTE_UNUSED,\n+\t\t walk_tree_fn func, void *data, void *htab)\n+{\n+  enum tree_code code = TREE_CODE (*tp);\n+  location_t save_locus;\n+  tree result;\n+\n+#define WALK_SUBTREE(NODE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      result = walk_tree (&(NODE), func, data, htab);\t\\\n+      if (result) goto out;\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+  if (code != DECL_STMT)\n+    return NULL_TREE;\n+\n+  /* Set input_location here so we get the right instantiation context\n+     if we call instantiate_decl from inlinable_function_p.  */\n+  save_locus = input_location;\n+  if (EXPR_LOCUS (*tp))\n+    input_location = *EXPR_LOCUS (*tp);\n+\n+  /* Walk the DECL_INITIAL and DECL_SIZE.  We don't want to walk\n+     into declarations that are just mentioned, rather than\n+     declared; they don't really belong to this part of the tree.\n+     And, we can see cycles: the initializer for a declaration can\n+     refer to the declaration itself.  */\n+  WALK_SUBTREE (DECL_INITIAL (DECL_STMT_DECL (*tp)));\n+  WALK_SUBTREE (DECL_SIZE (DECL_STMT_DECL (*tp)));\n+  WALK_SUBTREE (DECL_SIZE_UNIT (DECL_STMT_DECL (*tp)));\n+  WALK_SUBTREE (TREE_CHAIN (*tp));\n+  *walk_subtrees_p = 0;\n+\n+  /* We didn't find what we were looking for.  */\n+ out:\n+  input_location = save_locus;\n+  return result;\n+\n+#undef WALK_SUBTREE\n+}\n+\n+/* C implementation of lang_hooks.tree_inlining.tree_chain_matters_p.\n+   Apart from TREE_LISTs, the only trees whose TREE_CHAIN we care about are\n+   _STMT nodes.  */\n+\n+int\n+c_tree_chain_matters_p (tree t)\n+{\n+  /* For statements, we also walk the chain so that we cover the\n+     entire statement tree.  */\n+  return STATEMENT_CODE_P (TREE_CODE (t));\n+}\n+\n /* Function to help qsort sort FIELD_DECLs by name order.  */\n \n int\n@@ -5573,15 +5799,15 @@ resort_field_decl_cmp (const void *x_p, const void *y_p)\n \n void\n resort_sorted_fields (void *obj,\n-                      void *orig_obj ATTRIBUTE_UNUSED ,\n-                      gt_pointer_operator new_value,\n-                      void *cookie)\n+\t\t      void *orig_obj ATTRIBUTE_UNUSED ,\n+\t\t      gt_pointer_operator new_value,\n+\t\t      void *cookie)\n {\n   struct sorted_fields_type *sf = obj;\n   resort_data.new_value = new_value;\n   resort_data.cookie = cookie;\n   qsort (&sf->elts[0], sf->len, sizeof (tree),\n-         resort_field_decl_cmp);\n+\t resort_field_decl_cmp);\n }\n \n /* Used by estimate_num_insns.  Estimate number of instructions seen\n@@ -5675,14 +5901,12 @@ c_estimate_num_insns_1 (tree *tp, int *walk_subtrees, void *data)\n     case EXIT_EXPR:\n     case LABELED_BLOCK_EXPR:\n     case EXIT_BLOCK_EXPR:\n-    case EXPR_WITH_FILE_LOCATION:\n \n     case EXPR_STMT:\n     case COMPOUND_STMT:\n     case RETURN_STMT:\n     case LABEL_STMT:\n     case SCOPE_STMT:\n-    case FILE_STMT:\n     case CASE_LABEL:\n     case STMT_EXPR:\n     case CLEANUP_STMT:\n@@ -5711,37 +5935,6 @@ c_estimate_num_insns (tree decl)\n   return num;\n }\n \n-/* Used by c_decl_uninit to find where expressions like x = x + 1; */\n-\n-static tree\n-c_decl_uninit_1 (tree *t, int *walk_sub_trees, void *x)\n-{\n-  /* If x = EXP(&x)EXP, then do not warn about the use of x.  */\n-  if (TREE_CODE (*t) == ADDR_EXPR && TREE_OPERAND (*t, 0) == x)\n-    {\n-      *walk_sub_trees = 0;\n-      return NULL_TREE;\n-    }\n-  if (*t == x)\n-    return *t;\n-  return NULL_TREE;\n-}\n-\n-/* Find out if a variable is uninitialized based on DECL_INITIAL.  */\n-\n-bool\n-c_decl_uninit (tree t)\n-{\n-  /* int x = x; is GCC extension to turn off this warning, only if warn_init_self is zero.  */\n-  if (DECL_INITIAL (t) == t)\n-    return warn_init_self ? true : false;\n-\n-  /* Walk the trees looking for the variable itself.  */\n-  if (walk_tree_without_duplicates (&DECL_INITIAL (t), c_decl_uninit_1, t))\n-    return true;\n-  return false;\n-}\n-\n /* Issue the error given by MSGID, indicating that it occurred before\n    TOKEN, which had the associated VALUE.  */\n \n@@ -5774,4 +5967,74 @@ c_parse_error (const char *msgid, enum cpp_ttype token, tree value)\n     error (\"%s\", string);\n }\n \n+/* Walk a gimplified function and warn for functions whose return value is\n+   ignored and attribute((warn_unused_result)) is set.  This is done before\n+   inlining, so we don't have to worry about that.  */  \n+   \n+void\n+c_warn_unused_result (tree *top_p)\n+{\n+  tree t = *top_p;\n+  tree_stmt_iterator i;\n+  tree fdecl, ftype;\n+\n+  switch (TREE_CODE (t))\n+    {\n+    case STATEMENT_LIST:\n+      for (i = tsi_start (*top_p); !tsi_end_p (i); tsi_next (&i))\n+\tc_warn_unused_result (tsi_stmt_ptr (i));\n+      break;\n+\n+    case COND_EXPR:\n+      c_warn_unused_result (&COND_EXPR_THEN (t));\n+      c_warn_unused_result (&COND_EXPR_ELSE (t));\n+      break;\n+    case BIND_EXPR:\n+      c_warn_unused_result (&BIND_EXPR_BODY (t));\n+      break;\n+    case TRY_FINALLY_EXPR:\n+    case TRY_CATCH_EXPR:\n+      c_warn_unused_result (&TREE_OPERAND (t, 0));\n+      c_warn_unused_result (&TREE_OPERAND (t, 1));\n+      break;\n+    case CATCH_EXPR:\n+      c_warn_unused_result (&CATCH_BODY (t));\n+      break;\n+    case EH_FILTER_EXPR:\n+      c_warn_unused_result (&EH_FILTER_FAILURE (t));\n+      break;\n+\n+    case CALL_EXPR:\n+      /* This is a naked call, as opposed to a CALL_EXPR nested inside\n+\t a MODIFY_EXPR.  All calls whose value is ignored should be\n+\t represented like this.  Look for the attribute.  */\n+      fdecl = get_callee_fndecl (t);\n+      if (fdecl)\n+\tftype = TREE_TYPE (fdecl);\n+      else\n+\t{\n+\t  ftype = TREE_TYPE (TREE_OPERAND (t, 0));\n+\t  /* Look past pointer-to-function to the function type itself.  */\n+\t  ftype = TREE_TYPE (ftype);\n+\t}\n+\n+      if (lookup_attribute (\"warn_unused_result\", TYPE_ATTRIBUTES (ftype)))\n+\t{\n+\t  if (fdecl)\n+\t    warning (\"%Hignoring return value of `%D', \"\n+\t\t     \"declared with attribute warn_unused_result\",\n+\t\t     EXPR_LOCUS (t), fdecl);\n+\t  else\n+\t    warning (\"%Hignoring return value of function \"\n+\t\t     \"declared with attribute warn_unused_result\",\n+\t\t     EXPR_LOCUS (t));\n+\t}\n+      break;\n+\n+    default:\n+      /* Not a container, not a call, or a call whose value is used.  */\n+      break;\n+    }\n+}\n+\n #include \"gt-c-common.h\""}, {"sha": "3282cc603e4645aed2672bbf24678db036ec2be7", "filename": "gcc/c-common.def", "status": "modified", "additions": 1, "deletions": 5, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -79,7 +79,7 @@ DEFTREECODE (GOTO_STMT, \"goto_stmt\", 'e', 1)\n DEFTREECODE (LABEL_STMT, \"label_stmt\", 'e', 1)\n \n /* Used to represent an inline assembly statement.  */\n-DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n+DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 4)\n \n /* A SCOPE_STMT marks the beginning or end of a scope.  If\n    SCOPE_BEGIN_P holds, then this is the start of a scope.  If\n@@ -89,10 +89,6 @@ DEFTREECODE (ASM_STMT, \"asm_stmt\", 'e', 5)\n    variables declared in this scope.  */\n DEFTREECODE (SCOPE_STMT, \"scope_stmt\", 'e', 1)\n \n-/* A FILE_STMT marks the spot where a function changes files.  It has no\n-   other semantics.  FILE_STMT_FILENAME gives the name.  */\n-DEFTREECODE (FILE_STMT, \"file_stmt\", 'e', 1)\n-\n /* Used to represent a CASE_LABEL. The operands are CASE_LOW and\n    CASE_HIGH, respectively. If CASE_LOW is NULL_TREE, the label is a\n    'default' label. If CASE_HIGH is NULL_TREE, the label is a normal case"}, {"sha": "7499910442840005ccde6385a18df4bbabf97844", "filename": "gcc/c-common.h", "status": "modified", "additions": 16, "deletions": 83, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -37,10 +37,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n       STMT_EXPR_NO_SCOPE (in STMT_EXPR)\n    1: C_DECLARED_LABEL_FLAG (in LABEL_DECL)\n       STMT_IS_FULL_EXPR_P (in _STMT)\n-   2: STMT_LINENO_FOR_FN_P (in _STMT)\n+   2: unused\n    3: SCOPE_NO_CLEANUPS_P (in SCOPE_STMT)\n       COMPOUND_STMT_BODY_BLOCK (in COMPOUND_STMT)\n-      STMT_EXPR_WARN_UNUSED_RESULT (in STMT_EXPR)\n    4: SCOPE_PARTIAL_P (in SCOPE_STMT)\n */\n \n@@ -321,8 +320,7 @@ struct c_language_function GTY(()) {\n \n /* Language-specific hooks.  */\n \n-extern void (*lang_expand_stmt) (tree);\n-extern void (*lang_expand_decl_stmt) (tree);\n+extern int (*lang_gimplify_stmt) (tree *, tree *);\n extern void (*lang_expand_function_end) (void);\n \n /* Callback that determines if it's ok for a function to have no\n@@ -342,7 +340,6 @@ extern void finish_stmt_tree (tree *);\n \n extern tree walk_stmt_tree (tree *, walk_tree_fn, void *);\n extern void prep_stmt (tree);\n-extern void expand_stmt (tree);\n extern tree c_begin_if_stmt (void);\n extern tree c_begin_while_stmt (void);\n extern void c_finish_while_stmt_cond (tree, tree);\n@@ -999,22 +996,9 @@ extern void finish_file\t(void);\n #define FOR_EXPR(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 2)\n #define FOR_BODY(NODE)          TREE_OPERAND (FOR_STMT_CHECK (NODE), 3)\n \n-/* SWITCH_STMT accessors. These give access to the condition, body and\n-   original condition type (before any compiler conversions)\n-   of the switch statement, respectively.  */\n-#define SWITCH_COND(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 0)\n-#define SWITCH_BODY(NODE)       TREE_OPERAND (SWITCH_STMT_CHECK (NODE), 1)\n #define SWITCH_TYPE(NODE)\tTREE_OPERAND (SWITCH_STMT_CHECK (NODE), 2)\n-\n-/* CASE_LABEL accessors. These give access to the high and low values\n-   of a case label, respectively.  */\n-#define CASE_LOW(NODE)          TREE_OPERAND (CASE_LABEL_CHECK (NODE), 0)\n-#define CASE_HIGH(NODE)         TREE_OPERAND (CASE_LABEL_CHECK (NODE), 1)\n #define CASE_LABEL_DECL(NODE)   TREE_OPERAND (CASE_LABEL_CHECK (NODE), 2)\n \n-/* GOTO_STMT accessor. This gives access to the label associated with\n-   a goto statement.  */\n-#define GOTO_DESTINATION(NODE)  TREE_OPERAND (GOTO_STMT_CHECK (NODE), 0)\n /* True for goto created artificially by the compiler.  */\n #define GOTO_FAKE_P(NODE)\t(TREE_LANG_FLAG_0 (GOTO_STMT_CHECK (NODE)))\n \n@@ -1024,16 +1008,6 @@ extern void finish_file\t(void);\n    calling TREE_CHAIN on a node in the list.  */\n #define COMPOUND_BODY(NODE)     TREE_OPERAND (COMPOUND_STMT_CHECK (NODE), 0)\n \n-/* ASM_STMT accessors. ASM_STRING returns a STRING_CST for the\n-   instruction (e.g., \"mov x, y\"). ASM_OUTPUTS, ASM_INPUTS, and\n-   ASM_CLOBBERS represent the outputs, inputs, and clobbers for the\n-   statement.  */\n-#define ASM_CV_QUAL(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 0)\n-#define ASM_STRING(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 1)\n-#define ASM_OUTPUTS(NODE)       TREE_OPERAND (ASM_STMT_CHECK (NODE), 2)\n-#define ASM_INPUTS(NODE)        TREE_OPERAND (ASM_STMT_CHECK (NODE), 3)\n-#define ASM_CLOBBERS(NODE)      TREE_OPERAND (ASM_STMT_CHECK (NODE), 4)\n-\n /* DECL_STMT accessor. This gives access to the DECL associated with\n    the given declaration statement.  */\n #define DECL_STMT_DECL(NODE)    TREE_OPERAND (DECL_STMT_CHECK (NODE), 0)\n@@ -1045,11 +1019,6 @@ extern void finish_file\t(void);\n #define STMT_EXPR_NO_SCOPE(NODE) \\\n    TREE_LANG_FLAG_0 (STMT_EXPR_CHECK (NODE))\n \n-/* Nonzero if this statement-expression should cause warning if its result\n-   is not used.  */\n-#define STMT_EXPR_WARN_UNUSED_RESULT(NODE) \\\n-   TREE_LANG_FLAG_3 (STMT_EXPR_CHECK (NODE))\n-\n /* LABEL_STMT accessor. This gives access to the label associated with\n    the given label statement.  */\n #define LABEL_STMT_LABEL(NODE)  TREE_OPERAND (LABEL_STMT_CHECK (NODE), 0)\n@@ -1097,42 +1066,17 @@ extern void finish_file\t(void);\n #define SCOPE_PARTIAL_P(NODE) \\\n   (TREE_LANG_FLAG_4 (SCOPE_STMT_CHECK (NODE)))\n \n-/* Nonzero for an ASM_STMT if the assembly statement is volatile.  */\n-#define ASM_VOLATILE_P(NODE)\t\t\t\\\n-  (ASM_CV_QUAL (ASM_STMT_CHECK (NODE)) != NULL_TREE)\n-\n /* The VAR_DECL to clean up in a CLEANUP_STMT.  */\n #define CLEANUP_DECL(NODE) \\\n   TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 0)\n /* The cleanup to run in a CLEANUP_STMT.  */\n #define CLEANUP_EXPR(NODE) \\\n   TREE_OPERAND (CLEANUP_STMT_CHECK (NODE), 1)\n \n-/* The filename we are changing to as of this FILE_STMT.  */\n-#define FILE_STMT_FILENAME_NODE(NODE) \\\n-  (TREE_OPERAND (FILE_STMT_CHECK (NODE), 0))\n-#define FILE_STMT_FILENAME(NODE) \\\n-  (IDENTIFIER_POINTER (FILE_STMT_FILENAME_NODE (NODE)))\n-\n-/* The line-number at which a statement began.  But if\n-   STMT_LINENO_FOR_FN_P does holds, then this macro gives the\n-   line number for the end of the current function instead.  */\n-#define STMT_LINENO(NODE)\t\t\t\\\n-  (TREE_COMPLEXITY ((NODE)))\n-\n-/* If nonzero, the STMT_LINENO for NODE is the line at which the\n-   function ended.  */\n-#define STMT_LINENO_FOR_FN_P(NODE)\t\t\\\n-  (TREE_LANG_FLAG_2 ((NODE)))\n-\n /* Nonzero if we want the new ISO rules for pushing a new scope for `for'\n    initialization variables.  */\n #define NEW_FOR_SCOPE_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n \n-/* Nonzero if we want to create an ASM_INPUT instead of an\n-   ASM_OPERAND with no operands.  */\n-#define ASM_INPUT_P(NODE) (TREE_LANG_FLAG_0 (NODE))\n-\n #define DEFTREECODE(SYM, NAME, TYPE, LENGTH) SYM,\n \n enum c_tree_code {\n@@ -1149,7 +1093,7 @@ enum c_tree_code {\n    WHILE_STMT,\t\tDO_STMT,\tRETURN_STMT,\t\\\n    BREAK_STMT,\t\tCONTINUE_STMT,\tSCOPE_STMT,\t\\\n    SWITCH_STMT,\t\tGOTO_STMT,\tLABEL_STMT,\t\\\n-   ASM_STMT,\t\tFILE_STMT,\tCASE_LABEL\n+   ASM_STMT,\t\tCASE_LABEL\n \n /* TRUE if a code represents a statement.  The front end init\n    langhook should take care of initialization of this array.  */\n@@ -1165,24 +1109,6 @@ extern bool statement_code_p[MAX_TREE_CODES];\n       statement_code_p[STMT_CODES[i]] = true;\t\t\t\\\n   } while (0)\n \n-extern void genrtl_do_pushlevel (void);\n-extern void genrtl_goto_stmt (tree);\n-extern void genrtl_expr_stmt (tree);\n-extern void genrtl_expr_stmt_value (tree, int, int);\n-extern void genrtl_decl_stmt (tree);\n-extern void genrtl_if_stmt (tree);\n-extern void genrtl_while_stmt (tree);\n-extern void genrtl_do_stmt (tree);\n-extern void genrtl_return_stmt (tree);\n-extern void genrtl_for_stmt (tree);\n-extern void genrtl_break_stmt (void);\n-extern void genrtl_continue_stmt (void);\n-extern void genrtl_scope_stmt (tree);\n-extern void genrtl_switch_stmt (tree);\n-extern void genrtl_case_label (tree);\n-extern void genrtl_compound_stmt (tree);\n-extern void genrtl_asm_stmt (tree, tree, tree, tree, tree, int);\n-extern void genrtl_cleanup_stmt (tree);\n extern int stmts_are_full_exprs_p (void);\n extern int anon_aggr_type_p (tree);\n \n@@ -1198,13 +1124,8 @@ extern int anon_aggr_type_p (tree);\n #define CLEAR_DECL_C_BIT_FIELD(NODE) \\\n   (DECL_LANG_FLAG_4 (FIELD_DECL_CHECK (NODE)) = 0)\n \n-/* In a VAR_DECL, nonzero if the decl is a register variable with\n-   an explicit asm specification.  */\n-#define DECL_C_HARD_REGISTER(DECL)  DECL_LANG_FLAG_4 (VAR_DECL_CHECK (DECL))\n-\n extern void emit_local_var (tree);\n extern void make_rtl_for_local_static (tree);\n-extern tree expand_cond (tree);\n extern tree c_expand_return (tree);\n extern tree do_case (tree, tree);\n extern tree build_stmt (enum tree_code, ...);\n@@ -1249,6 +1170,8 @@ extern int case_compare (splay_tree_key, splay_tree_key);\n \n extern tree c_add_case_label (splay_tree, tree, tree, tree);\n \n+extern void c_do_switch_warnings (splay_tree, tree);\n+\n extern tree build_function_call (tree, tree);\n \n extern tree finish_label_address_expr (tree);\n@@ -1289,6 +1212,17 @@ extern void dump_time_statistics (void);\n \n extern bool c_dump_tree (void *, tree);\n \n+extern int c_gimplify_expr (tree *, tree *, tree *);\n+extern tree c_walk_subtrees (tree*, int*, walk_tree_fn, void*, void*);\n+extern int c_tree_chain_matters_p (tree);\n+\n+extern void c_warn_unused_result (tree *);\n+\n+/* In c-simplify.c  */\n+extern void c_genericize (tree);\n+extern int c_gimplify_stmt (tree *);\n+extern tree stmt_expr_last_stmt (tree);\n+\n extern void pch_init (void);\n extern int c_common_valid_pch (cpp_reader *pfile, const char *name, int fd);\n extern void c_common_read_pch (cpp_reader *pfile, const char *name, int fd,\n@@ -1299,7 +1233,6 @@ extern void builtin_define_with_value (const char *, const char *, int);\n extern void c_stddef_cpp_builtins (void);\n extern void fe_file_change (const struct line_map *);\n extern int c_estimate_num_insns (tree decl);\n-extern bool c_decl_uninit (tree t);\n extern void c_parse_error (const char *, enum cpp_ttype, tree);\n \n /* The following have been moved here from c-tree.h, since they're needed"}, {"sha": "3067137c372c5f739b3ff7bdc71ccf61426a7775", "filename": "gcc/c-convert.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-convert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-convert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-convert.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -114,6 +114,9 @@ convert (tree type, tree expr)\n     return fold (convert_to_complex (type, e));\n   if (code == VECTOR_TYPE)\n     return fold (convert_to_vector (type, e));\n+  if ((code == RECORD_TYPE || code == UNION_TYPE)\n+      && lang_hooks.types_compatible_p (type, TREE_TYPE (expr)))\n+      return e;\n \n   error (\"conversion to non-scalar type requested\");\n   return error_mark_node;"}, {"sha": "d0fc708ea052911298fce3be2d238d95650d0611", "filename": "gcc/c-decl.c", "status": "modified", "additions": 163, "deletions": 66, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-decl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -49,6 +49,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"timevar.h\"\n #include \"c-common.h\"\n #include \"c-pragma.h\"\n+#include \"langhooks.h\"\n+#include \"tree-mudflap.h\"\n+#include \"tree-simple.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-dump.h\"\n #include \"cgraph.h\"\n #include \"hashtab.h\"\n #include \"libfuncs.h\"\n@@ -1664,7 +1669,7 @@ merge_decls (tree newdecl, tree olddecl, tree newtype, tree oldtype)\n static bool\n duplicate_decls (tree newdecl, tree olddecl)\n {\n-  tree newtype, oldtype;\n+  tree newtype = NULL, oldtype = NULL;\n \n   if (!diagnose_mismatched_decls (newdecl, olddecl, &newtype, &oldtype))\n     return false;\n@@ -2113,10 +2118,6 @@ lookup_label (tree name)\n    any that may be inherited from containing functions or containing\n    scopes.  This is called for __label__ declarations.  */\n \n-/* Note that valid use, if the label being shadowed comes from another\n-   scope in the same function, requires calling declare_nonlocal_label\n-   right away.  (Is this still true?  -zw 2003-07-17)  */\n-\n tree\n declare_label (tree name)\n {\n@@ -2936,7 +2937,7 @@ finish_decl (tree decl, tree init, tree asmspec_tree)\n \t\t in a particular register.  */\n \t      if (C_DECL_REGISTER (decl))\n \t\t{\n-\t\t  DECL_C_HARD_REGISTER (decl) = 1;\n+\t\t  DECL_HARD_REGISTER (decl) = 1;\n \t\t  /* This cannot be done for a structure with volatile\n \t\t     fields, on which DECL_REGISTER will have been\n \t\t     reset.  */\n@@ -3304,11 +3305,14 @@ check_bitfield_type_and_width (tree *type, tree *width, const char *orig_name)\n   else\n     w = tree_low_cst (*width, 1);\n \n-  if (TREE_CODE (*type) == ENUMERAL_TYPE\n-      && (w < min_precision (TYPE_MIN_VALUE (*type), TYPE_UNSIGNED (*type))\n-\t  || w < min_precision (TYPE_MAX_VALUE (*type),\n-\t\t\t\tTYPE_UNSIGNED (*type))))\n-    warning (\"`%s' is narrower than values of its type\", name);\n+  if (TREE_CODE (*type) == ENUMERAL_TYPE)\n+    {\n+      struct lang_type *lt = TYPE_LANG_SPECIFIC (*type);\n+      if (!lt \n+          || w < min_precision (lt->enum_min, TYPE_UNSIGNED (*type))\n+\t  || w < min_precision (lt->enum_max, TYPE_UNSIGNED (*type)))\n+\twarning (\"`%s' is narrower than values of its type\", name);\n+    }\n }\n \f\n /* Given declspecs and a declarator,\n@@ -4059,6 +4063,11 @@ grokdeclarator (tree declarator, tree declspecs,\n \t      TYPE_SIZE (type) = bitsize_zero_node;\n \t      TYPE_SIZE_UNIT (type) = size_zero_node;\n \t    }\n+\t  else if (declarator && TREE_CODE (declarator) == INDIRECT_REF)\n+\t    /* We can never complete an array type which is the target of a\n+\t       pointer, so go ahead and lay it out.  */\n+\t    layout_type (type);\n+\n \t  if (decl_context != PARM\n \t      && (array_ptr_quals != NULL_TREE || array_parm_static))\n \t    {\n@@ -5251,7 +5260,7 @@ finish_struct (tree t, tree fieldlist, tree attributes)\n           ensure that this lives as long as the rest of the struct decl.\n           All decls in an inline function need to be saved.  */\n \n-        space = ggc_alloc (sizeof (struct lang_type));\n+        space = ggc_alloc_cleared (sizeof (struct lang_type));\n         space2 = ggc_alloc (sizeof (struct sorted_fields_type) + len * sizeof (tree));\n \n         len = 0;\n@@ -5386,9 +5395,10 @@ tree\n finish_enum (tree enumtype, tree values, tree attributes)\n {\n   tree pair, tem;\n-  tree minnode = 0, maxnode = 0, enum_value_type;\n+  tree minnode = 0, maxnode = 0;\n   int precision, unsign;\n   bool toplevel = (file_scope == current_scope);\n+  struct lang_type *lt;\n \n   decl_attributes (&enumtype, attributes, (int) ATTR_FLAG_TYPE_IN_PLACE);\n \n@@ -5418,27 +5428,20 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \t\t   min_precision (maxnode, unsign));\n   if (TYPE_PACKED (enumtype) || precision > TYPE_PRECISION (integer_type_node))\n     {\n-      tree narrowest = c_common_type_for_size (precision, unsign);\n-      if (narrowest == 0)\n+      tem = c_common_type_for_size (precision, unsign);\n+      if (tem == NULL)\n \t{\n \t  warning (\"enumeration values exceed range of largest integer\");\n-\t  narrowest = long_long_integer_type_node;\n+\t  tem = long_long_integer_type_node;\n \t}\n-\n-      precision = TYPE_PRECISION (narrowest);\n     }\n   else\n-    precision = TYPE_PRECISION (integer_type_node);\n-\n-  if (precision == TYPE_PRECISION (integer_type_node))\n-    enum_value_type = c_common_type_for_size (precision, 0);\n-  else\n-    enum_value_type = enumtype;\n+    tem = unsign ? unsigned_type_node : integer_type_node;\n \n-  TYPE_MIN_VALUE (enumtype) = minnode;\n-  TYPE_MAX_VALUE (enumtype) = maxnode;\n-  TYPE_PRECISION (enumtype) = precision;\n-  TYPE_UNSIGNED (enumtype) = unsign;\n+  TYPE_MIN_VALUE (enumtype) = TYPE_MIN_VALUE (tem);\n+  TYPE_MAX_VALUE (enumtype) = TYPE_MAX_VALUE (tem);\n+  TYPE_PRECISION (enumtype) = TYPE_PRECISION (tem);\n+  TYPE_UNSIGNED (enumtype) = TYPE_UNSIGNED (tem);\n   TYPE_SIZE (enumtype) = 0;\n   layout_type (enumtype);\n \n@@ -5454,6 +5457,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       for (pair = values; pair; pair = TREE_CHAIN (pair))\n \t{\n \t  tree enu = TREE_PURPOSE (pair);\n+\t  tree ini = DECL_INITIAL (enu);\n \n \t  TREE_TYPE (enu) = enumtype;\n \n@@ -5464,18 +5468,27 @@ finish_enum (tree enumtype, tree values, tree attributes)\n \t     when comparing integers with enumerators that fit in the\n \t     int range.  When -pedantic is given, build_enumerator()\n \t     would have already taken care of those that don't fit.  */\n-\t  if (int_fits_type_p (DECL_INITIAL (enu), enum_value_type))\n-\t    DECL_INITIAL (enu) = convert (enum_value_type, DECL_INITIAL (enu));\n+\t  if (int_fits_type_p (ini, integer_type_node))\n+\t    tem = integer_type_node;\n \t  else\n-\t    DECL_INITIAL (enu) = convert (enumtype, DECL_INITIAL (enu));\n+\t    tem = enumtype;\n+\t  ini = convert (tem, ini);\n \n+\t  DECL_INITIAL (enu) = ini;\n \t  TREE_PURPOSE (pair) = DECL_NAME (enu);\n-\t  TREE_VALUE (pair) = DECL_INITIAL (enu);\n+\t  TREE_VALUE (pair) = ini;\n \t}\n \n       TYPE_VALUES (enumtype) = values;\n     }\n \n+  /* Record the min/max values so that we can warn about bit-field\n+     enumerations that are too small for the values.  */\n+  lt = ggc_alloc_cleared (sizeof (struct lang_type));\n+  lt->enum_min = minnode;\n+  lt->enum_max = maxnode;\n+  TYPE_LANG_SPECIFIC (enumtype) = lt;\n+\n   /* Fix up all variant types of this enum type.  */\n   for (tem = TYPE_MAIN_VARIANT (enumtype); tem; tem = TYPE_NEXT_VARIANT (tem))\n     {\n@@ -5491,6 +5504,7 @@ finish_enum (tree enumtype, tree values, tree attributes)\n       TYPE_ALIGN (tem) = TYPE_ALIGN (enumtype);\n       TYPE_USER_ALIGN (tem) = TYPE_USER_ALIGN (enumtype);\n       TYPE_UNSIGNED (tem) = TYPE_UNSIGNED (enumtype);\n+      TYPE_LANG_SPECIFIC (tem) = TYPE_LANG_SPECIFIC (enumtype);\n     }\n \n   /* Finish debugging output for this type.  */\n@@ -6085,6 +6099,25 @@ store_parm_decls_oldstyle (tree fndecl, tree arg_info)\n     }\n }\n \n+/* A subroutine of store_parm_decls called via walk_tree.  Mark all\n+   decls non-local.  */\n+\n+static tree\n+set_decl_nonlocal (tree *tp, int *walk_subtrees, void *data ATTRIBUTE_UNUSED)\n+{\n+  tree t = *tp;\n+\n+  if (DECL_P (t))\n+    {\n+      DECL_NONLOCAL (t) = 1;\n+      *walk_subtrees = 0;\n+    }\n+  else if (TYPE_P (t))\n+    *walk_subtrees = 0;\n+\n+  return NULL;\n+}\n+\n /* Store the parameter declarations into the current function declaration.\n    This is called after parsing the parameter declarations, before\n    digesting the body of the function.\n@@ -6142,7 +6175,14 @@ store_parm_decls (void)\n       for (t = DECL_LANG_SPECIFIC (fndecl)->pending_sizes;\n \t   t;\n \t   t = TREE_CHAIN (t))\n-\tSAVE_EXPR_CONTEXT (TREE_VALUE (t)) = context;\n+\t{\n+\t  /* We will have a nonlocal use of whatever variables are\n+\t     buried inside here.  */\n+\t  walk_tree (&TREE_OPERAND (TREE_VALUE (t), 0),\n+\t\t     set_decl_nonlocal, NULL, NULL);\n+\n+\t  SAVE_EXPR_CONTEXT (TREE_VALUE (t)) = context;\n+\t}\n     }\n \n   /* This function is being processed in whole-function mode.  */\n@@ -6156,6 +6196,32 @@ store_parm_decls (void)\n   cfun->x_dont_save_pending_sizes_p = 1;\n }\n \f\n+/* Give FNDECL and all its nested functions to cgraph for compilation.  */\n+\n+static void\n+c_finalize (tree fndecl)\n+{\n+  struct cgraph_node *cgn;\n+\n+  /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n+  c_warn_unused_result (&DECL_SAVED_TREE (fndecl));\n+\n+  /* ??? Objc emits functions after finalizing the compilation unit.\n+     This should be cleaned up later and this conditional removed.  */\n+  if (cgraph_global_info_ready)\n+    {\n+      c_expand_body (fndecl);\n+      return;\n+    }\n+\n+  /* Finalize all nested functions now.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    c_finalize (cgn->decl);\n+\n+  cgraph_finalize_function (fndecl, false);\n+}\n+\n /* Finish up a function declaration and compile that function\n    all the way to assembler language output.  The free the storage\n    for the function definition.\n@@ -6253,17 +6319,44 @@ finish_function (void)\n       && current_function_returns_null)\n     warning (\"this function may return with or without a value\");\n \n+  /* Store the end of the function, so that we get good line number\n+     info for the epilogue.  */\n+  cfun->function_end_locus = input_location;\n+\n+  /* If we don't have ctors/dtors sections, and this is a static\n+     constructor or destructor, it must be recorded now.  */\n+  if (DECL_STATIC_CONSTRUCTOR (fndecl)\n+      && !targetm.have_ctors_dtors)\n+    static_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n+  if (DECL_STATIC_DESTRUCTOR (fndecl)\n+      && !targetm.have_ctors_dtors)\n+    static_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n+\n+  /* Genericize before inlining.  Delay genericizing nested functions\n+     until their parent function is genericized.  Since finalizing\n+     requires GENERIC, delay that as well.  */\n+     \n+  if (DECL_INITIAL (fndecl) && DECL_INITIAL (fndecl) != error_mark_node)\n+    {\n+      if (!decl_function_context (fndecl))\n+        {\n+          c_genericize (fndecl);\n+\t  lower_nested_functions (fndecl);\n+          c_finalize (fndecl);\n+        }\n+      else\n+        {\n+          /* Register this function with cgraph just far enough to get it\n+            added to our parent's nested function list.  Handy, since the\n+            C front end doesn't have such a list.  */\n+          (void) cgraph_node (fndecl);\n+        }\n+    }\n+\n   /* We're leaving the context of this function, so zap cfun.\n-     It's still in DECL_STRUCT_FUNCTION , and we'll restore it in\n+     It's still in DECL_STRUCT_FUNCTION, and we'll restore it in\n      tree_rest_of_compilation.  */\n   cfun = NULL;\n-\n-  /* ??? Objc emits functions after finalizing the compilation unit.\n-     This should be cleaned up later and this conditional removed.  */\n-  if (!cgraph_global_info_ready)\n-    cgraph_finalize_function (fndecl, false);\n-  else\n-    c_expand_body (fndecl);\n   current_function_decl = NULL;\n }\n \n@@ -6290,23 +6383,14 @@ c_expand_body_1 (tree fndecl, int nested_p)\n     /* Return to the enclosing function.  */\n     pop_function_context ();\n \n-  if (DECL_STATIC_CONSTRUCTOR (fndecl))\n-    {\n-      if (targetm.have_ctors_dtors)\n-\ttargetm.asm_out.constructor (XEXP (DECL_RTL (fndecl), 0),\n-\t\t\t\t     DEFAULT_INIT_PRIORITY);\n-      else\n-\tstatic_ctors = tree_cons (NULL_TREE, fndecl, static_ctors);\n-    }\n-\n-  if (DECL_STATIC_DESTRUCTOR (fndecl))\n-    {\n-      if (targetm.have_ctors_dtors)\n-\ttargetm.asm_out.destructor (XEXP (DECL_RTL (fndecl), 0),\n-\t\t\t\t    DEFAULT_INIT_PRIORITY);\n-      else\n-\tstatic_dtors = tree_cons (NULL_TREE, fndecl, static_dtors);\n-    }\n+  if (DECL_STATIC_CONSTRUCTOR (fndecl)\n+      && targetm.have_ctors_dtors)\n+    targetm.asm_out.constructor (XEXP (DECL_RTL (fndecl), 0),\n+\t\t\t\t DEFAULT_INIT_PRIORITY);\n+  if (DECL_STATIC_DESTRUCTOR (fndecl)\n+      && targetm.have_ctors_dtors)\n+    targetm.asm_out.destructor (XEXP (DECL_RTL (fndecl), 0),\n+\t\t\t\tDEFAULT_INIT_PRIORITY);\n }\n \n /* Like c_expand_body_1 but only for unnested functions.  */\n@@ -6512,19 +6596,32 @@ c_begin_compound_stmt (void)\n   return stmt;\n }\n \n-/* Expand T (a DECL_STMT) if it declares an entity not handled by the\n+/* Expand DECL if it declares an entity not handled by the\n    common code.  */\n \n-void\n-c_expand_decl_stmt (tree t)\n+int\n+c_expand_decl (tree decl)\n {\n-  tree decl = DECL_STMT_DECL (t);\n-\n+  if (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl))\n+    {\n+      /* Let the back-end know about this variable.  */\n+      if (!anon_aggr_type_p (TREE_TYPE (decl)))\n+\temit_local_var (decl);\n+      else\n+\texpand_anon_union_decl (decl, NULL_TREE, \n+\t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+    make_rtl_for_local_static (decl);\n   /* Expand nested functions.  */\n-  if (TREE_CODE (decl) == FUNCTION_DECL\n-      && DECL_CONTEXT (decl) == current_function_decl\n-      && DECL_SAVED_TREE (decl))\n+  else if (TREE_CODE (decl) == FUNCTION_DECL\n+\t   && DECL_CONTEXT (decl) == current_function_decl\n+\t   && DECL_SAVED_TREE (decl))\n     c_expand_body_1 (decl, 1);\n+  else\n+    return 0;\n+\n+  return 1;\n }\n \n /* Return the global value of T as a symbol.  */"}, {"sha": "859d85041693f98c332163c57e91e246710eee8e", "filename": "gcc/c-dump.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-dump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-dump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-dump.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -32,7 +32,9 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n void\n dump_stmt (dump_info_p di, tree t)\n {\n-  dump_int (di, \"line\", STMT_LINENO (t));\n+  location_t *locus = EXPR_LOCUS (t);\n+  if (locus)\n+    dump_int (di, \"line\", locus->line);\n }\n \n /* Dump the next statement after STMT.  */"}, {"sha": "17ef68a608a4f064c70583b5b9853201ff85a568", "filename": "gcc/c-format.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-format.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-format.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-format.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -86,7 +86,7 @@ handle_format_arg_attribute (tree *node, tree name ATTRIBUTE_UNUSED,\n {\n   tree type = *node;\n   tree format_num_expr = TREE_VALUE (args);\n-  unsigned HOST_WIDE_INT format_num;\n+  unsigned HOST_WIDE_INT format_num = 0;\n   tree argument;\n \n   if (!get_constant (format_num_expr, &format_num, 0))"}, {"sha": "cf422cb3cc5717ca1e3b45008ca6fe0376607a18", "filename": "gcc/c-lang.c", "status": "modified", "additions": 23, "deletions": 7, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-lang.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -30,6 +30,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"ggc.h\"\n #include \"langhooks.h\"\n #include \"langhooks-def.h\"\n+#include \"tree-inline.h\"\n #include \"diagnostic.h\"\n #include \"c-pretty-print.h\"\n \n@@ -63,6 +64,8 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n #undef LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR c_expand_expr\n+#undef LANG_HOOKS_EXPAND_DECL\n+#define LANG_HOOKS_EXPAND_DECL c_expand_decl\n #undef LANG_HOOKS_MARK_ADDRESSABLE\n #define LANG_HOOKS_MARK_ADDRESSABLE c_mark_addressable\n #undef LANG_HOOKS_PARSE_FILE\n@@ -89,34 +92,35 @@ enum c_language_kind c_language = clk_c;\n #define LANG_HOOKS_FUNCTION_ENTER_NESTED c_push_function_context\n #undef LANG_HOOKS_FUNCTION_LEAVE_NESTED\n #define LANG_HOOKS_FUNCTION_LEAVE_NESTED c_pop_function_context\n+#undef LANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P\n+#define LANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P c_missing_noreturn_ok_p\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL c_dup_lang_specific_decl\n-#undef LANG_HOOKS_DECL_UNINIT\n-#define LANG_HOOKS_DECL_UNINIT c_decl_uninit\n-\n-#undef LANG_HOOKS_RTL_EXPAND_STMT\n-#define LANG_HOOKS_RTL_EXPAND_STMT expand_stmt\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n #define LANG_HOOKS_COMMON_ATTRIBUTE_TABLE c_common_attribute_table\n #undef LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE\n #define LANG_HOOKS_FORMAT_ATTRIBUTE_TABLE c_common_format_attribute_table\n \n+#undef LANG_HOOKS_TREE_INLINING_WALK_SUBTREES\n+#define LANG_HOOKS_TREE_INLINING_WALK_SUBTREES \\\n+  c_walk_subtrees\n #undef LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN\n #define LANG_HOOKS_TREE_INLINING_CANNOT_INLINE_TREE_FN \\\n   c_cannot_inline_tree_fn\n #undef LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS\n #define LANG_HOOKS_TREE_INLINING_DISREGARD_INLINE_LIMITS \\\n   c_disregard_inline_limits\n+#undef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n+#define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n+  c_tree_chain_matters_p\n #undef LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P \\\n   anon_aggr_type_p\n #undef LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING\n #define LANG_HOOKS_TREE_INLINING_CONVERT_PARM_FOR_INLINING \\\n   c_convert_parm_for_inlining\n-#undef LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS\n-#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS c_estimate_num_insns\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN c_dump_tree\n \n@@ -156,6 +160,13 @@ enum c_language_kind c_language = clk_c;\n #undef LANG_HOOKS_WRITE_GLOBALS\n #define LANG_HOOKS_WRITE_GLOBALS c_write_global_declarations\n \n+/* Hooks for tree gimplification.  */\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#define LANG_HOOKS_GIMPLIFY_EXPR c_gimplify_expr\n+\n+#undef LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P c_types_compatible_p\n+\n /* ### When changing hooks, consider if ObjC needs changing too!! ### */\n \n /* Each front end provides its own.  */\n@@ -202,6 +213,11 @@ finish_file (void)\n   c_objc_common_finish_file ();\n }\n \n+int\n+c_types_compatible_p (tree x, tree y)\n+{\n+    return comptypes (TYPE_MAIN_VARIANT (x), TYPE_MAIN_VARIANT (y), 0);\n+}\n static void\n c_initialize_diagnostics (diagnostic_context *context)\n {"}, {"sha": "e2fa5b1a438a0c72d291bc02e42203e4ff2d3aa0", "filename": "gcc/c-mudflap.c", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-mudflap.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,100 @@\n+/* Mudflap: narrow-pointer bounds-checking by tree rewriting:\n+   C front-end interface.\n+\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Frank Ch. Eigler <fche@redhat.com>\n+   and Graydon Hoare <graydon@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"errors.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"c-tree.h\"\n+#include \"c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"output.h\"\n+#include \"varray.h\"\n+#include \"tree-mudflap.h\"\n+#include \"target.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"toplev.h\"\n+#include \"function.h\"\n+\n+\n+\n+/* ------------------------------------------------------------------------ */\n+\n+\n+/* Initialize the global tree nodes that correspond to mf-runtime.h\n+   declarations.  */\n+tree\n+mflang_lookup_decl (const char* name)\n+{\n+  tree decl = lookup_name (get_identifier (name));\n+  if (decl == NULL_TREE)\n+    internal_error (\"mudflap: cannot find declaration of `%s' from mf-runtime.h\",\n+\t\t    name);\n+\n+  return decl;\n+}\n+\n+\n+/* Emit a synthetic CTOR function for the current file.  Populate it from\n+   the enqueued __mf_register calls.  Compile the function.  */\n+\n+void\n+mflang_flush_calls (tree enqueued_call_stmt_chain)\n+{\n+  tree fnname, t1, t2, body, block, scope;\n+\n+  /* Short-circuit!  */\n+  if (enqueued_call_stmt_chain == NULL_TREE)\n+    return;\n+\n+  fnname = get_identifier (\"__mudflap_static_initializer\");\n+  t1 = build_tree_list (NULL_TREE, void_type_node);\n+  t2 = tree_cons (NULL, NULL, t1);\n+  start_function (t1, build_nt (CALL_EXPR, fnname, t2, NULL), NULL);\n+  store_parm_decls ();\n+\n+  DECL_STATIC_CONSTRUCTOR (current_function_decl) = 1;\n+  TREE_PUBLIC (current_function_decl) = 0;\n+  TREE_USED (current_function_decl) = 1;\n+  mf_mark (current_function_decl);\n+\n+  body = c_begin_compound_stmt ();\n+  push_scope ();\n+  clear_last_expr ();\n+  add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n+\n+  c_expand_expr_stmt (enqueued_call_stmt_chain);\n+\n+  scope = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n+  block = pop_scope ();\n+  SCOPE_STMT_BLOCK (TREE_PURPOSE (scope)) = block;\n+  SCOPE_STMT_BLOCK (TREE_VALUE (scope)) = block;\n+  RECHAIN_STMTS (body, COMPOUND_BODY (body));\n+  finish_function ();\n+}"}, {"sha": "f7e7c8acb104d20fe56fe2f74b453f20c3aa809a", "filename": "gcc/c-objc-common.c", "status": "modified", "additions": 24, "deletions": 43, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-objc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-objc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-objc-common.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -36,14 +36,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"varray.h\"\n #include \"ggc.h\"\n #include \"langhooks.h\"\n+#include \"tree-mudflap.h\"\n #include \"target.h\"\n #include \"cgraph.h\"\n \n static bool c_tree_printer (pretty_printer *, text_info *);\n-static tree start_cdtor (int);\n-static void finish_cdtor (tree);\n \n-int\n+bool\n c_missing_noreturn_ok_p (tree decl)\n {\n   /* A missing noreturn is not ok for freestanding implementations and\n@@ -166,13 +165,10 @@ c_objc_common_init (void)\n   if (c_common_init () == false)\n     return false;\n \n-  lang_expand_decl_stmt = c_expand_decl_stmt;\n-\n   /* These were not defined in the Objective-C front end, but I'm\n      putting them here anyway.  The diagnostic format decoder might\n      want an enhanced ObjC implementation.  */\n   diagnostic_format_decoder (global_dc) = &c_tree_printer;\n-  lang_missing_noreturn_ok_p = &c_missing_noreturn_ok_p;\n \n   /* If still unspecified, make it match -std=c99\n      (allowing for -pedantic-errors).  */\n@@ -187,40 +183,33 @@ c_objc_common_init (void)\n   return true;\n }\n \n-static tree\n-start_cdtor (int method_type)\n+/* Synthesize a function which calls all the global ctors or global dtors\n+   in this file.  */\n+static void\n+build_cdtor (int method_type, tree cdtors)\n {\n   tree fnname = get_file_function_name (method_type);\n-  tree void_list_node_1 = build_tree_list (NULL_TREE, void_type_node);\n   tree body;\n+  tree scope;\n+  tree block;\n \n-  start_function (void_list_node_1,\n+  start_function (void_list_node,\n \t\t  build_nt (CALL_EXPR, fnname,\n-\t\t\t    tree_cons (NULL_TREE, NULL_TREE, void_list_node_1),\n+\t\t\t    tree_cons (NULL_TREE, NULL_TREE, void_list_node),\n \t\t\t    NULL_TREE),\n \t\t  NULL_TREE);\n   store_parm_decls ();\n \n-  current_function_cannot_inline\n-    = \"static constructors and destructors cannot be inlined\";\n-\n   body = c_begin_compound_stmt ();\n-\n-  push_scope ();\n-  clear_last_expr ();\n   add_scope_stmt (/*begin_p=*/1, /*partial_p=*/0);\n \n-  return body;\n-}\n-\n-static void\n-finish_cdtor (tree body)\n-{\n-  tree scope;\n-  tree block;\n+  for (; cdtors; cdtors = TREE_CHAIN (cdtors))\n+    add_stmt (build_stmt (EXPR_STMT,\n+\t\t\t  build_function_call (TREE_VALUE (cdtors), 0)));\n \n   scope = add_scope_stmt (/*begin_p=*/0, /*partial_p=*/0);\n-  block = pop_scope ();\n+\n+  block = make_node (BLOCK);\n   SCOPE_STMT_BLOCK (TREE_PURPOSE (scope)) = block;\n   SCOPE_STMT_BLOCK (TREE_VALUE (scope)) = block;\n \n@@ -237,30 +226,22 @@ c_objc_common_finish_file (void)\n   if (pch_file)\n     c_common_write_pch ();\n \n-  cgraph_finalize_compilation_unit ();\n-  cgraph_optimize ();\n-\n   if (static_ctors)\n     {\n-      tree body = start_cdtor ('I');\n-\n-      for (; static_ctors; static_ctors = TREE_CHAIN (static_ctors))\n-\tc_expand_expr_stmt (build_function_call (TREE_VALUE (static_ctors),\n-\t\t\t\t\t\t NULL_TREE));\n-\n-      finish_cdtor (body);\n+      build_cdtor ('I', static_ctors);\n+      static_ctors = 0;\n     }\n-\n   if (static_dtors)\n     {\n-      tree body = start_cdtor ('D');\n+      build_cdtor ('D', static_dtors);\n+      static_dtors = 0;\n+    }\n \n-      for (; static_dtors; static_dtors = TREE_CHAIN (static_dtors))\n-\tc_expand_expr_stmt (build_function_call (TREE_VALUE (static_dtors),\n-\t\t\t\t\t\t NULL_TREE));\n+  cgraph_finalize_compilation_unit ();\n+  cgraph_optimize ();\n \n-      finish_cdtor (body);\n-    }\n+  if (flag_mudflap)\n+    mudflap_finish_file ();\n }\n \n /* Called during diagnostic message formatting process to print a"}, {"sha": "1300b69cd0b18fafbc87cca8358e66301d256ee3", "filename": "gcc/c-opts.c", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-opts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-opts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-opts.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -733,11 +733,6 @@ c_common_handle_option (size_t scode, const char *arg, int value)\n       cpp_opts->dollars_in_ident = value;\n       break;\n \n-    case OPT_fdump_:\n-      if (!dump_switch_p (arg))\n-\tresult = 0;\n-      break;\n-\n     case OPT_ffreestanding:\n       value = !value;\n       /* Fall through....  */\n@@ -1100,17 +1095,13 @@ c_common_post_options (const char **pfilename)\n \n   flag_inline_trees = 1;\n \n-  /* Use tree inlining if possible.  Function instrumentation is only\n-     done in the RTL level, so we disable tree inlining.  */\n-  if (! flag_instrument_function_entry_exit)\n+  /* Use tree inlining.  */\n+  if (!flag_no_inline)\n+    flag_no_inline = 1;\n+  if (flag_inline_functions)\n     {\n-      if (!flag_no_inline)\n-\tflag_no_inline = 1;\n-      if (flag_inline_functions)\n-\t{\n-\t  flag_inline_trees = 2;\n-\t  flag_inline_functions = 0;\n-\t}\n+      flag_inline_trees = 2;\n+      flag_inline_functions = 0;\n     }\n \n   /* -Wextra implies -Wsign-compare, but not if explicitly"}, {"sha": "07854c48d6b504365966a9fb4b82d3a9e90e1e03", "filename": "gcc/c-parse.in", "status": "modified", "additions": 7, "deletions": 9, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-parse.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-parse.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-parse.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -661,6 +661,7 @@ primary:\n \t\t    last_expr_type = void_type_node;\n \t\t  $$ = build1 (STMT_EXPR, last_expr_type, $1);\n \t\t  TREE_SIDE_EFFECTS ($$) = 1;\n+\t\t  annotate_with_locus ($$, input_location);\n \t\t}\n \t| compstmt_primary_start error ')'\n \t\t{\n@@ -2130,7 +2131,7 @@ simple_if:\n \n if_prefix:\n \t  /* We must build the IF_STMT node before parsing its\n-\t     condition so that STMT_LINENO refers to the line\n+\t     condition so that EXPR_LOCUS refers to the line\n \t     containing the \"if\", and not the line containing\n \t     the close-parenthesis.\n \n@@ -2194,12 +2195,8 @@ lineno_stmt:\n \t  save_location stmt\n \t\t{ if ($2)\n \t\t    {\n-\t\t      STMT_LINENO ($2) = $1.line;\n-\t\t      /* ??? We currently have no way of recording\n-\t\t\t the filename for a statement.  This probably\n-\t\t\t matters little in practice at the moment,\n-\t\t\t but I suspect that problems will occur when\n-\t\t\t doing inlining at the tree level.  */\n+\t\t      SET_EXPR_LOCUS ($2, NULL);\n+\t\t      annotate_with_locus ($2, $1);\n \t\t    }\n \t\t}\n \t;\n@@ -2208,7 +2205,8 @@ lineno_label:\n \t  save_location label\n \t\t{ if ($2)\n \t\t    {\n-\t\t      STMT_LINENO ($2) = $1.line;\n+\t\t      SET_EXPR_LOCUS ($2, NULL);\n+\t\t      annotate_with_locus ($2, $1);\n \t\t    }\n \t\t}\n \t;\n@@ -2237,7 +2235,7 @@ select_or_iter_stmt:\n \t| simple_if ELSE error\n \t\t{ c_expand_end_cond (); }\n        /* We must build the WHILE_STMT node before parsing its\n-\t  condition so that STMT_LINENO refers to the line\n+\t  condition so that EXPR_LOCUS refers to the line\n \t  containing the \"while\", and not the line containing\n \t  the close-parenthesis.\n "}, {"sha": "31a17a109d21cc21e6db4eba9c1c1db4a71e8457", "filename": "gcc/c-pragma.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pragma.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pragma.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pragma.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -352,7 +352,6 @@ maybe_apply_pragma_weak (tree decl ATTRIBUTE_UNUSED)\n \n static GTY(()) tree pending_redefine_extname;\n \n-#ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n static void handle_pragma_redefine_extname (cpp_reader *);\n \n /* #pragma redefined_extname oldname newname */\n@@ -388,7 +387,6 @@ handle_pragma_redefine_extname (cpp_reader *dummy ATTRIBUTE_UNUSED)\n   else\n     add_to_renaming_pragma_list(oldname, newname);\n }\n-#endif\n \n void\n add_to_renaming_pragma_list (tree oldname, tree newname)\n@@ -502,6 +500,9 @@ init_pragma (void)\n #endif\n #ifdef HANDLE_PRAGMA_REDEFINE_EXTNAME\n   c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n+#else\n+  if (flag_mudflap)\n+    c_register_pragma (0, \"redefine_extname\", handle_pragma_redefine_extname);\n #endif\n #ifdef HANDLE_PRAGMA_EXTERN_PREFIX\n   c_register_pragma (0, \"extern_prefix\", handle_pragma_extern_prefix);"}, {"sha": "e73ab1b51e37ac640aefe7c5e5090fb8b910b808", "filename": "gcc/c-pretty-print.c", "status": "modified", "additions": 110, "deletions": 39, "changes": 149, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -26,6 +26,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"real.h\"\n #include \"c-pretty-print.h\"\n #include \"c-tree.h\"\n+#include \"diagnostic.h\"\n \n /* The pretty-printer code is primarily designed to closely follow\n    (GNU) C and C++ grammars.  That is to be contrasted with spaghetti\n@@ -280,7 +281,7 @@ pp_c_type_specifier (c_pretty_printer *pp, tree t)\n       break;\n \n     case IDENTIFIER_NODE:\n-      pp_c_tree_identifier (pp, t);\n+      pp_c_tree_decl_identifier (pp, t);\n       break;\n \n     case VOID_TYPE:\n@@ -561,11 +562,10 @@ pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n     case TYPE_DECL:\n     case FIELD_DECL:\n     case LABEL_DECL:\n-      if (DECL_NAME (t))\n-        {\n-          pp_c_space_for_pointer_operator (pp, TREE_TYPE (t));\n-          pp_c_tree_identifier (pp, DECL_NAME (t));\n-        }\n+      pp_c_space_for_pointer_operator (pp, TREE_TYPE (t));\n+      pp_c_tree_decl_identifier (pp, t);\n+      break;\n+\n     case ARRAY_TYPE:\n     case POINTER_TYPE:\n       pp_abstract_declarator (pp, TREE_TYPE (t));\n@@ -578,7 +578,7 @@ pp_c_direct_declarator (c_pretty_printer *pp, tree t)\n \n     case FUNCTION_DECL:\n       pp_c_space_for_pointer_operator (pp, TREE_TYPE (TREE_TYPE (t)));\n-      pp_c_tree_identifier (pp, DECL_NAME (t));\n+      pp_c_tree_decl_identifier (pp, t);\n       if (pp_c_base (pp)->flags & pp_c_flag_abstract)\n         pp_abstract_declarator (pp, TREE_TYPE (t));\n       else\n@@ -960,8 +960,9 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n     case CONST_DECL:\n     case FUNCTION_DECL:\n     case LABEL_DECL:\n-      e = DECL_NAME (e);\n-      /* Fall through.  */\n+      pp_c_tree_decl_identifier (pp, e);\n+      break;\n+\n     case IDENTIFIER_NODE:\n       pp_c_tree_identifier (pp, e);\n       break;\n@@ -980,6 +981,22 @@ pp_c_primary_expression (c_pretty_printer *pp, tree e)\n       pp_c_constant (pp, e);\n       break;\n \n+    case TARGET_EXPR:\n+      pp_c_identifier (pp, \"__builtin_memcpy\");\n+      pp_c_left_paren (pp);\n+      pp_ampersand (pp);\n+      pp_primary_expression (pp, TREE_OPERAND (e, 0));\n+      pp_separate_with (pp, ',');\n+      pp_ampersand (pp);\n+      pp_initializer (pp, TREE_OPERAND (e, 1));\n+      if (TREE_OPERAND (e, 2))\n+\t{\n+\t  pp_separate_with (pp, ',');\n+\t  pp_c_expression (pp, TREE_OPERAND (e, 2));\n+\t}\n+      pp_c_right_paren (pp);\n+      break;\n+\n     case STMT_EXPR:\n       pp_c_left_paren (pp);\n       pp_statement (pp, STMT_EXPR_STMT (e));\n@@ -1005,13 +1022,7 @@ static void\n pp_c_initializer (c_pretty_printer *pp, tree e)\n {\n   if (TREE_CODE (e) == CONSTRUCTOR)\n-    {\n-      enum tree_code code = TREE_CODE (TREE_TYPE (e));\n-      if (code == RECORD_TYPE || code == UNION_TYPE || code == ARRAY_TYPE)\n-        pp_c_brace_enclosed_initializer_list (pp, e);\n-      else\n-\tpp_unsupported_tree (pp, TREE_OPERAND (e, 1));\n-    }\n+    pp_c_brace_enclosed_initializer_list (pp, e);\n   else\n     pp_expression (pp, e);\n }\n@@ -1099,25 +1110,36 @@ pp_c_initializer_list (c_pretty_printer *pp, tree e)\n               pp_separate_with (pp, ',');\n           }\n       }\n-      break;\n+      return;\n \n     case VECTOR_TYPE:\n-      pp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n-      break;\n+      if (TREE_CODE (e) == VECTOR_CST)\n+        pp_c_expression_list (pp, TREE_VECTOR_CST_ELTS (e));\n+      else if (TREE_CODE (e) == CONSTRUCTOR)\n+        pp_c_expression_list (pp, CONSTRUCTOR_ELTS (e));\n+      else\n+        break;\n+      return;\n \n     case COMPLEX_TYPE:\n-      {\n-        const bool cst = TREE_CODE (e) == COMPLEX_CST;\n-        pp_expression (pp, cst ? TREE_REALPART (e) : TREE_OPERAND (e, 0));\n-        pp_separate_with (pp, ',');\n-        pp_expression (pp, cst ? TREE_IMAGPART (e) : TREE_OPERAND (e, 1));\n-      }\n-      break;\n+      if (TREE_CODE (e) == CONSTRUCTOR)\n+\tpp_c_expression_list (pp, CONSTRUCTOR_ELTS (e));\n+      else if (TREE_CODE (e) == COMPLEX_CST || TREE_CODE (e) == COMPLEX_EXPR)\n+\t{\n+\t  const bool cst = TREE_CODE (e) == COMPLEX_CST;\n+\t  pp_expression (pp, cst ? TREE_REALPART (e) : TREE_OPERAND (e, 0));\n+\t  pp_separate_with (pp, ',');\n+\t  pp_expression (pp, cst ? TREE_IMAGPART (e) : TREE_OPERAND (e, 1));\n+\t}\n+      else\n+\tbreak;\n+      return;\n \n     default:\n-      pp_unsupported_tree (pp, type);\n       break;\n     }\n+\n+  pp_unsupported_tree (pp, type);\n }\n \n /* Pretty-print a brace-enclosed initializer-list.  */\n@@ -1149,7 +1171,9 @@ pp_c_id_expression (c_pretty_printer *pp, tree t)\n     case FUNCTION_DECL:\n     case FIELD_DECL:\n     case LABEL_DECL:\n-      t = DECL_NAME (t);\n+      pp_c_tree_decl_identifier (pp, t);\n+      break;\n+\n     case IDENTIFIER_NODE:\n       pp_c_tree_identifier (pp, t);\n       break;\n@@ -1862,7 +1886,7 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       else\n         pp_indentation (pp) -= 3;\n       if (code == LABEL_STMT)\n-\tpp_tree_identifier (pp, DECL_NAME (LABEL_STMT_LABEL (stmt)));\n+\tpp_c_tree_decl_identifier (pp, LABEL_STMT_LABEL (stmt));\n       else if (code == CASE_LABEL)\n \t{\n \t  if (CASE_LOW (stmt) == NULL_TREE)\n@@ -2121,16 +2145,6 @@ pp_c_statement (c_pretty_printer *pp, tree stmt)\n       }\n       break;\n \n-    case FILE_STMT:\n-      pp_c_identifier (pp, \"__FILE__\");\n-      pp_space (pp);\n-      pp_equal (pp);\n-      pp_c_whitespace (pp);\n-      pp_c_identifier (pp, FILE_STMT_FILENAME (stmt));\n-      pp_c_semicolon (pp);\n-      pp_needs_newline (pp) = true;\n-      break;\n-\n     default:\n       pp_unsupported_tree (pp, stmt);\n     }\n@@ -2170,3 +2184,60 @@ pp_c_pretty_printer_init (c_pretty_printer *pp)\n   pp->assignment_expression     = pp_c_assignment_expression;\n   pp->expression                = pp_c_expression;\n }\n+\n+\n+/* Print the tree T in full, on file FILE.  */\n+\n+void\n+print_c_tree (FILE *file, tree t)\n+{\n+  static c_pretty_printer pp_rec;\n+  static bool initialized = 0;\n+  c_pretty_printer *pp = &pp_rec;\n+\n+  if (!initialized)\n+    {\n+      initialized = 1;\n+      pp_construct (pp_base (pp), NULL, 0);\n+      pp_c_pretty_printer_init (pp);\n+      pp_needs_newline (pp) = true;\n+    }\n+  pp_base (pp)->buffer->stream = file;\n+\n+  pp_statement (pp, t);\n+\n+  pp_newline (pp);\n+  pp_flush (pp);\n+}\n+\n+/* Print the tree T in full, on stderr.  */\n+\n+void\n+debug_c_tree (tree t)\n+{\n+  print_c_tree (stderr, t);\n+  fputc ('\\n', stderr);\n+}\n+\n+/* Output the DECL_NAME of T.  If T has no DECL_NAME, output a string made\n+   up of T's memory address.  */\n+\n+void\n+pp_c_tree_decl_identifier (c_pretty_printer *pp, tree t)\n+{\n+  const char *name;\n+\n+  if (!DECL_P (t))\n+    abort ();\n+\n+  if (DECL_NAME (t))\n+    name = IDENTIFIER_POINTER (DECL_NAME (t));\n+  else\n+    {\n+      static char xname[8];\n+      sprintf (xname, \"<U%4x>\", ((unsigned)((unsigned long)(t) & 0xffff)));\n+      name = xname;\n+    }\n+\n+  pp_c_identifier (pp, name);\n+}"}, {"sha": "efffa234d4bf180ee760fa7a96fd45a9bbd3daaa", "filename": "gcc/c-pretty-print.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-pretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-pretty-print.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -95,7 +95,7 @@ struct c_pretty_print_info\n #undef pp_base\n #define pp_base(PP)  (&pp_c_base (PP)->base)\n \n-     \n+\n #define pp_c_tree_identifier(PPI, ID)              \\\n    pp_c_identifier (PPI, IDENTIFIER_POINTER (ID))\n \n@@ -166,6 +166,7 @@ void pp_c_semicolon (c_pretty_printer *);\n void pp_c_space_for_pointer_operator (c_pretty_printer *, tree);\n \n /* Declarations.  */\n+void pp_c_tree_decl_identifier (c_pretty_printer *, tree);\n void pp_c_function_definition (c_pretty_printer *, tree);\n void pp_c_attributes (c_pretty_printer *, tree);\n void pp_c_type_qualifier_list (c_pretty_printer *, tree);\n@@ -197,4 +198,6 @@ void pp_c_id_expression (c_pretty_printer *, tree);\n void pp_c_identifier (c_pretty_printer *, const char *);\n void pp_c_string_literal (c_pretty_printer *, tree);\n \n+void print_c_tree (FILE *file, tree t);\n+\n #endif /* GCC_C_PRETTY_PRINTER */"}, {"sha": "b74fda6302a50564ad1e6de3c1f9ea2c1a9d41a1", "filename": "gcc/c-semantics.c", "status": "modified", "additions": 34, "deletions": 790, "changes": 824, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-semantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-semantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-semantics.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -44,23 +44,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"timevar.h\"\n #include \"predict.h\"\n #include \"tree-inline.h\"\n-\n-/* If non-NULL, the address of a language-specific function for\n-   expanding statements.  */\n-void (*lang_expand_stmt) (tree);\n-\n-/* If non-NULL, the address of a language-specific function for\n-   expanding a DECL_STMT.  After the language-independent cases are\n-   handled, this function will be called.  If this function is not\n-   defined, it is assumed that declarations other than those for\n-   variables and labels do not require any RTL generation.  */\n-void (*lang_expand_decl_stmt) (tree);\n-\n-static tree find_reachable_label_1 (tree *, int *, void *);\n-static tree find_reachable_label (tree);\n-static bool expand_unreachable_if_stmt (tree);\n-static tree expand_unreachable_stmt (tree, int);\n-static void genrtl_do_stmt_1 (tree, tree);\n+#include \"langhooks.h\"\n \n /* Create an empty statement tree rooted at T.  */\n \n@@ -81,18 +65,8 @@ begin_stmt_tree (tree *t)\n tree\n add_stmt (tree t)\n {\n-  if (input_filename != last_expr_filename)\n-    {\n-      /* If the filename has changed, also add in a FILE_STMT.  Do a string\n-\t compare first, though, as it might be an equivalent string.  */\n-      int add = (strcmp (input_filename, last_expr_filename) != 0);\n-      last_expr_filename = input_filename;\n-      if (add)\n-\t{\n-\t  tree pos = build_nt (FILE_STMT, get_identifier (input_filename));\n-\t  add_stmt (pos);\n-\t}\n-    }\n+  if (!EXPR_LOCUS (t))\n+    annotate_with_locus (t, input_location);\n \n   /* Add T to the statement-tree.  */\n   TREE_CHAIN (last_tree) = t;\n@@ -171,58 +145,53 @@ finish_stmt_tree (tree *t)\n   stmt = TREE_CHAIN (*t);\n   *t = stmt;\n   last_tree = NULL_TREE;\n-\n-  if (cfun && stmt)\n-    {\n-      /* The line-number recorded in the outermost statement in a function\n-\t is the line number of the end of the function.  */\n-      STMT_LINENO (stmt) = input_line;\n-      STMT_LINENO_FOR_FN_P (stmt) = 1;\n-    }\n }\n \n /* Build a generic statement based on the given type of node and\n    arguments. Similar to `build_nt', except that we set\n-   STMT_LINENO to be the current line number.  */\n+   EXPR_LOCUS to be the current source location.  */\n /* ??? This should be obsolete with the lineno_stmt productions\n    in the grammar.  */\n \n tree\n build_stmt (enum tree_code code, ...)\n {\n-  tree t;\n-  int length;\n-  int i;\n+  tree ret;\n+  int length, i;\n   va_list p;\n+  bool side_effects;\n \n   va_start (p, code);\n \n-  t = make_node (code);\n+  ret = make_node (code);\n   length = TREE_CODE_LENGTH (code);\n-  STMT_LINENO (t) = input_line;\n-\n-  for (i = 0; i < length; i++)\n-    TREE_OPERAND (t, i) = va_arg (p, tree);\n-\n-  va_end (p);\n-  return t;\n-}\n+  annotate_with_locus (ret, input_location);\n \n-/* Some statements, like for-statements or if-statements, require a\n-   condition.  This condition can be a declaration.  If T is such a\n-   declaration it is processed, and an expression appropriate to use\n-   as the condition is returned.  Otherwise, T itself is returned.  */\n+  /* Most statements have implicit side effects all on their own, \n+     such as control transfer.  For those that do, we'll compute\n+     the real value of TREE_SIDE_EFFECTS from its arguments.  */\n+  switch (code)\n+    {\n+    case EXPR_STMT:\n+      side_effects = false;\n+      break;\n+    default:\n+      side_effects = true;\n+      break;\n+    }\n \n-tree\n-expand_cond (tree t)\n-{\n-  if (t && TREE_CODE (t) == TREE_LIST)\n+  for (i = 0; i < length; i++)\n     {\n-      expand_stmt (TREE_PURPOSE (t));\n-      return TREE_VALUE (t);\n+      tree t = va_arg (p, tree);\n+      if (t && IS_NON_TYPE_CODE_CLASS (TREE_CODE_CLASS (TREE_CODE (t))))\n+        side_effects |= TREE_SIDE_EFFECTS (t);\n+      TREE_OPERAND (ret, i) = t;\n     }\n-  else\n-    return t;\n+\n+  TREE_SIDE_EFFECTS (ret) = side_effects;\n+\n+  va_end (p);\n+  return ret;\n }\n \n /* Create RTL for the local static variable DECL.  */\n@@ -268,7 +237,7 @@ emit_local_var (tree decl)\n   /* Create RTL for this variable.  */\n   if (!DECL_RTL_SET_P (decl))\n     {\n-      if (DECL_C_HARD_REGISTER (decl))\n+      if (DECL_HARD_REGISTER (decl))\n \t/* The user specified an assembler name for this variable.\n \t   Set that up now.  */\n \trest_of_decl_compilation\n@@ -291,214 +260,6 @@ emit_local_var (tree decl)\n     }\n }\n \n-/* Helper for generating the RTL at the beginning of a scope.  */\n-\n-void\n-genrtl_do_pushlevel (void)\n-{\n-  emit_line_note (input_location);\n-  clear_last_expr ();\n-}\n-\n-/* Generate the RTL for DESTINATION, which is a GOTO_STMT.  */\n-\n-void\n-genrtl_goto_stmt (tree destination)\n-{\n-  if (TREE_CODE (destination) == IDENTIFIER_NODE)\n-    abort ();\n-\n-  /* We warn about unused labels with -Wunused.  That means we have to\n-     mark the used labels as used.  */\n-  if (TREE_CODE (destination) == LABEL_DECL)\n-    TREE_USED (destination) = 1;\n-\n-  emit_line_note (input_location);\n-\n-  if (TREE_CODE (destination) == LABEL_DECL)\n-    {\n-      label_rtx (destination);\n-      expand_goto (destination);\n-    }\n-  else\n-    expand_computed_goto (destination);\n-}\n-\n-/* Generate the RTL for EXPR, which is an EXPR_STMT.  Provided just\n-   for backward compatibility.  genrtl_expr_stmt_value() should be\n-   used for new code.  */\n-\n-void\n-genrtl_expr_stmt (tree expr)\n-{\n-  genrtl_expr_stmt_value (expr, -1, 1);\n-}\n-\n-/* Generate the RTL for EXPR, which is an EXPR_STMT.  WANT_VALUE tells\n-   whether to (1) save the value of the expression, (0) discard it or\n-   (-1) use expr_stmts_for_value to tell.  The use of -1 is\n-   deprecated, and retained only for backward compatibility.\n-   MAYBE_LAST is nonzero if this EXPR_STMT might be the last statement\n-   in expression statement.  */\n-\n-void\n-genrtl_expr_stmt_value (tree expr, int want_value, int maybe_last)\n-{\n-  if (expr != NULL_TREE)\n-    {\n-      emit_line_note (input_location);\n-\n-      if (stmts_are_full_exprs_p ())\n-\texpand_start_target_temps ();\n-\n-      if (expr != error_mark_node)\n-\texpand_expr_stmt_value (expr, want_value, maybe_last);\n-\n-      if (stmts_are_full_exprs_p ())\n-\texpand_end_target_temps ();\n-    }\n-}\n-\n-/* Generate the RTL for T, which is a DECL_STMT.  */\n-\n-void\n-genrtl_decl_stmt (tree t)\n-{\n-  tree decl;\n-  emit_line_note (input_location);\n-  decl = DECL_STMT_DECL (t);\n-  /* If this is a declaration for an automatic local\n-     variable, initialize it.  Note that we might also see a\n-     declaration for a namespace-scope object (declared with\n-     `extern').  We don't have to handle the initialization\n-     of those objects here; they can only be declarations,\n-     rather than definitions.  */\n-  if (TREE_CODE (decl) == VAR_DECL\n-      && !TREE_STATIC (decl)\n-      && !DECL_EXTERNAL (decl))\n-    {\n-      /* Let the back-end know about this variable.  */\n-      if (!anon_aggr_type_p (TREE_TYPE (decl)))\n-\temit_local_var (decl);\n-      else\n-\texpand_anon_union_decl (decl, NULL_TREE,\n-\t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n-    }\n-  else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n-    make_rtl_for_local_static (decl);\n-  else if (TREE_CODE (decl) == LABEL_DECL\n-\t   && C_DECLARED_LABEL_FLAG (decl))\n-    declare_nonlocal_label (decl);\n-  else if (TREE_CODE (decl) == TYPE_DECL)\n-    force_type_save_exprs (TREE_TYPE (decl));\n-  else if (lang_expand_decl_stmt)\n-    (*lang_expand_decl_stmt) (t);\n-}\n-\n-/* Generate the RTL for T, which is an IF_STMT.  */\n-\n-void\n-genrtl_if_stmt (tree t)\n-{\n-  tree cond;\n-  genrtl_do_pushlevel ();\n-  cond = expand_cond (IF_COND (t));\n-  emit_line_note (input_location);\n-  expand_start_cond (cond, 0);\n-  if (THEN_CLAUSE (t))\n-    {\n-      tree nextt = THEN_CLAUSE (t);\n-\n-      if (cond && integer_zerop (cond))\n-\tnextt = expand_unreachable_stmt (nextt, warn_notreached);\n-      expand_stmt (nextt);\n-    }\n-\n-  if (ELSE_CLAUSE (t))\n-    {\n-      tree nextt = ELSE_CLAUSE (t);\n-      expand_start_else ();\n-      if (cond && integer_nonzerop (cond))\n-\tnextt = expand_unreachable_stmt (nextt, warn_notreached);\n-      expand_stmt (nextt);\n-    }\n-  expand_end_cond ();\n-}\n-\n-/* Generate the RTL for T, which is a WHILE_STMT.  */\n-\n-void\n-genrtl_while_stmt (tree t)\n-{\n-  tree cond = WHILE_COND (t);\n-\n-  emit_line_note (input_location);\n-  expand_start_loop (1);\n-  genrtl_do_pushlevel ();\n-\n-  if (cond && !integer_nonzerop (cond))\n-    {\n-      cond = expand_cond (cond);\n-      emit_line_note (input_location);\n-      expand_exit_loop_top_cond (0, cond);\n-      genrtl_do_pushlevel ();\n-    }\n-\n-  expand_stmt (WHILE_BODY (t));\n-\n-  expand_end_loop ();\n-}\n-\n-/* Generate the RTL for a DO_STMT with condition COND and loop BODY\n-   body.  This is reused for expanding unreachable WHILE_STMTS.  */\n-\n-static void\n-genrtl_do_stmt_1 (tree cond, tree body)\n-{\n-  /* Recognize the common special-case of do { ... } while (0) and do\n-     not emit the loop widgetry in this case.  In particular this\n-     avoids cluttering the rtl with dummy loop notes, which can affect\n-     alignment of adjacent labels.  COND can be NULL due to parse\n-     errors.  */\n-  if (!cond || integer_zerop (cond))\n-    {\n-      expand_start_null_loop ();\n-      expand_stmt (body);\n-      expand_end_null_loop ();\n-    }\n-  else if (integer_nonzerop (cond))\n-    {\n-      emit_line_note (input_location);\n-      expand_start_loop (1);\n-\n-      expand_stmt (body);\n-\n-      emit_line_note (input_location);\n-      expand_end_loop ();\n-    }\n-  else\n-    {\n-      emit_line_note (input_location);\n-      expand_start_loop_continue_elsewhere (1);\n-\n-      expand_stmt (body);\n-\n-      expand_loop_continue_here ();\n-      cond = expand_cond (cond);\n-      emit_line_note (input_location);\n-      expand_exit_loop_if_false (0, cond);\n-      expand_end_loop ();\n-    }\n-}\n-\n-/* Generate the RTL for T, which is a DO_STMT.  */\n-\n-void\n-genrtl_do_stmt (tree t)\n-{\n-  genrtl_do_stmt_1 (DO_COND (t), DO_BODY (t));\n-}\n-\n /* Build the node for a return statement and return it.  */\n \n tree\n@@ -507,74 +268,6 @@ build_return_stmt (tree expr)\n   return (build_stmt (RETURN_STMT, expr));\n }\n \n-/* Generate the RTL for STMT, which is a RETURN_STMT.  */\n-\n-void\n-genrtl_return_stmt (tree stmt)\n-{\n-  tree expr;\n-\n-  expr = RETURN_STMT_EXPR (stmt);\n-\n-  emit_line_note (input_location);\n-  if (!expr)\n-    expand_null_return ();\n-  else\n-    {\n-      expand_start_target_temps ();\n-      expand_return (expr);\n-      expand_end_target_temps ();\n-    }\n-}\n-\n-/* Generate the RTL for T, which is a FOR_STMT.  */\n-\n-void\n-genrtl_for_stmt (tree t)\n-{\n-  tree cond = FOR_COND (t);\n-  location_t saved_loc;\n-\n-  if (NEW_FOR_SCOPE_P (t))\n-    genrtl_do_pushlevel ();\n-\n-  expand_stmt (FOR_INIT_STMT (t));\n-\n-  /* Expand the initialization.  */\n-  emit_line_note (input_location);\n-  if (FOR_EXPR (t))\n-    expand_start_loop_continue_elsewhere (1);\n-  else\n-    expand_start_loop (1);\n-  genrtl_do_pushlevel ();\n-\n-  /* Save the filename and line number so that we expand the FOR_EXPR\n-     we can reset them back to the saved values.  */\n-  saved_loc = input_location;\n-\n-  /* Expand the condition.  */\n-  if (cond && !integer_nonzerop (cond))\n-    {\n-      cond = expand_cond (cond);\n-      emit_line_note (input_location);\n-      expand_exit_loop_top_cond (0, cond);\n-      genrtl_do_pushlevel ();\n-    }\n-\n-  /* Expand the body.  */\n-  expand_stmt (FOR_BODY (t));\n-\n-  /* Expand the increment expression.  */\n-  input_location = saved_loc;\n-  emit_line_note (input_location);\n-  if (FOR_EXPR (t))\n-    {\n-      expand_loop_continue_here ();\n-      genrtl_expr_stmt (FOR_EXPR (t));\n-    }\n-  expand_end_loop ();\n-}\n-\n /* Build a break statement node and return it.  */\n \n tree\n@@ -583,16 +276,6 @@ build_break_stmt (void)\n   return (build_stmt (BREAK_STMT));\n }\n \n-/* Generate the RTL for a BREAK_STMT.  */\n-\n-void\n-genrtl_break_stmt (void)\n-{\n-  emit_line_note (input_location);\n-  if ( ! expand_exit_something ())\n-    abort ();\n-}\n-\n /* Build a continue statement node and return it.  */\n \n tree\n@@ -601,80 +284,6 @@ build_continue_stmt (void)\n   return (build_stmt (CONTINUE_STMT));\n }\n \n-/* Generate the RTL for a CONTINUE_STMT.  */\n-\n-void\n-genrtl_continue_stmt (void)\n-{\n-  emit_line_note (input_location);\n-  if (! expand_continue_loop (0))\n-    abort ();\n-}\n-\n-/* Generate the RTL for T, which is a SCOPE_STMT.  */\n-\n-void\n-genrtl_scope_stmt (tree t)\n-{\n-  tree block = SCOPE_STMT_BLOCK (t);\n-\n-  if (!SCOPE_NO_CLEANUPS_P (t))\n-    {\n-      if (SCOPE_BEGIN_P (t))\n-\texpand_start_bindings_and_block (2 * SCOPE_NULLIFIED_P (t), block);\n-      else if (SCOPE_END_P (t))\n-\texpand_end_bindings (NULL_TREE, !SCOPE_NULLIFIED_P (t), 0);\n-    }\n-  else if (!SCOPE_NULLIFIED_P (t))\n-    {\n-      rtx note = emit_note (SCOPE_BEGIN_P (t)\n-\t\t\t    ? NOTE_INSN_BLOCK_BEG : NOTE_INSN_BLOCK_END);\n-      NOTE_BLOCK (note) = block;\n-    }\n-\n-  /* If we're at the end of a scope that contains inlined nested\n-     functions, we have to decide whether or not to write them out.  */\n-  if (block && SCOPE_END_P (t))\n-    {\n-      tree fn;\n-\n-      for (fn = BLOCK_VARS (block); fn; fn = TREE_CHAIN (fn))\n-\t{\n-\t  if (TREE_CODE (fn) == FUNCTION_DECL\n-\t      && DECL_CONTEXT (fn) == current_function_decl\n-\t      && DECL_STRUCT_FUNCTION (fn)\n-\t      && DECL_STRUCT_FUNCTION (fn)->saved_for_inline\n-\t      && !TREE_ASM_WRITTEN (fn)\n-\t      && TREE_ADDRESSABLE (fn))\n-\t    {\n-\t      push_function_context ();\n-\t      output_inline_function (fn);\n-\t      pop_function_context ();\n-\t    }\n-\t}\n-    }\n-}\n-\n-/* Generate the RTL for T, which is a SWITCH_STMT.  */\n-\n-void\n-genrtl_switch_stmt (tree t)\n-{\n-  tree cond;\n-  genrtl_do_pushlevel ();\n-\n-  cond = expand_cond (SWITCH_COND (t));\n-  if (cond == error_mark_node)\n-    /* The code is in error, but we don't want expand_end_case to\n-       crash.  */\n-    cond = truthvalue_false_node;\n-\n-  emit_line_note (input_location);\n-  expand_start_case (1, cond, TREE_TYPE (cond), \"switch statement\");\n-  expand_stmt (expand_unreachable_stmt (SWITCH_BODY (t), warn_notreached));\n-  expand_end_case_type (cond, SWITCH_TYPE (t));\n-}\n-\n /* Create a CASE_LABEL tree node and return it.  */\n \n tree\n@@ -683,378 +292,13 @@ build_case_label (tree low_value, tree high_value, tree label_decl)\n   return build_stmt (CASE_LABEL, low_value, high_value, label_decl);\n }\n \n-\n-/* Generate the RTL for a CASE_LABEL.  */\n-\n-void\n-genrtl_case_label (tree case_label)\n-{\n-  tree duplicate;\n-  tree cleanup;\n-\n-  cleanup = last_cleanup_this_contour ();\n-  if (cleanup)\n-    {\n-      static int explained = 0;\n-      warning (\"destructor needed for `%D'\", (TREE_PURPOSE (cleanup)));\n-      warning (\"where case label appears here\");\n-      if (!explained)\n-\t{\n-\t  warning (\"(enclose actions of previous case statements requiring destructors in their own scope.)\");\n-\t  explained = 1;\n-\t}\n-    }\n-\n-  add_case_node (CASE_LOW (case_label), CASE_HIGH (case_label),\n-\t\t CASE_LABEL_DECL (case_label), &duplicate);\n-}\n-\n-/* Generate the RTL for T, which is a COMPOUND_STMT.  */\n-\n-void\n-genrtl_compound_stmt (tree t)\n-{\n-#ifdef ENABLE_CHECKING\n-  struct nesting *n = current_nesting_level ();\n-#endif\n-\n-  expand_stmt (COMPOUND_BODY (t));\n-\n-#ifdef ENABLE_CHECKING\n-  /* Make sure that we've pushed and popped the same number of levels.  */\n-  if (!COMPOUND_STMT_NO_SCOPE (t) && n != current_nesting_level ())\n-    abort ();\n-#endif\n-}\n-\n-/* Generate the RTL for an ASM_STMT.  */\n-\n-void\n-genrtl_asm_stmt (tree cv_qualifier, tree string, tree output_operands,\n-\t\t tree input_operands, tree clobbers, int asm_input_p)\n-{\n-  if (cv_qualifier != NULL_TREE\n-      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n-    {\n-      warning (\"%s qualifier ignored on asm\",\n-\t       IDENTIFIER_POINTER (cv_qualifier));\n-      cv_qualifier = NULL_TREE;\n-    }\n-\n-  emit_line_note (input_location);\n-  if (asm_input_p)\n-    expand_asm (string, cv_qualifier != NULL_TREE);\n-  else\n-    c_expand_asm_operands (string, output_operands, input_operands,\n-\t\t\t   clobbers, cv_qualifier != NULL_TREE,\n-\t\t\t   input_location);\n-}\n-\n-/* Generate the RTL for a CLEANUP_STMT.  */\n-\n-void\n-genrtl_cleanup_stmt (tree t)\n-{\n-  tree decl = CLEANUP_DECL (t);\n-  if (!decl || !DECL_P (decl)\n-      || (DECL_SIZE (decl) && TREE_TYPE (decl) != error_mark_node))\n-    expand_decl_cleanup_eh (decl, CLEANUP_EXPR (t), CLEANUP_EH_ONLY (t));\n-}\n-\n /* We're about to expand T, a statement.  Set up appropriate context\n    for the substitution.  */\n \n void\n prep_stmt (tree t)\n {\n-  if (!STMT_LINENO_FOR_FN_P (t))\n-    input_line = STMT_LINENO (t);\n+  if (EXPR_LOCUS (t))\n+    input_location = *EXPR_LOCUS (t);\n   current_stmt_tree ()->stmts_are_full_exprs_p = STMT_IS_FULL_EXPR_P (t);\n }\n-\n-/* Generate the RTL for the statement T, its substatements, and any\n-   other statements at its nesting level.  */\n-\n-void\n-expand_stmt (tree t)\n-{\n-  while (t && t != error_mark_node)\n-    {\n-      int saved_stmts_are_full_exprs_p;\n-\n-      /* Set up context appropriately for handling this statement.  */\n-      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n-      prep_stmt (t);\n-\n-      switch (TREE_CODE (t))\n-\t{\n-\tcase FILE_STMT:\n-\t  input_filename = FILE_STMT_FILENAME (t);\n-\t  break;\n-\n-\tcase RETURN_STMT:\n-\t  genrtl_return_stmt (t);\n-\t  t = expand_unreachable_stmt (TREE_CHAIN (t), warn_notreached);\n-\t  goto process_t;\n-\n-\tcase EXPR_STMT:\n-\t  genrtl_expr_stmt_value (EXPR_STMT_EXPR (t), TREE_ADDRESSABLE (t),\n-\t\t\t\t  TREE_CHAIN (t) == NULL\n-\t\t\t\t  || (TREE_CODE (TREE_CHAIN (t)) == SCOPE_STMT\n-\t\t\t\t      && TREE_CHAIN (TREE_CHAIN (t)) == NULL));\n-\t  break;\n-\n-\tcase DECL_STMT:\n-\t  genrtl_decl_stmt (t);\n-\t  break;\n-\n-\tcase FOR_STMT:\n-\t  genrtl_for_stmt (t);\n-\t  break;\n-\n-\tcase WHILE_STMT:\n-\t  genrtl_while_stmt (t);\n-\t  break;\n-\n-\tcase DO_STMT:\n-\t  genrtl_do_stmt (t);\n-\t  break;\n-\n-\tcase IF_STMT:\n-\t  genrtl_if_stmt (t);\n-\t  break;\n-\n-\tcase COMPOUND_STMT:\n-\t  genrtl_compound_stmt (t);\n-\t  break;\n-\n-\tcase BREAK_STMT:\n-\t  genrtl_break_stmt ();\n-\t  t = expand_unreachable_stmt (TREE_CHAIN (t), warn_notreached);\n-\t  goto process_t;\n-\n-\tcase CONTINUE_STMT:\n-\t  genrtl_continue_stmt ();\n-\t  t = expand_unreachable_stmt (TREE_CHAIN (t), warn_notreached);\n-\t  goto process_t;\n-\n-\tcase SWITCH_STMT:\n-\t  genrtl_switch_stmt (t);\n-\t  break;\n-\n-\tcase CASE_LABEL:\n-\t  genrtl_case_label (t);\n-\t  break;\n-\n-\tcase LABEL_STMT:\n-\t  expand_label (LABEL_STMT_LABEL (t));\n-\t  break;\n-\n-\tcase GOTO_STMT:\n-\t  /* Emit information for branch prediction.  */\n-\t  if (!GOTO_FAKE_P (t)\n-\t      && TREE_CODE (GOTO_DESTINATION (t)) == LABEL_DECL\n-\t      && flag_guess_branch_prob)\n-\t    {\n-\t      rtx note = emit_note (NOTE_INSN_PREDICTION);\n-\n-\t      NOTE_PREDICTION (note) = NOTE_PREDICT (PRED_GOTO, NOT_TAKEN);\n-\t    }\n-\t  genrtl_goto_stmt (GOTO_DESTINATION (t));\n-\t  t = expand_unreachable_stmt (TREE_CHAIN (t), warn_notreached);\n-\t  goto process_t;\n-\n-\tcase ASM_STMT:\n-\t  genrtl_asm_stmt (ASM_CV_QUAL (t), ASM_STRING (t),\n-\t\t\t   ASM_OUTPUTS (t), ASM_INPUTS (t),\n-\t\t\t   ASM_CLOBBERS (t), ASM_INPUT_P (t));\n-\t  break;\n-\n-\tcase SCOPE_STMT:\n-\t  genrtl_scope_stmt (t);\n-\t  break;\n-\n-\tcase CLEANUP_STMT:\n-\t  genrtl_cleanup_stmt (t);\n-\t  break;\n-\n-\tdefault:\n-\t  if (lang_expand_stmt)\n-\t    (*lang_expand_stmt) (t);\n-\t  else\n-\t    abort ();\n-\t  break;\n-\t}\n-\n-      /* Go on to the next statement in this scope.  */\n-      t = TREE_CHAIN (t);\n-\n-    process_t:\n-      /* Restore saved state.  */\n-      current_stmt_tree ()->stmts_are_full_exprs_p\n-\t= saved_stmts_are_full_exprs_p;\n-    }\n-}\n-\f\n-/* If *TP is a potentially reachable label, return nonzero.  */\n-\n-static tree\n-find_reachable_label_1 (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n-\t\t\tvoid *data ATTRIBUTE_UNUSED)\n-{\n-  switch (TREE_CODE (*tp))\n-    {\n-    case LABEL_STMT:\n-    case CASE_LABEL:\n-      return *tp;\n-\n-    default:\n-      break;\n-    }\n-  return NULL_TREE;\n-}\n-\n-/* Determine whether expression EXP contains a potentially\n-   reachable label.  */\n-static tree\n-find_reachable_label (tree exp)\n-{\n-  location_t saved_loc = input_location;\n-  tree ret = walk_tree_without_duplicates\n-\t\t(&exp, find_reachable_label_1, NULL);\n-  input_location = saved_loc;\n-  return ret;\n-}\n-\n-/* Expand an unreachable if statement, T.  This function returns\n-   true if the IF_STMT contains a potentially reachable code_label.  */\n-static bool\n-expand_unreachable_if_stmt (tree t)\n-{\n-  tree n;\n-\n-  if (find_reachable_label (IF_COND (t)) != NULL_TREE)\n-    {\n-      genrtl_if_stmt (t);\n-      return true;\n-    }\n-\n-  if (THEN_CLAUSE (t) && ELSE_CLAUSE (t))\n-    {\n-      n = expand_unreachable_stmt (THEN_CLAUSE (t), 0);\n-\n-      if (n != NULL_TREE)\n-\t{\n-\t  rtx label;\n-\t  expand_stmt (n);\n-\t  label = gen_label_rtx ();\n-\t  emit_jump (label);\n-\t  expand_stmt (expand_unreachable_stmt (ELSE_CLAUSE (t), 0));\n-\t  emit_label (label);\n-\t  return true;\n-\t}\n-      else\n-\tn = expand_unreachable_stmt (ELSE_CLAUSE (t), 0);\n-    }\n-  else if (THEN_CLAUSE (t))\n-    n = expand_unreachable_stmt (THEN_CLAUSE (t), 0);\n-  else if (ELSE_CLAUSE (t))\n-    n = expand_unreachable_stmt (ELSE_CLAUSE (t), 0);\n-  else\n-    n = NULL_TREE;\n-\n-  expand_stmt (n);\n-\n-  return n != NULL_TREE;\n-}\n-\n-/* Expand an unreachable statement list.  This function skips all\n-   statements preceding the first potentially reachable label and\n-   then returns the label (or, in same cases, the statement after\n-   one containing the label).  */\n-static tree\n-expand_unreachable_stmt (tree t, int warn)\n-{\n-  int saved;\n-\n-  while (t && t != error_mark_node)\n-    {\n-      if (warn)\n-\tswitch (TREE_CODE (t))\n-\t  {\n-\t  case BREAK_STMT:\n-\t  case CONTINUE_STMT:\n-\t  case EXPR_STMT:\n-\t  case GOTO_STMT:\n-\t  case IF_STMT:\n-\t  case RETURN_STMT:\n-\t    if (!STMT_LINENO_FOR_FN_P (t))\n-\t      input_line = STMT_LINENO (t);\n-\t    warning(\"will never be executed\");\n-\t    warn = false;\n-\t    break;\n-\n-\t  default:\n-\t    break;\n-\t  }\n-\n-      switch (TREE_CODE (t))\n-\t{\n-\tcase GOTO_STMT:\n-\tcase CONTINUE_STMT:\n-\tcase BREAK_STMT:\n-\t  break;\n-\n-\tcase FILE_STMT:\n-\t  input_filename = FILE_STMT_FILENAME (t);\n-\t  break;\n-\n-\tcase RETURN_STMT:\n-\t  if (find_reachable_label (RETURN_STMT_EXPR (t)) != NULL_TREE)\n-\t    return t;\n-\t  break;\n-\n-\tcase EXPR_STMT:\n-\t  if (find_reachable_label (EXPR_STMT_EXPR (t)) != NULL_TREE)\n-\t    return t;\n-\t  break;\n-\n-\tcase IF_STMT:\n-\t  if (expand_unreachable_if_stmt (t))\n-\t    return TREE_CHAIN (t);\n-\t  break;\n-\n-\tcase WHILE_STMT:\n-\t  /* If the start of a while statement is unreachable, there is\n-\t     no need to rotate the loop, instead the WHILE_STMT can be\n-\t     expanded like a DO_STMT.  */\n-\t  genrtl_do_stmt_1 (WHILE_COND (t), WHILE_BODY (t));\n-\t  return TREE_CHAIN (t);\n-\n-\tcase COMPOUND_STMT:\n-\t  {\n-\t    tree n;\n-\t    n = expand_unreachable_stmt (COMPOUND_BODY (t), warn);\n-\t    if (n != NULL_TREE)\n-\t      {\n-\t\texpand_stmt (n);\n-\t\treturn TREE_CHAIN (t);\n-\t      }\n-\t    warn = false;\n-\t    break;\n-\t  }\n-\n-\tcase SCOPE_STMT:\n-\t  saved = stmts_are_full_exprs_p ();\n-\t  prep_stmt (t);\n-\t  genrtl_scope_stmt (t);\n-\t  current_stmt_tree ()->stmts_are_full_exprs_p = saved;\n-\t  break;\n-\n-\tdefault:\n-\t  return t;\n-\t}\n-      t = TREE_CHAIN (t);\n-    }\n-  return NULL_TREE;\n-}"}, {"sha": "bd50b5e025b88bc2628e9729db1271f28674356a", "filename": "gcc/c-simplify.c", "status": "added", "additions": 1102, "deletions": 0, "changes": 1102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-simplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-simplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-simplify.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,1102 @@\n+/* Tree lowering pass.  This pass gimplifies the tree representation built\n+   by the C-based front ends.  The structure of gimplified, or\n+   language-independent, trees is dictated by the grammar described in this\n+   file.\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Lowering of expressions contributed by Sebastian Pop <s.pop@laposte.net>\n+   Re-written to support lowering of whole function trees, documentation\n+   and miscellaneous cleanups by Diego Novillo <dnovillo@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"errors.h\"\n+#include \"varray.h\"\n+#include \"c-tree.h\"\n+#include \"c-common.h\"\n+#include \"tree-simple.h\"\n+#include \"hard-reg-set.h\"\n+#include \"basic-block.h\"\n+#include \"tree-flow.h\"\n+#include \"tree-inline.h\"\n+#include \"diagnostic.h\"\n+#include \"langhooks.h\"\n+#include \"langhooks-def.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"toplev.h\"\n+#include \"tree-dump.h\"\n+#include \"c-pretty-print.h\"\n+#include \"cgraph.h\"\n+\n+\n+/*  The gimplification pass converts the language-dependent trees\n+    (ld-trees) emitted by the parser into language-independent trees\n+    (li-trees) that are the target of SSA analysis and transformations.\n+\n+    Language-independent trees are based on the SIMPLE intermediate\n+    representation used in the McCAT compiler framework:\n+\n+    \"Designing the McCAT Compiler Based on a Family of Structured\n+    Intermediate Representations,\"\n+    L. Hendren, C. Donawa, M. Emami, G. Gao, Justiani, and B. Sridharan,\n+    Proceedings of the 5th International Workshop on Languages and\n+    Compilers for Parallel Computing, no. 757 in Lecture Notes in\n+    Computer Science, New Haven, Connecticut, pp. 406-420,\n+    Springer-Verlag, August 3-5, 1992.\n+\n+    http://www-acaps.cs.mcgill.ca/info/McCAT/McCAT.html\n+\n+    Basically, we walk down gimplifying the nodes that we encounter.  As we\n+    walk back up, we check that they fit our constraints, and copy them\n+    into temporaries if not.  */\n+\n+/* Local declarations.  */\n+\n+static enum gimplify_status gimplify_expr_stmt (tree *);\n+static enum gimplify_status gimplify_decl_stmt (tree *);\n+static enum gimplify_status gimplify_for_stmt (tree *, tree *);\n+static enum gimplify_status gimplify_while_stmt (tree *);\n+static enum gimplify_status gimplify_do_stmt (tree *);\n+static enum gimplify_status gimplify_if_stmt (tree *);\n+static enum gimplify_status gimplify_switch_stmt (tree *);\n+static enum gimplify_status gimplify_return_stmt (tree *);\n+static enum gimplify_status gimplify_stmt_expr (tree *);\n+static enum gimplify_status gimplify_compound_literal_expr (tree *);\n+#if defined ENABLE_CHECKING\n+static int is_last_stmt_of_scope (tree);\n+#endif\n+static enum gimplify_status gimplify_block (tree *, tree *);\n+static enum gimplify_status gimplify_cleanup (tree *, tree *);\n+static tree gimplify_c_loop (tree, tree, tree, bool);\n+static void push_context (void);\n+static void pop_context (void);\n+static tree c_build_bind_expr (tree, tree);\n+static void add_block_to_enclosing (tree);\n+static void gimplify_condition (tree *);\n+\n+enum bc_t { bc_break = 0, bc_continue = 1 };\n+static tree begin_bc_block (enum bc_t);\n+static tree finish_bc_block (tree, tree);\n+static tree build_bc_goto (enum bc_t);\n+\n+static struct c_gimplify_ctx\n+{\n+  /* For handling break and continue.  */\n+  tree current_bc_label;\n+  tree bc_id[2];\n+} *ctxp;\n+\n+static void\n+push_context (void)\n+{\n+  if (ctxp)\n+    abort ();\n+  ctxp = (struct c_gimplify_ctx *) xcalloc (1, sizeof (struct c_gimplify_ctx));\n+  ctxp->bc_id[bc_continue] = get_identifier (\"continue\");\n+  ctxp->bc_id[bc_break] = get_identifier (\"break\");\n+}\n+\n+static void\n+pop_context (void)\n+{\n+  if (!ctxp || ctxp->current_bc_label)\n+    abort ();\n+  free (ctxp);\n+  ctxp = NULL;\n+}\n+\n+/* Gimplification of statement trees.  */\n+\n+/* Convert the tree representation of FNDECL from C frontend trees to\n+   GENERIC.  */\n+\n+void\n+c_genericize (tree fndecl)\n+{\n+  FILE *dump_file;\n+  int local_dump_flags;\n+  struct cgraph_node *cgn;\n+\n+  /* Dump the C-specific tree IR.  */\n+  dump_file = dump_begin (TDI_original, &local_dump_flags);\n+  if (dump_file)\n+    {\n+      fprintf (dump_file, \"\\n;; Function %s\",\n+\t       (*lang_hooks.decl_printable_name) (fndecl, 2));\n+      fprintf (dump_file, \" (%s)\\n\",\n+\t       IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (fndecl)));\n+      fprintf (dump_file, \";; enabled by -%s\\n\", dump_flag_name (TDI_original));\n+      fprintf (dump_file, \"\\n\");\n+\n+      if (local_dump_flags & TDF_RAW)\n+\tdump_node (DECL_SAVED_TREE (fndecl),\n+\t\t   TDF_SLIM | local_dump_flags, dump_file);\n+      else\n+\tprint_c_tree (dump_file, DECL_SAVED_TREE (fndecl));\n+      fprintf (dump_file, \"\\n\");\n+\n+      dump_end (TDI_original, dump_file);\n+    }\n+\n+  /* Go ahead and gimplify for now.  */\n+  push_context ();\n+  gimplify_function_tree (fndecl);\n+  pop_context ();\n+\n+  /* Dump the genericized tree IR.  */\n+  dump_function (TDI_generic, fndecl);\n+\n+  /* Genericize all nested functions now.  We do things in this order so\n+     that items like VLA sizes are expanded properly in the context of\n+     the correct function.  */\n+  cgn = cgraph_node (fndecl);\n+  for (cgn = cgn->nested; cgn ; cgn = cgn->next_nested)\n+    c_genericize (cgn->decl);\n+}\n+\n+/*  Entry point for the tree lowering pass.  Recursively scan\n+    *STMT_P and convert it to a GIMPLE tree.  */\n+\n+int\n+c_gimplify_stmt (tree *stmt_p)\n+{\n+  tree stmt, next;\n+  tree outer_pre = NULL_TREE;\n+\n+  /* PRE and POST are tree chains that contain the side-effects of the\n+     gimplified tree.  For instance, given the expression tree:\n+\n+\t\tc = ++a * 3 + b++;\n+\n+     After gimplification, the tree will be re-written as:\n+\n+\t\ta = a + 1;\n+\t\tt1 = a * 3;\t<-- PRE\n+\t\tc = t1 + b;\n+\t\tb = b + 1;\t<-- POST  */\n+\n+  for (stmt = *stmt_p; stmt && stmt != error_mark_node; stmt = next)\n+    {\n+      tree pre, post;\n+      int saved_stmts_are_full_exprs_p;\n+      location_t stmt_locus;\n+      enum gimplify_status ret;\n+\n+      /* Set up context appropriately for handling this statement.  */\n+      saved_stmts_are_full_exprs_p = stmts_are_full_exprs_p ();\n+      prep_stmt (stmt);\n+      stmt_locus = input_location;\n+\n+      pre = NULL_TREE;\n+      post = NULL_TREE;\n+\n+      next = TREE_CHAIN (stmt);\n+\n+      switch (TREE_CODE (stmt))\n+\t{\n+\tcase COMPOUND_STMT:\n+\t  stmt = COMPOUND_BODY (stmt);\n+\t  ret = GS_OK;\n+\t  break;\n+\n+\tcase SCOPE_STMT:\n+\t  ret = gimplify_block (&stmt, &next);\n+\t  break;\n+\n+\tcase FOR_STMT:\n+\t  ret = gimplify_for_stmt (&stmt, &next);\n+\t  break;\n+\n+\tcase WHILE_STMT:\n+\t  ret = gimplify_while_stmt (&stmt);\n+\t  break;\n+\n+\tcase DO_STMT:\n+\t  ret = gimplify_do_stmt (&stmt);\n+\t  break;\n+\n+\tcase IF_STMT:\n+\t  ret = gimplify_if_stmt (&stmt);\n+\t  break;\n+\n+\tcase SWITCH_STMT:\n+\t  ret = gimplify_switch_stmt (&stmt);\n+\t  break;\n+\n+\tcase EXPR_STMT:\n+\t  ret = gimplify_expr_stmt (&stmt);\n+\t  break;\n+\n+\tcase RETURN_STMT:\n+\t  ret = gimplify_return_stmt (&stmt);\n+\t  break;\n+\n+\tcase DECL_STMT:\n+\t  ret = gimplify_decl_stmt (&stmt);\n+\t  break;\n+\n+\tcase LABEL_STMT:\n+\t  stmt = build1 (LABEL_EXPR, void_type_node, LABEL_STMT_LABEL (stmt));\n+\t  ret = GS_OK;\n+\t  break;\n+\n+\tcase GOTO_STMT:\n+\t  stmt = build1 (GOTO_EXPR, void_type_node, GOTO_DESTINATION (stmt));\n+\t  ret = GS_OK;\n+\t  break;\n+\n+\tcase CASE_LABEL:\n+\t  {\n+\t    tree label = create_artificial_label ();\n+\t    stmt = build (CASE_LABEL_EXPR, void_type_node,\n+\t\t\t  CASE_LOW (stmt), CASE_HIGH (stmt), label);\n+\t    ret = GS_OK;\n+\t  }\n+\t  break;\n+\n+\tcase CONTINUE_STMT:\n+\t  stmt = build_bc_goto (bc_continue);\n+\t  ret = GS_OK;\n+\t  break;\n+\n+\tcase BREAK_STMT:\n+\t  stmt = build_bc_goto (bc_break);\n+\t  ret = GS_OK;\n+\t  break;\n+\n+\tcase CLEANUP_STMT:\n+\t  ret = gimplify_cleanup (&stmt, &next);\n+\t  break;\n+\n+\tcase ASM_STMT:\n+\t  {\n+\t    tree new_stmt = build (ASM_EXPR, void_type_node, ASM_STRING (stmt),\n+\t\t\t\t   ASM_OUTPUTS (stmt), ASM_INPUTS (stmt),\n+\t\t\t\t   ASM_CLOBBERS (stmt));\n+\t    ASM_INPUT_P (new_stmt) = ASM_INPUT_P (stmt);\n+\t    ASM_VOLATILE_P (new_stmt) = ASM_VOLATILE_P (stmt);\n+\t    stmt = new_stmt;\n+\t    ret = GS_OK;\n+\t  }\n+\t  break;\n+\n+\tdefault:\n+\t  if (lang_gimplify_stmt && (*lang_gimplify_stmt) (&stmt, &next))\n+\t    {\n+\t      ret = GS_OK;\n+\t      break;\n+\t    }\n+\n+\t  fprintf (stderr, \"unhandled statement node in c_gimplify_stmt:\\n\");\n+\t  debug_tree (stmt);\n+\t  abort ();\n+\t  break;\n+\t}\n+\n+      switch (ret)\n+\t{\n+\tcase GS_ERROR:\n+\t  goto cont;\n+\tcase GS_OK:\n+          gimplify_stmt (&stmt);\n+\t  break;\n+\tcase GS_ALL_DONE:\n+\t  break;\n+\tdefault:\n+\t  abort ();\n+\t}\n+\n+      /* PRE and POST now contain a list of statements for all the\n+\t side-effects in STMT.  */\n+\n+      append_to_statement_list (stmt, &pre);\n+      append_to_statement_list (post, &pre);\n+      annotate_all_with_locus (&pre, stmt_locus);\n+\n+      append_to_statement_list (pre, &outer_pre);\n+    cont:\n+      /* Restore saved state.  */\n+      current_stmt_tree ()->stmts_are_full_exprs_p\n+\t= saved_stmts_are_full_exprs_p;\n+    }\n+  append_to_statement_list (stmt, &outer_pre);\n+  *stmt_p = outer_pre;\n+\n+  return GS_ALL_DONE;\n+}\n+\n+static void\n+add_block_to_enclosing (tree block)\n+{\n+  tree enclosing;\n+\n+  for (enclosing = gimple_current_bind_expr ();\n+       enclosing; enclosing = TREE_CHAIN (enclosing))\n+    if (BIND_EXPR_BLOCK (enclosing))\n+      break;\n+\n+  enclosing = BIND_EXPR_BLOCK (enclosing);\n+  BLOCK_SUBBLOCKS (enclosing) = chainon (BLOCK_SUBBLOCKS (enclosing), block);\n+}\n+\n+/* Genericize a scope by creating a new BIND_EXPR.\n+   BLOCK is either a BLOCK representing the scope or a chain of _DECLs.\n+     In the latter case, we need to create a new BLOCK and add it to the\n+     BLOCK_SUBBLOCKS of the enclosing block.\n+   BODY is a chain of C _STMT nodes for the contents of the scope, to be\n+     genericized.  */\n+\n+static tree\n+c_build_bind_expr (tree block, tree body)\n+{\n+  tree decls, bind;\n+\n+  if (block == NULL_TREE)\n+    decls = NULL_TREE;\n+  else if (TREE_CODE (block) == BLOCK)\n+    decls = BLOCK_VARS (block);\n+  else\n+    {\n+      decls = block;\n+      if (DECL_ARTIFICIAL (decls))\n+\tblock = NULL_TREE;\n+      else\n+\t{\n+\t  block = make_node (BLOCK);\n+\t  BLOCK_VARS (block) = decls;\n+\t  add_block_to_enclosing (block);\n+\t}\n+    }\n+\n+  if (!body)\n+    body = build_empty_stmt ();\n+\n+  bind = build (BIND_EXPR, void_type_node, decls, body, block);\n+  TREE_SIDE_EFFECTS (bind) = 1;\n+\n+  return bind;\n+}\n+\n+/* Genericize a syntactic block by removing the bracketing SCOPE_STMTs and\n+   wrapping the intervening code in a BIND_EXPR.  This function assumes\n+   that matching SCOPE_STMTs will always appear in the same statement\n+   sequence.  */\n+\n+static enum gimplify_status\n+gimplify_block (tree *stmt_p, tree *next_p)\n+{\n+  tree *p;\n+  tree block;\n+  tree bind;\n+  int depth;\n+  location_t stmt_locus;\n+\n+  if (!SCOPE_BEGIN_P (*stmt_p))\n+    {\n+      /* Can wind up mismatched with syntax errors.  */\n+      if (!errorcount && !sorrycount)\n+\tabort ();\n+      *stmt_p = NULL;\n+      return GS_ERROR;\n+    }\n+\n+  block = SCOPE_STMT_BLOCK (*stmt_p);\n+\n+  /* Find the matching ending SCOPE_STMT.  */\n+  depth = 1;\n+  for (p = &TREE_CHAIN (*stmt_p);; p = &TREE_CHAIN (*p))\n+    {\n+      if (*p == NULL)\n+\tbreak;\n+      if (TREE_CODE (*p) == SCOPE_STMT)\n+\t{\n+\t  if (SCOPE_BEGIN_P (*p))\n+\t    ++depth;\n+\t  else if (--depth == 0)\n+\t    break;\n+\t}\n+    }\n+\n+  stmt_locus = input_location;\n+  if (*p)\n+    {\n+      if (SCOPE_STMT_BLOCK (*p) != block)\n+\tabort ();\n+      if (EXPR_LOCUS (*p))\n+\tstmt_locus = *EXPR_LOCUS (*p);\n+      *next_p = TREE_CHAIN (*p);\n+      *p = NULL_TREE;\n+    }\n+  else\n+    {\n+      /* Can wind up mismatched with syntax errors.  */\n+      if (!errorcount && !sorrycount)\n+\tabort ();\n+    }\n+\n+  bind = c_build_bind_expr (block, TREE_CHAIN (*stmt_p));\n+  *stmt_p = bind;\n+  input_location = stmt_locus;\n+\n+  return GS_OK;\n+}\n+\n+/* Genericize a CLEANUP_STMT.  Just wrap everything from here to the end of\n+   the block in a TRY_FINALLY_EXPR.  Or a TRY_CATCH_EXPR, if it's an\n+   EH-only cleanup.  */\n+\n+static enum gimplify_status\n+gimplify_cleanup (tree *stmt_p, tree *next_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree body = TREE_CHAIN (stmt);\n+  tree cleanup = CLEANUP_EXPR (stmt);\n+  enum tree_code code\n+    = (CLEANUP_EH_ONLY (stmt) ? TRY_CATCH_EXPR : TRY_FINALLY_EXPR);\n+\n+  if (!body)\n+    body = build_empty_stmt ();\n+  if (!cleanup)\n+    cleanup = build_empty_stmt ();\n+\n+  *stmt_p = build (code, void_type_node, body, cleanup);\n+  *next_p = NULL_TREE;\n+\n+  return GS_OK;\n+}\n+\n+/*  Gimplify an EXPR_STMT node.\n+\n+    STMT is the statement node.\n+\n+    PRE_P points to the list where side effects that must happen before\n+\tSTMT should be stored.\n+\n+    POST_P points to the list where side effects that must happen after\n+\tSTMT should be stored.  */\n+\n+static enum gimplify_status\n+gimplify_expr_stmt (tree *stmt_p)\n+{\n+  tree stmt = EXPR_STMT_EXPR (*stmt_p);\n+\n+  if (stmt == error_mark_node)\n+    stmt = NULL;\n+\n+  /* Gimplification of a statement expression will nullify the\n+     statement if all its side effects are moved to *PRE_P and *POST_P.\n+\n+     In this case we will not want to emit the gimplified statement.\n+     However, we may still want to emit a warning, so we do that before\n+     gimplification.  */\n+  if (stmt && (extra_warnings || warn_unused_value))\n+    {\n+      if (!TREE_SIDE_EFFECTS (stmt))\n+\t{\n+\t  if (!IS_EMPTY_STMT (stmt)\n+\t      && !VOID_TYPE_P (TREE_TYPE (stmt))\n+\t      && !TREE_NO_WARNING (stmt))\n+\t    warning (\"statement with no effect\");\n+\t}\n+      else if (warn_unused_value)\n+\t{\n+\t  /* Kludge for 20020220-2.c.  warn_if_unused_value shouldn't use\n+\t     the stmt file location info.  */\n+\t  set_file_and_line_for_stmt (input_location);\n+\t  warn_if_unused_value (stmt);\n+\t}\n+    }\n+\n+  if (stmt == NULL_TREE)\n+    stmt = build_empty_stmt ();\n+  else if (stmts_are_full_exprs_p ())\n+    stmt = build1 (CLEANUP_POINT_EXPR, void_type_node, stmt);\n+\n+  *stmt_p = stmt;\n+\n+  return GS_OK;\n+}\n+\n+/* If the condition for a loop (or the like) is a decl, it will be a\n+   TREE_LIST where the TREE_PURPOSE is a DECL_STMT and the TREE_VALUE is\n+   a use of the decl.  Turn such a thing into a COMPOUND_EXPR.  */\n+\n+static void\n+gimplify_condition (tree *cond_p)\n+{\n+  tree cond = *cond_p;\n+  if (cond && TREE_CODE (cond) == TREE_LIST)\n+    {\n+      tree decl = TREE_PURPOSE (cond);\n+      tree value = TREE_VALUE (cond);\n+      c_gimplify_stmt (&decl);\n+      *cond_p = build (COMPOUND_EXPR, TREE_TYPE (value), decl, value);\n+    }\n+}\n+\n+/* Begin a scope which can be exited by a break or continue statement.  BC\n+   indicates which.\n+\n+   Just creates a label and pushes it into the current context.  */\n+\n+static tree\n+begin_bc_block (enum bc_t bc)\n+{\n+  tree label = create_artificial_label ();\n+  DECL_NAME (label) = ctxp->bc_id[bc];\n+  TREE_CHAIN (label) = ctxp->current_bc_label;\n+  ctxp->current_bc_label = label;\n+  return label;\n+}\n+\n+/* Finish a scope which can be exited by a break or continue statement.\n+   LABEL was returned from the most recent call to begin_bc_block.  BODY is\n+   an expression for the contents of the scope.\n+\n+   If we saw a break (or continue) in the scope, append a LABEL_EXPR to\n+   body.  Otherwise, just forget the label.  */\n+\n+static tree\n+finish_bc_block (tree label, tree body)\n+{\n+  if (label != ctxp->current_bc_label)\n+    abort ();\n+\n+  if (TREE_USED (label))\n+    {\n+      tree t, sl = NULL;\n+\n+      /* Clear the name so flow can delete the label.  */\n+      DECL_NAME (label) = NULL_TREE;\n+      t = build1 (LABEL_EXPR, void_type_node, label);\n+\n+      append_to_statement_list (body, &sl);\n+      append_to_statement_list (t, &sl);\n+      body = sl;\n+    }\n+\n+  ctxp->current_bc_label = TREE_CHAIN (label);\n+  TREE_CHAIN (label) = NULL_TREE;\n+  return body;\n+}\n+\n+/* Build a GOTO_EXPR to represent a break or continue statement.  BC\n+   indicates which.  */\n+\n+static tree\n+build_bc_goto (enum bc_t bc)\n+{\n+  tree label;\n+  tree target_name = ctxp->bc_id[bc];\n+\n+  /* Look for the appropriate type of label.  */\n+  for (label = ctxp->current_bc_label;\n+       label;\n+       label = TREE_CHAIN (label))\n+    if (DECL_NAME (label) == target_name)\n+      break;\n+\n+  if (label == NULL_TREE)\n+    {\n+      if (bc == bc_break)\n+\terror (\"break statement not within loop or switch\");\n+      else\n+\terror (\"continue statement not within loop or switch\");\n+\n+      return NULL_TREE;\n+    }\n+\n+  /* Mark the label used for finish_bc_block.  */\n+  TREE_USED (label) = 1;\n+  return build1 (GOTO_EXPR, void_type_node, label);\n+}\n+\n+/* Build a generic representation of one of the C loop forms.  COND is the\n+   loop condition or NULL_TREE.  BODY is the (possibly compound) statement\n+   controlled by the loop.  INCR is the increment expression of a for-loop,\n+   or NULL_TREE.  COND_IS_FIRST indicates whether the condition is\n+   evaluated before the loop body as in while and for loops, or after the\n+   loop body as in do-while loops.  */\n+\n+static tree\n+gimplify_c_loop (tree cond, tree body, tree incr, bool cond_is_first)\n+{\n+  tree top, entry, exit, cont_block, break_block, stmt_list, t;\n+  location_t stmt_locus;\n+\n+  stmt_locus = input_location;\n+\n+  /* Detect do { ... } while (0) and don't generate loop construct.  */\n+  if (!cond_is_first && cond && integer_zerop (cond))\n+    top = cond = NULL;\n+  else\n+    {\n+      /* If we use a LOOP_EXPR here, we have to feed the whole thing\n+\t back through the main gimplifier to lower it.  Given that we\n+\t have to gimplify the loop body NOW so that we can resolve\n+\t break/continue stmts, seems easier to just expand to gotos.  */\n+      top = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+    }\n+\n+  break_block = begin_bc_block (bc_break);\n+\n+  if (top)\n+    {\n+      /* If we have an exit condition, then we build an IF with gotos either\n+\t out of the loop, or to the top of it.  If there's no exit condition,\n+\t then we just build a jump back to the top.  */\n+      exit = build_and_jump (&LABEL_EXPR_LABEL (top));\n+      if (cond)\n+\t{\n+\t  gimplify_condition (&cond);\n+\t  t = build_bc_goto (bc_break);\n+\t  exit = build (COND_EXPR, void_type_node, cond, exit, t);\n+\t  exit = fold (exit);\n+\t  gimplify_stmt (&exit);\n+\t}\n+    }\n+  else\n+    exit = NULL_TREE;\n+\n+  cont_block = begin_bc_block (bc_continue);\n+\n+  gimplify_stmt (&body);\n+  if (incr && stmts_are_full_exprs_p ())\n+    incr = fold (build1 (CLEANUP_POINT_EXPR, void_type_node, incr));\n+  gimplify_stmt (&incr);\n+\n+  body = finish_bc_block (cont_block, body);\n+\n+  stmt_list = NULL;\n+\n+  if (cond_is_first && cond)\n+    {\n+      entry = build1 (LABEL_EXPR, void_type_node, NULL_TREE);\n+      t = build_and_jump (&LABEL_EXPR_LABEL (entry));\n+      append_to_statement_list (t, &stmt_list);\n+    }\n+  else\n+    entry = NULL_TREE;\n+\n+  append_to_statement_list (top, &stmt_list);\n+  append_to_statement_list (body, &stmt_list);\n+  append_to_statement_list (incr, &stmt_list);\n+  append_to_statement_list (entry, &stmt_list);\n+  append_to_statement_list (exit, &stmt_list);\n+\n+  annotate_all_with_locus (&stmt_list, stmt_locus);\n+\n+  return finish_bc_block (break_block, stmt_list);\n+}\n+\n+/* Gimplify a FOR_STMT node.  Move the stuff in the for-init-stmt into the\n+   prequeue and hand off to gimplify_c_loop.  */\n+\n+static enum gimplify_status\n+gimplify_for_stmt (tree *stmt_p, tree *next_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree init = FOR_INIT_STMT (stmt);\n+\n+  if (init)\n+    {\n+      /* Reorganize the statements so that we do the right thing with a\n+\t CLEANUP_STMT.  We want the FOR_STMT and nothing else to be in the\n+\t scope of the cleanup, so play with pointers to accomplish that. */\n+      FOR_INIT_STMT (stmt) = NULL_TREE;\n+      chainon (init, stmt);\n+      *stmt_p = init;\n+      *next_p = TREE_CHAIN (stmt);\n+      TREE_CHAIN (stmt) = NULL_TREE;\n+      c_gimplify_stmt (stmt_p);\n+    }\n+  else\n+    *stmt_p = gimplify_c_loop (FOR_COND (stmt), FOR_BODY (stmt),\n+\t\t\t       FOR_EXPR (stmt), 1);\n+\n+  return GS_ALL_DONE;\n+}\n+\n+/* Gimplify a WHILE_STMT node.  */\n+\n+static enum gimplify_status\n+gimplify_while_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  *stmt_p = gimplify_c_loop (WHILE_COND (stmt), WHILE_BODY (stmt),\n+\t\t\t     NULL_TREE, 1);\n+  return GS_ALL_DONE;\n+}\n+\n+/* Gimplify a DO_STMT node.  */\n+\n+static enum gimplify_status\n+gimplify_do_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  *stmt_p = gimplify_c_loop (DO_COND (stmt), DO_BODY (stmt),\n+\t\t\t     NULL_TREE, 0);\n+  return GS_ALL_DONE;\n+}\n+\n+/* Genericize an IF_STMT by turning it into a COND_EXPR.  */\n+\n+static enum gimplify_status\n+gimplify_if_stmt (tree *stmt_p)\n+{\n+  tree stmt, then_, else_;\n+\n+  stmt = *stmt_p;\n+ restart:\n+  then_ = THEN_CLAUSE (stmt);\n+  else_ = ELSE_CLAUSE (stmt);\n+\n+  if (!then_)\n+    then_ = build_empty_stmt ();\n+  if (!else_)\n+    else_ = build_empty_stmt ();\n+\n+  stmt = build (COND_EXPR, void_type_node, IF_COND (stmt), then_, else_);\n+  gimplify_condition (& TREE_OPERAND (stmt, 0));\n+  *stmt_p = stmt;\n+\n+  /* Handle properly nested if-else chains via iteration instead of\n+     mutual recursion between gimplify.c and c-simplify.c.  */\n+  annotate_with_locus (stmt, input_location);\n+  if (TREE_CODE (else_) == IF_STMT && !TREE_CHAIN (else_))\n+    {\n+      stmt_p = &COND_EXPR_ELSE (stmt);\n+      stmt = else_;\n+      prep_stmt (stmt);\n+      goto restart;\n+    }\n+\n+  return GS_OK;\n+}\n+\n+/* Genericize a SWITCH_STMT by turning it into a SWITCH_EXPR.  */\n+\n+static enum gimplify_status\n+gimplify_switch_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree break_block, body;\n+  location_t stmt_locus = input_location;\n+\n+  break_block = begin_bc_block (bc_break);\n+\n+  gimplify_condition (&SWITCH_COND (stmt));\n+\n+  body = SWITCH_BODY (stmt);\n+  if (!body)\n+    body = build_empty_stmt ();\n+\n+  *stmt_p = build (SWITCH_EXPR, SWITCH_TYPE (stmt), SWITCH_COND (stmt),\n+\t\t   body, NULL_TREE);\n+  annotate_with_locus (*stmt_p, stmt_locus);\n+  gimplify_stmt (stmt_p);\n+\n+  *stmt_p = finish_bc_block (break_block, *stmt_p);\n+  return GS_ALL_DONE;\n+}\n+\n+/* Genericize a RETURN_STMT by turning it into a RETURN_EXPR.  */\n+\n+static enum gimplify_status\n+gimplify_return_stmt (tree *stmt_p)\n+{\n+  tree expr = RETURN_STMT_EXPR (*stmt_p);\n+  expr = build1 (RETURN_EXPR, void_type_node, expr);\n+  if (stmts_are_full_exprs_p ())\n+    expr = build1 (CLEANUP_POINT_EXPR, void_type_node, expr);\n+  *stmt_p = expr;\n+  return GS_OK;\n+}\n+\n+/* Gimplifies a DECL_STMT node T.\n+\n+   If a declaration V has an initial value I, create an expression 'V = I'\n+   and insert it after the DECL_STMT.\n+\n+   PRE_P is a queue for effects that should happen before the DECL_STMT.\n+\n+   MID_P is a queue for effects that should happen after the DECL_STMT,\n+   but before uses of the initialized decl.\n+\n+   POST_P is a queue for effects that should happen after uses of the\n+   initialized decl.\n+\n+   Usually these last two will be the same, but they may need to be\n+   different if the DECL_STMT is somehow embedded in an expression.  */\n+\n+static enum gimplify_status\n+gimplify_decl_stmt (tree *stmt_p)\n+{\n+  tree stmt = *stmt_p;\n+  tree decl = DECL_STMT_DECL (stmt);\n+  tree pre = NULL_TREE;\n+  tree post = NULL_TREE;\n+\n+  if (TREE_TYPE (decl) == error_mark_node)\n+    {\n+      *stmt_p = NULL;\n+      return GS_ERROR;\n+    }\n+    \n+  if (TREE_CODE (decl) == TYPE_DECL)\n+    {\n+      tree type = TREE_TYPE (decl);\n+      if (TYPE_SIZE_UNIT (type)\n+          && !TREE_CONSTANT (TYPE_SIZE_UNIT (type)))\n+        {\n+          /* This is a variable-sized array type.  Simplify its size.  */\n+          tree temp = TYPE_SIZE_UNIT (type);\n+          gimplify_expr (&temp, &pre, &post, is_gimple_val, fb_rvalue);\n+        }\n+    }\n+\n+  if (TREE_CODE (decl) == VAR_DECL && !DECL_EXTERNAL (decl))\n+    {\n+      tree init = DECL_INITIAL (decl);\n+\n+      if (!TREE_CONSTANT (DECL_SIZE (decl)))\n+\t{\n+\t  tree pt_type = build_pointer_type (TREE_TYPE (decl));\n+\t  tree alloc, size;\n+\n+\t  /* This is a variable-sized decl.  Simplify its size and mark it\n+\t     for deferred expansion.  Note that mudflap depends on the format\n+\t     of the emitted code: see mx_register_decls().  */\n+\n+\t  size = get_initialized_tmp_var (DECL_SIZE_UNIT (decl), &pre, &post);\n+\t  DECL_DEFER_OUTPUT (decl) = 1;\n+\t  alloc = build_function_call_expr\n+\t    (implicit_built_in_decls[BUILT_IN_STACK_ALLOC],\n+\t     tree_cons (NULL_TREE,\n+\t\t\tbuild1 (ADDR_EXPR, pt_type, decl),\n+\t\t\ttree_cons (NULL_TREE, size, NULL_TREE)));\n+\t  append_to_compound_expr (alloc, &pre);\n+\t}\n+\n+      if (init && init != error_mark_node)\n+\t{\n+\t  if (!TREE_STATIC (decl))\n+\t    {\n+              /* Do not warn about int x = x; as it is a GCC extension\n+                 to turn off this warning but only if warn_init_self\n+\t\t is zero.  */\n+              if (init == decl && !warn_init_self)\n+                TREE_NO_WARNING (decl) = 1;\n+              \n+\t      DECL_INITIAL (decl) = NULL_TREE;\n+\t      init = build (MODIFY_EXPR, void_type_node, decl, init);\n+\t      if (stmts_are_full_exprs_p ())\n+\t\tinit = build1 (CLEANUP_POINT_EXPR, void_type_node, init);\n+\t      append_to_compound_expr (init, &pre);\n+\t    }\n+\t  else\n+\t    {\n+\t      /* We must still examine initializers for static variables\n+\t\t as they may contain a label address.  */\n+\t      walk_tree (&init, force_labels_r, NULL, NULL);\n+\t    }\n+\t}\n+\n+      /* This decl isn't mentioned in the enclosing block, so add it to the\n+\t list of temps.  FIXME it seems a bit of a kludge to say that\n+\t anonymous artificial vars aren't pushed, but everything else is.  */\n+      if (DECL_ARTIFICIAL (decl) && DECL_NAME (decl) == NULL_TREE)\n+\tgimple_add_tmp_var (decl);\n+    }\n+\n+  append_to_compound_expr (post, &pre);\n+  *stmt_p = pre;\n+  return GS_OK;\n+}\n+\n+/* Gimplification of expression trees.  */\n+\n+/* Gimplify a C99 compound literal expression.  This just means adding the\n+   DECL_STMT before the current EXPR_STMT and using its anonymous decl\n+   instead.  */\n+\n+static enum gimplify_status\n+gimplify_compound_literal_expr (tree *expr_p)\n+{\n+  tree decl_s = COMPOUND_LITERAL_EXPR_DECL_STMT (*expr_p);\n+  tree decl = DECL_STMT_DECL (decl_s);\n+\n+  /* This decl isn't mentioned in the enclosing block, so add it to the\n+     list of temps.  FIXME it seems a bit of a kludge to say that\n+     anonymous artificial vars aren't pushed, but everything else is.  */\n+  if (DECL_NAME (decl) == NULL_TREE)\n+    gimple_add_tmp_var (decl);\n+\n+  gimplify_decl_stmt (&decl_s);\n+  *expr_p = decl_s ? decl_s : decl;\n+  return GS_OK;\n+}\n+\n+/* Do C-specific gimplification.  Args are as for gimplify_expr.  */\n+\n+int\n+c_gimplify_expr (tree *expr_p, tree *pre_p ATTRIBUTE_UNUSED,\n+\t\t tree *post_p ATTRIBUTE_UNUSED)\n+{\n+  enum tree_code code = TREE_CODE (*expr_p);\n+\n+  if (STATEMENT_CODE_P (code))\n+    return c_gimplify_stmt (expr_p);\n+\n+  switch (code)\n+    {\n+    case COMPOUND_LITERAL_EXPR:\n+      return gimplify_compound_literal_expr (expr_p);\n+\n+    case STMT_EXPR:\n+      return gimplify_stmt_expr (expr_p);\n+\n+    default:\n+      return GS_UNHANDLED;\n+    }\n+}\n+\n+/* Returns the final EXPR_STMT which represents the return value of a\n+   STMT_EXPR, or NULL_TREE if none.  */\n+\n+tree\n+stmt_expr_last_stmt (tree stmt_expr)\n+{\n+  tree body = STMT_EXPR_STMT (stmt_expr);\n+  tree last_stmt, substmt;\n+\n+  /* Splice the last expression out of the STMT chain.  */\n+  last_stmt = NULL_TREE;\n+  for (substmt = COMPOUND_BODY (body); substmt;\n+       substmt = TREE_CHAIN (substmt))\n+    if (TREE_CODE (substmt) != SCOPE_STMT)\n+      last_stmt = substmt;\n+\n+  if (last_stmt == NULL_TREE\n+      || TREE_CODE (last_stmt) != EXPR_STMT\n+      || (TREE_TYPE (last_stmt)\n+\t  && VOID_TYPE_P (TREE_TYPE (last_stmt))))\n+    {\n+      location_t loc;\n+      if (last_stmt && EXPR_LOCUS (last_stmt))\n+\tloc = *EXPR_LOCUS (last_stmt);\n+      else if (EXPR_LOCUS (stmt_expr))\n+\tloc = *EXPR_LOCUS (stmt_expr);\n+      else\n+\tloc = input_location;\n+      warning (\"%Hstatement-expressions should end with a \"\n+\t       \"non-void expression\", &loc);\n+      last_stmt = NULL_TREE;\n+    }\n+\n+#if defined ENABLE_CHECKING\n+  if (last_stmt && !is_last_stmt_of_scope (last_stmt))\n+    abort ();\n+#endif\n+\n+  return last_stmt;\n+}\n+\n+/* Gimplify a STMT_EXPR.  EXPR_P points to the expression to gimplify.\n+   After gimplification, if the STMT_EXPR returns a value, EXPR_P will\n+   point to a new temporary that holds that value; otherwise it will be\n+   null.\n+\n+   PRE_P points to the list where side effects that must happen before\n+     *EXPR_P should be stored.  */\n+\n+static enum gimplify_status\n+gimplify_stmt_expr (tree *expr_p)\n+{\n+  tree body = STMT_EXPR_STMT (*expr_p);\n+\n+  if (VOID_TYPE_P (TREE_TYPE (*expr_p)))\n+    {\n+      *expr_p = body;\n+      return c_gimplify_stmt (expr_p);\n+    }\n+  else\n+    {\n+      tree last_stmt = stmt_expr_last_stmt (*expr_p);\n+      tree last_expr = NULL_TREE;\n+\n+      if (last_stmt)\n+\t{\n+\t  last_expr = EXPR_STMT_EXPR (last_stmt);\n+\n+\t  if (stmts_are_full_exprs_p ())\n+\t    last_expr = build1 (CLEANUP_POINT_EXPR, TREE_TYPE (last_expr),\n+\t\t\t\tlast_expr);\n+\t  EXPR_STMT_EXPR (last_stmt) = NULL_TREE;\n+\t}\n+\n+      /* Genericize the block.  */\n+      c_gimplify_stmt (&body);\n+\n+      /* Now retrofit that last expression into the BIND_EXPR.  */\n+      if (last_expr)\n+\t{\n+\t  tree *sub_p;\n+\n+\t  if (!STMT_EXPR_NO_SCOPE (*expr_p))\n+\t    {\n+\t      /* Our BIND_EXPR will always be hidden within\n+\t\t a STATEMENT_LIST.  Discard that.  */\n+\t      body = expr_first (body);\n+\t      sub_p = &BIND_EXPR_BODY (body);\n+\n+\t      /* Append the last expression to the end of the BIND_EXPR.\n+\t\t We'll now re-process this, and let voidify_wrapper_expr\n+\t\t do its job.  */\n+\t      append_to_statement_list_force (last_expr, sub_p);\n+\t      TREE_TYPE (body) = TREE_TYPE (last_expr);\n+\t    }\n+\t  else\n+\t    append_to_compound_expr (last_expr, &body);\n+\t}\n+\n+      *expr_p = body;\n+      return GS_OK;\n+    }\n+}\n+\n+/* Code generation.  */\n+\n+/* Miscellaneous helpers.  */\n+\n+#if defined ENABLE_CHECKING\n+/*  Return nonzero if STMT is the last statement of its scope.  */\n+\n+static int\n+is_last_stmt_of_scope (tree stmt)\n+{\n+  return (TREE_CHAIN (stmt) == NULL_TREE\n+\t  || (TREE_CODE (TREE_CHAIN (stmt)) == SCOPE_STMT\n+\t      && SCOPE_END_P (TREE_CHAIN (stmt))));\n+}\n+#endif"}, {"sha": "da41c3a5c7ab8383b516541b5cf39f82f69333d4", "filename": "gcc/c-tree.h", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-tree.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -29,6 +29,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define C_SIZEOF_STRUCT_LANG_IDENTIFIER \\\n   (sizeof (struct c_common_identifier) + 3 * sizeof (void *))\n \n+/* For gc purposes, return the most likely link for the longest chain.  */\n+#define C_LANG_TREE_NODE_CHAIN_NEXT(T)\t\t\t\t\\\n+  ((union lang_tree_node *)\t\t\t\t\t\\\n+   (TREE_CODE (T) == INTEGER_TYPE ? TYPE_NEXT_VARIANT (T)\t\\\n+    : TREE_CODE (T) == COMPOUND_EXPR ? TREE_OPERAND (T, 1)\t\\\n+    : TREE_CHAIN (T)))\n+\n /* Language-specific declaration information.  */\n \n struct lang_decl GTY(())\n@@ -58,10 +65,13 @@ struct lang_decl GTY(())\n    and C_RID_YYCODE is the token number wanted by Yacc.  */\n #define C_IS_RESERVED_WORD(ID) TREE_LANG_FLAG_0 (ID)\n \n-/* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n struct lang_type GTY(())\n {\n+  /* In a RECORD_TYPE, a sorted array of the fields of the type.  */\n   struct sorted_fields_type * GTY ((reorder (\"resort_sorted_fields\"))) s;\n+  /* In an ENUMERAL_TYPE, the min and max values.  */\n+  tree enum_min;\n+  tree enum_max;\n };\n \n /* Record whether a type or decl was written with nonconstant size.\n@@ -182,16 +192,16 @@ extern tree start_struct (enum tree_code, tree);\n extern void store_parm_decls (void);\n extern tree xref_tag (enum tree_code, tree);\n extern tree c_begin_compound_stmt (void);\n-extern void c_expand_decl_stmt (tree);\n+extern int c_expand_decl (tree);\n extern void c_static_assembler_name (tree);\n extern tree make_pointer_declarator (tree, tree);\n \n /* in c-objc-common.c */\n extern int c_disregard_inline_limits (tree);\n extern int c_cannot_inline_tree_fn (tree *);\n extern bool c_objc_common_init (void);\n+extern bool c_missing_noreturn_ok_p (tree);\n extern tree c_objc_common_truthvalue_conversion (tree expr);\n-extern int c_missing_noreturn_ok_p (tree);\n extern void c_objc_common_finish_file (void);\n extern int defer_fn (tree);\n extern bool c_warn_unused_global_decl (tree);\n@@ -248,6 +258,7 @@ extern void c_finish_case (void);\n extern tree build_asm_expr (tree, tree, tree, tree, bool);\n extern tree build_asm_stmt (tree, tree);\n extern tree c_convert_parm_for_inlining (tree, tree, tree, int);\n+extern int c_types_compatible_p (tree, tree);\n \n /* Set to 0 at beginning of a function definition, set to 1 if\n    a return statement that specifies a return value is seen.  */"}, {"sha": "14270b971cabd5c6abd9b915a383ab7d9e419717", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 48, "deletions": 54, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -687,7 +687,9 @@ tagged_types_tu_compatible_p (tree t1, tree t2, int flags)\n   /* We have to verify that the tags of the types are the same.  This\n      is harder than it looks because this may be a typedef, so we have\n      to go look at the original type.  It may even be a typedef of a\n-     typedef...  */\n+     typedef...\n+     In the case of compiler-created builtin structs the TYPE_DECL\n+     may be a dummy, with no DECL_ORIGINAL_TYPE.  Don't fault.  */\n   while (TYPE_NAME (t1)\n \t && TREE_CODE (TYPE_NAME (t1)) == TYPE_DECL\n \t && DECL_ORIGINAL_TYPE (TYPE_NAME (t1)))\n@@ -1143,7 +1145,6 @@ default_function_array_conversion (tree exp)\n \t  adr = build1 (ADDR_EXPR, ptrtype, exp);\n \t  if (!c_mark_addressable (exp))\n \t    return error_mark_node;\n-\t  TREE_CONSTANT (adr) = staticp (exp);\n \t  TREE_SIDE_EFFECTS (adr) = 0;   /* Default would be, same as EXP.  */\n \t  return adr;\n \t}\n@@ -1489,8 +1490,7 @@ build_array_ref (tree array, tree index)\n       || TREE_TYPE (index) == error_mark_node)\n     return error_mark_node;\n \n-  if (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE\n-      && TREE_CODE (array) != INDIRECT_REF)\n+  if (TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE)\n     {\n       tree rval, type;\n \n@@ -1660,6 +1660,7 @@ build_external_ref (tree id, int fun)\n     {\n       ref = DECL_INITIAL (ref);\n       TREE_CONSTANT (ref) = 1;\n+      TREE_INVARIANT (ref) = 1;\n     }\n   else if (current_function_decl != 0\n \t   && !DECL_FILE_SCOPE_P (current_function_decl)\n@@ -2088,14 +2089,12 @@ parser_build_binary_op (enum tree_code code, tree arg1, tree arg2)\n     C_SET_EXP_ORIGINAL_CODE (result, code);\n   else\n     {\n-      int flag = TREE_CONSTANT (result);\n       /* We used to use NOP_EXPR rather than NON_LVALUE_EXPR\n \t so that convert_for_assignment wouldn't strip it.\n \t That way, we got warnings for things like p = (1 - 1).\n \t But it turns out we should not get those warnings.  */\n       result = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n       C_SET_EXP_ORIGINAL_CODE (result, code);\n-      TREE_CONSTANT (result) = flag;\n     }\n \n   return result;\n@@ -2127,7 +2126,6 @@ c_tree_expr_nonnegative_p (tree t)\n static tree\n pointer_diff (tree op0, tree op1)\n {\n-  tree result, folded;\n   tree restype = ptrdiff_type_node;\n \n   tree target_type = TREE_TYPE (TREE_TYPE (op0));\n@@ -2191,13 +2189,7 @@ pointer_diff (tree op0, tree op1)\n   op1 = c_size_in_bytes (target_type);\n \n   /* Divide by the size, in easiest possible way.  */\n-\n-  result = build (EXACT_DIV_EXPR, restype, op0, convert (restype, op1));\n-\n-  folded = fold (result);\n-  if (folded == result)\n-    TREE_CONSTANT (folded) = TREE_CONSTANT (op0) & TREE_CONSTANT (op1);\n-  return folded;\n+  return fold (build (EXACT_DIV_EXPR, restype, op0, convert (restype, op1)));\n }\n \f\n /* Construct and perhaps optimize a tree representation\n@@ -2420,7 +2412,7 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \tTREE_SIDE_EFFECTS (val) = 1;\n \tval = convert (result_type, val);\n \tif (TREE_CODE (val) != code)\n-\t  TREE_NO_UNUSED_WARNING (val) = 1;\n+\t  TREE_NO_WARNING (val) = 1;\n \treturn val;\n       }\n \n@@ -2492,12 +2484,6 @@ build_unary_op (enum tree_code code, tree xarg, int flag)\n \telse\n \t  addr = build1 (code, argtype, arg);\n \n-\t/* Address of a static or external variable or\n-\t   file-scope function counts as a constant.  */\n-\tif (staticp (arg)\n-\t    && ! (TREE_CODE (arg) == FUNCTION_DECL\n-\t\t  && !DECL_FILE_SCOPE_P (arg)))\n-\t  TREE_CONSTANT (addr) = 1;\n \treturn addr;\n       }\n \n@@ -2933,6 +2919,7 @@ build_c_cast (tree type, tree expr)\n \t\t\t\t\t      build_tree_list (field, value)),\n \t\t\t   0);\n \t  TREE_CONSTANT (t) = TREE_CONSTANT (value);\n+\t  TREE_INVARIANT (t) = TREE_INVARIANT (value);\n \t  return t;\n \t}\n       error (\"cast to union type from type not present in union\");\n@@ -4758,7 +4745,7 @@ pop_init_level (int implicit)\n \t  constructor = build_constructor (constructor_type,\n \t\t\t\t\t   nreverse (constructor_elements));\n \t  if (constructor_constant)\n-\t    TREE_CONSTANT (constructor) = 1;\n+\t    TREE_CONSTANT (constructor) = TREE_INVARIANT (constructor) = 1;\n \t  if (constructor_constant && constructor_simple)\n \t    TREE_STATIC (constructor) = 1;\n \t}\n@@ -6052,8 +6039,8 @@ process_init_element (tree value)\n tree\n build_asm_stmt (tree cv_qualifier, tree args)\n {\n-  if (!TREE_OPERAND (args, 0))\n-    TREE_OPERAND (args, 0) = cv_qualifier;\n+  if (!ASM_VOLATILE_P (args) && cv_qualifier)\n+    ASM_VOLATILE_P (args) = 1;\n   return add_stmt (args);\n }\n \n@@ -6068,36 +6055,42 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n {\n   tree tail;\n   tree args;\n+  int i;\n+  const char *constraint;\n+  bool allows_mem, allows_reg, is_inout;\n+  int ninputs;\n+  int noutputs;\n+\n+  ninputs = list_length (inputs);\n+  noutputs = list_length (outputs);\n \n-  /* We can remove output conversions that change the type,\n-     but not the mode.  */\n-  for (tail = outputs; tail; tail = TREE_CHAIN (tail))\n+  /* Remove output conversions that change the type but not the mode.  */\n+  for (i = 0, tail = outputs; tail; ++i, tail = TREE_CHAIN (tail))\n     {\n       tree output = TREE_VALUE (tail);\n-\n       STRIP_NOPS (output);\n       TREE_VALUE (tail) = output;\n+      lvalue_or_else (output, \"invalid lvalue in asm statement\");\n \n-      /* Allow conversions as LHS here.  build_modify_expr as called below\n-\t will do the right thing with them.  */\n-      while (TREE_CODE (output) == NOP_EXPR\n-\t     || TREE_CODE (output) == CONVERT_EXPR\n-\t     || TREE_CODE (output) == FLOAT_EXPR\n-\t     || TREE_CODE (output) == FIX_TRUNC_EXPR\n-\t     || TREE_CODE (output) == FIX_FLOOR_EXPR\n-\t     || TREE_CODE (output) == FIX_ROUND_EXPR\n-\t     || TREE_CODE (output) == FIX_CEIL_EXPR)\n-\toutput = TREE_OPERAND (output, 0);\n+      constraint = TREE_STRING_POINTER (TREE_VALUE (TREE_PURPOSE (tail)));\n \n-      lvalue_or_else (TREE_VALUE (tail), \"invalid lvalue in asm statement\");\n-    }\n+      if (!parse_output_constraint (&constraint, i, ninputs, noutputs,\n+                                    &allows_mem, &allows_reg, &is_inout))\n+        {\n+          /* By marking this operand as erroneous, we will not try\n+          to process this operand again in expand_asm_operands.  */\n+          TREE_VALUE (tail) = error_mark_node;\n+          continue;\n+        }\n \n-  /* Remove output conversions that change the type but not the mode.  */\n-  for (tail = outputs; tail; tail = TREE_CHAIN (tail))\n-    {\n-      tree output = TREE_VALUE (tail);\n-      STRIP_NOPS (output);\n-      TREE_VALUE (tail) = output;\n+      /* If the operand is a DECL that is going to end up in\n+        memory, assume it is addressable.  This is a bit more\n+        conservative than it would ideally be; the exact test is\n+        buried deep in expand_asm_operands and depends on the\n+        DECL_RTL for the OPERAND -- which we don't have at this\n+        point.  */\n+      if (!allows_reg && DECL_P (output))\n+        c_mark_addressable (output);\n     }\n \n   /* Perform default conversions on array and function inputs.\n@@ -6106,12 +6099,12 @@ build_asm_expr (tree string, tree outputs, tree inputs, tree clobbers,\n   for (tail = inputs; tail; tail = TREE_CHAIN (tail))\n     TREE_VALUE (tail) = default_function_array_conversion (TREE_VALUE (tail));\n \n-  args = build_stmt (ASM_STMT, 0, string, outputs, inputs, clobbers);\n+  args = build_stmt (ASM_STMT, string, outputs, inputs, clobbers);\n \n   /* Simple asm statements are treated as volatile.  */\n   if (simple)\n     {\n-      TREE_OPERAND (args, 0) = ridpointers[RID_VOLATILE];\n+      ASM_VOLATILE_P (args) = 1;\n       ASM_INPUT_P (args) = 1;\n     }\n   return args;\n@@ -6375,6 +6368,9 @@ c_finish_case (void)\n {\n   struct c_switch *cs = switch_stack;\n \n+  /* Emit warnings as needed.  */\n+  c_do_switch_warnings (cs->cases, cs->switch_stmt);\n+\n   /* Rechain the next statements to the SWITCH_STMT.  */\n   last_tree = cs->switch_stmt;\n \n@@ -7103,16 +7099,14 @@ build_binary_op (enum tree_code code, tree orig_op0, tree orig_op1,\n \n   {\n     tree result = build (resultcode, build_type, op0, op1);\n-    tree folded;\n \n     /* Treat expressions in initializers specially as they can't trap.  */\n-    folded = initializer_stack ? fold_initializer (result)\n+    result = initializer_stack ? fold_initializer (result)\n \t\t\t       : fold (result);\n-    if (folded == result)\n-      TREE_CONSTANT (folded) = TREE_CONSTANT (op0) & TREE_CONSTANT (op1);\n+\n     if (final_type != 0)\n-      return convert (final_type, folded);\n-    return folded;\n+      result = convert (final_type, result);\n+    return result;\n   }\n }\n "}, {"sha": "bafe6a14d8ba6305fcf66a0cbc074146eb91270b", "filename": "gcc/c.opt", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fc.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc.opt?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -469,10 +469,6 @@ fdollars-in-identifiers\n C ObjC C++ ObjC++\n Permit '$' as an identifier character\n \n-fdump-\n-C ObjC C++ ObjC++ Joined RejectNegative\n--fdump-<type>\tDump various compiler internals to a file\n-\n felide-constructors\n C++ ObjC++\n "}, {"sha": "e15a96b9c3749c3b9d7c95e39f2f7e87b1d9614f", "filename": "gcc/calls.c", "status": "modified", "additions": 163, "deletions": 312, "changes": 475, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -120,7 +120,7 @@ int stack_arg_under_construction;\n static int calls_function (tree, int);\n static int calls_function_1 (tree, int);\n \n-static void emit_call_1 (rtx, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n+static void emit_call_1 (rtx, tree, tree, tree, HOST_WIDE_INT, HOST_WIDE_INT,\n \t\t\t HOST_WIDE_INT, rtx, rtx, int, rtx, int,\n \t\t\t CUMULATIVE_ARGS *);\n static void precompute_register_parameters (int, struct arg_data *, int *);\n@@ -134,15 +134,14 @@ static void initialize_argument_information (int, struct arg_data *,\n \t\t\t\t\t     struct args_size *, int, tree,\n \t\t\t\t\t     tree, CUMULATIVE_ARGS *, int,\n \t\t\t\t\t     rtx *, int *, int *, int *,\n-\t\t\t\t\t     bool);\n+\t\t\t\t\t     bool *, bool);\n static void compute_argument_addresses (struct arg_data *, rtx, int);\n static rtx rtx_for_function_call (tree, tree);\n static void load_register_parameters (struct arg_data *, int, rtx *, int,\n \t\t\t\t      int, int *);\n static rtx emit_library_call_value_1 (int, rtx, rtx, enum libcall_type,\n \t\t\t\t      enum machine_mode, int, va_list);\n static int special_function_p (tree, int);\n-static rtx try_to_integrate (tree, tree, rtx, int, tree, rtx);\n static int check_sibcall_argument_overlap_1 (rtx);\n static int check_sibcall_argument_overlap (rtx, struct arg_data *, int);\n \n@@ -280,17 +279,11 @@ calls_function_1 (tree exp, int which)\n    CALL_INSN_FUNCTION_USAGE information.  */\n \n rtx\n-prepare_call_address (rtx funexp, tree fndecl, rtx *call_fusage,\n-\t\t      int reg_parm_seen, int sibcallp)\n+prepare_call_address (rtx funexp, rtx static_chain_value,\n+\t\t      rtx *call_fusage, int reg_parm_seen, int sibcallp)\n {\n-  rtx static_chain_value = 0;\n-\n   funexp = protect_from_queue (funexp, 0);\n \n-  if (fndecl != 0)\n-    /* Get possible static chain value for nested function in C.  */\n-    static_chain_value = lookup_static_chain (fndecl);\n-\n   /* Make a valid memory address and copy constants through pseudo-regs,\n      but not for a constant address if -fno-function-cse.  */\n   if (GET_CODE (funexp) != SYMBOL_REF)\n@@ -362,7 +355,8 @@ prepare_call_address (rtx funexp, tree fndecl, rtx *call_fusage,\n    denote registers used by the called function.  */\n \n static void\n-emit_call_1 (rtx funexp, tree fndecl ATTRIBUTE_UNUSED, tree funtype ATTRIBUTE_UNUSED,\n+emit_call_1 (rtx funexp, tree fntree, tree fndecl ATTRIBUTE_UNUSED,\n+\t     tree funtype ATTRIBUTE_UNUSED,\n \t     HOST_WIDE_INT stack_size ATTRIBUTE_UNUSED,\n \t     HOST_WIDE_INT rounded_stack_size,\n \t     HOST_WIDE_INT struct_value_size ATTRIBUTE_UNUSED,\n@@ -506,7 +500,16 @@ emit_call_1 (rtx funexp, tree fndecl ATTRIBUTE_UNUSED, tree funtype ATTRIBUTE_UN\n     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, const0_rtx,\n \t\t\t\t\t       REG_NOTES (call_insn));\n   else\n-    note_eh_region_may_contain_throw ();\n+    {\n+      int rn = lookup_stmt_eh_region (fntree);\n+\n+      /* If rn < 0, then either (1) tree-ssa not used or (2) doesn't\n+\t throw, which we already took care of.  */\n+      if (rn > 0)\n+\tREG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_EH_REGION, GEN_INT (rn),\n+\t\t\t\t\t\t   REG_NOTES (call_insn));\n+      note_current_region_may_contain_throw ();\n+    }\n \n   if (ecf_flags & ECF_NORETURN)\n     REG_NOTES (call_insn) = gen_rtx_EXPR_LIST (REG_NORETURN, const0_rtx,\n@@ -590,8 +593,7 @@ emit_call_1 (rtx funexp, tree fndecl ATTRIBUTE_UNUSED, tree funtype ATTRIBUTE_UN\n static int\n special_function_p (tree fndecl, int flags)\n {\n-  if (! (flags & ECF_MALLOC)\n-      && fndecl && DECL_NAME (fndecl)\n+  if (fndecl && DECL_NAME (fndecl)\n       && IDENTIFIER_LENGTH (DECL_NAME (fndecl)) <= 17\n       /* Exclude functions not at the file scope, or not `extern',\n \t since they are not the magic functions we would otherwise\n@@ -714,6 +716,8 @@ flags_from_decl_or_type (tree exp)\n \n       if (TREE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n \tflags |= ECF_LIBCALL_BLOCK | ECF_CONST;\n+\n+      flags = special_function_p (exp, flags);\n     }\n   else if (TYPE_P (exp) && TYPE_READONLY (exp) && ! TREE_THIS_VOLATILE (exp))\n     flags |= ECF_CONST;\n@@ -1012,6 +1016,9 @@ store_unaligned_arguments_into_pseudos (struct arg_data *args, int num_actuals)\n    OLD_PENDING_ADJ, MUST_PREALLOCATE and FLAGS are pointers to integer\n    flags which may may be modified by this routine. \n \n+   MAY_TAILCALL is cleared if we encounter an invisible pass-by-reference\n+   that requires allocation of stack space.\n+\n    CALL_FROM_THUNK_P is true if this call is the jump from a thunk to\n    the thunked-to function.  */\n \n@@ -1025,7 +1032,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t int reg_parm_stack_space,\n \t\t\t\t rtx *old_stack_level, int *old_pending_adj,\n \t\t\t\t int *must_preallocate, int *ecf_flags,\n-\t\t\t\t bool call_from_thunk_p)\n+\t\t\t\t bool *may_tailcall, bool call_from_thunk_p)\n {\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n@@ -1138,6 +1145,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t\t   build_pointer_type (type),\n \t\t\t\t\t   args[i].tree_value);\n \t      type = build_pointer_type (type);\n+\t      *may_tailcall = false;\n \t    }\n \t  else\n \t    {\n@@ -1177,6 +1185,7 @@ initialize_argument_information (int num_actuals ATTRIBUTE_UNUSED,\n \t\t\t\t\t   build_pointer_type (type),\n \t\t\t\t\t   make_tree (type, copy));\n \t      type = build_pointer_type (type);\n+\t      *may_tailcall = false;\n \t    }\n \t}\n \n@@ -1705,120 +1714,6 @@ load_register_parameters (struct arg_data *args, int num_actuals,\n     }\n }\n \n-/* Try to integrate function.  See expand_inline_function for documentation\n-   about the parameters.  */\n-\n-static rtx\n-try_to_integrate (tree fndecl, tree actparms, rtx target, int ignore,\n-\t\t  tree type, rtx structure_value_addr)\n-{\n-  rtx temp;\n-  rtx before_call;\n-  int i;\n-  rtx old_stack_level = 0;\n-  int reg_parm_stack_space = 0;\n-\n-#ifdef REG_PARM_STACK_SPACE\n-  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n-#endif\n-\n-  before_call = get_last_insn ();\n-\n-  timevar_push (TV_INTEGRATION);\n-\n-  temp = expand_inline_function (fndecl, actparms, target,\n-\t\t\t\t ignore, type,\n-\t\t\t\t structure_value_addr);\n-\n-  timevar_pop (TV_INTEGRATION);\n-\n-  /* If inlining succeeded, return.  */\n-  if (temp != (rtx) (size_t) - 1)\n-    {\n-      if (ACCUMULATE_OUTGOING_ARGS)\n-\t{\n-\t  /* If the outgoing argument list must be preserved, push\n-\t     the stack before executing the inlined function if it\n-\t     makes any calls.  */\n-\n-\t  i = reg_parm_stack_space;\n-\t  if (i > highest_outgoing_arg_in_use)\n-\t    i = highest_outgoing_arg_in_use;\n-\t  while (--i >= 0 && stack_usage_map[i] == 0)\n-\t    ;\n-\n-\t  if (stack_arg_under_construction || i >= 0)\n-\t    {\n-\t      rtx first_insn\n-\t\t= before_call ? NEXT_INSN (before_call) : get_insns ();\n-\t      rtx insn = NULL_RTX, seq;\n-\n-\t      /* Look for a call in the inline function code.\n-\t         If DECL_STRUCT_FUNCTION (fndecl)->outgoing_args_size is\n-\t         nonzero then there is a call and it is not necessary\n-\t         to scan the insns.  */\n-\n-\t      if (DECL_STRUCT_FUNCTION (fndecl)->outgoing_args_size == 0)\n-\t\tfor (insn = first_insn; insn; insn = NEXT_INSN (insn))\n-\t\t  if (GET_CODE (insn) == CALL_INSN)\n-\t\t    break;\n-\n-\t      if (insn)\n-\t\t{\n-\t\t  /* Reserve enough stack space so that the largest\n-\t\t     argument list of any function call in the inline\n-\t\t     function does not overlap the argument list being\n-\t\t     evaluated.  This is usually an overestimate because\n-\t\t     allocate_dynamic_stack_space reserves space for an\n-\t\t     outgoing argument list in addition to the requested\n-\t\t     space, but there is no way to ask for stack space such\n-\t\t     that an argument list of a certain length can be\n-\t\t     safely constructed.\n-\n-\t\t     Add the stack space reserved for register arguments, if\n-\t\t     any, in the inline function.  What is really needed is the\n-\t\t     largest value of reg_parm_stack_space in the inline\n-\t\t     function, but that is not available.  Using the current\n-\t\t     value of reg_parm_stack_space is wrong, but gives\n-\t\t     correct results on all supported machines.  */\n-\n-\t\t  int adjust =\n-\t\t\t(DECL_STRUCT_FUNCTION (fndecl)->outgoing_args_size\n-\t\t\t + reg_parm_stack_space);\n-\n-\t\t  start_sequence ();\n-\t\t  emit_stack_save (SAVE_BLOCK, &old_stack_level, NULL_RTX);\n-\t\t  allocate_dynamic_stack_space (GEN_INT (adjust),\n-\t\t\t\t\t\tNULL_RTX, BITS_PER_UNIT);\n-\t\t  seq = get_insns ();\n-\t\t  end_sequence ();\n-\t\t  emit_insn_before (seq, first_insn);\n-\t\t  emit_stack_restore (SAVE_BLOCK, old_stack_level, NULL_RTX);\n-\t\t}\n-\t    }\n-\t}\n-\n-      /* If the result is equivalent to TARGET, return TARGET to simplify\n-         checks in store_expr.  They can be equivalent but not equal in the\n-         case of a function that returns BLKmode.  */\n-      if (temp != target && rtx_equal_p (temp, target))\n-\treturn target;\n-      return temp;\n-    }\n-\n-  /* If inlining failed, mark FNDECL as needing to be compiled\n-     separately after all.  If function was declared inline,\n-     give a warning.  */\n-  if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n-      && optimize > 0 && !TREE_ADDRESSABLE (fndecl))\n-    {\n-      warning (\"%Jinlining failed in call to '%F'\", fndecl, fndecl);\n-      warning (\"called from here\");\n-    }\n-  lang_hooks.mark_addressable (fndecl);\n-  return (rtx) (size_t) - 1;\n-}\n-\n /* We need to pop PENDING_STACK_ADJUST bytes.  But, if the arguments\n    wouldn't fill up an even multiple of PREFERRED_UNIT_STACK_BOUNDARY\n    bytes, then we would need to push some additional bytes to pad the\n@@ -2029,6 +1924,69 @@ shift_returned_value (tree type, rtx *value)\n   return false;\n }\n \n+/* Remove all REG_EQUIV notes found in the insn chain.  */\n+\n+static void\n+purge_reg_equiv_notes (void)\n+{\n+  rtx insn;\n+\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      while (1)\n+\t{\n+\t  rtx note = find_reg_note (insn, REG_EQUIV, 0);\n+\t  if (note)\n+\t    {\n+\t      /* Remove the note and keep looking at the notes for\n+\t\t this insn.  */\n+\t      remove_note (insn, note);\n+\t      continue;\n+\t    }\n+\t  break;\n+\t}\n+    }\n+}\n+\n+/* Clear RTX_UNCHANGING_P flag of incoming argument MEMs.  */\n+\n+static void\n+purge_mem_unchanging_flag (rtx x)\n+{\n+  RTX_CODE code;\n+  int i, j;\n+  const char *fmt;\n+\n+  if (x == NULL_RTX)\n+    return;\n+\n+  code = GET_CODE (x);\n+\n+  if (code == MEM)\n+    {\n+      if (RTX_UNCHANGING_P (x)\n+\t  && (XEXP (x, 0) == current_function_internal_arg_pointer\n+\t      || (GET_CODE (XEXP (x, 0)) == PLUS\n+\t\t  && XEXP (XEXP (x, 0), 0) ==\n+\t\t     current_function_internal_arg_pointer\n+\t\t  && GET_CODE (XEXP (XEXP (x, 0), 1)) == CONST_INT)))\n+\tRTX_UNCHANGING_P (x) = 0;\n+      return;\n+    }\n+\n+  /* Scan all subexpressions.  */\n+  fmt = GET_RTX_FORMAT (code);\n+  for (i = 0; i < GET_RTX_LENGTH (code); i++, fmt++)\n+    {\n+      if (*fmt == 'e')\n+\tpurge_mem_unchanging_flag (XEXP (x, i));\n+      else if (*fmt == 'E')\n+\tfor (j = 0; j < XVECLEN (x, i); j++)\n+\t  purge_mem_unchanging_flag (XVECEXP (x, i, j));\n+    }\n+}\n+\n+\n /* Generate all the code for a function call\n    and return an rtx for its value.\n    Store the value in TARGET (specified as an rtx) if convenient.\n@@ -2045,11 +2003,9 @@ expand_call (tree exp, rtx target, int ignore)\n   tree actparms = TREE_OPERAND (exp, 1);\n   /* RTX for the function to be called.  */\n   rtx funexp;\n-  /* Sequence of insns to perform a tail recursive \"call\".  */\n-  rtx tail_recursion_insns = NULL_RTX;\n   /* Sequence of insns to perform a normal \"call\".  */\n   rtx normal_call_insns = NULL_RTX;\n-  /* Sequence of insns to perform a tail recursive \"call\".  */\n+  /* Sequence of insns to perform a tail \"call\".  */\n   rtx tail_call_insns = NULL_RTX;\n   /* Data type of the function.  */\n   tree funtype;\n@@ -2059,9 +2015,7 @@ expand_call (tree exp, rtx target, int ignore)\n   tree fndecl = 0;\n   /* The type of the function being called.  */\n   tree fntype;\n-  rtx insn;\n-  int try_tail_call = 1;\n-  int try_tail_recursion = 1;\n+  bool try_tail_call = CALL_EXPR_TAILCALL (exp);\n   int pass;\n \n   /* Register in which non-BLKmode value will be returned,\n@@ -2122,8 +2076,6 @@ expand_call (tree exp, rtx target, int ignore)\n \n   /* Mask of ECF_ flags.  */\n   int flags = 0;\n-  /* Nonzero if this is a call to an inline function.  */\n-  int is_integrable = 0;\n #ifdef REG_PARM_STACK_SPACE\n   /* Define the boundary of the register parm stack space that needs to be\n      saved, if any.  */\n@@ -2132,7 +2084,6 @@ expand_call (tree exp, rtx target, int ignore)\n #endif\n \n   int initial_highest_arg_in_use = highest_outgoing_arg_in_use;\n-  rtx temp_target = 0;\n   char *initial_stack_usage_map = stack_usage_map;\n \n   int old_stack_allocated;\n@@ -2156,58 +2107,23 @@ expand_call (tree exp, rtx target, int ignore)\n   HOST_WIDE_INT preferred_stack_boundary;\n   /* The alignment of the stack, in bytes.  */\n   HOST_WIDE_INT preferred_unit_stack_boundary;\n-\n+  /* The static chain value to use for this call.  */\n+  rtx static_chain_value;\n   /* See if this is \"nothrow\" function call.  */\n   if (TREE_NOTHROW (exp))\n     flags |= ECF_NOTHROW;\n \n-  /* See if we can find a DECL-node for the actual function.\n-     As a result, decide whether this is a call to an integrable function.  */\n-\n+  /* See if we can find a DECL-node for the actual function, and get the\n+     function attributes (flags) from the function decl or type node.  */\n   fndecl = get_callee_fndecl (exp);\n   if (fndecl)\n     {\n       fntype = TREE_TYPE (fndecl);\n-      if (!flag_no_inline\n-\t  && fndecl != current_function_decl\n-\t  && DECL_INLINE (fndecl)\n-\t  && DECL_STRUCT_FUNCTION (fndecl)\n-\t  && DECL_STRUCT_FUNCTION (fndecl)->inlinable)\n-\tis_integrable = 1;\n-      else if (! TREE_ADDRESSABLE (fndecl))\n-\t{\n-\t  /* In case this function later becomes inlinable,\n-\t     record that there was already a non-inline call to it.\n-\n-\t     Use abstraction instead of setting TREE_ADDRESSABLE\n-\t     directly.  */\n-\t  if (DECL_INLINE (fndecl) && warn_inline && !flag_no_inline\n-\t      && optimize > 0)\n-\t    {\n-\t      warning (\"%Jcan't inline call to '%F'\", fndecl, fndecl);\n-\t      warning (\"called from here\");\n-\t    }\n-\t  lang_hooks.mark_addressable (fndecl);\n-\t}\n-\n-      if (ignore\n-\t  && lookup_attribute (\"warn_unused_result\",\n-\t\t\t       TYPE_ATTRIBUTES (TREE_TYPE (fndecl))))\n-\twarning (\"ignoring return value of `%D', \"\n-\t\t \"declared with attribute warn_unused_result\", fndecl);\n-\n       flags |= flags_from_decl_or_type (fndecl);\n     }\n-\n-  /* If we don't have specific function to call, see if we have a\n-     attributes set in the type.  */\n   else\n     {\n       fntype = TREE_TYPE (TREE_TYPE (p));\n-      if (ignore\n-\t  && lookup_attribute (\"warn_unused_result\", TYPE_ATTRIBUTES (fntype)))\n-\twarning (\"ignoring return value of function \"\n-\t\t \"declared with attribute warn_unused_result\");\n       flags |= flags_from_decl_or_type (fntype);\n     }\n \n@@ -2264,15 +2180,6 @@ expand_call (tree exp, rtx target, int ignore)\n #ifdef PCC_STATIC_STRUCT_RETURN\n       {\n \tpcc_struct_value = 1;\n-\t/* Easier than making that case work right.  */\n-\tif (is_integrable)\n-\t  {\n-\t    /* In case this is a static function, note that it has been\n-\t       used.  */\n-\t    if (! TREE_ADDRESSABLE (fndecl))\n-\t      lang_hooks.mark_addressable (fndecl);\n-\t    is_integrable = 0;\n-\t  }\n       }\n #else /* not PCC_STATIC_STRUCT_RETURN */\n       {\n@@ -2305,17 +2212,6 @@ expand_call (tree exp, rtx target, int ignore)\n #endif /* not PCC_STATIC_STRUCT_RETURN */\n     }\n \n-  /* If called function is inline, try to integrate it.  */\n-\n-  if (is_integrable)\n-    {\n-      rtx temp = try_to_integrate (fndecl, actparms, target,\n-\t\t\t\t   ignore, TREE_TYPE (exp),\n-\t\t\t\t   structure_value_addr);\n-      if (temp != (rtx) (size_t) - 1)\n-\treturn temp;\n-    }\n-\n   /* Figure out the amount to which the stack should be aligned.  */\n   preferred_stack_boundary = PREFERRED_STACK_BOUNDARY;\n   if (fndecl)\n@@ -2341,10 +2237,6 @@ expand_call (tree exp, rtx target, int ignore)\n   else\n     type_arg_types = TYPE_ARG_TYPES (funtype);\n \n-  /* See if this is a call to a function that can return more than once\n-     or a call to longjmp or malloc.  */\n-  flags |= special_function_p (fndecl, flags);\n-\n   if (flags & ECF_MAY_BE_ALLOCA)\n     current_function_calls_alloca = 1;\n \n@@ -2427,7 +2319,7 @@ expand_call (tree exp, rtx target, int ignore)\n \t\t\t\t   &args_so_far, reg_parm_stack_space,\n \t\t\t\t   &old_stack_level, &old_pending_adj,\n \t\t\t\t   &must_preallocate, &flags,\n-\t\t\t\t   CALL_FROM_THUNK_P (exp));\n+\t\t\t\t   &try_tail_call, CALL_FROM_THUNK_P (exp));\n \n   if (args_size.var)\n     {\n@@ -2476,14 +2368,9 @@ expand_call (tree exp, rtx target, int ignore)\n       || !rtx_equal_function_value_matters\n       || current_nesting_level () == 0\n       || any_pending_cleanups ()\n-      || args_size.var)\n-    try_tail_call = try_tail_recursion = 0;\n-\n-  /* Tail recursion fails, when we are not dealing with recursive calls.  */\n-  if (!try_tail_recursion\n-      || TREE_CODE (addr) != ADDR_EXPR\n-      || TREE_OPERAND (addr, 0) != current_function_decl)\n-    try_tail_recursion = 0;\n+      || args_size.var\n+      || lookup_stmt_eh_region (exp) >= 0)\n+    try_tail_call = 0;\n \n   /*  Rest of purposes for tail call optimizations to fail.  */\n   if (\n@@ -2521,7 +2408,7 @@ expand_call (tree exp, rtx target, int ignore)\n       || !lang_hooks.decls.ok_for_sibcall (fndecl))\n     try_tail_call = 0;\n \n-  if (try_tail_call || try_tail_recursion)\n+  if (try_tail_call)\n     {\n       int end, inc;\n       actparms = NULL_TREE;\n@@ -2556,62 +2443,16 @@ expand_call (tree exp, rtx target, int ignore)\n       for (; i != end; i += inc)\n \t{\n           args[i].tree_value = fix_unsafe_tree (args[i].tree_value);\n-\t  /* We need to build actparms for optimize_tail_recursion.  We can\n-\t     safely trash away TREE_PURPOSE, since it is unused by this\n-\t     function.  */\n-\t  if (try_tail_recursion)\n-\t    actparms = tree_cons (NULL_TREE, args[i].tree_value, actparms);\n \t}\n       /* Do the same for the function address if it is an expression.  */\n       if (!fndecl)\n         addr = fix_unsafe_tree (addr);\n       /* Expanding one of those dangerous arguments could have added\n \t cleanups, but otherwise give it a whirl.  */\n       if (any_pending_cleanups ())\n-\ttry_tail_call = try_tail_recursion = 0;\n+\ttry_tail_call = 0;\n     }\n \n-  /* Generate a tail recursion sequence when calling ourselves.  */\n-\n-  if (try_tail_recursion)\n-    {\n-      /* We want to emit any pending stack adjustments before the tail\n-\t recursion \"call\".  That way we know any adjustment after the tail\n-\t recursion call can be ignored if we indeed use the tail recursion\n-\t call expansion.  */\n-      int save_pending_stack_adjust = pending_stack_adjust;\n-      int save_stack_pointer_delta = stack_pointer_delta;\n-\n-      /* Emit any queued insns now; otherwise they would end up in\n-\t only one of the alternates.  */\n-      emit_queue ();\n-\n-      /* Use a new sequence to hold any RTL we generate.  We do not even\n-\t know if we will use this RTL yet.  The final decision can not be\n-\t made until after RTL generation for the entire function is\n-\t complete.  */\n-      start_sequence ();\n-      /* If expanding any of the arguments creates cleanups, we can't\n-\t do a tailcall.  So, we'll need to pop the pending cleanups\n-\t list.  If, however, all goes well, and there are no cleanups\n-\t then the call to expand_start_target_temps will have no\n-\t effect.  */\n-      expand_start_target_temps ();\n-      if (optimize_tail_recursion (actparms, get_last_insn ()))\n-\t{\n-\t  if (any_pending_cleanups ())\n-\t    try_tail_call = try_tail_recursion = 0;\n-\t  else\n-\t    tail_recursion_insns = get_insns ();\n-\t}\n-      expand_end_target_temps ();\n-      end_sequence ();\n-\n-      /* Restore the original pending stack adjustment for the sibling and\n-\t normal call cases below.  */\n-      pending_stack_adjust = save_pending_stack_adjust;\n-      stack_pointer_delta = save_stack_pointer_delta;\n-    }\n \n   /* Ensure current function's preferred stack boundary is at least\n      what we need.  We don't have to increase alignment for recursive\n@@ -2634,7 +2475,7 @@ expand_call (tree exp, rtx target, int ignore)\n       int sibcall_failure = 0;\n       /* We want to emit any pending stack adjustments before the tail\n \t recursion \"call\".  That way we know any adjustment after the tail\n-\t recursion call can be ignored if we indeed use the tail recursion\n+\t recursion call can be ignored if we indeed use the tail \n \t call expansion.  */\n       int save_pending_stack_adjust = 0;\n       int save_stack_pointer_delta = 0;\n@@ -2966,6 +2807,12 @@ expand_call (tree exp, rtx target, int ignore)\n \t once we have started filling any specific hard regs.  */\n       precompute_register_parameters (num_actuals, args, &reg_parm_seen);\n \n+      if (TREE_OPERAND (exp, 2))\n+\tstatic_chain_value = expand_expr (TREE_OPERAND (exp, 2),\n+\t\t\t\t\t  NULL_RTX, VOIDmode, 0);\n+      else\n+\tstatic_chain_value = 0;\n+\n #ifdef REG_PARM_STACK_SPACE\n       /* Save the fixed argument area if it's part of the caller's frame and\n \t is clobbered by argument setup for this call.  */\n@@ -3056,8 +2903,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t    use_reg (&call_fusage, struct_value);\n \t}\n \n-      funexp = prepare_call_address (funexp, fndecl, &call_fusage,\n-\t\t\t\t     reg_parm_seen, pass == 0);\n+      funexp = prepare_call_address (funexp, static_chain_value,\n+\t\t\t\t     &call_fusage, reg_parm_seen, pass == 0);\n \n       load_register_parameters (args, num_actuals, &call_fusage, flags,\n \t\t\t\tpass == 0, &sibcall_failure);\n@@ -3088,7 +2935,7 @@ expand_call (tree exp, rtx target, int ignore)\n \tabort ();\n \n       /* Generate the actual call instruction.  */\n-      emit_call_1 (funexp, fndecl, funtype, unadjusted_args_size,\n+      emit_call_1 (funexp, exp, fndecl, funtype, unadjusted_args_size,\n \t\t   adjusted_args_size.constant, struct_value_size,\n \t\t   next_arg_reg, valreg, old_inhibit_defer_pop, call_fusage,\n \t\t   flags, & args_so_far);\n@@ -3255,19 +3102,14 @@ expand_call (tree exp, rtx target, int ignore)\n \t The Irix 6 ABI has examples of this.  */\n       else if (GET_CODE (valreg) == PARALLEL)\n \t{\n-\t  /* Second condition is added because \"target\" is freed at the\n-\t     the end of \"pass0\" for -O2 when call is made to\n-\t     expand_end_target_temps ().  Its \"in_use\" flag has been set\n-\t     to false, so allocate a new temp.  */\n-\t  if (target == 0 || (pass == 1 && target == temp_target))\n+\t  if (target == 0)\n \t    {\n \t      /* This will only be assigned once, so it can be readonly.  */\n \t      tree nt = build_qualified_type (TREE_TYPE (exp),\n \t\t\t\t\t      (TYPE_QUALS (TREE_TYPE (exp))\n \t\t\t\t\t       | TYPE_QUAL_CONST));\n \n \t      target = assign_temp (nt, 0, 1, 1);\n-\t      temp_target = target;\n \t      preserve_temp_slots (target);\n \t    }\n \n@@ -3392,8 +3234,8 @@ expand_call (tree exp, rtx target, int ignore)\n \t Check for the handler slots since we might not have a save area\n \t for non-local gotos.  */\n \n-      if ((flags & ECF_MAY_BE_ALLOCA) && nonlocal_goto_handler_slots != 0)\n-\temit_stack_save (SAVE_NONLOCAL, &nonlocal_goto_stack_level, NULL_RTX);\n+      if ((flags & ECF_MAY_BE_ALLOCA) && cfun->nonlocal_goto_save_area != 0)\n+\tupdate_nonlocal_goto_save_area ();\n \n       /* Free up storage we no longer need.  */\n       for (i = 0; i < num_actuals; ++i)\n@@ -3462,48 +3304,16 @@ expand_call (tree exp, rtx target, int ignore)\n \t zero out the sequence.  */\n       if (sibcall_failure)\n \ttail_call_insns = NULL_RTX;\n+      else\n+\tbreak;\n     }\n \n-  /* The function optimize_sibling_and_tail_recursive_calls doesn't\n-     handle CALL_PLACEHOLDERs inside other CALL_PLACEHOLDERs.  This\n-     can happen if the arguments to this function call an inline\n-     function who's expansion contains another CALL_PLACEHOLDER.\n-\n-     If there are any C_Ps in any of these sequences, replace them\n-     with their normal call.  */\n-\n-  for (insn = normal_call_insns; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CALL_INSN\n-\t&& GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-      replace_call_placeholder (insn, sibcall_use_normal);\n-\n-  for (insn = tail_call_insns; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CALL_INSN\n-\t&& GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-      replace_call_placeholder (insn, sibcall_use_normal);\n-\n-  for (insn = tail_recursion_insns; insn; insn = NEXT_INSN (insn))\n-    if (GET_CODE (insn) == CALL_INSN\n-\t&& GET_CODE (PATTERN (insn)) == CALL_PLACEHOLDER)\n-      replace_call_placeholder (insn, sibcall_use_normal);\n-\n-  /* If this was a potential tail recursion site, then emit a\n-     CALL_PLACEHOLDER with the normal and the tail recursion streams.\n-     One of them will be selected later.  */\n-  if (tail_recursion_insns || tail_call_insns)\n+  /* If tail call production suceeded, we need to remove REG_EQUIV notes on\n+     arguments too, as argument area is now clobbered by the call.  */\n+  if (tail_call_insns)\n     {\n-      /* The tail recursion label must be kept around.  We could expose\n-\t its use in the CALL_PLACEHOLDER, but that creates unwanted edges\n-\t and makes determining true tail recursion sites difficult.\n-\n-\t So we set LABEL_PRESERVE_P here, then clear it when we select\n-\t one of the call sequences after rtl generation is complete.  */\n-      if (tail_recursion_insns)\n-\tLABEL_PRESERVE_P (tail_recursion_label) = 1;\n-      emit_call_insn (gen_rtx_CALL_PLACEHOLDER (VOIDmode, normal_call_insns,\n-\t\t\t\t\t\ttail_call_insns,\n-\t\t\t\t\t\ttail_recursion_insns,\n-\t\t\t\t\t\ttail_recursion_label));\n+      emit_insn (tail_call_insns);\n+      cfun->tail_call_emit = true;\n     }\n   else\n     emit_insn (normal_call_insns);\n@@ -3524,6 +3334,47 @@ expand_call (tree exp, rtx target, int ignore)\n   return target;\n }\n \n+/* A sibling call sequence invalidates any REG_EQUIV notes made for\n+   this function's incoming arguments.\n+\n+   At the start of RTL generation we know the only REG_EQUIV notes\n+   in the rtl chain are those for incoming arguments, so we can safely\n+   flush any REG_EQUIV note.\n+\n+   This is (slight) overkill.  We could keep track of the highest\n+   argument we clobber and be more selective in removing notes, but it\n+   does not seem to be worth the effort.  */\n+void\n+fixup_tail_calls (void)\n+{\n+  rtx insn;\n+  tree arg;\n+\n+  purge_reg_equiv_notes ();\n+\n+  /* A sibling call sequence also may invalidate RTX_UNCHANGING_P\n+     flag of some incoming arguments MEM RTLs, because it can write into\n+     those slots.  We clear all those bits now.\n+\n+     This is (slight) overkill, we could keep track of which arguments\n+     we actually write into.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    {\n+      if (INSN_P (insn))\n+\tpurge_mem_unchanging_flag (PATTERN (insn));\n+    }\n+\n+  /* Similarly, invalidate RTX_UNCHANGING_P for any incoming\n+     arguments passed in registers.  */\n+  for (arg = DECL_ARGUMENTS (current_function_decl);\n+       arg;\n+       arg = TREE_CHAIN (arg))\n+    {\n+      if (REG_P (DECL_RTL (arg)))\n+\tRTX_UNCHANGING_P (DECL_RTL (arg)) = false;\n+    }\n+}\n+\n /* Traverse an argument list in VALUES and expand all complex\n    arguments into their components.  */\n tree\n@@ -4135,7 +3986,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n   else\n     argnum = 0;\n \n-  fun = prepare_call_address (fun, NULL_TREE, &call_fusage, 0, 0);\n+  fun = prepare_call_address (fun, NULL, &call_fusage, 0, 0);\n \n   /* Now load any reg parms into their regs.  */\n \n@@ -4197,7 +4048,7 @@ emit_library_call_value_1 (int retval, rtx orgfun, rtx value,\n      always signed.  We also assume that the list of arguments passed has\n      no impact, so we pretend it is unknown.  */\n \n-  emit_call_1 (fun,\n+  emit_call_1 (fun, NULL,\n \t       get_identifier (XSTR (orgfun, 0)),\n \t       build_function_type (tfom, NULL_TREE),\n \t       original_args_size.constant, args_size.constant,"}, {"sha": "4b6de6d66a8f7196d8f7110e3983a44e4142a727", "filename": "gcc/cfg.c", "status": "modified", "additions": 153, "deletions": 117, "changes": 270, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfg.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -62,20 +62,14 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"tm_p.h\"\n #include \"obstack.h\"\n #include \"alloc-pool.h\"\n+#include \"timevar.h\"\n+#include \"ggc.h\"\n \n /* The obstack on which the flow graph components are allocated.  */\n \n struct obstack flow_obstack;\n static char *flow_firstobj;\n \n-/* Basic block object pool.  */\n-\n-static alloc_pool bb_pool;\n-\n-/* Edge object pool.  */\n-\n-static alloc_pool edge_pool;\n-\n /* Number of basic blocks in the current function.  */\n \n int n_basic_blocks;\n@@ -93,56 +87,10 @@ int n_edges;\n varray_type basic_block_info;\n \n /* The special entry and exit blocks.  */\n+basic_block ENTRY_BLOCK_PTR, EXIT_BLOCK_PTR;\n \n-struct basic_block_def entry_exit_blocks[2]\n-= {{NULL,\t\t\t/* head */\n-    NULL,\t\t\t/* end */\n-    NULL,\t\t\t/* head_tree */\n-    NULL,\t\t\t/* end_tree */\n-    NULL,\t\t\t/* pred */\n-    NULL,\t\t\t/* succ */\n-    NULL,\t\t\t/* local_set */\n-    NULL,\t\t\t/* cond_local_set */\n-    NULL,\t\t\t/* global_live_at_start */\n-    NULL,\t\t\t/* global_live_at_end */\n-    NULL,\t\t\t/* aux */\n-    ENTRY_BLOCK,\t\t/* index */\n-    NULL,\t\t\t/* prev_bb */\n-    EXIT_BLOCK_PTR,\t\t/* next_bb */\n-    0,\t\t\t\t/* loop_depth */\n-    NULL,                       /* loop_father */\n-    { NULL, NULL },\t\t/* dom */\n-    0,\t\t\t\t/* count */\n-    0,\t\t\t\t/* frequency */\n-    0,\t\t\t\t/* flags */\n-    0,                          /* partition */\n-    NULL\t\t\t/* rbi */\n-  },\n-  {\n-    NULL,\t\t\t/* head */\n-    NULL,\t\t\t/* end */\n-    NULL,\t\t\t/* head_tree */\n-    NULL,\t\t\t/* end_tree */\n-    NULL,\t\t\t/* pred */\n-    NULL,\t\t\t/* succ */\n-    NULL,\t\t\t/* local_set */\n-    NULL,\t\t\t/* cond_local_set */\n-    NULL,\t\t\t/* global_live_at_start */\n-    NULL,\t\t\t/* global_live_at_end */\n-    NULL,\t\t\t/* aux */\n-    EXIT_BLOCK,\t\t\t/* index */\n-    ENTRY_BLOCK_PTR,\t\t/* prev_bb */\n-    NULL,\t\t\t/* next_bb */\n-    0,\t\t\t\t/* loop_depth */\n-    NULL,                       /* loop_father */\n-    { NULL, NULL },\t\t/* dom */\n-    0,\t\t\t\t/* count */\n-    0,\t\t\t\t/* frequency */\n-    0,\t\t\t\t/* flags */\n-    0,                          /* partition */\n-    NULL\t\t\t/* rbi */\n-  }\n-};\n+/* Memory alloc pool for bb member rbi.  */\n+alloc_pool rbi_pool;\n \n void debug_flow_info (void);\n static void free_edge (edge);\n@@ -164,25 +112,26 @@ init_flow (void)\n     }\n   else\n     {\n-      free_alloc_pool (bb_pool);\n-      free_alloc_pool (edge_pool);\n       obstack_free (&flow_obstack, flow_firstobj);\n       flow_firstobj = obstack_alloc (&flow_obstack, 0);\n     }\n-  bb_pool = create_alloc_pool (\"Basic block pool\",\n-\t\t\t       sizeof (struct basic_block_def), 100);\n-  edge_pool = create_alloc_pool (\"Edge pool\",\n-\t\t\t       sizeof (struct edge_def), 100);\n+\n+  ENTRY_BLOCK_PTR = ggc_alloc_cleared (sizeof (*ENTRY_BLOCK_PTR));\n+  ENTRY_BLOCK_PTR->index = ENTRY_BLOCK;\n+  EXIT_BLOCK_PTR = ggc_alloc_cleared (sizeof (*EXIT_BLOCK_PTR));\n+  EXIT_BLOCK_PTR->index = EXIT_BLOCK;\n+  ENTRY_BLOCK_PTR->next_bb = EXIT_BLOCK_PTR;\n+  EXIT_BLOCK_PTR->prev_bb = ENTRY_BLOCK_PTR;\n }\n \f\n /* Helper function for remove_edge and clear_edges.  Frees edge structure\n    without actually unlinking it from the pred/succ lists.  */\n \n static void\n-free_edge (edge e)\n+free_edge (edge e ATTRIBUTE_UNUSED)\n {\n   n_edges--;\n-  pool_free (edge_pool, e);\n+  /* ggc_free (e);  */\n }\n \n /* Free the memory associated with the edge structures.  */\n@@ -231,11 +180,40 @@ basic_block\n alloc_block (void)\n {\n   basic_block bb;\n-  bb = pool_alloc (bb_pool);\n-  memset (bb, 0, sizeof (*bb));\n+  bb = ggc_alloc_cleared (sizeof (*bb));\n   return bb;\n }\n \n+/* Create memory pool for rbi_pool.  */\n+\n+void\n+alloc_rbi_pool (void)\n+{\n+  rbi_pool = create_alloc_pool (\"rbi pool\", \n+\t\t\t\tsizeof (struct reorder_block_def),\n+\t\t\t\tn_basic_blocks + 2);\n+}\n+\n+/* Free rbi_pool.  */\n+\n+void\n+free_rbi_pool (void)\n+{\n+  free_alloc_pool (rbi_pool);\n+}\n+\n+/* Initialize rbi (the structure containing data used by basic block\n+   duplication and reordering) for the given basic block.  */\n+\n+void\n+initialize_bb_rbi (basic_block bb)\n+{\n+  if (bb->rbi)\n+    abort ();\n+  bb->rbi = pool_alloc (rbi_pool);\n+  memset (bb->rbi, 0, sizeof (struct reorder_block_def));\n+}\n+\n /* Link block B to chain after AFTER.  */\n void\n link_block (basic_block b, basic_block after)\n@@ -252,6 +230,8 @@ unlink_block (basic_block b)\n {\n   b->next_bb->prev_bb = b->prev_bb;\n   b->prev_bb->next_bb = b->next_bb;\n+  b->prev_bb = NULL;\n+  b->next_bb = NULL;\n }\n \n /* Sequentially order blocks and compact the arrays.  */\n@@ -272,6 +252,9 @@ compact_blocks (void)\n   if (i != n_basic_blocks)\n     abort ();\n \n+  for (; i < last_basic_block; i++)\n+    BASIC_BLOCK (i) = NULL;\n+\n   last_basic_block = n_basic_blocks;\n }\n \n@@ -283,7 +266,7 @@ expunge_block (basic_block b)\n   unlink_block (b);\n   BASIC_BLOCK (b->index) = NULL;\n   n_basic_blocks--;\n-  pool_free (bb_pool, b);\n+  /* ggc_free (b); */\n }\n \f\n /* Create an edge connecting SRC and DEST with flags FLAGS.  Return newly\n@@ -294,8 +277,7 @@ edge\n unchecked_make_edge (basic_block src, basic_block dst, int flags)\n {\n   edge e;\n-  e = pool_alloc (edge_pool);\n-  memset (e, 0, sizeof (*e));\n+  e = ggc_alloc_cleared (sizeof (*e));\n   n_edges++;\n \n   e->succ_next = src->succ;\n@@ -490,54 +472,56 @@ void\n dump_flow_info (FILE *file)\n {\n   int i;\n-  int max_regno = max_reg_num ();\n   basic_block bb;\n   static const char * const reg_class_names[] = REG_CLASS_NAMES;\n \n-  fprintf (file, \"%d registers.\\n\", max_regno);\n   if (reg_n_info)\n-    for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n-      if (REG_N_REFS (i))\n-\t{\n-\t  enum reg_class class, altclass;\n-\n-\t  fprintf (file, \"\\nRegister %d used %d times across %d insns\",\n-\t\t   i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n-\t  if (REG_BASIC_BLOCK (i) >= 0)\n-\t    fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n-\t  if (REG_N_SETS (i))\n-\t    fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n-\t\t     (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n-\t  if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n-\t    fprintf (file, \"; user var\");\n-\t  if (REG_N_DEATHS (i) != 1)\n-\t    fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n-\t  if (REG_N_CALLS_CROSSED (i) == 1)\n-\t    fprintf (file, \"; crosses 1 call\");\n-\t  else if (REG_N_CALLS_CROSSED (i))\n-\t    fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n-\t  if (regno_reg_rtx[i] != NULL\n-\t      && PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n-\t    fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n-\n-\t  class = reg_preferred_class (i);\n-\t  altclass = reg_alternate_class (i);\n-\t  if (class != GENERAL_REGS || altclass != ALL_REGS)\n-\t    {\n-\t      if (altclass == ALL_REGS || class == ALL_REGS)\n-\t\tfprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n-\t      else if (altclass == NO_REGS)\n-\t\tfprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n-\t      else\n-\t\tfprintf (file, \"; pref %s, else %s\",\n-\t\t\t reg_class_names[(int) class],\n-\t\t\t reg_class_names[(int) altclass]);\n-\t    }\n-\n-\t  if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n-\t    fprintf (file, \"; pointer\");\n-\t  fprintf (file, \".\\n\");\n-\t}\n+    {\n+      int max_regno = max_reg_num ();\n+      fprintf (file, \"%d registers.\\n\", max_regno);\n+      for (i = FIRST_PSEUDO_REGISTER; i < max_regno; i++)\n+\tif (REG_N_REFS (i))\n+\t  {\n+\t    enum reg_class class, altclass;\n+\n+\t    fprintf (file, \"\\nRegister %d used %d times across %d insns\",\n+\t\t     i, REG_N_REFS (i), REG_LIVE_LENGTH (i));\n+\t    if (REG_BASIC_BLOCK (i) >= 0)\n+\t      fprintf (file, \" in block %d\", REG_BASIC_BLOCK (i));\n+\t    if (REG_N_SETS (i))\n+\t      fprintf (file, \"; set %d time%s\", REG_N_SETS (i),\n+\t\t       (REG_N_SETS (i) == 1) ? \"\" : \"s\");\n+\t    if (regno_reg_rtx[i] != NULL && REG_USERVAR_P (regno_reg_rtx[i]))\n+\t      fprintf (file, \"; user var\");\n+\t    if (REG_N_DEATHS (i) != 1)\n+\t      fprintf (file, \"; dies in %d places\", REG_N_DEATHS (i));\n+\t    if (REG_N_CALLS_CROSSED (i) == 1)\n+\t      fprintf (file, \"; crosses 1 call\");\n+\t    else if (REG_N_CALLS_CROSSED (i))\n+\t      fprintf (file, \"; crosses %d calls\", REG_N_CALLS_CROSSED (i));\n+\t    if (regno_reg_rtx[i] != NULL\n+\t\t&& PSEUDO_REGNO_BYTES (i) != UNITS_PER_WORD)\n+\t      fprintf (file, \"; %d bytes\", PSEUDO_REGNO_BYTES (i));\n+\n+\t    class = reg_preferred_class (i);\n+\t    altclass = reg_alternate_class (i);\n+\t    if (class != GENERAL_REGS || altclass != ALL_REGS)\n+\t      {\n+\t\tif (altclass == ALL_REGS || class == ALL_REGS)\n+\t\t  fprintf (file, \"; pref %s\", reg_class_names[(int) class]);\n+\t\telse if (altclass == NO_REGS)\n+\t\t  fprintf (file, \"; %s or none\", reg_class_names[(int) class]);\n+\t\telse\n+\t\t  fprintf (file, \"; pref %s, else %s\",\n+\t\t\t   reg_class_names[(int) class],\n+\t\t\t   reg_class_names[(int) altclass]);\n+\t      }\n+\n+\t    if (regno_reg_rtx[i] != NULL && REG_POINTER (regno_reg_rtx[i]))\n+\t      fprintf (file, \"; pointer\");\n+\t    fprintf (file, \".\\n\");\n+\t  }\n+    }\n \n   fprintf (file, \"\\n%d basic blocks, %d edges.\\n\", n_basic_blocks, n_edges);\n   FOR_EACH_BB (bb)\n@@ -546,8 +530,7 @@ dump_flow_info (FILE *file)\n       int sum;\n       gcov_type lsum;\n \n-      fprintf (file, \"\\nBasic block %d: first insn %d, last %d, \",\n-\t       bb->index, INSN_UID (BB_HEAD (bb)), INSN_UID (BB_END (bb)));\n+      fprintf (file, \"\\nBasic block %d \", bb->index);\n       fprintf (file, \"prev %d, next %d, \",\n \t       bb->prev_bb->index, bb->next_bb->index);\n       fprintf (file, \"loop_depth %d, count \", bb->loop_depth);\n@@ -641,7 +624,8 @@ dump_edge_info (FILE *file, edge e, int do_succ)\n     {\n       static const char * const bitnames[] = {\n \t\"fallthru\", \"ab\", \"abcall\", \"eh\", \"fake\", \"dfs_back\",\n-\t\"can_fallthru\", \"irreducible\", \"sibcall\", \"loop_exit\"\n+\t\"can_fallthru\", \"irreducible\", \"sibcall\", \"loop_exit\",\n+\t\"true\", \"false\", \"exec\"\n       };\n       int comma = 0;\n       int i, flags = e->flags;\n@@ -825,3 +809,55 @@ debug_bb_n (int n)\n   dump_bb (bb, stderr, 0);\n   return bb;\n }\n+\n+/* Dumps cfg related information about basic block BB to FILE.  */\n+\n+static void\n+dump_cfg_bb_info (FILE *file, basic_block bb)\n+{\n+  unsigned i;\n+  bool first = true;\n+  static const char * const bb_bitnames[] =\n+    {\n+      \"dirty\", \"new\", \"reachable\", \"visited\", \"irreducible_loop\", \"superblock\"\n+    };\n+  const unsigned n_bitnames = sizeof (bb_bitnames) / sizeof (char *);\n+  edge e;\n+\n+  fprintf (file, \"Basic block %d\", bb->index);\n+  for (i = 0; i < n_bitnames; i++)\n+    if (bb->flags & (1 << i))\n+      {\n+\tif (first)\n+\t  fprintf (file, \" (\");\n+\telse\n+\t  fprintf (file, \", \");\n+\tfirst = false;\n+\tfprintf (file, bb_bitnames[i]);\n+      }\n+  if (!first)\n+    fprintf (file, \")\");\n+  fprintf (file, \"\\n\");\n+\n+  fprintf (file, \"Predecessors: \");\n+  for (e = bb->pred; e; e = e->pred_next)\n+    dump_edge_info (file, e, 0);\n+\n+  fprintf (file, \"\\nSuccessors: \");\n+  for (e = bb->succ; e; e = e->succ_next)\n+    dump_edge_info (file, e, 1);\n+  fprintf (file, \"\\n\\n\");\n+}\n+\n+/* Dumps a brief description of cfg to FILE.  */\n+\n+void\n+brief_dump_cfg (FILE *file)\n+{\n+  basic_block bb;\n+\n+  FOR_EACH_BB (bb)\n+    {\n+      dump_cfg_bb_info (file, bb);\n+    }\n+}"}, {"sha": "1a7d280513f7bc1f693ac128dbfa32302d3bf972", "filename": "gcc/cfganal.c", "status": "modified", "additions": 15, "deletions": 164, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -52,7 +52,6 @@ static void flow_dfs_compute_reverse_add_bb (depth_first_search_ds,\n static basic_block flow_dfs_compute_reverse_execute (depth_first_search_ds);\n static void flow_dfs_compute_reverse_finish (depth_first_search_ds);\n static void remove_fake_successors (basic_block);\n-static bool need_fake_edge_p (rtx);\n static bool flow_active_insn_p (rtx);\n \f\n /* Like active_insn_p, except keep the return value clobber around\n@@ -242,169 +241,6 @@ set_edge_can_fallthru_flag (void)\n     }\n }\n \n-/* Return true if we need to add fake edge to exit.\n-   Helper function for the flow_call_edges_add.  */\n-\n-static bool\n-need_fake_edge_p (rtx insn)\n-{\n-  if (!INSN_P (insn))\n-    return false;\n-\n-  if ((GET_CODE (insn) == CALL_INSN\n-       && !SIBLING_CALL_P (insn)\n-       && !find_reg_note (insn, REG_NORETURN, NULL)\n-       && !find_reg_note (insn, REG_ALWAYS_RETURN, NULL)\n-       && !CONST_OR_PURE_CALL_P (insn)))\n-    return true;\n-\n-  return ((GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n-\t   && MEM_VOLATILE_P (PATTERN (insn)))\n-\t  || (GET_CODE (PATTERN (insn)) == PARALLEL\n-\t      && asm_noperands (insn) != -1\n-\t      && MEM_VOLATILE_P (XVECEXP (PATTERN (insn), 0, 0)))\n-\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n-}\n-\n-/* Add fake edges to the function exit for any non constant and non noreturn\n-   calls, volatile inline assembly in the bitmap of blocks specified by\n-   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n-   that were split.\n-\n-   The goal is to expose cases in which entering a basic block does not imply\n-   that all subsequent instructions must be executed.  */\n-\n-int\n-flow_call_edges_add (sbitmap blocks)\n-{\n-  int i;\n-  int blocks_split = 0;\n-  int last_bb = last_basic_block;\n-  bool check_last_block = false;\n-\n-  if (n_basic_blocks == 0)\n-    return 0;\n-\n-  if (! blocks)\n-    check_last_block = true;\n-  else\n-    check_last_block = TEST_BIT (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n-\n-  /* In the last basic block, before epilogue generation, there will be\n-     a fallthru edge to EXIT.  Special care is required if the last insn\n-     of the last basic block is a call because make_edge folds duplicate\n-     edges, which would result in the fallthru edge also being marked\n-     fake, which would result in the fallthru edge being removed by\n-     remove_fake_edges, which would result in an invalid CFG.\n-\n-     Moreover, we can't elide the outgoing fake edge, since the block\n-     profiler needs to take this into account in order to solve the minimal\n-     spanning tree in the case that the call doesn't return.\n-\n-     Handle this by adding a dummy instruction in a new last basic block.  */\n-  if (check_last_block)\n-    {\n-      basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n-      rtx insn = BB_END (bb);\n-\n-      /* Back up past insns that must be kept in the same block as a call.  */\n-      while (insn != BB_HEAD (bb)\n-\t     && keep_with_call_p (insn))\n-\tinsn = PREV_INSN (insn);\n-\n-      if (need_fake_edge_p (insn))\n-\t{\n-\t  edge e;\n-\n-\t  for (e = bb->succ; e; e = e->succ_next)\n-\t    if (e->dest == EXIT_BLOCK_PTR)\n-\t      {\n-\t\tinsert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n-\t\tcommit_edge_insertions ();\n-\t\tbreak;\n-\t      }\n-\t}\n-    }\n-\n-  /* Now add fake edges to the function exit for any non constant\n-     calls since there is no way that we can determine if they will\n-     return or not...  */\n-\n-  for (i = 0; i < last_bb; i++)\n-    {\n-      basic_block bb = BASIC_BLOCK (i);\n-      rtx libcall_end = NULL_RTX;\n-      rtx insn;\n-      rtx prev_insn;\n-\n-      if (!bb)\n-\tcontinue;\n-\n-      if (blocks && !TEST_BIT (blocks, i))\n-\tcontinue;\n-\n-      for (insn = BB_END (bb); ; insn = prev_insn)\n-\t{\n-\t  prev_insn = PREV_INSN (insn);\n-\t  if (need_fake_edge_p (insn))\n-\t    {\n-\t      edge e;\n-\t      rtx split_at_insn = insn;\n-\n-\t      /* Don't split libcalls.  */\n-\t      if (libcall_end)\n-\t\tsplit_at_insn = libcall_end;\n-\n-\t      /* Don't split the block between a call and an insn that should\n-\t         remain in the same block as the call.  */\n-\t      else if (GET_CODE (insn) == CALL_INSN)\n-\t\twhile (split_at_insn != BB_END (bb)\n-\t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n-\t\t  split_at_insn = NEXT_INSN (split_at_insn);\n-\n-\t      /* The handling above of the final block before the epilogue\n-\t         should be enough to verify that there is no edge to the exit\n-\t\t block in CFG already.  Calling make_edge in such case would\n-\t\t cause us to mark that edge as fake and remove it later.  */\n-\n-#ifdef ENABLE_CHECKING\n-\t      if (split_at_insn == BB_END (bb))\n-\t\tfor (e = bb->succ; e; e = e->succ_next)\n-\t\t  if (e->dest == EXIT_BLOCK_PTR)\n-\t\t    abort ();\n-#endif\n-\n-\t      /* Note that the following may create a new basic block\n-\t\t and renumber the existing basic blocks.  */\n-\t      if (split_at_insn != BB_END (bb))\n-\t\t{\n-\t\t  e = split_block (bb, split_at_insn);\n-\t\t  if (e)\n-\t\t    blocks_split++;\n-\t\t}\n-\n-\t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n-\t    }\n-\n-\t  /* Watch out for REG_LIBCALL/REG_RETVAL notes so that we know\n-\t     whether we are currently in a libcall or not.  Remember that\n-\t     we are scanning backwards!  */\n-\t  if (find_reg_note (insn, REG_RETVAL, NULL_RTX))\n-\t    libcall_end = insn;\n-\t  if (find_reg_note (insn, REG_LIBCALL, NULL_RTX))\n-\t    libcall_end = NULL_RTX;\n-\n-\t  if (insn == BB_HEAD (bb))\n-\t    break;\n-\t}\n-    }\n-\n-  if (blocks_split)\n-    verify_flow_info ();\n-\n-  return blocks_split;\n-}\n-\n /* Find unreachable blocks.  An unreachable block will have 0 in\n    the reachable bit in block->flags.  A nonzero value indicates the\n    block is reachable.  */\n@@ -603,6 +439,21 @@ verify_edge_list (FILE *f, struct edge_list *elist)\n       }\n }\n \n+/* Given PRED and SUCC blocks, return the edge which connects the blocks.\n+   If no such edge exists, return NULL.  */\n+\n+edge\n+find_edge (basic_block pred, basic_block succ)\n+{\n+  edge e;\n+\n+  for (e = pred->succ; e; e = e->succ_next)\n+    if (e->dest == succ)\n+      return e;\n+\n+  return NULL;\n+}\n+\n /* This routine will determine what, if any, edge there is between\n    a specified predecessor and successor.  */\n "}, {"sha": "3e9a36cca4d44310a8ad070ed2dea97ab591c509", "filename": "gcc/cfgbuild.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgbuild.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgbuild.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgbuild.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -240,7 +240,7 @@ make_label_edge (sbitmap *edge_cache, basic_block src, rtx label, int flags)\n /* Create the edges generated by INSN in REGION.  */\n \n void\n-make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n+rtl_make_eh_edge (sbitmap *edge_cache, basic_block src, rtx insn)\n {\n   int is_call = GET_CODE (insn) == CALL_INSN ? EDGE_ABNORMAL_CALL : 0;\n   rtx handlers, i;\n@@ -325,7 +325,7 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n \n \t  /* Recognize exception handling placeholders.  */\n \t  if (GET_CODE (PATTERN (insn)) == RESX)\n-\t    make_eh_edge (edge_cache, bb, insn);\n+\t    rtl_make_eh_edge (edge_cache, bb, insn);\n \n \t  /* Recognize a non-local goto as a branch outside the\n \t     current function.  */\n@@ -405,7 +405,7 @@ make_edges (rtx label_value_list, basic_block min, basic_block max, int update_p\n       else if (code == CALL_INSN || flag_non_call_exceptions)\n \t{\n \t  /* Add any appropriate EH edges.  */\n-\t  make_eh_edge (edge_cache, bb, insn);\n+\t  rtl_make_eh_edge (edge_cache, bb, insn);\n \n \t  if (code == CALL_INSN && nonlocal_goto_handler_labels)\n \t    {\n@@ -610,7 +610,7 @@ find_basic_blocks (rtx f, int nregs ATTRIBUTE_UNUSED,\n       FOR_EACH_BB (bb)\n \tbb->aux = NULL;\n \n-      VARRAY_FREE (basic_block_info);\n+      basic_block_info = NULL;\n     }\n \n   n_basic_blocks = count_basic_blocks (f);"}, {"sha": "10d9e96c13506e6f36c6685793bf203ba96d55d5", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1368,7 +1368,7 @@ outgoing_edges_match (int mode, basic_block bb1, basic_block bb2)\n \t  /* The labels should never be the same rtx.  If they really are same\n \t     the jump tables are same too. So disable crossjumping of blocks BB1\n \t     and BB2 because when deleting the common insns in the end of BB1\n-\t     by delete_block () the jump table would be deleted too.  */\n+\t     by delete_basic_block () the jump table would be deleted too.  */\n \t  /* If LABEL2 is referenced in BB1->END do not do anything\n \t     because we would loose information when replacing\n \t     LABEL1 by LABEL2 and then LABEL2 by LABEL1 in BB1->END.  */\n@@ -1501,6 +1501,8 @@ try_crossjump_to_edge (int mode, edge e1, edge e2)\n   rtx newpos1, newpos2;\n   edge s;\n \n+  newpos1 = newpos2 = NULL_RTX;\n+\n   /* If we have partitioned hot/cold basic blocks, it is a bad idea\n      to try this optimization.  */\n \n@@ -2033,6 +2035,32 @@ delete_unreachable_blocks (void)\n     tidy_fallthru_edges ();\n   return changed;\n }\n+\n+/* Merges sequential blocks if possible.  */\n+\n+bool\n+merge_seq_blocks (void)\n+{\n+  basic_block bb;\n+  bool changed = false;\n+\n+  for (bb = ENTRY_BLOCK_PTR->next_bb; bb != EXIT_BLOCK_PTR; )\n+    {\n+      if (bb->succ\n+\t  && !bb->succ->succ_next\n+\t  && can_merge_blocks_p (bb, bb->succ->dest))\n+\t{\n+\t  /* Merge the blocks and retry.  */\n+\t  merge_blocks (bb, bb->succ->dest);\n+\t  changed = true;\n+\t  continue;\n+\t}\n+\n+      bb = bb->next_bb;\n+    }\n+\n+  return changed;\n+}\n \f\n /* Tidy the CFG by deleting unreachable code and whatnot.  */\n "}, {"sha": "29f5dfd1695864f23dc04a263df799640ca77a54", "filename": "gcc/cfghooks.c", "status": "modified", "additions": 175, "deletions": 8, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -26,6 +26,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"tree.h\"\n #include \"rtl.h\"\n #include \"basic-block.h\"\n+#include \"tree-flow.h\"\n #include \"timevar.h\"\n #include \"toplev.h\"\n \n@@ -46,6 +47,22 @@ cfg_layout_rtl_register_cfg_hooks (void)\n   cfg_hooks = &cfg_layout_rtl_cfg_hooks;\n }\n \n+/* Initialization of functions specific to the tree IR.  */\n+\n+void\n+tree_register_cfg_hooks (void)\n+{\n+  cfg_hooks = &tree_cfg_hooks;\n+}\n+\n+/* Returns current ir type (rtl = 0, trees = 1).  */\n+\n+int\n+ir_type (void)\n+{\n+  return cfg_hooks == &tree_cfg_hooks ? 1 : 0;\n+}\n+\n /* Verify the CFG consistency.\n \n    Currently it does following: checks edge and basic block list correctness\n@@ -246,10 +263,10 @@ dump_bb (basic_block bb, FILE *outf, int indent)\n    be equivalent to E in the case of duplicate edges being removed) or NULL\n    if edge is not easily redirectable for whatever reason.  */\n \n-bool\n+edge\n redirect_edge_and_branch (edge e, basic_block dest)\n {\n-  bool ret;\n+  edge ret;\n \n   if (!cfg_hooks->redirect_edge_and_branch)\n     internal_error (\"%s does not support redirect_edge_and_branch.\",\n@@ -286,7 +303,6 @@ edge\n split_block (basic_block bb, void *i)\n {\n   basic_block new_bb;\n-  edge e;\n \n   if (!cfg_hooks->split_block)\n     internal_error (\"%s does not support split_block.\", cfg_hooks->name);\n@@ -305,11 +321,7 @@ split_block (basic_block bb, void *i)\n       set_immediate_dominator (CDI_DOMINATORS, new_bb, bb);\n     }\n \n-  e = make_edge (bb, new_bb, EDGE_FALLTHRU);\n-  e->probability = REG_BR_PROB_BASE;\n-  e->count = bb->count;\n-\n-  return e;\n+  return make_edge (bb, new_bb, EDGE_FALLTHRU);\n }\n \n /* Splits block BB just after labels.  The newly created edge is returned.  */\n@@ -464,6 +476,24 @@ can_merge_blocks_p (basic_block bb1, basic_block bb2)\n   return ret;\n }\n \n+void\n+predict_edge (edge e, enum br_predictor predictor, int probability)\n+{\n+  if (!cfg_hooks->predict_edge)\n+    internal_error (\"%s does not support predict_edge.\", cfg_hooks->name);\n+\n+  cfg_hooks->predict_edge (e, predictor, probability);\n+}\n+\n+bool\n+predicted_by_p (basic_block bb, enum br_predictor predictor)\n+{\n+  if (!cfg_hooks->predict_edge)\n+    internal_error (\"%s does not support predicted_by_p.\", cfg_hooks->name);\n+\n+  return cfg_hooks->predicted_by_p (bb, predictor);\n+}\n+\n /* Merges basic block B into basic block A.  */\n \n void\n@@ -605,3 +635,140 @@ tidy_fallthru_edges (void)\n \ttidy_fallthru_edge (s);\n     }\n }\n+\n+/* Returns true if we can duplicate basic block BB.  */\n+\n+bool\n+can_duplicate_block_p (basic_block bb)\n+{\n+  edge e;\n+\n+  if (!cfg_hooks->can_duplicate_block_p)\n+    internal_error (\"%s does not support can_duplicate_block_p.\",\n+\t\t    cfg_hooks->name);\n+\n+  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n+    return false;\n+\n+  /* Duplicating fallthru block to exit would require adding a jump\n+     and splitting the real last BB.  */\n+  for (e = bb->succ; e; e = e->succ_next)\n+    if (e->dest == EXIT_BLOCK_PTR && e->flags & EDGE_FALLTHRU)\n+       return false;\n+\n+  return cfg_hooks->can_duplicate_block_p (bb);\n+}\n+\n+/* Duplicates basic block BB and redirects edge E to it.  Returns the\n+   new basic block.  */\n+\n+basic_block\n+duplicate_block (basic_block bb, edge e)\n+{\n+  edge s, n;\n+  basic_block new_bb;\n+  gcov_type new_count = e ? e->count : 0;\n+\n+  if (!cfg_hooks->duplicate_block)\n+    internal_error (\"%s does not support duplicate_block.\",\n+\t\t    cfg_hooks->name);\n+\n+  if (bb->count < new_count)\n+    new_count = bb->count;\n+  if (!bb->pred)\n+    abort ();\n+#ifdef ENABLE_CHECKING\n+  if (!can_duplicate_block_p (bb))\n+    abort ();\n+#endif\n+\n+  new_bb = cfg_hooks->duplicate_block (bb);\n+\n+  new_bb->loop_depth = bb->loop_depth;\n+  new_bb->flags = bb->flags;\n+  for (s = bb->succ; s; s = s->succ_next)\n+    {\n+      /* Since we are creating edges from a new block to successors\n+\t of another block (which therefore are known to be disjoint), there\n+\t is no need to actually check for duplicated edges.  */\n+      n = unchecked_make_edge (new_bb, s->dest, s->flags);\n+      n->probability = s->probability;\n+      if (e && bb->count)\n+\t{\n+\t  /* Take care for overflows!  */\n+\t  n->count = s->count * (new_count * 10000 / bb->count) / 10000;\n+\t  s->count -= n->count;\n+\t}\n+      else\n+\tn->count = s->count;\n+      n->aux = s->aux;\n+    }\n+\n+  if (e)\n+    {\n+      new_bb->count = new_count;\n+      bb->count -= new_count;\n+\n+      new_bb->frequency = EDGE_FREQUENCY (e);\n+      bb->frequency -= EDGE_FREQUENCY (e);\n+\n+      redirect_edge_and_branch_force (e, new_bb);\n+\n+      if (bb->count < 0)\n+\tbb->count = 0;\n+      if (bb->frequency < 0)\n+\tbb->frequency = 0;\n+    }\n+  else\n+    {\n+      new_bb->count = bb->count;\n+      new_bb->frequency = bb->frequency;\n+    }\n+\n+  new_bb->rbi->original = bb;\n+  bb->rbi->copy = new_bb;\n+\n+  return new_bb;\n+}\n+\n+/* Return 1 if BB ends with a call, possibly followed by some\n+   instructions that must stay with the call, 0 otherwise.  */\n+\n+bool \n+block_ends_with_call_p (basic_block bb)\n+{\n+  if (!cfg_hooks->block_ends_with_call_p)\n+    internal_error (\"%s does not support block_ends_with_call_p\", cfg_hooks->name);\n+\n+  return (cfg_hooks->block_ends_with_call_p) (bb);\n+}\n+\n+/* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n+\n+bool \n+block_ends_with_condjump_p (basic_block bb)\n+{\n+  if (!cfg_hooks->block_ends_with_condjump_p)\n+    internal_error (\"%s does not support block_ends_with_condjump_p\",\n+\t\t    cfg_hooks->name);\n+\n+  return (cfg_hooks->block_ends_with_condjump_p) (bb);\n+}\n+\n+/* Add fake edges to the function exit for any non constant and non noreturn\n+   calls, volatile inline assembly in the bitmap of blocks specified by\n+   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n+   that were split.\n+\n+   The goal is to expose cases in which entering a basic block does not imply\n+   that all subsequent instructions must be executed.  */\n+\n+int\n+flow_call_edges_add (sbitmap blocks)\n+{\n+  if (!cfg_hooks->flow_call_edges_add)\n+    internal_error (\"%s does not support flow_call_edges_add\", \n+\t\t    cfg_hooks->name);\n+\n+  return (cfg_hooks->flow_call_edges_add) (blocks);\n+}"}, {"sha": "7cbe700df3678b84d291511a0bc15b7d5feed224", "filename": "gcc/cfghooks.h", "status": "modified", "additions": 45, "deletions": 4, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfghooks.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -37,9 +37,10 @@ struct cfg_hooks\n   basic_block (*create_basic_block) (void *head, void *end, basic_block after);\n \n   /* Redirect edge E to the given basic block B and update underlying program\n-     representation.  Returns false when edge is not easily redirectable for\n-     whatever reason.  */\n-  bool (*redirect_edge_and_branch) (edge e, basic_block b);\n+     representation.  Returns edge representing redirected branch (that may not\n+     be equivalent to E in the case of duplicate edges being removed) or NULL\n+     if edge is not easily redirectable for whatever reason.  */\n+  edge (*redirect_edge_and_branch) (edge e, basic_block b);\n \n   /* Same as the above but allows redirecting of fallthru edges.  In that case\n      newly created forwarder basic block is returned.  It aborts when called\n@@ -62,18 +63,48 @@ struct cfg_hooks\n   /* Merge blocks A and B.  */\n   void (*merge_blocks) (basic_block a, basic_block b);\n \n+  /* Predict edge E using PREDICTOR to given PROBABILITY.  */\n+  void (*predict_edge) (edge e, enum br_predictor predictor, int probability);\n+\n+  /* Return true if the one of outgoing edges is already predicted by\n+     PREDICTOR.  */\n+  bool (*predicted_by_p) (basic_block bb, enum br_predictor predictor);\n+\n+  /* Return true when block A can be duplicated.  */\n+  bool (*can_duplicate_block_p) (basic_block a);\n+\n+  /* Duplicate block A.  */\n+  basic_block (*duplicate_block) (basic_block a);\n+\n   /* Higher level functions representable by primitive operations above if\n      we didn't have some oddities in RTL and Tree representations.  */\n   basic_block (*split_edge) (edge);\n   void (*make_forwarder_block) (edge);\n \n   /* Tries to make the edge fallthru.  */\n   void (*tidy_fallthru_edge) (edge);\n+\n+  /* Say whether a block ends with a call, possibly followed by some\n+     other code that must stay with the call.  */\n+  bool (*block_ends_with_call_p) (basic_block);\n+\n+  /* Say whether a block ends with a conditional branch.  Switches\n+     and unconditional branches do not qualify.  */\n+  bool (*block_ends_with_condjump_p) (basic_block);\n+\n+  /* Add fake edges to the function exit for any non constant and non noreturn\n+     calls, volatile inline assembly in the bitmap of blocks specified by\n+     BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n+     that were split.\n+\n+     The goal is to expose cases in which entering a basic block does not imply\n+     that all subsequent instructions must be executed.  */\n+  int (*flow_call_edges_add) (sbitmap);\n };\n \n extern void verify_flow_info (void);\n extern void dump_bb (basic_block, FILE *, int);\n-extern bool redirect_edge_and_branch (edge, basic_block);\n+extern edge redirect_edge_and_branch (edge, basic_block);\n extern basic_block redirect_edge_and_branch_force (edge, basic_block);\n extern edge split_block (basic_block, void *);\n extern edge split_block_after_labels (basic_block);\n@@ -88,13 +119,23 @@ extern edge make_forwarder_block (basic_block, bool (*)(edge),\n \t\t\t\t  void (*) (basic_block));\n extern void tidy_fallthru_edge (edge);\n extern void tidy_fallthru_edges (void);\n+extern void predict_edge (edge e, enum br_predictor predictor, int probability);\n+extern bool predicted_by_p (basic_block bb, enum br_predictor predictor);\n+extern bool can_duplicate_block_p (basic_block);\n+extern basic_block duplicate_block (basic_block, edge);\n+extern bool block_ends_with_call_p (basic_block bb);\n+extern bool block_ends_with_condjump_p (basic_block bb);\n+extern int flow_call_edges_add (sbitmap);\n \n /* Hooks containers.  */\n+extern struct cfg_hooks tree_cfg_hooks;\n extern struct cfg_hooks rtl_cfg_hooks;\n extern struct cfg_hooks cfg_layout_rtl_cfg_hooks;\n \n /* Declarations.  */\n+extern int ir_type (void);\n extern void rtl_register_cfg_hooks (void);\n extern void cfg_layout_rtl_register_cfg_hooks (void);\n+extern void tree_register_cfg_hooks (void);\n \n #endif  /* GCC_CFGHOOKS_H */"}, {"sha": "8a57c68c2b21db76e441df500773b4eff2b4cae0", "filename": "gcc/cfglayout.c", "status": "modified", "additions": 32, "deletions": 90, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfglayout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfglayout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -41,8 +41,6 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    in this obstack, and all are freed at the end of the function.  */\n extern struct obstack flow_obstack;\n \n-alloc_pool cfg_layout_pool;\n-\n /* Holds the interesting trailing notes for the function.  */\n rtx cfg_layout_function_footer, cfg_layout_function_header;\n \n@@ -311,10 +309,14 @@ insn_locators_initialize (void)\n \t  switch (NOTE_LINE_NUMBER (insn))\n \t    {\n \t    case NOTE_INSN_BLOCK_BEG:\n+\t      if (cfun->dont_emit_block_notes)\n+\t\tabort ();\n \t      block = NOTE_BLOCK (insn);\n \t      delete_insn (insn);\n \t      break;\n \t    case NOTE_INSN_BLOCK_END:\n+\t      if (cfun->dont_emit_block_notes)\n+\t\tabort ();\n \t      block = BLOCK_SUPERCONTEXT (block);\n \t      if (block && TREE_CODE (block) == FUNCTION_DECL)\n \t\tblock = 0;\n@@ -329,11 +331,17 @@ insn_locators_initialize (void)\n \t      break;\n \t    }\n \t}\n+\n+      if (cfun->dont_emit_block_notes)\n+\tcheck_block_change (insn, &block);\n     }\n \n   /* Tag the blocks with a depth number so that change_scope can find\n      the common parent easily.  */\n   set_block_levels (DECL_INITIAL (cfun->decl), 0);\n+\n+  if (cfun->dont_emit_block_notes)\n+    free_block_changes ();\n }\n \n /* For each lexical block, set BLOCK_NUMBER to the depth at which it is\n@@ -771,7 +779,7 @@ fixup_reorder_chain (void)\n       nb = force_nonfallthru (e_fall);\n       if (nb)\n \t{\n-\t  cfg_layout_initialize_rbi (nb);\n+\t  initialize_bb_rbi (nb);\n \t  nb->rbi->visited = 1;\n \t  nb->rbi->next = bb->rbi->next;\n \t  bb->rbi->next = nb;\n@@ -933,20 +941,15 @@ fixup_fallthru_exit_predecessor (void)\n \f\n /* Return true in case it is possible to duplicate the basic block BB.  */\n \n+/* We do not want to declare the function in a header file, since it should\n+   only be used through the cfghooks interface, and we do not want to move\n+   it to cfgrtl.c since it would require also moving quite a lot of related\n+   code.  */\n+extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n+\n bool\n cfg_layout_can_duplicate_bb_p (basic_block bb)\n {\n-  edge s;\n-\n-  if (bb == EXIT_BLOCK_PTR || bb == ENTRY_BLOCK_PTR)\n-    return false;\n-\n-  /* Duplicating fallthru block to exit would require adding a jump\n-     and splitting the real last BB.  */\n-  for (s = bb->succ; s; s = s->succ_next)\n-    if (s->dest == EXIT_BLOCK_PTR && s->flags & EDGE_FALLTHRU)\n-       return false;\n-\n   /* Do not attempt to duplicate tablejumps, as we need to unshare\n      the dispatch table.  This is difficult to do, as the instructions\n      computing jump destination may be hoisted outside the basic block.  */\n@@ -1062,26 +1065,19 @@ duplicate_insn_chain (rtx from, rtx to)\n   delete_insn (last);\n   return insn;\n }\n-/* Create a duplicate of the basic block BB and redirect edge E into it.\n-   If E is not specified, BB is just copied, but updating the frequencies\n-   etc. is left to the caller.  */\n+/* Create a duplicate of the basic block BB.  */\n+\n+/* We do not want to declare the function in a header file, since it should\n+   only be used through the cfghooks interface, and we do not want to move\n+   it to cfgrtl.c since it would require also moving quite a lot of related\n+   code.  */\n+extern basic_block cfg_layout_duplicate_bb (basic_block);\n \n basic_block\n-cfg_layout_duplicate_bb (basic_block bb, edge e)\n+cfg_layout_duplicate_bb (basic_block bb)\n {\n   rtx insn;\n-  edge s, n;\n   basic_block new_bb;\n-  gcov_type new_count = e ? e->count : 0;\n-\n-  if (bb->count < new_count)\n-    new_count = bb->count;\n-  if (!bb->pred)\n-    abort ();\n-#ifdef ENABLE_CHECKING\n-  if (!cfg_layout_can_duplicate_bb_p (bb))\n-    abort ();\n-#endif\n \n   insn = duplicate_insn_chain (BB_HEAD (bb), BB_END (bb));\n   new_bb = create_basic_block (insn,\n@@ -1116,62 +1112,9 @@ cfg_layout_duplicate_bb (basic_block bb, edge e)\n       COPY_REG_SET (new_bb->global_live_at_end, bb->global_live_at_end);\n     }\n \n-  new_bb->loop_depth = bb->loop_depth;\n-  new_bb->flags = bb->flags;\n-  for (s = bb->succ; s; s = s->succ_next)\n-    {\n-      /* Since we are creating edges from a new block to successors\n-\t of another block (which therefore are known to be disjoint), there\n-\t is no need to actually check for duplicated edges.  */\n-      n = unchecked_make_edge (new_bb, s->dest, s->flags);\n-      n->probability = s->probability;\n-      if (e && bb->count)\n-\t{\n-\t  /* Take care for overflows!  */\n-\t  n->count = s->count * (new_count * 10000 / bb->count) / 10000;\n-\t  s->count -= n->count;\n-\t}\n-      else\n-\tn->count = s->count;\n-      n->aux = s->aux;\n-    }\n-\n-  if (e)\n-    {\n-      new_bb->count = new_count;\n-      bb->count -= new_count;\n-\n-      new_bb->frequency = EDGE_FREQUENCY (e);\n-      bb->frequency -= EDGE_FREQUENCY (e);\n-\n-      redirect_edge_and_branch_force (e, new_bb);\n-\n-      if (bb->count < 0)\n-\tbb->count = 0;\n-      if (bb->frequency < 0)\n-\tbb->frequency = 0;\n-    }\n-  else\n-    {\n-      new_bb->count = bb->count;\n-      new_bb->frequency = bb->frequency;\n-    }\n-\n-  new_bb->rbi->original = bb;\n-  bb->rbi->copy = new_bb;\n-\n   return new_bb;\n }\n \f\n-void\n-cfg_layout_initialize_rbi (basic_block bb)\n-{\n-  if (bb->rbi)\n-    abort ();\n-  bb->rbi = pool_alloc (cfg_layout_pool);\n-  memset (bb->rbi, 0, sizeof (struct reorder_block_def));\n-}\n-\f\n /* Main entry point to this module - initialize the data structures for\n    CFG layout changes.  It keeps LOOPS up-to-date if not null.  */\n \n@@ -1180,13 +1123,12 @@ cfg_layout_initialize (void)\n {\n   basic_block bb;\n \n-  /* Our algorithm depends on fact that there are now dead jumptables\n+  /* Our algorithm depends on fact that there are no dead jumptables\n      around the code.  */\n-  cfg_layout_pool =\n-    create_alloc_pool (\"cfg layout pool\", sizeof (struct reorder_block_def),\n-\t\t       n_basic_blocks + 2);\n+  alloc_rbi_pool ();\n+\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n-    cfg_layout_initialize_rbi (bb);\n+    initialize_bb_rbi (bb);\n \n   cfg_layout_rtl_register_cfg_hooks ();\n \n@@ -1242,7 +1184,7 @@ cfg_layout_finalize (void)\n   verify_insn_chain ();\n #endif\n \n-  free_alloc_pool (cfg_layout_pool);\n+  free_rbi_pool ();\n   FOR_BB_BETWEEN (bb, ENTRY_BLOCK_PTR, NULL, next_bb)\n     bb->rbi = NULL;\n \n@@ -1275,7 +1217,7 @@ can_copy_bbs_p (basic_block *bbs, unsigned n)\n \t    goto end;\n \t  }\n \n-      if (!cfg_layout_can_duplicate_bb_p (bbs[i]))\n+      if (!can_duplicate_block_p (bbs[i]))\n \t{\n \t  ret = false;\n \t  break;\n@@ -1318,7 +1260,7 @@ copy_bbs (basic_block *bbs, unsigned n, basic_block *new_bbs,\n     {\n       /* Duplicate.  */\n       bb = bbs[i];\n-      new_bb = new_bbs[i] = cfg_layout_duplicate_bb (bb, NULL);\n+      new_bb = new_bbs[i] = duplicate_block (bb, NULL);\n       bb->rbi->duplicated = 1;\n       /* Add to loop.  */\n       add_bb_to_loop (new_bb, bb->loop_father->copy);"}, {"sha": "b074f642633e420f9ca53b35854a3e2b1335b2c9", "filename": "gcc/cfglayout.h", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfglayout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfglayout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfglayout.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -18,31 +18,13 @@\n    Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    02111-1307, USA.  */\n \n-/* Structure to hold information about the blocks during reordering.  */\n-typedef struct reorder_block_def\n-{\n-  rtx header;\n-  rtx footer;\n-  basic_block next;\n-  basic_block original;\n-  /* Used by loop copying.  */\n-  basic_block copy;\n-  int duplicated;\n-\n-  /* These fields are used by bb-reorder pass.  */\n-  int visited;\n-} *reorder_block_def;\n-\n extern rtx cfg_layout_function_footer;\n \n extern void cfg_layout_initialize (void);\n extern void cfg_layout_finalize (void);\n-extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n-extern basic_block cfg_layout_duplicate_bb (basic_block, edge);\n extern void insn_locators_initialize (void);\n extern void reemit_insn_block_notes (void);\n extern bool can_copy_bbs_p (basic_block *, unsigned);\n extern void copy_bbs (basic_block *, unsigned, basic_block *,\n \t\t      edge *, unsigned, edge *, struct loop *);\n-extern void cfg_layout_initialize_rbi (basic_block);\n extern bool scan_ahead_for_unlikely_executed_note (rtx);"}, {"sha": "3d13386ba4e1cd2038ef38b4598424ea605ebf93", "filename": "gcc/cfgloop.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -28,6 +28,8 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"toplev.h\"\n #include \"cfgloop.h\"\n #include \"flags.h\"\n+#include \"tree.h\"\n+#include \"tree-flow.h\"\n \n /* Ratio of frequencies of edges so that one of more latch edges is\n    considered to belong to inner loop with same header.  */"}, {"sha": "d9c758408f22fe80779a61b5c4555ef60e9e04e1", "filename": "gcc/cfgloop.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloop.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloop.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloop.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -237,6 +237,7 @@ extern void flow_loop_dump (const struct loop *, FILE *,\n extern int flow_loop_scan (struct loop *, int);\n extern void flow_loop_free (struct loop *);\n void mark_irreducible_loops (struct loops *);\n+extern void create_loop_notes (void);\n \n /* Loop data structure manipulation/querying.  */\n extern void flow_loop_tree_node_add (struct loop *, struct loop *);"}, {"sha": "9e10d8e6ccb537cedad2bebabb10798dee0def5c", "filename": "gcc/cfgloopmanip.c", "status": "modified", "additions": 96, "deletions": 0, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloopmanip.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgloopmanip.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgloopmanip.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1242,3 +1242,99 @@ loop_split_edge_with (edge e, rtx insns)\n \n   return new_bb;\n }\n+\n+/* Uses the natural loop discovery to recreate loop notes.  */\n+void\n+create_loop_notes (void)\n+{\n+  rtx insn, head, end;\n+  struct loops loops;\n+  struct loop *loop;\n+  basic_block *first, *last, bb, pbb;\n+  struct loop **stack, **top;\n+\n+#ifdef ENABLE_CHECKING\n+  /* Verify that there really are no loop notes.  */\n+  for (insn = get_insns (); insn; insn = NEXT_INSN (insn))\n+    if (GET_CODE (insn) == NOTE\n+\t&& NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+      abort ();\n+#endif\n+\n+  flow_loops_find (&loops, LOOP_TREE);\n+  free_dominance_info (CDI_DOMINATORS);\n+  if (loops.num > 1)\n+    {\n+      last = xcalloc (loops.num, sizeof (basic_block));\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  for (loop = bb->loop_father; loop->outer; loop = loop->outer)\n+\t    last[loop->num] = bb;\n+\t}\n+\n+      first = xcalloc (loops.num, sizeof (basic_block));\n+      stack = xcalloc (loops.num, sizeof (struct loop *));\n+      top = stack;\n+\n+      FOR_EACH_BB (bb)\n+\t{\n+\t  for (loop = bb->loop_father; loop->outer; loop = loop->outer)\n+\t    {\n+\t      if (!first[loop->num])\n+\t\t{\n+\t\t  *top++ = loop;\n+\t\t  first[loop->num] = bb;\n+\t\t}\n+\n+\t      if (bb == last[loop->num])\n+\t\t{\n+\t\t  /* Prevent loops from overlapping.  */\n+\t\t  while (*--top != loop)\n+\t\t    last[(*top)->num] = EXIT_BLOCK_PTR;\n+\n+\t\t  /* If loop starts with jump into it, place the note in\n+\t\t     front of the jump.  */\n+\t\t  insn = PREV_INSN (BB_HEAD (first[loop->num]));\n+\t\t  if (insn\n+\t\t      && GET_CODE (insn) == BARRIER)\n+\t\t    insn = PREV_INSN (insn);\n+\t\t  \n+\t\t  if (insn\n+\t\t      && GET_CODE (insn) == JUMP_INSN\n+\t\t      && any_uncondjump_p (insn)\n+\t\t      && onlyjump_p (insn))\n+\t\t    {\n+\t\t      pbb = BLOCK_FOR_INSN (insn);\n+\t\t      if (!pbb || !pbb->succ || pbb->succ->succ_next)\n+\t\t\tabort ();\n+\n+\t\t      if (!flow_bb_inside_loop_p (loop, pbb->succ->dest))\n+\t\t\tinsn = BB_HEAD (first[loop->num]);\n+\t\t    }\n+\t\t  else\n+\t\t    insn = BB_HEAD (first[loop->num]);\n+\t\t    \n+\t\t  head = BB_HEAD (first[loop->num]);\n+\t\t  emit_note_before (NOTE_INSN_LOOP_BEG, insn);\n+\t\t  BB_HEAD (first[loop->num]) = head;\n+\n+\t\t  /* Position the note correctly wrto barrier.  */\n+\t\t  insn = BB_END (last[loop->num]);\n+\t\t  if (NEXT_INSN (insn)\n+\t\t      && GET_CODE (NEXT_INSN (insn)) == BARRIER)\n+\t\t    insn = NEXT_INSN (insn);\n+\t\t  \n+\t\t  end = BB_END (last[loop->num]);\n+\t\t  emit_note_after (NOTE_INSN_LOOP_END, insn);\n+\t\t  BB_END (last[loop->num]) = end;\n+\t\t}\n+\t    }\n+\t}\n+\n+      free (first);\n+      free (last);\n+      free (stack);\n+    }\n+  flow_loops_free (&loops);\n+}"}, {"sha": "486128a0074b61d1b387982cd73075208a08d783", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 251, "deletions": 57, "changes": 308, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -74,12 +74,12 @@ static basic_block rtl_split_edge (edge);\n static bool rtl_move_block_after (basic_block, basic_block);\n static int rtl_verify_flow_info (void);\n static basic_block cfg_layout_split_block (basic_block, void *);\n-static bool cfg_layout_redirect_edge_and_branch (edge, basic_block);\n+static edge cfg_layout_redirect_edge_and_branch (edge, basic_block);\n static basic_block cfg_layout_redirect_edge_and_branch_force (edge, basic_block);\n static void cfg_layout_delete_block (basic_block);\n static void rtl_delete_block (basic_block);\n static basic_block rtl_redirect_edge_and_branch_force (edge, basic_block);\n-static bool rtl_redirect_edge_and_branch (edge, basic_block);\n+static edge rtl_redirect_edge_and_branch (edge, basic_block);\n static basic_block rtl_split_block (basic_block, void *);\n static void rtl_dump_bb (basic_block, FILE *, int);\n static int rtl_verify_flow_info_1 (void);\n@@ -259,7 +259,6 @@ create_basic_block_structure (rtx head, rtx end, rtx bb_note, basic_block after)\n   basic_block bb;\n \n   if (bb_note\n-      && ! RTX_INTEGRATED_P (bb_note)\n       && (bb = NOTE_BASIC_BLOCK (bb_note)) != NULL\n       && bb->aux == NULL)\n     {\n@@ -354,7 +353,7 @@ cfg_layout_create_basic_block (void *head, void *end, basic_block after)\n {\n   basic_block newbb = rtl_create_basic_block (head, end, after);\n \n-  cfg_layout_initialize_rbi (newbb);\n+  initialize_bb_rbi (newbb);\n   return newbb;\n }\n \f\n@@ -392,8 +391,6 @@ rtl_delete_block (basic_block b)\n \n   insn = BB_HEAD (b);\n \n-  never_reached_warning (insn, BB_END (b));\n-\n   if (GET_CODE (insn) == CODE_LABEL)\n     maybe_remove_eh_handler (insn);\n \n@@ -666,7 +663,7 @@ block_label (basic_block block)\n    apply only if all edges now point to the same block.  The parameters and\n    return values are equivalent to redirect_edge_and_branch.  */\n \n-bool\n+edge\n try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n {\n   basic_block src = e->src;\n@@ -690,14 +687,14 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n       break;\n \n   if (tmp || !onlyjump_p (insn))\n-    return false;\n+    return NULL;\n   if ((!optimize || reload_completed) && tablejump_p (insn, NULL, NULL))\n-    return false;\n+    return NULL;\n \n   /* Avoid removing branch with side effects.  */\n   set = single_set (insn);\n   if (!set || side_effects_p (set))\n-    return false;\n+    return NULL;\n \n   /* In case we zap a conditional jump, we'll need to kill\n      the cc0 setter too.  */\n@@ -746,21 +743,21 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   else if (simplejump_p (insn))\n     {\n       if (e->dest == target)\n-\treturn false;\n+\treturn NULL;\n       if (dump_file)\n \tfprintf (dump_file, \"Redirecting jump %i from %i to %i.\\n\",\n \t\t INSN_UID (insn), e->dest->index, target->index);\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n \t  if (target == EXIT_BLOCK_PTR)\n-\t    return false;\n+\t    return NULL;\n \t  abort ();\n \t}\n     }\n \n   /* Cannot do anything for target exit block.  */\n   else if (target == EXIT_BLOCK_PTR)\n-    return false;\n+    return NULL;\n \n   /* Or replace possibly complicated jump insn by simple jump insn.  */\n   else\n@@ -834,7 +831,7 @@ try_redirect_by_replacing_jump (edge e, basic_block target, bool in_cfglayout)\n   if (e->dest != target)\n     redirect_edge_succ (e, target);\n \n-  return true;\n+  return e;\n }\n \n /* Return last loop_beg note appearing after INSN, before start of next\n@@ -859,8 +856,9 @@ last_loop_beg_note (rtx insn)\n   return last;\n }\n \n-/* Redirect edge representing branch of (un)conditional jump or tablejump.  */\n-static bool\n+/* Redirect edge representing branch of (un)conditional jump or tablejump,\n+   NULL on failure  */\n+static edge\n redirect_branch_edge (edge e, basic_block target)\n {\n   rtx tmp;\n@@ -870,9 +868,9 @@ redirect_branch_edge (edge e, basic_block target)\n \n   /* We can only redirect non-fallthru edges of jump insn.  */\n   if (e->flags & EDGE_FALLTHRU)\n-    return false;\n+    return NULL;\n   else if (GET_CODE (insn) != JUMP_INSN)\n-    return false;\n+    return NULL;\n \n   /* Recognize a tablejump and adjust all matching cases.  */\n   if (tablejump_p (insn, NULL, &tmp))\n@@ -882,7 +880,7 @@ redirect_branch_edge (edge e, basic_block target)\n       rtx new_label = block_label (target);\n \n       if (target == EXIT_BLOCK_PTR)\n-\treturn false;\n+\treturn NULL;\n       if (GET_CODE (PATTERN (tmp)) == ADDR_VEC)\n \tvec = XVEC (PATTERN (tmp), 0);\n       else\n@@ -917,7 +915,7 @@ redirect_branch_edge (edge e, basic_block target)\n       if (computed_jump_p (insn)\n \t  /* A return instruction can't be redirected.  */\n \t  || returnjump_p (insn))\n-\treturn false;\n+\treturn NULL;\n \n       /* If the insn doesn't go where we think, we're confused.  */\n       if (JUMP_LABEL (insn) != old_label)\n@@ -929,7 +927,7 @@ redirect_branch_edge (edge e, basic_block target)\n       if (!redirect_jump (insn, block_label (target), 0))\n \t{\n \t  if (target == EXIT_BLOCK_PTR)\n-\t    return false;\n+\t    return NULL;\n \t  abort ();\n \t}\n     }\n@@ -939,8 +937,8 @@ redirect_branch_edge (edge e, basic_block target)\n \t     e->src->index, e->dest->index, target->index);\n \n   if (e->dest != target)\n-    redirect_edge_succ_nodup (e, target);\n-  return true;\n+    e = redirect_edge_succ_nodup (e, target);\n+  return e;\n }\n \n /* Attempt to change code to redirect edge E to TARGET.  Don't do that on\n@@ -949,32 +947,35 @@ redirect_branch_edge (edge e, basic_block target)\n    Function can be also called with edge destination equivalent to the TARGET.\n    Then it should try the simplifications and do nothing if none is possible.\n \n-   Return true if transformation succeeded.  We still return false in case E\n-   already destinated TARGET and we didn't managed to simplify instruction\n-   stream.  */\n+   Return edge representing the branch if transformation succeeded.  Return NULL\n+   on failure.\n+   We still return NULL in case E already destinated TARGET and we didn't\n+   managed to simplify instruction stream.  */\n \n-static bool\n+static edge\n rtl_redirect_edge_and_branch (edge e, basic_block target)\n {\n+  edge ret;\n   basic_block src = e->src;\n \n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n-    return false;\n+    return NULL;\n \n   if (e->dest == target)\n-    return true;\n+    return e;\n \n-  if (try_redirect_by_replacing_jump (e, target, false))\n+  if ((ret = try_redirect_by_replacing_jump (e, target, false)) != NULL)\n     {\n       src->flags |= BB_DIRTY;\n-      return true;\n+      return ret;\n     }\n \n-  if (!redirect_branch_edge (e, target))\n-    return false;\n+  ret = redirect_branch_edge (e, target);\n+  if (!ret)\n+    return NULL;\n \n   src->flags |= BB_DIRTY;\n-  return true;\n+  return ret;\n }\n \n /* Like force_nonfallthru below, but additionally performs redirection\n@@ -1376,14 +1377,14 @@ insert_insn_on_edge (rtx pattern, edge e)\n   if ((e->flags & EDGE_ABNORMAL) && EDGE_CRITICAL_P (e))\n     abort ();\n \n-  if (e->insns == NULL_RTX)\n+  if (e->insns.r == NULL_RTX)\n     start_sequence ();\n   else\n-    push_to_sequence (e->insns);\n+    push_to_sequence (e->insns.r);\n \n   emit_insn (pattern);\n \n-  e->insns = get_insns ();\n+  e->insns.r = get_insns ();\n   end_sequence ();\n }\n \n@@ -1491,8 +1492,8 @@ commit_one_edge_insertion (edge e, int watch_calls)\n   basic_block bb = NULL;\n \n   /* Pull the insns off the edge now since the edge might go away.  */\n-  insns = e->insns;\n-  e->insns = NULL_RTX;\n+  insns = e->insns.r;\n+  e->insns.r = NULL_RTX;\n \n   /* Special case -- avoid inserting code between call and storing\n      its return value.  */\n@@ -1663,10 +1664,10 @@ commit_edge_insertions (void)\n       for (e = bb->succ; e; e = next)\n \t{\n \t  next = e->succ_next;\n-\t  if (e->insns)\n+\t  if (e->insns.r)\n \t    {\n-\t       changed = true;\n-\t       commit_one_edge_insertion (e, false);\n+\t      changed = true;\n+\t      commit_one_edge_insertion (e, false);\n \t    }\n \t}\n     }\n@@ -1711,7 +1712,7 @@ commit_edge_insertions_watch_calls (void)\n       for (e = bb->succ; e; e = next)\n \t{\n \t  next = e->succ_next;\n-\t  if (e->insns)\n+\t  if (e->insns.r)\n \t    {\n \t      changed = true;\n \t      commit_one_edge_insertion (e, true);\n@@ -2467,23 +2468,23 @@ cfg_layout_split_block (basic_block bb, void *insnp)\n \n \n /* Redirect Edge to DEST.  */\n-static bool\n+static edge\n cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n {\n   basic_block src = e->src;\n-  bool ret;\n+  edge ret;\n \n   if (e->flags & (EDGE_ABNORMAL_CALL | EDGE_EH))\n-    return false;\n+    return NULL;\n \n   if (e->dest == dest)\n-    return true;\n+    return e;\n \n   if (e->src != ENTRY_BLOCK_PTR\n-      && try_redirect_by_replacing_jump (e, dest, true))\n+      && (ret = try_redirect_by_replacing_jump (e, dest, true)))\n     {\n       src->flags |= BB_DIRTY;\n-      return true;\n+      return ret;\n     }\n \n   if (e->src == ENTRY_BLOCK_PTR\n@@ -2495,7 +2496,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \n       e->src->flags |= BB_DIRTY;\n       redirect_edge_succ (e, dest);\n-      return true;\n+      return e;\n     }\n \n   /* Redirect_edge_and_branch may decide to turn branch into fallthru edge\n@@ -2518,7 +2519,7 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t    abort ();\n \t  e->flags |= EDGE_FALLTHRU;\n           e->src->flags |= BB_DIRTY;\n-\t  return true;\n+\t  return e;\n \t}\n       /* In case we are redirecting fallthru edge to the branch edge\n          of conditional jump, remove it.  */\n@@ -2531,13 +2532,10 @@ cfg_layout_redirect_edge_and_branch (edge e, basic_block dest)\n \t      && onlyjump_p (BB_END (src)))\n \t    delete_insn (BB_END (src));\n \t}\n-\n+      ret = redirect_edge_succ_nodup (e, dest);\n       if (dump_file)\n \tfprintf (dump_file, \"Fallthru edge %i->%i redirected to %i\\n\",\n \t\t e->src->index, e->dest->index, dest->index);\n-      redirect_edge_succ_nodup (e, dest);\n-\n-      ret = true;\n     }\n   else\n     ret = redirect_branch_edge (e, dest);\n@@ -2781,6 +2779,179 @@ rtl_make_forwarder_block (edge fallthru ATTRIBUTE_UNUSED)\n {\n }\n \n+/* Return 1 if BB ends with a call, possibly followed by some\n+   instructions that must stay with the call, 0 otherwise.  */\n+\n+static bool\n+rtl_block_ends_with_call_p (basic_block bb)\n+{\n+  rtx insn = BB_END (bb);\n+\n+  while (GET_CODE (insn) != CALL_INSN\n+\t && insn != BB_HEAD (bb)\n+\t && keep_with_call_p (insn))\n+    insn = PREV_INSN (insn);\n+  return (GET_CODE (insn) == CALL_INSN);\n+}\n+\n+/* Return 1 if BB ends with a conditional branch, 0 otherwise.  */\n+\n+static bool\n+rtl_block_ends_with_condjump_p (basic_block bb)\n+{\n+  return any_condjump_p (BB_END (bb));\n+}\n+\n+/* Return true if we need to add fake edge to exit.\n+   Helper function for rtl_flow_call_edges_add.  */\n+\n+static bool\n+need_fake_edge_p (rtx insn)\n+{\n+  if (!INSN_P (insn))\n+    return false;\n+\n+  if ((GET_CODE (insn) == CALL_INSN\n+       && !SIBLING_CALL_P (insn)\n+       && !find_reg_note (insn, REG_NORETURN, NULL)\n+       && !find_reg_note (insn, REG_ALWAYS_RETURN, NULL)\n+       && !CONST_OR_PURE_CALL_P (insn)))\n+    return true;\n+\n+  return ((GET_CODE (PATTERN (insn)) == ASM_OPERANDS\n+\t   && MEM_VOLATILE_P (PATTERN (insn)))\n+\t  || (GET_CODE (PATTERN (insn)) == PARALLEL\n+\t      && asm_noperands (insn) != -1\n+\t      && MEM_VOLATILE_P (XVECEXP (PATTERN (insn), 0, 0)))\n+\t  || GET_CODE (PATTERN (insn)) == ASM_INPUT);\n+}\n+\n+/* Add fake edges to the function exit for any non constant and non noreturn\n+   calls, volatile inline assembly in the bitmap of blocks specified by\n+   BLOCKS or to the whole CFG if BLOCKS is zero.  Return the number of blocks\n+   that were split.\n+\n+   The goal is to expose cases in which entering a basic block does not imply\n+   that all subsequent instructions must be executed.  */\n+\n+static int\n+rtl_flow_call_edges_add (sbitmap blocks)\n+{\n+  int i;\n+  int blocks_split = 0;\n+  int last_bb = last_basic_block;\n+  bool check_last_block = false;\n+\n+  if (n_basic_blocks == 0)\n+    return 0;\n+\n+  if (! blocks)\n+    check_last_block = true;\n+  else\n+    check_last_block = TEST_BIT (blocks, EXIT_BLOCK_PTR->prev_bb->index);\n+\n+  /* In the last basic block, before epilogue generation, there will be\n+     a fallthru edge to EXIT.  Special care is required if the last insn\n+     of the last basic block is a call because make_edge folds duplicate\n+     edges, which would result in the fallthru edge also being marked\n+     fake, which would result in the fallthru edge being removed by\n+     remove_fake_edges, which would result in an invalid CFG.\n+\n+     Moreover, we can't elide the outgoing fake edge, since the block\n+     profiler needs to take this into account in order to solve the minimal\n+     spanning tree in the case that the call doesn't return.\n+\n+     Handle this by adding a dummy instruction in a new last basic block.  */\n+  if (check_last_block)\n+    {\n+      basic_block bb = EXIT_BLOCK_PTR->prev_bb;\n+      rtx insn = BB_END (bb);\n+\n+      /* Back up past insns that must be kept in the same block as a call.  */\n+      while (insn != BB_HEAD (bb)\n+\t     && keep_with_call_p (insn))\n+\tinsn = PREV_INSN (insn);\n+\n+      if (need_fake_edge_p (insn))\n+\t{\n+\t  edge e;\n+\n+\t  for (e = bb->succ; e; e = e->succ_next)\n+\t    if (e->dest == EXIT_BLOCK_PTR)\n+\t      {\n+\t\tinsert_insn_on_edge (gen_rtx_USE (VOIDmode, const0_rtx), e);\n+\t\tcommit_edge_insertions ();\n+\t\tbreak;\n+\t      }\n+\t}\n+    }\n+\n+  /* Now add fake edges to the function exit for any non constant\n+     calls since there is no way that we can determine if they will\n+     return or not...  */\n+\n+  for (i = 0; i < last_bb; i++)\n+    {\n+      basic_block bb = BASIC_BLOCK (i);\n+      rtx insn;\n+      rtx prev_insn;\n+\n+      if (!bb)\n+\tcontinue;\n+\n+      if (blocks && !TEST_BIT (blocks, i))\n+\tcontinue;\n+\n+      for (insn = BB_END (bb); ; insn = prev_insn)\n+\t{\n+\t  prev_insn = PREV_INSN (insn);\n+\t  if (need_fake_edge_p (insn))\n+\t    {\n+\t      edge e;\n+\t      rtx split_at_insn = insn;\n+\n+\t      /* Don't split the block between a call and an insn that should\n+\t         remain in the same block as the call.  */\n+\t      if (GET_CODE (insn) == CALL_INSN)\n+\t\twhile (split_at_insn != BB_END (bb)\n+\t\t       && keep_with_call_p (NEXT_INSN (split_at_insn)))\n+\t\t  split_at_insn = NEXT_INSN (split_at_insn);\n+\n+\t      /* The handling above of the final block before the epilogue\n+\t         should be enough to verify that there is no edge to the exit\n+\t\t block in CFG already.  Calling make_edge in such case would\n+\t\t cause us to mark that edge as fake and remove it later.  */\n+\n+#ifdef ENABLE_CHECKING\n+\t      if (split_at_insn == BB_END (bb))\n+\t\tfor (e = bb->succ; e; e = e->succ_next)\n+\t\t  if (e->dest == EXIT_BLOCK_PTR)\n+\t\t    abort ();\n+#endif\n+\n+\t      /* Note that the following may create a new basic block\n+\t\t and renumber the existing basic blocks.  */\n+\t      if (split_at_insn != BB_END (bb))\n+\t\t{\n+\t\t  e = split_block (bb, split_at_insn);\n+\t\t  if (e)\n+\t\t    blocks_split++;\n+\t\t}\n+\n+\t      make_edge (bb, EXIT_BLOCK_PTR, EDGE_FAKE);\n+\t    }\n+\n+\t  if (insn == BB_HEAD (bb))\n+\t    break;\n+\t}\n+    }\n+\n+  if (blocks_split)\n+    verify_flow_info ();\n+\n+  return blocks_split;\n+}\n+\n /* Implementation of CFG manipulation for linearized RTL.  */\n struct cfg_hooks rtl_cfg_hooks = {\n   \"rtl\",\n@@ -2794,15 +2965,30 @@ struct cfg_hooks rtl_cfg_hooks = {\n   rtl_move_block_after,\n   rtl_can_merge_blocks,  /* can_merge_blocks_p */\n   rtl_merge_blocks,\n+  rtl_predict_edge,\n+  rtl_predicted_by_p,\n+  NULL, /* can_duplicate_block_p */\n+  NULL, /* duplicate_block */\n   rtl_split_edge,\n   rtl_make_forwarder_block,\n-  rtl_tidy_fallthru_edge\n+  rtl_tidy_fallthru_edge,\n+  rtl_block_ends_with_call_p,\n+  rtl_block_ends_with_condjump_p,\n+  rtl_flow_call_edges_add\n };\n \n /* Implementation of CFG manipulation for cfg layout RTL, where\n    basic block connected via fallthru edges does not have to be adjacent.\n    This representation will hopefully become the default one in future\n    version of the compiler.  */\n+\n+/* We do not want to declare these functions in a header file, since they\n+   should only be used through the cfghooks interface, and we do not want to\n+   move them here since it would require also moving quite a lot of related\n+   code.  */\n+extern bool cfg_layout_can_duplicate_bb_p (basic_block);\n+extern basic_block cfg_layout_duplicate_bb (basic_block);\n+\n struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   \"cfglayout mode\",\n   rtl_verify_flow_info_1,\n@@ -2815,7 +3001,15 @@ struct cfg_hooks cfg_layout_rtl_cfg_hooks = {\n   rtl_move_block_after,\n   cfg_layout_can_merge_blocks_p,\n   cfg_layout_merge_blocks,\n+  rtl_predict_edge,\n+  rtl_predicted_by_p,\n+  cfg_layout_can_duplicate_bb_p,\n+  cfg_layout_duplicate_bb,\n   cfg_layout_split_edge,\n   rtl_make_forwarder_block,\n-  NULL\n+  NULL,\n+  rtl_block_ends_with_call_p,\n+  rtl_block_ends_with_condjump_p,\n+  rtl_flow_call_edges_add\n };\n+"}, {"sha": "5669edd8f08d4fd3fa599ca5bccdcc4336f7dd43", "filename": "gcc/cgraph.c", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -407,16 +407,6 @@ cgraph_mark_reachable_node (struct cgraph_node *node)\n \n       node->next_needed = cgraph_nodes_queue;\n       cgraph_nodes_queue = node;\n-\n-      /* At the moment frontend automatically emits all nested functions.  */\n-      if (node->nested)\n-\t{\n-\t  struct cgraph_node *node2;\n-\n-\t  for (node2 = node->nested; node2; node2 = node2->next_nested)\n-\t    if (!node2->reachable)\n-\t      cgraph_mark_reachable_node (node2);\n-\t}\n     }\n }\n "}, {"sha": "c76b5dc6cafcb76921faf415e6db42bd03fb14ef", "filename": "gcc/cgraph.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -30,7 +30,6 @@ struct cgraph_local_info GTY(())\n {\n   /* Size of the function before inlining.  */\n   int self_insns;\n-\n   /* Set when function function is visible in current compilation unit only\n      and it's address is never taken.  */\n   bool local;\n@@ -66,9 +65,9 @@ struct cgraph_global_info GTY(())\n \n struct cgraph_rtl_info GTY(())\n {\n+   int preferred_incoming_stack_boundary;\n    bool const_function;\n    bool pure_function;\n-   int preferred_incoming_stack_boundary;\n };\n \n "}, {"sha": "c079e404ee5abc9d1110966d39d72c9f779c15d4", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 172, "deletions": 56, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -216,6 +216,8 @@ static htab_t visited_nodes;\n static bool\n decide_is_function_needed (struct cgraph_node *node, tree decl)\n {\n+  struct cgraph_node *origin;\n+\n   /* If we decided it was needed before, but at the time we didn't have\n      the body of the function available, then it's still needed.  We have\n      to go back and re-check its dependencies now.  */\n@@ -252,6 +254,11 @@ decide_is_function_needed (struct cgraph_node *node, tree decl)\n   /* \"extern inline\" functions are never output locally.  */\n   if (DECL_EXTERNAL (decl))\n     return false;\n+  /* Nested functions of extern inline function shall not be emit unless\n+     we inlined the origin.  */\n+  for (origin = node->origin; origin; origin = origin->origin)\n+    if (DECL_EXTERNAL (origin->decl))\n+      return false;\n   /* We want to emit COMDAT functions only when absolutely necessary.  */\n   if (DECL_COMDAT (decl))\n     return false;\n@@ -283,7 +290,7 @@ cgraph_assemble_pending_functions (void)\n \n       cgraph_nodes_queue = cgraph_nodes_queue->next_needed;\n       n->next_needed = NULL;\n-      if (!n->origin && !n->global.inlined_to && !DECL_EXTERNAL (n->decl))\n+      if (!n->global.inlined_to && !DECL_EXTERNAL (n->decl))\n \t{\n \t  cgraph_expand_function (n);\n \t  output = true;\n@@ -374,11 +381,6 @@ cgraph_finalize_function (tree decl, bool nested)\n   if (!TREE_ASM_WRITTEN (decl))\n     (*debug_hooks->deferred_inline_function) (decl);\n \n-  /* We will never really output the function body, clear the STRUCT_FUNCTION array\n-     early then.  */\n-  if (DECL_EXTERNAL (decl))\n-    DECL_STRUCT_FUNCTION (decl) = NULL;\n-\n   /* Possibly warn about unused parameters.  */\n   if (warn_unused_parameter)\n     do_warn_unused_parameter (decl);\n@@ -618,9 +620,7 @@ cgraph_analyze_function (struct cgraph_node *node)\n   cgraph_create_edges (node, DECL_SAVED_TREE (decl));\n \n   node->local.inlinable = tree_inlinable_function_p (decl);\n-  if (!node->local.self_insns)\n-    node->local.self_insns\n-      = lang_hooks.tree_inlining.estimate_num_insns (decl);\n+  node->local.self_insns = estimate_num_insns (DECL_SAVED_TREE (decl));\n   if (node->local.inlinable)\n     node->local.disregard_inline_limits\n       = lang_hooks.tree_inlining.disregard_inline_limits (decl);\n@@ -737,7 +737,6 @@ cgraph_finalize_compilation_unit (void)\n   ggc_collect ();\n   timevar_pop (TV_CGRAPH);\n }\n-\n /* Figure out what functions we want to assemble.  */\n \n static void\n@@ -749,7 +748,6 @@ cgraph_mark_functions_to_output (void)\n     {\n       tree decl = node->decl;\n       struct cgraph_edge *e;\n-\n       if (node->output)\n \tabort ();\n \n@@ -764,12 +762,12 @@ cgraph_mark_functions_to_output (void)\n \t  && !node->global.inlined_to\n \t  && (node->needed\n \t      || (e && node->reachable))\n-\t  && !TREE_ASM_WRITTEN (decl) && !node->origin\n+\t  && !TREE_ASM_WRITTEN (decl)\n \t  && !DECL_EXTERNAL (decl))\n \tnode->output = 1;\n       /* We should've reclaimed all functions that are not needed.  */\n       else if (!node->global.inlined_to && DECL_SAVED_TREE (decl)\n-\t       && !node->origin && !DECL_EXTERNAL (decl))\n+\t       && !DECL_EXTERNAL (decl))\n \t{\n \t  dump_cgraph_node (stderr, node);\n \t  abort ();\n@@ -794,15 +792,21 @@ cgraph_expand_function (struct cgraph_node *node)\n   /* Generate RTL for the body of DECL.  Nested functions are expanded\n      via lang_expand_decl_stmt.  */\n   lang_hooks.callgraph.expand_function (decl);\n-  if (DECL_DEFER_OUTPUT (decl))\n-    abort ();\n \n-  /* Make sure that BE didn't gave up on compiling.  */\n-  if (!TREE_ASM_WRITTEN (node->decl)\n-      && !(sorrycount || errorcount))\n+  /* Make sure that BE didn't give up on compiling.  */\n+  /* ??? Can happen with nested function of extern inline.  */\n+  if (!TREE_ASM_WRITTEN (node->decl))\n     abort ();\n \n   current_function_decl = NULL;\n+  if (DECL_SAVED_TREE (node->decl)\n+      && !cgraph_preserve_function_body_p (node->decl))\n+    {\n+      DECL_SAVED_TREE (node->decl) = NULL;\n+      DECL_STRUCT_FUNCTION (node->decl) = NULL;\n+      DECL_ARGUMENTS (node->decl) = NULL;\n+      DECL_INITIAL (node->decl) = error_mark_node;\n+    }\n }\n \n /* Fill array order with all nodes with output flag set in the reverse\n@@ -822,7 +826,7 @@ cgraph_postorder (struct cgraph_node **order)\n   /* We have to deal with cycles nicely, so use a depth first traversal\n      output algorithm.  Ignore the fact that some functions won't need\n      to be output and put them into order as well, so we get dependencies\n-     right throughout inline functions.  */\n+     right through intline functions.  */\n   for (node = cgraph_nodes; node; node = node->next)\n     node->aux = NULL;\n   for (node = cgraph_nodes; node; node = node->next)\n@@ -921,7 +925,7 @@ cgraph_remove_unreachable_nodes (void)\n   /* Remove unreachable nodes.  Extern inline functions need special care;\n      Unreachable extern inline functions shall be removed.\n      Reachable extern inline functions we never inlined shall get their bodies\n-     eliminated\n+     eliminated.\n      Reachable extern inline functions we sometimes inlined will be turned into\n      unanalyzed nodes so they look like for true extern functions to the rest\n      of code.  Body of such functions is released via remove_node once the\n@@ -1008,7 +1012,7 @@ cgraph_estimate_growth (struct cgraph_node *node)\n   /* ??? Wrong for self recursive functions or cases where we decide to not\n      inline for different reasons, but it is not big deal as in that case\n      we will keep the body around, but we will also avoid some inlining.  */\n-  if (!node->needed && !node->origin && !DECL_EXTERNAL (node->decl))\n+  if (!node->needed && !DECL_EXTERNAL (node->decl))\n     growth -= node->global.insns;\n \n   return growth;\n@@ -1028,7 +1032,6 @@ cgraph_clone_inlined_nodes (struct cgraph_edge *e, bool duplicate)\n      case just go ahead and re-use it.  */\n   if (!e->callee->callers->next_caller\n       && (!e->callee->needed || DECL_EXTERNAL (e->callee->decl))\n-      && !e->callee->origin\n       && duplicate\n       && flag_unit_at_a_time)\n     {\n@@ -1191,28 +1194,17 @@ cgraph_recursive_inlining_p (struct cgraph_node *to,\n \t\t\t     struct cgraph_node *what,\n \t\t\t     const char **reason)\n {\n-  struct cgraph_node *node;\n-\n-  /* Walk TO and all functions TO is inlined in.  */\n-  while (1)\n-    {\n-      /* We create recursive inlining either by inlining WHAT into something\n-\t already inlined in possibly different clone of WHAT.  */\n-      if (what->decl == to->decl)\n-\tgoto recursive;\n-      /* Or by inlining WHAT into something that is already inlined in WHAT.  */\n-      for (node = cgraph_node (to->decl); node; node = node->next_clone)\n-\tif (node->global.inlined_to == what)\n-\t  goto recursive;\n-      if (!to->callers || to->callers->inline_failed)\n-\treturn false;\n-      to = to->callers->caller;\n-    }\n-recursive:\n-  if (reason)\n+  bool recursive;\n+  if (to->global.inlined_to)\n+    recursive = what->decl == to->global.inlined_to->decl;\n+  else\n+    recursive = what->decl == to->decl;\n+  /* Marking recursive function inlinine has sane semantic and thus we should\n+     not warn on it.  */\n+  if (recursive && reason)\n     *reason = (what->local.disregard_inline_limits\n \t       ? N_(\"recursive inlining\") : \"\");\n-  return true;\n+  return recursive;\n }\n \n /* Recompute heap nodes for each of callees.  */\n@@ -1230,6 +1222,110 @@ update_callee_keys (fibheap_t heap, struct fibnode **heap_node,\n       update_callee_keys (heap, heap_node, e->callee);\n }\n \n+/* Enqueue all recursive calls from NODE into queue linked via aux pointers\n+   in between FIRST and LAST.  WHERE is used for bookkeeping while looking\n+   int calls inlined within NODE.  */\n+static void\n+lookup_recursive_calls (struct cgraph_node *node, struct cgraph_node *where,\n+\t\t\tstruct cgraph_edge **first, struct cgraph_edge **last)\n+{\n+  struct cgraph_edge *e;\n+  for (e = where->callees; e; e = e->next_callee)\n+    if (e->callee == node)\n+      {\n+\tif (!*first)\n+\t  *first = e;\n+\telse\n+\t  (*last)->aux = e;\n+\t*last = e;\n+      }\n+  for (e = where->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      lookup_recursive_calls (node, e->callee, first, last);\n+}\n+\n+/* Decide on recursive inlining: in the case function has recursive calls,\n+   inline until body size reaches given argument.  */\n+static void\n+cgraph_decide_recursive_inlining (struct cgraph_node *node)\n+{\n+  int limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE_AUTO);\n+  int max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH_AUTO);\n+  struct cgraph_edge *first_call = NULL, *last_call = NULL;\n+  struct cgraph_edge *last_in_current_depth;\n+  struct cgraph_edge *e;\n+  struct cgraph_node *master_clone;\n+  int depth = 0;\n+  int n = 0;\n+\n+  if (DECL_DECLARED_INLINE_P (node->decl))\n+    {\n+      limit = PARAM_VALUE (PARAM_MAX_INLINE_INSNS_RECURSIVE);\n+      max_depth = PARAM_VALUE (PARAM_MAX_INLINE_RECURSIVE_DEPTH);\n+    }\n+\n+  /* Make sure that function is small enought to be considered for inlining.  */\n+  if (!max_depth\n+      || cgraph_estimate_size_after_inlining (1, node, node)  >= limit)\n+    return;\n+  lookup_recursive_calls (node, node, &first_call, &last_call);\n+  if (!first_call)\n+    return;\n+\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \n+\t     \"\\nPerforming recursive inlining on %s\\n\",\n+\t     cgraph_node_name (node));\n+\n+  /* We need original clone to copy around.  */\n+  master_clone = cgraph_clone_node (node);\n+  master_clone->needed = true;\n+  for (e = master_clone->callees; e; e = e->next_callee)\n+    if (!e->inline_failed)\n+      cgraph_clone_inlined_nodes (e, true);\n+\n+  /* Do the inlining and update list of recursive call during process.  */\n+  last_in_current_depth = last_call;\n+  while (first_call\n+\t && cgraph_estimate_size_after_inlining (1, node, master_clone) <= limit)\n+    {\n+      struct cgraph_edge *curr = first_call;\n+\n+      first_call = first_call->aux;\n+      curr->aux = NULL;\n+\n+      cgraph_redirect_edge_callee (curr, master_clone);\n+      cgraph_mark_inline_edge (curr);\n+      lookup_recursive_calls (node, curr->callee, &first_call, &last_call);\n+\n+      if (last_in_current_depth\n+\t  && ++depth >= max_depth)\n+\tbreak;\n+      n++;\n+    }\n+\n+  /* Cleanup queue pointers.  */\n+  while (first_call)\n+    {\n+      struct cgraph_edge *next = first_call->aux;\n+      first_call->aux = NULL;\n+      first_call = next;\n+    }\n+  if (cgraph_dump_file)\n+    fprintf (cgraph_dump_file, \n+\t     \"\\n   Inlined %i times, body grown from %i to %i insns\\n\", n,\n+\t     master_clone->global.insns, node->global.insns);\n+\n+  /* Remove master clone we used for inlining.  We rely that clones inlined\n+     into master clone gets queued just before master clone so we don't\n+     need recursion.  */\n+  for (node = cgraph_nodes; node != master_clone;\n+       node = node->next)\n+    if (node->global.inlined_to == master_clone)\n+      cgraph_remove_node (node);\n+  cgraph_remove_node (master_clone);\n+}\n+\n /* Set inline_failed for all callers of given function to REASON.  */\n \n static void\n@@ -1333,6 +1429,8 @@ cgraph_decide_inlining_of_small_functions (void)\n \t    }\n \t}\n \n+      cgraph_decide_recursive_inlining (node);\n+\n       /* Similarly all functions called by the function we just inlined\n          are now called more times; update keys.  */\n       update_callee_keys (heap, heap_node, node);\n@@ -1383,38 +1481,36 @@ cgraph_decide_inlining (void)\n      so none of our later choices will make this impossible.  */\n   for (i = nnodes - 1; i >= 0; i--)\n     {\n-      struct cgraph_edge *e;\n+      struct cgraph_edge *e, *next;\n \n       node = order[i];\n \n-      for (e = node->callees; e; e = e->next_callee)\n-\tif (e->callee->local.disregard_inline_limits)\n-\t  break;\n-      if (!e)\n+      if (!node->local.disregard_inline_limits)\n \tcontinue;\n       if (cgraph_dump_file)\n \tfprintf (cgraph_dump_file,\n \t\t \"\\nConsidering %s %i insns (always inline)\\n\",\n \t\t cgraph_node_name (e->callee), e->callee->global.insns);\n-      for (; e; e = e->next_callee)\n+      old_insns = overall_insns;\n+      for (e = node->callers; e; e = next)\n \t{\n-\t  old_insns = overall_insns;\n-\t  if (!e->inline_failed || !e->callee->local.disregard_inline_limits)\n+\t  next = e->next_caller;\n+\t  if (!e->inline_failed)\n \t    continue;\n-\t  if (cgraph_recursive_inlining_p (order[i], e->callee,\n+\t  if (cgraph_recursive_inlining_p (e->caller, e->callee,\n \t\t\t\t  \t   &e->inline_failed))\n \t    continue;\n-\t  cgraph_mark_inline (e);\n+\t  cgraph_mark_inline_edge (e);\n \t  if (cgraph_dump_file)\n \t    fprintf (cgraph_dump_file, \n \t\t     \" Inlined into %s which now has %i insns.\\n\",\n \t\t     cgraph_node_name (node->callees->caller),\n \t             node->callees->caller->global.insns);\n \t}\n-\tif (cgraph_dump_file)\n-\t  fprintf (cgraph_dump_file, \n-\t\t   \" Inlined for a net change of %+i insns.\\n\",\n-\t\t   overall_insns - old_insns);\n+      if (cgraph_dump_file)\n+\tfprintf (cgraph_dump_file, \n+\t\t \" Inlined for a net change of %+i insns.\\n\",\n+\t\t overall_insns - old_insns);\n     }\n \n   if (!flag_really_no_inline)\n@@ -1675,5 +1771,25 @@ cgraph_optimize (void)\n     }\n #ifdef ENABLE_CHECKING\n   verify_cgraph ();\n+  /* Double check that all inline clones are gone and that all\n+     function bodies have been released from memory.  */\n+  if (flag_unit_at_a_time\n+      && !dump_enabled_p (TDI_all)\n+      && !(sorrycount || errorcount))\n+    {\n+      struct cgraph_node *node;\n+      bool error_found = false;\n+\n+      for (node = cgraph_nodes; node; node = node->next)\n+\tif (node->analyzed\n+\t    && (node->global.inlined_to\n+\t        || DECL_SAVED_TREE (node->decl)))\n+\t  {\n+\t    error_found = true;\n+\t    dump_cgraph_node (stderr, node);\n+ \t  }\n+      if (error_found)\n+\tinternal_error (\"Nodes with no released memory found.\");\n+    }\n #endif\n }"}, {"sha": "2abd3d86c5c380709f2b0e2343bcf0ba7a5bd32f", "filename": "gcc/combine.c", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -6661,17 +6661,15 @@ get_pos_from_mask (unsigned HOST_WIDE_INT m, unsigned HOST_WIDE_INT *plen)\n {\n   /* Get the bit number of the first 1 bit from the right, -1 if none.  */\n   int pos = exact_log2 (m & -m);\n-  int len;\n-\n-  if (pos < 0)\n-    return -1;\n+  int len = 0;\n \n-  /* Now shift off the low-order zero bits and see if we have a power of\n-     two minus 1.  */\n-  len = exact_log2 ((m >> pos) + 1);\n+  if (pos >= 0)\n+    /* Now shift off the low-order zero bits and see if we have a\n+       power of two minus 1.  */\n+    len = exact_log2 ((m >> pos) + 1);\n \n   if (len <= 0)\n-    return -1;\n+    pos = -1;\n \n   *plen = len;\n   return pos;"}, {"sha": "5309365a0f529901eaa49b5a21cd780822500b39", "filename": "gcc/common.opt", "status": "modified", "additions": 71, "deletions": 0, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -310,6 +310,10 @@ fdiagnostics-show-location=\n Common Joined RejectNegative\n -fdiagnostics-show-location=[once|every-line]\tHow often to emit source location at the beginning of line-wrapped diagnostics\n \n+fdump-\n+Common Joined RejectNegative\n+-fdump-<type>\tDump various compiler internals to a file\n+\n fdump-unnumbered\n Common\n Suppress output of instruction numbers and line number notes in debugging dumps\n@@ -466,6 +470,18 @@ fmove-all-movables\n Common\n Force all loop invariant computations out of loops\n \n+fmudflap\n+Common RejectNegative\n+Add mudflap bounds-checking instrumentation for single-threaded program.\n+\n+fmudflapth\n+Common RejectNegative\n+Add mudflap bounds-checking instrumentation for multi-threaded program.\n+\n+fmudflapir\n+Common RejectNegative\n+Ignore read operations when inserting mudflap instrumentation.\n+\n fnew-ra\n Common\n Use graph-coloring register allocation\n@@ -712,6 +728,61 @@ ftrapv\n Common\n Trap for signed overflow in addition, subtraction and multiplication\n \n+ftree-based-profiling\n+Common\n+Use tree-ssa based implementation of profiling\n+\n+ftree-ccp\n+Common\n+Enable SSA-CCP optimization on trees\n+\n+ftree-ch\n+Common\n+Enable loop header copying on trees\n+\n+ftree-combine-temps\n+Common\n+Coalesce memory temporaries in the SSA->normal pass\n+\n+ftree-copyrename\n+Common\n+Replace SSA temporaries with better names in copies.\n+\n+ftree-dce\n+Common\n+Enable SSA dead code elimination optimization on trees\n+\n+ftree-dominator-opts\n+Common\n+Enable dominator optimizations\n+\n+ftree-dse\n+Common\n+Enable dead store elimination\n+\n+ftree-loop-optimize\n+Common\n+Enable loop optimizations on trees\n+\n+ftree-points-to=\n+Common Joined RejectNegative\n+\n+ftree-pre\n+Common\n+Enable SSA-PRE optimization on trees\n+\n+ftree-sra\n+Common\n+Perform scalar replacement of aggregates\n+\n+ftree-ter\n+Common\n+Replace temporary expressions in the SSA->normal pass\n+\n+ftree-lrs\n+Common\n+Perform live range splitting during the SSA->normal pass.\n+\n funit-at-a-time\n Common\n Compile whole compilation unit at a time"}, {"sha": "6f0661fd6ee8461a913827dd5aef03232bc0f5f2", "filename": "gcc/config.in", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -568,6 +568,15 @@\n /* Define to `int' if <sys/types.h> does not define. */\n #undef ssize_t\n \n+/* Define if your linker supports -pie option. */\n+#undef HAVE_LD_PIE\n+\n+/* Define if BANSHEE is available */\n+#undef HAVE_BANSHEE\n+\n+/* Define to PREFIX/include if cpp should also search that directory. */\n+#undef PREFIX_INCLUDE_DIR\n+\n /* Define to `int' if <sys/types.h> doesn't define. */\n #undef uid_t\n "}, {"sha": "1f78205771cdf121213ff3a2af295849526557e8", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -801,9 +801,6 @@ input_operand (rtx op, enum machine_mode mode)\n     case CONST_INT:\n       return mode == QImode || mode == HImode || add_operand (op, mode);\n \n-    case CONSTANT_P_RTX:\n-      return 1;\n-\n     default:\n       break;\n     }"}, {"sha": "ae9ff3a1b80551736e5d139a6c6c373ecb813686", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1116,7 +1116,7 @@ arm_compute_func_type (void)\n       && TREE_THIS_VOLATILE (current_function_decl))\n     type |= ARM_FT_VOLATILE;\n   \n-  if (current_function_needs_context)\n+  if (cfun->static_chain_decl != NULL)\n     type |= ARM_FT_NESTED;\n \n   attr = DECL_ATTRIBUTES (current_function_decl);\n@@ -10227,10 +10227,10 @@ arm_compute_initial_elimination_offset (unsigned int from, unsigned int to)\n \t     frame pointer and the arg pointer coincide.  */\n \t  if (offsets->frame == offsets->saved_regs)\n \t    return 0;\n-          /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n-          return (frame_pointer_needed\n-                  && current_function_needs_context\n-                  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;\n+\t  /* FIXME:  Not sure about this.  Maybe we should always return 0 ?  */\n+\t  return (frame_pointer_needed\n+\t\t  && cfun->static_chain_decl != NULL\n+\t\t  && ! cfun->machine->uses_anonymous_args) ? 4 : 0;\n \n \tcase STACK_POINTER_REGNUM:\n \t  /* If nothing has been pushed on the stack at all"}, {"sha": "518e387bba8dbc71b784a9728bdc8b3b1264a260", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2046,7 +2046,6 @@ typedef struct\n #define THUMB_LEGITIMATE_CONSTANT_P(X)\t\\\n  (   GET_CODE (X) == CONST_INT\t\t\\\n   || GET_CODE (X) == CONST_DOUBLE\t\\\n-  || GET_CODE (X) == CONSTANT_P_RTX     \\\n   || CONSTANT_ADDRESS_P (X)\t\t\\\n   || flag_pic)\n "}, {"sha": "a78b42be449980d46edd65ddd26a2ff5cf7ddabf", "filename": "gcc/config/avr/avr.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Favr%2Favr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Favr%2Favr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Favr%2Favr.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -765,9 +765,6 @@ extern int avr_case_values_threshold;\n \n #define FUNCTION_MODE HImode\n \n-     /*                            1        3 */\n-#define INTEGRATE_THRESHOLD(DECL) (1 + (3 * list_length (DECL_ARGUMENTS (DECL)) / 2))\n-\n #define DOLLARS_IN_IDENTIFIERS 0\n \n #define NO_DOLLAR_IN_LABEL 1"}, {"sha": "850bcef44b9366f99e604f7fc961302c10e64c3c", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2940,9 +2940,6 @@ const_operand (register rtx op, register enum machine_mode mode)\n     case Pmode:\n #endif\n     case QImode:\n-      if (GET_CODE (op) == CONSTANT_P_RTX)\n-\treturn 1;\n-\n       if (GET_CODE (op) != CONST_INT\n \t  || (GET_MODE (op) != VOIDmode && GET_MODE (op) != mode)\n \t  || GET_MODE_CLASS (mode) != MODE_INT)"}, {"sha": "9ca9d2d3551c04c460f544b64ebde8135a3d953f", "filename": "gcc/config/cris/cris.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2488,7 +2488,6 @@ cris_symbol (rtx x)\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-    case CONSTANT_P_RTX:\n       return 0;\n \n     default:\n@@ -2550,7 +2549,6 @@ cris_gotless_symbol (rtx x)\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-    case CONSTANT_P_RTX:\n       return 0;\n \n     default:\n@@ -2595,7 +2593,6 @@ cris_got_symbol (rtx x)\n \n     case CONST_INT:\n     case CONST_DOUBLE:\n-    case CONSTANT_P_RTX:\n       return 0;\n \n     default:"}, {"sha": "9c62e36ed4009cfd667857e5768d10df5033d766", "filename": "gcc/config/frv/frv.h", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Ffrv%2Ffrv.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Ffrv%2Ffrv.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Ffrv%2Ffrv.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2639,8 +2639,7 @@ fixup_section (void)\t\t\t\t\t\t\t\\\n   (   GET_CODE (X) == CONST_INT\t\t\t\t\t\t\\\n    || GET_CODE (X) == CONST_DOUBLE\t\t\t\t\t\\\n    || (GET_CODE (X) == HIGH && GET_CODE (XEXP (X, 0)) == CONST_INT)\t\\\n-   || got12_operand (X, VOIDmode)\t\t\t\t\t\\\n-   || GET_CODE (X) == CONSTANT_P_RTX)\n+   || got12_operand (X, VOIDmode))\t\t\t\t\t\\\n \n \f\n /* The Overall Framework of an Assembler File.  */"}, {"sha": "9efa140c23b60792c0a4f986dc95b5685357c669", "filename": "gcc/config/h8300/h8300.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fh8300%2Fh8300.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fh8300%2Fh8300.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -384,7 +384,7 @@ h8300_emit_stack_adjustment (int sign, unsigned int size)\n   if (TARGET_H8300\n       && size > 4\n       && !h8300_current_function_interrupt_function_p ()\n-      && !(current_function_needs_context && sign < 0))\n+      && !(cfun->static_chain_decl != NULL && sign < 0))\n     {\n       rtx r3 = gen_rtx_REG (Pmode, 3);\n       emit_insn (gen_movhi (r3, GEN_INT (sign * size)));"}, {"sha": "e15a8a7c8d569f4887bde68cb155dbdffd2f26b2", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 3, "deletions": 13, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -715,7 +715,6 @@ int\n gr_reg_or_5bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && INTVAL (op) >= 0 && INTVAL (op) < 32)\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -725,7 +724,6 @@ int\n gr_reg_or_6bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -735,7 +733,6 @@ int\n gr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -745,7 +742,6 @@ int\n grfr_reg_or_8bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || grfr_register_operand (op, mode));\n }\n \n@@ -756,7 +752,6 @@ int\n gr_reg_or_8bit_adjusted_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_L (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -770,7 +765,6 @@ gr_reg_or_8bit_and_adjusted_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_K (INTVAL (op))\n \t   && CONST_OK_FOR_L (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -780,7 +774,6 @@ int\n gr_reg_or_14bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_I (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -790,7 +783,6 @@ int\n gr_reg_or_22bit_operand (rtx op, enum machine_mode mode)\n {\n   return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_J (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX\n \t  || gr_register_operand (op, mode));\n }\n \n@@ -799,18 +791,16 @@ gr_reg_or_22bit_operand (rtx op, enum machine_mode mode)\n int\n shift_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  return ((GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+  return (GET_CODE (op) == CONST_INT && CONST_OK_FOR_M (INTVAL (op)));\n }\n \n /* Return 1 if OP is a 5 bit immediate operand.  */\n \n int\n shift_32bit_count_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n-  return ((GET_CODE (op) == CONST_INT\n-\t   && (INTVAL (op) >= 0 && INTVAL (op) < 32))\n-\t  || GET_CODE (op) == CONSTANT_P_RTX);\n+  return (GET_CODE (op) == CONST_INT\n+\t   && (INTVAL (op) >= 0 && INTVAL (op) < 32));\n }\n \n /* Return 1 if OP is a 2, 4, 8, or 16 immediate operand.  */"}, {"sha": "b0f4dc64bce3f4454ef4057b39d9adb14a0fab6d", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 11, "deletions": 14, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2178,27 +2178,24 @@ do {\t\t\t\t\t\t\t\t\t\\\n { \"destination_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n { \"not_postinc_memory_operand\", {MEM}},\t\t\t\t\t\\\n { \"move_operand\", {SUBREG, REG, MEM, CONST_INT, CONST_DOUBLE,\t\t\\\n-\t\t     CONSTANT_P_RTX, SYMBOL_REF, CONST, LABEL_REF}},\t\\\n+\t\t     SYMBOL_REF, CONST, LABEL_REF}},\t\t\t\\\n { \"gr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n { \"fr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n { \"grfr_register_operand\", {SUBREG, REG}},\t\t\t\t\\\n { \"gr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n { \"fr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n { \"grfr_nonimmediate_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n { \"gr_reg_or_0_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n-{ \"gr_reg_or_5bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n-{ \"gr_reg_or_6bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n-{ \"gr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n-{ \"grfr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n-{ \"gr_reg_or_8bit_adjusted_operand\", {SUBREG, REG, CONST_INT,\t\t\\\n-\t\t\t\t     CONSTANT_P_RTX}},\t\t\t\\\n-{ \"gr_reg_or_8bit_and_adjusted_operand\", {SUBREG, REG, CONST_INT,\t\\\n-\t\t\t\t\t CONSTANT_P_RTX}},\t\t\\\n-{ \"gr_reg_or_14bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n-{ \"gr_reg_or_22bit_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}}, \\\n-{ \"shift_count_operand\", {SUBREG, REG, CONST_INT, CONSTANT_P_RTX}},\t\\\n-{ \"shift_32bit_count_operand\", {SUBREG, REG, CONST_INT,\t\t\t\\\n-\t\t\t\t  CONSTANT_P_RTX}},\t\t\t\\\n+{ \"gr_reg_or_5bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{ \"gr_reg_or_6bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{ \"gr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{ \"grfr_reg_or_8bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+{ \"gr_reg_or_8bit_adjusted_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n+{ \"gr_reg_or_8bit_and_adjusted_operand\", {SUBREG, REG, CONST_INT}},\t\\\n+{ \"gr_reg_or_14bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+{ \"gr_reg_or_22bit_operand\", {SUBREG, REG, CONST_INT}}, \t\t\\\n+{ \"shift_count_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+{ \"shift_32bit_count_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n { \"shladd_operand\", {CONST_INT}},\t\t\t\t\t\\\n { \"fetchadd_operand\", {CONST_INT}},\t\t\t\t\t\\\n { \"fr_reg_or_fp01_operand\", {SUBREG, REG, CONST_DOUBLE}},\t\t\\"}, {"sha": "a069bf21d183241362125e3bfb27a385290a36f6", "filename": "gcc/config/ip2k/ip2k.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fip2k%2Fip2k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fip2k%2Fip2k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fip2k%2Fip2k.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -767,9 +767,6 @@ do {\t\t\t\t\t\t\t\\\n \n #define FUNCTION_MODE HImode\n \n-#define INTEGRATE_THRESHOLD(DECL) \\\n-  (1 + (3 * list_length (DECL_ARGUMENTS (DECL)) / 2))\n-\n #define DOLLARS_IN_IDENTIFIERS 0\n \n extern int ip2k_reorg_in_progress;"}, {"sha": "fa898bcd18985a8a4ffa549e23defd269d50ee40", "filename": "gcc/config/m32r/m32r.c", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fm32r%2Fm32r.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm32r%2Fm32r.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -771,8 +771,6 @@ move_src_operand (rtx op, enum machine_mode mode)\n \t}\n       else\n \treturn 1;\n-    case CONSTANT_P_RTX:\n-\treturn 1;\n     case CONST_DOUBLE :\n       if (mode == SFmode)\n \treturn 1;"}, {"sha": "5bcdbd938bce8713c83d2bd619bbf205f03686fb", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1277,9 +1277,6 @@ mips_const_insns (rtx x)\n \n   switch (GET_CODE (x))\n     {\n-    case CONSTANT_P_RTX:\n-      return 1;\n-\n     case HIGH:\n       if (TARGET_MIPS16\n \t  || !mips_symbolic_constant_p (XEXP (x, 0), &symbol_type)"}, {"sha": "5c3014c4731f2614697786d9864a84719bf3a586", "filename": "gcc/config/mmix/mmix.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fmmix%2Fmmix.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fmmix%2Fmmix.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmmix%2Fmmix.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1008,7 +1008,6 @@ mmix_constant_address_p (rtx x)\n     case SYMBOL_REF:\n       return 1;\n \n-    case CONSTANT_P_RTX:\n     case HIGH:\n       /* FIXME: Don't know how to dissect these.  Avoid them for now,\n \t except we know they're constants.  */"}, {"sha": "0cc1ed7eb99d8a2165c3683ad83345b9789bd6f0", "filename": "gcc/config/pa/pa.c", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fpa%2Fpa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fpa%2Fpa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -592,9 +592,6 @@ move_src_operand (rtx op, enum machine_mode mode)\n   if (register_operand (op, mode))\n     return 1;\n \n-  if (GET_CODE (op) == CONSTANT_P_RTX)\n-    return 1;\n-\n   if (GET_CODE (op) == CONST_INT)\n     return cint_ok_for_move (INTVAL (op));\n "}, {"sha": "b08021dd472c5307ac1ed029875ad4e83eb2a38b", "filename": "gcc/config/pa/pa.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fpa%2Fpa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fpa%2Fpa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpa%2Fpa.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1987,15 +1987,15 @@ do { \t\t\t\t\t\t\t\t\t\\\n #define PREDICATE_CODES\t\t\t\t\t\t\t\\\n   {\"reg_or_0_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE}},\t\t\\\n   {\"call_operand_address\", {LABEL_REF, SYMBOL_REF, CONST_INT,\t\t\\\n-\t\t\t    CONST_DOUBLE, CONST, HIGH, CONSTANT_P_RTX}}, \\\n+\t\t\t    CONST_DOUBLE, CONST, HIGH}},\t\t \\\n   {\"indexed_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n   {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n   {\"symbolic_memory_operand\", {SUBREG, MEM}},\t\t\t\t\\\n   {\"reg_before_reload_operand\", {REG, MEM}},\t\t\t\t\\\n   {\"reg_or_0_or_nonsymb_mem_operand\", {SUBREG, REG, MEM, CONST_INT,\t\\\n \t\t\t\t       CONST_DOUBLE}},\t\t\t\\\n   {\"move_dest_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"move_src_operand\", {SUBREG, REG, CONSTANT_P_RTX, CONST_INT, MEM}},\t\\\n+  {\"move_src_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n   {\"reg_or_cint_move_operand\", {SUBREG, REG, CONST_INT}},\t\t\\\n   {\"pic_label_operand\", {LABEL_REF, CONST}},\t\t\t\t\\\n   {\"fp_reg_operand\", {REG}},\t\t\t\t\t\t\\"}, {"sha": "887520797729e1f8560de82832942cdaaac652b6", "filename": "gcc/config/rs6000/aix.h", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Faix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Faix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Faix.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -51,12 +51,37 @@\n #define REAL_NM_FILE_NAME \"/usr/ucb/nm\"\n \n #define USER_LABEL_PREFIX  \"\"\n+\n /* Don't turn -B into -L if the argument specifies a relative file name.  */\n #define RELATIVE_PREFIX_NOT_LINKDIR\n \n /* Because of the above, we must have gcc search itself to find libgcc.a.  */\n #define LINK_LIBGCC_SPECIAL_1\n \n+#define MFWRAP_SPEC \" %{static: %{fmudflap|fmudflapth: \\\n+ -brename:malloc,__wrap_malloc -brename:__real_malloc,malloc \\\n+ -brename:free,__wrap_free -brename:__real_free,free \\\n+ -brename:calloc,__wrap_calloc -brename:__real_calloc,calloc \\\n+ -brename:realloc,__wrap_realloc -brename:__real_realloc,realloc \\\n+ -brename:mmap,__wrap_mmap -brename:__real_mmap,mmap \\\n+ -brename:munmap,__wrap_munmap -brename:__real_munmap,munmap \\\n+ -brename:alloca,__wrap_alloca -brename:__real_alloca,alloca \\\n+} %{fmudflapth: \\\n+ -brename:pthread_create,__wrap_pthread_create \\\n+ -brename:__real_pthread_create,pthread_create \\\n+ -brename:pthread_join,__wrap_pthread_join \\\n+ -brename:__real_pthread_join,pthread_join \\\n+ -brename:pthread_exit,__wrap_pthread_exit \\\n+ -brename:__real_pthread_exit,pthread_exit \\\n+}} %{fmudflap|fmudflapth: \\\n+ -brename:main,__wrap_main -brename:__real_main,main \\\n+}\"\n+\n+#define MFLIB_SPEC \" %{fmudflap: -lmudflap \\\n+ %{static:%(link_gcc_c_sequence) -lmudflap}} \\\n+ %{fmudflapth: -lmudflapth -lpthread \\\n+ %{static:%(link_gcc_c_sequence) -lmudflapth}} \"\n+\n /* Names to predefine in the preprocessor for this target machine.  */\n #define TARGET_OS_AIX_CPP_BUILTINS()\t\t\\\n   do\t\t\t\t\t\t\\"}, {"sha": "9f6301b3910aa82d82b8c1a166a9e73e7da5b5ff", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 3, "deletions": 10, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2419,10 +2419,6 @@ input_operand (rtx op, enum machine_mode mode)\n   if (memory_operand (op, mode))\n     return 1;\n \n-  /* Only a tiny bit of handling for CONSTANT_P_RTX is necessary.  */\n-  if (GET_CODE (op) == CONSTANT_P_RTX)\n-    return 1;\n-\n   /* For floating-point, easy constants are valid.  */\n   if (GET_MODE_CLASS (mode) == MODE_FLOAT\n       && CONSTANT_P (op)\n@@ -3753,10 +3749,6 @@ rs6000_emit_move (rtx dest, rtx source, enum machine_mode mode)\n \t  || ! nonimmediate_operand (operands[0], mode)))\n     goto emit_set;\n \n-  /* Handle the case of CONSTANT_P_RTX.  */\n-  if (GET_CODE (operands[1]) == CONSTANT_P_RTX)\n-    goto emit_set;\n-\n   /* 128-bit constant floating-point values on Darwin should really be\n      loaded as two parts.  */\n   if ((DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n@@ -13125,7 +13117,8 @@ rs6000_output_function_epilogue (FILE *file,\n \t Java is 13.  Objective-C is 14.  */\n       if (! strcmp (language_string, \"GNU C\"))\n \ti = 0;\n-      else if (! strcmp (language_string, \"GNU F77\"))\n+      else if (! strcmp (language_string, \"GNU F77\")\n+\t       || ! strcmp (language_string, \"GNU F95\"))\n \ti = 1;\n       else if (! strcmp (language_string, \"GNU Pascal\"))\n \ti = 2;\n@@ -14120,7 +14113,7 @@ output_function_profiler (FILE *file, int labelno)\n \t  asm_fprintf (file, \"\\tmflr %s\\n\", reg_names[0]);\n \t  asm_fprintf (file, \"\\tstd %s,16(%s)\\n\", reg_names[0], reg_names[1]);\n \n-\t  if (current_function_needs_context)\n+\t  if (cfun->static_chain_decl != NULL)\n \t    {\n \t      asm_fprintf (file, \"\\tstd %s,24(%s)\\n\",\n \t\t\t   reg_names[STATIC_CHAIN_REGNUM], reg_names[1]);"}, {"sha": "9546461e57d02a42b7f9d1b6a3dcc888794d54d8", "filename": "gcc/config/rs6000/t-rs6000", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Frs6000%2Ft-rs6000", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Ft-rs6000?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -18,3 +18,23 @@ rs6000-c.o: $(srcdir)/config/rs6000/rs6000-c.c \\\n \n # The rs6000 backend doesn't cause warnings in these files.\n insn-conditions.o-warn =\n+# The files below trigger warnings in tree-ssa because of the gimplifier\n+# emitting code that confuse the compiler into thinking that some variables\n+# are used uninitialized.\n+jump.o-warn = -Wno-error\n+regmove.o-warn = -Wno-error\n+c-typeck.o-warn = -Wno-error\n+cfgrtl.o-warn = -Wno-error\n+combine.o-warn = -Wno-error\n+fold-const.o-warn = -Wno-error\n+ifcvt.o-warn = -Wno-error\n+reload1.o-warn = -Wno-error\n+rtlanal.o-warn = -Wno-error\n+cp/decl2.o-warn = -Wno-error\n+cp/pt.o-warn = -Wno-error\n+f/where.o-warn = -Wno-error\n+java/expr.o-warn = -Wno-error\n+objc/objc-act.o-warn = -Wno-error\n+rs6000.o-warn = -Wno-error\n+insn-emit.o-warn = -Wno-error\n+simplify-rtx.o-warn = -Wno-error"}, {"sha": "9e786bfdf7070713658cae288e57c767cec4925d", "filename": "gcc/config/s390/s390.c", "status": "modified", "additions": 18, "deletions": 24, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fs390%2Fs390.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fs390%2Fs390.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fs390%2Fs390.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -2956,18 +2956,14 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n   else\n     {\n       rtx dst_addr, src_addr, count, blocks, temp;\n+      rtx loop_end_label = gen_label_rtx ();\n       rtx end_label = gen_label_rtx ();\n       enum machine_mode mode;\n-      tree type;\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n         mode = Pmode;\n \n-      type = lang_hooks.types.type_for_mode (mode, 1);\n-      if (!type)\n-        abort ();\n-\n       dst_addr = gen_reg_rtx (Pmode);\n       src_addr = gen_reg_rtx (Pmode);\n       count = gen_reg_rtx (mode);\n@@ -2990,10 +2986,9 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_start_loop (1);\n-      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n-\t\t\t\t\t   make_tree (type, blocks),\n-\t\t\t\t\t   make_tree (type, const0_rtx)));\n \n       emit_insn (gen_movstr_short (dst, src, GEN_INT (255)));\n       s390_load_address (dst_addr,\n@@ -3005,7 +3000,10 @@ s390_expand_movstr (rtx dst, rtx src, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_end_loop ();\n+      emit_label (loop_end_label);\n \n       emit_insn (gen_movstr_short (dst, src,\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));\n@@ -3032,18 +3030,14 @@ s390_expand_clrstr (rtx dst, rtx len)\n   else\n     {\n       rtx dst_addr, src_addr, count, blocks, temp;\n+      rtx loop_end_label = gen_label_rtx ();\n       rtx end_label = gen_label_rtx ();\n       enum machine_mode mode;\n-      tree type;\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n         mode = Pmode;\n \n-      type = lang_hooks.types.type_for_mode (mode, 1);\n-      if (!type)\n-        abort ();\n-\n       dst_addr = gen_reg_rtx (Pmode);\n       src_addr = gen_reg_rtx (Pmode);\n       count = gen_reg_rtx (mode);\n@@ -3064,10 +3058,9 @@ s390_expand_clrstr (rtx dst, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_start_loop (1);\n-      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n-\t\t\t\t\t   make_tree (type, blocks),\n-\t\t\t\t\t   make_tree (type, const0_rtx)));\n \n       emit_insn (gen_clrstr_short (dst, GEN_INT (255)));\n       s390_load_address (dst_addr,\n@@ -3077,7 +3070,10 @@ s390_expand_clrstr (rtx dst, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_end_loop ();\n+      emit_label (loop_end_label);\n \n       emit_insn (gen_clrstr_short (dst, convert_to_mode (Pmode, count, 1)));\n       emit_label (end_label);\n@@ -3120,18 +3116,14 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n   else\n     {\n       rtx addr0, addr1, count, blocks, temp;\n+      rtx loop_end_label = gen_label_rtx ();\n       rtx end_label = gen_label_rtx ();\n       enum machine_mode mode;\n-      tree type;\n \n       mode = GET_MODE (len);\n       if (mode == VOIDmode)\n         mode = Pmode;\n \n-      type = lang_hooks.types.type_for_mode (mode, 1);\n-      if (!type)\n-        abort ();\n-\n       addr0 = gen_reg_rtx (Pmode);\n       addr1 = gen_reg_rtx (Pmode);\n       count = gen_reg_rtx (mode);\n@@ -3154,10 +3146,9 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_start_loop (1);\n-      expand_exit_loop_top_cond (0, build (NE_EXPR, type,\n-\t\t\t\t\t   make_tree (type, blocks),\n-\t\t\t\t\t   make_tree (type, const0_rtx)));\n \n       emit_insn (gen_cmpmem_short (op0, op1, GEN_INT (255)));\n       temp = gen_rtx_NE (VOIDmode, gen_rtx_REG (CCSmode, 33), const0_rtx);\n@@ -3175,7 +3166,10 @@ s390_expand_cmpmem (rtx target, rtx op0, rtx op1, rtx len)\n       if (temp != blocks)\n         emit_move_insn (blocks, temp);\n \n+      emit_cmp_and_jump_insns (blocks, const0_rtx,\n+\t\t\t       EQ, NULL_RTX, mode, 1, loop_end_label);\n       expand_end_loop ();\n+      emit_label (loop_end_label);\n \n       emit_insn (gen_cmpmem_short (op0, op1,\n \t\t\t\t   convert_to_mode (Pmode, count, 1)));"}, {"sha": "30526c2e69455cf41c4f6bf96973715ad1a6af7a", "filename": "gcc/config/sh/sh.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fsh%2Fsh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fsh%2Fsh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsh.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -4704,7 +4704,7 @@ output_stack_adjust (int size, rtx reg, int epilogue_p,\n \t\t  for (i = FIRST_PARM_REG;\n \t\t       i < FIRST_PARM_REG + NPARM_REGS (SImode); i++)\n \t\t    CLEAR_HARD_REG_BIT (temps, i);\n-\t\t  if (current_function_needs_context)\n+\t\t  if (cfun->static_chain_decl != NULL)\n \t\t    CLEAR_HARD_REG_BIT (temps, STATIC_CHAIN_REGNUM);\n \t\t}\n \t      temp = scavenge_reg (&temps);\n@@ -5161,7 +5161,7 @@ sh5_schedule_saves (HARD_REG_SET *live_regs_mask, save_schedule *schedule,\n       if (call_used_regs[i] && ! fixed_regs[i] && i != PR_MEDIA_REG\n \t  && ! FUNCTION_ARG_REGNO_P (i)\n \t  && i != FIRST_RET_REG\n-\t  && ! (current_function_needs_context && i == STATIC_CHAIN_REGNUM)\n+\t  && ! (cfun->static_chain_decl != NULL && i == STATIC_CHAIN_REGNUM)\n \t  && ! (current_function_calls_eh_return\n \t\t&& (i == EH_RETURN_STACKADJ_REGNO\n \t\t    || ((unsigned) i <= EH_RETURN_DATA_REGNO (0)"}, {"sha": "278ca9a26b0d22b951b7248e7aceba143528ef7a", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1280,10 +1280,6 @@ input_operand (rtx op, enum machine_mode mode)\n   if (mode != VOIDmode && GET_MODE (op) != VOIDmode && mode != GET_MODE (op))\n     return 0;\n \n-  /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and result in 0/1.  */\n-  if (GET_CODE (op) == CONSTANT_P_RTX)\n-    return 1;\n-\n   /* Allow any one instruction integer constant, and all CONST_INT\n      variants when we are working in DImode and !arch64.  */\n   if (GET_MODE_CLASS (mode) == MODE_INT"}, {"sha": "f9e54cc2df982c32229552e5e45db59380d54022", "filename": "gcc/config/v850/v850.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fv850%2Fv850.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fv850%2Fv850.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fv850%2Fv850.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1136,7 +1136,6 @@ movsi_source_operand (rtx op, enum machine_mode mode)\n      must be done with HIGH & LO_SUM patterns.  */\n   if (CONSTANT_P (op)\n       && GET_CODE (op) != HIGH\n-      && GET_CODE (op) != CONSTANT_P_RTX\n       && !(GET_CODE (op) == CONST_INT\n            && (CONST_OK_FOR_J (INTVAL (op))\n                || CONST_OK_FOR_K (INTVAL (op))"}, {"sha": "89d8c9ddf3de98d56c2d7ba9867d930edf46110c", "filename": "gcc/config/xtensa/xtensa.c", "status": "modified", "additions": 1, "deletions": 7, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfig%2Fxtensa%2Fxtensa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fxtensa%2Fxtensa.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -627,11 +627,6 @@ move_operand (rtx op, enum machine_mode mode)\n \n     case HImode:\n     case QImode:\n-      /* Accept CONSTANT_P_RTX, since it will be gone by CSE1 and\n-\t result in 0/1.  */\n-      if (GET_CODE (op) == CONSTANT_P_RTX)\n-\treturn TRUE;\n-\n       if (GET_CODE (op) == CONST_INT && xtensa_simm12b (INTVAL (op)))\n \treturn TRUE;\n       break;\n@@ -1252,7 +1247,6 @@ int\n xtensa_emit_move_sequence (rtx *operands, enum machine_mode mode)\n {\n   if (CONSTANT_P (operands[1])\n-      && GET_CODE (operands[1]) != CONSTANT_P_RTX\n       && (GET_CODE (operands[1]) != CONST_INT\n \t  || !xtensa_simm12b (INTVAL (operands[1]))))\n     {\n@@ -2229,7 +2223,7 @@ long\n compute_frame_size (int size)\n {\n   /* Add space for the incoming static chain value.  */\n-  if (current_function_needs_context)\n+  if (cfun->static_chain_decl != NULL)\n     size += (1 * UNITS_PER_WORD);\n \n   xtensa_current_frame_size ="}, {"sha": "92d222c4276eab32b576a18e33cfb16fc629ccb6", "filename": "gcc/configure", "status": "modified", "additions": 67, "deletions": 2, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -309,7 +309,7 @@ ac_includes_default=\"\\\n # include <unistd.h>\n #endif\"\n \n-ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP strict1_warn warn_cflags WERROR nocommon_flag EGREP valgrind_path valgrind_path_defines valgrind_command coverage_flags enable_multilib enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep SET_MAKE AWK LN LN_S RANLIB ac_ct_RANLIB INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON stage1_cflags COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file FORBUILD PACKAGE VERSION USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS CROSS ALL SYSTEM_HEADER_DIR inhibit_libc BUILD_PREFIX BUILD_PREFIX_1 CC_FOR_BUILD BUILD_CFLAGS STMP_FIXINC STMP_FIXPROTO collect2 libgcc_visibility GGC zlibdir zlibinc MAINT gcc_tooldir dollar slibdir objdir subdirs srcdir all_boot_languages all_compilers all_gtfiles all_gtfiles_files_langs all_gtfiles_files_files all_lang_makefrags all_lang_makefiles all_languages all_stagestuff build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines check_languages cc_set_by_configure quoted_cc_set_by_configure cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir libstdcxx_incdir gcc_version gcc_version_full gcc_version_trigger host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file stage_prefix_set_by_configure quoted_stage_prefix_set_by_configure symbolic_link thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines target_noncanonical c_target_objs cxx_target_objs target_cpu_default LIBOBJS LTLIBOBJS'\n+ac_subst_vars='SHELL PATH_SEPARATOR PACKAGE_NAME PACKAGE_TARNAME PACKAGE_VERSION PACKAGE_STRING PACKAGE_BUGREPORT exec_prefix prefix program_transform_name bindir sbindir libexecdir datadir sysconfdir sharedstatedir localstatedir libdir includedir oldincludedir infodir mandir build_alias host_alias target_alias DEFS ECHO_C ECHO_N ECHO_T LIBS build build_cpu build_vendor build_os host host_cpu host_vendor host_os target target_cpu target_vendor target_os build_subdir host_subdir target_subdir GENINSRC CC CFLAGS LDFLAGS CPPFLAGS ac_ct_CC EXEEXT OBJEXT NO_MINUS_C_MINUS_O OUTPUT_OPTION CPP strict1_warn warn_cflags WERROR nocommon_flag EGREP valgrind_path valgrind_path_defines valgrind_command coverage_flags TREEBROWSER enable_multilib enable_shared TARGET_SYSTEM_ROOT TARGET_SYSTEM_ROOT_DEFINE CROSS_SYSTEM_HEADER_DIR onestep SET_MAKE AWK LN LN_S RANLIB ac_ct_RANLIB INSTALL INSTALL_PROGRAM INSTALL_DATA make_compare_target have_mktemp_command MAKEINFO BUILD_INFO GENERATED_MANPAGES FLEX BISON stage1_cflags COLLECT2_LIBS GNAT_LIBEXC LDEXP_LIB TARGET_GETGROUPS_T LIBICONV LIBICONV_DEP manext objext gthread_flags extra_modes_file FORBUILD PACKAGE VERSION USE_NLS LIBINTL LIBINTL_DEP INCINTL XGETTEXT GMSGFMT POSUB CATALOGS CROSS ALL SYSTEM_HEADER_DIR inhibit_libc BUILD_PREFIX BUILD_PREFIX_1 CC_FOR_BUILD BUILD_CFLAGS STMP_FIXINC STMP_FIXPROTO collect2 libgcc_visibility GGC zlibdir zlibinc MAINT ANDER BANSHEEINC BANSHEELIB gcc_tooldir dollar slibdir objdir subdirs srcdir all_boot_languages all_compilers all_gtfiles all_gtfiles_files_langs all_gtfiles_files_files all_lang_makefrags all_lang_makefiles all_languages all_stagestuff build_exeext build_install_headers_dir build_xm_file_list build_xm_include_list build_xm_defines check_languages cc_set_by_configure quoted_cc_set_by_configure cpp_install_dir xmake_file tmake_file extra_gcc_objs extra_headers_list extra_objs extra_parts extra_passes extra_programs float_h_file gcc_config_arguments gcc_gxx_include_dir libstdcxx_incdir gcc_version gcc_version_full gcc_version_trigger host_exeext host_xm_file_list host_xm_include_list host_xm_defines out_host_hook_obj install lang_opt_files lang_specs_files lang_tree_files local_prefix md_file objc_boehm_gc out_file out_object_file stage_prefix_set_by_configure quoted_stage_prefix_set_by_configure symbolic_link thread_file tm_file_list tm_include_list tm_defines tm_p_file_list tm_p_include_list xm_file_list xm_include_list xm_defines target_noncanonical c_target_objs cxx_target_objs target_cpu_default GMPLIBS GMPINC LIBOBJS LTLIBOBJS'\n ac_subst_files='language_hooks'\n \n # Initialize some variables set by options.\n@@ -770,6 +770,14 @@ ac_env_CPP_set=${CPP+set}\n ac_env_CPP_value=$CPP\n ac_cv_env_CPP_set=${CPP+set}\n ac_cv_env_CPP_value=$CPP\n+ac_env_GMPLIBS_set=${GMPLIBS+set}\n+ac_env_GMPLIBS_value=$GMPLIBS\n+ac_cv_env_GMPLIBS_set=${GMPLIBS+set}\n+ac_cv_env_GMPLIBS_value=$GMPLIBS\n+ac_env_GMPINC_set=${GMPINC+set}\n+ac_env_GMPINC_value=$GMPINC\n+ac_cv_env_GMPINC_set=${GMPINC+set}\n+ac_cv_env_GMPINC_value=$GMPINC\n \n #\n # Report the --help message.\n@@ -868,6 +876,7 @@ Optional Features:\n \t\t\t  optimization. Values are opt, noopt,\n \t\t\t  default is noopt\n   --enable-gather-detailed-mem-stats         enable detailed memory allocation stats gathering\n+  --enable-tree-browser   enable the tree browsing routines for debugging\n   --enable-multilib       enable library support for multiple ABIs\n   --enable-__cxa_atexit   enable __cxa_atexit for C++\n   --enable-threads        enable thread usage for target GCC\n@@ -915,6 +924,7 @@ Optional Packages:\n   --with-gc={page,zone}   choose the garbage collection mechanism to use\n                           with the compiler\n   --with-system-zlib      use installed libz\n+  --with-libbanshee\t  enable libbanshee\n   --with-slibdir=DIR      shared libraries in DIR LIBDIR\n \n Some influential environment variables:\n@@ -925,6 +935,8 @@ Some influential environment variables:\n   CPPFLAGS    C/C++ preprocessor flags, e.g. -I<include dir> if you have\n               headers in a nonstandard directory <include dir>\n   CPP         C preprocessor\n+  GMPLIBS     How to link GMP\n+  GMPINC      How to find GMP include files\n \n Use these variables to override the choices made by `configure' or to help\n it to find libraries and programs with nonstandard names/locations.\n@@ -4673,6 +4685,18 @@ _ACEOF\n \n fi\n \n+# Check whether --enable-tree-browser or --disable-tree-browser was given.\n+if test \"${enable_tree_browser+set}\" = set; then\n+  enableval=\"$enable_tree_browser\"\n+\n+else\n+  enable_tree_browser=no\n+fi;\n+if test x$enable_tree_browser = xyes ; then\n+  TREEBROWSER=tree-browser.o\n+fi\n+\n+\n # -------------------------------\n # Miscenalleous configure options\n # -------------------------------\n@@ -5283,7 +5307,7 @@ if test \"${gcc_cv_prog_makeinfo_modern+set}\" = set; then\n else\n     ac_prog_version=`$MAKEINFO --version 2>&1 |\n                    sed -n 's/^.*GNU texinfo.* \\([0-9][0-9.]*\\).*$/\\1/p'`\n-  echo \"configure:5286: version of makeinfo is $ac_prog_version\" >&5\n+  echo \"configure:5310: version of makeinfo is $ac_prog_version\" >&5\n   case $ac_prog_version in\n     '')     gcc_cv_prog_makeinfo_modern=no;;\n     4.[2-9]*)\n@@ -12131,6 +12155,38 @@ else\n   MAINT='#'\n fi\n \n+echo \"$as_me:$LINENO: checking whether to use libbanshee for points-to alias analysis\" >&5\n+echo $ECHO_N \"checking whether to use libbanshee for points-to alias analysis... $ECHO_C\" >&6\n+\n+# Check whether --with-libbanshee or --without-libbanshee was given.\n+if test \"${with_libbanshee+set}\" = set; then\n+  withval=\"$with_libbanshee\"\n+  libbanshee=\"$with_libbanshee\"\n+else\n+  libbanshee=no\n+fi;\n+\n+if test x\"$libbanshee\" = xyes; then\n+\tBANSHEELIB=\"../libbanshee/points-to/libandersen.a ../libbanshee/engine/libbansheeengine.a ../libbanshee/libcompat/libbansheecompat.a \"\n+\tBANSHEEINC=\"-I\\$(srcdir)/../libbanshee/libcompat -I\\$(srcdir)/../libbanshee -I\\$(srcdir)/../libbanshee/points-to\"\n+\tANDER=\"tree-alias-ander.o\"\n+\n+cat >>confdefs.h <<\\_ACEOF\n+#define HAVE_BANSHEE 1\n+_ACEOF\n+\n+else\n+\tBANSHEELIB=\"\"\n+\tBANSHEEINC=\"\"\n+\tANDER=\"\"\n+fi\n+echo \"$as_me:$LINENO: result: $with_libbanshee\" >&5\n+echo \"${ECHO_T}$with_libbanshee\" >&6\n+\n+\n+\n+\n+\n # --------------\n # Language hooks\n # --------------\n@@ -12430,6 +12486,9 @@ else\n   fi\n fi\n \n+\n+\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n \n@@ -13099,6 +13158,7 @@ s,@valgrind_path@,$valgrind_path,;t t\n s,@valgrind_path_defines@,$valgrind_path_defines,;t t\n s,@valgrind_command@,$valgrind_command,;t t\n s,@coverage_flags@,$coverage_flags,;t t\n+s,@TREEBROWSER@,$TREEBROWSER,;t t\n s,@enable_multilib@,$enable_multilib,;t t\n s,@enable_shared@,$enable_shared,;t t\n s,@TARGET_SYSTEM_ROOT@,$TARGET_SYSTEM_ROOT,;t t\n@@ -13159,6 +13219,9 @@ s,@GGC@,$GGC,;t t\n s,@zlibdir@,$zlibdir,;t t\n s,@zlibinc@,$zlibinc,;t t\n s,@MAINT@,$MAINT,;t t\n+s,@ANDER@,$ANDER,;t t\n+s,@BANSHEEINC@,$BANSHEEINC,;t t\n+s,@BANSHEELIB@,$BANSHEELIB,;t t\n s,@gcc_tooldir@,$gcc_tooldir,;t t\n s,@dollar@,$dollar,;t t\n s,@slibdir@,$slibdir,;t t\n@@ -13228,6 +13291,8 @@ s,@target_noncanonical@,$target_noncanonical,;t t\n s,@c_target_objs@,$c_target_objs,;t t\n s,@cxx_target_objs@,$cxx_target_objs,;t t\n s,@target_cpu_default@,$target_cpu_default,;t t\n+s,@GMPLIBS@,$GMPLIBS,;t t\n+s,@GMPINC@,$GMPINC,;t t\n s,@LIBOBJS@,$LIBOBJS,;t t\n s,@LTLIBOBJS@,$LTLIBOBJS,;t t\n /@language_hooks@/r $language_hooks"}, {"sha": "33a9f0bc0a0a56b82496ef94aa41142126d281ee", "filename": "gcc/configure.ac", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfigure.ac?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -544,6 +544,14 @@ if test x$enable_gather_detailed_mem_stats = xyes ; then\n         [Define to enable detailed memory allocation stats gathering.])\n fi\n \n+AC_ARG_ENABLE(tree-browser,\n+[  --enable-tree-browser   enable the tree browsing routines for debugging], [],\n+[enable_tree_browser=no])\n+if test x$enable_tree_browser = xyes ; then\n+  TREEBROWSER=tree-browser.o\n+fi\n+AC_SUBST(TREEBROWSER)\n+\n # -------------------------------\n # Miscenalleous configure options\n # -------------------------------\n@@ -2847,6 +2855,28 @@ else\n fi\n AC_SUBST(MAINT)dnl\n \n+AC_MSG_CHECKING([whether to use libbanshee for points-to alias analysis])\n+AC_ARG_WITH(libbanshee,\n+[  --with-libbanshee\t  enable libbanshee],\n+libbanshee=\"$with_libbanshee\",\n+libbanshee=no)\n+\n+if test x\"$libbanshee\" = xyes; then\n+\tBANSHEELIB=\"../libbanshee/points-to/libandersen.a ../libbanshee/engine/libbansheeengine.a ../libbanshee/libcompat/libbansheecompat.a \"\n+\tBANSHEEINC=\"-I\\$(srcdir)/../libbanshee/libcompat -I\\$(srcdir)/../libbanshee -I\\$(srcdir)/../libbanshee/points-to\"\n+\tANDER=\"tree-alias-ander.o\"\n+\tAC_DEFINE(HAVE_BANSHEE, 1, [Define if BANSHEE is available])\n+else\n+\tBANSHEELIB=\"\"\n+\tBANSHEEINC=\"\"\n+\tANDER=\"\"\n+fi\n+AC_MSG_RESULT($with_libbanshee)\n+\n+AC_SUBST(ANDER)\n+AC_SUBST(BANSHEEINC)\n+AC_SUBST(BANSHEELIB)\n+\n # --------------\n # Language hooks\n # --------------\n@@ -3143,6 +3173,9 @@ else\n   fi\n fi\n \n+AC_ARG_VAR(GMPLIBS,[How to link GMP])\n+AC_ARG_VAR(GMPINC,[How to find GMP include files])\n+\n # Configure the subdirectories\n # AC_CONFIG_SUBDIRS($subdirs)\n "}, {"sha": "8e952831acb123d5d3f80923d5c28c8777cc5d49", "filename": "gcc/coverage.c", "status": "modified", "additions": 49, "deletions": 12, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -96,7 +96,11 @@ static char *da_file_name;\n /* Hash table of count data.  */\n static htab_t counts_hash = NULL;\n \n-/* The names of the counter tables.  */\n+/* Trees representing the counter table arrays.  */\n+static GTY(()) tree tree_ctr_tables[GCOV_COUNTERS];\n+\n+/* The names of the counter tables.  Not used if we're\n+   generating counters at tree level.  */\n static GTY(()) rtx ctr_labels[GCOV_COUNTERS];\n \n /* The names of merge functions for counters.  */\n@@ -369,14 +373,22 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n   if (!num)\n     return 1;\n \n-  if (!ctr_labels[counter])\n+  if (!tree_ctr_tables[counter])\n     {\n       /* Generate and save a copy of this so it can be shared.  */\n+      /* We don't know the size yet; make it big enough that nobody\n+\t will make any clever transformation on it.  */\n       char buf[20];\n-\n+      tree domain_tree\n+        = build_index_type (build_int_2 (1000, 0)); /* replaced later */\n+      tree gcov_type_array_type\n+        = build_array_type (GCOV_TYPE_NODE, domain_tree);\n+      tree_ctr_tables[counter]\n+        = build_decl (VAR_DECL, NULL_TREE, gcov_type_array_type);\n+      TREE_STATIC (tree_ctr_tables[counter]) = 1;\n       ASM_GENERATE_INTERNAL_LABEL (buf, \"LPBX\", counter + 1);\n-      ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode, ggc_strdup (buf));\n-      SYMBOL_REF_FLAGS (ctr_labels[counter]) = SYMBOL_FLAG_LOCAL;\n+      DECL_NAME (tree_ctr_tables[counter]) = get_identifier (buf);\n+      DECL_ALIGN (tree_ctr_tables[counter]) = TYPE_ALIGN (GCOV_TYPE_NODE);\n     }\n   fn_b_ctrs[counter] = fn_n_ctrs[counter];\n   fn_n_ctrs[counter] += num;\n@@ -387,7 +399,7 @@ coverage_counter_alloc (unsigned counter, unsigned num)\n /* Generate a MEM rtl to access COUNTER NO.  */\n \n rtx\n-coverage_counter_ref (unsigned counter, unsigned no)\n+rtl_coverage_counter_ref (unsigned counter, unsigned no)\n {\n   unsigned gcov_size = tree_low_cst (TYPE_SIZE (GCOV_TYPE_NODE), 1);\n   enum machine_mode mode = mode_for_size (gcov_size, MODE_INT, 0);\n@@ -396,13 +408,37 @@ coverage_counter_ref (unsigned counter, unsigned no)\n   if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n     abort ();\n   no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n+  if (!ctr_labels[counter])\n+      {\n+        ctr_labels[counter] = gen_rtx_SYMBOL_REF (Pmode,\n+\t\t\t       ggc_strdup (IDENTIFIER_POINTER (DECL_NAME\n+\t\t\t       (tree_ctr_tables[counter]))));\n+        SYMBOL_REF_FLAGS (ctr_labels[counter]) = SYMBOL_FLAG_LOCAL;\n+      }\n   ref = plus_constant (ctr_labels[counter], gcov_size / BITS_PER_UNIT * no);\n   ref = gen_rtx_MEM (mode, ref);\n   set_mem_alias_set (ref, new_alias_set ());\n   MEM_NOTRAP_P (ref) = 1;\n \n   return ref;\n }\n+\n+/* Generate a tree to access COUNTER NO.  */\n+\n+tree\n+tree_coverage_counter_ref (unsigned counter, unsigned no)\n+{\n+  tree t;\n+\n+  if (no >= fn_n_ctrs[counter] - fn_b_ctrs[counter])\n+    abort ();\n+  no += prg_n_ctrs[counter] + fn_b_ctrs[counter];\n+\n+  /* \"no\" here is an array index, scaled to bytes later.  */\n+  t = build (ARRAY_REF, GCOV_TYPE_NODE, tree_ctr_tables[counter],\n+\t     build_int_2 (no, 0));\n+  return t;\n+}\n \f\n /* Generate a checksum for a string.  CHKSUM is the current\n    checksum.  */\n@@ -684,19 +720,20 @@ build_ctr_info_value (unsigned int counter, tree type)\n \n   if (prg_n_ctrs[counter])\n     {\n-      tree array_type, array;\n+      tree array_type;\n \n       array_type = build_index_type (build_int_2 (prg_n_ctrs[counter] - 1, 0));\n       array_type = build_array_type (TREE_TYPE (TREE_TYPE (fields)),\n \t\t\t\t     array_type);\n \n-      array = build_decl (VAR_DECL, NULL_TREE, array_type);\n-      TREE_STATIC (array) = 1;\n-      DECL_NAME (array) = get_identifier (XSTR (ctr_labels[counter], 0));\n-      assemble_variable (array, 0, 0, 0);\n+      TREE_TYPE (tree_ctr_tables[counter]) = array_type;\n+      DECL_SIZE (tree_ctr_tables[counter]) = TYPE_SIZE (array_type);\n+      DECL_SIZE_UNIT (tree_ctr_tables[counter]) = TYPE_SIZE_UNIT (array_type);\n+      assemble_variable (tree_ctr_tables[counter], 0, 0, 0);\n \n       value = tree_cons (fields,\n-\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields), array),\n+\t\t\t build1 (ADDR_EXPR, TREE_TYPE (fields), \n+\t\t\t\t\t    tree_ctr_tables[counter]),\n \t\t\t value);\n     }\n   else"}, {"sha": "ec8134f1fe67967d708c14c2c5902b606754b5fc", "filename": "gcc/coverage.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcoverage.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcoverage.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -38,7 +38,9 @@ extern int coverage_begin_output (void);\n /* Allocate some counters. Repeatable per function.  */\n extern int coverage_counter_alloc (unsigned /*counter*/, unsigned/*num*/);\n /* Use a counter from the most recent allocation.  */\n-extern rtx coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n+extern rtx rtl_coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n+/* Use a counter from the most recent allocation.  */\n+extern tree tree_coverage_counter_ref (unsigned /*counter*/, unsigned/*num*/);\n \n /* Get all the counters for the current function.  */\n extern gcov_type *get_coverage_counts (unsigned /*counter*/,"}, {"sha": "9d990ee36429e4d815e9dee2b7a84c1514cc02a7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1,3 +1,16 @@\n+2004-05-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\tMerge from tree-ssa-20020619-branch.  See\n+\tChangeLog.tree-ssa for details.\n+\n+\t* Make-lang.in, call.c, class.c, cp-lang.c, cp-tree.def,\n+\tcp-tree.h, cvt.c, decl.c, decl2.c, error.c, except.c,\n+\texpr.c, init.c, name-lookup.h, optimize.c, parser.c,\n+\tpt.c, rtti.c, semantics.c, tree.c, typeck.c, typeck2.c:\n+\tMerged.\n+\t* cp-mudflap.c: New file.\n+\t* cp-simplify.c:: New file.\n+\n 2004-05-03  Giovanni Bajo  <giovannibajo@gcc.gnu.org>\n \n \tPR c++/14389"}, {"sha": "a52dea6745084ee74a25f5795a73e80b26165d70", "filename": "gcc/cp/ChangeLog.tree-ssa", "status": "added", "additions": 566, "deletions": 0, "changes": 566, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,566 @@\n+2004-04-19  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (check_handlers_1): Use locus stored in master for warning.\n+\t* tree.c (cp_walk_subtrees): Save and restore input_location.\n+\n+2004-04-12  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_RTL_EXPAND_START): Remove.\n+\t(LANG_HOOKS_RTL_EXPAND_STMT): Remove.\n+\t* semantics.c (cxx_expand_function_start): Remove.\n+\n+2004-04-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* except.c (check_handlers_1): Use EXPR_LOCUS instead of STMT_LINENO.\n+\t* semantics.c (finalize_nrv_r): Likewise.\n+\t* tree.c (cp_walk_subtrees): Likewise.\n+\t* parser.c (cp_parser_statement): Save and restore entire locus;\n+\tset EXPR_LOCUS.\n+\t* pt.c (tsubst_expr): Don't special-case LABEL_STMT.\n+\n+2004-04-01  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* name-lookup.c (innermost_nonclass_level): Check for\n+\terror_mark_node.\n+\n+2004-03-25  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* parser.c (cp_parser_class_specifier): Initialize\n+\tvariable 'attributes'.\n+\n+2004-03-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-lang.c (cxx_types_compatible_p): Use\n+\tsame_type_ignoring_top_level_qualifiers_p.\n+\n+2004-03-16  Dale Johannesen  <dalej@apple.com>\n+\n+\t* cp-lang.c (cxx_types_compatible_p): New.\n+\tLANG_HOOKS_TYPES_COMPATIBLE_P: New.\n+\n+2004-03-10  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/14452\n+\t* tree.c (stabilize_init): Return whether or not it worked.\n+\t* init.c (build_new_1): If not, use a sentry.\n+\t* cp-tree.h: Adjust prototype.\n+\n+2004-03-01  Jeff Law  <law@redhat.com>\n+\n+\t* init.c (build_vec_delete_1): Convert 2nd argument to NE_EXPR to\n+\tthe proper type.\n+ \n+2004-02-24  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/13944\n+\t* except.c (do_free_exception): Remove #if 0 wrapper.\n+\t(build_throw): Use it if we elide a copy into the exception object.\n+\n+\t* tree.c (stabilize_call): Fix thinko.\n+\n+2004-02-19  Steven Bosscher  <stevenb@suse.de>\n+\n+\t* decl.c (poplevel): Don't output nested inline functions.\n+\n+2004-02-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* call.c (build_call, build_over_call, build_new_method_call): Add\n+\tstatic chain operand to call_expr.\n+\t* decl.c (build_offset_ref_call_from_tree): Likewise.\n+\t* parser.c (cp_parser_postfix_expression): Likewise.\n+\t* semantics.c (finish_call_expr): Likewise.\n+\t* cp-lang.c (cp_expand_decl): Don't declare_nonlocal_label.\n+\n+2004-02-09  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P): New.\n+\t* cp-tree.h (cp_missing_noreturn_ok_p): Declare.\n+\t* decl.c (cp_missing_noreturn_ok_p): Export.\n+\t(cxx_init_decl_processing): Don't set lang_missing_noreturn_ok_p.\n+\n+2004-02-06  Andrew Pinski  <pinskia@physics.uc.edu>\n+\n+\tPR c/13863\n+\t* cp-lang.c (LANG_HOOKS_DECL_UNINIT): Remove.\n+\n+2004-02-03  Richard Henderson  <rth@redhat.com>\n+\n+\tPR middle-end/13325\n+\t* call.c, cvt.c, init.c, typeck.c: Use TREE_NO_WARNING instead\n+\tof TREE_NO_UNUSED_WARNING.\n+\t* cvt.c (convert_to_void): Also use it for \"has no effect\" warning.\n+\t\n+2004-01-30  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_flush_calls): Mark static ctor as TREE_USED.\n+\n+2004-01-12  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-lang.c (ok_to_generate_alias_set_for_type): Remove.\n+\t(cxx_get_alias_set): Allow all types.\n+\n+2004-01-08  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_flush_calls): mf_mark synthetic function.\n+\n+2004-01-04  Richard Henderson  <rth@redhat.com>\n+\n+\t* call.c (build_over_call): Don't create a save_expr of an\n+\taggregate, but rather its address.\n+\n+2004-01-01  Richard Henderson  <rth@redhat.com>\n+\n+\t* expr.c (cxx_expand_expr): Don't handle THROW_EXPR, or\n+\tMUST_NOT_THROW_EXPR.\n+\t* semantics.c (genrtl_try_block, genrtl_eh_spec_block,\n+\tgenrtl_handler, cp_expand_stmt): Remove.\n+\t(init_cp_semantics): Don't set lang_expand_stmt.\n+\n+2003-12-31  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_register_call): Remove.\n+\n+2003-12-18  Jason Merrill  <jason@redhat.com>\n+\n+\tPR c++/12453\n+\t* cp-simplify.c (cp_gimplify_init_expr): Look inside STMT_EXPRs\n+\tand COMPOUND_EXPRs to find an AGGR_INIT_EXPR.\n+\n+2003-12-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR middle-end/12920\n+\t* decl.c (grokdeclarator): Immediately layout an\n+\tARRAY_TYPE used in a pointer-to-array declarator.\n+\n+2003-12-16  Jan Hubicka  <jh@suse.cz>\n+\n+\tRevert until initializers are made language independent:\n+\t* cp-lang.c (LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Kill.\n+\t* cp-tree.h (cxx_callgraph_analyze_expr): Kill.\n+\t* decl2.c (cxx_callgraph_analyze_expr): Kill.\n+\t\n+2003-12-14  Jan Hubicka  <jh@suse.cz>\n+\n+\t* cp-lang.c (LANG_HOOKS_CALLGRAPH_ANALYZE_EXPR): Kill.\n+\t* cp-tree.h (cxx_callgraph_analyze_expr): Kill.\n+\t* decl2.c (cxx_callgraph_analyze_expr): Kill.\n+\n+2003-11-24  Richard Henderson  <rth@redhat.com>\n+\n+\t* Make-lang.in (tree.o, typeck.o): Remove -Wno-error.\n+\n+2003-11-20  Richard Henderson  <rth@redhat.com>\n+\n+\t* call.c (build_java_interface_fn_ref): Use build_address+convert.\n+\t* except.c (build_eh_type_type): Likewise.\n+\t* class.c (build_base_path): Use convert+build_indirect_ref.\n+\t* init.c (expand_virtual_init): Likewise.\n+\t* rtti.c (get_tinfo_decl_dynamic): Use convert.\n+\n+2003-11-20  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_flush_calls): Adapt to direct expansion of\n+\tsynthetic function, bypassing callgraph code.\n+\t* cp-decl2.c (finish_file): Call mudflap after callgraph-based\n+\texpansion.\n+\n+2003-11-17  Jason Merrill  <jason@redhat.com>\n+\n+\t* init.c (build_new_1): Preevaluate initializer.  Simplify EH code.\n+\t(build_init): Call a constructor rather than call build_aggr_init\n+\tfor classes.\n+\t* except.c (stabilize_throw_expr): Remove.\n+\t(build_throw): Use stabilize_init instead of stabilize_throw_expr.\n+\t* tree.c (stabilize_call, stabilize_init): New fns.\n+\t* call.c (build_over_call): A constructor no longer returns the\n+\taddress of the object.\n+\n+2003-11-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* typeck.c (pointer_diff): Remove unused variable.\n+\n+2003-11-16  Jason Merrill  <jason@redhat.com>\n+\n+\tPR optimization/11269\n+\t* semantics.c (finalize_nrv_r): Rename from nullify_returns_r.\n+\tAlso replace uses of the nrv with our RESULT_DECL.\n+\t(cxx_expand_function_start): Don't mess with the nrv.\n+\t(finalize_nrv): New fn.\n+\t* cp-tree.h: Declare it.\n+\t* decl.c (finish_function): Call it.\n+\t* tree.c (cp_copy_res_decl_for_inlining): Don't mess with the nrv.\n+\n+2003-11-10  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-simplify.c (gimplify_must_not_throw_expr): Replace add_tree\n+\twith append_to_statement_list.\n+\n+2003-10-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c (pop_switch): Call c_do_switch_warnings.\n+\n+2003-10-23  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-simplify.c (cp_gimplify_expr): Return gimplify_status.\n+\n+2003-10-16  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c (finish_function): Don't check flag_disable_gimple.\n+\n+2003-10-14  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c (finish_function): Always gimplify; call c_warn_unused_result.\n+\n+2003-10-13  Richard Henderson  <rth@redhat.com>\n+\n+\t* pt.c (push_tinst_level): Use annotate_with_locus.\n+\n+2003-10-12  Richard Henderson  <rth@redhat.com>\n+\n+\t* call.c (call_builtin_trap): Use implicit_built_in_decls.\n+\t* class.c (build_base_path): Set TREE_INVARIANT.\n+\t(build_vtbl_ref_1, build_vtbl_initializer): Likewise.\n+\t* decl.c (build_enumerator): Likewise.\n+\t* init.c (build_zero_init): Likewise.\n+\t* pt.c (push_inline_template_parms_recursive): Likewise.\n+\t(build_template_parm_index, reduce_template_parm_level): Likewise.\n+\t(process_template_parm): Likewise.\n+\t* rtti.c (tinfo_base_init, generic_initializer): Likewise.\n+\t(ptr_initializer, ptm_initializer, class_initializer): Likewise.\n+\t* typeck.c (build_ptrmemfunc1): Likewise.\n+\t* typeck2.c (process_init_constructor): Likewise.\n+\n+\t* calls.c (dfs_accumulate_vtbl_inits): Rely on build to set\n+\tTREE_CONSTANT.\n+\t(build_vtbl_initializer): Likewise.\n+\t* init.c (build_vtbl_address): Likewise.\n+\t* rtti.c (tinfo_base_init): Likewise.\n+\t* tree.c (make_ptrmem_cst): Likewise.\n+\t* typeck.c (decay_conversion): Likewise.\n+\t(get_member_function_from_ptrfunc, build_binary_op): Likewise.\n+\t(pointer_diff, build_address, build_nop, build_unary_op): Likewise.\n+\n+2003-09-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c (finish_function): Set cfun->function_end_locus.\n+\n+2003-09-24  Jason Merrill  <jason@redhat.com>\n+\n+\t* class.c, decl.c, decl2.c, error.c, init.c, lex.c, method.c,\n+\tpt.c, semantics.c, tree.c: Revert from TREE_LOCUS to\n+\tDECL_SOURCE_LOCATION.\n+\n+2003-09-17  Richard Henderson  <rth@redhat.com>\n+\n+\t* decl.c (cxx_init_decl_processing): Don't using_eh_for_cleanups\n+\tif exceptions are disabled.\n+\n+2003-09-03  Richard Henderson  <rth@redhat.com>\n+\n+\t* cp-lang.c (LANG_HOOKS_RTL_EXPAND_STMT): Use expand_stmt_toplev.\n+\n+2003-09-03  Richard Henderson  <rth@redhat.com>\n+\n+        * decl.c (finish_function): Fix misapplied patch.  Don't\n+        free_after_parsing or free_after_compilation.  For real this time.\n+\n+2003-08-22  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (cp_gimplify_init_expr): Update use of predicates.\n+\n+2003-08-21  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (cp_gimplify_expr): Use simplify_aggr_init_expr.\n+\t(cp_gimplify_init_expr): Don't call it here.\n+\t(gimplify_aggr_init_expr): Remove.\n+\n+2003-08-19  Jason Merrill  <jason@redhat.com>\n+\n+\t* typeck.c (build_array_ref): Also build ARRAY_REFs from\n+\tINDIRECT_REFs of ARRAY_TYPE.\n+\n+\t* semantics.c (finish_id_expression): Unshare aliases.\n+\n+2003-08-12  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* optimize.c (optimize_function): Do not call dump_function.\n+\n+2003-08-08  Jason Merrill  <jason@redhat.com>\n+\n+\t* optimize.c (optimize_function): Restore support for\n+\t!keep_function_tree_in_gimple_form.\n+\n+2003-07-27  Andreas Jaeger  <aj@suse.de>\n+\n+\t* cp-lang.c: Convert K&R prototypes to ISO C90.\n+\t* cp-simplify.c: Likewise.\n+\t* cp-mudflap.c: Likewise.\n+\n+2003-06-13  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* semantics.c (expand_body): Call mudflap_c_function just before\n+\trtl expansion of function body; don't interfere with inlining.\n+\t* optimize.c (optimize_function): Remove mudflap call.\n+\n+2003-06-13  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* cp-lang.c, cp-simplify.c, cp-tree.h, decl.c, optimize.c,\n+\tsemantics.c, tree.c: Rename SIMPLE to GIMPLE everywhere.\n+\n+2003-06-05  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_register_call): Give the synthetic decl\n+\tundefined (not zero) size.\n+\n+2003-06-05  Frank Ch. Eigler  <fche@redhat.com>\n+\n+        * cp-mudflap.c (mx_flag): Remove.  Update callers to use mf_mark.\n+\n+2003-05-24  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Make-lang.in (optimize.o): Add dependency on tree-simple.h\n+\t* decl.c (grokdeclarator): Don't abort when the declarator is\n+\tERROR_MARK_NODE.\n+\t* optimize.c (optimize_function): Unshare all trees after\n+\toptimizing inline calls.\n+\n+2003-05-12  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* class.c (dump_array): Call CONSTRUCTOR_ELTS to access\n+\tthe operand of a CONSTRUCTOR node.\n+\n+2003-05-07  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* decl.c (grokdeclarator): Fix thinko in handling\n+\tERROR_MARK declarators.\n+\n+2003-05-07  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* decl.c (grokdeclarator): Handle ERROR_MARK declarators.\n+\n+2003-05-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* semantics.c (expand_body): Call expand_stmt when\n+\t-fdisable-simple is given.\n+\n+2003-04-21  Jeff Law  <law@redhat.com>\n+\n+\t* optimize.c (optimize_function_tree): Do run the tree-ssa\n+\toptimizers.\n+\n+2003-04-16  Jeff Law  <law@redhat.com>\n+\n+\t* optimize.c (optimize_function): No longer check\n+\tflag_disable_simple.\n+\n+2003-04-15  Jeff Law  <law@redhat.com>\n+\n+\t* pt.c (instantiate_decl): If CFUN is null, then we will\n+\tneed to push to the toplevel.\n+\n+\t* Makefile.in (decl.o): Depends on tree-flow.h.\n+\t* decl.c (finish_function): Call set_has_hidden_use when\n+\tnullifying returns for named value return optimization.\n+\n+2003-04-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (cp_simplify_expr) <case EMPTY_CLASS_EXPR>:\n+\tChange type of constant to RECORD_TYPE.\n+\n+2003-03-10  Jeff Law  <law@redhat.com>\n+\n+\t* optimize.c (optimize_function): Avoid unnecessary\n+\tsimplification of the function tree.\n+\n+2003-03-02  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* decl.c: Replace DECL_SOURCE_LOCATION with TREE_LOCUS\n+\teverywhere.\n+\n+2003-02-28  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* decl2.c (finish_file): Adjust timing of mudflap_finish_file call\n+\tto account for unit-at-a-time compilation.\n+\n+2003-02-07  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (cp_simplify_expr): Handle BASELINK.\n+\n+\t* parser.c (cp_parser_primary_expression): Unshare a COMPONENT_REF\n+\tfrom an ALIAS_DECL.\n+\n+2003-02-05  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (genericize_try_block): Do genericize catch blocks.\n+\n+2003-02-03  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* parser.c (cp_parser_asm_definition): Call finish_asm_stmt with\n+\t'volatile_p' directly.\n+\t* typeck.c (build_binary_op): Initialize variable 'type'.\n+\t* Make-lang.in (cp/tree.o-warn): Add -Wno-error.\n+\n+2003-01-29  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\t* cp-mudflap.c (mflang_register_call): Adapt to mf-runtime.h API\n+\tchange.\n+\n+2003-01-15  Jeff Law <law@redhat.com>\n+\n+\t* class.c: Use TREE_FILENAME and TREE_LINENO to extract\n+\tfile/line information from tree nodes.  Remove EXPR_WITH_FILE_LOCATION\n+\tnodes.  Use annotate_with_file_line to attach file/line information\n+\tto tree nodes.  Use TREE_LOCUS to copy file/line information\n+\tfrom one node to another.\n+\t* decl2.c, error.c, init.c, lex.c, method.c: Likewise.\n+\t* optimize.c: Likewise.\n+\t* cp-tree.def (TINST_LEVEL): New tree node.\n+\t* cp-tree.h (TINST_DECL): Update now that we no longer use\n+\tEXPR_WITH_FILE_LOCATION to represent the TINST_DECL information.\n+\t(TINST_FILE, TINST_LINE): Kill.\n+\t* decl.c: Use TREE_FILENAME and TREE_LINENO to extract\n+\tfile/line information from tree nodes.  Use annotate_witH_file_line\n+\tto add file/line information to tree nodes.  Use TREE_LOCUS\n+\tto copy file/line information from one node to another.\n+\t(duplicate_decls): Make sure to copy TREE_LOCUS information\n+\tfrom the old decl to the new decl.\n+\t(finish_function): Save and restore file/line information\n+\taround genericizing the function tree.\n+\t* pt.c (lookup_template_class): Use TREE_LOCUS to copy file/line\n+\tinformation from one node to another.\n+\t(push_tinst_level): Generate a TINST_LEVEL node rather than\n+\tusing EXPR_WITH_FILE_LOCATION nodes.  Use annotate_with_file_line\n+\tto annotate the new node with file/line information.\n+\t(pop_tinst_level): Use  TREE_LINENO and TREE_FILENAME to extract\n+\tfile/line information from nodes.\n+\t(tsubst_friend_function, instantiate_class_template): Likewise.\n+\t(tsubst_decl, instantiate_decl, tsubst_enum): Likewise.\n+\t* semantics.c: Use annotate_with_file_line to annotate tree\n+\tnodes with file/line information.  Use TREE_FILENAME and TREE_LINENO\n+\tto extract file/line information from tree nodes.\n+\t(expand_body): Restore file/line information slightly earlier.\n+\ttree.c (cp_walk_subtrees): Set lineno appropriately.\n+\t(cp_copy_res_decl_for_inlining): Use TREE_LOCUS to copy file/line\n+\tinformation from one node to another.\n+\n+2003-01-13  Frank Ch. Eigler  <fche@redhat.com>\n+\n+\tPrototype C++ mudflap support.\n+\t* Make-lang.in (CXX_OBJS): Add cp/cp-mudflap.o and dependencies.\n+\t* cp-mudflap.c: New file with C++ front-end mflang_* routines.\n+\t* decl2.c (finish_file): Divert to mudflap if appropriate.\n+\t* optimize.c (optimize_function): Ditto.\n+\n+2003-01-02  Jason Merrill  <jason@redhat.com>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Replace old-tree-inline.o with\n+\ttree-inline.o.\n+\n+\t* optimize.c (dump_function): Move to ../tree-dump.c.\n+\n+\t* cp-simplify.c (cp_simplify_expr): Handle PTRMEM_CST, INIT_EXPR,\n+\tMODIFY_EXPR and EMPTY_CLASS_EXPR.\n+\t(cp_simplify_stmt): Handle USING_STMT.\n+\t(cp_simplify_init_expr): New fn.\n+\t* cvt.c (build_up_reference): Don't push the decl.\n+\t* class.c (build_vtable_entry_ref, build_vtbl_ref_1): Unshare the\n+\tvtable address.\n+\t* init.c (build_vtbl_address): Likewise.\n+\t* cp-lang.c (LANG_HOOKS_UNSAVE_EXPR_NOW): Remove.\n+\t* decl.c (lookup_name_real): Unshare the expansion of an ALIAS_DECL.\n+\t(finish_function): Don't genericize templates.\n+\t* parse.y (parse_asm_stmt): Fix prototype.\n+\t* semantics.c (expand_body): Don't expand if we saw errors.\n+\tDrop support for expanding non-GENERIC code.\n+\n+\t* cp-simplify.c (cp_simplify_stmt): Handle HANDLER and EH_SPEC_BLOCK.\n+\t(genericize_try_block): Always build a TRY_CATCH_EXPR.\n+\t(genericize_catch_block): New fn.\n+\t(genericize_eh_spec_block): New fn.\n+\t(cp_simplify_expr): Handle THROW_EXPR and MUST_NOT_THROW_EXPR.\n+\t(simplify_must_not_throw_expr): New fn.\n+\t* except.c (wrap_cleanups_r): Make the MUST_NOT_THROW_EXPR void.\n+\t(build_throw): Likewise.\n+\n+2002-12-14  Jason Merrill  <jason@redhat.com>\n+\n+\t* optimize.c (dump_function): Use pretty dumpers.\n+\t(optimize_function): Don't do .original dump here.\n+\n+2002-12-03  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* cp-simplify.c: Include coretypes.h and tm.h.\n+\n+2002-11-24  Jason Merrill  <jason@redhat.com>\n+\n+\tGimplify C++ cleanups.\n+\t* decl.c (finish_function): Call c_genericize.\n+\t* cp-simplify.c (cp_simplify_stmt): New fn.\n+\t(genericize_try_block): New fn.\n+\t(cp_simplify_expr): Move INIT_EXPR/TARGET_EXPR code\n+\tto ../gimplify.c.  Handle AGGR_INIT_EXPR.\n+\t(simplify_target_expr): Move to ../gimplify.c.\n+\t(maybe_fixup_loop_cond): Remove.\n+\t(simplify_aggr_init_expr): Split out from...\n+\t* semantics.c (simplify_aggr_init_exprs_r): ...here.\n+\t(expand_body): Don't simplify AGGR_INIT_EXPRs here\n+\tif we're gimplifying.  Handle expanding generic trees.\n+\t* tree.c (init_tree): Set lang_simplify_stmt.\n+\t* cp-tree.h: Declare the new fns.\n+\n+\t* optimize.c (optimize_function): Do pretty dumps.\n+\n+2002-10-04  Jason Merrill  <jason@redhat.com>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add gimplify.o.\n+\n+2002-09-24  Jason Merrill  <jason@redhat.com>\n+\n+\t* parse.y (parse_asm_stmt): New fn.\n+\t(simple_stmt): Use it.\n+\t* semantics.c (finish_asm_stmt): Change cv_qualifier parm to\n+\tvolatile_p.\n+\t* cp-tree.h: Adjust prototype.\n+\t* pt.c (tsubst_expr): Adjust call.\n+\n+2002-08-23  Diego Novillo  <dnovillo@redhat.com>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add tree-dchain.o\n+\n+2002-08-11  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (maybe_fixup_loop_cond): Move here.\n+\t(cp_simplify_expr): Call it.\n+\t(simplify_target_expr): Remove pre_p parm.\n+\n+2002-08-09  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c (cp_simplify_expr): New fn.\n+\t(simplify_target_expr): New fn.\n+\t(cp_simplify_function_tree): Remove.\n+\t* cp-lang.c (LANG_HOOKS_SIMPLIFY_FUNCTION_TREE): Don't define.\n+\t(LANG_HOOKS_SIMPLIFY_EXPR): Define.\n+\t* optimize.c (optimize_function): De-hook simplify_function_tree.\n+\t* cp-tree.h: Declare cp_simplify_expr.\n+\n+2002-07-17  Daniel Berlin  <dberlin@dberlin.org>\n+\n+\t* Make-lang.in (CXX_C_OBJS): Add tree-alias-ecr.c,\n+\ttree-alias-type.o, tree-alias-steen.o, disjoint-set.o.\n+\n+2002-06-21  Andreas Jaeger  <aj@suse.de>\n+\n+\t* Make-lang.in (cp-simplify.o): New.\n+\n+2002-06-18  Jason Merrill  <jason@redhat.com>\n+\n+\t* cp-simplify.c: New file.\n+\t* Make-lang.in: Add it.\n+\t* cp-tree.h: Declare cp_simplify_function_tree.\n+\t* cp-lang.c (LANG_HOOKS_SIMPLIFY_FUNCTION_TREE): Define.\n+\t* optimize.c (optimize_function): Call tree optimizers (but not yet).\n+\n+Local Variables:\n+mode: change-log\n+change-log-default-name: \"ChangeLog.tree-ssa\"\n+End:"}, {"sha": "bf4b0fe850f5e0f6ae0dc7add5e8239fc019cb83", "filename": "gcc/cp/Make-lang.in", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FMake-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -73,14 +73,16 @@ g++-cross$(exeext): g++$(exeext)\n # Shared with C front end:\n CXX_C_OBJS = attribs.o c-common.o c-format.o c-pragma.o c-semantics.o c-lex.o \\\n \tc-dump.o $(CXX_TARGET_OBJS) c-pretty-print.o c-opts.o c-pch.o \\\n-\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o\n+\tc-incpath.o cppdefault.o c-ppoutput.o c-cppbuiltin.o prefix.o \\\n+\tc-simplify.o tree-inline.o\n \n # Language-specific object files.\n CXX_OBJS = cp/call.o cp/decl.o cp/expr.o cp/pt.o cp/typeck2.o \\\n  cp/class.o cp/decl2.o cp/error.o cp/lex.o cp/parser.o cp/ptree.o cp/rtti.o \\\n  cp/typeck.o cp/cvt.o cp/except.o cp/friend.o cp/init.o cp/method.o \\\n  cp/search.o cp/semantics.o cp/tree.o cp/repo.o cp/dump.o cp/optimize.o \\\n- cp/mangle.o cp/cp-lang.o cp/name-lookup.o cp/cxx-pretty-print.o\n+ cp/mangle.o cp/cp-lang.o cp/name-lookup.o cp/cxx-pretty-print.o \\\n+ cp/cp-simplify.o tree-mudflap.o cp/cp-mudflap.o\n \n # Use strict warnings for this front end.\n cp-warn = $(STRICT_WARN) $(WERROR)\n@@ -221,7 +223,7 @@ cp/cp-lang.o: cp/cp-lang.c $(CXX_TREE_H) $(TM_H) toplev.h langhooks.h \\\n cp/decl.o: cp/decl.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h stack.h \\\n   output.h $(EXPR_H) except.h toplev.h $(HASHTAB_H) $(RTL_H) \\\n   cp/operators.def $(TM_P_H) tree-inline.h diagnostic.h c-pragma.h \\\n-  debug.h gt-cp-decl.h gtype-cp.h timevar.h\n+  debug.h gt-cp-decl.h gtype-cp.h timevar.h $(TREE_FLOW_H)\n cp/decl2.o: cp/decl2.c $(CXX_TREE_H) $(TM_H) flags.h cp/lex.h cp/decl.h $(EXPR_H) \\\n   output.h except.h toplev.h $(RTL_H) c-common.h gt-cp-decl2.h cgraph.h\n cp/typeck2.o: cp/typeck2.c $(CXX_TREE_H) $(TM_H) flags.h toplev.h output.h $(TM_P_H) \\\n@@ -257,12 +259,16 @@ cp/semantics.o: cp/semantics.c $(CXX_TREE_H) $(TM_H) cp/lex.h except.h toplev.h\n   tree-inline.h cgraph.h\n cp/dump.o: cp/dump.c $(CXX_TREE_H) $(TM_H) tree-dump.h\n cp/optimize.o: cp/optimize.c $(CXX_TREE_H) $(TM_H) rtl.h integrate.h insn-config.h \\\n-  input.h $(PARAMS_H) debug.h tree-inline.h\n+  input.h $(PARAMS_H) debug.h tree-inline.h tree-simple.h\n cp/mangle.o: cp/mangle.c $(CXX_TREE_H) $(TM_H) toplev.h real.h gt-cp-mangle.h \\\n   $(TARGET_H) $(TM_P_H)\n \n cp/parser.o: cp/parser.c $(CXX_TREE_H) $(TM_H) diagnostic.h gt-cp-parser.h \\\n   output.h\n+cp/cp-simplify.o: cp/cp-simplify.c $(CXX_TREE_H) toplev.h c-common.h \\\n+\t$(TM_H) coretypes.h\n+cp/cp-mudflap.o: cp/cp-mudflap.c $(CXX_TREE_H) toplev.h c-common.h \\\n+\t$(TM_H) coretypes.h\n \n cp/name-lookup.o: cp/name-lookup.c $(CONFIG_H) $(SYSTEM_H) coretypes.h \\\n \t$(TM_H) $(CXX_TREE_H) timevar.h gt-cp-name-lookup.h toplev.h \\"}, {"sha": "c4892e949e45cf02e5dd9fd24799018ce88a6daa", "filename": "gcc/cp/call.c", "status": "modified", "additions": 8, "deletions": 12, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -346,7 +346,7 @@ build_call (tree function, tree parms)\n \t\t\t\t    TREE_VALUE (tmp), t);\n \t}\n \n-  function = build (CALL_EXPR, result_type, function, parms);\n+  function = build (CALL_EXPR, result_type, function, parms, NULL_TREE);\n   TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n   TREE_NOTHROW (function) = nothrow;\n   \n@@ -4331,7 +4331,7 @@ convert_like_real (conversion *convs, tree expr, tree fn, int argnum,\n static tree\n call_builtin_trap (tree type)\n {\n-  tree fn = IDENTIFIER_GLOBAL_VALUE (get_identifier (\"__builtin_trap\"));\n+  tree fn = implicit_built_in_decls[BUILT_IN_TRAP];\n \n   my_friendly_assert (fn != NULL, 20030927);\n   fn = build_call (fn, NULL_TREE);\n@@ -4560,7 +4560,7 @@ build_over_call (struct z_candidate *cand, int flags)\n       tree expr;\n       tree return_type;\n       return_type = TREE_TYPE (TREE_TYPE (fn));\n-      expr = build (CALL_EXPR, return_type, fn, args);\n+      expr = build (CALL_EXPR, return_type, fn, args, NULL_TREE);\n       if (!VOID_TYPE_P (return_type))\n \trequire_complete_type (return_type);\n       return convert_from_reference (expr);\n@@ -4768,16 +4768,11 @@ build_over_call (struct z_candidate *cand, int flags)\n       else if (TREE_CODE (arg) == TARGET_EXPR\n \t       || TYPE_HAS_TRIVIAL_INIT_REF (DECL_CONTEXT (fn)))\n \t{\n-\t  tree address;\n \t  tree to = stabilize_reference\n \t    (build_indirect_ref (TREE_VALUE (args), 0));\n \n \t  val = build (INIT_EXPR, DECL_CONTEXT (fn), to, arg);\n-\t  address = build_unary_op (ADDR_EXPR, val, 0);\n-\t  /* Avoid a warning about this expression, if the address is\n-\t     never used.  */\n-\t  TREE_USED (address) = 1;\n-\t  return address;\n+\t  return val;\n \t}\n     }\n   else if (DECL_OVERLOADED_OPERATOR_P (fn) == NOP_EXPR\n@@ -4813,7 +4808,7 @@ build_over_call (struct z_candidate *cand, int flags)\n \t  val = build (MODIFY_EXPR, as_base, to_as_base, arg_as_base);\n \t  val = convert_to_void (val, NULL);\n \t  val = build (COMPOUND_EXPR, type, val, save_to);\n-\t  TREE_NO_UNUSED_WARNING (val) = 1;\n+\t  TREE_NO_WARNING (val) = 1;\n \t}\n       \n       return val;\n@@ -4936,7 +4931,8 @@ build_java_interface_fn_ref (tree fn, tree instance)\n \t\tiface);\n       return error_mark_node;\n     }\n-  iface_ref = build1 (ADDR_EXPR, build_pointer_type (iface), iface_ref);\n+  iface_ref = build_address (iface_ref);\n+  iface_ref = convert (build_pointer_type (iface), iface_ref);\n   \n   /* Determine the itable index of FN.  */\n   i = 1;\n@@ -5360,7 +5356,7 @@ build_new_method_call (tree instance, tree fns, tree args,\n     call = (build_min_non_dep\n \t    (CALL_EXPR, call,\n \t     build_min_nt (COMPONENT_REF, orig_instance, orig_fns),\n-\t     orig_args));\n+\t     orig_args, NULL_TREE));\n \n  /* Free all the conversions we allocated.  */\n   obstack_free (&conversion_obstack, p);"}, {"sha": "6d2fef502059ba363fbf072fec81e50790c2635e", "filename": "gcc/cp/class.c", "status": "modified", "additions": 15, "deletions": 16, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -335,14 +335,14 @@ build_base_path (enum tree_code code,\n \t  /* In a base member initializer, we cannot rely on\n \t     the vtable being set up. We have to use the vtt_parm.  */\n \t  tree derived = BINFO_INHERITANCE_CHAIN (v_binfo);\n-\t  \n-\t  v_offset = build (PLUS_EXPR, TREE_TYPE (current_vtt_parm),\n-\t\t\t    current_vtt_parm, BINFO_VPTR_INDEX (derived));\n-\t  \n-\t  v_offset = build1 (INDIRECT_REF,\n-\t\t\t     TREE_TYPE (TYPE_VFIELD (BINFO_TYPE (derived))),\n-\t\t\t     v_offset);\n-\t  \n+\t  tree t;\n+\n+\t  t = TREE_TYPE (TYPE_VFIELD (BINFO_TYPE (derived)));\n+\t  t = build_pointer_type (t);\n+\t  v_offset = convert (t, current_vtt_parm);\n+\t  v_offset = build (PLUS_EXPR, t, v_offset,\n+\t\t\t    BINFO_VPTR_INDEX (derived));\n+\t  v_offset = build_indirect_ref (v_offset, NULL);\n \t}\n       else\n \tv_offset = build_vfield_ref (build_indirect_ref (expr, NULL),\n@@ -354,6 +354,8 @@ build_base_path (enum tree_code code,\n \t\t\t build_pointer_type (ptrdiff_type_node),\n \t\t\t v_offset);\n       v_offset = build_indirect_ref (v_offset, NULL);\n+      TREE_CONSTANT (v_offset) = 1;\n+      TREE_INVARIANT (v_offset) = 1;\n \n       offset = convert_to_integer (ptrdiff_type_node,\n \t\t\t\t   size_diffop (offset, \n@@ -513,7 +515,7 @@ build_vtbl_ref_1 (tree instance, tree idx)\n       tree binfo = lookup_base (fixed_type, basetype,\n \t\t\t\tba_ignore|ba_quiet, NULL);\n       if (binfo)\n-\tvtbl = BINFO_VTABLE (binfo);\n+\tvtbl = unshare_expr (BINFO_VTABLE (binfo));\n     }\n \n   if (!vtbl)\n@@ -522,6 +524,8 @@ build_vtbl_ref_1 (tree instance, tree idx)\n   assemble_external (vtbl);\n \n   aref = build_array_ref (vtbl, idx);\n+  TREE_CONSTANT (aref) |= TREE_CONSTANT (vtbl) && TREE_CONSTANT (idx);\n+  TREE_INVARIANT (aref) = TREE_CONSTANT (aref);\n \n   return aref;\n }\n@@ -7277,18 +7281,14 @@ dfs_accumulate_vtbl_inits (tree binfo,\n \n       /* Figure out the position to which the VPTR should point.  */\n       vtbl = TREE_PURPOSE (l);\n-      vtbl = build1 (ADDR_EXPR, \n-\t\t     vtbl_ptr_type_node,\n-\t\t     vtbl);\n-      TREE_CONSTANT (vtbl) = 1;\n+      vtbl = build1 (ADDR_EXPR, vtbl_ptr_type_node, vtbl);\n       index = size_binop (PLUS_EXPR,\n \t\t\t  size_int (non_fn_entries),\n \t\t\t  size_int (list_length (TREE_VALUE (l))));\n       index = size_binop (MULT_EXPR,\n \t\t\t  TYPE_SIZE_UNIT (vtable_entry_type),\n \t\t\t  index);\n       vtbl = build (PLUS_EXPR, TREE_TYPE (vtbl), vtbl, index);\n-      TREE_CONSTANT (vtbl) = 1;\n     }\n \n   if (ctor_vtbl_p)\n@@ -7462,8 +7462,6 @@ build_vtbl_initializer (tree binfo,\n \t  /* Take the address of the function, considering it to be of an\n \t     appropriate generic type.  */\n \t  init = build1 (ADDR_EXPR, vfunc_ptr_type_node, fn);\n-\t  /* The address of a function can't change.  */\n-\t  TREE_CONSTANT (init) = 1;\n \t}\n \n       /* And add it to the chain of initializers.  */\n@@ -7480,6 +7478,7 @@ build_vtbl_initializer (tree binfo,\n \t\t\t\t    TREE_OPERAND (init, 0),\n \t\t\t\t    build_int_2 (i, 0));\n \t\tTREE_CONSTANT (fdesc) = 1;\n+\t\tTREE_INVARIANT (fdesc) = 1;\n \n \t\tvfun_inits = tree_cons (NULL_TREE, fdesc, vfun_inits);\n \t      }"}, {"sha": "3d737ad502a1b969ee787130073687c2236002d1", "filename": "gcc/cp/cp-lang.c", "status": "modified", "additions": 47, "deletions": 74, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-lang.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -35,11 +35,12 @@ Boston, MA 02111-1307, USA.  */\n enum c_language_kind c_language = clk_cxx;\n \n static HOST_WIDE_INT cxx_get_alias_set (tree);\n-static bool ok_to_generate_alias_set_for_type (tree);\n static bool cxx_warn_unused_global_decl (tree);\n static tree cp_expr_size (tree);\n static size_t cp_tree_size (enum tree_code);\n static bool cp_var_mod_type_p (tree);\n+static int cxx_types_compatible_p (tree, tree);\n+static int cp_expand_decl (tree);\n static void cxx_initialize_diagnostics (diagnostic_context *);\n \n #undef LANG_HOOKS_NAME\n@@ -70,14 +71,14 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_EXPAND_CONSTANT cplus_expand_constant\n #undef LANG_HOOKS_EXPAND_EXPR\n #define LANG_HOOKS_EXPAND_EXPR cxx_expand_expr\n+#undef LANG_HOOKS_EXPAND_DECL\n+#define LANG_HOOKS_EXPAND_DECL cp_expand_decl\n #undef LANG_HOOKS_SAFE_FROM_P\n #define LANG_HOOKS_SAFE_FROM_P c_safe_from_p\n #undef LANG_HOOKS_PARSE_FILE\n #define LANG_HOOKS_PARSE_FILE c_common_parse_file\n #undef LANG_HOOKS_DUP_LANG_SPECIFIC_DECL\n #define LANG_HOOKS_DUP_LANG_SPECIFIC_DECL cxx_dup_lang_specific_decl\n-#undef LANG_HOOKS_UNSAVE_EXPR_NOW\n-#define LANG_HOOKS_UNSAVE_EXPR_NOW cxx_unsave_expr_now\n #undef LANG_HOOKS_MAYBE_BUILD_CLEANUP\n #define LANG_HOOKS_MAYBE_BUILD_CLEANUP cxx_maybe_build_cleanup\n #undef LANG_HOOKS_TRUTHVALUE_CONVERSION\n@@ -110,8 +111,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_WARN_UNUSED_GLOBAL_DECL cxx_warn_unused_global_decl\n #undef LANG_HOOKS_WRITE_GLOBALS\n #define LANG_HOOKS_WRITE_GLOBALS lhd_do_nothing\n-#undef LANG_HOOKS_DECL_UNINIT\n-#define LANG_HOOKS_DECL_UNINIT c_decl_uninit\n #undef LANG_HOOKS_UPDATE_DECL_AFTER_SAVING\n #define LANG_HOOKS_UPDATE_DECL_AFTER_SAVING cp_update_decl_after_saving\n \n@@ -120,11 +119,8 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_FUNCTION_INIT cxx_push_function_context\n #undef LANG_HOOKS_FUNCTION_FINAL\n #define LANG_HOOKS_FUNCTION_FINAL cxx_pop_function_context\n-\n-#undef LANG_HOOKS_RTL_EXPAND_START\n-#define LANG_HOOKS_RTL_EXPAND_START cxx_expand_function_start\n-#undef LANG_HOOKS_RTL_EXPAND_STMT\n-#define LANG_HOOKS_RTL_EXPAND_STMT expand_stmt\n+#undef LANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P\n+#define LANG_HOOKS_FUNCTION_MISSING_NORETURN_OK_P cp_missing_noreturn_ok_p\n \n /* Attribute hooks.  */\n #undef LANG_HOOKS_COMMON_ATTRIBUTE_TABLE\n@@ -145,7 +141,7 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n   cp_add_pending_fn_decls\n #undef LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P\n #define LANG_HOOKS_TREE_INLINING_TREE_CHAIN_MATTERS_P \\\n-  cp_is_overload_p\n+  cp_tree_chain_matters_p\n #undef LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P\n #define LANG_HOOKS_TREE_INLINING_AUTO_VAR_IN_FN_P \\\n   cp_auto_var_in_fn_p\n@@ -156,8 +152,6 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_TREE_INLINING_ANON_AGGR_TYPE_P anon_aggr_type_p\n #undef LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P\n #define LANG_HOOKS_TREE_INLINING_VAR_MOD_TYPE_P cp_var_mod_type_p\n-#undef LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS\n-#define LANG_HOOKS_TREE_INLINING_ESTIMATE_NUM_INSNS c_estimate_num_insns\n #undef LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN\n #define LANG_HOOKS_TREE_DUMP_DUMP_TREE_FN cp_dump_tree\n #undef LANG_HOOKS_TREE_DUMP_TYPE_QUALS_FN\n@@ -186,8 +180,12 @@ static void cxx_initialize_diagnostics (diagnostic_context *);\n #define LANG_HOOKS_INCOMPLETE_TYPE_ERROR cxx_incomplete_type_error\n #undef LANG_HOOKS_TYPE_PROMOTES_TO\n #define LANG_HOOKS_TYPE_PROMOTES_TO cxx_type_promotes_to\n+#undef LANG_HOOKS_TYPES_COMPATIBLE_P\n+#define LANG_HOOKS_TYPES_COMPATIBLE_P cxx_types_compatible_p\n #undef LANG_HOOKS_REGISTER_BUILTIN_TYPE\n #define LANG_HOOKS_REGISTER_BUILTIN_TYPE c_register_builtin_type\n+#undef LANG_HOOKS_GIMPLIFY_EXPR\n+#define LANG_HOOKS_GIMPLIFY_EXPR cp_gimplify_expr\n \n /* Each front end provides its own hooks, for toplev.c.  */\n const struct lang_hooks lang_hooks = LANG_HOOKS_INITIALIZER;\n@@ -233,60 +231,6 @@ const char *const tree_code_name[] = {\n };\n #undef DEFTREECODE\n \n-/* Check if a C++ type is safe for aliasing.\n-   Return TRUE if T safe for aliasing FALSE otherwise.  */\n-\n-static bool\n-ok_to_generate_alias_set_for_type (tree t)\n-{\n-  if (TYPE_PTRMEMFUNC_P (t))\n-    return true;\n-  if (AGGREGATE_TYPE_P (t))\n-    {\n-      if ((TREE_CODE (t) == RECORD_TYPE) || (TREE_CODE (t) == UNION_TYPE))\n-\t{\n-\t  tree fields;\n-\t  /* Backend-created structs are safe.  */\n-\t  if (! CLASS_TYPE_P (t))\n-\t    return true;\n-\t  /* PODs are safe.  */\n-\t  if (! CLASSTYPE_NON_POD_P(t))\n-\t    return true;\n-\t  /* Classes with virtual baseclasses are not.  */\n-\t  if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-\t    return false;\n-\t  /* Recursively check the base classes.  */\n-\t  if (TYPE_BINFO (t) != NULL && TYPE_BINFO_BASETYPES (t) != NULL)\n-\t    {\n-\t      int i;\n-\t      for (i = 0; i < TREE_VEC_LENGTH (TYPE_BINFO_BASETYPES (t)); i++)\n-\t\t{\n-\t\t  tree binfo = TREE_VEC_ELT (TYPE_BINFO_BASETYPES (t), i);\n-\t\t  if (!ok_to_generate_alias_set_for_type (BINFO_TYPE (binfo)))\n-\t\t    return false;\n-\t\t}\n-\t    }\n-\t  /* Check all the fields.  */\n-\t  for (fields = TYPE_FIELDS (t); fields; fields = TREE_CHAIN (fields))\n-\t    {\n-\t      if (TREE_CODE (fields) != FIELD_DECL)\n-\t\tcontinue;\n-\t      if (! ok_to_generate_alias_set_for_type (TREE_TYPE (fields)))\n-\t\treturn false;\n-\t    }\n-\t  return true;\n-\t}\n-      else if (TREE_CODE (t) == ARRAY_TYPE)\n-\treturn ok_to_generate_alias_set_for_type (TREE_TYPE (t));\n-      else\n-\t/* This should never happen, we dealt with all the aggregate\n-\t   types that can appear in C++ above.  */\n-\tabort ();\n-    }\n-  else\n-    return true;\n-}\n-\n /* Special routine to get the alias set for C++.  */\n \n static HOST_WIDE_INT\n@@ -297,13 +241,8 @@ cxx_get_alias_set (tree t)\n        complete type.  */\n     return get_alias_set (TYPE_CONTEXT (t));\n   \n-  if (/* It's not yet safe to use alias sets for some classes in C++.  */\n-      !ok_to_generate_alias_set_for_type (t)\n-      /* Nor is it safe to use alias sets for pointers-to-member\n-\t functions, due to the fact that there may be more than one\n-\t RECORD_TYPE type corresponding to the same pointer-to-member\n-\t type.  */\n-      || TYPE_PTRMEMFUNC_P (t))\n+  /* Punt on PMFs until we canonicalize functions properly.  */\n+  if (TYPE_PTRMEMFUNC_P (t))\n     return 0;\n \n   return c_common_get_alias_set (t);\n@@ -354,6 +293,35 @@ cp_expr_size (tree exp)\n     return lhd_expr_size (exp);\n }\n \n+/* Expand DECL if it declares an entity not handled by the\n+   common code.  */\n+\n+static int\n+cp_expand_decl (tree decl)\n+{\n+  if (TREE_CODE (decl) == VAR_DECL && !TREE_STATIC (decl))\n+    {\n+      /* Let the back-end know about this variable.  */\n+      if (!anon_aggr_type_p (TREE_TYPE (decl)))\n+\temit_local_var (decl);\n+      else\n+\texpand_anon_union_decl (decl, NULL_TREE, \n+\t\t\t\tDECL_ANON_UNION_ELEMS (decl));\n+    }\n+  else if (TREE_CODE (decl) == VAR_DECL && TREE_STATIC (decl))\n+    make_rtl_for_local_static (decl);\n+  else\n+    return 0;\n+\n+  return 1;\n+}\n+\n+int\n+cp_tree_chain_matters_p (tree t)\n+{\n+  return cp_is_overload_p (t) || c_tree_chain_matters_p (t);\n+}\n+\n /* Langhook for tree_size: determine size of our 'x' and 'c' nodes.  */\n static size_t\n cp_tree_size (enum tree_code code)\n@@ -388,6 +356,11 @@ cp_var_mod_type_p (tree type)\n   return false;\n }\n \n+static int cxx_types_compatible_p (tree x, tree y)\n+{\n+  return same_type_ignoring_top_level_qualifiers_p (x, y);\n+}\n+\n /* Construct a C++-aware pretty-printer for CONTEXT.  It is assumed\n    that CONTEXT->printer is an already constructed basic pretty_printer.  */\n static void"}, {"sha": "878dc8a1c8571ddce8341272c38dfc77b8f7479a", "filename": "gcc/cp/cp-mudflap.c", "status": "added", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-mudflap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-mudflap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-mudflap.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,108 @@\n+/* Mudflap: narrow-pointer bounds-checking by tree rewriting:\n+   C++ front-end interface.\n+\n+   Copyright (C) 2002, 2003, 2004 Free Software Foundation, Inc.\n+   Contributed by Frank Ch. Eigler <fche@redhat.com>\n+   and Graydon Hoare <graydon@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+\n+#include \"config.h\"\n+#include \"errors.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"tree-inline.h\"\n+#include \"cp-tree.h\"\n+#include \"c-common.h\"\n+#include \"diagnostic.h\"\n+#include \"output.h\"\n+#include \"varray.h\"\n+#include \"tree-mudflap.h\"\n+#include \"target.h\"\n+#include \"flags.h\"\n+#include \"rtl.h\"\n+#include \"toplev.h\"\n+\n+\n+/* Initialize the global tree nodes that correspond to mf-runtime.h\n+   declarations.  */\n+tree\n+mflang_lookup_decl (const char* name)\n+{\n+  tree decl = lookup_name (get_identifier (name), 1);\n+  if (decl == NULL_TREE)\n+    internal_error (\"mudflap: cannot find declaration of `%s' from mf-runtime.h\",\n+\t\t    name);\n+\n+  return decl;\n+}\n+\n+\n+/* Emit a synthetic CTOR function for the current file.  Populate it from\n+   the enqueued __mf_register calls.  Register it with the constructors.  */\n+\n+void\n+mflang_flush_calls (tree enqueued_call_stmt_chain)\n+{\n+  tree fnname, fndecl, body;\n+\n+  /* Short-circuit!  */\n+  if (enqueued_call_stmt_chain == NULL_TREE)\n+    return;\n+\n+  /* Create a ctor function declaration.  */\n+  fnname = get_identifier (\"__static_initialization_and_destruction_mudflap\");\n+\n+  start_function (void_list_node,\n+\t\t  make_call_declarator (fnname, void_list_node, NULL_TREE,\n+\t\t\t\t\tNULL_TREE),\n+\t\t  NULL_TREE, SF_DEFAULT);\n+\n+  TREE_PUBLIC (current_function_decl) = 0;\n+  TREE_USED (current_function_decl) = 1;\n+  DECL_ARTIFICIAL (current_function_decl) = 1;\n+  mf_mark (current_function_decl);\n+\n+  /* Generate the body, one statement at a time.  */\n+  body = begin_compound_stmt (/*has_no_scope=*/false);\n+\n+  while (enqueued_call_stmt_chain)\n+    {\n+      tree next = TREE_CHAIN (enqueued_call_stmt_chain);\n+      finish_expr_stmt (enqueued_call_stmt_chain);\n+      enqueued_call_stmt_chain = next;\n+    }\n+\n+  finish_compound_stmt (body);\n+  fndecl = finish_function (0);\n+\n+  /* NB: We cannot call expand_or_defer_fn here, since that goes through\n+     the callgraph queue.  This queue will have already been processed by the\n+     time this function is running.  */\n+  expand_body (fndecl);\n+  if (targetm.have_ctors_dtors)\n+    (* targetm.asm_out.constructor) (XEXP (DECL_RTL (fndecl), 0),\n+                                     DEFAULT_INIT_PRIORITY);\n+  else\n+    /* By this time, it's too late to do this:\n+       static_ctors = tree_cons (NULL_TREE, fndecl, static_ctors); */\n+    abort ();\n+}"}, {"sha": "af302ee5476edccc5326766005fcf3262490e711", "filename": "gcc/cp/cp-simplify.c", "status": "added", "additions": 236, "deletions": 0, "changes": 236, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-simplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-simplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-simplify.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -0,0 +1,236 @@\n+/* C++-specific tree lowering bits; see also c-simplify.c and tree-simple.c.\n+\n+   Copyright (C) 2002, 2003 Free Software Foundation, Inc.\n+   Contributed by Jason Merrill <jason@redhat.com>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 2, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to the Free\n+Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n+02111-1307, USA.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"tree.h\"\n+#include \"cp-tree.h\"\n+#include \"c-common.h\"\n+#include \"toplev.h\"\n+#include \"tree-simple.h\"\n+\n+static void genericize_try_block (tree *);\n+static void genericize_catch_block (tree *);\n+static void genericize_eh_spec_block (tree *);\n+static void gimplify_must_not_throw_expr (tree *, tree *);\n+static void cp_gimplify_init_expr (tree *, tree *, tree *);\n+\n+/* Genericize a C++ _STMT.  Called from c_gimplify_stmt.  */\n+\n+int\n+cp_gimplify_stmt (tree *stmt_p, tree *next_p ATTRIBUTE_UNUSED)\n+{\n+  tree stmt = *stmt_p;\n+  switch (TREE_CODE (stmt))\n+    {\n+    case TRY_BLOCK:\n+      genericize_try_block (stmt_p);\n+      return 1;\n+\n+    case HANDLER:\n+      genericize_catch_block (stmt_p);\n+      return 1;\n+\n+    case EH_SPEC_BLOCK:\n+      genericize_eh_spec_block (stmt_p);\n+      return 1;\n+\n+    case USING_STMT:\n+      /* Just ignore for now.  Eventually we will want to pass this on to\n+\t the debugger.  */\n+      *stmt_p = build_empty_stmt ();\n+      return 1;\n+\n+    default:\n+      break;\n+    }\n+  return 0;\n+}\n+\n+/* Genericize a TRY_BLOCK.  */\n+\n+static void\n+genericize_try_block (tree *stmt_p)\n+{\n+  tree body = TRY_STMTS (*stmt_p);\n+  tree cleanup = TRY_HANDLERS (*stmt_p);\n+\n+  c_gimplify_stmt (&body);\n+\n+  if (CLEANUP_P (*stmt_p))\n+    /* A cleanup is an expression, so it doesn't need to be genericized.  */;\n+  else\n+    c_gimplify_stmt (&cleanup);\n+\n+  *stmt_p = build (TRY_CATCH_EXPR, void_type_node, body, cleanup);\n+}\n+\n+/* Genericize a HANDLER by converting to a CATCH_EXPR.  */\n+\n+static void\n+genericize_catch_block (tree *stmt_p)\n+{\n+  tree type = HANDLER_TYPE (*stmt_p);\n+  tree body = HANDLER_BODY (*stmt_p);\n+\n+  c_gimplify_stmt (&body);\n+\n+  /* FIXME should the caught type go in TREE_TYPE?  */\n+  *stmt_p = build (CATCH_EXPR, void_type_node, type, body);\n+}\n+\n+/* Genericize an EH_SPEC_BLOCK by converting it to a\n+   TRY_CATCH_EXPR/EH_FILTER_EXPR pair.  */\n+\n+static void\n+genericize_eh_spec_block (tree *stmt_p)\n+{\n+  tree body = EH_SPEC_STMTS (*stmt_p);\n+  tree allowed = EH_SPEC_RAISES (*stmt_p);\n+  tree failure = build_call (call_unexpected_node,\n+\t\t\t     tree_cons (NULL_TREE, build_exc_ptr (),\n+\t\t\t\t\tNULL_TREE));\n+  c_gimplify_stmt (&body);\n+\n+  *stmt_p = gimple_build_eh_filter (body, allowed, failure);\n+}\n+\n+/* Do C++-specific gimplification.  Args are as for gimplify_expr.  */\n+\n+int\n+cp_gimplify_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  switch (TREE_CODE (*expr_p))\n+    {\n+    case PTRMEM_CST:\n+      *expr_p = cplus_expand_constant (*expr_p);\n+      return GS_OK;\n+\n+    case AGGR_INIT_EXPR:\n+      simplify_aggr_init_expr (expr_p);\n+      return GS_OK;\n+\n+    case THROW_EXPR:\n+      /* FIXME communicate throw type to backend, probably by moving\n+\t THROW_EXPR into ../tree.def.  */\n+      *expr_p = TREE_OPERAND (*expr_p, 0);\n+      return GS_OK;\n+\n+    case MUST_NOT_THROW_EXPR:\n+      gimplify_must_not_throw_expr (expr_p, pre_p);\n+      return GS_OK;\n+\n+    case INIT_EXPR:\n+    case MODIFY_EXPR:\n+      cp_gimplify_init_expr (expr_p, pre_p, post_p);\n+      return GS_OK;\n+\n+    case EMPTY_CLASS_EXPR:\n+      {\n+\t/* Yes, an INTEGER_CST with RECORD_TYPE.  */\n+\ttree i = build_int_2 (0, 0);\n+\tTREE_TYPE (i) = TREE_TYPE (*expr_p);\n+\t*expr_p = i;\n+      }\n+      return GS_OK;\n+\n+    case BASELINK:\n+      *expr_p = BASELINK_FUNCTIONS (*expr_p);\n+      return GS_OK;\n+\n+    default:\n+      return c_gimplify_expr (expr_p, pre_p, post_p);\n+    }\n+}\n+\n+/* Gimplify initialization from an AGGR_INIT_EXPR.  */\n+\n+static void\n+cp_gimplify_init_expr (tree *expr_p, tree *pre_p, tree *post_p)\n+{\n+  tree from = TREE_OPERAND (*expr_p, 1);\n+  tree to = TREE_OPERAND (*expr_p, 0);\n+  tree sub;\n+\n+  /* If we are initializing something from a TARGET_EXPR, strip the\n+     TARGET_EXPR and initialize it directly.  */\n+  /* What about code that pulls out the temp and uses it elsewhere?  I\n+     think that such code never uses the TARGET_EXPR as an initializer.  If\n+     I'm wrong, we'll abort because the temp won't have any RTL.  In that\n+     case, I guess we'll need to replace references somehow.  */\n+  if (TREE_CODE (from) == TARGET_EXPR)\n+    from = TARGET_EXPR_INITIAL (from);\n+\n+  sub = from;\n+\n+  /* If we are initializing from a STMT_EXPR, extract the returned\n+     expression.  */\n+  if (TREE_CODE (from) == STMT_EXPR)\n+    sub = EXPR_STMT_EXPR (stmt_expr_last_stmt (from));\n+\n+  /* Look through any COMPOUND_EXPRs.  */\n+  while (TREE_CODE (sub) == COMPOUND_EXPR)\n+    sub = TREE_OPERAND (sub, 1);\n+\n+  /* If we are initializing from an AGGR_INIT_EXPR, drop the INIT_EXPR and\n+     replace the slot operand with our target.\n+\n+     Should we add a target parm to gimplify_expr instead?  No, as in this\n+     case we want to replace the INIT_EXPR.  */\n+  if (TREE_CODE (sub) == AGGR_INIT_EXPR)\n+    {\n+      gimplify_expr (&to, pre_p, post_p, is_gimple_lvalue, fb_lvalue);\n+      TREE_OPERAND (sub, 2) = to;\n+      *expr_p = from;\n+\n+      /* The initialization is now a side-effect, so the container can\n+         become void.  This is important for a STMT_EXPR, so we don't try\n+         to voidify it later by creating a temporary.  */\n+      if (from != sub)\n+\tTREE_TYPE (from) = void_type_node;\n+    }\n+}\n+\n+/* Gimplify a MUST_NOT_THROW_EXPR.  */\n+\n+static void\n+gimplify_must_not_throw_expr (tree *expr_p, tree *pre_p)\n+{\n+  tree stmt = *expr_p;\n+  tree temp = voidify_wrapper_expr (stmt);\n+  tree body = TREE_OPERAND (stmt, 0);\n+\n+  gimplify_stmt (&body);\n+\n+  stmt = gimple_build_eh_filter (body, NULL_TREE,\n+\t\t\t\t build_call (terminate_node, NULL_TREE));\n+\n+  if (temp)\n+    {\n+      append_to_statement_list (stmt, pre_p);\n+      *expr_p = temp;\n+    }\n+  else\n+    *expr_p = stmt;\n+}"}, {"sha": "63a18af378e6ba5142f89e0e63cb6864e54ae9de", "filename": "gcc/cp/cp-tree.def", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -257,6 +257,15 @@ DEFTREECODE (MUST_NOT_THROW_EXPR, \"must_not_throw_expr\", 'e', 1)\n \n DEFTREECODE (TAG_DEFN, \"tag_defn\", 'e', 0)\n \n+/* Template instantiation level node.\n+\n+   Operand 1 contains the original DECL node and can be accessed via TINST_DECL.\n+\n+   A stack of template instantiation nodes is kept through the TREE_CHAIN\n+   fields of these nodes.  */\n+\n+DEFTREECODE (TINST_LEVEL, \"TINST_LEVEL\", 'e', 1)\n+\n /*\n Local variables:\n mode:c"}, {"sha": "7efe55d806121edba7c4469afd783636dbaeecbc", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 12, "deletions": 7, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -3137,12 +3137,9 @@ typedef enum unification_kind_t {\n   DEDUCE_ORDER\n } unification_kind_t;\n \n-/* Macros for operating on a template instantiation level node, represented\n-   by an EXPR_WITH_FILE_LOCATION.  */\n+/* Macros for operating on a template instantiation level node.  */\n \n-#define TINST_DECL(NODE) EXPR_WFL_NODE (NODE)\n-#define TINST_LINE(NODE) EXPR_WFL_LINENO (NODE)\n-#define TINST_FILE(NODE) EXPR_WFL_FILENAME (NODE)\n+#define TINST_DECL(NODE) TREE_OPERAND (NODE, 0)\n \n /* in class.c */\n \n@@ -3709,6 +3706,7 @@ extern tmpl_spec_kind current_tmpl_spec_kind    (int);\n extern tree cp_fname_init\t\t\t(const char *, tree *);\n extern tree check_elaborated_type_specifier     (enum tag_types, tree, bool);\n extern void warn_extern_redeclared_static (tree, tree);\n+extern bool cp_missing_noreturn_ok_p\t\t(tree);\n \n extern bool have_extern_spec;\n \n@@ -4047,7 +4045,7 @@ extern void finish_handler                      (tree);\n extern void finish_cleanup                      (tree, tree);\n extern tree begin_compound_stmt                 (bool);\n extern tree finish_compound_stmt                (tree);\n-extern tree finish_asm_stmt                     (tree, tree, tree, tree, tree);\n+extern tree finish_asm_stmt                     (int, tree, tree, tree, tree);\n extern tree finish_label_stmt                   (tree);\n extern void finish_label_decl                   (tree);\n extern void finish_subobject                    (tree);\n@@ -4087,7 +4085,6 @@ extern void finish_decl_cleanup                 (tree, tree);\n extern void finish_eh_cleanup                   (tree);\n extern void expand_body                         (tree);\n extern void cxx_expand_function_start\t\t(void);\n-extern tree nullify_returns_r\t\t      (tree *, int *, void *);\n extern void do_pushlevel                        (scope_kind);\n extern tree do_poplevel                         (void);\n extern void finish_mem_initializers             (tree);\n@@ -4098,11 +4095,14 @@ extern void expand_or_defer_fn\t\t\t(tree);\n extern void check_accessibility_of_qualified_id (tree, tree, tree);\n extern tree finish_qualified_id_expr            (tree, tree, bool, bool);\n extern void simplify_aggr_init_expr\t\t(tree *);\n+extern void finalize_nrv\t\t\t(tree *, tree, tree);\n \n /* in tree.c */\n extern void lang_check_failed\t\t\t(const char *, int,\n \t\t\t\t\t\t\t const char *);\n extern tree stabilize_expr\t\t\t(tree, tree *);\n+extern void stabilize_call\t\t\t(tree, tree *);\n+extern bool stabilize_init\t\t\t(tree, tree *);\n extern tree cxx_unsave_expr_now\t\t\t(tree);\n extern tree cxx_maybe_build_cleanup\t\t(tree);\n extern void init_tree\t\t\t        (void);\n@@ -4166,6 +4166,7 @@ extern tree find_tree                           (tree, tree);\n extern linkage_kind decl_linkage                (tree);\n extern tree cp_walk_subtrees (tree*, int*, walk_tree_fn,\n \t\t\t\t      void*, void*);\n+extern int cp_tree_chain_matters_p\t\t(tree);\n extern int cp_cannot_inline_tree_fn (tree*);\n extern tree cp_add_pending_fn_decls (void*,tree);\n extern int cp_is_overload_p (tree);\n@@ -4283,6 +4284,10 @@ extern tree mangle_ref_init_variable            (tree);\n /* in dump.c */\n extern bool cp_dump_tree                         (void *, tree);\n \n+/* in cp-simplify.c */\n+extern int cp_gimplify_expr\t\t        (tree *, tree *, tree *);\n+extern int cp_gimplify_stmt\t\t        (tree *, tree *);\n+\n /* -- end of C++ */\n \n /* In order for the format checking to accept the C++ frontend"}, {"sha": "b22948106b2daf18894a5e4857c2687f7268e5d1", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -810,7 +810,7 @@ convert_to_void (tree expr, const char *implicit)\n         /* The second part of a compound expr contains the value.  */\n         tree op1 = TREE_OPERAND (expr,1);\n         tree new_op1 = convert_to_void\n-\t  (op1, (implicit && !TREE_NO_UNUSED_WARNING (expr)\n+\t  (op1, (implicit && !TREE_NO_WARNING (expr)\n \t\t ? \"right-hand operand of comma\" : NULL));\n         \n         if (new_op1 != op1)\n@@ -887,7 +887,8 @@ convert_to_void (tree expr, const char *implicit)\n   \n   if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n-      if (implicit && !TREE_SIDE_EFFECTS (expr) && warn_unused_value)\n+      if (implicit && warn_unused_value\n+\t  && !TREE_SIDE_EFFECTS (expr) && !TREE_NO_WARNING (expr))\n \twarning (\"%s has no effect\", implicit);\n       expr = build1 (CONVERT_EXPR, void_type_node, expr);\n     }"}, {"sha": "21f82548eaa15f923d297877029e160283b9292d", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 40, "deletions": 49, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -51,6 +51,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"diagnostic.h\"\n #include \"debug.h\"\n #include \"timevar.h\"\n+#include \"tree-flow.h\"\n \n static tree grokparms (tree, tree *);\n static const char *redeclaration_error_message (tree, tree);\n@@ -114,7 +115,6 @@ static tree check_special_function_return_type\n static tree push_cp_library_fn (enum tree_code, tree);\n static tree build_cp_library_fn (tree, enum tree_code, tree);\n static void store_parm_decls (tree);\n-static int cp_missing_noreturn_ok_p (tree);\n static void initialize_local_var (tree, tree);\n static void expand_static_init (tree, tree);\n static tree next_initializable_field (tree);\n@@ -499,28 +499,6 @@ poplevel (int keep, int reverse, int functionbody)\n   else\n     decls = current_binding_level->names;\n \n-  /* Output any nested inline functions within this block\n-     if they weren't already output.  */\n-  for (decl = decls; decl; decl = TREE_CHAIN (decl))\n-    if (TREE_CODE (decl) == FUNCTION_DECL\n-\t&& ! TREE_ASM_WRITTEN (decl)\n-\t&& DECL_INITIAL (decl) != NULL_TREE\n-\t&& TREE_ADDRESSABLE (decl)\n-\t&& decl_function_context (decl) == current_function_decl)\n-      {\n-\t/* If this decl was copied from a file-scope decl\n-\t   on account of a block-scope extern decl,\n-\t   propagate TREE_ADDRESSABLE to the file-scope decl.  */\n-\tif (DECL_ABSTRACT_ORIGIN (decl) != NULL_TREE)\n-\t  TREE_ADDRESSABLE (DECL_ABSTRACT_ORIGIN (decl)) = 1;\n-\telse\n-\t  {\n-\t    push_function_context ();\n-\t    output_inline_function (decl);\n-\t    pop_function_context ();\n-\t  }\n-      }\n-\n   /* When not in function-at-a-time mode, expand_end_bindings will\n      warn about unused variables.  But, in function-at-a-time mode\n      expand_end_bindings is not passed the list of variables in the\n@@ -2406,9 +2384,11 @@ push_switch (tree switch_stmt)\n void\n pop_switch (void)\n {\n-  struct cp_switch *cs;\n+  struct cp_switch *cs = switch_stack;\n+\n+  /* Emit warnings as needed.  */\n+  c_do_switch_warnings (cs->cases, cs->switch_stmt);\n \n-  cs = switch_stack;\n   splay_tree_delete (cs->cases);\n   switch_stack = switch_stack->next;\n   free (cs);\n@@ -2878,9 +2858,6 @@ cxx_init_decl_processing (void)\n   /* Create all the identifiers we need.  */\n   initialize_predefined_identifiers ();\n \n-  /* Fill in back-end hooks.  */\n-  lang_missing_noreturn_ok_p = &cp_missing_noreturn_ok_p;\n-\n   /* Create the global variables.  */\n   push_to_top_level ();\n \n@@ -3060,7 +3037,8 @@ cxx_init_decl_processing (void)\n   start_fname_decls ();\n \n   /* Show we use EH for cleanups.  */\n-  using_eh_for_cleanups ();\n+  if (flag_exceptions)\n+    using_eh_for_cleanups ();\n }\n \n /* Generate an initializer for a function naming variable from\n@@ -4544,7 +4522,7 @@ make_rtl_for_nonlocal_decl (tree decl, tree init, const char* asmspec)\n \t asm-specification, indicates that the variable should be\n \t placed in a particular register.  */\n       if (DECL_REGISTER (decl))\n-\tDECL_C_HARD_REGISTER (decl) = 1;\n+\tDECL_HARD_REGISTER (decl) = 1;\n     }\n \n   /* We don't create any RTL for local variables.  */\n@@ -7283,6 +7261,13 @@ grokdeclarator (tree declarator,\n \n \t    type = create_array_type_for_decl (dname, type, size);\n \n+\t    if (declarator\n+\t\t&& (TREE_CODE (declarator) == INDIRECT_REF\n+\t\t    || TREE_CODE (declarator) == ADDR_EXPR))\n+\t      /* We can never complete an array type which is the target of a\n+\t\t pointer, so go ahead and lay it out.  */\n+\t      layout_type (type);\n+\n \t    ctype = NULL_TREE;\n \t  }\n \t  break;\n@@ -7768,6 +7753,7 @@ grokdeclarator (tree declarator,\n     }\n \n   if (declarator == NULL_TREE\n+      || TREE_CODE (declarator) == ERROR_MARK\n       || TREE_CODE (declarator) == IDENTIFIER_NODE\n       || (TREE_CODE (declarator) == TEMPLATE_ID_EXPR\n \t  && (TREE_CODE (type) == FUNCTION_TYPE\n@@ -9935,7 +9921,9 @@ build_enumerator (tree name, tree value, tree enumtype)\n     decl = build_decl (CONST_DECL, name, type);\n \n   DECL_CONTEXT (decl) = FROB_CONTEXT (context);\n-  TREE_CONSTANT (decl) = TREE_READONLY (decl) = 1;\n+  TREE_CONSTANT (decl) = 1;\n+  TREE_INVARIANT (decl) = 1;\n+  TREE_READONLY (decl) = 1;\n   DECL_INITIAL (decl) = value;\n \n   if (context && context == current_class_type)\n@@ -10730,10 +10718,8 @@ finish_function (int flags)\n      of curly braces for a function.  */\n   my_friendly_assert (stmts_are_full_exprs_p (), 19990831);\n \n-  /* Set up the named return value optimization, if we can.  Here, we\n-     eliminate the copy from the nrv into the RESULT_DECL and any cleanup\n-     for the nrv.  genrtl_start_function and declare_return_variable\n-     handle making the nrv and RESULT_DECL share space.  */\n+  /* Set up the named return value optimization, if we can.  Candidate\n+     variables are selected in check_return_value.  */\n   if (current_function_return_value)\n     {\n       tree r = current_function_return_value;\n@@ -10750,16 +10736,9 @@ finish_function (int flags)\n \t  /* Skip the artificial function body block.  */\n \t  && (outer = BLOCK_SUBBLOCKS (BLOCK_SUBBLOCKS (DECL_INITIAL (fndecl))),\n \t      chain_member (r, BLOCK_VARS (outer))))\n-\t{\n-\t  \n-\t  DECL_ALIGN (r) = DECL_ALIGN (DECL_RESULT (fndecl));\n-\t  walk_tree_without_duplicates (&DECL_SAVED_TREE (fndecl),\n-\t\t\t\t\tnullify_returns_r, r);\n-\t}\n-      else\n-\t/* Clear it so genrtl_start_function and declare_return_variable\n-\t   know we're not optimizing.  */\n-\tcurrent_function_return_value = NULL_TREE;\n+\tfinalize_nrv (&DECL_SAVED_TREE (fndecl), r, DECL_RESULT (fndecl));\n+\n+      current_function_return_value = NULL_TREE;\n     }\n \n   /* Remember that we were in class scope.  */\n@@ -10802,9 +10781,21 @@ finish_function (int flags)\n       && (DECL_INLINE (fndecl) || processing_template_decl))\n     warning (\"no return statement in function returning non-void\");\n \n-  /* We're leaving the context of this function, so zap cfun.\n-     It's still in DECL_STRUCT_FUNCTION, and we'll restore it in\n-     tree_rest_of_compilation.  */\n+  /* Store the end of the function, so that we get good line number\n+     info for the epilogue.  */\n+  cfun->function_end_locus = input_location;\n+\n+  /* Genericize before inlining.  */\n+  if (!processing_template_decl)\n+    {\n+      c_genericize (fndecl);\n+\n+      /* Handle attribute((warn_unused_result)).  Relies on gimple input.  */\n+      c_warn_unused_result (&DECL_SAVED_TREE (fndecl));\n+    }\n+\n+  /* We're leaving the context of this function, so zap cfun.  It's still in\n+     DECL_STRUCT_FUNCTION, and we'll restore it in tree_rest_of_compilation.  */\n   cfun = NULL;\n   current_function_decl = NULL;\n \n@@ -11178,7 +11169,7 @@ build_void_list_node (void)\n   return t;\n }\n \n-static int\n+bool\n cp_missing_noreturn_ok_p (tree decl)\n {\n   /* A missing noreturn is ok for the `main' function.  */"}, {"sha": "4c36eb5549cf0e62d047ab897e9ce8c9b6d5c7ef", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -46,8 +46,10 @@ Boston, MA 02111-1307, USA.  */\n #include \"cpplib.h\"\n #include \"target.h\"\n #include \"c-common.h\"\n+#include \"tree-mudflap.h\"\n #include \"cgraph.h\"\n #include \"tree-inline.h\"\n+\n extern cpp_reader *parse_in;\n \n /* This structure contains information about the initializations\n@@ -2587,7 +2589,7 @@ finish_file (void)\n   timevar_push (TV_VARCONST);\n \n   emit_support_tinfos ();\n-  \n+\n   do \n     {\n       tree t;\n@@ -2872,6 +2874,11 @@ finish_file (void)\n       cgraph_optimize ();\n     }\n \n+  /* Emit mudflap static registration function.  This must be done\n+     after all the user functions have been expanded.  */\n+  if (flag_mudflap)\n+    mudflap_finish_file ();\n+\n   /* Now, issue warnings about static, but not defined, functions,\n      etc., and emit debugging information.  */\n   walk_namespaces (wrapup_globals_for_namespace, /*data=*/&reconsider);\n@@ -2885,12 +2892,12 @@ finish_file (void)\n      to a file.  */\n   {\n     int flags;\n-    FILE *stream = dump_begin (TDI_all, &flags);\n+    FILE *stream = dump_begin (TDI_tu, &flags);\n \n     if (stream)\n       {\n \tdump_node (global_namespace, flags & ~TDF_SLIM, stream);\n-\tdump_end (TDI_all, stream);\n+\tdump_end (TDI_tu, stream);\n       }\n   }\n   \n@@ -2932,7 +2939,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \t\t\t  20030708);\n       if (type_dependent_expression_p (fn)\n \t  || any_type_dependent_arguments_p (args))\n-\treturn build_min_nt (CALL_EXPR, fn, args);\n+\treturn build_min_nt (CALL_EXPR, fn, args, NULL_TREE);\n \n       /* Transform the arguments and add the implicit \"this\"\n \t parameter.  That must be done before the FN is transformed\n@@ -2962,7 +2969,7 @@ build_offset_ref_call_from_tree (tree fn, tree args)\n \n   expr = build_function_call (fn, args);\n   if (processing_template_decl && expr != error_mark_node)\n-    return build_min_non_dep (CALL_EXPR, expr, orig_fn, orig_args);\n+    return build_min_non_dep (CALL_EXPR, expr, orig_fn, orig_args, NULL_TREE);\n   return expr;\n }\n   "}, {"sha": "6e186503bad925328ceccb6d533042be94f66248", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 9, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -47,7 +47,7 @@ static cxx_pretty_printer scratch_pretty_printer;\n # define NEXT_CODE(T) (TREE_CODE (TREE_TYPE (T)))\n \n #define reinit_global_formatting_buffer() \\\n-   output_clear_message_text (scratch_buffer)\n+   pp_clear_output_area (scratch_buffer)\n \n static const char *args_to_string (tree, int);\n static const char *assop_to_string (enum tree_code);\n@@ -1604,10 +1604,6 @@ dump_expr (tree t, int flags)\n \tbreak;\n       }\n       \n-    case EXPR_WITH_FILE_LOCATION:\n-      dump_expr (EXPR_WFL_NODE (t), flags);\n-      break;\n-\n     case CONSTRUCTOR:\n       if (TREE_TYPE (t) && TYPE_PTRMEMFUNC_P (TREE_TYPE (t)))\n \t{\n@@ -2191,8 +2187,7 @@ print_instantiation_full_context (diagnostic_context *context)\n                          decl_as_string (TINST_DECL (p),\n                                          TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n \n-\t  location.line = TINST_LINE (p);\n-\t  location.file = TINST_FILE (p);\n+\t  location = *EXPR_LOCUS (p);\n \t  p = TREE_CHAIN (p);\n \t}\n     }\n@@ -2211,8 +2206,7 @@ print_instantiation_partial_context (diagnostic_context *context,\n                    loc.file, loc.line,\n                    decl_as_string (TINST_DECL (t),\n                                    TFF_DECL_SPECIFIERS | TFF_RETURN_TYPE));\n-      loc.line = TINST_LINE (t);\n-      loc.file = TINST_FILE (t);\n+      loc = *EXPR_LOCUS (t);\n     }\n   pp_verbatim (context->printer, \"%s:%d:   instantiated from here\\n\",\n                loc.file, loc.line);"}, {"sha": "79f1dfac0d90b1c1479a23486a2e9cb1e04f4120", "filename": "gcc/cp/except.c", "status": "modified", "additions": 37, "deletions": 73, "changes": 110, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexcept.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -47,7 +47,6 @@ static tree do_end_catch (tree);\n static bool decl_is_java_type (tree decl, int err);\n static void initialize_handler_parm (tree, tree);\n static tree do_allocate_exception (tree);\n-static tree stabilize_throw_expr (tree, tree *);\n static tree wrap_cleanups_r (tree *, int *, void *);\n static int complete_ptr_ref_or_void_ptr_p (tree, tree);\n static bool is_admissible_throw_operand (tree);\n@@ -145,7 +144,7 @@ build_eh_type_type (tree type)\n \n   mark_used (exp);\n \n-  return build1 (ADDR_EXPR, ptr_type_node, exp);\n+  return convert (ptr_type_node, build_address (exp));\n }\n \n tree\n@@ -507,7 +506,6 @@ do_allocate_exception (tree type)\n \t\t\t\t\t     NULL_TREE));\n }\n \n-#if 0\n /* Call __cxa_free_exception from a cleanup.  This is never invoked\n    directly, but see the comment for stabilize_throw_expr.  */\n \n@@ -526,7 +524,6 @@ do_free_exception (tree ptr)\n \n   return build_function_call (fn, tree_cons (NULL_TREE, ptr, NULL_TREE));\n }\n-#endif\n \n /* Wrap all cleanups for TARGET_EXPRs in MUST_NOT_THROW_EXPR.\n    Called from build_throw via walk_tree_without_duplicates.  */\n@@ -558,58 +555,6 @@ wrap_cleanups_r (tree *tp, int *walk_subtrees ATTRIBUTE_UNUSED,\n   return NULL_TREE;\n }\n \n-/* Like stabilize_expr, but specifically for a thrown expression.  When\n-   throwing a temporary class object, we want to construct it directly into\n-   the thrown exception, so we look past the TARGET_EXPR and stabilize the\n-   arguments of the call instead.\n-\n-   The case where EXP is a call to a function returning a class is a bit of\n-   a grey area in the standard; it's unclear whether or not it should be\n-   allowed to throw.  I'm going to say no, as that allows us to optimize\n-   this case without worrying about deallocating the exception object if it\n-   does.  The alternatives would be either not optimizing this case, or\n-   wrapping the initialization in a TRY_CATCH_EXPR to call do_free_exception\n-   rather than in a MUST_NOT_THROW_EXPR, for this case only.  */\n-\n-static tree\n-stabilize_throw_expr (tree exp, tree *initp)\n-{\n-  tree init_expr;\n-\n-  if (TREE_CODE (exp) == TARGET_EXPR\n-      && TREE_CODE (TARGET_EXPR_INITIAL (exp)) == AGGR_INIT_EXPR\n-      && flag_elide_constructors)\n-    {\n-      tree aggr_init = AGGR_INIT_EXPR_CHECK (TARGET_EXPR_INITIAL (exp));\n-      tree args = TREE_OPERAND (aggr_init, 1);\n-      tree newargs = NULL_TREE;\n-      tree *p = &newargs;\n-\n-      init_expr = void_zero_node;\n-      for (; args; args = TREE_CHAIN (args))\n-\t{\n-\t  tree arg = TREE_VALUE (args);\n-\t  tree arg_init_expr;\n-\n-\t  arg = stabilize_expr (arg, &arg_init_expr);\n-\n-\t  if (TREE_SIDE_EFFECTS (arg_init_expr))\n-\t    init_expr = build (COMPOUND_EXPR, void_type_node, init_expr,\n-\t\t\t       arg_init_expr);\n-\t  *p = tree_cons (NULL_TREE, arg, NULL_TREE);\n-\t  p = &TREE_CHAIN (*p);\n-\t}\n-      TREE_OPERAND (aggr_init, 1) = newargs;\n-    }\n-  else\n-    {\n-      exp = stabilize_expr (exp, &init_expr);\n-    }\n-\n-  *initp = init_expr;\n-  return exp;\n-}\n-\n /* Build a throw expression.  */\n \n tree\n@@ -663,6 +608,7 @@ build_throw (tree exp)\n       tree object, ptr;\n       tree tmp;\n       tree temp_expr, allocate_expr;\n+      bool elided;\n \n       fn = get_identifier (\"__cxa_throw\");\n       if (!get_global_value_if_present (fn, &fn))\n@@ -703,18 +649,15 @@ build_throw (tree exp)\n \t the call to __cxa_allocate_exception first (which doesn't\n \t matter, since it can't throw).  */\n \n-      /* Pre-evaluate the thrown expression first, since if we allocated\n-\t the space first we would have to deal with cleaning it up if\n-\t evaluating this expression throws.  */\n-      exp = stabilize_throw_expr (exp, &temp_expr);\n-\n       /* Allocate the space for the exception.  */\n       allocate_expr = do_allocate_exception (TREE_TYPE (exp));\n       allocate_expr = get_target_expr (allocate_expr);\n       ptr = TARGET_EXPR_SLOT (allocate_expr);\n       object = build1 (NOP_EXPR, build_pointer_type (TREE_TYPE (exp)), ptr);\n       object = build_indirect_ref (object, NULL);\n \n+      elided = (TREE_CODE (exp) == TARGET_EXPR);\n+\n       /* And initialize the exception object.  */\n       exp = build_init (object, exp, LOOKUP_ONLYCONVERTING);\n       if (exp == error_mark_node)\n@@ -723,10 +666,35 @@ build_throw (tree exp)\n \t  return error_mark_node;\n \t}\n \n-      exp = build1 (MUST_NOT_THROW_EXPR, void_type_node, exp);\n+      /* Pre-evaluate the thrown expression first, since if we allocated\n+\t the space first we would have to deal with cleaning it up if\n+\t evaluating this expression throws.\n+\n+\t The case where EXP the initializer is a call to a constructor or a\n+\t function returning a class is a bit of a grey area in the\n+\t standard; it's unclear whether or not it should be allowed to\n+\t throw.  We used to say no, as that allowed us to optimize this\n+\t case without worrying about deallocating the exception object if\n+\t it does.  But that conflicted with expectations (PR 13944) and the\n+\t EDG compiler; now we wrap the initialization in a TRY_CATCH_EXPR\n+\t to call do_free_exception rather than in a MUST_NOT_THROW_EXPR,\n+\t for this case only.\n+\n+         Note that we don't check the return value from stabilize_init\n+         because it will only return false in cases where elided is true,\n+         and therefore we don't need to work around the failure to\n+         preevaluate.  */\n+      stabilize_init (exp, &temp_expr);\n+\n+      if (elided)\n+\texp = build (TRY_CATCH_EXPR, void_type_node, exp,\n+\t\t     do_free_exception (ptr));\n+      else\n+\texp = build1 (MUST_NOT_THROW_EXPR, void_type_node, exp);\n+\n       /* Prepend the allocation.  */\n       exp = build (COMPOUND_EXPR, TREE_TYPE (exp), allocate_expr, exp);\n-      if (temp_expr != void_zero_node)\n+      if (temp_expr)\n \t{\n \t  /* Prepend the calculation of the throw expression.  Also, force\n \t     any cleanups from the expression to be evaluated here so that\n@@ -921,11 +889,10 @@ check_handlers_1 (tree master, tree handlers)\n     if (TREE_TYPE (handler)\n \t&& can_convert_eh (type, TREE_TYPE (handler)))\n       {\n-\tinput_line = STMT_LINENO (handler);\n-\twarning (\"exception of type `%T' will be caught\",\n-\t\t    TREE_TYPE (handler));\n-\tinput_line = STMT_LINENO (master);\n-\twarning (\"   by earlier handler for `%T'\", type);\n+\twarning (\"%Hexception of type `%T' will be caught\",\n+\t\t EXPR_LOCUS (handler), TREE_TYPE (handler));\n+\twarning (\"%H   by earlier handler for `%T'\",\n+\t\t EXPR_LOCUS (master), type);\n \tbreak;\n       }\n }\n@@ -943,11 +910,8 @@ check_handlers (tree handlers)\n       if (TREE_CHAIN (handler) == NULL_TREE)\n \t/* No more handlers; nothing to shadow.  */;\n       else if (TREE_TYPE (handler) == NULL_TREE)\n-\t{\n-\t  input_line = STMT_LINENO (handler);\n-\t  pedwarn\n-\t    (\"`...' handler must be the last handler for its try block\");\n-\t}\n+\tpedwarn (\"%H`...' handler must be the last handler for\"\n+\t\t \" its try block\", EXPR_LOCUS (handler));\n       else\n \tcheck_handlers_1 (handler, TREE_CHAIN (handler));\n     }"}, {"sha": "e12c6a4a64fff356f72a4b26a2a477788c92a572", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 3, "deletions": 15, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -73,6 +73,9 @@ cplus_expand_constant (tree cst)\n }\n \n /* Hook used by expand_expr to expand language-specific tree codes.  */\n+/* ??? The only thing that should be here are things needed to expand\n+   constant initializers; everything else should be handled by the\n+   gimplification routines.  Are EMPTY_CLASS_EXPR or BASELINK needed?  */\n \n rtx\n cxx_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier,\n@@ -81,7 +84,6 @@ cxx_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier,\n   tree type = TREE_TYPE (exp);\n   enum machine_mode mode = TYPE_MODE (type);\n   enum tree_code code = TREE_CODE (exp);\n-  rtx ret;\n \n   /* No sense saving up arithmetic to be done\n      if it's all in the wrong mode to form part of an address.\n@@ -99,17 +101,6 @@ cxx_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier,\n     case OFFSET_REF:\n       /* Offset refs should not make it through to here.  */\n       abort ();\n-      return const0_rtx;\n-      \n-    case THROW_EXPR:\n-      expand_expr (TREE_OPERAND (exp, 0), const0_rtx, VOIDmode, 0);\n-      return const0_rtx;\n-\n-    case MUST_NOT_THROW_EXPR:\n-      expand_eh_region_start ();\n-      ret = expand_expr (TREE_OPERAND (exp, 0), target, tmode, modifier);\n-      expand_eh_region_end_must_not_throw (build_call (terminate_node, 0));\n-      return ret;\n \n     case EMPTY_CLASS_EXPR:\n       /* We don't need to generate any code for an empty class.  */\n@@ -122,7 +113,4 @@ cxx_expand_expr (tree exp, rtx target, enum machine_mode tmode, int modifier,\n     default:\n       return c_expand_expr (exp, target, tmode, modifier, alt_rtl);\n     }\n-  abort ();\n-  /* NOTREACHED */\n-  return NULL;\n }"}, {"sha": "8cf0019cfab249d4f986e39c697c98cd2f0809b3", "filename": "gcc/cp/init.c", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -248,7 +248,10 @@ build_zero_init (tree type, tree nelts, bool static_storage_p)\n \n   /* In all cases, the initializer is a constant.  */\n   if (init)\n-    TREE_CONSTANT (init) = 1;\n+    {\n+      TREE_CONSTANT (init) = 1;\n+      TREE_INVARIANT (init) = 1;\n+    }\n \n   return init;\n }\n@@ -728,12 +731,9 @@ build_vtbl_address (tree binfo)\n   TREE_USED (vtbl) = 1;\n \n   /* Now compute the address to use when initializing the vptr.  */\n-  vtbl = BINFO_VTABLE (binfo_for);\n+  vtbl = unshare_expr (BINFO_VTABLE (binfo_for));\n   if (TREE_CODE (vtbl) == VAR_DECL)\n-    {\n-      vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n-      TREE_CONSTANT (vtbl) = 1;\n-    }\n+    vtbl = build1 (ADDR_EXPR, build_pointer_type (TREE_TYPE (vtbl)), vtbl);\n \n   return vtbl;\n }\n@@ -767,7 +767,8 @@ expand_virtual_init (tree binfo, tree decl)\n \t\t     TREE_TYPE (vtt_parm), \n \t\t     vtt_parm,\n \t\t     vtt_index);\n-      vtbl2 = build1 (INDIRECT_REF, TREE_TYPE (vtbl), vtbl2);\n+      vtbl2 = build_indirect_ref (vtbl2, NULL);\n+      vtbl2 = convert (TREE_TYPE (vtbl), vtbl2);\n \n       /* The actual initializer is the VTT value only in the subobject\n \t constructor.  In maybe_clone_body we'll substitute NULL for\n@@ -1143,9 +1144,13 @@ build_init (tree decl, tree init, int flags)\n {\n   tree expr;\n \n-  if (IS_AGGR_TYPE (TREE_TYPE (decl))\n-      || TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n+  if (TREE_CODE (TREE_TYPE (decl)) == ARRAY_TYPE)\n     expr = build_aggr_init (decl, init, flags);\n+  else if (CLASS_TYPE_P (TREE_TYPE (decl)))\n+    expr = build_special_member_call (decl, complete_ctor_identifier,\n+\t\t\t\t      build_tree_list (NULL_TREE, init),\n+\t\t\t\t      TYPE_BINFO (TREE_TYPE (decl)),\n+\t\t\t\t      LOOKUP_NORMAL|flags);\n   else\n     expr = build (INIT_EXPR, TREE_TYPE (decl), decl, init);\n \n@@ -1825,7 +1830,7 @@ build_new (tree placement, tree decl, tree init, int use_global_new)\n \n   /* Wrap it in a NOP_EXPR so warn_if_unused_value doesn't complain.  */\n   rval = build1 (NOP_EXPR, TREE_TYPE (rval), rval);\n-  TREE_NO_UNUSED_WARNING (rval) = 1;\n+  TREE_NO_WARNING (rval) = 1;\n \n   return rval;\n }\n@@ -1908,7 +1913,7 @@ static tree\n build_new_1 (tree exp)\n {\n   tree placement, init;\n-  tree true_type, size, rval, t;\n+  tree true_type, size, rval;\n   /* The type of the new-expression.  (This type is always a pointer\n      type.)  */\n   tree pointer_type;\n@@ -1949,6 +1954,7 @@ build_new_1 (tree exp)\n      address of the first array element.  This node is a VAR_DECL, and\n      is therefore reusable.  */\n   tree data_addr;\n+  tree init_preeval_expr = NULL_TREE;\n \n   placement = TREE_OPERAND (exp, 0);\n   type = TREE_OPERAND (exp, 1);\n@@ -2009,7 +2015,9 @@ build_new_1 (tree exp)\n       tree class_addr, alloc_decl;\n       tree class_decl = build_java_class_ref (true_type);\n       static const char alloc_name[] = \"_Jv_AllocObject\";\n+\n       use_java_new = 1;\n+      alloc_decl = NULL;\n       if (!get_global_value_if_present (get_identifier (alloc_name), \n \t\t\t\t\t&alloc_decl))\n \t{\n@@ -2115,18 +2123,8 @@ build_new_1 (tree exp)\n      placement delete.  */\n   if (placement_allocation_fn_p)\n     {\n-      tree inits = NULL_TREE;\n-      t = TREE_CHAIN (TREE_OPERAND (alloc_call, 1));\n-      for (; t; t = TREE_CHAIN (t))\n-\tif (TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n-\t  {\n-\t    tree init;\n-\t    TREE_VALUE (t) = stabilize_expr (TREE_VALUE (t), &init);\n-\t    if (inits)\n-\t      inits = build (COMPOUND_EXPR, void_type_node, inits, init);\n-\t    else\n-\t      inits = init;\n-\t  }\n+      tree inits;\n+      stabilize_call (alloc_call, &inits);\n       if (inits)\n \talloc_expr = build (COMPOUND_EXPR, TREE_TYPE (alloc_expr), inits,\n \t\t\t    alloc_expr);\n@@ -2169,43 +2167,57 @@ build_new_1 (tree exp)\n       data_addr = alloc_node;\n     }\n \n-  /* Now initialize the allocated object.  */\n+  /* Now initialize the allocated object.  Note that we preevaluate the\n+     initialization expression, apart from the actual constructor call or\n+     assignment--we do this because we want to delay the allocation as long\n+     as possible in order to minimize the size of the exception region for\n+     placement delete.  */\n   if (is_initialized)\n     {\n+      bool stable;\n+\n       init_expr = build_indirect_ref (data_addr, NULL);\n \n       if (init == void_zero_node)\n \tinit = build_default_init (full_type, nelts);\n-      else if (init && pedantic && has_array)\n+      else if (init && has_array)\n \tpedwarn (\"ISO C++ forbids initialization in array new\");\n \n       if (has_array)\n-\tinit_expr\n-\t  = build_vec_init (init_expr,\n-\t\t\t    cp_build_binary_op (MINUS_EXPR, outer_nelts,\n-\t\t\t\t\t\tinteger_one_node),\n-\t\t\t    init, /*from_array=*/0);\n+\t{\n+\t  init_expr\n+\t    = build_vec_init (init_expr,\n+\t\t\t      cp_build_binary_op (MINUS_EXPR, outer_nelts,\n+\t\t\t\t\t\t  integer_one_node),\n+\t\t\t      init, /*from_array=*/0);\n+\n+\t  /* An array initialization is stable because the initialization\n+\t     of each element is a full-expression, so the temporaries don't\n+\t     leak out.  */\n+\t  stable = true;\n+\t}\n       else if (TYPE_NEEDS_CONSTRUCTING (type))\n-\tinit_expr = build_special_member_call (init_expr, \n-\t\t\t\t\t       complete_ctor_identifier,\n-\t\t\t\t\t       init, TYPE_BINFO (true_type),\n-\t\t\t\t\t       LOOKUP_NORMAL);\n+\t{\n+\t  init_expr = build_special_member_call (init_expr, \n+\t\t\t\t\t\t complete_ctor_identifier,\n+\t\t\t\t\t\t init, TYPE_BINFO (true_type),\n+\t\t\t\t\t\t LOOKUP_NORMAL);\n+\t  stable = stabilize_init (init_expr, &init_preeval_expr);\n+\t}\n       else\n \t{\n \t  /* We are processing something like `new int (10)', which\n \t     means allocate an int, and initialize it with 10.  */\n \n \t  if (TREE_CODE (init) == TREE_LIST)\n \t    init = build_x_compound_expr_from_list (init, \"new initializer\");\n-\t  \n+\n \t  else if (TREE_CODE (init) == CONSTRUCTOR\n \t\t   && TREE_TYPE (init) == NULL_TREE)\n-\t    {\n-\t      pedwarn (\"ISO C++ forbids aggregate initializer to new\");\n-\t      init = digest_init (type, init, 0);\n-\t    }\n+\t    abort ();\n \n \t  init_expr = build_modify_expr (init_expr, INIT_EXPR, init);\n+\t  stable = stabilize_init (init_expr, &init_preeval_expr);\n \t}\n \n       if (init_expr == error_mark_node)\n@@ -2232,31 +2244,24 @@ build_new_1 (tree exp)\n \t\t\t\t\t  (placement_allocation_fn_p \n \t\t\t\t\t   ? alloc_call : NULL_TREE));\n \n-\t  /* Ack!  First we allocate the memory.  Then we set our sentry\n-\t     variable to true, and expand a cleanup that deletes the memory\n-\t     if sentry is true.  Then we run the constructor, and finally\n-\t     clear the sentry.\n-\n-\t     It would be nice to be able to handle this without the sentry\n-\t     variable, perhaps with a TRY_CATCH_EXPR, but this doesn't\n-\t     work.  We allocate the space first, so if there are any\n-\t     temporaries with cleanups in the constructor args we need this\n-\t     EH region to extend until end of full-expression to preserve\n-\t     nesting.\n-\n-\t     If the backend had some mechanism so that we could force the\n-\t     allocation to be expanded after all the other args to the\n-\t     constructor, that would fix the nesting problem and we could\n-\t     do away with this complexity.  But that would complicate other\n-\t     things; in particular, it would make it difficult to bail out\n-\t     if the allocation function returns null.  Er, no, it wouldn't;\n-\t     we just don't run the constructor.  The standard says it's\n-\t     unspecified whether or not the args are evaluated.\n-\n-\t     FIXME FIXME FIXME inline invisible refs as refs.  That way we\n-\t     can preevaluate value parameters.  */\n-\n-\t  if (cleanup)\n+\t  if (!cleanup)\n+\t    /* We're done.  */;\n+\t  else if (stable)\n+\t    /* This is much simpler if we were able to preevaluate all of\n+\t       the arguments to the constructor call.  */\n+\t    init_expr = build (TRY_CATCH_EXPR, void_type_node,\n+\t\t\t       init_expr, cleanup);\n+\t  else\n+\t    /* Ack!  First we allocate the memory.  Then we set our sentry\n+\t       variable to true, and expand a cleanup that deletes the\n+\t       memory if sentry is true.  Then we run the constructor, and\n+\t       finally clear the sentry.\n+\n+\t       We need to do this because we allocate the space first, so\n+\t       if there are any temporaries with cleanups in the\n+\t       constructor args and we weren't able to preevaluate them, we\n+\t       need this EH region to extend until end of full-expression\n+\t       to preserve nesting.  */\n \t    {\n \t      tree end, sentry, begin;\n \n@@ -2277,6 +2282,7 @@ build_new_1 (tree exp)\n \t\t\t build (COMPOUND_EXPR, void_type_node, init_expr,\n \t\t\t\tend));\n \t    }\n+\t    \n \t}\n     }\n   else\n@@ -2309,6 +2315,9 @@ build_new_1 (tree exp)\n       rval = build (COMPOUND_EXPR, TREE_TYPE (rval), alloc_expr, rval);\n     }\n \n+  if (init_preeval_expr)\n+    rval = build (COMPOUND_EXPR, TREE_TYPE (rval), init_preeval_expr, rval);\n+\n   /* Convert to the final type.  */\n   rval = build_nop (pointer_type, rval);\n "}, {"sha": "044f2895c0c9667e48227711e077e9c89f43f30a", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -317,7 +317,6 @@ static inline bool\n get_global_value_if_present (tree id, tree *decl)\n {\n   tree global_value = namespace_binding (id, global_namespace);\n-\n   if (global_value)\n     *decl = global_value;\n   return global_value != NULL;"}, {"sha": "1be4d8afdcc53e1e3c260ec30695359b570b582a", "filename": "gcc/cp/optimize.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Foptimize.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Foptimize.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Foptimize.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -36,6 +36,11 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #include \"hashtab.h\"\n #include \"debug.h\"\n #include \"tree-inline.h\"\n+#include \"flags.h\"\n+#include \"langhooks.h\"\n+#include \"diagnostic.h\"\n+#include \"tree-dump.h\"\n+#include \"tree-simple.h\"\n \n /* Prototypes.  */\n "}, {"sha": "fdc171e041faaaa0e07f72eee9d8c42ccc12368b", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 12, "deletions": 10, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -3842,7 +3842,8 @@ cp_parser_postfix_expression (cp_parser *parser, bool address_p)\n \t\t\t|| any_type_dependent_arguments_p (args)))\n \t\t  {\n \t\t    postfix_expression\n-\t\t      = build_min_nt (CALL_EXPR, postfix_expression, args);\n+\t\t      = build_min_nt (CALL_EXPR, postfix_expression,\n+\t\t\t\t      args, NULL_TREE);\n \t\t    break;\n \t\t  }\n \n@@ -5473,14 +5474,14 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n {\n   tree statement;\n   cp_token *token;\n-  int statement_line_number;\n+  location_t statement_locus;\n \n   /* There is no statement yet.  */\n   statement = NULL_TREE;\n   /* Peek at the next token.  */\n   token = cp_lexer_peek_token (parser->lexer);\n-  /* Remember the line number of the first token in the statement.  */\n-  statement_line_number = token->location.line;\n+  /* Remember the location of the first token in the statement.  */\n+  statement_locus = token->location;\n   /* If this is a keyword, then that will often determine what kind of\n      statement we have.  */\n   if (token->type == CPP_KEYWORD)\n@@ -5556,7 +5557,10 @@ cp_parser_statement (cp_parser* parser, bool in_statement_expr_p)\n \n   /* Set the line number for the statement.  */\n   if (statement && STATEMENT_CODE_P (TREE_CODE (statement)))\n-    STMT_LINENO (statement) = statement_line_number;\n+    {\n+      SET_EXPR_LOCUS (statement, NULL);\n+      annotate_with_locus (statement, statement_locus);\n+    }\n }\n \n /* Parse a labeled-statement.\n@@ -9867,10 +9871,8 @@ cp_parser_asm_definition (cp_parser* parser)\n   /* Create the ASM_STMT.  */\n   if (at_function_scope_p ())\n     {\n-      asm_stmt =\n-\tfinish_asm_stmt (volatile_p\n-\t\t\t ? ridpointers[(int) RID_VOLATILE] : NULL_TREE,\n-\t\t\t string, outputs, inputs, clobbers);\n+      asm_stmt = finish_asm_stmt (volatile_p, string, outputs,\n+\t\t\t\t  inputs, clobbers);\n       /* If the extended syntax was not used, mark the ASM_STMT.  */\n       if (!extended_p)\n \tASM_INPUT_P (asm_stmt) = 1;\n@@ -11787,7 +11789,7 @@ cp_parser_class_specifier (cp_parser* parser)\n {\n   cp_token *token;\n   tree type;\n-  tree attributes;\n+  tree attributes = NULL_TREE;\n   int has_trailing_semicolon;\n   bool nested_name_specifier_p;\n   unsigned saved_num_template_parameter_lists;"}, {"sha": "043e3e467c25f80af9d0a1ca83991c5b96581bb6", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 20, "deletions": 17, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -375,7 +375,9 @@ push_inline_template_parms_recursive (tree parmlist, int levels)\n \t    tree decl = build_decl (CONST_DECL, DECL_NAME (parm),\n \t\t\t\t    TREE_TYPE (parm));\n \t    DECL_ARTIFICIAL (decl) = 1;\n-\t    TREE_CONSTANT (decl) = TREE_READONLY (decl) = 1;\n+\t    TREE_CONSTANT (decl) = 1;\n+\t    TREE_INVARIANT (decl) = 1;\n+\t    TREE_READONLY (decl) = 1;\n \t    DECL_INITIAL (decl) = DECL_INITIAL (parm);\n \t    SET_DECL_TEMPLATE_PARM_P (decl);\n \t    pushdecl (decl);\n@@ -2115,6 +2117,7 @@ build_template_parm_index (int index,\n   TEMPLATE_PARM_DECL (t) = decl;\n   TREE_TYPE (t) = type;\n   TREE_CONSTANT (t) = TREE_CONSTANT (decl);\n+  TREE_INVARIANT (t) = TREE_INVARIANT (decl);\n   TREE_READONLY (t) = TREE_READONLY (decl);\n \n   return t;\n@@ -2137,6 +2140,7 @@ reduce_template_parm_level (tree index, tree type, int levels)\n       \n       decl = build_decl (TREE_CODE (orig_decl), DECL_NAME (orig_decl), type);\n       TREE_CONSTANT (decl) = TREE_CONSTANT (orig_decl);\n+      TREE_INVARIANT (decl) = TREE_INVARIANT (orig_decl);\n       TREE_READONLY (decl) = TREE_READONLY (orig_decl);\n       DECL_ARTIFICIAL (decl) = 1;\n       SET_DECL_TEMPLATE_PARM_P (decl);\n@@ -2200,11 +2204,15 @@ process_template_parm (tree list, tree next)\n       TREE_TYPE (parm) = TYPE_MAIN_VARIANT (TREE_TYPE (parm));\n \n       /* A template parameter is not modifiable.  */\n-      TREE_READONLY (parm) = TREE_CONSTANT (parm) = 1;\n+      TREE_CONSTANT (parm) = 1;\n+      TREE_INVARIANT (parm) = 1;\n+      TREE_READONLY (parm) = 1;\n       if (invalid_nontype_parm_type_p (TREE_TYPE (parm), 1))\n         TREE_TYPE (parm) = void_type_node;\n       decl = build_decl (CONST_DECL, DECL_NAME (parm), TREE_TYPE (parm));\n-      TREE_CONSTANT (decl) = TREE_READONLY (decl) = 1;\n+      TREE_CONSTANT (decl) = 1;\n+      TREE_INVARIANT (decl) = 1;\n+      TREE_READONLY (decl) = 1;\n       DECL_INITIAL (parm) = DECL_INITIAL (decl) \n \t= build_template_parm_index (idx, processing_template_decl,\n \t\t\t\t     processing_template_decl,\n@@ -4865,7 +4873,9 @@ push_tinst_level (tree d)\n       return 0;\n     }\n \n-  new = build_expr_wfl (d, input_filename, input_line, 0);\n+  new = make_node (TINST_LEVEL);\n+  annotate_with_locus (new, input_location);\n+  TINST_DECL (new) = d;\n   TREE_CHAIN (new) = current_tinst_level;\n   current_tinst_level = new;\n \n@@ -4889,8 +4899,7 @@ pop_tinst_level (void)\n \n   /* Restore the filename and line number stashed away when we started\n      this instantiation.  */\n-  input_line = TINST_LINE (old);\n-  input_filename = TINST_FILE (old);\n+  input_location = *EXPR_LOCUS (old);\n   extract_interface_info ();\n   \n   current_tinst_level = TREE_CHAIN (old);\n@@ -5648,7 +5657,7 @@ instantiate_class_template (tree type)\n      that would be used for non-template classes.  */\n   typedecl = TYPE_MAIN_DECL (type);\n   input_location = DECL_SOURCE_LOCATION (typedecl);\n-  \n+\n   unreverse_member_declarations (type);\n   finish_struct_1 (type);\n \n@@ -7971,15 +7980,10 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n       break;\n \n     case LABEL_STMT:\n-      input_line = STMT_LINENO (t);\n+      prep_stmt (t);\n       finish_label_stmt (DECL_NAME (LABEL_STMT_LABEL (t)));\n       break;\n \n-    case FILE_STMT:\n-      input_filename = FILE_STMT_FILENAME (t);\n-      add_stmt (build_nt (FILE_STMT, FILE_STMT_FILENAME_NODE (t)));\n-      break;\n-\n     case GOTO_STMT:\n       prep_stmt (t);\n       tmp = GOTO_DESTINATION (t);\n@@ -7996,7 +8000,7 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl)\n     case ASM_STMT:\n       prep_stmt (t);\n       tmp = finish_asm_stmt\n-\t(ASM_CV_QUAL (t),\n+\t(ASM_VOLATILE_P (t),\n \t tsubst_expr (ASM_STRING (t), args, complain, in_decl),\n \t tsubst_expr (ASM_OUTPUTS (t), args, complain, in_decl),\n \t tsubst_expr (ASM_INPUTS (t), args, complain, in_decl), \n@@ -11151,7 +11155,7 @@ instantiate_decl (tree d, int defer_ok)\n       goto out;\n     }\n \n-  need_push = !global_bindings_p ();\n+  need_push = !cfun || !global_bindings_p ();\n   if (need_push)\n     push_to_top_level ();\n \n@@ -11164,8 +11168,7 @@ instantiate_decl (tree d, int defer_ok)\n   regenerate_decl_from_template (d, td);\n   \n   /* We already set the file and line above.  Reset them now in case\n-     they changed as a result of calling\n-     regenerate_decl_from_template.  */\n+     they changed as a result of calling regenerate_decl_from_template.  */\n   input_location = DECL_SOURCE_LOCATION (d);\n \n   if (TREE_CODE (d) == VAR_DECL)"}, {"sha": "ac149c8c91baefca7666972e7003aabf6030bceb", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -231,7 +231,7 @@ get_tinfo_decl_dynamic (tree exp)\n       /* The RTTI information is at index -1.  */\n       index = build_int_2 (-1 * TARGET_VTABLE_DATA_ENTRY_DISTANCE, -1);\n       t = build_vtbl_ref (exp, index);\n-      TREE_TYPE (t) = type_info_ptr_type;\n+      t = convert (type_info_ptr_type, t);\n     }\n   else\n     /* Otherwise return the type_info for the static type of the expr.  */\n@@ -797,7 +797,6 @@ tinfo_base_init (tree desc, tree target)\n \t size_binop (MULT_EXPR,\n \t\t     size_int (2 * TARGET_VTABLE_DATA_ENTRY_DISTANCE),\n \t\t     TYPE_SIZE_UNIT (vtable_entry_type)));\n-      TREE_CONSTANT (vtable_ptr) = 1;\n \n       TINFO_VTABLE_DECL (desc) = vtable_ptr;\n     }\n@@ -807,7 +806,9 @@ tinfo_base_init (tree desc, tree target)\n   init = tree_cons (NULL_TREE, decay_conversion (name_decl), init);\n   \n   init = build_constructor (NULL_TREE, nreverse (init));\n-  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n   init = tree_cons (NULL_TREE, init, NULL_TREE);\n   \n   return init;\n@@ -823,7 +824,9 @@ generic_initializer (tree desc, tree target)\n   tree init = tinfo_base_init (desc, target);\n   \n   init = build_constructor (NULL_TREE, init);\n-  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n   return init;\n }\n \n@@ -850,7 +853,9 @@ ptr_initializer (tree desc, tree target, bool *non_public_ptr)\n                     init);\n   \n   init = build_constructor (NULL_TREE, nreverse (init));\n-  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n   return init;\n }\n \n@@ -887,7 +892,9 @@ ptm_initializer (tree desc, tree target, bool *non_public_ptr)\n \t\t    init);  \n   \n   init = build_constructor (NULL_TREE, nreverse (init));\n-  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n   return init;  \n }\n \n@@ -955,7 +962,9 @@ class_initializer (tree desc, tree target, tree trail)\n   \n   TREE_CHAIN (init) = trail;\n   init = build_constructor (NULL_TREE, init);\n-  TREE_CONSTANT (init) = TREE_STATIC (init) = 1;\n+  TREE_CONSTANT (init) = 1;\n+  TREE_INVARIANT (init) = 1;\n+  TREE_STATIC (init) = 1;\n   return init;  \n }\n "}, {"sha": "2fea1c8b86ca6fe510ca84d08d98052648b188b4", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 87, "deletions": 133, "changes": 220, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -32,6 +32,7 @@\n #include \"tree.h\"\n #include \"cp-tree.h\"\n #include \"tree-inline.h\"\n+#include \"tree-mudflap.h\"\n #include \"except.h\"\n #include \"lex.h\"\n #include \"toplev.h\"\n@@ -41,6 +42,7 @@\n #include \"output.h\"\n #include \"timevar.h\"\n #include \"debug.h\"\n+#include \"diagnostic.h\"\n #include \"cgraph.h\"\n \n /* There routines provide a modular interface to perform many parsing\n@@ -55,10 +57,7 @@\n static tree maybe_convert_cond (tree);\n static tree simplify_aggr_init_exprs_r (tree *, int *, void *);\n static void emit_associated_thunks (tree);\n-static void genrtl_try_block (tree);\n-static void genrtl_eh_spec_block (tree);\n-static void genrtl_handler (tree);\n-static void cp_expand_stmt (tree);\n+static tree finalize_nrv_r (tree *, int *, void *);\n \n \n /* Finish processing the COND, the SUBSTMT condition for STMT.  */\n@@ -788,56 +787,6 @@ finish_switch_stmt (tree switch_stmt)\n   do_poplevel ();\n }\n \n-/* Generate the RTL for T, which is a TRY_BLOCK.  */\n-\n-static void \n-genrtl_try_block (tree t)\n-{\n-  if (CLEANUP_P (t))\n-    {\n-      expand_eh_region_start ();\n-      expand_stmt (TRY_STMTS (t));\n-      expand_eh_region_end_cleanup (TRY_HANDLERS (t));\n-    }\n-  else\n-    {\n-      if (!FN_TRY_BLOCK_P (t)) \n-\temit_line_note (input_location);\n-\n-      expand_eh_region_start ();\n-      expand_stmt (TRY_STMTS (t));\n-\n-      if (FN_TRY_BLOCK_P (t))\n-\t{\n-\t  expand_start_all_catch ();\n-\t  in_function_try_handler = 1;\n-\t  expand_stmt (TRY_HANDLERS (t));\n-\t  in_function_try_handler = 0;\n-\t  expand_end_all_catch ();\n-\t}\n-      else \n-\t{\n-\t  expand_start_all_catch ();  \n-\t  expand_stmt (TRY_HANDLERS (t));\n-\t  expand_end_all_catch ();\n-\t}\n-    }\n-}\n-\n-/* Generate the RTL for T, which is an EH_SPEC_BLOCK.  */\n-\n-static void \n-genrtl_eh_spec_block (tree t)\n-{\n-  expand_eh_region_start ();\n-  expand_stmt (EH_SPEC_STMTS (t));\n-  expand_eh_region_end_allowed (EH_SPEC_RAISES (t),\n-\t\t\t\tbuild_call (call_unexpected_node,\n-\t\t\t\t\t    tree_cons (NULL_TREE,\n-\t\t\t\t\t\t       build_exc_ptr (),\n-\t\t\t\t\t\t       NULL_TREE)));\n-}\n-\n /* Begin a try-block.  Returns a newly-created TRY_BLOCK if\n    appropriate.  */\n \n@@ -925,19 +874,6 @@ finish_function_handler_sequence (tree try_block)\n   check_handlers (TRY_HANDLERS (try_block));\n }\n \n-/* Generate the RTL for T, which is a HANDLER.  */\n-\n-static void\n-genrtl_handler (tree t)\n-{\n-  genrtl_do_pushlevel ();\n-  if (!processing_template_decl)\n-    expand_start_catch (HANDLER_TYPE (t));\n-  expand_stmt (HANDLER_BODY (t));\n-  if (!processing_template_decl)\n-    expand_end_catch ();\n-}\n-\n /* Begin a handler.  Returns a HANDLER if appropriate.  */\n \n tree\n@@ -1050,28 +986,17 @@ finish_compound_stmt (tree compound_stmt)\n   return r;\n }\n \n-/* Finish an asm-statement, whose components are a CV_QUALIFIER, a\n-   STRING, some OUTPUT_OPERANDS, some INPUT_OPERANDS, and some\n-   CLOBBERS.  */\n+/* Finish an asm-statement, whose components are a STRING, some\n+   OUTPUT_OPERANDS, some INPUT_OPERANDS, and some CLOBBERS.  Also note\n+   whether the asm-statement should be considered volatile.  */\n \n tree\n-finish_asm_stmt (tree cv_qualifier, \n-                 tree string, \n-                 tree output_operands,\n-\t\t tree input_operands, \n-                 tree clobbers)\n+finish_asm_stmt (int volatile_p, tree string, tree output_operands,\n+\t\t tree input_operands, tree clobbers)\n {\n   tree r;\n   tree t;\n \n-  if (cv_qualifier != NULL_TREE\n-      && cv_qualifier != ridpointers[(int) RID_VOLATILE])\n-    {\n-      warning (\"%s qualifier ignored on asm\",\n-\t\t  IDENTIFIER_POINTER (cv_qualifier));\n-      cv_qualifier = NULL_TREE;\n-    }\n-\n   if (!processing_template_decl)\n     {\n       int i;\n@@ -1133,9 +1058,10 @@ finish_asm_stmt (tree cv_qualifier,\n \t}\n     }\n \n-  r = build_stmt (ASM_STMT, cv_qualifier, string,\n+  r = build_stmt (ASM_STMT, string,\n \t\t  output_operands, input_operands,\n \t\t  clobbers);\n+  ASM_VOLATILE_P (r) = volatile_p;\n   return add_stmt (r);\n }\n \n@@ -1629,7 +1555,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       if (type_dependent_expression_p (fn)\n \t  || any_type_dependent_arguments_p (args))\n \t{\n-\t  result = build_nt (CALL_EXPR, fn, args);\n+\t  result = build_nt (CALL_EXPR, fn, args, NULL_TREE);\n \t  KOENIG_LOOKUP_P (result) = koenig_p;\n \t  return result;\n \t}\n@@ -1704,7 +1630,7 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n       if (processing_template_decl)\n \t{\n \t  if (type_dependent_expression_p (object))\n-\t    return build_nt (CALL_EXPR, orig_fn, orig_args);\n+\t    return build_nt (CALL_EXPR, orig_fn, orig_args, NULL_TREE);\n \t  object = build_non_dependent_expr (object);\n \t}\n \n@@ -1737,7 +1663,8 @@ finish_call_expr (tree fn, tree args, bool disallow_virtual, bool koenig_p)\n \n   if (processing_template_decl)\n     {\n-      result = build (CALL_EXPR, TREE_TYPE (result), orig_fn, orig_args);\n+      result = build (CALL_EXPR, TREE_TYPE (result), orig_fn,\n+\t\t      orig_args, NULL_TREE);\n       KOENIG_LOOKUP_P (result) = koenig_p;\n     }\n   return result;\n@@ -2686,7 +2613,7 @@ finish_id_expression (tree id_expression,\n       /* Resolve references to variables of anonymous unions\n \t into COMPONENT_REFs.  */\n       if (TREE_CODE (decl) == ALIAS_DECL)\n-\tdecl = DECL_INITIAL (decl);\n+\tdecl = unshare_expr (DECL_INITIAL (decl));\n     }\n \n   if (TREE_DEPRECATED (decl))\n@@ -2722,37 +2649,8 @@ finish_typeof (tree expr)\n   return type;\n }\n \n-/* Generate RTL for the statement T, and its substatements, and any\n-   other statements at its nesting level.  */\n-\n-static void\n-cp_expand_stmt (tree t)\n-{\n-  switch (TREE_CODE (t))\n-    {\n-    case TRY_BLOCK:\n-      genrtl_try_block (t);\n-      break;\n-\n-    case EH_SPEC_BLOCK:\n-      genrtl_eh_spec_block (t);\n-      break;\n-\n-    case HANDLER:\n-      genrtl_handler (t);\n-      break;\n-\n-    case USING_STMT:\n-      break;\n-    \n-    default:\n-      abort ();\n-      break;\n-    }\n-}\n-\n /* Called from expand_body via walk_tree.  Replace all AGGR_INIT_EXPRs\n-   will equivalent CALL_EXPRs.  */\n+   with equivalent CALL_EXPRs.  */\n \n static tree\n simplify_aggr_init_exprs_r (tree* tp, \n@@ -2905,7 +2803,7 @@ void\n expand_body (tree fn)\n {\n   tree saved_function;\n-  \n+\n   /* Compute the appropriate object-file linkage for inline\n      functions.  */\n   if (DECL_DECLARED_INLINE_P (fn))\n@@ -3013,45 +2911,101 @@ expand_or_defer_fn (tree fn)\n   function_depth--;\n }\n \n-/* Helper function for walk_tree, used by finish_function to override all\n-   the RETURN_STMTs and pertinent CLEANUP_STMTs for the named return\n-   value optimization.  */\n+struct nrv_data\n+{\n+  tree var;\n+  tree result;\n+  htab_t visited;\n+};\n \n-tree\n-nullify_returns_r (tree* tp, int* walk_subtrees, void* data)\n+/* Helper function for walk_tree, used by finalize_nrv below.  */\n+\n+static tree\n+finalize_nrv_r (tree* tp, int* walk_subtrees, void* data)\n {\n-  tree nrv = (tree) data;\n+  struct nrv_data *dp = (struct nrv_data *)data;\n+  void **slot;\n \n   /* No need to walk into types.  There wouldn't be any need to walk into\n      non-statements, except that we have to consider STMT_EXPRs.  */\n   if (TYPE_P (*tp))\n     *walk_subtrees = 0;\n+  /* Change all returns to just refer to the RESULT_DECL; this is a nop,\n+     but differs from using NULL_TREE in that it indicates that we care\n+     about the value of the RESULT_DECL.  */\n   else if (TREE_CODE (*tp) == RETURN_STMT)\n-    RETURN_STMT_EXPR (*tp) = NULL_TREE;\n+    RETURN_STMT_EXPR (*tp) = dp->result;\n+  /* Change all cleanups for the NRV to only run when an exception is\n+     thrown.  */\n   else if (TREE_CODE (*tp) == CLEANUP_STMT\n-\t   && CLEANUP_DECL (*tp) == nrv)\n+\t   && CLEANUP_DECL (*tp) == dp->var)\n     CLEANUP_EH_ONLY (*tp) = 1;\n+  /* Replace the DECL_STMT for the NRV with an initialization of the\n+     RESULT_DECL, if needed.  */\n+  else if (TREE_CODE (*tp) == DECL_STMT\n+\t   && DECL_STMT_DECL (*tp) == dp->var)\n+    {\n+      tree init;\n+      if (DECL_INITIAL (dp->var)\n+\t  && DECL_INITIAL (dp->var) != error_mark_node)\n+\t{\n+\t  init = build (INIT_EXPR, void_type_node, dp->result,\n+\t\t\tDECL_INITIAL (dp->var));\n+\t  DECL_INITIAL (dp->var) = error_mark_node;\n+\t}\n+      else\n+\tinit = NULL_TREE;\n+      init = build_stmt (EXPR_STMT, init);\n+      SET_EXPR_LOCUS (init, EXPR_LOCUS (*tp));\n+      TREE_CHAIN (init) = TREE_CHAIN (*tp);\n+      *tp = init;\n+    }\n+  /* And replace all uses of the NRV with the RESULT_DECL.  */\n+  else if (*tp == dp->var)\n+    *tp = dp->result;\n+\n+  /* Avoid walking into the same tree more than once.  Unfortunately, we\n+     can't just use walk_tree_without duplicates because it would only call\n+     us for the first occurrence of dp->var in the function body.  */\n+  slot = htab_find_slot (dp->visited, *tp, INSERT);\n+  if (*slot)\n+    *walk_subtrees = 0;\n+  else\n+    *slot = *tp;\n \n   /* Keep iterating.  */\n   return NULL_TREE;\n }\n \n-/* Start generating the RTL for FN.  */\n+/* Called from finish_function to implement the named return value\n+   optimization by overriding all the RETURN_STMTs and pertinent\n+   CLEANUP_STMTs and replacing all occurrences of VAR with RESULT, the\n+   RESULT_DECL for the function.  */\n \n void\n-cxx_expand_function_start (void)\n+finalize_nrv (tree *tp, tree var, tree result)\n {\n-  /* Give our named return value the same RTL as our RESULT_DECL.  */\n-  if (current_function_return_value)\n-    COPY_DECL_RTL (DECL_RESULT (cfun->decl), current_function_return_value);\n+  struct nrv_data data;\n+\n+  /* Copy debugging information from VAR to RESULT.  */\n+  DECL_NAME (result) = DECL_NAME (var);\n+  DECL_SOURCE_LOCATION (result) = DECL_SOURCE_LOCATION (var);\n+  DECL_ABSTRACT_ORIGIN (result) = DECL_ABSTRACT_ORIGIN (var);\n+  /* Don't forget that we take its address.  */\n+  TREE_ADDRESSABLE (result) = TREE_ADDRESSABLE (var);\n+\n+  data.var = var;\n+  data.result = result;\n+  data.visited = htab_create (37, htab_hash_pointer, htab_eq_pointer, NULL);\n+  walk_tree (tp, finalize_nrv_r, &data, 0);\n+  htab_delete (data.visited);\n }\n \n /* Perform initialization related to this module.  */\n \n void\n init_cp_semantics (void)\n {\n-  lang_expand_stmt = cp_expand_stmt;\n }\n \n #include \"gt-cp-semantics.h\""}, {"sha": "1e470eb862dfccb2808b302dcc713c5b9ae21f97", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 92, "deletions": 39, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f", "patch": "@@ -1933,9 +1933,6 @@ tree\n make_ptrmem_cst (tree type, tree member)\n {\n   tree ptrmem_cst = make_node (PTRMEM_CST);\n-  /* If would seem a great convenience if make_node would set\n-     TREE_CONSTANT for things of class `c', but it does not.  */\n-  TREE_CONSTANT (ptrmem_cst) = 1;\n   TREE_TYPE (ptrmem_cst) = type;\n   PTRMEM_CST_MEMBER (ptrmem_cst) = member;\n   return ptrmem_cst;\n@@ -1969,19 +1966,26 @@ cp_walk_subtrees (tree* tp,\n                   void* htab)\n {\n   enum tree_code code = TREE_CODE (*tp);\n+  location_t save_locus;\n   tree result;\n   \n #define WALK_SUBTREE(NODE)\t\t\t\t\\\n   do\t\t\t\t\t\t\t\\\n     {\t\t\t\t\t\t\t\\\n       result = walk_tree (&(NODE), func, data, htab);\t\\\n-      if (result)\t\t\t\t\t\\\n-\treturn result;\t\t\t\t\t\\\n+      if (result) goto out;\t\t\t\t\\\n     }\t\t\t\t\t\t\t\\\n   while (0)\n \n+  /* Set input_location here so we get the right instantiation context\n+     if we call instantiate_decl from inlinable_function_p.  */\n+  save_locus = input_location;\n+  if (EXPR_LOCUS (*tp))\n+    input_location = *EXPR_LOCUS (*tp);\n+\n   /* Not one of the easy cases.  We must explicitly go through the\n      children.  */\n+  result = NULL_TREE;\n   switch (code)\n     {\n     case DEFAULT_ARG:\n@@ -2019,11 +2023,14 @@ cp_walk_subtrees (tree* tp,\n       break;\n \n     default:\n-      break;\n+      input_location = save_locus;\n+      return c_walk_subtrees (tp, walk_subtrees_p, func, data, htab);\n     }\n \n   /* We didn't find what we were looking for.  */\n-  return NULL_TREE;\n+ out:\n+  input_location = save_locus;\n+  return result;\n \n #undef WALK_SUBTREE\n }\n@@ -2132,11 +2139,10 @@ tree\n cp_copy_res_decl_for_inlining (tree result, \n                                tree fn, \n                                tree caller, \n-                               void* decl_map_,\n+                               void* decl_map_ ATTRIBUTE_UNUSED,\n                                int* need_decl, \n                                tree return_slot_addr)\n {\n-  splay_tree decl_map = (splay_tree)decl_map_;\n   tree var;\n \n   /* If FN returns an aggregate then the caller will always pass the\n@@ -2147,7 +2153,7 @@ cp_copy_res_decl_for_inlining (tree result,\n      references to the RESULT into references to the target.  */\n \n   /* We should have an explicit return slot iff the return type is\n-     TREE_ADDRESSABLE.  See simplify_aggr_init_expr.  */\n+     TREE_ADDRESSABLE.  See gimplify_aggr_init_expr.  */\n   if (TREE_ADDRESSABLE (TREE_TYPE (result))\n       != (return_slot_addr != NULL_TREE))\n     abort ();\n@@ -2164,34 +2170,6 @@ cp_copy_res_decl_for_inlining (tree result,\n   else\n     var = copy_decl_for_inlining (result, fn, caller);\n \n-  if (DECL_SAVED_FUNCTION_DATA (fn))\n-    {\n-      tree nrv = DECL_SAVED_FUNCTION_DATA (fn)->x_return_value;\n-      if (nrv)\n-\t{\n-\t  /* We have a named return value; copy the name and source\n-\t     position so we can get reasonable debugging information, and\n-\t     register the return variable as its equivalent.  */\n-\t  if (TREE_CODE (var) == VAR_DECL\n-\t      /* But not if we're initializing a variable from the\n-\t\t enclosing function which already has its own name.  */\n-\t      && DECL_NAME (var) == NULL_TREE)\n-\t    {\n-\t      DECL_NAME (var) = DECL_NAME (nrv);\n-\t      DECL_SOURCE_LOCATION (var) = DECL_SOURCE_LOCATION (nrv);\n-\t      DECL_ABSTRACT_ORIGIN (var) = DECL_ORIGIN (nrv);\n-\t      /* Don't lose initialization info.  */\n-\t      DECL_INITIAL (var) = DECL_INITIAL (nrv);\n-\t      /* Don't forget that it needs to go in the stack.  */\n-\t      TREE_ADDRESSABLE (var) = TREE_ADDRESSABLE (nrv);\n-\t    }\n-\n-\t  splay_tree_insert (decl_map,\n-\t\t\t     (splay_tree_key) nrv,\n-\t\t\t     (splay_tree_value) var);\n-\t}\n-    }\n-\n   return var;\n }\n \n@@ -2214,6 +2192,7 @@ cp_update_decl_after_saving (tree fn,\n void\n init_tree (void)\n {\n+  lang_gimplify_stmt = cp_gimplify_stmt;\n   list_hash_table = htab_create_ggc (31, list_hash, list_hash_eq, NULL);\n }\n \n@@ -2431,7 +2410,7 @@ stabilize_expr (tree exp, tree* initp)\n \n   if (!TREE_SIDE_EFFECTS (exp))\n     {\n-      init_expr = void_zero_node;\n+      init_expr = NULL_TREE;\n     }\n   else if (!real_lvalue_p (exp)\n \t   || !TYPE_NEEDS_CONSTRUCTING (TREE_TYPE (exp)))\n@@ -2450,6 +2429,80 @@ stabilize_expr (tree exp, tree* initp)\n   *initp = init_expr;\n   return exp;\n }\n+\n+/* Like stabilize_expr, but for a call whose args we want to\n+   pre-evaluate.  */\n+\n+void\n+stabilize_call (tree call, tree *initp)\n+{\n+  tree inits = NULL_TREE;\n+  tree t;\n+\n+  if (call == error_mark_node)\n+    return;\n+\n+  if (TREE_CODE (call) != CALL_EXPR\n+      && TREE_CODE (call) != AGGR_INIT_EXPR)\n+    abort ();\n+\n+  for (t = TREE_OPERAND (call, 1); t; t = TREE_CHAIN (t))\n+    if (TREE_SIDE_EFFECTS (TREE_VALUE (t)))\n+      {\n+\ttree init;\n+\tTREE_VALUE (t) = stabilize_expr (TREE_VALUE (t), &init);\n+\tif (!init)\n+\t  /* Nothing.  */;\n+\telse if (inits)\n+\t  inits = build (COMPOUND_EXPR, void_type_node, inits, init);\n+\telse\n+\t  inits = init;\n+      }\n+\n+  *initp = inits;\n+}\n+\n+/* Like stabilize_expr, but for an initialization.  If we are initializing\n+   an object of class type, we don't want to introduce an extra temporary,\n+   so we look past the TARGET_EXPR and stabilize the arguments of the call\n+   instead.  */\n+\n+bool\n+stabilize_init (tree init, tree *initp)\n+{\n+  tree t = init;\n+\n+  if (t == error_mark_node)\n+    return true;\n+\n+  if (TREE_CODE (t) == INIT_EXPR\n+      && TREE_CODE (TREE_OPERAND (t, 1)) != TARGET_EXPR)\n+    TREE_OPERAND (t, 1) = stabilize_expr (TREE_OPERAND (t, 1), initp);\n+  else\n+    {\n+      if (TREE_CODE (t) == INIT_EXPR)\n+\tt = TREE_OPERAND (t, 1);\n+      if (TREE_CODE (t) == TARGET_EXPR)\n+\tt = TARGET_EXPR_INITIAL (t);\n+      if (TREE_CODE (t) == CONSTRUCTOR\n+\t  && CONSTRUCTOR_ELTS (t) == NULL_TREE)\n+\t{\n+\t  /* Default-initialization.  */\n+\t  *initp = NULL_TREE;\n+\t  return true;\n+\t}\n+\n+      /* If the initializer is a COND_EXPR, we can't preevaluate\n+\t anything.  */\n+      if (TREE_CODE (t) == COND_EXPR)\n+\treturn false;\n+\n+      stabilize_call (t, initp);\n+    }\n+\n+  return true;\n+}\n+\n \f\n #if defined ENABLE_TREE_CHECKING && (GCC_VERSION >= 2007)\n /* Complain that some language-specific thing hanging off a tree"}, {"sha": "2bfd743e0901b0d70ed03de023c3e67004cda147", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "2c6b843a7f08560ad4c4bbc8f052e80d2a023b29", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "22d34b694163ba44f9bebdd154c8aa28f1bf37aa", "filename": "gcc/cppexp.c", "status": "modified", "additions": 15, "deletions": 13, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcppexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcppexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppexp.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6d3c53f7635b8e5a4cefbb4a5611619c4b0e0f54", "filename": "gcc/cse.c", "status": "modified", "additions": 12, "deletions": 24, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "9e3ffb4ea8b527bafb9f9e3584b8610bed79c568", "filename": "gcc/dbxout.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdbxout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdbxout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdbxout.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "220559798c00472ac7da6ee7838be83573adce01", "filename": "gcc/defaults.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "782f50280251e64aa5b31da7009e613f810e029b", "filename": "gcc/diagnostic.h", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdiagnostic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdiagnostic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdiagnostic.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d99c568380d257586c8a7d197b391ebf748d31f7", "filename": "gcc/doc/c-tree.texi", "status": "modified", "additions": 12, "deletions": 30, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fc-tree.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fc-tree.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fc-tree.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "58a890cc2628f3756e72d95d5da01b10d5c2a8ca", "filename": "gcc/doc/cfg.texi", "status": "added", "additions": 614, "deletions": 0, "changes": 614, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fcfg.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fcfg.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fcfg.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "5dbe1f79f438569467904f62f731f73101940177", "filename": "gcc/doc/gccint.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fgccint.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fgccint.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgccint.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "599b9172c77fa88ef0a7a17b99c2c7911bf56b98", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3144fd1fcb48beb4b3f33b389712e40a98449388", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 292, "deletions": 6, "changes": 298, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "b5a69d8863318cab2139e614df2868b171a47c37", "filename": "gcc/doc/passes.texi", "status": "modified", "additions": 571, "deletions": 506, "changes": 1077, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fpasses.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fpasses.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fpasses.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c5e8d33c15b483a281fbc08b3709eb46f463935d", "filename": "gcc/doc/rtl.texi", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Frtl.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Frtl.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Frtl.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "03a450a2b9943e57886f44762c6b413760d619aa", "filename": "gcc/doc/sourcebuild.texi", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fsourcebuild.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fsourcebuild.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fsourcebuild.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "df14c0f143d0c4e43c485eea047637ea565f6ab5", "filename": "gcc/doc/standards.texi", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fstandards.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Fstandards.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fstandards.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "339dc7ad1c4b216395fb4d4b8cc92372bd03febb", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "56ccd6109c2d321972d8b928772fe331093c6fbd", "filename": "gcc/doc/tree-ssa.texi", "status": "added", "additions": 1189, "deletions": 0, "changes": 1189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Ftree-ssa.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdoc%2Ftree-ssa.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftree-ssa.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "86f0191eb4f4f06d01868a8f78c983ac3ef2c34c", "filename": "gcc/dominance.c", "status": "modified", "additions": 21, "deletions": 7, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdominance.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdominance.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdominance.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ce0ccd113e48b63498fd6cbb7e08e96ffad7cf5a", "filename": "gcc/domwalk.c", "status": "added", "additions": 265, "deletions": 0, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdomwalk.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdomwalk.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "2c2138a9199340cfdddb544a296f2e12a401e2d4", "filename": "gcc/domwalk.h", "status": "added", "additions": 112, "deletions": 0, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdomwalk.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdomwalk.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdomwalk.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "cfedd13bd2852b8b1a838b8d385172422d24ea98", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 25, "deletions": 15, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ba8a3d6cf2410447e68d80b09484a3101302089f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "9b0997188bdb3e4076050003072477e490bbd37e", "filename": "gcc/et-forest.c", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fet-forest.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fet-forest.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fet-forest.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "2dfd073e70a792e1577a1d7a56b89568e2df45ef", "filename": "gcc/except.c", "status": "modified", "additions": 382, "deletions": 161, "changes": 543, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "2fed79f30fbe2211fef84549de1048221e1d5f21", "filename": "gcc/except.h", "status": "modified", "additions": 29, "deletions": 1, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "155404dc0cf4ce7c569b9d863da75e90d285b25f", "filename": "gcc/explow.c", "status": "modified", "additions": 23, "deletions": 11, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a8cd617f8599d212138616ab54bc21604ddf7fe3", "filename": "gcc/expmed.c", "status": "modified", "additions": 2, "deletions": 7, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "23e128d470472de684535db81c22d97e5bdb4728", "filename": "gcc/expr.c", "status": "modified", "additions": 554, "deletions": 178, "changes": 732, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "002bcfc892d065b2959de47a336a33a614c358c7", "filename": "gcc/expr.h", "status": "modified", "additions": 11, "deletions": 6, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fexpr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0d3532e5da694f4cfa36b2a5b26b250692cc5392", "filename": "gcc/f/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "783ebaa998b927c75fd12299ae071e7454bc0684", "filename": "gcc/f/ChangeLog.tree-ssa", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "8ec70f7af8c9d0fc4902bed8224ba2e203a54511", "filename": "gcc/f/config-lang.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ff%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ff%2Fconfig-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "96a7a5bfcdbc2dc9bdae5898b880eab112e62ee6", "filename": "gcc/final.c", "status": "modified", "additions": 4, "deletions": 6, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffinal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffinal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffinal.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "8778b63539274012db81323ee431b1916fc6045f", "filename": "gcc/flags.h", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fflags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fflags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflags.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "fa47f2d24a03c55f9c4229514b87acfa948f014f", "filename": "gcc/flow.c", "status": "modified", "additions": 2, "deletions": 68, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fflow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fflow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fflow.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ed54ee93bb615b138227800ab8063ecbd8031438", "filename": "gcc/fold-const.c", "status": "modified", "additions": 716, "deletions": 61, "changes": 777, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "da7ce896169af7e50e8724c535ff23826ec539bc", "filename": "gcc/fortran/.cvsignore", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2F.cvsignore", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2F.cvsignore", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2F.cvsignore?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "765dfe62e3b3c6cf9d05b17a26f48e7d5865b2f4", "filename": "gcc/fortran/CONTRIB", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FCONTRIB", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FCONTRIB", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FCONTRIB?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "4e927638feea653867c087f182fa2f533fe1912d", "filename": "gcc/fortran/ChangeLog", "status": "added", "additions": 3068, "deletions": 0, "changes": 3068, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a38834b471371bb1be293f66cfd80e9414bb3556", "filename": "gcc/fortran/Make-lang.in", "status": "added", "additions": 300, "deletions": 0, "changes": 300, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FMake-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ce466feef812823edcf51efc130fad88728ae911", "filename": "gcc/fortran/NEWS", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FNEWS", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FNEWS", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FNEWS?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "fc28c995200672ff59bc0fe5464b866fc4cacbb9", "filename": "gcc/fortran/README", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FREADME?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "023ac34b0a056346a3be2ebe87e23bf65fadb41e", "filename": "gcc/fortran/TODO", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FTODO", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2FTODO", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FTODO?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "bd03fba4046eb79cb2e517da4859c056f62eba9f", "filename": "gcc/fortran/arith.c", "status": "added", "additions": 2763, "deletions": 0, "changes": 2763, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farith.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farith.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3e629eee57fd9a3aee64f7692b092e4b383efdfb", "filename": "gcc/fortran/arith.h", "status": "added", "additions": 91, "deletions": 0, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farith.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farith.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farith.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6ab5f83b9a39ee60b504549e9f9ae138724ccfd0", "filename": "gcc/fortran/array.c", "status": "added", "additions": 1973, "deletions": 0, "changes": 1973, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farray.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Farray.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Farray.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "5846ccd4d399a7135018ce8583c1b760ce2493de", "filename": "gcc/fortran/bbt.c", "status": "added", "additions": 201, "deletions": 0, "changes": 201, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fbbt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fbbt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fbbt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "e37964df85d0839d779288c6e0346fb8544af778", "filename": "gcc/fortran/check.c", "status": "added", "additions": 1866, "deletions": 0, "changes": 1866, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fcheck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fcheck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fcheck.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c638dcbaf480f87b09f434f0b75437a794998123", "filename": "gcc/fortran/config-lang.in", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fconfig-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fconfig-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconfig-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "9759f057f50f88b92de8b6c91b7286f2a3748e3d", "filename": "gcc/fortran/convert.c", "status": "added", "additions": 124, "deletions": 0, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fconvert.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fconvert.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fconvert.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7977b335836f0fee5377f190d4695ace7b6958cb", "filename": "gcc/fortran/data.c", "status": "added", "additions": 457, "deletions": 0, "changes": 457, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdata.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "1bc91c18393761974499975aec6bf8c4d61df05e", "filename": "gcc/fortran/decl.c", "status": "added", "additions": 2649, "deletions": 0, "changes": 2649, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "03edb8f169f9b292b0dd060b30c6f4e9afecc597", "filename": "gcc/fortran/dependency.c", "status": "added", "additions": 679, "deletions": 0, "changes": 679, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdependency.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdependency.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "42a33947505fb42fba2b1bec943d535b0c69f7b3", "filename": "gcc/fortran/dependency.h", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdependency.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdependency.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdependency.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "1083c6474bf915120b883442a2dbeab839d9b33b", "filename": "gcc/fortran/dump-parse-tree.c", "status": "added", "additions": 1459, "deletions": 0, "changes": 1459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "be3d991f55d340b7633da532412634bf8eef1f44", "filename": "gcc/fortran/error.c", "status": "added", "additions": 750, "deletions": 0, "changes": 750, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ferror.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "78a8dc29998735a5a6416c1b14c266f8a8c03390", "filename": "gcc/fortran/expr.c", "status": "added", "additions": 1954, "deletions": 0, "changes": 1954, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "51ce3c4e5302ee562273a76fb32e54081c6da89c", "filename": "gcc/fortran/f95-lang.c", "status": "added", "additions": 838, "deletions": 0, "changes": 838, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ff95-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ff95-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ff95-lang.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "71665dd6d077aab1548abfa9a16e10b348618068", "filename": "gcc/fortran/gfortran.h", "status": "added", "additions": 1652, "deletions": 0, "changes": 1652, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "9b6477e8e4b760a028e00cd663a900ba91a9e111", "filename": "gcc/fortran/gfortran.texi", "status": "added", "additions": 829, "deletions": 0, "changes": 829, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortran.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortran.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "bbf9fa372eb0c9c4ced1ca840607a37bcd4904d0", "filename": "gcc/fortran/gfortranspec.c", "status": "added", "additions": 548, "deletions": 0, "changes": 548, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortranspec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fgfortranspec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortranspec.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "aa31985c7ecfb28d4de9f8c85070acb7517416cb", "filename": "gcc/fortran/interface.c", "status": "added", "additions": 1858, "deletions": 0, "changes": 1858, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3d05b72ca04ba64ffb727b80669da8fa8de97000", "filename": "gcc/fortran/intrinsic.c", "status": "added", "additions": 2560, "deletions": 0, "changes": 2560, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "723d1051db11db04841010346ad19325af3501f8", "filename": "gcc/fortran/intrinsic.h", "status": "added", "additions": 314, "deletions": 0, "changes": 314, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fintrinsic.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fintrinsic.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "88330e1bda01df93680bafd3e9f3e8e65957cf58", "filename": "gcc/fortran/invoke.texi", "status": "added", "additions": 656, "deletions": 0, "changes": 656, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finvoke.texi?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "5e7240d1622265eecd4637b20659247abeca4e72", "filename": "gcc/fortran/io.c", "status": "added", "additions": 2409, "deletions": 0, "changes": 2409, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fio.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fio.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fio.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "24205939d3bc98b9e80bb4f4707bb674d3f68dc8", "filename": "gcc/fortran/iresolve.c", "status": "added", "additions": 1377, "deletions": 0, "changes": 1377, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Firesolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Firesolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Firesolve.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3d8d7c4cbcafae2e2b7c65f633adf5dcae2ea0e8", "filename": "gcc/fortran/lang-specs.h", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Flang-specs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Flang-specs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang-specs.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "593e3f15eedd8860b39ee2020c5b94cdf06b8b37", "filename": "gcc/fortran/lang.opt", "status": "added", "additions": 152, "deletions": 0, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Flang.opt?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3c7504159a98c80959b9b5db6b76265fb659fe4d", "filename": "gcc/fortran/match.c", "status": "added", "additions": 3558, "deletions": 0, "changes": 3558, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6cd71339c49ef3783042067cae422b00dea880f0", "filename": "gcc/fortran/match.h", "status": "added", "additions": 164, "deletions": 0, "changes": 164, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "4acd98e66fc27aeccd4e95e979c247771a9b0f44", "filename": "gcc/fortran/matchexp.c", "status": "added", "additions": 776, "deletions": 0, "changes": 776, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatchexp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmatchexp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatchexp.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c46c1d523a5d4afa71fd7fa903be84d630e2e568", "filename": "gcc/fortran/mathbuiltins.def", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmathbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmathbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmathbuiltins.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "1054386e0e3a61501bc62f29db31b3e87de47875", "filename": "gcc/fortran/misc.c", "status": "added", "additions": 327, "deletions": 0, "changes": 327, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmisc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmisc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmisc.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3498f75d46373dfb5edf6b047a474757dde2b9c5", "filename": "gcc/fortran/module.c", "status": "added", "additions": 3459, "deletions": 0, "changes": 3459, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmodule.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fmodule.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmodule.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7d6d8f31efc5ab0e6f4def37def2b4d55e2d5d11", "filename": "gcc/fortran/options.c", "status": "added", "additions": 320, "deletions": 0, "changes": 320, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Foptions.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Foptions.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Foptions.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6494ba8e5780039a17c80a14bdc78159252bb887", "filename": "gcc/fortran/parse.c", "status": "added", "additions": 2503, "deletions": 0, "changes": 2503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7598441d736f455019d7c82301ab19f15a488252", "filename": "gcc/fortran/parse.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fparse.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fparse.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "03e975776ea816bd7a4d9a69a3aed91c3355b1fd", "filename": "gcc/fortran/primary.c", "status": "added", "additions": 2214, "deletions": 0, "changes": 2214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "cec47165c02456ee9bf24178b864a81bca85cbbd", "filename": "gcc/fortran/resolve.c", "status": "added", "additions": 4435, "deletions": 0, "changes": 4435, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c3e3acb8bf34b424365a861eef9703c7dce10d17", "filename": "gcc/fortran/scanner.c", "status": "added", "additions": 1073, "deletions": 0, "changes": 1073, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fscanner.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fscanner.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fscanner.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "876eb2fdaf1580e2414c4bd171eec0e99f70708d", "filename": "gcc/fortran/simplify.c", "status": "added", "additions": 4008, "deletions": 0, "changes": 4008, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fsimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fsimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsimplify.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c4f4533e94fa44b5839f0fad2db6662f4aeb3a68", "filename": "gcc/fortran/st.c", "status": "added", "additions": 186, "deletions": 0, "changes": 186, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "1bf32b241e7e494842f4d36213b09c751240bda8", "filename": "gcc/fortran/symbol.c", "status": "added", "additions": 2417, "deletions": 0, "changes": 2417, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fsymbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Fsymbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fsymbol.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "452b0fec81c9b5566b2d857b884fbbedfdca1605", "filename": "gcc/fortran/trans-array.c", "status": "added", "additions": 4158, "deletions": 0, "changes": 4158, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "fe3f9ce707df48af914eccd7dbe84949c53e7003", "filename": "gcc/fortran/trans-array.h", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-array.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-array.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0c9541918189045a6670f829fb5b94630fcdf46f", "filename": "gcc/fortran/trans-common.c", "status": "added", "additions": 756, "deletions": 0, "changes": 756, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-common.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a0a72911834d288ddb7a1e8c8b32e7cc9892e3d7", "filename": "gcc/fortran/trans-const.c", "status": "added", "additions": 375, "deletions": 0, "changes": 375, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a500ddf8f45a0dcffc2fb1f85214e5c6a0551474", "filename": "gcc/fortran/trans-const.h", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-const.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-const.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-const.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "79e8cf6927eec140101d6c1db8799d8d263fb16f", "filename": "gcc/fortran/trans-decl.c", "status": "added", "additions": 2137, "deletions": 0, "changes": 2137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "864b006c536d410f58316bc10179b3f0c06d0b95", "filename": "gcc/fortran/trans-expr.c", "status": "added", "additions": 1835, "deletions": 0, "changes": 1835, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "fb3ceb2f6b1b53fd4f248dc16596828974375771", "filename": "gcc/fortran/trans-intrinsic.c", "status": "added", "additions": 3003, "deletions": 0, "changes": 3003, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d18bb7941956d7a3de1a70f38e6d3f192c07b06d", "filename": "gcc/fortran/trans-io.c", "status": "added", "additions": 1157, "deletions": 0, "changes": 1157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-io.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-io.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-io.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0de62a5367cc05a77f33b812962650891f82ddf4", "filename": "gcc/fortran/trans-stmt.c", "status": "added", "additions": 3159, "deletions": 0, "changes": 3159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ff62dd5b017755955c591e78826648df0e7cffb2", "filename": "gcc/fortran/trans-stmt.h", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "129438915824a20736bac3ef290bffca3f3bb633", "filename": "gcc/fortran/trans-types.c", "status": "added", "additions": 1485, "deletions": 0, "changes": 1485, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "b401499deb8f692354a888534b851257810409a0", "filename": "gcc/fortran/trans-types.h", "status": "added", "additions": 143, "deletions": 0, "changes": 143, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-types.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans-types.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "aed764d0a36f6a4b294a64a4284a1c3cc5b8b079", "filename": "gcc/fortran/trans.c", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d5b31376e81e5020e2b0799f55394141d505cb09", "filename": "gcc/fortran/trans.h", "status": "added", "additions": 534, "deletions": 0, "changes": 534, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "322227bc49528b0d74a4d3a3a5f8f8d208815289", "filename": "gcc/function.c", "status": "modified", "additions": 102, "deletions": 436, "changes": 538, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "4c7537eba6db6b41ee5b6cd8cb47a920342f74bf", "filename": "gcc/function.h", "status": "modified", "additions": 33, "deletions": 55, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffunction.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ffunction.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0c61555e00c8fd9082f73a553c4a0bda9d2bd7f5", "filename": "gcc/gcc.c", "status": "modified", "additions": 26, "deletions": 2, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "9e6ced54dd1f2ad1d8ba955ba12a50e91a2b2a6f", "filename": "gcc/gcse.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "753cd9e73bc75d05e8219e9a5a1f941ffa9e2760", "filename": "gcc/gdbinit.in", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgdbinit.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgdbinit.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbinit.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "245c65599b1c7baee03e6e89e8af7c483b4f8065", "filename": "gcc/genattrtab.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgenattrtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgenattrtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenattrtab.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "19d7691f35e9a612ed3c553bb0828c3af714441a", "filename": "gcc/gengtype-lex.l", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype-lex.l", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype-lex.l", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-lex.l?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "02136dc0d2974f2b4657a61baa4365b92a6087e7", "filename": "gcc/gengtype-yacc.y", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype-yacc.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype-yacc.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype-yacc.y?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "1b56a839fcc1393151ac58450355c39e5e122506", "filename": "gcc/gengtype.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgengtype.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgengtype.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c727fec97c59cebdd8b3b5a1d099e89aa611da60", "filename": "gcc/genrecog.c", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgenrecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgenrecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenrecog.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "af2760279bc10ca92f744d528449d7acaaf44582", "filename": "gcc/gimple-low.c", "status": "added", "additions": 472, "deletions": 0, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgimple-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgimple-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-low.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "dda218beab4e0dd282919a2b18789484a00faa0e", "filename": "gcc/gimplify.c", "status": "added", "additions": 3754, "deletions": 0, "changes": 3754, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fgimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimplify.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6a212f1ccc27936dc1bdeb674a7a0c32b5501eb3", "filename": "gcc/haifa-sched.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fhaifa-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fhaifa-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fhaifa-sched.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a6066da2151e944ab64f8c4c37039fb07b496ffa", "filename": "gcc/ifcvt.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fifcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fifcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fifcvt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "6e11023a900aadf189aecbaf8454b3af29ec3590", "filename": "gcc/input.h", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Finput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Finput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finput.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "de897176ea0ccafa5fe9a040017cd67264091de5", "filename": "gcc/integrate.c", "status": "modified", "additions": 20, "deletions": 1827, "changes": 1847, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fintegrate.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fintegrate.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "88a4f5ddeb756b6e45f17d41a7f43082676cb895", "filename": "gcc/integrate.h", "status": "modified", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fintegrate.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fintegrate.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fintegrate.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7ac2ba595549f81a492257d8dfaabd688611f8af", "filename": "gcc/java/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "81081a5286096c43525509abce3cc47010ceefbb", "filename": "gcc/java/ChangeLog.tree-ssa", "status": "added", "additions": 360, "deletions": 0, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "db3ac9d55312789cbcb5eaff5dcf96587d7920b4", "filename": "gcc/java/Make-lang.in", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FMake-lang.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2FMake-lang.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2FMake-lang.in?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "77f0c58210570ff49d7ec6ab56d5a8e3034d269a", "filename": "gcc/java/builtins.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fbuiltins.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "f325c4e80abe3c43305b6d98ce58da3a4abcaa10", "filename": "gcc/java/check-init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fcheck-init.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fcheck-init.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fcheck-init.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "137b647d1915aa2c4754b25ec3dcf6a8251d272b", "filename": "gcc/java/class.c", "status": "modified", "additions": 8, "deletions": 34, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fclass.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "32fc854c9dbe31cf66e24343c8451ef916a14456", "filename": "gcc/java/constants.c", "status": "modified", "additions": 23, "deletions": 19, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fconstants.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fconstants.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fconstants.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7a36e54ffb92eca25d4c8a30e6baeb65efbc09fc", "filename": "gcc/java/decl.c", "status": "modified", "additions": 246, "deletions": 202, "changes": 448, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fdecl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "b77842e8a662a5a6722a5e320439fa1232918b1a", "filename": "gcc/java/except.c", "status": "modified", "additions": 65, "deletions": 10, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexcept.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a63309ec9a43661ceba6c07b9f3dc5fe37c4467e", "filename": "gcc/java/expr.c", "status": "modified", "additions": 205, "deletions": 129, "changes": 334, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fexpr.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0646d61b591261c273d428ef01247f32d3c88b8a", "filename": "gcc/java/java-except.h", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-except.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-except.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-except.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ae8acd54c1249debfe6e7c40992ccd4fed020be6", "filename": "gcc/java/java-gimplify.c", "status": "added", "additions": 277, "deletions": 0, "changes": 277, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-gimplify.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-gimplify.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-gimplify.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "25ee5386205cc5a3ab30a851c42d872cbbb16a0e", "filename": "gcc/java/java-tree.def", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-tree.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-tree.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "b04ee4b0a954ef62cb0860538afa85ae33d0888d", "filename": "gcc/java/java-tree.h", "status": "modified", "additions": 31, "deletions": 5, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjava-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjava-tree.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a44e860a242fd10ee336aaf79c7d0eb57f32b843", "filename": "gcc/java/jcf-parse.c", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjcf-parse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjcf-parse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-parse.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c715a2c1ed827bb248ce308af6873c8ab7ab2001", "filename": "gcc/java/jcf-write.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjcf-write.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fjcf-write.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fjcf-write.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "20f13e5adb24bccb4874f5b787400d05b0dd3870", "filename": "gcc/java/lang.c", "status": "modified", "additions": 14, "deletions": 138, "changes": 152, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Flang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Flang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ae367a718a53bf80d7b7ee3727c828a990bd4b71", "filename": "gcc/java/lang.opt", "status": "modified", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Flang.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Flang.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Flang.opt?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d6c597f4a52134cb7ff2f96b58c8357d3e56ed5e", "filename": "gcc/java/parse.y", "status": "modified", "additions": 65, "deletions": 126, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fparse.y?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "dc42a6f6e7e5cab15dcb6e5611f2a212d816f284", "filename": "gcc/java/resource.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fresource.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjava%2Fresource.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjava%2Fresource.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "2b46f7bc991f3e9d88dfc0e308a1011863c08446", "filename": "gcc/jump.c", "status": "modified", "additions": 2, "deletions": 359, "changes": 361, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "594103e129238da150ee7d5875819492b5adfa6a", "filename": "gcc/langhooks-def.h", "status": "modified", "additions": 17, "deletions": 13, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks-def.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "58e4eb6b21d896be862e48f410e308be21016a69", "filename": "gcc/langhooks.c", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "92bf00b61c2162eade7d44208fe8076e65aa8119", "filename": "gcc/langhooks.h", "status": "modified", "additions": 18, "deletions": 17, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Flanghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flanghooks.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "bec59c061ae48c440fe50a548d4279b09d8b8ea8", "filename": "gcc/objc/objc-act.c", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fobjc%2Fobjc-act.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fobjc%2Fobjc-act.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-act.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "cdc5453687c709bc80df12e8bb0534f995813f9d", "filename": "gcc/objc/objc-lang.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fobjc%2Fobjc-lang.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fobjc%2Fobjc-lang.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fobjc%2Fobjc-lang.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c8a488f5d4575cfd4eef3938c3e4d2cc724fe6df", "filename": "gcc/opts.c", "status": "modified", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fopts.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "945dace71d2f0dfa7923eceeadf1270c1d9c986a", "filename": "gcc/output.h", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ff77eb488ce7a07cab7815537293ba7fcf129503", "filename": "gcc/params.def", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "996f7a0b77e5a485652d3d9151b6468a29391eb7", "filename": "gcc/params.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fparams.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fparams.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "43b46e2cae7f2dd657d9354b499bd775f7b94f86", "filename": "gcc/passes.c", "status": "modified", "additions": 39, "deletions": 217, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpasses.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpasses.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "271698bd2d18a62162d4f1a2e8dd392596d7da46", "filename": "gcc/predict.c", "status": "modified", "additions": 432, "deletions": 77, "changes": 509, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "836d853b379081e18fbce01e96dfcfc2e76623bb", "filename": "gcc/predict.def", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "16817f9b5b643e820432f223dc2af2a585eb7027", "filename": "gcc/predict.h", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpredict.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "46cae27504cb5ec13450cb98f5f35170a033eb4a", "filename": "gcc/pretty-print.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpretty-print.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpretty-print.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "8c568a42f4d3fd019099f2e829630417da632164", "filename": "gcc/pretty-print.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpretty-print.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fpretty-print.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpretty-print.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "66f0a01f06352b85040ed392ce8bf82c488389ad", "filename": "gcc/print-rtl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprint-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprint-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-rtl.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "fd90b181f4636b19c5e8a395f26f95c42151fc74", "filename": "gcc/print-tree.c", "status": "modified", "additions": 12, "deletions": 8, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprint-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprint-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprint-tree.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0468a0f828420f41d6418a78ec89ebaaa068e402", "filename": "gcc/profile.c", "status": "modified", "additions": 83, "deletions": 379, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7479860798e0a8d9c2b216268731b5073c6189d1", "filename": "gcc/ra-rewrite.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fra-rewrite.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fra-rewrite.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fra-rewrite.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d7c950724008860eff5610a87bb6cb0ec8534b6e", "filename": "gcc/recog.c", "status": "modified", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "c100bdeabacee620ecac992500f3aa4835c50ba8", "filename": "gcc/regs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fregs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fregs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fregs.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "ae211302efa5037b71e4e19bf395bd9ecba02cf7", "filename": "gcc/reload.c", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Freload.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Freload.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freload.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a53a00464a951cbcf1f819a6b1bf763d23deb1cc", "filename": "gcc/rtl-profile.c", "status": "added", "additions": 424, "deletions": 0, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl-profile.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "3eecf1fb79edaaef9c8e33bffb955802d59e54ed", "filename": "gcc/rtl.def", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.def?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "d5f7a1ec644b288f0fdfaa432d81b48bc10265c1", "filename": "gcc/rtl.h", "status": "modified", "additions": 13, "deletions": 26, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "a52f614b8785a7f14a9010538ec2cdc19e389f99", "filename": "gcc/rtlanal.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtlanal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Frtlanal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtlanal.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "dfd764528cb05fe608cac46eb6958d03809f372c", "filename": "gcc/sbitmap.c", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsbitmap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsbitmap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0ddc0d051c68807c6c4f240935719cd53f1e8249", "filename": "gcc/sbitmap.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsbitmap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsbitmap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsbitmap.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "cfd1a629c62dd98688c52e889c0c3409ecfb3af2", "filename": "gcc/sibcall.c", "status": "removed", "additions": 0, "deletions": 753, "changes": 753, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ac1a20aec53364d77f3bdff94a2a0a06840e0fe9/gcc%2Fsibcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ac1a20aec53364d77f3bdff94a2a0a06840e0fe9/gcc%2Fsibcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsibcall.c?ref=ac1a20aec53364d77f3bdff94a2a0a06840e0fe9"}, {"sha": "680ecafc21a7d353102e03b7f83fd846820f6979", "filename": "gcc/simplify-rtx.c", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsimplify-rtx.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsimplify-rtx.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsimplify-rtx.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "0baeb8ce27281183aabf57a3b2a95654c663a65e", "filename": "gcc/stmt.c", "status": "modified", "additions": 215, "deletions": 600, "changes": 815, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "13f95a44ff5bf1f28ed0426a9ab175a1bf9e190c", "filename": "gcc/stor-layout.c", "status": "modified", "additions": 9, "deletions": 7, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fstor-layout.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fstor-layout.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstor-layout.c?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "56aeb25fa0b0b9885f3132a2818061c8c719a6db", "filename": "gcc/system.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsystem.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Fsystem.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsystem.h?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "7f62d4b07db7685be8c1ffb008e0632da8ad7d07", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "03ccbb01ed2f12c97ffbdffe3543af00d6811e6b", "filename": "gcc/testsuite/ChangeLog.tree-ssa", "status": "added", "additions": 1204, "deletions": 0, "changes": 1204, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2FChangeLog.tree-ssa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2FChangeLog.tree-ssa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog.tree-ssa?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "14b736e7a731b9f60db3357b6614dbe99af1ae8b", "filename": "gcc/testsuite/g++.dg/README", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2FREADME?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "f3e3e4216fb678e8421f76e63e1cf47ced921dd5", "filename": "gcc/testsuite/g++.dg/eh/goto1.C", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fgoto1.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "5eff16ffe7cb98121cdb520524c7d2351e723c0d", "filename": "gcc/testsuite/g++.dg/ext/asm3.C", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fasm3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fasm3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Fasm3.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "604bfdc12c3cb4d4b69798465b5afd3d48b465a0", "filename": "gcc/testsuite/g++.dg/ext/label3.C", "status": "added", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fext%2Flabel3.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "93c67bdd70673bc241137f3ebc828eac1faf3d65", "filename": "gcc/testsuite/g++.dg/init/pmf1.C", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpmf1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpmf1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fpmf1.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "78cdebe32aa5b4ca8d11cffeef2ee0901c0b6adf", "filename": "gcc/testsuite/g++.dg/opt/bool1.C", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fbool1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fbool1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fbool1.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}, {"sha": "94522ed4171f6623bae496c5d88a028005b6f9be", "filename": "gcc/testsuite/g++.dg/opt/cfg4.C", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcfg4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcfg4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fopt%2Fcfg4.C?ref=6de9cd9a886ea695aa892c3c7c07818a7b7e9e6f"}]}