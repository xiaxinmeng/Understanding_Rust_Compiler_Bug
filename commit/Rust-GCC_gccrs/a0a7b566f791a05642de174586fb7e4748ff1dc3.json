{"sha": "a0a7b566f791a05642de174586fb7e4748ff1dc3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTBhN2I1NjZmNzkxYTA1NjQyZGUxNzQ1ODZmYjdlNDc0OGZmMWRjMw==", "commit": {"author": {"name": "Bernd Schmidt", "email": "bernds@redhat.com", "date": "2001-04-20T12:19:47Z"}, "committer": {"name": "Bernd Schmidt", "email": "bernds@gcc.gnu.org", "date": "2001-04-20T12:19:47Z"}, "message": "Better scheduling of shifts\n\nFrom-SVN: r41458", "tree": {"sha": "e5eaf4a88d20827e4dfe19518bacfe473df1bd1d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/e5eaf4a88d20827e4dfe19518bacfe473df1bd1d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a0a7b566f791a05642de174586fb7e4748ff1dc3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7b566f791a05642de174586fb7e4748ff1dc3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a0a7b566f791a05642de174586fb7e4748ff1dc3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a0a7b566f791a05642de174586fb7e4748ff1dc3/comments", "author": null, "committer": null, "parents": [{"sha": "a6f5b6f9581a40f14776e32713acbafe46d812be", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a6f5b6f9581a40f14776e32713acbafe46d812be", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a6f5b6f9581a40f14776e32713acbafe46d812be"}], "stats": {"total": 172, "additions": 165, "deletions": 7}, "files": [{"sha": "893f79d22840708a1f2d8450c2378b0a26374087", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=a0a7b566f791a05642de174586fb7e4748ff1dc3", "patch": "@@ -1,3 +1,16 @@\n+2001-04-20  Bernd Schmidt  <bernds@redhat.com>\n+\n+\t* ia64.h (MD_SCHED_REORDER, MD_SCHED_REORDER2): Pass CLOCK to called\n+\tfunction.\n+\t* ia64-protos.h (ia64_sched_reorder): Additional arg for clock.\n+\t* ia64.c (nop_cycles_until): New function.\n+\t(prev_cycle, prev_first, last_issued): New static variables.\n+\t(ia64_sched_reorder): Additional arg for clock.\n+\tOn final scheduling pass, emit extra NOPs as needed.\n+\tSet prev_first and prev_cycle.\n+\t(ia64_sched_reorder2): Pass clock arg down to ia64_sched_reorder.\n+\t(ia64_variable_issue): Set last_issued.\n+\n 2001-04-20  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* config/i386/i386.c (ix86_expand_int_movcc,"}, {"sha": "a5c2848b3cf45646724e6e278fc8124a560c93f2", "filename": "gcc/config/ia64/ia64-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64-protos.h?ref=a0a7b566f791a05642de174586fb7e4748ff1dc3", "patch": "@@ -97,7 +97,7 @@ extern int ia64_issue_rate PARAMS ((void));\n extern int ia64_adjust_cost PARAMS ((rtx, rtx, rtx, int));\n extern void ia64_sched_init PARAMS ((FILE *, int, int));\n extern void ia64_sched_finish PARAMS ((FILE *, int));\n-extern int ia64_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int));\n+extern int ia64_sched_reorder PARAMS ((FILE *, int, rtx *, int *, int, int));\n extern int ia64_sched_reorder2 PARAMS ((FILE *, int, rtx *, int *, int));\n extern int ia64_variable_issue PARAMS ((FILE *, int, rtx, int));\n #endif /* RTX_CODE */"}, {"sha": "de8d2abf91ff5dc582ff42decaff311b93c47e02", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 149, "deletions": 4, "changes": 153, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=a0a7b566f791a05642de174586fb7e4748ff1dc3", "patch": "@@ -4901,6 +4901,7 @@ static void maybe_rotate PARAMS ((FILE *));\n static void finish_last_head PARAMS ((FILE *, int));\n static void rotate_one_bundle PARAMS ((FILE *));\n static void rotate_two_bundles PARAMS ((FILE *));\n+static void nop_cycles_until PARAMS ((int, FILE *));\n static void cycle_end_fill_slots PARAMS ((FILE *));\n static int packet_matches_p PARAMS ((const struct ia64_packet *, int, int *));\n static int get_split PARAMS ((const struct ia64_packet *, int));\n@@ -5780,16 +5781,125 @@ maybe_rotate (dump)\n   sched_data.first_slot = sched_data.cur;\n }\n \n+/* The clock cycle when ia64_sched_reorder was last called.  */\n+static int prev_cycle;\n+\n+/* The first insn scheduled in the previous cycle.  This is the saved\n+   value of sched_data.first_slot.  */\n+static int prev_first;\n+\n+/* The last insn that has been scheduled.  At the start of a new cycle\n+   we know that we can emit new insns after it; the main scheduling code\n+   has already emitted a cycle_display insn after it and is using that\n+   as its current last insn.  */\n+static rtx last_issued;\n+\n+/* Emit NOPs to fill the delay between PREV_CYCLE and CLOCK_VAR.  Used to\n+   pad out the delay between MM (shifts, etc.) and integer operations.  */\n+\n+static void\n+nop_cycles_until (clock_var, dump)\n+     int clock_var;\n+     FILE *dump;\n+{\n+  int prev_clock = prev_cycle;\n+  int cycles_left = clock_var - prev_clock;\n+\n+  /* Finish the previous cycle; pad it out with NOPs.  */\n+  if (sched_data.cur == 3)\n+    {\n+      rtx t = gen_insn_group_barrier (GEN_INT (3));\n+      last_issued = emit_insn_after (t, last_issued);\n+      maybe_rotate (dump);\n+    }\n+  else if (sched_data.cur > 0)\n+    {\n+      int need_stop = 0;\n+      int split = itanium_split_issue (sched_data.packet, prev_first);\n+\n+      if (sched_data.cur < 3 && split > 3)\n+\t{\n+\t  split = 3;\n+\t  need_stop = 1;\n+\t}\n+\n+      if (split > sched_data.cur)\n+\t{\n+\t  int i;\n+\t  for (i = sched_data.cur; i < split; i++)\n+\t    {\n+\t      rtx t;\n+\n+\t      t = gen_nop_type (sched_data.packet->t[i]);\n+\t      last_issued = emit_insn_after (t, last_issued);\n+\t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n+\t      sched_data.insns[i] = last_issued;\n+\t      sched_data.stopbit[i] = 0;\n+\t    }\n+\t  sched_data.cur = split;\n+\t}\n+\n+      if (! need_stop && sched_data.cur > 0 && sched_data.cur < 6\n+\t  && cycles_left > 1)\n+\t{\n+\t  int i;\n+\t  for (i = sched_data.cur; i < 6; i++)\n+\t    {\n+\t      rtx t;\n+\n+\t      t = gen_nop_type (sched_data.packet->t[i]);\n+\t      last_issued = emit_insn_after (t, last_issued);\n+\t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n+\t      sched_data.insns[i] = last_issued;\n+\t      sched_data.stopbit[i] = 0;\n+\t    }\n+\t  sched_data.cur = 6;\n+\t  cycles_left--;\n+\t  need_stop = 1;\n+\t}\n+\n+      if (need_stop || sched_data.cur == 6)\n+\t{\n+\t  rtx t = gen_insn_group_barrier (GEN_INT (3));\n+\t  last_issued = emit_insn_after (t, last_issued);\n+\t}\n+      maybe_rotate (dump);\n+    }\n+\n+  cycles_left--;\n+  while (cycles_left > 0)\n+    {\n+      rtx t = gen_bundle_selector (GEN_INT (0));\n+      last_issued = emit_insn_after (t, last_issued);\n+      t = gen_nop_type (TYPE_M);\n+      last_issued = emit_insn_after (t, last_issued);\n+      t = gen_nop_type (TYPE_I);\n+      last_issued = emit_insn_after (t, last_issued);\n+      if (cycles_left > 1)\n+\t{\n+\t  t = gen_insn_group_barrier (GEN_INT (2));\n+\t  last_issued = emit_insn_after (t, last_issued);\n+\t  cycles_left--;\n+\t}\n+      t = gen_nop_type (TYPE_I);\n+      last_issued = emit_insn_after (t, last_issued);\n+      t = gen_insn_group_barrier (GEN_INT (3));\n+      last_issued = emit_insn_after (t, last_issued);\n+      cycles_left--;\n+    }\n+}\n+\n /* We are about to being issuing insns for this clock cycle.\n    Override the default sort algorithm to better slot instructions.  */\n \n int\n-ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, reorder_type)\n+ia64_sched_reorder (dump, sched_verbose, ready, pn_ready,\n+\t\t    reorder_type, clock_var)\n      FILE *dump ATTRIBUTE_UNUSED;\n      int sched_verbose ATTRIBUTE_UNUSED;\n      rtx *ready;\n      int *pn_ready;\n-     int reorder_type;\n+     int reorder_type, clock_var;\n {\n   int n_ready = *pn_ready;\n   rtx *e_ready = ready + n_ready;\n@@ -5802,6 +5912,38 @@ ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, reorder_type)\n       dump_current_packet (dump);\n     }\n \n+  if (reorder_type == 0 && clock_var > 0 && ia64_final_schedule)\n+    {\n+      for (insnp = ready; insnp < e_ready; insnp++)\n+\t{\n+\t  rtx insn = *insnp;\n+\t  enum attr_itanium_class t = ia64_safe_itanium_class (insn);\n+\t  if (t == ITANIUM_CLASS_IALU || t == ITANIUM_CLASS_ISHF\n+\t      || t == ITANIUM_CLASS_ILOG\n+\t      || t == ITANIUM_CLASS_LD || t == ITANIUM_CLASS_ST)\n+\t    {\n+\t      rtx link;\n+\t      for (link = LOG_LINKS (insn); link; link = XEXP (link, 1))\n+\t\tif (REG_NOTE_KIND (link) != REG_DEP_OUTPUT\n+\t\t    && REG_NOTE_KIND (link) != REG_DEP_ANTI)\n+\t\t  {\n+\t\t    rtx other = XEXP (link, 0);\n+\t\t    enum attr_itanium_class t0 = ia64_safe_itanium_class (other);\n+\t\t    if (t0 == ITANIUM_CLASS_MMSHF\n+\t\t\t|| t0 == ITANIUM_CLASS_MMMUL)\n+\t\t      {\n+\t\t\tnop_cycles_until (clock_var, sched_verbose ? dump : NULL);\n+\t\t\tgoto out;\n+\t\t      }\n+\t\t  }\n+\t    }\n+\t}\n+    }\n+ out:\n+\n+  prev_first = sched_data.first_slot;\n+  prev_cycle = clock_var;\n+\n   if (reorder_type == 0)\n     maybe_rotate (sched_verbose ? dump : NULL);\n \n@@ -5893,7 +6035,7 @@ ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n      int sched_verbose ATTRIBUTE_UNUSED;\n      rtx *ready;\n      int *pn_ready;\n-     int clock_var ATTRIBUTE_UNUSED;\n+     int clock_var;\n {\n   if (sched_data.last_was_stop)\n     return 0;\n@@ -5977,7 +6119,8 @@ ia64_sched_reorder2 (dump, sched_verbose, ready, pn_ready, clock_var)\n \n   if (*pn_ready > 0)\n     {\n-      int more = ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, 1);\n+      int more = ia64_sched_reorder (dump, sched_verbose, ready, pn_ready, 1,\n+\t\t\t\t     clock_var);\n       if (more)\n \treturn more;\n       /* Did we schedule a stop?  If so, finish this cycle.  */\n@@ -6006,6 +6149,8 @@ ia64_variable_issue (dump, sched_verbose, insn, can_issue_more)\n {\n   enum attr_type t = ia64_safe_type (insn);\n \n+  last_issued = insn;\n+\n   if (sched_data.last_was_stop)\n     {\n       int t = sched_data.first_slot;"}, {"sha": "d4f9eb4eb571ade8c61ded22c8d7ce8ec961c1fc", "filename": "gcc/config/ia64/ia64.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a0a7b566f791a05642de174586fb7e4748ff1dc3/gcc%2Fconfig%2Fia64%2Fia64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.h?ref=a0a7b566f791a05642de174586fb7e4748ff1dc3", "patch": "@@ -2831,10 +2831,10 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ia64_sched_init (DUMP, SCHED_VERBOSE, MAX_READY)\n \n #define MD_SCHED_REORDER(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-  (CIM) = ia64_sched_reorder (DUMP, SCHED_VERBOSE, READY, &N_READY, 0)\n+  (CIM) = ia64_sched_reorder (DUMP, SCHED_VERBOSE, READY, &N_READY, 0, CLOCK)\n \n #define MD_SCHED_REORDER2(DUMP, SCHED_VERBOSE, READY, N_READY, CLOCK, CIM) \\\n-  (CIM) = ia64_sched_reorder2 (DUMP, SCHED_VERBOSE, READY, &N_READY, 1)\n+  (CIM) = ia64_sched_reorder2 (DUMP, SCHED_VERBOSE, READY, &N_READY, CLOCK)\n \n #define MD_SCHED_FINISH(DUMP, SCHED_VERBOSE) \\\n   ia64_sched_finish (DUMP, SCHED_VERBOSE)"}]}