{"sha": "6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM1MmI3ZGZjNDU1NzhiZDg0NzBhM2I2Mjk3ZWYzYjA0ZmQzNTkyNg==", "commit": {"author": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-11-05T19:16:13Z"}, "committer": {"name": "Fran\u00e7ois Dumont", "email": "fdumont@gcc.gnu.org", "date": "2014-11-05T19:16:13Z"}, "message": "re PR libstdc++/63698 (std::set leaks nodes on assignment)\n\n2014-11-04  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n\t    Jonathan Wakely  <jwakely@redhat.com>\n\n\tPR libstdc++/63698\n\t* include/bits/stl_tree.h (_Reuse_or_alloc_node): Simplify constructor.\n\tAlways move to the left node if there is one.\n\t* testsuite/23_containers/set/allocator/move_assign.cc (test04): New.\n\nCo-Authored-By: Jonathan Wakely <jwakely@redhat.com>\n\nFrom-SVN: r217154", "tree": {"sha": "0ef3321c8827e2e4e0539c8407d4e04776903665", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ef3321c8827e2e4e0539c8407d4e04776903665"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/comments", "author": null, "committer": null, "parents": [{"sha": "e028b0bbca86c369c145a410cf06a65d729c91d6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e028b0bbca86c369c145a410cf06a65d729c91d6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e028b0bbca86c369c145a410cf06a65d729c91d6"}], "stats": {"total": 72, "additions": 61, "deletions": 11}, "files": [{"sha": "a1787638e9750c713797cf5a4c34208b3261d2ab", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "patch": "@@ -1,3 +1,11 @@\n+2014-11-05  Fran\u00e7ois Dumont  <fdumont@gcc.gnu.org>\n+\t    Jonathan Wakely  <jwakely@redhat.com>\n+\n+\tPR libstdc++/63698\n+\t* include/bits/stl_tree.h (_Reuse_or_alloc_node): Simplify constructor.\n+\tAlways move to the left node if there is one.\n+\t* testsuite/23_containers/set/allocator/move_assign.cc (test04): New.\n+\n 2014-11-04  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* include/bits/unique_ptr.h (make_unique): Use alias for trait."}, {"sha": "1e4e9e95aa70630be4b43554ef63fa0c3754c658", "filename": "libstdc++-v3/include/bits/stl_tree.h", "status": "modified", "additions": 18, "deletions": 11, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_tree.h?ref=6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "patch": "@@ -359,16 +359,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       typedef const _Rb_tree_node<_Val>*\t_Const_Link_type;\n \n     private:\n-      // Functor recycling a pool of nodes and using allocation once the pool is\n-      // empty.\n+      // Functor recycling a pool of nodes and using allocation once the pool\n+      // is empty.\n       struct _Reuse_or_alloc_node\n       {\n-\t_Reuse_or_alloc_node(const _Rb_tree_node_base& __header,\n-\t\t\t     _Rb_tree& __t)\n-\t  : _M_root(__header._M_parent), _M_nodes(__header._M_right), _M_t(__t)\n+\t_Reuse_or_alloc_node(_Rb_tree& __t)\n+\t  : _M_root(__t._M_root()), _M_nodes(__t._M_rightmost()), _M_t(__t)\n \t{\n \t  if (_M_root)\n-\t    _M_root->_M_parent = 0;\n+\t    {\n+\t      _M_root->_M_parent = 0;\n+\n+\t      if (_M_nodes->_M_left)\n+\t\t_M_nodes = _M_nodes->_M_left;\n+\t    }\n \t  else\n \t    _M_nodes = 0;\n \t}\n@@ -420,6 +424,9 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \t\t      while (_M_nodes->_M_right)\n \t\t\t_M_nodes = _M_nodes->_M_right;\n+\n+\t\t      if (_M_nodes->_M_left)\n+\t\t\t_M_nodes = _M_nodes->_M_left;\n \t\t    }\n \t\t}\n \t      else // __node is on the left.\n@@ -436,7 +443,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t_Rb_tree& _M_t;\n       };\n \n-      // Functor similar to the previous one but without any pool of node to\n+      // Functor similar to the previous one but without any pool of nodes to\n       // recycle.\n       struct _Alloc_node\n       {\n@@ -1271,7 +1278,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n       // Try to move each node reusing existing nodes and copying __x nodes\n       // structure.\n-      _Reuse_or_alloc_node __roan(_M_impl._M_header, *this);\n+      _Reuse_or_alloc_node __roan(*this);\n       _M_impl._M_reset();\n       if (__x._M_root() != nullptr)\n \t{\n@@ -1297,7 +1304,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n       _M_assign_unique(_Iterator __first, _Iterator __last)\n       {\n-\t_Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t_Reuse_or_alloc_node __roan(*this);\n \t_M_impl._M_reset();\n \tfor (; __first != __last; ++__first)\n \t  _M_insert_unique_(end(), *__first, __roan);\n@@ -1310,7 +1317,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _Rb_tree<_Key, _Val, _KeyOfValue, _Compare, _Alloc>::\n       _M_assign_equal(_Iterator __first, _Iterator __last)\n       {\n-\t_Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t_Reuse_or_alloc_node __roan(*this);\n \t_M_impl._M_reset();\n \tfor (; __first != __last; ++__first)\n \t  _M_insert_equal_(end(), *__first, __roan);\n@@ -1342,7 +1349,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t    }\n #endif\n \n-\t  _Reuse_or_alloc_node __roan(this->_M_impl._M_header, *this);\n+\t  _Reuse_or_alloc_node __roan(*this);\n \t  _M_impl._M_reset();\n \t  _M_impl._M_key_compare = __x._M_impl._M_key_compare;\n \t  if (__x._M_root() != 0)"}, {"sha": "f9f4369897349810e72d86d014187b56dccf1146", "filename": "libstdc++-v3/testsuite/23_containers/set/allocator/move_assign.cc", "status": "modified", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c52b7dfc45578bd8470a3b6297ef3b04fd35926/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Fset%2Fallocator%2Fmove_assign.cc?ref=6c52b7dfc45578bd8470a3b6297ef3b04fd35926", "patch": "@@ -18,6 +18,8 @@\n // { dg-options \"-std=gnu++11\" }\n \n #include <set>\n+#include <random>\n+\n #include <testsuite_hooks.h>\n #include <testsuite_allocator.h>\n \n@@ -89,10 +91,43 @@ void test03()\n   VERIFY( tracker_allocator_counter::get_construct_count() == constructs + 2 );\n }\n \n+void test04()\n+{\n+  bool test __attribute__((unused)) = true;\n+\n+  using namespace __gnu_test;\n+\n+  typedef tracker_allocator<int> alloc_type;\n+  typedef std::set<int, std::less<int>, alloc_type> test_type;\n+\n+  std::mt19937 rng;\n+  std::uniform_int_distribution<int> d;\n+  std::uniform_int_distribution<int>::param_type p{0, 100};\n+  std::uniform_int_distribution<int>::param_type x{0, 1000};\n+\n+  for (int i = 0; i < 10; ++i)\n+  {\n+    test_type l, r;\n+    for (int n = d(rng, p); n > 0; --n)\n+    {\n+      int i = d(rng, x);\n+      l.insert(i);\n+      r.insert(i);\n+\n+      tracker_allocator_counter::reset();\n+\n+      l = r;\n+\n+      VERIFY( tracker_allocator_counter::get_allocation_count() == 0 );\n+    }\n+  }\n+}\n+\n int main()\n {\n   test01();\n   test02();\n   test03();\n+  test04();\n   return 0;\n }"}]}