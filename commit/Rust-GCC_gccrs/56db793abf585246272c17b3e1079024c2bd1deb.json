{"sha": "56db793abf585246272c17b3e1079024c2bd1deb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTZkYjc5M2FiZjU4NTI0NjI3MmMxN2IzZTEwNzkwMjRjMmJkMWRlYg==", "commit": {"author": {"name": "Daniel Berlin", "email": "dberlin@dberlin.org", "date": "2004-06-21T21:57:33Z"}, "committer": {"name": "Daniel Berlin", "email": "dberlin@gcc.gnu.org", "date": "2004-06-21T21:57:33Z"}, "message": "re PR tree-optimization/15982 (ICE in tree-ssa-pre due to GVN-PRE)\n\n2004-06-21  Daniel Berlin  <dberlin@dberlin.org>\n\n    Fix PR optimization/15982\n    * tree-ssa-pre.c: Update a few comments and todos to\n    reflect constants change.\n    (get_value_handle): Constants now value number to themselves.\n    (lookup): Constants lookup to themselves.\n    (add_to_value): Adjust to always be on.\n    (set_contains_value): Adjust for constants change.\n    (find_leader): Ditto.\n    (phi_translate): 'r' nodes are never ANTIC right now.\n    (valid_in_set): Ditto.\n    (get_expr_set): New function.\n    (find_or_generate_expression): New function, broken out from\n    insert_aux.\n    (create_expression_by_pieces): Ditto, plus additional\n    machinery to handle complex values.\n    (compute_avail): Remove dead RETURN_EXPR handling.\n\nFrom-SVN: r83453", "tree": {"sha": "0cb1d88a086a676f6a202fc50757014d308ce347", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0cb1d88a086a676f6a202fc50757014d308ce347"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/56db793abf585246272c17b3e1079024c2bd1deb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56db793abf585246272c17b3e1079024c2bd1deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56db793abf585246272c17b3e1079024c2bd1deb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56db793abf585246272c17b3e1079024c2bd1deb/comments", "author": {"login": "dberlin", "id": 324715, "node_id": "MDQ6VXNlcjMyNDcxNQ==", "avatar_url": "https://avatars.githubusercontent.com/u/324715?v=4", "gravatar_id": "", "url": "https://api.github.com/users/dberlin", "html_url": "https://github.com/dberlin", "followers_url": "https://api.github.com/users/dberlin/followers", "following_url": "https://api.github.com/users/dberlin/following{/other_user}", "gists_url": "https://api.github.com/users/dberlin/gists{/gist_id}", "starred_url": "https://api.github.com/users/dberlin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/dberlin/subscriptions", "organizations_url": "https://api.github.com/users/dberlin/orgs", "repos_url": "https://api.github.com/users/dberlin/repos", "events_url": "https://api.github.com/users/dberlin/events{/privacy}", "received_events_url": "https://api.github.com/users/dberlin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8bc527afe92d96fd31972cfa4362cc1023e523e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bc527afe92d96fd31972cfa4362cc1023e523e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bc527afe92d96fd31972cfa4362cc1023e523e9"}], "stats": {"total": 411, "additions": 243, "deletions": 168}, "files": [{"sha": "51d4e189dfa0772f1a2f8b88911c2ee9f72f1d9e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56db793abf585246272c17b3e1079024c2bd1deb/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56db793abf585246272c17b3e1079024c2bd1deb/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=56db793abf585246272c17b3e1079024c2bd1deb", "patch": "@@ -1,3 +1,22 @@\n+2004-06-21  Daniel Berlin  <dberlin@dberlin.org>\n+    \n+    Fix PR optimization/15982\n+    * tree-ssa-pre.c: Update a few comments and todos to\n+    reflect constants change.\n+    (get_value_handle): Constants now value number to themselves.\n+    (lookup): Constants lookup to themselves.\n+    (add_to_value): Adjust to always be on.\n+    (set_contains_value): Adjust for constants change.\n+    (find_leader): Ditto.\n+    (phi_translate): 'r' nodes are never ANTIC right now.\n+    (valid_in_set): Ditto.\n+    (get_expr_set): New function.\n+    (find_or_generate_expression): New function, broken out from\n+    insert_aux.\n+    (create_expression_by_pieces): Ditto, plus additional\n+    machinery to handle complex values.\n+    (compute_avail): Remove dead RETURN_EXPR handling.\n+\n 2004-06-21  Steven Bosscher  <stevenb@suse.de>\n \n \t* config/i386/i386.c: Include insn-codes.h"}, {"sha": "c8d8035f5ec263bcd59110fac9195a510c1a92f3", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 224, "deletions": 168, "changes": 392, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/56db793abf585246272c17b3e1079024c2bd1deb/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/56db793abf585246272c17b3e1079024c2bd1deb/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=56db793abf585246272c17b3e1079024c2bd1deb", "patch": "@@ -62,6 +62,13 @@ Boston, MA 02111-1307, USA.  */\n       a new value every time we see a statement with a vuse.\n    5. Strength reduction can be performed by anticipating expressions\n       we can repair later on.\n+   6. Our canonicalization of expressions during lookups don't take\n+      constants into account very well.  In particular, we don't fold\n+      anywhere, so we can get situations where we stupidly think\n+      something is a new value (a + 1 + 1 vs a + 2).  This is somewhat\n+      expensive to fix, but it does expose a lot more eliminations.\n+      It may or not be worth it, depending on how critical you\n+      consider PRE vs just plain GRE.\n */   \n \n /* For ease of terminology, \"expression node\" in the below refers to\n@@ -71,30 +78,30 @@ Boston, MA 02111-1307, USA.  */\n \n /* Basic algorithm\n    \n-   First we walk the statements to generate the AVAIL sets, the EXP_GEN\n-   sets, and the tmp_gen sets.  AVAIL is a forward dataflow\n-   problem. EXP_GEN sets represent the generation of\n-   values/expressions by a given block.  We use them when computing\n-   the ANTIC sets.  The AVAIL sets consist of SSA_NAME's that\n-   represent values, so we know what values are available in what\n-   blocks.  In SSA, values are never killed, so we don't need a kill\n-   set, or a fixpoint iteration, in order to calculate the AVAIL sets.\n-   In traditional parlance, AVAIL sets tell us the downsafety of the\n+   First we walk the statements to generate the AVAIL sets, the\n+   EXP_GEN sets, and the tmp_gen sets.  EXP_GEN sets represent the\n+   generation of values/expressions by a given block.  We use them\n+   when computing the ANTIC sets.  The AVAIL sets consist of\n+   SSA_NAME's that represent values, so we know what values are\n+   available in what blocks.  AVAIL is a forward dataflow problem.  In\n+   SSA, values are never killed, so we don't need a kill set, or a\n+   fixpoint iteration, in order to calculate the AVAIL sets.  In\n+   traditional parlance, AVAIL sets tell us the downsafety of the\n    expressions/values.\n    \n-   Next, we generate the ANTIC sets.  ANTIC is a backwards dataflow\n-   problem.  These sets represent the anticipatable expressions.  An\n-   expression is anticipatable in a given block if it could be\n-   generated in that block.  This means that if we had to perform an\n-   insertion in that block, of the value of that expression, we could.\n-   Calculating the ANTIC sets requires phi translation of expressions,\n-   because the flow goes backwards through phis.  We must iterate to a\n-   fixpoint of the ANTIC sets, because we have a kill set.\n-   Even in SSA form, values are not live over the entire function,\n-   only from their definition point onwards.  So we have to remove\n-   values from the ANTIC set once we go past the definition point of\n-   the leaders that make them up.  compute_antic/compute_antic_aux\n-   performs this computation.\n+   Next, we generate the ANTIC sets.  These sets represent the\n+   anticipatable expressions.  ANTIC is a backwards dataflow\n+   problem.An expression is anticipatable in a given block if it could\n+   be generated in that block.  This means that if we had to perform\n+   an insertion in that block, of the value of that expression, we\n+   could.  Calculating the ANTIC sets requires phi translation of\n+   expressions, because the flow goes backwards through phis.  We must\n+   iterate to a fixpoint of the ANTIC sets, because we have a kill\n+   set.  Even in SSA form, values are not live over the entire\n+   function, only from their definition point onwards.  So we have to\n+   remove values from the ANTIC set once we go past the definition\n+   point of the leaders that make them up.\n+   compute_antic/compute_antic_aux performs this computation.\n \n    Third, we perform insertions to make partially redundant\n    expressions fully redundant.\n@@ -118,10 +125,10 @@ Boston, MA 02111-1307, USA.  */\n \n    Value numbers are represented using the \"value handle\" approach.\n    This means that each SSA_NAME (and for other reasons to be\n-   disclosed in a moment, expression nodes and constant nodes) has a\n-   value handle that can be retrieved through get_value_handle.  This\n-   value handle, *is* the value number of the SSA_NAME.  You can\n-   pointer compare the value handles for equivalence purposes.\n+   disclosed in a moment, expression nodes) has a value handle that\n+   can be retrieved through get_value_handle.  This value handle, *is*\n+   the value number of the SSA_NAME.  You can pointer compare the\n+   value handles for equivalence purposes.\n \n    For debugging reasons, the value handle is internally more than\n    just a number, it is a VAR_DECL named \"value.x\", where x is a\n@@ -133,10 +140,8 @@ Boston, MA 02111-1307, USA.  */\n    Expression nodes have value handles associated with them as a\n    cache.  Otherwise, we'd have to look them up again in the hash\n    table This makes significant difference (factor of two or more) on\n-   some test cases.  They can be thrown away after the Constants have\n-   value handles associated with them so that they aren't special\n-   cased everywhere, and for consistency sake. This may be changed\n-   depending on memory usage vs code maintenance tradeoff.  */\n+   some test cases.  They can be thrown away after the pass is\n+   finished.  */\n \n /* Representation of expressions on value numbers: \n \n@@ -166,9 +171,9 @@ Boston, MA 02111-1307, USA.  */\n \n    Sets are represented as doubly linked lists kept in topological\n    order, with an optional supporting bitmap of values present in the\n-   set.  The sets represent values, and the elements can be constants,\n-   values, or expressions.  The elements can appear in different sets,\n-   but each element can only appear once in each set.\n+   set.  The sets represent values, and the elements can be values or\n+   expressions.  The elements can appear in different sets, but each\n+   element can only appear once in each set.\n \n    Since each node in the set represents a value, we also want to be\n    able to map expression, set pairs to something that tells us\n@@ -179,7 +184,7 @@ Boston, MA 02111-1307, USA.  */\n \n \n /* A value set element.  Basically a single linked list of\n-   expressions/constants/values.  */\n+   expressions/values.  */\n typedef struct value_set_node\n {\n   /* An expression.  */\n@@ -278,6 +283,7 @@ static void add_to_value (tree, tree);\n static value_set_t set_new  (bool);\n static bool is_undefined_value (tree);\n static bool expressions_equal_p (tree, tree);\n+static tree create_expression_by_pieces (basic_block, tree, tree);\n \n /* We can add and remove elements and entries to and from sets\n    and hash tables, so we use alloc pools for them.  */\n@@ -372,8 +378,9 @@ get_value_handle (tree expr)\n     {\n       return SSA_NAME_VALUE (expr);\n     }\n-  else if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c'\n-\t   || EXPR_P (expr))\n+  else if (TREE_CODE_CLASS (TREE_CODE (expr)) == 'c')\n+    return expr;\n+  else if (EXPR_P (expr))\n     {\n       tree_ann_t ann = tree_ann (expr);  \n       if (ann)\n@@ -393,8 +400,7 @@ set_value_handle (tree e, tree v)\n     abort ();\n   else if (TREE_CODE (e) == SSA_NAME)\n     SSA_NAME_VALUE (e) = v;\n-  else if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c'\n-\t   || EXPR_P (e))\n+  else if (EXPR_P (e))\n     get_tree_ann (e)->common.value_handle = v;\n }\n \n@@ -499,6 +505,8 @@ lookup (htab_t table, tree e)\n {\n   void **slot;\n   struct val_expr_pair_d vep = {NULL, NULL, 0};\n+  if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n+    return e;\n   vep.e = e;\n   vep.hashcode = iterative_hash_expr (e,0); \n   slot = htab_find_slot_with_hash (table, &vep, vep.hashcode, NO_INSERT);\n@@ -513,30 +521,25 @@ lookup (htab_t table, tree e)\n static inline void\n add_to_value (tree v, tree e)\n {\n-#if DEBUG_VALUE_EXPRESSIONS\n-  var_ann_t va = var_ann (v);\n-#endif\n-  /* For values representing numerical constants, we mark\n-     TREE_CONSTANT as true and set the tree chain to the actual\n-     constant.  This is because unlike values involving expressions,\n-     which are only available to use where the expressions are live, a\n-     constant can be remade anywhere, and thus, is available\n-     everywhere.  */\n-  if (TREE_CODE_CLASS (TREE_CODE (e)) == 'c')\n-    {\n-      TREE_CONSTANT (v) = true;\n-      TREE_CHAIN (v) = e;\n-    }\n-  else if (is_gimple_min_invariant (e))\n+  var_ann_t va;\n+  /* For values representing non-CST nodes, but still function\n+     invariant things we mark TREE_CONSTANT as true and set the tree\n+     chain to the actual constant.  This is because unlike values\n+     involving expressions, which are only available to use where the\n+     expressions are live, a function invariant can be remade\n+     anywhere, and thus, is available everywhere, just like a constant.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (v)) == 'c')\n+    return;\n+  else if (is_gimple_min_invariant (v))\n     {\n       TREE_CONSTANT (v) = true;\n       TREE_CHAIN (v) = e;\n+      return;\n     }\n-#if DEBUG_VALUE_EXPRESSIONS\n+  va = var_ann (v);\n   if (va->expr_set == NULL)\n     va->expr_set = set_new (false);\n   insert_into_set (va->expr_set, e);\n-#endif\n }\n \n /* Insert E into TABLE with value V, and add expression E to the value\n@@ -758,9 +761,13 @@ set_remove (value_set_t set, tree expr)\n static bool\n set_contains_value (value_set_t set, tree val)\n {\n+  /* All true constants are in every set.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (val)) == 'c')\n+    return true;\n   /* This is only referring to the flag above that we set on\n-     values referring to numerical constants, because we know that we\n+     values referring to invariants, because we know that we\n      are dealing with one of the value handles we created.  */\n+\n   if (TREE_CONSTANT (val))\n     return true;\n   \n@@ -866,7 +873,9 @@ value_insert_into_set (value_set_t set, tree expr)\n {\n   tree val = get_value_handle (expr);\n \n-  /* Constant values exist everywhere.  */\n+\n+  /* Constant and invariant values exist everywhere, and thus,\n+     actually keeping them in the sets is pointless.  */\n   if (TREE_CONSTANT (val))\n     return;\n \n@@ -980,6 +989,11 @@ phi_translate (tree expr, value_set_t set,  basic_block pred,\n \t  }\n       }\n       break;\n+      /* XXX: Until we have PRE of loads working, none will be ANTIC.\n+       */\n+    case 'r':\n+      return NULL;\n+      break;\n     case '1':\n       {\n \ttree oldop1 = TREE_OPERAND (expr, 0);\n@@ -1059,7 +1073,11 @@ find_leader (value_set_t set, tree val)\n \n   if (val == NULL)\n     return NULL;\n-\n+  /* True constants represent themselves.  */\n+  if (TREE_CODE_CLASS (TREE_CODE (val)) == 'c')\n+    return val;\n+  /* Invariants are still represented by values, since they may be\n+     more than a single _CST node.  */  \n   if (TREE_CONSTANT (val))\n     return TREE_CHAIN (val);\n \n@@ -1106,6 +1124,12 @@ valid_in_set (value_set_t set, tree expr)\n \treturn set_contains_value (set, op1);\n       }\n       break;\n+      /* XXX: Until PRE of loads works, no reference nodes are ANTIC.\n+       */\n+    case 'r':\n+      {\n+\treturn false;\n+      }\n     case 'x':\n       {\n \tif (TREE_CODE (expr) == SSA_NAME)\n@@ -1304,6 +1328,135 @@ compute_antic (void)\n     fprintf (dump_file, \"compute_antic required %d iterations\\n\", num_iterations);\n }\n \n+/* Get the expressions represented by value VAL.  */\n+\n+static value_set_t\n+get_expr_set (tree val)\n+{\n+  var_ann_t va = var_ann (val);\n+  return va->expr_set;\n+}\n+\n+\n+/* Find a leader for an expression, or generate one using\n+   create_expression_by_pieces if it's ANTIC but\n+   complex.  \n+   BLOCK is the basic_block we are looking for leaders in.\n+   EXPR is the expression to find a leader or generate for. \n+   STMTS is the statement list to put the inserted expressions on.\n+   Returns the SSA_NAME of the LHS of the generated expression or the\n+   leader.  */\n+\n+static tree\n+find_or_generate_expression (basic_block block, tree expr, tree stmts)\n+{\n+  tree genop;\n+  genop = find_leader (AVAIL_OUT (block), expr);\n+  /* Depending on the order we process DOM branches in, the value\n+     may not have propagated to all the dom children yet during\n+     this iteration.  In this case, the value will always be in\n+     the NEW_SETS for us already, having been propogated from our\n+     dominator.  */\n+  if (genop == NULL)\n+    genop = find_leader (NEW_SETS (block), expr);\n+  /* If it's still NULL, see if it is a complex expression, and if\n+     so, generate it recursively, otherwise, abort, because it's\n+     not really .  */\n+  if (genop == NULL)\n+    {\n+      genop = get_expr_set (expr)->head->expr;\n+      if (TREE_CODE_CLASS (TREE_CODE (genop)) != '1'\n+\t  && TREE_CODE_CLASS (TREE_CODE (genop)) != '2')\n+\tabort ();\n+      genop = create_expression_by_pieces (block, genop, stmts);\n+    }\n+  return genop;\n+}\n+\n+  \n+/* Create an expression in pieces, so that we can handle very complex\n+   expressions that may be ANTIC, but not necessary GIMPLE.  \n+   BLOCK is the basic block the expression will be inserted into,\n+   EXPR is the expression to insert (in value form)\n+   STMTS is a statement list to append the necessary insertions into.\n+\n+   This function will abort if we hit some value that shouldn't be\n+   ANTIC but is (IE there is no leader for it, or its components).\n+   This function may also generate expressions that are themselves\n+   partially or fully redundant.  Those that are will be either made\n+   fully redundant during the next iteration of insert (for partially\n+   redundant ones), or eliminated by eliminate (for fully redundant\n+   ones).  */\n+\n+static tree\n+create_expression_by_pieces (basic_block block, tree expr, tree stmts)\n+{\n+  tree name = NULL_TREE;\n+  tree newexpr = NULL_TREE;\n+  tree v;\n+  \n+  switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n+    {\n+    case '2':\n+      {\n+\ttree_stmt_iterator tsi;\n+\ttree genop1, genop2;\n+\ttree temp;\n+\ttree op1 = TREE_OPERAND (expr, 0);\n+\ttree op2 = TREE_OPERAND (expr, 1);\n+\tgenop1 = find_or_generate_expression (block, op1, stmts);\n+\tgenop2 = find_or_generate_expression (block, op2, stmts);\n+\ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n+\tadd_referenced_tmp_var (temp);\n+\tnewexpr = build (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t genop1, genop2);\n+\tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n+\t\t\t temp, newexpr);\n+\tname = make_ssa_name (temp, newexpr);\n+\tTREE_OPERAND (newexpr, 0) = name;\n+\ttsi = tsi_last (stmts);\n+\ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n+\tpre_stats.insertions++;\n+\tbreak;\n+      }\n+    case '1':\n+      {\n+\ttree_stmt_iterator tsi;\n+\ttree genop1;\n+\ttree temp;\n+\ttree op1 = TREE_OPERAND (expr, 0);\n+\tgenop1 = find_or_generate_expression (block, op1, stmts);\n+\ttemp = create_tmp_var (TREE_TYPE (expr), \"pretmp\");\n+\tadd_referenced_tmp_var (temp);\n+\tnewexpr = build (TREE_CODE (expr), TREE_TYPE (expr), \n+\t\t\t genop1);\n+\tnewexpr = build (MODIFY_EXPR, TREE_TYPE (expr),\n+\t\t\t temp, newexpr);\n+\tname = make_ssa_name (temp, newexpr);\n+\tTREE_OPERAND (newexpr, 0) = name;\n+\ttsi = tsi_last (stmts);\n+\ttsi_link_after (&tsi, newexpr, TSI_CONTINUE_LINKING);\n+\tpre_stats.insertions++;\n+\n+\tbreak;\n+      }\n+    default:\n+      abort ();\n+      \n+    }\n+  v = get_value_handle (expr);\n+  add (value_table, name, v);\n+  insert_into_set (NEW_SETS (block), name);\n+  value_insert_into_set (AVAIL_OUT (block), name);\n+  if (dump_file && (dump_flags & TDF_DETAILS))\n+    {\t\t\t\t    \n+      fprintf (dump_file, \"Inserted \");\n+      print_generic_expr (dump_file, newexpr, 0);\n+      fprintf (dump_file, \" in predecessor %d\\n\", block->index);\n+    }\n+  return name;\n+}\n+      \n /* Perform insertion of partially redundant values.\n    For BLOCK, do the following:\n    1.  Propagate the NEW_SETS of the dominator into the current block.\n@@ -1426,8 +1579,6 @@ insert_aux (basic_block block)\n \t\t\t{\n \t\t\t  tree type = TREE_TYPE (avail[block->pred->src->index]);\n \t\t\t  tree temp;\n-\t\t\t  tree v;\n-\n \t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n \t\t\t    {\n \t\t\t      fprintf (dump_file, \"Found partial redundancy for expression \");\n@@ -1440,112 +1591,21 @@ insert_aux (basic_block block)\n \t\t\t       pred;\n \t\t\t       pred = pred->pred_next)\n \t\t\t    {\n+\t\t\t      tree stmts = alloc_stmt_list ();\n+\t\t\t      tree builtexpr;\n \t\t\t      bprime = pred->src;\n \t\t\t      eprime = avail[bprime->index];\n-\t\t\t      if (TREE_CODE_CLASS (TREE_CODE (eprime)) == '2')\n+\t\t\t      if (TREE_CODE_CLASS (TREE_CODE (eprime)) == '2'\n+\t\t\t\t  || TREE_CODE_CLASS (TREE_CODE (eprime)) == '1')\n \t\t\t\t{\n-\t\t\t\t  tree s1, s2;\n-\t\t\t\t  tree newexpr;\n-\t\t\t\t  s1 = find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t    TREE_OPERAND (eprime, 0));\n-\t\t\t\t  /* Depending on the order we process\n-\t\t\t\t     DOM branches in, the value may\n-\t\t\t\t     not have propagated to all the\n-\t\t\t\t     dom children yet during this\n-\t\t\t\t     iteration.  In this case, the\n-\t\t\t\t     value will always be in the\n-\t\t\t\t     NEW_SETS for *our* dominator */\n-\t\t\t\t  if (!s1)\n-\t\t\t\t    s1 = find_leader (NEW_SETS (dom),\n-\t\t\t\t\t\t      TREE_OPERAND (eprime, 0));\n-\t\t\t\t  if (!s1)\n-\t\t\t\t    abort ();\n-\t\t\t\t  \n-\t\t\t\t  s2 = find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t    TREE_OPERAND (eprime, 1));\n-\t\t\t\t  if (!s2)\n-\t\t\t\t    s2 = find_leader (NEW_SETS (dom),\n-\t\t\t\t\t\t      TREE_OPERAND (eprime, 1));\n-\t\t\t\t  if (!s2)\n-\t\t\t\t    abort ();\n-\t\t\t\t  \n-\t\t\t\t  temp = create_tmp_var (TREE_TYPE (eprime),\n-\t\t\t\t\t\t\t \"pretmp\");\n-\t\t\t\t  add_referenced_tmp_var (temp);\n-\t\t\t\t  newexpr = build (TREE_CODE (eprime),\n-\t\t\t\t\t\t   TREE_TYPE (eprime),\n-\t\t\t\t\t\t   s1, s2);\n-\t\t\t\t  newexpr = build (MODIFY_EXPR, \n-\t\t\t\t\t\t   TREE_TYPE (eprime),\n-\t\t\t\t\t\t   temp, newexpr);\n-\t\t\t\t  temp = make_ssa_name (temp, newexpr);\n-\t\t\t\t  TREE_OPERAND (newexpr, 0) = temp;\n-\t\t\t\t  bsi_insert_on_edge (pred, newexpr);\n+\t\t\t\t  builtexpr = create_expression_by_pieces (bprime,\n+\t\t\t\t\t\t\t\t\t   eprime,\n+\t\t\t\t\t\t\t\t\t   stmts);\n+\t\t\t\t  bsi_insert_on_edge (pred, stmts);\n \t\t\t\t  bsi_commit_edge_inserts (NULL);\n-\t\t\t\t  \n-\t\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t\t    {\t\t\t\t    \n-\t\t\t\t      fprintf (dump_file, \"Inserted \");\n-\t\t\t\t      print_generic_expr (dump_file, newexpr, 0);\n-\t\t\t\t      fprintf (dump_file, \" in predecessor %d\\n\", pred->src->index);\n-\t\t\t\t    }\n-\t\t\t\t  pre_stats.insertions++;\n-\t\t\t\t  v = lookup_or_add (value_table, eprime);\n-\t\t\t\t  add (value_table, temp, v);\n-\t\t\t\t  insert_into_set (NEW_SETS (bprime), temp);\n-\t\t\t\t  value_insert_into_set (AVAIL_OUT (bprime), \n-\t\t\t\t\t\t\t temp);\n-\t\t\t\t  avail[bprime->index] = temp;\n-\t\t\t\t}\n-\t\t\t      else if (TREE_CODE_CLASS (TREE_CODE (eprime)) == '1')\n-\t\t\t\t{\n-\t\t\t\t  tree s1;\n-\t\t\t\t  tree newexpr;\n-\t\t\t\t  s1 = find_leader (AVAIL_OUT (bprime),\n-\t\t\t\t\t\t    TREE_OPERAND (eprime, 0));\n-\t\t\t\t  /* Depending on the order we process\n-\t\t\t\t     DOM branches in, the value may not have\n-\t\t\t\t     propagated to all the dom\n-\t\t\t\t     children yet in the current\n-\t\t\t\t     iteration, but it will be in\n-\t\t\t\t     NEW_SETS if it is not yet\n-\t\t\t\t     propagated.  */\n-\t\t\t\t     \n-\t\t\t\t  if (!s1)\n-\t\t\t\t    s1 = find_leader (NEW_SETS (dom),\n-\t\t\t\t\t\t      TREE_OPERAND (eprime, 0));\n-\t\t\t\t  if (!s1)\n-\t\t\t\t    abort ();\n-\t\t\t\t  \n-\t\t\t\t  temp = create_tmp_var (TREE_TYPE (eprime),\n-\t\t\t\t\t\t\t \"pretmp\");\n-\t\t\t\t  add_referenced_tmp_var (temp);\n-\t\t\t\t  newexpr = build (TREE_CODE (eprime),\n-\t\t\t\t\t\t   TREE_TYPE (eprime),\n-\t\t\t\t\t\t   s1);\n-\t\t\t\t  newexpr = build (MODIFY_EXPR, \n-\t\t\t\t\t\t   TREE_TYPE (eprime),\n-\t\t\t\t\t\t   temp, newexpr);\n-\t\t\t\t  temp = make_ssa_name (temp, newexpr);\n-\t\t\t\t  TREE_OPERAND (newexpr, 0) = temp;\n-\t\t\t\t  bsi_insert_on_edge (pred, newexpr);\n-\t\t\t\t  bsi_commit_edge_inserts (NULL);\n-\t\t\t\t  \n-\t\t\t\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t\t\t    {\t\t\t\t    \n-\t\t\t\t      fprintf (dump_file, \"Inserted \");\n-\t\t\t\t      print_generic_expr (dump_file, newexpr, 0);\n-\t\t\t\t      fprintf (dump_file, \" in predecessor %d\\n\", pred->src->index);\n-\t\t\t\t    }\n-\t\t\t\t  pre_stats.insertions++;\n-\t\t\t\t  v = lookup_or_add (value_table, eprime);\n-\t\t\t\t  add (value_table, temp, v);\n-\t\t\t\t  insert_into_set (NEW_SETS (bprime), temp);\n-\t\t\t\t  value_insert_into_set (AVAIL_OUT (bprime), \n-\t\t\t\t\t\t\t temp);\n-\t\t\t\t  avail[bprime->index] = temp;\n-\t\t\t\t}\n-\t\t\t    }\t        \n+\t\t\t\t  avail[bprime->index] = builtexpr;\n+\t\t\t\t}\t\t\t      \n+\t\t\t    } \n \t\t\t  /* Now build a phi for the new variable.  */\n \t\t\t  temp = create_tmp_var (type, \"prephitmp\");\n \t\t\t  add_referenced_tmp_var (temp);\n@@ -1729,11 +1789,7 @@ compute_avail (basic_block block)\n \t\t}\n \t      continue;\n \t    }\n-\t  else if (TREE_CODE (stmt) == RETURN_EXPR\n-\t\t   && TREE_OPERAND (stmt, 0)\n-\t\t   && TREE_CODE (TREE_OPERAND (stmt, 0)) == MODIFY_EXPR)\n-\t    stmt = TREE_OPERAND (stmt, 0);\n-\t  \n+\n \t  if (TREE_CODE (stmt) == MODIFY_EXPR)\n \t    {\n \t      op0 = TREE_OPERAND (stmt, 0);\n@@ -1743,7 +1799,7 @@ compute_avail (basic_block block)\n \t\tcontinue;\n \t      op1 = TREE_OPERAND (stmt, 1);\n \t      STRIP_USELESS_TYPE_CONVERSION (op1);\n-\t      if (TREE_CODE_CLASS (TREE_CODE (op1)) == 'c')\n+\t      if (is_gimple_min_invariant (op1))\n \t\t{\n \t\t  add (value_table, op0, lookup_or_add (value_table, op1));\n \t\t  insert_into_set (TMP_GEN (block), op0);"}]}