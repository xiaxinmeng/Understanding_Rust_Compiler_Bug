{"sha": "3a77e7ccc4cc096613394ab0ebb520ac71325405", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2E3N2U3Y2NjNGNjMDk2NjEzMzk0YWIwZWJiNTIwYWM3MTMyNTQwNQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-15T19:35:52Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-05-15T19:35:52Z"}, "message": "re PR c++/79369 (namespace definition with qualified id)\n\n\tgcc/cp/\n\tPR c++/79369\n\t* cp-tree.h (DECL_NAMESPACE_INLINE_P): New.\n\t* name-lookup.h (push_namespace): Return int, add make_inline arg.\n\t* name-lookup.c (push_namespace): Deal with inline directly.\n\tReturn pushed count.\n\t* parser.c (cp_parser_namespace_definition): Adjust for\n\tpush_namespace change.\n\n\tgcc/testsuite/\n\t* g++.dg/cpp0x/pr65558.C: Adjust diagnostic location.\n\t* g++.dg/cpp0x/pr79369.C: New.\n\nFrom-SVN: r248073", "tree": {"sha": "fa2958bbb482d2c4052540d22b615137a1f8c25c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fa2958bbb482d2c4052540d22b615137a1f8c25c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3a77e7ccc4cc096613394ab0ebb520ac71325405", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a77e7ccc4cc096613394ab0ebb520ac71325405", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3a77e7ccc4cc096613394ab0ebb520ac71325405", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3a77e7ccc4cc096613394ab0ebb520ac71325405/comments", "author": null, "committer": null, "parents": [{"sha": "0735a1c8cf2fe23ade2f98e5dbaf1781f597471d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0735a1c8cf2fe23ade2f98e5dbaf1781f597471d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0735a1c8cf2fe23ade2f98e5dbaf1781f597471d"}], "stats": {"total": 318, "additions": 164, "deletions": 154}, "files": [{"sha": "fe99fa779ec1578e66205b3162cf83889c2dbec6", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -1,3 +1,13 @@\n+2017-05-15  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/79369\n+\t* cp-tree.h (DECL_NAMESPACE_INLINE_P): New.\n+\t* name-lookup.h (push_namespace): Return int, add make_inline arg.\n+\t* name-lookup.c (push_namespace): Deal with inline directly.\n+\tReturn pushed count.\n+\t* parser.c (cp_parser_namespace_definition): Adjust for\n+\tpush_namespace change.\n+\n 2017-05-11  Nathan Sidwell  <nathan@acm.org>\n \n \t* cp-lang.c (get_global_decls, cxx_pushdecl, LANG_HOOK_GETDECLS,"}, {"sha": "85cdf07cb91905263197cbc1897cb4e4a549119f", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -333,6 +333,7 @@ extern GTY(()) tree cp_global_trees[CPTI_MAX];\n       FOLD_EXPR_MODOP_P (*_FOLD_EXPR)\n       IF_STMT_CONSTEXPR_P (IF_STMT)\n       TEMPLATE_TYPE_PARM_FOR_CLASS (TEMPLATE_TYPE_PARM)\n+      DECL_NAMESPACE_INLINE_P (in NAMESPACE_DECL)\n    1: IDENTIFIER_VIRTUAL_P (in IDENTIFIER_NODE)\n       TI_PENDING_TEMPLATE_FLAG.\n       TEMPLATE_PARMS_FOR_INLINE.\n@@ -2916,6 +2917,10 @@ struct GTY(()) lang_decl {\n #define LOCAL_CLASS_P(NODE)\t\t\t\t\\\n   (decl_function_context (TYPE_MAIN_DECL (NODE)) != NULL_TREE)\n \n+/* Whether the namepace is an inline namespace.  */\n+#define DECL_NAMESPACE_INLINE_P(NODE) \\\n+  TREE_LANG_FLAG_0 (NAMESPACE_DECL_CHECK (NODE))\n+\n /* For a NAMESPACE_DECL: the list of using namespace directives\n    The PURPOSE is the used namespace, the value is the namespace\n    that is the common ancestor.  */"}, {"sha": "375376a89a8d1c47ec6e1817d9d8d8573c3d4286", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 81, "deletions": 76, "changes": 157, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -6441,107 +6441,112 @@ pop_from_top_level (void)\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n }\n \n-/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE, then we\n-   select a name that is unique to this compilation unit.  Returns FALSE if\n-   pushdecl fails, TRUE otherwise.  */\n+/* Push into the scope of the NAME namespace.  If NAME is NULL_TREE,\n+   then we enter an anonymous namespace.  If MAKE_INLINE is true, then\n+   we create an inline namespace (it is up to the caller to check upon\n+   redefinition). Return the number of namespaces entered.  */\n \n-bool\n-push_namespace (tree name)\n+int\n+push_namespace (tree name, bool make_inline)\n {\n-  tree d = NULL_TREE;\n-  bool need_new = true;\n-  bool implicit_use = false;\n-  bool anon = !name;\n-\n   bool subtime = timevar_cond_start (TV_NAME_LOOKUP);\n+  int count = 0;\n \n   /* We should not get here if the global_namespace is not yet constructed\n      nor if NAME designates the global namespace:  The global scope is\n      constructed elsewhere.  */\n   gcc_assert (global_namespace != NULL && name != global_identifier);\n \n-  if (anon)\n-    {\n-      name = anon_identifier;\n-      d = get_namespace_binding (current_namespace, name);\n-      if (d)\n-\t/* Reopening anonymous namespace.  */\n-\tneed_new = false;\n-      implicit_use = true;\n-    }\n-  else\n+  if (!name)\n+    name = anon_identifier;\n+\n+  /* Check whether this is an extended namespace definition.  */\n+  tree ns = get_namespace_binding (current_namespace, name);\n+  if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n     {\n-      /* Check whether this is an extended namespace definition.  */\n-      d = get_namespace_binding (current_namespace, name);\n-      if (d != NULL_TREE && TREE_CODE (d) == NAMESPACE_DECL)\n+      if (tree dna = DECL_NAMESPACE_ALIAS (ns))\n \t{\n-\t  tree dna = DECL_NAMESPACE_ALIAS (d);\n-\t  if (dna)\n- \t    {\n-\t      /* We do some error recovery for, eg, the redeclaration\n-\t\t of M here:\n-\n-\t\t namespace N {}\n-\t\t namespace M = N;\n-\t\t namespace M {}\n-\n-\t\t However, in nasty cases like:\n-\n-\t\t namespace N\n-\t\t {\n-\t\t   namespace M = N;\n-\t\t   namespace M {}\n-\t\t }\n-\n-\t\t we just error out below, in duplicate_decls.  */\n-\t      if (NAMESPACE_LEVEL (dna)->level_chain\n-\t\t  == current_binding_level)\n-\t\t{\n-\t\t  error (\"namespace alias %qD not allowed here, \"\n-\t\t\t \"assuming %qD\", d, dna);\n-\t\t  d = dna;\n-\t\t  need_new = false;\n-\t\t}\n+\t  /* We do some error recovery for, eg, the redeclaration of M\n+\t     here:\n+\n+\t     namespace N {}\n+\t     namespace M = N;\n+\t     namespace M {}\n+\n+\t     However, in nasty cases like:\n+\n+\t     namespace N\n+\t     {\n+\t       namespace M = N;\n+\t       namespace M {}\n+\t     }\n+\n+\t     we just error out below, in duplicate_decls.  */\n+\t  if (NAMESPACE_LEVEL (dna)->level_chain == current_binding_level)\n+\t    {\n+\t      error (\"namespace alias %qD not allowed here, \"\n+\t\t     \"assuming %qD\", ns, dna);\n+\t      ns = dna;\n \t    }\n \t  else\n-\t    need_new = false;\n+\t    ns = NULL_TREE;\n \t}\n     }\n+  else\n+    ns = NULL_TREE;\n \n-  if (need_new)\n+  bool new_ns = false;\n+  if (!ns)\n     {\n-      /* Make a new namespace, binding the name to it.  */\n-      d = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n-      DECL_CONTEXT (d) = FROB_CONTEXT (current_namespace);\n-      /* The name of this namespace is not visible to other translation\n-\t units if it is an anonymous namespace or member thereof.  */\n-      if (anon || decl_anon_ns_mem_p (current_namespace))\n-\tTREE_PUBLIC (d) = 0;\n+      ns = build_lang_decl (NAMESPACE_DECL, name, void_type_node);\n+      DECL_CONTEXT (ns) = FROB_CONTEXT (current_namespace);\n+      new_ns = true;\n+\n+      if (pushdecl (ns) == error_mark_node)\n+\tns = NULL_TREE;\n       else\n-\tTREE_PUBLIC (d) = 1;\n-      if (pushdecl (d) == error_mark_node)\n \t{\n-\t  timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-\t  return false;\n+\t  if (name == anon_identifier)\n+\t    {\n+\t      /* Clear DECL_NAME for the benefit of debugging back ends.  */\n+\t      SET_DECL_ASSEMBLER_NAME (ns, name);\n+\t      DECL_NAME (ns) = NULL_TREE;\n+\n+\t      if (!make_inline)\n+\t\tdo_using_directive (ns);\n+\t    }\n+\t  else if (TREE_PUBLIC (current_namespace))\n+\t    TREE_PUBLIC (ns) = 1;\n+\n+\t  if (make_inline)\n+\t    {\n+\t      DECL_NAMESPACE_INLINE_P (ns) = true;\n+\t      /* Set up namespace association.  */\n+\t      DECL_NAMESPACE_ASSOCIATIONS (ns)\n+\t\t= tree_cons (current_namespace, NULL_TREE, NULL_TREE);\n+\t      /* Import the contents of the inline namespace.  */\n+\t      do_using_directive (ns);\n+\t    }\n \t}\n-      if (anon)\n+    }\n+\n+  if (ns)\n+    {\n+      if (make_inline && !DECL_NAMESPACE_INLINE_P (ns))\n \t{\n-\t  /* Clear DECL_NAME for the benefit of debugging back ends.  */\n-\t  SET_DECL_ASSEMBLER_NAME (d, name);\n-\t  DECL_NAME (d) = NULL_TREE;\n+\t  error (\"inline namespace must be specified at initial definition\");\n+\t  inform (DECL_SOURCE_LOCATION (ns), \"%qD defined here\", ns);\n \t}\n-      begin_scope (sk_namespace, d);\n+      if (new_ns)\n+\tbegin_scope (sk_namespace, ns);\n+      else\n+\tresume_scope (NAMESPACE_LEVEL (ns));\n+      current_namespace = ns;\n+      count++;\n     }\n-  else\n-    resume_scope (NAMESPACE_LEVEL (d));\n-\n-  if (implicit_use)\n-    do_using_directive (d);\n-  /* Enter the name space.  */\n-  current_namespace = d;\n \n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n-  return true;\n+  return count;\n }\n \n /* Pop from the scope of the current namespace.  */"}, {"sha": "824ea3386a70eda0a66749e9a87a78ac07a0323f", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -340,7 +340,7 @@ extern tree pushdecl (tree, bool is_friend = false);\n extern tree pushdecl_top_level (tree, bool is_friend = false);\n extern tree pushdecl_top_level_and_finish (tree, tree);\n extern tree pushtag (tree, tree, tag_scope);\n-extern bool push_namespace (tree);\n+extern int push_namespace (tree, bool make_inline = false);\n extern void pop_namespace (void);\n extern void push_nested_namespace (tree);\n extern void pop_nested_namespace (tree);"}, {"sha": "99c742f72e9586b195dfe9c381b8db8a277789f6", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 48, "deletions": 74, "changes": 122, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -18172,114 +18172,88 @@ cp_parser_namespace_name (cp_parser* parser)\n static void\n cp_parser_namespace_definition (cp_parser* parser)\n {\n-  tree identifier, attribs;\n-  bool has_visibility;\n-  bool is_inline;\n-  cp_token* token;\n+  tree identifier;\n   int nested_definition_count = 0;\n \n   cp_ensure_no_omp_declare_simd (parser);\n   cp_ensure_no_oacc_routine (parser);\n-  if (cp_lexer_next_token_is_keyword (parser->lexer, RID_INLINE))\n+\n+  bool is_inline = cp_lexer_next_token_is_keyword (parser->lexer, RID_INLINE);\n+\n+  if (is_inline)\n     {\n       maybe_warn_cpp0x (CPP0X_INLINE_NAMESPACES);\n-      is_inline = true;\n       cp_lexer_consume_token (parser->lexer);\n     }\n-  else\n-    is_inline = false;\n \n   /* Look for the `namespace' keyword.  */\n-  token = cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);\n+  cp_token* token\n+    = cp_parser_require_keyword (parser, RID_NAMESPACE, RT_NAMESPACE);\n \n   /* Parse any specified attributes before the identifier.  */\n-  attribs = cp_parser_attributes_opt (parser);\n+  tree attribs = cp_parser_attributes_opt (parser);\n \n-  /* Get the name of the namespace.  We do not attempt to distinguish\n-     between an original-namespace-definition and an\n-     extension-namespace-definition at this point.  The semantic\n-     analysis routines are responsible for that.  */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-    identifier = cp_parser_identifier (parser);\n-  else\n-    identifier = NULL_TREE;\n-\n-  /* Parse any specified attributes after the identifier.  */\n-  tree post_ident_attribs = cp_parser_attributes_opt (parser);\n-  if (post_ident_attribs)\n+  for (;;)\n     {\n-      if (attribs)\n-        attribs = chainon (attribs, post_ident_attribs);\n-      else\n-        attribs = post_ident_attribs;\n-    }\n+      identifier = NULL_TREE;\n+      \n+      if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n+\t{\n+\t  identifier = cp_parser_identifier (parser);\n \n-  /* Start the namespace.  */\n-  bool ok = push_namespace (identifier);\n+\t  /* Parse any attributes specified after the identifier.  */\n+\t  attribs = chainon (attribs, cp_parser_attributes_opt (parser));\n+\t}\n \n-  /* Parse any nested namespace definition. */\n-  if (cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n-    {\n-      if (attribs)\n-        error_at (token->location, \"a nested namespace definition cannot have attributes\");\n-      if (cxx_dialect < cxx1z)\n+      if (cp_lexer_next_token_is_not (parser->lexer, CPP_SCOPE))\n+\tbreak;\n+  \n+      if (!nested_definition_count && cxx_dialect < cxx1z)\n         pedwarn (input_location, OPT_Wpedantic,\n                  \"nested namespace definitions only available with \"\n                  \"-std=c++1z or -std=gnu++1z\");\n-      if (is_inline)\n-        error_at (token->location, \"a nested namespace definition cannot be inline\");\n-      while (cp_lexer_next_token_is (parser->lexer, CPP_SCOPE))\n-        {\n-          cp_lexer_consume_token (parser->lexer);\n-          if (cp_lexer_next_token_is (parser->lexer, CPP_NAME))\n-            identifier = cp_parser_identifier (parser);\n-          else\n-            {\n-              cp_parser_error (parser, \"nested identifier required\");\n-              break;\n-            }\n-\t  if (push_namespace (identifier))\n-\t    ++nested_definition_count;\n-        }\n+\n+      /* Nested namespace names can create new namespaces (unlike\n+\t other qualified-ids).  */\n+      if (int count = identifier ? push_namespace (identifier) : 0)\n+\tnested_definition_count += count;\n+      else\n+\tcp_parser_error (parser, \"nested namespace name required\");\n+      cp_lexer_consume_token (parser->lexer);\n     }\n \n-  /* Look for the `{' to validate starting the namespace.  */\n-  cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+  if (nested_definition_count && !identifier)\n+    cp_parser_error (parser, \"namespace name required\");\n+  \n+  if (nested_definition_count && attribs)\n+    error_at (token->location,\n+\t      \"a nested namespace definition cannot have attributes\");\n+  if (nested_definition_count && is_inline)\n+    error_at (token->location,\n+\t      \"a nested namespace definition cannot be inline\");\n \n-  /* \"inline namespace\" is equivalent to a stub namespace definition\n-     followed by a strong using directive.  */\n-  if (is_inline && ok)\n-    {\n-      tree name_space = current_namespace;\n-      /* Set up namespace association.  */\n-      DECL_NAMESPACE_ASSOCIATIONS (name_space)\n-\t= tree_cons (CP_DECL_CONTEXT (name_space), NULL_TREE,\n-\t\t     DECL_NAMESPACE_ASSOCIATIONS (name_space));\n-      /* Import the contents of the inline namespace.  */\n-      pop_namespace ();\n-      do_using_directive (name_space);\n-      push_namespace (identifier);\n-    }\n+  /* Start the namespace.  */\n+  nested_definition_count += push_namespace (identifier, is_inline);\n \n-  has_visibility = handle_namespace_attrs (current_namespace, attribs);\n+  bool has_visibility = handle_namespace_attrs (current_namespace, attribs);\n \n   warning  (OPT_Wnamespaces, \"namespace %qD entered\", current_namespace);\n \n+  /* Look for the `{' to validate starting the namespace.  */\n+  cp_parser_require (parser, CPP_OPEN_BRACE, RT_OPEN_BRACE);\n+\n   /* Parse the body of the namespace.  */\n   cp_parser_namespace_body (parser);\n \n+  /* Look for the final `}'.  */\n+  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n+\n   if (has_visibility)\n     pop_visibility (1);\n \n-  /* Finish the nested namespace definitions.  */\n+  /* Pop the nested namespace definitions.  */\n   while (nested_definition_count--)\n     pop_namespace ();\n-\n-  /* Finish the namespace.  */\n-  if (ok)\n-    pop_namespace ();\n-  /* Look for the final `}'.  */\n-  cp_parser_require (parser, CPP_CLOSE_BRACE, RT_CLOSE_BRACE);\n }\n \n /* Parse a namespace-body."}, {"sha": "65fe9e336bd952256a0e53ecefdc08ad690e7c7c", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -1,7 +1,13 @@\n+2017-05-15  Nathan Sidwell  <nathan@acm.org>\n+\n+\tPR c++/79369\n+\t* g++.dg/cpp0x/pr65558.C: Adjust diagnostic location.\n+\t* g++.dg/cpp0x/pr79369.C: New.\n+\n 2017-05-15  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/80752\n-\tgfortran.dg/pr80752.f90: New test.\n+\t* gfortran.dg/pr80752.f90: New test.\n \n 2017-05-15  Uros Bizjak  <ubizjak@gmail.com>\n "}, {"sha": "d294c95a657ecb7146065cd4b3130c5d7c4c732e", "filename": "gcc/testsuite/g++.dg/cpp0x/pr65558.C", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr65558.C?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -1,6 +1,7 @@\n // PR c++/65558\n // { dg-do compile { target c++11 } }\n \n-inline namespace __attribute__((__abi_tag__))\n-{ // { dg-warning \"ignoring .__abi_tag__. attribute on anonymous namespace\" }\n+inline namespace\n+__attribute__((__abi_tag__)) // { dg-warning \"ignoring .__abi_tag__. attribute on anonymous namespace\" }\n+{\n }"}, {"sha": "58116f254ff23d541865c7cd44a0f8c339d3b744", "filename": "gcc/testsuite/g++.dg/cpp0x/pr79369.C", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr79369.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3a77e7ccc4cc096613394ab0ebb520ac71325405/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr79369.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fpr79369.C?ref=3a77e7ccc4cc096613394ab0ebb520ac71325405", "patch": "@@ -0,0 +1,9 @@\n+// { dg-do compile { target c++11 } }\n+// PR c++/79369 accept late inline of namespace\n+\n+namespace X {}\n+inline namespace X {} // { dg-error \"must be specified\" }\n+\n+inline namespace Y {}\n+namespace Y {} // OK\n+inline namespace Y {} // also Ok"}]}