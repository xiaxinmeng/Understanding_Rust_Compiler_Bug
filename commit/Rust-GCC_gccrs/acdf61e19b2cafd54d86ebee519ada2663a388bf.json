{"sha": "acdf61e19b2cafd54d86ebee519ada2663a388bf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWNkZjYxZTE5YjJjYWZkNTRkODZlYmVlNTE5YWRhMjY2M2EzODhiZg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-03-24T00:42:44Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2005-03-24T00:42:44Z"}, "message": "Reverted erroneous commit\n\nFrom-SVN: r96966", "tree": {"sha": "93c0bc6f6fff5721cebbe18050d22518ded65f6d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93c0bc6f6fff5721cebbe18050d22518ded65f6d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/acdf61e19b2cafd54d86ebee519ada2663a388bf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acdf61e19b2cafd54d86ebee519ada2663a388bf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acdf61e19b2cafd54d86ebee519ada2663a388bf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acdf61e19b2cafd54d86ebee519ada2663a388bf/comments", "author": null, "committer": null, "parents": [{"sha": "5fb0e509e17730a3b45a2ffa43cce61cda3fc37f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5fb0e509e17730a3b45a2ffa43cce61cda3fc37f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5fb0e509e17730a3b45a2ffa43cce61cda3fc37f"}], "stats": {"total": 13518, "additions": 6244, "deletions": 7274}, "files": [{"sha": "006dc1302e346991c8b8bf162d35b0fb7bfefcc0", "filename": "libjava/gnu/xml/aelfred2/JAXPFactory.java", "status": "modified", "additions": 119, "deletions": 154, "changes": 273, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FJAXPFactory.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FJAXPFactory.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fxml%2Faelfred2%2FJAXPFactory.java?ref=acdf61e19b2cafd54d86ebee519ada2663a388bf", "patch": "@@ -60,172 +60,137 @@\n  *\n  * @author David Brownell\n  */\n-public final class JAXPFactory\n-  extends SAXParserFactory\n+public final class JAXPFactory extends SAXParserFactory\n {\n-  \n-  private Hashtable flags = new Hashtable();\n-\n-  /**\n-   * Constructs a factory which normally returns a non-validating\n-   * parser.\n-   */\n-  public JAXPFactory()\n-  {\n-  }\n-\n-  public SAXParser newSAXParser()\n-    throws ParserConfigurationException, SAXException\n-  {\n-    JaxpParser jaxp = new JaxpParser();\n-    Enumeration e = flags.keys();\n-    XMLReader parser = jaxp.getXMLReader();\n-\n-    parser.setFeature(SAXDriver.FEATURE + \"namespaces\",\n-                      isNamespaceAware());\n-    parser.setFeature(SAXDriver.FEATURE + \"validation\",\n-                      isValidating());\n-    // that makes SAX2 feature flags trump JAXP\n-    \n-    while (e.hasMoreElements())\n-      {\n-        String uri = (String) e.nextElement();\n-        Boolean value = (Boolean) flags.get(uri);\n-        parser.setFeature(uri, value.booleanValue());\n-      }\n-\n-    return jaxp;\n-  }\n-\n-  // yes, this \"feature transfer\" mechanism doesn't play well\n-  \n-  public void setFeature(String name, boolean value) \n-    throws ParserConfigurationException, SAXNotRecognizedException,\n-           SAXNotSupportedException\n-  {\n-    try\n-      {\n-        // force \"early\" detection of errors where possible\n-        // (flags can't necessarily be set before parsing)\n-        new JaxpParser().getXMLReader().setFeature(name, value);\n-        \n-        flags.put(name, new Boolean(value));\n-      }\n-    catch (SAXNotRecognizedException e)\n-      {\n-        throw new SAXNotRecognizedException(name);\n-      }\n-    catch (SAXNotSupportedException e)\n-      {\n-        throw new SAXNotSupportedException(name);\n-      }\n-    catch (Exception e)\n-      {\n-        throw new ParserConfigurationException(e.getClass().getName()\n-                                               + \": \"\n-                                               + e.getMessage());\n-      }\n-  }\n-\n-  public boolean getFeature(String name) \n-    throws ParserConfigurationException, SAXNotRecognizedException,\n-           SAXNotSupportedException\n-  {\n-    Boolean value = (Boolean) flags.get(name);\n-    \n-    if (value != null)\n-      {\n-        return value.booleanValue();\n-      }\n-    else\n-      {\n-        try\n-          {\n-            return new JaxpParser().getXMLReader().getFeature(name);\n-          }\n-        catch (SAXNotRecognizedException e)\n-          {\n-            throw new SAXNotRecognizedException(name);\n-          }\n-        catch (SAXNotSupportedException e)\n-          {\n-            throw new SAXNotSupportedException(name);\n-          }\n-        catch (SAXException e)\n-          {\n-            throw new ParserConfigurationException(e.getClass().getName()\n-                                                   + \": \"\n-                                                   + e.getMessage());\n-          }\n-      }\n-  }\n-           \n-  private static class JaxpParser\n-    extends SAXParser\n-  {\n-    \n-    private XmlReader ae2 = new XmlReader();\n-    private XMLReaderAdapter parser = null;\n-    \n-    JaxpParser()\n-    {\n-    }\n+    private Hashtable\tflags = new Hashtable ();\n \n-    public void setProperty(String id, Object value) \n-      throws SAXNotRecognizedException, SAXNotSupportedException\n-    {\n-      ae2.setProperty(id, value);\n-    }\n+    /**\n+     * Constructs a factory which normally returns a non-validating\n+     * parser.\n+     */\n+    public JAXPFactory () { }\n \n-    public Object getProperty(String id) \n-      throws SAXNotRecognizedException, SAXNotSupportedException\n+    public SAXParser newSAXParser ()\n+    throws ParserConfigurationException, SAXException\n     {\n-      return ae2.getProperty(id);\n+\tJaxpParser\tjaxp = new JaxpParser ();\n+\tEnumeration\te = flags.keys ();\n+\tXMLReader\tparser = jaxp.getXMLReader ();\n+\n+\tparser.setFeature (\n+\t\tSAXDriver.FEATURE + \"namespaces\",\n+\t\tisNamespaceAware ());\n+\tparser.setFeature (\n+\t\tSAXDriver.FEATURE + \"validation\",\n+\t\tisValidating ());\n+\t// that makes SAX2 feature flags trump JAXP\n+\n+\twhile (e.hasMoreElements ()) {\n+\t    String\turi = (String) e.nextElement ();\n+\t    Boolean\tvalue = (Boolean) flags.get (uri);\n+\t    parser.setFeature (uri, value.booleanValue ());\n+\t}\n+\n+\treturn jaxp;\n     }\n \n-    public Parser getParser()\n-      throws SAXException\n-    {\n-      if (parser == null)\n-        {\n-          parser = new XMLReaderAdapter(ae2);\n-        }\n-      return parser;\n-    }\n+    // yes, this \"feature transfer\" mechanism doesn't play well\n \n-    public XMLReader getXMLReader ()\n-      throws SAXException\n+    public void setFeature (String name, boolean value) \n+    throws\n+\tParserConfigurationException,\n+\tSAXNotRecognizedException,\n+\tSAXNotSupportedException\n     {\n-      return ae2;\n+\ttry {\n+\t    // force \"early\" detection of errors where possible\n+\t    // (flags can't necessarily be set before parsing)\n+\t    new JaxpParser ().getXMLReader ().setFeature (name, value);\n+\n+\t    flags.put (name, new Boolean (value));\n+\t} catch (SAXNotRecognizedException e) {\n+\t    throw new SAXNotRecognizedException (name);\n+\t} catch (SAXNotSupportedException e) {\n+\t    throw new SAXNotSupportedException (name);\n+\t} catch (Exception e) {\n+\t    throw new ParserConfigurationException (\n+\t\t  e.getClass ().getName ()\n+\t\t+ \": \"\n+\t\t+ e.getMessage ());\n+\t}\n     }\n \n-    public boolean isNamespaceAware()\n+    public boolean getFeature (String name) \n+    throws\n+\tParserConfigurationException,\n+\tSAXNotRecognizedException,\n+\tSAXNotSupportedException\n     {\n-      try\n-        {\n-          return ae2.getFeature(SAXDriver.FEATURE + \"namespaces\");\n-        }\n-      catch (Exception e)\n-        {\n-          throw new Error();\n-        }\n+\tBoolean\tvalue = (Boolean) flags.get (name);\n+\t\n+\tif (value != null)\n+\t    return value.booleanValue ();\n+\telse\n+\t    try {\n+\t\treturn new JaxpParser ().getXMLReader ().getFeature (name);\n+\t    } catch (SAXNotRecognizedException e) {\n+\t\tthrow new SAXNotRecognizedException (name);\n+\t    } catch (SAXNotSupportedException e) {\n+\t\tthrow new SAXNotSupportedException (name);\n+\t    } catch (SAXException e) {\n+\t\tthrow new ParserConfigurationException (\n+\t\t      e.getClass ().getName ()\n+\t\t    + \": \"\n+\t\t    + e.getMessage ());\n+\t    }\n     }\n-    \n-    public boolean isValidating()\n+\n+    private static class JaxpParser extends SAXParser\n     {\n-      try\n-        {\n-          return ae2.getFeature(SAXDriver.FEATURE + \"validation\");\n-        }\n-      catch (Exception e)\n-        {\n-          throw new Error();\n-        }\n+\tprivate XmlReader\tae2 = new XmlReader ();\n+\tprivate XMLReaderAdapter parser = null;\n+\n+\tJaxpParser () { }\n+\n+\tpublic void setProperty (String id, Object value) \n+\tthrows SAXNotRecognizedException, SAXNotSupportedException\n+\t    { ae2.setProperty (id, value); }\n+\n+\tpublic Object getProperty (String id) \n+\tthrows SAXNotRecognizedException, SAXNotSupportedException\n+\t    { return ae2.getProperty (id); }\n+\n+\tpublic Parser getParser ()\n+\tthrows SAXException\n+\t{ \n+\t    if (parser == null)\n+\t\tparser = new XMLReaderAdapter (ae2);\n+\t    return parser;\n+\t}\n+\n+\tpublic XMLReader getXMLReader ()\n+\tthrows SAXException\n+\t    { return ae2; }\n+\n+\tpublic boolean isNamespaceAware ()\n+\t{\n+\t    try {\n+\t\treturn ae2.getFeature (SAXDriver.FEATURE + \"namespaces\");\n+\t    } catch (Exception e) {\n+\t\tthrow new Error ();\n+\t    }\n+\t}\n+\n+\tpublic boolean isValidating ()\n+\t{\n+\t    try {\n+\t\treturn ae2.getFeature (SAXDriver.FEATURE + \"validation\");\n+\t    } catch (Exception e) {\n+\t\tthrow new Error ();\n+\t    }\n+\t}\n+\n+        // TODO isXIncludeAware()\n+        \n     }\n-    \n-    // TODO isXIncludeAware()\n-    \n-  }\n-  \n }\n-"}, {"sha": "0e7b3c719a60c825ffc5b1f9b0e701fa6e200754", "filename": "libjava/gnu/xml/aelfred2/SAXDriver.java", "status": "modified", "additions": 1121, "deletions": 1335, "changes": 2456, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fxml%2Faelfred2%2FSAXDriver.java?ref=acdf61e19b2cafd54d86ebee519ada2663a388bf", "patch": "@@ -60,11 +60,15 @@\n import java.util.Locale;\n import java.util.Stack;\n \n+// maintaining 1.1 compatibility for now ... more portable, PJava, etc\n+// Iterator, Hashmap and ArrayList ought to be faster\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.Hashtable;\n import java.util.Iterator;\n import java.util.List;\n+import java.util.Vector;\n \n import org.xml.sax.*;\n import org.xml.sax.ext.*;\n@@ -129,1494 +133,1276 @@\n  * @see org.xml.sax.Parser\n  */\n final public class SAXDriver\n-  implements Locator, Attributes2, XMLReader, Parser, AttributeList\n+    implements Locator, Attributes2, XMLReader, Parser, AttributeList\n {\n-  \n-  private final DefaultHandler2 base = new DefaultHandler2();\n-  private XmlParser parser;\n-  \n-  private EntityResolver entityResolver = base;\n-  private EntityResolver2 resolver2 = null;\n-  private ContentHandler contentHandler = base;\n-  private DTDHandler dtdHandler = base;\n-  private ErrorHandler errorHandler = base;\n-  private DeclHandler declHandler = base;\n-  private LexicalHandler lexicalHandler = base;\n-  \n-  private String elementName;\n-  private Stack entityStack;\n-  \n-  // one vector (of object/struct): faster, smaller\n-  private List attributesList;\n-  \n-  private boolean namespaces = true;\n-  private boolean xmlNames = false;\n-  private boolean extGE = true;\n-  private boolean extPE = true;\n-  private boolean resolveAll = true;\n-  private boolean useResolver2 = true;\n-  \n-  // package private to allow (read-only) access in XmlParser\n-  boolean stringInterning = true;\n-  \n-  private int attributeCount;\n-  private boolean attributes;\n-  private String[] nsTemp;\n-  private NamespaceSupport prefixStack;\n-  \n-  //\n-  // Constructor.\n-  //\n-\n-  /**\n-   * Constructs a SAX Parser.\n-   */\n-  public SAXDriver()\n-  {\n-    reset();\n-  }\n+    private final DefaultHandler2\tbase = new DefaultHandler2 ();\n+    private XmlParser\t\t\tparser;\n+\n+    private EntityResolver\t\tentityResolver = base;\n+    private EntityResolver2\t\tresolver2 = null;\n+    private ContentHandler\t\tcontentHandler = base;\n+    private DTDHandler\t\t\tdtdHandler = base;\n+    private ErrorHandler \t\terrorHandler = base;\n+    private DeclHandler\t\t\tdeclHandler = base;\n+    private LexicalHandler\t\tlexicalHandler = base;\n+\n+    private String\t\t\telementName;\n+    private Stack\t\t\tentityStack;\n+\n+    // one vector (of object/struct): faster, smaller\n+    private List\t\t\tattributesList;\n+\n+    private boolean\t\t\tnamespaces = true;\n+    private boolean\t\t\txmlNames = false;\n+    private boolean\t\t\textGE = true;\n+    private boolean\t\t\textPE = true;\n+    private boolean\t\t\tresolveAll = true;\n+    private boolean\t\t\tuseResolver2 = true;\n+    private boolean                     stringInterning = true;\n+\n+    private int\t\t\t\tattributeCount;\n+    private boolean\t\t\tattributes;\n+    private String\t\t\tnsTemp [];\n+    private NamespaceSupport\t\tprefixStack;\n \n-  private void reset()\n-  {\n-    elementName = null;\n-    entityStack = new Stack();\n-    attributesList = Collections.synchronizedList(new ArrayList());\n-    attributeCount = 0;\n-    attributes = false;\n-    nsTemp = new String[3];\n-    prefixStack = null;\n-  }\n+    //\n+    // Constructor.\n+    //\n \n+    /** Constructs a SAX Parser.  */\n+    public SAXDriver ()\n+    {\n+      reset ();\n+    }\n \n-  //\n-  // Implementation of org.xml.sax.Parser.\n-  //\n+    private void reset ()\n+    {\n+      elementName = null;\n+      entityStack = new Stack ();\n+      attributesList = Collections.synchronizedList(new ArrayList());\n+      attributeCount = 0;\n+      attributes = false;\n+      nsTemp = new String[3];\n+      prefixStack = null;\n+    }\n \n-  /**\n-   * <b>SAX1</b>: Sets the locale used for diagnostics; currently,\n-   * only locales using the English language are supported.\n-   * @param locale The locale for which diagnostics will be generated\n-   */\n-  public void setLocale(Locale locale)\n-    throws SAXException\n-  {\n-    if (\"en\".equals(locale.getLanguage()))\n-      {\n-        return;\n-      }\n-    throw new SAXException (\"AElfred2 only supports English locales.\");\n-  }\n \n-  /**\n-   * <b>SAX2</b>: Returns the object used when resolving external\n-   * entities during parsing (both general and parameter entities).\n-   */\n-  public EntityResolver getEntityResolver()\n-  {\n-    return (entityResolver == base) ? null : entityResolver;\n-  }\n+    //\n+    // Implementation of org.xml.sax.Parser.\n+    //\n \n-  /**\n-   * <b>SAX1, SAX2</b>: Set the entity resolver for this parser.\n-   * @param handler The object to receive entity events.\n-   */\n-  public void setEntityResolver(EntityResolver resolver)\n-  {\n-    if (resolver instanceof EntityResolver2)\n-      {\n-        resolver2 = (EntityResolver2) resolver;\n-      }\n-    else\n-      {\n-        resolver2 = null;\n-      }\n-    if (resolver == null)\n-      {\n-        resolver = base;\n-      }\n-    entityResolver = resolver;\n-  }\n+    /**\n+     * <b>SAX1</b>: Sets the locale used for diagnostics; currently,\n+     * only locales using the English language are supported.\n+     * @param locale The locale for which diagnostics will be generated\n+     */\n+    public void setLocale (Locale locale)\n+    throws SAXException\n+    {\n+\tif (\"en\".equals (locale.getLanguage ()))\n+\t    return ;\n \n-  /**\n-   * <b>SAX2</b>: Returns the object used to process declarations related\n-   * to notations and unparsed entities.\n-   */\n-  public DTDHandler getDTDHandler()\n-  {\n-    return (dtdHandler == base) ? null : dtdHandler;\n-  }\n+\tthrow new SAXException (\"AElfred2 only supports English locales.\");\n+    }\n \n-  /**\n-   * <b>SAX1, SAX2</b>: Set the DTD handler for this parser.\n-   * @param handler The object to receive DTD events.\n-   */\n-  public void setDTDHandler(DTDHandler handler)\n-  {\n-    if (handler == null)\n-      {\n-        handler = base;\n-      }\n-    this.dtdHandler = handler;\n-  }\n \n+    /**\n+     * <b>SAX2</b>: Returns the object used when resolving external\n+     * entities during parsing (both general and parameter entities).\n+     */\n+    public EntityResolver getEntityResolver ()\n+    {\n+\treturn (entityResolver == base) ? null : entityResolver;\n+    }\n \n-  /**\n-   * <b>SAX1</b>: Set the document handler for this parser.  If a\n-   * content handler was set, this document handler will supplant it.\n-   * The parser is set to report all XML 1.0 names rather than to\n-   * filter out \"xmlns\" attributes (the \"namespace-prefixes\" feature\n-   * is set to true).\n-   *\n-   * @deprecated SAX2 programs should use the XMLReader interface\n-   *  and a ContentHandler.\n-   *\n-   * @param handler The object to receive document events.\n-   */\n-  public void setDocumentHandler(DocumentHandler handler)\n-  {\n-    contentHandler = new Adapter(handler);\n-    xmlNames = true;\n-  }\n+    /**\n+     * <b>SAX1, SAX2</b>: Set the entity resolver for this parser.\n+     * @param handler The object to receive entity events.\n+     */\n+    public void setEntityResolver (EntityResolver resolver)\n+    {\n+\tif (resolver instanceof EntityResolver2)\n+\t    resolver2 = (EntityResolver2) resolver;\n+\telse\n+\t    resolver2 = null;\n+\tif (resolver == null)\n+\t    resolver = base;\n+\tentityResolver = resolver;\n+    }\n \n-  /**\n-   * <b>SAX2</b>: Returns the object used to report the logical\n-   * content of an XML document.\n-   */\n-  public ContentHandler getContentHandler()\n-  {\n-    return (contentHandler == base) ? null : contentHandler;\n-  }\n \n-  /**\n-   * <b>SAX2</b>: Assigns the object used to report the logical\n-   * content of an XML document.  If a document handler was set,\n-   * this content handler will supplant it (but XML 1.0 style name\n-   * reporting may remain enabled).\n-   */\n-  public void setContentHandler(ContentHandler handler)\n-  {\n-    if (handler == null)\n-      {\n-        handler = base;\n-      }\n-    contentHandler = handler;\n-  }\n+    /**\n+     * <b>SAX2</b>: Returns the object used to process declarations related\n+     * to notations and unparsed entities.\n+     */\n+    public DTDHandler getDTDHandler ()\n+    {\n+\treturn (dtdHandler == base) ? null : dtdHandler;\n+    }\n \n-  /**\n-   * <b>SAX1, SAX2</b>: Set the error handler for this parser.\n-   * @param handler The object to receive error events.\n-   */\n-  public void setErrorHandler(ErrorHandler handler)\n-  {\n-    if (handler == null)\n-      {\n-        handler = base;\n-      }\n-    this.errorHandler = handler;\n-  }\n+    /**\n+     * <b>SAX1, SAX2</b>: Set the DTD handler for this parser.\n+     * @param handler The object to receive DTD events.\n+     */\n+    public void setDTDHandler (DTDHandler handler)\n+    {\n+\tif (handler == null)\n+\t    handler = base;\n+\tthis.dtdHandler = handler;\n+    }\n \n-  /**\n-   * <b>SAX2</b>: Returns the object used to receive callbacks for XML\n-   * errors of all levels (fatal, nonfatal, warning); this is never null;\n-   */\n-  public ErrorHandler getErrorHandler()\n-  {\n-    return (errorHandler == base) ? null : errorHandler;\n-  }\n \n-  /**\n-   * <b>SAX1, SAX2</b>: Auxiliary API to parse an XML document, used mostly\n-   * when no URI is available.\n-   * If you want anything useful to happen, you should set\n-   * at least one type of handler.\n-   * @param source The XML input source.  Don't set 'encoding' unless\n-   *  you know for a fact that it's correct.\n-   * @see #setEntityResolver\n-   * @see #setDTDHandler\n-   * @see #setContentHandler\n-   * @see #setErrorHandler\n-   * @exception SAXException The handlers may throw any SAXException,\n-   *  and the parser normally throws SAXParseException objects.\n-   * @exception IOException IOExceptions are normally through through\n-   *  the parser if there are problems reading the source document.\n-   */\n-  public void parse(InputSource source)\n-    throws SAXException, IOException\n-  {\n-    synchronized (base)\n-      {\n-        parser = new XmlParser();\n-        if (namespaces)\n-          {\n-            prefixStack = new NamespaceSupport();\n-          }\n-        else if (!xmlNames)\n-          {\n-            throw new IllegalStateException();\n-          }\n-        parser.setHandler(this);\n-        \n-        try\n-          {\n-            Reader r = source.getCharacterStream();\n-            InputStream in = source.getByteStream();\n-                        \n-            parser.doParse(source.getSystemId(),\n-                           source.getPublicId(),\n-                           r,\n-                           in,\n-                           source.getEncoding());\n-          }\n-        catch (SAXException e)\n-          {\n-            throw e;\n-          }\n-        catch (IOException e)\n-          {\n-            throw e;\n-          }\n-        catch (RuntimeException e)\n-          {\n-            throw e;\n-          }\n-        catch (Exception e)\n-          {\n-            throw new SAXParseException(e.getMessage(), this, e);\n-          }\n-        finally\n-          {\n-            contentHandler.endDocument();\n-            reset();\n-          }\n-      }\n-  }\n-\n-  /**\n-   * <b>SAX1, SAX2</b>: Preferred API to parse an XML document, using a\n-   * system identifier (URI).\n-   */\n-  public void parse(String systemId)\n-    throws SAXException, IOException\n-  {\n-    parse(new InputSource(systemId));\n-  }\n+    /**\n+     * <b>SAX1</b>: Set the document handler for this parser.  If a\n+     * content handler was set, this document handler will supplant it.\n+     * The parser is set to report all XML 1.0 names rather than to\n+     * filter out \"xmlns\" attributes (the \"namespace-prefixes\" feature\n+     * is set to true).\n+     *\n+     * @deprecated SAX2 programs should use the XMLReader interface\n+     *\tand a ContentHandler.\n+     *\n+     * @param handler The object to receive document events.\n+     */\n+    public void setDocumentHandler (DocumentHandler handler)\n+    {\n+\tcontentHandler = new Adapter (handler);\n+\txmlNames = true;\n+    }\n \n-  //\n-  // Implementation of SAX2 \"XMLReader\" interface\n-  //\n-  static final String FEATURE = \"http://xml.org/sax/features/\";\n-  static final String PROPERTY = \"http://xml.org/sax/properties/\";\n-\n-  /**\n-   * <b>SAX2</b>: Tells the value of the specified feature flag.\n-   *\n-   * @exception SAXNotRecognizedException thrown if the feature flag\n-   *  is neither built in, nor yet assigned.\n-   */\n-  public boolean getFeature(String featureId)\n-    throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    if ((FEATURE + \"validation\").equals(featureId))\n-      {\n-        return false;\n-      }\n+    /**\n+     * <b>SAX2</b>: Returns the object used to report the logical\n+     * content of an XML document.\n+     */\n+    public ContentHandler getContentHandler ()\n+    {\n+\treturn contentHandler == base ? null : contentHandler;\n+    }\n \n-    // external entities (both types) are optionally included\n-    if ((FEATURE + \"external-general-entities\").equals(featureId))\n-      {\n-        return extGE;\n-      }\n-    if ((FEATURE + \"external-parameter-entities\").equals(featureId))\n-      {\n-        return extPE;\n-      }\n-    \n-    // element/attribute names are as written in document; no mangling\n-    if ((FEATURE + \"namespace-prefixes\").equals(featureId))\n-      {\n-        return xmlNames;\n-      }\n+    /**\n+     * <b>SAX2</b>: Assigns the object used to report the logical\n+     * content of an XML document.  If a document handler was set,\n+     * this content handler will supplant it (but XML 1.0 style name\n+     * reporting may remain enabled).\n+     */\n+    public void setContentHandler (ContentHandler handler)\n+    {\n+\tif (handler == null)\n+\t    handler = base;\n+\tcontentHandler = handler;\n+    }\n \n-    // report element/attribute namespaces?\n-    if ((FEATURE + \"namespaces\").equals(featureId))\n-      {\n-        return namespaces;\n-      }\n+    /**\n+     * <b>SAX1, SAX2</b>: Set the error handler for this parser.\n+     * @param handler The object to receive error events.\n+     */\n+    public void setErrorHandler (ErrorHandler handler)\n+    {\n+\tif (handler == null)\n+\t    handler = base;\n+\tthis.errorHandler = handler;\n+    }\n \n-    // all PEs and GEs are reported\n-    if ((FEATURE + \"lexical-handler/parameter-entities\").equals(featureId))\n-      {\n-        return true;\n-      }\n+    /**\n+     * <b>SAX2</b>: Returns the object used to receive callbacks for XML\n+     * errors of all levels (fatal, nonfatal, warning); this is never null;\n+     */\n+    public ErrorHandler getErrorHandler ()\n+\t{ return errorHandler == base ? null : errorHandler; }\n+\n+\n+    /**\n+     * <b>SAX1, SAX2</b>: Auxiliary API to parse an XML document, used mostly\n+     * when no URI is available.\n+     * If you want anything useful to happen, you should set\n+     * at least one type of handler.\n+     * @param source The XML input source.  Don't set 'encoding' unless\n+     *\tyou know for a fact that it's correct.\n+     * @see #setEntityResolver\n+     * @see #setDTDHandler\n+     * @see #setContentHandler\n+     * @see #setErrorHandler\n+     * @exception SAXException The handlers may throw any SAXException,\n+     *\tand the parser normally throws SAXParseException objects.\n+     * @exception IOException IOExceptions are normally through through\n+     *\tthe parser if there are problems reading the source document.\n+     */\n+    public void parse (InputSource source)\n+    throws SAXException, IOException\n+    {\n+\tsynchronized (base) {\n+\t    parser = new XmlParser ();\n+\t    if (namespaces)\n+\t\tprefixStack = new NamespaceSupport ();\n+\t    else if (!xmlNames)\n+\t\tthrow new IllegalStateException ();\n+\t    parser.setHandler (this);\n+\n+\t    try {\n+\n+\t      Reader r = source.getCharacterStream();\n+\t      InputStream in = source.getByteStream();\n+\n+\t      \n+\t\tparser.doParse (source.getSystemId (),\n+\t\t\t      source.getPublicId (),\n+\t\t\t      r,\n+\t\t\t      in,\n+\t\t\t      source.getEncoding ());\n+\t    } catch (SAXException e) {\n+\t\tthrow e;\n+\t    } catch (IOException e) {\n+\t\tthrow e;\n+\t    } catch (RuntimeException e) {\n+\t\tthrow e;\n+\t    } catch (Exception e) {\n+\t\tthrow new SAXParseException (e.getMessage (), this, e);\n+\t    } finally {\n+\t\tcontentHandler.endDocument ();\n+                reset();\n+\t    }\n+\t}\n+    }\n \n-    // default is true\n-    if ((FEATURE + \"string-interning\").equals(featureId))\n-      {\n-        return stringInterning;\n-      }\n-  \n-    // EXTENSIONS 1.1\n-    \n-    // always returns isSpecified info\n-    if ((FEATURE + \"use-attributes2\").equals(featureId))\n-      {\n-        return true;\n-      }\n-  \n-    // meaningful between startDocument/endDocument\n-    if ((FEATURE + \"is-standalone\").equals(featureId))\n-      {\n-        if (parser == null)\n-          {\n-            throw new SAXNotSupportedException(featureId);\n-          }\n-        return parser.isStandalone();\n-      }\n \n-    // optionally don't absolutize URIs in declarations\n-    if ((FEATURE + \"resolve-dtd-uris\").equals(featureId))\n-      {\n-        return resolveAll;\n-      }\n+    /**\n+     * <b>SAX1, SAX2</b>: Preferred API to parse an XML document, using a\n+     * system identifier (URI).\n+     */\n+    public void parse (String systemId)\n+    throws SAXException, IOException\n+    {\n+\tparse (new InputSource (systemId));\n+    }\n \n-    // optionally use resolver2 interface methods, if possible\n-    if ((FEATURE + \"use-entity-resolver2\").equals(featureId))\n-      {\n-        return useResolver2;\n-      }\n-  \n-    throw new SAXNotRecognizedException(featureId);\n-  }\n+    //\n+    // Implementation of SAX2 \"XMLReader\" interface\n+    //\n+    static final String\tFEATURE = \"http://xml.org/sax/features/\";\n+    static final String\tPROPERTY = \"http://xml.org/sax/properties/\";\n+\n+    /**\n+     * <b>SAX2</b>: Tells the value of the specified feature flag.\n+     *\n+     * @exception SAXNotRecognizedException thrown if the feature flag\n+     *\tis neither built in, nor yet assigned.\n+     */\n+    public boolean getFeature (String featureId)\n+    throws SAXNotRecognizedException, SAXNotSupportedException\n+    {\n+\tif ((FEATURE + \"validation\").equals (featureId))\n+\t    return false;\n+\n+\t// external entities (both types) are optionally included\n+\tif ((FEATURE + \"external-general-entities\").equals (featureId))\n+\t    return extGE;\n+\tif ((FEATURE + \"external-parameter-entities\") .equals (featureId))\n+\t    return extPE;\n+\n+\t// element/attribute names are as written in document; no mangling\n+\tif ((FEATURE + \"namespace-prefixes\").equals (featureId))\n+\t    return xmlNames;\n+\n+\t// report element/attribute namespaces?\n+\tif ((FEATURE + \"namespaces\").equals (featureId))\n+\t    return namespaces;\n+\n+\t// all PEs and GEs are reported\n+\tif ((FEATURE + \"lexical-handler/parameter-entities\").equals (featureId))\n+\t    return true;\n+\n+\t// default is true\n+\tif ((FEATURE + \"string-interning\").equals (featureId))\n+\t    return stringInterning;\n+\t\n+\t// EXTENSIONS 1.1\n+\n+\t// always returns isSpecified info\n+\tif ((FEATURE + \"use-attributes2\").equals (featureId))\n+\t    return true;\n+\t\n+\t// meaningful between startDocument/endDocument\n+\tif ((FEATURE + \"is-standalone\").equals (featureId)) {\n+\t    if (parser == null)\n+\t\tthrow new SAXNotSupportedException (featureId);\n+\t    return parser.isStandalone ();\n+\t}\n+\n+\t// optionally don't absolutize URIs in declarations\n+\tif ((FEATURE + \"resolve-dtd-uris\").equals (featureId))\n+\t    return resolveAll;\n+\n+\t// optionally use resolver2 interface methods, if possible\n+\tif ((FEATURE + \"use-entity-resolver2\").equals (featureId))\n+\t    return useResolver2;\n+\t\n+\tthrow new SAXNotRecognizedException (featureId);\n+    }\n \n-  // package private\n-  DeclHandler getDeclHandler()\n-  {\n-    return declHandler;\n-  }\n+    // package private\n+    DeclHandler getDeclHandler () { return declHandler; }\n \n-  // package private\n-  boolean resolveURIs()\n-  {\n-    return resolveAll;\n-  }\n+    // package private\n+    boolean resolveURIs () { return resolveAll; }\n \n-  /**\n-   * <b>SAX2</b>:  Returns the specified property.\n-   *\n-   * @exception SAXNotRecognizedException thrown if the property value\n-   *  is neither built in, nor yet stored.\n-   */\n-  public Object getProperty(String propertyId)\n+    /**\n+     * <b>SAX2</b>:  Returns the specified property.\n+     *\n+     * @exception SAXNotRecognizedException thrown if the property value\n+     *\tis neither built in, nor yet stored.\n+     */\n+    public Object getProperty (String propertyId)\n     throws SAXNotRecognizedException\n-  {\n-    if ((PROPERTY + \"declaration-handler\").equals(propertyId))\n-      {\n-        return (declHandler == base) ? null : declHandler;\n-      }\n-\n-    if ((PROPERTY + \"lexical-handler\").equals(propertyId))\n-      {\n-        return (lexicalHandler == base) ? null : lexicalHandler;\n-      }\n-    \n-    // unknown properties\n-    throw new SAXNotRecognizedException(propertyId);\n-  }\n+    {\n+\tif ((PROPERTY + \"declaration-handler\").equals (propertyId))\n+\t    return declHandler == base ? null : declHandler;\n+\n+\tif ((PROPERTY + \"lexical-handler\").equals (propertyId))\n+\t    return lexicalHandler == base ? null : lexicalHandler;\n+\t\n+\t// unknown properties\n+\tthrow new SAXNotRecognizedException (propertyId);\n+    }\n \n-  /**\n-   * <b>SAX2</b>:  Sets the state of feature flags in this parser.  Some\n-   * built-in feature flags are mutable.\n-   */\n-  public void setFeature(String featureId, boolean value)\n+    /**\n+     * <b>SAX2</b>:  Sets the state of feature flags in this parser.  Some\n+     * built-in feature flags are mutable.\n+     */\n+    public void setFeature (String featureId, boolean value)\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    boolean state;\n-  \n-    // Features with a defined value, we just change it if we can.\n-    state = getFeature (featureId);\n-    \n-    if (state == value)\n-      {\n-        return;\n-      }\n-    if (parser != null)\n-      {\n-        throw new SAXNotSupportedException(\"not while parsing\");\n-      }\n-\n-    if ((FEATURE + \"namespace-prefixes\").equals(featureId))\n-      {\n-        // in this implementation, this only affects xmlns reporting\n-        xmlNames = value;\n-        // forcibly prevent illegal parser state\n-        if (!xmlNames)\n-          {\n-            namespaces = true;\n-          }\n-        return;\n-      }\n-\n-    if ((FEATURE + \"namespaces\").equals(featureId))\n-      {\n-        namespaces = value;\n-        // forcibly prevent illegal parser state\n-        if (!namespaces)\n-          {\n-            xmlNames = true;\n-          }\n-        return;\n-      }\n-\n-    if ((FEATURE + \"external-general-entities\").equals(featureId))\n-      {\n-        extGE = value;\n-        return;\n-      }\n-    if ((FEATURE + \"external-parameter-entities\").equals(featureId))\n-      {\n-        extPE = value;\n-        return;\n-      }\n-    if ((FEATURE + \"resolve-dtd-uris\").equals(featureId))\n-      {\n-        resolveAll = value;\n-        return;\n-      }\n-\n-    if ((FEATURE + \"use-entity-resolver2\").equals(featureId))\n-      {\n-        useResolver2 = value;\n-        return;\n-      }\n-\n-    throw new SAXNotRecognizedException(featureId);\n-  }\n+    {\n+\tboolean\tstate;\n+\t\n+\t// Features with a defined value, we just change it if we can.\n+\tstate = getFeature (featureId);\n+\n+\tif (state == value)\n+\t    return;\n+\tif (parser != null)\n+\t    throw new SAXNotSupportedException (\"not while parsing\");\n+\n+\tif ((FEATURE + \"namespace-prefixes\").equals (featureId)) {\n+\t    // in this implementation, this only affects xmlns reporting\n+\t    xmlNames = value;\n+\t    // forcibly prevent illegal parser state\n+\t    if (!xmlNames)\n+\t\tnamespaces = true;\n+\t    return;\n+\t}\n+\n+\tif ((FEATURE + \"namespaces\").equals (featureId)) {\n+\t    namespaces = value;\n+\t    // forcibly prevent illegal parser state\n+\t    if (!namespaces)\n+\t\txmlNames = true;\n+\t    return;\n+\t}\n+\n+\tif ((FEATURE + \"external-general-entities\").equals (featureId)) {\n+\t    extGE = value;\n+\t    return;\n+\t}\n+\tif ((FEATURE + \"external-parameter-entities\") .equals (featureId)) {\n+\t    extPE = value;\n+\t    return;\n+\t}\n+\tif ((FEATURE + \"resolve-dtd-uris\").equals (featureId)) {\n+\t    resolveAll = value;\n+\t    return;\n+\t}\n+\n+\tif ((FEATURE + \"use-entity-resolver2\").equals (featureId)) {\n+\t    useResolver2 = value;\n+\t    return;\n+\t}\n+\n+\tthrow new SAXNotRecognizedException (featureId);\n+    }\n \n-  /**\n-   * <b>SAX2</b>:  Assigns the specified property.  Like SAX1 handlers,\n-   * these may be changed at any time.\n-   */\n-  public void setProperty(String propertyId, Object value)\n+    /**\n+     * <b>SAX2</b>:  Assigns the specified property.  Like SAX1 handlers,\n+     * these may be changed at any time.\n+     */\n+    public void setProperty (String propertyId, Object value)\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    // see if the property is recognized\n-    getProperty(propertyId);\n-    \n-    // Properties with a defined value, we just change it if we can.\n-    \n-    if ((PROPERTY + \"declaration-handler\").equals(propertyId))\n-      {\n-        if (value == null)\n-          {\n-            declHandler = base;\n-          }\n-        else if (!(value instanceof DeclHandler))\n-          {\n-            throw new SAXNotSupportedException(propertyId);\n-          }\n-        else\n-          {\n-            declHandler = (DeclHandler) value;\n-          }\n-        return ;\n-      }\n-    \n-    if ((PROPERTY + \"lexical-handler\").equals(propertyId))\n-      {\n-        if (value == null)\n-          {\n-            lexicalHandler = base;\n-          }\n-        else if (!(value instanceof LexicalHandler))\n-          {\n-            throw new SAXNotSupportedException(propertyId);\n-          }\n-        else\n-          {\n-            lexicalHandler = (LexicalHandler) value;\n-          }\n-        return;\n-      }\n-    \n-    throw new SAXNotSupportedException(propertyId);\n-  }\n+    {\n+\t// see if the property is recognized\n+\tgetProperty (propertyId);\n+\n+\t// Properties with a defined value, we just change it if we can.\n+\n+\tif ((PROPERTY + \"declaration-handler\").equals (propertyId)) {\n+\t    if (value == null)\n+\t\tdeclHandler = base;\n+\t    else if (! (value instanceof DeclHandler))\n+\t\tthrow new SAXNotSupportedException (propertyId);\n+\t    else\n+\t\tdeclHandler = (DeclHandler) value;\n+\t    return ;\n+\t}\n+\n+\tif ((PROPERTY + \"lexical-handler\").equals (propertyId)) {\n+\t    if (value == null)\n+\t\tlexicalHandler = base;\n+\t    else if (! (value instanceof LexicalHandler))\n+\t\tthrow new SAXNotSupportedException (propertyId);\n+\t    else\n+\t\tlexicalHandler = (LexicalHandler) value;\n+\t    return ;\n+\t}\n+\n+\tthrow new SAXNotSupportedException (propertyId);\n+    }\n \n-  //\n-  // This is where the driver receives XmlParser callbacks and translates\n-  // them into SAX callbacks.  Some more callbacks have been added for\n-  // SAX2 support.\n-  //\n \n-  void startDocument()\n-    throws SAXException\n-  {\n-    contentHandler.setDocumentLocator(this);\n-    contentHandler.startDocument();\n-    attributesList.clear();\n-  }\n+    //\n+    // This is where the driver receives XmlParser callbacks and translates\n+    // them into SAX callbacks.  Some more callbacks have been added for\n+    // SAX2 support.\n+    //\n \n-  void xmlDecl(String version,\n-               String encoding,\n-               boolean standalone,\n-               String inputEncoding)\n+    void startDocument ()\n     throws SAXException\n-  {\n-    if (contentHandler instanceof ContentHandler2)\n-      {\n-        ((ContentHandler2) contentHandler).xmlDecl(version,\n-                                                   encoding,\n-                                                   standalone,\n-                                                   inputEncoding);\n-      }\n-  }\n+    {\n+\tcontentHandler.setDocumentLocator (this);\n+\tcontentHandler.startDocument ();\n+\tattributesList.clear ();\n+    }\n+\n+    void xmlDecl(String version,\n+                 String encoding,\n+                 boolean standalone,\n+                 String inputEncoding)\n+      throws SAXException\n+    {\n+      if (contentHandler instanceof ContentHandler2)\n+        {\n+          ((ContentHandler2) contentHandler).xmlDecl(version,\n+                                                     encoding,\n+                                                     standalone,\n+                                                     inputEncoding);\n+        }\n+    }\n \n-  void skippedEntity(String name)\n+    void skippedEntity (String name)\n     throws SAXException\n-  {\n-    contentHandler.skippedEntity(name);\n-  }\n+\t{ contentHandler.skippedEntity (name); }\n \n-  InputSource getExternalSubset(String name, String baseURI)\n+    InputSource getExternalSubset (String name, String baseURI)\n     throws SAXException, IOException\n-  {\n-    if (resolver2 == null || !useResolver2 || !extPE)\n-      {\n-        return null;\n-      }\n-    return resolver2.getExternalSubset(name, baseURI);\n-  }\n+    {\n+\tif (resolver2 == null || !useResolver2 || !extPE)\n+\t    return null;\n+\treturn resolver2.getExternalSubset (name, baseURI);\n+    }\n \n-  InputSource resolveEntity(boolean isPE, String name,\n-                            InputSource in, String baseURI)\n+    InputSource resolveEntity (boolean isPE, String name,\n+    \tInputSource in, String baseURI)\n     throws SAXException, IOException\n-  {\n-    InputSource  source;\n-    \n-    // external entities might be skipped\n-    if (isPE && !extPE)\n-      {\n-        return null;\n-      }\n-    if (!isPE && !extGE)\n-      {\n-        return null;\n-      }\n-\n-    // ... or not\n-    lexicalHandler.startEntity(name);\n-    if (resolver2 != null && useResolver2)\n-      {\n-        source = resolver2.resolveEntity(name, in.getPublicId(),\n-                                         baseURI, in.getSystemId());\n-        if (source == null)\n-          {\n-            in.setSystemId(absolutize(baseURI,\n-                                      in.getSystemId(), false));\n-            source = in;\n-          }\n-      }\n-    else\n-      {\n-        in.setSystemId(absolutize(baseURI, in.getSystemId(), false));\n-        source = entityResolver.resolveEntity(in.getPublicId(),\n-                                              in.getSystemId());\n-        if (source == null)\n-          {\n-            source = in;\n-          }\n-      }\n-    startExternalEntity(name, source.getSystemId(), true);\n-    return source;\n-  }\n+    {\n+\tInputSource\tsource;\n+\n+\t// external entities might be skipped\n+\tif (isPE && !extPE)\n+\t    return null;\n+\tif (!isPE && !extGE)\n+\t    return null;\n+\n+\t// ... or not\n+\tlexicalHandler.startEntity (name);\n+\tif (resolver2 != null && useResolver2) {\n+\t    source = resolver2.resolveEntity (name, in.getPublicId (),\n+\t\t\tbaseURI, in.getSystemId ());\n+\t    if (source == null) {\n+\t\tin.setSystemId (absolutize (baseURI,\n+\t\t\t\tin.getSystemId (), false));\n+\t\tsource = in;\n+\t    }\n+\t} else {\n+\t    in.setSystemId (absolutize (baseURI, in.getSystemId (), false));\n+\t    source = entityResolver.resolveEntity (in.getPublicId (),\n+\t\t\tin.getSystemId ());\n+\t    if (source == null)\n+\t\tsource = in;\n+\t}\n+\tstartExternalEntity (name, source.getSystemId (), true);\n+\treturn source;\n+    }\n \n-  // absolutize a system ID relative to the specified base URI\n-  // (temporarily) package-visible for external entity decls\n-  String absolutize(String baseURI, String systemId, boolean nice)\n+    // absolutize a system ID relative to the specified base URI\n+    // (temporarily) package-visible for external entity decls\n+    String absolutize (String baseURI, String systemId, boolean nice)\n     throws MalformedURLException, SAXException\n-  {\n-    // FIXME normalize system IDs -- when?\n-    // - Convert to UTF-8\n-    // - Map reserved and non-ASCII characters to %HH\n-    \n-    try\n-      {\n-        if (baseURI == null)\n-          {\n-            if (XmlParser.uriWarnings)\n-              {\n-                warn (\"No base URI; hope this SYSTEM id is absolute: \"\n-                      + systemId);\n-              }\n-            return new URL(systemId).toString();\n-          }\n-        else\n-          {\n-            return new URL(new URL(baseURI), systemId).toString();\n-          }\n-      }\n-    catch (MalformedURLException e)\n-      {\n-        // Let unknown URI schemes pass through unless we need\n-        // the JVM to map them to i/o streams for us...\n-        if (!nice)\n-          {\n-            throw e;\n-          }\n-        \n-        // sometimes sysids for notations or unparsed entities\n-        // aren't really URIs...\n-        warn(\"Can't absolutize SYSTEM id: \" + e.getMessage());\n-        return systemId;\n-      }\n-  }\n+    {\n+\t// FIXME normalize system IDs -- when?\n+\t// - Convert to UTF-8\n+\t// - Map reserved and non-ASCII characters to %HH\n+\n+\ttry {\n+\t    if (baseURI == null) {\n+\t\twarn (\"No base URI; hope this SYSTEM id is absolute: \"\n+\t\t\t+ systemId);\n+\t\treturn new URL (systemId).toString ();\n+\t    } else\n+\t\treturn new URL (new URL (baseURI), systemId).toString ();\n+\n+\t} catch (MalformedURLException e) {\n+\n+\t    // Let unknown URI schemes pass through unless we need\n+\t    // the JVM to map them to i/o streams for us...\n+\t    if (!nice)\n+\t\tthrow e;\n+\n+\t    // sometimes sysids for notations or unparsed entities\n+\t    // aren't really URIs...\n+\t    warn (\"Can't absolutize SYSTEM id: \" + e.getMessage ());\n+\t    return systemId;\n+\t}\n+    }\n \n-  void startExternalEntity(String name, String systemId, boolean stackOnly)\n+    void startExternalEntity (String name, String systemId,\n+    \tboolean stackOnly)\n     throws SAXException\n-  {\n-    // The following warning was deleted because the application has the\n-    // option of not setting systemId. Sun's JAXP or Xerces seems to\n-    // ignore this case.\n-    /*\n-       if (systemId == null)\n-       warn (\"URI was not reported to parser for entity \" + name);\n-     */\n-    if (!stackOnly)  // spliced [dtd] needs startEntity\n-      {\n-        lexicalHandler.startEntity(name);\n-      }\n-    entityStack.push(systemId);\n-  }\n+    {\n+\t// The following warning was deleted because the application has the\n+\t// option of not setting systemId. Sun's JAXP or Xerces seems to\n+\t// ignore this case.\n+\t/*\n+\tif (systemId == null)\n+\t    warn (\"URI was not reported to parser for entity \" + name);\n+\t*/\n+\tif (!stackOnly)\t\t// spliced [dtd] needs startEntity\n+\t    lexicalHandler.startEntity (name);\n+\tentityStack.push (systemId);\n+    }\n \n-  void endExternalEntity(String name)\n+    void endExternalEntity (String name)\n     throws SAXException\n-  {\n-    if (!\"[document]\".equals(name))\n-      {\n-        lexicalHandler.endEntity(name);\n-      }\n-    entityStack.pop();\n-  }\n+    {\n+\tif (!\"[document]\".equals (name))\n+\t    lexicalHandler.endEntity (name);\n+\tentityStack.pop ();\n+    }\n \n-  void startInternalEntity(String name)\n+    void startInternalEntity (String name)\n     throws SAXException\n-  {\n-    lexicalHandler.startEntity(name);\n-  }\n+    {\n+\tlexicalHandler.startEntity (name);\n+    }\n \n-  void endInternalEntity(String name)\n+    void endInternalEntity (String name)\n     throws SAXException\n-  {\n-    lexicalHandler.endEntity(name);\n-  }\n+    {\n+\tlexicalHandler.endEntity (name);\n+    }\n \n-  void doctypeDecl(String name, String publicId, String systemId)\n-    throws SAXException\n-  {\n-    lexicalHandler.startDTD(name, publicId, systemId);\n-  \n-    // ... the \"name\" is a declaration and should be given\n-    // to the DeclHandler (but sax2 doesn't).\n-    \n-    // the IDs for the external subset are lexical details,\n-    // as are the contents of the internal subset; but sax2\n-    // doesn't provide the internal subset \"pre-parse\"\n-  }\n-  \n-  void notationDecl(String name, String publicId, String systemId,\n-                    String baseUri)\n+    void doctypeDecl (String name, String publicId, String systemId)\n     throws SAXException\n-  {\n-    try\n-      {\n-        dtdHandler.notationDecl(name, publicId,\n-                                (resolveAll && systemId != null)\n-                                ? absolutize(baseUri, systemId, true)\n-                                : systemId);\n-      }\n-    catch (IOException e)\n-      {\n-        // \"can't happen\"\n-        throw new SAXParseException(e.getMessage(), this, e);\n-      }\n-  }\n+    {\n+\tlexicalHandler.startDTD (name, publicId, systemId);\n+\t\n+\t// ... the \"name\" is a declaration and should be given\n+\t// to the DeclHandler (but sax2 doesn't).\n+\n+\t// the IDs for the external subset are lexical details,\n+\t// as are the contents of the internal subset; but sax2\n+\t// doesn't provide the internal subset \"pre-parse\"\n+    }\n \n-  void unparsedEntityDecl(String name, String publicId, String systemId,\n-                          String baseUri, String notation)\n+    void notationDecl (String name, String ids [])\n     throws SAXException\n-  {\n-    try\n-      {\n-        dtdHandler.unparsedEntityDecl(name, publicId,\n-                                      resolveAll\n-                                      ? absolutize(baseUri, systemId, true)\n-                                      : systemId,\n-                                      notation);\n-      }\n-    catch (IOException e)\n-      {\n-        // \"can't happen\"\n-        throw new SAXParseException(e.getMessage(), this, e);\n-      }\n-  }\n+    {\n+\ttry {\n+\t    dtdHandler.notationDecl (name, ids [0],\n+\t\t(resolveAll && ids [1] != null)\n+\t\t\t? absolutize (ids [2], ids [1], true)\n+\t\t\t: ids [1]);\n+\t} catch (IOException e) {\n+\t    // \"can't happen\"\n+\t    throw new SAXParseException (e.getMessage (), this, e);\n+\t}\n+    }\n \n-  void endDoctype()\n+    void unparsedEntityDecl (String name, String ids [], String notation)\n     throws SAXException\n-  {\n-    lexicalHandler.endDTD();\n-  }\n+    {\n+\ttry {\n+\t    dtdHandler.unparsedEntityDecl (name, ids [0],\n+\t\t    resolveAll\n+\t\t\t? absolutize (ids [2], ids [1], true)\n+\t\t\t: ids [1],\n+\t\t    notation);\n+\t} catch (IOException e) {\n+\t    // \"can't happen\"\n+\t    throw new SAXParseException (e.getMessage (), this, e);\n+\t}\n+    }\n \n-  private void declarePrefix(String prefix, String uri)\n+    void endDoctype ()\n     throws SAXException\n-  {\n-    int index = uri.indexOf(':');\n-\n-    // many versions of nwalsh docbook stylesheets \n-    // have bogus URLs; so this can't be an error...\n-    if (index < 1 && uri.length() != 0)\n-      {\n-        warn(\"relative URI for namespace: \" + uri);\n-      }\n+    {\n+\tlexicalHandler.endDTD ();\n+    }\n \n-    // FIXME:  char [0] must be ascii alpha; chars [1..index]\n-    // must be ascii alphanumeric or in \"+-.\" [RFC 2396]\n-    \n-    //Namespace Constraints\n-    //name for xml prefix must be http://www.w3.org/XML/1998/namespace\n-    boolean prefixEquality = prefix.equals(\"xml\");\n-    boolean uriEquality = uri.equals(\"http://www.w3.org/XML/1998/namespace\");\n-    if ((prefixEquality || uriEquality) && !(prefixEquality && uriEquality))\n-      {\n-        fatal(\"xml is by definition bound to the namespace name \" +\n-              \"http://www.w3.org/XML/1998/namespace\");\n-      }\n-  \n-    //xmlns prefix declaration is illegal but xml prefix declaration is llegal...\n-    if (prefixEquality && uriEquality)\n-      {\n-        return;\n-      }\n-  \n-    //name for xmlns prefix must be http://www.w3.org/2000/xmlns/\n-    prefixEquality = prefix.equals(\"xmlns\");\n-    uriEquality = uri.equals(\"http://www.w3.org/2000/xmlns/\");\n-    if ((prefixEquality || uriEquality) && !(prefixEquality && uriEquality))\n-      {\n-        fatal(\"http://www.w3.org/2000/xmlns/ is by definition bound\" +\n-              \" to prefix xmlns\");\n-      }\n-  \n-    //even if the uri is http://www.w3.org/2000/xmlns/\n-    // it is illegal to declare it\n-    if (prefixEquality && uriEquality)\n-      {\n-        fatal (\"declaring the xmlns prefix is illegal\");\n-      }\n-  \n-    uri = uri.intern();\n-    prefixStack.declarePrefix(prefix, uri);\n-    contentHandler.startPrefixMapping(prefix, uri);\n-  }\n+    private void declarePrefix (String prefix, String uri)\n+    throws SAXException\n+    {\n+\tint index = uri.indexOf (':');\n+\n+\t// many versions of nwalsh docbook stylesheets \n+\t// have bogus URLs; so this can't be an error...\n+\tif (index < 1 && uri.length () != 0)\n+\t    warn (\"relative URI for namespace: \" + uri);\n+\n+\t// FIXME:  char [0] must be ascii alpha; chars [1..index]\n+\t// must be ascii alphanumeric or in \"+-.\" [RFC 2396]\n+\t\n+\t//Namespace Constraints\n+\t//name for xml prefix must be http://www.w3.org/XML/1998/namespace\n+\tboolean prefixEquality = prefix.equals(\"xml\");\n+\tboolean uriEquality = uri.equals(\"http://www.w3.org/XML/1998/namespace\");\n+\tif ((prefixEquality || uriEquality) && !(prefixEquality && uriEquality))\n+\t   fatal (\"xml is by definition bound to the namespace name \" +\n+\t   \t\t\"http://www.w3.org/XML/1998/namespace\");\n+\t\n+        //xmlns prefix declaration is illegal but xml prefix declaration is llegal...\n+\tif (prefixEquality && uriEquality)\n+\t   return;\n+\t\n+        //name for xmlns prefix must be http://www.w3.org/2000/xmlns/\n+\tprefixEquality = prefix.equals(\"xmlns\");\n+\turiEquality = uri.equals(\"http://www.w3.org/2000/xmlns/\");\n+\tif ((prefixEquality || uriEquality) && !(prefixEquality && uriEquality))\n+\t   fatal(\"http://www.w3.org/2000/xmlns/ is by definition bound\" +\n+\t   \t\t\" to prefix xmlns\");\n+\t\n+\t//even if the uri is http://www.w3.org/2000/xmlns/ it is illegal to declare it\n+\tif (prefixEquality && uriEquality)\n+\t   fatal (\"declaring the xmlns prefix is illegal\");\n+\t\t\n+\turi = uri.intern ();\n+\tprefixStack.declarePrefix (prefix, uri);\n+\tcontentHandler.startPrefixMapping (prefix, uri);\n+    }\n \n-  void attribute(String qname, String value, boolean isSpecified)\n+    void attribute (String qname, String value, boolean isSpecified)\n     throws SAXException\n-  {\n-    if (!attributes)\n-      {\n-        attributes = true;\n-        if (namespaces)\n-          {\n-            prefixStack.pushContext();\n-          }\n-      }\n-    \n-    // process namespace decls immediately;\n-    // then maybe forget this as an attribute\n-    if (namespaces)\n-      {\n-        int index;\n-        \n-        // default NS declaration?\n-        if (stringInterning)\n-          {\n-            if (\"xmlns\" == qname)\n-              {\n-                declarePrefix(\"\", value);\n-                if (!xmlNames)\n-                  {\n-                    return;\n-                  }\n-              }\n-            // NS prefix declaration?\n-            else if ((index = qname.indexOf(':')) == 5\n-                     && qname.startsWith(\"xmlns\"))\n-              {\n-                String prefix = qname.substring(6);\n-              \n-                if (prefix.equals(\"\"))\n-                  {\n-                    fatal(\"missing prefix \" +\n-                          \"in namespace declaration attribute\");  \n-                  }\n-                if (value.length() == 0)\n-                  {\n-                    verror(\"missing URI in namespace declaration attribute: \"\n-                           + qname);\n-                  }\n-                else\n-                  {\n-                    declarePrefix(prefix, value);\n-                  }\n-                if (!xmlNames)\n-                  {\n-                    return;\n-                  }\n-              }\n-          }\n-        else\n-          {\n-            if (\"xmlns\".equals(qname))\n-              {\n-                declarePrefix(\"\", value);\n-                if (!xmlNames)\n-                  {\n-                    return;\n-                  }\n-              }\n-            // NS prefix declaration?\n-            else if ((index = qname.indexOf(':')) == 5\n-                     && qname.startsWith(\"xmlns\"))\n-              {\n-                String prefix = qname.substring(6);\n-                \n-                if (value.length() == 0)\n-                  {\n-                    verror(\"missing URI in namespace decl attribute: \"\n-                           + qname);\n-                  }\n-                else\n-                  {\n-                    declarePrefix(prefix, value);\n-                  }\n-                if (!xmlNames)\n-                  {\n-                    return;\n-                  }\n-              }\n-          }\n+    {\n+\tif (!attributes) {\n+\t    attributes = true;\n+\t    if (namespaces)\n+\t\tprefixStack.pushContext ();\n+\t}\n+\n+\t// process namespace decls immediately;\n+\t// then maybe forget this as an attribute\n+\tif (namespaces) {\n+\t    int\tindex;\n+\n+      // default NS declaration?\n+      if (getFeature (FEATURE + \"string-interning\")) {\n+        if (\"xmlns\" == qname) {\n+          declarePrefix (\"\", value);\n+          if (!xmlNames)\n+            return;\n+        }\n+        // NS prefix declaration?\n+        else if ((index = qname.indexOf (':')) == 5\n+                 && qname.startsWith (\"xmlns\")) {\n+          String\t\tprefix = qname.substring (6);\n+          \n+          if (prefix.equals(\"\"))\n+          \tfatal (\"missing prefix in namespace declaration attribute\");\t\n+          if (value.length () == 0) {\n+            verror (\"missing URI in namespace declaration attribute: \"\n+                    + qname);\n+          } else\n+            declarePrefix (prefix, value);\n+          if (!xmlNames)\n+            return;\n+        }\n+      } else {\n+        if (\"xmlns\".equals(qname)) {\n+          declarePrefix (\"\", value);\n+          if (!xmlNames)\n+            return;\n+        }\n+        // NS prefix declaration?\n+        else if ((index = qname.indexOf (':')) == 5\n+                 && qname.startsWith (\"xmlns\")) {\n+          String\t\tprefix = qname.substring (6);\n+          \n+          if (value.length () == 0) {\n+            verror (\"missing URI in namespace decl attribute: \"\n+                    + qname);\n+          } else\n+            declarePrefix (prefix, value);\n+          if (!xmlNames)\n+            return;\n+        }\n       }\n-    // remember this attribute ...\n-    attributeCount++;\n-    \n-    // attribute type comes from querying parser's DTD records\n-    attributesList.add(new Attribute(qname, value, isSpecified));\n-    \n   }\n-  \n-  void startElement(String elname)\n+\t// remember this attribute ...\n+\n+\tattributeCount++;\n+\t\n+\t// attribute type comes from querying parser's DTD records\n+\tattributesList.add(new Attribute(qname, value, isSpecified));\n+\n+    }\n+\n+    void startElement (String elname)\n     throws SAXException\n-  {\n-    ContentHandler handler = contentHandler;\n+    {\n+\tContentHandler handler = contentHandler;\n+\n+\t//\n+\t// NOTE:  this implementation of namespace support adds something\n+\t// like six percent to parsing CPU time, in a large (~50 MB)\n+\t// document that doesn't use namespaces at all.  (Measured by PC\n+\t// sampling, with a bug where endElement processing was omitted.)\n+\t// [Measurement referred to older implementation, older JVM ...]\n+\t//\n+\t// It ought to become notably faster in such cases.  Most\n+\t// costs are the prefix stack calling Hashtable.get() (2%),\n+\t// String.hashCode() (1.5%) and about 1.3% each for pushing\n+\t// the context, and two chunks of name processing.\n+\t//\n+\n+\tif (!attributes) {\n+\t    if (namespaces)\n+\t\tprefixStack.pushContext ();\n+\t} else if (namespaces) {\n+\n+\t    // now we can patch up namespace refs; we saw all the\n+\t    // declarations, so now we'll do the Right Thing\n+\t    Iterator itt = attributesList.iterator ();\n+\t    while(itt.hasNext())\n+\t    {\n+\t    \tAttribute attribute = (Attribute) itt.next();\n+\t    \tString\tqname = attribute.name;\n+\t\tint\tindex;\n+\n+    // default NS declaration?\n+    if (getFeature (FEATURE + \"string-interning\")) {\n+      if (\"xmlns\" == qname)\n+\t\t    continue;\n+    } else {\n+      if (\"xmlns\".equals(qname))\n+\t\t    continue;\n+    }\n+               //Illegal in the new Namespaces Draft\n+               //should it be only in 1.1 docs??\n+               if (qname.equals (\":\"))\n+                   fatal (\"namespace names consisting of a single colon \" +\n+                   \t\t\"character are invalid\");\n+\t\tindex = qname.indexOf (':');\n+\n+\t\t// NS prefix declaration?\n+\t\tif (index == 5 && qname.startsWith (\"xmlns\"))\n+\t\t    continue;\n+\n+\t\t// it's not a NS decl; patch namespace info items\n+\t\tif (prefixStack.processName (qname, nsTemp, true) == null)\n+\t\t    fatal (\"undeclared attribute prefix in: \" + qname);\n+\t\telse {\n+\t\t    attribute.nameSpace = nsTemp[0];\n+\t\t    attribute.localName = nsTemp[1];\n+\t\t}\n+\t    }\n+\t}\n+\n+\t// save element name so attribute callbacks work\n+\telementName = elname;\n+\tif (namespaces) {\n+\t    if (prefixStack.processName (elname, nsTemp, false) == null) {\n+\t\tfatal (\"undeclared element prefix in: \" + elname);\n+\t\tnsTemp [0] = nsTemp [1] = \"\";\n+\t    }\n+\t    handler.startElement (nsTemp [0], nsTemp [1], elname, this);\n+\t} else\n+\t    handler.startElement (\"\", \"\", elname, this);\n+\t// elementName = null;\n+\n+\t// elements with no attributes are pretty common!\n+\tif (attributes) {\n+\t    attributesList.clear();\n+\t    attributeCount = 0;\n+\t    attributes = false;\n+\t}\n+    }\n \n-    //\n-    // NOTE:  this implementation of namespace support adds something\n-    // like six percent to parsing CPU time, in a large (~50 MB)\n-    // document that doesn't use namespaces at all.  (Measured by PC\n-    // sampling, with a bug where endElement processing was omitted.)\n-    // [Measurement referred to older implementation, older JVM ...]\n-    //\n-    // It ought to become notably faster in such cases.  Most\n-    // costs are the prefix stack calling Hashtable.get() (2%),\n-    // String.hashCode() (1.5%) and about 1.3% each for pushing\n-    // the context, and two chunks of name processing.\n-    //\n-    \n-    if (!attributes)\n-      {\n-        if (namespaces)\n-          {\n-            prefixStack.pushContext();\n-          }\n-      }\n-    else if (namespaces)\n-      {\n-      \n-        // now we can patch up namespace refs; we saw all the\n-        // declarations, so now we'll do the Right Thing\n-        Iterator itt = attributesList.iterator();\n-        while (itt.hasNext())\n-          {\n-            Attribute attribute = (Attribute) itt.next();\n-            String qname = attribute.name;\n-            int index;\n-            \n-            // default NS declaration?\n-            if (stringInterning)\n-              {\n-                if (\"xmlns\" == qname)\n-                  {\n-                    continue;\n-                  }\n-              }\n-            else\n-              {\n-                if (\"xmlns\".equals(qname))\n-                  {\n-                    continue;\n-                  }\n-              }\n-            //Illegal in the new Namespaces Draft\n-            //should it be only in 1.1 docs??\n-            if (qname.equals (\":\"))\n-              {\n-                fatal(\"namespace names consisting of a single colon \" +\n-                      \"character are invalid\");\n-              }\n-            index = qname.indexOf(':');\n-            \n-            // NS prefix declaration?\n-            if (index == 5 && qname.startsWith(\"xmlns\"))\n-              {\n-                continue;\n-              }\n-            \n-            // it's not a NS decl; patch namespace info items\n-            if (prefixStack.processName(qname, nsTemp, true) == null)\n-              {\n-                fatal(\"undeclared attribute prefix in: \" + qname);\n-              }\n-            else\n-              {\n-                attribute.nameSpace = nsTemp[0];\n-                attribute.localName = nsTemp[1];\n-              }\n-          }\n-      }\n-    \n-    // save element name so attribute callbacks work\n-    elementName = elname;\n-    if (namespaces)\n-      {\n-        if (prefixStack.processName(elname, nsTemp, false) == null)\n-          {\n-            fatal(\"undeclared element prefix in: \" + elname);\n-            nsTemp[0] = nsTemp[1] = \"\";\n-          }\n-        handler.startElement(nsTemp[0], nsTemp[1], elname, this);\n-      }\n-    else\n-      {\n-        handler.startElement(\"\", \"\", elname, this);\n-      }\n-    // elementName = null;\n-    \n-    // elements with no attributes are pretty common!\n-    if (attributes)\n-      {\n-        attributesList.clear();\n-        attributeCount = 0;\n-        attributes = false;\n-      }\n-  }\n-  \n-  void endElement(String elname)\n+    void endElement (String elname)\n     throws SAXException\n-  {\n-    ContentHandler handler = contentHandler;\n+    {\n+\tContentHandler\thandler = contentHandler;\n \n-    if (!namespaces)\n-      {\n-        handler.endElement(\"\", \"\", elname);\n-        return;\n-      }\n-    prefixStack.processName(elname, nsTemp, false);\n-    handler.endElement(nsTemp[0], nsTemp[1], elname);\n-    \n-    Enumeration prefixes = prefixStack.getDeclaredPrefixes();\n-    \n-    while (prefixes.hasMoreElements())\n-      {\n-        handler.endPrefixMapping((String) prefixes.nextElement());\n-      }\n-    prefixStack.popContext();\n-  }\n+\tif (!namespaces) {\n+\t    handler.endElement (\"\", \"\", elname);\n+\t    return;\n+\t}\n+\tprefixStack.processName (elname, nsTemp, false);\n+\thandler.endElement (nsTemp [0], nsTemp [1], elname);\n+\n+\tEnumeration\tprefixes = prefixStack.getDeclaredPrefixes ();\n \n-  void startCDATA()\n+\twhile (prefixes.hasMoreElements ())\n+\t    handler.endPrefixMapping ((String) prefixes.nextElement ());\n+\tprefixStack.popContext ();\n+    }\n+\n+    void startCDATA ()\n     throws SAXException\n-  {\n-    lexicalHandler.startCDATA();\n-  }\n+    {\n+\tlexicalHandler.startCDATA ();\n+    }\n \n-  void charData(char[] ch, int start, int length)\n+    void charData (char ch[], int start, int length)\n     throws SAXException\n-  {\n-    contentHandler.characters(ch, start, length);\n-  }\n+    {\n+\tcontentHandler.characters (ch, start, length);\n+    }\n \n-  void endCDATA()\n+    void endCDATA ()\n     throws SAXException\n-  {\n-    lexicalHandler.endCDATA();\n-  }\n+    {\n+\tlexicalHandler.endCDATA ();\n+    }\n \n-  void ignorableWhitespace(char[] ch, int start, int length)\n+    void ignorableWhitespace (char ch[], int start, int length)\n     throws SAXException\n-  {\n-    contentHandler.ignorableWhitespace(ch, start, length);\n-  }\n+    {\n+\tcontentHandler.ignorableWhitespace (ch, start, length);\n+    }\n \n-  void processingInstruction(String target, String data)\n+    void processingInstruction (String target, String data)\n     throws SAXException\n-  {\n-    contentHandler.processingInstruction(target, data);\n-  }\n+    {\n+\tcontentHandler.processingInstruction (target, data);\n+    }\n \n-  void comment(char[] ch, int start, int length)\n+    void comment (char ch[], int start, int length)\n     throws SAXException\n-  {\n-    if (lexicalHandler != base)\n-      {\n-        lexicalHandler.comment(ch, start, length);\n-      }\n-  }\n+    {\n+\tif (lexicalHandler != base)\n+\t    lexicalHandler.comment (ch, start, length);\n+    }\n \n-  void fatal(String message)\n+    void fatal (String message)\n     throws SAXException\n-  {\n-    SAXParseException fatal;\n-  \n-    fatal = new SAXParseException(message, this);\n-    errorHandler.fatalError(fatal);\n-\n-    // Even if the application can continue ... we can't!\n-    throw fatal;\n-  }\n+    {\n+\tSAXParseException fatal;\n+\t\n+\tfatal = new SAXParseException (message, this);\n+\terrorHandler.fatalError (fatal);\n+\n+\t// Even if the application can continue ... we can't!\n+\tthrow fatal;\n+    }\n \n-  // We can safely report a few validity errors that\n-  // make layered SAX2 DTD validation more conformant\n-  void verror(String message)\n+    // We can safely report a few validity errors that\n+    // make layered SAX2 DTD validation more conformant\n+    void verror (String message)\n     throws SAXException\n-  {\n-    SAXParseException err;\n-    \n-    err = new SAXParseException(message, this);\n-    errorHandler.error(err);\n-  }\n-  \n-  void warn(String message)\n+    {\n+\tSAXParseException err;\n+\t\n+\terr = new SAXParseException (message, this);\n+\terrorHandler.error (err);\n+    }\n+\n+    void warn (String message)\n     throws SAXException\n-  {\n-    SAXParseException err;\n-  \n-    err = new SAXParseException(message, this);\n-    errorHandler.warning(err);\n-  }\n+    {\n+\tSAXParseException err;\n+\t\n+\terr = new SAXParseException (message, this);\n+\terrorHandler.warning (err);\n+    }\n \n-  //\n-  // Implementation of org.xml.sax.Attributes.\n-  //\n-\n-  /**\n-   * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n-   * (don't invoke on parser);\n-   */\n-  public int getLength()\n-  {\n-    return attributesList.size();\n-  }\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public String getURI(int index)\n-  {\n-    if (index < 0 || index >= attributesList.size())\n-      {\n-        return null;\n-      }\n-    return ((Attribute) attributesList.get(index)).nameSpace;\n-  }\n+    //\n+    // Implementation of org.xml.sax.Attributes.\n+    //\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public String getLocalName(int index)\n-  {\n-    if (index < 0 || index >= attributesList.size())\n-      {\n-        return null;\n-      }\n-    Attribute attr = (Attribute) attributesList.get(index);\n-    // FIXME attr.localName is sometimes null, why?\n-    if (namespaces && attr.localName == null)\n-      {\n-        // XXX fix this here for now\n-        int ci = attr.name.indexOf(':');\n-        attr.localName = (ci == -1) ? attr.name :\n-          attr.name.substring(ci + 1);\n-      }\n-    return (attr.localName == null) ? \"\" : attr.localName;\n-  }\n+    /**\n+     * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n+     * (don't invoke on parser);\n+     */\n+    public int getLength ()\n+    {\n+\treturn attributesList.size();\n+    }\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public String getQName(int index)\n-  {\n-    if (index < 0 || index >= attributesList.size())\n-      {\n-      return null;\n-      }\n-    Attribute attr = (Attribute) attributesList.get(index);\n-    return (attr.name == null) ? \"\" : attr.name;\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public String getURI (int index)\n+    {\n+        if (index < 0 || index >= attributesList.size())\n+          {\n+            return null;\n+          }\n+\treturn ((Attribute) attributesList.get(index)).nameSpace;\n+    }\n \n-  /**\n-   * <b>SAX1 AttributeList</b> method (don't invoke on parser);\n-   */\n-  public String getName(int index)\n-  {\n-    return getQName(index);\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public String getLocalName (int index)\n+    {\n+        if (index < 0 || index >= attributesList.size())\n+          {\n+            return null;\n+          }\n+        Attribute attr = (Attribute) attributesList.get(index);\n+        // FIXME attr.localName is sometimes null, why?\n+        if (namespaces && attr.localName == null)\n+          {\n+            // XXX fix this here for now\n+            int ci = attr.name.indexOf(':');\n+            attr.localName = (ci == -1) ? attr.name :\n+              attr.name.substring(ci + 1);\n+          }\n+        return (attr.localName == null) ? \"\" : attr.localName;\n+    }\n \n-  /**\n-   * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n-   * (don't invoke on parser);\n-   */\n-  public String getType(int index)\n-  {\n-    if (index < 0 || index >= attributesList.size())\n-      {\n-        return null;\n-      }\n-    String type = parser.getAttributeType(elementName, getQName(index));\n-    if (type == null)\n-      {\n-        return \"CDATA\";\n-      }\n-    // ... use DeclHandler.attributeDecl to see enumerations\n-    if (type == \"ENUMERATION\")\n-      {\n-        return \"NMTOKEN\";\n-      }\n-    return type;\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public String getQName (int index)\n+    {\n+        if (index < 0 || index >= attributesList.size())\n+          {\n+            return null;\n+          }\n+        Attribute attr = (Attribute) attributesList.get(index);\n+    \treturn (attr.name == null) ? \"\" : attr.name;\n+    }\n \n-  /**\n-   * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n-   * (don't invoke on parser);\n-   */\n-  public String getValue(int index)\n-  {\n-    if (index < 0 || index >= attributesList.size())\n-      {\n-        return null;\n-      }\n-    return ((Attribute) attributesList.get(index)).value;\n-  }\n+    /**\n+     * <b>SAX1 AttributeList</b> method (don't invoke on parser);\n+     */\n+    public String getName (int index)\n+    {\n+    \treturn getQName(index);\n+    }\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public int getIndex(String uri, String local)\n+    /**\n+     * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n+     * (don't invoke on parser);\n+     */\n+    public String getType (int index)\n     {\n-      int length = getLength();\n-      \n-      for (int i = 0; i < length; i++)\n-        {\n-          if (!getURI(i).equals(uri))\n-            {\n-              continue;\n-            }\n-          if (getLocalName(i).equals(local))\n-            {\n-              return i;\n-            }\n-        }\n-      return -1;\n-  }\n+        if (index < 0 || index >= attributesList.size())\n+          {\n+            return null;\n+          }\n+\tString\ttype = parser.getAttributeType(elementName, getQName(index));\n+\tif (type == null)\n+          {\n+\t    return \"CDATA\";\n+          }\n+\t// ... use DeclHandler.attributeDecl to see enumerations\n+        if (type == \"ENUMERATION\")\n+          {\n+            return \"NMTOKEN\";\n+          }\n+        return type;\n+    }\n+\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public int getIndex(String xmlName)\n-  {\n-    int length = getLength();\n-    \n-    for (int i = 0; i < length; i++)\n-      {\n-        if (getQName(i).equals(xmlName))\n+    /**\n+     * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n+     * (don't invoke on parser);\n+     */\n+    public String getValue (int index)\n+    {\n+        if (index < 0 || index >= attributesList.size())\n           {\n-            return i;\n+            return null;\n           }\n-      }\n-    return -1;\n-  }\n+    \treturn ((Attribute) attributesList.get(index)).value;\n+    }\n \n-  /**\n-   * <b>SAX2 Attributes</b> method (don't invoke on parser);\n-   */\n-  public String getType(String uri, String local)\n-  {\n-    int index = getIndex(uri, local);\n-    \n-    if (index < 0)\n-      {\n-        return null;\n-      }\n-    return getType(index);\n-  }\n \n-  /**\n-   * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n-   * (don't invoke on parser);\n-   */\n-  public String getType(String xmlName)\n-  {\n-    int index = getIndex(xmlName);\n-    \n-    if (index < 0)\n-      {\n-        return null;\n-      }\n-    return getType(index);\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public int getIndex (String uri, String local)\n+    {\n+\tint length = getLength();\n \n-  /**\n-   * <b>SAX Attributes</b> method (don't invoke on parser);\n-   */\n-  public String getValue(String uri, String local)\n-  {\n-    int index = getIndex(uri, local);\n-    \n-    if (index < 0)\n-      {\n-        return null;\n-      }\n-    return getValue(index);\n-  }\n+\tfor (int i = 0; i < length; i++)\n+          {\n+            if (!getURI(i).equals(uri))\n+              {\n+\t\tcontinue;\n+              }\n+\t    if (getLocalName(i).equals(local))\n+              {\n+\t\treturn i;\n+              }\n+          }\n+\treturn -1;\n+    }\n \n-  /**\n-   * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n-   * (don't invoke on parser);\n-   */\n-  public String getValue(String xmlName)\n-  {\n-    int index = getIndex(xmlName);\n-    \n-    if (index < 0)\n-      {\n-        return null;\n-      }\n-    return getValue(index);\n-  }\n \n-  //\n-  // Implementation of org.xml.sax.ext.Attributes2\n-  //\n-\n-  /** @return false unless the attribute was declared in the DTD.\n-   * @throws java.lang.ArrayIndexOutOfBoundsException\n-   *   When the supplied index does not identify an attribute.\n-   */  \n-  public boolean isDeclared(int index)\n-  {\n-    if (index < 0 || index >= attributeCount)\n-      {\n-        throw new ArrayIndexOutOfBoundsException();\n-      }\n-    String type = parser.getAttributeType(elementName, getQName(index));\n-    return (type != null);\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public int getIndex (String xmlName)\n+    {\n+\tint length = getLength();\n \n-  /** @return false unless the attribute was declared in the DTD.\n-   * @throws java.lang.IllegalArgumentException\n-   *   When the supplied names do not identify an attribute.\n-   */\n-  public boolean isDeclared(String qName)\n-  {\n-    int index = getIndex(qName);\n-    if (index < 0)\n-      {\n-        throw new IllegalArgumentException();\n-      }\n-    String type = parser.getAttributeType(elementName, qName);\n-    return (type != null);\n-  }\n+\tfor (int i = 0; i < length; i++)\n+          {\n+            if (getQName(i).equals(xmlName))\n+              {\n+\t\treturn i;\n+              }\n+          }\n+\treturn -1;\n+    }\n \n-  /** @return false unless the attribute was declared in the DTD.\n-   * @throws java.lang.IllegalArgumentException\n-   *   When the supplied names do not identify an attribute.\n-   */\n-  public boolean isDeclared(String uri, String localName)\n-  {\n-    int index = getIndex(uri, localName);\n-    return isDeclared(index);\n-  }\n \n-  /**\n-   * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n-   */\n-  public boolean isSpecified(int index)\n-  {\n-    return ((Attribute) attributesList.get(index)).specified;\n-  }\n+    /**\n+     * <b>SAX2 Attributes</b> method (don't invoke on parser);\n+     */\n+    public String getType (String uri, String local)\n+    {\n+\tint index = getIndex(uri, local);\n \n-  /**\n-   * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n-   */\n-  public boolean isSpecified(String uri, String local)\n-  {\n-    int index = getIndex (uri, local);\n-    return isSpecified(index);\n-  }\n+\tif (index < 0)\n+          {\n+\t    return null;\n+          }\n+\treturn getType(index);\n+    }\n \n-  /**\n-   * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n-   */\n-  public boolean isSpecified(String xmlName)\n-  {\n-    int index = getIndex (xmlName);\n-    return isSpecified(index);\n-  }\n \n-  //\n-  // Implementation of org.xml.sax.Locator.\n-  //\n+    /**\n+     * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n+     * (don't invoke on parser);\n+     */\n+    public String getType (String xmlName)\n+    {\n+\tint index = getIndex(xmlName);\n \n-  /**\n-   * <b>SAX Locator</b> method (don't invoke on parser);\n-   */\n-  public String getPublicId()\n-  {\n-    return null;   // FIXME track public IDs too\n-  }\n+\tif (index < 0)\n+          {\n+\t    return null;\n+          }\n+\treturn getType(index);\n+    }\n \n-  /**\n-   * <b>SAX Locator</b> method (don't invoke on parser);\n-   */\n-  public String getSystemId()\n-  {\n-    if (entityStack.empty())\n-      {\n-        return null;\n-      }\n-    else\n-      {\n-        return (String) entityStack.peek();\n-      }\n-  }\n \n-  /**\n-   * <b>SAX Locator</b> method (don't invoke on parser);\n-   */\n-  public int getLineNumber()\n-  {\n-    return parser.getLineNumber();\n-  }\n+    /**\n+     * <b>SAX Attributes</b> method (don't invoke on parser);\n+     */\n+    public String getValue (String uri, String local)\n+    {\n+\tint index = getIndex(uri, local);\n \n-  /**\n-   * <b>SAX Locator</b> method (don't invoke on parser);\n-   */\n-  public int getColumnNumber()\n-  {\n-    return parser.getColumnNumber();\n-  }\n+\tif (index < 0)\n+          {\n+\t    return null;\n+          }\n+\treturn getValue(index);\n+    }\n \n-  // adapter between SAX2 content handler and SAX1 document handler callbacks\n-  private static class Adapter\n-    implements ContentHandler\n-  {\n-    \n-    private DocumentHandler docHandler;\n \n-    Adapter(DocumentHandler dh)\n+    /**\n+     * <b>SAX1 AttributeList, SAX2 Attributes</b> method\n+     * (don't invoke on parser);\n+     */\n+    public String getValue (String xmlName)\n     {\n-      docHandler = dh;\n+\tint index = getIndex(xmlName);\n+\n+\tif (index < 0)\n+          {\n+\t    return null;\n+          }\n+\treturn getValue(index);\n     }\n \n-    public void setDocumentLocator(Locator l)\n+\n+    //\n+    // Implementation of org.xml.sax.ext.Attributes2\n+    //\n+\n+\n+    /** @return false unless the attribute was declared in the DTD.\n+     * @throws java.lang.ArrayIndexOutOfBoundsException\n+     *   When the supplied index does not identify an attribute.\n+     */    \n+    public boolean isDeclared (int index)\n     {\n-      docHandler.setDocumentLocator(l);\n+\tif (index < 0 || index >= attributeCount) \n+\t    throw new ArrayIndexOutOfBoundsException ();\n+        String type = parser.getAttributeType(elementName, getQName(index));\n+        return (type != null);\n     }\n-  \n-    public void startDocument()\n-      throws SAXException\n+\n+    /** @return false unless the attribute was declared in the DTD.\n+     * @throws java.lang.IllegalArgumentException\n+     *   When the supplied names do not identify an attribute.\n+     */\n+    public boolean isDeclared (String qName)\n     {\n-      docHandler.startDocument();\n+\tint index = getIndex (qName);\n+\tif (index < 0)\n+\t    throw new IllegalArgumentException ();\n+        String type = parser.getAttributeType(elementName, qName);\n+        return (type != null);\n     }\n-  \n-    public void processingInstruction(String target, String data)\n-      throws SAXException\n+\n+    /** @return false unless the attribute was declared in the DTD.\n+     * @throws java.lang.IllegalArgumentException\n+     *   When the supplied names do not identify an attribute.\n+     */\n+    public boolean isDeclared (String uri, String localName)\n     {\n-      docHandler.processingInstruction(target, data);\n+\tint index = getIndex (uri, localName);\n+        return isDeclared(index);\n     }\n-  \n-    public void startPrefixMapping(String prefix, String uri)\n+\n+\n+    /**\n+     * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n+     */\n+    public boolean isSpecified (int index)\n     {\n-      /* ignored */\n+\treturn ((Attribute) attributesList.get(index)).specified;\n     }\n \n-    public void startElement(String namespace,\n-                             String local,\n-                             String name,\n-                             Attributes attrs)\n-      throws SAXException\n+    /**\n+     * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n+     */\n+    public boolean isSpecified (String uri, String local)\n     {\n-      docHandler.startElement(name, (AttributeList) attrs);\n+\tint index = getIndex (uri, local);\n+        return isSpecified(index);\n     }\n \n-    public void characters(char[] buf, int offset, int len)\n-      throws SAXException\n+    /**\n+     * <b>SAX-ext Attributes2</b> method (don't invoke on parser);\n+     */\n+    public boolean isSpecified (String xmlName)\n     {\n-      docHandler.characters(buf, offset, len);\n+\tint index = getIndex (xmlName);\n+        return isSpecified(index);\n     }\n \n-    public void ignorableWhitespace(char[] buf, int offset, int len)\n-      throws SAXException\n+\n+    //\n+    // Implementation of org.xml.sax.Locator.\n+    //\n+\n+    /**\n+     * <b>SAX Locator</b> method (don't invoke on parser);\n+     */\n+    public String getPublicId ()\n     {\n-      docHandler.ignorableWhitespace(buf, offset, len);\n+\treturn null; \t\t// FIXME track public IDs too\n     }\n \n-    public void skippedEntity(String name)\n+    /**\n+     * <b>SAX Locator</b> method (don't invoke on parser);\n+     */\n+    public String getSystemId ()\n     {\n-      /* ignored */\n+\tif (entityStack.empty ())\n+\t    return null;\n+\telse\n+\t    return (String) entityStack.peek ();\n     }\n \n-    public void endElement(String u, String l, String name)\n-      throws SAXException\n+    /**\n+     * <b>SAX Locator</b> method (don't invoke on parser);\n+     */\n+    public int getLineNumber ()\n     {\n-      docHandler.endElement(name);\n+\treturn parser.getLineNumber ();\n     }\n \n-    public void endPrefixMapping(String prefix)\n+    /**\n+     * <b>SAX Locator</b> method (don't invoke on parser);\n+     */\n+    public int getColumnNumber ()\n     {\n-      /* ignored */\n+\treturn parser.getColumnNumber ();\n     }\n \n-    public void endDocument()\n-      throws SAXException\n+    // adapter between SAX2 content handler and SAX1 document handler callbacks\n+    private static class Adapter implements ContentHandler\n     {\n-      docHandler.endDocument();\n+\tprivate DocumentHandler\t\tdocHandler;\n+\n+\tAdapter (DocumentHandler dh)\n+\t    { docHandler = dh; }\n+\n+\n+\tpublic void setDocumentLocator (Locator l)\n+\t    { docHandler.setDocumentLocator (l); }\n+\t\n+\tpublic void startDocument () throws SAXException\n+\t    { docHandler.startDocument (); }\n+\t\n+\tpublic void processingInstruction (String target, String data)\n+\tthrows SAXException\n+\t    { docHandler.processingInstruction (target, data); }\n+\t\n+\tpublic void startPrefixMapping (String prefix, String uri)\n+\t    { /* ignored */ }\n+\n+\tpublic void startElement (\n+\t    String\tnamespace,\n+\t    String\tlocal,\n+\t    String\tname,\n+\t    Attributes\tattrs\n+\t) throws SAXException\n+\t    { docHandler.startElement (name, (AttributeList) attrs); }\n+\n+\tpublic void characters (char buf [], int offset, int len)\n+\tthrows SAXException\n+\t    { docHandler.characters (buf, offset, len); }\n+\n+\tpublic void ignorableWhitespace (char buf [], int offset, int len)\n+\tthrows SAXException\n+\t    { docHandler.ignorableWhitespace (buf, offset, len); }\n+\n+\tpublic void skippedEntity (String name)\n+\t    { /* ignored */ }\n+\n+\tpublic void endElement (String u, String l, String name)\n+\tthrows SAXException\n+\t    { docHandler.endElement (name); }\n+\n+\tpublic void endPrefixMapping (String prefix)\n+\t    { /* ignored */ }\n+\n+\tpublic void endDocument () throws SAXException\n+\t    { docHandler.endDocument (); }\n     }\n-  }\n+}\n+\n+class Attribute\n+{\n \n-  private static class Attribute\n-  {\n-    \n     String name;\n     String value;\n     String nameSpace;\n     String localName;\n     boolean specified;\n-    \n+\n     Attribute(String name, String value, boolean specified)\n     {\n-      this.name = name;\n-      this.value = value;\n-      this.nameSpace = \"\";\n-      this.specified = specified;\n+        this.name = name;\n+        this.value = value;\n+        this.nameSpace = \"\";\n+        this.specified = specified;\n     }\n-    \n-  }\n-\n }\n+"}, {"sha": "f4abf222993a0641d9d7de139a731b80430986f6", "filename": "libjava/gnu/xml/aelfred2/XmlParser.java", "status": "modified", "additions": 4776, "deletions": 5498, "changes": 10274, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlParser.java?ref=acdf61e19b2cafd54d86ebee519ada2663a388bf"}, {"sha": "96c9c723fb6b912a7dc6b6732fe7d8cc205eba65", "filename": "libjava/gnu/xml/aelfred2/XmlReader.java", "status": "modified", "additions": 228, "deletions": 287, "changes": 515, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlReader.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/acdf61e19b2cafd54d86ebee519ada2663a388bf/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlReader.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fxml%2Faelfred2%2FXmlReader.java?ref=acdf61e19b2cafd54d86ebee519ada2663a388bf", "patch": "@@ -70,305 +70,246 @@\n  *\n  * @author David Brownell\n  */\n-public final class XmlReader\n-  implements XMLReader\n+public final class XmlReader implements XMLReader\n {\n+    private SAXDriver\t\taelfred2 = new SAXDriver ();\n+    private EventFilter\t\tfilter = new EventFilter ();\n+    private boolean\t\tisValidating;\n+    private boolean\t\tactive;\n \n-  static class FatalErrorHandler\n-    extends DefaultHandler2\n-  {\n-    \n-    public void error(SAXParseException e)\n-      throws SAXException\n+\n+    /** Constructs a SAX Parser.  */\n+    public XmlReader ()\n+\t{ }\n+\n+    /**\n+     * Constructs a SAX Parser, optionally treating validity errors\n+     * as if they were fatal errors.\n+     */\n+    public XmlReader (boolean invalidIsFatal)\n+    {\n+\tif (invalidIsFatal)\n+\t    setErrorHandler (new DefaultHandler2 () {\n+\t\tpublic void error (SAXParseException e)\n+\t\tthrows SAXException\n+\t\t    { throw e; }\n+\t\t});\n+    }\n+\n+    /**\n+     * <b>SAX2</b>: Returns the object used to report the logical\n+     * content of an XML document.\n+     */\n+    public ContentHandler getContentHandler ()\n+\t{ return filter.getContentHandler (); }\n+\n+    /**\n+     * <b>SAX2</b>: Assigns the object used to report the logical\n+     * content of an XML document.\n+     * @exception IllegalStateException if called mid-parse\n+     */\n+    public void setContentHandler (ContentHandler handler)\n     {\n-      throw e;\n+\tif (active)\n+\t    throw new IllegalStateException (\"already parsing\");\n+\tfilter.setContentHandler (handler);\n     }\n-    \n-  }\n-  \n-  private SAXDriver aelfred2 = new SAXDriver();\n-  private EventFilter filter = new EventFilter();\n-  private boolean isValidating;\n-  private boolean active;\n-\n-  /**\n-   * Constructs a SAX Parser.\n-   */\n-  public XmlReader()\n-  {\n-  }\n-\n-  /**\n-   * Constructs a SAX Parser, optionally treating validity errors\n-   * as if they were fatal errors.\n-   */\n-  public XmlReader(boolean invalidIsFatal)\n-  {\n-    if (invalidIsFatal)\n-      {\n-        setErrorHandler(new FatalErrorHandler());\n-      }\n-  }\n-  \n-  /**\n-   * <b>SAX2</b>: Returns the object used to report the logical\n-   * content of an XML document.\n-   */\n-  public ContentHandler getContentHandler()\n-  {\n-    return filter.getContentHandler();\n-  }\n-\n-  /**\n-   * <b>SAX2</b>: Assigns the object used to report the logical\n-   * content of an XML document.\n-   * @exception IllegalStateException if called mid-parse\n-   */\n-  public void setContentHandler(ContentHandler handler)\n-  {\n-    if (active)\n-      {\n-        throw new IllegalStateException(\"already parsing\");\n-      }\n-    filter.setContentHandler(handler);\n-  }\n-\n-  /**\n-   * <b>SAX2</b>: Returns the object used to process declarations related\n-   * to notations and unparsed entities.\n-   */\n-  public DTDHandler getDTDHandler()\n-  {\n-    return filter.getDTDHandler();\n-  }\n-\n-  /**\n-   * <b>SAX1</b> Assigns DTD handler\n-   * @exception IllegalStateException if called mid-parse\n-   */\n-  public void setDTDHandler(DTDHandler handler)\n-  {\n-    if (active)\n-      {\n-        throw new IllegalStateException(\"already parsing\");\n-      }\n-    filter.setDTDHandler(handler);\n-  }\n-  \n-  /**\n-   * <b>SAX2</b>: Returns the object used when resolving external\n-   * entities during parsing (both general and parameter entities).\n-   */\n-  public EntityResolver getEntityResolver()\n-  {\n-    return aelfred2.getEntityResolver();\n-  }\n-\n-  /**\n-   * <b>SAX1</b> Assigns parser's entity resolver\n-   */\n-  public void setEntityResolver(EntityResolver handler)\n-  {\n-    aelfred2.setEntityResolver(handler);\n-  }\n-\n-  /**\n-   * <b>SAX2</b>: Returns the object used to receive callbacks for XML\n-   * errors of all levels (fatal, nonfatal, warning); this is never null;\n-   */\n-  public ErrorHandler getErrorHandler()\n-  {\n-    return aelfred2.getErrorHandler();\n-  }\n-\n-  /**\n-   * <b>SAX1</b> Assigns error handler\n-   * @exception IllegalStateException if called mid-parse\n-   */\n-  public void setErrorHandler(ErrorHandler handler)\n-  {\n-    if (active)\n-      {\n-        throw new IllegalStateException(\"already parsing\");\n-      }\n-    aelfred2.setErrorHandler(handler);\n-  }\n-\n-  /**\n-   * <b>SAX2</b>:  Assigns the specified property.\n-   * @exception IllegalStateException if called mid-parse\n-   */\n-  public void setProperty(String propertyId, Object value)\n+\n+    /**\n+     * <b>SAX2</b>: Returns the object used to process declarations related\n+     * to notations and unparsed entities.\n+     */\n+    public DTDHandler getDTDHandler ()\n+\t{ return filter.getDTDHandler (); }\n+\n+    /**\n+     * <b>SAX1</b> Assigns DTD handler\n+     * @exception IllegalStateException if called mid-parse\n+     */\n+    public void setDTDHandler (DTDHandler handler)\n+    {\n+\tif (active)\n+\t    throw new IllegalStateException (\"already parsing\");\n+\tfilter.setDTDHandler (handler);\n+    }\n+\n+    /**\n+     * <b>SAX2</b>: Returns the object used when resolving external\n+     * entities during parsing (both general and parameter entities).\n+     */\n+    public EntityResolver getEntityResolver ()\n+\t{ return aelfred2.getEntityResolver (); }\n+\n+    /** <b>SAX1</b> Assigns parser's entity resolver */\n+    public void setEntityResolver (EntityResolver handler)\n+\t{ aelfred2.setEntityResolver (handler); }\n+\n+    /**\n+     * <b>SAX2</b>: Returns the object used to receive callbacks for XML\n+     * errors of all levels (fatal, nonfatal, warning); this is never null;\n+     */\n+    public ErrorHandler getErrorHandler ()\n+\t{ return aelfred2.getErrorHandler (); }\n+\n+    /**\n+     * <b>SAX1</b> Assigns error handler\n+     * @exception IllegalStateException if called mid-parse\n+     */\n+    public void setErrorHandler (ErrorHandler handler)\n+    {\n+\tif (active)\n+\t    throw new IllegalStateException (\"already parsing\");\n+\taelfred2.setErrorHandler (handler);\n+    }\n+\n+    /**\n+     * <b>SAX2</b>:  Assigns the specified property.\n+     * @exception IllegalStateException if called mid-parse\n+     */\n+    public void setProperty (String propertyId, Object value)\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    if (active)\n-      {\n-        throw new IllegalStateException(\"already parsing\");\n-      }\n-    if (getProperty(propertyId) != value)\n-      {\n-        filter.setProperty(propertyId, value);\n-      }\n-  }\n-\n-  /**\n-   * <b>SAX2</b>:  Returns the specified property.\n-   */\n-  public Object getProperty(String propertyId)\n+    {\n+\tif (active)\n+\t    throw new IllegalStateException (\"already parsing\");\n+\tif (getProperty (propertyId) != value)\n+\t    filter.setProperty (propertyId, value);\n+    }\n+\n+    /**\n+     * <b>SAX2</b>:  Returns the specified property.\n+     */\n+    public Object getProperty (String propertyId)\n     throws SAXNotRecognizedException\n-  {\n-    if ((SAXDriver.PROPERTY + \"declaration-handler\").equals(propertyId)\n-        || (SAXDriver.PROPERTY + \"lexical-handler\").equals(propertyId))\n-      {\n-        return filter.getProperty(propertyId);\n-      }\n-    throw new SAXNotRecognizedException(propertyId);\n-  }\n-  \n-  private void forceValidating()\n+    {\n+\tif ((SAXDriver.PROPERTY + \"declaration-handler\")\n+\t\t\t.equals (propertyId)\n+\t\t|| (SAXDriver.PROPERTY + \"lexical-handler\")\n+\t\t\t.equals (propertyId))\n+\t    return filter.getProperty (propertyId);\n+\tthrow new SAXNotRecognizedException (propertyId);\n+    }\n+\n+    private void forceValidating ()\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    aelfred2.setFeature(SAXDriver.FEATURE + \"namespace-prefixes\",\n-                        true);\n-    aelfred2.setFeature(SAXDriver.FEATURE + \"external-general-entities\",\n-                        true);\n-    aelfred2.setFeature(SAXDriver.FEATURE + \"external-parameter-entities\",\n-                        true);\n-  }\n-\n-  /**\n-   * <b>SAX2</b>:  Sets the state of features supported in this parser.\n-   * Note that this parser requires reporting of namespace prefixes when\n-   * validating.\n-   */\n-  public void setFeature(String featureId, boolean state)\n+    {\n+\taelfred2.setFeature (\n+\t    SAXDriver.FEATURE + \"namespace-prefixes\",\n+\t    true);\n+\taelfred2.setFeature (\n+\t    SAXDriver.FEATURE + \"external-general-entities\",\n+\t    true);\n+\taelfred2.setFeature (\n+\t    SAXDriver.FEATURE + \"external-parameter-entities\",\n+\t    true);\n+    }\n+\n+    /**\n+     * <b>SAX2</b>:  Sets the state of features supported in this parser.\n+     * Note that this parser requires reporting of namespace prefixes when\n+     * validating.\n+     */\n+    public void setFeature (String featureId, boolean state)\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    boolean value = getFeature(featureId);\n-\n-    if (state == value)\n-      {\n-        return;\n-      }\n-\n-    if ((SAXDriver.FEATURE + \"validation\").equals(featureId))\n-      {\n-        if (active)\n-          {\n-            throw new SAXNotSupportedException(\"already parsing\");\n-          }\n-        if (state)\n-          {\n-            forceValidating();\n-          }\n-        isValidating = state;\n-      }\n-    else\n-      {\n-        aelfred2.setFeature(featureId, state);\n-      }\n-  }\n-\n-  /**\n-   * <b>SAX2</b>: Tells whether this parser supports the specified feature.\n-   * At this time, this directly parallels the underlying SAXDriver,\n-   * except that validation is optionally supported.\n-   *\n-   * @see SAXDriver\n-   */\n-  public boolean getFeature(String featureId)\n+    {\n+\tboolean value = getFeature (featureId);\n+\n+\tif (state == value)\n+\t    return;\n+\n+\tif ((SAXDriver.FEATURE + \"validation\").equals (featureId)) {\n+\t    if (active)\n+\t\tthrow new SAXNotSupportedException (\"already parsing\");\n+\t    if (state)\n+\t\tforceValidating ();\n+\t    isValidating = state;\n+\t} else\n+\t    aelfred2.setFeature (featureId, state);\n+    }\n+\n+    /**\n+     * <b>SAX2</b>: Tells whether this parser supports the specified feature.\n+     * At this time, this directly parallels the underlying SAXDriver,\n+     * except that validation is optionally supported.\n+     *\n+     * @see SAXDriver\n+     */\n+    public boolean getFeature (String featureId)\n     throws SAXNotRecognizedException, SAXNotSupportedException\n-  {\n-    if ((SAXDriver.FEATURE + \"validation\").equals(featureId))\n-      {\n-        return isValidating;\n-      }\n-\n-    return aelfred2.getFeature(featureId);\n-  }\n-\n-  /**\n-   * <b>SAX1</b>: Sets the locale used for diagnostics; currently,\n-   * only locales using the English language are supported.\n-   * @param locale The locale for which diagnostics will be generated\n-   */\n-  public void setLocale(Locale locale)\n+    {\n+\tif ((SAXDriver.FEATURE + \"validation\").equals (featureId))\n+\t    return isValidating;\n+\n+\treturn aelfred2.getFeature (featureId);\n+    }\n+\n+    /**\n+     * <b>SAX1</b>: Sets the locale used for diagnostics; currently,\n+     * only locales using the English language are supported.\n+     * @param locale The locale for which diagnostics will be generated\n+     */\n+    public void setLocale (Locale locale)\n     throws SAXException\n-  {\n-    aelfred2.setLocale(locale);\n-  }\n+\t{ aelfred2.setLocale (locale); }\n \n-  /**\n-   * <b>SAX1</b>: Preferred API to parse an XML document, using a\n-   * system identifier (URI).\n+    /**\n+     * <b>SAX1</b>: Preferred API to parse an XML document, using a\n+     * system identifier (URI).\n      */\n-  public void parse(String systemId)\n-    throws SAXException, IOException\n-  {\n-    parse(new InputSource(systemId));\n-  }\n-\n-  /**\n-   * <b>SAX1</b>: Underlying API to parse an XML document, used\n-   * directly when no URI is available.  When this is invoked,\n-   * and the parser is set to validate, some features will be\n-   * automatically reset to appropriate values:  for reporting\n-   * namespace prefixes, and incorporating external entities.\n-   *\n-   * @param source The XML input source.\n-   *\n-   * @exception IllegalStateException if called mid-parse\n-   * @exception SAXException The handlers may throw any SAXException,\n-   *  and the parser normally throws SAXParseException objects.\n-   * @exception IOException IOExceptions are normally through through\n-   *  the parser if there are problems reading the source document.\n-   */\n-  public void parse(InputSource source)\n+    public void parse (String systemId)\n     throws SAXException, IOException\n-  {\n-    EventFilter next;\n-    boolean nsdecls;\n-\n-    synchronized (aelfred2)\n-      {\n-        if (active)\n-          {\n-            throw new IllegalStateException(\"already parsing\");\n-          }\n-        active = true;\n-      }\n-\n-    // set up the output pipeline\n-    if (isValidating)\n-      {\n-        forceValidating();\n-        next = new ValidationConsumer(filter);\n-      }\n-    else\n-      {\n-        next = filter;\n-      }\n-\n-    // connect pipeline and error handler\n-    // don't let _this_ call to bind() affect xmlns* attributes\n-    nsdecls = aelfred2.getFeature(SAXDriver.FEATURE + \"namespace-prefixes\");\n-    EventFilter.bind(aelfred2, next);\n-    if (!nsdecls)\n-      {\n-        aelfred2.setFeature(SAXDriver.FEATURE + \"namespace-prefixes\",\n-                            false);\n-      }\n-\n-    // parse, clean up\n-    try\n-      {\n-        aelfred2.parse(source);\n-      }\n-    finally\n-      {\n-        active = false;\n-      }\n-  }\n+    {\n+\tparse (new InputSource (systemId));\n+    }\n \n+    /**\n+     * <b>SAX1</b>: Underlying API to parse an XML document, used\n+     * directly when no URI is available.  When this is invoked,\n+     * and the parser is set to validate, some features will be\n+     * automatically reset to appropriate values:  for reporting\n+     * namespace prefixes, and incorporating external entities.\n+     *\n+     * @param source The XML input source.\n+     *\n+     * @exception IllegalStateException if called mid-parse\n+     * @exception SAXException The handlers may throw any SAXException,\n+     *\tand the parser normally throws SAXParseException objects.\n+     * @exception IOException IOExceptions are normally through through\n+     *\tthe parser if there are problems reading the source document.\n+     */\n+    public void parse (InputSource source)\n+    throws SAXException, IOException\n+    {\n+\tEventFilter\tnext;\n+\tboolean\t\tnsdecls;\n+\n+\tsynchronized (aelfred2) {\n+\t    if (active)\n+\t\tthrow new IllegalStateException (\"already parsing\");\n+\t    active = true;\n+\t}\n+\n+\t// set up the output pipeline\n+\tif (isValidating) {\n+\t    forceValidating ();\n+\t    next = new ValidationConsumer (filter);\n+\t} else\n+\t    next = filter;\n+\n+\t// connect pipeline and error handler\n+\t// don't let _this_ call to bind() affect xmlns* attributes\n+\tnsdecls = aelfred2.getFeature (\n+\t    SAXDriver.FEATURE + \"namespace-prefixes\");\n+\tEventFilter.bind (aelfred2, next);\n+\tif (!nsdecls)\n+\t    aelfred2.setFeature (\n+\t\tSAXDriver.FEATURE + \"namespace-prefixes\",\n+\t\tfalse);\n+\n+\t// parse, clean up\n+\ttry {\n+\t    aelfred2.parse (source);\n+\t} finally {\n+\t    active = false;\n+\t}\n+    }\n }\n-"}]}