{"sha": "e8c89d29703051af683fe65dc055089b61acde2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZThjODlkMjk3MDMwNTFhZjY4M2ZlNjVkYzA1NTA4OWI2MWFjZGUyZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2003-12-19T14:00:53Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2003-12-19T14:00:53Z"}, "message": "unwind-ia64.c (ia64_copy_rbs): New function.\n\n\t* config/ia64/unwind-ia64.c (ia64_copy_rbs): New function.\n\t(unw_access_gr): Only call ia64_rse_rnat_addr if addr is above\n\tregstk_top.\n\t(uw_frame_state_for): Handle locations inside bundles.\n\t(uw_init_context_1): Initialize context->rnat.\n\tSet context->regstk_top to lowest rbs address which has nat collection\n\tin context->rnat.\n\t(uw_install_context): Fix rnat restoring.\n\tRestore ar.rsc to previous state.\n\t* config/ia64/linux.h (MD_FALLBACK_FRAME_STATE_FOR,\n\tMD_HANDLE_UNWABI): Handle unwinding through SA_ONSTACK frames.\n\n\t* gcc.dg/cleanup-10.c: New test.\n\t* gcc.dg/cleanup-11.c: New test.\n\nFrom-SVN: r74835", "tree": {"sha": "7faf100b24bd243e8eba0de3b6bf9f538ba40ee2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7faf100b24bd243e8eba0de3b6bf9f538ba40ee2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e8c89d29703051af683fe65dc055089b61acde2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c89d29703051af683fe65dc055089b61acde2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8c89d29703051af683fe65dc055089b61acde2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8c89d29703051af683fe65dc055089b61acde2f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "effed6551681c1411cfaebeb005979cb6996e528", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/effed6551681c1411cfaebeb005979cb6996e528", "html_url": "https://github.com/Rust-GCC/gccrs/commit/effed6551681c1411cfaebeb005979cb6996e528"}], "stats": {"total": 402, "additions": 386, "deletions": 16}, "files": [{"sha": "ac10544a42db7ae0c19600b14e9a3b6041dc91a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -1,3 +1,17 @@\n+2003-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* config/ia64/unwind-ia64.c (ia64_copy_rbs): New function.\n+\t(unw_access_gr): Only call ia64_rse_rnat_addr if addr is above\n+\tregstk_top.\n+\t(uw_frame_state_for): Handle locations inside bundles.\n+\t(uw_init_context_1): Initialize context->rnat.\n+\tSet context->regstk_top to lowest rbs address which has nat collection\n+\tin context->rnat.\n+\t(uw_install_context): Fix rnat restoring.\n+\tRestore ar.rsc to previous state.\n+\t* config/ia64/linux.h (MD_FALLBACK_FRAME_STATE_FOR,\n+\tMD_HANDLE_UNWABI): Handle unwinding through SA_ONSTACK frames.\n+\n 2003-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/13239"}, {"sha": "fc7df808188211b947254b53af8c6be6b48c442c", "filename": "gcc/config/ia64/linux.h", "status": "modified", "additions": 32, "deletions": 2, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Fconfig%2Fia64%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Fconfig%2Fia64%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Flinux.h?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -97,14 +97,29 @@ do {\t\t\t\t\t\t\\\n       (CONTEXT)->br_loc[0] = &(sc_->sc_br[0]);\t\t\t\t\\\n       (CONTEXT)->br_loc[6] = &(sc_->sc_br[6]);\t\t\t\t\\\n       (CONTEXT)->br_loc[7] = &(sc_->sc_br[7]);\t\t\t\t\\\n-      (CONTEXT)->bsp = sc_->sc_ar_bsp;\t\t\t\t\t\\\n       (CONTEXT)->pr = sc_->sc_pr;\t\t\t\t\t\\\n       (CONTEXT)->psp = sc_->sc_gr[12];\t\t\t\t\t\\\n       (CONTEXT)->gp = sc_->sc_gr[1];\t\t\t\t\t\\\n       /* Signal frame doesn't have an associated reg. stack frame \t\\\n          other than what we adjust for below.\t  */\t\t\t\\\n       (FS) -> no_reg_stack_frame = 1;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (sc_->sc_rbs_base)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Need to switch from alternate register backing store.  */\t\\\n+\t  long ndirty, loadrs = sc_->sc_loadrs >> 16;\t\t\t\\\n+\t  unsigned long alt_bspstore = (CONTEXT)->bsp - loadrs;\t\t\\\n+\t  unsigned long bspstore;\t\t\t\t\t\\\n+\t  unsigned long *ar_bsp = (unsigned long *)(sc_->sc_ar_bsp);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\t\\\n+\t\t\t\t      (unsigned long *) (CONTEXT)->bsp);\\\n+\t  bspstore = (unsigned long)\t\t\t\t\t\\\n+\t\t     ia64_rse_skip_regs (ar_bsp, -ndirty);\t\t\\\n+\t  ia64_copy_rbs ((CONTEXT), bspstore, alt_bspstore, loadrs,\t\\\n+\t\t\t sc_->sc_ar_rnat);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       /* Don't touch the branch registers o.t. b0, b6 and b7.\t\t\\\n \t The kernel doesn't pass the preserved branch registers\t\t\\\n \t in the sigcontext but leaves them intact, so there's no\t\\\n@@ -154,13 +169,28 @@ do {\t\t\t\t\t\t\\\n       (CONTEXT)->br_loc[0] = &(sc_->sc_br[0]);\t\t\t\t\\\n       (CONTEXT)->br_loc[6] = &(sc_->sc_br[6]);\t\t\t\t\\\n       (CONTEXT)->br_loc[7] = &(sc_->sc_br[7]);\t\t\t\t\\\n-      (CONTEXT)->bsp = sc_->sc_ar_bsp;\t\t\t\t\t\\\n       (CONTEXT)->pr = sc_->sc_pr;\t\t\t\t\t\\\n       (CONTEXT)->gp = sc_->sc_gr[1];\t\t\t\t\t\\\n       /* Signal frame doesn't have an associated reg. stack frame \t\\\n          other than what we adjust for below.\t  */\t\t\t\\\n       (FS) -> no_reg_stack_frame = 1;\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n+      if (sc_->sc_rbs_base)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* Need to switch from alternate register backing store.  */\t\\\n+\t  long ndirty, loadrs = sc_->sc_loadrs >> 16;\t\t\t\\\n+\t  unsigned long alt_bspstore = (CONTEXT)->bsp - loadrs;\t\t\\\n+\t  unsigned long bspstore;\t\t\t\t\t\\\n+\t  unsigned long *ar_bsp = (unsigned long *)(sc_->sc_ar_bsp);\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  ndirty = ia64_rse_num_regs ((unsigned long *) alt_bspstore,\t\\\n+\t\t\t\t      (unsigned long *) (CONTEXT)->bsp);\\\n+\t  bspstore = (unsigned long)\t\t\t\t\t\\\n+\t\t     ia64_rse_skip_regs (ar_bsp, -ndirty);\t\t\\\n+\t  ia64_copy_rbs ((CONTEXT), bspstore, alt_bspstore, loadrs,\t\\\n+\t\t\t sc_->sc_ar_rnat);\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n       /* Don't touch the branch registers o.t. b0, b6 and b7.\t\t\\\n \t The kernel doesn't pass the preserved branch registers\t\t\\\n \t in the sigcontext but leaves them intact, so there's no\t\\"}, {"sha": "29c63fa13a7d2e5e301d3206a4f7ad714bd5e738", "filename": "gcc/config/ia64/unwind-ia64.c", "status": "modified", "additions": 107, "deletions": 14, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Fconfig%2Fia64%2Funwind-ia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Funwind-ia64.c?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -184,7 +184,8 @@ struct _Unwind_Context\n {\n   /* Initial frame info.  */\n   unsigned long rnat;\t\t/* rse nat collection */\n-  unsigned long regstk_top;\t/* bsp for first frame */\n+  unsigned long regstk_top;\t/* lowest address of rbs stored register\n+\t\t\t\t   which uses context->rnat collection */\n \n   /* Current frame info.  */\n   unsigned long bsp;\t\t/* backing store pointer value\n@@ -1492,6 +1493,80 @@ ia64_rse_skip_regs (unsigned long *addr, long num_regs)\n }\n \n \f\n+/* Copy register backing store from SRC to DST, LEN words\n+   (which include both saved registers and nat collections).\n+   DST_RNAT is a partial nat collection for DST.  SRC and DST\n+   don't have to be equal modulo 64 slots, so it cannot be\n+   done with a simple memcpy as the nat collections will be\n+   at different relative offsets and need to be combined together.  */\n+static void\n+ia64_copy_rbs (struct _Unwind_Context *info, unsigned long dst,\n+               unsigned long src, long len, unsigned long dst_rnat)\n+{\n+  long count;\n+  unsigned long src_rnat;\n+  unsigned long shift1, shift2;\n+\n+  len <<= 3;\n+  dst_rnat &= (1UL << ((dst >> 3) & 0x3f)) - 1;\n+  src_rnat = src >= info->regstk_top\n+\t     ? info->rnat : *(unsigned long *) (src | 0x1f8);\n+  src_rnat &= ~((1UL << ((src >> 3) & 0x3f)) - 1);\n+  /* Just to make sure.  */\n+  src_rnat &= ~(1UL << 63);\n+  shift1 = ((dst - src) >> 3) & 0x3f;\n+  if ((dst & 0x1f8) < (src & 0x1f8))\n+    shift1--;\n+  shift2 = 0x3f - shift1;\n+  if ((dst & 0x1f8) >= (src & 0x1f8))\n+    {\n+      count = ~dst & 0x1f8;\n+      goto first;\n+    }\n+  count = ~src & 0x1f8;\n+  goto second;\n+  while (len > 0)\n+    {\n+      src_rnat = src >= info->regstk_top\n+\t\t ? info->rnat : *(unsigned long *) (src | 0x1f8);\n+      /* Just to make sure.  */\n+      src_rnat &= ~(1UL << 63);\n+      count = shift2 << 3;\n+first:\n+      if (count > len)\n+        count = len;\n+      memcpy ((char *) dst, (char *) src, count);\n+      dst += count;\n+      src += count;\n+      len -= count;\n+      dst_rnat |= (src_rnat << shift1) & ~(1UL << 63);\n+      if (len <= 0)\n+        break;\n+      *(long *) dst = dst_rnat;\n+      dst += 8;\n+      dst_rnat = 0;\n+      count = shift1 << 3;\n+second:\n+      if (count > len)\n+        count = len;\n+      memcpy ((char *) dst, (char *) src, count);\n+      dst += count;\n+      src += count + 8;\n+      len -= count + 8;\n+      dst_rnat |= (src_rnat >> shift2);\n+    }\n+  if ((dst & 0x1f8) == 0x1f8)\n+    {\n+      *(long *) dst = dst_rnat;\n+      dst += 8;\n+      dst_rnat = 0;\n+    }\n+  /* Set info->regstk_top to lowest rbs address which will use\n+     info->rnat collection.  */\n+  info->regstk_top = dst & ~0x1ffUL;\n+  info->rnat = dst_rnat;\n+}\n+\n /* Unwind accessors.  */\n \n static void\n@@ -1551,9 +1626,10 @@ unw_access_gr (struct _Unwind_Context *info, int regnum,\n \t      break;\n \n \t    case UNW_NAT_REGSTK:\n-\t      nat_addr = ia64_rse_rnat_addr (addr);\n-\t      if ((unsigned long) nat_addr >= info->regstk_top)\n+\t      if ((unsigned long) addr >= info->regstk_top)\n \t\tnat_addr = &info->rnat;\n+\t      else\n+\t\tnat_addr = ia64_rse_rnat_addr (addr);\n \t      nat_mask = 1UL << ia64_rse_slot_num (addr);\n \t      break;\n \t    }\n@@ -1563,9 +1639,10 @@ unw_access_gr (struct _Unwind_Context *info, int regnum,\n     {\n       /* Access a stacked register.  */\n       addr = ia64_rse_skip_regs ((unsigned long *) info->bsp, regnum - 32);\n-      nat_addr = ia64_rse_rnat_addr (addr);\n-      if ((unsigned long) nat_addr >= info->regstk_top)\n+      if ((unsigned long) addr >= info->regstk_top)\n \tnat_addr = &info->rnat;\n+      else\n+\tnat_addr = ia64_rse_rnat_addr (addr);\n       nat_mask = 1UL << ia64_rse_slot_num (addr);\n     }\n \n@@ -1724,7 +1801,8 @@ uw_frame_state_for (struct _Unwind_Context *context, _Unwind_FrameState *fs)\n     }\n \n   context->region_start = ent->start_offset + segment_base;\n-  fs->when_target = (context->rp - context->region_start) / 16 * 3;\n+  fs->when_target = ((context->rp & -16) - context->region_start) / 16 * 3\n+\t\t    + (context->rp & 15);\n \n   unw = (unsigned long *) (ent->info_offset + segment_base);\n   header = *unw;\n@@ -1998,18 +2076,31 @@ uw_init_context_1 (struct _Unwind_Context *context, void *bsp)\n   /* Set psp to the caller's stack pointer.  */\n   void *psp = __builtin_dwarf_cfa () - 16;\n   _Unwind_FrameState fs;\n-\n-  /* Flush the register stack to memory so that we can access it.  */\n-  __builtin_ia64_flushrs ();\n+  unsigned long rnat, tmp1, tmp2;\n+\n+  /* Flush the register stack to memory so that we can access it.\n+     Get rse nat collection for the last incomplete rbs chunk of\n+     registers at the same time.  For this RSE needs to be turned\n+     into the mandatory only mode.  */\n+  asm (\"mov.m %1 = ar.rsc;;\\n\\t\"\n+       \"and %2 = 0x1c, %1;;\\n\\t\"\n+       \"mov.m ar.rsc = %2;;\\n\\t\"\n+       \"flushrs;;\\n\\t\"\n+       \"mov.m %0 = ar.rnat;;\\n\\t\"\n+       \"mov.m ar.rsc = %1\\n\\t\"\n+       : \"=r\" (rnat), \"=r\" (tmp1), \"=r\" (tmp2));\n \n   memset (context, 0, sizeof (struct _Unwind_Context));\n-  context->bsp = context->regstk_top = (unsigned long) bsp;\n+  context->bsp = (unsigned long) bsp;\n+  /* Set context->regstk_top to lowest rbs address which will use\n+     context->rnat collection.  */\n+  context->regstk_top = context->bsp & ~0x1ffULL;\n+  context->rnat = rnat;\n   context->psp = (unsigned long) psp;\n   context->rp = (unsigned long) rp;\n   asm (\"mov %0 = sp\" : \"=r\" (context->sp));\n   asm (\"mov %0 = pr\" : \"=r\" (context->pr));\n   context->pri_unat_loc = &context->initial_unat;\t/* ??? */\n-  /* ??? Get rnat.  Don't we have to turn off the rse for that?  */\n \n   if (uw_frame_state_for (context, &fs) != _URC_NO_REASON)\n     abort ();\n@@ -2050,6 +2141,9 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n     ia64_rse_skip_regs ((unsigned long *)target->bsp,\n \t\t\t(*target->pfs_loc >> 7) & 0x7f);\n \n+  if (target->bsp < target->regstk_top)\n+    target->rnat = *ia64_rse_rnat_addr ((unsigned long *) target->bsp);\n+\n   /* Provide assembly with the offsets into the _Unwind_Context.  */\n   asm volatile (\"uc_rnat = %0\"\n \t\t: : \"i\"(offsetof (struct _Unwind_Context, rnat)));\n@@ -2251,10 +2345,10 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n \t\"mov.m r25 = ar.rsc\t\t\t\\n\\t\"\n \t\"(p6) mov.m ar.fpsr = r30\t\t\\n\\t\"\n \t\";;\t\t\t\t\t\\n\\t\"\n-\t\"and r25 = 0x1c, r25\t\t\t\\n\\t\"\n+\t\"and r29 = 0x1c, r25\t\t\t\\n\\t\"\n \t\"mov b0 = r26\t\t\t\t\\n\\t\"\n \t\";;\t\t\t\t\t\\n\\t\"\n-\t\"mov.m ar.rsc = r25\t\t\t\\n\\t\"\n+\t\"mov.m ar.rsc = r29\t\t\t\\n\\t\"\n \t\";;\t\t\t\t\t\\n\\t\"\n \t/* This must be done before setting AR.BSPSTORE, otherwise \n \t   AR.BSP will be initialized with a random displacement\n@@ -2265,7 +2359,6 @@ uw_install_context (struct _Unwind_Context *current __attribute__((unused)),\n \t\";;\t\t\t\t\t\\n\\t\"\n \t\"mov.m ar.bspstore = r23\t\t\\n\\t\"\n \t\";;\t\t\t\t\t\\n\\t\"\n-\t\"or r25 = 0x3, r25\t\t\t\\n\\t\"\n \t\"mov.m ar.rnat = r22\t\t\t\\n\\t\"\n \t\";;\t\t\t\t\t\\n\\t\"\n \t\"mov.m ar.rsc = r25\t\t\t\\n\\t\""}, {"sha": "33e006ec38647ed239af0ce7faed012c17c478f9", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -1,3 +1,8 @@\n+2003-12-19  Jakub Jelinek  <jakub@redhat.com>\n+\n+\t* gcc.dg/cleanup-10.c: New test.\n+\t* gcc.dg/cleanup-11.c: New test.\n+\n 2003-12-19  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/13239"}, {"sha": "39923fdde15dc26f7d607402ca2d0807f29cc417", "filename": "gcc/testsuite/gcc.dg/cleanup-10.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-10.c?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through signal frames\n+   on alternate stack.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  stack_t ss;\n+  struct sigaction s;\n+\n+  ss.ss_size = 4 * sysconf (_SC_PAGESIZE);\n+  if (ss.ss_size < SIGSTKSZ)\n+    ss.ss_size = SIGSTKSZ;\n+  ss.ss_sp = malloc (ss.ss_size);\n+  if (ss.ss_sp == NULL)\n+    exit (1);\n+  ss.ss_flags = 0;\n+  if (sigaltstack (&ss, NULL) < 0)\n+    exit (1);\n+\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_ONESHOT | SA_ONSTACK;\n+  sigaction (SIGSEGV, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}, {"sha": "9c47f6cf6588eb71389a7f806ba5f8538a265983", "filename": "gcc/testsuite/gcc.dg/cleanup-11.c", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e8c89d29703051af683fe65dc055089b61acde2f/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fcleanup-11.c?ref=e8c89d29703051af683fe65dc055089b61acde2f", "patch": "@@ -0,0 +1,114 @@\n+/* { dg-do run { target i?86-*-linux* x86_64-*-linux* ia64-*-linux* alpha*-*-linux* powerpc*-*-linux* s390*-*-linux* sparc*-*-linux* mips*-*-linux* } } */\n+/* { dg-options \"-fasynchronous-unwind-tables -fexceptions -O2\" } */\n+/* Verify that cleanups work with exception handling through realtime signal\n+   frames on alternate stack.  */\n+\n+#include <unwind.h>\n+#include <stdlib.h>\n+#include <signal.h>\n+#include <unistd.h>\n+\n+static _Unwind_Reason_Code\n+force_unwind_stop (int version, _Unwind_Action actions,\n+                   _Unwind_Exception_Class exc_class,\n+                   struct _Unwind_Exception *exc_obj,\n+                   struct _Unwind_Context *context,\n+                   void *stop_parameter)\n+{\n+  if (actions & _UA_END_OF_STACK)\n+    abort ();\n+  return _URC_NO_REASON;\n+}\n+\n+static void force_unwind ()\n+{\n+  struct _Unwind_Exception *exc = malloc (sizeof (*exc));\n+  exc->exception_class = 0;\n+  exc->exception_cleanup = 0;\n+                   \n+#ifndef __USING_SJLJ_EXCEPTIONS__\n+  _Unwind_ForcedUnwind (exc, force_unwind_stop, 0);\n+#else\n+  _Unwind_SjLj_ForcedUnwind (exc, force_unwind_stop, 0);\n+#endif\n+                   \n+  abort ();\n+}\n+\n+int count;\n+char *null;\n+\n+static void counter (void *p __attribute__((unused)))\n+{\n+  ++count;\n+}\n+\n+static void handler (void *p __attribute__((unused)))\n+{\n+  if (count != 2)\n+    abort ();\n+  exit (0);\n+}\n+\n+static int __attribute__((noinline)) fn5 ()\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  force_unwind ();\n+  return 0;\n+}\n+\n+static void fn4 (int sig, siginfo_t *info, void *ctx)\n+{\n+  char dummy __attribute__((cleanup (counter)));\n+  fn5 ();\n+  null = NULL;\n+}\n+\n+static void fn3 ()\n+{\n+  abort ();\n+}\n+\n+static int __attribute__((noinline)) fn2 ()\n+{\n+  *null = 0;\n+  fn3 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn1 ()\n+{\n+  stack_t ss;\n+  struct sigaction s;\n+\n+  ss.ss_size = 4 * sysconf (_SC_PAGESIZE);\n+  if (ss.ss_size < SIGSTKSZ)\n+    ss.ss_size = SIGSTKSZ;\n+  ss.ss_sp = malloc (ss.ss_size);\n+  if (ss.ss_sp == NULL)\n+    exit (1);\n+  ss.ss_flags = 0;\n+  if (sigaltstack (&ss, NULL) < 0)\n+    exit (1);\n+\n+  sigemptyset (&s.sa_mask);\n+  s.sa_sigaction = fn4;\n+  s.sa_flags = SA_ONESHOT | SA_ONSTACK | SA_SIGINFO;\n+  sigaction (SIGSEGV, &s, NULL);\n+  fn2 ();\n+  return 0;\n+}\n+\n+static int __attribute__((noinline)) fn0 ()\n+{\n+  char dummy __attribute__((cleanup (handler)));\n+  fn1 ();\n+  null = 0;\n+  return 0;\n+}\n+\n+int main()\n+{ \n+  fn0 ();\n+  abort ();\n+}"}]}