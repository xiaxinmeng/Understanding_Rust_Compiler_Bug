{"sha": "283a25451f48b420c45ad4068031b121fd907767", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjgzYTI1NDUxZjQ4YjQyMGM0NWFkNDA2ODAzMWIxMjFmZDkwNzc2Nw==", "commit": {"author": {"name": "Robert Lipe", "email": "robertlipe@usa.net", "date": "1999-10-27T05:16:12Z"}, "committer": {"name": "Robert Lipe", "email": "robertl@gcc.gnu.org", "date": "1999-10-27T05:16:12Z"}, "message": "gcse.c (expr_reaches_here_p): Use xcalloc and explit free instead of alloca.\n\n        * gcse.c (expr_reaches_here_p): Use xcalloc and explit free instead\n        of alloca.\n        (pre_gcse): Likewise.\n        (hoist_expr_reaches_here_p): Likewise.\n        (hoist_code): Likewise.\n        (pre_expr_reaches_here_p): Replace alloca with xcalloc.   Move core\n        code to ...\n        (pre_expr_reaches_here_p_work): ... here.\n        (expr_reaches_here_p): Replace alloca with xcalloc.   Move core\n        code to ...\n        (expr_reaches_here_p_work): ... here.\n\nFrom-SVN: r30207", "tree": {"sha": "b96810740df706c665d254e6807b502dfcca8d2e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b96810740df706c665d254e6807b502dfcca8d2e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/283a25451f48b420c45ad4068031b121fd907767", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283a25451f48b420c45ad4068031b121fd907767", "html_url": "https://github.com/Rust-GCC/gccrs/commit/283a25451f48b420c45ad4068031b121fd907767", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/283a25451f48b420c45ad4068031b121fd907767/comments", "author": null, "committer": null, "parents": [{"sha": "d024732666bb406ca995f2a8c82f6168aa277f44", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d024732666bb406ca995f2a8c82f6168aa277f44", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d024732666bb406ca995f2a8c82f6168aa277f44"}], "stats": {"total": 124, "additions": 88, "deletions": 36}, "files": [{"sha": "b6839ada039a538d840784a5224def24d60a5e51", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283a25451f48b420c45ad4068031b121fd907767/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283a25451f48b420c45ad4068031b121fd907767/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=283a25451f48b420c45ad4068031b121fd907767", "patch": "@@ -1,3 +1,18 @@\n+\n+Wed Oct 27 00:14:13 1999  Robert Lipe  <robertlipe@usa.net>\n+\n+\t* gcse.c (expr_reaches_here_p): Use xcalloc and explit free instead\n+\tof alloca.\n+\t(pre_gcse): Likewise.\n+\t(hoist_expr_reaches_here_p): Likewise.\n+\t(hoist_code): Likewise.\n+\t(pre_expr_reaches_here_p): Replace alloca with xcalloc.   Move core\n+\tcode to ...\n+\t(pre_expr_reaches_here_p_work): ... here.\n+\t(expr_reaches_here_p): Replace alloca with xcalloc.   Move core \n+\tcode to ...\n+\t(expr_reaches_here_p_work): ... here.\n+\n Tue Oct 26 20:42:45 1999  Richard Henderson  <rth@cygnus.com>\n \n \t* resource.c (find_basic_block): Delete."}, {"sha": "7732cd3fe8da61844e39ecad0b0fa1cce0f2609f", "filename": "gcc/gcse.c", "status": "modified", "additions": 73, "deletions": 36, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/283a25451f48b420c45ad4068031b121fd907767/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/283a25451f48b420c45ad4068031b121fd907767/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=283a25451f48b420c45ad4068031b121fd907767", "patch": "@@ -585,7 +585,7 @@ static void alloc_pre_mem\t     PROTO ((int, int));\n static void free_pre_mem\t      PROTO ((void));\n static void compute_pre_data\t  PROTO ((void));\n static int pre_expr_reaches_here_p    PROTO ((int, struct expr *,\n-\t\t\t\t\t      int, int, char *));\n+\t\t\t\t\t      int, int));\n static void insert_insn_end_bb\tPROTO ((struct expr *, int, int));\n static void pre_insert_copy_insn      PROTO ((struct expr *, rtx));\n static void pre_insert_copies\t PROTO ((void));\n@@ -614,7 +614,7 @@ static void compute_ae_gen\t    PROTO ((void));\n static int expr_killed_p\t      PROTO ((rtx, int));\n static void compute_ae_kill\t   PROTO ((sbitmap *, sbitmap *));\n static int expr_reaches_here_p\tPROTO ((struct occr *, struct expr *,\n-\t\t\t\t\t      int, int, char *));\n+\t\t\t\t\t      int, int));\n static rtx computing_insn\t     PROTO ((struct expr *, rtx));\n static int def_reaches_here_p\t PROTO ((rtx, rtx));\n static int can_disregard_other_sets   PROTO ((struct reg_set **, rtx, int));\n@@ -2881,7 +2881,7 @@ compute_ae_kill (ae_gen, ae_kill)\n    the closest such expression.  */\n \n static int\n-expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n+expr_reaches_here_p_work (occr, expr, bb, check_self_loop, visited)\n      struct occr *occr;\n      struct expr *expr;\n      int bb;\n@@ -2890,12 +2890,6 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n {\n   edge pred;\n \n-  if (visited == NULL)\n-    {\n-      visited = (char *) alloca (n_basic_blocks);\n-      bzero (visited, n_basic_blocks);\n-    }\n-\n   for (pred = BASIC_BLOCK(bb)->pred; pred != NULL; pred = pred->pred_next)\n     {\n       int pred_bb = pred->src->index;\n@@ -2932,7 +2926,8 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n       else\n \t{\n \t  visited[pred_bb] = 1;\n-\t  if (expr_reaches_here_p (occr, expr, pred_bb, check_self_loop, visited))\n+\t  if (expr_reaches_here_p_work (occr, expr, pred_bb, check_self_loop, \n+\t      visited))\n \t    return 1;\n \t}\n     }\n@@ -2941,6 +2936,26 @@ expr_reaches_here_p (occr, expr, bb, check_self_loop, visited)\n   return 0;\n }\n \n+/* This wrapper for expr_reaches_here_p_work() is to ensure that any\n+   memory allocated for that function is returned. */\n+\n+static int\n+expr_reaches_here_p (occr, expr, bb, check_self_loop)\n+     struct occr *occr;\n+     struct expr *expr;\n+     int bb;\n+     int check_self_loop;\n+{\n+  int rval;\n+  char * visited = (char *) xcalloc (n_basic_blocks, 1);\n+\n+  rval = expr_reaches_here_p_work(occr, expr, bb, check_self_loop, visited);\n+  \n+  free (visited);\n+\n+  return (rval);\n+}\n+\n /* Return the instruction that computes EXPR that reaches INSN's basic block.\n    If there is more than one such instruction, return NULL.\n \n@@ -2984,7 +2999,7 @@ computing_insn (expr, insn)\n \t\t We let the normal cse pass handle the other cases.  */\n \t      if (INSN_CUID (insn) < INSN_CUID (occr->insn))\n \t\t{\n-\t\t  if (expr_reaches_here_p (occr, expr, bb, 1, NULL))\n+\t\t  if (expr_reaches_here_p (occr, expr, bb, 1))\n \t\t    {\n \t\t      can_reach++;\n \t\t      if (can_reach > 1)\n@@ -2995,7 +3010,7 @@ computing_insn (expr, insn)\n \t    }\n \t  else /* Computation of the pattern outside this block.  */\n \t    {\n-\t      if (expr_reaches_here_p (occr, expr, bb, 0, NULL))\n+\t      if (expr_reaches_here_p (occr, expr, bb, 0))\n \t\t{\n \t\t  can_reach++;\n \t\t  if (can_reach > 1)\n@@ -4178,7 +4193,7 @@ compute_pre_data ()\n    the closest such expression.  */\n \n static int\n-pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp, visited)\n+pre_expr_reaches_here_p_work (occr_bb, expr, bb, check_pre_comp, visited)\n      int occr_bb;\n      struct expr *expr;\n      int bb;\n@@ -4187,12 +4202,6 @@ pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp, visited)\n {\n   edge pred;\n \n-  if (visited == NULL)\n-    {\n-      visited = (char *) alloca (n_basic_blocks);\n-      bzero (visited, n_basic_blocks);\n-    }\n-\n   for (pred = BASIC_BLOCK (bb)->pred; pred != NULL; pred = pred->pred_next)\n     {\n       int pred_bb = pred->src->index;\n@@ -4221,15 +4230,36 @@ pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp, visited)\n       else\n \t{\n \t  visited[pred_bb] = 1;\n-\t  if (pre_expr_reaches_here_p (occr_bb, expr, pred_bb,\n-\t\t\t\t       check_pre_comp, visited))\n+\t  if (pre_expr_reaches_here_p_work (occr_bb, expr, pred_bb,\n+\t\t\t\t            check_pre_comp, visited))\n \t    return 1;\n \t}\n     }\n \n   /* All paths have been checked.  */\n   return 0;\n }\n+\n+/* The wrapper for pre_expr_reaches_here_work that ensures that any\n+   memory allocated for that function is returned. */\n+\n+static int\n+pre_expr_reaches_here_p (occr_bb, expr, bb, check_pre_comp)\n+     int occr_bb;\n+     struct expr *expr;\n+     int bb;\n+     int check_pre_comp;\n+{\n+  int rval;\n+  char * visited = (char *) xcalloc (n_basic_blocks, 1);\n+\n+  rval = pre_expr_reaches_here_p_work(occr_bb, expr, bb, check_pre_comp, \n+\t\t\t\t      visited);\n+\n+  free (visited);\n+\n+  return (rval);\n+}\n \f\n \n /* Given an expr, generate RTL which we can insert at the end of a BB,\n@@ -4472,8 +4502,7 @@ pre_edge_insert (edge_list, index_map)\n \t\t      if (!TEST_BIT (inserted[e], j)\n \t\t\t  && (bb == ENTRY_BLOCK \n \t\t\t      || pre_expr_reaches_here_p (bb, expr,\n-\t\t\t\t\t\t   BLOCK_NUM (occr->insn), 0,\n-\t\t\t\t\t\t   NULL)))\n+\t\t\t\t\t\t   BLOCK_NUM (occr->insn), 0)))\n \t\t\t{\n \t\t\t  rtx insn;\n \t\t\t  edge eg = INDEX_EDGE (edge_list, e);\n@@ -4597,8 +4626,7 @@ pre_insert_copies ()\n \t\t    continue;\n \t\t  /* Or if the expression doesn't reach the deleted one.  */\n \t\t  if (! pre_expr_reaches_here_p (BLOCK_NUM (avail->insn), expr,\n-\t\t\t\t\t\t BLOCK_NUM (occr->insn),\n-\t\t\t\t\t\t 1, NULL))\n+\t\t\t\t\t\t BLOCK_NUM (occr->insn),1))\n \t\t    continue;\n \n \t\t  /* Copy the result of avail to reaching_reg.  */\n@@ -4719,8 +4747,7 @@ pre_gcse ()\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) alloca (n_exprs * sizeof (struct expr *));\n-  bzero ((char *) index_map, n_exprs * sizeof (struct expr *));\n+  index_map = xcalloc (n_exprs, sizeof (struct expr *));\n   for (i = 0; i < expr_hash_table_size; i++)\n     {\n       struct expr *expr;\n@@ -4749,6 +4776,7 @@ pre_gcse ()\n       changed = 1;\n     }\n \n+  free (index_map);\n   free (pre_redundant_insns);\n \n   return changed;\n@@ -4985,10 +5013,10 @@ delete_null_pointer_checks (f)\n \n   /* We need predecessor/successor lists as well as pred/succ counts for\n      each basic block.  */\n-  s_preds = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  s_succs = (int_list_ptr *) alloca (n_basic_blocks * sizeof (int_list_ptr));\n-  num_preds = (int *) alloca (n_basic_blocks * sizeof (int));\n-  num_succs = (int *) alloca (n_basic_blocks * sizeof (int));\n+  s_preds = (int_list_ptr *) gmalloc (n_basic_blocks * sizeof (int_list_ptr));\n+  s_succs = (int_list_ptr *) gmalloc (n_basic_blocks * sizeof (int_list_ptr));\n+  num_preds = (int *) gmalloc (n_basic_blocks * sizeof (int));\n+  num_succs = (int *) gmalloc (n_basic_blocks * sizeof (int));\n   compute_preds_succs (s_preds, s_succs, num_preds, num_succs);\n \n   /* Allocate bitmaps to hold local and global properties.  */\n@@ -5141,6 +5169,12 @@ delete_null_pointer_checks (f)\n   /* Free storage allocated by find_basic_blocks.  */\n   free_basic_block_vars (0);\n \n+  /* Free our local predecessor/successor lists. */\n+  free (s_preds);\n+  free (s_succs);\n+  free (num_preds);\n+  free (num_succs);\n+\n   /* Free bitmaps.  */\n   free (nonnull_local);\n   free (nonnull_killed);\n@@ -5273,11 +5307,13 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n      char *visited;\n {\n   edge pred;\n+  int visited_allocated_locally = 0;\n+  \n \n   if (visited == NULL)\n     {\n-      visited = (char *) alloca (n_basic_blocks);\n-      bzero (visited, n_basic_blocks);\n+       visited_allocated_locally = 1;\n+       visited = xcalloc (n_basic_blocks, 1);\n     }\n \n   visited[expr_bb] = 1;\n@@ -5303,7 +5339,8 @@ hoist_expr_reaches_here_p (expr_bb, expr_index, bb, visited)\n \t    break;\n \t}\n     }\n-\n+  if (visited_allocated_locally) \n+    free (visited);\n   return (pred == NULL);\n }\n \f\n@@ -5319,8 +5356,7 @@ hoist_code ()\n   /* Compute a mapping from expression number (`bitmap_index') to\n      hash table entry.  */\n \n-  index_map = (struct expr **) alloca (n_exprs * sizeof (struct expr *));\n-  bzero ((char *) index_map, n_exprs * sizeof (struct expr *));\n+  index_map = xcalloc (n_exprs, sizeof (struct expr *));\n   for (i = 0; i < expr_hash_table_size; i++)\n     {\n       struct expr *expr;\n@@ -5473,6 +5509,7 @@ hoist_code ()\n \t    }\n \t}\n     }\n+    free (index_map);\n }\n \n /* Top level routine to perform one code hoisting (aka unification) pass"}]}