{"sha": "7fcd72187907e12fa670d7c4794641691b30e825", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjZDcyMTg3OTA3ZTEyZmE2NzBkN2M0Nzk0NjQxNjkxYjMwZTgyNQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2001-11-19T17:08:48Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2001-11-19T17:08:48Z"}, "message": "gcse.c (try_replace_reg): Copy RTX before creating note.\n\n\t* gcse.c (try_replace_reg): Copy RTX before creating note.\n\n\t* df.h (df_ref_flags): New uenum.\n\t(DF_REF_FLAGS): New macro.\n\t(struct ref): Add field \"flags\".\n\t* df.c (HANDLE_SUBREG): Remove.\n\t(df_ref_create): Likewise; set flags field of ref.\n\t(df_def_record_1): Strip down read_write subreg; remove\n\tcommented out code; set READ_WRITE flag.\n\t(read_modify_subreg_p): New static function.\n\t(df_uses_record): Cleanup SET handling; set READ_WRITE flag;\n\tnew argument \"flags\".\n\t(df_insn_refs_record): Update call of df_uses_record.\n\t(df_insn_modify): Avoid #if 0 around comment.\n\t(df_dump): Dump the read/write flag.\n\n\t* predict.c (propagate_freq): Make cyclic_probability and frequency\n\tvolatile\n\n\t* i386.c (ix86_cc_mode): Accept USE.\n\n\t* cfgrtl.c (purge_dead_edges):  Cleanup EDGE_ABNORMAL flag if computed\n\tjump is turned into simplejump.\n\nFrom-SVN: r47175", "tree": {"sha": "b294c67de998851f229c1f90e61eb62fdc07c65f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b294c67de998851f229c1f90e61eb62fdc07c65f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fcd72187907e12fa670d7c4794641691b30e825", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcd72187907e12fa670d7c4794641691b30e825", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcd72187907e12fa670d7c4794641691b30e825", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcd72187907e12fa670d7c4794641691b30e825/comments", "author": null, "committer": null, "parents": [{"sha": "f83fd9ae2ea1ea580626ed3171c1f5c46a4a05ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f83fd9ae2ea1ea580626ed3171c1f5c46a4a05ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f83fd9ae2ea1ea580626ed3171c1f5c46a4a05ea"}], "stats": {"total": 282, "additions": 152, "deletions": 130}, "files": [{"sha": "12f897d29b615bcb1be499459b3310525a69f9ee", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -1,3 +1,29 @@\n+Mon Nov 19 18:06:21 CET 2001  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcse.c (try_replace_reg): Copy RTX before creating note.\n+\n+\t* df.h (df_ref_flags): New uenum.\n+\t(DF_REF_FLAGS): New macro.\n+\t(struct ref): Add field \"flags\".\n+\t* df.c (HANDLE_SUBREG): Remove.\n+\t(df_ref_create): Likewise; set flags field of ref.\n+\t(df_def_record_1): Strip down read_write subreg; remove\n+\tcommented out code; set READ_WRITE flag.\n+\t(read_modify_subreg_p): New static function.\n+\t(df_uses_record): Cleanup SET handling; set READ_WRITE flag;\n+\tnew argument \"flags\".\n+\t(df_insn_refs_record): Update call of df_uses_record.\n+\t(df_insn_modify): Avoid #if 0 around comment.\n+\t(df_dump): Dump the read/write flag.\n+\n+\t* predict.c (propagate_freq): Make cyclic_probability and frequency\n+\tvolatile\n+\n+\t* i386.c (ix86_cc_mode): Accept USE.\n+\n+\t* cfgrtl.c (purge_dead_edges):  Cleanup EDGE_ABNORMAL flag if computed\n+\tjump is turned into simplejump.\n+\n 2001-11-19  Joseph S. Myers  <jsm28@cam.ac.uk>\n \n \t* doc/fragments.texi, doc/trouble.texi: Remove links to old"}, {"sha": "2687e73d358e1335b40f69f86f7dc128ec29d285", "filename": "gcc/cfgrtl.c", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fcfgrtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fcfgrtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgrtl.c?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -1837,6 +1837,11 @@ purge_dead_edges (bb)\n \t{\n \t  next = e->succ_next;\n \n+\t  /* Avoid abnormal flags to leak from computed jumps turned\n+\t     into simplejumps.  */\n+ \n+\t  e->flags &= EDGE_ABNORMAL;\n+\n \t  /* Check purposes we can have edge.  */\n \t  if ((e->flags & EDGE_FALLTHRU)\n \t      && any_condjump_p (insn))"}, {"sha": "46ef9f0afb76866ca28464ff120131d02d7e6233", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -7099,6 +7099,10 @@ ix86_cc_mode (code, op0, op1)\n \treturn CCNOmode;\n       else\n \treturn CCGCmode;\n+      /* strcmp pattern do (use flags) and combine may ask us for proper\n+\t mode.  */\n+    case USE:\n+      return CCmode;\n     default:\n       abort ();\n     }"}, {"sha": "97184c58cf21c1b4f9edafa67aaebacbeb8bf42d", "filename": "gcc/df.c", "status": "modified", "additions": 103, "deletions": 125, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fdf.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fdf.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.c?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -227,15 +227,18 @@ static void df_refs_unlink PARAMS ((struct df *, bitmap));\n \n static struct ref *df_ref_create PARAMS((struct df *,\n \t\t\t\t\t rtx, rtx *, basic_block, rtx,\n-\t\t\t\t\t enum df_ref_type));\n+\t\t\t\t\t enum df_ref_type, enum df_ref_flags));\n static void df_ref_record_1 PARAMS((struct df *, rtx, rtx *,\n-\t\t\t\t    basic_block, rtx, enum df_ref_type));\n+\t\t\t\t    basic_block, rtx, enum df_ref_type,\n+\t\t\t\t    enum df_ref_flags));\n static void df_ref_record PARAMS((struct df *, rtx, rtx *,\n-\t\t\t\t  basic_block bb, rtx, enum df_ref_type));\n+\t\t\t\t  basic_block bb, rtx, enum df_ref_type,\n+\t\t\t\t  enum df_ref_flags));\n static void df_def_record_1 PARAMS((struct df *, rtx, basic_block, rtx));\n static void df_defs_record PARAMS((struct df *, rtx, basic_block, rtx));\n static void df_uses_record PARAMS((struct df *, rtx *,\n-\t\t\t\t   enum df_ref_type, basic_block, rtx));\n+\t\t\t\t   enum df_ref_type, basic_block, rtx,\n+\t\t\t\t   enum df_ref_flags));\n static void df_insn_refs_record PARAMS((struct df *, basic_block, rtx));\n static void df_bb_refs_record PARAMS((struct df *, basic_block));\n static void df_refs_record PARAMS((struct df *, bitmap));\n@@ -298,6 +301,7 @@ static void df_ru_transfer_function PARAMS ((int, int *, bitmap, bitmap,\n \t\t\t\t\t     bitmap, bitmap, void *));\n static void df_lr_transfer_function PARAMS ((int, int *, bitmap, bitmap, \n \t\t\t\t\t     bitmap, bitmap, void *));\n+static inline bool read_modify_subreg_p PARAMS ((rtx));\n \n \f\n /* Local memory allocation/deallocation routines.  */\n@@ -780,13 +784,14 @@ df_use_unlink (df, use)\n /* Create a new ref of type DF_REF_TYPE for register REG at address\n    LOC within INSN of BB.  */\n static struct ref *\n-df_ref_create (df, reg, loc, bb, insn, ref_type)\n+df_ref_create (df, reg, loc, bb, insn, ref_type, ref_flags)\n      struct df *df;\n      rtx reg;\n      rtx *loc;\n      basic_block bb;\n      rtx insn;\n      enum df_ref_type ref_type;\n+     enum df_ref_flags ref_flags;\n {\n   struct ref *this_ref;\n   unsigned int uid;\n@@ -799,6 +804,7 @@ df_ref_create (df, reg, loc, bb, insn, ref_type)\n   DF_REF_INSN (this_ref) = insn;\n   DF_REF_CHAIN (this_ref) = 0;\n   DF_REF_TYPE (this_ref) = ref_type;\n+  DF_REF_FLAGS (this_ref) = ref_flags;\n   uid = INSN_UID (insn);\n \n   if (ref_type == DF_REF_REG_DEF)\n@@ -832,28 +838,30 @@ df_ref_create (df, reg, loc, bb, insn, ref_type)\n /* Create a new reference of type DF_REF_TYPE for a single register REG,\n    used inside the LOC rtx of INSN.  */\n static void\n-df_ref_record_1 (df, reg, loc, bb, insn, ref_type)\n+df_ref_record_1 (df, reg, loc, bb, insn, ref_type, ref_flags)\n      struct df *df;\n      rtx reg;\n      rtx *loc;\n      basic_block bb;\n      rtx insn;\n      enum df_ref_type ref_type;\n+     enum df_ref_flags ref_flags;\n {\n-  df_ref_create (df, reg, loc, bb, insn, ref_type);\n+  df_ref_create (df, reg, loc, bb, insn, ref_type, ref_flags);\n }\n \n \n /* Create new references of type DF_REF_TYPE for each part of register REG\n    at address LOC within INSN of BB.  */\n static void\n-df_ref_record (df, reg, loc, bb, insn, ref_type)\n+df_ref_record (df, reg, loc, bb, insn, ref_type, ref_flags)\n      struct df *df;\n      rtx reg;\n      rtx *loc;\n      basic_block bb;\n      rtx insn;\n      enum df_ref_type ref_type;\n+     enum df_ref_flags ref_flags;\n {\n   unsigned int regno;\n \n@@ -892,14 +900,30 @@ df_ref_record (df, reg, loc, bb, insn, ref_type)\n \n       for (i = regno; i < endregno; i++)\n \tdf_ref_record_1 (df, gen_rtx_REG (reg_raw_mode[i], i),\n-\t\t\t loc, bb, insn, ref_type);\n+\t\t\t loc, bb, insn, ref_type, ref_flags);\n     }\n   else\n     {\n-      df_ref_record_1 (df, reg, loc, bb, insn, ref_type);\n+      df_ref_record_1 (df, reg, loc, bb, insn, ref_type, ref_flags);\n     }\n }\n \n+/* Writes to SUBREG of inndermode wider than word and outermode shorter than\n+   word are read-modify-write.  */\n+\n+static inline bool\n+read_modify_subreg_p (x)\n+     rtx x;\n+{\n+  if (GET_CODE (x) != SUBREG)\n+    return false;\n+  if (GET_MODE_SIZE (GET_MODE (SUBREG_REG (x))) <= UNITS_PER_WORD)\n+    return false;\n+  if (GET_MODE_SIZE (GET_MODE (x)) > UNITS_PER_WORD)\n+    return false;\n+  return true;\n+}\n+\n /* Process all the registers defined in the rtx, X.  */\n static void\n df_def_record_1 (df, x, bb, insn)\n@@ -910,6 +934,7 @@ df_def_record_1 (df, x, bb, insn)\n {\n   rtx *loc = &SET_DEST (x);\n   rtx dst = *loc;\n+  enum df_ref_flags flags = 0;\n \n   /* Some targets place small structures in registers for\n      return values of functions.  */\n@@ -924,38 +949,26 @@ df_def_record_1 (df, x, bb, insn)\n \n   /* May be, we should flag the use of strict_low_part somehow.  Might be\n      handy for the reg allocator.  */\n-#ifdef HANDLE_SUBREG\n   while (GET_CODE (dst) == STRICT_LOW_PART\n          || GET_CODE (dst) == ZERO_EXTRACT\n-\t || GET_CODE (dst) == SIGN_EXTRACT)\n-    {\n-      loc = &XEXP (dst, 0);\n-      dst = *loc;\n-    }\n-  /* For the reg allocator we are interested in exact register references.\n-     This means, we want to know, if only a part of a register is\n-     used/defd.  */\n-/*\n-  if (GET_CODE (dst) == SUBREG)\n-    {\n-      loc = &XEXP (dst, 0);\n-      dst = *loc;\n-    } */\n-#else\n-\n-  while (GET_CODE (dst) == SUBREG\n-\t || GET_CODE (dst) == ZERO_EXTRACT\n \t || GET_CODE (dst) == SIGN_EXTRACT\n-\t || GET_CODE (dst) == STRICT_LOW_PART)\n+\t || read_modify_subreg_p (dst))\n     {\n+      /* Strict low part allways contains SUBREG, but we don't want to make\n+\t it appear outside, as whole register is allways considered.  */\n+      if (GET_CODE (dst) == STRICT_LOW_PART)\n+\t{\n+\t  loc = &XEXP (dst, 0);\n+\t  dst = *loc;\n+\t}\n       loc = &XEXP (dst, 0);\n       dst = *loc;\n+      flags |= DF_REF_READ_WRITE;\n     }\n-#endif\n   \n     if (GET_CODE (dst) == REG\n         || (GET_CODE (dst) == SUBREG && GET_CODE (SUBREG_REG (dst)) == REG))\n-      df_ref_record (df, dst, loc, bb, insn, DF_REF_REG_DEF);\n+      df_ref_record (df, dst, loc, bb, insn, DF_REF_REG_DEF, flags);\n }\n \n \n@@ -991,18 +1004,21 @@ df_defs_record (df, x, bb, insn)\n \n /* Process all the registers used in the rtx at address LOC.  */\n static void\n-df_uses_record (df, loc, ref_type, bb, insn)\n+df_uses_record (df, loc, ref_type, bb, insn, flags)\n      struct df *df;\n      rtx *loc;\n      enum df_ref_type ref_type;\n      basic_block bb;\n      rtx insn;\n+     enum df_ref_flags flags;\n {\n   RTX_CODE code;\n   rtx x;\n \n  retry:\n   x = *loc;\n+  if (!x)\n+    return;\n   code = GET_CODE (x);\n   switch (code)\n     {\n@@ -1021,120 +1037,78 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t as being used.  */\n       if (GET_CODE (XEXP (x, 0)) == MEM)\n \tdf_uses_record (df, &XEXP (XEXP (x, 0), 0),\n-\t\t\tDF_REF_REG_MEM_STORE, bb, insn);\n+\t\t\tDF_REF_REG_MEM_STORE, bb, insn, flags);\n \n       /* If we're clobbering a REG then we have a def so ignore.  */\n       return;\n \n     case MEM:\n-      df_uses_record (df, &XEXP (x, 0), DF_REF_REG_MEM_LOAD, bb, insn);\n+      df_uses_record (df, &XEXP (x, 0), DF_REF_REG_MEM_LOAD, bb, insn, flags);\n       return;\n \n     case SUBREG:\n       /* While we're here, optimize this case.  */\n-#if defined(HANDLE_SUBREG)\n \n       /* In case the SUBREG is not of a register, don't optimize.  */\n       if (GET_CODE (SUBREG_REG (x)) != REG)\n \t{\n \t  loc = &SUBREG_REG (x);\n-\t  df_uses_record (df, loc, ref_type, bb, insn);\n+\t  df_uses_record (df, loc, ref_type, bb, insn, flags);\n \t  return;\n \t}\n \n-#else\n-      loc = &SUBREG_REG (x);\n-      x = *loc;\n-      if (GET_CODE (x) != REG)\n-\t{\n-\t  df_uses_record (df, loc, ref_type, bb, insn);\n-\t  return;\n-\t}\n-#endif\n       /* ... Fall through ...  */\n \n     case REG:\n       /* See a register (or subreg) other than being set.  */\n-      df_ref_record (df, x, loc, bb, insn, ref_type);\n+      df_ref_record (df, x, loc, bb, insn, ref_type, flags);\n       return;\n \n     case SET:\n       {\n \trtx dst = SET_DEST (x);\n-\tint use_dst = 0;\n \n-\t/* If storing into MEM, don't show it as being used.  But do\n-\t   show the address as being used.  */\n-\tif (GET_CODE (dst) == MEM)\n-\t  {\n-\t    df_uses_record (df, &XEXP (dst, 0),\n-\t\t\t    DF_REF_REG_MEM_STORE,\n-\t\t\t    bb, insn);\n-\t    df_uses_record (df, &SET_SRC (x), DF_REF_REG_USE, bb, insn);\n-\t    return;\n-\t  }\n+\tdf_uses_record (df, &SET_SRC (x), DF_REF_REG_USE, bb, insn, 0);\n \n-#if 1 && defined(HANDLE_SUBREG)\n-\t/* Look for sets that perform a read-modify-write.  */\n-\twhile (GET_CODE (dst) == STRICT_LOW_PART\n-\t       || GET_CODE (dst) == ZERO_EXTRACT\n-\t       || GET_CODE (dst) == SIGN_EXTRACT)\n+\tswitch (GET_CODE (dst))\n \t  {\n-\t    if (GET_CODE (dst) == STRICT_LOW_PART)\n-\t      {\n-\t\tdst = XEXP (dst, 0);\n-\t\tif (GET_CODE (dst) != SUBREG)\n-\t\t  abort ();\n-\t\t/* A strict_low_part uses the whole reg not only the subreg.  */\n-\t\tdf_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb, insn);\n-\t      }\n-\t    else\n-\t      {\n-\t        df_uses_record (df, &XEXP (dst, 0), DF_REF_REG_USE, bb, insn);\n-\t\tdst = XEXP (dst, 0);\n-\t      }\n-\t  }\n-\tif (GET_CODE (dst) == SUBREG)\n-\t  {\n-\t    /* Paradoxical or too small subreg's are read-mod-write.  */\n-            if (GET_MODE_SIZE (GET_MODE (dst)) < GET_MODE_SIZE (word_mode)\n-                || GET_MODE_SIZE (GET_MODE (dst))\n-\t           >= GET_MODE_SIZE (GET_MODE (SUBREG_REG (dst))))\n-\t      use_dst = 1;\n-\t  }\n-\t/* In the original code also some SUBREG rtx's were considered\n-\t   read-modify-write (those with\n-\t     REG_SIZE(SUBREG_REG(dst)) > REG_SIZE(dst) )\n-\t   e.g. a (subreg:QI (reg:SI A) 0).  I can't see this.  The only\n-\t   reason for a read cycle for reg A would be to somehow preserve\n-\t   the bits outside of the subreg:QI.  But for this a strict_low_part\n-\t   was necessary anyway, and this we handled already.  */\n-#else\n-\twhile (GET_CODE (dst) == STRICT_LOW_PART\n-\t       || GET_CODE (dst) == ZERO_EXTRACT\n-\t       || GET_CODE (dst) == SIGN_EXTRACT\n-\t       || GET_CODE (dst) == SUBREG)\n-\t  {\n-\t    /* A SUBREG of a smaller size does not use the old value.  */\n-\t    if (GET_CODE (dst) != SUBREG\n-\t\t|| (REG_SIZE (SUBREG_REG (dst)) > REG_SIZE (dst)))\n-\t      use_dst = 1;\n-\t    dst = XEXP (dst, 0);\n-\t  }\n-#endif\n-\n-\tif ((GET_CODE (dst) == PARALLEL && GET_MODE (dst) == BLKmode)\n-\t    || GET_CODE (dst) == REG || GET_CODE (dst) == SUBREG)\n-\t  {\n-#if 1 || !defined(HANDLE_SUBREG)\n-            if (use_dst)\n-\t      df_uses_record (df, &SET_DEST (x), DF_REF_REG_USE, bb, insn);\n-#endif\n-\t    df_uses_record (df, &SET_SRC (x), DF_REF_REG_USE, bb, insn);\n-\t    return;\n+\t    case SUBREG:\n+\t      if (read_modify_subreg_p (dst))\n+\t\t{\n+\t\t  df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n+\t\t\t\t  insn, DF_REF_READ_WRITE);\n+\t\t  break;\n+\t\t}\n+\t      /* ... FALLTHRU ... */\n+\t    case REG:\n+\t    case PC:\n+\t      break;\n+\t    case MEM:\n+\t      df_uses_record (df, &XEXP (dst, 0), \n+\t\t\t      DF_REF_REG_MEM_STORE,\n+\t\t\t      bb, insn, 0);\n+\t      break;\n+\t    case STRICT_LOW_PART:\n+\t      /* A strict_low_part uses the whole reg not only the subreg.  */\n+\t      dst = XEXP (dst, 0);\n+\t      if (GET_CODE (dst) != SUBREG)\n+\t\tabort ();\n+\t      df_uses_record (df, &SUBREG_REG (dst), DF_REF_REG_USE, bb,\n+\t\t\t     insn, DF_REF_READ_WRITE);\n+\t      break;\n+\t    case ZERO_EXTRACT:\n+\t    case SIGN_EXTRACT:\n+\t      df_uses_record (df, &XEXP (dst, 0), DF_REF_REG_USE, bb, insn,\n+\t\t\t      DF_REF_READ_WRITE);\n+\t      df_uses_record (df, &XEXP (dst, 1), DF_REF_REG_USE, bb, insn, 0);\n+\t      df_uses_record (df, &XEXP (dst, 2), DF_REF_REG_USE, bb, insn, 0);\n+\t      dst = XEXP (dst, 0);\n+\t      break;\n+\t    default:\n+\t      abort ();\n \t  }\n+\treturn;\n       }\n-      break;\n \n     case RETURN:\n       break;\n@@ -1165,7 +1139,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \n \t    for (j = 0; j < ASM_OPERANDS_INPUT_LENGTH (x); j++)\n \t      df_uses_record (df, &ASM_OPERANDS_INPUT (x, j),\n-\t\t\t      DF_REF_REG_USE, bb, insn);\n+\t\t\t      DF_REF_REG_USE, bb, insn, 0);\n \t    return;\n \t  }\n \tbreak;\n@@ -1178,7 +1152,7 @@ df_uses_record (df, loc, ref_type, bb, insn)\n     case PRE_MODIFY:\n     case POST_MODIFY:\n       /* Catch the def of the register being modified.  */\n-      df_ref_record (df, XEXP (x, 0), &XEXP (x, 0), bb, insn, DF_REF_REG_DEF);\n+      df_ref_record (df, XEXP (x, 0), &XEXP (x, 0), bb, insn, DF_REF_REG_DEF, DF_REF_READ_WRITE);\n \n       /* ... Fall through to handle uses ...  */\n \n@@ -1201,14 +1175,14 @@ df_uses_record (df, loc, ref_type, bb, insn)\n \t\tloc = &XEXP (x, 0);\n \t\tgoto retry;\n \t      }\n-\t    df_uses_record (df, &XEXP (x, i), ref_type, bb, insn);\n+\t    df_uses_record (df, &XEXP (x, i), ref_type, bb, insn, flags);\n \t  }\n \telse if (fmt[i] == 'E')\n \t  {\n \t    int j;\n \t    for (j = 0; j < XVECLEN (x, i); j++)\n \t      df_uses_record (df, &XVECEXP (x, i, j), ref_type,\n-\t\t\t      bb, insn);\n+\t\t\t      bb, insn, flags);\n \t  }\n       }\n   }\n@@ -1240,7 +1214,7 @@ df_insn_refs_record (df, bb, insn)\n \t\tcase REG_EQUIV:\n \t\tcase REG_EQUAL:\n \t\t  df_uses_record (df, &XEXP (note, 0), DF_REF_REG_USE,\n-\t\t\t\t  bb, insn);\n+\t\t\t\t  bb, insn, 0);\n \t\tdefault:\n \t\t  break;\n \t      }\n@@ -1257,12 +1231,12 @@ df_insn_refs_record (df, bb, insn)\n \t    {\n \t      if (GET_CODE (XEXP (note, 0)) == USE)\n \t\tdf_uses_record (df, &SET_DEST (XEXP (note, 0)), DF_REF_REG_USE,\n-\t\t\t\tbb, insn);\n+\t\t\t\tbb, insn, 0);\n \t    }\n \n \t  /* The stack ptr is used (honorarily) by a CALL insn.  */\n \t  x = df_reg_use_gen (STACK_POINTER_REGNUM);\n-\t  df_uses_record (df, &SET_DEST (x), DF_REF_REG_USE, bb, insn);\n+\t  df_uses_record (df, &SET_DEST (x), DF_REF_REG_USE, bb, insn, 0);\n \n \t  if (df->flags & DF_HARD_REGS)\n \t    {\n@@ -1273,14 +1247,14 @@ df_insn_refs_record (df, bb, insn)\n \t\t  {\n \t\t    x = df_reg_use_gen (i);\n \t\t    df_uses_record (df, &SET_DEST (x),\n-\t\t\t\t    DF_REF_REG_USE, bb, insn);\n+ \t\t\t\t    DF_REF_REG_USE, bb, insn, 0);\n \t\t  }\n \t    }\n \t}\n \n       /* Record the register uses.  */\n       df_uses_record (df, &PATTERN (insn),\n-\t\t      DF_REF_REG_USE, bb, insn);\n+\t\t      DF_REF_REG_USE, bb, insn, 0);\n \n \n       if (GET_CODE (insn) == CALL_INSN)\n@@ -3339,6 +3313,8 @@ df_dump (df, flags, file)\n \t\t       DF_INSN_LUID (df, DF_REF_INSN (df->defs[j])),\n \t\t       DF_REF_INSN_UID (df->defs[j]),\n \t\t       DF_REF_REGNO (df->defs[j]));\n+\t      if (df->defs[j]->flags & DF_REF_READ_WRITE)\n+\t\tfprintf (file, \"read/write \");\n \t      df_chain_dump (DF_REF_CHAIN (df->defs[j]), file);\n \t      fprintf (file, \"\\n\");\n \t    }\n@@ -3379,6 +3355,8 @@ df_dump (df, flags, file)\n \t\t       DF_INSN_LUID (df, DF_REF_INSN (df->uses[j])),\n \t\t       DF_REF_INSN_UID (df->uses[j]),\n \t\t       DF_REF_REGNO (df->uses[j]));\n+\t      if (df->uses[j]->flags & DF_REF_READ_WRITE)\n+\t\tfprintf (file, \"read/write \");\n \t      df_chain_dump (DF_REF_CHAIN (df->uses[j]), file);\n \t      fprintf (file, \"\\n\");\n \t    }"}, {"sha": "4d9ea0f30f5e1cea8dee4370e3c6b3b479fce271", "filename": "gcc/df.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fdf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fdf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdf.h?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -48,6 +48,10 @@ struct df_link\n   struct ref *ref;\n };\n \n+enum df_ref_flags\n+  {\n+    DF_REF_READ_WRITE = 1\n+  };\n \n /* Define a register reference structure.  */\n struct ref\n@@ -59,6 +63,7 @@ struct ref\n   struct df_link *chain;\t/* Head of def-use or use-def chain.  */\n   enum df_ref_type type;\t/* Type of ref.  */\n   int id;\t\t\t/* Ref index.  */\n+  enum df_ref_flags flags;\t/* Various flags.  */\n };\n \n \n@@ -177,6 +182,7 @@ struct df_map\n #define DF_REF_TYPE(REF) ((REF)->type)\n #define DF_REF_CHAIN(REF) ((REF)->chain)\n #define DF_REF_ID(REF) ((REF)->id)\n+#define DF_REF_FLAGS(REF) ((REF)->flags)\n \n /* Macros to determine the reference type.  */\n "}, {"sha": "a69ed83457104446f94783d96721a1cb0a47915c", "filename": "gcc/gcse.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fgcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fgcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcse.c?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -3929,7 +3929,7 @@ try_replace_reg (from, to, insn)\n   /* If we've failed to do replacement, have a single SET, and don't already\n      have a note, add a REG_EQUAL note to not lose information.  */\n   if (!success && note == 0 && set != 0)\n-    note = set_unique_reg_note (insn, REG_EQUAL, src);\n+    note = set_unique_reg_note (insn, REG_EQUAL, copy_rtx (src));\n \n   /* If there is already a NOTE, update the expression in it with our\n      replacement.  */"}, {"sha": "dacefbe4ab9cbeb854db16ee6c6bd746a0327cde", "filename": "gcc/predict.c", "status": "modified", "additions": 7, "deletions": 4, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fpredict.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcd72187907e12fa670d7c4794641691b30e825/gcc%2Fpredict.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpredict.c?ref=7fcd72187907e12fa670d7c4794641691b30e825", "patch": "@@ -602,7 +602,7 @@ expected_value_to_br_prob ()\n typedef struct block_info_def\n {\n   /* Estimated frequency of execution of basic_block.  */\n-  double frequency;\n+  volatile double frequency;\n \n   /* To keep queue of basic blocks to process.  */\n   basic_block next;\n@@ -619,8 +619,11 @@ typedef struct edge_info_def\n {\n   /* In case edge is an loopback edge, the probability edge will be reached\n      in case header is.  Estimated number of iterations of the loop can be\n-     then computed as 1 / (1 - back_edge_prob).  */\n-  double back_edge_prob;\n+     then computed as 1 / (1 - back_edge_prob).\n+\n+     Volatile is needed to avoid differences in the optimized and unoptimized\n+     builds on machines where FP registers are wider than double.  */\n+  volatile double back_edge_prob;\n   /* True if the edge is an loopback edge in the natural loop.  */\n   int back_edge:1;\n } *edge_info;\n@@ -663,7 +666,7 @@ propagate_freq (head)\n   BLOCK_INFO (head)->frequency = 1;\n   for (; bb; bb = nextbb)\n     {\n-      double cyclic_probability = 0, frequency = 0;\n+      volatile double cyclic_probability = 0, frequency = 0;\n \n       nextbb = BLOCK_INFO (bb)->next;\n       BLOCK_INFO (bb)->next = NULL;"}]}