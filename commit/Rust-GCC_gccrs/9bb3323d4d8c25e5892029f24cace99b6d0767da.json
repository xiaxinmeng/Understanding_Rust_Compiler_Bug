{"sha": "9bb3323d4d8c25e5892029f24cace99b6d0767da", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWJiMzMyM2Q0ZDhjMjVlNTg5MjAyOWYyNGNhY2U5OWI2ZDA3NjdkYQ==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@libertysurf.fr", "date": "2005-05-03T14:55:04Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2005-05-03T14:55:04Z"}, "message": "predicates.md (const_compl_high_operand): New.\n\n\t* config/sparc/predicates.md (const_compl_high_operand): New.\n\t* config/sparc/sparc.c (sparc_emit_set_safe_HIGH64): Rename into\n\tgen_safe_HIGH64.\n\t(sparc_emit_set_const64_quick1): Adjust for above change.\n\t(sparc_emit_set_const64_quick2): Likewise.\n\t(sparc_emit_set_const64_longway): Likewise.\n\t(sparc_emit_set_const64): Likewise.\n\t* config/sparc/sparc.md (movhi_const64_special, movsi_const64_special,\n\tmovdi_const64_special): Delete.\n\t(logical constant splitters): Use const_compl_high_operand.\n\nFrom-SVN: r99160", "tree": {"sha": "550385e4560f46b68ae9e4f1780c9bc8c9d3feff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/550385e4560f46b68ae9e4f1780c9bc8c9d3feff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9bb3323d4d8c25e5892029f24cace99b6d0767da", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb3323d4d8c25e5892029f24cace99b6d0767da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9bb3323d4d8c25e5892029f24cace99b6d0767da", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9bb3323d4d8c25e5892029f24cace99b6d0767da/comments", "author": {"login": "ebotcazou", "id": 48091907, "node_id": "MDQ6VXNlcjQ4MDkxOTA3", "avatar_url": "https://avatars.githubusercontent.com/u/48091907?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ebotcazou", "html_url": "https://github.com/ebotcazou", "followers_url": "https://api.github.com/users/ebotcazou/followers", "following_url": "https://api.github.com/users/ebotcazou/following{/other_user}", "gists_url": "https://api.github.com/users/ebotcazou/gists{/gist_id}", "starred_url": "https://api.github.com/users/ebotcazou/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ebotcazou/subscriptions", "organizations_url": "https://api.github.com/users/ebotcazou/orgs", "repos_url": "https://api.github.com/users/ebotcazou/repos", "events_url": "https://api.github.com/users/ebotcazou/events{/privacy}", "received_events_url": "https://api.github.com/users/ebotcazou/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ff7c859760d5caf49e39b8f848925fd0e997d9f3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ff7c859760d5caf49e39b8f848925fd0e997d9f3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ff7c859760d5caf49e39b8f848925fd0e997d9f3"}], "stats": {"total": 77, "additions": 37, "deletions": 40}, "files": [{"sha": "eaceebc0a019164037db0785ee1db37611937190", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=9bb3323d4d8c25e5892029f24cace99b6d0767da", "patch": "@@ -1,3 +1,16 @@\n+2005-05-03  Eric Botcazou  <ebotcazou@libertysurf.fr>\n+\n+\t* config/sparc/predicates.md (const_compl_high_operand): New.\n+\t* config/sparc/sparc.c (sparc_emit_set_safe_HIGH64): Rename into\n+\tgen_safe_HIGH64.\n+\t(sparc_emit_set_const64_quick1): Adjust for above change.\n+\t(sparc_emit_set_const64_quick2): Likewise.\n+\t(sparc_emit_set_const64_longway): Likewise.\n+\t(sparc_emit_set_const64): Likewise.\n+\t* config/sparc/sparc.md (movhi_const64_special, movsi_const64_special,\n+\tmovdi_const64_special): Delete.\n+\t(logical constant splitters): Use const_compl_high_operand.\n+\n 2005-05-03  Richard Guenther  <rguenth@gcc.gnu.org>\n \n \t* tree-ssa-ccp.c (maybe_fold_stmt_indirect): Use STRIP_TYPE_NOPS"}, {"sha": "58f0bb7414bfb52f8b45f70a57e03267aacc6f04", "filename": "gcc/config/sparc/predicates.md", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fpredicates.md?ref=9bb3323d4d8c25e5892029f24cace99b6d0767da", "patch": "@@ -68,6 +68,12 @@\n        (and (match_test \"INTVAL (op) & ~(HOST_WIDE_INT)0x3ff\")\n             (match_test \"SPARC_SETHI_P (INTVAL (op) & GET_MODE_MASK (mode))\"))))\n \n+;; Return true if OP is a constant whose 1's complement can be loaded by the\n+;; sethi instruction.\n+(define_predicate \"const_compl_high_operand\"\n+  (and (match_code \"const_int\")\n+       (and (not (match_operand 0 \"small_int_operand\"))\n+            (match_test \"SPARC_SETHI_P (~INTVAL (op) & GET_MODE_MASK (mode))\"))))\n \n ;; Predicates for symbolic constants.\n "}, {"sha": "94ef74d16a9e4164bab14c6966390990aa3fb185", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=9bb3323d4d8c25e5892029f24cace99b6d0767da", "patch": "@@ -1145,7 +1145,7 @@ sparc_emit_set_const64 (rtx op0 ATTRIBUTE_UNUSED, rtx op1 ATTRIBUTE_UNUSED)\n /* These avoid problems when cross compiling.  If we do not\n    go through all this hair then the optimizer will see\n    invalid REG_EQUAL notes or in some cases none at all.  */\n-static void sparc_emit_set_safe_HIGH64 (rtx, HOST_WIDE_INT);\n+static rtx gen_safe_HIGH64 (rtx, HOST_WIDE_INT);\n static rtx gen_safe_SET64 (rtx, HOST_WIDE_INT);\n static rtx gen_safe_OR64 (rtx, HOST_WIDE_INT);\n static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n@@ -1155,10 +1155,10 @@ static rtx gen_safe_XOR64 (rtx, HOST_WIDE_INT);\n    Unfortunately this leads to many missed optimizations\n    during CSE.  We mask out the non-HIGH bits, and matches\n    a plain movdi, to alleviate this problem.  */\n-static void\n-sparc_emit_set_safe_HIGH64 (rtx dest, HOST_WIDE_INT val)\n+static rtx\n+gen_safe_HIGH64 (rtx dest, HOST_WIDE_INT val)\n {\n-  emit_insn (gen_rtx_SET (VOIDmode, dest, GEN_INT (val & ~(HOST_WIDE_INT)0x3ff)));\n+  return gen_rtx_SET (VOIDmode, dest, GEN_INT (val & ~(HOST_WIDE_INT)0x3ff));\n }\n \n static rtx\n@@ -1201,7 +1201,7 @@ sparc_emit_set_const64_quick1 (rtx op0, rtx temp,\n   else\n     high_bits = low_bits;\n \n-  sparc_emit_set_safe_HIGH64 (temp, high_bits);\n+  emit_insn (gen_safe_HIGH64 (temp, high_bits));\n   if (!is_neg)\n     {\n       emit_insn (gen_rtx_SET (VOIDmode, op0,\n@@ -1240,7 +1240,7 @@ sparc_emit_set_const64_quick2 (rtx op0, rtx temp,\n \n   if ((high_bits & 0xfffffc00) != 0)\n     {\n-      sparc_emit_set_safe_HIGH64 (temp, high_bits);\n+      emit_insn (gen_safe_HIGH64 (temp, high_bits));\n       if ((high_bits & ~0xfffffc00) != 0)\n \temit_insn (gen_rtx_SET (VOIDmode, op0,\n \t\t\t\tgen_safe_OR64 (temp, (high_bits & 0x3ff))));\n@@ -1284,7 +1284,7 @@ sparc_emit_set_const64_longway (rtx op0, rtx temp,\n \n   if ((high_bits & 0xfffffc00) != 0)\n     {\n-      sparc_emit_set_safe_HIGH64 (temp, high_bits);\n+      emit_insn (gen_safe_HIGH64 (temp, high_bits));\n       if ((high_bits & ~0xfffffc00) != 0)\n \temit_insn (gen_rtx_SET (VOIDmode,\n \t\t\t\tsub_temp,\n@@ -1308,7 +1308,7 @@ sparc_emit_set_const64_longway (rtx op0, rtx temp,\n \t\t\t      gen_rtx_ASHIFT (DImode, sub_temp,\n \t\t\t\t\t      GEN_INT (32))));\n \n-      sparc_emit_set_safe_HIGH64 (temp2, low_bits);\n+      emit_insn (gen_safe_HIGH64 (temp2, low_bits));\n       if ((low_bits & ~0xfffffc00) != 0)\n \t{\n \t  emit_insn (gen_rtx_SET (VOIDmode, temp3,\n@@ -1597,7 +1597,7 @@ sparc_emit_set_const64 (rtx op0, rtx op1)\n       gcc_assert (SPARC_SETHI_P (focus_bits));\n       gcc_assert (lowest_bit_set != 10);\n \n-      sparc_emit_set_safe_HIGH64 (temp, focus_bits);\n+      emit_insn (gen_safe_HIGH64 (temp, focus_bits));\n \n       /* If lowest_bit_set == 10 then a sethi alone could have done it.  */\n       if (lowest_bit_set < 10)"}, {"sha": "2078c3aebde931a8c1739a956c4b1bc71c58f8f4", "filename": "gcc/config/sparc/sparc.md", "status": "modified", "additions": 9, "deletions": 31, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fsparc.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9bb3323d4d8c25e5892029f24cace99b6d0767da/gcc%2Fconfig%2Fsparc%2Fsparc.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.md?ref=9bb3323d4d8c25e5892029f24cace99b6d0767da", "patch": "@@ -1841,12 +1841,6 @@\n   ;\n })\n \n-(define_insn \"*movhi_const64_special\"\n-  [(set (match_operand:HI 0 \"register_operand\" \"=r\")\n-\t(match_operand:HI 1 \"const_high_operand\" \"K\"))]\n-  \"TARGET_ARCH64\"\n-  \"sethi\\t%%hi(%a1), %0\")\n-\n (define_insn \"*movhi_insn\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,r,m\")\n \t(match_operand:HI 1 \"input_operand\"   \"rI,K,m,rJ\"))]\n@@ -1943,14 +1937,6 @@\n   ;\n })\n \n-;; This is needed to show CSE exactly which bits are set\n-;; in a 64-bit register by sethi instructions.\n-(define_insn \"*movsi_const64_special\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=r\")\n-\t(match_operand:SI 1 \"const_high_operand\" \"K\"))]\n-  \"TARGET_ARCH64\"\n-  \"sethi\\t%%hi(%a1), %0\")\n-\n (define_insn \"*movsi_insn\"\n   [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=r,f,r,r,r,f,m,m,d\")\n \t(match_operand:SI 1 \"input_operand\"   \"rI,!f,K,J,m,!m,rJ,!f,J\"))]\n@@ -2187,14 +2173,6 @@\n   [(set_attr \"type\" \"store,store,load,*,*,*,*,fpstore,fpload,*,*,*\")\n    (set_attr \"length\" \"2,*,*,2,2,2,2,*,*,2,2,2\")])\n \n-;; This is needed to show CSE exactly which bits are set\n-;; in a 64-bit register by sethi instructions.\n-(define_insn \"*movdi_const64_special\"\n-  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n-\t(match_operand:DI 1 \"const_high_operand\" \"N\"))]\n-  \"TARGET_ARCH64\"\n-  \"sethi\\t%%hi(%a1), %0\")\n-\n (define_insn \"*movdi_insn_sp64_novis\"\n   [(set (match_operand:DI 0 \"nonimmediate_operand\" \"=r,r,r,r,m,?e,?e,?W\")\n         (match_operand:DI 1 \"input_operand\"   \"rI,N,J,m,rJ,e,W,e\"))]\n@@ -5845,7 +5823,7 @@\n   \"umacd\\t%1, %2, %L0\"\n   [(set_attr \"type\" \"imul\")])\n \f\n-;;- Boolean instructions\n+;; Boolean instructions\n ;; We define DImode `and' so with DImode `not' we can get\n ;; DImode `andn'.  Other combinations are possible.\n \n@@ -5896,9 +5874,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(and:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t\t(match_operand:SI 2 \"const_compl_high_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (and:SI (not:SI (match_dup 3)) (match_dup 1)))]\n {\n@@ -5997,9 +5975,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(ior:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t\t(match_operand:SI 2 \"const_compl_high_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (ior:SI (not:SI (match_dup 3)) (match_dup 1)))]\n {\n@@ -6098,9 +6076,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t(match_operand:SI 2 \"const_int_operand\" \"\")))\n+\t\t(match_operand:SI 2 \"const_compl_high_operand\" \"\")))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-   \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+   \"\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (not:SI (xor:SI (match_dup 3) (match_dup 1))))]\n {\n@@ -6110,9 +6088,9 @@\n (define_split\n   [(set (match_operand:SI 0 \"register_operand\" \"\")\n \t(not:SI (xor:SI (match_operand:SI 1 \"register_operand\" \"\")\n-\t\t\t(match_operand:SI 2 \"const_int_operand\" \"\"))))\n+\t\t\t(match_operand:SI 2 \"const_compl_high_operand\" \"\"))))\n    (clobber (match_operand:SI 3 \"register_operand\" \"\"))]\n-  \"!SMALL_INT (operands[2]) && (INTVAL (operands[2]) & 0x3ff) == 0x3ff\"\n+  \"\"\n   [(set (match_dup 3) (match_dup 4))\n    (set (match_dup 0) (xor:SI (match_dup 3) (match_dup 1)))]\n {"}]}