{"sha": "4005971c079cc76629a3646e817e7fac34968df1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDAwNTk3MWMwNzljYzc2NjI5YTM2NDZlODE3ZTdmYWMzNDk2OGRmMQ==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2002-06-19T22:37:30Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2002-06-19T22:37:30Z"}, "message": "genautomata.c (DECL_UNIT, [...]): New macros with checking and without it.\n\n2002-06-19  Vladimir Makarov  <vmakarov@redhat.com>\n\n\t* genautomata.c (DECL_UNIT, DECL_BYPASS, DECL_AUTOMATON,\n\tDECL_EXCL, DECL_PRESENCE, DECL_ABSENCE, DECL_RESERV,\n\tDECL_INSN_RESERV, REGEXP_UNIT, REGEXP_RESERV, REGEXP_SEQUENCE,\n\tREGEXP_REPEAT, REGEXP_ALLOF, REGEXP_ONEOF): New macros with\n\tchecking and without it.\n\t(decl_name, decl_mode_check_failed, regexp_name,\n\tregexp_mode_check_failed): New functions.\n\t(gen_cpu_unit, gen_query_cpu_unit, gen_bypass, gen_excl_set,\n\tgen_presence_set, gen_absence_set, gen_automaton,\n\tgen_regexp_repeat, gen_regexp_allof, gen_regexp_oneof,\n\tgen_regexp_sequence, gen_reserv, gen_insn_reserv,\n\tautomaton_decl_hash, automaton_decl_eq_p): Use the macros.\n\t(find_automaton_decl): Ditto.  Set up mode of work_automaton_decl.\n\t(insn_decl_hash, insn_decl_hash, insn_decl_eq_p): Use the macros.\n\t(find_insn_decl): Ditto.  Set up mode of work_insn_decl.\n\t(decl_hash, decl_eq_p): Use the macros.\n\t(find_decl): Ditto.  Set up mode of work_decl.\n\t(process_excls, process_presence_absence, process_decls,\n\tcheck_automaton_usage, process_regexp, process_regexp_decls,\n\tcheck_usage, loop_in_regexp, check_loops_in_regexps,\n\tprocess_regexp_cycles, add_advance_cycle_insn_decl,\n\tinitiate_states, initiate_excl_sets,\n\tinitiate_presence_absence_sets, copy_insn_regexp, transform_1,\n\ttransform_2): Use the macros.\n\t(transform_3): Ditto.  Check mode before making transformations of\n\tALLOF.\n\t(regexp_transform_func, transform_insn_regexps,\n\tprocess_unit_to_form_the_same_automaton_unit_lists,\n\tform_the_same_automaton_unit_lists_from_regexp,\n\tform_the_same_automaton_unit_lists,\n\tprocess_seq_for_forming_states, process_alts_for_forming_states,\n\tcreate_alt_states, form_ainsn_with_same_reservs, make_automaton,\n\tform_arcs_marked_by_insn, NDFA_to_DFA, set_new_cycle_flags,\n\testimate_one_automaton_bound, compare_max_occ_cycle_nums,\n\tunits_to_automata_heuristic_distr, create_ainsns,\n\tunits_to_automata_distr, create_automata): Use the macros.\n\t(form_regexp): Ditto.  Fix typo in access to fields of ALLOF.\n\t(longest_path_length, min_issue_delay_pass_states,\n\toutput_dead_lock_vect, output_tables, output_insn_code_cases,\n\toutput_internal_insn_latency_func, output_print_reservation_func,\n\toutput_description, output_automaton_units, generate): Use the\n\tmacros.\n\t(make_insn_alts_attr): Ditto.  Check case when there are not\n\talternatives in the reservation.\n\t(make_internal_dfa_insn_code_attr, make_default_insn_latency_attr,\n\tmake_bypass_attr, form_important_insn_automata_lists,\n\texpand_automata): Use the macros.\n\nFrom-SVN: r54802", "tree": {"sha": "833421971b9cf51a175f55aeed20e72eb3ed296b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/833421971b9cf51a175f55aeed20e72eb3ed296b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4005971c079cc76629a3646e817e7fac34968df1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4005971c079cc76629a3646e817e7fac34968df1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4005971c079cc76629a3646e817e7fac34968df1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4005971c079cc76629a3646e817e7fac34968df1/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "11d8b4080698dc5ac86e78f077af48eab87c8c12", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/11d8b4080698dc5ac86e78f077af48eab87c8c12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/11d8b4080698dc5ac86e78f077af48eab87c8c12"}], "stats": {"total": 1319, "additions": 810, "deletions": 509}, "files": [{"sha": "9de02b90124b13c3e62d6cf5a2d84f5d78f7f5f2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4005971c079cc76629a3646e817e7fac34968df1/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4005971c079cc76629a3646e817e7fac34968df1/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4005971c079cc76629a3646e817e7fac34968df1", "patch": "@@ -1,3 +1,53 @@\n+2002-06-19  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+\t* genautomata.c (DECL_UNIT, DECL_BYPASS, DECL_AUTOMATON,\n+\tDECL_EXCL, DECL_PRESENCE, DECL_ABSENCE, DECL_RESERV,\n+\tDECL_INSN_RESERV, REGEXP_UNIT, REGEXP_RESERV, REGEXP_SEQUENCE,\n+\tREGEXP_REPEAT, REGEXP_ALLOF, REGEXP_ONEOF): New macros with\n+\tchecking and without it.\n+\t(decl_name, decl_mode_check_failed, regexp_name,\n+\tregexp_mode_check_failed): New functions.\n+\t(gen_cpu_unit, gen_query_cpu_unit, gen_bypass, gen_excl_set,\n+\tgen_presence_set, gen_absence_set, gen_automaton,\n+\tgen_regexp_repeat, gen_regexp_allof, gen_regexp_oneof,\n+\tgen_regexp_sequence, gen_reserv, gen_insn_reserv,\n+\tautomaton_decl_hash, automaton_decl_eq_p): Use the macros.\n+\t(find_automaton_decl): Ditto.  Set up mode of work_automaton_decl.\n+\t(insn_decl_hash, insn_decl_hash, insn_decl_eq_p): Use the macros.\n+\t(find_insn_decl): Ditto.  Set up mode of work_insn_decl.\n+\t(decl_hash, decl_eq_p): Use the macros.\n+\t(find_decl): Ditto.  Set up mode of work_decl.\n+\t(process_excls, process_presence_absence, process_decls,\n+\tcheck_automaton_usage, process_regexp, process_regexp_decls,\n+\tcheck_usage, loop_in_regexp, check_loops_in_regexps,\n+\tprocess_regexp_cycles, add_advance_cycle_insn_decl,\n+\tinitiate_states, initiate_excl_sets,\n+\tinitiate_presence_absence_sets, copy_insn_regexp, transform_1,\n+\ttransform_2): Use the macros.\n+\t(transform_3): Ditto.  Check mode before making transformations of\n+\tALLOF.\n+\t(regexp_transform_func, transform_insn_regexps,\n+\tprocess_unit_to_form_the_same_automaton_unit_lists,\n+\tform_the_same_automaton_unit_lists_from_regexp,\n+\tform_the_same_automaton_unit_lists,\n+\tprocess_seq_for_forming_states, process_alts_for_forming_states,\n+\tcreate_alt_states, form_ainsn_with_same_reservs, make_automaton,\n+\tform_arcs_marked_by_insn, NDFA_to_DFA, set_new_cycle_flags,\n+\testimate_one_automaton_bound, compare_max_occ_cycle_nums,\n+\tunits_to_automata_heuristic_distr, create_ainsns,\n+\tunits_to_automata_distr, create_automata): Use the macros.\n+\t(form_regexp): Ditto.  Fix typo in access to fields of ALLOF.\n+\t(longest_path_length, min_issue_delay_pass_states,\n+\toutput_dead_lock_vect, output_tables, output_insn_code_cases,\n+\toutput_internal_insn_latency_func, output_print_reservation_func,\n+\toutput_description, output_automaton_units, generate): Use the\n+\tmacros.\n+\t(make_insn_alts_attr): Ditto.  Check case when there are not\n+\talternatives in the reservation.\n+\t(make_internal_dfa_insn_code_attr, make_default_insn_latency_attr,\n+\tmake_bypass_attr, form_important_insn_automata_lists,\n+\texpand_automata): Use the macros.\n+\t\n 2002-06-20  Tim Josling  <tej@melbpc.org.au>\n \n \t* Makefile.in: Clean up code to check for misspecified languages"}, {"sha": "6eec55f4f9dec1542bc243bbcf4081fb4055b27a", "filename": "gcc/genautomata.c", "status": "modified", "additions": 760, "deletions": 509, "changes": 1269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4005971c079cc76629a3646e817e7fac34968df1/gcc%2Fgenautomata.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4005971c079cc76629a3646e817e7fac34968df1/gcc%2Fgenautomata.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenautomata.c?ref=4005971c079cc76629a3646e817e7fac34968df1", "patch": "@@ -1238,6 +1238,228 @@ struct state_ainsn_table\n   int min_base_vect_el_value, max_base_vect_el_value;\n };\n \n+/* Macros to access members of unions.  Use only them for access to\n+   union members of declarations and regexps.  */\n+\n+#if defined ENABLE_CHECKING && (GCC_VERSION >= 2007)\n+\n+#define DECL_UNIT(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_unit)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_unit\",\t\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.unit; }))\n+\n+#define DECL_BYPASS(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_bypass)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_bypass\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.bypass; }))\n+\n+#define DECL_AUTOMATON(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_automaton)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_automaton\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.automaton; }))\n+\n+#define DECL_EXCL(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_excl)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_excl\",\t\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.excl; }))\n+\n+#define DECL_PRESENCE(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_presence)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_presence\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.presence; }))\n+\n+#define DECL_ABSENCE(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_absence)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_absence\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.absence; }))\n+\n+#define DECL_RESERV(d) __extension__\t\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_reserv)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_reserv\",\t\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.reserv; }))\n+\n+#define DECL_INSN_RESERV(d) __extension__\t\t\t\t\\\n+(({ struct decl *_decl = (d);\t\t\t\t\t\t\\\n+     if (_decl->mode != dm_insn_reserv)\t\t\t\t\t\\\n+       decl_mode_check_failed (_decl->mode, \"dm_insn_reserv\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_decl)->decl.insn_reserv; }))\n+\n+static const char *decl_name PARAMS ((enum decl_mode));\n+static void decl_mode_check_failed PARAMS ((enum decl_mode, const char *,\n+\t\t\t\t\t    const char *, int, const char *));\n+\n+/* Return string representation of declaration mode MODE.  */\n+static const char *\n+decl_name (mode)\n+     enum decl_mode mode;\n+{\n+  static char str [100];\n+\n+  if (mode == dm_unit)\n+    return \"dm_unit\";\n+  else if (mode == dm_bypass)\n+    return \"dm_bypass\";\n+  else if (mode == dm_automaton)\n+    return \"dm_automaton\";\n+  else if (mode == dm_excl)\n+    return \"dm_excl\";\n+  else if (mode == dm_presence)\n+    return \"dm_presence\";\n+  else if (mode == dm_absence)\n+    return \"dm_absence\";\n+  else if (mode == dm_reserv)\n+    return \"dm_reserv\";\n+  else if (mode == dm_insn_reserv)\n+    return \"dm_insn_reserv\";\n+  else\n+    sprintf (str, \"unknown (%d)\", (int) mode);\n+  return str;\n+}\n+\n+/* The function prints message about unexpected declaration and finish\n+   the program.  */\n+static void\n+decl_mode_check_failed (mode, expected_mode_str, file, line, func)\n+     enum decl_mode mode;\n+     const char *expected_mode_str;\n+     const char *file;\n+     int line;\n+     const char *func;\n+{\n+  fprintf\n+    (stderr,\n+     \"\\n%s: %d: error in %s: DECL check: expected decl %s, have %s\\n\",\n+     file, line, func, expected_mode_str, decl_name (mode));\n+  exit (1);\n+}\n+\n+\n+#define REGEXP_UNIT(r) __extension__\t\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_unit)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_unit\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.unit; }))\n+\n+#define REGEXP_RESERV(r) __extension__\t\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_reserv)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_reserv\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.reserv; }))\n+\n+#define REGEXP_SEQUENCE(r) __extension__\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_sequence)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_sequence\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.sequence; }))\n+\n+#define REGEXP_REPEAT(r) __extension__\t\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_repeat)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_repeat\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.repeat; }))\n+\n+#define REGEXP_ALLOF(r) __extension__\t\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_allof)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_allof\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.allof; }))\n+\n+#define REGEXP_ONEOF(r) __extension__\t\t\t\t\t\\\n+(({ struct regexp *_regexp = (r);\t\t\t\t\t\\\n+     if (_regexp->mode != rm_oneof)\t\t\t\t\t\\\n+       regexp_mode_check_failed (_regexp->mode, \"rm_oneof\",\t\t\\\n+\t\t\t       __FILE__, __LINE__, __FUNCTION__);\t\\\n+     &(_regexp)->regexp.oneof; }))\n+\n+static const char *regexp_name PARAMS ((enum regexp_mode));\n+static void regexp_mode_check_failed PARAMS ((enum regexp_mode, const char *,\n+\t\t\t\t\t      const char *, int,\n+\t\t\t\t\t      const char *));\n+\n+\n+/* Return string representation of regexp mode MODE.  */\n+static const char *\n+regexp_name (mode)\n+     enum regexp_mode mode;\n+{\n+  static char str [100];\n+\n+  if (mode == rm_unit)\n+    return \"rm_unit\";\n+  else if (mode == rm_reserv)\n+    return \"rm_reserv\";\n+  else if (mode == rm_nothing)\n+    return \"rm_nothing\";\n+  else if (mode == rm_sequence)\n+    return \"rm_sequence\";\n+  else if (mode == rm_repeat)\n+    return \"rm_repeat\";\n+  else if (mode == rm_allof)\n+    return \"rm_allof\";\n+  else if (mode == rm_oneof)\n+    return \"rm_oneof\";\n+  else\n+    sprintf (str, \"unknown (%d)\", (int) mode);\n+  return str;\n+}\n+\n+/* The function prints message about unexpected regexp and finish the\n+   program.  */\n+static void\n+regexp_mode_check_failed (mode, expected_mode_str, file, line, func)\n+     enum regexp_mode mode;\n+     const char *expected_mode_str;\n+     const char *file;\n+     int line;\n+     const char *func;\n+{\n+  fprintf\n+    (stderr,\n+     \"\\n%s: %d: error in %s: REGEXP check: expected decl %s, have %s\\n\",\n+     file, line, func, expected_mode_str, regexp_name (mode));\n+  exit (1);\n+}\n+\n+#else /* #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007) */\n+\n+#define DECL_UNIT(d) (&(d)->decl.unit)\n+#define DECL_BYPASS(d) (&(d)->decl.bypass)\n+#define DECL_AUTOMATON(d) (&(d)->decl.automaton)\n+#define DECL_EXCL(d) (&(d)->decl.excl)\n+#define DECL_PRESENCE(d) (&(d)->decl.presence)\n+#define DECL_ABSENCE(d) (&(d)->decl.absence)\n+#define DECL_RESERV(d) (&(d)->decl.reserv)\n+#define DECL_INSN_RESERV(d) (&(d)->decl.insn_reserv)\n+\n+#define REGEXP_UNIT(r) (&(r)->regexp.unit)\n+#define REGEXP_RESERV(r) (&(r)->regexp.reserv)\n+#define REGEXP_SEQUENCE(r) (&(r)->regexp.sequence)\n+#define REGEXP_REPEAT(r) (&(r)->regexp.repeat)\n+#define REGEXP_ALLOF(r) (&(r)->regexp.allof)\n+#define REGEXP_ONEOF(r) (&(r)->regexp.oneof)\n+\n+#endif /* #if defined ENABLE_RTL_CHECKING && (GCC_VERSION >= 2007) */\n+\n /* Create IR structure (node).  */\n static void *\n create_node (size)\n@@ -1412,9 +1634,9 @@ gen_cpu_unit (def)\n       decl = create_node (sizeof (struct decl));\n       decl->mode = dm_unit;\n       decl->pos = 0;\n-      decl->decl.unit.name = check_name (str_cpu_units [i], decl->pos);\n-      decl->decl.unit.automaton_name = (char *) XSTR (def, 1);\n-      decl->decl.unit.query_p = 0;\n+      DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n+      DECL_UNIT (decl)->automaton_name = (char *) XSTR (def, 1);\n+      DECL_UNIT (decl)->query_p = 0;\n       VLA_PTR_ADD (decls, decl);\n       num_dfa_decls++;\n     }\n@@ -1441,9 +1663,9 @@ gen_query_cpu_unit (def)\n       decl = create_node (sizeof (struct decl));\n       decl->mode = dm_unit;\n       decl->pos = 0;\n-      decl->decl.unit.name = check_name (str_cpu_units [i], decl->pos);\n-      decl->decl.unit.automaton_name = (char *) XSTR (def, 1);\n-      decl->decl.unit.query_p = 1;\n+      DECL_UNIT (decl)->name = check_name (str_cpu_units [i], decl->pos);\n+      DECL_UNIT (decl)->automaton_name = (char *) XSTR (def, 1);\n+      DECL_UNIT (decl)->query_p = 1;\n       VLA_PTR_ADD (decls, decl);\n       num_dfa_decls++;\n     }\n@@ -1477,10 +1699,10 @@ gen_bypass (def)\n \tdecl = create_node (sizeof (struct decl));\n \tdecl->mode = dm_bypass;\n \tdecl->pos = 0;\n-\tdecl->decl.bypass.latency = XINT (def, 0);\n-\tdecl->decl.bypass.out_insn_name = out_insns [i];\n-\tdecl->decl.bypass.in_insn_name = in_insns [j];\n-\tdecl->decl.bypass.bypass_guard_name = (char *) XSTR (def, 3);\n+\tDECL_BYPASS (decl)->latency = XINT (def, 0);\n+\tDECL_BYPASS (decl)->out_insn_name = out_insns [i];\n+\tDECL_BYPASS (decl)->in_insn_name = in_insns [j];\n+\tDECL_BYPASS (decl)->bypass_guard_name = (char *) XSTR (def, 3);\n \tVLA_PTR_ADD (decls, decl);\n \tnum_dfa_decls++;\n       }\n@@ -1514,13 +1736,14 @@ gen_excl_set (def)\n   decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n   decl->mode = dm_excl;\n   decl->pos = 0;\n-  decl->decl.excl.names_num = length;\n-  decl->decl.excl.first_list_length = first_vect_length;\n+  DECL_EXCL (decl)->names_num = length;\n+  DECL_EXCL (decl)->first_list_length = first_vect_length;\n   for (i = 0; i < length; i++)\n     if (i < first_vect_length)\n-      decl->decl.excl.names [i] = first_str_cpu_units [i];\n+      DECL_EXCL (decl)->names [i] = first_str_cpu_units [i];\n     else\n-      decl->decl.excl.names [i] = second_str_cpu_units [i - first_vect_length];\n+      DECL_EXCL (decl)->names [i]\n+\t= second_str_cpu_units [i - first_vect_length];\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n }\n@@ -1553,13 +1776,13 @@ gen_presence_set (def)\n   decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n   decl->mode = dm_presence;\n   decl->pos = 0;\n-  decl->decl.presence.names_num = length;\n-  decl->decl.presence.first_list_length = first_vect_length;\n+  DECL_PRESENCE (decl)->names_num = length;\n+  DECL_PRESENCE (decl)->first_list_length = first_vect_length;\n   for (i = 0; i < length; i++)\n     if (i < first_vect_length)\n-      decl->decl.presence.names [i] = first_str_cpu_units [i];\n+      DECL_PRESENCE (decl)->names [i] = first_str_cpu_units [i];\n     else\n-      decl->decl.presence.names [i]\n+      DECL_PRESENCE (decl)->names [i]\n \t= second_str_cpu_units [i - first_vect_length];\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n@@ -1593,13 +1816,13 @@ gen_absence_set (def)\n   decl = create_node (sizeof (struct decl) + (length - 1) * sizeof (char *));\n   decl->mode = dm_absence;\n   decl->pos = 0;\n-  decl->decl.absence.names_num = length;\n-  decl->decl.absence.first_list_length = first_vect_length;\n+  DECL_ABSENCE (decl)->names_num = length;\n+  DECL_ABSENCE (decl)->first_list_length = first_vect_length;\n   for (i = 0; i < length; i++)\n     if (i < first_vect_length)\n-      decl->decl.absence.names [i] = first_str_cpu_units [i];\n+      DECL_ABSENCE (decl)->names [i] = first_str_cpu_units [i];\n     else\n-      decl->decl.absence.names [i]\n+      DECL_ABSENCE (decl)->names [i]\n \t= second_str_cpu_units [i - first_vect_length];\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n@@ -1627,7 +1850,7 @@ gen_automaton (def)\n       decl = create_node (sizeof (struct decl));\n       decl->mode = dm_automaton;\n       decl->pos = 0;\n-      decl->decl.automaton.name = check_name (str_automata [i], decl->pos);\n+      DECL_AUTOMATON (decl)->name = check_name (str_automata [i], decl->pos);\n       VLA_PTR_ADD (decls, decl);\n       num_dfa_decls++;\n     }\n@@ -1687,7 +1910,7 @@ gen_regexp_el (str)\n     {\n       regexp = create_node (sizeof (struct decl));\n       regexp->mode = rm_unit;\n-      regexp->regexp.unit.name = str;\n+      REGEXP_UNIT (regexp)->name = str;\n     }\n   return regexp;\n }\n@@ -1713,9 +1936,9 @@ gen_regexp_repeat (str)\n \t{\n \t  repeat = create_node (sizeof (struct regexp));\n \t  repeat->mode = rm_repeat;\n-\t  repeat->regexp.repeat.regexp = regexp;\n-\t  repeat->regexp.repeat.repeat_num = atoi (repeat_vect [i]);\n-          if (repeat->regexp.repeat.repeat_num <= 1)\n+\t  REGEXP_REPEAT (repeat)->regexp = regexp;\n+\t  REGEXP_REPEAT (repeat)->repeat_num = atoi (repeat_vect [i]);\n+          if (REGEXP_REPEAT (repeat)->repeat_num <= 1)\n             fatal (\"repetition `%s' <= 1 in reservation `%s'\",\n                    str, reserv_str);\n           regexp = repeat;\n@@ -1744,9 +1967,9 @@ gen_regexp_allof (str)\n       allof = create_node (sizeof (struct regexp)\n \t\t\t   + sizeof (regexp_t) * (els_num - 1));\n       allof->mode = rm_allof;\n-      allof->regexp.allof.regexps_num = els_num;\n+      REGEXP_ALLOF (allof)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n-\tallof->regexp.allof.regexps [i] = gen_regexp_repeat (allof_vect [i]);\n+\tREGEXP_ALLOF (allof)->regexps [i] = gen_regexp_repeat (allof_vect [i]);\n       return allof;\n     }\n   else\n@@ -1771,9 +1994,9 @@ gen_regexp_oneof (str)\n       oneof = create_node (sizeof (struct regexp)\n \t\t\t   + sizeof (regexp_t) * (els_num - 1));\n       oneof->mode = rm_oneof;\n-      oneof->regexp.oneof.regexps_num = els_num;\n+      REGEXP_ONEOF (oneof)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n-\toneof->regexp.oneof.regexps [i] = gen_regexp_allof (oneof_vect [i]);\n+\tREGEXP_ONEOF (oneof)->regexps [i] = gen_regexp_allof (oneof_vect [i]);\n       return oneof;\n     }\n   else\n@@ -1796,9 +2019,9 @@ gen_regexp_sequence (str)\n       sequence = create_node (sizeof (struct regexp)\n \t\t\t      + sizeof (regexp_t) * (els_num - 1));\n       sequence->mode = rm_sequence;\n-      sequence->regexp.sequence.regexps_num = els_num;\n+      REGEXP_SEQUENCE (sequence)->regexps_num = els_num;\n       for (i = 0; i < els_num; i++)\n-\tsequence->regexp.sequence.regexps [i]\n+\tREGEXP_SEQUENCE (sequence)->regexps [i]\n           = gen_regexp_oneof (sequence_vect [i]);\n       return sequence;\n     }\n@@ -1829,8 +2052,8 @@ gen_reserv (def)\n   decl = create_node (sizeof (struct decl));\n   decl->mode = dm_reserv;\n   decl->pos = 0;\n-  decl->decl.reserv.name = check_name ((char *) XSTR (def, 0), decl->pos);\n-  decl->decl.reserv.regexp = gen_regexp ((char *) XSTR (def, 1));\n+  DECL_RESERV (decl)->name = check_name ((char *) XSTR (def, 0), decl->pos);\n+  DECL_RESERV (decl)->regexp = gen_regexp ((char *) XSTR (def, 1));\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n }\n@@ -1849,10 +2072,11 @@ gen_insn_reserv (def)\n   decl = create_node (sizeof (struct decl));\n   decl->mode = dm_insn_reserv;\n   decl->pos = 0;\n-  decl->decl.insn_reserv.name = check_name ((char *) XSTR (def, 0), decl->pos);\n-  decl->decl.insn_reserv.default_latency = XINT (def, 1);\n-  decl->decl.insn_reserv.condexp = XEXP (def, 2);\n-  decl->decl.insn_reserv.regexp = gen_regexp ((char *) XSTR (def, 3));\n+  DECL_INSN_RESERV (decl)->name\n+    = check_name ((char *) XSTR (def, 0), decl->pos);\n+  DECL_INSN_RESERV (decl)->default_latency = XINT (def, 1);\n+  DECL_INSN_RESERV (decl)->condexp = XEXP (def, 2);\n+  DECL_INSN_RESERV (decl)->regexp = gen_regexp ((char *) XSTR (def, 3));\n   VLA_PTR_ADD (decls, decl);\n   num_dfa_decls++;\n }\n@@ -1887,9 +2111,9 @@ automaton_decl_hash (automaton_decl)\n {\n   const decl_t decl = (decl_t) automaton_decl;\n \n-  if (decl->mode == dm_automaton && decl->decl.automaton.name == NULL)\n+  if (decl->mode == dm_automaton && DECL_AUTOMATON (decl)->name == NULL)\n     abort ();\n-  return string_hash (decl->decl.automaton.name);\n+  return string_hash (DECL_AUTOMATON (decl)->name);\n }\n \n /* The function tests automaton declarations on equality of their\n@@ -1904,10 +2128,11 @@ automaton_decl_eq_p (automaton_decl_1, automaton_decl_2)\n   const decl_t decl1 = (decl_t) automaton_decl_1;\n   const decl_t decl2 = (decl_t) automaton_decl_2;\n \n-  if (decl1->mode != dm_automaton || decl1->decl.automaton.name == NULL\n-      || decl2->mode != dm_automaton || decl2->decl.automaton.name == NULL)\n+  if (decl1->mode != dm_automaton || DECL_AUTOMATON (decl1)->name == NULL\n+      || decl2->mode != dm_automaton || DECL_AUTOMATON (decl2)->name == NULL)\n     abort ();\n-  return strcmp (decl1->decl.automaton.name, decl2->decl.automaton.name) == 0;\n+  return strcmp (DECL_AUTOMATON (decl1)->name,\n+\t\t DECL_AUTOMATON (decl2)->name) == 0;\n }\n \n /* The automaton declaration table itself is represented by the\n@@ -1946,7 +2171,8 @@ find_automaton_decl (name)\n {\n   void *entry;\n \n-  work_automaton_decl.decl.automaton.name = name;\n+  work_automaton_decl.mode = dm_automaton;\n+  DECL_AUTOMATON (&work_automaton_decl)->name = name;\n   entry = htab_find (automaton_decl_table, &work_automaton_decl);\n   return (decl_t) entry;\n }\n@@ -1989,9 +2215,9 @@ insn_decl_hash (insn_decl)\n {\n   const decl_t decl = (decl_t) insn_decl;\n \n-  if (decl->mode != dm_insn_reserv || decl->decl.insn_reserv.name == NULL)\n+  if (decl->mode != dm_insn_reserv || DECL_INSN_RESERV (decl)->name == NULL)\n     abort ();\n-  return string_hash (decl->decl.insn_reserv.name);\n+  return string_hash (DECL_INSN_RESERV (decl)->name);\n }\n \n /* The function tests insn declarations on equality of their keys.\n@@ -2005,11 +2231,12 @@ insn_decl_eq_p (insn_decl_1, insn_decl_2)\n   const decl_t decl1 = (decl_t) insn_decl_1;\n   const decl_t decl2 = (decl_t) insn_decl_2;\n \n-  if (decl1->mode != dm_insn_reserv || decl1->decl.insn_reserv.name == NULL\n-      || decl2->mode != dm_insn_reserv || decl2->decl.insn_reserv.name == NULL)\n+  if (decl1->mode != dm_insn_reserv || DECL_INSN_RESERV (decl1)->name == NULL\n+      || decl2->mode != dm_insn_reserv\n+      || DECL_INSN_RESERV (decl2)->name == NULL)\n     abort ();\n-  return strcmp (decl1->decl.insn_reserv.name,\n-                 decl2->decl.insn_reserv.name) == 0;\n+  return strcmp (DECL_INSN_RESERV (decl1)->name,\n+                 DECL_INSN_RESERV (decl2)->name) == 0;\n }\n \n /* The insn declaration table itself is represented by the following\n@@ -2048,7 +2275,8 @@ find_insn_decl (name)\n {\n   void *entry;\n \n-  work_insn_decl.decl.insn_reserv.name = name;\n+  work_insn_decl.mode = dm_insn_reserv;\n+  DECL_INSN_RESERV (&work_insn_decl)->name = name;\n   entry = htab_find (insn_decl_table, &work_insn_decl);\n   return (decl_t) entry;\n }\n@@ -2090,11 +2318,11 @@ decl_hash (decl)\n {\n   const decl_t d = (const decl_t) decl;\n \n-  if ((d->mode != dm_unit || d->decl.unit.name == NULL)\n-      && (d->mode != dm_reserv || d->decl.reserv.name == NULL))\n+  if ((d->mode != dm_unit || DECL_UNIT (d)->name == NULL)\n+      && (d->mode != dm_reserv || DECL_RESERV (d)->name == NULL))\n     abort ();\n   return string_hash (d->mode == dm_unit\n-\t\t      ? d->decl.unit.name : d->decl.reserv.name);\n+\t\t      ? DECL_UNIT (d)->name : DECL_RESERV (d)->name);\n }\n \n /* The function tests declarations on equality of their keys.  The\n@@ -2108,15 +2336,15 @@ decl_eq_p (decl_1, decl_2)\n   const decl_t d1 = (const decl_t) decl_1;\n   const decl_t d2 = (const decl_t) decl_2;\n \n-  if (((d1->mode != dm_unit || d1->decl.unit.name == NULL)\n-       && (d1->mode != dm_reserv || d1->decl.reserv.name == NULL))\n-      || ((d2->mode != dm_unit || d2->decl.unit.name == NULL)\n-\t  && (d2->mode != dm_reserv || d2->decl.reserv.name == NULL)))\n+  if (((d1->mode != dm_unit || DECL_UNIT (d1)->name == NULL)\n+       && (d1->mode != dm_reserv || DECL_RESERV (d1)->name == NULL))\n+      || ((d2->mode != dm_unit || DECL_UNIT (d2)->name == NULL)\n+\t  && (d2->mode != dm_reserv || DECL_RESERV (d2)->name == NULL)))\n     abort ();\n   return strcmp ((d1->mode == dm_unit\n-                  ? d1->decl.unit.name : d1->decl.reserv.name),\n+                  ? DECL_UNIT (d1)->name : DECL_RESERV (d1)->name),\n                  (d2->mode == dm_unit\n-                  ? d2->decl.unit.name : d2->decl.reserv.name)) == 0;\n+                  ? DECL_UNIT (d2)->name : DECL_RESERV (d2)->name)) == 0;\n }\n \n /* The declaration table itself is represented by the following\n@@ -2154,7 +2382,8 @@ find_decl (name)\n {\n   void *entry;\n \n-  work_decl.decl.unit.name = name;\n+  work_decl.mode = dm_unit;\n+  DECL_UNIT (&work_decl)->name = name;\n   entry = htab_find (decl_table, &work_decl);\n   return (decl_t) entry;\n }\n@@ -2209,7 +2438,7 @@ process_excls (names, num, excl_pos)\n       else\n \t{\n \t  new_el = create_node (sizeof (struct unit_set_el));\n-\t  new_el->unit_decl = &decl_in_table->decl.unit;\n+\t  new_el->unit_decl = DECL_UNIT (decl_in_table);\n \t  new_el->next_unit_set_el = NULL;\n \t  if (last_el == NULL)\n \t    el_list = last_el = new_el;\n@@ -2305,7 +2534,7 @@ process_presence_absence (names, num, req_pos, presence_p)\n       else\n \t{\n \t  new_el = create_node (sizeof (struct unit_set_el));\n-\t  new_el->unit_decl = &decl_in_table->decl.unit;\n+\t  new_el->unit_decl = DECL_UNIT (decl_in_table);\n \t  new_el->next_unit_set_el = NULL;\n \t  if (last_el == NULL)\n \t    el_list = last_el = new_el;\n@@ -2471,10 +2700,10 @@ process_decls ()\n \t    {\n \t      if (!w_flag)\n \t\terror (\"repeated declaration of automaton `%s'\",\n-\t\t       decl->decl.automaton.name);\n+\t\t       DECL_AUTOMATON (decl)->name);\n \t      else\n \t\twarning (\"repeated declaration of automaton `%s'\",\n-\t\t\t decl->decl.automaton.name);\n+\t\t\t DECL_AUTOMATON (decl)->name);\n \t    }\n \t}\n     }\n@@ -2486,75 +2715,75 @@ process_decls ()\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n \t{\n-          decl->decl.insn_reserv.condexp\n-\t    = check_attr_test (decl->decl.insn_reserv.condexp, 0, 0);\n-\t  if (decl->decl.insn_reserv.default_latency < 0)\n+          DECL_INSN_RESERV (decl)->condexp\n+\t    = check_attr_test (DECL_INSN_RESERV (decl)->condexp, 0, 0);\n+\t  if (DECL_INSN_RESERV (decl)->default_latency < 0)\n \t    error (\"define_insn_reservation `%s' has negative latency time\",\n-\t\t   decl->decl.insn_reserv.name);\n-\t  decl->decl.insn_reserv.insn_num = description->insns_num;\n+\t\t   DECL_INSN_RESERV (decl)->name);\n+\t  DECL_INSN_RESERV (decl)->insn_num = description->insns_num;\n \t  description->insns_num++;\n \t  decl_in_table = insert_insn_decl (decl);\n \t  if (decl_in_table != decl)\n \t    error (\"`%s' is already used as insn reservation name\",\n-\t\t   decl->decl.insn_reserv.name);\n+\t\t   DECL_INSN_RESERV (decl)->name);\n \t}\n       else if (decl->mode == dm_bypass)\n \t{\n-\t  if (decl->decl.bypass.latency < 0)\n+\t  if (DECL_BYPASS (decl)->latency < 0)\n \t    error (\"define_bypass `%s - %s' has negative latency time\",\n-\t\t   decl->decl.bypass.out_insn_name,\n-\t\t   decl->decl.bypass.in_insn_name);\n+\t\t   DECL_BYPASS (decl)->out_insn_name,\n+\t\t   DECL_BYPASS (decl)->in_insn_name);\n \t}\n       else if (decl->mode == dm_unit || decl->mode == dm_reserv)\n \t{\n \t  if (decl->mode == dm_unit)\n \t    {\n-\t      decl->decl.unit.automaton_decl = NULL;\n-\t      if (decl->decl.unit.automaton_name != NULL)\n+\t      DECL_UNIT (decl)->automaton_decl = NULL;\n+\t      if (DECL_UNIT (decl)->automaton_name != NULL)\n \t\t{\n \t\t  automaton_decl\n-                    = find_automaton_decl (decl->decl.unit.automaton_name);\n+                    = find_automaton_decl (DECL_UNIT (decl)->automaton_name);\n \t\t  if (automaton_decl == NULL)\n \t\t    error (\"automaton `%s' is not declared\",\n-\t\t\t   decl->decl.unit.automaton_name);\n+\t\t\t   DECL_UNIT (decl)->automaton_name);\n \t\t  else\n \t\t    {\n-\t\t      automaton_decl->decl.automaton.automaton_is_used = 1;\n-\t\t      decl->decl.unit.automaton_decl\n-\t\t\t= &automaton_decl->decl.automaton;\n+\t\t      DECL_AUTOMATON (automaton_decl)->automaton_is_used = 1;\n+\t\t      DECL_UNIT (decl)->automaton_decl\n+\t\t\t= DECL_AUTOMATON (automaton_decl);\n \t\t    }\n \t\t}\n \t      else if (automaton_presence)\n \t\terror (\"define_unit `%s' without automaton when one defined\",\n-\t\t       decl->decl.unit.name);\n-\t      decl->decl.unit.unit_num = description->units_num;\n+\t\t       DECL_UNIT (decl)->name);\n+\t      DECL_UNIT (decl)->unit_num = description->units_num;\n \t      description->units_num++;\n-\t      if (strcmp (decl->decl.unit.name, NOTHING_NAME) == 0)\n+\t      if (strcmp (DECL_UNIT (decl)->name, NOTHING_NAME) == 0)\n \t\t{\n \t\t  error (\"`%s' is declared as cpu unit\", NOTHING_NAME);\n \t\t  continue;\n \t\t}\n-\t      decl_in_table = find_decl (decl->decl.unit.name);\n+\t      decl_in_table = find_decl (DECL_UNIT (decl)->name);\n \t    }\n \t  else\n \t    {\n-\t      if (strcmp (decl->decl.reserv.name, NOTHING_NAME) == 0)\n+\t      if (strcmp (DECL_RESERV (decl)->name, NOTHING_NAME) == 0)\n \t\t{\n \t\t  error (\"`%s' is declared as cpu reservation\", NOTHING_NAME);\n \t\t  continue;\n \t\t}\n-\t      decl_in_table = find_decl (decl->decl.reserv.name);\n+\t      decl_in_table = find_decl (DECL_RESERV (decl)->name);\n \t    }\n \t  if (decl_in_table == NULL)\n \t    decl_in_table = insert_decl (decl);\n \t  else\n \t    {\n \t      if (decl->mode == dm_unit)\n \t\terror (\"repeated declaration of unit `%s'\",\n-\t\t       decl->decl.unit.name);\n+\t\t       DECL_UNIT (decl)->name);\n \t      else\n \t\terror (\"repeated declaration of reservation `%s'\",\n-\t\t       decl->decl.reserv.name);\n+\t\t       DECL_RESERV (decl)->name);\n \t    }\n \t}\n     }\n@@ -2565,49 +2794,49 @@ process_decls ()\n       decl = description->decls [i];\n       if (decl->mode == dm_bypass)\n \t{\n-\t  out_insn_reserv = find_insn_decl (decl->decl.bypass.out_insn_name);\n-\t  in_insn_reserv = find_insn_decl (decl->decl.bypass.in_insn_name);\n+\t  out_insn_reserv = find_insn_decl (DECL_BYPASS (decl)->out_insn_name);\n+\t  in_insn_reserv = find_insn_decl (DECL_BYPASS (decl)->in_insn_name);\n \t  if (out_insn_reserv == NULL)\n \t    error (\"there is no insn reservation `%s'\",\n-\t\t   decl->decl.bypass.out_insn_name);\n+\t\t   DECL_BYPASS (decl)->out_insn_name);\n \t  else if (in_insn_reserv == NULL)\n \t    error (\"there is no insn reservation `%s'\",\n-\t\t   decl->decl.bypass.in_insn_name);\n+\t\t   DECL_BYPASS (decl)->in_insn_name);\n \t  else\n \t    {\n-\t      decl->decl.bypass.out_insn_reserv\n-\t\t= &out_insn_reserv->decl.insn_reserv;\n-\t      decl->decl.bypass.in_insn_reserv\n-\t\t= &in_insn_reserv->decl.insn_reserv;\n+\t      DECL_BYPASS (decl)->out_insn_reserv\n+\t\t= DECL_INSN_RESERV (out_insn_reserv);\n+\t      DECL_BYPASS (decl)->in_insn_reserv\n+\t\t= DECL_INSN_RESERV (in_insn_reserv);\n \t      bypass\n-\t\t= find_bypass (out_insn_reserv->decl.insn_reserv.bypass_list,\n-\t\t\t       decl->decl.bypass.in_insn_reserv);\n+\t\t= find_bypass (DECL_INSN_RESERV (out_insn_reserv)->bypass_list,\n+\t\t\t       DECL_BYPASS (decl)->in_insn_reserv);\n \t      if (bypass != NULL)\n \t\t{\n-\t\t  if (decl->decl.bypass.latency == bypass->latency)\n+\t\t  if (DECL_BYPASS (decl)->latency == bypass->latency)\n \t\t    {\n \t\t      if (!w_flag)\n \t\t\terror\n \t\t\t  (\"the same bypass `%s - %s' is already defined\",\n-\t\t\t   decl->decl.bypass.out_insn_name,\n-\t\t\t   decl->decl.bypass.in_insn_name);\n+\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n+\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n \t\t      else\n \t\t\twarning\n \t\t\t  (\"the same bypass `%s - %s' is already defined\",\n-\t\t\t   decl->decl.bypass.out_insn_name,\n-\t\t\t   decl->decl.bypass.in_insn_name);\n+\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n+\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n \t\t    }\n \t\t  else\n \t\t    error (\"bypass `%s - %s' is already defined\",\n-\t\t\t   decl->decl.bypass.out_insn_name,\n-\t\t\t   decl->decl.bypass.in_insn_name);\n+\t\t\t   DECL_BYPASS (decl)->out_insn_name,\n+\t\t\t   DECL_BYPASS (decl)->in_insn_name);\n \t\t}\n \t      else\n \t\t{\n-\t\t  decl->decl.bypass.next\n-\t\t    = out_insn_reserv->decl.insn_reserv.bypass_list;\n-\t\t  out_insn_reserv->decl.insn_reserv.bypass_list\n-\t\t    = &decl->decl.bypass;\n+\t\t  DECL_BYPASS (decl)->next\n+\t\t    = DECL_INSN_RESERV (out_insn_reserv)->bypass_list;\n+\t\t  DECL_INSN_RESERV (out_insn_reserv)->bypass_list\n+\t\t    = DECL_BYPASS (decl);\n \t\t}\n \t    }\n \t}\n@@ -2623,13 +2852,13 @@ process_decls ()\n \t  unit_set_el_t unit_set_el_list_2;\n \t  \n \t  unit_set_el_list\n-            = process_excls (decl->decl.excl.names,\n-\t\t\t     decl->decl.excl.first_list_length, decl->pos);\n+            = process_excls (DECL_EXCL (decl)->names,\n+\t\t\t     DECL_EXCL (decl)->first_list_length, decl->pos);\n \t  unit_set_el_list_2\n-\t    = process_excls (&decl->decl.excl.names\n-\t\t\t     [decl->decl.excl.first_list_length],\n-                             decl->decl.excl.names_num\n-                             - decl->decl.excl.first_list_length,\n+\t    = process_excls (&DECL_EXCL (decl)->names\n+\t\t\t     [DECL_EXCL (decl)->first_list_length],\n+                             DECL_EXCL (decl)->names_num\n+                             - DECL_EXCL (decl)->first_list_length,\n                              decl->pos);\n \t  add_excls (unit_set_el_list, unit_set_el_list_2, decl->pos);\n \t  add_excls (unit_set_el_list_2, unit_set_el_list, decl->pos);\n@@ -2647,14 +2876,14 @@ process_decls ()\n \t  \n \t  unit_set_el_list\n             = process_presence_absence\n-\t      (decl->decl.presence.names,\n-\t       decl->decl.presence.first_list_length, decl->pos, 1);\n+\t      (DECL_PRESENCE (decl)->names,\n+\t       DECL_PRESENCE (decl)->first_list_length, decl->pos, 1);\n \t  unit_set_el_list_2\n \t    = process_presence_absence\n-\t      (&decl->decl.presence.names\n-\t       [decl->decl.presence.first_list_length],\n-\t       decl->decl.presence.names_num\n-\t       - decl->decl.presence.first_list_length,\n+\t      (&DECL_PRESENCE (decl)->names\n+\t       [DECL_PRESENCE (decl)->first_list_length],\n+\t       DECL_PRESENCE (decl)->names_num\n+\t       - DECL_PRESENCE (decl)->first_list_length,\n \t       decl->pos, 1);\n \t  add_presence_absence (unit_set_el_list, unit_set_el_list_2,\n \t\t\t\tdecl->pos, 1);\n@@ -2672,14 +2901,14 @@ process_decls ()\n \t  \n \t  unit_set_el_list\n             = process_presence_absence\n-\t      (decl->decl.presence.names,\n-\t       decl->decl.presence.first_list_length, decl->pos, 0);\n+\t      (DECL_ABSENCE (decl)->names,\n+\t       DECL_ABSENCE (decl)->first_list_length, decl->pos, 0);\n \t  unit_set_el_list_2\n \t    = process_presence_absence\n-\t      (&decl->decl.presence.names\n-\t       [decl->decl.presence.first_list_length],\n-\t       decl->decl.presence.names_num\n-\t       - decl->decl.presence.first_list_length,\n+\t      (&DECL_ABSENCE (decl)->names\n+\t       [DECL_ABSENCE (decl)->first_list_length],\n+\t       DECL_ABSENCE (decl)->names_num\n+\t       - DECL_ABSENCE (decl)->first_list_length,\n \t       decl->pos, 0);\n \t  add_presence_absence (unit_set_el_list, unit_set_el_list_2,\n \t\t\t\tdecl->pos, 0);\n@@ -2700,12 +2929,13 @@ check_automaton_usage ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_automaton\n-\t  && !decl->decl.automaton.automaton_is_used)\n+\t  && !DECL_AUTOMATON (decl)->automaton_is_used)\n \t{\n \t  if (!w_flag)\n-\t    error (\"automaton `%s' is not used\", decl->decl.automaton.name);\n+\t    error (\"automaton `%s' is not used\", DECL_AUTOMATON (decl)->name);\n \t  else\n-\t    warning (\"automaton `%s' is not used\", decl->decl.automaton.name);\n+\t    warning (\"automaton `%s' is not used\",\n+\t\t     DECL_AUTOMATON (decl)->name);\n \t}\n     }\n }\n@@ -2725,43 +2955,44 @@ process_regexp (regexp)\n     \n   if (regexp->mode == rm_unit)\n     {\n-      decl_in_table = find_decl (regexp->regexp.unit.name);\n+      decl_in_table = find_decl (REGEXP_UNIT (regexp)->name);\n       if (decl_in_table == NULL)\n         error (\"undeclared unit or reservation `%s'\",\n-\t       regexp->regexp.unit.name);\n+\t       REGEXP_UNIT (regexp)->name);\n       else if (decl_in_table->mode == dm_unit)\n \t{\n-\t  decl_in_table->decl.unit.unit_is_used = 1;\n-\t  regexp->regexp.unit.unit_decl = &decl_in_table->decl.unit;\n+\t  DECL_UNIT (decl_in_table)->unit_is_used = 1;\n+\t  REGEXP_UNIT (regexp)->unit_decl = DECL_UNIT (decl_in_table);\n \t}\n       else if (decl_in_table->mode == dm_reserv)\n \t{\n-\t  decl_in_table->decl.reserv.reserv_is_used = 1;\n+\t  DECL_RESERV (decl_in_table)->reserv_is_used = 1;\n \t  new_regexp = create_node (sizeof (struct regexp));\n \t  new_regexp->mode = rm_reserv;\n \t  new_regexp->pos = regexp->pos;\n-\t  new_regexp->regexp.reserv.name = regexp->regexp.unit.name;\n-\t  new_regexp->regexp.reserv.reserv_decl = &decl_in_table->decl.reserv;\n+\t  REGEXP_RESERV (new_regexp)->name = REGEXP_UNIT (regexp)->name;\n+\t  REGEXP_RESERV (new_regexp)->reserv_decl\n+\t    = DECL_RESERV (decl_in_table);\n \t  regexp = new_regexp;\n \t}\n       else\n \tabort ();\n     }\n   else if (regexp->mode == rm_sequence)\n-    for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-      regexp->regexp.sequence.regexps [i]\n-\t= process_regexp (regexp->regexp.sequence.regexps [i]);\n+    for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+     REGEXP_SEQUENCE (regexp)->regexps [i]\n+\t= process_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n   else if (regexp->mode == rm_allof)\n-    for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-      regexp->regexp.allof.regexps [i]\n-        = process_regexp (regexp->regexp.allof.regexps [i]);\n+    for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+      REGEXP_ALLOF (regexp)->regexps [i]\n+        = process_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n   else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n-      regexp->regexp.oneof.regexps [i]\n-\t= process_regexp (regexp->regexp.oneof.regexps [i]);\n+    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+      REGEXP_ONEOF (regexp)->regexps [i]\n+\t= process_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n   else if (regexp->mode == rm_repeat)\n-    regexp->regexp.repeat.regexp\n-      = process_regexp (regexp->regexp.repeat.regexp);\n+    REGEXP_REPEAT (regexp)->regexp\n+      = process_regexp (REGEXP_REPEAT (regexp)->regexp);\n   else if (regexp->mode != rm_nothing)\n     abort ();\n   return regexp;\n@@ -2780,10 +3011,11 @@ process_regexp_decls ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_reserv)\n-\tdecl->decl.reserv.regexp = process_regexp (decl->decl.reserv.regexp);\n+\tDECL_RESERV (decl)->regexp\n+\t  = process_regexp (DECL_RESERV (decl)->regexp);\n       else if (decl->mode == dm_insn_reserv)\n-\tdecl->decl.insn_reserv.regexp\n-\t  = process_regexp (decl->decl.insn_reserv.regexp);\n+\tDECL_INSN_RESERV (decl)->regexp\n+\t  = process_regexp (DECL_INSN_RESERV (decl)->regexp);\n     }\n }\n \n@@ -2800,19 +3032,19 @@ check_usage ()\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n-      if (decl->mode == dm_unit && !decl->decl.unit.unit_is_used)\n+      if (decl->mode == dm_unit && !DECL_UNIT (decl)->unit_is_used)\n \t{\n \t  if (!w_flag)\n-\t    error (\"unit `%s' is not used\", decl->decl.unit.name);\n+\t    error (\"unit `%s' is not used\", DECL_UNIT (decl)->name);\n \t  else\n-\t    warning (\"unit `%s' is not used\", decl->decl.unit.name);\n+\t    warning (\"unit `%s' is not used\", DECL_UNIT (decl)->name);\n \t}\n-      else if (decl->mode == dm_reserv && !decl->decl.reserv.reserv_is_used)\n+      else if (decl->mode == dm_reserv && !DECL_RESERV (decl)->reserv_is_used)\n \t{\n \t  if (!w_flag)\n-\t    error (\"reservation `%s' is not used\", decl->decl.reserv.name);\n+\t    error (\"reservation `%s' is not used\", DECL_RESERV (decl)->name);\n \t  else\n-\t    warning (\"reservation `%s' is not used\", decl->decl.reserv.name);\n+\t    warning (\"reservation `%s' is not used\", DECL_RESERV (decl)->name);\n \t}\n     }\n }\n@@ -2838,43 +3070,43 @@ loop_in_regexp (regexp, start_decl)\n   else if (regexp->mode == rm_reserv)\n     {\n       if (start_decl->mode == dm_reserv\n-          && regexp->regexp.reserv.reserv_decl == &start_decl->decl.reserv)\n+          && REGEXP_RESERV (regexp)->reserv_decl == DECL_RESERV (start_decl))\n         return 1;\n-      else if (regexp->regexp.reserv.reserv_decl->loop_pass_num\n+      else if (REGEXP_RESERV (regexp)->reserv_decl->loop_pass_num\n \t       == curr_loop_pass_num)\n         /* declaration has been processed.  */\n         return 0;\n       else\n         {\n-\t  regexp->regexp.reserv.reserv_decl->loop_pass_num\n+\t  REGEXP_RESERV (regexp)->reserv_decl->loop_pass_num\n             = curr_loop_pass_num;\n-          return loop_in_regexp (regexp->regexp.reserv.reserv_decl->regexp,\n+          return loop_in_regexp (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n                                  start_decl);\n         }\n     }\n   else if (regexp->mode == rm_sequence)\n     {\n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-\tif (loop_in_regexp (regexp->regexp.sequence.regexps [i], start_decl))\n+      for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tif (loop_in_regexp (REGEXP_SEQUENCE (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n     }\n   else if (regexp->mode == rm_allof)\n     {\n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-\tif (loop_in_regexp (regexp->regexp.allof.regexps [i], start_decl))\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tif (loop_in_regexp (REGEXP_ALLOF (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n     }\n   else if (regexp->mode == rm_oneof)\n     {\n-      for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n-\tif (loop_in_regexp (regexp->regexp.oneof.regexps [i], start_decl))\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\tif (loop_in_regexp (REGEXP_ONEOF (regexp)->regexps [i], start_decl))\n \t  return 1;\n       return 0;\n     }\n   else if (regexp->mode == rm_repeat)\n-    return loop_in_regexp (regexp->regexp.repeat.regexp, start_decl);\n+    return loop_in_regexp (REGEXP_REPEAT (regexp)->regexp, start_decl);\n   else\n     {\n       if (regexp->mode != rm_nothing)\n@@ -2895,7 +3127,7 @@ check_loops_in_regexps ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_reserv)\n-\tdecl->decl.reserv.loop_pass_num = 0;\n+\tDECL_RESERV (decl)->loop_pass_num = 0;\n     }\n   for (i = 0; i < description->decls_num; i++)\n     {\n@@ -2904,13 +3136,13 @@ check_loops_in_regexps ()\n       \n       if (decl->mode == dm_reserv)\n \t  {\n-\t    decl->decl.reserv.loop_pass_num = curr_loop_pass_num;\n-\t    if (loop_in_regexp (decl->decl.reserv.regexp, decl))\n+\t    DECL_RESERV (decl)->loop_pass_num = curr_loop_pass_num;\n+\t    if (loop_in_regexp (DECL_RESERV (decl)->regexp, decl))\n \t      {\n-\t\tif (decl->decl.reserv.regexp == NULL)\n+\t\tif (DECL_RESERV (decl)->regexp == NULL)\n \t\t  abort ();\n \t\terror (\"cycle in definition of reservation `%s'\",\n-\t\t       decl->decl.reserv.name);\n+\t\t       DECL_RESERV (decl)->name);\n \t      }\n \t  }\n     }\n@@ -2928,25 +3160,25 @@ process_regexp_cycles (regexp, start_cycle)\n \n   if (regexp->mode == rm_unit)\n     {\n-      if (regexp->regexp.unit.unit_decl->max_occ_cycle_num < start_cycle)\n-\tregexp->regexp.unit.unit_decl->max_occ_cycle_num = start_cycle;\n+      if (REGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num < start_cycle)\n+\tREGEXP_UNIT (regexp)->unit_decl->max_occ_cycle_num = start_cycle;\n       return start_cycle;\n     }\n   else if (regexp->mode == rm_reserv)\n-    return process_regexp_cycles (regexp->regexp.reserv.reserv_decl->regexp,\n+    return process_regexp_cycles (REGEXP_RESERV (regexp)->reserv_decl->regexp,\n                                   start_cycle);\n   else if (regexp->mode == rm_repeat)\n     {\n-      for (i = 0; i < regexp->regexp.repeat.repeat_num; i++)\n-        start_cycle = process_regexp_cycles (regexp->regexp.repeat.regexp,\n+      for (i = 0; i < REGEXP_REPEAT (regexp)->repeat_num; i++)\n+        start_cycle = process_regexp_cycles (REGEXP_REPEAT (regexp)->regexp,\n \t\t\t\t\t     start_cycle) + 1;\n       return start_cycle;\n     }\n   else if (regexp->mode == rm_sequence)\n     {\n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n+      for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tstart_cycle\n-          = process_regexp_cycles (regexp->regexp.sequence.regexps [i],\n+          = process_regexp_cycles (REGEXP_SEQUENCE (regexp)->regexps [i],\n \t\t\t\t   start_cycle) + 1;\n       return start_cycle;\n     }\n@@ -2955,9 +3187,9 @@ process_regexp_cycles (regexp, start_cycle)\n       int finish_cycle = 0;\n       int cycle;\n \n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t{\n-\t  cycle = process_regexp_cycles (regexp->regexp.allof.regexps [i],\n+\t  cycle = process_regexp_cycles (REGEXP_ALLOF (regexp)->regexps [i],\n \t\t\t\t\t start_cycle);\n \t  if (finish_cycle < cycle)\n \t    finish_cycle = cycle;\n@@ -2969,9 +3201,9 @@ process_regexp_cycles (regexp, start_cycle)\n       int finish_cycle = 0;\n       int cycle;\n \n-      for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n \t{\n-\t  cycle = process_regexp_cycles (regexp->regexp.oneof.regexps [i],\n+\t  cycle = process_regexp_cycles (REGEXP_ONEOF (regexp)->regexps [i],\n \t\t\t\t\t start_cycle);\n \t  if (finish_cycle < cycle)\n \t    finish_cycle = cycle;\n@@ -3002,7 +3234,7 @@ evaluate_max_reserv_cycles ()\n       if (decl->mode == dm_insn_reserv)\n       {\n         max_insn_cycles_num\n-          = process_regexp_cycles (decl->decl.insn_reserv.regexp, 0);\n+          = process_regexp_cycles (DECL_INSN_RESERV (decl)->regexp, 0);\n         if (description->max_insn_reserv_cycles < max_insn_cycles_num)\n \t  description->max_insn_reserv_cycles = max_insn_cycles_num;\n       }\n@@ -3148,9 +3380,10 @@ add_advance_cycle_insn_decl ()\n   advance_cycle_insn_decl = create_node (sizeof (struct decl));\n   advance_cycle_insn_decl->mode = dm_insn_reserv;\n   advance_cycle_insn_decl->pos = no_pos;\n-  advance_cycle_insn_decl->decl.insn_reserv.regexp = NULL;\n-  advance_cycle_insn_decl->decl.insn_reserv.name = (char *) \"$advance_cycle\";\n-  advance_cycle_insn_decl->decl.insn_reserv.insn_num = description->insns_num;\n+  DECL_INSN_RESERV (advance_cycle_insn_decl)->regexp = NULL;\n+  DECL_INSN_RESERV (advance_cycle_insn_decl)->name = (char *) \"$advance_cycle\";\n+  DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num\n+    = description->insns_num;\n   description->decls [description->decls_num] = advance_cycle_insn_decl;\n   description->decls_num++;\n   description->insns_num++;\n@@ -3913,7 +4146,7 @@ initiate_states ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n-\tunits_array [decl->decl.unit.unit_num] = &decl->decl.unit;\n+\tunits_array [DECL_UNIT (decl)->unit_num] = DECL_UNIT (decl);\n     }\n   max_cycles_num = description->max_insn_reserv_cycles;\n   els_in_cycle_reserv\n@@ -4263,11 +4496,11 @@ initiate_excl_sets ()\n \t  unit_excl_set = (reserv_sets_t) obstack_base (&irp);\n \t  obstack_finish (&irp);\n \t  memset (unit_excl_set, 0, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  for (el = decl->decl.unit.excl_list;\n+\t  for (el = DECL_UNIT (decl)->excl_list;\n \t       el != NULL;\n \t       el = el->next_unit_set_el)\n             SET_BIT (unit_excl_set, el->unit_decl->unit_num);\n-          unit_excl_set_table [decl->decl.unit.unit_num] = unit_excl_set;\n+          unit_excl_set_table [DECL_UNIT (decl)->unit_num] = unit_excl_set;\n         }\n     }\n }\n@@ -4349,21 +4582,21 @@ initiate_presence_absence_sets ()\n \t  unit_set = (reserv_sets_t) obstack_base (&irp);\n \t  obstack_finish (&irp);\n \t  memset (unit_set, 0, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  for (el = decl->decl.unit.presence_list;\n+\t  for (el = DECL_UNIT (decl)->presence_list;\n \t       el != NULL;\n \t       el = el->next_unit_set_el)\n             SET_BIT (unit_set, el->unit_decl->unit_num);\n-          unit_presence_set_table [decl->decl.unit.unit_num] = unit_set;\n+          unit_presence_set_table [DECL_UNIT (decl)->unit_num] = unit_set;\n \n \t  obstack_blank (&irp, els_in_cycle_reserv * sizeof (set_el_t));\n \t  unit_set = (reserv_sets_t) obstack_base (&irp);\n \t  obstack_finish (&irp);\n \t  memset (unit_set, 0, els_in_cycle_reserv * sizeof (set_el_t));\n-\t  for (el = decl->decl.unit.absence_list;\n+\t  for (el = DECL_UNIT (decl)->absence_list;\n \t       el != NULL;\n \t       el = el->next_unit_set_el)\n             SET_BIT (unit_set, el->unit_decl->unit_num);\n-          unit_absence_set_table [decl->decl.unit.unit_num] = unit_set;\n+          unit_absence_set_table [DECL_UNIT (decl)->unit_num] = unit_set;\n         }\n     }\n }\n@@ -4426,41 +4659,41 @@ copy_insn_regexp (regexp)\n   int i;\n \n   if (regexp->mode == rm_reserv)\n-    result = copy_insn_regexp (regexp->regexp.reserv.reserv_decl->regexp);\n+    result = copy_insn_regexp (REGEXP_RESERV (regexp)->reserv_decl->regexp);\n   else if (regexp->mode == rm_unit)\n     result = copy_node (regexp, sizeof (struct regexp));\n   else if (regexp->mode == rm_repeat)\n     {\n       result = copy_node (regexp, sizeof (struct regexp));\n-      result->regexp.repeat.regexp\n-        = copy_insn_regexp (regexp->regexp.repeat.regexp);\n+      REGEXP_REPEAT (result)->regexp\n+        = copy_insn_regexp (REGEXP_REPEAT (regexp)->regexp);\n     }\n   else if (regexp->mode == rm_sequence)\n     {\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (regexp->regexp.sequence.regexps_num - 1));\n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-\tresult->regexp.sequence.regexps [i]\n-\t  = copy_insn_regexp (regexp->regexp.sequence.regexps [i]);\n+\t\t\t  * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n+      for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tREGEXP_SEQUENCE (result)->regexps [i]\n+\t  = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n     }\n   else if (regexp->mode == rm_allof)\n     {\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (regexp->regexp.allof.regexps_num - 1));\n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-\tresult->regexp.allof.regexps [i]\n-\t  = copy_insn_regexp (regexp->regexp.allof.regexps [i]);\n+\t\t\t  * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tREGEXP_ALLOF (result)->regexps [i]\n+\t  = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n     }\n   else if (regexp->mode == rm_oneof)\n     {\n       result = copy_node (regexp,\n                           sizeof (struct regexp) + sizeof (regexp_t)\n-\t\t\t  * (regexp->regexp.oneof.regexps_num - 1));\n-      for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n-\tresult->regexp.oneof.regexps [i]\n-\t  = copy_insn_regexp (regexp->regexp.oneof.regexps [i]);\n+\t\t\t  * (REGEXP_ONEOF (regexp)->regexps_num - 1));\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\tREGEXP_ONEOF (result)->regexps [i]\n+\t  = copy_insn_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n     }\n   else\n     {\n@@ -4488,18 +4721,18 @@ transform_1 (regexp)\n \n   if (regexp->mode == rm_repeat)\n     {\n-      repeat_num = regexp->regexp.repeat.repeat_num;\n+      repeat_num = REGEXP_REPEAT (regexp)->repeat_num;\n       if (repeat_num <= 1)\n \tabort ();\n-      operand = regexp->regexp.repeat.regexp;\n+      operand = REGEXP_REPEAT (regexp)->regexp;\n       pos = regexp->mode;\n       regexp = create_node (sizeof (struct regexp) + sizeof (regexp_t)\n \t\t\t    * (repeat_num - 1));\n       regexp->mode = rm_sequence;\n       regexp->pos = pos;\n-      regexp->regexp.sequence.regexps_num = repeat_num;\n+      REGEXP_SEQUENCE (regexp)->regexps_num = repeat_num;\n       for (i = 0; i < repeat_num; i++)\n-\tregexp->regexp.sequence.regexps [i] = copy_insn_regexp (operand);\n+\tREGEXP_SEQUENCE (regexp)->regexps [i] = copy_insn_regexp (operand);\n       regexp_transformed_p = 1;\n     }\n   return regexp;\n@@ -4520,40 +4753,40 @@ transform_2 (regexp)\n       int sequence_index = 0;\n       int i, j;\n \n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-\tif (regexp->regexp.sequence.regexps [i]->mode == rm_sequence)\n+      for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tif (REGEXP_SEQUENCE (regexp)->regexps [i]->mode == rm_sequence)\n \t  {\n \t    sequence_index = i;\n-\t    sequence = regexp->regexp.sequence.regexps [i];\n+\t    sequence = REGEXP_SEQUENCE (regexp)->regexps [i];\n \t    break;\n \t  }\n-      if (i < regexp->regexp.sequence.regexps_num)\n+      if (i < REGEXP_SEQUENCE (regexp)->regexps_num)\n \t{\n-\t  if (sequence->regexp.sequence.regexps_num <= 1\n-\t      || regexp->regexp.sequence.regexps_num <= 1)\n+\t  if ( REGEXP_SEQUENCE (sequence)->regexps_num <= 1\n+\t      || REGEXP_SEQUENCE (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n                                 + sizeof (regexp_t)\n-\t\t\t\t* (regexp->regexp.sequence.regexps_num\n-                                   + sequence->regexp.sequence.regexps_num\n+\t\t\t\t* (REGEXP_SEQUENCE (regexp)->regexps_num\n+                                   + REGEXP_SEQUENCE (sequence)->regexps_num\n                                    - 2));\n \t  result->mode = rm_sequence;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.sequence.regexps_num\n-            = (regexp->regexp.sequence.regexps_num\n-               + sequence->regexp.sequence.regexps_num - 1);\n-\t  for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n+\t  REGEXP_SEQUENCE (result)->regexps_num\n+            = (REGEXP_SEQUENCE (regexp)->regexps_num\n+               + REGEXP_SEQUENCE (sequence)->regexps_num - 1);\n+\t  for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n             if (i < sequence_index)\n-              result->regexp.sequence.regexps [i]\n-                = copy_insn_regexp (regexp->regexp.sequence.regexps [i]);\n+              REGEXP_SEQUENCE (result)->regexps [i]\n+                = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n             else if (i > sequence_index)\n-              result->regexp.sequence.regexps\n-                [i + sequence->regexp.sequence.regexps_num - 1]\n-                = copy_insn_regexp (regexp->regexp.sequence.regexps [i]);\n+              REGEXP_SEQUENCE (result)->regexps\n+                [i + REGEXP_SEQUENCE (sequence)->regexps_num - 1]\n+                = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n             else\n-              for (j = 0; j < sequence->regexp.sequence.regexps_num; j++)\n-                result->regexp.sequence.regexps [i + j]\n-                  = copy_insn_regexp (sequence->regexp.sequence.regexps [j]);\n+              for (j = 0; j < REGEXP_SEQUENCE (sequence)->regexps_num; j++)\n+                REGEXP_SEQUENCE (result)->regexps [i + j]\n+                  = copy_insn_regexp (REGEXP_SEQUENCE (sequence)->regexps [j]);\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}\n@@ -4565,39 +4798,39 @@ transform_2 (regexp)\n       int allof_index = 0;\n       int i, j;\n \n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-\tif (regexp->regexp.allof.regexps [i]->mode == rm_allof)\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tif (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_allof)\n \t  {\n \t    allof_index = i;\n-\t    allof = regexp->regexp.allof.regexps [i];\n+\t    allof = REGEXP_ALLOF (regexp)->regexps [i];\n \t    break;\n \t  }\n-      if (i < regexp->regexp.allof.regexps_num)\n+      if (i < REGEXP_ALLOF (regexp)->regexps_num)\n \t{\n-\t  if (allof->regexp.allof.regexps_num <= 1\n-\t      || regexp->regexp.allof.regexps_num <= 1)\n+\t  if (REGEXP_ALLOF (allof)->regexps_num <= 1\n+\t      || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n                                 + sizeof (regexp_t)\n-\t\t\t\t* (regexp->regexp.allof.regexps_num\n-                                   + allof->regexp.allof.regexps_num - 2));\n+\t\t\t\t* (REGEXP_ALLOF (regexp)->regexps_num\n+                                   + REGEXP_ALLOF (allof)->regexps_num - 2));\n \t  result->mode = rm_allof;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.allof.regexps_num\n-            = (regexp->regexp.allof.regexps_num\n-               + allof->regexp.allof.regexps_num - 1);\n-\t  for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n+\t  REGEXP_ALLOF (result)->regexps_num\n+            = (REGEXP_ALLOF (regexp)->regexps_num\n+               + REGEXP_ALLOF (allof)->regexps_num - 1);\n+\t  for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n             if (i < allof_index)\n-              result->regexp.allof.regexps [i]\n-                = copy_insn_regexp (regexp->regexp.allof.regexps [i]);\n+              REGEXP_ALLOF (result)->regexps [i]\n+                = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n             else if (i > allof_index)\n-              result->regexp.allof.regexps\n-                [i + allof->regexp.allof.regexps_num - 1]\n-                = copy_insn_regexp (regexp->regexp.allof.regexps [i]);\n+              REGEXP_ALLOF (result)->regexps\n+                [i + REGEXP_ALLOF (allof)->regexps_num - 1]\n+                = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n             else\n-              for (j = 0; j < allof->regexp.allof.regexps_num; j++)\n-                result->regexp.allof.regexps [i + j]\n-                  = copy_insn_regexp (allof->regexp.allof.regexps [j]);\n+              for (j = 0; j < REGEXP_ALLOF (allof)->regexps_num; j++)\n+                REGEXP_ALLOF (result)->regexps [i + j]\n+                  = copy_insn_regexp (REGEXP_ALLOF (allof)->regexps [j]);\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}\n@@ -4609,39 +4842,39 @@ transform_2 (regexp)\n       int oneof_index = 0;\n       int i, j;\n \n-      for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n-\tif (regexp->regexp.oneof.regexps [i]->mode == rm_oneof)\n+      for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+\tif (REGEXP_ONEOF (regexp)->regexps [i]->mode == rm_oneof)\n \t  {\n \t    oneof_index = i;\n-\t    oneof = regexp->regexp.oneof.regexps [i];\n+\t    oneof = REGEXP_ONEOF (regexp)->regexps [i];\n \t    break;\n \t  }\n-      if (i < regexp->regexp.oneof.regexps_num)\n+      if (i < REGEXP_ONEOF (regexp)->regexps_num)\n \t{\n-\t  if (oneof->regexp.oneof.regexps_num <= 1\n-\t      || regexp->regexp.oneof.regexps_num <= 1)\n+\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n+\t      || REGEXP_ONEOF (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (regexp->regexp.oneof.regexps_num\n-                                   + oneof->regexp.oneof.regexps_num - 2));\n+\t\t\t\t* (REGEXP_ONEOF (regexp)->regexps_num\n+                                   + REGEXP_ONEOF (oneof)->regexps_num - 2));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.oneof.regexps_num\n-\t    = (regexp->regexp.oneof.regexps_num\n-               + oneof->regexp.oneof.regexps_num - 1);\n-\t  for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n+\t  REGEXP_ONEOF (result)->regexps_num\n+\t    = (REGEXP_ONEOF (regexp)->regexps_num\n+               + REGEXP_ONEOF (oneof)->regexps_num - 1);\n+\t  for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n             if (i < oneof_index)\n-              result->regexp.oneof.regexps [i]\n-                = copy_insn_regexp (regexp->regexp.oneof.regexps [i]);\n+              REGEXP_ONEOF (result)->regexps [i]\n+                = copy_insn_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n             else if (i > oneof_index)\n-              result->regexp.oneof.regexps\n-                [i + oneof->regexp.oneof.regexps_num - 1]\n-                = copy_insn_regexp (regexp->regexp.oneof.regexps [i]);\n+              REGEXP_ONEOF (result)->regexps\n+                [i + REGEXP_ONEOF (oneof)->regexps_num - 1]\n+                = copy_insn_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n             else\n-              for (j = 0; j < oneof->regexp.oneof.regexps_num; j++)\n-                result->regexp.oneof.regexps [i + j]\n-                  = copy_insn_regexp (oneof->regexp.oneof.regexps [j]);\n+              for (j = 0; j < REGEXP_ONEOF (oneof)->regexps_num; j++)\n+                REGEXP_ONEOF (result)->regexps [i + j]\n+                  = copy_insn_regexp (REGEXP_ONEOF (oneof)->regexps [j]);\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}\n@@ -4666,42 +4899,43 @@ transform_3 (regexp)\n       regexp_t sequence;\n       int i, j;\n \n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-\tif (regexp->regexp.sequence.regexps [i]->mode == rm_oneof)\n+      for (i = 0; i <REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+\tif (REGEXP_SEQUENCE (regexp)->regexps [i]->mode == rm_oneof)\n \t  {\n \t    oneof_index = i;\n-\t    oneof = regexp->regexp.sequence.regexps [i];\n+\t    oneof = REGEXP_SEQUENCE (regexp)->regexps [i];\n \t    break;\n \t  }\n-      if (i < regexp->regexp.sequence.regexps_num)\n+      if (i < REGEXP_SEQUENCE (regexp)->regexps_num)\n \t{\n-\t  if (oneof->regexp.oneof.regexps_num <= 1\n-\t      || regexp->regexp.sequence.regexps_num <= 1)\n+\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n+\t      || REGEXP_SEQUENCE (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (oneof->regexp.oneof.regexps_num - 1));\n+\t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.oneof.regexps_num = oneof->regexp.oneof.regexps_num;\n-\t  for (i = 0; i < result->regexp.oneof.regexps_num; i++)\n+\t  REGEXP_ONEOF (result)->regexps_num\n+\t    = REGEXP_ONEOF (oneof)->regexps_num;\n+\t  for (i = 0; i < REGEXP_ONEOF (result)->regexps_num; i++)\n \t    {\n \t      sequence\n                 = create_node (sizeof (struct regexp)\n                                + sizeof (regexp_t)\n-                               * (regexp->regexp.sequence.regexps_num - 1));\n+                               * (REGEXP_SEQUENCE (regexp)->regexps_num - 1));\n \t      sequence->mode = rm_sequence;\n \t      sequence->pos = regexp->pos;\n-\t      sequence->regexp.sequence.regexps_num\n-                = regexp->regexp.sequence.regexps_num;\n-              result->regexp.oneof.regexps [i] = sequence;\n-\t      for (j = 0; j < sequence->regexp.sequence.regexps_num; j++)\n+\t      REGEXP_SEQUENCE (sequence)->regexps_num\n+                = REGEXP_SEQUENCE (regexp)->regexps_num;\n+              REGEXP_ONEOF (result)->regexps [i] = sequence;\n+\t      for (j = 0; j < REGEXP_SEQUENCE (sequence)->regexps_num; j++)\n \t\tif (j != oneof_index)\n-\t\t  sequence->regexp.sequence.regexps [j]\n-\t\t    = copy_insn_regexp (regexp->regexp.sequence.regexps [j]);\n+\t\t  REGEXP_SEQUENCE (sequence)->regexps [j]\n+\t\t    = copy_insn_regexp (REGEXP_SEQUENCE (regexp)->regexps [j]);\n \t\telse\n-\t\t  sequence->regexp.sequence.regexps [j]\n-\t\t    = copy_insn_regexp (oneof->regexp.oneof.regexps [i]);\n+\t\t  REGEXP_SEQUENCE (sequence)->regexps [j]\n+\t\t    = copy_insn_regexp (REGEXP_ONEOF (oneof)->regexps [i]);\n \t    }\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n@@ -4712,118 +4946,125 @@ transform_3 (regexp)\n       regexp_t oneof = NULL, seq;\n       int oneof_index = 0, max_seq_length, allof_length;\n       regexp_t result;\n-      regexp_t allof = NULL, allof_op;\n+      regexp_t allof = NULL, allof_op = NULL;\n       int i, j;\n \n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-\tif (regexp->regexp.allof.regexps [i]->mode == rm_oneof)\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\tif (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_oneof)\n \t  {\n \t    oneof_index = i;\n-\t    oneof = regexp->regexp.allof.regexps [i];\n+\t    oneof = REGEXP_ALLOF (regexp)->regexps [i];\n \t    break;\n \t  }\n-      if (i < regexp->regexp.allof.regexps_num)\n+      if (i < REGEXP_ALLOF (regexp)->regexps_num)\n \t{\n-\t  if (oneof->regexp.oneof.regexps_num <= 1\n-\t      || regexp->regexp.allof.regexps_num <= 1)\n+\t  if (REGEXP_ONEOF (oneof)->regexps_num <= 1\n+\t      || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t)\n-\t\t\t\t* (oneof->regexp.oneof.regexps_num - 1));\n+\t\t\t\t* (REGEXP_ONEOF (oneof)->regexps_num - 1));\n \t  result->mode = rm_oneof;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.oneof.regexps_num = oneof->regexp.oneof.regexps_num;\n-\t  for (i = 0; i < result->regexp.oneof.regexps_num; i++)\n+\t  REGEXP_ONEOF (result)->regexps_num\n+\t    = REGEXP_ONEOF (oneof)->regexps_num;\n+\t  for (i = 0; i < REGEXP_ONEOF (result)->regexps_num; i++)\n \t    {\n \t      allof\n \t\t= create_node (sizeof (struct regexp)\n                                + sizeof (regexp_t)\n-\t\t\t       * (regexp->regexp.allof.regexps_num - 1));\n+\t\t\t       * (REGEXP_ALLOF (regexp)->regexps_num - 1));\n \t      allof->mode = rm_allof;\n \t      allof->pos = regexp->pos;\n-\t      allof->regexp.allof.regexps_num\n-                = regexp->regexp.allof.regexps_num;\n-              result->regexp.oneof.regexps [i] = allof;\n-\t      for (j = 0; j < allof->regexp.allof.regexps_num; j++)\n+\t      REGEXP_ALLOF (allof)->regexps_num\n+                = REGEXP_ALLOF (regexp)->regexps_num;\n+              REGEXP_ONEOF (result)->regexps [i] = allof;\n+\t      for (j = 0; j < REGEXP_ALLOF (allof)->regexps_num; j++)\n \t\tif (j != oneof_index)\n-\t\t  allof->regexp.allof.regexps [j]\n-\t\t    = copy_insn_regexp (regexp->regexp.allof.regexps [j]);\n+\t\t  REGEXP_ALLOF (allof)->regexps [j]\n+\t\t    = copy_insn_regexp (REGEXP_ALLOF (regexp)->regexps [j]);\n \t\telse\n-\t\t  allof->regexp.allof.regexps [j]\n-\t\t    = copy_insn_regexp (oneof->regexp.oneof.regexps [i]);\n+\t\t  REGEXP_ALLOF (allof)->regexps [j]\n+\t\t    = copy_insn_regexp (REGEXP_ONEOF (oneof)->regexps [i]);\n \t    }\n \t  regexp_transformed_p = 1;\n \t  regexp = result;\n \t}\n       max_seq_length = 0;\n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-\tif (regexp->regexp.allof.regexps [i]->mode == rm_sequence)\n-\t  {\n-\t    seq = regexp->regexp.allof.regexps [i];\n-\t    if (max_seq_length < seq->regexp.sequence.regexps_num)\n-\t      max_seq_length = seq->regexp.sequence.regexps_num;\n-\t  }\n-\telse if (regexp->regexp.allof.regexps [i]->mode != rm_unit)\n-\t  {\n-\t    max_seq_length = 0;\n-\t    break;\n-\t  }\n+      if (regexp->mode == rm_allof)\n+\tfor (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+\t  if (REGEXP_ALLOF (regexp)->regexps [i]->mode == rm_sequence)\n+\t    {\n+\t      seq = REGEXP_ALLOF (regexp)->regexps [i];\n+\t      if (max_seq_length < REGEXP_SEQUENCE (seq)->regexps_num)\n+\t      max_seq_length = REGEXP_SEQUENCE (seq)->regexps_num;\n+\t    }\n+\t  else if (REGEXP_ALLOF (regexp)->regexps [i]->mode != rm_unit)\n+\t    {\n+\t      max_seq_length = 0;\n+\t      break;\n+\t    }\n       if (max_seq_length != 0)\n \t{\n-\t  if (max_seq_length == 1 || regexp->regexp.allof.regexps_num <= 1)\n+\t  if (max_seq_length == 1 || REGEXP_ALLOF (regexp)->regexps_num <= 1)\n \t    abort ();\n \t  result = create_node (sizeof (struct regexp)\n \t\t\t\t+ sizeof (regexp_t) * (max_seq_length - 1));\n \t  result->mode = rm_sequence;\n \t  result->pos = regexp->pos;\n-\t  result->regexp.sequence.regexps_num = max_seq_length;\n+\t  REGEXP_SEQUENCE (result)->regexps_num = max_seq_length;\n \t  for (i = 0; i < max_seq_length; i++)\n \t    {\n \t      allof_length = 0;\n-\t      for (j = 0; j < regexp->regexp.allof.regexps_num; j++)\n-\t\tif (regexp->regexp.allof.regexps [j]->mode == rm_sequence\n-\t\t    && (i < (regexp->regexp.allof.regexps [j]\n-\t\t\t     ->regexp.sequence.regexps_num)))\n+\t      for (j = 0; j < REGEXP_ALLOF (regexp)->regexps_num; j++)\n+\t\tif (REGEXP_ALLOF (regexp)->regexps [j]->mode == rm_sequence\n+\t\t    && (i < (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t      ->regexps [j])->regexps_num)))\n \t\t  {\n-\t\t    allof_op = (regexp->regexp.allof.regexps [j]\n-\t\t\t\t->regexp.sequence.regexps [i]);\n+\t\t    allof_op\n+\t\t      = (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)->regexps [j])\n+\t\t\t ->regexps [i]);\n \t\t    allof_length++;\n \t\t  }\n \t\telse if (i == 0\n-\t\t\t && regexp->regexp.allof.regexps [j]->mode == rm_unit)\n+\t\t\t && (REGEXP_ALLOF (regexp)->regexps [j]->mode\n+\t\t\t     == rm_unit))\n \t\t  {\n-\t\t    allof_op = regexp->regexp.allof.regexps [j];\n+\t\t    allof_op = REGEXP_ALLOF (regexp)->regexps [j];\n \t\t    allof_length++;\n \t\t  }\n \t      if (allof_length == 1)\n-\t\tresult->regexp.sequence.regexps [i] = allof_op;\n+\t\tREGEXP_SEQUENCE (result)->regexps [i] = allof_op;\n \t      else\n \t\t{\n \t\t  allof = create_node (sizeof (struct regexp)\n \t\t\t\t       + sizeof (regexp_t)\n \t\t\t\t       * (allof_length - 1));\n \t\t  allof->mode = rm_allof;\n \t\t  allof->pos = regexp->pos;\n-\t\t  allof->regexp.allof.regexps_num = allof_length;\n-\t\t  result->regexp.sequence.regexps [i] = allof;\n+\t\t  REGEXP_ALLOF (allof)->regexps_num = allof_length;\n+\t\t  REGEXP_SEQUENCE (result)->regexps [i] = allof;\n \t\t  allof_length = 0;\n-\t\t  for (j = 0; j < regexp->regexp.allof.regexps_num; j++)\n-\t\t    if (regexp->regexp.allof.regexps [j]->mode == rm_sequence\n-\t\t\t&& (i < (regexp->regexp.allof.regexps [j]\n-\t\t\t\t ->regexp.sequence.regexps_num)))\n+\t\t  for (j = 0; j < REGEXP_ALLOF (regexp)->regexps_num; j++)\n+\t\t    if (REGEXP_ALLOF (regexp)->regexps [j]->mode == rm_sequence\n+\t\t\t&& (i <\n+\t\t\t    (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t      ->regexps [j])->regexps_num)))\n \t\t      {\n-\t\t\tallof_op = (regexp->regexp.allof.regexps [j]\n-\t\t\t\t    ->regexp.sequence.regexps [i]);\n-\t\t\tallof->regexp.allof.regexps [allof_length] = allof_op;\n-\t\t\t\n+\t\t\tallof_op = (REGEXP_SEQUENCE (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t\t     ->regexps [j])\n+\t\t\t\t    ->regexps [i]);\n+\t\t\tREGEXP_ALLOF (allof)->regexps [allof_length]\n+\t\t\t  = allof_op;\n \t\t\tallof_length++;\n \t\t      }\n \t\t    else if (i == 0\n-\t\t\t     && (regexp->regexp.allof.regexps [j]->mode\n+\t\t\t     && (REGEXP_ALLOF (regexp)->regexps [j]->mode\n \t\t\t\t == rm_unit))\n \t\t      {\n-\t\t\tallof_op = regexp->regexp.allof.regexps [j];\n-\t\t\tallof->regexp.allof.regexps [allof_length] = allof_op;\n+\t\t\tallof_op = REGEXP_ALLOF (regexp)->regexps [j];\n+\t\t\tREGEXP_ALLOF (allof)->regexps [allof_length]\n+\t\t\t  = allof_op;\n \t\t\tallof_length++;\n \t\t      }\n \t\t}\n@@ -4845,20 +5086,20 @@ regexp_transform_func (regexp, func)\n   int i;\n \n   if (regexp->mode == rm_sequence)\n-    for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n-      regexp->regexp.sequence.regexps [i]\n-\t= regexp_transform_func (regexp->regexp.sequence.regexps [i], func);\n+    for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n+      REGEXP_SEQUENCE (regexp)->regexps [i]\n+\t= regexp_transform_func (REGEXP_SEQUENCE (regexp)->regexps [i], func);\n   else if (regexp->mode == rm_allof)\n-    for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n-      regexp->regexp.allof.regexps [i]\n-\t= regexp_transform_func (regexp->regexp.allof.regexps [i], func);\n+    for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n+      REGEXP_ALLOF (regexp)->regexps [i]\n+\t= regexp_transform_func (REGEXP_ALLOF (regexp)->regexps [i], func);\n   else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n-      regexp->regexp.oneof.regexps [i]\n-\t= regexp_transform_func (regexp->regexp.oneof.regexps [i], func);\n+    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n+      REGEXP_ONEOF (regexp)->regexps [i]\n+\t= regexp_transform_func (REGEXP_ONEOF (regexp)->regexps [i], func);\n   else if (regexp->mode == rm_repeat)\n-    regexp->regexp.repeat.regexp\n-      = regexp_transform_func (regexp->regexp.repeat.regexp, func);\n+    REGEXP_REPEAT (regexp)->regexp\n+      = regexp_transform_func (REGEXP_REPEAT (regexp)->regexp, func);\n   else if (regexp->mode != rm_nothing && regexp->mode != rm_unit)\n     abort ();\n   return (*func) (regexp);\n@@ -4897,9 +5138,9 @@ transform_insn_regexps ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n-\tdecl->decl.insn_reserv.transformed_regexp\n+\tDECL_INSN_RESERV (decl)->transformed_regexp\n \t  = transform_regexp (copy_insn_regexp\n-\t\t\t      (decl->decl.insn_reserv.regexp));\n+\t\t\t      (DECL_INSN_RESERV (decl)->regexp));\n     }\n   fprintf (stderr, \"done\\n\");\n   ticker_off (&transform_time);\n@@ -4929,42 +5170,43 @@ process_unit_to_form_the_same_automaton_unit_lists (unit, regexp, cycle)\n \n   if (regexp == NULL || regexp->mode != rm_oneof)\n     abort ();\n-  unit_decl = unit->regexp.unit.unit_decl;\n-  for (i = regexp->regexp.oneof.regexps_num - 1; i >= 0; i--)\n+  unit_decl = REGEXP_UNIT (unit)->unit_decl;\n+  for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n-      seq = regexp->regexp.oneof.regexps [i];\n+      seq = REGEXP_ONEOF (regexp)->regexps [i];\n       if (seq->mode == rm_sequence)\n \t{\n-\t  if (cycle >= seq->regexp.sequence.regexps_num)\n+\t  if (cycle >= REGEXP_SEQUENCE (seq)->regexps_num)\n \t    break;\n-\t  allof = seq->regexp.sequence.regexps [cycle];\n+\t  allof = REGEXP_SEQUENCE (seq)->regexps [cycle];\n \t  if (allof->mode == rm_allof)\n \t    {\n-\t      for (k = 0; k < allof->regexp.allof.regexps_num; k++)\n-\t\tif (allof->regexp.allof.regexps [k]->mode == rm_unit\n-\t\t    && (allof->regexp.allof.regexps [k]->regexp.unit.unit_decl\n-\t\t\t== unit_decl))\n+\t      for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n+\t\tif (REGEXP_ALLOF (allof)->regexps [k]->mode == rm_unit\n+\t\t    && (REGEXP_UNIT (REGEXP_ALLOF (allof)->regexps [k])\n+\t\t\t->unit_decl == unit_decl))\n \t\t  break;\n-\t      if (k >= allof->regexp.allof.regexps_num)\n+\t      if (k >= REGEXP_ALLOF (allof)->regexps_num)\n \t\tbreak;\n \t    }\n \t  else if (allof->mode == rm_unit\n-\t\t   && allof->regexp.unit.unit_decl != unit_decl)\n+\t\t   && REGEXP_UNIT (allof)->unit_decl != unit_decl)\n \t    break;\n \t}\n       else if (cycle != 0)\n \tbreak;\n       else if (seq->mode == rm_allof)\n \t{\n-\t  for (k = 0; k < seq->regexp.allof.regexps_num; k++)\n-\t    if (seq->regexp.allof.regexps [k]->mode == rm_unit\n-\t\t&& (seq->regexp.allof.regexps [k]->regexp.unit.unit_decl\n+\t  for (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n+\t    if (REGEXP_ALLOF (seq)->regexps [k]->mode == rm_unit\n+\t\t&& (REGEXP_UNIT (REGEXP_ALLOF (seq)->regexps [k])->unit_decl\n \t\t    == unit_decl))\n \t      break;\n-\t  if (k >= seq->regexp.allof.regexps_num)\n+\t  if (k >= REGEXP_ALLOF (seq)->regexps_num)\n \t    break;\n \t}\n-      else if (seq->mode == rm_unit && seq->regexp.unit.unit_decl != unit_decl)\n+      else if (seq->mode == rm_unit\n+\t       && REGEXP_UNIT (seq)->unit_decl != unit_decl)\n \tbreak;\n     }\n   if (i >= 0)\n@@ -5002,17 +5244,17 @@ form_the_same_automaton_unit_lists_from_regexp (regexp)\n     return;\n   for (i = 0; i < description->max_insn_reserv_cycles; i++)\n     the_same_automaton_lists [i] = NULL;\n-  for (i = regexp->regexp.oneof.regexps_num - 1; i >= 0; i--)\n+  for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n     {\n-      seq = regexp->regexp.oneof.regexps [i];\n+      seq = REGEXP_ONEOF (regexp)->regexps [i];\n       if (seq->mode == rm_sequence)\n-\tfor (j = 0; j < seq->regexp.sequence.regexps_num; j++)\n+\tfor (j = 0; j < REGEXP_SEQUENCE (seq)->regexps_num; j++)\n \t  {\n-\t    allof = seq->regexp.sequence.regexps [j];\n+\t    allof = REGEXP_SEQUENCE (seq)->regexps [j];\n \t    if (allof->mode == rm_allof)\n-\t      for (k = 0; k < allof->regexp.allof.regexps_num; k++)\n+\t      for (k = 0; k < REGEXP_ALLOF (allof)->regexps_num; k++)\n \t\t{\n-\t\t  unit = allof->regexp.allof.regexps [k];\n+\t\t  unit = REGEXP_ALLOF (allof)->regexps [k];\n \t\t  if (unit->mode == rm_unit)\n \t\t    process_unit_to_form_the_same_automaton_unit_lists\n \t\t      (unit, regexp, j);\n@@ -5026,9 +5268,9 @@ form_the_same_automaton_unit_lists_from_regexp (regexp)\n \t      abort ();\n \t  }\n       else if (seq->mode == rm_allof)\n-\tfor (k = 0; k < seq->regexp.allof.regexps_num; k++)\n+\tfor (k = 0; k < REGEXP_ALLOF (seq)->regexps_num; k++)\n \t  {\n-\t    unit = seq->regexp.allof.regexps [k];\n+\t    unit = REGEXP_ALLOF (seq)->regexps [k];\n \t    if (unit->mode == rm_unit)\n \t      process_unit_to_form_the_same_automaton_unit_lists\n \t\t(unit, regexp, 0);\n@@ -5060,16 +5302,16 @@ form_the_same_automaton_unit_lists ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  decl->decl.unit.the_same_automaton_message_reported_p = FALSE;\n-\t  decl->decl.unit.the_same_automaton_unit = &decl->decl.unit;\n+\t  DECL_UNIT (decl)->the_same_automaton_message_reported_p = FALSE;\n+\t  DECL_UNIT (decl)->the_same_automaton_unit = DECL_UNIT (decl);\n \t}\n     }\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n \tform_the_same_automaton_unit_lists_from_regexp\n-\t  (decl->decl.insn_reserv.transformed_regexp);\n+\t  (DECL_INSN_RESERV (decl)->transformed_regexp);\n     }\n   free (the_same_automaton_lists);\n }\n@@ -5089,7 +5331,7 @@ check_unit_distributions_to_automata ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  start_unit_decl = &decl->decl.unit;\n+\t  start_unit_decl = DECL_UNIT (decl);\n \t  if (!start_unit_decl->the_same_automaton_message_reported_p)\n \t    for (unit_decl = start_unit_decl->the_same_automaton_unit;\n \t\t unit_decl != start_unit_decl;\n@@ -5131,30 +5373,30 @@ process_seq_for_forming_states (regexp, automaton, curr_cycle)\n     return curr_cycle;\n   else if (regexp->mode == rm_unit)\n     {\n-      if (regexp->regexp.unit.unit_decl->corresponding_automaton_num\n+      if (REGEXP_UNIT (regexp)->unit_decl->corresponding_automaton_num\n           == automaton->automaton_order_num)\n         set_state_reserv (state_being_formed, curr_cycle,\n-                          regexp->regexp.unit.unit_decl->unit_num);\n+                          REGEXP_UNIT (regexp)->unit_decl->unit_num);\n       return curr_cycle;\n     }\n   else if (regexp->mode == rm_sequence)\n     {\n-      for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n+      for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n \tcurr_cycle\n \t  = process_seq_for_forming_states\n-\t    (regexp->regexp.sequence.regexps [i], automaton, curr_cycle) + 1;\n+\t    (REGEXP_SEQUENCE (regexp)->regexps [i], automaton, curr_cycle) + 1;\n       return curr_cycle;\n     }\n   else if (regexp->mode == rm_allof)\n     {\n       int finish_cycle = 0;\n       int cycle;\n \n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t{\n-\t  cycle\n-            = process_seq_for_forming_states (regexp->regexp.allof.regexps [i],\n-                                              automaton, curr_cycle);\n+\t  cycle = process_seq_for_forming_states (REGEXP_ALLOF (regexp)\n+\t\t\t\t\t\t  ->regexps [i],\n+\t\t\t\t\t\t  automaton, curr_cycle);\n \t  if (finish_cycle < cycle)\n \t    finish_cycle = cycle;\n \t}\n@@ -5222,8 +5464,8 @@ process_alts_for_forming_states (regexp, automaton, inside_oneof_p)\n       /* We processes it in reverse order to get list with the same\n \t order as in the description.  See also the previous\n \t commentary.  */\n-      for (i = regexp->regexp.oneof.regexps_num - 1; i >= 0; i--)\n-\tprocess_alts_for_forming_states (regexp->regexp.oneof.regexps [i],\n+      for (i = REGEXP_ONEOF (regexp)->regexps_num - 1; i >= 0; i--)\n+\tprocess_alts_for_forming_states (REGEXP_ONEOF (regexp)->regexps [i],\n \t\t\t\t\t automaton, 1);\n     }\n }\n@@ -5240,7 +5482,7 @@ create_alt_states (automaton)\n        curr_ainsn = curr_ainsn->next_ainsn)\n     {\n       reserv_decl = curr_ainsn->insn_reserv_decl;\n-      if (reserv_decl != &advance_cycle_insn_decl->decl.insn_reserv)\n+      if (reserv_decl != DECL_INSN_RESERV (advance_cycle_insn_decl))\n         {\n           curr_ainsn->alt_states = NULL;\n           process_alts_for_forming_states (reserv_decl->transformed_regexp,\n@@ -5273,7 +5515,7 @@ form_ainsn_with_same_reservs (automaton)\n        curr_ainsn != NULL;\n        curr_ainsn = curr_ainsn->next_ainsn)\n     if (curr_ainsn->insn_reserv_decl\n-\t== &advance_cycle_insn_decl->decl.insn_reserv)\n+\t== DECL_INSN_RESERV (advance_cycle_insn_decl))\n       {\n         curr_ainsn->next_same_reservs_insn = NULL;\n         curr_ainsn->first_insn_with_same_reservs = 1;\n@@ -5337,7 +5579,7 @@ make_automaton (automaton)\n         if (ainsn->first_insn_with_same_reservs)\n           {\n             insn_reserv_decl = ainsn->insn_reserv_decl;\n-            if (insn_reserv_decl != &advance_cycle_insn_decl->decl.insn_reserv)\n+            if (insn_reserv_decl != DECL_INSN_RESERV (advance_cycle_insn_decl))\n               {\n \t\t/* We process alt_states in the same order as they are\n                    present in the description.  */\n@@ -5404,7 +5646,7 @@ form_arcs_marked_by_insn (state)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n-\tdecl->decl.insn_reserv.arcs_marked_by_insn = NULL;\n+\tDECL_INSN_RESERV (decl)->arcs_marked_by_insn = NULL;\n     }\n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     {\n@@ -5536,7 +5778,7 @@ NDFA_to_DFA (automaton)\n \t  decl = description->decls [i];\n \t  if (decl->mode == dm_insn_reserv)\n \t    create_composed_state\n-              (state, decl->decl.insn_reserv.arcs_marked_by_insn,\n+              (state, DECL_INSN_RESERV (decl)->arcs_marked_by_insn,\n \t       &state_stack);\n \t}\n     }\n@@ -5917,7 +6159,7 @@ set_new_cycle_flags (state)\n \n   for (arc = first_out_arc (state); arc != NULL; arc = next_out_arc (arc))\n     if (arc->insn->insn_reserv_decl\n-\t== &advance_cycle_insn_decl->decl.insn_reserv)\n+\t== DECL_INSN_RESERV (advance_cycle_insn_decl))\n       arc->to_state->new_cycle_p = 1;\n }\n \n@@ -6207,7 +6449,7 @@ estimate_one_automaton_bound ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  root_value = exp (log (decl->decl.unit.max_occ_cycle_num + 1.0)\n+\t  root_value = exp (log (DECL_UNIT (decl)->max_occ_cycle_num + 1.0)\n                             / automata_num);\n \t  if (MAX_FLOATING_POINT_VALUE_FOR_AUTOMATON_BOUND / root_value\n \t      > one_automaton_estimation_bound)\n@@ -6224,11 +6466,11 @@ compare_max_occ_cycle_nums (unit_decl_1, unit_decl_2)\n      const void *unit_decl_1;\n      const void *unit_decl_2;\n {\n-  if (((*(decl_t *) unit_decl_1)->decl.unit.max_occ_cycle_num)\n-      < ((*(decl_t *) unit_decl_2)->decl.unit.max_occ_cycle_num))\n+  if ((DECL_UNIT (*(decl_t *) unit_decl_1)->max_occ_cycle_num)\n+      < (DECL_UNIT (*(decl_t *) unit_decl_2)->max_occ_cycle_num))\n     return 1;\n-  else if (((*(decl_t *) unit_decl_1)->decl.unit.max_occ_cycle_num)\n-\t   == ((*(decl_t *) unit_decl_2)->decl.unit.max_occ_cycle_num))\n+  else if ((DECL_UNIT (*(decl_t *) unit_decl_1)->max_occ_cycle_num)\n+\t   == (DECL_UNIT (*(decl_t *) unit_decl_2)->max_occ_cycle_num))\n     return 0;\n   else\n     return -1;\n@@ -6262,8 +6504,8 @@ units_to_automata_heuristic_distr ()\n          sizeof (decl_t), compare_max_occ_cycle_nums);\n   automaton_num = 0;\n   unit_decl_ptr = VLA_PTR_BEGIN (unit_decls);\n-  bound_value = (*unit_decl_ptr)->decl.unit.max_occ_cycle_num;\n-  (*unit_decl_ptr)->decl.unit.corresponding_automaton_num = automaton_num;\n+  bound_value = DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n+  DECL_UNIT (*unit_decl_ptr)->corresponding_automaton_num = automaton_num;\n   for (unit_decl_ptr++;\n        unit_decl_ptr <= (decl_t *) VLA_PTR_LAST (unit_decls);\n        unit_decl_ptr++)\n@@ -6276,14 +6518,14 @@ units_to_automata_heuristic_distr ()\n           && ((automata_num - automaton_num - 1 == rest_units_num)\n               || (bound_value\n                   > (estimation_bound\n-\t\t     / ((*unit_decl_ptr)->decl.unit.max_occ_cycle_num)))))\n+\t\t     / (DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num)))))\n         {\n-          bound_value = (*unit_decl_ptr)->decl.unit.max_occ_cycle_num;\n+          bound_value = DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n           automaton_num++;\n         }\n       else\n-        bound_value *= (*unit_decl_ptr)->decl.unit.max_occ_cycle_num;\n-      (*unit_decl_ptr)->decl.unit.corresponding_automaton_num = automaton_num;\n+        bound_value *= DECL_UNIT (*unit_decl_ptr)->max_occ_cycle_num;\n+      DECL_UNIT (*unit_decl_ptr)->corresponding_automaton_num = automaton_num;\n     }\n   if (automaton_num != automata_num - 1)\n     abort ();\n@@ -6310,7 +6552,7 @@ create_ainsns ()\n       if (decl->mode == dm_insn_reserv)\n \t{\n \t  curr_ainsn = create_node (sizeof (struct ainsn));\n-\t  curr_ainsn->insn_reserv_decl = &decl->decl.insn_reserv;\n+\t  curr_ainsn->insn_reserv_decl = DECL_INSN_RESERV (decl);\n \t  curr_ainsn->important_p = FALSE;\n \t  curr_ainsn->next_ainsn = NULL;\n \t  if (prev_ainsn == NULL)\n@@ -6336,14 +6578,14 @@ units_to_automata_distr ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  if (decl->decl.unit.automaton_decl == NULL\n-\t      || (decl->decl.unit.automaton_decl->corresponding_automaton\n+\t  if (DECL_UNIT (decl)->automaton_decl == NULL\n+\t      || (DECL_UNIT (decl)->automaton_decl->corresponding_automaton\n \t\t  == NULL))\n \t    /* Distribute to the first automaton.  */\n-\t    decl->decl.unit.corresponding_automaton_num = 0;\n+\t    DECL_UNIT (decl)->corresponding_automaton_num = 0;\n \t  else\n-\t    decl->decl.unit.corresponding_automaton_num\n-\t      = (decl->decl.unit.automaton_decl\n+\t    DECL_UNIT (decl)->corresponding_automaton_num\n+\t      = (DECL_UNIT (decl)->automaton_decl\n                  ->corresponding_automaton->automaton_order_num);\n \t}\n     }\n@@ -6386,14 +6628,14 @@ create_automata ()\n \t{\n \t  decl = description->decls [i];\n \t  if (decl->mode == dm_automaton\n-\t      && decl->decl.automaton.automaton_is_used)\n+\t      && DECL_AUTOMATON (decl)->automaton_is_used)\n \t    {\n \t      curr_automaton = create_node (sizeof (struct automaton));\n \t      curr_automaton->ainsn_list = create_ainsns ();\n \t      curr_automaton->corresponding_automaton_decl\n-\t\t= &decl->decl.automaton;\n+\t\t= DECL_AUTOMATON (decl);\n \t      curr_automaton->next_automaton = NULL;\n-\t      decl->decl.automaton.corresponding_automaton = curr_automaton;\n+\t      DECL_AUTOMATON (decl)->corresponding_automaton = curr_automaton;\n \t      curr_automaton->automaton_order_num = curr_automaton_num;\n \t      if (prev_automaton == NULL)\n \t\tdescription->first_automaton = curr_automaton;\n@@ -6459,60 +6701,60 @@ form_regexp (regexp)\n   if (regexp->mode == rm_unit || regexp->mode == rm_reserv)\n     {\n       const char *name = (regexp->mode == rm_unit\n-                          ? regexp->regexp.unit.name\n-\t\t\t  : regexp->regexp.reserv.name);\n+                          ? REGEXP_UNIT (regexp)->name\n+\t\t\t  : REGEXP_RESERV (regexp)->name);\n \n       obstack_grow (&irp, name, strlen (name));\n     }\n   else if (regexp->mode == rm_sequence)\n-    for (i = 0; i < regexp->regexp.sequence.regexps_num; i++)\n+    for (i = 0; i < REGEXP_SEQUENCE (regexp)->regexps_num; i++)\n       {\n \tif (i != 0)\n           obstack_1grow (&irp, ',');\n-\tform_regexp (regexp->regexp.sequence.regexps [i]);\n+\tform_regexp (REGEXP_SEQUENCE (regexp)->regexps [i]);\n       }\n   else if (regexp->mode == rm_allof)\n     {\n       obstack_1grow (&irp, '(');\n-      for (i = 0; i < regexp->regexp.allof.regexps_num; i++)\n+      for (i = 0; i < REGEXP_ALLOF (regexp)->regexps_num; i++)\n \t{\n \t  if (i != 0)\n             obstack_1grow (&irp, '+');\n-\t  if (regexp->regexp.allof.regexps[i]->mode == rm_sequence\n-              || regexp->regexp.oneof.regexps[i]->mode == rm_oneof)\n+\t  if (REGEXP_ALLOF (regexp)->regexps[i]->mode == rm_sequence\n+              || REGEXP_ALLOF (regexp)->regexps[i]->mode == rm_oneof)\n             obstack_1grow (&irp, '(');\n-\t  form_regexp (regexp->regexp.allof.regexps [i]);\n-\t  if (regexp->regexp.allof.regexps[i]->mode == rm_sequence\n-              || regexp->regexp.oneof.regexps[i]->mode == rm_oneof)\n+\t  form_regexp (REGEXP_ALLOF (regexp)->regexps [i]);\n+\t  if (REGEXP_ALLOF (regexp)->regexps[i]->mode == rm_sequence\n+              || REGEXP_ALLOF (regexp)->regexps[i]->mode == rm_oneof)\n             obstack_1grow (&irp, ')');\n         }\n       obstack_1grow (&irp, ')');\n     }\n   else if (regexp->mode == rm_oneof)\n-    for (i = 0; i < regexp->regexp.oneof.regexps_num; i++)\n+    for (i = 0; i < REGEXP_ONEOF (regexp)->regexps_num; i++)\n       {\n \tif (i != 0)\n           obstack_1grow (&irp, '|');\n-\tif (regexp->regexp.oneof.regexps[i]->mode == rm_sequence)\n+\tif (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n           obstack_1grow (&irp, '(');\n-        form_regexp (regexp->regexp.oneof.regexps [i]);\n-\tif (regexp->regexp.oneof.regexps[i]->mode == rm_sequence)\n+        form_regexp (REGEXP_ONEOF (regexp)->regexps [i]);\n+\tif (REGEXP_ONEOF (regexp)->regexps[i]->mode == rm_sequence)\n           obstack_1grow (&irp, ')');\n       }\n   else if (regexp->mode == rm_repeat)\n     {\n       char digits [30];\n \n-      if (regexp->regexp.repeat.regexp->mode == rm_sequence\n-\t  || regexp->regexp.repeat.regexp->mode == rm_allof\n-\t  || regexp->regexp.repeat.regexp->mode == rm_oneof)\n+      if (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n+\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n+\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n         obstack_1grow (&irp, '(');\n-      form_regexp (regexp->regexp.repeat.regexp);\n-      if (regexp->regexp.repeat.regexp->mode == rm_sequence\n-\t  || regexp->regexp.repeat.regexp->mode == rm_allof\n-\t  || regexp->regexp.repeat.regexp->mode == rm_oneof)\n+      form_regexp (REGEXP_REPEAT (regexp)->regexp);\n+      if (REGEXP_REPEAT (regexp)->regexp->mode == rm_sequence\n+\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_allof\n+\t  || REGEXP_REPEAT (regexp)->regexp->mode == rm_oneof)\n         obstack_1grow (&irp, ')');\n-      sprintf (digits, \"*%d\", regexp->regexp.repeat.repeat_num);\n+      sprintf (digits, \"*%d\", REGEXP_REPEAT (regexp)->repeat_num);\n       obstack_grow (&irp, digits, strlen (digits));\n     }\n   else if (regexp->mode == rm_nothing)\n@@ -6602,7 +6844,7 @@ longest_path_length (state)\n     /* Ignore cycles containing one state and `cycle advance' arcs.  */\n     if (arc->to_state != state\n \t&& (arc->insn->insn_reserv_decl\n-\t    != &advance_cycle_insn_decl->decl.insn_reserv))\n+\t    != DECL_INSN_RESERV (advance_cycle_insn_decl)))\n     {\n       length = longest_path_length (arc->to_state);\n       if (length > result)\n@@ -7457,7 +7699,7 @@ min_issue_delay_pass_states (state, ainsn)\n \tif (insn_issue_delay != -1)\n \t  {\n \t    if (arc->insn->insn_reserv_decl\n-\t\t== &advance_cycle_insn_decl->decl.insn_reserv)\n+\t\t== DECL_INSN_RESERV (advance_cycle_insn_decl))\n \t      insn_issue_delay++;\n \t    if (min_insn_issue_delay == -1\n \t\t|| min_insn_issue_delay > insn_issue_delay)\n@@ -7614,7 +7856,7 @@ output_dead_lock_vect (automaton)\n       VLA_HWINT (dead_lock_vect, (*state_ptr)->order_state_num)\n         = (next_out_arc (arc) == NULL\n            && (arc->insn->insn_reserv_decl\n-               == &advance_cycle_insn_decl->decl.insn_reserv) ? 1 : 0);\n+               == DECL_INSN_RESERV (advance_cycle_insn_decl)) ? 1 : 0);\n #ifndef NDEBUG\n       if (VLA_HWINT (dead_lock_vect, (*state_ptr)->order_state_num))\n         locked_states_num++;\n@@ -7715,7 +7957,7 @@ output_tables ()\n \t}\n     }\n   fprintf (output_file, \"\\n#define %s %d\\n\\n\", ADVANCE_CYCLE_VALUE_NAME,\n-           advance_cycle_insn_decl->decl.insn_reserv.insn_num);\n+           DECL_INSN_RESERV (advance_cycle_insn_decl)->insn_num);\n }\n \n /* The function outputs definition and value of PHR interface variable\n@@ -7739,35 +7981,36 @@ static void\n output_insn_code_cases (output_automata_list_code)\n      void (*output_automata_list_code) (automata_list_el_t);\n {\n-  decl_t decl, decl_2;\n+  decl_t decl, decl2;\n   int i, j;\n \n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv)\n-\tdecl->decl.insn_reserv.processed_p = FALSE;\n+\tDECL_INSN_RESERV (decl)->processed_p = FALSE;\n     }\n   for (i = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n-      if (decl->mode == dm_insn_reserv && !decl->decl.insn_reserv.processed_p)\n+      if (decl->mode == dm_insn_reserv\n+\t  && !DECL_INSN_RESERV (decl)->processed_p)\n \t{\n \t  for (j = i; j < description->decls_num; j++)\n \t    {\n-\t      decl_2 = description->decls [j];\n-\t      if (decl_2->mode == dm_insn_reserv\n-\t\t  && (decl_2->decl.insn_reserv.important_automata_list\n-\t\t      == decl->decl.insn_reserv.important_automata_list))\n+\t      decl2 = description->decls [j];\n+\t      if (decl2->mode == dm_insn_reserv\n+\t\t  && (DECL_INSN_RESERV (decl2)->important_automata_list\n+\t\t      == DECL_INSN_RESERV (decl)->important_automata_list))\n \t\t{\n-\t\t  decl_2->decl.insn_reserv.processed_p = TRUE;\n+\t\t  DECL_INSN_RESERV (decl2)->processed_p = TRUE;\n \t\t  fprintf (output_file, \"    case %d: /* %s */\\n\",\n-\t\t\t   decl_2->decl.insn_reserv.insn_num,\n-\t\t\t   decl_2->decl.insn_reserv.name);\n+\t\t\t   DECL_INSN_RESERV (decl2)->insn_num,\n+\t\t\t   DECL_INSN_RESERV (decl2)->name);\n \t\t}\n \t    }\n \t  (*output_automata_list_code)\n-\t    (decl->decl.insn_reserv.important_automata_list);\n+\t    (DECL_INSN_RESERV (decl)->important_automata_list);\n \t}\n     }\n }\n@@ -8278,16 +8521,16 @@ output_internal_insn_latency_func ()\n       if (decl->mode == dm_insn_reserv)\n \t{\n \t  fprintf (output_file, \"    case %d:\\n\",\n-\t\t   decl->decl.insn_reserv.insn_num);\n-\t  if (decl->decl.insn_reserv.bypass_list == NULL)\n+\t\t   DECL_INSN_RESERV (decl)->insn_num);\n+\t  if (DECL_INSN_RESERV (decl)->bypass_list == NULL)\n \t    fprintf (output_file, \"      return (%s != %s ? %d : 0);\\n\",\n \t\t     INTERNAL_INSN2_CODE_NAME, ADVANCE_CYCLE_VALUE_NAME,\n-\t\t     decl->decl.insn_reserv.default_latency);\n+\t\t     DECL_INSN_RESERV (decl)->default_latency);\n \t  else\n \t    {\n \t      fprintf (output_file, \"      switch (%s)\\n        {\\n\",\n \t\t       INTERNAL_INSN2_CODE_NAME);\n-\t      for (bypass = decl->decl.insn_reserv.bypass_list;\n+\t      for (bypass = DECL_INSN_RESERV (decl)->bypass_list;\n \t\t   bypass != NULL;\n \t\t   bypass = bypass->next)\n \t\t{\n@@ -8301,13 +8544,13 @@ output_internal_insn_latency_func ()\n \t\t\t     \"          return (%s (%s, %s) ? %d : %d);\\n\",\n \t\t\t     bypass->bypass_guard_name, INSN_PARAMETER_NAME,\n \t\t\t     INSN2_PARAMETER_NAME, bypass->latency,\n-\t\t\t     decl->decl.insn_reserv.default_latency);\n+\t\t\t     DECL_INSN_RESERV (decl)->default_latency);\n \t\t}\n \t      fprintf (output_file, \"        default:\\n\");\n \t      fprintf (output_file,\n \t\t       \"          return (%s != %s ? %d : 0);\\n        }\\n\",\n \t\t       INTERNAL_INSN2_CODE_NAME, ADVANCE_CYCLE_VALUE_NAME,\n-\t\t       decl->decl.insn_reserv.default_latency);\n+\t\t       DECL_INSN_RESERV (decl)->default_latency);\n \t      \n \t    }\n \t}\n@@ -8366,11 +8609,11 @@ output_print_reservation_func ()\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n \t{\n           fprintf (output_file,\n-                   \"    case %d:\\n\", decl->decl.insn_reserv.insn_num);\n+                   \"    case %d:\\n\", DECL_INSN_RESERV (decl)->insn_num);\n           fprintf (output_file,\n                    \"      fprintf (%s, \\\"%s\\\");\\n      break;\\n\",\n                    FILE_PARAMETER_NAME,\n-                   regexp_representation (decl->decl.insn_reserv.regexp));\n+                   regexp_representation (DECL_INSN_RESERV (decl)->regexp));\n           finish_regexp_representation ();\n         }\n     }\n@@ -8557,25 +8800,25 @@ output_description ()\n       decl = description->decls [i];\n       if (decl->mode == dm_unit)\n \t{\n-\t  if (decl->decl.unit.excl_list != NULL)\n+\t  if (DECL_UNIT (decl)->excl_list != NULL)\n \t    {\n \t      fprintf (output_description_file, \"unit %s exlusion_set: \",\n-\t\t       decl->decl.unit.name);\n-\t      output_unit_set_el_list (decl->decl.unit.excl_list);\n+\t\t       DECL_UNIT (decl)->name);\n+\t      output_unit_set_el_list (DECL_UNIT (decl)->excl_list);\n \t      fprintf (output_description_file, \"\\n\");\n \t    }\n-\t  if (decl->decl.unit.presence_list != NULL)\n+\t  if (DECL_UNIT (decl)->presence_list != NULL)\n \t    {\n \t      fprintf (output_description_file, \"unit %s presence_set: \",\n-\t\t       decl->decl.unit.name);\n-\t      output_unit_set_el_list (decl->decl.unit.presence_list);\n+\t\t       DECL_UNIT (decl)->name);\n+\t      output_unit_set_el_list (DECL_UNIT (decl)->presence_list);\n \t      fprintf (output_description_file, \"\\n\");\n \t    }\n-\t  if (decl->decl.unit.absence_list != NULL)\n+\t  if (DECL_UNIT (decl)->absence_list != NULL)\n \t    {\n \t      fprintf (output_description_file, \"unit %s absence_set: \",\n-\t\t       decl->decl.unit.name);\n-\t      output_unit_set_el_list (decl->decl.unit.absence_list);\n+\t\t       DECL_UNIT (decl)->name);\n+\t      output_unit_set_el_list (DECL_UNIT (decl)->absence_list);\n \t      fprintf (output_description_file, \"\\n\");\n \t    }\n \t}\n@@ -8587,24 +8830,26 @@ output_description ()\n       if (decl->mode == dm_reserv)\n \t{\n           fprintf (output_description_file, \"reservation \");\n-          fprintf (output_description_file, decl->decl.reserv.name);\n+          fprintf (output_description_file, DECL_RESERV (decl)->name);\n           fprintf (output_description_file, \": \");\n-          output_regexp (decl->decl.reserv.regexp);\n+          output_regexp (DECL_RESERV (decl)->regexp);\n           fprintf (output_description_file, \"\\n\");\n         }\n       else if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n         {\n           fprintf (output_description_file, \"insn reservation %s \",\n-\t\t   decl->decl.insn_reserv.name);\n-          print_rtl (output_description_file, decl->decl.insn_reserv.condexp);\n+\t\t   DECL_INSN_RESERV (decl)->name);\n+          print_rtl (output_description_file,\n+\t\t     DECL_INSN_RESERV (decl)->condexp);\n           fprintf (output_description_file, \": \");\n-          output_regexp (decl->decl.insn_reserv.regexp);\n+          output_regexp (DECL_INSN_RESERV (decl)->regexp);\n           fprintf (output_description_file, \"\\n\");\n         }\n       else if (decl->mode == dm_bypass)\n \tfprintf (output_description_file, \"bypass %d %s %s\\n\",\n-\t\t decl->decl.bypass.latency, decl->decl.bypass.out_insn_name,\n-\t\t decl->decl.bypass.in_insn_name);\n+\t\t DECL_BYPASS (decl)->latency,\n+\t\t DECL_BYPASS (decl)->out_insn_name,\n+\t\t DECL_BYPASS (decl)->in_insn_name);\n     }\n   fprintf (output_description_file, \"\\n\\f\\n\");\n }\n@@ -8644,11 +8889,11 @@ output_automaton_units (automaton)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_unit\n-          && (decl->decl.unit.corresponding_automaton_num\n+          && (DECL_UNIT (decl)->corresponding_automaton_num\n \t      == automaton->automaton_order_num))\n \t{\n \t  there_is_an_automaton_unit = 1;\n-\t  name = decl->decl.unit.name;\n+\t  name = DECL_UNIT (decl)->name;\n \t  if (curr_line_length + strlen (name) + 1 > MAX_LINE_LENGTH )\n \t    {\n \t      curr_line_length = strlen (name) + 4;\n@@ -8953,8 +9198,8 @@ generate ()\n \n \f\n \n-/* The following function creates attribute which order number of insn\n-   in pipeline hazard description translator.  */\n+/* The following function creates insn attribute whose values are\n+   number alternatives in insn reservations.  */\n static void\n make_insn_alts_attr ()\n {\n@@ -8970,10 +9215,13 @@ make_insn_alts_attr ()\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n \t{\n-          XVECEXP (condexp, 0, 2 * insn_num) = decl->decl.insn_reserv.condexp;\n+          XVECEXP (condexp, 0, 2 * insn_num)\n+\t    = DECL_INSN_RESERV (decl)->condexp;\n           XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value (decl->decl.insn_reserv.transformed_regexp\n-\t\t\t\t  ->regexp.oneof.regexps_num);\n+            = make_numeric_value\n+\t      (DECL_INSN_RESERV (decl)->transformed_regexp->mode != rm_oneof\n+\t       ? 1 : REGEXP_ONEOF (DECL_INSN_RESERV (decl)\n+\t\t\t\t   ->transformed_regexp)->regexps_num);\n           insn_num++;\n         }\n     }\n@@ -8998,16 +9246,18 @@ make_internal_dfa_insn_code_attr ()\n \n   condexp = rtx_alloc (COND);\n   XVEC (condexp, 0) = rtvec_alloc ((description->insns_num - 1) * 2);\n-  XEXP (condexp, 1) = make_numeric_value (advance_cycle_insn_decl\n-\t\t\t\t\t  ->decl.insn_reserv.insn_num + 1);\n+  XEXP (condexp, 1)\n+    = make_numeric_value (DECL_INSN_RESERV (advance_cycle_insn_decl)\n+\t\t\t  ->insn_num + 1);\n   for (i = insn_num = 0; i < description->decls_num; i++)\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n \t{\n-          XVECEXP (condexp, 0, 2 * insn_num) = decl->decl.insn_reserv.condexp;\n+          XVECEXP (condexp, 0, 2 * insn_num)\n+\t    = DECL_INSN_RESERV (decl)->condexp;\n           XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value (decl->decl.insn_reserv.insn_num);\n+            = make_numeric_value (DECL_INSN_RESERV (decl)->insn_num);\n           insn_num++;\n         }\n     }\n@@ -9039,9 +9289,10 @@ make_default_insn_latency_attr ()\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv && decl != advance_cycle_insn_decl)\n \t{\n-          XVECEXP (condexp, 0, 2 * insn_num) = decl->decl.insn_reserv.condexp;\n+          XVECEXP (condexp, 0, 2 * insn_num)\n+\t    = DECL_INSN_RESERV (decl)->condexp;\n           XVECEXP (condexp, 0, 2 * insn_num + 1)\n-            = make_numeric_value (decl->decl.insn_reserv.default_latency);\n+            = make_numeric_value (DECL_INSN_RESERV (decl)->default_latency);\n           insn_num++;\n         }\n     }\n@@ -9069,8 +9320,8 @@ make_bypass_attr ()\n     {\n       decl = description->decls [i];\n       if (decl->mode == dm_insn_reserv\n-\t  && decl->decl.insn_reserv.condexp != NULL\n-\t  && decl->decl.insn_reserv.bypass_list != NULL)\n+\t  && DECL_INSN_RESERV (decl)->condexp != NULL\n+\t  && DECL_INSN_RESERV (decl)->bypass_list != NULL)\n \tbypass_insns_num++;\n     }\n   if (bypass_insns_num == 0)\n@@ -9085,11 +9336,11 @@ make_bypass_attr ()\n         {\n           decl = description->decls [i];\n           if (decl->mode == dm_insn_reserv\n-\t      && decl->decl.insn_reserv.condexp != NULL\n-\t      && decl->decl.insn_reserv.bypass_list != NULL)\n+\t      && DECL_INSN_RESERV (decl)->condexp != NULL\n+\t      && DECL_INSN_RESERV (decl)->bypass_list != NULL)\n \t    {\n               XVECEXP (result_rtx, 0, 2 * bypass_insn)\n-\t\t= decl->decl.insn_reserv.condexp;\n+\t\t= DECL_INSN_RESERV (decl)->condexp;\n               XVECEXP (result_rtx, 0, 2 * bypass_insn + 1)\n \t        = make_numeric_value (1);\n               bypass_insn++;\n@@ -9310,12 +9561,12 @@ form_important_insn_automata_lists ()\n \t\t ainsn != NULL;\n \t\t ainsn = ainsn->next_ainsn)\n \t      if (ainsn->important_p\n-\t\t  && ainsn->insn_reserv_decl == &decl->decl.insn_reserv)\n+\t\t  && ainsn->insn_reserv_decl == DECL_INSN_RESERV (decl))\n \t\t{\n \t\t  automata_list_add (automaton);\n \t\t  break;\n \t\t}\n-\t  decl->decl.insn_reserv.important_automata_list\n+\t  DECL_INSN_RESERV (decl)->important_automata_list\n \t    = automata_list_finish ();\n \t}\n     }\n@@ -9338,8 +9589,8 @@ expand_automata ()\n     {\n       description->decls [i] = VLA_PTR (decls, i);\n       if (description->decls [i]->mode == dm_unit\n-\t  && description->decls [i]->decl.unit.query_p)\n-        description->decls [i]->decl.unit.query_num\n+\t  && DECL_UNIT (description->decls [i])->query_p)\n+        DECL_UNIT (description->decls [i])->query_num\n \t  = description->query_units_num++;\n     }\n   all_time = create_ticker ();"}]}