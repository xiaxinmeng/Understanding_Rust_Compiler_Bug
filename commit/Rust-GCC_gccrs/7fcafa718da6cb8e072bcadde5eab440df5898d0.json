{"sha": "7fcafa718da6cb8e072bcadde5eab440df5898d0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2ZjYWZhNzE4ZGE2Y2I4ZTA3MmJjYWRkZTVlYWI0NDBkZjU4OThkMA==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-31T06:55:16Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2006-12-31T06:55:16Z"}, "message": "re PR fortran/23060 (%VAL, %REF and %DESCR constructs not implemented)\n\n2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23060\n\t* intrinsic.c (compare_actual_formal ): Distinguish argument\n\tlist functions from keywords.\n\t* intrinsic.c (sort_actual): If formal is NULL, the presence of\n\tan argument list function actual is an error.\n\t* trans-expr.c (conv_arglist_function) : New function to\n\timplement argument list functions %VAL, %REF and %LOC.\n\t(gfc_conv_function_call): Call it.\n\t* resolve.c (resolve_actual_arglist): Add arg ptype and check\n\targument list functions.\n\t(resolve_function, resolve_call): Set value of ptype before\n\tcalls to resolve_actual_arglist.\n\t* primary.c (match_arg_list_function): New function.\n\t(gfc_match_actual_arglist): Call it before trying for a\n\tkeyword argument.\n\n2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n\n\tPR fortran/23060\n\t* gfortran.dg/c_by_val.c: Called by c_by_val_1.f.\n\t* gfortran.dg/c_by_val_1.f: New test.\n\t* gfortran.dg/c_by_val_2.f: New test.\n\t* gfortran.dg/c_by_val_3.f: New test.\n\nFrom-SVN: r120295", "tree": {"sha": "6103da430695e877961c11f0de7a098d90d6f0c2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6103da430695e877961c11f0de7a098d90d6f0c2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7fcafa718da6cb8e072bcadde5eab440df5898d0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcafa718da6cb8e072bcadde5eab440df5898d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7fcafa718da6cb8e072bcadde5eab440df5898d0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7fcafa718da6cb8e072bcadde5eab440df5898d0/comments", "author": null, "committer": null, "parents": [{"sha": "e7e9c63d558d1e7a564d7542038615b980710272", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e7e9c63d558d1e7a564d7542038615b980710272", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e7e9c63d558d1e7a564d7542038615b980710272"}], "stats": {"total": 368, "additions": 354, "deletions": 14}, "files": [{"sha": "7aa22fe180916203a6e56dfd371a5c459b9ff661", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -1,3 +1,21 @@\n+2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23060\n+\t* intrinsic.c (compare_actual_formal ): Distinguish argument\n+\tlist functions from keywords.\n+\t* intrinsic.c (sort_actual): If formal is NULL, the presence of\n+\tan argument list function actual is an error.\n+\t* trans-expr.c (conv_arglist_function) : New function to\n+\timplement argument list functions %VAL, %REF and %LOC.\n+\t(gfc_conv_function_call): Call it.\n+\t* resolve.c (resolve_actual_arglist): Add arg ptype and check\n+\targument list functions.\n+\t(resolve_function, resolve_call): Set value of ptype before\n+\tcalls to resolve_actual_arglist.\n+\t* primary.c (match_arg_list_function): New function.\n+\t(gfc_match_actual_arglist): Call it before trying for a\n+\tkeyword argument.\n+\n 2006-12-28  Paul Thomas  <pault@gcc.gnu.org>\n \n \tPR fortran/30034"}, {"sha": "04618e7924ea740c3373685b1e006e557183a11b", "filename": "gcc/fortran/interface.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Finterface.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Finterface.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Finterface.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -1293,7 +1293,8 @@ compare_actual_formal (gfc_actual_arglist ** ap,\n \n   for (a = actual; a; a = a->next, f = f->next)\n     {\n-      if (a->name != NULL)\n+      /* Look for keywords but ignore g77 extensions like %VAL.  */\n+      if (a->name != NULL && a->name[0] != '%')\n \t{\n \t  i = 0;\n \t  for (f = formal; f; f = f->next, i++)"}, {"sha": "5cdf80d0a75e2628a27f9036db2b28f0274dae9e", "filename": "gcc/fortran/intrinsic.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fintrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fintrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fintrinsic.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -2864,7 +2864,11 @@ sort_actual (const char *name, gfc_actual_arglist ** ap,\n \n       if (f == NULL)\n \t{\n-\t  gfc_error (\"Can't find keyword named '%s' in call to '%s' at %L\",\n+\t  if (a->name[0] == '%')\n+\t    gfc_error (\"Argument list function at %L is not allowed in this \"\n+\t\t       \"context\", where);\n+\t  else\n+\t    gfc_error (\"Can't find keyword named '%s' in call to '%s' at %L\",\n \t\t     a->name, name, where);\n \t  return FAILURE;\n \t}"}, {"sha": "f67500c45814749f821fa95f44929bdd0b4171ce", "filename": "gcc/fortran/primary.c", "status": "modified", "additions": 87, "deletions": 4, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fprimary.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fprimary.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fprimary.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -1429,6 +1429,80 @@ match_keyword_arg (gfc_actual_arglist * actual, gfc_actual_arglist * base)\n }\n \n \n+/* Match an argument list function, such as %VAL.  */\n+\n+static match\n+match_arg_list_function (gfc_actual_arglist *result)\n+{\n+  char name[GFC_MAX_SYMBOL_LEN + 1];\n+  locus old_locus;\n+  match m;\n+\n+  old_locus = gfc_current_locus;\n+\n+  if (gfc_match_char ('%') != MATCH_YES)\n+    {\n+      m = MATCH_NO;\n+      goto cleanup;\n+    }\n+\n+  m = gfc_match (\"%n (\", name);\n+  if (m != MATCH_YES)\n+    goto cleanup;\n+\n+  if (name[0] != '\\0')\n+    {\n+      switch (name[0])\n+\t{\n+\tcase 'l':\n+\t  if (strncmp(name, \"loc\", 3) == 0)\n+\t    {\n+\t      result->name = \"%LOC\";\n+\t      break;\n+\t    }\n+\tcase 'r':\n+\t  if (strncmp(name, \"ref\", 3) == 0)\n+\t    {\n+\t      result->name = \"%REF\";\n+\t      break;\n+\t    }\n+\tcase 'v':\n+\t  if (strncmp(name, \"val\", 3) == 0)\n+\t    {\n+\t      result->name = \"%VAL\";\n+\t      break;\n+\t    }\n+\tdefault:\n+\t  m = MATCH_ERROR;\n+\t  goto cleanup;\n+\t}\n+    }\n+\n+  if (gfc_notify_std (GFC_STD_GNU, \"Extension: argument list \"\n+\t\t      \"function at %C\") == FAILURE)\n+    {\n+      m = MATCH_ERROR;\n+      goto cleanup;\n+    }\n+\n+  m = match_actual_arg (&result->expr);\n+  if (m != MATCH_YES)\n+    goto cleanup;\n+\n+  if (gfc_match_char (')') != MATCH_YES)\n+    {\n+      m = MATCH_NO;\n+      goto cleanup;\n+    }\n+\n+  return MATCH_YES;\n+\n+cleanup:\n+  gfc_current_locus = old_locus;\n+  return m;\n+}\n+\n+\n /* Matches an actual argument list of a function or subroutine, from\n    the opening parenthesis to the closing parenthesis.  The argument\n    list is assumed to allow keyword arguments because we don't know if\n@@ -1497,13 +1571,21 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n \t}\n       else\n \t{\n-\t  /* See if we have the first keyword argument.  */\n-\t  m = match_keyword_arg (tail, head);\n-\t  if (m == MATCH_YES)\n-\t    seen_keyword = 1;\n+\t  /* Try an argument list function, like %VAL.  */\n+\t  m = match_arg_list_function (tail);\n \t  if (m == MATCH_ERROR)\n \t    goto cleanup;\n \n+\t  /* See if we have the first keyword argument.  */\n+\t  if (m == MATCH_NO)\n+\t    {\n+\t      m = match_keyword_arg (tail, head);\n+\t      if (m == MATCH_YES)\n+\t\tseen_keyword = 1;\n+\t      if (m == MATCH_ERROR)\n+\t\tgoto cleanup;\n+\t    }\n+\n \t  if (m == MATCH_NO)\n \t    {\n \t      /* Try for a non-keyword argument.  */\n@@ -1515,6 +1597,7 @@ gfc_match_actual_arglist (int sub_flag, gfc_actual_arglist ** argp)\n \t    }\n \t}\n \n+\n     next:\n       if (gfc_match_char (')') == MATCH_YES)\n \tbreak;"}, {"sha": "1b46a10ca5f810b077be55393300cb67965bb49a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 71, "deletions": 8, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -844,15 +844,14 @@ resolve_assumed_size_actual (gfc_expr *e)\n    references.  */\n \n static try\n-resolve_actual_arglist (gfc_actual_arglist * arg)\n+resolve_actual_arglist (gfc_actual_arglist * arg, procedure_type ptype)\n {\n   gfc_symbol *sym;\n   gfc_symtree *parent_st;\n   gfc_expr *e;\n \n   for (; arg; arg = arg->next)\n     {\n-\n       e = arg->expr;\n       if (e == NULL)\n         {\n@@ -873,7 +872,7 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t{\n \t  if (gfc_resolve_expr (e) != SUCCESS)\n \t    return FAILURE;\n-\t  continue;\n+\t  goto argument_list;\n \t}\n \n       /* See if the expression node should really be a variable\n@@ -938,7 +937,7 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t\t      && sym->ns->parent->proc_name == sym)))\n \t    goto got_variable;\n \n-\t  continue;\n+\t  goto argument_list;\n \t}\n \n       /* See if the name is a module procedure in a parent unit.  */\n@@ -962,7 +961,7 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t  || sym->attr.intrinsic\n \t  || sym->attr.external)\n \t{\n-\t  continue;\n+\t  goto argument_list;\n \t}\n \n     got_variable:\n@@ -976,6 +975,62 @@ resolve_actual_arglist (gfc_actual_arglist * arg)\n \t  e->ref->u.ar.type = AR_FULL;\n \t  e->ref->u.ar.as = sym->as;\n \t}\n+\n+    argument_list:\n+      /* Check argument list functions %VAL, %LOC and %REF.  There is\n+\t nothing to do for %REF.  */\n+      if (arg->name && arg->name[0] == '%')\n+\t{\n+\t  if (strncmp (\"%VAL\", arg->name, 4) == 0)\n+\t    {\n+\t      if (e->ts.type == BT_CHARACTER || e->ts.type == BT_DERIVED)\n+\t\t{\n+\t\t  gfc_error (\"By-value argument at %L is not of numeric \"\n+\t\t\t     \"type\", &e->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\n+\t      if (e->rank)\n+\t\t{\n+\t\t  gfc_error (\"By-value argument at %L cannot be an array or \"\n+\t\t\t     \"an array section\", &e->where);\n+\t\treturn FAILURE;\n+\t\t}\n+\n+\t      /* Intrinsics are still PROC_UNKNOWN here.  However,\n+\t\t since same file external procedures are not resolvable\n+\t\t in gfortran, it is a good deal easier to leave them to\n+\t\t intrinsic.c.  */\n+\t      if (ptype != PROC_UNKNOWN && ptype != PROC_EXTERNAL)\n+\t\t{\n+\t\t  gfc_error (\"By-value argument at %L is not allowed \"\n+\t\t\t     \"in this context\", &e->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\n+\t      if (((e->ts.type == BT_REAL || e->ts.type == BT_COMPLEX)\n+\t\t    && e->ts.kind > gfc_default_real_kind)\n+\t\t      || (e->ts.kind > gfc_default_integer_kind))\n+\t\t{\n+\t\t  gfc_error (\"Kind of by-value argument at %L is larger \"\n+\t\t\t     \"than default kind\", &e->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\n+\t    }\n+\n+\t  /* Statement functions have already been excluded above.  */\n+\t  else if (strncmp (\"%LOC\", arg->name, 4) == 0\n+\t\t     && e->ts.type == BT_PROCEDURE)\n+\t    {\n+\t      if (e->symtree->n.sym->attr.proc == PROC_INTERNAL)\n+\t\t{\n+\t\t  gfc_error (\"Passing internal procedure at %L by location \"\n+\t\t\t     \"not allowed\", &e->where);\n+\t\t  return FAILURE;\n+\t\t}\n+\t    }\n+\t}\n     }\n \n   return SUCCESS;\n@@ -1451,6 +1506,7 @@ resolve_function (gfc_expr * expr)\n   const char *name;\n   try t;\n   int temp;\n+  procedure_type p = PROC_INTRINSIC;\n \n   sym = NULL;\n   if (expr->symtree)\n@@ -1467,8 +1523,11 @@ resolve_function (gfc_expr * expr)\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n \n-  if (resolve_actual_arglist (expr->value.function.actual) == FAILURE)\n-    return FAILURE;\n+  if (expr->symtree && expr->symtree->n.sym)\n+    p = expr->symtree->n.sym->attr.proc;\n+\n+  if (resolve_actual_arglist (expr->value.function.actual, p) == FAILURE)\n+      return FAILURE;\n \n   /* Resume assumed_size checking. */\n   need_full_assumed_size--;\n@@ -1848,6 +1907,7 @@ static try\n resolve_call (gfc_code * c)\n {\n   try t;\n+  procedure_type ptype = PROC_INTRINSIC;\n \n   if (c->symtree && c->symtree->n.sym\n \t&& c->symtree->n.sym->ts.type != BT_UNKNOWN)\n@@ -1894,7 +1954,10 @@ resolve_call (gfc_code * c)\n      of procedure, once the procedure itself is resolved.  */\n   need_full_assumed_size++;\n \n-  if (resolve_actual_arglist (c->ext.actual) == FAILURE)\n+  if (c->symtree && c->symtree->n.sym)\n+    ptype = c->symtree->n.sym->attr.proc;\n+\n+  if (resolve_actual_arglist (c->ext.actual, ptype) == FAILURE)\n     return FAILURE;\n \n   /* Resume assumed_size checking. */"}, {"sha": "e534aff78414a12baeb756eba90754498e4208d7", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -1906,6 +1906,57 @@ is_aliased_array (gfc_expr * e)\n   return false;\n }\n \n+/* Generate the code for argument list functions.  */\n+\n+static void\n+conv_arglist_function (gfc_se *se, gfc_expr *expr, const char *name)\n+{\n+  tree type = NULL_TREE;\n+  /* Pass by value for g77 %VAL(arg), pass the address\n+     indirectly for %LOC, else by reference.  Thus %REF\n+     is a \"do-nothing\" and %LOC is the same as an F95\n+     pointer.  */\n+  if (strncmp (name, \"%VAL\", 4) == 0)\n+    {\n+      gfc_conv_expr (se, expr);\n+      /* %VAL converts argument to default kind.  */\n+      switch (expr->ts.type)\n+\t{\n+\t  case BT_REAL:\n+\t    type = gfc_get_real_type (gfc_default_real_kind);\n+\t    se->expr = fold_convert (type, se->expr);\n+\t    break;\n+\t  case BT_COMPLEX:\n+\t    type = gfc_get_complex_type (gfc_default_complex_kind);\n+\t    se->expr = fold_convert (type, se->expr);\n+\t    break;\n+\t  case BT_INTEGER:\n+\t    type = gfc_get_int_type (gfc_default_integer_kind);\n+\t    se->expr = fold_convert (type, se->expr);\n+\t    break;\n+\t  case BT_LOGICAL:\n+\t    type = gfc_get_logical_type (gfc_default_logical_kind);\n+\t    se->expr = fold_convert (type, se->expr);\n+\t    break;\n+\t  /* This should have been resolved away.  */\n+\t  case BT_UNKNOWN: case BT_CHARACTER: case BT_DERIVED:\n+\t  case BT_PROCEDURE: case BT_HOLLERITH:\n+\t    gfc_internal_error (\"Bad type in conv_arglist_function\");\n+\t}\n+\t  \n+    }\n+  else if (strncmp (name, \"%LOC\", 4) == 0)\n+    {\n+      gfc_conv_expr_reference (se, expr);\n+      se->expr = gfc_build_addr_expr (NULL, se->expr);\n+    }\n+  else if (strncmp (name, \"%REF\", 4) == 0)\n+    gfc_conv_expr_reference (se, expr);\n+  else\n+    gfc_error (\"Unknown argument list function at %L\", &expr->where);\n+}\n+\n+\n /* Generate code for a procedure call.  Note can return se->post != NULL.\n    If se->direct_byref is set then se->expr contains the return parameter.\n    Return nonzero, if the call has alternate specifiers.  */\n@@ -2024,6 +2075,10 @@ gfc_conv_function_call (gfc_se * se, gfc_symbol * sym,\n \t\t{\n \t\t  gfc_conv_expr (&parmse, e);\n \t\t}\n+\t      else if (arg->name && arg->name[0] == '%')\n+\t\t/* Argument list functions %VAL, %LOC and %REF are signalled\n+\t\t   through arg->name.  */\n+\t\tconv_arglist_function (&parmse, arg->expr, arg->name);\n \t      else\n \t\t{\n \t\t  gfc_conv_expr_reference (&parmse, e);"}, {"sha": "5ba52bad2373893b679769bf718614f32a501365", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -1,3 +1,11 @@\n+2006-12-31  Paul Thomas  <pault@gcc.gnu.org>\n+\n+\tPR fortran/23060\n+\t* gfortran.dg/c_by_val.c: Called by c_by_val_1.f.\n+\t* gfortran.dg/c_by_val_1.f: New test.\n+\t* gfortran.dg/c_by_val_2.f: New test.\n+\t* gfortran.dg/c_by_val_3.f: New test.\n+\n 2006-12-30  Thomas Koenig  <Thomas.Koenig@online.de>\n \n \tPR libfortran/30321"}, {"sha": "daba6d2c52dc31dda6e71e341d053bb9bd662e2d", "filename": "gcc/testsuite/gfortran.dg/c_by_val.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val.c?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -0,0 +1,41 @@\n+/*  Passing from fortran to C by value, using %VAL.  */\n+\n+typedef struct { float r, i; } complex;\n+extern void f_to_f__ (float*, float, float*, float**);\n+extern void i_to_i__ (int*, int, int*, int**);\n+extern void c_to_c__ (complex*, complex, complex*, complex**);\n+extern void abort (void);\n+\n+void\n+f_to_f__(float *retval, float a1, float *a2, float **a3)\n+{\n+  if ( a1 != *a2 ) abort();\n+  if ( a1 != **a3 ) abort();\n+  a1 = 0.0;\n+  *retval = *a2 * 2.0;\n+  return;\n+}\n+\n+void\n+i_to_i__(int *retval, int i1, int *i2, int **i3)\n+{\n+  if ( i1 != *i2 ) abort();\n+  if ( i1 != **i3 ) abort();\n+  i1 = 0;\n+  *retval = *i2 * 3;\n+  return;\n+}\n+\n+void\n+c_to_c__(complex *retval, complex c1, complex *c2, complex **c3)\n+{\n+  if ( c1.r != c2->r ) abort();\n+  if ( c1.i != c2->i ) abort();\n+  if ( c1.r != (*c3)->r ) abort();\n+  if ( c1.i != (*c3)->i ) abort();\n+  c1.r = 0.0;\n+  c1.i = 0.0;\n+  retval->r = c2->r * 4.0;\n+  retval->i = c2->i * 4.0;\n+  return;\n+}"}, {"sha": "133cc55e173d7810fb23bc0e4f13c4a761442b0a", "filename": "gcc/testsuite/gfortran.dg/c_by_val_1.f", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_1.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_1.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_1.f?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -0,0 +1,31 @@\n+C { dg-do run }\n+C { dg-additional-sources c_by_val.c }\n+C { dg-options \"-ff2c -w -O0\" }\n+\n+      program c_by_val_1\n+      external   f_to_f, i_to_i, c_to_c\n+      real       a, b, c\n+      integer*4  i, j, k\n+      complex    u, v, w, c_to_c\n+\n+      a = 42.0\n+      b = 0.0\n+      c = a\n+      call  f_to_f (b, %VAL (a), %REF (c), %LOC (c))\n+      if ((2.0 * a).ne.b) call abort ()\n+\n+      i = 99\n+      j = 0\n+      k = i\n+      call i_to_i (j, %VAL (i), %REF (k), %LOC (k))\n+      if ((3 * i).ne.j) call abort ()\n+\n+      u = (-1.0, 2.0)\n+      v = (1.0, -2.0)\n+      w = u\n+      v = c_to_c (%VAL (u), %REF (w), %LOC (w))\n+      if ((4.0 * u).ne.v) call abort ()\n+\n+      stop\n+      end\n+"}, {"sha": "6aadd9834261cbb0895e0201c577ed5dd16fdb88", "filename": "gcc/testsuite/gfortran.dg/c_by_val_2.f90", "status": "added", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_2.f90?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -0,0 +1,29 @@\n+! { dg-do compile }\n+! { dg-options \"-w\" }\n+\n+program c_by_val_2\n+  external bar\n+  real (4) :: bar, ar(2) = (/1.0,2.0/)\n+  type     :: mytype\n+    integer  :: i\n+  end type mytype\n+  type(mytype)  :: z\n+  character(8)  :: c = \"blooey\"\n+  print *, sin (%VAL(2.0))   ! { dg-error \"not allowed in this context\" }\n+  print *, foo (%VAL(1.0))   ! { dg-error \"not allowed in this context\" }\n+  call  foobar (%VAL(0.5))   ! { dg-error \"not allowed in this context\" }\n+  print *, bar (%VAL(z))     ! { dg-error \"not of numeric type\" }\n+  print *, bar (%VAL(c))     ! { dg-error \"not of numeric type\" }\n+  print *, bar (%VAL(ar))    ! { dg-error \"cannot be an array\" }\n+  print *, bar (%VAL(0.0))\n+contains\n+  function foo (a)\n+    real(4) :: a, foo\n+    foo = cos (a)\n+  end function foo\n+  subroutine foobar (a)\n+    real(4) :: a\n+    print *, a\n+  end subroutine foobar\n+end program c_by_val_2\n+"}, {"sha": "bf7aedf8ba4a7f08e1c27761af0a6dd857b5028e", "filename": "gcc/testsuite/gfortran.dg/c_by_val_3.f90", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fc_by_val_3.f90?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0", "patch": "@@ -0,0 +1,7 @@\n+! { dg-do compile }\n+! { dg-options \"-std=f95\" }\n+program c_by_val_3\n+  external bar\n+  real (4) :: bar\n+  print *, bar (%VAL(0.0)) ! { dg-error \"argument list function\" }\n+end program c_by_val_3"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "gcc/testsuite/gfortran.dg/char_length_1.f90", "status": "added", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7fcafa718da6cb8e072bcadde5eab440df5898d0/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fchar_length_1.f90?ref=7fcafa718da6cb8e072bcadde5eab440df5898d0"}]}