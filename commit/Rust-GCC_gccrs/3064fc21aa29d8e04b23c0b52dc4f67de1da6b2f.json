{"sha": "3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzA2NGZjMjFhYTI5ZDhlMDRiMjNjMGI1MmRjNGY2N2RlMWRhNmIyZg==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-04-01T10:11:39Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2021-04-01T10:11:39Z"}, "message": "Add testcase for PR98265\n\ngcc/testsuite/ChangeLog:\n\n2021-04-01  Jan Hubicka  <hubicka@ucw.cz>\n\n\tPR ipa/98265\n\t* gcc.dg/tree-ssa/pr98265.C: New test.", "tree": {"sha": "d909c63a5109536cc33045f23af9361402d2e3dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d909c63a5109536cc33045f23af9361402d2e3dd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f/comments", "author": null, "committer": null, "parents": [{"sha": "7b478ede2a37b1586846abd355bd902ea4cae117", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7b478ede2a37b1586846abd355bd902ea4cae117", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7b478ede2a37b1586846abd355bd902ea4cae117"}], "stats": {"total": 348, "additions": 348, "deletions": 0}, "files": [{"sha": "9c798e6c59de5e42b3853defae256c6fd7369171", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr98265.C", "status": "added", "additions": 348, "deletions": 0, "changes": 348, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr98265.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr98265.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr98265.C?ref=3064fc21aa29d8e04b23c0b52dc4f67de1da6b2f", "patch": "@@ -0,0 +1,348 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+extern void __assert_fail(const char*, const char*, int, const char*);\n+namespace Eigen {\n+enum { AutoAlign };\n+template <int, typename>\n+struct conditional;\n+template <typename Else>\n+struct conditional<false, Else> {\n+  typedef Else type;\n+};\n+template <typename T>\n+struct remove_reference {\n+  typedef T type;\n+};\n+struct is_arithmetic {\n+  enum { value };\n+};\n+template <typename>\n+struct traits;\n+template <typename T>\n+struct traits<const T> : traits<T> {};\n+template <typename>\n+struct evaluator;\n+template <typename>\n+struct EigenBase;\n+template <typename>\n+class PlainObjectBase;\n+template <typename, int _Rows, int _Cols, int = AutoAlign, int = _Rows,\n+          int = _Cols>\n+class Matrix;\n+template <typename>\n+class MatrixBase;\n+template <typename, typename>\n+class CwiseNullaryOp;\n+template <typename, typename, typename>\n+class CwiseBinaryOp;\n+template <typename>\n+struct scalar_constant_op;\n+template <int _Rows>\n+struct size_at_compile_time {\n+  enum { ret = _Rows };\n+};\n+struct ref_selector {\n+  typedef const Matrix<float, 3, 1>& type;\n+};\n+template <typename Derived>\n+struct dense_xpr_base {\n+  typedef MatrixBase<Derived> type;\n+};\n+template <typename Derived, typename = typename traits<Derived>::XprKind>\n+struct generic_xpr_base {\n+  typedef typename dense_xpr_base<Derived>::type type;\n+};\n+template <typename Expr, typename Scalar = typename Expr::Scalar>\n+struct plain_constant_type {\n+  ;\n+  typedef CwiseNullaryOp<scalar_constant_op<Scalar>,\n+                         Matrix<Scalar, traits<Expr>::ColsAtCompileTime,\n+                                traits<Expr>::MaxRowsAtCompileTime,\n+                                traits<Expr>::MaxColsAtCompileTime>>\n+      type;\n+};\n+struct scalar_product_op {\n+  float operator()(float a, float b) { return a * b; }\n+};\n+template <typename>\n+struct scalar_constant_op {\n+  scalar_constant_op(float other) : m_other(other) {}\n+  float operator()() { return m_other; }\n+  float m_other;\n+};\n+struct assign_op {\n+  void assignCoeff(float& a, float b) { a = b; }\n+};\n+template <typename Derived>\n+class DenseCoeffsBase : public EigenBase<Derived> {\n+ public:\n+  typedef typename traits<Derived>::Scalar Scalar;\n+  typedef\n+      typename conditional<is_arithmetic::value, Scalar>::type CoeffReturnType;\n+};\n+template <typename Derived>\n+class DenseBase : public DenseCoeffsBase<Derived> {\n+ public:\n+  enum {\n+    RowsAtCompileTime = traits<Derived>::RowsAtCompileTime,\n+    SizeAtCompileTime = size_at_compile_time<RowsAtCompileTime>::ret,\n+    MaxSizeAtCompileTime\n+  };\n+};\n+template <typename Derived>\n+class MatrixBase : public DenseBase<Derived> {\n+ public:\n+  using DenseBase<Derived>::derived;\n+  template <typename T>\n+  CwiseBinaryOp<scalar_product_op, const Derived,\n+                const typename plain_constant_type<Derived, T>::type>\n+  operator*(T& scalar) {\n+    return CwiseBinaryOp<scalar_product_op, const Derived,\n+                         const typename plain_constant_type<Derived>::type>(\n+        derived(), typename plain_constant_type<Derived>::type(derived().rows(),\n+                                                               0, scalar));\n+  }\n+};\n+template <typename Derived>\n+struct EigenBase {\n+  const Derived& derived() const { return *static_cast<const Derived*>(this); }\n+  Derived& const_cast_derived() const {\n+    return *static_cast<Derived*>(const_cast<EigenBase*>(this));\n+  }\n+};\n+template <typename>\n+struct binary_evaluator;\n+template <typename T>\n+struct evaluator<const T> : evaluator<T> {\n+  evaluator(const T& xpr) : evaluator<T>(xpr) {}\n+};\n+template <typename Derived>\n+struct evaluator {\n+  typedef Derived PlainObjectType;\n+  typedef typename PlainObjectType::Scalar Scalar;\n+  evaluator(const PlainObjectType& m) : m_data(m.data()) {}\n+  typename PlainObjectType::CoeffReturnType coeff(long row, long) {\n+    return m_data[row];\n+  }\n+  Scalar& coeffRef(long row, long) { return const_cast<Scalar*>(m_data)[row]; }\n+  const Scalar* m_data;\n+};\n+template <typename Scalar, int Rows, int Cols, int Options, int MaxRows,\n+          int MaxCols>\n+struct evaluator<Matrix<Scalar, Rows, Cols, Options, MaxRows, MaxCols>>\n+    : evaluator<PlainObjectBase<Matrix<Scalar, Rows, Cols>>> {\n+  typedef Matrix<Scalar, Rows, Cols> XprType;\n+  evaluator(const XprType& m) : evaluator<PlainObjectBase<XprType>>(m) {}\n+};\n+struct nullary_wrapper {\n+  template <typename IndexType>\n+  float operator()(scalar_constant_op<float> op, IndexType, IndexType) const {\n+    return op();\n+  }\n+};\n+template <typename NullaryOp, typename PlainObjectType>\n+struct evaluator<CwiseNullaryOp<NullaryOp, PlainObjectType>> {\n+  typedef CwiseNullaryOp<NullaryOp, PlainObjectType> XprType;\n+  evaluator(XprType n) : m_functor(n.functor()) {}\n+  template <typename IndexType>\n+  typename XprType::CoeffReturnType coeff(IndexType row, IndexType col) {\n+    return m_wrapper(m_functor, row, col);\n+  }\n+  NullaryOp m_functor;\n+  nullary_wrapper m_wrapper;\n+};\n+template <typename BinaryOp, typename Lhs, typename Rhs>\n+struct evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>>\n+    : binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>> {\n+  evaluator(CwiseBinaryOp<BinaryOp, Lhs, Rhs> xpr)\n+      : binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>>(xpr) {}\n+};\n+template <typename BinaryOp, typename Lhs, typename Rhs>\n+struct binary_evaluator<CwiseBinaryOp<BinaryOp, Lhs, Rhs>> {\n+  typedef CwiseBinaryOp<BinaryOp, Lhs, Rhs> XprType;\n+  binary_evaluator(XprType xpr) : m_lhsImpl(xpr.lhs()), m_rhsImpl(xpr.rhs()) {}\n+  typename XprType::CoeffReturnType coeff(long row, long col) {\n+    return m_functor(m_lhsImpl.coeff(row, col), m_rhsImpl.coeff(row, col));\n+  }\n+  BinaryOp m_functor;\n+  evaluator<Lhs> m_lhsImpl;\n+  evaluator<Rhs> m_rhsImpl;\n+};\n+template <typename Kernel, int Index, int Stop>\n+struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling {\n+  enum { outer, inner = Index };\n+  static void run(Kernel kernel) {\n+    kernel.assignCoeffByOuterInner(outer, inner);\n+    copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Index + 1,\n+                                                            Stop>::run(kernel);\n+  }\n+};\n+template <typename Kernel, int Stop>\n+struct copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, Stop,\n+                                                               Stop> {\n+  static void run(Kernel) {}\n+};\n+template <typename Kernel>\n+struct dense_assignment_loop {\n+  static void run(Kernel kernel) {\n+    typedef typename Kernel::DstEvaluatorType::XprType DstXprType;\n+    enum { size = DstXprType::SizeAtCompileTime, alignedSize = 0 };\n+    copy_using_evaluator_DefaultTraversal_CompleteUnrolling<Kernel, alignedSize,\n+                                                            size>::run(kernel);\n+  }\n+};\n+template <typename DstEvaluatorTypeT, typename SrcEvaluatorTypeT,\n+          typename Functor>\n+class generic_dense_assignment_kernel {\n+  typedef typename DstEvaluatorTypeT::XprType DstXprType;\n+\n+ public:\n+  typedef DstEvaluatorTypeT DstEvaluatorType;\n+  typedef SrcEvaluatorTypeT SrcEvaluatorType;\n+  generic_dense_assignment_kernel(DstEvaluatorType dst, SrcEvaluatorType src,\n+                                  Functor, DstXprType& dstExpr)\n+      : m_dst(dst), m_src(src), m_dstExpr(dstExpr) {}\n+  long assignCoeff_col;\n+  void assignCoeffByOuterInner(long, long inner) {\n+    long __trans_tmp_1 = inner;\n+    m_functor.assignCoeff(m_dst.coeffRef(__trans_tmp_1, assignCoeff_col),\n+                          m_src.coeff(__trans_tmp_1, assignCoeff_col));\n+  }\n+  DstEvaluatorType m_dst;\n+  SrcEvaluatorType m_src;\n+  Functor m_functor;\n+  DstXprType& m_dstExpr;\n+};\n+template <typename DstXprType, typename SrcXprType, typename Functor>\n+void call_dense_assignment_loop(DstXprType& dst, SrcXprType src, Functor func) {\n+  typedef evaluator<DstXprType> DstEvaluatorType;\n+  typedef evaluator<SrcXprType> SrcEvaluatorType;\n+  SrcEvaluatorType srcEvaluator(src);\n+  DstEvaluatorType dstEvaluator(dst);\n+  typedef generic_dense_assignment_kernel<DstEvaluatorType, SrcEvaluatorType,\n+                                          Functor>\n+      Kernel;\n+  Kernel kernel(dstEvaluator, srcEvaluator, func, dst.const_cast_derived());\n+  dense_assignment_loop<Kernel>::run(kernel);\n+}\n+template <typename Dst, typename Src, typename Func>\n+void call_assignment_no_alias(Dst& dst, Src src, Func func) {\n+  enum { NeedToTranspose };\n+  typename conditional<NeedToTranspose, Dst&>::type actualDst(dst);\n+  CwiseBinaryOp<scalar_product_op, const Matrix<float, 3, 1>,\n+                const CwiseNullaryOp<scalar_constant_op<float>,\n+                                     const Matrix<float, 3, 1, 0, 2, 3>>>\n+      __trans_tmp_4 = src;\n+  call_dense_assignment_loop(actualDst, __trans_tmp_4, func);\n+}\n+template <int Size>\n+struct plain_array {\n+  float array[Size];\n+};\n+template <int Size, int _Rows>\n+class DenseStorage {\n+  plain_array<Size> m_data;\n+\n+ public:\n+  DenseStorage() {}\n+  DenseStorage(const DenseStorage&);\n+  static long rows() { return _Rows; }\n+  const float* data() const { return m_data.array; }\n+  float* data() { return m_data.array; }\n+};\n+template <typename Derived>\n+class PlainObjectBase : public dense_xpr_base<Derived>::type {\n+ public:\n+  typedef typename dense_xpr_base<Derived>::type Base;\n+  typedef typename traits<Derived>::Scalar Scalar;\n+  DenseStorage<Base::MaxSizeAtCompileTime, Base::RowsAtCompileTime> m_storage;\n+  long rows() const { return m_storage.rows(); }\n+  const Scalar* data() const { return m_storage.data(); }\n+  PlainObjectBase() {}\n+  template <typename OtherDerived>\n+  PlainObjectBase(const DenseBase<OtherDerived>& other) {\n+    _set_noalias(other);\n+  }\n+  template <typename OtherDerived>\n+  void _set_noalias(const DenseBase<OtherDerived>& other) {\n+    call_assignment_no_alias(this->derived(), other.derived(), assign_op());\n+  }\n+};\n+template <typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows,\n+          int _MaxCols>\n+struct traits<Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>> {\n+  typedef _Scalar Scalar;\n+  typedef int XprKind;\n+  enum {\n+    RowsAtCompileTime = _Rows,\n+    ColsAtCompileTime,\n+    MaxRowsAtCompileTime,\n+    MaxColsAtCompileTime,\n+  };\n+};\n+template <typename _Scalar, int _Rows, int _Cols, int _Options, int _MaxRows,\n+          int _MaxCols>\n+class Matrix\n+    : public PlainObjectBase<\n+          Matrix<_Scalar, _Rows, _Cols, _Options, _MaxRows, _MaxCols>> {\n+ public:\n+  typedef PlainObjectBase<Matrix> Base;\n+  typedef typename traits<Matrix>::Scalar Scalar;\n+  Matrix(Scalar& x, Scalar& y, Scalar& z) {\n+    m_storage.data()[0] = x;\n+    m_storage.data()[1] = y;\n+    m_storage.data()[2] = z;\n+  }\n+  template <typename OtherDerived>\n+  Matrix(const EigenBase<OtherDerived>& other) : Base(other.derived()) {}\n+  using Base::m_storage;\n+};\n+template <typename BinaryOp, typename Lhs, typename Rhs>\n+struct traits<CwiseBinaryOp<BinaryOp, Lhs, Rhs>> {\n+  typedef typename traits<Lhs>::XprKind XprKind;\n+  enum { RowsAtCompileTime };\n+  typedef float Scalar;\n+};\n+template <typename>\n+class CwiseBinaryOpImpl;\n+template <typename, typename, typename RhsType>\n+class CwiseBinaryOp : public CwiseBinaryOpImpl<RhsType> {\n+ public:\n+  typedef ref_selector::type LhsNested;\n+  typedef RhsType RhsNested;\n+  CwiseBinaryOp(const Matrix<float, 3, 1>& aLhs, RhsType& aRhs)\n+      : m_lhs(aLhs), m_rhs(aRhs) {}\n+  remove_reference<LhsNested>::type& lhs() { return m_lhs; }\n+  typename remove_reference<RhsNested>::type& rhs() { return m_rhs; }\n+  LhsNested m_lhs;\n+  RhsNested m_rhs;\n+};\n+template <typename>\n+class CwiseBinaryOpImpl\n+    : public generic_xpr_base<CwiseBinaryOp<\n+          scalar_product_op, const Matrix<float, 3, 1>,\n+          const CwiseNullaryOp<scalar_constant_op<float>,\n+                               const Matrix<float, 3, 1, 0, 2, 3>>>>::type {};\n+template <typename NullaryOp, typename PlainObjectType>\n+struct traits<CwiseNullaryOp<NullaryOp, PlainObjectType>>\n+    : traits<PlainObjectType> {};\n+template <typename, typename PlainObjectType>\n+class CwiseNullaryOp\n+    : public dense_xpr_base<CwiseNullaryOp<int, PlainObjectType>>::type {\n+ public:\n+  CwiseNullaryOp(long rows, long, scalar_constant_op<float> func)\n+      : m_functor(func) {\n+    rows ? void() : __assert_fail(\"\", \"\", 1, __PRETTY_FUNCTION__);\n+  }\n+  scalar_constant_op<float> functor() { return m_functor; }\n+  scalar_constant_op<float> m_functor;\n+};\n+}  // namespace Eigen\n+Eigen::Matrix<float, 3, 1> should_inline(float x, float y, float z,\n+                                         float scale) {\n+  return Eigen::Matrix<float, 3, 1>(x, y, z) * scale;\n+}\n+\n+// We should inline everything to should_inline\n+\n+/* { dg-final { scan-tree-dump-times \"Function\" \"optimized\" } } */"}]}