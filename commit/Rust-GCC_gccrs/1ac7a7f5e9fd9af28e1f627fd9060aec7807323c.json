{"sha": "1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWFjN2E3ZjVlOWZkOWFmMjhlMWY2MjdmZDkwNjBhZWM3ODA3MzIzYw==", "commit": {"author": {"name": "Michael Hayes", "email": "m.hayes@elec.canterbury.ac.nz", "date": "1999-04-15T04:22:04Z"}, "committer": {"name": "Michael Hayes", "email": "m.hayes@gcc.gnu.org", "date": "1999-04-15T04:22:04Z"}, "message": "c4x.h: Tweaked comment formatting.\n\n\t* config/c4x/c4x.h:  Tweaked comment formatting.\n\t* config/c4x/c4x.c:  Likewise.\n\nFrom-SVN: r26470", "tree": {"sha": "02d633cec2feccab53218a3818db3642ea2c5f4f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/02d633cec2feccab53218a3818db3642ea2c5f4f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/comments", "author": null, "committer": null, "parents": [{"sha": "75923b2fc5c3dad018c2e5a85c332914938f7535", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75923b2fc5c3dad018c2e5a85c332914938f7535", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75923b2fc5c3dad018c2e5a85c332914938f7535"}], "stats": {"total": 61, "additions": 33, "deletions": 28}, "files": [{"sha": "183159ed1a8652b7f4b82590b25dcd16e9ac7ab7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "patch": "@@ -1,3 +1,8 @@\n+Thu Apr 15 23:13:35 1999  Michael Hayes  <m.hayes@elec.canterbury.ac.nz>\n+\n+\t* config/c4x/c4x.h:  Tweaked comment formatting.\n+\t* config/c4x/c4x.c:  Likewise.\n+\n Thu Apr 15 02:45:19 1999  Mumit Khan  <khan@xraylith.wisc.edu>\n \n         * aclocal.m4 (GCC_FUNC_MKDIR_TAKES_ONE_ARG): Define."}, {"sha": "0b84e02826e6f0f10d1db62b09fe02372cfd389a", "filename": "gcc/config/c4x/c4x.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2Fconfig%2Fc4x%2Fc4x.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2Fconfig%2Fc4x%2Fc4x.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.c?ref=1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "patch": "@@ -515,7 +515,7 @@ c4x_function_arg (cum, mode, type, named)\n       cum->maxints = (cum->ints > 6 - cum->maxfloats) ? \n \t6 - cum->maxfloats : cum->ints;\n \n-      /* If there is no prototype, assume all the arguments are integers. */\n+      /* If there is no prototype, assume all the arguments are integers.  */\n       if (! cum->prototype)\n \tcum->maxints = 6;\n \n@@ -1555,7 +1555,7 @@ rtx addr;\n \t    \n \t    op1 = eliminate_constant_term (op1, &offset);\n \t    \n-\t    /* ??? These costs need rethinking... */\n+\t    /* ??? These costs need rethinking...  */\n \t    if (GET_CODE (op1) == LABEL_REF)\n \t      return 3;\n \t    \n@@ -2072,7 +2072,7 @@ c4x_rptb_nop_p (insn)\n \n       /* If we have a jump instruction we should insert a NOP. If we\n \t hit repeat block top we should only insert a NOP if the loop\n-\t is empty. */\n+\t is empty.  */\n       if (GET_CODE (insn) == JUMP_INSN)\n \treturn 1;\n       insn = previous_insn (insn);\n@@ -2138,7 +2138,7 @@ c4x_process_after_reload (first)\n \t    continue;\n \n \t  /* Insert the RTX for RPTB at the top of the loop\n-\t     and a label at the end of the loop. */\n+\t     and a label at the end of the loop.  */\n \t  if (insn_code_number == CODE_FOR_rptb_end)\n \t    c4x_rptb_insert(insn);\n \n@@ -3270,7 +3270,7 @@ c4x_address_conflict (op0, op1, store0, store1)\n     return 1;\n \n   /* We can not optimize the case where op1 and op2 refer to the same\n-     address. */\n+     address.  */\n   if (base0 == base1 && disp0 == disp1 && index0 == index1)\n     return 1;\n \n@@ -3580,7 +3580,7 @@ c4x_valid_operands (code, operands, mode, force)\n \treturn 0;\n       break;\n \n-      /* Any valid memory operand screened by src_operand is OK. */      \n+      /* Any valid memory operand screened by src_operand is OK.  */      \n     case MEM:\n \n       /* After CSE, any remaining (ADDRESSOF:P reg) gets converted"}, {"sha": "67ac4a0cd873f34e7afc1f1955694245cc11d113", "filename": "gcc/config/c4x/c4x.h", "status": "modified", "additions": 22, "deletions": 22, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1ac7a7f5e9fd9af28e1f627fd9060aec7807323c/gcc%2Fconfig%2Fc4x%2Fc4x.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fc4x%2Fc4x.h?ref=1ac7a7f5e9fd9af28e1f627fd9060aec7807323c", "patch": "@@ -67,7 +67,7 @@\n %{mcpu=31:--architecture c3x} \\\n %{mcpu=32:--architecture c3x}\"\n \n-/* Define C preprocessor options. */\n+/* Define C preprocessor options.  */\n \n #define CPP_SPEC \"\\\n %{!m30:%{!m31:%{!m32:%{!mcpu=30:%{!mcpu=31:%{!mcpu=32:%{!mcpu=40:%{!mcpu=44:\\\n@@ -88,7 +88,7 @@\n %{!msmall:%{!mbig:-D_BIGMODEL }} \\\n %{finline-functions:-D_INLINE }\"\n \n-/* Specify the startup file to link with. */\n+/* Specify the startup file to link with.  */\n \n #define STARTFILE_SPEC \"\\\n %{!mmemparm:%{m30:%{msmall:crt0_3sr%O%s} %{!msmall:crt0_3br%O%s}}} \\\n@@ -256,7 +256,7 @@\n \n /* Default target switches */\n \n-/* Play safe, not the fastest code. */\n+/* Play safe, not the fastest code.  */\n #define TARGET_DEFAULT\t\tALIASES_FLAG | PARALLEL_PACK_FLAG \\\n \t\t\t\t| PARALLEL_MPY_FLAG | RPTB_FLAG\n \n@@ -307,7 +307,7 @@ extern int target_flags;\n \n /* -mrpts            allows the use of the RPTS instruction irregardless.\n    -mrpts=max-cycles will use RPTS if the number of cycles is constant\n-   and less than max-cycles. */\n+   and less than max-cycles.  */\n \n #define TARGET_RPTS_CYCLES(CYCLES) (TARGET_RPTS || (CYCLES) < c4x_rpts_cycles)\n \n@@ -344,7 +344,7 @@ extern char *c4x_rpts_cycles_string, *c4x_cpu_version_string;\n    on a particular target machine.  You can define a macro\n    `OVERRIDE_OPTIONS' to take account of this.  This macro, if\n    defined, is executed once just after all the command options have\n-   been parsed. */\n+   been parsed.  */\n \n extern void c4x_override_options ();\n #define OVERRIDE_OPTIONS c4x_override_options ()\n@@ -364,15 +364,15 @@ extern void c4x_optimization_options ();\n #define WORDS_BIG_ENDIAN\t0\n \n /* Technically, we are little endian, but we put the floats out as\n-   whole longs and this makes GCC put them out in the right order. */\n+   whole longs and this makes GCC put them out in the right order.  */\n \n #define FLOAT_WORDS_BIG_ENDIAN\t1\n \n /* Note the ANSI C standard requires sizeof(char) = 1.  On the C[34]x\n    all integral and floating point data types are stored in memory as\n    32-bits (floating point types can be stored as 40-bits in the\n    extended precision registers), so sizeof(char) = sizeof(short) =\n-   sizeof(int) = sizeof(long) = sizeof(float) = sizeof(double) = 1. */\n+   sizeof(int) = sizeof(long) = sizeof(float) = sizeof(double) = 1.  */\n \n #define BITS_PER_UNIT\t\t32\n #define BITS_PER_WORD\t\t32\n@@ -393,7 +393,7 @@ extern void c4x_optimization_options ();\n #define BITS_PER_LO_SUM 16\n \n /* Use the internal floating point stuff in the compiler and not the\n-   host floating point stuff. */\n+   host floating point stuff.  */\n \n #define REAL_ARITHMETIC\n \n@@ -535,7 +535,7 @@ extern void c4x_optimization_options ();\n #define IS_RC_OR_PSEUDO_REGNO(op)    (IS_RC_OR_PSEUDO_REG(REGNO(op)))\n \n /* 1 for registers that have pervasive standard uses\n-   and are not available for the register allocator. */\n+   and are not available for the register allocator.  */\n \n #define FIXED_REGISTERS \\\n {\t\t\t\t\t\t\t\t\t\\\n@@ -564,7 +564,7 @@ extern void c4x_optimization_options ();\n     1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  1,  0,  1,  1,  1\t\\\n }\n \n-/* Macro to conditionally modify fixed_regs/call_used_regs. */\n+/* Macro to conditionally modify fixed_regs/call_used_regs.  */\n \n #define CONDITIONAL_REGISTER_USAGE\t\t\t\\\n   {\t\t\t\t\t\t\t\\\n@@ -627,7 +627,7 @@ extern void c4x_optimization_options ();\n  ((CLASS) == INDEX_REGS)\n \n /* CCmode is wrongly defined in machmode.def  It should have a size\n-   of UNITS_PER_WORD. */\n+   of UNITS_PER_WORD.  */\n \n #define HARD_REGNO_NREGS(REGNO, MODE)\t\t\t\t\\\n (((MODE) == CCmode || (MODE) == CC_NOOVmode) ? 1 : ((MODE) == HFmode) ? 1 : \\\n@@ -1013,7 +1013,7 @@ c4x_secondary_memory_needed(CLASS1, CLASS2, MODE)\n /* Basic Stack Layout  */\n      \n /* The stack grows upward, stack frame grows upward, and args grow\n-   downward. */\n+   downward.  */\n \n #define STARTING_FRAME_OFFSET\t\tC4X_LOC0\n #define FIRST_PARM_OFFSET(FNDECL)      (C4X_ARG0 + 1)\n@@ -1128,7 +1128,7 @@ extern struct rtx_def *c4x_function_arg();\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) 0\n \n-/* 1 if N is a possible register number for function argument passing. */\n+/* 1 if N is a possible register number for function argument passing.  */\n \n #define FUNCTION_ARG_REGNO_P(REGNO) \\\n \t(  (   ((REGNO) == AR2_REGNO)\t/* AR2 */\t\\\n@@ -1566,7 +1566,7 @@ extern struct rtx_def *c4x_function_arg();\n \n /* CC_NOOVmode should be used when the first operand is a PLUS, MINUS, NEG\n    or MULT.\n-   CCmode should be used when no special processing is needed. */\n+   CCmode should be used when no special processing is needed.  */\n #define SELECT_CC_MODE(OP,X,Y) \\\n   ((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS\t\t\\\n     || GET_CODE (X) == NEG || GET_CODE (X) == MULT\t\t\\\n@@ -1841,7 +1841,7 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n \n #define\tWORD_REGISTER_OPERATIONS\n \n-/* Dividing the Output into Sections  */\n+/* Dividing the Output into Sections.  */\n \n #define TEXT_SECTION_ASM_OP \"\\t.text\"\n \n@@ -1852,7 +1852,7 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n #define CONST_SECTION_ASM_OP \"\\t.sect\\t\\\".const\\\"\"\n \n /* Do not use .init section so __main will be called on startup. This will\n-   call __do_global_ctors and prepare for __do_global_dtors on exit. */\n+   call __do_global_ctors and prepare for __do_global_dtors on exit.  */\n \n #if 0\n #define INIT_SECTION_ASM_OP  \"\\t.sect\\t\\\".init\\\"\"\n@@ -1866,7 +1866,7 @@ if (REG_P (OP1) && ! REG_P (OP0))\t\t\t\\\n    READONLY_DATA_SECTION (giving it some code which switches to the\n    readonly data section) or else you can #define the symbols\n    EXTRA_SECTIONS, EXTRA_SECTION_FUNCTIONS, SELECT_SECTION, and\n-   SELECT_RTX_SECTION.  We do both here just to be on the safe side. */\n+   SELECT_RTX_SECTION.  We do both here just to be on the safe side.  */\n \n /* Define a few machine-specific details of the implementation of\n    constructors.\n@@ -1892,7 +1892,7 @@ do {\t\t\t\t\t\t\t\t\\\n     (*--p) ();\t\t\t\t\t\t\t\\\n } while (0)\n \n-/* The TI tooling uses atexit. */\n+/* The TI tooling uses atexit.  */\n #define\tHAVE_ATEXIT\n \n #undef EXTRA_SECTIONS\n@@ -2067,7 +2067,7 @@ dtors_section ()\t\t\t\t\t\t\t\\\n /* We need to have a data section we can identify so that we can set\n    the DP register back to a data pointer in the small memory model.\n    This is only required for ISRs if we are paranoid that someone\n-   may have quietly changed this register on the sly. */\n+   may have quietly changed this register on the sly.  */\n \n #define ASM_IDENTIFY_GCC(FILE) \\\n     if (! TARGET_TI) fputs (\"gcc2_compiled.:\\n\", FILE);\t\\\n@@ -2283,7 +2283,7 @@ extern void c4x_print_operand ();\n #define PRINT_OPERAND(FILE, X, CODE) c4x_print_operand(FILE, X, CODE)\n \n /* Determine which codes are valid without a following integer.  These must\n-   not be alphabetic. */\n+   not be alphabetic.  */\n \n #define PRINT_OPERAND_PUNCT_VALID_P(CODE) ((CODE) == '#')\n \n@@ -2318,7 +2318,7 @@ extern int c4x_valid_type_attribute_p ();\n \n #define ASM_NO_SKIP_IN_TEXT 1\n \n-/* I'm not sure about this one.  FIXME. */\n+/* I'm not sure about this one.  FIXME.  */\n \n #define ASM_OUTPUT_ALIGN(FILE, LOG)\t\\\n   if ((LOG) != 0)\t\t\t\\\n@@ -2515,7 +2515,7 @@ do { fprintf (asm_out_file, \"\\t.sdef\\t\");\t\t\\\n #define MOVE_MAX 1\n \n /* MOVE_RATIO is the number of move instructions that is better than a\n-   block move. */\n+   block move.  */\n \n #define MOVE_RATIO 2\t\t/* Default value */\n "}]}