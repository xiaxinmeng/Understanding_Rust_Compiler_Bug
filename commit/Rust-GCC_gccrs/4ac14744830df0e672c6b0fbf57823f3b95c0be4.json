{"sha": "4ac14744830df0e672c6b0fbf57823f3b95c0be4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFjMTQ3NDQ4MzBkZjBlNjcyYzZiMGZiZjU3ODIzZjNiOTVjMGJlNA==", "commit": {"author": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-16T18:43:00Z"}, "committer": {"name": "Mike Stump", "email": "mrs@gcc.gnu.org", "date": "1996-05-16T18:43:00Z"}, "message": "86th Cygnus<->FSF quick merge\n\nFrom-SVN: r11974", "tree": {"sha": "1fd63b75624ee907f78b23f718f4b44ac276eec5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1fd63b75624ee907f78b23f718f4b44ac276eec5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ac14744830df0e672c6b0fbf57823f3b95c0be4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac14744830df0e672c6b0fbf57823f3b95c0be4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ac14744830df0e672c6b0fbf57823f3b95c0be4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ac14744830df0e672c6b0fbf57823f3b95c0be4/comments", "author": null, "committer": null, "parents": [{"sha": "62cb090122381c4e7a3058c88a5a5ef192c08e7c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/62cb090122381c4e7a3058c88a5a5ef192c08e7c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/62cb090122381c4e7a3058c88a5a5ef192c08e7c"}], "stats": {"total": 947, "additions": 535, "deletions": 412}, "files": [{"sha": "4b4c2b85df870f0f8237fede284959b47ef97de2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 76, "deletions": 0, "changes": 76, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -3,6 +3,82 @@ Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n \t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n \t(finish_file): Likewise.\n \n+Wed May 15 14:46:14 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_method_call): Allow implicit & on METHOD_TYPEs,\n+\tbut pedwarn as the code is bogus.\n+\t* typeck.c (decay_conversion): Ditto.\n+\t(build_function_call_real): Use build_addr_func instead of\n+\tdefault_conversion.  Don't allow pointer-to-method functions down\n+\there.\n+\t(build_unary_op): Use real pointer-to-member functions instead of\n+\tfake ones.\n+\t(build_ptrmemfunc): Use build_addr_func instead of build_unary_op.\n+\t(convert_for_assignment): Removed some obsolete code.\n+\t* decl2.c (reparse_absdcl_as_expr): Pass current_class_ref to\n+\tbuild_x_function_call instead of current_class_ptr.  Only call\n+\tdigest_init once on an initializer, we do this just checking\n+\tTREE_TYPE.\n+\t(build_expr_from_tree): Pass current_class_ref to\n+\tbuild_x_function_call instead of current_class_ptr.\n+\t* init.c (build_member_call): Ditto.\n+\t* pase.y: Ditto.\n+\t* error.c (dump_expr): Handle OFFSET_REFs better.\n+\t* pt.c (unify): Handle pointer-to-member functions better.\n+\t* decl.c (finish_function): Clear out current_class_ref just like\n+\twe do for current_class_ptr.\n+\n+\t* typeck.c (get_delta_difference): Handle virtual bases better.\n+\n+Tue May 14 16:37:37 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* sig.c (build_signature_table_constructor): Use the delta for\n+\tthe original basetype for this virtual function with thunks.\n+\t(build_signature_method_call): We still need to adjust 'this'\n+\twith thunks.\n+\n+Tue May 14 16:27:25 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* call.c (build_addr_func): New routine.  Used to get the `real'\n+\taddress of a function or a method.  Needed to avoid getting a\n+\tpointer-to-member function.\n+\t(build_call): New routine to build CALL_EXPRs.\n+\t(build_method_call): Use it.\n+\t* cvt.c (convert_to_aggr): Ditto.\n+\t* typeck.c (build_function_call_real): Ditto.\n+\t* sig.c (build_signature_table_constructor): Use build_addr_func.\n+\t* cp-tree.h (build_call, build_addr_func): Declare them.\n+\n+Tue May 14 12:47:47 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* cp-tree.h (LOOKUP_AGGR): Remove, unused.\n+\t* parse.y: Remove uses of LOOKUP_AGGR.\n+\n+Tue May 14 12:07:51 1996  Mike Stump  <mrs@cygnus.com>\n+\n+\t* *.[chy]: Rename current_class_decl to current_class_ptr, and\n+\tC_C_D to current_class_ref.\n+\n+Mon May 13 16:55:23 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* call.c (convert_harshness): Tighten up pointer conversions.\n+\n+Sat May 11 04:33:50 1996  Doug Evans  <dje@canuck.cygnus.com>\n+\n+\t* decl2.c (finish_vtable_vardecl): Surround DECL_ONE_ONLY with ifdef.\n+\t(finish_file): Likewise.\n+\n+Fri May 10 11:09:57 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cvt.c (convert_fn_ptr): We don't use thunks for pmfs.\n+\n+\t* method.c (emit_thunk): Set flag_omit_frame_pointer in default\n+ \tcode.\n+\n+Thu May  9 18:18:30 1996  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* decl2.c: Turn on thunks by default where supported.\n+\n Tue May  7 20:39:57 1996  Mike Stump  <mrs@cygnus.com>\n \n \t* cp-tree.h (build_overload_call_maybe): Removed."}, {"sha": "f51d09b8783cabde73f1bb929a8cd5164001c36a", "filename": "gcc/cp/call.c", "status": "modified", "additions": 92, "deletions": 46, "changes": 138, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -506,12 +506,6 @@ convert_harshness (type, parmtype, parm)\n       if (TREE_CODE (ttl) != VOID_TYPE\n \t  && (TREE_CODE (ttr) != VOID_TYPE || !parm || !integer_zerop (parm)))\n \t{\n-\t  if (TREE_UNSIGNED (ttl) != TREE_UNSIGNED (ttr))\n-\t    {\n-\t      ttl = unsigned_type (ttl);\n-\t      ttr = unsigned_type (ttr);\n-\t      penalty = 10;\n-\t    }\n \t  if (comp_target_types (type, parmtype, 1) <= 0)\n \t    return EVIL_RETURN (h);\n \t}\n@@ -526,22 +520,18 @@ convert_harshness (type, parmtype, parm)\n \treturn EVIL_RETURN (h);\n #endif\n \n-      if (penalty == 10 || ttr == ttl)\n+      if (ttr == ttl)\n \t{\n \t  tree tmp1 = TREE_TYPE (type), tmp2 = TREE_TYPE (parmtype);\n \n-\t  /* If one was unsigned but the other wasn't, then we need to\n-\t     do a standard conversion from T to unsigned T.  */\n-\t  if (penalty == 10)\n-\t    h.code = PROMO_CODE; /* was STD_CODE */\n-\t  else\n-\t    h.code = 0;\n-\n+\t  h.code = 0;\n \t  /* Note conversion from `T*' to `const T*',\n \t                       or `T*' to `volatile T*'.  */\n-\t  if (ttl == ttr\n-\t      && ((TYPE_READONLY (tmp1) != TREE_READONLY (tmp2))\n-\t\t  || (TYPE_VOLATILE (tmp1) != TYPE_VOLATILE (tmp2))))\n+\t  if ((TYPE_READONLY (tmp1) < TREE_READONLY (tmp2))\n+\t      || (TYPE_VOLATILE (tmp1) < TYPE_VOLATILE (tmp2)))\n+\t    h.code = EVIL_CODE;\n+\t  else if ((TYPE_READONLY (tmp1) != TREE_READONLY (tmp2))\n+\t\t   || (TYPE_VOLATILE (tmp1) != TYPE_VOLATILE (tmp2)))\n \t    h.code |= QUAL_CODE;\n \n \t  h.distance = 0;\n@@ -580,8 +570,11 @@ convert_harshness (type, parmtype, parm)\n       if (ttl != ttr)\n \t{\n \t  tree tmp1 = TREE_TYPE (type), tmp2 = TREE_TYPE (parmtype);\n-\t  if ((TYPE_READONLY (tmp1) != TREE_READONLY (tmp2))\n-\t      || (TYPE_VOLATILE (tmp1) != TYPE_VOLATILE (tmp2)))\n+\t  if ((TYPE_READONLY (tmp1) < TREE_READONLY (tmp2))\n+\t      || (TYPE_VOLATILE (tmp1) < TYPE_VOLATILE (tmp2)))\n+\t    h.code = EVIL_CODE;\n+\t  else if ((TYPE_READONLY (tmp1) > TREE_READONLY (tmp2))\n+\t\t   || (TYPE_VOLATILE (tmp1) > TYPE_VOLATILE (tmp2)))\n \t    h.code |= QUAL_CODE;\n \t}\n       return h;\n@@ -1192,7 +1185,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n {\n   tree field, instance;\n \n-  if (instance_ptr == current_class_decl)\n+  if (instance_ptr == current_class_ptr)\n     {\n       /* Check to see if we really have a reference to an instance variable\n \t with `operator()()' overloaded.  */\n@@ -1208,7 +1201,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t{\n \t  /* If it's a field, try overloading operator (),\n \t     or calling if the field is a pointer-to-function.  */\n-\t  instance = build_component_ref_1 (C_C_D, field, 0);\n+\t  instance = build_component_ref_1 (current_class_ref, field, 0);\n \t  if (instance == error_mark_node)\n \t    return error_mark_node;\n \n@@ -1221,7 +1214,7 @@ build_field_call (basetype_path, instance_ptr, name, parms)\n \t      if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == FUNCTION_TYPE)\n \t\treturn build_function_call (instance, parms);\n \t      else if (TREE_CODE (TREE_TYPE (TREE_TYPE (instance))) == METHOD_TYPE)\n-\t\treturn build_function_call (instance, tree_cons (NULL_TREE, current_class_decl, parms));\n+\t\treturn build_function_call (instance, tree_cons (NULL_TREE, current_class_ptr, parms));\n \t    }\n \t}\n       return NULL_TREE;\n@@ -1527,6 +1520,71 @@ print_n_candidates (candidates, n)\n     cp_error_at (\"                %D\", candidates[i].function);\n }\n \n+/* We want the address of a function or method.  We avoid creating a\n+   pointer-to-member function.  */\n+tree\n+build_addr_func (function)\n+     tree function;\n+{\n+  tree type = TREE_TYPE (function);\n+\n+  /* We have to do these by hand to avoid real pointer to member\n+     functions.  */\n+  if (TREE_CODE (type) == METHOD_TYPE)\n+    {\n+      tree addr;\n+\n+      type = build_pointer_type (type);\n+\n+      if (mark_addressable (function) == 0)\n+\treturn error_mark_node;\n+\n+      addr = build1 (ADDR_EXPR, type, function);\n+\n+      /* Address of a static or external variable or function counts\n+\t as a constant */\n+      if (staticp (function))\n+\tTREE_CONSTANT (addr) = 1;\n+\n+      function = addr;\n+    }\n+  else\n+    function = default_conversion (function);\n+\n+  return function;\n+}\n+\n+/* Build a CALL_EXPR, we can handle FUNCTION_TYPEs, METHOD_TYPEs, or\n+   POINTER_TYPE to those.  Note, pointer to member function types\n+   (TYPE_PTRMEMFUNC_P) must be handled by our callers.  */\n+tree\n+build_call (function, result_type, parms)\n+     tree function, result_type, parms;\n+{\n+  int is_constructor = 0;\n+\n+  function = build_addr_func (function);\n+\n+  if (TYPE_PTRMEMFUNC_P (TREE_TYPE (function)))\n+    {\n+      sorry (\"unable to call pointer to member function here\");\n+      return error_mark_node;\n+    }\n+\n+  if (TREE_CODE (function) == ADDR_EXPR\n+      && TREE_CODE (TREE_OPERAND (function, 0)) == FUNCTION_DECL\n+      && DECL_CONSTRUCTOR_P (TREE_OPERAND (function, 0)))\n+    is_constructor = 1;\n+\n+  function = build_nt (CALL_EXPR, function, parms, NULL_TREE);\n+  TREE_HAS_CONSTRUCTOR (function) = is_constructor;\n+  TREE_TYPE (function) = result_type;\n+  TREE_SIDE_EFFECTS (function) = 1;\n+  \n+  return function;\n+}\n+\n+\n /* Build something of the form ptr->method (args)\n    or object.method (args).  This can also build\n    calls to constructors, and find friends.\n@@ -1739,11 +1797,11 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  return error_mark_node;\n \t}\n     }\n-  else if (instance == C_C_D || instance == current_class_decl)\n+  else if (instance == current_class_ref || instance == current_class_ptr)\n     {\n       /* When doing initialization, we side-effect the TREE_TYPE of\n-\t C_C_D, hence we cannot set up BASETYPE from CURRENT_CLASS_TYPE.  */\n-      basetype = TREE_TYPE (C_C_D);\n+\t current_class_ref, hence we cannot set up BASETYPE from CURRENT_CLASS_TYPE.  */\n+      basetype = TREE_TYPE (current_class_ref);\n \n       /* Anything manifestly `this' in constructors and destructors\n \t has a known type, so virtual function tables are not needed.  */\n@@ -1765,8 +1823,8 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t}\n       else\n \t{\n-\t  instance = C_C_D;\n-\t  instance_ptr = current_class_decl;\n+\t  instance = current_class_ref;\n+\t  instance_ptr = current_class_ptr;\n \t  basetype_path = TYPE_BINFO (current_class_type);\n \t}\n       result = build_field_call (basetype_path, instance_ptr, name, parms);\n@@ -1940,9 +1998,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n \t  TREE_VALUE (parm) = resolve_offset_ref (TREE_VALUE (parm));\n \t  t = TREE_TYPE (TREE_VALUE (parm));\n \t}\n-      if (TREE_CODE (TREE_VALUE (parm)) == OFFSET_REF\n-\t  && TREE_CODE (t) == METHOD_TYPE)\n+      if (TREE_CODE (t) == METHOD_TYPE)\n \t{\n+\t  cp_pedwarn (\"assuming & on `%E'\", TREE_VALUE (parm));\n \t  TREE_VALUE (parm) = build_unary_op (ADDR_EXPR, TREE_VALUE (parm), 0);\n \t}\n #if 0\n@@ -2365,7 +2423,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n      type (if it exists) is a pointer to.  */\n \n   if (DECL_ABSTRACT_VIRTUAL_P (function)\n-      && instance == C_C_D\n+      && instance == current_class_ref\n       && DECL_CONSTRUCTOR_P (current_function_decl)\n       && ! (flags & LOOKUP_NONVIRTUAL)\n       && value_member (function, get_abstract_virtuals (basetype)))\n@@ -2422,7 +2480,7 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     {\n       /* Let's be nasty to the user now, and give reasonable\n \t error messages.  */\n-      instance_ptr = current_class_decl;\n+      instance_ptr = current_class_ptr;\n       if (instance_ptr)\n \t{\n \t  if (basetype != current_class_type)\n@@ -2540,21 +2598,9 @@ build_method_call (instance, name, parms, basetype_path, flags)\n     GNU_xref_call (current_function_decl,\n \t\t   IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (function)));\n \n-  {\n-    int is_constructor\n-      = TREE_CODE (function) == FUNCTION_DECL\n-\t&& DECL_CONSTRUCTOR_P (function);\n-\n-    function = default_conversion (function);\n-\n-    result = build_nt (CALL_EXPR, function, parms, NULL_TREE);\n-\n-    TREE_TYPE (result) = value_type;\n-    TREE_SIDE_EFFECTS (result) = 1;\n-    TREE_HAS_CONSTRUCTOR (result) = is_constructor;\n-    result = convert_from_reference (result);\n-    return result;\n-  }\n+  result = build_call (function, value_type, parms);\n+  result = convert_from_reference (result);\n+  return result;\n }\n \n /* Similar to `build_method_call', but for overloaded non-member functions."}, {"sha": "4c6cf3ecd714ea1a09eef5ab74e3125023aaa355", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -72,7 +72,9 @@ struct class_level\n   int unused;\n };\n \n-tree current_class_decl, C_C_D;\t/* PARM_DECL: the class instance variable */\n+/* The currect_class_ptr is the pointer to the current class.\n+   current_class_ref is the actual current class.  */\n+tree current_class_ptr, current_class_ref;\n \n /* The following two can be derived from the previous one */\n tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n@@ -434,7 +436,7 @@ build_vtbl_ref (instance, idx)\n   if (TREE_CODE (basetype) == REFERENCE_TYPE)\n     basetype = TREE_TYPE (basetype);\n \n-  if (instance == C_C_D)\n+  if (instance == current_class_ref)\n     vtbl = build_indirect_ref (build_vfield_ref (instance, basetype),\n \t\t\t       NULL_PTR);\n   else\n@@ -4494,7 +4496,7 @@ resolves_to_fixed_type_p (instance, nonnull)\n \t}\n       else if (nonnull)\n \t{\n-\t  if (instance == current_class_decl\n+\t  if (instance == current_class_ptr\n \t      && flag_this_is_variable <= 0)\n \t    {\n \t      /* Some people still use `this = 0' inside destructors.  */\n@@ -4941,12 +4943,6 @@ instantiate_type (lhstype, rhs, complain)\n \ttree elem, baselink, name;\n \tint globals = overloaded_globals_p (rhs);\n \n-#if 0 /* obsolete */\n-\t/* If there's only one function we know about, return that.  */\n-\tif (globals > 0 && TREE_CHAIN (rhs) == NULL_TREE)\n-\t  return TREE_VALUE (rhs);\n-#endif\n-\n \t/* First look for an exact match.  Search either overloaded\n \t   functions or member functions.  May have to undo what\n \t   `default_conversion' might do to lhstype.  */"}, {"sha": "cb850e077ce26d6755456b17f2497d7692779ad1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -1002,7 +1002,7 @@ struct lang_decl\n \n /* Nonzero for FUNCTION_DECL means that this constructor is known to\n    not make any assignment to `this', and therefore can be trusted\n-   to return it unchanged.  Otherwise, we must re-assign `current_class_decl'\n+   to return it unchanged.  Otherwise, we must re-assign `current_class_ptr'\n    after performing base initializations.  */\n #define DECL_PRESERVES_THIS(NODE) (DECL_LANG_SPECIFIC(NODE)->decl_flags.preserves_first_arg)\n \n@@ -1551,7 +1551,8 @@ extern tree current_lang_name, lang_name_cplusplus, lang_name_c;\n    of CURRENT_FUNCTION_DECL due to overloading */\n extern tree original_function_name;\n \n-extern tree current_class_name, current_class_type, current_class_decl, C_C_D;\n+extern tree current_class_name, current_class_type;\n+extern tree current_class_ptr, current_class_ref;\n \n /* in init.c  */\n extern tree global_base_init_list;\n@@ -1820,8 +1821,6 @@ extern int at_eof;\n \n enum overload_flags { NO_SPECIAL = 0, DTOR_FLAG, OP_FLAG, TYPENAME_FLAG };\n \n-extern tree current_class_decl, C_C_D;\t/* PARM_DECL: the class instance variable */\n-\n /* The following two can be derived from the previous one */\n extern tree current_class_name;\t/* IDENTIFIER_NODE: name of current class */\n extern tree current_class_type;\t/* _TYPE: the type of the current class */\n@@ -1838,7 +1837,6 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n    LOOKUP_COMPLAIN mean complain if no suitable member function\n      matching the arguments is found.\n    LOOKUP_NORMAL is just a combination of these two.\n-   LOOKUP_AGGR requires the instance to be of aggregate type.\n    LOOKUP_NONVIRTUAL means make a direct call to the member function found\n    LOOKUP_GLOBAL means search through the space of overloaded functions,\n      as well as the space of member functions.\n@@ -1858,7 +1856,7 @@ extern tree current_class_type;\t/* _TYPE: the type of the current class */\n #define LOOKUP_PROTECT (1)\n #define LOOKUP_COMPLAIN (2)\n #define LOOKUP_NORMAL (3)\n-#define LOOKUP_AGGR (4)\n+/* #define LOOKUP_UNUSED (4) */\n #define LOOKUP_NONVIRTUAL (8)\n #define LOOKUP_GLOBAL (16)\n #define LOOKUP_HAS_IN_CHARGE (32)\n@@ -1941,6 +1939,8 @@ extern int get_arglist_len_in_bytes\t\tPROTO((tree));\n extern tree build_vfield_ref\t\t\tPROTO((tree, tree));\n extern tree find_scoped_type\t\t\tPROTO((tree, tree, tree));\n extern tree resolve_scope_to_name\t\tPROTO((tree, tree));\n+extern tree build_call\t\t\t\tPROTO((tree, tree, tree));\n+extern tree build_addr_func\t\t\tPROTO((tree));\n extern tree build_scoped_method_call\t\tPROTO((tree, tree, tree, tree));\n extern tree build_method_call\t\t\tPROTO((tree, tree, tree, tree, int));\n extern tree build_overload_call_real\t\tPROTO((tree, tree, int, struct candidate *, int));"}, {"sha": "972939e6e4c32fcf814440a7a89d975c6a59b498", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 171, "deletions": 9, "changes": 180, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -82,6 +82,7 @@ static tree\n convert_fn_ptr (type, expr)\n      tree type, expr;\n {\n+#if 0\t\t\t\t/* We don't use thunks for pmfs.  */\n   if (flag_vtable_thunks)\n     {\n       tree intype = TREE_TYPE (expr);\n@@ -104,6 +105,7 @@ convert_fn_ptr (type, expr)\n       return build1 (NOP_EXPR, type, build_thunk (BINFO_OFFSET (binfo), expr));\n     }\n   else\n+#endif\n     return build_ptrmemfunc (type, expr, 1);\n }\n \n@@ -477,7 +479,7 @@ build_up_reference (type, arg, flags, checkconst)\n \n     case PARM_DECL:\n #if 0\n-      if (targ == current_class_decl)\n+      if (targ == current_class_ptr)\n \t{\n \t  error (\"address of `this' not available\");\n /* #if 0 */\t  \n@@ -1056,14 +1058,11 @@ convert_to_aggr (type, expr, msgp, protect)\n     return NULL_TREE;\n \n   fntype = TREE_TYPE (function);\n-  function = default_conversion (function);\n-\n-  result = build_nt (CALL_EXPR, function,\n-\t\t     convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n-\t\t\t\t\tparmlist, NULL_TREE, LOOKUP_NORMAL),\n-\t\t     NULL_TREE);\n-  TREE_TYPE (result) = TREE_TYPE (fntype);\n-  TREE_SIDE_EFFECTS (result) = 1;\n+\n+  parmlist = convert_arguments (NULL_TREE, TYPE_ARG_TYPES (fntype),\n+\t\t\t\tparmlist, NULL_TREE, LOOKUP_NORMAL);\n+\n+  result = build_call (function, TREE_TYPE (fntype), parmlist);\n   return result;\n }\n \n@@ -1809,3 +1808,166 @@ type_promotes_to (type)\n \n   return cp_build_type_variant (type, constp, volatilep);\n }\n+\n+#if 0\n+/* Work in progress.  Ask jason before removing. */\n+\n+int\n+null_ptr_cst (t)\n+     tree t;\n+{\n+  return (INTEGRAL_TYPE_P (TREE_TYPE (t)) && integer_zerop (t));\n+}\n+\n+tree\n+standard_conversion (to, from, expr)\n+     tree to, from, expr;\n+{\n+  enum tree_code fcode = TREE_CODE (from);\n+  enum tree_code tcode = TREE_CODE (to);\n+  tree conv;\n+\n+  if (from == to)\n+    return from;\n+\n+  conv = from;\n+\n+  if (fcode == FUNCTION_TYPE)\n+    {\n+      from = build_pointer_type (from);\n+      fcode = TREE_CODE (from);\n+      conv = build1 (LVALUE_CONV, from, conv);\n+    }\n+  else if (fcode == ARRAY_TYPE)\n+    {\n+      from = build_pointer_type (TREE_TYPE (from));\n+      fcode = TREE_CODE (from);\n+      conv = build1 (LVALUE_CONV, from, conv);\n+    }\n+\n+  if ((tcode == POINTER_TYPE || TYPE_PTRMEMFUNC_P (to))\n+      && expr && null_ptr_cst (expr))\n+    {\n+      conv = build1 (CONV_CONV, to, conv);\n+    }\n+  else if (tcode == POINTER_TYPE && fcode == POINTER_TYPE)\n+    {\n+      enum tree_code ufcode = TREE_CODE (TREE_TYPE (from));\n+      enum tree_code utcode = TREE_CODE (TREE_TYPE (to));\n+\n+      if (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n+\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))), 1))\n+\t/* OK for now */;\n+      else if (utcode == VOID_TYPE && ufcode != OFFSET_TYPE\n+\t       && ufcode != FUNCTION_TYPE)\n+\t{\n+\t  from = cp_build_type_variant (void_type_node,\n+\t\t\t\t\tTYPE_READONLY (TREE_TYPE (from)),\n+\t\t\t\t\tTYPE_VOLATILE (TREE_TYPE (from)));\n+\t  conv = build1 (CONV_CONV, from, conv);\n+\t}\n+      else if (ufcode == OFFSET_TYPE && utcode == OFFSET_TYPE)\n+\t{\n+\t  tree fbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (from));\n+\t  tree tbase = TYPE_OFFSET_BASETYPE (TREE_TYPE (to));\n+\n+\t  if (DERIVED_FROM_P (tbase, fbase)\n+\t      && (comptypes (TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (from))),\n+\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (to))),\n+\t\t\t     1)))\n+\t    {\n+\t      from = build_offset_type (tbase, TREE_TYPE (TREE_TYPE (from)));\n+\t      conv = build1 (CONV_CONV, from, conv);\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else if (IS_AGGR_TYPE (TREE_TYPE (from))\n+\t       && IS_AGGR_TYPE (TREE_TYPE (to)))\n+\t{\n+\t  if (DERIVED_FROM_P (TREE_TYPE (to), TREE_TYPE (from)))\n+\t    {\n+\t      from = cp_build_type_variant (TREE_TYPE (to),\n+\t\t\t\t\t    TYPE_READONLY (TREE_TYPE (from)),\n+\t\t\t\t\t    TYPE_VOLATILE (TREE_TYPE (from)));\n+\t      conv = build1 (CONV_CONV, from, conv);\n+\t    }\n+\t  else\n+\t    return 0;\n+\t}\n+      else\n+\treturn 0;\n+\n+      if (! comptypes (from, to, 1) && comp_ptr_ttypes (to, from))\n+\t{\n+\t  from = to;\n+\t  conv = build1 (QUAL_CONV, from, conv);\n+\t}\n+    }\n+  else if (TYPE_PTRMEMFUNC_P (to) && TYPE_PTRMEMFUNC_P (from))\n+    {\n+      tree fromfn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (from));\n+      tree tofn = TREE_TYPE (TYPE_PTRMEMFUNC_FN_TYPE (to));\n+      tree fbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (fromfn)));\n+      tree tbase = TREE_TYPE (TREE_VALUE (TYPE_ARG_TYPES (tofn)));\n+\n+      if (! DERIVED_FROM_P (tbase, fbase)\n+\t  || ! comptypes (TREE_TYPE (fromfn), TREE_TYPE (tofn), 1)\n+\t  || ! compparms (TREE_CHAIN (TYPE_ARG_TYPES (fromfn)),\n+\t\t\t  TREE_CHAIN (TYPE_ARG_TYPES (tofn)), 1)\n+\t  || TYPE_READONLY (fbase) != TYPE_READONLY (tbase)\n+\t  || TYPE_VOLATILE (fbase) != TYPE_VOLATILE (tbase))\n+\treturn 0;\n+\n+      from = cp_build_type_variant (tbase, TYPE_READONLY (fbase),\n+\t\t\t\t    TYPE_VOLATILE (fbase));\n+      from = build_cplus_method_type (from, TREE_TYPE (fromfn),\n+\t\t\t\t      TREE_CHAIN (TYPE_ARG_TYPES (fromfn)));\n+      conv = build1 (CONV_CONV, from, conv);\n+    }\n+  else if (tcode == BOOLEAN_TYPE)\n+    {\n+      if (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE\n+\t  || fcode == POINTER_TYPE)\n+\treturn build1 (CONV_CONV, to, conv);\n+      else\n+\treturn 0;\n+    }\n+  else if (INTEGRAL_CODE_P (tcode) || tcode == REAL_TYPE)\n+    {\n+      if (! (INTEGRAL_CODE_P (fcode) || fcode == REAL_TYPE))\n+\treturn 0;\n+      else if (to == type_promotes_to (from))\n+\tconv = build1 (PROMO_CONV, to, conv);\n+      else \n+\tconv = build1 (CONV_CONV, to, conv);\n+    }\n+  else if (IS_AGGR_TYPE (to) && IS_AGGR_TYPE (from)\n+\t   && DERIVED_FROM_P (to, from))\n+    {\n+      conv = build1 (CONV_CONV, to, conv);\n+    }\n+  else\n+    return 0;\n+\n+  return conv;\n+}\n+\n+tree\n+implicit_conversion (to, from, expr, flags)\n+     tree to, from, expr;\n+     int flags;\n+{\n+  tree conv = standard_conversion (to, from, expr);\n+\n+  if (conv || (flags & LOOKUP_NO_CONVERSION))\n+    return conv;\n+\n+  flags |= LOOKUP_NO_CONVERSION;\n+\n+    /* try constructors */;\n+    /* try conversion ops */;\n+\n+  return conv;\n+}\n+#endif"}, {"sha": "73b570945d290ecfadfc8bdaadcf0508adc8ffc2", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 29, "deletions": 28, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -3275,7 +3275,7 @@ pushdecl (x)\n \t      if (oldlocal != NULL_TREE && TREE_CODE (oldlocal) == PARM_DECL)\n \t\twarnstring = \"declaration of `%s' shadows a parameter\";\n \t      else if (IDENTIFIER_CLASS_VALUE (name) != NULL_TREE\n-\t\t       && current_class_decl\n+\t\t       && current_class_ptr\n \t\t       && !TREE_STATIC (name))\n \t\twarnstring = \"declaration of `%s' shadows a member of `this'\";\n \t      else if (oldlocal != NULL_TREE)\n@@ -11075,14 +11075,14 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n       push_nested_class (ctype, 1);\n \n       /* If we're compiling a friend function, neither of the variables\n-\t current_class_decl nor current_class_type will have values.  */\n+\t current_class_ptr nor current_class_type will have values.  */\n       if (! doing_friend)\n \t{\n \t  /* We know that this was set up by `grokclassfn'.\n \t     We do not wait until `store_parm_decls', since evil\n \t     parse errors may never get us to that point.  Here\n \t     we keep the consistency between `current_class_type'\n-\t     and `current_class_decl'.  */\n+\t     and `current_class_ptr'.  */\n \t  tree t = current_function_parms;\n \n \t  my_friendly_assert (t != NULL_TREE\n@@ -11093,14 +11093,14 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \t      int i = suspend_momentary ();\n \n \t      /* Fool build_indirect_ref.  */\n-\t      current_class_decl = NULL_TREE;\n-\t      C_C_D = build_indirect_ref (t, NULL_PTR);\n-\t      current_class_decl = t;\n+\t      current_class_ptr = NULL_TREE;\n+\t      current_class_ref = build_indirect_ref (t, NULL_PTR);\n+\t      current_class_ptr = t;\n \t      resume_momentary (i);\n \t    }\n \t  else\n \t    /* We're having a signature pointer here.  */\n-\t    C_C_D = current_class_decl = t;\n+\t    current_class_ref = current_class_ptr = t;\n \n \t}\n     }\n@@ -11110,7 +11110,7 @@ start_function (declspecs, declarator, raises, attrs, pre_parsed_p)\n \tpush_nested_class (DECL_CONTEXT (decl1), 2);\n       else\n \tpush_memoized_context (0, 1);\n-      current_class_decl = C_C_D = NULL_TREE;\n+      current_class_ptr = current_class_ref = NULL_TREE;\n     }\n \n   pushlevel (0);\n@@ -11502,7 +11502,7 @@ finish_function (lineno, call_poplevel, nested)\n \n \t  if (current_function_assigns_this)\n \t    cond = build (NE_EXPR, boolean_type_node,\n-\t\t\t  current_class_decl, integer_zero_node);\n+\t\t\t  current_class_ptr, integer_zero_node);\n \t  else\n \t    {\n \t      int n_baseclasses = CLASSTYPE_N_BASECLASSES (current_class_type);\n@@ -11541,10 +11541,10 @@ finish_function (lineno, call_poplevel, nested)\n \t  /* These are two cases where we cannot delegate deletion.  */\n \t  if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type)\n \t      || TYPE_GETS_REG_DELETE (current_class_type))\n-\t    exprstmt = build_delete (current_class_type, C_C_D, integer_zero_node,\n+\t    exprstmt = build_delete (current_class_type, current_class_ref, integer_zero_node,\n \t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \t  else\n-\t    exprstmt = build_delete (current_class_type, C_C_D, in_charge_node,\n+\t    exprstmt = build_delete (current_class_type, current_class_ref, in_charge_node,\n \t\t\t\t     LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n \t  /* If we did not assign to this, then `this' is non-zero at\n@@ -11576,7 +11576,7 @@ finish_function (lineno, call_poplevel, nested)\n \t\t    {\n \t\t      if (TYPE_NEEDS_DESTRUCTOR (BINFO_TYPE (vbases)))\n \t\t\t{\n-\t\t\t  tree ptr = convert_pointer_to_vbase (BINFO_TYPE (vbases), current_class_decl);\n+\t\t\t  tree ptr = convert_pointer_to_vbase (BINFO_TYPE (vbases), current_class_ptr);\n \t\t\t  expand_expr_stmt (build_delete (build_pointer_type (BINFO_TYPE (vbases)),\n \t\t\t\t\t\t\t  ptr, integer_zero_node,\n \t\t\t\t\t\t\t  LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR|LOOKUP_HAS_IN_CHARGE, 0));\n@@ -11605,11 +11605,11 @@ finish_function (lineno, call_poplevel, nested)\n \t\t\t  error_mark_node),\n \t\t  NULL_PTR),\n \t\t ansi_opname[(int) DELETE_EXPR],\n-\t\t tree_cons (NULL_TREE, current_class_decl,\n+\t\t tree_cons (NULL_TREE, current_class_ptr,\n \t\t\t    build_tree_list (NULL_TREE, virtual_size)),\n \t\t NULL_TREE, LOOKUP_NORMAL);\n \t  else if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t    exprstmt = build_x_delete (ptr_type_node, current_class_decl, 0,\n+\t    exprstmt = build_x_delete (ptr_type_node, current_class_ptr, 0,\n \t\t\t\t       virtual_size);\n \t  else\n \t    exprstmt = NULL_TREE;\n@@ -11646,16 +11646,16 @@ finish_function (lineno, call_poplevel, nested)\n \t      /* Make all virtual function table pointers in non-virtual base\n \t\t classes point to CURRENT_CLASS_TYPE's virtual function\n \t\t tables.  */\n-\t      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_decl);\n+\t      expand_direct_vtbls_init (binfo, binfo, 1, 0, current_class_ptr);\n \n \t      if (TYPE_USES_VIRTUAL_BASECLASSES (current_class_type))\n-\t\texpand_indirect_vtbls_init (binfo, C_C_D, current_class_decl);\n+\t\texpand_indirect_vtbls_init (binfo, current_class_ref, current_class_ptr);\n \t    }\n \t  \n \t  if (! ok_to_optimize_dtor)\n \t    {\n \t      cond = build_binary_op (NE_EXPR,\n-\t\t\t\t      current_class_decl, integer_zero_node, 1);\n+\t\t\t\t      current_class_ptr, integer_zero_node, 1);\n \t      expand_start_cond (cond, 0);\n \t    }\n \n@@ -11691,7 +11691,7 @@ finish_function (lineno, call_poplevel, nested)\n \t\t  expand_end_bindings (decls, decls != NULL_TREE, 0);\n \t\t  poplevel (decls != NULL_TREE, 0, 0);\n \t\t}\n-\t      c_expand_return (current_class_decl);\n+\t      c_expand_return (current_class_ptr);\n \t    }\n \t  else if (TYPE_MAIN_VARIANT (TREE_TYPE (\n \t\t\t\t\t\t DECL_RESULT (current_function_decl))) != void_type_node\n@@ -11715,8 +11715,8 @@ finish_function (lineno, call_poplevel, nested)\n \t  if (flag_this_is_variable > 0)\n \t    {\n \t      cond = build_binary_op (EQ_EXPR,\n-\t\t\t\t      current_class_decl, integer_zero_node, 1);\n-\t      thenclause = build_modify_expr (current_class_decl, NOP_EXPR,\n+\t\t\t\t      current_class_ptr, integer_zero_node, 1);\n+\t      thenclause = build_modify_expr (current_class_ptr, NOP_EXPR,\n \t\t\t\t\t      build_new (NULL_TREE, current_class_type, void_type_node, 0));\n \t    }\n \n@@ -11769,7 +11769,7 @@ finish_function (lineno, call_poplevel, nested)\n \t      poplevel (decls != NULL_TREE, 1, 0);\n \t    }\n \n-\t  c_expand_return (current_class_decl);\n+\t  c_expand_return (current_class_ptr);\n \n \t  current_function_assigns_this = 0;\n \t  current_function_just_assigned_this = 0;\n@@ -11974,7 +11974,8 @@ finish_function (lineno, call_poplevel, nested)\n     }\n \n   named_label_uses = NULL_TREE;\n-  current_class_decl = NULL_TREE;\n+  current_class_ptr = NULL_TREE;\n+  current_class_ref = NULL_TREE;\n }\n \f\n /* Create the FUNCTION_DECL for a function definition.\n@@ -12412,8 +12413,8 @@ struct cp_function\n   tree base_init_list;\n   tree member_init_list;\n   tree base_init_expr;\n-  tree class_decl;\n-  tree C_C_D;\n+  tree current_class_ptr;\n+  tree current_class_ref;\n   rtx result_rtx;\n   struct cp_function *next;\n   struct binding_level *binding_level;\n@@ -12459,8 +12460,8 @@ push_cp_function_context (context)\n   p->temp_name_counter = temp_name_counter;\n   p->base_init_list = current_base_init_list;\n   p->member_init_list = current_member_init_list;\n-  p->class_decl = current_class_decl;\n-  p->C_C_D = C_C_D;\n+  p->current_class_ptr = current_class_ptr;\n+  p->current_class_ref = current_class_ref;\n \n   p->eh_context = push_eh_context ();\n }\n@@ -12502,8 +12503,8 @@ pop_cp_function_context (context)\n   temp_name_counter = p->temp_name_counter;\n   current_base_init_list = p->base_init_list;\n   current_member_init_list = p->member_init_list;\n-  current_class_decl = p->class_decl;\n-  C_C_D = p->C_C_D;\n+  current_class_ptr = p->current_class_ptr;\n+  current_class_ref = p->current_class_ref;\n \n   pop_eh_context (p->eh_context);\n "}, {"sha": "18fb1af8606afb4ec85881115f97301512f70a25", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -155,9 +155,13 @@ int warn_implicit = 1;\n int warn_ctor_dtor_privacy = 1;\n \n /* True if we want to implement vtables using \"thunks\".\n-   The default is off now, but will be on later. */\n+   The default is off by default, on if explicitly supported. */\n \n+#ifdef ASM_OUTPUT_MI_THUNK\n+int flag_vtable_thunks = 1;\n+#else\n int flag_vtable_thunks;\n+#endif\n \n /* True if we want to deal with repository information.  */\n \n@@ -3336,7 +3340,7 @@ reparse_absdcl_as_expr (type, decl)\n   /* recurse */\n   decl = reparse_decl_as_expr (type, TREE_OPERAND (decl, 0));\n \n-  decl = build_x_function_call (decl, NULL_TREE, current_class_decl);\n+  decl = build_x_function_call (decl, NULL_TREE, current_class_ref);\n \n   if (TREE_CODE (decl) == CALL_EXPR && TREE_TYPE (decl) != void_type_node)\n     decl = require_complete_type (decl);\n@@ -3357,7 +3361,8 @@ reparse_absdcl_as_casts (decl, expr)\n {\n   tree type;\n   \n-  if (TREE_CODE (expr) == CONSTRUCTOR)\n+  if (TREE_CODE (expr) == CONSTRUCTOR\n+      && TREE_TYPE (expr) == 0)\n     {\n       type = groktypename (TREE_VALUE (TREE_OPERAND (decl, 1)));\n       decl = TREE_OPERAND (decl, 0);\n@@ -3556,7 +3561,7 @@ build_expr_from_tree (t)\n \t    name = build_expr_from_tree (name);\n \t  return build_x_function_call\n \t    (name, build_expr_from_tree (TREE_OPERAND (t, 1)),\n-\t     current_class_decl);\n+\t     current_class_ref);\n \t}\n \n     case COND_EXPR:"}, {"sha": "1f661558869e349e7b2099bca5739514d288f08d", "filename": "gcc/cp/error.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ferror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ferror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ferror.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -1259,8 +1259,9 @@ dump_expr (t, nop)\n \t  dump_expr (TREE_OPERAND (t, 1), 0);\n \telse\n \t  {\n-\t    sorry (\"operand of OFFSET_REF not understood\");\n-\t    goto error;\n+\t    dump_expr (TREE_OPERAND (t, 0), 0);\n+\t    OB_PUTS (\" .* \");\n+\t    dump_expr (TREE_OPERAND (t, 1), 0);\n \t  }\n \tbreak;\n       }"}, {"sha": "5695c980f62c8b385798f15a994dfc2f81968788", "filename": "gcc/cp/init.c", "status": "modified", "additions": 32, "deletions": 32, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -174,7 +174,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n       if (init != NULL_TREE && TREE_CODE (init) != TREE_LIST)\n \tinit = build_tree_list (NULL_TREE, init);\n \n-      decl = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n+      decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n \n       if (explicit\n \t  && TREE_CODE (type) == ARRAY_TYPE\n@@ -220,7 +220,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n \t current_member_init_list.  */\n       if (init || explicit)\n \t{\n-\t  decl = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n+\t  decl = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n \t  expand_expr_stmt (build_modify_expr (decl, INIT_EXPR, init));\n \t}\n     }\n@@ -237,7 +237,7 @@ perform_member_init (member, name, init, explicit, protect_list)\n \n   if (TYPE_NEEDS_DESTRUCTOR (type))\n     {\n-      tree expr = build_component_ref (C_C_D, name, NULL_TREE, explicit);\n+      tree expr = build_component_ref (current_class_ref, name, NULL_TREE, explicit);\n       expr = build_delete (type, expr, integer_zero_node,\n \t\t\t   LOOKUP_NONVIRTUAL|LOOKUP_DESTRUCTOR, 0);\n \n@@ -487,7 +487,7 @@ build_partial_cleanup_for (binfo)\n      tree binfo;\n {\n   tree expr = convert_pointer_to_real (binfo,\n-\t\t\t\t       build_unary_op (ADDR_EXPR, C_C_D, 0));\n+\t\t\t\t       build_unary_op (ADDR_EXPR, current_class_ref, 0));\n \n   return build_delete (TREE_TYPE (expr),\n \t\t       expr,\n@@ -561,7 +561,7 @@ emit_base_init (t, immediately)\n       tree first_arg = TREE_CHAIN (DECL_ARGUMENTS (current_function_decl));\n \n       expand_start_cond (first_arg, 0);\n-      expand_aggr_vbase_init (t_binfo, C_C_D, current_class_decl,\n+      expand_aggr_vbase_init (t_binfo, current_class_ref, current_class_ptr,\n \t\t\t      vbase_init_list);\n       expand_end_cond ();\n     }\n@@ -596,7 +596,7 @@ emit_base_init (t, immediately)\n \t  push_temp_slots ();\n \t  target_temp_slot_level = temp_slot_level;\n \n-\t  member = convert_pointer_to_real (base_binfo, current_class_decl);\n+\t  member = convert_pointer_to_real (base_binfo, current_class_ptr);\n \t  expand_aggr_init_1 (base_binfo, NULL_TREE,\n \t\t\t      build_indirect_ref (member, NULL_PTR), init,\n \t\t\t      BINFO_OFFSET_ZEROP (base_binfo), LOOKUP_NORMAL);\n@@ -626,11 +626,11 @@ emit_base_init (t, immediately)\n   /* Initialize all the virtual function table fields that\n      do come from virtual base classes. */\n   if (TYPE_USES_VIRTUAL_BASECLASSES (t))\n-    expand_indirect_vtbls_init (t_binfo, C_C_D, current_class_decl);\n+    expand_indirect_vtbls_init (t_binfo, current_class_ref, current_class_ptr);\n \n   /* Initialize all the virtual function table fields that\n      do not come from virtual base classes.  */\n-  expand_direct_vtbls_init (t_binfo, t_binfo, 1, 1, current_class_decl);\n+  expand_direct_vtbls_init (t_binfo, t_binfo, 1, 1, current_class_ptr);\n \n   for (member = TYPE_FIELDS (t); member; member = TREE_CHAIN (member))\n     {\n@@ -863,7 +863,7 @@ do_member_init (s_id, name, init)\n       return;\n     }\n \n-  base = convert_pointer_to (binfo, current_class_decl);\n+  base = convert_pointer_to (binfo, current_class_ptr);\n   expand_member_init (build_indirect_ref (base, NULL_PTR), name, init);\n }\n \n@@ -1139,8 +1139,9 @@ expand_member_init (exp, name, init)\n    explaining that such initializations are invalid.\n \n    ALIAS_THIS is nonzero iff we are initializing something which is\n-   essentially an alias for C_C_D.  In this case, the base constructor\n-   may move it on us, and we must keep track of such deviations.\n+   essentially an alias for current_class_ref.  In this case, the base\n+   constructor may move it on us, and we must keep track of such\n+   deviations.\n \n    If INIT resolves to a CALL_EXPR which happens to return\n    something of the type we are looking for, then we know\n@@ -1160,8 +1161,7 @@ expand_member_init (exp, name, init)\n    initialization.\n \n    A constructor or a conversion operator may have to be used to\n-   perform the initialization, but not both, as it would be ambiguous.\n-   */\n+   perform the initialization, but not both, as it would be ambiguous. */\n \n void\n expand_aggr_init (exp, init, alias_this, flags)\n@@ -1318,8 +1318,8 @@ expand_default_init (binfo, true_exp, exp, init, alias_this, flags)\n \t     value is used in the derived class.  */\n \t  if ((flag_this_is_variable & 1) && alias_this)\n \t    {\n-\t      TREE_TYPE (rval) = TREE_TYPE (current_class_decl);\n-\t      expand_assignment (current_class_decl, rval, 0, 0);\n+\t      TREE_TYPE (rval) = TREE_TYPE (current_class_ptr);\n+\t      expand_assignment (current_class_ptr, rval, 0, 0);\n \t    }\n \t  else\n \t    expand_expr_stmt (rval);\n@@ -1676,7 +1676,7 @@ build_member_call (type, name, parmlist)\n       tree ns = lookup_name (type, 0);\n       if (ns && TREE_CODE (ns) == NAMESPACE_DECL)\n \t{\n-\t  return build_x_function_call (build_offset_ref (type, name), parmlist, current_class_decl);\n+\t  return build_x_function_call (build_offset_ref (type, name), parmlist, current_class_ref);\n \t}\n     }\n \n@@ -1705,14 +1705,14 @@ build_member_call (type, name, parmlist)\n       basetype_path = TYPE_BINFO (type);\n       decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n     }\n-  else if (current_class_decl == 0)\n+  else if (current_class_ptr == 0)\n     {\n       dont_use_this = 1;\n       decl = build1 (NOP_EXPR, build_pointer_type (type), error_mark_node);\n     }\n   else\n     {\n-      tree olddecl = current_class_decl;\n+      tree olddecl = current_class_ptr;\n       tree oldtype = TREE_TYPE (TREE_TYPE (olddecl));\n       if (oldtype != type)\n \t{\n@@ -1846,10 +1846,10 @@ build_offset_ref (type, name)\n       basebinfo = TYPE_BINFO (type);\n       decl = build1 (NOP_EXPR, type, error_mark_node);\n     }\n-  else if (current_class_decl == 0)\n+  else if (current_class_ptr == 0)\n     decl = build1 (NOP_EXPR, type, error_mark_node);\n   else\n-    decl = C_C_D;\n+    decl = current_class_ref;\n \n   if (constructor_name (BINFO_TYPE (basebinfo)) == name)\n     if (dtor)\n@@ -1978,7 +1978,12 @@ resolve_offset_ref (exp)\n   if (TREE_CODE (exp) == TREE_LIST)\n     return build_unary_op (ADDR_EXPR, exp, 0);\n \n-  if (TREE_CODE (exp) != OFFSET_REF)\n+  if (TREE_CODE (exp) == OFFSET_REF)\n+    {\n+      member = TREE_OPERAND (exp, 1);\n+      base = TREE_OPERAND (exp, 0);\n+    }\n+  else\n     {\n       my_friendly_assert (TREE_CODE (type) == OFFSET_TYPE, 214);\n       if (TYPE_OFFSET_BASETYPE (type) != current_class_type)\n@@ -1988,12 +1993,7 @@ resolve_offset_ref (exp)\n \t}\n       member = exp;\n       type = TREE_TYPE (type);\n-      base = C_C_D;\n-    }\n-  else\n-    {\n-      member = TREE_OPERAND (exp, 1);\n-      base = TREE_OPERAND (exp, 0);\n+      base = current_class_ref;\n     }\n \n   if ((TREE_CODE (member) == VAR_DECL\n@@ -2008,7 +2008,7 @@ resolve_offset_ref (exp)\n \n   /* Syntax error can cause a member which should\n      have been seen as static to be grok'd as non-static.  */\n-  if (TREE_CODE (member) == FIELD_DECL && C_C_D == NULL_TREE)\n+  if (TREE_CODE (member) == FIELD_DECL && current_class_ref == NULL_TREE)\n     {\n       if (TREE_ADDRESSABLE (member) == 0)\n \t{\n@@ -2022,7 +2022,7 @@ resolve_offset_ref (exp)\n \n   /* The first case is really just a reference to a member of `this'.  */\n   if (TREE_CODE (member) == FIELD_DECL\n-      && (base == C_C_D\n+      && (base == current_class_ref\n \t  || (TREE_CODE (base) == NOP_EXPR\n \t      && TREE_OPERAND (base, 0) == error_mark_node)))\n     {\n@@ -2033,7 +2033,7 @@ resolve_offset_ref (exp)\n       else\n \tbasetype = DECL_CONTEXT (member);\n \n-      base = current_class_decl;\n+      base = current_class_ptr;\n       \n       if (get_base_distance (basetype, TREE_TYPE (TREE_TYPE (base)), 0, &basetype_path) < 0)\n \t{\n@@ -3555,8 +3555,8 @@ build_delete (type, addr, auto_delete, flags, use_global_delete)\n \taddr = convert_force (build_pointer_type (type), addr, 0);\n \n       if (TREE_CODE (addr) == NOP_EXPR\n-\t  && TREE_OPERAND (addr, 0) == current_class_decl)\n-\tref = C_C_D;\n+\t  && TREE_OPERAND (addr, 0) == current_class_ptr)\n+\tref = current_class_ref;\n       else\n \tref = build_indirect_ref (addr, NULL_PTR);\n       ptr = 0;"}, {"sha": "79761e9d46496411d17c3345fae03339b8916fa4", "filename": "gcc/cp/method.c", "status": "modified", "additions": 11, "deletions": 144, "changes": 155, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -1549,19 +1549,19 @@ hack_identifier (value, name)\n   type = TREE_TYPE (value);\n   if (TREE_CODE (value) == FIELD_DECL)\n     {\n-      if (current_class_decl == NULL_TREE)\n+      if (current_class_ptr == NULL_TREE)\n \t{\n \t  error (\"request for member `%s' in static member function\",\n \t\t IDENTIFIER_POINTER (DECL_NAME (value)));\n \t  return error_mark_node;\n \t}\n-      TREE_USED (current_class_decl) = 1;\n+      TREE_USED (current_class_ptr) = 1;\n \n       /* Mark so that if we are in a constructor, and then find that\n \t this field was initialized by a base initializer,\n \t we can emit an error message.  */\n       TREE_USED (value) = 1;\n-      value = build_component_ref (C_C_D, name, NULL_TREE, 1);\n+      value = build_component_ref (current_class_ref, name, NULL_TREE, 1);\n     }\n   else if (really_overloaded_fn (value))\n     {\n@@ -1652,141 +1652,6 @@ hack_identifier (value, name)\n   return value;\n }\n \n-\f\n-#if 0\n-/* Given an object OF, and a type conversion operator COMPONENT\n-   build a call to the conversion operator, if a call is requested,\n-   or return the address (as a pointer to member function) if one is not.\n-\n-   OF can be a TYPE_DECL or any kind of datum that would normally\n-   be passed to `build_component_ref'.  It may also be NULL_TREE,\n-   in which case `current_class_type' and `current_class_decl'\n-   provide default values.\n-\n-   BASETYPE_PATH, if non-null, is the path of basetypes\n-   to go through before we get the the instance of interest.\n-\n-   PROTECT says whether we apply C++ scoping rules or not.  */\n-tree\n-build_component_type_expr (of, component, basetype_path, protect)\n-     tree of, component, basetype_path;\n-     int protect;\n-{\n-  tree cname = NULL_TREE;\n-  tree tmp, last;\n-  tree name;\n-  int flags = protect ? LOOKUP_NORMAL : LOOKUP_COMPLAIN;\n-\n-  if (of)\n-    my_friendly_assert (IS_AGGR_TYPE (TREE_TYPE (of)), 253);\n-  my_friendly_assert (TREE_CODE (component) == TYPE_EXPR, 254);\n-\n-  tmp = TREE_OPERAND (component, 0);\n-  last = NULL_TREE;\n-\n-  while (tmp)\n-    {\n-      switch (TREE_CODE (tmp))\n-\t{\n-\tcase CALL_EXPR:\n-\t  if (last)\n-\t    TREE_OPERAND (last, 0) = TREE_OPERAND (tmp, 0);\n-\t  else\n-\t    TREE_OPERAND (component, 0) = TREE_OPERAND (tmp, 0);\n-\n-\t  last = groktypename (build_tree_list (TREE_TYPE (component),\n-\t\t\t\t\t\tTREE_OPERAND (component, 0)));\n-\t  name = build_typename_overload (last);\n-\t  TREE_TYPE (name) = last;\n-\n-\t  if (TREE_OPERAND (tmp, 0)\n-\t      && TREE_OPERAND (tmp, 0) != void_list_node)\n-\t    {\n-\t      cp_error (\"`operator %T' requires empty parameter list\", last);\n-\t      TREE_OPERAND (tmp, 0) = NULL_TREE;\n-\t    }\n-\n-\t  if (of && TREE_CODE (of) != TYPE_DECL)\n-\t    return build_method_call (of, name, NULL_TREE, NULL_TREE, flags);\n-\t  else if (of)\n-\t    {\n-\t      tree this_this;\n-\n-\t      if (current_class_decl == NULL_TREE)\n-\t\t{\n-\t\t  cp_error (\"object required for `operator %T' call\",\n-\t\t\t    TREE_TYPE (name));\n-\t\t  return error_mark_node;\n-\t\t}\n-\n-\t      this_this = convert_pointer_to (TREE_TYPE (of),\n-\t\t\t\t\t      current_class_decl);\n-\t      this_this = build_indirect_ref (this_this, NULL_PTR);\n-\t      return build_method_call (this_this, name, NULL_TREE,\n-\t\t\t\t\tNULL_TREE, flags | LOOKUP_NONVIRTUAL);\n-\t    }\n-\t  else if (current_class_decl)\n-\t    return build_method_call (tmp, name, NULL_TREE, NULL_TREE, flags);\n-\n-\t  cp_error (\"object required for `operator %T' call\",\n-\t\t    TREE_TYPE (name));\n-\t  return error_mark_node;\n-\n-\tcase INDIRECT_REF:\n-\tcase ADDR_EXPR:\n-\tcase ARRAY_REF:\n-\t  break;\n-\n-\tcase SCOPE_REF:\n-\t  my_friendly_assert (cname == 0, 255);\n-\t  cname = TREE_OPERAND (tmp, 0);\n-\t  tmp = TREE_OPERAND (tmp, 1);\n-\t  break;\n-\n-\tdefault:\n-\t  my_friendly_abort (77);\n-\t}\n-      last = tmp;\n-      tmp = TREE_OPERAND (tmp, 0);\n-    }\n-\n-  last = groktypename (build_tree_list (TREE_TYPE (component), TREE_OPERAND (component, 0)));\n-  name = build_typename_overload (last);\n-  TREE_TYPE (name) = last;\n-  if (of && TREE_CODE (of) == TYPE_DECL)\n-    {\n-      if (cname == NULL_TREE)\n-\t{\n-\t  cname = DECL_NAME (of);\n-\t  of = NULL_TREE;\n-\t}\n-      else my_friendly_assert (cname == DECL_NAME (of), 256);\n-    }\n-\n-  if (of)\n-    {\n-      tree this_this;\n-\n-      if (current_class_decl == NULL_TREE)\n-\t{\n-\t  cp_error (\"object required for `operator %T' call\",\n-\t\t    TREE_TYPE (name));\n-\t  return error_mark_node;\n-\t}\n-\n-      this_this = convert_pointer_to (TREE_TYPE (of), current_class_decl);\n-      return build_component_ref (this_this, name, NULL_TREE, protect);\n-    }\n-  else if (cname)\n-    return build_offset_ref (cname, name);\n-  else if (current_class_name)\n-    return build_offset_ref (current_class_name, name);\n-\n-  cp_error (\"object required for `operator %T' member reference\",\n-\t    TREE_TYPE (name));\n-  return error_mark_node;\n-}\n-#endif\n \f\n static char *\n thunk_printable_name (decl)\n@@ -1863,6 +1728,7 @@ emit_thunk (thunk_fndecl)\n   char *fnname = XSTR (XEXP (DECL_RTL (thunk_fndecl), 0), 0);\n   int tem;\n   int failure = 0;\n+  int save_ofp;\n \n   /* Used to remember which regs we need to emit a USE rtx for. */\n   rtx need_use[FIRST_PSEUDO_REGISTER];\n@@ -1892,6 +1758,8 @@ emit_thunk (thunk_fndecl)\n   ASM_OUTPUT_MI_THUNK (asm_out_file, thunk_fndecl, delta, function);\n   assemble_end_function (thunk_fndecl, fnname);\n #else\n+  save_ofp = flag_omit_frame_pointer;\n+  flag_omit_frame_pointer = 1;\n   init_function_start (thunk_fndecl, input_filename, lineno);\n   pushlevel (0);\n   expand_start_bindings (1);\n@@ -2063,13 +1931,12 @@ emit_thunk (thunk_fndecl)\n   final (insns, asm_out_file, optimize, 0);\n   assemble_end_function (thunk_fndecl, fnname);\n \n- exit_rest_of_compilation:\n-\n   reload_completed = 0;\n \n   /* Cancel the effect of rtl_in_current_obstack.  */\n \n   permanent_allocation (1);\n+  flag_omit_frame_pointer = save_ofp;\n #endif /* ASM_OUTPUT_MI_THUNK */\n \n   decl_printable_name = save_decl_printable_name;\n@@ -2112,7 +1979,7 @@ do_build_copy_constructor (fndecl)\n \n   if (TYPE_HAS_TRIVIAL_INIT_REF (current_class_type))\n     {\n-      t = build (INIT_EXPR, void_type_node, C_C_D, parm);\n+      t = build (INIT_EXPR, void_type_node, current_class_ref, parm);\n       TREE_SIDE_EFFECTS (t) = 1;\n       cplus_expand_expr_stmt (t);\n     }\n@@ -2202,7 +2069,7 @@ do_build_assign_ref (fndecl)\n \n   if (TYPE_HAS_TRIVIAL_ASSIGN_REF (current_class_type))\n     {\n-      tree t = build (MODIFY_EXPR, void_type_node, C_C_D, parm);\n+      tree t = build (MODIFY_EXPR, void_type_node, current_class_ref, parm);\n       TREE_SIDE_EFFECTS (t) = 1;\n       cplus_expand_expr_stmt (t);\n     }\n@@ -2253,13 +2120,13 @@ do_build_assign_ref (fndecl)\n \t  else\n \t    continue;\n \n-\t  comp = build (COMPONENT_REF, TREE_TYPE (field), C_C_D, field);\n+\t  comp = build (COMPONENT_REF, TREE_TYPE (field), current_class_ref, field);\n \t  init = build (COMPONENT_REF, TREE_TYPE (field), parm, field);\n \n \t  expand_expr_stmt (build_modify_expr (comp, NOP_EXPR, init));\n \t}\n     }\n-  c_expand_return (C_C_D);\n+  c_expand_return (current_class_ref);\n   pop_momentary ();\n }\n "}, {"sha": "adda622222eed38958a3be424b68d9106c18375a", "filename": "gcc/cp/parse.y", "status": "modified", "additions": 20, "deletions": 25, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fparse.y", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fparse.y", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparse.y?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -782,22 +782,22 @@ member_init: '(' nonnull_exprlist ')'\n \t\t{\n \t\t  if (current_class_name && !flag_traditional)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  expand_member_init (C_C_D, NULL_TREE, $2);\n+\t\t  expand_member_init (current_class_ref, NULL_TREE, $2);\n \t\t}\n \t| LEFT_RIGHT\n \t\t{\n \t\t  if (current_class_name && !flag_traditional)\n \t\t    pedwarn (\"anachronistic old style base class initializer\");\n-\t\t  expand_member_init (C_C_D, NULL_TREE, void_type_node);\n+\t\t  expand_member_init (current_class_ref, NULL_TREE, void_type_node);\n \t\t}\n \t| notype_identifier '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (C_C_D, $1, $3); }\n+\t\t{ expand_member_init (current_class_ref, $1, $3); }\n \t| notype_identifier LEFT_RIGHT\n-\t\t{ expand_member_init (C_C_D, $1, void_type_node); }\n+\t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n \t| complete_type_name '(' nonnull_exprlist ')'\n-\t\t{ expand_member_init (C_C_D, $1, $3); }\n+\t\t{ expand_member_init (current_class_ref, $1, $3); }\n \t| complete_type_name LEFT_RIGHT\n-\t\t{ expand_member_init (C_C_D, $1, void_type_node); }\n+\t\t{ expand_member_init (current_class_ref, $1, void_type_node); }\n \t/* GNU extension */\n \t| notype_qualified_id '(' nonnull_exprlist ')'\n \t\t{\n@@ -1046,12 +1046,7 @@ nonnull_exprlist:\n \n unary_expr:\n \t  primary %prec UNARY\n-\t\t{\n-#if 0\n-\t\t  if (TREE_CODE ($$) == TYPE_EXPR)\n-\t\t    $$ = build_component_type_expr (C_C_D, $$, NULL_TREE, 1);\n-#endif\n-\t\t}\n+\t\t{ $$ = $1; }\n \t/* __extension__ turns off -pedantic for following primary.  */\n \t| EXTENSION\n \t\t{ $<itype>1 = pedantic;\n@@ -1362,14 +1357,14 @@ primary:\n \t\t}\n \t| primary '(' nonnull_exprlist ')'\n                 {\n-                  $$ = build_x_function_call ($1, $3, current_class_decl); \n+                  $$ = build_x_function_call ($1, $3, current_class_ref); \n                   if (TREE_CODE ($$) == CALL_EXPR\n                       && TREE_TYPE ($$) != void_type_node)\n \t            $$ = require_complete_type ($$);\n                 }\n \t| primary LEFT_RIGHT\n                 {\n-\t\t  $$ = build_x_function_call ($$, NULL_TREE, current_class_decl);\n+\t\t  $$ = build_x_function_call ($$, NULL_TREE, current_class_ref);\n \t\t  if (TREE_CODE ($$) == CALL_EXPR\n \t\t      && TREE_TYPE ($$) != void_type_node)\n \t\t    $$ = require_complete_type ($$);\n@@ -1391,12 +1386,12 @@ primary:\n \t\t  $$ = build_x_unary_op (POSTDECREMENT_EXPR, $$); }\n \t/* C++ extensions */\n \t| THIS\n-\t\t{ if (current_class_decl)\n+\t\t{ if (current_class_ptr)\n \t\t    {\n #ifdef WARNING_ABOUT_CCD\n-\t\t      TREE_USED (current_class_decl) = 1;\n+\t\t      TREE_USED (current_class_ptr) = 1;\n #endif\n-\t\t      $$ = current_class_decl;\n+\t\t      $$ = current_class_ptr;\n \t\t    }\n \t\t  else if (current_function_decl\n \t\t\t   && DECL_STATIC_FUNCTION_P (current_function_decl))\n@@ -1516,13 +1511,13 @@ primary:\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n \t\t     in build_component_ref entirely yet, we cannot do this. */\n-\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, $$);\n+\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), $4, current_class_ref);\n \t\t  if (TREE_CODE ($$) == CALL_EXPR\n \t\t      && TREE_TYPE ($$) != void_type_node)\n \t\t    $$ = require_complete_type ($$);\n #else\n \t\t  $$ = build_method_call ($$, $2, $4, NULL_TREE,\n-\t\t\t\t\t  (LOOKUP_NORMAL|LOOKUP_AGGR));\n+\t\t\t\t\t  LOOKUP_NORMAL);\n #endif\n \t\t}\n \t| object unqualified_id LEFT_RIGHT\n@@ -1531,13 +1526,13 @@ primary:\n \t\t  /* This is a future direction of this code, but because\n \t\t     build_x_function_call cannot always undo what is done\n \t\t     in build_component_ref entirely yet, we cannot do this. */\n-\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, $$);\n+\t\t  $$ = build_x_function_call (build_component_ref ($$, $2, NULL_TREE, 1), NULL_TREE, current_class_ref);\n \t\t  if (TREE_CODE ($$) == CALL_EXPR\n \t\t      && TREE_TYPE ($$) != void_type_node)\n \t\t    $$ = require_complete_type ($$);\n #else\n \t\t  $$ = build_method_call ($$, $2, NULL_TREE, NULL_TREE,\n-\t\t\t\t\t  (LOOKUP_NORMAL|LOOKUP_AGGR));\n+\t\t\t\t\t  LOOKUP_NORMAL);\n #endif\n \t\t}\n \t| object overqualified_id '(' nonnull_exprlist ')'\n@@ -1546,7 +1541,7 @@ primary:\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n \t\t      $$ = build_method_call ($$, OP1 ($2), $4, NULL_TREE,\n-\t\t\t\t\t      (LOOKUP_NORMAL|LOOKUP_AGGR));\n+\t\t\t\t\t      LOOKUP_NORMAL);\n \t\t    }\n \t\t  else\n \t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), $4);\n@@ -1557,7 +1552,7 @@ primary:\n \t\t    {\n \t\t      warning (\"signature name in scope resolution ignored\");\n \t\t      $$ = build_method_call ($$, OP1 ($2), NULL_TREE, NULL_TREE,\n-\t\t\t\t\t      (LOOKUP_NORMAL|LOOKUP_AGGR));\n+\t\t\t\t\t      LOOKUP_NORMAL);\n \t\t    }\n \t\t  else\n \t\t    $$ = build_scoped_method_call ($$, OP0 ($2), OP1 ($2), NULL_TREE);\n@@ -1605,9 +1600,9 @@ primary_no_id:\n \t\t    pedwarn (\"ANSI C++ forbids braced-groups within expressions\");\n \t\t  $$ = expand_end_stmt_expr ($<ttype>2); }\n \t| primary_no_id '(' nonnull_exprlist ')'\n-\t\t{ $$ = build_x_function_call ($$, $3, current_class_decl); }\n+\t\t{ $$ = build_x_function_call ($$, $3, current_class_ref); }\n \t| primary_no_id LEFT_RIGHT\n-\t\t{ $$ = build_x_function_call ($$, NULL_TREE, current_class_decl); }\n+\t\t{ $$ = build_x_function_call ($$, NULL_TREE, current_class_ref); }\n \t| primary_no_id '[' expr ']'\n \t\t{ goto do_array; }\n \t| primary_no_id PLUSPLUS"}, {"sha": "0addffdee912173b4714641628a7cb6506f9ee7f", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -2581,6 +2581,10 @@ unify (tparms, targs, ntparms, parm, arg, nsubsts)\n       return 0;\n \n     case POINTER_TYPE:\n+      if (TREE_CODE (arg) == RECORD_TYPE && TYPE_PTRMEMFUNC_FLAG (arg))\n+\treturn unify (tparms, targs, ntparms, parm,\n+\t\t      TYPE_PTRMEMFUNC_FN_TYPE (arg), nsubsts);\n+\n       if (TREE_CODE (arg) != POINTER_TYPE)\n \treturn 1;\n       return unify (tparms, targs, ntparms, TREE_TYPE (parm), TREE_TYPE (arg),"}, {"sha": "2a852cd12761baf9bb9347f35aed505f3a3fe099", "filename": "gcc/cp/search.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -769,7 +769,7 @@ lookup_field_1 (type, name)\n    itself inside a class, we need decls to go into the fn's decls (our\n    second case below).  But if we're in a class and the class itself is\n    inside a function, we need decls to go into the decls for the class.  To\n-   achieve this last goal, we must see if, when both current_class_decl and\n+   achieve this last goal, we must see if, when both current_class_ptr and\n    current_function_decl are set, the class was declared inside that\n    function.  If so, we know to put the decls into the class's scope.  */\n "}, {"sha": "701b3be26e6b778197fa80f7cfe36cb7ec55da5d", "filename": "gcc/cp/sig.c", "status": "modified", "additions": 9, "deletions": 8, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fsig.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Fsig.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsig.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -573,7 +573,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n \t      delta = integer_zero_node;\n \t      index = integer_zero_node;\n-\t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n+\t      pfn = build_addr_func (rhs_method);\n \t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n \t      TREE_TYPE (pfn) = ptr_type_node;\n \t      TREE_ADDRESSABLE (rhs_method) = 1;\n@@ -584,8 +584,12 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      /* virtual member function */\n \t      tag = integer_one_node;\n \t      vb_off = build_unary_op (NEGATE_EXPR, integer_one_node, 0);\n-\t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n-\t\t\t\t\t       rhstype, 1));\n+\t      if (flag_vtable_thunks)\n+\t\tdelta = BINFO_OFFSET\n+\t\t  (get_binfo (DECL_CONTEXT (rhs_method), rhstype, 1));\n+\t      else\n+\t\tdelta = BINFO_OFFSET\n+\t\t  (get_binfo (DECL_CLASS_CONTEXT (rhs_method), rhstype, 1));\n \t      index = DECL_VINDEX (rhs_method);\n \t      vt_off = get_vfield_offset (get_binfo (DECL_CONTEXT (rhs_method),\n \t\t\t\t\t\t     rhstype, 0));\n@@ -598,7 +602,7 @@ build_signature_table_constructor (sig_ty, rhs)\n \t      delta = BINFO_OFFSET (get_binfo (DECL_CLASS_CONTEXT (rhs_method),\n \t\t\t\t\t       rhstype, 1));\n \t      index = integer_zero_node;\n-\t      pfn = build_unary_op (ADDR_EXPR, rhs_method, 0);\n+\t      pfn = build_addr_func (rhs_method);\n \t      TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (rhs_method)) = 1;\n \t      TREE_TYPE (pfn) = ptr_type_node;\n \t      TREE_ADDRESSABLE (rhs_method) = 1;\n@@ -985,10 +989,7 @@ build_signature_method_call (basetype, instance, function, parms)\n \n       TREE_TYPE (vfn) = build_pointer_type (TREE_TYPE (function));\n \n-      if (flag_vtable_thunks)\n-\tvirtual_call = build_function_call (vfn, parms);\n-      else\n-\tvirtual_call = build_function_call (vfn, new_parms);\n+      virtual_call = build_function_call (vfn, new_parms);\n     }\n \n     /* Undo the cast, make `this' a signature pointer again.  */"}, {"sha": "3684a2a3f67852433501dd15acb0052e4fcc7752", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -48,7 +48,7 @@ real_lvalue_p (ref)\n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n     return 1;\n \n-  if (ref == current_class_decl && flag_this_is_variable <= 0)\n+  if (ref == current_class_ptr && flag_this_is_variable <= 0)\n     return 0;\n \n   switch (TREE_CODE (ref))\n@@ -118,7 +118,7 @@ lvalue_p (ref)\n   if (TREE_CODE (TREE_TYPE (ref)) == REFERENCE_TYPE)\n     return 1;\n \n-  if (ref == current_class_decl && flag_this_is_variable <= 0)\n+  if (ref == current_class_ptr && flag_this_is_variable <= 0)\n     return 0;\n \n   switch (TREE_CODE (ref))"}, {"sha": "507150ca1bac557c6b73dc9367eeddd2320a8af2", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 64, "deletions": 95, "changes": 159, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -100,13 +100,13 @@ require_complete_type (value)\n      not been laid out.  Try to avoid an error by interpreting\n      it as this->X::Y, if reasonable.  */\n   if (TREE_CODE (value) == OFFSET_REF\n-      && C_C_D != 0\n-      && TREE_OPERAND (value, 0) == C_C_D)\n+      && current_class_ref != 0\n+      && TREE_OPERAND (value, 0) == current_class_ref)\n     {\n       tree base, member = TREE_OPERAND (value, 1);\n       tree basetype = TYPE_OFFSET_BASETYPE (type);\n       my_friendly_assert (TREE_CODE (member) == FIELD_DECL, 305);\n-      base = convert_pointer_to (basetype, current_class_decl);\n+      base = convert_pointer_to (basetype, current_class_ptr);\n       value = build (COMPONENT_REF, TREE_TYPE (member),\n \t\t     build_indirect_ref (base, NULL_PTR), member);\n       return require_complete_type (value);\n@@ -1470,14 +1470,7 @@ decay_conversion (exp)\n     }\n   if (code == METHOD_TYPE)\n     {\n-      if (TREE_CODE (exp) == OFFSET_REF)\n-\t{\n-\t  /* FIXME: We should emit an error here about using a ptrmemfunc\n-\t     for something other than a function call.  */\n-\t  my_friendly_assert (TREE_CODE (TREE_OPERAND (exp, 1)) == FUNCTION_DECL,\n-\t\t\t      308);\n-\t  return build_unary_op (ADDR_EXPR, TREE_OPERAND (exp, 1), 0);\n-\t}\n+      cp_pedwarn (\"assuming & on `%E'\", exp);\n       return build_unary_op (ADDR_EXPR, exp, 0);\n     }\n   if (code == ARRAY_TYPE)\n@@ -1628,7 +1621,7 @@ build_object_ref (datum, basetype, field)\n }\n \n /* Like `build_component_ref, but uses an already found field.\n-   Must compute access for C_C_D.  Otherwise, ok.  */\n+   Must compute access for current_class_ref.  Otherwise, ok.  */\n tree\n build_component_ref_1 (datum, field, protect)\n      tree datum, field;\n@@ -1667,7 +1660,7 @@ build_component_ref_1 (datum, field, protect)\n   if (TREE_STATIC (field))\n     return field;\n \n-  if (datum == C_C_D)\n+  if (datum == current_class_ref)\n     {\n       tree access = compute_access (TYPE_BINFO (current_class_type), field);\n \n@@ -2020,8 +2013,8 @@ build_indirect_ref (ptr, errorstring)\n \t\t\t   ptr : default_conversion (ptr));\n   register tree type = TREE_TYPE (pointer);\n \n-  if (ptr == current_class_decl)\n-    return C_C_D;\n+  if (ptr == current_class_ptr)\n+    return current_class_ref;\n \n   if (IS_AGGR_TYPE (type))\n     {\n@@ -2226,8 +2219,9 @@ build_array_ref (array, idx)\n \f\n /* Build a function call to function FUNCTION with parameters PARAMS.\n    PARAMS is a list--a chain of TREE_LIST nodes--in which the\n-   TREE_VALUE of each node is a parameter-expression.\n-   FUNCTION's data type may be a function type or a pointer-to-function.\n+   TREE_VALUE of each node is a parameter-expression.  The PARAMS do\n+   not include any object pointer that may be required.  FUNCTION's\n+   data type may be a function type or a pointer-to-function.\n \n    For C++: If FUNCTION's data type is a TREE_LIST, then the tree list\n    is the list of possible methods that FUNCTION could conceivably\n@@ -2242,7 +2236,7 @@ build_array_ref (array, idx)\n    In the second case, TREE_PURPOSE (function) is the function's\n    name directly.\n \n-   DECL is the class instance variable, usually CURRENT_CLASS_DECL.\n+   DECL is the class instance variable, usually CURRENT_CLASS_REF.\n \n    When calling a TEMPLATE_DECL, we don't require a complete return\n    type.  */\n@@ -2392,7 +2386,7 @@ build_x_function_call (function, params, decl)\n       if (TREE_OPERAND (function, 0))\n \tdecl = TREE_OPERAND (function, 0);\n       else\n-\tdecl = C_C_D;\n+\tdecl = current_class_ref;\n \n       decl_addr = build_unary_op (ADDR_EXPR, decl, 0);\n       function = get_member_function_from_ptrfunc (&decl_addr,\n@@ -2594,25 +2588,25 @@ build_function_call_real (function, params, require_complete, flags)\n \t  function = inline_conversion (function);\n \t}\n       else\n-\tfunction = default_conversion (function);\n+\tfunction = build_addr_func (function);\n     }\n   else\n     {\n       fndecl = NULL_TREE;\n \n-      /* Convert anything with function type to a pointer-to-function.  */\n-      if (function == error_mark_node)\n-\treturn error_mark_node;\n-      function = default_conversion (function);\n+      function = build_addr_func (function);\n     }\n \n+  if (function == error_mark_node)\n+    return error_mark_node;\n+\n   fntype = TREE_TYPE (function);\n \n   if (TYPE_PTRMEMFUNC_P (fntype))\n     {\n-      tree instance_ptr = build_unary_op (ADDR_EXPR, C_C_D, 0);\n-      fntype = TYPE_PTRMEMFUNC_FN_TYPE (fntype);\n-      function = get_member_function_from_ptrfunc (&instance_ptr, function);\n+      cp_error (\"must use .* or ->* to call pointer-to-member function in `%E (...)'\",\n+\t\tfunction);\n+      return error_mark_node;\n     }\n \n   is_method = (TREE_CODE (fntype) == POINTER_TYPE\n@@ -2670,17 +2664,15 @@ build_function_call_real (function, params, require_complete, flags)\n   /* C++ */\n   value_type = TREE_TYPE (fntype) ? TREE_TYPE (fntype) : void_type_node;\n   {\n-    register tree result = \n-      build (CALL_EXPR, value_type,\n-\t     function, coerced_params, NULL_TREE);\n-\n-    TREE_SIDE_EFFECTS (result) = 1;\n+    register tree result\n+      = build_call (function, value_type, coerced_params);\n \n-    if (! require_complete)\n-      return convert_from_reference (result);\n-    if (value_type == void_type_node)\n-      return result;\n-    result = require_complete_type (result);\n+    if (require_complete)\n+      {\n+\tif (value_type == void_type_node)\n+\t  return result;\n+\tresult = require_complete_type (result);\n+      }\n     return convert_from_reference (result);\n   }\n }\n@@ -4282,10 +4274,10 @@ build_unary_op (code, xarg, noconvert)\n       /* Let &* cancel out to simplify resulting code.  */\n       if (TREE_CODE (arg) == INDIRECT_REF)\n \t{\n-\t  /* We don't need to have `current_class_decl' wrapped in a\n+\t  /* We don't need to have `current_class_ptr' wrapped in a\n \t     NON_LVALUE_EXPR node.  */\n-\t  if (arg == C_C_D)\n-\t    return current_class_decl;\n+\t  if (arg == current_class_ref)\n+\t    return current_class_ptr;\n \n \t  /* Keep `default_conversion' from converting if\n \t     ARG is of REFERENCE_TYPE.  */\n@@ -4402,6 +4394,14 @@ build_unary_op (code, xarg, noconvert)\n \t   function counts as a constant */\n \tif (staticp (arg))\n \t  TREE_CONSTANT (addr) = 1;\n+\n+\tif (TREE_CODE (argtype) == POINTER_TYPE &&\n+\t    TREE_CODE (TREE_TYPE (argtype)) == METHOD_TYPE)\n+\t  {\n+\t    build_ptrmemfunc_type (argtype);\n+\t    addr = build_ptrmemfunc (argtype, addr, 0);\n+\t  }\n+\n \treturn addr;\n       }\n     }\n@@ -4542,31 +4542,6 @@ unary_complex_lvalue (code, arg)\n     }\n \n   \n-#if 0\n-  /* This seems to be obsolete now (and posssibly wrong, compare with\n-     resolve_offset_ref).  */\n-  if (TREE_CODE (arg) == OFFSET_REF)\n-    {\n-      tree left = TREE_OPERAND (arg, 0), left_addr;\n-      tree right_addr = build_unary_op (ADDR_EXPR, TREE_OPERAND (arg, 1), 0);\n-\n-      if (left == 0)\n-\tif (current_class_decl)\n-\t  left_addr = current_class_decl;\n-\telse\n-\t  {\n-\t    error (\"no `this' for pointer to member\");\n-\t    return error_mark_node;\n-\t  }\n-      else\n-\tleft_addr = build_unary_op (ADDR_EXPR, left, 0);\n-\n-      return build (PLUS_EXPR, build_pointer_type (TREE_TYPE (arg)),\n-\t\t    build1 (NOP_EXPR, integer_type_node, left_addr),\n-\t\t    build1 (NOP_EXPR, integer_type_node, right_addr));\n-    }\n-#endif\n-\n   /* We permit compiler to make function calls returning\n      objects of aggregate type look like lvalues.  */\n   {\n@@ -4597,7 +4572,7 @@ unary_complex_lvalue (code, arg)\n    address of it; it should not be allocated in a register.\n    Value is 1 if successful.\n \n-   C++: we do not allow `current_class_decl' to be addressable.  */\n+   C++: we do not allow `current_class_ptr' to be addressable.  */\n \n int\n mark_addressable (exp)\n@@ -4618,7 +4593,7 @@ mark_addressable (exp)\n \tbreak;\n \n       case PARM_DECL:\n-\tif (x == current_class_decl)\n+\tif (x == current_class_ptr)\n \t  {\n \t    error (\"address of `this' not available\");\n \t    TREE_ADDRESSABLE (x) = 1; /* so compiler doesn't die later */\n@@ -5702,7 +5677,7 @@ build_modify_expr (lhs, modifycode, rhs)\n     }\n \n   /* check to see if there is an assignment to `this' */\n-  if (lhs == current_class_decl)\n+  if (lhs == current_class_ptr)\n     {\n       if (flag_this_is_variable > 0\n \t  && DECL_NAME (current_function_decl) != NULL_TREE\n@@ -5976,11 +5951,16 @@ get_delta_difference (from, to, force)\n \t}\n       if (TREE_VIA_VIRTUAL (binfo))\n \t{\n+\t  binfo = binfo_member (BINFO_TYPE (binfo),\n+\t\t\t\tCLASSTYPE_VBASECLASSES (from));\n \t  warning (\"pointer to member conversion to virtual base class will only work if you are very careful\");\n \t}\n+      delta = BINFO_OFFSET (binfo);\n+      delta = convert (ptrdiff_type_node, delta);\n+      \n       return build_binary_op (MINUS_EXPR,\n \t\t\t      integer_zero_node,\n-\t\t\t      BINFO_OFFSET (binfo), 1);\n+\t\t\t      delta, 1);\n     }\n   if (TREE_VIA_VIRTUAL (binfo))\n     {\n@@ -6099,8 +6079,7 @@ build_ptrmemfunc (type, pfn, force)\n       pfn = instantiate_type (type, pfn, 1);\n       if (pfn == error_mark_node)\n \treturn error_mark_node;\n-      if (TREE_CODE (pfn) != ADDR_EXPR)\n-\tpfn = build_unary_op (ADDR_EXPR, pfn, 0);\n+      pfn = build_addr_func (pfn);\n     }\n \n   /* Allow pointer to member conversions here. */\n@@ -6109,6 +6088,14 @@ build_ptrmemfunc (type, pfn, force)\n \t\t\t\tforce);\n   delta2 = build_binary_op (PLUS_EXPR, delta2, delta, 1);\n \n+#if 0\n+  /* We need to check the argument types to see if they are compatible\n+     (any const or volatile violations.  */\n+  something like this:\n+  comptype (TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (type))),\n+\t    TREE_VALUE (TYPE_ARG_TYPES (TREE_TYPE (TREE_TYPE (pfn)))), ?);\n+#endif\n+\n   if (TREE_CODE (TREE_OPERAND (pfn, 0)) != FUNCTION_DECL)\n     warning (\"assuming pointer to member function is non-virtual\");\n \n@@ -6414,12 +6401,12 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t     some type instantiation if that resolves the\n \t     ambiguity of (X Y::*) and (X *).  */\n \n-\t  if (current_class_decl)\n+\t  if (current_class_ptr)\n \t    {\n \t      if (TREE_CODE (rhs) == INTEGER_CST)\n \t\t{\n \t\t  rhs = build (PLUS_EXPR, build_pointer_type (TREE_TYPE (ttr)),\n-\t\t\t       current_class_decl, rhs);\n+\t\t\t       current_class_ptr, rhs);\n \t\t  return convert_for_assignment (type, rhs,\n \t\t\t\t\t\t errtype, fndecl, parmnum);\n \t\t}\n@@ -6522,24 +6509,6 @@ convert_for_assignment (type, rhs, errtype, fndecl, parmnum)\n \t\t    cp_warning (\"\\t`%T' != `%T'\", type, rhstype);\n \t\t  }\n \t    }\n-\t  else if (TREE_CODE (TREE_TYPE (rhs)) == METHOD_TYPE)\n-\t    {\n-\t      /* When does this happen?  */\n-\t      my_friendly_abort (119);\n-\t      /* Conversion of a pointer-to-member type to void *.  */\n-\t      rhs = build_unary_op (ADDR_EXPR, rhs, 0);\n-\t      TREE_TYPE (rhs) = type;\n-\t      return rhs;\n-\t    }\n-\t  else if (TREE_CODE (TREE_TYPE (rhs)) == OFFSET_TYPE)\n-\t    {\n-\t      /* When does this happen?  */\n-\t      my_friendly_abort (120);\n-\t      /* Conversion of a pointer-to-member type to void *.  */\n-\t      rhs = build_unary_op (ADDR_EXPR, rhs, 0);\n-\t      TREE_TYPE (rhs) = type;\n-\t      return rhs;\n-\t    }\n \t  else\n \t    {\n \t      if (fndecl)\n@@ -6931,7 +6900,7 @@ c_expand_return (retval)\n \t}\n \n       if (DECL_CONSTRUCTOR_P (current_function_decl))\n-\tretval = current_class_decl;\n+\tretval = current_class_ptr;\n       else if (DECL_NAME (result) != NULL_TREE\n \t       && TREE_CODE (valtype) != VOID_TYPE)\n \tretval = result;\n@@ -6956,10 +6925,10 @@ c_expand_return (retval)\n \t}\n     }\n   else if (DECL_CONSTRUCTOR_P (current_function_decl)\n-\t   && retval != current_class_decl)\n+\t   && retval != current_class_ptr)\n     {\n       error (\"return from a constructor: use `this = ...' instead\");\n-      retval = current_class_decl;\n+      retval = current_class_ptr;\n     }\n \n   if (valtype == NULL_TREE || TREE_CODE (valtype) == VOID_TYPE)\n@@ -7164,7 +7133,7 @@ c_expand_return (retval)\n \t}\n       else if (ctor_label && TREE_CODE (ctor_label) != ERROR_MARK)\n \t{\n-\t  /* Here RETVAL is CURRENT_CLASS_DECL, so there's nothing to do.  */\n+\t  /* Here RETVAL is CURRENT_CLASS_PTR, so there's nothing to do.  */\n \t  expand_goto (ctor_label);\n \t}\n       else if (retval)"}, {"sha": "14802dc9e6e735ee3269782d783ea80b5e3b375b", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ac14744830df0e672c6b0fbf57823f3b95c0be4/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=4ac14744830df0e672c6b0fbf57823f3b95c0be4", "patch": "@@ -1341,7 +1341,7 @@ build_m_component_ref (datum, component)\n     {\n       component = build_indirect_ref (component, NULL_PTR);\n       type = TREE_TYPE (component);\n-      rettype = TREE_TYPE (TREE_TYPE (component));\n+      rettype = TREE_TYPE (type);\n     }\n \n   if (datum == error_mark_node || component == error_mark_node)"}]}