{"sha": "c840bf9bc92e71291a9dc653688bf496aa219b7d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzg0MGJmOWJjOTJlNzEyOTFhOWRjNjUzNjg4YmY0OTZhYTIxOWI3ZA==", "commit": {"author": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-20T17:02:37Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "pmderodat@gcc.gnu.org", "date": "2017-10-20T17:02:37Z"}, "message": "s-osinte__linux.ads (Relative_Timed_Wait): Add variable needed for using monotonic clock.\n\ngcc/ada/\n\n2017-10-20  Doug Rupp  <rupp@adacore.com>\n\n\t* libgnarl/s-osinte__linux.ads (Relative_Timed_Wait): Add variable\n\tneeded for using monotonic clock.\n\t* libgnarl/s-taprop__linux.adb: Revert previous monotonic clock\n\tchanges.\n\t* libgnarl/s-taprop__linux.adb, s-taprop__posix.adb: Unify and factor\n\tout monotonic clock related functions body.\n\t(Timed_Sleep, Timed_Delay, Montonic_Clock, RT_Resolution,\n\tCompute_Deadline): Move to...\n\t* libgnarl/s-tpopmo.adb: ... here. New separate package body.\n\n2017-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_util.adb (Is_Controlling_Limited_Procedure): Handle properly the\n\tcase where the controlling formal is an anonymous access to interface\n\ttype.\n\t* exp_ch9.adb (Extract_Dispatching_Call): If controlling actual is an\n\taccess type, handle properly the the constructed dereference that\n\tdesignates the object used in the rewritten synchronized call.\n\t(Parameter_Block_Pack): If the type of the actual is by-copy, its\n\tgenerated declaration in the parameter block does not need an\n\tinitialization even if the type is a null-excluding access type,\n\tbecause it will be initialized with the value of the actual later on.\n\t(Parameter_Block_Pack): Do not add controlling actual to parameter\n\tblock when its type is by-copy.\n\n2017-10-20  Justin Squirek  <squirek@adacore.com>\n\n\t* sem_ch8.adb (Update_Use_Clause_Chain): Add sanity check to verify\n\tscope stack traversal into the context clause.\n\ngcc/testsuite/\n\n2017-10-20  Ed Schonberg  <schonberg@adacore.com>\n\n\t* gnat.dg/sync_iface_call.adb, gnat.dg/sync_iface_call_pkg.ads,\n\tgnat.dg/sync_iface_call_pkg2.adb, gnat.dg/sync_iface_call_pkg2.ads:\n\tNew testcase.\n\nFrom-SVN: r253948", "tree": {"sha": "1b5bbab4b062b0ce438f2e767c216dbbcdf64181", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1b5bbab4b062b0ce438f2e767c216dbbcdf64181"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c840bf9bc92e71291a9dc653688bf496aa219b7d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c840bf9bc92e71291a9dc653688bf496aa219b7d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c840bf9bc92e71291a9dc653688bf496aa219b7d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c840bf9bc92e71291a9dc653688bf496aa219b7d/comments", "author": null, "committer": null, "parents": [{"sha": "8ce6219665fe0ea4679794694eb25d323b3e5c58", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ce6219665fe0ea4679794694eb25d323b3e5c58", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ce6219665fe0ea4679794694eb25d323b3e5c58"}], "stats": {"total": 969, "additions": 515, "deletions": 454}, "files": [{"sha": "dac7791a8e64b05565bb6fd2f1dea128dcb2dcbc", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -1,3 +1,35 @@\n+2017-10-20  Doug Rupp  <rupp@adacore.com>\n+\n+\t* libgnarl/s-osinte__linux.ads (Relative_Timed_Wait): Add variable\n+\tneeded for using monotonic clock.\n+\t* libgnarl/s-taprop__linux.adb: Revert previous monotonic clock\n+\tchanges.\n+\t* libgnarl/s-taprop__linux.adb, s-taprop__posix.adb: Unify and factor\n+\tout monotonic clock related functions body.\n+\t(Timed_Sleep, Timed_Delay, Montonic_Clock, RT_Resolution,\n+\tCompute_Deadline): Move to...\n+\t* libgnarl/s-tpopmo.adb: ... here. New separate package body.\n+\n+2017-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_util.adb (Is_Controlling_Limited_Procedure): Handle properly the\n+\tcase where the controlling formal is an anonymous access to interface\n+\ttype.\n+\t* exp_ch9.adb (Extract_Dispatching_Call): If controlling actual is an\n+\taccess type, handle properly the the constructed dereference that\n+\tdesignates the object used in the rewritten synchronized call.\n+\t(Parameter_Block_Pack): If the type of the actual is by-copy, its\n+\tgenerated declaration in the parameter block does not need an\n+\tinitialization even if the type is a null-excluding access type,\n+\tbecause it will be initialized with the value of the actual later on.\n+\t(Parameter_Block_Pack): Do not add controlling actual to parameter\n+\tblock when its type is by-copy.\n+\n+2017-10-20  Justin Squirek  <squirek@adacore.com>\n+\n+\t* sem_ch8.adb (Update_Use_Clause_Chain): Add sanity check to verify\n+\tscope stack traversal into the context clause.\n+\n 2017-10-20  Bob Duff  <duff@adacore.com>\n \n \t* sinfo.ads: Fix a comment typo."}, {"sha": "063b812f9bcd00f575fd89a2fdc6008d6f28015c", "filename": "gcc/ada/exp_ch9.adb", "status": "modified", "additions": 24, "deletions": 8, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fexp_ch9.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fexp_ch9.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch9.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -12909,11 +12909,14 @@ package body Exp_Ch9 is\n       end if;\n \n       --  If the type of the dispatching object is an access type then return\n-      --  an explicit dereference.\n+      --  an explicit dereference  of a copy of the object, and note that\n+      --  this is the controlling actual of the call.\n \n       if Is_Access_Type (Etype (Object)) then\n-         Object := Make_Explicit_Dereference (Sloc (N), Object);\n+         Object :=\n+           Make_Explicit_Dereference (Sloc (N), New_Copy_Tree (Object));\n          Analyze (Object);\n+         Set_Is_Controlling_Actual (Object);\n       end if;\n    end Extract_Dispatching_Call;\n \n@@ -14561,6 +14564,12 @@ package body Exp_Ch9 is\n                 Object_Definition   =>\n                   New_Occurrence_Of (Etype (Formal), Loc)));\n \n+            --  The object is initialized with an explicit assignment\n+            --  later. Indicate that it does not need an initialization\n+            --  to prevent spurious warnings if the type excludes null.\n+\n+            Set_No_Initialization (Last (Decls));\n+\n             if Ekind (Formal) /= E_Out_Parameter then\n \n                --  Generate:\n@@ -14577,15 +14586,22 @@ package body Exp_Ch9 is\n                    Expression => New_Copy_Tree (Actual)));\n             end if;\n \n-            --  Generate:\n+            --  If the actual is not controlling, generate:\n+\n             --    Jnn'unchecked_access\n \n-            Append_To (Params,\n-              Make_Attribute_Reference (Loc,\n-                Attribute_Name => Name_Unchecked_Access,\n-                Prefix         => New_Occurrence_Of (Temp_Nam, Loc)));\n+            --  and add it to aggegate for access to formals. Note that\n+            --  the actual may be by-copy but still be a controlling actual\n+            --  if it is an access to class-wide interface.\n \n-            Has_Param := True;\n+            if not Is_Controlling_Actual (Actual) then\n+               Append_To (Params,\n+                 Make_Attribute_Reference (Loc,\n+                   Attribute_Name => Name_Unchecked_Access,\n+                   Prefix         => New_Occurrence_Of (Temp_Nam, Loc)));\n+\n+               Has_Param := True;\n+            end if;\n \n          --  The controlling parameter is omitted\n "}, {"sha": "a2ba537fb373874f3f276547fca932924d332d4f", "filename": "gcc/ada/libgnarl/s-osinte__linux.ads", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-osinte__linux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-osinte__linux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-osinte__linux.ads?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -448,6 +448,9 @@ package System.OS_Interface is\n       abstime : access timespec) return int;\n    pragma Import (C, pthread_cond_timedwait, \"pthread_cond_timedwait\");\n \n+   Relative_Timed_Wait : constant Boolean := False;\n+   --  pthread_cond_timedwait requires an absolute delay time\n+\n    --------------------------\n    -- POSIX.1c  Section 13 --\n    --------------------------"}, {"sha": "5da10824a157d146da2d0d98b80bd8cb51f5e10a", "filename": "gcc/ada/libgnarl/s-taprop__linux.adb", "status": "modified", "additions": 37, "deletions": 232, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__linux.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -38,9 +38,7 @@ pragma Polling (Off);\n --  Turn off polling, we do not want ATC polling to take place during tasking\n --  operations. It causes infinite loops and other problems.\n \n-with Interfaces.C; use Interfaces;\n-use type Interfaces.C.int;\n-use type Interfaces.C.long;\n+with Interfaces.C; use Interfaces; use type Interfaces.C.int;\n \n with System.Task_Info;\n with System.Tasking.Debug;\n@@ -112,8 +110,6 @@ package body System.Task_Primitives.Operations is\n    --  Constant to indicate that the thread identifier has not yet been\n    --  initialized.\n \n-   Base_Monotonic_Clock : Duration := 0.0;\n-\n    --------------------\n    -- Local Packages --\n    --------------------\n@@ -141,6 +137,38 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   package Monotonic is\n+\n+      function Monotonic_Clock return Duration;\n+      pragma Inline (Monotonic_Clock);\n+      --  Returns \"absolute\" time, represented as an offset relative to \"the\n+      --  Epoch\", which is Jan 1, 1970. This clock implementation is immune to\n+      --  the system's clock changes.\n+\n+      function RT_Resolution return Duration;\n+      pragma Inline (RT_Resolution);\n+      --  Returns resolution of the underlying clock used to implement RT_Clock\n+\n+      procedure Timed_Sleep\n+        (Self_ID  : ST.Task_Id;\n+         Time     : Duration;\n+         Mode     : ST.Delay_Modes;\n+         Reason   : System.Tasking.Task_States;\n+         Timedout : out Boolean;\n+         Yielded  : out Boolean);\n+      --  Combination of Sleep (above) and Timed_Delay\n+\n+      procedure Timed_Delay\n+        (Self_ID : ST.Task_Id;\n+         Time    : Duration;\n+         Mode    : ST.Delay_Modes);\n+      --  Implement the semantics of the delay statement.\n+      --  The caller should be abort-deferred and should not hold any locks.\n+\n+   end Monotonic;\n+\n+   package body Monotonic is separate;\n+\n    ----------------------------------\n    -- ATCB allocation/deallocation --\n    ----------------------------------\n@@ -169,11 +197,6 @@ package body System.Task_Primitives.Operations is\n \n    procedure Abort_Handler (signo : Signal);\n \n-   function Compute_Base_Monotonic_Clock return Duration;\n-   --  The monotonic clock epoch is set to some undetermined time in the past\n-   --  (typically system boot time). In order to use the monotonic clock for\n-   --  absolute time, the offset from a known epoch is needed.\n-\n    function GNAT_pthread_condattr_setup\n      (attr : access pthread_condattr_t) return C.int;\n    pragma Import\n@@ -275,100 +298,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Handler;\n \n-   ----------------------------------\n-   -- Compute_Base_Monotonic_Clock --\n-   ----------------------------------\n-\n-   function Compute_Base_Monotonic_Clock return Duration is\n-      Aft     : Duration;\n-      Bef     : Duration;\n-      Mon     : Duration;\n-      Res_A   : Interfaces.C.int;\n-      Res_B   : Interfaces.C.int;\n-      Res_M   : Interfaces.C.int;\n-      TS_Aft  : aliased timespec;\n-      TS_Aft0 : aliased timespec;\n-      TS_Bef  : aliased timespec;\n-      TS_Bef0 : aliased timespec;\n-      TS_Mon  : aliased timespec;\n-      TS_Mon0 : aliased timespec;\n-\n-   begin\n-      Res_B :=\n-        clock_gettime\n-          (clock_id => OSC.CLOCK_REALTIME,\n-           tp       => TS_Bef0'Unchecked_Access);\n-      pragma Assert (Res_B = 0);\n-\n-      Res_M :=\n-        clock_gettime\n-          (clock_id => OSC.CLOCK_RT_Ada,\n-           tp       => TS_Mon0'Unchecked_Access);\n-      pragma Assert (Res_M = 0);\n-\n-      Res_A :=\n-        clock_gettime\n-          (clock_id => OSC.CLOCK_REALTIME,\n-           tp       => TS_Aft0'Unchecked_Access);\n-      pragma Assert (Res_A = 0);\n-\n-      for I in 1 .. 10 loop\n-\n-         --  Guard against a leap second that will cause CLOCK_REALTIME to jump\n-         --  backwards. In the extrenmely unlikely event we call clock_gettime\n-         --  before and after the jump the epoch, the result will be off\n-         --  slightly.\n-         --  Use only results where the tv_sec values match, for the sake of\n-         --  convenience.\n-         --  Also try to calculate the most accurate epoch by taking the\n-         --  minimum difference of 10 tries.\n-\n-         Res_B :=\n-           clock_gettime\n-             (clock_id => OSC.CLOCK_REALTIME,\n-              tp       => TS_Bef'Unchecked_Access);\n-         pragma Assert (Res_B = 0);\n-\n-         Res_M :=\n-           clock_gettime\n-             (clock_id => OSC.CLOCK_RT_Ada,\n-              tp       => TS_Mon'Unchecked_Access);\n-         pragma Assert (Res_M = 0);\n-\n-         Res_A :=\n-           clock_gettime\n-             (clock_id => OSC.CLOCK_REALTIME,\n-              tp       => TS_Aft'Unchecked_Access);\n-         pragma Assert (Res_A = 0);\n-\n-         --  The calls to clock_gettime before the loop were no good\n-\n-         if (TS_Bef0.tv_sec /= TS_Aft0.tv_sec\n-               and then TS_Bef.tv_sec  = TS_Aft.tv_sec)\n-\n-           --  The most recent calls to clock_gettime were better\n-\n-           or else\n-             (TS_Bef0.tv_sec = TS_Aft0.tv_sec\n-                and then TS_Bef.tv_sec = TS_Aft.tv_sec\n-                and then (TS_Aft.tv_nsec - TS_Bef.tv_nsec\n-                            < TS_Aft0.tv_nsec - TS_Bef0.tv_nsec))\n-         then\n-            TS_Bef0 := TS_Bef;\n-            TS_Aft0 := TS_Aft;\n-            TS_Mon0 := TS_Mon;\n-         end if;\n-      end loop;\n-\n-      Bef := To_Duration (TS_Bef0);\n-      Mon := To_Duration (TS_Mon0);\n-      Aft := To_Duration (TS_Aft0);\n-\n-      --  Distribute the division, to avoid potential type overflow someday\n-\n-      return Bef / 2 + Aft / 2 - Mon;\n-   end Compute_Base_Monotonic_Clock;\n-\n    --------------\n    -- Lock_RTS --\n    --------------\n@@ -690,56 +619,7 @@ package body System.Task_Primitives.Operations is\n       Mode     : ST.Delay_Modes;\n       Reason   : System.Tasking.Task_States;\n       Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time - Base_Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased timespec;\n-      Result     : C.int;\n-\n-   begin\n-      Timedout := True;\n-      Yielded := False;\n-\n-      Abs_Time :=\n-        (if Mode = Relative\n-         then Duration'Min (Time, Max_Sensible_Delay) + Check_Time\n-         else Duration'Min (Check_Time + Max_Sensible_Delay,\n-                            Time - Base_Monotonic_Clock));\n-\n-      if Abs_Time > Check_Time then\n-         Request := To_Timespec (Abs_Time);\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time + Base_Monotonic_Clock <= Check_Time\n-                      or else Check_Time < Base_Time;\n-\n-            if Result in 0 | EINTR then\n-\n-               --  Somebody may have called Wakeup for us\n-\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            pragma Assert (Result = ETIMEDOUT);\n-         end loop;\n-      end if;\n-   end Timed_Sleep;\n+      Yielded  : out Boolean) renames Monotonic.Timed_Sleep;\n \n    -----------------\n    -- Timed_Delay --\n@@ -751,92 +631,19 @@ package body System.Task_Primitives.Operations is\n    procedure Timed_Delay\n      (Self_ID : Task_Id;\n       Time    : Duration;\n-      Mode    : ST.Delay_Modes)\n-   is\n-      Base_Time  : constant Duration := Monotonic_Clock;\n-      Check_Time : Duration := Base_Time - Base_Monotonic_Clock;\n-      Abs_Time   : Duration;\n-      Request    : aliased timespec;\n-\n-      Result : C.int;\n-      pragma Warnings (Off, Result);\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      Write_Lock (Self_ID);\n-\n-      Abs_Time :=\n-        (if Mode = Relative\n-         then Time + Check_Time\n-         else Duration'Min (Check_Time + Max_Sensible_Delay,\n-                            Time - Base_Monotonic_Clock));\n-\n-      if Abs_Time > Check_Time then\n-         Request := To_Timespec (Abs_Time);\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time + Base_Monotonic_Clock <= Check_Time\n-                      or else Check_Time < Base_Time;\n-\n-            pragma Assert (Result in 0 | ETIMEDOUT | EINTR);\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      Result := sched_yield;\n-   end Timed_Delay;\n+      Mode    : ST.Delay_Modes) renames Monotonic.Timed_Delay;\n \n    ---------------------\n    -- Monotonic_Clock --\n    ---------------------\n \n-   function Monotonic_Clock return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := clock_gettime\n-        (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-\n-      return Base_Monotonic_Clock + To_Duration (TS);\n-   end Monotonic_Clock;\n+   function Monotonic_Clock return Duration renames Monotonic.Monotonic_Clock;\n \n    -------------------\n    -- RT_Resolution --\n    -------------------\n \n-   function RT_Resolution return Duration is\n-      TS     : aliased timespec;\n-      Result : C.int;\n-\n-   begin\n-      Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-\n-      return To_Duration (TS);\n-   end RT_Resolution;\n+   function RT_Resolution return Duration renames Monotonic.RT_Resolution;\n \n    ------------\n    -- Wakeup --\n@@ -1612,8 +1419,6 @@ package body System.Task_Primitives.Operations is\n \n       Interrupt_Management.Initialize;\n \n-      Base_Monotonic_Clock := Compute_Base_Monotonic_Clock;\n-\n       --  Prepare the set of signals that should be unblocked in all tasks\n \n       Result := sigemptyset (Unblocked_Signal_Mask'Access);"}, {"sha": "d9ee078b3649074a365be5eb98af43678cb7fc61", "filename": "gcc/ada/libgnarl/s-taprop__posix.adb", "status": "modified", "additions": 36, "deletions": 206, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-taprop__posix.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -145,6 +145,38 @@ package body System.Task_Primitives.Operations is\n    package body Specific is separate;\n    --  The body of this package is target specific\n \n+   package Monotonic is\n+\n+      function Monotonic_Clock return Duration;\n+      pragma Inline (Monotonic_Clock);\n+      --  Returns \"absolute\" time, represented as an offset relative to \"the\n+      --  Epoch\", which is Jan 1, 1970. This clock implementation is immune to\n+      --  the system's clock changes.\n+\n+      function RT_Resolution return Duration;\n+      pragma Inline (RT_Resolution);\n+      --  Returns resolution of the underlying clock used to implement RT_Clock\n+\n+      procedure Timed_Sleep\n+        (Self_ID  : ST.Task_Id;\n+         Time     : Duration;\n+         Mode     : ST.Delay_Modes;\n+         Reason   : System.Tasking.Task_States;\n+         Timedout : out Boolean;\n+         Yielded  : out Boolean);\n+      --  Combination of Sleep (above) and Timed_Delay\n+\n+      procedure Timed_Delay\n+        (Self_ID : ST.Task_Id;\n+         Time    : Duration;\n+         Mode    : ST.Delay_Modes);\n+      --  Implement the semantics of the delay statement.\n+      --  The caller should be abort-deferred and should not hold any locks.\n+\n+   end Monotonic;\n+\n+   package body Monotonic is separate;\n+\n    ----------------------------------\n    -- ATCB allocation/deallocation --\n    ----------------------------------\n@@ -183,18 +215,6 @@ package body System.Task_Primitives.Operations is\n    pragma Import (C,\n      GNAT_pthread_condattr_setup, \"__gnat_pthread_condattr_setup\");\n \n-   procedure Compute_Deadline\n-     (Time       : Duration;\n-      Mode       : ST.Delay_Modes;\n-      Check_Time : out Duration;\n-      Abs_Time   : out Duration;\n-      Rel_Time   : out Duration);\n-   --  Helper for Timed_Sleep and Timed_Delay: given a deadline specified by\n-   --  Time and Mode, compute the current clock reading (Check_Time), and the\n-   --  target absolute and relative clock readings (Abs_Time, Rel_Time). The\n-   --  epoch for Time depends on Mode; the epoch for Check_Time and Abs_Time\n-   --  is always that of CLOCK_RT_Ada.\n-\n    -------------------\n    -- Abort_Handler --\n    -------------------\n@@ -253,67 +273,6 @@ package body System.Task_Primitives.Operations is\n       end if;\n    end Abort_Handler;\n \n-   ----------------------\n-   -- Compute_Deadline --\n-   ----------------------\n-\n-   procedure Compute_Deadline\n-     (Time       : Duration;\n-      Mode       : ST.Delay_Modes;\n-      Check_Time : out Duration;\n-      Abs_Time   : out Duration;\n-      Rel_Time   : out Duration)\n-   is\n-   begin\n-      Check_Time := Monotonic_Clock;\n-\n-      --  Relative deadline\n-\n-      if Mode = Relative then\n-         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n-         end if;\n-\n-         pragma Warnings (Off);\n-         --  Comparison \"OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\" is compile\n-         --  time known.\n-\n-      --  Absolute deadline specified using the tasking clock (CLOCK_RT_Ada)\n-\n-      elsif Mode = Absolute_RT\n-        or else OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\n-      then\n-         pragma Warnings (On);\n-         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n-\n-         if Relative_Timed_Wait then\n-            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n-         end if;\n-\n-      --  Absolute deadline specified using the calendar clock, in the\n-      --  case where it is not the same as the tasking clock: compensate for\n-      --  difference between clock epochs (Base_Time - Base_Cal_Time).\n-\n-      else\n-         declare\n-            Cal_Check_Time : constant Duration := OS_Primitives.Clock;\n-            RT_Time        : constant Duration :=\n-                               Time + Check_Time - Cal_Check_Time;\n-\n-         begin\n-            Abs_Time :=\n-              Duration'Min (Check_Time + Max_Sensible_Delay, RT_Time);\n-\n-            if Relative_Timed_Wait then\n-               Rel_Time :=\n-                 Duration'Min (Max_Sensible_Delay, RT_Time - Check_Time);\n-            end if;\n-         end;\n-      end if;\n-   end Compute_Deadline;\n-\n    -----------------\n    -- Stack_Guard --\n    -----------------\n@@ -600,60 +559,7 @@ package body System.Task_Primitives.Operations is\n       Mode     : ST.Delay_Modes;\n       Reason   : Task_States;\n       Timedout : out Boolean;\n-      Yielded  : out Boolean)\n-   is\n-      pragma Unreferenced (Reason);\n-\n-      Base_Time  : Duration;\n-      Check_Time : Duration;\n-      Abs_Time   : Duration;\n-      Rel_Time   : Duration;\n-\n-      Request    : aliased timespec;\n-      Result     : Interfaces.C.int;\n-\n-   begin\n-      Timedout := True;\n-      Yielded := False;\n-\n-      Compute_Deadline\n-        (Time       => Time,\n-         Mode       => Mode,\n-         Check_Time => Check_Time,\n-         Abs_Time   => Abs_Time,\n-         Rel_Time   => Rel_Time);\n-      Base_Time := Check_Time;\n-\n-      if Abs_Time > Check_Time then\n-         Request :=\n-           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            if Result = 0 or Result = EINTR then\n-\n-               --  Somebody may have called Wakeup for us\n-\n-               Timedout := False;\n-               exit;\n-            end if;\n-\n-            pragma Assert (Result = ETIMEDOUT);\n-         end loop;\n-      end if;\n-   end Timed_Sleep;\n+      Yielded  : out Boolean) renames Monotonic.Timed_Sleep;\n \n    -----------------\n    -- Timed_Delay --\n@@ -665,95 +571,19 @@ package body System.Task_Primitives.Operations is\n    procedure Timed_Delay\n      (Self_ID : Task_Id;\n       Time    : Duration;\n-      Mode    : ST.Delay_Modes)\n-   is\n-      Base_Time  : Duration;\n-      Check_Time : Duration;\n-      Abs_Time   : Duration;\n-      Rel_Time   : Duration;\n-      Request    : aliased timespec;\n-\n-      Result : Interfaces.C.int;\n-      pragma Warnings (Off, Result);\n-\n-   begin\n-      if Single_Lock then\n-         Lock_RTS;\n-      end if;\n-\n-      Write_Lock (Self_ID);\n-\n-      Compute_Deadline\n-        (Time       => Time,\n-         Mode       => Mode,\n-         Check_Time => Check_Time,\n-         Abs_Time   => Abs_Time,\n-         Rel_Time   => Rel_Time);\n-      Base_Time := Check_Time;\n-\n-      if Abs_Time > Check_Time then\n-         Request :=\n-           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n-         Self_ID.Common.State := Delay_Sleep;\n-\n-         loop\n-            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n-\n-            Result :=\n-              pthread_cond_timedwait\n-                (cond    => Self_ID.Common.LL.CV'Access,\n-                 mutex   => (if Single_Lock\n-                             then Single_RTS_Lock'Access\n-                             else Self_ID.Common.LL.L'Access),\n-                 abstime => Request'Access);\n-\n-            Check_Time := Monotonic_Clock;\n-            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n-\n-            pragma Assert (Result = 0\n-                             or else Result = ETIMEDOUT\n-                             or else Result = EINTR);\n-         end loop;\n-\n-         Self_ID.Common.State := Runnable;\n-      end if;\n-\n-      Unlock (Self_ID);\n-\n-      if Single_Lock then\n-         Unlock_RTS;\n-      end if;\n-\n-      Result := sched_yield;\n-   end Timed_Delay;\n+      Mode    : ST.Delay_Modes) renames Monotonic.Timed_Delay;\n \n    ---------------------\n    -- Monotonic_Clock --\n    ---------------------\n \n-   function Monotonic_Clock return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := clock_gettime\n-        (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-      return To_Duration (TS);\n-   end Monotonic_Clock;\n+   function Monotonic_Clock return Duration renames Monotonic.Monotonic_Clock;\n \n    -------------------\n    -- RT_Resolution --\n    -------------------\n \n-   function RT_Resolution return Duration is\n-      TS     : aliased timespec;\n-      Result : Interfaces.C.int;\n-   begin\n-      Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n-      pragma Assert (Result = 0);\n-\n-      return To_Duration (TS);\n-   end RT_Resolution;\n+   function RT_Resolution return Duration renames Monotonic.RT_Resolution;\n \n    ------------\n    -- Wakeup --"}, {"sha": "b6164aa19ed4ee712bc4768900d86842771ecf4b", "filename": "gcc/ada/libgnarl/s-tpopmo.adb", "status": "added", "additions": 283, "deletions": 0, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnarl%2Fs-tpopmo.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -0,0 +1,283 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                 GNAT RUN-TIME LIBRARY (GNARL) COMPONENTS                 --\n+--                                                                          --\n+--               SYSTEM.TASK_PRIMITIVES.OPERATIONS.MONOTONIC                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--         Copyright (C) 1992-2017, Free Software Foundation, Inc.          --\n+--                                                                          --\n+-- GNARL is free software; you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNARL was developed by the GNARL team at Florida State University.       --\n+-- Extensive contributions were provided by Ada Core Technologies, Inc.     --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the Monotonic version of this package for Posix and Linux targets.\n+\n+separate (System.Task_Primitives.Operations)\n+package body Monotonic is\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   procedure Compute_Deadline\n+     (Time       : Duration;\n+      Mode       : ST.Delay_Modes;\n+      Check_Time : out Duration;\n+      Abs_Time   : out Duration;\n+      Rel_Time   : out Duration);\n+   --  Helper for Timed_Sleep and Timed_Delay: given a deadline specified by\n+   --  Time and Mode, compute the current clock reading (Check_Time), and the\n+   --  target absolute and relative clock readings (Abs_Time, Rel_Time). The\n+   --  epoch for Time depends on Mode; the epoch for Check_Time and Abs_Time\n+   --  is always that of CLOCK_RT_Ada.\n+\n+   ---------------------\n+   -- Monotonic_Clock --\n+   ---------------------\n+\n+   function Monotonic_Clock return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+   begin\n+      Result := clock_gettime\n+        (clock_id => OSC.CLOCK_RT_Ada, tp => TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+\n+      return To_Duration (TS);\n+   end Monotonic_Clock;\n+\n+   -------------------\n+   -- RT_Resolution --\n+   -------------------\n+\n+   function RT_Resolution return Duration is\n+      TS     : aliased timespec;\n+      Result : Interfaces.C.int;\n+\n+   begin\n+      Result := clock_getres (OSC.CLOCK_REALTIME, TS'Unchecked_Access);\n+      pragma Assert (Result = 0);\n+\n+      return To_Duration (TS);\n+   end RT_Resolution;\n+\n+   ----------------------\n+   -- Compute_Deadline --\n+   ----------------------\n+\n+   procedure Compute_Deadline\n+     (Time       : Duration;\n+      Mode       : ST.Delay_Modes;\n+      Check_Time : out Duration;\n+      Abs_Time   : out Duration;\n+      Rel_Time   : out Duration)\n+   is\n+   begin\n+      Check_Time := Monotonic_Clock;\n+\n+      --  Relative deadline\n+\n+      if Mode = Relative then\n+         Abs_Time := Duration'Min (Time, Max_Sensible_Delay) + Check_Time;\n+\n+         if Relative_Timed_Wait then\n+            Rel_Time := Duration'Min (Max_Sensible_Delay, Time);\n+         end if;\n+\n+         pragma Warnings (Off);\n+         --  Comparison \"OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\" is compile\n+         --  time known.\n+\n+      --  Absolute deadline specified using the tasking clock (CLOCK_RT_Ada)\n+\n+      elsif Mode = Absolute_RT\n+        or else OSC.CLOCK_RT_Ada = OSC.CLOCK_REALTIME\n+      then\n+         pragma Warnings (On);\n+         Abs_Time := Duration'Min (Check_Time + Max_Sensible_Delay, Time);\n+\n+         if Relative_Timed_Wait then\n+            Rel_Time := Duration'Min (Max_Sensible_Delay, Time - Check_Time);\n+         end if;\n+\n+      --  Absolute deadline specified using the calendar clock, in the\n+      --  case where it is not the same as the tasking clock: compensate for\n+      --  difference between clock epochs (Base_Time - Base_Cal_Time).\n+\n+      else\n+         declare\n+            Cal_Check_Time : constant Duration := OS_Primitives.Clock;\n+            RT_Time        : constant Duration :=\n+                               Time + Check_Time - Cal_Check_Time;\n+\n+         begin\n+            Abs_Time :=\n+              Duration'Min (Check_Time + Max_Sensible_Delay, RT_Time);\n+\n+            if Relative_Timed_Wait then\n+               Rel_Time :=\n+                 Duration'Min (Max_Sensible_Delay, RT_Time - Check_Time);\n+            end if;\n+         end;\n+      end if;\n+   end Compute_Deadline;\n+\n+   -----------------\n+   -- Timed_Sleep --\n+   -----------------\n+\n+   --  This is for use within the run-time system, so abort is\n+   --  assumed to be already deferred, and the caller should be\n+   --  holding its own ATCB lock.\n+\n+   procedure Timed_Sleep\n+     (Self_ID  : ST.Task_Id;\n+      Time     : Duration;\n+      Mode     : ST.Delay_Modes;\n+      Reason   : System.Tasking.Task_States;\n+      Timedout : out Boolean;\n+      Yielded  : out Boolean)\n+   is\n+      pragma Unreferenced (Reason);\n+\n+      Base_Time  : Duration;\n+      Check_Time : Duration;\n+      Abs_Time   : Duration;\n+      Rel_Time   : Duration;\n+\n+      Request    : aliased timespec;\n+      Result     : Interfaces.C.int;\n+\n+   begin\n+      Timedout := True;\n+      Yielded := False;\n+\n+      Compute_Deadline\n+        (Time       => Time,\n+         Mode       => Mode,\n+         Check_Time => Check_Time,\n+         Abs_Time   => Abs_Time,\n+         Rel_Time   => Rel_Time);\n+      Base_Time := Check_Time;\n+\n+      if Abs_Time > Check_Time then\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n+\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+\n+            if Result in 0 | EINTR then\n+\n+               --  Somebody may have called Wakeup for us\n+\n+               Timedout := False;\n+               exit;\n+            end if;\n+\n+            pragma Assert (Result = ETIMEDOUT);\n+         end loop;\n+      end if;\n+   end Timed_Sleep;\n+\n+   -----------------\n+   -- Timed_Delay --\n+   -----------------\n+\n+   --  This is for use in implementing delay statements, so we assume the\n+   --  caller is abort-deferred but is holding no locks.\n+\n+   procedure Timed_Delay\n+     (Self_ID : ST.Task_Id;\n+      Time    : Duration;\n+      Mode    : ST.Delay_Modes)\n+   is\n+      Base_Time  : Duration;\n+      Check_Time : Duration;\n+      Abs_Time   : Duration;\n+      Rel_Time   : Duration;\n+      Request    : aliased timespec;\n+\n+      Result : Interfaces.C.int;\n+      pragma Warnings (Off, Result);\n+\n+   begin\n+      if Single_Lock then\n+         Lock_RTS;\n+      end if;\n+\n+      Write_Lock (Self_ID);\n+\n+      Compute_Deadline\n+        (Time       => Time,\n+         Mode       => Mode,\n+         Check_Time => Check_Time,\n+         Abs_Time   => Abs_Time,\n+         Rel_Time   => Rel_Time);\n+      Base_Time := Check_Time;\n+\n+      if Abs_Time > Check_Time then\n+         Request :=\n+           To_Timespec (if Relative_Timed_Wait then Rel_Time else Abs_Time);\n+         Self_ID.Common.State := Delay_Sleep;\n+\n+         loop\n+            exit when Self_ID.Pending_ATC_Level < Self_ID.ATC_Nesting_Level;\n+\n+            Result :=\n+              pthread_cond_timedwait\n+                (cond    => Self_ID.Common.LL.CV'Access,\n+                 mutex   => (if Single_Lock\n+                             then Single_RTS_Lock'Access\n+                             else Self_ID.Common.LL.L'Access),\n+                 abstime => Request'Access);\n+\n+            Check_Time := Monotonic_Clock;\n+            exit when Abs_Time <= Check_Time or else Check_Time < Base_Time;\n+\n+            pragma Assert (Result in 0 | ETIMEDOUT | EINTR);\n+         end loop;\n+\n+         Self_ID.Common.State := Runnable;\n+      end if;\n+\n+      Unlock (Self_ID);\n+\n+      if Single_Lock then\n+         Unlock_RTS;\n+      end if;\n+\n+      Result := sched_yield;\n+   end Timed_Delay;\n+\n+end Monotonic;"}, {"sha": "bdc8aba1e1fd306f4762510136160d322f29988d", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -9108,10 +9108,10 @@ package body Sem_Ch8 is\n       --  Deal with use clauses within the context area if the current\n       --  scope is a compilation unit.\n \n-      if Is_Compilation_Unit (Current_Scope) then\n-\n-         pragma Assert (Scope_Stack.Last /= Scope_Stack.First);\n-\n+      if Is_Compilation_Unit (Current_Scope)\n+        and then Sloc (Scope_Stack.Table\n+                        (Scope_Stack.Last - 1).Entity) = Standard_Location\n+      then\n          Update_Chain_In_Scope (Scope_Stack.Last - 1);\n       end if;\n    end Update_Use_Clause_Chain;"}, {"sha": "3698bbf16bdf0b8c7583c4e60ea23505885a1cdf", "filename": "gcc/ada/sem_util.adb", "status": "modified", "additions": 20, "deletions": 4, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fsem_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Fada%2Fsem_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_util.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -13186,17 +13186,29 @@ package body Sem_Util is\n    function Is_Controlling_Limited_Procedure\n      (Proc_Nam : Entity_Id) return Boolean\n    is\n+      Param     : Node_Id;\n       Param_Typ : Entity_Id := Empty;\n \n    begin\n       if Ekind (Proc_Nam) = E_Procedure\n         and then Present (Parameter_Specifications (Parent (Proc_Nam)))\n       then\n-         Param_Typ := Etype (Parameter_Type (First (\n-                        Parameter_Specifications (Parent (Proc_Nam)))));\n+         Param := Parameter_Type (First (\n+                    Parameter_Specifications (Parent (Proc_Nam))));\n \n-      --  In this case where an Itype was created, the procedure call has been\n-      --  rewritten.\n+         --  The formal may be an anonymous access type.\n+\n+         if Nkind (Param) = N_Access_Definition then\n+            Param_Typ := Entity (Subtype_Mark (Param));\n+\n+         else\n+            Param_Typ := Etype (Param);\n+         end if;\n+\n+      --  In the case where an Itype was created for a dispatchin call, the\n+      --  procedure call has been rewritten. The actual may be an access to\n+      --  interface type in which case it is the designated type that is the\n+      --  controlling type.\n \n       elsif Present (Associated_Node_For_Itype (Proc_Nam))\n         and then Present (Original_Node (Associated_Node_For_Itype (Proc_Nam)))\n@@ -13207,6 +13219,10 @@ package body Sem_Util is\n          Param_Typ :=\n            Etype (First (Parameter_Associations\n                           (Associated_Node_For_Itype (Proc_Nam))));\n+\n+         if Ekind (Param_Typ) = E_Anonymous_Access_Type then\n+            Param_Typ := Directly_Designated_Type (Param_Typ);\n+         end if;\n       end if;\n \n       if Present (Param_Typ) then"}, {"sha": "04d7910c1489568fb6639056599edea60601ccec", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -1,3 +1,9 @@\n+2017-10-20  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* gnat.dg/sync_iface_call.adb, gnat.dg/sync_iface_call_pkg.ads,\n+\tgnat.dg/sync_iface_call_pkg2.adb, gnat.dg/sync_iface_call_pkg2.ads:\n+\tNew testcase.\n+\n 2017-10-20  Justin Squirek  <squirek@adacore.com>\n \n \t* gnat.dg/default_pkg_actual.adb, gnat.dg/default_pkg_actual2.adb: New"}, {"sha": "1603981892ed78d4d921e82913b99720e8b16ed2", "filename": "gcc/testsuite/gnat.dg/sync_iface_call.adb", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -0,0 +1,34 @@\n+--  { dg-do compile }\n+\n+with Sync_Iface_Call_Pkg;\n+with Sync_Iface_Call_Pkg2;\n+\n+procedure Sync_Iface_Call is\n+\n+   Impl : access Sync_Iface_Call_Pkg.IFace'Class :=\n+       new Sync_Iface_Call_Pkg2.Impl;\n+   Val : aliased Integer := 10;\n+begin\n+   select\n+      Impl.Do_Stuff (Val);\n+   or\n+      delay 10.0;\n+   end select;\n+   select\n+      Impl.Do_Stuff_Access (Val'Access);\n+   or\n+      delay 10.0;\n+   end select;\n+\n+   select\n+      Impl.Do_Stuff_2 (Val);\n+   or\n+      delay 10.0;\n+   end select;\n+\n+   select\n+      Impl.Do_Stuff_2_Access (Val'Access);\n+   or\n+      delay 10.0;\n+   end select;\n+end Sync_Iface_Call;"}, {"sha": "e392c024c79895a944495b435cd40d3acfeb8551", "filename": "gcc/testsuite/gnat.dg/sync_iface_call_pkg.ads", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg.ads?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -0,0 +1,21 @@\n+package Sync_Iface_Call_Pkg is\n+\n+   type IFace is synchronized interface;\n+\n+   procedure Do_Stuff\n+     (This  : in out IFace;\n+      Value : in Integer) is null;\n+\n+   procedure Do_Stuff_Access\n+     (This  : in out IFace;\n+      Value : not null access Integer) is null;\n+\n+   procedure Do_Stuff_2\n+     (This  : not null access IFace;\n+      Value : in Integer) is null;\n+\n+   procedure Do_Stuff_2_Access\n+     (This  : not null access IFace;\n+      Value : not null access Integer) is null;\n+\n+end Sync_Iface_Call_Pkg;"}, {"sha": "b3c221e5b1a8d97e1b3f2ec44aab282eebc5f4c2", "filename": "gcc/testsuite/gnat.dg/sync_iface_call_pkg2.adb", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.adb?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -0,0 +1,8 @@\n+package body Sync_Iface_Call_Pkg2 is\n+\n+   task body Impl is\n+   begin\n+      null;\n+   end Impl;\n+\n+end Sync_Iface_Call_Pkg2;"}, {"sha": "ca21b1d6d088b82f9757ea02643af7fef14402a7", "filename": "gcc/testsuite/gnat.dg/sync_iface_call_pkg2.ads", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c840bf9bc92e71291a9dc653688bf496aa219b7d/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fsync_iface_call_pkg2.ads?ref=c840bf9bc92e71291a9dc653688bf496aa219b7d", "patch": "@@ -0,0 +1,7 @@\n+with Sync_Iface_Call_Pkg;\n+\n+package Sync_Iface_Call_Pkg2 is\n+\n+   task type Impl is new Sync_Iface_Call_Pkg.IFace with end;\n+\n+end Sync_Iface_Call_Pkg2;"}]}