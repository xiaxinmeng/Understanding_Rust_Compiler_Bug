{"sha": "330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzMwZGIxZTMwMTI1MGYyYjgxYTFkYzc5YThjMDdiMmQ5ZTdkZmMyOQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-04-15T12:45:58Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-04-15T12:45:58Z"}, "message": "fold-const.c (LOWPART, [...]): Move ...\n\n2010-04-15  Richard Guenther  <rguenther@suse.de>\n\n\t* fold-const.c (LOWPART, HIGHPART, BASE, encode, decode,\n\tfit_double_type, force_fit_type_double, add_double_with_sign,\n\tneg_double, mul_double_with_sign, lshift_double, rshift_double,\n\tlrotate_double, rrotate_double, div_and_round_double): Move ...\n\t* double-int.c: ... here.\n\t* tree.h (force_fit_type_double, fit_double_type, add_double_with_sign,\n\tadd_double, neg_double, mul_double_with_sign, mul_double,\n\tlshift_double, rshift_double, lrotate_double, rrotate_double,\n\tdiv_and_round_double): Move prototypes ...\n\t* double-int.h: ... here.\n\nFrom-SVN: r158372", "tree": {"sha": "ef22bf965c36b317d7e9ce2473fb42ef161f830d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ef22bf965c36b317d7e9ce2473fb42ef161f830d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "html_url": "https://github.com/Rust-GCC/gccrs/commit/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "0b3467c4a3424bc3b960336dd87160db7a481f99", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b3467c4a3424bc3b960336dd87160db7a481f99", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b3467c4a3424bc3b960336dd87160db7a481f99"}], "stats": {"total": 1554, "additions": 793, "deletions": 761}, "files": [{"sha": "74cf0149ea9db6decb7eddeaaaaa84dbf5bfaa2b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "patch": "@@ -1,3 +1,16 @@\n+2010-04-15  Richard Guenther  <rguenther@suse.de>\n+\n+\t* fold-const.c (LOWPART, HIGHPART, BASE, encode, decode,\n+\tfit_double_type, force_fit_type_double, add_double_with_sign,\n+\tneg_double, mul_double_with_sign, lshift_double, rshift_double,\n+\tlrotate_double, rrotate_double, div_and_round_double): Move ...\n+\t* double-int.c: ... here.\n+\t* tree.h (force_fit_type_double, fit_double_type, add_double_with_sign,\n+\tadd_double, neg_double, mul_double_with_sign, mul_double,\n+\tlshift_double, rshift_double, lrotate_double, rrotate_double,\n+\tdiv_and_round_double): Move prototypes ...\n+\t* double-int.h: ... here.\n+\n 2010-04-15  Bernd Schmidt  <bernd.schmidt@codesourcery.com>\n \n \tPR target/43742"}, {"sha": "96e5884c96fc1fa346dda7f62fcdaf7b909ee8ba", "filename": "gcc/double-int.c", "status": "modified", "additions": 736, "deletions": 1, "changes": 737, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Fdouble-int.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Fdouble-int.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.c?ref=330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "patch": "@@ -23,6 +23,741 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm.h\"\n #include \"tree.h\"\n \n+/* We know that A1 + B1 = SUM1, using 2's complement arithmetic and ignoring\n+   overflow.  Suppose A, B and SUM have the same respective signs as A1, B1,\n+   and SUM1.  Then this yields nonzero if overflow occurred during the\n+   addition.\n+\n+   Overflow occurs if A and B have the same sign, but A and SUM differ in\n+   sign.  Use `^' to test whether signs differ, and `< 0' to isolate the\n+   sign.  */\n+#define OVERFLOW_SUM_SIGN(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n+\n+/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n+   We do that by representing the two-word integer in 4 words, with only\n+   HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive\n+   number.  The value of the word is LOWPART + HIGHPART * BASE.  */\n+\n+#define LOWPART(x) \\\n+  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)) - 1))\n+#define HIGHPART(x) \\\n+  ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT / 2)\n+#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT / 2)\n+\n+/* Unpack a two-word integer into 4 words.\n+   LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n+   WORDS points to the array of HOST_WIDE_INTs.  */\n+\n+static void\n+encode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n+{\n+  words[0] = LOWPART (low);\n+  words[1] = HIGHPART (low);\n+  words[2] = LOWPART (hi);\n+  words[3] = HIGHPART (hi);\n+}\n+\n+/* Pack an array of 4 words into a two-word integer.\n+   WORDS points to the array of words.\n+   The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n+\n+static void\n+decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n+\tHOST_WIDE_INT *hi)\n+{\n+  *low = words[0] + words[1] * BASE;\n+  *hi = words[2] + words[3] * BASE;\n+}\n+\n+/* Force the double-word integer L1, H1 to be within the range of the\n+   integer type TYPE.  Stores the properly truncated and sign-extended\n+   double-word integer in *LV, *HV.  Returns true if the operation\n+   overflows, that is, argument and result are different.  */\n+\n+int\n+fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, const_tree type)\n+{\n+  unsigned HOST_WIDE_INT low0 = l1;\n+  HOST_WIDE_INT high0 = h1;\n+  unsigned int prec = TYPE_PRECISION (type);\n+  int sign_extended_type;\n+\n+  /* Size types *are* sign extended.  */\n+  sign_extended_type = (!TYPE_UNSIGNED (type)\n+\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n+\t\t\t    && TYPE_IS_SIZETYPE (type)));\n+\n+  /* First clear all bits that are beyond the type's precision.  */\n+  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n+    ;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    h1 &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+  else\n+    {\n+      h1 = 0;\n+      if (prec < HOST_BITS_PER_WIDE_INT)\n+\tl1 &= ~((HOST_WIDE_INT) (-1) << prec);\n+    }\n+\n+  /* Then do sign extension if necessary.  */\n+  if (!sign_extended_type)\n+    /* No sign extension */;\n+  else if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n+    /* Correct width already.  */;\n+  else if (prec > HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* Sign extend top half? */\n+      if (h1 & ((unsigned HOST_WIDE_INT)1\n+\t\t<< (prec - HOST_BITS_PER_WIDE_INT - 1)))\n+\th1 |= (HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else if (prec == HOST_BITS_PER_WIDE_INT)\n+    {\n+      if ((HOST_WIDE_INT)l1 < 0)\n+\th1 = -1;\n+    }\n+  else\n+    {\n+      /* Sign extend bottom half? */\n+      if (l1 & ((unsigned HOST_WIDE_INT)1 << (prec - 1)))\n+\t{\n+\t  h1 = -1;\n+\t  l1 |= (HOST_WIDE_INT)(-1) << prec;\n+\t}\n+    }\n+\n+  *lv = l1;\n+  *hv = h1;\n+\n+  /* If the value didn't fit, signal overflow.  */\n+  return l1 != low0 || h1 != high0;\n+}\n+\n+/* We force the double-int HIGH:LOW to the range of the type TYPE by\n+   sign or zero extending it.\n+   OVERFLOWABLE indicates if we are interested\n+   in overflow of the value, when >0 we are only interested in signed\n+   overflow, for <0 we are interested in any overflow.  OVERFLOWED\n+   indicates whether overflow has already occurred.  CONST_OVERFLOWED\n+   indicates whether constant overflow has already occurred.  We force\n+   T's value to be within range of T's type (by setting to 0 or 1 all\n+   the bits outside the type's range).  We set TREE_OVERFLOWED if,\n+  \tOVERFLOWED is nonzero,\n+\tor OVERFLOWABLE is >0 and signed overflow occurs\n+\tor OVERFLOWABLE is <0 and any overflow occurs\n+   We return a new tree node for the extended double-int.  The node\n+   is shared if no overflow flags are set.  */\n+\n+tree\n+force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n+\t\t       HOST_WIDE_INT high, int overflowable,\n+\t\t       bool overflowed)\n+{\n+  int sign_extended_type;\n+  bool overflow;\n+\n+  /* Size types *are* sign extended.  */\n+  sign_extended_type = (!TYPE_UNSIGNED (type)\n+\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n+\t\t\t    && TYPE_IS_SIZETYPE (type)));\n+\n+  overflow = fit_double_type (low, high, &low, &high, type);\n+\n+  /* If we need to set overflow flags, return a new unshared node.  */\n+  if (overflowed || overflow)\n+    {\n+      if (overflowed\n+\t  || overflowable < 0\n+\t  || (overflowable > 0 && sign_extended_type))\n+\t{\n+          tree t = make_node (INTEGER_CST);\n+          TREE_INT_CST_LOW (t) = low;\n+          TREE_INT_CST_HIGH (t) = high;\n+          TREE_TYPE (t) = type;\n+\t  TREE_OVERFLOW (t) = 1;\n+\t  return t;\n+\t}\n+    }\n+\n+  /* Else build a shared node.  */\n+  return build_int_cst_wide (type, low, high);\n+}\n+\n+/* Add two doubleword integers with doubleword result.\n+   Return nonzero if the operation overflows according to UNSIGNED_P.\n+   Each argument is given as two `HOST_WIDE_INT' pieces.\n+   One argument is L1 and H1; the other, L2 and H2.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+int\n+add_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t\t      bool unsigned_p)\n+{\n+  unsigned HOST_WIDE_INT l;\n+  HOST_WIDE_INT h;\n+\n+  l = l1 + l2;\n+  h = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) h1\n+\t\t       + (unsigned HOST_WIDE_INT) h2\n+\t\t       + (l < l1));\n+\n+  *lv = l;\n+  *hv = h;\n+\n+  if (unsigned_p)\n+    return ((unsigned HOST_WIDE_INT) h < (unsigned HOST_WIDE_INT) h1\n+\t    || (h == h1\n+\t\t&& l < l1));\n+  else\n+    return OVERFLOW_SUM_SIGN (h1, h2, h);\n+}\n+\n+/* Negate a doubleword integer with doubleword result.\n+   Return nonzero if the operation overflows, assuming it's signed.\n+   The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+int\n+neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+{\n+  if (l1 == 0)\n+    {\n+      *lv = 0;\n+      *hv = - h1;\n+      return (*hv & h1) < 0;\n+    }\n+  else\n+    {\n+      *lv = -l1;\n+      *hv = ~h1;\n+      return 0;\n+    }\n+}\n+\n+/* Multiply two doubleword integers with doubleword result.\n+   Return nonzero if the operation overflows according to UNSIGNED_P.\n+   Each argument is given as two `HOST_WIDE_INT' pieces.\n+   One argument is L1 and H1; the other, L2 and H2.\n+   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+int\n+mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n+\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t\t      bool unsigned_p)\n+{\n+  HOST_WIDE_INT arg1[4];\n+  HOST_WIDE_INT arg2[4];\n+  HOST_WIDE_INT prod[4 * 2];\n+  unsigned HOST_WIDE_INT carry;\n+  int i, j, k;\n+  unsigned HOST_WIDE_INT toplow, neglow;\n+  HOST_WIDE_INT tophigh, neghigh;\n+\n+  encode (arg1, l1, h1);\n+  encode (arg2, l2, h2);\n+\n+  memset (prod, 0, sizeof prod);\n+\n+  for (i = 0; i < 4; i++)\n+    {\n+      carry = 0;\n+      for (j = 0; j < 4; j++)\n+\t{\n+\t  k = i + j;\n+\t  /* This product is <= 0xFFFE0001, the sum <= 0xFFFF0000.  */\n+\t  carry += arg1[i] * arg2[j];\n+\t  /* Since prod[p] < 0xFFFF, this sum <= 0xFFFFFFFF.  */\n+\t  carry += prod[k];\n+\t  prod[k] = LOWPART (carry);\n+\t  carry = HIGHPART (carry);\n+\t}\n+      prod[i + 4] = carry;\n+    }\n+\n+  decode (prod, lv, hv);\n+  decode (prod + 4, &toplow, &tophigh);\n+\n+  /* Unsigned overflow is immediate.  */\n+  if (unsigned_p)\n+    return (toplow | tophigh) != 0;\n+\n+  /* Check for signed overflow by calculating the signed representation of the\n+     top half of the result; it should agree with the low half's sign bit.  */\n+  if (h1 < 0)\n+    {\n+      neg_double (l2, h2, &neglow, &neghigh);\n+      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+    }\n+  if (h2 < 0)\n+    {\n+      neg_double (l1, h1, &neglow, &neghigh);\n+      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n+    }\n+  return (*hv < 0 ? ~(toplow & tophigh) : toplow | tophigh) != 0;\n+}\n+\n+/* Shift the doubleword integer in L1, H1 left by COUNT places\n+   keeping only PREC bits of result.\n+   Shift right if COUNT is negative.\n+   ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+void\n+lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t       HOST_WIDE_INT count, unsigned int prec,\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, bool arith)\n+{\n+  unsigned HOST_WIDE_INT signmask;\n+\n+  if (count < 0)\n+    {\n+      rshift_double (l1, h1, -count, prec, lv, hv, arith);\n+      return;\n+    }\n+\n+  if (SHIFT_COUNT_TRUNCATED)\n+    count %= prec;\n+\n+  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* Shifting by the host word size is undefined according to the\n+\t ANSI standard, so we must handle this as a special case.  */\n+      *hv = 0;\n+      *lv = 0;\n+    }\n+  else if (count >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      *hv = l1 << (count - HOST_BITS_PER_WIDE_INT);\n+      *lv = 0;\n+    }\n+  else\n+    {\n+      *hv = (((unsigned HOST_WIDE_INT) h1 << count)\n+\t     | (l1 >> (HOST_BITS_PER_WIDE_INT - count - 1) >> 1));\n+      *lv = l1 << count;\n+    }\n+\n+  /* Sign extend all bits that are beyond the precision.  */\n+\n+  signmask = -((prec > HOST_BITS_PER_WIDE_INT\n+\t\t? ((unsigned HOST_WIDE_INT) *hv\n+\t\t   >> (prec - HOST_BITS_PER_WIDE_INT - 1))\n+\t\t: (*lv >> (prec - 1))) & 1);\n+\n+  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n+    ;\n+  else if (prec >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      *hv &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n+      *hv |= signmask << (prec - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else\n+    {\n+      *hv = signmask;\n+      *lv &= ~((unsigned HOST_WIDE_INT) (-1) << prec);\n+      *lv |= signmask << prec;\n+    }\n+}\n+\n+/* Shift the doubleword integer in L1, H1 right by COUNT places\n+   keeping only PREC bits of result.  Shift left if COUNT is negative.\n+   ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+void\n+rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t       HOST_WIDE_INT count, unsigned int prec,\n+\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n+\t       bool arith)\n+{\n+  unsigned HOST_WIDE_INT signmask;\n+\n+  if (count < 0)\n+    {\n+      lshift_double (l1, h1, -count, prec, lv, hv, arith);\n+      return;\n+    }\n+\n+  signmask = (arith\n+\t      ? -((unsigned HOST_WIDE_INT) h1 >> (HOST_BITS_PER_WIDE_INT - 1))\n+\t      : 0);\n+\n+  if (SHIFT_COUNT_TRUNCATED)\n+    count %= prec;\n+\n+  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n+    {\n+      /* Shifting by the host word size is undefined according to the\n+\t ANSI standard, so we must handle this as a special case.  */\n+      *hv = 0;\n+      *lv = 0;\n+    }\n+  else if (count >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      *hv = 0;\n+      *lv = (unsigned HOST_WIDE_INT) h1 >> (count - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else\n+    {\n+      *hv = (unsigned HOST_WIDE_INT) h1 >> count;\n+      *lv = ((l1 >> count)\n+\t     | ((unsigned HOST_WIDE_INT) h1\n+\t\t<< (HOST_BITS_PER_WIDE_INT - count - 1) << 1));\n+    }\n+\n+  /* Zero / sign extend all bits that are beyond the precision.  */\n+\n+  if (count >= (HOST_WIDE_INT)prec)\n+    {\n+      *hv = signmask;\n+      *lv = signmask;\n+    }\n+  else if ((prec - count) >= 2 * HOST_BITS_PER_WIDE_INT)\n+    ;\n+  else if ((prec - count) >= HOST_BITS_PER_WIDE_INT)\n+    {\n+      *hv &= ~((HOST_WIDE_INT) (-1) << (prec - count - HOST_BITS_PER_WIDE_INT));\n+      *hv |= signmask << (prec - count - HOST_BITS_PER_WIDE_INT);\n+    }\n+  else\n+    {\n+      *hv = signmask;\n+      *lv &= ~((unsigned HOST_WIDE_INT) (-1) << (prec - count));\n+      *lv |= signmask << (prec - count);\n+    }\n+}\n+\n+/* Rotate the doubleword integer in L1, H1 left by COUNT places\n+   keeping only PREC bits of result.\n+   Rotate right if COUNT is negative.\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+void\n+lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\tHOST_WIDE_INT count, unsigned int prec,\n+\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+{\n+  unsigned HOST_WIDE_INT s1l, s2l;\n+  HOST_WIDE_INT s1h, s2h;\n+\n+  count %= prec;\n+  if (count < 0)\n+    count += prec;\n+\n+  lshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n+  rshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n+  *lv = s1l | s2l;\n+  *hv = s1h | s2h;\n+}\n+\n+/* Rotate the doubleword integer in L1, H1 left by COUNT places\n+   keeping only PREC bits of result.  COUNT must be positive.\n+   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n+\n+void\n+rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n+\t\tHOST_WIDE_INT count, unsigned int prec,\n+\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n+{\n+  unsigned HOST_WIDE_INT s1l, s2l;\n+  HOST_WIDE_INT s1h, s2h;\n+\n+  count %= prec;\n+  if (count < 0)\n+    count += prec;\n+\n+  rshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n+  lshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n+  *lv = s1l | s2l;\n+  *hv = s1h | s2h;\n+}\n+\n+/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN\n+   for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).\n+   CODE is a tree code for a kind of division, one of\n+   TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR\n+   or EXACT_DIV_EXPR\n+   It controls how the quotient is rounded to an integer.\n+   Return nonzero if the operation overflows.\n+   UNS nonzero says do unsigned division.  */\n+\n+int\n+div_and_round_double (unsigned code, int uns,\n+\t\t      /* num == numerator == dividend */\n+\t\t      unsigned HOST_WIDE_INT lnum_orig,\n+\t\t      HOST_WIDE_INT hnum_orig,\n+\t\t      /* den == denominator == divisor */\n+\t\t      unsigned HOST_WIDE_INT lden_orig,\n+\t\t      HOST_WIDE_INT hden_orig,\n+\t\t      unsigned HOST_WIDE_INT *lquo,\n+\t\t      HOST_WIDE_INT *hquo, unsigned HOST_WIDE_INT *lrem,\n+\t\t      HOST_WIDE_INT *hrem)\n+{\n+  int quo_neg = 0;\n+  HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n+  HOST_WIDE_INT den[4], quo[4];\n+  int i, j;\n+  unsigned HOST_WIDE_INT work;\n+  unsigned HOST_WIDE_INT carry = 0;\n+  unsigned HOST_WIDE_INT lnum = lnum_orig;\n+  HOST_WIDE_INT hnum = hnum_orig;\n+  unsigned HOST_WIDE_INT lden = lden_orig;\n+  HOST_WIDE_INT hden = hden_orig;\n+  int overflow = 0;\n+\n+  if (hden == 0 && lden == 0)\n+    overflow = 1, lden = 1;\n+\n+  /* Calculate quotient sign and convert operands to unsigned.  */\n+  if (!uns)\n+    {\n+      if (hnum < 0)\n+\t{\n+\t  quo_neg = ~ quo_neg;\n+\t  /* (minimum integer) / (-1) is the only overflow case.  */\n+\t  if (neg_double (lnum, hnum, &lnum, &hnum)\n+\t      && ((HOST_WIDE_INT) lden & hden) == -1)\n+\t    overflow = 1;\n+\t}\n+      if (hden < 0)\n+\t{\n+\t  quo_neg = ~ quo_neg;\n+\t  neg_double (lden, hden, &lden, &hden);\n+\t}\n+    }\n+\n+  if (hnum == 0 && hden == 0)\n+    {\t\t\t\t/* single precision */\n+      *hquo = *hrem = 0;\n+      /* This unsigned division rounds toward zero.  */\n+      *lquo = lnum / lden;\n+      goto finish_up;\n+    }\n+\n+  if (hnum == 0)\n+    {\t\t\t\t/* trivial case: dividend < divisor */\n+      /* hden != 0 already checked.  */\n+      *hquo = *lquo = 0;\n+      *hrem = hnum;\n+      *lrem = lnum;\n+      goto finish_up;\n+    }\n+\n+  memset (quo, 0, sizeof quo);\n+\n+  memset (num, 0, sizeof num);\t/* to zero 9th element */\n+  memset (den, 0, sizeof den);\n+\n+  encode (num, lnum, hnum);\n+  encode (den, lden, hden);\n+\n+  /* Special code for when the divisor < BASE.  */\n+  if (hden == 0 && lden < (unsigned HOST_WIDE_INT) BASE)\n+    {\n+      /* hnum != 0 already checked.  */\n+      for (i = 4 - 1; i >= 0; i--)\n+\t{\n+\t  work = num[i] + carry * BASE;\n+\t  quo[i] = work / lden;\n+\t  carry = work % lden;\n+\t}\n+    }\n+  else\n+    {\n+      /* Full double precision division,\n+\t with thanks to Don Knuth's \"Seminumerical Algorithms\".  */\n+      int num_hi_sig, den_hi_sig;\n+      unsigned HOST_WIDE_INT quo_est, scale;\n+\n+      /* Find the highest nonzero divisor digit.  */\n+      for (i = 4 - 1;; i--)\n+\tif (den[i] != 0)\n+\t  {\n+\t    den_hi_sig = i;\n+\t    break;\n+\t  }\n+\n+      /* Insure that the first digit of the divisor is at least BASE/2.\n+\t This is required by the quotient digit estimation algorithm.  */\n+\n+      scale = BASE / (den[den_hi_sig] + 1);\n+      if (scale > 1)\n+\t{\t\t/* scale divisor and dividend */\n+\t  carry = 0;\n+\t  for (i = 0; i <= 4 - 1; i++)\n+\t    {\n+\t      work = (num[i] * scale) + carry;\n+\t      num[i] = LOWPART (work);\n+\t      carry = HIGHPART (work);\n+\t    }\n+\n+\t  num[4] = carry;\n+\t  carry = 0;\n+\t  for (i = 0; i <= 4 - 1; i++)\n+\t    {\n+\t      work = (den[i] * scale) + carry;\n+\t      den[i] = LOWPART (work);\n+\t      carry = HIGHPART (work);\n+\t      if (den[i] != 0) den_hi_sig = i;\n+\t    }\n+\t}\n+\n+      num_hi_sig = 4;\n+\n+      /* Main loop */\n+      for (i = num_hi_sig - den_hi_sig - 1; i >= 0; i--)\n+\t{\n+\t  /* Guess the next quotient digit, quo_est, by dividing the first\n+\t     two remaining dividend digits by the high order quotient digit.\n+\t     quo_est is never low and is at most 2 high.  */\n+\t  unsigned HOST_WIDE_INT tmp;\n+\n+\t  num_hi_sig = i + den_hi_sig + 1;\n+\t  work = num[num_hi_sig] * BASE + num[num_hi_sig - 1];\n+\t  if (num[num_hi_sig] != den[den_hi_sig])\n+\t    quo_est = work / den[den_hi_sig];\n+\t  else\n+\t    quo_est = BASE - 1;\n+\n+\t  /* Refine quo_est so it's usually correct, and at most one high.  */\n+\t  tmp = work - quo_est * den[den_hi_sig];\n+\t  if (tmp < BASE\n+\t      && (den[den_hi_sig - 1] * quo_est\n+\t\t  > (tmp * BASE + num[num_hi_sig - 2])))\n+\t    quo_est--;\n+\n+\t  /* Try QUO_EST as the quotient digit, by multiplying the\n+\t     divisor by QUO_EST and subtracting from the remaining dividend.\n+\t     Keep in mind that QUO_EST is the I - 1st digit.  */\n+\n+\t  carry = 0;\n+\t  for (j = 0; j <= den_hi_sig; j++)\n+\t    {\n+\t      work = quo_est * den[j] + carry;\n+\t      carry = HIGHPART (work);\n+\t      work = num[i + j] - LOWPART (work);\n+\t      num[i + j] = LOWPART (work);\n+\t      carry += HIGHPART (work) != 0;\n+\t    }\n+\n+\t  /* If quo_est was high by one, then num[i] went negative and\n+\t     we need to correct things.  */\n+\t  if (num[num_hi_sig] < (HOST_WIDE_INT) carry)\n+\t    {\n+\t      quo_est--;\n+\t      carry = 0;\t\t/* add divisor back in */\n+\t      for (j = 0; j <= den_hi_sig; j++)\n+\t\t{\n+\t\t  work = num[i + j] + den[j] + carry;\n+\t\t  carry = HIGHPART (work);\n+\t\t  num[i + j] = LOWPART (work);\n+\t\t}\n+\n+\t      num [num_hi_sig] += carry;\n+\t    }\n+\n+\t  /* Store the quotient digit.  */\n+\t  quo[i] = quo_est;\n+\t}\n+    }\n+\n+  decode (quo, lquo, hquo);\n+\n+ finish_up:\n+  /* If result is negative, make it so.  */\n+  if (quo_neg)\n+    neg_double (*lquo, *hquo, lquo, hquo);\n+\n+  /* Compute trial remainder:  rem = num - (quo * den)  */\n+  mul_double (*lquo, *hquo, lden_orig, hden_orig, lrem, hrem);\n+  neg_double (*lrem, *hrem, lrem, hrem);\n+  add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n+\n+  switch (code)\n+    {\n+    case TRUNC_DIV_EXPR:\n+    case TRUNC_MOD_EXPR:\t/* round toward zero */\n+    case EXACT_DIV_EXPR:\t/* for this one, it shouldn't matter */\n+      return overflow;\n+\n+    case FLOOR_DIV_EXPR:\n+    case FLOOR_MOD_EXPR:\t/* round toward negative infinity */\n+      if (quo_neg && (*lrem != 0 || *hrem != 0))   /* ratio < 0 && rem != 0 */\n+\t{\n+\t  /* quo = quo - 1;  */\n+\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n+\t\t      lquo, hquo);\n+\t}\n+      else\n+\treturn overflow;\n+      break;\n+\n+    case CEIL_DIV_EXPR:\n+    case CEIL_MOD_EXPR:\t\t/* round toward positive infinity */\n+      if (!quo_neg && (*lrem != 0 || *hrem != 0))  /* ratio > 0 && rem != 0 */\n+\t{\n+\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t\t      lquo, hquo);\n+\t}\n+      else\n+\treturn overflow;\n+      break;\n+\n+    case ROUND_DIV_EXPR:\n+    case ROUND_MOD_EXPR:\t/* round to closest integer */\n+      {\n+\tunsigned HOST_WIDE_INT labs_rem = *lrem;\n+\tHOST_WIDE_INT habs_rem = *hrem;\n+\tunsigned HOST_WIDE_INT labs_den = lden, ltwice;\n+\tHOST_WIDE_INT habs_den = hden, htwice;\n+\n+\t/* Get absolute values.  */\n+\tif (*hrem < 0)\n+\t  neg_double (*lrem, *hrem, &labs_rem, &habs_rem);\n+\tif (hden < 0)\n+\t  neg_double (lden, hden, &labs_den, &habs_den);\n+\n+\t/* If (2 * abs (lrem) >= abs (lden)), adjust the quotient.  */\n+\tmul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,\n+\t\t    labs_rem, habs_rem, &ltwice, &htwice);\n+\n+\tif (((unsigned HOST_WIDE_INT) habs_den\n+\t     < (unsigned HOST_WIDE_INT) htwice)\n+\t    || (((unsigned HOST_WIDE_INT) habs_den\n+\t\t == (unsigned HOST_WIDE_INT) htwice)\n+\t\t&& (labs_den <= ltwice)))\n+\t  {\n+\t    if (*hquo < 0)\n+\t      /* quo = quo - 1;  */\n+\t      add_double (*lquo, *hquo,\n+\t\t\t  (HOST_WIDE_INT) -1, (HOST_WIDE_INT) -1, lquo, hquo);\n+\t    else\n+\t      /* quo = quo + 1; */\n+\t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n+\t\t\t  lquo, hquo);\n+\t  }\n+\telse\n+\t  return overflow;\n+      }\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Compute true remainder:  rem = num - (quo * den)  */\n+  mul_double (*lquo, *hquo, lden_orig, hden_orig, lrem, hrem);\n+  neg_double (*lrem, *hrem, lrem, hrem);\n+  add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n+  return overflow;\n+}\n+\n+\n /* Returns mask for PREC bits.  */\n \n double_int\n@@ -211,7 +946,7 @@ double_int_divmod (double_int a, double_int b, bool uns, unsigned code,\n {\n   double_int ret;\n \n-  div_and_round_double ((enum tree_code) code, uns, a.low, a.high,\n+  div_and_round_double (code, uns, a.low, a.high,\n \t\t\tb.low, b.high, &ret.low, &ret.high,\n \t\t\t&mod->low, &mod->high);\n   return ret;"}, {"sha": "64ac843da1a30a7015403333455bebcdefc58e00", "filename": "gcc/double-int.h", "status": "modified", "additions": 44, "deletions": 5, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Fdouble-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Fdouble-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdouble-int.h?ref=330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "patch": "@@ -59,13 +59,11 @@ typedef struct\n \n #define HOST_BITS_PER_DOUBLE_INT (2 * HOST_BITS_PER_WIDE_INT)\n \n-union tree_node;\n-\n /* Constructors and conversions.  */\n \n-union tree_node *double_int_to_tree (union tree_node *, double_int);\n-bool double_int_fits_to_tree_p (const union tree_node *, double_int);\n-double_int tree_to_double_int (const union tree_node *);\n+tree double_int_to_tree (tree, double_int);\n+bool double_int_fits_to_tree_p (const_tree, double_int);\n+double_int tree_to_double_int (const_tree);\n \n /* Constructs double_int from integer CST.  The bits over the precision of\n    HOST_WIDE_INT are filled with the sign bit.  */\n@@ -202,6 +200,47 @@ double_int_equal_p (double_int cst1, double_int cst2)\n   return cst1.low == cst2.low && cst1.high == cst2.high;\n }\n \n+\n+/* Legacy interface with decomposed high/low parts.  */\n+\n+extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t   int, bool);\n+extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t    const_tree);\n+extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+#define add_double(l1,h1,l2,h2,lv,hv) \\\n+  add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n+\t\t\t\t bool);\n+#define mul_double(l1,h1,l2,h2,lv,hv) \\\n+  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n+extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, unsigned int,\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n+extern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t   HOST_WIDE_INT, unsigned int,\n+\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n+extern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t    HOST_WIDE_INT, unsigned int,\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern void rrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n+\t\t\t    HOST_WIDE_INT, unsigned int,\n+\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+extern int div_and_round_double (unsigned, int, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n+\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n+\t\t\t\t HOST_WIDE_INT *);\n+\n+\n #ifndef GENERATOR_FILE\n /* Conversion to and from GMP integer representations.  */\n "}, {"sha": "c1af8248a395f55c1d51a914681dbfada7ec3a21", "filename": "gcc/fold-const.c", "status": "modified", "additions": 0, "deletions": 717, "changes": 717, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "patch": "@@ -93,8 +93,6 @@ enum comparison_code {\n   COMPCODE_TRUE = 15\n };\n \n-static void encode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n-static void decode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n static bool negate_mathfn_p (enum built_in_function);\n static bool negate_expr_p (tree);\n static tree negate_expr (tree);\n@@ -159,721 +157,6 @@ static tree fold_convert_const (enum tree_code, tree, tree);\n    sign.  */\n #define OVERFLOW_SUM_SIGN(a, b, sum) ((~((a) ^ (b)) & ((a) ^ (sum))) < 0)\n \f\n-/* To do constant folding on INTEGER_CST nodes requires two-word arithmetic.\n-   We do that by representing the two-word integer in 4 words, with only\n-   HOST_BITS_PER_WIDE_INT / 2 bits stored in each word, as a positive\n-   number.  The value of the word is LOWPART + HIGHPART * BASE.  */\n-\n-#define LOWPART(x) \\\n-  ((x) & (((unsigned HOST_WIDE_INT) 1 << (HOST_BITS_PER_WIDE_INT / 2)) - 1))\n-#define HIGHPART(x) \\\n-  ((unsigned HOST_WIDE_INT) (x) >> HOST_BITS_PER_WIDE_INT / 2)\n-#define BASE ((unsigned HOST_WIDE_INT) 1 << HOST_BITS_PER_WIDE_INT / 2)\n-\n-/* Unpack a two-word integer into 4 words.\n-   LOW and HI are the integer, as two `HOST_WIDE_INT' pieces.\n-   WORDS points to the array of HOST_WIDE_INTs.  */\n-\n-static void\n-encode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT low, HOST_WIDE_INT hi)\n-{\n-  words[0] = LOWPART (low);\n-  words[1] = HIGHPART (low);\n-  words[2] = LOWPART (hi);\n-  words[3] = HIGHPART (hi);\n-}\n-\n-/* Pack an array of 4 words into a two-word integer.\n-   WORDS points to the array of words.\n-   The integer is stored into *LOW and *HI as two `HOST_WIDE_INT' pieces.  */\n-\n-static void\n-decode (HOST_WIDE_INT *words, unsigned HOST_WIDE_INT *low,\n-\tHOST_WIDE_INT *hi)\n-{\n-  *low = words[0] + words[1] * BASE;\n-  *hi = words[2] + words[3] * BASE;\n-}\n-\f\n-/* Force the double-word integer L1, H1 to be within the range of the\n-   integer type TYPE.  Stores the properly truncated and sign-extended\n-   double-word integer in *LV, *HV.  Returns true if the operation\n-   overflows, that is, argument and result are different.  */\n-\n-int\n-fit_double_type (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, const_tree type)\n-{\n-  unsigned HOST_WIDE_INT low0 = l1;\n-  HOST_WIDE_INT high0 = h1;\n-  unsigned int prec = TYPE_PRECISION (type);\n-  int sign_extended_type;\n-\n-  /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t    && TYPE_IS_SIZETYPE (type)));\n-\n-  /* First clear all bits that are beyond the type's precision.  */\n-  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n-    ;\n-  else if (prec > HOST_BITS_PER_WIDE_INT)\n-    h1 &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-  else\n-    {\n-      h1 = 0;\n-      if (prec < HOST_BITS_PER_WIDE_INT)\n-\tl1 &= ~((HOST_WIDE_INT) (-1) << prec);\n-    }\n-\n-  /* Then do sign extension if necessary.  */\n-  if (!sign_extended_type)\n-    /* No sign extension */;\n-  else if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n-    /* Correct width already.  */;\n-  else if (prec > HOST_BITS_PER_WIDE_INT)\n-    {\n-      /* Sign extend top half? */\n-      if (h1 & ((unsigned HOST_WIDE_INT)1\n-\t\t<< (prec - HOST_BITS_PER_WIDE_INT - 1)))\n-\th1 |= (HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT);\n-    }\n-  else if (prec == HOST_BITS_PER_WIDE_INT)\n-    {\n-      if ((HOST_WIDE_INT)l1 < 0)\n-\th1 = -1;\n-    }\n-  else\n-    {\n-      /* Sign extend bottom half? */\n-      if (l1 & ((unsigned HOST_WIDE_INT)1 << (prec - 1)))\n-\t{\n-\t  h1 = -1;\n-\t  l1 |= (HOST_WIDE_INT)(-1) << prec;\n-\t}\n-    }\n-\n-  *lv = l1;\n-  *hv = h1;\n-\n-  /* If the value didn't fit, signal overflow.  */\n-  return l1 != low0 || h1 != high0;\n-}\n-\n-/* We force the double-int HIGH:LOW to the range of the type TYPE by\n-   sign or zero extending it.\n-   OVERFLOWABLE indicates if we are interested\n-   in overflow of the value, when >0 we are only interested in signed\n-   overflow, for <0 we are interested in any overflow.  OVERFLOWED\n-   indicates whether overflow has already occurred.  CONST_OVERFLOWED\n-   indicates whether constant overflow has already occurred.  We force\n-   T's value to be within range of T's type (by setting to 0 or 1 all\n-   the bits outside the type's range).  We set TREE_OVERFLOWED if,\n-  \tOVERFLOWED is nonzero,\n-\tor OVERFLOWABLE is >0 and signed overflow occurs\n-\tor OVERFLOWABLE is <0 and any overflow occurs\n-   We return a new tree node for the extended double-int.  The node\n-   is shared if no overflow flags are set.  */\n-\n-tree\n-force_fit_type_double (tree type, unsigned HOST_WIDE_INT low,\n-\t\t       HOST_WIDE_INT high, int overflowable,\n-\t\t       bool overflowed)\n-{\n-  int sign_extended_type;\n-  bool overflow;\n-\n-  /* Size types *are* sign extended.  */\n-  sign_extended_type = (!TYPE_UNSIGNED (type)\n-\t\t\t|| (TREE_CODE (type) == INTEGER_TYPE\n-\t\t\t    && TYPE_IS_SIZETYPE (type)));\n-\n-  overflow = fit_double_type (low, high, &low, &high, type);\n-\n-  /* If we need to set overflow flags, return a new unshared node.  */\n-  if (overflowed || overflow)\n-    {\n-      if (overflowed\n-\t  || overflowable < 0\n-\t  || (overflowable > 0 && sign_extended_type))\n-\t{\n-          tree t = make_node (INTEGER_CST);\n-          TREE_INT_CST_LOW (t) = low;\n-          TREE_INT_CST_HIGH (t) = high;\n-          TREE_TYPE (t) = type;\n-\t  TREE_OVERFLOW (t) = 1;\n-\t  return t;\n-\t}\n-    }\n-\n-  /* Else build a shared node.  */\n-  return build_int_cst_wide (type, low, high);\n-}\n-\f\n-/* Add two doubleword integers with doubleword result.\n-   Return nonzero if the operation overflows according to UNSIGNED_P.\n-   Each argument is given as two `HOST_WIDE_INT' pieces.\n-   One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-int\n-add_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n-\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t\t      bool unsigned_p)\n-{\n-  unsigned HOST_WIDE_INT l;\n-  HOST_WIDE_INT h;\n-\n-  l = l1 + l2;\n-  h = (HOST_WIDE_INT) ((unsigned HOST_WIDE_INT) h1\n-\t\t       + (unsigned HOST_WIDE_INT) h2\n-\t\t       + (l < l1));\n-\n-  *lv = l;\n-  *hv = h;\n-\n-  if (unsigned_p)\n-    return ((unsigned HOST_WIDE_INT) h < (unsigned HOST_WIDE_INT) h1\n-\t    || (h == h1\n-\t\t&& l < l1));\n-  else\n-    return OVERFLOW_SUM_SIGN (h1, h2, h);\n-}\n-\n-/* Negate a doubleword integer with doubleword result.\n-   Return nonzero if the operation overflows, assuming it's signed.\n-   The argument is given as two `HOST_WIDE_INT' pieces in L1 and H1.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-int\n-neg_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t    unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n-{\n-  if (l1 == 0)\n-    {\n-      *lv = 0;\n-      *hv = - h1;\n-      return (*hv & h1) < 0;\n-    }\n-  else\n-    {\n-      *lv = -l1;\n-      *hv = ~h1;\n-      return 0;\n-    }\n-}\n-\f\n-/* Multiply two doubleword integers with doubleword result.\n-   Return nonzero if the operation overflows according to UNSIGNED_P.\n-   Each argument is given as two `HOST_WIDE_INT' pieces.\n-   One argument is L1 and H1; the other, L2 and H2.\n-   The value is stored as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-int\n-mul_double_with_sign (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\t      unsigned HOST_WIDE_INT l2, HOST_WIDE_INT h2,\n-\t\t      unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t\t      bool unsigned_p)\n-{\n-  HOST_WIDE_INT arg1[4];\n-  HOST_WIDE_INT arg2[4];\n-  HOST_WIDE_INT prod[4 * 2];\n-  unsigned HOST_WIDE_INT carry;\n-  int i, j, k;\n-  unsigned HOST_WIDE_INT toplow, neglow;\n-  HOST_WIDE_INT tophigh, neghigh;\n-\n-  encode (arg1, l1, h1);\n-  encode (arg2, l2, h2);\n-\n-  memset (prod, 0, sizeof prod);\n-\n-  for (i = 0; i < 4; i++)\n-    {\n-      carry = 0;\n-      for (j = 0; j < 4; j++)\n-\t{\n-\t  k = i + j;\n-\t  /* This product is <= 0xFFFE0001, the sum <= 0xFFFF0000.  */\n-\t  carry += arg1[i] * arg2[j];\n-\t  /* Since prod[p] < 0xFFFF, this sum <= 0xFFFFFFFF.  */\n-\t  carry += prod[k];\n-\t  prod[k] = LOWPART (carry);\n-\t  carry = HIGHPART (carry);\n-\t}\n-      prod[i + 4] = carry;\n-    }\n-\n-  decode (prod, lv, hv);\n-  decode (prod + 4, &toplow, &tophigh);\n-\n-  /* Unsigned overflow is immediate.  */\n-  if (unsigned_p)\n-    return (toplow | tophigh) != 0;\n-\n-  /* Check for signed overflow by calculating the signed representation of the\n-     top half of the result; it should agree with the low half's sign bit.  */\n-  if (h1 < 0)\n-    {\n-      neg_double (l2, h2, &neglow, &neghigh);\n-      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n-    }\n-  if (h2 < 0)\n-    {\n-      neg_double (l1, h1, &neglow, &neghigh);\n-      add_double (neglow, neghigh, toplow, tophigh, &toplow, &tophigh);\n-    }\n-  return (*hv < 0 ? ~(toplow & tophigh) : toplow | tophigh) != 0;\n-}\n-\f\n-/* Shift the doubleword integer in L1, H1 left by COUNT places\n-   keeping only PREC bits of result.\n-   Shift right if COUNT is negative.\n-   ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-lshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t       HOST_WIDE_INT count, unsigned int prec,\n-\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv, bool arith)\n-{\n-  unsigned HOST_WIDE_INT signmask;\n-\n-  if (count < 0)\n-    {\n-      rshift_double (l1, h1, -count, prec, lv, hv, arith);\n-      return;\n-    }\n-\n-  if (SHIFT_COUNT_TRUNCATED)\n-    count %= prec;\n-\n-  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n-    {\n-      /* Shifting by the host word size is undefined according to the\n-\t ANSI standard, so we must handle this as a special case.  */\n-      *hv = 0;\n-      *lv = 0;\n-    }\n-  else if (count >= HOST_BITS_PER_WIDE_INT)\n-    {\n-      *hv = l1 << (count - HOST_BITS_PER_WIDE_INT);\n-      *lv = 0;\n-    }\n-  else\n-    {\n-      *hv = (((unsigned HOST_WIDE_INT) h1 << count)\n-\t     | (l1 >> (HOST_BITS_PER_WIDE_INT - count - 1) >> 1));\n-      *lv = l1 << count;\n-    }\n-\n-  /* Sign extend all bits that are beyond the precision.  */\n-\n-  signmask = -((prec > HOST_BITS_PER_WIDE_INT\n-\t\t? ((unsigned HOST_WIDE_INT) *hv\n-\t\t   >> (prec - HOST_BITS_PER_WIDE_INT - 1))\n-\t\t: (*lv >> (prec - 1))) & 1);\n-\n-  if (prec >= 2 * HOST_BITS_PER_WIDE_INT)\n-    ;\n-  else if (prec >= HOST_BITS_PER_WIDE_INT)\n-    {\n-      *hv &= ~((HOST_WIDE_INT) (-1) << (prec - HOST_BITS_PER_WIDE_INT));\n-      *hv |= signmask << (prec - HOST_BITS_PER_WIDE_INT);\n-    }\n-  else\n-    {\n-      *hv = signmask;\n-      *lv &= ~((unsigned HOST_WIDE_INT) (-1) << prec);\n-      *lv |= signmask << prec;\n-    }\n-}\n-\n-/* Shift the doubleword integer in L1, H1 right by COUNT places\n-   keeping only PREC bits of result.  Shift left if COUNT is negative.\n-   ARITH nonzero specifies arithmetic shifting; otherwise use logical shift.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-rshift_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t       HOST_WIDE_INT count, unsigned int prec,\n-\t       unsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv,\n-\t       bool arith)\n-{\n-  unsigned HOST_WIDE_INT signmask;\n-\n-  signmask = (arith\n-\t      ? -((unsigned HOST_WIDE_INT) h1 >> (HOST_BITS_PER_WIDE_INT - 1))\n-\t      : 0);\n-\n-  if (SHIFT_COUNT_TRUNCATED)\n-    count %= prec;\n-\n-  if (count >= 2 * HOST_BITS_PER_WIDE_INT)\n-    {\n-      /* Shifting by the host word size is undefined according to the\n-\t ANSI standard, so we must handle this as a special case.  */\n-      *hv = 0;\n-      *lv = 0;\n-    }\n-  else if (count >= HOST_BITS_PER_WIDE_INT)\n-    {\n-      *hv = 0;\n-      *lv = (unsigned HOST_WIDE_INT) h1 >> (count - HOST_BITS_PER_WIDE_INT);\n-    }\n-  else\n-    {\n-      *hv = (unsigned HOST_WIDE_INT) h1 >> count;\n-      *lv = ((l1 >> count)\n-\t     | ((unsigned HOST_WIDE_INT) h1 << (HOST_BITS_PER_WIDE_INT - count - 1) << 1));\n-    }\n-\n-  /* Zero / sign extend all bits that are beyond the precision.  */\n-\n-  if (count >= (HOST_WIDE_INT)prec)\n-    {\n-      *hv = signmask;\n-      *lv = signmask;\n-    }\n-  else if ((prec - count) >= 2 * HOST_BITS_PER_WIDE_INT)\n-    ;\n-  else if ((prec - count) >= HOST_BITS_PER_WIDE_INT)\n-    {\n-      *hv &= ~((HOST_WIDE_INT) (-1) << (prec - count - HOST_BITS_PER_WIDE_INT));\n-      *hv |= signmask << (prec - count - HOST_BITS_PER_WIDE_INT);\n-    }\n-  else\n-    {\n-      *hv = signmask;\n-      *lv &= ~((unsigned HOST_WIDE_INT) (-1) << (prec - count));\n-      *lv |= signmask << (prec - count);\n-    }\n-}\n-\f\n-/* Rotate the doubleword integer in L1, H1 left by COUNT places\n-   keeping only PREC bits of result.\n-   Rotate right if COUNT is negative.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-lrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\tHOST_WIDE_INT count, unsigned int prec,\n-\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n-{\n-  unsigned HOST_WIDE_INT s1l, s2l;\n-  HOST_WIDE_INT s1h, s2h;\n-\n-  count %= prec;\n-  if (count < 0)\n-    count += prec;\n-\n-  lshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n-  rshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n-  *lv = s1l | s2l;\n-  *hv = s1h | s2h;\n-}\n-\n-/* Rotate the doubleword integer in L1, H1 left by COUNT places\n-   keeping only PREC bits of result.  COUNT must be positive.\n-   Store the value as two `HOST_WIDE_INT' pieces in *LV and *HV.  */\n-\n-void\n-rrotate_double (unsigned HOST_WIDE_INT l1, HOST_WIDE_INT h1,\n-\t\tHOST_WIDE_INT count, unsigned int prec,\n-\t\tunsigned HOST_WIDE_INT *lv, HOST_WIDE_INT *hv)\n-{\n-  unsigned HOST_WIDE_INT s1l, s2l;\n-  HOST_WIDE_INT s1h, s2h;\n-\n-  count %= prec;\n-  if (count < 0)\n-    count += prec;\n-\n-  rshift_double (l1, h1, count, prec, &s1l, &s1h, 0);\n-  lshift_double (l1, h1, prec - count, prec, &s2l, &s2h, 0);\n-  *lv = s1l | s2l;\n-  *hv = s1h | s2h;\n-}\n-\f\n-/* Divide doubleword integer LNUM, HNUM by doubleword integer LDEN, HDEN\n-   for a quotient (stored in *LQUO, *HQUO) and remainder (in *LREM, *HREM).\n-   CODE is a tree code for a kind of division, one of\n-   TRUNC_DIV_EXPR, FLOOR_DIV_EXPR, CEIL_DIV_EXPR, ROUND_DIV_EXPR\n-   or EXACT_DIV_EXPR\n-   It controls how the quotient is rounded to an integer.\n-   Return nonzero if the operation overflows.\n-   UNS nonzero says do unsigned division.  */\n-\n-int\n-div_and_round_double (enum tree_code code, int uns,\n-\t\t      unsigned HOST_WIDE_INT lnum_orig, /* num == numerator == dividend */\n-\t\t      HOST_WIDE_INT hnum_orig,\n-\t\t      unsigned HOST_WIDE_INT lden_orig, /* den == denominator == divisor */\n-\t\t      HOST_WIDE_INT hden_orig,\n-\t\t      unsigned HOST_WIDE_INT *lquo,\n-\t\t      HOST_WIDE_INT *hquo, unsigned HOST_WIDE_INT *lrem,\n-\t\t      HOST_WIDE_INT *hrem)\n-{\n-  int quo_neg = 0;\n-  HOST_WIDE_INT num[4 + 1];\t/* extra element for scaling.  */\n-  HOST_WIDE_INT den[4], quo[4];\n-  int i, j;\n-  unsigned HOST_WIDE_INT work;\n-  unsigned HOST_WIDE_INT carry = 0;\n-  unsigned HOST_WIDE_INT lnum = lnum_orig;\n-  HOST_WIDE_INT hnum = hnum_orig;\n-  unsigned HOST_WIDE_INT lden = lden_orig;\n-  HOST_WIDE_INT hden = hden_orig;\n-  int overflow = 0;\n-\n-  if (hden == 0 && lden == 0)\n-    overflow = 1, lden = 1;\n-\n-  /* Calculate quotient sign and convert operands to unsigned.  */\n-  if (!uns)\n-    {\n-      if (hnum < 0)\n-\t{\n-\t  quo_neg = ~ quo_neg;\n-\t  /* (minimum integer) / (-1) is the only overflow case.  */\n-\t  if (neg_double (lnum, hnum, &lnum, &hnum)\n-\t      && ((HOST_WIDE_INT) lden & hden) == -1)\n-\t    overflow = 1;\n-\t}\n-      if (hden < 0)\n-\t{\n-\t  quo_neg = ~ quo_neg;\n-\t  neg_double (lden, hden, &lden, &hden);\n-\t}\n-    }\n-\n-  if (hnum == 0 && hden == 0)\n-    {\t\t\t\t/* single precision */\n-      *hquo = *hrem = 0;\n-      /* This unsigned division rounds toward zero.  */\n-      *lquo = lnum / lden;\n-      goto finish_up;\n-    }\n-\n-  if (hnum == 0)\n-    {\t\t\t\t/* trivial case: dividend < divisor */\n-      /* hden != 0 already checked.  */\n-      *hquo = *lquo = 0;\n-      *hrem = hnum;\n-      *lrem = lnum;\n-      goto finish_up;\n-    }\n-\n-  memset (quo, 0, sizeof quo);\n-\n-  memset (num, 0, sizeof num);\t/* to zero 9th element */\n-  memset (den, 0, sizeof den);\n-\n-  encode (num, lnum, hnum);\n-  encode (den, lden, hden);\n-\n-  /* Special code for when the divisor < BASE.  */\n-  if (hden == 0 && lden < (unsigned HOST_WIDE_INT) BASE)\n-    {\n-      /* hnum != 0 already checked.  */\n-      for (i = 4 - 1; i >= 0; i--)\n-\t{\n-\t  work = num[i] + carry * BASE;\n-\t  quo[i] = work / lden;\n-\t  carry = work % lden;\n-\t}\n-    }\n-  else\n-    {\n-      /* Full double precision division,\n-\t with thanks to Don Knuth's \"Seminumerical Algorithms\".  */\n-      int num_hi_sig, den_hi_sig;\n-      unsigned HOST_WIDE_INT quo_est, scale;\n-\n-      /* Find the highest nonzero divisor digit.  */\n-      for (i = 4 - 1;; i--)\n-\tif (den[i] != 0)\n-\t  {\n-\t    den_hi_sig = i;\n-\t    break;\n-\t  }\n-\n-      /* Insure that the first digit of the divisor is at least BASE/2.\n-\t This is required by the quotient digit estimation algorithm.  */\n-\n-      scale = BASE / (den[den_hi_sig] + 1);\n-      if (scale > 1)\n-\t{\t\t/* scale divisor and dividend */\n-\t  carry = 0;\n-\t  for (i = 0; i <= 4 - 1; i++)\n-\t    {\n-\t      work = (num[i] * scale) + carry;\n-\t      num[i] = LOWPART (work);\n-\t      carry = HIGHPART (work);\n-\t    }\n-\n-\t  num[4] = carry;\n-\t  carry = 0;\n-\t  for (i = 0; i <= 4 - 1; i++)\n-\t    {\n-\t      work = (den[i] * scale) + carry;\n-\t      den[i] = LOWPART (work);\n-\t      carry = HIGHPART (work);\n-\t      if (den[i] != 0) den_hi_sig = i;\n-\t    }\n-\t}\n-\n-      num_hi_sig = 4;\n-\n-      /* Main loop */\n-      for (i = num_hi_sig - den_hi_sig - 1; i >= 0; i--)\n-\t{\n-\t  /* Guess the next quotient digit, quo_est, by dividing the first\n-\t     two remaining dividend digits by the high order quotient digit.\n-\t     quo_est is never low and is at most 2 high.  */\n-\t  unsigned HOST_WIDE_INT tmp;\n-\n-\t  num_hi_sig = i + den_hi_sig + 1;\n-\t  work = num[num_hi_sig] * BASE + num[num_hi_sig - 1];\n-\t  if (num[num_hi_sig] != den[den_hi_sig])\n-\t    quo_est = work / den[den_hi_sig];\n-\t  else\n-\t    quo_est = BASE - 1;\n-\n-\t  /* Refine quo_est so it's usually correct, and at most one high.  */\n-\t  tmp = work - quo_est * den[den_hi_sig];\n-\t  if (tmp < BASE\n-\t      && (den[den_hi_sig - 1] * quo_est\n-\t\t  > (tmp * BASE + num[num_hi_sig - 2])))\n-\t    quo_est--;\n-\n-\t  /* Try QUO_EST as the quotient digit, by multiplying the\n-\t     divisor by QUO_EST and subtracting from the remaining dividend.\n-\t     Keep in mind that QUO_EST is the I - 1st digit.  */\n-\n-\t  carry = 0;\n-\t  for (j = 0; j <= den_hi_sig; j++)\n-\t    {\n-\t      work = quo_est * den[j] + carry;\n-\t      carry = HIGHPART (work);\n-\t      work = num[i + j] - LOWPART (work);\n-\t      num[i + j] = LOWPART (work);\n-\t      carry += HIGHPART (work) != 0;\n-\t    }\n-\n-\t  /* If quo_est was high by one, then num[i] went negative and\n-\t     we need to correct things.  */\n-\t  if (num[num_hi_sig] < (HOST_WIDE_INT) carry)\n-\t    {\n-\t      quo_est--;\n-\t      carry = 0;\t\t/* add divisor back in */\n-\t      for (j = 0; j <= den_hi_sig; j++)\n-\t\t{\n-\t\t  work = num[i + j] + den[j] + carry;\n-\t\t  carry = HIGHPART (work);\n-\t\t  num[i + j] = LOWPART (work);\n-\t\t}\n-\n-\t      num [num_hi_sig] += carry;\n-\t    }\n-\n-\t  /* Store the quotient digit.  */\n-\t  quo[i] = quo_est;\n-\t}\n-    }\n-\n-  decode (quo, lquo, hquo);\n-\n- finish_up:\n-  /* If result is negative, make it so.  */\n-  if (quo_neg)\n-    neg_double (*lquo, *hquo, lquo, hquo);\n-\n-  /* Compute trial remainder:  rem = num - (quo * den)  */\n-  mul_double (*lquo, *hquo, lden_orig, hden_orig, lrem, hrem);\n-  neg_double (*lrem, *hrem, lrem, hrem);\n-  add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n-\n-  switch (code)\n-    {\n-    case TRUNC_DIV_EXPR:\n-    case TRUNC_MOD_EXPR:\t/* round toward zero */\n-    case EXACT_DIV_EXPR:\t/* for this one, it shouldn't matter */\n-      return overflow;\n-\n-    case FLOOR_DIV_EXPR:\n-    case FLOOR_MOD_EXPR:\t/* round toward negative infinity */\n-      if (quo_neg && (*lrem != 0 || *hrem != 0))   /* ratio < 0 && rem != 0 */\n-\t{\n-\t  /* quo = quo - 1;  */\n-\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) -1, (HOST_WIDE_INT)  -1,\n-\t\t      lquo, hquo);\n-\t}\n-      else\n-\treturn overflow;\n-      break;\n-\n-    case CEIL_DIV_EXPR:\n-    case CEIL_MOD_EXPR:\t\t/* round toward positive infinity */\n-      if (!quo_neg && (*lrem != 0 || *hrem != 0))  /* ratio > 0 && rem != 0 */\n-\t{\n-\t  add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n-\t\t      lquo, hquo);\n-\t}\n-      else\n-\treturn overflow;\n-      break;\n-\n-    case ROUND_DIV_EXPR:\n-    case ROUND_MOD_EXPR:\t/* round to closest integer */\n-      {\n-\tunsigned HOST_WIDE_INT labs_rem = *lrem;\n-\tHOST_WIDE_INT habs_rem = *hrem;\n-\tunsigned HOST_WIDE_INT labs_den = lden, ltwice;\n-\tHOST_WIDE_INT habs_den = hden, htwice;\n-\n-\t/* Get absolute values.  */\n-\tif (*hrem < 0)\n-\t  neg_double (*lrem, *hrem, &labs_rem, &habs_rem);\n-\tif (hden < 0)\n-\t  neg_double (lden, hden, &labs_den, &habs_den);\n-\n-\t/* If (2 * abs (lrem) >= abs (lden)), adjust the quotient.  */\n-\tmul_double ((HOST_WIDE_INT) 2, (HOST_WIDE_INT) 0,\n-\t\t    labs_rem, habs_rem, &ltwice, &htwice);\n-\n-\tif (((unsigned HOST_WIDE_INT) habs_den\n-\t     < (unsigned HOST_WIDE_INT) htwice)\n-\t    || (((unsigned HOST_WIDE_INT) habs_den\n-\t\t == (unsigned HOST_WIDE_INT) htwice)\n-\t\t&& (labs_den <= ltwice)))\n-\t  {\n-\t    if (*hquo < 0)\n-\t      /* quo = quo - 1;  */\n-\t      add_double (*lquo, *hquo,\n-\t\t\t  (HOST_WIDE_INT) -1, (HOST_WIDE_INT) -1, lquo, hquo);\n-\t    else\n-\t      /* quo = quo + 1; */\n-\t      add_double (*lquo, *hquo, (HOST_WIDE_INT) 1, (HOST_WIDE_INT) 0,\n-\t\t\t  lquo, hquo);\n-\t  }\n-\telse\n-\t  return overflow;\n-      }\n-      break;\n-\n-    default:\n-      gcc_unreachable ();\n-    }\n-\n-  /* Compute true remainder:  rem = num - (quo * den)  */\n-  mul_double (*lquo, *hquo, lden_orig, hden_orig, lrem, hrem);\n-  neg_double (*lrem, *hrem, lrem, hrem);\n-  add_double (lnum_orig, hnum_orig, *lrem, *hrem, lrem, hrem);\n-  return overflow;\n-}\n-\n /* If ARG2 divides ARG1 with zero remainder, carries out the division\n    of type CODE and returns the quotient.\n    Otherwise returns NULL_TREE.  */"}, {"sha": "447451254f41a8163a9f3c4f69c3231e454a4317", "filename": "gcc/tree.h", "status": "modified", "additions": 0, "deletions": 38, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/330db1e301250f2b81a1dc79a8c07b2d9e7dfc29/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=330db1e301250f2b81a1dc79a8c07b2d9e7dfc29", "patch": "@@ -4820,44 +4820,6 @@ extern void fold_undefer_overflow_warnings (bool, const_gimple, int);\n extern void fold_undefer_and_ignore_overflow_warnings (void);\n extern bool fold_deferring_overflow_warnings_p (void);\n \n-extern tree force_fit_type_double (tree, unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t   int, bool);\n-\n-extern int fit_double_type (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, const_tree);\n-extern int add_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t bool);\n-#define add_double(l1,h1,l2,h2,lv,hv) \\\n-  add_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n-extern int neg_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t       unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-extern int mul_double_with_sign (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t\t unsigned HOST_WIDE_INT *, HOST_WIDE_INT *,\n-\t\t\t\t bool);\n-#define mul_double(l1,h1,l2,h2,lv,hv) \\\n-  mul_double_with_sign (l1, h1, l2, h2, lv, hv, false)\n-extern void lshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n-extern void rshift_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t   HOST_WIDE_INT, unsigned int,\n-\t\t\t   unsigned HOST_WIDE_INT *, HOST_WIDE_INT *, bool);\n-extern void lrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    HOST_WIDE_INT, unsigned int,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-extern void rrotate_double (unsigned HOST_WIDE_INT, HOST_WIDE_INT,\n-\t\t\t    HOST_WIDE_INT, unsigned int,\n-\t\t\t    unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n-\n-extern int div_and_round_double (enum tree_code, int, unsigned HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT,\n-\t\t\t\t HOST_WIDE_INT, unsigned HOST_WIDE_INT *,\n-\t\t\t\t HOST_WIDE_INT *, unsigned HOST_WIDE_INT *,\n-\t\t\t\t HOST_WIDE_INT *);\n-\n enum operand_equal_flag\n {\n   OEP_ONLY_CONST = 1,"}]}