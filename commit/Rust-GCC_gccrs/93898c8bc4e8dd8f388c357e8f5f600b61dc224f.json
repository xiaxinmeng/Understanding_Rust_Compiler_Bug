{"sha": "93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTM4OThjOGJjNGU4ZGQ4ZjM4OGMzNTdlOGY1ZjYwMGI2MWRjMjI0Zg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@redhat.com", "date": "2004-08-29T11:54:33Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2004-08-29T11:54:33Z"}, "message": "mips.md (divide_condition): New mode attribute.\n\n\t* config/mips/mips.md (divide_condition): New mode attribute.\n\t(div[sd]f3, *div[sd]f3): Use it.  Redefine using :SCALARF.\n\t(sqrt[sd]f3): Redefine using SCALARF.\n\t(*recip[sd]f3, *rsqrt<mode>[ab]): Likewise.  Name formerly unnamed\n\tpatterns.\n\nFrom-SVN: r86721", "tree": {"sha": "ad124a33f4089d603b26ec69ae9d38614b34e42f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ad124a33f4089d603b26ec69ae9d38614b34e42f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/93898c8bc4e8dd8f388c357e8f5f600b61dc224f/comments", "author": null, "committer": null, "parents": [{"sha": "aae0609ca919ce45f08b9c1f3fe836d743d562dd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aae0609ca919ce45f08b9c1f3fe836d743d562dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aae0609ca919ce45f08b9c1f3fe836d743d562dd"}], "stats": {"total": 255, "additions": 74, "deletions": 181}, "files": [{"sha": "bcfbc0b9dbdec0bc9354f23a5ec04ed0c6e43854", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93898c8bc4e8dd8f388c357e8f5f600b61dc224f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93898c8bc4e8dd8f388c357e8f5f600b61dc224f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "patch": "@@ -1,3 +1,11 @@\n+2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n+\n+\t* config/mips/mips.md (divide_condition): New mode attribute.\n+\t(div[sd]f3, *div[sd]f3): Use it.  Redefine using :SCALARF.\n+\t(sqrt[sd]f3): Redefine using SCALARF.\n+\t(*recip[sd]f3, *rsqrt<mode>[ab]): Likewise.  Name formerly unnamed\n+\tpatterns.\n+\n 2004-08-29  Richard Sandiford  <rsandifo@redhat.com>\n \n \t* config/mips/mips.md (ANYF, SCALARF): New mode macros."}, {"sha": "3e220d07d961c58ee9fcae08dec73a2792a69798", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 66, "deletions": 181, "changes": 247, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/93898c8bc4e8dd8f388c357e8f5f600b61dc224f/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/93898c8bc4e8dd8f388c357e8f5f600b61dc224f/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=93898c8bc4e8dd8f388c357e8f5f600b61dc224f", "patch": "@@ -399,6 +399,16 @@\n ;; floating-point mode.\n (define_mode_attr UNITMODE [(SF \"SF\") (DF \"DF\") (V2SF \"SF\")])\n \n+;; This attribute works around the early SB-1 rev2 core \"F2\" erratum:\n+;;\n+;; In certain cases, div.s and div.ps may have a rounding error\n+;; and/or wrong inexact flag.\n+;;\n+;; Therefore, we only allow div.s if not working around SB-1 rev2\n+;; errata or if a slight loss of precision is OK.\n+(define_mode_attr divide_condition\n+  [DF (SF \"!TARGET_FIX_SB1 || flag_unsafe_math_optimizations\")])\n+\n ;; This code macro allows all branch instructions to be generated from\n ;; a single define_expand template.\n (define_code_macro any_cond [unordered ordered unlt unge uneq ltgt unle ungt\n@@ -1705,18 +1715,18 @@\n ;;  ....................\n ;;\n \n-(define_expand \"divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\")\n-\t(div:DF (match_operand:DF 1 \"reg_or_1_operand\")\n-\t\t(match_operand:DF 2 \"register_operand\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\")\n+\t(div:SCALARF (match_operand:SCALARF 1 \"reg_or_1_operand\")\n+\t\t     (match_operand:SCALARF 2 \"register_operand\")))]\n+  \"<divide_condition>\"\n {\n-  if (const_1_operand (operands[1], DFmode))\n+  if (const_1_operand (operands[1], <MODE>mode))\n     if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n-      operands[1] = force_reg (DFmode, operands[1]);\n+      operands[1] = force_reg (<MODE>mode, operands[1]);\n })\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum:\n+;; These patterns work around the early SB-1 rev2 core \"F1\" erratum:\n ;;\n ;; If an mfc1 or dmfc1 happens to access the floating point register\n ;; file at the same time a long latency operation (div, sqrt, recip,\n@@ -1728,102 +1738,37 @@\n ;; The workaround is to insert an unconditional 'mov' from/to the\n ;; long latency op destination register.\n \n-(define_insn \"*divdf3\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"register_operand\" \"f\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n-{\n-  if (TARGET_FIX_SB1)\n-    return \"div.d\\t%0,%1,%2\\;mov.d\\t%0,%0\";\n-  else\n-    return \"div.d\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set (attr \"length\")\n-        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n-                      (const_int 8)\n-                      (const_int 4)))])\n-\n-\n-;; This pattern works around the early SB-1 rev2 core \"F2\" erratum:\n-;;\n-;; In certain cases, div.s and div.ps may have a rounding error\n-;; and/or wrong inexact flag.\n-;;\n-;; Therefore, we only allow div.s if not working around SB-1 rev2\n-;; errata, or if working around those errata and a slight loss of\n-;; precision is OK (i.e., flag_unsafe_math_optimizations is set).\n-(define_expand \"divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\")\n-\t(div:SF (match_operand:SF 1 \"reg_or_1_operand\")\n-\t\t(match_operand:SF 2 \"register_operand\")))]\n-  \"TARGET_HARD_FLOAT && (!TARGET_FIX_SB1 || flag_unsafe_math_optimizations)\"\n-{\n-  if (const_1_operand (operands[1], SFmode))\n-    if (!(ISA_HAS_FP4 && flag_unsafe_math_optimizations))\n-      operands[1] = force_reg (SFmode, operands[1]);\n-})\n-\n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-;;\n-;; This pattern works around the early SB-1 rev2 core \"F2\" erratum (see\n-;; \"divsf3\" comment for details).\n-(define_insn \"*divsf3\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"register_operand\" \"f\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && (!TARGET_FIX_SB1 || flag_unsafe_math_optimizations)\"\n-{\n-  if (TARGET_FIX_SB1)\n-    return \"div.s\\t%0,%1,%2\\;mov.s\\t%0,%0\";\n-  else\n-    return \"div.s\\t%0,%1,%2\";\n-}\n-  [(set_attr \"type\"\t\"fdiv\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set (attr \"length\")\n-        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n-                      (const_int 8)\n-                      (const_int 4)))])\n-\n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n-\t\t(match_operand:DF 2 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n+(define_insn \"*div<mode>3\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n+\t(div:SCALARF (match_operand:SCALARF 1 \"register_operand\" \"f\")\n+\t\t     (match_operand:SCALARF 2 \"register_operand\" \"f\")))]\n+  \"<divide_condition>\"\n {\n   if (TARGET_FIX_SB1)\n-    return \"recip.d\\t%0,%2\\;mov.d\\t%0,%0\";\n+    return \"div.<fmt>\\t%0,%1,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n-    return \"recip.d\\t%0,%2\";\n+    return \"div.<fmt>\\t%0,%1,%2\";\n }\n-  [(set_attr \"type\"\t\"frdiv\")\n-   (set_attr \"mode\"\t\"DF\")\n+  [(set_attr \"type\" \"fdiv\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n-\t\t(match_operand:SF 2 \"register_operand\" \"f\")))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n+(define_insn \"*recip<mode>3\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n+\t(div:SCALARF (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n+\t\t     (match_operand:SCALARF 2 \"register_operand\" \"f\")))]\n+  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n-    return \"recip.s\\t%0,%2\\;mov.s\\t%0,%0\";\n+    return \"recip.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n-    return \"recip.s\\t%0,%2\";\n+    return \"recip.<fmt>\\t%0,%2\";\n }\n-  [(set_attr \"type\"\t\"frdiv\")\n-   (set_attr \"mode\"\t\"SF\")\n+  [(set_attr \"type\" \"frdiv\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n@@ -1862,119 +1807,59 @@\n ;;\n ;;  ....................\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"sqrtdf2\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(sqrt:DF (match_operand:DF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && HAVE_SQRT_P() && TARGET_DOUBLE_FLOAT\"\n-{\n-  if (TARGET_FIX_SB1)\n-    return \"sqrt.d\\t%0,%1\\;mov.d\\t%0,%0\";\n-  else\n-    return \"sqrt.d\\t%0,%1\";\n-}\n-  [(set_attr \"type\"\t\"fsqrt\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set (attr \"length\")\n-        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n-                      (const_int 8)\n-                      (const_int 4)))])\n-\n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"sqrtsf2\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SF (match_operand:SF 1 \"register_operand\" \"f\")))]\n-  \"TARGET_HARD_FLOAT && HAVE_SQRT_P()\"\n-{\n-  if (TARGET_FIX_SB1)\n-    return \"sqrt.s\\t%0,%1\\;mov.s\\t%0,%0\";\n-  else\n-    return \"sqrt.s\\t%0,%1\";\n-}\n-  [(set_attr \"type\"\t\"fsqrt\")\n-   (set_attr \"mode\"\t\"SF\")\n-   (set (attr \"length\")\n-        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n-                      (const_int 8)\n-                      (const_int 4)))])\n-\n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n-\t\t(sqrt:DF (match_operand:DF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n-{\n-  if (TARGET_FIX_SB1)\n-    return \"rsqrt.d\\t%0,%2\\;mov.d\\t%0,%0\";\n-  else\n-    return \"rsqrt.d\\t%0,%2\";\n-}\n-  [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"DF\")\n-   (set (attr \"length\")\n-        (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n-                      (const_int 8)\n-                      (const_int 4)))])\n+;; These patterns work around the early SB-1 rev2 core \"F1\" erratum (see\n+;; \"*div[sd]f3\" comment for details).\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n-\t\t(sqrt:SF (match_operand:SF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n+(define_insn \"sqrt<mode>2\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SCALARF (match_operand:SCALARF 1 \"register_operand\" \"f\")))]\n+  \"HAVE_SQRT_P()\"\n {\n   if (TARGET_FIX_SB1)\n-    return \"rsqrt.s\\t%0,%2\\;mov.s\\t%0,%0\";\n+    return \"sqrt.<fmt>\\t%0,%1\\;mov.<fmt>\\t%0,%0\";\n   else\n-    return \"rsqrt.s\\t%0,%2\";\n+    return \"sqrt.<fmt>\\t%0,%1\";\n }\n-  [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"SF\")\n+  [(set_attr \"type\" \"fsqrt\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(sqrt:DF (div:DF (match_operand:DF 1 \"const_1_operand\" \"\")\n-\t\t\t (match_operand:DF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && flag_unsafe_math_optimizations\"\n+(define_insn \"*rsqrt<mode>a\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n+\t(div:SCALARF\n+\t (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n+\t (sqrt:SCALARF (match_operand:SCALARF 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n-    return \"rsqrt.d\\t%0,%2\\;mov.d\\t%0,%0\";\n+    return \"rsqrt.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n-    return \"rsqrt.d\\t%0,%2\";\n+    return \"rsqrt.<fmt>\\t%0,%2\";\n }\n-  [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"DF\")\n+  [(set_attr \"type\" \"frsqrt\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)\n                       (const_int 4)))])\n \n-;; This pattern works around the early SB-1 rev2 core \"F1\" erratum (see\n-;; \"divdf3\" comment for details).\n-(define_insn \"\"\n-  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n-\t(sqrt:SF (div:SF (match_operand:SF 1 \"const_1_operand\" \"\")\n-\t\t\t (match_operand:SF 2 \"register_operand\" \"f\"))))]\n-  \"ISA_HAS_FP4 && TARGET_HARD_FLOAT && flag_unsafe_math_optimizations\"\n+(define_insn \"*rsqrt<mode>b\"\n+  [(set (match_operand:SCALARF 0 \"register_operand\" \"=f\")\n+\t(sqrt:SCALARF\n+\t (div:SCALARF (match_operand:SCALARF 1 \"const_1_operand\" \"\")\n+\t\t      (match_operand:SCALARF 2 \"register_operand\" \"f\"))))]\n+  \"ISA_HAS_FP4 && flag_unsafe_math_optimizations\"\n {\n   if (TARGET_FIX_SB1)\n-    return \"rsqrt.s\\t%0,%2\\;mov.s\\t%0,%0\";\n+    return \"rsqrt.<fmt>\\t%0,%2\\;mov.<fmt>\\t%0,%0\";\n   else\n-    return \"rsqrt.s\\t%0,%2\";\n+    return \"rsqrt.<fmt>\\t%0,%2\";\n }\n-  [(set_attr \"type\"\t\"frsqrt\")\n-   (set_attr \"mode\"\t\"SF\")\n+  [(set_attr \"type\" \"frsqrt\")\n+   (set_attr \"mode\" \"<MODE>\")\n    (set (attr \"length\")\n         (if_then_else (ne (symbol_ref \"TARGET_FIX_SB1\") (const_int 0))\n                       (const_int 8)"}]}