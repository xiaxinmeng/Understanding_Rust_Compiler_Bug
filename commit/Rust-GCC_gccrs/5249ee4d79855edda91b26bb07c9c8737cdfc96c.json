{"sha": "5249ee4d79855edda91b26bb07c9c8737cdfc96c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTI0OWVlNGQ3OTg1NWVkZGE5MWIyNmJiMDdjOWM4NzM3Y2RmYzk2Yw==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2018-07-12T13:02:17Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-12T13:02:17Z"}, "message": "Implement SLP of internal functions\n\nSLP of calls was previously restricted to built-in functions.\nThis patch extends it to internal functions.\n\n2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n\ngcc/\n\t* internal-fn.h (vectorizable_internal_fn_p): New function.\n\t* tree-vect-slp.c (compatible_calls_p): Likewise.\n\t(vect_build_slp_tree_1): Remove nops argument.  Handle calls\n\tto internal functions.\n\t(vect_build_slp_tree_2): Update call to vect_build_slp_tree_1.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-cond-arith-6.c: New test.\n\t* gcc.target/aarch64/sve/cond_arith_4.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_4_run.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_5.c: Likewise.\n\t* gcc.target/aarch64/sve/cond_arith_5_run.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_14.c: Likewise.\n\t* gcc.target/aarch64/sve/slp_14_run.c: Likewise.\n\nFrom-SVN: r262590", "tree": {"sha": "79b0f24d85f96dc00b4f8858b92f7df81b7181bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/79b0f24d85f96dc00b4f8858b92f7df81b7181bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5249ee4d79855edda91b26bb07c9c8737cdfc96c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5249ee4d79855edda91b26bb07c9c8737cdfc96c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5249ee4d79855edda91b26bb07c9c8737cdfc96c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5249ee4d79855edda91b26bb07c9c8737cdfc96c/comments", "author": null, "committer": null, "parents": [{"sha": "2c58d42c3ed599b4c2976fc173eefd8e016ea216", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c58d42c3ed599b4c2976fc173eefd8e016ea216", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c58d42c3ed599b4c2976fc173eefd8e016ea216"}], "stats": {"total": 440, "additions": 430, "deletions": 10}, "files": [{"sha": "03cb0fa41909a8f4bb075e3596a6479ea7b8af01", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -1,3 +1,11 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* internal-fn.h (vectorizable_internal_fn_p): New function.\n+\t* tree-vect-slp.c (compatible_calls_p): Likewise.\n+\t(vect_build_slp_tree_1): Remove nops argument.  Handle calls\n+\tto internal functions.\n+\t(vect_build_slp_tree_2): Update call to vect_build_slp_tree_1.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* fold-const.h (inverse_conditions_p): Declare."}, {"sha": "5c5bda1b3b7b7561ca1ebee215d6910e820a7c7c", "filename": "gcc/internal-fn.h", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Finternal-fn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Finternal-fn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Finternal-fn.h?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -160,6 +160,17 @@ direct_internal_fn_p (internal_fn fn)\n   return direct_internal_fn_array[fn].type0 >= -1;\n }\n \n+/* Return true if FN is a direct internal function that can be vectorized by\n+   converting the return type and all argument types to vectors of the same\n+   number of elements.  E.g. we can vectorize an IFN_SQRT on floats as an\n+   IFN_SQRT on vectors of N floats.  */\n+\n+inline bool\n+vectorizable_internal_fn_p (internal_fn fn)\n+{\n+  return direct_internal_fn_array[fn].vectorizable;\n+}\n+\n /* Return optab information about internal function FN.  Only meaningful\n    if direct_internal_fn_p (FN).  */\n "}, {"sha": "1c1098519c6d485ffb16c41cebea5c21ce560aa7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -1,3 +1,13 @@\n+2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n+\n+\t* gcc.dg/vect/vect-cond-arith-6.c: New test.\n+\t* gcc.target/aarch64/sve/cond_arith_4.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_4_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_5.c: Likewise.\n+\t* gcc.target/aarch64/sve/cond_arith_5_run.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_14.c: Likewise.\n+\t* gcc.target/aarch64/sve/slp_14_run.c: Likewise.\n+\n 2018-07-12  Richard Sandiford  <richard.sandiford@linaro.org>\n \n \t* gcc.dg/vect/vect-cond-arith-4.c: New test."}, {"sha": "cc70b8a54c44fbc1d20aa9c2599b9a37d9fc135b", "filename": "gcc/testsuite/gcc.dg/vect/vect-cond-arith-6.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-cond-arith-6.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-additional-options \"-fdump-tree-optimized\" } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N (VECTOR_BITS * 11 / 64 + 4)\n+\n+#define add(A, B) ((A) + (B))\n+#define sub(A, B) ((A) - (B))\n+#define mul(A, B) ((A) * (B))\n+#define div(A, B) ((A) / (B))\n+\n+#define DEF(OP)\t\t\t\t\t\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\t\t\t\\\n+  f_##OP (double *restrict a, double *restrict b, double x)\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; i += 2)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ta[i] = b[i] < 100 ? OP (b[i], x) : b[i];\t\t\t\\\n+\ta[i + 1] = b[i + 1] < 70 ? OP (b[i + 1], x) : b[i + 1];\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST(OP)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    f_##OP (a, b, 10);\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tint bval = (i % 17) * 10;\t\t\t\t\\\n+\tint truev = OP (bval, 10);\t\t\t\t\\\n+\tif (a[i] != (bval < (i & 1 ? 70 : 100) ? truev : bval))\t\\\n+\t__builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define FOR_EACH_OP(T)\t\t\t\t\\\n+  T (add)\t\t\t\t\t\\\n+  T (sub)\t\t\t\t\t\\\n+  T (mul)\t\t\t\t\t\\\n+  T (div)\n+\n+FOR_EACH_OP (DEF)\n+\n+int\n+main (void)\n+{\n+  double a[N], b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = (i % 17) * 10;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  FOR_EACH_OP (TEST)\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-times {vectorizing stmts using SLP} 4 \"vect\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_ADD} 1 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_SUB} 1 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_MUL} 1 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-times { = \\.COND_RDIV} 1 \"optimized\" { target vect_double_cond_arith } } } */\n+/* { dg-final { scan-tree-dump-not {VEC_COND_EXPR} \"optimized\" { target vect_double_cond_arith } } } */"}, {"sha": "811ca61584fbe66c4feefc612d51291ef5dfabaf", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_4.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,62 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  test_##TYPE##_##NAME (TYPE *__restrict x,\t\t\t\t\\\n+\t\t\tTYPE *__restrict y,\t\t\t\t\\\n+\t\t\tTYPE z1, TYPE z2,\t\t\t\t\\\n+\t\t\tTYPE *__restrict pred, int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tx[i] = (pred[i] != 1 ? y[i] OP z1 : y[i]);\t\t\t\\\n+\tx[i + 1] = (pred[i + 1] != 1 ? y[i + 1] OP z2 : y[i + 1]);\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_INT_TYPE(TYPE) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_FP_TYPE(TYPE) \\\n+  TEST (TYPE, add, +) \\\n+  TEST (TYPE, sub, -) \\\n+  TEST (TYPE, mul, *) \\\n+  TEST (TYPE, div, /)\n+\n+#define TEST_ALL \\\n+  TEST_INT_TYPE (int32_t) \\\n+  TEST_INT_TYPE (uint32_t) \\\n+  TEST_INT_TYPE (int64_t) \\\n+  TEST_INT_TYPE (uint64_t) \\\n+  TEST_FP_TYPE (float) \\\n+  TEST_FP_TYPE (double)\n+\n+TEST_ALL\n+\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s, p[0-7]/m,} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d, p[0-7]/m,} 1 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z,} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7],} 6 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z,} 12 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7],} 6 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "153f0c3abd5cda42699d80aa6a9952a146ff3286", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_4_run.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_4_run.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,32 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"cond_arith_4.c\"\n+\n+#define N 98\n+\n+#undef TEST\n+#define TEST(TYPE, NAME, OP)\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE x[N], y[N], pred[N], z[2] = { 5, 7 };\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ty[i] = i * i;\t\t\t\t\t\t\\\n+\tpred[i] = i % 3;\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    test_##TYPE##_##NAME (x, y, z[0], z[1], pred, N);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE expected = i % 3 != 1 ? y[i] OP z[i & 1] : y[i];\t\\\n+\tif (x[i] != expected)\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL\n+  return 0;\n+}"}, {"sha": "8bc247e42ed2e239803e3144f4c2f1d590f85bef", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_5.c", "status": "added", "additions": 85, "deletions": 0, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,85 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize -fno-vect-cost-model\" } */\n+\n+#include <stdint.h>\n+\n+#define TEST(DATA_TYPE, OTHER_TYPE, NAME, OP)\t\t\t\t\\\n+  void __attribute__ ((noinline, noclone))\t\t\t\t\\\n+  test_##DATA_TYPE##_##OTHER_TYPE##_##NAME (DATA_TYPE *__restrict x,\t\\\n+\t\t\t\t\t    DATA_TYPE *__restrict y,\t\\\n+\t\t\t\t\t    DATA_TYPE z1, DATA_TYPE z2,\t\\\n+\t\t\t\t\t    DATA_TYPE *__restrict pred,\t\\\n+\t\t\t\t\t    OTHER_TYPE *__restrict foo,\t\\\n+\t\t\t\t\t    int n)\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < n; i += 2)\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tx[i] = (pred[i] != 1 ? y[i] OP z1 : y[i]);\t\t\t\\\n+\tx[i + 1] = (pred[i + 1] != 1 ? y[i + 1] OP z2 : y[i + 1]);\t\\\n+\tfoo[i] += 1;\t\t\t\t\t\t\t\\\n+\tfoo[i + 1] += 2;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+#define TEST_INT_TYPE(DATA_TYPE, OTHER_TYPE) \\\n+  TEST (DATA_TYPE, OTHER_TYPE, div, /)\n+\n+#define TEST_FP_TYPE(DATA_TYPE, OTHER_TYPE) \\\n+  TEST (DATA_TYPE, OTHER_TYPE, add, +) \\\n+  TEST (DATA_TYPE, OTHER_TYPE, sub, -) \\\n+  TEST (DATA_TYPE, OTHER_TYPE, mul, *) \\\n+  TEST (DATA_TYPE, OTHER_TYPE, div, /)\n+\n+#define TEST_ALL \\\n+  TEST_INT_TYPE (int32_t, int8_t) \\\n+  TEST_INT_TYPE (int32_t, int16_t) \\\n+  TEST_INT_TYPE (uint32_t, int8_t) \\\n+  TEST_INT_TYPE (uint32_t, int16_t) \\\n+  TEST_INT_TYPE (int64_t, int8_t) \\\n+  TEST_INT_TYPE (int64_t, int16_t) \\\n+  TEST_INT_TYPE (int64_t, int32_t) \\\n+  TEST_INT_TYPE (uint64_t, int8_t) \\\n+  TEST_INT_TYPE (uint64_t, int16_t) \\\n+  TEST_INT_TYPE (uint64_t, int32_t) \\\n+  TEST_FP_TYPE (float, int8_t) \\\n+  TEST_FP_TYPE (float, int16_t) \\\n+  TEST_FP_TYPE (double, int8_t) \\\n+  TEST_FP_TYPE (double, int16_t) \\\n+  TEST_FP_TYPE (double, int32_t)\n+\n+TEST_ALL\n+\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfadd\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfsub\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfmul\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s, p[0-7]/m,} 6 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d, p[0-7]/m,} 14 } } */\n+\n+/* The load XFAILs for fixed-length SVE account for extra loads from the\n+   constant pool.  */\n+/* { dg-final { scan-assembler-times {\\tld1b\\tz[0-9]+\\.b, p[0-7]/z,} 12 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1b\\tz[0-9]+\\.b, p[0-7],} 12 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1h\\tz[0-9]+\\.h, p[0-7]/z,} 12 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1h\\tz[0-9]+\\.h, p[0-7],} 12 } } */\n+\n+/* 72 for x operations, 6 for foo operations.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\tz[0-9]+\\.s, p[0-7]/z,} 78 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* 36 for x operations, 6 for foo operations.  */\n+/* { dg-final { scan-assembler-times {\\tst1w\\tz[0-9]+\\.s, p[0-7],} 42 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tld1d\\tz[0-9]+\\.d, p[0-7]/z,} 168 } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\tz[0-9]+\\.d, p[0-7],} 84 } } */\n+\n+/* { dg-final { scan-assembler-not {\\tsel\\t} } } */"}, {"sha": "118a23974dc64a13f61a7a13afd0cf9ef1773d08", "filename": "gcc/testsuite/gcc.target/aarch64/sve/cond_arith_5_run.c", "status": "added", "additions": 35, "deletions": 0, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fcond_arith_5_run.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,35 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"cond_arith_5.c\"\n+\n+#define N 98\n+\n+#undef TEST\n+#define TEST(DATA_TYPE, OTHER_TYPE, NAME, OP)\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\t\\\n+    DATA_TYPE x[N], y[N], pred[N], z[2] = { 5, 7 };\t\t\t\\\n+    OTHER_TYPE foo[N];\t\t\t\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\ty[i] = i * i;\t\t\t\t\t\t\t\\\n+\tpred[i] = i % 3;\t\t\t\t\t\t\\\n+\tfoo[i] = i * 5;\t\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+    test_##DATA_TYPE##_##OTHER_TYPE##_##NAME (x, y, z[0], z[1],\t\t\\\n+\t\t\t\t\t      pred, foo, N);\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\t\\\n+\tDATA_TYPE expected = i % 3 != 1 ? y[i] OP z[i & 1] : y[i];\t\\\n+\tif (x[i] != expected)\t\t\t\t\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL\n+  return 0;\n+}"}, {"sha": "2f9123c6fba232f9d4ec4b57566fa77df69c2da5", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_14.c", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,48 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include <stdint.h>\n+\n+#define VEC_PERM(TYPE)\t\t\t\t\t\t\\\n+void __attribute__ ((weak))\t\t\t\t\t\\\n+vec_slp_##TYPE (TYPE *restrict a, TYPE *restrict b, int n)\t\\\n+{\t\t\t\t\t\t\t\t\\\n+  for (int i = 0; i < n; ++i)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      TYPE a1 = a[i * 2];\t\t\t\t\t\\\n+      TYPE a2 = a[i * 2 + 1];\t\t\t\t\t\\\n+      TYPE b1 = b[i * 2];\t\t\t\t\t\\\n+      TYPE b2 = b[i * 2 + 1];\t\t\t\t\t\\\n+      a[i * 2] = b1 > 1 ? a1 / b1 : a1;\t\t\t\t\\\n+      a[i * 2 + 1] = b2 > 2 ? a2 / b2 : a2;\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+}\n+\n+#define TEST_ALL(T)\t\t\t\t\\\n+  T (int32_t)\t\t\t\t\t\\\n+  T (uint32_t)\t\t\t\t\t\\\n+  T (int64_t)\t\t\t\t\t\\\n+  T (uint64_t)\t\t\t\t\t\\\n+  T (float)\t\t\t\t\t\\\n+  T (double)\n+\n+TEST_ALL (VEC_PERM)\n+\n+/* The loop should be fully-masked.  The load XFAILs for fixed-length\n+   SVE account for extra loads from the constant pool.  */\n+/* { dg-final { scan-assembler-times {\\tld1w\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1w\\t} 3 } } */\n+/* { dg-final { scan-assembler-times {\\tld1d\\t} 6 { xfail { aarch64_sve && { ! vect_variable_length } } } } } */\n+/* { dg-final { scan-assembler-times {\\tst1d\\t} 3 } } */\n+/* { dg-final { scan-assembler-not {\\tldr} } } */\n+/* { dg-final { scan-assembler-not {\\tstr} } } */\n+\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.s} 6 } } */\n+/* { dg-final { scan-assembler-times {\\twhilelo\\tp[0-7]\\.d} 6 } } */\n+\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.s} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.s} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.s} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tsdiv\\tz[0-9]+\\.d} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tudiv\\tz[0-9]+\\.d} 1 } } */\n+/* { dg-final { scan-assembler-times {\\tfdiv\\tz[0-9]+\\.d} 1 } } */"}, {"sha": "112b8b8a96681d8e1182f0dbc323cf418fbbb6f3", "filename": "gcc/testsuite/gcc.target/aarch64/sve/slp_14_run.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14_run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14_run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fsve%2Fslp_14_run.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-do run { target aarch64_sve_hw } } */\n+/* { dg-options \"-O2 -ftree-vectorize\" } */\n+\n+#include \"slp_14.c\"\n+\n+#define N1 (103 * 2)\n+#define N2 (111 * 2)\n+\n+#define HARNESS(TYPE)\t\t\t\t\t\t\\\n+  {\t\t\t\t\t\t\t\t\\\n+    TYPE a[N2], b[N2];\t\t\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\ta[i] = i * 2 + i % 5;\t\t\t\t\t\\\n+\tb[i] = i % 11;\t\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+    vec_slp_##TYPE (a, b, N1 / 2);\t\t\t\t\\\n+    for (unsigned int i = 0; i < N2; ++i)\t\t\t\\\n+      {\t\t\t\t\t\t\t\t\\\n+\tTYPE orig_a = i * 2 + i % 5;\t\t\t\t\\\n+\tTYPE orig_b = i % 11;\t\t\t\t\t\\\n+\tTYPE expected_a = orig_a;\t\t\t\t\\\n+\tif (i < N1 && orig_b > (i & 1 ? 2 : 1))\t\t\t\\\n+\t  expected_a /= orig_b;\t\t\t\t\t\\\n+\tif (a[i] != expected_a || b[i] != orig_b)\t\t\\\n+\t  __builtin_abort ();\t\t\t\t\t\\\n+      }\t\t\t\t\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  TEST_ALL (HARNESS)\n+}"}, {"sha": "8dc5763015280acf8473a2651bb8180ff60c45cd", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 43, "deletions": 10, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5249ee4d79855edda91b26bb07c9c8737cdfc96c/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=5249ee4d79855edda91b26bb07c9c8737cdfc96c", "patch": "@@ -562,6 +562,41 @@ vect_get_and_check_slp_defs (vec_info *vinfo, unsigned char *swap,\n   return 0;\n }\n \n+/* Return true if call statements CALL1 and CALL2 are similar enough\n+   to be combined into the same SLP group.  */\n+\n+static bool\n+compatible_calls_p (gcall *call1, gcall *call2)\n+{\n+  unsigned int nargs = gimple_call_num_args (call1);\n+  if (nargs != gimple_call_num_args (call2))\n+    return false;\n+\n+  if (gimple_call_combined_fn (call1) != gimple_call_combined_fn (call2))\n+    return false;\n+\n+  if (gimple_call_internal_p (call1))\n+    {\n+      if (!types_compatible_p (TREE_TYPE (gimple_call_lhs (call1)),\n+\t\t\t       TREE_TYPE (gimple_call_lhs (call2))))\n+\treturn false;\n+      for (unsigned int i = 0; i < nargs; ++i)\n+\tif (!types_compatible_p (TREE_TYPE (gimple_call_arg (call1, i)),\n+\t\t\t\t TREE_TYPE (gimple_call_arg (call2, i))))\n+\t  return false;\n+    }\n+  else\n+    {\n+      if (!operand_equal_p (gimple_call_fn (call1),\n+\t\t\t    gimple_call_fn (call2), 0))\n+\treturn false;\n+\n+      if (gimple_call_fntype (call1) != gimple_call_fntype (call2))\n+\treturn false;\n+    }\n+  return true;\n+}\n+\n /* A subroutine of vect_build_slp_tree for checking VECTYPE, which is the\n    caller's attempt to find the vector type in STMT with the narrowest\n    element type.  Return true if VECTYPE is nonnull and if it is valid\n@@ -650,8 +685,8 @@ vect_two_operations_perm_ok_p (vec<gimple *> stmts, unsigned int group_size,\n static bool\n vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t\t       vec<gimple *> stmts, unsigned int group_size,\n-\t\t       unsigned nops, poly_uint64 *max_nunits,\n-\t\t       bool *matches, bool *two_operators)\n+\t\t       poly_uint64 *max_nunits, bool *matches,\n+\t\t       bool *two_operators)\n {\n   unsigned int i;\n   gimple *first_stmt = stmts[0], *stmt = stmts[0];\n@@ -727,7 +762,9 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n       if (gcall *call_stmt = dyn_cast <gcall *> (stmt))\n \t{\n \t  rhs_code = CALL_EXPR;\n-\t  if (gimple_call_internal_p (call_stmt)\n+\t  if ((gimple_call_internal_p (call_stmt)\n+\t       && (!vectorizable_internal_fn_p\n+\t\t   (gimple_call_internal_fn (call_stmt))))\n \t      || gimple_call_tail_p (call_stmt)\n \t      || gimple_call_noreturn_p (call_stmt)\n \t      || !gimple_call_nothrow_p (call_stmt)\n@@ -873,11 +910,8 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n \t  if (rhs_code == CALL_EXPR)\n \t    {\n \t      gimple *first_stmt = stmts[0];\n-\t      if (gimple_call_num_args (stmt) != nops\n-\t\t  || !operand_equal_p (gimple_call_fn (first_stmt),\n-\t\t\t\t       gimple_call_fn (stmt), 0)\n-\t\t  || gimple_call_fntype (first_stmt)\n-\t\t     != gimple_call_fntype (stmt))\n+\t      if (!compatible_calls_p (as_a <gcall *> (first_stmt),\n+\t\t\t\t       as_a <gcall *> (stmt)))\n \t\t{\n \t\t  if (dump_enabled_p ())\n \t\t    {\n@@ -1193,8 +1227,7 @@ vect_build_slp_tree_2 (vec_info *vinfo,\n \n   bool two_operators = false;\n   unsigned char *swap = XALLOCAVEC (unsigned char, group_size);\n-  if (!vect_build_slp_tree_1 (vinfo, swap,\n-\t\t\t      stmts, group_size, nops,\n+  if (!vect_build_slp_tree_1 (vinfo, swap, stmts, group_size,\n \t\t\t      &this_max_nunits, matches, &two_operators))\n     return NULL;\n "}]}