{"sha": "5092eb960c2df8071aa8d61114788265579ebeaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTA5MmViOTYwYzJkZjgwNzFhYThkNjExMTQ3ODgyNjU1NzllYmVhYQ==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-03-27T09:01:34Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-03-27T09:01:34Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-03-27  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * caf/libcaf.h: New - coarray communication library.\n        * caf/mpi.c: New.\n        * caf/single.c: New.\n\nFrom-SVN: r171570", "tree": {"sha": "cf54dd924454ebbfa0ca7cf4e63c9f60cc95aacd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf54dd924454ebbfa0ca7cf4e63c9f60cc95aacd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5092eb960c2df8071aa8d61114788265579ebeaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5092eb960c2df8071aa8d61114788265579ebeaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5092eb960c2df8071aa8d61114788265579ebeaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5092eb960c2df8071aa8d61114788265579ebeaa/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "69d523395b0da6fe5e9178cbe96e57356f32980b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69d523395b0da6fe5e9178cbe96e57356f32980b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69d523395b0da6fe5e9178cbe96e57356f32980b"}], "stats": {"total": 378, "additions": 378, "deletions": 0}, "files": [{"sha": "4557c7cdce96097ada8cd522c5eeb84c91ea9aa8", "filename": "libgfortran/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2FChangeLog?ref=5092eb960c2df8071aa8d61114788265579ebeaa", "patch": "@@ -1,3 +1,10 @@\n+2011-03-27  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* caf/libcaf.h: New - coarray communication library.\n+\t* caf/mpi.c: New.\n+\t* caf/single.c: New.\n+\n 2011-03-23  Jerry DeLisle  <jvdelisle@gcc.gnu.org>\n \n \tPR libgfortran/48030"}, {"sha": "8a66ef3deff1e35315497b043a2cd2928b256a5d", "filename": "libgfortran/caf/libcaf.h", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Flibcaf.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Flibcaf.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Flibcaf.h?ref=5092eb960c2df8071aa8d61114788265579ebeaa", "patch": "@@ -0,0 +1,53 @@\n+/* Common declarations for all of GNU Fortran libcaf implementations.\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran Coarray Runtime Library (libcaf).\n+\n+Libcaf is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+Libcaf is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef LIBCAF_H\n+#define LIBCAF_H\n+\n+#include <stdint.h>\n+#include <string.h>\n+\n+/* Definitions of the Fortran 2008 standard; need to kept in sync with\n+   ISO_FORTRAN_ENV, cf. libgfortran.h.  */\n+#define STAT_UNLOCKED\t\t0\n+#define STAT_LOCKED\t\t1\n+#define STAT_LOCKED_OTHER_IMAGE\t2\n+#define STAT_STOPPED_IMAGE \t3\n+\n+\n+void _gfortran_caf_init (int *, char ***, int *, int *);\n+void _gfortran_caf_finalize (void);\n+\n+int _gfortran_caf_sync_all (char *, int);\n+int _gfortran_caf_sync_images (int count, int images[], char *, int);\n+\n+void _gfortran_caf_critical (void);\n+void _gfortran_caf_end_critical (void);\n+\n+void _gfortran_caf_error_stop_str (const char *, int32_t) __attribute__ ((noreturn));\n+void _gfortran_caf_error_stop (int32_t) __attribute__ ((noreturn));\n+\n+#endif  /* LIBCAF_H  */"}, {"sha": "634e240bf19e314cbd0120326ce39c5335448d4a", "filename": "libgfortran/caf/mpi.c", "status": "added", "additions": 211, "deletions": 0, "changes": 211, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Fmpi.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Fmpi.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fmpi.c?ref=5092eb960c2df8071aa8d61114788265579ebeaa", "patch": "@@ -0,0 +1,211 @@\n+/* MPI implementation of GNU Fortran Coarray Library\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran Coarray Runtime Library (libcaf).\n+\n+Libcaf is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+Libcaf is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libcaf.h\"\n+#include <stdio.h>\n+#include <stdlib.h>\n+#include <mpi.h>\n+\n+/* Define GFC_CAF_CHECK to enable run-time checking.  */\n+/* #define GFC_CAF_CHECK  1  */\n+\n+\n+static void error_stop (int error) __attribute__ ((noreturn));\n+\n+/* Global variables.  */\n+static int caf_this_image;\n+static int caf_num_images;\n+static MPI_Win caf_world_window;\n+\n+\n+/* Initialize coarray program.  This routine assumes that no other\n+   MPI initialization happened before; otherwise MPI_Initialized\n+   had to be used.  As the MPI library might modify the command-line\n+   arguments, the routine should be called before the run-time\n+   libaray is initialized.  */\n+\n+void\n+_gfortran_caf_init (int *argc, char ***argv, int *this_image, int *num_images)\n+{\n+  int flag;\n+\n+  /* The following is only the case if one does not have a Fortran\n+     main program. */\n+  MPI_Initialized (&flag);\n+  if (!flag)\n+    MPI_Init (argc, argv);\n+\n+  MPI_Comm_rank (MPI_COMM_WORLD, &caf_this_image);\n+  *this_image = caf_this_image + 1;\n+  MPI_Comm_size (MPI_COMM_WORLD, &caf_num_images);\n+  *num_images = caf_num_images;\n+\n+  /* Obtain window for CRITICAL section locking.  */\n+  MPI_Win_create (NULL, 0, 1, MPI_INFO_NULL, MPI_COMM_WORLD,\n+\t\t  &caf_world_window);\n+}\n+\n+\n+/* Finalize coarray program. Note: This is only called before the\n+   program ends; thus the MPI_Initialized status of _gfortran_caf_init\n+   does not play a role.  */\n+\n+void\n+_gfortran_caf_finalize (void)\n+{\n+  MPI_Win_free (&caf_world_window);\n+  MPI_Finalize ();\n+}\n+\n+\n+/* SYNC ALL - the return value matches Fortran's STAT argument.  */\n+\n+int\n+_gfortran_caf_sync_all (char *errmsg, int errmsg_len)\n+{\n+  int ierr;\n+  ierr = MPI_Barrier (MPI_COMM_WORLD);\n+\n+  if (ierr && errmsg_len > 0)\n+    {\n+      const char msg[] = \"SYNC ALL failed\";\n+      int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t  : (int) sizeof (msg);\n+      memcpy (errmsg, msg, len);\n+      if (errmsg_len > len)\n+\tmemset (&errmsg[len], ' ', errmsg_len-len);\n+    }\n+\n+  /* TODO: Is ierr correct? When should STAT_STOPPED_IMAGE be used?  */\n+  return ierr;\n+}\n+\n+\n+/* SYNC IMAGES. Note: SYNC IMAGES(*) is passed as count == -1 while\n+   SYNC IMAGES([]) has count == 0. Note further that SYNC IMAGES(*)\n+   is not equivalent to SYNC ALL.  The return value matches Fortran's\n+   STAT argument.  */\n+int\n+_gfortran_caf_sync_images (int count, int images[], char *errmsg,\n+\t\t\t   int errmsg_len)\n+{\n+  int ierr;\n+\n+  if (count == 0 || (count == 1 && images[0] == caf_this_image))\n+    return 0;\n+\n+#ifdef GFC_CAF_CHECK\n+  {\n+    int i;\n+\n+    for (i = 0; i < count; i++)\n+      if (images[i] < 1 || images[i] > caf_num_images)\n+\t{\n+\t  fprintf (stderr, \"COARRAY ERROR: Invalid image index %d to SYNC \"\n+\t\t   \"IMAGES\", images[i]);\n+\t  error_stop (1);\n+\t}\n+  }\n+#endif\n+\n+  /* FIXME: SYNC IMAGES with a nontrivial argument cannot easily be\n+     mapped to MPI communicators. Thus, exist early with an error message.  */\n+  if (count > 0)\n+    {\n+      fprintf (stderr, \"COARRAY ERROR: SYNC IMAGES not yet implemented\");\n+      error_stop (1);\n+    }\n+\n+  /* Handle SYNC IMAGES(*).  */\n+  ierr = MPI_Barrier (MPI_COMM_WORLD);\n+\n+  if (ierr && errmsg_len > 0)\n+    {\n+      const char msg[] = \"SYNC IMAGES failed\";\n+      int len = ((int) sizeof (msg) > errmsg_len) ? errmsg_len\n+\t\t\t\t\t\t  : (int) sizeof (msg);\n+      memcpy (errmsg, msg, len);\n+      if (errmsg_len > len)\n+\tmemset (&errmsg[len], ' ', errmsg_len-len);\n+    }\n+\n+  /* TODO: Is ierr correct? When should STAT_STOPPED_IMAGE be used?  */\n+  return ierr;\n+}\n+\n+\n+/* CRITICAL BLOCK. */\n+\n+void\n+_gfortran_caf_critical (void)\n+{\n+  MPI_Win_lock (MPI_LOCK_SHARED, 0, 0, caf_world_window);\n+}\n+\n+\n+void\n+_gfortran_caf_end_critical (void)\n+{\n+  MPI_Win_unlock (0, caf_world_window);\n+}\n+\n+\n+/* ERROR STOP the other images.  */\n+\n+static void\n+error_stop (int error)\n+{\n+  /* FIXME: Shutdown the Fortran RTL to flush the buffer.  PR 43849.  */\n+  /* FIXME: Do some more effort than just MPI_ABORT.  */\n+  MPI_Abort (MPI_COMM_WORLD, error);\n+\n+  /* Should be unreachable, but to make sure also call exit.  */\n+  exit (error);\n+}\n+\n+\n+/* ERROR STOP function for string arguments.  */\n+\n+void\n+_gfortran_caf_error_stop_str (const char *string, int32_t len)\n+{\n+  fputs (\"ERROR STOP \", stderr);\n+  while (len--)\n+    fputc (*(string++), stderr);\n+  fputs (\"\\n\", stderr);\n+\n+  error_stop (1);\n+}\n+\n+\n+/* ERROR STOP function for numerical arguments.  */\n+\n+void\n+_gfortran_caf_error_stop (int32_t error)\n+{\n+  fprintf (stderr, \"ERROR STOP %d\\n\", error);\n+  error_stop (error);\n+}"}, {"sha": "7ee37b3a99de430ca8767ea41cd961153b4022f2", "filename": "libgfortran/caf/single.c", "status": "added", "additions": 107, "deletions": 0, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Fsingle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5092eb960c2df8071aa8d61114788265579ebeaa/libgfortran%2Fcaf%2Fsingle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgfortran%2Fcaf%2Fsingle.c?ref=5092eb960c2df8071aa8d61114788265579ebeaa", "patch": "@@ -0,0 +1,107 @@\n+/* Single-image implementation of GNU Fortran Coarray Library\n+   Copyright (C) 2011\n+   Free Software Foundation, Inc.\n+   Contributed by Tobias Burnus <burnus@net-b.de>\n+\n+This file is part of the GNU Fortran Coarray Runtime Library (libcaf).\n+\n+Libcaf is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+Libcaf is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+Under Section 7 of GPL version 3, you are granted additional\n+permissions described in the GCC Runtime Library Exception, version\n+3.1, as published by the Free Software Foundation.\n+\n+You should have received a copy of the GNU General Public License and\n+a copy of the GCC Runtime Library Exception along with this program;\n+see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"libcaf.h\"\n+#include <stdio.h>  /* For fputs and fprintf.  */\n+#include <stdlib.h> /* For exit.  */\n+\n+/* Define GFC_CAF_CHECK to enable run-time checking.  */\n+/* #define GFC_CAF_CHECK  1  */\n+\n+\n+/* Single-image implementation of the CAF library.\n+   Note: For performance reasons -fcoarry=single should be used\n+   rather than this library.  */\n+\n+void\n+_gfortran_caf_init (int *argc __attribute__ ((unused)),\n+\t\t    char ***argv __attribute__ ((unused)),\n+\t\t    int *this_image, int *num_images)\n+{\n+  *this_image = 1;\n+  *num_images = 1;\n+}\n+\n+void\n+_gfortran_caf_finalize (void)\n+{\n+}\n+\n+int\n+_gfortran_caf_sync_all (char *errmsg __attribute__ ((unused)),\n+\t\t\tint errmsg_len __attribute__ ((unused)))\n+{\n+  return 0;\n+}\n+\n+int\n+_gfortran_caf_sync_images (int count __attribute__ ((unused)),\n+\t\t\t   int images[] __attribute__ ((unused)),\n+\t\t\t   char *errmsg __attribute__ ((unused)),\n+\t\t\t   int errmsg_len __attribute__ ((unused)))\n+{\n+#ifdef GFC_CAF_CHECK\n+  int i;\n+\n+  for (i = 0; i < count; i++)\n+    if (images[i] != 1)\n+      {\n+\tfprintf (stderr, \"COARRAY ERROR: Invalid image index %d to SYNC \"\n+\t\t \"IMAGES\", images[i]);\n+\texit (1);\n+      }\n+#endif\n+\n+  return 0;\n+}\n+\n+void\n+_gfortran_caf_critical (void)\n+{\n+}\n+\n+void\n+_gfortran_caf_end_critical (void)\n+{\n+}\n+\n+void\n+_gfortran_caf_error_stop_str (const char *string, int32_t len)\n+{\n+  fputs (\"ERROR STOP \", stderr);\n+  while (len--)\n+    fputc (*(string++), stderr);\n+  fputs (\"\\n\", stderr);\n+\n+  exit (1);\n+}\n+\n+void\n+_gfortran_caf_error_stop (int32_t error)\n+{\n+  fprintf (stderr, \"ERROR STOP %d\\n\", error);\n+  exit (error);\n+}"}]}