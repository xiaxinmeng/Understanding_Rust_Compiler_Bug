{"sha": "4c254e68ed108c49daf413213136f6d025bce6ba", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMyNTRlNjhlZDEwOGM0OWRhZjQxMzIxMzEzNmY2ZDAyNWJjZTZiYQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2004-09-08T08:08:56Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2004-09-08T08:08:56Z"}, "message": "vec.c (vec_p_reserve, [...]): Rename to ...\n\n\t* vec.c (vec_p_reserve, vec_o_reserve): Rename to ...\n\t(vec_gc_p_reserve, vec_gc_o_reserve): ... here. Clone to\n\t(vec_heap_p_reserve, vec_heap_o_reserve): ... here, adjust.\n\t(vec_gc_free, vec_heap_free): New.\n\t* vec.h (DEF_VEC_GC_P, DEF_VEC_MALLOC_P): New.\n\t(DEF_VEC_P): Add allocator argument. Adjust.\n\t(DEF_VEC_GC_O, DEF_VEC_MALLOC_O): New.\n\t(DEF_VEC_O): Add allocator argument. Adjust.\n\t(VEC(free)): New.\n\n\t* tree.h (tree): Define a GC'd vector.\n\t* lamba-code.c (lambda_loop): Likewise.\n\t* value-prof.h (histogram_value): Likewise.\n\t* cp/cp-tree.h (tree_pair_s): Likewise.\n\t* cp/name-lookup.h (cxx_saved_binding, cp_class_binding): Likewise.\n\t* cp/semantics.c (deferred_access): Likewise.\n\nFrom-SVN: r87179", "tree": {"sha": "82cf8d02cbdec1663fdfa61ae2f02250a8f504bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/82cf8d02cbdec1663fdfa61ae2f02250a8f504bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c254e68ed108c49daf413213136f6d025bce6ba", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c254e68ed108c49daf413213136f6d025bce6ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c254e68ed108c49daf413213136f6d025bce6ba", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c254e68ed108c49daf413213136f6d025bce6ba/comments", "author": null, "committer": null, "parents": [{"sha": "5b0264cb4d7a017784253061843a52f7776a3942", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5b0264cb4d7a017784253061843a52f7776a3942", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5b0264cb4d7a017784253061843a52f7776a3942"}], "stats": {"total": 174, "additions": 145, "deletions": 29}, "files": [{"sha": "28fe88eb1c01f91d2392d95d5e4d9367f24af67d", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -1,3 +1,22 @@\n+2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* vec.c (vec_p_reserve, vec_o_reserve): Rename to ...\n+\t(vec_gc_p_reserve, vec_gc_o_reserve): ... here. Clone to\n+\t(vec_heap_p_reserve, vec_heap_o_reserve): ... here, adjust.\n+\t(vec_gc_free, vec_heap_free): New.\n+\t* vec.h (DEF_VEC_GC_P, DEF_VEC_MALLOC_P): New.\n+\t(DEF_VEC_P): Add allocator argument. Adjust.\n+\t(DEF_VEC_GC_O, DEF_VEC_MALLOC_O): New.\n+\t(DEF_VEC_O): Add allocator argument. Adjust.\n+\t(VEC(free)): New.\n+\n+\t* tree.h (tree): Define a GC'd vector.\n+\t* lamba-code.c (lambda_loop): Likewise.\n+\t* value-prof.h (histogram_value): Likewise.\n+\t* cp/cp-tree.h (tree_pair_s): Likewise.\n+\t* cp/name-lookup.h (cxx_saved_binding, cp_class_binding): Likewise.\n+\t* cp/semantics.c (deferred_access): Likewise.\n+\n 2004-09-08  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* emit-rtl.c (immed_double_const): Use gcc_assert and gcc_unreachable."}, {"sha": "0204cc23ed78c08cc0cb46b1d8f49746ce92f6c0", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -955,7 +955,7 @@ typedef struct tree_pair_s GTY (())\n   tree value;\n } tree_pair_s;\n typedef tree_pair_s *tree_pair_p;\n-DEF_VEC_O (tree_pair_s);\n+DEF_VEC_GC_O (tree_pair_s);\n \n /* This is a few header flags for 'struct lang_type'.  Actually,\n    all but the first are used only for lang_type_class; they"}, {"sha": "e03f8ec933980df14ab4298afd85614130fe9130", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -91,7 +91,7 @@ typedef struct cxx_saved_binding GTY(())\n   tree real_type_value;\n } cxx_saved_binding;\n \n-DEF_VEC_O(cxx_saved_binding);\n+DEF_VEC_GC_O(cxx_saved_binding);\n \n extern tree identifier_type_value (tree);\n extern void set_identifier_type_value (tree, tree);\n@@ -132,7 +132,7 @@ typedef struct cp_class_binding GTY(())\n   tree identifier;\n } cp_class_binding;\n \n-DEF_VEC_O(cp_class_binding);\n+DEF_VEC_GC_O(cp_class_binding);\n \n /* For each binding contour we allocate a binding_level structure\n    which records the names defined in that contour."}, {"sha": "fe687a0f618e9d8bb62effcecf2472a253aeef15", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -138,7 +138,7 @@ typedef struct deferred_access GTY(())\n   enum deferring_kind deferring_access_checks_kind;\n   \n } deferred_access;\n-DEF_VEC_O (deferred_access);\n+DEF_VEC_GC_O (deferred_access);\n \n /* Data for deferred access checking.  */\n static GTY(()) VEC (deferred_access) *deferred_access_stack;"}, {"sha": "be1195048cd3c2499a4c6d9013d783686100a94f", "filename": "gcc/lambda-code.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Flambda-code.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Flambda-code.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flambda-code.c?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -1406,7 +1406,7 @@ find_induction_var_from_exit_cond (struct loop *loop)\n   return TREE_OPERAND (test, 0);\n }\n \n-DEF_VEC_P(lambda_loop);\n+DEF_VEC_GC_P(lambda_loop);\n /* Generate a lambda loopnest from a gcc loopnest LOOP_NEST.\n    Return the new loop nest.  \n    INDUCTIONVARS is a pointer to an array of induction variables for the"}, {"sha": "c23ec7c769ccd9ebf2291aba9ef5071b658df34d", "filename": "gcc/tree.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -76,8 +76,8 @@ extern const unsigned char tree_code_length[];\n \n extern const char *const tree_code_name[];\n \n-/* A vector of trees.  */\n-DEF_VEC_P(tree);\n+/* A garbage collected vector of trees.  */\n+DEF_VEC_GC_P(tree);\n \n \f\n /* Classify which part of the compiler has defined a given builtin function."}, {"sha": "312b8bc6226f3ce9a8e5f8ebbac78757078668eb", "filename": "gcc/value-prof.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -66,7 +66,7 @@ struct histogram_value_t GTY(())\n \n typedef struct histogram_value_t *histogram_value;\n \n-DEF_VEC_P(histogram_value);\n+DEF_VEC_GC_P(histogram_value);\n \n typedef VEC(histogram_value) *histogram_values;\n "}, {"sha": "72480dcd6fed864184c7b19464fe81080b801515", "filename": "gcc/vec.c", "status": "modified", "additions": 65, "deletions": 6, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvec.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvec.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.c?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -39,11 +39,11 @@ struct vec_prefix\n    VEC can be NULL, to create a new vector.  */\n \n void *\n-vec_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n+vec_gc_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n {\n-  return vec_o_reserve (vec, reserve,\n-\t\t\toffsetof (struct vec_prefix, vec), sizeof (void *)\n-\t\t\tPASS_MEM_STAT);\n+  return vec_gc_o_reserve (vec, reserve,\n+\t\t\t   offsetof (struct vec_prefix, vec), sizeof (void *)\n+\t\t\t   PASS_MEM_STAT);\n }\n \n /* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n@@ -53,8 +53,8 @@ vec_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n    ELT_SIZE sized elements.  */\n \n void *\n-vec_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n-\t       MEM_STAT_DECL)\n+vec_gc_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n+\t\t   MEM_STAT_DECL)\n {\n   struct vec_prefix *pfx = vec;\n   unsigned alloc = pfx ? pfx->num : 0;\n@@ -77,6 +77,65 @@ vec_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n   return vec;\n }\n \n+/* Explicitly release a vector.  */\n+\n+void\n+vec_gc_free (void *vec)\n+{\n+  ggc_free (vec);\n+}\n+\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n+   0.  If RESERVE < 0 increase the current allocation exponentially.\n+   VEC can be NULL, to create a new vector.  */\n+\n+void *\n+vec_heap_p_reserve (void *vec, int reserve MEM_STAT_DECL)\n+{\n+  return vec_heap_o_reserve (vec, reserve,\n+\t\t\t     offsetof (struct vec_prefix, vec), sizeof (void *)\n+\t\t\t     PASS_MEM_STAT);\n+}\n+\n+/* Ensure there are at least RESERVE free slots in VEC, if RESERVE >=\n+   0.  If RESERVE < 0, increase the current allocation exponentially.\n+   VEC can be NULL, in which case a new vector is created.  The\n+   vector's trailing array is at VEC_OFFSET offset and consists of\n+   ELT_SIZE sized elements.  */\n+\n+void *\n+vec_heap_o_reserve (void *vec, int reserve, size_t vec_offset, size_t elt_size\n+\t\t    MEM_STAT_DECL)\n+{\n+  struct vec_prefix *pfx = vec;\n+  unsigned alloc = pfx ? pfx->num : 0;\n+\n+  if (reserve >= 0)\n+    alloc += reserve;\n+  else if (alloc)\n+    alloc *= 2;\n+  else\n+    alloc = 4;\n+\n+  if (pfx && pfx->alloc >= alloc)\n+    abort ();\n+  \n+  vec = xrealloc (vec, vec_offset + alloc * elt_size);\n+  ((struct vec_prefix *)vec)->alloc = alloc;\n+  if (!pfx)\n+    ((struct vec_prefix *)vec)->num = 0;\n+  \n+  return vec;\n+}\n+\n+/* Explicitly release a vector.  */\n+\n+void\n+vec_heap_free (void *vec)\n+{\n+  free (vec);\n+}\n+\n #if ENABLE_CHECKING\n /* Issue a vector domain error, and then fall over.  */\n "}, {"sha": "d6fc8adfcea822ca47449da836a222d7c4ece184", "filename": "gcc/vec.h", "status": "modified", "additions": 53, "deletions": 15, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvec.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c254e68ed108c49daf413213136f6d025bce6ba/gcc%2Fvec.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvec.h?ref=4c254e68ed108c49daf413213136f6d025bce6ba", "patch": "@@ -78,19 +78,25 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n    The 'lower_bound' function will determine where to place an item in the\n    array using insert that will maintain sorted order.\n \n+   Both garbage collected and explicitly managed vector types are\n+   creatable.  The allocation mechanism is specified when the type is\n+   defined, and is therefore part of the type.\n+   \n    If you need to directly manipulate a vector, then the 'address'\n    accessor will return the address of the start of the vector.  Also\n    the 'space' predicate will tell you whether there is spare capacity\n    in the vector.  You will not normally need to use these two functions.\n    \n-   Vector types are defined using a DEF_VEC_{O,P}(TYPEDEF) macro, and\n-   variables of vector type are declared using a VEC(TYPEDEF)\n-   macro. The characters O and P indicate whether TYPEDEF is a pointer\n-   (P) or object (O) type.\n+   Vector types are defined using a DEF_VEC_{GC,MALLOC}_{O,P}(TYPEDEF)\n+   macro, and variables of vector type are declared using a\n+   VEC(TYPEDEF) macro.  The tags GC and MALLOC specify the allocation\n+   method -- garbage collected or explicit malloc/free calls.  The\n+   characters O and P indicate whether TYPEDEF is a pointer (P) or\n+   object (O) type.\n \n    An example of their use would be,\n \n-   DEF_VEC_P(tree);\t// define a vector of tree pointers.  This must\n+   DEF_VEC_GC_P(tree);\t// define a gc'd vector of tree pointers.  This must\n    \t\t\t// appear at file scope.\n \n    struct my_struct {\n@@ -158,6 +164,13 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #define VEC_alloc(TDEF,A)\t(VEC_OP(TDEF,alloc)(A MEM_STAT_INFO))\n \n+/* Free a vector.\n+   void VEC_T_alloc(VEC(T) *&);\n+\n+   Free a vector and set it to NULL.  */\n+\n+#define VEC_free(TDEF,V)\t(VEC_OP(TDEF,free)(&V))\n+\n /* Use these to determine the required size and initialization of a\n    vector embedded within another structure (as the final member).\n    \n@@ -317,8 +330,12 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n #if !IN_GENGTYPE\n /* Reallocate an array of elements with prefix.  */\n-extern void *vec_p_reserve (void *, int MEM_STAT_DECL);\n-extern void *vec_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void *vec_gc_p_reserve (void *, int MEM_STAT_DECL);\n+extern void *vec_gc_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void vec_gc_free (void *);\n+extern void *vec_heap_p_reserve (void *, int MEM_STAT_DECL);\n+extern void *vec_heap_o_reserve (void *, int, size_t, size_t MEM_STAT_DECL);\n+extern void vec_heap_free (void *);\n \n #if ENABLE_CHECKING\n #define VEC_CHECK_INFO ,__FILE__,__LINE__,__FUNCTION__\n@@ -359,10 +376,13 @@ typedef struct VEC (TDEF) GTY(())\t\t\t\t\t  \\\n \n /* Vector of pointer to object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_P\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+{\"DEF_VEC_GC_P\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+{\"DEF_VEC_MALLOC_P\", \"\", NULL},\n #else\n+#define DEF_VEC_GC_P(TDEF) DEF_VEC_P(TDEF,gc)\n+#define DEF_VEC_MALLOC_P(TDEF) DEF_VEC_P(TDEF,heap)\n   \n-#define DEF_VEC_P(TDEF)\t\t\t\t\t\t\t  \\\n+#define DEF_VEC_P(TDEF,a)\t\t\t\t\t\t  \\\n VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (TDEF,length)\t\t\t\t  \\\n@@ -405,7 +425,14 @@ static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)\t\t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC (TDEF) *) vec_p_reserve (NULL, alloc_ - !alloc_ PASS_MEM_STAT);\\\n+  return (VEC (TDEF) *) vec_##a##_p_reserve (NULL, alloc_ - !alloc_ PASS_MEM_STAT);\\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,free)\t\t\t\t\t  \\\n+     (VEC (TDEF) **vec_)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  vec_##a##_free (*vec_);\t\t\t\t\t\t  \\\n+  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n@@ -434,7 +461,7 @@ static inline int VEC_OP (TDEF,reserve)\t       \t\t\t\t  \\\n   int extend = VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n \t\t  \t\t\t\t\t\t\t  \\\n   if (extend)\t  \t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC (TDEF) *) vec_p_reserve (*vec_, alloc_ PASS_MEM_STAT);   \\\n+    *vec_ = (VEC (TDEF) *) vec_##a##_p_reserve (*vec_, alloc_ PASS_MEM_STAT);   \\\n \t\t  \t\t\t\t\t\t\t  \\\n   return extend;\t\t\t\t\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n@@ -577,10 +604,14 @@ struct vec_swallow_trailing_semi\n \n /* Vector of object.  */\n #if IN_GENGTYPE\n-{\"DEF_VEC_O\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+{\"DEF_VEC_GC_O\", VEC_STRINGIFY (VEC_TDEF (#)) \";\", NULL},\n+{\"DEF_VEC_MALLOC_O\", \"\", NULL},\n #else\n   \n-#define DEF_VEC_O(TDEF)\t\t\t\t\t\t\t  \\\n+#define DEF_VEC_GC_O(TDEF) DEF_VEC_O(TDEF,gc)\n+#define DEF_VEC_MALLOC_O(TDEF) DEF_VEC_O(TDEF,heap)\n+\n+#define DEF_VEC_O(TDEF,a)\t\t\t\t\t\t  \\\n VEC_TDEF (TDEF);\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n static inline unsigned VEC_OP (TDEF,length)\t\t\t\t  \\\n@@ -623,11 +654,18 @@ static inline int VEC_OP (TDEF,iterate)\t\t\t  \t     \t  \\\n static inline VEC (TDEF) *VEC_OP (TDEF,alloc)      \t\t\t  \\\n      (int alloc_ MEM_STAT_DECL)\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n-  return (VEC (TDEF) *) vec_o_reserve (NULL, alloc_ - !alloc_,\t\t  \\\n+  return (VEC (TDEF) *) vec_##a##_o_reserve (NULL, alloc_ - !alloc_,\t  \\\n                                        offsetof (VEC(TDEF),vec), sizeof (TDEF)\\\n                                        PASS_MEM_STAT);\t\t\t  \\\n }\t\t\t\t\t\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n+static inline void VEC_OP (TDEF,free)\t\t\t\t\t  \\\n+     (VEC (TDEF) **vec_)\t\t\t\t\t\t  \\\n+{\t\t\t\t\t\t\t\t\t  \\\n+  vec_##a##_free (*vec_);\t\t\t\t\t\t  \\\n+  *vec_ = NULL;\t\t\t\t\t\t\t\t  \\\n+}\t\t\t\t\t\t\t\t\t  \\\n+\t\t\t\t\t\t\t\t\t  \\\n static inline size_t VEC_OP (TDEF,embedded_size)\t\t\t  \\\n      (int alloc_)\t\t\t\t\t\t\t  \\\n {\t\t\t\t\t\t\t\t\t  \\\n@@ -654,7 +692,7 @@ static inline int VEC_OP (TDEF,reserve)\t   \t    \t\t\t  \\\n   int extend = VEC_OP (TDEF,space) (*vec_, alloc_);\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\\n   if (extend)\t\t\t\t\t\t\t\t  \\\n-    *vec_ = (VEC (TDEF) *) vec_o_reserve (*vec_, alloc_,\t\t  \\\n+    *vec_ = (VEC (TDEF) *) vec_##a##_o_reserve (*vec_, alloc_,\t\t  \\\n \t\t\t   offsetof (VEC(TDEF),vec), sizeof (TDEF)\t  \\\n \t\t\t   PASS_MEM_STAT);\t\t\t\t  \\\n \t\t\t\t\t\t\t\t\t  \\"}]}