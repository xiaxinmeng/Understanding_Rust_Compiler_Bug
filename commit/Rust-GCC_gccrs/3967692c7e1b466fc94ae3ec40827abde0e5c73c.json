{"sha": "3967692c7e1b466fc94ae3ec40827abde0e5c73c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk2NzY5MmM3ZTFiNDY2ZmM5NGFlM2VjNDA4MjdhYmRlMGU1YzczYw==", "commit": {"author": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-23T16:02:41Z"}, "committer": {"name": "Richard Earnshaw", "email": "erich@gnu.org", "date": "1994-06-23T16:02:41Z"}, "message": "(TARGET_WHEN_DEBUGGING): Delete.\n\n(MODES_TIEABLE_P): All modes of the same class are tieable.\n(CONST_OK_FOR_LETTER_P): Add 'M' for constants valid in a shift.\n(FUNCTION_PROFILER): Don't call arm_increase_location.\n(INITIAL_ELIMINATION_OFFSET): Call saved regs are no-longer pushed for\nfunctions that don't return.\n(LEGITIMIZE_ADDRESS): Push constants that will never be legitimate -- symbols\nand labels -- into registers.  Handle DImode better.\n(DEFAULT_SIGNED_CHAR): Use unsigned unless already defined.\n(RTX_COSTS): Call arm_rtx_costs.\n(ADDRESS_COST): Since most operations have the same rtx cost, make the\nmore complex addresses cheaper.\n(PREDICATE_CODES): Add ROTATERT to shift_operator; and new predicates for\nreg_or_int_operand and multi_register_push.\n(DBX_CONTIN_LENGTH): Only define if not already done.\n(PRINT_OPERAND_ADDRESS): Let arm_print operand output the \", \" for shifts.\n\nFrom-SVN: r7536", "tree": {"sha": "a68d53b49b42341aa2455052ba94a2d94bd8ac0b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a68d53b49b42341aa2455052ba94a2d94bd8ac0b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3967692c7e1b466fc94ae3ec40827abde0e5c73c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3967692c7e1b466fc94ae3ec40827abde0e5c73c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3967692c7e1b466fc94ae3ec40827abde0e5c73c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3967692c7e1b466fc94ae3ec40827abde0e5c73c/comments", "author": null, "committer": null, "parents": [{"sha": "e8da7c023749fb8d5e940d935a2a541c8df66459", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8da7c023749fb8d5e940d935a2a541c8df66459", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8da7c023749fb8d5e940d935a2a541c8df66459"}], "stats": {"total": 248, "additions": 110, "deletions": 138}, "files": [{"sha": "984bbca4fd22cec2e4b0f20b1605d94d4af51a13", "filename": "gcc/config/arm/arm.h", "status": "modified", "additions": 110, "deletions": 138, "changes": 248, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3967692c7e1b466fc94ae3ec40827abde0e5c73c/gcc%2Fconfig%2Farm%2Farm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3967692c7e1b466fc94ae3ec40827abde0e5c73c/gcc%2Fconfig%2Farm%2Farm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.h?ref=3967692c7e1b466fc94ae3ec40827abde0e5c73c", "patch": "@@ -136,9 +136,6 @@ extern enum processor_type arm_cpu;\n    - if floating point is done by emulation, forget about instruction\n      scheduling.  Note that this only saves compilation time; it doesn't\n      matter for the final code.  */\n-#ifndef TARGET_WHEN_DEBUGGING\n-#define TARGET_WHEN_DEBUGGING  1\n-#endif\n \n #define OVERRIDE_OPTIONS  \\\n {\t\t\t\t\t\t\t\t\\\n@@ -374,8 +371,7 @@ extern enum processor_type arm_cpu;\n    If HARD_REGNO_MODE_OK could produce different values for MODE1 and MODE2,\n    for any hard reg, then this must be 0 for correct output.  */\n #define MODES_TIEABLE_P(MODE1, MODE2)  \\\n-  (((MODE1) == SFmode || (MODE1) == DFmode)      \\\n-   == ((MODE2) == SFmode || (MODE2) == DFmode))\n+  (GET_MODE_CLASS (MODE1) == GET_MODE_CLASS (MODE2))\n \n /* Specify the registers used for certain standard purposes.\n    The values of these macros are register numbers.  */\n@@ -494,12 +490,16 @@ enum reg_class\n \tI: immediate arithmetic operand (i.e. 8 bits shifted as required).\n \tJ: valid indexing constants.  \n \tK: ~value ok in rhs argument of data operand.\n-\tL: -value ok in rhs argument of data operand. */\n+\tL: -value ok in rhs argument of data operand. \n+        M: 0..32, or a power of 2  (for shifts, or mult done by shift).  */\n #define CONST_OK_FOR_LETTER_P(VALUE, C)  \t\t\\\n   ((C) == 'I' ? const_ok_for_arm (VALUE) :\t\t\\\n    (C) == 'J' ? ((VALUE) < 4096 && (VALUE) > -4096) :\t\\\n    (C) == 'K' ? (const_ok_for_arm (~(VALUE))) :\t\t\\\n-   (C) == 'L' ? (const_ok_for_arm (-(VALUE))) : 0)\n+   (C) == 'L' ? (const_ok_for_arm (-(VALUE))) :\t\t\\\n+   (C) == 'M' ? (((VALUE >= 0 && VALUE <= 32))\t\t\\\n+\t\t || (((VALUE) & ((VALUE) - 1)) == 0))\t\\\n+   : 0)\n \n /* For the ARM, `Q' means that this is a memory operand that is just\n    an offset from a register.  \n@@ -696,7 +696,6 @@ enum reg_class\n     fprintf(STREAM, \"\\tmov\\t%sip, %slr\\n\", ARM_REG_PREFIX, ARM_REG_PREFIX); \\\n     fprintf(STREAM, \"\\tbl\\tmcount\\n\");\t\t\t\t\t    \\\n     fprintf(STREAM, \"\\t.word\\tLP%d\\n\", (LABELNO));\t\t\t    \\\n-    arm_increase_location (12);\t\t\t\t\t\t    \\\n }\n \n /* EXIT_IGNORE_STACK should be nonzero if, when returning from a function,\n@@ -749,6 +748,7 @@ enum reg_class\n    its replacement, at the start of a routine.  */\n #define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\t\t\\\n {\t\t\t\t\t\t\t\t\t\\\n+  int volatile_func = arm_volatile_func ();\t\t\t\t\\\n   if ((FROM) == ARG_POINTER_REGNUM && (TO) == HARD_FRAME_POINTER_REGNUM)\\\n     (OFFSET) = 0;\t\t\t\t\t\t\t\\\n   else if ((FROM) == FRAME_POINTER_REGNUM && (TO) == STACK_POINTER_REGNUM)\\\n@@ -759,19 +759,22 @@ enum reg_class\n       int offset = 12;\t\t\t\t\t\t\t\\\n       int saved_hard_reg = 0;\t\t\t\t\t\t\\\n \t\t\t\t\t\t\t\t\t\\\n-      for (regno = 0; regno <= 10; regno++)\t\t\t\t\\\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n-\t  saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n-      for (regno = 16; regno <=23; regno++)\t\t\t\t\\\n-\tif (regs_ever_live[regno] && ! call_used_regs[regno])\t\t\\\n-\t  offset += 12;\t\t\t\t\t\t\t\\\n+      if (! volatile_func)\t\t\t\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+          for (regno = 0; regno <= 10; regno++)\t\t\t\t\\\n+\t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+\t      saved_hard_reg = 1, offset += 4;\t\t\t\t\\\n+          for (regno = 16; regno <=23; regno++)\t\t\t\t\\\n+\t    if (regs_ever_live[regno] && ! call_used_regs[regno])\t\\\n+\t      offset += 12;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n       if ((FROM) == FRAME_POINTER_REGNUM)\t\t\t\t\\\n \t(OFFSET) = -offset;\t\t\t\t\t\t\\\n       else\t\t\t\t\t\t\t\t\\\n \t{\t\t\t\t\t\t\t\t\\\n \t   if (! regs_ever_live[HARD_FRAME_POINTER_REGNUM])\t\t\\\n \t     offset -= 16;\t\t\t\t\t\t\\\n-\t   if (regs_ever_live[14] || saved_hard_reg)\t\t\t\\\n+\t   if (! volatile_func && (regs_ever_live[14] || saved_hard_reg)) \\\n \t     offset += 4;\t\t\t\t\t\t\\\n \t   (OFFSET) = (get_frame_size () + 3 & ~3) + offset;\t\t\\\n          }\t\t\t\t\t\t\t\t\\\n@@ -1049,48 +1052,66 @@ do\t\t\t\t\t\t\t\t\t\\\n    On the ARM, try to convert [REG, #BIGCONST]\n    into ADD BASE, REG, #UPPERCONST and [BASE, #VALIDCONST],\n    where VALIDCONST == 0 in case of TImode.  */\n-#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)  \\\n-{\t\t\t\t\t\t        \t\t     \\\n-  if (GET_CODE (X) == PLUS)\t\t\t        \t\t     \\\n-    {\t\t\t\t\t\t        \t\t     \\\n-      rtx xop0 = XEXP (X, 0);\t\t\t        \t\t     \\\n-      rtx xop1 = XEXP (X, 1);\t\t\t        \t\t     \\\n-\t\t\t\t\t\t        \t\t     \\\n-      if (BASE_REGISTER_RTX_P (xop0) && GET_CODE (xop1) == CONST_INT)\t     \\\n-\t{\t\t\t\t\t        \t\t     \\\n-\t  int n = INTVAL (xop1);\t\t        \t\t     \\\n-\t  int low_n = ((MODE) == TImode ? 0\t        \t\t     \\\n-\t\t       : n >= 0 ? (n & 0xFFF) : -((-n) & 0xFFF));\t     \\\n-\t  rtx base_reg = gen_reg_rtx (SImode);\t        \t\t     \\\n-\t  rtx val = force_operand (gen_rtx (PLUS, SImode, xop0,\t\t     \\\n-\t\t\t\t\t    gen_rtx (CONST_INT,\t\t     \\\n-\t\t\t\t\t\t     VOIDmode, n - low_n)),  \\\n-\t\t\t\t   0);\t\t\t\t\t     \\\n-          emit_move_insn (base_reg, val);\t\t\t\t     \\\n-\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t     \\\n-\t\t : gen_rtx (PLUS, SImode, base_reg,\t\t\t     \\\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, low_n)));\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-      else if (BASE_REGISTER_RTX_P (xop1) && GET_CODE (xop0) == CONST_INT)   \\\n-\t{\t\t\t\t\t\t\t\t     \\\n-\t  int n = INTVAL (xop0);\t\t\t\t\t     \\\n-\t  int low_n = ((MODE) == TImode ? 0\t\t\t\t     \\\n-\t\t       : n >= 0 ? (n & 0xFFF) : -((-n) & 0xFFF));\t     \\\n-\t  rtx base_reg = gen_reg_rtx (SImode);\t\t\t\t     \\\n-\t  rtx val = force_operand (gen_rtx (PLUS, SImode, xop1,\t\t     \\\n-\t\t\t\t\t    gen_rtx (CONST_INT,\t\t     \\\n-\t\t\t\t\t\t     VOIDmode, n - low_n)),  \\\n-\t\t\t\t   0);\t\t\t\t\t     \\\n-\t  emit_move_insn (base_reg, val);\t\t\t\t     \\\n-\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t     \\\n-\t\t : gen_rtx (PLUS, SImode, base_reg,\t\t\t     \\\n-\t\t\t    gen_rtx (CONST_INT, VOIDmode, low_n)));\t     \\\n-\t}\t\t\t\t\t\t\t\t     \\\n-    }\t\t\t\t\t\t\t\t\t     \\\n-  if (memory_address_p (MODE, X))\t\t\t\t\t     \\\n-    goto win;\t\t\t\t\t\t\t\t     \\\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN)\t\t\t\t \\\n+{\t\t\t\t\t\t\t\t\t \\\n+  if (GET_CODE (X) == PLUS)\t\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+      if (CONSTANT_P (xop0) && ! LEGITIMATE_CONSTANT_P (xop0))\t\t \\\n+\txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n+      if (CONSTANT_P (xop1) && ! LEGITIMATE_CONSTANT_P (xop1))\t\t \\\n+\txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n+      if (BASE_REGISTER_RTX_P (xop0) && GET_CODE (xop1) == CONST_INT)\t \\\n+\t{\t\t\t\t\t\t\t\t \\\n+\t  HOST_WIDE_INT n, low_n;\t\t\t\t\t \\\n+\t  rtx base_reg, val;\t\t\t\t\t\t \\\n+\t  n = INTVAL (xop1);\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+\t  if (MODE == DImode)\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      low_n = n & 0x0f;\t\t\t\t\t\t \\\n+\t      n &= ~0x0f;\t\t\t\t\t\t \\\n+\t      if (low_n > 4)\t\t\t\t\t\t \\\n+\t\t{\t\t\t\t\t\t\t \\\n+\t\t  n += 16;\t\t\t\t\t\t \\\n+\t\t  low_n -= 16;\t\t\t\t\t\t \\\n+\t\t}\t\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  else\t\t\t\t\t\t\t\t \\\n+\t    {\t\t\t\t\t\t\t\t \\\n+\t      low_n = ((MODE) == TImode ? 0\t\t\t\t \\\n+\t\t       : n >= 0 ? (n & 0xfff) : -((-n) & 0xfff));\t \\\n+\t      n -= low_n;\t\t\t\t\t\t \\\n+\t    }\t\t\t\t\t\t\t\t \\\n+\t  base_reg = gen_reg_rtx (SImode);\t\t\t\t \\\n+\t  val = force_operand (gen_rtx (PLUS, SImode, xop0,\t\t \\\n+\t\t\t\t\tGEN_INT (n)), NULL_RTX);\t \\\n+\t  emit_move_insn (base_reg, val);\t\t\t\t \\\n+\t  (X) = (low_n == 0 ? base_reg\t\t\t\t\t \\\n+\t\t : gen_rtx (PLUS, SImode, base_reg, GEN_INT (low_n)));\t \\\n+\t}\t\t\t\t\t\t\t\t \\\n+      else if (xop0 != XEXP (X, 0) || xop1 != XEXP (x, 1))\t\t \\\n+\t(X) = gen_rtx (PLUS, SImode, xop0, xop1);\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  else if (GET_CODE (X) == MINUS)\t\t\t\t\t \\\n+    {\t\t\t\t\t\t\t\t\t \\\n+      rtx xop0 = XEXP (X, 0);\t\t\t\t\t\t \\\n+      rtx xop1 = XEXP (X, 1);\t\t\t\t\t\t \\\n+\t\t\t\t\t\t\t\t\t \\\n+      if (CONSTANT_P (xop0))\t\t\t\t\t\t \\\n+\txop0 = force_reg (SImode, xop0);\t\t\t\t \\\n+      if (CONSTANT_P (xop1) && ! LEGITIMATE_CONSTANT_P (xop1))\t\t \\\n+\txop1 = force_reg (SImode, xop1);\t\t\t\t \\\n+      if (xop0 != XEXP (X, 0) || xop1 != XEXP (X, 1))\t\t\t \\\n+\t(X) = gen_rtx (MINUS, SImode, xop0, xop1);\t\t\t \\\n+    }\t\t\t\t\t\t\t\t\t \\\n+  if (memory_address_p (MODE, X))\t\t\t\t\t \\\n+    goto WIN;\t\t\t\t\t\t\t\t \\\n }\n \n+\n /* Go to LABEL if ADDR (a legitimate address expression)\n    has an effect that depends on the machine mode it is used for.  */\n #define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR,LABEL)  \\\n@@ -1118,7 +1139,7 @@ do\t\t\t\t\t\t\t\t\t\\\n /* signed 'char' is most compatible, but RISC OS wants it unsigned.\n    unsigned is probably best, but may break some code.  */\n #ifndef DEFAULT_SIGNED_CHAR\n-#define DEFAULT_SIGNED_CHAR  1\n+#define DEFAULT_SIGNED_CHAR  0\n #endif\n \n /* Don't cse the address of the function being compiled.  */\n@@ -1204,91 +1225,38 @@ do\t\t\t\t\t\t\t\t\t\\\n        return -1;\t\t\t\t\t\t\\\n     return(7);\n \n+#define ARM_FRAME_RTX(X)\t\t\t\t\\\n+  ((X) == frame_pointer_rtx || (X) == stack_pointer_rtx\t\\\n+   || (X) == arg_pointer_rtx)\n+\n #define RTX_COSTS(X,CODE,OUTER_CODE)                                    \\\n-  case MEM:                                                             \\\n-    {                                                                   \\\n-      int num_words = (GET_MODE_SIZE (GET_MODE (X)) > UNITS_PER_WORD) ? 2 : 1;\\\n-      return (COSTS_N_INSNS (10*num_words));                             \\\n-    }                                                                   \\\n-  case MULT:                                                            \\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT                             \\\n-        && exact_log2 (INTVAL (XEXP (X, 1))) >= 0)                      \\\n-      return rtx_cost (XEXP (X, 0), GET_CODE (X))+1;                    \\\n-    return COSTS_N_INSNS (9);                                           \\\n-  case ASHIFT:\t\t\t\t\t\t\t\t\\\n-  case LSHIFTRT:\t\t\t\t\t\t\t\\\n-  case ASHIFTRT:\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == CONST_INT)\t\t\t\t\\\n-      return rtx_cost (XEXP (X, 0), GET_CODE (X))+1;\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case MINUS:\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    enum rtx_code code = GET_CODE (XEXP (X, 1));\t\t\t\\\n-    if (code == MULT)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XEXP (X, 1), 1)) == CONST_INT\t\t\\\n-\t    && exact_log2 (INTVAL (XEXP (XEXP (X, 0), 1))) >= 0)\t\\\n-\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT)\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-  } /* fall through */\t\t\t\t\t\t\t\\\n-  case PLUS:\t\t\t\t\t\t\t\t\\\n-  case IOR:\t\t\t\t\t\t\t\t\\\n-  case XOR:\t\t\t\t\t\t\t\t\\\n-  case AND:\t\t\t\t\t\t\t\t\\\n-  {\t\t\t\t\t\t\t\t\t\\\n-    enum rtx_code code = GET_CODE (XEXP (X, 0));\t\t\t\\\n-    if (code == MULT)\t\t\t\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (XEXP (X, 0), 1)) == CONST_INT\t\t\\\n-\t    && exact_log2 (INTVAL (XEXP (XEXP (X, 0), 1))) >= 0)\t\\\n-\t  return COSTS_N_INSNS (1);\t\t\t\t\t\\\n-\tif (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n-\t  return COSTS_N_INSNS (12);\t\t\t\t\t\\\n-\tbreak;\t\t\t\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    else if (code == ASHIFT || code == ASHIFTRT || code == LSHIFTRT)\t\\\n-      return COSTS_N_INSNS (1);\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  }\t\t\t\t\t\t\t\t\t\\\n-  case NOT:\t\t\t\t\t\t\t\t\\\n-    return rtx_cost (XEXP (X, 0), GET_CODE (XEXP (X, 0)));\t\t\\\n-  case IF_THEN_ELSE:                                                    \\\n-    {                                                                   \\\n-      if (GET_CODE (XEXP(X,1)) == PC || GET_CODE (XEXP(X,2)) == PC)     \\\n-        return COSTS_N_INSNS (4);                                       \\\n-      return COSTS_N_INSNS (1);                                 \t\\\n-    }                                                                   \\\n-  case SIGN_EXTEND:                                                     \\\n-    return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-  case ZERO_EXTEND:\t\t\t\t\t\t\t\\\n-    if (GET_MODE (XEXP (X, 0)) == QImode)\t\t\t\t\\\n-      {\t\t\t\t\t\t\t\t\t\\\n-\tif (GET_CODE (XEXP (X, 0)) == MEM)\t\t\t\t\\\n-\t  return COSTS_N_INSNS (10);\t\t\t\t\t\\\n-\treturn COSTS_N_INSNS (1);\t\t\t\t\t\\\n-      }\t\t\t\t\t\t\t\t\t\\\n-    break;\t\t\t\t\t\t\t\t\\\n-  case COMPARE:\t\t\t\t\t\t\t\t\\\n-    if (GET_CODE (XEXP (X, 1)) == REG)\t\t\t\t\t\\\n-      return 4;\t\t\t\t\t\t\t\t\\\n-  case SMIN:\t\t\t\t\t\t\t\t\\\n-  case SMAX:\t\t\t\t\t\t\t\t\\\n-  case UMIN:\t\t\t\t\t\t\t\t\\\n-  case UMAX:\t\t\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (3);\t\t\t\t\t\t\\\n-  case ABS:\t\t\t\t\t\t\t\t\\\n-    if (GET_MODE (X) == SImode)\t\t\t\t\t\t\\\n-      return COSTS_N_INSNS (2);\t\t\t\t\t\t\\\n-    return COSTS_N_INSNS (1);\n+  default:\t\t\t\t\t\t\t\t\\\n+   return arm_rtx_costs (X, CODE, OUTER_CODE);\n \n /* Moves to and from memory are quite expensive */\n #define MEMORY_MOVE_COST(MODE)  10\n \n-/* All address computations that can be done are free */\n-#define ADDRESS_COST(x) 2\n+/* All address computations that can be done are free, but rtx cost returns\n+   the same for practically all of them.  So we weight the differnt types\n+   of address here in the order (most pref first):\n+   PRE/POST_INC/DEC, SHIFT or NON-INT sum, INT sum, REG, MEM or LABEL. */\n+#define ADDRESS_COST(X)\t\t\t\t\t\t\t     \\\n+  (10 - ((GET_CODE (X) == MEM || GET_CODE (X) == LABEL_REF\t\t     \\\n+\t  || GET_CODE (X) == SYMBOL_REF)\t\t\t\t     \\\n+\t ? 0\t\t\t\t\t\t\t\t     \\\n+\t : ((GET_CODE (X) == PRE_INC || GET_CODE (X) == PRE_DEC\t\t     \\\n+\t     || GET_CODE (X) == POST_INC || GET_CODE (X) == POST_DEC)\t     \\\n+\t    ? 10\t\t\t\t\t\t\t     \\\n+\t    : (((GET_CODE (X) == PLUS || GET_CODE (X) == MINUS)\t\t     \\\n+\t\t? 6 + (GET_CODE (XEXP (X, 1)) == CONST_INT ? 2 \t\t     \\\n+\t\t       : ((GET_RTX_CLASS (GET_CODE (XEXP (X, 0))) == '2'     \\\n+\t\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (X, 0))) == 'c'  \\\n+\t\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (X, 1))) == '2'  \\\n+\t\t\t   || GET_RTX_CLASS (GET_CODE (XEXP (X, 1))) == 'c') \\\n+\t\t\t  ? 1 : 0))\t\t\t\t\t     \\\n+\t\t: 4)))))\n+\t \n+   \n \n /* Try to generate sequences that don't involve branches, we can then use\n    conditional instructions */\n@@ -1342,14 +1310,16 @@ extern int arm_compare_fp;\n   {\"arm_not_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n   {\"shiftable_operator\", {PLUS, MINUS, AND, IOR, XOR}},\t\t\t\\\n   {\"minmax_operator\", {SMIN, SMAX, UMIN, UMAX}},\t\t\t\\\n-  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, MULT}},\t\\\n+  {\"shift_operator\", {ASHIFT, ASHIFTRT, LSHIFTRT, ROTATERT, MULT}},\t\\\n   {\"di_operand\", {SUBREG, REG, CONST_INT, CONST_DOUBLE, MEM}},\t\t\\\n   {\"load_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n   {\"store_multiple_operation\", {PARALLEL}},\t\t\t\t\\\n   {\"equality_operator\", {EQ, NE}},\t\t\t\t\t\\\n   {\"arm_rhsm_operand\", {SUBREG, REG, CONST_INT, MEM}},\t\t\t\\\n   {\"const_shift_operand\", {CONST_INT}},\t\t\t\t\t\\\n   {\"index_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\t\\\n+  {\"reg_or_int_operand\", {SUBREG, REG, CONST_INT}},\t\t\t\\\n+  {\"multi_register_push\", {PARALLEL}},\t\t\t\t\t\\\n   {\"cc_register\", {REG}},\n \n \f\n@@ -1430,7 +1400,9 @@ extern int arm_compare_fp;\n #define DBX_DEBUGGING_INFO  1\n \n /* Acorn dbx moans about continuation chars, so don't use any.  */\n+#ifndef DBX_CONTIN_LENGTH\n #define DBX_CONTIN_LENGTH  0\n+#endif\n \n /* Output a source filename for the debugger. RISCiX dbx insists that the\n    ``desc'' field is set to compiler version number >= 315 (sic).  */\n@@ -1709,7 +1681,7 @@ do { char dstr[30];\t\t\t\t\t\t\t\\\n \t  case ASHIFT:\t\t\t\t\t\t\t\\\n \t  case ROTATERT:\t\t\t\t\t\t\\\n \t  {\t\t\t\t\t\t\t\t\\\n-\t    fprintf (STREAM, \"[%s%s, %s%s%s, \", ARM_REG_PREFIX,\t\t\\\n+\t    fprintf (STREAM, \"[%s%s, %s%s%s\", ARM_REG_PREFIX,\t\t\\\n \t\t     base_reg_name, is_minus ? \"-\" : \"\", ARM_REG_PREFIX,\\\n \t\t     reg_names[REGNO (XEXP (index, 0))]);\t\t\\\n \t    arm_print_operand (STREAM, index, 'S');\t\t\t\\"}]}