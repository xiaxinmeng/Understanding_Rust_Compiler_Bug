{"sha": "208149b7201420d965991e08cb4e4c261171b0a2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjA4MTQ5YjcyMDE0MjBkOTY1OTkxZTA4Y2I0ZTRjMjYxMTcxYjBhMg==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2019-07-31T14:38:21Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2019-07-31T14:38:21Z"}, "message": "re PR tree-optimization/91280 (ICE in get_constraint_for_component_ref, at tree-ssa-structalias.c:3259 since r260354)\n\n2019-07-31  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/91280\n\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n\tDecompose MEM_REF manually for offset handling.\n\n\t* g++.dg/torture/pr91280.C: New testcase.\n\nFrom-SVN: r273936", "tree": {"sha": "95dce03118e2b3393eff7e3602cd0ffdef245560", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/95dce03118e2b3393eff7e3602cd0ffdef245560"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/208149b7201420d965991e08cb4e4c261171b0a2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208149b7201420d965991e08cb4e4c261171b0a2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/208149b7201420d965991e08cb4e4c261171b0a2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/208149b7201420d965991e08cb4e4c261171b0a2/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a28351e7f54cb63ed19e2fa67de8f91101260d94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a28351e7f54cb63ed19e2fa67de8f91101260d94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a28351e7f54cb63ed19e2fa67de8f91101260d94"}], "stats": {"total": 260, "additions": 257, "deletions": 3}, "files": [{"sha": "18f2ce2268c67e9211e2517b6aad0dbeb981c97f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=208149b7201420d965991e08cb4e4c261171b0a2", "patch": "@@ -1,3 +1,9 @@\n+2019-07-31  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91280\n+\t* tree-ssa-structalias.c (get_constraint_for_component_ref):\n+\tDecompose MEM_REF manually for offset handling.\n+\n 2019-07-31  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91293"}, {"sha": "f490292d534678579901fc9c3cfcec96a48439c4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=208149b7201420d965991e08cb4e4c261171b0a2", "patch": "@@ -1,3 +1,8 @@\n+2019-07-31  Richard Biener  <rguenther@suse.de>\n+\n+\tPR tree-optimization/91280\n+\t* g++.dg/torture/pr91280.C: New testcase.\n+\n 2019-07-31  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91293"}, {"sha": "063bef836f9a5604e26f48e55f856999b8f917c3", "filename": "gcc/testsuite/g++.dg/torture/pr91280.C", "status": "added", "additions": 223, "deletions": 0, "changes": 223, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr91280.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr91280.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2Fpr91280.C?ref=208149b7201420d965991e08cb4e4c261171b0a2", "patch": "@@ -0,0 +1,223 @@\n+// { dg-do compile }\n+\n+enum { Aligned, RowMajor };\n+enum { ReadOnlyAccessors };\n+template <typename> struct K {\n+  enum { value };\n+};\n+template <typename> struct traits;\n+template <typename T> struct traits<const T> : traits<T> {};\n+struct A {\n+  enum { has_write_access, value };\n+};\n+template <typename, int n> class array {\n+public:\n+  int operator[](unsigned long p1) { return values[p1]; }\n+  int values[n];\n+};\n+template <typename> struct I;\n+template <typename, int, template <class> class = I> class M;\n+template <typename, int, int, typename> class J;\n+template <typename, int> class N;\n+template <typename, typename> class D;\n+template <typename, typename, typename, typename> class TensorContractionOp;\n+template <long, typename> class TensorChippingOp;\n+class C;\n+template <typename DenseIndex, int NumDims>\n+struct K<array<DenseIndex, NumDims>> {\n+  static const long value = NumDims;\n+};\n+template <typename Scalar_, int NumIndices_, int Options_, typename IndexType_>\n+struct traits<J<Scalar_, NumIndices_, Options_, IndexType_>> {\n+  typedef IndexType_ Index;\n+};\n+template <typename PlainObjectType, int Options_,\n+          template <class> class MakePointer_>\n+struct traits<M<PlainObjectType, Options_, MakePointer_>>\n+    : traits<PlainObjectType> {};\n+template <typename T> struct B { typedef T type; };\n+template <typename Derived> class N<Derived, ReadOnlyAccessors> {\n+public:\n+  typedef typename traits<Derived>::Index Index;\n+  D<int, Derived> m_fn1();\n+  template <typename OtherDerived, typename Dimensions>\n+  TensorContractionOp<Dimensions, Derived, const OtherDerived, int>\n+      m_fn2(OtherDerived, Dimensions);\n+  template <Index> TensorChippingOp<1, Derived> m_fn3(Index);\n+};\n+template <typename Derived, int = A::value>\n+class N : public N<Derived, ReadOnlyAccessors> {\n+public:\n+  template <typename DeviceType> C m_fn4(DeviceType);\n+};\n+template <typename, typename> struct TensorEvaluator;\n+template <typename UnaryOp, typename ArgType, typename Device>\n+struct TensorEvaluator<const D<UnaryOp, ArgType>, Device> {\n+  TensorEvaluator(D<UnaryOp, ArgType>, Device);\n+};\n+template <typename, typename> class D {\n+public:\n+  typedef typename B<D>::type Nested;\n+};\n+template <typename Indices_, typename LeftArgType_, typename RightArgType_,\n+          typename OutputKernelType_, typename Device_>\n+struct traits<\n+    TensorEvaluator<const TensorContractionOp<Indices_, LeftArgType_,\n+                                              RightArgType_, OutputKernelType_>,\n+                    Device_>> {\n+  typedef Indices_ Indices;\n+  typedef LeftArgType_ LeftArgType;\n+  typedef RightArgType_ RightArgType;\n+  typedef OutputKernelType_ OutputKernelType;\n+  typedef Device_ Device;\n+};\n+template <typename, typename LhsXprType, typename RhsXprType, typename>\n+class TensorContractionOp {\n+public:\n+  typedef typename B<TensorContractionOp>::type Nested;\n+  typename LhsXprType::Nested m_fn5();\n+  typename RhsXprType::Nested m_fn6();\n+};\n+template <typename Derived> struct TensorContractionEvaluatorBase {\n+  typedef typename traits<Derived>::LeftArgType LeftArgType;\n+  typedef typename traits<Derived>::RightArgType RightArgType;\n+  typedef typename traits<Derived>::Device Device;\n+  TensorContractionEvaluatorBase(\n+      TensorContractionOp<typename traits<Derived>::Indices, LeftArgType,\n+                          RightArgType,\n+                          typename traits<Derived>::OutputKernelType>\n+          p1,\n+      Device p2)\n+      : m_leftImpl(p1.m_fn6(), p2), m_rightImpl(p1.m_fn5(), p2) {\n+    long nocontract_idx;\n+    for (int i;; i++) {\n+      bool contracting;\n+      if (contracting) {\n+        if (nocontract_idx < K<int>::value)\n+          m_j_size = m_j_strides[nocontract_idx];\n+        nocontract_idx++;\n+      }\n+    }\n+  }\n+  array<long, 1> m_j_strides;\n+  long m_j_size;\n+  TensorEvaluator<RightArgType, Device> m_leftImpl;\n+  TensorEvaluator<LeftArgType, Device> m_rightImpl;\n+};\n+template <typename Indices, typename LeftArgType, typename RightArgType,\n+          typename OutputKernelType, typename Device>\n+struct TensorEvaluator<\n+    const TensorContractionOp<Indices, LeftArgType, RightArgType,\n+                              OutputKernelType>,\n+    Device>\n+    : TensorContractionEvaluatorBase<TensorEvaluator<\n+          const TensorContractionOp<Indices, LeftArgType, RightArgType,\n+                                    OutputKernelType>,\n+          Device>> {\n+  typedef TensorEvaluator Self;\n+  typedef TensorContractionEvaluatorBase<Self> Base;\n+  TensorEvaluator(\n+      TensorContractionOp<Indices, LeftArgType, RightArgType, OutputKernelType>\n+          p1,\n+      Device p2)\n+      : Base(p1, p2) {}\n+};\n+template <long DimId, typename XprType>\n+struct traits<TensorChippingOp<DimId, XprType>> : traits<XprType> {};\n+template <long, typename XprType>\n+class TensorChippingOp : public N<TensorChippingOp<1, XprType>> {\n+public:\n+  typedef typename B<TensorChippingOp>::type Nested;\n+};\n+template <long DimId, typename ArgType, typename Device>\n+struct TensorEvaluator<const TensorChippingOp<DimId, ArgType>, Device> {\n+  static const int NumInputDims = K<typename ArgType::Dimensions>::value;\n+  array<long, NumInputDims> m_dimensions;\n+};\n+template <long DimId, typename ArgType, typename Device>\n+struct TensorEvaluator<TensorChippingOp<DimId, ArgType>, Device>\n+    : TensorEvaluator<const TensorChippingOp<1, ArgType>, Device> {\n+  TensorEvaluator(TensorChippingOp<DimId, ArgType>, Device);\n+};\n+template <typename, typename RhsXprType> class TensorAssignOp {\n+public:\n+  TensorAssignOp(TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,\n+                 RhsXprType);\n+  TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>> m_fn7();\n+  typename RhsXprType::Nested m_fn8();\n+};\n+template <typename LeftArgType, typename RightArgType, typename Device>\n+struct TensorEvaluator<const TensorAssignOp<LeftArgType, RightArgType>,\n+                       Device> {\n+  TensorEvaluator(TensorAssignOp<LeftArgType, RightArgType> p1, Device p2)\n+      : m_leftImpl(p1.m_fn7(), p2), m_rightImpl(p1.m_fn8(), p2) {}\n+  TensorEvaluator<LeftArgType, Device> m_leftImpl;\n+  TensorEvaluator<RightArgType, Device> m_rightImpl;\n+};\n+template <typename Expression> class F {\n+public:\n+  static void m_fn9(Expression p1) {\n+    int device;\n+    TensorEvaluator<Expression, int>(p1, device);\n+  }\n+};\n+class C {\n+public:\n+  void\n+  operator=(TensorContractionOp<array<int, 1>,\n+                                TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,\n+                                const D<int, M<J<float, 3, 1, int>, 0>>, int>\n+                p1) {\n+    TensorAssignOp<\n+        TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,\n+        const TensorContractionOp<\n+            array<int, 1>, TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,\n+            const D<int, M<J<float, 3, 1, int>, 0>>, int>>\n+        assign(m_expression, p1);\n+    F<const TensorAssignOp<\n+        TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>>,\n+        const TensorContractionOp<\n+            array<int, 1>, TensorChippingOp<1, M<J<float, 3, 1, int>, 0>>,\n+            const D<int, M<J<float, 3, 1, int>, 0>>, int>>>::m_fn9(assign);\n+  }\n+  TensorChippingOp<0, const M<J<int, 3, 1, int>, 1>> m_expression;\n+};\n+template <typename, int NumIndices_, int, typename> class J {\n+public:\n+  typedef array<long, NumIndices_> Dimensions;\n+};\n+template <typename PlainObjectType, int Options_, template <class> class>\n+class M : public N<M<PlainObjectType, Options_>> {\n+public:\n+  typedef typename PlainObjectType::Dimensions Dimensions;\n+};\n+template <int NDIMS> struct TTypes {\n+  typedef M<J<float, NDIMS, RowMajor, int>, Aligned> ConstTensor;\n+};\n+class L {\n+public:\n+  template <typename, long NDIMS> typename TTypes<NDIMS>::ConstTensor m_fn10();\n+};\n+class H {\n+public:\n+  H(int *);\n+};\n+class G {\n+public:\n+  G(H *(int *));\n+};\n+int Run_d;\n+class O : H {\n+public:\n+  int BatchMatMul_context;\n+  O() : H(&BatchMatMul_context) {\n+    L out, in_y, in_x;\n+    auto Tx = in_x.m_fn10<float, 3>(), Ty = in_y.m_fn10<float, 3>(),\n+         Tz = out.m_fn10<float, 3>(), z = Tz;\n+    array<int, 1> contract_pairs;\n+    auto x = Tx.m_fn3<0>(0);\n+    auto y = Ty.m_fn1();\n+    z.m_fn4(Run_d) = x.m_fn2(y, contract_pairs);\n+  }\n+};\n+G registrar__body__0__object([](int *) -> H * { O(); return 0; });"}, {"sha": "75c6faedc1f6741b19b34c673d6943a1d9f24e8e", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 23, "deletions": 3, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/208149b7201420d965991e08cb4e4c261171b0a2/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=208149b7201420d965991e08cb4e4c261171b0a2", "patch": "@@ -3289,9 +3289,29 @@ get_constraint_for_component_ref (tree t, vec<ce_s> *results,\n       return;\n     }\n \n-  /* Pretend to take the address of the base, we'll take care of\n-     adding the required subset of sub-fields below.  */\n-  get_constraint_for_1 (t, results, true, lhs_p);\n+  /* Avoid creating pointer-offset constraints, so handle MEM_REF\n+     offsets directly.  Pretend to take the address of the base,\n+     we'll take care of adding the required subset of sub-fields below.  */\n+  if (TREE_CODE (t) == MEM_REF\n+      && !integer_zerop (TREE_OPERAND (t, 0)))\n+    {\n+      poly_offset_int off = mem_ref_offset (t);\n+      off <<= LOG2_BITS_PER_UNIT;\n+      off += bitpos;\n+      poly_int64 off_hwi;\n+      if (off.to_shwi (&off_hwi))\n+\tbitpos = off_hwi;\n+      else\n+\t{\n+\t  bitpos = 0;\n+\t  bitmaxsize = -1;\n+\t}\n+      get_constraint_for_1 (TREE_OPERAND (t, 0), results, false, lhs_p);\n+      do_deref (results);\n+    }\n+  else\n+    get_constraint_for_1 (t, results, true, lhs_p);\n+\n   /* Strip off nothing_id.  */\n   if (results->length () == 2)\n     {"}]}