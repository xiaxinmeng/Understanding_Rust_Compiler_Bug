{"sha": "3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2I2ZmE3YTVjNmU4NDQ4OWQ2YmU5MDEyMTYzYzk5MjNjYmI5YTk1Yw==", "commit": {"author": {"name": "Tobias Burnus", "email": "burnus@net-b.de", "date": "2011-08-18T15:10:25Z"}, "committer": {"name": "Tobias Burnus", "email": "burnus@gcc.gnu.org", "date": "2011-08-18T15:10:25Z"}, "message": "re PR fortran/18918 (Eventually support Fortran 2008's coarrays [co-arrays])\n\n2011-08-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * parse.c (parse_derived): Add lock_type\n        checks, improve coarray_comp handling.\n        * resolve.c (resolve_allocate_expr,\n        resolve_lock_unlock, resolve_symbol): Fix lock_type\n        constraint checks.\n\n2011-08-18  Tobias Burnus  <burnus@net-b.de>\n\n        PR fortran/18918\n        * gfortran.dg/coarray_lock_1.f90: Update dg-error.\n        * gfortran.dg/coarray_lock_3.f90: Fix test.\n        * gfortran.dg/coarray_lock_4.f90: New.\n        * gfortran.dg/coarray_lock_5.f90: New.\n\nFrom-SVN: r177867", "tree": {"sha": "8b7705adc50a1ef4dcadb26cfc780b37f96174e7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8b7705adc50a1ef4dcadb26cfc780b37f96174e7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "a1998fab44f12c5d4553e62d33b974f7ec189477", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a1998fab44f12c5d4553e62d33b974f7ec189477", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a1998fab44f12c5d4553e62d33b974f7ec189477"}], "stats": {"total": 273, "additions": 244, "deletions": 29}, "files": [{"sha": "fa92219393b5087a859460b00dab2c36391f4703", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -1,3 +1,12 @@\n+2011-08-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* parse.c (parse_derived): Add lock_type\n+\tchecks, improve coarray_comp handling.\n+\t* resolve.c (resolve_allocate_expr,\n+\tresolve_lock_unlock, resolve_symbol): Fix lock_type\n+\tconstraint checks.\n+\n 2011-08-17  Tobias Burnus  <burnus@net-b.de>\n \n \tPR fortran/31461"}, {"sha": "0aaad90fca031068c59bb054677611a1461a2ab7", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 79, "deletions": 9, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -2018,7 +2018,7 @@ parse_derived (void)\n   gfc_statement st;\n   gfc_state_data s;\n   gfc_symbol *sym;\n-  gfc_component *c;\n+  gfc_component *c, *lock_comp = NULL;\n \n   accept_statement (ST_DERIVED_DECL);\n   push_state (&s, COMP_DERIVED, gfc_new_block);\n@@ -2126,19 +2126,28 @@ parse_derived (void)\n   sym = gfc_current_block ();\n   for (c = sym->components; c; c = c->next)\n     {\n+      bool coarray, lock_type, allocatable, pointer;\n+      coarray = lock_type = allocatable = pointer = false;\n+\n       /* Look for allocatable components.  */\n       if (c->attr.allocatable\n \t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n \t      && CLASS_DATA (c)->attr.allocatable)\n \t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.alloc_comp))\n-\tsym->attr.alloc_comp = 1;\n+\t{\n+\t  allocatable = true;\n+\t  sym->attr.alloc_comp = 1;\n+\t}\n \n       /* Look for pointer components.  */\n       if (c->attr.pointer\n \t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n \t      && CLASS_DATA (c)->attr.class_pointer)\n \t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.pointer_comp))\n-\tsym->attr.pointer_comp = 1;\n+\t{\n+\t  pointer = true;\n+\t  sym->attr.pointer_comp = 1;\n+\t}\n \n       /* Look for procedure pointer components.  */\n       if (c->attr.proc_pointer\n@@ -2148,15 +2157,76 @@ parse_derived (void)\n \n       /* Looking for coarray components.  */\n       if (c->attr.codimension\n-\t  || (c->attr.coarray_comp && !c->attr.pointer && !c->attr.allocatable))\n-\tsym->attr.coarray_comp = 1;\n+\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n+\t      && CLASS_DATA (c)->attr.codimension))\n+\t{\n+\t  coarray = true;\n+\t  sym->attr.coarray_comp = 1;\n+\t}\n+     \n+      if (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.coarray_comp)\n+\t{\n+\t  coarray = true;\n+\t  if (!pointer && !allocatable)\n+\t    sym->attr.coarray_comp = 1;\n+\t}\n \n       /* Looking for lock_type components.  */\n-      if (c->attr.lock_comp\n-\t  || (sym->ts.type == BT_DERIVED\n+      if ((c->ts.type == BT_DERIVED\n \t      && c->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n-\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE))\n-\tsym->attr.lock_comp = 1;\n+\t      && c->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+\t  || (c->ts.type == BT_CLASS && c->attr.class_ok\n+\t      && CLASS_DATA (c)->ts.u.derived->from_intmod\n+\t\t == INTMOD_ISO_FORTRAN_ENV\n+\t      && CLASS_DATA (c)->ts.u.derived->intmod_sym_id\n+\t\t == ISOFORTRAN_LOCK_TYPE)\n+\t  || (c->ts.type == BT_DERIVED && c->ts.u.derived->attr.lock_comp\n+\t      && !allocatable && !pointer))\n+\t{\n+\t  lock_type = 1;\n+\t  lock_comp = c;\n+\t  sym->attr.lock_comp = 1;\n+\t}\n+\n+      /* Check for F2008, C1302 - and recall that pointers may not be coarrays\n+\t (5.3.14) and that subobjects of coarray are coarray themselves (2.4.7),\n+\t unless there are nondirect [allocatable or pointer] components\n+\t involved (cf. 1.3.33.1 and 1.3.33.3).  */\n+\n+      if (pointer && !coarray && lock_type)\n+\tgfc_error (\"Component %s at %L of type LOCK_TYPE must have a \"\n+\t\t   \"codimension or be a subcomponent of a coarray, \"\n+\t\t   \"which is not possible as the component has the \"\n+\t\t   \"pointer attribute\", c->name, &c->loc);\n+      else if (pointer && !coarray && c->ts.type == BT_DERIVED\n+\t       && c->ts.u.derived->attr.lock_comp)\n+\tgfc_error (\"Pointer component %s at %L has a noncoarray subcomponent \"\n+\t\t   \"of type LOCK_TYPE, which must have a codimension or be a \"\n+\t\t   \"subcomponent of a coarray\", c->name, &c->loc);\n+\n+      if (lock_type && allocatable && !coarray)\n+\tgfc_error (\"Allocatable component %s at %L of type LOCK_TYPE must have \"\n+\t\t   \"a codimension\", c->name, &c->loc);\n+      else if (lock_type && allocatable && c->ts.type == BT_DERIVED\n+\t       && c->ts.u.derived->attr.lock_comp)\n+\tgfc_error (\"Allocatable component %s at %L must have a codimension as \"\n+\t\t   \"it has a noncoarray subcomponent of type LOCK_TYPE\",\n+\t\t   c->name, &c->loc);\n+\n+      if (sym->attr.coarray_comp && !coarray && lock_type)\n+\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+\t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n+\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n+\t\t   \"not have a codimension as already a coarray \"\n+\t\t   \"subcomponent exists)\", c->name, &c->loc, sym->name);\n+\n+      if (sym->attr.lock_comp && coarray && !lock_type)\n+\tgfc_error (\"Noncoarray component %s at %L of type LOCK_TYPE or with \"\n+\t\t   \"subcomponent of type LOCK_TYPE must have a codimension or \"\n+\t\t   \"be a subcomponent of a coarray. (Variables of type %s may \"\n+\t\t   \"not have a codimension as %s at %L has a codimension or a \"\n+\t\t   \"coarray subcomponent)\", lock_comp->name, &lock_comp->loc,\n+\t\t   sym->name, c->name, &c->loc);\n \n       /* Look for private components.  */\n       if (sym->component_access == ACCESS_PRIVATE"}, {"sha": "53234fa5e3990f7a36fda20fa23b25cc85f7ce92", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -6806,7 +6806,7 @@ resolve_allocate_expr (gfc_expr *e, gfc_code *code)\n \n       /* Check F2008, C642.  */\n       if (code->expr3->ts.type == BT_DERIVED\n-\t  && ((codimension &&  gfc_expr_attr (code->expr3).lock_comp)\n+\t  && ((codimension && gfc_expr_attr (code->expr3).lock_comp)\n \t      || (code->expr3->ts.u.derived->from_intmod\n \t\t     == INTMOD_ISO_FORTRAN_ENV\n \t\t  && code->expr3->ts.u.derived->intmod_sym_id\n@@ -8224,10 +8224,9 @@ resolve_lock_unlock (gfc_code *code)\n       || code->expr1->ts.u.derived->from_intmod != INTMOD_ISO_FORTRAN_ENV\n       || code->expr1->ts.u.derived->intmod_sym_id != ISOFORTRAN_LOCK_TYPE\n       || code->expr1->rank != 0\n-      || !(gfc_expr_attr (code->expr1).codimension\n-\t   || gfc_is_coindexed (code->expr1)))\n-    gfc_error (\"Lock variable at %L must be a scalar coarray of type \"\n-\t       \"LOCK_TYPE\", &code->expr1->where);\n+      || (!gfc_is_coarray (code->expr1) && !gfc_is_coindexed (code->expr1)))\n+    gfc_error (\"Lock variable at %L must be a scalar of type LOCK_TYPE\",\n+\t       &code->expr1->where);\n \n   /* Check STAT.  */\n   if (code->expr2\n@@ -12221,12 +12220,14 @@ resolve_symbol (gfc_symbol *sym)\n \n   /* F2008, C1302.  */\n   if (sym->ts.type == BT_DERIVED\n-      && sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n-      && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE\n-      && !sym->attr.codimension)\n+      && ((sym->ts.u.derived->from_intmod == INTMOD_ISO_FORTRAN_ENV\n+\t   && sym->ts.u.derived->intmod_sym_id == ISOFORTRAN_LOCK_TYPE)\n+\t  || sym->ts.u.derived->attr.lock_comp)\n+      && !sym->attr.codimension && !sym->ts.u.derived->attr.coarray_comp)\n     {\n-      gfc_error (\"Variable '%s' at %L of type LOCK_TYPE must be a coarray\",\n-\t\t sym->name, &sym->declared_at);\n+      gfc_error (\"Variable %s at %L of type LOCK_TYPE or with subcomponent of \"\n+\t\t \"type LOCK_TYPE must be a coarray\", sym->name,\n+\t\t &sym->declared_at);\n       return;\n     }\n "}, {"sha": "f76a52c737d997d0e1db7fb6efe9f1b11ce29133", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -1,3 +1,11 @@\n+2011-08-18  Tobias Burnus  <burnus@net-b.de>\n+\n+\tPR fortran/18918\n+\t* gfortran.dg/coarray_lock_1.f90: Update dg-error.\n+\t* gfortran.dg/coarray_lock_3.f90: Fix test.\n+\t* gfortran.dg/coarray_lock_4.f90: New.\n+\t* gfortran.dg/coarray_lock_5.f90: New.\n+\n 2011-08-18  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR target/50009"}, {"sha": "419ba47bab1c156e2e079701d30e7d06357b7059", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_1.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_1.f90?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -10,6 +10,6 @@\n character(len=3) :: c\n logical :: bool\n \n-LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n-UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+LOCK (a, stat=s, acquired_lock=bool, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n+UNLOCK (a, stat=s, errmsg=c) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n end"}, {"sha": "958cee4c09ee0ad2c6091824fc6cd10eb981f2c7", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_3.f90", "status": "modified", "additions": 18, "deletions": 8, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_3.f90?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -19,11 +19,21 @@ module m\n   type t\n     type(lock_type), allocatable :: x(:)[:]\n   end type t\n+end module m\n \n+module m2\n+  use iso_fortran_env\n   type t2\n-    type(lock_type), allocatable :: x\n+    type(lock_type), allocatable :: x ! { dg-error \"Allocatable component x at .1. of type LOCK_TYPE must have a codimension\" }\n   end type t2\n-end module m\n+end module m2\n+\n+module m3\n+  use iso_fortran_env\n+  type t3\n+    type(lock_type) :: x ! OK\n+  end type t3\n+end module m3\n \n subroutine sub(x)\n   use iso_fortran_env\n@@ -46,15 +56,15 @@ subroutine sub3(x) ! { dg-error \"with coarray component shall be a nonpointer, n\n end subroutine sub3\n \n subroutine sub4(x)\n-  use m\n-  type(t2), intent(inout) :: x[*] ! OK\n+  use m3\n+  type(t3), intent(inout) :: x[*] ! OK\n end subroutine sub4\n \n subroutine lock_test\n   use iso_fortran_env\n   type t\n   end type t\n-  type(lock_type) :: lock ! { dg-error \"type LOCK_TYPE must be a coarray\" }\n+  type(lock_type) :: lock ! { dg-error \"of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must be a coarray\" }\n end subroutine lock_test\n \n subroutine lock_test2\n@@ -65,10 +75,10 @@ subroutine lock_test2\n   type(t) :: x\n   type(lock_type), save :: lock[*],lock2(2)[*]\n   lock(t) ! { dg-error \"Syntax error in LOCK statement\" }\n-  lock(x) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+  lock(x) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n   lock(lock)\n   lock(lock2(1))\n-  lock(lock2) ! { dg-error \"must be a scalar coarray of type LOCK_TYPE\" }\n+  lock(lock2) ! { dg-error \"must be a scalar of type LOCK_TYPE\" }\n   lock(lock[1]) ! OK\n end subroutine lock_test2\n \n@@ -104,4 +114,4 @@ subroutine test(x)\n   end subroutine test\n end subroutine argument_check\n \n-! { dg-final { cleanup-modules \"m\" } }\n+! { dg-final { cleanup-modules \"m m2 m3\" } }"}, {"sha": "787dfe042102056d6a127bee2f320c63583e0476", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_4.f90", "status": "added", "additions": 64, "deletions": 0, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_4.f90?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -0,0 +1,64 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+!\n+! LOCK/LOCK_TYPE checks \n+!\n+\n+subroutine valid()\n+  use iso_fortran_env\n+  implicit none\n+  type t\n+    type(lock_type) :: lock\n+  end type t\n+\n+  type t2\n+    type(lock_type), allocatable :: lock(:)[:]\n+  end type t2\n+\n+  type(t), save :: a[*]\n+  type(t2), save :: b ! OK\n+\n+  allocate(b%lock(1)[*])\n+  LOCK(a%lock) ! OK\n+  LOCK(a[1]%lock) ! OK\n+\n+  LOCK(b%lock(1)) ! OK\n+  LOCK(b%lock(1)[1]) ! OK\n+end subroutine valid\n+\n+subroutine invalid()\n+  use iso_fortran_env\n+  implicit none\n+  type t\n+    type(lock_type) :: lock\n+  end type t\n+  type(t), save :: a ! { dg-error \"type LOCK_TYPE or with subcomponent of type LOCK_TYPE must be a coarray\" }\n+end subroutine invalid\n+\n+subroutine more_tests\n+  use iso_fortran_env\n+  implicit none\n+  type t\n+    type(lock_type) :: a ! OK\n+  end type t\n+\n+  type t1\n+    type(lock_type), allocatable :: c2(:)[:] ! OK \n+  end type t1\n+  type(t1) :: x1 ! OK\n+\n+  type t2\n+    type(lock_type), allocatable :: c1(:) ! { dg-error \"Allocatable component c1 at .1. of type LOCK_TYPE must have a codimension\" }\n+  end type t2\n+\n+  type t3\n+    type(t) :: b\n+  end type t3\n+  type(t3) :: x3 ! { dg-error \"of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must be a coarray\" }\n+\n+  type t4\n+    type(lock_type) :: c0(2)\n+  end type t4\n+  type(t4) :: x4 ! { dg-error \"of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must be a coarray\" }\n+end subroutine more_tests"}, {"sha": "aac90279854ba6a9a0de2b8fc1c36abc4b454ca7", "filename": "gcc/testsuite/gfortran.dg/coarray_lock_5.f90", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_5.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b6fa7a5c6e84489d6be9012163c9923cbb9a95c/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_5.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fcoarray_lock_5.f90?ref=3b6fa7a5c6e84489d6be9012163c9923cbb9a95c", "patch": "@@ -0,0 +1,53 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! LOCK_TYPE checks\n+!\n+module m3\n+  use iso_fortran_env\n+  type, extends(lock_type) :: lock\n+    integer :: j = 7\n+  end type lock\n+end module m3\n+\n+use m3\n+type(lock_type) :: tl[*] = lock_type ()\n+type(lock) :: t[*]\n+tl = lock_type () ! { dg-error \"variable definition context\" }\n+print *,t%j\n+end\n+\n+subroutine test()\n+  use iso_fortran_env\n+  type t\n+    type(lock_type) :: lock\n+  end type t\n+\n+  type t2\n+    type(t), pointer :: x ! { dg-error \"Pointer component x at .1. has a noncoarray subcomponent of type LOCK_TYPE, which must have a codimension or be a subcomponent of a coarray\" }\n+  end type t2\n+end subroutine test\n+\n+subroutine test2()\n+  use iso_fortran_env\n+  implicit none\n+  type t\n+    type(lock_type), allocatable :: lock ! { dg-error \"Allocatable component lock at .1. of type LOCK_TYPE must have a codimension\" }\n+  end type t\n+  type t2\n+    type(lock_type) :: lock\n+  end type t2\n+  type t3\n+    type(t2), allocatable :: lock_cmp\n+  end type t3\n+  type t4\n+    integer, allocatable :: a[:]\n+    type(t2) :: b ! { dg-error \"Noncoarray component b at .1. of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must have a codimension or be a subcomponent of a coarray. .Variables of type t4 may not have a codimension as already a coarray subcomponent exists.\" }\n+  end type t4\n+  type t5\n+    type(t2) :: c ! { dg-error \"Noncoarray component c at .1. of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must have a codimension or be a subcomponent of a coarray. .Variables of type t5 may not have a codimension as d at .2. has a codimension or a coarray subcomponent.\" }\n+    integer, allocatable :: d[:] ! { dg-error \"Noncoarray component c at .1. of type LOCK_TYPE or with subcomponent of type LOCK_TYPE must have a codimension or be a subcomponent of a coarray. .Variables of type t5 may not have a codimension as d at .2. has a codimension or a coarray subcomponent.\" }\n+  end type t5\n+end subroutine test2\n+\n+! { dg-final { cleanup-modules \"m3\" } }"}]}