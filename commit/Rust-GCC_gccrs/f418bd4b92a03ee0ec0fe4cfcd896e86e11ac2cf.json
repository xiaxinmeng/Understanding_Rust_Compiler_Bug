{"sha": "f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjQxOGJkNGI5MmEwM2VlMGVjMGZlNGNmY2Q4OTZlODZlMTFhYzJjZg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-14T08:31:59Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2020-07-14T08:31:59Z"}, "message": "openmp: Adjust outer bounds of non-rect loops\n\nIn loops like:\n  #pragma omp parallel for collapse(2)\n  for (i = -4; i < 8; i++)\n    for (j = 3 * i; j > 2 * i; j--)\nfor some outer loop iterations there are no inner loop iterations at all,\nthe condition is false.  In order to use Summ\u00e6 Potestate to count number\nof iterations or to transform the logical iteration number to actual\niterator values using quadratic non-equation root discovery the outer\niterator range needs to be adjusted, such that the inner loop has at least\none iteration for each of the outer loop iterator value in the reduced\nrange.  Sometimes this adjustment is done at the start of the range,\nat other times at the end.\n\nThis patch implements it during the compile time number of loop computation\n(if all expressions are compile time constants).\n\n2020-07-14  Jakub Jelinek  <jakub@redhat.com>\n\n\t* omp-general.h (struct omp_for_data): Add adjn1 member.\n\t* omp-general.c (omp_extract_for_data): For non-rect loop, punt on\n\tcount computing if n1, n2 or step are not INTEGER_CST earlier.\n\tNarrow the outer iterator range if needed so that non-rect loop\n\thas at least one iteration for each outer range iteration.  Compute\n\tadjn1.\n\t* omp-expand.c (expand_omp_for_init_vars): Use adjn1 if non-NULL\n\tinstead of the outer loop's n1.\n\n\t* testsuite/libgomp.c/loop-21.c: New test.", "tree": {"sha": "17d168705338d42d8c50ed25f5ba654e5bfb8c14", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/17d168705338d42d8c50ed25f5ba654e5bfb8c14"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6a48d12475cdb7375b98277f8bc089715feeeafe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6a48d12475cdb7375b98277f8bc089715feeeafe", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6a48d12475cdb7375b98277f8bc089715feeeafe"}], "stats": {"total": 364, "additions": 360, "deletions": 4}, "files": [{"sha": "a721940a6170d82460a6d099e991984e2b08d63a", "filename": "gcc/omp-expand.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-expand.c?ref=f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "patch": "@@ -2262,6 +2262,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      && (optab_handler (sqrt_optab, TYPE_MODE (double_type_node))\n \t\t  != CODE_FOR_nothing))\n \t    {\n+\t      tree outer_n1 = fd->adjn1 ? fd->adjn1 : fd->loops[i - 1].n1;\n \t      tree itype = TREE_TYPE (fd->loops[i].v);\n \t      tree min_inner_iterations = fd->min_inner_iterations;\n \t      tree factor = fd->factor;\n@@ -2384,7 +2385,7 @@ expand_omp_for_init_vars (struct omp_for_data *fd, gimple_stmt_iterator *gsi,\n \t      *gsi = gsi_after_labels (e->dest);\n \t      t = fold_convert (itype, c);\n \t      t = fold_build2 (MULT_EXPR, itype, t, fd->loops[i - 1].step);\n-\t      t = fold_build2 (PLUS_EXPR, itype, fd->loops[i - 1].n1, t);\n+\t      t = fold_build2 (PLUS_EXPR, itype, outer_n1, t);\n \t      t = force_gimple_operand_gsi (gsi, t, true, NULL_TREE, false,\n \t\t\t\t\t    GSI_CONTINUE_LINKING);\n \t      expand_omp_build_assign (gsi, fd->loops[i - 1].v, t, true);"}, {"sha": "b2ce4083b271f2172a1b51b440be951fab207c3f", "filename": "gcc/omp-general.c", "status": "modified", "additions": 126, "deletions": 3, "changes": 129, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-general.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-general.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.c?ref=f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "patch": "@@ -214,6 +214,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n   fd->simd_schedule = false;\n   fd->min_inner_iterations = NULL_TREE;\n   fd->factor = NULL_TREE;\n+  fd->adjn1 = NULL_TREE;\n   collapse_iter = NULL;\n   collapse_count = NULL;\n \n@@ -508,7 +509,10 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t\tcontinue;\n \t      if (single_nonrect == -1\n \t\t  || (loop->m1 && TREE_CODE (loop->m1) != INTEGER_CST)\n-\t\t  || (loop->m2 && TREE_CODE (loop->m2) != INTEGER_CST))\n+\t\t  || (loop->m2 && TREE_CODE (loop->m2) != INTEGER_CST)\n+\t\t  || TREE_CODE (loop->n1) != INTEGER_CST\n+\t\t  || TREE_CODE (loop->n2) != INTEGER_CST\n+\t\t  || TREE_CODE (loop->step) != INTEGER_CST)\n \t\t{\n \t\t  count = NULL_TREE;\n \t\t  continue;\n@@ -574,12 +578,129 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t      else if (t && t2 && integer_zerop (t) && integer_zerop (t2))\n \t\t/* No iterations of the inner loop.  count will be set to\n \t\t   zero cst below.  */;\n-\t      else\n+\t      else if (TYPE_UNSIGNED (itype)\n+\t\t       || t == NULL_TREE\n+\t\t       || t2 == NULL_TREE\n+\t\t       || TREE_CODE (t) != INTEGER_CST\n+\t\t       || TREE_CODE (t2) != INTEGER_CST)\n \t\t{\n \t\t  /* Punt (for now).  */\n \t\t  count = NULL_TREE;\n \t\t  continue;\n \t\t}\n+\t      else\n+\t\t{\n+\t\t  /* Some iterations of the outer loop have zero iterations\n+\t\t     of the inner loop, while others have at least one.\n+\t\t     In this case, we need to adjust one of those outer\n+\t\t     loop bounds.  If ADJ_FIRST, we need to adjust outer n1\n+\t\t     (first), otherwise outer n2 (last).  */\n+\t\t  bool adj_first = integer_zerop (t);\n+\t\t  tree n1 = fold_convert (itype, loop->n1);\n+\t\t  tree n2 = fold_convert (itype, loop->n2);\n+\t\t  tree m1 = loop->m1 ? fold_convert (itype, loop->m1)\n+\t\t\t\t     : build_zero_cst (itype);\n+\t\t  tree m2 = loop->m2 ? fold_convert (itype, loop->m2)\n+\t\t\t\t     : build_zero_cst (itype);\n+\t\t  t = fold_binary (MINUS_EXPR, itype, n1, n2);\n+\t\t  t2 = fold_binary (MINUS_EXPR, itype, m2, m1);\n+\t\t  t = fold_binary (TRUNC_DIV_EXPR, itype, t, t2);\n+\t\t  t2 = fold_binary (MINUS_EXPR, itype, t, first);\n+\t\t  t2 = fold_binary (TRUNC_MOD_EXPR, itype, t2, ostep);\n+\t\t  t = fold_binary (MINUS_EXPR, itype, t, t2);\n+\t\t  tree n1cur\n+\t\t    = fold_binary (PLUS_EXPR, itype, n1,\n+\t\t\t\t   fold_binary (MULT_EXPR, itype, m1, t));\n+\t\t  tree n2cur\n+\t\t    = fold_binary (PLUS_EXPR, itype, n2,\n+\t\t\t\t   fold_binary (MULT_EXPR, itype, m2, t));\n+\t\t  t2 = fold_binary (loop->cond_code, boolean_type_node,\n+\t\t\t\t    n1cur, n2cur);\n+\t\t  tree t3 = fold_binary (MULT_EXPR, itype, m1, ostep);\n+\t\t  tree t4 = fold_binary (MULT_EXPR, itype, m2, ostep);\n+\t\t  tree diff;\n+\t\t  if (adj_first)\n+\t\t    {\n+\t\t      tree new_first;\n+\t\t      if (integer_nonzerop (t2))\n+\t\t\t{\n+\t\t\t  new_first = t;\n+\t\t\t  n1first = n1cur;\n+\t\t\t  n2first = n2cur;\n+\t\t\t  if (flag_checking)\n+\t\t\t    {\n+\t\t\t      t3 = fold_binary (MINUS_EXPR, itype, n1cur, t3);\n+\t\t\t      t4 = fold_binary (MINUS_EXPR, itype, n2cur, t4);\n+\t\t\t      t3 = fold_binary (loop->cond_code,\n+\t\t\t\t\t\tboolean_type_node, t3, t4);\n+\t\t\t      gcc_assert (integer_zerop (t3));\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  t3 = fold_binary (PLUS_EXPR, itype, n1cur, t3);\n+\t\t\t  t4 = fold_binary (PLUS_EXPR, itype, n2cur, t4);\n+\t\t\t  new_first = fold_binary (PLUS_EXPR, itype, t, ostep);\n+\t\t\t  n1first = t3;\n+\t\t\t  n2first = t4;\n+\t\t\t  if (flag_checking)\n+\t\t\t    {\n+\t\t\t      t3 = fold_binary (loop->cond_code,\n+\t\t\t\t\t\tboolean_type_node, t3, t4);\n+\t\t\t      gcc_assert (integer_nonzerop (t3));\n+\t\t\t    }\n+\t\t\t}\n+\t\t      diff = fold_binary (MINUS_EXPR, itype, new_first, first);\n+\t\t      first = new_first;\n+\t\t      fd->adjn1 = first;\n+\t\t    }\n+\t\t  else\n+\t\t    {\n+\t\t      tree new_last;\n+\t\t      if (integer_zerop (t2))\n+\t\t\t{\n+\t\t\t  t3 = fold_binary (MINUS_EXPR, itype, n1cur, t3);\n+\t\t\t  t4 = fold_binary (MINUS_EXPR, itype, n2cur, t4);\n+\t\t\t  new_last = fold_binary (MINUS_EXPR, itype, t, ostep);\n+\t\t\t  n1last = t3;\n+\t\t\t  n2last = t4;\n+\t\t\t  if (flag_checking)\n+\t\t\t    {\n+\t\t\t      t3 = fold_binary (loop->cond_code,\n+\t\t\t\t\t\tboolean_type_node, t3, t4);\n+\t\t\t      gcc_assert (integer_nonzerop (t3));\n+\t\t\t    }\n+\t\t\t}\n+\t\t      else\n+\t\t\t{\n+\t\t\t  new_last = t;\n+\t\t\t  n1last = n1cur;\n+\t\t\t  n2last = n2cur;\n+\t\t\t  if (flag_checking)\n+\t\t\t    {\n+\t\t\t      t3 = fold_binary (PLUS_EXPR, itype, n1cur, t3);\n+\t\t\t      t4 = fold_binary (PLUS_EXPR, itype, n2cur, t4);\n+\t\t\t      t3 = fold_binary (loop->cond_code,\n+\t\t\t\t\t\tboolean_type_node, t3, t4);\n+\t\t\t      gcc_assert (integer_zerop (t3));\n+\t\t\t    }\n+\t\t\t}\n+\t\t      diff = fold_binary (MINUS_EXPR, itype, last, new_last);\n+\t\t    }\n+\t\t  if (TYPE_UNSIGNED (itype)\n+\t\t      && single_nonrect_cond_code == GT_EXPR)\n+\t\t    diff = fold_binary (TRUNC_DIV_EXPR, itype,\n+\t\t\t\t\tfold_unary (NEGATE_EXPR, itype, diff),\n+\t\t\t\t\tfold_unary (NEGATE_EXPR, itype,\n+\t\t\t\t\t\t    ostep));\n+\t\t  else\n+\t\t    diff = fold_binary (TRUNC_DIV_EXPR, itype, diff, ostep);\n+\t\t  diff = fold_convert (long_long_unsigned_type_node, diff);\n+\t\t  single_nonrect_count\n+\t\t    = fold_binary (MINUS_EXPR, long_long_unsigned_type_node,\n+\t\t\t\t   single_nonrect_count, diff);\n+\t\t  t = NULL_TREE;\n+\t\t}\n \t    }\n \t  else\n \t    t = fold_binary (loop->cond_code, boolean_type_node,\n@@ -715,10 +836,11 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t  *collapse_count = fold_convert_loc (loc, iter_type, count);\n \t  if (fd->min_inner_iterations && fd->factor)\n \t    {\n-\t      t = make_tree_vec (3);\n+\t      t = make_tree_vec (4);\n \t      TREE_VEC_ELT (t, 0) = *collapse_count;\n \t      TREE_VEC_ELT (t, 1) = fd->min_inner_iterations;\n \t      TREE_VEC_ELT (t, 2) = fd->factor;\n+\t      TREE_VEC_ELT (t, 3) = fd->adjn1;\n \t      *collapse_count = t;\n \t    }\n \t}\n@@ -736,6 +858,7 @@ omp_extract_for_data (gomp_for *for_stmt, struct omp_for_data *fd,\n \t  gcc_assert (fd->non_rect);\n \t  fd->min_inner_iterations = TREE_VEC_ELT (fd->loop.n2, 1);\n \t  fd->factor = TREE_VEC_ELT (fd->loop.n2, 2);\n+\t  fd->adjn1 = TREE_VEC_ELT (fd->loop.n2, 3);\n \t  fd->loop.n2 = TREE_VEC_ELT (fd->loop.n2, 0);\n \t}\n       fd->loop.step = build_int_cst (TREE_TYPE (fd->loop.v), 1);"}, {"sha": "2da4d14b3102b811cdee168aead48fadbef718ff", "filename": "gcc/omp-general.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-general.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/gcc%2Fomp-general.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-general.h?ref=f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "patch": "@@ -85,6 +85,8 @@ struct omp_for_data\n \t\t\t\touter iterator, depending on which\n \t\t\t\tresults in fewer iterations.  */\n   tree factor; /* (m2 - m1) * outer_step / inner_step.  */\n+  /* Adjusted n1 of the outer loop in such loop nests (if needed).  */\n+  tree adjn1;\n };\n \n #define OACC_FN_ATTRIB \"oacc function\""}, {"sha": "1baf13d84db175ff931ff5f2f353c77c46f20b8a", "filename": "libgomp/testsuite/libgomp.c/loop-21.c", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.c%2Floop-21.c?ref=f418bd4b92a03ee0ec0fe4cfcd896e86e11ac2cf", "patch": "@@ -0,0 +1,230 @@\n+/* { dg-do run } */\n+\n+extern void abort (void);\n+\n+int x, i, j;\n+volatile int a, b, c, d, e, f, g, h;\n+int k[13][27];\n+\n+int\n+main ()\n+{\n+  int niters;\n+  for (i = -4; i < 8; i++)\n+    for (j = 3 * i; j > 2 * i; j--)\n+      k[i + 5][j + 5] = 1;\n+  a = -4; b = 8; c = 1; d = 3; e = 0; f = 2; g = 0; h = -1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = -4; i < 8; i++)\n+    for (j = 3 * i; j > 2 * i; j--)\n+      {\n+\tif (i < -4 || i >= 8 || j > 3 * i || j <= i * 2 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 8 || j != 14 || x != 7183 || niters != 28)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j > g + i * f; j += h)\n+      {\n+\tif (i < -4 || i >= 8 || j > 3 * i || j <= i * 2 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != 8 || j != 14 || x != 7183 || niters != 28)\n+    abort ();\n+  for (int i = -4; i < 8; i++)\n+    for (int j = 3 * i; j > 2 * i; j--)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  for (i = -2; i < 4; i++)\n+    for (j = -2 * i + 3; j > -3; j -= 2)\n+      k[i + 5][j + 5] = 1;\n+  a = -2; b = 4; c = 1; d = -2; e = 3; f = 0; g = -3; h = -2;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = -2; i < 4; i++)\n+    for (j = -2 * i + 3; j > -3; j -= 2)\n+      {\n+\tif (i < -2 || i >= 4 || j <= -3 || j > -2 * i + 3 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/* i != 4 || j != -3 || */x != 3071 || niters != 15)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i < b; i += c)\n+    for (j = d * i + e; j > g + i * f; j += h)\n+      {\n+\tif (i < -2 || i >= 4 || j <= -3 || j > -2 * i + 3 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != 4 || j != -3 || */x != 3071 || niters != 15)\n+    abort ();\n+  for (i = -2; i < 4; i++)\n+    for (j = -2 * i + 3; j > -3; j -= 2)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  for (i = 3; i > -3; i--)\n+    for (j = -2 * i + 7; j > 2 * i + 1; j--)\n+      k[i + 5][j + 5] = 1;\n+  a = 3; b = -3; c = -1; d = -2; e = 7; f = 2; g = 1; h = -1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 3; i > -3; i--)\n+    for (j = -2 * i + 7; j > 2 * i + 1; j--)\n+      {\n+\tif (i <= -3 || i > 3 || j <= 2 * i + 1 || j > -2 * i + 7 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != -3 || j != -3 || x != -1026 || niters != 32)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i > b; i += c)\n+    for (j = d * i + e; j > g + i * f; j += h)\n+      {\n+\tif (i <= -3 || i > 3 || j <= 2 * i + 1 || j > -2 * i + 7 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != -3 || j != -3 || x != -1026 || niters != 32)\n+    abort ();\n+  for (i = 3; i > -3; i--)\n+    for (j = -2 * i + 7; j > 2 * i + 1; j--)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  for (i = 3; i > -3; i--)\n+    for (j = 2 * i + 7; j > -2 * i + 1; j--)\n+      k[i + 5][j + 5] = 1;\n+  a = 3; b = -3; c = -1; d = 2; e = 7; f = -2; g = 1; h = -1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 3; i > -3; i--)\n+    for (j = 2 * i + 7; j > -2 * i + 1; j--)\n+      {\n+\tif (i <= -3 || i > 3 || j <= -2 * i + 1 || j > 2 * i + 7 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != -3 || j != 3 || */x != -1020 || niters != 50)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i > b; i += c)\n+    for (j = d * i + e; j > g + i * f; j += h)\n+      {\n+\tif (i <= -3 || i > 3 || j <= -2 * i + 1 || j > 2 * i + 7 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != -3 || j != 3 || */x != -1020 || niters != 50)\n+    abort ();\n+  for (i = 3; i > -3; i--)\n+    for (j = 2 * i + 7; j > -2 * i + 1; j--)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  for (i = 6; i > -6; i--)\n+    for (j = 2 * i + 7; j <= -2 * i + 1; j++)\n+      k[i + 5][j + 5] = 1;\n+  a = 6; b = -6; c = -1; d = 2; e = 7; f = -2; g = 2; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 6; i > -6; i--)\n+    for (j = 2 * i + 7; j <= -2 * i + 1; j++)\n+      {\n+\tif (i <= -6 || i > 6 || j < 2 * i + 7 || j >= -2 * i + 2 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != -6 || j != 12 || x != -5109 || niters != 36)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i > b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i <= -6 || i > 6 || j < 2 * i + 7 || j >= -2 * i + 2 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (i != -6 || j != 12 || x != -5109 || niters != 36)\n+    abort ();\n+  for (i = 6; i > -6; i--)\n+    for (j = 2 * i + 7; j <= -2 * i + 1; j++)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  for (i = 6; i > -6; i -= 2)\n+    for (j = -2 * i + 7; j <= 2 * i + 1; j++)\n+      k[i + 5][j + 5] = 1;\n+  a = 6; b = -6; c = -2; d = -2; e = 7; f = 2; g = 2; h = 1;\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = 6; i > -6; i -= 2)\n+    for (j = -2 * i + 7; j <= 2 * i + 1; j++)\n+      {\n+\tif (i <= -6 || i > 6 || j < -2 * i + 7 || j >= 2 * i + 2 || k[i + 5][j + 5] != 1)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != -6 || j != 15 || */x != 2053 || niters != 33)\n+    abort ();\n+  niters = 0; i = -100; j = -100; x = -100;\n+  #pragma omp parallel for collapse(2) lastprivate (i, j, x) reduction(+:niters)\n+  for (i = a; i > b; i += c)\n+    for (j = d * i + e; j < g + i * f; j += h)\n+      {\n+\tif (i <= -6 || i > 6 || j < -2 * i + 7 || j >= 2 * i + 2 || k[i + 5][j + 5] != 2)\n+\t  abort ();\n+\tk[i + 5][j + 5]++;\n+\tx = i * 1024 + (j & 1023);\n+\tniters++;\n+      }\n+  if (/*i != -6 || j != 15 || */x != 2053 || niters != 33)\n+    abort ();\n+  for (i = 6; i > -6; i -= 2)\n+    for (j = -2 * i + 7; j <= 2 * i + 1; j++)\n+      if (k[i + 5][j + 5] == 3)\n+\tk[i + 5][j + 5] = 0;\n+      else\n+\tabort ();\n+  return 0;\n+}"}]}