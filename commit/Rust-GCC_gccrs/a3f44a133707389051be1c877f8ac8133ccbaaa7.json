{"sha": "a3f44a133707389051be1c877f8ac8133ccbaaa7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTNmNDRhMTMzNzA3Mzg5MDUxYmUxYzg3N2Y4YWM4MTMzY2NiYWFhNw==", "commit": {"author": {"name": "Brendan Kehoe", "email": "brendan@lasher.cygnus.com", "date": "1997-10-01T16:56:13Z"}, "committer": {"name": "Brendan Kehoe", "email": "brendan@gcc.gnu.org", "date": "1997-10-01T16:56:13Z"}, "message": "lex.c (real_yylex): Clean up the code to fully behave the way the c-lex.c parser does for complex...\n\n\t* lex.c (real_yylex): Clean up the code to fully behave the way\n\tthe c-lex.c parser does for complex and real numbers.\n\nFrom-SVN: r15826", "tree": {"sha": "86ab308e5e70259d5aea987fe2371f7a19231709", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86ab308e5e70259d5aea987fe2371f7a19231709"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a3f44a133707389051be1c877f8ac8133ccbaaa7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f44a133707389051be1c877f8ac8133ccbaaa7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a3f44a133707389051be1c877f8ac8133ccbaaa7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a3f44a133707389051be1c877f8ac8133ccbaaa7/comments", "author": null, "committer": null, "parents": [{"sha": "281de624e33db467fd888e0ac4c4a8a1cad1fa73", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/281de624e33db467fd888e0ac4c4a8a1cad1fa73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/281de624e33db467fd888e0ac4c4a8a1cad1fa73"}], "stats": {"total": 55, "additions": 27, "deletions": 28}, "files": [{"sha": "5a30120827171a5e71c46af65a0babc9249cb9d0", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f44a133707389051be1c877f8ac8133ccbaaa7/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f44a133707389051be1c877f8ac8133ccbaaa7/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=a3f44a133707389051be1c877f8ac8133ccbaaa7", "patch": "@@ -1,3 +1,8 @@\n+1997-10-01  Brendan Kehoe  <brendan@lasher.cygnus.com>\n+\n+\t* lex.c (real_yylex): Clean up the code to fully behave the way\n+\tthe c-lex.c parser does for complex and real numbers.\n+\n Tue Sep 30 08:51:36 1997  Jason Merrill  <jason@yorick.cygnus.com>\n \n \t* method.c (build_decl_overload_real): Reformat."}, {"sha": "d1b7d699aaa86f08eea854f2f4c0504f3476322a", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 22, "deletions": 28, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a3f44a133707389051be1c877f8ac8133ccbaaa7/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a3f44a133707389051be1c877f8ac8133ccbaaa7/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=a3f44a133707389051be1c877f8ac8133ccbaaa7", "patch": "@@ -3805,17 +3805,14 @@ real_yylex ()\n \t    yylval.ttype = build_int_2 (low, high);\n \t    TREE_TYPE (yylval.ttype) = long_long_unsigned_type_node;\n \n+\t    /* Calculate the ANSI type.  */\n \t    if (!spec_long && !spec_unsigned\n \t\t&& int_fits_type_p (yylval.ttype, integer_type_node))\n-\t      {\n-\t\ttype = integer_type_node;\n-\t      }\n+\t      type = integer_type_node;\n \t    else if (!spec_long && (base != 10 || spec_unsigned)\n \t\t     && int_fits_type_p (yylval.ttype, unsigned_type_node))\n-\t      {\n-\t\t/* Nondecimal constants try unsigned even in traditional C.  */\n-\t\ttype = unsigned_type_node;\n-\t      }\n+\t      /* Nondecimal constants try unsigned even in traditional C.  */\n+\t      type = unsigned_type_node;\n \t    else if (!spec_unsigned && !spec_long_long\n \t\t     && int_fits_type_p (yylval.ttype, long_integer_type_node))\n \t      type = long_integer_type_node;\n@@ -3827,31 +3824,28 @@ real_yylex ()\n \t\t     && int_fits_type_p (yylval.ttype,\n \t\t\t\t\t long_long_integer_type_node))\n \t      type = long_long_integer_type_node;\n-\t    else if (int_fits_type_p (yylval.ttype,\n-\t\t\t\t      long_long_unsigned_type_node))\n+\t    else\n \t      type = long_long_unsigned_type_node;\n \n-\t    else\n-\t      {\n-\t\ttype = long_long_integer_type_node;\n-\t\twarning (\"integer constant out of range\");\n+\t    if (!int_fits_type_p (yylval.ttype, type) && !warn)\n+\t      pedwarn (\"integer constant out of range\");\n \n-\t\tif (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n-\t\t  warning (\"decimal integer constant is so large that it is unsigned\");\n-\t\tif (spec_imag)\n-\t\t  {\n-\t\t    if (TYPE_PRECISION (type)\n-\t\t\t<= TYPE_PRECISION (integer_type_node))\n-\t\t      yylval.ttype\n-\t\t\t= build_complex (NULL_TREE, integer_zero_node,\n-\t\t\t\t\t cp_convert (integer_type_node,\n-\t\t\t\t\t\t     yylval.ttype));\n-\t\t    else\n-\t\t      error (\"complex integer constant is too wide for `__complex int'\");\n-\t\t  }\n-\t      }\n+\t    if (base == 10 && ! spec_unsigned && TREE_UNSIGNED (type))\n+\t      warning (\"decimal integer constant is so large that it is unsigned\");\n \n-\t    TREE_TYPE (yylval.ttype) = type;\n+\t    if (spec_imag)\n+\t      {\n+\t\tif (TYPE_PRECISION (type)\n+\t\t    <= TYPE_PRECISION (integer_type_node))\n+\t\t  yylval.ttype\n+\t\t    = build_complex (NULL_TREE, integer_zero_node,\n+\t\t\t\t     cp_convert (integer_type_node,\n+\t\t\t\t\t\t yylval.ttype));\n+\t\telse\n+\t\t  error (\"complex integer constant is too wide for `__complex int'\");\n+\t      }\n+\t    else\n+\t      TREE_TYPE (yylval.ttype) = type;\n \t  }\n \n \tput_back (c);"}]}