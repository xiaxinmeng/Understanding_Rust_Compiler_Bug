{"sha": "bffb8014d0566af64c3cd5c7afac21c125a14df2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmZmYjgwMTRkMDU2NmFmNjRjM2NkNWM3YWZhYzIxYzEyNWExNGRmMg==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-31T14:23:29Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-31T14:23:29Z"}, "message": "[20/46] Make *FIRST_ELEMENT and *NEXT_ELEMENT stmt_vec_infos\n\nThis patch changes {REDUC,DR}_GROUP_{FIRST,NEXT} element from a\ngimple stmt to stmt_vec_info.\n\n2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* tree-vectorizer.h (_stmt_vec_info::first_element): Change from\n\ta gimple stmt to a stmt_vec_info.\n\t(_stmt_vec_info::next_element): Likewise.\n\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel)\n\t(vect_slp_analyze_and_verify_node_alignment)\n\t(vect_analyze_group_access_1, vect_analyze_group_access)\n\t(vect_small_gap_p, vect_prune_runtime_alias_test_list)\n\t(vect_create_data_ref_ptr, vect_record_grouped_load_vectors)\n\t(vect_supportable_dr_alignment): Update accordingly.\n\t* tree-vect-loop.c (vect_fixup_reduc_chain): Likewise.\n\t(vect_fixup_scalar_cycles_with_patterns, vect_is_slp_reduction)\n\t(vect_is_simple_reduction, vectorizable_reduction): Likewise.\n\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Likewise.\n\t* tree-vect-slp.c (vect_build_slp_tree_1)\n\t(vect_attempt_slp_rearrange_stmts, vect_supported_load_permutation_p)\n\t(vect_split_slp_store_group, vect_analyze_slp_instance)\n\t(vect_analyze_slp, vect_transform_slp_perm_load): Likewise.\n\t* tree-vect-stmts.c (vect_model_store_cost, vect_model_load_cost)\n\t(get_group_load_store_type, get_load_store_type)\n\t(get_group_alias_ptr_type, vectorizable_store, vectorizable_load)\n\t(vect_transform_stmt, vect_remove_stores): Likewise.\n\nFrom-SVN: r263135", "tree": {"sha": "1a875c5d43b72c10cf6aae018cb86f8a28eef983", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1a875c5d43b72c10cf6aae018cb86f8a28eef983"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bffb8014d0566af64c3cd5c7afac21c125a14df2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffb8014d0566af64c3cd5c7afac21c125a14df2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bffb8014d0566af64c3cd5c7afac21c125a14df2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bffb8014d0566af64c3cd5c7afac21c125a14df2/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "78e02b3bbb00fc898c550b88161838eb5dd95806", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78e02b3bbb00fc898c550b88161838eb5dd95806", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78e02b3bbb00fc898c550b88161838eb5dd95806"}], "stats": {"total": 446, "additions": 227, "deletions": 219}, "files": [{"sha": "7d62f29a525aa5e152e8f72313d2b9f5c34e84bf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -1,3 +1,27 @@\n+2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* tree-vectorizer.h (_stmt_vec_info::first_element): Change from\n+\ta gimple stmt to a stmt_vec_info.\n+\t(_stmt_vec_info::next_element): Likewise.\n+\t* tree-vect-data-refs.c (vect_update_misalignment_for_peel)\n+\t(vect_slp_analyze_and_verify_node_alignment)\n+\t(vect_analyze_group_access_1, vect_analyze_group_access)\n+\t(vect_small_gap_p, vect_prune_runtime_alias_test_list)\n+\t(vect_create_data_ref_ptr, vect_record_grouped_load_vectors)\n+\t(vect_supportable_dr_alignment): Update accordingly.\n+\t* tree-vect-loop.c (vect_fixup_reduc_chain): Likewise.\n+\t(vect_fixup_scalar_cycles_with_patterns, vect_is_slp_reduction)\n+\t(vect_is_simple_reduction, vectorizable_reduction): Likewise.\n+\t* tree-vect-patterns.c (vect_reassociating_reduction_p): Likewise.\n+\t* tree-vect-slp.c (vect_build_slp_tree_1)\n+\t(vect_attempt_slp_rearrange_stmts, vect_supported_load_permutation_p)\n+\t(vect_split_slp_store_group, vect_analyze_slp_instance)\n+\t(vect_analyze_slp, vect_transform_slp_perm_load): Likewise.\n+\t* tree-vect-stmts.c (vect_model_store_cost, vect_model_load_cost)\n+\t(get_group_load_store_type, get_load_store_type)\n+\t(get_group_alias_ptr_type, vectorizable_store, vectorizable_load)\n+\t(vect_transform_stmt, vect_remove_stores): Likewise.\n+\n 2018-07-31  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vectorizer.h (vect_dr_stmt): Return a stmt_vec_info rather"}, {"sha": "14a1a8fea25c6fa59dcc44f4327b2341705f32b2", "filename": "gcc/tree-vect-data-refs.c", "status": "modified", "additions": 52, "deletions": 60, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-data-refs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-data-refs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-data-refs.c?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -1077,7 +1077,7 @@ vect_update_misalignment_for_peel (struct data_reference *dr,\n  /* For interleaved data accesses the step in the loop must be multiplied by\n      the size of the interleaving group.  */\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    dr_size *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info)));\n+    dr_size *= DR_GROUP_SIZE (DR_GROUP_FIRST_ELEMENT (stmt_info));\n   if (STMT_VINFO_GROUPED_ACCESS (peel_stmt_info))\n     dr_peel_size *= DR_GROUP_SIZE (peel_stmt_info);\n \n@@ -2370,12 +2370,11 @@ vect_slp_analyze_and_verify_node_alignment (slp_tree node)\n      the node is permuted in which case we start from the first\n      element in the group.  */\n   stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-  gimple *first_stmt = first_stmt_info->stmt;\n   data_reference_p first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n   if (SLP_TREE_LOAD_PERMUTATION (node).exists ())\n-    first_stmt = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n+    first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n \n-  data_reference_p dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+  data_reference_p dr = STMT_VINFO_DATA_REF (first_stmt_info);\n   vect_compute_data_ref_alignment (dr);\n   /* For creating the data-ref pointer we need alignment of the\n      first element anyway.  */\n@@ -2520,11 +2519,11 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n   if (DR_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info)\n     {\n       /* First stmt in the interleaving chain. Check the chain.  */\n-      gimple *next = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+      stmt_vec_info next = DR_GROUP_NEXT_ELEMENT (stmt_info);\n       struct data_reference *data_ref = dr;\n       unsigned int count = 1;\n       tree prev_init = DR_INIT (data_ref);\n-      gimple *prev = stmt_info;\n+      stmt_vec_info prev = stmt_info;\n       HOST_WIDE_INT diff, gaps = 0;\n \n       /* By construction, all group members have INTEGER_CST DR_INITs.  */\n@@ -2535,8 +2534,7 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n              stmt, and the rest get their vectorized loads from the first\n              one.  */\n           if (!tree_int_cst_compare (DR_INIT (data_ref),\n-                                     DR_INIT (STMT_VINFO_DATA_REF (\n-\t\t\t\t\t\t   vinfo_for_stmt (next)))))\n+\t\t\t\t     DR_INIT (STMT_VINFO_DATA_REF (next))))\n             {\n               if (DR_IS_WRITE (data_ref))\n                 {\n@@ -2550,16 +2548,16 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \t\tdump_printf_loc (MSG_MISSED_OPTIMIZATION, vect_location,\n \t\t\t\t \"Two or more load stmts share the same dr.\\n\");\n \n-              /* For load use the same data-ref load.  */\n-              DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next)) = prev;\n+\t      /* For load use the same data-ref load.  */\n+\t      DR_GROUP_SAME_DR_STMT (next) = prev;\n \n-              prev = next;\n-              next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n-              continue;\n+\t      prev = next;\n+\t      next = DR_GROUP_NEXT_ELEMENT (next);\n+\t      continue;\n             }\n \n-          prev = next;\n-          data_ref = STMT_VINFO_DATA_REF (vinfo_for_stmt (next));\n+\t  prev = next;\n+\t  data_ref = STMT_VINFO_DATA_REF (next);\n \n \t  /* All group members have the same STEP by construction.  */\n \t  gcc_checking_assert (operand_equal_p (DR_STEP (data_ref), step, 0));\n@@ -2587,12 +2585,12 @@ vect_analyze_group_access_1 (struct data_reference *dr)\n \n           /* Store the gap from the previous member of the group. If there is no\n              gap in the access, DR_GROUP_GAP is always 1.  */\n-          DR_GROUP_GAP (vinfo_for_stmt (next)) = diff;\n+\t  DR_GROUP_GAP (next) = diff;\n \n-          prev_init = DR_INIT (data_ref);\n-          next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n-          /* Count the number of data-refs in the chain.  */\n-          count++;\n+\t  prev_init = DR_INIT (data_ref);\n+\t  next = DR_GROUP_NEXT_ELEMENT (next);\n+\t  /* Count the number of data-refs in the chain.  */\n+\t  count++;\n         }\n \n       if (groupsize == 0)\n@@ -2668,15 +2666,13 @@ vect_analyze_group_access (struct data_reference *dr)\n   if (!vect_analyze_group_access_1 (dr))\n     {\n       /* Dissolve the group if present.  */\n-      gimple *next;\n-      gimple *stmt = DR_GROUP_FIRST_ELEMENT (vect_dr_stmt (dr));\n-      while (stmt)\n+      stmt_vec_info stmt_info = DR_GROUP_FIRST_ELEMENT (vect_dr_stmt (dr));\n+      while (stmt_info)\n \t{\n-\t  stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n-\t  next = DR_GROUP_NEXT_ELEMENT (vinfo);\n-\t  DR_GROUP_FIRST_ELEMENT (vinfo) = NULL;\n-\t  DR_GROUP_NEXT_ELEMENT (vinfo) = NULL;\n-\t  stmt = next;\n+\t  stmt_vec_info next = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+\t  DR_GROUP_FIRST_ELEMENT (stmt_info) = NULL;\n+\t  DR_GROUP_NEXT_ELEMENT (stmt_info) = NULL;\n+\t  stmt_info = next;\n \t}\n       return false;\n     }\n@@ -3281,7 +3277,7 @@ vect_small_gap_p (loop_vec_info loop_vinfo, data_reference *dr, poly_int64 gap)\n   HOST_WIDE_INT count\n     = estimated_poly_value (LOOP_VINFO_VECT_FACTOR (loop_vinfo));\n   if (DR_GROUP_FIRST_ELEMENT (stmt_info))\n-    count *= DR_GROUP_SIZE (vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info)));\n+    count *= DR_GROUP_SIZE (DR_GROUP_FIRST_ELEMENT (stmt_info));\n   return estimated_poly_value (gap) <= count * vect_get_scalar_dr_size (dr);\n }\n \n@@ -3379,11 +3375,9 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n       int comp_res;\n       poly_uint64 lower_bound;\n       struct data_reference *dr_a, *dr_b;\n-      gimple *dr_group_first_a, *dr_group_first_b;\n       tree segment_length_a, segment_length_b;\n       unsigned HOST_WIDE_INT access_size_a, access_size_b;\n       unsigned int align_a, align_b;\n-      gimple *stmt_a, *stmt_b;\n \n       /* Ignore the alias if the VF we chose ended up being no greater\n \t than the dependence distance.  */\n@@ -3409,15 +3403,15 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t}\n \n       dr_a = DDR_A (ddr);\n-      stmt_a = vect_dr_stmt (DDR_A (ddr));\n+      stmt_vec_info stmt_info_a = vect_dr_stmt (DDR_A (ddr));\n \n       dr_b = DDR_B (ddr);\n-      stmt_b = vect_dr_stmt (DDR_B (ddr));\n+      stmt_vec_info stmt_info_b = vect_dr_stmt (DDR_B (ddr));\n \n       /* Skip the pair if inter-iteration dependencies are irrelevant\n \t and intra-iteration dependencies are guaranteed to be honored.  */\n       if (ignore_step_p\n-\t  && (vect_preserves_scalar_order_p (stmt_a, stmt_b)\n+\t  && (vect_preserves_scalar_order_p (stmt_info_a, stmt_info_b)\n \t      || vectorizable_with_step_bound_p (dr_a, dr_b, &lower_bound)))\n \t{\n \t  if (dump_enabled_p ())\n@@ -3468,18 +3462,18 @@ vect_prune_runtime_alias_test_list (loop_vec_info loop_vinfo)\n \t  continue;\n \t}\n \n-      dr_group_first_a = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_a));\n+      stmt_vec_info dr_group_first_a = DR_GROUP_FIRST_ELEMENT (stmt_info_a);\n       if (dr_group_first_a)\n \t{\n-\t  stmt_a = dr_group_first_a;\n-\t  dr_a = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_a));\n+\t  stmt_info_a = dr_group_first_a;\n+\t  dr_a = STMT_VINFO_DATA_REF (stmt_info_a);\n \t}\n \n-      dr_group_first_b = DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt_b));\n+      stmt_vec_info dr_group_first_b = DR_GROUP_FIRST_ELEMENT (stmt_info_b);\n       if (dr_group_first_b)\n \t{\n-\t  stmt_b = dr_group_first_b;\n-\t  dr_b = STMT_VINFO_DATA_REF (vinfo_for_stmt (stmt_b));\n+\t  stmt_info_b = dr_group_first_b;\n+\t  dr_b = STMT_VINFO_DATA_REF (stmt_info_b);\n \t}\n \n       if (ignore_step_p)\n@@ -4734,20 +4728,19 @@ vect_create_data_ref_ptr (gimple *stmt, tree aggr_type, struct loop *at_loop,\n   /* Likewise for any of the data references in the stmt group.  */\n   else if (DR_GROUP_SIZE (stmt_info) > 1)\n     {\n-      gimple *orig_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      stmt_vec_info sinfo = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       do\n \t{\n-\t  stmt_vec_info sinfo = vinfo_for_stmt (orig_stmt);\n \t  struct data_reference *sdr = STMT_VINFO_DATA_REF (sinfo);\n \t  if (!alias_sets_conflict_p (get_alias_set (aggr_type),\n \t\t\t\t      get_alias_set (DR_REF (sdr))))\n \t    {\n \t      need_ref_all = true;\n \t      break;\n \t    }\n-\t  orig_stmt = DR_GROUP_NEXT_ELEMENT (sinfo);\n+\t  sinfo = DR_GROUP_NEXT_ELEMENT (sinfo);\n \t}\n-      while (orig_stmt);\n+      while (sinfo);\n     }\n   aggr_ptr_type = build_pointer_type_for_mode (aggr_type, ptr_mode,\n \t\t\t\t\t       need_ref_all);\n@@ -6345,19 +6338,18 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n {\n   stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n   vec_info *vinfo = stmt_info->vinfo;\n-  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-  gimple *next_stmt;\n+  stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n   unsigned int i, gap_count;\n   tree tmp_data_ref;\n \n   /* Put a permuted data-ref in the VECTORIZED_STMT field.\n      Since we scan the chain starting from it's first node, their order\n      corresponds the order of data-refs in RESULT_CHAIN.  */\n-  next_stmt = first_stmt;\n+  stmt_vec_info next_stmt_info = first_stmt_info;\n   gap_count = 1;\n   FOR_EACH_VEC_ELT (result_chain, i, tmp_data_ref)\n     {\n-      if (!next_stmt)\n+      if (!next_stmt_info)\n \tbreak;\n \n       /* Skip the gaps.  Loads created for the gaps will be removed by dead\n@@ -6366,27 +6358,27 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n        DR_GROUP_GAP is the number of steps in elements from the previous\n        access (if there is no gap DR_GROUP_GAP is 1).  We skip loads that\n        correspond to the gaps.  */\n-      if (next_stmt != first_stmt\n-          && gap_count < DR_GROUP_GAP (vinfo_for_stmt (next_stmt)))\n+      if (next_stmt_info != first_stmt_info\n+\t  && gap_count < DR_GROUP_GAP (next_stmt_info))\n       {\n         gap_count++;\n         continue;\n       }\n \n-      while (next_stmt)\n+      while (next_stmt_info)\n         {\n \t  stmt_vec_info new_stmt_info = vinfo->lookup_def (tmp_data_ref);\n \t  /* We assume that if VEC_STMT is not NULL, this is a case of multiple\n \t     copies, and we put the new vector statement in the first available\n \t     RELATED_STMT.  */\n-\t  if (!STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)))\n-\t    STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt)) = new_stmt_info;\n+\t  if (!STMT_VINFO_VEC_STMT (next_stmt_info))\n+\t    STMT_VINFO_VEC_STMT (next_stmt_info) = new_stmt_info;\n \t  else\n             {\n-              if (!DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+\t      if (!DR_GROUP_SAME_DR_STMT (next_stmt_info))\n                 {\n \t\t  stmt_vec_info prev_stmt_info\n-\t\t    = STMT_VINFO_VEC_STMT (vinfo_for_stmt (next_stmt));\n+\t\t    = STMT_VINFO_VEC_STMT (next_stmt_info);\n \t\t  stmt_vec_info rel_stmt_info\n \t\t    = STMT_VINFO_RELATED_STMT (prev_stmt_info);\n \t\t  while (rel_stmt_info)\n@@ -6399,12 +6391,12 @@ vect_record_grouped_load_vectors (gimple *stmt, vec<tree> result_chain)\n                 }\n             }\n \n-\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t  gap_count = 1;\n-\t  /* If NEXT_STMT accesses the same DR as the previous statement,\n+\t  /* If NEXT_STMT_INFO accesses the same DR as the previous statement,\n \t     put the same TMP_DATA_REF as its vectorized statement; otherwise\n \t     get the next data-ref from RESULT_CHAIN.  */\n-\t  if (!next_stmt || !DR_GROUP_SAME_DR_STMT (vinfo_for_stmt (next_stmt)))\n+\t  if (!next_stmt_info || !DR_GROUP_SAME_DR_STMT (next_stmt_info))\n \t    break;\n         }\n     }\n@@ -6545,8 +6537,8 @@ vect_supportable_dr_alignment (struct data_reference *dr,\n \t  if (loop_vinfo\n \t      && STMT_SLP_TYPE (stmt_info)\n \t      && !multiple_p (LOOP_VINFO_VECT_FACTOR (loop_vinfo)\n-\t\t\t      * DR_GROUP_SIZE (vinfo_for_stmt\n-\t\t\t\t\t    (DR_GROUP_FIRST_ELEMENT (stmt_info))),\n+\t\t\t      * (DR_GROUP_SIZE\n+\t\t\t\t (DR_GROUP_FIRST_ELEMENT (stmt_info))),\n \t\t\t      TYPE_VECTOR_SUBPARTS (vectype)))\n \t    ;\n \t  else if (!loop_vinfo"}, {"sha": "0b5631b78d3d2db4d11e1764c12c62e363f8a169", "filename": "gcc/tree-vect-loop.c", "status": "modified", "additions": 30, "deletions": 27, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-loop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-loop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-loop.c?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -661,14 +661,14 @@ vect_fixup_reduc_chain (gimple *stmt)\n   REDUC_GROUP_SIZE (firstp) = REDUC_GROUP_SIZE (stmt_info);\n   do\n     {\n-      stmtp = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n+      stmtp = STMT_VINFO_RELATED_STMT (stmt_info);\n       REDUC_GROUP_FIRST_ELEMENT (stmtp) = firstp;\n-      stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n-      if (stmt)\n+      stmt_info = REDUC_GROUP_NEXT_ELEMENT (stmt_info);\n+      if (stmt_info)\n \tREDUC_GROUP_NEXT_ELEMENT (stmtp)\n-\t  = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt));\n+\t  = STMT_VINFO_RELATED_STMT (stmt_info);\n     }\n-  while (stmt);\n+  while (stmt_info);\n   STMT_VINFO_DEF_TYPE (stmtp) = vect_reduction_def;\n }\n \n@@ -683,12 +683,12 @@ vect_fixup_scalar_cycles_with_patterns (loop_vec_info loop_vinfo)\n   FOR_EACH_VEC_ELT (LOOP_VINFO_REDUCTION_CHAINS (loop_vinfo), i, first)\n     if (STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (first)))\n       {\n-\tgimple *next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n+\tstmt_vec_info next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n \twhile (next)\n \t  {\n-\t    if (! STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (next)))\n+\t    if (! STMT_VINFO_IN_PATTERN_P (next))\n \t      break;\n-\t    next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+\t    next = REDUC_GROUP_NEXT_ELEMENT (next);\n \t  }\n \t/* If not all stmt in the chain are patterns try to handle\n \t   the chain without patterns.  */\n@@ -2188,7 +2188,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       vinfo = SLP_TREE_SCALAR_STMTS (SLP_INSTANCE_TREE (instance))[0];\n       if (! STMT_VINFO_GROUPED_ACCESS (vinfo))\n \tcontinue;\n-      vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n+      vinfo = DR_GROUP_FIRST_ELEMENT (vinfo);\n       unsigned int size = DR_GROUP_SIZE (vinfo);\n       tree vectype = STMT_VINFO_VECTYPE (vinfo);\n       if (! vect_store_lanes_supported (vectype, size, false)\n@@ -2198,7 +2198,7 @@ vect_analyze_loop_2 (loop_vec_info loop_vinfo, bool &fatal, unsigned *n_stmts)\n       FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (instance), j, node)\n \t{\n \t  vinfo = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t  vinfo = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (vinfo));\n+\t  vinfo = DR_GROUP_FIRST_ELEMENT (vinfo);\n \t  bool single_element_p = !DR_GROUP_NEXT_ELEMENT (vinfo);\n \t  size = DR_GROUP_SIZE (vinfo);\n \t  vectype = STMT_VINFO_VECTYPE (vinfo);\n@@ -2527,7 +2527,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n   struct loop *loop = (gimple_bb (phi))->loop_father;\n   struct loop *vect_loop = LOOP_VINFO_LOOP (loop_info);\n   enum tree_code code;\n-  gimple *loop_use_stmt = NULL, *first, *next_stmt;\n+  gimple *loop_use_stmt = NULL;\n   stmt_vec_info use_stmt_info, current_stmt_info = NULL;\n   tree lhs;\n   imm_use_iterator imm_iter;\n@@ -2592,12 +2592,12 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n       use_stmt_info = loop_info->lookup_stmt (loop_use_stmt);\n       if (current_stmt_info)\n         {\n-\t  REDUC_GROUP_NEXT_ELEMENT (current_stmt_info) = loop_use_stmt;\n+\t  REDUC_GROUP_NEXT_ELEMENT (current_stmt_info) = use_stmt_info;\n           REDUC_GROUP_FIRST_ELEMENT (use_stmt_info)\n             = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n         }\n       else\n-\tREDUC_GROUP_FIRST_ELEMENT (use_stmt_info) = loop_use_stmt;\n+\tREDUC_GROUP_FIRST_ELEMENT (use_stmt_info) = use_stmt_info;\n \n       lhs = gimple_assign_lhs (loop_use_stmt);\n       current_stmt_info = use_stmt_info;\n@@ -2610,9 +2610,10 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n   /* Swap the operands, if needed, to make the reduction operand be the second\n      operand.  */\n   lhs = PHI_RESULT (phi);\n-  next_stmt = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n-  while (next_stmt)\n+  stmt_vec_info next_stmt_info = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n+  while (next_stmt_info)\n     {\n+      gassign *next_stmt = as_a <gassign *> (next_stmt_info->stmt);\n       if (gimple_assign_rhs2 (next_stmt) == lhs)\n \t{\n \t  tree op = gimple_assign_rhs1 (next_stmt);\n@@ -2626,7 +2627,7 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n \t      && vect_valid_reduction_input_p (def_stmt_info))\n \t    {\n \t      lhs = gimple_assign_lhs (next_stmt);\n-\t      next_stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t      next_stmt_info = REDUC_GROUP_NEXT_ELEMENT (next_stmt_info);\n  \t      continue;\n \t    }\n \n@@ -2663,13 +2664,14 @@ vect_is_slp_reduction (loop_vec_info loop_info, gimple *phi,\n         }\n \n       lhs = gimple_assign_lhs (next_stmt);\n-      next_stmt = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+      next_stmt_info = REDUC_GROUP_NEXT_ELEMENT (next_stmt_info);\n     }\n \n   /* Save the chain for further analysis in SLP detection.  */\n-  first = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n-  LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (first);\n-  REDUC_GROUP_SIZE (vinfo_for_stmt (first)) = size;\n+  stmt_vec_info first_stmt_info\n+    = REDUC_GROUP_FIRST_ELEMENT (current_stmt_info);\n+  LOOP_VINFO_REDUCTION_CHAINS (loop_info).safe_push (first_stmt_info);\n+  REDUC_GROUP_SIZE (first_stmt_info) = size;\n \n   return true;\n }\n@@ -3254,12 +3256,12 @@ vect_is_simple_reduction (loop_vec_info loop_info, stmt_vec_info phi_info,\n     }\n \n   /* Dissolve group eventually half-built by vect_is_slp_reduction.  */\n-  gimple *first = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n+  stmt_vec_info first = REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (def_stmt));\n   while (first)\n     {\n-      gimple *next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first));\n-      REDUC_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first)) = NULL;\n-      REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first)) = NULL;\n+      stmt_vec_info next = REDUC_GROUP_NEXT_ELEMENT (first);\n+      REDUC_GROUP_FIRST_ELEMENT (first) = NULL;\n+      REDUC_GROUP_NEXT_ELEMENT (first) = NULL;\n       first = next;\n     }\n \n@@ -6130,7 +6132,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   if (REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n-    gcc_assert (slp_node && REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt);\n+    gcc_assert (slp_node\n+\t\t&& REDUC_GROUP_FIRST_ELEMENT (stmt_info) == stmt_info);\n \n   if (gimple_code (stmt) == GIMPLE_PHI)\n     {\n@@ -6784,8 +6787,8 @@ vectorizable_reduction (gimple *stmt, gimple_stmt_iterator *gsi,\n   tree neutral_op = NULL_TREE;\n   if (slp_node)\n     neutral_op = neutral_op_for_slp_reduction\n-\t\t   (slp_node_instance->reduc_phis, code,\n-\t\t    REDUC_GROUP_FIRST_ELEMENT (stmt_info) != NULL);\n+      (slp_node_instance->reduc_phis, code,\n+       REDUC_GROUP_FIRST_ELEMENT (stmt_info) != NULL_STMT_VEC_INFO);\n \n   if (double_reduc && reduction_type == FOLD_LEFT_REDUCTION)\n     {"}, {"sha": "d5cf851626741a7860a20733121f3571e32775a9", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -820,7 +820,7 @@ vect_reassociating_reduction_p (stmt_vec_info stmt_vinfo)\n {\n   return (STMT_VINFO_DEF_TYPE (stmt_vinfo) == vect_reduction_def\n \t  ? STMT_VINFO_REDUC_TYPE (stmt_vinfo) != FOLD_LEFT_REDUCTION\n-\t  : REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL);\n+\t  : REDUC_GROUP_FIRST_ELEMENT (stmt_vinfo) != NULL_STMT_VEC_INFO);\n }\n \n /* As above, but also require it to have code CODE and to be a reduction"}, {"sha": "665ee4f7395f5d15d9c684547096e93ee7130128", "filename": "gcc/tree-vect-slp.c", "status": "modified", "additions": 32, "deletions": 42, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-slp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-slp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-slp.c?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -712,7 +712,7 @@ vect_build_slp_tree_1 (vec_info *vinfo, unsigned char *swap,\n   int icode;\n   machine_mode optab_op2_mode;\n   machine_mode vec_mode;\n-  gimple *first_load = NULL, *prev_first_load = NULL;\n+  stmt_vec_info first_load = NULL, prev_first_load = NULL;\n \n   /* For every stmt in NODE find its def stmt/s.  */\n   stmt_vec_info stmt_info;\n@@ -1692,8 +1692,7 @@ vect_attempt_slp_rearrange_stmts (slp_instance slp_instn)\n   FOR_EACH_VEC_ELT (SLP_INSTANCE_LOADS (slp_instn), i, node)\n     {\n       stmt_vec_info first_stmt_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-      first_stmt_info\n-\t= vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (first_stmt_info));\n+      first_stmt_info = DR_GROUP_FIRST_ELEMENT (first_stmt_info);\n       /* But we have to keep those permutations that are required because\n          of handling of gaps.  */\n       if (known_eq (unrolling_factor, 1U)\n@@ -1717,7 +1716,6 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n   unsigned int group_size = SLP_INSTANCE_GROUP_SIZE (slp_instn);\n   unsigned int i, j, k, next;\n   slp_tree node;\n-  gimple *next_load;\n \n   if (dump_enabled_p ())\n     {\n@@ -1766,26 +1764,25 @@ vect_supported_load_permutation_p (slp_instance slp_instn)\n \t  if (!SLP_TREE_LOAD_PERMUTATION (node).exists ())\n \t    continue;\n \t  bool subchain_p = true;\n-          next_load = NULL;\n+\t  stmt_vec_info next_load_info = NULL;\n \t  stmt_vec_info load_info;\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (node), j, load_info)\n \t    {\n \t      if (j != 0\n-\t\t  && (next_load != load_info\n+\t\t  && (next_load_info != load_info\n \t\t      || DR_GROUP_GAP (load_info) != 1))\n \t\t{\n \t\t  subchain_p = false;\n \t\t  break;\n \t\t}\n-\t      next_load = DR_GROUP_NEXT_ELEMENT (load_info);\n+\t      next_load_info = DR_GROUP_NEXT_ELEMENT (load_info);\n \t    }\n \t  if (subchain_p)\n \t    SLP_TREE_LOAD_PERMUTATION (node).release ();\n \t  else\n \t    {\n \t      stmt_vec_info group_info = SLP_TREE_SCALAR_STMTS (node)[0];\n-\t      group_info\n-\t\t= vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (group_info));\n+\t      group_info = DR_GROUP_FIRST_ELEMENT (group_info);\n \t      unsigned HOST_WIDE_INT nunits;\n \t      unsigned k, maxk = 0;\n \t      FOR_EACH_VEC_ELT (SLP_TREE_LOAD_PERMUTATION (node), j, k)\n@@ -1868,33 +1865,33 @@ static gimple *\n vect_split_slp_store_group (gimple *first_stmt, unsigned group1_size)\n {\n   stmt_vec_info first_vinfo = vinfo_for_stmt (first_stmt);\n-  gcc_assert (DR_GROUP_FIRST_ELEMENT (first_vinfo) == first_stmt);\n+  gcc_assert (DR_GROUP_FIRST_ELEMENT (first_vinfo) == first_vinfo);\n   gcc_assert (group1_size > 0);\n   int group2_size = DR_GROUP_SIZE (first_vinfo) - group1_size;\n   gcc_assert (group2_size > 0);\n   DR_GROUP_SIZE (first_vinfo) = group1_size;\n \n-  gimple *stmt = first_stmt;\n+  stmt_vec_info stmt_info = first_vinfo;\n   for (unsigned i = group1_size; i > 1; i--)\n     {\n-      stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n-      gcc_assert (DR_GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+      stmt_info = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+      gcc_assert (DR_GROUP_GAP (stmt_info) == 1);\n     }\n   /* STMT is now the last element of the first group.  */\n-  gimple *group2 = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt));\n-  DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)) = 0;\n+  stmt_vec_info group2 = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+  DR_GROUP_NEXT_ELEMENT (stmt_info) = 0;\n \n-  DR_GROUP_SIZE (vinfo_for_stmt (group2)) = group2_size;\n-  for (stmt = group2; stmt; stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (stmt)))\n+  DR_GROUP_SIZE (group2) = group2_size;\n+  for (stmt_info = group2; stmt_info;\n+       stmt_info = DR_GROUP_NEXT_ELEMENT (stmt_info))\n     {\n-      DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (stmt)) = group2;\n-      gcc_assert (DR_GROUP_GAP (vinfo_for_stmt (stmt)) == 1);\n+      DR_GROUP_FIRST_ELEMENT (stmt_info) = group2;\n+      gcc_assert (DR_GROUP_GAP (stmt_info) == 1);\n     }\n \n   /* For the second group, the DR_GROUP_GAP is that before the original group,\n      plus skipping over the first vector.  */\n-  DR_GROUP_GAP (vinfo_for_stmt (group2))\n-    = DR_GROUP_GAP (first_vinfo) + group1_size;\n+  DR_GROUP_GAP (group2) = DR_GROUP_GAP (first_vinfo) + group1_size;\n \n   /* DR_GROUP_GAP of the first group now has to skip over the second group too.  */\n   DR_GROUP_GAP (first_vinfo) += group2_size;\n@@ -1928,8 +1925,6 @@ vect_analyze_slp_instance (vec_info *vinfo,\n   slp_tree node;\n   unsigned int group_size;\n   tree vectype, scalar_type = NULL_TREE;\n-  gimple *next;\n-  stmt_vec_info next_info;\n   unsigned int i;\n   vec<slp_tree> loads;\n   struct data_reference *dr = STMT_VINFO_DATA_REF (stmt_info);\n@@ -1970,34 +1965,32 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \n   /* Create a node (a root of the SLP tree) for the packed grouped stores.  */\n   scalar_stmts.create (group_size);\n-  next = stmt;\n+  stmt_vec_info next_info = stmt_info;\n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     {\n       /* Collect the stores and store them in SLP_TREE_SCALAR_STMTS.  */\n-      while (next)\n+      while (next_info)\n         {\n-\t  next_info = vinfo_for_stmt (next);\n \t  if (STMT_VINFO_IN_PATTERN_P (next_info)\n \t      && STMT_VINFO_RELATED_STMT (next_info))\n \t    scalar_stmts.safe_push (STMT_VINFO_RELATED_STMT (next_info));\n \t  else\n \t    scalar_stmts.safe_push (next_info);\n-          next = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+\t  next_info = DR_GROUP_NEXT_ELEMENT (next_info);\n         }\n     }\n   else if (!dr && REDUC_GROUP_FIRST_ELEMENT (stmt_info))\n     {\n       /* Collect the reduction stmts and store them in\n \t SLP_TREE_SCALAR_STMTS.  */\n-      while (next)\n+      while (next_info)\n         {\n-\t  next_info = vinfo_for_stmt (next);\n \t  if (STMT_VINFO_IN_PATTERN_P (next_info)\n \t      && STMT_VINFO_RELATED_STMT (next_info))\n \t    scalar_stmts.safe_push (STMT_VINFO_RELATED_STMT (next_info));\n \t  else\n \t    scalar_stmts.safe_push (next_info);\n-          next = REDUC_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next));\n+\t  next_info = REDUC_GROUP_NEXT_ELEMENT (next_info);\n         }\n       /* Mark the first element of the reduction chain as reduction to properly\n \t transform the node.  In the reduction analysis phase only the last\n@@ -2067,15 +2060,14 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  vec<unsigned> load_permutation;\n \t  int j;\n \t  stmt_vec_info load_info;\n-\t  gimple *first_stmt;\n \t  bool this_load_permuted = false;\n \t  load_permutation.create (group_size);\n-\t  first_stmt = DR_GROUP_FIRST_ELEMENT\n+\t  stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT\n \t    (SLP_TREE_SCALAR_STMTS (load_node)[0]);\n \t  FOR_EACH_VEC_ELT (SLP_TREE_SCALAR_STMTS (load_node), j, load_info)\n \t    {\n \t      int load_place = vect_get_place_in_interleaving_chain\n-\t\t(load_info, first_stmt);\n+\t\t(load_info, first_stmt_info);\n \t      gcc_assert (load_place != -1);\n \t      if (load_place != j)\n \t\tthis_load_permuted = true;\n@@ -2086,8 +2078,8 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t         a gap either because the group is larger than the SLP\n \t\t group-size or because there is a gap between the groups.  */\n \t      && (known_eq (unrolling_factor, 1U)\n-\t\t  || (group_size == DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n-\t\t      && DR_GROUP_GAP (vinfo_for_stmt (first_stmt)) == 0)))\n+\t\t  || (group_size == DR_GROUP_SIZE (first_stmt_info)\n+\t\t      && DR_GROUP_GAP (first_stmt_info) == 0)))\n \t    {\n \t      load_permutation.release ();\n \t      continue;\n@@ -2122,11 +2114,9 @@ vect_analyze_slp_instance (vec_info *vinfo,\n \t  slp_tree load_node;\n \t  FOR_EACH_VEC_ELT (loads, i, load_node)\n \t    {\n-\t      gimple *first_stmt = DR_GROUP_FIRST_ELEMENT\n+\t      stmt_vec_info stmt_vinfo = DR_GROUP_FIRST_ELEMENT\n \t\t(SLP_TREE_SCALAR_STMTS (load_node)[0]);\n-\t      stmt_vec_info stmt_vinfo = vinfo_for_stmt (first_stmt);\n-\t\t  /* Use SLP for strided accesses (or if we\n-\t\t     can't load-lanes).  */\n+\t      /* Use SLP for strided accesses (or if we can't load-lanes).  */\n \t      if (STMT_VINFO_STRIDED_P (stmt_vinfo)\n \t\t  || ! vect_load_lanes_supported\n \t\t\t(STMT_VINFO_VECTYPE (stmt_vinfo),\n@@ -2230,11 +2220,11 @@ vect_analyze_slp (vec_info *vinfo, unsigned max_tree_size)\n \t\t\t\t\t     max_tree_size))\n \t      {\n \t\t/* Dissolve reduction chain group.  */\n-\t\tgimple *next, *stmt = first_element;\n+\t\tgimple *stmt = first_element;\n \t\twhile (stmt)\n \t\t  {\n \t\t    stmt_vec_info vinfo = vinfo_for_stmt (stmt);\n-\t\t    next = REDUC_GROUP_NEXT_ELEMENT (vinfo);\n+\t\t    stmt_vec_info next = REDUC_GROUP_NEXT_ELEMENT (vinfo);\n \t\t    REDUC_GROUP_FIRST_ELEMENT (vinfo) = NULL;\n \t\t    REDUC_GROUP_NEXT_ELEMENT (vinfo) = NULL;\n \t\t    stmt = next;\n@@ -3698,7 +3688,7 @@ vect_transform_slp_perm_load (slp_tree node, vec<tree> dr_chain,\n   if (!STMT_VINFO_GROUPED_ACCESS (stmt_info))\n     return false;\n \n-  stmt_info = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info));\n+  stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   mode = TYPE_MODE (vectype);\n "}, {"sha": "257ab076b349bbfc34d69cd41a0101e0940d6e80", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 86, "deletions": 87, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -978,7 +978,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n \t\t       stmt_vector_for_cost *cost_vec)\n {\n   unsigned int inside_cost = 0, prologue_cost = 0;\n-  gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n+  stmt_vec_info first_stmt_info = stmt_info;\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n   /* ???  Somehow we need to fix this at the callers.  */\n@@ -998,12 +998,12 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n   /* Grouped stores update all elements in the group at once,\n      so we want the DR for the first statement.  */\n   if (!slp_node && grouped_access_p)\n-    first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+    first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   /* True if we should include any once-per-group costs as well as\n      the cost of the statement itself.  For SLP we only get called\n      once per group anyhow.  */\n-  bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n+  bool first_stmt_p = (first_stmt_info == stmt_info);\n \n   /* We assume that the cost of a single store-lanes instruction is\n      equivalent to the cost of DR_GROUP_SIZE separate stores.  If a grouped\n@@ -1014,7 +1014,7 @@ vect_model_store_cost (stmt_vec_info stmt_info, int ncopies,\n     {\n       /* Uses a high and low interleave or shuffle operations for each\n \t needed permute.  */\n-      int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      int group_size = DR_GROUP_SIZE (first_stmt_info);\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost = record_stmt_cost (cost_vec, nstmts, vec_perm,\n \t\t\t\t      stmt_info, 0, vect_body);\n@@ -1122,7 +1122,6 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n \t\t      slp_tree slp_node,\n \t\t      stmt_vector_for_cost *cost_vec)\n {\n-  gimple *first_stmt = STMT_VINFO_STMT (stmt_info);\n   unsigned int inside_cost = 0, prologue_cost = 0;\n   bool grouped_access_p = STMT_VINFO_GROUPED_ACCESS (stmt_info);\n \n@@ -1136,28 +1135,27 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n     {\n       /* If the load is permuted then the alignment is determined by\n \t the first group element not by the first scalar stmt DR.  */\n-      gimple *stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+      stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n       /* Record the cost for the permutation.  */\n       unsigned n_perms;\n       unsigned assumed_nunits\n-\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (stmt_info));\n+\t= vect_nunits_for_cost (STMT_VINFO_VECTYPE (first_stmt_info));\n       unsigned slp_vf = (ncopies * assumed_nunits) / instance->group_size; \n       vect_transform_slp_perm_load (slp_node, vNULL, NULL,\n \t\t\t\t    slp_vf, instance, true,\n \t\t\t\t    &n_perms);\n       inside_cost += record_stmt_cost (cost_vec, n_perms, vec_perm,\n-\t\t\t\t       stmt_info, 0, vect_body);\n+\t\t\t\t       first_stmt_info, 0, vect_body);\n       /* And adjust the number of loads performed.  This handles\n \t redundancies as well as loads that are later dead.  */\n-      auto_sbitmap perm (DR_GROUP_SIZE (stmt_info));\n+      auto_sbitmap perm (DR_GROUP_SIZE (first_stmt_info));\n       bitmap_clear (perm);\n       for (unsigned i = 0;\n \t   i < SLP_TREE_LOAD_PERMUTATION (slp_node).length (); ++i)\n \tbitmap_set_bit (perm, SLP_TREE_LOAD_PERMUTATION (slp_node)[i]);\n       ncopies = 0;\n       bool load_seen = false;\n-      for (unsigned i = 0; i < DR_GROUP_SIZE (stmt_info); ++i)\n+      for (unsigned i = 0; i < DR_GROUP_SIZE (first_stmt_info); ++i)\n \t{\n \t  if (i % assumed_nunits == 0)\n \t    {\n@@ -1171,19 +1169,21 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n       if (load_seen)\n \tncopies++;\n       gcc_assert (ncopies\n-\t\t  <= (DR_GROUP_SIZE (stmt_info) - DR_GROUP_GAP (stmt_info)\n+\t\t  <= (DR_GROUP_SIZE (first_stmt_info)\n+\t\t      - DR_GROUP_GAP (first_stmt_info)\n \t\t      + assumed_nunits - 1) / assumed_nunits);\n     }\n \n   /* Grouped loads read all elements in the group at once,\n      so we want the DR for the first statement.  */\n+  stmt_vec_info first_stmt_info = stmt_info;\n   if (!slp_node && grouped_access_p)\n-    first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+    first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \n   /* True if we should include any once-per-group costs as well as\n      the cost of the statement itself.  For SLP we only get called\n      once per group anyhow.  */\n-  bool first_stmt_p = (first_stmt == STMT_VINFO_STMT (stmt_info));\n+  bool first_stmt_p = (first_stmt_info == stmt_info);\n \n   /* We assume that the cost of a single load-lanes instruction is\n      equivalent to the cost of DR_GROUP_SIZE separate loads.  If a grouped\n@@ -1194,7 +1194,7 @@ vect_model_load_cost (stmt_vec_info stmt_info, unsigned ncopies,\n     {\n       /* Uses an even and odd extract operations or shuffle operations\n \t for each needed permute.  */\n-      int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      int group_size = DR_GROUP_SIZE (first_stmt_info);\n       int nstmts = ncopies * ceil_log2 (group_size) * group_size;\n       inside_cost += record_stmt_cost (cost_vec, nstmts, vec_perm,\n \t\t\t\t       stmt_info, 0, vect_body);\n@@ -2183,12 +2183,12 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n   vec_info *vinfo = stmt_info->vinfo;\n   loop_vec_info loop_vinfo = STMT_VINFO_LOOP_VINFO (stmt_info);\n   struct loop *loop = loop_vinfo ? LOOP_VINFO_LOOP (loop_vinfo) : NULL;\n-  gimple *first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-  data_reference *first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  unsigned int group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-  bool single_element_p = (stmt == first_stmt\n+  stmt_vec_info first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+  data_reference *first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n+  unsigned int group_size = DR_GROUP_SIZE (first_stmt_info);\n+  bool single_element_p = (stmt_info == first_stmt_info\n \t\t\t   && !DR_GROUP_NEXT_ELEMENT (stmt_info));\n-  unsigned HOST_WIDE_INT gap = DR_GROUP_GAP (vinfo_for_stmt (first_stmt));\n+  unsigned HOST_WIDE_INT gap = DR_GROUP_GAP (first_stmt_info);\n   poly_uint64 nunits = TYPE_VECTOR_SUBPARTS (vectype);\n \n   /* True if the vectorized statements would access beyond the last\n@@ -2315,14 +2315,14 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t*memory_access_type = VMAT_GATHER_SCATTER;\n     }\n \n-  if (vls_type != VLS_LOAD && first_stmt == stmt)\n+  if (vls_type != VLS_LOAD && first_stmt_info == stmt_info)\n     {\n       /* STMT is the leader of the group. Check the operands of all the\n \t stmts of the group.  */\n-      gimple *next_stmt = DR_GROUP_NEXT_ELEMENT (stmt_info);\n-      while (next_stmt)\n+      stmt_vec_info next_stmt_info = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+      while (next_stmt_info)\n \t{\n-\t  tree op = vect_get_store_rhs (next_stmt);\n+\t  tree op = vect_get_store_rhs (next_stmt_info);\n \t  enum vect_def_type dt;\n \t  if (!vect_is_simple_use (op, vinfo, &dt))\n \t    {\n@@ -2331,7 +2331,7 @@ get_group_load_store_type (gimple *stmt, tree vectype, bool slp,\n \t\t\t\t \"use not simple.\\n\");\n \t      return false;\n \t    }\n-\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t}\n     }\n \n@@ -2482,7 +2482,7 @@ get_load_store_type (gimple *stmt, tree vectype, bool slp, bool masked_p,\n      traditional behavior until that can be fixed.  */\n   if (*memory_access_type == VMAT_ELEMENTWISE\n       && !STMT_VINFO_STRIDED_P (stmt_info)\n-      && !(stmt == DR_GROUP_FIRST_ELEMENT (stmt_info)\n+      && !(stmt_info == DR_GROUP_FIRST_ELEMENT (stmt_info)\n \t   && !DR_GROUP_NEXT_ELEMENT (stmt_info)\n \t   && !pow2p_hwi (DR_GROUP_SIZE (stmt_info))))\n     {\n@@ -6195,13 +6195,13 @@ static tree\n get_group_alias_ptr_type (gimple *first_stmt)\n {\n   struct data_reference *first_dr, *next_dr;\n-  gimple *next_stmt;\n \n   first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n-  while (next_stmt)\n+  stmt_vec_info next_stmt_info\n+    = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (first_stmt));\n+  while (next_stmt_info)\n     {\n-      next_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (next_stmt));\n+      next_dr = STMT_VINFO_DATA_REF (next_stmt_info);\n       if (get_alias_set (DR_REF (first_dr))\n \t  != get_alias_set (DR_REF (next_dr)))\n \t{\n@@ -6210,7 +6210,7 @@ get_group_alias_ptr_type (gimple *first_stmt)\n \t\t\t     \"conflicting alias set types.\\n\");\n \t  return ptr_type_node;\n \t}\n-      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+      next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n     }\n   return reference_alias_ptr_type (DR_REF (first_dr));\n }\n@@ -6248,7 +6248,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n   gimple *ptr_incr = NULL;\n   int ncopies;\n   int j;\n-  gimple *next_stmt, *first_stmt;\n+  stmt_vec_info first_stmt_info;\n   bool grouped_store;\n   unsigned int group_size, i;\n   vec<tree> oprnds = vNULL;\n@@ -6400,13 +6400,13 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t   && (slp || memory_access_type != VMAT_CONTIGUOUS));\n   if (grouped_store)\n     {\n-      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n+      group_size = DR_GROUP_SIZE (first_stmt_info);\n     }\n   else\n     {\n-      first_stmt = stmt;\n+      first_stmt_info = stmt_info;\n       first_dr = dr;\n       group_size = vec_num = 1;\n     }\n@@ -6584,10 +6584,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n     }\n \n   if (STMT_VINFO_GROUPED_ACCESS (stmt_info))\n-    {\n-      gimple *group_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      DR_GROUP_STORE_COUNT (vinfo_for_stmt (group_stmt))++;\n-    }\n+    DR_GROUP_STORE_COUNT (DR_GROUP_FIRST_ELEMENT (stmt_info))++;\n \n   if (grouped_store)\n     {\n@@ -6596,8 +6593,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       /* We vectorize all the stmts of the interleaving group when we\n \t reach the last stmt in the group.  */\n-      if (DR_GROUP_STORE_COUNT (vinfo_for_stmt (first_stmt))\n-\t  < DR_GROUP_SIZE (vinfo_for_stmt (first_stmt))\n+      if (DR_GROUP_STORE_COUNT (first_stmt_info)\n+\t  < DR_GROUP_SIZE (first_stmt_info)\n \t  && !slp)\n \t{\n \t  *vec_stmt = NULL;\n@@ -6610,17 +6607,18 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n           /* VEC_NUM is the number of vect stmts to be created for this \n              group.  */\n           vec_num = SLP_TREE_NUMBER_OF_VEC_STMTS (slp_node);\n-          first_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0]; \n-\t  gcc_assert (DR_GROUP_FIRST_ELEMENT (vinfo_for_stmt (first_stmt)) == first_stmt);\n-          first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n-\t  op = vect_get_store_rhs (first_stmt);\n+\t  first_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+\t  gcc_assert (DR_GROUP_FIRST_ELEMENT (first_stmt_info)\n+\t\t      == first_stmt_info);\n+\t  first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n+\t  op = vect_get_store_rhs (first_stmt_info);\n         } \n       else\n         /* VEC_NUM is the number of vect stmts to be created for this \n            group.  */\n \tvec_num = group_size;\n \n-      ref_type = get_group_alias_ptr_type (first_stmt);\n+      ref_type = get_group_alias_ptr_type (first_stmt_info);\n     }\n   else\n     ref_type = reference_alias_ptr_type (DR_REF (first_dr));\n@@ -6759,7 +6757,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       prev_stmt_info = NULL;\n       alias_off = build_int_cst (ref_type, 0);\n-      next_stmt = first_stmt;\n+      stmt_vec_info next_stmt_info = first_stmt_info;\n       for (g = 0; g < group_size; g++)\n \t{\n \t  running_off = offvar;\n@@ -6780,7 +6778,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  for (j = 0; j < ncopies; j++)\n \t    {\n \t      /* We've set op and dt above, from vect_get_store_rhs,\n-\t\t and first_stmt == stmt.  */\n+\t\t and first_stmt_info == stmt_info.  */\n \t      if (j == 0)\n \t\t{\n \t\t  if (slp)\n@@ -6791,8 +6789,9 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t  else\n \t\t    {\n-\t\t      op = vect_get_store_rhs (next_stmt);\n-\t\t      vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt);\n+\t\t      op = vect_get_store_rhs (next_stmt_info);\n+\t\t      vec_oprnd = vect_get_vec_def_for_operand\n+\t\t\t(op, next_stmt_info);\n \t\t    }\n \t\t}\n \t      else\n@@ -6866,7 +6865,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    }\n \t\t}\n \t    }\n-\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t  if (slp)\n \t    break;\n \t}\n@@ -6985,19 +6984,20 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \n \t\t If the store is not grouped, DR_GROUP_SIZE is 1, and DR_CHAIN and\n \t\t OPRNDS are of size 1.  */\n-\t      next_stmt = first_stmt;\n+\t      stmt_vec_info next_stmt_info = first_stmt_info;\n \t      for (i = 0; i < group_size; i++)\n \t\t{\n \t\t  /* Since gaps are not supported for interleaved stores,\n \t\t     DR_GROUP_SIZE is the exact number of stmts in the chain.\n-\t\t     Therefore, NEXT_STMT can't be NULL_TREE.  In case that\n-\t\t     there is no interleaving, DR_GROUP_SIZE is 1, and only one\n-\t\t     iteration of the loop will be executed.  */\n-\t\t  op = vect_get_store_rhs (next_stmt);\n-\t\t  vec_oprnd = vect_get_vec_def_for_operand (op, next_stmt);\n+\t\t     Therefore, NEXT_STMT_INFO can't be NULL_TREE.  In case\n+\t\t     that there is no interleaving, DR_GROUP_SIZE is 1,\n+\t\t     and only one iteration of the loop will be executed.  */\n+\t\t  op = vect_get_store_rhs (next_stmt_info);\n+\t\t  vec_oprnd = vect_get_vec_def_for_operand\n+\t\t    (op, next_stmt_info);\n \t\t  dr_chain.quick_push (vec_oprnd);\n \t\t  oprnds.quick_push (vec_oprnd);\n-\t\t  next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n+\t\t  next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n \t\t}\n \t      if (mask)\n \t\tvec_mask = vect_get_vec_def_for_operand (mask, stmt,\n@@ -7029,7 +7029,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    dataref_ptr\n-\t      = vect_create_data_ref_ptr (first_stmt, aggr_type,\n+\t      = vect_create_data_ref_ptr (first_stmt_info, aggr_type,\n \t\t\t\t\t  simd_lane_access_p ? loop : NULL,\n \t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n \t\t\t\t\t  simd_lane_access_p, &inv_p,\n@@ -7132,7 +7132,7 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t\t\t\t&result_chain);\n \t    }\n \n-\t  next_stmt = first_stmt;\n+\t  stmt_vec_info next_stmt_info = first_stmt_info;\n \t  for (i = 0; i < vec_num; i++)\n \t    {\n \t      unsigned align, misalign;\n@@ -7249,8 +7249,8 @@ vectorizable_store (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      if (slp)\n \t\tcontinue;\n \n-\t      next_stmt = DR_GROUP_NEXT_ELEMENT (vinfo_for_stmt (next_stmt));\n-\t      if (!next_stmt)\n+\t      next_stmt_info = DR_GROUP_NEXT_ELEMENT (next_stmt_info);\n+\t      if (!next_stmt_info)\n \t\tbreak;\n \t    }\n \t}\n@@ -7423,7 +7423,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n   gphi *phi = NULL;\n   vec<tree> dr_chain = vNULL;\n   bool grouped_load = false;\n-  gimple *first_stmt;\n+  stmt_vec_info first_stmt_info;\n   stmt_vec_info first_stmt_info_for_drptr = NULL;\n   bool inv_p;\n   bool compute_in_loop = false;\n@@ -7565,8 +7565,8 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n       gcc_assert (!nested_in_vect_loop);\n       gcc_assert (!STMT_VINFO_GATHER_SCATTER_P (stmt_info));\n \n-      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      group_size = DR_GROUP_SIZE (first_stmt_info);\n \n       if (slp && SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n \tslp_perm = true;\n@@ -7696,25 +7696,26 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \n       if (grouped_load)\n \t{\n-\t  first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-\t  first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+\t  first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+\t  first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n \t}\n       else\n \t{\n-\t  first_stmt = stmt;\n+\t  first_stmt_info = stmt_info;\n \t  first_dr = dr;\n \t}\n       if (slp && grouped_load)\n \t{\n-\t  group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n-\t  ref_type = get_group_alias_ptr_type (first_stmt);\n+\t  group_size = DR_GROUP_SIZE (first_stmt_info);\n+\t  ref_type = get_group_alias_ptr_type (first_stmt_info);\n \t}\n       else\n \t{\n \t  if (grouped_load)\n \t    cst_offset\n \t      = (tree_to_uhwi (TYPE_SIZE_UNIT (TREE_TYPE (vectype)))\n-\t\t * vect_get_place_in_interleaving_chain (stmt, first_stmt));\n+\t\t * vect_get_place_in_interleaving_chain (stmt,\n+\t\t\t\t\t\t\t first_stmt_info));\n \t  group_size = 1;\n \t  ref_type = reference_alias_ptr_type (DR_REF (dr));\n \t}\n@@ -7924,19 +7925,19 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \n   if (grouped_load)\n     {\n-      first_stmt = DR_GROUP_FIRST_ELEMENT (stmt_info);\n-      group_size = DR_GROUP_SIZE (vinfo_for_stmt (first_stmt));\n+      first_stmt_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n+      group_size = DR_GROUP_SIZE (first_stmt_info);\n       /* For SLP vectorization we directly vectorize a subchain\n          without permutation.  */\n       if (slp && ! SLP_TREE_LOAD_PERMUTATION (slp_node).exists ())\n-\tfirst_stmt = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n+\tfirst_stmt_info = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n       /* For BB vectorization always use the first stmt to base\n \t the data ref pointer on.  */\n       if (bb_vinfo)\n \tfirst_stmt_info_for_drptr = SLP_TREE_SCALAR_STMTS (slp_node)[0];\n \n       /* Check if the chain of loads is already vectorized.  */\n-      if (STMT_VINFO_VEC_STMT (vinfo_for_stmt (first_stmt))\n+      if (STMT_VINFO_VEC_STMT (first_stmt_info)\n \t  /* For SLP we would need to copy over SLP_TREE_VEC_STMTS.\n \t     ???  But we can only do so if there is exactly one\n \t     as we have no way to get at the rest.  Leave the CSE\n@@ -7950,7 +7951,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  *vec_stmt = STMT_VINFO_VEC_STMT (stmt_info);\n \t  return true;\n \t}\n-      first_dr = STMT_VINFO_DATA_REF (vinfo_for_stmt (first_stmt));\n+      first_dr = STMT_VINFO_DATA_REF (first_stmt_info);\n       group_gap_adj = 0;\n \n       /* VEC_NUM is the number of vect stmts to be created for this group.  */\n@@ -7979,11 +7980,11 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n       else\n \tvec_num = group_size;\n \n-      ref_type = get_group_alias_ptr_type (first_stmt);\n+      ref_type = get_group_alias_ptr_type (first_stmt_info);\n     }\n   else\n     {\n-      first_stmt = stmt;\n+      first_stmt_info = stmt_info;\n       first_dr = dr;\n       group_size = vec_num = 1;\n       group_gap_adj = 0;\n@@ -8120,7 +8121,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n        || alignment_support_scheme == dr_explicit_realign)\n       && !compute_in_loop)\n     {\n-      msq = vect_setup_realignment (first_stmt, gsi, &realignment_token,\n+      msq = vect_setup_realignment (first_stmt_info, gsi, &realignment_token,\n \t\t\t\t    alignment_support_scheme, NULL_TREE,\n \t\t\t\t    &at_loop);\n       if (alignment_support_scheme == dr_explicit_realign_optimized)\n@@ -8184,7 +8185,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t      inv_p = false;\n \t    }\n \t  else if (first_stmt_info_for_drptr\n-\t\t   && first_stmt != first_stmt_info_for_drptr)\n+\t\t   && first_stmt_info != first_stmt_info_for_drptr)\n \t    {\n \t      dataref_ptr\n \t\t= vect_create_data_ref_ptr (first_stmt_info_for_drptr,\n@@ -8209,7 +8210,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t    }\n \t  else\n \t    dataref_ptr\n-\t      = vect_create_data_ref_ptr (first_stmt, aggr_type, at_loop,\n+\t      = vect_create_data_ref_ptr (first_stmt_info, aggr_type, at_loop,\n \t\t\t\t\t  offset, &dummy, gsi, &ptr_incr,\n \t\t\t\t\t  simd_lane_access_p, &inv_p,\n \t\t\t\t\t  byte_offset, bump);\n@@ -8388,7 +8389,7 @@ vectorizable_load (gimple *stmt, gimple_stmt_iterator *gsi,\n \t\t    tree vs = size_int (TYPE_VECTOR_SUBPARTS (vectype));\n \n \t\t    if (compute_in_loop)\n-\t\t      msq = vect_setup_realignment (first_stmt, gsi,\n+\t\t      msq = vect_setup_realignment (first_stmt_info, gsi,\n \t\t\t\t\t\t    &realignment_token,\n \t\t\t\t\t\t    dr_explicit_realign,\n \t\t\t\t\t\t    dataref_ptr, NULL);\n@@ -9708,8 +9709,7 @@ vect_transform_stmt (gimple *stmt, gimple_stmt_iterator *gsi,\n \t     one are skipped, and there vec_stmt_info shouldn't be freed\n \t     meanwhile.  */\n \t  *grouped_store = true;\n-\t  stmt_vec_info group_info\n-\t    = vinfo_for_stmt (DR_GROUP_FIRST_ELEMENT (stmt_info));\n+\t  stmt_vec_info group_info = DR_GROUP_FIRST_ELEMENT (stmt_info);\n \t  if (DR_GROUP_STORE_COUNT (group_info) == DR_GROUP_SIZE (group_info))\n \t    is_store = true;\n \t}\n@@ -9817,14 +9817,13 @@ void\n vect_remove_stores (gimple *first_stmt)\n {\n   gimple *next = first_stmt;\n-  gimple *tmp;\n   gimple_stmt_iterator next_si;\n \n   while (next)\n     {\n       stmt_vec_info stmt_info = vinfo_for_stmt (next);\n \n-      tmp = DR_GROUP_NEXT_ELEMENT (stmt_info);\n+      stmt_vec_info tmp = DR_GROUP_NEXT_ELEMENT (stmt_info);\n       if (is_pattern_stmt_p (stmt_info))\n \tnext = STMT_VINFO_RELATED_STMT (stmt_info);\n       /* Free the attached stmt_vec_info and remove the stmt.  */"}, {"sha": "fe49843aa66e820ee8b7142ff9215250f774f403", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bffb8014d0566af64c3cd5c7afac21c125a14df2/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=bffb8014d0566af64c3cd5c7afac21c125a14df2", "patch": "@@ -871,9 +871,9 @@ struct _stmt_vec_info {\n \n   /* Interleaving and reduction chains info.  */\n   /* First element in the group.  */\n-  gimple *first_element;\n+  stmt_vec_info first_element;\n   /* Pointer to the next element in the group.  */\n-  gimple *next_element;\n+  stmt_vec_info next_element;\n   /* For data-refs, in case that two or more stmts share data-ref, this is the\n      pointer to the previously detected stmt with the same dr.  */\n   gimple *same_dr_stmt;"}]}