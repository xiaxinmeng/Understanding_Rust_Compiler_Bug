{"sha": "6245e3dfd1f55063f4bea59d6a4b3618e26d915b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjI0NWUzZGZkMWY1NTA2M2Y0YmVhNTlkNmE0YjM2MThlMjZkOTE1Yg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-17T00:32:42Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1996-03-17T00:32:42Z"}, "message": "(alpha_tp, alpha_fprm, alpha_fptm): New variables.\n\n(alpha_tp_string, alpha_fprm_string, alpha_fptm_string\n(trap_pending): Likewise.\n(override_options, summarize_insn, final_prescan_insn): New functions.\n(print_operand): Handle cases '&', '\\'', ')', and '+'.\n(output_prolog): Emit \".eflag 48\" if TARGET_IEEE_CONFORMANT.\n(output_epilog): Call final_prescan_insn before emitting epilog.\n\nFrom-SVN: r11550", "tree": {"sha": "50c8c042f6a8126dfe2d7922b0d26b3c37809682", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50c8c042f6a8126dfe2d7922b0d26b3c37809682"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6245e3dfd1f55063f4bea59d6a4b3618e26d915b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6245e3dfd1f55063f4bea59d6a4b3618e26d915b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6245e3dfd1f55063f4bea59d6a4b3618e26d915b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6245e3dfd1f55063f4bea59d6a4b3618e26d915b/comments", "author": null, "committer": null, "parents": [{"sha": "2bf6230de9fe946ecc286c4d2543266a412d02b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2bf6230de9fe946ecc286c4d2543266a412d02b5", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2bf6230de9fe946ecc286c4d2543266a412d02b5"}], "stats": {"total": 437, "additions": 437, "deletions": 0}, "files": [{"sha": "5db3c5844547ac4dd821423ffaf5ccd8ec72fbaa", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 437, "deletions": 0, "changes": 437, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6245e3dfd1f55063f4bea59d6a4b3618e26d915b/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6245e3dfd1f55063f4bea59d6a4b3618e26d915b/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=6245e3dfd1f55063f4bea59d6a4b3618e26d915b", "patch": "@@ -38,6 +38,23 @@ Boston, MA 02111-1307, USA.  */\n #include \"obstack.h\"\n #include \"tree.h\"\n \n+/* Specify how accurate floating-point traps need to be.  */\n+\n+enum alpha_trap_precision alpha_tp;\n+\n+/* Specify the floating-point rounding mode.  */\n+\n+enum alpha_fp_rounding_mode alpha_fprm;\n+\n+/* Specify which things cause traps.  */\n+\n+enum alpha_fp_trap_mode alpha_fptm;\n+\n+/* Strings decoded into the above options.  */\n+char *alpha_tp_string;\t\t/* -mtrap-precision=[p|s|i] */\n+char *alpha_fprm_string;\t/* -mfp-rounding-mode=[n|m|c|d] */\n+char *alpha_fptm_string;\t/* -mfp-trap-mode=[n|u|su|sui] */\n+\n /* Save information from a \"cmpxx\" operation until the branch or scc is\n    emitted.  */\n \n@@ -54,6 +71,10 @@ char *alpha_function_name;\n \n static int inside_function = FALSE;\n \n+/* Non-zero if an instruction that may cause a trap is pending.  */\n+\n+static int trap_pending = 0;\n+\n /* Nonzero if the current function needs gp.  */\n \n int alpha_function_needs_gp;\n@@ -65,6 +86,97 @@ extern int rtx_equal_function_value_matters;\n static void alpha_set_memflags_1  PROTO((rtx, int, int, int));\n static void add_long_const\tPROTO((FILE *, HOST_WIDE_INT, int, int, int));\n \f\n+/* Parse target option strings. */\n+\n+void\n+override_options ()\n+{\n+  alpha_tp = ALPHA_TP_PROG;\n+  alpha_fprm = ALPHA_FPRM_NORM;\n+  alpha_fptm = ALPHA_FPTM_N;\n+\n+  if (TARGET_IEEE)\n+    {\n+      alpha_tp_string = \"i\";\n+      alpha_fptm_string = \"su\";\n+      target_flags |= MASK_IEEE_CONFORMANT;\n+    }\n+\n+  if (TARGET_IEEE_WITH_INEXACT)\n+    {\n+      alpha_tp_string = \"i\";\n+      alpha_fptm_string = \"sui\";\n+      target_flags |= MASK_IEEE_CONFORMANT;\n+    }\n+\n+  if (alpha_tp_string)\n+    switch (alpha_tp_string[0])\n+      {\n+      case 'p':\n+\talpha_tp = ALPHA_TP_PROG;\n+\tbreak;\n+\n+      case 'f':\n+\talpha_tp = ALPHA_TP_FUNC;\n+\tbreak;\n+\n+      case 'i':\n+\talpha_tp = ALPHA_TP_INSN;\n+\tbreak;\n+\n+      default:\n+\terror (\"bad value (%s) for -mtrap-precision switch\",\n+\t\t alpha_tp_string);\n+\t  break;\n+      }\n+\n+  if (alpha_fprm_string)\n+    switch (alpha_fprm_string[0])\n+      {\n+      case 'n':\n+\talpha_fprm = ALPHA_FPRM_NORM;\n+\tbreak;\n+\n+      case 'm':\n+\talpha_fprm = ALPHA_FPRM_MINF;\n+\tbreak;\n+\n+      case 'c':\n+\talpha_fprm = ALPHA_FPRM_CHOP;\n+\tbreak;\n+\n+      case 'd':\n+\talpha_fprm = ALPHA_FPRM_DYN;\n+\tbreak;\n+\n+      default:\n+\terror (\"bad value (%s) for -mfp-rounding-mode switch\",\n+\t       alpha_fprm_string);\n+\tbreak;\n+      }\n+\n+  if (alpha_fptm_string)\n+    if (strcmp (alpha_fptm_string, \"n\") == 0)\n+      alpha_fptm = ALPHA_FPTM_N;\n+    else if (strcmp (alpha_fptm_string, \"u\") == 0)\n+      alpha_fptm = ALPHA_FPTM_U;\n+    else if (strcmp (alpha_fptm_string, \"su\") == 0)\n+      alpha_fptm = ALPHA_FPTM_SU;\n+    else if (strcmp (alpha_fptm_string, \"sui\") == 0)\n+      alpha_fptm = ALPHA_FPTM_SUI;\n+    else\n+      error (\"bad value (%s) for -mfp-trap-mode switch\",\n+\t     alpha_fptm_string);\n+\n+  /* Do some sanity checks on the above option. */\n+\n+  if (alpha_fptm >= ALPHA_FPTM_SU && alpha_tp != ALPHA_TP_INSN)\n+    {\n+      error (\"fp software completion requires -mtrap-precision=i\");\n+      alpha_tp = ALPHA_TP_INSN;\n+    }\n+}\n+\f\n /* Returns 1 if VALUE is a mask that contains full bytes of zero or ones.  */\n \n int\n@@ -922,6 +1034,67 @@ print_operand (file, x, code)\n \n   switch (code)\n     {\n+    case '&':\n+      /* Generates fp-rounding mode suffix: nothing for normal, 'c' for\n+\t chopped, 'm' for minus-infinity, and 'd' for dynamic rounding\n+\t mode.  alpha_fprm controls which suffix is generated.  */\n+      switch (alpha_fprm)\n+\t{\n+\tcase ALPHA_FPRM_NORM:\n+\t  break;\n+\tcase ALPHA_FPRM_MINF: \n+\t  fputc ('m', file);\n+\t  break;\n+\tcase ALPHA_FPRM_CHOP:\n+\t  fputc ('c', file);\n+\t  break;\n+\tcase ALPHA_FPRM_DYN:\n+\t  fputc ('d', file);\n+\t  break;\n+\t}\n+      break;\n+\n+    case '\\'':\n+      /* Generates trap-mode suffix for instructions that accept the su\n+\t suffix only (cmpt et al).  */\n+      if (alpha_tp == ALPHA_TP_INSN)\n+\tfputs (\"su\", file);\n+      break;\n+\n+    case ')':\n+      /* Generates trap-mode suffix for instructions that accept the u, su,\n+\t and sui suffix.  This is the bulk of the IEEE floating point\n+\t instructions (addt et al).  */\n+      switch (alpha_fptm)\n+\t{\n+\tcase ALPHA_FPTM_N:\n+\t  break;\n+\tcase ALPHA_FPTM_U:\n+\t  fputc ('u', file);\n+\t  break;\n+\tcase ALPHA_FPTM_SU:\n+\t  fputs (\"su\", file);\n+\t  break;\n+\tcase ALPHA_FPTM_SUI:\n+\t  fputs (\"sui\", file);\n+\t  break;\n+\t}\n+      break;\n+\n+    case '+':\n+      /* Generates trap-mode suffix for instructions that accept the sui\n+\t suffix (cvtqt and cvtqs).  */\n+      switch (alpha_fptm)\n+\t{\n+\tcase ALPHA_FPTM_N: case ALPHA_FPTM_U:\n+\tcase ALPHA_FPTM_SU:\t/* cvtqt/cvtqs can't cause underflow */\n+\t  break;\n+\tcase ALPHA_FPTM_SUI:\n+\t  fputs (\"sui\", file);\n+\t  break;\n+\t}\n+      break;\n+\n     case 'r':\n       /* If this operand is the constant zero, write it as \"$31\".  */\n       if (GET_CODE (x) == REG)\n@@ -1364,6 +1537,12 @@ output_prolog (file, size)\n   ASM_OUTPUT_LABEL (file, alpha_function_name);\n   inside_function = TRUE;\n \n+  if (TARGET_IEEE_CONFORMANT)\n+    /* Set flags in procedure descriptor to request IEEE-conformant\n+       math-library routines.  The value we set it to is PDSC_EXC_IEEE\n+       (/usr/include/pdsc.h). */\n+    fprintf (file, \"\\t.eflag 48\\n\");\n+\n   /* Set up offsets to alpha virtual arg/local debugging pointer.  */\n \n   alpha_auto_offset = -frame_size + current_function_pretend_args_size;\n@@ -1548,6 +1727,8 @@ output_epilog (file, size)\n     {\n       int fp_offset = 0;\n \n+      final_prescan_insn (NULL_RTX, NULL_PTR, 0);\n+\n       /* If we have a frame pointer, restore SP from it.  */\n       if (frame_pointer_needed)\n \tfprintf (file, \"\\tbis $15,$15,$30\\n\");\n@@ -1710,3 +1891,259 @@ alpha_output_lineno (stream, line)\n   else\n     fprintf (stream, \"\\n\\t.loc\\t%d %d\\n\", num_source_filenames, line);\n }\n+\f\n+/* Structure to show the current status of registers and memory.  */\n+\n+struct shadow_summary\n+{\n+  struct {\n+    unsigned long i     : 32;\t/* Mask of int regs */\n+    unsigned long fp    : 32;\t/* Mask of fp regs */\n+    unsigned long mem   :  1;\t/* mem == imem | fpmem */\n+  } used, defd;\n+};\n+\n+/* Summary the effects of expression X on the machine.  Update SUM, a pointer\n+   to the summary structure.  SET is nonzero if the insn is setting the\n+   object, otherwise zero.  */\n+\n+static void\n+summarize_insn (x, sum, set)\n+     rtx x;\n+     struct shadow_summary *sum;\n+     int set;\n+{\n+  char *format_ptr;\n+  int i, j;\n+\n+  if (x == 0)\n+    return;\n+\n+  switch (GET_CODE (x))\n+    {\n+      /* ??? Note that this case would be incorrect if the Alpha had a\n+\t ZERO_EXTRACT in SET_DEST.  */\n+    case SET:\n+      summarize_insn (SET_SRC (x), sum, 0);\n+      summarize_insn (SET_DEST (x), sum, 1);\n+      break;\n+\n+    case CLOBBER:\n+      summarize_insn (XEXP (x, 0), sum, 1);\n+      break;\n+\n+    case USE:\n+      summarize_insn (XEXP (x, 0), sum, 0);\n+      break;\n+\n+    case PARALLEL:\n+      for (i = XVECLEN (x, 0); i >= 0; i--)\n+\tsummarize_insn (XVECEXP (x, 0, i), sum, 0);\n+      break;\n+\n+    case REG:\n+      {\n+\tint regno = REGNO (x);\n+\tunsigned long mask = 1UL << (regno % 32);\n+\n+\tif (regno == 31 || regno == 63)\n+\t  break;\n+\n+\tif (set)\n+\t  {\n+\t    if (regno < 32)\n+\t      sum->defd.i |= mask;\n+\t    else\n+\t      sum->defd.fp |= mask;\n+\t  }\n+\telse\n+\t  {\n+\t    if (regno < 32)\n+\t      sum->used.i  |= mask;\n+\t    else\n+\t      sum->used.fp |= mask;\n+\t  }\n+\t}\n+      break;\n+\n+    case MEM:\n+      if (set)\n+\tsum->defd.mem = 1;\n+      else\n+\tsum->used.mem = 1;\n+\n+      /* Find the regs used in memory address computation: */\n+      summarize_insn (XEXP (x, 0), sum, 0);\n+      break;\n+\n+      /* Handle common unary and binary ops for efficiency.  */\n+    case COMPARE:  case PLUS:    case MINUS:   case MULT:      case DIV:\n+    case MOD:      case UDIV:    case UMOD:    case AND:       case IOR:\n+    case XOR:      case ASHIFT:  case ROTATE:  case ASHIFTRT:  case LSHIFTRT:\n+    case ROTATERT: case SMIN:    case SMAX:    case UMIN:      case UMAX:\n+    case NE:       case EQ:      case GE:      case GT:        case LE:\n+    case LT:       case GEU:     case GTU:     case LEU:       case LTU:\n+      summarize_insn (XEXP (x, 0), sum, 0);\n+      summarize_insn (XEXP (x, 1), sum, 0);\n+      break;\n+\n+    case NEG:  case NOT:  case SIGN_EXTEND:  case ZERO_EXTEND:\n+    case TRUNCATE:  case FLOAT_EXTEND:  case FLOAT_TRUNCATE:  case FLOAT:\n+    case FIX:  case UNSIGNED_FLOAT:  case UNSIGNED_FIX:  case ABS:\n+    case SQRT:  case FFS: \n+      summarize_insn (XEXP (x, 0), sum, 0);\n+      break;\n+\n+    default:\n+      format_ptr = GET_RTX_FORMAT (GET_CODE (x));\n+      for (i = GET_RTX_LENGTH (GET_CODE (x)); i >= 0; i--)\n+\tswitch (*format_ptr++)\n+\t  {\n+\t  case 'e':\n+\t    summarize_insn (XEXP (x, i), sum, 0);\n+\t    break;\n+\n+\t  case 'E':\n+\t    for (j = XVECLEN (x, i); j >= 0; j--)\n+\t      summarize_insn (XVECEXP (x, i, j), sum, 0);\n+\t    break;\n+\n+\t  default:\n+\t    abort ();\n+\t  }\n+    }\n+}\n+\f\n+/* This function is executed just prior to the output of assembler code for\n+   INSN to modify the extracted operands so they will be output differently.\n+\n+   OPVEC is the vector containing the operands extracted from INSN, and\n+   NOPERANDS is the number of elements of the vector which contain meaningful\n+   data for this insn.  The contents of this vector are what will be used to\n+   convert the insn template into assembler code, so you can change the\n+   assembler output by changing the contents of the vector.\n+\n+   We use this function to ensure a sufficient number of `trapb' instructions\n+   are in the code when the user requests code with a trap precision of\n+   functions or instructions.\n+\n+   In naive mode, when the user requests a trap-precision of \"instruction\", a\n+   trapb is needed after every instruction that may generate a trap (and after\n+   jsr/bsr instructions, because called functions may import a trap from the\n+   caller).  This ensures that the code is resumption safe but it is also slow.\n+\n+   When optimizations are turned on, we delay issuing a trapb as long as\n+   possible.  In this context, a trap shadow is the sequence of instructions\n+   that starts with a (potentially) trap generating instruction and extends to\n+   the next trapb or call_pal instruction (but GCC never generates call_pal by\n+   itself).  We can delay (and therefore sometimes omit) a trapb subject to the\n+   following conditions:\n+\n+   (a) On entry to the trap shadow, if any Alpha register or memory location\n+   contains a value that is used as an operand value by some instruction in\n+   the trap shadow (live on entry), then no instruction in the trap shadow\n+   may modify the register or memory location.\n+\n+   (b) Within the trap shadow, the computation of the base register for a\n+   memory load or store instruction may not involve using the result\n+   of an instruction that might generate an UNPREDICTABLE result.\n+\n+   (c) Within the trap shadow, no register may be used more than once as a\n+   destination register.  (This is to make life easier for the trap-handler.)\n+\n+   (d) The trap shadow may not include any branch instructions.\n+\n+     */\n+\n+void\n+final_prescan_insn (insn, opvec, noperands)\n+     rtx insn;\n+     rtx *opvec;\n+     int noperands;\n+{\n+  static struct shadow_summary shadow = {0, 0, 0, 0, 0};\n+\n+#define CLOSE_SHADOW\t\t\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputs (\"\\ttrapb\\n\", asm_out_file);\t\\\n+      trap_pending = 0;\t\t\t\t\\\n+      bzero ((char *) &shadow,  sizeof shadow);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+  if (alpha_tp == ALPHA_TP_PROG)\n+    return;\n+\n+  if (trap_pending)\n+    switch (alpha_tp)\n+      {\n+      case ALPHA_TP_FUNC:\n+\t/* Generate one trapb before epilogue (indicated by INSN==0) */\n+\tif (insn == 0)\n+\t  CLOSE_SHADOW;\n+\tbreak;\n+\n+      case ALPHA_TP_INSN:\n+\tif (optimize && insn != 0)\n+\t  {\n+\t    struct shadow_summary sum = {0, 0, 0};\n+\n+\t    switch (GET_CODE(insn))\n+\t      {\n+\t      case INSN:\n+\t\tsummarize_insn (PATTERN (insn), &sum, 0);\n+\n+\t\tif ((sum.defd.i & shadow.defd.i)\n+\t\t    || (sum.defd.fp & shadow.defd.fp))\n+\t\t  {\n+\t\t    /* (c) would be violated */\n+\t\t    CLOSE_SHADOW;\n+\t\t    break;\n+\t\t  }\n+\n+\t\t/* Combine shadow with summary of current insn: */\n+\t\tshadow.used.i     |= sum.used.i;\n+\t\tshadow.used.fp    |= sum.used.fp;\n+\t\tshadow.used.mem   |= sum.used.mem;\n+\t\tshadow.defd.i     |= sum.defd.i;\n+\t\tshadow.defd.fp    |= sum.defd.fp;\n+\t\tshadow.defd.mem   |= sum.defd.mem;\n+\n+\t\tif ((sum.defd.i & shadow.used.i)\n+\t\t    || (sum.defd.fp & shadow.used.fp)\n+\t\t    || (sum.defd.mem & shadow.used.mem))\n+\t\t  {\n+\t\t    /* (a) would be violated (also takes care of (b)).  */\n+\t\t    if (get_attr_trap (insn) == TRAP_YES\n+\t\t\t&& ((sum.defd.i & sum.used.i)\n+\t\t\t    || (sum.defd.fp & sum.used.fp)))\n+\t\t      abort ();\n+\n+\t\t    CLOSE_SHADOW;\n+\t\t    break;\n+\t\t  }\n+\t\tbreak;\n+\n+\t      case JUMP_INSN:\n+\t      case CALL_INSN:\n+\t      case CODE_LABEL:\n+\t\tCLOSE_SHADOW;\n+\t\tbreak;\n+\n+\t      default:\n+\t\tabort ();\n+\t      }\n+\t  }\n+\telse\n+\t  CLOSE_SHADOW;\n+\tbreak;\n+      }\n+\n+  if (insn != 0 && get_attr_trap (insn) == TRAP_YES)\n+    {\n+      if (optimize && !trap_pending && GET_CODE (insn) == INSN)\n+\tsummarize_insn (PATTERN (insn), &shadow, 0);\n+      trap_pending = 1;\n+    }\n+}"}]}