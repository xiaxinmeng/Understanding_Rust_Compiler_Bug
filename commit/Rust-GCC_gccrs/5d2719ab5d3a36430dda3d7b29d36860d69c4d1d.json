{"sha": "5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWQyNzE5YWI1ZDNhMzY0MzBkZGEzZDdiMjlkMzY4NjBkNjljNGQxZA==", "commit": {"author": {"name": "Christophe Lyon", "email": "christophe.lyon@linaro.org", "date": "2015-06-19T14:05:57Z"}, "committer": {"name": "Christophe Lyon", "email": "clyon@gcc.gnu.org", "date": "2015-06-19T14:05:57Z"}, "message": "vtbX.c: New file.\n\n2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n\n\t* gcc.target/aarch64/advsimd-intrinsics/vtbX.c: New file.\n\nFrom-SVN: r224668", "tree": {"sha": "8bbb5329f597231bb5b90b66c35858282bdaf2a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8bbb5329f597231bb5b90b66c35858282bdaf2a0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d/comments", "author": null, "committer": null, "parents": [{"sha": "4069ef63c53051728389eeee5d5abcb0cabe0f27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4069ef63c53051728389eeee5d5abcb0cabe0f27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4069ef63c53051728389eeee5d5abcb0cabe0f27"}], "stats": {"total": 293, "additions": 293, "deletions": 0}, "files": [{"sha": "096550b4ac8db4e028f034d7154d5d452b3b4f37", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "patch": "@@ -1,3 +1,7 @@\n+2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n+\n+\t* gcc.target/aarch64/advsimd-intrinsics/vtbX.c: New file.\n+\n 2015-06-19  Christophe Lyon  <christophe.lyon@linaro.org>\n \n \t* gcc.target/aarch64/advsimd-intrinsics/vstX_lane.c: New file."}, {"sha": "0557efd6e7e401ae0d6f02b3d08d54627fece25f", "filename": "gcc/testsuite/gcc.target/aarch64/advsimd-intrinsics/vtbX.c", "status": "added", "additions": 289, "deletions": 0, "changes": 289, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FvtbX.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5d2719ab5d3a36430dda3d7b29d36860d69c4d1d/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FvtbX.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Fadvsimd-intrinsics%2FvtbX.c?ref=5d2719ab5d3a36430dda3d7b29d36860d69c4d1d", "patch": "@@ -0,0 +1,289 @@\n+#include <arm_neon.h>\n+#include \"arm-neon-ref.h\"\n+#include \"compute-ref-data.h\"\n+\n+/* Expected results for vtbl1.  */\n+VECT_VAR_DECL(expected_vtbl1,int,8,8) [] = { 0x0, 0xf2, 0xf2, 0xf2,\n+\t\t\t\t\t     0x0, 0x0, 0xf2, 0xf2 };\n+VECT_VAR_DECL(expected_vtbl1,uint,8,8) [] = { 0x0, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t      0x0, 0x0, 0xf3, 0xf3 };\n+VECT_VAR_DECL(expected_vtbl1,poly,8,8) [] = { 0x0, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t      0x0, 0x0, 0xf3, 0xf3 };\n+\n+/* Expected results for vtbl2.  */\n+VECT_VAR_DECL(expected_vtbl2,int,8,8) [] = { 0xf6, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t     0x0, 0x0, 0xf3, 0xf3 };\n+VECT_VAR_DECL(expected_vtbl2,uint,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t      0x0, 0x0, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected_vtbl2,poly,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t      0x0, 0x0, 0xf5, 0xf5 };\n+\n+/* Expected results for vtbl3.  */\n+VECT_VAR_DECL(expected_vtbl3,int,8,8) [] = { 0xf8, 0xf4, 0xf4, 0xf4,\n+\t\t\t\t\t     0xff, 0x0, 0xf4, 0xf4 };\n+VECT_VAR_DECL(expected_vtbl3,uint,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,\n+\t\t\t\t\t      0xff, 0x0, 0xf7, 0xf7 };\n+VECT_VAR_DECL(expected_vtbl3,poly,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,\n+\t\t\t\t\t      0xff, 0x0, 0xf7, 0xf7 };\n+\n+/* Expected results for vtbl4.  */\n+VECT_VAR_DECL(expected_vtbl4,int,8,8) [] = { 0xfa, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t    0x3, 0x0, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected_vtbl4,uint,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,\n+\t\t\t\t\t     0x3, 0x0, 0xf9, 0xf9 };\n+VECT_VAR_DECL(expected_vtbl4,poly,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,\n+\t\t\t\t\t     0x3, 0x0, 0xf9, 0xf9 };\n+\n+/* Expected results for vtbx1.  */\n+VECT_VAR_DECL(expected_vtbx1,int,8,8) [] = { 0x33, 0xf2, 0xf2, 0xf2,\n+\t\t\t\t\t    0x33, 0x33, 0xf2, 0xf2 };\n+VECT_VAR_DECL(expected_vtbx1,uint,8,8) [] = { 0xcc, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t     0xcc, 0xcc, 0xf3, 0xf3 };\n+VECT_VAR_DECL(expected_vtbx1,poly,8,8) [] = { 0xcc, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t     0xcc, 0xcc, 0xf3, 0xf3 };\n+\n+/* Expected results for vtbx2.  */\n+VECT_VAR_DECL(expected_vtbx2,int,8,8) [] = { 0xf6, 0xf3, 0xf3, 0xf3,\n+\t\t\t\t\t    0x33, 0x33, 0xf3, 0xf3 };\n+VECT_VAR_DECL(expected_vtbx2,uint,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t     0xcc, 0xcc, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected_vtbx2,poly,8,8) [] = { 0xf6, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t     0xcc, 0xcc, 0xf5, 0xf5 };\n+\n+/* Expected results for vtbx3.  */\n+VECT_VAR_DECL(expected_vtbx3,int,8,8) [] = { 0xf8, 0xf4, 0xf4, 0xf4,\n+\t\t\t\t\t    0xff, 0x33, 0xf4, 0xf4 };\n+VECT_VAR_DECL(expected_vtbx3,uint,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,\n+\t\t\t\t\t     0xff, 0xcc, 0xf7, 0xf7 };\n+VECT_VAR_DECL(expected_vtbx3,poly,8,8) [] = { 0xf8, 0xf7, 0xf7, 0xf7,\n+\t\t\t\t\t     0xff, 0xcc, 0xf7, 0xf7 };\n+\n+/* Expected results for vtbx4.  */\n+VECT_VAR_DECL(expected_vtbx4,int,8,8) [] = { 0xfa, 0xf5, 0xf5, 0xf5,\n+\t\t\t\t\t     0x3, 0x33, 0xf5, 0xf5 };\n+VECT_VAR_DECL(expected_vtbx4,uint,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,\n+\t\t\t\t\t      0x3, 0xcc, 0xf9, 0xf9 };\n+VECT_VAR_DECL(expected_vtbx4,poly,8,8) [] = { 0xfa, 0xf9, 0xf9, 0xf9,\n+\t\t\t\t\t      0x3, 0xcc, 0xf9, 0xf9 };\n+\n+void exec_vtbX (void)\n+{\n+  int i;\n+\n+  /* In this case, input variables are arrays of vectors.  */\n+#define DECL_VTBX(T1, W, N, X)\t\t\t\t\t\t\\\n+  VECT_ARRAY_TYPE(T1, W, N, X) VECT_ARRAY_VAR(table_vector, T1, W, N, X)\n+\n+  /* The vtbl1 variant is different from vtbl{2,3,4} because it takes a\n+     vector as 1st param, instead of an array of vectors.  */\n+#define TEST_VTBL1(T1, T2, T3, W, N)\t\t\t\\\n+  VECT_VAR(table_vector, T1, W, N) =\t\t\t\\\n+    vld1##_##T2##W((T1##W##_t *)lookup_table);\t\t\\\n+\t\t\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vtbl1_##T2##W(VECT_VAR(table_vector, T1, W, N),\t\\\n+\t\t  VECT_VAR(vector, T3, W, N));\t\t\\\n+  vst1_##T2##W(VECT_VAR(result, T1, W, N),\t\t\\\n+\t       VECT_VAR(vector_res, T1, W, N));\n+\n+#define TEST_VTBLX(T1, T2, T3, W, N, X)\t\t\t\t\t\\\n+  VECT_ARRAY_VAR(table_vector, T1, W, N, X) =\t\t\t\t\\\n+    vld##X##_##T2##W((T1##W##_t *)lookup_table);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vtbl##X##_##T2##W(VECT_ARRAY_VAR(table_vector, T1, W, N, X),\t\\\n+\t\t      VECT_VAR(vector, T3, W, N));\t\t\t\\\n+  vst1_##T2##W(VECT_VAR(result, T1, W, N),\t\t\t\t\\\n+\t       VECT_VAR(vector_res, T1, W, N));\n+\n+  /* We need to define a lookup table.  */\n+  uint8_t lookup_table[32];\n+\n+  DECL_VARIABLE(vector, int, 8, 8);\n+  DECL_VARIABLE(vector, uint, 8, 8);\n+  DECL_VARIABLE(vector, poly, 8, 8);\n+  DECL_VARIABLE(vector_res, int, 8, 8);\n+  DECL_VARIABLE(vector_res, uint, 8, 8);\n+  DECL_VARIABLE(vector_res, poly, 8, 8);\n+\n+  /* For vtbl1.  */\n+  DECL_VARIABLE(table_vector, int, 8, 8);\n+  DECL_VARIABLE(table_vector, uint, 8, 8);\n+  DECL_VARIABLE(table_vector, poly, 8, 8);\n+\n+  /* For vtbx*.  */\n+  DECL_VARIABLE(default_vector, int, 8, 8);\n+  DECL_VARIABLE(default_vector, uint, 8, 8);\n+  DECL_VARIABLE(default_vector, poly, 8, 8);\n+\n+  /* We need only 8 bits variants.  */\n+#define DECL_ALL_VTBLX(X)\t\t\t\\\n+  DECL_VTBX(int, 8, 8, X);\t\t\t\\\n+  DECL_VTBX(uint, 8, 8, X);\t\t\t\\\n+  DECL_VTBX(poly, 8, 8, X)\n+\n+#define TEST_ALL_VTBL1()\t\t\t\\\n+  TEST_VTBL1(int, s, int, 8, 8);\t\t\\\n+  TEST_VTBL1(uint, u, uint, 8, 8);\t\t\\\n+  TEST_VTBL1(poly, p, uint, 8, 8)\n+\n+#define TEST_ALL_VTBLX(X)\t\t\t\\\n+  TEST_VTBLX(int, s, int, 8, 8, X);\t\t\\\n+  TEST_VTBLX(uint, u, uint, 8, 8, X);\t\t\\\n+  TEST_VTBLX(poly, p, uint, 8, 8, X)\n+\n+  /* Declare the temporary buffers / variables.  */\n+  DECL_ALL_VTBLX(2);\n+  DECL_ALL_VTBLX(3);\n+  DECL_ALL_VTBLX(4);\n+\n+  /* Fill the lookup table.  */\n+  for (i=0; i<32; i++) {\n+    lookup_table[i] = i-15;\n+  }\n+\n+  /* Choose init value arbitrarily, will be used as table index.  */\n+  VDUP(vector, , int, s, 8, 8, 1);\n+  VDUP(vector, , uint, u, 8, 8, 2);\n+  VDUP(vector, , poly, p, 8, 8, 2);\n+\n+  /* To ensure coverage, add some indexes larger than 8,16 and 32\n+     except: lane 0 (by 6), lane 1 (by 8) and lane 2 (by 9).  */\n+  VSET_LANE(vector, , int, s, 8, 8, 0, 10);\n+  VSET_LANE(vector, , int, s, 8, 8, 4, 20);\n+  VSET_LANE(vector, , int, s, 8, 8, 5, 40);\n+  VSET_LANE(vector, , uint, u, 8, 8, 0, 10);\n+  VSET_LANE(vector, , uint, u, 8, 8, 4, 20);\n+  VSET_LANE(vector, , uint, u, 8, 8, 5, 40);\n+  VSET_LANE(vector, , poly, p, 8, 8, 0, 10);\n+  VSET_LANE(vector, , poly, p, 8, 8, 4, 20);\n+  VSET_LANE(vector, , poly, p, 8, 8, 5, 40);\n+\n+\n+  /* Check vtbl1.  */\n+  clean_results ();\n+#define TEST_MSG \"VTBL1\"\n+  TEST_ALL_VTBL1();\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl1, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl1, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl1, \"\");\n+\n+  /* Check vtbl2.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBL2\"\n+  TEST_ALL_VTBLX(2);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl2, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl2, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl2, \"\");\n+\n+  /* Check vtbl3.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBL3\"\n+  TEST_ALL_VTBLX(3);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl3, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl3, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl3, \"\");\n+\n+  /* Check vtbl4.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBL4\"\n+  TEST_ALL_VTBLX(4);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbl4, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbl4, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbl4, \"\");\n+\n+\n+  /* Now test VTBX.  */\n+\n+  /* The vtbx1 variant is different from vtbx{2,3,4} because it takes a\n+     vector as 1st param, instead of an array of vectors.  */\n+#define TEST_VTBX1(T1, T2, T3, W, N)\t\t\t\\\n+  VECT_VAR(table_vector, T1, W, N) =\t\t\t\\\n+    vld1##_##T2##W((T1##W##_t *)lookup_table);\t\t\\\n+\t\t\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\\\n+    vtbx1_##T2##W(VECT_VAR(default_vector, T1, W, N),\t\\\n+\t\t  VECT_VAR(table_vector, T1, W, N),\t\\\n+\t\t  VECT_VAR(vector, T3, W, N));\t\t\\\n+  vst1_##T2##W(VECT_VAR(result, T1, W, N),\t\t\\\n+\t       VECT_VAR(vector_res, T1, W, N));\n+\n+#define TEST_VTBXX(T1, T2, T3, W, N, X)\t\t\t\t\t\\\n+  VECT_ARRAY_VAR(table_vector, T1, W, N, X) =\t\t\t\t\\\n+    vld##X##_##T2##W((T1##W##_t *)lookup_table);\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  VECT_VAR(vector_res, T1, W, N) =\t\t\t\t\t\\\n+    vtbx##X##_##T2##W(VECT_VAR(default_vector, T1, W, N),\t\t\\\n+\t\t      VECT_ARRAY_VAR(table_vector, T1, W, N, X),\t\\\n+\t\t      VECT_VAR(vector, T3, W, N));\t\t\t\\\n+  vst1_##T2##W(VECT_VAR(result, T1, W, N),\t\t\t\t\\\n+\t       VECT_VAR(vector_res, T1, W, N));\n+\n+#define TEST_ALL_VTBX1()\t\t\t\\\n+  TEST_VTBX1(int, s, int, 8, 8);\t\t\\\n+  TEST_VTBX1(uint, u, uint, 8, 8);\t\t\\\n+  TEST_VTBX1(poly, p, uint, 8, 8)\n+\n+#define TEST_ALL_VTBXX(X)\t\t\t\\\n+  TEST_VTBXX(int, s, int, 8, 8, X);\t\t\\\n+  TEST_VTBXX(uint, u, uint, 8, 8, X);\t\t\\\n+  TEST_VTBXX(poly, p, uint, 8, 8, X)\n+\n+  /* Choose init value arbitrarily, will be used as default value.  */\n+  VDUP(default_vector, , int, s, 8, 8, 0x33);\n+  VDUP(default_vector, , uint, u, 8, 8, 0xCC);\n+  VDUP(default_vector, , poly, p, 8, 8, 0xCC);\n+\n+  /* Check vtbx1.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBX1\"\n+  TEST_ALL_VTBX1();\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx1, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx1, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx1, \"\");\n+\n+  /* Check vtbx2.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBX2\"\n+  TEST_ALL_VTBXX(2);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx2, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx2, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx2, \"\");\n+\n+  /* Check vtbx3.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBX3\"\n+  TEST_ALL_VTBXX(3);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx3, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx3, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx3, \"\");\n+\n+  /* Check vtbx4.  */\n+  clean_results ();\n+#undef TEST_MSG\n+#define TEST_MSG \"VTBX4\"\n+  TEST_ALL_VTBXX(4);\n+\n+  CHECK(TEST_MSG, int, 8, 8, PRIx8, expected_vtbx4, \"\");\n+  CHECK(TEST_MSG, uint, 8, 8, PRIx8, expected_vtbx4, \"\");\n+  CHECK(TEST_MSG, poly, 8, 8, PRIx8, expected_vtbx4, \"\");\n+}\n+\n+int main (void)\n+{\n+  exec_vtbX ();\n+  return 0;\n+}"}]}