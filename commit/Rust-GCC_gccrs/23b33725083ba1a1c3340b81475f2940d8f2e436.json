{"sha": "23b33725083ba1a1c3340b81475f2940d8f2e436", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjNiMzM3MjUwODNiYTFhMWMzMzQwYjgxNDc1ZjI5NDBkOGYyZTQzNg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2014-05-17T07:00:02Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2014-05-17T07:00:02Z"}, "message": "emit-rtl.h (replace_equiv_address, [...]): Add an inplace argument.\n\ngcc/\n\t* emit-rtl.h (replace_equiv_address, replace_equiv_address_nv): Add an\n\tinplace argument.  Store the new address in the original MEM when true.\n\t* emit-rtl.c (change_address_1): Likewise.\n\t(adjust_address_1, adjust_automodify_address_1, offset_address):\n\tUpdate accordingly.\n\t* rtl.h (plus_constant): Add an inplace argument.\n\t* explow.c (plus_constant): Likewise.  Try to reuse the original PLUS\n\twhen true.  Avoid generating (plus X (const_int 0)).\n\t* function.c (instantiate_virtual_regs_in_rtx): Adjust the PLUS\n\tin-place.  Pass true to plus_constant.\n\t(instantiate_virtual_regs_in_insn): Pass true to replace_equiv_address.\n\nFrom-SVN: r210543", "tree": {"sha": "d0bbc16685eb58141c00c2372960b318c757d524", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d0bbc16685eb58141c00c2372960b318c757d524"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/23b33725083ba1a1c3340b81475f2940d8f2e436", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b33725083ba1a1c3340b81475f2940d8f2e436", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23b33725083ba1a1c3340b81475f2940d8f2e436", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23b33725083ba1a1c3340b81475f2940d8f2e436/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e16db39967ab6aaef964cae249087d37c18984a0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e16db39967ab6aaef964cae249087d37c18984a0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e16db39967ab6aaef964cae249087d37c18984a0"}], "stats": {"total": 99, "additions": 67, "deletions": 32}, "files": [{"sha": "352a109bc203cf9f98c9498ec5c8dbef5bde55a7", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -1,3 +1,17 @@\n+2014-05-17  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* emit-rtl.h (replace_equiv_address, replace_equiv_address_nv): Add an\n+\tinplace argument.  Store the new address in the original MEM when true.\n+\t* emit-rtl.c (change_address_1): Likewise.\n+\t(adjust_address_1, adjust_automodify_address_1, offset_address):\n+\tUpdate accordingly.\n+\t* rtl.h (plus_constant): Add an inplace argument.\n+\t* explow.c (plus_constant): Likewise.  Try to reuse the original PLUS\n+\twhen true.  Avoid generating (plus X (const_int 0)).\n+\t* function.c (instantiate_virtual_regs_in_rtx): Adjust the PLUS\n+\tin-place.  Pass true to plus_constant.\n+\t(instantiate_virtual_regs_in_insn): Pass true to replace_equiv_address.\n+\n 2014-05-16  Dehao Chen  <dehao@google.com>\n \n \t* tree-cfg.c (gimple_merge_blocks): Updates bb count with max count."}, {"sha": "d48d761479986ee1479fe4041e5061b908ebef41", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -145,7 +145,6 @@ static GTY ((if_marked (\"ggc_marked_p\"), param_is (struct rtx_def)))\n #define cur_debug_insn_uid (crtl->emit.x_cur_debug_insn_uid)\n #define first_label_num (crtl->emit.x_first_label_num)\n \n-static rtx change_address_1 (rtx, enum machine_mode, rtx, int);\n static void set_used_decls (tree);\n static void mark_label_nuses (rtx);\n static hashval_t const_int_htab_hash (const void *);\n@@ -2010,11 +2009,15 @@ clear_mem_size (rtx mem)\n /* Return a memory reference like MEMREF, but with its mode changed to MODE\n    and its address changed to ADDR.  (VOIDmode means don't change the mode.\n    NULL for ADDR means don't change the address.)  VALIDATE is nonzero if the\n-   returned memory location is required to be valid.  The memory\n-   attributes are not changed.  */\n+   returned memory location is required to be valid.  INPLACE is true if any\n+   changes can be made directly to MEMREF or false if MEMREF must be treated\n+   as immutable.\n+\n+   The memory attributes are not changed.  */\n \n static rtx\n-change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n+change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate,\n+\t\t  bool inplace)\n {\n   addr_space_t as;\n   rtx new_rtx;\n@@ -2042,6 +2045,12 @@ change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n   if (rtx_equal_p (addr, XEXP (memref, 0)) && mode == GET_MODE (memref))\n     return memref;\n \n+  if (inplace)\n+    {\n+      XEXP (memref, 0) = addr;\n+      return memref;\n+    }\n+\n   new_rtx = gen_rtx_MEM (mode, addr);\n   MEM_COPY_ATTRIBUTES (new_rtx, memref);\n   return new_rtx;\n@@ -2053,7 +2062,7 @@ change_address_1 (rtx memref, enum machine_mode mode, rtx addr, int validate)\n rtx\n change_address (rtx memref, enum machine_mode mode, rtx addr)\n {\n-  rtx new_rtx = change_address_1 (memref, mode, addr, 1);\n+  rtx new_rtx = change_address_1 (memref, mode, addr, 1, false);\n   enum machine_mode mmode = GET_MODE (new_rtx);\n   struct mem_attrs attrs, *defattrs;\n \n@@ -2166,7 +2175,7 @@ adjust_address_1 (rtx memref, enum machine_mode mode, HOST_WIDE_INT offset,\n \taddr = plus_constant (address_mode, addr, offset);\n     }\n \n-  new_rtx = change_address_1 (memref, mode, addr, validate);\n+  new_rtx = change_address_1 (memref, mode, addr, validate, false);\n \n   /* If the address is a REG, change_address_1 rightfully returns memref,\n      but this would destroy memref's MEM_ATTRS.  */\n@@ -2236,7 +2245,7 @@ rtx\n adjust_automodify_address_1 (rtx memref, enum machine_mode mode, rtx addr,\n \t\t\t     HOST_WIDE_INT offset, int validate)\n {\n-  memref = change_address_1 (memref, VOIDmode, addr, validate);\n+  memref = change_address_1 (memref, VOIDmode, addr, validate, false);\n   return adjust_address_1 (memref, mode, offset, validate, 0, 0, 0);\n }\n \n@@ -2272,7 +2281,7 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n     }\n \n   update_temp_slot_address (XEXP (memref, 0), new_rtx);\n-  new_rtx = change_address_1 (memref, VOIDmode, new_rtx, 1);\n+  new_rtx = change_address_1 (memref, VOIDmode, new_rtx, 1, false);\n \n   /* If there are no changes, just return the original memory reference.  */\n   if (new_rtx == memref)\n@@ -2292,23 +2301,25 @@ offset_address (rtx memref, rtx offset, unsigned HOST_WIDE_INT pow2)\n /* Return a memory reference like MEMREF, but with its address changed to\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n-   by putting something into a register.  */\n+   by putting something into a register.  INPLACE is true if any changes\n+   can be made directly to MEMREF or false if MEMREF must be treated as\n+   immutable.  */\n \n rtx\n-replace_equiv_address (rtx memref, rtx addr)\n+replace_equiv_address (rtx memref, rtx addr, bool inplace)\n {\n   /* change_address_1 copies the memory attribute structure without change\n      and that's exactly what we want here.  */\n   update_temp_slot_address (XEXP (memref, 0), addr);\n-  return change_address_1 (memref, VOIDmode, addr, 1);\n+  return change_address_1 (memref, VOIDmode, addr, 1, inplace);\n }\n \n /* Likewise, but the reference is not required to be valid.  */\n \n rtx\n-replace_equiv_address_nv (rtx memref, rtx addr)\n+replace_equiv_address_nv (rtx memref, rtx addr, bool inplace)\n {\n-  return change_address_1 (memref, VOIDmode, addr, 0);\n+  return change_address_1 (memref, VOIDmode, addr, 0, inplace);\n }\n \n /* Return a memory reference like MEMREF, but with its mode widened to"}, {"sha": "c72c24f4d88f66fce4fe13b89fb2c51c81a88d70", "filename": "gcc/emit-rtl.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Femit-rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Femit-rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.h?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -52,10 +52,10 @@ extern tree get_spill_slot_decl (bool);\n    ADDR.  The caller is asserting that the actual piece of memory pointed\n    to is the same, just the form of the address is being changed, such as\n    by putting something into a register.  */\n-extern rtx replace_equiv_address (rtx, rtx);\n+extern rtx replace_equiv_address (rtx, rtx, bool = false);\n \n /* Likewise, but the reference is not required to be valid.  */\n-extern rtx replace_equiv_address_nv (rtx, rtx);\n+extern rtx replace_equiv_address_nv (rtx, rtx, bool = false);\n \n extern rtx gen_blockage (void);\n extern rtvec gen_rtvec (int, ...);"}, {"sha": "e39db0507db9a8ebd7f7799afc7ae3693360768c", "filename": "gcc/explow.c", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -74,10 +74,12 @@ trunc_int_for_mode (HOST_WIDE_INT c, enum machine_mode mode)\n }\n \n /* Return an rtx for the sum of X and the integer C, given that X has\n-   mode MODE.  */\n+   mode MODE.  INPLACE is true if X can be modified inplace or false\n+   if it must be treated as immutable.  */\n \n rtx\n-plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n+plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c,\n+\t       bool inplace)\n {\n   RTX_CODE code;\n   rtx y;\n@@ -116,6 +118,8 @@ plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n     case CONST:\n       /* If adding to something entirely constant, set a flag\n \t so that we can add a CONST around the result.  */\n+      if (inplace && shared_const_p (x))\n+\tinplace = false;\n       x = XEXP (x, 0);\n       all_constant = 1;\n       goto restart;\n@@ -136,19 +140,25 @@ plus_constant (enum machine_mode mode, rtx x, HOST_WIDE_INT c)\n \n       if (CONSTANT_P (XEXP (x, 1)))\n \t{\n-\t  x = gen_rtx_PLUS (mode, XEXP (x, 0),\n-\t\t\t    plus_constant (mode, XEXP (x, 1), c));\n+\t  rtx term = plus_constant (mode, XEXP (x, 1), c, inplace);\n+\t  if (term == const0_rtx)\n+\t    x = XEXP (x, 0);\n+\t  else if (inplace)\n+\t    XEXP (x, 1) = term;\n+\t  else\n+\t    x = gen_rtx_PLUS (mode, XEXP (x, 0), term);\n \t  c = 0;\n \t}\n-      else if (find_constant_term_loc (&y))\n+      else if (rtx *const_loc = find_constant_term_loc (&y))\n \t{\n-\t  /* We need to be careful since X may be shared and we can't\n-\t     modify it in place.  */\n-\t  rtx copy = copy_rtx (x);\n-\t  rtx *const_loc = find_constant_term_loc (&copy);\n-\n-\t  *const_loc = plus_constant (mode, *const_loc, c);\n-\t  x = copy;\n+\t  if (!inplace)\n+\t    {\n+\t      /* We need to be careful since X may be shared and we can't\n+\t\t modify it in place.  */\n+\t      x = copy_rtx (x);\n+\t      const_loc = find_constant_term_loc (&x);\n+\t    }\n+\t  *const_loc = plus_constant (mode, *const_loc, c, true);\n \t  c = 0;\n \t}\n       break;"}, {"sha": "d269c5434e25e37dc8c842af4943be8d77d03450", "filename": "gcc/function.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -1459,8 +1459,8 @@ instantiate_virtual_regs_in_rtx (rtx *loc, void *data)\n       new_rtx = instantiate_new_reg (XEXP (x, 0), &offset);\n       if (new_rtx)\n \t{\n-\t  new_rtx = plus_constant (GET_MODE (x), new_rtx, offset);\n-\t  *loc = simplify_gen_binary (PLUS, GET_MODE (x), new_rtx, XEXP (x, 1));\n+\t  XEXP (x, 0) = new_rtx;\n+\t  *loc = plus_constant (GET_MODE (x), x, offset, true);\n \t  if (changed)\n \t    *changed = true;\n \t  return -1;\n@@ -1622,7 +1622,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t      continue;\n \n \t    start_sequence ();\n-\t    x = replace_equiv_address (x, addr);\n+\t    x = replace_equiv_address (x, addr, true);\n \t    /* It may happen that the address with the virtual reg\n \t       was valid (e.g. based on the virtual stack reg, which might\n \t       be acceptable to the predicates with all offsets), whereas\n@@ -1635,7 +1635,7 @@ instantiate_virtual_regs_in_insn (rtx insn)\n \t    if (!safe_insn_predicate (insn_code, i, x))\n \t      {\n \t\taddr = force_reg (GET_MODE (addr), addr);\n-\t\tx = replace_equiv_address (x, addr);\n+\t\tx = replace_equiv_address (x, addr, true);\n \t      }\n \t    seq = get_insns ();\n \t    end_sequence ();"}, {"sha": "8bead6c763049fe6f1ba6e204766747f652aeafb", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/23b33725083ba1a1c3340b81475f2940d8f2e436/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=23b33725083ba1a1c3340b81475f2940d8f2e436", "patch": "@@ -1952,7 +1952,7 @@ extern int currently_expanding_to_rtl;\n \n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, enum machine_mode);\n-extern rtx plus_constant (enum machine_mode, rtx, HOST_WIDE_INT);\n+extern rtx plus_constant (enum machine_mode, rtx, HOST_WIDE_INT, bool = false);\n \n /* In rtl.c */\n extern rtx rtx_alloc_stat (RTX_CODE MEM_STAT_DECL);"}]}