{"sha": "f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNiMGJiN2E1NjBiZTBmMDViMDkyODc0MDFhMTBjNGM0YjEyY2ZjNg==", "commit": {"author": {"name": "Andre Vehreschild", "email": "vehre@gmx.de", "date": "2015-04-23T11:32:00Z"}, "committer": {"name": "Andre Vehreschild", "email": "vehre@gcc.gnu.org", "date": "2015-04-23T11:32:00Z"}, "message": "PF fortran/60322\n\ngcc/testsuite/ChangeLog:\n\n2015-04-23  Andre Vehreschild  <vehre@gmx.de>\n\n\tPF fortran/60322\n\t* gfortran.dg/class_allocate_19.f03: New test.\n\t* gfortran.dg/class_array_20.f03: New test.\n\t* gfortran.dg/class_array_21.f03: New test.\n\t* gfortran.dg/finalize_10.f90: Corrected scan-trees.\n\t* gfortran.dg/finalize_15.f90: Fixing comparision to model\n\tinitialization correctly.\n\t* gfortran.dg/finalize_29.f08: New test.\n\n\ngcc/fortran/ChangeLog:\n\n2015-04-23  Andre Vehreschild  <vehre@gmx.de>\n\n\tPR fortran/60322\n\t* expr.c (gfc_lval_expr_from_sym): Code to select the regular\n\tor class array added.\n\t* gfortran.h: Add IS_CLASS_ARRAY macro.\n\t* trans-array.c (gfc_add_loop_ss_code): Treat class objects\n\tto be referenced always.\n\t(build_class_array_ref): Adapt retrieval of array descriptor.\n\t(build_array_ref): Likewise.\n\t(gfc_conv_array_ref): Hand the vptr or the descriptor to \n\tbuild_array_ref depending whether the sym is class or not.\n\t(gfc_trans_array_cobounds):  Select correct gfc_array_spec for\n\tregular and class arrays.\n\t(gfc_trans_array_bounds): Likewise.\n\t(gfc_trans_dummy_array_bias): Likewise. \n\t(gfc_get_dataptr_offset): Correcting call of build_array_ref.\n\t(gfc_conv_expr_descriptor): Set the array's offset to -1 when\n\tlbound in inner most dim is 1 and symbol non-pointer/assoc.\n\t* trans-decl.c (gfc_build_qualified_array): Select correct\n\tgfc_array_spec for regular and class arrays.\n\t(gfc_build_dummy_array_decl): Likewise.\n\t(gfc_get_symbol_decl): Get a dummy array for class arrays.\n\t(gfc_trans_deferred_vars): Tell conv_expr that the descriptor\n\tis desired.\n\t* trans-expr.c (gfc_class_vptr_get): Get the class descriptor\n\tfrom the correct location for class arrays.\n\t(gfc_class_len_get): Likewise.\n\t(gfc_conv_intrinsic_to_class): Add handling of _len component.\n\t(gfc_conv_class_to_class):  Prevent access to unset array data\n\twhen the array is an optional argument. Add handling of _len\n\tcomponent.\n\t(gfc_copy_class_to_class): Check that _def_init is non-NULL\n\twhen used in _vptr->copy()\n\t(gfc_trans_class_init_assign): Ensure that the rank of\n\t_def_init is zero.\n\t(gfc_conv_component_ref): Get the _vptr along with _data refs.\n\t(gfc_conv_variable): Make sure the temp array descriptor is\n\treturned for class arrays, too, and that class arrays are\n\tdereferenced correctly.\n\t(gfc_conv_procedure_call): For polymorphic type initialization\n\tthe initializer has to be a pointer to _def_init stored in a\n\tdummy variable, which then needs to be used by value.\n\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Use the\n\ttemporary array descriptor for class arrays, too.\n\t(gfc_conv_intrinsic_storage_size): Likewise.\n\t(gfc_conv_intrinsic_loc): Add ref to _data for BT_CLASS\n\texpressions.\n\t* trans-stmt.c (trans_associate_var): Use a temporary array for\n\tthe associate variable of class arrays, too, making the array\n\tone-based (lbound == 1).\n\t* trans-types.c (gfc_is_nodesc_array): Use the correct\n\tarray data.\n\t* trans.c (gfc_build_array_ref): Use the dummy array descriptor\n\twhen present.\n\t* trans.h: Add class_vptr to gfc_se for storing a class ref's\n\tvptr.\n\nFrom-SVN: r222361", "tree": {"sha": "59696dbb795a0a0b6ebd4e66730a0a3c2315c6d1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/59696dbb795a0a0b6ebd4e66730a0a3c2315c6d1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/comments", "author": {"login": "vehre", "id": 4761547, "node_id": "MDQ6VXNlcjQ3NjE1NDc=", "avatar_url": "https://avatars.githubusercontent.com/u/4761547?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vehre", "html_url": "https://github.com/vehre", "followers_url": "https://api.github.com/users/vehre/followers", "following_url": "https://api.github.com/users/vehre/following{/other_user}", "gists_url": "https://api.github.com/users/vehre/gists{/gist_id}", "starred_url": "https://api.github.com/users/vehre/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vehre/subscriptions", "organizations_url": "https://api.github.com/users/vehre/orgs", "repos_url": "https://api.github.com/users/vehre/repos", "events_url": "https://api.github.com/users/vehre/events{/privacy}", "received_events_url": "https://api.github.com/users/vehre/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "eff973a26bfec7032229170de11cbad63f4a2e64", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eff973a26bfec7032229170de11cbad63f4a2e64", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eff973a26bfec7032229170de11cbad63f4a2e64"}], "stats": {"total": 673, "additions": 541, "deletions": 132}, "files": [{"sha": "263469a5167f3ed15ad29fd336d5b24864c2110a", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -1,3 +1,61 @@\n+2015-04-23  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60322\n+\t* expr.c (gfc_lval_expr_from_sym): Code to select the regular\n+\tor class array added.\n+\t* gfortran.h: Add IS_CLASS_ARRAY macro.\n+\t* trans-array.c (gfc_add_loop_ss_code): Treat class objects\n+\tto be referenced always.\n+\t(build_class_array_ref): Adapt retrieval of array descriptor.\n+\t(build_array_ref): Likewise.\n+\t(gfc_conv_array_ref): Hand the vptr or the descriptor to \n+\tbuild_array_ref depending whether the sym is class or not.\n+\t(gfc_trans_array_cobounds):  Select correct gfc_array_spec for\n+\tregular and class arrays.\n+\t(gfc_trans_array_bounds): Likewise.\n+\t(gfc_trans_dummy_array_bias): Likewise. \n+\t(gfc_get_dataptr_offset): Correcting call of build_array_ref.\n+\t(gfc_conv_expr_descriptor): Set the array's offset to -1 when\n+\tlbound in inner most dim is 1 and symbol non-pointer/assoc.\n+\t* trans-decl.c (gfc_build_qualified_array): Select correct\n+\tgfc_array_spec for regular and class arrays.\n+\t(gfc_build_dummy_array_decl): Likewise.\n+\t(gfc_get_symbol_decl): Get a dummy array for class arrays.\n+\t(gfc_trans_deferred_vars): Tell conv_expr that the descriptor\n+\tis desired.\n+\t* trans-expr.c (gfc_class_vptr_get): Get the class descriptor\n+\tfrom the correct location for class arrays.\n+\t(gfc_class_len_get): Likewise.\n+\t(gfc_conv_intrinsic_to_class): Add handling of _len component.\n+\t(gfc_conv_class_to_class):  Prevent access to unset array data\n+\twhen the array is an optional argument. Add handling of _len\n+\tcomponent.\n+\t(gfc_copy_class_to_class): Check that _def_init is non-NULL\n+\twhen used in _vptr->copy()\n+\t(gfc_trans_class_init_assign): Ensure that the rank of\n+\t_def_init is zero.\n+\t(gfc_conv_component_ref): Get the _vptr along with _data refs.\n+\t(gfc_conv_variable): Make sure the temp array descriptor is\n+\treturned for class arrays, too, and that class arrays are\n+\tdereferenced correctly.\n+\t(gfc_conv_procedure_call): For polymorphic type initialization\n+\tthe initializer has to be a pointer to _def_init stored in a\n+\tdummy variable, which then needs to be used by value.\n+\t* trans-intrinsic.c (gfc_conv_intrinsic_sizeof): Use the\n+\ttemporary array descriptor for class arrays, too.\n+\t(gfc_conv_intrinsic_storage_size): Likewise.\n+\t(gfc_conv_intrinsic_loc): Add ref to _data for BT_CLASS\n+\texpressions.\n+\t* trans-stmt.c (trans_associate_var): Use a temporary array for\n+\tthe associate variable of class arrays, too, making the array\n+\tone-based (lbound == 1).\n+\t* trans-types.c (gfc_is_nodesc_array): Use the correct\n+\tarray data.\n+\t* trans.c (gfc_build_array_ref): Use the dummy array descriptor\n+\twhen present.\n+\t* trans.h: Add class_vptr to gfc_se for storing a class ref's\n+\tvptr.\n+\n 2015-04-22  Steven G. Kargl  <kargl@gcc.gnu.org>\n \n \tPR fortran/65429"}, {"sha": "7f3a59d1d86cd2cd1e61646db5c116b0c034022f", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -4052,17 +4052,18 @@ gfc_expr *\n gfc_lval_expr_from_sym (gfc_symbol *sym)\n {\n   gfc_expr *lval;\n+  gfc_array_spec *as;\n   lval = gfc_get_expr ();\n   lval->expr_type = EXPR_VARIABLE;\n   lval->where = sym->declared_at;\n   lval->ts = sym->ts;\n   lval->symtree = gfc_find_symtree (sym->ns->sym_root, sym->name);\n \n   /* It will always be a full array.  */\n-  lval->rank = sym->as ? sym->as->rank : 0;\n+  as = IS_CLASS_ARRAY (sym) ? CLASS_DATA (sym)->as : sym->as;\n+  lval->rank = as ? as->rank : 0;\n   if (lval->rank)\n-    gfc_add_full_array_ref (lval, sym->ts.type == BT_CLASS ?\n-\t\t\t    CLASS_DATA (sym)->as : sym->as);\n+    gfc_add_full_array_ref (lval, as);\n   return lval;\n }\n "}, {"sha": "832a6ce3ebe8ecb05a9709b3e65fc29100c85336", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -3210,6 +3210,11 @@ bool gfc_is_finalizable (gfc_symbol *, gfc_expr **);\n \t && CLASS_DATA (sym) \\\n \t && CLASS_DATA (sym)->ts.u.derived \\\n \t && CLASS_DATA (sym)->ts.u.derived->attr.unlimited_polymorphic)\n+#define IS_CLASS_ARRAY(sym) \\\n+\t(sym->ts.type == BT_CLASS \\\n+\t && CLASS_DATA (sym) \\\n+\t && CLASS_DATA (sym)->attr.dimension \\\n+\t && !CLASS_DATA (sym)->attr.class_pointer)\n \n /* frontend-passes.c */\n "}, {"sha": "3803cf82aacce12b324070080577e72baccd4c5c", "filename": "gcc/fortran/trans-array.c", "status": "modified", "additions": 86, "deletions": 31, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-array.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -2495,11 +2495,14 @@ gfc_add_loop_ss_code (gfc_loopinfo * loop, gfc_ss * ss, bool subscript,\n \tcase GFC_SS_REFERENCE:\n \t  /* Scalar argument to elemental procedure.  */\n \t  gfc_init_se (&se, NULL);\n-\t  if (ss_info->can_be_null_ref)\n+\t  if (ss_info->can_be_null_ref || (expr->symtree\n+\t\t\t     && (expr->symtree->n.sym->ts.type == BT_DERIVED\n+\t\t\t\t || expr->symtree->n.sym->ts.type == BT_CLASS)))\n \t    {\n \t      /* If the actual argument can be absent (in other words, it can\n \t\t be a NULL reference), don't try to evaluate it; pass instead\n-\t\t the reference directly.  */\n+\t\t the reference directly.  The reference is also needed when\n+\t\t expr is of type class or derived.  */\n \t      gfc_conv_expr_reference (&se, expr);\n \t    }\n \t  else\n@@ -3046,7 +3049,14 @@ build_class_array_ref (gfc_se *se, tree base, tree index)\n \treturn false;\n     }\n   else if (class_ref == NULL)\n-    decl = expr->symtree->n.sym->backend_decl;\n+    {\n+      decl = expr->symtree->n.sym->backend_decl;\n+      /* For class arrays the tree containing the class is stored in\n+\t GFC_DECL_SAVED_DESCRIPTOR of the sym's backend_decl.\n+\t For all others it's sym's backend_decl directly.  */\n+      if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+\tdecl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+    }\n   else\n     {\n       /* Remove everything after the last class reference, convert the\n@@ -3155,30 +3165,45 @@ add_to_offset (tree *cst_offset, tree *offset, tree t)\n \n \n static tree\n-build_array_ref (tree desc, tree offset, tree decl)\n+build_array_ref (tree desc, tree offset, tree decl, tree vptr)\n {\n   tree tmp;\n   tree type;\n+  tree cdecl;\n+  bool classarray = false;\n+\n+  /* For class arrays the class declaration is stored in the saved\n+     descriptor.  */\n+  if (INDIRECT_REF_P (desc)\n+      && DECL_LANG_SPECIFIC (TREE_OPERAND (desc, 0))\n+      && GFC_DECL_SAVED_DESCRIPTOR (TREE_OPERAND (desc, 0)))\n+    cdecl = gfc_class_data_get (GFC_DECL_SAVED_DESCRIPTOR (\n+\t\t\t\t  TREE_OPERAND (desc, 0)));\n+  else\n+    cdecl = desc;\n \n   /* Class container types do not always have the GFC_CLASS_TYPE_P\n      but the canonical type does.  */\n-  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (desc))\n-      && TREE_CODE (desc) == COMPONENT_REF)\n+  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (cdecl))\n+      && TREE_CODE (cdecl) == COMPONENT_REF)\n     {\n-      type = TREE_TYPE (TREE_OPERAND (desc, 0));\n+      type = TREE_TYPE (TREE_OPERAND (cdecl, 0));\n       if (TYPE_CANONICAL (type)\n \t  && GFC_CLASS_TYPE_P (TYPE_CANONICAL (type)))\n-\ttype = TYPE_CANONICAL (type);\n+\t{\n+\t  type = TREE_TYPE (desc);\n+\t  classarray = true;\n+\t}\n     }\n   else\n     type = NULL;\n \n   /* Class array references need special treatment because the assigned\n      type size needs to be used to point to the element.  */\n-  if (type && GFC_CLASS_TYPE_P (type))\n+  if (classarray)\n     {\n-      type = gfc_get_element_type (TREE_TYPE (desc));\n-      tmp = TREE_OPERAND (desc, 0);\n+      type = gfc_get_element_type (type);\n+      tmp = TREE_OPERAND (cdecl, 0);\n       tmp = gfc_get_class_array_ref (offset, tmp);\n       tmp = fold_convert (build_pointer_type (type), tmp);\n       tmp = build_fold_indirect_ref_loc (input_location, tmp);\n@@ -3187,7 +3212,7 @@ build_array_ref (tree desc, tree offset, tree decl)\n \n   tmp = gfc_conv_array_data (desc);\n   tmp = build_fold_indirect_ref_loc (input_location, tmp);\n-  tmp = gfc_build_array_ref (tmp, offset, decl);\n+  tmp = gfc_build_array_ref (tmp, offset, decl, vptr);\n   return tmp;\n }\n \n@@ -3350,7 +3375,8 @@ gfc_conv_array_ref (gfc_se * se, gfc_array_ref * ar, gfc_expr *expr,\n     offset = fold_build2_loc (input_location, PLUS_EXPR,\n \t\t\t      gfc_array_index_type, offset, cst_offset);\n \n-  se->expr = build_array_ref (se->expr, offset, sym->backend_decl);\n+  se->expr = build_array_ref (se->expr, offset, sym->ts.type == BT_CLASS ?\n+\t\t\t\tNULL_TREE : sym->backend_decl, se->class_vptr);\n }\n \n \n@@ -5570,7 +5596,7 @@ gfc_trans_array_cobounds (tree type, stmtblock_t * pblock,\n   gfc_se se;\n   gfc_array_spec *as;\n \n-  as = sym->as;\n+  as = IS_CLASS_ARRAY (sym) ? CLASS_DATA (sym)->as : sym->as;\n \n   for (dim = as->rank; dim < as->rank + as->corank; dim++)\n     {\n@@ -5613,7 +5639,7 @@ gfc_trans_array_bounds (tree type, gfc_symbol * sym, tree * poffset,\n \n   int dim;\n \n-  as = sym->as;\n+  as = IS_CLASS_ARRAY (sym) ? CLASS_DATA (sym)->as : sym->as;\n \n   size = gfc_index_one_node;\n   offset = gfc_index_zero_node;\n@@ -5900,12 +5926,17 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   int checkparm;\n   int no_repack;\n   bool optional_arg;\n+  gfc_array_spec *as;\n+  bool is_classarray = IS_CLASS_ARRAY (sym);\n \n   /* Do nothing for pointer and allocatable arrays.  */\n-  if (sym->attr.pointer || sym->attr.allocatable)\n+  if ((sym->ts.type != BT_CLASS && sym->attr.pointer)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.class_pointer)\n+      || sym->attr.allocatable\n+      || (is_classarray && CLASS_DATA (sym)->attr.allocatable))\n     return;\n \n-  if (sym->attr.dummy && gfc_is_nodesc_array (sym))\n+  if (!is_classarray && sym->attr.dummy && gfc_is_nodesc_array (sym))\n     {\n       gfc_trans_g77_array (sym, block);\n       return;\n@@ -5918,14 +5949,20 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   type = TREE_TYPE (tmpdesc);\n   gcc_assert (GFC_ARRAY_TYPE_P (type));\n   dumdesc = GFC_DECL_SAVED_DESCRIPTOR (tmpdesc);\n-  dumdesc = build_fold_indirect_ref_loc (input_location, dumdesc);\n+  if (is_classarray)\n+    /* For a class array the dummy array descriptor is in the _class\n+       component.  */\n+    dumdesc = gfc_class_data_get (dumdesc);\n+  else\n+    dumdesc = build_fold_indirect_ref_loc (input_location, dumdesc);\n+  as = IS_CLASS_ARRAY (sym) ? CLASS_DATA (sym)->as : sym->as;\n   gfc_start_block (&init);\n \n   if (sym->ts.type == BT_CHARACTER\n       && TREE_CODE (sym->ts.u.cl->backend_decl) == VAR_DECL)\n     gfc_conv_string_length (sym->ts.u.cl, NULL, &init);\n \n-  checkparm = (sym->as->type == AS_EXPLICIT\n+  checkparm = (as->type == AS_EXPLICIT\n \t       && (gfc_option.rtcheck & GFC_RTCHECK_BOUNDS));\n \n   no_repack = !(GFC_DECL_PACKED_ARRAY (tmpdesc)\n@@ -6001,9 +6038,9 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n   size = gfc_index_one_node;\n \n   /* Evaluate the bounds of the array.  */\n-  for (n = 0; n < sym->as->rank; n++)\n+  for (n = 0; n < as->rank; n++)\n     {\n-      if (checkparm || !sym->as->upper[n])\n+      if (checkparm || !as->upper[n])\n \t{\n \t  /* Get the bounds of the actual parameter.  */\n \t  dubound = gfc_conv_descriptor_ubound_get (dumdesc, gfc_rank_cst[n]);\n@@ -6019,21 +6056,21 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n       if (!INTEGER_CST_P (lbound))\n \t{\n \t  gfc_init_se (&se, NULL);\n-\t  gfc_conv_expr_type (&se, sym->as->lower[n],\n+\t  gfc_conv_expr_type (&se, as->lower[n],\n \t\t\t      gfc_array_index_type);\n \t  gfc_add_block_to_block (&init, &se.pre);\n \t  gfc_add_modify (&init, lbound, se.expr);\n \t}\n \n       ubound = GFC_TYPE_ARRAY_UBOUND (type, n);\n       /* Set the desired upper bound.  */\n-      if (sym->as->upper[n])\n+      if (as->upper[n])\n \t{\n \t  /* We know what we want the upper bound to be.  */\n \t  if (!INTEGER_CST_P (ubound))\n \t    {\n \t      gfc_init_se (&se, NULL);\n-\t      gfc_conv_expr_type (&se, sym->as->upper[n],\n+\t      gfc_conv_expr_type (&se, as->upper[n],\n \t\t\t\t  gfc_array_index_type);\n \t      gfc_add_block_to_block (&init, &se.pre);\n \t      gfc_add_modify (&init, ubound, se.expr);\n@@ -6086,7 +6123,7 @@ gfc_trans_dummy_array_bias (gfc_symbol * sym, tree tmpdesc,\n \t\t\t\tgfc_array_index_type, offset, tmp);\n \n       /* The size of this dimension, and the stride of the next.  */\n-      if (n + 1 < sym->as->rank)\n+      if (n + 1 < as->rank)\n \t{\n \t  stride = GFC_TYPE_ARRAY_STRIDE (type, n + 1);\n \n@@ -6234,7 +6271,7 @@ gfc_get_dataptr_offset (stmtblock_t *block, tree parm, tree desc, tree offset,\n \treturn;\n     }\n \n-  tmp = build_array_ref (desc, offset, NULL);\n+  tmp = build_array_ref (desc, offset, NULL, NULL);\n \n   /* Offset the data pointer for pointer assignments from arrays with\n      subreferences; e.g. my_integer => my_type(:)%integer_component.  */\n@@ -6789,6 +6826,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n       tree from;\n       tree to;\n       tree base;\n+      bool onebased = false;\n \n       ndim = info->ref ? info->ref->u.ar.dimen : ss->dimen;\n \n@@ -6930,6 +6968,7 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \t\t\t\t    gfc_array_index_type, to, tmp);\n \t      from = gfc_index_one_node;\n \t    }\n+\t  onebased = integer_onep (from);\n \t  gfc_conv_descriptor_lbound_set (&loop.pre, parm,\n \t\t\t\t\t  gfc_rank_cst[dim], from);\n \n@@ -6986,13 +7025,29 @@ gfc_conv_expr_descriptor (gfc_se *se, gfc_expr *expr)\n \tgfc_get_dataptr_offset (&loop.pre, parm, desc, offset,\n \t\t\t\tsubref_array_target, expr);\n \n-      if (((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n-\t   && !se->data_not_needed)\n-\t  || (se->use_offset && base != NULL_TREE))\n+      /* Force the offset to be -1, when the lower bound of the highest\n+\t dimension is one and the symbol is present and is not a\n+\t pointer/allocatable or associated.  */\n+      if (onebased && se->use_offset\n+\t  && expr->symtree\n+\t  && !(expr->symtree->n.sym && expr->symtree->n.sym->ts.type == BT_CLASS\n+\t       && !CLASS_DATA (expr->symtree->n.sym)->attr.class_pointer)\n+\t  && !expr->symtree->n.sym->attr.allocatable\n+\t  && !expr->symtree->n.sym->attr.pointer\n+\t  && !expr->symtree->n.sym->attr.host_assoc\n+\t  && !expr->symtree->n.sym->attr.use_assoc)\n \t{\n-\t  /* Set the offset.  */\n-\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, base);\n+\t  /* Set the offset to -1.  */\n+\t  mpz_t minus_one;\n+\t  mpz_init_set_si (minus_one, -1);\n+\t  tmp = gfc_conv_mpz_to_tree (minus_one, gfc_index_integer_kind);\n+\t  gfc_conv_descriptor_offset_set (&loop.pre, parm, tmp);\n \t}\n+      else if (((se->direct_byref || GFC_ARRAY_TYPE_P (TREE_TYPE (desc)))\n+\t\t&& !se->data_not_needed)\n+\t       || (se->use_offset && base != NULL_TREE))\n+\t/* Set the offset depending on base.  */\n+\tgfc_conv_descriptor_offset_set (&loop.pre, parm, base);\n       else\n \t{\n \t  /* Only the callee knows what the correct offset it, so just set"}, {"sha": "4c189200658a6865e82478b821713c040c5014bd", "filename": "gcc/fortran/trans-decl.c", "status": "modified", "additions": 87, "deletions": 32, "changes": 119, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-decl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-decl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-decl.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -812,8 +812,13 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   int dim;\n   int nest;\n   gfc_namespace* procns;\n+  symbol_attribute *array_attr;\n+  gfc_array_spec *as;\n+  bool is_classarray = IS_CLASS_ARRAY (sym);\n \n   type = TREE_TYPE (decl);\n+  array_attr = is_classarray ? &CLASS_DATA (sym)->attr : &sym->attr;\n+  as = is_classarray ? CLASS_DATA (sym)->as : sym->as;\n \n   /* We just use the descriptor, if there is one.  */\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n@@ -824,8 +829,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n   nest = (procns->proc_name->backend_decl != current_function_decl)\n \t && !sym->attr.contained;\n \n-  if (sym->attr.codimension && flag_coarray == GFC_FCOARRAY_LIB\n-      && sym->as->type != AS_ASSUMED_SHAPE\n+  if (array_attr->codimension && flag_coarray == GFC_FCOARRAY_LIB\n+      && as->type != AS_ASSUMED_SHAPE\n       && GFC_TYPE_ARRAY_CAF_TOKEN (type) == NULL_TREE)\n     {\n       tree token;\n@@ -878,8 +883,8 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n \t}\n       /* Don't try to use the unknown bound for assumed shape arrays.  */\n       if (GFC_TYPE_ARRAY_UBOUND (type, dim) == NULL_TREE\n-          && (sym->as->type != AS_ASSUMED_SIZE\n-              || dim < GFC_TYPE_ARRAY_RANK (type) - 1))\n+\t  && (as->type != AS_ASSUMED_SIZE\n+\t      || dim < GFC_TYPE_ARRAY_RANK (type) - 1))\n \t{\n \t  GFC_TYPE_ARRAY_UBOUND (type, dim) = create_index_var (\"ubound\", nest);\n \t  TREE_NO_WARNING (GFC_TYPE_ARRAY_UBOUND (type, dim)) = 1;\n@@ -920,7 +925,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     }\n \n   if (GFC_TYPE_ARRAY_SIZE (type) == NULL_TREE\n-      && sym->as->type != AS_ASSUMED_SIZE)\n+      && as->type != AS_ASSUMED_SIZE)\n     {\n       GFC_TYPE_ARRAY_SIZE (type) = create_index_var (\"size\", nest);\n       TREE_NO_WARNING (GFC_TYPE_ARRAY_SIZE (type)) = 1;\n@@ -947,12 +952,12 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     }\n \n   if (TYPE_NAME (type) != NULL_TREE\n-      && GFC_TYPE_ARRAY_UBOUND (type, sym->as->rank - 1) != NULL_TREE\n-      && TREE_CODE (GFC_TYPE_ARRAY_UBOUND (type, sym->as->rank - 1)) == VAR_DECL)\n+      && GFC_TYPE_ARRAY_UBOUND (type, as->rank - 1) != NULL_TREE\n+      && TREE_CODE (GFC_TYPE_ARRAY_UBOUND (type, as->rank - 1)) == VAR_DECL)\n     {\n       tree gtype = DECL_ORIGINAL_TYPE (TYPE_NAME (type));\n \n-      for (dim = 0; dim < sym->as->rank - 1; dim++)\n+      for (dim = 0; dim < as->rank - 1; dim++)\n \t{\n \t  gcc_assert (TREE_CODE (gtype) == ARRAY_TYPE);\n \t  gtype = TREE_TYPE (gtype);\n@@ -966,7 +971,7 @@ gfc_build_qualified_array (tree decl, gfc_symbol * sym)\n     {\n       tree gtype = TREE_TYPE (type), rtype, type_decl;\n \n-      for (dim = sym->as->rank - 1; dim >= 0; dim--)\n+      for (dim = as->rank - 1; dim >= 0; dim--)\n \t{\n \t  tree lbound, ubound;\n \t  lbound = GFC_TYPE_ARRAY_LBOUND (type, dim);\n@@ -1014,41 +1019,56 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n   tree decl;\n   tree type;\n   gfc_array_spec *as;\n+  symbol_attribute *array_attr;\n   char *name;\n   gfc_packed packed;\n   int n;\n   bool known_size;\n-\n-  if (sym->attr.pointer || sym->attr.allocatable\n-      || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n+  bool is_classarray = IS_CLASS_ARRAY (sym);\n+\n+  /* Use the array as and attr.  */\n+  as = is_classarray ? CLASS_DATA (sym)->as : sym->as;\n+  array_attr = is_classarray ? &CLASS_DATA (sym)->attr : &sym->attr;\n+\n+  /* The dummy is returned for pointer, allocatable or assumed rank arrays.\n+     For class arrays the information if sym is an allocatable or pointer\n+     object needs to be checked explicitly (IS_CLASS_ARRAY can be false for\n+     too many reasons to be of use here).  */\n+  if ((sym->ts.type != BT_CLASS && sym->attr.pointer)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.class_pointer)\n+      || array_attr->allocatable\n+      || (as && as->type == AS_ASSUMED_RANK))\n     return dummy;\n \n-  /* Add to list of variables if not a fake result variable.  */\n+  /* Add to list of variables if not a fake result variable.\n+     These symbols are set on the symbol only, not on the class component.  */\n   if (sym->attr.result || sym->attr.dummy)\n     gfc_defer_symbol_init (sym);\n \n-  type = TREE_TYPE (dummy);\n+  /* For a class array the array descriptor is in the _data component, while\n+     for a regular array the TREE_TYPE of the dummy is a pointer to the\n+     descriptor.  */\n+  type = TREE_TYPE (is_classarray ? gfc_class_data_get (dummy)\n+\t\t\t\t  : TREE_TYPE (dummy));\n+  /* type now is the array descriptor w/o any indirection.  */\n   gcc_assert (TREE_CODE (dummy) == PARM_DECL\n-\t  && POINTER_TYPE_P (type));\n+\t  && POINTER_TYPE_P (TREE_TYPE (dummy)));\n \n   /* Do we know the element size?  */\n   known_size = sym->ts.type != BT_CHARACTER\n \t  || INTEGER_CST_P (sym->ts.u.cl->backend_decl);\n \n-  if (known_size && !GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (type)))\n+  if (known_size && !GFC_DESCRIPTOR_TYPE_P (type))\n     {\n       /* For descriptorless arrays with known element size the actual\n          argument is sufficient.  */\n-      gcc_assert (GFC_ARRAY_TYPE_P (type));\n       gfc_build_qualified_array (dummy, sym);\n       return dummy;\n     }\n \n-  type = TREE_TYPE (type);\n   if (GFC_DESCRIPTOR_TYPE_P (type))\n     {\n       /* Create a descriptorless array pointer.  */\n-      as = sym->as;\n       packed = PACKED_NO;\n \n       /* Even when -frepack-arrays is used, symbols with TARGET attribute\n@@ -1079,8 +1099,11 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n \t    packed = PACKED_PARTIAL;\n \t}\n \n-      type = gfc_typenode_for_spec (&sym->ts);\n-      type = gfc_get_nodesc_array_type (type, sym->as, packed,\n+      /* For classarrays the element type is required, but\n+\t gfc_typenode_for_spec () returns the array descriptor.  */\n+      type = is_classarray ? gfc_get_element_type (type)\n+\t\t\t   : gfc_typenode_for_spec (&sym->ts);\n+      type = gfc_get_nodesc_array_type (type, as, packed,\n \t\t\t\t\t!sym->attr.target);\n     }\n   else\n@@ -1110,7 +1133,7 @@ gfc_build_dummy_array_decl (gfc_symbol * sym, tree dummy)\n \n   /* We should never get deferred shape arrays here.  We used to because of\n      frontend bugs.  */\n-  gcc_assert (sym->as->type != AS_DEFERRED);\n+  gcc_assert (as->type != AS_DEFERRED);\n \n   if (packed == PACKED_PARTIAL)\n     GFC_DECL_PARTIAL_PACKED_ARRAY (decl) = 1;\n@@ -1429,13 +1452,30 @@ gfc_get_symbol_decl (gfc_symbol * sym)\n \t  sym->backend_decl = decl;\n \t}\n \n+      /* Returning the descriptor for dummy class arrays is hazardous, because\n+\t some caller is expecting an expression to apply the component refs to.\n+\t Therefore the descriptor is only created and stored in\n+\t sym->backend_decl's GFC_DECL_SAVED_DESCRIPTOR.  The caller is then\n+\t responsible to extract it from there, when the descriptor is\n+\t desired.  */\n+      if (IS_CLASS_ARRAY (sym)\n+\t  && (!DECL_LANG_SPECIFIC (sym->backend_decl)\n+\t      || !GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl)))\n+\t{\n+\t  decl = gfc_build_dummy_array_decl (sym, sym->backend_decl);\n+\t  /* Prevent the dummy from being detected as unused if it is copied.  */\n+\t  if (sym->backend_decl != NULL && decl != sym->backend_decl)\n+\t    DECL_ARTIFICIAL (sym->backend_decl) = 1;\n+\t  sym->backend_decl = decl;\n+\t}\n+\n       TREE_USED (sym->backend_decl) = 1;\n       if (sym->attr.assign && GFC_DECL_ASSIGN (sym->backend_decl) == 0)\n \t{\n \t  gfc_add_assign_aux_vars (sym);\n \t}\n \n-      if (sym->attr.dimension\n+      if ((sym->attr.dimension || IS_CLASS_ARRAY (sym))\n \t  && DECL_LANG_SPECIFIC (sym->backend_decl)\n \t  && GFC_DECL_SAVED_DESCRIPTOR (sym->backend_decl)\n \t  && DECL_CONTEXT (sym->backend_decl) != current_function_decl)\n@@ -3976,18 +4016,31 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t= gfc_class_set_static_fields (sym->backend_decl, vptr, tmp);\n \t  TREE_CONSTANT (DECL_INITIAL (sym->backend_decl)) = 1;\n \t}\n-      else if (sym->attr.dimension || sym->attr.codimension)\n+      else if (sym->attr.dimension || sym->attr.codimension\n+\t       || (IS_CLASS_ARRAY (sym) && !CLASS_DATA (sym)->attr.allocatable))\n \t{\n-          /* Assumed-size Cray pointees need to be treated as AS_EXPLICIT.  */\n-          array_type tmp = sym->as->type;\n-          if (tmp == AS_ASSUMED_SIZE && sym->as->cp_was_assumed)\n-            tmp = AS_EXPLICIT;\n-          switch (tmp)\n+\t  bool is_classarray = IS_CLASS_ARRAY (sym);\n+\t  symbol_attribute *array_attr;\n+\t  gfc_array_spec *as;\n+\t  array_type tmp;\n+\n+\t  array_attr = is_classarray ? &CLASS_DATA (sym)->attr : &sym->attr;\n+\t  as = is_classarray ? CLASS_DATA (sym)->as : sym->as;\n+\t  /* Assumed-size Cray pointees need to be treated as AS_EXPLICIT.  */\n+\t  tmp = as->type;\n+\t  if (tmp == AS_ASSUMED_SIZE && as->cp_was_assumed)\n+\t    tmp = AS_EXPLICIT;\n+\t  switch (tmp)\n \t    {\n \t    case AS_EXPLICIT:\n \t      if (sym->attr.dummy || sym->attr.result)\n \t\tgfc_trans_dummy_array_bias (sym, sym->backend_decl, block);\n-\t      else if (sym->attr.pointer || sym->attr.allocatable)\n+\t      /* Allocatable and pointer arrays need to processed\n+\t\t explicitly.  */\n+\t      else if ((sym->ts.type != BT_CLASS && sym->attr.pointer)\n+\t\t       || (sym->ts.type == BT_CLASS\n+\t\t\t   && CLASS_DATA (sym)->attr.class_pointer)\n+\t\t       || array_attr->allocatable)\n \t\t{\n \t\t  if (TREE_STATIC (sym->backend_decl))\n \t\t    {\n@@ -4002,7 +4055,8 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t      gfc_trans_deferred_array (sym, block);\n \t\t    }\n \t\t}\n-\t      else if (sym->attr.codimension && TREE_STATIC (sym->backend_decl))\n+\t      else if (sym->attr.codimension\n+\t\t       && TREE_STATIC (sym->backend_decl))\n \t\t{\n \t\t  gfc_init_block (&tmpblock);\n \t\t  gfc_trans_array_cobounds (TREE_TYPE (sym->backend_decl),\n@@ -4041,7 +4095,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \n \t    case AS_ASSUMED_SIZE:\n \t      /* Must be a dummy parameter.  */\n-\t      gcc_assert (sym->attr.dummy || sym->as->cp_was_assumed);\n+\t      gcc_assert (sym->attr.dummy || as->cp_was_assumed);\n \n \t      /* We should always pass assumed size arrays the g77 way.  */\n \t      if (sym->attr.dummy)\n@@ -4103,6 +4157,7 @@ gfc_trans_deferred_vars (gfc_symbol * proc_sym, gfc_wrapped_block * block)\n \t\t}\n \t      else\n \t\t{\n+\t\t  se.descriptor_only = 1;\n \t\t  gfc_conv_expr (&se, e);\n \t\t  descriptor = se.expr;\n \t\t  se.expr = gfc_conv_descriptor_data_addr (se.expr);"}, {"sha": "81b72273e454e7f744b57a420ff733e55de988de", "filename": "gcc/fortran/trans-expr.c", "status": "modified", "additions": 160, "deletions": 10, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-expr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-expr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-expr.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -149,6 +149,11 @@ tree\n gfc_class_vptr_get (tree decl)\n {\n   tree vptr;\n+  /* For class arrays decl may be a temporary descriptor handle, the vptr is\n+     then available through the saved descriptor.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+      && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n     decl = build_fold_indirect_ref_loc (input_location, decl);\n   vptr = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n@@ -163,6 +168,11 @@ tree\n gfc_class_len_get (tree decl)\n {\n   tree len;\n+  /* For class arrays decl may be a temporary descriptor handle, the len is\n+     then available through the saved descriptor.  */\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_LANG_SPECIFIC (decl)\n+      && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+    decl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n   if (POINTER_TYPE_P (TREE_TYPE (decl)))\n     decl = build_fold_indirect_ref_loc (input_location, decl);\n   len = gfc_advance_chain (TYPE_FIELDS (TREE_TYPE (decl)),\n@@ -804,6 +814,16 @@ gfc_conv_intrinsic_to_class (gfc_se *parmse, gfc_expr *e,\n \n       gfc_add_modify (&parmse->pre, ctree, tmp);\n     }\n+  else if (class_ts.type == BT_CLASS\n+\t   && class_ts.u.derived->components\n+\t   && class_ts.u.derived->components->ts.u\n+\t\t.derived->attr.unlimited_polymorphic)\n+    {\n+      ctree = gfc_class_len_get (var);\n+      gfc_add_modify (&parmse->pre, ctree,\n+\t\t      fold_convert (TREE_TYPE (ctree),\n+\t\t\t\t    integer_zero_node));\n+    }\n   /* Pass the address of the class object.  */\n   parmse->expr = gfc_build_addr_expr (NULL_TREE, var);\n }\n@@ -830,6 +850,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n   tree tmp;\n   tree vptr;\n   tree cond = NULL_TREE;\n+  tree slen = NULL_TREE;\n   gfc_ref *ref;\n   gfc_ref *class_ref;\n   stmtblock_t block;\n@@ -921,7 +942,12 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n   tmp = NULL_TREE;\n   if (class_ref == NULL\n \t&& e->symtree && e->symtree->n.sym->ts.type == BT_CLASS)\n-    tmp = e->symtree->n.sym->backend_decl;\n+    {\n+      tmp = e->symtree->n.sym->backend_decl;\n+      if (DECL_LANG_SPECIFIC (tmp) && GFC_DECL_SAVED_DESCRIPTOR (tmp))\n+\ttmp = GFC_DECL_SAVED_DESCRIPTOR (tmp);\n+      slen = integer_zero_node;\n+    }\n   else\n     {\n       /* Remove everything after the last class reference, convert the\n@@ -933,6 +959,7 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n       gfc_conv_expr (&tmpse, e);\n       class_ref->next = ref;\n       tmp = tmpse.expr;\n+      slen = tmpse.string_length;\n     }\n \n   gcc_assert (tmp != NULL_TREE);\n@@ -951,11 +978,38 @@ gfc_conv_class_to_class (gfc_se *parmse, gfc_expr *e, gfc_typespec class_ts,\n     gfc_add_modify (&parmse->post, vptr,\n \t\t    fold_convert (TREE_TYPE (vptr), ctree));\n \n+  /* For unlimited polymorphic objects also set the _len component.  */\n+  if (class_ts.type == BT_CLASS\n+      && class_ts.u.derived->components\n+      && class_ts.u.derived->components->ts.u\n+\t\t      .derived->attr.unlimited_polymorphic)\n+    {\n+      ctree = gfc_class_len_get (var);\n+      if (UNLIMITED_POLY (e))\n+\ttmp = gfc_class_len_get (tmp);\n+      else if (e->ts.type == BT_CHARACTER)\n+\t{\n+\t  gcc_assert (slen != NULL_TREE);\n+\t  tmp = slen;\n+\t}\n+      else\n+\ttmp = integer_zero_node;\n+      gfc_add_modify (&parmse->pre, ctree,\n+\t\t      fold_convert (TREE_TYPE (ctree), tmp));\n+    }\n+\n   if (optional)\n     {\n       tree tmp2;\n \n       cond = gfc_conv_expr_present (e->symtree->n.sym);\n+      /* parmse->pre may contain some preparatory instructions for the\n+ \t temporary array descriptor.  Those may only be executed when the\n+\t optional argument is set, therefore add parmse->pre's instructions\n+\t to block, which is later guarded by an if (optional_arg_given).  */\n+      gfc_add_block_to_block (&parmse->pre, &block);\n+      block.head = parmse->pre.head;\n+      parmse->pre.head = NULL_TREE;\n       tmp = gfc_finish_block (&block);\n \n       if (optional_alloc_ptr)\n@@ -1042,7 +1096,7 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n   fcn_type = TREE_TYPE (TREE_TYPE (fcn));\n \n   if (from != NULL_TREE)\n-      from_data = gfc_class_data_get (from);\n+    from_data = gfc_class_data_get (from);\n   else\n     from_data = gfc_class_vtab_def_init_get (to);\n \n@@ -1099,7 +1153,8 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       gfc_init_block (&ifbody);\n       gfc_add_block_to_block (&ifbody, &loop.pre);\n       stdcopy = gfc_finish_block (&ifbody);\n-      if (unlimited)\n+      /* In initialization mode from_len is a constant zero.  */\n+      if (unlimited && !integer_zerop (from_len))\n \t{\n \t  vec_safe_push (args, from_len);\n \t  vec_safe_push (args, to_len);\n@@ -1141,7 +1196,8 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n       vec_safe_push (args, to_data);\n       stdcopy = build_call_vec (fcn_type, fcn, args);\n \n-      if (unlimited)\n+      /* In initialization mode from_len is a constant zero.  */\n+      if (unlimited && !integer_zerop (from_len))\n \t{\n \t  vec_safe_push (args, from_len);\n \t  vec_safe_push (args, to_len);\n@@ -1156,6 +1212,18 @@ gfc_copy_class_to_class (tree from, tree to, tree nelems, bool unlimited)\n \ttmp = stdcopy;\n     }\n \n+  /* Only copy _def_init to to_data, when it is not a NULL-pointer.  */\n+  if (from == NULL_TREE)\n+    {\n+      tree cond;\n+      cond = fold_build2_loc (input_location, NE_EXPR,\n+\t\t\t      boolean_type_node,\n+\t\t\t      from_data, null_pointer_node);\n+      tmp = fold_build3_loc (input_location, COND_EXPR,\n+\t\t\t     void_type_node, cond,\n+\t\t\t     tmp, build_empty_stmt (input_location));\n+    }\n+\n   return tmp;\n }\n \n@@ -1229,6 +1297,8 @@ gfc_trans_class_init_assign (gfc_code *code)\n      been referenced.  */\n   gfc_get_derived_type (rhs->ts.u.derived);\n   gfc_add_def_init_component (rhs);\n+  /* The _def_init is always scalar.  */\n+  rhs->rank = 0;\n \n   if (code->expr1->ts.type == BT_CLASS\n \t&& CLASS_DATA (code->expr1)->attr.dimension)\n@@ -2203,6 +2273,16 @@ gfc_conv_component_ref (gfc_se * se, gfc_ref * ref)\n       field = f2;\n     }\n \n+  if (ref->u.c.sym && ref->u.c.sym->ts.type == BT_CLASS\n+      && strcmp (\"_data\", c->name) == 0)\n+    {\n+      /* Found a ref to the _data component.  Store the associated ref to\n+\t the vptr in se->class_vptr.  */\n+      se->class_vptr = gfc_class_vptr_get (decl);\n+    }\n+  else\n+    se->class_vptr = NULL_TREE;\n+\n   tmp = fold_build3_loc (input_location, COMPONENT_REF, TREE_TYPE (field),\n \t\t\t decl, field, NULL_TREE);\n \n@@ -2284,8 +2364,11 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n   bool return_value;\n   bool alternate_entry;\n   bool entry_master;\n+  bool is_classarray;\n+  bool first_time = true;\n \n   sym = expr->symtree->n.sym;\n+  is_classarray = IS_CLASS_ARRAY (sym);\n   ss = se->ss;\n   if (ss != NULL)\n     {\n@@ -2389,9 +2472,24 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t}\n       else if (!sym->attr.value)\n \t{\n+\t  /* Dereference temporaries for class array dummy arguments.  */\n+\t  if (sym->attr.dummy && is_classarray\n+\t      && GFC_ARRAY_TYPE_P (TREE_TYPE (se->expr)))\n+\t    {\n+\t      if (!se->descriptor_only)\n+\t\tse->expr = GFC_DECL_SAVED_DESCRIPTOR (se->expr);\n+\n+\t      se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\t      se->expr);\n+\t    }\n+\n \t  /* Dereference non-character scalar dummy arguments.  */\n \t  if (sym->attr.dummy && !sym->attr.dimension\n-\t      && !(sym->attr.codimension && sym->attr.allocatable))\n+\t      && !(sym->attr.codimension && sym->attr.allocatable)\n+\t      && (sym->ts.type != BT_CLASS\n+\t\t  || (!CLASS_DATA (sym)->attr.dimension\n+\t\t      && !(CLASS_DATA (sym)->attr.codimension\n+\t\t\t   && CLASS_DATA (sym)->attr.allocatable))))\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n@@ -2403,18 +2501,45 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n \n-\t  /* Dereference non-character pointer variables.\n+\t  /* Dereference non-character, non-class pointer variables.\n \t     These must be dummies, results, or scalars.  */\n-\t  if ((sym->attr.pointer || sym->attr.allocatable\n-\t       || gfc_is_associate_pointer (sym)\n-\t       || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n+\t  if (!is_classarray\n+\t      && (sym->attr.pointer || sym->attr.allocatable\n+\t\t  || gfc_is_associate_pointer (sym)\n+\t\t  || (sym->as && sym->as->type == AS_ASSUMED_RANK))\n \t      && (sym->attr.dummy\n \t\t  || sym->attr.function\n \t\t  || sym->attr.result\n \t\t  || (!sym->attr.dimension\n \t\t      && (!sym->attr.codimension || !sym->attr.allocatable))))\n \t    se->expr = build_fold_indirect_ref_loc (input_location,\n \t\t\t\t\t\tse->expr);\n+\t  /* Now treat the class array pointer variables accordingly.  */\n+\t  else if (sym->ts.type == BT_CLASS\n+\t\t   && sym->attr.dummy\n+\t\t   && (CLASS_DATA (sym)->attr.dimension\n+\t\t       || CLASS_DATA (sym)->attr.codimension)\n+\t\t   && ((CLASS_DATA (sym)->as\n+\t\t\t&& CLASS_DATA (sym)->as->type == AS_ASSUMED_RANK)\n+\t\t       || CLASS_DATA (sym)->attr.allocatable\n+\t\t       || CLASS_DATA (sym)->attr.class_pointer))\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n+\t  /* And the case where a non-dummy, non-result, non-function,\n+\t     non-allotable and non-pointer classarray is present.  This case was\n+\t     previously covered by the first if, but with introducing the\n+\t     condition !is_classarray there, that case has to be covered\n+\t     explicitly.  */\n+\t  else if (sym->ts.type == BT_CLASS\n+\t\t   && !sym->attr.dummy\n+\t\t   && !sym->attr.function\n+\t\t   && !sym->attr.result\n+\t\t   && (CLASS_DATA (sym)->attr.dimension\n+\t\t       || CLASS_DATA (sym)->attr.codimension)\n+\t\t   && !CLASS_DATA (sym)->attr.allocatable\n+\t\t   && !CLASS_DATA (sym)->attr.class_pointer)\n+\t    se->expr = build_fold_indirect_ref_loc (input_location,\n+\t\t\t\t\t\tse->expr);\n \t}\n \n       ref = expr->ref;\n@@ -2452,6 +2577,18 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  break;\n \n \tcase REF_COMPONENT:\n+\t  if (first_time && is_classarray && sym->attr.dummy\n+\t      && se->descriptor_only\n+\t      && !CLASS_DATA (sym)->attr.allocatable\n+\t      && !CLASS_DATA (sym)->attr.class_pointer\n+\t      && CLASS_DATA (sym)->as\n+\t      && CLASS_DATA (sym)->as->type != AS_ASSUMED_RANK\n+\t      && strcmp (\"_data\", ref->u.c.component->name) == 0)\n+\t    /* Skip the first ref of a _data component, because for class\n+\t       arrays that one is already done by introducing a temporary\n+\t       array descriptor.  */\n+\t    break;\n+\n \t  if (ref->u.c.sym->attr.extension)\n \t    conv_parent_component_references (se, ref);\n \n@@ -2471,6 +2608,7 @@ gfc_conv_variable (gfc_se * se, gfc_expr * expr)\n \t  gcc_unreachable ();\n \t  break;\n \t}\n+      first_time = false;\n       ref = ref->next;\n     }\n   /* Pointer assignment, allocation or pass by reference.  Arrays are handled\n@@ -4597,7 +4735,19 @@ gfc_conv_procedure_call (gfc_se * se, gfc_symbol * sym,\n \t  gfc_init_se (&parmse, se);\n \t  parm_kind = ELEMENTAL;\n \n-\t  if (fsym && fsym->attr.value)\n+\t  /* For all value functions or polymorphic scalar non-pointer\n+\t     non-allocatable variables use the expression in e directly.  This\n+\t     ensures, that initializers of polymorphic entities are correctly\n+\t     copied.  */\n+\t  if (fsym && (fsym->attr.value\n+\t\t       || (e->expr_type == EXPR_VARIABLE\n+\t\t\t   && fsym->ts.type == BT_DERIVED\n+\t\t\t   && e->ts.type == BT_DERIVED\n+\t\t\t   && !e->ts.u.derived->attr.dimension\n+\t\t\t   && !e->rank\n+\t\t\t   && (!e->symtree\n+\t\t\t       || (!e->symtree->n.sym->attr.allocatable\n+\t\t\t\t   && !e->symtree->n.sym->attr.pointer)))))\n \t    gfc_conv_expr (&parmse, e);\n \t  else\n \t    gfc_conv_expr_reference (&parmse, e);"}, {"sha": "20e5b37e240ba4824dc8a4f234d8ff11ff76cab0", "filename": "gcc/fortran/trans-intrinsic.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-intrinsic.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-intrinsic.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-intrinsic.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -5921,8 +5921,17 @@ gfc_conv_intrinsic_sizeof (gfc_se *se, gfc_expr *expr)\n     }\n   else if (arg->ts.type == BT_CLASS)\n     {\n-      if (arg->rank)\n+      /* For deferred length arrays, conv_expr_descriptor returns an\n+\t indirect_ref to the component.  */\n+      if (arg->rank < 0\n+\t  || (arg->rank > 0 && !VAR_P (argse.expr)\n+\t      && GFC_DECL_CLASS (TREE_OPERAND (argse.expr, 0))))\n \tbyte_size = gfc_class_vtab_size_get (TREE_OPERAND (argse.expr, 0));\n+      else if (arg->rank > 0)\n+\t/* The scalarizer added an additional temp.  To get the class' vptr\n+\t   one has to look at the original backend_decl.  */\n+\tbyte_size = gfc_class_vtab_size_get (\n+\t      GFC_DECL_SAVED_DESCRIPTOR (arg->symtree->n.sym->backend_decl));\n       else\n \tbyte_size = gfc_class_vtab_size_get (argse.expr);\n     }\n@@ -6053,7 +6062,11 @@ gfc_conv_intrinsic_storage_size (gfc_se *se, gfc_expr *expr)\n       gfc_conv_expr_descriptor (&argse, arg);\n       if (arg->ts.type == BT_CLASS)\n \t{\n-\t  tmp = gfc_class_vtab_size_get (TREE_OPERAND (argse.expr, 0));\n+\t  if (arg->rank > 0)\n+\t    tmp = gfc_class_vtab_size_get (\n+\t\t GFC_DECL_SAVED_DESCRIPTOR (arg->symtree->n.sym->backend_decl));\n+\t  else\n+\t    tmp = gfc_class_vtab_size_get (TREE_OPERAND (argse.expr, 0));\n \t  tmp = fold_convert (result_type, tmp);\n \t  goto done;\n \t}\n@@ -7080,7 +7093,11 @@ gfc_conv_intrinsic_loc (gfc_se * se, gfc_expr * expr)\n \n   arg_expr = expr->value.function.actual->expr;\n   if (arg_expr->rank == 0)\n-    gfc_conv_expr_reference (se, arg_expr);\n+    {\n+      if (arg_expr->ts.type == BT_CLASS)\n+\tgfc_add_component_ref (arg_expr, \"_data\");\n+      gfc_conv_expr_reference (se, arg_expr);\n+    }\n   else\n     gfc_conv_array_parameter (se, arg_expr, true, NULL, NULL, NULL);\n   se->expr = convert (gfc_get_int_type (gfc_index_integer_kind), se->expr);"}, {"sha": "53e9bcc73ce7dc3480954e7f4649580246ff09de", "filename": "gcc/fortran/trans-stmt.c", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-stmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-stmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-stmt.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -1390,12 +1390,29 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \n       gfc_init_se (&se, NULL);\n       se.descriptor_only = 1;\n-      gfc_conv_expr (&se, e);\n+      /* In a select type the (temporary) associate variable shall point to\n+\t a standard fortran array (lower bound == 1), but conv_expr ()\n+\t just maps to the input array in the class object, whose lbound may\n+\t be arbitrary.  conv_expr_descriptor solves this by inserting a\n+\t temporary array descriptor.  */\n+      gfc_conv_expr_descriptor (&se, e);\n \n-      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr)));\n+      gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (se.expr))\n+\t\t  || GFC_ARRAY_TYPE_P (TREE_TYPE (se.expr)));\n       gcc_assert (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (sym->backend_decl)));\n \n-      gfc_add_modify (&se.pre, sym->backend_decl, se.expr);\n+      if (GFC_ARRAY_TYPE_P (TREE_TYPE (se.expr)))\n+\t{\n+\t  if (INDIRECT_REF_P (se.expr))\n+\t    tmp = TREE_OPERAND (se.expr, 0);\n+\t  else\n+\t    tmp = se.expr;\n+\n+\t  gfc_add_modify (&se.pre, sym->backend_decl,\n+\t\t\t  gfc_class_data_get (GFC_DECL_SAVED_DESCRIPTOR (tmp)));\n+\t}\n+      else\n+\tgfc_add_modify (&se.pre, sym->backend_decl, se.expr);\n \n       if (unlimited)\n \t{\n@@ -1406,7 +1423,7 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t\t\t  gfc_get_dtype (TREE_TYPE (sym->backend_decl)));\n \t}\n \n-      gfc_add_init_cleanup (block, gfc_finish_block( &se.pre),\n+      gfc_add_init_cleanup (block, gfc_finish_block (&se.pre),\n \t\t\t    gfc_finish_block (&se.post));\n     }\n \n@@ -1449,9 +1466,18 @@ trans_associate_var (gfc_symbol *sym, gfc_wrapped_block *block)\n \t    }\n \t  if (need_len_assign)\n \t    {\n-\t      /* Get the _len comp from the target expr by stripping _data\n-\t\t from it and adding component-ref to _len.  */\n-\t      tmp = gfc_class_len_get (TREE_OPERAND (target_expr, 0));\n+\t      if (e->symtree\n+\t\t  && DECL_LANG_SPECIFIC (e->symtree->n.sym->backend_decl)\n+\t\t && GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl))\n+\t\t/* Use the original class descriptor stored in the saved\n+\t\t   descriptor to get the target_expr.  */\n+\t\ttarget_expr =\n+\t\t    GFC_DECL_SAVED_DESCRIPTOR (e->symtree->n.sym->backend_decl);\n+\t      else\n+\t\t/* Strip the _data component from the target_expr.  */\n+\t\ttarget_expr = TREE_OPERAND (target_expr, 0);\n+\t      /* Add a reference to the _len comp to the target expr.  */\n+\t      tmp = gfc_class_len_get (target_expr);\n \t      /* Get the component-ref for the temp structure's _len comp.  */\n \t      charlen = gfc_class_len_get (se.expr);\n \t      /* Add the assign to the beginning of the the block...  */"}, {"sha": "25334785b875d949d7c1e8cb31a0c9293ce30a19", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 17, "deletions": 7, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -1288,25 +1288,35 @@ gfc_get_element_type (tree type)\n int\n gfc_is_nodesc_array (gfc_symbol * sym)\n {\n-  gcc_assert (sym->attr.dimension || sym->attr.codimension);\n+  symbol_attribute *array_attr;\n+  gfc_array_spec *as;\n+  bool is_classarray = IS_CLASS_ARRAY (sym);\n+\n+  array_attr = is_classarray ? &CLASS_DATA (sym)->attr : &sym->attr;\n+  as = is_classarray ? CLASS_DATA (sym)->as : sym->as;\n+\n+  gcc_assert (array_attr->dimension || array_attr->codimension);\n \n   /* We only want local arrays.  */\n-  if (sym->attr.pointer || sym->attr.allocatable)\n+  if ((sym->ts.type != BT_CLASS && sym->attr.pointer)\n+      || (sym->ts.type == BT_CLASS && CLASS_DATA (sym)->attr.class_pointer)\n+      || array_attr->allocatable)\n     return 0;\n \n   /* We want a descriptor for associate-name arrays that do not have an\n-     explicitly known shape already.  */\n-  if (sym->assoc && sym->as->type != AS_EXPLICIT)\n+\t explicitly known shape already.  */\n+  if (sym->assoc && as->type != AS_EXPLICIT)\n     return 0;\n \n+  /* The dummy is stored in sym and not in the component.  */\n   if (sym->attr.dummy)\n-    return sym->as->type != AS_ASSUMED_SHAPE\n-\t   && sym->as->type != AS_ASSUMED_RANK;\n+    return as->type != AS_ASSUMED_SHAPE\n+\t&& as->type != AS_ASSUMED_RANK;\n \n   if (sym->attr.result || sym->attr.function)\n     return 0;\n \n-  gcc_assert (sym->as->type == AS_EXPLICIT || sym->as->cp_was_assumed);\n+  gcc_assert (as->type == AS_EXPLICIT || as->cp_was_assumed);\n \n   return 1;\n }"}, {"sha": "2dabf0827b3c03079e52055c0e8eb47ba6af2b09", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -321,7 +321,7 @@ gfc_build_addr_expr (tree type, tree t)\n /* Build an ARRAY_REF with its natural type.  */\n \n tree\n-gfc_build_array_ref (tree base, tree offset, tree decl)\n+gfc_build_array_ref (tree base, tree offset, tree decl, tree vptr)\n {\n   tree type = TREE_TYPE (base);\n   tree tmp;\n@@ -353,30 +353,47 @@ gfc_build_array_ref (tree base, tree offset, tree decl)\n   /* If the array reference is to a pointer, whose target contains a\n      subreference, use the span that is stored with the backend decl\n      and reference the element with pointer arithmetic.  */\n-  if (decl && (TREE_CODE (decl) == FIELD_DECL\n-\t\t || TREE_CODE (decl) == VAR_DECL\n-\t\t || TREE_CODE (decl) == PARM_DECL)\n-\t&& ((GFC_DECL_SUBREF_ARRAY_P (decl)\n-\t      && !integer_zerop (GFC_DECL_SPAN(decl)))\n+  if ((decl && (TREE_CODE (decl) == FIELD_DECL\n+\t\t|| TREE_CODE (decl) == VAR_DECL\n+\t\t|| TREE_CODE (decl) == PARM_DECL)\n+       && ((GFC_DECL_SUBREF_ARRAY_P (decl)\n+\t    && !integer_zerop (GFC_DECL_SPAN (decl)))\n \t   || GFC_DECL_CLASS (decl)))\n+      || vptr)\n     {\n-      if (GFC_DECL_CLASS (decl))\n+      if (decl)\n \t{\n-\t  /* Allow for dummy arguments and other good things.  */\n-\t  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n-\t    decl = build_fold_indirect_ref_loc (input_location, decl);\n-\n-\t  /* Check if '_data' is an array descriptor. If it is not,\n-\t     the array must be one of the components of the class object,\n-\t     so return a normal array reference.  */\n-\t  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (gfc_class_data_get (decl))))\n-\t    return build4_loc (input_location, ARRAY_REF, type, base,\n-\t\t\t       offset, NULL_TREE, NULL_TREE);\n-\n-\t  span = gfc_class_vtab_size_get (decl);\n+\t  if (GFC_DECL_CLASS (decl))\n+\t    {\n+\t      /* When a temporary is in place for the class array, then the\n+\t\t original class' declaration is stored in the saved\n+\t\t descriptor.  */\n+\t      if (DECL_LANG_SPECIFIC (decl) && GFC_DECL_SAVED_DESCRIPTOR (decl))\n+\t\tdecl = GFC_DECL_SAVED_DESCRIPTOR (decl);\n+\t      else\n+\t\t{\n+\t\t  /* Allow for dummy arguments and other good things.  */\n+\t\t  if (POINTER_TYPE_P (TREE_TYPE (decl)))\n+\t\t    decl = build_fold_indirect_ref_loc (input_location, decl);\n+\n+\t\t  /* Check if '_data' is an array descriptor.  If it is not,\n+\t\t     the array must be one of the components of the class\n+\t\t     object, so return a normal array reference.  */\n+\t\t  if (!GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (\n+\t\t\t\t\t\tgfc_class_data_get (decl))))\n+\t\t    return build4_loc (input_location, ARRAY_REF, type, base,\n+\t\t\t\t       offset, NULL_TREE, NULL_TREE);\n+\t\t}\n+\n+\t      span = gfc_class_vtab_size_get (decl);\n+\t    }\n+\t  else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n+\t    span = GFC_DECL_SPAN (decl);\n+\t  else\n+\t    gcc_unreachable ();\n \t}\n-      else if (GFC_DECL_SUBREF_ARRAY_P (decl))\n-\tspan = GFC_DECL_SPAN(decl);\n+      else if (vptr)\n+\tspan = gfc_vptr_size_get (vptr);\n       else\n \tgcc_unreachable ();\n "}, {"sha": "e2a1fea98145832ebb47b667fb4ec3632fd005f1", "filename": "gcc/fortran/trans.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ffortran%2Ftrans.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.h?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -49,6 +49,10 @@ typedef struct gfc_se\n   /* The length of a character string value.  */\n   tree string_length;\n \n+  /* When expr is a reference to a class object, store its vptr access\n+     here.  */\n+  tree class_vptr;\n+\n   /* If set gfc_conv_variable will return an expression for the array\n      descriptor. When set, want_pointer should also be set.\n      If not set scalarizing variables will be substituted.  */\n@@ -528,7 +532,7 @@ tree gfc_get_function_decl (gfc_symbol *);\n tree gfc_build_addr_expr (tree, tree);\n \n /* Build an ARRAY_REF.  */\n-tree gfc_build_array_ref (tree, tree, tree);\n+tree gfc_build_array_ref (tree, tree, tree, tree vptr = NULL_TREE);\n \n /* Creates a label.  Decl is artificial if label_id == NULL_TREE.  */\n tree gfc_build_label_decl (tree);"}, {"sha": "ed4491098669e615b7819ff260989efb029b9d10", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -1,3 +1,14 @@\n+2015-04-23  Andre Vehreschild  <vehre@gmx.de>\n+\n+\tPR fortran/60322\n+\t* gfortran.dg/class_allocate_19.f03: New test.\n+\t* gfortran.dg/class_array_20.f03: New test.\n+\t* gfortran.dg/class_array_21.f03: New test.\n+\t* gfortran.dg/finalize_10.f90: Corrected scan-trees.\n+\t* gfortran.dg/finalize_15.f90: Fixing comparision to model\n+\tinitialization correctly.\n+\t* gfortran.dg/finalize_29.f08: New test.\n+\n 2015-04-22  Bill Schmidt  <wschmidt@linux.vnet.ibm.com>\n \n \t* gcc.target/powerpc/swaps-p8-18.c: New test."}, {"sha": "32386ce570350aa77766f027a6c93c92cb68e284", "filename": "gcc/testsuite/gfortran.dg/finalize_10.f90", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_10.f90?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -27,8 +27,8 @@ end subroutine foo\n ! Finalize CLASS + set default init\n ! { dg-final { scan-tree-dump-times \"y->_vptr->_final \\\\(&desc.\\[0-9\\]+, y->_vptr->_size, 0\\\\);\" 1 \"original\" } }\n ! { dg-final { scan-tree-dump       \"__builtin_memcpy \\\\(\\\\(void .\\\\) y->_data, \\\\(void .\\\\) y->_vptr->_def_init, \\\\((unsigned long|unsigned int|character\\\\(kind=4\\\\))\\\\) y->_vptr->_size\\\\);\" \"original\" } }\n-! { dg-final { scan-tree-dump-times \"x->_vptr->_final \\\\(&x->_data, x->_vptr->_size, 0\\\\);\" 1 \"original\" } }\n-! { dg-final { scan-tree-dump-times \"x->_vptr->_copy \\\\(x->_vptr->_def_init, &x->_data\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"x->_vptr->_final \\\\(&parm.\\[0-9\\]+, x->_vptr->_size, 0\\\\);\" 1 \"original\" } }\n+! { dg-final { scan-tree-dump-times \"x->_vptr->_copy \\\\(\" 1 \"original\" } }\n \n ! FINALIZE TYPE:\n ! { dg-final { scan-tree-dump-times \"parm.\\[0-9\\]+.data = \\\\(void \\\\*\\\\) &\\\\(\\\\*aa.\\[0-9\\]+\\\\)\\\\\\[0\\\\\\];\" 1 \"original\" } }"}, {"sha": "d5ba28f14d3c92a25ba1a774cd8d015da98d029c", "filename": "gcc/testsuite/gfortran.dg/finalize_15.f90", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_15.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3b0bb7a560be0f05b09287401a10c4c4b12cfc6/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_15.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Ffinalize_15.f90?ref=f3b0bb7a560be0f05b09287401a10c4c4b12cfc6", "patch": "@@ -9,37 +9,37 @@ module m\n   implicit none\n \n   type t1\n-    integer :: i\n+    integer :: i = 1\n   contains\n     final :: fini_elem\n   end type t1\n \n   type, extends(t1) :: t1e\n-    integer :: j\n+    integer :: j = 11\n   contains\n     final :: fini_elem2\n   end type t1e\n \n   type t2\n-    integer :: i\n+    integer :: i = 2\n   contains\n     final :: fini_shape\n   end type t2\n \n   type, extends(t2) :: t2e\n-    integer :: j\n+    integer :: j = 22\n   contains\n     final :: fini_shape2\n   end type t2e\n \n   type t3\n-    integer :: i\n+    integer :: i = 3\n   contains\n     final :: fini_explicit\n   end type t3\n \n   type, extends(t3) :: t3e\n-    integer :: j\n+    integer :: j = 33\n   contains\n     final :: fini_explicit2\n   end type t3e\n@@ -204,31 +204,31 @@ program test\n \n   select type(x)\n     type is (t1e)\n-      call check_val(x%i, 1)\n-      call check_val(x%j, 100)\n+      call check_val(x%i, 1, 1)\n+      call check_val(x%j, 100, 11)\n   end select\n \n   select type(y)\n     type is (t2e)\n-      call check_val(y%i, 1)\n-      call check_val(y%j, 100)\n+      call check_val(y%i, 1, 2)\n+      call check_val(y%j, 100, 22)\n   end select\n \n   select type(z)\n     type is (t3e)\n-      call check_val(z%i, 1)\n-      call check_val(z%j, 100)\n+      call check_val(z%i, 1, 3)\n+      call check_val(z%j, 100, 33)\n   end select\n \n contains\n-  subroutine check_val(x, factor)\n+  subroutine check_val(x, factor, val)\n     integer :: x(:,:)\n-    integer, value :: factor\n+    integer, value :: factor, val\n     integer :: i, j\n     do i = 1, 10\n       do j = 1, 10\n         if (mod (j-1, 2) == 0 .and. mod (i-1, 3) == 0) then\n-          if (x(j,i) /= (j + 100*i)*factor*(-13)) call abort ()\n+          if (x(j,i) /= val) call abort ()\n         else\n           if (x(j,i) /= (j + 100*i)*factor) call abort ()\n         end if"}]}