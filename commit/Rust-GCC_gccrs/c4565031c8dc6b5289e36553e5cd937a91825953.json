{"sha": "c4565031c8dc6b5289e36553e5cd937a91825953", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzQ1NjUwMzFjOGRjNmI1Mjg5ZTM2NTUzZTVjZDkzN2E5MTgyNTk1Mw==", "commit": {"author": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-08-23T14:34:27Z"}, "committer": {"name": "Paul Thomas", "email": "pault@gcc.gnu.org", "date": "2020-08-23T14:34:27Z"}, "message": "This patch fixes PR96737. See the explanatory comment in the testcase.\n\n2020-08-23  Paul Thomas  <pault@gcc.gnu.org>\n\ngcc/fortran\n\tPR fortran/96737\n\t* trans-types.c (gfc_get_derived_type): Derived types that are\n\tused in submodules are not compatible with TYPE_CANONICAL from\n\tany of the global namespaces.\n\ngcc/testsuite/\n\tPR fortran/96737\n\t* gfortran.dg/pr96737.f90: New test.", "tree": {"sha": "066a1a57b8fbba30b69a6e435da2d1755f686cc2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/066a1a57b8fbba30b69a6e435da2d1755f686cc2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c4565031c8dc6b5289e36553e5cd937a91825953", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4565031c8dc6b5289e36553e5cd937a91825953", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c4565031c8dc6b5289e36553e5cd937a91825953", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c4565031c8dc6b5289e36553e5cd937a91825953/comments", "author": null, "committer": null, "parents": [{"sha": "e769f9707d6f1e2c6dc9e8197119634ff2c44b76", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e769f9707d6f1e2c6dc9e8197119634ff2c44b76", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e769f9707d6f1e2c6dc9e8197119634ff2c44b76"}], "stats": {"total": 109, "additions": 107, "deletions": 2}, "files": [{"sha": "d38aa2865ae85a56064345aa384ee66e5b80aeac", "filename": "gcc/fortran/trans-types.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4565031c8dc6b5289e36553e5cd937a91825953/gcc%2Ffortran%2Ftrans-types.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4565031c8dc6b5289e36553e5cd937a91825953/gcc%2Ffortran%2Ftrans-types.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-types.c?ref=c4565031c8dc6b5289e36553e5cd937a91825953", "patch": "@@ -2559,14 +2559,16 @@ gfc_get_derived_type (gfc_symbol * derived, int codimen)\n \n   /* If use associated, use the module type for this one.  */\n   if (derived->backend_decl == NULL\n-      && derived->attr.use_assoc\n+      && (derived->attr.use_assoc || derived->attr.used_in_submodule)\n       && derived->module\n       && gfc_get_module_backend_decl (derived))\n     goto copy_derived_types;\n \n   /* The derived types from an earlier namespace can be used as the\n      canonical type.  */\n-  if (derived->backend_decl == NULL && !derived->attr.use_assoc\n+  if (derived->backend_decl == NULL\n+      && !derived->attr.use_assoc\n+      && !derived->attr.used_in_submodule\n       && gfc_global_ns_list)\n     {\n       for (ns = gfc_global_ns_list;"}, {"sha": "c92085cc148cc777df6c6a261d55204d02e3940e", "filename": "gcc/testsuite/gfortran.dg/pr96737.f90", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c4565031c8dc6b5289e36553e5cd937a91825953/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr96737.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c4565031c8dc6b5289e36553e5cd937a91825953/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr96737.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fpr96737.f90?ref=c4565031c8dc6b5289e36553e5cd937a91825953", "patch": "@@ -0,0 +1,103 @@\n+! { dg-do compile }\n+! { dg-options \"-fcoarray=single\" }\n+!\n+! Test the fix for PR96737 in which the 'TYPE_CANONICAL' was not campatible\n+! in the submodule.\n+!\n+! Contributed by Andre Vehreschild  <vehre@gcc.gnu.org>\n+!\n+module surface_packages\n+  implicit none\n+\n+  type flux_planes\n+    integer, allocatable :: normals(:,:)\n+  end type\n+\n+  type package\n+    integer id\n+    type(flux_planes), allocatable :: surface_fluxes(:)\n+    integer, allocatable :: positions(:,:,:,:)\n+  end type\n+\n+  type surfaces\n+    type(package), allocatable :: halo_outbox(:,:,:)\n+  contains\n+    procedure, nopass :: set_halo_outbox\n+    procedure, nopass :: get_surface_normal_spacing\n+  end type\n+\n+  type problem_discretization\n+    type(surfaces) block_surfaces\n+  end type\n+\n+  interface\n+    module subroutine set_halo_outbox(my_halo_outbox)\n+      implicit none\n+      type(package), intent(in) :: my_halo_outbox(:,:,:)\n+    end subroutine\n+\n+    module subroutine get_surface_normal_spacing\n+    end subroutine\n+  end interface\n+\n+end module\n+\n+submodule(surface_packages) implementation\n+  implicit none\n+  type(surfaces), save :: singleton[*]\n+contains\n+\n+  module procedure get_surface_normal_spacing\n+    integer i, b, d, f\n+\n+    do i=1,num_images()\n+      associate( positions => reshape(i*[5,4,3,2], [2,1,1,2]), normals => reshape(i*[6,6,6], [3,1]) )\n+        do b=1,size(singleton[i]%halo_outbox,1)\n+          do d=1,size(singleton[i]%halo_outbox,2)\n+            do f=1,size(singleton[i]%halo_outbox,3)\n+              if ( .not. all([singleton[i]%halo_outbox(b,d,f)%positions == positions]) ) error stop \"positions\"\n+              if ( .not. all([singleton[i]%halo_outbox(b,d,f)%surface_fluxes(1)%normals == normals] ) )  error stop \"normals\"\n+            end do\n+          end do\n+        end do\n+      end associate\n+    end do\n+  end procedure\n+\n+  module procedure set_halo_outbox\n+    singleton%halo_outbox = my_halo_outbox\n+    sync all\n+  end procedure\n+\n+end submodule\n+\n+program main\n+  use surface_packages, only : problem_discretization, package\n+  implicit none\n+  type(problem_discretization) global_grid\n+  type(package), allocatable :: bare(:,:,:)\n+  integer i, j, k\n+\n+  associate( me=>this_image() )\n+\n+    allocate( bare(me,3,2) )\n+\n+    do i=1, size(bare,1)\n+      bare(i,:,:)%id = i\n+      do j=1, size(bare,2)\n+        do k=1, size(bare,3)\n+          bare(i,j,k)%positions =  reshape(me*[5,4,3,2], [2,1,1,2])\n+          allocate( bare(i,j,k)%surface_fluxes(1) )\n+          bare(i,j,k)%surface_fluxes(1)%normals = reshape(me*[6,6,6], [3,1])\n+        end do\n+      end do\n+    end do\n+\n+    call global_grid%block_surfaces%set_halo_outbox(bare)\n+    call global_grid%block_surfaces%get_surface_normal_spacing\n+\n+  end associate\n+\n+  sync all\n+  if (this_image()==1) print *,\"Test passed\"\n+end program main"}]}