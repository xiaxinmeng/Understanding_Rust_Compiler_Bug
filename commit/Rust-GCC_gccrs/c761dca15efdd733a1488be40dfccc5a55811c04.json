{"sha": "c761dca15efdd733a1488be40dfccc5a55811c04", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Yzc2MWRjYTE1ZWZkZDczM2ExNDg4YmU0MGRmY2NjNWE1NTgxMWMwNA==", "commit": {"author": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-28T21:11:37Z"}, "committer": {"name": "Oleg Endo", "email": "olegendo@gcc.gnu.org", "date": "2015-01-28T21:11:37Z"}, "message": "re PR target/64659 ([SH] Immedate values not used for atomic ops)\n\ngcc/\n\tPR target/64659\n\t* config/sh/predicates.md (atomic_arith_operand,\n\tatomic_logical_operand): Remove.\n\t* config/sh/sync.md (fetchop_predicate, fetchop_constraint): Remove.\n\t(atomic_arith_operand_0): New predicate.\n\t(atomic_compare_and_swap<mode>): Use arith_reg_dest for output values.\n\tUse atomic_arith_operand_0 for input values.\n\t(atomic_compare_and_swapsi_hard, atomic_compare_and_swap<mode>_hard,\n\tatomic_compare_and_swap<mode>_soft_gusa,\n\tatomic_compare_and_swap<mode>_soft_tcb,\n\tatomic_compare_and_swap<mode>_soft_imask): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.\n\t(atomic_exchange<mode>): Use arith_reg_dest for output value.  Use\n\tatomic_arith_operand_0 for newval input.\n\t(atomic_exchangesi_hard, atomic_exchange<mode>_hard,\n\tatomic_exchange<mode>_soft_gusa, atomic_exchange<mode>_soft_tcb,\n\tatomic_exchange<mode>_soft_imask): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.\n\t(atomic_arith_operand_1, atomic_logical_operand_1): New predicates.\n\tfetchop_predicate_1, fetchop_constraint_1_llcs,\n\tfetchop_constraint_1_gusa, fetchop_constraint_1_tcb,\n\tfetchop_constraint_1_imask): New code iterator attributes.\n\t(atomic_fetch_<fetchop_name><mode>): Use arith_reg_dest instead of\n\tregister_operand.  Use fetchop_predicate_1.\n\t(atomic_fetch_<fetchop_name>si_hard,\n\tatomic_fetch_<fetchop_name><mode>_hard): Use arith_reg_dest instead of\n\tregister_operand.  Use fetchop_predicate_1, fetchop_constraint_1_llcs.\n\t(atomic_fetch_<fetchop_name><mode>_soft_gusa): Use arith_reg_dest\n\tand arith_reg_operand instead of register_operand.  Use\n\tfetchop_predicate_1, fetchop_constraint_1_gusa.\n\t(atomic_fetch_<fetchop_name><mode>_soft_tcb): Use arith_reg_dest\n\tand arith_reg_operand instead of register_operand.  Use\n\tfetchop_predicate_1, fetchop_constraint_1_tcb.  Adjust asm sequence\n\tto allow R0 usage.\n\t(atomic_fetch_<fetchop_name><mode>_soft_imask): Use arith_reg_dest\n\tand arith_reg_operand instead of register_operand.  Use\n\tfetchop_predicate_1, fetchop_constraint_1_imask.  Adjust asm sequence\n\tto allow R0 usage.\n\t(atomic_fetch_nand<mode>): Use arith_reg_dest instead of\n\tregister_operand.  Use atomic_logical_operand_1.\n\t(atomic_fetch_nandsi_hard, atomic_fetch_nand<mode>_hard,\n\tatomic_fetch_nand<mode>_soft_gusa): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.\n\t(atomic_fetch_nand<mode>_soft_tcb, atomic_fetch_nand<mode>_soft_imask):\n\tUse arith_reg_dest and arith_reg_operand instead of register_operand.\n\tUse logical_operand and rK08.  Adjust asm sequence to allow R0 usage.\n\t(atomic_<fetchop_name>_fetch<mode>): Use arith_reg_dest instead of\n\tregister_operand.  Use fetchop_predicate_1.\n\t(atomic_<fetchop_name>_fetchsi_hard,\n\tatomic_<fetchop_name>_fetch<mode>_hard): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n\tfetchop_constraint_1_llcs.\n\t(atomic_<fetchop_name>_fetch<mode>_soft_gusa): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n\tfetchop_constraint_1_gusa.\n\t(atomic_<fetchop_name>_fetch<mode>_soft_tcb): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n\tfetchop_constraint_1_tcb.  Adjust asm sequence to allow R0 usage.\n\t(atomic_<fetchop_name>_fetch<mode>_soft_imask): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n\tfetchop_constraint_1_imask.  Adjust asm sequence to allow R0 usage.\n\t(atomic_nand_fetch<mode>): Use arith_reg_dest instead of\n\tregister_operand.  Use atomic_logical_operand_1.\n\t(atomic_nand_fetchsi_hard, atomic_nand_fetch<mode>_hard,\n\tatomic_nand_fetch<mode>_soft_gusa): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.\n\t(atomic_nand_fetch<mode>_soft_tcb): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use logical_operand\n\tand K08.  Adjust asm sequence to allow R0 usage.\n\t(atomic_nand_fetch<mode>_soft_imask): Use arith_reg_dest and\n\tarith_reg_operand instead of register_operand.  Use logical_operand\n\tand K08.\n\ngcc/testsuite/\n\tPR target/64659\n\t* gcc.target/sh/sh.exp\n\t(check_effective_target_atomic_model_soft_gusa_available,\n\tcheck_effective_target_atomic_model_soft_tcb_available,\n\tcheck_effective_target_atomic_model_soft_imask_available,\n\tcheck_effective_target_atomic_model_hard_llcs_available): New.\n\t* gcc.target/sh/pr64659-0.h: New.\n\t* gcc.target/sh/pr64659-1.c: New.\n\t* gcc.target/sh/pr64659-2.c: New.\n\t* gcc.target/sh/pr64659-3.c: New.\n\t* gcc.target/sh/pr64659-4.c: New.\n\nFrom-SVN: r220217", "tree": {"sha": "93fabc6f2ea57890ab92970922940b2fe69e00cc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/93fabc6f2ea57890ab92970922940b2fe69e00cc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c761dca15efdd733a1488be40dfccc5a55811c04", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c761dca15efdd733a1488be40dfccc5a55811c04", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c761dca15efdd733a1488be40dfccc5a55811c04", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c761dca15efdd733a1488be40dfccc5a55811c04/comments", "author": null, "committer": null, "parents": [{"sha": "13a48f378062cbd707063393613c44e17a18b71f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/13a48f378062cbd707063393613c44e17a18b71f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/13a48f378062cbd707063393613c44e17a18b71f"}], "stats": {"total": 653, "additions": 453, "deletions": 200}, "files": [{"sha": "e0fef992067c7346f2b4fbd0ac039b7ed09f7ee9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -1,3 +1,78 @@\n+2015-01-28  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64659\n+\t* config/sh/predicates.md (atomic_arith_operand,\n+\tatomic_logical_operand): Remove.\n+\t* config/sh/sync.md (fetchop_predicate, fetchop_constraint): Remove.\n+\t(atomic_arith_operand_0): New predicate.\n+\t(atomic_compare_and_swap<mode>): Use arith_reg_dest for output values.\n+\tUse atomic_arith_operand_0 for input values.\n+\t(atomic_compare_and_swapsi_hard, atomic_compare_and_swap<mode>_hard,\n+\tatomic_compare_and_swap<mode>_soft_gusa,\n+\tatomic_compare_and_swap<mode>_soft_tcb,\n+\tatomic_compare_and_swap<mode>_soft_imask): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.\n+\t(atomic_exchange<mode>): Use arith_reg_dest for output value.  Use\n+\tatomic_arith_operand_0 for newval input.\n+\t(atomic_exchangesi_hard, atomic_exchange<mode>_hard,\n+\tatomic_exchange<mode>_soft_gusa, atomic_exchange<mode>_soft_tcb,\n+\tatomic_exchange<mode>_soft_imask): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.\n+\t(atomic_arith_operand_1, atomic_logical_operand_1): New predicates.\n+\tfetchop_predicate_1, fetchop_constraint_1_llcs,\n+\tfetchop_constraint_1_gusa, fetchop_constraint_1_tcb,\n+\tfetchop_constraint_1_imask): New code iterator attributes.\n+\t(atomic_fetch_<fetchop_name><mode>): Use arith_reg_dest instead of\n+\tregister_operand.  Use fetchop_predicate_1.\n+\t(atomic_fetch_<fetchop_name>si_hard,\n+\tatomic_fetch_<fetchop_name><mode>_hard): Use arith_reg_dest instead of\n+\tregister_operand.  Use fetchop_predicate_1, fetchop_constraint_1_llcs.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_gusa): Use arith_reg_dest\n+\tand arith_reg_operand instead of register_operand.  Use\n+\tfetchop_predicate_1, fetchop_constraint_1_gusa.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_tcb): Use arith_reg_dest\n+\tand arith_reg_operand instead of register_operand.  Use\n+\tfetchop_predicate_1, fetchop_constraint_1_tcb.  Adjust asm sequence\n+\tto allow R0 usage.\n+\t(atomic_fetch_<fetchop_name><mode>_soft_imask): Use arith_reg_dest\n+\tand arith_reg_operand instead of register_operand.  Use\n+\tfetchop_predicate_1, fetchop_constraint_1_imask.  Adjust asm sequence\n+\tto allow R0 usage.\n+\t(atomic_fetch_nand<mode>): Use arith_reg_dest instead of\n+\tregister_operand.  Use atomic_logical_operand_1.\n+\t(atomic_fetch_nandsi_hard, atomic_fetch_nand<mode>_hard,\n+\tatomic_fetch_nand<mode>_soft_gusa): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.\n+\t(atomic_fetch_nand<mode>_soft_tcb, atomic_fetch_nand<mode>_soft_imask):\n+\tUse arith_reg_dest and arith_reg_operand instead of register_operand.\n+\tUse logical_operand and rK08.  Adjust asm sequence to allow R0 usage.\n+\t(atomic_<fetchop_name>_fetch<mode>): Use arith_reg_dest instead of\n+\tregister_operand.  Use fetchop_predicate_1.\n+\t(atomic_<fetchop_name>_fetchsi_hard,\n+\tatomic_<fetchop_name>_fetch<mode>_hard): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n+\tfetchop_constraint_1_llcs.\n+\t(atomic_<fetchop_name>_fetch<mode>_soft_gusa): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n+\tfetchop_constraint_1_gusa.\n+\t(atomic_<fetchop_name>_fetch<mode>_soft_tcb): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n+\tfetchop_constraint_1_tcb.  Adjust asm sequence to allow R0 usage.\n+\t(atomic_<fetchop_name>_fetch<mode>_soft_imask): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use fetchop_predicate_1,\n+\tfetchop_constraint_1_imask.  Adjust asm sequence to allow R0 usage.\n+\t(atomic_nand_fetch<mode>): Use arith_reg_dest instead of\n+\tregister_operand.  Use atomic_logical_operand_1.\n+\t(atomic_nand_fetchsi_hard, atomic_nand_fetch<mode>_hard,\n+\tatomic_nand_fetch<mode>_soft_gusa): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.\n+\t(atomic_nand_fetch<mode>_soft_tcb): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use logical_operand\n+\tand K08.  Adjust asm sequence to allow R0 usage.\n+\t(atomic_nand_fetch<mode>_soft_imask): Use arith_reg_dest and\n+\tarith_reg_operand instead of register_operand.  Use logical_operand\n+\tand K08.\n+\n 2015-01-28  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR other/63504"}, {"sha": "8447524c67ff08223e2b1d9f858e627f98d29eab", "filename": "gcc/config/sh/predicates.md", "status": "modified", "additions": 0, "deletions": 18, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Fconfig%2Fsh%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Fconfig%2Fsh%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fpredicates.md?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -1134,24 +1134,6 @@\n   return 0;\n })\n \n-;; The atomic_* operand predicates are used for the atomic patterns.\n-;; Depending on the particular pattern some operands can be immediate\n-;; values.  Using these predicates avoids the usage of 'force_reg' in the\n-;; expanders.\n-(define_predicate \"atomic_arith_operand\"\n-  (ior (match_code \"subreg,reg\")\n-       (and (match_test \"satisfies_constraint_I08 (op)\")\n-\t    (match_test \"mode != QImode\")\n-\t    (match_test \"mode != HImode\")\n-\t    (match_test \"TARGET_SH4A\"))))\n-\n-(define_predicate \"atomic_logical_operand\"\n-  (ior (match_code \"subreg,reg\")\n-       (and (match_test \"satisfies_constraint_K08 (op)\")\n-\t    (match_test \"mode != QImode\")\n-\t    (match_test \"mode != HImode\")\n-\t    (match_test \"TARGET_SH4A\"))))\n-\n ;; A predicate that matches any expression for which there is an\n ;; insn pattern that sets the T bit.\n (define_predicate \"treg_set_expr\""}, {"sha": "b3ff70ce171dc55ee135eba11dfc6a65967ca0e4", "filename": "gcc/config/sh/sync.md", "status": "modified", "additions": 238, "deletions": 182, "changes": 420, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Fconfig%2Fsh%2Fsync.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Fconfig%2Fsh%2Fsync.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsh%2Fsync.md?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -195,26 +195,29 @@\n (define_code_attr fetchop_name\n   [(plus \"add\") (minus \"sub\") (ior \"or\") (xor \"xor\") (and \"and\")])\n \n-(define_code_attr fetchop_predicate\n-  [(plus \"atomic_arith_operand\") (minus \"register_operand\")\n-   (ior \"atomic_logical_operand\") (xor \"atomic_logical_operand\")\n-   (and \"atomic_logical_operand\")])\n-\n-(define_code_attr fetchop_constraint\n-  [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n-\n ;;------------------------------------------------------------------------------\n ;; comapre and swap\n \n+;; Only the hard_llcs SImode patterns can use an I08 for the comparison\n+;; or for the new swapped in value.\n+(define_predicate \"atomic_arith_operand_0\"\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (and (match_test \"satisfies_constraint_I08 (op)\")\n+\t\t (match_test \"mode == SImode\")\n+\t\t (ior (match_test \"TARGET_ATOMIC_HARD_LLCS\")\n+\t\t      (match_test \"TARGET_ATOMIC_ANY && TARGET_SH4A\n+\t\t\t\t   && !TARGET_ATOMIC_STRICT\"))))))\n+\n (define_expand \"atomic_compare_and_swap<mode>\"\n-  [(match_operand:SI 0 \"register_operand\" \"\")\t\t;; bool success output\n-   (match_operand:QIHISI 1 \"register_operand\" \"\")\t;; oldval output\n-   (match_operand:QIHISI 2 \"memory_operand\" \"\")\t\t;; memory\n-   (match_operand:QIHISI 3 \"atomic_arith_operand\" \"\")\t;; expected input\n-   (match_operand:QIHISI 4 \"atomic_arith_operand\" \"\")\t;; newval input\n-   (match_operand:SI 5 \"const_int_operand\" \"\")\t\t;; is_weak\n-   (match_operand:SI 6 \"const_int_operand\" \"\")\t\t;; success model\n-   (match_operand:SI 7 \"const_int_operand\" \"\")]\t\t;; failure model\n+  [(match_operand:SI 0 \"arith_reg_dest\")\t\t;; bool success output\n+   (match_operand:QIHISI 1 \"arith_reg_dest\")\t\t;; oldval output\n+   (match_operand:QIHISI 2 \"memory_operand\")\t\t;; memory\n+   (match_operand:QIHISI 3 \"atomic_arith_operand_0\")\t;; expected input\n+   (match_operand:QIHISI 4 \"atomic_arith_operand_0\")\t;; newval input\n+   (match_operand:SI 5 \"const_int_operand\")\t\t;; is_weak\n+   (match_operand:SI 6 \"const_int_operand\")\t\t;; success model\n+   (match_operand:SI 7 \"const_int_operand\")]\t\t;; failure model\n   \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[2], 0));\n@@ -252,9 +255,9 @@\n })\n \n (define_insn \"atomic_compare_and_swapsi_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n-\t  [(mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  [(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t   (match_operand:SI 2 \"arith_operand\" \"rI08\")\n \t   (match_operand:SI 3 \"arith_operand\" \"rI08\")]\n \t  UNSPECV_CMPXCHG_1))\n@@ -278,11 +281,11 @@\n   [(set_attr \"length\" \"14\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t   (match_operand:QIHI 2 \"register_operand\" \"r\")\n-\t   (match_operand:QIHI 3 \"register_operand\" \"r\")]\n+\t  [(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t   (match_operand:QIHI 2 \"arith_reg_operand\" \"r\")\n+\t   (match_operand:QIHI 3 \"arith_reg_operand\" \"r\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec_volatile:QIHI [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -314,11 +317,11 @@\n   [(set_attr \"length\" \"30\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_soft_gusa\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&u\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&u\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n-\t   (match_operand:QIHISI 2 \"register_operand\" \"u\")\n-\t   (match_operand:QIHISI 3 \"register_operand\" \"u\")]\n+\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")\n+\t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"u\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -343,11 +346,11 @@\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_soft_tcb\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t   (match_operand:QIHISI 2 \"register_operand\" \"r\")\n-\t   (match_operand:QIHISI 3 \"register_operand\" \"r\")]\n+\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")\n+\t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"r\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -374,11 +377,11 @@\n   [(set_attr \"length\" \"22\")])\n \n (define_insn \"atomic_compare_and_swap<mode>_soft_imask\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n \t(unspec_volatile:SI\n-\t  [(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t   (match_operand:QIHISI 2 \"register_operand\" \"r\")\n-\t   (match_operand:QIHISI 3 \"register_operand\" \"r\")]\n+\t  [(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t   (match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")\n+\t   (match_operand:QIHISI 3 \"arith_reg_operand\" \"r\")]\n \t  UNSPECV_CMPXCHG_1))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec_volatile:QIHISI [(const_int 0)] UNSPECV_CMPXCHG_2))\n@@ -426,10 +429,10 @@\n ;; read - write - return old value\n \n (define_expand \"atomic_exchange<mode>\"\n-  [(match_operand:QIHISI 0 \"register_operand\" \"\")\t;; oldval output\n-   (match_operand:QIHISI 1 \"memory_operand\" \"\")\t\t;; memory\n-   (match_operand:QIHISI 2 \"atomic_arith_operand\" \"\")\t;; newval input\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\t\t;; memory model\n+  [(match_operand:QIHISI 0 \"arith_reg_dest\")\t\t;; oldval output\n+   (match_operand:QIHISI 1 \"memory_operand\")\t\t;; memory\n+   (match_operand:QIHISI 2 \"atomic_arith_operand_0\")\t;; newval input\n+   (match_operand:SI 3 \"const_int_operand\")]\t\t;; memory model\n   \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n@@ -461,8 +464,8 @@\n })\n \n (define_insn \"atomic_exchangesi_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n \t(unspec:SI\n \t  [(match_operand:SI 2 \"arith_operand\" \"rI08\")] UNSPEC_ATOMIC))\n@@ -480,11 +483,11 @@\n   [(set_attr \"length\" \"10\")])\n \n (define_insn \"atomic_exchange<mode>_hard\"\n-  [(set (match_operand:QIHI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec:QIHI\n-\t  [(match_operand:QIHI 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+\t  [(match_operand:QIHI 2 \"arith_reg_operand\" \"r\")] UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))\n    (clobber (match_scratch:SI 3 \"=&r\"))\n@@ -507,11 +510,11 @@\n   [(set_attr \"length\" \"24\")])\n \n (define_insn \"atomic_exchange<mode>_soft_gusa\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(match_operand:QIHISI 2 \"register_operand\" \"u\")] UNSPEC_ATOMIC))\n+\t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_ATOMIC_SOFT_GUSA\"\n@@ -527,11 +530,11 @@\n   [(set_attr \"length\" \"14\")])\n \n (define_insn \"atomic_exchange<mode>_soft_tcb\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(match_operand:QIHISI 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+\t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")] UNSPEC_ATOMIC))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))\n    (use (match_operand:SI 3 \"gbr_displacement\"))]\n@@ -549,11 +552,11 @@\n   [(set_attr \"length\" \"16\")])\n \n (define_insn \"atomic_exchange<mode>_soft_imask\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(match_operand:QIHISI 2 \"register_operand\" \"r\")] UNSPEC_ATOMIC))\n+\t  [(match_operand:QIHISI 2 \"arith_reg_operand\" \"r\")] UNSPEC_ATOMIC))\n    (clobber (match_scratch:SI 3 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n {\n@@ -570,15 +573,52 @@\n ;;------------------------------------------------------------------------------\n ;; read - add|sub|or|and|xor|nand - write - return old value\n \n+;; atomic_arith_operand_1 can be used by any atomic type for a plus op,\n+;; since there's no r0 restriction.\n+(define_predicate \"atomic_arith_operand_1\"\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (match_test \"satisfies_constraint_I08 (op)\"))))\n+\n+;; atomic_logic_operand_1 can be used by the hard_llcs, tcb and soft_imask\n+;; patterns only due to its r0 restriction. \n+(define_predicate \"atomic_logical_operand_1\"\n+  (and (match_code \"subreg,reg,const_int\")\n+       (ior (match_operand 0 \"arith_reg_operand\")\n+\t    (and (match_test \"satisfies_constraint_K08 (op)\")\n+\t\t (ior (match_test \"TARGET_ATOMIC_HARD_LLCS\")\n+\t\t      (match_test \"TARGET_ATOMIC_SOFT_IMASK\")\n+\t\t      (match_test \"TARGET_ATOMIC_SOFT_TCB\")\n+\t\t      (match_test \"TARGET_ATOMIC_ANY && TARGET_SH4A\n+\t\t\t\t   && mode == SImode\n+\t\t\t\t   && !TARGET_ATOMIC_STRICT\"))))))\n+\n+(define_code_attr fetchop_predicate_1\n+  [(plus \"atomic_arith_operand_1\") (minus \"arith_reg_operand\")\n+   (ior \"atomic_logical_operand_1\") (xor \"atomic_logical_operand_1\")\n+   (and \"atomic_logical_operand_1\")])\n+\n+(define_code_attr fetchop_constraint_1_llcs\n+  [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n+\n+(define_code_attr fetchop_constraint_1_gusa\n+  [(plus \"uI08\") (minus \"u\") (ior \"u\") (xor \"u\") (and \"u\")])\n+\n+(define_code_attr fetchop_constraint_1_tcb\n+  [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n+\n+(define_code_attr fetchop_constraint_1_imask\n+  [(plus \"rI08\") (minus \"r\") (ior \"rK08\") (xor \"rK08\") (and \"rK08\")])\n+\n (define_expand \"atomic_fetch_<fetchop_name><mode>\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n-\t(match_operand:QIHISI 1 \"memory_operand\" \"\"))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n+\t(match_operand:QIHISI 1 \"memory_operand\"))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (match_dup 1)\n-\t     (match_operand:QIHISI 2 \"<fetchop_predicate>\" \"\"))]\n+\t     (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"))]\n \t  UNSPEC_ATOMIC))\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+   (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n@@ -612,12 +652,13 @@\n })\n \n (define_insn \"atomic_fetch_<fetchop_name>si_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n \t(unspec:SI\n \t  [(FETCHOP:SI (mem:SI (match_dup 1))\n-\t     (match_operand:SI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\"))]\n+\t\t       (match_operand:SI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t   \"<fetchop_constraint_1_llcs>\"))]\n \t  UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))]\n@@ -633,12 +674,13 @@\n   [(set_attr \"length\" \"10\")])\n \n (define_insn \"atomic_fetch_<fetchop_name><mode>_hard\"\n-  [(set (match_operand:QIHI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec:QIHI\n \t  [(FETCHOP:QIHI (mem:QIHI (match_dup 1))\n-\t     (match_operand:QIHI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\"))]\n+\t\t\t (match_operand:QIHI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t       \"<fetchop_constraint_1_llcs>\"))]\n \t  UNSPEC_ATOMIC))\n    (set (reg:SI T_REG) (const_int 1))\n    (clobber (reg:SI R0_REG))\n@@ -664,12 +706,14 @@\n   [(set_attr \"length\" \"28\")])\n \n (define_insn \"atomic_fetch_<fetchop_name><mode>_soft_gusa\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"u\"))]\n+\t  [(FETCHOP:QIHISI\n+\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t\"<fetchop_constraint_1_gusa>\"))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:QIHISI 3 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n@@ -689,65 +733,68 @@\n   [(set_attr \"length\" \"18\")])\n \n (define_insn \"atomic_fetch_<fetchop_name><mode>_soft_tcb\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"r\"))]\n+\t  [(FETCHOP:QIHISI\n+\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t\"<fetchop_constraint_1_tcb>\"))]\n \t  UNSPEC_ATOMIC))\n    (use (match_operand:SI 3 \"gbr_displacement\"))\n-   (clobber (match_scratch:QIHISI 4 \"=&r\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_ATOMIC_SOFT_TCB\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n-\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n+\t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n-\t \"\t<fetchop_name>\t%2,%4\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%4,@%1\"\t\t\"\\n\"\n-\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_fetch_<fetchop_name><mode>_soft_imask\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"r\"))]\n+\t  [(FETCHOP:QIHISI\n+\t\t(mem:QIHISI (match_dup 1))\n+\t\t(match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\t\"<fetchop_constraint_1_imask>\"))]\n \t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:QIHISI 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:QIHISI 3 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n {\n-  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n-\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n-\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n-\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov\t%0,%3\"\t\t\t\"\\n\"\n-\t \"\t<fetchop_name>\t%2,%3\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n-\t \"\tldc\t%4,sr\";\n+  return \"\\r\tstc\tsr,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\tr0,%3\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,r0\"\t\t\"\\n\"\n+\t \"\tldc\tr0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%3,sr\";\n }\n   [(set_attr \"length\" \"18\")])\n \n (define_expand \"atomic_fetch_nand<mode>\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n-\t(match_operand:QIHISI 1 \"memory_operand\" \"\"))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n+\t(match_operand:QIHISI 1 \"memory_operand\"))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (match_dup 1)\n-\t\t       (match_operand:QIHISI 2 \"atomic_logical_operand\" \"\")))]\n+\t\t       (match_operand:QIHISI 2 \"atomic_logical_operand_1\")))]\n \t  UNSPEC_ATOMIC))\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+   (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n@@ -781,8 +828,8 @@\n })\n \n (define_insn \"atomic_fetch_nandsi_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&r\")\n-\t(mem:SI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:SI (match_dup 1))\n \t(unspec:SI\n \t  [(not:SI (and:SI (mem:SI (match_dup 1))\n@@ -803,8 +850,8 @@\n   [(set_attr \"length\" \"12\")])\n \n (define_insn \"atomic_fetch_nand<mode>_hard\"\n-  [(set (match_operand:QIHI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec:QIHI\n \t  [(not:QIHI (and:QIHI (mem:QIHI (match_dup 1))\n@@ -835,12 +882,13 @@\n   [(set_attr \"length\" \"30\")])\n \n (define_insn \"atomic_fetch_nand<mode>_soft_gusa\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"u\")))]\n+\t  [(not:QIHISI\n+\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t\t\t (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\")))]\n \t  UNSPEC_ATOMIC))\n    (clobber (match_scratch:QIHISI 3 \"=&u\"))\n    (clobber (reg:SI R0_REG))\n@@ -861,66 +909,67 @@\n   [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_fetch_nand<mode>_soft_tcb\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"r\")))]\n+\t  [(not:QIHISI\n+\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t\t\t (match_operand:QIHISI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n    (use (match_operand:SI 3 \"gbr_displacement\"))\n-   (clobber (match_scratch:QIHISI 4 \"=&r\"))\n    (clobber (reg:SI R0_REG))\n    (clobber (reg:SI R1_REG))]\n   \"TARGET_ATOMIC_SOFT_TCB\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n-\t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n-\t \"\tmov\t%2,%4\"\t\t\t\"\\n\"\n-\t \"\tand\t%0,%4\"\t\t\t\"\\n\"\n-\t \"\tnot\t%4,%4\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%4,@%1\"\t\t\"\\n\"\n-\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n   [(set_attr \"length\" \"22\")])\n \n (define_insn \"atomic_fetch_nand<mode>_soft_imask\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n-\t(mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\")))\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n+\t(mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n-\t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1))\n-\t     (match_operand:QIHISI 2 \"register_operand\" \"r\")))]\n+\t  [(not:QIHISI\n+\t     (and:QIHISI (mem:QIHISI (match_dup 1))\n+\t\t\t (match_operand:QIHISI 2 \"logical_operand\" \"rK08\")))]\n \t  UNSPEC_ATOMIC))\n-   (clobber (match_scratch:QIHISI 3 \"=&r\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))]\n+   (clobber (reg:SI R0_REG))\n+   (clobber (match_scratch:SI 3 \"=&r\"))]\n   \"TARGET_ATOMIC_SOFT_IMASK\"\n {\n-  return \"\\r\tstc\tsr,%0\"\t\t\t\"\\n\"\n-\t \"\tmov\t%0,%4\"\t\t\t\"\\n\"\n-\t \"\tor\t#0xF0,%0\"\t\t\"\\n\"\n-\t \"\tldc\t%0,sr\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov\t%2,%3\"\t\t\t\"\\n\"\n-\t \"\tand\t%0,%3\"\t\t\t\"\\n\"\n-\t \"\tnot\t%3,%3\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%3,@%1\"\t\t\"\\n\"\n-\t \"\tldc\t%4,sr\";\n+  return \"\\r\tstc\tsr,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\tr0,%3\"\t\t\t\"\\n\"\n+\t \"\tor\t#0xF0,r0\"\t\t\"\\n\"\n+\t \"\tldc\tr0,sr\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"\tldc\t%3,sr\";\n }\n   [(set_attr \"length\" \"20\")])\n \n ;;------------------------------------------------------------------------------\n ;; read - add|sub|or|and|xor|nand - write - return new value\n \n (define_expand \"atomic_<fetchop_name>_fetch<mode>\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n \t(FETCHOP:QIHISI\n-\t  (match_operand:QIHISI 1 \"memory_operand\" \"\")\n-\t  (match_operand:QIHISI 2 \"<fetchop_predicate>\" \"\")))\n+\t  (match_operand:QIHISI 1 \"memory_operand\")\n+\t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\")))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (match_dup 1) (match_dup 2))]\n@@ -959,10 +1008,11 @@\n })\n \n (define_insn \"atomic_<fetchop_name>_fetchsi_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n \t(FETCHOP:SI\n-\t  (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:SI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\")))\n+\t  (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:SI 2 \"<fetchop_predicate_1>\"\n+\t\t\t      \"<fetchop_constraint_1_llcs>\")))\n    (set (mem:SI (match_dup 1))\n \t(unspec:SI\n \t  [(FETCHOP:SI (mem:SI (match_dup 1)) (match_dup 2))]\n@@ -979,10 +1029,11 @@\n   [(set_attr \"length\" \"8\")])\n \n (define_insn \"atomic_<fetchop_name>_fetch<mode>_hard\"\n-  [(set (match_operand:QIHI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHI\n-\t  (mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:QIHI 2 \"<fetchop_predicate>\" \"<fetchop_constraint>\")))\n+\t  (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t\"<fetchop_constraint_1_llcs>\")))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec:QIHI\n \t  [(FETCHOP:QIHI (mem:QIHI (match_dup 1)) (match_dup 2))]\n@@ -1011,10 +1062,11 @@\n   [(set_attr \"length\" \"28\")])\n \n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_gusa\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"u\")))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t  \"<fetchop_constraint_1_gusa>\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n@@ -1035,10 +1087,11 @@\n   [(set_attr \"length\" \"16\")])\n \n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_tcb\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"r\")))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t  \"<fetchop_constraint_1_tcb>\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n@@ -1049,22 +1102,24 @@\n   \"TARGET_ATOMIC_SOFT_TCB\"\n {\n   return \"\\r\tmova\t1f,r0\"\t\t\t\"\\n\"\n-\t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n+\t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n+\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\t<fetchop_name>\t%2,r0\"\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov\tr0,%0\"\t\t\t\"\\n\"\n \t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n-\t \"\t<fetchop_name>\t%2,%0\"\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n-\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+\t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n-  [(set_attr \"length\" \"18\")])\n+  [(set_attr \"length\" \"20\")])\n \n (define_insn \"atomic_<fetchop_name>_fetch<mode>_soft_imask\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n \t(FETCHOP:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"r\")))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"<fetchop_predicate_1>\"\n+\t\t\t\t  \"<fetchop_constraint_1_imask>\")))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(FETCHOP:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2))]\n@@ -1084,15 +1139,15 @@\n   [(set_attr \"length\" \"16\")])\n \n (define_expand \"atomic_nand_fetch<mode>\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\")\n \t(not:QIHISI (and:QIHISI\n-\t  (match_operand:QIHISI 1 \"memory_operand\" \"\")\n-\t  (match_operand:QIHISI 2 \"atomic_logical_operand\" \"\"))))\n+\t  (match_operand:QIHISI 1 \"memory_operand\")\n+\t  (match_operand:QIHISI 2 \"atomic_logical_operand_1\"))))\n    (set (match_dup 1)\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (match_dup 1) (match_dup 2)))]\n \t  UNSPEC_ATOMIC))\n-   (match_operand:SI 3 \"const_int_operand\" \"\")]\n+   (match_operand:SI 3 \"const_int_operand\")]\n   \"TARGET_ATOMIC_ANY\"\n {\n   rtx addr = force_reg (Pmode, XEXP (operands[1], 0));\n@@ -1126,8 +1181,8 @@\n })\n \n (define_insn \"atomic_nand_fetchsi_hard\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=&z\")\n-\t(not:SI (and:SI (mem:SI (match_operand:SI 1 \"register_operand\" \"r\"))\n+  [(set (match_operand:SI 0 \"arith_reg_dest\" \"=&z\")\n+\t(not:SI (and:SI (mem:SI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t\t\t(match_operand:SI 2 \"logical_operand\" \"rK08\"))))\n    (set (mem:SI (match_dup 1))\n \t(unspec:SI\n@@ -1146,9 +1201,9 @@\n   [(set_attr \"length\" \"10\")])\n \n (define_insn \"atomic_nand_fetch<mode>_hard\"\n-  [(set (match_operand:QIHI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:QIHI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHI\n-\t  (and:QIHI (mem:QIHI (match_operand:SI 1 \"register_operand\" \"r\"))\n+\t  (and:QIHI (mem:QIHI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n \t\t    (match_operand:QIHI 2 \"logical_operand\" \"rK08\"))))\n    (set (mem:QIHI (match_dup 1))\n \t(unspec:QIHI\n@@ -1178,10 +1233,10 @@\n   [(set_attr \"length\" \"28\")])\n \n (define_insn \"atomic_nand_fetch<mode>_soft_gusa\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&u\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&u\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"u\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"u\"))))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"u\"))\n+\t  (match_operand:QIHISI 2 \"arith_reg_operand\" \"u\"))))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n@@ -1203,10 +1258,10 @@\n   [(set_attr \"length\" \"18\")])\n \n (define_insn \"atomic_nand_fetch<mode>_soft_tcb\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&r\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&r\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"r\"))))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"logical_operand\" \"rK08\"))))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]\n@@ -1220,20 +1275,21 @@\n \t \"\tmov\t#(0f-1f),r1\"\t\t\"\\n\"\n \t \"\t.align 2\"\t\t\t\"\\n\"\n \t \"\tmov.l\tr0,@(%O3,gbr)\"\t\t\"\\n\"\n-\t \"0:\tmov.<bwl>\t@%1,%0\"\t\t\"\\n\"\n-\t \"\tmov\t#0,r0\"\t\t\t\"\\n\"\n-\t \"\tand\t%2,%0\"\t\t\t\"\\n\"\n-\t \"\tnot\t%0,%0\"\t\t\t\"\\n\"\n-\t \"\tmov.<bwl>\t%0,@%1\"\t\t\"\\n\"\n-\t \"1:\tmov.l\tr0,@(%O3,gbr)\";\n+\t \"0:\tmov.<bwl>\t@%1,r0\"\t\t\"\\n\"\n+\t \"\tand\t%2,r0\"\t\t\t\"\\n\"\n+\t \"\tnot\tr0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov\tr0,%0\"\t\t\t\"\\n\"\n+\t \"\tmov.<bwl>\tr0,@%1\"\t\t\"\\n\"\n+\t \"1:\tmov\t#0,r0\"\t\t\t\"\\n\"\n+\t \"\tmov.l\tr0,@(%O3,gbr)\";\n }\n-  [(set_attr \"length\" \"20\")])\n+  [(set_attr \"length\" \"22\")])\n \n (define_insn \"atomic_nand_fetch<mode>_soft_imask\"\n-  [(set (match_operand:QIHISI 0 \"register_operand\" \"=&z\")\n+  [(set (match_operand:QIHISI 0 \"arith_reg_dest\" \"=&z\")\n \t(not:QIHISI (and:QIHISI\n-\t  (mem:QIHISI (match_operand:SI 1 \"register_operand\" \"r\"))\n-\t  (match_operand:QIHISI 2 \"register_operand\" \"r\"))))\n+\t  (mem:QIHISI (match_operand:SI 1 \"arith_reg_operand\" \"r\"))\n+\t  (match_operand:QIHISI 2 \"logical_operand\" \"rK08\"))))\n    (set (mem:QIHISI (match_dup 1))\n \t(unspec:QIHISI\n \t  [(not:QIHISI (and:QIHISI (mem:QIHISI (match_dup 1)) (match_dup 2)))]"}, {"sha": "9dc18d731780fe14329b48d296787846b3777573", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -1,3 +1,17 @@\n+2015-01-28  Oleg Endo  <olegendo@gcc.gnu.org>\n+\n+\tPR target/64659\n+\t* gcc.target/sh/sh.exp\n+\t(check_effective_target_atomic_model_soft_gusa_available,\n+\tcheck_effective_target_atomic_model_soft_tcb_available,\n+\tcheck_effective_target_atomic_model_soft_imask_available,\n+\tcheck_effective_target_atomic_model_hard_llcs_available): New.\n+\t* gcc.target/sh/pr64659-0.h: New.\n+\t* gcc.target/sh/pr64659-1.c: New.\n+\t* gcc.target/sh/pr64659-2.c: New.\n+\t* gcc.target/sh/pr64659-3.c: New.\n+\t* gcc.target/sh/pr64659-4.c: New.\n+\n 2015-01-28  Alex Velenko  <Alex.Velenko@arm.com>\n \n \t* gcc.target/arm/atomic-op-consume.c (scan-assember-times): Adjust"}, {"sha": "a63df2ba1c5681fc62f730d5758a6ea290953f7d", "filename": "gcc/testsuite/gcc.target/sh/pr64659-0.h", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-0.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-0.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-0.h?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -0,0 +1,60 @@\n+/* Check that atomic ops utilize insns with immediate values.  */\n+\n+#define emitfuncs(name)\\\n+  void test_ ## name ## _0 (char* mem)\\\n+  {\\\n+    name (mem, 1, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  void test_ ## name ## _1 (short* mem)\\\n+  {\\\n+    name (mem, 1, __ATOMIC_ACQ_REL);\\\n+  }\\\n+  void test_ ## name ##_2 (int* mem)\\\n+  {\\\n+    name (mem, 1, __ATOMIC_ACQ_REL);\\\n+  }\\\n+\n+emitfuncs (__atomic_add_fetch)\n+emitfuncs (__atomic_fetch_add)\n+\n+emitfuncs (__atomic_sub_fetch)\n+emitfuncs (__atomic_fetch_sub)\n+\n+emitfuncs (__atomic_and_fetch)\n+emitfuncs (__atomic_fetch_and)\n+\n+emitfuncs (__atomic_or_fetch)\n+emitfuncs (__atomic_fetch_or)\n+\n+emitfuncs (__atomic_xor_fetch)\n+emitfuncs (__atomic_fetch_xor)\n+\n+emitfuncs (__atomic_nand_fetch)\n+emitfuncs (__atomic_fetch_nand)\n+\n+void\n+test___atomic_compare_exchange_0 (char* mem)\n+{\n+  char expected = 1;\n+  char desired = 5;\n+  __atomic_compare_exchange (mem, &expected, &desired, 0, __ATOMIC_ACQ_REL,\n+\t\t\t     __ATOMIC_RELAXED);\n+}\n+\n+void\n+test___atomic_compare_exchange_1 (short* mem)\n+{\n+  short expected = 1;\n+  short desired = 5;\n+  __atomic_compare_exchange (mem, &expected, &desired, 0, __ATOMIC_ACQ_REL,\n+\t\t\t     __ATOMIC_RELAXED);\n+}\n+\n+void\n+test___atomic_compare_exchange_2 (int* mem)\n+{\n+  int expected = 1;\n+  int desired = 5;\n+  __atomic_compare_exchange (mem, &expected, &desired, 0, __ATOMIC_ACQ_REL,\n+\t\t\t     __ATOMIC_RELAXED);\n+}"}, {"sha": "e86c0bb316103b0be2ababe2f8ad78391db2b56a", "filename": "gcc/testsuite/gcc.target/sh/pr64659-1.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-1.c?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -0,0 +1,7 @@\n+/* Check that atomic ops utilize insns with immediate values.  */\n+/* { dg-do compile { target { atomic_model_soft_gusa_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-gusa,strict\" }  */\n+/* { dg-final { scan-assembler-times \"add\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"add\\t#-1\" 6 } }  */\n+\n+#include \"pr64659-0.h\""}, {"sha": "e9c069c9097af5290c77384203f1527b1bac5447", "filename": "gcc/testsuite/gcc.target/sh/pr64659-2.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-2.c?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -0,0 +1,10 @@\n+/* Check that atomic ops utilize insns with immediate values.  */\n+/* { dg-do compile { target { atomic_model_soft_tcb_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-tcb,gbr-offset=0,strict\" }  */\n+/* { dg-final { scan-assembler-times \"add\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"add\\t#-1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"and\\t#1\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"\\tor\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"xor\\t#1\" 6 } }  */\n+\n+#include \"pr64659-0.h\""}, {"sha": "b5a7f41a0349784692b038d9e414e3b247e6febc", "filename": "gcc/testsuite/gcc.target/sh/pr64659-3.c", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-3.c?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -0,0 +1,10 @@\n+/* Check that atomic ops utilize insns with immediate values.  */\n+/* { dg-do compile { target { atomic_model_soft_imask_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=soft-imask,strict -mno-usermode\" }  */\n+/* { dg-final { scan-assembler-times \"add\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"add\\t#-1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"and\\t#1\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"\\tor\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"xor\\t#1\" 6 } }  */\n+\n+#include \"pr64659-0.h\""}, {"sha": "acf1cde760cbb594c7c4e68312348c189212f30b", "filename": "gcc/testsuite/gcc.target/sh/pr64659-4.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fpr64659-4.c?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -0,0 +1,11 @@\n+/* Check that atomic ops utilize insns with immediate values.  */\n+/* { dg-do compile { target { atomic_model_hard_llcs_available } } }  */\n+/* { dg-options \"-O2 -matomic-model=hard-llcs,strict\" }  */\n+/* { dg-final { scan-assembler-times \"add\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"add\\t#-1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"and\\t#1\" 12 } }  */\n+/* { dg-final { scan-assembler-times \"\\tor\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"xor\\t#1\" 6 } }  */\n+/* { dg-final { scan-assembler-times \"cmp/eq\\t#1\" 1 } }  */\n+\n+#include \"pr64659-0.h\""}, {"sha": "6f9c97e34e7037a709e2d1794091165aa3b6ce11", "filename": "gcc/testsuite/gcc.target/sh/sh.exp", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c761dca15efdd733a1488be40dfccc5a55811c04/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fsh%2Fsh.exp?ref=c761dca15efdd733a1488be40dfccc5a55811c04", "patch": "@@ -33,6 +33,34 @@ proc check_effective_target_sh2a { } {\n     } \"\"]\n }\n \n+# Return 1 if target supports atomic-model=soft-gusa\n+proc check_effective_target_atomic_model_soft_gusa_available { } {\n+    return [check_no_compiler_messages atomic_model_soft_gusa_available object {\n+\t     int x = 0;\n+    } \"-matomic-model=soft-gusa\"]\n+}\n+\n+# Return 1 if target supports atomic-model=soft-tcb\n+proc check_effective_target_atomic_model_soft_tcb_available { } {\n+    return [check_no_compiler_messages atomic_model_soft_tcb_available object {\n+\t     int x = 0;\n+    } \"-matomic-model=soft-tcb,gbr-offset=0\"]\n+}\n+\n+# Return 1 if target supports atomic-model=soft-imask\n+proc check_effective_target_atomic_model_soft_imask_available { } {\n+    return [check_no_compiler_messages atomic_model_soft_imask_available object {\n+\t     int x = 0;\n+    } \"-matomic-model=soft-imask -mno-usermode\"]\n+}\n+\n+# Return 1 if target supports atomic-model=hard-llcs\n+proc check_effective_target_atomic_model_hard_llcs_available { } {\n+    return [check_no_compiler_messages atomic_model_hard_llcs_available object {\n+\t     int x = 0;\n+    } \"-matomic-model=hard-llcs\"]\n+}\n+\n # If a testcase doesn't have special options, use these.\n global DEFAULT_CFLAGS\n if ![info exists DEFAULT_CFLAGS] then {"}]}