{"sha": "dc10fd963fd136ac24f79e2f052956802bd8d361", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGMxMGZkOTYzZmQxMzZhYzI0Zjc5ZTJmMDUyOTU2ODAyYmQ4ZDM2MQ==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2014-09-26T08:03:09Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2014-09-26T08:03:09Z"}, "message": "common.opt: New option.\n\ngcc/\n\n2014-09-26  Jakub Jelinek  <jakub@redhat.com>\n\t    Max Ostapenko  <m.ostapenko@partner.samsung.com>\n\n\t* common.opt: New option.\n\t* doc/invoke.texi: Describe new option.\n\t* gcc.c (execute): Don't free first string early, but at the end\n\tof the function.  Call retry_ice if compiler exited with\n\tICE_EXIT_CODE.\n\t(main): Factor out common code.\n\t(print_configuration): New function.\n\t(files_equal_p): Likewise.\n\t(check_repro): Likewise.\n\t(run_attempt): Likewise.\n\t(do_report_bug): Likewise.\n\t(append_text): Likewise.\n\t(try_generate_repro): Likewise\n\nCo-Authored-By: Max Ostapenko <m.ostapenko@partner.samsung.com>\n\nFrom-SVN: r215633", "tree": {"sha": "84861efce6f9503064dc6063f66593ea9dda1eaf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84861efce6f9503064dc6063f66593ea9dda1eaf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/dc10fd963fd136ac24f79e2f052956802bd8d361", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc10fd963fd136ac24f79e2f052956802bd8d361", "html_url": "https://github.com/Rust-GCC/gccrs/commit/dc10fd963fd136ac24f79e2f052956802bd8d361", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/dc10fd963fd136ac24f79e2f052956802bd8d361/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "29ce50b031e023317550f4de34a8ba1fb7bf0609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/29ce50b031e023317550f4de34a8ba1fb7bf0609", "html_url": "https://github.com/Rust-GCC/gccrs/commit/29ce50b031e023317550f4de34a8ba1fb7bf0609"}], "stats": {"total": 410, "additions": 374, "deletions": 36}, "files": [{"sha": "dc03561323b49ed3a8362185d03e9f1d12f68cdf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=dc10fd963fd136ac24f79e2f052956802bd8d361", "patch": "@@ -1,3 +1,20 @@\n+2014-09-26  Jakub Jelinek  <jakub@redhat.com>\n+\t    Max Ostapenko  <m.ostapenko@partner.samsung.com>\n+\n+\t* common.opt: New option.\n+\t* doc/invoke.texi: Describe new option.\n+\t* gcc.c (execute): Don't free first string early, but at the end\n+\tof the function.  Call retry_ice if compiler exited with\n+\tICE_EXIT_CODE.\n+\t(main): Factor out common code.\n+\t(print_configuration): New function.\n+\t(files_equal_p): Likewise.\n+\t(check_repro): Likewise.\n+\t(run_attempt): Likewise.\n+\t(do_report_bug): Likewise.\n+\t(append_text): Likewise.\n+\t(try_generate_repro): Likewise\n+\n 2014-09-25  Andi Kleen  <ak@linux.intel.com>\n \n \t* config/i386/i386.c (x86_print_call_or_nop): New function."}, {"sha": "b4f0ed465211e9d78a913f7209ef701804de8b0c", "filename": "gcc/common.opt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fcommon.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fcommon.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon.opt?ref=dc10fd963fd136ac24f79e2f052956802bd8d361", "patch": "@@ -1120,6 +1120,11 @@ fdump-noaddr\n Common Report Var(flag_dump_noaddr)\n Suppress output of addresses in debugging dumps\n \n+freport-bug\n+Common Driver Var(flag_report_bug)\n+Collect and dump debug information into temporary file if ICE in C/C++\n+compiler occured.\n+\n fdump-passes\n Common Var(flag_dump_passes) Init(0)\n Dump optimization passes"}, {"sha": "f6c3b420da18c61fa5d837317f7bad961f3f8bdf", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=dc10fd963fd136ac24f79e2f052956802bd8d361", "patch": "@@ -6344,6 +6344,11 @@ feasible to use diff on debugging dumps for compiler invocations with\n different compiler binaries and/or different\n text / bss / data / heap / stack / dso start locations.\n \n+@item -freport-bug\n+@opindex freport-bug\n+Collect and dump debug information into temporary file if ICE in C/C++\n+compiler occured.\n+\n @item -fdump-unnumbered\n @opindex fdump-unnumbered\n When doing debugging dumps, suppress instruction numbers and address output."}, {"sha": "e32ff47685eba38e425ca93790a99b0facc164ee", "filename": "gcc/gcc.c", "status": "modified", "additions": 347, "deletions": 36, "changes": 383, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fgcc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/dc10fd963fd136ac24f79e2f052956802bd8d361/gcc%2Fgcc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcc.c?ref=dc10fd963fd136ac24f79e2f052956802bd8d361", "patch": "@@ -253,6 +253,7 @@ static void init_gcc_specs (struct obstack *, const char *, const char *,\n static const char *convert_filename (const char *, int, int);\n #endif\n \n+static void try_generate_repro (const char *prog, const char **argv);\n static const char *getenv_spec_function (int, const char **);\n static const char *if_exists_spec_function (int, const char **);\n static const char *if_exists_else_spec_function (int, const char **);\n@@ -2856,7 +2857,7 @@ execute (void)\n \t    }\n \t}\n \n-      if (string != commands[i].prog)\n+      if (i && string != commands[i].prog)\n \tfree (CONST_CAST (char *, string));\n     }\n \n@@ -2909,6 +2910,15 @@ execute (void)\n \telse if (WIFEXITED (status)\n \t\t && WEXITSTATUS (status) >= MIN_FATAL_STATUS)\n \t  {\n+\t    /* For ICEs in cc1, cc1obj, cc1plus see if it is\n+\t       reproducible or not.  */\n+\t    const char *p;\n+\t    if (flag_report_bug\n+\t\t&& WEXITSTATUS (status) == ICE_EXIT_CODE\n+\t\t&& i == 0\n+\t\t&& (p = strrchr (commands[0].argv[0], DIR_SEPARATOR))\n+\t\t&& ! strncmp (p + 1, \"cc1\", 3))\n+\t      try_generate_repro (commands[0].prog, commands[0].argv);\n \t    if (WEXITSTATUS (status) > greatest_status)\n \t      greatest_status = WEXITSTATUS (status);\n \t    ret_code = -1;\n@@ -2966,6 +2976,9 @@ execute (void)\n \t  }\n       }\n \n+   if (commands[0].argv[0] != commands[0].prog)\n+     free (CONST_CAST (char *, commands[0].argv[0]));\n+\n     return ret_code;\n   }\n }\n@@ -6157,6 +6170,338 @@ give_switch (int switchnum, int omit_first_word)\n   switches[switchnum].validated = true;\n }\n \f\n+/* Print GCC configuration (e.g. version, thread model, target,\n+   configuration_arguments) to a given FILE.  */\n+\n+static void\n+print_configuration (FILE *file)\n+{\n+  int n;\n+  const char *thrmod;\n+\n+  fnotice (file, \"Target: %s\\n\", spec_machine);\n+  fnotice (file, \"Configured with: %s\\n\", configuration_arguments);\n+\n+#ifdef THREAD_MODEL_SPEC\n+  /* We could have defined THREAD_MODEL_SPEC to \"%*\" by default,\n+  but there's no point in doing all this processing just to get\n+  thread_model back.  */\n+  obstack_init (&obstack);\n+  do_spec_1 (THREAD_MODEL_SPEC, 0, thread_model);\n+  obstack_1grow (&obstack, '\\0');\n+  thrmod = XOBFINISH (&obstack, const char *);\n+#else\n+  thrmod = thread_model;\n+#endif\n+\n+  fnotice (file, \"Thread model: %s\\n\", thrmod);\n+\n+  /* compiler_version is truncated at the first space when initialized\n+  from version string, so truncate version_string at the first space\n+  before comparing.  */\n+  for (n = 0; version_string[n]; n++)\n+    if (version_string[n] == ' ')\n+      break;\n+\n+  if (! strncmp (version_string, compiler_version, n)\n+      && compiler_version[n] == 0)\n+    fnotice (file, \"gcc version %s %s\\n\\n\", version_string,\n+\t     pkgversion_string);\n+  else\n+    fnotice (file, \"gcc driver version %s %sexecuting gcc version %s\\n\\n\",\n+\t     version_string, pkgversion_string, compiler_version);\n+\n+}\n+\n+#define RETRY_ICE_ATTEMPTS 3\n+\n+/* Returns true if FILE1 and FILE2 contain equivalent data, 0 otherwise.  */\n+\n+static bool\n+files_equal_p (char *file1, char *file2)\n+{\n+  struct stat st1, st2;\n+  off_t n, len;\n+  int fd1, fd2;\n+  const int bufsize = 8192;\n+  char *buf = XNEWVEC (char, bufsize);\n+\n+  fd1 = open (file1, O_RDONLY);\n+  fd2 = open (file2, O_RDONLY);\n+\n+  if (fd1 < 0 || fd2 < 0)\n+    goto error;\n+\n+  if (fstat (fd1, &st1) < 0 || fstat (fd2, &st2) < 0)\n+    goto error;\n+\n+  if (st1.st_size != st2.st_size)\n+    goto error;\n+\n+  for (n = st1.st_size; n; n -= len)\n+    {\n+      len = n;\n+      if ((int) len > bufsize / 2)\n+\tlen = bufsize / 2;\n+\n+      if (read (fd1, buf, len) != (int) len\n+\t  || read (fd2, buf + bufsize / 2, len) != (int) len)\n+\t{\n+\t  goto error;\n+\t}\n+\n+      if (memcmp (buf, buf + bufsize / 2, len) != 0)\n+\tgoto error;\n+    }\n+\n+  free (buf);\n+  close (fd1);\n+  close (fd2);\n+\n+  return 1;\n+\n+error:\n+  free (buf);\n+  close (fd1);\n+  close (fd2);\n+  return 0;\n+}\n+\n+/* Check that compiler's output doesn't differ across runs.\n+   TEMP_STDOUT_FILES and TEMP_STDERR_FILES are arrays of files, containing\n+   stdout and stderr for each compiler run.  Return true if all of\n+   TEMP_STDOUT_FILES and TEMP_STDERR_FILES are equivalent.  */\n+\n+static bool\n+check_repro (char **temp_stdout_files, char **temp_stderr_files)\n+{\n+  int i;\n+  for (i = 0; i < RETRY_ICE_ATTEMPTS - 2; ++i)\n+    {\n+     if (!files_equal_p (temp_stdout_files[i], temp_stdout_files[i + 1])\n+\t || !files_equal_p (temp_stderr_files[i], temp_stderr_files[i + 1]))\n+       {\n+\t fnotice (stderr, \"The bug is not reproducible, so it is\"\n+\t\t  \" likely a hardware or OS problem.\\n\");\n+\t break;\n+       }\n+    }\n+  return i == RETRY_ICE_ATTEMPTS - 2;\n+}\n+\n+enum attempt_status {\n+  ATTEMPT_STATUS_FAIL_TO_RUN,\n+  ATTEMPT_STATUS_SUCCESS,\n+  ATTEMPT_STATUS_ICE\n+};\n+\n+\n+/* Run compiler with arguments NEW_ARGV to reproduce the ICE, storing stdout\n+   to OUT_TEMP and stderr to ERR_TEMP.  If APPEND is TRUE, append to OUT_TEMP\n+   and ERR_TEMP instead of truncating.  If EMIT_SYSTEM_INFO is TRUE, also write\n+   GCC configuration into to ERR_TEMP.  Return ATTEMPT_STATUS_FAIL_TO_RUN if\n+   compiler failed to run, ATTEMPT_STATUS_ICE if compiled ICE-ed and\n+   ATTEMPT_STATUS_SUCCESS otherwise.  */\n+\n+static enum attempt_status\n+run_attempt (const char **new_argv, const char *out_temp,\n+\t     const char *err_temp, int emit_system_info, int append)\n+{\n+\n+  if (emit_system_info)\n+    {\n+      FILE *file_out = fopen (err_temp, \"a\");\n+      print_configuration (file_out);\n+      fclose (file_out);\n+    }\n+\n+  int exit_status;\n+  const char *errmsg;\n+  struct pex_obj *pex;\n+  int err;\n+  int pex_flags = PEX_USE_PIPES | PEX_LAST;\n+  enum attempt_status status = ATTEMPT_STATUS_FAIL_TO_RUN;\n+\n+  if (append)\n+    pex_flags |= PEX_STDOUT_APPEND | PEX_STDERR_APPEND;\n+\n+  pex = pex_init (PEX_USE_PIPES, new_argv[0], NULL);\n+  if (!pex)\n+    fatal_error (\"pex_init failed: %m\");\n+\n+  errmsg = pex_run (pex, pex_flags, new_argv[0],\n+\t\t    CONST_CAST2 (char *const *, const char **, &new_argv[1]), out_temp,\n+\t\t    err_temp, &err);\n+\n+  if (!pex_get_status (pex, 1, &exit_status))\n+    goto out;\n+\n+  switch (WEXITSTATUS (exit_status))\n+    {\n+      case ICE_EXIT_CODE:\n+\tstatus = ATTEMPT_STATUS_ICE;\n+\tbreak;\n+\n+      case SUCCESS_EXIT_CODE:\n+\tstatus = ATTEMPT_STATUS_SUCCESS;\n+\tbreak;\n+\n+      default:\n+\t;\n+    }\n+\n+out:\n+  pex_free (pex);\n+  return status;\n+}\n+\n+/* This routine adds preprocessed source code into the given ERR_FILE.\n+   To do this, it adds \"-E\" to NEW_ARGV and execute RUN_ATTEMPT routine to\n+   add information in report file.  RUN_ATTEMPT should return\n+   ATTEMPT_STATUS_SUCCESS, in other case we cannot generate the report.  */\n+\n+static void\n+do_report_bug (const char **new_argv, const int nargs,\n+\t       char **out_file, char **err_file)\n+{\n+  int i, status;\n+  int fd = open (*out_file, O_RDWR | O_APPEND);\n+  if (fd < 0)\n+    return;\n+  write (fd, \"\\n//\", 3);\n+  for (i = 0; i < nargs; i++)\n+    {\n+      write (fd, \" \", 1);\n+      write (fd, new_argv[i], strlen (new_argv[i]));\n+    }\n+  write (fd, \"\\n\\n\", 2);\n+  close (fd);\n+  new_argv[nargs] = \"-E\";\n+  new_argv[nargs + 1] = NULL;\n+\n+  status = run_attempt (new_argv, *out_file, *err_file, 0, 1);\n+\n+  if (status == ATTEMPT_STATUS_SUCCESS)\n+    {\n+      fnotice (stderr, \"Preprocessed source stored into %s file,\"\n+\t       \" please attach this to your bugreport.\\n\", *out_file);\n+      /* Make sure it is not deleted.  */\n+      free (*out_file);\n+      *out_file = NULL;\n+    }\n+}\n+\n+/* Append string STR to file FILE.  */\n+\n+static void\n+append_text (char *file, const char *str)\n+{\n+  int fd = open (file, O_RDWR | O_APPEND);\n+  if (fd < 0)\n+    return;\n+\n+  write (fd, str, strlen (str));\n+  close (fd);\n+}\n+\n+/* Try to reproduce ICE.  If bug is reproducible, generate report .err file\n+   containing GCC configuration, backtrace, compiler's command line options\n+   and preprocessed source code.  */\n+\n+static void\n+try_generate_repro (const char *prog, const char **argv)\n+{\n+  int i, nargs, out_arg = -1, quiet = 0, attempt;\n+  const char **new_argv;\n+  char *temp_files[RETRY_ICE_ATTEMPTS * 2];\n+  char **temp_stdout_files = &temp_files[0];\n+  char **temp_stderr_files = &temp_files[RETRY_ICE_ATTEMPTS];\n+\n+  if (gcc_input_filename == NULL || ! strcmp (gcc_input_filename, \"-\"))\n+    return;\n+\n+  for (nargs = 0; argv[nargs] != NULL; ++nargs)\n+    /* Only retry compiler ICEs, not preprocessor ones.  */\n+    if (! strcmp (argv[nargs], \"-E\"))\n+      return;\n+    else if (argv[nargs][0] == '-' && argv[nargs][1] == 'o')\n+      {\n+\tif (out_arg == -1)\n+\t  out_arg = nargs;\n+\telse\n+\t  return;\n+      }\n+    /* If the compiler is going to output any time information,\n+       it might varry between invocations.  */\n+    else if (! strcmp (argv[nargs], \"-quiet\"))\n+      quiet = 1;\n+    else if (! strcmp (argv[nargs], \"-ftime-report\"))\n+      return;\n+\n+  if (out_arg == -1 || !quiet)\n+    return;\n+\n+  memset (temp_files, '\\0', sizeof (temp_files));\n+  new_argv = XALLOCAVEC (const char *, nargs + 4);\n+  memcpy (new_argv, argv, (nargs + 1) * sizeof (const char *));\n+  new_argv[nargs++] = \"-frandom-seed=0\";\n+  new_argv[nargs++] = \"-fdump-noaddr\";\n+  new_argv[nargs] = NULL;\n+  if (new_argv[out_arg][2] == '\\0')\n+    new_argv[out_arg + 1] = \"-\";\n+  else\n+    new_argv[out_arg] = \"-o-\";\n+\n+  int status;\n+  for (attempt = 0; attempt < RETRY_ICE_ATTEMPTS; ++attempt)\n+    {\n+      int emit_system_info = 0;\n+      int append = 0;\n+      temp_stdout_files[attempt] = make_temp_file (\".out\");\n+      temp_stderr_files[attempt] = make_temp_file (\".err\");\n+\n+      if (attempt == RETRY_ICE_ATTEMPTS - 1)\n+\t{\n+\t  append = 1;\n+\t  emit_system_info = 1;\n+\t}\n+\n+      if (emit_system_info)\n+\tappend_text (temp_stderr_files[attempt], \"/*\\n\");\n+\n+      status = run_attempt (new_argv, temp_stdout_files[attempt],\n+\t\t\t    temp_stderr_files[attempt], emit_system_info,\n+\t\t\t    append);\n+\n+      if (emit_system_info)\n+\tappend_text (temp_stderr_files[attempt], \"*/\\n\");\n+\n+      if (status != ATTEMPT_STATUS_ICE)\n+\t{\n+\t  fnotice (stderr, \"The bug is not reproducible, so it is\"\n+\t\t   \" likely a hardware or OS problem.\\n\");\n+\t  goto out;\n+\t}\n+    }\n+\n+  if (!check_repro (temp_stdout_files, temp_stderr_files))\n+    goto out;\n+\n+  /* In final attempt we append compiler options and preprocesssed code to last\n+     generated .err file with configuration and backtrace.  */\n+  do_report_bug (new_argv, nargs,\n+\t\t &temp_stderr_files[RETRY_ICE_ATTEMPTS - 1],\n+\t\t &temp_stdout_files[RETRY_ICE_ATTEMPTS - 1]);\n+\n+out:\n+  for (i = 0; i < RETRY_ICE_ATTEMPTS * 2; i++)\n+    if (temp_files[i])\n+      {\n+\tunlink (temp_stdout_files[i]);\n+\tfree (temp_stdout_files[i]);\n+      }\n+}\n+\n /* Search for a file named NAME trying various prefixes including the\n    user's -B prefix and some standard ones.\n    Return the absolute file name found.  If nothing is found, return NAME.  */\n@@ -6926,41 +7271,7 @@ warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.\\n\\n\"\n \n   if (verbose_flag)\n     {\n-      int n;\n-      const char *thrmod;\n-\n-      fnotice (stderr, \"Target: %s\\n\", spec_machine);\n-      fnotice (stderr, \"Configured with: %s\\n\", configuration_arguments);\n-\n-#ifdef THREAD_MODEL_SPEC\n-      /* We could have defined THREAD_MODEL_SPEC to \"%*\" by default,\n-\t but there's no point in doing all this processing just to get\n-\t thread_model back.  */\n-      obstack_init (&obstack);\n-      do_spec_1 (THREAD_MODEL_SPEC, 0, thread_model);\n-      obstack_1grow (&obstack, '\\0');\n-      thrmod = XOBFINISH (&obstack, const char *);\n-#else\n-      thrmod = thread_model;\n-#endif\n-\n-      fnotice (stderr, \"Thread model: %s\\n\", thrmod);\n-\n-      /* compiler_version is truncated at the first space when initialized\n-\t from version string, so truncate version_string at the first space\n-\t before comparing.  */\n-      for (n = 0; version_string[n]; n++)\n-\tif (version_string[n] == ' ')\n-\t  break;\n-\n-      if (! strncmp (version_string, compiler_version, n)\n-\t  && compiler_version[n] == 0)\n-\tfnotice (stderr, \"gcc version %s %s\\n\", version_string,\n-\t\t pkgversion_string);\n-      else\n-\tfnotice (stderr, \"gcc driver version %s %sexecuting gcc version %s\\n\",\n-\t\t version_string, pkgversion_string, compiler_version);\n-\n+      print_configuration (stderr);\n       if (n_infiles == 0)\n \treturn (0);\n     }"}]}