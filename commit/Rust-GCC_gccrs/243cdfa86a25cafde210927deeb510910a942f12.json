{"sha": "243cdfa86a25cafde210927deeb510910a942f12", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjQzY2RmYTg2YTI1Y2FmZGUyMTA5MjdkZWViNTEwOTEwYTk0MmYxMg==", "commit": {"author": {"name": "Zdenek Dvorak", "email": "dvorakz@suse.cz", "date": "2006-01-11T12:46:28Z"}, "committer": {"name": "Zdenek Dvorak", "email": "rakdver@gcc.gnu.org", "date": "2006-01-11T12:46:28Z"}, "message": "tree-ssa-operands.c (get_expr_operands): Record addressable variables directly.\n\n\t* tree-ssa-operands.c (get_expr_operands): Record addressable\n\tvariables directly.  Do not call add_stmt_operands for CONST_DECLs\n\tand ARRAY_DECLs.\n\t(get_indirect_ref_operands): Remove handling of *(&a + offset) case.\n\t(add_stmt_operands): Handle only objects satisfying SSA_VAR_P.\n\nFrom-SVN: r109576", "tree": {"sha": "dccc4a31597ac12b89628e10fc54f4ceffbba014", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dccc4a31597ac12b89628e10fc54f4ceffbba014"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/243cdfa86a25cafde210927deeb510910a942f12", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243cdfa86a25cafde210927deeb510910a942f12", "html_url": "https://github.com/Rust-GCC/gccrs/commit/243cdfa86a25cafde210927deeb510910a942f12", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/243cdfa86a25cafde210927deeb510910a942f12/comments", "author": null, "committer": null, "parents": [{"sha": "c6c0cc813b0afee463086a70e7a21bca202926a7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6c0cc813b0afee463086a70e7a21bca202926a7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6c0cc813b0afee463086a70e7a21bca202926a7"}], "stats": {"total": 66, "additions": 17, "deletions": 49}, "files": [{"sha": "61c5a682b6941d2c9d7824721f8035a1f658d265", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cdfa86a25cafde210927deeb510910a942f12/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cdfa86a25cafde210927deeb510910a942f12/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=243cdfa86a25cafde210927deeb510910a942f12", "patch": "@@ -1,3 +1,11 @@\n+2006-01-11  Zdenek Dvorak <dvorakz@suse.cz>\n+\n+\t* tree-ssa-operands.c (get_expr_operands): Record addressable\n+\tvariables directly.  Do not call add_stmt_operands for CONST_DECLs\n+\tand ARRAY_DECLs.\n+\t(get_indirect_ref_operands): Remove handling of *(&a + offset) case.\n+\t(add_stmt_operands): Handle only objects satisfying SSA_VAR_P.\n+\n 2006-01-11  Ben Elliston  <bje@au.ibm.com>\n \n \t* config/i386/i386.c (ix86_return_in_memory): Fix comment: this"}, {"sha": "24cd3644717860c453c671d1cdee750dbfc30cc0", "filename": "gcc/tree-ssa-operands.c", "status": "modified", "additions": 9, "deletions": 49, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/243cdfa86a25cafde210927deeb510910a942f12/gcc%2Ftree-ssa-operands.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/243cdfa86a25cafde210927deeb510910a942f12/gcc%2Ftree-ssa-operands.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-operands.c?ref=243cdfa86a25cafde210927deeb510910a942f12", "patch": "@@ -1038,12 +1038,11 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n   switch (code)\n     {\n     case ADDR_EXPR:\n-      /* We could have the address of a component, array member,\n-\t etc which has interesting variable references.  */\n       /* Taking the address of a variable does not represent a\n \t reference to it, but the fact that the stmt takes its address will be\n \t of interest to some passes (e.g. alias resolution).  */\n-      add_stmt_operand (expr_p, s_ann, 0);\n+      add_to_addressable_set (TREE_OPERAND (expr, 0),\n+\t\t\t      &s_ann->addresses_taken);\n \n       /* If the address is invariant, there may be no interesting variable\n \t references inside.  */\n@@ -1070,7 +1069,6 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case VAR_DECL:\n     case PARM_DECL:\n     case RESULT_DECL:\n-    case CONST_DECL:\n       {\n \tsubvar_t svars;\n \t\n@@ -1110,13 +1108,8 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n \t is the VAR_DECL for the array.  */\n \n       /* Add the virtual variable for the ARRAY_REF to VDEFS or VUSES\n-\t according to the value of IS_DEF.  Recurse if the LHS of the\n-\t ARRAY_REF node is not a regular variable.  */\n-      if (SSA_VAR_P (TREE_OPERAND (expr, 0)))\n-\tadd_stmt_operand (expr_p, s_ann, flags);\n-      else\n-\tget_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n-\n+\t according to the value of IS_DEF.  */\n+      get_expr_operands (stmt, &TREE_OPERAND (expr, 0), flags);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 1), opf_none);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 2), opf_none);\n       get_expr_operands (stmt, &TREE_OPERAND (expr, 3), opf_none);\n@@ -1259,6 +1252,7 @@ get_expr_operands (tree stmt, tree *expr_p, int flags)\n     case EXC_PTR_EXPR:\n     case FILTER_EXPR:\n     case LABEL_DECL:\n+    case CONST_DECL:\n       /* Expressions that make no memory references.  */\n       return;\n \n@@ -1441,26 +1435,6 @@ get_indirect_ref_operands (tree stmt, tree expr, int flags)\n \ts_ann->has_volatile_ops = true;\n       return;\n     }\n-\n-  /* Everything else *should* have been folded elsewhere, but users\n-     are smarter than we in finding ways to write invalid code.  We\n-     cannot just assert here.  If we were absolutely certain that we\n-     do handle all valid cases, then we could just do nothing here.\n-     That seems optimistic, so attempt to do something logical... */\n-  else if ((TREE_CODE (ptr) == PLUS_EXPR || TREE_CODE (ptr) == MINUS_EXPR)\n-\t   && TREE_CODE (TREE_OPERAND (ptr, 0)) == ADDR_EXPR\n-\t   && TREE_CODE (TREE_OPERAND (ptr, 1)) == INTEGER_CST)\n-    {\n-      /* Make sure we know the object is addressable.  */\n-      pptr = &TREE_OPERAND (ptr, 0);\n-      add_stmt_operand (pptr, s_ann, 0);\n-\n-      /* Mark the object itself with a VUSE.  */\n-      pptr = &TREE_OPERAND (*pptr, 0);\n-      get_expr_operands (stmt, pptr, flags);\n-      return;\n-    }\n-\n   /* Ok, this isn't even is_gimple_min_invariant.  Something's broke.  */\n   else\n     gcc_unreachable ();\n@@ -1577,26 +1551,12 @@ add_stmt_operand (tree *var_p, stmt_ann_t s_ann, int flags)\n   var_ann_t v_ann;\n \n   var = *var_p;\n-  STRIP_NOPS (var);\n+  gcc_assert (SSA_VAR_P (var));\n \n-  /* If the operand is an ADDR_EXPR, add its operand to the list of\n-     variables that have had their address taken in this statement.  */\n-  if (TREE_CODE (var) == ADDR_EXPR && s_ann)\n-    {\n-      add_to_addressable_set (TREE_OPERAND (var, 0), &s_ann->addresses_taken);\n-      return;\n-    }\n-\n-  /* If the original variable is not a scalar, it will be added to the list\n-     of virtual operands.  In that case, use its base symbol as the virtual\n-     variable representing it.  */\n   is_real_op = is_gimple_reg (var);\n-  if (!is_real_op && !DECL_P (var))\n-    var = get_virtual_var (var);\n-\n-  /* If VAR is not a variable that we care to optimize, do nothing.  */\n-  if (var == NULL_TREE || !SSA_VAR_P (var))\n-    return;\n+  /* If this is a real operand, the operand is either ssa name or decl.\n+     Virtual operands may only be decls.  */\n+  gcc_assert (is_real_op || DECL_P (var));\n \n   sym = (TREE_CODE (var) == SSA_NAME ? SSA_NAME_VAR (var) : var);\n   v_ann = var_ann (sym);"}]}