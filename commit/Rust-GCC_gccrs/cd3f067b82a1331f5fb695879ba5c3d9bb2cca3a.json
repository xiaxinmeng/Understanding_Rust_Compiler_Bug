{"sha": "cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2QzZjA2N2I4MmExMzMxZjVmYjY5NTg3OWJhNWMzZDliYjJjY2EzYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-01T23:07:05Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-01T23:07:05Z"}, "message": "libstdc++: Fix filesystem::u8path for mingw targets (PR 95392)\n\nWhen I refactored filesystem::path string conversions in\nr11-587-584d52b088f9fcf78704b504c3f1f07e17c1cded I failed to update the\nmingw-specific code in filesystem::u8path, causing a bootstrap failure.\n\nThis fixes it, and further refactors the mingw-specific code along the\nsame lines as the previous commit. All conversions from UTF-8 strings to\nwide strings now use the same helper function, __wstr_from_utf8.\n\n\tPR libstdc++/95392\n\t* include/bits/fs_path.h (path::_S_to_string): Move to\n\tnamespace-scope and rename to ...\n\t(__detail::__string_from_range): ... this.\n\t[WINDOWS] (__detail::__wstr_from_utf8): New function template to\n\tconvert a char sequence containing UTF-8 to wstring.\n\t(path::_S_convert(Iter, Iter)): Adjust call to _S_to_string.\n\t(path::_S_convert_loc(Iter, Iter, const locale&)): Likewise.\n\t(u8path(InputIterator, InputIterator)) [WINDOWS]: Use\n\t__string_from_range to obtain a contiguous range and\n\t__wstr_from_utf8 to obtain a wide string.\n\t(u8path(const Source&)) [WINDOWS]: Use __effective_range to\n\tobtain a contiguous range and __wstr_from_utf8 to obtain a wide\n\tstring.\n\t(path::_S_convert(const _EcharT*, const _EcharT)) [WINDOWS]:\n\tUse __wstr_from_utf8.", "tree": {"sha": "2429c301f24875951570a65c662f455e3bbec2ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2429c301f24875951570a65c662f455e3bbec2ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c7969df1c5d3785c0b409f97e7682a6f0d2637ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c7969df1c5d3785c0b409f97e7682a6f0d2637ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c7969df1c5d3785c0b409f97e7682a6f0d2637ec"}], "stats": {"total": 132, "additions": 57, "deletions": 75}, "files": [{"sha": "26ddf0afec41c78ddc5341c09ef1d0b920486fef", "filename": "libstdc++-v3/include/bits/fs_path.h", "status": "modified", "additions": 57, "deletions": 75, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Ffs_path.h?ref=cd3f067b82a1331f5fb695879ba5c3d9bb2cca3a", "patch": "@@ -211,6 +211,51 @@ namespace __detail\n #endif\n \t\t\t , _Val>;\n \n+  // Create a string or string view from an iterator range.\n+  template<typename _InputIterator>\n+    inline auto\n+    __string_from_range(_InputIterator __first, _InputIterator __last)\n+    {\n+      using _EcharT\n+\t= typename std::iterator_traits<_InputIterator>::value_type;\n+      static_assert(__is_encoded_char<_EcharT>);\n+\n+#if __cpp_lib_concepts\n+      constexpr bool __contiguous = std::contiguous_iterator<_InputIterator>;\n+#else\n+      constexpr bool __contiguous\n+\t= is_pointer_v<decltype(std::__niter_base(__first))>;\n+#endif\n+      if constexpr (__contiguous)\n+\t{\n+\t  // For contiguous iterators we can just return a string view.\n+\t  const auto* __f = std::__to_address(std::__niter_base(__first));\n+\t  const auto* __l = std::__to_address(std::__niter_base(__last));\n+\t  return basic_string_view<_EcharT>(__f, __l - __f);\n+\t}\n+      else\n+\t// Conversion requires contiguous characters, so create a string.\n+\treturn basic_string<_EcharT>(__first, __last);\n+    }\n+\n+#ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n+  template<typename _Tp>\n+    inline std::wstring\n+    __wstr_from_utf8(const _Tp& __str)\n+    {\n+      static_assert(std::is_same_v<typename _Tp::value_type, char>);\n+      std::wstring __wstr;\n+      // XXX This assumes native wide encoding is UTF-16.\n+      std::codecvt_utf8_utf16<wchar_t> __wcvt;\n+      const auto __p = __str.data();\n+      if (!__str_codecvt_in_all(__p, __p + __str.size(), __wstr, __wcvt))\n+\t_GLIBCXX_THROW_OR_ABORT(filesystem_error(\n+\t      \"Cannot convert character sequence\",\n+\t      std::make_error_code(errc::illegal_byte_sequence)));\n+      return __wstr;\n+    }\n+#endif\n+\n } // namespace __detail\n   /// @endcond\n \n@@ -542,33 +587,6 @@ namespace __detail\n \n     pair<const string_type*, size_t> _M_find_extension() const noexcept;\n \n-    // Create a string or string view from an iterator range.\n-    template<typename _InputIterator>\n-      static auto\n-      _S_to_string(_InputIterator __first, _InputIterator __last)\n-      {\n-\tusing _EcharT\n-\t  = typename std::iterator_traits<_InputIterator>::value_type;\n-\tstatic_assert(__detail::__is_encoded_char<_EcharT>);\n-\n-#if __cpp_lib_concepts\n-\tconstexpr bool __contiguous = std::contiguous_iterator<_InputIterator>;\n-#else\n-\tconstexpr bool __contiguous\n-\t  = is_pointer_v<decltype(std::__niter_base(__first))>;\n-#endif\n-\tif constexpr (__contiguous)\n-\t  {\n-\t    // For contiguous iterators we can just return a string view.\n-\t    const auto* __f = std::__to_address(std::__niter_base(__first));\n-\t    const auto* __l = std::__to_address(std::__niter_base(__last));\n-\t    return basic_string_view<_EcharT>(__f, __l - __f);\n-\t  }\n-\telse\n-\t  // Conversion requires contiguous characters, so create a string.\n-\t  return basic_string<_EcharT>(__first, __last);\n-      }\n-\n     // path::_S_convert creates a basic_string<value_type> or\n     // basic_string_view<value_type> from a range (either the effective\n     // range of a Source parameter, or a pair of InputIterator parameters),\n@@ -602,7 +620,7 @@ namespace __detail\n     template<typename _Iter>\n       static auto\n       _S_convert(_Iter __first, _Iter __last)\n-      { return _S_convert(_S_to_string(__first, __last)); }\n+      { return _S_convert(__detail::__string_from_range(__first, __last)); }\n \n     static string_type\n     _S_convert_loc(const char* __first, const char* __last,\n@@ -612,7 +630,7 @@ namespace __detail\n       static string_type\n       _S_convert_loc(_Iter __first, _Iter __last, const std::locale& __loc)\n       {\n-\tconst auto __s = _S_to_string(__first, __last);\n+\tconst auto __s = __detail::__string_from_range(__first, __last);\n \treturn _S_convert_loc(__s.data(), __s.data() + __s.size(), __loc);\n       }\n \n@@ -738,28 +756,10 @@ namespace __detail\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n       if constexpr (is_same_v<_CharT, char>)\n-\t{\n-\t  // XXX This assumes native wide encoding is UTF-16.\n-\t  std::codecvt_utf8_utf16<path::value_type> __cvt;\n-\t  path::string_type __tmp;\n-\t  if constexpr (is_pointer_v<_InputIterator>)\n-\t    {\n-\t      if (__str_codecvt_in_all(__first, __last, __tmp, __cvt))\n-\t\treturn path{ __tmp };\n-\t    }\n-\t  else\n-\t    {\n-\t      const std::string __u8str{__first, __last};\n-\t      const char* const __p = __u8str.data();\n-\t      if (__str_codecvt_in_all(__p, __p + __u8str.size(), __tmp, __cvt))\n-\t\treturn path{ __tmp };\n-\t    }\n-\t  _GLIBCXX_THROW_OR_ABORT(filesystem_error(\n-\t      \"Cannot convert character sequence\",\n-\t      std::make_error_code(errc::illegal_byte_sequence)));\n-\t}\n+\treturn path{ __detail::__wstr_from_utf8(\n+\t    __detail::__string_from_range(__first, __last)) };\n       else\n-\treturn path{ __first, __last };\n+\treturn path{ __first, __last }; // constructor handles char8_t\n #else\n       // This assumes native normal encoding is UTF-8.\n       return path{ __first, __last };\n@@ -778,21 +778,12 @@ namespace __detail\n     {\n #ifdef _GLIBCXX_FILESYSTEM_IS_WINDOWS\n       if constexpr (is_same_v<_CharT, char>)\n-\t{\n-\t  if constexpr (is_convertible_v<const _Source&, std::string_view>)\n-\t    {\n-\t      const std::string_view __s = __source;\n-\t      return filesystem::u8path(__s.data(), __s.data() + __s.size());\n-\t    }\n-\t  else\n-\t    {\n-\t      std::string __s = path::_S_string_from_iter(__source);\n-\t      return filesystem::u8path(__s.data(), __s.data() + __s.size());\n-\t    }\n-\t}\n+\treturn path{ __detail::__wstr_from_utf8(\n+\t    __detail::__effective_range(__source)) };\n       else\n-\treturn path{ __source };\n+\treturn path{ __source }; // constructor handles char8_t\n #else\n+      // This assumes native normal encoding is UTF-8.\n       return path{ __source };\n #endif\n     }\n@@ -836,11 +827,8 @@ namespace __detail\n #ifdef _GLIBCXX_USE_CHAR8_T\n \t  else if constexpr (is_same_v<_EcharT, char8_t>)\n \t    {\n-\t      const char* __f2 = (const char*)__f;\n-\t      const char* __l2 = (const char*)__l;\n-\t      std::codecvt_utf8_utf16<wchar_t> __wcvt;\n-\t      if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n-\t\treturn __wstr;\n+\t      const auto __f2 = reinterpret_cast<const char*>(__f);\n+\t      return __detail::__wstr_from_utf8(string_view(__f2, __l - __f));\n \t    }\n #endif\n \t  else // char16_t or char32_t\n@@ -849,13 +837,7 @@ namespace __detail\n \t      { } __cvt;\n \t      std::string __str;\n \t      if (__str_codecvt_out_all(__f, __l, __str, __cvt))\n-\t\t{\n-\t\t  const char* __f2 = __str.data();\n-\t\t  const char* __l2 = __f2 + __str.size();\n-\t\t  std::codecvt_utf8_utf16<wchar_t> __wcvt;\n-\t\t  if (__str_codecvt_in_all(__f2, __l2, __wstr, __wcvt))\n-\t\t    return __wstr;\n-\t\t}\n+\t\treturn __detail::__wstr_from_utf8(__str);\n \t    }\n #else // ! windows\n \t  struct _UCvt : std::codecvt<_EcharT, char, std::mbstate_t>"}]}