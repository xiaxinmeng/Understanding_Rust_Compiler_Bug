{"sha": "05d362b88d8226fd136f53aac476527ea8381719", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDVkMzYyYjg4ZDgyMjZmZDEzNmY1M2FhYzQ3NjUyN2VhODM4MTcxOQ==", "commit": {"author": {"name": "Roger Sayle", "email": "roger@eyesopen.com", "date": "2003-10-11T21:15:08Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2003-10-11T21:15:08Z"}, "message": "fold-const.c (negate_mathfn_p): New function to determine whether a built-in mathematical function is sign...\n\n\n\t* fold-const.c (negate_mathfn_p): New function to determine whether\n\ta built-in mathematical function is sign preserving, f(-x) == -f(x).\n\tAdd support for BUILT_IN_ASIN, BUILT_IN_ASINF and BUILT_IN_ASINL.\n\t(tree_swap_operands_p): Change API to take an additional argument\n\tindicating that the swapped operands evaluate in reverse order.\n\tCanonicalize VAR_DECLs and PARM_DECLs last if we can, i.e. neither\n\toperand side-effects or we don't care about flag_evaluation_order.\n\t(reorder_operands_p): New function to check whether its safe to\n\tevaluate the given operands in reverse order.\n\t(negate_expr_p):  We can always negate integer constants unless\n\twe honor -ftrapv and the signed type would overflow.  Only allow\n\t-(A-B) into B-A if reorder_operands_p says that its OK.  Allow\n\tnegation of COMPLEX_CST if both real and imaginary parts can be\n\tnegated.  Allow negation through floating point extensions and\n\tsign-preserving built-in functions.\n\t(negate_expr):  Move the code to negate integers from \"fold\" to\n\there.  Always negate integer constants unless we honor -ftrapv\n\tand the signed type would overflow.  Always negate real constants\n\tunless we honor -ftrapping-math.  Only convert -(A-B) into B-A\n\tif allowed by reorder_operands_p.  Add support for COMPLEX_CST.\n\tOptimize negation through floating point extensions and\n\tsign-preserving built-in functions (as defined by negate_mathfn_p).\n\t(fold): Adjust calls to tree_swap_operands_p.\n\t(fold <NEGATE_EXPR>): Move the remaining negation optimizations\n\tto negate_expr_p/negate_expr.\n\t(fold <MINUS_EXPR>): Use reorder_operands_p to check whether we're\n\tallowed to convert (-A) - B into (-B) - A.\n\nFrom-SVN: r72381", "tree": {"sha": "2ea903ac1b386f6fcfc5ba2e8ca0396ba01e21b0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2ea903ac1b386f6fcfc5ba2e8ca0396ba01e21b0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/05d362b88d8226fd136f53aac476527ea8381719", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d362b88d8226fd136f53aac476527ea8381719", "html_url": "https://github.com/Rust-GCC/gccrs/commit/05d362b88d8226fd136f53aac476527ea8381719", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/05d362b88d8226fd136f53aac476527ea8381719/comments", "author": null, "committer": null, "parents": [{"sha": "c43fa1f51a746777e557c1ca99b6111474c5c961", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c43fa1f51a746777e557c1ca99b6111474c5c961", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c43fa1f51a746777e557c1ca99b6111474c5c961"}], "stats": {"total": 258, "additions": 177, "deletions": 81}, "files": [{"sha": "b233e9496e477abb3ac633575fb001a87aa03704", "filename": "gcc/ChangeLog", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05d362b88d8226fd136f53aac476527ea8381719/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05d362b88d8226fd136f53aac476527ea8381719/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=05d362b88d8226fd136f53aac476527ea8381719", "patch": "@@ -1,3 +1,33 @@\n+2003-10-11  Roger Sayle  <roger@eyesopen.com>\n+\n+\t* fold-const.c (negate_mathfn_p): New function to determine whether\n+\ta built-in mathematical function is sign preserving, f(-x) == -f(x).\n+\tAdd support for BUILT_IN_ASIN, BUILT_IN_ASINF and BUILT_IN_ASINL.\n+\t(tree_swap_operands_p): Change API to take an additional argument\n+\tindicating that the swapped operands evaluate in reverse order.\n+\tCanonicalize VAR_DECLs and PARM_DECLs last if we can, i.e. neither\n+\toperand side-effects or we don't care about flag_evaluation_order.\n+\t(reorder_operands_p): New function to check whether its safe to\n+\tevaluate the given operands in reverse order.\n+\t(negate_expr_p):  We can always negate integer constants unless\n+\twe honor -ftrapv and the signed type would overflow.  Only allow\n+\t-(A-B) into B-A if reorder_operands_p says that its OK.  Allow\n+\tnegation of COMPLEX_CST if both real and imaginary parts can be\n+\tnegated.  Allow negation through floating point extensions and\n+\tsign-preserving built-in functions.\n+\t(negate_expr):  Move the code to negate integers from \"fold\" to\n+\there.  Always negate integer constants unless we honor -ftrapv\n+\tand the signed type would overflow.  Always negate real constants\n+\tunless we honor -ftrapping-math.  Only convert -(A-B) into B-A\n+\tif allowed by reorder_operands_p.  Add support for COMPLEX_CST.\n+\tOptimize negation through floating point extensions and \n+\tsign-preserving built-in functions (as defined by negate_mathfn_p).\n+\t(fold): Adjust calls to tree_swap_operands_p.\n+\t(fold <NEGATE_EXPR>): Move the remaining negation optimizations\n+\tto negate_expr_p/negate_expr.\n+\t(fold <MINUS_EXPR>): Use reorder_operands_p to check whether we're\n+\tallowed to convert (-A) - B into (-B) - A.\n+\n 2003-10-11  Roger Sayle  <roger@eyesopen.com>\n \n \t* builtins.c (expand_builtin_strcmp): Defend against the possibility"}, {"sha": "2e64314c46e4ec685ee77c396b4f4472c3c63f6f", "filename": "gcc/fold-const.c", "status": "modified", "additions": 147, "deletions": 81, "changes": 228, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/05d362b88d8226fd136f53aac476527ea8381719/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/05d362b88d8226fd136f53aac476527ea8381719/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=05d362b88d8226fd136f53aac476527ea8381719", "patch": "@@ -60,6 +60,7 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n \n static void encode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT, HOST_WIDE_INT);\n static void decode (HOST_WIDE_INT *, unsigned HOST_WIDE_INT *, HOST_WIDE_INT *);\n+static bool negate_mathfn_p (enum built_in_function);\n static bool negate_expr_p (tree);\n static tree negate_expr (tree);\n static tree split_tree (tree, enum tree_code, tree *, tree *, tree *, int);\n@@ -108,7 +109,8 @@ static bool fold_real_zero_addition_p (tree, tree, int);\n static tree fold_mathfn_compare (enum built_in_function, enum tree_code,\n \t\t\t\t tree, tree, tree);\n static tree fold_inf_compare (enum tree_code, tree, tree, tree);\n-static bool tree_swap_operands_p (tree, tree);\n+static bool reorder_operands_p (tree, tree);\n+static bool tree_swap_operands_p (tree, tree, bool);\n \n /* The following constants represent a bit based encoding of GCC's\n    comparison operators.  This encoding simplifies transformations\n@@ -803,6 +805,35 @@ div_and_round_double (enum tree_code code, int uns,\n   return overflow;\n }\n \f\n+/* Return true if built-in mathematical function specified by CODE\n+   preserves the sign of it argument, i.e. -f(x) == f(-x).  */\n+\n+static bool\n+negate_mathfn_p (enum built_in_function code)\n+{\n+  switch (code)\n+    {\n+    case BUILT_IN_ASIN:\n+    case BUILT_IN_ASINF:\n+    case BUILT_IN_ASINL:\n+    case BUILT_IN_ATAN:\n+    case BUILT_IN_ATANF:\n+    case BUILT_IN_ATANL:\n+    case BUILT_IN_SIN:\n+    case BUILT_IN_SINF:\n+    case BUILT_IN_SINL:\n+    case BUILT_IN_TAN:\n+    case BUILT_IN_TANF:\n+    case BUILT_IN_TANL:\n+      return true;\n+\n+    default:\n+      break;\n+    }\n+  return false;\n+}\n+\n+\n /* Determine whether an expression T can be cheaply negated using\n    the function negate_expr.  */\n \n@@ -822,8 +853,8 @@ negate_expr_p (tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-      if (TREE_UNSIGNED (type))\n-\treturn false;\n+      if (TREE_UNSIGNED (type) || ! flag_trapv)\n+\treturn true;\n \n       /* Check that -CST will not overflow type.  */\n       prec = TYPE_PRECISION (type);\n@@ -844,9 +875,15 @@ negate_expr_p (tree t)\n     case NEGATE_EXPR:\n       return true;\n \n+    case COMPLEX_CST:\n+      return negate_expr_p (TREE_REALPART (t))\n+\t     && negate_expr_p (TREE_IMAGPART (t));\n+\n     case MINUS_EXPR:\n       /* We can't turn -(A-B) into B-A when we honor signed zeros.  */\n-      return ! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations;\n+      return (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+\t     && reorder_operands_p (TREE_OPERAND (t, 0),\n+\t\t\t\t    TREE_OPERAND (t, 1));\n \n     case MULT_EXPR:\n       if (TREE_UNSIGNED (TREE_TYPE (t)))\n@@ -860,6 +897,22 @@ negate_expr_p (tree t)\n \t       || negate_expr_p (TREE_OPERAND (t, 0));\n       break;\n \n+    case NOP_EXPR:\n+      /* Negate -((double)float) as (double)(-float).  */\n+      if (TREE_CODE (type) == REAL_TYPE)\n+\t{\n+\t  tree tem = strip_float_extensions (t);\n+\t  if (tem != t)\n+\t    return negate_expr_p (tem);\n+\t}\n+      break;\n+\n+    case CALL_EXPR:\n+      /* Negate -f(x) as f(-x).  */\n+      if (negate_mathfn_p (builtin_mathfn_code (t)))\n+\treturn negate_expr_p (TREE_VALUE (TREE_OPERAND (t, 1)));\n+      break;\n+\n     default:\n       break;\n     }\n@@ -884,25 +937,53 @@ negate_expr (tree t)\n   switch (TREE_CODE (t))\n     {\n     case INTEGER_CST:\n-      if (! TREE_UNSIGNED (type)\n-\t  && 0 != (tem = fold (build1 (NEGATE_EXPR, type, t)))\n-\t  && ! TREE_OVERFLOW (tem))\n+      {\n+\tunsigned HOST_WIDE_INT low;\n+\tHOST_WIDE_INT high;\n+\tint overflow = neg_double (TREE_INT_CST_LOW (t),\n+\t\t\t\t   TREE_INT_CST_HIGH (t),\n+\t\t\t\t   &low, &high);\n+\ttem = build_int_2 (low, high);\n+\tTREE_TYPE (tem) = type;\n+\tTREE_OVERFLOW (tem)\n+\t  = (TREE_OVERFLOW (t)\n+\t     | force_fit_type (tem, overflow && !TREE_UNSIGNED (type)));\n+\tTREE_CONSTANT_OVERFLOW (tem)\n+\t  = TREE_OVERFLOW (tem) | TREE_CONSTANT_OVERFLOW (t);\n+      }\n+      if (! TREE_OVERFLOW (tem)\n+\t  || TREE_UNSIGNED (type)\n+\t  || ! flag_trapv)\n \treturn tem;\n       break;\n \n     case REAL_CST:\n       tem = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (t)));\n       /* Two's complement FP formats, such as c4x, may overflow.  */\n-      if (! TREE_OVERFLOW (tem))\n+      if (! TREE_OVERFLOW (tem) || ! flag_trapping_math)\n \treturn convert (type, tem);\n       break;\n \n+    case COMPLEX_CST:\n+      {\n+\ttree rpart = negate_expr (TREE_REALPART (t));\n+\ttree ipart = negate_expr (TREE_IMAGPART (t));\n+\n+\tif ((TREE_CODE (rpart) == REAL_CST\n+\t     && TREE_CODE (ipart) == REAL_CST)\n+\t    || (TREE_CODE (rpart) == INTEGER_CST\n+\t\t&& TREE_CODE (ipart) == INTEGER_CST))\n+\t  return build_complex (type, rpart, ipart);\n+      }\n+      break;\n+\n     case NEGATE_EXPR:\n       return convert (type, TREE_OPERAND (t, 0));\n \n     case MINUS_EXPR:\n       /* - (A - B) -> B - A  */\n-      if (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+      if ((! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations)\n+\t  && reorder_operands_p (TREE_OPERAND (t, 0), TREE_OPERAND (t, 1)))\n \treturn convert (type,\n \t\t\tfold (build (MINUS_EXPR, TREE_TYPE (t),\n \t\t\t\t     TREE_OPERAND (t, 1),\n@@ -933,6 +1014,30 @@ negate_expr (tree t)\n \t}\n       break;\n \n+    case NOP_EXPR:\n+      /* Convert -((double)float) into (double)(-float).  */\n+      if (TREE_CODE (type) == REAL_TYPE)\n+\t{\n+\t  tem = strip_float_extensions (t);\n+\t  if (tem != t && negate_expr_p (tem))\n+\t    return convert (type, negate_expr (tem));\n+\t}\n+      break;\n+\n+    case CALL_EXPR:\n+      /* Negate -f(x) as f(-x).  */\n+      if (negate_mathfn_p (builtin_mathfn_code (t))\n+\t  && negate_expr_p (TREE_VALUE (TREE_OPERAND (t, 1))))\n+\t{\n+\t  tree fndecl, arg, arglist;\n+\n+\t  fndecl = get_callee_fndecl (t);\n+\t  arg = negate_expr (TREE_VALUE (TREE_OPERAND (t, 1)));\n+\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t  return build_function_call_expr (fndecl, arglist);\n+\t}\n+      break;\n+\n     default:\n       break;\n     }\n@@ -4999,12 +5104,27 @@ fold_single_bit_test (enum tree_code code, tree arg0, tree arg1,\n   return NULL_TREE;\n }\n \n+/* Check whether we are allowed to reorder operands arg0 and arg1,\n+   such that the evaluation of arg1 occurs before arg0.  */\n+\n+static bool\n+reorder_operands_p (tree arg0, tree arg1)\n+{\n+  if (! flag_evaluation_order)\n+    return true;\n+  if (TREE_CONSTANT (arg0) || TREE_CONSTANT (arg1))\n+    return true;\n+  return ! TREE_SIDE_EFFECTS (arg0)\n+\t && ! TREE_SIDE_EFFECTS (arg1);\n+}\n+\n /* Test whether it is preferable two swap two operands, ARG0 and\n    ARG1, for example because ARG0 is an integer constant and ARG1\n-   isn't.  */\n+   isn't.  If REORDER is true, only recommend swapping if we can\n+   evaluate the operands in reverse order.  */\n \n static bool\n-tree_swap_operands_p (tree arg0, tree arg1)\n+tree_swap_operands_p (tree arg0, tree arg1, bool reorder)\n {\n   STRIP_SIGN_NOPS (arg0);\n   STRIP_SIGN_NOPS (arg1);\n@@ -5029,6 +5149,15 @@ tree_swap_operands_p (tree arg0, tree arg1)\n   if (TREE_CONSTANT (arg0))\n     return 1;\n \n+  if (reorder && flag_evaluation_order\n+      && (TREE_SIDE_EFFECTS (arg0) || TREE_SIDE_EFFECTS (arg1)))\n+    return 0;\n+\n+  if (DECL_P (arg1))\n+    return 0;\n+  if (DECL_P (arg0))\n+    return 1;\n+\n   return 0;\n }\n \n@@ -5143,7 +5272,7 @@ fold (tree expr)\n   if ((code == PLUS_EXPR || code == MULT_EXPR || code == MIN_EXPR\n        || code == MAX_EXPR || code == BIT_IOR_EXPR || code == BIT_XOR_EXPR\n        || code == BIT_AND_EXPR)\n-      && tree_swap_operands_p (arg0, arg1))\n+      && tree_swap_operands_p (arg0, arg1, true))\n     return fold (build (code, type, arg1, arg0));\n \n   /* Now WINS is set as described above,\n@@ -5482,71 +5611,8 @@ fold (tree expr)\n       return t;\n \n     case NEGATE_EXPR:\n-      if (wins)\n-\t{\n-\t  if (TREE_CODE (arg0) == INTEGER_CST)\n-\t    {\n-\t      unsigned HOST_WIDE_INT low;\n-\t      HOST_WIDE_INT high;\n-\t      int overflow = neg_double (TREE_INT_CST_LOW (arg0),\n-\t\t\t\t\t TREE_INT_CST_HIGH (arg0),\n-\t\t\t\t\t &low, &high);\n-\t      t = build_int_2 (low, high);\n-\t      TREE_TYPE (t) = type;\n-\t      TREE_OVERFLOW (t)\n-\t\t= (TREE_OVERFLOW (arg0)\n-\t\t   | force_fit_type (t, overflow && !TREE_UNSIGNED (type)));\n-\t      TREE_CONSTANT_OVERFLOW (t)\n-\t\t= TREE_OVERFLOW (t) | TREE_CONSTANT_OVERFLOW (arg0);\n-\t    }\n-\t  else if (TREE_CODE (arg0) == REAL_CST)\n-\t    t = build_real (type, REAL_VALUE_NEGATE (TREE_REAL_CST (arg0)));\n-\t}\n-      else if (TREE_CODE (arg0) == NEGATE_EXPR)\n-\treturn TREE_OPERAND (arg0, 0);\n-      /* Convert -((double)float) into (double)(-float).  */\n-      else if (TREE_CODE (arg0) == NOP_EXPR\n-\t       && TREE_CODE (type) == REAL_TYPE)\n-\t{\n-\t  tree targ0 = strip_float_extensions (arg0);\n-\t  if (targ0 != arg0)\n-\t    return convert (type, build1 (NEGATE_EXPR, TREE_TYPE (targ0), targ0));\n-\n-\t}\n-\n-      /* Convert - (a - b) to (b - a) for non-floating-point.  */\n-      else if (TREE_CODE (arg0) == MINUS_EXPR\n-\t       && (! FLOAT_TYPE_P (type) || flag_unsafe_math_optimizations))\n-\treturn build (MINUS_EXPR, type, TREE_OPERAND (arg0, 1),\n-\t\t      TREE_OPERAND (arg0, 0));\n-\n-      /* Convert -f(x) into f(-x) where f is sin, tan or atan.  */\n-      switch (builtin_mathfn_code (arg0))\n-\t{\n-\tcase BUILT_IN_SIN:\n-\tcase BUILT_IN_SINF:\n-\tcase BUILT_IN_SINL:\n-\tcase BUILT_IN_TAN:\n-\tcase BUILT_IN_TANF:\n-\tcase BUILT_IN_TANL:\n-\tcase BUILT_IN_ATAN:\n-\tcase BUILT_IN_ATANF:\n-\tcase BUILT_IN_ATANL:\n-\t  if (negate_expr_p (TREE_VALUE (TREE_OPERAND (arg0, 1))))\n-\t    {\n-\t      tree fndecl, arg, arglist;\n-\n-\t      fndecl = get_callee_fndecl (arg0);\n-\t      arg = TREE_VALUE (TREE_OPERAND (arg0, 1));\n-\t      arg = fold (build1 (NEGATE_EXPR, type, arg));\n-\t      arglist = build_tree_list (NULL_TREE, arg);\n-\t      return build_function_call_expr (fndecl, arglist);\n-\t    }\n-\t  break;\n-\n-\tdefault:\n-\t  break;\n-\t}\n+      if (negate_expr_p (arg0))\n+\treturn negate_expr (arg0);\n       return t;\n \n     case ABS_EXPR:\n@@ -5999,8 +6065,7 @@ fold (tree expr)\n \t  && (FLOAT_TYPE_P (type)\n \t      || (INTEGRAL_TYPE_P (type) && flag_wrapv && !flag_trapv))\n \t  && negate_expr_p (arg1)\n-\t  && (! TREE_SIDE_EFFECTS (arg0) || TREE_CONSTANT (arg1))\n-\t  && (! TREE_SIDE_EFFECTS (arg1) || TREE_CONSTANT (arg0)))\n+\t  && reorder_operands_p (arg0, arg1))\n \treturn fold (build (MINUS_EXPR, type, negate_expr (arg1),\n \t\t\t    TREE_OPERAND (arg0, 0)));\n \n@@ -6911,7 +6976,7 @@ fold (tree expr)\n     case LE_EXPR:\n     case GE_EXPR:\n       /* If one arg is a real or integer constant, put it last.  */\n-      if (tree_swap_operands_p (arg0, arg1))\n+      if (tree_swap_operands_p (arg0, arg1, true))\n \treturn fold (build (swap_tree_comparison (code), type, arg1, arg0));\n \n       if (FLOAT_TYPE_P (TREE_TYPE (arg0)))\n@@ -8025,7 +8090,8 @@ fold (tree expr)\n \n       /* If the second operand is simpler than the third, swap them\n \t since that produces better jump optimization results.  */\n-      if (tree_swap_operands_p (TREE_OPERAND (t, 1), TREE_OPERAND (t, 2)))\n+      if (tree_swap_operands_p (TREE_OPERAND (t, 1),\n+\t\t\t\tTREE_OPERAND (t, 2), false))\n \t{\n \t  /* See if this can be inverted.  If it can't, possibly because\n \t     it was a floating-point inequality comparison, don't do"}]}