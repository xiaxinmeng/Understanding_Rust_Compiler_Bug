{"sha": "ddb3773a1230fc16c29d8df7af3200afbab93359", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGRiMzc3M2ExMjMwZmMxNmMyOWQ4ZGY3YWYzMjAwYWZiYWI5MzM1OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-05-13T02:54:50Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-05-13T02:54:50Z"}, "message": "re PR ipa/65873 (Failure to inline always_inline memcpy)\n\n\n\tPR ipa/65873\n\t* ipa-inline.c (can_inline_edge_p): Allow early inlining of always\n\tinlines across optimization boundary.\n\nFrom-SVN: r223107", "tree": {"sha": "83e46c62e730b29f6e90da37da4a6774bc5dde3f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/83e46c62e730b29f6e90da37da4a6774bc5dde3f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ddb3773a1230fc16c29d8df7af3200afbab93359", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb3773a1230fc16c29d8df7af3200afbab93359", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ddb3773a1230fc16c29d8df7af3200afbab93359", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ddb3773a1230fc16c29d8df7af3200afbab93359/comments", "author": null, "committer": null, "parents": [{"sha": "fe1814cf8401eb2cdc54ce76838bd5996d9d6e70", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe1814cf8401eb2cdc54ce76838bd5996d9d6e70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe1814cf8401eb2cdc54ce76838bd5996d9d6e70"}], "stats": {"total": 96, "additions": 61, "deletions": 35}, "files": [{"sha": "3da39da22e50a43ab73f1db7fb94bee2a60ba74a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb3773a1230fc16c29d8df7af3200afbab93359/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb3773a1230fc16c29d8df7af3200afbab93359/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ddb3773a1230fc16c29d8df7af3200afbab93359", "patch": "@@ -1,3 +1,9 @@\n+2015-05-12  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/65873\n+\t* ipa-inline.c (can_inline_edge_p): Allow early inlining of always\n+\tinlines across optimization boundary.\n+\n 2015-05-12  Jason Merrill  <jason@redhat.com>\n \n \t* config/mmix/mmix.c, config/msp430/msp430.c: Add space between"}, {"sha": "7fd2374bc52962d10ee410c266179a4eee574ed1", "filename": "gcc/ipa-inline.c", "status": "modified", "additions": 55, "deletions": 35, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ddb3773a1230fc16c29d8df7af3200afbab93359/gcc%2Fipa-inline.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ddb3773a1230fc16c29d8df7af3200afbab93359/gcc%2Fipa-inline.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-inline.c?ref=ddb3773a1230fc16c29d8df7af3200afbab93359", "patch": "@@ -427,46 +427,55 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t      && lookup_attribute (\"always_inline\",\n \t\t\t\t   DECL_ATTRIBUTES (callee->decl)));\n \n+     /* Until GCC 4.9 we did not check the semantics alterning flags\n+\tbellow and inline across optimization boundry.\n+\tEnabling checks bellow breaks several packages by refusing\n+\tto inline library always_inline functions. See PR65873.\n+\tDisable the check for early inlining for now until better solution\n+\tis found.  */\n+     if (always_inline && early)\n+\t;\n       /* There are some options that change IL semantics which means\n          we cannot inline in these cases for correctness reason.\n \t Not even for always_inline declared functions.  */\n       /* Strictly speaking only when the callee contains signed integer\n          math where overflow is undefined.  */\n-      if ((check_maybe_up (flag_strict_overflow)\n-\t   /* this flag is set by optimize.  Allow inlining across\n-\t      optimize boundary.  */\n-\t   && (!opt_for_fn (caller->decl, optimize)\n-\t       == !opt_for_fn (callee->decl, optimize) || !always_inline))\n-\t  || check_match (flag_wrapv)\n-\t  || check_match (flag_trapv)\n-\t  /* Strictly speaking only when the callee uses FP math.  */\n-\t  || check_maybe_up (flag_rounding_math)\n-\t  || check_maybe_up (flag_trapping_math)\n-\t  || check_maybe_down (flag_unsafe_math_optimizations)\n-\t  || check_maybe_down (flag_finite_math_only)\n-\t  || check_maybe_up (flag_signaling_nans)\n-\t  || check_maybe_down (flag_cx_limited_range)\n-\t  || check_maybe_up (flag_signed_zeros)\n-\t  || check_maybe_down (flag_associative_math)\n-\t  || check_maybe_down (flag_reciprocal_math)\n-\t  /* We do not want to make code compiled with exceptions to be brought\n-\t     into a non-EH function unless we know that the callee does not\n-\t     throw.  This is tracked by DECL_FUNCTION_PERSONALITY.  */\n-\t  || (check_match (flag_non_call_exceptions)\n-\t      /* TODO: We also may allow bringing !flag_non_call_exceptions\n-\t\t to flag_non_call_exceptions function, but that may need\n-\t\t extra work in tree-inline to add the extra EH edges.  */\n-\t      && (!opt_for_fn (callee->decl, flag_non_call_exceptions)\n-\t\t  || DECL_FUNCTION_PERSONALITY (callee->decl)))\n-\t  || (check_maybe_up (flag_exceptions)\n-\t      && DECL_FUNCTION_PERSONALITY (callee->decl))\n-\t  /* Strictly speaking only when the callee contains function\n-\t     calls that may end up setting errno.  */\n-\t  || check_maybe_up (flag_errno_math)\n-\t  /* When devirtualization is diabled for callee, it is not safe\n-\t     to inline it as we possibly mangled the type info.\n-\t     Allow early inlining of always inlines.  */\n-\t  || (!early && check_maybe_down (flag_devirtualize)))\n+     else if ((check_maybe_up (flag_strict_overflow)\n+\t       /* this flag is set by optimize.  Allow inlining across\n+\t\t  optimize boundary.  */\n+\t       && (!opt_for_fn (caller->decl, optimize)\n+\t\t   == !opt_for_fn (callee->decl, optimize) || !always_inline))\n+\t      || check_match (flag_wrapv)\n+\t      || check_match (flag_trapv)\n+\t      /* Strictly speaking only when the callee uses FP math.  */\n+\t      || check_maybe_up (flag_rounding_math)\n+\t      || check_maybe_up (flag_trapping_math)\n+\t      || check_maybe_down (flag_unsafe_math_optimizations)\n+\t      || check_maybe_down (flag_finite_math_only)\n+\t      || check_maybe_up (flag_signaling_nans)\n+\t      || check_maybe_down (flag_cx_limited_range)\n+\t      || check_maybe_up (flag_signed_zeros)\n+\t      || check_maybe_down (flag_associative_math)\n+\t      || check_maybe_down (flag_reciprocal_math)\n+\t      /* We do not want to make code compiled with exceptions to be\n+\t\t brought into a non-EH function unless we know that the callee\n+\t\t does not throw.\n+\t\t This is tracked by DECL_FUNCTION_PERSONALITY.  */\n+\t      || (check_match (flag_non_call_exceptions)\n+\t\t  /* TODO: We also may allow bringing !flag_non_call_exceptions\n+\t\t     to flag_non_call_exceptions function, but that may need\n+\t\t     extra work in tree-inline to add the extra EH edges.  */\n+\t\t  && (!opt_for_fn (callee->decl, flag_non_call_exceptions)\n+\t\t      || DECL_FUNCTION_PERSONALITY (callee->decl)))\n+\t      || (check_maybe_up (flag_exceptions)\n+\t\t  && DECL_FUNCTION_PERSONALITY (callee->decl))\n+\t      /* Strictly speaking only when the callee contains function\n+\t\t calls that may end up setting errno.  */\n+\t      || check_maybe_up (flag_errno_math)\n+\t      /* When devirtualization is diabled for callee, it is not safe\n+\t\t to inline it as we possibly mangled the type info.\n+\t\t Allow early inlining of always inlines.  */\n+\t      || (!early && check_maybe_down (flag_devirtualize)))\n \t{\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n@@ -481,6 +490,17 @@ can_inline_edge_p (struct cgraph_edge *e, bool report,\n \t  e->inline_failed = CIF_OPTIMIZATION_MISMATCH;\n \t  inlinable = false;\n \t}\n+      /* If explicit optimize attribute are not used, the mismatch is caused\n+\t by different command line options used to build different units.\n+\t Do not care about COMDAT functions - those are intended to be\n+         optimized with the optimization flags of module they are used in.\n+\t Also do not care about mixing up size/speed optimization when\n+\t DECL_DISREGARD_INLINE_LIMITS is set.  */\n+      else if ((callee->merged\n+\t        && !lookup_attribute (\"optimize\",\n+\t\t\t\t      DECL_ATTRIBUTES (caller->decl)))\n+\t       || DECL_DISREGARD_INLINE_LIMITS (callee->decl))\n+\t;\n       /* If mismatch is caused by merging two LTO units with different\n \t optimizationflags we want to be bit nicer.  However never inline\n \t if one of functions is not optimized at all.  */"}]}