{"sha": "3b3b1e3202eb1c375c842a8cb629668047882fb8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6M2IzYjFlMzIwMmViMWMzNzVjODQyYThjYjYyOTY2ODA0Nzg4MmZiOA==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-01-06T07:38:28Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-01-06T07:38:28Z"}, "message": "cfgcleanup.c (try_forward_edges): Detect infinite loops while jump threading.\n\n        * cfgcleanup.c (try_forward_edges): Detect infinite loops while\n        jump threading.\n\nFrom-SVN: r48574", "tree": {"sha": "cce7d23e8bc39afc78ec3d86b5852080fa7113bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cce7d23e8bc39afc78ec3d86b5852080fa7113bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3b3b1e3202eb1c375c842a8cb629668047882fb8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3b1e3202eb1c375c842a8cb629668047882fb8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3b3b1e3202eb1c375c842a8cb629668047882fb8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3b3b1e3202eb1c375c842a8cb629668047882fb8/comments", "author": null, "committer": null, "parents": [{"sha": "98e40e83636aaed6b6b66ad680e6419461d48dc0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98e40e83636aaed6b6b66ad680e6419461d48dc0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98e40e83636aaed6b6b66ad680e6419461d48dc0"}], "stats": {"total": 35, "additions": 32, "deletions": 3}, "files": [{"sha": "292a19533c18d4d6184fb16a280c1317d1c5148c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3b1e3202eb1c375c842a8cb629668047882fb8/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3b1e3202eb1c375c842a8cb629668047882fb8/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=3b3b1e3202eb1c375c842a8cb629668047882fb8", "patch": "@@ -1,3 +1,8 @@\n+2002-01-05  Richard Henderson  <rth@redhat.com>\n+\n+\t* cfgcleanup.c (try_forward_edges): Detect infinite loops while\n+\tjump threading.\n+\n 2002-01-05  Richard Henderson  <rth@redhat.com>\n \n \t* c-decl.c (c_expand_body): Don't call outlining_inline_function."}, {"sha": "69045a08f3babc6d5eb3f7c516ac05306ca12cec", "filename": "gcc/cfgcleanup.c", "status": "modified", "additions": 27, "deletions": 3, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3b3b1e3202eb1c375c842a8cb629668047882fb8/gcc%2Fcfgcleanup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3b3b1e3202eb1c375c842a8cb629668047882fb8/gcc%2Fcfgcleanup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgcleanup.c?ref=3b3b1e3202eb1c375c842a8cb629668047882fb8", "patch": "@@ -412,12 +412,32 @@ try_forward_edges (mode, b)\n \t      edge t = thread_jump (mode, e, target);\n \t      if (t)\n \t\t{\n-\t\t  new_target = t->dest;\n-\t\t  new_target_threaded = true;\n \t\t  if (!nthreaded_edges)\n \t\t    threaded_edges = xmalloc (sizeof (*threaded_edges)\n \t\t\t\t\t      * n_basic_blocks);\n+\t\t  else\n+\t\t    {\n+\t\t      int i;\n+\n+\t\t      /* Detect an infinite loop across blocks not\n+\t\t\t including the start block.  */\n+\t\t      for (i = 0; i < nthreaded_edges; ++i)\n+\t\t\tif (threaded_edges[i] == t)\n+\t\t\t  break;\n+\t\t      if (i < nthreaded_edges)\n+\t\t\tbreak;\n+\t\t    }\n+\n+\t\t  /* Detect an infinite loop across the start block.  */\n+\t\t  if (t->dest == b)\n+\t\t    break;\n+\n+\t\t  if (nthreaded_edges >= n_basic_blocks)\n+\t\t    abort ();\n \t\t  threaded_edges[nthreaded_edges++] = t;\n+\n+\t\t  new_target = t->dest;\n+\t\t  new_target_threaded = true;\n \t\t}\n \t    }\n \n@@ -504,7 +524,11 @@ try_forward_edges (mode, b)\n \t      first->succ->count -= edge_count;\n \t      first->frequency -= edge_frequency;\n \t      if (first->succ->succ_next)\n-\t\tt = threaded_edges [n++];\n+\t\t{\n+\t\t  if (n >= nthreaded_edges)\n+\t\t    abort ();\n+\t\t  t = threaded_edges [n++];\n+\t\t}\n \t      else\n \t\tt = first->succ;\n "}]}