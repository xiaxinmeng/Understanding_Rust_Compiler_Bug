{"sha": "1de6a873129a16012941fb75d8c2a1bbde736690", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRlNmE4NzMxMjlhMTYwMTI5NDFmYjc1ZDhjMmExYmJkZTczNjY5MA==", "commit": {"author": {"name": "Ira Rosen", "email": "irar@il.ibm.com", "date": "2004-12-29T13:16:07Z"}, "committer": {"name": "Dorit Nuzman", "email": "dorit@gcc.gnu.org", "date": "2004-12-29T13:16:07Z"}, "message": "re PR tree-optimization/18179 (vectorizer: wrong alignment/step/initial-address computed for struct accesses)\n\n2004-12-29  Ira Rosen  <irar@il.ibm.com>\n\n        PR tree-optimization/18179\n        * tree-vectorizer.h (struct _stmt_vec_info): Add new fields:\n        initial_offset, step, misalignment and base_aligned_p and macros\n        to access them.\n        * tree-vectorizer.c (vect_analyze_offset_expr): New function.\n        (new_stmt_vec_info): Initialize the new fields of stmt_vec_info.\n\n        (vect_create_data_ref_ptr): Fix printings.\n\nFrom-SVN: r92701", "tree": {"sha": "cf9d1470da9d3ec01f212318944d0be7811a10b6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cf9d1470da9d3ec01f212318944d0be7811a10b6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1de6a873129a16012941fb75d8c2a1bbde736690", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de6a873129a16012941fb75d8c2a1bbde736690", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1de6a873129a16012941fb75d8c2a1bbde736690", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1de6a873129a16012941fb75d8c2a1bbde736690/comments", "author": {"login": "irar2", "id": 16818592, "node_id": "MDQ6VXNlcjE2ODE4NTky", "avatar_url": "https://avatars.githubusercontent.com/u/16818592?v=4", "gravatar_id": "", "url": "https://api.github.com/users/irar2", "html_url": "https://github.com/irar2", "followers_url": "https://api.github.com/users/irar2/followers", "following_url": "https://api.github.com/users/irar2/following{/other_user}", "gists_url": "https://api.github.com/users/irar2/gists{/gist_id}", "starred_url": "https://api.github.com/users/irar2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/irar2/subscriptions", "organizations_url": "https://api.github.com/users/irar2/orgs", "repos_url": "https://api.github.com/users/irar2/repos", "events_url": "https://api.github.com/users/irar2/events{/privacy}", "received_events_url": "https://api.github.com/users/irar2/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e611d9276d1c7d278be5a47c09d3cab6b34fbf8"}], "stats": {"total": 264, "additions": 242, "deletions": 22}, "files": [{"sha": "df492c52e5444e11d6c39af67963317315ee2795", "filename": "gcc/ChangeLog", "status": "modified", "additions": 12, "deletions": 1, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1de6a873129a16012941fb75d8c2a1bbde736690", "patch": "@@ -1,6 +1,17 @@\n 2004-12-29  Ira Rosen  <irar@il.ibm.com>\n \n-        PR tree-optimization/18179\n+\tPR tree-optimization/18179\n+\t* tree-vectorizer.h (struct _stmt_vec_info): Add new fields:\n+\tinitial_offset, step, misalignment and base_aligned_p and macros\n+\tto access them.\n+\t* tree-vectorizer.c (vect_analyze_offset_expr): New function.\n+\t(new_stmt_vec_info): Initialize the new fields of stmt_vec_info.\n+\n+\t(vect_create_data_ref_ptr): Fix printings.\n+\n+2004-12-29  Ira Rosen  <irar@il.ibm.com>\n+\n+\tPR tree-optimization/18179\n \t* tree-vectorizer.c (vect_get_symbl_and_dr): Reorganize. Add memtag \n \tretrieval.\n \t(vect_analyze_data_refs): Remove memtag retrieval."}, {"sha": "70af3e48fba535ad5d5629196115bec6d9afc4aa", "filename": "gcc/tree-vectorizer.c", "status": "modified", "additions": 193, "deletions": 4, "changes": 197, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2Ftree-vectorizer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2Ftree-vectorizer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.c?ref=1de6a873129a16012941fb75d8c2a1bbde736690", "patch": "@@ -232,6 +232,8 @@ static tree vect_compute_array_ref_alignment\n static tree vect_get_ptr_offset (tree, tree, tree *);\n static tree vect_get_symbl_and_dr\n   (tree, tree, bool, loop_vec_info, struct data_reference **);\n+static bool vect_analyze_offset_expr (tree, struct loop *, tree, tree *, \n+\t\t\t\t      tree *, tree *);\n \n /* Utility functions for the code transformation.  */\n static tree vect_create_destination_var (tree, tree);\n@@ -1139,6 +1141,10 @@ new_stmt_vec_info (tree stmt, struct loop *loop)\n   STMT_VINFO_DATA_REF (res) = NULL;\n   STMT_VINFO_MEMTAG (res) = NULL;\n   STMT_VINFO_VECT_DR_BASE (res) = NULL;\n+  STMT_VINFO_VECT_INIT_OFFSET (res) = NULL_TREE;\n+  STMT_VINFO_VECT_STEP (res) = NULL_TREE;\n+  STMT_VINFO_VECT_BASE_ALIGNED_P (res) = false;\n+  STMT_VINFO_VECT_MISALIGNMENT (res) = NULL_TREE;\n \n   return res;\n }\n@@ -1338,6 +1344,189 @@ vect_get_ptr_offset (tree ref ATTRIBUTE_UNUSED,\n }\n \n \n+/* Function vect_analyze_offset_expr\n+\n+   Given an offset expression EXPR received from get_inner_reference, analyze\n+   it and create an expression for INITIAL_OFFSET by substituting the variables \n+   of EXPR with initial_condition of the corresponding access_fn in the loop. \n+   E.g., \n+      for i\n+         for (j = 3; j < N; j++)\n+            a[j].b[i][j] = 0;\n+\t \n+   For a[j].b[i][j], EXPR will be 'i * C_i + j * C_j + C'. 'i' cannot be \n+   subsituted, since its access_fn in the inner loop is i. 'j' will be \n+   substituted with 3. An INITIAL_OFFSET will be 'i * C_i + C`', where\n+   C` =  3 * C_j + C.\n+\n+   Compute MISALIGN (the misalignment of the data reference initial access from\n+   its base) if possible. Misalignment can be calculated only if all the\n+   variables can be substitued with constants, or if a variable is multiplied\n+   by a multiple of VECTYPE_ALIGNMENT. In the above example, since 'i' cannot\n+   be substituted, MISALIGN will be NULL_TREE in case that C_i is not a multiple\n+   of VECTYPE_ALIGNMENT, and C` otherwise. (We perform MISALIGN modulo \n+   VECTYPE_ALIGNMENT computation in the caller of this function).\n+\n+   STEP is an evolution of the data reference in this loop in bytes.\n+   In the above example, STEP is C_j.\n+\n+   Return FALSE, if the analysis fails, e.g., there is no access_fn for a \n+   variable. In this case, all the outputs (INITIAL_OFFSET, MISALIGN and STEP) \n+   are NULL_TREEs. Otherwise, return TRUE.\n+\n+*/\n+\n+static bool\n+vect_analyze_offset_expr (tree expr, \n+\t\t\t  struct loop *loop, \n+\t\t\t  tree vectype_alignment,\n+\t\t\t  tree *initial_offset,\n+\t\t\t  tree *misalign,\n+\t\t\t  tree *step)\n+{\n+  tree oprnd0;\n+  tree oprnd1;\n+  tree left_offset = size_zero_node;\n+  tree right_offset = size_zero_node;\n+  tree left_misalign = size_zero_node;\n+  tree right_misalign = size_zero_node;\n+  tree left_step = size_zero_node;\n+  tree right_step = size_zero_node;\n+  enum tree_code code;\n+  tree init, evolution, def_stmt;\n+\n+  STRIP_NOPS (expr);\n+  \n+  *step = NULL_TREE;\n+  *misalign = NULL_TREE;\n+  *initial_offset = NULL_TREE;\n+\n+  /* Stop conditions:\n+     1. Constant.  */\n+  if (TREE_CONSTANT (expr))\n+    {\n+      *initial_offset = fold_convert (sizetype, expr);\n+      *misalign = fold_convert (sizetype, expr);      \n+      *step = size_zero_node;\n+      return true;\n+    }\n+\n+  /* 2. Variable. Try to substitute with initial_condition of the corresponding\n+     access_fn in the current loop.  */\n+  if (SSA_VAR_P (expr))\n+    {\n+      tree access_fn = analyze_scalar_evolution (loop, expr);\n+\n+      if (access_fn == chrec_dont_know)\n+\t/* No access_fn.  */\n+\treturn false;\n+\n+      init = initial_condition_in_loop_num (access_fn, loop->num);\n+      if (init == expr)\n+\t{\n+\t  def_stmt = SSA_NAME_DEF_STMT (init);\n+\t  if (def_stmt \n+\t      && !IS_EMPTY_STMT (def_stmt)\n+\t      && flow_bb_inside_loop_p (loop, bb_for_stmt (def_stmt)))\n+\t    /* Not enough information: may be not loop invariant.  \n+\t       E.g., for a[b[i]], we get a[D], where D=b[i]. EXPR is D, its \n+\t       initial_condition is D, but it depends on i - loop's induction\n+\t       variable.  */\t  \n+\t    return false;\n+\t}\n+\n+      evolution = evolution_part_in_loop_num (access_fn, loop->num);\n+      if (evolution && TREE_CODE (evolution) != INTEGER_CST)\n+\t/* Evolution is not constant.  */\n+\treturn false;\n+\n+      if (TREE_CONSTANT (init))\n+\t*misalign = fold_convert (sizetype, init);\n+      else\n+\t/* Not constant, misalignment cannot be calculated.  */\n+\t*misalign = NULL_TREE;\n+\n+      *initial_offset = fold_convert (sizetype, init); \n+\n+      *step = evolution ? fold_convert (sizetype, evolution) : size_zero_node;\n+      return true;      \n+    }\n+\n+  /* Recursive computation.  */\n+  oprnd0 = TREE_OPERAND (expr, 0);\n+  oprnd1 = TREE_OPERAND (expr, 1);\n+\n+  if (!vect_analyze_offset_expr (oprnd0, loop, vectype_alignment, &left_offset, \n+\t\t\t\t&left_misalign, &left_step)\n+      || !vect_analyze_offset_expr (oprnd1, loop, vectype_alignment, \n+\t\t\t\t    &right_offset, &right_misalign, &right_step))\n+      return false;\n+\n+  /* The type of the operation: plus, minus or mult.  */\n+  code = TREE_CODE (expr);\n+  switch (code)\n+    {\n+    case MULT_EXPR:\n+      if (!TREE_CONSTANT (right_offset))\n+\t/* RIGHT_OFFSET can be not constant. For example, for arrays of variable \n+\t   sized types. \n+\t   FORNOW: We don't support such cases.  */\n+\treturn false;\n+\n+      /* Misalignment computation.  */\n+      if (SSA_VAR_P (left_offset))\n+\t{\n+\t  /* If the left side contains variable that cannot be substituted with \n+\t     constant, we check if the right side is a multiple of ALIGNMENT.  */\n+\t  if (integer_zerop (size_binop (TRUNC_MOD_EXPR, right_offset, \n+\t\t\t\t\t vectype_alignment)))\n+\t    *misalign = size_zero_node;\n+\t  else\n+\t    /* If the remainder is not zero or the right side isn't constant, we \n+\t       can't compute  misalignment.  */\n+\t    *misalign = NULL_TREE;\n+\t}\n+      else \n+\t{\n+\t  /* The left operand was successfully substituted with constant.  */\t  \n+\t  if (left_misalign)\n+\t    /* In case of EXPR '(i * C1 + j) * C2', LEFT_MISALIGN is \n+\t       NULL_TREE.  */\n+\t    *misalign  = size_binop (code, left_misalign, right_misalign);\n+\t  else\n+\t    *misalign = NULL_TREE; \n+\t}\n+\n+      /* Step calculation.  */\n+      /* Multiply the step by the right operand.  */\n+      *step  = size_binop (MULT_EXPR, left_step, right_offset);\n+      break;\n+   \n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+      /* Combine the recursive calculations for step and misalignment.  */\n+      *step = size_binop (code, left_step, right_step);\n+   \n+      if (left_misalign && right_misalign)\n+\t*misalign  = size_binop (code, left_misalign, right_misalign);\n+      else\n+\t*misalign = NULL_TREE;\n+    \n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+\n+  /* Compute offset.  */\n+  *initial_offset = fold_convert (sizetype, \n+\t\t\t\t  fold (build2 (code, TREE_TYPE (left_offset), \n+\t\t\t\t\t\tleft_offset, \n+\t\t\t\t\t\tright_offset)));\n+  return true;\n+}\n+\n+\n /* Function vect_get_base_and_bit_offset\n \n    Return the BASE of the data reference EXPR.\n@@ -1885,13 +2074,13 @@ vect_create_data_ref_ptr (tree stmt, block_stmt_iterator *bsi, tree offset,\n       fprintf (dump_file, \"create array_ref of type: \");\n       print_generic_expr (dump_file, vectype, TDF_SLIM);\n       if (TREE_CODE (data_ref_base) == VAR_DECL)\n-        fprintf (dump_file, \"vectorizing a one dimensional array ref: \");\n+        fprintf (dump_file, \"\\nvectorizing a one dimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == ARRAY_REF)\n-        fprintf (dump_file, \"vectorizing a multidimensional array ref: \");\n+        fprintf (dump_file, \"\\nvectorizing a multidimensional array ref: \");\n       else if (TREE_CODE (data_ref_base) == COMPONENT_REF)\n-        fprintf (dump_file, \"vectorizing a record based array ref: \");\n+        fprintf (dump_file, \"\\nvectorizing a record based array ref: \");\n       else if (TREE_CODE (data_ref_base) == SSA_NAME)\n-        fprintf (dump_file, \"vectorizing a pointer ref: \");\n+        fprintf (dump_file, \"\\nvectorizing a pointer ref: \");\n       print_generic_expr (dump_file, base_name, TDF_SLIM);\n     }\n "}, {"sha": "642e3848fa9ecc0b93041859e723ad0c2f934a86", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 37, "deletions": 17, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1de6a873129a16012941fb75d8c2a1bbde736690/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=1de6a873129a16012941fb75d8c2a1bbde736690", "patch": "@@ -85,26 +85,46 @@ typedef struct _stmt_vec_info {\n   /* Aliasing information.  */\n   tree memtag;\n \n-  /* Data reference base. This field holds the entire invariant part of the \n-     data-reference (with respect to the relevant loop), as opposed to the \n-     field DR_BASE of the STMT_VINFO_DATA_REF struct, which holds only the \n-     initial base; e.g:\n-     REF\tBR_BASE\t    VECT_DR_BASE\n-     a[i]\ta\t\ta\n-     a[i][j]\ta\t\ta[i]  */\n-  tree vect_dr_base;\n+  /** The following fields are used to store the information about \n+      data-reference. {base + initial_offset} is the first location accessed by\n+      data-ref in the loop, and step is the stride of data-ref in the loop;\n+      e.g.:\n+    \n+                       Example 1                      Example 2\n+      data-ref         a[j].b[i][j]                   a + 4B (a is int*)\n+\n+      base             a                              a\n+      initial_offset   j_0*D_j + i_0*D_i + C          4\n+      step             D_j                            4\n+\n+  **/\n+  /* The above base, offset and step.  */\n+  tree base;\n+  tree initial_offset;\n+  tree step;\n+\n+  /* Alignment information. Whether the base of the data-reference is aligned \n+     to vectype.  */\n+  bool base_aligned_p;\n+  /* Alignment information. The offset of the data-reference from its base \n+     in bytes.  */\n+  tree misalignment;\n } *stmt_vec_info;\n \n /* Access Functions.  */\n-#define STMT_VINFO_TYPE(S)          (S)->type\n-#define STMT_VINFO_STMT(S)          (S)->stmt\n-#define STMT_VINFO_LOOP(S)          (S)->loop\n-#define STMT_VINFO_RELEVANT_P(S)    (S)->relevant\n-#define STMT_VINFO_VECTYPE(S)       (S)->vectype\n-#define STMT_VINFO_VEC_STMT(S)      (S)->vectorized_stmt\n-#define STMT_VINFO_DATA_REF(S)      (S)->data_ref_info\n-#define STMT_VINFO_MEMTAG(S)        (S)->memtag\n-#define STMT_VINFO_VECT_DR_BASE(S)  (S)->vect_dr_base\n+#define STMT_VINFO_TYPE(S)                (S)->type\n+#define STMT_VINFO_STMT(S)                (S)->stmt\n+#define STMT_VINFO_LOOP(S)                (S)->loop\n+#define STMT_VINFO_RELEVANT_P(S)          (S)->relevant\n+#define STMT_VINFO_VECTYPE(S)             (S)->vectype\n+#define STMT_VINFO_VEC_STMT(S)            (S)->vectorized_stmt\n+#define STMT_VINFO_DATA_REF(S)            (S)->data_ref_info\n+#define STMT_VINFO_MEMTAG(S)              (S)->memtag\n+#define STMT_VINFO_VECT_DR_BASE(S)        (S)->base\n+#define STMT_VINFO_VECT_INIT_OFFSET(S)    (S)->initial_offset\n+#define STMT_VINFO_VECT_STEP(S)           (S)->step\n+#define STMT_VINFO_VECT_BASE_ALIGNED_P(S) (S)->base_aligned_p\n+#define STMT_VINFO_VECT_MISALIGNMENT(S)   (S)->misalignment\n \n static inline void set_stmt_info (stmt_ann_t ann, stmt_vec_info stmt_info);\n static inline stmt_vec_info vinfo_for_stmt (tree stmt);"}]}