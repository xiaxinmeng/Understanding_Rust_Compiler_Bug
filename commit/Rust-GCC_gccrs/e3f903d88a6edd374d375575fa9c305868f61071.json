{"sha": "e3f903d88a6edd374d375575fa9c305868f61071", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTNmOTAzZDg4YTZlZGQzNzRkMzc1NTc1ZmE5YzMwNTg2OGY2MTA3MQ==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2011-06-30T20:59:41Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2011-06-30T20:59:41Z"}, "message": "dwarf2out: Convert regs_saved_in_regs to VEC.\n\n        * dwarf2out.c (struct reg_saved_in_data): Provide a typedef.\n        Define a vector of this type.\n        (regs_saved_in_regs): Use a VEC.\n        (num_regs_saved_in_regs): Remove.\n        (compare_reg_or_pc): New.\n        (record_reg_saved_in_reg): Split out from...\n        (dwarf2out_flush_queued_reg_saves): ... here.\n        (clobbers_queued_reg_save): Update for VEC.\n        (reg_saved_in): Likewise.\n        (dwarf2out_frame_debug_init): Likewise.\n        (dwarf2out_reg_save_reg): Use record_reg_saved_in_reg.\n        (dwarf2out_frame_debug_cfa_register): Likewise.\n\nFrom-SVN: r175727", "tree": {"sha": "3cc12b7bded8b4a0cd53ce0068a1eb0c9ef0485f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cc12b7bded8b4a0cd53ce0068a1eb0c9ef0485f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3f903d88a6edd374d375575fa9c305868f61071", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f903d88a6edd374d375575fa9c305868f61071", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3f903d88a6edd374d375575fa9c305868f61071", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3f903d88a6edd374d375575fa9c305868f61071/comments", "author": null, "committer": null, "parents": [{"sha": "e2c9010ae86229c17b29cfdb83a5ac9d6c0299ba", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e2c9010ae86229c17b29cfdb83a5ac9d6c0299ba", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e2c9010ae86229c17b29cfdb83a5ac9d6c0299ba"}], "stats": {"total": 130, "additions": 80, "deletions": 50}, "files": [{"sha": "277fc9eb2760d0bc8445974b284a3532b6cf2b60", "filename": "gcc/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f903d88a6edd374d375575fa9c305868f61071/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f903d88a6edd374d375575fa9c305868f61071/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e3f903d88a6edd374d375575fa9c305868f61071", "patch": "@@ -1,3 +1,18 @@\n+2011-06-30  Richard Henderson  <rth@redhat.com>\n+\n+\t* dwarf2out.c (struct reg_saved_in_data): Provide a typedef.\n+\tDefine a vector of this type.\n+\t(regs_saved_in_regs): Use a VEC.\n+\t(num_regs_saved_in_regs): Remove.\n+\t(compare_reg_or_pc): New.\n+\t(record_reg_saved_in_reg): Split out from...\n+\t(dwarf2out_flush_queued_reg_saves): ... here.\n+\t(clobbers_queued_reg_save): Update for VEC.\n+\t(reg_saved_in): Likewise.\n+\t(dwarf2out_frame_debug_init): Likewise.\n+\t(dwarf2out_reg_save_reg): Use record_reg_saved_in_reg.\n+\t(dwarf2out_frame_debug_cfa_register): Likewise.\n+\n 2011-06-30  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR tree-optimization/49572"}, {"sha": "8aa2eb2d4d17e8b83c4304a9a189ccdc09e5f742", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 65, "deletions": 50, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3f903d88a6edd374d375575fa9c305868f61071/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3f903d88a6edd374d375575fa9c305868f61071/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e3f903d88a6edd374d375575fa9c305868f61071", "patch": "@@ -1732,17 +1732,56 @@ struct GTY(()) queued_reg_save {\n static GTY(()) struct queued_reg_save *queued_reg_saves;\n \n /* The caller's ORIG_REG is saved in SAVED_IN_REG.  */\n-struct GTY(()) reg_saved_in_data {\n+typedef struct GTY(()) reg_saved_in_data {\n   rtx orig_reg;\n   rtx saved_in_reg;\n-};\n+} reg_saved_in_data;\n+\n+DEF_VEC_O (reg_saved_in_data);\n+DEF_VEC_ALLOC_O (reg_saved_in_data, gc);\n+\n+/* A set of registers saved in other registers.  This is implemented as\n+   a flat array because it normally contains zero or 1 entry, depending\n+   on the target.  IA-64 is the big spender here, using a maximum of\n+   5 entries.  */\n+static GTY(()) VEC(reg_saved_in_data, gc) *regs_saved_in_regs;\n \n-/* A list of registers saved in other registers.\n-   The list intentionally has a small maximum capacity of 4; if your\n-   port needs more than that, you might consider implementing a\n-   more efficient data structure.  */\n-static GTY(()) struct reg_saved_in_data regs_saved_in_regs[4];\n-static GTY(()) size_t num_regs_saved_in_regs;\n+/* Compare X and Y for equivalence.  The inputs may be REGs or PC_RTX.  */\n+\n+static bool\n+compare_reg_or_pc (rtx x, rtx y)\n+{\n+  if (REG_P (x) && REG_P (y))\n+    return REGNO (x) == REGNO (y);\n+  return x == y;\n+}\n+\n+/* Record SRC as being saved in DEST.  DEST may be null to delete an\n+   existing entry.  SRC may be a register or PC_RTX.  */\n+\n+static void\n+record_reg_saved_in_reg (rtx dest, rtx src)\n+{\n+  reg_saved_in_data *elt;\n+  size_t i;\n+\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, elt)\n+    if (compare_reg_or_pc (elt->orig_reg, src))\n+      {\n+\tif (dest == NULL)\n+\t  VEC_unordered_remove(reg_saved_in_data, regs_saved_in_regs, i);\n+\telse\n+\t  elt->saved_in_reg = dest;\n+\treturn;\n+      }\n+\n+  if (dest == NULL)\n+    return;\n+\n+  elt = VEC_safe_push(reg_saved_in_data, gc, regs_saved_in_regs, NULL);\n+  elt->orig_reg = src;\n+  elt->saved_in_reg = dest;\n+}\n \n static const char *last_reg_save_label;\n \n@@ -1784,22 +1823,9 @@ dwarf2out_flush_queued_reg_saves (void)\n \n   for (q = queued_reg_saves; q; q = q->next)\n     {\n-      size_t i;\n       unsigned int reg, sreg;\n \n-      for (i = 0; i < num_regs_saved_in_regs; i++)\n-\tif (REGNO (regs_saved_in_regs[i].orig_reg) == REGNO (q->reg))\n-\t  break;\n-      if (q->saved_reg && i == num_regs_saved_in_regs)\n-\t{\n-\t  gcc_assert (i != ARRAY_SIZE (regs_saved_in_regs));\n-\t  num_regs_saved_in_regs++;\n-\t}\n-      if (i != num_regs_saved_in_regs)\n-\t{\n-\t  regs_saved_in_regs[i].orig_reg = q->reg;\n-\t  regs_saved_in_regs[i].saved_in_reg = q->saved_reg;\n-\t}\n+      record_reg_saved_in_reg (q->saved_reg, q->reg);\n \n       reg = DWARF_FRAME_REGNUM (REGNO (q->reg));\n       if (q->saved_reg)\n@@ -1826,11 +1852,14 @@ clobbers_queued_reg_save (const_rtx insn)\n   for (q = queued_reg_saves; q; q = q->next)\n     {\n       size_t i;\n+      reg_saved_in_data *rir;\n+\n       if (modified_in_p (q->reg, insn))\n \treturn true;\n-      for (i = 0; i < num_regs_saved_in_regs; i++)\n-\tif (REGNO (q->reg) == REGNO (regs_saved_in_regs[i].orig_reg)\n-\t    && modified_in_p (regs_saved_in_regs[i].saved_in_reg, insn))\n+\n+      FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+\tif (compare_reg_or_pc (q->reg, rir->orig_reg)\n+\t    && modified_in_p (rir->saved_in_reg, insn))\n \t  return true;\n     }\n \n@@ -1842,19 +1871,9 @@ clobbers_queued_reg_save (const_rtx insn)\n void\n dwarf2out_reg_save_reg (const char *label, rtx reg, rtx sreg)\n {\n-  size_t i;\n   unsigned int regno, sregno;\n \n-  for (i = 0; i < num_regs_saved_in_regs; i++)\n-    if (REGNO (regs_saved_in_regs[i].orig_reg) == REGNO (reg))\n-      break;\n-  if (i == num_regs_saved_in_regs)\n-    {\n-      gcc_assert (i != ARRAY_SIZE (regs_saved_in_regs));\n-      num_regs_saved_in_regs++;\n-    }\n-  regs_saved_in_regs[i].orig_reg = reg;\n-  regs_saved_in_regs[i].saved_in_reg = sreg;\n+  record_reg_saved_in_reg (sreg, reg);\n \n   regno = DWARF_FRAME_REGNUM (REGNO (reg));\n   sregno = DWARF_FRAME_REGNUM (REGNO (sreg));\n@@ -1867,17 +1886,17 @@ static rtx\n reg_saved_in (rtx reg)\n {\n   unsigned int regn = REGNO (reg);\n-  size_t i;\n   struct queued_reg_save *q;\n+  reg_saved_in_data *rir;\n+  size_t i;\n \n   for (q = queued_reg_saves; q; q = q->next)\n     if (q->saved_reg && regn == REGNO (q->saved_reg))\n       return q->reg;\n \n-  for (i = 0; i < num_regs_saved_in_regs; i++)\n-    if (regs_saved_in_regs[i].saved_in_reg\n-\t&& regn == REGNO (regs_saved_in_regs[i].saved_in_reg))\n-      return regs_saved_in_regs[i].orig_reg;\n+  FOR_EACH_VEC_ELT (reg_saved_in_data, regs_saved_in_regs, i, rir)\n+    if (regn == REGNO (rir->saved_in_reg))\n+      return rir->orig_reg;\n \n   return NULL_RTX;\n }\n@@ -2026,7 +2045,10 @@ dwarf2out_frame_debug_cfa_register (rtx set, const char *label)\n   if (src == pc_rtx)\n     sregno = DWARF_FRAME_RETURN_COLUMN;\n   else\n-    sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+    {\n+      record_reg_saved_in_reg (dest, src);\n+      sregno = DWARF_FRAME_REGNUM (REGNO (src));\n+    }\n \n   dregno = DWARF_FRAME_REGNUM (REGNO (dest));\n \n@@ -2928,8 +2950,6 @@ dwarf2out_frame_debug (rtx insn, bool after_p)\n void\n dwarf2out_frame_debug_init (void)\n {\n-  size_t i;\n-\n   /* Flush any queued register saves.  */\n   dwarf2out_flush_queued_reg_saves ();\n \n@@ -2943,12 +2963,7 @@ dwarf2out_frame_debug_init (void)\n   cfa_temp.reg = -1;\n   cfa_temp.offset = 0;\n \n-  for (i = 0; i < num_regs_saved_in_regs; i++)\n-    {\n-      regs_saved_in_regs[i].orig_reg = NULL_RTX;\n-      regs_saved_in_regs[i].saved_in_reg = NULL_RTX;\n-    }\n-  num_regs_saved_in_regs = 0;\n+  regs_saved_in_regs = NULL;\n \n   if (barrier_args_size)\n     {"}]}