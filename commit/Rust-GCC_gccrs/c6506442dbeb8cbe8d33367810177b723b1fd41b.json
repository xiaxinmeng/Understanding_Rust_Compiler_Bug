{"sha": "c6506442dbeb8cbe8d33367810177b723b1fd41b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzY1MDY0NDJkYmViOGNiZThkMzMzNjc4MTAxNzdiNzIzYjFmZDQxYg==", "commit": {"author": {"name": "David Edelsohn", "email": "edelsohn@gnu.org", "date": "2005-03-11T22:58:49Z"}, "committer": {"name": "David Edelsohn", "email": "dje@gcc.gnu.org", "date": "2005-03-11T22:58:49Z"}, "message": "re PR rtl-optimization/20306 (FP complex modes moved via GPRs)\n\n        PR rtl-optimization/20306\n        * expr.c (emit_move_complex): Set try_int false if mode is\n        MODE_COMPLEX_FLOAT and mov_optab exists for inner mode.  Only try\n        emit_block_move if try_int is true.\n\nFrom-SVN: r96312", "tree": {"sha": "675b3a954c1c9d341f4acdf5508ad1ae49e1add0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/675b3a954c1c9d341f4acdf5508ad1ae49e1add0"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c6506442dbeb8cbe8d33367810177b723b1fd41b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6506442dbeb8cbe8d33367810177b723b1fd41b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6506442dbeb8cbe8d33367810177b723b1fd41b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6506442dbeb8cbe8d33367810177b723b1fd41b/comments", "author": null, "committer": null, "parents": [{"sha": "a96cf7633a4094a9fab58127913f66f53fc7d08c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a96cf7633a4094a9fab58127913f66f53fc7d08c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a96cf7633a4094a9fab58127913f66f53fc7d08c"}], "stats": {"total": 35, "additions": 24, "deletions": 11}, "files": [{"sha": "51901ed86e901d84ccf965cf7b51b033efc5c9f3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6506442dbeb8cbe8d33367810177b723b1fd41b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6506442dbeb8cbe8d33367810177b723b1fd41b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c6506442dbeb8cbe8d33367810177b723b1fd41b", "patch": "@@ -1,3 +1,10 @@\n+2005-03-11  David Edelsohn  <edelsohn@gnu.org>\n+\n+\tPR rtl-optimization/20306\n+\t* expr.c (emit_move_complex): Set try_int false if mode is\n+\tMODE_COMPLEX_FLOAT and mov_optab exists for inner mode.  Only try\n+\temit_block_move if try_int is true.\n+\n 2005-03-11  Richard Henderson  <rth@redhat.com>\n \n \tPR target/20415"}, {"sha": "9e08315531f0fd17e25aeb26977a86bf2c6db656", "filename": "gcc/expr.c", "status": "modified", "additions": 17, "deletions": 11, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c6506442dbeb8cbe8d33367810177b723b1fd41b/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c6506442dbeb8cbe8d33367810177b723b1fd41b/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=c6506442dbeb8cbe8d33367810177b723b1fd41b", "patch": "@@ -2877,19 +2877,14 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n   if (push_operand (x, mode))\n     return emit_move_complex_push (mode, x, y);\n \n-  /* For memory to memory moves, optimal behavior can be had with the\n-     existing block move logic.  */\n-  if (MEM_P (x) && MEM_P (y))\n-    {\n-      emit_block_move (x, y, GEN_INT (GET_MODE_SIZE (mode)),\n-\t\t       BLOCK_OP_NO_LIBCALL);\n-      return get_last_insn ();\n-    }\n-\n   /* See if we can coerce the target into moving both values at once.  */\n \n+  /* Move floating point as parts.  */\n+  if (GET_MODE_CLASS (mode) == MODE_COMPLEX_FLOAT\n+      && mov_optab->handlers[GET_MODE_INNER (mode)].insn_code != CODE_FOR_nothing)\n+    try_int = false;\n   /* Not possible if the values are inherently not adjacent.  */\n-  if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n+  else if (GET_CODE (x) == CONCAT || GET_CODE (y) == CONCAT)\n     try_int = false;\n   /* Is possible if both are registers (or subregs of registers).  */\n   else if (register_operand (x, mode) && register_operand (y, mode))\n@@ -2907,7 +2902,18 @@ emit_move_complex (enum machine_mode mode, rtx x, rtx y)\n \n   if (try_int)\n     {\n-      rtx ret = emit_move_via_integer (mode, x, y);\n+      rtx ret;\n+\n+      /* For memory to memory moves, optimal behavior can be had with the\n+\t existing block move logic.  */\n+      if (MEM_P (x) && MEM_P (y))\n+\t{\n+\t  emit_block_move (x, y, GEN_INT (GET_MODE_SIZE (mode)),\n+\t\t\t   BLOCK_OP_NO_LIBCALL);\n+\t  return get_last_insn ();\n+\t}\n+\n+      ret = emit_move_via_integer (mode, x, y);\n       if (ret)\n \treturn ret;\n     }"}]}