{"sha": "f6ce35ac7cd0498638a00396ae4a47269def92ac", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjZjZTM1YWM3Y2QwNDk4NjM4YTAwMzk2YWU0YTQ3MjY5ZGVmOTJhYw==", "commit": {"author": {"name": "Vladimir Makarov", "email": "vmakarov@redhat.com", "date": "2013-04-24T15:45:42Z"}, "committer": {"name": "Vladimir Makarov", "email": "vmakarov@gcc.gnu.org", "date": "2013-04-24T15:45:42Z"}, "message": "rtl.h (struct rtx_def): Add comment for field jump.\n\n2013-04-24  Vladimir Makarov  <vmakarov@redhat.com>\n\n        * rtl.h (struct rtx_def): Add comment for field jump.\n\t(LRA_SUBREG_P): New macro.\n\t* recog.c (register_operand): Check LRA_SUBREG_P.\n\t* lra.c (lra): Add note at the end of RTL code. Align non-empty\n\tstack frame.\n\t* lra-spills.c (lra_spill): Align stack after spilling pseudos.\n\t(lra_final_code_change): Skip subreg change for operators.\n\t* lra-eliminations.c (eliminate_regs_in_insn): Make return earlier\n\tif there are no operand changes.\n\t* lra-constraints.c (curr_insn_set): New.\n\t(match_reload): Set LRA_SUBREG_P.\n\t(emit_spill_move): Ditto.\n\t(check_and_process_move): Use curr_insn_set. Process only single\n\tset insns.  Don't initialize sec_mem_p and change_p.\n\t(simplify_operand_subreg): Use LRA_SUBREG_P.\n\t(reg_in_class_p): New function.\n\t(process_alt_operands): Use it.  Use #if HAVE_ATTR_enabled instead\n\tof #ifdef.  Add code to remove cycling.\n\t(process_address): Check EXTRA_CONSTRAINT_STR. Process even if\n\tnon-null disp.  Reload inner instead of disp when base and index\n\tare null.  Try to put lo_sum into register.\n\t(EBB_PROBABILITY_CUTOFF): Redefine probability in percents.\n        (check_and_process_move): Move code for move cost check to\n\tsimple_move_p.  Remove equiv_substitution.\n        (simple_move_p): New function.\n\t(curr_insn_transform): Initialize sec_mem_p and change_p.  Set up\n\tcurr_insn_set.  Call check_and_process_move only for single set\n\tinsns.  Use the new function.  Move call of check_and_process_move\n\tafter operand equiv substitution and address process.\n\nFrom-SVN: r198252", "tree": {"sha": "5d62cbda55e99dcc3d68549c968022c1afd79065", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5d62cbda55e99dcc3d68549c968022c1afd79065"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f6ce35ac7cd0498638a00396ae4a47269def92ac", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ce35ac7cd0498638a00396ae4a47269def92ac", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6ce35ac7cd0498638a00396ae4a47269def92ac", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6ce35ac7cd0498638a00396ae4a47269def92ac/comments", "author": {"login": "vnmakarov", "id": 9855671, "node_id": "MDQ6VXNlcjk4NTU2NzE=", "avatar_url": "https://avatars.githubusercontent.com/u/9855671?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vnmakarov", "html_url": "https://github.com/vnmakarov", "followers_url": "https://api.github.com/users/vnmakarov/followers", "following_url": "https://api.github.com/users/vnmakarov/following{/other_user}", "gists_url": "https://api.github.com/users/vnmakarov/gists{/gist_id}", "starred_url": "https://api.github.com/users/vnmakarov/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vnmakarov/subscriptions", "organizations_url": "https://api.github.com/users/vnmakarov/orgs", "repos_url": "https://api.github.com/users/vnmakarov/repos", "events_url": "https://api.github.com/users/vnmakarov/events{/privacy}", "received_events_url": "https://api.github.com/users/vnmakarov/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "38047d904b3662577d9ac6b3527ef587deeaad2c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/38047d904b3662577d9ac6b3527ef587deeaad2c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/38047d904b3662577d9ac6b3527ef587deeaad2c"}], "stats": {"total": 265, "additions": 199, "deletions": 66}, "files": [{"sha": "45f918a08b6297f75c1841df42f2d402c7dbfb2f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -1,3 +1,35 @@\n+2013-04-24  Vladimir Makarov  <vmakarov@redhat.com>\n+\n+        * rtl.h (struct rtx_def): Add comment for field jump.\n+\t(LRA_SUBREG_P): New macro.\n+\t* recog.c (register_operand): Check LRA_SUBREG_P.\n+\t* lra.c (lra): Add note at the end of RTL code. Align non-empty\n+\tstack frame.\n+\t* lra-spills.c (lra_spill): Align stack after spilling pseudos.\n+\t(lra_final_code_change): Skip subreg change for operators.\n+\t* lra-eliminations.c (eliminate_regs_in_insn): Make return earlier\n+\tif there are no operand changes.\n+\t* lra-constraints.c (curr_insn_set): New.\n+\t(match_reload): Set LRA_SUBREG_P.\n+\t(emit_spill_move): Ditto.\n+\t(check_and_process_move): Use curr_insn_set. Process only single\n+\tset insns.  Don't initialize sec_mem_p and change_p.\n+\t(simplify_operand_subreg): Use LRA_SUBREG_P.\n+\t(reg_in_class_p): New function.\n+\t(process_alt_operands): Use it.  Use #if HAVE_ATTR_enabled instead\n+\tof #ifdef.  Add code to remove cycling.\n+\t(process_address): Check EXTRA_CONSTRAINT_STR. Process even if\n+\tnon-null disp.  Reload inner instead of disp when base and index\n+\tare null.  Try to put lo_sum into register.\n+\t(EBB_PROBABILITY_CUTOFF): Redefine probability in percents.\n+        (check_and_process_move): Move code for move cost check to\n+\tsimple_move_p.  Remove equiv_substitution.\n+        (simple_move_p): New function.\n+\t(curr_insn_transform): Initialize sec_mem_p and change_p.  Set up\n+\tcurr_insn_set.  Call check_and_process_move only for single set\n+\tinsns.  Use the new function.  Move call of check_and_process_move\n+\tafter operand equiv substitution and address process.\n+\n 2013-04-24  James Greenhalgh  <james.greenhalgh@arm.com>\n \n \t* config/aarch64/arm_neon.h (vld1<q>_lane*): Fix constraints."}, {"sha": "24782dcdec7a812e909ea4905f983f7f18d9e36e", "filename": "gcc/lra-constraints.c", "status": "modified", "additions": 128, "deletions": 53, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-constraints.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-constraints.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-constraints.c?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -135,10 +135,11 @@\n    reload insns.  */\n static int bb_reload_num;\n \n-/* The current insn being processed and corresponding its data (basic\n-   block, the insn data, the insn static data, and the mode of each\n-   operand).  */\n+/* The current insn being processed and corresponding its single set\n+   (NULL otherwise), its data (basic block, the insn data, the insn\n+   static data, and the mode of each operand).  */\n static rtx curr_insn;\n+static rtx curr_insn_set;\n static basic_block curr_bb;\n static lra_insn_recog_data_t curr_id;\n static struct lra_static_insn_data *curr_static_id;\n@@ -698,6 +699,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t    new_out_reg = gen_lowpart_SUBREG (outmode, reg);\n \t  else\n \t    new_out_reg = gen_rtx_SUBREG (outmode, reg, 0);\n+\t  LRA_SUBREG_P (new_out_reg) = 1;\n \t  /* If the input reg is dying here, we can use the same hard\n \t     register for REG and IN_RTX.  We do it only for original\n \t     pseudos as reload pseudos can die although original\n@@ -721,6 +723,7 @@ match_reload (signed char out, signed char *ins, enum reg_class goal_class,\n \t     it at the end of LRA work.  */\n \t  clobber = emit_clobber (new_out_reg);\n \t  LRA_TEMP_CLOBBER_P (PATTERN (clobber)) = 1;\n+\t  LRA_SUBREG_P (new_in_reg) = 1;\n \t  if (GET_CODE (in_rtx) == SUBREG)\n \t    {\n \t      rtx subreg_reg = SUBREG_REG (in_rtx);\n@@ -855,48 +858,41 @@ static rtx\n emit_spill_move (bool to_p, rtx mem_pseudo, rtx val)\n {\n   if (GET_MODE (mem_pseudo) != GET_MODE (val))\n-    val = gen_rtx_SUBREG (GET_MODE (mem_pseudo),\n-\t\t\t  GET_CODE (val) == SUBREG ? SUBREG_REG (val) : val,\n-\t\t\t  0);\n+    {\n+      val = gen_rtx_SUBREG (GET_MODE (mem_pseudo),\n+\t\t\t    GET_CODE (val) == SUBREG ? SUBREG_REG (val) : val,\n+\t\t\t    0);\n+      LRA_SUBREG_P (val) = 1;\n+    }\n   return (to_p\n-\t  ? gen_move_insn (mem_pseudo, val)\n-\t  : gen_move_insn (val, mem_pseudo));\n+          ? gen_move_insn (mem_pseudo, val)\n+          : gen_move_insn (val, mem_pseudo));\n }\n \n /* Process a special case insn (register move), return true if we\n-   don't need to process it anymore.  Return that RTL was changed\n-   through CHANGE_P and macro SECONDARY_MEMORY_NEEDED says to use\n-   secondary memory through SEC_MEM_P.\t*/\n+   don't need to process it anymore.  INSN should be a single set\n+   insn.  Set up that RTL was changed through CHANGE_P and macro\n+   SECONDARY_MEMORY_NEEDED says to use secondary memory through\n+   SEC_MEM_P.  */\n static bool\n-check_and_process_move (bool *change_p, bool *sec_mem_p)\n+check_and_process_move (bool *change_p, bool *sec_mem_p ATTRIBUTE_UNUSED)\n {\n   int sregno, dregno;\n-  rtx set, dest, src, dreg, sreg, old_sreg, new_reg, before, scratch_reg;\n+  rtx dest, src, dreg, sreg, old_sreg, new_reg, before, scratch_reg;\n   enum reg_class dclass, sclass, secondary_class;\n   enum machine_mode sreg_mode;\n   secondary_reload_info sri;\n \n-  *sec_mem_p = *change_p = false;\n-  if ((set = single_set (curr_insn)) == NULL)\n-    return false;\n-  dreg = dest = SET_DEST (set);\n-  sreg = src = SET_SRC (set);\n-  /* Quick check on the right move insn which does not need\n-     reloads.  */\n-  if ((dclass = get_op_class (dest)) != NO_REGS\n-      && (sclass = get_op_class (src)) != NO_REGS\n-      /* The backend guarantees that register moves of cost 2 never\n-\t need reloads.  */\n-      && targetm.register_move_cost (GET_MODE (src), dclass, sclass) == 2)\n-    return true;\n+  lra_assert (curr_insn_set != NULL_RTX);\n+  dreg = dest = SET_DEST (curr_insn_set);\n+  sreg = src = SET_SRC (curr_insn_set);\n   if (GET_CODE (dest) == SUBREG)\n     dreg = SUBREG_REG (dest);\n   if (GET_CODE (src) == SUBREG)\n     sreg = SUBREG_REG (src);\n   if (! REG_P (dreg) || ! REG_P (sreg))\n     return false;\n   sclass = dclass = NO_REGS;\n-  dreg = get_equiv_substitution (dreg);\n   if (REG_P (dreg))\n     dclass = get_reg_class (REGNO (dreg));\n   if (dclass == ALL_REGS)\n@@ -910,7 +906,6 @@ check_and_process_move (bool *change_p, bool *sec_mem_p)\n     return false;\n   sreg_mode = GET_MODE (sreg);\n   old_sreg = sreg;\n-  sreg = get_equiv_substitution (sreg);\n   if (REG_P (sreg))\n     sclass = get_reg_class (REGNO (sreg));\n   if (sclass == ALL_REGS)\n@@ -1007,7 +1002,7 @@ check_and_process_move (bool *change_p, bool *sec_mem_p)\n       if (GET_CODE (src) == SUBREG)\n \tSUBREG_REG (src) = new_reg;\n       else\n-\tSET_SRC (set) = new_reg;\n+\tSET_SRC (curr_insn_set) = new_reg;\n     }\n   else\n     {\n@@ -1204,7 +1199,10 @@ simplify_operand_subreg (int nop, enum machine_mode reg_mode)\n        && (hard_regno_nregs[hard_regno][GET_MODE (reg)]\n \t   >= hard_regno_nregs[hard_regno][mode])\n        && simplify_subreg_regno (hard_regno, GET_MODE (reg),\n-\t\t\t\t SUBREG_BYTE (operand), mode) < 0)\n+\t\t\t\t SUBREG_BYTE (operand), mode) < 0\n+       /* Don't reload subreg for matching reload.  It is actually\n+\t  valid subreg in LRA.  */\n+       && ! LRA_SUBREG_P (operand))\n       || CONSTANT_P (reg) || GET_CODE (reg) == PLUS || MEM_P (reg))\n     {\n       enum op_type type = curr_static_id->operand[nop].type;\n@@ -1311,6 +1309,14 @@ general_constant_p (rtx x)\n   return CONSTANT_P (x) && (! flag_pic || LEGITIMATE_PIC_OPERAND_P (x));\n }\n \n+static bool\n+reg_in_class_p (rtx reg, enum reg_class cl)\n+{\n+  if (cl == NO_REGS)\n+    return get_reg_class (REGNO (reg)) == NO_REGS;\n+  return in_class_p (reg, cl, NULL);\n+}\n+\n /* Major function to choose the current insn alternative and what\n    operands should be reloaded and how.\t If ONLY_ALTERNATIVE is not\n    negative we should consider only this alternative.  Return false if\n@@ -1390,7 +1396,7 @@ process_alt_operands (int only_alternative)\n   for (nalt = 0; nalt < n_alternatives; nalt++)\n     {\n       /* Loop over operands for one constraint alternative.  */\n-#ifdef HAVE_ATTR_enabled\n+#if HAVE_ATTR_enabled\n       if (curr_id->alternative_enabled_p != NULL\n \t  && ! curr_id->alternative_enabled_p[nalt])\n \tcontinue;\n@@ -2054,6 +2060,31 @@ process_alt_operands (int only_alternative)\n \t  if (early_clobber_p && operand_reg[nop] != NULL_RTX)\n \t    early_clobbered_nops[early_clobbered_regs_num++] = nop;\n \t}\n+      if (curr_insn_set != NULL_RTX && n_operands == 2\n+\t  && ((! curr_alt_win[0] && ! curr_alt_win[1]\n+\t       && REG_P (no_subreg_reg_operand[0])\n+\t       && REG_P (no_subreg_reg_operand[1])\n+\t       && (reg_in_class_p (no_subreg_reg_operand[0], curr_alt[1])\n+\t\t   || reg_in_class_p (no_subreg_reg_operand[1], curr_alt[0])))\n+\t      || (! curr_alt_win[0] && curr_alt_win[1]\n+\t\t  && REG_P (no_subreg_reg_operand[1])\n+\t\t  && reg_in_class_p (no_subreg_reg_operand[1], curr_alt[0]))\n+\t      || (curr_alt_win[0] && ! curr_alt_win[1]\n+\t\t  && REG_P (no_subreg_reg_operand[0])\n+\t\t  && reg_in_class_p (no_subreg_reg_operand[0], curr_alt[1])\n+\t\t  && (! CONST_POOL_OK_P (curr_operand_mode[1],\n+\t\t\t\t\t no_subreg_reg_operand[1])\n+\t\t      || (targetm.preferred_reload_class\n+\t\t\t  (no_subreg_reg_operand[1],\n+\t\t\t   (enum reg_class) curr_alt[1]) != NO_REGS))\n+\t\t  /* If it is a result of recent elimination in move\n+\t\t     insn we can transform it into an add still by\n+\t\t     using this alternative.  */\n+\t\t  && GET_CODE (no_subreg_reg_operand[1]) != PLUS)))\n+\t/* We have a move insn and a new reload insn will be similar\n+\t   to the current insn.  We should avoid such situation as it\n+\t   results in LRA cycling.  */\n+\toverall += LRA_MAX_REJECT;\n       ok_p = true;\n       curr_alt_dont_inherit_ops_num = 0;\n       for (nop = 0; nop < early_clobbered_regs_num; nop++)\n@@ -2425,54 +2456,75 @@ process_address (int nop, rtx *before, rtx *after)\n       && process_addr_reg (ad.index_term, before, NULL, INDEX_REG_CLASS))\n     change_p = true;\n \n+#ifdef EXTRA_CONSTRAINT_STR\n+  /* Target hooks sometimes reject extra constraint addresses -- use\n+     EXTRA_CONSTRAINT_STR for the validation.  */\n+  if (constraint[0] != 'p'\n+      && EXTRA_ADDRESS_CONSTRAINT (constraint[0], constraint)\n+      && EXTRA_CONSTRAINT_STR (op, constraint[0], constraint))\n+    return change_p;\n+#endif\n+\n   /* There are three cases where the shape of *AD.INNER may now be invalid:\n \n      1) the original address was valid, but either elimination or\n-\tequiv_address_substitution applied a displacement that made\n-\tit invalid.\n+\tequiv_address_substitution was applied and that made\n+\tthe address invalid.\n \n      2) the address is an invalid symbolic address created by\n \tforce_const_to_mem.\n \n      3) the address is a frame address with an invalid offset.\n \n-     All these cases involve a displacement and a non-autoinc address,\n-     so there is no point revalidating other types.  */\n-  if (ad.disp == NULL || ad.autoinc_p || valid_address_p (&ad))\n+     All these cases involve a non-autoinc address, so there is no\n+     point revalidating other types.  */\n+  if (ad.autoinc_p || valid_address_p (&ad))\n     return change_p;\n \n   /* Any index existed before LRA started, so we can assume that the\n      presence and shape of the index is valid.  */\n   push_to_sequence (*before);\n-  gcc_assert (ad.segment == NULL);\n-  gcc_assert (ad.disp == ad.disp_term);\n+  lra_assert (ad.disp == ad.disp_term);\n   if (ad.base == NULL)\n     {\n       if (ad.index == NULL)\n \t{\n \t  int code = -1;\n \t  enum reg_class cl = base_reg_class (ad.mode, ad.as,\n \t\t\t\t\t      SCRATCH, SCRATCH);\n-\t  rtx disp = *ad.disp;\n+\t  rtx addr = *ad.inner;\n \n-\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"disp\");\n+\t  new_reg = lra_create_new_reg (Pmode, NULL_RTX, cl, \"addr\");\n #ifdef HAVE_lo_sum\n \t  {\n \t    rtx insn;\n \t    rtx last = get_last_insn ();\n \n-\t    /* disp => lo_sum (new_base, disp), case (2) above.  */\n+\t    /* addr => lo_sum (new_base, addr), case (2) above.  */\n \t    insn = emit_insn (gen_rtx_SET\n \t\t\t      (VOIDmode, new_reg,\n-\t\t\t       gen_rtx_HIGH (Pmode, copy_rtx (disp))));\n+\t\t\t       gen_rtx_HIGH (Pmode, copy_rtx (addr))));\n \t    code = recog_memoized (insn);\n \t    if (code >= 0)\n \t      {\n-\t\t*ad.disp = gen_rtx_LO_SUM (Pmode, new_reg, disp);\n+\t\t*ad.inner = gen_rtx_LO_SUM (Pmode, new_reg, addr);\n \t\tif (! valid_address_p (ad.mode, *ad.outer, ad.as))\n \t\t  {\n-\t\t    *ad.disp = disp;\n-\t\t    code = -1;\n+\t\t    /* Try to put lo_sum into register.  */\n+\t\t    insn = emit_insn (gen_rtx_SET\n+\t\t\t\t      (VOIDmode, new_reg,\n+\t\t\t\t       gen_rtx_LO_SUM (Pmode, new_reg, addr)));\n+\t\t    code = recog_memoized (insn);\n+\t\t    if (code >= 0)\n+\t\t      {\n+\t\t\t*ad.inner = new_reg;\n+\t\t\tif (! valid_address_p (ad.mode, *ad.outer, ad.as))\n+\t\t\t  {\n+\t\t\t    *ad.inner = addr;\n+\t\t\t    code = -1;\n+\t\t\t  }\n+\t\t      }\n+\t\t    \n \t\t  }\n \t      }\n \t    if (code < 0)\n@@ -2481,9 +2533,9 @@ process_address (int nop, rtx *before, rtx *after)\n #endif\n \t  if (code < 0)\n \t    {\n-\t      /* disp => new_base, case (2) above.  */\n-\t      lra_emit_move (new_reg, disp);\n-\t      *ad.disp = new_reg;\n+\t      /* addr => new_base, case (2) above.  */\n+\t      lra_emit_move (new_reg, addr);\n+\t      *ad.inner = new_reg;\n \t    }\n \t}\n       else\n@@ -2650,6 +2702,24 @@ emit_inc (enum reg_class new_rclass, rtx in, rtx value, int inc_amount)\n   return result;\n }\n \n+/* Return true if the current move insn does not need processing as we\n+   already know that it satisfies its constraints.  */\n+static bool\n+simple_move_p (void)\n+{\n+  rtx dest, src;\n+  enum reg_class dclass, sclass;\n+\n+  lra_assert (curr_insn_set != NULL_RTX);\n+  dest = SET_DEST (curr_insn_set);\n+  src = SET_SRC (curr_insn_set);\n+  return ((dclass = get_op_class (dest)) != NO_REGS\n+\t  && (sclass = get_op_class (src)) != NO_REGS\n+\t  /* The backend guarantees that register moves of cost 2\n+\t     never need reloads.  */\n+\t  && targetm.register_move_cost (GET_MODE (src), dclass, sclass) == 2);\n+ }\n+\n /* Swap operands NOP and NOP + 1. */\n static inline void\n swap_operands (int nop)\n@@ -2693,12 +2763,13 @@ curr_insn_transform (void)\n   int max_regno_before;\n   int reused_alternative_num;\n \n+  curr_insn_set = single_set (curr_insn);\n+  if (curr_insn_set != NULL_RTX && simple_move_p ())\n+    return false;\n+\n   no_input_reloads_p = no_output_reloads_p = false;\n   goal_alt_number = -1;\n-\n-  if (check_and_process_move (&change_p, &sec_mem_p))\n-    return change_p;\n-\n+  change_p = sec_mem_p = false;\n   /* JUMP_INSNs and CALL_INSNs are not allowed to have any output\n      reloads; neither are insns that SET cc0.  Insns that use CC0 are\n      not allowed to have any input reloads.  */\n@@ -2793,6 +2864,10 @@ curr_insn_transform (void)\n        we chose previously may no longer be valid.  */\n     lra_set_used_insn_alternative (curr_insn, -1);\n \n+  if (curr_insn_set != NULL_RTX\n+      && check_and_process_move (&change_p, &sec_mem_p))\n+    return change_p;\n+\n  try_swapped:\n \n   reused_alternative_num = curr_id->used_insn_alternative;\n@@ -4812,7 +4887,7 @@ inherit_in_ebb (rtx head, rtx tail)\n /* This value affects EBB forming.  If probability of edge from EBB to\n    a BB is not greater than the following value, we don't add the BB\n    to EBB.  */\n-#define EBB_PROBABILITY_CUTOFF (REG_BR_PROB_BASE / 2)\n+#define EBB_PROBABILITY_CUTOFF ((REG_BR_PROB_BASE * 50) / 100)\n \n /* Current number of inheritance/split iteration.  */\n int lra_inheritance_iter;"}, {"sha": "24a0dc7523db3b3f99b973e068b2b0c08647457c", "filename": "gcc/lra-eliminations.c", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-eliminations.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-eliminations.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-eliminations.c?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -977,23 +977,23 @@ eliminate_regs_in_insn (rtx insn, bool replace_p)\n \t}\n     }\n \n+  if (! validate_p)\n+    return;\n+\n   /* Substitute the operands; the new values are in the substed_operand\n      array.  */\n   for (i = 0; i < static_id->n_operands; i++)\n     *id->operand_loc[i] = substed_operand[i];\n   for (i = 0; i < static_id->n_dups; i++)\n     *id->dup_loc[i] = substed_operand[(int) static_id->dup_num[i]];\n \n-  if (validate_p)\n-    {\n-      /* If we had a move insn but now we don't, re-recognize it.\n-\t This will cause spurious re-recognition if the old move had a\n-\t PARALLEL since the new one still will, but we can't call\n-\t single_set without having put new body into the insn and the\n-\t re-recognition won't hurt in this rare case.  */\n-      id = lra_update_insn_recog_data (insn);\n-      static_id = id->insn_static_data;\n-    }\n+  /* If we had a move insn but now we don't, re-recognize it.\n+     This will cause spurious re-recognition if the old move had a\n+     PARALLEL since the new one still will, but we can't call\n+     single_set without having put new body into the insn and the\n+     re-recognition won't hurt in this rare case.  */\n+  id = lra_update_insn_recog_data (insn);\n+  static_id = id->insn_static_data;\n }\n \n /* Spill pseudos which are assigned to hard registers in SET.  Add"}, {"sha": "7c0c630273dfc92da99002331b1935f9b3ac6e98", "filename": "gcc/lra-spills.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-spills.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra-spills.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra-spills.c?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -548,6 +548,11 @@ lra_spill (void)\n   for (i = 0; i < n; i++)\n     if (pseudo_slots[pseudo_regnos[i]].mem == NULL_RTX)\n       assign_mem_slot (pseudo_regnos[i]);\n+  if (n > 0 && crtl->stack_alignment_needed)\n+    /* If we have a stack frame, we must align it now.  The stack size\n+       may be a part of the offset computation for register\n+       elimination.  */\n+    assign_stack_local (BLKmode, 0, crtl->stack_alignment_needed);\n   if (lra_dump_file != NULL)\n     {\n       for (i = 0; i < slots_num; i++)\n@@ -644,10 +649,12 @@ lra_final_code_change (void)\n \t    }\n \n \t  lra_insn_recog_data_t id = lra_get_insn_recog_data (insn);\n+\t  struct lra_static_insn_data *static_id = id->insn_static_data;\n \t  bool insn_change_p = false;\n \n \t  for (i = id->insn_static_data->n_operands - 1; i >= 0; i--)\n-\t    if (alter_subregs (id->operand_loc[i], ! DEBUG_INSN_P (insn)))\n+\t    if ((DEBUG_INSN_P (insn) || ! static_id->operand[i].is_operator)\n+\t\t&& alter_subregs (id->operand_loc[i], ! DEBUG_INSN_P (insn)))\n \t      {\n \t\tlra_update_dup (id, i);\n \t\tinsn_change_p = true;"}, {"sha": "7c6bff15b8b3eb1c94d41ab5965b331639806ba5", "filename": "gcc/lra.c", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Flra.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flra.c?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -2203,6 +2203,10 @@ lra (FILE *f)\n \n   timevar_push (TV_LRA);\n \n+  /* Make sure that the last insn is a note.  Some subsequent passes\n+     need it.  */\n+  emit_note (NOTE_INSN_DELETED);\n+\n   COPY_HARD_REG_SET (lra_no_alloc_regs, ira_no_alloc_regs);\n \n   init_reg_info ();\n@@ -2259,6 +2263,11 @@ lra (FILE *f)\n   bitmap_initialize (&lra_split_regs, &reg_obstack);\n   bitmap_initialize (&lra_optional_reload_pseudos, &reg_obstack);\n   live_p = false;\n+  if (get_frame_size () != 0 && crtl->stack_alignment_needed)\n+    /* If we have a stack frame, we must align it now.  The stack size\n+       may be a part of the offset computation for register\n+       elimination.  */\n+    assign_stack_local (BLKmode, 0, crtl->stack_alignment_needed);\n   for (;;)\n     {\n       for (;;)"}, {"sha": "75d1113fcfbbd04459c941a0010e57469bc0f068", "filename": "gcc/recog.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Frecog.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Frecog.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frecog.c?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -1065,7 +1065,11 @@ register_operand (rtx op, enum machine_mode mode)\n \t  && REGNO (sub) < FIRST_PSEUDO_REGISTER\n \t  && REG_CANNOT_CHANGE_MODE_P (REGNO (sub), GET_MODE (sub), mode)\n \t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_INT\n-\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT)\n+\t  && GET_MODE_CLASS (GET_MODE (sub)) != MODE_COMPLEX_FLOAT\n+\t  /* LRA can generate some invalid SUBREGS just for matched\n+\t     operand reload presentation.  LRA needs to treat them as\n+\t     valid.  */\n+\t  && ! LRA_SUBREG_P (op))\n \treturn 0;\n #endif\n "}, {"sha": "e9013ec4a084ce977667e7301067cc92df0305c1", "filename": "gcc/rtl.h", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f6ce35ac7cd0498638a00396ae4a47269def92ac/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=f6ce35ac7cd0498638a00396ae4a47269def92ac", "patch": "@@ -265,7 +265,8 @@ struct GTY((chain_next (\"RTX_NEXT (&%h)\"),\n      1 in a SET that is for a return.\n      In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a CONCAT is VAL_EXPR_IS_COPIED in var-tracking.c.\n-     1 in a VALUE is SP_BASED_VALUE_P in cselib.c.  */\n+     1 in a VALUE is SP_BASED_VALUE_P in cselib.c.\n+     1 in a SUBREG generated by LRA for reload insns.  */\n   unsigned int jump : 1;\n   /* In a CODE_LABEL, part of the two-bit alternate entry field.\n      1 in a MEM if it cannot trap.\n@@ -1411,6 +1412,11 @@ do {\t\t\t\t\t\t\t\t\t\\\n   ((RTL_FLAG_CHECK1(\"SUBREG_PROMOTED_UNSIGNED_P\", (RTX), SUBREG)->volatil) \\\n    ? -1 : (int) (RTX)->unchanging)\n \n+/* True if the subreg was generated by LRA for reload insns.  Such\n+   subregs are valid only during LRA.  */\n+#define LRA_SUBREG_P(RTX)\t\\\n+  (RTL_FLAG_CHECK1(\"LRA_SUBREG_P\", (RTX), SUBREG)->jump)\n+\n /* Access various components of an ASM_OPERANDS rtx.  */\n \n #define ASM_OPERANDS_TEMPLATE(RTX) XCSTR (RTX, 0, ASM_OPERANDS)"}]}