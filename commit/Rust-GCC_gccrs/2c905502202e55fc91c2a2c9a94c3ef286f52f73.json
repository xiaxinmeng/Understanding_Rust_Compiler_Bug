{"sha": "2c905502202e55fc91c2a2c9a94c3ef286f52f73", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MmM5MDU1MDIyMDJlNTVmYzkxYzJhMmM5YTk0YzNlZjI4NmY1MmY3Mw==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2012-08-31T02:50:28Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2012-08-31T02:50:28Z"}, "message": "re PR c++/50545 ([C++0x][DR 1172] SFINAE does not handle an explicit type conversion (functional notation) with a braced-init-list well if target type is not dependent)\n\n\tPR c++/50545\n\tPR c++/51222\n\t* pt.c (instantiation_dependent_r): New.\n\t(instantiation_dependent_expression_p): New.\n\t(value_dependent_expression_p): Use it.  SCOPE_REF is always dependent.\n\t* semantics.c (finish_decltype_type): Use it.\n\t* cp-tree.h: Declare it.\n\nFrom-SVN: r190830", "tree": {"sha": "037fed94ca2a1f6f563da30fce47620ac45fcd05", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/037fed94ca2a1f6f563da30fce47620ac45fcd05"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/2c905502202e55fc91c2a2c9a94c3ef286f52f73", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c905502202e55fc91c2a2c9a94c3ef286f52f73", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c905502202e55fc91c2a2c9a94c3ef286f52f73", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c905502202e55fc91c2a2c9a94c3ef286f52f73/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e467c9d25782edea98d2cd66956d5abb82e847e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e467c9d25782edea98d2cd66956d5abb82e847e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e467c9d25782edea98d2cd66956d5abb82e847e9"}], "stats": {"total": 321, "additions": 293, "deletions": 28}, "files": [{"sha": "0bfcde7ecd85cc93b07ec67929e920234f3aba88", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -1,5 +1,13 @@\n 2012-08-30  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/50545\n+\tPR c++/51222\n+\t* pt.c (instantiation_dependent_r): New.\n+\t(instantiation_dependent_expression_p): New.\n+\t(value_dependent_expression_p): Use it.  SCOPE_REF is always dependent.\n+\t* semantics.c (finish_decltype_type): Use it.\n+\t* cp-tree.h: Declare it.\n+\n \t* semantics.c (finish_qualified_id_expr): Handle building up a\n \tnon-dependent SCOPE_REF here.\n \t(finish_id_expression): Not here."}, {"sha": "1b085bd16094d7994aa4d81b21021532eba14b9c", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -5391,6 +5391,7 @@ extern bool any_type_dependent_arguments_p      (const VEC(tree,gc) *);\n extern bool any_type_dependent_elements_p       (const_tree);\n extern bool type_dependent_expression_p_push\t(tree);\n extern bool value_dependent_expression_p\t(tree);\n+extern bool instantiation_dependent_expression_p (tree);\n extern bool any_value_dependent_elements_p      (const_tree);\n extern bool dependent_omp_for_p\t\t\t(tree, tree, tree, tree);\n extern tree resolve_typename_type\t\t(tree, bool);"}, {"sha": "5ce6e8af87fc0ce79b37e4659841c60a94f893fb", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 105, "deletions": 20, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -19100,20 +19100,7 @@ dependent_scope_p (tree scope)\n \n /* Note that this predicate is not appropriate for general expressions;\n    only constant expressions (that satisfy potential_constant_expression)\n-   can be tested for value dependence.\n-\n-   We should really also have a predicate for \"instantiation-dependent\".\n-\n-   fold_non_dependent_expr: fold if constant and not type-dependent and not value-dependent.\n-     (what about instantiation-dependent constant-expressions?)\n-   is_late_template_attribute: defer if instantiation-dependent.\n-   compute_array_index_type: proceed if constant and not t- or v-dependent\n-     if instantiation-dependent, need to remember full expression\n-   uses_template_parms: FIXME - need to audit callers\n-   tsubst_decl [function_decl]: Why is this using value_dependent_expression_p?\n-   dependent_type_p [array_type]: dependent if index type is dependent\n-     (or non-constant?)\n-   static_assert - instantiation-dependent */\n+   can be tested for value dependence.  */\n \n bool\n value_dependent_expression_p (tree expression)\n@@ -19193,7 +19180,7 @@ value_dependent_expression_p (tree expression)\n         return true;\n       else if (TYPE_P (expression))\n \treturn dependent_type_p (expression);\n-      return type_dependent_expression_p (expression);\n+      return instantiation_dependent_expression_p (expression);\n \n     case AT_ENCODE_EXPR:\n       /* An 'encode' expression is value-dependent if the operand is\n@@ -19203,13 +19190,13 @@ value_dependent_expression_p (tree expression)\n \n     case NOEXCEPT_EXPR:\n       expression = TREE_OPERAND (expression, 0);\n-      return type_dependent_expression_p (expression);\n+      return instantiation_dependent_expression_p (expression);\n \n     case SCOPE_REF:\n-      {\n-\ttree name = TREE_OPERAND (expression, 1);\n-\treturn value_dependent_expression_p (name);\n-      }\n+      /* instantiation_dependent_r treats this as dependent so that we\n+\t check access at instantiation time, and all instantiation-dependent\n+\t expressions should also be considered value-dependent.  */\n+      return true;\n \n     case COMPONENT_REF:\n       return (value_dependent_expression_p (TREE_OPERAND (expression, 0))\n@@ -19488,6 +19475,104 @@ type_dependent_expression_p (tree expression)\n   return (dependent_type_p (TREE_TYPE (expression)));\n }\n \n+/* walk_tree callback function for instantiation_dependent_expression_p,\n+   below.  Returns non-zero if a dependent subexpression is found.  */\n+\n+static tree\n+instantiation_dependent_r (tree *tp, int *walk_subtrees,\n+\t\t\t   void *data ATTRIBUTE_UNUSED)\n+{\n+  if (TYPE_P (*tp))\n+    {\n+      /* We don't have to worry about decltype currently because decltype\n+\t of an instantiation-dependent expr is a dependent type.  This\n+\t might change depending on the resolution of DR 1172.  */\n+      *walk_subtrees = false;\n+      return NULL_TREE;\n+    }\n+  enum tree_code code = TREE_CODE (*tp);\n+  switch (code)\n+    {\n+      /* Don't treat an argument list as dependent just because it has no\n+\t TREE_TYPE.  */\n+    case TREE_LIST:\n+    case TREE_VEC:\n+      return NULL_TREE;\n+\n+    case TEMPLATE_PARM_INDEX:\n+      return *tp;\n+\n+      /* Handle expressions with type operands.  */\n+    case SIZEOF_EXPR:\n+    case ALIGNOF_EXPR:\n+    case TYPEID_EXPR:\n+    case AT_ENCODE_EXPR:\n+    case TRAIT_EXPR:\n+      {\n+\ttree op = TREE_OPERAND (*tp, 0);\n+\tif (TYPE_P (op))\n+\t  {\n+\t    if (dependent_type_p (op)\n+\t\t|| (code == TRAIT_EXPR\n+\t\t    && dependent_type_p (TREE_OPERAND (*tp, 1))))\n+\t      return *tp;\n+\t    else\n+\t      {\n+\t\t*walk_subtrees = false;\n+\t\treturn NULL_TREE;\n+\t      }\n+\t  }\n+\tbreak;\n+      }\n+\n+    case COMPONENT_REF:\n+      if (TREE_CODE (TREE_OPERAND (*tp, 1)) == IDENTIFIER_NODE)\n+\t/* In a template, finish_class_member_access_expr creates a\n+\t   COMPONENT_REF with an IDENTIFIER_NODE for op1 even if it isn't\n+\t   type-dependent, so that we can check access control at\n+\t   instantiation time (PR 42277).  See also Core issue 1273.  */\n+\treturn *tp;\n+      break;\n+\n+    case SCOPE_REF:\n+      /* Similarly, finish_qualified_id_expr builds up a SCOPE_REF in a\n+\t template so that we can check access at instantiation time even\n+\t though we know which member it resolves to.  */\n+      return *tp;\n+\n+    default:\n+      break;\n+    }\n+\n+  if (type_dependent_expression_p (*tp))\n+    return *tp;\n+  else\n+    return NULL_TREE;\n+}\n+\n+/* Returns TRUE if the EXPRESSION is instantiation-dependent, in the\n+   sense defined by the ABI:\n+\n+   \"An expression is instantiation-dependent if it is type-dependent\n+   or value-dependent, or it has a subexpression that is type-dependent\n+   or value-dependent.\"  */\n+\n+bool\n+instantiation_dependent_expression_p (tree expression)\n+{\n+  tree result;\n+\n+  if (!processing_template_decl)\n+    return false;\n+\n+  if (expression == error_mark_node)\n+    return false;\n+\n+  result = cp_walk_tree_without_duplicates (&expression,\n+\t\t\t\t\t    instantiation_dependent_r, NULL);\n+  return result != NULL_TREE;\n+}\n+\n /* Like type_dependent_expression_p, but it also works while not processing\n    a template definition, i.e. during substitution or mangling.  */\n "}, {"sha": "183a78a7e4faaa3e250fa063ff9dc42c85fe78db", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 8, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -5187,14 +5187,10 @@ finish_decltype_type (tree expr, bool id_expression_or_member_access_p,\n       return error_mark_node;\n     }\n \n-  /* FIXME instantiation-dependent  */\n-  if (type_dependent_expression_p (expr)\n-      /* In a template, a COMPONENT_REF has an IDENTIFIER_NODE for op1 even\n-\t if it isn't dependent, so that we can check access control at\n-\t instantiation time, so defer the decltype as well (PR 42277).  */\n-      || (id_expression_or_member_access_p\n-\t  && processing_template_decl\n-\t  && TREE_CODE (expr) == COMPONENT_REF))\n+  /* Depending on the resolution of DR 1172, we may later need to distinguish\n+     instantiation-dependent but not type-dependent expressions so that, say,\n+     A<decltype(sizeof(T))>::U doesn't require 'typename'.  */\n+  if (instantiation_dependent_expression_p (expr))\n     {\n       type = cxx_make_type (DECLTYPE_TYPE);\n       DECLTYPE_TYPE_EXPR (type) = expr;"}, {"sha": "7933c95b31f23708dd68272ebf005c38702a28c4", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype40.C", "status": "added", "additions": 101, "deletions": 0, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype40.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype40.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype40.C?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -0,0 +1,101 @@\n+// PR c++/51222\n+// { dg-options -std=c++11 }\n+\n+template<class T>\n+struct add_rref {\n+  typedef T&& type;\n+};\n+\n+template<>\n+struct add_rref<void> {\n+  typedef void type;\n+};\n+\n+template<class T>\n+typename add_rref<T>::type declval();\n+\n+template<class T, class U, class =\n+  decltype(::delete ::new T(declval<U>()))\n+>\n+auto f(int) -> char;\n+\n+template<class, class>\n+auto f(...) -> char(&)[2];\n+\n+template<class T, class =\n+  decltype(::delete ::new T())\n+>\n+auto g(int) -> char;\n+\n+template<class>\n+auto g(...) -> char(&)[2];\n+\n+template<class T, class U>\n+auto f2(int) -> decltype(::delete ::new T(declval<U>()), char());\n+\n+template<class, class>\n+auto f2(...) -> char(&)[2];\n+\n+template<class T>\n+auto g2(int) -> decltype(::delete ::new T(), char());\n+\n+template<class>\n+auto g2(...) -> char(&)[2];\n+\n+struct C { };\n+\n+struct A {\n+  virtual ~A() = 0;\n+};\n+\n+struct D1 {\n+  D1() = delete;\n+};\n+\n+struct D2 {\n+  ~D2() = delete;\n+};\n+\n+static_assert(sizeof(g<void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<void()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<void() const>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<A>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<D1>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<D2>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<int&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<int&&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<void(&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g<void(&&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void(), void()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void() const, void() const>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<int, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void, int>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<C, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<C, int>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<int&, int&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<int&&, int&&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void(&)(), void(&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f<void(&&)(), void(&&)()>(0)) == 2, \"Ouch\");\n+\n+static_assert(sizeof(g2<void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<void()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<void() const>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<A>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<D1>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<D2>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<int&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<int&&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<void(&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(g2<void(&&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void(), void()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void() const, void() const>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<int, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void, int>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<C, void>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<C, int>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<int&, int&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<int&&, int&&>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void(&)(), void(&)()>(0)) == 2, \"Ouch\");\n+static_assert(sizeof(f2<void(&&)(), void(&&)()>(0)) == 2, \"Ouch\");"}, {"sha": "1439e15c0d46a8f1433e3ffc05e8b41abc774073", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype41.C", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype41.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype41.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype41.C?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -0,0 +1,43 @@\n+// Core 1273\n+// { dg-do compile { target c++11 } }\n+\n+template <class T> struct C;\n+template <class T> struct D;\n+\n+class A\n+{\n+  int i;\n+  static int j;\n+  friend struct C<int>;\n+  friend struct D<int>;\n+} a;\n+\n+class B\n+{\n+  int i;\n+  static int j;\n+  friend struct C<float>;\n+  friend struct D<float>;\n+} b;\n+\n+template <class T>\n+struct C\n+{\n+  template <class U> decltype (a.i) f() { } // #1\n+  template <class U> decltype (b.i) f() { } // #2\n+};\n+\n+template <class T>\n+struct D\n+{\n+  template <class U> decltype (A::j) f() { } // #1\n+  template <class U> decltype (B::j) f() { } // #2\n+};\n+\n+int main()\n+{\n+  C<int>().f<int>();     // calls #1\n+  C<float>().f<float>(); // calls #2\n+  D<int>().f<int>();     // calls #1\n+  D<float>().f<float>(); // calls #2\n+}"}, {"sha": "6c1aa43647817f6a3c019fb2c138af45caad7039", "filename": "gcc/testsuite/g++.dg/cpp0x/decltype42.C", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype42.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/2c905502202e55fc91c2a2c9a94c3ef286f52f73/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype42.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Fdecltype42.C?ref=2c905502202e55fc91c2a2c9a94c3ef286f52f73", "patch": "@@ -0,0 +1,31 @@\n+// PR c++/50545\n+// { dg-do compile { target c++11 } }\n+\n+template< class T >\n+T&& declval();\n+\n+// #1\n+template< class T >\n+auto f( int )\n+  -> decltype( int{ declval<T>() } );\n+\n+// #2\n+template< class >\n+void f( ... );\n+\n+\n+#define STATIC_ASSERT( ... ) static_assert( __VA_ARGS__, #__VA_ARGS__ )\n+\n+template< class T, class U >\n+struct is_same {\n+  static constexpr bool value = false;\n+};\n+\n+template< class T >\n+struct is_same<T, T> {\n+  static constexpr bool value = true;\n+};\n+\n+\n+STATIC_ASSERT( is_same< decltype( f<int>(0) ),  int >::value );  // OK; f<int>(0) calls #1.\n+STATIC_ASSERT( is_same< decltype( f<int*>(0) ), void >::value ); // static assertion fails; f<int*>(0) should call #2, because int{ (int*)0 } is ill-formed, but calls #1."}]}