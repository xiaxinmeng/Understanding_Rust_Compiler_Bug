{"sha": "69971cd850625b888f40dacdb4fc122b57602e9b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Njk5NzFjZDg1MDYyNWI4ODhmNDBkYWNkYjRmYzEyMmI1NzYwMmU5Yg==", "commit": {"author": {"name": "Benjamin Kosnik", "email": "bkoz@redhat.com", "date": "2001-09-10T01:00:27Z"}, "committer": {"name": "Benjamin Kosnik", "email": "bkoz@gcc.gnu.org", "date": "2001-09-10T01:00:27Z"}, "message": "Implement std::money_put.\n\n\n2001-09-09  Benjamin Kosnik  <bkoz@redhat.com>\n\n\tImplement std::money_put.\n\t* include/bits/locale_facets.h\n\t(moneypunct::_M_initialize_moneypunct): Split up specializations\n\tto account for _Intl.  More grody hacking to get around the\n\till-considered use of const bool as a template parameter.\n\t* config/locale/moneypunct_members_gnu.cc: And here.\n\t* config/locale/moneypunct_members_generic.cc: And here.\n\t* testsuite/22_locale/moneypunct_members_char.cc: Add tests.\n\t* testsuite/22_locale/moneypunct.cc: Add tests.\n\t* testsuite/22_locale/money_put_members_wchar_t.cc: New file.\n\t* testsuite/22_locale/moneypunct_members_wchar_t.cc: New file.\n\n\t* src/locale.cc (money_base::_S_construct_pattern): Move into\n\tgnu-specific file.\n\t* config/locale/moneypunct_members_gnu.cc: Add here.\n\t* config/locale/moneypunct_members_generic.cc: Add generic version\n\there.\n\n\t* include/bits/locale_facets.tcc (money_put::do_put): Move member\n\tfunction definitions here.\n\t* include/bits/locale_facets.h (money_put): Implement.\n\t* src/locale-inst.cc: Add use_facet instantiations for moneypunct.\n\tCorrect money_get, money_put instantiations.\n\t* src/locale.cc (money_base::_S_construct_pattern): Handle case\n\twhere __posn == 0.\n\t* testsuite/22_locale/money_put_members_char.cc: Add tests.\n\nFrom-SVN: r45496", "tree": {"sha": "b815e508219cc05c103ba813878fb45c805615db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b815e508219cc05c103ba813878fb45c805615db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69971cd850625b888f40dacdb4fc122b57602e9b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69971cd850625b888f40dacdb4fc122b57602e9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69971cd850625b888f40dacdb4fc122b57602e9b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69971cd850625b888f40dacdb4fc122b57602e9b/comments", "author": null, "committer": null, "parents": [{"sha": "1650fcade99016be5813646d3b10461f1d28bf8b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1650fcade99016be5813646d3b10461f1d28bf8b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1650fcade99016be5813646d3b10461f1d28bf8b"}], "stats": {"total": 1668, "additions": 1297, "deletions": 371}, "files": [{"sha": "c220b260711c2e27cea2e6031dc43286cbc2ddda", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -1,3 +1,32 @@\n+2001-09-09  Benjamin Kosnik  <bkoz@redhat.com>\n+\n+\tImplement std::money_put.\n+\t* include/bits/locale_facets.h\n+\t(moneypunct::_M_initialize_moneypunct): Split up specializations\n+\tto account for _Intl.  More grody hacking to get around the\n+\till-considered use of const bool as a template parameter.\n+\t* config/locale/moneypunct_members_gnu.cc: And here.\n+\t* config/locale/moneypunct_members_generic.cc: And here.\t\n+\t* testsuite/22_locale/moneypunct_members_char.cc: Add tests.\n+\t* testsuite/22_locale/moneypunct.cc: Add tests.\n+\t* testsuite/22_locale/money_put_members_wchar_t.cc: New file.\n+\t* testsuite/22_locale/moneypunct_members_wchar_t.cc: New file.\n+\t\n+\t* src/locale.cc (money_base::_S_construct_pattern): Move into\n+\tgnu-specific file.\n+\t* config/locale/moneypunct_members_gnu.cc: Add here.\n+\t* config/locale/moneypunct_members_generic.cc: Add generic version\n+\there.\n+\n+\t* include/bits/locale_facets.tcc (money_put::do_put): Move member\n+\tfunction definitions here.\n+\t* include/bits/locale_facets.h (money_put): Implement.\n+\t* src/locale-inst.cc: Add use_facet instantiations for moneypunct.\n+\tCorrect money_get, money_put instantiations.\n+\t* src/locale.cc (money_base::_S_construct_pattern): Handle case\n+\twhere __posn == 0.\n+\t* testsuite/22_locale/money_put_members_char.cc: Add tests.\n+\t\n 2001-09-05  Phil Edwards  <pme@sources.redhat.com>\n \n \t* testsuite_flags.in:  No longer need to search testsuite builddir."}, {"sha": "dd92443c0f7ece5523969cd43834e5c0c558f798", "filename": "libstdc++-v3/config/locale/moneypunct_members_generic.cc", "status": "modified", "additions": 40, "deletions": 2, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_generic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_generic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_generic.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -37,9 +37,31 @@\n \n namespace std\n {\n+  // Construct and return valid pattern consisting of some combination of:\n+  // space none symbol sign value\n+  money_base::pattern\n+  money_base::_S_construct_pattern(char __preceeds, char __space, char __posn)\n+  { return _S_default_pattern; }\n+\n+  template<> \n+    void\n+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = '.';\n+      _M_thousands_sep = ',';\n+      _M_grouping = \"\";\n+      _M_curr_symbol = string_type();\n+      _M_positive_sign = string_type();\n+      _M_negative_sign = string_type();\n+      _M_frac_digits = 0;\n+      _M_pos_format = money_base::_S_default_pattern;\n+      _M_neg_format = money_base::_S_default_pattern;\n+    }\n+\n   template<> \n     void\n-    moneypunct<char>::_M_initialize_moneypunct(__c_locale)\n+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale)\n     {\n       // \"C\" locale\n       _M_decimal_point = '.';\n@@ -56,7 +78,23 @@ namespace std\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<> \n     void\n-    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale)\n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale)\n+    {\n+      // \"C\" locale\n+      _M_decimal_point = L'.';\n+      _M_thousands_sep = L',';\n+      _M_grouping = \"\";\n+      _M_curr_symbol = string_type();\n+      _M_positive_sign = string_type();\n+      _M_negative_sign = string_type();\n+      _M_frac_digits = 0;\n+      _M_pos_format = money_base::_S_default_pattern;\n+      _M_neg_format = money_base::_S_default_pattern;\n+    }\n+\n+  template<> \n+    void\n+    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale)\n     {\n       // \"C\" locale\n       _M_decimal_point = L'.';"}, {"sha": "83d647efbe26b66459447916079c829b383b43b4", "filename": "libstdc++-v3/config/locale/moneypunct_members_gnu.cc", "status": "modified", "additions": 291, "deletions": 66, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_gnu.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_gnu.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fconfig%2Flocale%2Fmoneypunct_members_gnu.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -37,9 +37,186 @@\n \n namespace std\n {\n+  // Construct and return valid pattern consisting of some combination of:\n+  // space none symbol sign value\n+  money_base::pattern\n+  money_base::_S_construct_pattern(char __preceeds, char __space, char __posn)\n+  { \n+    pattern __ret;\n+\n+    // This insanely complicated routine attempts to construct a valid\n+    // pattern for use with monyepunct. A couple of invariants:\n+\n+    // if (__preceeds) symbol -> value\n+    // else value -> symbol\n+    \n+    // if (__space) space\n+    // else none\n+\n+    // none == never first\n+    // space never first or last\n+\n+    // Any elegant implementations of this are welcome.\n+    switch (__posn)\n+      {\n+      case 0:\n+      case 1:\n+\t// 1 The sign precedes the value and symbol.\n+\tif (__space)\n+\t  {\n+\t    // Pattern starts with sign.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t    __ret.field[0] = sign;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern starts with sign and ends with none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[1] = value;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[0] = sign;\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 2:\n+\t// 2 The sign follows the value and symbol.\n+\tif (__space)\n+\t  {\n+\t    // Pattern either ends with sign.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[3] = sign;\n+\t  }\n+\telse\n+\t  {\n+\t    // Pattern ends with sign then none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = symbol;\n+\t      }\n+\t    __ret.field[2] = sign;\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 3:\n+\t// 3 The sign immediately precedes the symbol.\n+\tif (__space)\n+\t  {\n+\t    // Have space.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = sign;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = sign;\n+\t\t__ret.field[3] = symbol;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Have none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = sign;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = symbol;\n+\t      }\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      case 4:\n+\t// 4 The sign immediately follows the symbol. \n+\tif (__space)\n+\t  {\n+\t    // Have space.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = space;\n+\t\t__ret.field[3] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = space;\n+\t\t__ret.field[2] = symbol;\n+\t\t__ret.field[3] = sign;\n+\t      }\n+\t  }\n+\telse\n+\t  {\n+\t    // Have none.\n+\t    if (__preceeds)\n+\t      {\n+\t\t__ret.field[0] = symbol;\n+\t\t__ret.field[1] = sign;\n+\t\t__ret.field[2] = value;\n+\t      }\n+\t    else\n+\t      {\n+\t\t__ret.field[0] = value;\n+\t\t__ret.field[1] = symbol;\n+\t\t__ret.field[2] = sign;\n+\t      }\n+\t    __ret.field[3] = none;\n+\t  }\n+\tbreak;\n+      default:\n+\t;\n+      }\n+    return __ret;\n+  }\n+\n   template<> \n     void\n-    moneypunct<char>::_M_initialize_moneypunct(__c_locale __cloc)\n+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale __cloc)\n     {\n       if (!__cloc)\n \t{\n@@ -62,45 +239,69 @@ namespace std\n \t  _M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);\n \t  _M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n \t  _M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n-\t  if (intl)\n-\t    {\n-\t      _M_curr_symbol = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);\n-\t      _M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, __cloc));\n-\t      char __ppreceeds = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, \n-\t\t\t\t\t\t   __cloc));\n-\t      char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n-\t      char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n-\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n-\t\t\t\t\t\t   __pposn);\n-\t      char __npreceeds = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, \n-\t\t\t\t\t\t   __cloc));\n-\t      char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n-\t      char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n-\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n-\t\t\t\t\t\t   __nposn);\n-\t    }\n-\t  else\n-\t    {\n-\t      _M_curr_symbol = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n-\t      _M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n-\t      char __ppreceeds = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n-\t      char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n-\t      char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n-\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n-\t\t\t\t\t\t   __pposn);\n-\t      char __npreceeds = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n-\t      char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n-\t      char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n-\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n-\t\t\t\t\t\t   __nposn);\n-\t    }\n+\n+\t  // _Intl == true\n+\t  _M_curr_symbol = __nl_langinfo_l(__INT_CURR_SYMBOL, __cloc);\n+\t  _M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, __cloc));\n+\t  char __ppreceeds = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));\n+\t  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n+\t  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n+\t  _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, __pposn);\n+\t  char __npreceeds = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));\n+\t  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n+\t  char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n+\t  if (!__nposn)\n+\t    _M_negative_sign = \"()\";\n+\t  _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, __nposn);\n+\t}\n+    }\n+\n+  template<> \n+    void\n+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale __cloc)\n+    {\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_decimal_point = '.';\n+\t  _M_thousands_sep = ',';\n+\t  _M_grouping = \"\";\n+\t  _M_curr_symbol = string_type();\n+\t  _M_positive_sign = string_type();\n+\t  _M_negative_sign = string_type();\n+\t  _M_frac_digits = 0;\n+\t  _M_pos_format = money_base::_S_default_pattern;\n+\t  _M_neg_format = money_base::_S_default_pattern;\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  _M_decimal_point = *(__nl_langinfo_l(__MON_DECIMAL_POINT, __cloc));\n+\t  _M_thousands_sep = *(__nl_langinfo_l(__MON_THOUSANDS_SEP, __cloc));\n+\t  _M_grouping = __nl_langinfo_l(__MON_GROUPING, __cloc);\n+\t  _M_positive_sign = __nl_langinfo_l(__POSITIVE_SIGN, __cloc);\n+\t  _M_negative_sign = __nl_langinfo_l(__NEGATIVE_SIGN, __cloc);\n+\n+\t  // _Intl == false\n+\t  _M_curr_symbol = __nl_langinfo_l(__CURRENCY_SYMBOL, __cloc);\n+\t  _M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n+\t  char __ppreceeds = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n+\t  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n+\t  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n+\t  _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, __pposn);\n+\t  char __npreceeds = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n+\t  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n+\t  char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n+\t  if (!__nposn)\n+\t    _M_negative_sign = \"()\";\n+\t  _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, __nposn);\n \t}\n     }\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<> \n     void\n-    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale __cloc)\n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale __cloc)\n     {\n       if (!__cloc)\n \t{\n@@ -123,38 +324,62 @@ namespace std\n \t  _M_grouping = __nl_langinfo_l(GROUPING, __cloc);\n \t  _M_positive_sign = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__POSITIVE_SIGN, __cloc));\n \t  _M_negative_sign = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__NEGATIVE_SIGN, __cloc));\n-\t  if (intl)\n-\t    {\n-\t      _M_curr_symbol = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__INT_CURR_SYMBOL, __cloc));\n-\t      _M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, __cloc));\n-\t      char __ppreceeds = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, \n-\t\t\t\t\t\t   __cloc));\n-\t      char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n-\t      char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n-\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n-\t\t\t\t\t\t   __pposn);\n-\t      char __npreceeds = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, \n-\t\t\t\t\t\t   __cloc));\n-\t      char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n-\t      char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n-\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n-\t\t\t\t\t\t   __nposn);\n-\t    }\n-\t  else\n-\t    {\n-\t      _M_curr_symbol = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__CURRENCY_SYMBOL, __cloc));\n-\t      _M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n-\t      char __ppreceeds = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n-\t      char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n-\t      char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n-\t      _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, \n-\t\t\t\t\t\t   __pposn);\n-\t      char __npreceeds = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n-\t      char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n-\t      char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n-\t      _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, \n-\t\t\t\t\t\t   __nposn);\n-\t    }\n+\n+\t  // _Intl == true.\n+\t  _M_curr_symbol = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__INT_CURR_SYMBOL, __cloc));\n+\t  _M_frac_digits = *(__nl_langinfo_l(__INT_FRAC_DIGITS, __cloc));\n+\t  char __ppreceeds = *(__nl_langinfo_l(__INT_P_CS_PRECEDES, __cloc));\n+\t  char __pspace = *(__nl_langinfo_l(__INT_P_SEP_BY_SPACE, __cloc));\n+\t  char __pposn = *(__nl_langinfo_l(__INT_P_SIGN_POSN, __cloc));\n+\t  _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, __pposn);\n+\t  char __npreceeds = *(__nl_langinfo_l(__INT_N_CS_PRECEDES, __cloc));\n+\t  char __nspace = *(__nl_langinfo_l(__INT_N_SEP_BY_SPACE, __cloc));\n+\t  char __nposn = *(__nl_langinfo_l(__INT_N_SIGN_POSN, __cloc));\n+\t  if (!__nposn)\n+\t    _M_negative_sign = L\"()\";\n+\t  _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, __nposn);\n+\t}\n+    }\n+\n+  template<> \n+    void\n+    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale __cloc)\n+    {\n+      if (!__cloc)\n+\t{\n+\t  // \"C\" locale\n+\t  _M_decimal_point = L'.';\n+\t  _M_thousands_sep = L',';\n+\t  _M_grouping = \"\";\n+\t  _M_curr_symbol = string_type();\n+\t  _M_positive_sign = string_type();\n+\t  _M_negative_sign = string_type();\n+\t  _M_frac_digits = 0;\n+\t  _M_pos_format = money_base::_S_default_pattern;\n+\t  _M_neg_format = money_base::_S_default_pattern;\n+\t}\n+      else\n+\t{\n+\t  // Named locale.\n+\t  _M_decimal_point = reinterpret_cast<wchar_t>(__nl_langinfo_l(_NL_NUMERIC_DECIMAL_POINT_WC, __cloc));\n+\t  _M_thousands_sep = reinterpret_cast<wchar_t>(__nl_langinfo_l(_NL_NUMERIC_THOUSANDS_SEP_WC,__cloc));\n+\t  _M_grouping = __nl_langinfo_l(GROUPING, __cloc);\n+\t  _M_positive_sign = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__POSITIVE_SIGN, __cloc));\n+\t  _M_negative_sign = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__NEGATIVE_SIGN, __cloc));\n+\n+\t  // _Intl == false.\n+\t  _M_curr_symbol = reinterpret_cast<wchar_t*>(__nl_langinfo_l(__CURRENCY_SYMBOL, __cloc));\n+\t  _M_frac_digits = *(__nl_langinfo_l(__FRAC_DIGITS, __cloc));\n+\t  char __ppreceeds = *(__nl_langinfo_l(__P_CS_PRECEDES, __cloc));\n+\t  char __pspace = *(__nl_langinfo_l(__P_SEP_BY_SPACE, __cloc));\n+\t  char __pposn = *(__nl_langinfo_l(__P_SIGN_POSN, __cloc));\n+\t  _M_pos_format = _S_construct_pattern(__ppreceeds, __pspace, __pposn);\n+\t  char __npreceeds = *(__nl_langinfo_l(__N_CS_PRECEDES, __cloc));\n+\t  char __nspace = *(__nl_langinfo_l(__N_SEP_BY_SPACE, __cloc));\n+\t  char __nposn = *(__nl_langinfo_l(__N_SIGN_POSN, __cloc));\n+\t  if (!__nposn)\n+\t    _M_negative_sign = L\"()\";\n+\t  _M_neg_format = _S_construct_pattern(__npreceeds, __nspace, __nposn);\n \t}\n     }\n #endif"}, {"sha": "1e64224d11d17bb40e6e8ac35707993543ef6e7b", "filename": "libstdc++-v3/include/bits/locale_facets.h", "status": "modified", "additions": 26, "deletions": 25, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.h?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -1271,26 +1271,24 @@ namespace std\n       iter_type \n       put(iter_type __s, bool __intl, ios_base& __f,\n \t  char_type __fill, long double __units) const\n-      { return do_put(__s, __intl, __f, __fill, __units); }\n+      { return this->do_put(__s, __intl, __f, __fill, __units); }\n \n       iter_type \n       put(iter_type __s, bool __intl, ios_base& __f,\n \t  char_type __fill, const string_type& __digits) const\n-      { return do_put(__s, __intl, __f, __fill, __digits); }\n+      { return this->do_put(__s, __intl, __f, __fill, __digits); }\n \n     protected:\n       virtual \n       ~money_put() { }\n \n       virtual iter_type\n-      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n-\t     long double /*__units*/) const\n-      { return __s; }\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     long double __units) const;\n \n       virtual iter_type\n-      do_put(iter_type __s, bool, ios_base& /*__io*/, char_type /*__fill*/,\n-\t     const string_type& /*__digits*/) const\n-      { return __s; }\n+      do_put(iter_type __s, bool __intl, ios_base& __io, char_type __fill,\n+\t     const string_type& __digits) const;\n     };\n \n   template<typename _CharT, typename _OutIter>\n@@ -1417,8 +1415,8 @@ namespace std\n       { return _M_neg_format; }\n \n       // For use at construction time only.\n-      void \n-      _M_initialize_moneypunct(__c_locale __cloc = NULL);\n+       void \n+       _M_initialize_moneypunct(__c_locale __cloc = NULL);\n     };\n \n   template<typename _CharT, bool _Intl>\n@@ -1427,21 +1425,28 @@ namespace std\n   template<typename _CharT, bool _Intl>\n     const bool moneypunct<_CharT, _Intl>::intl;\n \n+  // NB: Cannot be made generic. \n   template<typename _CharT, bool _Intl>\n     void\n-    moneypunct<_CharT, _Intl>::_M_initialize_moneypunct(__c_locale /*__cloc*/)\n-    { \n-      // NB: Cannot be made generic. \n-    }\n+    moneypunct<_CharT, _Intl>::_M_initialize_moneypunct(__c_locale)\n+    { }\n+\n+  template<> \n+    void\n+    moneypunct<char, true>::_M_initialize_moneypunct(__c_locale __cloc);\n \n   template<> \n     void\n-    moneypunct<char>::_M_initialize_moneypunct(__c_locale __cloc);\n+    moneypunct<char, false>::_M_initialize_moneypunct(__c_locale __cloc);\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template<> \n     void\n-    moneypunct<wchar_t>::_M_initialize_moneypunct(__c_locale __cloc);\n+    moneypunct<wchar_t, true>::_M_initialize_moneypunct(__c_locale __cloc);\n+\n+  template<> \n+    void\n+    moneypunct<wchar_t, false>::_M_initialize_moneypunct(__c_locale __cloc);\n #endif\n \n   template<typename _CharT, bool _Intl>\n@@ -1625,10 +1630,10 @@ namespace std\n     };\n \n \n-  // Subclause convenience interfaces, inlines \n-  // NB: these are inline\n-  // because, when used in a loop, some compilers can hoist the body\n-  // out of the loop; then it's just as fast as the C is*() function.\n+  // Subclause convenience interfaces, inlines.\n+  // NB: These are inline because, when used in a loop, some compilers\n+  // can hoist the body out of the loop; then it's just as fast as the\n+  // C is*() function.\n   template<typename _CharT>\n     inline bool \n     isspace(_CharT __c, const locale& __loc)\n@@ -1694,8 +1699,4 @@ namespace std\n     { return use_facet<ctype<_CharT> >(__loc).tolower(__c); }\n } // namespace std\n \n-#endif\t/* _CPP_BITS_LOCFACETS_H */\n-\n-// Local Variables:\n-// mode:c++\n-// End:\n+#endif"}, {"sha": "5ed35d1394422e27d46aaf5585970ec226c0e6d1", "filename": "libstdc++-v3/include/bits/locale_facets.tcc", "status": "modified", "additions": 217, "deletions": 48, "changes": 265, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Flocale_facets.tcc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -227,6 +227,184 @@ namespace std\n       return __ncp;\n     }\n \n+  template<typename _CharT, typename _OutIter>\n+    money_put<_CharT, _OutIter>::iter_type\n+    money_put<_CharT, _OutIter>::do_put(iter_type __s, bool __intl, \n+\t\t\t\t\tios_base& __io, char_type __fill,\n+\t\t\t\t\tlong double __units) const\n+    { \n+      locale __loc = __io.getloc();\n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc); \n+      const int __n = numeric_limits<long double>::digits10;\n+      char* __cs = static_cast<char*>(__builtin_alloca(sizeof(char) * __n));\n+      _CharT* __ws = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+      int __len = sprintf(__cs, \"%.01Lf\", __units);\n+      __ct.widen(__cs, __cs + __len, __ws);\n+      string_type __digits(__ws);\n+      return this->do_put(__s, __intl, __io, __fill, __digits); \n+    }\n+\n+  template<typename _CharT, typename _OutIter>\n+    money_put<_CharT, _OutIter>::iter_type\n+    money_put<_CharT, _OutIter>::do_put(iter_type __s, bool __intl, \n+\t\t \t\t\tios_base& __io, char_type __fill,\n+\t\t\t\t\tconst string_type& __digits) const\n+    { \n+      typedef typename string_type::size_type size_type;\n+\n+      locale __loc = __io.getloc();\n+      size_type __width = static_cast<size_type>(__io.width());\n+\n+      // These contortions are quite unfortunate.\n+      typedef moneypunct<_CharT, true> __money_true;\n+      typedef moneypunct<_CharT, false> __money_false;\n+      const __money_true& __mpt = use_facet<__money_true>(__loc); \n+      const __money_false& __mpf = use_facet<__money_false>(__loc); \n+      const ctype<_CharT>& __ct = use_facet<ctype<_CharT> >(__loc); \n+\n+      // Determine if negative or positive formats are to be used, and\n+      // discard leading negative_sign if it is present.\n+      const char_type* __beg = __digits.data();\n+      const char_type* __end = __beg + __digits.size();\n+      money_base::pattern __p;\n+      string_type __sign;\n+      if (*__beg != __ct.widen('-'))\n+\t{\n+\t  __p = __intl ? __mpt.pos_format() : __mpf.pos_format();\n+\t  __sign =__intl ? __mpt.positive_sign() : __mpf.positive_sign();\n+\t}\n+      else\n+\t{\n+\t  __p = __intl ? __mpt.neg_format() : __mpf.neg_format();\n+\t  __sign =__intl ? __mpt.negative_sign() : __mpf.negative_sign();\n+\t  ++__beg;\n+\t}\n+      \n+      // Look for valid numbers in the current ctype facet within input digits.\n+      __end = __ct.scan_not(ctype_base::digit, __beg, __end);\n+      if (__beg != __end)\n+\t{\n+\t  // Assume valid input, and attempt to format.\n+\t  // Break down input numbers into base components, as follows:\n+\t  //   final_value = grouped units + (decimal point) + (digits)\n+\t  string_type __res;\n+\t  string_type __value;\n+\t  string_type __symbol = __intl \n+\t    \t\t\t ? __mpt.curr_symbol() : __mpf.curr_symbol();\n+\n+\t  // Deal with decimal point, decimal digits.\n+\t  int __frac = __intl ? __mpt.frac_digits() : __mpf.frac_digits();\n+\t  if (__frac > 0)\n+\t    {\n+\t      char_type __d = __intl \n+\t\t\t      ? __mpt.decimal_point() : __mpf.decimal_point();\n+\t      if (__end - __beg >= __frac)\n+\t\t{\n+\t\t  __value = string_type(__end - __frac, __end);\n+\t\t  __value.insert(__value.begin(), __d);\n+\t\t  __end -= __frac;\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  // Have to pad zeros in the decimal position.\n+\t\t  __value = string_type(__beg, __end);\n+\t\t  int __paddec = __frac - (__end - __beg);\n+\t\t  char_type __zero = __ct.widen('0');\n+\t\t  __value.insert(__value.begin(), __paddec, __zero);\n+\t\t  __value.insert(__value.begin(), __d);\n+\t\t  __beg = __end;\n+\t\t}\n+\t    }\n+\n+\t  // Add thousands separators to non-decimal digits, per\n+\t  // grouping rules.\n+\t  if (__beg != __end)\n+\t    {\n+\t      string __grouping = __intl ? __mpt.grouping() : __mpf.grouping();\n+\t      if (__grouping.size())\n+\t\t{\n+\t\t  char_type __sep = __intl ? __mpt.thousands_sep() \n+\t\t    \t\t\t   : __mpf.thousands_sep();\n+\t\t  const char* __gbeg = __grouping.data();\n+\t\t  const char* __gend = __gbeg + __grouping.size();\n+\t\t  const int __n = numeric_limits<long double>::digits10 * 2;\n+\t\t  _CharT* __s = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+\t\t  _CharT* __s_end = __group_digits(__s, __sep, __gbeg, \n+\t\t\t\t\t\t   __gend, __beg, __end);\n+\t\t  __value.insert(0, __s, __s_end - __s);\n+\t\t}\n+\t      else\n+\t\t__value.insert(0, string_type(__beg, __end));\n+\t    }\n+\n+\t  // Calculate length of resulting string.\n+\t  ios_base::fmtflags __f = __io.flags() & ios_base::adjustfield;\n+\t  size_type __len = __value.size() + __sign.size();\n+\t  __len += (__io.flags() & ios_base::showbase) ? __symbol.size() : 0;\n+\t  bool __testipad = __f == ios_base::internal && __len < __width;\n+\n+\t  // Fit formatted digits into the required pattern.\n+\t  for (int __i = 0; __i < 4; ++__i)\n+\t    {\n+\t      typedef money_base::part part;\n+\t      part __which = static_cast<part>(__p.field[__i]);\n+\t      switch (__which)\n+\t\t{\n+\t\tcase money_base::symbol:\n+\t\t  if (__io.flags() & ios_base::showbase)\n+\t\t    __res += __symbol;\n+\t\t  break;\n+\t\tcase money_base::sign:\t\t    \n+\t\t  // Sign might not exist, or be more than one\n+\t\t  // charater long. In that case, add in the rest\n+\t\t  // below.\n+\t\t  if (__sign.size())\n+\t\t    __res += __sign[0];\n+\t\t  break;\n+\t\tcase money_base::value:\n+\t\t  __res += __value;\n+\t\t  break;\n+\t\tcase money_base::space:\n+\t\t  // At least one space is required, but if internal\n+\t\t  // formatting is required, an arbitrary number of\n+\t\t  // fill spaces will be necessary.\n+\t\t  if (__testipad)\n+\t\t    __res += string_type(__width - __len, __fill);\n+\t\t  else\n+\t\t    __res += __ct.widen(' ');\n+\t\t  break;\n+\t\tcase money_base::none:\n+\t\t  if (__testipad)\n+\t\t    __res += string_type(__width - __len, __fill);\n+\t\t  break;\n+\t\t}\n+\t    }\n+\n+\t  // Special case of multi-part sign parts.\n+\t  if (__sign.size() > 1)\n+\t    __res += string_type(__sign.begin() + 1, __sign.end());\n+\n+\t  // Pad, if still necessary.\n+\t  __len = __res.size();\n+\t  if (__width > __len)\n+\t    {\n+\t      if (__f == ios_base::left)\n+\t\t// After.\n+\t\t__res.append(__width - __len, __fill);\n+\t      else\n+\t\t// Before.\n+\t\t__res.insert(0, string_type(__width - __len, __fill));\n+\t      __len = __width;\n+\t    }\n+\n+\t  // Write resulting, fully-formatted string to output iterator.\n+\t  for (size_type __i = 0; __i < __len; ++__i)\n+\t    __s = __res[__i];\n+\t}\n+      __io.width(0);\n+      return __s; \n+    }\n+\n   // This member function takes an (w)istreambuf_iterator object and\n   // parses it into a generic char array suitable for parsing with\n   // strto[l,ll,f,d]. The thought was to encapsulate the conversion\n@@ -823,20 +1001,20 @@ namespace std\n   // __group_digits inserts \"group separator\" characters into an array\n   // of characters.  It's recursive, one iteration per group.  It moves\n   // the characters in the buffer this way: \"xxxx12345\" -> \"12,345xxx\".\n-  // Call this only with __grouping != __grend.\n+  // Call this only with __gbeg != __gend.\n   template <typename _CharT>\n     _CharT*\n-    __group_digits(_CharT* __s, _CharT __grsep,  char const* __grouping,\n-                    char const* __grend, _CharT const* __first,\n-                    _CharT const* __last)\n+    __group_digits(_CharT* __s, _CharT __sep,  \n+\t\t   const char* __gbeg, const char* __gend, \n+\t\t   const _CharT* __first, const _CharT* __last)\n     {\n-      if (__last - __first > *__grouping)\n+      if (__last - __first > *__gbeg)\n         {\n-          __s = __group_digits(__s,  __grsep,\n-              (__grouping + 1 == __grend ? __grouping : __grouping + 1),\n-              __grend, __first, __last - *__grouping);\n-          __first = __last - *__grouping;\n-          *__s++ = __grsep;\n+          __s = __group_digits(__s,  __sep,\n+\t\t\t       (__gbeg + 1 == __gend ? __gbeg : __gbeg + 1),\n+\t\t\t       __gend, __first, __last - *__gbeg);\n+          __first = __last - *__gbeg;\n+          *__s++ = __sep;\n         }\n       do\n         {\n@@ -849,71 +1027,74 @@ namespace std\n   template <typename _CharT, typename _OutIter, typename _ValueT>\n     _OutIter\n     __output_integer(_OutIter __s, ios_base& __io, _CharT __fill, bool __neg,\n-              _ValueT __v)\n+\t\t     _ValueT __v)\n     {\n-      // Leave room for \"+/-,\" \"0x,\" and commas.\n-      const long _M_room = numeric_limits<_ValueT>::digits10 * 2 + 4;\n-      _CharT __digits[_M_room];\n-      _CharT* __front = __digits + _M_room;\n+      // Leave room for \"+/-,\" \"0x,\" and commas. This size is\n+      // arbitrary, but should work.\n+      const int __n = numeric_limits<_ValueT>::digits10 * 2 + 4;\n+      _CharT* __digits = static_cast<_CharT*>(__builtin_alloca(sizeof(_CharT) * __n));\n+      _CharT* __digits_end = __digits + __n;\n       ios_base::fmtflags __flags = __io.flags();\n       const _Format_cache<_CharT>* __fmt = _Format_cache<_CharT>::_S_get(__io);\n       char const* __table = __fmt->_S_literals + __fmt->_S_digits;\n \n       ios_base::fmtflags __basefield = (__flags & __io.basefield);\n-      _CharT* __sign_end = __front;\n+      _CharT* __sign_end = __digits_end;\n       if (__basefield == ios_base::hex)\n         {\n           if (__flags & ios_base::uppercase)\n             __table += 16;  // use ABCDEF\n           do\n-            *--__front = __table[__v & 15];\n+            *--__digits_end = __table[__v & 15];\n           while ((__v >>= 4) != 0);\n-          __sign_end = __front;\n+          __sign_end = __digits_end;\n           if (__flags & ios_base::showbase)\n             {\n-              *--__front = __fmt->_S_literals[__fmt->_S_x +\n+              *--__digits_end = __fmt->_S_literals[__fmt->_S_x +\n                        ((__flags & ios_base::uppercase) ? 1 : 0)];\n-              *--__front = __table[0];\n+              *--__digits_end = __table[0];\n             }\n         }\n       else if (__basefield == ios_base::oct)\n         {\n           do\n-            *--__front = __table[__v & 7];\n+            *--__digits_end = __table[__v & 7];\n           while ((__v >>= 3) != 0);\n           if (__flags & ios_base::showbase\n-              && static_cast<char>(*__front) != __table[0])\n-            *--__front = __table[0];\n-          __sign_end = __front;\n+              && static_cast<char>(*__digits_end) != __table[0])\n+            *--__digits_end = __table[0];\n+          __sign_end = __digits_end;\n         }\n       else\n         {\n           // NB: This is _lots_ faster than using ldiv.\n           do\n-            *--__front = __table[__v % 10];\n+            *--__digits_end = __table[__v % 10];\n           while ((__v /= 10) != 0);\n-          __sign_end = __front;\n+          __sign_end = __digits_end;\n           // NB: ios_base:hex || ios_base::oct assumed to be unsigned.\n           if (__neg || (__flags & ios_base::showpos))\n-            *--__front = __fmt->_S_literals[__fmt->_S_plus - __neg];\n+            *--__digits_end = __fmt->_S_literals[__fmt->_S_plus - __neg];\n         }\n \n       // XXX should specialize!\n       if (!__fmt->_M_use_grouping && !__io.width())\n-        return copy(__front, __digits + _M_room, __s);\n+        return copy(__digits_end, __digits + __n, __s);\n \n       if (!__fmt->_M_use_grouping)\n         return __pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t     __front, __sign_end, __digits + _M_room);\n+\t\t\t     __digits_end, __sign_end, __digits + __n);\n \n       _CharT* __p = __digits;\n-      while (__front < __sign_end)\n-        *__p++ = *__front++;\n-      const char* __gr = __fmt->_M_grouping.data();\n-      __front = __group_digits(__p, __fmt->_M_thousands_sep, __gr,\n-        __gr + __fmt->_M_grouping.size(), __sign_end, __digits + _M_room);\n+      while (__digits_end < __sign_end)\n+        *__p++ = *__digits_end++;\n+      const char* __gbeg = __fmt->_M_grouping.data();\n+      const char* __gend = __gbeg + __fmt->_M_grouping.size();\n+      __digits_end = __group_digits(__p, __fmt->_M_thousands_sep, \n+\t\t\t\t    __gbeg, __gend,\n+\t\t\t\t    __sign_end, __digits + __n);\n       return __pad_numeric(__s, __flags, __fill, __io.width(0),\n-\t\t\t   __digits, __p, __front);\n+\t\t\t   __digits, __p, __digits_end);\n     }\n \n   template <typename _CharT, typename _OutIter>\n@@ -1276,16 +1457,4 @@ namespace std\n     }\n } // namespace std\n \n-#endif // _CPP_BITS_LOCFACETS_TCC\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n-\n+#endif"}, {"sha": "8a9b7025dde984b789eaba53826e82dfe102005f", "filename": "libstdc++-v3/include/bits/std_iosfwd.h", "status": "modified", "additions": 1, "deletions": 6, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstd_iosfwd.h?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -128,9 +128,4 @@ namespace std\n #endif\n } // namespace std\n \n-#endif\t// _CPP_IOSFWD\n-\n-\n-\n-\n-\n+#endif"}, {"sha": "78464a698073cf52d93e9ee7051409083dca4406", "filename": "libstdc++-v3/src/locale-inst.cc", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale-inst.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -54,21 +54,17 @@ namespace std\n   template class moneypunct<char, true>;\n   template class moneypunct_byname<char, false>;\n   template class moneypunct_byname<char, true>;\n-  template class money_get<char, obuf_iterator>;\n-  template class money_put<char, obuf_iterator>;\n   template class money_get<char, ibuf_iterator>;\n-  template class money_put<char, ibuf_iterator>;\n+  template class money_put<char, obuf_iterator>;\n   template class _Format_cache<char>;\n \n #ifdef _GLIBCPP_USE_WCHAR_T\n   template class moneypunct<wchar_t, false>;\n   template class moneypunct<wchar_t, true>;\n   template class moneypunct_byname<wchar_t, false>;\n   template class moneypunct_byname<wchar_t, true>;\n-  template class money_get<wchar_t, wobuf_iterator>;\n-  template class money_put<wchar_t, wobuf_iterator>;\n   template class money_get<wchar_t, wibuf_iterator>;\n-  template class money_put<wchar_t, wibuf_iterator>;\n+  template class money_put<wchar_t, wobuf_iterator>;\n   template class _Format_cache<wchar_t>;\n #endif\n \n@@ -149,6 +145,12 @@ namespace std\n   template\n     const collate<char>& \n     use_facet<collate<char> >(const locale&);\n+  template\n+    const moneypunct<char, true>& \n+    use_facet<moneypunct<char, true> >(const locale&);\n+  template\n+    const moneypunct<char, false>& \n+    use_facet<moneypunct<char, false> >(const locale&);\n #ifdef _GLIBCPP_USE_WCHAR_T\n   template \n     const num_put<wchar_t, wobuf_iterator>& \n@@ -165,6 +167,12 @@ namespace std\n   template\n     const collate<wchar_t>& \n     use_facet<collate<wchar_t> >(const locale&);\n+  template\n+    const moneypunct<wchar_t, true>& \n+    use_facet<moneypunct<wchar_t, true> >(const locale&);\n+  template\n+    const moneypunct<wchar_t, false>& \n+    use_facet<moneypunct<wchar_t, false> >(const locale&);\n #endif\n \n   // has_facet"}, {"sha": "990e66248e0e879194ebb579e3a15111ded312a4", "filename": "libstdc++-v3/src/locale.cc", "status": "modified", "additions": 0, "deletions": 176, "changes": 176, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocale.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -162,182 +162,6 @@ namespace std\n     0\n   };\n \n-  // Construct and return valid pattern consisting of some combination of:\n-  // space none symbol sign value\n-  money_base::pattern\n-  money_base::_S_construct_pattern(char __preceeds, char __space, char __posn)\n-  { \n-    pattern __ret;\n-\n-    // This insanely complicated routine attempts to construct a valid\n-    // pattern for use with monyepunct. A couple of invariants:\n-\n-    // if (__preceeds) symbol -> value\n-    // else value -> symbol\n-    \n-    // if (__space) space\n-    // else none\n-\n-    // none == never first\n-    // space never first or last\n-\n-    // Any elegant implementations of this are welcome.\n-    switch (__posn)\n-      {\n-      case 1:\n-\t// 1 The sign precedes the value and symbol.\n-\tif (__space)\n-\t  {\n-\t    // Pattern starts with sign.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[1] = symbol;\n-\t\t__ret.field[2] = space;\n-\t\t__ret.field[3] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[1] = value;\n-\t\t__ret.field[2] = space;\n-\t\t__ret.field[3] = symbol;\n-\t      }\n-\t    __ret.field[0] = sign;\n-\t  }\n-\telse\n-\t  {\n-\t    // Pattern starts with sign and ends with none.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[1] = symbol;\n-\t\t__ret.field[2] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[1] = value;\n-\t\t__ret.field[2] = symbol;\n-\t      }\n-\t    __ret.field[0] = sign;\n-\t    __ret.field[3] = none;\n-\t  }\n-\tbreak;\n-      case 2:\n-\t// 2 The sign follows the value and symbol.\n-\tif (__space)\n-\t  {\n-\t    // Pattern either ends with sign.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = symbol;\n-\t\t__ret.field[1] = space;\n-\t\t__ret.field[2] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = space;\n-\t\t__ret.field[2] = symbol;\n-\t      }\n-\t    __ret.field[3] = sign;\n-\t  }\n-\telse\n-\t  {\n-\t    // Pattern ends with sign then none.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = symbol;\n-\t\t__ret.field[1] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = symbol;\n-\t      }\n-\t    __ret.field[2] = sign;\n-\t    __ret.field[3] = none;\n-\t  }\n-\tbreak;\n-      case 3:\n-\t// 3 The sign immediately precedes the symbol.\n-\tif (__space)\n-\t  {\n-\t    // Have space.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = sign;\n-\t\t__ret.field[1] = symbol;\n-\t\t__ret.field[2] = space;\n-\t\t__ret.field[3] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = space;\n-\t\t__ret.field[2] = sign;\n-\t\t__ret.field[3] = symbol;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    // Have none.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = sign;\n-\t\t__ret.field[1] = symbol;\n-\t\t__ret.field[2] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = sign;\n-\t\t__ret.field[2] = symbol;\n-\t      }\n-\t    __ret.field[3] = none;\n-\t  }\n-\tbreak;\n-      case 4:\n-\t// 4 The sign immediately follows the symbol. \n-\tif (__space)\n-\t  {\n-\t    // Have space.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = symbol;\n-\t\t__ret.field[1] = sign;\n-\t\t__ret.field[2] = space;\n-\t\t__ret.field[3] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = space;\n-\t\t__ret.field[2] = symbol;\n-\t\t__ret.field[3] = sign;\n-\t      }\n-\t  }\n-\telse\n-\t  {\n-\t    // Have none.\n-\t    if (__preceeds)\n-\t      {\n-\t\t__ret.field[0] = symbol;\n-\t\t__ret.field[1] = sign;\n-\t\t__ret.field[2] = value;\n-\t      }\n-\t    else\n-\t      {\n-\t\t__ret.field[0] = value;\n-\t\t__ret.field[1] = symbol;\n-\t\t__ret.field[2] = sign;\n-\t      }\n-\t    __ret.field[3] = none;\n-\t  }\n-\tbreak;\n-      default:\n-\t;\n-      }\n-    return __ret;\n-  }\n-\n   locale::~locale() throw()\n   { _M_impl->_M_remove_reference(); }\n "}, {"sha": "f921c2f19a2528d14d0972bae75d8658280fe1c6", "filename": "libstdc++-v3/src/localename.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Fsrc%2Flocalename.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -96,7 +96,7 @@ namespace std\n     _M_init_facet(new std::ctype<char>);\n     _M_init_facet(new codecvt<char, char, mbstate_t>);\n     _M_init_facet(new moneypunct<char, false>(__cloc));\n-    _M_init_facet(new moneypunct<char,true>(__cloc));\n+    _M_init_facet(new moneypunct<char, true>(__cloc));\n     _M_init_facet(new money_get<char>);\n     _M_init_facet(new money_put<char>);\n     _M_init_facet(new numpunct<char>(__cloc));\n@@ -111,7 +111,7 @@ namespace std\n     _M_init_facet(new std::ctype<wchar_t>);\n     _M_init_facet(new codecvt<wchar_t, char, mbstate_t>);\n     _M_init_facet(new moneypunct<wchar_t, false>(__cloc));\n-    _M_init_facet(new moneypunct<wchar_t,true>(__cloc));\n+    _M_init_facet(new moneypunct<wchar_t, true>(__cloc));\n     _M_init_facet(new money_get<wchar_t>);\n     _M_init_facet(new money_put<wchar_t>);\n     _M_init_facet(new numpunct<wchar_t>(__cloc));"}, {"sha": "5495afe87a027742575de06f2263fa3246a50ce9", "filename": "libstdc++-v3/testsuite/22_locale/money_put_members_char.cc", "status": "modified", "additions": 211, "deletions": 13, "changes": 224, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_char.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -21,16 +21,19 @@\n // 22.2.6.2.1 money_put members\n \n #include <locale>\n+#include <sstream>\n #include <testsuite_hooks.h>\n \n // XXX This test is not working for non-glibc locale models.\n // { dg-do run { xfail *-*-* } }\n \n+// test string version\n void test01()\n {\n   using namespace std;\n   typedef money_base::part part;\n   typedef money_base::pattern pattern;\n+  typedef ostreambuf_iterator<char> iterator_type;\n \n   bool test = true;\n   string str;\n@@ -39,35 +42,230 @@ void test01()\n   locale loc_c = locale::classic();\n   str = loc_c.name();\n \n-  locale loc_us(\"en_US\");\n-  str = loc_us.name();\n-  VERIFY( loc_c != loc_us );\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n \n-  locale loc_fr(\"fr_FR\");\n+  locale loc_fr(\"fr_FR@euro\");\n   str = loc_fr.name();\n   VERIFY( loc_c != loc_fr );\n \n   locale loc_de(\"de_DE\");\n   str = loc_de.name();\n   VERIFY( loc_c != loc_de );\n \n-  VERIFY( loc_us != loc_fr );\n-  VERIFY( loc_us != loc_de );\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n   VERIFY( loc_de != loc_fr );\n \n-  // cache the money_put facets\n-  const money_put<char>& monp_c = use_facet<money_put<char> >(loc_c); \n-  const money_put<char>& monp_us = use_facet<money_put<char> >(loc_us); \n-  const money_put<char>& monp_fr = use_facet<money_put<char> >(loc_fr); \n-  const money_put<char>& monp_de = use_facet<money_put<char> >(loc_de); \n+  // cache the moneypunct facets\n+  typedef moneypunct<char, true> __money_true;\n+  typedef moneypunct<char, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n \n   // sanity check the data is correct.\n-  // VERIFY( dp1 != dp2 );\n+  const string empty;\n+\n+  // total EPA budget FY 2002\n+  const string digits1(\"720000000000\");\n+\n+  // est. cost, national missle \"defense\", expressed as a loss in USD 2001\n+  const string digits2(\"-10000000000000\");  \n+\n+  // not valid input\n+  const string digits3(\"-A\"); \n+\n+  // input less than frac_digits\n+  const string digits4(\"-1\");\n+  \n+\n+  ostringstream oss;\n+  oss.imbue(loc_de);\n+  // cache the money_put facet\n+  const money_put<char>& mon_put = use_facet<money_put<char> >(oss.getloc()); \n+\n+\n+  iterator_type os_it01 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  string result1 = oss.str();\n+  VERIFY( result1 == \"7.200.000.000,00 \");\n+\n+  oss.str(empty);\n+  iterator_type os_it02 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  string result2 = oss.str();\n+  VERIFY( result2 == \"7.200.000.000,00 \");\n+\n+  // intl and non-intl versions should be the same.\n+  VERIFY( result1 == result2 );\n+\n+  // now try with showbase, to get currency symbol in format\n+  oss.setf(ios_base::showbase);\n+\n+  oss.str(empty);\n+  iterator_type os_it03 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  string result3 = oss.str();\n+  VERIFY( result3 == \"7.200.000.000,00 DEM \");\n+\n+  oss.str(empty);\n+  iterator_type os_it04 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  string result4 = oss.str();\n+  VERIFY( result4 == \"7.200.000.000,00 DM\");\n+\n+  // intl and non-intl versions should be different.\n+  VERIFY( result3 != result4 );\n+  VERIFY( result3 != result1 );\n+  VERIFY( result4 != result2 );\n+\n+  // test sign of more than one digit, say hong kong.\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  iterator_type os_it05 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  string result5 = oss.str();\n+  VERIFY( result5 == \"HK$7,200,000,000.00\");\n+\n+  oss.str(empty);\n+  iterator_type os_it06 = mon_put.put(oss.rdbuf(), true, oss, '*', digits2);\n+  string result6 = oss.str();\n+  VERIFY( result6 == \"(HKD 100,000,000,000.00)\");\n+\n+  // test one-digit formats without zero padding\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  iterator_type os_it07 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  string result7 = oss.str();\n+  VERIFY( result7 == \"1\");\n+\n+  // test one-digit formats with zero padding, zero frac widths\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  iterator_type os_it08 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  string result8 = oss.str();\n+  VERIFY( result8 == \"(HKD .01)\");\n+\n+  oss.unsetf(ios_base::showbase);\n+\n+  // test bunk input\n+  oss.str(empty);\n+  iterator_type os_it09 = mon_put.put(oss.rdbuf(), true, oss, '*', digits3);\n+  string result9 = oss.str();\n+  VERIFY( result9 == \"\");\n+\n+  // test io.width() > length\n+  // test various fill strategies\n+  oss.imbue(loc_de);\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  iterator_type os_it10 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  string result10 = oss.str();\n+  VERIFY( result10 == \"***************-,01 \");\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::internal);\n+  iterator_type os_it11 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  string result11 = oss.str();\n+  VERIFY( result11 == \"-,01****************\");\n+}\n+\n+// test double/string versions\n+void test02()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+  typedef ostreambuf_iterator<char> iterator_type;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n+\n+  locale loc_fr(\"fr_FR@euro\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<char, true> __money_true;\n+  typedef moneypunct<char, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const string empty;\n+\n+  // total EPA budget FY 2002\n+  const long double  digits1 = 720000000000;\n+\n+  // est. cost, national missle \"defense\", expressed as a loss in USD 2001\n+  const long double digits2 = -10000000000000;  \n+\n+  // input less than frac_digits\n+  const long double digits4 = -1;\n+  \n+\n+  ostringstream oss;\n+  oss.imbue(loc_de);\n+  // cache the money_put facet\n+  const money_put<char>& mon_put = use_facet<money_put<char> >(oss.getloc()); \n+\n+\n+  iterator_type os_it01 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  string result1 = oss.str();\n+  VERIFY( result1 == \"7.200.000.000,00 \");\n+\n+  oss.str(empty);\n+  iterator_type os_it02 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  string result2 = oss.str();\n+  VERIFY( result2 == \"7.200.000.000,00 \");\n+\n+  // intl and non-intl versions should be the same.\n+  VERIFY( result1 == result2 );\n+\n+  // now try with showbase, to get currency symbol in format\n+  oss.setf(ios_base::showbase);\n+\n+  oss.str(empty);\n+ iterator_type os_it03 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  string result3 = oss.str();\n+  VERIFY( result3 == \"7.200.000.000,00 DEM \");\n+\n+  oss.str(empty);\n+  iterator_type os_it04 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  string result4 = oss.str();\n+  VERIFY( result4 == \"7.200.000.000,00 DM\");\n+\n+  // intl and non-intl versions should be different.\n+  VERIFY( result3 != result4 );\n+  VERIFY( result3 != result1 );\n+  VERIFY( result4 != result2 );\n }\n \n int main()\n {\n   test01();\n-\n+  test02();\n   return 0;\n }"}, {"sha": "e3399f3d318ef59f45ebac662a91e5a9c40c4475", "filename": "libstdc++-v3/testsuite/22_locale/money_put_members_wchar_t.cc", "status": "added", "additions": 275, "deletions": 0, "changes": 275, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoney_put_members_wchar_t.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -0,0 +1,275 @@\n+// 2001-09-09 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.2.1 money_put members\n+\n+#include <locale>\n+#include <sstream>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+// test string version\n+void test01()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+  typedef ostreambuf_iterator<wchar_t> iterator_type;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n+\n+  locale loc_fr(\"fr_FR@euro\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<wchar_t, true> __money_true;\n+  typedef moneypunct<wchar_t, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const wstring empty;\n+\n+  // total EPA budget FY 2002\n+  const wstring digits1(L\"720000000000\");\n+\n+  // est. cost, national missle \"defense\", expressed as a loss in USD 2001\n+  const wstring digits2(L\"-10000000000000\");  \n+\n+  // not valid input\n+  const wstring digits3(L\"-A\"); \n+\n+  // input less than frac_digits\n+  const wstring digits4(L\"-1\");\n+  \n+\n+  wostringstream oss;\n+  oss.imbue(loc_de);\n+  // cache the money_put facet\n+  const money_put<wchar_t>& mon_put = use_facet<money_put<wchar_t> >(oss.getloc()); \n+\n+\n+  iterator_type os_it01 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  wstring result1 = oss.str();\n+  VERIFY( result1 == L\"7.200.000.000,00 \");\n+\n+  oss.str(empty);\n+  iterator_type os_it02 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  wstring result2 = oss.str();\n+  VERIFY( result2 == L\"7.200.000.000,00 \");\n+\n+  // intl and non-intl versions should be the same.\n+  VERIFY( result1 == result2 );\n+\n+  // now try with showbase, to get currency symbol in format\n+  oss.setf(ios_base::showbase);\n+\n+  oss.str(empty);\n+  iterator_type os_it03 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  wstring result3 = oss.str();\n+  VERIFY( result3 == L\"7.200.000.000,00 DEM \");\n+\n+  oss.str(empty);\n+  iterator_type os_it04 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  wstring result4 = oss.str();\n+  VERIFY( result4 == L\"7.200.000.000,00 DM\");\n+\n+  // intl and non-intl versions should be different.\n+  VERIFY( result3 != result4 );\n+  VERIFY( result3 != result1 );\n+  VERIFY( result4 != result2 );\n+\n+  // test sign of more than one digit, say hong kong.\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  iterator_type os_it05 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  wstring result5 = oss.str();\n+  VERIFY( result5 == L\"HK$7,200,000,000.00\");\n+\n+  oss.str(empty);\n+  iterator_type os_it06 = mon_put.put(oss.rdbuf(), true, oss, '*', digits2);\n+  wstring result6 = oss.str();\n+  VERIFY( result6 == L\"(HKD 100,000,000,000.00)\");\n+\n+  // test one-digit formats without zero padding\n+  oss.imbue(loc_c);\n+  oss.str(empty);\n+  iterator_type os_it07 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  wstring result7 = oss.str();\n+  VERIFY( result7 == L\"1\");\n+\n+  // test one-digit formats with zero padding, zero frac widths\n+  oss.imbue(loc_hk);\n+  oss.str(empty);\n+  iterator_type os_it08 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  wstring result8 = oss.str();\n+  VERIFY( result8 == L\"(HKD .01)\");\n+\n+  oss.unsetf(ios_base::showbase);\n+\n+  // test bunk input\n+  oss.str(empty);\n+  iterator_type os_it09 = mon_put.put(oss.rdbuf(), true, oss, '*', digits3);\n+  wstring result9 = oss.str();\n+  VERIFY( result9 == L\"\");\n+\n+  // test io.width() > length\n+  // test various fill strategies\n+  oss.imbue(loc_de);\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  iterator_type os_it10 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  wstring result10 = oss.str();\n+  VERIFY( result10 == L\"***************-,01 \");\n+\n+  oss.str(empty);\n+  oss.width(20);\n+  oss.setf(ios_base::internal);\n+  iterator_type os_it11 = mon_put.put(oss.rdbuf(), true, oss, '*', digits4);\n+  wstring result11 = oss.str();\n+  VERIFY( result11 == L\"-,01****************\");\n+}\n+\n+// test double/wstring versions\n+void test02()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+  typedef ostreambuf_iterator<wchar_t> iterator_type;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_hk(\"en_HK\");\n+  str = loc_hk.name();\n+  VERIFY( loc_c != loc_hk );\n+\n+  locale loc_fr(\"fr_FR@euro\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_hk != loc_fr );\n+  VERIFY( loc_hk != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<wchar_t, true> __money_true;\n+  typedef moneypunct<wchar_t, false> __money_false;\n+  const __money_true& monpunct_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monpunct_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monpunct_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monpunct_de_f = use_facet<__money_false>(loc_de); \n+  const __money_true& monpunct_hk_t = use_facet<__money_true>(loc_hk); \n+  const __money_false& monpunct_hk_f = use_facet<__money_false>(loc_hk); \n+\n+  // sanity check the data is correct.\n+  const wstring empty;\n+\n+  // total EPA budget FY 2002\n+  const long double  digits1 = 720000000000;\n+\n+  // est. cost, national missle \"defense\", expressed as a loss in USD 2001\n+  const long double digits2 = -10000000000000;  \n+\n+  // input less than frac_digits\n+  const long double digits4 = -1;\n+  \n+\n+  wostringstream oss;\n+  oss.imbue(loc_de);\n+  // cache the money_put facet\n+  const money_put<wchar_t>& mon_put = use_facet<money_put<wchar_t> >(oss.getloc()); \n+\n+\n+  iterator_type os_it01 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  wstring result1 = oss.str();\n+  VERIFY( result1 == L\"7.200.000.000,00 \");\n+\n+  oss.str(empty);\n+  iterator_type os_it02 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  wstring result2 = oss.str();\n+  VERIFY( result2 == L\"7.200.000.000,00 \");\n+\n+  // intl and non-intl versions should be the same.\n+  VERIFY( result1 == result2 );\n+\n+  // now try with showbase, to get currency symbol in format\n+  oss.setf(ios_base::showbase);\n+\n+  oss.str(empty);\n+ iterator_type os_it03 = mon_put.put(oss.rdbuf(), true, oss, '*', digits1);\n+  wstring result3 = oss.str();\n+  VERIFY( result3 == L\"7.200.000.000,00 DEM \");\n+\n+  oss.str(empty);\n+  iterator_type os_it04 = mon_put.put(oss.rdbuf(), false, oss, '*', digits1);\n+  wstring result4 = oss.str();\n+  VERIFY( result4 == L\"7.200.000.000,00 DM\");\n+\n+  // intl and non-intl versions should be different.\n+  VERIFY( result3 != result4 );\n+  VERIFY( result3 != result1 );\n+  VERIFY( result4 != result2 );\n+}\n+#endif\n+\n+int main()\n+{\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  test01();\n+  test02();\n+#endif\n+  return 0;\n+}"}, {"sha": "4bba75a618b08e14fb6fa353f903bccf3aa8603a", "filename": "libstdc++-v3/testsuite/22_locale/moneypunct.cc", "status": "modified", "additions": 25, "deletions": 4, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -21,11 +21,25 @@\n // 22.2.6.3  Template class moneypunct\n \n #include <locale>\n+#include <testsuite_hooks.h>\n \n void test01()\n {\n   // Check for required base class.\n-  typedef std::moneypunct<char> test_type;\n+  typedef std::moneypunct<char, true> test_type;\n+  typedef std::locale::facet base_type;\n+  const test_type& obj = std::use_facet<test_type>(std::locale()); \n+  const base_type* base = &obj;\n+  \n+  // Check for required typedefs\n+  typedef test_type::char_type char_type;\n+  typedef test_type::string_type string_type;\n+}\n+\n+void test02()\n+{\n+  // Check for required base class.\n+  typedef std::moneypunct<char, false> test_type;\n   typedef std::locale::facet base_type;\n   const test_type& obj = std::use_facet<test_type>(std::locale()); \n   const base_type* base = &obj;\n@@ -36,17 +50,24 @@ void test01()\n }\n \n // Should be able to instantiate this for other types besides char, wchar_t\n-class gnu_moneypunct: public std::moneypunct<unsigned char> \n+class gnu_moneypunct_t: public std::moneypunct<unsigned char, true> \n { };\n \n-void test02()\n+class gnu_moneypunct_f: public std::moneypunct<unsigned char, false> \n+{ };\n+\n+void test03()\n { \n-  gnu_moneypunct facet01;\n+  gnu_moneypunct_t facet01;\n+  gnu_moneypunct_f facet02;\n+  VERIFY (facet01.intl == true);\n+  VERIFY (facet02.intl == false);\n }\n \n int main()\n {\n   test01();\n   test02();\n+  test03();\n   return 0;\n }"}, {"sha": "cfc91649a8ac11680693201838131c6b73df8bbc", "filename": "libstdc++-v3/testsuite/22_locale/moneypunct_members_char.cc", "status": "modified", "additions": 39, "deletions": 23, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_char.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_char.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_char.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -56,31 +56,47 @@ void test01()\n   VERIFY( loc_de != loc_fr );\n \n   // cache the moneypunct facets\n-  const moneypunct<char>& monp_c = use_facet<moneypunct<char> >(loc_c); \n-  const moneypunct<char>& monp_us = use_facet<moneypunct<char> >(loc_us); \n-  const moneypunct<char>& monp_fr = use_facet<moneypunct<char> >(loc_fr); \n-  const moneypunct<char>& monp_de = use_facet<moneypunct<char> >(loc_de); \n+  typedef moneypunct<char, true> __money_true;\n+  typedef moneypunct<char, false> __money_false;\n+  const __money_true& monp_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monp_us_t = use_facet<__money_true>(loc_us); \n+  const __money_true& monp_fr_t = use_facet<__money_true>(loc_fr); \n+  const __money_true& monp_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monp_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monp_us_f = use_facet<__money_false>(loc_us); \n+  const __money_false& monp_fr_f = use_facet<__money_false>(loc_fr); \n+  const __money_false& monp_de_f = use_facet<__money_false>(loc_de); \n+\n+  // quick sanity check for data.\n+  char q1 = monp_c_t.decimal_point();\n+  char q2 = monp_c_t.thousands_sep();\n+  char q3 = monp_c_f.decimal_point();\n+  char q4 = monp_c_f.thousands_sep();\n+  VERIFY( q1 != char() );\n+  VERIFY( q2 != char() );\n+  VERIFY( q3 != char() );\n+  VERIFY( q4 != char() );\n \n   // sanity check the data is correct.\n-  char dp1 = monp_c.decimal_point();\n-  char th1 = monp_c.thousands_sep();\n-  string g1 = monp_c.grouping();\n-  string cs1 = monp_c.curr_symbol();\n-  string ps1 = monp_c.positive_sign();\n-  string ns1 = monp_c.negative_sign();\n-  int fd1 = monp_c.frac_digits();\n-  pattern pos1 = monp_c.pos_format();\n-  pattern neg1 = monp_c.neg_format();\n-\n-  char dp2 = monp_de.decimal_point();\n-  char th2 = monp_de.thousands_sep();\n-  string g2 = monp_de.grouping();\n-  string cs2 = monp_de.curr_symbol();\n-  string ps2 = monp_de.positive_sign();\n-  string ns2 = monp_de.negative_sign();\n-  int fd2 = monp_de.frac_digits();\n-  pattern pos2 = monp_de.pos_format();\n-  pattern neg2 = monp_de.neg_format();\n+  char dp1 = monp_c_t.decimal_point();\n+  char th1 = monp_c_t.thousands_sep();\n+  string g1 = monp_c_t.grouping();\n+  string cs1 = monp_c_t.curr_symbol();\n+  string ps1 = monp_c_t.positive_sign();\n+  string ns1 = monp_c_t.negative_sign();\n+  int fd1 = monp_c_t.frac_digits();\n+  pattern pos1 = monp_c_t.pos_format();\n+  pattern neg1 = monp_c_t.neg_format();\n+\n+  char dp2 = monp_de_t.decimal_point();\n+  char th2 = monp_de_t.thousands_sep();\n+  string g2 = monp_de_t.grouping();\n+  string cs2 = monp_de_t.curr_symbol();\n+  string ps2 = monp_de_t.positive_sign();\n+  string ns2 = monp_de_t.negative_sign();\n+  int fd2 = monp_de_t.frac_digits();\n+  pattern pos2 = monp_de_t.pos_format();\n+  pattern neg2 = monp_de_t.neg_format();\n \n   VERIFY( dp1 != dp2 );\n   VERIFY( th1 != th2 );"}, {"sha": "01b8d282111ef5b765be45343e9af703f346e14d", "filename": "libstdc++-v3/testsuite/22_locale/moneypunct_members_wchar_t.cc", "status": "added", "additions": 127, "deletions": 0, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_wchar_t.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69971cd850625b888f40dacdb4fc122b57602e9b/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_wchar_t.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F22_locale%2Fmoneypunct_members_wchar_t.cc?ref=69971cd850625b888f40dacdb4fc122b57602e9b", "patch": "@@ -0,0 +1,127 @@\n+// 2001-09-09 Benjamin Kosnik  <bkoz@redhat.com>\n+\n+// Copyright (C) 2001 Free Software Foundation\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 22.2.6.3.1 moneypunct members\n+\n+#include <locale>\n+#include <testsuite_hooks.h>\n+\n+// XXX This test is not working for non-glibc locale models.\n+// { dg-do run { xfail *-*-* } }\n+\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+void test01()\n+{\n+  using namespace std;\n+  typedef money_base::part part;\n+  typedef money_base::pattern pattern;\n+\n+  bool test = true;\n+  string str;\n+\n+  // basic construction\n+  locale loc_c = locale::classic();\n+  str = loc_c.name();\n+\n+  locale loc_us(\"en_US\");\n+  str = loc_us.name();\n+  VERIFY( loc_c != loc_us );\n+\n+  locale loc_fr(\"fr_FR\");\n+  str = loc_fr.name();\n+  VERIFY( loc_c != loc_fr );\n+\n+  locale loc_de(\"de_DE\");\n+  str = loc_de.name();\n+  VERIFY( loc_c != loc_de );\n+\n+  VERIFY( loc_us != loc_fr );\n+  VERIFY( loc_us != loc_de );\n+  VERIFY( loc_de != loc_fr );\n+\n+  // cache the moneypunct facets\n+  typedef moneypunct<wchar_t, true> __money_true;\n+  typedef moneypunct<wchar_t, false> __money_false;\n+  const __money_true& monp_c_t = use_facet<__money_true>(loc_c); \n+  const __money_true& monp_us_t = use_facet<__money_true>(loc_us); \n+  const __money_true& monp_fr_t = use_facet<__money_true>(loc_fr); \n+  const __money_true& monp_de_t = use_facet<__money_true>(loc_de); \n+  const __money_false& monp_c_f = use_facet<__money_false>(loc_c); \n+  const __money_false& monp_us_f = use_facet<__money_false>(loc_us); \n+  const __money_false& monp_fr_f = use_facet<__money_false>(loc_fr); \n+  const __money_false& monp_de_f = use_facet<__money_false>(loc_de); \n+\n+  // quick sanity check for data.\n+  wchar_t q1 = monp_c_t.decimal_point();\n+  wchar_t q2 = monp_c_t.thousands_sep();\n+  wchar_t q3 = monp_c_f.decimal_point();\n+  wchar_t q4 = monp_c_f.thousands_sep();\n+  VERIFY( q1 != wchar_t() );\n+  VERIFY( q2 != wchar_t() );\n+  VERIFY( q3 != wchar_t() );\n+  VERIFY( q4 != wchar_t() );\n+\n+  // sanity check the data is correct.\n+  wchar_t dp1 = monp_c_t.decimal_point();\n+  wchar_t th1 = monp_c_t.thousands_sep();\n+  string g1 = monp_c_t.grouping();\n+  wstring cs1 = monp_c_t.curr_symbol();\n+  wstring ps1 = monp_c_t.positive_sign();\n+  wstring ns1 = monp_c_t.negative_sign();\n+  int fd1 = monp_c_t.frac_digits();\n+  pattern pos1 = monp_c_t.pos_format();\n+  pattern neg1 = monp_c_t.neg_format();\n+\n+  wchar_t dp2 = monp_de_t.decimal_point();\n+  wchar_t th2 = monp_de_t.thousands_sep();\n+  string g2 = monp_de_t.grouping();\n+  wstring cs2 = monp_de_t.curr_symbol();\n+  wstring ps2 = monp_de_t.positive_sign();\n+  wstring ns2 = monp_de_t.negative_sign();\n+  int fd2 = monp_de_t.frac_digits();\n+  pattern pos2 = monp_de_t.pos_format();\n+  pattern neg2 = monp_de_t.neg_format();\n+\n+  VERIFY( dp1 != dp2 );\n+  VERIFY( th1 != th2 );\n+  VERIFY( g1 != g2 );\n+  VERIFY( cs1 != cs2 );\n+  //  VERIFY( ps1 != ps2 );\n+  VERIFY( ns1 != ns2 );\n+  VERIFY( fd1 != fd2 );\n+  VERIFY(static_cast<part>(pos1.field[0]) != static_cast<part>(pos2.field[0]));\n+  VERIFY(static_cast<part>(pos1.field[1]) != static_cast<part>(pos2.field[1]));\n+  VERIFY(static_cast<part>(pos1.field[2]) != static_cast<part>(pos2.field[2]));\n+  VERIFY(static_cast<part>(pos1.field[3]) != static_cast<part>(pos2.field[3]));\n+\n+  VERIFY(static_cast<part>(neg1.field[0]) != static_cast<part>(neg2.field[0]));\n+  VERIFY(static_cast<part>(neg1.field[1]) != static_cast<part>(neg2.field[1]));\n+  VERIFY(static_cast<part>(neg1.field[2]) != static_cast<part>(neg2.field[2]));\n+  VERIFY(static_cast<part>(neg1.field[3]) != static_cast<part>(neg2.field[3]));\n+}\n+#endif\n+\n+int main()\n+{\n+#ifdef _GLIBCPP_USE_WCHAR_T\n+  test01();\n+#endif\n+  return 0;\n+}"}]}