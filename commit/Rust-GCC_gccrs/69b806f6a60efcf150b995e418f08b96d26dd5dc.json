{"sha": "69b806f6a60efcf150b995e418f08b96d26dd5dc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjliODA2ZjZhNjBlZmNmMTUwYjk5NWU0MThmMDhiOTZkMjZkZDVkYw==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2016-08-02T10:13:28Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2016-08-02T10:13:28Z"}, "message": "re PR tree-optimization/34114 (Missed optimization: cannot determine loop termination)\n\n\tPR tree-optimization/34114\n\t* tree-ssa-loop-niter.c (number_of_iterations_ne): Prove no-overflow\n\tinformation for more control IVs.\n\n\tgcc/testsuite\n\tPR tree-optimization/34114\n\t* gcc.dg/tree-ssa/loop-42.c: New test.\n\nFrom-SVN: r238983", "tree": {"sha": "96e4edc600bc2e24873a666089d8219b03b880b5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/96e4edc600bc2e24873a666089d8219b03b880b5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69b806f6a60efcf150b995e418f08b96d26dd5dc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b806f6a60efcf150b995e418f08b96d26dd5dc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69b806f6a60efcf150b995e418f08b96d26dd5dc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69b806f6a60efcf150b995e418f08b96d26dd5dc/comments", "author": null, "committer": null, "parents": [{"sha": "4e2f2da341683a28aa56fae94bc38c2b6341a9ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e2f2da341683a28aa56fae94bc38c2b6341a9ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e2f2da341683a28aa56fae94bc38c2b6341a9ad"}], "stats": {"total": 136, "additions": 121, "deletions": 15}, "files": [{"sha": "7e23ba4da2dae36ca1c677bfe8a4f872fa9b65ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69b806f6a60efcf150b995e418f08b96d26dd5dc", "patch": "@@ -1,3 +1,9 @@\n+2016-08-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/34114\n+\t* tree-ssa-loop-niter.c (number_of_iterations_ne): Prove no-overflow\n+\tinformation for more control IVs.\n+\n 2016-08-02  Bin Cheng  <bin.cheng@arm.com>\n \n \tPR tree-optimization/34114"}, {"sha": "c1a98ec2e98058b645c66c8ffebcc910e3bc213d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=69b806f6a60efcf150b995e418f08b96d26dd5dc", "patch": "@@ -1,3 +1,8 @@\n+2016-08-02  Bin Cheng  <bin.cheng@arm.com>\n+\n+\tPR tree-optimization/34114\n+\t* gcc.dg/tree-ssa/loop-42.c: New test.\n+\n 2016-08-02  Tamar Christina  <tamar.christina@arm.com>\n \n \t* gcc.target/aarch64/vminmaxnm.c: New."}, {"sha": "3f9d91ac287553c91f11524e7a50eb9c4d6699bd", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-42.c", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-42.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-42.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-42.c?ref=69b806f6a60efcf150b995e418f08b96d26dd5dc", "patch": "@@ -0,0 +1,36 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivcanon-details\" } */\n+\n+void foo2 (unsigned int num, int *a)\n+{\n+  unsigned int i, n = (num - (num % 2));\n+\n+  for(i = 0; i != n; i += 2)\n+    a[i] = 0;\n+}\n+\n+void foo3 (unsigned int num, int *a)\n+{\n+  unsigned int i, n = (num - (num % 3));\n+\n+  for(i = 0; i != n; i += 3)\n+    a[i] = 0;\n+}\n+\n+void foo4 (unsigned int num, int *a)\n+{\n+  unsigned int i, n = (num - (num % 4));\n+\n+  for(i = 0; i != n; i += 4)\n+    a[i] = 0;\n+}\n+\n+void foo5 (unsigned int num, int *a)\n+{\n+  unsigned int i, n = (num - (num % 5));\n+\n+  for(i = 0; i != n; i += 5)\n+    a[i] = 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not \"under assumptions \" \"ivcanon\" } } */"}, {"sha": "c740ffa9d6a88a9454094d2369393e616d547d35", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69b806f6a60efcf150b995e418f08b96d26dd5dc/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=69b806f6a60efcf150b995e418f08b96d26dd5dc", "patch": "@@ -964,7 +964,6 @@ number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n   tree niter_type = unsigned_type_for (type);\n   tree s, c, d, bits, assumption, tmp, bound;\n   mpz_t max;\n-  tree e;\n \n   niter->control = *iv;\n   niter->bound = final;\n@@ -999,21 +998,76 @@ number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n \t\t\t\t TYPE_SIGN (niter_type));\n   mpz_clear (max);\n \n-  /* Compute no-overflow information for the control iv.  Note we are\n-     handling NE_EXPR, if iv base equals to final value, the loop exits\n-     immediately, and the iv does not overflow.  */\n-  if (tree_int_cst_sign_bit (iv->step))\n-    e = fold_build2 (GE_EXPR, boolean_type_node, iv->base, final);\n-  else\n-    e = fold_build2 (LE_EXPR, boolean_type_node, iv->base, final);\n-  e = simplify_using_initial_conditions (loop, e);\n-  if (integer_onep (e)\n-      && (integer_onep (s)\n-\t  || (TREE_CODE (c) == INTEGER_CST\n-\t      && TREE_CODE (s) == INTEGER_CST\n-\t      && wi::mod_trunc (c, s, TYPE_SIGN (type)) == 0)))\n+  /* Compute no-overflow information for the control iv.  This can be\n+     proven when below two conditions hold.\n+\n+       1) |FINAL - base| is an exact multiple of step.\n+       2) IV evaluates toward FINAL at beginning, i.e:\n+\n+\t    base <= FINAL ; step > 0\n+\t    base >= FINAL ; step < 0\n+\n+\t  Note the first condition holds, the second can be then relaxed\n+\t  to below condition.\n+\n+\t    base - step < FINAL ; step > 0\n+\t\t\t\t  && base - step doesn't underflow\n+\t    base - step > FINAL ; step < 0\n+\t\t\t\t  && base - step doesn't overflow\n+\n+\t  The relaxation is important because after pass loop-ch, loop\n+\t  with exit condition (IV != FINAL) will usually be guarded by\n+\t  pre-condition (IV.base - IV.step != FINAL).  Please refer to\n+\t  PR34114 as an example.\n+\n+     Also note, for NE_EXPR, base equals to FINAL is a special case, in\n+     which the loop exits immediately, and the iv does not overflow.  */\n+  if (!niter->control.no_overflow\n+      && (integer_onep (s) || multiple_of_p (type, c, s)))\n     {\n-      niter->control.no_overflow = true;\n+      tree t, cond, relaxed_cond = boolean_false_node;\n+\n+      if (tree_int_cst_sign_bit (iv->step))\n+\t{\n+\t  cond = fold_build2 (GE_EXPR, boolean_type_node, iv->base, final);\n+\t  if (TREE_CODE (type) == INTEGER_TYPE)\n+\t    {\n+\t      /* Only when base - step doesn't overflow.  */\n+\t      t = TYPE_MAX_VALUE (type);\n+\t      t = fold_build2 (PLUS_EXPR, type, t, iv->step);\n+\t      t = fold_build2 (GE_EXPR, boolean_type_node, t, iv->base);\n+\t      if (integer_nonzerop (t))\n+\t\t{\n+\t\t  t = fold_build2 (MINUS_EXPR, type, iv->base, iv->step);\n+\t\t  relaxed_cond = fold_build2 (GT_EXPR, boolean_type_node,\n+\t\t\t\t\t      t, final);\n+\t\t}\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  cond = fold_build2 (LE_EXPR, boolean_type_node, iv->base, final);\n+\t  if (TREE_CODE (type) == INTEGER_TYPE)\n+\t    {\n+\t      /* Only when base - step doesn't underflow.  */\n+\t      t = TYPE_MIN_VALUE (type);\n+\t      t = fold_build2 (PLUS_EXPR, type, t, iv->step);\n+\t      t = fold_build2 (LE_EXPR, boolean_type_node, t, iv->base);\n+\t      if (integer_nonzerop (t))\n+\t\t{\n+\t\t  t = fold_build2 (MINUS_EXPR, type, iv->base, iv->step);\n+\t\t  relaxed_cond = fold_build2 (LT_EXPR, boolean_type_node,\n+\t\t\t\t\t      t, final);\n+\t\t}\n+\t    }\n+\t}\n+\n+      t = simplify_using_initial_conditions (loop, cond);\n+      if (!t || !integer_onep (t))\n+\tt = simplify_using_initial_conditions (loop, relaxed_cond);\n+\n+      if (t && integer_onep (t))\n+\tniter->control.no_overflow = true;\n     }\n \n   /* First the trivial cases -- when the step is 1.  */\n@@ -1022,6 +1076,11 @@ number_of_iterations_ne (struct loop *loop, tree type, affine_iv *iv,\n       niter->niter = c;\n       return true;\n     }\n+  if (niter->control.no_overflow && multiple_of_p (type, c, s))\n+    {\n+      niter->niter = fold_build2 (FLOOR_DIV_EXPR, niter_type, c, s);\n+      return true;\n+    }\n \n   /* Let nsd (step, size of mode) = d.  If d does not divide c, the loop\n      is infinite.  Otherwise, the number of iterations is"}]}