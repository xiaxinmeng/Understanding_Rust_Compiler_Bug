{"sha": "8c1dd97000d801abc8c9119304be6bf30c5316c0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGMxZGQ5NzAwMGQ4MDFhYmM4YzkxMTkzMDRiZTZiZjMwYzUzMTZjMA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2017-09-20T05:05:12Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2017-09-20T05:05:12Z"}, "message": "explow.c: Include \"params.h\".\n\n2017-09-18  Jeff Law  <law@redhat.com>\n\n\t* explow.c: Include \"params.h\".\n\t(anti_adjust_stack_and_probe_stack_clash): New function.\n\t(get_stack_check_protect): Likewise.\n\t(compute_stack_clash_protection_loop_data): Likewise.\n\t(emit_stack_clash_protection_loop_start): Likewise.\n\t(emit_stack_clash_protection_loop_end): Likewise.\n\t(allocate_dynamic_stack_space): Use get_stack_check_protect.\n\tUse anti_adjust_stack_and_probe_stack_clash.\n\t* explow.h (compute_stack_clash_protection_loop_data): Prototype.\n\t(emit_stack_clash_protection_loop_start): Likewise.\n\t(emit_stack_clash_protection_loop_end): Likewise.\n\t* rtl.h (get_stack_check_protect): Prototype.\n\t* target.def (stack_clash_protection_final_dynamic_probe): New hook.\n\t* targhooks.c (default_stack_clash_protection_final_dynamic_probe): New.\n\t* targhooks.h (default_stack_clash_protection_final_dynamic_probe):\n\tPrototype.\n\t* doc/tm.texi.in (TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE):\n\tAdd @hook.\n\t* doc/tm.texi: Rebuilt.\n\t* config/aarch64/aarch64.c (aarch64_expand_prologue): Use\n\tget_stack_check_protect.\n\t* config/alpha/alpha.c (alpha_expand_prologue): Likewise.\n\t* config/arm/arm.c (arm_expand_prologue): Likewise.\n\t(arm_frame_pointer_required): Likewise.\n\t* config/i386/i386.c (ix86_expand_prologue): Likewise.\n\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n\t* config/powerpcspe/powerpcspe.c (rs6000_emit_prologue): Likewise.\n\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\n\t(sparc_flat_expand_prologue): Likewise.\n\n\t* gcc.dg/stack-check-3.c: New test.\n\nFrom-SVN: r252995", "tree": {"sha": "64eab318b17653e4aec6415328b0b93032cd88c6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/64eab318b17653e4aec6415328b0b93032cd88c6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8c1dd97000d801abc8c9119304be6bf30c5316c0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1dd97000d801abc8c9119304be6bf30c5316c0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8c1dd97000d801abc8c9119304be6bf30c5316c0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8c1dd97000d801abc8c9119304be6bf30c5316c0/comments", "author": null, "committer": null, "parents": [{"sha": "ee8f15c69e324cdb1fa553ac14f760f799c425e2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ee8f15c69e324cdb1fa553ac14f760f799c425e2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ee8f15c69e324cdb1fa553ac14f760f799c425e2"}], "stats": {"total": 481, "additions": 438, "deletions": 43}, "files": [{"sha": "b80126114053578fe435690d32cde2cee35ff5e5", "filename": "gcc/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -1,5 +1,37 @@\n 2017-09-19  Jeff Law  <law@redhat.com>\n \n+\t* explow.c: Include \"params.h\".\n+\t(anti_adjust_stack_and_probe_stack_clash): New function.\n+\t(get_stack_check_protect): Likewise.\n+\t(compute_stack_clash_protection_loop_data): Likewise.\n+\t(emit_stack_clash_protection_loop_start): Likewise.\n+\t(emit_stack_clash_protection_loop_end): Likewise.\n+\t(allocate_dynamic_stack_space): Use get_stack_check_protect.\n+\tUse anti_adjust_stack_and_probe_stack_clash.\n+\t* explow.h (compute_stack_clash_protection_loop_data): Prototype.\n+\t(emit_stack_clash_protection_loop_start): Likewise.\n+\t(emit_stack_clash_protection_loop_end): Likewise.\n+\t* rtl.h (get_stack_check_protect): Prototype.\n+\t* target.def (stack_clash_protection_final_dynamic_probe): New hook.\n+\t* targhooks.c (default_stack_clash_protection_final_dynamic_probe): New.\n+\t* targhooks.h (default_stack_clash_protection_final_dynamic_probe): \n+\tPrototype.\n+\t* doc/tm.texi.in (TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE):\n+\tAdd @hook.\n+\t* doc/tm.texi: Rebuilt.\n+\t* config/aarch64/aarch64.c (aarch64_expand_prologue): Use\n+\tget_stack_check_protect.\n+\t* config/alpha/alpha.c (alpha_expand_prologue): Likewise.\n+\t* config/arm/arm.c (arm_expand_prologue): Likewise.\n+\t(arm_frame_pointer_required): Likewise.\n+\t* config/i386/i386.c (ix86_expand_prologue): Likewise.\n+\t* config/ia64/ia64.c (ia64_expand_prologue): Likewise.\n+\t* config/mips/mips.c (mips_expand_prologue): Likewise.\n+\t* config/powerpcspe/powerpcspe.c (rs6000_emit_prologue): Likewise.\n+\t* config/rs6000/rs6000.c (rs6000_emit_prologue): Likewise.\n+\t* config/sparc/sparc.c (sparc_expand_prologue): Likewise.\n+\t(sparc_flat_expand_prologue): Likewise.\n+\n \t* common.opt (-fstack-clash-protection): New option.\n \t* flag-types.h (enum stack_check_type): Note difference between\n \t-fstack-check= and -fstack-clash-protection."}, {"sha": "5e26cb70da00689e587a23ecca14b7b0d71ac6f7", "filename": "gcc/config/aarch64/aarch64.c", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Faarch64%2Faarch64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -3666,12 +3666,14 @@ aarch64_expand_prologue (void)\n     {\n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (frame_size > PROBE_INTERVAL && frame_size > STACK_CHECK_PROTECT)\n-\t    aarch64_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t    frame_size - STACK_CHECK_PROTECT);\n+\t  if (frame_size > PROBE_INTERVAL\n+\t      && frame_size > get_stack_check_protect ())\n+\t    aarch64_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t    (frame_size\n+\t\t\t\t\t     - get_stack_check_protect ()));\n \t}\n       else if (frame_size > 0)\n-\taarch64_emit_probe_stack_range (STACK_CHECK_PROTECT, frame_size);\n+\taarch64_emit_probe_stack_range (get_stack_check_protect (), frame_size);\n     }\n \n   aarch64_sub_sp (IP0_REGNUM, initial_adjust, true);"}, {"sha": "a4e8b2b6c3014e86a7ef5ec527a0570bfea60b30", "filename": "gcc/config/alpha/alpha.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Falpha%2Falpha.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Falpha%2Falpha.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Falpha%2Falpha.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -7761,7 +7761,7 @@ alpha_expand_prologue (void)\n \n   probed_size = frame_size;\n   if (flag_stack_check)\n-    probed_size += STACK_CHECK_PROTECT;\n+    probed_size += get_stack_check_protect ();\n \n   if (probed_size <= 32768)\n     {"}, {"sha": "679e838b0aaefa75250c109bf555108096cbaab5", "filename": "gcc/config/arm/arm.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Farm%2Farm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Farm%2Farm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Farm.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -21693,13 +21693,13 @@ arm_expand_prologue (void)\n \n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    arm_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\tsize - STACK_CHECK_PROTECT,\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    arm_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\tsize - get_stack_check_protect (),\n \t\t\t\t\tregno, live_regs_mask);\n \t}\n       else if (size > 0)\n-\tarm_emit_probe_stack_range (STACK_CHECK_PROTECT, size,\n+\tarm_emit_probe_stack_range (get_stack_check_protect (), size,\n \t\t\t\t    regno, live_regs_mask);\n     }\n \n@@ -27886,7 +27886,7 @@ arm_frame_pointer_required (void)\n \t{\n \t  /* We don't have the final size of the frame so adjust.  */\n \t  size += 32 * UNITS_PER_WORD;\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n \t    return true;\n \t}\n       else"}, {"sha": "05b0520759c2893797b1596fbd6e79cf1d4ed027", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 8, "deletions": 6, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -14871,7 +14871,7 @@ ix86_expand_prologue (void)\n \t  HOST_WIDE_INT size = allocate;\n \n \t  if (TARGET_64BIT && size >= HOST_WIDE_INT_C (0x80000000))\n-\t    size = 0x80000000 - STACK_CHECK_PROTECT - 1;\n+\t    size = 0x80000000 - get_stack_check_protect () - 1;\n \n \t  if (TARGET_STACK_PROBE)\n \t    {\n@@ -14881,18 +14881,20 @@ ix86_expand_prologue (void)\n \t\t    ix86_emit_probe_stack_range (0, size);\n \t\t}\n \t      else\n-\t\tix86_emit_probe_stack_range (0, size + STACK_CHECK_PROTECT);\n+\t\tix86_emit_probe_stack_range (0,\n+\t\t\t\t\t     size + get_stack_check_protect ());\n \t    }\n \t  else\n \t    {\n \t      if (crtl->is_leaf && !cfun->calls_alloca)\n \t\t{\n-\t\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t\t    ix86_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t\t size - STACK_CHECK_PROTECT);\n+\t\t  if (size > PROBE_INTERVAL\n+\t\t      && size > get_stack_check_protect ())\n+\t\t    ix86_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t\t size - get_stack_check_protect ());\n \t\t}\n \t      else\n-\t\tix86_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\t\tix86_emit_probe_stack_range (get_stack_check_protect (), size);\n \t    }\n \t}\n     }"}, {"sha": "00ef2159323e05b0b57f5bb34ec8164b3120fe07", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 7, "deletions": 6, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -3502,15 +3502,16 @@ ia64_expand_prologue (void)\n \n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    ia64_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t size - STACK_CHECK_PROTECT,\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    ia64_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t size - get_stack_check_protect (),\n \t\t\t\t\t bs_size);\n-\t  else if (size + bs_size > STACK_CHECK_PROTECT)\n-\t    ia64_emit_probe_stack_range (STACK_CHECK_PROTECT, 0, bs_size);\n+\t  else if (size + bs_size > get_stack_check_protect ())\n+\t    ia64_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t 0, bs_size);\n \t}\n       else if (size + bs_size > 0)\n-\tia64_emit_probe_stack_range (STACK_CHECK_PROTECT, size, bs_size);\n+\tia64_emit_probe_stack_range (get_stack_check_protect (), size, bs_size);\n     }\n \n   if (dump_file) "}, {"sha": "67cee0bb0519bd98394000aabd5ba2e3b9a288b6", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -12084,12 +12084,12 @@ mips_expand_prologue (void)\n     {\n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    mips_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t size - STACK_CHECK_PROTECT);\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    mips_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t size - get_stack_check_protect ());\n \t}\n       else if (size > 0)\n-\tmips_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\tmips_emit_probe_stack_range (get_stack_check_protect (), size);\n     }\n \n   /* Save the registers.  Allocate up to MIPS_MAX_FIRST_STACK_STEP"}, {"sha": "a956729f7065d5085e3d78e61eb7bc9a1a6c578e", "filename": "gcc/config/powerpcspe/powerpcspe.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fpowerpcspe%2Fpowerpcspe.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -29693,12 +29693,12 @@ rs6000_emit_prologue (void)\n \n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t   size - STACK_CHECK_PROTECT);\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    rs6000_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t   size - get_stack_check_protect ());\n \t}\n       else if (size > 0)\n-\trs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\trs6000_emit_probe_stack_range (get_stack_check_protect (), size);\n     }\n \n   if (TARGET_FIX_AND_CONTINUE)"}, {"sha": "e5ef63889b7ab3b59430f1d49b322a6b3bf4deaf", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -26765,12 +26765,12 @@ rs6000_emit_prologue (void)\n \n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    rs6000_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t   size - STACK_CHECK_PROTECT);\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    rs6000_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t   size - get_stack_check_protect ());\n \t}\n       else if (size > 0)\n-\trs6000_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\trs6000_emit_probe_stack_range (get_stack_check_protect (), size);\n     }\n \n   if (TARGET_FIX_AND_CONTINUE)"}, {"sha": "906bd75b560ef48e705ad1bf7587ce492de5ca78", "filename": "gcc/config/sparc/sparc.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fconfig%2Fsparc%2Fsparc.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -5738,12 +5738,12 @@ sparc_expand_prologue (void)\n     {\n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t  size - STACK_CHECK_PROTECT);\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    sparc_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t  size - get_stack_check_protect ());\n \t}\n       else if (size > 0)\n-\tsparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\tsparc_emit_probe_stack_range (get_stack_check_protect (), size);\n     }\n \n   if (size == 0)\n@@ -5849,12 +5849,12 @@ sparc_flat_expand_prologue (void)\n     {\n       if (crtl->is_leaf && !cfun->calls_alloca)\n \t{\n-\t  if (size > PROBE_INTERVAL && size > STACK_CHECK_PROTECT)\n-\t    sparc_emit_probe_stack_range (STACK_CHECK_PROTECT,\n-\t\t\t\t\t  size - STACK_CHECK_PROTECT);\n+\t  if (size > PROBE_INTERVAL && size > get_stack_check_protect ())\n+\t    sparc_emit_probe_stack_range (get_stack_check_protect (),\n+\t\t\t\t\t  size - get_stack_check_protect ());\n \t}\n       else if (size > 0)\n-\tsparc_emit_probe_stack_range (STACK_CHECK_PROTECT, size);\n+\tsparc_emit_probe_stack_range (get_stack_check_protect (), size);\n     }\n \n   if (sparc_save_local_in_regs_p)"}, {"sha": "07ae66a2e619c3a7bd96ddf72ecda685f54abab5", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -3411,6 +3411,10 @@ GCC computed the default from the values of the above macros and you will\n normally not need to override that default.\n @end defmac\n \n+@deftypefn {Target Hook} bool TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE (rtx @var{residual})\n+Some targets make optimistic assumptions about the state of stack probing when they emit their prologues.  On such targets a probe into the end of any dynamically allocated space is likely required for safety against stack clash style attacks.  Define this variable to return nonzero if such a probe is required or zero otherwise.  You need not define this macro if it would always have the value zero.\n+@end deftypefn\n+\n @need 2000\n @node Frame Registers\n @subsection Registers That Address the Stack Frame"}, {"sha": "6a794371342d2981f4626f0ca38e8f2b562d30f6", "filename": "gcc/doc/tm.texi.in", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fdoc%2Ftm.texi.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fdoc%2Ftm.texi.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi.in?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -2847,6 +2847,8 @@ GCC computed the default from the values of the above macros and you will\n normally not need to override that default.\n @end defmac\n \n+@hook TARGET_STACK_CLASH_PROTECTION_FINAL_DYNAMIC_PROBE\n+\n @need 2000\n @node Frame Registers\n @subsection Registers That Address the Stack Frame"}, {"sha": "0f30507d1f583e9ff51917d3c65164c116fa2ad0", "filename": "gcc/explow.c", "status": "modified", "additions": 241, "deletions": 1, "changes": 242, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fexplow.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fexplow.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -40,8 +40,10 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"common/common-target.h\"\n #include \"output.h\"\n+#include \"params.h\"\n \n static rtx break_out_memory_refs (rtx);\n+static void anti_adjust_stack_and_probe_stack_clash (rtx);\n \n \n /* Truncate and perhaps sign-extend C as appropriate for MODE.  */\n@@ -1283,6 +1285,29 @@ get_dynamic_stack_size (rtx *psize, unsigned size_align,\n   *psize = size;\n }\n \n+/* Return the number of bytes to \"protect\" on the stack for -fstack-check.\n+\n+   \"protect\" in the context of -fstack-check means how many bytes we\n+   should always ensure are available on the stack.  More importantly\n+   this is how many bytes are skipped when probing the stack.\n+\n+   On some targets we want to reuse the -fstack-check prologue support\n+   to give a degree of protection against stack clashing style attacks.\n+\n+   In that scenario we do not want to skip bytes before probing as that\n+   would render the stack clash protections useless.\n+\n+   So we never use STACK_CHECK_PROTECT directly.  Instead we indirect though\n+   this helper which allows us to provide different values for\n+   -fstack-check and -fstack-clash-protection.  */\n+HOST_WIDE_INT\n+get_stack_check_protect (void)\n+{\n+  if (flag_stack_clash_protection)\n+    return 0;\n+ return STACK_CHECK_PROTECT;\n+}\n+\n /* Return an rtx representing the address of an area of memory dynamically\n    pushed on the stack.\n \n@@ -1441,7 +1466,7 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n     probe_stack_range (STACK_OLD_CHECK_PROTECT + STACK_CHECK_MAX_FRAME_SIZE,\n \t\t       size);\n   else if (flag_stack_check == STATIC_BUILTIN_STACK_CHECK)\n-    probe_stack_range (STACK_CHECK_PROTECT, size);\n+    probe_stack_range (get_stack_check_protect (), size);\n \n   /* Don't let anti_adjust_stack emit notes.  */\n   suppress_reg_args_size = true;\n@@ -1494,6 +1519,8 @@ allocate_dynamic_stack_space (rtx size, unsigned size_align,\n \n       if (flag_stack_check && STACK_CHECK_MOVING_SP)\n \tanti_adjust_stack_and_probe (size, false);\n+      else if (flag_stack_clash_protection)\n+\tanti_adjust_stack_and_probe_stack_clash (size);\n       else\n \tanti_adjust_stack (size);\n \n@@ -1769,6 +1796,219 @@ probe_stack_range (HOST_WIDE_INT first, rtx size)\n   emit_insn (gen_blockage ());\n }\n \n+/* Compute parameters for stack clash probing a dynamic stack\n+   allocation of SIZE bytes.\n+\n+   We compute ROUNDED_SIZE, LAST_ADDR, RESIDUAL and PROBE_INTERVAL.\n+\n+   Additionally we conditionally dump the type of probing that will\n+   be needed given the values computed.  */\n+\n+void\n+compute_stack_clash_protection_loop_data (rtx *rounded_size, rtx *last_addr,\n+\t\t\t\t\t  rtx *residual,\n+\t\t\t\t\t  HOST_WIDE_INT *probe_interval,\n+\t\t\t\t\t  rtx size)\n+{\n+  /* Round SIZE down to STACK_CLASH_PROTECTION_PROBE_INTERVAL */\n+  *probe_interval\n+    = 1 << PARAM_VALUE (PARAM_STACK_CLASH_PROTECTION_PROBE_INTERVAL);\n+  *rounded_size = simplify_gen_binary (AND, Pmode, size,\n+\t\t\t\t        GEN_INT (-*probe_interval));\n+\n+  /* Compute the value of the stack pointer for the last iteration.\n+     It's just SP + ROUNDED_SIZE.  */\n+  rtx rounded_size_op = force_operand (*rounded_size, NULL_RTX);\n+  *last_addr = force_operand (gen_rtx_fmt_ee (STACK_GROW_OP, Pmode,\n+\t\t\t\t\t      stack_pointer_rtx,\n+\t\t\t\t\t      rounded_size_op),\n+\t\t\t      NULL_RTX);\n+\n+  /* Compute any residuals not allocated by the loop above.  Residuals\n+     are just the ROUNDED_SIZE - SIZE.  */\n+  *residual = simplify_gen_binary (MINUS, Pmode, size, *rounded_size);\n+\n+  /* Dump key information to make writing tests easy.  */\n+  if (dump_file)\n+    {\n+      if (*rounded_size == CONST0_RTX (Pmode))\n+\tfprintf (dump_file,\n+\t\t \"Stack clash skipped dynamic allocation and probing loop.\\n\");\n+      else if (GET_CODE (*rounded_size) == CONST_INT\n+\t       && INTVAL (*rounded_size) <= 4 * *probe_interval)\n+\tfprintf (dump_file,\n+\t\t \"Stack clash dynamic allocation and probing inline.\\n\");\n+      else if (GET_CODE (*rounded_size) == CONST_INT)\n+\tfprintf (dump_file,\n+\t\t \"Stack clash dynamic allocation and probing in \"\n+\t\t \"rotated loop.\\n\");\n+      else\n+\tfprintf (dump_file,\n+\t\t \"Stack clash dynamic allocation and probing in loop.\\n\");\n+\n+      if (*residual != CONST0_RTX (Pmode))\n+\tfprintf (dump_file,\n+\t\t \"Stack clash dynamic allocation and probing residuals.\\n\");\n+      else\n+\tfprintf (dump_file,\n+\t\t \"Stack clash skipped dynamic allocation and \"\n+\t\t \"probing residuals.\\n\");\n+    }\n+}\n+\n+/* Emit the start of an allocate/probe loop for stack\n+   clash protection.\n+\n+   LOOP_LAB and END_LAB are returned for use when we emit the\n+   end of the loop.\n+\n+   LAST addr is the value for SP which stops the loop.  */\n+void\n+emit_stack_clash_protection_probe_loop_start (rtx *loop_lab,\n+\t\t\t\t\t      rtx *end_lab,\n+\t\t\t\t\t      rtx last_addr,\n+\t\t\t\t\t      bool rotated)\n+{\n+  /* Essentially we want to emit any setup code, the top of loop\n+     label and the comparison at the top of the loop.  */\n+  *loop_lab = gen_label_rtx ();\n+  *end_lab = gen_label_rtx ();\n+\n+  emit_label (*loop_lab);\n+  if (!rotated)\n+    emit_cmp_and_jump_insns (stack_pointer_rtx, last_addr, EQ, NULL_RTX,\n+\t\t\t     Pmode, 1, *end_lab);\n+}\n+\n+/* Emit the end of a stack clash probing loop.\n+\n+   This consists of just the jump back to LOOP_LAB and\n+   emitting END_LOOP after the loop.  */\n+\n+void\n+emit_stack_clash_protection_probe_loop_end (rtx loop_lab, rtx end_loop,\n+\t\t\t\t\t    rtx last_addr, bool rotated)\n+{\n+  if (rotated)\n+    emit_cmp_and_jump_insns (stack_pointer_rtx, last_addr, NE, NULL_RTX,\n+\t\t\t     Pmode, 1, loop_lab);\n+  else\n+    emit_jump (loop_lab);\n+\n+  emit_label (end_loop);\n+\n+}\n+\n+/* Adjust the stack pointer by minus SIZE (an rtx for a number of bytes)\n+   while probing it.  This pushes when SIZE is positive.  SIZE need not\n+   be constant.\n+\n+   This is subtly different than anti_adjust_stack_and_probe to try and\n+   prevent stack-clash attacks\n+\n+     1. It must assume no knowledge of the probing state, any allocation\n+\tmust probe.\n+\n+\tConsider the case of a 1 byte alloca in a loop.  If the sum of the\n+\tallocations is large, then this could be used to jump the guard if\n+\tprobes were not emitted.\n+\n+     2. It never skips probes, whereas anti_adjust_stack_and_probe will\n+\tskip probes on the first couple PROBE_INTERVALs on the assumption\n+\tthey're done elsewhere.\n+\n+     3. It only allocates and probes SIZE bytes, it does not need to\n+\tallocate/probe beyond that because this probing style does not\n+\tguarantee signal handling capability if the guard is hit.  */\n+\n+static void\n+anti_adjust_stack_and_probe_stack_clash (rtx size)\n+{\n+  /* First ensure SIZE is Pmode.  */\n+  if (GET_MODE (size) != VOIDmode && GET_MODE (size) != Pmode)\n+    size = convert_to_mode (Pmode, size, 1);\n+\n+  /* We can get here with a constant size on some targets.  */\n+  rtx rounded_size, last_addr, residual;\n+  HOST_WIDE_INT probe_interval;\n+  compute_stack_clash_protection_loop_data (&rounded_size, &last_addr,\n+\t\t\t\t\t    &residual, &probe_interval, size);\n+\n+  if (rounded_size != CONST0_RTX (Pmode))\n+    {\n+      if (INTVAL (rounded_size) <= 4 * probe_interval)\n+\t{\n+\t  for (HOST_WIDE_INT i = 0;\n+\t       i < INTVAL (rounded_size);\n+\t       i += probe_interval)\n+\t    {\n+\t      anti_adjust_stack (GEN_INT (probe_interval));\n+\n+\t      /* The prologue does not probe residuals.  Thus the offset\n+\t\t here to probe just beyond what the prologue had already\n+\t\t allocated.  */\n+\t      emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t       (probe_interval\n+\t\t\t\t\t\t- GET_MODE_SIZE (word_mode))));\n+\t      emit_insn (gen_blockage ());\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  rtx loop_lab, end_loop;\n+\t  bool rotate_loop = GET_CODE (rounded_size) == CONST_INT;\n+\t  emit_stack_clash_protection_probe_loop_start (&loop_lab, &end_loop,\n+\t\t\t\t\t\t\tlast_addr, rotate_loop);\n+\n+\t  anti_adjust_stack (GEN_INT (probe_interval));\n+\n+\t  /* The prologue does not probe residuals.  Thus the offset here\n+\t     to probe just beyond what the prologue had already allocated.  */\n+\t  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   (probe_interval\n+\t\t\t\t\t    - GET_MODE_SIZE (word_mode))));\n+\n+\t  emit_stack_clash_protection_probe_loop_end (loop_lab, end_loop,\n+\t\t\t\t\t\t      last_addr, rotate_loop);\n+\t  emit_insn (gen_blockage ());\n+\t}\n+    }\n+\n+  if (residual != CONST0_RTX (Pmode))\n+    {\n+      rtx x = force_reg (Pmode, plus_constant (Pmode, residual,\n+\t\t\t\t\t       -GET_MODE_SIZE (word_mode)));\n+      anti_adjust_stack (residual);\n+      emit_stack_probe (gen_rtx_PLUS (Pmode, stack_pointer_rtx, x));\n+      emit_insn (gen_blockage ());\n+    }\n+\n+  /* Some targets make optimistic assumptions in their prologues about\n+     how the caller may have probed the stack.  Make sure we honor\n+     those assumptions when needed.  */\n+  if (size != CONST0_RTX (Pmode)\n+      && targetm.stack_clash_protection_final_dynamic_probe (residual))\n+    {\n+      /* Ideally we would just probe at *sp.  However, if SIZE is not\n+\t a compile-time constant, but is zero at runtime, then *sp\n+\t might hold live data.  So probe at *sp if we know that\n+\t an allocation was made, otherwise probe into the red zone\n+\t which is obviously undesirable.  */\n+      if (GET_CODE (size) == CONST_INT)\n+\t{\n+\t  emit_stack_probe (stack_pointer_rtx);\n+\t  emit_insn (gen_blockage ());\n+\t}\n+      else\n+\t{\n+\t  emit_stack_probe (plus_constant (Pmode, stack_pointer_rtx,\n+\t\t\t\t\t   -GET_MODE_SIZE (word_mode)));\n+\t  emit_insn (gen_blockage ());\n+\t}\n+    }\n+}\n+\n+\n /* Adjust the stack pointer by minus SIZE (an rtx for a number of bytes)\n    while probing it.  This pushes when SIZE is positive.  SIZE need not\n    be constant.  If ADJUST_BACK is true, adjust back the stack pointer"}, {"sha": "b85c051e8ce90e1cb396521f387ac176b964f55d", "filename": "gcc/explow.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fexplow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Fexplow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexplow.h?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -69,6 +69,15 @@ extern void anti_adjust_stack (rtx);\n /* Add some bytes to the stack while probing it.  An rtx says how many. */\n extern void anti_adjust_stack_and_probe (rtx, bool);\n \n+/* Support for building allocation/probing loops for stack-clash\n+   protection of dyamically allocated stack space.  */\n+extern void compute_stack_clash_protection_loop_data (rtx *, rtx *, rtx *,\n+\t\t\t\t\t\t      HOST_WIDE_INT *, rtx);\n+extern void emit_stack_clash_protection_probe_loop_start (rtx *, rtx *,\n+\t\t\t\t\t\t\t  rtx, bool);\n+extern void emit_stack_clash_protection_probe_loop_end (rtx, rtx,\n+\t\t\t\t\t\t\trtx, bool);\n+\n /* This enum is used for the following two functions.  */\n enum save_level {SAVE_BLOCK, SAVE_FUNCTION, SAVE_NONLOCAL};\n "}, {"sha": "a63f33e747a5a3d28f2837fd818bb7d938a460fa", "filename": "gcc/rtl.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Frtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Frtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frtl.h?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -2722,6 +2722,7 @@ get_full_set_src_cost (rtx x, machine_mode mode, struct full_rtx_costs *c)\n /* In explow.c */\n extern HOST_WIDE_INT trunc_int_for_mode\t(HOST_WIDE_INT, machine_mode);\n extern rtx plus_constant (machine_mode, rtx, HOST_WIDE_INT, bool = false);\n+extern HOST_WIDE_INT get_stack_check_protect (void);\n \n /* In rtl.c */\n extern rtx rtx_alloc (RTX_CODE CXX_MEM_STAT_INFO);"}, {"sha": "ae22d7a61838e9154241b7ce8261dd16dd1e4886", "filename": "gcc/target.def", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarget.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarget.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.def?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -5735,6 +5735,13 @@ these registers when the target switches are opposed to them.)\",\n  void, (void),\n  hook_void_void)\n \n+DEFHOOK\n+(stack_clash_protection_final_dynamic_probe,\n+ \"Some targets make optimistic assumptions about the state of stack probing when they emit their prologues.  On such targets a probe into the end of any dynamically allocated space is likely required for safety against stack clash style attacks.  Define this variable to return nonzero if such a probe is required or zero otherwise.  You need not define this macro if it would always have the value zero.\",\n+ bool, (rtx residual),\n+ default_stack_clash_protection_final_dynamic_probe)\n+\n+\n /* Functions specific to the C family of frontends.  */\n #undef HOOK_PREFIX\n #define HOOK_PREFIX \"TARGET_C_\""}, {"sha": "d87d6c7f430dd5ea14d6f89694025b1a3431b343", "filename": "gcc/targhooks.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarghooks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarghooks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -2207,4 +2207,10 @@ default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED)\n   return FLT_EVAL_METHOD_PROMOTE_TO_FLOAT;\n }\n \n+HOST_WIDE_INT\n+default_stack_clash_protection_final_dynamic_probe (rtx residual ATTRIBUTE_UNUSED)\n+{\n+  return 0;\n+}\n+\n #include \"gt-targhooks.h\""}, {"sha": "a70992d034ec5c75758f7164f78c0f47db40d8b4", "filename": "gcc/targhooks.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -271,5 +271,6 @@ extern unsigned int default_min_arithmetic_precision (void);\n \n extern enum flt_eval_method\n default_excess_precision (enum excess_precision_type ATTRIBUTE_UNUSED);\n+extern bool default_stack_clash_protection_final_dynamic_probe (rtx);\n \n #endif /* GCC_TARGHOOKS_H */"}, {"sha": "221956496ae10f19b20c44ba371d2be850566980", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -1,5 +1,7 @@\n 2017-09-19  Jeff Law  <law@redhat.com>\n \n+\t* gcc.dg/stack-check-3.c: New test.\n+\n \t* gcc.dg/stack-check-2.c: New test.\n \t* lib/target-supports.exp\n \t(check_effective_target_supports_stack_clash_protection): New function."}, {"sha": "58fb65649ee2fd947d16964d3470f95669176ac7", "filename": "gcc/testsuite/gcc.dg/stack-check-3.c", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8c1dd97000d801abc8c9119304be6bf30c5316c0/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fstack-check-3.c?ref=8c1dd97000d801abc8c9119304be6bf30c5316c0", "patch": "@@ -0,0 +1,86 @@\n+/* The goal here is to ensure that dynamic allocations via vlas or\n+   alloca calls receive probing.\n+\n+   Scanning the RTL or assembly code seems like insanity here as does\n+   checking for particular allocation sizes and probe offsets.  For\n+   now we just verify that there's an allocation + probe loop and\n+   residual allocation + probe for f?.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fstack-clash-protection -fdump-rtl-expand -fno-optimize-sibling-calls --param stack-clash-protection-probe-interval=4096 --param stack-clash-protection-guard-size=4096\" } */\n+/* { dg-require-effective-target supports_stack_clash_protection } */\n+\n+__attribute__((noinline, noclone)) void\n+foo (char *p)\n+{\n+  asm volatile (\"\" : : \"r\" (p) : \"memory\");\n+}\n+\n+/* Simple VLA, no other locals. */\n+__attribute__((noinline, noclone)) void\n+f0 (int x)\n+{\n+  char vla[x];\n+  foo (vla);\n+}\n+\n+/* Simple VLA, small local frame.  */\n+__attribute__((noinline, noclone)) void\n+f1 (int x)\n+{\n+  char locals[128];\n+  char vla[x];\n+  foo (vla);\n+}\n+\n+/* Small constant alloca, no other locals. */\n+__attribute__((noinline, noclone)) void\n+f2 (int x)\n+{\n+  char *vla = __builtin_alloca (128);\n+  foo (vla);\n+}\n+\n+/* Big constant alloca, small local frame.  */\n+__attribute__((noinline, noclone)) void\n+f3 (int x)\n+{\n+  char locals[128];\n+  char *vla = __builtin_alloca (16384);\n+  foo (vla);\n+}\n+\n+/* Big constant alloca, small local frame.  */\n+__attribute__((noinline, noclone)) void\n+f3a (int x)\n+{\n+  char locals[128];\n+  char *vla = __builtin_alloca (32768);\n+  foo (vla);\n+}\n+\n+/* Nonconstant alloca, no other locals. */\n+__attribute__((noinline, noclone)) void\n+f4 (int x)\n+{\n+  char *vla = __builtin_alloca (x);\n+  foo (vla);\n+}\n+\n+/* Nonconstant alloca, small local frame.  */\n+__attribute__((noinline, noclone)) void\n+f5 (int x)\n+{\n+  char locals[128];\n+  char *vla = __builtin_alloca (x);\n+  foo (vla);\n+}\n+\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing residuals\" 7 \"expand\" } } */\n+\n+\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing in loop\" 7 \"expand\" { target callee_realigns_stack } } } */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing in loop\" 4 \"expand\" { target { ! callee_realigns_stack } } } } */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing in rotated loop\" 1 \"expand\" { target { ! callee_realigns_stack } } } } */\n+/* { dg-final { scan-rtl-dump-times \"allocation and probing inline\" 1 \"expand\" { target { ! callee_realigns_stack } } } } */\n+/* { dg-final { scan-rtl-dump-times \"skipped dynamic allocation and probing loop\" 1 \"expand\" { target { ! callee_realigns_stack } } } } */"}]}