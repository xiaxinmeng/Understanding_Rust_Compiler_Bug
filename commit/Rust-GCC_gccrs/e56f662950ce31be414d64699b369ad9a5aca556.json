{"sha": "e56f662950ce31be414d64699b369ad9a5aca556", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTU2ZjY2Mjk1MGNlMzFiZTQxNGQ2NDY5OWIzNjlhZDlhNWFjYTU1Ng==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@redhat.com", "date": "2018-06-22T21:57:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "2018-06-22T21:57:07Z"}, "message": "PR c++/86219 - ICE with erroneous initializer in template.\n\n\t* constexpr.c (fold_non_dependent_expr): Add complain parm.\n\t* call.c, expr.c, init.c, pt.c, semantics.c, typeck.c, typeck2.c:\n\tPass it.\n\t* call.c (build_cxx_call): Don't mess with builtins in a template.\n\t* typeck2.c (store_init_value): If fold_non_dependent_expr didn't\n\tproduce a constant value, go back to the uninstantiated form.\n\nFrom-SVN: r261972", "tree": {"sha": "3c353035edc43d26c7a4f038fcd1cd043b06b82e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3c353035edc43d26c7a4f038fcd1cd043b06b82e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e56f662950ce31be414d64699b369ad9a5aca556", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56f662950ce31be414d64699b369ad9a5aca556", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e56f662950ce31be414d64699b369ad9a5aca556", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e56f662950ce31be414d64699b369ad9a5aca556/comments", "author": {"login": "jicama", "id": 266146, "node_id": "MDQ6VXNlcjI2NjE0Ng==", "avatar_url": "https://avatars.githubusercontent.com/u/266146?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jicama", "html_url": "https://github.com/jicama", "followers_url": "https://api.github.com/users/jicama/followers", "following_url": "https://api.github.com/users/jicama/following{/other_user}", "gists_url": "https://api.github.com/users/jicama/gists{/gist_id}", "starred_url": "https://api.github.com/users/jicama/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jicama/subscriptions", "organizations_url": "https://api.github.com/users/jicama/orgs", "repos_url": "https://api.github.com/users/jicama/repos", "events_url": "https://api.github.com/users/jicama/events{/privacy}", "received_events_url": "https://api.github.com/users/jicama/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e4511ca2e9ecdb51d41b64452398f8e2df575668", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e4511ca2e9ecdb51d41b64452398f8e2df575668", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e4511ca2e9ecdb51d41b64452398f8e2df575668"}], "stats": {"total": 92, "additions": 65, "deletions": 27}, "files": [{"sha": "ae2fd618c198e562db41cd7f04331ad4519405f2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -1,5 +1,13 @@\n 2018-06-22  Jason Merrill  <jason@redhat.com>\n \n+\tPR c++/86219 - ICE with erroneous initializer in template.\n+\t* constexpr.c (fold_non_dependent_expr): Add complain parm.\n+\t* call.c, expr.c, init.c, pt.c, semantics.c, typeck.c, typeck2.c:\n+\tPass it.\n+\t* call.c (build_cxx_call): Don't mess with builtins in a template.\n+\t* typeck2.c (store_init_value): If fold_non_dependent_expr didn't\n+\tproduce a constant value, go back to the uninstantiated form.\n+\n \tAvoid taking the address of something just because it's in parens.\n \t* constexpr.c (same_type_ignoring_tlq_and_bounds_p): New.\n \t(cxx_fold_indirect_ref): Use it."}, {"sha": "aa0e696972ad04620d4b2fb3768c8b757d0ef537", "filename": "gcc/cp/call.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -544,7 +544,7 @@ null_ptr_cst_p (tree t)\n     }\n   else if (CP_INTEGRAL_TYPE_P (type))\n     {\n-      t = fold_non_dependent_expr (t);\n+      t = fold_non_dependent_expr (t, tf_none);\n       STRIP_NOPS (t);\n       if (integer_zerop (t) && !TREE_OVERFLOW (t))\n \treturn true;\n@@ -8796,6 +8796,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n \n   /* Check that arguments to builtin functions match the expectations.  */\n   if (fndecl\n+      && !processing_template_decl\n       && DECL_BUILT_IN (fndecl)\n       && DECL_BUILT_IN_CLASS (fndecl) == BUILT_IN_NORMAL)\n     {\n@@ -8804,7 +8805,7 @@ build_cxx_call (tree fn, int nargs, tree *argarray,\n       /* We need to take care that values to BUILT_IN_NORMAL\n          are reduced.  */\n       for (i = 0; i < nargs; i++)\n-\targarray[i] = fold_non_dependent_expr (argarray[i]);\n+\targarray[i] = maybe_constant_value (argarray[i]);\n \n       if (!check_builtin_function_arguments (EXPR_LOCATION (fn), vNULL, fndecl,\n \t\t\t\t\t     nargs, argarray))"}, {"sha": "365296d6e3be936ac9c08bb885aad78c4cefae4a", "filename": "gcc/cp/constexpr.c", "status": "modified", "additions": 13, "deletions": 5, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fconstexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fconstexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fconstexpr.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -5179,12 +5179,20 @@ clear_cv_and_fold_caches (void)\n /* Like maybe_constant_value but first fully instantiate the argument.\n \n    Note: this is equivalent to instantiate_non_dependent_expr_sfinae\n-   (t, tf_none) followed by maybe_constant_value but is more efficient,\n-   because calls instantiation_dependent_expression_p and\n-   potential_constant_expression at most once.  */\n+   (t, complain) followed by maybe_constant_value but is more efficient,\n+   because it calls instantiation_dependent_expression_p and\n+   potential_constant_expression at most once.\n+\n+   Callers should generally pass their active complain, or if they are in a\n+   non-template, diagnosing context, they can use the default of\n+   tf_warning_or_error.  Callers that might be within a template context, don't\n+   have a complain parameter, and aren't going to remember the result for long\n+   (e.g. null_ptr_cst_p), can pass tf_none and deal with error_mark_node\n+   appropriately.  */\n \n tree\n-fold_non_dependent_expr (tree t)\n+fold_non_dependent_expr (tree t,\n+\t\t\t tsubst_flags_t complain /* = tf_warning_or_error */)\n {\n   if (t == NULL_TREE)\n     return NULL_TREE;\n@@ -5201,7 +5209,7 @@ fold_non_dependent_expr (tree t)\n       if (is_nondependent_constant_expression (t))\n \t{\n \t  processing_template_decl_sentinel s;\n-\t  t = instantiate_non_dependent_expr_internal (t, tf_none);\n+\t  t = instantiate_non_dependent_expr_internal (t, complain);\n \n \t  if (type_unknown_p (t)\n \t      || BRACE_ENCLOSED_INITIALIZER_P (t))"}, {"sha": "284b44343d39369c0a56aa241af2635377619630", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -7534,7 +7534,7 @@ extern tree cxx_constant_value\t\t\t(tree, tree = NULL_TREE);\n extern tree cxx_constant_init\t\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_value\t\t(tree, tree = NULL_TREE);\n extern tree maybe_constant_init\t\t\t(tree, tree = NULL_TREE);\n-extern tree fold_non_dependent_expr\t\t(tree);\n+extern tree fold_non_dependent_expr\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern tree fold_simple\t\t\t\t(tree);\n extern bool is_sub_constant_expr                (tree);\n extern bool reduced_constant_expression_p       (tree);"}, {"sha": "93477bcd12f1409ba8c85ddf86e064d340654ee9", "filename": "gcc/cp/expr.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fexpr.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -353,7 +353,13 @@ fold_for_warn (tree x)\n   /* It's not generally safe to fully fold inside of a template, so\n      call fold_non_dependent_expr instead.  */\n   if (processing_template_decl)\n-    return fold_non_dependent_expr (x);\n+    {\n+      tree f = fold_non_dependent_expr (x, tf_none);\n+      if (f == error_mark_node)\n+\treturn x;\n+      else\n+\treturn f;\n+    }\n \n   return c_fully_fold (x, /*for_init*/false, /*maybe_constp*/NULL);\n }"}, {"sha": "76ce0b829dd2e36c4b1c918e8342cac988c7ae90", "filename": "gcc/cp/init.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -2931,7 +2931,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n \n   /* Lots of logic below depends on whether we have a constant number of\n      elements, so go ahead and fold it now.  */\n-  const_tree cst_outer_nelts = fold_non_dependent_expr (outer_nelts);\n+  const_tree cst_outer_nelts = fold_non_dependent_expr (outer_nelts, complain);\n \n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n@@ -3731,7 +3731,7 @@ build_new (vec<tree, va_gc> **placement, tree type, tree nelts,\n       /* Try to determine the constant value only for the purposes\n \t of the diagnostic below but continue to use the original\n \t value and handle const folding later.  */\n-      const_tree cst_nelts = fold_non_dependent_expr (nelts);\n+      const_tree cst_nelts = fold_non_dependent_expr (nelts, complain);\n \n       /* The expression in a noptr-new-declarator is erroneous if it's of\n \t non-class type and its value before converting to std::size_t is"}, {"sha": "e1e2f0152c112c6025b167d5afb2a464aea77392", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -16863,7 +16863,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t/* Don't instantiate the THEN_CLAUSE. */;\n       else\n \t{\n-\t  bool inhibit = integer_zerop (fold_non_dependent_expr (tmp));\n+\t  tree folded = fold_non_dependent_expr (tmp, complain);\n+\t  bool inhibit = integer_zerop (folded);\n \t  if (inhibit)\n \t    ++c_inhibit_evaluation_warnings;\n \t  RECUR (THEN_CLAUSE (t));\n@@ -16876,7 +16877,8 @@ tsubst_expr (tree t, tree args, tsubst_flags_t complain, tree in_decl,\n \t/* Don't instantiate the ELSE_CLAUSE. */;\n       else if (ELSE_CLAUSE (t))\n \t{\n-\t  bool inhibit = integer_nonzerop (fold_non_dependent_expr (tmp));\n+\t  tree folded = fold_non_dependent_expr (tmp, complain);\n+\t  bool inhibit = integer_nonzerop (folded);\n \t  begin_else_clause (stmt);\n \t  if (inhibit)\n \t    ++c_inhibit_evaluation_warnings;\n@@ -18517,7 +18519,7 @@ tsubst_copy_and_build (tree t,\n       {\n \ttree cond = RECUR (TREE_OPERAND (t, 0));\n \tcond = mark_rvalue_use (cond);\n-\ttree folded_cond = fold_non_dependent_expr (cond);\n+\ttree folded_cond = fold_non_dependent_expr (cond, complain);\n \ttree exp1, exp2;\n \n \tif (TREE_CODE (folded_cond) == INTEGER_CST)\n@@ -22082,7 +22084,7 @@ unify (tree tparms, tree targs, tree parm, tree arg, int strict,\n \t corresponding parameter is type-dependent.  Make any necessary\n \t adjustments based on whether arg is a reference.  */\n       if (CONSTANT_CLASS_P (arg))\n-\tparm = fold_non_dependent_expr (parm);\n+\tparm = fold_non_dependent_expr (parm, complain);\n       else if (REFERENCE_REF_P (arg))\n \t{\n \t  tree sub = TREE_OPERAND (arg, 0);\n@@ -25849,7 +25851,7 @@ build_non_dependent_expr (tree expr)\n       /* Don't do this during concept expansion either and for\n          the same reason.  */\n       && !expanding_concept ())\n-    fold_non_dependent_expr (expr);\n+    fold_non_dependent_expr (expr, tf_none);\n \n   STRIP_ANY_LOCATION_WRAPPER (expr);\n "}, {"sha": "c779137da456f07ad5cdd6498b098b6f9fae9f62", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -8676,7 +8676,7 @@ finish_static_assert (tree condition, tree message, location_t location,\n   /* Fold the expression and convert it to a boolean value. */\n   condition = perform_implicit_conversion_flags (boolean_type_node, condition,\n \t\t\t\t\t\t complain, LOOKUP_NORMAL);\n-  condition = fold_non_dependent_expr (condition);\n+  condition = fold_non_dependent_expr (condition, complain);\n \n   if (TREE_CODE (condition) == INTEGER_CST && !integer_zerop (condition))\n     /* Do nothing; the condition is satisfied. */"}, {"sha": "3a4f1cdf479284ed6dc72adf4a8a1a489d666a89", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -4163,7 +4163,7 @@ warn_for_null_address (location_t location, tree op, tsubst_flags_t complain)\n       || TREE_NO_WARNING (op))\n     return;\n \n-  tree cop = fold_non_dependent_expr (op);\n+  tree cop = fold_non_dependent_expr (op, complain);\n \n   if (TREE_CODE (cop) == ADDR_EXPR\n       && decl_with_nonnull_addr_p (TREE_OPERAND (cop, 0))\n@@ -4480,7 +4480,7 @@ cp_build_binary_op (location_t location,\n \t      || code1 == COMPLEX_TYPE || code1 == VECTOR_TYPE))\n \t{\n \t  enum tree_code tcode0 = code0, tcode1 = code1;\n-\t  tree cop1 = fold_non_dependent_expr (op1);\n+\t  tree cop1 = fold_non_dependent_expr (op1, complain);\n \t  doing_div_or_mod = true;\n \t  warn_for_div_by_zero (location, cop1);\n \n@@ -4519,7 +4519,7 @@ cp_build_binary_op (location_t location,\n     case TRUNC_MOD_EXPR:\n     case FLOOR_MOD_EXPR:\n       {\n-\ttree cop1 = fold_non_dependent_expr (op1);\n+\ttree cop1 = fold_non_dependent_expr (op1, complain);\n \tdoing_div_or_mod = true;\n \twarn_for_div_by_zero (location, cop1);\n       }\n@@ -4614,7 +4614,7 @@ cp_build_binary_op (location_t location,\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  tree const_op1 = fold_non_dependent_expr (op1);\n+\t  tree const_op1 = fold_non_dependent_expr (op1, complain);\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n@@ -4660,10 +4660,10 @@ cp_build_binary_op (location_t location,\n \t}\n       else if (code0 == INTEGER_TYPE && code1 == INTEGER_TYPE)\n \t{\n-\t  tree const_op0 = fold_non_dependent_expr (op0);\n+\t  tree const_op0 = fold_non_dependent_expr (op0, complain);\n \t  if (TREE_CODE (const_op0) != INTEGER_CST)\n \t    const_op0 = op0;\n-\t  tree const_op1 = fold_non_dependent_expr (op1);\n+\t  tree const_op1 = fold_non_dependent_expr (op1, complain);\n \t  if (TREE_CODE (const_op1) != INTEGER_CST)\n \t    const_op1 = op1;\n \t  result_type = type0;\n@@ -5370,8 +5370,8 @@ cp_build_binary_op (location_t location,\n       /* OP0 and/or OP1 might have side-effects.  */\n       op0 = cp_save_expr (op0);\n       op1 = cp_save_expr (op1);\n-      op0 = fold_non_dependent_expr (op0);\n-      op1 = fold_non_dependent_expr (op1);\n+      op0 = fold_non_dependent_expr (op0, complain);\n+      op1 = fold_non_dependent_expr (op1, complain);\n       if (doing_div_or_mod\n \t  && sanitize_flags_p (SANITIZE_DIVIDE | SANITIZE_FLOAT_DIVIDE))\n \t{"}, {"sha": "43e236de41c1d7deaa14bc13571bb52d35bad71d", "filename": "gcc/cp/typeck2.c", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Ftypeck2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Fcp%2Ftypeck2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck2.c?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -822,6 +822,7 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n   if (decl_maybe_constant_var_p (decl) || TREE_STATIC (decl))\n     {\n       bool const_init;\n+      tree oldval = value;\n       value = fold_non_dependent_expr (value);\n       if (DECL_DECLARED_CONSTEXPR_P (decl)\n \t  || (DECL_IN_AGGR_P (decl)\n@@ -847,6 +848,8 @@ store_init_value (tree decl, tree init, vec<tree, va_gc>** cleanups, int flags)\n       /* FIXME setting TREE_CONSTANT on refs breaks the back end.  */\n       if (!TYPE_REF_P (type))\n \tTREE_CONSTANT (decl) = const_init && decl_maybe_constant_var_p (decl);\n+      if (!const_init)\n+\tvalue = oldval;\n     }\n   value = cp_fully_fold (value);\n \n@@ -899,7 +902,7 @@ check_narrowing (tree type, tree init, tsubst_flags_t complain)\n       return ok;\n     }\n \n-  init = fold_non_dependent_expr (init);\n+  init = fold_non_dependent_expr (init, complain);\n \n   if (TREE_CODE (type) == INTEGER_TYPE\n       && TREE_CODE (ftype) == REAL_TYPE)\n@@ -1254,7 +1257,7 @@ massage_init_elt (tree type, tree init, int nested, tsubst_flags_t complain)\n     init = TARGET_EXPR_INITIAL (init);\n   /* When we defer constant folding within a statement, we may want to\n      defer this folding as well.  */\n-  tree t = fold_non_dependent_expr (init);\n+  tree t = fold_non_dependent_expr (init, complain);\n   t = maybe_constant_init (t);\n   if (TREE_CONSTANT (t))\n     init = t;"}, {"sha": "2f61c11356448a562bade2500e9ac9676e7a8f89", "filename": "gcc/testsuite/g++.dg/template/conv15.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e56f662950ce31be414d64699b369ad9a5aca556/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fconv15.C?ref=e56f662950ce31be414d64699b369ad9a5aca556", "patch": "@@ -0,0 +1,10 @@\n+// PR c++/86219\n+\n+template <int a> struct t;\n+template <int a>\n+void f ()\n+{\n+   const int b = \"\";\t\t// { dg-error \"conversion\" }\n+   t<b>::c;\t\t\t// { dg-error \"constant\" }\n+   // { dg-prune-output \"template argument 1 is invalid\" }\n+}"}]}