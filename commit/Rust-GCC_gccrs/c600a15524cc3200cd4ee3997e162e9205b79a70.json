{"sha": "c600a15524cc3200cd4ee3997e162e9205b79a70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzYwMGExNTUyNGNjMzIwMGNkNGVlMzk5N2UxNjJlOTIwNWI3OWE3MA==", "commit": {"author": {"name": "Adam Nemet", "email": "anemet@caviumnetworks.com", "date": "2009-07-01T21:22:28Z"}, "committer": {"name": "Adam Nemet", "email": "nemet@gcc.gnu.org", "date": "2009-07-01T21:22:28Z"}, "message": "revert: expmed.c (store_bit_field_1): Properly truncate the paradoxical subreg of op0 to the original op0.\n\n\tRevert:\n\t2009-01-11  Adam Nemet  <anemet@caviumnetworks.com>\n\t* expmed.c (store_bit_field_1): Properly truncate the paradoxical\n\tsubreg of op0 to the original op0.\n\n\t* expmed.c (store_bit_field_1): Use a temporary as the destination\n\tinstead of a paradoxical subreg when we need to truncate the result.\n\nFrom-SVN: r149153", "tree": {"sha": "f22fa7b6d9b6ffed269294835667cdcee38cb8ef", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f22fa7b6d9b6ffed269294835667cdcee38cb8ef"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c600a15524cc3200cd4ee3997e162e9205b79a70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c600a15524cc3200cd4ee3997e162e9205b79a70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c600a15524cc3200cd4ee3997e162e9205b79a70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c600a15524cc3200cd4ee3997e162e9205b79a70/comments", "author": null, "committer": null, "parents": [{"sha": "bf92f919e997d8c7da797723fa46c56bcc19baa8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bf92f919e997d8c7da797723fa46c56bcc19baa8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bf92f919e997d8c7da797723fa46c56bcc19baa8"}], "stats": {"total": 39, "additions": 30, "deletions": 9}, "files": [{"sha": "b1273fbf19236f9397ae07cacf7193048e91db58", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600a15524cc3200cd4ee3997e162e9205b79a70/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600a15524cc3200cd4ee3997e162e9205b79a70/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=c600a15524cc3200cd4ee3997e162e9205b79a70", "patch": "@@ -1,3 +1,13 @@\n+2009-07-01  Adam Nemet  <anemet@caviumnetworks.com>\n+\n+\tRevert:\n+\t2009-01-11  Adam Nemet  <anemet@caviumnetworks.com>\n+\t* expmed.c (store_bit_field_1): Properly truncate the paradoxical\n+\tsubreg of op0 to the original op0.\n+\n+\t* expmed.c (store_bit_field_1): Use a temporary as the destination\n+\tinstead of a paradoxical subreg when we need to truncate the result.\n+\n 2009-07-01  DJ Delorie  <dj@redhat.com>\n \n \t* config/mep/mep-ivc2.cpu (cmov, cmovc, cmovh): Add intrinsic names to VLIW variants."}, {"sha": "c54053768086fd5cc4324e95b231b45e8c9e56fd", "filename": "gcc/expmed.c", "status": "modified", "additions": 20, "deletions": 9, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c600a15524cc3200cd4ee3997e162e9205b79a70/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c600a15524cc3200cd4ee3997e162e9205b79a70/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=c600a15524cc3200cd4ee3997e162e9205b79a70", "patch": "@@ -685,6 +685,7 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       rtx xop0 = op0;\n       rtx last = get_last_insn ();\n       rtx pat;\n+      bool copy_back = false;\n \n       /* Add OFFSET into OP0's address.  */\n       if (MEM_P (xop0))\n@@ -699,6 +700,23 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n       if (REG_P (xop0) && GET_MODE (xop0) != op_mode)\n \txop0 = gen_rtx_SUBREG (op_mode, xop0, 0);\n \n+      /* If the destination is a paradoxical subreg such that we need a\n+\t truncate to the inner mode, perform the insertion on a temporary and\n+\t truncate the result to the original destination.  Note that we can't\n+\t just truncate the paradoxical subreg as (truncate:N (subreg:W (reg:N\n+\t X) 0)) is (reg:N X).  */\n+      if (GET_CODE (xop0) == SUBREG\n+\t  && REG_P (SUBREG_REG (xop0))\n+\t  && (!TRULY_NOOP_TRUNCATION\n+\t      (GET_MODE_BITSIZE (GET_MODE (SUBREG_REG (xop0))),\n+\t       GET_MODE_BITSIZE (op_mode))))\n+\t{\n+\t  rtx tem = gen_reg_rtx (op_mode);\n+\t  emit_move_insn (tem, xop0);\n+\t  xop0 = tem;\n+\t  copy_back = true;\n+\t}\n+\n       /* On big-endian machines, we count bits from the most significant.\n \t If the bit field insn does not, we must invert.  */\n \n@@ -758,15 +776,8 @@ store_bit_field_1 (rtx str_rtx, unsigned HOST_WIDE_INT bitsize,\n \t{\n \t  emit_insn (pat);\n \n-\t  /* If the mode of the insertion is wider than the mode of the\n-\t     target register we created a paradoxical subreg for the\n-\t     target.  Truncate the paradoxical subreg of the target to\n-\t     itself properly.  */\n-\t  if (!TRULY_NOOP_TRUNCATION (GET_MODE_BITSIZE (GET_MODE (op0)),\n-\t\t\t\t      GET_MODE_BITSIZE (op_mode))\n-\t      && (REG_P (xop0)\n-\t\t  || GET_CODE (xop0) == SUBREG))\n-\t      convert_move (op0, xop0, true);\n+\t  if (copy_back)\n+\t    convert_move (op0, xop0, true);\n \t  return true;\n \t}\n       delete_insns_since (last);"}]}