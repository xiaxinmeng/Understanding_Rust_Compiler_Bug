{"sha": "9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OWY2YWViODVlZTg3YzZiNGU1ODBiNmI3MWUyNmNiZTk5ZTFkYWI3MA==", "commit": {"author": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-01T08:56:32Z"}, "committer": {"name": "Uros Bizjak", "email": "ubizjak@gmail.com", "date": "2021-07-01T09:19:28Z"}, "message": "i386: Add integer nabs instructions [PR101044]\n\nThe patch adds integer nabs \"(NEG (ABS (...)))\" instructions, adds STV\nconversion and adjusts STV cost calculations accordingly.  When CMOV\ninstruction is used to implement abs, the sign is determined from the\npreceeding operand negation, and CMOVS is used to select between\nnegated and non-negated value.\n\nTo implement nabs, just reverse the condition and emit CMOVNS instead.\n\nThe STV costs are adjusted for inherent NOT of nabs insn. V2DI NOT is\nsomehow costly operation, since it is implemented as a load of zero,\nfollowed by a SUB insn. OTOH, integer nabs with inherent NOT is relatively\ncheap, so some STV chains became less profitable for conversion.\n\nThe patch rewrites operand scanner in compute_convert_gain to a switch\nand reorders case instances in general_scalar_to_vector_candidate_p\nto benefit from fallthroughs, and to remove special processing of\nandnot in the later case.\n\ngcc/\n\n2021-07-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\n\tPR target/101044\n\t* config/i386/i386.md (*nabs<dwi>2_doubleword):\n\tNew insn_and_split pattern.\n\t(*nabs<dwi>2_1): Ditto.\n\t* config/i386/i386-features.c\n\t(general_scalar_chain::compute_convert_gain):\n\tHandle (NEG (ABS (...))) RTX.  Rewrite src code\n\tscanner as switch statement.\n\t(general_scalar_chain::convert_insn):\n\tHandle (NEG (ABS (...))) RTX.\n\t(general_scalar_to_vector_candidate_p):\n\tDetect  (NEG (ABS (...))) RTX.  Reorder case statements\n\tfor (AND (NOT (...) ...)) fallthrough.\n\ngcc/testsuite/\n\n2021-07-01  Uro\u0161 Bizjak  <ubizjak@gmail.com>\n\n\tPR target/101044\n\t* gcc.target/i386/pr101044.c: New test.", "tree": {"sha": "eb44f095de9f8f4ad52c769852078ea2fe1a089e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/eb44f095de9f8f4ad52c769852078ea2fe1a089e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/comments", "author": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ubizjak", "id": 55479990, "node_id": "MDQ6VXNlcjU1NDc5OTkw", "avatar_url": "https://avatars.githubusercontent.com/u/55479990?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ubizjak", "html_url": "https://github.com/ubizjak", "followers_url": "https://api.github.com/users/ubizjak/followers", "following_url": "https://api.github.com/users/ubizjak/following{/other_user}", "gists_url": "https://api.github.com/users/ubizjak/gists{/gist_id}", "starred_url": "https://api.github.com/users/ubizjak/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ubizjak/subscriptions", "organizations_url": "https://api.github.com/users/ubizjak/orgs", "repos_url": "https://api.github.com/users/ubizjak/repos", "events_url": "https://api.github.com/users/ubizjak/events{/privacy}", "received_events_url": "https://api.github.com/users/ubizjak/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "7d8211603a3d04384812b481b0ae01205a287a72", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7d8211603a3d04384812b481b0ae01205a287a72", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7d8211603a3d04384812b481b0ae01205a287a72"}], "stats": {"total": 276, "additions": 196, "deletions": 80}, "files": [{"sha": "cbd430a2ecf5549113152bd5e479bd87123367bf", "filename": "gcc/config/i386/i386-features.c", "status": "modified", "additions": 115, "deletions": 80, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Fconfig%2Fi386%2Fi386-features.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Fconfig%2Fi386%2Fi386-features.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-features.c?ref=9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "patch": "@@ -544,71 +544,83 @@ general_scalar_chain::compute_convert_gain ()\n \t  += m * ix86_cost->int_store[2] - ix86_cost->sse_store[sse_cost_idx];\n       else if (MEM_P (src) && REG_P (dst))\n \tigain += m * ix86_cost->int_load[2] - ix86_cost->sse_load[sse_cost_idx];\n-      else if (GET_CODE (src) == ASHIFT\n-\t       || GET_CODE (src) == ASHIFTRT\n-\t       || GET_CODE (src) == LSHIFTRT)\n-\t{\n-\t  if (m == 2)\n-\t    {\n-\t      if (INTVAL (XEXP (src, 1)) >= 32)\n-\t\tigain += ix86_cost->add;\n-\t      else\n-\t\tigain += ix86_cost->shift_const;\n-\t    }\n+      else\n+\tswitch (GET_CODE (src))\n+\t  {\n+\t  case ASHIFT:\n+\t  case ASHIFTRT:\n+\t  case LSHIFTRT:\n+\t    if (m == 2)\n+\t      {\n+\t\tif (INTVAL (XEXP (src, 1)) >= 32)\n+\t\t  igain += ix86_cost->add;\n+\t\telse\n+\t\t  igain += ix86_cost->shift_const;\n+\t      }\n \n-\t  igain += ix86_cost->shift_const - ix86_cost->sse_op;\n+\t    igain += ix86_cost->shift_const - ix86_cost->sse_op;\n \n-\t  if (CONST_INT_P (XEXP (src, 0)))\n-\t    igain -= vector_const_cost (XEXP (src, 0));\n-\t}\n-      else if (GET_CODE (src) == PLUS\n-\t       || GET_CODE (src) == MINUS\n-\t       || GET_CODE (src) == IOR\n-\t       || GET_CODE (src) == XOR\n-\t       || GET_CODE (src) == AND)\n-\t{\n-\t  igain += m * ix86_cost->add - ix86_cost->sse_op;\n-\t  /* Additional gain for andnot for targets without BMI.  */\n-\t  if (GET_CODE (XEXP (src, 0)) == NOT\n-\t      && !TARGET_BMI)\n-\t    igain += m * ix86_cost->add;\n-\n-\t  if (CONST_INT_P (XEXP (src, 0)))\n-\t    igain -= vector_const_cost (XEXP (src, 0));\n-\t  if (CONST_INT_P (XEXP (src, 1)))\n-\t    igain -= vector_const_cost (XEXP (src, 1));\n-\t}\n-      else if (GET_CODE (src) == NEG\n-\t       || GET_CODE (src) == NOT)\n-\tigain += m * ix86_cost->add - ix86_cost->sse_op - COSTS_N_INSNS (1);\n-      else if (GET_CODE (src) == ABS\n-\t       || GET_CODE (src) == SMAX\n-\t       || GET_CODE (src) == SMIN\n-\t       || GET_CODE (src) == UMAX\n-\t       || GET_CODE (src) == UMIN)\n-\t{\n-\t  /* We do not have any conditional move cost, estimate it as a\n-\t     reg-reg move.  Comparisons are costed as adds.  */\n-\t  igain += m * (COSTS_N_INSNS (2) + ix86_cost->add);\n-\t  /* Integer SSE ops are all costed the same.  */\n-\t  igain -= ix86_cost->sse_op;\n-\t}\n-      else if (GET_CODE (src) == COMPARE)\n-\t{\n-\t  /* Assume comparison cost is the same.  */\n-\t}\n-      else if (CONST_INT_P (src))\n-\t{\n-\t  if (REG_P (dst))\n-\t    /* DImode can be immediate for TARGET_64BIT and SImode always.  */\n-\t    igain += m * COSTS_N_INSNS (1);\n-\t  else if (MEM_P (dst))\n-\t    igain += (m * ix86_cost->int_store[2]\n-\t\t     - ix86_cost->sse_store[sse_cost_idx]);\n-\t  igain -= vector_const_cost (src);\n-\t}\n-      else\n-\tgcc_unreachable ();\n+\t    if (CONST_INT_P (XEXP (src, 0)))\n+\t      igain -= vector_const_cost (XEXP (src, 0));\n+\t    break;\n+\n+\t  case AND:\n+\t  case IOR:\n+\t  case XOR:\n+\t  case PLUS:\n+\t  case MINUS:\n+\t    igain += m * ix86_cost->add - ix86_cost->sse_op;\n+\t    /* Additional gain for andnot for targets without BMI.  */\n+\t    if (GET_CODE (XEXP (src, 0)) == NOT\n+\t\t&& !TARGET_BMI)\n+\t      igain += m * ix86_cost->add;\n+\n+\t    if (CONST_INT_P (XEXP (src, 0)))\n+\t      igain -= vector_const_cost (XEXP (src, 0));\n+\t    if (CONST_INT_P (XEXP (src, 1)))\n+\t      igain -= vector_const_cost (XEXP (src, 1));\n+\t    break;\n+\n+\t  case NEG:\n+\t  case NOT:\n+\t    igain -= ix86_cost->sse_op + COSTS_N_INSNS (1);\n+\n+\t    if (GET_CODE (XEXP (src, 0)) != ABS)\n+\t      {\n+\t\tigain += m * ix86_cost->add;\n+\t\tbreak;\n+\t      }\n+\t    /* FALLTHRU */\n+\n+\t  case ABS:\n+\t  case SMAX:\n+\t  case SMIN:\n+\t  case UMAX:\n+\t  case UMIN:\n+\t    /* We do not have any conditional move cost, estimate it as a\n+\t       reg-reg move.  Comparisons are costed as adds.  */\n+\t    igain += m * (COSTS_N_INSNS (2) + ix86_cost->add);\n+\t    /* Integer SSE ops are all costed the same.  */\n+\t    igain -= ix86_cost->sse_op;\n+\t    break;\n+\n+\t  case COMPARE:\n+\t    /* Assume comparison cost is the same.  */\n+\t    break;\n+\n+\t  case CONST_INT:\n+\t    if (REG_P (dst))\n+\t      /* DImode can be immediate for TARGET_64BIT and SImode always.  */\n+\t      igain += m * COSTS_N_INSNS (1);\n+\t    else if (MEM_P (dst))\n+\t      igain += (m * ix86_cost->int_store[2]\n+\t\t\t- ix86_cost->sse_store[sse_cost_idx]);\n+\t    igain -= vector_const_cost (src);\n+\t    break;\n+\n+\t  default:\n+\t    gcc_unreachable ();\n+\t  }\n \n       if (igain != 0 && dump_file)\n \t{\n@@ -1009,7 +1021,19 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n \n     case NEG:\n       src = XEXP (src, 0);\n-      convert_op (&src, insn);\n+\n+      if (GET_CODE (src) == ABS)\n+\t{\n+\t  src = XEXP (src, 0);\n+\t  convert_op (&src, insn);\n+\t  subreg = gen_reg_rtx (vmode);\n+\t  emit_insn_before (gen_rtx_SET (subreg,\n+\t\t\t\t\t gen_rtx_ABS (vmode, src)), insn);\n+\t  src = subreg;\n+\t}\n+      else\n+\tconvert_op (&src, insn);\n+\n       subreg = gen_reg_rtx (vmode);\n       emit_insn_before (gen_move_insn (subreg, CONST0_RTX (vmode)), insn);\n       src = gen_rtx_MINUS (vmode, subreg, src);\n@@ -1042,9 +1066,10 @@ general_scalar_chain::convert_insn (rtx_insn *insn)\n \n       gcc_assert (REG_P (src) && GET_MODE (src) == DImode);\n       subreg = gen_rtx_SUBREG (V2DImode, src, 0);\n-      emit_insn_before (gen_vec_interleave_lowv2di (copy_rtx_if_shared (subreg),\n-\t\t\t\t\t\t    copy_rtx_if_shared (subreg),\n-\t\t\t\t\t\t    copy_rtx_if_shared (subreg)),\n+      emit_insn_before (gen_vec_interleave_lowv2di\n+\t\t\t(copy_rtx_if_shared (subreg),\n+\t\t\t copy_rtx_if_shared (subreg),\n+\t\t\t copy_rtx_if_shared (subreg)),\n \t\t\tinsn);\n       dst = gen_rtx_REG (CCmode, FLAGS_REG);\n       src = gen_rtx_UNSPEC (CCmode, gen_rtvec (2, copy_rtx_if_shared (subreg),\n@@ -1400,11 +1425,11 @@ general_scalar_to_vector_candidate_p (rtx_insn *insn, enum machine_mode mode)\n \treturn false;\n       /* Fallthru.  */\n \n-    case PLUS:\n-    case MINUS:\n+    case AND:\n     case IOR:\n     case XOR:\n-    case AND:\n+    case PLUS:\n+    case MINUS:\n       if (!REG_P (XEXP (src, 1))\n \t  && !MEM_P (XEXP (src, 1))\n \t  && !CONST_INT_P (XEXP (src, 1)))\n@@ -1413,18 +1438,32 @@ general_scalar_to_vector_candidate_p (rtx_insn *insn, enum machine_mode mode)\n       if (GET_MODE (XEXP (src, 1)) != mode\n \t  && !CONST_INT_P (XEXP (src, 1)))\n \treturn false;\n+\n+      /* Check for andnot case.  */\n+      if (GET_CODE (src) != AND\n+\t  || GET_CODE (XEXP (src, 0)) != NOT)\n+\tbreak;\n+\n+      src = XEXP (src, 0);\n+      /* FALLTHRU */\n+\n+    case NOT:\n       break;\n \n+    case NEG:\n+      /* Check for nabs case.  */\n+      if (GET_CODE (XEXP (src, 0)) != ABS)\n+\tbreak;\n+\n+      src = XEXP (src, 0);\n+      /* FALLTHRU */\n+\n     case ABS:\n       if ((mode == DImode && !TARGET_AVX512VL)\n \t  || (mode == SImode && !TARGET_SSSE3))\n \treturn false;\n       break;\n \n-    case NEG:\n-    case NOT:\n-      break;\n-\n     case REG:\n       return true;\n \n@@ -1438,12 +1477,8 @@ general_scalar_to_vector_candidate_p (rtx_insn *insn, enum machine_mode mode)\n \n   if (!REG_P (XEXP (src, 0))\n       && !MEM_P (XEXP (src, 0))\n-      && !CONST_INT_P (XEXP (src, 0))\n-      /* Check for andnot case.  */\n-      && (GET_CODE (src) != AND\n-\t  || GET_CODE (XEXP (src, 0)) != NOT\n-\t  || !REG_P (XEXP (XEXP (src, 0), 0))))\n-      return false;\n+      && !CONST_INT_P (XEXP (src, 0)))\n+    return false;\n \n   if (GET_MODE (XEXP (src, 0)) != mode\n       && !CONST_INT_P (XEXP (src, 0)))"}, {"sha": "156c6a94989af78122738576ebe95b59693fbdf2", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "patch": "@@ -10305,6 +10305,50 @@\n   split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\n })\n \n+(define_insn_and_split \"*nabs<dwi>2_doubleword\"\n+  [(set (match_operand:<DWI> 0 \"register_operand\")\n+\t(neg:<DWI>\n+\t  (abs:<DWI>\n+\t    (match_operand:<DWI> 1 \"general_operand\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_CMOVE\n+   && ix86_pre_reload_split ()\"\n+   \"#\"\n+   \"&& 1\"\n+  [(parallel\n+    [(set (reg:CCC FLAGS_REG)\n+\t  (ne:CCC (match_dup 1) (const_int 0)))\n+     (set (match_dup 2) (neg:DWIH (match_dup 1)))])\n+   (parallel\n+    [(set (match_dup 5)\n+\t  (plus:DWIH (plus:DWIH (ltu:DWIH (reg:CC FLAGS_REG) (const_int 0))\n+\t\t\t\t(match_dup 4))\n+\t\t     (const_int 0)))\n+     (clobber (reg:CC FLAGS_REG))])\n+   (parallel\n+     [(set (reg:CCGOC FLAGS_REG)\n+\t   (compare:CCGOC\n+\t     (neg:DWIH (match_dup 5))\n+\t     (const_int 0)))\n+      (set (match_dup 5)\n+\t   (neg:DWIH (match_dup 5)))])\n+   (set (match_dup 0)\n+        (if_then_else:DWIH\n+\t  (lt (reg:CCGOC FLAGS_REG) (const_int 0))\n+\t  (match_dup 2)\n+\t  (match_dup 1)))\n+   (set (match_dup 3)\n+        (if_then_else:DWIH\n+\t  (lt (reg:CCGOC FLAGS_REG) (const_int 0))\n+\t  (match_dup 5)\n+\t  (match_dup 4)))]\n+{\n+  operands[1] = force_reg (<DWI>mode, operands[1]);\n+  operands[2] = gen_reg_rtx (<DWI>mode);\n+\n+  split_double_mode (<DWI>mode, &operands[0], 3, &operands[0], &operands[3]);\n+})\n+\n (define_insn_and_split \"*abs<mode>2_1\"\n   [(set (match_operand:SWI 0 \"register_operand\")\n \t(abs:SWI\n@@ -10332,6 +10376,34 @@\n   operands[2] = gen_reg_rtx (<MODE>mode);\n })\n \n+(define_insn_and_split \"*nabs<mode>2_1\"\n+  [(set (match_operand:SWI 0 \"register_operand\")\n+\t(neg:SWI\n+\t  (abs:SWI\n+\t    (match_operand:SWI 1 \"general_operand\"))))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_CMOVE\n+   && (<MODE>mode != QImode || !TARGET_PARTIAL_REG_STALL)\n+   && ix86_pre_reload_split ()\"\n+   \"#\"\n+   \"&& 1\"\n+  [(parallel\n+     [(set (reg:CCGOC FLAGS_REG)\n+\t   (compare:CCGOC\n+\t     (neg:SWI (match_dup 1))\n+\t     (const_int 0)))\n+      (set (match_dup 2)\n+\t   (neg:SWI (match_dup 1)))])\n+   (set (match_dup 0)\n+        (if_then_else:SWI\n+\t  (lt (reg:CCGOC FLAGS_REG) (const_int 0))\n+\t  (match_dup 2)\n+\t  (match_dup 1)))]\n+{\n+  operands[1] = force_reg (<MODE>mode, operands[1]);\n+  operands[2] = gen_reg_rtx (<MODE>mode);\n+})\n+\n (define_expand \"<code>tf2\"\n   [(set (match_operand:TF 0 \"register_operand\")\n \t(absneg:TF (match_operand:TF 1 \"register_operand\")))]"}, {"sha": "03df86debb80e1c2a3d248e497a47e5332ee86a4", "filename": "gcc/testsuite/gcc.target/i386/pr101044.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101044.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101044.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101044.c?ref=9f6aeb85ee87c6b4e580b6b71e26cbe99e1dab70", "patch": "@@ -0,0 +1,9 @@\n+/* PR target/101044 */\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-sse3 -mtune=generic\" } */\n+/* { dg-final { scan-assembler-times \"neg\" 1 } } */\n+\n+int foo (int x)\n+{\n+  return (x < 0) ? x : -x;\n+}"}]}