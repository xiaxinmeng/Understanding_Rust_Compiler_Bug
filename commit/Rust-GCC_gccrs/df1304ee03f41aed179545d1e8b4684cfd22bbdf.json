{"sha": "df1304ee03f41aed179545d1e8b4684cfd22bbdf", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGYxMzA0ZWUwM2Y0MWFlZDE3OTU0NWQxZThiNDY4NGNmZDIyYmJkZg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-25T20:56:26Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2012-01-25T20:56:26Z"}, "message": "libgo: Update to weekly.2012-01-15.\n\nFrom-SVN: r183539", "tree": {"sha": "c68d6b2a9f5b82a23171b0a488a4b7e5c63ad860", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c68d6b2a9f5b82a23171b0a488a4b7e5c63ad860"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/df1304ee03f41aed179545d1e8b4684cfd22bbdf", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1304ee03f41aed179545d1e8b4684cfd22bbdf", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df1304ee03f41aed179545d1e8b4684cfd22bbdf", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df1304ee03f41aed179545d1e8b4684cfd22bbdf/comments", "author": null, "committer": null, "parents": [{"sha": "3be18e47c33b61365786831e0f967f42b09922c9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3be18e47c33b61365786831e0f967f42b09922c9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3be18e47c33b61365786831e0f967f42b09922c9"}], "stats": {"total": 11743, "additions": 7842, "deletions": 3901}, "files": [{"sha": "b72962fecbebc3d7d24359010e5b586e916bb56b", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -1,4 +1,4 @@\n-4a8268927758\n+354b17404643\n \n The first line of this file holds the Mercurial revision number of the\n last merge done from the master library sources."}, {"sha": "770a849e7446c979d4b573e21398735444699f3d", "filename": "libgo/Makefile.am", "status": "modified", "additions": 56, "deletions": 15, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -188,7 +188,7 @@ toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n \tcrypto/openpgp/elgamal.gox \\\n-\tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/errors.gox \\\n \tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n@@ -235,6 +235,7 @@ toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n+\texp/proxy.gox \\\n \texp/spdy.gox \\\n \texp/sql.gox \\\n \texp/ssh.gox \\\n@@ -669,17 +670,25 @@ endif # !LIBGO_IS_RTEMS\n if LIBGO_IS_LINUX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n+go_net_sockopt_file = go/net/sockopt_linux.go\n+go_net_sockoptip_file = go/net/sockoptip_linux.go\n else\n if LIBGO_IS_IRIX\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n+go_net_sockopt_file = go/net/sockopt_linux.go\n+go_net_sockoptip_file = go/net/sockoptip_linux.go\n else\n if LIBGO_IS_SOLARIS\n go_net_cgo_file = go/net/cgo_linux.go\n go_net_sock_file = go/net/sock_linux.go\n+go_net_sockopt_file = go/net/sockopt_linux.go\n+go_net_sockoptip_file = go/net/sockoptip_linux.go\n else\n go_net_cgo_file = go/net/cgo_bsd.go\n go_net_sock_file = go/net/sock_bsd.go\n+go_net_sockopt_file = go/net/sockopt_bsd.go\n+go_net_sockoptip_file = go/net/sockoptip_bsd.go\n endif\n endif\n endif\n@@ -728,6 +737,10 @@ go_net_files = \\\n \t$(go_net_sendfile_file) \\\n \tgo/net/sock.go \\\n \t$(go_net_sock_file) \\\n+\tgo/net/sockopt.go \\\n+\t$(go_net_sockopt_file) \\\n+\tgo/net/sockoptip.go \\\n+\t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n \tgo/net/udpsock.go \\\n@@ -890,8 +903,7 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/example.go \\\n-\tgo/testing/testing.go \\\n-\tgo/testing/wrapper.go\n+\tgo/testing/testing.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n@@ -1061,8 +1073,8 @@ go_crypto_openpgp_armor_files = \\\n \tgo/crypto/openpgp/armor/encode.go\n go_crypto_openpgp_elgamal_files = \\\n \tgo/crypto/openpgp/elgamal/elgamal.go\n-go_crypto_openpgp_error_files = \\\n-\tgo/crypto/openpgp/error/error.go\n+go_crypto_openpgp_errors_files = \\\n+\tgo/crypto/openpgp/errors/errors.go\n go_crypto_openpgp_packet_files = \\\n \tgo/crypto/openpgp/packet/compressed.go \\\n \tgo/crypto/openpgp/packet/encrypted_key.go \\\n@@ -1142,6 +1154,7 @@ go_encoding_pem_files = \\\n go_encoding_xml_files = \\\n \tgo/encoding/xml/marshal.go \\\n \tgo/encoding/xml/read.go \\\n+\tgo/encoding/xml/typeinfo.go \\\n \tgo/encoding/xml/xml.go\n \n go_exp_ebnf_files = \\\n@@ -1157,6 +1170,11 @@ go_exp_norm_files = \\\n \tgo/exp/norm/readwriter.go \\\n \tgo/exp/norm/tables.go \\\n \tgo/exp/norm/trie.go\n+go_exp_proxy_files = \\\n+\tgo/exp/proxy/direct.go \\\n+\tgo/exp/proxy/per_host.go \\\n+\tgo/exp/proxy/proxy.go \\\n+\tgo/exp/proxy/socks5.go\n go_exp_spdy_files = \\\n \tgo/exp/spdy/read.go \\\n \tgo/exp/spdy/types.go \\\n@@ -1173,7 +1191,7 @@ go_exp_ssh_files = \\\n \tgo/exp/ssh/doc.go \\\n \tgo/exp/ssh/messages.go \\\n \tgo/exp/ssh/server.go \\\n-\tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/server_terminal.go \\\n \tgo/exp/ssh/session.go \\\n \tgo/exp/ssh/tcpip.go \\\n \tgo/exp/ssh/transport.go\n@@ -1210,7 +1228,8 @@ go_go_doc_files = \\\n \tgo/go/doc/doc.go \\\n \tgo/go/doc/example.go \\\n \tgo/go/doc/exports.go \\\n-\tgo/go/doc/filter.go\n+\tgo/go/doc/filter.go \\\n+\tgo/go/doc/reader.go\n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n \tgo/go/parser/parser.go\n@@ -1461,8 +1480,15 @@ endif\n # Define ForkExec and Exec.\n if LIBGO_IS_RTEMS\n syscall_exec_file = go/syscall/exec_stubs.go\n+syscall_exec_os_file =\n+else\n+if LIBGO_IS_LINUX\n+syscall_exec_file = go/syscall/exec_unix.go\n+syscall_exec_os_file = go/syscall/exec_linux.go\n else\n syscall_exec_file = go/syscall/exec_unix.go\n+syscall_exec_os_file = go/syscall/exec_bsd.go\n+endif\n endif\n \n # Define Wait4.\n@@ -1573,6 +1599,7 @@ go_base_syscall_files = \\\n \tgo/syscall/syscall.go \\\n \t$(syscall_syscall_file) \\\n \t$(syscall_exec_file) \\\n+\t$(syscall_exec_os_file) \\\n \t$(syscall_wait_file) \\\n \t$(syscall_sleep_file) \\\n \t$(syscall_errstr_file) \\\n@@ -1720,7 +1747,7 @@ libgo_go_objs = \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n \tcrypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/error.lo \\\n+\tcrypto/openpgp/errors.lo \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n@@ -1743,6 +1770,7 @@ libgo_go_objs = \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n \texp/norm.lo \\\n+\texp/proxy.lo \\\n \texp/spdy.lo \\\n \texp/sql.lo \\\n \texp/ssh.lo \\\n@@ -2578,15 +2606,15 @@ crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/openpgp/elgamal/check\n \n-@go_include@ crypto/openpgp/error.lo.dep\n-crypto/openpgp/error.lo.dep: $(go_crypto_openpgp_error_files)\n+@go_include@ crypto/openpgp/errors.lo.dep\n+crypto/openpgp/errors.lo.dep: $(go_crypto_openpgp_errors_files)\n \t$(BUILDDEPS)\n-crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files)\n+crypto/openpgp/errors.lo: $(go_crypto_openpgp_errors_files)\n \t$(BUILDPACKAGE)\n-crypto/openpgp/error/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/error\n+crypto/openpgp/errors/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/errors\n \t@$(CHECK)\n-.PHONY: crypto/openpgp/error/check\n+.PHONY: crypto/openpgp/errors/check\n \n @go_include@ crypto/openpgp/packet.lo.dep\n crypto/openpgp/packet.lo.dep: $(go_crypto_openpgp_packet_files)\n@@ -2808,6 +2836,16 @@ exp/norm/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/norm/check\n \n+@go_include@ exp/proxy.lo.dep\n+exp/proxy.lo.dep: $(go_exp_proxy_files)\n+\t$(BUILDDEPS)\n+exp/proxy.lo: $(go_exp_proxy_files)\n+\t$(BUILDPACKAGE)\n+exp/proxy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/proxy\n+\t@$(CHECK)\n+.PHONY: exp/proxy/check\n+\n @go_include@ exp/spdy.lo.dep\n exp/spdy.lo.dep: $(go_exp_spdy_files)\n \t$(BUILDDEPS)\n@@ -3622,7 +3660,7 @@ crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n \t$(BUILDGOX)\n-crypto/openpgp/error.gox: crypto/openpgp/error.lo\n+crypto/openpgp/errors.gox: crypto/openpgp/errors.lo\n \t$(BUILDGOX)\n crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n \t$(BUILDGOX)\n@@ -3674,6 +3712,8 @@ exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n+exp/proxy.gox: exp/proxy.lo\n+\t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n \t$(BUILDGOX)\n exp/sql.gox: exp/sql.lo\n@@ -3920,6 +3960,7 @@ TEST_PACKAGES = \\\n \texp/ebnf/check \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n+\texp/proxy/check \\\n \texp/spdy/check \\\n \texp/sql/check \\\n \texp/ssh/check \\"}, {"sha": "b82bf422e5566a43df4efe8cc2873ef5e4d0a830", "filename": "libgo/Makefile.in", "status": "modified", "additions": 77, "deletions": 37, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -153,33 +153,34 @@ am__DEPENDENCIES_2 = bufio/bufio.lo bytes/bytes.lo bytes/index.lo \\\n \tcrypto/sha256.lo crypto/sha512.lo crypto/subtle.lo \\\n \tcrypto/tls.lo crypto/twofish.lo crypto/x509.lo crypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo crypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/error.lo crypto/openpgp/packet.lo \\\n+\tcrypto/openpgp/errors.lo crypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo crypto/x509/pkix.lo debug/dwarf.lo \\\n \tdebug/elf.lo debug/gosym.lo debug/macho.lo debug/pe.lo \\\n \tencoding/ascii85.lo encoding/asn1.lo encoding/base32.lo \\\n \tencoding/base64.lo encoding/binary.lo encoding/csv.lo \\\n \tencoding/git85.lo encoding/gob.lo encoding/hex.lo \\\n \tencoding/json.lo encoding/pem.lo encoding/xml.lo exp/ebnf.lo \\\n-\texp/norm.lo exp/spdy.lo exp/sql.lo exp/ssh.lo exp/terminal.lo \\\n-\texp/types.lo exp/sql/driver.lo html/template.lo go/ast.lo \\\n-\tgo/build.lo go/doc.lo go/parser.lo go/printer.lo go/scanner.lo \\\n-\tgo/token.lo hash/adler32.lo hash/crc32.lo hash/crc64.lo \\\n-\thash/fnv.lo net/http/cgi.lo net/http/fcgi.lo \\\n-\tnet/http/httptest.lo net/http/httputil.lo net/http/pprof.lo \\\n-\timage/bmp.lo image/color.lo image/draw.lo image/gif.lo \\\n-\timage/jpeg.lo image/png.lo image/tiff.lo index/suffixarray.lo \\\n-\tio/ioutil.lo log/syslog.lo log/syslog/syslog_c.lo math/big.lo \\\n-\tmath/cmplx.lo math/rand.lo mime/mime.lo mime/multipart.lo \\\n-\tnet/dict.lo net/http.lo net/mail.lo net/rpc.lo net/smtp.lo \\\n-\tnet/textproto.lo net/url.lo old/netchan.lo old/regexp.lo \\\n-\told/template.lo $(am__DEPENDENCIES_1) os/user.lo os/signal.lo \\\n-\tpath/filepath.lo regexp/syntax.lo net/rpc/jsonrpc.lo \\\n-\truntime/debug.lo runtime/pprof.lo sync/atomic.lo \\\n-\tsync/atomic_c.lo syscall/syscall.lo syscall/errno.lo \\\n-\tsyscall/wait.lo text/scanner.lo text/tabwriter.lo \\\n-\ttext/template.lo text/template/parse.lo testing/testing.lo \\\n-\ttesting/iotest.lo testing/quick.lo testing/script.lo \\\n-\tunicode/utf16.lo unicode/utf8.lo\n+\texp/norm.lo exp/proxy.lo exp/spdy.lo exp/sql.lo exp/ssh.lo \\\n+\texp/terminal.lo exp/types.lo exp/sql/driver.lo \\\n+\thtml/template.lo go/ast.lo go/build.lo go/doc.lo go/parser.lo \\\n+\tgo/printer.lo go/scanner.lo go/token.lo hash/adler32.lo \\\n+\thash/crc32.lo hash/crc64.lo hash/fnv.lo net/http/cgi.lo \\\n+\tnet/http/fcgi.lo net/http/httptest.lo net/http/httputil.lo \\\n+\tnet/http/pprof.lo image/bmp.lo image/color.lo image/draw.lo \\\n+\timage/gif.lo image/jpeg.lo image/png.lo image/tiff.lo \\\n+\tindex/suffixarray.lo io/ioutil.lo log/syslog.lo \\\n+\tlog/syslog/syslog_c.lo math/big.lo math/cmplx.lo math/rand.lo \\\n+\tmime/mime.lo mime/multipart.lo net/dict.lo net/http.lo \\\n+\tnet/mail.lo net/rpc.lo net/smtp.lo net/textproto.lo net/url.lo \\\n+\told/netchan.lo old/regexp.lo old/template.lo \\\n+\t$(am__DEPENDENCIES_1) os/user.lo os/signal.lo path/filepath.lo \\\n+\tregexp/syntax.lo net/rpc/jsonrpc.lo runtime/debug.lo \\\n+\truntime/pprof.lo sync/atomic.lo sync/atomic_c.lo \\\n+\tsyscall/syscall.lo syscall/errno.lo syscall/wait.lo \\\n+\ttext/scanner.lo text/tabwriter.lo text/template.lo \\\n+\ttext/template/parse.lo testing/testing.lo testing/iotest.lo \\\n+\ttesting/quick.lo testing/script.lo unicode/utf16.lo \\\n+\tunicode/utf8.lo\n libgo_la_DEPENDENCIES = $(am__DEPENDENCIES_2) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1) $(am__DEPENDENCIES_1) \\\n \t$(am__DEPENDENCIES_1)\n@@ -652,7 +653,7 @@ toolexeclibgocryptoopenpgpdir = $(toolexeclibgocryptodir)/openpgp\n toolexeclibgocryptoopenpgp_DATA = \\\n \tcrypto/openpgp/armor.gox \\\n \tcrypto/openpgp/elgamal.gox \\\n-\tcrypto/openpgp/error.gox \\\n+\tcrypto/openpgp/errors.gox \\\n \tcrypto/openpgp/packet.gox \\\n \tcrypto/openpgp/s2k.gox\n \n@@ -692,6 +693,7 @@ toolexeclibgoexp_DATA = \\\n \texp/ebnf.gox \\\n \t$(exp_inotify_gox) \\\n \texp/norm.gox \\\n+\texp/proxy.gox \\\n \texp/spdy.gox \\\n \texp/sql.gox \\\n \texp/ssh.gox \\\n@@ -1049,6 +1051,14 @@ go_mime_files = \\\n @LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sock_file = go/net/sock_linux.go\n @LIBGO_IS_LINUX_TRUE@go_net_sock_file = go/net/sock_linux.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockopt_file = go/net/sockopt_bsd.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockopt_file = go/net/sockopt_linux.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockopt_file = go/net/sockopt_linux.go\n+@LIBGO_IS_LINUX_TRUE@go_net_sockopt_file = go/net/sockopt_linux.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_FALSE@go_net_sockoptip_file = go/net/sockoptip_bsd.go\n+@LIBGO_IS_IRIX_FALSE@@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_SOLARIS_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n+@LIBGO_IS_IRIX_TRUE@@LIBGO_IS_LINUX_FALSE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n+@LIBGO_IS_LINUX_TRUE@go_net_sockoptip_file = go/net/sockoptip_linux.go\n @LIBGO_IS_LINUX_FALSE@go_net_sendfile_file = go/net/sendfile_stub.go\n @LIBGO_IS_LINUX_TRUE@go_net_sendfile_file = go/net/sendfile_linux.go\n @LIBGO_IS_LINUX_FALSE@@LIBGO_IS_NETBSD_FALSE@go_net_interface_file = go/net/interface_stub.go\n@@ -1082,6 +1092,10 @@ go_net_files = \\\n \t$(go_net_sendfile_file) \\\n \tgo/net/sock.go \\\n \t$(go_net_sock_file) \\\n+\tgo/net/sockopt.go \\\n+\t$(go_net_sockopt_file) \\\n+\tgo/net/sockoptip.go \\\n+\t$(go_net_sockoptip_file) \\\n \tgo/net/tcpsock.go \\\n \tgo/net/tcpsock_posix.go \\\n \tgo/net/udpsock.go \\\n@@ -1197,8 +1211,7 @@ go_syslog_c_files = \\\n go_testing_files = \\\n \tgo/testing/benchmark.go \\\n \tgo/testing/example.go \\\n-\tgo/testing/testing.go \\\n-\tgo/testing/wrapper.go\n+\tgo/testing/testing.go\n \n go_time_files = \\\n \tgo/time/format.go \\\n@@ -1394,8 +1407,8 @@ go_crypto_openpgp_armor_files = \\\n go_crypto_openpgp_elgamal_files = \\\n \tgo/crypto/openpgp/elgamal/elgamal.go\n \n-go_crypto_openpgp_error_files = \\\n-\tgo/crypto/openpgp/error/error.go\n+go_crypto_openpgp_errors_files = \\\n+\tgo/crypto/openpgp/errors/errors.go\n \n go_crypto_openpgp_packet_files = \\\n \tgo/crypto/openpgp/packet/compressed.go \\\n@@ -1492,6 +1505,7 @@ go_encoding_pem_files = \\\n go_encoding_xml_files = \\\n \tgo/encoding/xml/marshal.go \\\n \tgo/encoding/xml/read.go \\\n+\tgo/encoding/xml/typeinfo.go \\\n \tgo/encoding/xml/xml.go\n \n go_exp_ebnf_files = \\\n@@ -1510,6 +1524,12 @@ go_exp_norm_files = \\\n \tgo/exp/norm/tables.go \\\n \tgo/exp/norm/trie.go\n \n+go_exp_proxy_files = \\\n+\tgo/exp/proxy/direct.go \\\n+\tgo/exp/proxy/per_host.go \\\n+\tgo/exp/proxy/proxy.go \\\n+\tgo/exp/proxy/socks5.go\n+\n go_exp_spdy_files = \\\n \tgo/exp/spdy/read.go \\\n \tgo/exp/spdy/types.go \\\n@@ -1528,7 +1548,7 @@ go_exp_ssh_files = \\\n \tgo/exp/ssh/doc.go \\\n \tgo/exp/ssh/messages.go \\\n \tgo/exp/ssh/server.go \\\n-\tgo/exp/ssh/server_shell.go \\\n+\tgo/exp/ssh/server_terminal.go \\\n \tgo/exp/ssh/session.go \\\n \tgo/exp/ssh/tcpip.go \\\n \tgo/exp/ssh/transport.go\n@@ -1569,7 +1589,8 @@ go_go_doc_files = \\\n \tgo/go/doc/doc.go \\\n \tgo/go/doc/example.go \\\n \tgo/go/doc/exports.go \\\n-\tgo/go/doc/filter.go\n+\tgo/go/doc/filter.go \\\n+\tgo/go/doc/reader.go\n \n go_go_parser_files = \\\n \tgo/go/parser/interface.go \\\n@@ -1840,10 +1861,14 @@ go_unicode_utf8_files = \\\n \n # Define Syscall and Syscall6.\n @LIBGO_IS_RTEMS_TRUE@syscall_syscall_file = go/syscall/syscall_stubs.go\n-@LIBGO_IS_RTEMS_FALSE@syscall_exec_file = go/syscall/exec_unix.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_exec_file = go/syscall/exec_unix.go\n+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_exec_file = go/syscall/exec_unix.go\n \n # Define ForkExec and Exec.\n @LIBGO_IS_RTEMS_TRUE@syscall_exec_file = go/syscall/exec_stubs.go\n+@LIBGO_IS_LINUX_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_exec_os_file = go/syscall/exec_bsd.go\n+@LIBGO_IS_LINUX_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_exec_os_file = go/syscall/exec_linux.go\n+@LIBGO_IS_RTEMS_TRUE@syscall_exec_os_file = \n @HAVE_WAIT4_FALSE@@LIBGO_IS_RTEMS_FALSE@syscall_wait_file = go/syscall/libcall_waitpid.go\n @HAVE_WAIT4_TRUE@@LIBGO_IS_RTEMS_FALSE@syscall_wait_file = go/syscall/libcall_wait4.go\n \n@@ -1901,6 +1926,7 @@ go_base_syscall_files = \\\n \tgo/syscall/syscall.go \\\n \t$(syscall_syscall_file) \\\n \t$(syscall_exec_file) \\\n+\t$(syscall_exec_os_file) \\\n \t$(syscall_wait_file) \\\n \t$(syscall_sleep_file) \\\n \t$(syscall_errstr_file) \\\n@@ -1995,7 +2021,7 @@ libgo_go_objs = \\\n \tcrypto/xtea.lo \\\n \tcrypto/openpgp/armor.lo \\\n \tcrypto/openpgp/elgamal.lo \\\n-\tcrypto/openpgp/error.lo \\\n+\tcrypto/openpgp/errors.lo \\\n \tcrypto/openpgp/packet.lo \\\n \tcrypto/openpgp/s2k.lo \\\n \tcrypto/x509/pkix.lo \\\n@@ -2018,6 +2044,7 @@ libgo_go_objs = \\\n \tencoding/xml.lo \\\n \texp/ebnf.lo \\\n \texp/norm.lo \\\n+\texp/proxy.lo \\\n \texp/spdy.lo \\\n \texp/sql.lo \\\n \texp/ssh.lo \\\n@@ -2286,6 +2313,7 @@ TEST_PACKAGES = \\\n \texp/ebnf/check \\\n \t$(exp_inotify_check) \\\n \texp/norm/check \\\n+\texp/proxy/check \\\n \texp/spdy/check \\\n \texp/sql/check \\\n \texp/ssh/check \\\n@@ -5162,15 +5190,15 @@ crypto/openpgp/elgamal/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: crypto/openpgp/elgamal/check\n \n-@go_include@ crypto/openpgp/error.lo.dep\n-crypto/openpgp/error.lo.dep: $(go_crypto_openpgp_error_files)\n+@go_include@ crypto/openpgp/errors.lo.dep\n+crypto/openpgp/errors.lo.dep: $(go_crypto_openpgp_errors_files)\n \t$(BUILDDEPS)\n-crypto/openpgp/error.lo: $(go_crypto_openpgp_error_files)\n+crypto/openpgp/errors.lo: $(go_crypto_openpgp_errors_files)\n \t$(BUILDPACKAGE)\n-crypto/openpgp/error/check: $(CHECK_DEPS)\n-\t@$(MKDIR_P) crypto/openpgp/error\n+crypto/openpgp/errors/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) crypto/openpgp/errors\n \t@$(CHECK)\n-.PHONY: crypto/openpgp/error/check\n+.PHONY: crypto/openpgp/errors/check\n \n @go_include@ crypto/openpgp/packet.lo.dep\n crypto/openpgp/packet.lo.dep: $(go_crypto_openpgp_packet_files)\n@@ -5392,6 +5420,16 @@ exp/norm/check: $(CHECK_DEPS)\n \t@$(CHECK)\n .PHONY: exp/norm/check\n \n+@go_include@ exp/proxy.lo.dep\n+exp/proxy.lo.dep: $(go_exp_proxy_files)\n+\t$(BUILDDEPS)\n+exp/proxy.lo: $(go_exp_proxy_files)\n+\t$(BUILDPACKAGE)\n+exp/proxy/check: $(CHECK_DEPS)\n+\t@$(MKDIR_P) exp/proxy\n+\t@$(CHECK)\n+.PHONY: exp/proxy/check\n+\n @go_include@ exp/spdy.lo.dep\n exp/spdy.lo.dep: $(go_exp_spdy_files)\n \t$(BUILDDEPS)\n@@ -6201,7 +6239,7 @@ crypto/openpgp/armor.gox: crypto/openpgp/armor.lo\n \t$(BUILDGOX)\n crypto/openpgp/elgamal.gox: crypto/openpgp/elgamal.lo\n \t$(BUILDGOX)\n-crypto/openpgp/error.gox: crypto/openpgp/error.lo\n+crypto/openpgp/errors.gox: crypto/openpgp/errors.lo\n \t$(BUILDGOX)\n crypto/openpgp/packet.gox: crypto/openpgp/packet.lo\n \t$(BUILDGOX)\n@@ -6253,6 +6291,8 @@ exp/inotify.gox: exp/inotify.lo\n \t$(BUILDGOX)\n exp/norm.gox: exp/norm.lo\n \t$(BUILDGOX)\n+exp/proxy.gox: exp/proxy.lo\n+\t$(BUILDGOX)\n exp/spdy.gox: exp/spdy.lo\n \t$(BUILDGOX)\n exp/sql.gox: exp/sql.lo"}, {"sha": "e4a2569a0ae7626b85361656d2e84bde231a4439", "filename": "libgo/config.h.in", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfig.h.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfig.h.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfig.h.in?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -74,6 +74,9 @@\n /* Define to 1 if you have the <sys/mman.h> header file. */\n #undef HAVE_SYS_MMAN_H\n \n+/* Define to 1 if you have the <sys/prctl.h> header file. */\n+#undef HAVE_SYS_PRCTL_H\n+\n /* Define to 1 if you have the <sys/ptrace.h> header file. */\n #undef HAVE_SYS_PTRACE_H\n "}, {"sha": "5ebed8017001e83d32835d2990637f1d9fd97576", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -14505,7 +14505,7 @@ no)\n   ;;\n esac\n \n-for ac_header in sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h\n+for ac_header in sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h sys/prctl.h\n do :\n   as_ac_Header=`$as_echo \"ac_cv_header_$ac_header\" | $as_tr_sh`\n ac_fn_c_check_header_mongrel \"$LINENO\" \"$ac_header\" \"$as_ac_Header\" \"$ac_includes_default\""}, {"sha": "9795332d9a081f1c7c66d3de5e23d90f09bad5a5", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -451,7 +451,7 @@ no)\n   ;;\n esac\n \n-AC_CHECK_HEADERS(sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h)\n+AC_CHECK_HEADERS(sys/mman.h syscall.h sys/epoll.h sys/ptrace.h sys/syscall.h sys/user.h sys/utsname.h sys/select.h sys/socket.h net/if.h sys/prctl.h)\n \n AC_CHECK_HEADERS([linux/filter.h linux/netlink.h linux/rtnetlink.h], [], [],\n [#ifdef HAVE_SYS_SOCKET_H"}, {"sha": "77757af1d804fc501693ff416ac92c65ce425284", "filename": "libgo/go/bytes/buffer.go", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fbytes%2Fbuffer.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fbytes%2Fbuffer.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -97,8 +97,7 @@ func (b *Buffer) grow(n int) int {\n func (b *Buffer) Write(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tm := b.grow(len(p))\n-\tcopy(b.buf[m:], p)\n-\treturn len(p), nil\n+\treturn copy(b.buf[m:], p), nil\n }\n \n // WriteString appends the contents of s to the buffer.  The return\n@@ -200,13 +199,16 @@ func (b *Buffer) WriteRune(r rune) (n int, err error) {\n \n // Read reads the next len(p) bytes from the buffer or until the buffer\n // is drained.  The return value n is the number of bytes read.  If the\n-// buffer has no data to return, err is io.EOF even if len(p) is zero;\n+// buffer has no data to return, err is io.EOF (unless len(p) is zero);\n // otherwise it is nil.\n func (b *Buffer) Read(p []byte) (n int, err error) {\n \tb.lastRead = opInvalid\n \tif b.off >= len(b.buf) {\n \t\t// Buffer is empty, reset to recover space.\n \t\tb.Truncate(0)\n+\t\tif len(p) == 0 {\n+\t\t\treturn\n+\t\t}\n \t\treturn 0, io.EOF\n \t}\n \tn = copy(p, b.buf[b.off:])"}, {"sha": "d0af11f104b9d1706a70121c2523bf946cf5ef22", "filename": "libgo/go/bytes/buffer_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fbytes%2Fbuffer_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbuffer_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -373,3 +373,16 @@ func TestReadBytes(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+// Was a bug: used to give EOF reading empty slice at EOF.\n+func TestReadEmptyAtEOF(t *testing.T) {\n+\tb := new(Buffer)\n+\tslice := make([]byte, 0)\n+\tn, err := b.Read(slice)\n+\tif err != nil {\n+\t\tt.Errorf(\"read error: %v\", err)\n+\t}\n+\tif n != 0 {\n+\t\tt.Errorf(\"wrong count; got %d want 0\", n)\n+\t}\n+}"}, {"sha": "96957ab1b483e31210583776abbb4e116db185e3", "filename": "libgo/go/crypto/openpgp/armor/armor.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Farmor%2Farmor.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,7 +9,7 @@ package armor\n import (\n \t\"bufio\"\n \t\"bytes\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"encoding/base64\"\n \t\"io\"\n )\n@@ -35,7 +35,7 @@ type Block struct {\n \toReader openpgpReader\n }\n \n-var ArmorCorrupt error = error_.StructuralError(\"armor invalid\")\n+var ArmorCorrupt error = errors.StructuralError(\"armor invalid\")\n \n const crc24Init = 0xb704ce\n const crc24Poly = 0x1864cfb"}, {"sha": "c434b764c9b2a621814be42ef537ce8aa5a44b63", "filename": "libgo/go/crypto/openpgp/errors/errors.go", "status": "renamed", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Ferrors%2Ferrors.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// Package error contains common error types for the OpenPGP packages.\n-package error\n+// Package errors contains common error types for the OpenPGP packages.\n+package errors\n \n import (\n \t\"strconv\"", "previous_filename": "libgo/go/crypto/openpgp/error/error.go"}, {"sha": "624a5ea8a769c6481458ef0a2baec21a5874db2f", "filename": "libgo/go/crypto/openpgp/keys.go", "status": "modified", "additions": 29, "deletions": 26, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fkeys.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,8 +7,9 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/packet\"\n+\t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"io\"\n \t\"time\"\n@@ -181,13 +182,13 @@ func (el EntityList) DecryptionKeys() (keys []Key) {\n func ReadArmoredKeyRing(r io.Reader) (EntityList, error) {\n \tblock, err := armor.Decode(r)\n \tif err == io.EOF {\n-\t\treturn nil, error_.InvalidArgumentError(\"no armored data found\")\n+\t\treturn nil, errors.InvalidArgumentError(\"no armored data found\")\n \t}\n \tif err != nil {\n \t\treturn nil, err\n \t}\n \tif block.Type != PublicKeyType && block.Type != PrivateKeyType {\n-\t\treturn nil, error_.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n+\t\treturn nil, errors.InvalidArgumentError(\"expected public or private key block, got: \" + block.Type)\n \t}\n \n \treturn ReadKeyRing(block.Body)\n@@ -203,7 +204,7 @@ func ReadKeyRing(r io.Reader) (el EntityList, err error) {\n \t\tvar e *Entity\n \t\te, err = readEntity(packets)\n \t\tif err != nil {\n-\t\t\tif _, ok := err.(error_.UnsupportedError); ok {\n+\t\t\tif _, ok := err.(errors.UnsupportedError); ok {\n \t\t\t\tlastUnsupportedError = err\n \t\t\t\terr = readToNextPublicKey(packets)\n \t\t\t}\n@@ -235,7 +236,7 @@ func readToNextPublicKey(packets *packet.Reader) (err error) {\n \t\tif err == io.EOF {\n \t\t\treturn\n \t\t} else if err != nil {\n-\t\t\tif _, ok := err.(error_.UnsupportedError); ok {\n+\t\t\tif _, ok := err.(errors.UnsupportedError); ok {\n \t\t\t\terr = nil\n \t\t\t\tcontinue\n \t\t\t}\n@@ -266,14 +267,14 @@ func readEntity(packets *packet.Reader) (*Entity, error) {\n \tif e.PrimaryKey, ok = p.(*packet.PublicKey); !ok {\n \t\tif e.PrivateKey, ok = p.(*packet.PrivateKey); !ok {\n \t\t\tpackets.Unread(p)\n-\t\t\treturn nil, error_.StructuralError(\"first packet was not a public/private key\")\n+\t\t\treturn nil, errors.StructuralError(\"first packet was not a public/private key\")\n \t\t} else {\n \t\t\te.PrimaryKey = &e.PrivateKey.PublicKey\n \t\t}\n \t}\n \n \tif !e.PrimaryKey.PubKeyAlgo.CanSign() {\n-\t\treturn nil, error_.StructuralError(\"primary key cannot be used for signatures\")\n+\t\treturn nil, errors.StructuralError(\"primary key cannot be used for signatures\")\n \t}\n \n \tvar current *Identity\n@@ -303,12 +304,12 @@ EachPacket:\n \n \t\t\t\tsig, ok := p.(*packet.Signature)\n \t\t\t\tif !ok {\n-\t\t\t\t\treturn nil, error_.StructuralError(\"user ID packet not followed by self-signature\")\n+\t\t\t\t\treturn nil, errors.StructuralError(\"user ID packet not followed by self-signature\")\n \t\t\t\t}\n \n \t\t\t\tif (sig.SigType == packet.SigTypePositiveCert || sig.SigType == packet.SigTypeGenericCert) && sig.IssuerKeyId != nil && *sig.IssuerKeyId == e.PrimaryKey.KeyId {\n \t\t\t\t\tif err = e.PrimaryKey.VerifyUserIdSignature(pkt.Id, sig); err != nil {\n-\t\t\t\t\t\treturn nil, error_.StructuralError(\"user ID self-signature invalid: \" + err.Error())\n+\t\t\t\t\t\treturn nil, errors.StructuralError(\"user ID self-signature invalid: \" + err.Error())\n \t\t\t\t\t}\n \t\t\t\t\tcurrent.SelfSignature = sig\n \t\t\t\t\tbreak\n@@ -317,7 +318,7 @@ EachPacket:\n \t\t\t}\n \t\tcase *packet.Signature:\n \t\t\tif current == nil {\n-\t\t\t\treturn nil, error_.StructuralError(\"signature packet found before user id packet\")\n+\t\t\t\treturn nil, errors.StructuralError(\"signature packet found before user id packet\")\n \t\t\t}\n \t\t\tcurrent.Signatures = append(current.Signatures, pkt)\n \t\tcase *packet.PrivateKey:\n@@ -344,7 +345,7 @@ EachPacket:\n \t}\n \n \tif len(e.Identities) == 0 {\n-\t\treturn nil, error_.StructuralError(\"entity without any identities\")\n+\t\treturn nil, errors.StructuralError(\"entity without any identities\")\n \t}\n \n \treturn e, nil\n@@ -359,19 +360,19 @@ func addSubkey(e *Entity, packets *packet.Reader, pub *packet.PublicKey, priv *p\n \t\treturn io.ErrUnexpectedEOF\n \t}\n \tif err != nil {\n-\t\treturn error_.StructuralError(\"subkey signature invalid: \" + err.Error())\n+\t\treturn errors.StructuralError(\"subkey signature invalid: \" + err.Error())\n \t}\n \tvar ok bool\n \tsubKey.Sig, ok = p.(*packet.Signature)\n \tif !ok {\n-\t\treturn error_.StructuralError(\"subkey packet not followed by signature\")\n+\t\treturn errors.StructuralError(\"subkey packet not followed by signature\")\n \t}\n \tif subKey.Sig.SigType != packet.SigTypeSubkeyBinding {\n-\t\treturn error_.StructuralError(\"subkey signature with wrong type\")\n+\t\treturn errors.StructuralError(\"subkey signature with wrong type\")\n \t}\n \terr = e.PrimaryKey.VerifyKeySignature(subKey.PublicKey, subKey.Sig)\n \tif err != nil {\n-\t\treturn error_.StructuralError(\"subkey signature invalid: \" + err.Error())\n+\t\treturn errors.StructuralError(\"subkey signature invalid: \" + err.Error())\n \t}\n \te.Subkeys = append(e.Subkeys, subKey)\n \treturn nil\n@@ -385,7 +386,7 @@ const defaultRSAKeyBits = 2048\n func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email string) (*Entity, error) {\n \tuid := packet.NewUserId(name, comment, email)\n \tif uid == nil {\n-\t\treturn nil, error_.InvalidArgumentError(\"user id field contained invalid characters\")\n+\t\treturn nil, errors.InvalidArgumentError(\"user id field contained invalid characters\")\n \t}\n \tsigningPriv, err := rsa.GenerateKey(rand, defaultRSAKeyBits)\n \tif err != nil {\n@@ -397,8 +398,8 @@ func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email strin\n \t}\n \n \te := &Entity{\n-\t\tPrimaryKey: packet.NewRSAPublicKey(currentTime, &signingPriv.PublicKey, false /* not a subkey */ ),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, signingPriv, false /* not a subkey */ ),\n+\t\tPrimaryKey: packet.NewRSAPublicKey(currentTime, &signingPriv.PublicKey),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, signingPriv),\n \t\tIdentities: make(map[string]*Identity),\n \t}\n \tisPrimaryId := true\n@@ -420,8 +421,8 @@ func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email strin\n \n \te.Subkeys = make([]Subkey, 1)\n \te.Subkeys[0] = Subkey{\n-\t\tPublicKey:  packet.NewRSAPublicKey(currentTime, &encryptingPriv.PublicKey, true /* is a subkey */ ),\n-\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, encryptingPriv, true /* is a subkey */ ),\n+\t\tPublicKey:  packet.NewRSAPublicKey(currentTime, &encryptingPriv.PublicKey),\n+\t\tPrivateKey: packet.NewRSAPrivateKey(currentTime, encryptingPriv),\n \t\tSig: &packet.Signature{\n \t\t\tCreationTime:              currentTime,\n \t\t\tSigType:                   packet.SigTypeSubkeyBinding,\n@@ -433,6 +434,8 @@ func NewEntity(rand io.Reader, currentTime time.Time, name, comment, email strin\n \t\t\tIssuerKeyId:               &e.PrimaryKey.KeyId,\n \t\t},\n \t}\n+\te.Subkeys[0].PublicKey.IsSubkey = true\n+\te.Subkeys[0].PrivateKey.IsSubkey = true\n \n \treturn e, nil\n }\n@@ -450,7 +453,7 @@ func (e *Entity) SerializePrivate(w io.Writer) (err error) {\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n-\t\terr = ident.SelfSignature.SignUserId(ident.UserId.Id, e.PrimaryKey, e.PrivateKey)\n+\t\terr = ident.SelfSignature.SignUserId(rand.Reader, ident.UserId.Id, e.PrimaryKey, e.PrivateKey)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -464,7 +467,7 @@ func (e *Entity) SerializePrivate(w io.Writer) (err error) {\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n-\t\terr = subkey.Sig.SignKey(subkey.PublicKey, e.PrivateKey)\n+\t\terr = subkey.Sig.SignKey(rand.Reader, subkey.PublicKey, e.PrivateKey)\n \t\tif err != nil {\n \t\t\treturn\n \t\t}\n@@ -518,14 +521,14 @@ func (e *Entity) Serialize(w io.Writer) error {\n // necessary.\n func (e *Entity) SignIdentity(identity string, signer *Entity) error {\n \tif signer.PrivateKey == nil {\n-\t\treturn error_.InvalidArgumentError(\"signing Entity must have a private key\")\n+\t\treturn errors.InvalidArgumentError(\"signing Entity must have a private key\")\n \t}\n \tif signer.PrivateKey.Encrypted {\n-\t\treturn error_.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n+\t\treturn errors.InvalidArgumentError(\"signing Entity's private key must be decrypted\")\n \t}\n \tident, ok := e.Identities[identity]\n \tif !ok {\n-\t\treturn error_.InvalidArgumentError(\"given identity string not found in Entity\")\n+\t\treturn errors.InvalidArgumentError(\"given identity string not found in Entity\")\n \t}\n \n \tsig := &packet.Signature{\n@@ -535,7 +538,7 @@ func (e *Entity) SignIdentity(identity string, signer *Entity) error {\n \t\tCreationTime: time.Now(),\n \t\tIssuerKeyId:  &signer.PrivateKey.KeyId,\n \t}\n-\tif err := sig.SignKey(e.PrimaryKey, signer.PrivateKey); err != nil {\n+\tif err := sig.SignKey(rand.Reader, e.PrimaryKey, signer.PrivateKey); err != nil {\n \t\treturn err\n \t}\n \tident.Signatures = append(ident.Signatures, sig)"}, {"sha": "36736e34a0edcd7a153fc8c38a2000a77ca5cd47", "filename": "libgo/go/crypto/openpgp/packet/compressed.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fcompressed.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,7 +7,7 @@ package packet\n import (\n \t\"compress/flate\"\n \t\"compress/zlib\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"io\"\n \t\"strconv\"\n )\n@@ -31,7 +31,7 @@ func (c *Compressed) parse(r io.Reader) error {\n \tcase 2:\n \t\tc.Body, err = zlib.NewReader(r)\n \tdefault:\n-\t\terr = error_.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n+\t\terr = errors.UnsupportedError(\"unknown compression algorithm: \" + strconv.Itoa(int(buf[0])))\n \t}\n \n \treturn err"}, {"sha": "479a643935ed1aae47333ae08616c0447ac99f5f", "filename": "libgo/go/crypto/openpgp/packet/encrypted_key.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fencrypted_key.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,7 +6,7 @@ package packet\n \n import (\n \t\"crypto/openpgp/elgamal\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"encoding/binary\"\n@@ -35,7 +35,7 @@ func (e *EncryptedKey) parse(r io.Reader) (err error) {\n \t\treturn\n \t}\n \tif buf[0] != encryptedKeyVersion {\n-\t\treturn error_.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n+\t\treturn errors.UnsupportedError(\"unknown EncryptedKey version \" + strconv.Itoa(int(buf[0])))\n \t}\n \te.KeyId = binary.BigEndian.Uint64(buf[1:9])\n \te.Algo = PublicKeyAlgorithm(buf[9])\n@@ -77,7 +77,7 @@ func (e *EncryptedKey) Decrypt(priv *PrivateKey) error {\n \t\tc2 := new(big.Int).SetBytes(e.encryptedMPI2)\n \t\tb, err = elgamal.Decrypt(priv.PrivateKey.(*elgamal.PrivateKey), c1, c2)\n \tdefault:\n-\t\terr = error_.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n+\t\terr = errors.InvalidArgumentError(\"cannot decrypted encrypted session key with private key of type \" + strconv.Itoa(int(priv.PubKeyAlgo)))\n \t}\n \n \tif err != nil {\n@@ -89,7 +89,7 @@ func (e *EncryptedKey) Decrypt(priv *PrivateKey) error {\n \texpectedChecksum := uint16(b[len(b)-2])<<8 | uint16(b[len(b)-1])\n \tchecksum := checksumKeyMaterial(e.Key)\n \tif checksum != expectedChecksum {\n-\t\treturn error_.StructuralError(\"EncryptedKey checksum incorrect\")\n+\t\treturn errors.StructuralError(\"EncryptedKey checksum incorrect\")\n \t}\n \n \treturn nil\n@@ -116,16 +116,16 @@ func SerializeEncryptedKey(w io.Writer, rand io.Reader, pub *PublicKey, cipherFu\n \tcase PubKeyAlgoElGamal:\n \t\treturn serializeEncryptedKeyElGamal(w, rand, buf, pub.PublicKey.(*elgamal.PublicKey), keyBlock)\n \tcase PubKeyAlgoDSA, PubKeyAlgoRSASignOnly:\n-\t\treturn error_.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+\t\treturn errors.InvalidArgumentError(\"cannot encrypt to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n \t}\n \n-\treturn error_.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n+\treturn errors.UnsupportedError(\"encrypting a key to public key of type \" + strconv.Itoa(int(pub.PubKeyAlgo)))\n }\n \n func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub *rsa.PublicKey, keyBlock []byte) error {\n \tcipherText, err := rsa.EncryptPKCS1v15(rand, pub, keyBlock)\n \tif err != nil {\n-\t\treturn error_.InvalidArgumentError(\"RSA encryption failed: \" + err.Error())\n+\t\treturn errors.InvalidArgumentError(\"RSA encryption failed: \" + err.Error())\n \t}\n \n \tpacketLen := 10 /* header length */ + 2 /* mpi size */ + len(cipherText)\n@@ -144,7 +144,7 @@ func serializeEncryptedKeyRSA(w io.Writer, rand io.Reader, header [10]byte, pub\n func serializeEncryptedKeyElGamal(w io.Writer, rand io.Reader, header [10]byte, pub *elgamal.PublicKey, keyBlock []byte) error {\n \tc1, c2, err := elgamal.Encrypt(rand, pub, keyBlock)\n \tif err != nil {\n-\t\treturn error_.InvalidArgumentError(\"ElGamal encryption failed: \" + err.Error())\n+\t\treturn errors.InvalidArgumentError(\"ElGamal encryption failed: \" + err.Error())\n \t}\n \n \tpacketLen := 10 /* header length */"}, {"sha": "822cfe9b8f64ac559336d4a2771fb7078ffce96f", "filename": "libgo/go/crypto/openpgp/packet/one_pass_signature.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fone_pass_signature.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,7 +6,7 @@ package packet\n \n import (\n \t\"crypto\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/s2k\"\n \t\"encoding/binary\"\n \t\"io\"\n@@ -33,13 +33,13 @@ func (ops *OnePassSignature) parse(r io.Reader) (err error) {\n \t\treturn\n \t}\n \tif buf[0] != onePassSignatureVersion {\n-\t\terr = error_.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t\terr = errors.UnsupportedError(\"one-pass-signature packet version \" + strconv.Itoa(int(buf[0])))\n \t}\n \n \tvar ok bool\n \tops.Hash, ok = s2k.HashIdToHash(buf[2])\n \tif !ok {\n-\t\treturn error_.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n+\t\treturn errors.UnsupportedError(\"hash function: \" + strconv.Itoa(int(buf[2])))\n \t}\n \n \tops.SigType = SignatureType(buf[1])\n@@ -57,7 +57,7 @@ func (ops *OnePassSignature) Serialize(w io.Writer) error {\n \tvar ok bool\n \tbuf[2], ok = s2k.HashToHashId(ops.Hash)\n \tif !ok {\n-\t\treturn error_.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n+\t\treturn errors.UnsupportedError(\"hash type: \" + strconv.Itoa(int(ops.Hash)))\n \t}\n \tbuf[3] = uint8(ops.PubKeyAlgo)\n \tbinary.BigEndian.PutUint64(buf[4:12], ops.KeyId)"}, {"sha": "f7c1964fd4ca795226019f359e996d22ce2f20f8", "filename": "libgo/go/crypto/openpgp/packet/packet.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"crypto/aes\"\n \t\"crypto/cast5\"\n \t\"crypto/cipher\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"io\"\n \t\"math/big\"\n )\n@@ -162,7 +162,7 @@ func readHeader(r io.Reader) (tag packetType, length int64, contents io.Reader,\n \t\treturn\n \t}\n \tif buf[0]&0x80 == 0 {\n-\t\terr = error_.StructuralError(\"tag byte does not have MSB set\")\n+\t\terr = errors.StructuralError(\"tag byte does not have MSB set\")\n \t\treturn\n \t}\n \tif buf[0]&0x40 == 0 {\n@@ -337,7 +337,7 @@ func Read(r io.Reader) (p Packet, err error) {\n \t\tse.MDC = true\n \t\tp = se\n \tdefault:\n-\t\terr = error_.UnknownPacketTypeError(tag)\n+\t\terr = errors.UnknownPacketTypeError(tag)\n \t}\n \tif p != nil {\n \t\terr = p.parse(contents)"}, {"sha": "e4b86914192c7201f8e117bc13398e2e352741e2", "filename": "libgo/go/crypto/openpgp/packet/packet_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpacket_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,7 +6,7 @@ package packet\n \n import (\n \t\"bytes\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"encoding/hex\"\n \t\"fmt\"\n \t\"io\"\n@@ -152,7 +152,7 @@ func TestReadHeader(t *testing.T) {\n \tfor i, test := range readHeaderTests {\n \t\ttag, length, contents, err := readHeader(readerFromHex(test.hexInput))\n \t\tif test.structuralError {\n-\t\t\tif _, ok := err.(error_.StructuralError); ok {\n+\t\t\tif _, ok := err.(errors.StructuralError); ok {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tt.Errorf(\"%d: expected StructuralError, got:%s\", i, err)"}, {"sha": "5a90d0625fada59b0f237eab48508431b1c8421f", "filename": "libgo/go/crypto/openpgp/packet/private_key.go", "status": "modified", "additions": 24, "deletions": 11, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fprivate_key.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,7 +9,7 @@ import (\n \t\"crypto/cipher\"\n \t\"crypto/dsa\"\n \t\"crypto/openpgp/elgamal\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n@@ -28,14 +28,21 @@ type PrivateKey struct {\n \tencryptedData []byte\n \tcipher        CipherFunction\n \ts2k           func(out, in []byte)\n-\tPrivateKey    interface{} // An *rsa.PrivateKey.\n+\tPrivateKey    interface{} // An *rsa.PrivateKey or *dsa.PrivateKey.\n \tsha1Checksum  bool\n \tiv            []byte\n }\n \n-func NewRSAPrivateKey(currentTime time.Time, priv *rsa.PrivateKey, isSubkey bool) *PrivateKey {\n+func NewRSAPrivateKey(currentTime time.Time, priv *rsa.PrivateKey) *PrivateKey {\n \tpk := new(PrivateKey)\n-\tpk.PublicKey = *NewRSAPublicKey(currentTime, &priv.PublicKey, isSubkey)\n+\tpk.PublicKey = *NewRSAPublicKey(currentTime, &priv.PublicKey)\n+\tpk.PrivateKey = priv\n+\treturn pk\n+}\n+\n+func NewDSAPrivateKey(currentTime time.Time, priv *dsa.PrivateKey) *PrivateKey {\n+\tpk := new(PrivateKey)\n+\tpk.PublicKey = *NewDSAPublicKey(currentTime, &priv.PublicKey)\n \tpk.PrivateKey = priv\n \treturn pk\n }\n@@ -72,13 +79,13 @@ func (pk *PrivateKey) parse(r io.Reader) (err error) {\n \t\t\tpk.sha1Checksum = true\n \t\t}\n \tdefault:\n-\t\treturn error_.UnsupportedError(\"deprecated s2k function in private key\")\n+\t\treturn errors.UnsupportedError(\"deprecated s2k function in private key\")\n \t}\n \n \tif pk.Encrypted {\n \t\tblockSize := pk.cipher.blockSize()\n \t\tif blockSize == 0 {\n-\t\t\treturn error_.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n+\t\t\treturn errors.UnsupportedError(\"unsupported cipher in private key: \" + strconv.Itoa(int(pk.cipher)))\n \t\t}\n \t\tpk.iv = make([]byte, blockSize)\n \t\t_, err = readFull(r, pk.iv)\n@@ -121,8 +128,10 @@ func (pk *PrivateKey) Serialize(w io.Writer) (err error) {\n \tswitch priv := pk.PrivateKey.(type) {\n \tcase *rsa.PrivateKey:\n \t\terr = serializeRSAPrivateKey(privateKeyBuf, priv)\n+\tcase *dsa.PrivateKey:\n+\t\terr = serializeDSAPrivateKey(privateKeyBuf, priv)\n \tdefault:\n-\t\terr = error_.InvalidArgumentError(\"non-RSA private key\")\n+\t\terr = errors.InvalidArgumentError(\"unknown private key type\")\n \t}\n \tif err != nil {\n \t\treturn\n@@ -172,6 +181,10 @@ func serializeRSAPrivateKey(w io.Writer, priv *rsa.PrivateKey) error {\n \treturn writeBig(w, priv.Precomputed.Qinv)\n }\n \n+func serializeDSAPrivateKey(w io.Writer, priv *dsa.PrivateKey) error {\n+\treturn writeBig(w, priv.X)\n+}\n+\n // Decrypt decrypts an encrypted private key using a passphrase.\n func (pk *PrivateKey) Decrypt(passphrase []byte) error {\n \tif !pk.Encrypted {\n@@ -188,26 +201,26 @@ func (pk *PrivateKey) Decrypt(passphrase []byte) error {\n \n \tif pk.sha1Checksum {\n \t\tif len(data) < sha1.Size {\n-\t\t\treturn error_.StructuralError(\"truncated private key data\")\n+\t\t\treturn errors.StructuralError(\"truncated private key data\")\n \t\t}\n \t\th := sha1.New()\n \t\th.Write(data[:len(data)-sha1.Size])\n \t\tsum := h.Sum(nil)\n \t\tif !bytes.Equal(sum, data[len(data)-sha1.Size:]) {\n-\t\t\treturn error_.StructuralError(\"private key checksum failure\")\n+\t\t\treturn errors.StructuralError(\"private key checksum failure\")\n \t\t}\n \t\tdata = data[:len(data)-sha1.Size]\n \t} else {\n \t\tif len(data) < 2 {\n-\t\t\treturn error_.StructuralError(\"truncated private key data\")\n+\t\t\treturn errors.StructuralError(\"truncated private key data\")\n \t\t}\n \t\tvar sum uint16\n \t\tfor i := 0; i < len(data)-2; i++ {\n \t\t\tsum += uint16(data[i])\n \t\t}\n \t\tif data[len(data)-2] != uint8(sum>>8) ||\n \t\t\tdata[len(data)-1] != uint8(sum) {\n-\t\t\treturn error_.StructuralError(\"private key checksum failure\")\n+\t\t\treturn errors.StructuralError(\"private key checksum failure\")\n \t\t}\n \t\tdata = data[:len(data)-2]\n \t}"}, {"sha": "ba178b519ebdaa15c0b709c65ad7d92d66961818", "filename": "libgo/go/crypto/openpgp/packet/public_key.go", "status": "modified", "additions": 34, "deletions": 14, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fpublic_key.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,7 +7,7 @@ package packet\n import (\n \t\"crypto/dsa\"\n \t\"crypto/openpgp/elgamal\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/rsa\"\n \t\"crypto/sha1\"\n \t\"encoding/binary\"\n@@ -39,12 +39,11 @@ func fromBig(n *big.Int) parsedMPI {\n }\n \n // NewRSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n-func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey, isSubkey bool) *PublicKey {\n+func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey) *PublicKey {\n \tpk := &PublicKey{\n \t\tCreationTime: creationTime,\n \t\tPubKeyAlgo:   PubKeyAlgoRSA,\n \t\tPublicKey:    pub,\n-\t\tIsSubkey:     isSubkey,\n \t\tn:            fromBig(pub.N),\n \t\te:            fromBig(big.NewInt(int64(pub.E))),\n \t}\n@@ -53,6 +52,22 @@ func NewRSAPublicKey(creationTime time.Time, pub *rsa.PublicKey, isSubkey bool)\n \treturn pk\n }\n \n+// NewDSAPublicKey returns a PublicKey that wraps the given rsa.PublicKey.\n+func NewDSAPublicKey(creationTime time.Time, pub *dsa.PublicKey) *PublicKey {\n+\tpk := &PublicKey{\n+\t\tCreationTime: creationTime,\n+\t\tPubKeyAlgo:   PubKeyAlgoDSA,\n+\t\tPublicKey:    pub,\n+\t\tp:            fromBig(pub.P),\n+\t\tq:            fromBig(pub.Q),\n+\t\tg:            fromBig(pub.G),\n+\t\ty:            fromBig(pub.Y),\n+\t}\n+\n+\tpk.setFingerPrintAndKeyId()\n+\treturn pk\n+}\n+\n func (pk *PublicKey) parse(r io.Reader) (err error) {\n \t// RFC 4880, section 5.5.2\n \tvar buf [6]byte\n@@ -61,7 +76,7 @@ func (pk *PublicKey) parse(r io.Reader) (err error) {\n \t\treturn\n \t}\n \tif buf[0] != 4 {\n-\t\treturn error_.UnsupportedError(\"public key version\")\n+\t\treturn errors.UnsupportedError(\"public key version\")\n \t}\n \tpk.CreationTime = time.Unix(int64(uint32(buf[1])<<24|uint32(buf[2])<<16|uint32(buf[3])<<8|uint32(buf[4])), 0)\n \tpk.PubKeyAlgo = PublicKeyAlgorithm(buf[5])\n@@ -73,7 +88,7 @@ func (pk *PublicKey) parse(r io.Reader) (err error) {\n \tcase PubKeyAlgoElGamal:\n \t\terr = pk.parseElGamal(r)\n \tdefault:\n-\t\terr = error_.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n+\t\terr = errors.UnsupportedError(\"public key type: \" + strconv.Itoa(int(pk.PubKeyAlgo)))\n \t}\n \tif err != nil {\n \t\treturn\n@@ -105,7 +120,7 @@ func (pk *PublicKey) parseRSA(r io.Reader) (err error) {\n \t}\n \n \tif len(pk.e.bytes) > 3 {\n-\t\terr = error_.UnsupportedError(\"large public exponent\")\n+\t\terr = errors.UnsupportedError(\"large public exponent\")\n \t\treturn\n \t}\n \trsa := &rsa.PublicKey{\n@@ -255,7 +270,7 @@ func (pk *PublicKey) serializeWithoutHeaders(w io.Writer) (err error) {\n \tcase PubKeyAlgoElGamal:\n \t\treturn writeMPIs(w, pk.p, pk.g, pk.y)\n \t}\n-\treturn error_.InvalidArgumentError(\"bad public-key algorithm\")\n+\treturn errors.InvalidArgumentError(\"bad public-key algorithm\")\n }\n \n // CanSign returns true iff this public key can generate signatures\n@@ -267,32 +282,37 @@ func (pk *PublicKey) CanSign() bool {\n // public key, of the data hashed into signed. signed is mutated by this call.\n func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err error) {\n \tif !pk.CanSign() {\n-\t\treturn error_.InvalidArgumentError(\"public key cannot generate signatures\")\n+\t\treturn errors.InvalidArgumentError(\"public key cannot generate signatures\")\n \t}\n \n \tsigned.Write(sig.HashSuffix)\n \thashBytes := signed.Sum(nil)\n \n \tif hashBytes[0] != sig.HashTag[0] || hashBytes[1] != sig.HashTag[1] {\n-\t\treturn error_.SignatureError(\"hash tag doesn't match\")\n+\t\treturn errors.SignatureError(\"hash tag doesn't match\")\n \t}\n \n \tif pk.PubKeyAlgo != sig.PubKeyAlgo {\n-\t\treturn error_.InvalidArgumentError(\"public key and signature use different algorithms\")\n+\t\treturn errors.InvalidArgumentError(\"public key and signature use different algorithms\")\n \t}\n \n \tswitch pk.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n \t\trsaPublicKey, _ := pk.PublicKey.(*rsa.PublicKey)\n \t\terr = rsa.VerifyPKCS1v15(rsaPublicKey, sig.Hash, hashBytes, sig.RSASignature.bytes)\n \t\tif err != nil {\n-\t\t\treturn error_.SignatureError(\"RSA verification failure\")\n+\t\t\treturn errors.SignatureError(\"RSA verification failure\")\n \t\t}\n \t\treturn nil\n \tcase PubKeyAlgoDSA:\n \t\tdsaPublicKey, _ := pk.PublicKey.(*dsa.PublicKey)\n+\t\t// Need to truncate hashBytes to match FIPS 186-3 section 4.6.\n+\t\tsubgroupSize := (dsaPublicKey.Q.BitLen() + 7) / 8\n+\t\tif len(hashBytes) > subgroupSize {\n+\t\t\thashBytes = hashBytes[:subgroupSize]\n+\t\t}\n \t\tif !dsa.Verify(dsaPublicKey, hashBytes, new(big.Int).SetBytes(sig.DSASigR.bytes), new(big.Int).SetBytes(sig.DSASigS.bytes)) {\n-\t\t\treturn error_.SignatureError(\"DSA verification failure\")\n+\t\t\treturn errors.SignatureError(\"DSA verification failure\")\n \t\t}\n \t\treturn nil\n \tdefault:\n@@ -306,7 +326,7 @@ func (pk *PublicKey) VerifySignature(signed hash.Hash, sig *Signature) (err erro\n func keySignatureHash(pk, signed *PublicKey, sig *Signature) (h hash.Hash, err error) {\n \th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn nil, error_.UnsupportedError(\"hash function\")\n+\t\treturn nil, errors.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4\n@@ -332,7 +352,7 @@ func (pk *PublicKey) VerifyKeySignature(signed *PublicKey, sig *Signature) (err\n func userIdSignatureHash(id string, pk *PublicKey, sig *Signature) (h hash.Hash, err error) {\n \th = sig.Hash.New()\n \tif h == nil {\n-\t\treturn nil, error_.UnsupportedError(\"hash function\")\n+\t\treturn nil, errors.UnsupportedError(\"hash function\")\n \t}\n \n \t// RFC 4880, section 5.2.4"}, {"sha": "1a3e8e231338528d728ceff26301d422331c6486", "filename": "libgo/go/crypto/openpgp/packet/reader.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Freader.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -5,7 +5,7 @@\n package packet\n \n import (\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"io\"\n )\n \n@@ -34,7 +34,7 @@ func (r *Reader) Next() (p Packet, err error) {\n \t\t\tr.readers = r.readers[:len(r.readers)-1]\n \t\t\tcontinue\n \t\t}\n-\t\tif _, ok := err.(error_.UnknownPacketTypeError); !ok {\n+\t\tif _, ok := err.(errors.UnknownPacketTypeError); !ok {\n \t\t\treturn nil, err\n \t\t}\n \t}"}, {"sha": "c3ffb3a6fb9e50397bb35133de60edc87170dd7e", "filename": "libgo/go/crypto/openpgp/packet/signature.go", "status": "modified", "additions": 84, "deletions": 33, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsignature.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,9 +7,8 @@ package packet\n import (\n \t\"crypto\"\n \t\"crypto/dsa\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/s2k\"\n-\t\"crypto/rand\"\n \t\"crypto/rsa\"\n \t\"encoding/binary\"\n \t\"hash\"\n@@ -61,7 +60,7 @@ func (sig *Signature) parse(r io.Reader) (err error) {\n \t\treturn\n \t}\n \tif buf[0] != 4 {\n-\t\terr = error_.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n+\t\terr = errors.UnsupportedError(\"signature packet version \" + strconv.Itoa(int(buf[0])))\n \t\treturn\n \t}\n \n@@ -74,14 +73,14 @@ func (sig *Signature) parse(r io.Reader) (err error) {\n \tswitch sig.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly, PubKeyAlgoDSA:\n \tdefault:\n-\t\terr = error_.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t\terr = errors.UnsupportedError(\"public key algorithm \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t\treturn\n \t}\n \n \tvar ok bool\n \tsig.Hash, ok = s2k.HashIdToHash(buf[2])\n \tif !ok {\n-\t\treturn error_.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n+\t\treturn errors.UnsupportedError(\"hash function \" + strconv.Itoa(int(buf[2])))\n \t}\n \n \thashedSubpacketsLength := int(buf[3])<<8 | int(buf[4])\n@@ -153,7 +152,7 @@ func parseSignatureSubpackets(sig *Signature, subpackets []byte, isHashed bool)\n \t}\n \n \tif sig.CreationTime.IsZero() {\n-\t\terr = error_.StructuralError(\"no creation time in signature\")\n+\t\terr = errors.StructuralError(\"no creation time in signature\")\n \t}\n \n \treturn\n@@ -164,7 +163,7 @@ type signatureSubpacketType uint8\n const (\n \tcreationTimeSubpacket        signatureSubpacketType = 2\n \tsignatureExpirationSubpacket signatureSubpacketType = 3\n-\tkeyExpirySubpacket           signatureSubpacketType = 9\n+\tkeyExpirationSubpacket       signatureSubpacketType = 9\n \tprefSymmetricAlgosSubpacket  signatureSubpacketType = 11\n \tissuerSubpacket              signatureSubpacketType = 16\n \tprefHashAlgosSubpacket       signatureSubpacketType = 21\n@@ -207,7 +206,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \trest = subpacket[length:]\n \tsubpacket = subpacket[:length]\n \tif len(subpacket) == 0 {\n-\t\terr = error_.StructuralError(\"zero length signature subpacket\")\n+\t\terr = errors.StructuralError(\"zero length signature subpacket\")\n \t\treturn\n \t}\n \tpacketType = signatureSubpacketType(subpacket[0] & 0x7f)\n@@ -217,37 +216,33 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \tswitch packetType {\n \tcase creationTimeSubpacket:\n \t\tif !isHashed {\n-\t\t\terr = error_.StructuralError(\"signature creation time in non-hashed area\")\n+\t\t\terr = errors.StructuralError(\"signature creation time in non-hashed area\")\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error_.StructuralError(\"signature creation time not four bytes\")\n+\t\t\terr = errors.StructuralError(\"signature creation time not four bytes\")\n \t\t\treturn\n \t\t}\n \t\tt := binary.BigEndian.Uint32(subpacket)\n-\t\tif t == 0 {\n-\t\t\tsig.CreationTime = time.Time{}\n-\t\t} else {\n-\t\t\tsig.CreationTime = time.Unix(int64(t), 0)\n-\t\t}\n+\t\tsig.CreationTime = time.Unix(int64(t), 0)\n \tcase signatureExpirationSubpacket:\n \t\t// Signature expiration time, section 5.2.3.10\n \t\tif !isHashed {\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error_.StructuralError(\"expiration subpacket with bad length\")\n+\t\t\terr = errors.StructuralError(\"expiration subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.SigLifetimeSecs = new(uint32)\n \t\t*sig.SigLifetimeSecs = binary.BigEndian.Uint32(subpacket)\n-\tcase keyExpirySubpacket:\n+\tcase keyExpirationSubpacket:\n \t\t// Key expiration time, section 5.2.3.6\n \t\tif !isHashed {\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 4 {\n-\t\t\terr = error_.StructuralError(\"key expiration subpacket with bad length\")\n+\t\t\terr = errors.StructuralError(\"key expiration subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.KeyLifetimeSecs = new(uint32)\n@@ -262,7 +257,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \tcase issuerSubpacket:\n \t\t// Issuer, section 5.2.3.5\n \t\tif len(subpacket) != 8 {\n-\t\t\terr = error_.StructuralError(\"issuer subpacket with bad length\")\n+\t\t\terr = errors.StructuralError(\"issuer subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.IssuerKeyId = new(uint64)\n@@ -287,7 +282,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) != 1 {\n-\t\t\terr = error_.StructuralError(\"primary user id subpacket with bad length\")\n+\t\t\terr = errors.StructuralError(\"primary user id subpacket with bad length\")\n \t\t\treturn\n \t\t}\n \t\tsig.IsPrimaryId = new(bool)\n@@ -300,7 +295,7 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \t\t\treturn\n \t\t}\n \t\tif len(subpacket) == 0 {\n-\t\t\terr = error_.StructuralError(\"empty key flags subpacket\")\n+\t\t\terr = errors.StructuralError(\"empty key flags subpacket\")\n \t\t\treturn\n \t\t}\n \t\tsig.FlagsValid = true\n@@ -319,14 +314,14 @@ func parseSignatureSubpacket(sig *Signature, subpacket []byte, isHashed bool) (r\n \n \tdefault:\n \t\tif isCritical {\n-\t\t\terr = error_.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n+\t\t\terr = errors.UnsupportedError(\"unknown critical signature subpacket type \" + strconv.Itoa(int(packetType)))\n \t\t\treturn\n \t\t}\n \t}\n \treturn\n \n Truncated:\n-\terr = error_.StructuralError(\"signature subpacket truncated\")\n+\terr = errors.StructuralError(\"signature subpacket truncated\")\n \treturn\n }\n \n@@ -401,7 +396,7 @@ func (sig *Signature) buildHashSuffix() (err error) {\n \tsig.HashSuffix[3], ok = s2k.HashToHashId(sig.Hash)\n \tif !ok {\n \t\tsig.HashSuffix = nil\n-\t\treturn error_.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n+\t\treturn errors.InvalidArgumentError(\"hash cannot be represented in OpenPGP: \" + strconv.Itoa(int(sig.Hash)))\n \t}\n \tsig.HashSuffix[4] = byte(hashedSubpacketsLen >> 8)\n \tsig.HashSuffix[5] = byte(hashedSubpacketsLen)\n@@ -431,7 +426,7 @@ func (sig *Signature) signPrepareHash(h hash.Hash) (digest []byte, err error) {\n // Sign signs a message with a private key. The hash, h, must contain\n // the hash of the message to be signed and will be mutated by this function.\n // On success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err error) {\n+func (sig *Signature) Sign(rand io.Reader, h hash.Hash, priv *PrivateKey) (err error) {\n \tsig.outSubpackets = sig.buildSubpackets()\n \tdigest, err := sig.signPrepareHash(h)\n \tif err != nil {\n@@ -440,18 +435,25 @@ func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err error) {\n \n \tswitch priv.PubKeyAlgo {\n \tcase PubKeyAlgoRSA, PubKeyAlgoRSASignOnly:\n-\t\tsig.RSASignature.bytes, err = rsa.SignPKCS1v15(rand.Reader, priv.PrivateKey.(*rsa.PrivateKey), sig.Hash, digest)\n+\t\tsig.RSASignature.bytes, err = rsa.SignPKCS1v15(rand, priv.PrivateKey.(*rsa.PrivateKey), sig.Hash, digest)\n \t\tsig.RSASignature.bitLength = uint16(8 * len(sig.RSASignature.bytes))\n \tcase PubKeyAlgoDSA:\n-\t\tr, s, err := dsa.Sign(rand.Reader, priv.PrivateKey.(*dsa.PrivateKey), digest)\n+\t\tdsaPriv := priv.PrivateKey.(*dsa.PrivateKey)\n+\n+\t\t// Need to truncate hashBytes to match FIPS 186-3 section 4.6.\n+\t\tsubgroupSize := (dsaPriv.Q.BitLen() + 7) / 8\n+\t\tif len(digest) > subgroupSize {\n+\t\t\tdigest = digest[:subgroupSize]\n+\t\t}\n+\t\tr, s, err := dsa.Sign(rand, dsaPriv, digest)\n \t\tif err == nil {\n \t\t\tsig.DSASigR.bytes = r.Bytes()\n \t\t\tsig.DSASigR.bitLength = uint16(8 * len(sig.DSASigR.bytes))\n \t\t\tsig.DSASigS.bytes = s.Bytes()\n \t\t\tsig.DSASigS.bitLength = uint16(8 * len(sig.DSASigS.bytes))\n \t\t}\n \tdefault:\n-\t\terr = error_.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n+\t\terr = errors.UnsupportedError(\"public key algorithm: \" + strconv.Itoa(int(sig.PubKeyAlgo)))\n \t}\n \n \treturn\n@@ -460,22 +462,22 @@ func (sig *Signature) Sign(h hash.Hash, priv *PrivateKey) (err error) {\n // SignUserId computes a signature from priv, asserting that pub is a valid\n // key for the identity id.  On success, the signature is stored in sig. Call\n // Serialize to write it out.\n-func (sig *Signature) SignUserId(id string, pub *PublicKey, priv *PrivateKey) error {\n+func (sig *Signature) SignUserId(rand io.Reader, id string, pub *PublicKey, priv *PrivateKey) error {\n \th, err := userIdSignatureHash(id, pub, sig)\n \tif err != nil {\n \t\treturn nil\n \t}\n-\treturn sig.Sign(h, priv)\n+\treturn sig.Sign(rand, h, priv)\n }\n \n // SignKey computes a signature from priv, asserting that pub is a subkey.  On\n // success, the signature is stored in sig. Call Serialize to write it out.\n-func (sig *Signature) SignKey(pub *PublicKey, priv *PrivateKey) error {\n+func (sig *Signature) SignKey(rand io.Reader, pub *PublicKey, priv *PrivateKey) error {\n \th, err := keySignatureHash(&priv.PublicKey, pub, sig)\n \tif err != nil {\n \t\treturn err\n \t}\n-\treturn sig.Sign(h, priv)\n+\treturn sig.Sign(rand, h, priv)\n }\n \n // Serialize marshals sig to w. SignRSA or SignDSA must have been called first.\n@@ -484,7 +486,7 @@ func (sig *Signature) Serialize(w io.Writer) (err error) {\n \t\tsig.outSubpackets = sig.rawSubpackets\n \t}\n \tif sig.RSASignature.bytes == nil && sig.DSASigR.bytes == nil {\n-\t\treturn error_.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n+\t\treturn errors.InvalidArgumentError(\"Signature: need to call SignRSA or SignDSA before Serialize\")\n \t}\n \n \tsigLength := 0\n@@ -556,5 +558,54 @@ func (sig *Signature) buildSubpackets() (subpackets []outputSubpacket) {\n \t\tsubpackets = append(subpackets, outputSubpacket{true, issuerSubpacket, false, keyId})\n \t}\n \n+\tif sig.SigLifetimeSecs != nil && *sig.SigLifetimeSecs != 0 {\n+\t\tsigLifetime := make([]byte, 4)\n+\t\tbinary.BigEndian.PutUint32(sigLifetime, *sig.SigLifetimeSecs)\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, signatureExpirationSubpacket, true, sigLifetime})\n+\t}\n+\n+\t// Key flags may only appear in self-signatures or certification signatures.\n+\n+\tif sig.FlagsValid {\n+\t\tvar flags byte\n+\t\tif sig.FlagCertify {\n+\t\t\tflags |= 1\n+\t\t}\n+\t\tif sig.FlagSign {\n+\t\t\tflags |= 2\n+\t\t}\n+\t\tif sig.FlagEncryptCommunications {\n+\t\t\tflags |= 4\n+\t\t}\n+\t\tif sig.FlagEncryptStorage {\n+\t\t\tflags |= 8\n+\t\t}\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, keyFlagsSubpacket, false, []byte{flags}})\n+\t}\n+\n+\t// The following subpackets may only appear in self-signatures\n+\n+\tif sig.KeyLifetimeSecs != nil && *sig.KeyLifetimeSecs != 0 {\n+\t\tkeyLifetime := make([]byte, 4)\n+\t\tbinary.BigEndian.PutUint32(keyLifetime, *sig.KeyLifetimeSecs)\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, keyExpirationSubpacket, true, keyLifetime})\n+\t}\n+\n+\tif sig.IsPrimaryId != nil && *sig.IsPrimaryId {\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, primaryUserIdSubpacket, false, []byte{1}})\n+\t}\n+\n+\tif len(sig.PreferredSymmetric) > 0 {\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, prefSymmetricAlgosSubpacket, false, sig.PreferredSymmetric})\n+\t}\n+\n+\tif len(sig.PreferredHash) > 0 {\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, prefHashAlgosSubpacket, false, sig.PreferredHash})\n+\t}\n+\n+\tif len(sig.PreferredCompression) > 0 {\n+\t\tsubpackets = append(subpackets, outputSubpacket{true, prefCompressionSubpacket, false, sig.PreferredCompression})\n+\t}\n+\n \treturn\n }"}, {"sha": "94e0705040112f95339a8f57ef1d7b33172f9061", "filename": "libgo/go/crypto/openpgp/packet/symmetric_key_encrypted.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetric_key_encrypted.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,7 +7,7 @@ package packet\n import (\n \t\"bytes\"\n \t\"crypto/cipher\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/s2k\"\n \t\"io\"\n \t\"strconv\"\n@@ -37,12 +37,12 @@ func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err error) {\n \t\treturn\n \t}\n \tif buf[0] != symmetricKeyEncryptedVersion {\n-\t\treturn error_.UnsupportedError(\"SymmetricKeyEncrypted version\")\n+\t\treturn errors.UnsupportedError(\"SymmetricKeyEncrypted version\")\n \t}\n \tske.CipherFunc = CipherFunction(buf[1])\n \n \tif ske.CipherFunc.KeySize() == 0 {\n-\t\treturn error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n+\t\treturn errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(buf[1])))\n \t}\n \n \tske.s2k, err = s2k.Parse(r)\n@@ -60,7 +60,7 @@ func (ske *SymmetricKeyEncrypted) parse(r io.Reader) (err error) {\n \terr = nil\n \tif n != 0 {\n \t\tif n == maxSessionKeySizeInBytes {\n-\t\t\treturn error_.UnsupportedError(\"oversized encrypted session key\")\n+\t\t\treturn errors.UnsupportedError(\"oversized encrypted session key\")\n \t\t}\n \t\tske.encryptedKey = encryptedKey[:n]\n \t}\n@@ -89,13 +89,13 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) error {\n \t\tc.XORKeyStream(ske.encryptedKey, ske.encryptedKey)\n \t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n \t\tif ske.CipherFunc.blockSize() == 0 {\n-\t\t\treturn error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n+\t\t\treturn errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(ske.CipherFunc)))\n \t\t}\n \t\tske.CipherFunc = CipherFunction(ske.encryptedKey[0])\n \t\tske.Key = ske.encryptedKey[1:]\n \t\tif len(ske.Key)%ske.CipherFunc.blockSize() != 0 {\n \t\t\tske.Key = nil\n-\t\t\treturn error_.StructuralError(\"length of decrypted key not a multiple of block size\")\n+\t\t\treturn errors.StructuralError(\"length of decrypted key not a multiple of block size\")\n \t\t}\n \t}\n \n@@ -110,7 +110,7 @@ func (ske *SymmetricKeyEncrypted) Decrypt(passphrase []byte) error {\n func SerializeSymmetricKeyEncrypted(w io.Writer, rand io.Reader, passphrase []byte, cipherFunc CipherFunction) (key []byte, err error) {\n \tkeySize := cipherFunc.KeySize()\n \tif keySize == 0 {\n-\t\treturn nil, error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n+\t\treturn nil, errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(cipherFunc)))\n \t}\n \n \ts2kBuf := new(bytes.Buffer)"}, {"sha": "e99a23b9fb205ecc8f50152708b9b80286fe002b", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted.go", "status": "modified", "additions": 13, "deletions": 14, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,8 +6,7 @@ package packet\n \n import (\n \t\"crypto/cipher\"\n-\terror_ \"crypto/openpgp/error\"\n-\t\"crypto/rand\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/sha1\"\n \t\"crypto/subtle\"\n \t\"hash\"\n@@ -35,7 +34,7 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) error {\n \t\t\treturn err\n \t\t}\n \t\tif buf[0] != symmetricallyEncryptedVersion {\n-\t\t\treturn error_.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n+\t\t\treturn errors.UnsupportedError(\"unknown SymmetricallyEncrypted version\")\n \t\t}\n \t}\n \tse.contents = r\n@@ -48,10 +47,10 @@ func (se *SymmetricallyEncrypted) parse(r io.Reader) error {\n func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.ReadCloser, error) {\n \tkeySize := c.KeySize()\n \tif keySize == 0 {\n-\t\treturn nil, error_.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n+\t\treturn nil, errors.UnsupportedError(\"unknown cipher: \" + strconv.Itoa(int(c)))\n \t}\n \tif len(key) != keySize {\n-\t\treturn nil, error_.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n+\t\treturn nil, errors.InvalidArgumentError(\"SymmetricallyEncrypted: incorrect key length\")\n \t}\n \n \tif se.prefix == nil {\n@@ -61,7 +60,7 @@ func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.Read\n \t\t\treturn nil, err\n \t\t}\n \t} else if len(se.prefix) != c.blockSize()+2 {\n-\t\treturn nil, error_.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n+\t\treturn nil, errors.InvalidArgumentError(\"can't try ciphers with different block lengths\")\n \t}\n \n \tocfbResync := cipher.OCFBResync\n@@ -72,7 +71,7 @@ func (se *SymmetricallyEncrypted) Decrypt(c CipherFunction, key []byte) (io.Read\n \n \ts := cipher.NewOCFBDecrypter(c.new(key), se.prefix, ocfbResync)\n \tif s == nil {\n-\t\treturn nil, error_.KeyIncorrectError\n+\t\treturn nil, errors.KeyIncorrectError\n \t}\n \n \tplaintext := cipher.StreamReader{S: s, R: se.contents}\n@@ -181,7 +180,7 @@ const mdcPacketTagByte = byte(0x80) | 0x40 | 19\n \n func (ser *seMDCReader) Close() error {\n \tif ser.error {\n-\t\treturn error_.SignatureError(\"error during reading\")\n+\t\treturn errors.SignatureError(\"error during reading\")\n \t}\n \n \tfor !ser.eof {\n@@ -192,18 +191,18 @@ func (ser *seMDCReader) Close() error {\n \t\t\tbreak\n \t\t}\n \t\tif err != nil {\n-\t\t\treturn error_.SignatureError(\"error during reading\")\n+\t\t\treturn errors.SignatureError(\"error during reading\")\n \t\t}\n \t}\n \n \tif ser.trailer[0] != mdcPacketTagByte || ser.trailer[1] != sha1.Size {\n-\t\treturn error_.SignatureError(\"MDC packet not found\")\n+\t\treturn errors.SignatureError(\"MDC packet not found\")\n \t}\n \tser.h.Write(ser.trailer[:2])\n \n \tfinal := ser.h.Sum(nil)\n \tif subtle.ConstantTimeCompare(final, ser.trailer[2:]) != 1 {\n-\t\treturn error_.SignatureError(\"hash mismatch\")\n+\t\treturn errors.SignatureError(\"hash mismatch\")\n \t}\n \treturn nil\n }\n@@ -253,9 +252,9 @@ func (c noOpCloser) Close() error {\n // SerializeSymmetricallyEncrypted serializes a symmetrically encrypted packet\n // to w and returns a WriteCloser to which the to-be-encrypted packets can be\n // written.\n-func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte) (contents io.WriteCloser, err error) {\n+func SerializeSymmetricallyEncrypted(w io.Writer, rand io.Reader, c CipherFunction, key []byte) (contents io.WriteCloser, err error) {\n \tif c.KeySize() != len(key) {\n-\t\treturn nil, error_.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n+\t\treturn nil, errors.InvalidArgumentError(\"SymmetricallyEncrypted.Serialize: bad key length\")\n \t}\n \twriteCloser := noOpCloser{w}\n \tciphertext, err := serializeStreamHeader(writeCloser, packetTypeSymmetricallyEncryptedMDC)\n@@ -271,7 +270,7 @@ func SerializeSymmetricallyEncrypted(w io.Writer, c CipherFunction, key []byte)\n \tblock := c.new(key)\n \tblockSize := block.BlockSize()\n \tiv := make([]byte, blockSize)\n-\t_, err = rand.Reader.Read(iv)\n+\t_, err = rand.Read(iv)\n \tif err != nil {\n \t\treturn\n \t}"}, {"sha": "f7d133d0bbeeb6fbe467c77b7cd4a344fc87afb5", "filename": "libgo/go/crypto/openpgp/packet/symmetrically_encrypted_test.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fpacket%2Fsymmetrically_encrypted_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,7 +6,8 @@ package packet\n \n import (\n \t\"bytes\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n+\t\"crypto/rand\"\n \t\"crypto/sha1\"\n \t\"encoding/hex\"\n \t\"io\"\n@@ -70,7 +71,7 @@ func testMDCReader(t *testing.T) {\n \terr = mdcReader.Close()\n \tif err == nil {\n \t\tt.Error(\"corruption: no error\")\n-\t} else if _, ok := err.(*error_.SignatureError); !ok {\n+\t} else if _, ok := err.(*errors.SignatureError); !ok {\n \t\tt.Errorf(\"corruption: expected SignatureError, got: %s\", err)\n \t}\n }\n@@ -82,7 +83,7 @@ func TestSerialize(t *testing.T) {\n \tc := CipherAES128\n \tkey := make([]byte, c.KeySize())\n \n-\tw, err := SerializeSymmetricallyEncrypted(buf, c, key)\n+\tw, err := SerializeSymmetricallyEncrypted(buf, rand.Reader, c, key)\n \tif err != nil {\n \t\tt.Errorf(\"error from SerializeSymmetricallyEncrypted: %s\", err)\n \t\treturn"}, {"sha": "1d2343470412309278305b952cbec34b818d836f", "filename": "libgo/go/crypto/openpgp/read.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,7 +8,7 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/packet\"\n \t_ \"crypto/sha256\"\n \t\"hash\"\n@@ -27,7 +27,7 @@ func readArmored(r io.Reader, expectedType string) (body io.Reader, err error) {\n \t}\n \n \tif block.Type != expectedType {\n-\t\treturn nil, error_.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n+\t\treturn nil, errors.InvalidArgumentError(\"expected '\" + expectedType + \"', got: \" + block.Type)\n \t}\n \n \treturn block.Body, nil\n@@ -130,7 +130,7 @@ ParsePackets:\n \t\tcase *packet.Compressed, *packet.LiteralData, *packet.OnePassSignature:\n \t\t\t// This message isn't encrypted.\n \t\t\tif len(symKeys) != 0 || len(pubKeys) != 0 {\n-\t\t\t\treturn nil, error_.StructuralError(\"key material not followed by encrypted message\")\n+\t\t\t\treturn nil, errors.StructuralError(\"key material not followed by encrypted message\")\n \t\t\t}\n \t\t\tpackets.Unread(p)\n \t\t\treturn readSignedMessage(packets, nil, keyring)\n@@ -161,7 +161,7 @@ FindKey:\n \t\t\t\t\tcontinue\n \t\t\t\t}\n \t\t\t\tdecrypted, err = se.Decrypt(pk.encryptedKey.CipherFunc, pk.encryptedKey.Key)\n-\t\t\t\tif err != nil && err != error_.KeyIncorrectError {\n+\t\t\t\tif err != nil && err != errors.KeyIncorrectError {\n \t\t\t\t\treturn nil, err\n \t\t\t\t}\n \t\t\t\tif decrypted != nil {\n@@ -179,11 +179,11 @@ FindKey:\n \t\t}\n \n \t\tif len(candidates) == 0 && len(symKeys) == 0 {\n-\t\t\treturn nil, error_.KeyIncorrectError\n+\t\t\treturn nil, errors.KeyIncorrectError\n \t\t}\n \n \t\tif prompt == nil {\n-\t\t\treturn nil, error_.KeyIncorrectError\n+\t\t\treturn nil, errors.KeyIncorrectError\n \t\t}\n \n \t\tpassphrase, err := prompt(candidates, len(symKeys) != 0)\n@@ -197,7 +197,7 @@ FindKey:\n \t\t\t\terr = s.Decrypt(passphrase)\n \t\t\t\tif err == nil && !s.Encrypted {\n \t\t\t\t\tdecrypted, err = se.Decrypt(s.CipherFunc, s.Key)\n-\t\t\t\t\tif err != nil && err != error_.KeyIncorrectError {\n+\t\t\t\t\tif err != nil && err != errors.KeyIncorrectError {\n \t\t\t\t\t\treturn nil, err\n \t\t\t\t\t}\n \t\t\t\t\tif decrypted != nil {\n@@ -237,7 +237,7 @@ FindLiteralData:\n \t\t\tpackets.Push(p.Body)\n \t\tcase *packet.OnePassSignature:\n \t\t\tif !p.IsLast {\n-\t\t\t\treturn nil, error_.UnsupportedError(\"nested signatures\")\n+\t\t\t\treturn nil, errors.UnsupportedError(\"nested signatures\")\n \t\t\t}\n \n \t\t\th, wrappedHash, err = hashForSignature(p.Hash, p.SigType)\n@@ -281,7 +281,7 @@ FindLiteralData:\n func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Hash, hash.Hash, error) {\n \th := hashId.New()\n \tif h == nil {\n-\t\treturn nil, nil, error_.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n+\t\treturn nil, nil, errors.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hashId)))\n \t}\n \n \tswitch sigType {\n@@ -291,7 +291,7 @@ func hashForSignature(hashId crypto.Hash, sigType packet.SignatureType) (hash.Ha\n \t\treturn h, NewCanonicalTextHash(h), nil\n \t}\n \n-\treturn nil, nil, error_.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n+\treturn nil, nil, errors.UnsupportedError(\"unsupported signature type: \" + strconv.Itoa(int(sigType)))\n }\n \n // checkReader wraps an io.Reader from a LiteralData packet. When it sees EOF\n@@ -333,7 +333,7 @@ func (scr *signatureCheckReader) Read(buf []byte) (n int, err error) {\n \n \t\tvar ok bool\n \t\tif scr.md.Signature, ok = p.(*packet.Signature); !ok {\n-\t\t\tscr.md.SignatureError = error_.StructuralError(\"LiteralData not followed by Signature\")\n+\t\t\tscr.md.SignatureError = errors.StructuralError(\"LiteralData not followed by Signature\")\n \t\t\treturn\n \t\t}\n \n@@ -363,16 +363,16 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe\n \n \tsig, ok := p.(*packet.Signature)\n \tif !ok {\n-\t\treturn nil, error_.StructuralError(\"non signature packet found\")\n+\t\treturn nil, errors.StructuralError(\"non signature packet found\")\n \t}\n \n \tif sig.IssuerKeyId == nil {\n-\t\treturn nil, error_.StructuralError(\"signature doesn't have an issuer\")\n+\t\treturn nil, errors.StructuralError(\"signature doesn't have an issuer\")\n \t}\n \n \tkeys := keyring.KeysById(*sig.IssuerKeyId)\n \tif len(keys) == 0 {\n-\t\treturn nil, error_.UnknownIssuerError\n+\t\treturn nil, errors.UnknownIssuerError\n \t}\n \n \th, wrappedHash, err := hashForSignature(sig.Hash, sig.SigType)\n@@ -399,7 +399,7 @@ func CheckDetachedSignature(keyring KeyRing, signed, signature io.Reader) (signe\n \t\treturn\n \t}\n \n-\treturn nil, error_.UnknownIssuerError\n+\treturn nil, errors.UnknownIssuerError\n }\n \n // CheckArmoredDetachedSignature performs the same actions as"}, {"sha": "d1ecad3817958cff067ffc8ff60771c2da05ec78", "filename": "libgo/go/crypto/openpgp/read_test.go", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fread_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,7 +6,8 @@ package openpgp\n \n import (\n \t\"bytes\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n+\t_ \"crypto/sha512\"\n \t\"encoding/hex\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -77,6 +78,15 @@ func TestReadDSAKey(t *testing.T) {\n \t}\n }\n \n+func TestDSAHashTruncatation(t *testing.T) {\n+\t// dsaKeyWithSHA512 was generated with GnuPG and --cert-digest-algo\n+\t// SHA512 in order to require DSA hash truncation to verify correctly.\n+\t_, err := ReadKeyRing(readerFromHex(dsaKeyWithSHA512))\n+\tif err != nil {\n+\t\tt.Error(err)\n+\t}\n+}\n+\n func TestGetKeyById(t *testing.T) {\n \tkring, _ := ReadKeyRing(readerFromHex(testKeys1And2Hex))\n \n@@ -151,18 +161,18 @@ func TestSignedEncryptedMessage(t *testing.T) {\n \t\tprompt := func(keys []Key, symmetric bool) ([]byte, error) {\n \t\t\tif symmetric {\n \t\t\t\tt.Errorf(\"prompt: message was marked as symmetrically encrypted\")\n-\t\t\t\treturn nil, error_.KeyIncorrectError\n+\t\t\t\treturn nil, errors.KeyIncorrectError\n \t\t\t}\n \n \t\t\tif len(keys) == 0 {\n \t\t\t\tt.Error(\"prompt: no keys requested\")\n-\t\t\t\treturn nil, error_.KeyIncorrectError\n+\t\t\t\treturn nil, errors.KeyIncorrectError\n \t\t\t}\n \n \t\t\terr := keys[0].PrivateKey.Decrypt([]byte(\"passphrase\"))\n \t\t\tif err != nil {\n \t\t\t\tt.Errorf(\"prompt: error decrypting key: %s\", err)\n-\t\t\t\treturn nil, error_.KeyIncorrectError\n+\t\t\t\treturn nil, errors.KeyIncorrectError\n \t\t\t}\n \n \t\t\treturn nil, nil\n@@ -286,7 +296,7 @@ func TestReadingArmoredPrivateKey(t *testing.T) {\n \n func TestNoArmoredData(t *testing.T) {\n \t_, err := ReadArmoredKeyRing(bytes.NewBufferString(\"foo\"))\n-\tif _, ok := err.(error_.InvalidArgumentError); !ok {\n+\tif _, ok := err.(errors.InvalidArgumentError); !ok {\n \t\tt.Errorf(\"error was not an InvalidArgumentError: %s\", err)\n \t}\n }\n@@ -358,3 +368,5 @@ AHcVnXjtxrULkQFGbGvhKURLvS9WnzD/m1K2zzwxzkPTzT9/Yf06O6Mal5AdugPL\n VrM0m72/jnpKo04=\n =zNCn\n -----END PGP PRIVATE KEY BLOCK-----`\n+\n+const dsaKeyWithSHA512 = `9901a2044f04b07f110400db244efecc7316553ee08d179972aab87bb1214de7692593fcf5b6feb1c80fba268722dd464748539b85b81d574cd2d7ad0ca2444de4d849b8756bad7768c486c83a824f9bba4af773d11742bdfb4ac3b89ef8cc9452d4aad31a37e4b630d33927bff68e879284a1672659b8b298222fc68f370f3e24dccacc4a862442b9438b00a0ea444a24088dc23e26df7daf8f43cba3bffc4fe703fe3d6cd7fdca199d54ed8ae501c30e3ec7871ea9cdd4cf63cfe6fc82281d70a5b8bb493f922cd99fba5f088935596af087c8d818d5ec4d0b9afa7f070b3d7c1dd32a84fca08d8280b4890c8da1dde334de8e3cad8450eed2a4a4fcc2db7b8e5528b869a74a7f0189e11ef097ef1253582348de072bb07a9fa8ab838e993cef0ee203ff49298723e2d1f549b00559f886cd417a41692ce58d0ac1307dc71d85a8af21b0cf6eaa14baf2922d3a70389bedf17cc514ba0febbd107675a372fe84b90162a9e88b14d4b1c6be855b96b33fb198c46f058568817780435b6936167ebb3724b680f32bf27382ada2e37a879b3d9de2abe0c3f399350afd1ad438883f4791e2e3b4184453412068617368207472756e636174696f6e207465737488620413110a002205024f04b07f021b03060b090807030206150802090a0b0416020301021e01021780000a0910ef20e0cefca131581318009e2bf3bf047a44d75a9bacd00161ee04d435522397009a03a60d51bd8a568c6c021c8d7cf1be8d990d6417b0020003`"}, {"sha": "39479a1f1c6c10b887ef64a7e9b8112b8cd7b83e", "filename": "libgo/go/crypto/openpgp/s2k/s2k.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fs2k%2Fs2k.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,7 +8,7 @@ package s2k\n \n import (\n \t\"crypto\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"hash\"\n \t\"io\"\n \t\"strconv\"\n@@ -89,11 +89,11 @@ func Parse(r io.Reader) (f func(out, in []byte), err error) {\n \n \thash, ok := HashIdToHash(buf[1])\n \tif !ok {\n-\t\treturn nil, error_.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n+\t\treturn nil, errors.UnsupportedError(\"hash for S2K function: \" + strconv.Itoa(int(buf[1])))\n \t}\n \th := hash.New()\n \tif h == nil {\n-\t\treturn nil, error_.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n+\t\treturn nil, errors.UnsupportedError(\"hash not available: \" + strconv.Itoa(int(hash)))\n \t}\n \n \tswitch buf[0] {\n@@ -123,7 +123,7 @@ func Parse(r io.Reader) (f func(out, in []byte), err error) {\n \t\treturn f, nil\n \t}\n \n-\treturn nil, error_.UnsupportedError(\"S2K function\")\n+\treturn nil, errors.UnsupportedError(\"S2K function\")\n }\n \n // Serialize salts and stretches the given passphrase and writes the resulting"}, {"sha": "73daa11312119cd2f8be27a1dcc083ef6bcf29bc", "filename": "libgo/go/crypto/openpgp/write.go", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,7 +7,7 @@ package openpgp\n import (\n \t\"crypto\"\n \t\"crypto/openpgp/armor\"\n-\terror_ \"crypto/openpgp/error\"\n+\t\"crypto/openpgp/errors\"\n \t\"crypto/openpgp/packet\"\n \t\"crypto/openpgp/s2k\"\n \t\"crypto/rand\"\n@@ -58,10 +58,10 @@ func armoredDetachSign(w io.Writer, signer *Entity, message io.Reader, sigType p\n \n func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.SignatureType) (err error) {\n \tif signer.PrivateKey == nil {\n-\t\treturn error_.InvalidArgumentError(\"signing key doesn't have a private key\")\n+\t\treturn errors.InvalidArgumentError(\"signing key doesn't have a private key\")\n \t}\n \tif signer.PrivateKey.Encrypted {\n-\t\treturn error_.InvalidArgumentError(\"signing key is encrypted\")\n+\t\treturn errors.InvalidArgumentError(\"signing key is encrypted\")\n \t}\n \n \tsig := new(packet.Signature)\n@@ -77,7 +77,7 @@ func detachSign(w io.Writer, signer *Entity, message io.Reader, sigType packet.S\n \t}\n \tio.Copy(wrappedHash, message)\n \n-\terr = sig.Sign(h, signer.PrivateKey)\n+\terr = sig.Sign(rand.Reader, h, signer.PrivateKey)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -111,7 +111,7 @@ func SymmetricallyEncrypt(ciphertext io.Writer, passphrase []byte, hints *FileHi\n \tif err != nil {\n \t\treturn\n \t}\n-\tw, err := packet.SerializeSymmetricallyEncrypted(ciphertext, packet.CipherAES128, key)\n+\tw, err := packet.SerializeSymmetricallyEncrypted(ciphertext, rand.Reader, packet.CipherAES128, key)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -156,7 +156,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \tif signed != nil {\n \t\tsigner = signed.signingKey().PrivateKey\n \t\tif signer == nil || signer.Encrypted {\n-\t\t\treturn nil, error_.InvalidArgumentError(\"signing key must be decrypted\")\n+\t\t\treturn nil, errors.InvalidArgumentError(\"signing key must be decrypted\")\n \t\t}\n \t}\n \n@@ -183,7 +183,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \tfor i := range to {\n \t\tencryptKeys[i] = to[i].encryptionKey()\n \t\tif encryptKeys[i].PublicKey == nil {\n-\t\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.FormatUint(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n+\t\t\treturn nil, errors.InvalidArgumentError(\"cannot encrypt a message to key id \" + strconv.FormatUint(to[i].PrimaryKey.KeyId, 16) + \" because it has no encryption keys\")\n \t\t}\n \n \t\tsig := to[i].primaryIdentity().SelfSignature\n@@ -201,7 +201,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \t}\n \n \tif len(candidateCiphers) == 0 || len(candidateHashes) == 0 {\n-\t\treturn nil, error_.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n+\t\treturn nil, errors.InvalidArgumentError(\"cannot encrypt because recipient set shares no common algorithms\")\n \t}\n \n \tcipher := packet.CipherFunction(candidateCiphers[0])\n@@ -217,7 +217,7 @@ func Encrypt(ciphertext io.Writer, to []*Entity, signed *Entity, hints *FileHint\n \t\t}\n \t}\n \n-\tencryptedData, err := packet.SerializeSymmetricallyEncrypted(ciphertext, cipher, symKey)\n+\tencryptedData, err := packet.SerializeSymmetricallyEncrypted(ciphertext, rand.Reader, cipher, symKey)\n \tif err != nil {\n \t\treturn\n \t}\n@@ -287,7 +287,7 @@ func (s signatureWriter) Close() error {\n \t\tIssuerKeyId:  &s.signer.KeyId,\n \t}\n \n-\tif err := sig.Sign(s.h, s.signer); err != nil {\n+\tif err := sig.Sign(rand.Reader, s.h, s.signer); err != nil {\n \t\treturn err\n \t}\n \tif err := s.literalData.Close(); err != nil {"}, {"sha": "7df02e7bd134198d3c7d829387c7e2561813b21e", "filename": "libgo/go/crypto/openpgp/write_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fopenpgp%2Fwrite_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -222,7 +222,7 @@ func TestEncryption(t *testing.T) {\n \n \t\tif test.isSigned {\n \t\t\tif md.SignatureError != nil {\n-\t\t\t\tt.Errorf(\"#%d: signature error: %s\", i, err)\n+\t\t\t\tt.Errorf(\"#%d: signature error: %s\", i, md.SignatureError)\n \t\t\t}\n \t\t\tif md.Signature == nil {\n \t\t\t\tt.Error(\"signature missing\")"}, {"sha": "25f7a920cd380e066ef84a98456113477e964ed5", "filename": "libgo/go/crypto/tls/common.go", "status": "modified", "additions": 26, "deletions": 6, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fcommon.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -111,6 +111,18 @@ type ConnectionState struct {\n \tVerifiedChains [][]*x509.Certificate\n }\n \n+// ClientAuthType declares the policy the server will follow for\n+// TLS Client Authentication.\n+type ClientAuthType int\n+\n+const (\n+\tNoClientCert ClientAuthType = iota\n+\tRequestClientCert\n+\tRequireAnyClientCert\n+\tVerifyClientCertIfGiven\n+\tRequireAndVerifyClientCert\n+)\n+\n // A Config structure is used to configure a TLS client or server. After one\n // has been passed to a TLS function it must not be modified.\n type Config struct {\n@@ -120,7 +132,7 @@ type Config struct {\n \tRand io.Reader\n \n \t// Time returns the current time as the number of seconds since the epoch.\n-\t// If Time is nil, TLS uses the system time.Seconds.\n+\t// If Time is nil, TLS uses time.Now.\n \tTime func() time.Time\n \n \t// Certificates contains one or more certificate chains\n@@ -148,11 +160,14 @@ type Config struct {\n \t// hosting.\n \tServerName string\n \n-\t// AuthenticateClient controls whether a server will request a certificate\n-\t// from the client. It does not require that the client send a\n-\t// certificate nor does it require that the certificate sent be\n-\t// anything more than self-signed.\n-\tAuthenticateClient bool\n+\t// ClientAuth determines the server's policy for\n+\t// TLS Client Authentication. The default is NoClientCert.\n+\tClientAuth ClientAuthType\n+\n+\t// ClientCAs defines the set of root certificate authorities\n+\t// that servers use if required to verify a client certificate\n+\t// by the policy in ClientAuth.\n+\tClientCAs *x509.CertPool\n \n \t// InsecureSkipVerify controls whether a client verifies the\n \t// server's certificate chain and host name.\n@@ -259,6 +274,11 @@ type Certificate struct {\n \t// OCSPStaple contains an optional OCSP response which will be served\n \t// to clients that request it.\n \tOCSPStaple []byte\n+\t// Leaf is the parsed form of the leaf certificate, which may be\n+\t// initialized using x509.ParseCertificate to reduce per-handshake\n+\t// processing for TLS clients doing client authentication. If nil, the\n+\t// leaf certificate will be parsed as needed.\n+\tLeaf *x509.Certificate\n }\n \n // A TLS record."}, {"sha": "7c0718b82ab5765576d7d4778839afa1e964417a", "filename": "libgo/go/crypto/tls/generate_cert.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fgenerate_cert.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -31,16 +31,16 @@ func main() {\n \t\treturn\n \t}\n \n-\tnow := time.Seconds()\n+\tnow := time.Now()\n \n \ttemplate := x509.Certificate{\n \t\tSerialNumber: new(big.Int).SetInt64(0),\n \t\tSubject: pkix.Name{\n \t\t\tCommonName:   *hostName,\n \t\t\tOrganization: []string{\"Acme Co\"},\n \t\t},\n-\t\tNotBefore: time.SecondsToUTC(now - 300),\n-\t\tNotAfter:  time.SecondsToUTC(now + 60*60*24*365), // valid for 1 year.\n+\t\tNotBefore: now.Add(-5 * time.Minute).UTC(),\n+\t\tNotAfter:  now.AddDate(1, 0, 0).UTC(), // valid for 1 year.\n \n \t\tSubjectKeyId: []byte{1, 2, 3, 4},\n \t\tKeyUsage:     x509.KeyUsageKeyEncipherment | x509.KeyUsageDigitalSignature,"}, {"sha": "632ceea9c1a2adbdfb7261cd373666770d519c6c", "filename": "libgo/go/crypto/tls/handshake_client.go", "status": "modified", "additions": 54, "deletions": 29, "changes": 83, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_client.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -5,12 +5,14 @@\n package tls\n \n import (\n+\t\"bytes\"\n \t\"crypto\"\n \t\"crypto/rsa\"\n \t\"crypto/subtle\"\n \t\"crypto/x509\"\n \t\"errors\"\n \t\"io\"\n+\t\"strconv\"\n )\n \n func (c *Conn) clientHandshake() error {\n@@ -162,10 +164,23 @@ func (c *Conn) clientHandshake() error {\n \t\t}\n \t}\n \n-\ttransmitCert := false\n+\tvar certToSend *Certificate\n \tcertReq, ok := msg.(*certificateRequestMsg)\n \tif ok {\n-\t\t// We only accept certificates with RSA keys.\n+\t\t// RFC 4346 on the certificateAuthorities field:\n+\t\t// A list of the distinguished names of acceptable certificate\n+\t\t// authorities. These distinguished names may specify a desired\n+\t\t// distinguished name for a root CA or for a subordinate CA;\n+\t\t// thus, this message can be used to describe both known roots\n+\t\t// and a desired authorization space. If the\n+\t\t// certificate_authorities list is empty then the client MAY\n+\t\t// send any certificate of the appropriate\n+\t\t// ClientCertificateType, unless there is some external\n+\t\t// arrangement to the contrary.\n+\n+\t\tfinishedHash.Write(certReq.marshal())\n+\n+\t\t// For now, we only know how to sign challenges with RSA\n \t\trsaAvail := false\n \t\tfor _, certType := range certReq.certificateTypes {\n \t\t\tif certType == certTypeRSASign {\n@@ -174,23 +189,41 @@ func (c *Conn) clientHandshake() error {\n \t\t\t}\n \t\t}\n \n-\t\t// For now, only send a certificate back if the server gives us an\n-\t\t// empty list of certificateAuthorities.\n-\t\t//\n-\t\t// RFC 4346 on the certificateAuthorities field:\n-\t\t// A list of the distinguished names of acceptable certificate\n-\t\t// authorities.  These distinguished names may specify a desired\n-\t\t// distinguished name for a root CA or for a subordinate CA; thus,\n-\t\t// this message can be used to describe both known roots and a\n-\t\t// desired authorization space.  If the certificate_authorities\n-\t\t// list is empty then the client MAY send any certificate of the\n-\t\t// appropriate ClientCertificateType, unless there is some\n-\t\t// external arrangement to the contrary.\n-\t\tif rsaAvail && len(certReq.certificateAuthorities) == 0 {\n-\t\t\ttransmitCert = true\n-\t\t}\n+\t\t// We need to search our list of client certs for one\n+\t\t// where SignatureAlgorithm is RSA and the Issuer is in\n+\t\t// certReq.certificateAuthorities\n+\tfindCert:\n+\t\tfor i, cert := range c.config.Certificates {\n+\t\t\tif !rsaAvail {\n+\t\t\t\tcontinue\n+\t\t\t}\n \n-\t\tfinishedHash.Write(certReq.marshal())\n+\t\t\tleaf := cert.Leaf\n+\t\t\tif leaf == nil {\n+\t\t\t\tif leaf, err = x509.ParseCertificate(cert.Certificate[0]); err != nil {\n+\t\t\t\t\tc.sendAlert(alertInternalError)\n+\t\t\t\t\treturn errors.New(\"tls: failed to parse client certificate #\" + strconv.Itoa(i) + \": \" + err.Error())\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tif leaf.PublicKeyAlgorithm != x509.RSA {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif len(certReq.certificateAuthorities) == 0 {\n+\t\t\t\t// they gave us an empty list, so just take the\n+\t\t\t\t// first RSA cert from c.config.Certificates\n+\t\t\t\tcertToSend = &cert\n+\t\t\t\tbreak\n+\t\t\t}\n+\n+\t\t\tfor _, ca := range certReq.certificateAuthorities {\n+\t\t\t\tif bytes.Equal(leaf.RawIssuer, ca) {\n+\t\t\t\t\tcertToSend = &cert\n+\t\t\t\t\tbreak findCert\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \n \t\tmsg, err = c.readHandshake()\n \t\tif err != nil {\n@@ -204,17 +237,9 @@ func (c *Conn) clientHandshake() error {\n \t}\n \tfinishedHash.Write(shd.marshal())\n \n-\tvar cert *x509.Certificate\n-\tif transmitCert {\n+\tif certToSend != nil {\n \t\tcertMsg = new(certificateMsg)\n-\t\tif len(c.config.Certificates) > 0 {\n-\t\t\tcert, err = x509.ParseCertificate(c.config.Certificates[0].Certificate[0])\n-\t\t\tif err == nil && cert.PublicKeyAlgorithm == x509.RSA {\n-\t\t\t\tcertMsg.certificates = c.config.Certificates[0].Certificate\n-\t\t\t} else {\n-\t\t\t\tcert = nil\n-\t\t\t}\n-\t\t}\n+\t\tcertMsg.certificates = certToSend.Certificate\n \t\tfinishedHash.Write(certMsg.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certMsg.marshal())\n \t}\n@@ -229,7 +254,7 @@ func (c *Conn) clientHandshake() error {\n \t\tc.writeRecord(recordTypeHandshake, ckx.marshal())\n \t}\n \n-\tif cert != nil {\n+\tif certToSend != nil {\n \t\tcertVerify := new(certificateVerifyMsg)\n \t\tdigest := make([]byte, 0, 36)\n \t\tdigest = finishedHash.serverMD5.Sum(digest)"}, {"sha": "e1517cc794ff21c8eb474ab094a7e9d8e1f5b718", "filename": "libgo/go/crypto/tls/handshake_messages.go", "status": "modified", "additions": 21, "deletions": 19, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_messages.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -881,9 +881,11 @@ func (m *certificateRequestMsg) marshal() (x []byte) {\n \n \t// See http://tools.ietf.org/html/rfc4346#section-7.4.4\n \tlength := 1 + len(m.certificateTypes) + 2\n+\tcasLength := 0\n \tfor _, ca := range m.certificateAuthorities {\n-\t\tlength += 2 + len(ca)\n+\t\tcasLength += 2 + len(ca)\n \t}\n+\tlength += casLength\n \n \tx = make([]byte, 4+length)\n \tx[0] = typeCertificateRequest\n@@ -895,10 +897,8 @@ func (m *certificateRequestMsg) marshal() (x []byte) {\n \n \tcopy(x[5:], m.certificateTypes)\n \ty := x[5+len(m.certificateTypes):]\n-\n-\tnumCA := len(m.certificateAuthorities)\n-\ty[0] = uint8(numCA >> 8)\n-\ty[1] = uint8(numCA)\n+\ty[0] = uint8(casLength >> 8)\n+\ty[1] = uint8(casLength)\n \ty = y[2:]\n \tfor _, ca := range m.certificateAuthorities {\n \t\ty[0] = uint8(len(ca) >> 8)\n@@ -909,7 +909,6 @@ func (m *certificateRequestMsg) marshal() (x []byte) {\n \t}\n \n \tm.raw = x\n-\n \treturn\n }\n \n@@ -937,31 +936,34 @@ func (m *certificateRequestMsg) unmarshal(data []byte) bool {\n \t}\n \n \tdata = data[numCertTypes:]\n+\n \tif len(data) < 2 {\n \t\treturn false\n \t}\n-\n-\tnumCAs := uint16(data[0])<<16 | uint16(data[1])\n+\tcasLength := uint16(data[0])<<8 | uint16(data[1])\n \tdata = data[2:]\n+\tif len(data) < int(casLength) {\n+\t\treturn false\n+\t}\n+\tcas := make([]byte, casLength)\n+\tcopy(cas, data)\n+\tdata = data[casLength:]\n \n-\tm.certificateAuthorities = make([][]byte, numCAs)\n-\tfor i := uint16(0); i < numCAs; i++ {\n-\t\tif len(data) < 2 {\n+\tm.certificateAuthorities = nil\n+\tfor len(cas) > 0 {\n+\t\tif len(cas) < 2 {\n \t\t\treturn false\n \t\t}\n-\t\tcaLen := uint16(data[0])<<16 | uint16(data[1])\n+\t\tcaLen := uint16(cas[0])<<8 | uint16(cas[1])\n+\t\tcas = cas[2:]\n \n-\t\tdata = data[2:]\n-\t\tif len(data) < int(caLen) {\n+\t\tif len(cas) < int(caLen) {\n \t\t\treturn false\n \t\t}\n \n-\t\tca := make([]byte, caLen)\n-\t\tcopy(ca, data)\n-\t\tm.certificateAuthorities[i] = ca\n-\t\tdata = data[caLen:]\n+\t\tm.certificateAuthorities = append(m.certificateAuthorities, cas[:caLen])\n+\t\tcas = cas[caLen:]\n \t}\n-\n \tif len(data) > 0 {\n \t\treturn false\n \t}"}, {"sha": "fb53767f3e08c50e6cb857e3a6a60387a30a4a3d", "filename": "libgo/go/crypto/tls/handshake_server.go", "status": "modified", "additions": 68, "deletions": 28, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -150,14 +150,19 @@ FindCipherSuite:\n \t\tc.writeRecord(recordTypeHandshake, skx.marshal())\n \t}\n \n-\tif config.AuthenticateClient {\n+\tif config.ClientAuth >= RequestClientCert {\n \t\t// Request a client certificate\n \t\tcertReq := new(certificateRequestMsg)\n \t\tcertReq.certificateTypes = []byte{certTypeRSASign}\n+\n \t\t// An empty list of certificateAuthorities signals to\n \t\t// the client that it may send any certificate in response\n-\t\t// to our request.\n-\n+\t\t// to our request. When we know the CAs we trust, then\n+\t\t// we can send them down, so that the client can choose\n+\t\t// an appropriate certificate to give to us.\n+\t\tif config.ClientCAs != nil {\n+\t\t\tcertReq.certificateAuthorities = config.ClientCAs.Subjects()\n+\t\t}\n \t\tfinishedHash.Write(certReq.marshal())\n \t\tc.writeRecord(recordTypeHandshake, certReq.marshal())\n \t}\n@@ -166,52 +171,87 @@ FindCipherSuite:\n \tfinishedHash.Write(helloDone.marshal())\n \tc.writeRecord(recordTypeHandshake, helloDone.marshal())\n \n-\tvar pub *rsa.PublicKey\n-\tif config.AuthenticateClient {\n-\t\t// Get client certificate\n-\t\tmsg, err = c.readHandshake()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tcertMsg, ok = msg.(*certificateMsg)\n-\t\tif !ok {\n-\t\t\treturn c.sendAlert(alertUnexpectedMessage)\n+\tvar pub *rsa.PublicKey // public key for client auth, if any\n+\n+\tmsg, err = c.readHandshake()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// If we requested a client certificate, then the client must send a\n+\t// certificate message, even if it's empty.\n+\tif config.ClientAuth >= RequestClientCert {\n+\t\tif certMsg, ok = msg.(*certificateMsg); !ok {\n+\t\t\treturn c.sendAlert(alertHandshakeFailure)\n \t\t}\n \t\tfinishedHash.Write(certMsg.marshal())\n \n+\t\tif len(certMsg.certificates) == 0 {\n+\t\t\t// The client didn't actually send a certificate\n+\t\t\tswitch config.ClientAuth {\n+\t\t\tcase RequireAnyClientCert, RequireAndVerifyClientCert:\n+\t\t\t\tc.sendAlert(alertBadCertificate)\n+\t\t\t\treturn errors.New(\"tls: client didn't provide a certificate\")\n+\t\t\t}\n+\t\t}\n+\n \t\tcerts := make([]*x509.Certificate, len(certMsg.certificates))\n \t\tfor i, asn1Data := range certMsg.certificates {\n-\t\t\tcert, err := x509.ParseCertificate(asn1Data)\n-\t\t\tif err != nil {\n+\t\t\tif certs[i], err = x509.ParseCertificate(asn1Data); err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn errors.New(\"could not parse client's certificate: \" + err.Error())\n+\t\t\t\treturn errors.New(\"tls: failed to parse client certificate: \" + err.Error())\n \t\t\t}\n-\t\t\tcerts[i] = cert\n \t\t}\n \n-\t\t// TODO(agl): do better validation of certs: max path length, name restrictions etc.\n-\t\tfor i := 1; i < len(certs); i++ {\n-\t\t\tif err := certs[i-1].CheckSignatureFrom(certs[i]); err != nil {\n+\t\tif c.config.ClientAuth >= VerifyClientCertIfGiven && len(certs) > 0 {\n+\t\t\topts := x509.VerifyOptions{\n+\t\t\t\tRoots:         c.config.ClientCAs,\n+\t\t\t\tCurrentTime:   c.config.time(),\n+\t\t\t\tIntermediates: x509.NewCertPool(),\n+\t\t\t}\n+\n+\t\t\tfor i, cert := range certs {\n+\t\t\t\tif i == 0 {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\topts.Intermediates.AddCert(cert)\n+\t\t\t}\n+\n+\t\t\tchains, err := certs[0].Verify(opts)\n+\t\t\tif err != nil {\n \t\t\t\tc.sendAlert(alertBadCertificate)\n-\t\t\t\treturn errors.New(\"could not validate certificate signature: \" + err.Error())\n+\t\t\t\treturn errors.New(\"tls: failed to verify client's certificate: \" + err.Error())\n \t\t\t}\n+\n+\t\t\tok := false\n+\t\t\tfor _, ku := range certs[0].ExtKeyUsage {\n+\t\t\t\tif ku == x509.ExtKeyUsageClientAuth {\n+\t\t\t\t\tok = true\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif !ok {\n+\t\t\t\tc.sendAlert(alertHandshakeFailure)\n+\t\t\t\treturn errors.New(\"tls: client's certificate's extended key usage doesn't permit it to be used for client authentication\")\n+\t\t\t}\n+\n+\t\t\tc.verifiedChains = chains\n \t\t}\n \n \t\tif len(certs) > 0 {\n-\t\t\tkey, ok := certs[0].PublicKey.(*rsa.PublicKey)\n-\t\t\tif !ok {\n+\t\t\tif pub, ok = certs[0].PublicKey.(*rsa.PublicKey); !ok {\n \t\t\t\treturn c.sendAlert(alertUnsupportedCertificate)\n \t\t\t}\n-\t\t\tpub = key\n \t\t\tc.peerCertificates = certs\n \t\t}\n+\n+\t\tmsg, err = c.readHandshake()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \t// Get client key exchange\n-\tmsg, err = c.readHandshake()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n \tckx, ok := msg.(*clientKeyExchangeMsg)\n \tif !ok {\n \t\treturn c.sendAlert(alertUnexpectedMessage)"}, {"sha": "4bff5327e2c7e242e558fd16655bde4189efa30b", "filename": "libgo/go/crypto/tls/handshake_server_test.go", "status": "modified", "additions": 735, "deletions": 45, "changes": 780, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Fhandshake_server_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,9 +7,12 @@ package tls\n import (\n \t\"bytes\"\n \t\"crypto/rsa\"\n+\t\"crypto/x509\"\n \t\"encoding/hex\"\n+\t\"encoding/pem\"\n \t\"flag\"\n \t\"io\"\n+\t\"log\"\n \t\"math/big\"\n \t\"net\"\n \t\"strconv\"\n@@ -109,16 +112,18 @@ func TestClose(t *testing.T) {\n \t}\n }\n \n-func testServerScript(t *testing.T, name string, serverScript [][]byte, config *Config) {\n+func testServerScript(t *testing.T, name string, serverScript [][]byte, config *Config, peers []*x509.Certificate) {\n \tc, s := net.Pipe()\n \tsrv := Server(s, config)\n+\tpchan := make(chan []*x509.Certificate, 1)\n \tgo func() {\n \t\tsrv.Write([]byte(\"hello, world\\n\"))\n \t\tsrv.Close()\n \t\ts.Close()\n+\t\tst := srv.ConnectionState()\n+\t\tpchan <- st.PeerCertificates\n \t}()\n \n-\tdefer c.Close()\n \tfor i, b := range serverScript {\n \t\tif i%2 == 0 {\n \t\t\tc.Write(b)\n@@ -133,34 +138,66 @@ func testServerScript(t *testing.T, name string, serverScript [][]byte, config *\n \t\t\tt.Fatalf(\"%s #%d: mismatch on read: got:%x want:%x\", name, i, bb, b)\n \t\t}\n \t}\n+\tc.Close()\n+\n+\tif peers != nil {\n+\t\tgotpeers := <-pchan\n+\t\tif len(peers) == len(gotpeers) {\n+\t\t\tfor i, _ := range peers {\n+\t\t\t\tif !peers[i].Equal(gotpeers[i]) {\n+\t\t\t\t\tt.Fatalf(\"%s: mismatch on peer cert %d\", name, i)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t} else {\n+\t\t\tt.Fatalf(\"%s: mismatch on peer list length: %d (wanted) != %d (got)\", name, len(peers), len(gotpeers))\n+\t\t}\n+\t}\n }\n \n func TestHandshakeServerRC4(t *testing.T) {\n-\ttestServerScript(t, \"RC4\", rc4ServerScript, testConfig)\n+\ttestServerScript(t, \"RC4\", rc4ServerScript, testConfig, nil)\n }\n \n func TestHandshakeServer3DES(t *testing.T) {\n \tdes3Config := new(Config)\n \t*des3Config = *testConfig\n \tdes3Config.CipherSuites = []uint16{TLS_RSA_WITH_3DES_EDE_CBC_SHA}\n-\ttestServerScript(t, \"3DES\", des3ServerScript, des3Config)\n+\ttestServerScript(t, \"3DES\", des3ServerScript, des3Config, nil)\n }\n \n func TestHandshakeServerAES(t *testing.T) {\n \taesConfig := new(Config)\n \t*aesConfig = *testConfig\n \taesConfig.CipherSuites = []uint16{TLS_RSA_WITH_AES_128_CBC_SHA}\n-\ttestServerScript(t, \"AES\", aesServerScript, aesConfig)\n+\ttestServerScript(t, \"AES\", aesServerScript, aesConfig, nil)\n }\n \n func TestHandshakeServerSSLv3(t *testing.T) {\n-\ttestServerScript(t, \"SSLv3\", sslv3ServerScript, testConfig)\n+\ttestServerScript(t, \"SSLv3\", sslv3ServerScript, testConfig, nil)\n+}\n+\n+type clientauthTest struct {\n+\tname       string\n+\tclientauth ClientAuthType\n+\tpeers      []*x509.Certificate\n+\tscript     [][]byte\n+}\n+\n+func TestClientAuth(t *testing.T) {\n+\tfor _, cat := range clientauthTests {\n+\t\tt.Log(\"running\", cat.name)\n+\t\tcfg := new(Config)\n+\t\t*cfg = *testConfig\n+\t\tcfg.ClientAuth = cat.clientauth\n+\t\ttestServerScript(t, cat.name, cat.script, cfg, cat.peers)\n+\t}\n }\n \n var serve = flag.Bool(\"serve\", false, \"run a TLS server on :10443\")\n var testCipherSuites = flag.String(\"ciphersuites\",\n \t\"0x\"+strconv.FormatInt(int64(TLS_RSA_WITH_RC4_128_SHA), 16),\n \t\"cipher suites to accept in serving mode\")\n+var testClientAuth = flag.Int(\"clientauth\", 0, \"value for tls.Config.ClientAuth\")\n \n func TestRunServer(t *testing.T) {\n \tif !*serve {\n@@ -177,6 +214,8 @@ func TestRunServer(t *testing.T) {\n \t\ttestConfig.CipherSuites[i] = uint16(suite)\n \t}\n \n+\ttestConfig.ClientAuth = ClientAuthType(*testClientAuth)\n+\n \tl, err := Listen(\"tcp\", \":10443\", testConfig)\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -185,13 +224,23 @@ func TestRunServer(t *testing.T) {\n \tfor {\n \t\tc, err := l.Accept()\n \t\tif err != nil {\n+\t\t\tlog.Printf(\"error from TLS handshake: %s\", err)\n \t\t\tbreak\n \t\t}\n+\n \t\t_, err = c.Write([]byte(\"hello, world\\n\"))\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"error from TLS: %s\", err)\n-\t\t\tbreak\n+\t\t\tlog.Printf(\"error from TLS: %s\", err)\n+\t\t\tcontinue\n \t\t}\n+\n+\t\tst := c.(*Conn).ConnectionState()\n+\t\tif len(st.PeerCertificates) > 0 {\n+\t\t\tlog.Print(\"Handling request from client \", st.PeerCertificates[0].Subject.CommonName)\n+\t\t} else {\n+\t\t\tlog.Print(\"Handling request from anon client\")\n+\t\t}\n+\n \t\tc.Close()\n \t}\n }\n@@ -221,6 +270,18 @@ var testPrivateKey = &rsa.PrivateKey{\n \t},\n }\n \n+func loadPEMCert(in string) *x509.Certificate {\n+\tblock, _ := pem.Decode([]byte(in))\n+\tif block.Type == \"CERTIFICATE\" && len(block.Headers) == 0 {\n+\t\tcert, err := x509.ParseCertificate(block.Bytes)\n+\t\tif err == nil {\n+\t\t\treturn cert\n+\t\t}\n+\t\tpanic(\"error parsing cert\")\n+\t}\n+\tpanic(\"error parsing PEM\")\n+}\n+\n // Script of interaction with gnutls implementation.\n // The values for this test are obtained by building and running in server mode:\n //   % gotest -test.run \"TestRunServer\" -serve\n@@ -229,23 +290,22 @@ var testPrivateKey = &rsa.PrivateKey{\n //   % python parse-gnutls-cli-debug-log.py < /tmp/log\n var rc4ServerScript = [][]byte{\n \t{\n-\t\t0x16, 0x03, 0x02, 0x00, 0x7f, 0x01, 0x00, 0x00,\n-\t\t0x7b, 0x03, 0x02, 0x4d, 0x08, 0x1f, 0x5a, 0x7a,\n-\t\t0x0a, 0x92, 0x2f, 0xf0, 0x73, 0x16, 0x3a, 0x88,\n-\t\t0x14, 0x85, 0x4c, 0x98, 0x15, 0x7b, 0x65, 0xe0,\n-\t\t0x78, 0xd0, 0xed, 0xd0, 0xf3, 0x65, 0x20, 0xeb,\n-\t\t0x80, 0xd1, 0x0b, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n+\t\t0x76, 0x03, 0x02, 0x4e, 0xdd, 0xe6, 0xa5, 0xf7,\n+\t\t0x00, 0x36, 0xf7, 0x83, 0xec, 0x93, 0x7c, 0xd2,\n+\t\t0x4d, 0xe7, 0x7b, 0xf5, 0x4c, 0xf7, 0xe3, 0x86,\n+\t\t0xe8, 0xec, 0x3b, 0xbd, 0x2c, 0x9a, 0x3f, 0x57,\n+\t\t0xf0, 0xa4, 0xd4, 0x00, 0x00, 0x34, 0x00, 0x33,\n \t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n \t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n \t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n \t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n \t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n \t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n-\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x1e, 0x00, 0x09,\n+\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n \t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n \t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n-\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74, 0xff,\n-\t\t0x01, 0x00, 0x01, 0x00,\n+\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n \t},\n \n \t{\n@@ -349,38 +409,46 @@ var rc4ServerScript = [][]byte{\n \n \t{\n \t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n-\t\t0x82, 0x00, 0x80, 0x3c, 0x13, 0xd7, 0x12, 0xc1,\n-\t\t0x6a, 0xf0, 0x3f, 0x8c, 0xa1, 0x35, 0x5d, 0xc5,\n-\t\t0x89, 0x1e, 0x9e, 0xcd, 0x32, 0xc7, 0x9e, 0xe6,\n-\t\t0xae, 0xd5, 0xf1, 0xbf, 0x70, 0xd7, 0xa9, 0xef,\n-\t\t0x2c, 0x4c, 0xf4, 0x22, 0xbc, 0x17, 0x17, 0xaa,\n-\t\t0x05, 0xf3, 0x9f, 0x80, 0xf2, 0xe9, 0x82, 0x2f,\n-\t\t0x2a, 0x15, 0x54, 0x0d, 0x16, 0x0e, 0x77, 0x4c,\n-\t\t0x28, 0x3c, 0x03, 0x2d, 0x2d, 0xd7, 0xc8, 0x64,\n-\t\t0xd9, 0x59, 0x4b, 0x1c, 0xf4, 0xde, 0xff, 0x2f,\n-\t\t0xbc, 0x94, 0xaf, 0x18, 0x26, 0x37, 0xce, 0x4f,\n-\t\t0x84, 0x74, 0x2e, 0x45, 0x66, 0x7c, 0x0c, 0x54,\n-\t\t0x46, 0x36, 0x5f, 0x65, 0x21, 0x7b, 0x83, 0x8c,\n-\t\t0x6d, 0x76, 0xcd, 0x0d, 0x9f, 0xda, 0x1c, 0xa4,\n-\t\t0x6e, 0xfe, 0xb1, 0xf7, 0x09, 0x0d, 0xfb, 0x74,\n-\t\t0x66, 0x34, 0x99, 0x89, 0x7f, 0x5f, 0x77, 0x87,\n-\t\t0x4a, 0x66, 0x4b, 0xa9, 0x59, 0x57, 0xe3, 0x56,\n-\t\t0x0d, 0xdd, 0xd8, 0x14, 0x03, 0x01, 0x00, 0x01,\n-\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xc0, 0x4e,\n-\t\t0xd3, 0x0f, 0xb5, 0xc0, 0x57, 0xa6, 0x18, 0x80,\n-\t\t0x80, 0x6b, 0x49, 0xfe, 0xbd, 0x3a, 0x7a, 0x2c,\n-\t\t0xef, 0x70, 0xb5, 0x1c, 0xd2, 0xdf, 0x5f, 0x78,\n-\t\t0x5a, 0xd8, 0x4f, 0xa0, 0x95, 0xb4, 0xb3, 0xb5,\n-\t\t0xaa, 0x3b,\n+\t\t0x82, 0x00, 0x80, 0x39, 0xe2, 0x0f, 0x49, 0xa0,\n+\t\t0xe6, 0xe4, 0x3b, 0x0c, 0x5f, 0xce, 0x39, 0x97,\n+\t\t0x6c, 0xb6, 0x41, 0xd9, 0xe1, 0x52, 0x8f, 0x43,\n+\t\t0xb3, 0xc6, 0x4f, 0x9a, 0xe2, 0x1e, 0xb9, 0x3b,\n+\t\t0xe3, 0x72, 0x17, 0x68, 0xb2, 0x0d, 0x7b, 0x71,\n+\t\t0x33, 0x96, 0x5c, 0xf9, 0xfe, 0x18, 0x8f, 0x2f,\n+\t\t0x2b, 0x82, 0xec, 0x03, 0xf2, 0x16, 0xa8, 0xf8,\n+\t\t0x39, 0xf9, 0xbb, 0x5a, 0xd3, 0x0c, 0xc1, 0x2a,\n+\t\t0x52, 0xa1, 0x90, 0x20, 0x6b, 0x24, 0xc9, 0x55,\n+\t\t0xee, 0x05, 0xd8, 0xb3, 0x43, 0x58, 0xf6, 0x7f,\n+\t\t0x68, 0x2d, 0xb3, 0xd1, 0x1b, 0x30, 0xaa, 0xdf,\n+\t\t0xfc, 0x85, 0xf1, 0xab, 0x14, 0x51, 0x91, 0x78,\n+\t\t0x29, 0x35, 0x65, 0xe0, 0x9c, 0xf6, 0xb7, 0x35,\n+\t\t0x33, 0xdb, 0x28, 0x93, 0x4d, 0x86, 0xbc, 0xfe,\n+\t\t0xaa, 0xd1, 0xc0, 0x2e, 0x4d, 0xec, 0xa2, 0x98,\n+\t\t0xca, 0x08, 0xb2, 0x91, 0x14, 0xde, 0x97, 0x3a,\n+\t\t0xc4, 0x6b, 0x49, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0x7a, 0xcb,\n+\t\t0x3b, 0x0e, 0xbb, 0x7a, 0x56, 0x39, 0xaf, 0x83,\n+\t\t0xae, 0xfd, 0x25, 0xfd, 0x64, 0xb4, 0x0c, 0x0c,\n+\t\t0x17, 0x46, 0x54, 0x2c, 0x6a, 0x07, 0x83, 0xc6,\n+\t\t0x46, 0x08, 0x0b, 0xcd, 0x15, 0x53, 0xef, 0x40,\n+\t\t0x4e, 0x56,\n \t},\n \n \t{\n \t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n-\t\t0x01, 0x00, 0x24, 0x9d, 0xc9, 0xda, 0xdf, 0xeb,\n-\t\t0xc8, 0xdb, 0xf8, 0x94, 0xa5, 0xef, 0xd5, 0xfc,\n-\t\t0x89, 0x01, 0x64, 0x30, 0x77, 0x5a, 0x18, 0x4b,\n-\t\t0x16, 0x79, 0x9c, 0xf6, 0xf5, 0x09, 0x22, 0x12,\n-\t\t0x4c, 0x3e, 0xa8, 0x8e, 0x91, 0xa5, 0x24,\n+\t\t0x01, 0x00, 0x24, 0xd3, 0x72, 0xeb, 0x29, 0xb9,\n+\t\t0x15, 0x29, 0xb5, 0xe5, 0xb7, 0xef, 0x5c, 0xb2,\n+\t\t0x9d, 0xf6, 0xc8, 0x47, 0xd6, 0xa0, 0x84, 0xf0,\n+\t\t0x8c, 0xcb, 0xe6, 0xbe, 0xbc, 0xfb, 0x38, 0x90,\n+\t\t0x89, 0x60, 0xa2, 0xe8, 0xaa, 0xb3, 0x12, 0x17,\n+\t\t0x03, 0x01, 0x00, 0x21, 0x67, 0x4a, 0x3d, 0x31,\n+\t\t0x6c, 0x5a, 0x1c, 0xf9, 0x6e, 0xf1, 0xd8, 0x12,\n+\t\t0x0e, 0xb9, 0xfd, 0xfc, 0x66, 0x91, 0xd1, 0x1d,\n+\t\t0x6e, 0xe4, 0x55, 0xdd, 0x11, 0xb9, 0xb8, 0xa2,\n+\t\t0x65, 0xa1, 0x95, 0x64, 0x1c, 0x15, 0x03, 0x01,\n+\t\t0x00, 0x16, 0x9b, 0xa0, 0x24, 0xe3, 0xcb, 0xae,\n+\t\t0xad, 0x51, 0xb3, 0x63, 0x59, 0x78, 0x49, 0x24,\n+\t\t0x06, 0x6e, 0xee, 0x7a, 0xd7, 0x74, 0x53, 0x04,\n \t},\n }\n \n@@ -878,3 +946,625 @@ var sslv3ServerScript = [][]byte{\n \t\t0xaf, 0xd3, 0xb7, 0xa3, 0xcc, 0x4a, 0x1d, 0x2e,\n \t},\n }\n+\n+var clientauthTests = []clientauthTest{\n+\t// Server doesn't asks for cert\n+\t// gotest -test.run \"TestRunServer\" -serve -clientauth 0\n+\t// gnutls-cli --insecure --debug 100 -p 10443 localhost 2>&1 |\n+\t//   python parse-gnutls-cli-debug-log.py\n+\t{\"NoClientCert\", NoClientCert, nil,\n+\t\t[][]byte{{\n+\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n+\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe0, 0x92, 0x5d, 0xcd,\n+\t\t\t0xfe, 0x0c, 0x69, 0xd4, 0x7d, 0x8e, 0xa6, 0x88,\n+\t\t\t0xde, 0x72, 0x04, 0x29, 0x6a, 0x4a, 0x16, 0x23,\n+\t\t\t0xd7, 0x8f, 0xbc, 0xfa, 0x80, 0x73, 0x2e, 0x12,\n+\t\t\t0xb7, 0x0b, 0x39, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n+\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x04, 0x0e,\n+\t\t\t\t0x00, 0x00, 0x00,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t\t\t0x82, 0x00, 0x80, 0x10, 0xe1, 0x00, 0x3d, 0x0a,\n+\t\t\t\t0x6b, 0x02, 0x7f, 0x97, 0xde, 0xfb, 0x65, 0x46,\n+\t\t\t\t0x1a, 0x50, 0x4e, 0x34, 0x9a, 0xae, 0x14, 0x7e,\n+\t\t\t\t0xec, 0xef, 0x85, 0x15, 0x3b, 0x39, 0xc2, 0x45,\n+\t\t\t\t0x04, 0x40, 0x92, 0x71, 0xd6, 0x7e, 0xf6, 0xfd,\n+\t\t\t\t0x4d, 0x84, 0xf7, 0xc4, 0x77, 0x99, 0x3d, 0xe2,\n+\t\t\t\t0xc3, 0x8d, 0xb0, 0x4c, 0x74, 0xc8, 0x51, 0xec,\n+\t\t\t\t0xb2, 0xe8, 0x6b, 0xa1, 0xd2, 0x4d, 0xd8, 0x61,\n+\t\t\t\t0x92, 0x7a, 0x24, 0x57, 0x44, 0x4f, 0xa2, 0x1e,\n+\t\t\t\t0x74, 0x0b, 0x06, 0x4b, 0x80, 0x34, 0x8b, 0xfe,\n+\t\t\t\t0xc2, 0x0e, 0xc1, 0xcd, 0xab, 0x0c, 0x3f, 0x54,\n+\t\t\t\t0xe2, 0x44, 0xe9, 0x6c, 0x2b, 0xba, 0x7b, 0x64,\n+\t\t\t\t0xf1, 0x93, 0x65, 0x75, 0xf2, 0x35, 0xff, 0x27,\n+\t\t\t\t0x03, 0xd5, 0x64, 0xe6, 0x8e, 0xe7, 0x7b, 0x56,\n+\t\t\t\t0xb6, 0x61, 0x73, 0xeb, 0xa2, 0xdc, 0xa4, 0x6e,\n+\t\t\t\t0x52, 0xac, 0xbc, 0xba, 0x11, 0xa3, 0xd2, 0x61,\n+\t\t\t\t0x4a, 0xe0, 0xbb, 0x14, 0x03, 0x01, 0x00, 0x01,\n+\t\t\t\t0x01, 0x16, 0x03, 0x01, 0x00, 0x24, 0xd2, 0x5a,\n+\t\t\t\t0x0c, 0x2a, 0x27, 0x96, 0xba, 0xa9, 0x67, 0xd2,\n+\t\t\t\t0x51, 0x68, 0x32, 0x68, 0x22, 0x1f, 0xb9, 0x27,\n+\t\t\t\t0x79, 0x59, 0x28, 0xdf, 0x38, 0x1f, 0x92, 0x21,\n+\t\t\t\t0x5d, 0x0f, 0xf4, 0xc0, 0xee, 0xb7, 0x10, 0x5a,\n+\t\t\t\t0xa9, 0x45,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t\t\t0x01, 0x00, 0x24, 0x13, 0x6f, 0x6c, 0x71, 0x83,\n+\t\t\t\t0x59, 0xcf, 0x32, 0x72, 0xe9, 0xce, 0xcc, 0x7a,\n+\t\t\t\t0x6c, 0xf0, 0x72, 0x39, 0x16, 0xae, 0x40, 0x61,\n+\t\t\t\t0xfa, 0x92, 0x4c, 0xe7, 0xf2, 0x1a, 0xd7, 0x0c,\n+\t\t\t\t0x84, 0x76, 0x6c, 0xe9, 0x11, 0x43, 0x19, 0x17,\n+\t\t\t\t0x03, 0x01, 0x00, 0x21, 0xc0, 0xa2, 0x13, 0x28,\n+\t\t\t\t0x94, 0x8c, 0x5c, 0xd6, 0x79, 0xb9, 0xfe, 0xae,\n+\t\t\t\t0x45, 0x4b, 0xc0, 0x7c, 0xae, 0x2d, 0xb4, 0x0d,\n+\t\t\t\t0x31, 0xc4, 0xad, 0x22, 0xd7, 0x1e, 0x99, 0x1c,\n+\t\t\t\t0x4c, 0x69, 0xab, 0x42, 0x61, 0x15, 0x03, 0x01,\n+\t\t\t\t0x00, 0x16, 0xe1, 0x0c, 0x67, 0xf3, 0xf4, 0xb9,\n+\t\t\t\t0x8e, 0x81, 0x8e, 0x01, 0xb8, 0xa0, 0x69, 0x8c,\n+\t\t\t\t0x03, 0x11, 0x43, 0x3e, 0xee, 0xb7, 0x4d, 0x69,\n+\t\t\t}}},\n+\t// Server asks for cert with empty CA list, client doesn't give it.\n+\t// gotest -test.run \"TestRunServer\" -serve -clientauth 1\n+\t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n+\t{\"RequestClientCert, none given\", RequestClientCert, nil,\n+\t\t[][]byte{{\n+\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n+\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe0, 0x93, 0xe2, 0x47,\n+\t\t\t0x06, 0xa0, 0x61, 0x0c, 0x51, 0xdd, 0xf0, 0xef,\n+\t\t\t0xf4, 0x30, 0x72, 0xe1, 0xa6, 0x50, 0x68, 0x82,\n+\t\t\t0x3c, 0xfb, 0xcb, 0x72, 0x5e, 0x73, 0x9d, 0xda,\n+\t\t\t0x27, 0x35, 0x72, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n+\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n+\t\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n+\t\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x07, 0x0b, 0x00, 0x00,\n+\t\t\t\t0x03, 0x00, 0x00, 0x00, 0x16, 0x03, 0x01, 0x00,\n+\t\t\t\t0x86, 0x10, 0x00, 0x00, 0x82, 0x00, 0x80, 0x64,\n+\t\t\t\t0x28, 0xb9, 0x3f, 0x48, 0xaf, 0x06, 0x22, 0x39,\n+\t\t\t\t0x56, 0xd8, 0x6f, 0x63, 0x5d, 0x03, 0x48, 0x63,\n+\t\t\t\t0x01, 0x13, 0xa2, 0xd6, 0x76, 0xc0, 0xab, 0xda,\n+\t\t\t\t0x25, 0x30, 0x75, 0x6c, 0xaa, 0xb4, 0xdc, 0x35,\n+\t\t\t\t0x72, 0xdc, 0xf2, 0x43, 0xe4, 0x1d, 0x82, 0xfb,\n+\t\t\t\t0x6c, 0x64, 0xe2, 0xa7, 0x8f, 0x32, 0x67, 0x6b,\n+\t\t\t\t0xcd, 0xd2, 0xb2, 0x36, 0x94, 0xbc, 0x6f, 0x46,\n+\t\t\t\t0x79, 0x29, 0x42, 0xe3, 0x1a, 0xbf, 0xfb, 0x41,\n+\t\t\t\t0xd5, 0xe3, 0xb4, 0x2a, 0xf6, 0x95, 0x6f, 0x0c,\n+\t\t\t\t0x87, 0xb9, 0x03, 0x18, 0xa1, 0xea, 0x4a, 0xe2,\n+\t\t\t\t0x2e, 0x0f, 0x50, 0x00, 0xc1, 0xe8, 0x8c, 0xc8,\n+\t\t\t\t0xa2, 0xf6, 0xa4, 0x05, 0xf4, 0x38, 0x3e, 0xd9,\n+\t\t\t\t0x6e, 0x63, 0x96, 0x0c, 0x34, 0x73, 0x90, 0x03,\n+\t\t\t\t0x55, 0xa6, 0x34, 0xb0, 0x5e, 0x8c, 0x48, 0x40,\n+\t\t\t\t0x25, 0x45, 0x84, 0xa6, 0x21, 0x3f, 0x81, 0x97,\n+\t\t\t\t0xa7, 0x11, 0x09, 0x14, 0x95, 0xa5, 0xe5, 0x14,\n+\t\t\t\t0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01,\n+\t\t\t\t0x00, 0x24, 0x16, 0xaa, 0x01, 0x2c, 0xa8, 0xc1,\n+\t\t\t\t0x28, 0xaf, 0x35, 0xc1, 0xc1, 0xf3, 0x0a, 0x25,\n+\t\t\t\t0x66, 0x6e, 0x27, 0x11, 0xa3, 0xa4, 0xd9, 0xe9,\n+\t\t\t\t0xea, 0x15, 0x09, 0x9d, 0x28, 0xe3, 0x5b, 0x2b,\n+\t\t\t\t0xa6, 0x25, 0xa7, 0x14, 0x24, 0x3a,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t\t\t0x01, 0x00, 0x24, 0x9a, 0xa8, 0xd6, 0x77, 0x46,\n+\t\t\t\t0x45, 0x68, 0x9d, 0x5d, 0xa9, 0x68, 0x03, 0xe5,\n+\t\t\t\t0xaf, 0xe8, 0xc8, 0x21, 0xc5, 0xc6, 0xc1, 0x50,\n+\t\t\t\t0xe0, 0xd8, 0x52, 0xce, 0xa3, 0x4f, 0x2d, 0xf4,\n+\t\t\t\t0xe3, 0xa7, 0x7d, 0x35, 0x80, 0x84, 0x12, 0x17,\n+\t\t\t\t0x03, 0x01, 0x00, 0x21, 0x8a, 0x82, 0x0c, 0x54,\n+\t\t\t\t0x1b, 0xeb, 0x77, 0x90, 0x2c, 0x3e, 0xbc, 0xf0,\n+\t\t\t\t0x23, 0xcc, 0xa8, 0x9f, 0x25, 0x08, 0x12, 0xed,\n+\t\t\t\t0x43, 0xf1, 0xf9, 0x06, 0xad, 0xa9, 0x4b, 0x97,\n+\t\t\t\t0x82, 0xb7, 0xc4, 0x0b, 0x4c, 0x15, 0x03, 0x01,\n+\t\t\t\t0x00, 0x16, 0x05, 0x2d, 0x9d, 0x45, 0x03, 0xb7,\n+\t\t\t\t0xc2, 0xd1, 0xb5, 0x1a, 0x43, 0xcf, 0x1a, 0x37,\n+\t\t\t\t0xf4, 0x70, 0xcc, 0xb4, 0xed, 0x07, 0x76, 0x3a,\n+\t\t\t}}},\n+\t// Server asks for cert with empty CA list, client gives one\n+\t// gotest -test.run \"TestRunServer\" -serve -clientauth 1\n+\t// gnutls-cli --insecure --debug 100 -p 10443 localhost\n+\t{\"RequestClientCert, client gives it\", RequestClientCert,\n+\t\t[]*x509.Certificate{clicert},\n+\t\t[][]byte{{\n+\t\t\t0x16, 0x03, 0x02, 0x00, 0x7a, 0x01, 0x00, 0x00,\n+\t\t\t0x76, 0x03, 0x02, 0x4e, 0xe7, 0x44, 0xda, 0x58,\n+\t\t\t0x7d, 0x46, 0x4a, 0x48, 0x97, 0x9f, 0xe5, 0x91,\n+\t\t\t0x11, 0x64, 0xa7, 0x1e, 0x4d, 0xb7, 0xfe, 0x9b,\n+\t\t\t0xc6, 0x63, 0xf8, 0xa4, 0xb5, 0x0b, 0x18, 0xb5,\n+\t\t\t0xbd, 0x19, 0xb3, 0x00, 0x00, 0x34, 0x00, 0x33,\n+\t\t\t0x00, 0x45, 0x00, 0x39, 0x00, 0x88, 0x00, 0x16,\n+\t\t\t0x00, 0x32, 0x00, 0x44, 0x00, 0x38, 0x00, 0x87,\n+\t\t\t0x00, 0x13, 0x00, 0x66, 0x00, 0x90, 0x00, 0x91,\n+\t\t\t0x00, 0x8f, 0x00, 0x8e, 0x00, 0x2f, 0x00, 0x41,\n+\t\t\t0x00, 0x35, 0x00, 0x84, 0x00, 0x0a, 0x00, 0x05,\n+\t\t\t0x00, 0x04, 0x00, 0x8c, 0x00, 0x8d, 0x00, 0x8b,\n+\t\t\t0x00, 0x8a, 0x01, 0x00, 0x00, 0x19, 0x00, 0x09,\n+\t\t\t0x00, 0x03, 0x02, 0x00, 0x01, 0x00, 0x00, 0x00,\n+\t\t\t0x0e, 0x00, 0x0c, 0x00, 0x00, 0x09, 0x6c, 0x6f,\n+\t\t\t0x63, 0x61, 0x6c, 0x68, 0x6f, 0x73, 0x74,\n+\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x2a, 0x02, 0x00, 0x00,\n+\t\t\t\t0x26, 0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\n+\t\t\t\t0x00, 0x00, 0x00, 0x00, 0x00, 0x05, 0x00, 0x16,\n+\t\t\t\t0x03, 0x01, 0x02, 0xbe, 0x0b, 0x00, 0x02, 0xba,\n+\t\t\t\t0x00, 0x02, 0xb7, 0x00, 0x02, 0xb4, 0x30, 0x82,\n+\t\t\t\t0x02, 0xb0, 0x30, 0x82, 0x02, 0x19, 0xa0, 0x03,\n+\t\t\t\t0x02, 0x01, 0x02, 0x02, 0x09, 0x00, 0x85, 0xb0,\n+\t\t\t\t0xbb, 0xa4, 0x8a, 0x7f, 0xb8, 0xca, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x05, 0x05, 0x00, 0x30, 0x45, 0x31,\n+\t\t\t\t0x0b, 0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06,\n+\t\t\t\t0x13, 0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11,\n+\t\t\t\t0x06, 0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53,\n+\t\t\t\t0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74,\n+\t\t\t\t0x65, 0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65,\n+\t\t\t\t0x72, 0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64,\n+\t\t\t\t0x67, 0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79,\n+\t\t\t\t0x20, 0x4c, 0x74, 0x64, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t\t0x31, 0x30, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39,\n+\t\t\t\t0x30, 0x39, 0x33, 0x38, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t\t0x31, 0x30, 0x34, 0x32, 0x34, 0x30, 0x39, 0x30,\n+\t\t\t\t0x39, 0x33, 0x38, 0x5a, 0x30, 0x45, 0x31, 0x0b,\n+\t\t\t\t0x30, 0x09, 0x06, 0x03, 0x55, 0x04, 0x06, 0x13,\n+\t\t\t\t0x02, 0x41, 0x55, 0x31, 0x13, 0x30, 0x11, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x08, 0x13, 0x0a, 0x53, 0x6f,\n+\t\t\t\t0x6d, 0x65, 0x2d, 0x53, 0x74, 0x61, 0x74, 0x65,\n+\t\t\t\t0x31, 0x21, 0x30, 0x1f, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t\t0x0a, 0x13, 0x18, 0x49, 0x6e, 0x74, 0x65, 0x72,\n+\t\t\t\t0x6e, 0x65, 0x74, 0x20, 0x57, 0x69, 0x64, 0x67,\n+\t\t\t\t0x69, 0x74, 0x73, 0x20, 0x50, 0x74, 0x79, 0x20,\n+\t\t\t\t0x4c, 0x74, 0x64, 0x30, 0x81, 0x9f, 0x30, 0x0d,\n+\t\t\t\t0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7, 0x0d,\n+\t\t\t\t0x01, 0x01, 0x01, 0x05, 0x00, 0x03, 0x81, 0x8d,\n+\t\t\t\t0x00, 0x30, 0x81, 0x89, 0x02, 0x81, 0x81, 0x00,\n+\t\t\t\t0xbb, 0x79, 0xd6, 0xf5, 0x17, 0xb5, 0xe5, 0xbf,\n+\t\t\t\t0x46, 0x10, 0xd0, 0xdc, 0x69, 0xbe, 0xe6, 0x2b,\n+\t\t\t\t0x07, 0x43, 0x5a, 0xd0, 0x03, 0x2d, 0x8a, 0x7a,\n+\t\t\t\t0x43, 0x85, 0xb7, 0x14, 0x52, 0xe7, 0xa5, 0x65,\n+\t\t\t\t0x4c, 0x2c, 0x78, 0xb8, 0x23, 0x8c, 0xb5, 0xb4,\n+\t\t\t\t0x82, 0xe5, 0xde, 0x1f, 0x95, 0x3b, 0x7e, 0x62,\n+\t\t\t\t0xa5, 0x2c, 0xa5, 0x33, 0xd6, 0xfe, 0x12, 0x5c,\n+\t\t\t\t0x7a, 0x56, 0xfc, 0xf5, 0x06, 0xbf, 0xfa, 0x58,\n+\t\t\t\t0x7b, 0x26, 0x3f, 0xb5, 0xcd, 0x04, 0xd3, 0xd0,\n+\t\t\t\t0xc9, 0x21, 0x96, 0x4a, 0xc7, 0xf4, 0x54, 0x9f,\n+\t\t\t\t0x5a, 0xbf, 0xef, 0x42, 0x71, 0x00, 0xfe, 0x18,\n+\t\t\t\t0x99, 0x07, 0x7f, 0x7e, 0x88, 0x7d, 0x7d, 0xf1,\n+\t\t\t\t0x04, 0x39, 0xc4, 0xa2, 0x2e, 0xdb, 0x51, 0xc9,\n+\t\t\t\t0x7c, 0xe3, 0xc0, 0x4c, 0x3b, 0x32, 0x66, 0x01,\n+\t\t\t\t0xcf, 0xaf, 0xb1, 0x1d, 0xb8, 0x71, 0x9a, 0x1d,\n+\t\t\t\t0xdb, 0xdb, 0x89, 0x6b, 0xae, 0xda, 0x2d, 0x79,\n+\t\t\t\t0x02, 0x03, 0x01, 0x00, 0x01, 0xa3, 0x81, 0xa7,\n+\t\t\t\t0x30, 0x81, 0xa4, 0x30, 0x1d, 0x06, 0x03, 0x55,\n+\t\t\t\t0x1d, 0x0e, 0x04, 0x16, 0x04, 0x14, 0xb1, 0xad,\n+\t\t\t\t0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb, 0x69,\n+\t\t\t\t0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e, 0x18,\n+\t\t\t\t0x88, 0x39, 0x30, 0x75, 0x06, 0x03, 0x55, 0x1d,\n+\t\t\t\t0x23, 0x04, 0x6e, 0x30, 0x6c, 0x80, 0x14, 0xb1,\n+\t\t\t\t0xad, 0xe2, 0x85, 0x5a, 0xcf, 0xcb, 0x28, 0xdb,\n+\t\t\t\t0x69, 0xce, 0x23, 0x69, 0xde, 0xd3, 0x26, 0x8e,\n+\t\t\t\t0x18, 0x88, 0x39, 0xa1, 0x49, 0xa4, 0x47, 0x30,\n+\t\t\t\t0x45, 0x31, 0x0b, 0x30, 0x09, 0x06, 0x03, 0x55,\n+\t\t\t\t0x04, 0x06, 0x13, 0x02, 0x41, 0x55, 0x31, 0x13,\n+\t\t\t\t0x30, 0x11, 0x06, 0x03, 0x55, 0x04, 0x08, 0x13,\n+\t\t\t\t0x0a, 0x53, 0x6f, 0x6d, 0x65, 0x2d, 0x53, 0x74,\n+\t\t\t\t0x61, 0x74, 0x65, 0x31, 0x21, 0x30, 0x1f, 0x06,\n+\t\t\t\t0x03, 0x55, 0x04, 0x0a, 0x13, 0x18, 0x49, 0x6e,\n+\t\t\t\t0x74, 0x65, 0x72, 0x6e, 0x65, 0x74, 0x20, 0x57,\n+\t\t\t\t0x69, 0x64, 0x67, 0x69, 0x74, 0x73, 0x20, 0x50,\n+\t\t\t\t0x74, 0x79, 0x20, 0x4c, 0x74, 0x64, 0x82, 0x09,\n+\t\t\t\t0x00, 0x85, 0xb0, 0xbb, 0xa4, 0x8a, 0x7f, 0xb8,\n+\t\t\t\t0xca, 0x30, 0x0c, 0x06, 0x03, 0x55, 0x1d, 0x13,\n+\t\t\t\t0x04, 0x05, 0x30, 0x03, 0x01, 0x01, 0xff, 0x30,\n+\t\t\t\t0x0d, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x05, 0x00, 0x03, 0x81,\n+\t\t\t\t0x81, 0x00, 0x08, 0x6c, 0x45, 0x24, 0xc7, 0x6b,\n+\t\t\t\t0xb1, 0x59, 0xab, 0x0c, 0x52, 0xcc, 0xf2, 0xb0,\n+\t\t\t\t0x14, 0xd7, 0x87, 0x9d, 0x7a, 0x64, 0x75, 0xb5,\n+\t\t\t\t0x5a, 0x95, 0x66, 0xe4, 0xc5, 0x2b, 0x8e, 0xae,\n+\t\t\t\t0x12, 0x66, 0x1f, 0xeb, 0x4f, 0x38, 0xb3, 0x6e,\n+\t\t\t\t0x60, 0xd3, 0x92, 0xfd, 0xf7, 0x41, 0x08, 0xb5,\n+\t\t\t\t0x25, 0x13, 0xb1, 0x18, 0x7a, 0x24, 0xfb, 0x30,\n+\t\t\t\t0x1d, 0xba, 0xed, 0x98, 0xb9, 0x17, 0xec, 0xe7,\n+\t\t\t\t0xd7, 0x31, 0x59, 0xdb, 0x95, 0xd3, 0x1d, 0x78,\n+\t\t\t\t0xea, 0x50, 0x56, 0x5c, 0xd5, 0x82, 0x5a, 0x2d,\n+\t\t\t\t0x5a, 0x5f, 0x33, 0xc4, 0xb6, 0xd8, 0xc9, 0x75,\n+\t\t\t\t0x90, 0x96, 0x8c, 0x0f, 0x52, 0x98, 0xb5, 0xcd,\n+\t\t\t\t0x98, 0x1f, 0x89, 0x20, 0x5f, 0xf2, 0xa0, 0x1c,\n+\t\t\t\t0xa3, 0x1b, 0x96, 0x94, 0xdd, 0xa9, 0xfd, 0x57,\n+\t\t\t\t0xe9, 0x70, 0xe8, 0x26, 0x6d, 0x71, 0x99, 0x9b,\n+\t\t\t\t0x26, 0x6e, 0x38, 0x50, 0x29, 0x6c, 0x90, 0xa7,\n+\t\t\t\t0xbd, 0xd9, 0x16, 0x03, 0x01, 0x00, 0x08, 0x0d,\n+\t\t\t\t0x00, 0x00, 0x04, 0x01, 0x01, 0x00, 0x00, 0x16,\n+\t\t\t\t0x03, 0x01, 0x00, 0x04, 0x0e, 0x00, 0x00, 0x00,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x16, 0x03, 0x01, 0x01, 0xfb, 0x0b, 0x00, 0x01,\n+\t\t\t\t0xf7, 0x00, 0x01, 0xf4, 0x00, 0x01, 0xf1, 0x30,\n+\t\t\t\t0x82, 0x01, 0xed, 0x30, 0x82, 0x01, 0x58, 0xa0,\n+\t\t\t\t0x03, 0x02, 0x01, 0x02, 0x02, 0x01, 0x00, 0x30,\n+\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x30, 0x26, 0x31, 0x10,\n+\t\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n+\t\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n+\t\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x1e, 0x17, 0x0d,\n+\t\t\t\t0x31, 0x31, 0x31, 0x32, 0x30, 0x38, 0x30, 0x37,\n+\t\t\t\t0x35, 0x35, 0x31, 0x32, 0x5a, 0x17, 0x0d, 0x31,\n+\t\t\t\t0x32, 0x31, 0x32, 0x30, 0x37, 0x30, 0x38, 0x30,\n+\t\t\t\t0x30, 0x31, 0x32, 0x5a, 0x30, 0x26, 0x31, 0x10,\n+\t\t\t\t0x30, 0x0e, 0x06, 0x03, 0x55, 0x04, 0x0a, 0x13,\n+\t\t\t\t0x07, 0x41, 0x63, 0x6d, 0x65, 0x20, 0x43, 0x6f,\n+\t\t\t\t0x31, 0x12, 0x30, 0x10, 0x06, 0x03, 0x55, 0x04,\n+\t\t\t\t0x03, 0x13, 0x09, 0x31, 0x32, 0x37, 0x2e, 0x30,\n+\t\t\t\t0x2e, 0x30, 0x2e, 0x31, 0x30, 0x81, 0x9c, 0x30,\n+\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x01, 0x03, 0x81, 0x8c, 0x00,\n+\t\t\t\t0x30, 0x81, 0x88, 0x02, 0x81, 0x80, 0x4e, 0xd0,\n+\t\t\t\t0x7b, 0x31, 0xe3, 0x82, 0x64, 0xd9, 0x59, 0xc0,\n+\t\t\t\t0xc2, 0x87, 0xa4, 0x5e, 0x1e, 0x8b, 0x73, 0x33,\n+\t\t\t\t0xc7, 0x63, 0x53, 0xdf, 0x66, 0x92, 0x06, 0x84,\n+\t\t\t\t0xf6, 0x64, 0xd5, 0x8f, 0xe4, 0x36, 0xa7, 0x1d,\n+\t\t\t\t0x2b, 0xe8, 0xb3, 0x20, 0x36, 0x45, 0x23, 0xb5,\n+\t\t\t\t0xe3, 0x95, 0xae, 0xed, 0xe0, 0xf5, 0x20, 0x9c,\n+\t\t\t\t0x8d, 0x95, 0xdf, 0x7f, 0x5a, 0x12, 0xef, 0x87,\n+\t\t\t\t0xe4, 0x5b, 0x68, 0xe4, 0xe9, 0x0e, 0x74, 0xec,\n+\t\t\t\t0x04, 0x8a, 0x7f, 0xde, 0x93, 0x27, 0xc4, 0x01,\n+\t\t\t\t0x19, 0x7a, 0xbd, 0xf2, 0xdc, 0x3d, 0x14, 0xab,\n+\t\t\t\t0xd0, 0x54, 0xca, 0x21, 0x0c, 0xd0, 0x4d, 0x6e,\n+\t\t\t\t0x87, 0x2e, 0x5c, 0xc5, 0xd2, 0xbb, 0x4d, 0x4b,\n+\t\t\t\t0x4f, 0xce, 0xb6, 0x2c, 0xf7, 0x7e, 0x88, 0xec,\n+\t\t\t\t0x7c, 0xd7, 0x02, 0x91, 0x74, 0xa6, 0x1e, 0x0c,\n+\t\t\t\t0x1a, 0xda, 0xe3, 0x4a, 0x5a, 0x2e, 0xde, 0x13,\n+\t\t\t\t0x9c, 0x4c, 0x40, 0x88, 0x59, 0x93, 0x02, 0x03,\n+\t\t\t\t0x01, 0x00, 0x01, 0xa3, 0x32, 0x30, 0x30, 0x30,\n+\t\t\t\t0x0e, 0x06, 0x03, 0x55, 0x1d, 0x0f, 0x01, 0x01,\n+\t\t\t\t0xff, 0x04, 0x04, 0x03, 0x02, 0x00, 0xa0, 0x30,\n+\t\t\t\t0x0d, 0x06, 0x03, 0x55, 0x1d, 0x0e, 0x04, 0x06,\n+\t\t\t\t0x04, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30, 0x0f,\n+\t\t\t\t0x06, 0x03, 0x55, 0x1d, 0x23, 0x04, 0x08, 0x30,\n+\t\t\t\t0x06, 0x80, 0x04, 0x01, 0x02, 0x03, 0x04, 0x30,\n+\t\t\t\t0x0b, 0x06, 0x09, 0x2a, 0x86, 0x48, 0x86, 0xf7,\n+\t\t\t\t0x0d, 0x01, 0x01, 0x05, 0x03, 0x81, 0x81, 0x00,\n+\t\t\t\t0x36, 0x1f, 0xb3, 0x7a, 0x0c, 0x75, 0xc9, 0x6e,\n+\t\t\t\t0x37, 0x46, 0x61, 0x2b, 0xd5, 0xbd, 0xc0, 0xa7,\n+\t\t\t\t0x4b, 0xcc, 0x46, 0x9a, 0x81, 0x58, 0x7c, 0x85,\n+\t\t\t\t0x79, 0x29, 0xc8, 0xc8, 0xc6, 0x67, 0xdd, 0x32,\n+\t\t\t\t0x56, 0x45, 0x2b, 0x75, 0xb6, 0xe9, 0x24, 0xa9,\n+\t\t\t\t0x50, 0x9a, 0xbe, 0x1f, 0x5a, 0xfa, 0x1a, 0x15,\n+\t\t\t\t0xd9, 0xcc, 0x55, 0x95, 0x72, 0x16, 0x83, 0xb9,\n+\t\t\t\t0xc2, 0xb6, 0x8f, 0xfd, 0x88, 0x8c, 0x38, 0x84,\n+\t\t\t\t0x1d, 0xab, 0x5d, 0x92, 0x31, 0x13, 0x4f, 0xfd,\n+\t\t\t\t0x83, 0x3b, 0xc6, 0x9d, 0xf1, 0x11, 0x62, 0xb6,\n+\t\t\t\t0x8b, 0xec, 0xab, 0x67, 0xbe, 0xc8, 0x64, 0xb0,\n+\t\t\t\t0x11, 0x50, 0x46, 0x58, 0x17, 0x6b, 0x99, 0x1c,\n+\t\t\t\t0xd3, 0x1d, 0xfc, 0x06, 0xf1, 0x0e, 0xe5, 0x96,\n+\t\t\t\t0xa8, 0x0c, 0xf9, 0x78, 0x20, 0xb7, 0x44, 0x18,\n+\t\t\t\t0x51, 0x8d, 0x10, 0x7e, 0x4f, 0x94, 0x67, 0xdf,\n+\t\t\t\t0xa3, 0x4e, 0x70, 0x73, 0x8e, 0x90, 0x91, 0x85,\n+\t\t\t\t0x16, 0x03, 0x01, 0x00, 0x86, 0x10, 0x00, 0x00,\n+\t\t\t\t0x82, 0x00, 0x80, 0xa7, 0x2f, 0xed, 0xfa, 0xc2,\n+\t\t\t\t0xbd, 0x46, 0xa1, 0xf2, 0x69, 0xc5, 0x1d, 0xa1,\n+\t\t\t\t0x34, 0xd6, 0xd0, 0x84, 0xf5, 0x5d, 0x8c, 0x82,\n+\t\t\t\t0x8d, 0x98, 0x82, 0x9c, 0xd9, 0x07, 0xe0, 0xf7,\n+\t\t\t\t0x55, 0x49, 0x4d, 0xa1, 0x48, 0x59, 0x02, 0xd3,\n+\t\t\t\t0x84, 0x37, 0xaf, 0x01, 0xb3, 0x3a, 0xf4, 0xed,\n+\t\t\t\t0x99, 0xbe, 0x67, 0x36, 0x19, 0x55, 0xf3, 0xf9,\n+\t\t\t\t0xcb, 0x94, 0xe5, 0x7b, 0x8b, 0x77, 0xf2, 0x5f,\n+\t\t\t\t0x4c, 0xfe, 0x01, 0x1f, 0x7b, 0xd7, 0x23, 0x49,\n+\t\t\t\t0x0c, 0xcb, 0x6c, 0xb0, 0xe7, 0x77, 0xd6, 0xcf,\n+\t\t\t\t0xa8, 0x7d, 0xdb, 0xa7, 0x14, 0xe2, 0xf5, 0xf3,\n+\t\t\t\t0xff, 0xba, 0x23, 0xd2, 0x9a, 0x36, 0x14, 0x60,\n+\t\t\t\t0x2a, 0x91, 0x5d, 0x2b, 0x35, 0x3b, 0xb6, 0xdd,\n+\t\t\t\t0xcb, 0x6b, 0xdc, 0x18, 0xdc, 0x33, 0xb8, 0xb3,\n+\t\t\t\t0xc7, 0x27, 0x7e, 0xfc, 0xd2, 0xf7, 0x97, 0x90,\n+\t\t\t\t0x5e, 0x17, 0xac, 0x14, 0x8e, 0x0f, 0xca, 0xb5,\n+\t\t\t\t0x6f, 0xc9, 0x2d, 0x16, 0x03, 0x01, 0x00, 0x86,\n+\t\t\t\t0x0f, 0x00, 0x00, 0x82, 0x00, 0x80, 0x44, 0x7f,\n+\t\t\t\t0xa2, 0x59, 0x60, 0x0b, 0x5a, 0xc4, 0xaf, 0x1e,\n+\t\t\t\t0x60, 0xa5, 0x24, 0xea, 0xc1, 0xc3, 0x22, 0x21,\n+\t\t\t\t0x6b, 0x22, 0x8b, 0x2a, 0x11, 0x82, 0x68, 0x7d,\n+\t\t\t\t0xb9, 0xdd, 0x9c, 0x27, 0x4c, 0xc2, 0xc8, 0xa2,\n+\t\t\t\t0x8b, 0x6b, 0x77, 0x8d, 0x3a, 0x2b, 0x8d, 0x2f,\n+\t\t\t\t0x6a, 0x2b, 0x43, 0xd2, 0xd1, 0xc6, 0x41, 0x79,\n+\t\t\t\t0xa2, 0x4f, 0x2b, 0xc2, 0xf7, 0xb2, 0x10, 0xad,\n+\t\t\t\t0xa6, 0x01, 0x51, 0x51, 0x25, 0xe7, 0x58, 0x7a,\n+\t\t\t\t0xcf, 0x3b, 0xc4, 0x29, 0xb5, 0xe5, 0xa7, 0x83,\n+\t\t\t\t0xe6, 0xcb, 0x1e, 0xf3, 0x02, 0x0f, 0x53, 0x3b,\n+\t\t\t\t0xb5, 0x39, 0xef, 0x9c, 0x42, 0xe0, 0xa6, 0x9b,\n+\t\t\t\t0x2b, 0xdd, 0x60, 0xae, 0x0a, 0x73, 0x35, 0xbe,\n+\t\t\t\t0x26, 0x10, 0x1b, 0xe9, 0xe9, 0x61, 0xab, 0x20,\n+\t\t\t\t0xa5, 0x48, 0xc6, 0x60, 0xa6, 0x50, 0x3c, 0xfb,\n+\t\t\t\t0xa7, 0xca, 0xb0, 0x80, 0x95, 0x1e, 0xce, 0xc7,\n+\t\t\t\t0xbb, 0x68, 0x44, 0xdc, 0x0e, 0x0e, 0x14, 0x03,\n+\t\t\t\t0x01, 0x00, 0x01, 0x01, 0x16, 0x03, 0x01, 0x00,\n+\t\t\t\t0x24, 0xb6, 0xcd, 0x0c, 0x78, 0xfd, 0xd6, 0xff,\n+\t\t\t\t0xbe, 0x97, 0xd5, 0x0a, 0x7d, 0x4f, 0xa1, 0x03,\n+\t\t\t\t0x78, 0xc8, 0x61, 0x6f, 0xf2, 0x4b, 0xa8, 0x56,\n+\t\t\t\t0x4f, 0x3c, 0xa2, 0xd9, 0xd0, 0x20, 0x13, 0x1b,\n+\t\t\t\t0x8b, 0x36, 0xb7, 0x33, 0x9c,\n+\t\t\t},\n+\n+\t\t\t{\n+\t\t\t\t0x14, 0x03, 0x01, 0x00, 0x01, 0x01, 0x16, 0x03,\n+\t\t\t\t0x01, 0x00, 0x24, 0xa3, 0x43, 0x94, 0xe7, 0xdf,\n+\t\t\t\t0xb6, 0xc3, 0x03, 0x9f, 0xc1, 0x59, 0x0c, 0xc3,\n+\t\t\t\t0x13, 0xae, 0xed, 0xcf, 0xff, 0xf1, 0x80, 0xf3,\n+\t\t\t\t0x13, 0x63, 0x1c, 0xf0, 0xca, 0xad, 0x9e, 0x71,\n+\t\t\t\t0x46, 0x5f, 0x6b, 0xeb, 0x10, 0x3f, 0xe3, 0x17,\n+\t\t\t\t0x03, 0x01, 0x00, 0x21, 0xe9, 0x80, 0x95, 0x6e,\n+\t\t\t\t0x05, 0x55, 0x2f, 0xed, 0x4d, 0xde, 0x17, 0x3a,\n+\t\t\t\t0x32, 0x9b, 0x2a, 0x74, 0x30, 0x4f, 0xe0, 0x9f,\n+\t\t\t\t0x4e, 0xd3, 0x06, 0xbd, 0x3a, 0x43, 0x75, 0x8b,\n+\t\t\t\t0x5b, 0x9a, 0xd8, 0x2e, 0x56, 0x15, 0x03, 0x01,\n+\t\t\t\t0x00, 0x16, 0x53, 0xf5, 0xff, 0xe0, 0xa1, 0x6c,\n+\t\t\t\t0x33, 0xf4, 0x4e, 0x89, 0x68, 0xe1, 0xf7, 0x61,\n+\t\t\t\t0x13, 0xb3, 0x12, 0xa1, 0x8e, 0x5a, 0x7a, 0x02,\n+\t\t\t}}},\n+}\n+\n+// cert.pem and key.pem were generated with generate_cert.go\n+// Thus, they have no ExtKeyUsage fields and trigger an error\n+// when verification is turned on.\n+\n+var clicert = loadPEMCert(`\n+-----BEGIN CERTIFICATE-----\n+MIIB7TCCAVigAwIBAgIBADALBgkqhkiG9w0BAQUwJjEQMA4GA1UEChMHQWNtZSBD\n+bzESMBAGA1UEAxMJMTI3LjAuMC4xMB4XDTExMTIwODA3NTUxMloXDTEyMTIwNzA4\n+MDAxMlowJjEQMA4GA1UEChMHQWNtZSBDbzESMBAGA1UEAxMJMTI3LjAuMC4xMIGc\n+MAsGCSqGSIb3DQEBAQOBjAAwgYgCgYBO0Hsx44Jk2VnAwoekXh6LczPHY1PfZpIG\n+hPZk1Y/kNqcdK+izIDZFI7Xjla7t4PUgnI2V339aEu+H5Fto5OkOdOwEin/ekyfE\n+ARl6vfLcPRSr0FTKIQzQTW6HLlzF0rtNS0/Otiz3fojsfNcCkXSmHgwa2uNKWi7e\n+E5xMQIhZkwIDAQABozIwMDAOBgNVHQ8BAf8EBAMCAKAwDQYDVR0OBAYEBAECAwQw\n+DwYDVR0jBAgwBoAEAQIDBDALBgkqhkiG9w0BAQUDgYEANh+zegx1yW43RmEr1b3A\n+p0vMRpqBWHyFeSnIyMZn3TJWRSt1tukkqVCavh9a+hoV2cxVlXIWg7nCto/9iIw4\n+hB2rXZIxE0/9gzvGnfERYraL7KtnvshksBFQRlgXa5kc0x38BvEO5ZaoDPl4ILdE\n+GFGNEH5PlGffo05wc46QkYU=\n+-----END CERTIFICATE-----\n+`)\n+\n+/* corresponding key.pem for cert.pem is:\n+-----BEGIN RSA PRIVATE KEY-----\n+MIICXAIBAAKBgE7QezHjgmTZWcDCh6ReHotzM8djU99mkgaE9mTVj+Q2px0r6LMg\n+NkUjteOVru3g9SCcjZXff1oS74fkW2jk6Q507ASKf96TJ8QBGXq98tw9FKvQVMoh\n+DNBNbocuXMXSu01LT862LPd+iOx81wKRdKYeDBra40paLt4TnExAiFmTAgMBAAEC\n+gYBxvXd8yNteFTns8A/2yomEMC4yeosJJSpp1CsN3BJ7g8/qTnrVPxBy+RU+qr63\n+t2WquaOu/cr5P8iEsa6lk20tf8pjKLNXeX0b1RTzK8rJLbS7nGzP3tvOhL096VtQ\n+dAo4ROEaro0TzYpHmpciSvxVIeEIAAdFDObDJPKqcJAxyQJBAJizfYgK8Gzx9fsx\n+hxp+VteCbVPg2euASH5Yv3K5LukRdKoSzHE2grUVQgN/LafC0eZibRanxHegYSr7\n+7qaswKUCQQCEIWor/X4XTMdVj3Oj+vpiw75y/S9gh682+myZL+d/02IEkwnB098P\n+RkKVpenBHyrGg0oeN5La7URILWKj7CPXAkBKo6F+d+phNjwIFoN1Xb/RA32w/D1I\n+saG9sF+UEhRt9AxUfW/U/tIQ9V0ZHHcSg1XaCM5Nvp934brdKdvTOKnJAkBD5h/3\n+Rybatlvg/fzBEaJFyq09zhngkxlZOUtBVTqzl17RVvY2orgH02U4HbCHy4phxOn7\n+qTdQRYlHRftgnWK1AkANibn9PRYJ7mJyJ9Dyj2QeNcSkSTzrt0tPvUMf4+meJymN\n+1Ntu5+S1DLLzfxlaljWG6ylW6DNxujCyuXIV2rvAMAA=\n+-----END RSA PRIVATE KEY-----\n+*/"}, {"sha": "28e93a0be69c5165006c89be8f5058004107b43e", "filename": "libgo/go/crypto/tls/tls.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Ftls%2Ftls.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -120,7 +120,7 @@ func Dial(network, addr string, config *Config) (*Conn, error) {\n \n // LoadX509KeyPair reads and parses a public/private key pair from a pair of\n // files. The files must contain PEM encoded data.\n-func LoadX509KeyPair(certFile string, keyFile string) (cert Certificate, err error) {\n+func LoadX509KeyPair(certFile, keyFile string) (cert Certificate, err error) {\n \tcertPEMBlock, err := ioutil.ReadFile(certFile)\n \tif err != nil {\n \t\treturn"}, {"sha": "616a0b3c1e8570b5d2b236f0ddf32f5ffb8d34ba", "filename": "libgo/go/crypto/x509/cert_pool.go", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcrypto%2Fx509%2Fcert_pool.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -101,3 +101,13 @@ func (s *CertPool) AppendCertsFromPEM(pemCerts []byte) (ok bool) {\n \n \treturn\n }\n+\n+// Subjects returns a list of the DER-encoded subjects of\n+// all of the certificates in the pool. \n+func (s *CertPool) Subjects() (res [][]byte) {\n+\tres = make([][]byte, len(s.certs))\n+\tfor i, c := range s.certs {\n+\t\tres[i] = c.RawSubject\n+\t}\n+\treturn\n+}"}, {"sha": "b90181bdc64103ba86d4c1961a6acc412067fbb8", "filename": "libgo/go/debug/gosym/pclntab_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fdebug%2Fgosym%2Fpclntab_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,14 +7,14 @@ package gosym\n import (\n \t\"debug/elf\"\n \t\"os\"\n-\t\"syscall\"\n+\t\"runtime\"\n \t\"testing\"\n )\n \n func dotest() bool {\n \t// For now, only works on ELF platforms.\n \t// TODO: convert to work with new go tool\n-\treturn false && syscall.OS == \"linux\" && os.Getenv(\"GOARCH\") == \"amd64\"\n+\treturn false && runtime.GOOS == \"linux\" && runtime.GOARCH == \"amd64\"\n }\n \n func getTable(t *testing.T) *Table {"}, {"sha": "4d1ae38c4edaa1ce4203da112dd81aa287d92b71", "filename": "libgo/go/encoding/asn1/asn1.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -786,7 +786,8 @@ func setDefaultValue(v reflect.Value, params fieldParameters) (ok bool) {\n // Because Unmarshal uses the reflect package, the structs\n // being written to must use upper case field names.\n //\n-// An ASN.1 INTEGER can be written to an int, int32 or int64.\n+// An ASN.1 INTEGER can be written to an int, int32, int64,\n+// or *big.Int (from the math/big package).\n // If the encoded value does not fit in the Go type,\n // Unmarshal returns a parse error.\n //"}, {"sha": "92c9eb62d2c6b373bbdb94e233cf07254e7abc6d", "filename": "libgo/go/encoding/asn1/asn1_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fasn1_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,6 +6,7 @@ package asn1\n \n import (\n \t\"bytes\"\n+\t\"math/big\"\n \t\"reflect\"\n \t\"testing\"\n \t\"time\"\n@@ -351,6 +352,10 @@ type TestElementsAfterString struct {\n \tA, B int\n }\n \n+type TestBigInt struct {\n+\tX *big.Int\n+}\n+\n var unmarshalTestData = []struct {\n \tin  []byte\n \tout interface{}\n@@ -369,6 +374,7 @@ var unmarshalTestData = []struct {\n \t{[]byte{0x01, 0x01, 0x00}, newBool(false)},\n \t{[]byte{0x01, 0x01, 0x01}, newBool(true)},\n \t{[]byte{0x30, 0x0b, 0x13, 0x03, 0x66, 0x6f, 0x6f, 0x02, 0x01, 0x22, 0x02, 0x01, 0x33}, &TestElementsAfterString{\"foo\", 0x22, 0x33}},\n+\t{[]byte{0x30, 0x05, 0x02, 0x03, 0x12, 0x34, 0x56}, &TestBigInt{big.NewInt(0x123456)}},\n }\n \n func TestUnmarshal(t *testing.T) {"}, {"sha": "a7447f978127c3362c1cf4691f63d6a63abf84d6", "filename": "libgo/go/encoding/asn1/marshal_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fasn1%2Fmarshal_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,6 +7,7 @@ package asn1\n import (\n \t\"bytes\"\n \t\"encoding/hex\"\n+\t\"math/big\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -20,6 +21,10 @@ type twoIntStruct struct {\n \tB int\n }\n \n+type bigIntStruct struct {\n+\tA *big.Int\n+}\n+\n type nestedStruct struct {\n \tA intStruct\n }\n@@ -65,6 +70,7 @@ var marshalTests = []marshalTest{\n \t{-128, \"020180\"},\n \t{-129, \"0202ff7f\"},\n \t{intStruct{64}, \"3003020140\"},\n+\t{bigIntStruct{big.NewInt(0x123456)}, \"30050203123456\"},\n \t{twoIntStruct{64, 65}, \"3006020140020141\"},\n \t{nestedStruct{intStruct{127}}, \"3005300302017f\"},\n \t{[]byte{1, 2, 3}, \"0403010203\"},"}, {"sha": "4d1325d176c61cc0455047559e36725c17cfb1ed", "filename": "libgo/go/encoding/gob/decode.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fdecode.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -1039,9 +1039,9 @@ func (dec *Decoder) compatibleType(fr reflect.Type, fw typeId, inProgress map[re\n \t\t// Extract and compare element types.\n \t\tvar sw *sliceType\n \t\tif tt, ok := builtinIdToType[fw]; ok {\n-\t\t\tsw = tt.(*sliceType)\n-\t\t} else {\n-\t\t\tsw = dec.wireType[fw].SliceT\n+\t\t\tsw, _ = tt.(*sliceType)\n+\t\t} else if wire != nil {\n+\t\t\tsw = wire.SliceT\n \t\t}\n \t\telem := userType(t.Elem()).base\n \t\treturn sw != nil && dec.compatibleType(elem, sw.Elem, inProgress)"}, {"sha": "7a30f9107e636638e6d666fce46792d5bb639be2", "filename": "libgo/go/encoding/gob/encoder_test.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fgob%2Fencoder_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -678,3 +678,11 @@ func TestUnexportedChan(t *testing.T) {\n \t\tt.Fatalf(\"error encoding unexported channel: %s\", err)\n \t}\n }\n+\n+func TestSliceIncompatibility(t *testing.T) {\n+\tvar in = []byte{1, 2, 3}\n+\tvar out []int\n+\tif err := encAndDec(in, &out); err == nil {\n+\t\tt.Error(\"expected compatibility error\")\n+\t}\n+}"}, {"sha": "87076b53dc06578d4b21b24293a957f1eb8d9566", "filename": "libgo/go/encoding/json/decode.go", "status": "modified", "additions": 28, "deletions": 7, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,6 +10,7 @@ package json\n import (\n \t\"encoding/base64\"\n \t\"errors\"\n+\t\"fmt\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"strconv\"\n@@ -538,7 +539,7 @@ func (d *decodeState) object(v reflect.Value) {\n \t\t// Read value.\n \t\tif destring {\n \t\t\td.value(reflect.ValueOf(&d.tempstr))\n-\t\t\td.literalStore([]byte(d.tempstr), subv)\n+\t\t\td.literalStore([]byte(d.tempstr), subv, true)\n \t\t} else {\n \t\t\td.value(subv)\n \t\t}\n@@ -571,11 +572,15 @@ func (d *decodeState) literal(v reflect.Value) {\n \td.off--\n \td.scan.undo(op)\n \n-\td.literalStore(d.data[start:d.off], v)\n+\td.literalStore(d.data[start:d.off], v, false)\n }\n \n // literalStore decodes a literal stored in item into v.\n-func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n+//\n+// fromQuoted indicates whether this literal came from unwrapping a\n+// string from the \",string\" struct tag option. this is used only to\n+// produce more helpful error messages.\n+func (d *decodeState) literalStore(item []byte, v reflect.Value, fromQuoted bool) {\n \t// Check for unmarshaler.\n \twantptr := item[0] == 'n' // null\n \tunmarshaler, pv := d.indirect(v, wantptr)\n@@ -601,7 +606,11 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n \t\tvalue := c == 't'\n \t\tswitch v.Kind() {\n \t\tdefault:\n-\t\t\td.saveError(&UnmarshalTypeError{\"bool\", v.Type()})\n+\t\t\tif fromQuoted {\n+\t\t\t\td.saveError(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.saveError(&UnmarshalTypeError{\"bool\", v.Type()})\n+\t\t\t}\n \t\tcase reflect.Bool:\n \t\t\tv.SetBool(value)\n \t\tcase reflect.Interface:\n@@ -611,7 +620,11 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n \tcase '\"': // string\n \t\ts, ok := unquoteBytes(item)\n \t\tif !ok {\n-\t\t\td.error(errPhase)\n+\t\t\tif fromQuoted {\n+\t\t\t\td.error(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.error(errPhase)\n+\t\t\t}\n \t\t}\n \t\tswitch v.Kind() {\n \t\tdefault:\n@@ -636,12 +649,20 @@ func (d *decodeState) literalStore(item []byte, v reflect.Value) {\n \n \tdefault: // number\n \t\tif c != '-' && (c < '0' || c > '9') {\n-\t\t\td.error(errPhase)\n+\t\t\tif fromQuoted {\n+\t\t\t\td.error(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.error(errPhase)\n+\t\t\t}\n \t\t}\n \t\ts := string(item)\n \t\tswitch v.Kind() {\n \t\tdefault:\n-\t\t\td.error(&UnmarshalTypeError{\"number\", v.Type()})\n+\t\t\tif fromQuoted {\n+\t\t\t\td.error(fmt.Errorf(\"json: invalid use of ,string struct tag, trying to unmarshal %q into %v\", item, v.Type()))\n+\t\t\t} else {\n+\t\t\t\td.error(&UnmarshalTypeError{\"number\", v.Type()})\n+\t\t\t}\n \t\tcase reflect.Interface:\n \t\t\tn, err := strconv.ParseFloat(s, 64)\n \t\t\tif err != nil {"}, {"sha": "cc3103f032fb26c1c23cdfac08cbd7ca3c026eeb", "filename": "libgo/go/encoding/json/decode_test.go", "status": "modified", "additions": 3, "deletions": 6, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fdecode_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -258,13 +258,10 @@ type wrongStringTest struct {\n \tin, err string\n }\n \n-// TODO(bradfitz): as part of Issue 2331, fix these tests' expected\n-// error values to be helpful, rather than the confusing messages they\n-// are now.\n var wrongStringTests = []wrongStringTest{\n-\t{`{\"result\":\"x\"}`, \"JSON decoder out of sync - data changing underfoot?\"},\n-\t{`{\"result\":\"foo\"}`, \"json: cannot unmarshal bool into Go value of type string\"},\n-\t{`{\"result\":\"123\"}`, \"json: cannot unmarshal number into Go value of type string\"},\n+\t{`{\"result\":\"x\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"x\" into string`},\n+\t{`{\"result\":\"foo\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"foo\" into string`},\n+\t{`{\"result\":\"123\"}`, `json: invalid use of ,string struct tag, trying to unmarshal \"123\" into string`},\n }\n \n // If people misuse the ,string modifier, the error message should be"}, {"sha": "033da2d0ade140aff6389f0e886c99645f4cc203", "filename": "libgo/go/encoding/json/encode.go", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -12,6 +12,7 @@ package json\n import (\n \t\"bytes\"\n \t\"encoding/base64\"\n+\t\"math\"\n \t\"reflect\"\n \t\"runtime\"\n \t\"sort\"\n@@ -170,6 +171,15 @@ func (e *UnsupportedTypeError) Error() string {\n \treturn \"json: unsupported type: \" + e.Type.String()\n }\n \n+type UnsupportedValueError struct {\n+\tValue reflect.Value\n+\tStr   string\n+}\n+\n+func (e *UnsupportedValueError) Error() string {\n+\treturn \"json: unsupported value: \" + e.Str\n+}\n+\n type InvalidUTF8Error struct {\n \tS string\n }\n@@ -290,7 +300,11 @@ func (e *encodeState) reflectValueQuoted(v reflect.Value, quoted bool) {\n \t\t\te.Write(b)\n \t\t}\n \tcase reflect.Float32, reflect.Float64:\n-\t\tb := strconv.AppendFloat(e.scratch[:0], v.Float(), 'g', -1, v.Type().Bits())\n+\t\tf := v.Float()\n+\t\tif math.IsInf(f, 0) || math.IsNaN(f) {\n+\t\t\te.error(&UnsupportedValueError{v, strconv.FormatFloat(f, 'g', -1, v.Type().Bits())})\n+\t\t}\n+\t\tb := strconv.AppendFloat(e.scratch[:0], f, 'g', -1, v.Type().Bits())\n \t\tif quoted {\n \t\t\twriteString(e, string(b))\n \t\t} else {"}, {"sha": "0e39559a463405ccbe164cd24794737dc2f37481", "filename": "libgo/go/encoding/json/encode_test.go", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fjson%2Fencode_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,6 +6,7 @@ package json\n \n import (\n \t\"bytes\"\n+\t\"math\"\n \t\"reflect\"\n \t\"testing\"\n )\n@@ -107,3 +108,21 @@ func TestEncodeRenamedByteSlice(t *testing.T) {\n \t\tt.Errorf(\" got %s want %s\", result, expect)\n \t}\n }\n+\n+var unsupportedValues = []interface{}{\n+\tmath.NaN(),\n+\tmath.Inf(-1),\n+\tmath.Inf(1),\n+}\n+\n+func TestUnsupportedValues(t *testing.T) {\n+\tfor _, v := range unsupportedValues {\n+\t\tif _, err := Marshal(v); err != nil {\n+\t\t\tif _, ok := err.(*UnsupportedValueError); !ok {\n+\t\t\t\tt.Errorf(\"for %v, got %T want UnsupportedValueError\", v, err)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tt.Errorf(\"for %v, expected error\", v)\n+\t\t}\n+\t}\n+}"}, {"sha": "8d003aade0770fb85fcbd2757d0791910fce217a", "filename": "libgo/go/encoding/xml/atom_test.go", "status": "modified", "additions": 14, "deletions": 13, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fatom_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -5,6 +5,7 @@\n package xml\n \n var atomValue = &Feed{\n+\tXMLName: Name{\"http://www.w3.org/2005/Atom\", \"feed\"},\n \tTitle:   \"Example Feed\",\n \tLink:    []Link{{Href: \"http://example.org/\"}},\n \tUpdated: ParseTime(\"2003-12-13T18:30:02Z\"),\n@@ -24,19 +25,19 @@ var atomValue = &Feed{\n \n var atomXml = `` +\n \t`<feed xmlns=\"http://www.w3.org/2005/Atom\">` +\n-\t`<Title>Example Feed</Title>` +\n-\t`<Id>urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6</Id>` +\n-\t`<Link href=\"http://example.org/\"></Link>` +\n-\t`<Updated>2003-12-13T18:30:02Z</Updated>` +\n-\t`<Author><Name>John Doe</Name><URI></URI><Email></Email></Author>` +\n-\t`<Entry>` +\n-\t`<Title>Atom-Powered Robots Run Amok</Title>` +\n-\t`<Id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</Id>` +\n-\t`<Link href=\"http://example.org/2003/12/13/atom03\"></Link>` +\n-\t`<Updated>2003-12-13T18:30:02Z</Updated>` +\n-\t`<Author><Name></Name><URI></URI><Email></Email></Author>` +\n-\t`<Summary>Some text.</Summary>` +\n-\t`</Entry>` +\n+\t`<title>Example Feed</title>` +\n+\t`<id>urn:uuid:60a76c80-d399-11d9-b93C-0003939e0af6</id>` +\n+\t`<link href=\"http://example.org/\"></link>` +\n+\t`<updated>2003-12-13T18:30:02Z</updated>` +\n+\t`<author><name>John Doe</name><uri></uri><email></email></author>` +\n+\t`<entry>` +\n+\t`<title>Atom-Powered Robots Run Amok</title>` +\n+\t`<id>urn:uuid:1225c695-cfb8-4ebb-aaaa-80da344efa6a</id>` +\n+\t`<link href=\"http://example.org/2003/12/13/atom03\"></link>` +\n+\t`<updated>2003-12-13T18:30:02Z</updated>` +\n+\t`<author><name></name><uri></uri><email></email></author>` +\n+\t`<summary>Some text.</summary>` +\n+\t`</entry>` +\n \t`</feed>`\n \n func ParseTime(str string) Time {"}, {"sha": "ec7f478bec3fdff5fbe049660402232dd3098748", "filename": "libgo/go/encoding/xml/embed_test.go", "status": "removed", "additions": 0, "deletions": 124, "changes": 124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fencoding%2Fxml%2Fembed_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fencoding%2Fxml%2Fembed_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fembed_test.go?ref=3be18e47c33b61365786831e0f967f42b09922c9", "patch": "@@ -1,124 +0,0 @@\n-// Copyright 2010 The Go Authors.  All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package xml\n-\n-import \"testing\"\n-\n-type C struct {\n-\tName string\n-\tOpen bool\n-}\n-\n-type A struct {\n-\tXMLName Name `xml:\"http://domain a\"`\n-\tC\n-\tB      B\n-\tFieldA string\n-}\n-\n-type B struct {\n-\tXMLName Name `xml:\"b\"`\n-\tC\n-\tFieldB string\n-}\n-\n-const _1a = `\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<a xmlns=\"http://domain\">\n-  <name>KmlFile</name>\n-  <open>1</open>\n-  <b>\n-    <name>Absolute</name>\n-    <open>0</open>\n-    <fieldb>bar</fieldb>\n-  </b>\n-  <fielda>foo</fielda>\n-</a>\n-`\n-\n-// Tests that embedded structs are marshalled.\n-func TestEmbedded1(t *testing.T) {\n-\tvar a A\n-\tif e := Unmarshal(StringReader(_1a), &a); e != nil {\n-\t\tt.Fatalf(\"Unmarshal: %s\", e)\n-\t}\n-\tif a.FieldA != \"foo\" {\n-\t\tt.Fatalf(\"Unmarshal: expected 'foo' but found '%s'\", a.FieldA)\n-\t}\n-\tif a.Name != \"KmlFile\" {\n-\t\tt.Fatalf(\"Unmarshal: expected 'KmlFile' but found '%s'\", a.Name)\n-\t}\n-\tif !a.Open {\n-\t\tt.Fatal(\"Unmarshal: expected 'true' but found otherwise\")\n-\t}\n-\tif a.B.FieldB != \"bar\" {\n-\t\tt.Fatalf(\"Unmarshal: expected 'bar' but found '%s'\", a.B.FieldB)\n-\t}\n-\tif a.B.Name != \"Absolute\" {\n-\t\tt.Fatalf(\"Unmarshal: expected 'Absolute' but found '%s'\", a.B.Name)\n-\t}\n-\tif a.B.Open {\n-\t\tt.Fatal(\"Unmarshal: expected 'false' but found otherwise\")\n-\t}\n-}\n-\n-type A2 struct {\n-\tXMLName Name `xml:\"http://domain a\"`\n-\tXY      string\n-\tXy      string\n-}\n-\n-const _2a = `\n-<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n-<a xmlns=\"http://domain\">\n-  <xy>foo</xy>\n-</a>\n-`\n-\n-// Tests that conflicting field names get excluded.\n-func TestEmbedded2(t *testing.T) {\n-\tvar a A2\n-\tif e := Unmarshal(StringReader(_2a), &a); e != nil {\n-\t\tt.Fatalf(\"Unmarshal: %s\", e)\n-\t}\n-\tif a.XY != \"\" {\n-\t\tt.Fatalf(\"Unmarshal: expected empty string but found '%s'\", a.XY)\n-\t}\n-\tif a.Xy != \"\" {\n-\t\tt.Fatalf(\"Unmarshal: expected empty string but found '%s'\", a.Xy)\n-\t}\n-}\n-\n-type A3 struct {\n-\tXMLName Name `xml:\"http://domain a\"`\n-\txy      string\n-}\n-\n-// Tests that private fields are not set.\n-func TestEmbedded3(t *testing.T) {\n-\tvar a A3\n-\tif e := Unmarshal(StringReader(_2a), &a); e != nil {\n-\t\tt.Fatalf(\"Unmarshal: %s\", e)\n-\t}\n-\tif a.xy != \"\" {\n-\t\tt.Fatalf(\"Unmarshal: expected empty string but found '%s'\", a.xy)\n-\t}\n-}\n-\n-type A4 struct {\n-\tXMLName Name `xml:\"http://domain a\"`\n-\tAny     string\n-}\n-\n-// Tests that private fields are not set.\n-func TestEmbedded4(t *testing.T) {\n-\tvar a A4\n-\tif e := Unmarshal(StringReader(_2a), &a); e != nil {\n-\t\tt.Fatalf(\"Unmarshal: %s\", e)\n-\t}\n-\tif a.Any != \"foo\" {\n-\t\tt.Fatalf(\"Unmarshal: expected 'foo' but found '%s'\", a.Any)\n-\t}\n-}"}, {"sha": "d25ee30a72b0b82387313cdcb41ac779615ba61d", "filename": "libgo/go/encoding/xml/marshal.go", "status": "modified", "additions": 161, "deletions": 96, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,6 +6,8 @@ package xml\n \n import (\n \t\"bufio\"\n+\t\"bytes\"\n+\t\"fmt\"\n \t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n@@ -42,38 +44,45 @@ type printer struct {\n // elements containing the data.\n //\n // The name for the XML elements is taken from, in order of preference:\n-//     - the tag on an XMLName field, if the data is a struct\n-//     - the value of an XMLName field of type xml.Name\n+//     - the tag on the XMLName field, if the data is a struct\n+//     - the value of the XMLName field of type xml.Name\n //     - the tag of the struct field used to obtain the data\n //     - the name of the struct field used to obtain the data\n-//     - the name '???'.\n+//     - the name of the marshalled type\n //\n // The XML element for a struct contains marshalled elements for each of the\n // exported fields of the struct, with these exceptions:\n //     - the XMLName field, described above, is omitted.\n-//     - a field with tag \"attr\" becomes an attribute in the XML element.\n-//     - a field with tag \"chardata\" is written as character data,\n-//        not as an XML element.\n-//     - a field with tag \"innerxml\" is written verbatim,\n-//        not subject to the usual marshalling procedure.\n+//     - a field with tag \"name,attr\" becomes an attribute with\n+//       the given name in the XML element.\n+//     - a field with tag \",attr\" becomes an attribute with the\n+//       field name in the in the XML element.\n+//     - a field with tag \",chardata\" is written as character data,\n+//       not as an XML element.\n+//     - a field with tag \",innerxml\" is written verbatim, not subject\n+//       to the usual marshalling procedure.\n+//     - a field with tag \",comment\" is written as an XML comment, not\n+//       subject to the usual marshalling procedure. It must not contain\n+//       the \"--\" string within it.\n //\n // If a field uses a tag \"a>b>c\", then the element c will be nested inside\n // parent elements a and b.  Fields that appear next to each other that name\n // the same parent will be enclosed in one XML element.  For example:\n //\n //\ttype Result struct {\n //\t\tXMLName   xml.Name `xml:\"result\"`\n+//\t\tId        int      `xml:\"id,attr\"`\n //\t\tFirstName string   `xml:\"person>name>first\"`\n //\t\tLastName  string   `xml:\"person>name>last\"`\n //\t\tAge       int      `xml:\"person>age\"`\n //\t}\n //\n-//\txml.Marshal(w, &Result{FirstName: \"John\", LastName: \"Doe\", Age: 42})\n+//\txml.Marshal(w, &Result{Id: 13, FirstName: \"John\", LastName: \"Doe\", Age: 42})\n //\n // would be marshalled as:\n //\n //\t<result>\n-//\t\t<person>\n+//\t\t<person id=\"13\">\n //\t\t\t<name>\n //\t\t\t\t<first>John</first>\n //\t\t\t\t<last>Doe</last>\n@@ -85,12 +94,12 @@ type printer struct {\n // Marshal will return an error if asked to marshal a channel, function, or map.\n func Marshal(w io.Writer, v interface{}) (err error) {\n \tp := &printer{bufio.NewWriter(w)}\n-\terr = p.marshalValue(reflect.ValueOf(v), \"???\")\n+\terr = p.marshalValue(reflect.ValueOf(v), nil)\n \tp.Flush()\n \treturn err\n }\n \n-func (p *printer) marshalValue(val reflect.Value, name string) error {\n+func (p *printer) marshalValue(val reflect.Value, finfo *fieldInfo) error {\n \tif !val.IsValid() {\n \t\treturn nil\n \t}\n@@ -115,58 +124,75 @@ func (p *printer) marshalValue(val reflect.Value, name string) error {\n \t\tif val.IsNil() {\n \t\t\treturn nil\n \t\t}\n-\t\treturn p.marshalValue(val.Elem(), name)\n+\t\treturn p.marshalValue(val.Elem(), finfo)\n \t}\n \n \t// Slices and arrays iterate over the elements. They do not have an enclosing tag.\n \tif (kind == reflect.Slice || kind == reflect.Array) && typ.Elem().Kind() != reflect.Uint8 {\n \t\tfor i, n := 0, val.Len(); i < n; i++ {\n-\t\t\tif err := p.marshalValue(val.Index(i), name); err != nil {\n+\t\t\tif err := p.marshalValue(val.Index(i), finfo); err != nil {\n \t\t\t\treturn err\n \t\t\t}\n \t\t}\n \t\treturn nil\n \t}\n \n-\t// Find XML name\n-\txmlns := \"\"\n-\tif kind == reflect.Struct {\n-\t\tif f, ok := typ.FieldByName(\"XMLName\"); ok {\n-\t\t\tif tag := f.Tag.Get(\"xml\"); tag != \"\" {\n-\t\t\t\tif i := strings.Index(tag, \" \"); i >= 0 {\n-\t\t\t\t\txmlns, name = tag[:i], tag[i+1:]\n-\t\t\t\t} else {\n-\t\t\t\t\tname = tag\n-\t\t\t\t}\n-\t\t\t} else if v, ok := val.FieldByIndex(f.Index).Interface().(Name); ok && v.Local != \"\" {\n-\t\t\t\txmlns, name = v.Space, v.Local\n-\t\t\t}\n+\ttinfo, err := getTypeInfo(typ)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Precedence for the XML element name is:\n+\t// 1. XMLName field in underlying struct;\n+\t// 2. field name/tag in the struct field; and\n+\t// 3. type name\n+\tvar xmlns, name string\n+\tif tinfo.xmlname != nil {\n+\t\txmlname := tinfo.xmlname\n+\t\tif xmlname.name != \"\" {\n+\t\t\txmlns, name = xmlname.xmlns, xmlname.name\n+\t\t} else if v, ok := val.FieldByIndex(xmlname.idx).Interface().(Name); ok && v.Local != \"\" {\n+\t\t\txmlns, name = v.Space, v.Local\n+\t\t}\n+\t}\n+\tif name == \"\" && finfo != nil {\n+\t\txmlns, name = finfo.xmlns, finfo.name\n+\t}\n+\tif name == \"\" {\n+\t\tname = typ.Name()\n+\t\tif name == \"\" {\n+\t\t\treturn &UnsupportedTypeError{typ}\n \t\t}\n \t}\n \n \tp.WriteByte('<')\n \tp.WriteString(name)\n \n+\tif xmlns != \"\" {\n+\t\tp.WriteString(` xmlns=\"`)\n+\t\t// TODO: EscapeString, to avoid the allocation.\n+\t\tEscape(p, []byte(xmlns))\n+\t\tp.WriteByte('\"')\n+\t}\n+\n \t// Attributes\n-\tif kind == reflect.Struct {\n-\t\tif len(xmlns) > 0 {\n-\t\t\tp.WriteString(` xmlns=\"`)\n-\t\t\tEscape(p, []byte(xmlns))\n-\t\t\tp.WriteByte('\"')\n+\tfor i := range tinfo.fields {\n+\t\tfinfo := &tinfo.fields[i]\n+\t\tif finfo.flags&fAttr == 0 {\n+\t\t\tcontinue\n \t\t}\n-\n-\t\tfor i, n := 0, typ.NumField(); i < n; i++ {\n-\t\t\tif f := typ.Field(i); f.PkgPath == \"\" && f.Tag.Get(\"xml\") == \"attr\" {\n-\t\t\t\tif f.Type.Kind() == reflect.String {\n-\t\t\t\t\tif str := val.Field(i).String(); str != \"\" {\n-\t\t\t\t\t\tp.WriteByte(' ')\n-\t\t\t\t\t\tp.WriteString(strings.ToLower(f.Name))\n-\t\t\t\t\t\tp.WriteString(`=\"`)\n-\t\t\t\t\t\tEscape(p, []byte(str))\n-\t\t\t\t\t\tp.WriteByte('\"')\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n+\t\tvar str string\n+\t\tif fv := val.FieldByIndex(finfo.idx); fv.Kind() == reflect.String {\n+\t\t\tstr = fv.String()\n+\t\t} else {\n+\t\t\tstr = fmt.Sprint(fv.Interface())\n+\t\t}\n+\t\tif str != \"\" {\n+\t\t\tp.WriteByte(' ')\n+\t\t\tp.WriteString(finfo.name)\n+\t\t\tp.WriteString(`=\"`)\n+\t\t\tEscape(p, []byte(str))\n+\t\t\tp.WriteByte('\"')\n \t\t}\n \t}\n \tp.WriteByte('>')\n@@ -194,58 +220,9 @@ func (p *printer) marshalValue(val reflect.Value, name string) error {\n \t\tbytes := val.Interface().([]byte)\n \t\tEscape(p, bytes)\n \tcase reflect.Struct:\n-\t\ts := parentStack{printer: p}\n-\t\tfor i, n := 0, val.NumField(); i < n; i++ {\n-\t\t\tif f := typ.Field(i); f.Name != \"XMLName\" && f.PkgPath == \"\" {\n-\t\t\t\tname := f.Name\n-\t\t\t\tvf := val.Field(i)\n-\t\t\t\tswitch tag := f.Tag.Get(\"xml\"); tag {\n-\t\t\t\tcase \"\":\n-\t\t\t\t\ts.trim(nil)\n-\t\t\t\tcase \"chardata\":\n-\t\t\t\t\tif tk := f.Type.Kind(); tk == reflect.String {\n-\t\t\t\t\t\tEscape(p, []byte(vf.String()))\n-\t\t\t\t\t} else if tk == reflect.Slice {\n-\t\t\t\t\t\tif elem, ok := vf.Interface().([]byte); ok {\n-\t\t\t\t\t\t\tEscape(p, elem)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t\tcontinue\n-\t\t\t\tcase \"innerxml\":\n-\t\t\t\t\tiface := vf.Interface()\n-\t\t\t\t\tswitch raw := iface.(type) {\n-\t\t\t\t\tcase []byte:\n-\t\t\t\t\t\tp.Write(raw)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\tcase string:\n-\t\t\t\t\t\tp.WriteString(raw)\n-\t\t\t\t\t\tcontinue\n-\t\t\t\t\t}\n-\t\t\t\tcase \"attr\":\n-\t\t\t\t\tcontinue\n-\t\t\t\tdefault:\n-\t\t\t\t\tparents := strings.Split(tag, \">\")\n-\t\t\t\t\tif len(parents) == 1 {\n-\t\t\t\t\t\tparents, name = nil, tag\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\tparents, name = parents[:len(parents)-1], parents[len(parents)-1]\n-\t\t\t\t\t\tif parents[0] == \"\" {\n-\t\t\t\t\t\t\tparents[0] = f.Name\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\n-\t\t\t\t\ts.trim(parents)\n-\t\t\t\t\tif !(vf.Kind() == reflect.Ptr || vf.Kind() == reflect.Interface) || !vf.IsNil() {\n-\t\t\t\t\t\ts.push(parents[len(s.stack):])\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tif err := p.marshalValue(vf, name); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t}\n+\t\tif err := p.marshalStruct(tinfo, val); err != nil {\n+\t\t\treturn err\n \t\t}\n-\t\ts.trim(nil)\n \tdefault:\n \t\treturn &UnsupportedTypeError{typ}\n \t}\n@@ -258,6 +235,94 @@ func (p *printer) marshalValue(val reflect.Value, name string) error {\n \treturn nil\n }\n \n+var ddBytes = []byte(\"--\")\n+\n+func (p *printer) marshalStruct(tinfo *typeInfo, val reflect.Value) error {\n+\ts := parentStack{printer: p}\n+\tfor i := range tinfo.fields {\n+\t\tfinfo := &tinfo.fields[i]\n+\t\tif finfo.flags&(fAttr|fAny) != 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvf := val.FieldByIndex(finfo.idx)\n+\t\tswitch finfo.flags & fMode {\n+\t\tcase fCharData:\n+\t\t\tswitch vf.Kind() {\n+\t\t\tcase reflect.String:\n+\t\t\t\tEscape(p, []byte(vf.String()))\n+\t\t\tcase reflect.Slice:\n+\t\t\t\tif elem, ok := vf.Interface().([]byte); ok {\n+\t\t\t\t\tEscape(p, elem)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tcontinue\n+\n+\t\tcase fComment:\n+\t\t\tk := vf.Kind()\n+\t\t\tif !(k == reflect.String || k == reflect.Slice && vf.Type().Elem().Kind() == reflect.Uint8) {\n+\t\t\t\treturn fmt.Errorf(\"xml: bad type for comment field of %s\", val.Type())\n+\t\t\t}\n+\t\t\tif vf.Len() == 0 {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tp.WriteString(\"<!--\")\n+\t\t\tdashDash := false\n+\t\t\tdashLast := false\n+\t\t\tswitch k {\n+\t\t\tcase reflect.String:\n+\t\t\t\ts := vf.String()\n+\t\t\t\tdashDash = strings.Index(s, \"--\") >= 0\n+\t\t\t\tdashLast = s[len(s)-1] == '-'\n+\t\t\t\tif !dashDash {\n+\t\t\t\t\tp.WriteString(s)\n+\t\t\t\t}\n+\t\t\tcase reflect.Slice:\n+\t\t\t\tb := vf.Bytes()\n+\t\t\t\tdashDash = bytes.Index(b, ddBytes) >= 0\n+\t\t\t\tdashLast = b[len(b)-1] == '-'\n+\t\t\t\tif !dashDash {\n+\t\t\t\t\tp.Write(b)\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tpanic(\"can't happen\")\n+\t\t\t}\n+\t\t\tif dashDash {\n+\t\t\t\treturn fmt.Errorf(`xml: comments must not contain \"--\"`)\n+\t\t\t}\n+\t\t\tif dashLast {\n+\t\t\t\t// \"--->\" is invalid grammar. Make it \"- -->\"\n+\t\t\t\tp.WriteByte(' ')\n+\t\t\t}\n+\t\t\tp.WriteString(\"-->\")\n+\t\t\tcontinue\n+\n+\t\tcase fInnerXml:\n+\t\t\tiface := vf.Interface()\n+\t\t\tswitch raw := iface.(type) {\n+\t\t\tcase []byte:\n+\t\t\t\tp.Write(raw)\n+\t\t\t\tcontinue\n+\t\t\tcase string:\n+\t\t\t\tp.WriteString(raw)\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\tcase fElement:\n+\t\t\ts.trim(finfo.parents)\n+\t\t\tif len(finfo.parents) > len(s.stack) {\n+\t\t\t\tif vf.Kind() != reflect.Ptr && vf.Kind() != reflect.Interface || !vf.IsNil() {\n+\t\t\t\t\ts.push(finfo.parents[len(s.stack):])\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tif err := p.marshalValue(vf, finfo); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\ts.trim(nil)\n+\treturn nil\n+}\n+\n type parentStack struct {\n \t*printer\n \tstack []string"}, {"sha": "bec53761e1a31ea25dedaddc01627354065e1386", "filename": "libgo/go/encoding/xml/marshal_test.go", "status": "modified", "additions": 325, "deletions": 108, "changes": 433, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fmarshal_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -25,10 +25,10 @@ type Passenger struct {\n }\n \n type Ship struct {\n-\tXMLName Name `xml:\"spaceship\"`\n+\tXMLName struct{} `xml:\"spaceship\"`\n \n-\tName      string       `xml:\"attr\"`\n-\tPilot     string       `xml:\"attr\"`\n+\tName      string       `xml:\"name,attr\"`\n+\tPilot     string       `xml:\"pilot,attr\"`\n \tDrive     DriveType    `xml:\"drive\"`\n \tAge       uint         `xml:\"age\"`\n \tPassenger []*Passenger `xml:\"passenger\"`\n@@ -44,48 +44,50 @@ func (rx RawXML) MarshalXML() ([]byte, error) {\n type NamedType string\n \n type Port struct {\n-\tXMLName Name   `xml:\"port\"`\n-\tType    string `xml:\"attr\"`\n-\tNumber  string `xml:\"chardata\"`\n+\tXMLName struct{} `xml:\"port\"`\n+\tType    string   `xml:\"type,attr\"`\n+\tComment string   `xml:\",comment\"`\n+\tNumber  string   `xml:\",chardata\"`\n }\n \n type Domain struct {\n-\tXMLName Name   `xml:\"domain\"`\n-\tCountry string `xml:\"attr\"`\n-\tName    []byte `xml:\"chardata\"`\n+\tXMLName struct{} `xml:\"domain\"`\n+\tCountry string   `xml:\",attr\"`\n+\tName    []byte   `xml:\",chardata\"`\n+\tComment []byte   `xml:\",comment\"`\n }\n \n type Book struct {\n-\tXMLName Name   `xml:\"book\"`\n-\tTitle   string `xml:\"chardata\"`\n+\tXMLName struct{} `xml:\"book\"`\n+\tTitle   string   `xml:\",chardata\"`\n }\n \n type SecretAgent struct {\n-\tXMLName   Name   `xml:\"agent\"`\n-\tHandle    string `xml:\"attr\"`\n+\tXMLName   struct{} `xml:\"agent\"`\n+\tHandle    string   `xml:\"handle,attr\"`\n \tIdentity  string\n-\tObfuscate string `xml:\"innerxml\"`\n+\tObfuscate string `xml:\",innerxml\"`\n }\n \n type NestedItems struct {\n-\tXMLName Name     `xml:\"result\"`\n+\tXMLName struct{} `xml:\"result\"`\n \tItems   []string `xml:\">item\"`\n \tItem1   []string `xml:\"Items>item1\"`\n }\n \n type NestedOrder struct {\n-\tXMLName Name   `xml:\"result\"`\n-\tField1  string `xml:\"parent>c\"`\n-\tField2  string `xml:\"parent>b\"`\n-\tField3  string `xml:\"parent>a\"`\n+\tXMLName struct{} `xml:\"result\"`\n+\tField1  string   `xml:\"parent>c\"`\n+\tField2  string   `xml:\"parent>b\"`\n+\tField3  string   `xml:\"parent>a\"`\n }\n \n type MixedNested struct {\n-\tXMLName Name   `xml:\"result\"`\n-\tA       string `xml:\"parent1>a\"`\n-\tB       string `xml:\"b\"`\n-\tC       string `xml:\"parent1>parent2>c\"`\n-\tD       string `xml:\"parent1>d\"`\n+\tXMLName struct{} `xml:\"result\"`\n+\tA       string   `xml:\"parent1>a\"`\n+\tB       string   `xml:\"b\"`\n+\tC       string   `xml:\"parent1>parent2>c\"`\n+\tD       string   `xml:\"parent1>d\"`\n }\n \n type NilTest struct {\n@@ -95,62 +97,165 @@ type NilTest struct {\n }\n \n type Service struct {\n-\tXMLName Name    `xml:\"service\"`\n-\tDomain  *Domain `xml:\"host>domain\"`\n-\tPort    *Port   `xml:\"host>port\"`\n+\tXMLName struct{} `xml:\"service\"`\n+\tDomain  *Domain  `xml:\"host>domain\"`\n+\tPort    *Port    `xml:\"host>port\"`\n \tExtra1  interface{}\n \tExtra2  interface{} `xml:\"host>extra2\"`\n }\n \n var nilStruct *Ship\n \n+type EmbedA struct {\n+\tEmbedC\n+\tEmbedB EmbedB\n+\tFieldA string\n+}\n+\n+type EmbedB struct {\n+\tFieldB string\n+\tEmbedC\n+}\n+\n+type EmbedC struct {\n+\tFieldA1 string `xml:\"FieldA>A1\"`\n+\tFieldA2 string `xml:\"FieldA>A2\"`\n+\tFieldB  string\n+\tFieldC  string\n+}\n+\n+type NameCasing struct {\n+\tXMLName struct{} `xml:\"casing\"`\n+\tXy      string\n+\tXY      string\n+\tXyA     string `xml:\"Xy,attr\"`\n+\tXYA     string `xml:\"XY,attr\"`\n+}\n+\n+type NamePrecedence struct {\n+\tXMLName     Name              `xml:\"Parent\"`\n+\tFromTag     XMLNameWithoutTag `xml:\"InTag\"`\n+\tFromNameVal XMLNameWithoutTag\n+\tFromNameTag XMLNameWithTag\n+\tInFieldName string\n+}\n+\n+type XMLNameWithTag struct {\n+\tXMLName Name   `xml:\"InXMLNameTag\"`\n+\tValue   string \",chardata\"\n+}\n+\n+type XMLNameWithoutTag struct {\n+\tXMLName Name\n+\tValue   string \",chardata\"\n+}\n+\n+type AttrTest struct {\n+\tInt   int     `xml:\",attr\"`\n+\tLower int     `xml:\"int,attr\"`\n+\tFloat float64 `xml:\",attr\"`\n+\tUint8 uint8   `xml:\",attr\"`\n+\tBool  bool    `xml:\",attr\"`\n+\tStr   string  `xml:\",attr\"`\n+}\n+\n+type AnyTest struct {\n+\tXMLName  struct{}  `xml:\"a\"`\n+\tNested   string    `xml:\"nested>value\"`\n+\tAnyField AnyHolder `xml:\",any\"`\n+}\n+\n+type AnyHolder struct {\n+\tXMLName Name\n+\tXML     string `xml:\",innerxml\"`\n+}\n+\n+type RecurseA struct {\n+\tA string\n+\tB *RecurseB\n+}\n+\n+type RecurseB struct {\n+\tA *RecurseA\n+\tB string\n+}\n+\n+type Plain struct {\n+\tV interface{}\n+}\n+\n+// Unless explicitly stated as such (or *Plain), all of the\n+// tests below are two-way tests. When introducing new tests,\n+// please try to make them two-way as well to ensure that\n+// marshalling and unmarshalling are as symmetrical as feasible.\n var marshalTests = []struct {\n-\tValue     interface{}\n-\tExpectXML string\n+\tValue         interface{}\n+\tExpectXML     string\n+\tMarshalOnly   bool\n+\tUnmarshalOnly bool\n }{\n \t// Test nil marshals to nothing\n-\t{Value: nil, ExpectXML: ``},\n-\t{Value: nilStruct, ExpectXML: ``},\n-\n-\t// Test value types (no tag name, so ???)\n-\t{Value: true, ExpectXML: `<???>true</???>`},\n-\t{Value: int(42), ExpectXML: `<???>42</???>`},\n-\t{Value: int8(42), ExpectXML: `<???>42</???>`},\n-\t{Value: int16(42), ExpectXML: `<???>42</???>`},\n-\t{Value: int32(42), ExpectXML: `<???>42</???>`},\n-\t{Value: uint(42), ExpectXML: `<???>42</???>`},\n-\t{Value: uint8(42), ExpectXML: `<???>42</???>`},\n-\t{Value: uint16(42), ExpectXML: `<???>42</???>`},\n-\t{Value: uint32(42), ExpectXML: `<???>42</???>`},\n-\t{Value: float32(1.25), ExpectXML: `<???>1.25</???>`},\n-\t{Value: float64(1.25), ExpectXML: `<???>1.25</???>`},\n-\t{Value: uintptr(0xFFDD), ExpectXML: `<???>65501</???>`},\n-\t{Value: \"gopher\", ExpectXML: `<???>gopher</???>`},\n-\t{Value: []byte(\"gopher\"), ExpectXML: `<???>gopher</???>`},\n-\t{Value: \"</>\", ExpectXML: `<???>&lt;/&gt;</???>`},\n-\t{Value: []byte(\"</>\"), ExpectXML: `<???>&lt;/&gt;</???>`},\n-\t{Value: [3]byte{'<', '/', '>'}, ExpectXML: `<???>&lt;/&gt;</???>`},\n-\t{Value: NamedType(\"potato\"), ExpectXML: `<???>potato</???>`},\n-\t{Value: []int{1, 2, 3}, ExpectXML: `<???>1</???><???>2</???><???>3</???>`},\n-\t{Value: [3]int{1, 2, 3}, ExpectXML: `<???>1</???><???>2</???><???>3</???>`},\n+\t{Value: nil, ExpectXML: ``, MarshalOnly: true},\n+\t{Value: nilStruct, ExpectXML: ``, MarshalOnly: true},\n+\n+\t// Test value types\n+\t{Value: &Plain{true}, ExpectXML: `<Plain><V>true</V></Plain>`},\n+\t{Value: &Plain{false}, ExpectXML: `<Plain><V>false</V></Plain>`},\n+\t{Value: &Plain{int(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{int8(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{int16(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{int32(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{uint(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{uint8(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{uint16(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{uint32(42)}, ExpectXML: `<Plain><V>42</V></Plain>`},\n+\t{Value: &Plain{float32(1.25)}, ExpectXML: `<Plain><V>1.25</V></Plain>`},\n+\t{Value: &Plain{float64(1.25)}, ExpectXML: `<Plain><V>1.25</V></Plain>`},\n+\t{Value: &Plain{uintptr(0xFFDD)}, ExpectXML: `<Plain><V>65501</V></Plain>`},\n+\t{Value: &Plain{\"gopher\"}, ExpectXML: `<Plain><V>gopher</V></Plain>`},\n+\t{Value: &Plain{[]byte(\"gopher\")}, ExpectXML: `<Plain><V>gopher</V></Plain>`},\n+\t{Value: &Plain{\"</>\"}, ExpectXML: `<Plain><V>&lt;/&gt;</V></Plain>`},\n+\t{Value: &Plain{[]byte(\"</>\")}, ExpectXML: `<Plain><V>&lt;/&gt;</V></Plain>`},\n+\t{Value: &Plain{[3]byte{'<', '/', '>'}}, ExpectXML: `<Plain><V>&lt;/&gt;</V></Plain>`},\n+\t{Value: &Plain{NamedType(\"potato\")}, ExpectXML: `<Plain><V>potato</V></Plain>`},\n+\t{Value: &Plain{[]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n+\t{Value: &Plain{[3]int{1, 2, 3}}, ExpectXML: `<Plain><V>1</V><V>2</V><V>3</V></Plain>`},\n \n \t// Test innerxml\n-\t{Value: RawXML(\"</>\"), ExpectXML: `</>`},\n \t{\n \t\tValue: &SecretAgent{\n \t\t\tHandle:    \"007\",\n \t\t\tIdentity:  \"James Bond\",\n \t\t\tObfuscate: \"<redacted/>\",\n \t\t},\n-\t\t//ExpectXML: `<agent handle=\"007\"><redacted/></agent>`,\n-\t\tExpectXML: `<agent handle=\"007\"><Identity>James Bond</Identity><redacted/></agent>`,\n+\t\tExpectXML:   `<agent handle=\"007\"><Identity>James Bond</Identity><redacted/></agent>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tValue: &SecretAgent{\n+\t\t\tHandle:    \"007\",\n+\t\t\tIdentity:  \"James Bond\",\n+\t\t\tObfuscate: \"<Identity>James Bond</Identity><redacted/>\",\n+\t\t},\n+\t\tExpectXML:     `<agent handle=\"007\"><Identity>James Bond</Identity><redacted/></agent>`,\n+\t\tUnmarshalOnly: true,\n+\t},\n+\n+\t// Test marshaller interface\n+\t{\n+\t\tValue:       RawXML(\"</>\"),\n+\t\tExpectXML:   `</>`,\n+\t\tMarshalOnly: true,\n \t},\n \n \t// Test structs\n \t{Value: &Port{Type: \"ssl\", Number: \"443\"}, ExpectXML: `<port type=\"ssl\">443</port>`},\n \t{Value: &Port{Number: \"443\"}, ExpectXML: `<port>443</port>`},\n \t{Value: &Port{Type: \"<unix>\"}, ExpectXML: `<port type=\"&lt;unix&gt;\"></port>`},\n+\t{Value: &Port{Number: \"443\", Comment: \"https\"}, ExpectXML: `<port><!--https-->443</port>`},\n+\t{Value: &Port{Number: \"443\", Comment: \"add space-\"}, ExpectXML: `<port><!--add space- -->443</port>`, MarshalOnly: true},\n \t{Value: &Domain{Name: []byte(\"google.com&friends\")}, ExpectXML: `<domain>google.com&amp;friends</domain>`},\n+\t{Value: &Domain{Name: []byte(\"google.com\"), Comment: []byte(\" &friends \")}, ExpectXML: `<domain>google.com<!-- &friends --></domain>`},\n \t{Value: &Book{Title: \"Pride & Prejudice\"}, ExpectXML: `<book>Pride &amp; Prejudice</book>`},\n \t{Value: atomValue, ExpectXML: atomXml},\n \t{\n@@ -203,24 +308,33 @@ var marshalTests = []struct {\n \t\t\t`</passenger>` +\n \t\t\t`</spaceship>`,\n \t},\n+\n \t// Test a>b\n \t{\n-\t\tValue: NestedItems{Items: []string{}, Item1: []string{}},\n+\t\tValue: &NestedItems{Items: nil, Item1: nil},\n+\t\tExpectXML: `<result>` +\n+\t\t\t`<Items>` +\n+\t\t\t`</Items>` +\n+\t\t\t`</result>`,\n+\t},\n+\t{\n+\t\tValue: &NestedItems{Items: []string{}, Item1: []string{}},\n \t\tExpectXML: `<result>` +\n \t\t\t`<Items>` +\n \t\t\t`</Items>` +\n \t\t\t`</result>`,\n+\t\tMarshalOnly: true,\n \t},\n \t{\n-\t\tValue: NestedItems{Items: []string{}, Item1: []string{\"A\"}},\n+\t\tValue: &NestedItems{Items: nil, Item1: []string{\"A\"}},\n \t\tExpectXML: `<result>` +\n \t\t\t`<Items>` +\n \t\t\t`<item1>A</item1>` +\n \t\t\t`</Items>` +\n \t\t\t`</result>`,\n \t},\n \t{\n-\t\tValue: NestedItems{Items: []string{\"A\", \"B\"}, Item1: []string{}},\n+\t\tValue: &NestedItems{Items: []string{\"A\", \"B\"}, Item1: nil},\n \t\tExpectXML: `<result>` +\n \t\t\t`<Items>` +\n \t\t\t`<item>A</item>` +\n@@ -229,7 +343,7 @@ var marshalTests = []struct {\n \t\t\t`</result>`,\n \t},\n \t{\n-\t\tValue: NestedItems{Items: []string{\"A\", \"B\"}, Item1: []string{\"C\"}},\n+\t\tValue: &NestedItems{Items: []string{\"A\", \"B\"}, Item1: []string{\"C\"}},\n \t\tExpectXML: `<result>` +\n \t\t\t`<Items>` +\n \t\t\t`<item>A</item>` +\n@@ -239,7 +353,7 @@ var marshalTests = []struct {\n \t\t\t`</result>`,\n \t},\n \t{\n-\t\tValue: NestedOrder{Field1: \"C\", Field2: \"B\", Field3: \"A\"},\n+\t\tValue: &NestedOrder{Field1: \"C\", Field2: \"B\", Field3: \"A\"},\n \t\tExpectXML: `<result>` +\n \t\t\t`<parent>` +\n \t\t\t`<c>C</c>` +\n@@ -249,16 +363,17 @@ var marshalTests = []struct {\n \t\t\t`</result>`,\n \t},\n \t{\n-\t\tValue: NilTest{A: \"A\", B: nil, C: \"C\"},\n-\t\tExpectXML: `<???>` +\n+\t\tValue: &NilTest{A: \"A\", B: nil, C: \"C\"},\n+\t\tExpectXML: `<NilTest>` +\n \t\t\t`<parent1>` +\n \t\t\t`<parent2><a>A</a></parent2>` +\n \t\t\t`<parent2><c>C</c></parent2>` +\n \t\t\t`</parent1>` +\n-\t\t\t`</???>`,\n+\t\t\t`</NilTest>`,\n+\t\tMarshalOnly: true, // Uses interface{}\n \t},\n \t{\n-\t\tValue: MixedNested{A: \"A\", B: \"B\", C: \"C\", D: \"D\"},\n+\t\tValue: &MixedNested{A: \"A\", B: \"B\", C: \"C\", D: \"D\"},\n \t\tExpectXML: `<result>` +\n \t\t\t`<parent1><a>A</a></parent1>` +\n \t\t\t`<b>B</b>` +\n@@ -269,32 +384,154 @@ var marshalTests = []struct {\n \t\t\t`</result>`,\n \t},\n \t{\n-\t\tValue:     Service{Port: &Port{Number: \"80\"}},\n+\t\tValue:     &Service{Port: &Port{Number: \"80\"}},\n \t\tExpectXML: `<service><host><port>80</port></host></service>`,\n \t},\n \t{\n-\t\tValue:     Service{},\n+\t\tValue:     &Service{},\n \t\tExpectXML: `<service></service>`,\n \t},\n \t{\n-\t\tValue: Service{Port: &Port{Number: \"80\"}, Extra1: \"A\", Extra2: \"B\"},\n+\t\tValue: &Service{Port: &Port{Number: \"80\"}, Extra1: \"A\", Extra2: \"B\"},\n \t\tExpectXML: `<service>` +\n \t\t\t`<host><port>80</port></host>` +\n \t\t\t`<Extra1>A</Extra1>` +\n \t\t\t`<host><extra2>B</extra2></host>` +\n \t\t\t`</service>`,\n+\t\tMarshalOnly: true,\n \t},\n \t{\n-\t\tValue: Service{Port: &Port{Number: \"80\"}, Extra2: \"example\"},\n+\t\tValue: &Service{Port: &Port{Number: \"80\"}, Extra2: \"example\"},\n \t\tExpectXML: `<service>` +\n \t\t\t`<host><port>80</port></host>` +\n \t\t\t`<host><extra2>example</extra2></host>` +\n \t\t\t`</service>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\n+\t// Test struct embedding\n+\t{\n+\t\tValue: &EmbedA{\n+\t\t\tEmbedC: EmbedC{\n+\t\t\t\tFieldA1: \"\", // Shadowed by A.A\n+\t\t\t\tFieldA2: \"\", // Shadowed by A.A\n+\t\t\t\tFieldB:  \"A.C.B\",\n+\t\t\t\tFieldC:  \"A.C.C\",\n+\t\t\t},\n+\t\t\tEmbedB: EmbedB{\n+\t\t\t\tFieldB: \"A.B.B\",\n+\t\t\t\tEmbedC: EmbedC{\n+\t\t\t\t\tFieldA1: \"A.B.C.A1\",\n+\t\t\t\t\tFieldA2: \"A.B.C.A2\",\n+\t\t\t\t\tFieldB:  \"\", // Shadowed by A.B.B\n+\t\t\t\t\tFieldC:  \"A.B.C.C\",\n+\t\t\t\t},\n+\t\t\t},\n+\t\t\tFieldA: \"A.A\",\n+\t\t},\n+\t\tExpectXML: `<EmbedA>` +\n+\t\t\t`<FieldB>A.C.B</FieldB>` +\n+\t\t\t`<FieldC>A.C.C</FieldC>` +\n+\t\t\t`<EmbedB>` +\n+\t\t\t`<FieldB>A.B.B</FieldB>` +\n+\t\t\t`<FieldA>` +\n+\t\t\t`<A1>A.B.C.A1</A1>` +\n+\t\t\t`<A2>A.B.C.A2</A2>` +\n+\t\t\t`</FieldA>` +\n+\t\t\t`<FieldC>A.B.C.C</FieldC>` +\n+\t\t\t`</EmbedB>` +\n+\t\t\t`<FieldA>A.A</FieldA>` +\n+\t\t\t`</EmbedA>`,\n+\t},\n+\n+\t// Test that name casing matters\n+\t{\n+\t\tValue:     &NameCasing{Xy: \"mixed\", XY: \"upper\", XyA: \"mixedA\", XYA: \"upperA\"},\n+\t\tExpectXML: `<casing Xy=\"mixedA\" XY=\"upperA\"><Xy>mixed</Xy><XY>upper</XY></casing>`,\n+\t},\n+\n+\t// Test the order in which the XML element name is chosen\n+\t{\n+\t\tValue: &NamePrecedence{\n+\t\t\tFromTag:     XMLNameWithoutTag{Value: \"A\"},\n+\t\t\tFromNameVal: XMLNameWithoutTag{XMLName: Name{Local: \"InXMLName\"}, Value: \"B\"},\n+\t\t\tFromNameTag: XMLNameWithTag{Value: \"C\"},\n+\t\t\tInFieldName: \"D\",\n+\t\t},\n+\t\tExpectXML: `<Parent>` +\n+\t\t\t`<InTag><Value>A</Value></InTag>` +\n+\t\t\t`<InXMLName><Value>B</Value></InXMLName>` +\n+\t\t\t`<InXMLNameTag><Value>C</Value></InXMLNameTag>` +\n+\t\t\t`<InFieldName>D</InFieldName>` +\n+\t\t\t`</Parent>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\t{\n+\t\tValue: &NamePrecedence{\n+\t\t\tXMLName:     Name{Local: \"Parent\"},\n+\t\t\tFromTag:     XMLNameWithoutTag{XMLName: Name{Local: \"InTag\"}, Value: \"A\"},\n+\t\t\tFromNameVal: XMLNameWithoutTag{XMLName: Name{Local: \"FromNameVal\"}, Value: \"B\"},\n+\t\t\tFromNameTag: XMLNameWithTag{XMLName: Name{Local: \"InXMLNameTag\"}, Value: \"C\"},\n+\t\t\tInFieldName: \"D\",\n+\t\t},\n+\t\tExpectXML: `<Parent>` +\n+\t\t\t`<InTag><Value>A</Value></InTag>` +\n+\t\t\t`<FromNameVal><Value>B</Value></FromNameVal>` +\n+\t\t\t`<InXMLNameTag><Value>C</Value></InXMLNameTag>` +\n+\t\t\t`<InFieldName>D</InFieldName>` +\n+\t\t\t`</Parent>`,\n+\t\tUnmarshalOnly: true,\n+\t},\n+\n+\t// Test attributes\n+\t{\n+\t\tValue: &AttrTest{\n+\t\t\tInt:   8,\n+\t\t\tLower: 9,\n+\t\t\tFloat: 23.5,\n+\t\t\tUint8: 255,\n+\t\t\tBool:  true,\n+\t\t\tStr:   \"s\",\n+\t\t},\n+\t\tExpectXML: `<AttrTest Int=\"8\" int=\"9\" Float=\"23.5\" Uint8=\"255\" Bool=\"true\" Str=\"s\"></AttrTest>`,\n+\t},\n+\n+\t// Test \",any\"\n+\t{\n+\t\tExpectXML: `<a><nested><value>known</value></nested><other><sub>unknown</sub></other></a>`,\n+\t\tValue: &AnyTest{\n+\t\t\tNested: \"known\",\n+\t\t\tAnyField: AnyHolder{\n+\t\t\t\tXMLName: Name{Local: \"other\"},\n+\t\t\t\tXML:     \"<sub>unknown</sub>\",\n+\t\t\t},\n+\t\t},\n+\t\tUnmarshalOnly: true,\n+\t},\n+\t{\n+\t\tValue:       &AnyTest{Nested: \"known\", AnyField: AnyHolder{XML: \"<unknown/>\"}},\n+\t\tExpectXML:   `<a><nested><value>known</value></nested></a>`,\n+\t\tMarshalOnly: true,\n+\t},\n+\n+\t// Test recursive types.\n+\t{\n+\t\tValue: &RecurseA{\n+\t\t\tA: \"a1\",\n+\t\t\tB: &RecurseB{\n+\t\t\t\tA: &RecurseA{\"a2\", nil},\n+\t\t\t\tB: \"b1\",\n+\t\t\t},\n+\t\t},\n+\t\tExpectXML: `<RecurseA><A>a1</A><B><A><A>a2</A></A><B>b1</B></B></RecurseA>`,\n \t},\n }\n \n func TestMarshal(t *testing.T) {\n \tfor idx, test := range marshalTests {\n+\t\tif test.UnmarshalOnly {\n+\t\t\tcontinue\n+\t\t}\n \t\tbuf := bytes.NewBuffer(nil)\n \t\terr := Marshal(buf, test.Value)\n \t\tif err != nil {\n@@ -303,9 +540,9 @@ func TestMarshal(t *testing.T) {\n \t\t}\n \t\tif got, want := buf.String(), test.ExpectXML; got != want {\n \t\t\tif strings.Contains(want, \"\\n\") {\n-\t\t\t\tt.Errorf(\"#%d: marshal(%#v) - GOT:\\n%s\\nWANT:\\n%s\", idx, test.Value, got, want)\n+\t\t\t\tt.Errorf(\"#%d: marshal(%#v):\\nHAVE:\\n%s\\nWANT:\\n%s\", idx, test.Value, got, want)\n \t\t\t} else {\n-\t\t\t\tt.Errorf(\"#%d: marshal(%#v) = %#q want %#q\", idx, test.Value, got, want)\n+\t\t\t\tt.Errorf(\"#%d: marshal(%#v):\\nhave %#q\\nwant %#q\", idx, test.Value, got, want)\n \t\t\t}\n \t\t}\n \t}\n@@ -334,57 +571,44 @@ var marshalErrorTests = []struct {\n \t\tErr:   \"xml: unsupported type: map[*xml.Ship]bool\",\n \t\tKind:  reflect.Map,\n \t},\n+\t{\n+\t\tValue: &Domain{Comment: []byte(\"f--bar\")},\n+\t\tErr:   `xml: comments must not contain \"--\"`,\n+\t},\n }\n \n func TestMarshalErrors(t *testing.T) {\n \tfor idx, test := range marshalErrorTests {\n \t\tbuf := bytes.NewBuffer(nil)\n \t\terr := Marshal(buf, test.Value)\n \t\tif err == nil || err.Error() != test.Err {\n-\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error] %q, want %q\", idx, test.Value, err, test.Err)\n+\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error] %v, want %v\", idx, test.Value, err, test.Err)\n \t\t}\n-\t\tif kind := err.(*UnsupportedTypeError).Type.Kind(); kind != test.Kind {\n-\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error kind] %s, want %s\", idx, test.Value, kind, test.Kind)\n+\t\tif test.Kind != reflect.Invalid {\n+\t\t\tif kind := err.(*UnsupportedTypeError).Type.Kind(); kind != test.Kind {\n+\t\t\t\tt.Errorf(\"#%d: marshal(%#v) = [error kind] %s, want %s\", idx, test.Value, kind, test.Kind)\n+\t\t\t}\n \t\t}\n \t}\n }\n \n // Do invertibility testing on the various structures that we test\n func TestUnmarshal(t *testing.T) {\n \tfor i, test := range marshalTests {\n-\t\t// Skip the nil pointers\n-\t\tif i <= 1 {\n+\t\tif test.MarshalOnly {\n \t\t\tcontinue\n \t\t}\n-\n-\t\tvar dest interface{}\n-\n-\t\tswitch test.Value.(type) {\n-\t\tcase *Ship, Ship:\n-\t\t\tdest = &Ship{}\n-\t\tcase *Port, Port:\n-\t\t\tdest = &Port{}\n-\t\tcase *Domain, Domain:\n-\t\t\tdest = &Domain{}\n-\t\tcase *Feed, Feed:\n-\t\t\tdest = &Feed{}\n-\t\tdefault:\n+\t\tif _, ok := test.Value.(*Plain); ok {\n \t\t\tcontinue\n \t\t}\n \n+\t\tvt := reflect.TypeOf(test.Value)\n+\t\tdest := reflect.New(vt.Elem()).Interface()\n \t\tbuffer := bytes.NewBufferString(test.ExpectXML)\n \t\terr := Unmarshal(buffer, dest)\n \n-\t\t// Don't compare XMLNames\n \t\tswitch fix := dest.(type) {\n-\t\tcase *Ship:\n-\t\t\tfix.XMLName = Name{}\n-\t\tcase *Port:\n-\t\t\tfix.XMLName = Name{}\n-\t\tcase *Domain:\n-\t\t\tfix.XMLName = Name{}\n \t\tcase *Feed:\n-\t\t\tfix.XMLName = Name{}\n \t\t\tfix.Author.InnerXML = \"\"\n \t\t\tfor i := range fix.Entry {\n \t\t\t\tfix.Entry[i].Author.InnerXML = \"\"\n@@ -394,30 +618,23 @@ func TestUnmarshal(t *testing.T) {\n \t\tif err != nil {\n \t\t\tt.Errorf(\"#%d: unexpected error: %#v\", i, err)\n \t\t} else if got, want := dest, test.Value; !reflect.DeepEqual(got, want) {\n-\t\t\tt.Errorf(\"#%d: unmarshal(%q) = %#v, want %#v\", i, test.ExpectXML, got, want)\n+\t\t\tt.Errorf(\"#%d: unmarshal(%q):\\nhave %#v\\nwant %#v\", i, test.ExpectXML, got, want)\n \t\t}\n \t}\n }\n \n func BenchmarkMarshal(b *testing.B) {\n-\tidx := len(marshalTests) - 1\n-\ttest := marshalTests[idx]\n-\n \tbuf := bytes.NewBuffer(nil)\n \tfor i := 0; i < b.N; i++ {\n-\t\tMarshal(buf, test.Value)\n+\t\tMarshal(buf, atomValue)\n \t\tbuf.Truncate(0)\n \t}\n }\n \n func BenchmarkUnmarshal(b *testing.B) {\n-\tidx := len(marshalTests) - 1\n-\ttest := marshalTests[idx]\n-\tsm := &Ship{}\n-\txml := []byte(test.ExpectXML)\n-\n+\txml := []byte(atomXml)\n \tfor i := 0; i < b.N; i++ {\n \t\tbuffer := bytes.NewBuffer(xml)\n-\t\tUnmarshal(buffer, sm)\n+\t\tUnmarshal(buffer, &Feed{})\n \t}\n }"}, {"sha": "dde68de3e7839c35fedce20c45a5ca2ad3883c16", "filename": "libgo/go/encoding/xml/read.go", "status": "modified", "additions": 132, "deletions": 200, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,13 +7,10 @@ package xml\n import (\n \t\"bytes\"\n \t\"errors\"\n-\t\"fmt\"\n \t\"io\"\n \t\"reflect\"\n \t\"strconv\"\n \t\"strings\"\n-\t\"unicode\"\n-\t\"unicode/utf8\"\n )\n \n // BUG(rsc): Mapping between XML elements and data structures is inherently flawed:\n@@ -31,7 +28,7 @@ import (\n // For example, given these definitions:\n //\n //\ttype Email struct {\n-//\t\tWhere string `xml:\"attr\"`\n+//\t\tWhere string `xml:\",attr\"`\n //\t\tAddr  string\n //\t}\n //\n@@ -64,7 +61,8 @@ import (\n //\n // via Unmarshal(r, &result) is equivalent to assigning\n //\n-//\tr = Result{xml.Name{\"\", \"result\"},\n+//\tr = Result{\n+//\t\txml.Name{Local: \"result\"},\n //\t\t\"Grace R. Emlin\", // name\n //\t\t\"phone\",\t  // no phone given\n //\t\t[]Email{\n@@ -87,9 +85,9 @@ import (\n // In the rules, the tag of a field refers to the value associated with the\n // key 'xml' in the struct field's tag (see the example above).\n //\n-//   * If the struct has a field of type []byte or string with tag \"innerxml\",\n-//      Unmarshal accumulates the raw XML nested inside the element\n-//      in that field.  The rest of the rules still apply.\n+//   * If the struct has a field of type []byte or string with tag\n+//      \",innerxml\", Unmarshal accumulates the raw XML nested inside the\n+//      element in that field.  The rest of the rules still apply.\n //\n //   * If the struct has a field named XMLName of type xml.Name,\n //      Unmarshal records the element name in that field.\n@@ -100,32 +98,40 @@ import (\n //      returns an error.\n //\n //   * If the XML element has an attribute whose name matches a\n-//      struct field of type string with tag \"attr\", Unmarshal records\n-//      the attribute value in that field.\n+//      struct field name with an associated tag containing \",attr\" or\n+//      the explicit name in a struct field tag of the form \"name,attr\",\n+//      Unmarshal records the attribute value in that field.\n //\n //   * If the XML element contains character data, that data is\n //      accumulated in the first struct field that has tag \"chardata\".\n //      The struct field may have type []byte or string.\n //      If there is no such field, the character data is discarded.\n //\n //   * If the XML element contains comments, they are accumulated in\n-//      the first struct field that has tag \"comments\".  The struct\n+//      the first struct field that has tag \",comments\".  The struct\n //      field may have type []byte or string.  If there is no such\n //      field, the comments are discarded.\n //\n //   * If the XML element contains a sub-element whose name matches\n-//      the prefix of a tag formatted as \"a>b>c\", unmarshal\n+//      the prefix of a tag formatted as \"a\" or \"a>b>c\", unmarshal\n //      will descend into the XML structure looking for elements with the\n-//      given names, and will map the innermost elements to that struct field.\n-//      A tag starting with \">\" is equivalent to one starting\n+//      given names, and will map the innermost elements to that struct\n+//      field. A tag starting with \">\" is equivalent to one starting\n //      with the field name followed by \">\".\n //\n-//   * If the XML element contains a sub-element whose name\n-//      matches a field whose tag is neither \"attr\" nor \"chardata\",\n-//      Unmarshal maps the sub-element to that struct field.\n-//      Otherwise, if the struct has a field named Any, unmarshal\n+//   * If the XML element contains a sub-element whose name matches\n+//      a struct field's XMLName tag and the struct field has no\n+//      explicit name tag as per the previous rule, unmarshal maps\n+//      the sub-element to that struct field.\n+//\n+//   * If the XML element contains a sub-element whose name matches a\n+//      field without any mode flags (\",attr\", \",chardata\", etc), Unmarshal\n //      maps the sub-element to that struct field.\n //\n+//   * If the XML element contains a sub-element that hasn't matched any\n+//      of the above rules and the struct has a field with tag \",any\",\n+//      unmarshal maps the sub-element to that struct field.\n+//\n // Unmarshal maps an XML element to a string or []byte by saving the\n // concatenation of that element's character data in the string or\n // []byte.\n@@ -169,18 +175,6 @@ type UnmarshalError string\n \n func (e UnmarshalError) Error() string { return string(e) }\n \n-// A TagPathError represents an error in the unmarshalling process\n-// caused by the use of field tags with conflicting paths.\n-type TagPathError struct {\n-\tStruct       reflect.Type\n-\tField1, Tag1 string\n-\tField2, Tag2 string\n-}\n-\n-func (e *TagPathError) Error() string {\n-\treturn fmt.Sprintf(\"%s field %q with tag %q conflicts with field %q with tag %q\", e.Struct, e.Field1, e.Tag1, e.Field2, e.Tag2)\n-}\n-\n // The Parser's Unmarshal method is like xml.Unmarshal\n // except that it can be passed a pointer to the initial start element,\n // useful when a client reads some raw XML tokens itself\n@@ -195,26 +189,6 @@ func (p *Parser) Unmarshal(val interface{}, start *StartElement) error {\n \treturn p.unmarshal(v.Elem(), start)\n }\n \n-// fieldName strips invalid characters from an XML name\n-// to create a valid Go struct name.  It also converts the\n-// name to lower case letters.\n-func fieldName(original string) string {\n-\n-\tvar i int\n-\t//remove leading underscores, without exhausting all characters\n-\tfor i = 0; i < len(original)-1 && original[i] == '_'; i++ {\n-\t}\n-\n-\treturn strings.Map(\n-\t\tfunc(x rune) rune {\n-\t\t\tif x == '_' || unicode.IsDigit(x) || unicode.IsLetter(x) {\n-\t\t\t\treturn unicode.ToLower(x)\n-\t\t\t}\n-\t\t\treturn -1\n-\t\t},\n-\t\toriginal[i:])\n-}\n-\n // Unmarshal a single XML element into val.\n func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n \t// Find start element if we need it.\n@@ -246,15 +220,22 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n \t\tsaveXML      reflect.Value\n \t\tsaveXMLIndex int\n \t\tsaveXMLData  []byte\n+\t\tsaveAny      reflect.Value\n \t\tsv           reflect.Value\n-\t\tstyp         reflect.Type\n-\t\tfieldPaths   map[string]pathInfo\n+\t\ttinfo        *typeInfo\n+\t\terr          error\n \t)\n \n \tswitch v := val; v.Kind() {\n \tdefault:\n \t\treturn errors.New(\"unknown type \" + v.Type().String())\n \n+\tcase reflect.Interface:\n+\t\t// TODO: For now, simply ignore the field. In the near\n+\t\t//       future we may choose to unmarshal the start\n+\t\t//       element on it, if not nil.\n+\t\treturn p.Skip()\n+\n \tcase reflect.Slice:\n \t\ttyp := v.Type()\n \t\tif typ.Elem().Kind() == reflect.Uint8 {\n@@ -288,100 +269,76 @@ func (p *Parser) unmarshal(val reflect.Value, start *StartElement) error {\n \t\tsaveData = v\n \n \tcase reflect.Struct:\n-\t\tif _, ok := v.Interface().(Name); ok {\n-\t\t\tv.Set(reflect.ValueOf(start.Name))\n-\t\t\tbreak\n-\t\t}\n-\n \t\tsv = v\n \t\ttyp := sv.Type()\n-\t\tstyp = typ\n-\t\t// Assign name.\n-\t\tif f, ok := typ.FieldByName(\"XMLName\"); ok {\n-\t\t\t// Validate element name.\n-\t\t\tif tag := f.Tag.Get(\"xml\"); tag != \"\" {\n-\t\t\t\tns := \"\"\n-\t\t\t\ti := strings.LastIndex(tag, \" \")\n-\t\t\t\tif i >= 0 {\n-\t\t\t\t\tns, tag = tag[0:i], tag[i+1:]\n-\t\t\t\t}\n-\t\t\t\tif tag != start.Name.Local {\n-\t\t\t\t\treturn UnmarshalError(\"expected element type <\" + tag + \"> but have <\" + start.Name.Local + \">\")\n-\t\t\t\t}\n-\t\t\t\tif ns != \"\" && ns != start.Name.Space {\n-\t\t\t\t\te := \"expected element <\" + tag + \"> in name space \" + ns + \" but have \"\n-\t\t\t\t\tif start.Name.Space == \"\" {\n-\t\t\t\t\t\te += \"no name space\"\n-\t\t\t\t\t} else {\n-\t\t\t\t\t\te += start.Name.Space\n-\t\t\t\t\t}\n-\t\t\t\t\treturn UnmarshalError(e)\n+\t\ttinfo, err = getTypeInfo(typ)\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\t// Validate and assign element name.\n+\t\tif tinfo.xmlname != nil {\n+\t\t\tfinfo := tinfo.xmlname\n+\t\t\tif finfo.name != \"\" && finfo.name != start.Name.Local {\n+\t\t\t\treturn UnmarshalError(\"expected element type <\" + finfo.name + \"> but have <\" + start.Name.Local + \">\")\n+\t\t\t}\n+\t\t\tif finfo.xmlns != \"\" && finfo.xmlns != start.Name.Space {\n+\t\t\t\te := \"expected element <\" + finfo.name + \"> in name space \" + finfo.xmlns + \" but have \"\n+\t\t\t\tif start.Name.Space == \"\" {\n+\t\t\t\t\te += \"no name space\"\n+\t\t\t\t} else {\n+\t\t\t\t\te += start.Name.Space\n \t\t\t\t}\n+\t\t\t\treturn UnmarshalError(e)\n \t\t\t}\n-\n-\t\t\t// Save\n-\t\t\tv := sv.FieldByIndex(f.Index)\n-\t\t\tif _, ok := v.Interface().(Name); ok {\n-\t\t\t\tv.Set(reflect.ValueOf(start.Name))\n+\t\t\tfv := sv.FieldByIndex(finfo.idx)\n+\t\t\tif _, ok := fv.Interface().(Name); ok {\n+\t\t\t\tfv.Set(reflect.ValueOf(start.Name))\n \t\t\t}\n \t\t}\n \n \t\t// Assign attributes.\n \t\t// Also, determine whether we need to save character data or comments.\n-\t\tfor i, n := 0, typ.NumField(); i < n; i++ {\n-\t\t\tf := typ.Field(i)\n-\t\t\tswitch f.Tag.Get(\"xml\") {\n-\t\t\tcase \"attr\":\n-\t\t\t\tstrv := sv.FieldByIndex(f.Index)\n+\t\tfor i := range tinfo.fields {\n+\t\t\tfinfo := &tinfo.fields[i]\n+\t\t\tswitch finfo.flags & fMode {\n+\t\t\tcase fAttr:\n+\t\t\t\tstrv := sv.FieldByIndex(finfo.idx)\n \t\t\t\t// Look for attribute.\n \t\t\t\tval := \"\"\n-\t\t\t\tk := strings.ToLower(f.Name)\n \t\t\t\tfor _, a := range start.Attr {\n-\t\t\t\t\tif fieldName(a.Name.Local) == k {\n+\t\t\t\t\tif a.Name.Local == finfo.name {\n \t\t\t\t\t\tval = a.Value\n \t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t\tcopyValue(strv, []byte(val))\n \n-\t\t\tcase \"comment\":\n+\t\t\tcase fCharData:\n+\t\t\t\tif !saveData.IsValid() {\n+\t\t\t\t\tsaveData = sv.FieldByIndex(finfo.idx)\n+\t\t\t\t}\n+\n+\t\t\tcase fComment:\n \t\t\t\tif !saveComment.IsValid() {\n-\t\t\t\t\tsaveComment = sv.FieldByIndex(f.Index)\n+\t\t\t\t\tsaveComment = sv.FieldByIndex(finfo.idx)\n \t\t\t\t}\n \n-\t\t\tcase \"chardata\":\n-\t\t\t\tif !saveData.IsValid() {\n-\t\t\t\t\tsaveData = sv.FieldByIndex(f.Index)\n+\t\t\tcase fAny:\n+\t\t\t\tif !saveAny.IsValid() {\n+\t\t\t\t\tsaveAny = sv.FieldByIndex(finfo.idx)\n \t\t\t\t}\n \n-\t\t\tcase \"innerxml\":\n+\t\t\tcase fInnerXml:\n \t\t\t\tif !saveXML.IsValid() {\n-\t\t\t\t\tsaveXML = sv.FieldByIndex(f.Index)\n+\t\t\t\t\tsaveXML = sv.FieldByIndex(finfo.idx)\n \t\t\t\t\tif p.saved == nil {\n \t\t\t\t\t\tsaveXMLIndex = 0\n \t\t\t\t\t\tp.saved = new(bytes.Buffer)\n \t\t\t\t\t} else {\n \t\t\t\t\t\tsaveXMLIndex = p.savedOffset()\n \t\t\t\t\t}\n \t\t\t\t}\n-\n-\t\t\tdefault:\n-\t\t\t\tif tag := f.Tag.Get(\"xml\"); strings.Contains(tag, \">\") {\n-\t\t\t\t\tif fieldPaths == nil {\n-\t\t\t\t\t\tfieldPaths = make(map[string]pathInfo)\n-\t\t\t\t\t}\n-\t\t\t\t\tpath := strings.ToLower(tag)\n-\t\t\t\t\tif strings.HasPrefix(tag, \">\") {\n-\t\t\t\t\t\tpath = strings.ToLower(f.Name) + path\n-\t\t\t\t\t}\n-\t\t\t\t\tif strings.HasSuffix(tag, \">\") {\n-\t\t\t\t\t\tpath = path[:len(path)-1]\n-\t\t\t\t\t}\n-\t\t\t\t\terr := addFieldPath(sv, fieldPaths, path, f.Index)\n-\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\treturn err\n-\t\t\t\t\t}\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -400,44 +357,23 @@ Loop:\n \t\t}\n \t\tswitch t := tok.(type) {\n \t\tcase StartElement:\n-\t\t\t// Sub-element.\n-\t\t\t// Look up by tag name.\n+\t\t\tconsumed := false\n \t\t\tif sv.IsValid() {\n-\t\t\t\tk := fieldName(t.Name.Local)\n-\n-\t\t\t\tif fieldPaths != nil {\n-\t\t\t\t\tif _, found := fieldPaths[k]; found {\n-\t\t\t\t\t\tif err := p.unmarshalPaths(sv, fieldPaths, k, &t); err != nil {\n-\t\t\t\t\t\t\treturn err\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tcontinue Loop\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\n-\t\t\t\tmatch := func(s string) bool {\n-\t\t\t\t\t// check if the name matches ignoring case\n-\t\t\t\t\tif strings.ToLower(s) != k {\n-\t\t\t\t\t\treturn false\n-\t\t\t\t\t}\n-\t\t\t\t\t// now check that it's public\n-\t\t\t\t\tc, _ := utf8.DecodeRuneInString(s)\n-\t\t\t\t\treturn unicode.IsUpper(c)\n-\t\t\t\t}\n-\n-\t\t\t\tf, found := styp.FieldByNameFunc(match)\n-\t\t\t\tif !found { // fall back to mop-up field named \"Any\"\n-\t\t\t\t\tf, found = styp.FieldByName(\"Any\")\n+\t\t\t\tconsumed, err = p.unmarshalPath(tinfo, sv, nil, &t)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn err\n \t\t\t\t}\n-\t\t\t\tif found {\n-\t\t\t\t\tif err := p.unmarshal(sv.FieldByIndex(f.Index), &t); err != nil {\n+\t\t\t\tif !consumed && saveAny.IsValid() {\n+\t\t\t\t\tconsumed = true\n+\t\t\t\t\tif err := p.unmarshal(saveAny, &t); err != nil {\n \t\t\t\t\t\treturn err\n \t\t\t\t\t}\n-\t\t\t\t\tcontinue Loop\n \t\t\t\t}\n \t\t\t}\n-\t\t\t// Not saving sub-element but still have to skip over it.\n-\t\t\tif err := p.Skip(); err != nil {\n-\t\t\t\treturn err\n+\t\t\tif !consumed {\n+\t\t\t\tif err := p.Skip(); err != nil {\n+\t\t\t\t\treturn err\n+\t\t\t\t}\n \t\t\t}\n \n \t\tcase EndElement:\n@@ -503,10 +439,10 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \t\treturn err == nil\n \t}\n \n-\t// Save accumulated data and comments\n+\t// Save accumulated data.\n \tswitch t := dst; t.Kind() {\n \tcase reflect.Invalid:\n-\t\t// Probably a comment, handled below\n+\t\t// Probably a comment.\n \tdefault:\n \t\treturn errors.New(\"cannot happen: unknown type \" + t.Type().String())\n \tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n@@ -538,70 +474,66 @@ func copyValue(dst reflect.Value, src []byte) (err error) {\n \treturn nil\n }\n \n-type pathInfo struct {\n-\tfieldIdx []int\n-\tcomplete bool\n-}\n-\n-// addFieldPath takes an element path such as \"a>b>c\" and fills the\n-// paths map with all paths leading to it (\"a\", \"a>b\", and \"a>b>c\").\n-// It is okay for paths to share a common, shorter prefix but not ok\n-// for one path to itself be a prefix of another.\n-func addFieldPath(sv reflect.Value, paths map[string]pathInfo, path string, fieldIdx []int) error {\n-\tif info, found := paths[path]; found {\n-\t\treturn tagError(sv, info.fieldIdx, fieldIdx)\n-\t}\n-\tpaths[path] = pathInfo{fieldIdx, true}\n-\tfor {\n-\t\ti := strings.LastIndex(path, \">\")\n-\t\tif i < 0 {\n-\t\t\tbreak\n+// unmarshalPath walks down an XML structure looking for wanted\n+// paths, and calls unmarshal on them.\n+// The consumed result tells whether XML elements have been consumed\n+// from the Parser until start's matching end element, or if it's\n+// still untouched because start is uninteresting for sv's fields.\n+func (p *Parser) unmarshalPath(tinfo *typeInfo, sv reflect.Value, parents []string, start *StartElement) (consumed bool, err error) {\n+\trecurse := false\n+Loop:\n+\tfor i := range tinfo.fields {\n+\t\tfinfo := &tinfo.fields[i]\n+\t\tif finfo.flags&fElement == 0 || len(finfo.parents) < len(parents) {\n+\t\t\tcontinue\n \t\t}\n-\t\tpath = path[:i]\n-\t\tif info, found := paths[path]; found {\n-\t\t\tif info.complete {\n-\t\t\t\treturn tagError(sv, info.fieldIdx, fieldIdx)\n+\t\tfor j := range parents {\n+\t\t\tif parents[j] != finfo.parents[j] {\n+\t\t\t\tcontinue Loop\n \t\t\t}\n-\t\t} else {\n-\t\t\tpaths[path] = pathInfo{fieldIdx, false}\n+\t\t}\n+\t\tif len(finfo.parents) == len(parents) && finfo.name == start.Name.Local {\n+\t\t\t// It's a perfect match, unmarshal the field.\n+\t\t\treturn true, p.unmarshal(sv.FieldByIndex(finfo.idx), start)\n+\t\t}\n+\t\tif len(finfo.parents) > len(parents) && finfo.parents[len(parents)] == start.Name.Local {\n+\t\t\t// It's a prefix for the field. Break and recurse\n+\t\t\t// since it's not ok for one field path to be itself\n+\t\t\t// the prefix for another field path.\n+\t\t\trecurse = true\n+\n+\t\t\t// We can reuse the same slice as long as we\n+\t\t\t// don't try to append to it.\n+\t\t\tparents = finfo.parents[:len(parents)+1]\n+\t\t\tbreak\n \t\t}\n \t}\n-\treturn nil\n-\n-}\n-\n-func tagError(sv reflect.Value, idx1 []int, idx2 []int) error {\n-\tt := sv.Type()\n-\tf1 := t.FieldByIndex(idx1)\n-\tf2 := t.FieldByIndex(idx2)\n-\treturn &TagPathError{t, f1.Name, f1.Tag.Get(\"xml\"), f2.Name, f2.Tag.Get(\"xml\")}\n-}\n-\n-// unmarshalPaths walks down an XML structure looking for\n-// wanted paths, and calls unmarshal on them.\n-func (p *Parser) unmarshalPaths(sv reflect.Value, paths map[string]pathInfo, path string, start *StartElement) error {\n-\tif info, _ := paths[path]; info.complete {\n-\t\treturn p.unmarshal(sv.FieldByIndex(info.fieldIdx), start)\n+\tif !recurse {\n+\t\t// We have no business with this element.\n+\t\treturn false, nil\n \t}\n+\t// The element is not a perfect match for any field, but one\n+\t// or more fields have the path to this element as a parent\n+\t// prefix. Recurse and attempt to match these.\n \tfor {\n-\t\ttok, err := p.Token()\n+\t\tvar tok Token\n+\t\ttok, err = p.Token()\n \t\tif err != nil {\n-\t\t\treturn err\n+\t\t\treturn true, err\n \t\t}\n \t\tswitch t := tok.(type) {\n \t\tcase StartElement:\n-\t\t\tk := path + \">\" + fieldName(t.Name.Local)\n-\t\t\tif _, found := paths[k]; found {\n-\t\t\t\tif err := p.unmarshalPaths(sv, paths, k, &t); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\t\t\t\tcontinue\n+\t\t\tconsumed2, err := p.unmarshalPath(tinfo, sv, parents, &t)\n+\t\t\tif err != nil {\n+\t\t\t\treturn true, err\n \t\t\t}\n-\t\t\tif err := p.Skip(); err != nil {\n-\t\t\t\treturn err\n+\t\t\tif !consumed2 {\n+\t\t\t\tif err := p.Skip(); err != nil {\n+\t\t\t\t\treturn true, err\n+\t\t\t\t}\n \t\t\t}\n \t\tcase EndElement:\n-\t\t\treturn nil\n+\t\t\treturn true, nil\n \t\t}\n \t}\n \tpanic(\"unreachable\")"}, {"sha": "ff61bd7e1c51eee836fc2c75db1aa79e6d65151a", "filename": "libgo/go/encoding/xml/read_test.go", "status": "modified", "additions": 73, "deletions": 116, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fread_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,14 +6,15 @@ package xml\n \n import (\n \t\"reflect\"\n+\t\"strings\"\n \t\"testing\"\n )\n \n // Stripped down Atom feed data structures.\n \n func TestUnmarshalFeed(t *testing.T) {\n \tvar f Feed\n-\tif err := Unmarshal(StringReader(atomFeedString), &f); err != nil {\n+\tif err := Unmarshal(strings.NewReader(atomFeedString), &f); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t}\n \tif !reflect.DeepEqual(f, atomFeed) {\n@@ -24,8 +25,8 @@ func TestUnmarshalFeed(t *testing.T) {\n // hget http://codereview.appspot.com/rss/mine/rsc\n const atomFeedString = `\n <?xml version=\"1.0\" encoding=\"utf-8\"?>\n-<feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en-us\"><title>Code Review - My issues</title><link href=\"http://codereview.appspot.com/\" rel=\"alternate\"></link><li-nk href=\"http://codereview.appspot.com/rss/mine/rsc\" rel=\"self\"></li-nk><id>http://codereview.appspot.com/</id><updated>2009-10-04T01:35:58+00:00</updated><author><name>rietveld&lt;&gt;</name></author><entry><title>rietveld: an attempt at pubsubhubbub\n-</title><link hre-f=\"http://codereview.appspot.com/126085\" rel=\"alternate\"></link><updated>2009-10-04T01:35:58+00:00</updated><author><name>email-address-removed</name></author><id>urn:md5:134d9179c41f806be79b3a5f7877d19a</id><summary type=\"html\">\n+<feed xmlns=\"http://www.w3.org/2005/Atom\" xml:lang=\"en-us\"><title>Code Review - My issues</title><link href=\"http://codereview.appspot.com/\" rel=\"alternate\"></link><link href=\"http://codereview.appspot.com/rss/mine/rsc\" rel=\"self\"></link><id>http://codereview.appspot.com/</id><updated>2009-10-04T01:35:58+00:00</updated><author><name>rietveld&lt;&gt;</name></author><entry><title>rietveld: an attempt at pubsubhubbub\n+</title><link href=\"http://codereview.appspot.com/126085\" rel=\"alternate\"></link><updated>2009-10-04T01:35:58+00:00</updated><author><name>email-address-removed</name></author><id>urn:md5:134d9179c41f806be79b3a5f7877d19a</id><summary type=\"html\">\n   An attempt at adding pubsubhubbub support to Rietveld.\n http://code.google.com/p/pubsubhubbub\n http://code.google.com/p/rietveld/issues/detail?id=155\n@@ -78,39 +79,39 @@ not being used from outside intra_region_diff.py.\n </summary></entry></feed> \t   `\n \n type Feed struct {\n-\tXMLName Name `xml:\"http://www.w3.org/2005/Atom feed\"`\n-\tTitle   string\n-\tId      string\n-\tLink    []Link\n-\tUpdated Time\n-\tAuthor  Person\n-\tEntry   []Entry\n+\tXMLName Name    `xml:\"http://www.w3.org/2005/Atom feed\"`\n+\tTitle   string  `xml:\"title\"`\n+\tId      string  `xml:\"id\"`\n+\tLink    []Link  `xml:\"link\"`\n+\tUpdated Time    `xml:\"updated\"`\n+\tAuthor  Person  `xml:\"author\"`\n+\tEntry   []Entry `xml:\"entry\"`\n }\n \n type Entry struct {\n-\tTitle   string\n-\tId      string\n-\tLink    []Link\n-\tUpdated Time\n-\tAuthor  Person\n-\tSummary Text\n+\tTitle   string `xml:\"title\"`\n+\tId      string `xml:\"id\"`\n+\tLink    []Link `xml:\"link\"`\n+\tUpdated Time   `xml:\"updated\"`\n+\tAuthor  Person `xml:\"author\"`\n+\tSummary Text   `xml:\"summary\"`\n }\n \n type Link struct {\n-\tRel  string `xml:\"attr\"`\n-\tHref string `xml:\"attr\"`\n+\tRel  string `xml:\"rel,attr\"`\n+\tHref string `xml:\"href,attr\"`\n }\n \n type Person struct {\n-\tName     string\n-\tURI      string\n-\tEmail    string\n-\tInnerXML string `xml:\"innerxml\"`\n+\tName     string `xml:\"name\"`\n+\tURI      string `xml:\"uri\"`\n+\tEmail    string `xml:\"email\"`\n+\tInnerXML string `xml:\",innerxml\"`\n }\n \n type Text struct {\n-\tType string `xml:\"attr\"`\n-\tBody string `xml:\"chardata\"`\n+\tType string `xml:\"type,attr\"`\n+\tBody string `xml:\",chardata\"`\n }\n \n type Time string\n@@ -213,63 +214,45 @@ not being used from outside intra_region_diff.py.\n \t},\n }\n \n-type FieldNameTest struct {\n-\tin, out string\n-}\n-\n-var FieldNameTests = []FieldNameTest{\n-\t{\"Profile-Image\", \"profileimage\"},\n-\t{\"_score\", \"score\"},\n-}\n-\n-func TestFieldName(t *testing.T) {\n-\tfor _, tt := range FieldNameTests {\n-\t\ta := fieldName(tt.in)\n-\t\tif a != tt.out {\n-\t\t\tt.Fatalf(\"have %#v\\nwant %#v\\n\\n\", a, tt.out)\n-\t\t}\n-\t}\n-}\n-\n const pathTestString = `\n-<result>\n-    <before>1</before>\n-    <items>\n-        <item1>\n-            <value>A</value>\n-        </item1>\n-        <item2>\n-            <value>B</value>\n-        </item2>\n+<Result>\n+    <Before>1</Before>\n+    <Items>\n+        <Item1>\n+            <Value>A</Value>\n+        </Item1>\n+        <Item2>\n+            <Value>B</Value>\n+        </Item2>\n         <Item1>\n             <Value>C</Value>\n             <Value>D</Value>\n         </Item1>\n         <_>\n-            <value>E</value>\n+            <Value>E</Value>\n         </_>\n-    </items>\n-    <after>2</after>\n-</result>\n+    </Items>\n+    <After>2</After>\n+</Result>\n `\n \n type PathTestItem struct {\n \tValue string\n }\n \n type PathTestA struct {\n-\tItems         []PathTestItem `xml:\">item1\"`\n+\tItems         []PathTestItem `xml:\">Item1\"`\n \tBefore, After string\n }\n \n type PathTestB struct {\n-\tOther         []PathTestItem `xml:\"items>Item1\"`\n+\tOther         []PathTestItem `xml:\"Items>Item1\"`\n \tBefore, After string\n }\n \n type PathTestC struct {\n-\tValues1       []string `xml:\"items>item1>value\"`\n-\tValues2       []string `xml:\"items>item2>value\"`\n+\tValues1       []string `xml:\"Items>Item1>Value\"`\n+\tValues2       []string `xml:\"Items>Item2>Value\"`\n \tBefore, After string\n }\n \n@@ -278,12 +261,12 @@ type PathTestSet struct {\n }\n \n type PathTestD struct {\n-\tOther         PathTestSet `xml:\"items>\"`\n+\tOther         PathTestSet `xml:\"Items\"`\n \tBefore, After string\n }\n \n type PathTestE struct {\n-\tUnderline     string `xml:\"items>_>value\"`\n+\tUnderline     string `xml:\"Items>_>Value\"`\n \tBefore, After string\n }\n \n@@ -298,7 +281,7 @@ var pathTests = []interface{}{\n func TestUnmarshalPaths(t *testing.T) {\n \tfor _, pt := range pathTests {\n \t\tv := reflect.New(reflect.TypeOf(pt).Elem()).Interface()\n-\t\tif err := Unmarshal(StringReader(pathTestString), v); err != nil {\n+\t\tif err := Unmarshal(strings.NewReader(pathTestString), v); err != nil {\n \t\t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t\t}\n \t\tif !reflect.DeepEqual(v, pt) {\n@@ -310,7 +293,7 @@ func TestUnmarshalPaths(t *testing.T) {\n type BadPathTestA struct {\n \tFirst  string `xml:\"items>item1\"`\n \tOther  string `xml:\"items>item2\"`\n-\tSecond string `xml:\"items>\"`\n+\tSecond string `xml:\"items\"`\n }\n \n type BadPathTestB struct {\n@@ -319,81 +302,55 @@ type BadPathTestB struct {\n \tSecond string `xml:\"items>item1>value\"`\n }\n \n+type BadPathTestC struct {\n+\tFirst  string\n+\tSecond string `xml:\"First\"`\n+}\n+\n+type BadPathTestD struct {\n+\tBadPathEmbeddedA\n+\tBadPathEmbeddedB\n+}\n+\n+type BadPathEmbeddedA struct {\n+\tFirst string\n+}\n+\n+type BadPathEmbeddedB struct {\n+\tSecond string `xml:\"First\"`\n+}\n+\n var badPathTests = []struct {\n \tv, e interface{}\n }{\n-\t{&BadPathTestA{}, &TagPathError{reflect.TypeOf(BadPathTestA{}), \"First\", \"items>item1\", \"Second\", \"items>\"}},\n+\t{&BadPathTestA{}, &TagPathError{reflect.TypeOf(BadPathTestA{}), \"First\", \"items>item1\", \"Second\", \"items\"}},\n \t{&BadPathTestB{}, &TagPathError{reflect.TypeOf(BadPathTestB{}), \"First\", \"items>item1\", \"Second\", \"items>item1>value\"}},\n+\t{&BadPathTestC{}, &TagPathError{reflect.TypeOf(BadPathTestC{}), \"First\", \"\", \"Second\", \"First\"}},\n+\t{&BadPathTestD{}, &TagPathError{reflect.TypeOf(BadPathTestD{}), \"First\", \"\", \"Second\", \"First\"}},\n }\n \n func TestUnmarshalBadPaths(t *testing.T) {\n \tfor _, tt := range badPathTests {\n-\t\terr := Unmarshal(StringReader(pathTestString), tt.v)\n+\t\terr := Unmarshal(strings.NewReader(pathTestString), tt.v)\n \t\tif !reflect.DeepEqual(err, tt.e) {\n-\t\t\tt.Fatalf(\"Unmarshal with %#v didn't fail properly: %#v\", tt.v, err)\n+\t\t\tt.Fatalf(\"Unmarshal with %#v didn't fail properly:\\nhave %#v,\\nwant %#v\", tt.v, err, tt.e)\n \t\t}\n \t}\n }\n \n-func TestUnmarshalAttrs(t *testing.T) {\n-\tvar f AttrTest\n-\tif err := Unmarshal(StringReader(attrString), &f); err != nil {\n-\t\tt.Fatalf(\"Unmarshal: %s\", err)\n-\t}\n-\tif !reflect.DeepEqual(f, attrStruct) {\n-\t\tt.Fatalf(\"have %#v\\nwant %#v\", f, attrStruct)\n-\t}\n-}\n-\n-type AttrTest struct {\n-\tTest1 Test1\n-\tTest2 Test2\n-}\n-\n-type Test1 struct {\n-\tInt   int     `xml:\"attr\"`\n-\tFloat float64 `xml:\"attr\"`\n-\tUint8 uint8   `xml:\"attr\"`\n-}\n-\n-type Test2 struct {\n-\tBool bool `xml:\"attr\"`\n-}\n-\n-const attrString = `\n-<?xml version=\"1.0\" charset=\"utf-8\"?>\n-<attrtest>\n-  <test1 int=\"8\" float=\"23.5\" uint8=\"255\"/>\n-  <test2 bool=\"true\"/>\n-</attrtest>\n-`\n-\n-var attrStruct = AttrTest{\n-\tTest1: Test1{\n-\t\tInt:   8,\n-\t\tFloat: 23.5,\n-\t\tUint8: 255,\n-\t},\n-\tTest2: Test2{\n-\t\tBool: true,\n-\t},\n-}\n-\n-// test data for TestUnmarshalWithoutNameType\n-\n const OK = \"OK\"\n const withoutNameTypeData = `\n <?xml version=\"1.0\" charset=\"utf-8\"?>\n-<Test3 attr=\"OK\" />`\n+<Test3 Attr=\"OK\" />`\n \n type TestThree struct {\n-\tXMLName bool   `xml:\"Test3\"` // XMLName field without an xml.Name type \n-\tAttr    string `xml:\"attr\"`\n+\tXMLName Name   `xml:\"Test3\"`\n+\tAttr    string `xml:\",attr\"`\n }\n \n func TestUnmarshalWithoutNameType(t *testing.T) {\n \tvar x TestThree\n-\tif err := Unmarshal(StringReader(withoutNameTypeData), &x); err != nil {\n+\tif err := Unmarshal(strings.NewReader(withoutNameTypeData), &x); err != nil {\n \t\tt.Fatalf(\"Unmarshal: %s\", err)\n \t}\n \tif x.Attr != OK {"}, {"sha": "8f79c4e78bbb6a6f3ce7569b79e6ea20edf0942c", "filename": "libgo/go/encoding/xml/typeinfo.go", "status": "added", "additions": 321, "deletions": 0, "changes": 321, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Ftypeinfo.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,321 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package xml\n+\n+import (\n+\t\"fmt\"\n+\t\"reflect\"\n+\t\"strings\"\n+\t\"sync\"\n+)\n+\n+// typeInfo holds details for the xml representation of a type.\n+type typeInfo struct {\n+\txmlname *fieldInfo\n+\tfields  []fieldInfo\n+}\n+\n+// fieldInfo holds details for the xml representation of a single field.\n+type fieldInfo struct {\n+\tidx     []int\n+\tname    string\n+\txmlns   string\n+\tflags   fieldFlags\n+\tparents []string\n+}\n+\n+type fieldFlags int\n+\n+const (\n+\tfElement fieldFlags = 1 << iota\n+\tfAttr\n+\tfCharData\n+\tfInnerXml\n+\tfComment\n+\tfAny\n+\n+\t// TODO:\n+\t//fIgnore\n+\t//fOmitEmpty\n+\n+\tfMode = fElement | fAttr | fCharData | fInnerXml | fComment | fAny\n+)\n+\n+var tinfoMap = make(map[reflect.Type]*typeInfo)\n+var tinfoLock sync.RWMutex\n+\n+// getTypeInfo returns the typeInfo structure with details necessary\n+// for marshalling and unmarshalling typ.\n+func getTypeInfo(typ reflect.Type) (*typeInfo, error) {\n+\ttinfoLock.RLock()\n+\ttinfo, ok := tinfoMap[typ]\n+\ttinfoLock.RUnlock()\n+\tif ok {\n+\t\treturn tinfo, nil\n+\t}\n+\ttinfo = &typeInfo{}\n+\tif typ.Kind() == reflect.Struct {\n+\t\tn := typ.NumField()\n+\t\tfor i := 0; i < n; i++ {\n+\t\t\tf := typ.Field(i)\n+\t\t\tif f.PkgPath != \"\" {\n+\t\t\t\tcontinue // Private field\n+\t\t\t}\n+\n+\t\t\t// For embedded structs, embed its fields.\n+\t\t\tif f.Anonymous {\n+\t\t\t\tif f.Type.Kind() != reflect.Struct {\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\t\t\t\tinner, err := getTypeInfo(f.Type)\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, err\n+\t\t\t\t}\n+\t\t\t\tfor _, finfo := range inner.fields {\n+\t\t\t\t\tfinfo.idx = append([]int{i}, finfo.idx...)\n+\t\t\t\t\tif err := addFieldInfo(typ, tinfo, &finfo); err != nil {\n+\t\t\t\t\t\treturn nil, err\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tfinfo, err := structFieldInfo(typ, &f)\n+\t\t\tif err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\n+\t\t\tif f.Name == \"XMLName\" {\n+\t\t\t\ttinfo.xmlname = finfo\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Add the field if it doesn't conflict with other fields.\n+\t\t\tif err := addFieldInfo(typ, tinfo, finfo); err != nil {\n+\t\t\t\treturn nil, err\n+\t\t\t}\n+\t\t}\n+\t}\n+\ttinfoLock.Lock()\n+\ttinfoMap[typ] = tinfo\n+\ttinfoLock.Unlock()\n+\treturn tinfo, nil\n+}\n+\n+// structFieldInfo builds and returns a fieldInfo for f.\n+func structFieldInfo(typ reflect.Type, f *reflect.StructField) (*fieldInfo, error) {\n+\tfinfo := &fieldInfo{idx: f.Index}\n+\n+\t// Split the tag from the xml namespace if necessary.\n+\ttag := f.Tag.Get(\"xml\")\n+\tif i := strings.Index(tag, \" \"); i >= 0 {\n+\t\tfinfo.xmlns, tag = tag[:i], tag[i+1:]\n+\t}\n+\n+\t// Parse flags.\n+\ttokens := strings.Split(tag, \",\")\n+\tif len(tokens) == 1 {\n+\t\tfinfo.flags = fElement\n+\t} else {\n+\t\ttag = tokens[0]\n+\t\tfor _, flag := range tokens[1:] {\n+\t\t\tswitch flag {\n+\t\t\tcase \"attr\":\n+\t\t\t\tfinfo.flags |= fAttr\n+\t\t\tcase \"chardata\":\n+\t\t\t\tfinfo.flags |= fCharData\n+\t\t\tcase \"innerxml\":\n+\t\t\t\tfinfo.flags |= fInnerXml\n+\t\t\tcase \"comment\":\n+\t\t\t\tfinfo.flags |= fComment\n+\t\t\tcase \"any\":\n+\t\t\t\tfinfo.flags |= fAny\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Validate the flags used.\n+\t\tswitch mode := finfo.flags & fMode; mode {\n+\t\tcase 0:\n+\t\t\tfinfo.flags |= fElement\n+\t\tcase fAttr, fCharData, fInnerXml, fComment, fAny:\n+\t\t\tif f.Name != \"XMLName\" && (tag == \"\" || mode == fAttr) {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tfallthrough\n+\t\tdefault:\n+\t\t\t// This will also catch multiple modes in a single field.\n+\t\t\treturn nil, fmt.Errorf(\"xml: invalid tag in field %s of type %s: %q\",\n+\t\t\t\tf.Name, typ, f.Tag.Get(\"xml\"))\n+\t\t}\n+\t}\n+\n+\t// Use of xmlns without a name is not allowed.\n+\tif finfo.xmlns != \"\" && tag == \"\" {\n+\t\treturn nil, fmt.Errorf(\"xml: namespace without name in field %s of type %s: %q\",\n+\t\t\tf.Name, typ, f.Tag.Get(\"xml\"))\n+\t}\n+\n+\tif f.Name == \"XMLName\" {\n+\t\t// The XMLName field records the XML element name. Don't\n+\t\t// process it as usual because its name should default to\n+\t\t// empty rather than to the field name.\n+\t\tfinfo.name = tag\n+\t\treturn finfo, nil\n+\t}\n+\n+\tif tag == \"\" {\n+\t\t// If the name part of the tag is completely empty, get\n+\t\t// default from XMLName of underlying struct if feasible,\n+\t\t// or field name otherwise.\n+\t\tif xmlname := lookupXMLName(f.Type); xmlname != nil {\n+\t\t\tfinfo.xmlns, finfo.name = xmlname.xmlns, xmlname.name\n+\t\t} else {\n+\t\t\tfinfo.name = f.Name\n+\t\t}\n+\t\treturn finfo, nil\n+\t}\n+\n+\t// Prepare field name and parents.\n+\ttokens = strings.Split(tag, \">\")\n+\tif tokens[0] == \"\" {\n+\t\ttokens[0] = f.Name\n+\t}\n+\tif tokens[len(tokens)-1] == \"\" {\n+\t\treturn nil, fmt.Errorf(\"xml: trailing '>' in field %s of type %s\", f.Name, typ)\n+\t}\n+\tfinfo.name = tokens[len(tokens)-1]\n+\tif len(tokens) > 1 {\n+\t\tfinfo.parents = tokens[:len(tokens)-1]\n+\t}\n+\n+\t// If the field type has an XMLName field, the names must match\n+\t// so that the behavior of both marshalling and unmarshalling\n+\t// is straighforward and unambiguous.\n+\tif finfo.flags&fElement != 0 {\n+\t\tftyp := f.Type\n+\t\txmlname := lookupXMLName(ftyp)\n+\t\tif xmlname != nil && xmlname.name != finfo.name {\n+\t\t\treturn nil, fmt.Errorf(\"xml: name %q in tag of %s.%s conflicts with name %q in %s.XMLName\",\n+\t\t\t\tfinfo.name, typ, f.Name, xmlname.name, ftyp)\n+\t\t}\n+\t}\n+\treturn finfo, nil\n+}\n+\n+// lookupXMLName returns the fieldInfo for typ's XMLName field\n+// in case it exists and has a valid xml field tag, otherwise\n+// it returns nil.\n+func lookupXMLName(typ reflect.Type) (xmlname *fieldInfo) {\n+\tfor typ.Kind() == reflect.Ptr {\n+\t\ttyp = typ.Elem()\n+\t}\n+\tif typ.Kind() != reflect.Struct {\n+\t\treturn nil\n+\t}\n+\tfor i, n := 0, typ.NumField(); i < n; i++ {\n+\t\tf := typ.Field(i)\n+\t\tif f.Name != \"XMLName\" {\n+\t\t\tcontinue\n+\t\t}\n+\t\tfinfo, err := structFieldInfo(typ, &f)\n+\t\tif finfo.name != \"\" && err == nil {\n+\t\t\treturn finfo\n+\t\t}\n+\t\t// Also consider errors as a non-existent field tag\n+\t\t// and let getTypeInfo itself report the error.\n+\t\tbreak\n+\t}\n+\treturn nil\n+}\n+\n+func min(a, b int) int {\n+\tif a <= b {\n+\t\treturn a\n+\t}\n+\treturn b\n+}\n+\n+// addFieldInfo adds finfo to tinfo.fields if there are no\n+// conflicts, or if conflicts arise from previous fields that were\n+// obtained from deeper embedded structures than finfo. In the latter\n+// case, the conflicting entries are dropped.\n+// A conflict occurs when the path (parent + name) to a field is\n+// itself a prefix of another path, or when two paths match exactly.\n+// It is okay for field paths to share a common, shorter prefix.\n+func addFieldInfo(typ reflect.Type, tinfo *typeInfo, newf *fieldInfo) error {\n+\tvar conflicts []int\n+Loop:\n+\t// First, figure all conflicts. Most working code will have none.\n+\tfor i := range tinfo.fields {\n+\t\toldf := &tinfo.fields[i]\n+\t\tif oldf.flags&fMode != newf.flags&fMode {\n+\t\t\tcontinue\n+\t\t}\n+\t\tminl := min(len(newf.parents), len(oldf.parents))\n+\t\tfor p := 0; p < minl; p++ {\n+\t\t\tif oldf.parents[p] != newf.parents[p] {\n+\t\t\t\tcontinue Loop\n+\t\t\t}\n+\t\t}\n+\t\tif len(oldf.parents) > len(newf.parents) {\n+\t\t\tif oldf.parents[len(newf.parents)] == newf.name {\n+\t\t\t\tconflicts = append(conflicts, i)\n+\t\t\t}\n+\t\t} else if len(oldf.parents) < len(newf.parents) {\n+\t\t\tif newf.parents[len(oldf.parents)] == oldf.name {\n+\t\t\t\tconflicts = append(conflicts, i)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tif newf.name == oldf.name {\n+\t\t\t\tconflicts = append(conflicts, i)\n+\t\t\t}\n+\t\t}\n+\t}\n+\t// Without conflicts, add the new field and return.\n+\tif conflicts == nil {\n+\t\ttinfo.fields = append(tinfo.fields, *newf)\n+\t\treturn nil\n+\t}\n+\n+\t// If any conflict is shallower, ignore the new field.\n+\t// This matches the Go field resolution on embedding.\n+\tfor _, i := range conflicts {\n+\t\tif len(tinfo.fields[i].idx) < len(newf.idx) {\n+\t\t\treturn nil\n+\t\t}\n+\t}\n+\n+\t// Otherwise, if any of them is at the same depth level, it's an error.\n+\tfor _, i := range conflicts {\n+\t\toldf := &tinfo.fields[i]\n+\t\tif len(oldf.idx) == len(newf.idx) {\n+\t\t\tf1 := typ.FieldByIndex(oldf.idx)\n+\t\t\tf2 := typ.FieldByIndex(newf.idx)\n+\t\t\treturn &TagPathError{typ, f1.Name, f1.Tag.Get(\"xml\"), f2.Name, f2.Tag.Get(\"xml\")}\n+\t\t}\n+\t}\n+\n+\t// Otherwise, the new field is shallower, and thus takes precedence,\n+\t// so drop the conflicting fields from tinfo and append the new one.\n+\tfor c := len(conflicts) - 1; c >= 0; c-- {\n+\t\ti := conflicts[c]\n+\t\tcopy(tinfo.fields[i:], tinfo.fields[i+1:])\n+\t\ttinfo.fields = tinfo.fields[:len(tinfo.fields)-1]\n+\t}\n+\ttinfo.fields = append(tinfo.fields, *newf)\n+\treturn nil\n+}\n+\n+// A TagPathError represents an error in the unmarshalling process\n+// caused by the use of field tags with conflicting paths.\n+type TagPathError struct {\n+\tStruct       reflect.Type\n+\tField1, Tag1 string\n+\tField2, Tag2 string\n+}\n+\n+func (e *TagPathError) Error() string {\n+\treturn fmt.Sprintf(\"%s field %q with tag %q conflicts with field %q with tag %q\", e.Struct, e.Field1, e.Tag1, e.Field2, e.Tag2)\n+}"}, {"sha": "524d4dda4f4f8aabfd9c749b711ee34fe4a5cfd5", "filename": "libgo/go/encoding/xml/xml_test.go", "status": "modified", "additions": 34, "deletions": 62, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fencoding%2Fxml%2Fxml_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -154,36 +154,8 @@ var xmlInput = []string{\n \t\"<t>cdata]]></t>\",\n }\n \n-type stringReader struct {\n-\ts   string\n-\toff int\n-}\n-\n-func (r *stringReader) Read(b []byte) (n int, err error) {\n-\tif r.off >= len(r.s) {\n-\t\treturn 0, io.EOF\n-\t}\n-\tfor r.off < len(r.s) && n < len(b) {\n-\t\tb[n] = r.s[r.off]\n-\t\tn++\n-\t\tr.off++\n-\t}\n-\treturn\n-}\n-\n-func (r *stringReader) ReadByte() (b byte, err error) {\n-\tif r.off >= len(r.s) {\n-\t\treturn 0, io.EOF\n-\t}\n-\tb = r.s[r.off]\n-\tr.off++\n-\treturn\n-}\n-\n-func StringReader(s string) io.Reader { return &stringReader{s, 0} }\n-\n func TestRawToken(t *testing.T) {\n-\tp := NewParser(StringReader(testInput))\n+\tp := NewParser(strings.NewReader(testInput))\n \ttestRawToken(t, p, rawTokens)\n }\n \n@@ -207,7 +179,7 @@ func (d *downCaser) Read(p []byte) (int, error) {\n \n func TestRawTokenAltEncoding(t *testing.T) {\n \tsawEncoding := \"\"\n-\tp := NewParser(StringReader(testInputAltEncoding))\n+\tp := NewParser(strings.NewReader(testInputAltEncoding))\n \tp.CharsetReader = func(charset string, input io.Reader) (io.Reader, error) {\n \t\tsawEncoding = charset\n \t\tif charset != \"x-testing-uppercase\" {\n@@ -219,7 +191,7 @@ func TestRawTokenAltEncoding(t *testing.T) {\n }\n \n func TestRawTokenAltEncodingNoConverter(t *testing.T) {\n-\tp := NewParser(StringReader(testInputAltEncoding))\n+\tp := NewParser(strings.NewReader(testInputAltEncoding))\n \ttoken, err := p.RawToken()\n \tif token == nil {\n \t\tt.Fatalf(\"expected a token on first RawToken call\")\n@@ -286,7 +258,7 @@ var nestedDirectivesTokens = []Token{\n }\n \n func TestNestedDirectives(t *testing.T) {\n-\tp := NewParser(StringReader(nestedDirectivesInput))\n+\tp := NewParser(strings.NewReader(nestedDirectivesInput))\n \n \tfor i, want := range nestedDirectivesTokens {\n \t\thave, err := p.Token()\n@@ -300,7 +272,7 @@ func TestNestedDirectives(t *testing.T) {\n }\n \n func TestToken(t *testing.T) {\n-\tp := NewParser(StringReader(testInput))\n+\tp := NewParser(strings.NewReader(testInput))\n \n \tfor i, want := range cookedTokens {\n \t\thave, err := p.Token()\n@@ -315,7 +287,7 @@ func TestToken(t *testing.T) {\n \n func TestSyntax(t *testing.T) {\n \tfor i := range xmlInput {\n-\t\tp := NewParser(StringReader(xmlInput[i]))\n+\t\tp := NewParser(strings.NewReader(xmlInput[i]))\n \t\tvar err error\n \t\tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n \t\t}\n@@ -372,26 +344,26 @@ var all = allScalars{\n var sixteen = \"16\"\n \n const testScalarsInput = `<allscalars>\n-\t<true1>true</true1>\n-\t<true2>1</true2>\n-\t<false1>false</false1>\n-\t<false2>0</false2>\n-\t<int>1</int>\n-\t<int8>-2</int8>\n-\t<int16>3</int16>\n-\t<int32>-4</int32>\n-\t<int64>5</int64>\n-\t<uint>6</uint>\n-\t<uint8>7</uint8>\n-\t<uint16>8</uint16>\n-\t<uint32>9</uint32>\n-\t<uint64>10</uint64>\n-\t<uintptr>11</uintptr>\n-\t<float>12.0</float>\n-\t<float32>13.0</float32>\n-\t<float64>14.0</float64>\n-\t<string>15</string>\n-\t<ptrstring>16</ptrstring>\n+\t<True1>true</True1>\n+\t<True2>1</True2>\n+\t<False1>false</False1>\n+\t<False2>0</False2>\n+\t<Int>1</Int>\n+\t<Int8>-2</Int8>\n+\t<Int16>3</Int16>\n+\t<Int32>-4</Int32>\n+\t<Int64>5</Int64>\n+\t<Uint>6</Uint>\n+\t<Uint8>7</Uint8>\n+\t<Uint16>8</Uint16>\n+\t<Uint32>9</Uint32>\n+\t<Uint64>10</Uint64>\n+\t<Uintptr>11</Uintptr>\n+\t<Float>12.0</Float>\n+\t<Float32>13.0</Float32>\n+\t<Float64>14.0</Float64>\n+\t<String>15</String>\n+\t<PtrString>16</PtrString>\n </allscalars>`\n \n func TestAllScalars(t *testing.T) {\n@@ -412,7 +384,7 @@ type item struct {\n }\n \n func TestIssue569(t *testing.T) {\n-\tdata := `<item><field_a>abcd</field_a></item>`\n+\tdata := `<item><Field_a>abcd</Field_a></item>`\n \tvar i item\n \tbuf := bytes.NewBufferString(data)\n \terr := Unmarshal(buf, &i)\n@@ -424,7 +396,7 @@ func TestIssue569(t *testing.T) {\n \n func TestUnquotedAttrs(t *testing.T) {\n \tdata := \"<tag attr=azAZ09:-_\\t>\"\n-\tp := NewParser(StringReader(data))\n+\tp := NewParser(strings.NewReader(data))\n \tp.Strict = false\n \ttoken, err := p.Token()\n \tif _, ok := err.(*SyntaxError); ok {\n@@ -450,7 +422,7 @@ func TestValuelessAttrs(t *testing.T) {\n \t\t{\"<input checked />\", \"input\", \"checked\"},\n \t}\n \tfor _, test := range tests {\n-\t\tp := NewParser(StringReader(test[0]))\n+\t\tp := NewParser(strings.NewReader(test[0]))\n \t\tp.Strict = false\n \t\ttoken, err := p.Token()\n \t\tif _, ok := err.(*SyntaxError); ok {\n@@ -500,7 +472,7 @@ func TestCopyTokenStartElement(t *testing.T) {\n \n func TestSyntaxErrorLineNum(t *testing.T) {\n \ttestInput := \"<P>Foo<P>\\n\\n<P>Bar</>\\n\"\n-\tp := NewParser(StringReader(testInput))\n+\tp := NewParser(strings.NewReader(testInput))\n \tvar err error\n \tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n \t}\n@@ -515,7 +487,7 @@ func TestSyntaxErrorLineNum(t *testing.T) {\n \n func TestTrailingRawToken(t *testing.T) {\n \tinput := `<FOO></FOO>  `\n-\tp := NewParser(StringReader(input))\n+\tp := NewParser(strings.NewReader(input))\n \tvar err error\n \tfor _, err = p.RawToken(); err == nil; _, err = p.RawToken() {\n \t}\n@@ -526,7 +498,7 @@ func TestTrailingRawToken(t *testing.T) {\n \n func TestTrailingToken(t *testing.T) {\n \tinput := `<FOO></FOO>  `\n-\tp := NewParser(StringReader(input))\n+\tp := NewParser(strings.NewReader(input))\n \tvar err error\n \tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n \t}\n@@ -537,7 +509,7 @@ func TestTrailingToken(t *testing.T) {\n \n func TestEntityInsideCDATA(t *testing.T) {\n \tinput := `<test><![CDATA[ &val=foo ]]></test>`\n-\tp := NewParser(StringReader(input))\n+\tp := NewParser(strings.NewReader(input))\n \tvar err error\n \tfor _, err = p.Token(); err == nil; _, err = p.Token() {\n \t}\n@@ -569,7 +541,7 @@ var characterTests = []struct {\n func TestDisallowedCharacters(t *testing.T) {\n \n \tfor i, tt := range characterTests {\n-\t\tp := NewParser(StringReader(tt.in))\n+\t\tp := NewParser(strings.NewReader(tt.in))\n \t\tvar err error\n \n \t\tfor err == nil {"}, {"sha": "42e6f1b79471f8c590edc025e80fd8642f6d9d6f", "filename": "libgo/go/exp/norm/input.go", "status": "modified", "additions": 3, "deletions": 5, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Finput.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,7 +8,7 @@ import \"unicode/utf8\"\n \n type input interface {\n \tskipASCII(p int) int\n-\tskipNonStarter() int\n+\tskipNonStarter(p int) int\n \tappendSlice(buf []byte, s, e int) []byte\n \tcopySlice(buf []byte, s, e int)\n \tcharinfo(p int) (uint16, int)\n@@ -25,8 +25,7 @@ func (s inputString) skipASCII(p int) int {\n \treturn p\n }\n \n-func (s inputString) skipNonStarter() int {\n-\tp := 0\n+func (s inputString) skipNonStarter(p int) int {\n \tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n \t}\n \treturn p\n@@ -71,8 +70,7 @@ func (s inputBytes) skipASCII(p int) int {\n \treturn p\n }\n \n-func (s inputBytes) skipNonStarter() int {\n-\tp := 0\n+func (s inputBytes) skipNonStarter(p int) int {\n \tfor ; p < len(s) && !utf8.RuneStart(s[p]); p++ {\n \t}\n \treturn p"}, {"sha": "3bd40470d5c351788b89368c8ccb6c3dbe916044", "filename": "libgo/go/exp/norm/normalize.go", "status": "modified", "additions": 31, "deletions": 22, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -34,24 +34,28 @@ const (\n \n // Bytes returns f(b). May return b if f(b) = b.\n func (f Form) Bytes(b []byte) []byte {\n-\tn := f.QuickSpan(b)\n+\trb := reorderBuffer{}\n+\trb.init(f, b)\n+\tn := quickSpan(&rb, 0)\n \tif n == len(b) {\n \t\treturn b\n \t}\n \tout := make([]byte, n, len(b))\n \tcopy(out, b[0:n])\n-\treturn f.Append(out, b[n:]...)\n+\treturn doAppend(&rb, out, n)\n }\n \n // String returns f(s).\n func (f Form) String(s string) string {\n-\tn := f.QuickSpanString(s)\n+\trb := reorderBuffer{}\n+\trb.initString(f, s)\n+\tn := quickSpan(&rb, 0)\n \tif n == len(s) {\n \t\treturn s\n \t}\n-\tout := make([]byte, 0, len(s))\n+\tout := make([]byte, n, len(s))\n \tcopy(out, s[0:n])\n-\treturn string(f.AppendString(out, s[n:]))\n+\treturn string(doAppend(&rb, out, n))\n }\n \n // IsNormal returns true if b == f(b).\n@@ -122,23 +126,27 @@ func (f Form) IsNormalString(s string) bool {\n \n // patchTail fixes a case where a rune may be incorrectly normalized\n // if it is followed by illegal continuation bytes. It returns the\n-// patched buffer and the number of trailing continuation bytes that\n-// have been dropped.\n-func patchTail(rb *reorderBuffer, buf []byte) ([]byte, int) {\n+// patched buffer and whether there were trailing continuation bytes.\n+func patchTail(rb *reorderBuffer, buf []byte) ([]byte, bool) {\n \tinfo, p := lastRuneStart(&rb.f, buf)\n \tif p == -1 || info.size == 0 {\n-\t\treturn buf, 0\n+\t\treturn buf, false\n \t}\n \tend := p + int(info.size)\n \textra := len(buf) - end\n \tif extra > 0 {\n+\t\t// Potentially allocating memory. However, this only\n+\t\t// happens with ill-formed UTF-8.\n+\t\tx := make([]byte, 0)\n+\t\tx = append(x, buf[len(buf)-extra:]...)\n \t\tbuf = decomposeToLastBoundary(rb, buf[:end])\n \t\tif rb.f.composing {\n \t\t\trb.compose()\n \t\t}\n-\t\treturn rb.flush(buf), extra\n+\t\tbuf = rb.flush(buf)\n+\t\treturn append(buf, x...), true\n \t}\n-\treturn buf, 0\n+\treturn buf, false\n }\n \n func appendQuick(rb *reorderBuffer, dst []byte, i int) ([]byte, int) {\n@@ -157,23 +165,23 @@ func (f Form) Append(out []byte, src ...byte) []byte {\n \t}\n \trb := reorderBuffer{}\n \trb.init(f, src)\n-\treturn doAppend(&rb, out)\n+\treturn doAppend(&rb, out, 0)\n }\n \n-func doAppend(rb *reorderBuffer, out []byte) []byte {\n+func doAppend(rb *reorderBuffer, out []byte, p int) []byte {\n \tsrc, n := rb.src, rb.nsrc\n \tdoMerge := len(out) > 0\n-\tp := 0\n-\tif p = src.skipNonStarter(); p > 0 {\n+\tif q := src.skipNonStarter(p); q > p {\n \t\t// Move leading non-starters to destination.\n-\t\tout = src.appendSlice(out, 0, p)\n-\t\tbuf, ndropped := patchTail(rb, out)\n-\t\tif ndropped > 0 {\n-\t\t\tout = src.appendSlice(buf, p-ndropped, p)\n+\t\tout = src.appendSlice(out, p, q)\n+\t\tbuf, endsInError := patchTail(rb, out)\n+\t\tif endsInError {\n+\t\t\tout = buf\n \t\t\tdoMerge = false // no need to merge, ends with illegal UTF-8\n \t\t} else {\n \t\t\tout = decomposeToLastBoundary(rb, buf) // force decomposition\n \t\t}\n+\t\tp = q\n \t}\n \tfd := &rb.f\n \tif doMerge {\n@@ -217,15 +225,16 @@ func (f Form) AppendString(out []byte, src string) []byte {\n \t}\n \trb := reorderBuffer{}\n \trb.initString(f, src)\n-\treturn doAppend(&rb, out)\n+\treturn doAppend(&rb, out, 0)\n }\n \n // QuickSpan returns a boundary n such that b[0:n] == f(b[0:n]).\n // It is not guaranteed to return the largest such n.\n func (f Form) QuickSpan(b []byte) int {\n \trb := reorderBuffer{}\n \trb.init(f, b)\n-\treturn quickSpan(&rb, 0)\n+\tn := quickSpan(&rb, 0)\n+\treturn n\n }\n \n func quickSpan(rb *reorderBuffer, i int) int {\n@@ -301,7 +310,7 @@ func (f Form) FirstBoundary(b []byte) int {\n \n func firstBoundary(rb *reorderBuffer) int {\n \tsrc, nsrc := rb.src, rb.nsrc\n-\ti := src.skipNonStarter()\n+\ti := src.skipNonStarter(0)\n \tif i >= nsrc {\n \t\treturn -1\n \t}"}, {"sha": "2e0c1f17120e7f11a473069362603ee734044feb", "filename": "libgo/go/exp/norm/normalize_test.go", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Fnormalize_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -253,7 +253,7 @@ var quickSpanNFDTests = []PositionTest{\n \t{\"\\u0316\\u0300cd\", 6, \"\"},\n \t{\"\\u043E\\u0308b\", 5, \"\"},\n \t// incorrectly ordered combining characters\n-\t{\"ab\\u0300\\u0316\", 1, \"\"}, // TODO(mpvl): we could skip 'b' as well.\n+\t{\"ab\\u0300\\u0316\", 1, \"\"}, // TODO: we could skip 'b' as well.\n \t{\"ab\\u0300\\u0316cd\", 1, \"\"},\n \t// Hangul\n \t{\"\uac19\uc740\", 0, \"\"},\n@@ -465,6 +465,7 @@ var appendTests = []AppendTest{\n \t{\"\\u0300\", \"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\"},\n \t{\"\\xF8\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\", \"\\xF8\\x80\\x80\\x80\\x80\\u0300\\u0300\"},\n \t{\"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\", \"\\u0300\", \"\\xFC\\x80\\x80\\x80\\x80\\x80\\u0300\\u0300\"},\n+\t{\"\\xF8\\x80\\x80\\x80\", \"\\x80\\u0300\\u0300\", \"\\xF8\\x80\\x80\\x80\\x80\\u0300\\u0300\"},\n }\n \n func appendF(f Form, out []byte, s string) []byte {\n@@ -475,9 +476,23 @@ func appendStringF(f Form, out []byte, s string) []byte {\n \treturn f.AppendString(out, s)\n }\n \n+func bytesF(f Form, out []byte, s string) []byte {\n+\tbuf := []byte{}\n+\tbuf = append(buf, out...)\n+\tbuf = append(buf, s...)\n+\treturn f.Bytes(buf)\n+}\n+\n+func stringF(f Form, out []byte, s string) []byte {\n+\touts := string(out) + s\n+\treturn []byte(f.String(outs))\n+}\n+\n func TestAppend(t *testing.T) {\n \trunAppendTests(t, \"TestAppend\", NFKC, appendF, appendTests)\n \trunAppendTests(t, \"TestAppendString\", NFKC, appendStringF, appendTests)\n+\trunAppendTests(t, \"TestBytes\", NFKC, bytesF, appendTests)\n+\trunAppendTests(t, \"TestString\", NFKC, stringF, appendTests)\n }\n \n func doFormBenchmark(b *testing.B, f Form, s string) {"}, {"sha": "2682894de0b1d19781cdd44184eb2be2c4bb5356", "filename": "libgo/go/exp/norm/readwriter.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fnorm%2Freadwriter.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -27,7 +27,7 @@ func (w *normWriter) Write(data []byte) (n int, err error) {\n \t\t}\n \t\tw.rb.src = inputBytes(data[:m])\n \t\tw.rb.nsrc = m\n-\t\tw.buf = doAppend(&w.rb, w.buf)\n+\t\tw.buf = doAppend(&w.rb, w.buf, 0)\n \t\tdata = data[m:]\n \t\tn += m\n \n@@ -101,7 +101,7 @@ func (r *normReader) Read(p []byte) (int, error) {\n \t\tr.rb.src = inputBytes(r.inbuf[0:n])\n \t\tr.rb.nsrc, r.err = n, err\n \t\tif n > 0 {\n-\t\t\tr.outbuf = doAppend(&r.rb, r.outbuf)\n+\t\t\tr.outbuf = doAppend(&r.rb, r.outbuf, 0)\n \t\t}\n \t\tif err == io.EOF {\n \t\t\tr.lastBoundary = len(r.outbuf)"}, {"sha": "4c5ad88b1e759060536fcc18cf42570545be9bbf", "filename": "libgo/go/exp/proxy/direct.go", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fdirect.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,18 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package proxy\n+\n+import (\n+\t\"net\"\n+)\n+\n+type direct struct{}\n+\n+// Direct is a direct proxy: one that makes network connections directly.\n+var Direct = direct{}\n+\n+func (direct) Dial(network, addr string) (net.Conn, error) {\n+\treturn net.Dial(network, addr)\n+}"}, {"sha": "397ef57cd92a010700c1b7cd884901ea1503a71c", "filename": "libgo/go/exp/proxy/per_host.go", "status": "added", "additions": 140, "deletions": 0, "changes": 140, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,140 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package proxy\n+\n+import (\n+\t\"net\"\n+\t\"strings\"\n+)\n+\n+// A PerHost directs connections to a default Dailer unless the hostname\n+// requested matches one of a number of exceptions.\n+type PerHost struct {\n+\tdef, bypass Dialer\n+\n+\tbypassNetworks []*net.IPNet\n+\tbypassIPs      []net.IP\n+\tbypassZones    []string\n+\tbypassHosts    []string\n+}\n+\n+// NewPerHost returns a PerHost Dialer that directs connections to either\n+// defaultDialer or bypass, depending on whether the connection matches one of\n+// the configured rules.\n+func NewPerHost(defaultDialer, bypass Dialer) *PerHost {\n+\treturn &PerHost{\n+\t\tdef:    defaultDialer,\n+\t\tbypass: bypass,\n+\t}\n+}\n+\n+// Dial connects to the address addr on the network net through either\n+// defaultDialer or bypass.\n+func (p *PerHost) Dial(network, addr string) (c net.Conn, err error) {\n+\thost, _, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\treturn p.dialerForRequest(host).Dial(network, addr)\n+}\n+\n+func (p *PerHost) dialerForRequest(host string) Dialer {\n+\tif ip := net.ParseIP(host); ip != nil {\n+\t\tfor _, net := range p.bypassNetworks {\n+\t\t\tif net.Contains(ip) {\n+\t\t\t\treturn p.bypass\n+\t\t\t}\n+\t\t}\n+\t\tfor _, bypassIP := range p.bypassIPs {\n+\t\t\tif bypassIP.Equal(ip) {\n+\t\t\t\treturn p.bypass\n+\t\t\t}\n+\t\t}\n+\t\treturn p.def\n+\t}\n+\n+\tfor _, zone := range p.bypassZones {\n+\t\tif strings.HasSuffix(host, zone) {\n+\t\t\treturn p.bypass\n+\t\t}\n+\t\tif host == zone[1:] {\n+\t\t\t// For a zone \"example.com\", we match \"example.com\"\n+\t\t\t// too.\n+\t\t\treturn p.bypass\n+\t\t}\n+\t}\n+\tfor _, bypassHost := range p.bypassHosts {\n+\t\tif bypassHost == host {\n+\t\t\treturn p.bypass\n+\t\t}\n+\t}\n+\treturn p.def\n+}\n+\n+// AddFromString parses a string that contains comma-separated values\n+// specifing hosts that should use the bypass proxy. Each value is either an\n+// IP address, a CIDR range, a zone (*.example.com) or a hostname\n+// (localhost). A best effort is made to parse the string and errors are\n+// ignored.\n+func (p *PerHost) AddFromString(s string) {\n+\thosts := strings.Split(s, \",\")\n+\tfor _, host := range hosts {\n+\t\thost = strings.TrimSpace(host)\n+\t\tif len(host) == 0 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.Contains(host, \"/\") {\n+\t\t\t// We assume that it's a CIDR address like 127.0.0.0/8\n+\t\t\tif _, net, err := net.ParseCIDR(host); err == nil {\n+\t\t\t\tp.AddNetwork(net)\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\tif ip := net.ParseIP(host); ip != nil {\n+\t\t\tp.AddIP(ip)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif strings.HasPrefix(host, \"*.\") {\n+\t\t\tp.AddZone(host[1:])\n+\t\t\tcontinue\n+\t\t}\n+\t\tp.AddHost(host)\n+\t}\n+}\n+\n+// AddIP specifies an IP address that will use the bypass proxy. Note that\n+// this will only take effect if a literal IP address is dialed. A connection\n+// to a named host will never match an IP.\n+func (p *PerHost) AddIP(ip net.IP) {\n+\tp.bypassIPs = append(p.bypassIPs, ip)\n+}\n+\n+// AddIP specifies an IP range that will use the bypass proxy. Note that this\n+// will only take effect if a literal IP address is dialed. A connection to a\n+// named host will never match.\n+func (p *PerHost) AddNetwork(net *net.IPNet) {\n+\tp.bypassNetworks = append(p.bypassNetworks, net)\n+}\n+\n+// AddZone specifies a DNS suffix that will use the bypass proxy. A zone of\n+// \"example.com\" matches \"example.com\" and all of its subdomains.\n+func (p *PerHost) AddZone(zone string) {\n+\tif strings.HasSuffix(zone, \".\") {\n+\t\tzone = zone[:len(zone)-1]\n+\t}\n+\tif !strings.HasPrefix(zone, \".\") {\n+\t\tzone = \".\" + zone\n+\t}\n+\tp.bypassZones = append(p.bypassZones, zone)\n+}\n+\n+// AddHost specifies a hostname that will use the bypass proxy.\n+func (p *PerHost) AddHost(host string) {\n+\tif strings.HasSuffix(host, \".\") {\n+\t\thost = host[:len(host)-1]\n+\t}\n+\tp.bypassHosts = append(p.bypassHosts, host)\n+}"}, {"sha": "a7d80957113d9496219c94597264fe5d6e74ea5c", "filename": "libgo/go/exp/proxy/per_host_test.go", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fper_host_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,55 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package proxy\n+\n+import (\n+\t\"errors\"\n+\t\"net\"\n+\t\"reflect\"\n+\t\"testing\"\n+)\n+\n+type recordingProxy struct {\n+\taddrs []string\n+}\n+\n+func (r *recordingProxy) Dial(network, addr string) (net.Conn, error) {\n+\tr.addrs = append(r.addrs, addr)\n+\treturn nil, errors.New(\"recordingProxy\")\n+}\n+\n+func TestPerHost(t *testing.T) {\n+\tvar def, bypass recordingProxy\n+\tperHost := NewPerHost(&def, &bypass)\n+\tperHost.AddFromString(\"localhost,*.zone,127.0.0.1,10.0.0.1/8,1000::/16\")\n+\n+\texpectedDef := []string{\n+\t\t\"example.com:123\",\n+\t\t\"1.2.3.4:123\",\n+\t\t\"[1001::]:123\",\n+\t}\n+\texpectedBypass := []string{\n+\t\t\"localhost:123\",\n+\t\t\"zone:123\",\n+\t\t\"foo.zone:123\",\n+\t\t\"127.0.0.1:123\",\n+\t\t\"10.1.2.3:123\",\n+\t\t\"[1000::]:123\",\n+\t}\n+\n+\tfor _, addr := range expectedDef {\n+\t\tperHost.Dial(\"tcp\", addr)\n+\t}\n+\tfor _, addr := range expectedBypass {\n+\t\tperHost.Dial(\"tcp\", addr)\n+\t}\n+\n+\tif !reflect.DeepEqual(expectedDef, def.addrs) {\n+\t\tt.Errorf(\"Hosts which went to the default proxy didn't match. Got %v, want %v\", def.addrs, expectedDef)\n+\t}\n+\tif !reflect.DeepEqual(expectedBypass, bypass.addrs) {\n+\t\tt.Errorf(\"Hosts which went to the bypass proxy didn't match. Got %v, want %v\", bypass.addrs, expectedBypass)\n+\t}\n+}"}, {"sha": "ccd3d1d8b8bac494bc050dad2b82d62c8eea8c66", "filename": "libgo/go/exp/proxy/proxy.go", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,98 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package proxy provides support for a variety of protocols to proxy network\n+// data.\n+package proxy\n+\n+import (\n+\t\"errors\"\n+\t\"net\"\n+\t\"net/url\"\n+\t\"os\"\n+\t\"strings\"\n+)\n+\n+// A Dialer is a means to establish a connection.\n+type Dialer interface {\n+\t// Dial connects to the given address via the proxy.\n+\tDial(network, addr string) (c net.Conn, err error)\n+}\n+\n+// Auth contains authentication parameters that specific Dialers may require.\n+type Auth struct {\n+\tUser, Password string\n+}\n+\n+// DefaultDialer returns the dialer specified by the proxy related variables in\n+// the environment.\n+func FromEnvironment() Dialer {\n+\tallProxy := os.Getenv(\"all_proxy\")\n+\tif len(allProxy) == 0 {\n+\t\treturn Direct\n+\t}\n+\n+\tproxyURL, err := url.Parse(allProxy)\n+\tif err != nil {\n+\t\treturn Direct\n+\t}\n+\tproxy, err := FromURL(proxyURL, Direct)\n+\tif err != nil {\n+\t\treturn Direct\n+\t}\n+\n+\tnoProxy := os.Getenv(\"no_proxy\")\n+\tif len(noProxy) == 0 {\n+\t\treturn proxy\n+\t}\n+\n+\tperHost := NewPerHost(proxy, Direct)\n+\tperHost.AddFromString(noProxy)\n+\treturn perHost\n+}\n+\n+// proxySchemes is a map from URL schemes to a function that creates a Dialer\n+// from a URL with such a scheme.\n+var proxySchemes map[string]func(*url.URL, Dialer) (Dialer, error)\n+\n+// RegisterDialerType takes a URL scheme and a function to generate Dialers from\n+// a URL with that scheme and a forwarding Dialer. Registered schemes are used\n+// by FromURL.\n+func RegisterDialerType(scheme string, f func(*url.URL, Dialer) (Dialer, error)) {\n+\tif proxySchemes == nil {\n+\t\tproxySchemes = make(map[string]func(*url.URL, Dialer) (Dialer, error))\n+\t}\n+\tproxySchemes[scheme] = f\n+}\n+\n+// FromURL returns a Dialer given a URL specification and an underlying\n+// Dialer for it to make network requests.\n+func FromURL(u *url.URL, forward Dialer) (Dialer, error) {\n+\tvar auth *Auth\n+\tif len(u.RawUserinfo) > 0 {\n+\t\tauth = new(Auth)\n+\t\tparts := strings.SplitN(u.RawUserinfo, \":\", 1)\n+\t\tif len(parts) == 1 {\n+\t\t\tauth.User = parts[0]\n+\t\t} else if len(parts) >= 2 {\n+\t\t\tauth.User = parts[0]\n+\t\t\tauth.Password = parts[1]\n+\t\t}\n+\t}\n+\n+\tswitch u.Scheme {\n+\tcase \"socks5\":\n+\t\treturn SOCKS5(\"tcp\", u.Host, auth, forward)\n+\t}\n+\n+\t// If the scheme doesn't match any of the built-in schemes, see if it\n+\t// was registered by another package.\n+\tif proxySchemes != nil {\n+\t\tif f, ok := proxySchemes[u.Scheme]; ok {\n+\t\t\treturn f(u, forward)\n+\t\t}\n+\t}\n+\n+\treturn nil, errors.New(\"proxy: unknown scheme: \" + u.Scheme)\n+}"}, {"sha": "4078bc76ae8527f09efaba24bcf1317bf7ff9669", "filename": "libgo/go/exp/proxy/proxy_test.go", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fproxy_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,50 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package proxy\n+\n+import (\n+\t\"net\"\n+\t\"net/url\"\n+\t\"testing\"\n+)\n+\n+type testDialer struct {\n+\tnetwork, addr string\n+}\n+\n+func (t *testDialer) Dial(network, addr string) (net.Conn, error) {\n+\tt.network = network\n+\tt.addr = addr\n+\treturn nil, t\n+}\n+\n+func (t *testDialer) Error() string {\n+\treturn \"testDialer \" + t.network + \" \" + t.addr\n+}\n+\n+func TestFromURL(t *testing.T) {\n+\tu, err := url.Parse(\"socks5://user:password@1.2.3.4:5678\")\n+\tif err != nil {\n+\t\tt.Fatalf(\"failed to parse URL: %s\", err)\n+\t}\n+\n+\ttp := &testDialer{}\n+\tproxy, err := FromURL(u, tp)\n+\tif err != nil {\n+\t\tt.Fatalf(\"FromURL failed: %s\", err)\n+\t}\n+\n+\tconn, err := proxy.Dial(\"tcp\", \"example.com:80\")\n+\tif conn != nil {\n+\t\tt.Error(\"Dial unexpected didn't return an error\")\n+\t}\n+\tif tp, ok := err.(*testDialer); ok {\n+\t\tif tp.network != \"tcp\" || tp.addr != \"1.2.3.4:5678\" {\n+\t\t\tt.Errorf(\"Dialer connected to wrong host. Wanted 1.2.3.4:5678, got: %v\", tp)\n+\t\t}\n+\t} else {\n+\t\tt.Errorf(\"Unexpected error from Dial: %s\", err)\n+\t}\n+}"}, {"sha": "466e135eb10981ca66f0e0b3b858a2561ac680de", "filename": "libgo/go/exp/proxy/socks5.go", "status": "added", "additions": 207, "deletions": 0, "changes": 207, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fproxy%2Fsocks5.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,207 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package proxy\n+\n+import (\n+\t\"errors\"\n+\t\"io\"\n+\t\"net\"\n+\t\"strconv\"\n+)\n+\n+// SOCKS5 returns a Dialer that makes SOCKSv5 connections to the given address\n+// with an optional username and password. See RFC 1928.\n+func SOCKS5(network, addr string, auth *Auth, forward Dialer) (Dialer, error) {\n+\ts := &socks5{\n+\t\tnetwork: network,\n+\t\taddr:    addr,\n+\t\tforward: forward,\n+\t}\n+\tif auth != nil {\n+\t\ts.user = auth.User\n+\t\ts.password = auth.Password\n+\t}\n+\n+\treturn s, nil\n+}\n+\n+type socks5 struct {\n+\tuser, password string\n+\tnetwork, addr  string\n+\tforward        Dialer\n+}\n+\n+const socks5Version = 5\n+\n+const (\n+\tsocks5AuthNone     = 0\n+\tsocks5AuthPassword = 2\n+)\n+\n+const socks5Connect = 1\n+\n+const (\n+\tsocks5IP4    = 1\n+\tsocks5Domain = 3\n+\tsocks5IP6    = 4\n+)\n+\n+var socks5Errors = []string{\n+\t\"\",\n+\t\"general failure\",\n+\t\"connection forbidden\",\n+\t\"network unreachable\",\n+\t\"host unreachable\",\n+\t\"connection refused\",\n+\t\"TTL expired\",\n+\t\"command not supported\",\n+\t\"address type not supported\",\n+}\n+\n+// Dial connects to the address addr on the network net via the SOCKS5 proxy.\n+func (s *socks5) Dial(network, addr string) (net.Conn, error) {\n+\tswitch network {\n+\tcase \"tcp\", \"tcp6\", \"tcp4\":\n+\t\tbreak\n+\tdefault:\n+\t\treturn nil, errors.New(\"proxy: no support for SOCKS5 proxy connections of type \" + network)\n+\t}\n+\n+\tconn, err := s.forward.Dial(s.network, s.addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tcloseConn := &conn\n+\tdefer func() {\n+\t\tif closeConn != nil {\n+\t\t\t(*closeConn).Close()\n+\t\t}\n+\t}()\n+\n+\thost, portStr, err := net.SplitHostPort(addr)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tport, err := strconv.Atoi(portStr)\n+\tif err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to parse port number: \" + portStr)\n+\t}\n+\tif port < 1 || port > 0xffff {\n+\t\treturn nil, errors.New(\"proxy: port number out of range: \" + portStr)\n+\t}\n+\n+\t// the size here is just an estimate\n+\tbuf := make([]byte, 0, 6+len(host))\n+\n+\tbuf = append(buf, socks5Version)\n+\tif len(s.user) > 0 && len(s.user) < 256 && len(s.password) < 256 {\n+\t\tbuf = append(buf, 2, /* num auth methods */ socks5AuthNone, socks5AuthPassword)\n+\t} else {\n+\t\tbuf = append(buf, 1, /* num auth methods */ socks5AuthNone)\n+\t}\n+\n+\tif _, err = conn.Write(buf); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to write greeting to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to read greeting from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\tif buf[0] != 5 {\n+\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" has unexpected version \" + strconv.Itoa(int(buf[0])))\n+\t}\n+\tif buf[1] == 0xff {\n+\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" requires authentication\")\n+\t}\n+\n+\tif buf[1] == socks5AuthPassword {\n+\t\tbuf = buf[:0]\n+\t\tbuf = append(buf, socks5Version)\n+\t\tbuf = append(buf, uint8(len(s.user)))\n+\t\tbuf = append(buf, s.user...)\n+\t\tbuf = append(buf, uint8(len(s.password)))\n+\t\tbuf = append(buf, s.password...)\n+\n+\t\tif _, err = conn.Write(buf); err != nil {\n+\t\t\treturn nil, errors.New(\"proxy: failed to write authentication request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\n+\t\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n+\t\t\treturn nil, errors.New(\"proxy: failed to read authentication reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\n+\t\tif buf[1] != 0 {\n+\t\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" rejected username/password\")\n+\t\t}\n+\t}\n+\n+\tbuf = buf[:0]\n+\tbuf = append(buf, socks5Version, socks5Connect, 0 /* reserved */ )\n+\n+\tif ip := net.ParseIP(host); ip != nil {\n+\t\tif len(ip) == 4 {\n+\t\t\tbuf = append(buf, socks5IP4)\n+\t\t} else {\n+\t\t\tbuf = append(buf, socks5IP6)\n+\t\t}\n+\t\tbuf = append(buf, []byte(ip)...)\n+\t} else {\n+\t\tbuf = append(buf, socks5Domain)\n+\t\tbuf = append(buf, byte(len(host)))\n+\t\tbuf = append(buf, host...)\n+\t}\n+\tbuf = append(buf, byte(port>>8), byte(port))\n+\n+\tif _, err = conn.Write(buf); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to write connect request to SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tif _, err = io.ReadFull(conn, buf[:4]); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to read connect reply from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tfailure := \"unknown error\"\n+\tif int(buf[1]) < len(socks5Errors) {\n+\t\tfailure = socks5Errors[buf[1]]\n+\t}\n+\n+\tif len(failure) > 0 {\n+\t\treturn nil, errors.New(\"proxy: SOCKS5 proxy at \" + s.addr + \" failed to connect: \" + failure)\n+\t}\n+\n+\tbytesToDiscard := 0\n+\tswitch buf[3] {\n+\tcase socks5IP4:\n+\t\tbytesToDiscard = 4\n+\tcase socks5IP6:\n+\t\tbytesToDiscard = 16\n+\tcase socks5Domain:\n+\t\t_, err := io.ReadFull(conn, buf[:1])\n+\t\tif err != nil {\n+\t\t\treturn nil, errors.New(\"proxy: failed to read domain length from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t\t}\n+\t\tbytesToDiscard = int(buf[0])\n+\tdefault:\n+\t\treturn nil, errors.New(\"proxy: got unknown address type \" + strconv.Itoa(int(buf[3])) + \" from SOCKS5 proxy at \" + s.addr)\n+\t}\n+\n+\tif cap(buf) < bytesToDiscard {\n+\t\tbuf = make([]byte, bytesToDiscard)\n+\t} else {\n+\t\tbuf = buf[:bytesToDiscard]\n+\t}\n+\tif _, err = io.ReadFull(conn, buf); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to read address from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\t// Also need to discard the port number\n+\tif _, err = io.ReadFull(conn, buf[:2]); err != nil {\n+\t\treturn nil, errors.New(\"proxy: failed to read port from SOCKS5 proxy at \" + s.addr + \": \" + err.Error())\n+\t}\n+\n+\tcloseConn = nil\n+\treturn conn, nil\n+}"}, {"sha": "702ba4399d5445bb87494c8b6cbaa63e94dbc2ec", "filename": "libgo/go/exp/sql/convert_test.go", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fconvert_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,8 +8,11 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"testing\"\n+\t\"time\"\n )\n \n+var someTime = time.Unix(123, 0)\n+\n type conversionTest struct {\n \ts, d interface{} // source and destination\n \n@@ -19,6 +22,7 @@ type conversionTest struct {\n \twantstr  string\n \twantf32  float32\n \twantf64  float64\n+\twanttime time.Time\n \twantbool bool // used if d is of type *bool\n \twanterr  string\n }\n@@ -35,12 +39,14 @@ var (\n \tscanbool   bool\n \tscanf32    float32\n \tscanf64    float64\n+\tscantime   time.Time\n )\n \n var conversionTests = []conversionTest{\n \t// Exact conversions (destination pointer type matches source type)\n \t{s: \"foo\", d: &scanstr, wantstr: \"foo\"},\n \t{s: 123, d: &scanint, wantint: 123},\n+\t{s: someTime, d: &scantime, wanttime: someTime},\n \n \t// To strings\n \t{s: []byte(\"byteslice\"), d: &scanstr, wantstr: \"byteslice\"},\n@@ -106,6 +112,10 @@ func float32Value(ptr interface{}) float32 {\n \treturn *(ptr.(*float32))\n }\n \n+func timeValue(ptr interface{}) time.Time {\n+\treturn *(ptr.(*time.Time))\n+}\n+\n func TestConversions(t *testing.T) {\n \tfor n, ct := range conversionTests {\n \t\terr := convertAssign(ct.d, ct.s)\n@@ -138,6 +148,9 @@ func TestConversions(t *testing.T) {\n \t\tif bp, boolTest := ct.d.(*bool); boolTest && *bp != ct.wantbool && ct.wanterr == \"\" {\n \t\t\terrf(\"want bool %v, got %v\", ct.wantbool, *bp)\n \t\t}\n+\t\tif !ct.wanttime.IsZero() && !ct.wanttime.Equal(timeValue(ct.d)) {\n+\t\t\terrf(\"want time %v, got %v\", ct.wanttime, timeValue(ct.d))\n+\t\t}\n \t}\n }\n "}, {"sha": "0cd2562d6822d360b58fc663a66da32df04ba861", "filename": "libgo/go/exp/sql/driver/driver.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Fdriver.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -16,6 +16,7 @@\n //   nil\n //   []byte\n //   string   [*] everywhere except from Rows.Next.\n+//   time.Time\n //\n package driver\n "}, {"sha": "d6ba641cb269e7bce0e79a05f16edd805953e8e5", "filename": "libgo/go/exp/sql/driver/types.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"fmt\"\n \t\"reflect\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // ValueConverter is the interface providing the ConvertValue method.\n@@ -39,7 +40,7 @@ type ValueConverter interface {\n //       1 is true\n //       0 is false,\n //       other integers are an error\n-//  - for strings and []byte, same rules as strconv.Atob\n+//  - for strings and []byte, same rules as strconv.ParseBool\n //  - all other types are an error\n var Bool boolType\n \n@@ -143,9 +144,10 @@ func (stringType) ConvertValue(v interface{}) (interface{}, error) {\n //   bool\n //   nil\n //   []byte\n+//   time.Time\n //   string\n //\n-// This is the ame list as IsScanSubsetType, with the addition of\n+// This is the same list as IsScanSubsetType, with the addition of\n // string.\n func IsParameterSubsetType(v interface{}) bool {\n \tif IsScanSubsetType(v) {\n@@ -165,14 +167,15 @@ func IsParameterSubsetType(v interface{}) bool {\n //   bool\n //   nil\n //   []byte\n+//   time.Time\n //\n // This is the same list as IsParameterSubsetType, without string.\n func IsScanSubsetType(v interface{}) bool {\n \tif v == nil {\n \t\treturn true\n \t}\n \tswitch v.(type) {\n-\tcase int64, float64, []byte, bool:\n+\tcase int64, float64, []byte, bool, time.Time:\n \t\treturn true\n \t}\n \treturn false"}, {"sha": "966bc6b45877eaf303e4bc5ec40aaff477637221", "filename": "libgo/go/exp/sql/driver/types_test.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fdriver%2Ftypes_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,6 +7,7 @@ package driver\n import (\n \t\"reflect\"\n \t\"testing\"\n+\t\"time\"\n )\n \n type valueConverterTest struct {\n@@ -16,6 +17,8 @@ type valueConverterTest struct {\n \terr string\n }\n \n+var now = time.Now()\n+\n var valueConverterTests = []valueConverterTest{\n \t{Bool, \"true\", true, \"\"},\n \t{Bool, \"True\", true, \"\"},\n@@ -33,6 +36,7 @@ var valueConverterTests = []valueConverterTest{\n \t{Bool, uint16(0), false, \"\"},\n \t{c: Bool, in: \"foo\", err: \"sql/driver: couldn't convert \\\"foo\\\" into type bool\"},\n \t{c: Bool, in: 2, err: \"sql/driver: couldn't convert 2 into type bool\"},\n+\t{DefaultParameterConverter, now, now, \"\"},\n }\n \n func TestValueConverters(t *testing.T) {"}, {"sha": "70aa68c1385cd0fa1b843421d0d5e8aac682e89b", "filename": "libgo/go/exp/sql/fakedb_test.go", "status": "modified", "additions": 62, "deletions": 10, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Ffakedb_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -12,6 +12,7 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \t\"sync\"\n+\t\"time\"\n \n \t\"exp/sql/driver\"\n )\n@@ -77,6 +78,17 @@ type fakeConn struct {\n \tdb *fakeDB // where to return ourselves to\n \n \tcurrTx *fakeTx\n+\n+\t// Stats for tests:\n+\tmu          sync.Mutex\n+\tstmtsMade   int\n+\tstmtsClosed int\n+}\n+\n+func (c *fakeConn) incrStat(v *int) {\n+\tc.mu.Lock()\n+\t*v++\n+\tc.mu.Unlock()\n }\n \n type fakeTx struct {\n@@ -110,25 +122,34 @@ func init() {\n \n // Supports dsn forms:\n //    <dbname>\n-//    <dbname>;wipe\n+//    <dbname>;<opts>  (no currently supported options)\n func (d *fakeDriver) Open(dsn string) (driver.Conn, error) {\n-\td.mu.Lock()\n-\tdefer d.mu.Unlock()\n-\td.openCount++\n-\tif d.dbs == nil {\n-\t\td.dbs = make(map[string]*fakeDB)\n-\t}\n \tparts := strings.Split(dsn, \";\")\n \tif len(parts) < 1 {\n \t\treturn nil, errors.New(\"fakedb: no database name\")\n \t}\n \tname := parts[0]\n+\n+\tdb := d.getDB(name)\n+\n+\td.mu.Lock()\n+\td.openCount++\n+\td.mu.Unlock()\n+\treturn &fakeConn{db: db}, nil\n+}\n+\n+func (d *fakeDriver) getDB(name string) *fakeDB {\n+\td.mu.Lock()\n+\tdefer d.mu.Unlock()\n+\tif d.dbs == nil {\n+\t\td.dbs = make(map[string]*fakeDB)\n+\t}\n \tdb, ok := d.dbs[name]\n \tif !ok {\n \t\tdb = &fakeDB{name: name}\n \t\td.dbs[name] = db\n \t}\n-\treturn &fakeConn{db: db}, nil\n+\treturn db\n }\n \n func (db *fakeDB) wipe() {\n@@ -200,7 +221,7 @@ func (c *fakeConn) Close() error {\n func checkSubsetTypes(args []interface{}) error {\n \tfor n, arg := range args {\n \t\tswitch arg.(type) {\n-\t\tcase int64, float64, bool, nil, []byte, string:\n+\t\tcase int64, float64, bool, nil, []byte, string, time.Time:\n \t\tdefault:\n \t\t\treturn fmt.Errorf(\"fakedb_test: invalid argument #%d: %v, type %T\", n+1, arg, arg)\n \t\t}\n@@ -297,6 +318,8 @@ func (c *fakeConn) prepareInsert(stmt *fakeStmt, parts []string) (driver.Stmt, e\n \t\t\tswitch ctype {\n \t\t\tcase \"string\":\n \t\t\t\tsubsetVal = []byte(value)\n+\t\t\tcase \"blob\":\n+\t\t\t\tsubsetVal = []byte(value)\n \t\t\tcase \"int32\":\n \t\t\t\ti, err := strconv.Atoi(value)\n \t\t\t\tif err != nil {\n@@ -327,6 +350,7 @@ func (c *fakeConn) Prepare(query string) (driver.Stmt, error) {\n \tcmd := parts[0]\n \tparts = parts[1:]\n \tstmt := &fakeStmt{q: query, c: c, cmd: cmd}\n+\tc.incrStat(&c.stmtsMade)\n \tswitch cmd {\n \tcase \"WIPE\":\n \t\t// Nothing\n@@ -347,7 +371,10 @@ func (s *fakeStmt) ColumnConverter(idx int) driver.ValueConverter {\n }\n \n func (s *fakeStmt) Close() error {\n-\ts.closed = true\n+\tif !s.closed {\n+\t\ts.c.incrStat(&s.c.stmtsClosed)\n+\t\ts.closed = true\n+\t}\n \treturn nil\n }\n \n@@ -501,9 +528,19 @@ type rowsCursor struct {\n \tpos    int\n \trows   []*row\n \tclosed bool\n+\n+\t// a clone of slices to give out to clients, indexed by the\n+\t// the original slice's first byte address.  we clone them\n+\t// just so we're able to corrupt them on close.\n+\tbytesClone map[*byte][]byte\n }\n \n func (rc *rowsCursor) Close() error {\n+\tif !rc.closed {\n+\t\tfor _, bs := range rc.bytesClone {\n+\t\t\tbs[0] = 255 // first byte corrupted\n+\t\t}\n+\t}\n \trc.closed = true\n \treturn nil\n }\n@@ -528,6 +565,19 @@ func (rc *rowsCursor) Next(dest []interface{}) error {\n \t\t// for ease of drivers, and to prevent drivers from\n \t\t// messing up conversions or doing them differently.\n \t\tdest[i] = v\n+\n+\t\tif bs, ok := v.([]byte); ok {\n+\t\t\tif rc.bytesClone == nil {\n+\t\t\t\trc.bytesClone = make(map[*byte][]byte)\n+\t\t\t}\n+\t\t\tclone, ok := rc.bytesClone[&bs[0]]\n+\t\t\tif !ok {\n+\t\t\t\tclone = make([]byte, len(bs))\n+\t\t\t\tcopy(clone, bs)\n+\t\t\t\trc.bytesClone[&bs[0]] = clone\n+\t\t\t}\n+\t\t\tdest[i] = clone\n+\t\t}\n \t}\n \treturn nil\n }\n@@ -540,6 +590,8 @@ func converterForType(typ string) driver.ValueConverter {\n \t\treturn driver.Int32\n \tcase \"string\":\n \t\treturn driver.String\n+\tcase \"datetime\":\n+\t\treturn driver.DefaultParameterConverter\n \t}\n \tpanic(\"invalid fakedb column type of \" + typ)\n }"}, {"sha": "4e68c3ee0952b6e778a0facf650862212164cbb9", "filename": "libgo/go/exp/sql/sql.go", "status": "modified", "additions": 46, "deletions": 12, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -243,8 +243,13 @@ func (db *DB) Query(query string, args ...interface{}) (*Rows, error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tdefer stmt.Close()\n-\treturn stmt.Query(args...)\n+\trows, err := stmt.Query(args...)\n+\tif err != nil {\n+\t\tstmt.Close()\n+\t\treturn nil, err\n+\t}\n+\trows.closeStmt = stmt\n+\treturn rows, nil\n }\n \n // QueryRow executes a query that is expected to return at most one row.\n@@ -549,8 +554,8 @@ func (s *Stmt) Exec(args ...interface{}) (Result, error) {\n // statement, a function to call to release the connection, and a\n // statement bound to that connection.\n func (s *Stmt) connStmt() (ci driver.Conn, releaseConn func(), si driver.Stmt, err error) {\n-\tif s.stickyErr != nil {\n-\t\treturn nil, nil, nil, s.stickyErr\n+\tif err = s.stickyErr; err != nil {\n+\t\treturn\n \t}\n \ts.mu.Lock()\n \tif s.closed {\n@@ -706,9 +711,10 @@ type Rows struct {\n \treleaseConn func()\n \trowsi       driver.Rows\n \n-\tclosed   bool\n-\tlastcols []interface{}\n-\tlasterr  error\n+\tclosed    bool\n+\tlastcols  []interface{}\n+\tlasterr   error\n+\tcloseStmt *Stmt // if non-nil, statement to Close on close\n }\n \n // Next prepares the next result row for reading with the Scan method.\n@@ -726,6 +732,9 @@ func (rs *Rows) Next() bool {\n \t\trs.lastcols = make([]interface{}, len(rs.rowsi.Columns()))\n \t}\n \trs.lasterr = rs.rowsi.Next(rs.lastcols)\n+\tif rs.lasterr == io.EOF {\n+\t\trs.Close()\n+\t}\n \treturn rs.lasterr == nil\n }\n \n@@ -786,6 +795,9 @@ func (rs *Rows) Close() error {\n \trs.closed = true\n \terr := rs.rowsi.Close()\n \trs.releaseConn()\n+\tif rs.closeStmt != nil {\n+\t\trs.closeStmt.Close()\n+\t}\n \treturn err\n }\n \n@@ -800,10 +812,6 @@ type Row struct {\n // pointed at by dest.  If more than one row matches the query,\n // Scan uses the first row and discards the rest.  If no row matches\n // the query, Scan returns ErrNoRows.\n-//\n-// If dest contains pointers to []byte, the slices should not be\n-// modified and should only be considered valid until the next call to\n-// Next or Scan.\n func (r *Row) Scan(dest ...interface{}) error {\n \tif r.err != nil {\n \t\treturn r.err\n@@ -812,7 +820,33 @@ func (r *Row) Scan(dest ...interface{}) error {\n \tif !r.rows.Next() {\n \t\treturn ErrNoRows\n \t}\n-\treturn r.rows.Scan(dest...)\n+\terr := r.rows.Scan(dest...)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// TODO(bradfitz): for now we need to defensively clone all\n+\t// []byte that the driver returned, since we're about to close\n+\t// the Rows in our defer, when we return from this function.\n+\t// the contract with the driver.Next(...) interface is that it\n+\t// can return slices into read-only temporary memory that's\n+\t// only valid until the next Scan/Close.  But the TODO is that\n+\t// for a lot of drivers, this copy will be unnecessary.  We\n+\t// should provide an optional interface for drivers to\n+\t// implement to say, \"don't worry, the []bytes that I return\n+\t// from Next will not be modified again.\" (for instance, if\n+\t// they were obtained from the network anyway) But for now we\n+\t// don't care.\n+\tfor _, dp := range dest {\n+\t\tb, ok := dp.(*[]byte)\n+\t\tif !ok {\n+\t\t\tcontinue\n+\t\t}\n+\t\tclone := make([]byte, len(*b))\n+\t\tcopy(clone, *b)\n+\t\t*b = clone\n+\t}\n+\treturn nil\n }\n \n // A Result summarizes an executed SQL command."}, {"sha": "3f98a8cd9f288ccd9fdc65da3b33c75419afc7b1", "filename": "libgo/go/exp/sql/sql_test.go", "status": "modified", "additions": 50, "deletions": 5, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fsql%2Fsql_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,21 +8,26 @@ import (\n \t\"reflect\"\n \t\"strings\"\n \t\"testing\"\n+\t\"time\"\n )\n \n+const fakeDBName = \"foo\"\n+\n+var chrisBirthday = time.Unix(123456789, 0)\n+\n func newTestDB(t *testing.T, name string) *DB {\n-\tdb, err := Open(\"test\", \"foo\")\n+\tdb, err := Open(\"test\", fakeDBName)\n \tif err != nil {\n \t\tt.Fatalf(\"Open: %v\", err)\n \t}\n \tif _, err := db.Exec(\"WIPE\"); err != nil {\n \t\tt.Fatalf(\"exec wipe: %v\", err)\n \t}\n \tif name == \"people\" {\n-\t\texec(t, db, \"CREATE|people|name=string,age=int32,dead=bool\")\n-\t\texec(t, db, \"INSERT|people|name=Alice,age=?\", 1)\n-\t\texec(t, db, \"INSERT|people|name=Bob,age=?\", 2)\n-\t\texec(t, db, \"INSERT|people|name=Chris,age=?\", 3)\n+\t\texec(t, db, \"CREATE|people|name=string,age=int32,photo=blob,dead=bool,bdate=datetime\")\n+\t\texec(t, db, \"INSERT|people|name=Alice,age=?,photo=APHOTO\", 1)\n+\t\texec(t, db, \"INSERT|people|name=Bob,age=?,photo=BPHOTO\", 2)\n+\t\texec(t, db, \"INSERT|people|name=Chris,age=?,photo=CPHOTO,bdate=?\", 3, chrisBirthday)\n \t}\n \treturn db\n }\n@@ -73,6 +78,12 @@ func TestQuery(t *testing.T) {\n \tif !reflect.DeepEqual(got, want) {\n \t\tt.Logf(\" got: %#v\\nwant: %#v\", got, want)\n \t}\n+\n+\t// And verify that the final rows.Next() call, which hit EOF,\n+\t// also closed the rows connection.\n+\tif n := len(db.freeConn); n != 1 {\n+\t\tt.Errorf(\"free conns after query hitting EOF = %d; want 1\", n)\n+\t}\n }\n \n func TestRowsColumns(t *testing.T) {\n@@ -97,12 +108,18 @@ func TestQueryRow(t *testing.T) {\n \tdefer closeDB(t, db)\n \tvar name string\n \tvar age int\n+\tvar birthday time.Time\n \n \terr := db.QueryRow(\"SELECT|people|age,name|age=?\", 3).Scan(&age)\n \tif err == nil || !strings.Contains(err.Error(), \"expected 2 destination arguments\") {\n \t\tt.Errorf(\"expected error from wrong number of arguments; actually got: %v\", err)\n \t}\n \n+\terr = db.QueryRow(\"SELECT|people|bdate|age=?\", 3).Scan(&birthday)\n+\tif err != nil || !birthday.Equal(chrisBirthday) {\n+\t\tt.Errorf(\"chris birthday = %v, err = %v; want %v\", birthday, err, chrisBirthday)\n+\t}\n+\n \terr = db.QueryRow(\"SELECT|people|age,name|age=?\", 2).Scan(&age, &name)\n \tif err != nil {\n \t\tt.Fatalf(\"age QueryRow+Scan: %v\", err)\n@@ -124,6 +141,16 @@ func TestQueryRow(t *testing.T) {\n \tif age != 1 {\n \t\tt.Errorf(\"expected age 1, got %d\", age)\n \t}\n+\n+\tvar photo []byte\n+\terr = db.QueryRow(\"SELECT|people|photo|name=?\", \"Alice\").Scan(&photo)\n+\tif err != nil {\n+\t\tt.Fatalf(\"photo QueryRow+Scan: %v\", err)\n+\t}\n+\twant := []byte(\"APHOTO\")\n+\tif !reflect.DeepEqual(photo, want) {\n+\t\tt.Errorf(\"photo = %q; want %q\", photo, want)\n+\t}\n }\n \n func TestStatementErrorAfterClose(t *testing.T) {\n@@ -258,3 +285,21 @@ func TestIssue2542Deadlock(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestQueryRowClosingStmt(t *testing.T) {\n+\tdb := newTestDB(t, \"people\")\n+\tdefer closeDB(t, db)\n+\tvar name string\n+\tvar age int\n+\terr := db.QueryRow(\"SELECT|people|age,name|age=?\", 3).Scan(&age, &name)\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(db.freeConn) != 1 {\n+\t\tt.Fatalf(\"expected 1 free conn\")\n+\t}\n+\tfakeConn := db.freeConn[0].(*fakeConn)\n+\tif made, closed := fakeConn.stmtsMade, fakeConn.stmtsClosed; made != closed {\n+\t\tt.Logf(\"statement close mismatch: made %d, closed %d\", made, closed)\n+\t}\n+}"}, {"sha": "8df81457bf54269bf13b522f1bd85c9de02c5d83", "filename": "libgo/go/exp/ssh/client.go", "status": "modified", "additions": 22, "deletions": 12, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fclient.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -420,27 +420,37 @@ type chanWriter struct {\n }\n \n // Write writes data to the remote process's standard input.\n-func (w *chanWriter) Write(data []byte) (n int, err error) {\n-\tfor {\n-\t\tif w.rwin == 0 {\n+func (w *chanWriter) Write(data []byte) (written int, err error) {\n+\tfor len(data) > 0 {\n+\t\tfor w.rwin < 1 {\n \t\t\twin, ok := <-w.win\n \t\t\tif !ok {\n \t\t\t\treturn 0, io.EOF\n \t\t\t}\n \t\t\tw.rwin += win\n-\t\t\tcontinue\n \t\t}\n+\t\tn := min(len(data), w.rwin)\n \t\tpeersId := w.clientChan.peersId\n-\t\tn = len(data)\n-\t\tpacket := make([]byte, 0, 9+n)\n-\t\tpacket = append(packet, msgChannelData,\n-\t\t\tbyte(peersId>>24), byte(peersId>>16), byte(peersId>>8), byte(peersId),\n-\t\t\tbyte(n>>24), byte(n>>16), byte(n>>8), byte(n))\n-\t\terr = w.clientChan.writePacket(append(packet, data...))\n+\t\tpacket := []byte{\n+\t\t\tmsgChannelData,\n+\t\t\tbyte(peersId >> 24), byte(peersId >> 16), byte(peersId >> 8), byte(peersId),\n+\t\t\tbyte(n >> 24), byte(n >> 16), byte(n >> 8), byte(n),\n+\t\t}\n+\t\tif err = w.clientChan.writePacket(append(packet, data[:n]...)); err != nil {\n+\t\t\tbreak\n+\t\t}\n+\t\tdata = data[n:]\n \t\tw.rwin -= n\n-\t\treturn\n+\t\twritten += n\n \t}\n-\tpanic(\"unreachable\")\n+\treturn\n+}\n+\n+func min(a, b int) int {\n+\tif a < b {\n+\t\treturn a\n+\t}\n+\treturn b\n }\n \n func (w *chanWriter) Close() error {"}, {"sha": "e7deb5ec168831488a3c9600c77cf1b86ad02c41", "filename": "libgo/go/exp/ssh/doc.go", "status": "modified", "additions": 35, "deletions": 13, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fdoc.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -14,7 +14,7 @@ others.\n An SSH server is represented by a ServerConfig, which holds certificate\n details and handles authentication of ServerConns.\n \n-\tconfig := new(ServerConfig)\n+\tconfig := new(ssh.ServerConfig)\n \tconfig.PubKeyCallback = pubKeyAuth\n \tconfig.PasswordCallback = passwordAuth\n \n@@ -34,8 +34,7 @@ Once a ServerConfig has been configured, connections can be accepted.\n \tif err != nil {\n \t\tpanic(\"failed to accept incoming connection\")\n \t}\n-\terr = sConn.Handshake(conn)\n-\tif err != nil {\n+\tif err := sConn.Handshake(conn); err != nil {\n \t\tpanic(\"failed to handshake\")\n \t}\n \n@@ -60,16 +59,20 @@ the case of a shell, the type is \"session\" and ServerShell may be used to\n present a simple terminal interface.\n \n \tif channel.ChannelType() != \"session\" {\n-\t\tc.Reject(UnknownChannelType, \"unknown channel type\")\n+\t\tchannel.Reject(UnknownChannelType, \"unknown channel type\")\n \t\treturn\n \t}\n \tchannel.Accept()\n \n-\tshell := NewServerShell(channel, \"> \")\n+\tterm := terminal.NewTerminal(channel, \"> \")\n+\tserverTerm := &ssh.ServerTerminal{\n+\t\tTerm: term,\n+\t\tChannel: channel,\n+\t}\n \tgo func() {\n \t\tdefer channel.Close()\n \t\tfor {\n-\t\t\tline, err := shell.ReadLine()\n+\t\t\tline, err := serverTerm.ReadLine()\n \t\t\tif err != nil {\n \t\t\t\tbreak\n \t\t\t}\n@@ -78,28 +81,47 @@ present a simple terminal interface.\n \t\treturn\n \t}()\n \n+To authenticate with the remote server you must pass at least one implementation of \n+ClientAuth via the Auth field in ClientConfig.\n+\n+\t// password implements the ClientPassword interface\n+\ttype password string\n+\n+\tfunc (p password) Password(user string) (string, error) {\n+\t\treturn string(p), nil\n+\t}\n+\n+\tconfig := &ssh.ClientConfig {\n+\t\tUser: \"username\",\n+\t\tAuth: []ClientAuth {\n+\t\t\t// ClientAuthPassword wraps a ClientPassword implementation\n+\t\t\t// in a type that implements ClientAuth.\n+\t\t\tClientAuthPassword(password(\"yourpassword\")),\n+\t\t}\n+\t}\n+\n An SSH client is represented with a ClientConn. Currently only the \"password\"\n-authentication method is supported. \n+authentication method is supported.\n \n \tconfig := &ClientConfig{\n \t\tUser: \"username\",\n \t\tAuth: []ClientAuth{ ... },\n \t}\n \tclient, err := Dial(\"yourserver.com:22\", config)\n \n-Each ClientConn can support multiple interactive sessions, represented by a Session. \n+Each ClientConn can support multiple interactive sessions, represented by a Session.\n \n \tsession, err := client.NewSession()\n \n-Once a Session is created, you can execute a single command on the remote side \n-using the Run method.\n+Once a Session is created, you can execute a single command on the remote side\n+using the Exec method.\n \n+\tb := bytes.NewBuffer()\n+\tsession.Stdin = b\n \tif err := session.Run(\"/usr/bin/whoami\"); err != nil {\n \t\tpanic(\"Failed to exec: \" + err.String())\n \t}\n-\treader := bufio.NewReader(session.Stdin)\n-\tline, _, _ := reader.ReadLine()\n-\tfmt.Println(line)\n+\tfmt.Println(bytes.String())\n \tsession.Close()\n */\n package ssh"}, {"sha": "5243d0ee7f4d5ce1536bdac66efae8ced5807e85", "filename": "libgo/go/exp/ssh/server_shell.go", "status": "removed", "additions": 0, "deletions": 398, "changes": 398, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell.go?ref=3be18e47c33b61365786831e0f967f42b09922c9", "patch": "@@ -1,398 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import \"io\"\n-\n-// ServerShell contains the state for running a VT100 terminal that is capable\n-// of reading lines of input.\n-type ServerShell struct {\n-\tc      Channel\n-\tprompt string\n-\n-\t// line is the current line being entered.\n-\tline []byte\n-\t// pos is the logical position of the cursor in line\n-\tpos int\n-\n-\t// cursorX contains the current X value of the cursor where the left\n-\t// edge is 0. cursorY contains the row number where the first row of\n-\t// the current line is 0.\n-\tcursorX, cursorY int\n-\t// maxLine is the greatest value of cursorY so far.\n-\tmaxLine int\n-\n-\ttermWidth, termHeight int\n-\n-\t// outBuf contains the terminal data to be sent.\n-\toutBuf []byte\n-\t// remainder contains the remainder of any partial key sequences after\n-\t// a read. It aliases into inBuf.\n-\tremainder []byte\n-\tinBuf     [256]byte\n-}\n-\n-// NewServerShell runs a VT100 terminal on the given channel. prompt is a\n-// string that is written at the start of each input line. For example: \"> \".\n-func NewServerShell(c Channel, prompt string) *ServerShell {\n-\treturn &ServerShell{\n-\t\tc:          c,\n-\t\tprompt:     prompt,\n-\t\ttermWidth:  80,\n-\t\ttermHeight: 24,\n-\t}\n-}\n-\n-const (\n-\tkeyCtrlD     = 4\n-\tkeyEnter     = '\\r'\n-\tkeyEscape    = 27\n-\tkeyBackspace = 127\n-\tkeyUnknown   = 256 + iota\n-\tkeyUp\n-\tkeyDown\n-\tkeyLeft\n-\tkeyRight\n-\tkeyAltLeft\n-\tkeyAltRight\n-)\n-\n-// bytesToKey tries to parse a key sequence from b. If successful, it returns\n-// the key and the remainder of the input. Otherwise it returns -1.\n-func bytesToKey(b []byte) (int, []byte) {\n-\tif len(b) == 0 {\n-\t\treturn -1, nil\n-\t}\n-\n-\tif b[0] != keyEscape {\n-\t\treturn int(b[0]), b[1:]\n-\t}\n-\n-\tif len(b) >= 3 && b[0] == keyEscape && b[1] == '[' {\n-\t\tswitch b[2] {\n-\t\tcase 'A':\n-\t\t\treturn keyUp, b[3:]\n-\t\tcase 'B':\n-\t\t\treturn keyDown, b[3:]\n-\t\tcase 'C':\n-\t\t\treturn keyRight, b[3:]\n-\t\tcase 'D':\n-\t\t\treturn keyLeft, b[3:]\n-\t\t}\n-\t}\n-\n-\tif len(b) >= 6 && b[0] == keyEscape && b[1] == '[' && b[2] == '1' && b[3] == ';' && b[4] == '3' {\n-\t\tswitch b[5] {\n-\t\tcase 'C':\n-\t\t\treturn keyAltRight, b[6:]\n-\t\tcase 'D':\n-\t\t\treturn keyAltLeft, b[6:]\n-\t\t}\n-\t}\n-\n-\t// If we get here then we have a key that we don't recognise, or a\n-\t// partial sequence. It's not clear how one should find the end of a\n-\t// sequence without knowing them all, but it seems that [a-zA-Z] only\n-\t// appears at the end of a sequence.\n-\tfor i, c := range b[0:] {\n-\t\tif c >= 'a' && c <= 'z' || c >= 'A' && c <= 'Z' {\n-\t\t\treturn keyUnknown, b[i+1:]\n-\t\t}\n-\t}\n-\n-\treturn -1, b\n-}\n-\n-// queue appends data to the end of ss.outBuf\n-func (ss *ServerShell) queue(data []byte) {\n-\tif len(ss.outBuf)+len(data) > cap(ss.outBuf) {\n-\t\tnewOutBuf := make([]byte, len(ss.outBuf), 2*(len(ss.outBuf)+len(data)))\n-\t\tcopy(newOutBuf, ss.outBuf)\n-\t\tss.outBuf = newOutBuf\n-\t}\n-\n-\toldLen := len(ss.outBuf)\n-\tss.outBuf = ss.outBuf[:len(ss.outBuf)+len(data)]\n-\tcopy(ss.outBuf[oldLen:], data)\n-}\n-\n-var eraseUnderCursor = []byte{' ', keyEscape, '[', 'D'}\n-\n-func isPrintable(key int) bool {\n-\treturn key >= 32 && key < 127\n-}\n-\n-// moveCursorToPos appends data to ss.outBuf which will move the cursor to the\n-// given, logical position in the text.\n-func (ss *ServerShell) moveCursorToPos(pos int) {\n-\tx := len(ss.prompt) + pos\n-\ty := x / ss.termWidth\n-\tx = x % ss.termWidth\n-\n-\tup := 0\n-\tif y < ss.cursorY {\n-\t\tup = ss.cursorY - y\n-\t}\n-\n-\tdown := 0\n-\tif y > ss.cursorY {\n-\t\tdown = y - ss.cursorY\n-\t}\n-\n-\tleft := 0\n-\tif x < ss.cursorX {\n-\t\tleft = ss.cursorX - x\n-\t}\n-\n-\tright := 0\n-\tif x > ss.cursorX {\n-\t\tright = x - ss.cursorX\n-\t}\n-\n-\tmovement := make([]byte, 3*(up+down+left+right))\n-\tm := movement\n-\tfor i := 0; i < up; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'A'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < down; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'B'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < left; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'D'\n-\t\tm = m[3:]\n-\t}\n-\tfor i := 0; i < right; i++ {\n-\t\tm[0] = keyEscape\n-\t\tm[1] = '['\n-\t\tm[2] = 'C'\n-\t\tm = m[3:]\n-\t}\n-\n-\tss.cursorX = x\n-\tss.cursorY = y\n-\tss.queue(movement)\n-}\n-\n-const maxLineLength = 4096\n-\n-// handleKey processes the given key and, optionally, returns a line of text\n-// that the user has entered.\n-func (ss *ServerShell) handleKey(key int) (line string, ok bool) {\n-\tswitch key {\n-\tcase keyBackspace:\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\n-\t\tcopy(ss.line[ss.pos:], ss.line[1+ss.pos:])\n-\t\tss.line = ss.line[:len(ss.line)-1]\n-\t\tss.writeLine(ss.line[ss.pos:])\n-\t\tss.moveCursorToPos(ss.pos)\n-\t\tss.queue(eraseUnderCursor)\n-\tcase keyAltLeft:\n-\t\t// move left by a word.\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\t\tfor ss.pos > 0 {\n-\t\t\tif ss.line[ss.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos--\n-\t\t}\n-\t\tfor ss.pos > 0 {\n-\t\t\tif ss.line[ss.pos] == ' ' {\n-\t\t\t\tss.pos++\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos--\n-\t\t}\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyAltRight:\n-\t\t// move right by a word.\n-\t\tfor ss.pos < len(ss.line) {\n-\t\t\tif ss.line[ss.pos] == ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos++\n-\t\t}\n-\t\tfor ss.pos < len(ss.line) {\n-\t\t\tif ss.line[ss.pos] != ' ' {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tss.pos++\n-\t\t}\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyLeft:\n-\t\tif ss.pos == 0 {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos--\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyRight:\n-\t\tif ss.pos == len(ss.line) {\n-\t\t\treturn\n-\t\t}\n-\t\tss.pos++\n-\t\tss.moveCursorToPos(ss.pos)\n-\tcase keyEnter:\n-\t\tss.moveCursorToPos(len(ss.line))\n-\t\tss.queue([]byte(\"\\r\\n\"))\n-\t\tline = string(ss.line)\n-\t\tok = true\n-\t\tss.line = ss.line[:0]\n-\t\tss.pos = 0\n-\t\tss.cursorX = 0\n-\t\tss.cursorY = 0\n-\t\tss.maxLine = 0\n-\tdefault:\n-\t\tif !isPrintable(key) {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(ss.line) == maxLineLength {\n-\t\t\treturn\n-\t\t}\n-\t\tif len(ss.line) == cap(ss.line) {\n-\t\t\tnewLine := make([]byte, len(ss.line), 2*(1+len(ss.line)))\n-\t\t\tcopy(newLine, ss.line)\n-\t\t\tss.line = newLine\n-\t\t}\n-\t\tss.line = ss.line[:len(ss.line)+1]\n-\t\tcopy(ss.line[ss.pos+1:], ss.line[ss.pos:])\n-\t\tss.line[ss.pos] = byte(key)\n-\t\tss.writeLine(ss.line[ss.pos:])\n-\t\tss.pos++\n-\t\tss.moveCursorToPos(ss.pos)\n-\t}\n-\treturn\n-}\n-\n-func (ss *ServerShell) writeLine(line []byte) {\n-\tfor len(line) != 0 {\n-\t\tif ss.cursorX == ss.termWidth {\n-\t\t\tss.queue([]byte(\"\\r\\n\"))\n-\t\t\tss.cursorX = 0\n-\t\t\tss.cursorY++\n-\t\t\tif ss.cursorY > ss.maxLine {\n-\t\t\t\tss.maxLine = ss.cursorY\n-\t\t\t}\n-\t\t}\n-\n-\t\tremainingOnLine := ss.termWidth - ss.cursorX\n-\t\ttodo := len(line)\n-\t\tif todo > remainingOnLine {\n-\t\t\ttodo = remainingOnLine\n-\t\t}\n-\t\tss.queue(line[:todo])\n-\t\tss.cursorX += todo\n-\t\tline = line[todo:]\n-\t}\n-}\n-\n-// parsePtyRequest parses the payload of the pty-req message and extracts the\n-// dimensions of the terminal. See RFC 4254, section 6.2.\n-func parsePtyRequest(s []byte) (width, height int, ok bool) {\n-\t_, s, ok = parseString(s)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\twidth32, s, ok := parseUint32(s)\n-\tif !ok {\n-\t\treturn\n-\t}\n-\theight32, _, ok := parseUint32(s)\n-\twidth = int(width32)\n-\theight = int(height32)\n-\tif width < 1 {\n-\t\tok = false\n-\t}\n-\tif height < 1 {\n-\t\tok = false\n-\t}\n-\treturn\n-}\n-\n-func (ss *ServerShell) Write(buf []byte) (n int, err error) {\n-\treturn ss.c.Write(buf)\n-}\n-\n-// ReadLine returns a line of input from the terminal.\n-func (ss *ServerShell) ReadLine() (line string, err error) {\n-\tss.writeLine([]byte(ss.prompt))\n-\tss.c.Write(ss.outBuf)\n-\tss.outBuf = ss.outBuf[:0]\n-\n-\tfor {\n-\t\t// ss.remainder is a slice at the beginning of ss.inBuf\n-\t\t// containing a partial key sequence\n-\t\treadBuf := ss.inBuf[len(ss.remainder):]\n-\t\tvar n int\n-\t\tn, err = ss.c.Read(readBuf)\n-\t\tif err == nil {\n-\t\t\tss.remainder = ss.inBuf[:n+len(ss.remainder)]\n-\t\t\trest := ss.remainder\n-\t\t\tlineOk := false\n-\t\t\tfor !lineOk {\n-\t\t\t\tvar key int\n-\t\t\t\tkey, rest = bytesToKey(rest)\n-\t\t\t\tif key < 0 {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif key == keyCtrlD {\n-\t\t\t\t\treturn \"\", io.EOF\n-\t\t\t\t}\n-\t\t\t\tline, lineOk = ss.handleKey(key)\n-\t\t\t}\n-\t\t\tif len(rest) > 0 {\n-\t\t\t\tn := copy(ss.inBuf[:], rest)\n-\t\t\t\tss.remainder = ss.inBuf[:n]\n-\t\t\t} else {\n-\t\t\t\tss.remainder = nil\n-\t\t\t}\n-\t\t\tss.c.Write(ss.outBuf)\n-\t\t\tss.outBuf = ss.outBuf[:0]\n-\t\t\tif lineOk {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif req, ok := err.(ChannelRequest); ok {\n-\t\t\tok := false\n-\t\t\tswitch req.Request {\n-\t\t\tcase \"pty-req\":\n-\t\t\t\tss.termWidth, ss.termHeight, ok = parsePtyRequest(req.Payload)\n-\t\t\t\tif !ok {\n-\t\t\t\t\tss.termWidth = 80\n-\t\t\t\t\tss.termHeight = 24\n-\t\t\t\t}\n-\t\t\tcase \"shell\":\n-\t\t\t\tok = true\n-\t\t\t\tif len(req.Payload) > 0 {\n-\t\t\t\t\t// We don't accept any commands, only the default shell.\n-\t\t\t\t\tok = false\n-\t\t\t\t}\n-\t\t\tcase \"env\":\n-\t\t\t\tok = true\n-\t\t\t}\n-\t\t\tif req.WantReply {\n-\t\t\t\tss.c.AckRequest(ok)\n-\t\t\t}\n-\t\t} else {\n-\t\t\treturn \"\", err\n-\t\t}\n-\t}\n-\tpanic(\"unreachable\")\n-}"}, {"sha": "aa69ef7fedb3c7e388c554c9d6152c29ef3867e2", "filename": "libgo/go/exp/ssh/server_shell_test.go", "status": "removed", "additions": 0, "deletions": 134, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_shell_test.go?ref=3be18e47c33b61365786831e0f967f42b09922c9", "patch": "@@ -1,134 +0,0 @@\n-// Copyright 2011 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package ssh\n-\n-import (\n-\t\"io\"\n-\t\"testing\"\n-)\n-\n-type MockChannel struct {\n-\ttoSend       []byte\n-\tbytesPerRead int\n-\treceived     []byte\n-}\n-\n-func (c *MockChannel) Accept() error {\n-\treturn nil\n-}\n-\n-func (c *MockChannel) Reject(RejectionReason, string) error {\n-\treturn nil\n-}\n-\n-func (c *MockChannel) Read(data []byte) (n int, err error) {\n-\tn = len(data)\n-\tif n == 0 {\n-\t\treturn\n-\t}\n-\tif n > len(c.toSend) {\n-\t\tn = len(c.toSend)\n-\t}\n-\tif n == 0 {\n-\t\treturn 0, io.EOF\n-\t}\n-\tif c.bytesPerRead > 0 && n > c.bytesPerRead {\n-\t\tn = c.bytesPerRead\n-\t}\n-\tcopy(data, c.toSend[:n])\n-\tc.toSend = c.toSend[n:]\n-\treturn\n-}\n-\n-func (c *MockChannel) Write(data []byte) (n int, err error) {\n-\tc.received = append(c.received, data...)\n-\treturn len(data), nil\n-}\n-\n-func (c *MockChannel) Close() error {\n-\treturn nil\n-}\n-\n-func (c *MockChannel) AckRequest(ok bool) error {\n-\treturn nil\n-}\n-\n-func (c *MockChannel) ChannelType() string {\n-\treturn \"\"\n-}\n-\n-func (c *MockChannel) ExtraData() []byte {\n-\treturn nil\n-}\n-\n-func TestClose(t *testing.T) {\n-\tc := &MockChannel{}\n-\tss := NewServerShell(c, \"> \")\n-\tline, err := ss.ReadLine()\n-\tif line != \"\" {\n-\t\tt.Errorf(\"Expected empty line but got: %s\", line)\n-\t}\n-\tif err != io.EOF {\n-\t\tt.Errorf(\"Error should have been EOF but got: %s\", err)\n-\t}\n-}\n-\n-var keyPressTests = []struct {\n-\tin   string\n-\tline string\n-\terr  error\n-}{\n-\t{\n-\t\t\"\",\n-\t\t\"\",\n-\t\tio.EOF,\n-\t},\n-\t{\n-\t\t\"\\r\",\n-\t\t\"\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"foo\\r\",\n-\t\t\"foo\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\x1b[Cb\\r\", // right\n-\t\t\"ab\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\x1b[Db\\r\", // left\n-\t\t\"ba\",\n-\t\tnil,\n-\t},\n-\t{\n-\t\t\"a\\177b\\r\", // backspace\n-\t\t\"b\",\n-\t\tnil,\n-\t},\n-}\n-\n-func TestKeyPresses(t *testing.T) {\n-\tfor i, test := range keyPressTests {\n-\t\tfor j := 0; j < len(test.in); j++ {\n-\t\t\tc := &MockChannel{\n-\t\t\t\ttoSend:       []byte(test.in),\n-\t\t\t\tbytesPerRead: j,\n-\t\t\t}\n-\t\t\tss := NewServerShell(c, \"> \")\n-\t\t\tline, err := ss.ReadLine()\n-\t\t\tif line != test.line {\n-\t\t\t\tt.Errorf(\"Line resulting from test %d (%d bytes per read) was '%s', expected '%s'\", i, j, line, test.line)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif err != test.err {\n-\t\t\t\tt.Errorf(\"Error resulting from test %d (%d bytes per read) was '%v', expected '%v'\", i, j, err, test.err)\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t}\n-}"}, {"sha": "708a9159ec8ae5e5641456f779f2d41d00d1ddf4", "filename": "libgo/go/exp/ssh/server_terminal.go", "status": "added", "additions": 81, "deletions": 0, "changes": 81, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fserver_terminal.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,81 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package ssh\n+\n+// A Terminal is capable of parsing and generating virtual terminal\n+// data from an SSH client.\n+type Terminal interface {\n+\tReadLine() (line string, err error)\n+\tSetSize(x, y int)\n+\tWrite([]byte) (int, error)\n+}\n+\n+// ServerTerminal contains the state for running a terminal that is capable of\n+// reading lines of input.\n+type ServerTerminal struct {\n+\tTerm    Terminal\n+\tChannel Channel\n+}\n+\n+// parsePtyRequest parses the payload of the pty-req message and extracts the\n+// dimensions of the terminal. See RFC 4254, section 6.2.\n+func parsePtyRequest(s []byte) (width, height int, ok bool) {\n+\t_, s, ok = parseString(s)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\twidth32, s, ok := parseUint32(s)\n+\tif !ok {\n+\t\treturn\n+\t}\n+\theight32, _, ok := parseUint32(s)\n+\twidth = int(width32)\n+\theight = int(height32)\n+\tif width < 1 {\n+\t\tok = false\n+\t}\n+\tif height < 1 {\n+\t\tok = false\n+\t}\n+\treturn\n+}\n+\n+func (ss *ServerTerminal) Write(buf []byte) (n int, err error) {\n+\treturn ss.Term.Write(buf)\n+}\n+\n+// ReadLine returns a line of input from the terminal.\n+func (ss *ServerTerminal) ReadLine() (line string, err error) {\n+\tfor {\n+\t\tif line, err = ss.Term.ReadLine(); err == nil {\n+\t\t\treturn\n+\t\t}\n+\n+\t\treq, ok := err.(ChannelRequest)\n+\t\tif !ok {\n+\t\t\treturn\n+\t\t}\n+\n+\t\tok = false\n+\t\tswitch req.Request {\n+\t\tcase \"pty-req\":\n+\t\t\tvar width, height int\n+\t\t\twidth, height, ok = parsePtyRequest(req.Payload)\n+\t\t\tss.Term.SetSize(width, height)\n+\t\tcase \"shell\":\n+\t\t\tok = true\n+\t\t\tif len(req.Payload) > 0 {\n+\t\t\t\t// We don't accept any commands, only the default shell.\n+\t\t\t\tok = false\n+\t\t\t}\n+\t\tcase \"env\":\n+\t\t\tok = true\n+\t\t}\n+\t\tif req.WantReply {\n+\t\t\tss.Channel.AckRequest(ok)\n+\t\t}\n+\t}\n+\tpanic(\"unreachable\")\n+}"}, {"sha": "4a3d22bee04f905be3cdf581f7a8a12955892c8b", "filename": "libgo/go/exp/ssh/session_test.go", "status": "modified", "additions": 16, "deletions": 7, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Fsession_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,6 +8,7 @@ package ssh\n \n import (\n \t\"bytes\"\n+\t\"exp/terminal\"\n \t\"io\"\n \t\"testing\"\n )\n@@ -290,53 +291,61 @@ type exitSignalMsg struct {\n \tLang       string\n }\n \n+func newServerShell(ch *channel, prompt string) *ServerTerminal {\n+\tterm := terminal.NewTerminal(ch, prompt)\n+\treturn &ServerTerminal{\n+\t\tTerm:    term,\n+\t\tChannel: ch,\n+\t}\n+}\n+\n func exitStatusZeroHandler(ch *channel) {\n \tdefer ch.Close()\n \t// this string is returned to stdout\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n \tsendStatus(0, ch)\n }\n \n func exitStatusNonZeroHandler(ch *channel) {\n \tdefer ch.Close()\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n \tsendStatus(15, ch)\n }\n \n func exitSignalAndStatusHandler(ch *channel) {\n \tdefer ch.Close()\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n \tsendStatus(15, ch)\n \tsendSignal(\"TERM\", ch)\n }\n \n func exitSignalHandler(ch *channel) {\n \tdefer ch.Close()\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n \tsendSignal(\"TERM\", ch)\n }\n \n func exitSignalUnknownHandler(ch *channel) {\n \tdefer ch.Close()\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n \tsendSignal(\"SYS\", ch)\n }\n \n func exitWithoutSignalOrStatus(ch *channel) {\n \tdefer ch.Close()\n-\tshell := NewServerShell(ch, \"> \")\n+\tshell := newServerShell(ch, \"> \")\n \tshell.ReadLine()\n }\n \n func shellHandler(ch *channel) {\n \tdefer ch.Close()\n \t// this string is returned to stdout\n-\tshell := NewServerShell(ch, \"golang\")\n+\tshell := newServerShell(ch, \"golang\")\n \tshell.ReadLine()\n \tsendStatus(0, ch)\n }"}, {"sha": "2e7c955a12de6d9abb3b6f8c1b0cfa802a1440e3", "filename": "libgo/go/exp/ssh/transport.go", "status": "modified", "additions": 1, "deletions": 3, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fssh%2Ftransport.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -117,9 +117,7 @@ func (r *reader) readOnePacket() ([]byte, error) {\n \t\treturn nil, err\n \t}\n \tmac := packet[length-1:]\n-\tif r.cipher != nil {\n-\t\tr.cipher.XORKeyStream(packet, packet[:length-1])\n-\t}\n+\tr.cipher.XORKeyStream(packet, packet[:length-1])\n \n \tif r.mac != nil {\n \t\tr.mac.Write(packet[:length-1])"}, {"sha": "c3ba5bde2ee6e69b01b7f9e315c1d17bdef7f3ea", "filename": "libgo/go/exp/terminal/terminal.go", "status": "modified", "additions": 34, "deletions": 30, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build linux\n-\n package terminal\n \n import (\n@@ -463,6 +461,31 @@ func (t *Terminal) readLine() (line string, err error) {\n \t}\n \n \tfor {\n+\t\trest := t.remainder\n+\t\tlineOk := false\n+\t\tfor !lineOk {\n+\t\t\tvar key int\n+\t\t\tkey, rest = bytesToKey(rest)\n+\t\t\tif key < 0 {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t\tif key == keyCtrlD {\n+\t\t\t\treturn \"\", io.EOF\n+\t\t\t}\n+\t\t\tline, lineOk = t.handleKey(key)\n+\t\t}\n+\t\tif len(rest) > 0 {\n+\t\t\tn := copy(t.inBuf[:], rest)\n+\t\t\tt.remainder = t.inBuf[:n]\n+\t\t} else {\n+\t\t\tt.remainder = nil\n+\t\t}\n+\t\tt.c.Write(t.outBuf)\n+\t\tt.outBuf = t.outBuf[:0]\n+\t\tif lineOk {\n+\t\t\treturn\n+\t\t}\n+\n \t\t// t.remainder is a slice at the beginning of t.inBuf\n \t\t// containing a partial key sequence\n \t\treadBuf := t.inBuf[len(t.remainder):]\n@@ -476,38 +499,19 @@ func (t *Terminal) readLine() (line string, err error) {\n \t\t\treturn\n \t\t}\n \n-\t\tif err == nil {\n-\t\t\tt.remainder = t.inBuf[:n+len(t.remainder)]\n-\t\t\trest := t.remainder\n-\t\t\tlineOk := false\n-\t\t\tfor !lineOk {\n-\t\t\t\tvar key int\n-\t\t\t\tkey, rest = bytesToKey(rest)\n-\t\t\t\tif key < 0 {\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tif key == keyCtrlD {\n-\t\t\t\t\treturn \"\", io.EOF\n-\t\t\t\t}\n-\t\t\t\tline, lineOk = t.handleKey(key)\n-\t\t\t}\n-\t\t\tif len(rest) > 0 {\n-\t\t\t\tn := copy(t.inBuf[:], rest)\n-\t\t\t\tt.remainder = t.inBuf[:n]\n-\t\t\t} else {\n-\t\t\t\tt.remainder = nil\n-\t\t\t}\n-\t\t\tt.c.Write(t.outBuf)\n-\t\t\tt.outBuf = t.outBuf[:0]\n-\t\t\tif lineOk {\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n+\t\tt.remainder = t.inBuf[:n+len(t.remainder)]\n \t}\n \tpanic(\"unreachable\")\n }\n \n+// SetPrompt sets the prompt to be used when reading subsequent lines.\n+func (t *Terminal) SetPrompt(prompt string) {\n+\tt.lock.Lock()\n+\tdefer t.lock.Unlock()\n+\n+\tt.prompt = prompt\n+}\n+\n func (t *Terminal) SetSize(width, height int) {\n \tt.lock.Lock()\n \tdefer t.lock.Unlock()"}, {"sha": "a2197210e2a8d4da5720b2c797afccd21156011d", "filename": "libgo/go/exp/terminal/terminal_test.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Fterminal%2Fterminal_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build linux\n-\n package terminal\n \n import ("}, {"sha": "ea9218ff51d67fbbe27f902de61b844cc0669a28", "filename": "libgo/go/exp/types/check_test.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Fcheck_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -111,7 +111,7 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t// set otherwise the position information returned here will\n \t\t// not match the position information collected by the parser\n \t\ts.Init(getFile(filename), src, nil, scanner.ScanComments)\n-\t\tvar prev token.Pos // position of last non-comment token\n+\t\tvar prev token.Pos // position of last non-comment, non-semicolon token\n \n \tscanFile:\n \t\tfor {\n@@ -124,6 +124,12 @@ func expectedErrors(t *testing.T, testname string, files map[string]*ast.File) m\n \t\t\t\tif len(s) == 2 {\n \t\t\t\t\terrors[prev] = string(s[1])\n \t\t\t\t}\n+\t\t\tcase token.SEMICOLON:\n+\t\t\t\t// ignore automatically inserted semicolon\n+\t\t\t\tif lit == \"\\n\" {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tfallthrough\n \t\t\tdefault:\n \t\t\t\tprev = pos\n \t\t\t}"}, {"sha": "46cff31bce84e8e833483d5e7cbbd96d61bf9c20", "filename": "libgo/go/exp/types/universe.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fexp%2Ftypes%2Funiverse.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -20,6 +20,7 @@ func define(kind ast.ObjKind, name string) *ast.Object {\n \tif scope.Insert(obj) != nil {\n \t\tpanic(\"types internal error: double declaration\")\n \t}\n+\tobj.Decl = scope\n \treturn obj\n }\n "}, {"sha": "964f5541b86c2f53d76c36aee21d3e355562b7ee", "filename": "libgo/go/flag/flag.go", "status": "modified", "additions": 77, "deletions": 37, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fflag%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fflag%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -65,71 +65,72 @@ import (\n \t\"os\"\n \t\"sort\"\n \t\"strconv\"\n+\t\"time\"\n )\n \n // ErrHelp is the error returned if the flag -help is invoked but no such flag is defined.\n var ErrHelp = errors.New(\"flag: help requested\")\n \n-// -- Bool Value\n+// -- bool Value\n type boolValue bool\n \n func newBoolValue(val bool, p *bool) *boolValue {\n \t*p = val\n \treturn (*boolValue)(p)\n }\n \n-func (b *boolValue) Set(s string) bool {\n+func (b *boolValue) Set(s string) error {\n \tv, err := strconv.ParseBool(s)\n \t*b = boolValue(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (b *boolValue) String() string { return fmt.Sprintf(\"%v\", *b) }\n \n-// -- Int Value\n+// -- int Value\n type intValue int\n \n func newIntValue(val int, p *int) *intValue {\n \t*p = val\n \treturn (*intValue)(p)\n }\n \n-func (i *intValue) Set(s string) bool {\n+func (i *intValue) Set(s string) error {\n \tv, err := strconv.ParseInt(s, 0, 64)\n \t*i = intValue(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (i *intValue) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n-// -- Int64 Value\n+// -- int64 Value\n type int64Value int64\n \n func newInt64Value(val int64, p *int64) *int64Value {\n \t*p = val\n \treturn (*int64Value)(p)\n }\n \n-func (i *int64Value) Set(s string) bool {\n+func (i *int64Value) Set(s string) error {\n \tv, err := strconv.ParseInt(s, 0, 64)\n \t*i = int64Value(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (i *int64Value) String() string { return fmt.Sprintf(\"%v\", *i) }\n \n-// -- Uint Value\n+// -- uint Value\n type uintValue uint\n \n func newUintValue(val uint, p *uint) *uintValue {\n \t*p = val\n \treturn (*uintValue)(p)\n }\n \n-func (i *uintValue) Set(s string) bool {\n+func (i *uintValue) Set(s string) error {\n \tv, err := strconv.ParseUint(s, 0, 64)\n \t*i = uintValue(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (i *uintValue) String() string { return fmt.Sprintf(\"%v\", *i) }\n@@ -142,10 +143,10 @@ func newUint64Value(val uint64, p *uint64) *uint64Value {\n \treturn (*uint64Value)(p)\n }\n \n-func (i *uint64Value) Set(s string) bool {\n+func (i *uint64Value) Set(s string) error {\n \tv, err := strconv.ParseUint(s, 0, 64)\n \t*i = uint64Value(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (i *uint64Value) String() string { return fmt.Sprintf(\"%v\", *i) }\n@@ -158,34 +159,50 @@ func newStringValue(val string, p *string) *stringValue {\n \treturn (*stringValue)(p)\n }\n \n-func (s *stringValue) Set(val string) bool {\n+func (s *stringValue) Set(val string) error {\n \t*s = stringValue(val)\n-\treturn true\n+\treturn nil\n }\n \n func (s *stringValue) String() string { return fmt.Sprintf(\"%s\", *s) }\n \n-// -- Float64 Value\n+// -- float64 Value\n type float64Value float64\n \n func newFloat64Value(val float64, p *float64) *float64Value {\n \t*p = val\n \treturn (*float64Value)(p)\n }\n \n-func (f *float64Value) Set(s string) bool {\n+func (f *float64Value) Set(s string) error {\n \tv, err := strconv.ParseFloat(s, 64)\n \t*f = float64Value(v)\n-\treturn err == nil\n+\treturn err\n }\n \n func (f *float64Value) String() string { return fmt.Sprintf(\"%v\", *f) }\n \n+// -- time.Duration Value\n+type durationValue time.Duration\n+\n+func newDurationValue(val time.Duration, p *time.Duration) *durationValue {\n+\t*p = val\n+\treturn (*durationValue)(p)\n+}\n+\n+func (d *durationValue) Set(s string) error {\n+\tv, err := time.ParseDuration(s)\n+\t*d = durationValue(v)\n+\treturn err\n+}\n+\n+func (d *durationValue) String() string { return (*time.Duration)(d).String() }\n+\n // Value is the interface to the dynamic value stored in a flag.\n // (The default value is represented as a string.)\n type Value interface {\n \tString() string\n-\tSet(string) bool\n+\tSet(string) error\n }\n \n // ErrorHandling defines how to handle flag parsing errors.\n@@ -276,27 +293,25 @@ func Lookup(name string) *Flag {\n \treturn commandLine.formal[name]\n }\n \n-// Set sets the value of the named flag.  It returns true if the set succeeded; false if\n-// there is no such flag defined.\n-func (f *FlagSet) Set(name, value string) bool {\n+// Set sets the value of the named flag.\n+func (f *FlagSet) Set(name, value string) error {\n \tflag, ok := f.formal[name]\n \tif !ok {\n-\t\treturn false\n+\t\treturn fmt.Errorf(\"no such flag -%v\", name)\n \t}\n-\tok = flag.Value.Set(value)\n-\tif !ok {\n-\t\treturn false\n+\terr := flag.Value.Set(value)\n+\tif err != nil {\n+\t\treturn err\n \t}\n \tif f.actual == nil {\n \t\tf.actual = make(map[string]*Flag)\n \t}\n \tf.actual[name] = flag\n-\treturn true\n+\treturn nil\n }\n \n-// Set sets the value of the named command-line flag. It returns true if the\n-// set succeeded; false if there is no such flag defined.\n-func Set(name, value string) bool {\n+// Set sets the value of the named command-line flag.\n+func Set(name, value string) error {\n \treturn commandLine.Set(name, value)\n }\n \n@@ -543,12 +558,38 @@ func (f *FlagSet) Float64(name string, value float64, usage string) *float64 {\n \treturn p\n }\n \n-// Float64 defines an int flag with specified name, default value, and usage string.\n+// Float64 defines a float64 flag with specified name, default value, and usage string.\n // The return value is the address of a float64 variable that stores the value of the flag.\n func Float64(name string, value float64, usage string) *float64 {\n \treturn commandLine.Float64(name, value, usage)\n }\n \n+// DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n+// The argument p points to a time.Duration variable in which to store the value of the flag.\n+func (f *FlagSet) DurationVar(p *time.Duration, name string, value time.Duration, usage string) {\n+\tf.Var(newDurationValue(value, p), name, usage)\n+}\n+\n+// DurationVar defines a time.Duration flag with specified name, default value, and usage string.\n+// The argument p points to a time.Duration variable in which to store the value of the flag.\n+func DurationVar(p *time.Duration, name string, value time.Duration, usage string) {\n+\tcommandLine.Var(newDurationValue(value, p), name, usage)\n+}\n+\n+// Duration defines a time.Duration flag with specified name, default value, and usage string.\n+// The return value is the address of a time.Duration variable that stores the value of the flag.\n+func (f *FlagSet) Duration(name string, value time.Duration, usage string) *time.Duration {\n+\tp := new(time.Duration)\n+\tf.DurationVar(p, name, value, usage)\n+\treturn p\n+}\n+\n+// Duration defines a time.Duration flag with specified name, default value, and usage string.\n+// The return value is the address of a time.Duration variable that stores the value of the flag.\n+func Duration(name string, value time.Duration, usage string) *time.Duration {\n+\treturn commandLine.Duration(name, value, usage)\n+}\n+\n // Var defines a flag with the specified name and usage string. The type and\n // value of the flag are represented by the first argument, of type Value, which\n // typically holds a user-defined implementation of Value. For instance, the\n@@ -645,8 +686,8 @@ func (f *FlagSet) parseOne() (bool, error) {\n \t}\n \tif fv, ok := flag.Value.(*boolValue); ok { // special case: doesn't need an arg\n \t\tif has_value {\n-\t\t\tif !fv.Set(value) {\n-\t\t\t\tf.failf(\"invalid boolean value %q for flag: -%s\", value, name)\n+\t\t\tif err := fv.Set(value); err != nil {\n+\t\t\t\tf.failf(\"invalid boolean value %q for  -%s: %v\", value, name, err)\n \t\t\t}\n \t\t} else {\n \t\t\tfv.Set(\"true\")\n@@ -661,9 +702,8 @@ func (f *FlagSet) parseOne() (bool, error) {\n \t\tif !has_value {\n \t\t\treturn false, f.failf(\"flag needs an argument: -%s\", name)\n \t\t}\n-\t\tok = flag.Value.Set(value)\n-\t\tif !ok {\n-\t\t\treturn false, f.failf(\"invalid value %q for flag: -%s\", value, name)\n+\t\tif err := flag.Value.Set(value); err != nil {\n+\t\t\treturn false, f.failf(\"invalid value %q for flag -%s: %v\", value, name, err)\n \t\t}\n \t}\n \tif f.actual == nil {"}, {"sha": "698c15f2c58f681c34befbf4481411af0211a8a7", "filename": "libgo/go/flag/flag_test.go", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fflag%2Fflag_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fflag%2Fflag_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fflag%2Fflag_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,16 +10,18 @@ import (\n \t\"os\"\n \t\"sort\"\n \t\"testing\"\n+\t\"time\"\n )\n \n var (\n-\ttest_bool    = Bool(\"test_bool\", false, \"bool value\")\n-\ttest_int     = Int(\"test_int\", 0, \"int value\")\n-\ttest_int64   = Int64(\"test_int64\", 0, \"int64 value\")\n-\ttest_uint    = Uint(\"test_uint\", 0, \"uint value\")\n-\ttest_uint64  = Uint64(\"test_uint64\", 0, \"uint64 value\")\n-\ttest_string  = String(\"test_string\", \"0\", \"string value\")\n-\ttest_float64 = Float64(\"test_float64\", 0, \"float64 value\")\n+\ttest_bool     = Bool(\"test_bool\", false, \"bool value\")\n+\ttest_int      = Int(\"test_int\", 0, \"int value\")\n+\ttest_int64    = Int64(\"test_int64\", 0, \"int64 value\")\n+\ttest_uint     = Uint(\"test_uint\", 0, \"uint value\")\n+\ttest_uint64   = Uint64(\"test_uint64\", 0, \"uint64 value\")\n+\ttest_string   = String(\"test_string\", \"0\", \"string value\")\n+\ttest_float64  = Float64(\"test_float64\", 0, \"float64 value\")\n+\ttest_duration = Duration(\"test_duration\", 0, \"time.Duration value\")\n )\n \n func boolString(s string) string {\n@@ -41,14 +43,16 @@ func TestEverything(t *testing.T) {\n \t\t\t\tok = true\n \t\t\tcase f.Name == \"test_bool\" && f.Value.String() == boolString(desired):\n \t\t\t\tok = true\n+\t\t\tcase f.Name == \"test_duration\" && f.Value.String() == desired+\"s\":\n+\t\t\t\tok = true\n \t\t\t}\n \t\t\tif !ok {\n \t\t\t\tt.Error(\"Visit: bad value\", f.Value.String(), \"for\", f.Name)\n \t\t\t}\n \t\t}\n \t}\n \tVisitAll(visitor)\n-\tif len(m) != 7 {\n+\tif len(m) != 8 {\n \t\tt.Error(\"VisitAll misses some flags\")\n \t\tfor k, v := range m {\n \t\t\tt.Log(k, *v)\n@@ -70,9 +74,10 @@ func TestEverything(t *testing.T) {\n \tSet(\"test_uint64\", \"1\")\n \tSet(\"test_string\", \"1\")\n \tSet(\"test_float64\", \"1\")\n+\tSet(\"test_duration\", \"1s\")\n \tdesired = \"1\"\n \tVisit(visitor)\n-\tif len(m) != 7 {\n+\tif len(m) != 8 {\n \t\tt.Error(\"Visit fails after set\")\n \t\tfor k, v := range m {\n \t\t\tt.Log(k, *v)\n@@ -109,6 +114,7 @@ func testParse(f *FlagSet, t *testing.T) {\n \tuint64Flag := f.Uint64(\"uint64\", 0, \"uint64 value\")\n \tstringFlag := f.String(\"string\", \"0\", \"string value\")\n \tfloat64Flag := f.Float64(\"float64\", 0, \"float64 value\")\n+\tdurationFlag := f.Duration(\"duration\", 5*time.Second, \"time.Duration value\")\n \textra := \"one-extra-argument\"\n \targs := []string{\n \t\t\"-bool\",\n@@ -119,6 +125,7 @@ func testParse(f *FlagSet, t *testing.T) {\n \t\t\"--uint64\", \"25\",\n \t\t\"-string\", \"hello\",\n \t\t\"-float64\", \"2718e28\",\n+\t\t\"-duration\", \"2m\",\n \t\textra,\n \t}\n \tif err := f.Parse(args); err != nil {\n@@ -151,6 +158,9 @@ func testParse(f *FlagSet, t *testing.T) {\n \tif *float64Flag != 2718e28 {\n \t\tt.Error(\"float64 flag should be 2718e28, is \", *float64Flag)\n \t}\n+\tif *durationFlag != 2*time.Minute {\n+\t\tt.Error(\"duration flag should be 2m, is \", *durationFlag)\n+\t}\n \tif len(f.Args()) != 1 {\n \t\tt.Error(\"expected one argument, got\", len(f.Args()))\n \t} else if f.Args()[0] != extra {\n@@ -174,9 +184,9 @@ func (f *flagVar) String() string {\n \treturn fmt.Sprint([]string(*f))\n }\n \n-func (f *flagVar) Set(value string) bool {\n+func (f *flagVar) Set(value string) error {\n \t*f = append(*f, value)\n-\treturn true\n+\treturn nil\n }\n \n func TestUserDefined(t *testing.T) {"}, {"sha": "7d4178da768bc91609e367b77c227e251933bc06", "filename": "libgo/go/fmt/doc.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ffmt%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ffmt%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Fdoc.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -30,8 +30,9 @@\n \t\t%X\tbase 16, with upper-case letters for A-F\n \t\t%U\tUnicode format: U+1234; same as \"U+%04X\"\n \tFloating-point and complex constituents:\n-\t\t%b\tdecimalless scientific notation with exponent a power\n-\t\t\tof two, in the manner of strconv.Ftoa32, e.g. -123456p-78\n+\t\t%b\tdecimalless scientific notation with exponent a power of two, \n+\t\t\tin the manner of strconv.FormatFloat with the 'b' format, \n+\t\t\te.g. -123456p-78\n \t\t%e\tscientific notation, e.g. -1234.456e+78\n \t\t%E\tscientific notation, e.g. -1234.456E+78\n \t\t%f\tdecimal point but no exponent, e.g. 123.456"}, {"sha": "beb410fa117fd94172a8160e0741eaacb7e64cbc", "filename": "libgo/go/fmt/fmt_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ffmt%2Ffmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ffmt%2Ffmt_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -517,7 +517,7 @@ var mallocTest = []struct {\n \t{1, `Sprintf(\"xxx\")`, func() { Sprintf(\"xxx\") }},\n \t{1, `Sprintf(\"%x\")`, func() { Sprintf(\"%x\", 7) }},\n \t{2, `Sprintf(\"%s\")`, func() { Sprintf(\"%s\", \"hello\") }},\n-\t{1, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x\", 7, 112) }},\n+\t{1, `Sprintf(\"%x %x\")`, func() { Sprintf(\"%x %x\", 7, 112) }},\n \t{1, `Sprintf(\"%g\")`, func() { Sprintf(\"%g\", 3.14159) }},\n \t{0, `Fprintf(buf, \"%x %x %x\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%x %x %x\", 7, 8, 9) }},\n \t{1, `Fprintf(buf, \"%s\")`, func() { mallocBuf.Reset(); Fprintf(&mallocBuf, \"%s\", \"hello\") }},"}, {"sha": "7123fe58f50b40aefa16b4571bb1d809b1d158b1", "filename": "libgo/go/go/ast/ast.go", "status": "modified", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fast.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,6 +9,7 @@ package ast\n \n import (\n \t\"go/token\"\n+\t\"strings\"\n \t\"unicode\"\n \t\"unicode/utf8\"\n )\n@@ -76,6 +77,74 @@ type CommentGroup struct {\n func (g *CommentGroup) Pos() token.Pos { return g.List[0].Pos() }\n func (g *CommentGroup) End() token.Pos { return g.List[len(g.List)-1].End() }\n \n+func isWhitespace(ch byte) bool { return ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r' }\n+\n+func stripTrailingWhitespace(s string) string {\n+\ti := len(s)\n+\tfor i > 0 && isWhitespace(s[i-1]) {\n+\t\ti--\n+\t}\n+\treturn s[0:i]\n+}\n+\n+// Text returns the text of the comment,\n+// with the comment markers - //, /*, and */ - removed.\n+func (g *CommentGroup) Text() string {\n+\tif g == nil {\n+\t\treturn \"\"\n+\t}\n+\tcomments := make([]string, len(g.List))\n+\tfor i, c := range g.List {\n+\t\tcomments[i] = string(c.Text)\n+\t}\n+\n+\tlines := make([]string, 0, 10) // most comments are less than 10 lines\n+\tfor _, c := range comments {\n+\t\t// Remove comment markers.\n+\t\t// The parser has given us exactly the comment text.\n+\t\tswitch c[1] {\n+\t\tcase '/':\n+\t\t\t//-style comment\n+\t\t\tc = c[2:]\n+\t\t\t// Remove leading space after //, if there is one.\n+\t\t\t// TODO(gri) This appears to be necessary in isolated\n+\t\t\t//           cases (bignum.RatFromString) - why?\n+\t\t\tif len(c) > 0 && c[0] == ' ' {\n+\t\t\t\tc = c[1:]\n+\t\t\t}\n+\t\tcase '*':\n+\t\t\t/*-style comment */\n+\t\t\tc = c[2 : len(c)-2]\n+\t\t}\n+\n+\t\t// Split on newlines.\n+\t\tcl := strings.Split(c, \"\\n\")\n+\n+\t\t// Walk lines, stripping trailing white space and adding to list.\n+\t\tfor _, l := range cl {\n+\t\t\tlines = append(lines, stripTrailingWhitespace(l))\n+\t\t}\n+\t}\n+\n+\t// Remove leading blank lines; convert runs of\n+\t// interior blank lines to a single blank line.\n+\tn := 0\n+\tfor _, line := range lines {\n+\t\tif line != \"\" || n > 0 && lines[n-1] != \"\" {\n+\t\t\tlines[n] = line\n+\t\t\tn++\n+\t\t}\n+\t}\n+\tlines = lines[0:n]\n+\n+\t// Add final \"\" entry to get trailing newline from Join.\n+\tif n > 0 && lines[n-1] != \"\" {\n+\t\tlines = append(lines, \"\")\n+\t}\n+\n+\treturn strings.Join(lines, \"\\n\")\n+}\n+\n // ----------------------------------------------------------------------------\n // Expressions and types\n "}, {"sha": "4a89b89096a04dece08010a39929616f699867ba", "filename": "libgo/go/go/ast/filter.go", "status": "modified", "additions": 22, "deletions": 11, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Ffilter.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -4,7 +4,10 @@\n \n package ast\n \n-import \"go/token\"\n+import (\n+\t\"go/token\"\n+\t\"sort\"\n+)\n \n // ----------------------------------------------------------------------------\n // Export filtering\n@@ -20,7 +23,7 @@ func exportFilter(name string) bool {\n // body) are removed. Non-exported fields and methods of exported types are\n // stripped. The File.Comments list is not changed.\n //\n-// FileExports returns true if there are exported declarationa;\n+// FileExports returns true if there are exported declarations;\n // it returns false otherwise.\n //\n func FileExports(src *File) bool {\n@@ -291,29 +294,35 @@ var separator = &Comment{noPos, \"//\"}\n //\n func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \t// Count the number of package docs, comments and declarations across\n-\t// all package files.\n+\t// all package files. Also, compute sorted list of filenames, so that\n+\t// subsequent iterations can always iterate in the same order.\n \tndocs := 0\n \tncomments := 0\n \tndecls := 0\n-\tfor _, f := range pkg.Files {\n+\tfilenames := make([]string, len(pkg.Files))\n+\ti := 0\n+\tfor filename, f := range pkg.Files {\n+\t\tfilenames[i] = filename\n+\t\ti++\n \t\tif f.Doc != nil {\n \t\t\tndocs += len(f.Doc.List) + 1 // +1 for separator\n \t\t}\n \t\tncomments += len(f.Comments)\n \t\tndecls += len(f.Decls)\n \t}\n+\tsort.Strings(filenames)\n \n \t// Collect package comments from all package files into a single\n-\t// CommentGroup - the collected package documentation. The order\n-\t// is unspecified. In general there should be only one file with\n-\t// a package comment; but it's better to collect extra comments\n-\t// than drop them on the floor.\n+\t// CommentGroup - the collected package documentation. In general\n+\t// there should be only one file with a package comment; but it's\n+\t// better to collect extra comments than drop them on the floor.\n \tvar doc *CommentGroup\n \tvar pos token.Pos\n \tif ndocs > 0 {\n \t\tlist := make([]*Comment, ndocs-1) // -1: no separator before first group\n \t\ti := 0\n-\t\tfor _, f := range pkg.Files {\n+\t\tfor _, filename := range filenames {\n+\t\t\tf := pkg.Files[filename]\n \t\t\tif f.Doc != nil {\n \t\t\t\tif i > 0 {\n \t\t\t\t\t// not the first group - add separator\n@@ -342,7 +351,8 @@ func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \t\tfuncs := make(map[string]int) // map of global function name -> decls index\n \t\ti := 0                        // current index\n \t\tn := 0                        // number of filtered entries\n-\t\tfor _, f := range pkg.Files {\n+\t\tfor _, filename := range filenames {\n+\t\t\tf := pkg.Files[filename]\n \t\t\tfor _, d := range f.Decls {\n \t\t\t\tif mode&FilterFuncDuplicates != 0 {\n \t\t\t\t\t// A language entity may be declared multiple\n@@ -398,7 +408,8 @@ func MergePackageFiles(pkg *Package, mode MergeMode) *File {\n \tvar imports []*ImportSpec\n \tif mode&FilterImportDuplicates != 0 {\n \t\tseen := make(map[string]bool)\n-\t\tfor _, f := range pkg.Files {\n+\t\tfor _, filename := range filenames {\n+\t\t\tf := pkg.Files[filename]\n \t\t\tfor _, imp := range f.Imports {\n \t\t\t\tif path := imp.Path.Value; !seen[path] {\n \t\t\t\t\t// TODO: consider handling cases where:"}, {"sha": "f6c63c0d8895611b1713ca1c306682ea635dfde1", "filename": "libgo/go/go/ast/print.go", "status": "modified", "additions": 10, "deletions": 14, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fprint.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -36,7 +36,7 @@ func NotNilFilter(_ string, v reflect.Value) bool {\n // struct fields for which f(fieldname, fieldvalue) is true are\n // are printed; all others are filtered from the output.\n //\n-func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n int, err error) {\n+func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (err error) {\n \t// setup printer\n \tp := printer{\n \t\toutput: w,\n@@ -48,7 +48,6 @@ func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n i\n \n \t// install error handler\n \tdefer func() {\n-\t\tn = p.written\n \t\tif e := recover(); e != nil {\n \t\t\terr = e.(localError).err // re-panics if it's not a localError\n \t\t}\n@@ -67,19 +66,18 @@ func Fprint(w io.Writer, fset *token.FileSet, x interface{}, f FieldFilter) (n i\n \n // Print prints x to standard output, skipping nil fields.\n // Print(fset, x) is the same as Fprint(os.Stdout, fset, x, NotNilFilter).\n-func Print(fset *token.FileSet, x interface{}) (int, error) {\n+func Print(fset *token.FileSet, x interface{}) error {\n \treturn Fprint(os.Stdout, fset, x, NotNilFilter)\n }\n \n type printer struct {\n-\toutput  io.Writer\n-\tfset    *token.FileSet\n-\tfilter  FieldFilter\n-\tptrmap  map[interface{}]int // *T -> line number\n-\twritten int                 // number of bytes written to output\n-\tindent  int                 // current indentation level\n-\tlast    byte                // the last byte processed by Write\n-\tline    int                 // current line number\n+\toutput io.Writer\n+\tfset   *token.FileSet\n+\tfilter FieldFilter\n+\tptrmap map[interface{}]int // *T -> line number\n+\tindent int                 // current indentation level\n+\tlast   byte                // the last byte processed by Write\n+\tline   int                 // current line number\n }\n \n var indent = []byte(\".  \")\n@@ -122,9 +120,7 @@ type localError struct {\n \n // printf is a convenience wrapper that takes care of print errors.\n func (p *printer) printf(format string, args ...interface{}) {\n-\tn, err := fmt.Fprintf(p, format, args...)\n-\tp.written += n\n-\tif err != nil {\n+\tif _, err := fmt.Fprintf(p, format, args...); err != nil {\n \t\tpanic(localError{err})\n \t}\n }"}, {"sha": "71c028e753787e4b322c8ab629cb04b115677623", "filename": "libgo/go/go/ast/print_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fprint_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -66,7 +66,7 @@ func TestPrint(t *testing.T) {\n \tvar buf bytes.Buffer\n \tfor _, test := range tests {\n \t\tbuf.Reset()\n-\t\tif _, err := Fprint(&buf, nil, test.x, nil); err != nil {\n+\t\tif err := Fprint(&buf, nil, test.x, nil); err != nil {\n \t\t\tt.Errorf(\"Fprint failed: %s\", err)\n \t\t}\n \t\tif s, ts := trim(buf.String()), trim(test.s); s != ts {"}, {"sha": "11e6b13f169b807095b0ee40abe76a7b296c66d5", "filename": "libgo/go/go/ast/scope.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fast%2Fscope.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fast%2Fscope.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -80,7 +80,7 @@ func (s *Scope) String() string {\n type Object struct {\n \tKind ObjKind\n \tName string      // declared name\n-\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, or AssignStmt; or nil\n+\tDecl interface{} // corresponding Field, XxxSpec, FuncDecl, LabeledStmt, AssignStmt, Scope; or nil\n \tData interface{} // object-specific data; or nil\n \tType interface{} // place holder for type information; may be nil\n }\n@@ -131,6 +131,8 @@ func (obj *Object) Pos() token.Pos {\n \t\t\t\treturn ident.Pos()\n \t\t\t}\n \t\t}\n+\tcase *Scope:\n+\t\t// predeclared object - nothing to do for now\n \t}\n \treturn token.NoPos\n }"}, {"sha": "9515a7e645224f41d032ad227e0ff4e4cf89ad1f", "filename": "libgo/go/go/build/build.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fbuild.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -396,8 +396,7 @@ func (b *build) cgo(cgofiles, cgocfiles []string) (outGo, outObj []string) {\n \t\tOutput: output,\n \t})\n \toutGo = append(outGo, gofiles...)\n-\texportH := filepath.Join(b.path, \"_cgo_export.h\")\n-\tb.script.addIntermediate(defunC, exportH, b.obj+\"_cgo_flags\")\n+\tb.script.addIntermediate(defunC, b.obj+\"_cgo_export.h\", b.obj+\"_cgo_flags\")\n \tb.script.addIntermediate(cfiles...)\n \n \t// cc _cgo_defun.c"}, {"sha": "5ce75fda7e08d38e5f9afdd2359484bef8cfea7d", "filename": "libgo/go/go/build/dir.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fdir.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,7 +9,6 @@ import (\n \t\"errors\"\n \t\"fmt\"\n \t\"go/ast\"\n-\t\"go/doc\"\n \t\"go/parser\"\n \t\"go/token\"\n \t\"io/ioutil\"\n@@ -412,7 +411,7 @@ func (ctxt *Context) shouldBuild(content []byte) bool {\n // TODO(rsc): This duplicates code in cgo.\n // Once the dust settles, remove this code from cgo.\n func (ctxt *Context) saveCgo(filename string, di *DirInfo, cg *ast.CommentGroup) error {\n-\ttext := doc.CommentText(cg)\n+\ttext := cg.Text()\n \tfor _, line := range strings.Split(text, \"\\n\") {\n \t\torig := line\n \n@@ -476,7 +475,7 @@ func (ctxt *Context) saveCgo(filename string, di *DirInfo, cg *ast.CommentGroup)\n \treturn nil\n }\n \n-var safeBytes = []byte(\"+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz\")\n+var safeBytes = []byte(\"+-.,/0123456789=ABCDEFGHIJKLMNOPQRSTUVWXYZ_abcdefghijklmnopqrstuvwxyz:\")\n \n func safeName(s string) bool {\n \tif s == \"\" {"}, {"sha": "bb9b8ca642a123f8a63b2c4d19ada8760d43ddf1", "filename": "libgo/go/go/build/path.go", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fbuild%2Fpath.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -157,6 +157,7 @@ func init() {\n \t\tPath = []*Tree{t}\n \t}\n \n+Loop:\n \tfor _, p := range filepath.SplitList(os.Getenv(\"GOPATH\")) {\n \t\tif p == \"\" {\n \t\t\tcontinue\n@@ -166,6 +167,21 @@ func init() {\n \t\t\tlog.Printf(\"invalid GOPATH %q: %v\", p, err)\n \t\t\tcontinue\n \t\t}\n+\n+\t\t// Check for dupes.\n+\t\t// TODO(alexbrainman): make this correct under windows (case insensitive).\n+\t\tfor _, t2 := range Path {\n+\t\t\tif t2.Path != t.Path {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tif t2.Goroot {\n+\t\t\t\tlog.Printf(\"GOPATH is the same as GOROOT: %q\", t.Path)\n+\t\t\t} else {\n+\t\t\t\tlog.Printf(\"duplicate GOPATH entry: %q\", t.Path)\n+\t\t\t}\n+\t\t\tcontinue Loop\n+\t\t}\n+\n \t\tPath = append(Path, t)\n \t\tgcImportArgs = append(gcImportArgs, \"-I\", t.PkgDir())\n \t\tldImportArgs = append(ldImportArgs, \"-L\", t.PkgDir())"}, {"sha": "060e37bff148d21b2c9c4ab313c4276ee3b80866", "filename": "libgo/go/go/doc/comment.go", "status": "modified", "additions": 2, "deletions": 73, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fcomment.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,7 +7,6 @@\n package doc\n \n import (\n-\t\"go/ast\"\n \t\"io\"\n \t\"regexp\"\n \t\"strings\"\n@@ -16,74 +15,6 @@ import (\n \t\"unicode/utf8\"\n )\n \n-func isWhitespace(ch byte) bool { return ch == ' ' || ch == '\\t' || ch == '\\n' || ch == '\\r' }\n-\n-func stripTrailingWhitespace(s string) string {\n-\ti := len(s)\n-\tfor i > 0 && isWhitespace(s[i-1]) {\n-\t\ti--\n-\t}\n-\treturn s[0:i]\n-}\n-\n-// CommentText returns the text of comment,\n-// with the comment markers - //, /*, and */ - removed.\n-func CommentText(comment *ast.CommentGroup) string {\n-\tif comment == nil {\n-\t\treturn \"\"\n-\t}\n-\tcomments := make([]string, len(comment.List))\n-\tfor i, c := range comment.List {\n-\t\tcomments[i] = string(c.Text)\n-\t}\n-\n-\tlines := make([]string, 0, 10) // most comments are less than 10 lines\n-\tfor _, c := range comments {\n-\t\t// Remove comment markers.\n-\t\t// The parser has given us exactly the comment text.\n-\t\tswitch c[1] {\n-\t\tcase '/':\n-\t\t\t//-style comment\n-\t\t\tc = c[2:]\n-\t\t\t// Remove leading space after //, if there is one.\n-\t\t\t// TODO(gri) This appears to be necessary in isolated\n-\t\t\t//           cases (bignum.RatFromString) - why?\n-\t\t\tif len(c) > 0 && c[0] == ' ' {\n-\t\t\t\tc = c[1:]\n-\t\t\t}\n-\t\tcase '*':\n-\t\t\t/*-style comment */\n-\t\t\tc = c[2 : len(c)-2]\n-\t\t}\n-\n-\t\t// Split on newlines.\n-\t\tcl := strings.Split(c, \"\\n\")\n-\n-\t\t// Walk lines, stripping trailing white space and adding to list.\n-\t\tfor _, l := range cl {\n-\t\t\tlines = append(lines, stripTrailingWhitespace(l))\n-\t\t}\n-\t}\n-\n-\t// Remove leading blank lines; convert runs of\n-\t// interior blank lines to a single blank line.\n-\tn := 0\n-\tfor _, line := range lines {\n-\t\tif line != \"\" || n > 0 && lines[n-1] != \"\" {\n-\t\t\tlines[n] = line\n-\t\t\tn++\n-\t\t}\n-\t}\n-\tlines = lines[0:n]\n-\n-\t// Add final \"\" entry to get trailing newline from Join.\n-\tif n > 0 && lines[n-1] != \"\" {\n-\t\tlines = append(lines, \"\")\n-\t}\n-\n-\treturn strings.Join(lines, \"\\n\")\n-}\n-\n var (\n \tldquo = []byte(\"&ldquo;\")\n \trdquo = []byte(\"&rdquo;\")\n@@ -422,12 +353,10 @@ func ToText(w io.Writer, text string, indent, preIndent string, width int) {\n \t\twidth:  width,\n \t\tindent: indent,\n \t}\n-\tfor i, b := range blocks(text) {\n+\tfor _, b := range blocks(text) {\n \t\tswitch b.op {\n \t\tcase opPara:\n-\t\t\tif i > 0 {\n-\t\t\t\tw.Write(nl)\n-\t\t\t}\n+\t\t\t// l.write will add leading newline if required\n \t\t\tfor _, line := range b.lines {\n \t\t\t\tl.write(line)\n \t\t\t}"}, {"sha": "66e2937aeb0405107fcde6e190dc335353d9ae13", "filename": "libgo/go/go/doc/doc.go", "status": "modified", "additions": 64, "deletions": 643, "changes": 707, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,673 +7,94 @@ package doc\n \n import (\n \t\"go/ast\"\n-\t\"go/token\"\n-\t\"regexp\"\n \t\"sort\"\n )\n \n-// ----------------------------------------------------------------------------\n-// Collection of documentation info\n-\n-// embeddedType describes the type of an anonymous field.\n-//\n-type embeddedType struct {\n-\ttyp *typeInfo // the corresponding base type\n-\tptr bool      // if set, the anonymous field type is a pointer\n-}\n-\n-type typeInfo struct {\n-\t// len(decl.Specs) == 1, and the element type is *ast.TypeSpec\n-\t// if the type declaration hasn't been seen yet, decl is nil\n-\tdecl     *ast.GenDecl\n-\tembedded []embeddedType\n-\tforward  *TypeDoc // forward link to processed type documentation\n-\n-\t// declarations associated with the type\n-\tvalues    []*ast.GenDecl // consts and vars\n-\tfactories map[string]*ast.FuncDecl\n-\tmethods   map[string]*ast.FuncDecl\n-}\n-\n-func (info *typeInfo) addEmbeddedType(embedded *typeInfo, isPtr bool) {\n-\tinfo.embedded = append(info.embedded, embeddedType{embedded, isPtr})\n-}\n-\n-// docReader accumulates documentation for a single package.\n-// It modifies the AST: Comments (declaration documentation)\n-// that have been collected by the DocReader are set to nil\n-// in the respective AST nodes so that they are not printed\n-// twice (once when printing the documentation and once when\n-// printing the corresponding AST node).\n-//\n-type docReader struct {\n-\tdoc      *ast.CommentGroup // package documentation, if any\n-\tpkgName  string\n-\tvalues   []*ast.GenDecl // consts and vars\n-\ttypes    map[string]*typeInfo\n-\tembedded map[string]*typeInfo // embedded types, possibly not exported\n-\tfuncs    map[string]*ast.FuncDecl\n-\tbugs     []*ast.CommentGroup\n-}\n-\n-func (doc *docReader) init(pkgName string) {\n-\tdoc.pkgName = pkgName\n-\tdoc.types = make(map[string]*typeInfo)\n-\tdoc.embedded = make(map[string]*typeInfo)\n-\tdoc.funcs = make(map[string]*ast.FuncDecl)\n-}\n-\n-func (doc *docReader) addDoc(comments *ast.CommentGroup) {\n-\tif doc.doc == nil {\n-\t\t// common case: just one package comment\n-\t\tdoc.doc = comments\n-\t\treturn\n-\t}\n-\t// More than one package comment: Usually there will be only\n-\t// one file with a package comment, but it's better to collect\n-\t// all comments than drop them on the floor.\n-\tblankComment := &ast.Comment{token.NoPos, \"//\"}\n-\tlist := append(doc.doc.List, blankComment)\n-\tdoc.doc.List = append(list, comments.List...)\n-}\n-\n-func (doc *docReader) lookupTypeInfo(name string) *typeInfo {\n-\tif name == \"\" || name == \"_\" {\n-\t\treturn nil // no type docs for anonymous types\n-\t}\n-\tif info, found := doc.types[name]; found {\n-\t\treturn info\n-\t}\n-\t// type wasn't found - add one without declaration\n-\tinfo := &typeInfo{\n-\t\tfactories: make(map[string]*ast.FuncDecl),\n-\t\tmethods:   make(map[string]*ast.FuncDecl),\n-\t}\n-\tdoc.types[name] = info\n-\treturn info\n-}\n-\n-func baseTypeName(typ ast.Expr, allTypes bool) string {\n-\tswitch t := typ.(type) {\n-\tcase *ast.Ident:\n-\t\t// if the type is not exported, the effect to\n-\t\t// a client is as if there were no type name\n-\t\tif t.IsExported() || allTypes {\n-\t\t\treturn t.Name\n-\t\t}\n-\tcase *ast.StarExpr:\n-\t\treturn baseTypeName(t.X, allTypes)\n-\t}\n-\treturn \"\"\n-}\n-\n-func (doc *docReader) addValue(decl *ast.GenDecl) {\n-\t// determine if decl should be associated with a type\n-\t// Heuristic: For each typed entry, determine the type name, if any.\n-\t//            If there is exactly one type name that is sufficiently\n-\t//            frequent, associate the decl with the respective type.\n-\tdomName := \"\"\n-\tdomFreq := 0\n-\tprev := \"\"\n-\tfor _, s := range decl.Specs {\n-\t\tif v, ok := s.(*ast.ValueSpec); ok {\n-\t\t\tname := \"\"\n-\t\t\tswitch {\n-\t\t\tcase v.Type != nil:\n-\t\t\t\t// a type is present; determine its name\n-\t\t\t\tname = baseTypeName(v.Type, false)\n-\t\t\tcase decl.Tok == token.CONST:\n-\t\t\t\t// no type is present but we have a constant declaration;\n-\t\t\t\t// use the previous type name (w/o more type information\n-\t\t\t\t// we cannot handle the case of unnamed variables with\n-\t\t\t\t// initializer expressions except for some trivial cases)\n-\t\t\t\tname = prev\n-\t\t\t}\n-\t\t\tif name != \"\" {\n-\t\t\t\t// entry has a named type\n-\t\t\t\tif domName != \"\" && domName != name {\n-\t\t\t\t\t// more than one type name - do not associate\n-\t\t\t\t\t// with any type\n-\t\t\t\t\tdomName = \"\"\n-\t\t\t\t\tbreak\n-\t\t\t\t}\n-\t\t\t\tdomName = name\n-\t\t\t\tdomFreq++\n-\t\t\t}\n-\t\t\tprev = name\n-\t\t}\n-\t}\n-\n-\t// determine values list\n-\tconst threshold = 0.75\n-\tvalues := &doc.values\n-\tif domName != \"\" && domFreq >= int(float64(len(decl.Specs))*threshold) {\n-\t\t// typed entries are sufficiently frequent\n-\t\ttyp := doc.lookupTypeInfo(domName)\n-\t\tif typ != nil {\n-\t\t\tvalues = &typ.values // associate with that type\n-\t\t}\n-\t}\n-\n-\t*values = append(*values, decl)\n-}\n-\n-// Helper function to set the table entry for function f. Makes sure that\n-// at least one f with associated documentation is stored in table, if there\n-// are multiple f's with the same name.\n-func setFunc(table map[string]*ast.FuncDecl, f *ast.FuncDecl) {\n-\tname := f.Name.Name\n-\tif g, exists := table[name]; exists && g.Doc != nil {\n-\t\t// a function with the same name has already been registered;\n-\t\t// since it has documentation, assume f is simply another\n-\t\t// implementation and ignore it\n-\t\t// TODO(gri) consider collecting all functions, or at least\n-\t\t//           all comments\n-\t\treturn\n-\t}\n-\t// function doesn't exist or has no documentation; use f\n-\ttable[name] = f\n-}\n-\n-func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n-\t// strip function body\n-\tfun.Body = nil\n-\n-\t// determine if it should be associated with a type\n-\tif fun.Recv != nil {\n-\t\t// method\n-\t\ttyp := doc.lookupTypeInfo(baseTypeName(fun.Recv.List[0].Type, false))\n-\t\tif typ != nil {\n-\t\t\t// exported receiver type\n-\t\t\tsetFunc(typ.methods, fun)\n-\t\t}\n-\t\t// otherwise don't show the method\n-\t\t// TODO(gri): There may be exported methods of non-exported types\n-\t\t// that can be called because of exported values (consts, vars, or\n-\t\t// function results) of that type. Could determine if that is the\n-\t\t// case and then show those methods in an appropriate section.\n-\t\treturn\n-\t}\n-\n-\t// perhaps a factory function\n-\t// determine result type, if any\n-\tif fun.Type.Results.NumFields() >= 1 {\n-\t\tres := fun.Type.Results.List[0]\n-\t\tif len(res.Names) <= 1 {\n-\t\t\t// exactly one (named or anonymous) result associated\n-\t\t\t// with the first type in result signature (there may\n-\t\t\t// be more than one result)\n-\t\t\ttname := baseTypeName(res.Type, false)\n-\t\t\ttyp := doc.lookupTypeInfo(tname)\n-\t\t\tif typ != nil {\n-\t\t\t\t// named and exported result type\n-\t\t\t\tsetFunc(typ.factories, fun)\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// ordinary function\n-\tsetFunc(doc.funcs, fun)\n-}\n-\n-func (doc *docReader) addDecl(decl ast.Decl) {\n-\tswitch d := decl.(type) {\n-\tcase *ast.GenDecl:\n-\t\tif len(d.Specs) > 0 {\n-\t\t\tswitch d.Tok {\n-\t\t\tcase token.CONST, token.VAR:\n-\t\t\t\t// constants and variables are always handled as a group\n-\t\t\t\tdoc.addValue(d)\n-\t\t\tcase token.TYPE:\n-\t\t\t\t// types are handled individually\n-\t\t\t\tfor _, spec := range d.Specs {\n-\t\t\t\t\ttspec := spec.(*ast.TypeSpec)\n-\t\t\t\t\t// add the type to the documentation\n-\t\t\t\t\tinfo := doc.lookupTypeInfo(tspec.Name.Name)\n-\t\t\t\t\tif info == nil {\n-\t\t\t\t\t\tcontinue // no name - ignore the type\n-\t\t\t\t\t}\n-\t\t\t\t\t// Make a (fake) GenDecl node for this TypeSpec\n-\t\t\t\t\t// (we need to do this here - as opposed to just\n-\t\t\t\t\t// for printing - so we don't lose the GenDecl\n-\t\t\t\t\t// documentation). Since a new GenDecl node is\n-\t\t\t\t\t// created, there's no need to nil out d.Doc.\n-\t\t\t\t\t//\n-\t\t\t\t\t// TODO(gri): Consider just collecting the TypeSpec\n-\t\t\t\t\t// node (and copy in the GenDecl.doc if there is no\n-\t\t\t\t\t// doc in the TypeSpec - this is currently done in\n-\t\t\t\t\t// makeTypeDocs below). Simpler data structures, but\n-\t\t\t\t\t// would lose GenDecl documentation if the TypeSpec\n-\t\t\t\t\t// has documentation as well.\n-\t\t\t\t\tfake := &ast.GenDecl{d.Doc, d.Pos(), token.TYPE, token.NoPos,\n-\t\t\t\t\t\t[]ast.Spec{tspec}, token.NoPos}\n-\t\t\t\t\t// A type should be added at most once, so info.decl\n-\t\t\t\t\t// should be nil - if it isn't, simply overwrite it.\n-\t\t\t\t\tinfo.decl = fake\n-\t\t\t\t\t// Look for anonymous fields that might contribute methods.\n-\t\t\t\t\tvar fields *ast.FieldList\n-\t\t\t\t\tswitch typ := spec.(*ast.TypeSpec).Type.(type) {\n-\t\t\t\t\tcase *ast.StructType:\n-\t\t\t\t\t\tfields = typ.Fields\n-\t\t\t\t\tcase *ast.InterfaceType:\n-\t\t\t\t\t\tfields = typ.Methods\n-\t\t\t\t\t}\n-\t\t\t\t\tif fields != nil {\n-\t\t\t\t\t\tfor _, field := range fields.List {\n-\t\t\t\t\t\t\tif len(field.Names) == 0 {\n-\t\t\t\t\t\t\t\t// anonymous field - add corresponding type\n-\t\t\t\t\t\t\t\t// to the info and collect it in doc\n-\t\t\t\t\t\t\t\tname := baseTypeName(field.Type, true)\n-\t\t\t\t\t\t\t\tif embedded := doc.lookupTypeInfo(name); embedded != nil {\n-\t\t\t\t\t\t\t\t\t_, ptr := field.Type.(*ast.StarExpr)\n-\t\t\t\t\t\t\t\t\tinfo.addEmbeddedType(embedded, ptr)\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\tcase *ast.FuncDecl:\n-\t\tdoc.addFunc(d)\n-\t}\n-}\n-\n-func copyCommentList(list []*ast.Comment) []*ast.Comment {\n-\treturn append([]*ast.Comment(nil), list...)\n-}\n-\n-var (\n-\tbug_markers = regexp.MustCompile(\"^/[/*][ \\t]*BUG\\\\(.*\\\\):[ \\t]*\") // BUG(uid):\n-\tbug_content = regexp.MustCompile(\"[^ \\n\\r\\t]+\")                    // at least one non-whitespace char\n-)\n-\n-// addFile adds the AST for a source file to the docReader.\n-// Adding the same AST multiple times is a no-op.\n-//\n-func (doc *docReader) addFile(src *ast.File) {\n-\t// add package documentation\n-\tif src.Doc != nil {\n-\t\tdoc.addDoc(src.Doc)\n-\t\tsrc.Doc = nil // doc consumed - remove from ast.File node\n-\t}\n-\n-\t// add all declarations\n-\tfor _, decl := range src.Decls {\n-\t\tdoc.addDecl(decl)\n-\t}\n-\n-\t// collect BUG(...) comments\n-\tfor _, c := range src.Comments {\n-\t\ttext := c.List[0].Text\n-\t\tif m := bug_markers.FindStringIndex(text); m != nil {\n-\t\t\t// found a BUG comment; maybe empty\n-\t\t\tif btxt := text[m[1]:]; bug_content.MatchString(btxt) {\n-\t\t\t\t// non-empty BUG comment; collect comment without BUG prefix\n-\t\t\t\tlist := copyCommentList(c.List)\n-\t\t\t\tlist[0].Text = text[m[1]:]\n-\t\t\t\tdoc.bugs = append(doc.bugs, &ast.CommentGroup{list})\n-\t\t\t}\n-\t\t}\n-\t}\n-\tsrc.Comments = nil // consumed unassociated comments - remove from ast.File node\n-}\n-\n-func NewPackageDoc(pkg *ast.Package, importpath string, exportsOnly bool) *PackageDoc {\n-\tvar r docReader\n-\tr.init(pkg.Name)\n-\tfilenames := make([]string, len(pkg.Files))\n-\ti := 0\n-\tfor filename, f := range pkg.Files {\n-\t\tif exportsOnly {\n-\t\t\tr.fileExports(f)\n-\t\t}\n-\t\tr.addFile(f)\n-\t\tfilenames[i] = filename\n-\t\ti++\n-\t}\n-\treturn r.newDoc(importpath, filenames)\n-}\n-\n-// ----------------------------------------------------------------------------\n-// Conversion to external representation\n-\n-// ValueDoc is the documentation for a group of declared\n-// values, either vars or consts.\n-//\n-type ValueDoc struct {\n+// Package is the documentation for an entire package.\n+type Package struct {\n+\tDoc        string\n+\tName       string\n+\tImportPath string\n+\tImports    []string // TODO(gri) this field is not computed at the moment\n+\tFilenames  []string\n+\tConsts     []*Value\n+\tTypes      []*Type\n+\tVars       []*Value\n+\tFuncs      []*Func\n+\tBugs       []string\n+}\n+\n+// Value is the documentation for a (possibly grouped) var or const declaration.\n+type Value struct {\n \tDoc   string\n+\tNames []string // var or const names in declaration order\n \tDecl  *ast.GenDecl\n+\n \torder int\n }\n \n-type sortValueDoc []*ValueDoc\n-\n-func (p sortValueDoc) Len() int      { return len(p) }\n-func (p sortValueDoc) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n-\n-func declName(d *ast.GenDecl) string {\n-\tif len(d.Specs) != 1 {\n-\t\treturn \"\"\n-\t}\n-\n-\tswitch v := d.Specs[0].(type) {\n-\tcase *ast.ValueSpec:\n-\t\treturn v.Names[0].Name\n-\tcase *ast.TypeSpec:\n-\t\treturn v.Name.Name\n-\t}\n-\n-\treturn \"\"\n+type Method struct {\n+\t*Func\n+\t// TODO(gri) The following fields are not set at the moment. \n+\tRecv  *Type // original receiver base type\n+\tLevel int   // embedding level; 0 means Func is not embedded\n }\n \n-func (p sortValueDoc) Less(i, j int) bool {\n-\t// sort by name\n-\t// pull blocks (name = \"\") up to top\n-\t// in original order\n-\tif ni, nj := declName(p[i].Decl), declName(p[j].Decl); ni != nj {\n-\t\treturn ni < nj\n-\t}\n-\treturn p[i].order < p[j].order\n-}\n+// Type is the documentation for type declaration.\n+type Type struct {\n+\tDoc     string\n+\tName    string\n+\tType    *ast.TypeSpec\n+\tDecl    *ast.GenDecl\n+\tConsts  []*Value  // sorted list of constants of (mostly) this type\n+\tVars    []*Value  // sorted list of variables of (mostly) this type\n+\tFuncs   []*Func   // sorted list of functions returning this type\n+\tMethods []*Method // sorted list of methods (including embedded ones) of this type\n \n-func makeValueDocs(list []*ast.GenDecl, tok token.Token) []*ValueDoc {\n-\td := make([]*ValueDoc, len(list)) // big enough in any case\n-\tn := 0\n-\tfor i, decl := range list {\n-\t\tif decl.Tok == tok {\n-\t\t\td[n] = &ValueDoc{CommentText(decl.Doc), decl, i}\n-\t\t\tn++\n-\t\t\tdecl.Doc = nil // doc consumed - removed from AST\n-\t\t}\n-\t}\n-\td = d[0:n]\n-\tsort.Sort(sortValueDoc(d))\n-\treturn d\n+\tmethods  []*Func   // top-level methods only\n+\tembedded methodSet // embedded methods only\n+\torder    int\n }\n \n-// FuncDoc is the documentation for a func declaration,\n-// either a top-level function or a method function.\n-//\n-type FuncDoc struct {\n+// Func is the documentation for a func declaration.\n+type Func struct {\n \tDoc  string\n-\tRecv ast.Expr // TODO(rsc): Would like string here\n \tName string\n+\t// TODO(gri) remove Recv once we switch to new implementation\n+\tRecv ast.Expr // TODO(rsc): Would like string here\n \tDecl *ast.FuncDecl\n }\n \n-type sortFuncDoc []*FuncDoc\n+// Mode values control the operation of New.\n+type Mode int\n \n-func (p sortFuncDoc) Len() int           { return len(p) }\n-func (p sortFuncDoc) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n-func (p sortFuncDoc) Less(i, j int) bool { return p[i].Name < p[j].Name }\n-\n-func makeFuncDocs(m map[string]*ast.FuncDecl) []*FuncDoc {\n-\td := make([]*FuncDoc, len(m))\n-\ti := 0\n-\tfor _, f := range m {\n-\t\tdoc := new(FuncDoc)\n-\t\tdoc.Doc = CommentText(f.Doc)\n-\t\tf.Doc = nil // doc consumed - remove from ast.FuncDecl node\n-\t\tif f.Recv != nil {\n-\t\t\tdoc.Recv = f.Recv.List[0].Type\n-\t\t}\n-\t\tdoc.Name = f.Name.Name\n-\t\tdoc.Decl = f\n-\t\td[i] = doc\n-\t\ti++\n-\t}\n-\tsort.Sort(sortFuncDoc(d))\n-\treturn d\n-}\n-\n-type methodSet map[string]*FuncDoc\n-\n-func (mset methodSet) add(m *FuncDoc) {\n-\tif mset[m.Name] == nil {\n-\t\tmset[m.Name] = m\n-\t}\n-}\n+const (\n+\t// extract documentation for all package-level declarations,\n+\t// not just exported ones\n+\tAllDecls Mode = 1 << iota\n+)\n \n-func (mset methodSet) sortedList() []*FuncDoc {\n-\tlist := make([]*FuncDoc, len(mset))\n+// New computes the package documentation for the given package.\n+func New(pkg *ast.Package, importpath string, mode Mode) *Package {\n+\tvar r docReader\n+\tr.init(pkg.Name, mode)\n+\tfilenames := make([]string, len(pkg.Files))\n+\t// sort package files before reading them so that the\n+\t// result is the same on different machines (32/64bit)\n \ti := 0\n-\tfor _, m := range mset {\n-\t\tlist[i] = m\n+\tfor filename := range pkg.Files {\n+\t\tfilenames[i] = filename\n \t\ti++\n \t}\n-\tsort.Sort(sortFuncDoc(list))\n-\treturn list\n-}\n-\n-// TypeDoc is the documentation for a declared type.\n-// Consts and Vars are sorted lists of constants and variables of (mostly) that type.\n-// Factories is a sorted list of factory functions that return that type.\n-// Methods is a sorted list of method functions on that type.\n-type TypeDoc struct {\n-\tDoc       string\n-\tType      *ast.TypeSpec\n-\tConsts    []*ValueDoc\n-\tVars      []*ValueDoc\n-\tFactories []*FuncDoc\n-\tmethods   []*FuncDoc // top-level methods only\n-\tembedded  methodSet  // embedded methods only\n-\tMethods   []*FuncDoc // all methods including embedded ones\n-\tDecl      *ast.GenDecl\n-\torder     int\n-}\n-\n-type sortTypeDoc []*TypeDoc\n-\n-func (p sortTypeDoc) Len() int      { return len(p) }\n-func (p sortTypeDoc) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n-func (p sortTypeDoc) Less(i, j int) bool {\n-\t// sort by name\n-\t// pull blocks (name = \"\") up to top\n-\t// in original order\n-\tif ni, nj := p[i].Type.Name.Name, p[j].Type.Name.Name; ni != nj {\n-\t\treturn ni < nj\n-\t}\n-\treturn p[i].order < p[j].order\n-}\n-\n-// NOTE(rsc): This would appear not to be correct for type ( )\n-// blocks, but the doc extractor above has split them into\n-// individual declarations.\n-func (doc *docReader) makeTypeDocs(m map[string]*typeInfo) []*TypeDoc {\n-\t// TODO(gri) Consider computing the embedded method information\n-\t//           before calling makeTypeDocs. Then this function can\n-\t//           be single-phased again. Also, it might simplify some\n-\t//           of the logic.\n-\t//\n-\t// phase 1: associate collected declarations with TypeDocs\n-\tlist := make([]*TypeDoc, len(m))\n-\ti := 0\n-\tfor _, old := range m {\n-\t\t// all typeInfos should have a declaration associated with\n-\t\t// them after processing an entire package - be conservative\n-\t\t// and check\n-\t\tif decl := old.decl; decl != nil {\n-\t\t\ttypespec := decl.Specs[0].(*ast.TypeSpec)\n-\t\t\tt := new(TypeDoc)\n-\t\t\tdoc := typespec.Doc\n-\t\t\ttypespec.Doc = nil // doc consumed - remove from ast.TypeSpec node\n-\t\t\tif doc == nil {\n-\t\t\t\t// no doc associated with the spec, use the declaration doc, if any\n-\t\t\t\tdoc = decl.Doc\n-\t\t\t}\n-\t\t\tdecl.Doc = nil // doc consumed - remove from ast.Decl node\n-\t\t\tt.Doc = CommentText(doc)\n-\t\t\tt.Type = typespec\n-\t\t\tt.Consts = makeValueDocs(old.values, token.CONST)\n-\t\t\tt.Vars = makeValueDocs(old.values, token.VAR)\n-\t\t\tt.Factories = makeFuncDocs(old.factories)\n-\t\t\tt.methods = makeFuncDocs(old.methods)\n-\t\t\t// The list of embedded types' methods is computed from the list\n-\t\t\t// of embedded types, some of which may not have been processed\n-\t\t\t// yet (i.e., their forward link is nil) - do this in a 2nd phase.\n-\t\t\t// The final list of methods can only be computed after that -\n-\t\t\t// do this in a 3rd phase.\n-\t\t\tt.Decl = old.decl\n-\t\t\tt.order = i\n-\t\t\told.forward = t // old has been processed\n-\t\t\tlist[i] = t\n-\t\t\ti++\n-\t\t} else {\n-\t\t\t// no corresponding type declaration found - move any associated\n-\t\t\t// values, factory functions, and methods back to the top-level\n-\t\t\t// so that they are not lost (this should only happen if a package\n-\t\t\t// file containing the explicit type declaration is missing or if\n-\t\t\t// an unqualified type name was used after a \".\" import)\n-\t\t\t// 1) move values\n-\t\t\tdoc.values = append(doc.values, old.values...)\n-\t\t\t// 2) move factory functions\n-\t\t\tfor name, f := range old.factories {\n-\t\t\t\tdoc.funcs[name] = f\n-\t\t\t}\n-\t\t\t// 3) move methods\n-\t\t\tfor name, f := range old.methods {\n-\t\t\t\t// don't overwrite functions with the same name\n-\t\t\t\tif _, found := doc.funcs[name]; !found {\n-\t\t\t\t\tdoc.funcs[name] = f\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\tlist = list[0:i] // some types may have been ignored\n-\n-\t// phase 2: collect embedded methods for each processed typeInfo\n-\tfor _, old := range m {\n-\t\tif t := old.forward; t != nil {\n-\t\t\t// old has been processed into t; collect embedded\n-\t\t\t// methods for t from the list of processed embedded\n-\t\t\t// types in old (and thus for which the methods are known)\n-\t\t\ttyp := t.Type\n-\t\t\tif _, ok := typ.Type.(*ast.StructType); ok {\n-\t\t\t\t// struct\n-\t\t\t\tt.embedded = make(methodSet)\n-\t\t\t\tcollectEmbeddedMethods(t.embedded, old, typ.Name.Name)\n-\t\t\t} else {\n-\t\t\t\t// interface\n-\t\t\t\t// TODO(gri) fix this\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// phase 3: compute final method set for each TypeDoc\n-\tfor _, d := range list {\n-\t\tif len(d.embedded) > 0 {\n-\t\t\t// there are embedded methods - exclude\n-\t\t\t// the ones with names conflicting with\n-\t\t\t// non-embedded methods\n-\t\t\tmset := make(methodSet)\n-\t\t\t// top-level methods have priority\n-\t\t\tfor _, m := range d.methods {\n-\t\t\t\tmset.add(m)\n-\t\t\t}\n-\t\t\t// add non-conflicting embedded methods\n-\t\t\tfor _, m := range d.embedded {\n-\t\t\t\tmset.add(m)\n-\t\t\t}\n-\t\t\td.Methods = mset.sortedList()\n-\t\t} else {\n-\t\t\t// no embedded methods\n-\t\t\td.Methods = d.methods\n-\t\t}\n-\t}\n-\n-\tsort.Sort(sortTypeDoc(list))\n-\treturn list\n-}\n+\tsort.Strings(filenames)\n \n-// collectEmbeddedMethods collects the embedded methods from all\n-// processed embedded types found in info in mset. It considers\n-// embedded types at the most shallow level first so that more\n-// deeply nested embedded methods with conflicting names are\n-// excluded.\n-//\n-func collectEmbeddedMethods(mset methodSet, info *typeInfo, recvTypeName string) {\n-\tfor _, e := range info.embedded {\n-\t\tif e.typ.forward != nil { // == e was processed\n-\t\t\tfor _, m := range e.typ.forward.methods {\n-\t\t\t\tmset.add(customizeRecv(m, e.ptr, recvTypeName))\n-\t\t\t}\n-\t\t\tcollectEmbeddedMethods(mset, e.typ, recvTypeName)\n+\t// process files in sorted order\n+\tfor _, filename := range filenames {\n+\t\tf := pkg.Files[filename]\n+\t\tif mode&AllDecls == 0 {\n+\t\t\tr.fileExports(f)\n \t\t}\n+\t\tr.addFile(f)\n \t}\n-}\n-\n-func customizeRecv(m *FuncDoc, embeddedIsPtr bool, recvTypeName string) *FuncDoc {\n-\tif m == nil || m.Decl == nil || m.Decl.Recv == nil || len(m.Decl.Recv.List) != 1 {\n-\t\treturn m // shouldn't happen, but be safe\n-\t}\n-\n-\t// copy existing receiver field and set new type\n-\t// TODO(gri) is receiver type computation correct?\n-\t//           what about deeply nested embeddings?\n-\tnewField := *m.Decl.Recv.List[0]\n-\t_, origRecvIsPtr := newField.Type.(*ast.StarExpr)\n-\tvar typ ast.Expr = ast.NewIdent(recvTypeName)\n-\tif embeddedIsPtr || origRecvIsPtr {\n-\t\ttyp = &ast.StarExpr{token.NoPos, typ}\n-\t}\n-\tnewField.Type = typ\n-\n-\t// copy existing receiver field list and set new receiver field\n-\tnewFieldList := *m.Decl.Recv\n-\tnewFieldList.List = []*ast.Field{&newField}\n-\n-\t// copy existing function declaration and set new receiver field list\n-\tnewFuncDecl := *m.Decl\n-\tnewFuncDecl.Recv = &newFieldList\n-\n-\t// copy existing function documentation and set new declaration\n-\tnewM := *m\n-\tnewM.Decl = &newFuncDecl\n-\tnewM.Recv = typ\n-\n-\treturn &newM\n-}\n-\n-func makeBugDocs(list []*ast.CommentGroup) []string {\n-\td := make([]string, len(list))\n-\tfor i, g := range list {\n-\t\td[i] = CommentText(g)\n-\t}\n-\treturn d\n-}\n-\n-// PackageDoc is the documentation for an entire package.\n-//\n-type PackageDoc struct {\n-\tPackageName string\n-\tImportPath  string\n-\tFilenames   []string\n-\tDoc         string\n-\tConsts      []*ValueDoc\n-\tTypes       []*TypeDoc\n-\tVars        []*ValueDoc\n-\tFuncs       []*FuncDoc\n-\tBugs        []string\n-}\n-\n-// newDoc returns the accumulated documentation for the package.\n-//\n-func (doc *docReader) newDoc(importpath string, filenames []string) *PackageDoc {\n-\tp := new(PackageDoc)\n-\tp.PackageName = doc.pkgName\n-\tp.ImportPath = importpath\n-\tsort.Strings(filenames)\n-\tp.Filenames = filenames\n-\tp.Doc = CommentText(doc.doc)\n-\t// makeTypeDocs may extend the list of doc.values and\n-\t// doc.funcs and thus must be called before any other\n-\t// function consuming those lists\n-\tp.Types = doc.makeTypeDocs(doc.types)\n-\tp.Consts = makeValueDocs(doc.values, token.CONST)\n-\tp.Vars = makeValueDocs(doc.values, token.VAR)\n-\tp.Funcs = makeFuncDocs(doc.funcs)\n-\tp.Bugs = makeBugDocs(doc.bugs)\n-\treturn p\n+\treturn r.newDoc(importpath, filenames)\n }"}, {"sha": "317d3abae880b23dfb59d45460ac1e053dfeca98", "filename": "libgo/go/go/doc/doc_test.go", "status": "added", "additions": 137, "deletions": 0, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fdoc_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,137 @@\n+// Copyright 2012 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"go/ast\"\n+\t\"go/parser\"\n+\t\"go/token\"\n+\t\"testing\"\n+\t\"text/template\"\n+)\n+\n+type sources map[string]string // filename -> file contents\n+\n+type testCase struct {\n+\tname       string\n+\timportPath string\n+\tmode       Mode\n+\tsrcs       sources\n+\tdoc        string\n+}\n+\n+var tests = make(map[string]*testCase)\n+\n+// To register a new test case, use the pattern:\n+//\n+//\tvar _ = register(&testCase{ ... })\n+//\n+// (The result value of register is always 0 and only present to enable the pattern.)\n+//\n+func register(test *testCase) int {\n+\tif _, found := tests[test.name]; found {\n+\t\tpanic(fmt.Sprintf(\"registration failed: test case %q already exists\", test.name))\n+\t}\n+\ttests[test.name] = test\n+\treturn 0\n+}\n+\n+func runTest(t *testing.T, test *testCase) {\n+\t// create AST\n+\tfset := token.NewFileSet()\n+\tvar pkg ast.Package\n+\tpkg.Files = make(map[string]*ast.File)\n+\tfor filename, src := range test.srcs {\n+\t\tfile, err := parser.ParseFile(fset, filename, src, parser.ParseComments)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"test %s: %v\", test.name, err)\n+\t\t\treturn\n+\t\t}\n+\t\tswitch {\n+\t\tcase pkg.Name == \"\":\n+\t\t\tpkg.Name = file.Name.Name\n+\t\tcase pkg.Name != file.Name.Name:\n+\t\t\tt.Errorf(\"test %s: different package names in test files\", test.name)\n+\t\t\treturn\n+\t\t}\n+\t\tpkg.Files[filename] = file\n+\t}\n+\n+\tdoc := New(&pkg, test.importPath, test.mode).String()\n+\tif doc != test.doc {\n+\t\t//TODO(gri) Enable this once the sorting issue of comments is fixed\n+\t\t//t.Errorf(\"test %s\\n\\tgot : %s\\n\\twant: %s\", test.name, doc, test.doc)\n+\t}\n+}\n+\n+func Test(t *testing.T) {\n+\tfor _, test := range tests {\n+\t\trunTest(t, test)\n+\t}\n+}\n+\n+// ----------------------------------------------------------------------------\n+// Printing support\n+\n+func (pkg *Package) String() string {\n+\tvar buf bytes.Buffer\n+\tdocText.Execute(&buf, pkg) // ignore error - test will fail w/ incorrect output\n+\treturn buf.String()\n+}\n+\n+// TODO(gri) complete template\n+var docText = template.Must(template.New(\"docText\").Parse(\n+\t`\n+PACKAGE {{.Name}}\n+DOC {{printf \"%q\" .Doc}}\n+IMPORTPATH {{.ImportPath}}\n+FILENAMES {{.Filenames}}\n+`))\n+\n+// ----------------------------------------------------------------------------\n+// Test cases\n+\n+// Test that all package comments and bugs are collected,\n+// and that the importPath is correctly set.\n+//\n+var _ = register(&testCase{\n+\tname:       \"p\",\n+\timportPath: \"p\",\n+\tsrcs: sources{\n+\t\t\"p1.go\": \"// comment 1\\npackage p\\n//BUG(uid): bug1\",\n+\t\t\"p0.go\": \"// comment 0\\npackage p\\n// BUG(uid): bug0\",\n+\t},\n+\tdoc: `\n+PACKAGE p\n+DOC \"comment 0\\n\\ncomment 1\\n\"\n+IMPORTPATH p\n+FILENAMES [p0.go p1.go]\n+`,\n+})\n+\n+// Test basic functionality.\n+//\n+var _ = register(&testCase{\n+\tname:       \"p1\",\n+\timportPath: \"p\",\n+\tsrcs: sources{\n+\t\t\"p.go\": `\n+package p\n+import \"a\"\n+const pi = 3.14       // pi\n+type T struct{}       // T\n+var V T               // v\n+func F(x int) int {}  // F\n+`,\n+\t},\n+\tdoc: `\n+PACKAGE p\n+DOC \"\"\n+IMPORTPATH p\n+FILENAMES [p.go]\n+`,\n+})"}, {"sha": "7c59bf9bd60a80b5c9e67227b72671db858cb530", "filename": "libgo/go/go/doc/example.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexample.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -35,7 +35,7 @@ func Examples(pkg *ast.Package) []*Example {\n \t\t\texamples = append(examples, &Example{\n \t\t\t\tName:   name[len(\"Example\"):],\n \t\t\t\tBody:   &printer.CommentedNode{f.Body, src.Comments},\n-\t\t\t\tOutput: CommentText(f.Doc),\n+\t\t\t\tOutput: f.Doc.Text(),\n \t\t\t})\n \t\t}\n \t}"}, {"sha": "994bf503b55b1f1062ca21aa918b5a3c13945914", "filename": "libgo/go/go/doc/exports.go", "status": "modified", "additions": 25, "deletions": 14, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fexports.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -33,7 +33,7 @@ func baseName(x ast.Expr) *ast.Ident {\n \treturn nil\n }\n \n-func (doc *docReader) filterFieldList(fields *ast.FieldList) (removedFields bool) {\n+func (doc *docReader) filterFieldList(tinfo *typeInfo, fields *ast.FieldList) (removedFields bool) {\n \tif fields == nil {\n \t\treturn false\n \t}\n@@ -44,7 +44,18 @@ func (doc *docReader) filterFieldList(fields *ast.FieldList) (removedFields bool\n \t\tif len(f.Names) == 0 {\n \t\t\t// anonymous field\n \t\t\tname := baseName(f.Type)\n-\t\t\tkeepField = name != nil && name.IsExported()\n+\t\t\tif name != nil && name.IsExported() {\n+\t\t\t\t// we keep the field - in this case doc.addDecl\n+\t\t\t\t// will take care of adding the embedded type\n+\t\t\t\tkeepField = true\n+\t\t\t} else if tinfo != nil {\n+\t\t\t\t// we don't keep the field - add it as an embedded\n+\t\t\t\t// type so we won't loose its methods, if any\n+\t\t\t\tif embedded := doc.lookupTypeInfo(name.Name); embedded != nil {\n+\t\t\t\t\t_, ptr := f.Type.(*ast.StarExpr)\n+\t\t\t\t\ttinfo.addEmbeddedType(embedded, ptr)\n+\t\t\t\t}\n+\t\t\t}\n \t\t} else {\n \t\t\tn := len(f.Names)\n \t\t\tf.Names = filterIdentList(f.Names)\n@@ -54,7 +65,7 @@ func (doc *docReader) filterFieldList(fields *ast.FieldList) (removedFields bool\n \t\t\tkeepField = len(f.Names) > 0\n \t\t}\n \t\tif keepField {\n-\t\t\tdoc.filterType(f.Type)\n+\t\t\tdoc.filterType(nil, f.Type)\n \t\t\tlist[j] = f\n \t\t\tj++\n \t\t}\n@@ -72,23 +83,23 @@ func (doc *docReader) filterParamList(fields *ast.FieldList) bool {\n \t}\n \tvar b bool\n \tfor _, f := range fields.List {\n-\t\tif doc.filterType(f.Type) {\n+\t\tif doc.filterType(nil, f.Type) {\n \t\t\tb = true\n \t\t}\n \t}\n \treturn b\n }\n \n-func (doc *docReader) filterType(typ ast.Expr) bool {\n+func (doc *docReader) filterType(tinfo *typeInfo, typ ast.Expr) bool {\n \tswitch t := typ.(type) {\n \tcase *ast.Ident:\n \t\treturn ast.IsExported(t.Name)\n \tcase *ast.ParenExpr:\n-\t\treturn doc.filterType(t.X)\n+\t\treturn doc.filterType(nil, t.X)\n \tcase *ast.ArrayType:\n-\t\treturn doc.filterType(t.Elt)\n+\t\treturn doc.filterType(nil, t.Elt)\n \tcase *ast.StructType:\n-\t\tif doc.filterFieldList(t.Fields) {\n+\t\tif doc.filterFieldList(tinfo, t.Fields) {\n \t\t\tt.Incomplete = true\n \t\t}\n \t\treturn len(t.Fields.List) > 0\n@@ -97,16 +108,16 @@ func (doc *docReader) filterType(typ ast.Expr) bool {\n \t\tb2 := doc.filterParamList(t.Results)\n \t\treturn b1 || b2\n \tcase *ast.InterfaceType:\n-\t\tif doc.filterFieldList(t.Methods) {\n+\t\tif doc.filterFieldList(tinfo, t.Methods) {\n \t\t\tt.Incomplete = true\n \t\t}\n \t\treturn len(t.Methods.List) > 0\n \tcase *ast.MapType:\n-\t\tb1 := doc.filterType(t.Key)\n-\t\tb2 := doc.filterType(t.Value)\n+\t\tb1 := doc.filterType(nil, t.Key)\n+\t\tb2 := doc.filterType(nil, t.Value)\n \t\treturn b1 || b2\n \tcase *ast.ChanType:\n-\t\treturn doc.filterType(t.Value)\n+\t\treturn doc.filterType(nil, t.Value)\n \t}\n \treturn false\n }\n@@ -116,12 +127,12 @@ func (doc *docReader) filterSpec(spec ast.Spec) bool {\n \tcase *ast.ValueSpec:\n \t\ts.Names = filterIdentList(s.Names)\n \t\tif len(s.Names) > 0 {\n-\t\t\tdoc.filterType(s.Type)\n+\t\t\tdoc.filterType(nil, s.Type)\n \t\t\treturn true\n \t\t}\n \tcase *ast.TypeSpec:\n \t\tif ast.IsExported(s.Name.Name) {\n-\t\t\tdoc.filterType(s.Type)\n+\t\t\tdoc.filterType(doc.lookupTypeInfo(s.Name.Name), s.Type)\n \t\t\treturn true\n \t\t}\n \t}"}, {"sha": "fe2d39b8802d06fb73ae4f0fb73170c4668f8b0b", "filename": "libgo/go/go/doc/filter.go", "status": "modified", "additions": 24, "deletions": 13, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Ffilter.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -49,7 +49,7 @@ func matchDecl(d *ast.GenDecl, f Filter) bool {\n \treturn false\n }\n \n-func filterValueDocs(a []*ValueDoc, f Filter) []*ValueDoc {\n+func filterValues(a []*Value, f Filter) []*Value {\n \tw := 0\n \tfor _, vd := range a {\n \t\tif matchDecl(vd.Decl, f) {\n@@ -60,7 +60,7 @@ func filterValueDocs(a []*ValueDoc, f Filter) []*ValueDoc {\n \treturn a[0:w]\n }\n \n-func filterFuncDocs(a []*FuncDoc, f Filter) []*FuncDoc {\n+func filterFuncs(a []*Func, f Filter) []*Func {\n \tw := 0\n \tfor _, fd := range a {\n \t\tif f(fd.Name) {\n@@ -71,19 +71,30 @@ func filterFuncDocs(a []*FuncDoc, f Filter) []*FuncDoc {\n \treturn a[0:w]\n }\n \n-func filterTypeDocs(a []*TypeDoc, f Filter) []*TypeDoc {\n+func filterMethods(a []*Method, f Filter) []*Method {\n+\tw := 0\n+\tfor _, md := range a {\n+\t\tif f(md.Name) {\n+\t\t\ta[w] = md\n+\t\t\tw++\n+\t\t}\n+\t}\n+\treturn a[0:w]\n+}\n+\n+func filterTypes(a []*Type, f Filter) []*Type {\n \tw := 0\n \tfor _, td := range a {\n \t\tn := 0 // number of matches\n \t\tif matchDecl(td.Decl, f) {\n \t\t\tn = 1\n \t\t} else {\n \t\t\t// type name doesn't match, but we may have matching consts, vars, factories or methods\n-\t\t\ttd.Consts = filterValueDocs(td.Consts, f)\n-\t\t\ttd.Vars = filterValueDocs(td.Vars, f)\n-\t\t\ttd.Factories = filterFuncDocs(td.Factories, f)\n-\t\t\ttd.Methods = filterFuncDocs(td.Methods, f)\n-\t\t\tn += len(td.Consts) + len(td.Vars) + len(td.Factories) + len(td.Methods)\n+\t\t\ttd.Consts = filterValues(td.Consts, f)\n+\t\t\ttd.Vars = filterValues(td.Vars, f)\n+\t\t\ttd.Funcs = filterFuncs(td.Funcs, f)\n+\t\t\ttd.Methods = filterMethods(td.Methods, f)\n+\t\t\tn += len(td.Consts) + len(td.Vars) + len(td.Funcs) + len(td.Methods)\n \t\t}\n \t\tif n > 0 {\n \t\t\ta[w] = td\n@@ -96,10 +107,10 @@ func filterTypeDocs(a []*TypeDoc, f Filter) []*TypeDoc {\n // Filter eliminates documentation for names that don't pass through the filter f.\n // TODO: Recognize \"Type.Method\" as a name.\n //\n-func (p *PackageDoc) Filter(f Filter) {\n-\tp.Consts = filterValueDocs(p.Consts, f)\n-\tp.Vars = filterValueDocs(p.Vars, f)\n-\tp.Types = filterTypeDocs(p.Types, f)\n-\tp.Funcs = filterFuncDocs(p.Funcs, f)\n+func (p *Package) Filter(f Filter) {\n+\tp.Consts = filterValues(p.Consts, f)\n+\tp.Vars = filterValues(p.Vars, f)\n+\tp.Types = filterTypes(p.Types, f)\n+\tp.Funcs = filterFuncs(p.Funcs, f)\n \tp.Doc = \"\" // don't show top-level package doc\n }"}, {"sha": "37486b126fd1b69062bb048875cb45cf1580558f", "filename": "libgo/go/go/doc/headscan.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Fheadscan.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -77,7 +77,7 @@ func main() {\n \t\t\treturn nil\n \t\t}\n \t\tfor _, pkg := range pkgs {\n-\t\t\td := doc.NewPackageDoc(pkg, path)\n+\t\t\td := doc.New(pkg, path, doc.Mode(0))\n \t\t\tlist := appendHeadings(nil, d.Doc)\n \t\t\tfor _, d := range d.Consts {\n \t\t\t\tlist = appendHeadings(list, d.Doc)"}, {"sha": "939dd89b00275f0c139d1e31053bb069d88eabea", "filename": "libgo/go/go/doc/reader.go", "status": "added", "additions": 669, "deletions": 0, "changes": 669, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fdoc%2Freader.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,669 @@\n+// Copyright 2009 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package doc\n+\n+import (\n+\t\"go/ast\"\n+\t\"go/token\"\n+\t\"regexp\"\n+\t\"sort\"\n+)\n+\n+// ----------------------------------------------------------------------------\n+// Collection of documentation info\n+\n+// embeddedType describes the type of an anonymous field.\n+//\n+type embeddedType struct {\n+\ttyp *typeInfo // the corresponding base type\n+\tptr bool      // if set, the anonymous field type is a pointer\n+}\n+\n+type typeInfo struct {\n+\tname     string // base type name\n+\tisStruct bool\n+\t// len(decl.Specs) == 1, and the element type is *ast.TypeSpec\n+\t// if the type declaration hasn't been seen yet, decl is nil\n+\tdecl     *ast.GenDecl\n+\tembedded []embeddedType\n+\tforward  *Type // forward link to processed type documentation\n+\n+\t// declarations associated with the type\n+\tvalues    []*ast.GenDecl // consts and vars\n+\tfactories map[string]*ast.FuncDecl\n+\tmethods   map[string]*ast.FuncDecl\n+}\n+\n+func (info *typeInfo) exported() bool {\n+\treturn ast.IsExported(info.name)\n+}\n+\n+func (info *typeInfo) addEmbeddedType(embedded *typeInfo, isPtr bool) {\n+\tinfo.embedded = append(info.embedded, embeddedType{embedded, isPtr})\n+}\n+\n+// docReader accumulates documentation for a single package.\n+// It modifies the AST: Comments (declaration documentation)\n+// that have been collected by the DocReader are set to nil\n+// in the respective AST nodes so that they are not printed\n+// twice (once when printing the documentation and once when\n+// printing the corresponding AST node).\n+//\n+type docReader struct {\n+\tdoc      *ast.CommentGroup // package documentation, if any\n+\tpkgName  string\n+\tmode     Mode\n+\tvalues   []*ast.GenDecl // consts and vars\n+\ttypes    map[string]*typeInfo\n+\tembedded map[string]*typeInfo // embedded types, possibly not exported\n+\tfuncs    map[string]*ast.FuncDecl\n+\tbugs     []*ast.CommentGroup\n+}\n+\n+func (doc *docReader) init(pkgName string, mode Mode) {\n+\tdoc.pkgName = pkgName\n+\tdoc.mode = mode\n+\tdoc.types = make(map[string]*typeInfo)\n+\tdoc.embedded = make(map[string]*typeInfo)\n+\tdoc.funcs = make(map[string]*ast.FuncDecl)\n+}\n+\n+func (doc *docReader) addDoc(comments *ast.CommentGroup) {\n+\tif doc.doc == nil {\n+\t\t// common case: just one package comment\n+\t\tdoc.doc = comments\n+\t\treturn\n+\t}\n+\t// More than one package comment: Usually there will be only\n+\t// one file with a package comment, but it's better to collect\n+\t// all comments than drop them on the floor.\n+\tblankComment := &ast.Comment{token.NoPos, \"//\"}\n+\tlist := append(doc.doc.List, blankComment)\n+\tdoc.doc.List = append(list, comments.List...)\n+}\n+\n+func (doc *docReader) lookupTypeInfo(name string) *typeInfo {\n+\tif name == \"\" || name == \"_\" {\n+\t\treturn nil // no type docs for anonymous types\n+\t}\n+\tif info, found := doc.types[name]; found {\n+\t\treturn info\n+\t}\n+\t// type wasn't found - add one without declaration\n+\tinfo := &typeInfo{\n+\t\tname:      name,\n+\t\tfactories: make(map[string]*ast.FuncDecl),\n+\t\tmethods:   make(map[string]*ast.FuncDecl),\n+\t}\n+\tdoc.types[name] = info\n+\treturn info\n+}\n+\n+func baseTypeName(typ ast.Expr, allTypes bool) string {\n+\tswitch t := typ.(type) {\n+\tcase *ast.Ident:\n+\t\t// if the type is not exported, the effect to\n+\t\t// a client is as if there were no type name\n+\t\tif t.IsExported() || allTypes {\n+\t\t\treturn t.Name\n+\t\t}\n+\tcase *ast.StarExpr:\n+\t\treturn baseTypeName(t.X, allTypes)\n+\t}\n+\treturn \"\"\n+}\n+\n+func (doc *docReader) addValue(decl *ast.GenDecl) {\n+\t// determine if decl should be associated with a type\n+\t// Heuristic: For each typed entry, determine the type name, if any.\n+\t//            If there is exactly one type name that is sufficiently\n+\t//            frequent, associate the decl with the respective type.\n+\tdomName := \"\"\n+\tdomFreq := 0\n+\tprev := \"\"\n+\tfor _, s := range decl.Specs {\n+\t\tif v, ok := s.(*ast.ValueSpec); ok {\n+\t\t\tname := \"\"\n+\t\t\tswitch {\n+\t\t\tcase v.Type != nil:\n+\t\t\t\t// a type is present; determine its name\n+\t\t\t\tname = baseTypeName(v.Type, false)\n+\t\t\tcase decl.Tok == token.CONST:\n+\t\t\t\t// no type is present but we have a constant declaration;\n+\t\t\t\t// use the previous type name (w/o more type information\n+\t\t\t\t// we cannot handle the case of unnamed variables with\n+\t\t\t\t// initializer expressions except for some trivial cases)\n+\t\t\t\tname = prev\n+\t\t\t}\n+\t\t\tif name != \"\" {\n+\t\t\t\t// entry has a named type\n+\t\t\t\tif domName != \"\" && domName != name {\n+\t\t\t\t\t// more than one type name - do not associate\n+\t\t\t\t\t// with any type\n+\t\t\t\t\tdomName = \"\"\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tdomName = name\n+\t\t\t\tdomFreq++\n+\t\t\t}\n+\t\t\tprev = name\n+\t\t}\n+\t}\n+\n+\t// determine values list\n+\tconst threshold = 0.75\n+\tvalues := &doc.values\n+\tif domName != \"\" && domFreq >= int(float64(len(decl.Specs))*threshold) {\n+\t\t// typed entries are sufficiently frequent\n+\t\ttyp := doc.lookupTypeInfo(domName)\n+\t\tif typ != nil {\n+\t\t\tvalues = &typ.values // associate with that type\n+\t\t}\n+\t}\n+\n+\t*values = append(*values, decl)\n+}\n+\n+// Helper function to set the table entry for function f. Makes sure that\n+// at least one f with associated documentation is stored in table, if there\n+// are multiple f's with the same name.\n+func setFunc(table map[string]*ast.FuncDecl, f *ast.FuncDecl) {\n+\tname := f.Name.Name\n+\tif g, exists := table[name]; exists && g.Doc != nil {\n+\t\t// a function with the same name has already been registered;\n+\t\t// since it has documentation, assume f is simply another\n+\t\t// implementation and ignore it\n+\t\t// TODO(gri) consider collecting all functions, or at least\n+\t\t//           all comments\n+\t\treturn\n+\t}\n+\t// function doesn't exist or has no documentation; use f\n+\ttable[name] = f\n+}\n+\n+func (doc *docReader) addFunc(fun *ast.FuncDecl) {\n+\t// strip function body\n+\tfun.Body = nil\n+\n+\t// determine if it should be associated with a type\n+\tif fun.Recv != nil {\n+\t\t// method\n+\t\trecvTypeName := baseTypeName(fun.Recv.List[0].Type, true /* exported or not */ )\n+\t\tvar typ *typeInfo\n+\t\tif ast.IsExported(recvTypeName) {\n+\t\t\t// exported recv type: if not found, add it to doc.types\n+\t\t\ttyp = doc.lookupTypeInfo(recvTypeName)\n+\t\t} else {\n+\t\t\t// unexported recv type: if not found, do not add it\n+\t\t\t// (unexported embedded types are added before this\n+\t\t\t// phase, so if the type doesn't exist yet, we don't\n+\t\t\t// care about this method)\n+\t\t\ttyp = doc.types[recvTypeName]\n+\t\t}\n+\t\tif typ != nil {\n+\t\t\t// exported receiver type\n+\t\t\t// associate method with the type\n+\t\t\t// (if the type is not exported, it may be embedded\n+\t\t\t// somewhere so we need to collect the method anyway)\n+\t\t\tsetFunc(typ.methods, fun)\n+\t\t}\n+\t\t// otherwise don't show the method\n+\t\t// TODO(gri): There may be exported methods of non-exported types\n+\t\t// that can be called because of exported values (consts, vars, or\n+\t\t// function results) of that type. Could determine if that is the\n+\t\t// case and then show those methods in an appropriate section.\n+\t\treturn\n+\t}\n+\n+\t// perhaps a factory function\n+\t// determine result type, if any\n+\tif fun.Type.Results.NumFields() >= 1 {\n+\t\tres := fun.Type.Results.List[0]\n+\t\tif len(res.Names) <= 1 {\n+\t\t\t// exactly one (named or anonymous) result associated\n+\t\t\t// with the first type in result signature (there may\n+\t\t\t// be more than one result)\n+\t\t\ttname := baseTypeName(res.Type, false)\n+\t\t\ttyp := doc.lookupTypeInfo(tname)\n+\t\t\tif typ != nil {\n+\t\t\t\t// named and exported result type\n+\t\t\t\tsetFunc(typ.factories, fun)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// ordinary function\n+\tsetFunc(doc.funcs, fun)\n+}\n+\n+func (doc *docReader) addDecl(decl ast.Decl) {\n+\tswitch d := decl.(type) {\n+\tcase *ast.GenDecl:\n+\t\tif len(d.Specs) > 0 {\n+\t\t\tswitch d.Tok {\n+\t\t\tcase token.CONST, token.VAR:\n+\t\t\t\t// constants and variables are always handled as a group\n+\t\t\t\tdoc.addValue(d)\n+\t\t\tcase token.TYPE:\n+\t\t\t\t// types are handled individually\n+\t\t\t\tfor _, spec := range d.Specs {\n+\t\t\t\t\ttspec := spec.(*ast.TypeSpec)\n+\t\t\t\t\t// add the type to the documentation\n+\t\t\t\t\tinfo := doc.lookupTypeInfo(tspec.Name.Name)\n+\t\t\t\t\tif info == nil {\n+\t\t\t\t\t\tcontinue // no name - ignore the type\n+\t\t\t\t\t}\n+\t\t\t\t\t// Make a (fake) GenDecl node for this TypeSpec\n+\t\t\t\t\t// (we need to do this here - as opposed to just\n+\t\t\t\t\t// for printing - so we don't lose the GenDecl\n+\t\t\t\t\t// documentation). Since a new GenDecl node is\n+\t\t\t\t\t// created, there's no need to nil out d.Doc.\n+\t\t\t\t\t//\n+\t\t\t\t\t// TODO(gri): Consider just collecting the TypeSpec\n+\t\t\t\t\t// node (and copy in the GenDecl.doc if there is no\n+\t\t\t\t\t// doc in the TypeSpec - this is currently done in\n+\t\t\t\t\t// makeTypes below). Simpler data structures, but\n+\t\t\t\t\t// would lose GenDecl documentation if the TypeSpec\n+\t\t\t\t\t// has documentation as well.\n+\t\t\t\t\tfake := &ast.GenDecl{d.Doc, d.Pos(), token.TYPE, token.NoPos,\n+\t\t\t\t\t\t[]ast.Spec{tspec}, token.NoPos}\n+\t\t\t\t\t// A type should be added at most once, so info.decl\n+\t\t\t\t\t// should be nil - if it isn't, simply overwrite it.\n+\t\t\t\t\tinfo.decl = fake\n+\t\t\t\t\t// Look for anonymous fields that might contribute methods.\n+\t\t\t\t\tvar fields *ast.FieldList\n+\t\t\t\t\tswitch typ := spec.(*ast.TypeSpec).Type.(type) {\n+\t\t\t\t\tcase *ast.StructType:\n+\t\t\t\t\t\tfields = typ.Fields\n+\t\t\t\t\t\tinfo.isStruct = true\n+\t\t\t\t\tcase *ast.InterfaceType:\n+\t\t\t\t\t\tfields = typ.Methods\n+\t\t\t\t\t}\n+\t\t\t\t\tif fields != nil {\n+\t\t\t\t\t\tfor _, field := range fields.List {\n+\t\t\t\t\t\t\tif len(field.Names) == 0 {\n+\t\t\t\t\t\t\t\t// anonymous field - add corresponding type\n+\t\t\t\t\t\t\t\t// to the info and collect it in doc\n+\t\t\t\t\t\t\t\tname := baseTypeName(field.Type, true)\n+\t\t\t\t\t\t\t\tif embedded := doc.lookupTypeInfo(name); embedded != nil {\n+\t\t\t\t\t\t\t\t\t_, ptr := field.Type.(*ast.StarExpr)\n+\t\t\t\t\t\t\t\t\tinfo.addEmbeddedType(embedded, ptr)\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\tcase *ast.FuncDecl:\n+\t\tdoc.addFunc(d)\n+\t}\n+}\n+\n+func copyCommentList(list []*ast.Comment) []*ast.Comment {\n+\treturn append([]*ast.Comment(nil), list...)\n+}\n+\n+var (\n+\tbug_markers = regexp.MustCompile(\"^/[/*][ \\t]*BUG\\\\(.*\\\\):[ \\t]*\") // BUG(uid):\n+\tbug_content = regexp.MustCompile(\"[^ \\n\\r\\t]+\")                    // at least one non-whitespace char\n+)\n+\n+// addFile adds the AST for a source file to the docReader.\n+// Adding the same AST multiple times is a no-op.\n+//\n+func (doc *docReader) addFile(src *ast.File) {\n+\t// add package documentation\n+\tif src.Doc != nil {\n+\t\tdoc.addDoc(src.Doc)\n+\t\tsrc.Doc = nil // doc consumed - remove from ast.File node\n+\t}\n+\n+\t// add all declarations\n+\tfor _, decl := range src.Decls {\n+\t\tdoc.addDecl(decl)\n+\t}\n+\n+\t// collect BUG(...) comments\n+\tfor _, c := range src.Comments {\n+\t\ttext := c.List[0].Text\n+\t\tif m := bug_markers.FindStringIndex(text); m != nil {\n+\t\t\t// found a BUG comment; maybe empty\n+\t\t\tif btxt := text[m[1]:]; bug_content.MatchString(btxt) {\n+\t\t\t\t// non-empty BUG comment; collect comment without BUG prefix\n+\t\t\t\tlist := copyCommentList(c.List)\n+\t\t\t\tlist[0].Text = text[m[1]:]\n+\t\t\t\tdoc.bugs = append(doc.bugs, &ast.CommentGroup{list})\n+\t\t\t}\n+\t\t}\n+\t}\n+\tsrc.Comments = nil // consumed unassociated comments - remove from ast.File node\n+}\n+\n+// ----------------------------------------------------------------------------\n+// Conversion to external representation\n+\n+type sortValue []*Value\n+\n+func (p sortValue) Len() int      { return len(p) }\n+func (p sortValue) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n+\n+func declName(d *ast.GenDecl) string {\n+\tif len(d.Specs) != 1 {\n+\t\treturn \"\"\n+\t}\n+\n+\tswitch v := d.Specs[0].(type) {\n+\tcase *ast.ValueSpec:\n+\t\treturn v.Names[0].Name\n+\tcase *ast.TypeSpec:\n+\t\treturn v.Name.Name\n+\t}\n+\n+\treturn \"\"\n+}\n+\n+func (p sortValue) Less(i, j int) bool {\n+\t// sort by name\n+\t// pull blocks (name = \"\") up to top\n+\t// in original order\n+\tif ni, nj := declName(p[i].Decl), declName(p[j].Decl); ni != nj {\n+\t\treturn ni < nj\n+\t}\n+\treturn p[i].order < p[j].order\n+}\n+\n+func specNames(specs []ast.Spec) []string {\n+\tnames := make([]string, len(specs)) // reasonable estimate\n+\tfor _, s := range specs {\n+\t\t// should always be an *ast.ValueSpec, but be careful\n+\t\tif s, ok := s.(*ast.ValueSpec); ok {\n+\t\t\tfor _, ident := range s.Names {\n+\t\t\t\tnames = append(names, ident.Name)\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn names\n+}\n+\n+func makeValues(list []*ast.GenDecl, tok token.Token) []*Value {\n+\td := make([]*Value, len(list)) // big enough in any case\n+\tn := 0\n+\tfor i, decl := range list {\n+\t\tif decl.Tok == tok {\n+\t\t\td[n] = &Value{decl.Doc.Text(), specNames(decl.Specs), decl, i}\n+\t\t\tn++\n+\t\t\tdecl.Doc = nil // doc consumed - removed from AST\n+\t\t}\n+\t}\n+\td = d[0:n]\n+\tsort.Sort(sortValue(d))\n+\treturn d\n+}\n+\n+type sortFunc []*Func\n+\n+func (p sortFunc) Len() int           { return len(p) }\n+func (p sortFunc) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n+func (p sortFunc) Less(i, j int) bool { return p[i].Name < p[j].Name }\n+\n+func makeFuncs(m map[string]*ast.FuncDecl) []*Func {\n+\td := make([]*Func, len(m))\n+\ti := 0\n+\tfor _, f := range m {\n+\t\tdoc := new(Func)\n+\t\tdoc.Doc = f.Doc.Text()\n+\t\tf.Doc = nil // doc consumed - remove from ast.FuncDecl node\n+\t\tif f.Recv != nil {\n+\t\t\tdoc.Recv = f.Recv.List[0].Type\n+\t\t}\n+\t\tdoc.Name = f.Name.Name\n+\t\tdoc.Decl = f\n+\t\td[i] = doc\n+\t\ti++\n+\t}\n+\tsort.Sort(sortFunc(d))\n+\treturn d\n+}\n+\n+type methodSet map[string]*Func\n+\n+func (mset methodSet) add(m *Func) {\n+\tif mset[m.Name] == nil {\n+\t\tmset[m.Name] = m\n+\t}\n+}\n+\n+type sortMethod []*Method\n+\n+func (p sortMethod) Len() int           { return len(p) }\n+func (p sortMethod) Swap(i, j int)      { p[i], p[j] = p[j], p[i] }\n+func (p sortMethod) Less(i, j int) bool { return p[i].Func.Name < p[j].Func.Name }\n+\n+func (mset methodSet) sortedList() []*Method {\n+\tlist := make([]*Method, len(mset))\n+\ti := 0\n+\tfor _, m := range mset {\n+\t\tlist[i] = &Method{Func: m}\n+\t\ti++\n+\t}\n+\tsort.Sort(sortMethod(list))\n+\treturn list\n+}\n+\n+type sortType []*Type\n+\n+func (p sortType) Len() int      { return len(p) }\n+func (p sortType) Swap(i, j int) { p[i], p[j] = p[j], p[i] }\n+func (p sortType) Less(i, j int) bool {\n+\t// sort by name\n+\t// pull blocks (name = \"\") up to top\n+\t// in original order\n+\tif ni, nj := p[i].Type.Name.Name, p[j].Type.Name.Name; ni != nj {\n+\t\treturn ni < nj\n+\t}\n+\treturn p[i].order < p[j].order\n+}\n+\n+// NOTE(rsc): This would appear not to be correct for type ( )\n+// blocks, but the doc extractor above has split them into\n+// individual declarations.\n+func (doc *docReader) makeTypes(m map[string]*typeInfo) []*Type {\n+\t// TODO(gri) Consider computing the embedded method information\n+\t//           before calling makeTypes. Then this function can\n+\t//           be single-phased again. Also, it might simplify some\n+\t//           of the logic.\n+\t//\n+\t// phase 1: associate collected declarations with Types\n+\tlist := make([]*Type, len(m))\n+\ti := 0\n+\tfor _, old := range m {\n+\t\t// old typeInfos may not have a declaration associated with them\n+\t\t// if they are not exported but embedded, or because the package\n+\t\t// is incomplete.\n+\t\tif decl := old.decl; decl != nil || !old.exported() {\n+\t\t\t// process the type even if not exported so that we have\n+\t\t\t// its methods in case they are embedded somewhere\n+\t\t\tt := new(Type)\n+\t\t\tif decl != nil {\n+\t\t\t\ttypespec := decl.Specs[0].(*ast.TypeSpec)\n+\t\t\t\tdoc := typespec.Doc\n+\t\t\t\ttypespec.Doc = nil // doc consumed - remove from ast.TypeSpec node\n+\t\t\t\tif doc == nil {\n+\t\t\t\t\t// no doc associated with the spec, use the declaration doc, if any\n+\t\t\t\t\tdoc = decl.Doc\n+\t\t\t\t}\n+\t\t\t\tdecl.Doc = nil // doc consumed - remove from ast.Decl node\n+\t\t\t\tt.Doc = doc.Text()\n+\t\t\t\tt.Type = typespec\n+\t\t\t}\n+\t\t\tt.Consts = makeValues(old.values, token.CONST)\n+\t\t\tt.Vars = makeValues(old.values, token.VAR)\n+\t\t\tt.Funcs = makeFuncs(old.factories)\n+\t\t\tt.methods = makeFuncs(old.methods)\n+\t\t\t// The list of embedded types' methods is computed from the list\n+\t\t\t// of embedded types, some of which may not have been processed\n+\t\t\t// yet (i.e., their forward link is nil) - do this in a 2nd phase.\n+\t\t\t// The final list of methods can only be computed after that -\n+\t\t\t// do this in a 3rd phase.\n+\t\t\tt.Decl = old.decl\n+\t\t\tt.order = i\n+\t\t\told.forward = t // old has been processed\n+\t\t\t// only add the type to the final type list if it\n+\t\t\t// is exported or if we want to see all types\n+\t\t\tif old.exported() || doc.mode&AllDecls != 0 {\n+\t\t\t\tlist[i] = t\n+\t\t\t\ti++\n+\t\t\t}\n+\t\t} else {\n+\t\t\t// no corresponding type declaration found - move any associated\n+\t\t\t// values, factory functions, and methods back to the top-level\n+\t\t\t// so that they are not lost (this should only happen if a package\n+\t\t\t// file containing the explicit type declaration is missing or if\n+\t\t\t// an unqualified type name was used after a \".\" import)\n+\t\t\t// 1) move values\n+\t\t\tdoc.values = append(doc.values, old.values...)\n+\t\t\t// 2) move factory functions\n+\t\t\tfor name, f := range old.factories {\n+\t\t\t\tdoc.funcs[name] = f\n+\t\t\t}\n+\t\t\t// 3) move methods\n+\t\t\tfor name, f := range old.methods {\n+\t\t\t\t// don't overwrite functions with the same name\n+\t\t\t\tif _, found := doc.funcs[name]; !found {\n+\t\t\t\t\tdoc.funcs[name] = f\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tlist = list[0:i] // some types may have been ignored\n+\n+\t// phase 2: collect embedded methods for each processed typeInfo\n+\tfor _, old := range m {\n+\t\tif t := old.forward; t != nil {\n+\t\t\t// old has been processed into t; collect embedded\n+\t\t\t// methods for t from the list of processed embedded\n+\t\t\t// types in old (and thus for which the methods are known)\n+\t\t\tif old.isStruct {\n+\t\t\t\t// struct\n+\t\t\t\tt.embedded = make(methodSet)\n+\t\t\t\tcollectEmbeddedMethods(t.embedded, old, old.name, false)\n+\t\t\t} else {\n+\t\t\t\t// interface\n+\t\t\t\t// TODO(gri) fix this\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// phase 3: compute final method set for each Type\n+\tfor _, d := range list {\n+\t\tif len(d.embedded) > 0 {\n+\t\t\t// there are embedded methods - exclude\n+\t\t\t// the ones with names conflicting with\n+\t\t\t// non-embedded methods\n+\t\t\tmset := make(methodSet)\n+\t\t\t// top-level methods have priority\n+\t\t\tfor _, m := range d.methods {\n+\t\t\t\tmset.add(m)\n+\t\t\t}\n+\t\t\t// add non-conflicting embedded methods\n+\t\t\tfor _, m := range d.embedded {\n+\t\t\t\tmset.add(m)\n+\t\t\t}\n+\t\t\td.Methods = mset.sortedList()\n+\t\t} else {\n+\t\t\t// no embedded methods - convert into a Method list\n+\t\t\td.Methods = make([]*Method, len(d.methods))\n+\t\t\tfor i, m := range d.methods {\n+\t\t\t\td.Methods[i] = &Method{Func: m}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tsort.Sort(sortType(list))\n+\treturn list\n+}\n+\n+// collectEmbeddedMethods collects the embedded methods from all\n+// processed embedded types found in info in mset. It considers\n+// embedded types at the most shallow level first so that more\n+// deeply nested embedded methods with conflicting names are\n+// excluded.\n+//\n+func collectEmbeddedMethods(mset methodSet, info *typeInfo, recvTypeName string, embeddedIsPtr bool) {\n+\tfor _, e := range info.embedded {\n+\t\tif e.typ.forward != nil { // == e was processed\n+\t\t\t// Once an embedded type was embedded as a pointer type\n+\t\t\t// all embedded types in those types are treated like\n+\t\t\t// pointer types for the purpose of the receiver type\n+\t\t\t// computation; i.e., embeddedIsPtr is sticky for this\n+\t\t\t// embedding hierarchy.\n+\t\t\tthisEmbeddedIsPtr := embeddedIsPtr || e.ptr\n+\t\t\tfor _, m := range e.typ.forward.methods {\n+\t\t\t\tmset.add(customizeRecv(m, thisEmbeddedIsPtr, recvTypeName))\n+\t\t\t}\n+\t\t\tcollectEmbeddedMethods(mset, e.typ, recvTypeName, thisEmbeddedIsPtr)\n+\t\t}\n+\t}\n+}\n+\n+func customizeRecv(m *Func, embeddedIsPtr bool, recvTypeName string) *Func {\n+\tif m == nil || m.Decl == nil || m.Decl.Recv == nil || len(m.Decl.Recv.List) != 1 {\n+\t\treturn m // shouldn't happen, but be safe\n+\t}\n+\n+\t// copy existing receiver field and set new type\n+\tnewField := *m.Decl.Recv.List[0]\n+\t_, origRecvIsPtr := newField.Type.(*ast.StarExpr)\n+\tvar typ ast.Expr = ast.NewIdent(recvTypeName)\n+\tif !embeddedIsPtr && origRecvIsPtr {\n+\t\ttyp = &ast.StarExpr{token.NoPos, typ}\n+\t}\n+\tnewField.Type = typ\n+\n+\t// copy existing receiver field list and set new receiver field\n+\tnewFieldList := *m.Decl.Recv\n+\tnewFieldList.List = []*ast.Field{&newField}\n+\n+\t// copy existing function declaration and set new receiver field list\n+\tnewFuncDecl := *m.Decl\n+\tnewFuncDecl.Recv = &newFieldList\n+\n+\t// copy existing function documentation and set new declaration\n+\tnewM := *m\n+\tnewM.Decl = &newFuncDecl\n+\tnewM.Recv = typ\n+\n+\treturn &newM\n+}\n+\n+func makeBugs(list []*ast.CommentGroup) []string {\n+\td := make([]string, len(list))\n+\tfor i, g := range list {\n+\t\td[i] = g.Text()\n+\t}\n+\treturn d\n+}\n+\n+// newDoc returns the accumulated documentation for the package.\n+//\n+func (doc *docReader) newDoc(importpath string, filenames []string) *Package {\n+\tp := new(Package)\n+\tp.Name = doc.pkgName\n+\tp.ImportPath = importpath\n+\tsort.Strings(filenames)\n+\tp.Filenames = filenames\n+\tp.Doc = doc.doc.Text()\n+\t// makeTypes may extend the list of doc.values and\n+\t// doc.funcs and thus must be called before any other\n+\t// function consuming those lists\n+\tp.Types = doc.makeTypes(doc.types)\n+\tp.Consts = makeValues(doc.values, token.CONST)\n+\tp.Vars = makeValues(doc.values, token.VAR)\n+\tp.Funcs = makeFuncs(doc.funcs)\n+\tp.Bugs = makeBugs(doc.bugs)\n+\treturn p\n+}"}, {"sha": "2ce3df8df714750db66d8e785fd18bda450c0351", "filename": "libgo/go/go/parser/interface.go", "status": "modified", "additions": 46, "deletions": 116, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Finterface.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"bytes\"\n \t\"errors\"\n \t\"go/ast\"\n-\t\"go/scanner\"\n \t\"go/token\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -36,86 +35,28 @@ func readSource(filename string, src interface{}) ([]byte, error) {\n \t\t\t}\n \t\tcase io.Reader:\n \t\t\tvar buf bytes.Buffer\n-\t\t\t_, err := io.Copy(&buf, s)\n-\t\t\tif err != nil {\n+\t\t\tif _, err := io.Copy(&buf, s); err != nil {\n \t\t\t\treturn nil, err\n \t\t\t}\n \t\t\treturn buf.Bytes(), nil\n-\t\tdefault:\n-\t\t\treturn nil, errors.New(\"invalid source\")\n \t\t}\n+\t\treturn nil, errors.New(\"invalid source\")\n \t}\n-\n \treturn ioutil.ReadFile(filename)\n }\n \n-func (p *parser) errors() error {\n-\tmode := scanner.Sorted\n-\tif p.mode&SpuriousErrors == 0 {\n-\t\tmode = scanner.NoMultiples\n-\t}\n-\treturn p.GetError(mode)\n-}\n-\n-// ParseExpr parses a Go expression and returns the corresponding\n-// AST node. The fset, filename, and src arguments have the same interpretation\n-// as for ParseFile. If there is an error, the result expression\n-// may be nil or contain a partial AST.\n-//\n-func ParseExpr(fset *token.FileSet, filename string, src interface{}) (ast.Expr, error) {\n-\tdata, err := readSource(filename, src)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar p parser\n-\tp.init(fset, filename, data, 0)\n-\tx := p.parseRhs()\n-\tif p.tok == token.SEMICOLON {\n-\t\tp.next() // consume automatically inserted semicolon, if any\n-\t}\n-\tp.expect(token.EOF)\n-\n-\treturn x, p.errors()\n-}\n-\n-// ParseStmtList parses a list of Go statements and returns the list\n-// of corresponding AST nodes. The fset, filename, and src arguments have the same\n-// interpretation as for ParseFile. If there is an error, the node\n-// list may be nil or contain partial ASTs.\n+// The mode parameter to the Parse* functions is a set of flags (or 0).\n+// They control the amount of source code parsed and other optional\n+// parser functionality.\n //\n-func ParseStmtList(fset *token.FileSet, filename string, src interface{}) ([]ast.Stmt, error) {\n-\tdata, err := readSource(filename, src)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar p parser\n-\tp.init(fset, filename, data, 0)\n-\tlist := p.parseStmtList()\n-\tp.expect(token.EOF)\n-\n-\treturn list, p.errors()\n-}\n-\n-// ParseDeclList parses a list of Go declarations and returns the list\n-// of corresponding AST nodes. The fset, filename, and src arguments have the same\n-// interpretation as for ParseFile. If there is an error, the node\n-// list may be nil or contain partial ASTs.\n-//\n-func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast.Decl, error) {\n-\tdata, err := readSource(filename, src)\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\n-\tvar p parser\n-\tp.init(fset, filename, data, 0)\n-\tlist := p.parseDeclList()\n-\tp.expect(token.EOF)\n-\n-\treturn list, p.errors()\n-}\n+const (\n+\tPackageClauseOnly uint = 1 << iota // parsing stops after package clause\n+\tImportsOnly                        // parsing stops after import declarations\n+\tParseComments                      // parse comments and add them to AST\n+\tTrace                              // print a trace of parsed productions\n+\tDeclarationErrors                  // report declaration errors\n+\tSpuriousErrors                     // report all (not just the first) errors per line\n+)\n \n // ParseFile parses the source code of a single Go source file and returns\n // the corresponding ast.File node. The source code may be provided via\n@@ -124,7 +65,6 @@ func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast\n // If src != nil, ParseFile parses the source from src and the filename is\n // only used when recording position information. The type of the argument\n // for the src parameter must be string, []byte, or io.Reader.\n-//\n // If src == nil, ParseFile parses the file specified by filename.\n //\n // The mode parameter controls the amount of source text parsed and other\n@@ -133,49 +73,18 @@ func ParseDeclList(fset *token.FileSet, filename string, src interface{}) ([]ast\n //\n // If the source couldn't be read, the returned AST is nil and the error\n // indicates the specific failure. If the source was read but syntax\n-// errors were found, the result is a partial AST (with ast.BadX nodes\n+// errors were found, the result is a partial AST (with ast.Bad* nodes\n // representing the fragments of erroneous source code). Multiple errors\n // are returned via a scanner.ErrorList which is sorted by file position.\n //\n func ParseFile(fset *token.FileSet, filename string, src interface{}, mode uint) (*ast.File, error) {\n-\tdata, err := readSource(filename, src)\n+\ttext, err := readSource(filename, src)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\n \tvar p parser\n-\tp.init(fset, filename, data, mode)\n-\tfile := p.parseFile() // parseFile reads to EOF\n-\n-\treturn file, p.errors()\n-}\n-\n-// ParseFiles calls ParseFile for each file in the filenames list and returns\n-// a map of package name -> package AST with all the packages found. The mode\n-// bits are passed to ParseFile unchanged. Position information is recorded\n-// in the file set fset.\n-//\n-// Files with parse errors are ignored. In this case the map of packages may\n-// be incomplete (missing packages and/or incomplete packages) and the first\n-// error encountered is returned.\n-//\n-func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[string]*ast.Package, first error) {\n-\tpkgs = make(map[string]*ast.Package)\n-\tfor _, filename := range filenames {\n-\t\tif src, err := ParseFile(fset, filename, nil, mode); err == nil {\n-\t\t\tname := src.Name.Name\n-\t\t\tpkg, found := pkgs[name]\n-\t\t\tif !found {\n-\t\t\t\t// TODO(gri) Use NewPackage here; reconsider ParseFiles API.\n-\t\t\t\tpkg = &ast.Package{name, nil, nil, make(map[string]*ast.File)}\n-\t\t\t\tpkgs[name] = pkg\n-\t\t\t}\n-\t\t\tpkg.Files[filename] = src\n-\t\t} else if first == nil {\n-\t\t\tfirst = err\n-\t\t}\n-\t}\n-\treturn\n+\tp.init(fset, filename, text, mode)\n+\treturn p.parseFile(), p.errors()\n }\n \n // ParseDir calls ParseFile for the files in the directory specified by path and\n@@ -186,9 +95,9 @@ func ParseFiles(fset *token.FileSet, filenames []string, mode uint) (pkgs map[st\n //\n // If the directory couldn't be read, a nil map and the respective error are\n // returned. If a parse error occurred, a non-nil but incomplete map and the\n-// error are returned.\n+// first error encountered are returned.\n //\n-func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode uint) (map[string]*ast.Package, error) {\n+func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, mode uint) (pkgs map[string]*ast.Package, first error) {\n \tfd, err := os.Open(path)\n \tif err != nil {\n \t\treturn nil, err\n@@ -200,15 +109,36 @@ func ParseDir(fset *token.FileSet, path string, filter func(os.FileInfo) bool, m\n \t\treturn nil, err\n \t}\n \n-\tfilenames := make([]string, len(list))\n-\tn := 0\n+\tpkgs = make(map[string]*ast.Package)\n \tfor _, d := range list {\n \t\tif filter == nil || filter(d) {\n-\t\t\tfilenames[n] = filepath.Join(path, d.Name())\n-\t\t\tn++\n+\t\t\tfilename := filepath.Join(path, d.Name())\n+\t\t\tif src, err := ParseFile(fset, filename, nil, mode); err == nil {\n+\t\t\t\tname := src.Name.Name\n+\t\t\t\tpkg, found := pkgs[name]\n+\t\t\t\tif !found {\n+\t\t\t\t\tpkg = &ast.Package{name, nil, nil, make(map[string]*ast.File)}\n+\t\t\t\t\tpkgs[name] = pkg\n+\t\t\t\t}\n+\t\t\t\tpkg.Files[filename] = src\n+\t\t\t} else if first == nil {\n+\t\t\t\tfirst = err\n+\t\t\t}\n \t\t}\n \t}\n-\tfilenames = filenames[0:n]\n \n-\treturn ParseFiles(fset, filenames, mode)\n+\treturn\n+}\n+\n+// ParseExpr is a convenience function for obtaining the AST of an expression x.\n+// The position information recorded in the AST is undefined.\n+// \n+func ParseExpr(x string) (ast.Expr, error) {\n+\t// parse x within the context of a complete package for correct scopes;\n+\t// use //line directive for correct positions in error messages\n+\tfile, err := ParseFile(token.NewFileSet(), \"\", \"package p;func _(){_=\\n//line :1\\n\"+x+\";}\", 0)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn file.Decls[0].(*ast.FuncDecl).Body.List[0].(*ast.AssignStmt).Rhs[0], nil\n }"}, {"sha": "d90f5775df45eff5c6b51c10bffdb62a8e583f5d", "filename": "libgo/go/go/parser/parser.go", "status": "modified", "additions": 13, "deletions": 35, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -16,19 +16,6 @@ import (\n \t\"go/token\"\n )\n \n-// The mode parameter to the Parse* functions is a set of flags (or 0).\n-// They control the amount of source code parsed and other optional\n-// parser functionality.\n-//\n-const (\n-\tPackageClauseOnly uint = 1 << iota // parsing stops after package clause\n-\tImportsOnly                        // parsing stops after import declarations\n-\tParseComments                      // parse comments and add them to AST\n-\tTrace                              // print a trace of parsed productions\n-\tDeclarationErrors                  // report declaration errors\n-\tSpuriousErrors                     // report all (not just the first) errors per line\n-)\n-\n // The parser structure holds the parser's internal state.\n type parser struct {\n \tfile *token.File\n@@ -65,18 +52,13 @@ type parser struct {\n \ttargetStack [][]*ast.Ident // stack of unresolved labels\n }\n \n-// scannerMode returns the scanner mode bits given the parser's mode bits.\n-func scannerMode(mode uint) uint {\n-\tvar m uint = scanner.InsertSemis\n-\tif mode&ParseComments != 0 {\n-\t\tm |= scanner.ScanComments\n-\t}\n-\treturn m\n-}\n-\n func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode uint) {\n \tp.file = fset.AddFile(filename, fset.Base(), len(src))\n-\tp.scanner.Init(p.file, src, p, scannerMode(mode))\n+\tvar m uint\n+\tif mode&ParseComments != 0 {\n+\t\tm = scanner.ScanComments\n+\t}\n+\tp.scanner.Init(p.file, src, p, m)\n \n \tp.mode = mode\n \tp.trace = mode&Trace != 0 // for convenience (p.trace is used frequently)\n@@ -92,6 +74,14 @@ func (p *parser) init(fset *token.FileSet, filename string, src []byte, mode uin\n \tp.openLabelScope()\n }\n \n+func (p *parser) errors() error {\n+\tm := scanner.Sorted\n+\tif p.mode&SpuriousErrors == 0 {\n+\t\tm = scanner.NoMultiples\n+\t}\n+\treturn p.GetError(m)\n+}\n+\n // ----------------------------------------------------------------------------\n // Scoping support\n \n@@ -2109,18 +2099,6 @@ func (p *parser) parseDecl() ast.Decl {\n \treturn p.parseGenDecl(p.tok, f)\n }\n \n-func (p *parser) parseDeclList() (list []ast.Decl) {\n-\tif p.trace {\n-\t\tdefer un(trace(p, \"DeclList\"))\n-\t}\n-\n-\tfor p.tok != token.EOF {\n-\t\tlist = append(list, p.parseDecl())\n-\t}\n-\n-\treturn\n-}\n-\n // ----------------------------------------------------------------------------\n // Source files\n "}, {"sha": "a3ee8525de29b931e73594c9570f3b91684e2139", "filename": "libgo/go/go/parser/parser_test.go", "status": "modified", "additions": 27, "deletions": 1, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fparser%2Fparser_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -54,7 +54,7 @@ func TestParseIllegalInputs(t *testing.T) {\n \t}\n }\n \n-var validPrograms = []interface{}{\n+var validPrograms = []string{\n \t\"package p\\n\",\n \t`package p;`,\n \t`package p; import \"fmt\"; func f() { fmt.Println(\"Hello, World!\") };`,\n@@ -136,6 +136,32 @@ func TestParse4(t *testing.T) {\n \t}\n }\n \n+func TestParseExpr(t *testing.T) {\n+\t// just kicking the tires:\n+\t// a valid expression\n+\tsrc := \"a + b\"\n+\tx, err := ParseExpr(src)\n+\tif err != nil {\n+\t\tt.Errorf(\"ParseExpr(%s): %v\", src, err)\n+\t}\n+\t// sanity check\n+\tif _, ok := x.(*ast.BinaryExpr); !ok {\n+\t\tt.Errorf(\"ParseExpr(%s): got %T, expected *ast.BinaryExpr\", src, x)\n+\t}\n+\n+\t// an invalid expression\n+\tsrc = \"a + *\"\n+\t_, err = ParseExpr(src)\n+\tif err == nil {\n+\t\tt.Errorf(\"ParseExpr(%s): %v\", src, err)\n+\t}\n+\n+\t// it must not crash\n+\tfor _, src := range validPrograms {\n+\t\tParseExpr(src)\n+\t}\n+}\n+\n func TestColonEqualsScope(t *testing.T) {\n \tf, err := ParseFile(fset, \"\", `package p; func f() { x, y, z := x, y, z }`, 0)\n \tif err != nil {"}, {"sha": "c720f2e665c479b263edd5c399a2573ac6b2e523", "filename": "libgo/go/go/printer/printer.go", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -773,8 +773,13 @@ func (p *printer) print(args ...interface{}) {\n \t\t\t\tnext = p.fset.Position(x) // accurate position of next item\n \t\t\t}\n \t\t\ttok = p.lastTok\n+\t\tcase string:\n+\t\t\t// incorrect AST - print error message\n+\t\t\tdata = x\n+\t\t\tisLit = true\n+\t\t\ttok = token.STRING\n \t\tdefault:\n-\t\t\tfmt.Fprintf(os.Stderr, \"print: unsupported argument type %T\\n\", f)\n+\t\t\tfmt.Fprintf(os.Stderr, \"print: unsupported argument %v (%T)\\n\", f, f)\n \t\t\tpanic(\"go/printer type\")\n \t\t}\n \t\tp.lastTok = tok"}, {"sha": "525fcc1595f7ef096b51f3457892365fafb88e99", "filename": "libgo/go/go/printer/printer_test.go", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fprinter%2Fprinter_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -204,3 +204,18 @@ func init() {\n \t\tpanic(\"got \" + s + \", want \" + name)\n \t}\n }\n+\n+// Verify that the printer doesn't crash if the AST contains BadXXX nodes.\n+func TestBadNodes(t *testing.T) {\n+\tconst src = \"package p\\n(\"\n+\tconst res = \"package p\\nBadDecl\\n\"\n+\tf, err := parser.ParseFile(fset, \"\", src, parser.ParseComments)\n+\tif err == nil {\n+\t\tt.Errorf(\"expected illegal program\")\n+\t}\n+\tvar buf bytes.Buffer\n+\tFprint(&buf, fset, f)\n+\tif buf.String() != res {\n+\t\tt.Errorf(\"got %q, expected %q\", buf.String(), res)\n+\t}\n+}"}, {"sha": "59a796574f60bb21051984dcbd51c984c531bfa5", "filename": "libgo/go/go/scanner/scanner.go", "status": "modified", "additions": 76, "deletions": 57, "changes": 133, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -90,8 +90,8 @@ func (S *Scanner) next() {\n // They control scanner behavior.\n //\n const (\n-\tScanComments = 1 << iota // return comments as COMMENT tokens\n-\tInsertSemis              // automatically insert semicolons\n+\tScanComments    = 1 << iota // return comments as COMMENT tokens\n+\tdontInsertSemis             // do not automatically insert semicolons - for testing only\n )\n \n // Init prepares the scanner S to tokenize the text src by setting the\n@@ -104,7 +104,7 @@ const (\n // Calls to Scan will use the error handler err if they encounter a\n // syntax error and err is not nil. Also, for each error encountered,\n // the Scanner field ErrorCount is incremented by one. The mode parameter\n-// determines how comments, illegal characters, and semicolons are handled.\n+// determines how comments are handled.\n //\n // Note that Init may call err if there is an error in the first character\n // of the file.\n@@ -157,7 +157,7 @@ func (S *Scanner) interpretLineComment(text []byte) {\n \t}\n }\n \n-func (S *Scanner) scanComment() {\n+func (S *Scanner) scanComment() string {\n \t// initial '/' already consumed; S.ch == '/' || S.ch == '*'\n \toffs := S.offset - 1 // position of initial '/'\n \n@@ -171,7 +171,7 @@ func (S *Scanner) scanComment() {\n \t\t\t// comment starts at the beginning of the current line\n \t\t\tS.interpretLineComment(S.src[offs:S.offset])\n \t\t}\n-\t\treturn\n+\t\tgoto exit\n \t}\n \n \t/*-style comment */\n@@ -181,11 +181,14 @@ func (S *Scanner) scanComment() {\n \t\tS.next()\n \t\tif ch == '*' && S.ch == '/' {\n \t\t\tS.next()\n-\t\t\treturn\n+\t\t\tgoto exit\n \t\t}\n \t}\n \n \tS.error(offs, \"comment not terminated\")\n+\n+exit:\n+\treturn string(S.src[offs:S.offset])\n }\n \n func (S *Scanner) findLineEnd() bool {\n@@ -240,12 +243,12 @@ func isDigit(ch rune) bool {\n \treturn '0' <= ch && ch <= '9' || ch >= 0x80 && unicode.IsDigit(ch)\n }\n \n-func (S *Scanner) scanIdentifier() token.Token {\n+func (S *Scanner) scanIdentifier() string {\n \toffs := S.offset\n \tfor isLetter(S.ch) || isDigit(S.ch) {\n \t\tS.next()\n \t}\n-\treturn token.Lookup(S.src[offs:S.offset])\n+\treturn string(S.src[offs:S.offset])\n }\n \n func digitVal(ch rune) int {\n@@ -266,11 +269,13 @@ func (S *Scanner) scanMantissa(base int) {\n \t}\n }\n \n-func (S *Scanner) scanNumber(seenDecimalPoint bool) token.Token {\n+func (S *Scanner) scanNumber(seenDecimalPoint bool) (token.Token, string) {\n \t// digitVal(S.ch) < 10\n+\toffs := S.offset\n \ttok := token.INT\n \n \tif seenDecimalPoint {\n+\t\toffs--\n \t\ttok = token.FLOAT\n \t\tS.scanMantissa(10)\n \t\tgoto exponent\n@@ -334,7 +339,7 @@ exponent:\n \t}\n \n exit:\n-\treturn tok\n+\treturn tok, string(S.src[offs:S.offset])\n }\n \n func (S *Scanner) scanEscape(quote rune) {\n@@ -381,7 +386,7 @@ func (S *Scanner) scanEscape(quote rune) {\n \t}\n }\n \n-func (S *Scanner) scanChar() {\n+func (S *Scanner) scanChar() string {\n \t// '\\'' opening already consumed\n \toffs := S.offset - 1\n \n@@ -405,9 +410,11 @@ func (S *Scanner) scanChar() {\n \tif n != 1 {\n \t\tS.error(offs, \"illegal character literal\")\n \t}\n+\n+\treturn string(S.src[offs:S.offset])\n }\n \n-func (S *Scanner) scanString() {\n+func (S *Scanner) scanString() string {\n \t// '\"' opening already consumed\n \toffs := S.offset - 1\n \n@@ -424,12 +431,27 @@ func (S *Scanner) scanString() {\n \t}\n \n \tS.next()\n+\n+\treturn string(S.src[offs:S.offset])\n+}\n+\n+func stripCR(b []byte) []byte {\n+\tc := make([]byte, len(b))\n+\ti := 0\n+\tfor _, ch := range b {\n+\t\tif ch != '\\r' {\n+\t\t\tc[i] = ch\n+\t\t\ti++\n+\t\t}\n+\t}\n+\treturn c[:i]\n }\n \n-func (S *Scanner) scanRawString() (hasCR bool) {\n+func (S *Scanner) scanRawString() string {\n \t// '`' opening already consumed\n \toffs := S.offset - 1\n \n+\thasCR := false\n \tfor S.ch != '`' {\n \t\tch := S.ch\n \t\tS.next()\n@@ -443,7 +465,13 @@ func (S *Scanner) scanRawString() (hasCR bool) {\n \t}\n \n \tS.next()\n-\treturn\n+\n+\tlit := S.src[offs:S.offset]\n+\tif hasCR {\n+\t\tlit = stripCR(lit)\n+\t}\n+\n+\treturn string(lit)\n }\n \n func (S *Scanner) skipWhitespace() {\n@@ -494,27 +522,24 @@ func (S *Scanner) switch4(tok0, tok1 token.Token, ch2 rune, tok2, tok3 token.Tok\n \treturn tok0\n }\n \n-func stripCR(b []byte) []byte {\n-\tc := make([]byte, len(b))\n-\ti := 0\n-\tfor _, ch := range b {\n-\t\tif ch != '\\r' {\n-\t\t\tc[i] = ch\n-\t\t\ti++\n-\t\t}\n-\t}\n-\treturn c[:i]\n-}\n-\n-// Scan scans the next token and returns the token position,\n-// the token, and the literal string corresponding to the\n-// token. The source end is indicated by token.EOF.\n+// Scan scans the next token and returns the token position, the token,\n+// and its literal string if applicable. The source end is indicated by\n+// token.EOF.\n+//\n+// If the returned token is a literal (token.IDENT, token.INT, token.FLOAT,\n+// token.IMAG, token.CHAR, token.STRING) or token.COMMENT, the literal string\n+// has the corresponding value.\n //\n // If the returned token is token.SEMICOLON, the corresponding\n // literal string is \";\" if the semicolon was present in the source,\n // and \"\\n\" if the semicolon was inserted because of a newline or\n // at EOF.\n //\n+// If the returned token is token.ILLEGAL, the literal string is the\n+// offending character.\n+//\n+// In all other cases, Scan returns an empty literal string.\n+//\n // For more tolerant parsing, Scan will return a valid token if\n // possible even if a syntax error was encountered. Thus, even\n // if the resulting token sequence contains no illegal tokens,\n@@ -526,60 +551,59 @@ func stripCR(b []byte) []byte {\n // set with Init. Token positions are relative to that file\n // and thus relative to the file set.\n //\n-func (S *Scanner) Scan() (token.Pos, token.Token, string) {\n+func (S *Scanner) Scan() (pos token.Pos, tok token.Token, lit string) {\n scanAgain:\n \tS.skipWhitespace()\n \n \t// current token start\n-\tinsertSemi := false\n-\toffs := S.offset\n-\ttok := token.ILLEGAL\n-\thasCR := false\n+\tpos = S.file.Pos(S.offset)\n \n \t// determine token value\n+\tinsertSemi := false\n \tswitch ch := S.ch; {\n \tcase isLetter(ch):\n-\t\ttok = S.scanIdentifier()\n+\t\tlit = S.scanIdentifier()\n+\t\ttok = token.Lookup(lit)\n \t\tswitch tok {\n \t\tcase token.IDENT, token.BREAK, token.CONTINUE, token.FALLTHROUGH, token.RETURN:\n \t\t\tinsertSemi = true\n \t\t}\n \tcase digitVal(ch) < 10:\n \t\tinsertSemi = true\n-\t\ttok = S.scanNumber(false)\n+\t\ttok, lit = S.scanNumber(false)\n \tdefault:\n \t\tS.next() // always make progress\n \t\tswitch ch {\n \t\tcase -1:\n \t\t\tif S.insertSemi {\n \t\t\t\tS.insertSemi = false // EOF consumed\n-\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n+\t\t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\t\t}\n \t\t\ttok = token.EOF\n \t\tcase '\\n':\n \t\t\t// we only reach here if S.insertSemi was\n \t\t\t// set in the first place and exited early\n \t\t\t// from S.skipWhitespace()\n \t\t\tS.insertSemi = false // newline consumed\n-\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n+\t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\tcase '\"':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n-\t\t\tS.scanString()\n+\t\t\tlit = S.scanString()\n \t\tcase '\\'':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.CHAR\n-\t\t\tS.scanChar()\n+\t\t\tlit = S.scanChar()\n \t\tcase '`':\n \t\t\tinsertSemi = true\n \t\t\ttok = token.STRING\n-\t\t\thasCR = S.scanRawString()\n+\t\t\tlit = S.scanRawString()\n \t\tcase ':':\n \t\t\ttok = S.switch2(token.COLON, token.DEFINE)\n \t\tcase '.':\n \t\t\tif digitVal(S.ch) < 10 {\n \t\t\t\tinsertSemi = true\n-\t\t\t\ttok = S.scanNumber(true)\n+\t\t\t\ttok, lit = S.scanNumber(true)\n \t\t\t} else if S.ch == '.' {\n \t\t\t\tS.next()\n \t\t\t\tif S.ch == '.' {\n@@ -593,6 +617,7 @@ scanAgain:\n \t\t\ttok = token.COMMA\n \t\tcase ';':\n \t\t\ttok = token.SEMICOLON\n+\t\t\tlit = \";\"\n \t\tcase '(':\n \t\t\ttok = token.LPAREN\n \t\tcase ')':\n@@ -626,12 +651,12 @@ scanAgain:\n \t\t\t\tif S.insertSemi && S.findLineEnd() {\n \t\t\t\t\t// reset position to the beginning of the comment\n \t\t\t\t\tS.ch = '/'\n-\t\t\t\t\tS.offset = offs\n-\t\t\t\t\tS.rdOffset = offs + 1\n+\t\t\t\t\tS.offset = S.file.Offset(pos)\n+\t\t\t\t\tS.rdOffset = S.offset + 1\n \t\t\t\t\tS.insertSemi = false // newline consumed\n-\t\t\t\t\treturn S.file.Pos(offs), token.SEMICOLON, \"\\n\"\n+\t\t\t\t\treturn pos, token.SEMICOLON, \"\\n\"\n \t\t\t\t}\n-\t\t\t\tS.scanComment()\n+\t\t\t\tlit = S.scanComment()\n \t\t\t\tif S.mode&ScanComments == 0 {\n \t\t\t\t\t// skip comment\n \t\t\t\t\tS.insertSemi = false // newline consumed\n@@ -668,21 +693,15 @@ scanAgain:\n \t\tcase '|':\n \t\t\ttok = S.switch3(token.OR, token.OR_ASSIGN, '|', token.LOR)\n \t\tdefault:\n-\t\t\tS.error(offs, fmt.Sprintf(\"illegal character %#U\", ch))\n+\t\t\tS.error(S.file.Offset(pos), fmt.Sprintf(\"illegal character %#U\", ch))\n \t\t\tinsertSemi = S.insertSemi // preserve insertSemi info\n+\t\t\ttok = token.ILLEGAL\n+\t\t\tlit = string(ch)\n \t\t}\n \t}\n-\n-\tif S.mode&InsertSemis != 0 {\n+\tif S.mode&dontInsertSemis == 0 {\n \t\tS.insertSemi = insertSemi\n \t}\n \n-\t// TODO(gri): The scanner API should change such that the literal string\n-\t//            is only valid if an actual literal was scanned. This will\n-\t//            permit a more efficient implementation.\n-\tlit := S.src[offs:S.offset]\n-\tif hasCR {\n-\t\tlit = stripCR(lit)\n-\t}\n-\treturn S.file.Pos(offs), tok, string(lit)\n+\treturn\n }"}, {"sha": "2e4dd4fff638860b79aaf2a1e8a86930a014060f", "filename": "libgo/go/go/scanner/scanner_test.go", "status": "modified", "additions": 41, "deletions": 15, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Fscanner%2Fscanner_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -177,6 +177,15 @@ var tokens = [...]elt{\n \n const whitespace = \"  \\t  \\n\\n\\n\" // to separate tokens\n \n+var source = func() []byte {\n+\tvar src []byte\n+\tfor _, t := range tokens {\n+\t\tsrc = append(src, t.lit...)\n+\t\tsrc = append(src, whitespace...)\n+\t}\n+\treturn src\n+}()\n+\n type testErrorHandler struct {\n \tt *testing.T\n }\n@@ -214,20 +223,20 @@ func checkPos(t *testing.T, lit string, p token.Pos, expected token.Position) {\n // Verify that calling Scan() provides the correct results.\n func TestScan(t *testing.T) {\n \t// make source\n-\tvar src string\n-\tfor _, e := range tokens {\n-\t\tsrc += e.lit + whitespace\n-\t}\n-\tsrc_linecount := newlineCount(src)\n+\tsrc_linecount := newlineCount(string(source))\n \twhitespace_linecount := newlineCount(whitespace)\n \n \t// verify scan\n \tvar s Scanner\n-\ts.Init(fset.AddFile(\"\", fset.Base(), len(src)), []byte(src), &testErrorHandler{t}, ScanComments)\n+\ts.Init(fset.AddFile(\"\", fset.Base(), len(source)), source, &testErrorHandler{t}, ScanComments|dontInsertSemis)\n \tindex := 0\n \tepos := token.Position{\"\", 0, 1, 1} // expected position\n \tfor {\n \t\tpos, tok, lit := s.Scan()\n+\t\tif lit == \"\" {\n+\t\t\t// no literal value for non-literal tokens\n+\t\t\tlit = tok.String()\n+\t\t}\n \t\te := elt{token.EOF, \"\", special}\n \t\tif index < len(tokens) {\n \t\t\te = tokens[index]\n@@ -430,14 +439,14 @@ var lines = []string{\n \n func TestSemis(t *testing.T) {\n \tfor _, line := range lines {\n-\t\tcheckSemi(t, line, InsertSemis)\n-\t\tcheckSemi(t, line, InsertSemis|ScanComments)\n+\t\tcheckSemi(t, line, 0)\n+\t\tcheckSemi(t, line, ScanComments)\n \n \t\t// if the input ended in newlines, the input must tokenize the\n \t\t// same with or without those newlines\n \t\tfor i := len(line) - 1; i >= 0 && line[i] == '\\n'; i-- {\n-\t\t\tcheckSemi(t, line[0:i], InsertSemis)\n-\t\t\tcheckSemi(t, line[0:i], InsertSemis|ScanComments)\n+\t\t\tcheckSemi(t, line[0:i], 0)\n+\t\t\tcheckSemi(t, line[0:i], ScanComments)\n \t\t}\n \t}\n }\n@@ -492,7 +501,7 @@ func TestLineComments(t *testing.T) {\n \t// verify scan\n \tvar S Scanner\n \tfile := fset.AddFile(filepath.Join(\"dir\", \"TestLineComments\"), fset.Base(), len(src))\n-\tS.Init(file, []byte(src), nil, 0)\n+\tS.Init(file, []byte(src), nil, dontInsertSemis)\n \tfor _, s := range segs {\n \t\tp, _, lit := S.Scan()\n \t\tpos := file.Position(p)\n@@ -511,7 +520,7 @@ func TestInit(t *testing.T) {\n \t// 1st init\n \tsrc1 := \"if true { }\"\n \tf1 := fset.AddFile(\"src1\", fset.Base(), len(src1))\n-\ts.Init(f1, []byte(src1), nil, 0)\n+\ts.Init(f1, []byte(src1), nil, dontInsertSemis)\n \tif f1.Size() != len(src1) {\n \t\tt.Errorf(\"bad file size: got %d, expected %d\", f1.Size(), len(src1))\n \t}\n@@ -525,7 +534,7 @@ func TestInit(t *testing.T) {\n \t// 2nd init\n \tsrc2 := \"go true { ]\"\n \tf2 := fset.AddFile(\"src2\", fset.Base(), len(src2))\n-\ts.Init(f2, []byte(src2), nil, 0)\n+\ts.Init(f2, []byte(src2), nil, dontInsertSemis)\n \tif f2.Size() != len(src2) {\n \t\tt.Errorf(\"bad file size: got %d, expected %d\", f2.Size(), len(src2))\n \t}\n@@ -551,7 +560,7 @@ func TestStdErrorHander(t *testing.T) {\n \n \tv := new(ErrorVector)\n \tvar s Scanner\n-\ts.Init(fset.AddFile(\"File1\", fset.Base(), len(src)), []byte(src), v, 0)\n+\ts.Init(fset.AddFile(\"File1\", fset.Base(), len(src)), []byte(src), v, dontInsertSemis)\n \tfor {\n \t\tif _, tok, _ := s.Scan(); tok == token.EOF {\n \t\t\tbreak\n@@ -596,7 +605,7 @@ func (h *errorCollector) Error(pos token.Position, msg string) {\n func checkError(t *testing.T, src string, tok token.Token, pos int, err string) {\n \tvar s Scanner\n \tvar h errorCollector\n-\ts.Init(fset.AddFile(\"\", fset.Base(), len(src)), []byte(src), &h, ScanComments)\n+\ts.Init(fset.AddFile(\"\", fset.Base(), len(src)), []byte(src), &h, ScanComments|dontInsertSemis)\n \t_, tok0, _ := s.Scan()\n \t_, tok1, _ := s.Scan()\n \tif tok0 != tok {\n@@ -659,3 +668,20 @@ func TestScanErrors(t *testing.T) {\n \t\tcheckError(t, e.src, e.tok, e.pos, e.err)\n \t}\n }\n+\n+func BenchmarkScan(b *testing.B) {\n+\tb.StopTimer()\n+\tfset := token.NewFileSet()\n+\tfile := fset.AddFile(\"\", fset.Base(), len(source))\n+\tvar s Scanner\n+\tb.StartTimer()\n+\tfor i := b.N - 1; i >= 0; i-- {\n+\t\ts.Init(file, source, nil, ScanComments)\n+\t\tfor {\n+\t\t\t_, tok, _ := s.Scan()\n+\t\t\tif tok == token.EOF {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t}\n+}"}, {"sha": "84b6314d57af1c8a623fec7b5cd155ca32318c1b", "filename": "libgo/go/go/token/token.go", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fgo%2Ftoken%2Ftoken.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -283,10 +283,8 @@ func init() {\n \n // Lookup maps an identifier to its keyword token or IDENT (if not a keyword).\n //\n-func Lookup(ident []byte) Token {\n-\t// TODO Maps with []byte key are illegal because []byte does not\n-\t//      support == . Should find a more efficient solution eventually.\n-\tif tok, is_keyword := keywords[string(ident)]; is_keyword {\n+func Lookup(ident string) Token {\n+\tif tok, is_keyword := keywords[ident]; is_keyword {\n \t\treturn tok\n \t}\n \treturn IDENT\n@@ -295,16 +293,16 @@ func Lookup(ident []byte) Token {\n // Predicates\n \n // IsLiteral returns true for tokens corresponding to identifiers\n-// and basic type literals; returns false otherwise.\n+// and basic type literals; it returns false otherwise.\n //\n func (tok Token) IsLiteral() bool { return literal_beg < tok && tok < literal_end }\n \n // IsOperator returns true for tokens corresponding to operators and\n-// delimiters; returns false otherwise.\n+// delimiters; it returns false otherwise.\n //\n func (tok Token) IsOperator() bool { return operator_beg < tok && tok < operator_end }\n \n // IsKeyword returns true for tokens corresponding to keywords;\n-// returns false otherwise.\n+// it returns false otherwise.\n //\n func (tok Token) IsKeyword() bool { return keyword_beg < tok && tok < keyword_end }"}, {"sha": "3ba81ce4d6f1655b32a0b6bae1f5a7d97b389f9e", "filename": "libgo/go/html/foreign.go", "status": "modified", "additions": 77, "deletions": 1, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fforeign.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fforeign.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fforeign.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -4,6 +4,42 @@\n \n package html\n \n+import (\n+\t\"strings\"\n+)\n+\n+func adjustForeignAttributes(aa []Attribute) {\n+\tfor i, a := range aa {\n+\t\tif a.Key == \"\" || a.Key[0] != 'x' {\n+\t\t\tcontinue\n+\t\t}\n+\t\tswitch a.Key {\n+\t\tcase \"xlink:actuate\", \"xlink:arcrole\", \"xlink:href\", \"xlink:role\", \"xlink:show\",\n+\t\t\t\"xlink:title\", \"xlink:type\", \"xml:base\", \"xml:lang\", \"xml:space\", \"xmlns:xlink\":\n+\t\t\tj := strings.Index(a.Key, \":\")\n+\t\t\taa[i].Namespace = a.Key[:j]\n+\t\t\taa[i].Key = a.Key[j+1:]\n+\t\t}\n+\t}\n+}\n+\n+func htmlIntegrationPoint(n *Node) bool {\n+\tif n.Type != ElementNode {\n+\t\treturn false\n+\t}\n+\tswitch n.Namespace {\n+\tcase \"math\":\n+\t\t// TODO: annotation-xml elements whose start tags have \"text/html\" or\n+\t\t// \"application/xhtml+xml\" encodings.\n+\tcase \"svg\":\n+\t\tswitch n.Data {\n+\t\tcase \"desc\", \"foreignObject\", \"title\":\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n // Section 12.2.5.5.\n var breakout = map[string]bool{\n \t\"b\":          true,\n@@ -53,4 +89,44 @@ var breakout = map[string]bool{\n \t\"var\":        true,\n }\n \n-// TODO: add look-up tables for MathML and SVG adjustments.\n+// Section 12.2.5.5.\n+var svgTagNameAdjustments = map[string]string{\n+\t\"altglyph\":            \"altGlyph\",\n+\t\"altglyphdef\":         \"altGlyphDef\",\n+\t\"altglyphitem\":        \"altGlyphItem\",\n+\t\"animatecolor\":        \"animateColor\",\n+\t\"animatemotion\":       \"animateMotion\",\n+\t\"animatetransform\":    \"animateTransform\",\n+\t\"clippath\":            \"clipPath\",\n+\t\"feblend\":             \"feBlend\",\n+\t\"fecolormatrix\":       \"feColorMatrix\",\n+\t\"fecomponenttransfer\": \"feComponentTransfer\",\n+\t\"fecomposite\":         \"feComposite\",\n+\t\"feconvolvematrix\":    \"feConvolveMatrix\",\n+\t\"fediffuselighting\":   \"feDiffuseLighting\",\n+\t\"fedisplacementmap\":   \"feDisplacementMap\",\n+\t\"fedistantlight\":      \"feDistantLight\",\n+\t\"feflood\":             \"feFlood\",\n+\t\"fefunca\":             \"feFuncA\",\n+\t\"fefuncb\":             \"feFuncB\",\n+\t\"fefuncg\":             \"feFuncG\",\n+\t\"fefuncr\":             \"feFuncR\",\n+\t\"fegaussianblur\":      \"feGaussianBlur\",\n+\t\"feimage\":             \"feImage\",\n+\t\"femerge\":             \"feMerge\",\n+\t\"femergenode\":         \"feMergeNode\",\n+\t\"femorphology\":        \"feMorphology\",\n+\t\"feoffset\":            \"feOffset\",\n+\t\"fepointlight\":        \"fePointLight\",\n+\t\"fespecularlighting\":  \"feSpecularLighting\",\n+\t\"fespotlight\":         \"feSpotLight\",\n+\t\"fetile\":              \"feTile\",\n+\t\"feturbulence\":        \"feTurbulence\",\n+\t\"foreignobject\":       \"foreignObject\",\n+\t\"glyphref\":            \"glyphRef\",\n+\t\"lineargradient\":      \"linearGradient\",\n+\t\"radialgradient\":      \"radialGradient\",\n+\t\"textpath\":            \"textPath\",\n+}\n+\n+// TODO: add look-up tables for MathML and SVG attribute adjustments."}, {"sha": "83f17308b18a10de4f0162bdd7621a87a57a2eb1", "filename": "libgo/go/html/node.go", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fnode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fnode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fnode.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -26,6 +26,10 @@ var scopeMarker = Node{Type: scopeMarkerNode}\n // content for text) and are part of a tree of Nodes. Element nodes may also\n // have a Namespace and contain a slice of Attributes. Data is unescaped, so\n // that it looks like \"a<b\" rather than \"a&lt;b\".\n+//\n+// An empty Namespace implies a \"http://www.w3.org/1999/xhtml\" namespace.\n+// Similarly, \"math\" is short for \"http://www.w3.org/1998/Math/MathML\", and\n+// \"svg\" is short for \"http://www.w3.org/2000/svg\".\n type Node struct {\n \tParent    *Node\n \tChild     []*Node"}, {"sha": "43c04727ab83d7adfdbbab3372d54d1c9e2427b5", "filename": "libgo/go/html/parse.go", "status": "modified", "additions": 204, "deletions": 105, "changes": 309, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fparse.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fparse.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -51,58 +51,87 @@ func (p *parser) top() *Node {\n \treturn p.doc\n }\n \n-// stopTags for use in popUntil. These come from section 12.2.3.2.\n+// Stop tags for use in popUntil. These come from section 12.2.3.2.\n var (\n-\tdefaultScopeStopTags  = []string{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"}\n-\tlistItemScopeStopTags = []string{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\", \"ol\", \"ul\"}\n-\tbuttonScopeStopTags   = []string{\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\", \"button\"}\n-\ttableScopeStopTags    = []string{\"html\", \"table\"}\n+\tdefaultScopeStopTags = map[string][]string{\n+\t\t\"\":     {\"applet\", \"caption\", \"html\", \"table\", \"td\", \"th\", \"marquee\", \"object\"},\n+\t\t\"math\": {\"annotation-xml\", \"mi\", \"mn\", \"mo\", \"ms\", \"mtext\"},\n+\t\t\"svg\":  {\"desc\", \"foreignObject\", \"title\"},\n+\t}\n )\n \n-// stopTags for use in clearStackToContext.\n-var (\n-\ttableRowContextStopTags = []string{\"tr\", \"html\"}\n+type scope int\n+\n+const (\n+\tdefaultScope scope = iota\n+\tlistItemScope\n+\tbuttonScope\n+\ttableScope\n+\ttableRowScope\n )\n \n // popUntil pops the stack of open elements at the highest element whose tag\n-// is in matchTags, provided there is no higher element in stopTags. It returns\n-// whether or not there was such an element. If there was not, popUntil leaves\n-// the stack unchanged.\n+// is in matchTags, provided there is no higher element in the scope's stop\n+// tags (as defined in section 12.2.3.2). It returns whether or not there was\n+// such an element. If there was not, popUntil leaves the stack unchanged.\n //\n-// For example, if the stack was:\n+// For example, the set of stop tags for table scope is: \"html\", \"table\". If\n+// the stack was:\n // [\"html\", \"body\", \"font\", \"table\", \"b\", \"i\", \"u\"]\n-// then popUntil([]string{\"html, \"table\"}, \"font\") would return false, but\n-// popUntil([]string{\"html, \"table\"}, \"i\") would return true and the resultant\n-// stack would be:\n+// then popUntil(tableScope, \"font\") would return false, but\n+// popUntil(tableScope, \"i\") would return true and the stack would become:\n // [\"html\", \"body\", \"font\", \"table\", \"b\"]\n //\n-// If an element's tag is in both stopTags and matchTags, then the stack will\n-// be popped and the function returns true (provided, of course, there was no\n-// higher element in the stack that was also in stopTags). For example,\n-// popUntil([]string{\"html, \"table\"}, \"table\") would return true and leave:\n+// If an element's tag is in both the stop tags and matchTags, then the stack\n+// will be popped and the function returns true (provided, of course, there was\n+// no higher element in the stack that was also in the stop tags). For example,\n+// popUntil(tableScope, \"table\") returns true and leaves:\n // [\"html\", \"body\", \"font\"]\n-func (p *parser) popUntil(stopTags []string, matchTags ...string) bool {\n-\tif i := p.indexOfElementInScope(stopTags, matchTags...); i != -1 {\n+func (p *parser) popUntil(s scope, matchTags ...string) bool {\n+\tif i := p.indexOfElementInScope(s, matchTags...); i != -1 {\n \t\tp.oe = p.oe[:i]\n \t\treturn true\n \t}\n \treturn false\n }\n \n-// indexOfElementInScope returns the index in p.oe of the highest element\n-// whose tag is in matchTags that is in scope according to stopTags.\n-// If no matching element is in scope, it returns -1.\n-func (p *parser) indexOfElementInScope(stopTags []string, matchTags ...string) int {\n+// indexOfElementInScope returns the index in p.oe of the highest element whose\n+// tag is in matchTags that is in scope. If no matching element is in scope, it\n+// returns -1.\n+func (p *parser) indexOfElementInScope(s scope, matchTags ...string) int {\n \tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\ttag := p.oe[i].Data\n-\t\tfor _, t := range matchTags {\n-\t\t\tif t == tag {\n-\t\t\t\treturn i\n+\t\tif p.oe[i].Namespace == \"\" {\n+\t\t\tfor _, t := range matchTags {\n+\t\t\t\tif t == tag {\n+\t\t\t\t\treturn i\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tswitch s {\n+\t\t\tcase defaultScope:\n+\t\t\t\t// No-op.\n+\t\t\tcase listItemScope:\n+\t\t\t\tif tag == \"ol\" || tag == \"ul\" {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\tcase buttonScope:\n+\t\t\t\tif tag == \"button\" {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\tcase tableScope:\n+\t\t\t\tif tag == \"html\" || tag == \"table\" {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n+\t\t\tdefault:\n+\t\t\t\tpanic(\"unreachable\")\n \t\t\t}\n \t\t}\n-\t\tfor _, t := range stopTags {\n-\t\t\tif t == tag {\n-\t\t\t\treturn -1\n+\t\tswitch s {\n+\t\tcase defaultScope, listItemScope, buttonScope:\n+\t\t\tfor _, t := range defaultScopeStopTags[p.oe[i].Namespace] {\n+\t\t\t\tif t == tag {\n+\t\t\t\t\treturn -1\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -111,8 +140,30 @@ func (p *parser) indexOfElementInScope(stopTags []string, matchTags ...string) i\n \n // elementInScope is like popUntil, except that it doesn't modify the stack of\n // open elements.\n-func (p *parser) elementInScope(stopTags []string, matchTags ...string) bool {\n-\treturn p.indexOfElementInScope(stopTags, matchTags...) != -1\n+func (p *parser) elementInScope(s scope, matchTags ...string) bool {\n+\treturn p.indexOfElementInScope(s, matchTags...) != -1\n+}\n+\n+// clearStackToContext pops elements off the stack of open elements until a\n+// scope-defined element is found.\n+func (p *parser) clearStackToContext(s scope) {\n+\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\ttag := p.oe[i].Data\n+\t\tswitch s {\n+\t\tcase tableScope:\n+\t\t\tif tag == \"html\" || tag == \"table\" {\n+\t\t\t\tp.oe = p.oe[:i+1]\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tcase tableRowScope:\n+\t\t\tif tag == \"html\" || tag == \"tr\" {\n+\t\t\t\tp.oe = p.oe[:i+1]\n+\t\t\t\treturn\n+\t\t\t}\n+\t\tdefault:\n+\t\t\tpanic(\"unreachable\")\n+\t\t}\n+\t}\n }\n \n // addChild adds a child node n to the top element, and pushes n onto the stack\n@@ -192,10 +243,9 @@ func (p *parser) addText(text string) {\n // addElement calls addChild with an element node.\n func (p *parser) addElement(tag string, attr []Attribute) {\n \tp.addChild(&Node{\n-\t\tType:      ElementNode,\n-\t\tData:      tag,\n-\t\tNamespace: p.top().Namespace,\n-\t\tAttr:      attr,\n+\t\tType: ElementNode,\n+\t\tData: tag,\n+\t\tAttr: attr,\n \t})\n }\n \n@@ -624,10 +674,10 @@ func inBodyIM(p *parser) bool {\n \t\tcase \"html\":\n \t\t\tcopyAttributes(p.oe[0], p.tok)\n \t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"menu\", \"nav\", \"ol\", \"p\", \"section\", \"summary\", \"ul\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tswitch n := p.top(); n.Data {\n \t\t\tcase \"h1\", \"h2\", \"h3\", \"h4\", \"h5\", \"h6\":\n \t\t\t\tp.oe.pop()\n@@ -649,7 +699,7 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.addFormattingElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"nobr\":\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tif p.elementInScope(defaultScopeStopTags, \"nobr\") {\n+\t\t\tif p.elementInScope(defaultScope, \"nobr\") {\n \t\t\t\tp.inBodyEndTagFormatting(\"nobr\")\n \t\t\t\tp.reconstructActiveFormattingElements()\n \t\t\t}\n@@ -667,14 +717,14 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.framesetOK = false\n \t\tcase \"table\":\n \t\t\tif !p.quirks {\n-\t\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\t}\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n \t\t\tp.im = inTableIM\n \t\t\treturn true\n \t\tcase \"hr\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.oe.pop()\n \t\t\tp.acknowledgeSelfClosingTag()\n@@ -683,12 +733,11 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n-\t\t\t// TODO: detect <select> inside a table.\n \t\t\tp.im = inSelectIM\n \t\t\treturn true\n \t\tcase \"form\":\n \t\t\tif p.form == nil {\n-\t\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\t\tp.form = p.top()\n \t\t\t}\n@@ -698,7 +747,7 @@ func inBodyIM(p *parser) bool {\n \t\t\t\tnode := p.oe[i]\n \t\t\t\tswitch node.Data {\n \t\t\t\tcase \"li\":\n-\t\t\t\t\tp.popUntil(listItemScopeStopTags, \"li\")\n+\t\t\t\t\tp.popUntil(listItemScope, \"li\")\n \t\t\t\tcase \"address\", \"div\", \"p\":\n \t\t\t\t\tcontinue\n \t\t\t\tdefault:\n@@ -708,7 +757,7 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"dd\", \"dt\":\n \t\t\tp.framesetOK = false\n@@ -726,13 +775,13 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"plaintext\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"button\":\n-\t\t\tp.popUntil(defaultScopeStopTags, \"button\")\n+\t\t\tp.popUntil(defaultScope, \"button\")\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.framesetOK = false\n@@ -750,6 +799,19 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t\tcopyAttributes(body, p.tok)\n \t\t\t\t}\n \t\t\t}\n+\t\tcase \"frameset\":\n+\t\t\tif !p.framesetOK || len(p.oe) < 2 || p.oe[1].Data != \"body\" {\n+\t\t\t\t// Ignore the token.\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t\tbody := p.oe[1]\n+\t\t\tif body.Parent != nil {\n+\t\t\t\tbody.Parent.Remove(body)\n+\t\t\t}\n+\t\t\tp.oe = p.oe[:1]\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.im = inFramesetIM\n+\t\t\treturn true\n \t\tcase \"base\", \"basefont\", \"bgsound\", \"command\", \"link\", \"meta\", \"noframes\", \"script\", \"style\", \"title\":\n \t\t\treturn inHeadIM(p)\n \t\tcase \"image\":\n@@ -776,7 +838,7 @@ func inBodyIM(p *parser) bool {\n \t\t\t\t}\n \t\t\t}\n \t\t\tp.acknowledgeSelfClosingTag()\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.addElement(\"form\", nil)\n \t\t\tp.form = p.top()\n \t\t\tif action != \"\" {\n@@ -794,23 +856,20 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.oe.pop()\n \t\t\tp.form = nil\n \t\tcase \"xmp\":\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\t\tp.reconstructActiveFormattingElements()\n \t\t\tp.framesetOK = false\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\tcase \"math\", \"svg\":\n \t\t\tp.reconstructActiveFormattingElements()\n-\t\t\tnamespace := \"\"\n \t\t\tif p.tok.Data == \"math\" {\n \t\t\t\t// TODO: adjust MathML attributes.\n-\t\t\t\tnamespace = \"mathml\"\n \t\t\t} else {\n \t\t\t\t// TODO: adjust SVG attributes.\n-\t\t\t\tnamespace = \"svg\"\n \t\t\t}\n-\t\t\t// TODO: adjust foreign attributes.\n+\t\t\tadjustForeignAttributes(p.tok.Attr)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n-\t\t\tp.top().Namespace = namespace\n+\t\t\tp.top().Namespace = p.tok.Data\n \t\t\treturn true\n \t\tcase \"caption\", \"col\", \"colgroup\", \"frame\", \"head\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// Ignore the token.\n@@ -825,16 +884,16 @@ func inBodyIM(p *parser) bool {\n \t\t\tp.im = afterBodyIM\n \t\t\treturn true\n \t\tcase \"p\":\n-\t\t\tif !p.elementInScope(buttonScopeStopTags, \"p\") {\n+\t\t\tif !p.elementInScope(buttonScope, \"p\") {\n \t\t\t\tp.addElement(\"p\", nil)\n \t\t\t}\n-\t\t\tp.popUntil(buttonScopeStopTags, \"p\")\n+\t\t\tp.popUntil(buttonScope, \"p\")\n \t\tcase \"a\", \"b\", \"big\", \"code\", \"em\", \"font\", \"i\", \"nobr\", \"s\", \"small\", \"strike\", \"strong\", \"tt\", \"u\":\n \t\t\tp.inBodyEndTagFormatting(p.tok.Data)\n \t\tcase \"address\", \"article\", \"aside\", \"blockquote\", \"button\", \"center\", \"details\", \"dir\", \"div\", \"dl\", \"fieldset\", \"figcaption\", \"figure\", \"footer\", \"header\", \"hgroup\", \"listing\", \"menu\", \"nav\", \"ol\", \"pre\", \"section\", \"summary\", \"ul\":\n-\t\t\tp.popUntil(defaultScopeStopTags, p.tok.Data)\n+\t\t\tp.popUntil(defaultScope, p.tok.Data)\n \t\tcase \"applet\", \"marquee\", \"object\":\n-\t\t\tif p.popUntil(defaultScopeStopTags, p.tok.Data) {\n+\t\t\tif p.popUntil(defaultScope, p.tok.Data) {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t}\n \t\tcase \"br\":\n@@ -883,7 +942,7 @@ func (p *parser) inBodyEndTagFormatting(tag string) {\n \t\t\tp.afe.remove(formattingElement)\n \t\t\treturn\n \t\t}\n-\t\tif !p.elementInScope(defaultScopeStopTags, tag) {\n+\t\tif !p.elementInScope(defaultScope, tag) {\n \t\t\t// Ignore the tag.\n \t\t\treturn\n \t\t}\n@@ -1017,45 +1076,56 @@ func inTableIM(p *parser) bool {\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"caption\":\n-\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.afe = append(p.afe, &scopeMarker)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.im = inCaptionIM\n \t\t\treturn true\n \t\tcase \"tbody\", \"tfoot\", \"thead\":\n-\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.im = inTableBodyIM\n \t\t\treturn true\n \t\tcase \"td\", \"th\", \"tr\":\n-\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.addElement(\"tbody\", nil)\n \t\t\tp.im = inTableBodyIM\n \t\t\treturn false\n \t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n+\t\t\tif p.popUntil(tableScope, \"table\") {\n \t\t\t\tp.resetInsertionMode()\n \t\t\t\treturn false\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\tcase \"colgroup\":\n-\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.im = inColumnGroupIM\n \t\t\treturn true\n \t\tcase \"col\":\n-\t\t\tp.clearStackToContext(tableScopeStopTags)\n+\t\t\tp.clearStackToContext(tableScope)\n \t\t\tp.addElement(\"colgroup\", p.tok.Attr)\n \t\t\tp.im = inColumnGroupIM\n \t\t\treturn false\n+\t\tcase \"select\":\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tswitch p.top().Data {\n+\t\t\tcase \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n+\t\t\t\tp.fosterParenting = true\n+\t\t\t}\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.fosterParenting = false\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = inSelectInTableIM\n+\t\t\treturn true\n \t\tdefault:\n \t\t\t// TODO.\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"table\") {\n+\t\t\tif p.popUntil(tableScope, \"table\") {\n \t\t\t\tp.resetInsertionMode()\n \t\t\t\treturn true\n \t\t\t}\n@@ -1082,44 +1152,37 @@ func inTableIM(p *parser) bool {\n \treturn inBodyIM(p)\n }\n \n-// clearStackToContext pops elements off the stack of open elements\n-// until an element listed in stopTags is found.\n-func (p *parser) clearStackToContext(stopTags []string) {\n-\tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\tfor _, tag := range stopTags {\n-\t\t\tif p.oe[i].Data == tag {\n-\t\t\t\tp.oe = p.oe[:i+1]\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n // Section 12.2.5.4.11.\n func inCaptionIM(p *parser) bool {\n \tswitch p.tok.Type {\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\tif p.popUntil(tableScope, \"caption\") {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n \t\t\t} else {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n+\t\tcase \"select\":\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = inSelectInTableIM\n+\t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"caption\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\tif p.popUntil(tableScope, \"caption\") {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t}\n \t\t\treturn true\n \t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"caption\") {\n+\t\t\tif p.popUntil(tableScope, \"caption\") {\n \t\t\t\tp.clearActiveFormattingElements()\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n@@ -1203,7 +1266,7 @@ func inTableBodyIM(p *parser) bool {\n \t\t\tdata = \"tr\"\n \t\t\tconsumed = false\n \t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\":\n-\t\t\tif !p.popUntil(tableScopeStopTags, \"tbody\", \"thead\", \"tfoot\") {\n+\t\t\tif !p.popUntil(tableScope, \"tbody\", \"thead\", \"tfoot\") {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n@@ -1215,7 +1278,7 @@ func inTableBodyIM(p *parser) bool {\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"tbody\", \"thead\", \"tfoot\") {\n+\t\t\tif p.popUntil(tableScope, \"tbody\", \"thead\", \"tfoot\") {\n \t\t\t\tp.im = inTableIM\n \t\t\t\treturn false\n \t\t\t}\n@@ -1251,13 +1314,13 @@ func inRowIM(p *parser) bool {\n \tcase StartTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"td\", \"th\":\n-\t\t\tp.clearStackToContext(tableRowContextStopTags)\n+\t\t\tp.clearStackToContext(tableRowScope)\n \t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n \t\t\tp.afe = append(p.afe, &scopeMarker)\n \t\t\tp.im = inCellIM\n \t\t\treturn true\n \t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"tfoot\", \"thead\", \"tr\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n+\t\t\tif p.popUntil(tableScope, \"tr\") {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn false\n \t\t\t}\n@@ -1269,14 +1332,14 @@ func inRowIM(p *parser) bool {\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"tr\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n+\t\t\tif p.popUntil(tableScope, \"tr\") {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn true\n \t\t\t}\n \t\t\t// Ignore the token.\n \t\t\treturn true\n \t\tcase \"table\":\n-\t\t\tif p.popUntil(tableScopeStopTags, \"tr\") {\n+\t\t\tif p.popUntil(tableScope, \"tr\") {\n \t\t\t\tp.im = inTableBodyIM\n \t\t\t\treturn false\n \t\t\t}\n@@ -1311,11 +1374,17 @@ func inCellIM(p *parser) bool {\n \t\tcase \"caption\", \"col\", \"colgroup\", \"tbody\", \"td\", \"tfoot\", \"th\", \"thead\", \"tr\":\n \t\t\t// TODO: check for \"td\" or \"th\" in table scope.\n \t\t\tcloseTheCellAndReprocess = true\n+\t\tcase \"select\":\n+\t\t\tp.reconstructActiveFormattingElements()\n+\t\t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\t\tp.framesetOK = false\n+\t\t\tp.im = inSelectInTableIM\n+\t\t\treturn true\n \t\t}\n \tcase EndTagToken:\n \t\tswitch p.tok.Data {\n \t\tcase \"td\", \"th\":\n-\t\t\tif !p.popUntil(tableScopeStopTags, p.tok.Data) {\n+\t\t\tif !p.popUntil(tableScope, p.tok.Data) {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n@@ -1336,7 +1405,7 @@ func inCellIM(p *parser) bool {\n \t\treturn true\n \t}\n \tif closeTheCellAndReprocess {\n-\t\tif p.popUntil(tableScopeStopTags, \"td\") || p.popUntil(tableScopeStopTags, \"th\") {\n+\t\tif p.popUntil(tableScope, \"td\") || p.popUntil(tableScope, \"th\") {\n \t\t\tp.clearActiveFormattingElements()\n \t\t\tp.im = inRowIM\n \t\t\treturn false\n@@ -1405,21 +1474,40 @@ func inSelectIM(p *parser) bool {\n \t\t})\n \t}\n \tif endSelect {\n-\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n-\t\t\tswitch p.oe[i].Data {\n-\t\t\tcase \"select\":\n-\t\t\t\tp.oe = p.oe[:i]\n-\t\t\t\tp.resetInsertionMode()\n-\t\t\t\treturn true\n-\t\t\tcase \"option\", \"optgroup\":\n-\t\t\t\tcontinue\n-\t\t\tdefault:\n+\t\tp.endSelect()\n+\t}\n+\treturn true\n+}\n+\n+// Section 12.2.5.4.17.\n+func inSelectInTableIM(p *parser) bool {\n+\tswitch p.tok.Type {\n+\tcase StartTagToken, EndTagToken:\n+\t\tswitch p.tok.Data {\n+\t\tcase \"caption\", \"table\", \"tbody\", \"tfoot\", \"thead\", \"tr\", \"td\", \"th\":\n+\t\t\tif p.tok.Type == StartTagToken || p.elementInScope(tableScope, p.tok.Data) {\n+\t\t\t\tp.endSelect()\n+\t\t\t\treturn false\n+\t\t\t} else {\n \t\t\t\t// Ignore the token.\n \t\t\t\treturn true\n \t\t\t}\n \t\t}\n \t}\n-\treturn true\n+\treturn inSelectIM(p)\n+}\n+\n+func (p *parser) endSelect() {\n+\tfor i := len(p.oe) - 1; i >= 0; i-- {\n+\t\tswitch p.oe[i].Data {\n+\t\tcase \"option\", \"optgroup\":\n+\t\t\tcontinue\n+\t\tcase \"select\":\n+\t\t\tp.oe = p.oe[:i]\n+\t\t\tp.resetInsertionMode()\n+\t\t}\n+\t\treturn\n+\t}\n }\n \n // Section 12.2.5.4.18.\n@@ -1618,6 +1706,11 @@ func parseForeignContent(p *parser) bool {\n \t\t\tData: p.tok.Data,\n \t\t})\n \tcase StartTagToken:\n+\t\tif htmlIntegrationPoint(p.top()) {\n+\t\t\tinBodyIM(p)\n+\t\t\tp.resetInsertionMode()\n+\t\t\treturn true\n+\t\t}\n \t\tif breakout[p.tok.Data] {\n \t\t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\t\t\t// TODO: HTML, MathML integration points.\n@@ -1629,16 +1722,22 @@ func parseForeignContent(p *parser) bool {\n \t\t\treturn false\n \t\t}\n \t\tswitch p.top().Namespace {\n-\t\tcase \"mathml\":\n+\t\tcase \"math\":\n \t\t\t// TODO: adjust MathML attributes.\n \t\tcase \"svg\":\n-\t\t\t// TODO: adjust SVG tag names.\n+\t\t\t// Adjust SVG tag names. The tokenizer lower-cases tag names, but\n+\t\t\t// SVG wants e.g. \"foreignObject\" with a capital second \"O\".\n+\t\t\tif x := svgTagNameAdjustments[p.tok.Data]; x != \"\" {\n+\t\t\t\tp.tok.Data = x\n+\t\t\t}\n \t\t\t// TODO: adjust SVG attributes.\n \t\tdefault:\n \t\t\tpanic(\"html: bad parser state: unexpected namespace\")\n \t\t}\n-\t\t// TODO: adjust foreign attributes.\n+\t\tadjustForeignAttributes(p.tok.Attr)\n+\t\tnamespace := p.top().Namespace\n \t\tp.addElement(p.tok.Data, p.tok.Attr)\n+\t\tp.top().Namespace = namespace\n \tcase EndTagToken:\n \t\tfor i := len(p.oe) - 1; i >= 0; i-- {\n \t\t\tif p.oe[i].Namespace == \"\" {"}, {"sha": "c929c257727f2e27fbdef26bd2645d18b3b7083a", "filename": "libgo/go/html/parse_test.go", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fparse_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Fparse_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Fparse_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -103,10 +103,21 @@ func dumpLevel(w io.Writer, n *Node, level int) error {\n \t\t} else {\n \t\t\tfmt.Fprintf(w, \"<%s>\", n.Data)\n \t\t}\n-\t\tfor _, a := range n.Attr {\n+\t\tattr := n.Attr\n+\t\tif len(attr) == 2 && attr[0].Namespace == \"xml\" && attr[1].Namespace == \"xlink\" {\n+\t\t\t// Some of the test cases in tests10.dat change the order of adjusted\n+\t\t\t// foreign attributes, but that behavior is not in the spec, and could\n+\t\t\t// simply be an implementation detail of html5lib's python map ordering.\n+\t\t\tattr[0], attr[1] = attr[1], attr[0]\n+\t\t}\n+\t\tfor _, a := range attr {\n \t\t\tio.WriteString(w, \"\\n\")\n \t\t\tdumpIndent(w, level+1)\n-\t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n+\t\t\tif a.Namespace != \"\" {\n+\t\t\t\tfmt.Fprintf(w, `%s %s=\"%s\"`, a.Namespace, a.Key, a.Val)\n+\t\t\t} else {\n+\t\t\t\tfmt.Fprintf(w, `%s=\"%s\"`, a.Key, a.Val)\n+\t\t\t}\n \t\t}\n \tcase TextNode:\n \t\tfmt.Fprintf(w, `\"%s\"`, n.Data)\n@@ -172,8 +183,8 @@ func TestParser(t *testing.T) {\n \t\t{\"tests3.dat\", -1},\n \t\t{\"tests4.dat\", -1},\n \t\t{\"tests5.dat\", -1},\n-\t\t{\"tests6.dat\", 47},\n-\t\t{\"tests10.dat\", 16},\n+\t\t{\"tests6.dat\", -1},\n+\t\t{\"tests10.dat\", 33},\n \t}\n \tfor _, tf := range testFiles {\n \t\tf, err := os.Open(\"testdata/webkit/\" + tf.filename)"}, {"sha": "07859faa7dd833df71f5410bdf67e044ec3aa437", "filename": "libgo/go/html/render.go", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Frender.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Frender.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Frender.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -149,6 +149,14 @@ func render1(w writer, n *Node) error {\n \t\tif err := w.WriteByte(' '); err != nil {\n \t\t\treturn err\n \t\t}\n+\t\tif a.Namespace != \"\" {\n+\t\t\tif _, err := w.WriteString(a.Namespace); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t\tif err := w.WriteByte(':'); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n \t\tif _, err := w.WriteString(a.Key); err != nil {\n \t\t\treturn err\n \t\t}"}, {"sha": "2ce1fb566a59d079647993c14a5664ccdf94743e", "filename": "libgo/go/html/template/escape_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftemplate%2Fescape_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -302,7 +302,7 @@ func TestEscape(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t\"styleObfuscatedExpressionBlocked\",\n-\t\t\t`<p style=\"width: {{\"  e\\78preS\\0Sio/**/n(alert(1337))\"}}\">`,\n+\t\t\t`<p style=\"width: {{\"  e\\\\78preS\\x00Sio/**/n(alert(1337))\"}}\">`,\n \t\t\t`<p style=\"width: ZgotmplZ\">`,\n \t\t},\n \t\t{\n@@ -312,7 +312,7 @@ func TestEscape(t *testing.T) {\n \t\t},\n \t\t{\n \t\t\t\"styleObfuscatedMozBindingBlocked\",\n-\t\t\t`<p style=\"{{\"  -mo\\7a-B\\0I/**/nding(alert(1337))\"}}: ...\">`,\n+\t\t\t`<p style=\"{{\"  -mo\\\\7a-B\\x00I/**/nding(alert(1337))\"}}: ...\">`,\n \t\t\t`<p style=\"ZgotmplZ: ...\">`,\n \t\t},\n \t\t{"}, {"sha": "5a385a1b5c544df4fd762e0e6e7c926d4a825b4e", "filename": "libgo/go/html/token.go", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Ftoken.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fhtml%2Ftoken.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fhtml%2Ftoken.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -52,11 +52,14 @@ func (t TokenType) String() string {\n \treturn \"Invalid(\" + strconv.Itoa(int(t)) + \")\"\n }\n \n-// An Attribute is an attribute key-value pair. Key is alphabetic (and hence\n+// An Attribute is an attribute namespace-key-value triple. Namespace is\n+// non-empty for foreign attributes like xlink, Key is alphabetic (and hence\n // does not contain escapable characters like '&', '<' or '>'), and Val is\n // unescaped (it looks like \"a<b\" rather than \"a&lt;b\").\n+//\n+// Namespace is only used by the parser, not the tokenizer.\n type Attribute struct {\n-\tKey, Val string\n+\tNamespace, Key, Val string\n }\n \n // A Token consists of a TokenType and some Data (tag name for start and end\n@@ -756,7 +759,7 @@ func (z *Tokenizer) Token() Token {\n \t\tfor moreAttr {\n \t\t\tvar key, val []byte\n \t\t\tkey, val, moreAttr = z.TagAttr()\n-\t\t\tattr = append(attr, Attribute{string(key), string(val)})\n+\t\t\tattr = append(attr, Attribute{\"\", string(key), string(val)})\n \t\t}\n \t\tt.Data = string(name)\n \t\tt.Attr = attr"}, {"sha": "b830f88e1c454cb760aedd0b954b888447a8408a", "filename": "libgo/go/image/names.go", "status": "modified", "additions": 11, "deletions": 11, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fimage%2Fnames.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fimage%2Fnames.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fimage%2Fnames.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -51,25 +51,25 @@ func NewUniform(c color.Color) *Uniform {\n \treturn &Uniform{c}\n }\n \n-// A Tiled is an infinite-sized Image that repeats another Image in both\n-// directions. Tiled{i, p}.At(x, y) will equal i.At(x+p.X, y+p.Y) for all\n+// Repeated is an infinite-sized Image that repeats another Image in both\n+// directions. Repeated{i, p}.At(x, y) will equal i.At(x+p.X, y+p.Y) for all\n // points {x+p.X, y+p.Y} within i's Bounds.\n-type Tiled struct {\n+type Repeated struct {\n \tI      Image\n \tOffset Point\n }\n \n-func (t *Tiled) ColorModel() color.Model {\n-\treturn t.I.ColorModel()\n+func (r *Repeated) ColorModel() color.Model {\n+\treturn r.I.ColorModel()\n }\n \n-func (t *Tiled) Bounds() Rectangle { return Rectangle{Point{-1e9, -1e9}, Point{1e9, 1e9}} }\n+func (r *Repeated) Bounds() Rectangle { return Rectangle{Point{-1e9, -1e9}, Point{1e9, 1e9}} }\n \n-func (t *Tiled) At(x, y int) color.Color {\n-\tp := Point{x, y}.Add(t.Offset).Mod(t.I.Bounds())\n-\treturn t.I.At(p.X, p.Y)\n+func (r *Repeated) At(x, y int) color.Color {\n+\tp := Point{x, y}.Add(r.Offset).Mod(r.I.Bounds())\n+\treturn r.I.At(p.X, p.Y)\n }\n \n-func NewTiled(i Image, offset Point) *Tiled {\n-\treturn &Tiled{i, offset}\n+func NewRepeated(i Image, offset Point) *Repeated {\n+\treturn &Repeated{i, offset}\n }"}, {"sha": "aef63480f161682b9066a432337ca8a54164bad2", "filename": "libgo/go/log/syslog/syslog.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Flog%2Fsyslog%2Fsyslog.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -93,13 +93,19 @@ func (w *Writer) Emerg(m string) (err error) {\n \treturn err\n }\n \n+// Alert logs a message using the LOG_ALERT priority.\n+func (w *Writer) Alert(m string) (err error) {\n+\t_, err = w.writeString(LOG_ALERT, m)\n+\treturn err\n+}\n+\n // Crit logs a message using the LOG_CRIT priority.\n func (w *Writer) Crit(m string) (err error) {\n \t_, err = w.writeString(LOG_CRIT, m)\n \treturn err\n }\n \n-// ERR logs a message using the LOG_ERR priority.\n+// Err logs a message using the LOG_ERR priority.\n func (w *Writer) Err(m string) (err error) {\n \t_, err = w.writeString(LOG_ERR, m)\n \treturn err"}, {"sha": "ed66a42fb0088b851b3ac29ca5e5233a705506f8", "filename": "libgo/go/math/all_test.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fmath%2Fall_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fmath%2Fall_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fall_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -2214,8 +2214,8 @@ func TestLogb(t *testing.T) {\n \t\t}\n \t}\n \tfor i := 0; i < len(vffrexpBC); i++ {\n-\t\tif e := Logb(vffrexpBC[i]); !alike(logbBC[i], e) {\n-\t\t\tt.Errorf(\"Ilogb(%g) = %g, want %g\", vffrexpBC[i], e, logbBC[i])\n+\t\tif f := Logb(vffrexpBC[i]); !alike(logbBC[i], f) {\n+\t\t\tt.Errorf(\"Logb(%g) = %g, want %g\", vffrexpBC[i], f, logbBC[i])\n \t\t}\n \t}\n }\n@@ -2536,7 +2536,7 @@ func TestLargeTan(t *testing.T) {\n }\n \n // Check that math constants are accepted by compiler\n-// and have right value (assumes strconv.Atof works).\n+// and have right value (assumes strconv.ParseFloat works).\n // http://code.google.com/p/go/issues/detail?id=201\n \n type floatTest struct {"}, {"sha": "16f6ce9ba1bc6c1dd1ee053ce02a8c556861e728", "filename": "libgo/go/math/big/nat.go", "status": "modified", "additions": 89, "deletions": 101, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fmath%2Fbig%2Fnat.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -715,13 +715,13 @@ func (x nat) decimalString() string {\n \n // string converts x to a string using digits from a charset; a digit with\n // value d is represented by charset[d]. The conversion base is determined\n-// by len(charset), which must be >= 2.\n+// by len(charset), which must be >= 2 and <= 256.\n func (x nat) string(charset string) string {\n \tb := Word(len(charset))\n \n \t// special cases\n \tswitch {\n-\tcase b < 2 || MaxBase < b:\n+\tcase b < 2 || MaxBase > 256:\n \t\tpanic(\"illegal base\")\n \tcase len(x) == 0:\n \t\treturn string(charset[0])\n@@ -773,49 +773,59 @@ func (x nat) string(charset string) string {\n \t\t\tw >>= shift\n \t\t\tnbits -= shift\n \t\t}\n+\n \t} else {\n-\t\t// determine \"big base\" as in 10^19 for 19 decimal digits in a 64 bit Word\n-\t\tbb := Word(1) // big base is b**ndigits\n-\t\tndigits := 0  // number of base b digits\n+\t\t// determine \"big base\"; i.e., the largest possible value bb\n+\t\t// that is a power of base b and still fits into a Word\n+\t\t// (as in 10^19 for 19 decimal digits in a 64bit Word)\n+\t\tbb := b      // big base is b**ndigits\n+\t\tndigits := 1 // number of base b digits\n \t\tfor max := Word(_M / b); bb <= max; bb *= b {\n \t\t\tndigits++ // maximize ndigits where bb = b**ndigits, bb <= _M\n \t\t}\n \n \t\t// construct table of successive squares of bb*leafSize to use in subdivisions\n+\t\t// result (table != nil) <=> (len(x) > leafSize > 0)\n \t\ttable := divisors(len(x), b, ndigits, bb)\n \n-\t\t// preserve x, create local copy for use in divisions\n+\t\t// preserve x, create local copy for use by convertWords\n \t\tq := nat(nil).set(x)\n \n-\t\t// convert q to string s in base b with index of MSD indicated by return value\n-\t\ti = q.convertWords(0, i, s, charset, b, ndigits, bb, table)\n+\t\t// convert q to string s in base b\n+\t\tq.convertWords(s, charset, b, ndigits, bb, table)\n+\n+\t\t// strip leading zeros\n+\t\t// (x != 0; thus s must contain at least one non-zero digit\n+\t\t// and the loop will terminate)\n+\t\ti = 0\n+\t\tfor zero := charset[0]; s[i] == zero; {\n+\t\t\ti++\n+\t\t}\n \t}\n \n \treturn string(s[i:])\n }\n \n-// Convert words of q to base b digits in s directly using iterated nat/Word divison to extract\n-// low-order Words and indirectly by recursive subdivision and nat/nat division by tabulated \n-// divisors. \n+// Convert words of q to base b digits in s. If q is large, it is recursively \"split in half\"\n+// by nat/nat division using tabulated divisors. Otherwise, it is converted iteratively using\n+// repeated nat/Word divison.\n //\n-// The direct method processes n Words by n divW() calls, each of which visits every Word in the \n+// The iterative method processes n Words by n divW() calls, each of which visits every Word in the \n // incrementally shortened q for a total of n + (n-1) + (n-2) ... + 2 + 1, or n(n+1)/2 divW()'s. \n-// Indirect conversion divides q by its approximate square root, yielding two parts, each half \n-// the size of q. Using the direct method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s plus \n-// the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and is \n-// made better by splitting the subblocks recursively. Best is to split blocks until one more \n+// Recursive conversion divides q by its approximate square root, yielding two parts, each half \n+// the size of q. Using the iterative method on both halves means 2 * (n/2)(n/2 + 1)/2 divW()'s\n+// plus the expensive long div(). Asymptotically, the ratio is favorable at 1/2 the divW()'s, and\n+// is made better by splitting the subblocks recursively. Best is to split blocks until one more \n // split would take longer (because of the nat/nat div()) than the twice as many divW()'s of the \n-// direct approach. This threshold is represented by leafSize. Benchmarking of leafSize in the \n+// iterative approach. This threshold is represented by leafSize. Benchmarking of leafSize in the \n // range 2..64 shows that values of 8 and 16 work well, with a 4x speedup at medium lengths and \n // ~30x for 20000 digits. Use nat_test.go's BenchmarkLeafSize tests to optimize leafSize for \n // specfic hardware.\n //\n-// lo and hi index character array s. conversion starts with the LSD at hi and moves down toward\n-// the MSD, which will be at s[0] or s[1]. lo == 0 signals span includes the most significant word.\n-//\n-func (q nat) convertWords(lo, hi int, s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) int {\n-\t// indirect conversion: split larger blocks to reduce quadratic expense of iterated nat/W division\n-\tif leafSize > 0 && len(q) > leafSize && table != nil {\n+func (q nat) convertWords(s []byte, charset string, b Word, ndigits int, bb Word, table []divisor) {\n+\t// split larger blocks recursively\n+\tif table != nil {\n+\t\t// len(q) > leafSize > 0\n \t\tvar r nat\n \t\tindex := len(table) - 1\n \t\tfor len(q) > leafSize {\n@@ -835,72 +845,52 @@ func (q nat) convertWords(lo, hi int, s []byte, charset string, b Word, ndigits\n \t\t\t// split q into the two digit number (q'*bbb + r) to form independent subblocks\n \t\t\tq, r = q.div(r, q, table[index].bbb)\n \n-\t\t\t// convert subblocks and collect results in s[lo:partition] and s[partition:hi]\n-\t\t\tpartition := hi - table[index].ndigits\n-\t\t\tr.convertWords(partition, hi, s, charset, b, ndigits, bb, table[0:index])\n-\t\t\thi = partition // i.e., q.convertWords(lo, partition, s, charset, b, ndigits, bb, table[0:index+1])\n+\t\t\t// convert subblocks and collect results in s[:h] and s[h:]\n+\t\t\th := len(s) - table[index].ndigits\n+\t\t\tr.convertWords(s[h:], charset, b, ndigits, bb, table[0:index])\n+\t\t\ts = s[:h] // == q.convertWords(s, charset, b, ndigits, bb, table[0:index+1])\n \t\t}\n-\t} // having split any large blocks now process the remaining small block\n+\t}\n \n-\t// direct conversion: process smaller blocks monolithically to avoid overhead of nat/nat division\n+\t// having split any large blocks now process the remaining (small) block iteratively\n+\ti := len(s)\n \tvar r Word\n-\tif b == 10 { // hard-coding for 10 here speeds this up by 1.25x (allows mod as mul vs div)\n+\tif b == 10 {\n+\t\t// hard-coding for 10 here speeds this up by 1.25x (allows for / and % by constants)\n \t\tfor len(q) > 0 {\n \t\t\t// extract least significant, base bb \"digit\"\n \t\t\tq, r = q.divW(q, bb)\n-\t\t\tif lo == 0 && len(q) == 0 {\n-\t\t\t\t// skip leading zeros in most-significant group of digits\n-\t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n-\t\t\t\t\thi--\n-\t\t\t\t\tt := r / 10\n-\t\t\t\t\ts[hi] = charset[r-(t<<3+t<<1)] // 8*t + 2*t = 10*t; r - 10*int(r/10) = r mod 10\n-\t\t\t\t\tr = t\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfor j := 0; j < ndigits && hi > lo; j++ {\n-\t\t\t\t\thi--\n-\t\t\t\t\tt := r / 10\n-\t\t\t\t\ts[hi] = charset[r-(t<<3+t<<1)] // 8*t + 2*t = 10*t; r - 10*int(r/10) = r mod 10\n-\t\t\t\t\tr = t\n-\t\t\t\t}\n+\t\t\tfor j := 0; j < ndigits && i > 0; j++ {\n+\t\t\t\ti--\n+\t\t\t\t// avoid % computation since r%10 == r - int(r/10)*10;\n+\t\t\t\t// this appears to be faster for BenchmarkString10000Base10\n+\t\t\t\t// and smaller strings (but a bit slower for larger ones)\n+\t\t\t\tt := r / 10\n+\t\t\t\ts[i] = charset[r-t<<3-t-t] // TODO(gri) replace w/ t*10 once compiler produces better code\n+\t\t\t\tr = t\n \t\t\t}\n \t\t}\n \t} else {\n \t\tfor len(q) > 0 {\n-\t\t\t// extract least significant group of digits\n+\t\t\t// extract least significant, base bb \"digit\"\n \t\t\tq, r = q.divW(q, bb)\n-\t\t\tif lo == 0 && len(q) == 0 {\n-\t\t\t\t// skip leading zeros in most-significant group of digits\n-\t\t\t\tfor j := 0; j < ndigits && r != 0; j++ {\n-\t\t\t\t\thi--\n-\t\t\t\t\ts[hi] = charset[r%b]\n-\t\t\t\t\tr = r / b\n-\t\t\t\t}\n-\t\t\t} else {\n-\t\t\t\tfor j := 0; j < ndigits && hi > lo; j++ {\n-\t\t\t\t\thi--\n-\t\t\t\t\ts[hi] = charset[r%b]\n-\t\t\t\t\tr = r / b\n-\t\t\t\t}\n+\t\t\tfor j := 0; j < ndigits && i > 0; j++ {\n+\t\t\t\ti--\n+\t\t\t\ts[i] = charset[r%b]\n+\t\t\t\tr /= b\n \t\t\t}\n \t\t}\n \t}\n \n-\t// prepend high-order zeroes when q has been normalized to a short number of Words.\n-\t// however, do not prepend zeroes when converting the most dignificant digits.\n-\tif lo != 0 { // if not MSD\n-\t\tzero := charset[0]\n-\t\tfor hi > lo { // while need more leading zeroes\n-\t\t\thi--\n-\t\t\ts[hi] = zero\n-\t\t}\n+\t// prepend high-order zeroes\n+\tzero := charset[0]\n+\tfor i > 0 { // while need more leading zeroes\n+\t\ti--\n+\t\ts[i] = zero\n \t}\n-\n-\t// return index of most significant output digit in s[] (stored in lowest index)\n-\treturn hi\n }\n \n-// Split blocks greater than leafSize Words (or set to 0 to disable indirect conversion)\n+// Split blocks greater than leafSize Words (or set to 0 to disable recursive conversion)\n // Benchmark and configure leafSize using: gotest -test.bench=\"Leaf\"\n //   8 and 16 effective on 3.0 GHz Xeon \"Clovertown\" CPU (128 byte cache lines)\n //   8 and 16 effective on 2.66 GHz Core 2 Duo \"Penryn\" CPU\n@@ -912,26 +902,30 @@ type divisor struct {\n \tndigits int // digit length of divisor in terms of output base digits\n }\n \n-const maxCache = 64               // maximum number of divisors in a single table\n-var cacheBase10 [maxCache]divisor // cached divisors for base 10\n-var cacheLock sync.Mutex          // defense against concurrent table extensions\n+var cacheBase10 [64]divisor // cached divisors for base 10\n+var cacheLock sync.Mutex    // protects cacheBase10\n+\n+// expWW computes x**y\n+func (z nat) expWW(x, y Word) nat {\n+\treturn z.expNN(nat(nil).setWord(x), nat(nil).setWord(y), nil)\n+}\n \n // construct table of powers of bb*leafSize to use in subdivisions\n func divisors(m int, b Word, ndigits int, bb Word) []divisor {\n-\t// only build table when indirect conversion is enabled and x is large\n+\t// only compute table when recursive conversion is enabled and x is large\n \tif leafSize == 0 || m <= leafSize {\n \t\treturn nil\n \t}\n \n \t// determine k where (bb**leafSize)**(2**k) >= sqrt(x)\n \tk := 1\n-\tfor words := leafSize; words < m>>1 && k < maxCache; words <<= 1 {\n+\tfor words := leafSize; words < m>>1 && k < len(cacheBase10); words <<= 1 {\n \t\tk++\n \t}\n \n \t// create new table of divisors or extend and reuse existing table as appropriate\n-\tvar cached bool\n \tvar table []divisor\n+\tvar cached bool\n \tswitch b {\n \tcase 10:\n \t\ttable = cacheBase10[0:k] // reuse old table for this conversion\n@@ -946,28 +940,27 @@ func divisors(m int, b Word, ndigits int, bb Word) []divisor {\n \t\t\tcacheLock.Lock() // begin critical section\n \t\t}\n \n-\t\tvar i int\n+\t\t// add new entries as needed\n \t\tvar larger nat\n-\t\tfor i < k && table[i].ndigits != 0 { // skip existing entries\n-\t\t\ti++\n-\t\t}\n-\t\tfor ; i < k; i++ { // add new entries\n-\t\t\tif i == 0 {\n-\t\t\t\ttable[i].bbb = nat(nil).expWW(bb, Word(leafSize))\n-\t\t\t\ttable[i].ndigits = ndigits * leafSize\n-\t\t\t} else {\n-\t\t\t\ttable[i].bbb = nat(nil).mul(table[i-1].bbb, table[i-1].bbb)\n-\t\t\t\ttable[i].ndigits = 2 * table[i-1].ndigits\n-\t\t\t}\n+\t\tfor i := 0; i < k; i++ {\n+\t\t\tif table[i].ndigits == 0 {\n+\t\t\t\tif i == 0 {\n+\t\t\t\t\ttable[i].bbb = nat(nil).expWW(bb, Word(leafSize))\n+\t\t\t\t\ttable[i].ndigits = ndigits * leafSize\n+\t\t\t\t} else {\n+\t\t\t\t\ttable[i].bbb = nat(nil).mul(table[i-1].bbb, table[i-1].bbb)\n+\t\t\t\t\ttable[i].ndigits = 2 * table[i-1].ndigits\n+\t\t\t\t}\n \n-\t\t\t// optimization: exploit aggregated extra bits in macro blocks\n-\t\t\tlarger = nat(nil).set(table[i].bbb)\n-\t\t\tfor mulAddVWW(larger, larger, b, 0) == 0 {\n-\t\t\t\ttable[i].bbb = table[i].bbb.set(larger)\n-\t\t\t\ttable[i].ndigits++\n-\t\t\t}\n+\t\t\t\t// optimization: exploit aggregated extra bits in macro blocks\n+\t\t\t\tlarger = nat(nil).set(table[i].bbb)\n+\t\t\t\tfor mulAddVWW(larger, larger, b, 0) == 0 {\n+\t\t\t\t\ttable[i].bbb = table[i].bbb.set(larger)\n+\t\t\t\t\ttable[i].ndigits++\n+\t\t\t\t}\n \n-\t\t\ttable[i].nbits = table[i].bbb.bitLen()\n+\t\t\t\ttable[i].nbits = table[i].bbb.bitLen()\n+\t\t\t}\n \t\t}\n \n \t\tif cached {\n@@ -1295,11 +1288,6 @@ func (z nat) expNN(x, y, m nat) nat {\n \treturn z.norm()\n }\n \n-// calculate x**y for Word arguments y and y\n-func (z nat) expWW(x, y Word) nat {\n-\treturn z.expNN(nat(nil).setWord(x), nat(nil).setWord(y), nil)\n-}\n-\n // probablyPrime performs reps Miller-Rabin tests to check whether n is prime.\n // If it returns true, n is prime with probability 1 - 1/4^reps.\n // If it returns false, n is not prime."}, {"sha": "868388efa1cd7d6b7249226d31418f63d9169855", "filename": "libgo/go/net/file_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ffile_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"os\"\n \t\"reflect\"\n \t\"runtime\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -67,7 +66,7 @@ func TestFileListener(t *testing.T) {\n \t\ttestFileListener(t, \"tcp\", \"127.0.0.1\")\n \t\ttestFileListener(t, \"tcp\", \"[::ffff:127.0.0.1]\")\n \t}\n-\tif syscall.OS == \"linux\" {\n+\tif runtime.GOOS == \"linux\" {\n \t\ttestFileListener(t, \"unix\", \"@gotest/net\")\n \t\ttestFileListener(t, \"unixpacket\", \"@gotest/net\")\n \t}\n@@ -132,7 +131,7 @@ func TestFilePacketConn(t *testing.T) {\n \tif supportsIPv6 && supportsIPv4map {\n \t\ttestFilePacketConnDial(t, \"udp\", \"[::ffff:127.0.0.1]:12345\")\n \t}\n-\tif syscall.OS == \"linux\" {\n+\tif runtime.GOOS == \"linux\" {\n \t\ttestFilePacketConnListen(t, \"unixgram\", \"@gotest1/net\")\n \t}\n }"}, {"sha": "2e30bbff1777e1ac0e7872e3d4b3d5e8a8179bb1", "filename": "libgo/go/net/http/cookie.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Fcookie.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -96,7 +96,7 @@ func readSetCookies(h Header) []*Cookie {\n \t\t\t\tcontinue\n \t\t\tcase \"max-age\":\n \t\t\t\tsecs, err := strconv.Atoi(val)\n-\t\t\t\tif err != nil || secs < 0 || secs != 0 && val[0] == '0' {\n+\t\t\t\tif err != nil || secs != 0 && val[0] == '0' {\n \t\t\t\t\tbreak\n \t\t\t\t}\n \t\t\t\tif secs <= 0 {"}, {"sha": "260301005ebb13374b7ef082abe4f0aa81308855", "filename": "libgo/go/net/http/request.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fhttp%2Frequest.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -368,8 +368,8 @@ func (req *Request) write(w io.Writer, usingProxy bool, extraHeaders Header) err\n \tif err != nil {\n \t\treturn err\n \t}\n-\tbw.Flush()\n-\treturn nil\n+\n+\treturn bw.Flush()\n }\n \n // Convert decimal at s[i:len(s)] to integer,"}, {"sha": "5e7b352ed50012943a323d6c5847d7d281953e2a", "filename": "libgo/go/net/interface.go", "status": "modified", "additions": 14, "deletions": 6, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Finterface.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Finterface.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Finterface.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -12,6 +12,14 @@ import (\n \t\"fmt\"\n )\n \n+var (\n+\terrInvalidInterface         = errors.New(\"net: invalid interface\")\n+\terrInvalidInterfaceIndex    = errors.New(\"net: invalid interface index\")\n+\terrInvalidInterfaceName     = errors.New(\"net: invalid interface name\")\n+\terrNoSuchInterface          = errors.New(\"net: no such interface\")\n+\terrNoSuchMulticastInterface = errors.New(\"net: no such multicast interface\")\n+)\n+\n // A HardwareAddr represents a physical hardware address.\n type HardwareAddr []byte\n \n@@ -131,7 +139,7 @@ func (f Flags) String() string {\n // Addrs returns interface addresses for a specific interface.\n func (ifi *Interface) Addrs() ([]Addr, error) {\n \tif ifi == nil {\n-\t\treturn nil, errors.New(\"net: invalid interface\")\n+\t\treturn nil, errInvalidInterface\n \t}\n \treturn interfaceAddrTable(ifi.Index)\n }\n@@ -140,7 +148,7 @@ func (ifi *Interface) Addrs() ([]Addr, error) {\n // a specific interface.\n func (ifi *Interface) MulticastAddrs() ([]Addr, error) {\n \tif ifi == nil {\n-\t\treturn nil, errors.New(\"net: invalid interface\")\n+\t\treturn nil, errInvalidInterface\n \t}\n \treturn interfaceMulticastAddrTable(ifi.Index)\n }\n@@ -159,7 +167,7 @@ func InterfaceAddrs() ([]Addr, error) {\n // InterfaceByIndex returns the interface specified by index.\n func InterfaceByIndex(index int) (*Interface, error) {\n \tif index <= 0 {\n-\t\treturn nil, errors.New(\"net: invalid interface index\")\n+\t\treturn nil, errInvalidInterfaceIndex\n \t}\n \tift, err := interfaceTable(index)\n \tif err != nil {\n@@ -168,13 +176,13 @@ func InterfaceByIndex(index int) (*Interface, error) {\n \tfor _, ifi := range ift {\n \t\treturn &ifi, nil\n \t}\n-\treturn nil, errors.New(\"net: no such interface\")\n+\treturn nil, errNoSuchInterface\n }\n \n // InterfaceByName returns the interface specified by name.\n func InterfaceByName(name string) (*Interface, error) {\n \tif name == \"\" {\n-\t\treturn nil, errors.New(\"net: invalid interface name\")\n+\t\treturn nil, errInvalidInterfaceName\n \t}\n \tift, err := interfaceTable(0)\n \tif err != nil {\n@@ -185,5 +193,5 @@ func InterfaceByName(name string) (*Interface, error) {\n \t\t\treturn &ifi, nil\n \t\t}\n \t}\n-\treturn nil, errors.New(\"net: no such interface\")\n+\treturn nil, errNoSuchInterface\n }"}, {"sha": "3fd9dce05e47d2741a2c9880bae2dea56e9b411f", "filename": "libgo/go/net/iprawsock_plan9.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_plan9.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -84,8 +84,8 @@ func splitNetProto(netProto string) (net string, proto int, err error) {\n \treturn\n }\n \n-// DialIP connects to the remote address raddr on the network net,\n-// which must be \"ip\", \"ip4\", or \"ip6\".\n+// DialIP connects to the remote address raddr on the network protocol netProto,\n+// which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon and a protocol number or name.\n func DialIP(netProto string, laddr, raddr *IPAddr) (c *IPConn, err error) {\n \treturn nil, os.EPLAN9\n }"}, {"sha": "103c4f6a92555de9a45caeac69e7feb8f673476a", "filename": "libgo/go/net/iprawsock_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fiprawsock_posix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -224,8 +224,8 @@ func splitNetProto(netProto string) (net string, proto int, err error) {\n \treturn net, proto, nil\n }\n \n-// DialIP connects to the remote address raddr on the network net,\n-// which must be \"ip\", \"ip4\", or \"ip6\".\n+// DialIP connects to the remote address raddr on the network protocol netProto,\n+// which must be \"ip\", \"ip4\", or \"ip6\" followed by a colon and a protocol number or name.\n func DialIP(netProto string, laddr, raddr *IPAddr) (c *IPConn, err error) {\n \tnet, proto, err := splitNetProto(netProto)\n \tif err != nil {\n@@ -260,7 +260,7 @@ func ListenIP(netProto string, laddr *IPAddr) (c *IPConn, err error) {\n \tdefault:\n \t\treturn nil, UnknownNetworkError(net)\n \t}\n-\tfd, e := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_RAW, proto, \"dial\", sockaddrToIP)\n+\tfd, e := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_RAW, proto, \"listen\", sockaddrToIP)\n \tif e != nil {\n \t\treturn nil, e\n \t}"}, {"sha": "45fe0d9640b224b749c56af091ce0068911b0732", "filename": "libgo/go/net/ipsock_posix.go", "status": "modified", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fipsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fipsock_posix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -91,11 +91,6 @@ func favoriteAddrFamily(net string, raddr, laddr sockaddr, mode string) int {\n \treturn syscall.AF_INET6\n }\n \n-// TODO(rsc): if syscall.OS == \"linux\", we're supposed to read\n-// /proc/sys/net/core/somaxconn,\n-// to take advantage of kernels that have raised the limit.\n-func listenBacklog() int { return syscall.SOMAXCONN }\n-\n // Internet sockets (TCP, UDP)\n \n // A sockaddr represents a TCP or UDP network address that can"}, {"sha": "183d5a8abaa837c9a136525098442614709896ad", "filename": "libgo/go/net/multicast_test.go", "status": "modified", "additions": 121, "deletions": 9, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fmulticast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fmulticast_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -13,7 +13,7 @@ import (\n \n var multicast = flag.Bool(\"multicast\", false, \"enable multicast tests\")\n \n-var joinAndLeaveGroupUDPTests = []struct {\n+var multicastUDPTests = []struct {\n \tnet   string\n \tladdr IP\n \tgaddr IP\n@@ -32,16 +32,16 @@ var joinAndLeaveGroupUDPTests = []struct {\n \t{\"udp6\", IPv6unspecified, ParseIP(\"ff0e::114\"), (FlagUp | FlagLoopback), true},\n }\n \n-func TestJoinAndLeaveGroupUDP(t *testing.T) {\n-\tif runtime.GOOS == \"windows\" {\n+func TestMulticastUDP(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n \t\treturn\n \t}\n \tif !*multicast {\n \t\tt.Logf(\"test disabled; use --multicast to enable\")\n \t\treturn\n \t}\n \n-\tfor _, tt := range joinAndLeaveGroupUDPTests {\n+\tfor _, tt := range multicastUDPTests {\n \t\tvar (\n \t\t\tifi   *Interface\n \t\t\tfound bool\n@@ -51,7 +51,7 @@ func TestJoinAndLeaveGroupUDP(t *testing.T) {\n \t\t}\n \t\tift, err := Interfaces()\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"Interfaces() failed: %v\", err)\n+\t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n \t\t}\n \t\tfor _, x := range ift {\n \t\t\tif x.Flags&tt.flags == tt.flags {\n@@ -65,15 +65,20 @@ func TestJoinAndLeaveGroupUDP(t *testing.T) {\n \t\t}\n \t\tc, err := ListenUDP(tt.net, &UDPAddr{IP: tt.laddr})\n \t\tif err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Fatalf(\"ListenUDP failed: %v\", err)\n \t\t}\n \t\tdefer c.Close()\n \t\tif err := c.JoinGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Fatalf(\"JoinGroup failed: %v\", err)\n+\t\t}\n+\t\tif !tt.ipv6 {\n+\t\t\ttestIPv4MulticastSocketOptions(t, c.fd, ifi)\n+\t\t} else {\n+\t\t\ttestIPv6MulticastSocketOptions(t, c.fd, ifi)\n \t\t}\n \t\tifmat, err := ifi.MulticastAddrs()\n \t\tif err != nil {\n-\t\t\tt.Fatalf(\"MulticastAddrs() failed: %v\", err)\n+\t\t\tt.Fatalf(\"MulticastAddrs failed: %v\", err)\n \t\t}\n \t\tfor _, ifma := range ifmat {\n \t\t\tif ifma.(*IPAddr).IP.Equal(tt.gaddr) {\n@@ -85,7 +90,114 @@ func TestJoinAndLeaveGroupUDP(t *testing.T) {\n \t\t\tt.Fatalf(\"%q not found in RIB\", tt.gaddr.String())\n \t\t}\n \t\tif err := c.LeaveGroup(ifi, tt.gaddr); err != nil {\n-\t\t\tt.Fatal(err)\n+\t\t\tt.Fatalf(\"LeaveGroup failed: %v\", err)\n+\t\t}\n+\t}\n+}\n+\n+func TestSimpleMulticastUDP(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" {\n+\t\treturn\n+\t}\n+\tif !*multicast {\n+\t\tt.Logf(\"test disabled; use --multicast to enable\")\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range multicastUDPTests {\n+\t\tvar ifi *Interface\n+\t\tif tt.ipv6 {\n+\t\t\tcontinue\n+\t\t}\n+\t\ttt.flags = FlagUp | FlagMulticast\n+\t\tift, err := Interfaces()\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"Interfaces failed: %v\", err)\n+\t\t}\n+\t\tfor _, x := range ift {\n+\t\t\tif x.Flags&tt.flags == tt.flags {\n+\t\t\t\tifi = &x\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif ifi == nil {\n+\t\t\tt.Logf(\"an appropriate multicast interface not found\")\n+\t\t\treturn\n+\t\t}\n+\t\tc, err := ListenUDP(tt.net, &UDPAddr{IP: tt.laddr})\n+\t\tif err != nil {\n+\t\t\tt.Fatalf(\"ListenUDP failed: %v\", err)\n+\t\t}\n+\t\tdefer c.Close()\n+\t\tif err := c.JoinGroup(ifi, tt.gaddr); err != nil {\n+\t\t\tt.Fatalf(\"JoinGroup failed: %v\", err)\n+\t\t}\n+\t\tif err := c.LeaveGroup(ifi, tt.gaddr); err != nil {\n+\t\t\tt.Fatalf(\"LeaveGroup failed: %v\", err)\n \t\t}\n \t}\n }\n+\n+func testIPv4MulticastSocketOptions(t *testing.T, fd *netFD, ifi *Interface) {\n+\tifmc, err := ipv4MulticastInterface(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv4MulticastInterface failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv4 multicast interface: %v\", ifmc)\n+\terr = setIPv4MulticastInterface(fd, ifi)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv4MulticastInterface failed: %v\", err)\n+\t}\n+\n+\tttl, err := ipv4MulticastTTL(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv4MulticastTTL failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv4 multicast TTL: %v\", ttl)\n+\terr = setIPv4MulticastTTL(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv4MulticastTTL failed: %v\", err)\n+\t}\n+\n+\tloop, err := ipv4MulticastLoopback(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv4MulticastLoopback failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv4 multicast loopback: %v\", loop)\n+\terr = setIPv4MulticastLoopback(fd, false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv4MulticastLoopback failed: %v\", err)\n+\t}\n+}\n+\n+func testIPv6MulticastSocketOptions(t *testing.T, fd *netFD, ifi *Interface) {\n+\tifmc, err := ipv6MulticastInterface(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv6MulticastInterface failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv6 multicast interface: %v\", ifmc)\n+\terr = setIPv6MulticastInterface(fd, ifi)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv6MulticastInterface failed: %v\", err)\n+\t}\n+\n+\thoplim, err := ipv6MulticastHopLimit(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv6MulticastHopLimit failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv6 multicast hop limit: %v\", hoplim)\n+\terr = setIPv6MulticastHopLimit(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv6MulticastHopLimit failed: %v\", err)\n+\t}\n+\n+\tloop, err := ipv6MulticastLoopback(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv6MulticastLoopback failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv6 multicast loopback: %v\", loop)\n+\terr = setIPv6MulticastLoopback(fd, false)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv6MulticastLoopback failed: %v\", err)\n+\t}\n+}"}, {"sha": "ae688c0f8ca82e0ff3d76d1e60d61b6b525d09c7", "filename": "libgo/go/net/rpc/server_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Frpc%2Fserver_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -498,8 +498,7 @@ func benchmarkEndToEnd(dial func() (*Client, error), b *testing.B) {\n \tonce.Do(startServer)\n \tclient, err := dial()\n \tif err != nil {\n-\t\tfmt.Println(\"error dialing\", err)\n-\t\treturn\n+\t\tb.Fatal(\"error dialing:\", err)\n \t}\n \n \t// Synchronous calls\n@@ -534,7 +533,7 @@ func benchmarkEndToEndAsync(dial func() (*Client, error), b *testing.B) {\n \tonce.Do(startServer)\n \tclient, err := dial()\n \tif err != nil {\n-\t\tb.Fatalf(\"error dialing:\", err)\n+\t\tb.Fatal(\"error dialing:\", err)\n \t}\n \n \t// Asynchronous calls"}, {"sha": "5475d3874fe6f1e8fe12c29f4d41e68bc150d428", "filename": "libgo/go/net/server_test.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fserver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fserver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fserver_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,7 +10,6 @@ import (\n \t\"os\"\n \t\"runtime\"\n \t\"strings\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -115,7 +114,7 @@ func doTest(t *testing.T, network, listenaddr, dialaddr string) {\n }\n \n func TestTCPServer(t *testing.T) {\n-\tif syscall.OS != \"openbsd\" {\n+\tif runtime.GOOS != \"openbsd\" {\n \t\tdoTest(t, \"tcp\", \"\", \"127.0.0.1\")\n \t}\n \tdoTest(t, \"tcp\", \"0.0.0.0\", \"127.0.0.1\")\n@@ -155,7 +154,7 @@ func TestUnixServer(t *testing.T) {\n \tos.Remove(\"/tmp/gotest.net\")\n \tdoTest(t, \"unix\", \"/tmp/gotest.net\", \"/tmp/gotest.net\")\n \tos.Remove(\"/tmp/gotest.net\")\n-\tif syscall.OS == \"linux\" {\n+\tif runtime.GOOS == \"linux\" {\n \t\tdoTest(t, \"unixpacket\", \"/tmp/gotest.net\", \"/tmp/gotest.net\")\n \t\tos.Remove(\"/tmp/gotest.net\")\n \t\t// Test abstract unix domain socket, a Linux-ism\n@@ -237,7 +236,7 @@ func TestUnixDatagramServer(t *testing.T) {\n \t\tdoTestPacket(t, \"unixgram\", \"/tmp/gotest1.net\", \"/tmp/gotest1.net\", isEmpty)\n \t\tos.Remove(\"/tmp/gotest1.net\")\n \t\tos.Remove(\"/tmp/gotest1.net.local\")\n-\t\tif syscall.OS == \"linux\" {\n+\t\tif runtime.GOOS == \"linux\" {\n \t\t\t// Test abstract unix domain socket, a Linux-ism\n \t\t\tdoTestPacket(t, \"unixgram\", \"@gotest1/net\", \"@gotest1/net\", isEmpty)\n \t\t}"}, {"sha": "881c922a25f31f3cb7c3ca2ca1f526fa3f713ef0", "filename": "libgo/go/net/sock.go", "status": "modified", "additions": 2, "deletions": 86, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,18 +10,11 @@ package net\n \n import (\n \t\"io\"\n-\t\"os\"\n \t\"reflect\"\n \t\"syscall\"\n )\n \n-// Boolean to int.\n-func boolint(b bool) int {\n-\tif b {\n-\t\treturn 1\n-\t}\n-\treturn 0\n-}\n+var listenerBacklog = maxListenerBacklog()\n \n // Generic socket creation.\n func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscall.Sockaddr) Addr) (fd *netFD, err error) {\n@@ -35,7 +28,7 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \tsyscall.CloseOnExec(s)\n \tsyscall.ForkLock.RUnlock()\n \n-\tsetKernelSpecificSockopt(s, f)\n+\tsetDefaultSockopts(s, f, p)\n \n \tif la != nil {\n \t\te = syscall.Bind(s, la)\n@@ -67,83 +60,6 @@ func socket(net string, f, p, t int, la, ra syscall.Sockaddr, toAddr func(syscal\n \treturn fd, nil\n }\n \n-func setsockoptInt(fd *netFD, level, opt int, value int) error {\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, level, opt, value))\n-}\n-\n-func setsockoptNsec(fd *netFD, level, opt int, nsec int64) error {\n-\tvar tv = syscall.NsecToTimeval(nsec)\n-\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptTimeval(fd.sysfd, level, opt, &tv))\n-}\n-\n-func setReadBuffer(fd *netFD, bytes int) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes)\n-}\n-\n-func setWriteBuffer(fd *netFD, bytes int) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes)\n-}\n-\n-func setReadTimeout(fd *netFD, nsec int64) error {\n-\tfd.rdeadline_delta = nsec\n-\treturn nil\n-}\n-\n-func setWriteTimeout(fd *netFD, nsec int64) error {\n-\tfd.wdeadline_delta = nsec\n-\treturn nil\n-}\n-\n-func setTimeout(fd *netFD, nsec int64) error {\n-\tif e := setReadTimeout(fd, nsec); e != nil {\n-\t\treturn e\n-\t}\n-\treturn setWriteTimeout(fd, nsec)\n-}\n-\n-func setReuseAddr(fd *netFD, reuse bool) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse))\n-}\n-\n-func setDontRoute(fd *netFD, dontroute bool) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute))\n-}\n-\n-func setKeepAlive(fd *netFD, keepalive bool) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive))\n-}\n-\n-func setNoDelay(fd *netFD, noDelay bool) error {\n-\tfd.incref()\n-\tdefer fd.decref()\n-\treturn setsockoptInt(fd, syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(noDelay))\n-}\n-\n-func setLinger(fd *netFD, sec int) error {\n-\tvar l syscall.Linger\n-\tif sec >= 0 {\n-\t\tl.Onoff = 1\n-\t\tl.Linger = int32(sec)\n-\t} else {\n-\t\tl.Onoff = 0\n-\t\tl.Linger = 0\n-\t}\n-\tfd.incref()\n-\tdefer fd.decref()\n-\te := syscall.SetsockoptLinger(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_LINGER, &l)\n-\treturn os.NewSyscallError(\"setsockopt\", e)\n-}\n-\n type UnknownSocketError struct {\n \tsa syscall.Sockaddr\n }"}, {"sha": "630a91ed9f670d06f35658264b2d248b2f3c9848", "filename": "libgo/go/net/sock_bsd.go", "status": "modified", "additions": 18, "deletions": 18, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_bsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -1,4 +1,4 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors.  All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n@@ -9,25 +9,25 @@\n package net\n \n import (\n+\t\"runtime\"\n \t\"syscall\"\n )\n \n-func setKernelSpecificSockopt(s, f int) {\n-\t// Allow reuse of recently-used addresses.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\n-\t// Allow reuse of recently-used ports.\n-\t// This option is supported only in descendants of 4.4BSD,\n-\t// to make an effective multicast application and an application\n-\t// that requires quick draw possible.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n-\n-\t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n-\n-\tif f == syscall.AF_INET6 {\n-\t\t// using ip, tcp, udp, etc.\n-\t\t// allow both protocols even if the OS default is otherwise.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+func maxListenerBacklog() int {\n+\tvar (\n+\t\tn   uint32\n+\t\terr error\n+\t)\n+\tswitch runtime.GOOS {\n+\tcase \"darwin\", \"freebsd\":\n+\t\tn, err = syscall.SysctlUint32(\"kern.ipc.somaxconn\")\n+\tcase \"netbsd\":\n+\t\t// NOTE: NetBSD has no somaxconn-like kernel state so far\n+\tcase \"openbsd\":\n+\t\tn, err = syscall.SysctlUint32(\"kern.somaxconn\")\n+\t}\n+\tif n == 0 || err != nil {\n+\t\treturn syscall.SOMAXCONN\n \t}\n+\treturn int(n)\n }"}, {"sha": "2cbc34f24b38384482642ac59e397cd542d5463f", "filename": "libgo/go/net/sock_linux.go", "status": "modified", "additions": 17, "deletions": 15, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_linux.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -1,25 +1,27 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors.  All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n // Sockets for Linux\n \n package net\n \n-import (\n-\t\"syscall\"\n-)\n+import \"syscall\"\n \n-func setKernelSpecificSockopt(s, f int) {\n-\t// Allow reuse of recently-used addresses.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n-\n-\t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n-\n-\tif f == syscall.AF_INET6 {\n-\t\t// using ip, tcp, udp, etc.\n-\t\t// allow both protocols even if the OS default is otherwise.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+func maxListenerBacklog() int {\n+\tfd, err := open(\"/proc/sys/net/core/somaxconn\")\n+\tif err != nil {\n+\t\treturn syscall.SOMAXCONN\n+\t}\n+\tdefer fd.close()\n+\tl, ok := fd.readLine()\n+\tif !ok {\n+\t\treturn syscall.SOMAXCONN\n+\t}\n+\tf := getFields(l)\n+\tn, _, ok := dtoi(f[0], 0)\n+\tif n == 0 || !ok {\n+\t\treturn syscall.SOMAXCONN\n \t}\n+\treturn n\n }"}, {"sha": "2d803de1fc180da2e93adaa87adfaec4aa93cb11", "filename": "libgo/go/net/sock_windows.go", "status": "modified", "additions": 5, "deletions": 20, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsock_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsock_windows.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -1,29 +1,14 @@\n-// Copyright 2011 The Go Authors.  All rights reserved.\n+// Copyright 2009 The Go Authors.  All rights reserved.\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n // Sockets for Windows\n \n package net\n \n-import (\n-\t\"syscall\"\n-)\n+import \"syscall\"\n \n-func setKernelSpecificSockopt(s syscall.Handle, f int) {\n-\t// Windows will reuse recently-used addresses by default.\n-\t// SO_REUSEADDR should not be used here, as it allows\n-\t// a socket to forcibly bind to a port in use by another socket.\n-\t// This could lead to a non-deterministic behavior, where\n-\t// connection requests over the port cannot be guaranteed\n-\t// to be handled by the correct socket.\n-\n-\t// Allow broadcast.\n-\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n-\n-\tif f == syscall.AF_INET6 {\n-\t\t// using ip, tcp, udp, etc.\n-\t\t// allow both protocols even if the OS default is otherwise.\n-\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n-\t}\n+func maxListenerBacklog() int {\n+\t// TODO: Implement this\n+\treturn syscall.SOMAXCONN\n }"}, {"sha": "7fa1052b120f59cc555010a69bea00c1d631dd06", "filename": "libgo/go/net/sockopt.go", "status": "added", "additions": 171, "deletions": 0, "changes": 171, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,171 @@\n+// Copyright 2009 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+// Socket options\n+\n+package net\n+\n+import (\n+\t\"bytes\"\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// Boolean to int.\n+func boolint(b bool) int {\n+\tif b {\n+\t\treturn 1\n+\t}\n+\treturn 0\n+}\n+\n+func ipv4AddrToInterface(ip IP) (*Interface, error) {\n+\tift, err := Interfaces()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, ifi := range ift {\n+\t\tifat, err := ifi.Addrs()\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tfor _, ifa := range ifat {\n+\t\t\tswitch v := ifa.(type) {\n+\t\t\tcase *IPAddr:\n+\t\t\t\tif ip.Equal(v.IP) {\n+\t\t\t\t\treturn &ifi, nil\n+\t\t\t\t}\n+\t\t\tcase *IPNet:\n+\t\t\t\tif ip.Equal(v.IP) {\n+\t\t\t\t\treturn &ifi, nil\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\tif ip.Equal(IPv4zero) {\n+\t\treturn nil, nil\n+\t}\n+\treturn nil, errNoSuchInterface\n+}\n+\n+func interfaceToIPv4Addr(ifi *Interface) (IP, error) {\n+\tif ifi == nil {\n+\t\treturn IPv4zero, nil\n+\t}\n+\tifat, err := ifi.Addrs()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tfor _, ifa := range ifat {\n+\t\tswitch v := ifa.(type) {\n+\t\tcase *IPAddr:\n+\t\t\tif v.IP.To4() != nil {\n+\t\t\t\treturn v.IP, nil\n+\t\t\t}\n+\t\tcase *IPNet:\n+\t\t\tif v.IP.To4() != nil {\n+\t\t\t\treturn v.IP, nil\n+\t\t\t}\n+\t\t}\n+\t}\n+\treturn nil, errNoSuchInterface\n+}\n+\n+func setIPv4MreqToInterface(mreq *syscall.IPMreq, ifi *Interface) error {\n+\tif ifi == nil {\n+\t\treturn nil\n+\t}\n+\tifat, err := ifi.Addrs()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tfor _, ifa := range ifat {\n+\t\tswitch v := ifa.(type) {\n+\t\tcase *IPAddr:\n+\t\t\tif a := v.IP.To4(); a != nil {\n+\t\t\t\tcopy(mreq.Interface[:], a)\n+\t\t\t\tgoto done\n+\t\t\t}\n+\t\tcase *IPNet:\n+\t\t\tif a := v.IP.To4(); a != nil {\n+\t\t\t\tcopy(mreq.Interface[:], a)\n+\t\t\t\tgoto done\n+\t\t\t}\n+\t\t}\n+\t}\n+done:\n+\tif bytes.Equal(mreq.Multiaddr[:], IPv4zero.To4()) {\n+\t\treturn errNoSuchMulticastInterface\n+\t}\n+\treturn nil\n+}\n+\n+func setReadBuffer(fd *netFD, bytes int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_RCVBUF, bytes))\n+}\n+\n+func setWriteBuffer(fd *netFD, bytes int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_SNDBUF, bytes))\n+}\n+\n+func setReadTimeout(fd *netFD, nsec int64) error {\n+\tfd.rdeadline_delta = nsec\n+\treturn nil\n+}\n+\n+func setWriteTimeout(fd *netFD, nsec int64) error {\n+\tfd.wdeadline_delta = nsec\n+\treturn nil\n+}\n+\n+func setTimeout(fd *netFD, nsec int64) error {\n+\tif e := setReadTimeout(fd, nsec); e != nil {\n+\t\treturn e\n+\t}\n+\treturn setWriteTimeout(fd, nsec)\n+}\n+\n+func setReuseAddr(fd *netFD, reuse bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, boolint(reuse)))\n+}\n+\n+func setDontRoute(fd *netFD, dontroute bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_DONTROUTE, boolint(dontroute)))\n+}\n+\n+func setKeepAlive(fd *netFD, keepalive bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_KEEPALIVE, boolint(keepalive)))\n+}\n+\n+func setNoDelay(fd *netFD, noDelay bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_TCP, syscall.TCP_NODELAY, boolint(noDelay)))\n+}\n+\n+func setLinger(fd *netFD, sec int) error {\n+\tvar l syscall.Linger\n+\tif sec >= 0 {\n+\t\tl.Onoff = 1\n+\t\tl.Linger = int32(sec)\n+\t} else {\n+\t\tl.Onoff = 0\n+\t\tl.Linger = 0\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptLinger(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_LINGER, &l))\n+}"}, {"sha": "e99fb418cddf99e351711216fae86097735c94b0", "filename": "libgo/go/net/sockopt_bsd.go", "status": "added", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_bsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,44 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd netbsd openbsd\n+\n+// Socket options for BSD variants\n+\n+package net\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func setDefaultSockopts(s, f, p int) {\n+\tswitch f {\n+\tcase syscall.AF_INET6:\n+\t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t}\n+\n+\tif f == syscall.AF_UNIX || p == syscall.IPPROTO_TCP {\n+\t\t// Allow reuse of recently-used addresses.\n+\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\n+\t\t// Allow reuse of recently-used ports.\n+\t\t// This option is supported only in descendants of 4.4BSD,\n+\t\t// to make an effective multicast application and an application\n+\t\t// that requires quick draw possible.\n+\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+\t}\n+\n+\t// Allow broadcast.\n+\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+}\n+\n+func setDefaultMulticastSockopts(fd *netFD) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\t// Allow multicast UDP and raw IP datagram sockets to listen\n+\t// concurrently across multiple listeners.\n+\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEPORT, 1)\n+}"}, {"sha": "51583844f1f6204bfa358a3f3438d219c415c5d2", "filename": "libgo/go/net/sockopt_linux.go", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_linux.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,36 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Socket options for Linux\n+\n+package net\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func setDefaultSockopts(s, f, p int) {\n+\tswitch f {\n+\tcase syscall.AF_INET6:\n+\t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t}\n+\n+\tif f == syscall.AF_UNIX || p == syscall.IPPROTO_TCP {\n+\t\t// Allow reuse of recently-used addresses.\n+\t\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+\t}\n+\n+\t// Allow broadcast.\n+\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\n+}\n+\n+func setDefaultMulticastSockopts(fd *netFD) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\t// Allow multicast UDP and raw IP datagram sockets to listen\n+\t// concurrently across multiple listeners.\n+\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+}"}, {"sha": "485c14a2d3ecc8c610b5ad45f48cd4b8e16b9923", "filename": "libgo/go/net/sockopt_windows.go", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockopt_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockopt_windows.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,38 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Socket options for Windows\n+\n+package net\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func setDefaultSockopts(s syscall.Handle, f, p int) {\n+\tswitch f {\n+\tcase syscall.AF_INET6:\n+\t\t// Allow both IP versions even if the OS default is otherwise.\n+\t\tsyscall.SetsockoptInt(s, syscall.IPPROTO_IPV6, syscall.IPV6_V6ONLY, 0)\n+\t}\n+\n+\t// Windows will reuse recently-used addresses by default.\n+\t// SO_REUSEADDR should not be used here, as it allows\n+\t// a socket to forcibly bind to a port in use by another socket.\n+\t// This could lead to a non-deterministic behavior, where\n+\t// connection requests over the port cannot be guaranteed\n+\t// to be handled by the correct socket.\n+\n+\t// Allow broadcast.\n+\tsyscall.SetsockoptInt(s, syscall.SOL_SOCKET, syscall.SO_BROADCAST, 1)\n+\n+}\n+\n+func setDefaultMulticastSockopts(fd *netFD) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\t// Allow multicast UDP and raw IP datagram sockets to listen\n+\t// concurrently across multiple listeners.\n+\tsyscall.SetsockoptInt(fd.sysfd, syscall.SOL_SOCKET, syscall.SO_REUSEADDR, 1)\n+}"}, {"sha": "90b6f751e1d3ffaaafe9f8c3ee08079862b99e54", "filename": "libgo/go/net/sockoptip.go", "status": "added", "additions": 187, "deletions": 0, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,187 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd linux netbsd openbsd windows\n+\n+// IP-level socket options\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4TOS(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TOS)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv4TOS(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TOS, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4TTL(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TTL)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv4TTL(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_TTL, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func joinIPv4Group(fd *netFD, ifi *Interface, ip IP) error {\n+\tmreq := &syscall.IPMreq{Multiaddr: [4]byte{ip[0], ip[1], ip[2], ip[3]}}\n+\tif err := setIPv4MreqToInterface(mreq, ifi); err != nil {\n+\t\treturn err\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_ADD_MEMBERSHIP, mreq))\n+}\n+\n+func leaveIPv4Group(fd *netFD, ifi *Interface, ip IP) error {\n+\tmreq := &syscall.IPMreq{Multiaddr: [4]byte{ip[0], ip[1], ip[2], ip[3]}}\n+\tif err := setIPv4MreqToInterface(mreq, ifi); err != nil {\n+\t\treturn err\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_DROP_MEMBERSHIP, mreq))\n+}\n+\n+func ipv6HopLimit(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv6HopLimit(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_UNICAST_HOPS, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv6MulticastInterface(fd *netFD) (*Interface, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_IF)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\tif v == 0 {\n+\t\treturn nil, nil\n+\t}\n+\tifi, err := InterfaceByIndex(v)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\treturn ifi, nil\n+}\n+\n+func setIPv6MulticastInterface(fd *netFD, ifi *Interface) error {\n+\tvar v int\n+\tif ifi != nil {\n+\t\tv = ifi.Index\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_IF, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv6MulticastHopLimit(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_HOPS)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv6MulticastHopLimit(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_HOPS, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv6MulticastLoopback(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_LOOP)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv6MulticastLoopback(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_MULTICAST_LOOP, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func joinIPv6Group(fd *netFD, ifi *Interface, ip IP) error {\n+\tmreq := &syscall.IPv6Mreq{}\n+\tcopy(mreq.Multiaddr[:], ip)\n+\tif ifi != nil {\n+\t\tmreq.Interface = uint32(ifi.Index)\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_JOIN_GROUP, mreq))\n+}\n+\n+func leaveIPv6Group(fd *netFD, ifi *Interface, ip IP) error {\n+\tmreq := &syscall.IPv6Mreq{}\n+\tcopy(mreq.Multiaddr[:], ip)\n+\tif ifi != nil {\n+\t\tmreq.Interface = uint32(ifi.Index)\n+\t}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\treturn os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_LEAVE_GROUP, mreq))\n+}"}, {"sha": "5f7dff248a3ff15a575d67fbad7fee60f7ad3dfb", "filename": "libgo/go/net/sockoptip_bsd.go", "status": "added", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_bsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,54 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd netbsd openbsd\n+\n+// IP-level socket options for BSD variants\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastTTL(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn int(v), nil\n+}\n+\n+func setIPv4MulticastTTL(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, byte(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv6TrafficClass(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv6TrafficClass(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}"}, {"sha": "dedfd6f4c3aa8c65a6cc7af7ddca7c98c857ef0b", "filename": "libgo/go/net/sockoptip_darwin.go", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_darwin.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for Darwin\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\ta, err := syscall.GetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn ipv4AddrToInterface(IPv4(a[0], a[1], a[2], a[3]))\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\tip, err := interfaceToIPv4Addr(ifi)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\tvar x [4]byte\n+\tcopy(x[:], ip.To4())\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}"}, {"sha": "55f7b1a60250a27456c184405f856c6671fa8125", "filename": "libgo/go/net/sockoptip_freebsd.go", "status": "added", "additions": 80, "deletions": 0, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_freebsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,80 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for FreeBSD\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tmreq, err := syscall.GetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\tif int(mreq.Ifindex) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\treturn InterfaceByIndex(int(mreq.Ifindex))\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\tvar v int32\n+\tif ifi != nil {\n+\t\tv = int32(ifi.Index)\n+\t}\n+\tmreq := &syscall.IPMreqn{Ifindex: v}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, mreq)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}"}, {"sha": "360f8dea60a3e5bea570379ce2e25132266de8eb", "filename": "libgo/go/net/sockoptip_linux.go", "status": "added", "additions": 120, "deletions": 0, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_linux.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,120 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for Linux\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tmreq, err := syscall.GetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\tif int(mreq.Ifindex) == 0 {\n+\t\treturn nil, nil\n+\t}\n+\treturn InterfaceByIndex(int(mreq.Ifindex))\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\tvar v int32\n+\tif ifi != nil {\n+\t\tv = int32(ifi.Index)\n+\t}\n+\tmreq := &syscall.IPMreqn{Ifindex: v}\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptIPMreqn(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, mreq)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4MulticastTTL(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv4MulticastTTL(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_TTL, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_PKTINFO)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_PKTINFO, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv6TrafficClass(fd *netFD) (int, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS)\n+\tif err != nil {\n+\t\treturn -1, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v, nil\n+}\n+\n+func setIPv6TrafficClass(fd *netFD, v int) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_TCLASS, v)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}"}, {"sha": "89b8e4592079430b59882baf7d06a11c268b7b2c", "filename": "libgo/go/net/sockoptip_openbsd.go", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_openbsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,78 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for OpenBSD\n+\n+package net\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\ta, err := syscall.GetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF)\n+\tif err != nil {\n+\t\treturn nil, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn ipv4AddrToInterface(IPv4(a[0], a[1], a[2], a[3]))\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\tip, err := interfaceToIPv4Addr(ifi)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\tvar x [4]byte\n+\tcopy(x[:], ip.To4())\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr = syscall.SetsockoptInet4Addr(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_IF, x)\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptByte(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_MULTICAST_LOOP, byte(boolint(v)))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\tv, err := syscall.GetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF)\n+\tif err != nil {\n+\t\treturn false, os.NewSyscallError(\"getsockopt\", err)\n+\t}\n+\treturn v == 1, nil\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\tfd.incref()\n+\tdefer fd.decref()\n+\terr := syscall.SetsockoptInt(fd.sysfd, syscall.IPPROTO_IP, syscall.IP_RECVIF, boolint(v))\n+\tif err != nil {\n+\t\treturn os.NewSyscallError(\"setsockopt\", err)\n+\t}\n+\treturn nil\n+}"}, {"sha": "3320e76bda883b28b64e1ea615f9b46352c6ffe7", "filename": "libgo/go/net/sockoptip_windows.go", "status": "added", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fsockoptip_windows.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,61 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// IP-level socket options for Windows\n+\n+package net\n+\n+import (\n+\t\"syscall\"\n+)\n+\n+func ipv4MulticastInterface(fd *netFD) (*Interface, error) {\n+\t// TODO: Implement this\n+\treturn nil, syscall.EWINDOWS\n+}\n+\n+func setIPv4MulticastInterface(fd *netFD, ifi *Interface) error {\n+\t// TODO: Implement this\n+\treturn syscall.EWINDOWS\n+}\n+\n+func ipv4MulticastTTL(fd *netFD) (int, error) {\n+\t// TODO: Implement this\n+\treturn -1, syscall.EWINDOWS\n+}\n+\n+func setIPv4MulticastTTL(fd *netFD, v int) error {\n+\t// TODO: Implement this\n+\treturn syscall.EWINDOWS\n+}\n+\n+func ipv4MulticastLoopback(fd *netFD) (bool, error) {\n+\t// TODO: Implement this\n+\treturn false, syscall.EWINDOWS\n+}\n+\n+func setIPv4MulticastLoopback(fd *netFD, v bool) error {\n+\t// TODO: Implement this\n+\treturn syscall.EWINDOWS\n+}\n+\n+func ipv4ReceiveInterface(fd *netFD) (bool, error) {\n+\t// TODO: Implement this\n+\treturn false, syscall.EWINDOWS\n+}\n+\n+func setIPv4ReceiveInterface(fd *netFD, v bool) error {\n+\t// TODO: Implement this\n+\treturn syscall.EWINDOWS\n+}\n+\n+func ipv6TrafficClass(fd *netFD) (int, error) {\n+\t// TODO: Implement this\n+\treturn 0, syscall.EWINDOWS\n+}\n+\n+func setIPv6TrafficClass(fd *netFD, v int) error {\n+\t// TODO: Implement this\n+\treturn syscall.EWINDOWS\n+}"}, {"sha": "a492e614e35419ba95aca0e1cec32e2f8b876481", "filename": "libgo/go/net/tcpsock_posix.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftcpsock_posix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -249,10 +249,10 @@ func ListenTCP(net string, laddr *TCPAddr) (l *TCPListener, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\terrno := syscall.Listen(fd.sysfd, listenBacklog())\n-\tif errno != nil {\n+\terr = syscall.Listen(fd.sysfd, listenerBacklog)\n+\tif err != nil {\n \t\tclosesocket(fd.sysfd)\n-\t\treturn nil, &OpError{\"listen\", \"tcp\", laddr, errno}\n+\t\treturn nil, &OpError{\"listen\", \"tcp\", laddr, err}\n \t}\n \tl = new(TCPListener)\n \tl.fd = fd"}, {"sha": "862cd536c467e237ec6f56d56195ea5fa255444c", "filename": "libgo/go/net/textproto/reader.go", "status": "modified", "additions": 21, "deletions": 50, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -22,6 +22,7 @@ import (\n type Reader struct {\n \tR   *bufio.Reader\n \tdot *dotReader\n+\tbuf []byte // a re-usable buffer for readContinuedLineSlice\n }\n \n // NewReader returns a new Reader reading from r.\n@@ -121,74 +122,44 @@ func (r *Reader) readContinuedLineSlice() ([]byte, error) {\n \t// Read the first line.\n \tline, err := r.readLineSlice()\n \tif err != nil {\n-\t\treturn line, err\n+\t\treturn nil, err\n \t}\n \tif len(line) == 0 { // blank line - no continuation\n \t\treturn line, nil\n \t}\n-\tline = trim(line)\n \n-\tcopied := false\n-\tif r.R.Buffered() < 1 {\n-\t\t// ReadByte will flush the buffer; make a copy of the slice.\n-\t\tcopied = true\n-\t\tline = append([]byte(nil), line...)\n-\t}\n-\n-\t// Look for a continuation line.\n-\tc, err := r.R.ReadByte()\n-\tif err != nil {\n-\t\t// Delay err until we read the byte next time.\n-\t\treturn line, nil\n-\t}\n-\tif c != ' ' && c != '\\t' {\n-\t\t// Not a continuation.\n-\t\tr.R.UnreadByte()\n-\t\treturn line, nil\n-\t}\n-\n-\tif !copied {\n-\t\t// The next readLineSlice will invalidate the previous one.\n-\t\tline = append(make([]byte, 0, len(line)*2), line...)\n-\t}\n+\t// ReadByte or the next readLineSlice will flush the read buffer;\n+\t// copy the slice into buf.\n+\tr.buf = append(r.buf[:0], trim(line)...)\n \n \t// Read continuation lines.\n-\tfor {\n-\t\t// Consume leading spaces; one already gone.\n-\t\tfor {\n-\t\t\tc, err = r.R.ReadByte()\n-\t\t\tif err != nil {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tif c != ' ' && c != '\\t' {\n-\t\t\t\tr.R.UnreadByte()\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t}\n-\t\tvar cont []byte\n-\t\tcont, err = r.readLineSlice()\n-\t\tcont = trim(cont)\n-\t\tline = append(line, ' ')\n-\t\tline = append(line, cont...)\n+\tfor r.skipSpace() > 0 {\n+\t\tline, err := r.readLineSlice()\n \t\tif err != nil {\n \t\t\tbreak\n \t\t}\n+\t\tr.buf = append(r.buf, ' ')\n+\t\tr.buf = append(r.buf, line...)\n+\t}\n+\treturn r.buf, nil\n+}\n \n-\t\t// Check for leading space on next line.\n-\t\tif c, err = r.R.ReadByte(); err != nil {\n+// skipSpace skips R over all spaces and returns the number of bytes skipped.\n+func (r *Reader) skipSpace() int {\n+\tn := 0\n+\tfor {\n+\t\tc, err := r.R.ReadByte()\n+\t\tif err != nil {\n+\t\t\t// Bufio will keep err until next read.\n \t\t\tbreak\n \t\t}\n \t\tif c != ' ' && c != '\\t' {\n \t\t\tr.R.UnreadByte()\n \t\t\tbreak\n \t\t}\n+\t\tn++\n \t}\n-\n-\t// Delay error until next call.\n-\tif len(line) > 0 {\n-\t\terr = nil\n-\t}\n-\treturn line, err\n+\treturn n\n }\n \n func (r *Reader) readCodeLine(expectCode int) (code int, continued bool, message string, err error) {"}, {"sha": "4d036914801f9b8fb30fe51fa16be01fead1dbaa", "filename": "libgo/go/net/textproto/reader_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Ftextproto%2Freader_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -138,6 +138,15 @@ func TestReadMIMEHeader(t *testing.T) {\n \t}\n }\n \n+func TestReadMIMEHeaderSingle(t *testing.T) {\n+\tr := reader(\"Foo: bar\\n\\n\")\n+\tm, err := r.ReadMIMEHeader()\n+\twant := MIMEHeader{\"Foo\": {\"bar\"}}\n+\tif !reflect.DeepEqual(m, want) || err != nil {\n+\t\tt.Fatalf(\"ReadMIMEHeader: %v, %v; want %v\", m, err, want)\n+\t}\n+}\n+\n func TestLargeReadMIMEHeader(t *testing.T) {\n \tdata := make([]byte, 16*1024)\n \tfor i := 0; i < len(data); i++ {"}, {"sha": "d0bdb14755e4348772444095a8a3b6f079a7155c", "filename": "libgo/go/net/udpsock_posix.go", "status": "modified", "additions": 10, "deletions": 44, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Fudpsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Fudpsock_posix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,7 +9,6 @@\n package net\n \n import (\n-\t\"bytes\"\n \t\"os\"\n \t\"syscall\"\n )\n@@ -233,7 +232,7 @@ func ListenUDP(net string, laddr *UDPAddr) (c *UDPConn, err error) {\n \tif laddr == nil {\n \t\treturn nil, &OpError{\"listen\", \"udp\", nil, errMissingAddress}\n \t}\n-\tfd, e := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_DGRAM, 0, \"dial\", sockaddrToUDP)\n+\tfd, e := internetSocket(net, laddr.toAddr(), nil, syscall.SOCK_DGRAM, 0, \"listen\", sockaddrToUDP)\n \tif e != nil {\n \t\treturn nil, e\n \t}\n@@ -252,6 +251,7 @@ func (c *UDPConn) JoinGroup(ifi *Interface, addr IP) error {\n \tif !c.ok() {\n \t\treturn os.EINVAL\n \t}\n+\tsetDefaultMulticastSockopts(c.fd)\n \tip := addr.To4()\n \tif ip != nil {\n \t\treturn joinIPv4GroupUDP(c, ifi, ip)\n@@ -272,66 +272,32 @@ func (c *UDPConn) LeaveGroup(ifi *Interface, addr IP) error {\n }\n \n func joinIPv4GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n-\tmreq := &syscall.IPMreq{Multiaddr: [4]byte{ip[0], ip[1], ip[2], ip[3]}}\n-\tif err := setIPv4InterfaceToJoin(mreq, ifi); err != nil {\n-\t\treturn &OpError{\"joinipv4group\", \"udp\", &IPAddr{ip}, err}\n-\t}\n-\tif err := os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(c.fd.sysfd, syscall.IPPROTO_IP, syscall.IP_ADD_MEMBERSHIP, mreq)); err != nil {\n+\terr := joinIPv4Group(c.fd, ifi, ip)\n+\tif err != nil {\n \t\treturn &OpError{\"joinipv4group\", \"udp\", &IPAddr{ip}, err}\n \t}\n \treturn nil\n }\n \n func leaveIPv4GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n-\tmreq := &syscall.IPMreq{Multiaddr: [4]byte{ip[0], ip[1], ip[2], ip[3]}}\n-\tif err := setIPv4InterfaceToJoin(mreq, ifi); err != nil {\n-\t\treturn &OpError{\"leaveipv4group\", \"udp\", &IPAddr{ip}, err}\n-\t}\n-\tif err := os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPMreq(c.fd.sysfd, syscall.IPPROTO_IP, syscall.IP_DROP_MEMBERSHIP, mreq)); err != nil {\n-\t\treturn &OpError{\"leaveipv4group\", \"udp\", &IPAddr{ip}, err}\n-\t}\n-\treturn nil\n-}\n-\n-func setIPv4InterfaceToJoin(mreq *syscall.IPMreq, ifi *Interface) error {\n-\tif ifi == nil {\n-\t\treturn nil\n-\t}\n-\tifat, err := ifi.Addrs()\n+\terr := leaveIPv4Group(c.fd, ifi, ip)\n \tif err != nil {\n-\t\treturn err\n-\t}\n-\tfor _, ifa := range ifat {\n-\t\tif x := ifa.(*IPAddr).IP.To4(); x != nil {\n-\t\t\tcopy(mreq.Interface[:], x)\n-\t\t\tbreak\n-\t\t}\n-\t}\n-\tif bytes.Equal(mreq.Multiaddr[:], IPv4zero) {\n-\t\treturn os.EINVAL\n+\t\treturn &OpError{\"leaveipv4group\", \"udp\", &IPAddr{ip}, err}\n \t}\n \treturn nil\n }\n \n func joinIPv6GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n-\tmreq := &syscall.IPv6Mreq{}\n-\tcopy(mreq.Multiaddr[:], ip)\n-\tif ifi != nil {\n-\t\tmreq.Interface = uint32(ifi.Index)\n-\t}\n-\tif err := os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(c.fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_JOIN_GROUP, mreq)); err != nil {\n+\terr := joinIPv6Group(c.fd, ifi, ip)\n+\tif err != nil {\n \t\treturn &OpError{\"joinipv6group\", \"udp\", &IPAddr{ip}, err}\n \t}\n \treturn nil\n }\n \n func leaveIPv6GroupUDP(c *UDPConn, ifi *Interface, ip IP) error {\n-\tmreq := &syscall.IPv6Mreq{}\n-\tcopy(mreq.Multiaddr[:], ip)\n-\tif ifi != nil {\n-\t\tmreq.Interface = uint32(ifi.Index)\n-\t}\n-\tif err := os.NewSyscallError(\"setsockopt\", syscall.SetsockoptIPv6Mreq(c.fd.sysfd, syscall.IPPROTO_IPV6, syscall.IPV6_LEAVE_GROUP, mreq)); err != nil {\n+\terr := leaveIPv6Group(c.fd, ifi, ip)\n+\tif err != nil {\n \t\treturn &OpError{\"leaveipv6group\", \"udp\", &IPAddr{ip}, err}\n \t}\n \treturn nil"}, {"sha": "6ed6f59cdd6dc25e72420a5b58939febd09f6038", "filename": "libgo/go/net/unicast_test.go", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Funicast_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Funicast_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funicast_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,99 @@\n+// Copyright 2011 The Go Authors.  All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package net\n+\n+import (\n+\t\"runtime\"\n+\t\"testing\"\n+)\n+\n+var unicastTests = []struct {\n+\tnet    string\n+\tladdr  string\n+\tipv6   bool\n+\tpacket bool\n+}{\n+\t{\"tcp4\", \"127.0.0.1:0\", false, false},\n+\t{\"tcp6\", \"[::1]:0\", true, false},\n+\t{\"udp4\", \"127.0.0.1:0\", false, true},\n+\t{\"udp6\", \"[::1]:0\", true, true},\n+}\n+\n+func TestUnicastTCPAndUDP(t *testing.T) {\n+\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" {\n+\t\treturn\n+\t}\n+\n+\tfor _, tt := range unicastTests {\n+\t\tif tt.ipv6 && !supportsIPv6 {\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar fd *netFD\n+\t\tif !tt.packet {\n+\t\t\tc, err := Listen(tt.net, tt.laddr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"Listen failed: %v\", err)\n+\t\t\t}\n+\t\t\tdefer c.Close()\n+\t\t\tfd = c.(*TCPListener).fd\n+\t\t} else {\n+\t\t\tc, err := ListenPacket(tt.net, tt.laddr)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Fatalf(\"ListenPacket failed: %v\", err)\n+\t\t\t}\n+\t\t\tdefer c.Close()\n+\t\t\tfd = c.(*UDPConn).fd\n+\t\t}\n+\t\tif !tt.ipv6 {\n+\t\t\ttestIPv4UnicastSocketOptions(t, fd)\n+\t\t} else {\n+\t\t\ttestIPv6UnicastSocketOptions(t, fd)\n+\t\t}\n+\t}\n+}\n+\n+func testIPv4UnicastSocketOptions(t *testing.T, fd *netFD) {\n+\ttos, err := ipv4TOS(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv4TOS failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv4 TOS: %v\", tos)\n+\terr = setIPv4TOS(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv4TOS failed: %v\", err)\n+\t}\n+\n+\tttl, err := ipv4TTL(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv4TTL failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv4 TTL: %v\", ttl)\n+\terr = setIPv4TTL(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv4TTL failed: %v\", err)\n+\t}\n+}\n+\n+func testIPv6UnicastSocketOptions(t *testing.T, fd *netFD) {\n+\ttos, err := ipv6TrafficClass(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv6TrafficClass failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv6 TrafficClass: %v\", tos)\n+\terr = setIPv6TrafficClass(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv6TrafficClass failed: %v\", err)\n+\t}\n+\n+\thoplim, err := ipv6HopLimit(fd)\n+\tif err != nil {\n+\t\tt.Fatalf(\"ipv6HopLimit failed: %v\", err)\n+\t}\n+\tt.Logf(\"IPv6 HopLimit: %v\", hoplim)\n+\terr = setIPv6HopLimit(fd, 1)\n+\tif err != nil {\n+\t\tt.Fatalf(\"setIPv6HopLimit failed: %v\", err)\n+\t}\n+}"}, {"sha": "00ee0164f2e64ad14511b258fcddd124f226db2b", "filename": "libgo/go/net/unixsock_posix.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fnet%2Funixsock_posix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fnet%2Funixsock_posix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -315,7 +315,7 @@ type UnixListener struct {\n \n // ListenUnix announces on the Unix domain socket laddr and returns a Unix listener.\n // Net must be \"unix\" (stream sockets).\n-func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err error) {\n+func ListenUnix(net string, laddr *UnixAddr) (*UnixListener, error) {\n \tif net != \"unix\" && net != \"unixgram\" && net != \"unixpacket\" {\n \t\treturn nil, UnknownNetworkError(net)\n \t}\n@@ -326,10 +326,10 @@ func ListenUnix(net string, laddr *UnixAddr) (l *UnixListener, err error) {\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\te1 := syscall.Listen(fd.sysfd, 8) // listenBacklog());\n-\tif e1 != nil {\n+\terr = syscall.Listen(fd.sysfd, listenerBacklog)\n+\tif err != nil {\n \t\tclosesocket(fd.sysfd)\n-\t\treturn nil, &OpError{Op: \"listen\", Net: \"unix\", Addr: laddr, Err: e1}\n+\t\treturn nil, &OpError{Op: \"listen\", Net: \"unix\", Addr: laddr, Err: err}\n \t}\n \treturn &UnixListener{fd, laddr.Name}, nil\n }"}, {"sha": "991fa4d057802a26750d0a43b52652f9b5140ec6", "filename": "libgo/go/os/env_test.go", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fenv_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fenv_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fenv_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,6 +6,7 @@ package os_test\n \n import (\n \t. \"os\"\n+\t\"reflect\"\n \t\"testing\"\n )\n \n@@ -57,3 +58,13 @@ func TestExpand(t *testing.T) {\n \t\t}\n \t}\n }\n+\n+func TestConsistentEnviron(t *testing.T) {\n+\te0 := Environ()\n+\tfor i := 0; i < 10; i++ {\n+\t\te1 := Environ()\n+\t\tif !reflect.DeepEqual(e0, e1) {\n+\t\t\tt.Fatalf(\"environment changed\")\n+\t\t}\n+\t}\n+}"}, {"sha": "59f2bb061503f547d85f80704b128f69a8d388cd", "filename": "libgo/go/os/os_test.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fos_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fos_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -11,8 +11,8 @@ import (\n \t\"io/ioutil\"\n \t. \"os\"\n \t\"path/filepath\"\n+\t\"runtime\"\n \t\"strings\"\n-\t\"syscall\"\n \t\"testing\"\n \t\"time\"\n )\n@@ -33,7 +33,7 @@ type sysDir struct {\n }\n \n var sysdir = func() (sd *sysDir) {\n-\tswitch syscall.OS {\n+\tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tsd = &sysDir{\n \t\t\tGetenv(\"SystemRoot\") + \"\\\\system32\\\\drivers\\\\etc\",\n@@ -87,7 +87,7 @@ func size(name string, t *testing.T) int64 {\n }\n \n func equal(name1, name2 string) (r bool) {\n-\tswitch syscall.OS {\n+\tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tr = strings.ToLower(name1) == strings.ToLower(name2)\n \tdefault:\n@@ -101,7 +101,7 @@ func newFile(testName string, t *testing.T) (f *File) {\n \t// On Unix, override $TMPDIR in case the user\n \t// has it set to an NFS-mounted directory.\n \tdir := \"\"\n-\tif syscall.OS != \"windows\" {\n+\tif runtime.GOOS != \"windows\" {\n \t\tdir = \"/tmp\"\n \t}\n \tf, err := ioutil.TempFile(dir, \"_Go_\"+testName)\n@@ -276,7 +276,7 @@ func smallReaddirnames(file *File, length int, t *testing.T) []string {\n func TestReaddirnamesOneAtATime(t *testing.T) {\n \t// big directory that doesn't change often.\n \tdir := \"/usr/bin\"\n-\tswitch syscall.OS {\n+\tswitch runtime.GOOS {\n \tcase \"windows\":\n \t\tdir = Getenv(\"SystemRoot\") + \"\\\\system32\"\n \tcase \"plan9\":\n@@ -380,7 +380,7 @@ func TestReaddirNValues(t *testing.T) {\n \n func TestHardLink(t *testing.T) {\n \t// Hardlinks are not supported under windows or Plan 9.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn\n \t}\n \tfrom, to := \"hardlinktestfrom\", \"hardlinktestto\"\n@@ -413,7 +413,7 @@ func TestHardLink(t *testing.T) {\n \n func TestSymLink(t *testing.T) {\n \t// Symlinks are not supported under windows or Plan 9.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn\n \t}\n \tfrom, to := \"symlinktestfrom\", \"symlinktestto\"\n@@ -475,7 +475,7 @@ func TestSymLink(t *testing.T) {\n \n func TestLongSymlink(t *testing.T) {\n \t// Symlinks are not supported under windows or Plan 9.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn\n \t}\n \ts := \"0123456789abcdef\"\n@@ -545,7 +545,7 @@ func exec(t *testing.T, dir, cmd string, args []string, expect string) {\n func TestStartProcess(t *testing.T) {\n \tvar dir, cmd, le string\n \tvar args []string\n-\tif syscall.OS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" {\n \t\tle = \"\\r\\n\"\n \t\tcmd = Getenv(\"COMSPEC\")\n \t\tdir = Getenv(\"SystemRoot\")\n@@ -576,7 +576,7 @@ func checkMode(t *testing.T, path string, mode FileMode) {\n \n func TestChmod(t *testing.T) {\n \t// Chmod is not supported under windows.\n-\tif syscall.OS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" {\n \t\treturn\n \t}\n \tf := newFile(\"TestChmod\", t)\n@@ -678,7 +678,7 @@ func TestChtimes(t *testing.T) {\n \t*/\n \tpat := Atime(postStat)\n \tpmt := postStat.ModTime()\n-\tif !pat.Before(at) && syscall.OS != \"plan9\" {\n+\tif !pat.Before(at) && runtime.GOOS != \"plan9\" {\n \t\tt.Errorf(\"AccessTime didn't go backwards; was=%d, after=%d\", at, pat)\n \t}\n \n@@ -689,7 +689,7 @@ func TestChtimes(t *testing.T) {\n \n func TestChdirAndGetwd(t *testing.T) {\n \t// TODO(brainman): file.Chdir() is not implemented on windows.\n-\tif syscall.OS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" {\n \t\treturn\n \t}\n \tfd, err := Open(\".\")\n@@ -700,7 +700,7 @@ func TestChdirAndGetwd(t *testing.T) {\n \t// (unlike, say, /var, /etc, and /tmp).\n \tdirs := []string{\"/\", \"/usr/bin\"}\n \t// /usr/bin does not usually exist on Plan 9.\n-\tif syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"plan9\" {\n \t\tdirs = []string{\"/\", \"/usr\"}\n \t}\n \tfor mode := 0; mode < 2; mode++ {\n@@ -828,7 +828,7 @@ func TestOpenError(t *testing.T) {\n \t\t\tt.Errorf(\"Open(%q, %d) returns error of %T type; want *PathError\", tt.path, tt.mode, err)\n \t\t}\n \t\tif perr.Err != tt.error {\n-\t\t\tif syscall.OS == \"plan9\" {\n+\t\t\tif runtime.GOOS == \"plan9\" {\n \t\t\t\tsyscallErrStr := perr.Err.Error()\n \t\t\t\texpectedErrStr := strings.Replace(tt.error.Error(), \"file \", \"\", 1)\n \t\t\t\tif !strings.HasSuffix(syscallErrStr, expectedErrStr) {\n@@ -886,7 +886,7 @@ func run(t *testing.T, cmd []string) string {\n func TestHostname(t *testing.T) {\n \t// There is no other way to fetch hostname on windows, but via winapi.\n \t// On Plan 9 it is can be taken from #c/sysname as Hostname() does.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn\n \t}\n "}, {"sha": "1bdcd748bc00991179f02e3beb2a7ec596af4b5e", "filename": "libgo/go/os/os_unix_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fos_unix_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fos_unix_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fos_unix_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,6 +8,7 @@ package os_test\n \n import (\n \t. \"os\"\n+\t\"runtime\"\n \t\"syscall\"\n \t\"testing\"\n )\n@@ -29,7 +30,7 @@ func checkUidGid(t *testing.T, path string, uid, gid int) {\n func TestChown(t *testing.T) {\n \t// Chown is not supported under windows or Plan 9.\n \t// Plan9 provides a native ChownPlan9 version instead.\n-\tif syscall.OS == \"windows\" || syscall.OS == \"plan9\" {\n+\tif runtime.GOOS == \"windows\" || runtime.GOOS == \"plan9\" {\n \t\treturn\n \t}\n \t// Use TempDir() to make sure we're on a local file system,"}, {"sha": "18634ba410ede3d23f8f4707181e6b5a99eadb1e", "filename": "libgo/go/os/path_test.go", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fpath_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,7 +8,6 @@ import (\n \t. \"os\"\n \t\"path/filepath\"\n \t\"runtime\"\n-\t\"syscall\"\n \t\"testing\"\n )\n \n@@ -63,7 +62,7 @@ func TestMkdirAll(t *testing.T) {\n \t\tt.Fatalf(\"MkdirAll %q returned wrong error path: %q not %q\", ffpath, filepath.Clean(perr.Path), filepath.Clean(fpath))\n \t}\n \n-\tif syscall.OS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" {\n \t\tpath := `_test\\_TestMkdirAll_\\dir\\.\\dir2\\`\n \t\terr := MkdirAll(path, 0777)\n \t\tif err != nil {\n@@ -117,7 +116,7 @@ func TestRemoveAll(t *testing.T) {\n \n \t// Determine if we should run the following test.\n \ttestit := true\n-\tif syscall.OS == \"windows\" {\n+\tif runtime.GOOS == \"windows\" {\n \t\t// Chmod is not supported under windows.\n \t\ttestit = false\n \t} else {"}, {"sha": "b0a569e24cd1c85a9e5c48f67982f2b77af2e876", "filename": "libgo/go/os/stat_openbsd.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Fstat_openbsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Fstat_openbsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -24,8 +24,10 @@ func fileInfoFromStat(st *syscall.Stat_t, name string) FileInfo {\n \t}\n \tfs.mode = FileMode(st.Mode & 0777)\n \tswitch st.Mode & syscall.S_IFMT {\n-\tcase syscall.S_IFBLK, syscall.S_IFCHR:\n+\tcase syscall.S_IFBLK:\n \t\tfs.mode |= ModeDevice\n+\tcase syscall.S_IFCHR:\n+\t\tfs.mode |= ModeDevice | ModeCharDevice\n \tcase syscall.S_IFDIR:\n \t\tfs.mode |= ModeDir\n \tcase syscall.S_IFIFO:"}, {"sha": "bf009805fd730dec8af0a26d7a87974434666d14", "filename": "libgo/go/os/types.go", "status": "modified", "additions": 15, "deletions": 11, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Ftypes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fos%2Ftypes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fos%2Ftypes.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -30,19 +30,23 @@ type FileMode uint32\n \n // The defined file mode bits are the most significant bits of the FileMode.\n // The nine least-significant bits are the standard Unix rwxrwxrwx permissions.\n+// The values of these bits should be considered part of the public API and\n+// may be used in wire protocols or disk representations: they must not be\n+// changed, although new bits might be added.\n const (\n \t// The single letters are the abbreviations\n \t// used by the String method's formatting.\n-\tModeDir       FileMode = 1 << (32 - 1 - iota) // d: is a directory\n-\tModeAppend                                    // a: append-only\n-\tModeExclusive                                 // l: exclusive use\n-\tModeTemporary                                 // t: temporary file (not backed up)\n-\tModeSymlink                                   // L: symbolic link\n-\tModeDevice                                    // D: device file\n-\tModeNamedPipe                                 // p: named pipe (FIFO)\n-\tModeSocket                                    // S: Unix domain socket\n-\tModeSetuid                                    // u: setuid\n-\tModeSetgid                                    // g: setgid\n+\tModeDir        FileMode = 1 << (32 - 1 - iota) // d: is a directory\n+\tModeAppend                                     // a: append-only\n+\tModeExclusive                                  // l: exclusive use\n+\tModeTemporary                                  // t: temporary file (not backed up)\n+\tModeSymlink                                    // L: symbolic link\n+\tModeDevice                                     // D: device file\n+\tModeNamedPipe                                  // p: named pipe (FIFO)\n+\tModeSocket                                     // S: Unix domain socket\n+\tModeSetuid                                     // u: setuid\n+\tModeSetgid                                     // g: setgid\n+\tModeCharDevice                                 // c: Unix character device, when ModeDevice is set\n \n \t// Mask for the type bits. For regular files, none will be set.\n \tModeType = ModeDir | ModeSymlink | ModeNamedPipe | ModeSocket | ModeDevice\n@@ -51,7 +55,7 @@ const (\n )\n \n func (m FileMode) String() string {\n-\tconst str = \"daltLDpSug\"\n+\tconst str = \"daltLDpSugc\"\n \tvar buf [20]byte\n \tw := 0\n \tfor i, c := range str {"}, {"sha": "c2b90566a9989e6f20b7e859e7b8dac01380afad", "filename": "libgo/go/runtime/debug.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fruntime%2Fdebug.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fruntime%2Fdebug.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fdebug.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -19,6 +19,7 @@ func UnlockOSThread()\n // GOMAXPROCS sets the maximum number of CPUs that can be executing\n // simultaneously and returns the previous setting.  If n < 1, it does not\n // change the current setting.\n+// The number of logical CPUs on the local machine can be queried with NumCPU.\n // This call will go away when the scheduler improves.\n func GOMAXPROCS(n int) int\n "}, {"sha": "25c7470aab16900284e62b84417e0502f92961a4", "filename": "libgo/go/runtime/extern.go", "status": "modified", "additions": 9, "deletions": 45, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fruntime%2Fextern.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fruntime%2Fextern.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fextern.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -19,8 +19,8 @@ func Gosched()\n func Goexit()\n \n // Caller reports file and line number information about function invocations on\n-// the calling goroutine's stack.  The argument skip is the number of stack frames to\n-// ascend, with 0 identifying the the caller of Caller.  The return values report the\n+// the calling goroutine's stack.  The argument skip is the number of stack frames\n+// to ascend, with 0 identifying the caller of Caller.  The return values report the\n // program counter, file name, and line number within the file of the corresponding\n // call.  The boolean ok is false if it was not possible to recover the information.\n func Caller(skip int) (pc uintptr, file string, line int, ok bool)\n@@ -59,54 +59,18 @@ func (f *Func) Entry() uintptr { return f.entry }\n // The result will not be accurate if pc is not a program\n // counter within f.\n func (f *Func) FileLine(pc uintptr) (file string, line int) {\n-\t// NOTE(rsc): If you edit this function, also edit\n-\t// symtab.c:/^funcline.  That function also has the\n-\t// comments explaining the logic.\n-\ttargetpc := pc\n-\n-\tvar pcQuant uintptr = 1\n-\tif GOARCH == \"arm\" {\n-\t\tpcQuant = 4\n-\t}\n-\n-\tp := f.pcln\n-\tpc = f.pc0\n-\tline = int(f.ln0)\n-\ti := 0\n-\t//print(\"FileLine start pc=\", pc, \" targetpc=\", targetpc, \" line=\", line,\n-\t//\t\" tab=\", p, \" \", p[0], \" quant=\", pcQuant, \" GOARCH=\", GOARCH, \"\\n\")\n-\tfor {\n-\t\tfor i < len(p) && p[i] > 128 {\n-\t\t\tpc += pcQuant * uintptr(p[i]-128)\n-\t\t\ti++\n-\t\t}\n-\t\t//print(\"pc<\", pc, \" targetpc=\", targetpc, \" line=\", line, \"\\n\")\n-\t\tif pc > targetpc || i >= len(p) {\n-\t\t\tbreak\n-\t\t}\n-\t\tif p[i] == 0 {\n-\t\t\tif i+5 > len(p) {\n-\t\t\t\tbreak\n-\t\t\t}\n-\t\t\tline += int(p[i+1]<<24) | int(p[i+2]<<16) | int(p[i+3]<<8) | int(p[i+4])\n-\t\t\ti += 5\n-\t\t} else if p[i] <= 64 {\n-\t\t\tline += int(p[i])\n-\t\t\ti++\n-\t\t} else {\n-\t\t\tline -= int(p[i] - 64)\n-\t\t\ti++\n-\t\t}\n-\t\t//print(\"pc=\", pc, \" targetpc=\", targetpc, \" line=\", line, \"\\n\")\n-\t\tpc += pcQuant\n-\t}\n-\tfile = f.src\n-\treturn\n+\treturn funcline_go(f, pc)\n }\n \n+// implemented in symtab.c\n+func funcline_go(*Func, uintptr) (string, int)\n+\n // mid returns the current os thread (m) id.\n func mid() uint32\n \n+// NumCPU returns the number of logical CPUs on the local machine.\n+func NumCPU() int\n+\n // Semacquire waits until *s > 0 and then atomically decrements it.\n // It is intended as a simple sleep primitive for use by the synchronization\n // library and should not be used directly."}, {"sha": "31da3c83d0d6162e70bfc353dac7dc985f94e93d", "filename": "libgo/go/sort/sort.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsort%2Fsort.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsort%2Fsort.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsort%2Fsort.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -191,7 +191,7 @@ func Sort(data Interface) {\n \t\tmaxDepth++\n \t}\n \tmaxDepth *= 2\n-\tquickSort(data, 0, data.Len(), maxDepth)\n+\tquickSort(data, 0, n, maxDepth)\n }\n \n func IsSorted(data Interface) bool {"}, {"sha": "64ab84f45549914b8e73df1a1b21beee88ace0df", "filename": "libgo/go/strconv/extfloat.go", "status": "modified", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fextfloat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fextfloat.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -191,6 +191,36 @@ func (f *extFloat) Assign(x float64) {\n \tf.exp -= 64\n }\n \n+// AssignComputeBounds sets f to the value of x and returns\n+// lower, upper such that any number in the closed interval\n+// [lower, upper] is converted back to x.\n+func (f *extFloat) AssignComputeBounds(x float64) (lower, upper extFloat) {\n+\t// Special cases.\n+\tbits := math.Float64bits(x)\n+\tflt := &float64info\n+\tneg := bits>>(flt.expbits+flt.mantbits) != 0\n+\texpBiased := int(bits>>flt.mantbits) & (1<<flt.expbits - 1)\n+\tmant := bits & (uint64(1)<<flt.mantbits - 1)\n+\n+\tif expBiased == 0 {\n+\t\t// denormalized.\n+\t\tf.mant = mant\n+\t\tf.exp = 1 + flt.bias - int(flt.mantbits)\n+\t} else {\n+\t\tf.mant = mant | 1<<flt.mantbits\n+\t\tf.exp = expBiased + flt.bias - int(flt.mantbits)\n+\t}\n+\tf.neg = neg\n+\n+\tupper = extFloat{mant: 2*f.mant + 1, exp: f.exp - 1, neg: f.neg}\n+\tif mant != 0 || expBiased == 1 {\n+\t\tlower = extFloat{mant: 2*f.mant - 1, exp: f.exp - 1, neg: f.neg}\n+\t} else {\n+\t\tlower = extFloat{mant: 4*f.mant - 1, exp: f.exp - 2, neg: f.neg}\n+\t}\n+\treturn\n+}\n+\n // Normalize normalizes f so that the highest bit of the mantissa is\n // set, and returns the number by which the mantissa was left-shifted.\n func (f *extFloat) Normalize() uint {\n@@ -309,3 +339,163 @@ func (f *extFloat) AssignDecimal(d *decimal) (ok bool) {\n \t}\n \treturn true\n }\n+\n+// Frexp10 is an analogue of math.Frexp for decimal powers. It scales\n+// f by an approximate power of ten 10^-exp, and returns exp10, so\n+// that f*10^exp10 has the same value as the old f, up to an ulp,\n+// as well as the index of 10^-exp in the powersOfTen table.\n+// The arguments expMin and expMax constrain the final value of the\n+// binary exponent of f.\n+func (f *extFloat) frexp10(expMin, expMax int) (exp10, index int) {\n+\t// it is illegal to call this function with a too restrictive exponent range.\n+\tif expMax-expMin <= 25 {\n+\t\tpanic(\"strconv: invalid exponent range\")\n+\t}\n+\t// Find power of ten such that x * 10^n has a binary exponent\n+\t// between expMin and expMax\n+\tapproxExp10 := -(f.exp + 100) * 28 / 93 // log(10)/log(2) is close to 93/28.\n+\ti := (approxExp10 - firstPowerOfTen) / stepPowerOfTen\n+Loop:\n+\tfor {\n+\t\texp := f.exp + powersOfTen[i].exp + 64\n+\t\tswitch {\n+\t\tcase exp < expMin:\n+\t\t\ti++\n+\t\tcase exp > expMax:\n+\t\t\ti--\n+\t\tdefault:\n+\t\t\tbreak Loop\n+\t\t}\n+\t}\n+\t// Apply the desired decimal shift on f. It will have exponent\n+\t// in the desired range. This is multiplication by 10^-exp10.\n+\tf.Multiply(powersOfTen[i])\n+\n+\treturn -(firstPowerOfTen + i*stepPowerOfTen), i\n+}\n+\n+// frexp10Many applies a common shift by a power of ten to a, b, c.\n+func frexp10Many(expMin, expMax int, a, b, c *extFloat) (exp10 int) {\n+\texp10, i := c.frexp10(expMin, expMax)\n+\ta.Multiply(powersOfTen[i])\n+\tb.Multiply(powersOfTen[i])\n+\treturn\n+}\n+\n+// ShortestDecimal stores in d the shortest decimal representation of f\n+// which belongs to the open interval (lower, upper), where f is supposed\n+// to lie. It returns false whenever the result is unsure. The implementation\n+// uses the Grisu3 algorithm.\n+func (f *extFloat) ShortestDecimal(d *decimal, lower, upper *extFloat) bool {\n+\tif f.mant == 0 {\n+\t\td.d[0] = '0'\n+\t\td.nd = 1\n+\t\td.dp = 0\n+\t\td.neg = f.neg\n+\t}\n+\tconst minExp = -60\n+\tconst maxExp = -32\n+\tupper.Normalize()\n+\t// Uniformize exponents.\n+\tif f.exp > upper.exp {\n+\t\tf.mant <<= uint(f.exp - upper.exp)\n+\t\tf.exp = upper.exp\n+\t}\n+\tif lower.exp > upper.exp {\n+\t\tlower.mant <<= uint(lower.exp - upper.exp)\n+\t\tlower.exp = upper.exp\n+\t}\n+\n+\texp10 := frexp10Many(minExp, maxExp, lower, f, upper)\n+\t// Take a safety margin due to rounding in frexp10Many, but we lose precision.\n+\tupper.mant++\n+\tlower.mant--\n+\n+\t// The shortest representation of f is either rounded up or down, but\n+\t// in any case, it is a truncation of upper.\n+\tshift := uint(-upper.exp)\n+\tinteger := uint32(upper.mant >> shift)\n+\tfraction := upper.mant - (uint64(integer) << shift)\n+\n+\t// How far we can go down from upper until the result is wrong.\n+\tallowance := upper.mant - lower.mant\n+\t// How far we should go to get a very precise result.\n+\ttargetDiff := upper.mant - f.mant\n+\n+\t// Count integral digits: there are at most 10.\n+\tvar integerDigits int\n+\tfor i, pow := range uint64pow10 {\n+\t\tif uint64(integer) >= pow {\n+\t\t\tintegerDigits = i + 1\n+\t\t}\n+\t}\n+\tfor i := 0; i < integerDigits; i++ {\n+\t\tpow := uint64pow10[integerDigits-i-1]\n+\t\tdigit := integer / uint32(pow)\n+\t\td.d[i] = byte(digit + '0')\n+\t\tinteger -= digit * uint32(pow)\n+\t\t// evaluate whether we should stop.\n+\t\tif currentDiff := uint64(integer)<<shift + fraction; currentDiff < allowance {\n+\t\t\td.nd = i + 1\n+\t\t\td.dp = integerDigits + exp10\n+\t\t\td.neg = f.neg\n+\t\t\t// Sometimes allowance is so large the last digit might need to be\n+\t\t\t// decremented to get closer to f.\n+\t\t\treturn adjustLastDigit(d, currentDiff, targetDiff, allowance, pow<<shift, 2)\n+\t\t}\n+\t}\n+\td.nd = integerDigits\n+\td.dp = d.nd + exp10\n+\td.neg = f.neg\n+\n+\t// Compute digits of the fractional part. At each step fraction does not\n+\t// overflow. The choice of minExp implies that fraction is less than 2^60.\n+\tvar digit int\n+\tmultiplier := uint64(1)\n+\tfor {\n+\t\tfraction *= 10\n+\t\tmultiplier *= 10\n+\t\tdigit = int(fraction >> shift)\n+\t\td.d[d.nd] = byte(digit + '0')\n+\t\td.nd++\n+\t\tfraction -= uint64(digit) << shift\n+\t\tif fraction < allowance*multiplier {\n+\t\t\t// We are in the admissible range. Note that if allowance is about to\n+\t\t\t// overflow, that is, allowance > 2^64/10, the condition is automatically\n+\t\t\t// true due to the limited range of fraction.\n+\t\t\treturn adjustLastDigit(d,\n+\t\t\t\tfraction, targetDiff*multiplier, allowance*multiplier,\n+\t\t\t\t1<<shift, multiplier*2)\n+\t\t}\n+\t}\n+\treturn false\n+}\n+\n+// adjustLastDigit modifies d = x-currentDiff*\u03b5, to get closest to \n+// d = x-targetDiff*\u03b5, without becoming smaller than x-maxDiff*\u03b5.\n+// It assumes that a decimal digit is worth ulpDecimal*\u03b5, and that\n+// all data is known with a error estimate of ulpBinary*\u03b5.\n+func adjustLastDigit(d *decimal, currentDiff, targetDiff, maxDiff, ulpDecimal, ulpBinary uint64) bool {\n+\tif ulpDecimal < 2*ulpBinary {\n+\t\t// Appromixation is too wide.\n+\t\treturn false\n+\t}\n+\tfor currentDiff+ulpDecimal/2+ulpBinary < targetDiff {\n+\t\td.d[d.nd-1]--\n+\t\tcurrentDiff += ulpDecimal\n+\t}\n+\tif currentDiff+ulpDecimal <= targetDiff+ulpDecimal/2+ulpBinary {\n+\t\t// we have two choices, and don't know what to do.\n+\t\treturn false\n+\t}\n+\tif currentDiff < ulpBinary || currentDiff > maxDiff-ulpBinary {\n+\t\t// we went too far\n+\t\treturn false\n+\t}\n+\tif d.nd == 1 && d.d[0] == '0' {\n+\t\t// the number has actually reached zero.\n+\t\td.nd = 0\n+\t\td.dp = 0\n+\t}\n+\treturn true\n+}"}, {"sha": "171defa4417ddfd09ff813a888ae81f4f38046db", "filename": "libgo/go/strconv/fp_test.go", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Ffp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Ffp_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -26,8 +26,8 @@ func pow2(i int) float64 {\n \treturn pow2(i/2) * pow2(i-i/2)\n }\n \n-// Wrapper around strconv.Atof64.  Handles dddddp+ddd (binary exponent)\n-// itself, passes the rest on to strconv.Atof64.\n+// Wrapper around strconv.ParseFloat(x, 64).  Handles dddddp+ddd (binary exponent)\n+// itself, passes the rest on to strconv.ParseFloat.\n func myatof64(s string) (f float64, ok bool) {\n \ta := strings.SplitN(s, \"p\", 2)\n \tif len(a) == 2 {\n@@ -70,8 +70,8 @@ func myatof64(s string) (f float64, ok bool) {\n \treturn f1, true\n }\n \n-// Wrapper around strconv.Atof32.  Handles dddddp+ddd (binary exponent)\n-// itself, passes the rest on to strconv.Atof32.\n+// Wrapper around strconv.ParseFloat(x, 32).  Handles dddddp+ddd (binary exponent)\n+// itself, passes the rest on to strconv.ParseFloat.\n func myatof32(s string) (f float32, ok bool) {\n \ta := strings.SplitN(s, \"p\", 2)\n \tif len(a) == 2 {"}, {"sha": "8eefbee79f21dca076a54779b15e45a7c4b13709", "filename": "libgo/go/strconv/ftoa.go", "status": "modified", "additions": 51, "deletions": 27, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fftoa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fftoa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -98,29 +98,43 @@ func genericFtoa(dst []byte, val float64, fmt byte, prec, bitSize int) []byte {\n \t\treturn fmtB(dst, neg, mant, exp, flt)\n \t}\n \n-\t// Create exact decimal representation.\n-\t// The shift is exp - flt.mantbits because mant is a 1-bit integer\n-\t// followed by a flt.mantbits fraction, and we are treating it as\n-\t// a 1+flt.mantbits-bit integer.\n-\td := new(decimal)\n-\td.Assign(mant)\n-\td.Shift(exp - int(flt.mantbits))\n-\n-\t// Round appropriately.\n \t// Negative precision means \"only as much as needed to be exact.\"\n-\tshortest := false\n-\tif prec < 0 {\n-\t\tshortest = true\n-\t\troundShortest(d, mant, exp, flt)\n-\t\tswitch fmt {\n-\t\tcase 'e', 'E':\n-\t\t\tprec = d.nd - 1\n-\t\tcase 'f':\n-\t\t\tprec = max(d.nd-d.dp, 0)\n-\t\tcase 'g', 'G':\n-\t\t\tprec = d.nd\n+\tshortest := prec < 0\n+\n+\td := new(decimal)\n+\tif shortest {\n+\t\tok := false\n+\t\tif optimize && bitSize == 64 {\n+\t\t\t// Try Grisu3 algorithm.\n+\t\t\tf := new(extFloat)\n+\t\t\tlower, upper := f.AssignComputeBounds(val)\n+\t\t\tok = f.ShortestDecimal(d, &lower, &upper)\n+\t\t}\n+\t\tif !ok {\n+\t\t\t// Create exact decimal representation.\n+\t\t\t// The shift is exp - flt.mantbits because mant is a 1-bit integer\n+\t\t\t// followed by a flt.mantbits fraction, and we are treating it as\n+\t\t\t// a 1+flt.mantbits-bit integer.\n+\t\t\td.Assign(mant)\n+\t\t\td.Shift(exp - int(flt.mantbits))\n+\t\t\troundShortest(d, mant, exp, flt)\n+\t\t}\n+\t\t// Precision for shortest representation mode.\n+\t\tif prec < 0 {\n+\t\t\tswitch fmt {\n+\t\t\tcase 'e', 'E':\n+\t\t\t\tprec = d.nd - 1\n+\t\t\tcase 'f':\n+\t\t\t\tprec = max(d.nd-d.dp, 0)\n+\t\t\tcase 'g', 'G':\n+\t\t\t\tprec = d.nd\n+\t\t\t}\n \t\t}\n \t} else {\n+\t\t// Create exact decimal representation.\n+\t\td.Assign(mant)\n+\t\td.Shift(exp - int(flt.mantbits))\n+\t\t// Round appropriately.\n \t\tswitch fmt {\n \t\tcase 'e', 'E':\n \t\t\td.Round(prec + 1)\n@@ -178,15 +192,26 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \t\treturn\n \t}\n \n-\t// TODO(rsc): Unless exp == minexp, if the number of digits in d\n-\t// is less than 17, it seems likely that it would be\n-\t// the shortest possible number already.  So maybe we can\n-\t// bail out without doing the extra multiprecision math here.\n-\n \t// Compute upper and lower such that any decimal number\n \t// between upper and lower (possibly inclusive)\n \t// will round to the original floating point number.\n \n+\t// We may see at once that the number is already shortest.\n+\t//\n+\t// Suppose d is not denormal, so that 2^exp <= d < 10^dp.\n+\t// The closest shorter number is at least 10^(dp-nd) away.\n+\t// The lower/upper bounds computed below are at distance\n+\t// at most 2^(exp-mantbits).\n+\t//\n+\t// So the number is already shortest if 10^(dp-nd) > 2^(exp-mantbits),\n+\t// or equivalently log2(10)*(dp-nd) > exp-mantbits.\n+\t// It is true if 332/100*(dp-nd) >= exp-mantbits (log2(10) > 3.32).\n+\tminexp := flt.bias + 1 // minimum possible exponent\n+\tif exp > minexp && 332*(d.dp-d.nd) >= 100*(exp-int(flt.mantbits)) {\n+\t\t// The number is already shortest.\n+\t\treturn\n+\t}\n+\n \t// d = mant << (exp - mantbits)\n \t// Next highest floating point number is mant+1 << exp-mantbits.\n \t// Our upper bound is halfway inbetween, mant*2+1 << exp-mantbits-1.\n@@ -200,7 +225,6 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \t// in which case the next lowest is mant*2-1 << exp-mantbits-1.\n \t// Either way, call it mantlo << explo-mantbits.\n \t// Our lower bound is halfway inbetween, mantlo*2+1 << explo-mantbits-1.\n-\tminexp := flt.bias + 1 // minimum possible exponent\n \tvar mantlo uint64\n \tvar explo int\n \tif mant > 1<<flt.mantbits || exp == minexp {\n@@ -241,7 +265,7 @@ func roundShortest(d *decimal, mant uint64, exp int, flt *floatInfo) {\n \n \t\t// Okay to round up if upper has a different digit and\n \t\t// either upper is inclusive or upper is bigger than the result of rounding up.\n-\t\tokup := m != u && (inclusive || i+1 < upper.nd)\n+\t\tokup := m != u && (inclusive || m+1 < u || i+1 < upper.nd)\n \n \t\t// If it's okay to do either, then round to the nearest one.\n \t\t// If it's okay to do only one, do it."}, {"sha": "ee7b7c431e7fa413e2c48fe0dea27c3b72a7dc52", "filename": "libgo/go/strconv/ftoa_test.go", "status": "modified", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fftoa_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fftoa_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -6,6 +6,7 @@ package strconv_test\n \n import (\n \t\"math\"\n+\t\"math/rand\"\n \t. \"strconv\"\n \t\"testing\"\n )\n@@ -123,6 +124,10 @@ var ftoatests = []ftoaTest{\n \t{2.2250738585072012e-308, 'g', -1, \"2.2250738585072014e-308\"},\n \t// http://www.exploringbinary.com/php-hangs-on-numeric-value-2-2250738585072011e-308/\n \t{2.2250738585072011e-308, 'g', -1, \"2.225073858507201e-308\"},\n+\n+\t// Issue 2625.\n+\t{383260575764816448, 'f', 0, \"383260575764816448\"},\n+\t{383260575764816448, 'g', -1, \"3.8326057576481645e+17\"},\n }\n \n func TestFtoa(t *testing.T) {\n@@ -149,6 +154,25 @@ func TestFtoa(t *testing.T) {\n \t}\n }\n \n+func TestFtoaRandom(t *testing.T) {\n+\tN := int(1e4)\n+\tif testing.Short() {\n+\t\tN = 100\n+\t}\n+\tt.Logf(\"testing %d random numbers with fast and slow FormatFloat\", N)\n+\tfor i := 0; i < N; i++ {\n+\t\tbits := uint64(rand.Uint32())<<32 | uint64(rand.Uint32())\n+\t\tx := math.Float64frombits(bits)\n+\t\tshortFast := FormatFloat(x, 'g', -1, 64)\n+\t\tSetOptimize(false)\n+\t\tshortSlow := FormatFloat(x, 'g', -1, 64)\n+\t\tSetOptimize(true)\n+\t\tif shortSlow != shortFast {\n+\t\t\tt.Errorf(\"%b printed as %s, want %s\", x, shortFast, shortSlow)\n+\t\t}\n+\t}\n+}\n+\n /* This test relies on escape analysis which gccgo does not yet do.\n \n func TestAppendFloatDoesntAllocate(t *testing.T) {\n@@ -188,6 +212,12 @@ func BenchmarkFormatFloatExp(b *testing.B) {\n \t}\n }\n \n+func BenchmarkFormatFloatNegExp(b *testing.B) {\n+\tfor i := 0; i < b.N; i++ {\n+\t\tFormatFloat(-5.11e-95, 'g', -1, 64)\n+\t}\n+}\n+\n func BenchmarkFormatFloatBig(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tFormatFloat(123456789123456789123456789, 'g', -1, 64)\n@@ -215,6 +245,13 @@ func BenchmarkAppendFloatExp(b *testing.B) {\n \t}\n }\n \n+func BenchmarkAppendFloatNegExp(b *testing.B) {\n+\tdst := make([]byte, 0, 30)\n+\tfor i := 0; i < b.N; i++ {\n+\t\tAppendFloat(dst, -5.11e-95, 'g', -1, 64)\n+\t}\n+}\n+\n func BenchmarkAppendFloatBig(b *testing.B) {\n \tdst := make([]byte, 0, 30)\n \tfor i := 0; i < b.N; i++ {"}, {"sha": "61dbcae70f4b2892d14492a69e07c26dda0e0687", "filename": "libgo/go/strconv/quote.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fquote.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fquote.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -260,6 +260,7 @@ func UnquoteChar(s string, quote byte) (value rune, multibyte bool, tail string,\n \t\tfor j := 0; j < 2; j++ { // one digit already; two more\n \t\t\tx := rune(s[j]) - '0'\n \t\t\tif x < 0 || x > 7 {\n+\t\t\t\terr = ErrSyntax\n \t\t\t\treturn\n \t\t\t}\n \t\t\tv = (v << 3) | x"}, {"sha": "3f544c43cd55cbd0f931233b1ad345d5e578f0d5", "filename": "libgo/go/strconv/quote_test.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fstrconv%2Fquote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fstrconv%2Fquote_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -191,7 +191,13 @@ var misquoted = []string{\n \t`\"'`,\n \t`b\"`,\n \t`\"\\\"`,\n+\t`\"\\9\"`,\n+\t`\"\\19\"`,\n+\t`\"\\129\"`,\n \t`'\\'`,\n+\t`'\\9'`,\n+\t`'\\19'`,\n+\t`'\\129'`,\n \t`'ab'`,\n \t`\"\\x1!\"`,\n \t`\"\\U12345678\"`,"}, {"sha": "c1a02135f4f1f0709ce43e198036aa006662acdb", "filename": "libgo/go/syscall/env_unix.go", "status": "modified", "additions": 44, "deletions": 20, "changes": 64, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fenv_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fenv_unix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -10,26 +10,40 @@ package syscall\n \n import \"sync\"\n \n-var env map[string]string\n-var envOnce sync.Once\n-var Envs []string // provided by runtime\n+var (\n+\t// envOnce guards initialization by copyenv, which populates env.\n+\tenvOnce sync.Once\n \n+\t// envLock guards env and envs.\n+\tenvLock sync.RWMutex\n+\n+\t// env maps from an environment variable to its first occurrence in envs.\n+\tenv map[string]int\n+\n+\t// envs is provided by the runtime. elements are expected to be\n+\t// of the form \"key=value\".\n+\tEnvs []string\n+)\n+\n+// setenv_c is provided by the runtime, but is a no-op if cgo isn't\n+// loaded.\n func setenv_c(k, v string)\n \n func copyenv() {\n-\tenv = make(map[string]string)\n-\tfor _, s := range Envs {\n+\tenv = make(map[string]int)\n+\tfor i, s := range Envs {\n \t\tfor j := 0; j < len(s); j++ {\n \t\t\tif s[j] == '=' {\n-\t\t\t\tenv[s[0:j]] = s[j+1:]\n+\t\t\t\tkey := s[:j]\n+\t\t\t\tif _, ok := env[key]; !ok {\n+\t\t\t\t\tenv[key] = i\n+\t\t\t\t}\n \t\t\t\tbreak\n \t\t\t}\n \t\t}\n \t}\n }\n \n-var envLock sync.RWMutex\n-\n func Getenv(key string) (value string, found bool) {\n \tenvOnce.Do(copyenv)\n \tif len(key) == 0 {\n@@ -39,11 +53,17 @@ func Getenv(key string) (value string, found bool) {\n \tenvLock.RLock()\n \tdefer envLock.RUnlock()\n \n-\tv, ok := env[key]\n+\ti, ok := env[key]\n \tif !ok {\n \t\treturn \"\", false\n \t}\n-\treturn v, true\n+\ts := Envs[i]\n+\tfor i := 0; i < len(s); i++ {\n+\t\tif s[i] == '=' {\n+\t\t\treturn s[i+1:], true\n+\t\t}\n+\t}\n+\treturn \"\", false\n }\n \n func Setenv(key, value string) error {\n@@ -55,8 +75,16 @@ func Setenv(key, value string) error {\n \tenvLock.Lock()\n \tdefer envLock.Unlock()\n \n-\tenv[key] = value\n-\tsetenv_c(key, value) // is a no-op if cgo isn't loaded\n+\ti, ok := env[key]\n+\tkv := key + \"=\" + value\n+\tif ok {\n+\t\tEnvs[i] = kv\n+\t} else {\n+\t\ti = len(Envs)\n+\t\tEnvs = append(Envs, kv)\n+\t}\n+\tenv[key] = i\n+\tsetenv_c(key, value)\n \treturn nil\n }\n \n@@ -66,20 +94,16 @@ func Clearenv() {\n \tenvLock.Lock()\n \tdefer envLock.Unlock()\n \n-\tenv = make(map[string]string)\n-\n+\tenv = make(map[string]int)\n+\tEnvs = []string{}\n \t// TODO(bradfitz): pass through to C\n }\n \n func Environ() []string {\n \tenvOnce.Do(copyenv)\n \tenvLock.RLock()\n \tdefer envLock.RUnlock()\n-\ta := make([]string, len(env))\n-\ti := 0\n-\tfor k, v := range env {\n-\t\ta[i] = k + \"=\" + v\n-\t\ti++\n-\t}\n+\ta := make([]string, len(Envs))\n+\tcopy(a, Envs)\n \treturn a\n }"}, {"sha": "7baa3af69cbd233d8a4cbdd5f3121ec5b986612a", "filename": "libgo/go/syscall/exec_bsd.go", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_bsd.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,227 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin freebsd netbsd openbsd\n+\n+package syscall\n+\n+import (\n+\t\"runtime\"\n+\t\"unsafe\"\n+)\n+\n+type SysProcAttr struct {\n+\tChroot     string      // Chroot.\n+\tCredential *Credential // Credential.\n+\tPtrace     bool        // Enable tracing.\n+\tSetsid     bool        // Create session.\n+\tSetpgid    bool        // Set process group ID to new pid (SYSV setpgrp)\n+\tSetctty    bool        // Set controlling terminal to fd 0\n+\tNoctty     bool        // Detach fd 0 from controlling terminal\n+}\n+\n+// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n+// If a dup or exec fails, write the errno error to pipe.\n+// (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n+// In the child, this function must not acquire any locks, because\n+// they might have been locked at the time of the fork.  This means\n+// no rescheduling, no malloc calls, and no new stack segments.\n+// The calls to RawSyscall are okay because they are assembly\n+// functions that do not grow the stack.\n+func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n+\t// Declare all variables at top in case any\n+\t// declarations require heap allocation (e.g., err1).\n+\tvar (\n+\t\tr1     Pid_t\n+\t\terr1   Errno\n+\t\tnextfd int\n+\t\ti      int\n+\t)\n+\n+\t// guard against side effects of shuffling fds below.\n+\tfd := append([]int(nil), attr.Files...)\n+\n+\t// About to call fork.\n+\t// No more allocation or calls of non-assembly functions.\n+\tr1, err1 = raw_fork()\n+\tif err1 != 0 {\n+\t\treturn 0, err1\n+\t}\n+\n+\tif r1 != 0 {\n+\t\t// parent; return PID\n+\t\treturn int(r1), 0\n+\t}\n+\n+\t// Fork succeeded, now in child.\n+\n+\t// Enable tracing if requested.\n+\tif sys.Ptrace {\n+\t\terr1 = raw_trace(_PTRACE_TRACEME, 0, nil, nil)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Session ID\n+\tif sys.Setsid {\n+\t\terr1 = raw_setsid()\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set process group\n+\tif sys.Setpgid {\n+\t\terr1 = raw_setpgid(0, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Chroot\n+\tif chroot != nil {\n+\t\terr1 = raw_chroot(chroot)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// User and groups\n+\tif cred := sys.Credential; cred != nil {\n+\t\tngroups := len(cred.Groups)\n+\t\tif ngroups == 0 {\n+\t\t\terr2 := setgroups(0, nil)\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tgroups := make([]Gid_t, ngroups)\n+\t\t\tfor i, v := range cred.Groups {\n+\t\t\t\tgroups[i] = Gid_t(v)\n+\t\t\t}\n+\t\t\terr2 := setgroups(ngroups, &groups[0])\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n+\t\t}\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t\terr2 := Setgid(int(cred.Gid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t\terr2 = Setuid(int(cred.Uid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Chdir\n+\tif dir != nil {\n+\t\terr1 = raw_chdir(dir)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Pass 1: look for fd[i] < i and move those up above len(fd)\n+\t// so that pass 2 won't stomp on an fd it needs later.\n+\tnextfd = int(len(fd))\n+\tif pipe < nextfd {\n+\t\t_, err2 := Dup2(pipe, nextfd)\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\tpipe = nextfd\n+\t\tnextfd++\n+\t}\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] >= 0 && fd[i] < int(i) {\n+\t\t\t_, err2 := Dup2(fd[i], nextfd)\n+\t\t\tif err2 != nil {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\traw_fcntl(nextfd, F_SETFD, F_CLOEXEC)\n+\t\t\tfd[i] = nextfd\n+\t\t\tnextfd++\n+\t\t\tif nextfd == pipe { // don't stomp on pipe\n+\t\t\t\tnextfd++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Pass 2: dup fd[i] down onto i.\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] == -1 {\n+\t\t\traw_close(i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif fd[i] == int(i) {\n+\t\t\t// dup2(i, i) won't clear close-on-exec flag on Linux,\n+\t\t\t// probably not elsewhere either.\n+\t\t\t_, err1 = raw_fcntl(fd[i], F_SETFD, 0)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// The new fd is created NOT close-on-exec,\n+\t\t// which is exactly what we want.\n+\t\t_, err2 := Dup2(fd[i], i)\n+\t\tif err1 != 0 {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// By convention, we don't close-on-exec the fds we are\n+\t// started with, so if len(fd) < 3, close 0, 1, 2 as needed.\n+\t// Programs that know they inherit fds >= 3 will need\n+\t// to set them close-on-exec.\n+\tfor i = len(fd); i < 3; i++ {\n+\t\traw_close(i)\n+\t}\n+\n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, err1 = raw_ioctl(0, IOTCNOTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Make fd 0 the tty\n+\tif sys.Setctty {\n+\t\t_, err1 = raw_ioctl(TIOCSCTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Time to exec.\n+\terr1 = raw_execve(argv0, &argv[0], &envv[0])\n+\n+childerror:\n+\t// send error code on pipe\n+\traw_write(pipe, (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n+\tfor {\n+\t\traw_exit(253)\n+\t}\n+\n+\t// Calling panic is not actually safe,\n+\t// but the for loop above won't break\n+\t// and this shuts up the compiler.\n+\tpanic(\"unreached\")\n+}"}, {"sha": "98dbeb27750f36d040660cdd1e2bc88091d1e01b", "filename": "libgo/go/syscall/exec_linux.go", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_linux.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_linux.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -0,0 +1,251 @@\n+// Copyright 2011 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build linux\n+\n+package syscall\n+\n+import (\n+\t\"unsafe\"\n+)\n+\n+//sysnb\traw_prctl(option int, arg2 int, arg3 int, arg4 int, arg5 int) (ret int, err Errno)\n+//prctl(option int, arg2 _C_long, arg3 _C_long, arg4 _C_long, arg5 _C_long) int\n+\n+type SysProcAttr struct {\n+\tChroot     string      // Chroot.\n+\tCredential *Credential // Credential.\n+\tPtrace     bool        // Enable tracing.\n+\tSetsid     bool        // Create session.\n+\tSetpgid    bool        // Set process group ID to new pid (SYSV setpgrp)\n+\tSetctty    bool        // Set controlling terminal to fd 0\n+\tNoctty     bool        // Detach fd 0 from controlling terminal\n+\tPdeathsig  int         // Signal that the process will get when its parent dies (Linux only)\n+}\n+\n+// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n+// If a dup or exec fails, write the errno error to pipe.\n+// (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n+// In the child, this function must not acquire any locks, because\n+// they might have been locked at the time of the fork.  This means\n+// no rescheduling, no malloc calls, and no new stack segments.\n+// The calls to RawSyscall are okay because they are assembly\n+// functions that do not grow the stack.\n+func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n+\t// Declare all variables at top in case any\n+\t// declarations require heap allocation (e.g., err1).\n+\tvar (\n+\t\tr1     Pid_t\n+\t\terr1   Errno\n+\t\tnextfd int\n+\t\ti      int\n+\t)\n+\n+\t// guard against side effects of shuffling fds below.\n+\tfd := append([]int(nil), attr.Files...)\n+\n+\t// About to call fork.\n+\t// No more allocation or calls of non-assembly functions.\n+\tr1, err1 = raw_fork()\n+\tif err1 != 0 {\n+\t\treturn 0, err1\n+\t}\n+\n+\tif r1 != 0 {\n+\t\t// parent; return PID\n+\t\treturn int(r1), 0\n+\t}\n+\n+\t// Fork succeeded, now in child.\n+\n+\t// Parent death signal\n+\tif sys.Pdeathsig != 0 {\n+\t\t_, err1 = raw_prctl(PR_SET_PDEATHSIG, sys.Pdeathsig, 0, 0, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\n+\t\t// Signal self if parent is already dead. This might cause a\n+\t\t// duplicate signal in rare cases, but it won't matter when\n+\t\t// using SIGKILL.\n+\t\tppid := Getppid()\n+\t\tif ppid == 1 {\n+\t\t\tpid = Getpid()\n+\t\t\terr2 := Kill(pid, sys.Pdeathsig)\n+\t\t\tif err2 != nil {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Enable tracing if requested.\n+\tif sys.Ptrace {\n+\t\terr1 = raw_ptrace(_PTRACE_TRACEME, 0, nil, nil)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Session ID\n+\tif sys.Setsid {\n+\t\terr1 = raw_setsid()\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Set process group\n+\tif sys.Setpgid {\n+\t\terr1 = raw_setpgid(0, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Chroot\n+\tif chroot != nil {\n+\t\terr1 = raw_chroot(chroot)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// User and groups\n+\tif cred := sys.Credential; cred != nil {\n+\t\tngroups := len(cred.Groups)\n+\t\tif ngroups == 0 {\n+\t\t\terr2 := setgroups(0, nil)\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n+\t\t} else {\n+\t\t\tgroups := make([]Gid_t, ngroups)\n+\t\t\tfor i, v := range cred.Groups {\n+\t\t\t\tgroups[i] = Gid_t(v)\n+\t\t\t}\n+\t\t\terr2 := setgroups(ngroups, &groups[0])\n+\t\t\tif err2 == nil {\n+\t\t\t\terr1 = 0\n+\t\t\t} else {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t}\n+\t\t}\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t\terr2 := Setgid(int(cred.Gid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t\terr2 = Setuid(int(cred.Uid))\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Chdir\n+\tif dir != nil {\n+\t\terr1 = raw_chdir(dir)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Pass 1: look for fd[i] < i and move those up above len(fd)\n+\t// so that pass 2 won't stomp on an fd it needs later.\n+\tnextfd = int(len(fd))\n+\tif pipe < nextfd {\n+\t\t_, err2 := Dup2(pipe, nextfd)\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\tpipe = nextfd\n+\t\tnextfd++\n+\t}\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] >= 0 && fd[i] < int(i) {\n+\t\t\t_, err2 := Dup2(fd[i], nextfd)\n+\t\t\tif err2 != nil {\n+\t\t\t\terr1 = err2.(Errno)\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n+\t\t\tfd[i] = nextfd\n+\t\t\tnextfd++\n+\t\t\tif nextfd == pipe { // don't stomp on pipe\n+\t\t\t\tnextfd++\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t// Pass 2: dup fd[i] down onto i.\n+\tfor i = 0; i < len(fd); i++ {\n+\t\tif fd[i] == -1 {\n+\t\t\traw_close(i)\n+\t\t\tcontinue\n+\t\t}\n+\t\tif fd[i] == int(i) {\n+\t\t\t// dup2(i, i) won't clear close-on-exec flag on Linux,\n+\t\t\t// probably not elsewhere either.\n+\t\t\t_, err1 = raw_fcntl(fd[i], F_SETFD, 0)\n+\t\t\tif err1 != 0 {\n+\t\t\t\tgoto childerror\n+\t\t\t}\n+\t\t\tcontinue\n+\t\t}\n+\t\t// The new fd is created NOT close-on-exec,\n+\t\t// which is exactly what we want.\n+\t\t_, err2 := Dup2(fd[i], i);\n+\t\tif err2 != nil {\n+\t\t\terr1 = err2.(Errno)\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// By convention, we don't close-on-exec the fds we are\n+\t// started with, so if len(fd) < 3, close 0, 1, 2 as needed.\n+\t// Programs that know they inherit fds >= 3 will need\n+\t// to set them close-on-exec.\n+\tfor i = len(fd); i < 3; i++ {\n+\t\traw_close(i)\n+\t}\n+\n+\t// Detach fd 0 from tty\n+\tif sys.Noctty {\n+\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Make fd 0 the tty\n+\tif sys.Setctty {\n+\t\t_, err1 = raw_ioctl(0, TIOCSCTTY, 0)\n+\t\tif err1 != 0 {\n+\t\t\tgoto childerror\n+\t\t}\n+\t}\n+\n+\t// Time to exec.\n+\terr1 = raw_execve(argv0, &argv[0], &envv[0])\n+\n+childerror:\n+\t// send error code on pipe\n+\traw_write(pipe, (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n+\tfor {\n+\t\traw_exit(253)\n+\t}\n+\n+\t// Calling panic is not actually safe,\n+\t// but the for loop above won't break\n+\t// and this shuts up the compiler.\n+\tpanic(\"unreached\")\n+}"}, {"sha": "131ebaae87c03e9ba158fa717173da2bd1dfe4cb", "filename": "libgo/go/syscall/exec_unix.go", "status": "modified", "additions": 2, "deletions": 216, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fexec_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fexec_unix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,6 +9,7 @@\n package syscall\n \n import (\n+\t\"runtime\"\n \t\"sync\"\n \t\"unsafe\"\n )\n@@ -126,211 +127,6 @@ func SetNonblock(fd int, nonblocking bool) (err error) {\n \treturn err\n }\n \n-// Fork, dup fd onto 0..len(fd), and exec(argv0, argvv, envv) in child.\n-// If a dup or exec fails, write the errno error to pipe.\n-// (Pipe is close-on-exec so if exec succeeds, it will be closed.)\n-// In the child, this function must not acquire any locks, because\n-// they might have been locked at the time of the fork.  This means\n-// no rescheduling, no malloc calls, and no new stack segments.\n-// The calls to RawSyscall are okay because they are assembly\n-// functions that do not grow the stack.\n-func forkAndExecInChild(argv0 *byte, argv, envv []*byte, chroot, dir *byte, attr *ProcAttr, sys *SysProcAttr, pipe int) (pid int, err Errno) {\n-\t// Declare all variables at top in case any\n-\t// declarations require heap allocation (e.g., err1).\n-\tvar (\n-\t\tr1 Pid_t\n-\t\terr1 Errno\n-\t\tnextfd int\n-\t\ti int\n-\t)\n-\n-\t// guard against side effects of shuffling fds below.\n-\tfd := append([]int(nil), attr.Files...)\n-\n-\t// About to call fork.\n-\t// No more allocation or calls of non-assembly functions.\n-\tr1, err1 = raw_fork()\n-\tif err1 != 0 {\n-\t\treturn 0, err1\n-\t}\n-\n-\tif r1 != 0 {\n-\t\t// parent; return PID\n-\t\treturn int(r1), 0\n-\t}\n-\n-\t// Fork succeeded, now in child.\n-\n-\t// Enable tracing if requested.\n-\tif sys.Ptrace {\n-\t\terr1 = raw_ptrace(_PTRACE_TRACEME, 0, nil, nil)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Session ID\n-\tif sys.Setsid {\n-\t\terr1 = raw_setsid()\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Set process group\n-\tif sys.Setpgid {\n-\t\terr1 = raw_setpgid(0, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Chroot\n-\tif chroot != nil {\n-\t\terr1 = raw_chroot(chroot)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// User and groups\n-\tif cred := sys.Credential; cred != nil {\n-\t\tngroups := len(cred.Groups)\n-\t\tif ngroups == 0 {\n-\t\t\terr2 := setgroups(0, nil)\n-\t\t\tif err2 == nil {\n-\t\t\t\terr1 = 0\n-\t\t\t} else {\n-\t\t\t\terr1 = err2.(Errno)\n-\t\t\t}\n-\t\t} else {\n-\t\t\tgroups := make([]Gid_t, ngroups)\n-\t\t\tfor i, v := range cred.Groups {\n-\t\t\t\tgroups[i] = Gid_t(v)\n-\t\t\t}\n-\t\t\terr2 := setgroups(ngroups, &groups[0])\n-\t\t\tif err2 == nil {\n-\t\t\t\terr1 = 0\n-\t\t\t} else {\n-\t\t\t\terr1 = err2.(Errno)\n-\t\t\t}\n-\t\t}\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t\terr2 := Setgid(int(cred.Gid))\n-\t\tif err2 != nil {\n-\t\t\terr1 = err2.(Errno)\n-\t\t\tgoto childerror\n-\t\t}\n-\t\terr2 = Setuid(int(cred.Uid))\n-\t\tif err2 != nil {\n-\t\t\terr1 = err2.(Errno)\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Chdir\n-\tif dir != nil {\n-\t\terr1 = raw_chdir(dir)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Pass 1: look for fd[i] < i and move those up above len(fd)\n-\t// so that pass 2 won't stomp on an fd it needs later.\n-\tnextfd = int(len(fd))\n-\tif pipe < nextfd {\n-\t\t_, err2 := Dup2(pipe, nextfd)\n-\t\tif err2 != nil {\n-\t\t\terr1 = err2.(Errno)\n-\t\t\tgoto childerror\n-\t\t}\n-\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n-\t\tpipe = nextfd\n-\t\tnextfd++\n-\t}\n-\tfor i = 0; i < len(fd); i++ {\n-\t\tif fd[i] >= 0 && fd[i] < int(i) {\n-\t\t\t_, err2 := Dup2(fd[i], nextfd)\n-\t\t\tif err2 != nil {\n-\t\t\t\terr1 = err2.(Errno)\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\t\t\traw_fcntl(nextfd, F_SETFD, FD_CLOEXEC)\n-\t\t\tfd[i] = nextfd\n-\t\t\tnextfd++\n-\t\t\tif nextfd == pipe { // don't stomp on pipe\n-\t\t\t\tnextfd++\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Pass 2: dup fd[i] down onto i.\n-\tfor i = 0; i < len(fd); i++ {\n-\t\tif fd[i] == -1 {\n-\t\t\traw_close(i)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif fd[i] == int(i) {\n-\t\t\t// Dup2(i, i) won't clear close-on-exec flag on\n-\t\t\t// GNU/Linux, probably not elsewhere either.\n-\t\t\t_, err1 = raw_fcntl(fd[i], F_SETFD, 0)\n-\t\t\tif err1 != 0 {\n-\t\t\t\tgoto childerror\n-\t\t\t}\n-\t\t\tcontinue\n-\t\t}\n-\t\t// The new fd is created NOT close-on-exec,\n-\t\t// which is exactly what we want.\n-\t\t_, err2 := Dup2(fd[i], i)\n-\t\tif err2 != nil {\n-\t\t\terr1 = err2.(Errno)\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// By convention, we don't close-on-exec the fds we are\n-\t// started with, so if len(fd) < 3, close 0, 1, 2 as needed.\n-\t// Programs that know they inherit fds >= 3 will need\n-\t// to set them close-on-exec.\n-\tfor i = len(fd); i < 3; i++ {\n-\t\traw_close(i)\n-\t}\n-\n-\t// Detach fd 0 from tty\n-\tif sys.Noctty {\n-\t\t_, err1 = raw_ioctl(0, TIOCNOTTY, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Make fd 0 the tty\n-\tif sys.Setctty {\n-\t\t_, err1 = raw_ioctl(0, TIOCSCTTY, 0)\n-\t\tif err1 != 0 {\n-\t\t\tgoto childerror\n-\t\t}\n-\t}\n-\n-\t// Time to exec.\n-\terr1 = raw_execve(argv0, &argv[0], &envv[0])\n-\n-childerror:\n-\t// send error code on pipe\n-\traw_write(pipe, (*byte)(unsafe.Pointer(&err1)), int(unsafe.Sizeof(err1)))\n-\tfor {\n-\t\traw_exit(253)\n-\t}\n-\n-\t// Calling panic is not actually safe,\n-\t// but the for loop above won't break\n-\t// and this shuts up the compiler.\n-\tpanic(\"unreached\")\n-}\n-\n // Credential holds user and group identities to be assumed\n // by a child process started by StartProcess.\n type Credential struct {\n@@ -348,16 +144,6 @@ type ProcAttr struct {\n \tSys   *SysProcAttr\n }\n \n-type SysProcAttr struct {\n-\tChroot     string      // Chroot.\n-\tCredential *Credential // Credential.\n-\tPtrace     bool        // Enable tracing.\n-\tSetsid     bool        // Create session.\n-\tSetpgid    bool        // Set process group ID to new pid (SYSV setpgrp)\n-\tSetctty    bool        // Set controlling terminal to fd 0\n-\tNoctty     bool        // Detach fd 0 from controlling terminal\n-}\n-\n var zeroProcAttr ProcAttr\n var zeroSysProcAttr SysProcAttr\n \n@@ -383,7 +169,7 @@ func forkExec(argv0 string, argv []string, attr *ProcAttr) (pid int, err error)\n \targvp := StringSlicePtr(argv)\n \tenvvp := StringSlicePtr(attr.Env)\n \n-\tif OS == \"freebsd\" && len(argv[0]) > len(argv0) {\n+\tif runtime.GOOS == \"freebsd\" && len(argv[0]) > len(argv0) {\n \t\targvp[0] = argv0p\n \t}\n "}, {"sha": "517b5b9408d50735063bc4598cccd5cbd6b5ab78", "filename": "libgo/go/syscall/socket.go", "status": "modified", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fsocket.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fsocket.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsocket.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -237,28 +237,20 @@ func GetsockoptIPMreq(fd, level, opt int) (*IPMreq, error) {\n \treturn &value, err\n }\n \n-/* FIXME: mksysinfo needs to support IPMreqn.\n-\n func GetsockoptIPMreqn(fd, level, opt int) (*IPMreqn, error) {\n \tvar value IPMreqn\n \tvallen := Socklen_t(SizeofIPMreqn)\n \terr := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n \treturn &value, err\n }\n \n-*/\n-\n-/* FIXME: mksysinfo needs to support IPv6Mreq.\n-\n func GetsockoptIPv6Mreq(fd, level, opt int) (*IPv6Mreq, error) {\n \tvar value IPv6Mreq\n \tvallen := Socklen_t(SizeofIPv6Mreq)\n \terr := getsockopt(fd, level, opt, uintptr(unsafe.Pointer(&value)), &vallen)\n \treturn &value, err\n }\n \n-*/\n-\n //sys\tsetsockopt(s int, level int, name int, val *byte, vallen Socklen_t) (err error)\n //setsockopt(s int, level int, optname int, val *byte, vallen Socklen_t) int\n \n@@ -288,14 +280,10 @@ func SetsockoptIPMreq(fd, level, opt int, mreq *IPMreq) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }\n \n-/* FIXME: mksysinfo needs to support IMPreqn.\n-\n func SetsockoptIPMreqn(fd, level, opt int, mreq *IPMreqn) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }\n \n-*/\n-\n func SetsockoptIPv6Mreq(fd, level, opt int, mreq *IPv6Mreq) (err error) {\n \treturn setsockopt(fd, level, opt, (*byte)(unsafe.Pointer(mreq)), Socklen_t(unsafe.Sizeof(*mreq)))\n }"}, {"sha": "fb8986ce8497f2439390406441999ada8bed249b", "filename": "libgo/go/syscall/syscall_unix.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fsyscall%2Fsyscall_unix.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -7,6 +7,7 @@\n package syscall\n \n import (\n+\t\"runtime\"\n \t\"sync\"\n \t\"unsafe\"\n )\n@@ -20,6 +21,8 @@ var (\n func c_syscall32(trap int32, a1, a2, a3, a4, a5, a6 int32) int32 __asm__ (\"syscall\");\n func c_syscall64(trap int64, a1, a2, a3, a4, a5, a6 int64) int64 __asm__ (\"syscall\");\n \n+const darwinAMD64 = runtime.GOOS == \"darwin\" && runtime.GOARCH == \"amd64\"\n+\n // Do a system call.  We look at the size of uintptr to see how to pass\n // the arguments, so that we don't pass a 64-bit value when the function\n // expects a 32-bit one."}, {"sha": "0bf567b7c4d898fa6e159a15e1c198a6a7a12e64", "filename": "libgo/go/testing/benchmark.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftesting%2Fbenchmark.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fbenchmark.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -142,6 +142,13 @@ func (b *B) run() BenchmarkResult {\n func (b *B) launch() {\n \t// Run the benchmark for a single iteration in case it's expensive.\n \tn := 1\n+\n+\t// Signal that we're done whether we return normally\n+\t// or by FailNow's runtime.Goexit.\n+\tdefer func() {\n+\t\tb.signal <- b\n+\t}()\n+\n \tb.runN(n)\n \t// Run the benchmark for at least the specified amount of time.\n \td := time.Duration(*benchTime * float64(time.Second))\n@@ -162,7 +169,6 @@ func (b *B) launch() {\n \t\tb.runN(n)\n \t}\n \tb.result = BenchmarkResult{b.N, b.duration, b.bytes}\n-\tb.signal <- b\n }\n \n // The results of a benchmark run."}, {"sha": "cfe212dc1d78ff16e7fdc03c3b2afb97111cda21", "filename": "libgo/go/testing/testing.go", "status": "modified", "additions": 33, "deletions": 7, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftesting%2Ftesting.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftesting%2Ftesting.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Ftesting.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -63,7 +63,7 @@ var (\n \tmemProfile     = flag.String(\"test.memprofile\", \"\", \"write a memory profile to the named file after execution\")\n \tmemProfileRate = flag.Int(\"test.memprofilerate\", 0, \"if >=0, sets runtime.MemProfileRate\")\n \tcpuProfile     = flag.String(\"test.cpuprofile\", \"\", \"write a cpu profile to the named file during execution\")\n-\ttimeout        = flag.Int64(\"test.timeout\", 0, \"if > 0, sets time limit for tests in seconds\")\n+\ttimeout        = flag.Duration(\"test.timeout\", 0, \"if positive, sets an aggregate time limit for all tests\")\n \tcpuListStr     = flag.String(\"test.cpu\", \"\", \"comma-separated list of number of CPUs to use for each test\")\n \tparallel       = flag.Int(\"test.parallel\", runtime.GOMAXPROCS(0), \"maximum test parallelism\")\n \n@@ -90,7 +90,7 @@ func Short() bool {\n // If addFileLine is true, it also prefixes the string with the file and line of the call site.\n func decorate(s string, addFileLine bool) string {\n \tif addFileLine {\n-\t\t_, file, line, ok := runtime.Caller(4) // decorate + log + public function.\n+\t\t_, file, line, ok := runtime.Caller(3) // decorate + log + public function.\n \t\tif ok {\n \t\t\t// Truncate file name at last file name separator.\n \t\t\tif index := strings.LastIndex(file, \"/\"); index >= 0 {\n@@ -136,9 +136,27 @@ func (c *common) Failed() bool { return c.failed }\n // FailNow marks the function as having failed and stops its execution.\n // Execution will continue at the next Test.\n func (c *common) FailNow() {\n-\tc.duration = time.Now().Sub(c.start)\n \tc.Fail()\n-\tc.signal <- c.self\n+\n+\t// Calling runtime.Goexit will exit the goroutine, which\n+\t// will run the deferred functions in this goroutine,\n+\t// which will eventually run the deferred lines in tRunner,\n+\t// which will signal to the test loop that this test is done.\n+\t//\n+\t// A previous version of this code said:\n+\t//\n+\t//\tc.duration = ...\n+\t//\tc.signal <- c.self\n+\t//\truntime.Goexit()\n+\t//\n+\t// This previous version duplicated code (those lines are in\n+\t// tRunner no matter what), but worse the goroutine teardown\n+\t// implicit in runtime.Goexit was not guaranteed to complete\n+\t// before the test exited.  If a test deferred an important cleanup\n+\t// function (like removing temporary files), there was no guarantee\n+\t// it would run on a test failure.  Because we send on c.signal during\n+\t// a top-of-stack deferred function now, we know that the send\n+\t// only happens after any other stacked defers have completed.\n \truntime.Goexit()\n }\n \n@@ -195,9 +213,17 @@ type InternalTest struct {\n \n func tRunner(t *T, test *InternalTest) {\n \tt.start = time.Now()\n+\n+\t// When this goroutine is done, either because test.F(t)\n+\t// returned normally or because a test failure triggered \n+\t// a call to runtime.Goexit, record the duration and send\n+\t// a signal saying that the test is done.\n+\tdefer func() {\n+\t\tt.duration = time.Now().Sub(t.start)\n+\t\tt.signal <- t\n+\t}()\n+\n \ttest.F(t)\n-\tt.duration = time.Now().Sub(t.start)\n-\tt.signal <- t\n }\n \n // An internal function but exported because it is cross-package; part of the implementation\n@@ -346,7 +372,7 @@ var timer *time.Timer\n // startAlarm starts an alarm if requested.\n func startAlarm() {\n \tif *timeout > 0 {\n-\t\ttimer = time.AfterFunc(time.Duration(*timeout)*time.Second, alarm)\n+\t\ttimer = time.AfterFunc(*timeout, alarm)\n \t}\n }\n "}, {"sha": "2bef9df9c6f2339594f429fc6371008d7297f6e8", "filename": "libgo/go/testing/wrapper.go", "status": "removed", "additions": 0, "deletions": 105, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Ftesting%2Fwrapper.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3be18e47c33b61365786831e0f967f42b09922c9/libgo%2Fgo%2Ftesting%2Fwrapper.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftesting%2Fwrapper.go?ref=3be18e47c33b61365786831e0f967f42b09922c9", "patch": "@@ -1,105 +0,0 @@\n-// Copyright 2009 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// This file contains wrappers so t.Errorf etc. have documentation.\n-// TODO: delete when godoc shows exported methods for unexported embedded fields.\n-// TODO: need to change the argument to runtime.Caller in testing.go from 4 to 3 at that point.\n-\n-package testing\n-\n-// Fail marks the function as having failed but continues execution.\n-func (b *B) Fail() {\n-\tb.common.Fail()\n-}\n-\n-// Failed returns whether the function has failed.\n-func (b *B) Failed() bool {\n-\treturn b.common.Failed()\n-}\n-\n-// FailNow marks the function as having failed and stops its execution.\n-// Execution will continue at the next Test.\n-func (b *B) FailNow() {\n-\tb.common.FailNow()\n-}\n-\n-// Log formats its arguments using default formatting, analogous to Println(),\n-// and records the text in the error log.\n-func (b *B) Log(args ...interface{}) {\n-\tb.common.Log(args...)\n-}\n-\n-// Logf formats its arguments according to the format, analogous to Printf(),\n-// and records the text in the error log.\n-func (b *B) Logf(format string, args ...interface{}) {\n-\tb.common.Logf(format, args...)\n-}\n-\n-// Error is equivalent to Log() followed by Fail().\n-func (b *B) Error(args ...interface{}) {\n-\tb.common.Error(args...)\n-}\n-\n-// Errorf is equivalent to Logf() followed by Fail().\n-func (b *B) Errorf(format string, args ...interface{}) {\n-\tb.common.Errorf(format, args...)\n-}\n-\n-// Fatal is equivalent to Log() followed by FailNow().\n-func (b *B) Fatal(args ...interface{}) {\n-\tb.common.Fatal(args...)\n-}\n-\n-// Fatalf is equivalent to Logf() followed by FailNow().\n-func (b *B) Fatalf(format string, args ...interface{}) {\n-\tb.common.Fatalf(format, args...)\n-}\n-\n-// Fail marks the function as having failed but continues execution.\n-func (t *T) Fail() {\n-\tt.common.Fail()\n-}\n-\n-// Failed returns whether the function has failed.\n-func (t *T) Failed() bool {\n-\treturn t.common.Failed()\n-}\n-\n-// FailNow marks the function as having failed and stops its execution.\n-// Execution will continue at the next Test.\n-func (t *T) FailNow() {\n-\tt.common.FailNow()\n-}\n-\n-// Log formats its arguments using default formatting, analogous to Println(),\n-// and records the text in the error log.\n-func (t *T) Log(args ...interface{}) {\n-\tt.common.Log(args...)\n-}\n-\n-// Logf formats its arguments according to the format, analogous to Printf(),\n-// and records the text in the error log.\n-func (t *T) Logf(format string, args ...interface{}) {\n-\tt.common.Logf(format, args...)\n-}\n-\n-// Error is equivalent to Log() followed by Fail().\n-func (t *T) Error(args ...interface{}) {\n-\tt.common.Error(args...)\n-}\n-\n-// Errorf is equivalent to Logf() followed by Fail().\n-func (t *T) Errorf(format string, args ...interface{}) {\n-\tt.common.Errorf(format, args...)\n-}\n-\n-// Fatal is equivalent to Log() followed by FailNow().\n-func (t *T) Fatal(args ...interface{}) {\n-\tt.common.Fatal(args...)\n-}\n-\n-// Fatalf is equivalent to Logf() followed by FailNow().\n-func (t *T) Fatalf(format string, args ...interface{}) {\n-\tt.common.Fatalf(format, args...)\n-}"}, {"sha": "3be1ec44e697102f6d4dc799c1b3552aff3469fd", "filename": "libgo/go/text/template/doc.go", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fdoc.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -50,7 +50,9 @@ data, defined in detail below.\n \t\tThe value of the pipeline must be an array, slice, or map. If\n \t\tthe value of the pipeline has length zero, nothing is output;\n \t\totherwise, dot is set to the successive elements of the array,\n-\t\tslice, or map and T1 is executed.\n+\t\tslice, or map and T1 is executed. If the value is a map and the\n+\t\tkeys are of basic type with a defined order (\"comparable\"), the\n+\t\telements will be visited in sorted key order.\n \n \t{{range pipeline}} T1 {{else}} T0 {{end}}\n \t\tThe value of the pipeline must be an array, slice, or map. If"}, {"sha": "973189a8a62c97de524bab028c4e730f0af023dd", "filename": "libgo/go/text/template/exec.go", "status": "modified", "additions": 49, "deletions": 3, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -9,6 +9,7 @@ import (\n \t\"io\"\n \t\"reflect\"\n \t\"runtime\"\n+\t\"sort\"\n \t\"strings\"\n \t\"text/template/parse\"\n )\n@@ -78,10 +79,14 @@ func (s *state) error(err error) {\n func errRecover(errp *error) {\n \te := recover()\n \tif e != nil {\n-\t\tif _, ok := e.(runtime.Error); ok {\n+\t\tswitch err := e.(type) {\n+\t\tcase runtime.Error:\n+\t\t\tpanic(e)\n+\t\tcase error:\n+\t\t\t*errp = err\n+\t\tdefault:\n \t\t\tpanic(e)\n \t\t}\n-\t\t*errp = e.(error)\n \t}\n }\n \n@@ -230,7 +235,7 @@ func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) {\n \t\tif val.Len() == 0 {\n \t\t\tbreak\n \t\t}\n-\t\tfor _, key := range val.MapKeys() {\n+\t\tfor _, key := range sortKeys(val.MapKeys()) {\n \t\t\toneIteration(key, val.MapIndex(key))\n \t\t}\n \t\treturn\n@@ -672,3 +677,44 @@ func (s *state) printValue(n parse.Node, v reflect.Value) {\n \t}\n \tfmt.Fprint(s.wr, v.Interface())\n }\n+\n+// Types to help sort the keys in a map for reproducible output.\n+\n+type rvs []reflect.Value\n+\n+func (x rvs) Len() int      { return len(x) }\n+func (x rvs) Swap(i, j int) { x[i], x[j] = x[j], x[i] }\n+\n+type rvInts struct{ rvs }\n+\n+func (x rvInts) Less(i, j int) bool { return x.rvs[i].Int() < x.rvs[j].Int() }\n+\n+type rvUints struct{ rvs }\n+\n+func (x rvUints) Less(i, j int) bool { return x.rvs[i].Uint() < x.rvs[j].Uint() }\n+\n+type rvFloats struct{ rvs }\n+\n+func (x rvFloats) Less(i, j int) bool { return x.rvs[i].Float() < x.rvs[j].Float() }\n+\n+type rvStrings struct{ rvs }\n+\n+func (x rvStrings) Less(i, j int) bool { return x.rvs[i].String() < x.rvs[j].String() }\n+\n+// sortKeys sorts (if it can) the slice of reflect.Values, which is a slice of map keys.\n+func sortKeys(v []reflect.Value) []reflect.Value {\n+\tif len(v) <= 1 {\n+\t\treturn v\n+\t}\n+\tswitch v[0].Kind() {\n+\tcase reflect.Float32, reflect.Float64:\n+\t\tsort.Sort(rvFloats{v})\n+\tcase reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:\n+\t\tsort.Sort(rvInts{v})\n+\tcase reflect.String:\n+\t\tsort.Sort(rvStrings{v})\n+\tcase reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:\n+\t\tsort.Sort(rvUints{v})\n+\t}\n+\treturn v\n+}"}, {"sha": "2070cefde73475d567fc307e0c4b3582876bdde6", "filename": "libgo/go/text/template/exec_test.go", "status": "modified", "additions": 2, "deletions": 15, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftext%2Ftemplate%2Fexec_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -11,7 +11,6 @@ import (\n \t\"fmt\"\n \t\"os\"\n \t\"reflect\"\n-\t\"sort\"\n \t\"strings\"\n \t\"testing\"\n )\n@@ -169,18 +168,6 @@ func (t *T) MAdd(a int, b []int) []int {\n \treturn v\n }\n \n-// MSort is used to sort map keys for stable output. (Nice trick!)\n-func (t *T) MSort(m map[string]int) []string {\n-\tkeys := make([]string, len(m))\n-\ti := 0\n-\tfor k := range m {\n-\t\tkeys[i] = k\n-\t\ti++\n-\t}\n-\tsort.Strings(keys)\n-\treturn keys\n-}\n-\n // EPERM returns a value and an error according to its argument.\n func (t *T) EPERM(error bool) (bool, error) {\n \tif error {\n@@ -410,9 +397,9 @@ var execTests = []execTest{\n \t{\"range empty else\", \"{{range .SIEmpty}}-{{.}}-{{else}}EMPTY{{end}}\", \"EMPTY\", tVal, true},\n \t{\"range []bool\", \"{{range .SB}}-{{.}}-{{end}}\", \"-true--false-\", tVal, true},\n \t{\"range []int method\", \"{{range .SI | .MAdd .I}}-{{.}}-{{end}}\", \"-20--21--22-\", tVal, true},\n-\t{\"range map\", \"{{range .MSI | .MSort}}-{{.}}-{{end}}\", \"-one--three--two-\", tVal, true},\n+\t{\"range map\", \"{{range .MSI}}-{{.}}-{{end}}\", \"-1--3--2-\", tVal, true},\n \t{\"range empty map no else\", \"{{range .MSIEmpty}}-{{.}}-{{end}}\", \"\", tVal, true},\n-\t{\"range map else\", \"{{range .MSI | .MSort}}-{{.}}-{{else}}EMPTY{{end}}\", \"-one--three--two-\", tVal, true},\n+\t{\"range map else\", \"{{range .MSI}}-{{.}}-{{else}}EMPTY{{end}}\", \"-1--3--2-\", tVal, true},\n \t{\"range empty map else\", \"{{range .MSIEmpty}}-{{.}}-{{else}}EMPTY{{end}}\", \"EMPTY\", tVal, true},\n \t{\"range empty interface\", \"{{range .Empty3}}-{{.}}-{{else}}EMPTY{{end}}\", \"-7--8-\", tVal, true},\n \t{\"range empty nil\", \"{{range .Empty0}}-{{.}}-{{end}}\", \"\", tVal, true},"}, {"sha": "bd02b4867201c6ea22b6058cb2ca61a4174300a2", "filename": "libgo/go/time/format.go", "status": "modified", "additions": 130, "deletions": 20, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Fformat.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Fformat.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fformat.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -283,25 +283,16 @@ var atoiError = errors.New(\"time: invalid number\")\n \n // Duplicates functionality in strconv, but avoids dependency.\n func atoi(s string) (x int, err error) {\n-\ti := 0\n-\tif len(s) > 0 && s[0] == '-' {\n-\t\ti++\n+\tneg := false\n+\tif s != \"\" && s[0] == '-' {\n+\t\tneg = true\n+\t\ts = s[1:]\n \t}\n-\tif i >= len(s) {\n+\tx, rem, err := leadingInt(s)\n+\tif err != nil || rem != \"\" {\n \t\treturn 0, atoiError\n \t}\n-\tfor ; i < len(s); i++ {\n-\t\tc := s[i]\n-\t\tif c < '0' || c > '9' {\n-\t\t\treturn 0, atoiError\n-\t\t}\n-\t\tif x >= (1<<31-10)/10 {\n-\t\t\t// will overflow\n-\t\t\treturn 0, atoiError\n-\t\t}\n-\t\tx = x*10 + int(c) - '0'\n-\t}\n-\tif s[0] == '-' {\n+\tif neg {\n \t\tx = -x\n \t}\n \treturn x, nil\n@@ -344,10 +335,6 @@ func (b *buffer) WriteString(s string) {\n \t*b = append(*b, s...)\n }\n \n-func (b *buffer) WriteByte(c byte) {\n-\t*b = append(*b, c)\n-}\n-\n func (b *buffer) String() string {\n \treturn string([]byte(*b))\n }\n@@ -893,3 +880,126 @@ func parseNanoseconds(value string, nbytes int) (ns int, rangeErrString string,\n \t}\n \treturn\n }\n+\n+var errLeadingInt = errors.New(\"time: bad [0-9]*\") // never printed\n+\n+// leadingInt consumes the leading [0-9]* from s.\n+func leadingInt(s string) (x int, rem string, err error) {\n+\ti := 0\n+\tfor ; i < len(s); i++ {\n+\t\tc := s[i]\n+\t\tif c < '0' || c > '9' {\n+\t\t\tbreak\n+\t\t}\n+\t\tif x >= (1<<31-10)/10 {\n+\t\t\t// overflow\n+\t\t\treturn 0, \"\", errLeadingInt\n+\t\t}\n+\t\tx = x*10 + int(c) - '0'\n+\t}\n+\treturn x, s[i:], nil\n+}\n+\n+var unitMap = map[string]float64{\n+\t\"ns\": float64(Nanosecond),\n+\t\"us\": float64(Microsecond),\n+\t\"\u00b5s\": float64(Microsecond), // U+00B5 = micro symbol\n+\t\"\u03bcs\": float64(Microsecond), // U+03BC = Greek letter mu\n+\t\"ms\": float64(Millisecond),\n+\t\"s\":  float64(Second),\n+\t\"m\":  float64(Minute),\n+\t\"h\":  float64(Hour),\n+}\n+\n+// ParseDuration parses a duration string.\n+// A duration string is a possibly signed sequence of\n+// decimal numbers, each with optional fraction and a unit suffix,\n+// such as \"300ms\", \"-1.5h\" or \"2h45m\".\n+// Valid time units are \"ns\", \"us\" (or \"\u00b5s\"), \"ms\", \"s\", \"m\", \"h\".\n+func ParseDuration(s string) (Duration, error) {\n+\t// [-+]?([0-9]*(\\.[0-9]*)?[a-z]+)+\n+\torig := s\n+\tf := float64(0)\n+\tneg := false\n+\n+\t// Consume [-+]?\n+\tif s != \"\" {\n+\t\tc := s[0]\n+\t\tif c == '-' || c == '+' {\n+\t\t\tneg = c == '-'\n+\t\t\ts = s[1:]\n+\t\t}\n+\t}\n+\t// Special case: if all that is left is \"0\", this is zero.\n+\tif s == \"0\" {\n+\t\treturn 0, nil\n+\t}\n+\tif s == \"\" {\n+\t\treturn 0, errors.New(\"time: invalid duration \" + orig)\n+\t}\n+\tfor s != \"\" {\n+\t\tg := float64(0) // this element of the sequence\n+\n+\t\tvar x int\n+\t\tvar err error\n+\n+\t\t// The next character must be [0-9.]\n+\t\tif !(s[0] == '.' || ('0' <= s[0] && s[0] <= '9')) {\n+\t\t\treturn 0, errors.New(\"time: invalid duration \" + orig)\n+\t\t}\n+\t\t// Consume [0-9]*\n+\t\tpl := len(s)\n+\t\tx, s, err = leadingInt(s)\n+\t\tif err != nil {\n+\t\t\treturn 0, errors.New(\"time: invalid duration \" + orig)\n+\t\t}\n+\t\tg = float64(x)\n+\t\tpre := pl != len(s) // whether we consumed anything before a period\n+\n+\t\t// Consume (\\.[0-9]*)?\n+\t\tpost := false\n+\t\tif s != \"\" && s[0] == '.' {\n+\t\t\ts = s[1:]\n+\t\t\tpl := len(s)\n+\t\t\tx, s, err = leadingInt(s)\n+\t\t\tif err != nil {\n+\t\t\t\treturn 0, errors.New(\"time: invalid duration \" + orig)\n+\t\t\t}\n+\t\t\tscale := 1\n+\t\t\tfor n := pl - len(s); n > 0; n-- {\n+\t\t\t\tscale *= 10\n+\t\t\t}\n+\t\t\tg += float64(x) / float64(scale)\n+\t\t\tpost = pl != len(s)\n+\t\t}\n+\t\tif !pre && !post {\n+\t\t\t// no digits (e.g. \".s\" or \"-.s\")\n+\t\t\treturn 0, errors.New(\"time: invalid duration \" + orig)\n+\t\t}\n+\n+\t\t// Consume unit.\n+\t\ti := 0\n+\t\tfor ; i < len(s); i++ {\n+\t\t\tc := s[i]\n+\t\t\tif c == '.' || ('0' <= c && c <= '9') {\n+\t\t\t\tbreak\n+\t\t\t}\n+\t\t}\n+\t\tif i == 0 {\n+\t\t\treturn 0, errors.New(\"time: missing unit in duration \" + orig)\n+\t\t}\n+\t\tu := s[:i]\n+\t\ts = s[i:]\n+\t\tunit, ok := unitMap[u]\n+\t\tif !ok {\n+\t\t\treturn 0, errors.New(\"time: unknown unit \" + u + \" in duration \" + orig)\n+\t\t}\n+\n+\t\tf += g * unit\n+\t}\n+\n+\tif neg {\n+\t\tf = -f\n+\t}\n+\treturn Duration(f), nil\n+}"}, {"sha": "27820b0eaa76ffbb258c5429d957e03b2604929a", "filename": "libgo/go/time/sleep.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Fsleep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Fsleep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Fsleep.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -41,7 +41,7 @@ func (t *Timer) Stop() (ok bool) {\n }\n \n // NewTimer creates a new Timer that will send\n-// the current time on its channel after at least ns nanoseconds.\n+// the current time on its channel after at least duration d.\n func NewTimer(d Duration) *Timer {\n \tc := make(chan Time, 1)\n \tt := &Timer{\n@@ -70,7 +70,7 @@ func sendTime(now int64, c interface{}) {\n \n // After waits for the duration to elapse and then sends the current time\n // on the returned channel.\n-// It is equivalent to NewTimer(ns).C.\n+// It is equivalent to NewTimer(d).C.\n func After(d Duration) <-chan Time {\n \treturn NewTimer(d).C\n }"}, {"sha": "8c6b9bc3b2a9a84aedb03d8015f5b51983194744", "filename": "libgo/go/time/tick.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Ftick.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Ftick.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftick.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -14,7 +14,7 @@ type Ticker struct {\n }\n \n // NewTicker returns a new Ticker containing a channel that will send the\n-// time, in nanoseconds, with a period specified by the duration argument.\n+// time with a period specified by the duration argument.\n // It adjusts the intervals or drops ticks to make up for slow receivers.\n // The duration d must be greater than zero; if not, NewTicker will panic.\n func NewTicker(d Duration) *Ticker {"}, {"sha": "cdc1c39c5f535e62380d35a167fd8e8c88b5fcc9", "filename": "libgo/go/time/time_test.go", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Ftime_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fgo%2Ftime%2Ftime_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Ftime%2Ftime_test.go?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/gob\"\n \t\"encoding/json\"\n+\t\"math/rand\"\n \t\"strconv\"\n \t\"strings\"\n \t\"testing\"\n@@ -816,6 +817,82 @@ func TestNotJSONEncodableTime(t *testing.T) {\n \t}\n }\n \n+var parseDurationTests = []struct {\n+\tin   string\n+\tok   bool\n+\twant Duration\n+}{\n+\t// simple\n+\t{\"0\", true, 0},\n+\t{\"5s\", true, 5 * Second},\n+\t{\"30s\", true, 30 * Second},\n+\t{\"1478s\", true, 1478 * Second},\n+\t// sign\n+\t{\"-5s\", true, -5 * Second},\n+\t{\"+5s\", true, 5 * Second},\n+\t{\"-0\", true, 0},\n+\t{\"+0\", true, 0},\n+\t// decimal\n+\t{\"5.0s\", true, 5 * Second},\n+\t{\"5.6s\", true, 5*Second + 600*Millisecond},\n+\t{\"5.s\", true, 5 * Second},\n+\t{\".5s\", true, 500 * Millisecond},\n+\t{\"1.0s\", true, 1 * Second},\n+\t{\"1.00s\", true, 1 * Second},\n+\t{\"1.004s\", true, 1*Second + 4*Millisecond},\n+\t{\"1.0040s\", true, 1*Second + 4*Millisecond},\n+\t{\"100.00100s\", true, 100*Second + 1*Millisecond},\n+\t// different units\n+\t{\"10ns\", true, 10 * Nanosecond},\n+\t{\"11us\", true, 11 * Microsecond},\n+\t{\"12\u00b5s\", true, 12 * Microsecond}, // U+00B5\n+\t{\"12\u03bcs\", true, 12 * Microsecond}, // U+03BC\n+\t{\"13ms\", true, 13 * Millisecond},\n+\t{\"14s\", true, 14 * Second},\n+\t{\"15m\", true, 15 * Minute},\n+\t{\"16h\", true, 16 * Hour},\n+\t// composite durations\n+\t{\"3h30m\", true, 3*Hour + 30*Minute},\n+\t{\"10.5s4m\", true, 4*Minute + 10*Second + 500*Millisecond},\n+\t{\"-2m3.4s\", true, -(2*Minute + 3*Second + 400*Millisecond)},\n+\t{\"1h2m3s4ms5us6ns\", true, 1*Hour + 2*Minute + 3*Second + 4*Millisecond + 5*Microsecond + 6*Nanosecond},\n+\t{\"39h9m14.425s\", true, 39*Hour + 9*Minute + 14*Second + 425*Millisecond},\n+\n+\t// errors\n+\t{\"\", false, 0},\n+\t{\"3\", false, 0},\n+\t{\"-\", false, 0},\n+\t{\"s\", false, 0},\n+\t{\".\", false, 0},\n+\t{\"-.\", false, 0},\n+\t{\".s\", false, 0},\n+\t{\"+.s\", false, 0},\n+}\n+\n+func TestParseDuration(t *testing.T) {\n+\tfor _, tc := range parseDurationTests {\n+\t\td, err := ParseDuration(tc.in)\n+\t\tif tc.ok && (err != nil || d != tc.want) {\n+\t\t\tt.Errorf(\"ParseDuration(%q) = %v, %v, want %v, nil\", tc.in, d, err, tc.want)\n+\t\t} else if !tc.ok && err == nil {\n+\t\t\tt.Errorf(\"ParseDuration(%q) = _, nil, want _, non-nil\", tc.in)\n+\t\t}\n+\t}\n+}\n+\n+func TestParseDurationRoundTrip(t *testing.T) {\n+\tfor i := 0; i < 100; i++ {\n+\t\t// Resolutions finer than milliseconds will result in\n+\t\t// imprecise round-trips.\n+\t\td0 := Duration(rand.Int31()) * Millisecond\n+\t\ts := d0.String()\n+\t\td1, err := ParseDuration(s)\n+\t\tif err != nil || d0 != d1 {\n+\t\t\tt.Errorf(\"round-trip failed: %d => %q => %d, %v\", d0, s, d1, err)\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkNow(b *testing.B) {\n \tfor i := 0; i < b.N; i++ {\n \t\tNow()"}, {"sha": "80474566eeb5d218508bfa0788c729776f31b143", "filename": "libgo/mksysinfo.sh", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fmksysinfo.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fmksysinfo.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fmksysinfo.sh?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -55,6 +55,9 @@ cat > sysinfo.c <<EOF\n #if defined(HAVE_SYS_MMAN_H)\n #include <sys/mman.h>\n #endif\n+#if defined(HAVE_SYS_PRCTL_H)\n+#include <sys/prctl.h>\n+#endif\n #if defined(HAVE_SYS_PTRACE_H)\n #include <sys/ptrace.h>\n #endif\n@@ -210,6 +213,10 @@ if ! grep '^const EPOLL_CLOEXEC' ${OUT} >/dev/null 2>&1; then\n   echo \"const EPOLL_CLOEXEC = 02000000\" >> ${OUT}\n fi\n \n+# Prctl constants.\n+grep '^const _PR_' gen-sysinfo.go |\n+  sed -e 's/^\\(const \\)_\\(PR_[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n+\n # Ptrace constants.\n grep '^const _PTRACE' gen-sysinfo.go |\n   sed -e 's/^\\(const \\)_\\(PTRACE[^= ]*\\)\\(.*\\)$/\\1\\2 = _\\2/' >> ${OUT}\n@@ -505,6 +512,26 @@ if ! grep 'type IPv6Mreq ' ${OUT} >/dev/null 2>&1; then\n   echo 'type IPv6Mreq struct { Multiaddr [16]byte; Interface uint32; }' >> ${OUT}\n fi\n \n+# The size of the ipv6_mreq struct.\n+echo 'var SizeofIPv6Mreq = int(unsafe.Sizeof(IPv6Mreq{}))' >> ${OUT}\n+\n+# The ip_mreqn struct.\n+grep '^type _ip_mreqn ' gen-sysinfo.go | \\\n+    sed -e 's/_ip_mreqn/IPMreqn/' \\\n+      -e 's/imr_multiaddr/Multiaddr/' \\\n+      -e 's/imr_address/Address/' \\\n+      -e 's/imr_ifindex/Ifindex/' \\\n+      -e 's/_in_addr/[4]byte/g' \\\n+    >> ${OUT}\n+\n+# We need IPMreq to compile the net package.\n+if ! grep 'type IPMreqn ' ${OUT} >/dev/null 2>&1; then\n+  echo 'type IPMreqn struct { Multiaddr [4]byte; Interface [4]byte; Ifindex int32 }' >> ${OUT}\n+fi\n+\n+# The size of the ip_mreqn struct.\n+echo 'var SizeofIPMreqn = int(unsafe.Sizeof(IPMreqn{}))' >> ${OUT}\n+\n # Try to guess the type to use for fd_set.\n fd_set=`grep '^type _fd_set ' gen-sysinfo.go || true`\n fds_bits_type=\"_C_long\""}, {"sha": "9ad9eda8350e0454f68e4a1eaf6b54614b3c0e47", "filename": "libgo/runtime/malloc.goc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmalloc.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmalloc.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.goc?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -129,7 +129,7 @@ __go_free(void *v)\n \tif(v == nil)\n \t\treturn;\n \t\n-\t// If you change this also change mgc0.c:/^sweepspan,\n+\t// If you change this also change mgc0.c:/^sweep,\n \t// which has a copy of the guts of free.\n \n \tm = runtime_m();"}, {"sha": "aa7d9ff3ae256ac2c00d76e1ee6a7f9fc5ed980b", "filename": "libgo/runtime/malloc.h", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmalloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmalloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmalloc.h?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -123,10 +123,9 @@ enum\n \n \t// Max number of threads to run garbage collection.\n \t// 2, 3, and 4 are all plausible maximums depending\n-\t// on the hardware details of the machine.  The second\n-\t// proc is the one that helps the most (after the first),\n-\t// so start with just 2 for now.\n-\tMaxGcproc = 2,\n+\t// on the hardware details of the machine.  The garbage\n+\t// collector scales well to 4 cpus.\n+\tMaxGcproc = 4,\n };\n \n // A generic linked list of blocks.  (Typically the block is bigger than sizeof(MLink).)"}, {"sha": "26633ab1f1879224d04d198cc3395c5f87073a0b", "filename": "libgo/runtime/mgc0.c", "status": "modified", "additions": 5, "deletions": 55, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmgc0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fmgc0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fmgc0.c?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -62,9 +62,6 @@ enum {\n #define bitMask (bitBlockBoundary | bitAllocated | bitMarked | bitSpecial)\n \n // TODO: Make these per-M.\n-static uint64 nlookup;\n-static uint64 nsizelookup;\n-static uint64 naddrlookup;\n static uint64 nhandoff;\n \n static int32 gctrace;\n@@ -218,8 +215,6 @@ scanblock(byte *b, int64 n)\n \n \t\t\t// Otherwise consult span table to find beginning.\n \t\t\t// (Manually inlined copy of MHeap_LookupMaybe.)\n-\t\t\tnlookup++;\n-\t\t\tnaddrlookup++;\n \t\t\tk = (uintptr)obj>>PageShift;\n \t\t\tx = k;\n \t\t\tif(sizeof(void*) == 8)\n@@ -307,49 +302,8 @@ scanblock(byte *b, int64 n)\n \t\tb = *--wp;\n \t\tnobj--;\n \n-\t\t// Figure out n = size of b.  Start by loading bits for b.\n-\t\toff = (uintptr*)b - (uintptr*)arena_start;\n-\t\tbitp = (uintptr*)arena_start - off/wordsPerBitmapWord - 1;\n-\t\tshift = off % wordsPerBitmapWord;\n-\t\txbits = *bitp;\n-\t\tbits = xbits >> shift;\n-\n-\t\t// Might be small; look for nearby block boundary.\n-\t\t// A block boundary is marked by either bitBlockBoundary\n-\t\t// or bitAllocated being set (see notes near their definition).\n-\t\tenum {\n-\t\t\tboundary = bitBlockBoundary|bitAllocated\n-\t\t};\n-\t\t// Look for a block boundary both after and before b\n-\t\t// in the same bitmap word.\n-\t\t//\n-\t\t// A block boundary j words after b is indicated by\n-\t\t//\tbits>>j & boundary\n-\t\t// assuming shift+j < bitShift.  (If shift+j >= bitShift then\n-\t\t// we'll be bleeding other bit types like bitMarked into our test.)\n-\t\t// Instead of inserting the conditional shift+j < bitShift into the loop,\n-\t\t// we can let j range from 1 to bitShift as long as we first\n-\t\t// apply a mask to keep only the bits corresponding\n-\t\t// to shift+j < bitShift aka j < bitShift-shift.\n-\t\tbits &= (boundary<<(bitShift-shift)) - boundary;\n-\n-\t\t// A block boundary j words before b is indicated by\n-\t\t//\txbits>>(shift-j) & boundary\n-\t\t// (assuming shift >= j).  There is no cleverness here\n-\t\t// avoid the test, because when j gets too large the shift\n-\t\t// turns negative, which is undefined in C.\n-\n-\t\tfor(j=1; j<bitShift; j++) {\n-\t\t\tif(((bits>>j)&boundary) != 0 || (shift>=j && ((xbits>>(shift-j))&boundary) != 0)) {\n-\t\t\t\tn = j*PtrSize;\n-\t\t\t\tgoto scan;\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Fall back to asking span about size class.\n+\t\t// Ask span about size class.\n \t\t// (Manually inlined copy of MHeap_Lookup.)\n-\t\tnlookup++;\n-\t\tnsizelookup++;\n \t\tx = (uintptr)b>>PageShift;\n \t\tif(sizeof(void*) == 8)\n \t\t\tx -= (uintptr)arena_start>>PageShift;\n@@ -358,7 +312,6 @@ scanblock(byte *b, int64 n)\n \t\t\tn = s->npages<<PageShift;\n \t\telse\n \t\t\tn = runtime_class_to_size[s->sizeclass];\n-\tscan:;\n \t}\n }\n \n@@ -1018,9 +971,6 @@ runtime_gc(int32 force)\n \t}\n \n \tt0 = runtime_nanotime();\n-\tnlookup = 0;\n-\tnsizelookup = 0;\n-\tnaddrlookup = 0;\n \tnhandoff = 0;\n \n \tm->gcing = 1;\n@@ -1085,11 +1035,11 @@ runtime_gc(int32 force)\n \t\truntime_printf(\"pause %llu\\n\", (unsigned long long)t3-t0);\n \n \tif(gctrace) {\n-\t\truntime_printf(\"gc%d: %llu+%llu+%llu ms %llu -> %llu MB %llu -> %llu (%llu-%llu) objects %llu pointer lookups (%llu size, %llu addr) %llu handoff\\n\",\n-\t\t\tmstats.numgc, (unsigned long long)(t1-t0)/1000000, (unsigned long long)(t2-t1)/1000000, (unsigned long long)(t3-t2)/1000000,\n+\t\truntime_printf(\"gc%d(%d): %llu+%llu+%llu ms %llu -> %llu MB %llu -> %llu (%llu-%llu) objects %llu handoff\\n\",\n+\t\t\tmstats.numgc, work.nproc, (unsigned long long)(t1-t0)/1000000, (unsigned long long)(t2-t1)/1000000, (unsigned long long)(t3-t2)/1000000,\n \t\t\t(unsigned long long)heap0>>20, (unsigned long long)heap1>>20, (unsigned long long)obj0, (unsigned long long)obj1,\n-\t\t\t(unsigned long long)mstats.nmalloc, (unsigned long long)mstats.nfree,\n-\t\t\t(unsigned long long)nlookup, (unsigned long long)nsizelookup, (unsigned long long)naddrlookup, (unsigned long long) nhandoff);\n+\t\t\t(unsigned long long) mstats.nmalloc, (unsigned long long)mstats.nfree,\n+\t\t\t(unsigned long long) nhandoff);\n \t}\n \n \truntime_semrelease(&gcsema);"}, {"sha": "922fa20448d2acc20b9f0fdccb0d80e032479df1", "filename": "libgo/runtime/runtime.c", "status": "modified", "additions": 20, "deletions": 1, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.c?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -115,7 +115,7 @@ runtime_goargs(void)\n }\n \n void\n-runtime_goenvs(void)\n+runtime_goenvs_unix(void)\n {\n \tString *s;\n \tint32 i, n;\n@@ -183,3 +183,22 @@ runtime_fastrand1(void)\n \tm->fastrand = x;\n \treturn x;\n }\n+\n+struct funcline_go_return\n+{\n+  String retfile;\n+  int32 retline;\n+};\n+\n+struct funcline_go_return\n+runtime_funcline_go(void *f, uintptr targetpc)\n+  __asm__(\"libgo_runtime.runtime.funcline_go\");\n+\n+struct funcline_go_return\n+runtime_funcline_go(void *f __attribute__((unused)),\n+\t\t    uintptr targetpc __attribute__((unused)))\n+{\n+  struct funcline_go_return ret;\n+  runtime_memclr(&ret, sizeof ret);\n+  return ret;\n+}"}, {"sha": "253c49b21f376773392e42868c798c7970477dc6", "filename": "libgo/runtime/runtime.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime.h?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -266,6 +266,7 @@ void\truntime_args(int32, byte**);\n void\truntime_osinit();\n void\truntime_goargs(void);\n void\truntime_goenvs(void);\n+void\truntime_goenvs_unix(void);\n void\truntime_throw(const char*) __attribute__ ((noreturn));\n void\truntime_panicstring(const char*) __attribute__ ((noreturn));\n void*\truntime_mal(uintptr);"}, {"sha": "fd8918ed57733d3ba4e154d0cf8d7327f861da4b", "filename": "libgo/runtime/runtime1.goc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime1.goc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fruntime1.goc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fruntime1.goc?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -8,3 +8,7 @@ package runtime\n func GOMAXPROCS(n int32) (ret int32) {\n \tret = runtime_gomaxprocsfunc(n);\n }\n+\n+func NumCPU() (ret int32) {\n+\tret = runtime_ncpu;\n+}"}, {"sha": "8dd5fc4b481150a62909a86ba3c452fc9284f8b2", "filename": "libgo/runtime/thread-linux.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fthread-linux.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Fruntime%2Fthread-linux.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fthread-linux.c?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -103,3 +103,9 @@ runtime_osinit(void)\n {\n \truntime_ncpu = getproccount();\n }\n+\n+void\n+runtime_goenvs(void)\n+{\n+\truntime_goenvs_unix();\n+}"}, {"sha": "3511c52a0716c316b6a14090bd7e2bf01da02778", "filename": "libgo/testsuite/gotest", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Ftestsuite%2Fgotest", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/df1304ee03f41aed179545d1e8b4684cfd22bbdf/libgo%2Ftestsuite%2Fgotest", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Ftestsuite%2Fgotest?ref=df1304ee03f41aed179545d1e8b4684cfd22bbdf", "patch": "@@ -273,8 +273,18 @@ esac\n \n # Split $gofiles into external gofiles (those in *_test packages)\n # and internal ones (those in the main package).\n-xgofiles=$(echo $(grep '^package[ \t]' $gofiles /dev/null | grep ':.*_test' | sed 's/:.*//'))\n-gofiles=$(echo $(grep '^package[ \t]' $gofiles /dev/null | grep -v ':.*_test' | sed 's/:.*//'))\n+for f in $gofiles; do\n+    package=`grep '^package[ \t]' $f | sed 1q`\n+    case \"$package\" in\n+    *_test)\n+\txgofiles=\"$xgofiles $f\"\n+\t;;\n+    *)\n+\tngofiles=\"$ngofiles $f\"\n+\t;;\n+    esac\n+done\n+gofiles=$ngofiles\n \n # External $O file\n xofile=\"\"\n@@ -413,9 +423,9 @@ xno)\n \t${GL} *.o ${GOLIBS}\n \n \tif test \"$trace\" = \"true\"; then\n-\t    echo ./a.out -test.short -test.timeout=$timeout \"$@\"\n+\t    echo ./a.out -test.short -test.timeout=${timeout}s \"$@\"\n \tfi\n-\t./a.out -test.short -test.timeout=$timeout \"$@\" &\n+\t./a.out -test.short -test.timeout=${timeout}s \"$@\" &\n \tpid=$!\n \t(sleep `expr $timeout + 10`\n \t    echo > gotest-timeout"}]}