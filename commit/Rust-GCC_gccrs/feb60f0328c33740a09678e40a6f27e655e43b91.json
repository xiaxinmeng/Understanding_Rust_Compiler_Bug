{"sha": "feb60f0328c33740a09678e40a6f27e655e43b91", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmViNjBmMDMyOGMzMzc0MGEwOTY3OGU0MGE2ZjI3ZTY1NWU0M2I5MQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2008-04-27T15:35:19Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2008-04-27T15:35:19Z"}, "message": "targhooks.h (default_emutls_var_fields, [...]): Declare.\n\n\t* targhooks.h (default_emutls_var_fields,\n\tdefault_emutls_var_init): Declare.\n\t* tree.h (DECL_THREAD_LOCAL): Compare against TLS_MODEL_REAL.\n\t* target.h (struct gcc_target): Add struct emutls member.\n\t* target-def.h (TARGET_EMUTLS_GET_ADDRESS,\n\tTARGET_EMUTLS_REGISTER_COMMON, TARGET_EMUTLS_VAR_SECTION,\n\tTARGET_EMUTLS_TMPL_SECTION, TARGET_EMUTLS_VAR_PREFIX,\n\tTARGET_EMUTLS_TMPL_PREFIX, TARGET_EMUTLS_VAR_FIELDS,\n\tTARGET_EMUTLS_VAR_INIT, TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS,\n\tTARGET_EMUTLS_VAR_ALIGN_FIXED, TARGET_EMUTLS): New.\n\t(TARGET_INITIALIZER): Add TARGET_EMUTLS.\n\t* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS,\n\tBUILT_IN_EMUTLS_REGISTER_COMMON): Get name from targetm structure.\n\t* dwarf2out.c (loc_descriptor_from_tree_1): Check if emutls can\n\temit debug information.\n\t* coretypes.h (tls_model): Add TLS_MODEL_EMULATED, TLS_MODEL_REAL.\n\t* varasm.c: Include targhooks.h.\n\t(emutls_object_section, emutls_tmpl_section): New.\n\t(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): Remove.\n\t(EMUTLS_SEPARATOR): New.\n\t(prefix_name): New.\n\t(get_emutls_object_name): New.\n\t(default_emutls_var_fields): New, broken out of ...\n\t(get_emutls_object_type): ... here.  Adjust to use target hooks.\n\t(get_emutls_init_templ_addr): Adjust to use target hooks.\n\t(emutls_decl): Adjust to use target hooks.\n\t(emutls_finish): Likewise.\n\t(default_emutls_var_init): New, broken out of ...\n\t(assemble_variable): ... here.  Adjust to use target hooks.\n\t* output.h (enum section_category): Add SECCAT_EMUTLS_VAR,\n\tSECCAT_EMUTLS_TMPL.\n\t* c-common.c (handle_section_attribute): Prevent overriding\n\tsections for emulated tls with special sections.\n\t* config/i386/i386.c (x86_64_elf_select_section): Add\n\tSECCAT_EMUTLS_VAR and SECCAT_EMUTLS_TMPL.\n\t(x86_64_elf_unique_section): Likewise.\n\t* config/vxworks.c: Include tree.h.\n\t(vxworks_emutls_var_fields, vxworks_emutls_var_init): New.\n\t(vxworks_override_options): Set TLS scheme.\n\t* gcc/doc/tm.texi (Emulated TLS): New node.\n\n\tgcc/testsuite/\n\t* gcc.dg/tls/section-2.c: New.\n\t* gcc.dg/tls/emutls-1.c: New.\n\t* lib/target-supports.exp (check_effective_target_tls_native):\n\tExclude vxworks.\n\nFrom-SVN: r134729", "tree": {"sha": "2fa1779872e1658a836ad7c6225a1303bfacea23", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fa1779872e1658a836ad7c6225a1303bfacea23"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/feb60f0328c33740a09678e40a6f27e655e43b91", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb60f0328c33740a09678e40a6f27e655e43b91", "html_url": "https://github.com/Rust-GCC/gccrs/commit/feb60f0328c33740a09678e40a6f27e655e43b91", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/feb60f0328c33740a09678e40a6f27e655e43b91/comments", "author": null, "committer": null, "parents": [{"sha": "f509e2962970850d4b6cb465a7ceaa4af9c5f8d0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f509e2962970850d4b6cb465a7ceaa4af9c5f8d0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f509e2962970850d4b6cb465a7ceaa4af9c5f8d0"}], "stats": {"total": 719, "additions": 584, "deletions": 135}, "files": [{"sha": "37d675217a5ce68a7f7b15f8ab28b0db2461475c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -1,3 +1,46 @@\n+2008-04-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* targhooks.h (default_emutls_var_fields,\n+\tdefault_emutls_var_init): Declare.\n+\t* tree.h (DECL_THREAD_LOCAL): Compare against TLS_MODEL_REAL.\n+\t* target.h (struct gcc_target): Add struct emutls member.\n+\t* target-def.h (TARGET_EMUTLS_GET_ADDRESS,\n+\tTARGET_EMUTLS_REGISTER_COMMON, TARGET_EMUTLS_VAR_SECTION,\n+\tTARGET_EMUTLS_TMPL_SECTION, TARGET_EMUTLS_VAR_PREFIX,\n+\tTARGET_EMUTLS_TMPL_PREFIX, TARGET_EMUTLS_VAR_FIELDS,\n+\tTARGET_EMUTLS_VAR_INIT, TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS,\n+\tTARGET_EMUTLS_VAR_ALIGN_FIXED, TARGET_EMUTLS): New.\n+\t(TARGET_INITIALIZER): Add TARGET_EMUTLS.\n+\t* builtins.def (BUILT_IN_EMUTLS_GET_ADDRESS,\n+\tBUILT_IN_EMUTLS_REGISTER_COMMON): Get name from targetm structure.\n+\t* dwarf2out.c (loc_descriptor_from_tree_1): Check if emutls can\n+\temit debug information.\n+\t* coretypes.h (tls_model): Add TLS_MODEL_EMULATED, TLS_MODEL_REAL.\n+\t* varasm.c: Include targhooks.h.\n+\t(emutls_object_section, emutls_tmpl_section): New.\n+\t(EMUTLS_VAR_PREFIX, EMUTLS_TMPL_PREFIX): Remove.\n+\t(EMUTLS_SEPARATOR): New.\n+\t(prefix_name): New.\n+\t(get_emutls_object_name): New.\n+\t(default_emutls_var_fields): New, broken out of ...\n+\t(get_emutls_object_type): ... here.  Adjust to use target hooks.\n+\t(get_emutls_init_templ_addr): Adjust to use target hooks.\n+\t(emutls_decl): Adjust to use target hooks.\n+\t(emutls_finish): Likewise.\n+\t(default_emutls_var_init): New, broken out of ...\n+\t(assemble_variable): ... here.  Adjust to use target hooks.\n+\t* output.h (enum section_category): Add SECCAT_EMUTLS_VAR,\n+\tSECCAT_EMUTLS_TMPL.\n+\t* c-common.c (handle_section_attribute): Prevent overriding\n+\tsections for emulated tls with special sections.\n+\t* config/i386/i386.c (x86_64_elf_select_section): Add\n+\tSECCAT_EMUTLS_VAR and SECCAT_EMUTLS_TMPL.\n+\t(x86_64_elf_unique_section): Likewise.\n+\t* config/vxworks.c: Include tree.h.\n+\t(vxworks_emutls_var_fields, vxworks_emutls_var_init): New.\n+\t(vxworks_override_options): Set TLS scheme.\n+\t* gcc/doc/tm.texi (Emulated TLS): New node.\n+\n 2008-04-26  Simon Baldwin <simonb@google.com>\n \n \tPR c/35652"}, {"sha": "722f81c7e3eac72047d6e7ac607182aa2f7af2a5", "filename": "gcc/builtins.def", "status": "modified", "additions": 10, "deletions": 2, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fbuiltins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fbuiltins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.def?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -745,8 +745,16 @@ DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_ENTER, \"profile_func_enter\")\n DEF_BUILTIN_STUB (BUILT_IN_PROFILE_FUNC_EXIT, \"profile_func_exit\")\n \n /* TLS emulation.  */\n-DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, \"__emutls_get_address\", BT_FN_PTR_PTR, ATTR_CONST_NOTHROW_NONNULL)\n-DEF_EXT_LIB_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON, \"__emutls_register_common\", BT_FN_VOID_PTR_WORD_WORD_PTR, ATTR_NOTHROW_LIST)\n+DEF_BUILTIN (BUILT_IN_EMUTLS_GET_ADDRESS, targetm.emutls.get_address,\n+\t     BUILT_IN_NORMAL,\n+\t     BT_FN_PTR_PTR,  BT_FN_PTR_PTR,\n+\t     true, true, true, ATTR_CONST_NOTHROW_NONNULL, false,\n+\t     !targetm.have_tls)\n+DEF_BUILTIN (BUILT_IN_EMUTLS_REGISTER_COMMON,\n+\t     targetm.emutls.register_common, BUILT_IN_NORMAL,\n+\t     BT_FN_VOID_PTR_WORD_WORD_PTR, BT_FN_VOID_PTR_WORD_WORD_PTR,\n+\t     true, true, true, ATTR_NOTHROW_LIST, false,\n+\t     !targetm.have_tls)\n \n /* Synchronization Primitives.  */\n #include \"sync-builtins.def\""}, {"sha": "5858523968082ed4d1ec00ddf224ba96009b08b0", "filename": "gcc/c-common.c", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-common.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -5476,6 +5476,13 @@ handle_section_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n \t\t     *node);\n \t      *no_add_attrs = true;\n \t    }\n+\t  else if (TREE_CODE (decl) == VAR_DECL\n+\t\t   && !targetm.have_tls && targetm.emutls.tmpl_section\n+\t\t   && DECL_THREAD_LOCAL_P (decl))\n+\t    {\n+\t      error (\"section of %q+D cannot be overridden\", *node);\n+\t      *no_add_attrs = true;\n+\t    }\n \t  else\n \t    DECL_SECTION_NAME (decl) = TREE_VALUE (args);\n \t}"}, {"sha": "43c669f8c38bdd4a9bfe3b9af16ccd583d88c6ed", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 21, "deletions": 13, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -2854,6 +2854,9 @@ x86_64_elf_select_section (tree decl, int reloc,\n \t  /* We don't split these for medium model.  Place them into\n \t     default sections and hope for best.  */\n \t  break;\n+\tcase SECCAT_EMUTLS_VAR:\n+\tcase SECCAT_EMUTLS_TMPL:\n+\t  gcc_unreachable ();\n \t}\n       if (sname)\n \t{\n@@ -2890,16 +2893,16 @@ x86_64_elf_unique_section (tree decl, int reloc)\n \tcase SECCAT_DATA_REL_LOCAL:\n \tcase SECCAT_DATA_REL_RO:\n \tcase SECCAT_DATA_REL_RO_LOCAL:\n-          prefix = one_only ? \".gnu.linkonce.ld.\" : \".ldata.\";\n+          prefix = one_only ? \".ld\" : \".ldata\";\n \t  break;\n \tcase SECCAT_BSS:\n-          prefix = one_only ? \".gnu.linkonce.lb.\" : \".lbss.\";\n+          prefix = one_only ? \".lb\" : \".lbss\";\n \t  break;\n \tcase SECCAT_RODATA:\n \tcase SECCAT_RODATA_MERGE_STR:\n \tcase SECCAT_RODATA_MERGE_STR_INIT:\n \tcase SECCAT_RODATA_MERGE_CONST:\n-          prefix = one_only ? \".gnu.linkonce.lr.\" : \".lrodata.\";\n+          prefix = one_only ? \".lr\" : \".lrodata\";\n \t  break;\n \tcase SECCAT_SRODATA:\n \tcase SECCAT_SDATA:\n@@ -2911,23 +2914,28 @@ x86_64_elf_unique_section (tree decl, int reloc)\n \t  /* We don't split these for medium model.  Place them into\n \t     default sections and hope for best.  */\n \t  break;\n+\tcase SECCAT_EMUTLS_VAR:\n+\t  prefix = targetm.emutls.var_section;\n+\t  break;\n+\tcase SECCAT_EMUTLS_TMPL:\n+\t  prefix = targetm.emutls.tmpl_section;\n+\t  break;\n \t}\n       if (prefix)\n \t{\n-\t  const char *name;\n-\t  size_t nlen, plen;\n+\t  const char *name, *linkonce;\n \t  char *string;\n-\t  plen = strlen (prefix);\n \n \t  name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n \t  name = targetm.strip_name_encoding (name);\n-\t  nlen = strlen (name);\n-\n-\t  string = (char *) alloca (nlen + plen + 1);\n-\t  memcpy (string, prefix, plen);\n-\t  memcpy (string + plen, name, nlen + 1);\n-\n-\t  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);\n+\t  \n+\t  /* If we're using one_only, then there needs to be a .gnu.linkonce\n+     \t     prefix to the section name.  */\n+\t  linkonce = one_only ? \".gnu.linkonce\" : \"\";\n+  \n+\t  string = ACONCAT ((linkonce, prefix, \".\", name, NULL));\n+\t  \n+\t  DECL_SECTION_NAME (decl) = build_string (strlen (string), string);\n \t  return;\n \t}\n     }"}, {"sha": "709791b02a306feb9aee4c3963adbc39de938fdd", "filename": "gcc/config/vxworks.c", "status": "modified", "additions": 77, "deletions": 0, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fconfig%2Fvxworks.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fconfig%2Fvxworks.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvxworks.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -26,6 +26,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"toplev.h\"\n #include \"output.h\"\n #include \"tm.h\"\n+#include \"tree.h\"\n \n /* Like default_named_section_asm_out_constructor, except that even\n    constructors with DEFAULT_INIT_PRIORITY must go in a numbered\n@@ -56,11 +57,87 @@ vxworks_asm_out_destructor (rtx symbol, int priority)\n   assemble_addr_to_section (symbol, sec);\n }\n \n+/* Return the list of FIELD_DECLs that make up an emulated TLS\n+   variable's control object.  TYPE is the structure these are fields\n+   of and *NAME will be filled in with the structure tag that should\n+   be used.  */\n+\n+static tree\n+vxworks_emutls_var_fields (tree type, tree *name)\n+{\n+  tree field, next_field;\n+  \n+  *name = get_identifier (\"__tls_var\");\n+  \n+  field = build_decl (FIELD_DECL, get_identifier (\"size\"),\n+\t\t      unsigned_type_node);\n+  DECL_CONTEXT (field) = type;\n+  next_field = field;\n+\n+  field = build_decl (FIELD_DECL, get_identifier (\"module_id\"),\n+\t\t      unsigned_type_node);\n+  DECL_CONTEXT (field) = type;\n+  TREE_CHAIN (field) = next_field;\n+  next_field = field;\n+\n+  field = build_decl (FIELD_DECL, get_identifier (\"offset\"),\n+\t\t      unsigned_type_node);\n+  DECL_CONTEXT (field) = type;\n+  TREE_CHAIN (field) = next_field;\n+\n+  return field;\n+}\n+\n+/* Return the CONSTRUCTOR to initialize an emulated TLS control\n+   object.  VAR is the control object.  DECL is the TLS object itself\n+   and TMPL_ADDR is the address (an ADDR_EXPR) of the initializer for\n+   that object.  */\n+\n+static tree\n+vxworks_emutls_var_init (tree var, tree decl, tree tmpl_addr)\n+{\n+  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 3);\n+  constructor_elt *elt;\n+  \n+  tree type = TREE_TYPE (var);\n+  tree field = TYPE_FIELDS (type);\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  elt->index = field;\n+  elt->value = fold_convert (TREE_TYPE (field), tmpl_addr);\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = TREE_CHAIN (field);\n+  elt->index = field;\n+  elt->value = build_int_cst (TREE_TYPE (field), 0);\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = TREE_CHAIN (field);\n+  elt->index = field;\n+  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+  \n+  return build_constructor (type, v);\n+}\n+\n /* Do VxWorks-specific parts of OVERRIDE_OPTIONS.  */\n \n void\n vxworks_override_options (void)\n {\n+  /* We don't support __thread via target hooks.  */\n+  targetm.have_tls = false;\n+\n+  targetm.emutls.get_address = \"__builtin___tls_lookup\";\n+  targetm.emutls.register_common = NULL;\n+  targetm.emutls.var_section = \".tls_vars\";\n+  targetm.emutls.tmpl_section = \".tls_data\";\n+  targetm.emutls.var_prefix = \"__tls__\";\n+  targetm.emutls.tmpl_prefix = \"\";\n+  targetm.emutls.var_fields = vxworks_emutls_var_fields;\n+  targetm.emutls.var_init = vxworks_emutls_var_init;\n+  targetm.emutls.var_align_fixed = true;\n+  targetm.emutls.debug_form_tls_address = true;\n+  \n   /* We can use .ctors/.dtors sections only in RTP mode.  */\n   targetm.have_ctors_dtors = TARGET_VXWORKS_RTP;\n "}, {"sha": "4fe480f781fbd5d0b6c9030424dbf5cff278242b", "filename": "gcc/coretypes.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -69,7 +69,9 @@ struct cpp_reader;\n    to it, so it's here.  */\n enum tls_model {\n   TLS_MODEL_NONE,\n-  TLS_MODEL_GLOBAL_DYNAMIC,\n+  TLS_MODEL_EMULATED,\n+  TLS_MODEL_REAL,\n+  TLS_MODEL_GLOBAL_DYNAMIC = TLS_MODEL_REAL,\n   TLS_MODEL_LOCAL_DYNAMIC,\n   TLS_MODEL_INITIAL_EXEC,\n   TLS_MODEL_LOCAL_EXEC"}, {"sha": "6ce3b4adbcde62bc7f51cba7aaa1ff296e0503de", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -50,6 +50,7 @@ through the macros defined in the @file{.h} file.\n * Floating Point::      Handling floating point for cross-compilers.\n * Mode Switching::      Insertion of mode-switching instructions.\n * Target Attributes::   Defining target-specific uses of @code{__attribute__}.\n+* Emulated TLS::        Emulated TLS support.\n * MIPS Coprocessors::   MIPS coprocessor support and how to customize it.\n * PCH Target::          Validity checking for precompiled headers.\n * C++ ABI::             Controlling C++ ABI changes.\n@@ -9192,6 +9193,84 @@ attributes, @code{false} otherwise.  By default, if a function has a\n target specific attribute attached to it, it will not be inlined.\n @end deftypefn\n \n+@node Emulated TLS\n+@section Emulating TLS\n+@cindex Emulated TLS\n+\n+For targets whose psABI does not provide Thread Local Storage via\n+specific relocations and instruction sequences, an emulation layer is\n+used.  A set of target hooks allows this emulation layer to be\n+configured for the requirements of a particular target.  For instance\n+the psABI may infact specify TLS support in terms of an emulation\n+layer.\n+\n+The emulation layer works by creating a control object for every TLS\n+object.  To access the TLS object, a lookup function is provided\n+which, when given the address of the control object, will return the\n+address of the current thread's instance of the TLS object.\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_GET_ADDRESS\n+Contains the name of the helper function that uses a TLS control\n+object to locate a TLS instance.  The default causes libgcc's\n+emulated TLS helper function to be used.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_REGISTER_COMMON\n+Contains the name of the helper function that should be used at\n+program startup to register TLS objects that are implicitly\n+initialized to zero.  If this is @code{NULL}, all TLS objects will\n+have explicit initializers.  The default causes libgcc's emulated TLS\n+registration function to be used.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_SECTION\n+Contains the name of the section in which TLS control variables should\n+be placed.  The default of @code{NULL} allows these to be placed in\n+any section.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_SECTION\n+Contains the name of the section in which TLS initializers should be\n+placed.  The default of @code{NULL} allows these to be placed in any\n+section.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_VAR_PREFIX\n+Contains the prefix to be prepended to TLS control variable names.\n+The default of @code{NULL} uses a target-specific prefix.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {const char *} TARGET_EMUTLS_TMPL_PREFIX\n+Contains the prefix to be prepended to TLS initializer objects.  The\n+default of @code{NULL} uses a target-specific prefix.\n+@end deftypevr\n+\n+@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_FIELDS (tree @var{type}, tree *@var{name})\n+Specifies a function that generates the FIELD_DECLs for a TLS control\n+object type.  @var{type} is the RECORD_TYPE the fields are for and\n+@var{name} should be filled with the structure tag, if the default of\n+@code{__emutls_object} is unsuitable.  The default creates a type suitable\n+for libgcc's emulated TLS function.\n+@end deftypefn\n+\n+@deftypefn {Target Hook} tree TARGET_EMUTLS_VAR_INIT (tree @var{var}, tree @var{decl}, tree @var{tmpl_addr})\n+Specifies a function that generates the CONSTRUCTOR to initialize a\n+TLS control object.  @var{var} is the TLS control object, @var{decl}\n+is the TLS object and @var{tmpl_addr} is the address of the\n+initializer.  The default initializes libgcc's emulated TLS control object.\n+@end deftypefn\n+\n+@deftypevr {Target Hook} {bool} TARGET_EMUTLS_VAR_ALIGN_FIXED\n+Specifies whether the alignment of TLS control variable objects is\n+fixed and should not be increased as some backends may do to optimize\n+single objects.  The default is false.\n+@end deftypevr\n+\n+@deftypevr {Target Hook} {bool} TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\n+Specifies whether a DWARF @code{DW_OP_form_tls_address} location descriptor\n+may be used to describe emulated TLS control objects.\n+@end deftypevr\n+\n @node MIPS Coprocessors\n @section Defining coprocessor specifics for MIPS targets.\n @cindex MIPS coprocessor-definition macros"}, {"sha": "83b3fb5aa83718eb5b8368869176d4a22eb85d3c", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 29, "deletions": 12, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -9494,16 +9494,33 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n       if (DECL_THREAD_LOCAL_P (loc))\n \t{\n \t  rtx rtl;\n+\t  unsigned first_op;\n+\t  unsigned second_op;\n \n-\t  /* If this is not defined, we have no way to emit the data.  */\n-\t  if (!targetm.have_tls || !targetm.asm_out.output_dwarf_dtprel)\n-\t    return 0;\n-\n-\t  /* The way DW_OP_GNU_push_tls_address is specified, we can only\n-\t     look up addresses of objects in the current module.  */\n-\t  if (DECL_EXTERNAL (loc))\n-\t    return 0;\n-\n+\t  if (targetm.have_tls)\n+\t    {\n+\t      /* If this is not defined, we have no way to emit the\n+\t         data.  */\n+\t      if (!targetm.asm_out.output_dwarf_dtprel)\n+\t\treturn 0;\n+\n+\t       /* The way DW_OP_GNU_push_tls_address is specified, we\n+\t     \t  can only look up addresses of objects in the current\n+\t     \t  module.  */\n+\t      if (DECL_EXTERNAL (loc))\n+\t\treturn 0;\n+\t      first_op = INTERNAL_DW_OP_tls_addr;\n+\t      second_op = DW_OP_GNU_push_tls_address;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (!targetm.emutls.debug_form_tls_address)\n+\t\treturn 0;\n+\t      loc = emutls_decl (loc);\n+\t      first_op = DW_OP_addr;\n+\t      second_op = DW_OP_form_tls_address;\n+\t    }\n+\t  \n \t  rtl = rtl_for_decl_location (loc);\n \t  if (rtl == NULL_RTX)\n \t    return 0;\n@@ -9514,11 +9531,11 @@ loc_descriptor_from_tree_1 (tree loc, int want_address)\n \t  if (! CONSTANT_P (rtl))\n \t    return 0;\n \n-\t  ret = new_loc_descr (INTERNAL_DW_OP_tls_addr, 0, 0);\n+\t  ret = new_loc_descr (first_op, 0, 0);\n \t  ret->dw_loc_oprnd1.val_class = dw_val_class_addr;\n \t  ret->dw_loc_oprnd1.v.val_addr = rtl;\n-\n-\t  ret1 = new_loc_descr (DW_OP_GNU_push_tls_address, 0, 0);\n+\t  \n+\t  ret1 = new_loc_descr (second_op, 0, 0);\n \t  add_loc_descr (&ret, ret1);\n \n \t  have_address = 1;"}, {"sha": "15daf5b8d0d91fc04f6b01ffbdd0566974a73a3f", "filename": "gcc/output.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Foutput.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Foutput.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foutput.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -460,7 +460,10 @@ enum section_category\n \n   SECCAT_BSS,\n   SECCAT_SBSS,\n-  SECCAT_TBSS\n+  SECCAT_TBSS,\n+\n+  SECCAT_EMUTLS_VAR,\n+  SECCAT_EMUTLS_TMPL\n };\n \n /* Information that is provided by all instances of the section type.  */"}, {"sha": "8566786194406a5e556e10eb127552c492d6d7ab", "filename": "gcc/target-def.h", "status": "modified", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarget-def.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarget-def.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget-def.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -692,6 +692,61 @@\n     TARGET_CXX_ADJUST_CLASS_AT_DEFINITION\t\\\n   }\n \n+/* EMUTLS specific */\n+#ifndef TARGET_EMUTLS_GET_ADDRESS\n+#define TARGET_EMUTLS_GET_ADDRESS \"__builtin___emutls_get_address\"\n+#endif\n+\n+#ifndef TARGET_EMUTLS_REGISTER_COMMON\n+#define TARGET_EMUTLS_REGISTER_COMMON \"__builtin___emutls_register_common\"\n+#endif\n+\n+#ifndef TARGET_EMUTLS_VAR_SECTION\n+#define TARGET_EMUTLS_VAR_SECTION NULL\n+#endif\n+\n+#ifndef TARGET_EMUTLS_TMPL_SECTION\n+#define TARGET_EMUTLS_TMPL_SECTION NULL\n+#endif\n+\n+#ifndef TARGET_EMUTLS_VAR_PREFIX\n+#define TARGET_EMUTLS_VAR_PREFIX NULL\n+#endif\n+\n+#ifndef TARGET_EMUTLS_TMPL_PREFIX\n+#define TARGET_EMUTLS_TMPL_PREFIX NULL\n+#endif\n+\n+#ifndef TARGET_EMUTLS_VAR_FIELDS\n+#define TARGET_EMUTLS_VAR_FIELDS default_emutls_var_fields\n+#endif\n+\n+#ifndef TARGET_EMUTLS_VAR_INIT\n+#define TARGET_EMUTLS_VAR_INIT default_emutls_var_init\n+#endif\n+\n+#ifndef TARGET_EMUTLS_VAR_ALIGN_FIXED\n+#define TARGET_EMUTLS_VAR_ALIGN_FIXED false\n+#endif\n+\n+#ifndef TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\n+#define TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS false\n+#endif\n+\n+#define TARGET_EMUTLS\t\t\t\t\\\n+  {\t\t\t\t\t\t\\\n+    TARGET_EMUTLS_GET_ADDRESS,  \t\t\\\n+    TARGET_EMUTLS_REGISTER_COMMON,  \t\t\\\n+    TARGET_EMUTLS_VAR_SECTION,  \t\t\\\n+    TARGET_EMUTLS_TMPL_SECTION,  \t\t\\\n+    TARGET_EMUTLS_VAR_PREFIX,  \t\t\t\\\n+    TARGET_EMUTLS_TMPL_PREFIX,  \t\t\\\n+    TARGET_EMUTLS_VAR_FIELDS,\t\t\t\\\n+    TARGET_EMUTLS_VAR_INIT,\t\t\t\\\n+    TARGET_EMUTLS_VAR_ALIGN_FIXED,\t\t\\\n+    TARGET_EMUTLS_DEBUG_FORM_TLS_ADDRESS\t\\\n+  }\n+\n /* The whole shebang.  */\n #define TARGET_INITIALIZER\t\t\t\\\n {\t\t\t\t\t\t\\\n@@ -783,6 +838,7 @@\n   TARGET_INSTANTIATE_DECLS,\t\t\t\\\n   TARGET_C,\t\t\t\t\t\\\n   TARGET_CXX,\t\t\t\t\t\\\n+  TARGET_EMUTLS,\t\t\t\t\\\n   TARGET_EXTRA_LIVE_ON_ENTRY,\t\t\t\\\n   TARGET_UNWIND_TABLES_DEFAULT,\t\t\t\\\n   TARGET_HAVE_NAMED_SECTIONS,\t\t\t\\"}, {"sha": "c331020b6abe92e0b6ea5fc1aa189a9654b8a74f", "filename": "gcc/target.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarget.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarget.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarget.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -917,6 +917,34 @@ struct gcc_target\n     void (*adjust_class_at_definition) (tree type);\n   } cxx;\n \n+  /* Functions and data for emulated TLS support.  */\n+  struct emutls {\n+    /* Name of the address and common functions.  */\n+    const char *get_address;\n+    const char *register_common;\n+\n+    /* Prefixes for proxy variable and template.  */\n+    const char *var_section;\n+    const char *tmpl_section;\n+\n+    /* Prefixes for proxy variable and template.  */\n+    const char *var_prefix;\n+    const char *tmpl_prefix;\n+    \n+    /* Function to generate field definitions of the proxy variable.  */\n+    tree (*var_fields) (tree, tree *);\n+\n+    /* Function to initialize a proxy variable.  */\n+    tree (*var_init) (tree, tree, tree);\n+\n+    /* Whether we are allowed to alter the usual alignment of the\n+       proxy variable.  */\n+    bool var_align_fixed;\n+\n+    /* Whether we can emit debug information for TLS vars.  */\n+    bool debug_form_tls_address;\n+  } emutls;  \n+\n   /* For targets that need to mark extra registers as live on entry to\n      the function, they should define this target hook and set their\n      bits in the bitmap passed in. */  "}, {"sha": "c94dd069f5e154f0727401586aa18966718f5cd7", "filename": "gcc/targhooks.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarghooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftarghooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftarghooks.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -94,3 +94,5 @@ extern void hook_void_bitmap (bitmap);\n extern bool default_handle_c_option (size_t, const char *, int);\n extern int default_reloc_rw_mask (void);\n extern tree default_mangle_decl_assembler_name (tree, tree);\n+extern tree default_emutls_var_fields (tree, tree *);\n+extern tree default_emutls_var_init (tree, tree, tree);"}, {"sha": "4c1397ca992b22888eb31967773bc6c63e439eb2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -1,3 +1,10 @@\n+2008-04-27  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* gcc.dg/tls/section-2.c: New.\n+\t* gcc.dg/tls/emutls-1.c: New.\n+\t* lib/target-supports.exp (check_effective_target_tls_native):\n+\tExclude vxworks.\n+\n 2008-04-26  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR testsuite/36053"}, {"sha": "a0dea509434784f68f6157853992605b7a844eb0", "filename": "gcc/testsuite/gcc.dg/tls/emutls-1.c", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Femutls-1.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -0,0 +1,21 @@\n+/* { dg-do run { target *-wrs-vxworks } } */\n+/* { dg-require-effective-target tls } */\n+\n+/* vxworks' TLS model requires no extra padding on the tls proxy\n+   objects.  */\n+\n+__thread int i;\n+__thread int j;\n+\n+extern int __tls__i;\n+extern int __tls__j;\n+\n+int main ()\n+{\n+  int delta = ((char *)&__tls__j - (char *)&__tls__i);\n+\n+  if (delta < 0)\n+    delta = -delta;\n+  \n+  return delta != 12;\n+}"}, {"sha": "c823f2dae612aae0fde757335f9960bb43d69076", "filename": "gcc/testsuite/gcc.dg/tls/section-2.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fsection-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fsection-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftls%2Fsection-2.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -0,0 +1,7 @@\n+/* Verify that we get errors for trying to put TLS data in \n+   sections which can't work.  */\n+/* { dg-require-effective-target tls } */\n+\n+#define A(X)\t__attribute__((section(X)))\n+\n+__thread int i A(\"foo\"); /* { dg-error \"cannot be overridden\" } */"}, {"sha": "5309ee2074fae849ffc9425defce1d43c02e08a0", "filename": "gcc/testsuite/lib/target-supports.exp", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Flib%2Ftarget-supports.exp?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -518,6 +518,13 @@ proc check_effective_target_tls {} {\n # This won't change for different subtargets so cache the result.\n \n proc check_effective_target_tls_native {} {\n+    # VxWorks uses emulated TLS machinery, but with non-standard helper\n+    # functions, so we fail to automatically detect it.\n+    global target_triplet\n+    if { [regexp \".*-.*-vxworks.*\" $target_triplet] } {\n+\treturn 0\n+    }\n+    \n     return [check_no_messages_and_pattern tls_native \"!emutls\" assembly {\n \t__thread int i;\n \tint f (void) { return i; }"}, {"sha": "c63ee947fabde73bf3e2963fd08fa307d8504892", "filename": "gcc/tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Ftree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.h?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -3178,7 +3178,7 @@ extern void decl_fini_priority_insert (tree, priority_type);\n /* In a VAR_DECL, nonzero if the data should be allocated from\n    thread-local storage.  */\n #define DECL_THREAD_LOCAL_P(NODE) \\\n-  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model != TLS_MODEL_NONE)\n+  (VAR_DECL_CHECK (NODE)->decl_with_vis.tls_model >= TLS_MODEL_REAL)\n \n struct tree_var_decl GTY(())\n {"}, {"sha": "0d22fc33c0c7a70f6b28f64cead6c6ea0e124848", "filename": "gcc/varasm.c", "status": "modified", "additions": 182, "deletions": 105, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/feb60f0328c33740a09678e40a6f27e655e43b91/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=feb60f0328c33740a09678e40a6f27e655e43b91", "patch": "@@ -48,6 +48,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tm_p.h\"\n #include \"debug.h\"\n #include \"target.h\"\n+#include \"targhooks.h\"\n #include \"tree-mudflap.h\"\n #include \"cgraph.h\"\n #include \"cfglayout.h\"\n@@ -194,68 +195,95 @@ static GTY(()) struct rtx_constant_pool *shared_constant_pool;\n static GTY ((if_marked (\"tree_map_marked_p\"), param_is (struct tree_map)))\n      htab_t emutls_htab;\n static GTY (()) tree emutls_object_type;\n-\n-#ifndef NO_DOT_IN_LABEL\n-# define EMUTLS_VAR_PREFIX\t\"__emutls_v.\"\n-# define EMUTLS_TMPL_PREFIX\t\"__emutls_t.\"\n-#elif !defined NO_DOLLAR_IN_LABEL\n-# define EMUTLS_VAR_PREFIX\t\"__emutls_v$\"\n-# define EMUTLS_TMPL_PREFIX\t\"__emutls_t$\"\n+/* Emulated TLS objects have the TLS model TLS_MODEL_EMULATED.  This\n+   macro can be used on them to distinguish the control variable from\n+   the initialization template.  */\n+#define DECL_EMUTLS_VAR_P(D)  (TREE_TYPE (D) == emutls_object_type)\n+\n+#if !defined (NO_DOT_IN_LABEL)\n+# define EMUTLS_SEPARATOR\t\".\"\n+#elif !defined (NO_DOLLAR_IN_LABEL)\n+# define EMUTLS_SEPARATOR\t\"$\"\n #else\n-# define EMUTLS_VAR_PREFIX\t\"__emutls_v_\"\n-# define EMUTLS_TMPL_PREFIX\t\"__emutls_t_\"\n+# define EMUTLS_SEPARATOR\t\"_\"\n #endif\n \n-/* Create an identifier for the struct __emutls_object, given an identifier\n-   of the DECL_ASSEMBLY_NAME of the original object.  */\n+/* Create an IDENTIFIER_NODE by prefixing PREFIX to the\n+   IDENTIFIER_NODE NAME's name.  */\n \n static tree\n-get_emutls_object_name (tree name)\n+prefix_name (const char *prefix, tree name)\n {\n-  char *toname = alloca (strlen (IDENTIFIER_POINTER (name))\n-\t\t\t + sizeof (EMUTLS_VAR_PREFIX));\n-  strcpy (toname, EMUTLS_VAR_PREFIX);\n-  strcpy (toname + sizeof (EMUTLS_VAR_PREFIX) - 1, IDENTIFIER_POINTER (name));\n+  unsigned plen = strlen (prefix);\n+  unsigned nlen = strlen (IDENTIFIER_POINTER (name));\n+  char *toname = alloca (plen + nlen + 1);\n+  \n+  memcpy (toname, prefix, plen);\n+  memcpy (toname + plen, IDENTIFIER_POINTER (name), nlen + 1);\n \n   return get_identifier (toname);\n }\n \n-/* Create the structure for struct __emutls_object.  This should match the\n-   structure at the top of emutls.c, modulo the union there.  */\n+/* Create an identifier for the struct __emutls_object, given an identifier\n+   of the DECL_ASSEMBLY_NAME of the original object.  */\n \n static tree\n-get_emutls_object_type (void)\n+get_emutls_object_name (tree name)\n {\n-  tree type, type_name, field, next_field, word_type_node;\n-\n-  type = emutls_object_type;\n-  if (type)\n-    return type;\n-\n-  emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);\n-  type_name = get_identifier (\"__emutls_object\");\n-  type_name = build_decl (TYPE_DECL, type_name, type);\n-  TYPE_NAME (type) = type_name;\n+  const char *prefix = (targetm.emutls.var_prefix\n+\t\t\t? targetm.emutls.var_prefix\n+\t\t\t: \"__emutls_v\" EMUTLS_SEPARATOR);\n+  return prefix_name (prefix, name);\n+}\n \n+tree\n+default_emutls_var_fields (tree type, tree *name ATTRIBUTE_UNUSED)\n+{\n+  tree word_type_node, field, next_field;\n+  \n   field = build_decl (FIELD_DECL, get_identifier (\"__templ\"), ptr_type_node);\n   DECL_CONTEXT (field) = type;\n   next_field = field;\n-\n-  field = build_decl (FIELD_DECL, get_identifier (\"__offset\"), ptr_type_node);\n+    \n+  field = build_decl (FIELD_DECL, get_identifier (\"__offset\"),\n+\t\t      ptr_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n   next_field = field;\n-\n+  \n   word_type_node = lang_hooks.types.type_for_mode (word_mode, 1);\n-  field = build_decl (FIELD_DECL, get_identifier (\"__align\"), word_type_node);\n+  field = build_decl (FIELD_DECL, get_identifier (\"__align\"),\n+\t\t      word_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n   next_field = field;\n-\n+  \n   field = build_decl (FIELD_DECL, get_identifier (\"__size\"), word_type_node);\n   DECL_CONTEXT (field) = type;\n   TREE_CHAIN (field) = next_field;\n \n+  return field;\n+}\n+\n+/* Create the structure for struct __emutls_object.  This should match the\n+   structure at the top of emutls.c, modulo the union there.  */\n+\n+static tree\n+get_emutls_object_type (void)\n+{\n+  tree type, type_name, field;\n+\n+  type = emutls_object_type;\n+  if (type)\n+    return type;\n+\n+  emutls_object_type = type = lang_hooks.types.make_type (RECORD_TYPE);\n+  type_name = NULL;\n+  field = targetm.emutls.var_fields (type, &type_name);\n+  if (!type_name)\n+    type_name = get_identifier (\"__emutls_object\");\n+  type_name = build_decl (TYPE_DECL, type_name, type);\n+  TYPE_NAME (type) = type_name;\n   TYPE_FIELDS (type) = field;\n   layout_type (type);\n \n@@ -269,26 +297,30 @@ static tree\n get_emutls_init_templ_addr (tree decl)\n {\n   tree name, to;\n-  char *toname;\n-\n-  if (!DECL_INITIAL (decl))\n+  \n+  if (targetm.emutls.register_common && !DECL_INITIAL (decl)\n+      && !DECL_SECTION_NAME (decl))\n     return null_pointer_node;\n \n   name = DECL_ASSEMBLER_NAME (decl);\n-  toname = alloca (strlen (IDENTIFIER_POINTER (name))\n-\t\t   + sizeof (EMUTLS_TMPL_PREFIX));\n-  strcpy (toname, EMUTLS_TMPL_PREFIX);\n-  strcpy (toname + sizeof (EMUTLS_TMPL_PREFIX) - 1, IDENTIFIER_POINTER (name));\n-  name = get_identifier (toname);\n+  if (!targetm.emutls.tmpl_prefix || targetm.emutls.tmpl_prefix[0])\n+    {\n+      const char *prefix = (targetm.emutls.tmpl_prefix\n+\t\t\t    ? targetm.emutls.tmpl_prefix\n+\t\t\t    : \"__emutls_t\" EMUTLS_SEPARATOR);\n+      name = prefix_name (prefix, name);\n+    }\n \n   to = build_decl (VAR_DECL, name, TREE_TYPE (decl));\n   SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n-\n+  DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;\n   DECL_ARTIFICIAL (to) = 1;\n   TREE_USED (to) = TREE_USED (decl);\n   TREE_READONLY (to) = 1;\n   DECL_IGNORED_P (to) = 1;\n   DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+  DECL_SECTION_NAME (to) = DECL_SECTION_NAME (decl);\n+  \n   DECL_WEAK (to) = DECL_WEAK (decl);\n   if (DECL_ONE_ONLY (decl))\n     {\n@@ -348,14 +380,18 @@ emutls_decl (tree decl)\n       h->to = to;\n       *(struct tree_map **) loc = h;\n \n+      DECL_TLS_MODEL (to) = TLS_MODEL_EMULATED;\n       DECL_ARTIFICIAL (to) = 1;\n       DECL_IGNORED_P (to) = 1;\n       TREE_READONLY (to) = 0;\n-\n       SET_DECL_ASSEMBLER_NAME (to, DECL_NAME (to));\n       if (DECL_ONE_ONLY (decl))\n \tmake_decl_one_only (to);\n       DECL_CONTEXT (to) = DECL_CONTEXT (decl);\n+      if (targetm.emutls.var_align_fixed)\n+\t/* If we're not allowed to change the proxy object's\n+\t   alignment, pretend it's been set by the user.  */\n+\tDECL_USER_ALIGN (to) = 1;\n     }\n \n   /* Note that these fields may need to be updated from time to time from\n@@ -413,16 +449,19 @@ emutls_common_1 (void **loc, void *xstmts)\n void\n emutls_finish (void)\n {\n-  tree body = NULL_TREE;\n-\n-  if (emutls_htab == NULL)\n-    return;\n+  if (!targetm.emutls.register_common)\n+    {\n+      tree body = NULL_TREE;\n \n-  htab_traverse_noresize (emutls_htab, emutls_common_1, &body);\n-  if (body == NULL_TREE)\n-    return;\n+      if (emutls_htab == NULL)\n+\treturn;\n \n-  cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n+      htab_traverse_noresize (emutls_htab, emutls_common_1, &body);\n+      if (body == NULL_TREE)\n+\treturn;\n+      \n+      cgraph_build_static_cdtor ('I', body, DEFAULT_INIT_PRIORITY);\n+    }\n }\n \n /* Helper routines for maintaining section_htab.  */\n@@ -1125,7 +1164,12 @@ get_variable_section (tree decl, bool prefer_noswitch_p)\n     {\n       if (DECL_THREAD_LOCAL_P (decl))\n \treturn tls_comm_section;\n-      if (TREE_PUBLIC (decl) && bss_initializer_p (decl))\n+      /* This cannot be common bss for an emulated TLS object without\n+\t a register_common hook.  */\n+      else if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED\n+\t       && !targetm.emutls.register_common)\n+\t;\n+      else if (TREE_PUBLIC (decl) && bss_initializer_p (decl))\n \treturn comm_section;\n     }\n \n@@ -1950,6 +1994,40 @@ assemble_variable_contents (tree decl, const char *name,\n     }\n }\n \n+/* Initialize emulated tls object TO, which refers to TLS variable\n+   DECL and is initialized by PROXY.  */\n+\n+tree\n+default_emutls_var_init (tree to, tree decl, tree proxy)\n+{\n+  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n+  constructor_elt *elt;\n+  tree type = TREE_TYPE (to);\n+  tree field = TYPE_FIELDS (type);\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  elt->index = field;\n+  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = TREE_CHAIN (field);\n+  elt->index = field;\n+  elt->value = build_int_cst (TREE_TYPE (field),\n+\t\t\t      DECL_ALIGN_UNIT (decl));\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = TREE_CHAIN (field);\n+  elt->index = field;\n+  elt->value = null_pointer_node;\n+  \n+  elt = VEC_quick_push (constructor_elt, v, NULL);\n+  field = TREE_CHAIN (field);\n+  elt->index = field;\n+  elt->value = proxy;\n+  \n+  return build_constructor (type, v);\n+}\n+\n /* Assemble everything that is needed for a variable or function declaration.\n    Not used for automatic variables, and not used for function definitions.\n    Should not be called for variables of incomplete structure type.\n@@ -1984,32 +2062,8 @@ assemble_variable (tree decl, int top_level ATTRIBUTE_UNUSED,\n \t      || (DECL_INITIAL (decl)\n \t\t  && DECL_INITIAL (decl) != error_mark_node)))\n \t{\n-\t  VEC(constructor_elt,gc) *v = VEC_alloc (constructor_elt, gc, 4);\n-\t  constructor_elt *elt;\n-\t  tree type = TREE_TYPE (to);\n-\t  tree field = TYPE_FIELDS (type);\n-\n-\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t  elt->index = field;\n-\t  elt->value = fold_convert (TREE_TYPE (field), DECL_SIZE_UNIT (decl));\n-\n-\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t  field = TREE_CHAIN (field);\n-\t  elt->index = field;\n-\t  elt->value = build_int_cst (TREE_TYPE (field),\n-\t\t\t\t      DECL_ALIGN_UNIT (decl));\n-\n-\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t  field = TREE_CHAIN (field);\n-\t  elt->index = field;\n-\t  elt->value = null_pointer_node;\n-\n-\t  elt = VEC_quick_push (constructor_elt, v, NULL);\n-\t  field = TREE_CHAIN (field);\n-\t  elt->index = field;\n-\t  elt->value = get_emutls_init_templ_addr (decl);\n-\n-\t  DECL_INITIAL (to) = build_constructor (type, v);\n+\t  DECL_INITIAL (to) = targetm.emutls.var_init\n+\t    (to, decl, get_emutls_init_templ_addr (decl));\n \n \t  /* Make sure the template is marked as needed early enough.\n \t     Without this, if the variable is placed in a\n@@ -5786,13 +5840,26 @@ categorize_decl_for_section (const_tree decl, int reloc)\n     ret = SECCAT_RODATA;\n \n   /* There are no read-only thread-local sections.  */\n-  if (TREE_CODE (decl) == VAR_DECL && DECL_THREAD_LOCAL_P (decl))\n+  if (TREE_CODE (decl) == VAR_DECL && DECL_TLS_MODEL (decl))\n     {\n+      if (DECL_TLS_MODEL (decl) == TLS_MODEL_EMULATED)\n+\t{\n+\t  if (DECL_EMUTLS_VAR_P (decl))\n+\t    {\n+\t      if (targetm.emutls.var_section)\n+\t\tret = SECCAT_EMUTLS_VAR;\n+\t    }\n+\t  else\n+\t    {\n+\t      if (targetm.emutls.tmpl_prefix)\n+\t\tret = SECCAT_EMUTLS_TMPL;\n+\t    }\n+\t}\n       /* Note that this would be *just* SECCAT_BSS, except that there's\n \t no concept of a read-only thread-local-data section.  */\n-      if (ret == SECCAT_BSS\n-\t  || (flag_zero_initialized_in_bss\n-\t      && initializer_zerop (DECL_INITIAL (decl))))\n+      else if (ret == SECCAT_BSS\n+\t       || (flag_zero_initialized_in_bss\n+\t\t   && initializer_zerop (DECL_INITIAL (decl))))\n \tret = SECCAT_TBSS;\n       else\n \tret = SECCAT_TDATA;\n@@ -5884,6 +5951,12 @@ default_elf_select_section (tree decl, int reloc,\n     case SECCAT_TBSS:\n       sname = \".tbss\";\n       break;\n+    case SECCAT_EMUTLS_VAR:\n+      sname = targetm.emutls.var_section;\n+      break;\n+    case SECCAT_EMUTLS_TMPL:\n+      sname = targetm.emutls.tmpl_section;\n+      break;\n     default:\n       gcc_unreachable ();\n     }\n@@ -5901,69 +5974,73 @@ default_unique_section (tree decl, int reloc)\n {\n   /* We only need to use .gnu.linkonce if we don't have COMDAT groups.  */\n   bool one_only = DECL_ONE_ONLY (decl) && !HAVE_COMDAT_GROUP;\n-  const char *prefix, *name;\n-  size_t nlen, plen;\n+  const char *prefix, *name, *linkonce;\n   char *string;\n \n   switch (categorize_decl_for_section (decl, reloc))\n     {\n     case SECCAT_TEXT:\n-      prefix = one_only ? \".gnu.linkonce.t.\" : \".text.\";\n+      prefix = one_only ? \".t\" : \".text\";\n       break;\n     case SECCAT_RODATA:\n     case SECCAT_RODATA_MERGE_STR:\n     case SECCAT_RODATA_MERGE_STR_INIT:\n     case SECCAT_RODATA_MERGE_CONST:\n-      prefix = one_only ? \".gnu.linkonce.r.\" : \".rodata.\";\n+      prefix = one_only ? \".r\" : \".rodata\";\n       break;\n     case SECCAT_SRODATA:\n-      prefix = one_only ? \".gnu.linkonce.s2.\" : \".sdata2.\";\n+      prefix = one_only ? \".s2\" : \".sdata2\";\n       break;\n     case SECCAT_DATA:\n-      prefix = one_only ? \".gnu.linkonce.d.\" : \".data.\";\n+      prefix = one_only ? \".d\" : \".data\";\n       break;\n     case SECCAT_DATA_REL:\n-      prefix = one_only ? \".gnu.linkonce.d.rel.\" : \".data.rel.\";\n+      prefix = one_only ? \".d.rel\" : \".data.rel\";\n       break;\n     case SECCAT_DATA_REL_LOCAL:\n-      prefix = one_only ? \".gnu.linkonce.d.rel.local.\" : \".data.rel.local.\";\n+      prefix = one_only ? \".d.rel.local\" : \".data.rel.local\";\n       break;\n     case SECCAT_DATA_REL_RO:\n-      prefix = one_only ? \".gnu.linkonce.d.rel.ro.\" : \".data.rel.ro.\";\n+      prefix = one_only ? \".d.rel.ro\" : \".data.rel.ro\";\n       break;\n     case SECCAT_DATA_REL_RO_LOCAL:\n-      prefix = one_only ? \".gnu.linkonce.d.rel.ro.local.\"\n-\t       : \".data.rel.ro.local.\";\n+      prefix = one_only ? \".d.rel.ro.local\" : \".data.rel.ro.local\";\n       break;\n     case SECCAT_SDATA:\n-      prefix = one_only ? \".gnu.linkonce.s.\" : \".sdata.\";\n+      prefix = one_only ? \".s\" : \".sdata\";\n       break;\n     case SECCAT_BSS:\n-      prefix = one_only ? \".gnu.linkonce.b.\" : \".bss.\";\n+      prefix = one_only ? \".b\" : \".bss\";\n       break;\n     case SECCAT_SBSS:\n-      prefix = one_only ? \".gnu.linkonce.sb.\" : \".sbss.\";\n+      prefix = one_only ? \".sb\" : \".sbss\";\n       break;\n     case SECCAT_TDATA:\n-      prefix = one_only ? \".gnu.linkonce.td.\" : \".tdata.\";\n+      prefix = one_only ? \".td\" : \".tdata\";\n       break;\n     case SECCAT_TBSS:\n-      prefix = one_only ? \".gnu.linkonce.tb.\" : \".tbss.\";\n+      prefix = one_only ? \".tb\" : \".tbss\";\n+      break;\n+    case SECCAT_EMUTLS_VAR:\n+      prefix = targetm.emutls.var_section;\n+      break;\n+    case SECCAT_EMUTLS_TMPL:\n+      prefix = targetm.emutls.tmpl_section;\n       break;\n     default:\n       gcc_unreachable ();\n     }\n-  plen = strlen (prefix);\n \n   name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n   name = targetm.strip_name_encoding (name);\n-  nlen = strlen (name);\n \n-  string = alloca (nlen + plen + 1);\n-  memcpy (string, prefix, plen);\n-  memcpy (string + plen, name, nlen + 1);\n+  /* If we're using one_only, then there needs to be a .gnu.linkonce\n+     prefix to the section name.  */\n+  linkonce = one_only ? \".gnu.linkonce\" : \"\";\n+  \n+  string = ACONCAT ((linkonce, prefix, \".\", name, NULL));\n \n-  DECL_SECTION_NAME (decl) = build_string (nlen + plen, string);\n+  DECL_SECTION_NAME (decl) = build_string (strlen (string), string);\n }\n \n /* Like compute_reloc_for_constant, except for an RTX.  The return value"}]}