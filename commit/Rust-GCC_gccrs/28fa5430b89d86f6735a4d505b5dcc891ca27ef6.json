{"sha": "28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjhmYTU0MzBiODlkODZmNjczNWE0ZDUwNWI1ZGNjODkxY2EyN2VmNg==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T10:08:52Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2015-01-06T10:08:52Z"}, "message": "[multiple changes]\n\n2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n\n\t* einfo.ads (Has_Independent_Components): Document extended usage.\n\t* einfo.adb (Has_Independent_Components): Remove obsolete assertion.\n\t(Set_Has_Independent_Components): Adjust assertion.\n\t* sem_prag.adb (Analyze_Pragma): Also set Has_Independent_Components\n\tfor pragma Atomic_Components.  Set Has_Independent_Components\n\ton the object instead of the type for an object declaration with\n\tpragma Independent_Components.\n\n2015-01-06  Olivier Hainque  <hainque@adacore.com>\n\n\t* set_targ.adb (Read_Target_Dependent_Values): Set\n\tLong_Double_Index when \"long double\" is read.\n\t(elaboration code): Register_Back_End_Types only when not reading from\n\tconfig files. Doing otherwise is pointless and error prone.\n\n2015-01-06  Robert Dewar  <dewar@adacore.com>\n\n\t* s-valrea.adb (Value_Real): Check for Str'Last = Positive'Last\n\n2015-01-06  Robert Dewar  <dewar@adacore.com>\n\n\t* a-wtgeau.adb, a-ztgeau.adb, a-tigeau.adb (String_Skip): Raise PE if\n\tStr'Last = Positive'Last.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch6.adb (Matches_Limited_View): Handle properly the case\n\twhere the non-limited type is a generic actual and appears as\n\ta subtype of the non-limited view of the other.\n\t* freeze.adb (Build_Renamed_Body): If the return type of the\n\tdeclaration that is being completed is a limited view and the\n\tnon-limited view is available, use it in the specification of\n\tthe generated body.\n\n2015-01-06  Javier Miranda  <miranda@adacore.com>\n\n\t* exp_disp.adb: Reapplying reversed patch.\n\n2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n\n\t* sem_ch3.adb (Find_Type_Name): If there is a previous tagged\n\tincomplete view, the type of the classwide type common to both\n\tviews is the type being declared.\n\nFrom-SVN: r219247", "tree": {"sha": "51e2e860329d34928673ca83071088b08eca2e1b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/51e2e860329d34928673ca83071088b08eca2e1b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/comments", "author": null, "committer": null, "parents": [{"sha": "8a52daeeb01ccfc4131283cc824989b01e0d0e98", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8a52daeeb01ccfc4131283cc824989b01e0d0e98", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8a52daeeb01ccfc4131283cc824989b01e0d0e98"}], "stats": {"total": 245, "additions": 203, "deletions": 42}, "files": [{"sha": "d8fb6f0e294e061560a59b8ed2516092bae1bfce", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -1,3 +1,50 @@\n+2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* einfo.ads (Has_Independent_Components): Document extended\n+\tusage.\n+\t* einfo.adb (Has_Independent_Components): Remove obsolete assertion.\n+\t(Set_Has_Independent_Components): Adjust assertion.\n+\t* sem_prag.adb (Analyze_Pragma): Also set Has_Independent_Components\n+\tfor pragma Atomic_Components.  Set Has_Independent_Components\n+\ton the object instead of the type for an object declaration with\n+\tpragma Independent_Components.\n+\n+2015-01-06  Olivier Hainque  <hainque@adacore.com>\n+\n+\t* set_targ.adb (Read_Target_Dependent_Values): Set\n+\tLong_Double_Index when \"long double\" is read.\n+\t(elaboration code): Register_Back_End_Types only when not reading from\n+\tconfig files. Doing otherwise is pointless and error prone.\n+\n+2015-01-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* s-valrea.adb (Value_Real): Check for Str'Last = Positive'Last\n+\n+2015-01-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* a-wtgeau.adb, a-ztgeau.adb, a-tigeau.adb (String_Skip): Raise PE if\n+\tStr'Last = Positive'Last.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch6.adb (Matches_Limited_View): Handle properly the case\n+\twhere the non-limited type is a generic actual and appears as\n+\ta subtype of the non-limited view of the other.\n+\t* freeze.adb (Build_Renamed_Body): If the return type of the\n+\tdeclaration that is being completed is a limited view and the\n+\tnon-limited view is available, use it in the specification of\n+\tthe generated body.\n+\n+2015-01-06  Javier Miranda  <miranda@adacore.com>\n+\n+\t* exp_disp.adb: Reapplying reversed patch.\n+\n+2015-01-06  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* sem_ch3.adb (Find_Type_Name): If there is a previous tagged\n+\tincomplete view, the type of the classwide type common to both\n+\tviews is the type being declared.\n+\n 2015-01-06  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* einfo.ads (Is_Independent): Further document extended usage."}, {"sha": "218aec87b8a206338ba1fbc914d5878812a83dce", "filename": "gcc/ada/a-tigeau.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-tigeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-tigeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-tigeau.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -443,6 +443,19 @@ package body Ada.Text_IO.Generic_Aux is\n \n    procedure String_Skip (Str : String; Ptr : out Integer) is\n    begin\n+      --  Routines calling String_Skip malfunction if Str'Last = Positive'Last.\n+      --  It's too much trouble to make this silly case work, so we just raise\n+      --  Program_Error with an appropriate message. We raise Program_Error\n+      --  rather than Constraint_Error because we don't want this case to be\n+      --  converted to Data_Error.\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n       Ptr := Str'First;\n \n       loop"}, {"sha": "7e2777313f0b2bbf58dc06044c167a24f47f3d5e", "filename": "gcc/ada/a-wtgeau.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-wtgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-wtgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-wtgeau.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -484,6 +484,19 @@ package body Ada.Wide_Text_IO.Generic_Aux is\n \n    procedure String_Skip (Str : String; Ptr : out Integer) is\n    begin\n+      --  Routines calling String_Skip malfunction if Str'Last = Positive'Last.\n+      --  It's too much trouble to make this silly case work, so we just raise\n+      --  Program_Error with an appropriate message. We raise Program_Error\n+      --  rather than Constraint_Error because we don't want this case to be\n+      --  converted to Data_Error.\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n       Ptr := Str'First;\n \n       loop"}, {"sha": "7f182a13fe81b134808a34ab21768fdf51502f38", "filename": "gcc/ada/a-ztgeau.adb", "status": "modified", "additions": 14, "deletions": 1, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-ztgeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fa-ztgeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fa-ztgeau.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2009, Free Software Foundation, Inc.         --\n+--          Copyright (C) 1992-2014, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -484,6 +484,19 @@ package body Ada.Wide_Wide_Text_IO.Generic_Aux is\n \n    procedure String_Skip (Str : String; Ptr : out Integer) is\n    begin\n+      --  Routines calling String_Skip malfunction if Str'Last = Positive'Last.\n+      --  It's too much trouble to make this silly case work, so we just raise\n+      --  Program_Error with an appropriate message. We raise Program_Error\n+      --  rather than Constraint_Error because we don't want this case to be\n+      --  converted to Data_Error.\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n       Ptr := Str'First;\n \n       loop"}, {"sha": "7407d48f0eaff789810698f267b6fe30f95e3d8b", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 2, "deletions": 4, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -1468,8 +1468,7 @@ package body Einfo is\n \n    function Has_Independent_Components (Id : E) return B is\n    begin\n-      pragma Assert (Is_Array_Type (Id) or else Is_Record_Type (Id));\n-      return Flag34 (Base_Type (Id));\n+      return Flag34 (Implementation_Base_Type (Id));\n    end Has_Independent_Components;\n \n    function Has_Inheritable_Invariants (Id : E) return B is\n@@ -4262,8 +4261,7 @@ package body Einfo is\n \n    procedure Set_Has_Independent_Components (Id : E; V : B := True) is\n    begin\n-      pragma Assert ((Is_Array_Type (Id) or else Is_Record_Type (Id))\n-        and then Is_Base_Type (Id));\n+      pragma Assert (not Is_Type (Id) or else Is_Base_Type (Id));\n       Set_Flag34 (Id, V);\n    end Set_Has_Independent_Components;\n "}, {"sha": "91d7c56ddf6b7e31820295dc9c556d837a65bf14", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 12, "deletions": 5, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -1605,11 +1605,16 @@ package Einfo is\n --       Implicit_Dereference. Set also on the discriminant named in the aspect\n --       clause, to simplify type resolution.\n \n---    Has_Independent_Components (Flag34) [base type only]\n---       Defined in types. Set if the aspect Independent_Components applies\n---       (in the base type only), if corresponding pragma or aspect applies.\n---       In the case of an object of anonymous array type, the flag is set on\n---       the created array type.\n+--    Has_Independent_Components (Flag34) [implementation base type only]\n+--       Defined in all types and objects. Set only for a record type or an\n+--       array type or array object if a valid pragma Independent_Components\n+--       applies to the type or object. Note that in the case of an object,\n+--       this flag is only set on the object if there was an explicit pragma\n+--       for the object. In other words, the proper test for whether an object\n+--       has independent components is to see if either the object or its base\n+--       type has this flag set. Note that in the case of a type, the pragma\n+--       will be chained to the rep item chain of the first subtype in the\n+--       usual manner.\n \n --    Has_Inheritable_Invariants (Flag248)\n --       Defined in all type entities. Set in private types from which one\n@@ -5525,6 +5530,7 @@ package Einfo is\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n    --    Has_Completion                      (Flag26)   (constants only)\n+   --    Has_Independent_Components          (Flag34)\n    --    Has_Thunks                          (Flag228)  (constants only)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Up_Level_Access                 (Flag215)\n@@ -6236,6 +6242,7 @@ package Einfo is\n    --    Has_Alignment_Clause                (Flag46)\n    --    Has_Atomic_Components               (Flag86)\n    --    Has_Biased_Representation           (Flag139)\n+   --    Has_Independent_Components          (Flag34)\n    --    Has_Initial_Value                   (Flag219)\n    --    Has_Size_Clause                     (Flag29)\n    --    Has_Up_Level_Access                 (Flag215)"}, {"sha": "905311b6eb923c7e1f7ee79fe42fc3f6c8aeec96", "filename": "gcc/ada/exp_disp.adb", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fexp_disp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fexp_disp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_disp.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -1138,6 +1138,25 @@ package body Exp_Disp is\n          Operand_Typ := Base_Type (Corresponding_Record_Type (Operand_Typ));\n       end if;\n \n+      --  No displacement of the pointer to the object needed when the type of\n+      --  the operand is not an interface type and the interface is one of\n+      --  its parent types (since they share the primary dispatch table).\n+\n+      declare\n+         Opnd : Entity_Id := Operand_Typ;\n+\n+      begin\n+         if Is_Access_Type (Opnd) then\n+            Opnd := Designated_Type (Opnd);\n+         end if;\n+\n+         if not Is_Interface (Opnd)\n+           and then Is_Ancestor (Iface_Typ, Opnd, Use_Full_View => True)\n+         then\n+            return;\n+         end if;\n+      end;\n+\n       --  Evaluate if we can statically displace the pointer to the object\n \n       declare"}, {"sha": "e87b1f4944c1762cb8b4d88982f0f16404c37c97", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -412,6 +412,26 @@ package body Freeze is\n          Set_Body_To_Inline (Decl, Old_S);\n       end if;\n \n+      --  Check whether the return type is a limited view. If the subprogram\n+      --  is already frozen the generated body may have a non-limited view\n+      --  of the type, that must be used, because it is the one in the spec\n+      --  of the renaming declaration.\n+\n+      if Ekind (Old_S) = E_Function\n+        and then Is_Entity_Name (Result_Definition (Spec))\n+      then\n+         declare\n+            Ret_Type : constant Entity_Id := Etype (Result_Definition (Spec));\n+         begin\n+            if Ekind (Ret_Type) = E_Incomplete_Type\n+              and then Present (Non_Limited_View (Ret_Type))\n+            then\n+               Set_Result_Definition (Spec,\n+                  New_Occurrence_Of (Non_Limited_View (Ret_Type), Loc));\n+            end if;\n+         end;\n+      end if;\n+\n       --  The body generated for this renaming is an internal artifact, and\n       --  does not  constitute a freeze point for the called entity.\n "}, {"sha": "b7be0ca043503c02bfbce4db53231c08732d10a6", "filename": "gcc/ada/s-valrea.adb", "status": "modified", "additions": 23, "deletions": 5, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-valrea.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -377,12 +377,30 @@ package body System.Val_Real is\n    ----------------\n \n    function Value_Real (Str : String) return Long_Long_Float is\n-      V : Long_Long_Float;\n-      P : aliased Integer := Str'First;\n    begin\n-      V := Scan_Real (Str, P'Access, Str'Last);\n-      Scan_Trailing_Blanks (Str, P);\n-      return V;\n+      --  We have to special case Str'Last = Positive'Last because the normal\n+      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n+      --  deal with this by converting to a subtype which fixes the bounds.\n+\n+      if Str'Last = Positive'Last then\n+         declare\n+            subtype NT is String (1 .. Str'Length);\n+         begin\n+            return Value_Real (NT (Str));\n+         end;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n+      else\n+         declare\n+            V : Long_Long_Float;\n+            P : aliased Integer := Str'First;\n+         begin\n+            V := Scan_Real (Str, P'Access, Str'Last);\n+            Scan_Trailing_Blanks (Str, P);\n+            return V;\n+         end;\n+      end if;\n    end Value_Real;\n \n end System.Val_Real;"}, {"sha": "c067539eb1c12d0e07878dcd935f0d3fdf5d75c2", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -16354,14 +16354,12 @@ package body Sem_Ch3 is\n                Set_Ekind (Id, Ekind (Prev));         --  will be reset later\n                Set_Class_Wide_Type (Id, Class_Wide_Type (Prev));\n \n-               --  If the incomplete type is completed by a private declaration\n-               --  the class-wide type remains associated with the incomplete\n-               --  type, to prevent order-of-elaboration issues in gigi, else\n-               --  we associate the class-wide type with the known full view.\n+               --  The type of the classwide type is the current Id. Previously\n+               --  this was not done for private declarations because of order-\n+               --  of elaboration issues in the back-end, but gigi now handles\n+               --  this properly.\n \n-               if Nkind (N) /= N_Private_Type_Declaration then\n-                  Set_Etype (Class_Wide_Type (Id), Id);\n-               end if;\n+               Set_Etype (Class_Wide_Type (Id), Id);\n             end if;\n \n          --  Case of full declaration of private type"}, {"sha": "fcca80b3878c555411e71c86a26a83b49a44ceb4", "filename": "gcc/ada/sem_ch6.adb", "status": "modified", "additions": 14, "deletions": 5, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch6.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -6600,13 +6600,22 @@ package body Sem_Ch6 is\n       begin\n          --  In some cases a type imported through a limited_with clause, and\n          --  its nonlimited view are both visible, for example in an anonymous\n-         --  access-to-class-wide type in a formal. Both entities designate the\n-         --  same type.\n-\n-         if From_Limited_With (T1) and then T2 = Available_View (T1) then\n+         --  access-to-class-wide type in a formal, or when building the body\n+         --  for a subprogram renaming after the subprogram has been frozen.\n+         --  In these cases Both entities designate the same type. In addition,\n+         --  if one of them is an actual in an instance, it may be a subtype of\n+         --  the non-limited view of the other.\n+\n+         if From_Limited_With (T1)\n+           and then (T2 = Available_View (T1)\n+                      or else Is_Subtype_Of (T2, Available_View (T1)))\n+         then\n             return True;\n \n-         elsif From_Limited_With (T2) and then T1 = Available_View (T2) then\n+         elsif From_Limited_With (T2)\n+           and then (T1 = Available_View (T2)\n+                      or else Is_Subtype_Of (T1, Available_View (T2)))\n+         then\n             return True;\n \n          elsif From_Limited_With (T1)"}, {"sha": "74607e576550d98867e596bde6b6cba4b1e03ccf", "filename": "gcc/ada/sem_prag.adb", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fsem_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_prag.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -11491,12 +11491,15 @@ package body Sem_Prag is\n                   E := Base_Type (E);\n                end if;\n \n-               Set_Has_Volatile_Components (E);\n+               --  Atomic implies both Independent and Volatile\n \n                if Prag_Id = Pragma_Atomic_Components then\n                   Set_Has_Atomic_Components (E);\n+                  Set_Has_Independent_Components (E);\n                end if;\n \n+               Set_Has_Volatile_Components (E);\n+\n             else\n                Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);\n             end if;\n@@ -14977,11 +14980,13 @@ package body Sem_Prag is\n             D := Declaration_Node (E);\n             K := Nkind (D);\n \n+            --  The flag is set on the base type, or on the object\n+\n             if K = N_Full_Type_Declaration\n               and then (Is_Array_Type (E) or else Is_Record_Type (E))\n             then\n-               Independence_Checks.Append ((N, Base_Type (E)));\n                Set_Has_Independent_Components (Base_Type (E));\n+               Independence_Checks.Append ((N, Base_Type (E)));\n \n                --  For record type, set all components independent\n \n@@ -14998,8 +15003,8 @@ package body Sem_Prag is\n               and then Nkind (Object_Definition (D)) =\n                                            N_Constrained_Array_Definition\n             then\n-               Independence_Checks.Append ((N, Base_Type (Etype (E))));\n-               Set_Has_Independent_Components (Base_Type (Etype (E)));\n+               Set_Has_Independent_Components (E);\n+               Independence_Checks.Append ((N, E));\n \n             else\n                Error_Pragma_Arg (\"inappropriate entity for pragma%\", Arg1);"}, {"sha": "4dbd735e97f9bd268688fca047afabe218892149", "filename": "gcc/ada/set_targ.adb", "status": "modified", "additions": 10, "deletions": 9, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fset_targ.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/28fa5430b89d86f6735a4d505b5dcc891ca27ef6/gcc%2Fada%2Fset_targ.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fset_targ.adb?ref=28fa5430b89d86f6735a4d505b5dcc891ca27ef6", "patch": "@@ -165,7 +165,7 @@ package body Set_Targ is\n    --  type can be found if it gets registered at all.\n \n    Long_Double_Index : Integer := -1;\n-   --  Once all the back-end types have been registered, the index in\n+   --  Once all the floating point types have been registered, the index in\n    --  FPT_Mode_Table at which \"long double\" can be found, if anywhere. A\n    --  negative value means that no \"long double\" has been registered. This\n    --  is useful to know whether we have a \"long double\" available at all and\n@@ -769,6 +769,10 @@ package body Set_Targ is\n          begin\n             E.NAME := new String'(Nam_Buf (1 .. Nam_Len));\n \n+            if Long_Double_Index < 0 and then E.NAME.all = \"long double\" then\n+               Long_Double_Index := Num_FPT_Modes;\n+            end if;\n+\n             E.DIGS := Get_Nat;\n             Check_Spaces;\n \n@@ -887,13 +891,6 @@ begin\n       end loop;\n    end;\n \n-   --  Register floating-point types from the back end. We do this\n-   --  unconditionally so C_Type_For may be called regardless of -gnateT, for\n-   --  which cstand has a use, and early so we can use FPT_Mode_Table below to\n-   --  compute some FP attributes.\n-\n-   Register_Back_End_Types (Register_Float_Type'Access);\n-\n    --  Case of reading the target dependent values from file\n \n    --  This is bit more complex than might be expected, because it has to be\n@@ -939,7 +936,11 @@ begin\n             Wchar_T_Size               := Get_Wchar_T_Size;\n             Words_BE                   := Get_Words_BE;\n \n-            --  Compute the sizes of floating point types\n+            --  Let the back-end register its floating point types and compute\n+            --  the sizes of our standard types from there:\n+\n+            Num_FPT_Modes := 0;\n+            Register_Back_End_Types (Register_Float_Type'Access);\n \n             declare\n                T : FPT_Mode_Entry renames"}]}