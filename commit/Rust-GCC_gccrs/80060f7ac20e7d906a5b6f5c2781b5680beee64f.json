{"sha": "80060f7ac20e7d906a5b6f5c2781b5680beee64f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODAwNjBmN2FjMjBlN2Q5MDZhNWI2ZjVjMjc4MWI1NjgwYmVlZTY0Zg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2011-05-30T15:16:40Z"}, "committer": {"name": "Eric Botcazou", "email": "ebotcazou@gcc.gnu.org", "date": "2011-05-30T15:16:40Z"}, "message": "var-tracking.c (vt_add_function_parameter): Remap incoming MEMs with crtl->args.internal_arg_pointer based address to...\n\n\t* var-tracking.c (vt_add_function_parameter): Remap incoming MEMs with\n\tcrtl->args.internal_arg_pointer based address to arg_pointer_rtx if\n\tthere is a DRAP register and arg_pointer_rtx is the CFA pointer.\n\t(vt_init_cfa_base): Don't equate cfa_base_rtx if stack was realigned.\n\t(vt_initialize): Initialize cfa_base_rtx if there is a DRAP register.\n\nFrom-SVN: r174438", "tree": {"sha": "86aad644f1485615e297b0a91bae29b8499bf166", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/86aad644f1485615e297b0a91bae29b8499bf166"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/80060f7ac20e7d906a5b6f5c2781b5680beee64f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80060f7ac20e7d906a5b6f5c2781b5680beee64f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/80060f7ac20e7d906a5b6f5c2781b5680beee64f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/80060f7ac20e7d906a5b6f5c2781b5680beee64f/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "17e99cdb2d3048641353093c53dd04e3e3f7e8aa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/17e99cdb2d3048641353093c53dd04e3e3f7e8aa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/17e99cdb2d3048641353093c53dd04e3e3f7e8aa"}], "stats": {"total": 106, "additions": 100, "deletions": 6}, "files": [{"sha": "12a6468dbe54db52ac67b1d8c17661385140c8d3", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=80060f7ac20e7d906a5b6f5c2781b5680beee64f", "patch": "@@ -1,3 +1,12 @@\n+2011-05-30  Jakub Jelinek  <jakub@redhat.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* var-tracking.c (vt_add_function_parameter): Remap incoming MEMs with\n+\tcrtl->args.internal_arg_pointer based address to arg_pointer_rtx if\n+\tthere is a DRAP register and arg_pointer_rtx is the CFA pointer.\n+\t(vt_init_cfa_base): Don't equate cfa_base_rtx if stack was realigned.\n+\t(vt_initialize): Initialize cfa_base_rtx if there is a DRAP register.\n+\n 2011-05-30  Richard Guenther  <rguenther@suse.de>\n \n \t* gimple.c (gimple_types_compatible_p_1): Compare record"}, {"sha": "e80c1b2c9b2450bf4bade4bc9ab09a31a92dd92d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=80060f7ac20e7d906a5b6f5c2781b5680beee64f", "patch": "@@ -1,9 +1,13 @@\n+2011-05-30  Jakub Jelinek  <jakub@redhat.com>\n+\t    Eric Botcazou  <ebotcazou@adacore.com>\n+\n+\t* gcc.dg/guality/drap.c: New test.\n+\n 2011-05-30  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/49210\n-\t* gnat.dg/boolean_subtype2.adb: New testcase.\n-\t* gnat.dg/boolean_subtype2.ads: Likewise.\n-\t* gnat.dg/boolean_subtype2_pkg.ads: Likewise.\n+\t* gnat.dg/boolean_subtype2.ad[sb]: New testcase.\n+\t* gnat.dg/boolean_subtype2_pkg.ads: New helper.\n \n 2011-05-30  Jakub Jelinek  <jakub@redhat.com>\n "}, {"sha": "573bb39d08fdc362b5e5ee07d2a219625002a181", "filename": "gcc/testsuite/gcc.dg/guality/drap.c", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fdrap.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fdrap.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fdrap.c?ref=80060f7ac20e7d906a5b6f5c2781b5680beee64f", "patch": "@@ -0,0 +1,30 @@\n+/* { dg-do run { target { i?86-*-* x86_64-*-* } } } */\n+/* { dg-options \"-g -mforce-drap\" } */\n+\n+volatile int v;\n+\n+__attribute__((noinline, noclone)) int\n+bar (int a, int b)\n+{\n+#ifdef __x86_64__\n+  asm volatile (\"movq %%rsp, %%r10\" : : : \"r10\");\n+#else\n+  asm volatile (\"movl %%esp, %%ecx\" : : : \"ecx\");\n+#endif\n+  return 0;\n+}\n+\n+__attribute__((noinline, noclone)) int\n+foo (int v0, int v1, int v2, int v3, int v4, int v5, int a, int b)\n+{\n+  __attribute__((aligned (32))) int c = bar (a, b);\n+  v++;               /* { dg-final { gdb-test 21 \"a\" \"5\" } } */\n+  return a + b + c;  /* { dg-final { gdb-test 22 \"b\" \"6\" } } */\n+}\n+\n+int\n+main (void)\n+{\n+  foo (0, 0, 0, 0, 0, 0, 5, 6);\n+  return 0;\n+}"}, {"sha": "2c16d08e02cb967408c5436d8cd4fb14e9e7b854", "filename": "gcc/var-tracking.c", "status": "modified", "additions": 54, "deletions": 3, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Fvar-tracking.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/80060f7ac20e7d906a5b6f5c2781b5680beee64f/gcc%2Fvar-tracking.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvar-tracking.c?ref=80060f7ac20e7d906a5b6f5c2781b5680beee64f", "patch": "@@ -8398,6 +8398,28 @@ vt_add_function_parameter (tree parm)\n   if (GET_MODE (decl_rtl) == BLKmode || GET_MODE (incoming) == BLKmode)\n     return;\n \n+  /* If there is a DRAP register, rewrite the incoming location of parameters\n+     passed on the stack into MEMs based on the argument pointer, as the DRAP\n+     register can be reused for other purposes and we do not track locations\n+     based on generic registers.  But the prerequisite is that this argument\n+     pointer be also the virtual CFA pointer, see vt_initialize.  */\n+  if (MEM_P (incoming)\n+      && stack_realign_drap\n+      && arg_pointer_rtx == cfa_base_rtx\n+      && (XEXP (incoming, 0) == crtl->args.internal_arg_pointer\n+\t  || (GET_CODE (XEXP (incoming, 0)) == PLUS\n+\t      && XEXP (XEXP (incoming, 0), 0)\n+\t\t == crtl->args.internal_arg_pointer\n+\t      && CONST_INT_P (XEXP (XEXP (incoming, 0), 1)))))\n+    {\n+      HOST_WIDE_INT off = -FIRST_PARM_OFFSET (current_function_decl);\n+      if (GET_CODE (XEXP (incoming, 0)) == PLUS)\n+\toff += INTVAL (XEXP (XEXP (incoming, 0), 1));\n+      incoming\n+\t= replace_equiv_address_nv (incoming,\n+\t\t\t\t    plus_constant (arg_pointer_rtx, off));\n+    }\n+\n   if (!vt_get_decl_and_offset (incoming, &decl, &offset))\n     {\n       if (REG_P (incoming) || MEM_P (incoming))\n@@ -8647,9 +8669,11 @@ vt_init_cfa_base (void)\n \n   /* Tell alias analysis that cfa_base_rtx should share\n      find_base_term value with stack pointer or hard frame pointer.  */\n-  vt_equate_reg_base_value (cfa_base_rtx,\n-\t\t\t    frame_pointer_needed\n-\t\t\t    ? hard_frame_pointer_rtx : stack_pointer_rtx);\n+  if (!frame_pointer_needed)\n+    vt_equate_reg_base_value (cfa_base_rtx, stack_pointer_rtx);\n+  else if (!crtl->stack_realign_tried)\n+    vt_equate_reg_base_value (cfa_base_rtx, hard_frame_pointer_rtx);\n+\n   val = cselib_lookup_from_insn (cfa_base_rtx, GET_MODE (cfa_base_rtx), 1,\n \t\t\t\t VOIDmode, get_insns ());\n   preserve_value (val);\n@@ -8780,6 +8804,33 @@ vt_initialize (void)\n \tfp_cfa_offset = -1;\n     }\n \n+  /* If the stack is realigned and a DRAP register is used, we're going to\n+     rewrite MEMs based on it representing incoming locations of parameters\n+     passed on the stack into MEMs based on the argument pointer.  Although\n+     we aren't going to rewrite other MEMs, we still need to initialize the\n+     virtual CFA pointer in order to ensure that the argument pointer will\n+     be seen as a constant throughout the function.\n+\n+     ??? This doesn't work if FRAME_POINTER_CFA_OFFSET is defined.  */\n+  else if (stack_realign_drap)\n+    {\n+      rtx reg, elim;\n+\n+#ifdef FRAME_POINTER_CFA_OFFSET\n+      reg = frame_pointer_rtx;\n+#else\n+      reg = arg_pointer_rtx;\n+#endif\n+      elim = eliminate_regs (reg, VOIDmode, NULL_RTX);\n+      if (elim != reg)\n+\t{\n+\t  if (GET_CODE (elim) == PLUS)\n+\t    elim = XEXP (elim, 0);\n+\t  if (elim == hard_frame_pointer_rtx)\n+\t    vt_init_cfa_base ();\n+\t}\n+    }\n+\n   if (frame_pointer_needed)\n     {\n       rtx insn;"}]}