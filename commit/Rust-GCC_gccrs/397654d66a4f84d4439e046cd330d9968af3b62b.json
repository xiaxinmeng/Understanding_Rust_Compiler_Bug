{"sha": "397654d66a4f84d4439e046cd330d9968af3b62b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzk3NjU0ZDY2YTRmODRkNDQzOWUwNDZjZDMzMGQ5OTY4YWYzYjYyYg==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-10-02T23:03:37Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-11-18T02:32:07Z"}, "message": "cmd/go, cmd/cgo: update gofrontend mangling checks\n\nThis is a port of two patches in the master repository.\n\nhttps://golang.org/cl/259298\n\n    cmd/cgo: split gofrontend mangling checks into cmd/internal/pkgpath\n\n    This is a step toward porting https://golang.org/cl/219817 from the\n    gofrontend repo to the main repo.\n\n    Note that this also corrects the implementation of the v2 mangling\n    scheme to use ..u and ..U where appropriate.\n\nhttps://golang.org/cl/259299\n\n    cmd/go: use cmd/internal/pkgpath for gccgo pkgpath symbol\n\nFor golang/go#37272\nFor golang/go#41862\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/270637", "tree": {"sha": "37402d687877131f53eae33139be194f9d26cb84", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/37402d687877131f53eae33139be194f9d26cb84"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/397654d66a4f84d4439e046cd330d9968af3b62b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/397654d66a4f84d4439e046cd330d9968af3b62b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/397654d66a4f84d4439e046cd330d9968af3b62b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/397654d66a4f84d4439e046cd330d9968af3b62b/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4dabb03719553f88ef0d74c75ccdc6c8aa172d6b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4dabb03719553f88ef0d74c75ccdc6c8aa172d6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4dabb03719553f88ef0d74c75ccdc6c8aa172d6b"}], "stats": {"total": 407, "additions": 276, "deletions": 131}, "files": [{"sha": "1f3c25ce710fc9248f6704bfbb234657c6555e77", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -1,4 +1,4 @@\n-893fa057e36ae6c9b2ac5ffdf74634c35b3489c6\n+c948c2d770122932a05b62f653efa2c51f72d3ae\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "da77e84517e6ef2a6b2f3a097539f20161214eac", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -22,6 +22,7 @@ cmd/go/internal/work\n cmd/internal/buildid\n cmd/internal/edit\n cmd/internal/objabi\n+cmd/internal/pkgpath\n cmd/internal/test2json\n compress/bzip2\n compress/flate"}, {"sha": "4952118b1f810bb3a8bf3cc31caf39106f0aa593", "filename": "libgo/go/cmd/cgo/main.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fmain.go?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -244,8 +244,7 @@ var exportHeader = flag.String(\"exportheader\", \"\", \"where to write export header\n var gccgo = flag.Bool(\"gccgo\", false, \"generate files for use with gccgo\")\n var gccgoprefix = flag.String(\"gccgoprefix\", \"\", \"-fgo-prefix option used with gccgo\")\n var gccgopkgpath = flag.String(\"gccgopkgpath\", \"\", \"-fgo-pkgpath option used with gccgo\")\n-var gccgoMangleCheckDone bool\n-var gccgoNewmanglingInEffect bool\n+var gccgoMangler func(string) string\n var importRuntimeCgo = flag.Bool(\"import_runtime_cgo\", true, \"import runtime/cgo in generated code\")\n var importSyscall = flag.Bool(\"import_syscall\", true, \"import syscall in generated code\")\n var goarch, goos string"}, {"sha": "2ab8425999f0b126390e411079558b602e31d10a", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 15, "deletions": 103, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -6,6 +6,7 @@ package main\n \n import (\n \t\"bytes\"\n+\t\"cmd/internal/pkgpath\"\n \t\"debug/elf\"\n \t\"debug/macho\"\n \t\"debug/pe\"\n@@ -15,7 +16,6 @@ import (\n \t\"go/token\"\n \t\"internal/xcoff\"\n \t\"io\"\n-\t\"io/ioutil\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -1286,112 +1286,24 @@ func (p *Package) writeExportHeader(fgcch io.Writer) {\n \tfmt.Fprintf(fgcch, \"%s\\n\", p.gccExportHeaderProlog())\n }\n \n-// gccgoUsesNewMangling reports whether gccgo uses the new collision-free\n-// packagepath mangling scheme (see determineGccgoManglingScheme for more\n-// info).\n-func gccgoUsesNewMangling() bool {\n-\tif !gccgoMangleCheckDone {\n-\t\tgccgoNewmanglingInEffect = determineGccgoManglingScheme()\n-\t\tgccgoMangleCheckDone = true\n-\t}\n-\treturn gccgoNewmanglingInEffect\n-}\n-\n-const mangleCheckCode = `\n-package l\u00e4ufer\n-func Run(x int) int {\n-  return 1\n-}\n-`\n-\n-// determineGccgoManglingScheme performs a runtime test to see which\n-// flavor of packagepath mangling gccgo is using. Older versions of\n-// gccgo use a simple mangling scheme where there can be collisions\n-// between packages whose paths are different but mangle to the same\n-// string. More recent versions of gccgo use a new mangler that avoids\n-// these collisions. Return value is whether gccgo uses the new mangling.\n-func determineGccgoManglingScheme() bool {\n-\n-\t// Emit a small Go file for gccgo to compile.\n-\tfilepat := \"*_gccgo_manglecheck.go\"\n-\tvar f *os.File\n-\tvar err error\n-\tif f, err = ioutil.TempFile(*objDir, filepat); err != nil {\n-\t\tfatalf(\"%v\", err)\n-\t}\n-\tgofilename := f.Name()\n-\tdefer os.Remove(gofilename)\n-\n-\tif err = ioutil.WriteFile(gofilename, []byte(mangleCheckCode), 0666); err != nil {\n-\t\tfatalf(\"%v\", err)\n-\t}\n-\n-\t// Compile with gccgo, capturing generated assembly.\n-\tgccgocmd := os.Getenv(\"GCCGO\")\n-\tif gccgocmd == \"\" {\n-\t\tgpath, gerr := exec.LookPath(\"gccgo\")\n-\t\tif gerr != nil {\n-\t\t\tfatalf(\"unable to locate gccgo: %v\", gerr)\n-\t\t}\n-\t\tgccgocmd = gpath\n-\t}\n-\tcmd := exec.Command(gccgocmd, \"-S\", \"-o\", \"-\", gofilename)\n-\tbuf, cerr := cmd.CombinedOutput()\n-\tif cerr != nil {\n-\t\tfatalf(\"%s\", cerr)\n-\t}\n-\n-\t// New mangling: expect go.l..u00e4ufer.Run\n-\t// Old mangling: expect go.l__ufer.Run\n-\treturn regexp.MustCompile(`go\\.l\\.\\.u00e4ufer\\.Run`).Match(buf)\n-}\n-\n-// gccgoPkgpathToSymbolNew converts a package path to a gccgo-style\n-// package symbol.\n-func gccgoPkgpathToSymbolNew(ppath string) string {\n-\tbsl := []byte{}\n-\tchanged := false\n-\tfor _, c := range []byte(ppath) {\n-\t\tswitch {\n-\t\tcase 'A' <= c && c <= 'Z', 'a' <= c && c <= 'z',\n-\t\t\t'0' <= c && c <= '9', c == '_':\n-\t\t\tbsl = append(bsl, c)\n-\t\tcase c == '.':\n-\t\t\tbsl = append(bsl, \".x2e\"...)\n-\t\tdefault:\n-\t\t\tchanged = true\n-\t\t\tencbytes := []byte(fmt.Sprintf(\"..z%02x\", c))\n-\t\t\tbsl = append(bsl, encbytes...)\n-\t\t}\n-\t}\n-\tif !changed {\n-\t\treturn ppath\n-\t}\n-\treturn string(bsl)\n-}\n-\n-// gccgoPkgpathToSymbolOld converts a package path to a gccgo-style\n-// package symbol using the older mangling scheme.\n-func gccgoPkgpathToSymbolOld(ppath string) string {\n-\tclean := func(r rune) rune {\n-\t\tswitch {\n-\t\tcase 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',\n-\t\t\t'0' <= r && r <= '9':\n-\t\t\treturn r\n-\t\t}\n-\t\treturn '_'\n-\t}\n-\treturn strings.Map(clean, ppath)\n-}\n-\n // gccgoPkgpathToSymbol converts a package path to a mangled packagepath\n // symbol.\n func gccgoPkgpathToSymbol(ppath string) string {\n-\tif gccgoUsesNewMangling() {\n-\t\treturn gccgoPkgpathToSymbolNew(ppath)\n-\t} else {\n-\t\treturn gccgoPkgpathToSymbolOld(ppath)\n+\tif gccgoMangler == nil {\n+\t\tvar err error\n+\t\tcmd := os.Getenv(\"GCCGO\")\n+\t\tif cmd == \"\" {\n+\t\t\tcmd, err = exec.LookPath(\"gccgo\")\n+\t\t\tif err != nil {\n+\t\t\t\tfatalf(\"unable to locate gccgo: %v\", err)\n+\t\t\t}\n+\t\t}\n+\t\tgccgoMangler, err = pkgpath.ToSymbolFunc(cmd, *objDir)\n+\t\tif err != nil {\n+\t\t\tfatalf(\"%v\", err)\n+\t\t}\n \t}\n+\treturn gccgoMangler(ppath)\n }\n \n // Return the package prefix when using gccgo."}, {"sha": "dbaff704468ca1eec73e9c4438297712175662c8", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 22, "deletions": 25, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -11,11 +11,13 @@ import (\n \t\"os/exec\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"sync\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/str\"\n+\t\"cmd/internal/pkgpath\"\n )\n \n // The Gccgo toolchain.\n@@ -174,7 +176,7 @@ func (tools gccgoToolchain) asm(b *Builder, a *Action, sfiles []string) ([]strin\n \t\tofiles = append(ofiles, ofile)\n \t\tsfile = mkAbs(p.Dir, sfile)\n \t\tdefs := []string{\"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch}\n-\t\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n+\t\tif pkgpath := tools.gccgoCleanPkgpath(b, p); pkgpath != \"\" {\n \t\t\tdefs = append(defs, `-D`, `GOPKGPATH=`+pkgpath)\n \t\t}\n \t\tdefs = tools.maybePIC(defs)\n@@ -556,7 +558,7 @@ func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile, cfile string) error\n \tcfile = mkAbs(p.Dir, cfile)\n \tdefs := []string{\"-D\", \"GOOS_\" + cfg.Goos, \"-D\", \"GOARCH_\" + cfg.Goarch}\n \tdefs = append(defs, b.gccArchArgs()...)\n-\tif pkgpath := gccgoCleanPkgpath(p); pkgpath != \"\" {\n+\tif pkgpath := tools.gccgoCleanPkgpath(b, p); pkgpath != \"\" {\n \t\tdefs = append(defs, `-D`, `GOPKGPATH=\"`+pkgpath+`\"`)\n \t}\n \tcompiler := envList(\"CC\", cfg.DefaultCC(cfg.Goos, cfg.Goarch))\n@@ -596,28 +598,23 @@ func gccgoPkgpath(p *load.Package) string {\n \treturn p.ImportPath\n }\n \n-// gccgoCleanPkgpath returns the form of p's pkgpath that gccgo uses\n-// for symbol names. This is like gccgoPkgpathToSymbolNew in cmd/cgo/out.go.\n-func gccgoCleanPkgpath(p *load.Package) string {\n-\tppath := gccgoPkgpath(p)\n-\tbsl := []byte{}\n-\tchanged := false\n-\tfor _, c := range []byte(ppath) {\n-\t\tswitch {\n-\t\tcase 'A' <= c && c <= 'Z', 'a' <= c && c <= 'z',\n-\t\t\t'0' <= c && c <= '9', c == '_':\n-\t\t\tbsl = append(bsl, c)\n-\t\tcase c == '.':\n-\t\t\tbsl = append(bsl, \".x2e\"...)\n-\t\t\tchanged = true\n-\t\tdefault:\n-\t\t\tencbytes := []byte(fmt.Sprintf(\"..z%02x\", c))\n-\t\t\tbsl = append(bsl, encbytes...)\n-\t\t\tchanged = true\n+var gccgoToSymbolFuncOnce sync.Once\n+var gccgoToSymbolFunc func(string) string\n+\n+func (tools gccgoToolchain) gccgoCleanPkgpath(b *Builder, p *load.Package) string {\n+\tgccgoToSymbolFuncOnce.Do(func() {\n+\t\tif cfg.BuildN {\n+\t\t\tgccgoToSymbolFunc = func(s string) string { return s }\n+\t\t\treturn\n \t\t}\n-\t}\n-\tif !changed {\n-\t\treturn ppath\n-\t}\n-\treturn string(bsl)\n+\t\tfn, err := pkgpath.ToSymbolFunc(tools.compiler(), b.WorkDir)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"cmd/go: %v\\n\", err)\n+\t\t\tbase.SetExitStatus(2)\n+\t\t\tbase.Exit()\n+\t\t}\n+\t\tgccgoToSymbolFunc = fn\n+\t})\n+\n+\treturn gccgoToSymbolFunc(gccgoPkgpath(p))\n }"}, {"sha": "0b24468be642069b03a3191fe725786b331df353", "filename": "libgo/go/cmd/internal/pkgpath/pkgpath.go", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath.go?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -0,0 +1,114 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package pkgpath determines the package path used by gccgo/GoLLVM symbols.\n+// This package is not used for the gc compiler.\n+package pkgpath\n+\n+import (\n+\t\"bytes\"\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"strings\"\n+)\n+\n+// ToSymbolFunc returns a function that may be used to convert a\n+// package path into a string suitable for use as a symbol.\n+// cmd is the gccgo/GoLLVM compiler in use, and tmpdir is a temporary\n+// directory to pass to ioutil.TempFile.\n+// For example, this returns a function that converts \"net/http\"\n+// into a string like \"net..z2fhttp\". The actual string varies for\n+// different gccgo/GoLLVM versions, which is why this returns a function\n+// that does the conversion appropriate for the compiler in use.\n+func ToSymbolFunc(cmd, tmpdir string) (func(string) string, error) {\n+\t// To determine the scheme used by cmd, we compile a small\n+\t// file and examine the assembly code. Older versions of gccgo\n+\t// use a simple mangling scheme where there can be collisions\n+\t// between packages whose paths are different but mangle to\n+\t// the same string. More recent versions use a new mangler\n+\t// that avoids these collisions.\n+\tconst filepat = \"*_gccgo_manglechck.go\"\n+\tf, err := ioutil.TempFile(tmpdir, filepat)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tgofilename := f.Name()\n+\tf.Close()\n+\tdefer os.Remove(gofilename)\n+\n+\tif err := ioutil.WriteFile(gofilename, []byte(mangleCheckCode), 0644); err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\tcommand := exec.Command(cmd, \"-S\", \"-o\", \"-\", gofilename)\n+\tbuf, err := command.Output()\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n+\t// New mangling: expect go.l..u00e4ufer.Run\n+\t// Old mangling: expect go.l__ufer.Run\n+\tif bytes.Contains(buf, []byte(\"go.l..u00e4ufer.Run\")) {\n+\t\treturn toSymbolV2, nil\n+\t} else if bytes.Contains(buf, []byte(\"go.l__ufer.Run\")) {\n+\t\treturn toSymbolV1, nil\n+\t} else {\n+\t\treturn nil, errors.New(cmd + \": unrecognized mangling scheme\")\n+\t}\n+}\n+\n+// mangleCheckCode is the package we compile to determine the mangling scheme.\n+const mangleCheckCode = `\n+package l\u00e4ufer\n+func Run(x int) int {\n+  return 1\n+}\n+`\n+\n+// toSymbolV1 converts a package path using the original mangling scheme.\n+func toSymbolV1(ppath string) string {\n+\tclean := func(r rune) rune {\n+\t\tswitch {\n+\t\tcase 'A' <= r && r <= 'Z', 'a' <= r && r <= 'z',\n+\t\t\t'0' <= r && r <= '9':\n+\t\t\treturn r\n+\t\t}\n+\t\treturn '_'\n+\t}\n+\treturn strings.Map(clean, ppath)\n+}\n+\n+// toSymbolV2 converts a package path using the newer mangling scheme.\n+func toSymbolV2(ppath string) string {\n+\t// This has to build at boostrap time, so it has to build\n+\t// with Go 1.4, so we don't use strings.Builder.\n+\tbsl := make([]byte, 0, len(ppath))\n+\tchanged := false\n+\tfor _, c := range ppath {\n+\t\tif ('A' <= c && c <= 'Z') || ('a' <= c && c <= 'z') || ('0' <= c && c <= '9') || c == '_' {\n+\t\t\tbsl = append(bsl, byte(c))\n+\t\t\tcontinue\n+\t\t}\n+\t\tvar enc string\n+\t\tswitch {\n+\t\tcase c == '.':\n+\t\t\tenc = \".x2e\"\n+\t\tcase c < 0x80:\n+\t\t\tenc = fmt.Sprintf(\"..z%02x\", c)\n+\t\tcase c < 0x10000:\n+\t\t\tenc = fmt.Sprintf(\"..u%04x\", c)\n+\t\tdefault:\n+\t\t\tenc = fmt.Sprintf(\"..U%08x\", c)\n+\t\t}\n+\t\tbsl = append(bsl, enc...)\n+\t\tchanged = true\n+\t}\n+\tif !changed {\n+\t\treturn ppath\n+\t}\n+\treturn string(bsl)\n+}"}, {"sha": "7355f81baec7a9f42b33293ce19e1a811d34a576", "filename": "libgo/go/cmd/internal/pkgpath/pkgpath_test.go", "status": "added", "additions": 121, "deletions": 0, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fpkgpath%2Fpkgpath_test.go?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -0,0 +1,121 @@\n+// Copyright 2020 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package pkgpath\n+\n+import (\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+const testEnvName = \"GO_PKGPATH_TEST_COMPILER\"\n+\n+// This init function supports TestToSymbolFunc. For simplicity,\n+// we use the test binary itself as a sample gccgo driver.\n+// We set an environment variable to specify how it should behave.\n+func init() {\n+\tswitch os.Getenv(testEnvName) {\n+\tcase \"\":\n+\t\treturn\n+\tcase \"v1\":\n+\t\tos.Stdout.WriteString(`.string\t\"go.l__ufer.Run\"`)\n+\t\tos.Exit(0)\n+\tcase \"v2\":\n+\t\tos.Stdout.WriteString(`.string\t\"go.l..u00e4ufer.Run\"`)\n+\t\tos.Exit(0)\n+\tcase \"error\":\n+\t\tos.Stdout.WriteString(`unknown string`)\n+\t\tos.Exit(0)\n+\t}\n+}\n+\n+func TestToSymbolFunc(t *testing.T) {\n+\tconst input = \"p\u00e4\u4e16\ud83d\udf03\"\n+\ttests := []struct {\n+\t\tenv     string\n+\t\tfail    bool\n+\t\tmangled string\n+\t}{\n+\t\t{\n+\t\t\tenv:     \"v1\",\n+\t\t\tmangled: \"p___\",\n+\t\t},\n+\t\t{\n+\t\t\tenv:     \"v2\",\n+\t\t\tmangled: \"p..u00e4..u4e16..U0001f703\",\n+\t\t},\n+\t\t{\n+\t\t\tenv:  \"error\",\n+\t\t\tfail: true,\n+\t\t},\n+\t}\n+\n+\tcmd := os.Args[0]\n+\ttmpdir := t.TempDir()\n+\n+\tdefer os.Unsetenv(testEnvName)\n+\n+\tfor _, test := range tests {\n+\t\tt.Run(test.env, func(t *testing.T) {\n+\t\t\tos.Setenv(testEnvName, test.env)\n+\n+\t\t\tfn, err := ToSymbolFunc(cmd, tmpdir)\n+\t\t\tif err != nil {\n+\t\t\t\tif !test.fail {\n+\t\t\t\t\tt.Errorf(\"ToSymbolFunc(%q, %q): unexpected error %v\", cmd, tmpdir, err)\n+\t\t\t\t}\n+\t\t\t} else if test.fail {\n+\t\t\t\tt.Errorf(\"ToSymbolFunc(%q, %q) succeeded but expected to fail\", cmd, tmpdir)\n+\t\t\t} else if got, want := fn(input), test.mangled; got != want {\n+\t\t\t\tt.Errorf(\"ToSymbolFunc(%q, %q)(%q) = %q, want %q\", cmd, tmpdir, input, got, want)\n+\t\t\t}\n+\t\t})\n+\t}\n+}\n+\n+var symbolTests = []struct {\n+\tinput, v1, v2 string\n+}{\n+\t{\n+\t\t\"\",\n+\t\t\"\",\n+\t\t\"\",\n+\t},\n+\t{\n+\t\t\"bytes\",\n+\t\t\"bytes\",\n+\t\t\"bytes\",\n+\t},\n+\t{\n+\t\t\"net/http\",\n+\t\t\"net_http\",\n+\t\t\"net..z2fhttp\",\n+\t},\n+\t{\n+\t\t\"golang.org/x/net/http\",\n+\t\t\"golang_org_x_net_http\",\n+\t\t\"golang.x2eorg..z2fx..z2fnet..z2fhttp\",\n+\t},\n+\t{\n+\t\t\"p\u00e4\u4e16.\ud83d\udf03\",\n+\t\t\"p____\",\n+\t\t\"p..u00e4..u4e16.x2e..U0001f703\",\n+\t},\n+}\n+\n+func TestV1(t *testing.T) {\n+\tfor _, test := range symbolTests {\n+\t\tif got, want := toSymbolV1(test.input), test.v1; got != want {\n+\t\t\tt.Errorf(\"toSymbolV1(%q) = %q, want %q\", test.input, got, want)\n+\t\t}\n+\t}\n+}\n+\n+func TestV2(t *testing.T) {\n+\tfor _, test := range symbolTests {\n+\t\tif got, want := toSymbolV2(test.input), test.v2; got != want {\n+\t\t\tt.Errorf(\"toSymbolV2(%q) = %q, want %q\", test.input, got, want)\n+\t\t}\n+\t}\n+}"}, {"sha": "c11df029192993da6980c134bf9f260f060c83a8", "filename": "libgo/gotool-packages.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgotool-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/397654d66a4f84d4439e046cd330d9968af3b62b/libgo%2Fgotool-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgotool-packages.txt?ref=397654d66a4f84d4439e046cd330d9968af3b62b", "patch": "@@ -43,6 +43,7 @@ cmd/internal/buildid\n cmd/internal/diff\n cmd/internal/edit\n cmd/internal/objabi\n+cmd/internal/pkgpath\n cmd/internal/sys\n cmd/internal/test2json\n golang.org/x/crypto/ed25519"}]}