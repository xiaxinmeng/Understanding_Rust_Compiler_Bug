{"sha": "b82f988e8d21c709426d691329cf025e978d94ed", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YjgyZjk4OGU4ZDIxYzcwOTQyNmQ2OTEzMjljZjAyNWU5NzhkOTRlZA==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2014-05-13T17:22:08Z"}, "committer": {"name": "Jonathan Wakely", "email": "redi@gcc.gnu.org", "date": "2014-05-13T17:22:08Z"}, "message": "re PR libstdc++/60497 (unique_ptr<T> tries to complete its type T even though it's not required to be a complete type)\n\n\tPR libstdc++/60497\n\t* include/debug/array (get): Qualify call to other get overload.\n\t* include/profile/array (get): Likewise.\n\t* include/std/array (get): Likewise.\n\t* include/std/functional (_Mu, _Bind, _Bind_result): Qualify std::get.\n\t* include/std/mutex (unique_lock, call_once): Use __addressof.\n\t(__unlock_impl): Remove unused template.\n\t(__try_to_lock): Declare inline.\n\t(__try_lock_impl::__do_try_lock): Qualify function calls.\n\t(lock): Avoid narrowing conversion.\n\t* testsuite/20_util/bind/60497.cc: New.\n\t* testsuite/23_containers/array/element_access/60497.cc: New.\n\t* testsuite/30_threads/call_once/60497.cc: New.\n\t* testsuite/30_threads/unique_lock/cons/60497.cc: New.\n\nFrom-SVN: r210388", "tree": {"sha": "28ad5ef3ed4989d00d219267165efbbd8fdf08f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/28ad5ef3ed4989d00d219267165efbbd8fdf08f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/b82f988e8d21c709426d691329cf025e978d94ed", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82f988e8d21c709426d691329cf025e978d94ed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b82f988e8d21c709426d691329cf025e978d94ed", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b82f988e8d21c709426d691329cf025e978d94ed/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "54fde020ccdc4bbb163fb6d481743342d9ee2deb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54fde020ccdc4bbb163fb6d481743342d9ee2deb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54fde020ccdc4bbb163fb6d481743342d9ee2deb"}], "stats": {"total": 260, "additions": 213, "deletions": 47}, "files": [{"sha": "680791ff5bf93a15336cd9af379fd34e28ac319a", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -6,6 +6,21 @@\n \t* testsuite/20_util/tuple/60497.cc: Test accessing rvalues.\n \t* testsuite/20_util/tuple/comparison_operators/overloaded.cc: New.\n \n+\tPR libstdc++/60497\n+\t* include/debug/array (get): Qualify call to other get overload.\n+\t* include/profile/array (get): Likewise.\n+\t* include/std/array (get): Likewise.\n+\t* include/std/functional (_Mu, _Bind, _Bind_result): Qualify std::get.\n+\t* include/std/mutex (unique_lock, call_once): Use __addressof.\n+\t(__unlock_impl): Remove unused template.\n+\t(__try_to_lock): Declare inline.\n+\t(__try_lock_impl::__do_try_lock): Qualify function calls.\n+\t(lock): Avoid narrowing conversion.\n+\t* testsuite/20_util/bind/60497.cc: New.\n+\t* testsuite/23_containers/array/element_access/60497.cc: New.\n+\t* testsuite/30_threads/call_once/60497.cc: New.\n+\t* testsuite/30_threads/unique_lock/cons/60497.cc: New.\n+\n 2014-05-09  Jonathan Wakely  <jwakely@redhat.com>\n \n \t* config/abi/pre/gnu.ver (GLIBCXX_3.4.20): Correct regex_error export."}, {"sha": "2266a53e41aa81fa2482f23ed0303adb676ef116", "filename": "libstdc++-v3/include/debug/array", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fdebug%2Farray?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -278,7 +278,7 @@ namespace __debug\n     get(array<_Tp, _Nm>&& __arr) noexcept\n     {\n       static_assert(_Int < _Nm, \"index is out of bounds\");\n-      return std::move(get<_Int>(__arr));\n+      return std::move(__debug::get<_Int>(__arr));\n     }\n \n   template<std::size_t _Int, typename _Tp, std::size_t _Nm>"}, {"sha": "1a43a4888d733707133ce75d970072ef1d172514", "filename": "libstdc++-v3/include/profile/array", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fprofile%2Farray?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -240,7 +240,7 @@ namespace __profile\n     get(array<_Tp, _Nm>&& __arr) noexcept\n     {\n       static_assert(_Int < _Nm, \"index is out of bounds\");\n-      return std::move(get<_Int>(__arr));\n+      return std::move(__profile::get<_Int>(__arr));\n     }\n \n   template<std::size_t _Int, typename _Tp, std::size_t _Nm>"}, {"sha": "22947ceb300637d2ea4bbe7a2433ddaffc0c9ad6", "filename": "libstdc++-v3/include/std/array", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Farray?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -281,7 +281,7 @@ _GLIBCXX_BEGIN_NAMESPACE_CONTAINER\n     get(array<_Tp, _Nm>&& __arr) noexcept\n     {\n       static_assert(_Int < _Nm, \"index is out of bounds\");\n-      return std::move(get<_Int>(__arr));\n+      return std::move(_GLIBCXX_STD_C::get<_Int>(__arr));\n     }\n \n   template<std::size_t _Int, typename _Tp, std::size_t _Nm>"}, {"sha": "2bc3d8da8a41b51b4c9447ea994c5d28276883d4", "filename": "libstdc++-v3/include/std/functional", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ffunctional?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -1120,7 +1120,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t       const _Index_tuple<_Indexes...>&) const volatile\n \t-> decltype(__arg(declval<_Args>()...))\n \t{\n-\t  return __arg(std::forward<_Args>(get<_Indexes>(__tuple))...);\n+\t  return __arg(std::forward<_Args>(std::get<_Indexes>(__tuple))...);\n \t}\n     };\n \n@@ -1261,7 +1261,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)\n \t{\n \t  return _M_f(_Mu<_Bound_args>()\n-\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t\t      (std::get<_Indexes>(_M_bound_args), __args)...);\n \t}\n \n       // Call as const\n@@ -1270,7 +1270,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t__call_c(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>) const\n \t{\n \t  return _M_f(_Mu<_Bound_args>()\n-\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t\t      (std::get<_Indexes>(_M_bound_args), __args)...);\n \t}\n \n       // Call as volatile\n@@ -1393,7 +1393,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t    typename __disable_if_void<_Res>::type = 0)\n \t{\n \t  return _M_f(_Mu<_Bound_args>()\n-\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t\t      (std::get<_Indexes>(_M_bound_args), __args)...);\n \t}\n \n       // Call unqualified, return void\n@@ -1403,7 +1403,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t    typename __enable_if_void<_Res>::type = 0)\n \t{\n \t  _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args), __args)...);\n+\t       (std::get<_Indexes>(_M_bound_args), __args)...);\n \t}\n \n       // Call as const\n@@ -1413,7 +1413,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t    typename __disable_if_void<_Res>::type = 0) const\n \t{\n \t  return _M_f(_Mu<_Bound_args>()\n-\t\t      (get<_Indexes>(_M_bound_args), __args)...);\n+\t\t      (std::get<_Indexes>(_M_bound_args), __args)...);\n \t}\n \n       // Call as const, return void\n@@ -1423,7 +1423,7 @@ _GLIBCXX_HAS_NESTED_TYPE(result_type)\n \t    typename __enable_if_void<_Res>::type = 0) const\n \t{\n \t  _M_f(_Mu<_Bound_args>()\n-\t       (get<_Indexes>(_M_bound_args),  __args)...);\n+\t       (std::get<_Indexes>(_M_bound_args),  __args)...);\n \t}\n \n       // Call as volatile"}, {"sha": "3d70754d94bef49b1f8144d9f16ce85d33222d85", "filename": "libstdc++-v3/include/std/mutex", "status": "modified", "additions": 20, "deletions": 37, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fmutex?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -400,36 +400,38 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n       explicit unique_lock(mutex_type& __m)\n-      : _M_device(&__m), _M_owns(false)\n+      : _M_device(std::__addressof(__m)), _M_owns(false)\n       {\n \tlock();\n \t_M_owns = true;\n       }\n \n       unique_lock(mutex_type& __m, defer_lock_t) noexcept\n-      : _M_device(&__m), _M_owns(false)\n+      : _M_device(std::__addressof(__m)), _M_owns(false)\n       { }\n \n       unique_lock(mutex_type& __m, try_to_lock_t)\n-      : _M_device(&__m), _M_owns(_M_device->try_lock())\n+      : _M_device(std::__addressof(__m)), _M_owns(_M_device->try_lock())\n       { }\n \n       unique_lock(mutex_type& __m, adopt_lock_t)\n-      : _M_device(&__m), _M_owns(true)\n+      : _M_device(std::__addressof(__m)), _M_owns(true)\n       {\n \t// XXX calling thread owns mutex\n       }\n \n       template<typename _Clock, typename _Duration>\n \tunique_lock(mutex_type& __m,\n \t\t    const chrono::time_point<_Clock, _Duration>& __atime)\n-\t: _M_device(&__m), _M_owns(_M_device->try_lock_until(__atime))\n+\t: _M_device(std::__addressof(__m)),\n+\t  _M_owns(_M_device->try_lock_until(__atime))\n \t{ }\n \n       template<typename _Rep, typename _Period>\n \tunique_lock(mutex_type& __m,\n \t\t    const chrono::duration<_Rep, _Period>& __rtime)\n-\t: _M_device(&__m), _M_owns(_M_device->try_lock_for(__rtime))\n+\t: _M_device(std::__addressof(__m)),\n+\t  _M_owns(_M_device->try_lock_for(__rtime))\n \t{ }\n \n       ~unique_lock()\n@@ -563,37 +565,16 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       bool\t\t_M_owns; // XXX use atomic_bool\n     };\n \n-  /// Partial specialization for unique_lock objects.\n+  /// Swap overload for unique_lock objects.\n   template<typename _Mutex>\n     inline void\n     swap(unique_lock<_Mutex>& __x, unique_lock<_Mutex>& __y) noexcept\n     { __x.swap(__y); }\n \n-  template<int _Idx>\n-    struct __unlock_impl\n-    {\n-      template<typename... _Lock>\n-\tstatic void\n-\t__do_unlock(tuple<_Lock&...>& __locks)\n-\t{\n-\t  std::get<_Idx>(__locks).unlock();\n-\t  __unlock_impl<_Idx - 1>::__do_unlock(__locks);\n-\t}\n-    };\n-\n-  template<>\n-    struct __unlock_impl<-1>\n-    {\n-      template<typename... _Lock>\n-\tstatic void\n-\t__do_unlock(tuple<_Lock&...>&)\n-\t{ }\n-    };\n-\n   template<typename _Lock>\n-    unique_lock<_Lock>\n+    inline unique_lock<_Lock>\n     __try_to_lock(_Lock& __l)\n-    { return unique_lock<_Lock>(__l, try_to_lock); }\n+    { return unique_lock<_Lock>{__l, try_to_lock}; }\n \n   template<int _Idx, bool _Continue = true>\n     struct __try_lock_impl\n@@ -603,11 +584,12 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n \t{\n           __idx = _Idx;\n-          auto __lock = __try_to_lock(std::get<_Idx>(__locks));\n+          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));\n           if (__lock.owns_lock())\n             {\n-              __try_lock_impl<_Idx + 1, _Idx + 2 < sizeof...(_Lock)>::\n-                __do_try_lock(__locks, __idx);\n+\t      constexpr bool __cont = _Idx + 2 < sizeof...(_Lock);\n+\t      using __try_locker = __try_lock_impl<_Idx + 1, __cont>;\n+\t      __try_locker::__do_try_lock(__locks, __idx);\n               if (__idx == -1)\n                 __lock.release();\n             }\n@@ -622,7 +604,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t__do_try_lock(tuple<_Lock&...>& __locks, int& __idx)\n \t{\n           __idx = _Idx;\n-          auto __lock = __try_to_lock(std::get<_Idx>(__locks));\n+          auto __lock = std::__try_to_lock(std::get<_Idx>(__locks));\n           if (__lock.owns_lock())\n             {\n               __idx = -1;\n@@ -665,16 +647,17 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    *  and unlock().  If the call exits via an exception any locks that were\n    *  obtained will be released.\n    */\n-  template<typename _L1, typename _L2, typename ..._L3>\n+  template<typename _L1, typename _L2, typename... _L3>\n     void\n     lock(_L1& __l1, _L2& __l2, _L3&... __l3)\n     {\n       while (true)\n         {\n+          using __try_locker = __try_lock_impl<0, sizeof...(_L3) != 0>;\n           unique_lock<_L1> __first(__l1);\n           int __idx;\n           auto __locks = std::tie(__l2, __l3...);\n-          __try_lock_impl<0, sizeof...(_L3)>::__do_try_lock(__locks, __idx);\n+          __try_locker::__do_try_lock(__locks, __idx);\n           if (__idx == -1)\n             {\n               __first.release();\n@@ -735,7 +718,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n #ifdef _GLIBCXX_HAVE_TLS\n       auto __bound_functor = std::__bind_simple(std::forward<_Callable>(__f),\n           std::forward<_Args>(__args)...);\n-      __once_callable = &__bound_functor;\n+      __once_callable = std::__addressof(__bound_functor);\n       __once_call = &__once_call_impl<decltype(__bound_functor)>;\n #else\n       unique_lock<mutex> __functor_lock(__get_once_mutex());"}, {"sha": "759c9d8b8853ce42fc3a39cb0d946b04fb7acade", "filename": "libstdc++-v3/testsuite/20_util/bind/60497.cc", "status": "added", "additions": 40, "deletions": 0, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F20_util%2Fbind%2F60497.cc?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -0,0 +1,40 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/60497\n+\n+#include <functional>\n+#include <memory>\n+\n+struct A;\n+template<typename T> struct B { T t; };\n+\n+using UP = std::unique_ptr<B<A>>;\n+\n+bool f(UP&, UP&) { return true; }\n+\n+bool g(UP& p)\n+{\n+  auto binder = std::bind(f, std::ref(p), std::placeholders::_1);\n+  bool b1 = binder(std::ref(p));\n+  auto binderbinder = std::bind(binder, std::placeholders::_1);\n+  bool b2 = binderbinder(std::ref(p));\n+  return b1 && b2;\n+}"}, {"sha": "14932a1b303aae1c8fa851d8b5b3d89674d8026b", "filename": "libstdc++-v3/testsuite/23_containers/array/element_access/60497.cc", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Felement_access%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Felement_access%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F23_containers%2Farray%2Felement_access%2F60497.cc?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -0,0 +1,38 @@\n+// { dg-options \"-std=gnu++11\" }\n+// { dg-do compile }\n+//\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+//\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+//\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/60497\n+\n+#include <array>\n+#include <debug/array>\n+#include <profile/array>\n+#include <memory>\n+\n+struct A;\n+template<typename T> struct B { T t; };\n+\n+std::array<B<A>*, 1> a;\n+auto b = std::get<0>(std::move(a));\n+\n+std::__debug::array<B<A>*, 1> c;\n+auto d = std::__debug::get<0>(std::move(c));\n+\n+std::__profile::array<B<A>*, 1> e;\n+auto f = std::__profile::get<0>(std::move(e));"}, {"sha": "76cc710f35762761ca6dd82ac0731e0a2062a0b6", "filename": "libstdc++-v3/testsuite/30_threads/call_once/60497.cc", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Fcall_once%2F60497.cc?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -0,0 +1,41 @@\n+// { dg-do compile }\n+// { dg-options \" -std=gnu++11 -pthread\" { target *-*-freebsd* *-*-netbsd* *-*-linux* *-*-gnu* powerpc-ibm-aix* } }\n+// { dg-options \" -std=gnu++11 -pthreads\" { target *-*-solaris* } }\n+// { dg-options \" -std=gnu++11 \" { target *-*-cygwin *-*-darwin* } }\n+// { dg-require-cstdint \"\" }\n+// { dg-require-gthreads \"\" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/60497\n+\n+#include <mutex>\n+#include <memory>\n+\n+struct A;\n+template<typename T> struct B { T t; };\n+\n+using UP = std::unique_ptr<B<A>>;\n+\n+void f(UP&) { }\n+\n+void g(UP& p)\n+{\n+  std::once_flag o;\n+  std::call_once(o, f, std::ref(p));\n+}"}, {"sha": "19be845fd940c5baf5a51c0c57538f3426bfe084", "filename": "libstdc++-v3/testsuite/30_threads/unique_lock/cons/60497.cc", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b82f988e8d21c709426d691329cf025e978d94ed/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F30_threads%2Funique_lock%2Fcons%2F60497.cc?ref=b82f988e8d21c709426d691329cf025e978d94ed", "patch": "@@ -0,0 +1,49 @@\n+// { dg-do compile }\n+// { dg-options \" -std=gnu++11 \" }\n+\n+// Copyright (C) 2014 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 3, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without even the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+// libstdc++/60497\n+\n+#include <mutex>\n+#include <memory>\n+\n+struct A;\n+template<typename  T> struct B { T t; };\n+\n+template<typename Dummy>\n+struct Lockable\n+{\n+  void lock();\n+  void unlock();\n+  bool try_lock();\n+};\n+\n+using test_type = Lockable<std::unique_ptr<B<A>>>;\n+\n+void test01()\n+{\n+  test_type l;\n+  std::unique_lock<test_type> ul(l);\n+}\n+\n+void test02()\n+{\n+  test_type l1, l2, l3;\n+  std::lock(l1, l2, l3);\n+}"}]}