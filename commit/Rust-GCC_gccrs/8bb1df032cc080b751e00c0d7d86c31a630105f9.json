{"sha": "8bb1df032cc080b751e00c0d7d86c31a630105f9", "node_id": "C_kwDOANBUbNoAKDhiYjFkZjAzMmNjMDgwYjc1MWUwMGMwZDdkODZjMzFhNjMwMTA1Zjk", "commit": {"author": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T06:23:33Z"}, "committer": {"name": "Aldy Hernandez", "email": "aldyh@redhat.com", "date": "2022-08-30T09:26:24Z"}, "message": "Add support for floating point endpoints to frange.\n\nThe current implementation of frange is just a type with some bits to\nrepresent NAN and INF.  We can do better and represent endpoints to\nultimately solve longstanding PRs such as PR24021.  This patch adds\nthese endpoints.  In follow-up patches I will add support for a bare\nbones PLUS_EXPR range-op-float entry to solve the PR.\n\nI have chosen to use REAL_VALUE_TYPEs for the endpoints, since that's\nwhat we use underneath the trees.  This will be somewhat analogous to\nour eventual use of wide-ints in the irange.  No sense going through\nadded levels of indirection if we can avoid it.  That, plus real.*\nalready has a nice API for dealing with floats.\n\nWith this patch, ranges will be closed float point intervals, which\nmake the implementation simpler, since we don't have to keep track of\nopen/closed intervals.  This is conservative enough for use in the\nranger world, as we'd rather err on the side of more elements in a\nrange, than less.\n\nFor example, even though we cannot precisely represent the open\ninterval (3.0, 5.0) with this approach, it is perfectably reasonable\nto represent it as [3.0, 5.0] since the closed interval is a super set\nof the open one.  In the VRP/ranger world, it is always better to\nerr on the side of more information in a range, than not.  After all,\nwhen we don't know anything about a range, we just use VARYING which\nis a fancy term for a range spanning the entire domain.\n\nSince REAL_VALUE_TYPEs have properly defined infinity and NAN\nsemantics, all the math can be made to work:\n\n[-INF, 3.0] !NAN        => Numbers <= 3.0 (NAN cannot happen)\n[3.0, 3.0]  \t\t=> 3.0 or NAN.\n[3.0, +INF]             => Numbers >= 3.0 (NAN is possible)\n[-INF, +INF]            => VARYING (NAN is possible)\n[-INF, +INF] !NAN       => Entire domain.  NAN cannot happen.\n\nAlso, since REAL_VALUE_TYPEs can represent the minimum and maximum\nrepresentable values of a TYPE_MODE, we can disambiguate between them\nand negative and positive infinity (see get_max_float in real.cc).\n\nThis also makes the math all work.  For example, suppose we know\nnothing about x and y (VARYING).  On the TRUE side of x > y, we can\ndeduce that:\n\n        (a) x cannot be NAN\n        (b) y cannot be NAN\n        (c) y cannot be +INF.\n\n(c) means that we can drop the upper bound of \"y\" from +INF to the\nmaximum representable value for its type.\n\nHaving endpoints with different representation for infinity and the\nmaximum representable values, means we can drop the +-INF properties\nwe currently have in the frange.\n\ngcc/ChangeLog:\n\n\t* range-op-float.cc (frange_set_nan): New.\n\t(frange_drop_inf): New.\n\t(frange_drop_ninf): New.\n\t(foperator_equal::op1_range): Adjust for endpoints.\n\t(foperator_lt::op1_range): Same.\n\t(foperator_lt::op2_range): Same.\n\t(foperator_gt::op1_range): Same.\n\t(foperator_gt::op2_range): Same.\n\t(foperator_unordered::op1_range): Same.\n\t* value-query.cc (range_query::get_tree_range): Same.\n\t* value-range-pretty-print.cc (vrange_printer::visit): Same.\n\t* value-range-storage.cc (frange_storage_slot::get_frange): Same.\n\t* value-range.cc (frange::set): Same.\n\t(frange::normalize_kind): Same.\n\t(frange::union_): Same.\n\t(frange::intersect): Same.\n\t(frange::operator=): Same.\n\t(early_nan_resolve): New.\n\t(frange::contains_p): New.\n\t(frange::singleton_p): New.\n\t(frange::set_nonzero): New.\n\t(frange::nonzero_p): New.\n\t(frange::set_zero): New.\n\t(frange::zero_p): New.\n\t(frange::set_nonnegative): New.\n\t(frange_float): New.\n\t(frange_nan): New.\n\t(range_tests_nan): New.\n\t(range_tests_signed_zeros): New.\n\t(range_tests_floats): New.\n\t(range_tests): New.\n\t* value-range.h (frange::lower_bound): New.\n\t(frange::upper_bound): New.\n\t(vrp_val_min): Use real_inf with a sign instead of negating inf.\n\t(frange::frange): New.\n\t(frange::set_varying): Adjust for endpoints.\n\t(real_max_representable): New.\n\t(real_min_representable): New.", "tree": {"sha": "109c86b64c96335dbdc87a78fa15028ba97eccd6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/109c86b64c96335dbdc87a78fa15028ba97eccd6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8bb1df032cc080b751e00c0d7d86c31a630105f9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb1df032cc080b751e00c0d7d86c31a630105f9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8bb1df032cc080b751e00c0d7d86c31a630105f9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8bb1df032cc080b751e00c0d7d86c31a630105f9/comments", "author": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "committer": {"login": "aldyh", "id": 12937877, "node_id": "MDQ6VXNlcjEyOTM3ODc3", "avatar_url": "https://avatars.githubusercontent.com/u/12937877?v=4", "gravatar_id": "", "url": "https://api.github.com/users/aldyh", "html_url": "https://github.com/aldyh", "followers_url": "https://api.github.com/users/aldyh/followers", "following_url": "https://api.github.com/users/aldyh/following{/other_user}", "gists_url": "https://api.github.com/users/aldyh/gists{/gist_id}", "starred_url": "https://api.github.com/users/aldyh/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/aldyh/subscriptions", "organizations_url": "https://api.github.com/users/aldyh/orgs", "repos_url": "https://api.github.com/users/aldyh/repos", "events_url": "https://api.github.com/users/aldyh/events{/privacy}", "received_events_url": "https://api.github.com/users/aldyh/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "df8fe4adb0721ab0e4486bc58482b501fe06287d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df8fe4adb0721ab0e4486bc58482b501fe06287d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df8fe4adb0721ab0e4486bc58482b501fe06287d"}], "stats": {"total": 664, "additions": 585, "deletions": 79}, "files": [{"sha": "ca41136f4cd3d6979eb3c92520c94f8595f6e8d6", "filename": "gcc/range-op-float.cc", "status": "modified", "additions": 58, "deletions": 21, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Frange-op-float.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Frange-op-float.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frange-op-float.cc?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -150,6 +150,18 @@ range_operator_float::op1_op2_relation (const irange &lhs ATTRIBUTE_UNUSED) cons\n   return VREL_VARYING;\n }\n \n+// Set R to [NAN, NAN].\n+\n+static inline void\n+frange_set_nan (frange &r, tree type)\n+{\n+  REAL_VALUE_TYPE rv;\n+  bool res = real_nan (&rv, \"\", 1, TYPE_MODE (type));\n+  if (flag_checking)\n+    gcc_assert (res);\n+  r.set (type, rv, rv);\n+}\n+\n // Return TRUE if OP1 and OP2 are known to be free of NANs.\n \n static inline bool\n@@ -178,6 +190,40 @@ frelop_early_resolve (irange &r, tree type,\n \t  && relop_early_resolve (r, type, op1, op2, rel, my_rel));\n }\n \n+// Crop R to [-INF, MAX] where MAX is the maximum representable number\n+// for TYPE.\n+\n+static inline void\n+frange_drop_inf (frange &r, tree type)\n+{\n+  // FIXME: build_real() bails on decimal float modes when called with\n+  // a max representable endpoint.\n+  if (DECIMAL_FLOAT_MODE_P (TYPE_MODE (type)))\n+    return;\n+\n+  REAL_VALUE_TYPE max;\n+  real_max_representable (&max, type);\n+  frange tmp (type, r.lower_bound (), max);\n+  r.intersect (tmp);\n+}\n+\n+// Crop R to [MIN, +INF] where MIN is the minimum representable number\n+// for TYPE.\n+\n+static inline void\n+frange_drop_ninf (frange &r, tree type)\n+{\n+  // FIXME: build_real() bails on decimal float modes when called with\n+  // a max representable endpoint.\n+  if (DECIMAL_FLOAT_MODE_P (TYPE_MODE (type)))\n+    return;\n+\n+  REAL_VALUE_TYPE min;\n+  real_min_representable (&min, type);\n+  frange tmp (type, min, r.upper_bound ());\n+  r.intersect (tmp);\n+}\n+\n // Default implementation of fold_range for relational operators.\n // This amounts to passing on any known relations from the oracle, iff\n // we know the operands are not NAN or -ffinite-math-only holds.\n@@ -252,21 +298,8 @@ foperator_equal::op1_range (frange &r, tree type,\n   switch (get_bool_state (r, lhs, type))\n     {\n     case BRS_TRUE:\n-      if (HONOR_SIGNED_ZEROS (type)\n-\t  && op2.contains_p (build_zero_cst (type)))\n-\t{\n-\t  // With signed zeros, x == -0.0 does not mean we can replace\n-\t  // x with -0.0, because x may be either +0.0 or -0.0.\n-\t  r.set_varying (type);\n-\t}\n-      else\n-\t{\n-\t  // If it's true, the result is the same as OP2.\n-\t  //\n-\t  // If the range does not actually contain zeros, this should\n-\t  // always be OK.\n-\t  r = op2;\n-\t}\n+      // If it's true, the result is the same as OP2.\n+      r = op2;\n       // The TRUE side of op1 == op2 implies op1 is !NAN.\n       r.set_nan (fp_prop::NO);\n       break;\n@@ -275,7 +308,7 @@ foperator_equal::op1_range (frange &r, tree type,\n       r.set_varying (type);\n       // The FALSE side of op1 == op1 implies op1 is a NAN.\n       if (rel == VREL_EQ)\n-\tr.set_nan (fp_prop::YES);\n+\tfrange_set_nan (r, type);\n       break;\n \n     default:\n@@ -365,7 +398,8 @@ foperator_lt::op1_range (frange &r,\n       r.set_varying (type);\n       // The TRUE side of op1 < op2 implies op1 is !NAN and !INF.\n       r.set_nan (fp_prop::NO);\n-      r.set_inf (fp_prop::NO);\n+      // x < y implies x is not +INF.\n+      frange_drop_inf (r, type);\n       break;\n \n     case BRS_FALSE:\n@@ -391,7 +425,8 @@ foperator_lt::op2_range (frange &r,\n       r.set_varying (type);\n       // The TRUE side of op1 < op2 implies op2 is !NAN and !NINF.\n       r.set_nan (fp_prop::NO);\n-      r.set_ninf (fp_prop::NO);\n+      // x < y implies y is not -INF.\n+      frange_drop_ninf (r, type);\n       break;\n \n     case BRS_FALSE:\n@@ -493,7 +528,8 @@ foperator_gt::op1_range (frange &r,\n       r.set_varying (type);\n       // The TRUE side of op1 > op2 implies op1 is !NAN and !NINF.\n       r.set_nan (fp_prop::NO);\n-      r.set_ninf (fp_prop::NO);\n+      // x > y implies x is not -INF.\n+      frange_drop_ninf (r, type);\n       break;\n \n     case BRS_FALSE:\n@@ -519,7 +555,8 @@ foperator_gt::op2_range (frange &r,\n       r.set_varying (type);\n       // The TRUE side of op1 > op2 implies op2 is !NAN and !INF.\n       r.set_nan (fp_prop::NO);\n-      r.set_inf (fp_prop::NO);\n+      // x > y implies y is not +INF.\n+      frange_drop_inf (r, type);\n       break;\n \n     case BRS_FALSE:\n@@ -636,7 +673,7 @@ foperator_unordered::op1_range (frange &r, tree type,\n       // Since at least one operand must be NAN, if one of them is\n       // not, the other must be.\n       if (op2.get_nan ().no_p ())\n-\tr.set_nan (fp_prop::YES);\n+\tfrange_set_nan (r, type);\n       break;\n \n     case BRS_FALSE:"}, {"sha": "4637fb409e5f4562c8f91414d667cdaa8da7377b", "filename": "gcc/value-query.cc", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-query.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-query.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-query.cc?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -211,10 +211,19 @@ range_query::get_tree_range (vrange &r, tree expr, gimple *stmt)\n   switch (TREE_CODE (expr))\n     {\n     case INTEGER_CST:\n+      if (TREE_OVERFLOW_P (expr))\n+\texpr = drop_tree_overflow (expr);\n+      r.set (expr, expr);\n+      return true;\n+\n     case REAL_CST:\n       if (TREE_OVERFLOW_P (expr))\n \texpr = drop_tree_overflow (expr);\n       r.set (expr, expr);\n+      if (real_isnan (TREE_REAL_CST_PTR (expr)))\n+\tas_a <frange> (r).set_nan (fp_prop::YES);\n+      else\n+\tas_a <frange> (r).set_nan (fp_prop::NO);\n       return true;\n \n     case SSA_NAME:"}, {"sha": "e66d56da29d59da416be41a4613b1b37340b86c3", "filename": "gcc/value-range-pretty-print.cc", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range-pretty-print.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range-pretty-print.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-pretty-print.cc?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -122,22 +122,30 @@ vrange_printer::print_irange_bitmasks (const irange &r) const\n void\n vrange_printer::visit (const frange &r) const\n {\n+  tree type = r.type ();\n+\n   pp_string (pp, \"[frange] \");\n   if (r.undefined_p ())\n     {\n       pp_string (pp, \"UNDEFINED\");\n       return;\n     }\n-  dump_generic_node (pp, r.type (), 0, TDF_NONE, false);\n+  dump_generic_node (pp, type, 0, TDF_NONE, false);\n   pp_string (pp, \" \");\n   if (r.varying_p ())\n     {\n       pp_string (pp, \"VARYING\");\n       return;\n     }\n+  pp_character (pp, '[');\n+  dump_generic_node (pp,\n+\t\t     build_real (type, r.lower_bound ()), 0, TDF_NONE, false);\n+  pp_string (pp, \", \");\n+  dump_generic_node (pp,\n+\t\t     build_real (type, r.upper_bound ()), 0, TDF_NONE, false);\n+  pp_string (pp, \"] \");\n+\n   print_frange_prop (\"NAN\", r.get_nan ());\n-  print_frange_prop (\"INF\", r.get_inf ());\n-  print_frange_prop (\"NINF\", r.get_ninf ());\n }\n \n // Print the FP properties in an frange."}, {"sha": "adf23c39f0de529962c60db3bc7646b551c38c22", "filename": "gcc/value-range-storage.cc", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range-storage.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range-storage.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range-storage.cc?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -261,6 +261,18 @@ frange_storage_slot::get_frange (frange &r, tree type) const\n {\n   gcc_checking_assert (r.supports_type_p (type));\n \n+  // FIXME: NANs get special treatment, because we need [NAN, NAN] in\n+  // the range to properly represent it, not just the NAN flag in the\n+  // property bits.  This will go away when we stream out the\n+  // endpoints.\n+  if (m_props.get_nan ().yes_p ())\n+    {\n+      REAL_VALUE_TYPE rv;\n+      real_nan (&rv, \"\", 1, TYPE_MODE (type));\n+      r.set (type, rv, rv);\n+      return;\n+    }\n+\n   r.set_varying (type);\n   r.m_props = m_props;\n   r.normalize_kind ();"}, {"sha": "bcc6651701b441da3c305cf5c924ca7788225b68", "filename": "gcc/value-range.cc", "status": "modified", "additions": 417, "deletions": 45, "changes": 462, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.cc?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -291,41 +291,20 @@ frange::set (tree min, tree max, value_range_kind kind)\n   m_kind = kind;\n   m_type = TREE_TYPE (min);\n   m_props.set_varying ();\n+  m_min = *TREE_REAL_CST_PTR (min);\n+  m_max = *TREE_REAL_CST_PTR (max);\n \n-  bool is_min = vrp_val_is_min (min);\n-  bool is_max = vrp_val_is_max (max);\n   bool is_nan = (real_isnan (TREE_REAL_CST_PTR (min))\n \t\t || real_isnan (TREE_REAL_CST_PTR (max)));\n \n   // Ranges with a NAN and a non-NAN endpoint are nonsensical.\n   gcc_checking_assert (!is_nan || operand_equal_p (min, max));\n \n-  // The properties for singletons can be all set ahead of time.\n-  if (operand_equal_p (min, max))\n-    {\n-      // Set INF properties.\n-      if (is_min)\n-\tm_props.ninf_set_yes ();\n-      else\n-\tm_props.ninf_set_no ();\n-      if (is_max)\n-\tm_props.inf_set_yes ();\n-      else\n-\tm_props.inf_set_no ();\n-      // Set NAN property.\n-      if (is_nan)\n-\tm_props.nan_set_yes ();\n-      else\n-\tm_props.nan_set_no ();\n-    }\n-  else\n-    {\n-      // Mark when the endpoints can't be +-INF.\n-      if (!is_min)\n-\tm_props.ninf_set_no ();\n-      if (!is_max)\n-\tm_props.inf_set_no ();\n-    }\n+  // Set NAN property if we're absolutely sure.\n+  if (is_nan && operand_equal_p (min, max))\n+    m_props.nan_set_yes ();\n+  else if (!HONOR_NANS (m_type))\n+    m_props.nan_set_no ();\n \n   // Check for swapped ranges.\n   gcc_checking_assert (is_nan || tree_compare (LE_EXPR, min, max));\n@@ -336,6 +315,16 @@ frange::set (tree min, tree max, value_range_kind kind)\n     verify_range ();\n }\n \n+// Setter for frange from REAL_VALUE_TYPE endpoints.\n+\n+void\n+frange::set (tree type,\n+\t     const REAL_VALUE_TYPE &min, const REAL_VALUE_TYPE &max,\n+\t     value_range_kind kind)\n+{\n+  set (build_real (type, min), build_real (type, max), kind);\n+}\n+\n // Normalize range to VARYING or UNDEFINED, or vice versa.  Return\n // TRUE if anything changed.\n //\n@@ -347,35 +336,55 @@ frange::set (tree min, tree max, value_range_kind kind)\n bool\n frange::normalize_kind ()\n {\n-  if (m_kind == VR_RANGE)\n+  // Undefined is viral.\n+  if (m_props.nan_undefined_p ())\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n+  if (m_kind == VR_RANGE\n+      && real_isinf (&m_min, 1)\n+      && real_isinf (&m_max, 0))\n     {\n       // No FP properties set means varying.\n       if (m_props.varying_p ())\n \t{\n \t  set_varying (m_type);\n \t  return true;\n \t}\n-      // Undefined is viral.\n-      if (m_props.nan_undefined_p ()\n-\t  || m_props.inf_undefined_p ()\n-\t  || m_props.ninf_undefined_p ())\n-\t{\n-\t  set_undefined ();\n-\t  return true;\n-\t}\n     }\n   else if (m_kind == VR_VARYING)\n     {\n       // If a VARYING has any FP properties, it's no longer VARYING.\n       if (!m_props.varying_p ())\n \t{\n \t  m_kind = VR_RANGE;\n+\t  real_inf (&m_min, 1);\n+\t  real_inf (&m_max, 0);\n \t  return true;\n \t}\n     }\n   return false;\n }\n \n+// If both operands are definitely NAN, do nothing as they combine\n+// perfectly.  If OTOH, only one is a NAN, set R to VARYING as they\n+// can't be neither unioned nor intersected.  Return TRUE if we\n+// changed anything.\n+\n+static inline bool\n+early_nan_resolve (frange &r, const frange &other)\n+{\n+  gcc_checking_assert (r.get_nan ().yes_p () || other.get_nan ().yes_p ());\n+\n+  // There's nothing to do for both NANs.\n+  if (r.get_nan ().yes_p () == other.get_nan ().yes_p ())\n+    return false;\n+  // But only one NAN complicates things.\n+  r.set_varying (r.type ());\n+  return true;\n+}\n+\n bool\n frange::union_ (const vrange &v)\n {\n@@ -388,13 +397,34 @@ frange::union_ (const vrange &v)\n       *this = r;\n       return true;\n     }\n+  // ?? We could do better here.  [5,6] U NAN should be [5,6] with the\n+  // NAN maybe bits set.  For now, this is conservatively correct.\n+  if (get_nan ().yes_p () || r.get_nan ().yes_p ())\n+    return early_nan_resolve (*this, r);\n \n-  bool ret = m_props.union_ (r.m_props);\n-  ret |= normalize_kind ();\n+  bool changed = m_props.union_ (r.m_props);\n+\n+  // Note: for the combination of zeros that differ in sign we keep\n+  // the endpoints untouched.  This means that for -0.0 U +0.0, the\n+  // result will be -0.0.  Ultimately this doesn't matter, because we\n+  // keep singleton zeros ambiguous throughout to avoid propagating\n+  // them.  See frange::singleton_p().\n+\n+  if (real_less (&r.m_min, &m_min))\n+    {\n+      m_min = r.m_min;\n+      changed = true;\n+    }\n+  if (real_less (&m_max, &r.m_max))\n+    {\n+      m_max = r.m_max;\n+      changed = true;\n+    }\n+  changed |= normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n-  return ret;\n+  return changed;\n }\n \n bool\n@@ -414,20 +444,47 @@ frange::intersect (const vrange &v)\n       *this = r;\n       return true;\n     }\n+  if (get_nan ().yes_p () || r.get_nan ().yes_p ())\n+    return early_nan_resolve (*this, r);\n+\n+  bool changed = m_props.intersect (r.m_props);\n+\n+  // Note: for the combination of zeros that differ in sign we keep\n+  // the endpoints untouched.  This means that for -0.0 ^ +0.0, the\n+  // result will be -0.0.  Ultimately this doesn't matter, because we\n+  // keep singleton zeros ambiguous throughout to avoid propagating\n+  // them.  See frange::singleton_p().\n \n-  bool ret = m_props.intersect (r.m_props);\n-  ret |= normalize_kind ();\n+  if (real_less (&m_min, &r.m_min))\n+    {\n+      m_min = r.m_min;\n+      changed = true;\n+    }\n+  if (real_less (&r.m_max, &m_max))\n+    {\n+      m_max = r.m_max;\n+      changed = true;\n+    }\n+  // If the endpoints are swapped, the ranges are disjoint.\n+  if (real_less (&m_max, &m_min))\n+    {\n+      set_undefined ();\n+      return true;\n+    }\n+  changed |= normalize_kind ();\n \n   if (flag_checking)\n     verify_range ();\n-  return ret;\n+  return changed;\n }\n \n frange &\n frange::operator= (const frange &src)\n {\n   m_kind = src.m_kind;\n   m_type = src.m_type;\n+  m_min = src.m_min;\n+  m_max = src.m_max;\n   m_props = src.m_props;\n \n   if (flag_checking)\n@@ -446,7 +503,59 @@ frange::operator== (const frange &src) const\n       if (varying_p ())\n \treturn types_compatible_p (m_type, src.m_type);\n \n-      return m_props == src.m_props;\n+      if (m_props.get_nan ().yes_p ()\n+\t  || src.m_props.get_nan ().yes_p ())\n+\treturn false;\n+\n+      return (real_identical (&m_min, &src.m_min)\n+\t      && real_identical (&m_max, &src.m_max)\n+\t      && m_props == src.m_props\n+\t      && types_compatible_p (m_type, src.m_type));\n+    }\n+  return false;\n+}\n+\n+// Return TRUE if range contains the TREE_REAL_CST_PTR in CST.\n+\n+bool\n+frange::contains_p (tree cst) const\n+{\n+  if (undefined_p ())\n+    return false;\n+\n+  if (varying_p ())\n+    return true;\n+\n+  gcc_checking_assert (m_kind == VR_RANGE);\n+\n+  return (real_compare (GE_EXPR, TREE_REAL_CST_PTR (cst), &m_min)\n+\t  && real_compare (LE_EXPR, TREE_REAL_CST_PTR (cst), &m_max));\n+}\n+\n+// If range is a singleton, place it in RESULT and return TRUE.  If\n+// RESULT is NULL, just return TRUE.\n+//\n+// A NAN can never be a singleton, and neither can a 0.0 if we're\n+// honoring signed zeros because we have no way of telling which zero\n+// it is.\n+\n+bool\n+frange::singleton_p (tree *result) const\n+{\n+  if (m_kind == VR_RANGE && real_identical (&m_min, &m_max))\n+    {\n+      // If we're honoring signed zeros, fail because we don't know\n+      // which zero we have.  This avoids propagating the wrong zero.\n+      if (HONOR_SIGNED_ZEROS (m_type) && zero_p ())\n+\treturn false;\n+\n+      // Return false for any singleton that may be a NAN.\n+      if (HONOR_NANS (m_type) && !get_nan ().no_p ())\n+\treturn false;\n+\n+      if (result)\n+\t*result = build_real (m_type, m_min);\n+      return true;\n     }\n   return false;\n }\n@@ -465,13 +574,82 @@ frange::verify_range ()\n       gcc_checking_assert (m_props.undefined_p ());\n       return;\n     }\n+  gcc_checking_assert (!m_props.undefined_p ());\n+\n   if (varying_p ())\n     {\n       gcc_checking_assert (m_props.varying_p ());\n       return;\n     }\n+\n+  // We don't support the inverse of an frange (yet).\n   gcc_checking_assert (m_kind == VR_RANGE);\n-  gcc_checking_assert (!m_props.varying_p () && !m_props.undefined_p ());\n+\n+  bool is_nan = real_isnan (&m_min) || real_isnan (&m_max);\n+  if (is_nan)\n+    {\n+      // If either is a NAN, both must be a NAN.\n+      gcc_checking_assert (real_identical (&m_min, &m_max));\n+      gcc_checking_assert (get_nan ().yes_p ());\n+    }\n+  else\n+    // Make sure we don't have swapped ranges.\n+    gcc_checking_assert (!real_less (&m_max, &m_min));\n+\n+  // If we're absolutely sure we have a NAN, the endpoints should\n+  // reflect this, otherwise we'd have more than one way to represent\n+  // a NAN.\n+  if (m_props.get_nan ().yes_p ())\n+    {\n+      gcc_checking_assert (real_isnan (&m_min));\n+      gcc_checking_assert (real_isnan (&m_max));\n+    }\n+\n+  // If all the properties are clear, we better not span the entire\n+  // domain, because that would make us varying.\n+  if (m_props.varying_p ())\n+    gcc_checking_assert (!real_isinf (&m_min, 1) || !real_isinf (&m_max, 0));\n+}\n+\n+// We can't do much with nonzeros yet.\n+void\n+frange::set_nonzero (tree type)\n+{\n+  set_varying (type);\n+}\n+\n+// We can't do much with nonzeros yet.\n+bool\n+frange::nonzero_p () const\n+{\n+  return false;\n+}\n+\n+// Set range to [+0.0, +0.0].\n+\n+void\n+frange::set_zero (tree type)\n+{\n+  tree zero = build_zero_cst (type);\n+  set (zero, zero);\n+}\n+\n+// Return TRUE for any [0.0, 0.0] regardless of sign.\n+\n+bool\n+frange::zero_p () const\n+{\n+  return (m_kind == VR_RANGE\n+\t  && real_iszero (&m_min)\n+\t  && real_iszero (&m_max));\n+}\n+\n+void\n+frange::set_nonnegative (tree type)\n+{\n+  tree zero = build_zero_cst (type);\n+  tree inf = vrp_val_max (type);\n+  set (zero, inf);\n }\n \n // Here we copy between any two irange's.  The ranges can be legacy or\n@@ -3304,6 +3482,199 @@ range_tests_nonzero_bits ()\n   ASSERT_TRUE (r0.varying_p ());\n }\n \n+// Build an frange from string endpoints.\n+\n+static inline frange\n+frange_float (const char *lb, const char *ub, tree type = float_type_node)\n+{\n+  REAL_VALUE_TYPE min, max;\n+  gcc_assert (real_from_string (&min, lb) == 0);\n+  gcc_assert (real_from_string (&max, ub) == 0);\n+  return frange (type, min, max);\n+}\n+\n+// Build a NAN of type TYPE.\n+\n+static inline frange\n+frange_nan (tree type = float_type_node)\n+{\n+  REAL_VALUE_TYPE r;\n+\n+  gcc_assert (real_nan (&r, \"\", 1, TYPE_MODE (type)));\n+  return frange (type, r, r);\n+}\n+\n+static void\n+range_tests_nan ()\n+{\n+  frange r0, r1;\n+\n+  // Equal ranges but with differing NAN bits are not equal.\n+  r1 = frange_float (\"10\", \"12\");\n+  r0 = r1;\n+  ASSERT_EQ (r0, r1);\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_NE (r0, r1);\n+  r0.set_nan (fp_prop::YES);\n+  ASSERT_NE (r0, r1);\n+  r0.set_nan (fp_prop::VARYING);\n+  ASSERT_EQ (r0, r1);\n+\n+  // NAN ranges are not equal to each other.\n+  r0 = frange_nan ();\n+  r1 = r0;\n+  ASSERT_FALSE (r0 == r1);\n+  ASSERT_FALSE (r0 == r0);\n+  ASSERT_TRUE (r0 != r0);\n+\n+  // Make sure that combining NAN and INF doesn't give any crazy results.\n+  r0 = frange_nan ();\n+  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+  r1 = frange_float (\"+Inf\", \"+Inf\");\n+  r0.union_ (r1);\n+  // [INF, INF] U NAN = VARYING\n+  ASSERT_TRUE (r0.varying_p ());\n+\n+  // [INF, INF] ^ NAN = VARYING\n+  r0 = frange_nan ();\n+  r1 = frange_float (\"+Inf\", \"+Inf\");\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.varying_p ());\n+\n+  // NAN ^ NAN = NAN\n+  r0 = frange_nan ();\n+  r1 = frange_nan ();\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+\n+  // VARYING ^ NAN = NAN.\n+  r0 = frange_nan ();\n+  r1.set_varying (float_type_node);\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.get_nan ().yes_p ());\n+}\n+\n+static void\n+range_tests_signed_zeros ()\n+{\n+  tree zero = build_zero_cst (float_type_node);\n+  tree neg_zero = fold_build1 (NEGATE_EXPR, float_type_node, zero);\n+  frange r0, r1;\n+\n+  // ?? If -0.0 == +0.0, then a range of [-0.0, -0.0] should\n+  // contain +0.0 and vice versa.  We probably need a property to\n+  // track signed zeros in the frange like we do for NAN, to\n+  // properly model all this.\n+  r0 = frange (zero, zero);\n+  r1 = frange (neg_zero, neg_zero);\n+  ASSERT_TRUE (r0.contains_p (zero));\n+  ASSERT_TRUE (r0.contains_p (neg_zero));\n+  ASSERT_TRUE (r1.contains_p (zero));\n+  ASSERT_TRUE (r1.contains_p (neg_zero));\n+}\n+\n+static void\n+range_tests_floats ()\n+{\n+  frange r0, r1;\n+\n+  range_tests_nan ();\n+\n+  if (HONOR_SIGNED_ZEROS (float_type_node))\n+    range_tests_signed_zeros ();\n+\n+  // A range of [-INF,+INF] is actually VARYING...\n+  r0 = frange_float (\"-Inf\", \"+Inf\");\n+  ASSERT_TRUE (r0.varying_p ());\n+  // ...unless it has some special property...\n+  r0.set_nan (fp_prop::NO);\n+  ASSERT_FALSE (r0.varying_p ());\n+\n+  // The endpoints of a VARYING are +-INF.\n+  REAL_VALUE_TYPE inf, ninf;\n+  real_inf (&inf, 0);\n+  real_inf (&ninf, 1);\n+  r0.set_varying (float_type_node);\n+  ASSERT_TRUE (real_identical (&r0.lower_bound (), &ninf));\n+  ASSERT_TRUE (real_identical (&r0.upper_bound (), &inf));\n+\n+  // The maximum representable range for a type is still a subset of VARYING.\n+  REAL_VALUE_TYPE q, r;\n+  real_min_representable (&q, float_type_node);\n+  real_max_representable (&r, float_type_node);\n+  r0 = frange (float_type_node, q, r);\n+  // r0 is not a varying, because it does not include -INF/+INF.\n+  ASSERT_FALSE (r0.varying_p ());\n+  // The upper bound of r0 must be less than +INF.\n+  ASSERT_TRUE (real_less (&r0.upper_bound (), &inf));\n+  // The lower bound of r0 must be greater than -INF.\n+  ASSERT_TRUE (real_less (&ninf, &r0.lower_bound ()));\n+\n+  // For most architectures, where float and double are different\n+  // sizes, having the same endpoints does not necessarily mean the\n+  // ranges are equal.\n+  if (!types_compatible_p (float_type_node, double_type_node))\n+    {\n+      r0 = frange_float (\"3.0\", \"3.0\", float_type_node);\n+      r1 = frange_float (\"3.0\", \"3.0\", double_type_node);\n+      ASSERT_NE (r0, r1);\n+    }\n+\n+  // [3,5] U [10,12] = [3,12].\n+  r0 = frange_float (\"3\", \"5\");\n+  r1 = frange_float (\"10\", \"12\");\n+  r0.union_ (r1);\n+  ASSERT_EQ (r0, frange_float (\"3\", \"12\"));\n+\n+  // [5,10] U [4,8] = [4,10]\n+  r0 = frange_float (\"5\", \"10\");\n+  r1 = frange_float (\"4\", \"8\");\n+  r0.union_ (r1);\n+  ASSERT_EQ (r0, frange_float (\"4\", \"10\"));\n+\n+  // [3,5] U [4,10] = [3,10]\n+  r0 = frange_float (\"3\", \"5\");\n+  r1 = frange_float (\"4\", \"10\");\n+  r0.union_ (r1);\n+  ASSERT_EQ (r0, frange_float (\"3\", \"10\"));\n+\n+  // [4,10] U [5,11] = [4,11]\n+  r0 = frange_float (\"4\", \"10\");\n+  r1 = frange_float (\"5\", \"11\");\n+  r0.union_ (r1);\n+  ASSERT_EQ (r0, frange_float (\"4\", \"11\"));\n+\n+  // [3,12] ^ [10,12] = [10,12].\n+  r0 = frange_float (\"3\", \"12\");\n+  r1 = frange_float (\"10\", \"12\");\n+  r0.intersect (r1);\n+  ASSERT_EQ (r0, frange_float (\"10\", \"12\"));\n+\n+  // [10,12] ^ [11,11] = [11,11]\n+  r0 = frange_float (\"10\", \"12\");\n+  r1 = frange_float (\"11\", \"11\");\n+  r0.intersect (r1);\n+  ASSERT_EQ (r0, frange_float (\"11\", \"11\"));\n+\n+  // [10,20] ^ [5,15] = [10,15]\n+  r0 = frange_float (\"10\", \"20\");\n+  r1 = frange_float (\"5\",  \"15\");\n+  r0.intersect (r1);\n+  ASSERT_EQ (r0, frange_float (\"10\", \"15\"));\n+\n+  // [10,20] ^ [15,25] = [15,20]\n+  r0 = frange_float (\"10\", \"20\");\n+  r1 = frange_float (\"15\", \"25\");\n+  r0.intersect (r1);\n+  ASSERT_EQ (r0, frange_float (\"15\", \"20\"));\n+\n+  // [10,20] ^ [21,25] = []\n+  r0 = frange_float (\"10\", \"20\");\n+  r1 = frange_float (\"21\", \"25\");\n+  r0.intersect (r1);\n+  ASSERT_TRUE (r0.undefined_p ());\n+}\n+\n void\n range_tests ()\n {\n@@ -3312,6 +3683,7 @@ range_tests ()\n   range_tests_int_range_max ();\n   range_tests_strict_enum ();\n   range_tests_nonzero_bits ();\n+  range_tests_floats ();\n   range_tests_misc ();\n }\n "}, {"sha": "43b231b8fe0b8e12f7824d9b1938f3baebd5e890", "filename": "gcc/value-range.h", "status": "modified", "additions": 78, "deletions": 10, "changes": 88, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8bb1df032cc080b751e00c0d7d86c31a630105f9/gcc%2Fvalue-range.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-range.h?ref=8bb1df032cc080b751e00c0d7d86c31a630105f9", "patch": "@@ -314,14 +314,10 @@ class frange_props\n   bool intersect (const frange_props &other);\n   bool operator== (const frange_props &other) const;\n   FP_PROP_ACCESSOR(nan)\n-  FP_PROP_ACCESSOR(inf)\n-  FP_PROP_ACCESSOR(ninf)\n private:\n   union {\n     struct {\n       unsigned char nan : 2;\n-      unsigned char inf : 2;\n-      unsigned char ninf : 2;\n     } bits;\n     unsigned char bytes;\n   } u;\n@@ -345,34 +341,62 @@ class frange : public vrange\n public:\n   frange ();\n   frange (const frange &);\n+  frange (tree, tree, value_range_kind = VR_RANGE);\n+  frange (tree type, const REAL_VALUE_TYPE &min, const REAL_VALUE_TYPE &max,\n+\t  value_range_kind = VR_RANGE);\n   static bool supports_p (const_tree type)\n   {\n     return SCALAR_FLOAT_TYPE_P (type);\n   }\n   virtual tree type () const override;\n   virtual void set (tree, tree, value_range_kind = VR_RANGE) override;\n+  void set (tree type, const REAL_VALUE_TYPE &, const REAL_VALUE_TYPE &,\n+\t    value_range_kind = VR_RANGE);\n   virtual void set_varying (tree type) override;\n   virtual void set_undefined () override;\n   virtual bool union_ (const vrange &) override;\n   virtual bool intersect (const vrange &) override;\n+  virtual bool contains_p (tree) const override;\n+  virtual bool singleton_p (tree *result = NULL) const override;\n   virtual bool supports_type_p (const_tree type) const override;\n   virtual void accept (const vrange_visitor &v) const override;\n+  virtual bool zero_p () const;\n+  virtual bool nonzero_p () const;\n+  virtual void set_nonzero (tree type);\n+  virtual void set_zero (tree type);\n+  virtual void set_nonnegative (tree type);\n   frange& operator= (const frange &);\n   bool operator== (const frange &) const;\n   bool operator!= (const frange &r) const { return !(*this == r); }\n+  const REAL_VALUE_TYPE &lower_bound () const;\n+  const REAL_VALUE_TYPE &upper_bound () const;\n \n   // Each fp_prop can be accessed with get_PROP() and set_PROP().\n   FRANGE_PROP_ACCESSOR(nan)\n-  FRANGE_PROP_ACCESSOR(inf)\n-  FRANGE_PROP_ACCESSOR(ninf)\n private:\n   void verify_range ();\n   bool normalize_kind ();\n \n   frange_props m_props;\n   tree m_type;\n+  REAL_VALUE_TYPE m_min;\n+  REAL_VALUE_TYPE m_max;\n };\n \n+inline const REAL_VALUE_TYPE &\n+frange::lower_bound () const\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  return m_min;\n+}\n+\n+inline const REAL_VALUE_TYPE &\n+frange::upper_bound () const\n+{\n+  gcc_checking_assert (!undefined_p ());\n+  return m_max;\n+}\n+\n // is_a<> and as_a<> implementation for vrange.\n \n // Anything we haven't specialized is a hard fail.\n@@ -1050,10 +1074,9 @@ vrp_val_min (const_tree type)\n     return build_zero_cst (const_cast<tree> (type));\n   if (frange::supports_p (type))\n     {\n-      REAL_VALUE_TYPE real, real_ninf;\n-      real_inf (&real);\n-      real_ninf = real_value_negate (&real);\n-      return build_real (const_cast <tree> (type), real_ninf);\n+      REAL_VALUE_TYPE ninf;\n+      real_inf (&ninf, 1);\n+      return build_real (const_cast <tree> (type), ninf);\n     }\n   return NULL_TREE;\n }\n@@ -1096,6 +1119,26 @@ frange::frange (const frange &src)\n   *this = src;\n }\n \n+// frange constructor from REAL_VALUE_TYPE endpoints.\n+\n+inline\n+frange::frange (tree type,\n+\t\tconst REAL_VALUE_TYPE &min, const REAL_VALUE_TYPE &max,\n+\t\tvalue_range_kind kind)\n+{\n+  m_discriminator = VR_FRANGE;\n+  set (type, min, max, kind);\n+}\n+\n+// frange constructor from trees.\n+\n+inline\n+frange::frange (tree min, tree max, value_range_kind kind)\n+{\n+  m_discriminator = VR_FRANGE;\n+  set (min, max, kind);\n+}\n+\n inline tree\n frange::type () const\n {\n@@ -1107,6 +1150,8 @@ frange::set_varying (tree type)\n {\n   m_kind = VR_VARYING;\n   m_type = type;\n+  real_inf (&m_min, 1);\n+  real_inf (&m_max, 0);\n   m_props.set_varying ();\n }\n \n@@ -1116,6 +1161,29 @@ frange::set_undefined ()\n   m_kind = VR_UNDEFINED;\n   m_type = NULL;\n   m_props.set_undefined ();\n+  memset (&m_min, 0, sizeof (m_min));\n+  memset (&m_max, 0, sizeof (m_max));\n+}\n+\n+// Set R to maximum representable value for TYPE.\n+\n+inline void\n+real_max_representable (REAL_VALUE_TYPE *r, tree type)\n+{\n+  char buf[128];\n+  get_max_float (REAL_MODE_FORMAT (TYPE_MODE (type)),\n+\t\t buf, sizeof (buf), false);\n+  int res = real_from_string (r, buf);\n+  gcc_checking_assert (!res);\n+}\n+\n+// Set R to minimum representable value for TYPE.\n+\n+inline void\n+real_min_representable (REAL_VALUE_TYPE *r, tree type)\n+{\n+  real_max_representable (r, type);\n+  *r = real_value_negate (r);\n }\n \n #endif // GCC_VALUE_RANGE_H"}]}