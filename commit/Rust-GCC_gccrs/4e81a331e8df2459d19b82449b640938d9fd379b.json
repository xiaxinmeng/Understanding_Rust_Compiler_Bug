{"sha": "4e81a331e8df2459d19b82449b640938d9fd379b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU4MWEzMzFlOGRmMjQ1OWQxOWI4MjQ0OWI2NDA5MzhkOWZkMzc5Yg==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T22:06:40Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-06T22:06:40Z"}, "message": "Initial revision\n\nFrom-SVN: r287", "tree": {"sha": "6cd371d71def84d6ea8b60c916f3bbb2c7254da4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/6cd371d71def84d6ea8b60c916f3bbb2c7254da4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e81a331e8df2459d19b82449b640938d9fd379b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e81a331e8df2459d19b82449b640938d9fd379b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e81a331e8df2459d19b82449b640938d9fd379b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e81a331e8df2459d19b82449b640938d9fd379b/comments", "author": null, "committer": null, "parents": [{"sha": "8ef309962a8ece5579a2851b276505aa56b8f43e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8ef309962a8ece5579a2851b276505aa56b8f43e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8ef309962a8ece5579a2851b276505aa56b8f43e"}], "stats": {"total": 1953, "additions": 1953, "deletions": 0}, "files": [{"sha": "814db0b41393484cf3b3e1e77140ce5b1d22d1a1", "filename": "gcc/collect2.c", "status": "added", "additions": 1704, "deletions": 0, "changes": 1704, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e81a331e8df2459d19b82449b640938d9fd379b/gcc%2Fcollect2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e81a331e8df2459d19b82449b640938d9fd379b/gcc%2Fcollect2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcollect2.c?ref=4e81a331e8df2459d19b82449b640938d9fd379b", "patch": "@@ -0,0 +1,1704 @@\n+/* Collect static initialization info into data structures\n+   that can be traversed by C++ initialization and finalization\n+   routines.\n+\n+   Copyright (C) 1992 Free Software Foundation, Inc.\n+   Contributed by Chris Smith (csmith@convex.com).\n+   Heavily modified by Michael Meissner (meissner@osf.org),\n+   Per Bothner (bothner@cygnus.com), and John Gilmore (gnu@cygnus.com).\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+\n+/* Build tables of static constructors and destructors and run ld. */\n+\n+#include <sys/types.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <stdlib.h>\n+#include <ctype.h>\n+#include \"gstddef.h\"\n+#include <errno.h>\n+#include <signal.h>\n+#include <sys/file.h>\n+#include <sys/stat.h>\n+#include <sys/wait.h>\n+\n+#define COLLECT\n+\n+#include \"config.h\"\n+\n+#ifndef __STDC__\n+#include \"gvarargs.h\"\n+#define generic char\n+#define PROTO(x) ()\n+#define const\n+\n+#else\n+#include \"stdarg.h\"\n+#define generic void\n+#define PROTO(x) x\n+#endif\n+\n+#ifdef OBJECT_FORMAT_ROSE\n+\n+#ifdef _OSF_SOURCE\n+#define USE_MMAP\n+#endif\n+\n+#ifdef USE_MMAP\n+#include <sys/mman.h>\n+#endif\n+\n+#include <unistd.h>\n+#include <mach_o_format.h>\n+#include <mach_o_header.h>\n+#include <mach_o_vals.h>\n+#include <mach_o_types.h>\n+#endif /* OBJECT_FORMAT_ROSE */\n+\n+/* Default flags to pass to nm.  */\n+#ifndef NM_FLAGS\n+#define NM_FLAGS \"-p\"\n+#endif\n+\n+#ifdef USG\n+#define vfork fork\n+#endif\n+\n+/* On MSDOS, write temp files in current dir\n+   because there's no place else we can expect to use.  */\n+#if __MSDOS__\n+#ifndef P_tmpdir\n+#define P_tmpdir \"./\"\n+#endif\n+#endif\n+\n+\f\n+/* Linked lists of constructor and destructor names. */\n+\n+struct id \n+{\n+  struct id *next;\n+  int sequence;\n+  char name[1];\n+};\n+\n+struct head\n+{\n+  struct id *first;\n+  struct id *last;\n+  int number;\n+};\n+\n+/* Enumeration giving which pass this is for scanning the program file.  */\n+\n+enum pass {\n+  PASS_FIRST,\t\t\t\t/* without constructors */\n+  PASS_SECOND\t\t\t\t/* with constructors linked in */\n+};\n+\n+extern char *sys_siglist[];\n+extern char *version_string;\n+\n+static int vflag;\t\t\t/* true if -v */\n+static int rflag;\t\t\t/* true if -r */\n+\n+static int debug;\t\t\t/* true if -debug */\n+\n+static int   temp_filename_length;\t/* Length of temp_filename */\n+static char *temp_filename;\t\t/* Base of temp filenames */\n+static char *c_file;\t\t\t/* <xxx>.c for constructor/destructor list. */\n+static char *o_file;\t\t\t/* <xxx>.o for constructor/destructor list. */\n+static char *nm_file_name;\t\t/* pathname of nm */\n+\n+static struct head constructors;\t/* list of constructors found */\n+static struct head destructors;\t\t/* list of destructors found */\n+\n+extern char *getenv\t\tPROTO((\tconst char * ));\n+extern char *mktemp\t\tPROTO((\tchar * ));\n+extern int   vfork\t\tPROTO(( void ));\n+static void  add_to_list\tPROTO((\tstruct head *headp, char *name ));\n+static void  scan_prog_file\tPROTO((\tchar *, enum pass ));\n+static void  fork_execute\tPROTO((\tchar *, char **argv ));\n+static void  do_wait\t\tPROTO((\tchar * ));\n+static void  write_c_file\tPROTO((\tFILE *, char * ));\n+static void  my_exit\t\tPROTO(( int ));\n+static void  handler\t\tPROTO(( int ));\n+static void  maybe_unlink\tPROTO(( char * ));\n+static void  choose_temp_base\tPROTO(( void ));\n+\n+generic\t\t*xcalloc\tPROTO((\tsize_t, size_t ));\n+generic\t\t*xmalloc\tPROTO((\tsize_t ));\n+\n+\f\n+\n+#if !defined(HAVE_STRERROR) && !defined(_OSF_SOURCE)\n+\n+char *strerror (e)\n+     int e;\n+{\n+  extern char *sys_errlist[];\n+  extern int sys_nerr;\n+  static char buffer[30];\n+\n+  if (!e)\n+    return \"\";\n+\n+  if (e > 0 && e < sys_nerr)\n+    return sys_errlist[e];\n+\n+  sprintf (buffer, \"Unknown error %d\", e);\n+  return buffer;\n+}\n+\n+#endif\n+\n+\f\n+/* Delete tempfiles and exit function.  */\n+\n+static void\n+my_exit (status)\n+     int status;\n+{\n+  if (c_file[0])\n+    maybe_unlink (c_file);\n+\n+  if (o_file[0])\n+    maybe_unlink (o_file);\n+\n+  exit (status);\n+}\n+\n+\f\n+#ifndef __STDC__\n+\n+/* Die when sys call fails. */\n+\n+/*VARARGS*/\n+static void\n+fatal_perror (va_alist)\n+{\n+  char *string;\n+  va_list vptr;\n+  int e = errno;\n+\n+  va_start (vptr);\n+  string = va_arg (vptr, char *);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \": %s\\n\", strerror (e));\n+  va_end (vptr);\n+  my_exit (1);\n+}\n+\n+/* Just die. */\n+\n+/*VARARGS*/\n+static void\n+fatal (va_alist)\n+{\n+  char *string;\n+  va_list vptr;\n+\n+  va_start (vptr);\n+  string = va_arg (vptr, char *);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \"\\n\");\n+  va_end (vptr);\n+  my_exit (1);\n+}\n+\n+/* Write error message.  */\n+\n+/*VARARGS*/\n+static void\n+error (va_alist)\n+{\n+  char *string;\n+  va_list vptr;\n+\n+  va_start (vptr);\n+  string = va_arg (vptr, char *);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \"\\n\");\n+  va_end (vptr);\n+}\n+\n+#else\n+\n+static void\n+fatal_perror (char *string, ...)\n+{\n+  va_list vptr;\n+  int e = errno;\n+\n+  va_start (vptr, string);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \": %s\\n\", strerror (e));\n+  va_end (vptr);\n+  my_exit (1);\n+}\n+\n+/* Just die. */\n+\n+static void\n+fatal (char *string, ...)\n+{\n+  va_list vptr;\n+\n+  va_start (vptr, string);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \"\\n\");\n+  va_end (vptr);\n+  my_exit (1);\n+}\n+\n+/* Write error message.  */\n+\n+static void\n+error (char *string, ...)\n+{\n+  va_list vptr;\n+\n+  va_start (vptr, string);\n+  fprintf (stderr, \"collect: \");\n+  vfprintf (stderr, string, vptr);\n+  fprintf (stderr, \"\\n\");\n+  va_end (vptr);\n+}\n+#endif\n+\n+\f\n+/* In case obstack is linked in, and abort is defined to fancy_abort,\n+   provide a default entry.  */\n+\n+void\n+fancy_abort ()\n+{\n+  fatal (\"internal error\");\n+}\n+\n+\f\n+static void\n+handler (signo)\n+     int signo;\n+{\n+  if (c_file[0])\n+    maybe_unlink (c_file);\n+\n+  if (o_file[0])\n+    maybe_unlink (o_file);\n+\n+  signal (signo, SIG_DFL);\n+\n+  fatal (\"Caught signal %d [%s]\", signo, sys_siglist[signo]);\n+  kill (getpid (), signo);\n+}\n+\n+\f\n+generic *\n+xcalloc (size1, size2)\n+     size_t size1, size2;\n+{\n+  generic *ptr = calloc (size1, size2);\n+  if (ptr)\n+    return ptr;\n+\n+  fatal (\"Out of memory.\");\n+  return (generic *)0;\n+}\n+\n+generic *\n+xmalloc (size)\n+     size_t size;\n+{\n+  generic *ptr = malloc (size);\n+  if (ptr)\n+    return ptr;\n+\n+  fatal (\"Out of memory.\");\n+  return (generic *)0;\n+}\n+\n+\f\n+/* Compute a string to use as the base of all temporary file names.\n+   It is substituted for %g.  */\n+\n+static void\n+choose_temp_base PROTO((void))\n+{\n+  char *base = getenv (\"TMPDIR\");\n+  int len;\n+\n+  if (base == (char *)0)\n+    {\n+#ifdef P_tmpdir\n+      if (access (P_tmpdir, R_OK | W_OK) == 0)\n+\tbase = P_tmpdir;\n+#endif\n+      if (base == (char *)0)\n+\t{\n+\t  if (access (\"/usr/tmp\", R_OK | W_OK) == 0)\n+\t    base = \"/usr/tmp/\";\n+\t  else\n+\t    base = \"/tmp/\";\n+\t}\n+    }\n+\n+  len = strlen (base);\n+  temp_filename = xmalloc (len + sizeof(\"/ccXXXXXX\"));\n+  strcpy (temp_filename, base);\n+  if (len > 0 && temp_filename[len-1] != '/')\n+    temp_filename[len++] = '/';\n+  strcpy (temp_filename + len, \"ccXXXXXX\");\n+\n+  mktemp (temp_filename);\n+  temp_filename_length = strlen (temp_filename);\n+}\n+\n+\f\n+/* Main program. */\n+\n+int\n+main (argc, argv)\n+     int argc;\n+     char *argv[];\n+{\n+  char *outfile\t\t= \"a.out\";\n+  char *arg;\n+  FILE *outf;\n+  char *ld_file_name;\n+  char *c_file_name;\n+  char *B_option;\n+  char *p;\n+  char *prefix;\n+  char **c_argv\t\t= (char **) xcalloc (sizeof (char *), argc+7);\n+  char **c_ptr\t\t= c_argv;\n+  char **ld1_argv\t= (char **) xcalloc (sizeof (char *), argc+2);\n+  char **ld1\t\t= ld1_argv;\n+  char **ld2_argv\t= (char **) xcalloc (sizeof (char *), argc+5);\n+  char **ld2\t\t= ld2_argv;\n+  int first_file;\n+  int len;\n+  int clen;\n+\n+#ifdef DEBUG\n+  debug = 1;\n+  vflag = 1;\n+#endif\n+\n+  if (argc < 2)\n+    fatal (\"no arguments\");\n+\n+  signal (SIGQUIT, handler);\n+  signal (SIGINT,  handler);\n+  signal (SIGALRM, handler);\n+  signal (SIGHUP,  handler);\n+  signal (SIGSEGV, handler);\n+  signal (SIGBUS,  handler);\n+\n+  /* Try to discover a valid linker/assembler/nm to use.  */\n+  len = strlen (argv[0]);\n+  prefix = (char *)0;\n+  if (len >= sizeof (\"ld\")-1)\n+    {\n+      p = argv[0] + len - sizeof (\"ld\") + 1;\n+      if (strcmp (p, \"ld\") == 0)\n+\t{\n+\t  prefix = argv[0];\n+\t  *p = '\\0';\n+\t}\n+    }\n+\n+  if (prefix == (char *)0)\n+    {\n+      p = strrchr (argv[0], '/');\n+      if (p != (char *)0)\n+\t{\n+\t  prefix = argv[0];\n+\t  p[1] = '\\0';\n+\t}\n+\n+#ifdef STANDARD_EXEC_PREFIX\n+      else if (access (STANDARD_EXEC_PREFIX, X_OK) == 0)\n+\tprefix = STANDARD_EXEC_PREFIX;\n+#endif\n+\n+#ifdef MD_EXEC_PREFIX\n+      else if (access (MD_EXEC_PREFIX, X_OK) == 0)\n+\tprefix = MD_EXEC_PREFIX;\n+#endif\n+\n+      else if (access (\"/usr/ccs/gcc\", X_OK) == 0)\n+\tprefix = \"/usr/ccs/gcc/\";\n+\n+      else if (access (\"/usr/ccs/bin\", X_OK) == 0)\n+\tprefix = \"/usr/ccs/bin/\";\n+\n+      else\n+\tprefix = \"/bin/\";\n+    }\n+\n+  clen = len = strlen (prefix);\n+\n+#ifdef STANDARD_BIN_PREFIX\n+  if (clen < sizeof (STANDARD_BIN_PREFIX) - 1)\n+    clen = sizeof (STANDARD_BIN_PREFIX) - 1;\n+#endif\n+\n+  ld_file_name = xcalloc (len + sizeof (\"real-ld\"), 1);\n+  c_file_name  = xcalloc (clen + sizeof (\"gcc\"), 1);\n+  nm_file_name = xcalloc (len + sizeof (\"gnm\"), 1);\n+  B_option     = xcalloc (len + sizeof (\"-B\"), 1);\n+\n+  memcpy (ld_file_name, prefix, len);\n+  strcpy (ld_file_name + len, \"real-ld\");\n+  if (access (ld_file_name, X_OK) < 0)\n+    {\n+      strcpy (ld_file_name + len, \"gld\");\n+      if (access (ld_file_name, X_OK) < 0)\n+\t{\n+\t  free (ld_file_name);\n+#ifdef REAL_LD_FILE_NAME\n+\t  ld_file_name = REAL_LD_FILE_NAME;\n+#else\n+\t  ld_file_name = (access (\"/usr/bin/ld\", X_OK) == 0) ? \"/usr/bin/ld\" : \"/bin/ld\";\n+#endif\n+\t}\n+    }\n+\n+  memcpy (c_file_name, prefix, len);\n+  strcpy (c_file_name + len, \"gcc\");\n+  if (access (c_file_name, X_OK) < 0)\n+    {\n+#ifdef STANDARD_BIN_PREFIX\n+      strcpy (c_file_name, STANDARD_BIN_PREFIX);\n+      strcat (c_file_name, \"gcc\");\n+      if (access (c_file_name, X_OK) < 0)\n+#endif\n+\t{\n+#ifdef STANDARD_EXEC_PREFIX\n+\t  strcpy (c_file_name, STANDARD_EXEC_PREFIX);\n+\t  strcat (c_file_name, \"gcc\");\n+\t  if (access (c_file_name, X_OK) < 0)\n+#endif\n+\t    {\n+\t      strcpy (c_file_name, \"gcc\");\n+\t    }\n+\t}\n+    }\n+\n+  memcpy (nm_file_name, prefix, len);\n+  strcpy (nm_file_name + len, \"nm\");\n+  if (access (nm_file_name, X_OK) < 0)\n+    {\n+      strcpy (nm_file_name + len, \"gnm\");\n+      if (access (nm_file_name, X_OK) < 0)\n+\t{\n+\t  free (nm_file_name);\n+#ifdef REAL_NM_FILE_NAME\n+\t  nm_file_name = REAL_NM_FILE_NAME;\n+#else\n+\t  nm_file_name = (access (\"/usr/bin/nm\", X_OK) == 0) ? \"/usr/bin/nm\" : \"/bin/nm\";\n+#endif\n+\t}\n+    }\n+\n+  strcpy (B_option, \"-B\");\n+  strcpy (B_option + sizeof (\"-B\") - 1, prefix);\n+\n+  *ld1++ = *ld2++ = \"ld\";\n+\n+  /* Make temp file names. */\n+  choose_temp_base ();\n+  c_file = xcalloc (temp_filename_length + sizeof (\".c\"), 1);\n+  o_file = xcalloc (temp_filename_length + sizeof (\".o\"), 1);\n+  sprintf (c_file, \"%s.c\", temp_filename);\n+  sprintf (o_file, \"%s.o\", temp_filename);\n+  *c_ptr++ = \"gcc\";\n+  *c_ptr++ = \"-c\";\n+  *c_ptr++ = \"-o\";\n+  *c_ptr++ = o_file;\n+\n+  /* Parse arguments.  Remember output file spec, pass the rest to ld. */\n+  /* After the first file, put in the c++ rt0 */\n+  first_file = 1;\n+  while ((arg = *++argv) != (char *)0)\n+    {\n+      *ld1++ = *ld2++ = arg;\n+\n+      if (arg[0] == '-')\n+\t  switch (arg[1])\n+\t    {\n+\t    case 'd':\n+\t      if (!strcmp (arg, \"-debug\"))\n+\t\t{\n+\t\t  debug = 1;\n+\t\t  vflag = 1;\n+\t\t  ld1--;\n+\t\t  ld2--;\n+\t\t}\n+\t      break;\n+\n+\t      /* pass -f<xxx>, -B<xxx>, -b<xxx>, -V<xxx>, and -m<xxx>\n+\t\t options to gcc.  This allows options to be passed\n+\t\t that affect search rules, and the size of pointers. */\n+\t    case 'b':\n+\t    case 'B':\n+\t    case 'f':\n+\t    case 'm':\n+\t    case 'V':\n+\t      if (arg[1] != '\\0')\n+\t\t{\n+\t\t  ld1--;\n+\t\t  ld2--;\n+\t\t  *c_ptr++ = arg;\n+\t\t}\n+\t      break;\n+\n+\t    case 'o':\n+\t      outfile = (arg[2] == '\\0') ? argv[1] : &arg[2];\n+\t      break;\n+\n+\t    case 'r':\n+\t      if (arg[2] == '\\0')\n+\t\trflag = 1;\n+\t      break;\n+\n+\t    case 'v':\n+\t      if (arg[2] == '\\0')\n+\t\tvflag = 1;\n+\t      break;\n+\t    }\n+\n+      else if (first_file\n+\t       && (p = strrchr (arg, '.')) != (char *)0\n+\t       && strcmp (p, \".o\") == 0)\n+\t{\n+\t  first_file = 0;\n+\t  *ld2++ = o_file;\n+\t}\n+    }\n+\n+  *c_ptr++ = B_option;\n+  *c_ptr++ = c_file;\n+  *c_ptr = *ld1 = *ld2 = (char *)0;\n+\n+  if (vflag)\n+    {\n+      fprintf (stderr, \"GNU COLLECT2 version %s\", version_string);\n+#ifdef TARGET_VERSION\n+      TARGET_VERSION;\n+#endif\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  if (debug)\n+    {\n+      fprintf (stderr, \"prefix       = %s\\n\", prefix);\n+      fprintf (stderr, \"ld_file_name = %s\\n\", ld_file_name);\n+      fprintf (stderr, \"c_file_name  = %s\\n\", c_file_name);\n+      fprintf (stderr, \"nm_file_name = %s\\n\", nm_file_name);\n+      fprintf (stderr, \"B_option     = %s\\n\", B_option);\n+      fprintf (stderr, \"c_file       = %s\\n\", c_file);\n+      fprintf (stderr, \"o_file       = %s\\n\", o_file);\n+    }\n+\n+  /* Load the program, searching all libraries.\n+     Examine the namelist with nm and search it for static constructors\n+     and destructors to call.\n+     Write the constructor and destructor tables to a .s file and reload. */\n+\n+  fork_execute (ld_file_name, ld1_argv);\n+\n+  /* If -r, don't build the constructor or destructor list, just return now.  */\n+  if (rflag)\n+    return 0;\n+\n+  scan_prog_file (outfile, PASS_FIRST);\n+\n+  if (debug)\n+    {\n+      fprintf (stderr, \"%d constructor(s) found\\n\", constructors.number);\n+      fprintf (stderr, \"%d destructor(s)  found\\n\", destructors.number);\n+    }\n+\n+  if (constructors.number == 0 && destructors.number == 0)\n+    return 0;\n+\n+  outf = fopen (c_file, \"w\");\n+  if (outf == (FILE *)0)\n+    fatal_perror (\"Can't write %s\", c_file);\n+\n+  write_c_file (outf, c_file);\n+\n+  if (fclose (outf))\n+    fatal_perror (\"Can't close %s\", c_file);\n+\n+  if (debug)\n+    {\n+      fprintf (stderr, \"\\n========== outfile = %s, c_file = %s\\n\", outfile, c_file);\n+      write_c_file (stderr, \"stderr\");\n+      fprintf (stderr, \"========== end of c_file\\n\\n\");\n+    }\n+\n+  /* Assemble the constructor and destructor tables.\n+     Link the tables in with the rest of the program. */\n+\n+  fork_execute (c_file_name,  c_argv);\n+  fork_execute (ld_file_name, ld2_argv);\n+\n+  /* Let scan_prog_file do any final mods (OSF/rose needs this for\n+     constructors/destructors in shared libraries.  */\n+  scan_prog_file (outfile, PASS_SECOND);\n+\n+  maybe_unlink (c_file);\n+  maybe_unlink (o_file);\n+  return 0;\n+}\n+\n+\f\n+/* Wait for a process to finish, and exit if a non-zero status is found. */\n+\n+static void\n+do_wait (prog)\n+     char *prog;\n+{\n+  int status;\n+\n+  wait (&status);\n+  if (status)\n+    {\n+      int sig = WTERMSIG (status);\n+      int ret;\n+\n+      if (sig != -1 && sig != 0)\n+\t{\n+\t  error (\"%s terminated with signal %d [%s]%s\",\n+\t\t prog,\n+\t\t sig,\n+\t\t sys_siglist[sig],\n+\t\t (status & 0200) ? \", core dumped\" : \"\");\n+\n+\t  my_exit (127);\n+\t}\n+\n+      ret = WEXITSTATUS (status);\n+      if (ret != -1 && ret != 0)\n+\t{\n+\t  error (\"%s returned %d exit status\", prog, ret);\n+\t  my_exit (ret);\n+\t}\n+    }\n+}\n+\n+\f\n+/* Fork and execute a program, and wait for the reply.  */\n+\n+static void\n+fork_execute (prog, argv)\n+     char *prog;\n+     char **argv;\n+{\n+  int pid;\n+  void (*int_handler) PROTO((int));\n+  void (*quit_handler) PROTO((int));\n+\n+  if (vflag || debug)\n+    {\n+      char **p_argv;\n+      char *str;\n+\n+      fprintf (stderr, \"%s\", prog);\n+      for (p_argv = &argv[1]; (str = *p_argv) != (char *)0; p_argv++)\n+\tfprintf (stderr, \" %s\", str);\n+\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  fflush (stdout);\n+  fflush (stderr);\n+\n+  pid = vfork ();\n+  if (pid == -1)\n+    fatal_perror (\"vfork\");\n+\n+  if (pid == 0)\t\t\t/* child context */\n+    {\n+      execvp (prog, argv);\n+      fatal_perror (\"Execute %s\", prog);\n+    }\n+\n+  int_handler  = (void (*)PROTO((int)))signal (SIGINT,  SIG_IGN);\n+  quit_handler = (void (*)PROTO((int)))signal (SIGQUIT, SIG_IGN);\n+\n+  do_wait (prog);\n+\n+  signal (SIGINT,  int_handler);\n+  signal (SIGQUIT, quit_handler);\n+}\n+\n+\f\n+/* Unlink a file unless we are debugging.  */\n+\n+static void\n+maybe_unlink (file)\n+     char *file;\n+{\n+  if (!debug)\n+    unlink (file);\n+  else\n+    fprintf (stderr, \"[Leaving %s]\\n\", file);\n+}\n+\n+\f\n+/* Add a name to a linked list.  */\n+\n+static void\n+add_to_list (head_ptr, name)\n+     struct head *head_ptr;\n+     char *name;\n+{\n+  struct id *newid = (struct id *) xcalloc (sizeof (*newid) + strlen (name), 1);\n+  static long sequence_number = 0;\n+  newid->sequence = ++sequence_number;\n+  strcpy (newid->name, name);\n+\n+  if (head_ptr->first)\n+    head_ptr->last->next = newid;\n+  else\n+    head_ptr->first = newid;\n+\n+  head_ptr->last = newid;\n+  head_ptr->number++;\n+}\n+\n+/* Write: `prefix', the names on list LIST, `suffix'.  */\n+\n+static void\n+write_list (stream, prefix, list)\n+     FILE *stream;\n+     char *prefix;\n+     struct id *list;\n+{\n+  while (list)\n+    {\n+      fprintf (stream, \"%sx%d,\\n\", prefix, list->sequence);\n+      list = list->next;\n+    }\n+}\n+\n+static void\n+write_list_with_asm (stream, prefix, list)\n+     FILE *stream;\n+     char *prefix;\n+     struct id *list;\n+{\n+  while (list)\n+    {\n+      fprintf (stream, \"%sx%d asm (\\\"%s\\\");\\n\",\n+\t       prefix, list->sequence, list->name);\n+      list = list->next;\n+    }\n+}\n+\n+/* Write the constructor/destructor tables. */\n+\n+static void\n+write_c_file (stream, name)\n+     FILE *stream;\n+     char *name;\n+{\n+  /* Write the tables as C code  */\n+\n+  fprintf (stream, \"typedef void entry_pt();\\n\\n\");\n+    \n+  write_list_with_asm (stream, \"entry_pt \", constructors);\n+    \n+  fprintf (stream, \"\\nentry_pt * __CTOR_LIST__[] = {\\n\");\n+  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", constructors.number);\n+  write_list (stream, \"\\t\", constructors);\n+  fprintf (stream, \"\\t0\\n};\\n\\n\");\n+\n+  write_list_with_asm (stream, \"entry_pt \", destructors);\n+\n+  fprintf (stream, \"\\nentry_pt * __DTOR_LIST__[] = {\\n\");\n+  fprintf (stream, \"\\t(entry_pt *) %d,\\n\", destructors.number);\n+  write_list (stream, \"\\t\", destructors);\n+  fprintf (stream, \"\\t0\\n};\\n\\n\");\n+\n+  fprintf (stream, \"extern entry_pt __main;\\n\");\n+  fprintf (stream, \"entry_pt *__main_reference = __main;\\n\\n\");\n+}\n+\n+\f\n+#ifndef OBJECT_FORMAT_ROSE\n+\n+/* OSF/rose specific version to scan the name list of the loaded\n+   program for the symbols g++ uses for static constructors and\n+   destructors.\n+\n+   The constructor table begins at __CTOR_LIST__ and contains a count\n+   of the number of pointers (or -1 if the constructors are built in a\n+   separate section by the linker), followed by the pointers to the\n+   constructor functions, terminated with a null pointer.  The\n+   destructor table has the same format, and begins at __DTOR_LIST__.  */\n+\n+static void\n+scan_prog_file (prog_name, which_pass)\n+     char *prog_name;\n+     enum pass which_pass;\n+{\n+  void (*int_handler) PROTO((int));\n+  void (*quit_handler) PROTO((int));\n+  char *nm_argv[4];\n+  int pid;\n+  int argc = 0;\n+  int pipe_fd[2];\n+  char *p, buf[1024];\n+  FILE *inf;\n+\n+  if (which_pass != PASS_FIRST)\n+    return;\n+\n+  nm_argv[ argc++ ] = \"nm\";\n+  if (NM_FLAGS[0] != '\\0')\n+    nm_argv[ argc++ ] = NM_FLAGS;\n+\n+  nm_argv[ argc++ ] = prog_name;\n+  nm_argv[ argc++ ] = (char *)0;\n+\n+  if (pipe (pipe_fd) < 0)\n+    fatal_perror (\"pipe\");\n+\n+  inf = fdopen (pipe_fd[0], \"r\");\n+  if (inf == (FILE *)0)\n+    fatal_perror (\"fdopen\");\n+\n+  /* Trace if needed.  */\n+  if (vflag)\n+    {\n+      char **p_argv;\n+      char *str;\n+\n+      fprintf (stderr, \"%s\", nm_file_name);\n+      for (p_argv = &nm_argv[1]; (str = *p_argv) != (char *)0; p_argv++)\n+\tfprintf (stderr, \" %s\", str);\n+\n+      fprintf (stderr, \"\\n\");\n+    }\n+\n+  fflush (stdout);\n+  fflush (stderr);\n+\n+  /* Spawn child nm on pipe */\n+  pid = vfork ();\n+  if (pid == -1)\n+    fatal_perror (\"vfork\");\n+\n+  if (pid == 0)\t\t\t/* child context */\n+    {\n+      /* setup stdout */\n+      if (dup2 (pipe_fd[1], 1) < 0)\n+\tfatal_perror (\"Dup2 (%d, 1)\", pipe_fd[1]);\n+\n+      if (close (pipe_fd[0]) < 0)\n+\tfatal_perror (\"Close (%d)\", pipe_fd[0]);\n+\n+      if (close (pipe_fd[1]) < 0)\n+\tfatal_perror (\"Close (%d)\", pipe_fd[1]);\n+\n+      execv (nm_file_name, nm_argv);\n+      fatal_perror (\"Execute %s\", nm_file_name);\n+    }\n+\n+  /* Parent context from here on.  */\n+  int_handler  = (void (*)PROTO((int)))signal (SIGINT,  SIG_IGN);\n+  quit_handler = (void (*)PROTO((int)))signal (SIGQUIT, SIG_IGN);\n+\n+  if (close (pipe_fd[1]) < 0)\n+    fatal_perror (\"Close (%d)\", pipe_fd[1]);\n+\n+  if (debug)\n+    fprintf (stderr, \"\\nnm output with constructors/destructors.\\n\");\n+\n+  /* Read each line of nm output.  */\n+  while (fgets (buf, sizeof buf, inf) != (char *)0)\n+    {\n+      int ch, ch2;\n+      char *start;\n+      char *end;\n+\n+      /* If it contains a constructor or destructor name, add the name\n+\t to the appropriate list. */\n+\n+      for (p = buf; (ch = *p) != '\\0' && ch != '\\n' && ch != '_'; p++)\n+\t;\n+\n+      if (ch == '\\0' || ch == '\\n')\n+\tcontinue;\n+\n+      start = p;\n+      while ((ch = *p) == '_')\t/* skip any extra '_' inserted */\n+\tp++;\n+\n+      for (end = p; (ch2 = *end) != '\\0' && !isspace (ch2); end++)\n+\t;\n+\n+      *end = '\\0';\n+      if (ch == 'G')\n+\t{\n+\t  if (! strncmp (p, \"GLOBAL_$I$\", 10))\n+\t    add_to_list (&constructors, p-1);\n+\n+\t  else if (! strncmp (p, \"GLOBAL_$D$\", 10))\n+\t    add_to_list (&destructors, p-1);\n+\n+\t  else\t\t\t\t/* not a constructor or destructor */\n+\t    continue;\n+\t}\n+\n+      else if (ch == 's' && (p - start) >= 2)\n+\t{\n+\t  if (! strncmp (p, \"sti__\", 5))\n+\t    add_to_list (&constructors, p-2);\n+\n+\t  else if (! strncmp (p, \"std__\", 5))\n+\t    add_to_list (&destructors, p-2);\n+\n+\t  else\t\t\t\t/* not a constructor or destructor */\n+\t    continue;\n+\t}\n+\n+      else\n+\tcontinue;\n+\n+      if (debug)\n+\tfprintf (stderr, \"\\t%s\\n\", buf);\n+    }\n+\n+  if (debug)\n+    fprintf (stderr, \"\\n\");\n+\n+  if (fclose (inf) != 0)\n+    fatal_perror (\"fclose of pipe\");\n+\n+  do_wait (nm_file_name);\n+\n+  signal (SIGINT,  int_handler);\n+  signal (SIGQUIT, quit_handler);\n+}\n+\n+#endif /* !OBJECT_FORMAT_ROSE */\n+\n+\f\n+/*\n+ * OSF/rose specific stuff.\n+ */\n+\n+#ifdef OBJECT_FORMAT_ROSE\n+\n+/* Union of the various load commands */\n+\n+typedef union load_union\n+{\n+  ldc_header_t\t\t\thdr;\t/* common header */\n+  load_cmd_map_command_t\tmap;\t/* map indexing other load cmds */\n+  interpreter_command_t\t\tiprtr;\t/* interpereter pathname */\n+  strings_command_t\t\tstr;\t/* load commands strings section */\n+  region_command_t\t\tregion;\t/* region load command */\n+  reloc_command_t\t\treloc;\t/* relocation section */\n+  package_command_t\t\tpkg;\t/* package load command */\n+  symbols_command_t\t\tsym;\t/* symbol sections */\n+  entry_command_t\t\tent;\t/* program start section */\n+  gen_info_command_t\t\tinfo;\t/* object information */\n+  func_table_command_t\t\tfunc;\t/* function constructors/destructors */\n+} load_union_t;\n+\n+/* Structure to point to load command and data section in memory.  */\n+\n+typedef struct load_all\n+{\n+  load_union_t *load;\t\t\t/* load command */\n+  char *section;\t\t\t/* pointer to section */\n+} load_all_t;\n+\n+/* Structure to contain information about a file mapped into memory.  */\n+\n+struct file_info\n+{\n+  char *start;\t\t\t\t/* start of map */\n+  char *name;\t\t\t\t/* filename */\n+  long\tsize;\t\t\t\t/* size of the file */\n+  long  rounded_size;\t\t\t/* size rounded to page boundary */\n+  int\tfd;\t\t\t\t/* file descriptor */\n+  int\trw;\t\t\t\t/* != 0 if opened read/write */\n+  int\tuse_mmap;\t\t\t/* != 0 if mmap'ed */\n+};\n+\n+extern int decode_mach_o_hdr\t\tPROTO((\tvoid *in_bufp,\n+\t\t\t\t\t\tsize_t in_bufsize,\n+\t\t\t\t\t\tunsigned long hdr_version,\n+\t\t\t\t\t\tmo_header_t *headerp ));\n+\n+extern int encode_mach_o_hdr\t\tPROTO((\tmo_header_t *headerp,\n+\t\t\t\t\t\tvoid *out_bufp,\n+\t\t\t\t\t\tsize_t out_bufsize ));\n+\n+static void bad_header\t\t\tPROTO(( int status ));\n+\n+static void print_header\t\tPROTO(( mo_header_t *hdr_ptr ));\n+\n+static void print_load_command\t\tPROTO(( load_union_t *load_hdr,\n+\t\t\t\t\t        size_t offset,\n+\t\t\t\t\t        int number ));\n+\n+static void add_func_table\t\tPROTO(( mo_header_t *hdr_p,\n+\t\t\t\t\t        load_all_t *load_array,\n+\t\t\t\t\t        symbol_info_t *sym,\n+\t\t\t\t\t        int type ));\n+\n+static struct file_info\t*read_file\tPROTO((\tchar *, int, int ));\n+\n+static void end_file\t\t\tPROTO((\tstruct file_info * ));\n+\n+\f\n+/* OSF/rose specific version to scan the name list of the loaded\n+   program for the symbols g++ uses for static constructors and\n+   destructors.\n+\n+   The constructor table begins at __CTOR_LIST__ and contains a count\n+   of the number of pointers (or -1 if the constructors are built in a\n+   separate section by the linker), followed by the pointers to the\n+   constructor functions, terminated with a null pointer.  The\n+   destructor table has the same format, and begins at __DTOR_LIST__.  */\n+\n+static void\n+scan_prog_file (prog_name, which_pass)\n+     char *prog_name;\n+     enum pass which_pass;\n+{\n+  char *obj;\n+  mo_header_t hdr;\n+  load_all_t *load_array;\n+  load_all_t *load_end;\n+  load_all_t *load_cmd;\n+  int symbol_load_cmds;\n+  off_t offset;\n+  int i;\n+  int num_syms;\n+  int status;\n+  char *str_sect;\n+  struct file_info *obj_file;\n+  int prog_fd;\n+  mo_lcid_t cmd_strings\t  = -1;\n+  symbol_info_t *main_sym = 0;\n+  int rw\t\t  = (which_pass != PASS_FIRST);\n+\n+  prog_fd = open (prog_name, (rw) ? O_RDWR : O_RDONLY);\n+  if (prog_fd < 0)\n+    fatal_perror (\"Can't read %s\", prog_name);\n+\n+  obj_file = read_file (prog_name, prog_fd, rw);\n+  obj = obj_file->start;\n+\n+  status = decode_mach_o_hdr (obj, MO_SIZEOF_RAW_HDR, MOH_HEADER_VERSION, &hdr);\n+  if (status != MO_HDR_CONV_SUCCESS)\n+    bad_header (status);\n+\n+\n+  /* Do some basic sanity checks.  Note we explicitly use the big endian magic number,\n+     since the hardware will automatically swap bytes for us on loading little endian\n+     integers.  */\n+\n+#ifndef CROSS_COMPILE\n+  if (hdr.moh_magic != MOH_MAGIC_MSB\n+      || hdr.moh_header_version != MOH_HEADER_VERSION\n+      || hdr.moh_byte_order != OUR_BYTE_ORDER\n+      || hdr.moh_data_rep_id != OUR_DATA_REP_ID\n+      || hdr.moh_cpu_type != OUR_CPU_TYPE\n+      || hdr.moh_cpu_subtype != OUR_CPU_SUBTYPE\n+      || hdr.moh_vendor_type != OUR_VENDOR_TYPE)\n+    {\n+      fatal (\"incompatibilities exist between object file & expected values.\");\n+    }\n+#endif\n+\n+  if (debug)\n+    print_header (&hdr);\n+\n+  offset = hdr.moh_first_cmd_off;\n+  load_end = load_array\n+    = (load_all_t *) xcalloc (sizeof (load_all_t), hdr.moh_n_load_cmds + 2);\n+\n+  /* Build array of load commands, calculating the offsets */\n+  for (i = 0; i < hdr.moh_n_load_cmds; i++)\n+    {\n+      load_union_t *load_hdr;\t\t/* load command header */\n+\n+      load_cmd = load_end++;\n+      load_hdr = (load_union_t *) (obj + offset);\n+\n+      /* If modifing the program file, copy the header.  */\n+      if (rw)\n+\t{\n+\t  load_union_t *ptr = (load_union_t *) xmalloc (load_hdr->hdr.ldci_cmd_size);\n+\t  memcpy (ptr, load_hdr, load_hdr->hdr.ldci_cmd_size);\n+\t  load_hdr = ptr;\n+\n+\t  /* null out old command map, because we will rewrite at the end.  */\n+\t  if (ptr->hdr.ldci_cmd_type == LDC_CMD_MAP)\n+\t    {\n+\t      cmd_strings = ptr->map.lcm_ld_cmd_strings;\n+\t      ptr->hdr.ldci_cmd_type = LDC_UNDEFINED;\n+\t    }\n+\t}\n+\n+      load_cmd->load = load_hdr;\n+      if (load_hdr->hdr.ldci_section_off > 0)\n+\tload_cmd->section = obj + load_hdr->hdr.ldci_section_off;\n+\n+      if (debug)\n+\tprint_load_command (load_hdr, offset, i);\n+\n+      offset += load_hdr->hdr.ldci_cmd_size;\n+    }\n+\n+  /* If the last command is the load command map and is not undefined,\n+     decrement the count of load commands.  */\n+  if (rw && load_end[-1].load->hdr.ldci_cmd_type == LDC_UNDEFINED)\n+    {\n+      load_end--;\n+      hdr.moh_n_load_cmds--;\n+    }\n+\n+  /* Go through and process each symbol table section.  */\n+  symbol_load_cmds = 0;\n+  for (load_cmd = load_array; load_cmd < load_end; load_cmd++)\n+    {\n+      load_union_t *load_hdr = load_cmd->load;\n+\n+      if (load_hdr->hdr.ldci_cmd_type == LDC_SYMBOLS)\n+\t{\n+\t  symbol_load_cmds++;\n+\n+\t  if (debug)\n+\t    {\n+\t      char *kind = \"uknown\";\n+\n+\t      switch (load_hdr->sym.symc_kind)\n+\t\t{\n+\t\tcase SYMC_IMPORTS:\t   kind = \"imports\"; break;\n+\t\tcase SYMC_DEFINED_SYMBOLS: kind = \"defined\"; break;\n+\t\tcase SYMC_STABS:\t   kind = \"stabs\";   break;\n+\t\t}\n+\n+\t      fprintf (stderr, \"\\nProcessing symbol table #%d, offset = 0x%.8lx, kind = %s\\n\",\n+\t\t       symbol_load_cmds, load_hdr->hdr.ldci_section_off, kind);\n+\t    }\n+\n+\t  if (load_hdr->sym.symc_kind != SYMC_DEFINED_SYMBOLS)\n+\t    continue;\n+\n+\t  str_sect = load_array[ load_hdr->sym.symc_strings_section ].section;\n+\t  if (str_sect == (char *)0)\n+\t    fatal (\"string section missing\");\n+\n+\t  if (load_cmd->section == (char *)0)\n+\t    fatal (\"section pointer missing\");\n+\n+\t  num_syms = load_hdr->sym.symc_nentries;\n+\t  for (i = 0; i < num_syms; i++)\n+\t    {\n+\t      symbol_info_t *sym = ((symbol_info_t *) load_cmd->section) + i;\n+\t      char *name = sym->si_name.symbol_name + str_sect;\n+\t      char *name_start = name;\n+\n+\t      if (name[0] != '_')\n+\t\tcontinue;\n+\n+\t      while (*++name == '_')\t/* skip any extra '_' inserted */\n+\t\t;\n+\n+\t      if (rw)\n+\t\t{\n+\t\t  if (*name != 'm' || (name - name_start) < 2\n+\t\t      || strcmp (name, \"main\"))\n+\t\t    continue;\n+\n+\t\t  main_sym = sym;\n+\t\t}\n+\n+\t      else if (*name == 'G')\n+\t\t{\n+\t\t  if (! strncmp (name, \"GLOBAL_$I$\", 10))\n+\t\t    add_to_list (&constructors, name_start);\n+\n+\t\t  else if (! strncmp (name, \"GLOBAL_$D$\", 10))\n+\t\t    add_to_list (&destructors, name_start);\n+\n+\t\t  else\t\t/* not a constructor or destructor */\n+\t\t    continue;\n+\t\t}\n+\n+\t      else if (*name == 's' && (name - name_start) > 2)\n+\t\t{\n+\t\t  if (! strncmp (name, \"sti__\", 5))\n+\t\t    add_to_list (&constructors, name_start);\n+\n+\t\t  else if (! strncmp (name, \"std__\", 5))\n+\t\t    add_to_list (&destructors, name_start);\n+\n+\t\t  else\t\t/* not a constructor or destructor */\n+\t\t    continue;\n+\t\t}\n+\n+\t      else\n+\t\tcontinue;\n+\n+\t      if (debug)\n+\t\tfprintf (stderr, \"\\ttype = 0x%.4x, sc = 0x%.2x, flags = 0x%.8x, name = %.30s\\n\",\n+\t\t\t sym->si_type, sym->si_sc_type, sym->si_flags, name);\n+\t    }\n+\t}\n+    }\n+\n+  if (symbol_load_cmds == 0)\n+    fatal (\"no symbol table found.\");\n+\n+  /* Update the program file now, rewrite header and load commands.  At present,\n+     we assume that there is enough space after the last load command to insert\n+     one more.  Since the first section written out is page aligned, and the\n+     number of load commands is small, this is ok for the present.  */\n+\n+  if (rw)\n+    {\n+      load_union_t *load_map;\n+      size_t size;\n+\n+      if (cmd_strings == -1)\n+\tfatal (\"no cmd_strings found.\");\n+\n+      /* Add __main to initializer list.  */\n+      if (main_sym != (symbol_info_t *)0)\n+\tadd_func_table (&hdr, load_array, main_sym, FNTC_INITIALIZATION);\n+\n+      if (debug)\n+\tfprintf (stderr, \"\\nUpdating header and load commands.\\n\\n\");\n+\n+      hdr.moh_n_load_cmds++;\n+      size = sizeof (load_cmd_map_command_t) + (sizeof (mo_offset_t) * (hdr.moh_n_load_cmds - 1));\n+\n+      /* Create new load command map.  */\n+      if (debug)\n+\tfprintf (stderr, \"load command map, %d cmds, new size %ld.\\n\",\n+\t\t (int)hdr.moh_n_load_cmds, (long)size);\n+\n+      load_map = (load_union_t *) xcalloc (1, size);\n+      load_map->map.ldc_header.ldci_cmd_type = LDC_CMD_MAP;\n+      load_map->map.ldc_header.ldci_cmd_size = size;\n+      load_map->map.lcm_ld_cmd_strings = cmd_strings;\n+      load_map->map.lcm_nentries = hdr.moh_n_load_cmds;\n+      load_array[hdr.moh_n_load_cmds-1].load = load_map;\n+\n+      offset = hdr.moh_first_cmd_off;\n+      for (i = 0; i < hdr.moh_n_load_cmds; i++)\n+\t{\n+\t  load_map->map.lcm_map[i] = offset;\n+\t  if (load_array[i].load->hdr.ldci_cmd_type == LDC_CMD_MAP)\n+\t    hdr.moh_load_map_cmd_off = offset;\n+\n+\t  offset += load_array[i].load->hdr.ldci_cmd_size;\n+\t}\n+\n+      hdr.moh_sizeofcmds = offset - MO_SIZEOF_RAW_HDR;\n+\n+      if (debug)\n+\tprint_header (&hdr);\n+\n+      /* Write header */\n+      status = encode_mach_o_hdr (&hdr, obj, MO_SIZEOF_RAW_HDR);\n+      if (status != MO_HDR_CONV_SUCCESS)\n+\tbad_header (status);\n+\n+      if (debug)\n+\tfprintf (stderr, \"writing load commands.\\n\\n\");\n+\n+      /* Write load commands */\n+      offset = hdr.moh_first_cmd_off;\n+      for (i = 0; i < hdr.moh_n_load_cmds; i++)\n+\t{\n+\t  load_union_t *load_hdr = load_array[i].load;\n+\t  size_t size = load_hdr->hdr.ldci_cmd_size;\n+\n+\t  if (debug)\n+\t    print_load_command (load_hdr, offset, i);\n+\n+\t  memcpy (obj + offset, load_hdr, size);\n+\t  offset += size;\n+\t}\n+    }\n+\n+  end_file (obj_file);\n+\n+  if (close (prog_fd))\n+    fatal_perror (\"Can't close %s\", prog_name);\n+\n+  if (debug)\n+    fprintf (stderr, \"\\n\");\n+}\n+\n+\f\n+/* Add a function table to the load commands to call a function\n+   on initition or termination of the process.  */\n+\n+static void\n+add_func_table (hdr_p, load_array, sym, type)\n+     mo_header_t *hdr_p;\t\t/* pointer to global header */\n+     load_all_t *load_array;\t\t/* array of ptrs to load cmds */\n+     symbol_info_t *sym;\t\t/* pointer to symbol entry */\n+     int type;\t\t\t\t/* fntc_type value */\n+{\n+  /* Add a new load command.  */\n+  int num_cmds = ++hdr_p->moh_n_load_cmds;\n+  int load_index = num_cmds - 1;\n+  size_t size = sizeof (func_table_command_t) + sizeof (mo_addr_t);\n+  load_union_t *ptr = xcalloc (1, size);\n+  load_all_t *load_cmd;\n+  int i;\n+\n+  /* Set the unresolved address bit in the header to force the loader to be\n+     used, since kernel exec does not call the initialization functions.  */\n+  hdr_p->moh_flags |= MOH_UNRESOLVED_F;\n+\n+  load_cmd = &load_array[load_index];\n+  load_cmd->load = ptr;\n+  load_cmd->section = (char *)0;\n+\n+  /* Fill in func table load command.  */\n+  ptr->func.ldc_header.ldci_cmd_type = LDC_FUNC_TABLE;\n+  ptr->func.ldc_header.ldci_cmd_size = size;\n+  ptr->func.ldc_header.ldci_section_off = 0;\n+  ptr->func.ldc_header.ldci_section_len = 0;\n+  ptr->func.fntc_type = type;\n+  ptr->func.fntc_nentries = 1;\n+\n+  /* copy address, turn it from abs. address to (region,offset) if necessary.  */\n+  /* Is the symbol already expressed as (region, offset)?  */\n+  if ((sym->si_flags & SI_ABSOLUTE_VALUE_F) == 0)\n+    {\n+      ptr->func.fntc_entry_loc[i].adr_lcid = sym->si_value.def_val.adr_lcid;\n+      ptr->func.fntc_entry_loc[i].adr_sctoff = sym->si_value.def_val.adr_sctoff;\n+    }\n+\n+  /* If not, figure out which region it's in.  */\n+  else\n+    {\n+      mo_vm_addr_t addr = sym->si_value.abs_val;\n+      int found = 0;\n+\n+      for (i = 0; i < load_index; i++)\n+\t{\n+\t  if (load_array[i].load->hdr.ldci_cmd_type == LDC_REGION)\n+\t    {\n+\t      region_command_t *region_ptr = &load_array[i].load->region;\n+\n+\t      if ((region_ptr->regc_flags & REG_ABS_ADDR_F) != 0\n+\t\t  && addr >= region_ptr->regc_addr.vm_addr\n+\t\t  && addr <= region_ptr->regc_addr.vm_addr + region_ptr->regc_vm_size)\n+\t\t{\n+\t\t  ptr->func.fntc_entry_loc[0].adr_lcid = i;\n+\t\t  ptr->func.fntc_entry_loc[0].adr_sctoff = addr - region_ptr->regc_addr.vm_addr;\n+\t\t  found++;\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      if (!found)\n+\tfatal (\"could not convert 0x%l.8x into a region\", addr);\n+    }\n+\n+  if (debug)\n+    fprintf (stderr,\n+\t     \"%s function, region %d, offset = %ld (0x%.8lx)\\n\",\n+\t     (type == FNTC_INITIALIZATION) ? \"init\" : \"term\",\n+\t     (int)ptr->func.fntc_entry_loc[i].adr_lcid,\n+\t     (long)ptr->func.fntc_entry_loc[i].adr_sctoff,\n+\t     (long)ptr->func.fntc_entry_loc[i].adr_sctoff);\n+\n+}\n+\n+\f\n+/* Print the global header for an OSF/rose object.  */\n+\n+static void\n+print_header (hdr_ptr)\n+     mo_header_t *hdr_ptr;\n+{\n+  fprintf (stderr, \"\\nglobal header:\\n\");\n+  fprintf (stderr, \"\\tmoh_magic            = 0x%.8lx\\n\", hdr_ptr->moh_magic);\n+  fprintf (stderr, \"\\tmoh_major_version    = %d\\n\", (int)hdr_ptr->moh_major_version);\n+  fprintf (stderr, \"\\tmoh_minor_version    = %d\\n\", (int)hdr_ptr->moh_minor_version);\n+  fprintf (stderr, \"\\tmoh_header_version   = %d\\n\", (int)hdr_ptr->moh_header_version);\n+  fprintf (stderr, \"\\tmoh_max_page_size    = %d\\n\", (int)hdr_ptr->moh_max_page_size);\n+  fprintf (stderr, \"\\tmoh_byte_order       = %d\\n\", (int)hdr_ptr->moh_byte_order);\n+  fprintf (stderr, \"\\tmoh_data_rep_id      = %d\\n\", (int)hdr_ptr->moh_data_rep_id);\n+  fprintf (stderr, \"\\tmoh_cpu_type         = %d\\n\", (int)hdr_ptr->moh_cpu_type);\n+  fprintf (stderr, \"\\tmoh_cpu_subtype      = %d\\n\", (int)hdr_ptr->moh_cpu_subtype);\n+  fprintf (stderr, \"\\tmoh_vendor_type      = %d\\n\", (int)hdr_ptr->moh_vendor_type);\n+  fprintf (stderr, \"\\tmoh_load_map_cmd_off = %d\\n\", (int)hdr_ptr->moh_load_map_cmd_off);\n+  fprintf (stderr, \"\\tmoh_first_cmd_off    = %d\\n\", (int)hdr_ptr->moh_first_cmd_off);\n+  fprintf (stderr, \"\\tmoh_sizeofcmds       = %d\\n\", (int)hdr_ptr->moh_sizeofcmds);\n+  fprintf (stderr, \"\\tmon_n_load_cmds      = %d\\n\", (int)hdr_ptr->moh_n_load_cmds);\n+  fprintf (stderr, \"\\tmoh_flags            = 0x%.8lx\", (long)hdr_ptr->moh_flags);\n+\n+  if (hdr_ptr->moh_flags & MOH_RELOCATABLE_F)\n+    fprintf (stderr, \", relocatable\");\n+\n+  if (hdr_ptr->moh_flags & MOH_LINKABLE_F)\n+    fprintf (stderr, \", linkable\");\n+\n+  if (hdr_ptr->moh_flags & MOH_EXECABLE_F)\n+    fprintf (stderr, \", execable\");\n+\n+  if (hdr_ptr->moh_flags & MOH_EXECUTABLE_F)\n+    fprintf (stderr, \", executable\");\n+\n+  if (hdr_ptr->moh_flags & MOH_UNRESOLVED_F)\n+    fprintf (stderr, \", unresolved\");\n+\n+  fprintf (stderr, \"\\n\\n\");\n+  return;\n+}\n+\n+\f\n+/* Print a short summary of a load command.  */\n+\n+static void\n+print_load_command (load_hdr, offset, number)\n+     load_union_t *load_hdr;\n+     size_t offset;\n+     int number;\n+{\n+  mo_long_t type = load_hdr->hdr.ldci_cmd_type;\n+  char *type_str = (char *)0;\n+\n+  switch (type)\n+    {\n+    case LDC_UNDEFINED:   type_str = \"UNDEFINED\";\tbreak;\n+    case LDC_CMD_MAP:\t  type_str = \"CMD_MAP\";\t\tbreak;\n+    case LDC_INTERPRETER: type_str = \"INTERPRETER\";\tbreak;\n+    case LDC_STRINGS:\t  type_str = \"STRINGS\";\t\tbreak;\n+    case LDC_REGION:\t  type_str = \"REGION\";\t\tbreak;\n+    case LDC_RELOC:\t  type_str = \"RELOC\";\t\tbreak;\n+    case LDC_PACKAGE:\t  type_str = \"PACKAGE\";\t\tbreak;\n+    case LDC_SYMBOLS:\t  type_str = \"SYMBOLS\";\t\tbreak;\n+    case LDC_ENTRY:\t  type_str = \"ENTRY\";\t\tbreak;\n+    case LDC_FUNC_TABLE:  type_str = \"FUNC_TABLE\";\tbreak;\n+    case LDC_GEN_INFO:\t  type_str = \"GEN_INFO\";\tbreak;\n+    }\n+\n+  fprintf (stderr,\n+\t   \"cmd %2d, sz: 0x%.2lx, coff: 0x%.3lx, doff: 0x%.6lx, dlen: 0x%.6lx\",\n+\t   number,\n+\t   (long) load_hdr->hdr.ldci_cmd_size,\n+\t   (long) offset,\n+\t   (long) load_hdr->hdr.ldci_section_off,\n+\t   (long) load_hdr->hdr.ldci_section_len);\n+\n+  if (type_str == (char *)0)\n+    fprintf (stderr, \", ty: unknown (%ld)\\n\", (long) type);\n+\n+  else if (type != LDC_REGION)\n+    fprintf (stderr, \", ty: %s\\n\", type_str);\n+\n+  else\n+    {\n+      char *region = \"\";\n+      switch (load_hdr->region.regc_usage_type)\n+\t{\n+\tcase REG_TEXT_T:\tregion = \", .text\";\tbreak;\n+\tcase REG_DATA_T:\tregion = \", .data\";\tbreak;\n+\tcase REG_BSS_T:\t\tregion = \", .bss\";\tbreak;\n+\tcase REG_GLUE_T:\tregion = \", .glue\";\tbreak;\n+#if defined (REG_RDATA_T) && defined (REG_SDATA_T) && defined (REG_SBSS_T) /*mips*/\n+\tcase REG_RDATA_T:\tregion = \", .rdata\";\tbreak;\n+\tcase REG_SDATA_T:\tregion = \", .sdata\";\tbreak;\n+\tcase REG_SBSS_T:\tregion = \", .sbss\";\tbreak;\n+#endif\n+\t}\n+\n+      fprintf (stderr, \", ty: %s, vaddr: 0x%.8lx, vlen: 0x%.6lx%s\\n\",\n+\t       type_str,\n+\t       (long) load_hdr->region.regc_vm_addr,\n+\t       (long) load_hdr->region.regc_vm_size,\n+\t       region);\n+    }\n+\n+  return;\n+}\n+\n+\f\n+/* Fatal error when {en,de}code_mach_o_header fails.  */\n+\n+static void\n+bad_header (status)\n+     int status;\n+{\n+  char *msg = (char *)0;\n+\n+  switch (status)\n+    {\n+    case MO_ERROR_BAD_MAGIC:\t\tmsg = \"bad magic number\";\t\tbreak;\n+    case MO_ERROR_BAD_HDR_VERS:\t\tmsg = \"bad header version\";\t\tbreak;\n+    case MO_ERROR_BAD_RAW_HDR_VERS:\tmsg = \"bad raw header version\";\t\tbreak;\n+    case MO_ERROR_BUF2SML:\t\tmsg = \"raw header buffer too small\";\tbreak;\n+    case MO_ERROR_OLD_RAW_HDR_FILE:\tmsg = \"old raw header file\";\t\tbreak;\n+    case MO_ERROR_UNSUPPORTED_VERS:\tmsg = \"unsupported version\";\t\tbreak;\n+    }\n+\n+  if (msg == (char *)0)\n+    fatal (\"unknown {de,en}code_mach_o_hdr return value %d\", status);\n+  else\n+    fatal (\"%s\", msg);\n+}\n+\n+\f\n+/* Read a file into a memory buffer.  */\n+\n+static struct file_info *\n+read_file (name, fd, rw)\n+     char *name;\t\t/* filename */\n+     int fd;\t\t\t/* file descriptor */\n+     int rw;\t\t\t/* read/write */\n+{\n+  struct stat stat_pkt;\n+  struct file_info *p = (struct file_info *) xcalloc (sizeof (struct file_info), 1);\n+#ifdef USE_MMAP\n+  static int page_size;\n+#endif\n+\n+  if (fstat (fd, &stat_pkt) < 0)\n+    fatal_perror (\"fstat %s\", name);\n+\n+  p->name\t  = name;\n+  p->size\t  = stat_pkt.st_size;\n+  p->rounded_size = stat_pkt.st_size;\n+  p->fd\t\t  = fd;\n+  p->rw\t\t  = rw;\n+\n+#ifdef USE_MMAP\n+  if (debug)\n+    fprintf (stderr, \"mmap %s, %s\\n\", name, (rw) ? \"read/write\" : \"read-only\");\n+\n+  if (page_size == 0)\n+    page_size = sysconf (_SC_PAGE_SIZE);\n+\n+  p->rounded_size = ((p->size + page_size - 1) / page_size) * page_size;\n+  p->start = mmap ((caddr_t)0,\n+\t\t   (rw) ? p->rounded_size : p->size,\n+\t\t   (rw) ? (PROT_READ | PROT_WRITE) : PROT_READ,\n+\t\t   MAP_FILE | MAP_VARIABLE | MAP_SHARED,\n+\t\t   fd,\n+\t\t   0L);\n+\n+  if (p->start != (char *)0 && p->start != (char *)-1)\n+    p->use_mmap = 1;\n+\n+  else\n+#endif /* USE_MMAP */\n+    {\n+      long len;\n+\n+      if (debug)\n+\tfprintf (stderr, \"read %s\\n\", name);\n+\n+      p->use_mmap = 0;\n+      p->start = xmalloc (p->size);\n+      if (lseek (fd, 0L, SEEK_SET) < 0)\n+\tfatal_perror (\"lseek to 0 on %s\", name);\n+\n+      len = read (fd, p->start, p->size);\n+      if (len < 0)\n+\tfatal_perror (\"read %s\", name);\n+\n+      if (len != p->size)\n+\tfatal (\"read %ld bytes, expected %ld, from %s\", len, p->size, name);\n+    }\n+\n+  return p;\n+}\n+\n+\f\n+/* Do anything necessary to write a file back from memory.  */\n+\n+static void\n+end_file (ptr)\n+     struct file_info *ptr;\t/* file information block */\n+{\n+#ifdef USE_MMAP\n+  if (ptr->use_mmap)\n+    {\n+      if (ptr->rw)\n+\t{\n+\t  if (debug)\n+\t    fprintf (stderr, \"msync %s\\n\", ptr->name);\n+\n+\t  if (msync (ptr->start, ptr->rounded_size, MS_ASYNC))\n+\t    fatal_perror (\"msync %s\", ptr->name);\n+\t}\n+\n+      if (debug)\n+\tfprintf (stderr, \"munmap %s\\n\", ptr->name);\n+\n+      if (munmap (ptr->start, ptr->size))\n+\tfatal_perror (\"munmap %s\", ptr->name);\n+    }\n+  else\n+#endif /* USE_MMAP */\n+    {\n+      if (ptr->rw)\n+\t{\n+\t  long len;\n+\n+\t  if (debug)\n+\t    fprintf (stderr, \"write %s\\n\", ptr->name);\n+\n+\t  if (lseek (ptr->fd, 0L, SEEK_SET) < 0)\n+\t    fatal_perror (\"lseek to 0 on %s\", ptr->name);\n+\n+\t  len = write (ptr->fd, ptr->start, ptr->size);\n+\t  if (len < 0)\n+\t    fatal_perror (\"read %s\", ptr->name);\n+\n+\t  if (len != ptr->size)\n+\t    fatal (\"wrote %ld bytes, expected %ld, to %s\", len, ptr->size, ptr->name);\n+\t}\n+\n+      free ((generic *)ptr->start);\n+    }\n+\n+  free ((generic *)ptr);\n+}\n+\n+#endif /* OBJECT_FORMAT_ROSE */"}, {"sha": "7d9584ab3acaf6814dd2b494486590e8ef5785e7", "filename": "gcc/config/vax/vms.h", "status": "added", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e81a331e8df2459d19b82449b640938d9fd379b/gcc%2Fconfig%2Fvax%2Fvms.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e81a331e8df2459d19b82449b640938d9fd379b/gcc%2Fconfig%2Fvax%2Fvms.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fvax%2Fvms.h?ref=4e81a331e8df2459d19b82449b640938d9fd379b", "patch": "@@ -0,0 +1,249 @@\n+/* Output variables, constants and external declarations, for GNU compiler.\n+   Copyright (C) 1988 Free Software Foundation, Inc.\n+\n+This file is part of GNU CC.\n+\n+GNU CC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GNU CC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GNU CC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n+\n+/* This enables certain macros in vax.h, which will make an indirect\n+   reference to an external symbol an invalid address.  This needs to be\n+   defined before we include vax.h, since it determines which macros\n+   are used for GO_IF_*.  */\n+\n+#define NO_EXTERNAL_INDIRECT_ADDRESS\n+\n+#include \"vax.h\"\n+\n+#undef LIB_SPEC\n+#undef CPP_PREDEFINES\n+#undef TARGET_VERSION\n+#undef TARGET_DEFAULT\n+#undef CALL_USED_REGISTERS\n+#undef MAYBE_VMS_FUNCTION_PROLOGUE\n+\n+/* Predefine this in CPP because VMS limits the size of command options\n+   and GNU CPP is not used on VMS except with GNU C.  */\n+#define CPP_PREDEFINES \"-Dvax -Dvms -DVMS -D__GNU__ -D__GNUC__\"\n+\n+/* Strictly speaking, VMS does not use DBX at all, but the interpreter built\n+   into gas only speaks straight DBX.  */\n+\n+#define DEFAULT_GDB_EXTENSIONS 0\n+\n+/* By default, allow $ to be part of an identifier.  */\n+#define DOLLARS_IN_IDENTIFIERS 2\n+\n+#define TARGET_DEFAULT 1\n+#define TARGET_VERSION fprintf (stderr, \" (vax vms)\");\n+\n+#define CALL_USED_REGISTERS {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1}\n+\n+#define __MAIN_NAME \" main (\"\n+/*\n+ * The MAYBE_VMS_FUNCTION_PROLOGUE macro works for both gcc and g++.  It\n+ * first checks to see if the current routine is \"main\", which will only\n+ * happen for GCC, and add the jsb if it is.  If is not the case then try and \n+ * see if __MAIN_NAME is part of current_function_name, which will only happen\n+ * if we are running g++, and add the jsb if it is.  In gcc there should never\n+ * be a space in the function name, and in g++ there is always a \"(\" in the\n+ * function name, thus there should never be any confusion.\n+ */\n+#define MAYBE_VMS_FUNCTION_PROLOGUE(FILE)\t\\\n+{ extern char *current_function_name;\t\t\\\n+  if (!strcmp (\"main\", current_function_name))\t\\\n+    fprintf(FILE, \"\\tjsb _c$main_args\\n\"); \t\\\n+  else {\t\t\t\t\t\\\n+    char *p = current_function_name;\t\t\\\n+    while (*p != '\\0')\t\t\t\t\\\n+      if (*p == *__MAIN_NAME)\t\t\t\\\n+        if (strncmp(p, __MAIN_NAME, (sizeof __MAIN_NAME)-1) == 0) {\\\n+          fprintf(FILE, \"\\tjsb _c$main_args\\n\");\\\n+          break;\t\t\t\t\\\n+        } else\t\t\t\t\t\\\n+          p++;\t\t\t\t\t\\\n+      else\t\t\t\t\t\\\n+        p++;\t\t\t\t\t\\\n+     };\t\t\t\t\t\t\\\n+}\n+\n+/* This macro definition sets up a default value for `main' to return.  */\n+#define DEFAULT_MAIN_RETURN  c_expand_return (integer_one_node)\n+\f\n+/* This makes use of a hook in varasm.c to mark all external variables\n+   for us.  We use this to make sure that external variables are correctly\n+   addressed.  Under VMS there is some brain damage in the linker that requires\n+   us to do this.  */\n+\n+#define ENCODE_SECTION_INFO(decl)  \t\t\t\t\\\n+  if (TREE_EXTERNAL (decl) && TREE_PUBLIC (decl)) \t\t\\\n+    SYMBOL_REF_FLAG (XEXP (DECL_RTL (decl), 0)) = 1; \n+\n+/* Under VMS we write the actual size of the storage to be allocated even\n+   though the symbol is external.  Although it is possible to give external\n+   symbols a size of 0 (as unix does), the VMS linker does not make the\n+   distinction between a variable definition and an external reference of a\n+   variable, and thus the linker will not complain about a missing definition.\n+   If we followed the unix example of giving external symbols a size of\n+   zero, you tried to link a program where a given variable was externally\n+   defined but none of the object modules contained a non-extern definition,\n+   the linker would allocate 0 bytes for the variable, and any attempt to\n+   use that variable would use the storage allocated to some other variable.\n+\n+   We must also select either const_section or data_section: this will indicate\n+   whether or not the variable will get the readonly bit set.  Since the\n+   VMS linker does not distinguish between a variable's definition and an\n+   external reference, all usages of a given variable must have the readonly\n+   bit set the same way, or the linker will get confused and give warning\n+   messages.  */\n+\n+/* We used to round the size up to a multiple of 4,\n+   but that causes linker errors sometimes when the variable was initialized\n+   since the size of its definition was not likewise rounded up.  */\n+\n+#define ASM_OUTPUT_EXTERNAL(FILE,DECL,NAME)\t\t\t\t\\\n+{ if (DECL_INITIAL (DECL) == 0 && TREE_CODE (DECL) != FUNCTION_DECL)\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\t\t\\\n+\tconst_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      fputs (\".comm \", (FILE));\t\t\t\t\t\t\\\n+      assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+      if (DECL_SIZE (DECL) == 0)\t\t\t\t\t\\\n+        fprintf ((FILE), \",0\\n\");\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  tree size_tree;\t\t\t\t\t\t\\\n+\t  size_tree = size_binop (CEIL_DIV_EXPR,\t\t\t\\\n+\t     DECL_SIZE (DECL), size_int (BITS_PER_UNIT));\t\t\\\n+\t  fprintf ((FILE), \",%d\\n\", TREE_INT_CST_LOW (size_tree));\t\\\n+        }\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* Here we redefine ASM_OUTPUT_COMMON to select the data_section or the\n+   const_section before writing the \".const\" assembler directive.\n+   If we were specifying a size of zero for external variables, we would\n+   not have to select a section, since the assembler can assume that\n+   when the size > 0, the storage is for a non-external, uninitialized\n+   variable (for which a \"const\" declaration would be senseless),\n+   and the assembler can make the storage read/write.\n+\n+   Since the \".const\" directive specifies the actual size of the storage used\n+   for both external and non-external variables, the assembler cannot\n+   make this assumption, and thus it has no way of deciding if storage should\n+   be read/write or read-only.  To resolve this, we give the assembler some\n+   assistance, in the form of a \".const\" or a \".data\" directive.\n+\n+   Under GCC 1.40, external variables were declared with a size of zero.\n+   The GNU assembler, GAS, will recognize the \"-2\" switch when built for VMS;\n+   when compiling programs with GCC 2.n this switch should be used or the\n+   assembler will not give the read-only attribute to external constants.\n+   Failure to use this switch will result in linker warning messages about\n+   mismatched psect attributes.  */\n+\n+#undef ASM_OUTPUT_COMMON\n+\n+#define ASM_OUTPUT_COMMON(FILE, NAME, SIZE, ROUNDED)\t\t\\\n+( ((TREE_READONLY (decl) && ! TREE_THIS_VOLATILE (decl))\t\\\n+   ? (const_section (), 0) : (data_section (), 0)),\t\t\\\n+  fputs (\".comm \", (FILE)),\t\t\t\t\t\\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t\\\n+  fprintf ((FILE), \",%u\\n\", (ROUNDED)))\n+\n+/* We define this to prevent the name mangler from putting dollar signs into\n+   function names.  This isn't really needed, but it has been here for\n+   some time and  removing it would cause the object files generated by the\n+   compiler to be incompatible with the object files from a compiler that\n+   had this defined.  Since it does no harm, we leave it in.  */\n+\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* Add a \"const\" section.  This is viewed by the assember as being nearly\n+   the same as the \"data\" section, with the only difference being that a\n+   flag is set for variables declared while in the const section.  This\n+   flag is used to determine whether or not the read/write bit should be\n+   set in the Psect definition.  */\n+\n+#define EXTRA_SECTIONS in_const\n+\n+#define EXTRA_SECTION_FUNCTIONS\t\t\t\t\\\n+void\t\t\t\t\t\t\t\\\n+const_section ()\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\\\n+  if (in_section != in_const) {\t\t\t\t\\\n+    fprintf(asm_out_file,\".const\\n\");\t\t\t\\\n+    in_section = in_const;\t\t\t\t\\\n+  }\t\t\t\t\t\t\t\\\n+}\n+\n+/* This macro contains the logic to decide which section a variable\n+   should be stored in.  Static constant variables go in the text_section,\n+   non-const variables go in the data_section, and non-static const\n+   variables go in the const_section.\n+\n+   Since this macro is used in a number of places, we must also be able\n+   to decide where to place string constants.  */\n+\n+#define SELECT_SECTION(T,RELOC)\t\t\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  if (TREE_CODE (T) == VAR_DECL)\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (TREE_READONLY (T) && ! TREE_THIS_VOLATILE (T))\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (TREE_PUBLIC (T))\t\t\t\t\t\t\\\n+\t    const_section ();\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    text_section ();\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  if (*tree_code_type[(int) TREE_CODE (T)] == 'c')\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((TREE_CODE (T) == STRING_CST && flag_writable_strings))\t\\\n+\tdata_section ();\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\ttext_section ();\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+}\n+\n+/* This is used by a hook in varasm.c to write the assembler directives\n+   that are needed to tell the startup code which constructors need to\n+   be run.  */\n+\n+#define ASM_OUTPUT_CONSTRUCTOR(FILE,NAME)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE),\".globl $$PsectAttributes_NOOVR$$__gxx_init_1\\n\"); \t\\\n+  data_section();\t\t\t\t\t\t\t\\\n+  fprintf ((FILE),\"$$PsectAttributes_NOOVR$$__gxx_init_1:\\n\\t.long\\t\"); \\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fputc ('\\n', (FILE));\t\t\t\t\t\t\t\\\n+}\n+\n+/* This is used by a hook in varasm.c to write the assembler directives\n+   that are needed to tell the startup code which destructors need to\n+   be run.  */\n+\n+#define ASM_OUTPUT_DESTRUCTOR(FILE,NAME)\t\t\t\t\\\n+{\t\t\t\t\t\t\t\t\t\\\n+  fprintf ((FILE),\".globl $$PsectAttributes_NOOVR$$__gxx_clean_1\\n\"); \t\\\n+  data_section();\t\t\t\t\t\t\t\\\n+  fprintf ((FILE),\"$$PsectAttributes_NOOVR$$__gxx_clean_1:\\n\\t.long\\t\");\\\n+  assemble_name ((FILE), (NAME));\t\t\t\t\t\\\n+  fputc ('\\n', (FILE));\t\t\t\t\t\t\t\\\n+}\n+\n+"}]}