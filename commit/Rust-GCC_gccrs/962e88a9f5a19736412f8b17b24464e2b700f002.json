{"sha": "962e88a9f5a19736412f8b17b24464e2b700f002", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTYyZTg4YTlmNWExOTczNjQxMmY4YjE3YjI0NDY0ZTJiNzAwZjAwMg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2019-01-01T12:49:18Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2019-01-01T12:49:18Z"}, "message": "coverage.c (get_coverage_counts): Use current_function_decl.\n\n\n\t* coverage.c (get_coverage_counts): Use current_function_decl.\n\t* profile.c (read_thunk_profile): New function.\n\t(branch_prob): Add THUNK parameter.\n\t* tree-profile.c (tree_profiling): Handle thunks.\n\t* value-prof.c (init_node_map): Handle thunks.\n\t* value-prof.h (branch_prob): Upate prototype.\n\t(read_thunk_profile): Declare.\n\n\t* g++.dg/tree-prof/devirt.C: Update testcase.\n\nFrom-SVN: r267495", "tree": {"sha": "1f3f47a623168992283688de2d7a2a6b07341b11", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1f3f47a623168992283688de2d7a2a6b07341b11"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/962e88a9f5a19736412f8b17b24464e2b700f002", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/962e88a9f5a19736412f8b17b24464e2b700f002", "html_url": "https://github.com/Rust-GCC/gccrs/commit/962e88a9f5a19736412f8b17b24464e2b700f002", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/962e88a9f5a19736412f8b17b24464e2b700f002/comments", "author": null, "committer": null, "parents": [{"sha": "a5544970246db337977bb8b69ab120e9ef209317", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a5544970246db337977bb8b69ab120e9ef209317", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a5544970246db337977bb8b69ab120e9ef209317"}], "stats": {"total": 303, "additions": 191, "deletions": 112}, "files": [{"sha": "f7c7109a89fcc04b39c8aa055272ca1c5359922a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -1,3 +1,13 @@\n+2019-01-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* coverage.c (get_coverage_counts): Use current_function_decl.\n+\t* profile.c (read_thunk_profile): New function.\n+\t(branch_prob): Add THUNK parameter.\n+\t* tree-profile.c (tree_profiling): Handle thunks.\n+\t* value-prof.c (init_node_map): Handle thunks.\n+\t* value-prof.h (branch_prob): Upate prototype.\n+\t(read_thunk_profile): Declare.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "a34c5da49bfccf5b1f3187a8e5fa6cf238c5e341", "filename": "gcc/coverage.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fcoverage.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fcoverage.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoverage.c?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -329,7 +329,7 @@ get_coverage_counts (unsigned counter, unsigned cfg_checksum,\n   else\n     {\n       gcc_assert (coverage_node_map_initialized_p ());\n-      elt.ident = cgraph_node::get (cfun->decl)->profile_id;\n+      elt.ident = cgraph_node::get (current_function_decl)->profile_id;\n     }\n   elt.ctr = counter;\n   entry = counts_hash->find (&elt);"}, {"sha": "7374b0d6883cb349fad8584ffa5bafb3d68cb996", "filename": "gcc/profile.c", "status": "modified", "additions": 146, "deletions": 104, "changes": 250, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fprofile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fprofile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile.c?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -963,6 +963,25 @@ compare_freqs (const void *p1, const void *p2)\n   return e2->dest->index - e1->dest->index;\n }\n \n+/* Only read execution count for thunks.  */\n+\n+void\n+read_thunk_profile (struct cgraph_node *node)\n+{\n+  tree old = current_function_decl;\n+  current_function_decl = node->decl;\n+  gcov_type *counts = get_coverage_counts (GCOV_COUNTER_ARCS, 0, 0, 1);\n+  if (counts)\n+    {\n+      node->callees->count = node->count\n+\t = profile_count::from_gcov_type (counts[0]);\n+      free (counts);\n+    }\n+  current_function_decl = old;\n+  return;\n+}\n+\n+\n /* Instrument and/or analyze program behavior based on program the CFG.\n \n    This function creates a representation of the control flow graph (of\n@@ -983,7 +1002,7 @@ compare_freqs (const void *p1, const void *p2)\n    Main entry point of this file.  */\n \n void\n-branch_prob (void)\n+branch_prob (bool thunk)\n {\n   basic_block bb;\n   unsigned i;\n@@ -1000,118 +1019,121 @@ branch_prob (void)\n \n   hash_set <location_triplet_hash> streamed_locations;\n \n-  /* We can't handle cyclic regions constructed using abnormal edges.\n-     To avoid these we replace every source of abnormal edge by a fake\n-     edge from entry node and every destination by fake edge to exit.\n-     This keeps graph acyclic and our calculation exact for all normal\n-     edges except for exit and entrance ones.\n-\n-     We also add fake exit edges for each call and asm statement in the\n-     basic, since it may not return.  */\n-\n-  FOR_EACH_BB_FN (bb, cfun)\n+  if (!thunk)\n     {\n-      int need_exit_edge = 0, need_entry_edge = 0;\n-      int have_exit_edge = 0, have_entry_edge = 0;\n-      edge e;\n-      edge_iterator ei;\n+      /* We can't handle cyclic regions constructed using abnormal edges.\n+\t To avoid these we replace every source of abnormal edge by a fake\n+\t edge from entry node and every destination by fake edge to exit.\n+\t This keeps graph acyclic and our calculation exact for all normal\n+\t edges except for exit and entrance ones.\n \n-      /* Functions returning multiple times are not handled by extra edges.\n-         Instead we simply allow negative counts on edges from exit to the\n-         block past call and corresponding probabilities.  We can't go\n-         with the extra edges because that would result in flowgraph that\n-\t needs to have fake edges outside the spanning tree.  */\n+\t We also add fake exit edges for each call and asm statement in the\n+\t basic, since it may not return.  */\n \n-      FOR_EACH_EDGE (e, ei, bb->succs)\n+      FOR_EACH_BB_FN (bb, cfun)\n \t{\n-\t  gimple_stmt_iterator gsi;\n-\t  gimple *last = NULL;\n-\n-\t  /* It may happen that there are compiler generated statements\n-\t     without a locus at all.  Go through the basic block from the\n-\t     last to the first statement looking for a locus.  */\n-\t  for (gsi = gsi_last_nondebug_bb (bb);\n-\t       !gsi_end_p (gsi);\n-\t       gsi_prev_nondebug (&gsi))\n+\t  int need_exit_edge = 0, need_entry_edge = 0;\n+\t  int have_exit_edge = 0, have_entry_edge = 0;\n+\t  edge e;\n+\t  edge_iterator ei;\n+\n+\t  /* Functions returning multiple times are not handled by extra edges.\n+\t     Instead we simply allow negative counts on edges from exit to the\n+\t     block past call and corresponding probabilities.  We can't go\n+\t     with the extra edges because that would result in flowgraph that\n+\t     needs to have fake edges outside the spanning tree.  */\n+\n+\t  FOR_EACH_EDGE (e, ei, bb->succs)\n \t    {\n-\t      last = gsi_stmt (gsi);\n-\t      if (!RESERVED_LOCATION_P (gimple_location (last)))\n-\t\tbreak;\n-\t    }\n+\t      gimple_stmt_iterator gsi;\n+\t      gimple *last = NULL;\n+\n+\t      /* It may happen that there are compiler generated statements\n+\t\t without a locus at all.  Go through the basic block from the\n+\t\t last to the first statement looking for a locus.  */\n+\t      for (gsi = gsi_last_nondebug_bb (bb);\n+\t\t   !gsi_end_p (gsi);\n+\t\t   gsi_prev_nondebug (&gsi))\n+\t\t{\n+\t\t  last = gsi_stmt (gsi);\n+\t\t  if (!RESERVED_LOCATION_P (gimple_location (last)))\n+\t\t    break;\n+\t\t}\n \n-\t  /* Edge with goto locus might get wrong coverage info unless\n-\t     it is the only edge out of BB.\n-\t     Don't do that when the locuses match, so\n-\t     if (blah) goto something;\n-\t     is not computed twice.  */\n-\t  if (last\n-\t      && gimple_has_location (last)\n-\t      && !RESERVED_LOCATION_P (e->goto_locus)\n-\t      && !single_succ_p (bb)\n-\t      && (LOCATION_FILE (e->goto_locus)\n-\t          != LOCATION_FILE (gimple_location (last))\n-\t\t  || (LOCATION_LINE (e->goto_locus)\n-\t\t      != LOCATION_LINE (gimple_location (last)))))\n+\t      /* Edge with goto locus might get wrong coverage info unless\n+\t\t it is the only edge out of BB.\n+\t\t Don't do that when the locuses match, so\n+\t\t if (blah) goto something;\n+\t\t is not computed twice.  */\n+\t      if (last\n+\t\t  && gimple_has_location (last)\n+\t\t  && !RESERVED_LOCATION_P (e->goto_locus)\n+\t\t  && !single_succ_p (bb)\n+\t\t  && (LOCATION_FILE (e->goto_locus)\n+\t\t      != LOCATION_FILE (gimple_location (last))\n+\t\t      || (LOCATION_LINE (e->goto_locus)\n+\t\t\t  != LOCATION_LINE (gimple_location (last)))))\n+\t\t{\n+\t\t  basic_block new_bb = split_edge (e);\n+\t\t  edge ne = single_succ_edge (new_bb);\n+\t\t  ne->goto_locus = e->goto_locus;\n+\t\t}\n+\t      if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n+\t\t   && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\tneed_exit_edge = 1;\n+\t      if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n+\t\thave_exit_edge = 1;\n+\t    }\n+\t  FOR_EACH_EDGE (e, ei, bb->preds)\n \t    {\n-\t      basic_block new_bb = split_edge (e);\n-\t      edge ne = single_succ_edge (new_bb);\n-\t      ne->goto_locus = e->goto_locus;\n+\t      if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n+\t\t   && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t\tneed_entry_edge = 1;\n+\t      if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n+\t\thave_entry_edge = 1;\n \t    }\n-\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n-\t       && e->dest != EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t    need_exit_edge = 1;\n-\t  if (e->dest == EXIT_BLOCK_PTR_FOR_FN (cfun))\n-\t    have_exit_edge = 1;\n-\t}\n-      FOR_EACH_EDGE (e, ei, bb->preds)\n-\t{\n-\t  if ((e->flags & (EDGE_ABNORMAL | EDGE_ABNORMAL_CALL))\n-\t       && e->src != ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t    need_entry_edge = 1;\n-\t  if (e->src == ENTRY_BLOCK_PTR_FOR_FN (cfun))\n-\t    have_entry_edge = 1;\n-\t}\n \n-      if (need_exit_edge && !have_exit_edge)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Adding fake exit edge to bb %i\\n\",\n-\t\t     bb->index);\n-\t  make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n-\t}\n-      if (need_entry_edge && !have_entry_edge)\n-\t{\n-\t  if (dump_file)\n-\t    fprintf (dump_file, \"Adding fake entry edge to bb %i\\n\",\n-\t\t     bb->index);\n-\t  make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FAKE);\n-\t  /* Avoid bbs that have both fake entry edge and also some\n-\t     exit edge.  One of those edges wouldn't be added to the\n-\t     spanning tree, but we can't instrument any of them.  */\n-\t  if (have_exit_edge || need_exit_edge)\n+\t  if (need_exit_edge && !have_exit_edge)\n \t    {\n-\t      gimple_stmt_iterator gsi;\n-\t      gimple *first;\n-\n-\t      gsi = gsi_start_nondebug_after_labels_bb (bb);\n-\t      gcc_checking_assert (!gsi_end_p (gsi));\n-\t      first = gsi_stmt (gsi);\n-\t      /* Don't split the bbs containing __builtin_setjmp_receiver\n-\t\t or ABNORMAL_DISPATCHER calls.  These are very\n-\t\t special and don't expect anything to be inserted before\n-\t\t them.  */\n-\t      if (is_gimple_call (first)\n-\t\t  && (gimple_call_builtin_p (first, BUILT_IN_SETJMP_RECEIVER)\n-\t\t      || (gimple_call_flags (first) & ECF_RETURNS_TWICE)\n-\t\t      || (gimple_call_internal_p (first)\n-\t\t\t  && (gimple_call_internal_fn (first)\n-\t\t\t      == IFN_ABNORMAL_DISPATCHER))))\n-\t\tcontinue;\n-\n \t      if (dump_file)\n-\t\tfprintf (dump_file, \"Splitting bb %i after labels\\n\",\n+\t\tfprintf (dump_file, \"Adding fake exit edge to bb %i\\n\",\n \t\t\t bb->index);\n-\t      split_block_after_labels (bb);\n+\t      make_edge (bb, EXIT_BLOCK_PTR_FOR_FN (cfun), EDGE_FAKE);\n+\t    }\n+\t  if (need_entry_edge && !have_entry_edge)\n+\t    {\n+\t      if (dump_file)\n+\t\tfprintf (dump_file, \"Adding fake entry edge to bb %i\\n\",\n+\t\t\t bb->index);\n+\t      make_edge (ENTRY_BLOCK_PTR_FOR_FN (cfun), bb, EDGE_FAKE);\n+\t      /* Avoid bbs that have both fake entry edge and also some\n+\t\t exit edge.  One of those edges wouldn't be added to the\n+\t\t spanning tree, but we can't instrument any of them.  */\n+\t      if (have_exit_edge || need_exit_edge)\n+\t\t{\n+\t\t  gimple_stmt_iterator gsi;\n+\t\t  gimple *first;\n+\n+\t\t  gsi = gsi_start_nondebug_after_labels_bb (bb);\n+\t\t  gcc_checking_assert (!gsi_end_p (gsi));\n+\t\t  first = gsi_stmt (gsi);\n+\t\t  /* Don't split the bbs containing __builtin_setjmp_receiver\n+\t\t     or ABNORMAL_DISPATCHER calls.  These are very\n+\t\t     special and don't expect anything to be inserted before\n+\t\t     them.  */\n+\t\t  if (is_gimple_call (first)\n+\t\t      && (gimple_call_builtin_p (first, BUILT_IN_SETJMP_RECEIVER)\n+\t\t\t  || (gimple_call_flags (first) & ECF_RETURNS_TWICE)\n+\t\t\t  || (gimple_call_internal_p (first)\n+\t\t\t      && (gimple_call_internal_fn (first)\n+\t\t\t\t  == IFN_ABNORMAL_DISPATCHER))))\n+\t\t    continue;\n+\n+\t\t  if (dump_file)\n+\t\t    fprintf (dump_file, \"Splitting bb %i after labels\\n\",\n+\t\t\t     bb->index);\n+\t\t  split_block_after_labels (bb);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -1143,7 +1165,18 @@ branch_prob (void)\n      on the spanning tree.  We insert as many abnormal and critical edges\n      as possible to minimize number of edge splits necessary.  */\n \n-  find_spanning_tree (el);\n+  if (!thunk)\n+    find_spanning_tree (el);\n+  else\n+    {\n+      edge e;\n+      edge_iterator ei;\n+      /* Keep only edge from entry block to be instrumented.  */\n+      FOR_EACH_BB_FN (bb, cfun)\n+\tFOR_EACH_EDGE (e, ei, bb->succs)\n+\t  EDGE_INFO (e)->ignore = true;\n+    }\n+\n \n   /* Fake edges that are not on the tree will not be instrumented, so\n      mark them ignored.  */\n@@ -1183,8 +1216,17 @@ branch_prob (void)\n      the checksum in only once place, since it depends on the shape\n      of the control flow which can change during \n      various transformations.  */\n-  cfg_checksum = coverage_compute_cfg_checksum (cfun);\n-  lineno_checksum = coverage_compute_lineno_checksum ();\n+  if (thunk)\n+    {\n+      /* At stream in time we do not have CFG, so we can not do checksums.  */\n+      cfg_checksum = 0;\n+      lineno_checksum = 0;\n+    }\n+  else\n+    {\n+      cfg_checksum = coverage_compute_cfg_checksum (cfun);\n+      lineno_checksum = coverage_compute_lineno_checksum ();\n+    }\n \n   /* Write the data from which gcov can reconstruct the basic block\n      graph and function line numbers (the gcno file).  */"}, {"sha": "0f75fffb2f86f0e99725f0745f99be5d9973b640", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -1,3 +1,7 @@\n+2019-01-01  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\t* g++.dg/tree-prof/devirt.C: Update testcase.\n+\n 2019-01-01  Jakub Jelinek  <jakub@redhat.com>\n \n \tUpdate copyright years."}, {"sha": "7d6797dd22694cd5ca92f4e6f389f509a83d6e37", "filename": "gcc/testsuite/g++.dg/tree-prof/devirt.C", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fdevirt.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fdevirt.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-prof%2Fdevirt.C?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -119,5 +119,5 @@ main ()\n     __builtin_abort ();\n }\n \n-/* { dg-final-use-not-autofdo { scan-tree-dump-times \"folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16\" 3 \"dom3\" } } */\n-/* { dg-final-use-not-autofdo { scan-tree-dump-times \"folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef\" 3 \"dom3\" } } */\n+/* { dg-final-use-not-autofdo { scan-tree-dump-times \"folding virtual function call to virtual unsigned int mozPersonalDictionary::_ZThn16\" 1 \"dom3\" } } */\n+/* { dg-final-use-not-autofdo { scan-tree-dump-times \"folding virtual function call to virtual unsigned int mozPersonalDictionary::AddRef\" 1 \"dom3\" } } */"}, {"sha": "30fadde86cf00ab4414234ae88a71bd735e7f5ea", "filename": "gcc/tree-profile.c", "status": "modified", "additions": 25, "deletions": 3, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftree-profile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Ftree-profile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-profile.c?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -739,7 +739,8 @@ tree_profiling (void)\n \n   FOR_EACH_DEFINED_FUNCTION (node)\n     {\n-      if (!gimple_has_body_p (node->decl))\n+      bool thunk = false;\n+      if (!gimple_has_body_p (node->decl) && !node->thunk.thunk_p)\n \tcontinue;\n \n       /* Don't profile functions produced for builtin stuff.  */\n@@ -760,22 +761,43 @@ tree_profiling (void)\n       if (!include_source_file_for_profile (file))\n \tcontinue;\n \n+      if (node->thunk.thunk_p)\n+\t{\n+\t  /* We can not expand variadic thunks to Gimple.  */\n+\t  if (stdarg_p (TREE_TYPE (node->decl)))\n+\t    continue;\n+\t  thunk = true;\n+\t  /* When generate profile, expand thunk to gimple so it can be\n+\t     instrumented same way as other functions.  */\n+\t  if (profile_arc_flag)\n+\t    node->expand_thunk (false, true);\n+\t  /* Read cgraph profile but keep function as thunk at profile-use\n+\t     time.  */\n+\t  else\n+\t    {\n+\t      read_thunk_profile (node);\n+\t      continue;\n+\t    }\n+\t}\n+\n       push_cfun (DECL_STRUCT_FUNCTION (node->decl));\n \n       if (dump_file)\n \tdump_function_header (dump_file, cfun->decl, dump_flags);\n \n       /* Local pure-const may imply need to fixup the cfg.  */\n-      if (execute_fixup_cfg () & TODO_cleanup_cfg)\n+      if (gimple_has_body_p (node->decl)\n+\t  && (execute_fixup_cfg () & TODO_cleanup_cfg))\n \tcleanup_tree_cfg ();\n \n-      branch_prob ();\n+      branch_prob (thunk);\n \n       if (! flag_branch_probabilities\n \t  && flag_profile_values)\n \tgimple_gen_ic_func_profiler ();\n \n       if (flag_branch_probabilities\n+\t  && !thunk\n \t  && flag_profile_values\n \t  && flag_value_profile_transformations)\n \tgimple_value_profile_transformations ();"}, {"sha": "5013956cf86f8ce5920f2646baf5883d12762584", "filename": "gcc/value-prof.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fvalue-prof.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fvalue-prof.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.c?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -1188,7 +1188,7 @@ init_node_map (bool local)\n   cgraph_node_map = new hash_map<profile_id_hash, cgraph_node *>;\n \n   FOR_EACH_DEFINED_FUNCTION (n)\n-    if (n->has_gimple_body_p ())\n+    if (n->has_gimple_body_p () || n->thunk.thunk_p)\n       {\n \tcgraph_node **val;\n \tif (local)"}, {"sha": "1251fa95e317c3df5689fc43706d06f2c34070d1", "filename": "gcc/value-prof.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fvalue-prof.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/962e88a9f5a19736412f8b17b24464e2b700f002/gcc%2Fvalue-prof.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvalue-prof.h?ref=962e88a9f5a19736412f8b17b24464e2b700f002", "patch": "@@ -112,7 +112,8 @@ extern struct cgraph_node* find_func_by_profile_id (int func_id);\n \n /* In profile.c.  */\n extern void init_branch_prob (void);\n-extern void branch_prob (void);\n+extern void branch_prob (bool);\n+extern void read_thunk_profile (struct cgraph_node *);\n extern void end_branch_prob (void);\n \n #endif\t/* GCC_VALUE_PROF_H */"}]}