{"sha": "6e55eda727cb9635c57de146ba53d35044c85589", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmU1NWVkYTcyN2NiOTYzNWM1N2RlMTQ2YmE1M2QzNTA0NGM4NTU4OQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2013-03-18T13:58:29Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2013-03-18T13:58:29Z"}, "message": "tree-ssa-structalias.c (find): Use gcc_checking_assert.\n\n2013-03-18  Richard Biener  <rguenther@suse.de>\n\n\t* tree-ssa-structalias.c (find): Use gcc_checking_assert.\n\t(unite): Likewise.\n\t(merge_node_constraints): Likewise.\n\t(build_succ_graph): Likewise.\n\t(valid_graph_edge): Inline into single caller.\n\t(unify_nodes): Likewise.  Use bitmap_set_bit return value\n\tand cache varinfo.\n\t(scc_visit): Fix formatting and variable use.\n\t(do_sd_constraint): Use gcc_checking_assert.\n\t(do_ds_constraint): Likewise.\n\t(do_complex_constraint): Likewise.\n\t(condense_visit): Likewise.  Cleanup.\n\t(dump_pred_graph): New function.\n\t(perform_var_substitution): Dump the pred-graph before\n\tvariable substitution.\n\t(find_equivalent_node): Use gcc_checking_assert.\n\t(rewrite_constraints): Guard checking loop with ENABLE_CHECKING.\n\nFrom-SVN: r196783", "tree": {"sha": "3f37789458935ec2ada8327c6aaafd860570c530", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3f37789458935ec2ada8327c6aaafd860570c530"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6e55eda727cb9635c57de146ba53d35044c85589", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e55eda727cb9635c57de146ba53d35044c85589", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e55eda727cb9635c57de146ba53d35044c85589", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e55eda727cb9635c57de146ba53d35044c85589/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4bdd44c4bc5ec2f3655e47cc56a3ade55fed2d26"}], "stats": {"total": 199, "additions": 136, "deletions": 63}, "files": [{"sha": "24b6b93c96f01e9d72a6ffc3a7ff34b4617481ed", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e55eda727cb9635c57de146ba53d35044c85589/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e55eda727cb9635c57de146ba53d35044c85589/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6e55eda727cb9635c57de146ba53d35044c85589", "patch": "@@ -1,3 +1,23 @@\n+2013-03-18  Richard Biener  <rguenther@suse.de>\n+\n+\t* tree-ssa-structalias.c (find): Use gcc_checking_assert.\n+\t(unite): Likewise.\n+\t(merge_node_constraints): Likewise.\n+\t(build_succ_graph): Likewise.\n+\t(valid_graph_edge): Inline into single caller.\n+\t(unify_nodes): Likewise.  Use bitmap_set_bit return value\n+\tand cache varinfo.\n+\t(scc_visit): Fix formatting and variable use.\n+\t(do_sd_constraint): Use gcc_checking_assert.\n+\t(do_ds_constraint): Likewise.\n+\t(do_complex_constraint): Likewise.\n+\t(condense_visit): Likewise.  Cleanup.\n+\t(dump_pred_graph): New function.\n+\t(perform_var_substitution): Dump the pred-graph before\n+\tvariable substitution.\n+\t(find_equivalent_node): Use gcc_checking_assert.\n+\t(rewrite_constraints): Guard checking loop with ENABLE_CHECKING.\n+\n 2013-03-18  Richard Biener  <rguenther@suse.de>\n \n \t* tree-vect-loop-manip.c (vect_create_cond_for_alias_checks):"}, {"sha": "6bcd4b50f8f6284eb5acc61388cd4da5aed0abad", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 116, "deletions": 63, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6e55eda727cb9635c57de146ba53d35044c85589/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6e55eda727cb9635c57de146ba53d35044c85589/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=6e55eda727cb9635c57de146ba53d35044c85589", "patch": "@@ -581,7 +581,7 @@ static constraint_graph_t graph;\n static unsigned int\n find (unsigned int node)\n {\n-  gcc_assert (node < graph->size);\n+  gcc_checking_assert (node < graph->size);\n   if (graph->rep[node] != node)\n     return graph->rep[node] = find (graph->rep[node]);\n   return node;\n@@ -595,7 +595,7 @@ find (unsigned int node)\n static bool\n unite (unsigned int to, unsigned int from)\n {\n-  gcc_assert (to < graph->size && from < graph->size);\n+  gcc_checking_assert (to < graph->size && from < graph->size);\n   if (to != from && graph->rep[from] != to)\n     {\n       graph->rep[from] = to;\n@@ -1023,7 +1023,7 @@ merge_node_constraints (constraint_graph_t graph, unsigned int to,\n   unsigned int i;\n   constraint_t c;\n \n-  gcc_assert (find (from) == to);\n+  gcc_checking_assert (find (from) == to);\n \n   /* Move all complex constraints from src node into to node  */\n   FOR_EACH_VEC_ELT (graph->complex[from], i, c)\n@@ -1143,16 +1143,6 @@ add_graph_edge (constraint_graph_t graph, unsigned int to,\n }\n \n \n-/* Return true if {DEST.SRC} is an existing graph edge in GRAPH.  */\n-\n-static bool\n-valid_graph_edge (constraint_graph_t graph, unsigned int src,\n-\t\t  unsigned int dest)\n-{\n-  return (graph->succs[dest]\n-\t  && bitmap_bit_p (graph->succs[dest], src));\n-}\n-\n /* Initialize the constraint graph structure to contain SIZE nodes.  */\n \n static void\n@@ -1319,7 +1309,7 @@ build_succ_graph (void)\n       else if (rhs.type == ADDRESSOF)\n \t{\n \t  /* x = &y */\n-\t  gcc_assert (find (rhs.var) == rhs.var);\n+\t  gcc_checking_assert (find (rhs.var) == rhs.var);\n \t  bitmap_set_bit (get_varinfo (lhsvar)->solution, rhsvar);\n \t}\n       else if (lhsvar > anything_id\n@@ -1396,14 +1386,11 @@ scc_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n       if (!bitmap_bit_p (si->visited, w))\n \tscc_visit (graph, si, w);\n-      {\n-\tunsigned int t = find (w);\n-\tunsigned int nnode = find (n);\n-\tgcc_assert (nnode == n);\n \n-\tif (si->dfs[t] < si->dfs[nnode])\n-\t  si->dfs[n] = si->dfs[t];\n-      }\n+      unsigned int t = find (w);\n+      gcc_checking_assert (find (n) == n);\n+      if (si->dfs[t] < si->dfs[n])\n+\tsi->dfs[n] = si->dfs[t];\n     }\n \n   /* See if any components have been identified.  */\n@@ -1458,8 +1445,8 @@ static void\n unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n \t     bool update_changed)\n {\n+  gcc_checking_assert (to != from && find (to) == to);\n \n-  gcc_assert (to != from && find (to) == to);\n   if (dump_file && (dump_flags & TDF_DETAILS))\n     fprintf (dump_file, \"Unifying %s to %s\\n\",\n \t     get_varinfo (from)->name,\n@@ -1477,35 +1464,30 @@ unify_nodes (constraint_graph_t graph, unsigned int to, unsigned int from,\n      as changed, decrease the changed count.  */\n \n   if (update_changed\n-      && bitmap_bit_p (changed, from))\n-    {\n-      bitmap_clear_bit (changed, from);\n-      bitmap_set_bit (changed, to);\n-    }\n-  if (get_varinfo (from)->solution)\n+      && bitmap_clear_bit (changed, from))\n+    bitmap_set_bit (changed, to);\n+  varinfo_t fromvi = get_varinfo (from);\n+  if (fromvi->solution)\n     {\n       /* If the solution changes because of the merging, we need to mark\n \t the variable as changed.  */\n-      if (bitmap_ior_into (get_varinfo (to)->solution,\n-\t\t\t   get_varinfo (from)->solution))\n+      varinfo_t tovi = get_varinfo (to);\n+      if (bitmap_ior_into (tovi->solution, fromvi->solution))\n \t{\n \t  if (update_changed)\n \t    bitmap_set_bit (changed, to);\n \t}\n \n-      BITMAP_FREE (get_varinfo (from)->solution);\n-      if (get_varinfo (from)->oldsolution)\n-\tBITMAP_FREE (get_varinfo (from)->oldsolution);\n+      BITMAP_FREE (fromvi->solution);\n+      if (fromvi->oldsolution)\n+\tBITMAP_FREE (fromvi->oldsolution);\n \n       if (stats.iterations > 0\n-\t  && get_varinfo (to)->oldsolution)\n-\tBITMAP_FREE (get_varinfo (to)->oldsolution);\n-    }\n-  if (valid_graph_edge (graph, to, to))\n-    {\n-      if (graph->succs[to])\n-\tbitmap_clear_bit (graph->succs[to], to);\n+\t  && tovi->oldsolution)\n+\tBITMAP_FREE (tovi->oldsolution);\n     }\n+  if (graph->succs[to])\n+    bitmap_clear_bit (graph->succs[to], to);\n }\n \n /* Information needed to compute the topological ordering of a graph.  */\n@@ -1581,7 +1563,7 @@ do_sd_constraint (constraint_graph_t graph, constraint_t c,\n   HOST_WIDE_INT roffset = c->rhs.offset;\n \n   /* Our IL does not allow this.  */\n-  gcc_assert (c->lhs.offset == 0);\n+  gcc_checking_assert (c->lhs.offset == 0);\n \n   /* If the solution of Y contains anything it is good enough to transfer\n      this to the LHS.  */\n@@ -1668,7 +1650,7 @@ do_ds_constraint (constraint_t c, bitmap delta)\n   bool escaped_p = false;\n \n   /* Our IL does not allow this.  */\n-  gcc_assert (c->rhs.offset == 0);\n+  gcc_checking_assert (c->rhs.offset == 0);\n \n   /* If the solution of y contains ANYTHING simply use the ANYTHING\n      solution.  This avoids needlessly increasing the points-to sets.  */\n@@ -1782,7 +1764,7 @@ do_complex_constraint (constraint_graph_t graph, constraint_t c, bitmap delta)\n       bitmap solution;\n       bool flag = false;\n \n-      gcc_assert (c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n+      gcc_checking_assert (c->rhs.type == SCALAR && c->lhs.type == SCALAR);\n       solution = get_varinfo (c->rhs.var)->solution;\n       tmp = get_varinfo (c->lhs.var)->solution;\n \n@@ -1992,7 +1974,7 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n   bitmap_iterator bi;\n   unsigned int my_dfs;\n \n-  gcc_assert (si->node_mapping[n] == n);\n+  gcc_checking_assert (si->node_mapping[n] == n);\n   bitmap_set_bit (si->visited, n);\n   si->dfs[n] = si->current_index ++;\n   my_dfs = si->dfs[n];\n@@ -2007,14 +1989,11 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n       if (!bitmap_bit_p (si->visited, w))\n \tcondense_visit (graph, si, w);\n-      {\n-\tunsigned int t = si->node_mapping[w];\n-\tunsigned int nnode = si->node_mapping[n];\n-\tgcc_assert (nnode == n);\n \n-\tif (si->dfs[t] < si->dfs[nnode])\n-\t  si->dfs[n] = si->dfs[t];\n-      }\n+      unsigned int t = si->node_mapping[w];\n+      gcc_checking_assert (si->node_mapping[n] == n);\n+      if (si->dfs[t] < si->dfs[n])\n+\tsi->dfs[n] = si->dfs[t];\n     }\n \n   /* Visit all the implicit predecessors.  */\n@@ -2027,14 +2006,11 @@ condense_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n \n       if (!bitmap_bit_p (si->visited, w))\n \tcondense_visit (graph, si, w);\n-      {\n-\tunsigned int t = si->node_mapping[w];\n-\tunsigned int nnode = si->node_mapping[n];\n-\tgcc_assert (nnode == n);\n \n-\tif (si->dfs[t] < si->dfs[nnode])\n-\t  si->dfs[n] = si->dfs[t];\n-      }\n+      unsigned int t = si->node_mapping[w];\n+      gcc_assert (si->node_mapping[n] == n);\n+      if (si->dfs[t] < si->dfs[n])\n+\tsi->dfs[n] = si->dfs[t];\n     }\n \n   /* See if any components have been identified.  */\n@@ -2164,6 +2140,75 @@ label_visit (constraint_graph_t graph, struct scc_info *si, unsigned int n)\n     }\n }\n \n+/* Print the pred graph in dot format.  */\n+\n+static void\n+dump_pred_graph (struct scc_info *si, FILE *file)\n+{\n+  unsigned int i;\n+\n+  /* Only print the graph if it has already been initialized:  */\n+  if (!graph)\n+    return;\n+\n+  /* Prints the header of the dot file:  */\n+  fprintf (file, \"strict digraph {\\n\");\n+  fprintf (file, \"  node [\\n    shape = box\\n  ]\\n\");\n+  fprintf (file, \"  edge [\\n    fontsize = \\\"12\\\"\\n  ]\\n\");\n+  fprintf (file, \"\\n  // List of nodes and complex constraints in \"\n+\t   \"the constraint graph:\\n\");\n+\n+  /* The next lines print the nodes in the graph together with the\n+     complex constraints attached to them.  */\n+  for (i = 0; i < graph->size; i++)\n+    {\n+      if (si->node_mapping[i] != i)\n+\tcontinue;\n+      if (i < FIRST_REF_NODE)\n+\tfprintf (file, \"\\\"%s\\\"\", get_varinfo (i)->name);\n+      else\n+\tfprintf (file, \"\\\"*%s\\\"\", get_varinfo (i - FIRST_REF_NODE)->name);\n+      if (graph->points_to[i]\n+\t  && !bitmap_empty_p (graph->points_to[i]))\n+\t{\n+\t  fprintf (file, \"[label=\\\"%s = {\", get_varinfo (i)->name);\n+\t  unsigned j;\n+\t  bitmap_iterator bi;\n+\t  EXECUTE_IF_SET_IN_BITMAP (graph->points_to[i], 0, j, bi)\n+\t    fprintf (file, \" %d\", j);\n+\t  fprintf (file, \" }\\\"]\");\n+\t}\n+      fprintf (file, \";\\n\");\n+    }\n+\n+  /* Go over the edges.  */\n+  fprintf (file, \"\\n  // Edges in the constraint graph:\\n\");\n+  for (i = 0; i < graph->size; i++)\n+    {\n+      unsigned j;\n+      bitmap_iterator bi;\n+      if (si->node_mapping[i] != i)\n+\tcontinue;\n+      EXECUTE_IF_IN_NONNULL_BITMAP (graph->preds[i], 0, j, bi)\n+\t{\n+\t  unsigned from = si->node_mapping[j];\n+\t  if (from < FIRST_REF_NODE)\n+\t    fprintf (file, \"\\\"%s\\\"\", get_varinfo (from)->name);\n+\t  else\n+\t    fprintf (file, \"\\\"*%s\\\"\", get_varinfo (from - FIRST_REF_NODE)->name);\n+\t  fprintf (file, \" -> \");\n+\t  if (i < FIRST_REF_NODE)\n+\t    fprintf (file, \"\\\"%s\\\"\", get_varinfo (i)->name);\n+\t  else\n+\t    fprintf (file, \"\\\"*%s\\\"\", get_varinfo (i - FIRST_REF_NODE)->name);\n+\t  fprintf (file, \";\\n\");\n+\t}\n+    }\n+\n+  /* Prints the tail of the dot file.  */\n+  fprintf (file, \"}\\n\");\n+}\n+\n /* Perform offline variable substitution, discovering equivalence\n    classes, and eliminating non-pointer variables.  */\n \n@@ -2188,6 +2233,14 @@ perform_var_substitution (constraint_graph_t graph)\n     if (!bitmap_bit_p (si->visited, si->node_mapping[i]))\n       condense_visit (graph, si, si->node_mapping[i]);\n \n+  if (dump_file && (dump_flags & TDF_GRAPH))\n+    {\n+      fprintf (dump_file, \"\\n\\n// The constraint graph before var-substitution \"\n+\t       \"in dot format:\\n\");\n+      dump_pred_graph (si, dump_file);\n+      fprintf (dump_file, \"\\n\\n\");\n+    }\n+\n   bitmap_clear (si->visited);\n   /* Actually the label the nodes for pointer equivalences  */\n   for (i = 0; i < FIRST_REF_NODE; i++)\n@@ -2303,7 +2356,7 @@ find_equivalent_node (constraint_graph_t graph,\n \n   if (!bitmap_bit_p (graph->address_taken, node))\n     {\n-      gcc_assert (label < graph->size);\n+      gcc_checking_assert (label < graph->size);\n \n       if (graph->eq_rep[label] != -1)\n \t{\n@@ -2320,7 +2373,7 @@ find_equivalent_node (constraint_graph_t graph,\n     }\n   else\n     {\n-      gcc_assert (label < graph->size);\n+      gcc_checking_assert (label < graph->size);\n       graph->pe[node] = label;\n       if (graph->pe_rep[label] == -1)\n \tgraph->pe_rep[label] = node;\n@@ -2400,11 +2453,12 @@ rewrite_constraints (constraint_graph_t graph,\n \t\t     struct scc_info *si)\n {\n   int i;\n-  unsigned int j;\n   constraint_t c;\n \n-  for (j = 0; j < graph->size; j++)\n+#ifdef ENABLE_CHECKING\n+  for (unsigned int j = 0; j < graph->size; j++)\n     gcc_assert (find (j) == j);\n+#endif\n \n   FOR_EACH_VEC_ELT (constraints, i, c)\n     {\n@@ -2456,7 +2510,6 @@ rewrite_constraints (constraint_graph_t graph,\n       rhsvar = find_equivalent_node (graph, rhsvar, rhslabel);\n       c->lhs.var = lhsvar;\n       c->rhs.var = rhsvar;\n-\n     }\n }\n "}]}