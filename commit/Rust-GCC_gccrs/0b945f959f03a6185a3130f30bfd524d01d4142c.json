{"sha": "0b945f959f03a6185a3130f30bfd524d01d4142c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI5NDVmOTU5ZjAzYTYxODVhMzEzMGYzMGJmZDUyNGQwMWQ0MTQyYw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-01T08:44:27Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2020-10-02T09:22:20Z"}, "message": "make use of CALL_FROM_NEW_OR_DELETE_P\n\nThis fixes points-to analysis and DCE to only consider new/delete\noperator calls from new or delete expressions and not direct calls.\n\n2020-10-01  Richard Biener  <rguenther@suse.de>\n\n\t* gimple.h (GF_CALL_FROM_NEW_OR_DELETE): New call flag.\n\t(gimple_call_set_from_new_or_delete): New.\n\t(gimple_call_from_new_or_delete): Likewise.\n\t* gimple.c (gimple_build_call_from_tree): Set\n\tGF_CALL_FROM_NEW_OR_DELETE appropriately.\n\t* ipa-icf-gimple.c (func_checker::compare_gimple_call):\n\tCompare gimple_call_from_new_or_delete.\n\t* tree-ssa-dce.c (mark_all_reaching_defs_necessary_1): Make\n\tsure to only consider new/delete calls from new or delete\n\texpressions.\n\t(propagate_necessity): Likewise.\n\t(eliminate_unnecessary_stmts): Likewise.\n\t* tree-ssa-structalias.c (find_func_aliases_for_call):\n\tLikewise.\n\n\t* g++.dg/tree-ssa/pta-delete-1.C: New testcase.", "tree": {"sha": "c61ced9467e75d017f2ef2df083b466f5b345aeb", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c61ced9467e75d017f2ef2df083b466f5b345aeb"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b945f959f03a6185a3130f30bfd524d01d4142c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b945f959f03a6185a3130f30bfd524d01d4142c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b945f959f03a6185a3130f30bfd524d01d4142c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b945f959f03a6185a3130f30bfd524d01d4142c/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b6158faacbfb7d24a1d25b3774bc4338dd849480", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b6158faacbfb7d24a1d25b3774bc4338dd849480", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b6158faacbfb7d24a1d25b3774bc4338dd849480"}], "stats": {"total": 92, "additions": 78, "deletions": 14}, "files": [{"sha": "f07ddab79531a8747f056798af2fe811cf278f19", "filename": "gcc/gimple.c", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -387,6 +387,10 @@ gimple_build_call_from_tree (tree t, tree fnptrtype)\n       && fndecl_built_in_p (fndecl, BUILT_IN_NORMAL)\n       && ALLOCA_FUNCTION_CODE_P (DECL_FUNCTION_CODE (fndecl)))\n     gimple_call_set_alloca_for_var (call, CALL_ALLOCA_FOR_VAR_P (t));\n+  else if (fndecl\n+\t   && (DECL_IS_OPERATOR_NEW_P (fndecl)\n+\t       || DECL_IS_OPERATOR_DELETE_P (fndecl)))\n+    gimple_call_set_from_new_or_delete (call, CALL_FROM_NEW_OR_DELETE_P (t));\n   else\n     gimple_call_set_from_thunk (call, CALL_FROM_THUNK_P (t));\n   gimple_call_set_va_arg_pack (call, CALL_EXPR_VA_ARG_PACK (t));"}, {"sha": "108ae84684929adf4ff8c33fc7a11af838668330", "filename": "gcc/gimple.h", "status": "modified", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fgimple.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fgimple.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.h?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -149,6 +149,7 @@ enum gf_mask {\n     GF_CALL_MUST_TAIL_CALL\t= 1 << 9,\n     GF_CALL_BY_DESCRIPTOR\t= 1 << 10,\n     GF_CALL_NOCF_CHECK\t\t= 1 << 11,\n+    GF_CALL_FROM_NEW_OR_DELETE\t= 1 << 12,\n     GF_OMP_PARALLEL_COMBINED\t= 1 << 0,\n     GF_OMP_TASK_TASKLOOP\t= 1 << 0,\n     GF_OMP_TASK_TASKWAIT\t= 1 << 1,\n@@ -3387,6 +3388,29 @@ gimple_call_from_thunk_p (gcall *s)\n }\n \n \n+/* If FROM_NEW_OR_DELETE_P is true, mark GIMPLE_CALL S as being a call\n+   to operator new or delete created from a new or delete expression.  */\n+\n+static inline void\n+gimple_call_set_from_new_or_delete (gcall *s, bool from_new_or_delete_p)\n+{\n+  if (from_new_or_delete_p)\n+    s->subcode |= GF_CALL_FROM_NEW_OR_DELETE;\n+  else\n+    s->subcode &= ~GF_CALL_FROM_NEW_OR_DELETE;\n+}\n+\n+\n+/* Return true if GIMPLE_CALL S is a call to operator new or delete from\n+   from a new or delete expression.  */\n+\n+static inline bool\n+gimple_call_from_new_or_delete (gcall *s)\n+{\n+  return (s->subcode & GF_CALL_FROM_NEW_OR_DELETE) != 0;\n+}\n+\n+\n /* If PASS_ARG_PACK_P is true, GIMPLE_CALL S is a stdarg call that needs the\n    argument pack in its argument list.  */\n "}, {"sha": "d5423a7e9b21afe5b0b5f70c145772bd6a52bc17", "filename": "gcc/ipa-icf-gimple.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fipa-icf-gimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Fipa-icf-gimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-icf-gimple.c?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -556,6 +556,7 @@ func_checker::compare_gimple_call (gcall *s1, gcall *s2)\n       || gimple_call_tail_p (s1) != gimple_call_tail_p (s2)\n       || gimple_call_return_slot_opt_p (s1) != gimple_call_return_slot_opt_p (s2)\n       || gimple_call_from_thunk_p (s1) != gimple_call_from_thunk_p (s2)\n+      || gimple_call_from_new_or_delete (s1) != gimple_call_from_new_or_delete (s2)\n       || gimple_call_va_arg_pack_p (s1) != gimple_call_va_arg_pack_p (s2)\n       || gimple_call_alloca_for_var_p (s1) != gimple_call_alloca_for_var_p (s2))\n     return false;"}, {"sha": "5e1e322344af89573d1a90c60bdca4d74a1bb50a", "filename": "gcc/testsuite/g++.dg/tree-ssa/pta-delete-1.C", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpta-delete-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpta-delete-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftree-ssa%2Fpta-delete-1.C?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -0,0 +1,24 @@\n+// { dg-do run }\n+// { dg-options \"-O2\" }\n+\n+struct X {\n+  static struct X saved;\n+  int *p;\n+  X() { __builtin_memcpy (this, &saved, sizeof (X)); }\n+};\n+X X::saved;\n+void __attribute__((noinline)) operator delete (void *p)\n+{\n+  __builtin_memcpy (&X::saved, p, sizeof (X));\n+}\n+int main()\n+{\n+  int y = 1;\n+  X *p = new X;\n+  p->p = &y;\n+  ::operator delete (p);\n+  X *q = new X;\n+  *(q->p) = 2;\n+  if (y != 2)\n+    __builtin_abort ();\n+}"}, {"sha": "c9e0c8fd116602045f5bfa14fa0323de97f9ba1b", "filename": "gcc/tree-ssa-dce.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftree-ssa-dce.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftree-ssa-dce.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dce.c?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -593,9 +593,9 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \n   /* We want to skip statments that do not constitute stores but have\n      a virtual definition.  */\n-  if (is_gimple_call (def_stmt))\n+  if (gcall *call = dyn_cast <gcall *> (def_stmt))\n     {\n-      tree callee = gimple_call_fndecl (def_stmt);\n+      tree callee = gimple_call_fndecl (call);\n       if (callee != NULL_TREE\n \t  && fndecl_built_in_p (callee, BUILT_IN_NORMAL))\n \tswitch (DECL_FUNCTION_CODE (callee))\n@@ -612,7 +612,8 @@ mark_all_reaching_defs_necessary_1 (ao_ref *ref ATTRIBUTE_UNUSED,\n \n       if (callee != NULL_TREE\n \t  && (DECL_IS_REPLACEABLE_OPERATOR_NEW_P (callee)\n-\t      || DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (callee)))\n+\t      || DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (callee))\n+\t  && gimple_call_from_new_or_delete (call))\n \treturn false;\n     }\n \n@@ -875,23 +876,25 @@ propagate_necessity (bool aggressive)\n \t     processing the argument.  */\n \t  bool is_delete_operator\n \t    = (is_gimple_call (stmt)\n+\t       && gimple_call_from_new_or_delete (as_a <gcall *> (stmt))\n \t       && gimple_call_replaceable_operator_delete_p (as_a <gcall *> (stmt)));\n \t  if (is_delete_operator\n \t      || gimple_call_builtin_p (stmt, BUILT_IN_FREE))\n \t    {\n \t      tree ptr = gimple_call_arg (stmt, 0);\n-\t      gimple *def_stmt;\n+\t      gcall *def_stmt;\n \t      tree def_callee;\n \t      /* If the pointer we free is defined by an allocation\n \t\t function do not add the call to the worklist.  */\n \t      if (TREE_CODE (ptr) == SSA_NAME\n-\t\t  && is_gimple_call (def_stmt = SSA_NAME_DEF_STMT (ptr))\n+\t\t  && (def_stmt = dyn_cast <gcall *> (SSA_NAME_DEF_STMT (ptr)))\n \t\t  && (def_callee = gimple_call_fndecl (def_stmt))\n \t\t  && ((DECL_BUILT_IN_CLASS (def_callee) == BUILT_IN_NORMAL\n \t\t       && (DECL_FUNCTION_CODE (def_callee) == BUILT_IN_ALIGNED_ALLOC\n \t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_MALLOC\n \t\t\t   || DECL_FUNCTION_CODE (def_callee) == BUILT_IN_CALLOC))\n-\t\t      || DECL_IS_REPLACEABLE_OPERATOR_NEW_P (def_callee)))\n+\t\t      || (DECL_IS_REPLACEABLE_OPERATOR_NEW_P (def_callee)\n+\t\t\t  && gimple_call_from_new_or_delete (def_stmt))))\n \t\t{\n \t\t  if (is_delete_operator)\n \t\t    {\n@@ -947,9 +950,9 @@ propagate_necessity (bool aggressive)\n \t     in 1).  By keeping a global visited bitmap for references\n \t     we walk for 2) we avoid quadratic behavior for those.  */\n \n-\t  if (is_gimple_call (stmt))\n+\t  if (gcall *call = dyn_cast <gcall *> (stmt))\n \t    {\n-\t      tree callee = gimple_call_fndecl (stmt);\n+\t      tree callee = gimple_call_fndecl (call);\n \t      unsigned i;\n \n \t      /* Calls to functions that are merely acting as barriers\n@@ -972,22 +975,23 @@ propagate_necessity (bool aggressive)\n \n \t      if (callee != NULL_TREE\n \t\t  && (DECL_IS_REPLACEABLE_OPERATOR_NEW_P (callee)\n-\t\t      || DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (callee)))\n+\t\t      || DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (callee))\n+\t\t  && gimple_call_from_new_or_delete (call))\n \t\tcontinue;\n \n \t      /* Calls implicitly load from memory, their arguments\n \t         in addition may explicitly perform memory loads.  */\n-\t      mark_all_reaching_defs_necessary (stmt);\n-\t      for (i = 0; i < gimple_call_num_args (stmt); ++i)\n+\t      mark_all_reaching_defs_necessary (call);\n+\t      for (i = 0; i < gimple_call_num_args (call); ++i)\n \t\t{\n-\t\t  tree arg = gimple_call_arg (stmt, i);\n+\t\t  tree arg = gimple_call_arg (call, i);\n \t\t  if (TREE_CODE (arg) == SSA_NAME\n \t\t      || is_gimple_min_invariant (arg))\n \t\t    continue;\n \t\t  if (TREE_CODE (arg) == WITH_SIZE_EXPR)\n \t\t    arg = TREE_OPERAND (arg, 0);\n \t\t  if (!ref_may_be_aliased (arg))\n-\t\t    mark_aliased_reaching_defs_necessary (stmt, arg);\n+\t\t    mark_aliased_reaching_defs_necessary (call, arg);\n \t\t}\n \t    }\n \t  else if (gimple_assign_single_p (stmt))\n@@ -1397,6 +1401,7 @@ eliminate_unnecessary_stmts (void)\n \t  if (gimple_plf (stmt, STMT_NECESSARY)\n \t      && (gimple_call_builtin_p (stmt, BUILT_IN_FREE)\n \t\t  || (is_gimple_call (stmt)\n+\t\t      && gimple_call_from_new_or_delete (as_a <gcall *> (stmt))\n \t\t      && gimple_call_replaceable_operator_delete_p (as_a <gcall *> (stmt)))))\n \t    {\n \t      tree ptr = gimple_call_arg (stmt, 0);"}, {"sha": "69de932b14cbafe933ee73e6ceb0b21647b7d584", "filename": "gcc/tree-ssa-structalias.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftree-ssa-structalias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b945f959f03a6185a3130f30bfd524d01d4142c/gcc%2Ftree-ssa-structalias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-structalias.c?ref=0b945f959f03a6185a3130f30bfd524d01d4142c", "patch": "@@ -4857,7 +4857,13 @@ find_func_aliases_for_call (struct function *fn, gcall *t)\n \t point for reachable memory of their arguments.  */\n       else if (flags & (ECF_PURE|ECF_LOOPING_CONST_OR_PURE))\n \thandle_pure_call (t, &rhsc);\n-      else if (fndecl && DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (fndecl))\n+      /* If the call is to a replaceable operator delete and results\n+\t from a delete expression as opposed to a direct call to\n+\t such operator, then the effects for PTA (in particular\n+\t the escaping of the pointer) can be ignored.  */\n+      else if (fndecl\n+\t       && DECL_IS_REPLACEABLE_OPERATOR_DELETE_P (fndecl)\n+\t       && gimple_call_from_new_or_delete (t))\n \t;\n       else\n \thandle_rhs_call (t, &rhsc);"}]}