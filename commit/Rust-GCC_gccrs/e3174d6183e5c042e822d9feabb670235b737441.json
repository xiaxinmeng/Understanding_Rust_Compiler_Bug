{"sha": "e3174d6183e5c042e822d9feabb670235b737441", "node_id": "C_kwDOANBUbNoAKGUzMTc0ZDYxODNlNWMwNDJlODIyZDlmZWFiYjY3MDIzNWI3Mzc0NDE", "commit": {"author": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-03-30T12:35:55Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2022-04-05T04:51:37Z"}, "message": "Split vector load from parm_del to elemental loads to avoid STLF stalls.\n\nSince cfg is freed before machine_reorg, just do a rough calculation\nof the window according to the layout.\nAlso according to an experiment on CLX, set window size to 64.\n\nCurrently only handle V2DFmode load since it doesn't need any scratch\nregisters, and it's sufficient to recover cray performance for -O2\ncompared to GCC11.\n\ngcc/ChangeLog:\n\n\tPR target/101908\n\t* config/i386/i386.cc (ix86_split_stlf_stall_load): New\n\tfunction\n\t(ix86_reorg): Call ix86_split_stlf_stall_load.\n\t* config/i386/i386.opt (-param=x86-stlf-window-ninsns=): New\n\tparam.\n\ngcc/testsuite/ChangeLog:\n\n\t* gcc.target/i386/pr101908-1.c: New test.\n\t* gcc.target/i386/pr101908-2.c: New test.\n\t* gcc.target/i386/pr101908-3.c: New test.", "tree": {"sha": "3cc052908840aea684e965682f7eec3d2eebc39b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3cc052908840aea684e965682f7eec3d2eebc39b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e3174d6183e5c042e822d9feabb670235b737441", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3174d6183e5c042e822d9feabb670235b737441", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e3174d6183e5c042e822d9feabb670235b737441", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e3174d6183e5c042e822d9feabb670235b737441/comments", "author": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "418967ca275853a570b0ae566d7022ff38e7cd0d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/418967ca275853a570b0ae566d7022ff38e7cd0d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/418967ca275853a570b0ae566d7022ff38e7cd0d"}], "stats": {"total": 103, "additions": 103, "deletions": 0}, "files": [{"sha": "c959b7144de3610373e36c8efd50d4bb3884d402", "filename": "gcc/config/i386/i386.cc", "status": "modified", "additions": 61, "deletions": 0, "changes": 61, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Fconfig%2Fi386%2Fi386.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Fconfig%2Fi386%2Fi386.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.cc?ref=e3174d6183e5c042e822d9feabb670235b737441", "patch": "@@ -21942,6 +21942,65 @@ ix86_seh_fixup_eh_fallthru (void)\n       emit_insn_after (gen_nops (const1_rtx), insn);\n     }\n }\n+/* Split vector load from parm_decl to elemental loads to avoid STLF\n+   stalls.  */\n+static void\n+ix86_split_stlf_stall_load ()\n+{\n+  rtx_insn* insn, *start = get_insns ();\n+  unsigned window = 0;\n+\n+  for (insn = start; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (!NONDEBUG_INSN_P (insn))\n+\tcontinue;\n+      window++;\n+      /* Insert 64 vaddps %xmm18, %xmm19, %xmm20(no dependence between each\n+\t other, just emulate for pipeline) before stalled load, stlf stall\n+\t case is as fast as no stall cases on CLX.\n+\t Since CFG is freed before machine_reorg, just do a rough\n+\t calculation of the window according to the layout.  */\n+      if (window > (unsigned) x86_stlf_window_ninsns)\n+\treturn;\n+\n+      if (any_uncondjump_p (insn)\n+\t  || ANY_RETURN_P (PATTERN (insn))\n+\t  || CALL_P (insn))\n+\treturn;\n+\n+      rtx set = single_set (insn);\n+      if (!set)\n+\tcontinue;\n+      rtx src = SET_SRC (set);\n+      if (!MEM_P (src)\n+\t  /* Only handle V2DFmode load since it doesn't need any scratch\n+\t     register.  */\n+\t  || GET_MODE (src) != E_V2DFmode\n+\t  || !MEM_EXPR (src)\n+\t  || TREE_CODE (get_base_address (MEM_EXPR (src))) != PARM_DECL)\n+\tcontinue;\n+\n+      rtx zero = CONST0_RTX (V2DFmode);\n+      rtx dest = SET_DEST (set);\n+      rtx m = adjust_address (src, DFmode, 0);\n+      rtx loadlpd = gen_sse2_loadlpd (dest, zero, m);\n+      emit_insn_before (loadlpd, insn);\n+      m = adjust_address (src, DFmode, 8);\n+      rtx loadhpd = gen_sse2_loadhpd (dest, dest, m);\n+      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t{\n+\t  fputs (\"Due to potential STLF stall, split instruction:\\n\",\n+\t\t dump_file);\n+\t  print_rtl_single (dump_file, insn);\n+\t  fputs (\"To:\\n\", dump_file);\n+\t  print_rtl_single (dump_file, loadlpd);\n+\t  print_rtl_single (dump_file, loadhpd);\n+\t}\n+      PATTERN (insn) = loadhpd;\n+      INSN_CODE (insn) = -1;\n+      gcc_assert (recog_memoized (insn) != -1);\n+    }\n+}\n \n /* Implement machine specific optimizations.  We implement padding of returns\n    for K8 CPUs and pass to avoid 4 jumps in the single 16 byte window.  */\n@@ -21957,6 +22016,8 @@ ix86_reorg (void)\n \n   if (optimize && optimize_function_for_speed_p (cfun))\n     {\n+      if (TARGET_SSE2)\n+\tix86_split_stlf_stall_load ();\n       if (TARGET_PAD_SHORT_FUNCTION)\n \tix86_pad_short_function ();\n       else if (TARGET_PAD_RETURNS)"}, {"sha": "a6b0e28f23853c9ff44e63357d13d484d8334484", "filename": "gcc/config/i386/i386.opt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Fconfig%2Fi386%2Fi386.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Fconfig%2Fi386%2Fi386.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.opt?ref=e3174d6183e5c042e822d9feabb670235b737441", "patch": "@@ -1210,3 +1210,7 @@ Support MMX, SSE, SSE2, SSE3, SSSE3, SSE4.1, SSE4.2, AVX, AVX2, AVX512F and AVX5\n mdirect-extern-access\n Target Var(ix86_direct_extern_access) Init(1)\n Do not use GOT to access external symbols.\n+\n+-param=x86-stlf-window-ninsns=\n+Target Joined UInteger Var(x86_stlf_window_ninsns) Init(64) Param\n+Instructions number above which STFL stall penalty can be compensated."}, {"sha": "33d9684f0ad84e00d632a0cc9b4c5c1f82ecdf08", "filename": "gcc/testsuite/gcc.target/i386/pr101908-1.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-1.c?ref=e3174d6183e5c042e822d9feabb670235b737441", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-avx\" } */\n+/* { dg-final { scan-assembler-not {(?n)movhpd[ \\t]} } } */\n+\n+struct X { double x[2]; };\n+typedef double v2df __attribute__((vector_size(16)));\n+\n+v2df __attribute__((noipa))\n+foo (struct X* x, struct X* y)\n+{\n+  return (v2df) {x->x[1], x->x[0] } + (v2df) { y->x[1], y->x[0] };\n+}"}, {"sha": "45060b73c065d977ac3fb7250e00fe02c88c9132", "filename": "gcc/testsuite/gcc.target/i386/pr101908-2.c", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-2.c?ref=e3174d6183e5c042e822d9feabb670235b737441", "patch": "@@ -0,0 +1,12 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-avx\" } */\n+/* { dg-final { scan-assembler-times {(?n)movhpd[ \\t]+} \"2\" } }  */\n+\n+struct X { double x[4]; };\n+typedef double v2df __attribute__((vector_size(16)));\n+\n+v2df __attribute__((noipa))\n+foo (struct X x, struct X y)\n+{\n+  return (v2df) {x.x[1], x.x[0] } + (v2df) { y.x[1], y.x[0] };\n+}"}, {"sha": "ddd3e8eff33ac40697bbe22d9eddb9df8c85c61f", "filename": "gcc/testsuite/gcc.target/i386/pr101908-3.c", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e3174d6183e5c042e822d9feabb670235b737441/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fpr101908-3.c?ref=e3174d6183e5c042e822d9feabb670235b737441", "patch": "@@ -0,0 +1,14 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -msse2 -mno-avx\" } */\n+/* { dg-final { scan-assembler-not {(?n)movhpd[ \\t]+} } }  */\n+\n+struct X { double x[4]; };\n+typedef double v2df __attribute__((vector_size(16)));\n+\n+extern void bar (void);\n+v2df __attribute__((noipa))\n+foo (struct X x, struct X y)\n+{\n+  bar ();\n+  return (v2df) {x.x[1], x.x[0] } + (v2df) { y.x[1], y.x[0] };\n+}"}]}