{"sha": "71e546870c4afb3c3ff993bd354a98637bcccdc7", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzFlNTQ2ODcwYzRhZmIzYzNmZjk5M2JkMzU0YTk4NjM3YmNjY2RjNw==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2015-12-07T17:36:54Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2015-12-07T17:36:54Z"}, "message": "re PR lto/61886 (LTO breaks fread with _FORTIFY_SOURCE=2)\n\n\tPR ipa/61886\n\t* symtab.c (ultimate_transparent_alias_target): New inline function.\n\t(symbol_table::assembler_names_equal_p): New method; break out from ...\n\t(symbol_table::decl_assembler_name_equal): ... here.\n\t(symbol_table::change_decl_assembler_name): Also update names and\n\ttranslation links of transparent aliases.\n\t(symtab_node::dump_base): Dump transparent_alias.\n\t(symtab_node::verify_base): Implement basic transparent alias\n\tverification.\n\t(symtab_node::make_decl_local): Support localization of weakrefs;\n\trecurse to transparent aliases; set TREE_STATIC.\n\t(symtab_node::ultimate_alias_target_1): Handle visibility of\n\ttransparent aliases.\n\t(symtab_node::resolve_alias): New parmaeter transparent; handle\n\ttransparent aliases; recurse to aliases of aliases to fix comdat\n\tgroups.\n\t(symtab_node::get_partitioning_class): Handle transparent aliases.\n\t* ipa-visibility.c (cgraph_externally_visible_p,\n\tvarpool_node::externally_visible_p): Visibility of transparent alias\n\tdepends on its target.\n\t(function_and_variable_visibility): Do not tweak visibility of\n\ttransparent laiases.\n\t(function_and_variable_visibility): Likewise.\n\t* ipa.c (symbol_table::remove_unreachable_nodes): Clear\n\ttransparent_alias flag.\n\t* alias.c (cgraph_node::create_alias, cgraph_node::get_availability):\n\tSupport transparent aliases.\n\t* cgraph.h (symtab_node): Update prototype of resolve_alias;\n\tadd transparent_alias flag.\n\t(symbol_table: Add assembler_names_equal_p.\n\t(symtab_node::real_symbol_p): Skip transparent aliases.\n\t* cgraphunit.c (cgraph_node::reset): Reset transparent_alias flag.\n\t(handle_alias_pairs): Set transparent_alias for weakref.\n\t(cgraph_node::assemble_thunks_and_aliases): Do not asemble transparent\n\taliases.\n\t* lto-cgraph.c (lto_output_node): When outputting same_comdat_group\n\tskip symbols not put into boundary; stream transparent_alias.\n\t(lto_output_varpool_node): Likewise.\n\t(input_overwrite_node, input_varpool_node): Stream transparent alias.\n\t* varpool.c (ctor_for_folding, varpool_node::get_availability,\n\tvarpool_node::assemble_aliases,\n\tsymbol_table::remove_unreferenced_decls): Handle transparent aliase.\n\t(varpool_node::create_alias): Set transparent_alias.\n\n\t* lto-partition.c (add_symbol_to_partition_1, contained_in_symbol,\n\trename_statics, rename_statics): Handle transparent aliases.\n\nFrom-SVN: r231373", "tree": {"sha": "88a2ecfa7b9a4506583492a38ea5179fc643bd39", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/88a2ecfa7b9a4506583492a38ea5179fc643bd39"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/71e546870c4afb3c3ff993bd354a98637bcccdc7", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e546870c4afb3c3ff993bd354a98637bcccdc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/71e546870c4afb3c3ff993bd354a98637bcccdc7", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/71e546870c4afb3c3ff993bd354a98637bcccdc7/comments", "author": null, "committer": null, "parents": [{"sha": "058c6384fe443310b1788dcdc8880beba24d6b43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/058c6384fe443310b1788dcdc8880beba24d6b43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/058c6384fe443310b1788dcdc8880beba24d6b43"}], "stats": {"total": 524, "additions": 388, "deletions": 136}, "files": [{"sha": "d60a6da679c3de8e9c66be5c37584bc1bfa2b63e", "filename": "gcc/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -1,3 +1,49 @@\n+2015-12-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* symtab.c (ultimate_transparent_alias_target): New inline function.\n+\t(symbol_table::assembler_names_equal_p): New method; break out from ...\n+\t(symbol_table::decl_assembler_name_equal): ... here.\n+\t(symbol_table::change_decl_assembler_name): Also update names and\n+\ttranslation links of transparent aliases.\n+\t(symtab_node::dump_base): Dump transparent_alias.\n+\t(symtab_node::verify_base): Implement basic transparent alias\n+\tverification.\n+\t(symtab_node::make_decl_local): Support localization of weakrefs;\n+\trecurse to transparent aliases; set TREE_STATIC.\n+\t(symtab_node::ultimate_alias_target_1): Handle visibility of\n+\ttransparent aliases.\n+\t(symtab_node::resolve_alias): New parmaeter transparent; handle\n+\ttransparent aliases; recurse to aliases of aliases to fix comdat\n+\tgroups.\n+\t(symtab_node::get_partitioning_class): Handle transparent aliases.\n+\t* ipa-visibility.c (cgraph_externally_visible_p,\n+\tvarpool_node::externally_visible_p): Visibility of transparent alias\n+\tdepends on its target.\n+\t(function_and_variable_visibility): Do not tweak visibility of\n+\ttransparent laiases.\n+\t(function_and_variable_visibility): Likewise.\n+\t* ipa.c (symbol_table::remove_unreachable_nodes): Clear\n+\ttransparent_alias flag.\n+\t* alias.c (cgraph_node::create_alias, cgraph_node::get_availability):\n+\tSupport transparent aliases.\n+\t* cgraph.h (symtab_node): Update prototype of resolve_alias;\n+\tadd transparent_alias flag.\n+\t(symbol_table: Add assembler_names_equal_p.\n+\t(symtab_node::real_symbol_p): Skip transparent aliases.\n+\t* cgraphunit.c (cgraph_node::reset): Reset transparent_alias flag.\n+\t(handle_alias_pairs): Set transparent_alias for weakref.\n+\t(cgraph_node::assemble_thunks_and_aliases): Do not asemble transparent\n+\taliases.\n+\t* lto-cgraph.c (lto_output_node): When outputting same_comdat_group\n+\tskip symbols not put into boundary; stream transparent_alias.\n+\t(lto_output_varpool_node): Likewise.\n+\t(input_overwrite_node, input_varpool_node): Stream transparent alias.\n+\t* varpool.c (ctor_for_folding, varpool_node::get_availability,\n+\tvarpool_node::assemble_aliases,\n+\tsymbol_table::remove_unreferenced_decls): Handle transparent aliase.\n+\t(varpool_node::create_alias): Set transparent_alias.\n+\n 2015-12-07  Eric Botcazou  <ebotcazou@adacore.com>\n \n \tPR middle-end/68291"}, {"sha": "35cd98c12f833347563426ad175703154bed60b9", "filename": "gcc/cgraph.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -560,7 +560,7 @@ cgraph_node::create_alias (tree alias, tree target)\n   alias_node->definition = true;\n   alias_node->alias = true;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n-    alias_node->weakref = true;\n+    alias_node->transparent_alias = alias_node->weakref = true;\n   return alias_node;\n }\n \n@@ -2147,7 +2147,7 @@ cgraph_node::get_availability (void)\n     avail = AVAIL_NOT_AVAILABLE;\n   else if (local.local)\n     avail = AVAIL_LOCAL;\n-  else if (alias && weakref)\n+  else if (transparent_alias)\n     ultimate_alias_target (&avail);\n   else if (lookup_attribute (\"ifunc\", DECL_ATTRIBUTES (decl)))\n     avail = AVAIL_INTERPOSABLE;"}, {"sha": "7c643502fff60bb2faa626269bc0f5b482349b84", "filename": "gcc/cgraph.h", "status": "modified", "additions": 30, "deletions": 1, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -249,9 +249,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   inline symtab_node *next_defined_symbol (void);\n \n   /* Add reference recording that symtab node is alias of TARGET.\n+     If TRANSPARENT is true make the alias to be transparent alias.\n      The function can fail in the case of aliasing cycles; in this case\n      it returns false.  */\n-  bool resolve_alias (symtab_node *target);\n+  bool resolve_alias (symtab_node *target, bool transparent = false);\n \n   /* C++ FE sometimes change linkage flags after producing same\n      body aliases.  */\n@@ -421,6 +422,28 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   /* True when symbol is an alias.\n      Set by ssemble_alias.  */\n   unsigned alias : 1;\n+  /* When true the alias is translated into its target symbol either by GCC\n+     or assembler (it also may just be a duplicate declaration of the same\n+     linker name).\n+\n+     Currently transparent aliases come in three different flavors\n+       - aliases having the same assembler name as their target (aka duplicated\n+\t declarations). In this case the assembler names compare via\n+\t assembler_names_equal_p and weakref is false\n+       - aliases that are renamed at a time being output to final file\n+\t by varasm.c. For those DECL_ASSEMBLER_NAME have\n+\t IDENTIFIER_TRANSPARENT_ALIAS set and thus also their assembler\n+\t name must be unique.\n+\t Weakrefs belong to this cateogry when we target assembler without\n+\t .weakref directive.\n+       - weakrefs that are renamed by assembler via .weakref directive.\n+\t In this case the alias may or may not be definition (depending if\n+\t target declaration was seen by the compiler), weakref is set.\n+\t Unless we are before renaming statics, assembler names are different.\n+\n+     Given that we now support duplicate declarations, the second option is\n+     redundant and will be removed.  */\n+  unsigned transparent_alias : 1;\n   /* True when alias is a weakref.  */\n   unsigned weakref : 1;\n   /* C++ frontend produce same body aliases and extra name aliases for\n@@ -2098,6 +2121,10 @@ class GTY((tag (\"SYMTAB\"))) symbol_table\n   /* Set the DECL_ASSEMBLER_NAME and update symtab hashtables.  */\n   void change_decl_assembler_name (tree decl, tree name);\n \n+  /* Return true if assembler names NAME1 and NAME2 leads to the same symbol\n+     name.  */\n+  static bool assembler_names_equal_p (const char *name1, const char *name2);\n+\n   int cgraph_count;\n   int cgraph_max_uid;\n   int cgraph_max_summary_uid;\n@@ -2251,6 +2278,8 @@ symtab_node::real_symbol_p (void)\n \n   if (DECL_ABSTRACT_P (decl))\n     return false;\n+  if (transparent_alias && definition)\n+    return false;\n   if (!is_a <cgraph_node *> (this))\n     return true;\n   cnode = dyn_cast <cgraph_node *> (this);"}, {"sha": "3d86c36488ea589e3950214115c2df235c406d0e", "filename": "gcc/cgraphunit.c", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraphunit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fcgraphunit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraphunit.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -369,6 +369,7 @@ cgraph_node::reset (void)\n   analyzed = false;\n   definition = false;\n   alias = false;\n+  transparent_alias = false;\n   weakref = false;\n   cpp_implicit_alias = false;\n \n@@ -594,7 +595,7 @@ cgraph_node::analyze (void)\n       thunk.alias = NULL;\n     }\n   if (alias)\n-    resolve_alias (cgraph_node::get (alias_target));\n+    resolve_alias (cgraph_node::get (alias_target), transparent_alias);\n   else if (dispatcher_function)\n     {\n       /* Generate the dispatcher body of multi-versioned functions.  */\n@@ -1254,6 +1255,7 @@ handle_alias_pairs (void)\n \t      node->alias_target = p->target;\n \t      node->weakref = true;\n \t      node->alias = true;\n+\t      node->transparent_alias = true;\n \t    }\n \t  alias_pairs->unordered_remove (i);\n \t  continue;\n@@ -1908,15 +1910,18 @@ cgraph_node::assemble_thunks_and_aliases (void)\n   FOR_EACH_ALIAS (this, ref)\n     {\n       cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n-      bool saved_written = TREE_ASM_WRITTEN (decl);\n-\n-      /* Force assemble_alias to really output the alias this time instead\n-\t of buffering it in same alias pairs.  */\n-      TREE_ASM_WRITTEN (decl) = 1;\n-      do_assemble_alias (alias->decl,\n-\t\t\t DECL_ASSEMBLER_NAME (decl));\n-      alias->assemble_thunks_and_aliases ();\n-      TREE_ASM_WRITTEN (decl) = saved_written;\n+      if (!alias->transparent_alias)\n+\t{\n+\t  bool saved_written = TREE_ASM_WRITTEN (decl);\n+\n+\t  /* Force assemble_alias to really output the alias this time instead\n+\t     of buffering it in same alias pairs.  */\n+\t  TREE_ASM_WRITTEN (decl) = 1;\n+\t  do_assemble_alias (alias->decl,\n+\t\t\t     DECL_ASSEMBLER_NAME (decl));\n+\t  alias->assemble_thunks_and_aliases ();\n+\t  TREE_ASM_WRITTEN (decl) = saved_written;\n+\t}\n     }\n }\n "}, {"sha": "0423f242af06af937d9319efb2cd72f9f2b0ee10", "filename": "gcc/ipa-visibility.c", "status": "modified", "additions": 22, "deletions": 10, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fipa-visibility.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fipa-visibility.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-visibility.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -185,6 +185,8 @@ static bool\n cgraph_externally_visible_p (struct cgraph_node *node,\n \t\t\t     bool whole_program)\n {\n+  while (node->transparent_alias && node->definition)\n+    node = node->get_alias_target ();\n   if (!node->definition)\n     return false;\n   if (!TREE_PUBLIC (node->decl)\n@@ -248,6 +250,8 @@ cgraph_externally_visible_p (struct cgraph_node *node,\n bool\n varpool_node::externally_visible_p (void)\n {\n+  while (transparent_alias && definition)\n+    return get_alias_target ()->externally_visible_p ();\n   if (DECL_EXTERNAL (decl))\n     return true;\n \n@@ -531,7 +535,8 @@ function_and_variable_visibility (bool whole_program)\n \t\t  next->set_comdat_group (NULL);\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n-\t\t  next->make_decl_local ();\n+\t\t  if (!next->transparent_alias)\n+\t\t    next->make_decl_local ();\n \t\t  next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n \t\t\t\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n \t\t\t\t        && TREE_PUBLIC (next->decl)\n@@ -547,7 +552,8 @@ function_and_variable_visibility (bool whole_program)\n \t    node->set_comdat_group (NULL);\n \t  if (DECL_COMDAT (node->decl) && !node->alias)\n \t    node->set_section (NULL);\n-\t  node->make_decl_local ();\n+\t  if (!node->transparent_alias)\n+\t    node->make_decl_local ();\n \t}\n \n       if (node->thunk.thunk_p\n@@ -654,7 +660,7 @@ function_and_variable_visibility (bool whole_program)\n \t\t\t    DECL_ATTRIBUTES (vnode->decl)))\n \tvnode->no_reorder = 1;\n       if (!vnode->externally_visible\n-\t  && !vnode->weakref)\n+\t  && !vnode->transparent_alias)\n \t{\n \t  gcc_assert (in_lto_p || whole_program || !TREE_PUBLIC (vnode->decl));\n \t  vnode->unique_name |= ((vnode->resolution == LDPR_PREVAILING_DEF_IRONLY\n@@ -675,20 +681,26 @@ function_and_variable_visibility (bool whole_program)\n \t\t  next->set_comdat_group (NULL);\n \t\t  if (!next->alias)\n \t\t    next->set_section (NULL);\n-\t\t  next->make_decl_local ();\n-\t\t  next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n-\t\t\t\t\t || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n-\t\t\t\t        && TREE_PUBLIC (next->decl)\n-\t\t\t\t\t&& !flag_incremental_link);\n+\t\t  if (!next->transparent_alias)\n+\t\t    {\n+\t\t      next->make_decl_local ();\n+\t\t      next->unique_name |= ((next->resolution == LDPR_PREVAILING_DEF_IRONLY\n+\t\t\t\t\t     || next->resolution == LDPR_PREVAILING_DEF_IRONLY_EXP)\n+\t\t\t\t\t    && TREE_PUBLIC (next->decl)\n+\t\t\t\t\t    && !flag_incremental_link);\n+\t\t    }\n \t\t}\n \t      vnode->dissolve_same_comdat_group_list ();\n \t    }\n \t  if (TREE_PUBLIC (vnode->decl))\n \t    vnode->set_comdat_group (NULL);\n \t  if (DECL_COMDAT (vnode->decl) && !vnode->alias)\n \t    vnode->set_section (NULL);\n-\t  vnode->make_decl_local ();\n-\t  vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t  if (!vnode->transparent_alias)\n+\t    {\n+\t      vnode->make_decl_local ();\n+\t      vnode->resolution = LDPR_PREVAILING_DEF_IRONLY;\n+\t    }\n \t}\n       update_visibility_by_resolution_info (vnode);\n "}, {"sha": "ce891e1249e4eacb0d283c3fb20a69bdca687fc7", "filename": "gcc/ipa.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fipa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fipa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -543,6 +543,7 @@ symbol_table::remove_unreachable_nodes (FILE *file)\n \t      node->definition = false;\n \t      node->cpp_implicit_alias = false;\n \t      node->alias = false;\n+\t      node->transparent_alias = false;\n \t      node->thunk.thunk_p = false;\n \t      node->weakref = false;\n \t      /* After early inlining we drop always_inline attributes on"}, {"sha": "e1c259593d95cc44fe1aea97a090bbd4e50fdf06", "filename": "gcc/lto-cgraph.c", "status": "modified", "additions": 15, "deletions": 9, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto-cgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto-cgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-cgraph.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -485,11 +485,12 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n \n   if (group)\n     {\n-      if (node->same_comdat_group && !boundary_p)\n+      if (node->same_comdat_group)\n \t{\n-\t  ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t\t   node->same_comdat_group);\n-\t  gcc_assert (ref != LCC_NOT_FOUND);\n+\t  ref = LCC_NOT_FOUND;\n+\t  for (struct symtab_node *n = node->same_comdat_group; \n+\t       ref == LCC_NOT_FOUND && n != node; n = n->same_comdat_group)\n+\t    ref = lto_symtab_encoder_lookup (encoder, n);\n \t}\n       else\n \tref = LCC_NOT_FOUND;\n@@ -523,6 +524,7 @@ lto_output_node (struct lto_simple_output_block *ob, struct cgraph_node *node,\n   bp_pack_value (&bp, node->lowered, 1);\n   bp_pack_value (&bp, in_other_partition, 1);\n   bp_pack_value (&bp, node->alias, 1);\n+  bp_pack_value (&bp, node->transparent_alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n   bp_pack_value (&bp, node->frequency, 2);\n   bp_pack_value (&bp, node->only_called_at_startup, 1);\n@@ -599,8 +601,9 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n   bp_pack_value (&bp, node->definition && (encode_initializer_p || node->alias),\n \t\t 1);\n   bp_pack_value (&bp, node->alias, 1);\n+  bp_pack_value (&bp, node->transparent_alias, 1);\n   bp_pack_value (&bp, node->weakref, 1);\n-  bp_pack_value (&bp, node->analyzed && !boundary_p, 1);\n+  bp_pack_value (&bp, node->analyzed && (!boundary_p || node->alias), 1);\n   gcc_assert (node->definition || !node->analyzed);\n   /* Constant pool initializers can be de-unified into individual ltrans units.\n      FIXME: Alternatively at -Os we may want to avoid generating for them the local\n@@ -632,11 +635,12 @@ lto_output_varpool_node (struct lto_simple_output_block *ob, varpool_node *node,\n \n   if (group)\n     {\n-      if (node->same_comdat_group && !boundary_p)\n+      if (node->same_comdat_group)\n \t{\n-\t  ref = lto_symtab_encoder_lookup (encoder,\n-\t\t\t\t\t   node->same_comdat_group);\n-\t  gcc_assert (ref != LCC_NOT_FOUND);\n+\t  ref = LCC_NOT_FOUND;\n+\t  for (struct symtab_node *n = node->same_comdat_group; \n+\t       ref == LCC_NOT_FOUND && n != node; n = n->same_comdat_group)\n+\t    ref = lto_symtab_encoder_lookup (encoder, n);\n \t}\n       else\n \tref = LCC_NOT_FOUND;\n@@ -1170,6 +1174,7 @@ input_overwrite_node (struct lto_file_decl_data *file_data,\n       TREE_STATIC (node->decl) = 0;\n     }\n   node->alias = bp_unpack_value (bp, 1);\n+  node->transparent_alias = bp_unpack_value (bp, 1);\n   node->weakref = bp_unpack_value (bp, 1);\n   node->frequency = (enum node_frequency)bp_unpack_value (bp, 2);\n   node->only_called_at_startup = bp_unpack_value (bp, 1);\n@@ -1369,6 +1374,7 @@ input_varpool_node (struct lto_file_decl_data *file_data,\n   node->writeonly = bp_unpack_value (&bp, 1);\n   node->definition = bp_unpack_value (&bp, 1);\n   node->alias = bp_unpack_value (&bp, 1);\n+  node->transparent_alias = bp_unpack_value (&bp, 1);\n   node->weakref = bp_unpack_value (&bp, 1);\n   node->analyzed = bp_unpack_value (&bp, 1);\n   node->used_from_other_partition = bp_unpack_value (&bp, 1);"}, {"sha": "bdbc8665a1cff096b3b6ad997bdfb967b9a44c25", "filename": "gcc/lto/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2FChangeLog?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -1,3 +1,9 @@\n+2015-12-07  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR ipa/61886\n+\t* lto-partition.c (add_symbol_to_partition_1, contained_in_symbol,\n+\trename_statics, rename_statics): Handle transparent aliases.\n+\n 2015-12-04  Jan Hubicka  <hubicka@ucw.cz>\n \n \t* lto-symtab.c (lto_cgraph_replace_node): Update code computing"}, {"sha": "ac1b618a5e2ed8ecb60f21c9d44414e54b3c9b4b", "filename": "gcc/lto/lto-partition.c", "status": "modified", "additions": 9, "deletions": 1, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto%2Flto-partition.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Flto%2Flto-partition.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto%2Flto-partition.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -1035,7 +1035,15 @@ rename_statics (lto_symtab_encoder_t encoder, symtab_node *node)\n   /* Assign every symbol in the set that shares the same ASM name an unique\n      mangled name.  */\n   for (s = symtab_node::get_for_asmname (name); s;)\n-    if (!s->externally_visible\n+    if ((!s->externally_visible || s->weakref)\n+\t/* Transparent aliases having same name as target are renamed at a\n+\t   time their target gets new name.  Transparent aliases that use\n+\t   separate assembler name require the name to be unique.  */\n+\t&& (!s->transparent_alias || !s->definition || s->weakref\n+\t    || !symbol_table::assembler_names_equal_p\n+\t\t (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (s->decl)),\n+\t\t  IDENTIFIER_POINTER\n+\t\t    (DECL_ASSEMBLER_NAME (s->get_alias_target()->decl))))\n \t&& ((s->real_symbol_p ()\n              && !DECL_EXTERNAL (node->decl)\n \t     && !TREE_PUBLIC (node->decl))"}, {"sha": "06d618bb3b4a20a809ab0780e0e3c47e1adf5707", "filename": "gcc/symtab.c", "status": "modified", "additions": 192, "deletions": 74, "changes": 266, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -52,6 +52,26 @@ const char * const ld_plugin_symbol_resolution_names[]=\n   \"prevailing_def_ironly_exp\"\n };\n \n+/* Follow the IDENTIFIER_TRANSPARENT_ALIAS chain starting at ALIAS\n+   until we find an identifier that is not itself a transparent alias.  */\n+\n+static inline tree\n+ultimate_transparent_alias_target (tree alias)\n+{\n+  tree target = alias;\n+\n+  while (IDENTIFIER_TRANSPARENT_ALIAS (target))\n+    {\n+      gcc_checking_assert (TREE_CHAIN (target));\n+      target = TREE_CHAIN (target);\n+    }\n+  gcc_checking_assert (! IDENTIFIER_TRANSPARENT_ALIAS (target)\n+\t\t       && ! TREE_CHAIN (target));\n+\n+  return target;\n+}\n+\n+\n /* Hash asmnames ignoring the user specified marks.  */\n \n hashval_t\n@@ -73,6 +93,44 @@ symbol_table::decl_assembler_name_hash (const_tree asmname)\n   return htab_hash_string (IDENTIFIER_POINTER (asmname));\n }\n \n+/* Return true if assembler names NAME1 and NAME2 leads to the same symbol\n+   name.  */\n+\n+bool\n+symbol_table::assembler_names_equal_p (const char *name1, const char *name2)\n+{\n+  if (name1 != name2)\n+    {\n+      if (name1[0] == '*')\n+\t{\n+\t  size_t ulp_len = strlen (user_label_prefix);\n+\n+\t  name1 ++;\n+\n+\t  if (ulp_len == 0)\n+\t    ;\n+\t  else if (strncmp (name1, user_label_prefix, ulp_len) == 0)\n+\t    name1 += ulp_len;\n+\t  else\n+\t    return false;\n+\t}\n+      if (name2[0] == '*')\n+\t{\n+\t  size_t ulp_len = strlen (user_label_prefix);\n+\n+\t  name2 ++;\n+\n+\t  if (ulp_len == 0)\n+\t    ;\n+\t  else if (strncmp (name2, user_label_prefix, ulp_len) == 0)\n+\t    name2 += ulp_len;\n+\t  else\n+\t    return false;\n+\t}\n+      return !strcmp (name1, name2);\n+    }\n+  return true;\n+}\n \n /* Compare ASMNAME with the DECL_ASSEMBLER_NAME of DECL.  */\n \n@@ -82,51 +140,13 @@ symbol_table::decl_assembler_name_equal (tree decl, const_tree asmname)\n   tree decl_asmname = DECL_ASSEMBLER_NAME (decl);\n   const char *decl_str;\n   const char *asmname_str;\n-  bool test = false;\n \n   if (decl_asmname == asmname)\n     return true;\n \n   decl_str = IDENTIFIER_POINTER (decl_asmname);\n   asmname_str = IDENTIFIER_POINTER (asmname);\n-\n-\n-  /* If the target assembler name was set by the user, things are trickier.\n-     We have a leading '*' to begin with.  After that, it's arguable what\n-     is the correct thing to do with -fleading-underscore.  Arguably, we've\n-     historically been doing the wrong thing in assemble_alias by always\n-     printing the leading underscore.  Since we're not changing that, make\n-     sure user_label_prefix follows the '*' before matching.  */\n-  if (decl_str[0] == '*')\n-    {\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      decl_str ++;\n-\n-      if (ulp_len == 0)\n-\ttest = true;\n-      else if (strncmp (decl_str, user_label_prefix, ulp_len) == 0)\n-\tdecl_str += ulp_len, test=true;\n-      else\n-\tdecl_str --;\n-    }\n-  if (asmname_str[0] == '*')\n-    {\n-      size_t ulp_len = strlen (user_label_prefix);\n-\n-      asmname_str ++;\n-\n-      if (ulp_len == 0)\n-\ttest = true;\n-      else if (strncmp (asmname_str, user_label_prefix, ulp_len) == 0)\n-\tasmname_str += ulp_len, test=true;\n-      else\n-\tasmname_str --;\n-    }\n-\n-  if (!test)\n-    return false;\n-  return strcmp (decl_str, asmname_str) == 0;\n+  return assembler_names_equal_p (decl_str, asmname_str);\n }\n \n \n@@ -273,6 +293,8 @@ symbol_table::change_decl_assembler_name (tree decl, tree name)\n \t\t    : NULL);\n       if (node)\n \tunlink_from_assembler_name_hash (node, true);\n+\n+      const char *old_name = IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl));\n       if (TREE_SYMBOL_REFERENCED (DECL_ASSEMBLER_NAME (decl))\n \t  && DECL_RTL_SET_P (decl))\n \twarning (0, \"%D renamed after being referenced in assembly\", decl);\n@@ -283,8 +305,48 @@ symbol_table::change_decl_assembler_name (tree decl, tree name)\n \t  IDENTIFIER_TRANSPARENT_ALIAS (name) = 1;\n \t  TREE_CHAIN (name) = alias;\n \t}\n+      /* If we change assembler name, also all transparent aliases must\n+\t be updated.  There are three kinds - those having same assembler name,\n+\t those being renamed in varasm.c and weakref being renamed by the\n+\t assembler.  */\n       if (node)\n-\tinsert_to_assembler_name_hash (node, true);\n+\t{\n+\t  insert_to_assembler_name_hash (node, true);\n+\t  ipa_ref *ref;\n+\t  for (unsigned i = 0; node->iterate_direct_aliases (i, ref); i++)\n+\t    {\n+\t      struct symtab_node *alias = ref->referring;\n+\t      if (alias->transparent_alias && !alias->weakref\n+\t\t  && symbol_table::assembler_names_equal_p\n+\t\t\t (old_name, IDENTIFIER_POINTER (\n+\t\t\t\t      DECL_ASSEMBLER_NAME (alias->decl))))\n+\t\tchange_decl_assembler_name (alias->decl, name);\n+\t      else if (alias->transparent_alias\n+\t\t       && IDENTIFIER_TRANSPARENT_ALIAS (alias->decl))\n+\t\t{\n+\t\t  gcc_assert (TREE_CHAIN (DECL_ASSEMBLER_NAME (alias->decl))\n+\t\t\t      && IDENTIFIER_TRANSPARENT_ALIAS\n+\t\t\t\t     (DECL_ASSEMBLER_NAME (alias->decl)));\n+\n+\t\t  TREE_CHAIN (DECL_ASSEMBLER_NAME (alias->decl)) = \n+\t\t    ultimate_transparent_alias_target\n+\t\t\t (DECL_ASSEMBLER_NAME (node->decl));\n+\t\t}\n+#ifdef ASM_OUTPUT_WEAKREF\n+\t     else gcc_assert (!alias->transparent_alias || alias->weakref);\n+#else\n+\t     else gcc_assert (!alias->transparent_alias);\n+#endif\n+\t    }\n+\t  gcc_assert (!node->transparent_alias || !node->definition\n+\t\t      || node->weakref\n+\t\t      || TREE_CHAIN (DECL_ASSEMBLER_NAME (decl))\n+\t\t      || symbol_table::assembler_names_equal_p\n+\t\t\t  (IDENTIFIER_POINTER (DECL_ASSEMBLER_NAME (decl)),\n+\t\t\t   IDENTIFIER_POINTER\n+\t\t\t     (DECL_ASSEMBLER_NAME\n+\t\t\t\t (node->get_alias_target ()->decl))));\n+\t}\n     }\n }\n \n@@ -727,6 +789,8 @@ symtab_node::dump_base (FILE *f)\n     fprintf (f, \" analyzed\");\n   if (alias)\n     fprintf (f, \" alias\");\n+  if (transparent_alias)\n+    fprintf (f, \" transparent_alias\");\n   if (weakref)\n     fprintf (f, \" weakref\");\n   if (cpp_implicit_alias)\n@@ -973,9 +1037,14 @@ symtab_node::verify_base (void)\n       error (\"node is alias but not definition\");\n       error_found = true;\n     }\n-  if (weakref && !alias)\n+  if (weakref && !transparent_alias)\n     {\n-      error (\"node is weakref but not an alias\");\n+      error (\"node is weakref but not an transparent_alias\");\n+      error_found = true;\n+    }\n+  if (transparent_alias && !alias)\n+    {\n+      error (\"node is transparent_alias but not an alias\");\n       error_found = true;\n     }\n   if (same_comdat_group)\n@@ -1061,6 +1130,29 @@ symtab_node::verify_base (void)\n       get_alias_target ()->dump (stderr);\n       error_found = true;\n     }\n+  if (transparent_alias && definition && !weakref)\n+    {\n+      symtab_node *to = get_alias_target ();\n+      const char *name1\n+\t= IDENTIFIER_POINTER (\n+\t    ultimate_transparent_alias_target (DECL_ASSEMBLER_NAME (decl)));\n+      const char *name2\n+\t= IDENTIFIER_POINTER (\n+\t    ultimate_transparent_alias_target (DECL_ASSEMBLER_NAME (to->decl)));\n+      if (!symbol_table::assembler_names_equal_p (name1, name2))\n+\t{\n+\t  error (\"Transparent alias and target's assembler names differs\");\n+\t  get_alias_target ()->dump (stderr);\n+\t  error_found = true;\n+\t}\n+    }\n+  if (transparent_alias && definition\n+      && get_alias_target()->transparent_alias && get_alias_target()->analyzed)\n+    {\n+      error (\"Chained transparent aliases\");\n+      get_alias_target ()->dump (stderr);\n+      error_found = true;\n+    }\n \n   return error_found;\n }\n@@ -1132,15 +1224,35 @@ symtab_node::make_decl_local (void)\n {\n   rtx rtl, symbol;\n \n+  if (weakref)\n+    {\n+      weakref = false;\n+      IDENTIFIER_TRANSPARENT_ALIAS (DECL_ASSEMBLER_NAME (decl)) = 0;\n+      TREE_CHAIN (DECL_ASSEMBLER_NAME (decl)) = NULL_TREE;\n+      symtab->change_decl_assembler_name\n+\t (decl, DECL_ASSEMBLER_NAME (get_alias_target ()->decl));\n+      DECL_ATTRIBUTES (decl) = remove_attribute (\"weakref\",\n+\t\t\t\t\t\t DECL_ATTRIBUTES (decl));\n+    }\n   /* Avoid clearing comdat_groups on comdat-local decls.  */\n-  if (TREE_PUBLIC (decl) == 0)\n+  else if (TREE_PUBLIC (decl) == 0)\n     return;\n \n+  /* Localizing a symbol also make all its transparent aliases local.  */\n+  ipa_ref *ref;\n+  for (unsigned i = 0; iterate_direct_aliases (i, ref); i++)\n+    {\n+      struct symtab_node *alias = ref->referring;\n+      if (alias->transparent_alias)\n+\talias->make_decl_local ();\n+    }\n+\n   if (TREE_CODE (decl) == VAR_DECL)\n     {\n       DECL_COMMON (decl) = 0;\n       /* ADDRESSABLE flag is not defined for public symbols.  */\n       TREE_ADDRESSABLE (decl) = 1;\n+      TREE_STATIC (decl) = 1;\n     }\n   else gcc_assert (TREE_CODE (decl) == FUNCTION_DECL);\n \n@@ -1175,29 +1287,28 @@ symtab_node::make_decl_local (void)\n symtab_node *\n symtab_node::ultimate_alias_target_1 (enum availability *availability)\n {\n-  bool weakref_p = false;\n+  bool transparent_p = false;\n \n   /* To determine visibility of the target, we follow ELF semantic of aliases.\n      Here alias is an alternative assembler name of a given definition. Its\n      availability prevails the availability of its target (i.e. static alias of\n      weak definition is available.\n \n-     Weakref is a different animal (and not part of ELF per se). It is just\n-     alternative name of a given symbol used within one complation unit\n-     and is translated prior hitting the object file.  It inherits the\n-     visibility of its target (i.e. weakref of non-overwritable definition\n-     is non-overwritable, while weakref of weak definition is weak).\n+     Transaparent alias is just alternative anme of a given symbol used within\n+     one compilation unit and is translated prior hitting the object file.  It\n+     inherits the visibility of its target.\n+     Weakref is a different animal (and noweak definition is weak).\n \n      If we ever get into supporting targets with different semantics, a target\n      hook will be needed here.  */\n \n   if (availability)\n     {\n-      weakref_p = weakref;\n-      if (!weakref_p)\n+      transparent_p = transparent_alias;\n+      if (!transparent_p)\n \t*availability = get_availability ();\n       else\n-\t*availability = AVAIL_LOCAL;\n+\t*availability = AVAIL_NOT_AVAILABLE;\n     }\n \n   symtab_node *node = this;\n@@ -1207,27 +1318,19 @@ symtab_node::ultimate_alias_target_1 (enum availability *availability)\n \tnode = node->get_alias_target ();\n       else\n \t{\n-\t  if (!availability)\n+\t  if (!availability || (!transparent_p && node->analyzed))\n \t    ;\n-\t  else if (node->analyzed)\n-\t    {\n-\t      if (weakref_p)\n-\t\t{\n-\t\t  enum availability a = node->get_availability ();\n-\t\t  if (a < *availability)\n-\t\t    *availability = a;\n-\t\t}\n-\t    }\n+\t  else if (node->analyzed && !node->transparent_alias)\n+\t    *availability = node->get_availability ();\n \t  else\n \t    *availability = AVAIL_NOT_AVAILABLE;\n \t  return node;\n \t}\n-      if (node && availability && weakref_p)\n+      if (node && availability && transparent_p\n+\t  && node->transparent_alias)\n \t{\n-\t  enum availability a = node->get_availability ();\n-\t  if (a < *availability)\n-\t    *availability = a;\n-          weakref_p = node->weakref;\n+\t  *availability = node->get_availability ();\n+\t  transparent_p = false;\n \t}\n     }\n   if (availability)\n@@ -1442,7 +1545,7 @@ symtab_node::set_implicit_section (symtab_node *n,\n    it returns false.  */\n \n bool\n-symtab_node::resolve_alias (symtab_node *target)\n+symtab_node::resolve_alias (symtab_node *target, bool transparent)\n {\n   symtab_node *n;\n \n@@ -1468,6 +1571,11 @@ symtab_node::resolve_alias (symtab_node *target)\n   definition = true;\n   alias = true;\n   analyzed = true;\n+  transparent |= transparent_alias;\n+  transparent_alias = transparent;\n+  if (transparent)\n+    while (target->transparent_alias && target->analyzed)\n+      target = target->get_alias_target ();\n   create_reference (target, IPA_REF_ALIAS, NULL);\n \n   /* Add alias into the comdat group of its target unless it is already there.  */\n@@ -1492,19 +1600,29 @@ symtab_node::resolve_alias (symtab_node *target)\n      when renaming symbols.  */\n   alias_target = NULL;\n \n-  if (cpp_implicit_alias && symtab->state >= CONSTRUCTION)\n+  if (!transparent && cpp_implicit_alias && symtab->state >= CONSTRUCTION)\n     fixup_same_cpp_alias_visibility (target);\n \n   /* If alias has address taken, so does the target.  */\n   if (address_taken)\n     target->ultimate_alias_target ()->address_taken = true;\n \n-  /* All non-weakref aliases of THIS are now in fact aliases of TARGET.  */\n+  /* All non-transparent aliases of THIS are now in fact aliases of TARGET.\n+     If alias is transparent, also all transparent aliases of THIS are now\n+     aliases of TARGET.\n+     Also merge same comdat group lists.  */\n   ipa_ref *ref;\n   for (unsigned i = 0; iterate_direct_aliases (i, ref);)\n     {\n       struct symtab_node *alias_alias = ref->referring;\n-      if (!alias_alias->weakref)\n+      if (alias_alias->get_comdat_group ())\n+\t{\n+\t  alias_alias->remove_from_same_comdat_group ();\n+\t  alias_alias->set_comdat_group (NULL);\n+\t  if (target->get_comdat_group ())\n+\t    alias_alias->add_to_same_comdat_group (target);\n+\t}\n+      if (!alias_alias->transparent_alias || transparent)\n \t{\n \t  alias_alias->remove_all_references ();\n \t  alias_alias->create_reference (target, IPA_REF_ALIAS, NULL);\n@@ -1648,9 +1766,9 @@ symtab_node::get_partitioning_class (void)\n   if (cnode && cnode->global.inlined_to)\n     return SYMBOL_DUPLICATE;\n \n-  /* Weakref aliases are always duplicated.  */\n-  if (weakref)\n-    return SYMBOL_DUPLICATE;\n+  /* Transparent aliases are always duplicated.  */\n+  if (transparent_alias)\n+    return definition ? SYMBOL_DUPLICATE : SYMBOL_EXTERNAL;\n \n   /* External declarations are external.  */\n   if (DECL_EXTERNAL (decl))"}, {"sha": "de67c4fdd8734d99f43a932dc053d8b3b22402bd", "filename": "gcc/tree.c", "status": "modified", "additions": 35, "deletions": 22, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -13423,6 +13423,12 @@ gimple_canonical_types_compatible_p (const_tree t1, const_tree t2,\n       {\n \ttree f1, f2;\n \n+\t/* Don't try to compare variants of an incomplete type, before\n+\t   TYPE_FIELDS has been copied around.  */\n+\tif (!COMPLETE_TYPE_P (t1) && !COMPLETE_TYPE_P (t2))\n+\t  return true;\n+\n+\n \tif (TYPE_REVERSE_STORAGE_ORDER (t1) != TYPE_REVERSE_STORAGE_ORDER (t2))\n \t  return false;\n \n@@ -13709,28 +13715,35 @@ verify_type (const_tree t)\n \t}\n     }\n   else if (RECORD_OR_UNION_TYPE_P (t))\n-    for (tree fld = TYPE_FIELDS (t); fld; fld = TREE_CHAIN (fld))\n-      {\n-\t/* TODO: verify properties of decls.  */\n-\tif (TREE_CODE (fld) == FIELD_DECL)\n-\t  ;\n-\telse if (TREE_CODE (fld) == TYPE_DECL)\n-\t  ;\n-\telse if (TREE_CODE (fld) == CONST_DECL)\n-\t  ;\n-\telse if (TREE_CODE (fld) == VAR_DECL)\n-\t  ;\n-\telse if (TREE_CODE (fld) == TEMPLATE_DECL)\n-\t  ;\n-\telse if (TREE_CODE (fld) == USING_DECL)\n-\t  ;\n-\telse\n-\t  {\n-\t    error (\"Wrong tree in TYPE_FIELDS list\");\n-\t    debug_tree (fld);\n-\t    error_found = true;\n-\t  }\n-      }\n+    {\n+      if (TYPE_FIELDS (t) && !COMPLETE_TYPE_P (t) && in_lto_p)\n+\t{\n+\t  error (\"TYPE_FIELDS defined in incomplete type\");\n+\t  error_found = true;\n+\t}\n+      for (tree fld = TYPE_FIELDS (t); fld; fld = TREE_CHAIN (fld))\n+\t{\n+\t  /* TODO: verify properties of decls.  */\n+\t  if (TREE_CODE (fld) == FIELD_DECL)\n+\t    ;\n+\t  else if (TREE_CODE (fld) == TYPE_DECL)\n+\t    ;\n+\t  else if (TREE_CODE (fld) == CONST_DECL)\n+\t    ;\n+\t  else if (TREE_CODE (fld) == VAR_DECL)\n+\t    ;\n+\t  else if (TREE_CODE (fld) == TEMPLATE_DECL)\n+\t    ;\n+\t  else if (TREE_CODE (fld) == USING_DECL)\n+\t    ;\n+\t  else\n+\t    {\n+\t      error (\"Wrong tree in TYPE_FIELDS list\");\n+\t      debug_tree (fld);\n+\t      error_found = true;\n+\t    }\n+\t}\n+    }\n   else if (TREE_CODE (t) == INTEGER_TYPE\n \t   || TREE_CODE (t) == BOOLEAN_TYPE\n \t   || TREE_CODE (t) == OFFSET_TYPE"}, {"sha": "ffbec6d727a40f3349471f3566832133d1d7162c", "filename": "gcc/varpool.c", "status": "modified", "additions": 15, "deletions": 7, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fvarpool.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/71e546870c4afb3c3ff993bd354a98637bcccdc7/gcc%2Fvarpool.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarpool.c?ref=71e546870c4afb3c3ff993bd354a98637bcccdc7", "patch": "@@ -440,7 +440,7 @@ ctor_for_folding (tree decl)\n       gcc_assert (!DECL_INITIAL (decl)\n \t\t  || (node->alias && node->get_alias_target () == real_node)\n \t\t  || DECL_INITIAL (decl) == error_mark_node);\n-      if (node->weakref)\n+      while (node->transparent_alias && node->analyzed)\n \t{\n \t  node = node->get_alias_target ();\n \t  decl = node->decl;\n@@ -490,11 +490,11 @@ varpool_node::get_availability (void)\n   if (DECL_IN_CONSTANT_POOL (decl)\n       || DECL_VIRTUAL_P (decl))\n     return AVAIL_AVAILABLE;\n-  if (alias && weakref)\n+  if (transparent_alias)\n     {\n       enum availability avail;\n \n-      ultimate_alias_target (&avail)->get_availability ();\n+      ultimate_alias_target (&avail);\n       return avail;\n     }\n   /* If the variable can be overwritten, return OVERWRITABLE.  Takes\n@@ -536,8 +536,9 @@ varpool_node::assemble_aliases (void)\n   FOR_EACH_ALIAS (this, ref)\n     {\n       varpool_node *alias = dyn_cast <varpool_node *> (ref->referring);\n-      do_assemble_alias (alias->decl,\n-\t\t\t DECL_ASSEMBLER_NAME (decl));\n+      if (!alias->transparent_alias)\n+\tdo_assemble_alias (alias->decl,\n+\t\t\t   DECL_ASSEMBLER_NAME (decl));\n       alias->assemble_aliases ();\n     }\n }\n@@ -665,7 +666,14 @@ symbol_table::remove_unreferenced_decls (void)\n \t      && vnode->analyzed)\n \t    enqueue_node (vnode, &first);\n \t  else\n-\t    referenced.add (node);\n+\t    {\n+\t      referenced.add (node);\n+\t      while (node->alias && node->definition)\n+\t\t{\n+\t\t  node = node->get_alias_target ();\n+\t          referenced.add (node);\n+\t\t}\n+\t    }\n \t}\n     }\n   if (dump_file)\n@@ -760,7 +768,7 @@ varpool_node::create_alias (tree alias, tree decl)\n   alias_node->definition = true;\n   alias_node->alias_target = decl;\n   if (lookup_attribute (\"weakref\", DECL_ATTRIBUTES (alias)) != NULL)\n-    alias_node->weakref = true;\n+    alias_node->weakref = alias_node->transparent_alias = true;\n   return alias_node;\n }\n "}]}