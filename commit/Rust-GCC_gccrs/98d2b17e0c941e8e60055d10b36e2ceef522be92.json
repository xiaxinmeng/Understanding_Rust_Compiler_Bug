{"sha": "98d2b17e0c941e8e60055d10b36e2ceef522be92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OThkMmIxN2UwYzk0MWU4ZTYwMDU1ZDEwYjM2ZTJjZWVmNTIyYmU5Mg==", "commit": {"author": {"name": "Richard Henderson", "email": "rth@redhat.com", "date": "2002-03-15T06:50:26Z"}, "committer": {"name": "Richard Henderson", "email": "rth@gcc.gnu.org", "date": "2002-03-15T06:50:26Z"}, "message": "re PR target/5312 ([IA64] ICE in itanium_reorder at config/ia64/ia64.c:5917)\n\n        PR target/5312\n        * config/ia64/ia64.c: Include tm_p.h last.\n        (gen_nop_type): Remove duplicate definition.\n        (cycle_end_fill_slots): Set sched_data for second L slot.\n        (maybe_rotate): Call cycle_end_fill_slots to fill in nop slots.\n        (nop_cycles_until): Fix typos.\n\n        * gcc.dg/20020313-1.c: New.\n\nFrom-SVN: r50796", "tree": {"sha": "7fe6fd36020bab109c963fa72c45e1619edbf346", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/7fe6fd36020bab109c963fa72c45e1619edbf346"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/98d2b17e0c941e8e60055d10b36e2ceef522be92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d2b17e0c941e8e60055d10b36e2ceef522be92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/98d2b17e0c941e8e60055d10b36e2ceef522be92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/98d2b17e0c941e8e60055d10b36e2ceef522be92/comments", "author": null, "committer": null, "parents": [{"sha": "a541f1aa810c507bd578bd1046ac2da836b8088e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a541f1aa810c507bd578bd1046ac2da836b8088e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a541f1aa810c507bd578bd1046ac2da836b8088e"}], "stats": {"total": 125, "additions": 93, "deletions": 32}, "files": [{"sha": "558a1897bfabce89ea52f7ec12aa26715493bac2", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=98d2b17e0c941e8e60055d10b36e2ceef522be92", "patch": "@@ -1,3 +1,12 @@\n+2002-03-14  Richard Henderson  <rth@redhat.com>\n+\n+\tPR target/5312\n+\t* config/ia64/ia64.c: Include tm_p.h last.\n+\t(gen_nop_type): Remove duplicate definition.\n+\t(cycle_end_fill_slots): Set sched_data for second L slot.\n+\t(maybe_rotate): Call cycle_end_fill_slots to fill in nop slots.\n+\t(nop_cycles_until): Fix typos.\n+\n 2002-03-15  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR optimization/5891"}, {"sha": "4815301a637aa7a8c7ab39e58d19b137d6fad80e", "filename": "gcc/config/ia64/ia64.c", "status": "modified", "additions": 14, "deletions": 32, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2Fconfig%2Fia64%2Fia64.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2Fconfig%2Fia64%2Fia64.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fia64%2Fia64.c?ref=98d2b17e0c941e8e60055d10b36e2ceef522be92", "patch": "@@ -24,7 +24,6 @@ Boston, MA 02111-1307, USA.  */\n #include \"system.h\"\n #include \"rtl.h\"\n #include \"tree.h\"\n-#include \"tm_p.h\"\n #include \"regs.h\"\n #include \"hard-reg-set.h\"\n #include \"real.h\"\n@@ -46,6 +45,7 @@ Boston, MA 02111-1307, USA.  */\n #include \"timevar.h\"\n #include \"target.h\"\n #include \"target-def.h\"\n+#include \"tm_p.h\"\n \n /* This is used for communication between ASM_OUTPUT_LABEL and\n    ASM_OUTPUT_LABELREF.  */\n@@ -5478,32 +5478,6 @@ ia64_emit_insn_before (insn, before)\n   emit_insn_before (insn, before);\n }\n \n-#if 0\n-/* Generate a nop insn of the given type.  Note we never generate L type\n-   nops.  */\n-\n-static rtx\n-gen_nop_type (t)\n-     enum attr_type t;\n-{\n-  switch (t)\n-    {\n-    case TYPE_M:\n-      return gen_nop_m ();\n-    case TYPE_I:\n-      return gen_nop_i ();\n-    case TYPE_B:\n-      return gen_nop_b ();\n-    case TYPE_F:\n-      return gen_nop_f ();\n-    case TYPE_X:\n-      return gen_nop_x ();\n-    default:\n-      abort ();\n-    }\n-}\n-#endif\n-\n /* When rotating a bundle out of the issue window, insert a bundle selector\n    insn in front of it.  DUMP is the scheduling dump file or NULL.  START\n    is either 0 or 3, depending on whether we want to emit a bundle selector\n@@ -5568,8 +5542,8 @@ cycle_end_fill_slots (dump)\n \t  if (slot > sched_data.split)\n \t    abort ();\n \t  if (dump)\n-\t    fprintf (dump, \"// Packet needs %s, have %s\\n\", type_names[packet->t[slot]],\n-\t\t     type_names[t]);\n+\t    fprintf (dump, \"// Packet needs %s, have %s\\n\",\n+\t\t     type_names[packet->t[slot]], type_names[t]);\n \t  sched_data.types[slot] = packet->t[slot];\n \t  sched_data.insns[slot] = 0;\n \t  sched_data.stopbit[slot] = 0;\n@@ -5581,15 +5555,22 @@ cycle_end_fill_slots (dump)\n \n \t  slot++;\n \t}\n+\n       /* Do _not_ use T here.  If T == TYPE_A, then we'd risk changing the\n \t actual slot type later.  */\n       sched_data.types[slot] = packet->t[slot];\n       sched_data.insns[slot] = tmp_insns[i];\n       sched_data.stopbit[slot] = 0;\n       slot++;\n+\n       /* TYPE_L instructions always fill up two slots.  */\n       if (t == TYPE_L)\n-\tslot++;\n+\t{\n+\t  sched_data.types[slot] = packet->t[slot];\n+\t  sched_data.insns[slot] = 0;\n+\t  sched_data.stopbit[slot] = 0;\n+\t  slot++;\n+\t}\n     }\n \n   /* This isn't right - there's no need to pad out until the forced split;\n@@ -6065,6 +6046,7 @@ static void\n maybe_rotate (dump)\n      FILE *dump;\n {\n+  cycle_end_fill_slots (dump);\n   if (sched_data.cur == 6)\n     rotate_two_bundles (dump);\n   else if (sched_data.cur >= 3)\n@@ -6115,7 +6097,7 @@ nop_cycles_until (clock_var, dump)\n \t  for (i = sched_data.cur; i < split; i++)\n \t    {\n \t      rtx t = sched_emit_insn (gen_nop_type (sched_data.packet->t[i]));\n-\t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n+\t      sched_data.types[i] = sched_data.packet->t[i];\n \t      sched_data.insns[i] = t;\n \t      sched_data.stopbit[i] = 0;\n \t    }\n@@ -6129,7 +6111,7 @@ nop_cycles_until (clock_var, dump)\n \t  for (i = sched_data.cur; i < 6; i++)\n \t    {\n \t      rtx t = sched_emit_insn (gen_nop_type (sched_data.packet->t[i]));\n-\t      sched_data.types[i] = sched_data.packet->t[sched_data.cur];\n+\t      sched_data.types[i] = sched_data.packet->t[i];\n \t      sched_data.insns[i] = t;\n \t      sched_data.stopbit[i] = 0;\n \t    }"}, {"sha": "f0ae6d4bde44644aa9a4fcbce3ae90fc1727a294", "filename": "gcc/testsuite/gcc.dg/20020313-1.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2Ftestsuite%2Fgcc.dg%2F20020313-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/98d2b17e0c941e8e60055d10b36e2ceef522be92/gcc%2Ftestsuite%2Fgcc.dg%2F20020313-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2F20020313-1.c?ref=98d2b17e0c941e8e60055d10b36e2ceef522be92", "patch": "@@ -0,0 +1,70 @@\n+/* PR 5312 \n+   The problem here is that the ia64 scheduler saw a sequence of L L M type\n+   insns, and messed up its internal state on which slot it was issuing\n+   to, and aborted.  */\n+\n+/* { dg-do compile { target ia64-*-* } } */\n+/* { dg-options \"-O2 -mconstant-gp\" } */\n+\n+typedef unsigned long __u64;\n+typedef unsigned int __u32;\n+typedef struct { } spinlock_t;\n+struct cpuinfo_ia64 {\n+        union {\n+                struct {\n+                        __u32 irq_count;\n+                        __u32 bh_count;\n+                } f;\n+                __u64 irq_and_bh_counts;\n+        } irq_stat;\n+        __u32 softirq_pending;\n+} __attribute__ ((aligned ((1UL << 14)))) ;\n+enum\n+{\n+        TCA_UNSPEC,\n+        TCA_KIND,\n+        TCA_OPTIONS,\n+        TCA_STATS,\n+        TCA_XSTATS,\n+        TCA_RATE,\n+};\n+struct tc_stats\n+{\n+        __u64 bytes;\n+        __u32 packets;\n+        __u32 drops;\n+        __u32 overlimits;\n+        __u32 bps;\n+        __u32 pps;\n+        __u32 qlen;\n+        __u32 backlog;\n+        spinlock_t *lock;\n+};\n+struct sk_buff {\n+        unsigned int data_len;\n+        unsigned char *tail;\n+        unsigned char *end;\n+};\n+static inline int skb_is_nonlinear(const struct sk_buff *skb)\n+{\n+        return skb->data_len;\n+}\n+static inline int skb_tailroom(const struct sk_buff *skb)\n+{\n+        return skb_is_nonlinear(skb) ? 0 : skb->end-skb->tail;\n+}\n+struct rtattr\n+{\n+        unsigned short rta_len;\n+        unsigned short rta_type;\n+};\n+int qdisc_copy_stats(struct sk_buff *skb, struct tc_stats *st)\n+{\n+        do { do { (((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->irq_stat.f.bh_count)++; __asm__ __volatile__(\"\": : :\"memory\"); } while (0); (void)(st->lock); } while (0);\n+        ({ if (skb_tailroom(skb) < (int)( (((( ((sizeof(struct rtattr))+4 -1) & ~(4 -1) ) + ((char*)&st->lock - (char*)st)))+4 -1) & ~(4 -1) )) goto rtattr_failure; __rta_fill(skb, TCA_STATS, (char*)&st->lock - (char*)st, st); });\n+        do { do { } while(0); do { do { __asm__ __volatile__(\"\": : :\"memory\"); (((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->irq_stat.f.bh_count)--; } while (0); if (__builtin_expect((((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->softirq_pending), 0) && (((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->irq_stat.f.bh_count) == 0) do_softirq(); } while (0); } while (0);\n+        return 0;\n+rtattr_failure:\n+        do { do { } while(0); do { do { __asm__ __volatile__(\"\": : :\"memory\"); (((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->irq_stat.f.bh_count)--; } while (0); if (__builtin_expect((((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->softirq_pending), 0) && (((struct cpuinfo_ia64 *) (0xa000000000000000 + 2*(1UL << 14)))->irq_stat.f.bh_count) == 0) do_softirq(); } while (0); } while (0);\n+        return -1;\n+}"}]}