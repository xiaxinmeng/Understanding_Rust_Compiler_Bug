{"sha": "cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Y2VhNWNhNmFmNDIyMjRjMTNkNzFjNWQ5ZWNkMzgwNDcxZDljMGI2Yg==", "commit": {"author": {"name": "Michael Koch", "email": "konqueror@gmx.de", "date": "2003-06-17T12:01:37Z"}, "committer": {"name": "Michael Koch", "email": "mkoch@gcc.gnu.org", "date": "2003-06-17T12:01:37Z"}, "message": "ArrayHelper.java, [...]: Reformatted to match classpath's versions.\n\n2003-06-17  Michael Koch  <konqueror@gmx.de>\n\n\t* gnu/java/lang/ArrayHelper.java,\n\tgnu/java/lang/ClassHelper.java:\n\tReformatted to match classpath's versions.\n\nFrom-SVN: r68078", "tree": {"sha": "a37c90d42d2a4afa1f45648bea1ebfadc52f852d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a37c90d42d2a4afa1f45648bea1ebfadc52f852d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/comments", "author": null, "committer": null, "parents": [{"sha": "c1e5104dee7fbf35c21319710000a36009b4f92f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c1e5104dee7fbf35c21319710000a36009b4f92f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c1e5104dee7fbf35c21319710000a36009b4f92f"}], "stats": {"total": 409, "additions": 187, "deletions": 222}, "files": [{"sha": "d43c1db5b66a2aba48703ac493e1c195c069ba40", "filename": "libjava/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "patch": "@@ -1,3 +1,9 @@\n+2003-06-17  Michael Koch  <konqueror@gmx.de>\n+\n+\t* gnu/java/lang/ArrayHelper.java,\n+\tgnu/java/lang/ClassHelper.java:\n+\tReformatted to match classpath's versions.\n+\n 2003-06-14  Michael Koch  <konqueror@gmx.de>\n \n \t* gnu/java/nio/FileChannelImpl.java"}, {"sha": "0216caba167c75566370cb676012480b0cbfd299", "filename": "libjava/gnu/java/lang/ArrayHelper.java", "status": "modified", "additions": 38, "deletions": 21, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FArrayHelper.java?ref=cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "patch": "@@ -1,13 +1,13 @@\n-/* gnu.java.lang.ArrayHelper\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* ArrayHelper.java -- Helper methods for handling array operations\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -39,25 +39,42 @@\n package gnu.java.lang;\n \n /**\n- ** ArrayHelper helps you do things with arrays.\n- **\n- ** @author John Keiser\n- ** @version 1.1.0, 29 Jul 1998\n- **/\n-\n-public class ArrayHelper {\n-\tpublic static boolean contains(Object[] array, Object searchFor) {\n-\t\treturn indexOf(array,searchFor) != -1;\n-\t}\n+ * ArrayHelper helps you do things with arrays.\n+ *\n+ * @author John Keiser\n+ */\n+public class ArrayHelper\n+{\n+  /**\n+   * Counterpart to java.util.Collection.contains.\n+   *\n+   * @param array the array to search\n+   * @param searchFor the object to locate\n+   * @return true if some array element <code>equals(searchFor)</code>\n+   */\n+  public static boolean contains(Object[] array, Object searchFor)\n+  {\n+    return indexOf(array, searchFor) != -1;\n+  }\n \n-\tpublic static int indexOf(Object[] array, Object searchFor) {\n-\t\tfor(int i=0;i<array.length;i++) {\n-\t\t\tif(array[i].equals(searchFor)) {\n-\t\t\t\treturn i;\n-\t\t\t}\n-\t\t}\n-\t\treturn -1;\n-\t}\n+  /**\n+   * Counterpart to java.util.Collection.indexOf.\n+   *\n+   * @param array the array to search\n+   * @param searchFor the object to locate\n+   * @return the index of the first equal object, or -1\n+   */\n+  public static int indexOf(Object[] array, Object searchFor)\n+  {\n+    for (int i = 0; i < array.length; i++)\n+      {\n+        if(array[i].equals(searchFor))\n+          {\n+            return i;\n+          }\n+      }\n+    return -1;\n+  }\n \n \tpublic static boolean equalsArray(Object[] a, Object[] b) {\n \t\tif(a.length == b.length) {"}, {"sha": "16d699e3453e18311d2d8d76ce12aec1d9c6774f", "filename": "libjava/gnu/java/lang/ClassHelper.java", "status": "modified", "additions": 143, "deletions": 201, "changes": 344, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/cea5ca6af42224c13d71c5d9ecd380471d9c0b6b/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fjava%2Flang%2FClassHelper.java?ref=cea5ca6af42224c13d71c5d9ecd380471d9c0b6b", "patch": "@@ -1,13 +1,13 @@\n-/* gnu.java.lang.ClassHelper\n-   Copyright (C) 1998 Free Software Foundation, Inc.\n+/* ClassHelper.java -- Utility methods to augment java.lang.Class\n+   Copyright (C) 1998, 2002 Free Software Foundation, Inc.\n \n This file is part of GNU Classpath.\n \n GNU Classpath is free software; you can redistribute it and/or modify\n it under the terms of the GNU General Public License as published by\n the Free Software Foundation; either version 2, or (at your option)\n any later version.\n- \n+\n GNU Classpath is distributed in the hope that it will be useful, but\n WITHOUT ANY WARRANTY; without even the implied warranty of\n MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n@@ -42,202 +42,144 @@\n import java.lang.reflect.*;\n \n /**\n- ** ClassHelper has various methods that ought to have been\n- ** in class.\n- **\n- ** @author John Keiser\n- ** @version 1.1.0, 29 Jul 1998\n- **/\n-\n-public class ClassHelper {\n-\t/** Strip the package part from the class name.\n-\t ** @param clazz the class to get the truncated name from\n-\t ** @return the truncated class name.\n-\t **/\n-\tpublic static String getTruncatedClassName(Class clazz) {\n-\t\treturn getTruncatedName(clazz.getName());\n-\t}\n-\t/** Strip the package part from the class name, or the\n-\t ** class part from the method or field name.\n-\t ** @param name the name to truncate.\n-\t ** @return the truncated name.\n-\t **/\n-\tpublic static String getTruncatedName(String name) {\n-\t\tint lastInd = name.lastIndexOf('.');\n-\t\tif(lastInd == -1) {\n-\t\t\treturn name;\n-\t\t} else {\n-\t\t\treturn name.substring(lastInd+1);\n-\t\t}\n-\t}\n-\n-\t/** Strip the last portion of the name (after the last\n-\t ** dot).\n-\t ** @param name the name to get package of.\n-\t ** @return the package name.  \"\" if no package.\n-\t **/\n-\tpublic static String getPackagePortion(String name) {\n-\t\tint lastInd = name.lastIndexOf('.');\n-\t\tif(lastInd == -1) {\n-\t\t\treturn \"\";\n-\t\t} else {\n-\t\t\treturn name.substring(0,lastInd);\n-\t\t}\n-\t}\n-\n-\tstatic Hashtable allMethods = new Hashtable();\n-\tstatic Hashtable allMethodsAtDeclaration = new Hashtable();\n-\n-\t/** Get all the methods, public, private and\n-\t ** otherwise, from the class, getting them\n-\t ** from the most recent class to find them.\n-\t **/\n-\tpublic static Method[] getAllMethods(Class clazz) {\n-\t\tMethod[] retval = (Method[])allMethods.get(clazz);\n-\t\tif(retval == null) {\n-\t\t\tMethod[] superMethods;\n-\t\t\tif(clazz.getSuperclass() != null) {\n-\t\t\t\tsuperMethods = getAllMethods(clazz.getSuperclass());\n-\t\t\t} else {\n-\t\t\t\tsuperMethods = new Method[0];\n-\t\t\t}\n-\t\t\tVector v = new Vector();\n-\t\t\tMethod[] currentMethods = clazz.getDeclaredMethods();\n-\t\t\tfor(int i=0;i<currentMethods.length;i++) {\n-\t\t\t\tv.addElement(currentMethods[i]);\n-\t\t\t}\n-\t\t\tfor(int i=0;i<superMethods.length;i++) {\n-\t\t\t\tboolean addOK = true;\n-\t\t\t\tfor(int j=0;j<currentMethods.length;j++) {\n-\t\t\t\t\tif(getTruncatedName(superMethods[i].getName()).equals(getTruncatedName(currentMethods[j].getName()))\n-\t\t\t\t\t   && ArrayHelper.equalsArray(superMethods[i].getParameterTypes(),currentMethods[j].getParameterTypes())) {\n-\t\t\t\t\t\taddOK = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(addOK) {\n-\t\t\t\t\tv.addElement(superMethods[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tretval = new Method[v.size()];\n-\t\t\tv.copyInto(retval);\n-\t\t\tallMethods.put(clazz,retval);\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/** Get all the methods, public, private and\n-\t ** otherwise, from the class, and get them from\n-\t ** their point of declaration.\n-\t **/\n-\tpublic static Method[] getAllMethodsAtDeclaration(Class clazz) {\n-\t\tMethod[] retval = (Method[])allMethodsAtDeclaration.get(clazz);\n-\t\tif(retval == null) {\n-\t\t\tMethod[] superMethods;\n-\t\t\tif(clazz.getSuperclass() != null) {\n-\t\t\t\tsuperMethods = getAllMethodsAtDeclaration(clazz.getSuperclass());\n-\t\t\t} else {\n-\t\t\t\tsuperMethods = new Method[0];\n-\t\t\t}\n-\t\t\tVector v = new Vector();\n-\t\t\tMethod[] currentMethods = clazz.getDeclaredMethods();\n-\t\t\tfor(int i=0;i<superMethods.length;i++) {\n-\t\t\t\tv.addElement(superMethods[i]);\n-\t\t\t}\n-\t\t\tfor(int i=0;i<superMethods.length;i++) {\n-\t\t\t\tboolean addOK = true;\n-\t\t\t\tfor(int j=0;j<currentMethods.length;j++) {\n-\t\t\t\t\tif(getTruncatedName(superMethods[i].getName()).equals(getTruncatedName(currentMethods[j].getName()))\n-\t\t\t\t\t   && ArrayHelper.equalsArray(superMethods[i].getParameterTypes(),currentMethods[j].getParameterTypes())) {\n-\t\t\t\t\t\taddOK = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(addOK) {\n-\t\t\t\t\tv.addElement(superMethods[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tretval = new Method[v.size()];\n-\t\t\tv.copyInto(retval);\n-\t\t\tallMethodsAtDeclaration.put(clazz,retval);\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\tstatic Hashtable allFields = new Hashtable();\n-\tstatic Hashtable allFieldsAtDeclaration = new Hashtable();\n-\n-\t/** Get all the fields, public, private and\n-\t ** otherwise, from the class, getting them\n-\t ** from the most recent class to find them.\n-\t **/\n-\tpublic static Field[] getAllFields(Class clazz) {\n-\t\tField[] retval = (Field[])allFields.get(clazz);\n-\t\tif(retval == null) {\n-\t\t\tField[] superFields;\n-\t\t\tif(clazz.getSuperclass() != null) {\n-\t\t\t\tsuperFields = getAllFields(clazz.getSuperclass());\n-\t\t\t} else {\n-\t\t\t\tsuperFields = new Field[0];\n-\t\t\t}\n-\t\t\tVector v = new Vector();\n-\t\t\tField[] currentFields = clazz.getDeclaredFields();\n-\t\t\tfor(int i=0;i<currentFields.length;i++) {\n-\t\t\t\tv.addElement(currentFields[i]);\n-\t\t\t}\n-\t\t\tfor(int i=0;i<superFields.length;i++) {\n-\t\t\t\tboolean addOK = true;\n-\t\t\t\tfor(int j=0;j<currentFields.length;j++) {\n-\t\t\t\t\tif(getTruncatedName(superFields[i].getName()).equals(getTruncatedName(currentFields[j].getName()))) {\n-\t\t\t\t\t\taddOK = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(addOK) {\n-\t\t\t\t\tv.addElement(superFields[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tretval = new Field[v.size()];\n-\t\t\tv.copyInto(retval);\n-\t\t\tallFields.put(clazz,retval);\n-\t\t}\n-\t\treturn retval;\n-\t}\n-\n-\t/** Get all the fields, public, private and\n-\t ** otherwise, from the class, and get them from\n-\t ** their point of declaration.\n-\t **/\n-\tpublic static Field[] getAllFieldsAtDeclaration(Class clazz) {\n-\t\tField[] retval = (Field[])allFieldsAtDeclaration.get(clazz);\n-\t\tif(retval == null) {\n-\t\t\tField[] superFields;\n-\t\t\tif(clazz.getSuperclass() != null) {\n-\t\t\t\tsuperFields = getAllFieldsAtDeclaration(clazz.getSuperclass());\n-\t\t\t} else {\n-\t\t\t\tsuperFields = new Field[0];\n-\t\t\t}\n-\t\t\tVector v = new Vector();\n-\t\t\tField[] currentFields = clazz.getDeclaredFields();\n-\t\t\tfor(int i=0;i<superFields.length;i++) {\n-\t\t\t\tv.addElement(superFields[i]);\n-\t\t\t}\n-\t\t\tfor(int i=0;i<superFields.length;i++) {\n-\t\t\t\tboolean addOK = true;\n-\t\t\t\tfor(int j=0;j<currentFields.length;j++) {\n-\t\t\t\t\tif(getTruncatedName(superFields[i].getName()).equals(getTruncatedName(currentFields[j].getName()))) {\n-\t\t\t\t\t\taddOK = false;\n-\t\t\t\t\t}\n-\t\t\t\t}\n-\t\t\t\tif(addOK) {\n-\t\t\t\t\tv.addElement(superFields[i]);\n-\t\t\t\t}\n-\t\t\t}\n-\n-\t\t\tretval = new Field[v.size()];\n-\t\t\tv.copyInto(retval);\n-\t\t\tallFieldsAtDeclaration.put(clazz,retval);\n-\t\t}\n-\t\treturn retval;\n-\t}\n+ * ClassHelper has various methods that ought to have been in Class.\n+ *\n+ * @author John Keiser\n+ * @author Eric Blake <ebb9@email.byu.edu>\n+ */\n+public class ClassHelper\n+{\n+  /**\n+   * Strip the package part from the class name.\n+   *\n+   * @param clazz the class to get the truncated name from\n+   * @return the truncated class name\n+   */\n+  public static String getTruncatedClassName(Class clazz)\n+  {\n+    return getTruncatedName(clazz.getName());\n+  }\n+\n+  /**\n+   * Strip the package part from the class name, or the class part from\n+   * the method or field name.\n+   *\n+   * @param name the name to truncate\n+   * @return the truncated name\n+   */\n+  public static String getTruncatedName(String name)\n+  {\n+    int lastInd = name.lastIndexOf('.');\n+    if (lastInd == -1)\n+      return name;\n+    return name.substring(lastInd + 1);\n+  }\n+\n+  /**\n+   * Strip the last portion of the name (after the last dot).\n+   *\n+   * @param name the name to get package of\n+   * @return the package name, or \"\" if no package\n+   */\n+  public static String getPackagePortion(String name)\n+  {\n+    int lastInd = name.lastIndexOf('.');\n+    if (lastInd == -1)\n+      return \"\";\n+    return name.substring(0, lastInd);\n+  }\n+\n+  /** Cache of methods found in getAllMethods(). */\n+  private static Map allMethods = new HashMap();\n+\n+  /**\n+   * Get all the methods, public, private and otherwise, from the class,\n+   * getting them from the most recent class to find them. This may not\n+   * be quite the correct approach, as this includes methods that are not\n+   * inherited or accessible from clazz, so beware.\n+   *\n+   * @param clazz the class to start at\n+   * @return all methods declared or inherited in clazz\n+   */\n+  public static Method[] getAllMethods(Class clazz)\n+  {\n+    Method[] retval = (Method[]) allMethods.get(clazz);\n+    if (retval == null)\n+      {\n+        Set methods = new HashSet();\n+        Class c = clazz;\n+        while (c != null)\n+          {\n+            Method[] currentMethods = c.getDeclaredMethods();\n+          loop:\n+            for (int i = 0; i < currentMethods.length; i++)\n+              {\n+                Method current = currentMethods[i];\n+                int size = methods.size();\n+                Iterator iter = methods.iterator();\n+                while (--size >= 0)\n+                  {\n+                    Method override = (Method) iter.next();\n+                    if (current.getName().equals(override.getName())\n+                        && Arrays.equals(current.getParameterTypes(),\n+                                         override.getParameterTypes())\n+                        && current.getReturnType() == override.getReturnType())\n+                      continue loop;\n+                  }\n+                methods.add(current);\n+              }\n+            c = c.getSuperclass();\n+          }\n+        retval = new Method[methods.size()];\n+        methods.toArray(retval);\n+        allMethods.put(clazz, retval);\n+      }\n+    return retval;\n+  }\n+\n+  /** Cache of fields found in getAllFields(). */\n+  private static Map allFields = new HashMap();\n+\n+  /**\n+   * Get all the fields, public, private and otherwise, from the class,\n+   * getting them from the most recent class to find them. This may not\n+   * be quite the correct approach, as this includes fields that are not\n+   * inherited or accessible from clazz, so beware.\n+   *\n+   * @param clazz the class to start at\n+   * @return all fields declared or inherited in clazz\n+   */\n+  public static Field[] getAllFields(Class clazz)\n+  {\n+    Field[] retval = (Field[]) allFields.get(clazz);\n+    if (retval == null)\n+      {\n+        Set fields = new HashSet();\n+        Class c = clazz;\n+        while (c != null)\n+          {\n+            Field[] currentFields = c.getDeclaredFields();\n+          loop:\n+            for (int i = 0; i < currentFields.length; i++)\n+              {\n+                Field current = currentFields[i];\n+                int size = fields.size();\n+                Iterator iter = fields.iterator();\n+                while (--size >= 0)\n+                  {\n+                    Field override = (Field) iter.next();\n+                    if (current.getName().equals(override.getName())\n+                        && current.getType() == override.getType())\n+                      continue loop;\n+                  }\n+                fields.add(current);\n+              }\n+            c = c.getSuperclass();\n+          }\n+        retval = new Field[fields.size()];\n+        fields.toArray(retval);\n+        allFields.put(clazz, retval);\n+      }\n+    return retval;\n+  }\n }"}]}