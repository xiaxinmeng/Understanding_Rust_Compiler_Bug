{"sha": "0817c29a423aca1c4c3f9ba812f67df35f36fc65", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDgxN2MyOWE0MjNhY2ExYzRjM2Y5YmE4MTJmNjdkZjM1ZjM2ZmM2NQ==", "commit": {"author": {"name": "Philip Herron", "email": "philip.herron@embecosm.com", "date": "2021-01-21T17:31:21Z"}, "committer": {"name": "Philip Herron", "email": "herron.philip@googlemail.com", "date": "2021-01-26T11:59:39Z"}, "message": "Add Integer and Float InterenceVariable\n\nIn order to properly handle all integer types and infer we must follow HM\nalgorithm. This means when we unify every type in the resolver this should\nkeep a chain of HirId of references such that when/if the type is resolved\nit lookup tables can be updated for the Backend to compile to Gimple.\n\nConsider the case:\n\nfn test(x:u32) -> u32 {...}\nlet a = test(1);\n\nThe VarDecl here will have the type let a:<I?> = test<u32>(1<I?>).\nSince this integer combines with the parameter x:u32 the type resolver\nknows at this point these must be a u32.\n\nlet a;\na = 1;\nlet b:u32 = a;\n\nThis is more subtle\n\nlet a:<?>\na:<?> = 1<I?>\nlet b:u32 = a<I?>;\n\nSince the integer inference variable combines with u32 all previous\nreferences can be updated to u32 at this point.\n\nIn the basic case of:\n\nlet a;\na = 1;\n\nThis resolves down to:\n\nlet a:<I?>;\na<I?> = 1<I?>\n\nIt is not until we complete type-inference we can iterate all the\nresolved types and HirIds and default any <I?> to i32 and any <F?> to f32.\nAny remaining general inference variable are errors.", "tree": {"sha": "942c0d79f3f5063361fb0cae8057bb8ab8b29940", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/942c0d79f3f5063361fb0cae8057bb8ab8b29940"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0817c29a423aca1c4c3f9ba812f67df35f36fc65", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0817c29a423aca1c4c3f9ba812f67df35f36fc65", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0817c29a423aca1c4c3f9ba812f67df35f36fc65", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0817c29a423aca1c4c3f9ba812f67df35f36fc65/comments", "author": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "committer": {"login": "philberty", "id": 84585, "node_id": "MDQ6VXNlcjg0NTg1", "avatar_url": "https://avatars.githubusercontent.com/u/84585?v=4", "gravatar_id": "", "url": "https://api.github.com/users/philberty", "html_url": "https://github.com/philberty", "followers_url": "https://api.github.com/users/philberty/followers", "following_url": "https://api.github.com/users/philberty/following{/other_user}", "gists_url": "https://api.github.com/users/philberty/gists{/gist_id}", "starred_url": "https://api.github.com/users/philberty/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/philberty/subscriptions", "organizations_url": "https://api.github.com/users/philberty/orgs", "repos_url": "https://api.github.com/users/philberty/repos", "events_url": "https://api.github.com/users/philberty/events{/privacy}", "received_events_url": "https://api.github.com/users/philberty/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "5294dfe7dce7a58fbaf2131c7589d115008ebf0e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5294dfe7dce7a58fbaf2131c7589d115008ebf0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5294dfe7dce7a58fbaf2131c7589d115008ebf0e"}], "stats": {"total": 1728, "additions": 1115, "deletions": 613}, "files": [{"sha": "ed03f02f33520d3f87c692838c638d8999ad59dd", "filename": "gcc/rust/backend/rust-compile-context.h", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-context.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-context.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -298,6 +298,37 @@ class TyTyResolveCompile : public TyTy::TyVisitor\n     translated = named_struct;\n   }\n \n+  void visit (TyTy::TupleType &type) override\n+  {\n+    bool ok = ctx->lookup_compiled_types (type.get_ty_ref (), &translated);\n+    if (ok)\n+      return;\n+\n+    // create implicit struct\n+    std::vector<Backend::Btyped_identifier> fields;\n+    for (size_t i = 0; i < type.num_fields (); i++)\n+      {\n+\tTyTy::TyBase *field = type.get_field (i);\n+\tBtype *compiled_field_ty\n+\t  = TyTyCompile::compile (ctx->get_backend (), field);\n+\n+\tBackend::Btyped_identifier f (std::to_string (i), compiled_field_ty,\n+\t\t\t\t      ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\ttype.get_ty_ref ()));\n+\tfields.push_back (std::move (f));\n+      }\n+\n+    Btype *struct_type_record = ctx->get_backend ()->struct_type (fields);\n+    Btype *named_struct\n+      = ctx->get_backend ()->named_type (type.as_string (), struct_type_record,\n+\t\t\t\t\t ctx->get_mappings ()->lookup_location (\n+\t\t\t\t\t   type.get_ty_ref ()));\n+\n+    ctx->push_type (named_struct);\n+    ctx->insert_compiled_type (type.get_ty_ref (), named_struct);\n+    translated = named_struct;\n+  }\n+\n   void visit (TyTy::ArrayType &type) override\n   {\n     mpz_t ival;"}, {"sha": "7c2f32d3a3d0e7ce2215cdb6dcbb52964ac148d5", "filename": "gcc/rust/backend/rust-compile-expr.h", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-expr.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -145,17 +145,19 @@ class CompileExpr : public HIRCompileBase\n \n   void visit (HIR::LiteralExpr &expr)\n   {\n+    auto literal_value = expr.get_literal ();\n     switch (expr.get_lit_type ())\n       {\n \tcase HIR::Literal::BOOL: {\n-\t  bool bval = expr.as_string ().compare (\"true\") == 0;\n+\t  bool bval = literal_value->as_string ().compare (\"true\") == 0;\n \t  translated = ctx->get_backend ()->boolean_constant_expression (bval);\n \t}\n \treturn;\n \n \tcase HIR::Literal::INT: {\n \t  mpz_t ival;\n-\t  if (mpz_init_set_str (ival, expr.as_string ().c_str (), 10) != 0)\n+\t  if (mpz_init_set_str (ival, literal_value->as_string ().c_str (), 10)\n+\t      != 0)\n \t    {\n \t      rust_fatal_error (expr.get_locus (), \"bad number in literal\");\n \t      return;\n@@ -178,7 +180,7 @@ class CompileExpr : public HIRCompileBase\n \n \tcase HIR::Literal::FLOAT: {\n \t  mpfr_t fval;\n-\t  if (mpfr_init_set_str (fval, expr.as_string ().c_str (), 10,\n+\t  if (mpfr_init_set_str (fval, literal_value->as_string ().c_str (), 10,\n \t\t\t\t MPFR_RNDN)\n \t      != 0)\n \t    {"}, {"sha": "b6794bc352edea86d5b30f732d6b8340547a5853", "filename": "gcc/rust/backend/rust-compile-tyty.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fbackend%2Frust-compile-tyty.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -52,6 +52,8 @@ class TyTyCompile : public TyTy::TyVisitor\n \n   void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n \n+  void visit (TyTy::TupleType &type) override { gcc_unreachable (); }\n+\n   void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n \n   void visit (TyTy::UnitType &type) override"}, {"sha": "69b680d27520571b47943f43ab14abf59a403ebf", "filename": "gcc/rust/hir/tree/rust-hir-expr.h", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-expr.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -61,7 +61,11 @@ class LiteralExpr : public ExprWithoutBlock\n   Location locus;\n \n public:\n-  std::string as_string () const override { return literal.as_string (); }\n+  std::string as_string () const override\n+  {\n+    return \"( \" + literal.as_string () + \" (\" + get_mappings ().as_string ()\n+\t   + \"))\";\n+  }\n \n   Literal::LitType get_lit_type () const { return literal.get_lit_type (); }\n "}, {"sha": "b727917c2f1b53af483d98ee24fe7cd1039d3f1d", "filename": "gcc/rust/hir/tree/rust-hir-full-test.cc", "status": "modified", "additions": 5, "deletions": 13, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir-full-test.cc?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -2072,23 +2072,15 @@ ArithmeticOrLogicalExpr::as_string () const\n       operator_str = \">>\";\n       break;\n     default:\n-      operator_str = \"invalid operator. wtf\";\n+      gcc_unreachable ();\n       break;\n     }\n \n-  std::string str (\"ArithmeticOrLogicalExpr: \");\n-  if (main_or_left_expr == nullptr || right_expr == nullptr)\n-    {\n-      str += \"error. this is probably a parsing failure.\";\n-    }\n-  else\n-    {\n-      str += main_or_left_expr->as_string () + \" \";\n-      str += operator_str + \" \";\n-      str += right_expr->as_string ();\n-    }\n+  std::string str = main_or_left_expr->as_string () + \" \";\n+  str += operator_str + \" \";\n+  str += right_expr->as_string ();\n \n-  return str + \"::\" + get_mappings ().as_string ();\n+  return \"( \" + str + \" (\" + get_mappings ().as_string () + \"))\";\n }\n \n std::string"}, {"sha": "e4a81c501ae1e6887e9ae0e8aa065169c5656566", "filename": "gcc/rust/hir/tree/rust-hir.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Fhir%2Ftree%2Frust-hir.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -895,7 +895,10 @@ class IdentifierExpr : public ExprWithoutBlock\n       ident (std::move (ident)), locus (locus)\n   {}\n \n-  std::string as_string () const override { return ident; }\n+  std::string as_string () const override\n+  {\n+    return \"( \" + ident + \" (\" + get_mappings ().as_string () + \"))\";\n+  }\n \n   Location get_locus () const { return locus; }\n   Location get_locus_slow () const override { return get_locus (); }\n@@ -908,6 +911,8 @@ class IdentifierExpr : public ExprWithoutBlock\n     return std::unique_ptr<IdentifierExpr> (clone_identifier_expr_impl ());\n   }\n \n+  Identifier get_identifier () const { return ident; }\n+\n protected:\n   // Clone method implementation\n   IdentifierExpr *clone_expr_without_block_impl () const override"}, {"sha": "281049dceb03e1c75541d0cbc8a98351d619e8db", "filename": "gcc/rust/rust-session-manager.cc", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Frust-session-manager.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Frust-session-manager.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Frust-session-manager.cc?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -34,6 +34,7 @@\n #include \"rust-ast-resolve.h\"\n #include \"rust-ast-lower.h\"\n #include \"rust-hir-type-check.h\"\n+#include \"rust-tycheck-dump.h\"\n #include \"rust-compile.h\"\n \n extern Linemap *\n@@ -548,6 +549,10 @@ Session::parse_file (const char *filename)\n   // type resolve\n   type_resolution (hir);\n \n+  // FIXME this needs an option of itself\n+  // auto buf = Resolver::TypeResolverDump::go (hir);\n+  // fprintf (stderr, \"%s\\n\", buf.c_str ());\n+\n   if (saw_errors ())\n     return;\n "}, {"sha": "8f60f72e62c988426cc87a1f74cce4c94abe0be1", "filename": "gcc/rust/typecheck/rust-hir-type-check-expr.h", "status": "modified", "additions": 170, "deletions": 79, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-expr.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -23,7 +23,6 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty.h\"\n #include \"rust-tyty-call.h\"\n-#include \"rust-tyty-resolver.h\"\n #include \"rust-hir-type-check-struct-field.h\"\n \n namespace Rust {\n@@ -38,10 +37,15 @@ class TypeCheckExpr : public TypeCheckBase\n     expr->accept_vis (resolver);\n \n     if (resolver.infered == nullptr)\n-      resolver.infered\n-\t= new TyTy::UnitType (expr->get_mappings ().get_hirid ());\n+      {\n+\tresolver.infered\n+\t  = new TyTy::UnitType (expr->get_mappings ().get_hirid ());\n+      }\n \n+    auto ref = expr->get_mappings ().get_hirid ();\n+    resolver.infered->set_ref (ref);\n     resolver.context->insert_type (expr->get_mappings (), resolver.infered);\n+\n     return resolver.infered;\n   }\n \n@@ -54,14 +58,40 @@ class TypeCheckExpr : public TypeCheckBase\n \t\t       \"failed to resolve TupleIndexExpr receiver\");\n \treturn;\n       }\n-    if (resolved->get_kind () != TyTy::TypeKind::ADT)\n+\n+    bool is_valid_type = resolved->get_kind () == TyTy::TypeKind::ADT\n+\t\t\t || resolved->get_kind () == TyTy::TypeKind::TUPLE;\n+    if (!is_valid_type)\n       {\n \trust_error_at (expr.get_tuple_expr ()->get_locus_slow (),\n-\t\t       \"Expected ADT type got: %s\",\n+\t\t       \"Expected Tuple or ADT got: %s\",\n \t\t       resolved->as_string ().c_str ());\n \treturn;\n       }\n \n+    if (resolved->get_kind () == TyTy::TypeKind::TUPLE)\n+      {\n+\tTyTy::TupleType *tuple = (TyTy::TupleType *) resolved;\n+\tTupleIndex index = expr.get_tuple_index ();\n+\tif ((size_t) index >= tuple->num_fields ())\n+\t  {\n+\t    rust_error_at (expr.get_locus (), \"unknown field at index %i\",\n+\t\t\t   index);\n+\t    return;\n+\t  }\n+\n+\tauto field_tyty = tuple->get_field ((size_t) index);\n+\tif (field_tyty == nullptr)\n+\t  {\n+\t    rust_error_at (expr.get_locus (),\n+\t\t\t   \"failed to lookup field type at index %i\", index);\n+\t    return;\n+\t  }\n+\n+\tinfered = field_tyty;\n+\treturn;\n+      }\n+\n     TyTy::ADTType *adt = (TyTy::ADTType *) resolved;\n     TupleIndex index = expr.get_tuple_index ();\n     if ((size_t) index >= adt->num_fields ())\n@@ -94,34 +124,32 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    size_t index = 0;\n-    std::string identifier = \"(\";\n-    std::vector<TyTy::StructFieldType *> fields;\n+    std::vector<HirId> fields;\n     for (auto &elem : expr.get_tuple_elems ())\n       {\n \tauto field_ty = TypeCheckExpr::Resolve (elem.get ());\n-\tidentifier += field_ty->as_string ();\n-\tif ((index + 1) < expr.get_tuple_elems ().size ())\n-\t  identifier += \",\";\n-\n-\tauto field_tyty\n-\t  = new TyTy::StructFieldType (elem->get_mappings ().get_hirid (),\n-\t\t\t\t       std::to_string (index), field_ty);\n-\tfields.push_back (field_tyty);\n-\tindex++;\n-      }\n-    identifier += \")\";\n-    infered = new TyTy::ADTType (expr.get_mappings ().get_hirid (), identifier,\n-\t\t\t\t true, fields);\n+\tfields.push_back (field_ty->get_ref ());\n+      }\n+    infered = new TyTy::TupleType (expr.get_mappings ().get_hirid (), fields);\n   }\n \n   void visit (HIR::ReturnExpr &expr)\n   {\n-    auto ret = context->peek_return_type ();\n-    rust_assert (ret != nullptr);\n+    auto fn_return_tyty = context->peek_return_type ();\n+    rust_assert (fn_return_tyty != nullptr);\n \n     auto expr_ty = TypeCheckExpr::Resolve (expr.get_expr ());\n-    infered = ret->combine (expr_ty);\n+    if (expr_ty == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failed to resolve type for ReturnExpr\");\n+\treturn;\n+      }\n+\n+    infered = fn_return_tyty->combine (expr_ty);\n+    fn_return_tyty->append_reference (expr_ty->get_ref ());\n+    for (auto &ref : infered->get_combined_refs ())\n+      fn_return_tyty->append_reference (ref);\n   }\n \n   void visit (HIR::CallExpr &expr)\n@@ -163,15 +191,13 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    infered = TyTy::TypeCheckCallExpr::go (lookup, expr);\n+    infered = TyTy::TypeCheckCallExpr::go (lookup, expr, context);\n     if (infered == nullptr)\n       {\n \trust_error_at (expr.get_locus (), \"failed to lookup type to CallExpr\");\n \treturn;\n       }\n \n-    TyTy::InferType infer (expr.get_mappings ().get_hirid ());\n-    infered = infer.combine (infered);\n     infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n@@ -181,6 +207,12 @@ class TypeCheckExpr : public TypeCheckBase\n     auto rhs = TypeCheckExpr::Resolve (expr.get_rhs ());\n \n     infered = lhs->combine (rhs);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"failure in TypeInference AssignmentExpr\");\n+\treturn;\n+      }\n \n     // in the case of declare first for an ADT Type:\n     //\n@@ -191,36 +223,34 @@ class TypeCheckExpr : public TypeCheckBase\n     // The lhs will have a TyTy of INFER and so when the declaration is\n     // referenced it will still have an unknown type so we will fail to resolve\n     // FieldAccessExpr\n-    if (lhs->get_kind () == TyTy::TypeKind::INFER)\n-      {\n-\tNodeId ast_node_id = expr.get_lhs ()->get_mappings ().get_nodeid ();\n-\tNodeId ref_node_id;\n-\tif (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n-\t  return;\n \n-\tDefinition def;\n-\tif (!resolver->lookup_definition (ref_node_id, &def))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"assignment infer - unknown reference\");\n-\t    return;\n-\t  }\n+    NodeId ast_node_id = expr.get_lhs ()->get_mappings ().get_nodeid ();\n+    NodeId ref_node_id;\n+    if (!resolver->lookup_resolved_name (ast_node_id, &ref_node_id))\n+      return;\n \n-\tHirId ref;\n-\tif (!mappings->lookup_node_to_hir (\n-\t      expr.get_mappings ().get_crate_num (), def.parent, &ref))\n-\t  {\n-\t    rust_error_at (expr.get_locus (),\n-\t\t\t   \"assignment infer - reverse lookup failure\");\n-\t    return;\n-\t  }\n+    Definition def;\n+    if (!resolver->lookup_definition (ref_node_id, &def))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"assignment infer - unknown reference\");\n+\treturn;\n+      }\n \n-\tcontext->insert_type (\n-\t  Analysis::NodeMapping (\n-\t    expr.get_lhs ()->get_mappings ().get_crate_num (), ref_node_id, ref,\n-\t    UNKNOWN_LOCAL_DEFID),\n-\t  infered);\n+    HirId ref;\n+    if (!mappings->lookup_node_to_hir (expr.get_mappings ().get_crate_num (),\n+\t\t\t\t       def.parent, &ref))\n+      {\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"assignment infer - reverse lookup failure\");\n+\treturn;\n       }\n+\n+    // FIXME free the old one\n+    context->insert_type (\n+      Analysis::NodeMapping (expr.get_lhs ()->get_mappings ().get_crate_num (),\n+\t\t\t     ref_node_id, ref, UNKNOWN_LOCAL_DEFID),\n+      infered->clone ());\n   }\n \n   void visit (HIR::IdentifierExpr &expr)\n@@ -265,8 +295,8 @@ class TypeCheckExpr : public TypeCheckBase\n \treturn;\n       }\n \n-    TyTy::InferType infer (expr.get_mappings ().get_hirid ());\n-    infered = infer.combine (lookup);\n+    lookup->append_reference (lookup->get_ref ());\n+    infered = lookup->clone ();\n     infered->set_ref (expr.get_mappings ().get_hirid ());\n   }\n \n@@ -321,7 +351,10 @@ class TypeCheckExpr : public TypeCheckBase\n \t      break;\n \n \t    default:\n-\t      ok = context->lookup_builtin (\"i32\", &infered);\n+\t      ok = true;\n+\t      infered = new TyTy::InferType (\n+\t\texpr.get_mappings ().get_hirid (),\n+\t\tTyTy::InferType::InferTypeKind::INTEGRAL);\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -339,8 +372,12 @@ class TypeCheckExpr : public TypeCheckBase\n \t    case CORETYPE_F64:\n \t      ok = context->lookup_builtin (\"f64\", &infered);\n \t      break;\n+\n \t    default:\n-\t      ok = context->lookup_builtin (\"f32\", &infered);\n+\t      ok = true;\n+\t      infered\n+\t\t= new TyTy::InferType (expr.get_mappings ().get_hirid (),\n+\t\t\t\t       TyTy::InferType::InferTypeKind::FLOAT);\n \t      break;\n \t    }\n \t  rust_assert (ok);\n@@ -358,9 +395,7 @@ class TypeCheckExpr : public TypeCheckBase\n \tbreak;\n       }\n \n-    TyTy::InferType infer (expr.get_mappings ().get_hirid ());\n-    infered = infer.combine (infered);\n-    infered->set_ref (expr.get_mappings ().get_hirid ());\n+    infered = infered->clone ();\n   }\n \n   void visit (HIR::ArithmeticOrLogicalExpr &expr)\n@@ -380,7 +415,13 @@ class TypeCheckExpr : public TypeCheckBase\n \tcase HIR::ArithmeticOrLogicalExpr::MODULUS: {\n \t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n \t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::FLOAT);\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::FLOAT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL))\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::FLOAT));\n \t  if (!valid)\n \t    {\n \t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n@@ -396,7 +437,10 @@ class TypeCheckExpr : public TypeCheckBase\n \tcase HIR::ArithmeticOrLogicalExpr::BITWISE_XOR: {\n \t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n \t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::BOOL);\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::BOOL)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL));\n \t  if (!valid)\n \t    {\n \t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n@@ -410,7 +454,10 @@ class TypeCheckExpr : public TypeCheckBase\n       case HIR::ArithmeticOrLogicalExpr::LEFT_SHIFT:\n \tcase HIR::ArithmeticOrLogicalExpr::RIGHT_SHIFT: {\n \t  bool valid = (combined->get_kind () == TyTy::TypeKind::INT)\n-\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT);\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::UINT)\n+\t\t       || (combined->get_kind () == TyTy::TypeKind::INFER\n+\t\t\t   && (((TyTy::InferType *) combined)->get_infer_kind ()\n+\t\t\t       == TyTy::InferType::INTEGRAL));\n \t  if (!valid)\n \t    {\n \t      rust_error_at (expr.get_locus (), \"cannot apply operator to %s\",\n@@ -422,6 +469,8 @@ class TypeCheckExpr : public TypeCheckBase\n       }\n \n     infered = combined;\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::ComparisonExpr &expr)\n@@ -435,6 +484,8 @@ class TypeCheckExpr : public TypeCheckBase\n \n     // we expect this to be\n     infered = new TyTy::BoolType (expr.get_mappings ().get_hirid ());\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::LazyBooleanExpr &expr)\n@@ -454,6 +505,8 @@ class TypeCheckExpr : public TypeCheckBase\n       return;\n \n     infered = lhs->combine (rhs);\n+    infered->append_reference (lhs->get_ref ());\n+    infered->append_reference (rhs->get_ref ());\n   }\n \n   void visit (HIR::NegationExpr &expr)\n@@ -467,7 +520,13 @@ class TypeCheckExpr : public TypeCheckBase\n \t  bool valid\n \t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n \t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT);\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::FLOAT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::INTEGRAL))\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::FLOAT));\n \t  if (!valid)\n \t    {\n \t      rust_error_at (expr.get_locus (), \"cannot apply unary - to %s\",\n@@ -481,7 +540,10 @@ class TypeCheckExpr : public TypeCheckBase\n \t  bool valid\n \t    = (negated_expr_ty->get_kind () == TyTy::TypeKind::BOOL)\n \t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INT)\n-\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT);\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::UINT)\n+\t      || (negated_expr_ty->get_kind () == TyTy::TypeKind::INFER\n+\t\t  && (((TyTy::InferType *) negated_expr_ty)->get_infer_kind ()\n+\t\t      == TyTy::InferType::INTEGRAL));\n \t  if (!valid)\n \t    {\n \t      rust_error_at (expr.get_locus (), \"cannot apply unary ! to %s\",\n@@ -492,7 +554,8 @@ class TypeCheckExpr : public TypeCheckBase\n \tbreak;\n       }\n \n-    infered = negated_expr_ty;\n+    infered = negated_expr_ty->clone ();\n+    infered->append_reference (negated_expr_ty->get_ref ());\n   }\n \n   void visit (HIR::IfExpr &expr)\n@@ -567,23 +630,45 @@ class TypeCheckExpr : public TypeCheckBase\n \n   void visit (HIR::ArrayIndexExpr &expr)\n   {\n-    // FIXME this should be size type\n-    TyTy::IntType size_ty (expr.get_index_expr ()->get_mappings ().get_hirid (),\n-\t\t\t   TyTy::IntType::I32);\n-    auto resolved\n-      = size_ty.combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n-    rust_assert (resolved != nullptr);\n+    TyTy::TyBase *size_ty;\n+    if (!context->lookup_builtin (\"i32\", &size_ty))\n+      {\n+\trust_error_at (\n+\t  expr.get_locus (),\n+\t  \"Failure looking up size type for index in ArrayIndexExpr\");\n+\treturn;\n+      }\n+\n+    auto resolved_index_expr\n+      = size_ty->combine (TypeCheckExpr::Resolve (expr.get_index_expr ()));\n+    if (resolved_index_expr == nullptr)\n+      {\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"Type Resolver failure in Index for ArrayIndexExpr\");\n+\treturn;\n+      }\n+    context->insert_type (expr.get_index_expr ()->get_mappings (),\n+\t\t\t  resolved_index_expr);\n \n+    // resolve the array reference\n     expr.get_array_expr ()->accept_vis (*this);\n-    if (infered->get_kind () != TyTy::TypeKind::ARRAY)\n+    if (infered == nullptr)\n       {\n-\trust_fatal_error (expr.get_array_expr ()->get_locus_slow (),\n-\t\t\t  \"expected an ArrayType for index expression\");\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"failed to resolve array reference expression\");\n+\treturn;\n+      }\n+    else if (infered->get_kind () != TyTy::TypeKind::ARRAY)\n+      {\n+\trust_error_at (expr.get_index_expr ()->get_locus_slow (),\n+\t\t       \"expected an ArrayType got [%s]\",\n+\t\t       infered->as_string ().c_str ());\n+\tinfered = nullptr;\n \treturn;\n       }\n \n-    // extract the element type out now from the base type\n-    infered = TyTyExtractorArray::ExtractElementTypeFromArray (infered);\n+    TyTy::ArrayType *array_type = (TyTy::ArrayType *) infered;\n+    infered = array_type->get_type ()->clone ();\n   }\n \n   void visit (HIR::ArrayExpr &expr)\n@@ -611,6 +696,9 @@ class TypeCheckExpr : public TypeCheckBase\n       {\n \tinfered_array_elems = infered_array_elems->combine (types.at (i));\n       }\n+\n+    for (auto &elem : types)\n+      infered_array_elems->append_reference (elem->get_ref ());\n   }\n \n   void visit (HIR::ArrayElemsCopied &elems)\n@@ -632,9 +720,12 @@ class TypeCheckExpr : public TypeCheckBase\n   {\n     auto struct_base\n       = TypeCheckExpr::Resolve (expr.get_receiver_expr ().get ());\n-    if (struct_base->get_kind () != TyTy::TypeKind::ADT)\n+\n+    bool is_valid_type = struct_base->get_kind () == TyTy::TypeKind::ADT;\n+    if (!is_valid_type)\n       {\n-\trust_error_at (expr.get_locus (), \"expected ADT Type got: [%s]\",\n+\trust_error_at (expr.get_locus (),\n+\t\t       \"expected ADT or Tuple Type got: [%s]\",\n \t\t       struct_base->as_string ().c_str ());\n \treturn;\n       }"}, {"sha": "d7f9af1bd5f449c7d34703e6b066e04bc777f9a4", "filename": "gcc/rust/typecheck/rust-hir-type-check-item.h", "status": "modified", "additions": 24, "deletions": 38, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-item.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -24,43 +24,10 @@\n #include \"rust-hir-type-check-type.h\"\n #include \"rust-hir-type-check-stmt.h\"\n #include \"rust-tyty-visitor.h\"\n-#include \"rust-tyty-resolver.h\"\n \n namespace Rust {\n namespace Resolver {\n \n-class ResolveFnType : public TyTy::TyVisitor\n-{\n-public:\n-  ResolveFnType (TyTy::TyBase *base) : base (base), state (nullptr) {}\n-\n-  TyTy::TyBase *go ()\n-  {\n-    base->accept_vis (*this);\n-    if (state == nullptr)\n-      gcc_unreachable ();\n-\n-    return state;\n-  }\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ArrayType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::FnType &type) override { state = type.return_type (); }\n-\n-private:\n-  TyTy::TyBase *base;\n-  TyTy::TyBase *state;\n-};\n-\n class TypeCheckItem : public TypeCheckBase\n {\n public:\n@@ -72,23 +39,42 @@ class TypeCheckItem : public TypeCheckBase\n \n   void visit (HIR::Function &function)\n   {\n-    TyTy::TyBase *fnType;\n-    if (!context->lookup_type (function.get_mappings ().get_hirid (), &fnType))\n+    TyTy::TyBase *lookup;\n+    if (!context->lookup_type (function.get_mappings ().get_hirid (), &lookup))\n       {\n \trust_error_at (function.locus, \"failed to lookup function type\");\n \treturn;\n       }\n \n+    if (lookup->get_kind () != TyTy::TypeKind::FNDEF)\n+      {\n+\trust_error_at (function.get_locus (),\n+\t\t       \"found invalid type for function [%s]\",\n+\t\t       lookup->as_string ().c_str ());\n+\treturn;\n+      }\n+\n     // need to get the return type from this\n-    ResolveFnType resolve_fn_type (fnType);\n-    context->push_return_type (resolve_fn_type.go ());\n+    TyTy::FnType *resolve_fn_type = (TyTy::FnType *) lookup;\n+    auto expected_ret_tyty = resolve_fn_type->return_type ();\n+    context->push_return_type (expected_ret_tyty);\n \n     TypeCheckExpr::Resolve (function.function_body.get ());\n     if (function.function_body->has_expr ())\n       {\n \tauto resolved\n \t  = TypeCheckExpr::Resolve (function.function_body->expr.get ());\n-\tcontext->peek_return_type ()->combine (resolved);\n+\n+\tauto ret_resolved = expected_ret_tyty->combine (resolved);\n+\tif (ret_resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.function_body->expr->get_locus_slow (),\n+\t\t\t   \"failed to resolve final expression\");\n+\t    return;\n+\t  }\n+\n+\tcontext->peek_return_type ()->append_reference (\n+\t  ret_resolved->get_ref ());\n       }\n \n     context->pop_return_type ();"}, {"sha": "99be0b72d6cdc12dc3c27ee4557504802f9e5e05", "filename": "gcc/rust/typecheck/rust-hir-type-check-stmt.h", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-stmt.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -49,10 +49,19 @@ class TypeCheckStmt : public TypeCheckBase\n \n   void visit (HIR::LetStmt &stmt)\n   {\n+    infered = new TyTy::UnitType (stmt.get_mappings ().get_hirid ());\n+\n     TyTy::TyBase *init_expr_ty = nullptr;\n     if (stmt.has_init_expr ())\n-      init_expr_ty\n-\t= TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+      {\n+\tinit_expr_ty\n+\t  = TypeCheckExpr::Resolve (stmt.get_init_expr (), is_final_stmt);\n+\n+\tinit_expr_ty = init_expr_ty->clone ();\n+\tauto ref = init_expr_ty->get_ref ();\n+\tinit_expr_ty->set_ref (stmt.get_mappings ().get_hirid ());\n+\tinit_expr_ty->append_reference (ref);\n+      }\n \n     TyTy::TyBase *specified_ty = nullptr;\n     if (stmt.has_type ())\n@@ -86,16 +95,17 @@ class TypeCheckStmt : public TypeCheckBase\n \t// let x;\n \telse\n \t  {\n-\t    context->insert_type (stmt.get_mappings (),\n-\t\t\t\t  new TyTy::InferType (\n-\t\t\t\t    stmt.get_mappings ().get_hirid ()));\n+\t    context->insert_type (\n+\t      stmt.get_mappings (),\n+\t      new TyTy::InferType (stmt.get_mappings ().get_hirid (),\n+\t\t\t\t   TyTy::InferType::InferTypeKind::GENERAL));\n \t  }\n       }\n   }\n \n private:\n   TypeCheckStmt (bool is_final_stmt)\n-    : TypeCheckBase (), is_final_stmt (is_final_stmt)\n+    : TypeCheckBase (), infered (nullptr), is_final_stmt (is_final_stmt)\n   {}\n \n   TyTy::TyBase *infered;"}, {"sha": "52b6cded787541c0f8c59ca632ab514171dec90c", "filename": "gcc/rust/typecheck/rust-hir-type-check-toplevel.h", "status": "modified", "additions": 10, "deletions": 6, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-toplevel.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -56,8 +56,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::TyBase *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   struct_decl.get_identifier (), true,\n-\t\t\t   std::move (fields));\n+\t\t\t   struct_decl.get_identifier (), std::move (fields));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n@@ -78,8 +77,7 @@ class TypeCheckTopLevel : public TypeCheckBase\n \n     TyTy::TyBase *type\n       = new TyTy::ADTType (struct_decl.get_mappings ().get_hirid (),\n-\t\t\t   struct_decl.get_identifier (), false,\n-\t\t\t   std::move (fields));\n+\t\t\t   struct_decl.get_identifier (), std::move (fields));\n \n     context->insert_type (struct_decl.get_mappings (), type);\n   }\n@@ -107,9 +105,15 @@ class TypeCheckTopLevel : public TypeCheckBase\n       ret_type = new TyTy::UnitType (function.get_mappings ().get_hirid ());\n     else\n       {\n-\tTyTy::InferType infer (function.get_mappings ().get_hirid ());\n \tauto resolved = TypeCheckType::Resolve (function.return_type.get ());\n-\tret_type = infer.combine (resolved);\n+\tif (resolved == nullptr)\n+\t  {\n+\t    rust_error_at (function.get_locus (),\n+\t\t\t   \"failed to resolve return type\");\n+\t    return;\n+\t  }\n+\n+\tret_type = resolved->clone ();\n \tret_type->set_ref (function.return_type->get_mappings ().get_hirid ());\n       }\n "}, {"sha": "e5d389864c6140104d50757ca816627b43ad509e", "filename": "gcc/rust/typecheck/rust-hir-type-check-type.h", "status": "modified", "additions": 14, "deletions": 18, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check-type.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -40,11 +40,12 @@ class ArrayCapacityConstant : public TypeCheckBase\n \n   void visit (HIR::LiteralExpr &expr)\n   {\n+    auto literal_value = expr.get_literal ();\n     switch (expr.get_lit_type ())\n       {\n \tcase HIR::Literal::LitType::INT: {\n \t  ok = true;\n-\t  std::stringstream ss (expr.as_string ());\n+\t  std::stringstream ss (literal_value->as_string ());\n \t  ss >> result;\n \t}\n \tbreak;\n@@ -70,8 +71,10 @@ class TypeCheckType : public TypeCheckBase\n     type->accept_vis (resolver);\n \n     if (resolver.translated != nullptr)\n-      resolver.context->insert_type (type->get_mappings (),\n-\t\t\t\t     resolver.translated);\n+      {\n+\tresolver.context->insert_type (type->get_mappings (),\n+\t\t\t\t       resolver.translated);\n+      }\n \n     return resolver.translated;\n   }\n@@ -89,25 +92,15 @@ class TypeCheckType : public TypeCheckBase\n \treturn;\n       }\n \n-    size_t index = 0;\n-    std::string identifier = \"(\";\n-    std::vector<TyTy::StructFieldType *> fields;\n+    std::vector<HirId> fields;\n     for (auto &elem : tuple.get_elems ())\n       {\n \tauto field_ty = TypeCheckType::Resolve (elem.get ());\n-\tidentifier += field_ty->as_string ();\n-\tif ((index + 1) < tuple.get_elems ().size ())\n-\t  identifier += \",\";\n-\n-\tauto field_tyty\n-\t  = new TyTy::StructFieldType (elem->get_mappings ().get_hirid (),\n-\t\t\t\t       std::to_string (index), field_ty);\n-\tfields.push_back (field_tyty);\n-\tindex++;\n+\tfields.push_back (field_ty->get_ref ());\n       }\n-    identifier += \")\";\n-    translated = new TyTy::ADTType (tuple.get_mappings ().get_hirid (),\n-\t\t\t\t    identifier, true, fields);\n+\n+    translated\n+      = new TyTy::TupleType (tuple.get_mappings ().get_hirid (), fields);\n   }\n \n   void visit (HIR::TypePath &path)\n@@ -129,6 +122,9 @@ class TypeCheckType : public TypeCheckBase\n \t// we got an HIR node\n \tif (context->lookup_type (hir_lookup, &translated))\n \t  {\n+\t    translated = translated->clone ();\n+\t    auto ref = path.get_mappings ().get_hirid ();\n+\t    translated->set_ref (ref);\n \t    return;\n \t  }\n       }"}, {"sha": "cf3a84639051a4826611e6d979d5501489c5f4b2", "filename": "gcc/rust/typecheck/rust-hir-type-check.cc", "status": "modified", "additions": 81, "deletions": 53, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.cc?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -34,6 +34,54 @@ TypeResolution::Resolve (HIR::Crate &crate)\n \n   for (auto it = crate.items.begin (); it != crate.items.end (); it++)\n     TypeCheckItem::Resolve (it->get ());\n+\n+  auto mappings = Analysis::Mappings::get ();\n+  auto context = TypeCheckContext::get ();\n+\n+  context->iterate ([&] (HirId id, TyTy::TyBase *ty) mutable -> bool {\n+    // nothing to do\n+    if (ty->get_kind () != TyTy::TypeKind::INFER)\n+      return true;\n+\n+    TyTy::InferType *infer_var = (TyTy::InferType *) ty;\n+    switch (infer_var->get_infer_kind ())\n+      {\n+      case TyTy::InferType::GENERAL:\n+\trust_error_at (mappings->lookup_location (id),\n+\t\t       \"unable to determine type: %u\", id);\n+\tbreak;\n+\n+\tcase TyTy::InferType::INTEGRAL: {\n+\t  TyTy::TyBase *default_integer;\n+\t  bool ok = context->lookup_builtin (\"i32\", &default_integer);\n+\t  rust_assert (ok);\n+\n+\t  auto result = ty->combine (default_integer);\n+\t  result->set_ref (id);\n+\t  context->insert_type (\n+\t    Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID),\n+\t    result);\n+\t}\n+\tbreak;\n+\n+\tcase TyTy::InferType::FLOAT: {\n+\t  TyTy::TyBase *default_float;\n+\t  bool ok = context->lookup_builtin (\"f32\", &default_float);\n+\t  rust_assert (ok);\n+\n+\t  auto result = ty->combine (default_float);\n+\t  result->set_ref (id);\n+\t  context->insert_type (\n+\t    Analysis::NodeMapping (mappings->get_current_crate (), 0, id,\n+\t\t\t\t   UNKNOWN_LOCAL_DEFID),\n+\t    result);\n+\t}\n+\tbreak;\n+      }\n+\n+    return true;\n+  });\n }\n \n // RUST_HIR_TYPE_CHECK_EXPR\n@@ -48,6 +96,12 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n     bool is_final_expr = is_final_stmt && !expr.has_expr ();\n \n     auto infered = TypeCheckStmt::Resolve (s, is_final_expr);\n+    if (infered == nullptr)\n+      {\n+\trust_error_at (s->get_locus_slow (), \"failure to resolve type\");\n+\treturn false;\n+      }\n+\n     if (is_final_expr)\n       {\n \tdelete block_tyty;\n@@ -59,21 +113,19 @@ TypeCheckExpr::visit (HIR::BlockExpr &expr)\n \n   // tail expression must be checked as part of the caller since\n   // the result of this is very dependant on what we expect it to be\n-  if (expr.has_expr ())\n-    TypeCheckExpr::Resolve (expr.expr.get ());\n \n   // now that the stmts have been resolved we must resolve the block of locals\n   // and make sure the variables have been resolved\n-  auto body_mappings = expr.get_mappings ();\n-  Rib *rib = nullptr;\n-  if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n-    {\n-      rust_fatal_error (expr.get_locus (), \"failed to lookup locals per block\");\n-      return;\n-    }\n-  TyTyResolver::Resolve (rib, mappings, resolver, context);\n-\n-  infered = block_tyty;\n+  // auto body_mappings = expr.get_mappings ();\n+  // Rib *rib = nullptr;\n+  // if (!resolver->find_name_rib (body_mappings.get_nodeid (), &rib))\n+  //   {\n+  //     rust_fatal_error (expr.get_locus (), \"failed to lookup locals per\n+  //     block\"); return;\n+  //   }\n+  // TyTyResolver::Resolve (rib, mappings, resolver, context);\n+\n+  infered = block_tyty->clone ();\n }\n \n // RUST_HIR_TYPE_CHECK_STRUCT_FIELD\n@@ -154,47 +206,23 @@ TypeCheckStructExpr::visit (HIR::StructExprStructFields &struct_expr)\n \t\t= struct_expr.struct_base->base_struct->clone_expr_impl ();\n \n \t      HIR::StructExprField *implicit_field = nullptr;\n-\t      if (struct_path_resolved->is_tuple_struct ())\n-\t\t{\n-\t\t  std::vector<HIR::Attribute> outer_attribs;\n-\t\t  TupleIndex tuple_index = std::stoi (missing);\n-\n-\t\t  auto crate_num = mappings->get_current_crate ();\n-\t\t  Analysis::NodeMapping mapping (\n-\t\t    crate_num,\n-\t\t    struct_expr.struct_base->base_struct->get_mappings ()\n-\t\t      .get_nodeid (),\n-\t\t    mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n-\n-\t\t  HIR::Expr *field_value = new HIR::TupleIndexExpr (\n-\t\t    mapping, std::unique_ptr<HIR::Expr> (receiver), tuple_index,\n-\t\t    std::move (outer_attribs),\n-\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n-\n-\t\t  implicit_field = new HIR::StructExprFieldIndexValue (\n-\t\t    mapping, tuple_index,\n-\t\t    std::unique_ptr<HIR::Expr> (field_value),\n-\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n-\t\t}\n-\t      else\n-\t\t{\n-\t\t  std::vector<HIR::Attribute> outer_attribs;\n-\t\t  auto crate_num = mappings->get_current_crate ();\n-\t\t  Analysis::NodeMapping mapping (\n-\t\t    crate_num,\n-\t\t    struct_expr.struct_base->base_struct->get_mappings ()\n-\t\t      .get_nodeid (),\n-\t\t    mappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n-\n-\t\t  HIR::Expr *field_value = new HIR::FieldAccessExpr (\n-\t\t    mapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n-\t\t    std::move (outer_attribs),\n-\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n-\n-\t\t  implicit_field = new HIR::StructExprFieldIdentifierValue (\n-\t\t    mapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n-\t\t    struct_expr.struct_base->base_struct->get_locus_slow ());\n-\t\t}\n+\n+\t      std::vector<HIR::Attribute> outer_attribs;\n+\t      auto crate_num = mappings->get_current_crate ();\n+\t      Analysis::NodeMapping mapping (\n+\t\tcrate_num,\n+\t\tstruct_expr.struct_base->base_struct->get_mappings ()\n+\t\t  .get_nodeid (),\n+\t\tmappings->get_next_hir_id (crate_num), UNKNOWN_LOCAL_DEFID);\n+\n+\t      HIR::Expr *field_value = new HIR::FieldAccessExpr (\n+\t\tmapping, std::unique_ptr<HIR::Expr> (receiver), missing,\n+\t\tstd::move (outer_attribs),\n+\t\tstruct_expr.struct_base->base_struct->get_locus_slow ());\n+\n+\t      implicit_field = new HIR::StructExprFieldIdentifierValue (\n+\t\tmapping, missing, std::unique_ptr<HIR::Expr> (field_value),\n+\t\tstruct_expr.struct_base->base_struct->get_locus_slow ());\n \n \t      size_t field_index;\n \t      bool ok = struct_path_resolved->get_field (missing, &field_index);"}, {"sha": "d033878c98210011862465cbfe51e8e67b617317", "filename": "gcc/rust/typecheck/rust-hir-type-check.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-hir-type-check.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -47,6 +47,15 @@ class TypeCheckContext\n   void push_return_type (TyTy::TyBase *return_type);\n   void pop_return_type ();\n \n+  void iterate (std::function<bool (HirId, TyTy::TyBase *)> cb)\n+  {\n+    for (auto it = resolved.begin (); it != resolved.end (); it++)\n+      {\n+\tif (!cb (it->first, it->second))\n+\t  return;\n+      }\n+  }\n+\n private:\n   TypeCheckContext ();\n "}, {"sha": "863c2eb376c75054e6debcdc9a20dfbbc8946c59", "filename": "gcc/rust/typecheck/rust-tycheck-dump.h", "status": "added", "additions": 178, "deletions": 0, "changes": 178, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tycheck-dump.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -0,0 +1,178 @@\n+// Copyright (C) 2020 Free Software Foundation, Inc.\n+\n+// This file is part of GCC.\n+\n+// GCC is free software; you can redistribute it and/or modify it under\n+// the terms of the GNU General Public License as published by the Free\n+// Software Foundation; either version 3, or (at your option) any later\n+// version.\n+\n+// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+// for more details.\n+\n+// You should have received a copy of the GNU General Public License\n+// along with GCC; see the file COPYING3.  If not see\n+// <http://www.gnu.org/licenses/>.\n+\n+#ifndef RUST_TYCHECK_DUMP\n+#define RUST_TYCHECK_DUMP\n+\n+#include \"rust-hir-type-check-base.h\"\n+#include \"rust-hir-full.h\"\n+\n+namespace Rust {\n+namespace Resolver {\n+\n+class TypeResolverDump : public TypeCheckBase\n+{\n+public:\n+  static std::string go (HIR::Crate &crate)\n+  {\n+    TypeResolverDump dumper;\n+    for (auto &item : crate.items)\n+      item->accept_vis (dumper);\n+\n+    return dumper.dump;\n+  }\n+\n+  void visit (HIR::Function &function)\n+  {\n+    dump += indent () + \"fn \" + function.function_name + \" \"\n+\t    + type_string (function.get_mappings ()) + \"\\n\";\n+    dump += indent () + \"{\\n\";\n+\n+    HIR::BlockExpr *function_body = function.function_body.get ();\n+    function_body->accept_vis (*this);\n+\n+    dump += indent () + \"}\\n\";\n+  }\n+\n+  void visit (HIR::BlockExpr &expr)\n+  {\n+    indentation_level++;\n+\n+    expr.iterate_stmts ([&] (HIR::Stmt *s) mutable -> bool {\n+      s->accept_vis (*this);\n+      dump += \";\\n\";\n+      return true;\n+    });\n+\n+    if (expr.has_expr () && expr.tail_expr_reachable ())\n+      {\n+\texpr.expr->accept_vis (*this);\n+\tdump += \";\\n\";\n+      }\n+\n+    indentation_level--;\n+  }\n+\n+  void visit (HIR::LetStmt &stmt)\n+  {\n+    dump += indent () + \"let \" + stmt.get_pattern ()->as_string () + \":\"\n+\t    + type_string (stmt.get_mappings ());\n+    if (stmt.has_init_expr ())\n+      {\n+\tdump += \" = \";\n+\tstmt.get_init_expr ()->accept_vis (*this);\n+      }\n+  }\n+\n+  void visit (HIR::ExprStmtWithBlock &stmt)\n+  {\n+    dump += indent ();\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::ExprStmtWithoutBlock &stmt)\n+  {\n+    dump += indent ();\n+    stmt.get_expr ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::AssignmentExpr &expr)\n+  {\n+    expr.get_lhs ()->accept_vis (*this);\n+    dump += \" = \";\n+    expr.get_rhs ()->accept_vis (*this);\n+  }\n+\n+  void visit (HIR::LiteralExpr &expr)\n+  {\n+    dump += expr.get_literal ()->as_string () + \":\"\n+\t    + type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::IdentifierExpr &expr)\n+  {\n+    dump += expr.get_identifier () + \":\" + type_string (expr.get_mappings ());\n+  }\n+\n+  void visit (HIR::ArrayExpr &expr)\n+  {\n+    dump += type_string (expr.get_mappings ()) + \":[\";\n+\n+    HIR::ArrayElems *elements = expr.get_internal_elements ();\n+    elements->accept_vis (*this);\n+\n+    dump += \"]\";\n+  }\n+\n+  void visit (HIR::ArrayElemsValues &elems)\n+  {\n+    elems.iterate ([&] (HIR::Expr *e) mutable -> bool {\n+      e->accept_vis (*this);\n+      dump += \",\";\n+      return true;\n+    });\n+  }\n+\n+  void visit (HIR::GroupedExpr &expr)\n+  {\n+    HIR::Expr *paren_expr = expr.get_expr_in_parens ().get ();\n+    dump += \"(\";\n+    paren_expr->accept_vis (*this);\n+    dump += \")\";\n+  }\n+\n+protected:\n+  std::string type_string (const Analysis::NodeMapping &mappings)\n+  {\n+    TyTy::TyBase *lookup = nullptr;\n+    if (!context->lookup_type (mappings.get_hirid (), &lookup))\n+      return \"<error>\";\n+\n+    std::string buf = \"[\";\n+    for (auto &ref : lookup->get_combined_refs ())\n+      {\n+\tbuf += std::to_string (ref);\n+\tbuf += \", \";\n+      }\n+    buf += \"]\";\n+\n+    return \"<\" + lookup->as_string ()\n+\t   + \" RF:\" + std::to_string (lookup->get_ref ()) + \" TF:\"\n+\t   + std::to_string (lookup->get_ty_ref ()) + +\" - \" + buf + \">\";\n+  }\n+\n+  std::string indent ()\n+  {\n+    std::string buf;\n+    for (size_t i = 0; i < indentation_level; ++i)\n+      buf += \"    \";\n+\n+    return buf;\n+  }\n+\n+private:\n+  TypeResolverDump () : TypeCheckBase (), indentation_level (0) {}\n+\n+  std::string dump;\n+  size_t indentation_level;\n+};\n+\n+} // namespace Resolver\n+} // namespace Rust\n+\n+#endif // RUST_TYCHECK_DUMP"}, {"sha": "84cfdce06f956a641b8247551b0ce8a495c9f43e", "filename": "gcc/rust/typecheck/rust-tyty-call.h", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-call.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -23,23 +23,26 @@\n #include \"rust-hir-full.h\"\n #include \"rust-tyty-visitor.h\"\n #include \"rust-tyty.h\"\n+#include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace TyTy {\n \n class TypeCheckCallExpr : private TyVisitor\n {\n public:\n-  static TyBase *go (TyBase *ref, HIR::CallExpr &call)\n+  static TyBase *go (TyBase *ref, HIR::CallExpr &call,\n+\t\t     Resolver::TypeCheckContext *context)\n   {\n-    TypeCheckCallExpr checker (call);\n+    TypeCheckCallExpr checker (call, context);\n     ref->accept_vis (checker);\n     return checker.resolved;\n   }\n   ~TypeCheckCallExpr () {}\n \n   void visit (UnitType &type) override { gcc_unreachable (); }\n   void visit (InferType &type) override { gcc_unreachable (); }\n+  void visit (TupleType &type) override { gcc_unreachable (); }\n   void visit (StructFieldType &type) override { gcc_unreachable (); }\n   void visit (ArrayType &type) override { gcc_unreachable (); }\n   void visit (BoolType &type) override { gcc_unreachable (); }\n@@ -55,10 +58,15 @@ class TypeCheckCallExpr : private TyVisitor\n   void visit (FnType &type) override;\n \n private:\n-  TypeCheckCallExpr (HIR::CallExpr &c) : resolved (nullptr), call (c) {}\n+  TypeCheckCallExpr (HIR::CallExpr &c, Resolver::TypeCheckContext *context)\n+    : resolved (nullptr), call (c), context (context),\n+      mappings (Analysis::Mappings::get ())\n+  {}\n \n   TyBase *resolved;\n   HIR::CallExpr &call;\n+  Resolver::TypeCheckContext *context;\n+  Analysis::Mappings *mappings;\n };\n \n } // namespace TyTy"}, {"sha": "d48952cde0b0eca5a2c4a4699da39bcc5e5062a7", "filename": "gcc/rust/typecheck/rust-tyty-resolver.h", "status": "removed", "additions": 0, "deletions": 214, "changes": 214, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5294dfe7dce7a58fbaf2131c7589d115008ebf0e/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5294dfe7dce7a58fbaf2131c7589d115008ebf0e/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-resolver.h?ref=5294dfe7dce7a58fbaf2131c7589d115008ebf0e", "patch": "@@ -1,214 +0,0 @@\n-// Copyright (C) 2020 Free Software Foundation, Inc.\n-\n-// This file is part of GCC.\n-\n-// GCC is free software; you can redistribute it and/or modify it under\n-// the terms of the GNU General Public License as published by the Free\n-// Software Foundation; either version 3, or (at your option) any later\n-// version.\n-\n-// GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n-// WARRANTY; without even the implied warranty of MERCHANTABILITY or\n-// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n-// for more details.\n-\n-// You should have received a copy of the GNU General Public License\n-// along with GCC; see the file COPYING3.  If not see\n-// <http://www.gnu.org/licenses/>.\n-\n-#ifndef RUST_TYTY_RESOLVER\n-#define RUST_TYTY_RESOLVER\n-\n-#include \"rust-system.h\"\n-#include \"rust-diagnostics.h\"\n-#include \"rust-hir-map.h\"\n-#include \"rust-name-resolver.h\"\n-#include \"rust-hir-type-check.h\"\n-#include \"rust-hir-full.h\"\n-#include \"rust-tyty-visitor.h\"\n-\n-namespace Rust {\n-namespace Resolver {\n-\n-class TyTyResolver\n-{\n-public:\n-  static void Resolve (Rib *rib, Analysis::Mappings *mappings,\n-\t\t       Resolver *resolver, TypeCheckContext *context)\n-  {\n-    TyTyResolver r (mappings, resolver, context);\n-    r.go (rib);\n-  }\n-\n-  virtual ~TyTyResolver () {}\n-\n-  void go (Rib *rib)\n-  {\n-    rib->iterate_decls ([&] (NodeId decl_node_id,\n-\t\t\t     Location locus) mutable -> bool {\n-      // type inference in rust means we need to gather and examine all\n-      // references of this decl and combine each to make sure the type is\n-      // correctly inferred. Consider the example:\n-      // let mut x; x = 1;\n-      // we can only say x is an infer variable then at the assignment\n-      // we think x must be an integer\n-\n-      bool ok = true;\n-      std::vector<TyTy::TyBase *> gathered_types;\n-      rib->iterate_references_for_def (\n-\tdecl_node_id, [&] (NodeId ref_node) mutable -> bool {\n-\t  HirId hir_node_ref;\n-\t  if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t     ref_node, &hir_node_ref))\n-\t    {\n-\t      rust_error_at (locus,\n-\t\t\t     \"failed to reserve lookup HIR node for reference\");\n-\t      ok = false;\n-\t      return false;\n-\t    }\n-\n-\t  TyTy::TyBase *resolved = nullptr;\n-\t  if (!context->lookup_type (hir_node_ref, &resolved))\n-\t    {\n-\t      // this could be an array/adt type\n-\t      Definition d;\n-\t      if (!resolver->lookup_definition (ref_node, &d))\n-\t\t{\n-\t\t  rust_error_at (\n-\t\t    locus,\n-\t\t    \"failed to lookup definition for referenced hir node\");\n-\n-\t\t  ok = false;\n-\t\t  return false;\n-\t\t}\n-\n-\t      if (!mappings->lookup_node_to_hir (mappings->get_current_crate (),\n-\t\t\t\t\t\t d.parent, &hir_node_ref))\n-\t\t{\n-\t\t  rust_error_at (locus,\n-\t\t\t\t \"failed to lookup HIR node for parent NodeId\");\n-\n-\t\t  ok = false;\n-\t\t  return false;\n-\t\t}\n-\n-\t      if (!context->lookup_type (hir_node_ref, &resolved))\n-\t\t{\n-\t\t  rust_error_at (\n-\t\t    mappings->lookup_location (hir_node_ref),\n-\t\t    \"failed to lookup type for reference at node [%u]\",\n-\t\t    hir_node_ref);\n-\n-\t\t  ok = false;\n-\t\t  return false;\n-\t\t}\n-\t    }\n-\n-\t  gathered_types.push_back (resolved);\n-\t  return true;\n-\t});\n-\n-      Definition d;\n-      if (!resolver->lookup_definition (decl_node_id, &d))\n-\t{\n-\t  rust_error_at (locus, \"Failed to lookup definition within rib\");\n-\t  return false;\n-\t}\n-\n-      HIR::Stmt *decl = nullptr;\n-      if (!mappings->resolve_nodeid_to_stmt (d.parent, &decl))\n-\t{\n-\t  rust_error_at (locus, \"Failed to resolve decl to HIR::Stmt\");\n-\t  return false;\n-\t}\n-\n-      TyTy::TyBase *resolved_type = nullptr;\n-      if (!context->lookup_type (decl->get_mappings ().get_hirid (),\n-\t\t\t\t &resolved_type))\n-\t{\n-\t  rust_error_at (locus, \"Unknown base type for decl in Rib\");\n-\t  return false;\n-\t}\n-\n-      // if it is not infer then it must have been figured out already\n-      // we might need changes for generics later on\n-      if (resolved_type->get_kind () != TyTy::TypeKind::INFER)\n-\treturn true;\n-\n-      auto resolved_tyty = resolved_type;\n-      for (auto it : gathered_types)\n-\t{\n-\t  auto combined = resolved_tyty->combine (it);\n-\t  if (combined == nullptr)\n-\t    {\n-\t      rust_fatal_error (decl->get_locus_slow (),\n-\t\t\t\t\"type-check resolver failed\");\n-\t      break;\n-\t    }\n-\n-\t  resolved_tyty = combined;\n-\t}\n-\n-      // something is not inferred we need to look at all references now\n-      if (resolved_tyty == nullptr\n-\t  || resolved_tyty->get_kind () == TyTy::TypeKind::INFER\n-\t  || resolved_tyty->get_kind () == TyTy::TypeKind::ERROR)\n-\t{\n-\t  rust_fatal_error (decl->get_locus_slow (), \"failed to resolve type\");\n-\t  return false;\n-\t}\n-\n-      // insert the new resolved definition\n-      context->insert_type (decl->get_mappings (), resolved_tyty);\n-      return true;\n-    });\n-  }\n-\n-protected:\n-private:\n-  TyTyResolver (Analysis::Mappings *mappings, Resolver *resolver,\n-\t\tTypeCheckContext *context)\n-    : mappings (mappings), resolver (resolver), context (context)\n-  {}\n-\n-  Analysis::Mappings *mappings;\n-  Resolver *resolver;\n-  TypeCheckContext *context;\n-};\n-\n-class TyTyExtractorArray : public TyTy::TyVisitor\n-{\n-public:\n-  static TyTy::TyBase *ExtractElementTypeFromArray (TyTy::TyBase *base)\n-  {\n-    TyTyExtractorArray e;\n-    base->accept_vis (e);\n-    rust_assert (e.extracted != nullptr);\n-    return e.extracted;\n-  }\n-\n-  virtual ~TyTyExtractorArray () {}\n-\n-  void visit (TyTy::UnitType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::InferType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::StructFieldType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ADTType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FnType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::BoolType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::IntType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::UintType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::FloatType &type) override { gcc_unreachable (); }\n-  void visit (TyTy::ErrorType &type) override { gcc_unreachable (); }\n-\n-  void visit (TyTy::ArrayType &type) override { extracted = type.get_type (); }\n-\n-private:\n-  TyTyExtractorArray () : extracted (nullptr) {}\n-\n-  TyTy::TyBase *extracted;\n-};\n-\n-} // namespace Resolver\n-} // namespace Rust\n-\n-#endif // RUST_TYTY_RESOLVER"}, {"sha": "890931f2ffd943a70cf34773aa11c3e69e4f6e32", "filename": "gcc/rust/typecheck/rust-tyty-rules.h", "status": "modified", "additions": 271, "deletions": 101, "changes": 372, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-rules.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -23,6 +23,7 @@\n #include \"rust-tyty.h\"\n #include \"rust-tyty-visitor.h\"\n #include \"rust-hir-map.h\"\n+#include \"rust-hir-type-check.h\"\n \n namespace Rust {\n namespace TyTy {\n@@ -32,161 +33,306 @@ class BaseRules : public TyVisitor\n public:\n   virtual ~BaseRules () {}\n \n+  TyBase *combine (TyBase *other)\n+  {\n+    other->accept_vis (*this);\n+    if (resolved != nullptr)\n+      {\n+\tresolved->append_reference (base->get_ref ());\n+\tresolved->append_reference (other->get_ref ());\n+\tfor (auto ref : base->get_combined_refs ())\n+\t  resolved->append_reference (ref);\n+\tfor (auto ref : other->get_combined_refs ())\n+\t  resolved->append_reference (ref);\n+\n+\tbool result_resolved = resolved->get_kind () != TyTy::TypeKind::INFER;\n+\tif (result_resolved)\n+\t  {\n+\t    for (auto &ref : resolved->get_combined_refs ())\n+\t      {\n+\t\tTyTy::TyBase *ref_tyty = nullptr;\n+\t\tbool ok = context->lookup_type (ref, &ref_tyty);\n+\t\tif (!ok)\n+\t\t  continue;\n+\n+\t\t// if any of the types are inference variables lets fix them\n+\t\tif (ref_tyty->get_kind () == TyTy::TypeKind::INFER)\n+\t\t  {\n+\t\t    NodeId ref_node_id = UNKNOWN_NODEID;\n+\t\t    context->insert_type (\n+\t\t      Analysis::NodeMapping (mappings->get_current_crate (),\n+\t\t\t\t\t     ref_node_id, ref,\n+\t\t\t\t\t     UNKNOWN_LOCAL_DEFID),\n+\t\t      resolved->clone ());\n+\t\t  }\n+\t      }\n+\t  }\n+      }\n+    return resolved;\n+  }\n+\n   virtual void visit (UnitType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n+  }\n+\n+  virtual void visit (TupleType &type) override\n+  {\n+    Location ref_locus = mappings->lookup_location (type.get_ref ());\n+    rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n+\t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n   }\n \n   virtual void visit (ADTType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (InferType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (FnType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (ArrayType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (BoolType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (IntType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (UintType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (FloatType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (ErrorType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n   virtual void visit (StructFieldType &type) override\n   {\n     Location ref_locus = mappings->lookup_location (type.get_ref ());\n-    Location def_locus = mappings->lookup_location (base->get_ref ());\n     rust_error_at (ref_locus, \"expected [%s] got [%s]\",\n \t\t   base->as_string ().c_str (), type.as_string ().c_str ());\n-    rust_error_at (def_locus, \"declared here\");\n   }\n \n protected:\n   BaseRules (TyBase *base)\n-    : mappings (Analysis::Mappings::get ()), base (base),\n+    : mappings (Analysis::Mappings::get ()),\n+      context (Resolver::TypeCheckContext::get ()), base (base),\n       resolved (new ErrorType (base->get_ref (), base->get_ref ()))\n   {}\n \n   Analysis::Mappings *mappings;\n+  Resolver::TypeCheckContext *context;\n+\n   TyBase *base;\n   TyBase *resolved;\n };\n \n-class InferRules : protected BaseRules\n+class InferRules : public BaseRules\n {\n public:\n   InferRules (InferType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (UnitType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (BoolType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (IntType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (UintType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind ()\n+\t    == TyTy::InferType::InferTypeKind::INTEGRAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n+\n+  void visit (FloatType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL)\n+\t|| (base->get_infer_kind () == TyTy::InferType::InferTypeKind::FLOAT);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n   }\n \n-  // we are an inference variable so this means we can take the other as the\n-  // type\n-  void visit (InferType &type) override { resolved = type.clone (); }\n+  void visit (ArrayType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n+\n+    BaseRules::visit (type);\n+  }\n \n-  void visit (UnitType &type) override { resolved = type.clone (); }\n+  void visit (ADTType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n \n-  void visit (BoolType &type) override { resolved = type.clone (); }\n+    BaseRules::visit (type);\n+  }\n \n-  void visit (IntType &type) override { resolved = type.clone (); }\n+  void visit (TupleType &type) override\n+  {\n+    bool is_valid\n+      = (base->get_infer_kind () == TyTy::InferType::InferTypeKind::GENERAL);\n+    if (is_valid)\n+      {\n+\tresolved = type.clone ();\n+\treturn;\n+      }\n \n-  void visit (UintType &type) override { resolved = type.clone (); }\n+    BaseRules::visit (type);\n+  }\n \n-  void visit (FloatType &type) override { resolved = type.clone (); }\n+  void visit (InferType &type) override\n+  {\n+    switch (base->get_infer_kind ())\n+      {\n+      case InferType::InferTypeKind::GENERAL:\n+\tresolved = type.clone ();\n+\treturn;\n \n-  void visit (ArrayType &type) override { resolved = type.clone (); }\n+\tcase InferType::InferTypeKind::INTEGRAL: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+\n+\tcase InferType::InferTypeKind::FLOAT: {\n+\t  if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+\t    {\n+\t      resolved = type.clone ();\n+\t      return;\n+\t    }\n+\t  else if (type.get_infer_kind () == InferType::InferTypeKind::GENERAL)\n+\t    {\n+\t      resolved = base->clone ();\n+\t      return;\n+\t    }\n+\t}\n+\tbreak;\n+      }\n \n-  void visit (ADTType &type) override { resolved = type.clone (); }\n+    BaseRules::visit (type);\n+  }\n \n private:\n   InferType *base;\n };\n \n-class StructFieldTypeRules : protected BaseRules\n+class StructFieldTypeRules : public BaseRules\n {\n public:\n   StructFieldTypeRules (StructFieldType *base) : BaseRules (base), base (base)\n   {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (StructFieldType &type)\n   {\n     TyBase *ty = base->get_field_type ()->combine (type.get_field_type ());\n@@ -201,17 +347,11 @@ class StructFieldTypeRules : protected BaseRules\n   StructFieldType *base;\n };\n \n-class UnitRules : protected BaseRules\n+class UnitRules : public BaseRules\n {\n public:\n   UnitRules (UnitType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (UnitType &type) override\n   {\n     resolved = new UnitType (type.get_ref (), type.get_ty_ref ());\n@@ -221,44 +361,36 @@ class UnitRules : protected BaseRules\n   UnitType *base;\n };\n \n-class FnRules : protected BaseRules\n+class FnRules : public BaseRules\n {\n public:\n   FnRules (FnType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n private:\n   FnType *base;\n };\n \n-class ArrayRules : protected BaseRules\n+class ArrayRules : public BaseRules\n {\n public:\n   ArrayRules (ArrayType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (ArrayType &type) override\n   {\n     // check base type\n     auto base_resolved = base->get_type ()->combine (type.get_type ());\n     if (base_resolved == nullptr)\n-      return;\n+      {\n+\t// fixme add error message\n+\treturn;\n+      }\n \n     // need to check the base types and capacity\n     if (type.get_capacity () != base->get_capacity ())\n       {\n \tLocation locus = mappings->lookup_location (type.get_ref ());\n \trust_error_at (locus, \"mismatch in array capacity\");\n+\tBaseRules::visit (type);\n \treturn;\n       }\n \n@@ -270,17 +402,11 @@ class ArrayRules : protected BaseRules\n   ArrayType *base;\n };\n \n-class BoolRules : protected BaseRules\n+class BoolRules : public BaseRules\n {\n public:\n   BoolRules (BoolType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (BoolType &type) override\n   {\n     resolved = new BoolType (type.get_ref (), type.get_ty_ref ());\n@@ -290,15 +416,22 @@ class BoolRules : protected BaseRules\n   BoolType *base;\n };\n \n-class IntRules : protected BaseRules\n+class IntRules : public BaseRules\n {\n public:\n   IntRules (IntType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (IntType &type) override\n@@ -317,15 +450,22 @@ class IntRules : protected BaseRules\n   IntType *base;\n };\n \n-class UintRules : protected BaseRules\n+class UintRules : public BaseRules\n {\n public:\n   UintRules (UintType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    // cant assign a float inference variable\n+    if (type.get_infer_kind () == InferType::InferTypeKind::FLOAT)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (UintType &type) override\n@@ -344,15 +484,21 @@ class UintRules : protected BaseRules\n   UintType *base;\n };\n \n-class FloatRules : protected BaseRules\n+class FloatRules : public BaseRules\n {\n public:\n   FloatRules (FloatType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n+  void visit (InferType &type) override\n   {\n-    other->accept_vis (*this);\n-    return resolved;\n+    if (type.get_infer_kind () == InferType::InferTypeKind::INTEGRAL)\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    resolved = base->clone ();\n+    resolved->set_ref (type.get_ref ());\n   }\n \n   void visit (FloatType &type) override\n@@ -371,17 +517,11 @@ class FloatRules : protected BaseRules\n   FloatType *base;\n };\n \n-class ADTRules : protected BaseRules\n+class ADTRules : public BaseRules\n {\n public:\n   ADTRules (ADTType *base) : BaseRules (base), base (base) {}\n \n-  TyBase *combine (TyBase *other)\n-  {\n-    other->accept_vis (*this);\n-    return resolved;\n-  }\n-\n   void visit (ADTType &type)\n   {\n     if (base->num_fields () != type.num_fields ())\n@@ -390,12 +530,6 @@ class ADTRules : protected BaseRules\n \treturn;\n       }\n \n-    if (base->get_name ().compare (type.get_name ()) != 0)\n-      {\n-\tBaseRules::visit (type);\n-\treturn;\n-      }\n-\n     std::vector<TyTy::StructFieldType *> fields;\n     for (size_t i = 0; i < type.num_fields (); ++i)\n       {\n@@ -412,15 +546,51 @@ class ADTRules : protected BaseRules\n \tfields.push_back ((TyTy::StructFieldType *) combined);\n       }\n \n-    resolved\n-      = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n-\t\t\t   type.get_name (), type.is_tuple_struct (), fields);\n+    resolved = new TyTy::ADTType (type.get_ref (), type.get_ty_ref (),\n+\t\t\t\t  type.get_name (), fields);\n   }\n \n private:\n   ADTType *base;\n };\n \n+class TupleRules : public BaseRules\n+{\n+public:\n+  TupleRules (TupleType *base) : BaseRules (base), base (base) {}\n+\n+  void visit (TupleType &type)\n+  {\n+    if (base->num_fields () != type.num_fields ())\n+      {\n+\tBaseRules::visit (type);\n+\treturn;\n+      }\n+\n+    std::vector<HirId> fields;\n+    for (size_t i = 0; i < base->num_fields (); i++)\n+      {\n+\tTyBase *bo = base->get_field (i);\n+\tTyBase *fo = type.get_field (i);\n+\n+\tTyBase *combined = bo->combine (fo);\n+\tif (combined == nullptr)\n+\t  {\n+\t    BaseRules::visit (type);\n+\t    return;\n+\t  }\n+\n+\tfields.push_back (combined->get_ref ());\n+      }\n+\n+    resolved\n+      = new TyTy::TupleType (type.get_ref (), type.get_ty_ref (), fields);\n+  }\n+\n+private:\n+  TupleType *base;\n+};\n+\n } // namespace TyTy\n } // namespace Rust\n "}, {"sha": "3997295ae898d5e4c3c3c75a43729a6f6c3d9e71", "filename": "gcc/rust/typecheck/rust-tyty-visitor.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty-visitor.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -31,6 +31,7 @@ class TyVisitor\n   virtual void visit (InferType &type) = 0;\n   virtual void visit (StructFieldType &type) = 0;\n   virtual void visit (ADTType &type) = 0;\n+  virtual void visit (TupleType &type) = 0;\n   virtual void visit (FnType &type) = 0;\n   virtual void visit (ArrayType &type) = 0;\n   virtual void visit (BoolType &type) = 0;"}, {"sha": "9efde688ef33758c66721d507998e4b39eb41f16", "filename": "gcc/rust/typecheck/rust-tyty.cc", "status": "modified", "additions": 96, "deletions": 30, "changes": 126, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.cc?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -47,7 +47,7 @@ UnitType::combine (TyBase *other)\n TyBase *\n UnitType::clone ()\n {\n-  return new UnitType (get_ref (), get_ty_ref ());\n+  return new UnitType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n void\n@@ -59,7 +59,16 @@ InferType::accept_vis (TyVisitor &vis)\n std::string\n InferType::as_string () const\n {\n-  return \"?\";\n+  switch (infer_kind)\n+    {\n+    case GENERAL:\n+      return \"T?\";\n+    case INTEGRAL:\n+      return \"<integer>\";\n+    case FLOAT:\n+      return \"<float>\";\n+    }\n+  return \"<infer::error>\";\n }\n \n TyBase *\n@@ -72,7 +81,8 @@ InferType::combine (TyBase *other)\n TyBase *\n InferType::clone ()\n {\n-  return new InferType (get_ref (), get_ty_ref ());\n+  return new InferType (get_ref (), get_ty_ref (), get_infer_kind (),\n+\t\t\tget_combined_refs ());\n }\n \n void\n@@ -98,7 +108,7 @@ ErrorType::combine (TyBase *other)\n TyBase *\n ErrorType::clone ()\n {\n-  return new ErrorType (get_ref ());\n+  return new ErrorType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n void\n@@ -124,7 +134,8 @@ TyBase *\n StructFieldType::clone ()\n {\n   return new StructFieldType (get_ref (), get_ty_ref (), get_name (),\n-\t\t\t      get_field_type ()->clone ());\n+\t\t\t      get_field_type ()->clone (),\n+\t\t\t      get_combined_refs ());\n }\n \n void\n@@ -157,8 +168,50 @@ ADTType::clone ()\n   for (auto &f : fields)\n     cloned_fields.push_back ((StructFieldType *) f->clone ());\n \n-  return new ADTType (get_ref (), get_ty_ref (), get_name (),\n-\t\t      is_tuple_struct (), cloned_fields);\n+  return new ADTType (get_ref (), get_ty_ref (), get_name (), cloned_fields,\n+\t\t      get_combined_refs ());\n+}\n+\n+void\n+TupleType::accept_vis (TyVisitor &vis)\n+{\n+  vis.visit (*this);\n+}\n+\n+std::string\n+TupleType::as_string () const\n+{\n+  std::string fields_buffer;\n+  iterate_fields ([&] (TyBase *field) mutable -> bool {\n+    fields_buffer += field->as_string ();\n+    fields_buffer += \", \";\n+    return true;\n+  });\n+  return \"(\" + fields_buffer + \")\";\n+}\n+\n+TyBase *\n+TupleType::get_field (size_t index) const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  TyBase *lookup = nullptr;\n+  bool ok = context->lookup_type (fields.at (index), &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n+TyBase *\n+TupleType::combine (TyBase *other)\n+{\n+  TupleRules r (this);\n+  return r.combine (other);\n+}\n+\n+TyBase *\n+TupleType::clone ()\n+{\n+  return new TupleType (get_ref (), get_ty_ref (), fields,\n+\t\t\tget_combined_refs ());\n }\n \n void\n@@ -199,7 +252,7 @@ FnType::clone ()\n       std::pair<HIR::Pattern *, TyBase *> (p.first, p.second->clone ()));\n \n   return new FnType (get_ref (), get_ty_ref (), cloned_params,\n-\t\t     get_return_type ()->clone ());\n+\t\t     get_return_type ()->clone (), get_combined_refs ());\n }\n \n void\n@@ -211,7 +264,8 @@ ArrayType::accept_vis (TyVisitor &vis)\n std::string\n ArrayType::as_string () const\n {\n-  return \"[\" + type->as_string () + \":\" + std::to_string (capacity) + \"]\";\n+  return \"[\" + get_type ()->as_string () + \":\" + std::to_string (capacity)\n+\t + \"]\";\n }\n \n TyBase *\n@@ -221,11 +275,21 @@ ArrayType::combine (TyBase *other)\n   return r.combine (other);\n }\n \n+TyBase *\n+ArrayType::get_type () const\n+{\n+  auto context = Resolver::TypeCheckContext::get ();\n+  TyBase *lookup = nullptr;\n+  bool ok = context->lookup_type (element_type_id, &lookup);\n+  rust_assert (ok);\n+  return lookup;\n+}\n+\n TyBase *\n ArrayType::clone ()\n {\n   return new ArrayType (get_ref (), get_ty_ref (), get_capacity (),\n-\t\t\tget_type ()->clone ());\n+\t\t\tget_type ()->clone (), get_combined_refs ());\n }\n \n void\n@@ -250,7 +314,7 @@ BoolType::combine (TyBase *other)\n TyBase *\n BoolType::clone ()\n {\n-  return new BoolType (get_ref (), get_ty_ref ());\n+  return new BoolType (get_ref (), get_ty_ref (), get_combined_refs ());\n }\n \n void\n@@ -289,7 +353,8 @@ IntType::combine (TyBase *other)\n TyBase *\n IntType::clone ()\n {\n-  return new IntType (get_ref (), get_ty_ref (), get_kind ());\n+  return new IntType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t      get_combined_refs ());\n }\n \n void\n@@ -328,7 +393,8 @@ UintType::combine (TyBase *other)\n TyBase *\n UintType::clone ()\n {\n-  return new UintType (get_ref (), get_ty_ref (), get_kind ());\n+  return new UintType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t       get_combined_refs ());\n }\n \n void\n@@ -361,18 +427,13 @@ FloatType::combine (TyBase *other)\n TyBase *\n FloatType::clone ()\n {\n-  return new FloatType (get_ref (), get_ty_ref (), get_kind ());\n+  return new FloatType (get_ref (), get_ty_ref (), get_kind (),\n+\t\t\tget_combined_refs ());\n }\n \n void\n TypeCheckCallExpr::visit (ADTType &type)\n {\n-  if (!type.is_tuple_struct ())\n-    {\n-      rust_error_at (call.get_locus (), \"Expected TupleStruct\");\n-      return;\n-    }\n-\n   if (call.num_params () != type.num_fields ())\n     {\n       rust_error_at (call.get_locus (),\n@@ -425,21 +486,26 @@ TypeCheckCallExpr::visit (FnType &type)\n     }\n \n   size_t i = 0;\n-  call.iterate_params ([&] (HIR::Expr *p) mutable -> bool {\n+  call.iterate_params ([&] (HIR::Expr *param) mutable -> bool {\n     auto fnparam = type.param_at (i);\n-    auto t = Resolver::TypeCheckExpr::Resolve (p);\n-    if (t == nullptr)\n+    auto argument_expr_tyty = Resolver::TypeCheckExpr::Resolve (param);\n+    if (argument_expr_tyty == nullptr)\n       {\n-\trust_error_at (p->get_locus_slow (), \"failed to resolve type\");\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"failed to resolve type for argument expr in CallExpr\");\n \treturn false;\n       }\n \n-    auto pt = fnparam.second;\n-    auto res = pt->combine (t);\n-    if (res == nullptr)\n-      return false;\n+    auto resolved_argument_type = fnparam.second->combine (argument_expr_tyty);\n+    if (resolved_argument_type == nullptr)\n+      {\n+\trust_error_at (param->get_locus_slow (),\n+\t\t       \"Type Resolution failure on parameter\");\n+\treturn false;\n+      }\n+\n+    context->insert_type (param->get_mappings (), resolved_argument_type);\n \n-    delete res;\n     i++;\n     return true;\n   });\n@@ -452,7 +518,7 @@ TypeCheckCallExpr::visit (FnType &type)\n       return;\n     }\n \n-  resolved = type.get_return_type ();\n+  resolved = type.get_return_type ()->clone ();\n }\n \n } // namespace TyTy"}, {"sha": "6c6f27c04a996e5ca866875c51cfeeefd8f7260e", "filename": "gcc/rust/typecheck/rust-tyty.h", "status": "modified", "additions": 136, "deletions": 47, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Ftypecheck%2Frust-tyty.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Ftypecheck%2Frust-tyty.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -24,6 +24,7 @@\n namespace Rust {\n namespace TyTy {\n \n+// https://rustc-dev-guide.rust-lang.org/type-inference.html#inference-variables\n // https://doc.rust-lang.org/nightly/nightly-rustc/rustc_middle/ty/enum.TyKind.html#variants\n enum TypeKind\n {\n@@ -72,22 +73,42 @@ class TyBase\n \n   virtual TyBase *clone () = 0;\n \n+  std::set<HirId> get_combined_refs () { return combined; }\n+\n+  void append_reference (HirId id) { combined.insert (id); }\n+\n protected:\n-  TyBase (HirId ref, HirId ty_ref, TypeKind kind)\n-    : kind (kind), ref (ref), ty_ref (ty_ref)\n+  TyBase (HirId ref, HirId ty_ref, TypeKind kind,\n+\t  std::set<HirId> refs = std::set<HirId> ())\n+    : kind (kind), ref (ref), ty_ref (ty_ref), combined (refs)\n   {}\n \n   TypeKind kind;\n   HirId ref;\n   HirId ty_ref;\n+\n+  std::set<HirId> combined;\n };\n \n class InferType : public TyBase\n {\n public:\n-  InferType (HirId ref) : TyBase (ref, ref, TypeKind::INFER) {}\n+  enum InferTypeKind\n+  {\n+    GENERAL,\n+    INTEGRAL,\n+    FLOAT\n+  };\n+\n+  InferType (HirId ref, InferTypeKind infer_kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+  {}\n \n-  InferType (HirId ref, HirId ty_ref) : TyBase (ref, ty_ref, TypeKind::INFER) {}\n+  InferType (HirId ref, HirId ty_ref, InferTypeKind infer_kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::INFER, refs), infer_kind (infer_kind)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -98,14 +119,23 @@ class InferType : public TyBase\n   TyBase *combine (TyBase *other) override;\n \n   TyBase *clone () final override;\n+\n+  InferTypeKind get_infer_kind () const { return infer_kind; }\n+\n+private:\n+  InferTypeKind infer_kind;\n };\n \n class ErrorType : public TyBase\n {\n public:\n-  ErrorType (HirId ref) : TyBase (ref, ref, TypeKind::ERROR) {}\n+  ErrorType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ERROR, refs)\n+  {}\n \n-  ErrorType (HirId ref, HirId ty_ref) : TyBase (ref, ty_ref, TypeKind::ERROR) {}\n+  ErrorType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ERROR, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -121,9 +151,13 @@ class ErrorType : public TyBase\n class UnitType : public TyBase\n {\n public:\n-  UnitType (HirId ref) : TyBase (ref, ref, TypeKind::UNIT) {}\n+  UnitType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::UNIT, refs)\n+  {}\n \n-  UnitType (HirId ref, HirId ty_ref) : TyBase (ref, ty_ref, TypeKind::UNIT) {}\n+  UnitType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::UNIT, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -139,12 +173,14 @@ class UnitType : public TyBase\n class StructFieldType : public TyBase\n {\n public:\n-  StructFieldType (HirId ref, std::string name, TyBase *ty)\n-    : TyBase (ref, ref, TypeKind::FIELD), name (name), ty (ty)\n+  StructFieldType (HirId ref, std::string name, TyBase *ty,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FIELD, refs), name (name), ty (ty)\n   {}\n \n-  StructFieldType (HirId ref, HirId ty_ref, std::string name, TyBase *ty)\n-    : TyBase (ref, ty_ref, TypeKind::FIELD), name (name), ty (ty)\n+  StructFieldType (HirId ref, HirId ty_ref, std::string name, TyBase *ty,\n+\t\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FIELD, refs), name (name), ty (ty)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -166,19 +202,61 @@ class StructFieldType : public TyBase\n   TyBase *ty;\n };\n \n+class TupleType : public TyBase\n+{\n+public:\n+  TupleType (HirId ref, std::vector<HirId> fields,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::TUPLE, refs), fields (fields)\n+  {}\n+\n+  TupleType (HirId ref, HirId ty_ref, std::vector<HirId> fields,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::TUPLE, refs), fields (fields)\n+  {}\n+\n+  void accept_vis (TyVisitor &vis) override;\n+\n+  bool is_unit () const override { return false; }\n+\n+  std::string as_string () const override;\n+\n+  TyBase *combine (TyBase *other) override;\n+\n+  size_t num_fields () const { return fields.size (); }\n+\n+  TyBase *get_field (size_t index) const;\n+\n+  TyBase *clone () final override;\n+\n+  void iterate_fields (std::function<bool (TyBase *)> cb) const\n+  {\n+    for (size_t i = 0; i < num_fields (); i++)\n+      {\n+\tif (!cb (get_field (i)))\n+\t  return;\n+      }\n+  }\n+\n+private:\n+  std::vector<HirId> fields;\n+};\n+\n class ADTType : public TyBase\n {\n public:\n-  ADTType (HirId ref, std::string identifier, bool is_tuple,\n-\t   std::vector<StructFieldType *> fields)\n-    : TyBase (ref, ref, TypeKind::ADT), identifier (identifier),\n-      is_tuple (is_tuple), fields (fields)\n+  ADTType (HirId ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ADT, refs), identifier (identifier),\n+      fields (fields)\n   {}\n \n-  ADTType (HirId ref, HirId ty_ref, std::string identifier, bool is_tuple,\n-\t   std::vector<StructFieldType *> fields)\n-    : TyBase (ref, ty_ref, TypeKind::ADT), identifier (identifier),\n-      is_tuple (is_tuple), fields (fields)\n+  ADTType (HirId ref, HirId ty_ref, std::string identifier,\n+\t   std::vector<StructFieldType *> fields,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ADT, refs), identifier (identifier),\n+      fields (fields)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -193,8 +271,6 @@ class ADTType : public TyBase\n \n   std::string get_name () const { return identifier; }\n \n-  bool is_tuple_struct () const { return is_tuple; }\n-\n   StructFieldType *get_field (size_t index) { return fields.at (index); }\n \n   StructFieldType *get_field (const std::string &lookup,\n@@ -230,23 +306,22 @@ class ADTType : public TyBase\n \n private:\n   std::string identifier;\n-  bool is_tuple;\n   std::vector<StructFieldType *> fields;\n };\n \n class FnType : public TyBase\n {\n public:\n   FnType (HirId ref, std::vector<std::pair<HIR::Pattern *, TyBase *> > params,\n-\t  TyBase *type)\n-    : TyBase (ref, ref, TypeKind::FNDEF), params (std::move (params)),\n+\t  TyBase *type, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FNDEF, refs), params (std::move (params)),\n       type (type)\n   {}\n \n   FnType (HirId ref, HirId ty_ref,\n \t  std::vector<std::pair<HIR::Pattern *, TyBase *> > params,\n-\t  TyBase *type)\n-    : TyBase (ref, ty_ref, TypeKind::FNDEF), params (params), type (type)\n+\t  TyBase *type, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FNDEF, refs), params (params), type (type)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -281,12 +356,16 @@ class FnType : public TyBase\n class ArrayType : public TyBase\n {\n public:\n-  ArrayType (HirId ref, size_t capacity, TyBase *type)\n-    : TyBase (ref, ref, TypeKind::ARRAY), capacity (capacity), type (type)\n+  ArrayType (HirId ref, size_t capacity, TyBase *type,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::ARRAY, refs), capacity (capacity),\n+      element_type_id (type->get_ref ())\n   {}\n \n-  ArrayType (HirId ref, HirId ty_ref, size_t capacity, TyBase *type)\n-    : TyBase (ref, ty_ref, TypeKind::ARRAY), capacity (capacity), type (type)\n+  ArrayType (HirId ref, HirId ty_ref, size_t capacity, TyBase *type,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::ARRAY, refs), capacity (capacity),\n+      element_type_id (type->get_ref ())\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -297,21 +376,27 @@ class ArrayType : public TyBase\n \n   size_t get_capacity () const { return capacity; }\n \n-  TyBase *get_type () { return type; }\n+  HirId element_type_ref () const { return element_type_id; }\n+\n+  TyBase *get_type () const;\n \n   TyBase *clone () final override;\n \n private:\n   size_t capacity;\n-  TyBase *type;\n+  HirId element_type_id;\n };\n \n class BoolType : public TyBase\n {\n public:\n-  BoolType (HirId ref) : TyBase (ref, ref, TypeKind::BOOL) {}\n+  BoolType (HirId ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::BOOL, refs)\n+  {}\n \n-  BoolType (HirId ref, HirId ty_ref) : TyBase (ref, ty_ref, TypeKind::BOOL) {}\n+  BoolType (HirId ref, HirId ty_ref, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::BOOL, refs)\n+  {}\n \n   void accept_vis (TyVisitor &vis) override;\n \n@@ -334,12 +419,13 @@ class IntType : public TyBase\n     I128\n   };\n \n-  IntType (HirId ref, IntKind kind)\n-    : TyBase (ref, ref, TypeKind::INT), int_kind (kind)\n+  IntType (HirId ref, IntKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::INT, refs), int_kind (kind)\n   {}\n \n-  IntType (HirId ref, HirId ty_ref, IntKind kind)\n-    : TyBase (ref, ty_ref, TypeKind::INT), int_kind (kind)\n+  IntType (HirId ref, HirId ty_ref, IntKind kind,\n+\t   std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::INT, refs), int_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -368,12 +454,13 @@ class UintType : public TyBase\n     U128\n   };\n \n-  UintType (HirId ref, UintKind kind)\n-    : TyBase (ref, ref, TypeKind::UINT), uint_kind (kind)\n+  UintType (HirId ref, UintKind kind, std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::UINT, refs), uint_kind (kind)\n   {}\n \n-  UintType (HirId ref, HirId ty_ref, UintKind kind)\n-    : TyBase (ref, ty_ref, TypeKind::UINT), uint_kind (kind)\n+  UintType (HirId ref, HirId ty_ref, UintKind kind,\n+\t    std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::UINT, refs), uint_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;\n@@ -399,12 +486,14 @@ class FloatType : public TyBase\n     F64\n   };\n \n-  FloatType (HirId ref, FloatKind kind)\n-    : TyBase (ref, ref, TypeKind::FLOAT), float_kind (kind)\n+  FloatType (HirId ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ref, TypeKind::FLOAT, refs), float_kind (kind)\n   {}\n \n-  FloatType (HirId ref, HirId ty_ref, FloatKind kind)\n-    : TyBase (ref, ty_ref, TypeKind::FLOAT), float_kind (kind)\n+  FloatType (HirId ref, HirId ty_ref, FloatKind kind,\n+\t     std::set<HirId> refs = std::set<HirId> ())\n+    : TyBase (ref, ty_ref, TypeKind::FLOAT, refs), float_kind (kind)\n   {}\n \n   void accept_vis (TyVisitor &vis) override;"}, {"sha": "925130f020a1bceba1f3b2c7b05d5e3f4de412ce", "filename": "gcc/rust/util/rust-hir-map.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Futil%2Frust-hir-map.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Futil%2Frust-hir-map.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.cc?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -159,6 +159,7 @@ Mappings::get_next_hir_id (CrateNum crateNum)\n \n   auto id = it->second + 1;\n   hirIdIter[crateNum] = id;\n+  hirNodesWithinCrate[crateNum].insert (id);\n   return id;\n }\n "}, {"sha": "4859d1e6d20d9429a59241e2419cb15a9ef11f8e", "filename": "gcc/rust/util/rust-hir-map.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Futil%2Frust-hir-map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Frust%2Futil%2Frust-hir-map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Frust%2Futil%2Frust-hir-map.h?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -143,6 +143,11 @@ class Mappings\n     return resolve_nodeid_to_stmt (get_current_crate (), id, stmt);\n   }\n \n+  std::set<HirId> &get_hirids_within_crate (CrateNum crate)\n+  {\n+    return hirNodesWithinCrate[crate];\n+  }\n+\n private:\n   Mappings ();\n \n@@ -171,6 +176,9 @@ class Mappings\n \n   // reverse mappings\n   std::map<CrateNum, std::map<NodeId, HirId> > nodeIdToHirMappings;\n+\n+  // all hirid nodes\n+  std::map<CrateNum, std::set<HirId> > hirNodesWithinCrate;\n };\n \n } // namespace Analysis"}, {"sha": "3170c7c4549935bd18fc8b496cc219965e639de4", "filename": "gcc/testsuite/rust.test/compilable/ints_infer1.rs", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Fints_infer1.rs?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -0,0 +1,18 @@\n+const TEST_CONST: i32 = 10;\n+\n+fn main() {\n+    let mut x = TEST_CONST;\n+    x = x + 1;\n+\n+    let mut y = x + TEST_CONST;\n+\n+    let z = 1u32;\n+\n+    let a = z;\n+\n+    let b;\n+    b = 1;\n+\n+    let c;\n+    c = a;\n+}"}, {"sha": "f6eac9e2eb7c3997f9c9f7b17751f61a9d8947a7", "filename": "gcc/testsuite/rust.test/compilable/type_infer6.rs", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0817c29a423aca1c4c3f9ba812f67df35f36fc65/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Frust.test%2Fcompilable%2Ftype_infer6.rs?ref=0817c29a423aca1c4c3f9ba812f67df35f36fc65", "patch": "@@ -0,0 +1,12 @@\n+fn test(x: u32) -> u32 {\n+    return x + 1;\n+}\n+\n+fn main() {\n+    let a;\n+    a = 1;\n+    let b = test(a);\n+\n+    let c = 1;\n+    let d = test(c + 1);\n+}"}]}