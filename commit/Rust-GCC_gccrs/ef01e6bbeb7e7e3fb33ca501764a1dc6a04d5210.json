{"sha": "ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZWYwMWU2YmJlYjdlN2UzZmIzM2NhNTAxNzY0YTFkYzZhMDRkNTIxMA==", "commit": {"author": {"name": "Dennis Zhang", "email": "dennis.zhang@arm.com", "date": "2019-11-19T13:43:39Z"}, "committer": {"name": "Kyrylo Tkachov", "email": "ktkachov@gcc.gnu.org", "date": "2019-11-19T13:43:39Z"}, "message": "[AArch64] Implement Armv8.5-A memory tagging (MTE) intrinsics\n\n2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n\n\t* config/aarch64/aarch64-builtins.c (enum aarch64_builtins): Add\n\tAARCH64_MEMTAG_BUILTIN_START, AARCH64_MEMTAG_BUILTIN_IRG,\n\tAARCH64_MEMTAG_BUILTIN_GMI, AARCH64_MEMTAG_BUILTIN_SUBP,\n\tAARCH64_MEMTAG_BUILTIN_INC_TAG, AARCH64_MEMTAG_BUILTIN_SET_TAG,\n\tAARCH64_MEMTAG_BUILTIN_GET_TAG, and AARCH64_MEMTAG_BUILTIN_END.\n\t(aarch64_init_memtag_builtins): New.\n\t(AARCH64_INIT_MEMTAG_BUILTINS_DECL): New macro.\n\t(aarch64_general_init_builtins): Call aarch64_init_memtag_builtins.\n\t(aarch64_expand_builtin_memtag): New.\n\t(aarch64_general_expand_builtin): Call aarch64_expand_builtin_memtag.\n\t(AARCH64_BUILTIN_SUBCODE): New macro.\n\t(aarch64_resolve_overloaded_memtag): New.\n\t(aarch64_resolve_overloaded_builtin_general): New. Call\n\taarch64_resolve_overloaded_memtag to handle overloaded MTE builtins.\n\t* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define\n\t__ARM_FEATURE_MEMORY_TAGGING when enabled.\n\t(aarch64_resolve_overloaded_builtin): Call\n\taarch64_resolve_overloaded_builtin_general.\n\t* config/aarch64/aarch64-protos.h\n\t(aarch64_resolve_overloaded_builtin_general): New declaration.\n\t* config/aarch64/aarch64.h (AARCH64_ISA_MEMTAG): New macro.\n\t(TARGET_MEMTAG): Likewise.\n\t* config/aarch64/aarch64.md (UNSPEC_GEN_TAG): New unspec.\n\t(UNSPEC_GEN_TAG_RND, and UNSPEC_TAG_SPACE): Likewise.\n\t(irg, gmi, subp, addg, ldg, stg): New instructions.\n\t* config/aarch64/arm_acle.h (__arm_mte_create_random_tag): New macro.\n\t(__arm_mte_exclude_tag, __arm_mte_ptrdiff): Likewise.\n\t(__arm_mte_increment_tag, __arm_mte_set_tag): Likewise.\n\t(__arm_mte_get_tag): Likewise.\n\t* config/aarch64/predicates.md (aarch64_memtag_tag_offset): New.\n\t(aarch64_granule16_uimm6, aarch64_granule16_simm9): New.\n\t* config/arm/types.md (memtag): New.\n\t* doc/invoke.texi (-memtag): Update description.\n\n2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n\n\t* gcc.target/aarch64/acle/memtag_1.c: New test.\n\t* gcc.target/aarch64/acle/memtag_2.c: New test.\n\t* gcc.target/aarch64/acle/memtag_3.c: New test.\n\nFrom-SVN: r278444", "tree": {"sha": "f84eb2d6cf761406fa4d455369c59a225df727f7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f84eb2d6cf761406fa4d455369c59a225df727f7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/comments", "author": null, "committer": null, "parents": [{"sha": "35ba842f23769782d1b12f31aa2cdfce70ece031", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/35ba842f23769782d1b12f31aa2cdfce70ece031", "html_url": "https://github.com/Rust-GCC/gccrs/commit/35ba842f23769782d1b12f31aa2cdfce70ece031"}], "stats": {"total": 570, "additions": 564, "deletions": 6}, "files": [{"sha": "81cab100956fd7fefad5ab7418debe9d5ebcce8a", "filename": "gcc/ChangeLog", "status": "modified", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -1,3 +1,39 @@\n+2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n+\n+\t* config/aarch64/aarch64-builtins.c (enum aarch64_builtins): Add\n+\tAARCH64_MEMTAG_BUILTIN_START, AARCH64_MEMTAG_BUILTIN_IRG,\n+\tAARCH64_MEMTAG_BUILTIN_GMI, AARCH64_MEMTAG_BUILTIN_SUBP,\n+\tAARCH64_MEMTAG_BUILTIN_INC_TAG, AARCH64_MEMTAG_BUILTIN_SET_TAG,\n+\tAARCH64_MEMTAG_BUILTIN_GET_TAG, and AARCH64_MEMTAG_BUILTIN_END.\n+\t(aarch64_init_memtag_builtins): New.\n+\t(AARCH64_INIT_MEMTAG_BUILTINS_DECL): New macro.\n+\t(aarch64_general_init_builtins): Call aarch64_init_memtag_builtins.\n+\t(aarch64_expand_builtin_memtag): New.\n+\t(aarch64_general_expand_builtin): Call aarch64_expand_builtin_memtag.\n+\t(AARCH64_BUILTIN_SUBCODE): New macro.\n+\t(aarch64_resolve_overloaded_memtag): New.\n+\t(aarch64_resolve_overloaded_builtin_general): New. Call\n+\taarch64_resolve_overloaded_memtag to handle overloaded MTE builtins.\n+\t* config/aarch64/aarch64-c.c (aarch64_update_cpp_builtins): Define\n+\t__ARM_FEATURE_MEMORY_TAGGING when enabled.\n+\t(aarch64_resolve_overloaded_builtin): Call\n+\taarch64_resolve_overloaded_builtin_general.\n+\t* config/aarch64/aarch64-protos.h\n+\t(aarch64_resolve_overloaded_builtin_general): New declaration.\n+\t* config/aarch64/aarch64.h (AARCH64_ISA_MEMTAG): New macro.\n+\t(TARGET_MEMTAG): Likewise.\n+\t* config/aarch64/aarch64.md (UNSPEC_GEN_TAG): New unspec.\n+\t(UNSPEC_GEN_TAG_RND, and UNSPEC_TAG_SPACE): Likewise.\n+\t(irg, gmi, subp, addg, ldg, stg): New instructions.\n+\t* config/aarch64/arm_acle.h (__arm_mte_create_random_tag): New macro.\n+\t(__arm_mte_exclude_tag, __arm_mte_ptrdiff): Likewise.\n+\t(__arm_mte_increment_tag, __arm_mte_set_tag): Likewise.\n+\t(__arm_mte_get_tag): Likewise.\n+\t* config/aarch64/predicates.md (aarch64_memtag_tag_offset): New.\n+\t(aarch64_granule16_uimm6, aarch64_granule16_simm9): New.\n+\t* config/arm/types.md (memtag): New.\n+\t* doc/invoke.texi (-memtag): Update description.\n+\n 2019-11-19  Richard Henderson  <richard.henderson@linaro.org>\n \n \t* config/arm/arm-c.c (arm_cpu_builtins): Use def_or_undef_macro"}, {"sha": "c35a1b1f0299ce5af8ca1a3df0209614f7bd0f25", "filename": "gcc/config/aarch64/aarch64-builtins.c", "status": "modified", "additions": 234, "deletions": 0, "changes": 234, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-builtins.c?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -448,6 +448,15 @@ enum aarch64_builtins\n   /* Armv8.5-a RNG instruction builtins.  */\n   AARCH64_BUILTIN_RNG_RNDR,\n   AARCH64_BUILTIN_RNG_RNDRRS,\n+  /* MEMTAG builtins.  */\n+  AARCH64_MEMTAG_BUILTIN_START,\n+  AARCH64_MEMTAG_BUILTIN_IRG,\n+  AARCH64_MEMTAG_BUILTIN_GMI,\n+  AARCH64_MEMTAG_BUILTIN_SUBP,\n+  AARCH64_MEMTAG_BUILTIN_INC_TAG,\n+  AARCH64_MEMTAG_BUILTIN_SET_TAG,\n+  AARCH64_MEMTAG_BUILTIN_GET_TAG,\n+  AARCH64_MEMTAG_BUILTIN_END,\n   AARCH64_BUILTIN_MAX\n };\n \n@@ -1130,6 +1139,51 @@ aarch64_init_rng_builtins (void)\n \t\t\t\t   AARCH64_BUILTIN_RNG_RNDRRS);\n }\n \n+/* Initialize the memory tagging extension (MTE) builtins.  */\n+struct\n+{\n+  tree ftype;\n+  enum insn_code icode;\n+} aarch64_memtag_builtin_data[AARCH64_MEMTAG_BUILTIN_END -\n+\t\t\t      AARCH64_MEMTAG_BUILTIN_START - 1];\n+\n+static void\n+aarch64_init_memtag_builtins (void)\n+{\n+  tree fntype = NULL;\n+\n+#define AARCH64_INIT_MEMTAG_BUILTINS_DECL(F, N, I, T) \\\n+  aarch64_builtin_decls[AARCH64_MEMTAG_BUILTIN_##F] \\\n+    = aarch64_general_add_builtin (\"__builtin_aarch64_memtag_\"#N, \\\n+\t\t\t\t   T, AARCH64_MEMTAG_BUILTIN_##F); \\\n+  aarch64_memtag_builtin_data[AARCH64_MEMTAG_BUILTIN_##F - \\\n+\t\t\t      AARCH64_MEMTAG_BUILTIN_START - 1] = \\\n+\t\t\t\t{T, CODE_FOR_##I};\n+\n+  fntype = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t     uint64_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (IRG, irg, irg, fntype);\n+\n+  fntype = build_function_type_list (uint64_type_node, ptr_type_node,\n+\t\t\t\t     uint64_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (GMI, gmi, gmi, fntype);\n+\n+  fntype = build_function_type_list (ptrdiff_type_node, ptr_type_node,\n+\t\t\t\t     ptr_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (SUBP, subp, subp, fntype);\n+\n+  fntype = build_function_type_list (ptr_type_node, ptr_type_node,\n+\t\t\t\t     unsigned_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (INC_TAG, inc_tag, addg, fntype);\n+\n+  fntype = build_function_type_list (void_type_node, ptr_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (SET_TAG, set_tag, stg, fntype);\n+\n+  fntype = build_function_type_list (ptr_type_node, ptr_type_node, NULL);\n+  AARCH64_INIT_MEMTAG_BUILTINS_DECL (GET_TAG, get_tag, ldg, fntype);\n+\n+#undef AARCH64_INIT_MEMTAG_BUILTINS_DECL\n+}\n \n /* Initialize all builtins in the AARCH64_BUILTIN_GENERAL group.  */\n \n@@ -1184,6 +1238,9 @@ aarch64_general_init_builtins (void)\n \n   if (TARGET_TME)\n     aarch64_init_tme_builtins ();\n+\n+  if (TARGET_MEMTAG)\n+    aarch64_init_memtag_builtins ();\n }\n \n /* Implement TARGET_BUILTIN_DECL for the AARCH64_BUILTIN_GENERAL group.  */\n@@ -1665,6 +1722,79 @@ aarch64_expand_rng_builtin (tree exp, rtx target, int fcode, int ignore)\n   return target;\n }\n \n+/* Expand an expression EXP that calls a MEMTAG built-in FCODE\n+   with result going to TARGET.  */\n+static rtx\n+aarch64_expand_builtin_memtag (int fcode, tree exp, rtx target)\n+{\n+  if (TARGET_ILP32)\n+    {\n+      error (\"Memory Tagging Extension does not support %<-mabi=ilp32%>\");\n+      return const0_rtx;\n+    }\n+\n+  rtx pat = NULL;\n+  enum insn_code icode = aarch64_memtag_builtin_data[fcode -\n+\t\t\t   AARCH64_MEMTAG_BUILTIN_START - 1].icode;\n+\n+  rtx op0 = expand_normal (CALL_EXPR_ARG (exp, 0));\n+  machine_mode mode0 = GET_MODE (op0);\n+  op0 = force_reg (mode0 == VOIDmode ? DImode : mode0, op0);\n+  op0 = convert_to_mode (DImode, op0, true);\n+\n+  switch (fcode)\n+    {\n+      case AARCH64_MEMTAG_BUILTIN_IRG:\n+      case AARCH64_MEMTAG_BUILTIN_GMI:\n+      case AARCH64_MEMTAG_BUILTIN_SUBP:\n+      case AARCH64_MEMTAG_BUILTIN_INC_TAG:\n+\t{\n+\t  if (! target\n+\t      || GET_MODE (target) != DImode\n+\t      || ! (*insn_data[icode].operand[0].predicate) (target, DImode))\n+\t    target = gen_reg_rtx (DImode);\n+\n+\t  if (fcode == AARCH64_MEMTAG_BUILTIN_INC_TAG)\n+\t    {\n+\t      rtx op1 = expand_normal (CALL_EXPR_ARG (exp, 1));\n+\n+\t      if ((*insn_data[icode].operand[3].predicate) (op1, QImode))\n+\t\t{\n+\t\t  pat = GEN_FCN (icode) (target, op0, const0_rtx, op1);\n+\t\t  break;\n+\t\t}\n+\t      error (\"%Kargument %d must be a constant immediate \"\n+\t\t     \"in range [0,15]\", exp, 2);\n+\t      return const0_rtx;\n+\t    }\n+\t  else\n+\t    {\n+\t      rtx op1 = expand_normal (CALL_EXPR_ARG (exp, 1));\n+\t      machine_mode mode1 = GET_MODE (op1);\n+\t      op1 = force_reg (mode1 == VOIDmode ? DImode : mode1, op1);\n+\t      op1 = convert_to_mode (DImode, op1, true);\n+\t      pat = GEN_FCN (icode) (target, op0, op1);\n+\t    }\n+\t  break;\n+\t}\n+      case AARCH64_MEMTAG_BUILTIN_GET_TAG:\n+\ttarget = op0;\n+\tpat = GEN_FCN (icode) (target, op0, const0_rtx);\n+\tbreak;\n+      case AARCH64_MEMTAG_BUILTIN_SET_TAG:\n+\tpat = GEN_FCN (icode) (op0, op0, const0_rtx);\n+\tbreak;\n+      default:\n+\tgcc_unreachable();\n+    }\n+\n+  if (!pat)\n+    return NULL_RTX;\n+\n+  emit_insn (pat);\n+  return target;\n+}\n+\n /* Expand an expression EXP that calls built-in function FCODE,\n    with result going to TARGET if that's convenient.  IGNORE is true\n    if the result of the builtin is ignored.  */\n@@ -1800,6 +1930,10 @@ aarch64_general_expand_builtin (unsigned int fcode, tree exp, rtx target,\n       || fcode == AARCH64_TME_BUILTIN_TCANCEL)\n     return aarch64_expand_builtin_tme (fcode, exp, target);\n \n+  if (fcode >= AARCH64_MEMTAG_BUILTIN_START\n+      && fcode <= AARCH64_MEMTAG_BUILTIN_END)\n+    return aarch64_expand_builtin_memtag (fcode, exp, target);\n+\n   gcc_unreachable ();\n }\n \n@@ -2151,6 +2285,106 @@ aarch64_atomic_assign_expand_fenv (tree *hold, tree *clear, tree *update)\n \t\t\t    reload_fenv, restore_fnenv), update_call);\n }\n \n+/* Resolve overloaded MEMTAG build-in functions.  */\n+#define AARCH64_BUILTIN_SUBCODE(F) \\\n+  (DECL_MD_FUNCTION_CODE (F) >> AARCH64_BUILTIN_SHIFT)\n+\n+static tree\n+aarch64_resolve_overloaded_memtag (location_t loc,\n+\t\t\t\t   tree fndecl, void *pass_params)\n+{\n+  vec<tree, va_gc> *params = static_cast<vec<tree, va_gc> *> (pass_params);\n+  unsigned param_num = params ? params->length() : 0;\n+  unsigned int fcode = AARCH64_BUILTIN_SUBCODE (fndecl);\n+  tree inittype = aarch64_memtag_builtin_data[\n+\t\t    fcode - AARCH64_MEMTAG_BUILTIN_START - 1].ftype;\n+  unsigned arg_num = list_length (TYPE_ARG_TYPES (inittype)) - 1;\n+\n+  if (param_num != arg_num)\n+    {\n+      TREE_TYPE (fndecl) = inittype;\n+      return NULL_TREE;\n+    }\n+  tree retype = NULL;\n+\n+  if (fcode == AARCH64_MEMTAG_BUILTIN_SUBP)\n+    {\n+      tree t0 = TREE_TYPE ((*params)[0]);\n+      tree t1 = TREE_TYPE ((*params)[1]);\n+\n+      if (t0 == error_mark_node || TREE_CODE (t0) != POINTER_TYPE)\n+\tt0 = ptr_type_node;\n+      if (t1 == error_mark_node || TREE_CODE (t1) != POINTER_TYPE)\n+\tt1 = ptr_type_node;\n+\n+      if (TYPE_MODE (t0) != DImode)\n+\twarning_at (loc, 1, \"expected 64-bit address but argument 1 is %d-bit\",\n+\t    (int)tree_to_shwi (DECL_SIZE ((*params)[0])));\n+\n+      if (TYPE_MODE (t1) != DImode)\n+\twarning_at (loc, 1, \"expected 64-bit address but argument 2 is %d-bit\",\n+\t    (int)tree_to_shwi (DECL_SIZE ((*params)[1])));\n+\n+      retype = build_function_type_list (ptrdiff_type_node, t0, t1, NULL);\n+    }\n+  else\n+    {\n+      tree t0 = TREE_TYPE ((*params)[0]);\n+\n+      if (t0 == error_mark_node || TREE_CODE (t0) != POINTER_TYPE)\n+\t{\n+\t  TREE_TYPE (fndecl) = inittype;\n+\t  return NULL_TREE;\n+\t}\n+\n+      if (TYPE_MODE (t0) != DImode)\n+\twarning_at (loc, 1, \"expected 64-bit address but argument 1 is %d-bit\",\n+\t    (int)tree_to_shwi (DECL_SIZE ((*params)[0])));\n+\n+      switch (fcode)\n+\t{\n+\tcase AARCH64_MEMTAG_BUILTIN_IRG:\n+\t  retype = build_function_type_list (t0, t0, uint64_type_node, NULL);\n+\t  break;\n+\tcase AARCH64_MEMTAG_BUILTIN_GMI:\n+\t  retype = build_function_type_list (uint64_type_node, t0,\n+\t      uint64_type_node, NULL);\n+\t  break;\n+\tcase AARCH64_MEMTAG_BUILTIN_INC_TAG:\n+\t  retype = build_function_type_list (t0, t0, unsigned_type_node, NULL);\n+\t  break;\n+\tcase AARCH64_MEMTAG_BUILTIN_SET_TAG:\n+\t  retype = build_function_type_list (void_type_node, t0, NULL);\n+\t  break;\n+\tcase AARCH64_MEMTAG_BUILTIN_GET_TAG:\n+\t  retype = build_function_type_list (t0, t0, NULL);\n+\t  break;\n+\tdefault:\n+\t  return NULL_TREE;\n+\t}\n+    }\n+\n+  if (!retype || retype == error_mark_node)\n+    TREE_TYPE (fndecl) = inittype;\n+  else\n+    TREE_TYPE (fndecl) = retype;\n+\n+  return NULL_TREE;\n+}\n+\n+/* Called at aarch64_resolve_overloaded_builtin in aarch64-c.c.  */\n+tree\n+aarch64_resolve_overloaded_builtin_general (location_t loc, tree function,\n+\t\t\t\t\t    void *pass_params)\n+{\n+  unsigned int fcode = AARCH64_BUILTIN_SUBCODE (function);\n+\n+  if (fcode >= AARCH64_MEMTAG_BUILTIN_START\n+      && fcode <= AARCH64_MEMTAG_BUILTIN_END)\n+    return aarch64_resolve_overloaded_memtag(loc, function, pass_params);\n+\n+  return NULL_TREE;\n+}\n \n #undef AARCH64_CHECK_BUILTIN_MODE\n #undef AARCH64_FIND_FRINT_VARIANT"}, {"sha": "f3da07fd28aecd523ab78f9202b115af3a1c9929", "filename": "gcc/config/aarch64/aarch64-c.c", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-c.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-c.c?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -163,6 +163,7 @@ aarch64_update_cpp_builtins (cpp_reader *pfile)\n   aarch64_def_or_undef (TARGET_FRINT, \"__ARM_FEATURE_FRINT\", pfile);\n   aarch64_def_or_undef (TARGET_TME, \"__ARM_FEATURE_TME\", pfile);\n   aarch64_def_or_undef (TARGET_RNG, \"__ARM_FEATURE_RNG\", pfile);\n+  aarch64_def_or_undef (TARGET_MEMTAG, \"__ARM_FEATURE_MEMORY_TAGGING\", pfile);\n \n   /* Not for ACLE, but required to keep \"float.h\" correct if we switch\n      target between implementations that do or do not support ARMv8.2-A\n@@ -279,8 +280,8 @@ aarch64_resolve_overloaded_builtin (unsigned int uncast_location,\n   switch (code & AARCH64_BUILTIN_CLASS)\n     {\n     case AARCH64_BUILTIN_GENERAL:\n-      return NULL_TREE;\n-\n+      return aarch64_resolve_overloaded_builtin_general (location, fndecl,\n+\t\t\t\t\t\t\t uncast_arglist);\n     case AARCH64_BUILTIN_SVE:\n       new_fndecl = aarch64_sve::resolve_overloaded_builtin (location, subcode,\n \t\t\t\t\t\t\t    arglist);"}, {"sha": "5b1fc7b7b28b3c62a1940f9b4e893056ec18f8d1", "filename": "gcc/config/aarch64/aarch64-protos.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64-protos.h?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -773,4 +773,6 @@ extern const atomic_ool_names aarch64_ool_ldset_names;\n extern const atomic_ool_names aarch64_ool_ldclr_names;\n extern const atomic_ool_names aarch64_ool_ldeor_names;\n \n+tree aarch64_resolve_overloaded_builtin_general (location_t, tree, void *);\n+\n #endif /* GCC_AARCH64_PROTOS_H */"}, {"sha": "ee01909abb9242394d79bce7a549261839163c47", "filename": "gcc/config/aarch64/aarch64.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.h?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -248,6 +248,7 @@ extern unsigned aarch64_architecture_version;\n #define AARCH64_ISA_RNG\t\t   (aarch64_isa_flags & AARCH64_FL_RNG)\n #define AARCH64_ISA_V8_5\t   (aarch64_isa_flags & AARCH64_FL_V8_5)\n #define AARCH64_ISA_TME\t\t   (aarch64_isa_flags & AARCH64_FL_TME)\n+#define AARCH64_ISA_MEMTAG\t   (aarch64_isa_flags & AARCH64_FL_MEMTAG)\n \n /* Crypto is an optional extension to AdvSIMD.  */\n #define TARGET_CRYPTO (TARGET_SIMD && AARCH64_ISA_CRYPTO)\n@@ -304,6 +305,9 @@ extern unsigned aarch64_architecture_version;\n /* Random number instructions from Armv8.5-a.  */\n #define TARGET_RNG (AARCH64_ISA_RNG)\n \n+/* Memory Tagging instructions optional to Armv8.5 enabled through +memtag.  */\n+#define TARGET_MEMTAG (AARCH64_ISA_V8_5 && AARCH64_ISA_MEMTAG)\n+\n /* Make sure this is always defined so we don't have to check for ifdefs\n    but rather use normal ifs.  */\n #ifndef TARGET_FIX_ERR_A53_835769_DEFAULT"}, {"sha": "b11ead7ab23d78bb5b45662fecb73dd0f4e0fda0", "filename": "gcc/config/aarch64/aarch64.md", "status": "modified", "additions": 90, "deletions": 0, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Faarch64.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Faarch64.md?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -270,6 +270,9 @@\n     UNSPEC_SVE_PREFETCH_GATHER\n     UNSPEC_SVE_COMPACT\n     UNSPEC_SVE_SPLICE\n+    UNSPEC_GEN_TAG\t\t; Generate a 4-bit MTE tag.\n+    UNSPEC_GEN_TAG_RND\t\t; Generate a random 4-bit MTE tag.\n+    UNSPEC_TAG_SPACE\t\t; Translate address to MTE tag address space.\n ])\n \n (define_c_enum \"unspecv\" [\n@@ -7386,6 +7389,93 @@\n   [(set_attr \"type\" \"mrs\")]\n )\n \n+;; Memory Tagging Extension (MTE) instructions.\n+\n+(define_insn \"irg\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rk\")\n+\t(ior:DI\n+\t (and:DI (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t (const_int -1080863910568919041)) ;; 0xf0ff...\n+\t (ashift:DI (unspec:QI [(match_operand:DI 2 \"register_operand\" \"r\")]\n+\t\t     UNSPEC_GEN_TAG_RND)\n+\t\t    (const_int 56))))]\n+  \"TARGET_MEMTAG\"\n+  \"irg\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n+(define_insn \"gmi\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(ior:DI (ashift:DI\n+\t\t (const_int 1)\n+\t\t (and:QI (lshiftrt:DI\n+\t\t\t  (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t\t  (const_int 56)) (const_int 15)))\n+\t\t(match_operand:DI 2 \"register_operand\" \"r\")))]\n+  \"TARGET_MEMTAG\"\n+  \"gmi\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n+(define_insn \"addg\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=rk\")\n+\t(ior:DI\n+\t (and:DI (plus:DI (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t\t  (match_operand:DI 2 \"aarch64_granule16_uimm6\" \"i\"))\n+\t\t (const_int -1080863910568919041)) ;; 0xf0ff...\n+\t (ashift:DI\n+\t  (unspec:QI\n+\t   [(and:QI (lshiftrt:DI (match_dup 1) (const_int 56)) (const_int 15))\n+\t    (match_operand:QI 3 \"aarch64_memtag_tag_offset\" \"i\")]\n+\t   UNSPEC_GEN_TAG)\n+\t  (const_int 56))))]\n+  \"TARGET_MEMTAG\"\n+  \"addg\\\\t%0, %1, #%2, #%3\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n+(define_insn \"subp\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"=r\")\n+\t(minus:DI\n+\t  (and:DI (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t  (const_int 72057594037927935)) ;; 0x00ff...\n+\t  (and:DI (match_operand:DI 2 \"register_operand\" \"rk\")\n+\t\t  (const_int 72057594037927935))))] ;; 0x00ff...\n+  \"TARGET_MEMTAG\"\n+  \"subp\\\\t%0, %1, %2\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n+;; LDG will use the 16-byte aligned value of the address.\n+(define_insn \"ldg\"\n+  [(set (match_operand:DI 0 \"register_operand\" \"+r\")\n+\t(ior:DI\n+\t (and:DI (match_dup 0) (const_int -1080863910568919041)) ;; 0xf0ff...\n+\t (ashift:DI\n+\t  (mem:QI (unspec:DI\n+\t   [(and:DI (plus:DI (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t\t     (match_operand:DI 2 \"aarch64_granule16_simm9\" \"i\"))\n+\t\t    (const_int -16))] UNSPEC_TAG_SPACE))\n+\t  (const_int 56))))]\n+  \"TARGET_MEMTAG\"\n+  \"ldg\\\\t%0, [%1, #%2]\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n+;; STG doesn't align the address but aborts with alignment fault\n+;; when the address is not 16-byte aligned.\n+(define_insn \"stg\"\n+  [(set (mem:QI (unspec:DI\n+\t [(plus:DI (match_operand:DI 1 \"register_operand\" \"rk\")\n+\t\t   (match_operand:DI 2 \"aarch64_granule16_simm9\" \"i\"))]\n+\t UNSPEC_TAG_SPACE))\n+\t(and:QI (lshiftrt:DI (match_operand:DI 0 \"register_operand\" \"rk\")\n+\t\t\t     (const_int 56)) (const_int 15)))]\n+  \"TARGET_MEMTAG\"\n+  \"stg\\\\t%0, [%1, #%2]\"\n+  [(set_attr \"type\" \"memtag\")]\n+)\n+\n ;; AdvSIMD Stuff\n (include \"aarch64-simd.md\")\n "}, {"sha": "1dfac866e0a654d87783986b27d6ac8df42a16a6", "filename": "gcc/config/aarch64/arm_acle.h", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Farm_acle.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Farm_acle.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Farm_acle.h?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -209,6 +209,29 @@ __rndrrs (uint64_t *__res)\n \n #pragma GCC pop_options\n \n+#pragma GCC push_options\n+#pragma GCC target (\"arch=armv8.5-a+memtag\")\n+\n+#define __arm_mte_create_random_tag(__ptr, __u64_mask) \\\n+  __builtin_aarch64_memtag_irg(__ptr, __u64_mask)\n+\n+#define __arm_mte_exclude_tag(__ptr, __u64_excluded) \\\n+  __builtin_aarch64_memtag_gmi(__ptr, __u64_excluded)\n+\n+#define __arm_mte_ptrdiff(__ptr_a, __ptr_b) \\\n+  __builtin_aarch64_memtag_subp(__ptr_a, __ptr_b)\n+\n+#define __arm_mte_increment_tag(__ptr, __u_offset) \\\n+  __builtin_aarch64_memtag_inc_tag(__ptr, __u_offset)\n+\n+#define __arm_mte_set_tag(__tagged_address) \\\n+  __builtin_aarch64_memtag_set_tag(__tagged_address)\n+\n+#define __arm_mte_get_tag(__address) \\\n+  __builtin_aarch64_memtag_get_tag(__address)\n+\n+#pragma GCC pop_options\n+\n #ifdef __cplusplus\n }\n #endif"}, {"sha": "da6779e790cb70203ea9920fadb5b926321d1576", "filename": "gcc/config/aarch64/predicates.md", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Faarch64%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Faarch64%2Fpredicates.md?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -874,3 +874,17 @@\n   (and (match_code \"const_int,const_poly_int\")\n        (match_test \"known_eq (wi::to_poly_wide (op, mode),\n \t\t\t      BYTES_PER_SVE_VECTOR)\")))\n+\n+(define_predicate \"aarch64_memtag_tag_offset\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 15)\")))\n+\n+(define_predicate \"aarch64_granule16_uimm6\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op), 0, 1008)\n+\t\t    && !(INTVAL (op) & 0xf)\")))\n+\n+(define_predicate \"aarch64_granule16_simm9\"\n+  (and (match_code \"const_int\")\n+       (match_test \"IN_RANGE (INTVAL (op),  -4096, 4080)\n+\t\t    && !(INTVAL (op) & 0xf)\")))"}, {"sha": "df39522f2ad63a52c910b1a6bcc7aa13aaf5d021", "filename": "gcc/config/arm/types.md", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Farm%2Ftypes.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fconfig%2Farm%2Ftypes.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Ftypes.md?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -1096,7 +1096,8 @@\n   crypto_sm3,\\\n   crypto_sm4,\\\n   coproc,\\\n-  tme\"\n+  tme,\\\n+  memtag\"\n    (const_string \"untyped\"))\n \n ; Is this an (integer side) multiply with a 32-bit (or smaller) result?"}, {"sha": "2117e5e1ac45e40bb8dc5f1fd35bb99c5331165a", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -16280,9 +16280,8 @@ Enable the Armv8.5-a Random Number instructions.  This option is only to\n enable the extension at the assembler level and does not affect code\n generation.\n @item memtag\n-Enable the Armv8.5-a Memory Tagging Extensions.  This option is only to\n-enable the extension at the assembler level and does not affect code\n-generation.\n+Enable the Armv8.5-a Memory Tagging Extensions.\n+Use of this option with architectures prior to Armv8.5-A is not supported.\n @item sb\n Enable the Armv8-a Speculation Barrier instruction.  This option is only to\n enable the extension at the assembler level and does not affect code"}, {"sha": "6cd444c6afa3a75c2e953c57e8ae32cc62d9dc40", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -1,3 +1,9 @@\n+2019-11-19  Dennis Zhang  <dennis.zhang@arm.com>\n+\n+\t* gcc.target/aarch64/acle/memtag_1.c: New test.\n+\t* gcc.target/aarch64/acle/memtag_2.c: New test.\n+\t* gcc.target/aarch64/acle/memtag_3.c: New test.\n+\n 2019-11-19  Richard Henderson  <richard.henderson@linaro.org>\n \n \t* testsuite/gcc.target/arm/asm-flag-3.c: Skip for thumb1."}, {"sha": "f83686900326909cbcba6649483cf2a6e5f4df1d", "filename": "gcc/testsuite/gcc.target/aarch64/acle/memtag_1.c", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_1.c?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -0,0 +1,62 @@\n+/* Test the MEMTAG ACLE intrinsic.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -march=armv8.5-a+memtag\" } */\n+\n+#include \"arm_acle.h\"\n+\n+/* irg */\n+\n+void *\n+test_memtag_1 (void *p)\n+{\n+  return __arm_mte_create_random_tag (p, 0);\n+}\n+\n+/* gmi */\n+\n+uint64_t\n+test_memtag_2 (void *p)\n+{\n+  return __arm_mte_exclude_tag (p, 0);\n+}\n+\n+/* addg */\n+\n+void *\n+test_memtag_3 (void *p)\n+{\n+  return __arm_mte_increment_tag (p, 1);\n+}\n+\n+/* subp */\n+\n+int64_t\n+test_memtag_4 (void *p, void *q)\n+{\n+  return __arm_mte_ptrdiff (p, q);\n+}\n+\n+/* ldg */\n+\n+void *\n+test_memtag_5 (void *p)\n+{\n+  return __arm_mte_get_tag (p);\n+}\n+\n+/* stg */\n+\n+void\n+test_memtag_6 (void *p)\n+{\n+  __arm_mte_set_tag (p);\n+}\n+\n+/* { dg-final { scan-assembler-times {irg\\tx..?, x..?, x..?\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {gmi\\tx..?, x..?, x..?\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {subp\\tx..?, x..?, x..?\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {addg\\tx..?, x..?, #0, #1\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {ldg\\tx..?, \\[x..?, #0\\]\\n} 1 } } */\n+/* { dg-final { scan-assembler-times {stg\\tx..?, \\[x..?, #0\\]\\n} 1 } } */\n\\ No newline at end of file"}, {"sha": "fcab05b7abeea84675f9bf9c3191b88e6bd2f2d3", "filename": "gcc/testsuite/gcc.target/aarch64/acle/memtag_2.c", "status": "added", "additions": 70, "deletions": 0, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_2.c?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -0,0 +1,70 @@\n+/* Test the MEMTAG intrinsic qualifier warnings and argument errors.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -march=armv8.5-a+memtag\" } */\n+\n+#include \"arm_acle.h\"\n+\n+void\n+test_memtag_warning_return_qualifier (void)\n+{\n+  const char *c;\n+  volatile char *v;\n+  char *n;\n+  int *i;\n+  int64_t d;\n+\n+  v = __arm_mte_get_tag(c);\t\t  /* { dg-warning {assignment} } */\n+  n = __arm_mte_get_tag(c);\t\t  /* { dg-warning {assignment} } */\n+  i = __arm_mte_get_tag(c);\t\t  /* { dg-warning {assignment} } */\n+  c = __arm_mte_get_tag(v);\t\t  /* { dg-warning {assignment} } */\n+  n = __arm_mte_get_tag(v);\t\t  /* { dg-warning {assignment} } */\n+\n+  i = __arm_mte_create_random_tag (c, 0); /* { dg-warning {assignment} } */\n+  i = __arm_mte_increment_tag (c, 0);\t  /* { dg-warning {assignment} } */\n+\n+  c = __arm_mte_get_tag(n);\t\t  /* No warning.  */\n+  d = __arm_mte_ptrdiff(c, i);\t\t  /* No warning.  */\n+}\n+\n+void\n+test_memtag_warning_argument (void)\n+{\n+  const char *c;\n+  uint64_t i;\n+  __arm_mte_exclude_tag(i, 0);\t\t/* { dg-warning {argument} } */\n+  __arm_mte_create_random_tag (i, 0);\t/* { dg-warning {argument} } */\n+  __arm_mte_set_tag(i);\t\t\t/* { dg-warning {argument} } */\n+  __arm_mte_get_tag(i);\t\t\t/* { dg-warning {argument} } */\n+  __arm_mte_increment_tag (i, 15);\t/* { dg-warning {argument} } */\n+  __arm_mte_ptrdiff(c, i);\t\t/* { dg-warning {argument} } */\n+  __arm_mte_ptrdiff(i, c);\t\t/* { dg-warning {argument} } */\n+\n+  __arm_mte_exclude_tag(1, 0);\t\t/* { dg-warning {argument} } */\n+  __arm_mte_create_random_tag (1, 0);\t/* { dg-warning {argument} } */\n+  __arm_mte_set_tag(1);\t\t\t/* { dg-warning {argument} } */\n+  __arm_mte_get_tag(1);\t\t\t/* { dg-warning {argument} } */\n+  __arm_mte_increment_tag (1, 15);\t/* { dg-warning {argument} } */\n+  __arm_mte_ptrdiff(c, 1);\t\t/* { dg-warning {argument} } */\n+  __arm_mte_ptrdiff(1, c);\t\t/* { dg-warning {argument} } */\n+\n+  __arm_mte_exclude_tag(0, 0);\t\t/* No warning.  */\n+  __arm_mte_create_random_tag (0, 0);\t/* No warning.  */\n+  __arm_mte_set_tag(0);\t\t\t/* No warning.  */\n+  __arm_mte_get_tag(0);\t\t\t/* No warning.  */\n+  __arm_mte_increment_tag (0, 15);\t/* No warning.  */\n+  __arm_mte_ptrdiff(c, 0);\t\t/* No warning.  */\n+  __arm_mte_ptrdiff(0, c);\t\t/* No warning.  */\n+}\n+\n+void\n+test_memtag_error_argument (void)\n+{\n+  /* Produce errors properly for invalid arguments.  */\n+  __arm_mte_exclude_tag(no_decl, 0);\t/* { dg-error {} } */\n+  __arm_mte_exclude_tag();\t\t/* { dg-error {} } */\n+  __arm_mte_ptrdiff(no_decl2, 0);\t/* { dg-error {} } */\n+  __arm_mte_ptrdiff(0);\t\t\t/* { dg-error {} } */\n+  __arm_mte_ptrdiff();\t\t\t/* { dg-error {} } */\n+}\n\\ No newline at end of file"}, {"sha": "109314e55958eccd23af5d0044ba6f5276467a7a", "filename": "gcc/testsuite/gcc.target/aarch64/acle/memtag_3.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Faarch64%2Facle%2Fmemtag_3.c?ref=ef01e6bbeb7e7e3fb33ca501764a1dc6a04d5210", "patch": "@@ -0,0 +1,16 @@\n+/* Test the MEMTAG intrinsic expanding errors.  */\n+\n+/* { dg-do compile } */\n+/* { dg-require-effective-target lp64 } */\n+/* { dg-options \"-O3 -march=armv8.5-a+memtag\" } */\n+\n+#include \"arm_acle.h\"\n+\n+void\n+test_memtag_error_expand (int i)\n+{\n+  const char *p;\n+  p = __arm_mte_increment_tag (p, -1);\t/* { dg-error {in range \\[0,15\\]} } */\n+  p = __arm_mte_increment_tag (p, 16);\t/* { dg-error {in range \\[0,15\\]} } */\n+  p = __arm_mte_increment_tag (p, i);\t/* { dg-error {constant immediate} } */\n+}\n\\ No newline at end of file"}]}