{"sha": "33579b59aaf02eb726c62d0e63e51af2d94610f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzM1NzliNTlhYWYwMmViNzI2YzYyZDBlNjNlNTFhZjJkOTQ2MTBmNA==", "commit": {"author": {"name": "Jeff Law", "email": "law@redhat.com", "date": "2019-04-25T14:32:16Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2019-04-25T14:32:16Z"}, "message": "re PR tree-optimization/90037 (-Wnull-dereference false positive after r269302)\n\n\tPR tree-optimization/90037\n\t* Makefile.in (OBJS): Remove tree-ssa-phionlycprop.c\n\t* passes.def: Replace all instance of phi-only cprop with the\n\tlattice propagator.  Move propagation pass from after erroneous\n\tpath isolation to before erroneous path isolation.\n\t* tree-ssa-phionlycprop.c: Remove.\n\n\t* gcc.dg/tree-ssa/20030710-1.c: Update dump file to scan.\n\t* gcc.dg/isolate-2.c: Likewise.\n\t* gcc.dg/isolate-4.c: Likewise.\n\t* gcc.dg/pr19431.c: Accept either ordering of PHI args.\n\t* gcc.dg/pr90037.c: New test.\n\nFrom-SVN: r270574", "tree": {"sha": "ebb2e235a5cec9ff41fc7e79a6c37d6fb50dc8e9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ebb2e235a5cec9ff41fc7e79a6c37d6fb50dc8e9"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/33579b59aaf02eb726c62d0e63e51af2d94610f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33579b59aaf02eb726c62d0e63e51af2d94610f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/33579b59aaf02eb726c62d0e63e51af2d94610f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/33579b59aaf02eb726c62d0e63e51af2d94610f4/comments", "author": null, "committer": null, "parents": [{"sha": "b16f214775619dd850e724a0630792da38ba3e40", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b16f214775619dd850e724a0630792da38ba3e40", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b16f214775619dd850e724a0630792da38ba3e40"}], "stats": {"total": 809, "additions": 199, "deletions": 610}, "files": [{"sha": "f99a15cf8ca86542dab576257fd54a7fb6311473", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1,3 +1,12 @@\n+2019-04-24  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/90037\n+\t* Makefile.in (OBJS): Remove tree-ssa-phionlycprop.c\n+\t* passes.def: Replace all instance of phi-only cprop with the\n+\tlattice propagator.  Move propagation pass from after erroneous\n+\tpath isolation to before erroneous path isolation.\n+\t* tree-ssa-phionlycprop.c: Remove.\n+\n 2019-04-24  Richard Biener  <rguenther@suse.de>\n \n \tPR middle-end/90213"}, {"sha": "5f43d9de00ecf0c6f828cbe91e82284e82c6009c", "filename": "gcc/Makefile.in", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1559,7 +1559,6 @@ OBJS = \\\n \ttree-ssa-loop.o \\\n \ttree-ssa-math-opts.o \\\n \ttree-ssa-operands.o \\\n-\ttree-ssa-phionlycprop.o \\\n \ttree-ssa-phiopt.o \\\n \ttree-ssa-phiprop.o \\\n \ttree-ssa-pre.o \\"}, {"sha": "bc147c4444db8e79ded11ca5f2230becfa86d630", "filename": "gcc/passes.def", "status": "modified", "additions": 9, "deletions": 18, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Fpasses.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Fpasses.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpasses.def?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -222,19 +222,13 @@ along with GCC; see the file COPYING3.  If not see\n \t trying to move or duplicate pass_dominator somewhere earlier.  */\n       NEXT_PASS (pass_thread_jumps);\n       NEXT_PASS (pass_dominator, true /* may_peel_loop_headers_p */);\n-      /* At this point the majority of const/copy propagations\n-\t are exposed.  Go ahead and identify paths that should never\n-\t be executed in a conforming program and isolate those paths.\n-\n-\t This will expose more degenerate PHIs in the main path and\n-\t expose more PRE/DOM optimization opportunities.  */\n+      /* Threading can leave many const/copy propagations in the IL.\n+\t Clean them up.  Failure to do so well can lead to false\n+\t positives from warnings for erroneous code.  */\n+      NEXT_PASS (pass_copy_prop);\n+      /* Identify paths that should never be executed in a conforming\n+\t program and isolate those paths.  */\n       NEXT_PASS (pass_isolate_erroneous_paths);\n-      /* The only const/copy propagation opportunities left after\n-\t DOM and erroneous path isolation should be due to degenerate PHI nodes.\n-\t So rather than run the full propagators, run a specialized pass which\n-\t only examines PHIs to discover const/copy propagation\n-\t opportunities.  */\n-      NEXT_PASS (pass_phi_only_cprop);\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_reassoc, true /* insert_powi_p */);\n       NEXT_PASS (pass_dce);\n@@ -321,13 +315,10 @@ along with GCC; see the file COPYING3.  If not see\n       NEXT_PASS (pass_strlen);\n       NEXT_PASS (pass_thread_jumps);\n       NEXT_PASS (pass_vrp, false /* warn_array_bounds_p */);\n-      /* The only const/copy propagation opportunities left after\n-\t DOM and VRP should be due to degenerate PHI nodes.  So rather than\n-\t run the full propagators, run a specialized pass which\n-\t only examines PHIs to discover const/copy propagation\n-\t opportunities.  */\n       NEXT_PASS (pass_warn_restrict);\n-      NEXT_PASS (pass_phi_only_cprop);\n+      /* Threading can leave many const/copy propagations in the IL.\n+\t Clean them up.  */\n+      NEXT_PASS (pass_copy_prop);\n       NEXT_PASS (pass_dse);\n       NEXT_PASS (pass_cd_dce);\n       NEXT_PASS (pass_forwprop);"}, {"sha": "eeef8b26afef8807dca9210e1dfd83b252b06ee5", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1,3 +1,12 @@\n+2019-04-24  Jeff Law  <law@redhat.com>\n+\n+\tPR tree-optimization/90037\n+\t* gcc.dg/tree-ssa/20030710-1.c: Update dump file to scan.\n+\t* gcc.dg/isolate-2.c: Likewise.\n+\t* gcc.dg/isolate-4.c: Likewise.\n+\t* gcc.dg/pr19431.c: Accept either ordering of PHI args.\n+\t* gcc.dg/pr90037.c: New test.\n+\n 2019-04-25  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR c++/44648"}, {"sha": "70f9ad2f83c3df498e89ef59085057ddaf4ccc33", "filename": "gcc/testsuite/gcc.dg/pr90037.c", "status": "added", "additions": 161, "deletions": 0, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr90037.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Fpr90037.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr90037.c?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -0,0 +1,161 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -Wnull-dereference\" } */\n+\n+typedef __SIZE_TYPE__ size_t;\n+typedef unsigned long int uintmax_t;\n+\n+struct group\n+{\n+  char *gr_name;\n+  char *gr_passwd;\n+  unsigned gr_gid;\n+  char **gr_mem;\n+};\n+\n+struct passwd\n+{\n+  char *pw_name;\n+  char *pw_passwd;\n+\n+  unsigned pw_uid;\n+  unsigned pw_gid;\n+  char *pw_gecos;\n+  char *pw_dir;\n+  char *pw_shell;\n+};\n+\n+extern struct group *getgrnam (const char *);\n+extern struct group *getgrgid (unsigned);\n+extern void endgrent (void);\n+extern struct passwd *getpwnam (const char *);\n+extern void endpwent (void);\n+extern unsigned long int strtoul (const char *__restrict,\n+\t\t\t\t  char **__restrict, int);\n+\n+char const *\n+parse_with_separator (char const *spec, char const *separator,\n+                      unsigned *uid, unsigned *gid,\n+                      char **username, char **groupname)\n+{\n+  static const char *E_invalid_user = \"invalid user\";\n+  static const char *E_invalid_group = \"invalid group\";\n+  static const char *E_bad_spec = \"invalid spec\";\n+  const char *error_msg;\n+  struct passwd *pwd;\n+  struct group *grp;\n+  char *u;\n+  char const *g;\n+  char *gname = 0;\n+  unsigned unum = *uid;\n+  unsigned gnum = gid ? *gid : (unsigned)-1;\n+\n+  error_msg = 0;\n+\n+  if (username)\n+    *username = 0;\n+\n+  if (groupname)\n+    *groupname = 0;\n+\n+  u = 0;\n+  if (separator == 0)\n+    {\n+      if (*spec)\n+        u = __builtin_strdup (spec);\n+    }\n+  else\n+    {\n+      size_t ulen = separator - spec;\n+      if (ulen != 0)\n+        {\n+          u = __builtin_malloc (ulen + 1);\n+          __builtin_memcpy (u, spec, ulen + 1);\n+          u[ulen] = '\\0';\n+        }\n+    }\n+\n+  g = (separator == 0 || *(separator + 1) == '\\0' ? 0 : separator + 1);\n+\n+  if (u != 0)\n+    {\n+      pwd = (*u == '+' ? 0 : getpwnam (u));\n+      if (pwd == 0)\n+        {\n+\t  _Bool use_login_group = (separator != 0 && g == 0);\n+          if (use_login_group)\n+            {\n+              error_msg = E_bad_spec;\n+            }\n+          else\n+            {\n+              unsigned long int tmp;\n+              tmp = strtoul (u, 0, 10);\n+              if (tmp <= (1ul << 31) && (unsigned) tmp != (unsigned) -1)\n+                unum = tmp;\n+              else\n+                error_msg = E_invalid_user;\n+            }\n+        }\n+      else\n+        {\n+          unum = pwd->pw_uid;\n+          if (g == 0 && separator != 0)\n+            {\n+              char buf[128];\n+              gnum = pwd->pw_gid;\n+              grp = getgrgid (gnum);\n+\n+              gname = buf;\n+\n+              if (grp)\n+\t\tgname = __builtin_strdup (grp->gr_name);\n+              else\n+\t\t__builtin_snprintf (buf, sizeof(buf), \"%ju\", (uintmax_t)gnum);\n+\n+              endgrent ();\n+            }\n+        }\n+\n+      endpwent ();\n+    }\n+\n+  if (g != 0 && error_msg == 0)\n+    {\n+      grp = (*g == '+' ? 0 : getgrnam (g));\n+      if (grp == 0)\n+        {\n+\t  unsigned long int tmp = strtoul (g, 0, 10);\n+\t\t\n+\t  if (tmp <= (1ul << 31) && (unsigned) tmp != (unsigned) -1)\n+            gnum = tmp;\n+          else\n+            error_msg = E_invalid_group;\n+        }\n+      else\n+        gnum = grp->gr_gid;\n+      endgrent ();\n+      gname = __builtin_strdup (g);\n+    }\n+\n+  if (error_msg == 0)\n+    {\n+      *uid = unum;\n+      if (gid)\n+        *gid = gnum;\n+      if (username)\n+        {\n+          *username = u;\n+          u = 0;\n+        }\n+      if (groupname)\n+        {\n+          *groupname = gname;\n+          gname = 0;\n+        }\n+    }\n+\n+  __builtin_free (u);\n+  __builtin_free (gname);\n+  return error_msg ? error_msg : 0;\n+}\n+"}, {"sha": "529c79b26e3f908c54567d831cd66464452bc27f", "filename": "gcc/testsuite/gcc.dg/tree-ssa/20030710-1.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030710-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030710-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2F20030710-1.c?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O1 -fdump-tree-phicprop1\" } */\n+/* { dg-options \"-O1 -fdump-tree-copyprop2\" } */\n \n extern void abort (void);\n extern void blah (void);\n@@ -42,14 +42,14 @@ record_component_aliases (type)\n /* The call to blah should have been eliminated.  If the call is not\n    eliminated, then dominator optimizations failed and it'll be\n    impossible to delete other unnecessary code.  */\n-/* { dg-final { scan-tree-dump-not \"blah \\\\(\\\\)\" \"phicprop1\" } } */\n+/* { dg-final { scan-tree-dump-not \"blah \\\\(\\\\)\" \"copyprop2\" } } */\n   \n /* There should be two IF conditionals.  */\n-/* { dg-final { scan-tree-dump-times \"if \" 2 \"phicprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"if \" 2 \"copyprop2\"} } */\n                                                                                 \n /* There should be a single load of type.binfo.  */\n-/* { dg-final { scan-tree-dump-times \"type\\\\.binfo\" 1 \"phicprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"type\\\\.binfo\" 1 \"copyprop2\"} } */\n \n /* There should be two loads of vec.length.  */\n-/* { dg-final { scan-tree-dump-times \"vec.length\" 2 \"phicprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"vec.length\" 2 \"copyprop2\"} } */\n "}, {"sha": "f5cd23ab24201f04070a58386d0dae3214cd4193", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-2.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-2.c?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdelete-null-pointer-checks -fisolate-erroneous-paths-attribute -fdump-tree-isolate-paths -fdump-tree-phicprop1\" } */\n+/* { dg-options \"-O2 -fdelete-null-pointer-checks -fisolate-erroneous-paths-attribute -fdump-tree-isolate-paths -fdump-tree-forwprop3\" } */\n /* { dg-skip-if \"\" keeps_null_pointer_checks } */\n \n \n@@ -34,9 +34,9 @@ bar (void)\n    a return statement.  We test this twice, once where the NULL flows\n    from a PHI, the second with an explicit return 0 in the IL.\n \n-   We also verify that after isolation phi-cprop simplifies the\n+   We also verify that after isolation cprop simplifies the\n    return statement so that it returns &z directly. */\n /* { dg-final { scan-tree-dump-times \"__builtin_trap\" 2 \"isolate-paths\"} } */\n-/* { dg-final { scan-tree-dump-times \"return &z;\" 1 \"phicprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"return &z;\" 1 \"forwprop3\"} } */\n \n "}, {"sha": "f357e16d3d7cc3d4f1892ea3d70c537b6ffcac52", "filename": "gcc/testsuite/gcc.dg/tree-ssa/isolate-4.c", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fisolate-4.c?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */ \n-/* { dg-options \"-O2 -fdelete-null-pointer-checks -fisolate-erroneous-paths-attribute -fdump-tree-isolate-paths -fdump-tree-phicprop1\" } */\n+/* { dg-options \"-O2 -fdelete-null-pointer-checks -fisolate-erroneous-paths-attribute -fdump-tree-isolate-paths -fdump-tree-ccp3\" } */\n /* { dg-skip-if \"\" keeps_null_pointer_checks } */\n \n \n@@ -26,6 +26,6 @@ bar (void)\n    We also verify that after isolation phi-cprop simplifies the\n    return statement so that it returns &z directly. */\n /* { dg-final { scan-tree-dump-times \"__builtin_trap\" 2 \"isolate-paths\"} } */\n-/* { dg-final { scan-tree-dump-times \"foo .&z.;\" 1 \"phicprop1\"} } */\n+/* { dg-final { scan-tree-dump-times \"foo .&z.;\" 1 \"ccp3\"} } */\n \n "}, {"sha": "a1f46c7aec51ed3e5be5d6920ab97d0bbdbc99e6", "filename": "gcc/testsuite/gcc.dg/tree-ssa/pr19431.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/33579b59aaf02eb726c62d0e63e51af2d94610f4/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fpr19431.c?ref=33579b59aaf02eb726c62d0e63e51af2d94610f4", "patch": "@@ -24,4 +24,4 @@ int f(int k, int i1, int j1)\n   return *f1;\n }\n \n-/* { dg-final { scan-tree-dump \"\\[^\\r\\n\\]*_. = PHI <i1_\\[^,\\]*, j1_\\[^>\\]*>\" \"optimized\" } } */\n+/* { dg-final { scan-tree-dump \"\\[^\\r\\n\\]*_. = PHI <\\[ij\\]1_\\[^,\\]*, \\[ij\\]1_\\[^>\\]*>\" \"optimized\" } } */"}, {"sha": "f367800da415a174169ccaa867d574624da3ddfd", "filename": "gcc/tree-ssa-phionlycprop.c", "status": "removed", "additions": 0, "deletions": 580, "changes": 580, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/b16f214775619dd850e724a0630792da38ba3e40/gcc%2Ftree-ssa-phionlycprop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/b16f214775619dd850e724a0630792da38ba3e40/gcc%2Ftree-ssa-phionlycprop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-phionlycprop.c?ref=b16f214775619dd850e724a0630792da38ba3e40", "patch": "@@ -1,580 +0,0 @@\n-/* Const/Copy propagation originating from degenerate PHIs\n-   Copyright (C) 2001-2019 Free Software Foundation, Inc.\n-\n-This file is part of GCC.\n-\n-GCC is free software; you can redistribute it and/or modify\n-it under the terms of the GNU General Public License as published by\n-the Free Software Foundation; either version 3, or (at your option)\n-any later version.\n-\n-GCC is distributed in the hope that it will be useful,\n-but WITHOUT ANY WARRANTY; without even the implied warranty of\n-MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n-GNU General Public License for more details.\n-\n-You should have received a copy of the GNU General Public License\n-along with GCC; see the file COPYING3.  If not see\n-<http://www.gnu.org/licenses/>.  */\n-\n-#include \"config.h\"\n-#include \"system.h\"\n-#include \"coretypes.h\"\n-#include \"backend.h\"\n-#include \"cfghooks.h\"\n-#include \"tree.h\"\n-#include \"gimple.h\"\n-#include \"ssa.h\"\n-#include \"fold-const.h\"\n-#include \"cfgloop.h\"\n-#include \"gimple-pretty-print.h\"\n-#include \"gimple-fold.h\"\n-#include \"tree-eh.h\"\n-#include \"gimple-iterator.h\"\n-#include \"tree-cfg.h\"\n-#include \"tree-pass.h\"\n-#include \"tree-ssa-propagate.h\"\n-\n-\n-/* PHI-ONLY copy and constant propagation.  This pass is meant to clean\n-   up degenerate PHIs created by or exposed by jump threading.  */\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   remove it from the IL.  */\n-\n-static void\n-remove_stmt_or_phi (gimple *stmt)\n-{\n-  gimple_stmt_iterator gsi = gsi_for_stmt (stmt);\n-\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    remove_phi_node (&gsi, true);\n-  else\n-    {\n-      gsi_remove (&gsi, true);\n-      release_defs (stmt);\n-    }\n-}\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   return the \"rhs\" of the node, in the case of a non-degenerate\n-   phi, NULL is returned.  */\n-\n-static tree\n-get_rhs_or_phi_arg (gimple *stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    return degenerate_phi_result (as_a <gphi *> (stmt));\n-  else if (gimple_assign_single_p (stmt))\n-    return gimple_assign_rhs1 (stmt);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-\n-/* Given a statement STMT, which is either a PHI node or an assignment,\n-   return the \"lhs\" of the node.  */\n-\n-static tree\n-get_lhs_or_phi_result (gimple *stmt)\n-{\n-  if (gimple_code (stmt) == GIMPLE_PHI)\n-    return gimple_phi_result (stmt);\n-  else if (is_gimple_assign (stmt))\n-    return gimple_assign_lhs (stmt);\n-  else\n-    gcc_unreachable ();\n-}\n-\n-/* Propagate RHS into all uses of LHS (when possible).\n-\n-   RHS and LHS are derived from STMT, which is passed in solely so\n-   that we can remove it if propagation is successful.\n-\n-   When propagating into a PHI node or into a statement which turns\n-   into a trivial copy or constant initialization, set the\n-   appropriate bit in INTERESTING_NAMEs so that we will visit those\n-   nodes as well in an effort to pick up secondary optimization\n-   opportunities. \n-\n-   NEED_EH_CLEANUP tracks blocks that need their EH information\n-   cleaned up after changing EH information on a statement.  */\n-\n-static bool\n-propagate_rhs_into_lhs (gimple *stmt, tree lhs, tree rhs,\n-\t\t\tbitmap interesting_names, bitmap need_eh_cleanup)\n-{\n-  bool cfg_altered = false;\n-\n-  /* First verify that propagation is valid.  */\n-  if (may_propagate_copy (lhs, rhs))\n-    {\n-      use_operand_p use_p;\n-      imm_use_iterator iter;\n-      gimple *use_stmt;\n-      bool all = true;\n-\n-      /* Dump details.  */\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t{\n-\t  fprintf (dump_file, \"  Replacing '\");\n-\t  print_generic_expr (dump_file, lhs, dump_flags);\n-\t  fprintf (dump_file, \"' with %s '\",\n-\t           (TREE_CODE (rhs) != SSA_NAME ? \"constant\" : \"variable\"));\n-\t\t   print_generic_expr (dump_file, rhs, dump_flags);\n-\t  fprintf (dump_file, \"'\\n\");\n-\t}\n-\n-      /* Walk over every use of LHS and try to replace the use with RHS.\n-\t At this point the only reason why such a propagation would not\n-\t be successful would be if the use occurs in an ASM_EXPR.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\t{\n-\t  /* Leave debug stmts alone.  If we succeed in propagating\n-\t     all non-debug uses, we'll drop the DEF, and propagation\n-\t     into debug stmts will occur then.  */\n-\t  if (gimple_debug_bind_p (use_stmt))\n-\t    continue;\n-\n-\t  /* It's not always safe to propagate into an ASM_EXPR.  */\n-\t  if (gimple_code (use_stmt) == GIMPLE_ASM\n-              && ! may_propagate_copy_into_asm (lhs))\n-\t    {\n-\t      all = false;\n-\t      continue;\n-\t    }\n-\n-\t  /* It's not ok to propagate into the definition stmt of RHS.\n-\t\t<bb 9>:\n-\t\t  # prephitmp.12_36 = PHI <g_67.1_6(9)>\n-\t\t  g_67.1_6 = prephitmp.12_36;\n-\t\t  goto <bb 9>;\n-\t     While this is strictly all dead code we do not want to\n-\t     deal with this here.  */\n-\t  if (TREE_CODE (rhs) == SSA_NAME\n-\t      && SSA_NAME_DEF_STMT (rhs) == use_stmt)\n-\t    {\n-\t      all = false;\n-\t      continue;\n-\t    }\n-\n-\t  /* Dump details.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"    Original statement:\");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t    }\n-\n-\t  /* Propagate the RHS into this use of the LHS.  */\n-\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t    propagate_value (use_p, rhs);\n-\n-\t  /* Special cases to avoid useless calls into the folding\n-\t     routines, operand scanning, etc.\n-\n-\t     Propagation into a PHI may cause the PHI to become\n-\t     a degenerate, so mark the PHI as interesting.  No other\n-\t     actions are necessary.  */\n-\t  if (gimple_code (use_stmt) == GIMPLE_PHI)\n-\t    {\n-\t      tree result;\n-\n-\t      /* Dump details.  */\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\t{\n-\t\t  fprintf (dump_file, \"    Updated statement:\");\n-\t\t  print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t\t}\n-\n-\t      result = get_lhs_or_phi_result (use_stmt);\n-\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n-\t      continue;\n-\t    }\n-\n-\t  /* From this point onward we are propagating into a\n-\t     real statement.  Folding may (or may not) be possible,\n-\t     we may expose new operands, expose dead EH edges,\n-\t     etc.  */\n-          /* NOTE tuples. In the tuples world, fold_stmt_inplace\n-             cannot fold a call that simplifies to a constant,\n-             because the GIMPLE_CALL must be replaced by a\n-             GIMPLE_ASSIGN, and there is no way to effect such a\n-             transformation in-place.  We might want to consider\n-             using the more general fold_stmt here.  */\n-\t    {\n-\t      gimple_stmt_iterator gsi = gsi_for_stmt (use_stmt);\n-\t      fold_stmt_inplace (&gsi);\n-\t    }\n-\n-\t  /* Sometimes propagation can expose new operands to the\n-\t     renamer.  */\n-\t  update_stmt (use_stmt);\n-\n-\t  /* Dump details.  */\n-\t  if (dump_file && (dump_flags & TDF_DETAILS))\n-\t    {\n-\t      fprintf (dump_file, \"    Updated statement:\");\n-\t      print_gimple_stmt (dump_file, use_stmt, 0, dump_flags);\n-\t    }\n-\n-\t  /* If we replaced a variable index with a constant, then\n-\t     we would need to update the invariant flag for ADDR_EXPRs.  */\n-          if (gimple_assign_single_p (use_stmt)\n-              && TREE_CODE (gimple_assign_rhs1 (use_stmt)) == ADDR_EXPR)\n-\t    recompute_tree_invariant_for_addr_expr\n-                (gimple_assign_rhs1 (use_stmt));\n-\n-\t  /* If we cleaned up EH information from the statement,\n-\t     mark its containing block as needing EH cleanups.  */\n-\t  if (maybe_clean_or_replace_eh_stmt (use_stmt, use_stmt))\n-\t    {\n-\t      bitmap_set_bit (need_eh_cleanup, gimple_bb (use_stmt)->index);\n-\t      if (dump_file && (dump_flags & TDF_DETAILS))\n-\t\tfprintf (dump_file, \"  Flagged to clear EH edges.\\n\");\n-\t    }\n-\n-\t  /* Propagation may expose new trivial copy/constant propagation\n-\t     opportunities.  */\n-          if (gimple_assign_single_p (use_stmt)\n-              && TREE_CODE (gimple_assign_lhs (use_stmt)) == SSA_NAME\n-              && (TREE_CODE (gimple_assign_rhs1 (use_stmt)) == SSA_NAME\n-                  || is_gimple_min_invariant (gimple_assign_rhs1 (use_stmt))))\n-            {\n-\t      tree result = get_lhs_or_phi_result (use_stmt);\n-\t      bitmap_set_bit (interesting_names, SSA_NAME_VERSION (result));\n-\t    }\n-\n-\t  /* Propagation into these nodes may make certain edges in\n-\t     the CFG unexecutable.  We want to identify them as PHI nodes\n-\t     at the destination of those unexecutable edges may become\n-\t     degenerates.  */\n-\t  else if (gimple_code (use_stmt) == GIMPLE_COND\n-\t\t   || gimple_code (use_stmt) == GIMPLE_SWITCH\n-\t\t   || gimple_code (use_stmt) == GIMPLE_GOTO)\n-            {\n-\t      tree val;\n-\n-\t      if (gimple_code (use_stmt) == GIMPLE_COND)\n-                val = fold_binary_loc (gimple_location (use_stmt),\n-\t\t\t\t   gimple_cond_code (use_stmt),\n-                                   boolean_type_node,\n-                                   gimple_cond_lhs (use_stmt),\n-                                   gimple_cond_rhs (use_stmt));\n-              else if (gimple_code (use_stmt) == GIMPLE_SWITCH)\n-\t\tval = gimple_switch_index (as_a <gswitch *> (use_stmt));\n-\t      else\n-\t\tval = gimple_goto_dest  (use_stmt);\n-\n-\t      if (val && is_gimple_min_invariant (val))\n-\t\t{\n-\t\t  basic_block bb = gimple_bb (use_stmt);\n-\t\t  edge te = find_taken_edge (bb, val);\n-\t\t  if (!te)\n-\t\t    continue;\n-\n-\t\t  edge_iterator ei;\n-\t\t  edge e;\n-\t\t  gimple_stmt_iterator gsi;\n-\t\t  gphi_iterator psi;\n-\n-\t\t  /* Remove all outgoing edges except TE.  */\n-\t\t  for (ei = ei_start (bb->succs); (e = ei_safe_edge (ei));)\n-\t\t    {\n-\t\t      if (e != te)\n-\t\t\t{\n-\t\t\t  /* Mark all the PHI nodes at the destination of\n-\t\t\t     the unexecutable edge as interesting.  */\n-                          for (psi = gsi_start_phis (e->dest);\n-                               !gsi_end_p (psi);\n-                               gsi_next (&psi))\n-                            {\n-                              gphi *phi = psi.phi ();\n-\n-\t\t\t      tree result = gimple_phi_result (phi);\n-\t\t\t      int version = SSA_NAME_VERSION (result);\n-\n-\t\t\t      bitmap_set_bit (interesting_names, version);\n-\t\t\t    }\n-\n-\t\t\t  te->probability += e->probability;\n-\n-\t\t\t  remove_edge (e);\n-\t\t\t  cfg_altered = true;\n-\t\t\t}\n-\t\t      else\n-\t\t\tei_next (&ei);\n-\t\t    }\n-\n-\t\t  gsi = gsi_last_bb (gimple_bb (use_stmt));\n-\t\t  gsi_remove (&gsi, true);\n-\n-\t\t  /* And fixup the flags on the single remaining edge.  */\n-\t\t  te->flags &= ~(EDGE_TRUE_VALUE | EDGE_FALSE_VALUE);\n-\t\t  te->flags &= ~EDGE_ABNORMAL;\n-\t\t  te->flags |= EDGE_FALLTHRU;\n-\t        }\n-\t    }\n-\t}\n-\n-      /* Ensure there is nothing else to do. */\n-      gcc_assert (!all || has_zero_uses (lhs));\n-\n-      /* If we were able to propagate away all uses of LHS, then\n-\t we can remove STMT.  */\n-      if (all)\n-\tremove_stmt_or_phi (stmt);\n-    }\n-  return cfg_altered;\n-}\n-\n-/* STMT is either a PHI node (potentially a degenerate PHI node) or\n-   a statement that is a trivial copy or constant initialization.\n-\n-   Attempt to eliminate STMT by propagating its RHS into all uses of\n-   its LHS.  This may in turn set new bits in INTERESTING_NAMES\n-   for nodes we want to revisit later.\n-\n-   All exit paths should clear INTERESTING_NAMES for the result\n-   of STMT.\n-\n-   NEED_EH_CLEANUP tracks blocks that need their EH information\n-   cleaned up after changing EH information on a statement.  It is\n-   not set or queried here, but passed along to children.  */\n-\n-static bool\n-eliminate_const_or_copy (gimple *stmt, bitmap interesting_names,\n-\t\t\t bitmap need_eh_cleanup)\n-{\n-  tree lhs = get_lhs_or_phi_result (stmt);\n-  tree rhs;\n-  int version = SSA_NAME_VERSION (lhs);\n-  bool cfg_altered = false;\n-\n-  /* If the LHS of this statement or PHI has no uses, then we can\n-     just eliminate it.  This can occur if, for example, the PHI\n-     was created by block duplication due to threading and its only\n-     use was in the conditional at the end of the block which was\n-     deleted.  */\n-  if (has_zero_uses (lhs))\n-    {\n-      bitmap_clear_bit (interesting_names, version);\n-      remove_stmt_or_phi (stmt);\n-      return cfg_altered;\n-    }\n-\n-  /* Get the RHS of the assignment or PHI node if the PHI is a\n-     degenerate.  */\n-  rhs = get_rhs_or_phi_arg (stmt);\n-  if (!rhs)\n-    {\n-      bitmap_clear_bit (interesting_names, version);\n-      return cfg_altered;\n-    }\n-\n-  if (!virtual_operand_p (lhs))\n-    cfg_altered = propagate_rhs_into_lhs (stmt, lhs, rhs,\n-\t\t\t\t\t  interesting_names, need_eh_cleanup);\n-  else\n-    {\n-      gimple *use_stmt;\n-      imm_use_iterator iter;\n-      use_operand_p use_p;\n-      /* For virtual operands we have to propagate into all uses as\n-         otherwise we will create overlapping life-ranges.  */\n-      FOR_EACH_IMM_USE_STMT (use_stmt, iter, lhs)\n-\tFOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t  SET_USE (use_p, rhs);\n-      if (SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n-\tSSA_NAME_OCCURS_IN_ABNORMAL_PHI (rhs) = 1;\n-      remove_stmt_or_phi (stmt);\n-    }\n-\n-  /* Note that STMT may well have been deleted by now, so do\n-     not access it, instead use the saved version # to clear\n-     T's entry in the worklist.  */\n-  bitmap_clear_bit (interesting_names, version);\n-  return cfg_altered;\n-}\n-\n-/* The first phase in degenerate PHI elimination.\n-\n-   Eliminate the degenerate PHIs in BB, then recurse on the\n-   dominator children of BB. \n-\n-   INTERESTING_NAMES tracks SSA_NAMEs that we may want to revisit\n-   in the future.  It is not set or queried here, but passed along\n-   to children. \n-\n-   NEED_EH_CLEANUP tracks blocks that need their EH information\n-   cleaned up after changing EH information on a statement.  It is\n-   not set or queried here, but passed along to children.  */\n-\n-static bool\n-eliminate_degenerate_phis_1 (basic_block bb, bitmap interesting_names,\n-\t\t\t     bitmap need_eh_cleanup)\n-{\n-  gphi_iterator gsi;\n-  basic_block son;\n-  bool cfg_altered = false;\n-\n-  for (gsi = gsi_start_phis (bb); !gsi_end_p (gsi);)\n-    {\n-      gphi *phi = gsi.phi ();\n-      /* We might end up removing PHI so advance the iterator now.  */\n-      gsi_next (&gsi);\n-      cfg_altered |= eliminate_const_or_copy (phi, interesting_names,\n-\t\t\t\t\t      need_eh_cleanup);\n-    }\n-\n-  /* Recurse into the dominator children of BB.  */\n-  for (son = first_dom_son (CDI_DOMINATORS, bb);\n-       son;\n-       son = next_dom_son (CDI_DOMINATORS, son))\n-    cfg_altered |= eliminate_degenerate_phis_1 (son, interesting_names,\n-\t\t\t\t\t\tneed_eh_cleanup);\n-\n-  return cfg_altered;\n-}\n-\n-\n-/* A very simple pass to eliminate degenerate PHI nodes from the\n-   IL.  This is meant to be fast enough to be able to be run several\n-   times in the optimization pipeline.\n-\n-   Certain optimizations, particularly those which duplicate blocks\n-   or remove edges from the CFG can create or expose PHIs which are\n-   trivial copies or constant initializations.\n-\n-   While we could pick up these optimizations in DOM or with the\n-   combination of copy-prop and CCP, those solutions are far too\n-   heavy-weight for our needs.\n-\n-   This implementation has two phases so that we can efficiently\n-   eliminate the first order degenerate PHIs and second order\n-   degenerate PHIs.\n-\n-   The first phase performs a dominator walk to identify and eliminate\n-   the vast majority of the degenerate PHIs.  When a degenerate PHI\n-   is identified and eliminated any affected statements or PHIs\n-   are put on a worklist.\n-\n-   The second phase eliminates degenerate PHIs and trivial copies\n-   or constant initializations using the worklist.  This is how we\n-   pick up the secondary optimization opportunities with minimal\n-   cost.  */\n-\n-namespace {\n-\n-const pass_data pass_data_phi_only_cprop =\n-{\n-  GIMPLE_PASS, /* type */\n-  \"phicprop\", /* name */\n-  OPTGROUP_NONE, /* optinfo_flags */\n-  TV_TREE_PHI_CPROP, /* tv_id */\n-  ( PROP_cfg | PROP_ssa ), /* properties_required */\n-  0, /* properties_provided */\n-  0, /* properties_destroyed */\n-  0, /* todo_flags_start */\n-  ( TODO_cleanup_cfg | TODO_update_ssa ), /* todo_flags_finish */\n-};\n-\n-class pass_phi_only_cprop : public gimple_opt_pass\n-{\n-public:\n-  pass_phi_only_cprop (gcc::context *ctxt)\n-    : gimple_opt_pass (pass_data_phi_only_cprop, ctxt)\n-  {}\n-\n-  /* opt_pass methods: */\n-  opt_pass * clone () { return new pass_phi_only_cprop (m_ctxt); }\n-  virtual bool gate (function *) { return flag_tree_dom != 0; }\n-  virtual unsigned int execute (function *);\n-\n-}; // class pass_phi_only_cprop\n-\n-unsigned int\n-pass_phi_only_cprop::execute (function *fun)\n-{\n-  bool cfg_altered = false;\n-\n-  /* Bitmap of blocks which need EH information updated.  We cannot\n-     update it on-the-fly as doing so invalidates the dominator tree.  */\n-  auto_bitmap need_eh_cleanup;\n-\n-  /* INTERESTING_NAMES is effectively our worklist, indexed by\n-     SSA_NAME_VERSION.\n-\n-     A set bit indicates that the statement or PHI node which\n-     defines the SSA_NAME should be (re)examined to determine if\n-     it has become a degenerate PHI or trivial const/copy propagation\n-     opportunity.\n-\n-     Experiments have show we generally get better compilation\n-     time behavior with bitmaps rather than sbitmaps.  */\n-  auto_bitmap interesting_names;\n-  auto_bitmap interesting_names1;\n-\n-  calculate_dominance_info (CDI_DOMINATORS);\n-  cfg_altered = false;\n-\n-  /* First phase.  Eliminate degenerate PHIs via a dominator\n-     walk of the CFG.\n-\n-     Experiments have indicated that we generally get better\n-     compile-time behavior by visiting blocks in the first\n-     phase in dominator order.  Presumably this is because walking\n-     in dominator order leaves fewer PHIs for later examination\n-     by the worklist phase.  */\n-  cfg_altered = eliminate_degenerate_phis_1 (ENTRY_BLOCK_PTR_FOR_FN (fun),\n-\t\t\t\t\t     interesting_names,\n-\t\t\t\t\t     need_eh_cleanup);\n-\n-  /* Second phase.  Eliminate second order degenerate PHIs as well\n-     as trivial copies or constant initializations identified by\n-     the first phase or this phase.  Basically we keep iterating\n-     until our set of INTERESTING_NAMEs is empty.   */\n-  while (!bitmap_empty_p (interesting_names))\n-    {\n-      unsigned int i;\n-      bitmap_iterator bi;\n-\n-      /* EXECUTE_IF_SET_IN_BITMAP does not like its bitmap\n-\t changed during the loop.  Copy it to another bitmap and\n-\t use that.  */\n-      bitmap_copy (interesting_names1, interesting_names);\n-\n-      EXECUTE_IF_SET_IN_BITMAP (interesting_names1, 0, i, bi)\n-\t{\n-\t  tree name = ssa_name (i);\n-\n-\t  /* Ignore SSA_NAMEs that have been released because\n-\t     their defining statement was deleted (unreachable).  */\n-\t  if (name)\n-\t    cfg_altered\n-\t      |= eliminate_const_or_copy (SSA_NAME_DEF_STMT (ssa_name (i)),\n-\t\t\t\t\t  interesting_names, need_eh_cleanup);\n-\t}\n-    }\n-\n-  if (cfg_altered)\n-    {\n-      free_dominance_info (CDI_DOMINATORS);\n-      /* If we changed the CFG schedule loops for fixup by cfgcleanup.  */\n-      loops_state_set (LOOPS_NEED_FIXUP);\n-    }\n-\n-  /* Propagation of const and copies may make some EH edges dead.  Purge\n-     such edges from the CFG as needed.  */\n-  if (!bitmap_empty_p (need_eh_cleanup))\n-    gimple_purge_all_dead_eh_edges (need_eh_cleanup);\n-\n-  return 0;\n-}\n-\n-} // anon namespace\n-\n-gimple_opt_pass *\n-make_pass_phi_only_cprop (gcc::context *ctxt)\n-{\n-  return new pass_phi_only_cprop (ctxt);\n-}"}]}