{"sha": "0b85d8165e0d39b555274fc776589d2abccfcf55", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGI4NWQ4MTY1ZTBkMzliNTU1Mjc0ZmM3NzY1ODlkMmFiY2NmY2Y1NQ==", "commit": {"author": {"name": "Hans-Peter Nilsson", "email": "hp@axis.com", "date": "2001-10-11T17:02:36Z"}, "committer": {"name": "Hans-Peter Nilsson", "email": "hp@gcc.gnu.org", "date": "2001-10-11T17:02:36Z"}, "message": "config.gcc: Add cris-*-aout, cris-*-elf, cris-*-none, cris-*-linux* cases.\n\n\t* config.gcc: Add cris-*-aout, cris-*-elf, cris-*-none,\n\tcris-*-linux* cases.\n\t* config/cris/cris-protos.h: New file.\n\t* config/cris/cris.c: New file.\n\t* config/cris/cris.h: New file.\n\t* config/cris/cris.md: New file.\n\t* config/cris/linux.h: New file.\n\t* config/cris/aout.h: New file.\n\t* config/cris/arit.c: New file.\n\t* config/cris/cris_abi_symbol.c: New file.\n\t* config/cris/mulsi3.asm: New file.\n\t* config/cris/t-aout: New file.\n\t* config/cris/t-cris: New file.\n\t* config/cris/t-elfmulti: New file.\n\t* config/cris/t-linux: New file.\n\t* doc/invoke.texi: Add CRIS options.\n\t* doc/install.texi (Specific): Add blurb for CRIS.\n\nFrom-SVN: r46191", "tree": {"sha": "1694ad7ed26e247e6ad86ecf3226ec444f6d51f2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/1694ad7ed26e247e6ad86ecf3226ec444f6d51f2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0b85d8165e0d39b555274fc776589d2abccfcf55", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b85d8165e0d39b555274fc776589d2abccfcf55", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b85d8165e0d39b555274fc776589d2abccfcf55", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b85d8165e0d39b555274fc776589d2abccfcf55/comments", "author": {"login": "hpataxisdotcom", "id": 80339731, "node_id": "MDQ6VXNlcjgwMzM5NzMx", "avatar_url": "https://avatars.githubusercontent.com/u/80339731?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hpataxisdotcom", "html_url": "https://github.com/hpataxisdotcom", "followers_url": "https://api.github.com/users/hpataxisdotcom/followers", "following_url": "https://api.github.com/users/hpataxisdotcom/following{/other_user}", "gists_url": "https://api.github.com/users/hpataxisdotcom/gists{/gist_id}", "starred_url": "https://api.github.com/users/hpataxisdotcom/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hpataxisdotcom/subscriptions", "organizations_url": "https://api.github.com/users/hpataxisdotcom/orgs", "repos_url": "https://api.github.com/users/hpataxisdotcom/repos", "events_url": "https://api.github.com/users/hpataxisdotcom/events{/privacy}", "received_events_url": "https://api.github.com/users/hpataxisdotcom/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "1567080ca309043cd694aa3a7593b6021c7ee045", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1567080ca309043cd694aa3a7593b6021c7ee045", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1567080ca309043cd694aa3a7593b6021c7ee045"}], "stats": {"total": 11596, "additions": 11596, "deletions": 0}, "files": [{"sha": "607e9790d812bff9e44f4b9a5326c3141ac187f9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -1,3 +1,23 @@\n+2001-10-11  Hans-Peter Nilsson  <hp@axis.com>\n+\n+\t* config.gcc: Add cris-*-aout, cris-*-elf, cris-*-none,\n+\tcris-*-linux* cases.\n+\t* config/cris/cris-protos.h: New file.\n+\t* config/cris/cris.c: New file.\n+\t* config/cris/cris.h: New file.\n+\t* config/cris/cris.md: New file.\n+\t* config/cris/linux.h: New file.\n+\t* config/cris/aout.h: New file.\n+\t* config/cris/arit.c: New file.\n+\t* config/cris/cris_abi_symbol.c: New file.\n+\t* config/cris/mulsi3.asm: New file.\n+\t* config/cris/t-aout: New file.\n+\t* config/cris/t-cris: New file.\n+\t* config/cris/t-elfmulti: New file.\n+\t* config/cris/t-linux: New file.\n+\t* doc/invoke.texi: Add CRIS options.\n+\t* doc/install.texi (Specific): Add blurb for CRIS.\n+\n 2001-10-10  Hartmut Schirmer <SchirmerH@Innovative-Systems.de>\n \n \t* config/float-i128.h: Make sure __STDC__VERSION__ is defined"}, {"sha": "f6085953e2b11787667450d439fe5dc5372a2e8e", "filename": "gcc/config.gcc", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig.gcc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig.gcc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig.gcc?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -657,6 +657,27 @@ clipper-intergraph-clix*)\n \textra_parts=\"crtbegin.o crtend.o\"\n \tinstall_headers_dir=install-headers-cpio\n \t;;\n+cris-*-aout)\n+\ttm_file=\"dbxelf.h cris/cris.h cris/aout.h\"\n+\tgas=yes\n+\ttmake_file=\"cris/t-cris cris/t-aout\"\n+\t;;\n+cris-*-elf | cris-*-none)\n+\ttm_file=\"elfos.h cris/cris.h\"\n+\ttmake_file=\"cris/t-cris cris/t-elfmulti\"\n+\tgas=yes\n+\t;;\n+cris-*-linux*)\n+\ttm_file=\"linux.h cris/cris.h cris/linux.h\"\n+\ttmake_file=\"cris/t-cris t-slibgcc-elf-ver cris/t-linux\"\n+\textra_parts=\"crtbegin.o crtbeginS.o crtend.o crtendS.o\"\n+\tcase x${enable_threads} in\n+\tx | xyes | xpthreads | xposix)\n+\t\tthread_file=posix\n+\t\t;;\n+\tesac\n+\tgas=yes\n+\t;;\n d30v-*)\n \tfloat_format=i64\n \t;;"}, {"sha": "dc998f1b0fe84e14077b6264d4f1a790292c94b4", "filename": "gcc/config/cris/aout.h", "status": "added", "additions": 422, "deletions": 0, "changes": 422, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Faout.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Faout.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Faout.h?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,422 @@\n+/* Definitions for GCC.  Part of the machine description for CRIS.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Axis Communications.  Written by Hans-Peter Nilsson.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* After the first \"Node:\" comment comes all preprocessor directives and\n+   attached declarations described in the info files, the \"Using and\n+   Porting GCC\" manual (uapgcc), in the same order as found in the \"Target\n+   macros\" section in the gcc-2.9x CVS edition of 2000-03-17.  FIXME: Not\n+   really, but needs an update anyway.\n+\n+   There is no generic copy-of-uapgcc comment, you'll have to see uapgcc\n+   for that.  If applicable, there is a CRIS-specific comment.  The order\n+   of macro definitions follow the order in the manual.  Every section in\n+   the manual (node in the info pages) has an introductory `Node:\n+   <subchapter>' comment.  If no macros are defined for a section, only\n+   the section-comment is present.  */\n+\n+/* This file defines the macros for a.out that are not covered by cris.h.\n+   Many macros are copied from elfos.h and should be in some generic\n+   config/gas-aout.h.  */\n+\n+/* Node: Driver */\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+ \"%{melinux:crt0.o%s}\\\n+  %{!melinux:\\\n+   %{sim2:s2crt0.o%s}\\\n+   %{!sim2:\\\n+    %{sim:scrt0.o%s}\\\n+    %{!sim:%{pg:gcrt0.o%s}\\\n+     %{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}}\"\n+\n+/* Which library to get.  The only difference from the default is to get\n+   libsc.a if -sim is given to the driver.  Repeat -lc -lsysX\n+   {X=sim,linux}, because libsysX needs (at least) errno from libc, and\n+   then we want to resolve new unknowns in libc against libsysX, not\n+   libnosys.  Assume everything is in libc for -mlinux.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+ \"%{melinux:-lc -lsyslinux -lc -lsyslinux -lic}\\\n+  %{!melinux:\\\n+   %{sim*:-lc -lsyssim -lc -lsyssim}\\\n+   %{!sim*:%{g*:-lg}\\\n+     %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} -lbsp}\\\n+   -lnosys}\"\n+\n+#undef CRIS_CPP_SUBTARGET_SPEC\n+#define CRIS_CPP_SUBTARGET_SPEC \\\n+ \"-D__AOUT__\\\n+  %{melinux:-D__linux__ -D__unix__ -D__elinux__ -D__uclinux__\\\n+    %{!nostdinc:\\\n+      %{!mbest-lib-options:%{isystem*}}\\\n+      -isystem elinux/include%s\\\n+      %{mbest-lib-options:%{isystem*}}}\\\n+    %{!ansi:%{!std=*:%{!undef:-Dlinux -Dunix -Delinux -Duclinux}}}}\\\n+  %{mbest-lib-options:\\\n+   %{!moverride-best-lib-options:\\\n+    %{!march=*:%{!metrax*:%{!mcpu=*:-D__tune_v8 -D__CRIS_arch_tune=8}}}}}\"\n+\n+#undef CRIS_CC1_SUBTARGET_SPEC\n+#define CRIS_CC1_SUBTARGET_SPEC \\\n+ \"%{mbest-lib-options:\\\n+   %{!moverride-best-lib-options:\\\n+    %{!march=*:%{!mcpu=*:-mtune=v8}}}}\"\n+\n+#undef CRIS_ASM_SUBTARGET_SPEC\n+#define CRIS_ASM_SUBTARGET_SPEC \"--em=crisaout\"\n+\n+#undef CRIS_LINK_SUBTARGET_SPEC\n+#define CRIS_LINK_SUBTARGET_SPEC \\\n+ \"-mcrisaout\\\n+  %{sim2:%{!T*:-Tdata 0x4000000 -Tbss 0x8000000}}\\\n+  %{melinux:-Ur -d\\\n+   %{!shlib:%{!symbolic:-Bstatic}}\\\n+   %{shlib:-Bdynamic}\\\n+   %{symbolic:-Bdynamic}\\\n+   %{static:-Bstatic}}\\\n+  %{melinux-stacksize=*:-defsym __Stacksize=%*}\"\n+\n+#undef CRIS_SUBTARGET_SWITCHES\n+#define CRIS_SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+  {\"elinux\", (TARGET_MASK_SVINTO\t\t\t\t\t\\\n+\t      + TARGET_MASK_STACK_ALIGN\t\t\t\t\t\\\n+\t      + TARGET_MASK_CONST_ALIGN\t\t\t\t\t\\\n+\t      + TARGET_MASK_DATA_ALIGN\t\t\t\t\t\\\n+\t      + TARGET_MASK_ETRAX4_ADD\t\t\t\t\t\\\n+\t      + TARGET_MASK_ALIGN_BY_32),\t\t\t\t\\\n+   N_(\"Compile for the MMU-less Etrax 100-based elinux system\")},\t\\\n+  /* Legacy option.  */\t\t\t\t\t\t\t\\\n+  {\"aout\",   0,\t\"\"},\n+\n+#undef CRIS_SUBTARGET_LONG_OPTIONS\n+#define CRIS_SUBTARGET_LONG_OPTIONS \\\n+  {\"elinux-stacksize=\", &cris_elinux_stacksize_str,\t\t\t\\\n+   N_(\"For elinux, request a specified stack-size for this program\")},\t\\\n+\n+#undef CRIS_SUBTARGET_VERSION\n+#define CRIS_SUBTARGET_VERSION \" - a.out\"\n+\n+#undef CRIS_SUBTARGET_DEFAULT\n+#define CRIS_SUBTARGET_DEFAULT 0\n+\n+/* Node: Storage Layout */\n+\n+/* We can align to 16 bits (only) with CRIS a.out.  */\n+#define MAX_OFILE_ALIGNMENT 16\n+\n+\n+/* Node: Library Calls */\n+\n+#define TARGET_MEM_FUNCTIONS\n+\n+\n+/* Node: Data Output */\n+\n+#define ESCAPES \\\n+\"\\1\\1\\1\\1\\1\\1\\1\\1btn\\1fr\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\0\\0\\\"\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\\\\\0\\0\\0\\\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\\n+\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\\1\"\n+\n+/* Some svr4 assemblers have a limit on the number of characters which\n+   can appear in the operand of a .string directive.  If your assembler\n+   has such a limitation, you should define STRING_LIMIT to reflect that\n+   limit.  Note that at least some svr4 assemblers have a limit on the\n+   actual number of bytes in the double-quoted string, and that they\n+   count each character in an escape sequence as one byte.  Thus, an\n+   escape sequence like \\377 would count as four bytes.\n+\n+   If your target assembler doesn't support the .string directive, you\n+   should define this to zero.  */\n+\n+#define STRING_LIMIT\t((unsigned) 256)\n+\n+#define STRING_ASM_OP\t\"\\t.string\\t\"\n+#define ASCII_DATA_ASM_OP\t\"\\t.ascii\\t\"\n+#define TYPE_ASM_OP\t\"\\t.type\\t\"\n+#define SIZE_ASM_OP\t\"\\t.size\\t\"\n+#define TYPE_OPERAND_FMT\t\"@%s\"\n+\n+/* The routine used to output NUL terminated strings.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable, especially for targets like the i386\n+   (where the only alternative is to output character sequences as\n+   comma separated lists of numbers).  */\n+\n+#define ASM_OUTPUT_LIMITED_STRING(FILE, STR)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      register const unsigned char *_limited_str =\t\\\n+\t(const unsigned char *) (STR);\t\t\t\\\n+      register unsigned ch;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"%s\\\"\", STRING_ASM_OP);\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      for (; (ch = *_limited_str); _limited_str++)\t\\\n+        {\t\t\t\t\t\t\\\n+\t  register int escape;\t\t\t\t\\\n+\t  \t\t\t\t\t\t\\\n+\t  switch (escape = ESCAPES[ch])\t\t\t\\\n+\t    {\t\t\t\t\t\t\\\n+\t    case 0:\t\t\t\t\t\\\n+\t      putc (ch, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    case 1:\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\\%03o\", ch);\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    default:\t\t\t\t\t\\\n+\t      putc ('\\\\', (FILE));\t\t\t\\\n+\t      putc (escape, (FILE));\t\t\t\\\n+\t      break;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\\\n+        }\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* The routine used to output sequences of byte values.  We use a special\n+   version of this for most svr4 targets because doing so makes the\n+   generated assembly code more compact (and thus faster to assemble)\n+   as well as more readable.  Note that if we find subparts of the\n+   character sequence which end with NUL (and which are shorter than\n+   STRING_LIMIT) we output those using ASM_OUTPUT_LIMITED_STRING.  */\n+\n+#undef  ASM_OUTPUT_ASCII\n+#define ASM_OUTPUT_ASCII(FILE, STR, LENGTH)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      register const unsigned char *_ascii_bytes =\t\t\t\\\n+\t(const unsigned char *) (STR);\t\t\t\t\t\\\n+      register const unsigned char *limit = _ascii_bytes + (LENGTH);\t\\\n+      register unsigned bytes_in_chunk = 0;\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      for (; _ascii_bytes < limit; _ascii_bytes++)\t\t\t\\\n+        {\t\t\t\t\t\t\t\t\\\n+\t  register const unsigned char *p;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t  if (bytes_in_chunk >= 60)\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+\t      bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t  for (p = _ascii_bytes; p < limit && *p != '\\0'; p++)\t\t\\\n+\t    continue;\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t  if (p < limit && (p - _ascii_bytes) <= (long)STRING_LIMIT)\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk > 0)\t\t\t\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\\\n+\t\t  bytes_in_chunk = 0;\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t      ASM_OUTPUT_LIMITED_STRING ((FILE), _ascii_bytes);\t\t\\\n+\t      _ascii_bytes = p;\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  else\t\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      register int escape;\t\t\t\t\t\\\n+\t      register unsigned ch;\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t      if (bytes_in_chunk == 0)\t\t\t\t\t\\\n+\t\tfprintf ((FILE), \"%s\\\"\", ASCII_DATA_ASM_OP);\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+\t      switch (escape = ESCAPES[ch = *_ascii_bytes])\t\t\\\n+\t\t{\t\t\t\t\t\t\t\\\n+\t\tcase 0:\t\t\t\t\t\t\t\\\n+\t\t  putc (ch, (FILE));\t\t\t\t\t\\\n+\t\t  bytes_in_chunk++;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tcase 1:\t\t\t\t\t\t\t\\\n+\t\t  fprintf ((FILE), \"\\\\%03o\", ch);\t\t\t\\\n+\t\t  bytes_in_chunk += 4;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\tdefault:\t\t\t\t\t\t\\\n+\t\t  putc ('\\\\', (FILE));\t\t\t\t\t\\\n+\t\t  putc (escape, (FILE));\t\t\t\t\\\n+\t\t  bytes_in_chunk += 2;\t\t\t\t\t\\\n+\t\t  break;\t\t\t\t\t\t\\\n+\t\t}\t\t\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\t\\\n+      if (bytes_in_chunk > 0)\t\t\t\t\t\t\\\n+        fprintf ((FILE), \"\\\"\\n\");\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Label Output */\n+\n+#define SET_ASM_OP\t\"\\t.set\\t\"\n+\n+#define ASM_OUTPUT_EXTERNAL_LIBCALL(FILE, FUN)\t\\\n+  ASM_GLOBALIZE_LABEL (FILE, XSTR (FUN, 0))\n+\n+#define ASM_WEAKEN_LABEL(FILE, NAME) \t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      fputs (\"\\t.weak\\t\", (FILE));\t\\\n+      assemble_name ((FILE), (NAME)); \t\\\n+      fputc ('\\n', (FILE));\t\t\\\n+    }\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\", TYPE_ASM_OP);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"function\");\t\\\n+      putc ('\\n', FILE);\t\t\t\t\\\n+      \t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL(FILE, NAME);\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_DECLARE_OBJECT_NAME(FILE, NAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      fprintf (FILE, \"%s\", TYPE_ASM_OP);\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\t\t\\\n+      putc (',', FILE);\t\t\t\t\t\t\\\n+      fprintf (FILE, TYPE_OPERAND_FMT, \"object\");\t\t\\\n+      putc ('\\n', FILE);\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      size_directive_output = 0;\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive\t\t\t\t\\\n+\t  && (DECL) && DECL_SIZE (DECL))\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, NAME);\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n+\t\t   int_size_in_bytes (TREE_TYPE (DECL)));\t\\\n+\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      ASM_OUTPUT_LABEL (FILE, NAME);\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_FINISH_DECLARE_OBJECT(FILE, DECL, TOP_LEVEL, AT_END)\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      const char *name = XSTR (XEXP (DECL_RTL (DECL), 0), 0);\t\\\n+      \t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive\t\t\t\t\\\n+\t  && DECL_SIZE (DECL)\t\t\t\t\t\\\n+\t  && ! AT_END && TOP_LEVEL\t\t\t\t\\\n+\t  && DECL_INITIAL (DECL) == error_mark_node\t\t\\\n+\t  && !size_directive_output)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  size_directive_output = 1;\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, name);\t\t\t\t\\\n+\t  putc (',', FILE);\t\t\t\t\t\\\n+\t  fprintf (FILE, HOST_WIDE_INT_PRINT_DEC,\t\t\\\n+\t\t   int_size_in_bytes (TREE_TYPE (DECL))); \t\\\n+\t  fputc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_DECLARE_FUNCTION_SIZE(FILE, FNAME, DECL)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (!flag_inhibit_size_directive)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  char label[256];\t\t\t\t\t\\\n+\t  static int labelno;\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  labelno++;\t\t\t\t\t\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  ASM_GENERATE_INTERNAL_LABEL (label, \"Lfe\", labelno);\t\\\n+\t  ASM_OUTPUT_INTERNAL_LABEL (FILE, \"Lfe\", labelno);\t\\\n+\t  \t\t\t\t\t\t\t\\\n+\t  fprintf (FILE, \"%s\", SIZE_ASM_OP);\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  fprintf (FILE, \",\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, label);\t\t\t\t\\\n+\t  fprintf (FILE, \"-\");\t\t\t\t\t\\\n+\t  assemble_name (FILE, (FNAME));\t\t\t\\\n+\t  putc ('\\n', FILE);\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Alignment Output */\n+\n+#define SKIP_ASM_OP\t\"\\t.zero\\t\"\n+\n+#undef  ASM_OUTPUT_SKIP\n+#define ASM_OUTPUT_SKIP(FILE, SIZE) \\\n+  fprintf (FILE, \"%s%u\\n\", SKIP_ASM_OP, (SIZE))\n+\n+/* Node: All Debuggers */\n+\n+#define PREFERRED_DEBUGGING_TYPE DBX_DEBUG\n+\n+\n+/* Node: Misc */\n+\n+#define HANDLE_SYSV_PRAGMA\n+\n+/* In theory, this one isn't necessary, but over time, external tools have\n+   been primed on names with \".\" rather than \"$\".  */\n+#define NO_DOLLAR_IN_LABEL\n+\n+/* These are undocumented, but to keep a single\n+   CRIS_ASM_OUTPUT_ALIGNED_DECL_COMMON, we set this to an asm that will\n+   emit an error if ever output.  It will not be emitted for a.out modulo\n+   careless hacking.  */\n+#define COMMON_ASM_OP\t\"\\t.err\\t\"\n+#define LOCAL_ASM_OP\t\"\\t.err\\t\"\n+\n+#if defined(__CRIS__) && defined (__AOUT__) && defined (IN_GCC)\n+\n+#define CRIS_ABI_VERSION_SYMBOL_STRING \".$CRIS_ABI_V2\"\n+\n+/* Make all a.out library functions have undefined references to the\n+   .$CRIS_ABI_V2 symbol, so it will be picked up.  Used by GDB.  GDB has\n+   a bug with reading a.out symbols; it does not see the GNU weak\n+   extensions, so we can't have .$CRIS_ABI_V2 weak.  Weak.  */\n+__asm__ (\".set .$abi_referer,\" CRIS_ABI_VERSION_SYMBOL_STRING);\n+#endif\n+\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "91f4e0560e92ca219dfcbdc3e61a74cb0109cd47", "filename": "gcc/config/cris/arit.c", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Farit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Farit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Farit.c?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,302 @@\n+/* Signed and unsigned multiplication and division and modulus for CRIS.\n+   Contributed by Axis Communications.\n+   Written by Hans-Peter Nilsson <hp@axis.se>, c:a 1992.\n+\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files, some of\n+   which are compiled with GCC, this library does not by itself cause\n+   the resulting object or executable to be covered by the GNU General\n+   Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file or object might be covered by the GNU General\n+   Public License.  */\n+\n+\n+/* Note that we provide prototypes for all \"const\" functions, to attach\n+   the const attribute.  This is necessary in 2.7.2 - adding the\n+   attribute to the function *definition* is a syntax error.\n+    This did not work with e.g. 2.1; back then, the return type had to\n+   be \"const\".  */\n+\n+#include \"config.h\"\n+\n+#if defined (__CRIS_arch_version) && __CRIS_arch_version >= 3\n+#define LZ(v) __extension__ \\\n+ ({ int tmp_; __asm__ (\"lz %1,%0\" : \"=r\" (tmp_) : \"r\" (v)); tmp_; })\n+#endif\n+\n+\n+#if defined (L_udivsi3) || defined (L_divsi3) || defined (L_umodsi3) \\\n+    || defined (L_modsi3)\n+/* Result type of divmod worker function.  */\n+struct quot_rem\n+ {\n+   long quot;\n+   long rem;\n+ };\n+\n+/* This is the worker function for div and mod.  It is inlined into the\n+   respective library function.  */\n+static __inline__ struct quot_rem\n+do_31div (unsigned long a, unsigned long b) __attribute__ ((__const__));\n+\n+static __inline__ struct quot_rem\n+do_31div (unsigned long a, unsigned long b)\n+{\n+  /* Adjust operands and result if a is 31 bits.  */\n+  long extra = 0;\n+  int quot_digits = 0;\n+\n+  if (b == 0)\n+    {\n+      struct quot_rem ret;\n+      ret.quot = 0xffffffff;\n+      ret.rem = 0xffffffff;\n+      return ret;\n+    }\n+\n+  if (a < b)\n+    return (struct quot_rem) { 0, a };\n+\n+#ifdef LZ\n+  if (b <= a)\n+    {\n+      quot_digits = LZ (b) - LZ (a);\n+      quot_digits += (a >= (b << quot_digits));\n+      b <<= quot_digits;\n+    }\n+#else\n+  while (b <= a)\n+    {\n+      b <<= 1;\n+      quot_digits++;\n+    }\n+#endif\n+\n+  /* Is a 31 bits?  Note that bit 31 is handled by the caller.  */\n+  if (a & 0x40000000)\n+    {\n+      /* Then make b:s highest bit max 0x40000000, because it must have\n+\t been 0x80000000 to be 1 bit higher than a.  */\n+      b >>= 1;\n+\n+      /* Adjust a to be maximum 0x3fffffff, i.e. two upper bits zero.  */\n+      if (a >= b)\n+\t{\n+\t  a -= b;\n+\t  extra = 1 << (quot_digits - 1);\n+\t}\n+      else\n+\t{\n+\t  a -= b >> 1;\n+\n+\t  /* Remember that we adjusted a by subtracting b * 2 ** Something.  */\n+\t  extra = 1 << quot_digits;\n+\t}\n+\n+      /* The number of quotient digits will be one less, because\n+\t we just adjusted b.  */\n+      quot_digits--;\n+    }\n+\n+  /* Now do the division part.  */\n+\n+  /* Subtract b and add ones to the right when a >= b\n+     i.e. \"a - (b - 1) == (a - b) + 1\".  */\n+  b--;\n+\n+#define DS __asm__ (\"dstep %2,%0\" : \"=r\" (a) : \"0\" (a), \"r\" (b))\n+\n+  switch (quot_digits)\n+    {\n+    case 32: DS; case 31: DS; case 30: DS; case 29: DS;\n+    case 28: DS; case 27: DS; case 26: DS; case 25: DS;\n+    case 24: DS; case 23: DS; case 22: DS; case 21: DS;\n+    case 20: DS; case 19: DS; case 18: DS; case 17: DS;\n+    case 16: DS; case 15: DS; case 14: DS; case 13: DS;\n+    case 12: DS; case 11: DS; case 10: DS; case 9: DS;\n+    case 8: DS; case 7: DS; case 6: DS; case 5: DS;\n+    case 4: DS; case 3: DS; case 2: DS; case 1: DS;\n+    case 0:;\n+    }\n+\n+  {\n+    struct quot_rem ret;\n+    ret.quot = (a & ((1 << quot_digits) - 1)) + extra;\n+    ret.rem = a >> quot_digits;\n+    return ret;\n+  }\n+}\n+\n+/* Note that unsigned and signed division both build when L_divsi3, but\n+   the unsigned variant is then inlined, as with do_31div above.  */\n+#if defined (L_udivsi3) || defined (L_divsi3)\n+#ifndef L_udivsi3\n+static __inline__\n+#endif\n+unsigned long\n+__Udiv (unsigned long a, unsigned long b) __attribute__ ((__const__));\n+\n+#ifndef L_udivsi3\n+static __inline__\n+#endif\n+unsigned long\n+__Udiv (unsigned long a, unsigned long b)\n+{\n+  long extra = 0;\n+\n+  /* Adjust operands and result, if a and/or b is 32 bits.  */\n+  /* Effectively: b & 0x80000000.  */\n+  if ((long) b < 0)\n+    return a >= b;\n+\n+  /* Effectively: a & 0x80000000.  */\n+  if ((long) a < 0)\n+    {\n+      int tmp = 0;\n+\n+      if (b == 0)\n+\treturn 0xffffffff;\n+#ifdef LZ\n+      tmp = LZ (b);\n+#else\n+      for (tmp = 31; (((long) b & (1 << tmp)) == 0); tmp--)\n+\t;\n+\n+      tmp = 31 - tmp;\n+#endif\n+\n+      if ((b << tmp) > a)\n+\t{\n+\t  extra = 1 << (tmp-1);\n+\t  a -= b << (tmp - 1);\n+\t}\n+      else\n+\t{\n+\t  extra = 1 << tmp;\n+\t  a -= b << tmp;\n+\t}\n+    }\n+\n+  return do_31div (a, b).quot+extra;\n+}\n+\n+\n+#ifdef L_divsi3\n+long\n+__Div (long a, long b) __attribute__ ((__const__));\n+\n+long\n+__Div (long a, long b)\n+{\n+  long sign;\n+  long result;\n+\n+  /* Do *not* call do_31div since abs (-2147483648) == 2147483648\n+     <=> abs (-0x80000000) == 0x80000000\n+     which is still 32 bits.  */\n+\n+  sign = a ^ b;\n+  result = __Udiv (abs (a), abs (b));\n+\n+  return  (sign < 0) ? -result : result;\n+}\n+#endif /* L_divsi3 */\n+#endif /* L_udivsi3 || L_divsi3 */\n+\n+\n+/* Note that unsigned and signed modulus both build when L_modsi3, but\n+   then the unsigned variant is inlined, as with do_31div above.  */\n+#if defined (L_umodsi3) || defined (L_modsi3)\n+#ifndef L_umodsi3\n+static __inline__\n+#endif\n+unsigned long\n+__Umod (unsigned long a, unsigned long b) __attribute__ ((__const__));\n+\n+#ifndef L_umodsi3\n+static __inline__\n+#endif\n+unsigned long\n+__Umod (unsigned long a, unsigned long b)\n+{\n+  /* Adjust operands and result if a and/or b is 32 bits.  */\n+  if ((long) b < 0)\n+    return a >= b ? a - b : a;\n+\n+  if ((long) a < 0)\n+    {\n+      int tmp = 0;\n+\n+      if (b == 0)\n+\treturn a;\n+#ifdef LZ\n+      tmp = LZ (b);\n+#else\n+      for (tmp = 31; (((long) b & (1 << tmp)) == 0); tmp--)\n+\t;\n+      tmp = 31 - tmp;\n+#endif\n+\n+      if ((b << tmp) > a)\n+\t{\n+\t  a -= b << (tmp - 1);\n+\t}\n+      else\n+\t{\n+\t  a -= b << tmp;\n+\t}\n+    }\n+\n+  return do_31div (a, b).rem;\n+}\n+\n+#ifdef L_modsi3\n+long\n+__Mod (long a, long b) __attribute__ ((__const__));\n+\n+long\n+__Mod (long a, long b)\n+{\n+  long\tresult;\n+\n+  result = __Umod (abs (a), abs (b));\n+\n+  return (a < 0) ? -result : result;\n+}\n+#endif /* L_modsi3 */\n+#endif /* L_umodsi3 || L_modsi3 */\n+#endif /* L_udivsi3 || L_divsi3 || L_umodsi3 || L_modsi3 */\n+\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "e13c94fb36db5418dc4bc68e0188e59b4c4fdd86", "filename": "gcc/config/cris/cris-protos.h", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris-protos.h?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,75 @@\n+/* Definitions for GCC.  Part of the machine description for CRIS.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Axis Communications.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* Prototypes for the CRIS port.  */\n+\n+#if defined(FILE) || defined(stdin) || defined(stdout) || defined(getc) || defined(putc)\n+#define STDIO_INCLUDED\n+#endif\n+\n+extern void cris_conditional_register_usage PARAMS ((void));\n+extern int cris_simple_epilogue PARAMS ((void));\n+#ifdef RTX_CODE\n+extern const char *cris_op_str PARAMS ((rtx));\n+extern int cris_eligible_for_epilogue_delay PARAMS ((rtx));\n+extern void cris_notice_update_cc PARAMS ((rtx, rtx));\n+extern int cris_address_cost PARAMS ((rtx));\n+extern void cris_print_operand PARAMS ((FILE *, rtx, int));\n+extern void cris_print_operand_address PARAMS ((FILE *, rtx));\n+extern int cris_side_effect_mode_ok PARAMS ((enum rtx_code, rtx *, int, int,\n+                                             int, int, int));\n+extern rtx cris_return_addr_rtx PARAMS ((int, rtx));\n+extern rtx cris_split_movdx PARAMS ((rtx *));\n+extern int cris_legitimate_pic_operand PARAMS ((rtx));\n+extern int cris_gotless_symbol PARAMS ((rtx));\n+extern int cris_got_symbol PARAMS ((rtx));\n+extern int cris_symbol PARAMS ((rtx));\n+extern void cris_output_addr_const PARAMS ((FILE *, rtx));\n+extern int cris_cfun_uses_pic_table PARAMS ((void));\n+extern void cris_target_asm_named_section\n+  PARAMS ((const char *, unsigned int));\n+\n+# ifdef TREE_CODE\n+extern rtx cris_expand_builtin_va_arg PARAMS ((tree, tree));\n+extern void cris_encode_section_info PARAMS ((tree));\n+# endif\n+#endif /* RTX_CODE */\n+\n+#ifdef STDIO_INCLUDED\n+# ifdef TREE_CODE\n+extern void cris_asm_output_mi_thunk PARAMS ((FILE *, tree, int, tree));\n+# endif\n+#endif\n+\n+#ifdef GCC_C_PRAGMA_H\n+extern void cris_pragma_expand_mul PARAMS ((cpp_reader *));\n+#endif\n+\n+/* Need one that returns an int; usable in expressions. */\n+extern int cris_fatal PARAMS ((char *));\n+\n+extern void cris_override_options PARAMS ((void));\n+\n+extern int cris_initial_elimination_offset PARAMS ((int, int));\n+\n+extern void cris_init_expanders PARAMS ((void));\n+\n+extern int cris_delay_slots_for_epilogue PARAMS ((void));"}, {"sha": "b87a2ac4e834b0cacb924a5c6aca84df21eb45b6", "filename": "gcc/config/cris/cris.c", "status": "added", "additions": 3043, "deletions": 0, "changes": 3043, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.c?ref=0b85d8165e0d39b555274fc776589d2abccfcf55"}, {"sha": "ccba9ae9427e5cf358c71a5aa55cddf1dd977ad7", "filename": "gcc/config/cris/cris.h", "status": "added", "additions": 1937, "deletions": 0, "changes": 1937, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.h?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,1937 @@\n+/* Definitions for GCC.  Part of the machine description for CRIS.\n+   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation, Inc.\n+   Contributed by Axis Communications.  Written by Hans-Peter Nilsson.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+/* After the first \"Node:\" comment comes all preprocessor directives and\n+   attached declarations described in the info files, the \"Using and\n+   Porting GCC\" manual (uapgcc), in the same order as found in the \"Target\n+   macros\" section in the gcc-2.9x CVS edition of 2000-03-17.  FIXME: Not\n+   really, but needs an update anyway.\n+\n+   There is no generic copy-of-uapgcc comment, you'll have to see uapgcc\n+   for that.  If applicable, there is a CRIS-specific comment.  The order\n+   of macro definitions follow the order in the manual.  Every section in\n+   the manual (node in the info pages) has an introductory `Node:\n+   <subchapter>' comment.  If no macros are defined for a section, only\n+   the section-comment is present.  */\n+\n+/* Note that other header files (e.g. config/elfos.h, config/linux.h,\n+   config/cris/linux.h and config/cris/aout.h) are responsible for lots of\n+   settings not repeated below.  This file contains general CRIS\n+   definitions and definitions for the cris-*-elf subtarget.  */\n+\n+/* Replacement for REG_P since it does not match SUBREGs.  Happens for\n+   testcase Axis-20000320 with gcc-2.9x.  */\n+#define REG_S_P(x) \\\n+ (REG_P (x) || (GET_CODE (x) == SUBREG && REG_P (XEXP (x, 0))))\n+\n+/* Last register in main register bank r0..r15.  */\n+#define CRIS_LAST_GENERAL_REGISTER 15\n+\n+/* Descriptions of registers used for arguments.  */\n+#define CRIS_FIRST_ARG_REG 10\n+#define CRIS_MAX_ARGS_IN_REGS 4\n+\n+/* Other convenience definitions.  */\n+#define CRIS_PC_REGNUM 15\n+#define CRIS_SRP_REGNUM 16\n+\n+/* Most of the time, we need the index into the register-names array.\n+   When passing debug-info, we need the real register number.  */\n+#define CRIS_CANONICAL_SRP_REGNUM (16 + 11)\n+#define CRIS_CANONICAL_MOF_REGNUM (16 + 7)\n+\n+/* When generating PIC, these suffixes are added to the names of non-local\n+   functions when being output.  Contrary to other ports, we have offsets\n+   relative to the GOT, not the PC.  We might implement PC-relative PLT\n+   semantics later for the general case; they are used in some cases right\n+   now, such as MI thunks.  */\n+#define CRIS_GOTPLT_SUFFIX \":GOTPLT\"\n+#define CRIS_PLT_GOTOFFSET_SUFFIX \":PLTG\"\n+#define CRIS_PLT_PCOFFSET_SUFFIX \":PLT\"\n+\n+#define CRIS_FUNCTION_ARG_SIZE(MODE, TYPE)\t\\\n+  ((MODE) != BLKmode ? GET_MODE_SIZE (MODE)\t\\\n+   : (unsigned) int_size_in_bytes (TYPE))\n+\n+/* Check for max allowed stackframe. A \"const char *\" to be parsed.  */\n+extern const char *cris_max_stackframe_str;\n+\n+/* Which CPU version this is.  A \"const char *\" to be parsed.  */\n+extern const char *cris_cpu_str;\n+\n+/* Which CPU version this is.  The parsed and adjusted cris_cpu_str.  */\n+extern int cris_cpu_version;\n+\n+/* Which CPU version to tune for.  A \"const char *\" to be parsed.  */\n+extern const char *cris_tune_str;\n+\n+/* The argument to \"-melinux-stacksize=\".  We don't parse it currently;\n+   it's just passed on to the linker.  We might want to do something\n+   here someday.  */\n+extern const char *cris_elinux_stacksize_str;\n+\n+/* Changing the order used to be necessary to put the fourth __make_dp\n+   argument (a DImode parameter) in registers, to fit with the libfunc\n+   parameter passing scheme used for intrinsic functions.  FIXME: Check\n+   performance and maybe remove definition from TARGET_LIBGCC2_CFLAGS now\n+   that it isn't strictly necessary.  We used to do this through\n+   TARGET_LIBGCC2_CFLAGS, but that became increasingly difficult as the\n+   parenthesis (that needed quoting) travels through several layers of\n+   make and shell invocations.  */\n+#ifdef IN_LIBGCC2\n+#define __make_dp(a,b,c,d) __cris_make_dp(d,a,b,c)\n+#endif\n+\n+\n+/* Node: Driver */\n+\n+/* When using make with defaults.mak for Sun this will handily remove\n+   any \"-target sun*\" switches.  */\n+/* We need to override any previous definitions (linux.h) */\n+#undef WORD_SWITCH_TAKES_ARG\n+#define WORD_SWITCH_TAKES_ARG(STR)\t\t\\\n+ (DEFAULT_WORD_SWITCH_TAKES_ARG (STR)\t\t\\\n+  || !strcmp (STR, \"target\"))\n+\n+/* Also provide canonical vN definitions when user specifies an alias.\n+   Note that -melf overrides -maout.  */\n+\n+/* The `-$' is here mostly due to the integrated preprocessor not\n+   handling the builtin expansion of \"#define __REGISTER_PREFIX__ $\"\n+   gracefully.  This is slightly redundant although not incorrect.\n+   We're quite alone defining REGISTER_PREFIX as \"$\" so it's unlikely\n+   someone will fight for us.  This year in the mountains.\n+   Note that for -melinux and -mlinux, command-line -isystem options are\n+   emitted both before and after the synthesized one.  We can't remove all\n+   of them: a %{<isystem} will only remove the first one and %{<isystem*}\n+   will not do TRT.  Those extra occurences are harmless anyway.  */\n+#define CPP_SPEC \\\n+ \"-$ -D__CRIS_ABI_version=2\\\n+  %{mtune=*:-D__tune_%* %{mtune=v*:-D__CRIS_arch_tune=%*}}\\\n+   %{mtune=etrax4:-D__tune_v3 -D__CRIS_arch_tune=3}\\\n+   %{mtune=etrax100:-D__tune_v8 -D__CRIS_arch_tune=8}\\\n+   %{mtune=svinto:-D__tune_v8 -D__CRIS_arch_tune=8}\\\n+   %{mtune=etrax100lx:-D__tune_v10 -D__CRIS_arch_tune=10}\\\n+   %{mtune=ng:-D__tune_v10 -D__CRIS_arch_tune=10}\\\n+  %{mcpu=*:-D__arch_%* %{mcpu=v*:-D__CRIS_arch_version=%*}}\\\n+   %{mcpu=etrax4:-D__arch_v3 -D__CRIS_arch_version=3}\\\n+   %{mcpu=etrax100:-D__arch_v8 -D__CRIS_arch_version=8}\\\n+   %{mcpu=svinto:-D__arch_v8 -D__CRIS_arch_version=8}\\\n+   %{mcpu=etrax100lx:-D__arch_v10 -D__CRIS_arch_version=10}\\\n+   %{mcpu=ng:-D__arch_v10 -D__CRIS_arch_version=10}\\\n+  %{march=*:-D__arch_%* %{march=v*:-D__CRIS_arch_version=%*}}\\\n+   %{march=etrax4:-D__arch_v3 -D__CRIS_arch_version=3}\\\n+   %{march=etrax100:-D__arch_v8 -D__CRIS_arch_version=8}\\\n+   %{march=svinto:-D__arch_v8 -D__CRIS_arch_version=8}\\\n+   %{march=etrax100lx:-D__arch_v10 -D__CRIS_arch_version=10}\\\n+   %{march=ng:-D__arch_v10 -D__CRIS_arch_version=10}\\\n+  %{metrax100:-D__arch__v8 -D__CRIS_arch_version=8}\\\n+  %{metrax4:-D__arch__v3 -D__CRIS_arch_version=3}\\\n+  %(cpp_subtarget)\"\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_CPP_SUBTARGET_SPEC \\\n+ \"-D__ELF__\\\n+  %{mbest-lib-options:\\\n+   %{!moverride-best-lib-options:\\\n+    %{!march=*:%{!metrax*:%{!mcpu=*:-D__tune_v10 -D__CRIS_arch_tune=10}}}}}\"\n+\n+/* Remove those Sun-make \"target\" switches.  */\n+/* Override previous definitions (linux.h).  */\n+#undef CC1_SPEC\n+#define CC1_SPEC \\\n+ \"%{target*:}\\\n+  %{metrax4:-march=v3}\\\n+  %{metrax100:-march=v8}\\\n+  %(cc1_subtarget)\"\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_CC1_SUBTARGET_SPEC \\\n+ \"-melf\\\n+  %{mbest-lib-options:\\\n+   %{!moverride-best-lib-options:\\\n+    %{!march=*:%{!mcpu=*:-mtune=v10 -D__CRIS_arch_tune=10}}\\\n+    %{!finhibit-size-directive:\\\n+      %{!fno-function-sections: -ffunction-sections}\\\n+      %{!fno-data-sections: -fdata-sections}}}}\"\n+\n+/* This adds to CC1_SPEC.  When bugs are removed from -fvtable-gc\n+   (-fforce-addr causes invalid .vtable_entry asm in tinfo.cc and\n+   nothing at all works in GCC 3.0-pre), add this line:\n+   \"%{mbest-lib-options:%{!moverride-best-lib-options:\\\n+   %{!melinux:%{!maout|melf:%{!fno-vtable-gc:-fvtable-gc}}}}}\".  */\n+#define CC1PLUS_SPEC \"\"\n+\n+/* Override previous definitions (linux.h).  */\n+#undef ASM_SPEC\n+#define ASM_SPEC \\\n+ \"%{v:-v}\\\n+  %(asm_subtarget)\"\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_ASM_SUBTARGET_SPEC \"--em=criself\"\n+\n+/* FIXME: We should propagate the -melf option to make the criself\n+   \"emulation\" unless a linker script is provided (-T*), but I don't know\n+   how to do that if either of -Ttext, -Tdata or -Tbss is given but no\n+   linker script, as is usually the case.  Leave it to the user for the\n+   time being.\n+\n+   Note that -melf overrides -maout except that a.out-compiled libraries\n+   are linked in (multilibbing).  The somewhat cryptic -rpath-link pair is\n+   to avoid *only* picking up the linux multilib subdir from the \"-B./\"\n+   option during build, while still giving it preference.  We'd need some\n+   %s-variant that checked for existance of some specific file.  */\n+/* Override previous definitions (svr4.h).  */\n+#undef LINK_SPEC\n+#define LINK_SPEC \\\n+ \"%{v:--verbose}\\\n+  %(link_subtarget)\" \n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_LINK_SUBTARGET_SPEC \\\n+ \"-mcriself\\\n+  %{sim2:%{!T*:-Tdata 0x4000000 -Tbss 0x8000000}}\\\n+  %{O2|O3: --gc-sections}\"\n+\n+/* Which library to get.  The only difference from the default is to get\n+   libsc.a if -sim is given to the driver.  Repeat -lc -lsysX\n+   {X=sim,linux}, because libsysX needs (at least) errno from libc, and\n+   then we want to resolve new unknowns in libc against libsysX, not\n+   libnosys.  */\n+/* Override previous definitions (linux.h).  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \\\n+ \"%{sim*:-lc -lsyssim -lc -lsyssim}\\\n+  %{!sim*:%{g*:-lg}\\\n+    %{!p:%{!pg:-lc}}%{p:-lc_p}%{pg:-lc_p} -lbsp}\\\n+  -lnosys\"\n+\n+/* Linker startfile options; crt0 flavors.\n+\n+   At the moment there are no gcrt0.o or mcrt0.o, but keep them here and\n+   link them to crt0.o to be prepared.  Use scrt0.c if running the\n+   simulator, linear style, or s2crt0.c if fixed style.  */\n+/* We need to remove any previous definition (elfos.h).  */\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+ \"%{sim2:s2crt0.o%s}\\\n+  %{!sim2:%{sim:scrt0.o%s}\\\n+   %{!sim:%{pg:gcrt0.o%s}\\\n+    %{!pg:%{p:mcrt0.o%s}%{!p:crt0.o%s}}}}\\\n+  crtbegin.o%s\"\n+\n+#define EXTRA_SPECS\t\t\t\t\\\n+  {\"cpp_subtarget\", CRIS_CPP_SUBTARGET_SPEC},\t\\\n+  {\"cc1_subtarget\", CRIS_CC1_SUBTARGET_SPEC},\t\\\n+  {\"asm_subtarget\", CRIS_ASM_SUBTARGET_SPEC},\t\\\n+  {\"link_subtarget\", CRIS_LINK_SUBTARGET_SPEC},\t\\\n+  CRIS_SUBTARGET_EXTRA_SPECS\n+\n+#define CRIS_SUBTARGET_EXTRA_SPECS\n+\n+\n+/* Node: Run-time Target */\n+\n+/* Only keep the non-varying ones here.  */\n+#define CPP_PREDEFINES\t\"-Dcris -DCRIS -DGNU_CRIS\"\n+\n+/* This needs to be at least 32 bits.  */\n+extern int target_flags;\n+\n+/* Currently this just affects aligment.  FIXME:  Redundant with\n+   TARGET_ALIGN_BY_32, or put machine stuff here?  */\n+#define TARGET_MASK_SVINTO 1\n+#define TARGET_SVINTO (target_flags & TARGET_MASK_SVINTO)\n+\n+/* If to use condition-codes generated by insns other than the\n+   immediately preceding compare/test insn.\n+    Used to check for errors in notice_update_cc. */\n+#define TARGET_MASK_CCINIT 2\n+#define TARGET_CCINIT (target_flags & TARGET_MASK_CCINIT)\n+\n+/* Debug option.  */\n+#define TARGET_MASK_PDEBUG 4\n+#define TARGET_PDEBUG (target_flags & TARGET_MASK_PDEBUG)\n+\n+/* If to use side-effect patterns.  Used to debug the [rx=ry+i] type\n+   patterns.  */\n+#define TARGET_MASK_SIDE_EFFECT_PREFIXES 8\n+#define TARGET_SIDE_EFFECT_PREFIXES \\\n+ (target_flags & TARGET_MASK_SIDE_EFFECT_PREFIXES)\n+\n+/* If to expand mul into mstep.  Only used when making libc.a.  */\n+#define TARGET_MASK_EXPAND_MUL 16\n+#define TARGET_EXPAND_MUL (target_flags & TARGET_MASK_EXPAND_MUL)\n+\n+/* If to *keep* (not force) alignment of stack at 16 bits.  */\n+#define TARGET_MASK_STACK_ALIGN 32\n+#define TARGET_STACK_ALIGN (target_flags & TARGET_MASK_STACK_ALIGN)\n+\n+/* If to do alignment on individual non-modifiable objects.  */\n+#define TARGET_MASK_CONST_ALIGN 64\n+#define TARGET_CONST_ALIGN (target_flags & TARGET_MASK_CONST_ALIGN)\n+\n+/* If to do alignment on individual modifiable objects.  */\n+#define TARGET_MASK_DATA_ALIGN 128\n+#define TARGET_DATA_ALIGN (target_flags & TARGET_MASK_DATA_ALIGN)\n+\n+/* If not to omit funtion prologue and epilogue.  */\n+#define TARGET_MASK_PROLOGUE_EPILOGUE 256\n+#define TARGET_PROLOGUE_EPILOGUE (target_flags & TARGET_MASK_PROLOGUE_EPILOGUE)\n+\n+/* Instructions additions from Etrax 4 and up.\n+   (Just \"lz\", which we don't really generate from GCC -- yet).  */\n+#define TARGET_MASK_ETRAX4_ADD 512\n+#define TARGET_ETRAX4_ADD (target_flags & TARGET_MASK_ETRAX4_ADD)\n+\n+/* Say that all alignment specifications say to prefer 32 rather\n+   than 16 bits.  */\n+#define TARGET_MASK_ALIGN_BY_32 1024\n+#define TARGET_ALIGN_BY_32 (target_flags & TARGET_MASK_ALIGN_BY_32)\n+\n+/* This condition is of limited use, as gcc is riddled with #ifdef:s\n+   controlling this, rather than if (...):s.  */\n+#define TARGET_MASK_ELF 2048\n+#define TARGET_ELF (target_flags & TARGET_MASK_ELF)\n+\n+/* Currently just used to error-check other options.  Note that this is\n+   *not* set for -melinux.  */\n+#define TARGET_MASK_LINUX 4096\n+#define TARGET_LINUX (target_flags & TARGET_MASK_LINUX)\n+\n+/* There's a small setup cost with using GOTPLT references, but should\n+   in total be a win both in code-size and execution-time.  */\n+#define TARGET_MASK_AVOID_GOTPLT 8192\n+#define TARGET_AVOID_GOTPLT (target_flags & TARGET_MASK_AVOID_GOTPLT)\n+\n+#define TARGET_SWITCHES\t\t\t\t\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\t\\\n+  /* No \"no-etrax\" as it does not really imply any model.\t\t\\\n+     On the other hand, \"etrax\" implies the common (and large)\t\t\\\n+     subset matching all models.  */\t\t\t\t\t\\\n+  {\"etrax4\",\t\t\t\t TARGET_MASK_ETRAX4_ADD,\t\\\n+   N_(\"Compile for ETRAX 4 (CRIS v3)\")},\t\t\t\t\\\n+  {\"no-etrax4\",\t\t\t\t-TARGET_MASK_ETRAX4_ADD, \"\"},\t\\\n+  {\"etrax100\",\t\t\t     (TARGET_MASK_SVINTO\t\t\\\n+\t\t\t\t      + TARGET_MASK_ETRAX4_ADD\t\t\\\n+\t\t\t\t      + TARGET_MASK_ALIGN_BY_32),\t\\\n+   N_(\"Compile for ETRAX 100 (CRIS v8)\")},\t\t\t\t\\\n+  {\"no-etrax100\",\t\t    -(TARGET_MASK_SVINTO\t\t\\\n+\t\t\t\t      + TARGET_MASK_ETRAX4_ADD), \"\"},\t\\\n+  {\"pdebug\",\t\t\t\t     TARGET_MASK_PDEBUG,\t\\\n+   N_(\"Emit verbose debug information in assembly code\")},\t\t\\\n+  {\"no-pdebug\",\t\t\t\t    -TARGET_MASK_PDEBUG, \"\"},\t\\\n+  {\"cc-init\",\t\t\t\t     TARGET_MASK_CCINIT,\t\\\n+   N_(\"Do not use condition codes from normal instructions\")},\t\t\\\n+  {\"no-cc-init\",\t\t\t    -TARGET_MASK_CCINIT, \"\"},\t\\\n+  {\"side-effects\",\t       TARGET_MASK_SIDE_EFFECT_PREFIXES, \"\"},\t\\\n+  {\"no-side-effects\",\t      -TARGET_MASK_SIDE_EFFECT_PREFIXES,\t\\\n+   N_(\"Do not emit addressing modes with side-effect assignment\")},\t\\\n+  {\"stack-align\",\t\t\tTARGET_MASK_STACK_ALIGN, \"\"},\t\\\n+  {\"no-stack-align\",\t\t       -TARGET_MASK_STACK_ALIGN,\t\\\n+   N_(\"Do not tune stack alignment\")},\t\t\t\t\t\\\n+  {\"data-align\",\t\t\t TARGET_MASK_DATA_ALIGN, \"\"},\t\\\n+  {\"no-data-align\",\t\t\t-TARGET_MASK_DATA_ALIGN,\t\\\n+   N_(\"Do not tune writable data alignment\")},\t\t\t\t\\\n+  {\"const-align\",\t\t\tTARGET_MASK_CONST_ALIGN, \"\"},\t\\\n+  {\"no-const-align\",\t\t       -TARGET_MASK_CONST_ALIGN,\t\\\n+   N_(\"Do not tune code and read-only data alignment\")},\t\t\\\n+  {\"32-bit\",\t\t\t    (TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_DATA_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_ALIGN_BY_32), \"\"},\t\\\n+  {\"32bit\",\t\t\t    (TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_DATA_ALIGN\t\t\\\n+\t\t\t\t     + TARGET_MASK_ALIGN_BY_32),\t\\\n+   N_(\"Align code and data to 32 bits\")},\t\t\t\t\\\n+  {\"16-bit\",\t\t\t     (TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_DATA_ALIGN), \"\"},\t\\\n+  {\"16bit\",\t\t\t     (TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_DATA_ALIGN), \"\"},\t\\\n+  {\"8-bit\",\t\t\t    -(TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_DATA_ALIGN), \"\"},\t\\\n+  {\"8bit\",\t\t\t    -(TARGET_MASK_STACK_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_CONST_ALIGN\t\t\\\n+\t\t\t\t      + TARGET_MASK_DATA_ALIGN),\t\\\n+   N_(\"Don't align items in code or data\")},\t\t\t\t\\\n+  {\"prologue-epilogue\",\t\t  TARGET_MASK_PROLOGUE_EPILOGUE, \"\"},\t\\\n+  {\"no-prologue-epilogue\",\t -TARGET_MASK_PROLOGUE_EPILOGUE,\t\\\n+   N_(\"Do not emit function prologue or epilogue\")},\t\t\t\\\n+  /* We have to handle this m-option here since we can't wash it off in \\\n+     both CC1_SPEC and CC1PLUS_SPEC.  */\t\t\t\t\\\n+  {\"best-lib-options\",\t\t\t\t\t      0,\t\\\n+ N_(\"Use the most feature-enabling options allowed by other options\")},\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+  /* We must call it \"override-\" since calling it \"no-\" will cause\t\\\n+     gcc.c to forget it, if there's a \"later\" -mbest-lib-options.\t\\\n+     Kludgy, but needed for some multilibbed files.  */\t\t\t\\\n+  {\"override-best-lib-options\",\t\t\t\t      0,\t\\\n+   N_(\"Override -mbest-lib-options\")},\t\t\t\t\t\\\n+  CRIS_SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+  {\"\",\t\t\tTARGET_DEFAULT | CRIS_SUBTARGET_DEFAULT, \"\"}}\t\\\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_SUBTARGET_SWITCHES \\\n+ {\"elf\", 0, \"\"},\n+\n+/* Default target_flags if no switches specified.  */\n+#ifndef TARGET_DEFAULT\n+# define TARGET_DEFAULT \\\n+ (TARGET_MASK_SIDE_EFFECT_PREFIXES + TARGET_MASK_STACK_ALIGN \\\n+  + TARGET_MASK_CONST_ALIGN + TARGET_MASK_DATA_ALIGN \\\n+  + TARGET_MASK_PROLOGUE_EPILOGUE)\n+#endif\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_SUBTARGET_DEFAULT TARGET_MASK_ELF\n+\n+#define CRIS_CPU_BASE 0\n+#define CRIS_CPU_ETRAX4 3\t/* Just lz added.  */\n+#define CRIS_CPU_SVINTO 8\t/* Added swap, jsrc & Co., 32-bit accesses.  */\n+#define CRIS_CPU_NG 10\t\t/* Added mul[su].  */\n+\n+/* Local, providing a default for cris_cpu_version.  */\n+#define CRIS_DEFAULT_CPU_VERSION CRIS_CPU_BASE\n+\n+#define TARGET_HAS_MUL_INSNS (cris_cpu_version >= CRIS_CPU_NG)\n+\n+#define TARGET_OPTIONS\t\t\t\t\t\t\t\\\n+ {{\"cpu=\", &cris_cpu_str, \"\"},\t\t\t\t\t\t\\\n+  {\"arch=\", &cris_cpu_str,\t\t\t\t\t\t\\\n+   N_(\"Generate code for the specified chip or CPU version\")},\t\t\\\n+  {\"tune=\", &cris_tune_str,\t\t\t\t\t\t\\\n+   N_(\"Tune alignment for the specified chip or CPU version\")},\t\t\\\n+  {\"max-stackframe=\", &cris_max_stackframe_str,\t\t\t\t\\\n+   N_(\"Warn when a stackframe is larger than the specified size\")},\t\\\n+  CRIS_SUBTARGET_LONG_OPTIONS\t\t\t\t\t\t\\\n+  {\"ax-stackframe=\", &cris_max_stackframe_str, \"\"}}\n+\n+#define CRIS_SUBTARGET_LONG_OPTIONS\n+\n+/* Print subsidiary information on the compiler version in use.\n+   Do not use VD.D syntax (D=digit), since this will cause confusion\n+   with the base gcc version among users, when we ask which version of\n+   gcc-cris they are using.  Please use some flavor of \"R<number>\" for\n+   the version (no need for major.minor versions, I believe).  */\n+#define TARGET_VERSION \\\n+ fprintf (stderr, \" [Axis CRIS release R36a%s]\", CRIS_SUBTARGET_VERSION)\n+\n+/* For the cris-*-elf subtarget.  */\n+#define CRIS_SUBTARGET_VERSION \" - generic ELF\"\n+\n+#define OVERRIDE_OPTIONS cris_override_options ()\n+\n+/* The following gives optimal code for gcc-2.7.2, but *may* be subject\n+   to change.  Omitting flag_force_addr gives .1-.7% faster code for gcc\n+   *only*, but 1.3% larger code.  On ipps it gives 5.3-10.6% slower\n+   code(!) and 0.3% larger code.  For products, images gets .1-1.8%\n+   larger.  Do not set strict aliasing from optimization options.  */\n+#define OPTIMIZATION_OPTIONS(OPTIMIZE, SIZE)\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      if ((OPTIMIZE) >= 2 || (SIZE))\t\t\\\n+\t{\t\t\t\t\t\\\n+\t  flag_force_addr =\t\t\t\\\n+\t    flag_omit_frame_pointer = 1;\t\\\n+\t}\t\t\t\t\t\\\n+      flag_strict_aliasing = 0;\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Storage Layout */\n+\n+#define BITS_BIG_ENDIAN 0\n+\n+#define BYTES_BIG_ENDIAN 0\n+\n+/* WORDS_BIG_ENDIAN is not defined in the hardware, but for consistency,\n+   we use little-endianness, and we may also be able to use\n+   post-increment on DImode indirect.  */\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define BITS_PER_UNIT 8\n+\n+#define BITS_PER_WORD 32\n+\n+#define UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE 32\n+\n+/* A combination of defining PROMOTE_MODE, PROMOTE_FUNCTION_ARGS,\n+   PROMOTE_FOR_CALL_ONLY and *not* defining PROMOTE_PROTOTYPES gives the\n+   best code size and speed for gcc, ipps and products in gcc-2.7.2.  */\n+#define CRIS_PROMOTED_MODE(MODE, UNSIGNEDP, TYPE) \\\n+ (GET_MODE_CLASS (MODE) == MODE_INT && GET_MODE_SIZE (MODE) < 4) \\\n+  ? SImode : MODE\n+\n+#define PROMOTE_MODE(MODE, UNSIGNEDP, TYPE)  \\\n+  (MODE) = CRIS_PROMOTED_MODE (MODE, UNSIGNEDP, TYPE)\n+\n+#define PROMOTE_FUNCTION_ARGS\n+\n+/* Defining PROMOTE_FUNCTION_RETURN in gcc-2.7.2 uncovers bug 981110 (even\n+   if defining FUNCTION_VALUE with MODE as PROMOTED_MODE ;-)\n+\n+   FIXME: Report this when cris.h is part of GCC, so others can easily\n+   see the problem.  Maybe check other systems that define\n+   PROMOTE_FUNCTION_RETURN.  */\n+#define PROMOTE_FOR_CALL_ONLY\n+\n+/* We will be using prototype promotion, so they will be 32 bit.  */\n+#define PARM_BOUNDARY 32\n+\n+/* Stack boundary is guided by -mstack-align, -mno-stack-align,\n+   -malign.\n+   Old comment: (2.1: still valid in 2.7.2?)\n+    Note that to make this macro affect the alignment of stack\n+   locals, a fix was required, and special precautions when handling\n+   the stack pointer in various other macros (FUNCTION_PROLOGUE et al)\n+   were required.  See file \"function.c\".  If you would just define\n+   this macro, it would only affect the builtin alloca and variable\n+   local data (non-ANSI, non-K&R, Gnu C extension).  */\n+#define STACK_BOUNDARY \\\n+ (TARGET_STACK_ALIGN ? (TARGET_ALIGN_BY_32 ? 32 : 16) : 8)\n+\n+#define FUNCTION_BOUNDARY 16\n+\n+/* Do not change BIGGEST_ALIGNMENT (when optimizing), as it will affect\n+   strange places, at least in 2.1. */\n+#define BIGGEST_ALIGNMENT 8\n+\n+/* If -m16bit,\t-m16-bit, -malign or -mdata-align,\n+   align everything to 16 bit. */\n+#define DATA_ALIGNMENT(TYPE, BASIC_ALIGN)\t\t\t\\\n+ (TARGET_DATA_ALIGN\t\t\t\t\t\t\\\n+  ? (TARGET_ALIGN_BY_32\t\t\t\t\t\t\\\n+     ? (BASIC_ALIGN < 32 ? 32 : BASIC_ALIGN)\t\t\t\\\n+     : (BASIC_ALIGN < 16 ? 16 : BASIC_ALIGN)) : BASIC_ALIGN)\n+\n+/* Note that CONSTANT_ALIGNMENT has the effect of making gcc believe that\n+   ALL references to constant stuff (in code segment, like strings) has\n+   this alignment.  That is a rather rushed assumption.  Luckily we do not\n+   care about the \"alignment\" operand to builtin memcpy (only place where\n+   it counts), so it doesn't affect any bad spots.  */\n+#define CONSTANT_ALIGNMENT(CONSTANT, BASIC_ALIGN)\t\t\\\n+ (TARGET_CONST_ALIGN\t\t\t\t\t\t\\\n+  ? (TARGET_ALIGN_BY_32\t\t\t\t\t\t\\\n+     ? (BASIC_ALIGN < 32 ? 32 : BASIC_ALIGN)\t\t\t\\\n+     : (BASIC_ALIGN < 16 ? 16 : BASIC_ALIGN)) : BASIC_ALIGN)\n+\n+/* FIXME: Define LOCAL_ALIGNMENT for word and dword or arrays and\n+   structures (if -mstack-align=), and check that it is good.  */\n+\n+#define EMPTY_FIELD_BOUNDARY 8\n+\n+#define STRUCTURE_SIZE_BOUNDARY 8\n+\n+#define STRICT_ALIGNMENT 0\n+\n+/* Remove any previous definition (elfos.h).\n+   ??? If it wasn't for all the other stuff that affects layout of\n+   structures and bit-fields, this could presumably cause incompatibility\n+   with other GNU/Linux ports (i.e. elfos.h users).  */\n+#undef PCC_BITFIELD_TYPE_MATTERS\n+\n+/* This is only used for non-scalars.  Strange stuff happens to structs\n+   (FIXME: What?) if we use anything larger than largest actually used\n+   datum size, so lets make it 32.  The type \"long long\" will still work\n+   as usual.  We can still have DImode insns, but they will only be used\n+   for scalar data (i.e. long long).  */\n+#define MAX_FIXED_MODE_SIZE 32\n+\n+\n+/* Node: Type Layout */\n+\n+/* Note that DOUBLE_TYPE_SIZE is not defined anymore, since the default\n+   value gives a 64-bit double, which is what we now use.  */\n+\n+/* For compatibility and historical reasons, a char should be signed.  */\n+#define DEFAULT_SIGNED_CHAR 1\n+\n+/* No DEFAULT_SHORT_ENUMS, please.  */\n+\n+/* Note that WCHAR_TYPE_SIZE is used in cexp.y,\n+   where TARGET_SHORT is not available.  */\n+#undef WCHAR_TYPE\n+#define WCHAR_TYPE \"long int\"\n+\n+#undef WCHAR_TYPE_SIZE\n+#define WCHAR_TYPE_SIZE 32\n+\n+\n+/* Node: Register Basics */\n+\n+/*  We count all 16 non-special registers, SRP and a faked argument\n+    pointer register.  */\n+#define FIRST_PSEUDO_REGISTER (16 + 1 + 1)\n+\n+/* For CRIS, these are r15 (pc) and r14 (sp). Register r8 is used as a\n+   frame-pointer, but is not fixed.  SRP is not included in general\n+   registers and will not be used automatically.  All other special\n+   registers are fixed at the moment.  The faked argument pointer register\n+   is fixed too.  */\n+#define FIXED_REGISTERS \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1}\n+\n+/* Register r9 is used for structure-address, r10-r13 for parameters,\n+   r10- for return values.  */\n+#define CALL_USED_REGISTERS \\\n+ {0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 0, 1}\n+\n+#define CONDITIONAL_REGISTER_USAGE cris_conditional_register_usage ()\n+\n+\n+/* Node: Allocation Order */\n+\n+/* We need this on CRIS, because call-used regs should be used first,\n+   (so we dont need to push).  Else start using registers from r0 and up.\n+    This preference is mainly because if we put call-used-regs from r0\n+   and up, then we can't use movem to push the rest, (which have to be\n+   saved if we use them, and movem has to start with r0).\n+   Change here if you change which registers to use as call registers.\n+\n+   The actual need to explicitly prefer call-used registers improved the\n+   situation a lot for 2.1, but might not actually be needed anymore.\n+   Still, this order reflects what GCC should find out by itself, so it\n+   probably does not hurt.\n+\n+   Order of preference: Call-used-regs first, then r0 and up, last fp &\n+   sp & pc as fillers.\n+   Call-used regs in opposite order, so they will cause less conflict if\n+   a function has few args (<= 3) and it wants a scratch reg.\n+    Use struct-return address first, since very few functions use\n+   structure return values so it is likely to be available.  */\n+#define REG_ALLOC_ORDER \\\n+ {9, 13, 12, 11, 10, 0, 1, 2, 3, 4, 5, 6, 7, 8, 14, 15, 16, 17}\n+\n+\n+/* Node: Values in Registers */\n+\n+/* The VOIDmode test is so we can omit mode on anonymous insns.  FIXME:\n+   Still needed in 2.9x, at least for Axis-20000319.  */\n+#define HARD_REGNO_NREGS(REGNO, MODE)\t\\\n+ (MODE == VOIDmode \\\n+  ? 1 : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* CRIS permits all registers to hold all modes.  */\n+#define HARD_REGNO_MODE_OK(REGNO, MODE) 1\n+\n+#define MODES_TIEABLE_P(MODE1, MODE2)  1\n+\n+\n+/* Node: Leaf Functions */\n+/* (no definitions) */\n+\n+/* Node: Stack Registers */\n+/* (no definitions) */\n+\n+\n+/* Node: Register Classes */\n+\n+/* CRIS has only one kind of registers, so NO_REGS and ALL_REGS\n+   are the only classes.  FIXME: It actually makes sense to have another\n+   class for special registers, and yet another class for the\n+   multiply-overflow register in v10; then a class for the return\n+   register also makes sense.  */\n+enum reg_class {NO_REGS, ALL_REGS, LIM_REG_CLASSES};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES {\"NO_REGS\", \"ALL_REGS\"}\n+\n+#define GENERAL_REGS ALL_REGS\n+\n+/* Count in the faked argument register in GENERAL_REGS.  Keep out SRP.  */\n+#define REG_CLASS_CONTENTS {{0}, {0x2ffff}}\n+\n+#define REGNO_REG_CLASS(REGNO) GENERAL_REGS\n+\n+#define BASE_REG_CLASS GENERAL_REGS\n+\n+#define INDEX_REG_CLASS GENERAL_REGS\n+\n+/* Get reg_class from a letter such as appears in the machine\n+   description.  No letters are used, since 'r' is used for any\n+   register.  */\n+#define REG_CLASS_FROM_LETTER(C) NO_REGS\n+\n+/* Since it uses reg_renumber, it is safe only once reg_renumber\n+   has been allocated, which happens in local-alloc.c.  */\n+#define REGNO_OK_FOR_BASE_P(REGNO)\t\t\t\t\t\\\n+ ((REGNO) <= CRIS_LAST_GENERAL_REGISTER\t\t\t\t\t\\\n+  || (REGNO) == ARG_POINTER_REGNUM\t\t\t\t\t\\\n+  || (unsigned) reg_renumber[REGNO] <= CRIS_LAST_GENERAL_REGISTER\t\\\n+  || (unsigned) reg_renumber[REGNO] == ARG_POINTER_REGNUM)\n+\n+/* See REGNO_OK_FOR_BASE_P.  */\n+#define REGNO_OK_FOR_INDEX_P(REGNO) REGNO_OK_FOR_BASE_P(REGNO)\n+\n+/* It seems like gcc (2.7.2 and 2.9x of 2000-03-22) may send \"NO_REGS\" as\n+   the class for a constant (testcase: __Mul in arit.c).  To avoid forcing\n+   out a constant into the constant pool, we will trap this case and\n+   return something a bit more sane.  FIXME: Check if this is a bug.  */\n+#define PREFERRED_RELOAD_CLASS(X, CLASS) \\\n+ ((CLASS) == NO_REGS ? GENERAL_REGS : (CLASS))\n+\n+/* For CRIS, this is always the size of MODE in words,\n+   since all registers are the same size.  To use omitted modes in\n+   patterns with reload constraints, you must say the widest size\n+   which is allowed for VOIDmode.\n+   FIXME:  Does that still apply for gcc-2.9x?  Keep poisoned until such\n+   patterns are added back.  News: 2001-03-16: Happens as early as the\n+   underscore-test.  */\n+#define CLASS_MAX_NREGS(CLASS, MODE)\t\t\t\t\t\\\n+ ((MODE) == VOIDmode\t\t\t\t\t\t\t\\\n+  ? 1 /* + cris_fatal (\"CLASS_MAX_NREGS with VOIDmode\")\t*/\t\t\\\n+  : ((GET_MODE_SIZE (MODE) + UNITS_PER_WORD - 1) / UNITS_PER_WORD))\n+\n+/* We are now out of letters; we could use ten more.  This forces us to\n+   use C-code in the 'md' file.  FIXME: Use some EXTRA_CONSTRAINTS.  */\n+#define CONST_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n+ (\t\t\t\t\t\t\t\\\n+  /* MOVEQ, CMPQ, ANDQ, ORQ.  */\t\t\t\\\n+  (C) == 'I' ? (VALUE) >= -32 && (VALUE) <= 31 :\t\\\n+  /* ADDQ, SUBQ.  */\t\t\t\t\t\\\n+  (C) == 'J' ? (VALUE) >= 0 && (VALUE) <= 63 :\t\t\\\n+  /* ASRQ, BTSTQ, LSRQ, LSLQ.  */\t\t\t\\\n+  (C) == 'K' ? (VALUE) >= 0 && (VALUE) <= 31 :\t\t\\\n+  /* A 16-bit signed number.  */\t\t\t\\\n+  (C) == 'L' ? (VALUE) >= -32768 && (VALUE) <= 32767 :\t\\\n+  /* The constant 0 for CLEAR.  */\t\t\t\\\n+  (C) == 'M' ? (VALUE) == 0 :\t\t\t\t\\\n+  /* A negative ADDQ or SUBQ.  */\t\t\t\\\n+  (C) == 'N' ? (VALUE) >= -63 && (VALUE) < 0 :\t\t\\\n+  /* Quickened ints, QI and HI.  */\t\t\t\\\n+  (C) == 'O' ? (VALUE) >= 0 && (VALUE) <= 65535\t\t\\\n+\t\t&& ((VALUE) >= (65535-31)\t\t\\\n+\t\t    || ((VALUE) >= (255-31)\t\t\\\n+\t\t\t&& (VALUE) <= 255 )) :\t\t\\\n+  /* A 16-bit number signed *or* unsigned.  */\t\t\\\n+  (C) == 'P' ? (VALUE) >= -32768 && (VALUE) <= 65535 :\t\\\n+  0)\n+\n+/* It is really simple to make up a 0.0; it is the same as int-0 in\n+   IEEE754. */\n+#define CONST_DOUBLE_OK_FOR_LETTER_P(VALUE, C)\t\t\t\\\n+ ((C) == 'G' && ((VALUE) == CONST0_RTX (DFmode)\t\t\t\\\n+\t\t || (VALUE) == CONST0_RTX (SFmode)))\n+\n+/* We need this on cris to distinguish delay-slottable addressing modes.  */\n+#define EXTRA_CONSTRAINT(X, C)\t\t\t\\\n+ (\t\t\t\t\t\t\\\n+  /* Slottable address mode?  */\t\t\\\n+  (C) == 'Q' ? EXTRA_CONSTRAINT_Q (X) :\t\t\\\n+  /* Operand to BDAP or BIAP?  */\t\t\\\n+  (C) == 'R' ? EXTRA_CONSTRAINT_R (X) :\t\t\\\n+  /* A local PIC symbol?  */\t\t\t\\\n+  (C) == 'S' ? EXTRA_CONSTRAINT_S (X) :\t\t\\\n+  /* A three-address addressing-mode?  */\t\\\n+  (C) == 'T' ? EXTRA_CONSTRAINT_T (X) :\t\t\\\n+  /* A global PIC symbol?  */\t\t\t\\\n+  (C) == 'U' ? EXTRA_CONSTRAINT_U (X) :\t\t\\\n+  0)\n+\n+#define EXTRA_CONSTRAINT_Q(X)\t\t\t\t\\\n+ (\t\t\t\t\t\t\t\\\n+  /* Slottable addressing modes:\t\t\t\\\n+     A register?  FIXME: Unnecessary.  */\t\t\\\n+  (BASE_P (X) && REGNO (X) != CRIS_PC_REGNUM)\t\t\\\n+  /* Indirect register: [reg]?  */\t\t\t\\\n+  || (GET_CODE (X) == MEM && BASE_P (XEXP (X, 0))\t\\\n+      && REGNO (XEXP (X, 0)) != CRIS_PC_REGNUM)\t\t\\\n+ )\n+\n+#define EXTRA_CONSTRAINT_R(X)\t\t\t\t\t\\\n+ (\t\t\t\t\t\t\t\t\\\n+  /* An operand to BDAP or BIAP:\t\t\t\t\\\n+     A BIAP; r.S? */\t\t\t\t\t\t\\\n+  BIAP_INDEX_P (X)\t\t\t\t\t\t\\\n+  /* A [reg] or (int) [reg], maybe with post-increment.  */\t\\\n+  || BDAP_INDEX_P (X)\t\t\t\t\t\t\\\n+  || CONSTANT_INDEX_P (X)\t\t\t\t\t\\\n+ )\n+\n+/* FIXME: Bug below: We can't have XEXP (X, 0)) both be MEM and a\n+   CONSTANT_P.  Parens don't match indentation.  */\n+\n+#define EXTRA_CONSTRAINT_T(X)\t\t\t\t\t\t\\\n+ (\t\t\t\t\t\t\t\t\t\\\n+  /* Three-address-operands.  All are indirect-memory:  */\t\t\\\n+  GET_CODE (X) == MEM\t\t\t\t\t\t\t\\\n+  && ((GET_CODE (XEXP (X, 0)) == MEM\t\t\t\t\t\\\n+  /* Double indirect: [[reg]] or [[reg+]]?  */\t\t\t\t\\\n+  && (BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\t\t\t\\\n+      /* Just an explicite indirect reference: [const]?  */\t\t\\\n+      || CONSTANT_P (XEXP (X, 0))\t\t\t\t\t\\\n+      /* Something that is indexed; [...+...]?  */\t\t\t\\\n+      || (GET_CODE (XEXP (X, 0)) == PLUS\t\t\t\t\\\n+\t  /* A BDAP constant: [reg+(8|16|32)bit offset]?  */\t\t\\\n+\t  && ((BASE_P (XEXP (XEXP (X, 0), 0))\t\t\t\t\\\n+\t       && CONSTANT_INDEX_P (XEXP (XEXP (X, 0), 1)))\t\t\\\n+\t      /* Swap arguments to the above.  FIXME: gcc-2.9x? */\t\\\n+\t      || (BASE_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n+\t\t  && CONSTANT_INDEX_P (XEXP (XEXP (X, 0), 0)))\t\t\\\n+\t      /* A BDAP register: [reg+[reg(+)].S]?  */\t\t\t\\\n+\t      || (BASE_P (XEXP (XEXP (X, 0), 0))\t\t\t\\\n+\t\t  && BDAP_INDEX_P(XEXP(XEXP(X, 0), 1)))\t\t\t\\\n+\t      /* Same, but with swapped arguments.  */\t\t\t\\\n+\t      || (BASE_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n+\t\t  && BDAP_INDEX_P (XEXP (XEXP (X, 0), 0)))\t\t\\\n+\t      /* A BIAP: [reg+reg.S].  */\t\t\t\t\\\n+\t      || (BASE_P (XEXP (XEXP (X, 0), 0))\t\t\t\\\n+\t\t  && BIAP_INDEX_P (XEXP (XEXP (X, 0), 1)))\t\t\\\n+\t      /* Same, but with swapped arguments.  */\t\t\t\\\n+\t      || (BASE_P (XEXP (XEXP (X, 0), 1))\t\t\t\\\n+\t\t  && BIAP_INDEX_P (XEXP (XEXP (X, 0), 0))))))\t\t\\\n+ )\n+\n+#define EXTRA_CONSTRAINT_S(X) \\\n+ (flag_pic && CONSTANT_P (X) && cris_gotless_symbol (X))\n+\n+#define EXTRA_CONSTRAINT_U(X) \\\n+ (flag_pic && CONSTANT_P (X) && cris_got_symbol (X))\n+\n+\n+/* Node: Frame Layout */\n+\n+#define STACK_GROWS_DOWNWARD\n+#define FRAME_GROWS_DOWNWARD\n+\n+/* It seems to be indicated in the code (at least 2.1) that this is\n+   better a constant, and best 0.  */\n+#define STARTING_FRAME_OFFSET 0\n+\n+#define FIRST_PARM_OFFSET(FNDECL) 0\n+\n+#define RETURN_ADDR_RTX(COUNT, FRAMEADDR) \\\n+ cris_return_addr_rtx (COUNT, FRAMEADDR)\n+\n+#define INCOMING_RETURN_ADDR_RTX gen_rtx (REG, Pmode, CRIS_SRP_REGNUM)\n+\n+/* FIXME: Any __builtin_eh_return callers must not return anything and\n+   there must not be collisions with incoming parameters.  Luckily the\n+   number of __builtin_eh_return callers is limited.  For now return\n+   parameter registers in reverse order and hope for the best.  */\n+#define EH_RETURN_DATA_REGNO(N) \\\n+  (((N) >= 0 && (N) < 4) ? (CRIS_FIRST_ARG_REG + 3 - (N)) : INVALID_REGNUM)\n+\n+/* Store the stack adjustment in the structure-return-address register.  */\n+#define CRIS_STACKADJ_REG STRUCT_VALUE_REGNUM\n+#define EH_RETURN_STACKADJ_RTX gen_rtx_REG (SImode, CRIS_STACKADJ_REG)\n+\n+#define EH_RETURN_HANDLER_RTX \\\n+  cris_return_addr_rtx (0, NULL)\n+\n+#define INIT_EXPANDERS cris_init_expanders ()\n+\n+/* FIXME: Move this to right node (it's not documented properly yet).  */\n+#define DWARF_FRAME_RETURN_COLUMN DWARF_FRAME_REGNUM (CRIS_SRP_REGNUM)\n+\n+/* FIXME: Move this to right node (it's not documented properly yet).\n+   FIXME: Check what alignment we can assume regarding\n+   TARGET_STACK_ALIGN and TARGET_ALIGN_BY_32.  */\n+#define DWARF_CIE_DATA_ALIGNMENT -1\n+\n+/* If we would ever need an exact mapping between canonical register\n+   number and dwarf frame register, we would either need to include all\n+   registers in the gcc decription (with some marked fixed of course), or\n+   an inverse mapping from dwarf register to gcc register.  There is one\n+   need in dwarf2out.c:expand_builtin_init_dwarf_reg_sizes.  Right now, I\n+   don't see that we need exact correspondence between DWARF *frame*\n+   registers and DBX_REGISTER_NUMBER, so map them onto GCC registers.  */\n+#define DWARF_FRAME_REGNUM(REG) (REG)\n+\n+/* Node: Stack Checking */\n+/* (no definitions) FIXME: Check.  */\n+\n+/* Node: Frame Registers */\n+\n+#define STACK_POINTER_REGNUM 14\n+\n+/* Register used for frame pointer.  This is also the last of the saved\n+   registers, when a frame pointer is not used. */\n+#define FRAME_POINTER_REGNUM 8\n+\n+/* Faked register, is always eliminated.  We need it to eliminate\n+   allocating stack slots for the return address and the frame pointer.  */\n+#define ARG_POINTER_REGNUM 17\n+\n+#define STATIC_CHAIN_REGNUM 7\n+\n+\n+/* Node: Elimination */\n+\n+/* Really only needed if the stack frame has variable length (alloca\n+   or variable sized local arguments (GNU C extension).  */\n+#define FRAME_POINTER_REQUIRED 0\n+\n+#define ELIMINABLE_REGS\t\t\t\t\\\n+ {{ARG_POINTER_REGNUM, STACK_POINTER_REGNUM},\t\\\n+  {ARG_POINTER_REGNUM, FRAME_POINTER_REGNUM},\t\\\n+  {FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM}}\n+\n+/* We need not worry about when the frame-pointer is required for other\n+   reasons.  */\n+#define CAN_ELIMINATE(FROM, TO) 1\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET) \\\n+ (OFFSET) = cris_initial_elimination_offset (FROM, TO)\n+\n+\n+/* Node: Stack Arguments */\n+\n+/* Since many parameters take up one register each in any case,\n+   PROMOTE_PROTOTYPES would seem like a good idea, but measurements\n+   indicate that a combination using PROMOTE_MODE is better.  */\n+\n+#define ACCUMULATE_OUTGOING_ARGS 1\n+\n+#define RETURN_POPS_ARGS(FUNDECL, FUNTYPE, STACKSIZE) 0\n+\n+\n+/* Node: Register Arguments */\n+\n+/* The void_type_node is sent as a \"closing\" call.  We have to stop it\n+   since it's invalid to FUNCTION_ARG_PASS_BY_REFERENCE (or was invalid at\n+   some time).  */\n+#define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+ ((CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\t\\\n+  && (TYPE) != void_type_node\t\t\t\t\t\\\n+  && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED)\t\\\n+  ? gen_rtx (REG, MODE, (CRIS_FIRST_ARG_REG) + (CUM).regs)\t\\\n+  : NULL_RTX)\n+\n+/* The differences between this and the previous, is that this one checks\n+   that an argument is named, since incoming stdarg/varargs arguments are\n+   pushed onto the stack, and we don't have to check against the \"closing\"\n+   void_type_node TYPE parameter.  */\n+#define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n+ (((NAMED) && (CUM).regs < CRIS_MAX_ARGS_IN_REGS\t\t\t\\\n+   && ! FUNCTION_ARG_PASS_BY_REFERENCE (CUM, MODE, TYPE, NAMED))\t\\\n+  ? gen_rtx (REG, MODE, CRIS_FIRST_ARG_REG + (CUM).regs)\t\t\\\n+  : NULL_RTX)\n+\n+#define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED)\t\\\n+ (((CUM).regs == (CRIS_MAX_ARGS_IN_REGS - 1)\t\t\t\\\n+   && !MUST_PASS_IN_STACK (MODE, TYPE)\t\t\t\t\\\n+   && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 4\t\t\t\\\n+   && CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) <= 8)\t\t\t\\\n+  ? 1 : 0)\n+\n+/* Structs may be passed by value, but they must not be more than 8\n+   bytes long.  */\n+#define FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+ (MUST_PASS_IN_STACK (MODE, TYPE)\t\t\t\t\t\\\n+  || CRIS_FUNCTION_ARG_SIZE (MODE, TYPE) > 8)\t\t\t\t\\\n+\n+/* Contrary to what you'd believe, defining FUNCTION_ARG_CALLEE_COPIES\n+   seems like a (small total) loss, at least for gcc-2.7.2 compiling and\n+   running gcc-2.1 (small win in size, small loss running -- 100.1%),\n+   and similarly for size for products (.1 .. .3% bloat, sometimes win).\n+   Due to the empirical likeliness of making slower code, it is not\n+   defined.  */\n+\n+/* This no longer *needs* to be a structure; but keeping it as such should\n+   not hurt (and hacking the ABI is simpler).  */\n+#define CUMULATIVE_ARGS struct cum_args\n+struct cum_args {int regs;};\n+\n+/* The regs member is an integer, the number of arguments got into\n+   registers so far, and lib is nonzero if init_cumulative_args was\n+   found to generate a call to a library function.  */\n+#define INIT_CUMULATIVE_ARGS(CUM, FNTYPE, LIBNAME, INDIRECT)\t  \\\n+ ((CUM).regs = 0)\n+\n+#define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\t\\\n+ ((CUM).regs\t\t\t\t\t\t\t\\\n+  = (FUNCTION_ARG_PASS_BY_REFERENCE(CUM, MODE, TYPE, NAMED)\t\\\n+     ? (CRIS_MAX_ARGS_IN_REGS) + 1\t\t\t\t\\\n+     : ((CUM).regs\t\t\t\t\t\t\\\n+\t+ (3 + (CRIS_FUNCTION_ARG_SIZE (MODE, TYPE))) / 4)))\n+\n+#define FUNCTION_ARG_REGNO_P(REGNO)\t\t\t\\\n+ ((REGNO) >= CRIS_FIRST_ARG_REG\t\t\t\t\\\n+  && (REGNO) < CRIS_FIRST_ARG_REG + (CRIS_MAX_ARGS_IN_REGS))\n+\n+\n+/* Node: Scalar Return */\n+\n+/* Let's assume all functions return in r[CRIS_FIRST_ARG_REG] for the\n+   time being.  */\n+#define FUNCTION_VALUE(VALTYPE, FUNC)  \\\n+ gen_rtx (REG, TYPE_MODE (VALTYPE), CRIS_FIRST_ARG_REG)\n+\n+#define LIBCALL_VALUE(MODE) gen_rtx (REG, MODE, CRIS_FIRST_ARG_REG)\n+\n+#define FUNCTION_VALUE_REGNO_P(N) ((N) == CRIS_FIRST_ARG_REG)\n+\n+\n+/* Node: Aggregate Return */\n+\n+#if 0\n+/* FIXME: Let's try this some time, so we return structures in registers.\n+   We would cast the result of int_size_in_bytes to unsigned, so we will\n+   get a huge number for \"structures\" of variable size (-1).  */\n+#define RETURN_IN_MEMORY(TYPE) \\\n+ ((unsigned) int_size_in_bytes (TYPE) > CRIS_MAX_ARGS_IN_REGS * UNITS_PER_WORD)\n+#endif\n+\n+#define STRUCT_VALUE_REGNUM ((CRIS_FIRST_ARG_REG) - 1)\n+\n+\n+/* Node: Caller Saves */\n+/* (no definitions) */\n+\n+/* Node: Function entry */\n+\n+/* See cris.c for TARGET_ASM_FUNCTION_PROLOGUE and\n+   TARGET_ASM_FUNCTION_EPILOGUE.  */\n+\n+/* If the epilogue uses the \"ret\" insn, we need to fill the\n+   delay slot.  */\n+#define DELAY_SLOTS_FOR_EPILOGUE cris_delay_slots_for_epilogue ()\n+\n+#define ELIGIBLE_FOR_EPILOGUE_DELAY(INSN, N) \\\n+  cris_eligible_for_epilogue_delay (INSN)\n+\n+#define ASM_OUTPUT_MI_THUNK(FILE, THUNK_FNDECL, DELTA, FUNCTION) \\\n+ cris_asm_output_mi_thunk(FILE, THUNK_FNDECL, DELTA, FUNCTION)\n+\n+\n+/* Node: Profiling */\n+\n+#define FUNCTION_PROFILER(FILE, LABELNO)  \\\n+ error (\"No FUNCTION_PROFILER for CRIS\")\n+\n+/* No profiling for the time being.  */\n+#define FUNCTION_BLOCK_PROFILER(FILE, LABELNO)\t\\\n+ error (\"No FUNCTION_BLOCK_PROFILER for CRIS\")\n+\n+/* No profiling for the time being.  */\n+#define BLOCK_PROFILER(FILE, BLOCKNO)\t\\\n+ error (\"No BLOCK_PROFILER for CRIS\")\n+\n+/* FIXME: Some of the undefined macros might be mandatory.  If so, fix\n+   documentation.  */\n+\n+\n+/* Node: Varargs */\n+\n+/* We save the register number of the first anonymous argument in\n+   first_vararg_reg, and take care of this in the function prologue.\n+   This behaviour is used by at least one more port (the ARM?), but\n+   may be unsafe when compiling nested functions.  (With varargs? Hairy.)\n+   Note that nested-functions is a GNU C extension.\n+\n+   FIXME: We can actually put the size in PRETEND and deduce the number\n+   of registers from it in the prologue and epilogue.  */\n+#define SETUP_INCOMING_VARARGS(ARGSSF, MODE, TYPE, PRETEND, SECOND)\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if ((ARGSSF).regs < (CRIS_MAX_ARGS_IN_REGS))\t\t\t\\\n+\t(PRETEND) = ((CRIS_MAX_ARGS_IN_REGS) - (ARGSSF).regs) * 4;\t\\\n+      if (TARGET_PDEBUG)\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  fprintf (asm_out_file,\t\t\t\t\t\\\n+\t\t   \"\\n; VA:: %s: %d args before, anon @ #%d, %dtime\\n\",\t\\\n+\t\t   current_function_varargs ? \"OLD\" : \"ANSI\",\t\t\\\n+\t\t   (ARGSSF).regs, PRETEND, SECOND);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* FIXME: This and other EXPAND_BUILTIN_VA_... target macros are not\n+   documented, although used by several targets.  */\n+#define EXPAND_BUILTIN_VA_ARG(VALIST, TYPE) \\\n+ cris_expand_builtin_va_arg (VALIST, TYPE)\n+\n+\n+/* Node: Trampolines */\n+\n+/* This looks too complicated, and it is.  I assigned r7 to be the\n+   static chain register, but it is call-saved, so we have to save it,\n+   and come back to restore it after the call, so we have to save srp...\n+   Anyway, trampolines are rare enough that we can cope with this\n+   somewhat lack of elegance.\n+    (Do not be tempted to \"straighten up\" whitespace in the asms; the\n+   assembler #NO_APP state mandates strict spacing). */\n+#define TRAMPOLINE_TEMPLATE(FILE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\tmove.d $%s,[$pc+20]\\n\",\t\\\n+\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n+      fprintf (FILE, \"\\tmove $srp,[$pc+22]\\n\");\t\\\n+      fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\\\n+\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n+      fprintf (FILE, \"\\tjsr 0\\n\");\t\t\\\n+      fprintf (FILE, \"\\tmove.d 0,$%s\\n\",\t\\\n+\t       reg_names[STATIC_CHAIN_REGNUM]);\t\\\n+      fprintf (FILE, \"\\tjump 0\\n\");\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define TRAMPOLINE_SIZE 32\n+\n+/* CRIS wants instructions on word-boundary.\n+   Note that due to a bug (reported) in 2.7.2 and earlier, this is\n+   actually treated as alignment in _bytes_, not _bits_.  (Obviously\n+   this is not fatal, only a slight waste of stack space). */\n+#define TRAMPOLINE_ALIGNMENT 16\n+\n+#define INITIALIZE_TRAMPOLINE(TRAMP, FNADDR, CXT)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\\\n+\t\t\t       plus_constant (TRAMP, 10)),\t\\\n+\t\t      CXT);\t\t\t\t\t\\\n+      emit_move_insn (gen_rtx (MEM, SImode,\t\t\t\\\n+\t\t\t       plus_constant (TRAMP, 16)),\t\\\n+\t\t      FNADDR);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Note that there is no need to do anything with the cache for sake of\n+   a trampoline.  */\n+\n+\n+/* Node: Library Calls */\n+\n+#define MULSI3_LIBCALL \"__Mul\"\n+#define DIVSI3_LIBCALL \"__Div\"\n+#define UDIVSI3_LIBCALL \"__Udiv\"\n+#define MODSI3_LIBCALL \"__Mod\"\n+#define UMODSI3_LIBCALL \"__Umod\"\n+\n+/* If you change this, you have to check whatever libraries and systems\n+   that use it.  */\n+#define TARGET_EDOM 33\n+\n+\n+/* Node: Addressing Modes */\n+\n+#define HAVE_POST_INCREMENT 1\n+\n+#define CONSTANT_ADDRESS_P(X) CONSTANT_P (X)\n+\n+#define MAX_REGS_PER_ADDRESS 2\n+\n+/* There are helper macros defined here which are used only in\n+   GO_IF_LEGITIMATE_ADDRESS.\n+\n+   Note that you *have to* reject invalid addressing modes for mode\n+   MODE, even if it is legal for normal addressing modes.  You cannot\n+   rely on the constraints to do this work.  They can only be used to\n+   doublecheck your intentions.  One example is that you HAVE TO reject\n+   (mem:DI (plus:SI (reg:SI x) (reg:SI y))) because for some reason\n+   this cannot be reloaded.  (Which of course you can argue that gcc\n+   should have done.)  FIXME:  Strange.  Check.  */\n+\n+/* No symbol can be used as an index (or more correct, as a base) together\n+   with a register with PIC; the PIC register must be there.  */\n+#define CONSTANT_INDEX_P(X) \\\n+ (CONSTANT_P (X) && !(flag_pic && cris_symbol (X)))\n+\n+/* True if X is a valid base register.  */\n+#define BASE_P(X) \\\n+ (REG_P (X) && REG_OK_FOR_BASE_P (X))\n+\n+/* True if X is a valid base register with or without autoincrement.  */\n+#define BASE_OR_AUTOINCR_P(X) \\\n+ (BASE_P (X) || (GET_CODE (X) == POST_INC && BASE_P (XEXP (X, 0))))\n+\n+/* True if X is a valid (register) index for BDAP, i.e. [Rs].S or [Rs+].S.  */\n+#define BDAP_INDEX_P(X)\t\t\t\t\t\\\n+ ((GET_CODE (X) == MEM && GET_MODE (X) == SImode\t\\\n+   && BASE_OR_AUTOINCR_P (XEXP (X, 0)))\t\t\t\\\n+  || (GET_CODE (X) == SIGN_EXTEND\t\t\t\\\n+      && GET_CODE (XEXP (X, 0)) == MEM\t\t\t\\\n+      && (GET_MODE (XEXP (X, 0)) == HImode\t\t\\\n+\t  || GET_MODE (XEXP (X, 0)) == QImode)\t\t\\\n+      && BASE_OR_AUTOINCR_P (XEXP (XEXP (X, 0), 0))))\n+\n+/* True if X is a valid (register) index for BIAP, i.e. Rd.m.  */\n+#define BIAP_INDEX_P(X)\t\t\t\t\\\n+ ((BASE_P (X) && REG_OK_FOR_INDEX_P (X))\t\\\n+  || (GET_CODE (X) == MULT\t\t\t\\\n+      && BASE_P (XEXP (X, 0))\t\t\t\\\n+      && REG_OK_FOR_INDEX_P (XEXP (X, 0))\t\\\n+      && GET_CODE (XEXP (X, 1)) == CONST_INT\t\\\n+      && (INTVAL (XEXP (X, 1)) == 2\t\t\\\n+\t  || INTVAL (XEXP (X, 1)) == 4)))\n+\n+/* True if X is an address that doesn't need a prefix i.e. [Rs] or [Rs+].  */\n+#define SIMPLE_ADDRESS_P(X) \\\n+ (BASE_P (X)\t\t\t\t\t\t\\\n+  || (GET_CODE (X) == POST_INC\t\t\t\t\\\n+      && BASE_P (XEXP (X, 0))))\n+\n+/* A PIC operand looks like a normal symbol here.  At output we dress it\n+   in \"[rPIC+symbol:GOT]\" (global symbol) or \"rPIC+symbol:GOTOFF\" (local\n+   symbol) so we exclude all addressing modes where we can't replace a\n+   plain \"symbol\" with that.  A global PIC symbol does not fit anywhere\n+   here (but is thankfully a general_operand in itself).  A local PIC\n+   symbol is valid for the plain \"symbol + offset\" case.  */\n+#define GO_IF_LEGITIMATE_ADDRESS(MODE, X, ADDR)\t\t\t\\\n+ {\t\t\t\t\t\t\t\t\\\n+   rtx x1, x2;\t\t\t\t\t\t\t\\\n+   if (SIMPLE_ADDRESS_P (X))\t\t\t\t\t\\\n+     goto ADDR;\t\t\t\t\t\t\t\\\n+   if (CONSTANT_P (X)\t\t\t\t\t\t\\\n+       && (! flag_pic\t\t\t\t\t\t\\\n+\t   || cris_gotless_symbol (X)\t\t\t\t\\\n+\t   || ! cris_symbol (X)))\t\t\t\t\\\n+     goto ADDR;\t\t\t\t\t\t\t\\\n+   /* Indexed?  */\t\t\t\t\t\t\\\n+   if (GET_CODE (X) == PLUS)\t\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+       x1 = XEXP (X, 0);\t\t\t\t\t\\\n+       x2 = XEXP (X, 1);\t\t\t\t\t\\\n+       /* BDAP o, Rd.  */\t\t\t\t\t\\\n+       if ((BASE_P (x1) && CONSTANT_INDEX_P (x2))\t\t\\\n+\t   || (BASE_P (x2) && CONSTANT_INDEX_P (x1))\t\t\\\n+\t    /* BDAP Rs[+], Rd.  */\t\t\t\t\\\n+\t   || (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\\\n+\t       && ((BASE_P (x1) && BDAP_INDEX_P (x2))\t\t\\\n+\t\t   || (BASE_P (x2) && BDAP_INDEX_P (x1))\t\\\n+\t\t   /* BIAP.m Rs, Rd */\t\t\t\t\\\n+\t\t   || (BASE_P (x1) && BIAP_INDEX_P (x2))\t\\\n+\t\t   || (BASE_P (x2) && BIAP_INDEX_P (x1)))))\t\\\n+\t goto ADDR;\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+   else if (GET_CODE (X) == MEM)\t\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\\\n+       /* DIP (Rs).  Reject [[reg+]] and [[reg]] for\t\t\\\n+\t  DImode (long long).  */\t\t\t\t\\\n+       if (GET_MODE_SIZE (MODE) <= UNITS_PER_WORD\t\t\\\n+\t   && (BASE_P (XEXP (X, 0))\t\t\t\t\\\n+\t       || BASE_OR_AUTOINCR_P (XEXP (X, 0))))\t\t\\\n+\t goto ADDR;\t\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\\\n+ }\n+\n+#ifndef REG_OK_STRICT\n+ /* Nonzero if X is a hard reg that can be used as a base reg\n+    or if it is a pseudo reg.  */\n+# define REG_OK_FOR_BASE_P(X)\t\t\t\\\n+ (REGNO (X) <= CRIS_LAST_GENERAL_REGISTER\t\\\n+  || REGNO (X) == ARG_POINTER_REGNUM\t\t\\\n+  || REGNO (X) >= FIRST_PSEUDO_REGISTER)\n+#else\n+ /* Nonzero if X is a hard reg that can be used as a base reg.  */\n+# define REG_OK_FOR_BASE_P(X) REGNO_OK_FOR_BASE_P (REGNO (X))\n+#endif\n+\n+#ifndef REG_OK_STRICT\n+ /* Nonzero if X is a hard reg that can be used as an index\n+    or if it is a pseudo reg.  */\n+# define REG_OK_FOR_INDEX_P(X) REG_OK_FOR_BASE_P (X)\n+#else\n+ /* Nonzero if X is a hard reg that can be used as an index.  */\n+# define REG_OK_FOR_INDEX_P(X) REGNO_OK_FOR_INDEX_P (REGNO (X))\n+#endif\n+\n+/* For now, don't do anything.  GCC does a good job most often.\n+\n+    Maybe we could do something about gcc:s misbehaviour when it\n+   recalculates frame offsets for local variables, from fp+offs to\n+   sp+offs.  The resulting address expression gets screwed up\n+   sometimes, but I'm not sure that it may be fixed here, since it is\n+   already split up in several instructions (Is this still true?).\n+   FIXME: Check and adjust for gcc-2.9x.  */\n+#define LEGITIMIZE_ADDRESS(X, OLDX, MODE, WIN) {}\n+\n+/* Functionality import from EGCS.\n+   Kludge to solve Axis-990219: Work around imperfection in\n+   reload_load_address1:\n+    (plus (sign_extend (mem:qi (reg))) (reg))\n+   should be reloaded as (plus (reg) (reg)), not\n+    (plus (sign_extend (reg)) (reg)).\n+   There are no checks that reload_load_address_1 \"reloads\"\n+   addresses correctly, so invalidness is not caught or\n+   corrected.\n+    When the right thing happens, the \"something_reloaded\" kludge can\n+   be removed.  The right thing does not appear to happen for\n+   EGCS CVS as of this date (above).  */\n+\n+#define LEGITIMIZE_RELOAD_ADDRESS(X, MODE, OPNUM, TYPE, IND_LEVELS, WIN) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      if (GET_CODE (X) == PLUS\t\t\t\t\t\t\\\n+\t  && REG_P (XEXP (X, 1))\t\t\t\t\t\\\n+\t  && GET_CODE (XEXP (X, 0)) == SIGN_EXTEND\t\t\t\\\n+\t  && GET_CODE (XEXP (XEXP (X, 0), 0)) == MEM\t\t\t\\\n+\t  && (GET_MODE (XEXP (XEXP (X, 0), 0)) == HImode\t\t\\\n+\t      || GET_MODE (XEXP (XEXP (X, 0), 0)) == QImode)\t\t\\\n+\t  && (REG_P (XEXP (XEXP (XEXP (X, 0), 0), 0))\t\t\t\\\n+\t      || (GET_CODE (XEXP (XEXP (XEXP (X, 0), 0), 0))\t\t\\\n+\t\t  == POST_INC\t\t\t\t\t\t\\\n+\t\t  && REG_P (XEXP (XEXP (XEXP (XEXP (X, 0), 0), 0),\t\\\n+\t\t\t\t  0)))))\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  int something_reloaded = 0;\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (REGNO (XEXP (X, 1)) >= FIRST_PSEUDO_REGISTER)\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* Second reg is pseudo, reload it. */\t\t\t\\\n+\t      push_reload (XEXP (X, 1), NULL_RTX, &XEXP (X, 1), \t\\\n+\t\t\t   NULL,\t\t\t\t\t\\\n+\t\t\t   GENERAL_REGS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n+\t\t\t   OPNUM, TYPE);\t\t\t\t\\\n+\t      something_reloaded = 1;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (REG_P (XEXP (XEXP (X, 0), 0))\t\t\t\t\\\n+\t      && (REGNO (XEXP (XEXP (X, 0), 0))\t\t\t\t\\\n+\t\t  >= FIRST_PSEUDO_REGISTER))\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      /* First one is a pseudo - reload that. */\t\t\\\n+\t      push_reload (XEXP (XEXP (X, 0), 0), NULL_RTX,\t\t\\\n+\t\t\t   &XEXP (XEXP (X, 0), 0), NULL, \t\t\\\n+\t\t\t   GENERAL_REGS,\t\t\t\t\\\n+\t\t\t   GET_MODE (X), VOIDmode, 0, 0, OPNUM, TYPE);\t\\\n+\t      something_reloaded = 1;\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t  if (! something_reloaded\t\t\t\t\t\\\n+\t      || (GET_CODE (XEXP (XEXP (X, 0), 0)) == POST_INC\t\t\\\n+\t\t  && (REGNO (XEXP (XEXP (XEXP (X, 0), 0), 0))\t\t\\\n+\t\t      >= FIRST_PSEUDO_REGISTER)))\t\t\t\\\n+\t    /* Reload the sign_extend.\tHappens if neither reg is a\t\\\n+\t       pseudo, or the first one was inside post_increment.  */\t\\\n+\t    push_reload (XEXP (X, 0), NULL_RTX, &XEXP (X, 0), NULL,\t\\\n+\t\t\t GENERAL_REGS, GET_MODE (X), VOIDmode, 0, 0,\t\\\n+\t\t\t OPNUM, TYPE);\t\t\t\t\t\\\n+\t  goto WIN;\t\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* In CRIS, only the postincrement address mode depends thus,\n+   since the increment depends on the size of the operand.  */\n+#define GO_IF_MODE_DEPENDENT_ADDRESS(ADDR, LABEL)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      if (GET_CODE (ADDR) == POST_INC)\t\t\t\\\n+\tgoto LABEL;\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define LEGITIMATE_CONSTANT_P(X) 1\n+\n+\n+/* Node: Condition Code */\n+\n+#define NOTICE_UPDATE_CC(EXP, INSN) cris_notice_update_cc (EXP, INSN)\n+\n+/* FIXME: Maybe define CANONICALIZE_COMPARISON later, when playing with\n+   optimizations.  It is needed; currently we do this with instruction\n+   patterns and NOTICE_UPDATE_CC.  */\n+\n+\n+/* Node: Costs */\n+\n+#define CONST_COSTS(RTX, CODE, OUTER_CODE)\t\t\t\t\\\n+ case CONST_INT:\t\t\t\t\t\t\t\\\n+   if (INTVAL (RTX) == 0)\t\t\t\t\t\t\\\n+     return 0;\t\t\t\t\t\t\t\t\\\n+   if (INTVAL (RTX) < 32 && INTVAL (RTX) >= -32)\t\t\t\\\n+     return 1;\t\t\t\t\t\t\t\t\\\n+   /* Eight or 16 bits are a word and cycle more expensive.  */\t\t\\\n+   if (INTVAL (RTX) <= 32767 && INTVAL (RTX) >= -32768)\t\t\t\\\n+     return 2;\t\t\t\t\t\t\t\t\\\n+   /* A 32 bit constant (or very seldom, unsigned 16 bits) costs\t\\\n+      another word.  FIXME: This isn't linear to 16 bits.  */\t\t\\\n+   return 4;\t\t\t\t\t\t\t\t\\\n+ case LABEL_REF:\t\t\t\t\t\t\t\\\n+   return 6;\t\t\t\t\t\t\t\t\\\n+ case CONST:\t\t\t\t\t\t\t\t\\\n+ case SYMBOL_REF:\t\t\t\t\t\t\t\\\n+   /* For PIC, we need a prefix (if it isn't already there),\t\t\\\n+      and the PIC register.  For a global PIC symbol, we also need a\t\\\n+      read of the GOT.  */\t\t\t\t\t\t\\\n+   return\t\t\t\t\t\t\t\t\\\n+     flag_pic ? (cris_got_symbol (RTX) ? (2 + 4 + 6) : (2 + 6)) : 6;\t\\\n+ case CONST_DOUBLE:\t\t\t\t\t\t\t\\\n+   if (RTX != CONST0_RTX (GET_MODE (RTX) == VOIDmode ? DImode\t\t\\\n+\t\t\t  : GET_MODE (RTX)))\t\t\t\t\\\n+     return 12;\t\t\t\t\t\t\t\t\\\n+   /* Make 0.0 cheap, else test-insns will not be used.  */\t\t\\\n+   return 0;\n+\n+#define RTX_COSTS(X, CODE, OUTER_CODE)\t\t\t\t\t\\\n+ case MULT:\t\t\t\t\t\t\t\t\\\n+   /* Identify values that are no powers of two.  Powers of 2 are\t\\\n+      taken care of already and those values should not be\t\t\\\n+      changed.  */\t\t\t\t\t\t\t\\\n+   if (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n+       || exact_log2 (INTVAL (XEXP (X, 1)) < 0))\t\t\t\\\n+     {\t\t\t\t\t\t\t\t\t\\\n+\t/* If we have a multiply insn, then the cost is between\t\t\\\n+\t   1 and 2 \"fast\" instructions.  */\t\t\t\t\\\n+\tif (TARGET_HAS_MUL_INSNS)\t\t\t\t\t\\\n+\t  return COSTS_N_INSNS (1) + COSTS_N_INSNS (1) /2;\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+\t/* Estimate as 4 + 4 * #ofbits.  */\t\t\t\t\\\n+\treturn COSTS_N_INSNS (132);\t\t\t\t\t\\\n+     }\t\t\t\t\t\t\t\t\t\\\n+     break;\t\t\t\t\t\t\t\t\\\n+ case UDIV:\t\t\t\t\t\t\t\t\\\n+ case MOD:\t\t\t\t\t\t\t\t\\\n+ case UMOD:\t\t\t\t\t\t\t\t\\\n+ case DIV:\t\t\t\t\t\t\t\t\\\n+   if (GET_CODE (XEXP (X, 1)) != CONST_INT\t\t\t\t\\\n+       || exact_log2 (INTVAL (XEXP (X, 1)) < 0))\t\t\t\\\n+     /* Estimate this as 4 + 8 * #of bits.  */\t\t\t\t\\\n+     return COSTS_N_INSNS (260);\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+ case AND:\t\t\t\t\t\t\t\t\\\n+   if (GET_CODE (XEXP (X, 1)) == CONST_INT\t\t\t\t\\\n+       /* Two constants may actually happen before optimization.  */\t\\\n+       && GET_CODE (XEXP (X, 0)) != CONST_INT\t\t\t\t\\\n+       && !CONST_OK_FOR_LETTER_P (INTVAL (XEXP (X, 1)), 'I'))\t\t\\\n+     return\t\t\t\t\t\t\t\t\\\n+       rtx_cost (XEXP (X, 0), OUTER_CODE) + 2\t\t\t\t\\\n+       + 2 * GET_MODE_NUNITS (GET_MODE (XEXP (X, 0)));\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+ case ZERO_EXTEND: case SIGN_EXTEND:\t\t\t\t\t\\\n+   /* Same as move. If embedded in other insn, cost is 0.  */\t\t\\\n+   return rtx_cost (XEXP (X, 0), OUTER_CODE);\n+\n+#define ADDRESS_COST(X) cris_address_cost (X)\n+\n+/* FIXME: Need to define REGISTER_MOVE_COST when more register classes are\n+   introduced.  */\n+\n+/* This isn't strictly correct for v0..3 in buswidth-8bit mode, but\n+   should suffice.  */\n+#define MEMORY_MOVE_COST(M, CLASS, IN) \\\n+ (((M) == QImode) ? 4 : ((M) == HImode) ? 4 : 6)\n+\n+/* Regardless of the presence of delay slots, the default value of 1 for\n+   BRANCH_COST is the best in the range (1, 2, 3), tested with gcc-2.7.2\n+   with testcases ipps and gcc, giving smallest and fastest code.  */\n+\n+#define SLOW_BYTE_ACCESS 0\n+\n+/* This is the threshold *below* which inline move sequences of\n+   word-length sizes will be emitted.  The \"9\" will translate to\n+   (9 - 1) * 4 = 32 bytes maximum moved, but using 16 instructions\n+   (8 instruction sequences) or less.  */\n+#define MOVE_RATIO 9\n+\n+\n+/* Node: Sections */\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.text\"\n+\n+#define DATA_SECTION_ASM_OP \"\\t.data\"\n+\n+#define FORCE_EH_FRAME_INFO_IN_DATA_SECTION (! TARGET_ELF)\n+\n+/* The jump table is immediately connected to the preceding insn.  */\n+#define JUMP_TABLES_IN_TEXT_SECTION 1\n+\n+/* We need to code in PIC-specific flags into SYMBOL_REF_FLAG.  */\n+\n+#define ENCODE_SECTION_INFO(EXP) cris_encode_section_info (EXP)\n+\n+/* We pull a little trick to register the _fini function with atexit,\n+   after (presumably) registering the eh frame info, since we don't handle\n+   _fini (a.k.a. ___fini_start) in crt0 or have a crti for \"pure\" ELF.  */\n+#ifdef CRT_BEGIN\n+#define FORCE_INIT_SECTION_ALIGN\t\t\\\n+ do\t\t\t\t\t\t\\\n+   {\t\t\t\t\t\t\\\n+     extern void __fini__start (void);\t\t\\\n+     atexit (__fini__start);\t\t\t\\\n+   }\t\t\t\t\t\t\\\n+ while (0)\n+#endif\n+\n+/* Node: PIC */\n+\n+#define PIC_OFFSET_TABLE_REGNUM 0\n+\n+#define LEGITIMATE_PIC_OPERAND_P(X) cris_legitimate_pic_operand (X)\n+\n+\n+/* Node: File Framework */\n+\n+/* NO_APP *only at file start* means faster assembly.\n+   It also means comments are not allowed.\n+   In some cases comments will be output for debugging purposes.\n+   Make sure they are allowed then.  */\n+/* Override previous definitions (elfos.h).  */\n+#undef ASM_FILE_START\n+#define ASM_FILE_START(STREAM)\t\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      if (TARGET_PDEBUG || flag_print_asm_name)\t\t\t\\\n+\tfprintf ((STREAM), \"#APP\\n\");\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\\\n+\tfprintf ((STREAM), \"#NO_APP\\n\");\t\t\t\\\n+      if (TARGET_ELF)\t\t\t\t\t\t\\\n+\toutput_file_directive ((STREAM), main_input_filename);\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Override previous definitions (elfos.h).  */\n+#undef ASM_FILE_END\n+#define ASM_FILE_END(STREAM)\n+\n+/* We don't want an .ident for gcc.  To avoid that but still support\n+   #ident, we override ASM_OUTPUT_IDENT and, since the gcc .ident is its\n+   only use besides ASM_OUTPUT_IDENT, undef IDENT_ASM_OP from elfos.h.  */\n+#undef IDENT_ASM_OP\n+#undef ASM_OUTPUT_IDENT\n+#define ASM_OUTPUT_IDENT(FILE, NAME) \\\n+  fprintf (FILE, \"%s\\\"%s\\\"\\n\", \"\\t.ident\\t\", NAME);\n+\n+#define ASM_APP_ON \"#APP\\n\"\n+\n+#define ASM_APP_OFF \"#NO_APP\\n\"\n+\n+\n+/* Node: Data Output */\n+\n+/* We must use REAL_VALUE_TO_TARGET_SINGLE and\n+   REAL_VALUE_TO_TARGET_LONG_DOUBLE.  It seems real.h cannot support when\n+   target-double is target-single is 32bit-single.  */\n+#define ASM_OUTPUT_LONG_DOUBLE(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      long l[2];\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_LONG_DOUBLE (VALUE, l);\t\\\n+      fprintf (FILE, \"\\t.dword 0x%lx\\n\", l[0]);\t\t\\\n+      fprintf (FILE, \"\\t.dword 0x%lx\\n\", l[1]);\t\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* FIXME: The manual says \"array of long:s\", but\n+   REAL_VALUE_TO_TARGET_SINGLE actually writes a long.  */\n+#define ASM_OUTPUT_FLOAT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      long l;\t\t\t\t\t\\\n+      REAL_VALUE_TO_TARGET_SINGLE (VALUE, l);\t\\\n+      fprintf (FILE, \"\\t.dword 0x%lx\\n\", l);\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* This is what is used by gcc for 64-bit floats,\n+   not the \"long double\" one. */\n+#define ASM_OUTPUT_DOUBLE(FILE, VALUE) \\\n+ ASM_OUTPUT_LONG_DOUBLE (FILE, VALUE)\n+\n+\n+/* This is a kludge for a.out+ELF support: For non-ELF prioritized\n+   [cd]tors, globalize the function so collect2 can collect it.  This is\n+   due to short-sightedness guided by defined (ASM_OUTPUT_SECTION_NAME)\n+   && defined (ASM_OUTPUT_CONSTRUCTOR).  */\n+\n+#define ASM_OUTPUT_INT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.dword \");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_SHORT(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.word \");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_CHAR(FILE, VALUE)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fprintf (FILE, \"\\t.byte \");\t\t\\\n+      output_addr_const (FILE, (VALUE));\t\\\n+      fprintf (FILE, \"\\n\");\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_BYTE(FILE, VALUE)  \\\n+ fprintf (FILE, \"\\t.byte 0x%x\\n\", (VALUE))\n+\n+#define IS_ASM_LOGICAL_LINE_SEPARATOR(C) (C) == '@'\n+\n+/* FIXME: These are undocumented. */\n+/* We need to define these, since the 2byte, 4byte, 8byte op:s are only\n+   available in ELF.  These \"normal\" pseudos do not have any alignment\n+   constraints or side-effects.  */\n+#undef UNALIGNED_SHORT_ASM_OP\n+#define UNALIGNED_SHORT_ASM_OP \"\\t.word\\t\"\n+\n+#undef INT_ASM_OP\n+#define INT_ASM_OP \"\\t.dword\\t\"\n+\n+#undef UNALIGNED_INT_ASM_OP\n+#define UNALIGNED_INT_ASM_OP \"\\t.dword\\t\"\n+\n+#undef UNALIGNED_DOUBLE_INT_ASM_OP\n+#define UNALIGNED_DOUBLE_INT_ASM_OP \"\\t.quad\\t\"\n+\n+/* Node: Uninitialized Data */\n+\n+/* Remember to round off odd values if we want data alignment,\n+   since we cannot do that with an .align directive.\n+\n+   Using .comm causes the space not to be reserved in .bss, but by\n+   tricks with the symbol type.  Not good if other tools than binutils\n+   are used on the object files.  Since \".global ... .lcomm ...\" works, we\n+   use that.  Use .._ALIGNED_COMMON, since gcc whines when we only have\n+   ..._COMMON, and we prefer to whine outselves; BIGGEST_ALIGNMENT is not\n+   the one to check.  This done for a.out only.  */\n+/* FIXME: I suspect a bug in gcc with alignment.  Do not warn until\n+   investigated; it mucks up the testsuite results.  */\n+#define CRIS_ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN, LOCAL) \\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      int align_ = (ALIGN) / BITS_PER_UNIT;\t\t\t\t\\\n+      if (TARGET_DATA_ALIGN && TARGET_ALIGN_BY_32 && align_ < 4)\t\\\n+\talign_ = 4;\t\t\t\t\t\t\t\\\n+      else if (TARGET_DATA_ALIGN && align_ < 2)\t\t\t\t\\\n+\talign_ = 2;\t\t\t\t\t\t\t\\\n+      /* FIXME: Do we need this?  */\t\t\t\t\t\\\n+      else if (align_ < 1)\t\t\t\t\t\t\\\n+\talign_ = 1;\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\t\\\n+      if (TARGET_ELF)\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  if (LOCAL)\t\t\t\t\t\t\t\\\n+\t    {\t\t\t\t\t\t\t\t\\\n+\t      fprintf ((FILE), \"%s\", LOCAL_ASM_OP);\t\t\t\\\n+\t      assemble_name ((FILE), (NAME));\t\t\t\t\\\n+\t      fprintf ((FILE), \"\\n\");\t\t\t\t\t\\\n+\t    }\t\t\t\t\t\t\t\t\\\n+\t  fprintf ((FILE), \"%s\", COMMON_ASM_OP);\t\t\t\\\n+\t  assemble_name ((FILE), (NAME));\t\t\t\t\\\n+\t  fprintf ((FILE), \",%u,%u\\n\", (SIZE), align_);\t\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+      else\t\t\t\t\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\t\\\n+\t  /* We can't tell a one-only or weak COMM from a \"global\t\\\n+\t     COMM\" so just make all non-locals weak.  */\t\t\\\n+\t  if (! (LOCAL))\t\t\t\t\t\t\\\n+\t    ASM_WEAKEN_LABEL (FILE, NAME);\t\t\t\t\\\n+\t  fputs (\"\\t.lcomm \", (FILE));\t\t\t\t\t\\\n+\t  assemble_name ((FILE), (NAME));\t\t\t\t\\\n+\t  fprintf ((FILE), \",%u\\n\",\t\t\t\t\t\\\n+\t\t   ((SIZE) + (align_ - 1)) & ~(align_ - 1));\t\t\\\n+\t}\t\t\t\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN) \\\n+ CRIS_ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN, 0)\n+\n+#undef ASM_OUTPUT_ALIGNED_DECL_LOCAL\n+#define ASM_OUTPUT_ALIGNED_DECL_LOCAL(FILE, DECL, NAME, SIZE, ALIGN) \\\n+ CRIS_ASM_OUTPUT_ALIGNED_DECL_COMMON(FILE, DECL, NAME, SIZE, ALIGN, 1)\n+\n+/* FIXME: define ASM_OUTPUT_SHARED_COMMON and emit an error when it is\n+   used with -melinux and a.out.  */\n+\n+/* Node: Label Output */\n+\n+#define ASM_OUTPUT_LABEL(FILE, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      assemble_name (FILE, NAME);\t\t\\\n+      fputs (\":\\n\", FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define ASM_GLOBALIZE_LABEL(FILE, NAME)\t\t\\\n+  do\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\\\n+      fputs (\"\\t.global \", FILE);\t\t\\\n+      assemble_name (FILE, NAME);\t\t\\\n+      fputs (\"\\n\", FILE);\t\t\t\\\n+    }\t\t\t\t\t\t\\\n+  while (0)\n+\n+#define SUPPORTS_WEAK 1\n+\n+/* FIXME: This macro isn't documented, but this would probably be an\n+   appropriate location.  It's only used in crtstuff.c, else we'd have to\n+   handle (to #undef or ignore it) in a.out.  */\n+#define HAVE_GAS_HIDDEN 1\n+\n+#undef  ASM_OUTPUT_INTERNAL_LABEL\n+#define ASM_OUTPUT_INTERNAL_LABEL(FILE, PREFIX, NUM)\t\\\n+  do\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\\\n+      asm_fprintf (FILE, \"%L%s%d:\\n\", PREFIX, NUM);\t\\\n+    }\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+/* Remove any previous definition (elfos.h).  */\n+#undef ASM_GENERATE_INTERNAL_LABEL\n+#define ASM_GENERATE_INTERNAL_LABEL(LABEL, PREFIX, NUM)\t\\\n+  sprintf (LABEL, \"*%s%s%ld\", LOCAL_LABEL_PREFIX, PREFIX, (long) NUM)\n+\n+#define ASM_FORMAT_PRIVATE_NAME(OUTPUT, NAME, LABELNO)\t\t\\\n+  do\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      (OUTPUT) = (char *) alloca (strlen ((NAME)) + 10);\t\\\n+      sprintf ((OUTPUT), \"%s.%d\", (NAME), (LABELNO));\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Initialization */\n+/* (no definitions) */\n+\n+/* Node: Macros for Initialization */\n+\n+/* We don't want to use \"strip\" for anything linked with \"-melinux\"\n+   \"-shlib\", seen by the linker as \"-Ur -d -Bdynamic\" in combination.  */\n+#define SET_STRIPPABLE_EXECUTABLE(DS, ARGC, ARGV)\t\t\\\n+  do \t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      int i;\t\t\t\t\t\t\t\\\n+      int flags = 0;\t\t\t\t\t\t\\\n+      for (i = (ARGC) - 1; i > 0; i--)\t\t\t\t\\\n+\t{\t\t\t\t\t\t\t\\\n+\t  if (strcmp ((ARGV)[i], \"-Ur\") == 0)\t\t\t\\\n+\t    flags |= 1;\t\t\t\t\t\t\\\n+\t  else if (strcmp ((ARGV)[i], \"-d\") == 0)\t\t\\\n+\t    flags |= 2;\t\t\t\t\t\t\\\n+\t  else if (strcmp ((ARGV)[i], \"-Bdynamic\") == 0)\t\\\n+\t    flags |= 4;\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+\t  if (flags == 7)\t\t\t\t\t\\\n+\t    break;\t\t\t\t\t\t\\\n+\t}\t\t\t\t\t\t\t\\\n+\t\t\t\t\t\t\t\t\\\n+      (DS) = (flags != 7);\t\t\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Instruction Output */\n+\n+#define REGISTER_NAMES\t\t\t\t\t\\\n+ {\"r0\", \"r1\", \"r2\", \"r3\", \"r4\", \"r5\", \"r6\", \"r7\", \"r8\",\t\\\n+  \"r9\", \"r10\", \"r11\", \"r12\", \"r13\", \"sp\", \"pc\", \"srp\", \"faked_ap\"}\n+\n+#define ADDITIONAL_REGISTER_NAMES \\\n+ {{\"r14\", 14}, {\"r15\", 15}}\n+\n+#define PRINT_OPERAND(FILE, X, CODE)\t\t\\\n+ cris_print_operand (FILE, X, CODE)\n+\n+/* For delay-slot handling.  */\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) (CODE == '#')\n+\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)\t\\\n+   cris_print_operand_address (FILE, ADDR)\n+\n+/* Output an empty line to illustrate the presence of the delay slot.  */\n+#define DBR_OUTPUT_SEQEND(FILE) \\\n+  fprintf (FILE, \"\\n\")\n+\n+#define LOCAL_LABEL_PREFIX (TARGET_ELF ? \".\" : \"\")\n+\n+/* cppinit.c initializes a const array from this, so it must be constant,\n+   can't have it different based on options.  Luckily, the prefix is\n+   always allowed, so let's have it on all GCC-generated code.  Note that\n+   we have this verbatim everywhere in the back-end, not using %R or %s or\n+   such.  */\n+#define REGISTER_PREFIX \"$\"\n+\n+/* Remove any previous definition (elfos.h).  */\n+/* We use -fno-leading-underscore to remove it, when necessary.  */\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"_\"\n+\n+#define ASM_OUTPUT_REG_PUSH(FILE, REGNO) \\\n+  fprintf (FILE, \"\\tpush $%s\\n\", reg_names[REGNO])\n+\n+#define ASM_OUTPUT_REG_POP(FILE, REGNO) \\\n+  fprintf (FILE, \"\\tpop $%s\\n\", reg_names[REGNO])\n+\n+\n+/* Node: Dispatch Tables */\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL)\t\\\n+  asm_fprintf (FILE, \"\\t.word %LL%d-%LL%d\\n\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE)  \\\n+  asm_fprintf (FILE, \"\\t.dword %LL%d\\n\", VALUE)\n+\n+/* Defined to also emit an .align in elfos.h.  We don't want that.  */\n+#undef ASM_OUTPUT_CASE_LABEL\n+\n+/* Since the \"bound\" insn loads the comparison value if the compared<\n+   value (register) is out of bounds (0..comparison value-1), we need\n+   to output another case to catch it.\n+   The way to find it is to look for the label_ref at the else-arm inside\n+   the expanded casesi core-insn.\n+   FIXME: Check this construct when changing to new version of gcc.  */\n+#define ASM_OUTPUT_CASE_END(STREAM, NUM, TABLE)\t\t\t\t\\\n+  do\t\t\t\t\t\t\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\t\\\n+      asm_fprintf (STREAM, \"\\t.word %LL%d-%LL%d%s\\n\",\t\t\t\\\n+\t\t   CODE_LABEL_NUMBER\t\t\t\t\t\\\n+\t\t    (XEXP (XEXP (XEXP\t\t\t\t\t\\\n+\t\t\t\t  (XVECEXP\t\t\t\t\\\n+\t\t\t\t    (PATTERN (PREV_INSN (PREV_INSN\t\\\n+\t\t\t\t\t\t\t  (TABLE))),\t\\\n+\t\t\t\t     0, 0), 1), 2), 0)),\t\t\\\n+\t\t   NUM,\t\t\t\t\t\t\t\\\n+\t\t   (TARGET_PDEBUG ? \"; default\" : \"\"));\t\t\t\\\n+    }\t\t\t\t\t\t\t\t\t\\\n+  while (0)\n+\n+\n+/* Node: Exception Region Output */\n+/* (no definitions) */\n+/* FIXME: Fill in with our own optimized layout.  */\n+\n+/* Node: Alignment Output */\n+\n+#define ASM_OUTPUT_ALIGN(FILE, LOG)  \\\n+ fprintf (FILE, \"\\t.align %d\\n\", (LOG))\n+\n+\n+/* Node: All Debuggers */\n+\n+#define DBX_REGISTER_NUMBER(REGNO) \\\n+ ((REGNO) == CRIS_SRP_REGNUM ? CRIS_CANONICAL_SRP_REGNUM : (REGNO))\n+\n+/* FIXME: Investigate DEBUGGER_AUTO_OFFSET, DEBUGGER_ARG_OFFSET.  */\n+\n+\n+/* Node: DBX Options */\n+\n+/* Is this correct? Check later. */\n+#define DBX_NO_XREFS\n+\n+#define DBX_CONTIN_LENGTH 0\n+\n+/* FIXME: Is this needed when we have 0 DBX_CONTIN_LENGTH?  */\n+#define DBX_CONTIN_CHAR '?'\n+\n+\n+/* Node: DBX Hooks */\n+/* (no definitions) */\n+\n+/* Node: File names and DBX */\n+/* (no definitions) */\n+\n+\n+/* Node: SDB and DWARF */\n+\n+#define DWARF_LINE_MIN_INSTR_LENGTH 2\n+\n+\n+/* Node: Cross-compilation */\n+#define REAL_ARITHMETIC\n+\n+\n+/* Node: Misc */\n+\n+/* FIXME: Check this one more time.  */\n+#define PREDICATE_CODES\t\t\t\t\t\\\n+ {\"cris_orthogonal_operator\",\t\t\t\t\\\n+  {PLUS, MINUS, IOR, AND, UMIN}},\t\t\t\\\n+ {\"cris_commutative_orth_op\",\t\t\t\t\\\n+  {PLUS, IOR, AND, UMIN}},\t\t\t\t\\\n+ {\"cris_operand_extend_operator\",\t\t\t\\\n+  {PLUS, MINUS, UMIN}},\t\t\t\t\t\\\n+ {\"cris_extend_operator\",\t\t\t\t\\\n+  {ZERO_EXTEND, SIGN_EXTEND}},\t\t\t\t\\\n+ {\"cris_plus_or_bound_operator\",\t\t\t\\\n+  {PLUS, UMIN}},\t\t\t\t\t\\\n+ {\"cris_bdap_operand\",\t\t\t\t\t\\\n+  {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n+   CONST_DOUBLE, CONST, SIGN_EXTEND}},\t\t\t\\\n+ {\"cris_bdap_biap_operand\",\t\t\t\t\\\n+  {SUBREG, REG, LABEL_REF, SYMBOL_REF, MEM, CONST_INT,\t\\\n+   CONST_DOUBLE, CONST, SIGN_EXTEND, MULT}},\t\t\\\n+ {\"cris_general_operand_or_gotless_symbol\",\t\t\\\n+  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n+   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n+ {\"cris_general_operand_or_symbol\",\t\t\t\\\n+  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n+   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n+ {\"cris_general_operand_or_plt_symbol\",\t\t\t\\\n+  {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\t\\\n+   LABEL_REF, SUBREG, REG, MEM}},\t\t\t\\\n+ {\"cris_mem_call_operand\",\t\t\t\t\\\n+  {MEM}},\n+\n+/* A combination of the bound (umin) insn together with a\n+   sign-extended add via the table to PC seems optimal.\n+   If the table overflows, the assembler will take care of it.\n+   Theoretically, in extreme cases (uncertain if they occur), an error\n+   will be emitted, so FIXME: Check how large case-tables are emitted,\n+   possible add an option to emit SImode case-tables.  */\n+#define CASE_VECTOR_MODE HImode\n+\n+#define CASE_VECTOR_PC_RELATIVE 1\n+\n+/* FIXME: Investigate CASE_VECTOR_SHORTEN_MODE to make sure HImode is not\n+   used when broken-.word could possibly fail (plus test-case).  */\n+\n+#define IMPLICIT_FIX_EXPR FIX_ROUND_EXPR\n+\n+#define FIXUNS_TRUNC_LIKE_FIX_TRUNC\n+\n+#define EASY_DIV_EXPR TRUNC_DIV_EXPR\n+\n+/* This is the number of bytes that can be moved in one\n+   reasonably fast instruction sequence.  For CRIS, this is two\n+   instructions: mem => reg, reg => mem.  */\n+#define MOVE_MAX 4\n+\n+/* Maybe SHIFT_COUNT_TRUNCATED is safe to define?  FIXME: Check later.  */\n+\n+#define TRULY_NOOP_TRUNCATION(OUTPREC, INPREC) 1\n+\n+#define STORE_FLAG_VALUE 1\n+\n+#define Pmode SImode\n+\n+#define FUNCTION_MODE QImode\n+\n+#define NO_IMPLICIT_EXTERN_C\n+\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "3df8aaabef3741e088eacf5d8942f9024b9fcf71", "filename": "gcc/config/cris/cris.md", "status": "added", "additions": 5096, "deletions": 0, "changes": 5096, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris.md?ref=0b85d8165e0d39b555274fc776589d2abccfcf55"}, {"sha": "a30d2052f5379b3cc951aa860fe0e824edadb836", "filename": "gcc/config/cris/cris_abi_symbol.c", "status": "added", "additions": 56, "deletions": 0, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris_abi_symbol.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fcris_abi_symbol.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fcris_abi_symbol.c?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,56 @@\n+/* Define symbol to recognize CRIS ABI version 2, for a.out use.\n+   Contributed by Axis Communications.\n+   Written by Hans-Peter Nilsson <hp@axis.se>, c:a 1992.\n+\n+   Copyright (C) 2000, 2001 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it\n+under the terms of the GNU General Public License as published by the\n+Free Software Foundation; either version 2, or (at your option) any\n+later version.\n+\n+In addition to the permissions in the GNU General Public License, the\n+Free Software Foundation gives you unlimited permission to link the\n+compiled version of this file with other programs, and to distribute\n+those programs without any restriction coming from the use of this\n+file.  (The General Public License restrictions do apply in other\n+respects; for example, they cover modification of the file, and\n+distribution when not linked into another program.)\n+\n+This file is distributed in the hope that it will be useful, but\n+WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU\n+General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with this program; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.\n+\n+   As a special exception, if you link this library with files, some of\n+   which are compiled with GCC, this library does not by itself cause\n+   the resulting object or executable to be covered by the GNU General\n+   Public License.\n+   This exception does not however invalidate any other reasons why\n+   the executable file or object might be covered by the GNU General\n+   Public License.  */\n+\n+#include \"config.h\"\n+\n+#ifdef __AOUT__\n+\n+/* ELF support was not released before the ABI was changed, so we\n+   restrict this awkwardness to a.out.  This symbol is for gdb to\n+   recognize, so it can debug both old and new programs successfully.  */\n+__asm__ (\".global \" CRIS_ABI_VERSION_SYMBOL_STRING);\n+__asm__ (\".set \" CRIS_ABI_VERSION_SYMBOL_STRING \",0\");\n+\n+#else  /* not __AOUT__ */\n+\n+/* The file must not be empty (declaration/definition-wise) according to\n+   ISO, IIRC. */\n+extern int _Dummy;\n+\n+#endif /* not __AOUT__ */"}, {"sha": "b02e19e2a41e57312f508c792fb98b9bb9498551", "filename": "gcc/config/cris/linux.h", "status": "added", "additions": 134, "deletions": 0, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Flinux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Flinux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Flinux.h?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,134 @@\n+/* Definitions for GCC.  Part of the machine description for CRIS.\n+   Copyright (C) 2001 Free Software Foundation, Inc.\n+   Contributed by Axis Communications.  Written by Hans-Peter Nilsson.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 2, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING.  If not, write to\n+the Free Software Foundation, 59 Temple Place - Suite 330,\n+Boston, MA 02111-1307, USA.  */\n+\n+\n+/* After the first \"Node:\" comment comes all preprocessor directives and\n+   attached declarations described in the info files, the \"Using and\n+   Porting GCC\" manual (uapgcc), in the same order as found in the \"Target\n+   macros\" section in the gcc-2.9x CVS edition of 2000-03-17.  FIXME: Not\n+   really, but needs an update anyway.\n+\n+   There is no generic copy-of-uapgcc comment, you'll have to see uapgcc\n+   for that.  If applicable, there is a CRIS-specific comment.  The order\n+   of macro definitions follow the order in the manual.  Every section in\n+   the manual (node in the info pages) has an introductory `Node:\n+   <subchapter>' comment.  If no macros are defined for a section, only\n+   the section-comment is present.  */\n+\n+/* This file defines the macros for cris-axis-linux-gnu that are not\n+   covered by cris.h, elfos.h and (config/)linux.h.  */\n+\n+\n+/* Node: Instruction Output */\n+\n+#undef USER_LABEL_PREFIX\n+#define USER_LABEL_PREFIX \"\"\n+\n+/* Node: Driver */\n+/* These macros are CRIS-specific, but used in target driver macros.  */\n+\n+#undef CRIS_CPP_SUBTARGET_SPEC\n+#define CRIS_CPP_SUBTARGET_SPEC \\\n+  \"-D__linux__ -D__unix__  -D__ELF__\\\n+   %{pthread:-D_REENTRANT}\\\n+   %{fPIC|fpic: -D__PIC__ -D__pic__}\\\n+   %{!fleading-underscore:-fno-leading-underscore -D__NO_UNDERSCORES__}\\\n+   %{!march=*:%{!cpu=*:-D__arch_v10 -D__CRIS_arch_version=10}}\\\n+   %{!ansi:%{!std=*:%{!undef:-Dlinux -Dunix}\\\n+     -Asystem(unix) -Asystem(posix) -Acpu(cris) -Amachine(cris)}}\"\n+\n+#undef CRIS_CC1_SUBTARGET_SPEC\n+#define CRIS_CC1_SUBTARGET_SPEC \\\n+ \"%{!march=*:%{!cpu=*:-march=v10}}\"\n+\n+#undef CRIS_ASM_SUBTARGET_SPEC\n+#define CRIS_ASM_SUBTARGET_SPEC \\\n+ \"--em=criself\\\n+  %{!fleading-underscore:--no-underscore}\\\n+  %{fPIC|fpic: --pic}\"\n+\n+/* Provide a legacy -mlinux option.  */\n+#undef CRIS_SUBTARGET_SWITCHES\n+#define CRIS_SUBTARGET_SWITCHES\t\t\t\t\t\t\\\n+ {\"linux\",\t\t\t\t 0, \"\"},\t\t\t\\\n+ {\"gotplt\",\t -TARGET_MASK_AVOID_GOTPLT, \"\"},\t\t\t\\\n+ {\"no-gotplt\",\t  TARGET_MASK_AVOID_GOTPLT,\t\t\t\t\\\n+  N_(\"Together with -fpic and -fPIC, do not use GOTPLT references\")},\n+\n+#undef CRIS_SUBTARGET_DEFAULT\n+#define CRIS_SUBTARGET_DEFAULT\t\t\t\\\n+  (TARGET_MASK_SVINTO\t\t\t\t\\\n+   + TARGET_MASK_ETRAX4_ADD\t\t\t\\\n+   + TARGET_MASK_ALIGN_BY_32\t\t\t\\\n+   + TARGET_MASK_ELF\t\t\t\t\\\n+   + TARGET_MASK_LINUX)\n+\n+#undef CRIS_DEFAULT_CPU_VERSION\n+#define CRIS_DEFAULT_CPU_VERSION CRIS_CPU_NG\n+\n+#undef CRIS_SUBTARGET_VERSION\n+#define CRIS_SUBTARGET_VERSION \" - cris-axis-linux-gnu\"\n+\n+\n+/* Redefine what was in svr4.h.  Include order madness makes it less\n+   useful to include (config/)linux.h after cris.h.  (config/)linux.h\n+   includes svr4.h which undef:s lots of supposedly arch-specific macros\n+   carefully defined by cris.h.  */\n+#undef LIB_SPEC\n+#define LIB_SPEC \"%{!shared:%{!symbolic:-lc}}\"\n+\n+/* We need an -rpath-link to ld.so.1, and presumably to each directory\n+   specified with -B.  */\n+#undef CRIS_LINK_SUBTARGET_SPEC\n+#define CRIS_LINK_SUBTARGET_SPEC \\\n+ \"-mcrislinux\\\n+  -rpath-link include/asm/../..%s\\\n+  %{shared} %{static}\\\n+  %{symbolic:-Bdynamic} %{shlib:-Bdynamic} %{static:-Bstatic}\\\n+  %{!shared:%{!static:%{rdynamic:-export-dynamic}}}\\\n+  %{O2|O3: --gc-sections}\"\n+\n+#undef STARTFILE_SPEC\n+#define STARTFILE_SPEC \\\n+ \"%{!shared:\\\n+   %{pg:gcrt1.o%s}\\\n+   %{!pg:\\\n+    %{p:gcrt1.o%s}\\\n+    %{!p:\\\n+     %{profile:gcrt1.o%s}\\\n+     %{!profile:crt1.o%s}}}}\\\n+  crti.o%s\\\n+  %{!shared:crtbegin.o%s}\\\n+  %{shared:crtbeginS.o%s}\"\n+\n+\n+/* Node: Sections */\n+\n+/* GNU/Linux has crti and crtn and does not need the\n+   FORCE_INIT_SECTION_ALIGN trick in cris.h.  */\n+#undef FORCE_INIT_SECTION_ALIGN\n+\n+/*\n+ * Local variables:\n+ * eval: (c-set-style \"gnu\")\n+ * indent-tabs-mode: t\n+ * End:\n+ */"}, {"sha": "3c482e7f2a96326ba74d02efc78c8481be5297b3", "filename": "gcc/config/cris/mulsi3.asm", "status": "added", "additions": 227, "deletions": 0, "changes": 227, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fmulsi3.asm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Fmulsi3.asm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Fmulsi3.asm?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,227 @@\n+;; This code used to be expanded through interesting expansions in\n+;; the machine description, compiled from this code:\n+;;\n+;; #ifdef L_mulsi3\n+;; long __Mul (unsigned long a, unsigned long b) __attribute__ ((__const__));\n+;; \n+;; /* This must be compiled with the -mexpand-mul flag, to synthesize the\n+;;    multiplication from the mstep instructions.  The check for\n+;;    smaller-size multiplication pays off in the order of .5-10%;\n+;;    estimated median 1%, depending on application.\n+;;     FIXME: It can be further optimized if we go to assembler code, as\n+;;    gcc 2.7.2 adds a few unnecessary instructions and does not put the\n+;;    basic blocks in optimal order.  */\n+;; long\n+;; __Mul (unsigned long a, unsigned long b)\n+;; {\n+;; #if defined (__CRIS_arch_version) && __CRIS_arch_version >= 10\n+;;   /* In case other code is compiled without -march=v10, they will\n+;; \tcontain calls to __Mul, regardless of flags at link-time.  The\n+;; \t\"else\"-code below will work, but is unnecessarily slow.  This\n+;; \tsometimes cuts a few minutes off from simulation time by just\n+;; \treturning a \"mulu.d\".  */\n+;;   return a * b;\n+;; #else\n+;;   unsigned long min;\n+;; \n+;;   /* Get minimum via the bound insn.  */\n+;;   min = a < b ? a : b;\n+;; \n+;;   /* Can we omit computation of the high part?\t*/\n+;;   if (min > 65535)\n+;;     /* No.  Perform full multiplication.  */\n+;;     return a * b;\n+;;   else\n+;;     {\n+;; \t /* Check if both operands are within 16 bits.  */\n+;; \t unsigned long max;\n+;; \n+;; \t /* Get maximum, by knowing the minimum.\n+;; \t    This will partition a and b into max and min.\n+;; \t    This is not currently something GCC understands,\n+;; \t    so do this trick by asm.  */\n+;; \t __asm__ (\"xor %1,%0\\n\\txor %2,%0\"\n+;; \t\t  : \"=r\" (max)\n+;; \t\t  :  \"r\" (b), \"r\" (a), \"0\" (min));\n+;; \n+;;     if (max > 65535)\n+;; \t /* Make GCC understand that only the low part of \"min\" will be\n+;; \t    used.  */\n+;; \t return max * (unsigned short) min;\n+;;     else\n+;; \t /* Only the low parts of both operands are necessary.  */\n+;; \t return ((unsigned short) max) * (unsigned short) min;\n+;;     }\n+;; #endif /* not __CRIS_arch_version >= 10 */\n+;; }\n+;; #endif /* L_mulsi3 */\n+;;\n+;; That approach was abandoned since the caveats outweighted the\n+;; benefits.  The expand-multiplication machinery is also removed, so you\n+;; can't do this anymore.\n+;;\n+;; For doubters of there being any benefits, some where: insensitivity to:\n+;; - ABI changes (mostly for experimentation)\n+;; - assembler syntax differences (mostly debug format).\n+;; - insn scheduling issues.\n+;; Most ABI experiments will presumably happen with arches with mul insns,\n+;; so that argument doesn't really hold anymore, and it's unlikely there\n+;; being new arch variants needing insn scheduling and not having mul\n+;; insns.\n+\n+;; ELF and a.out have different syntax for local labels: the \"wrong\"\n+;; one may not be omitted from the object.\n+#undef L\n+#ifdef __AOUT__\n+# define L(x) x\n+#else\n+# define L(x) .x\n+#endif\n+\n+\t.global ___Mul\n+\t.type\t___Mul,@function\n+___Mul:\n+#if defined (__CRIS_arch_version) && __CRIS_arch_version >= 10\n+\tret\n+\tmulu.d $r11,$r10\n+#else\n+\tmove.d $r10,$r12\n+\tmove.d $r11,$r9\n+\tbound.d $r12,$r9\n+\tcmpu.w 65535,$r9\n+\tbls L(L3)\n+\tmove.d $r12,$r13\n+\n+\tmovu.w $r11,$r9\n+\tlslq 16,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tmstep $r9,$r13\n+\tclear.w $r10\n+\ttest.d $r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmovu.w $r12,$r12\n+\tmove.d $r11,$r9\n+\tclear.w $r9\n+\ttest.d $r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tmstep $r12,$r9\n+\tadd.w $r9,$r10\n+\tlslq 16,$r10\n+\tret\n+\tadd.d $r13,$r10\n+\n+L(L3):\n+\tmove.d $r9,$r10\n+\txor $r11,$r10\n+\txor $r12,$r10\n+\tcmpu.w 65535,$r10\n+\tbls L(L5)\n+\tmovu.w $r9,$r13\n+\n+\tmovu.w $r13,$r13\n+\tmove.d $r10,$r9\n+\tlslq 16,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tmstep $r13,$r9\n+\tclear.w $r10\n+\ttest.d $r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tmstep $r13,$r10\n+\tlslq 16,$r10\n+\tret\n+\tadd.d $r9,$r10\n+\n+L(L5):\n+\tmovu.w $r9,$r9\n+\tlslq 16,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tmstep $r9,$r10\n+\tret\n+\tmstep $r9,$r10\n+#endif\n+L(Lfe1):\n+\t.size\t___Mul,L(Lfe1)-___Mul"}, {"sha": "a21052e42f0a6062cade4b51afd0bbd58c9f2310", "filename": "gcc/config/cris/t-aout", "status": "added", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-aout", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-aout", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-aout?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,12 @@\n+LIB2FUNCS_STATIC_EXTRA = \\\n+ tmpabi_symbol.c $(srcdir)/config/cris/mulsi3.asm\n+\n+MULTILIB_OPTIONS = melinux\n+MULTILIB_DIRNAMES = elinux\n+MULTILIB_EXTRA_OPTS = mbest-lib-options\n+\n+INSTALL_LIBGCC = install-multilib\n+LIBGCC = stmp-multilib\n+\n+tmpabi_symbol.c: $(srcdir)/config/cris/cris_abi_symbol.c\n+\tcp $(srcdir)/config/cris/cris_abi_symbol.c $@"}, {"sha": "5e7edf4d6d2246c19310ee0fb9f43a0987ab34fe", "filename": "gcc/config/cris/t-cris", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-cris", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-cris", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-cris?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,43 @@\n+#\n+# t-cris\n+#\n+# The Makefile fragment to include when compiling gcc et al for CRIS.\n+#\n+#\n+# The makefile macros etc. are included in the order found in the\n+# section \"Target Fragment\" in the gcc info-files (or the paper copy) of\n+# \"Using and Porting GCC\"\n+#\n+# Don't run fixproto\n+STMP_FIXPROTO =\n+\n+LIB2FUNCS_EXTRA = _udivsi3.c _divsi3.c _umodsi3.c _modsi3.c\n+CRIS_LIB1CSRC = $(srcdir)/config/cris/arit.c\n+\n+FPBIT = tmplibgcc_fp_bit.c\n+DPBIT = dp-bit.c\n+\n+dp-bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' > dp-bit.c\n+\tcat $(srcdir)/config/fp-bit.c           >> dp-bit.c\n+\n+# Use another name to avoid confusing SUN make, if support for\n+# it is reinstated elsewhere.  Prefixed with \"tmplibgcc\" means\n+# \"make clean\" will wipe it.  We define a few L_ thingies\n+# because we can't select them individually through FPBIT_FUNCS;\n+# see above.\n+tmplibgcc_fp_bit.c: $(srcdir)/config/fp-bit.c\n+\techo '#define FLOAT_BIT_ORDER_MISMATCH' >  $@\n+\techo '#define FLOAT'\t\t\t>> $@\n+\tcat $(srcdir)/config/fp-bit.c\t\t>> $@\n+\n+# The fixed-point arithmetic code is in one file, arit.c,\n+# similar to libgcc2.c (or the old libgcc1.c).  We need to\n+# \"split it up\" with one file per define.\n+$(LIB2FUNCS_EXTRA): $(CRIS_LIB1CSRC)\n+\tname=`echo $@ | sed -e 's,.*/,,' | sed -e 's,.c$$,,'`; \\\n+\techo \"#define L$$name\" > tmp-$@ \\\n+\t&& echo '#include \"$<\"' >> tmp-$@ \\\n+\t&& mv -f tmp-$@ $@\n+\n+TARGET_LIBGCC2_CFLAGS = -Dinhibit_libc"}, {"sha": "f4e4fcef64e3f39bccecb141bf32ed3eb284e904", "filename": "gcc/config/cris/t-elfmulti", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-elfmulti", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-elfmulti", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-elfmulti?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,16 @@\n+LIB2FUNCS_STATIC_EXTRA = $(srcdir)/config/cris/mulsi3.asm\n+EXTRA_MULTILIB_PARTS = crtbegin.o crtend.o\n+MULTILIB_OPTIONS = march=v10\n+MULTILIB_DIRNAMES = v10\n+MULTILIB_MATCHES = \\\n+\t\tmarch?v10=mcpu?etrax100lx \\\n+\t\tmarch?v10=mcpu?ng \\\n+\t\tmarch?v10=march?etrax100lx \\\n+\t\tmarch?v10=march?ng \\\n+\t\tmarch?v10=march?v11 \\\n+\t\tmarch?v10=mcpu?v11 \\\n+\t\tmarch?v10=mcpu?v10\n+MULTILIB_EXTRA_OPTS = mbest-lib-options\n+INSTALL_LIBGCC = install-multilib\n+LIBGCC = stmp-multilib\n+CRTSTUFF_T_CFLAGS = $(LIBGCC2_CFLAGS) -moverride-best-lib-options"}, {"sha": "43c3acd2ebbddc73dc5094c34a8e1a34870bc966", "filename": "gcc/config/cris/t-linux", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-linux", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fconfig%2Fcris%2Ft-linux", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fcris%2Ft-linux?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -0,0 +1,6 @@\n+TARGET_LIBGCC2_CFLAGS += -fPIC\n+CRTSTUFF_T_CFLAGS_S = $(TARGET_LIBGCC2_CFLAGS)\n+\n+# Override t-slibgcc-elf-ver to export some libgcc symbols with\n+# the symbol versions that glibc used.\n+SHLIB_MAPFILES += $(srcdir)/config/libgcc-glibc.ver"}, {"sha": "b4fbbae4c07652c18183dac70fabc2accd9d4d31", "filename": "gcc/doc/install.texi", "status": "modified", "additions": 39, "deletions": 0, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fdoc%2Finstall.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fdoc%2Finstall.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finstall.texi?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -1783,6 +1783,45 @@ can also be obtained from:\n @uref{http://www.elec.canterbury.ac.nz/c4x/,,http://www.elec.canterbury.ac.nz/c4x/}\n @end itemize\n \n+@html\n+</p>\n+<hr>\n+@end html\n+@heading @anchor{cris}CRIS\n+\n+CRIS is the CPU architecture in Axis Communications ETRAX system-on-a-chip\n+series.  These are used in embedded applications.\n+\n+@ifnothtml\n+@xref{CRIS Options,, CRIS Options, gcc, Using and Porting the GNU Compiler\n+Collection (GCC)},\n+@end ifnothtml\n+@ifhtml\n+See ``CRIS Options'' in the main manual\n+@end ifhtml\n+for a list of CRIS-specific options.\n+\n+There are a few different CRIS targets:\n+@table @code\n+@item cris-axis-aout\n+Old target.  Includes a multilib for the @samp{elinux} a.out-based\n+target.  No multilibs for newer architecture variants.\n+@item cris-axis-elf\n+Mainly for monolithic embedded systems.  Includes a multilib for the\n+@samp{v10} core used in @samp{ETRAX 100 LX}.\n+@item cris-axis-linux-gnu\n+A GNU/Linux port for the CRIS architecture, currently targeting\n+@samp{ETRAX 100 LX} by default.\n+@end table\n+\n+For @code{cris-axis-aout} and @code{cris-axis-elf} you need binutils 2.11\n+or newer.  For @code{cris-axis-linux-gnu} you need binutils 2.12 or newer.\n+\n+Pre-packaged tools can be obtained from\n+@uref{ftp://ftp.axis.com/pub/axis/tools/cris/compiler-kit/}.  More\n+information about this platform is available at\n+@uref{http://developer.axis.com/}.\n+\n @html\n </p>\n <hr>"}, {"sha": "cab5005f7523fdea3feb81a902816276aaf80d49", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 147, "deletions": 0, "changes": 147, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0b85d8165e0d39b555274fc776589d2abccfcf55/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=0b85d8165e0d39b555274fc776589d2abccfcf55", "patch": "@@ -588,6 +588,15 @@ in the following sections.\n -msmall-exec  -mno-small-exec  -mmvcle -mno-mvcle @gol\n -m64 -m31 -mdebug -mno-debug}\n \n+@emph{CRIS Options}\n+@gccoptlist{\n+-mcpu=@var{cpu} -march=@var{cpu} -mtune=@var{cpu} @gol\n+-mmax-stack-frame=@var{n} -melinux-stacksize=@var{n} @gol\n+-metrax4 -metrax100 -mpdebug -mcc-init -mno-side-effects @gol\n+-mstack-align -mdata-align -mconst-align @gol\n+-m32-bit -m16-bit -m8-bit -mno-prologue-epilogue -mno-gotplt @gol\n+-melf -maout -melinux -mlinux -sim -sim2}\n+\n @item Code Generation Options\n @xref{Code Gen Options,,Options for Code Generation Conventions}.\n @gccoptlist{\n@@ -5096,6 +5105,7 @@ that macro, which enables you to change the defaults.\n * IA-64 Options::\n * D30V Options::\n * S/390 and zSeries Options::\n+* CRIS Options::\n @end menu\n \n @node M680x0 Options\n@@ -9464,6 +9474,143 @@ The default is to not print debug information.\n \n @end table\n \n+@node CRIS Options\n+@subsection CRIS Options\n+@cindex CRIS Options\n+\n+These options are defined specifically for the CRIS ports.\n+\n+@table @gcctabopt\n+@item -march=@var{architecture-type}\n+@itemx -mcpu=@var{architecture-type}\n+@opindex march\n+@opindex mcpu\n+Generate code for the specified architecture.  The choices for\n+@var{architecture-type} are @samp{v3}, @samp{v8} and @samp{v10} for\n+respectively ETRAX@w{ }4, ETRAX@w{ }100, and ETRAX@w{ }100@w{ }LX.\n+Default is @samp{v0} except for cris-axis-linux-gnu, where the default is\n+@samp{v10}.\n+\n+@item -mtune=@var{architecture-type}\n+@opindex mtune\n+Tune to @var{architecture-type} everything applicable about the generated\n+code, except for the ABI and the set of available instructions.  The\n+choices for @var{architecture-type} are the same as for\n+@option{-march=@var{architecture-type}}.\n+\n+@item -mmax-stack-frame=@var{n}\n+@opindex mmax-stack-frame\n+Warn when the stack frame of a function exceeds @var{n} bytes.\n+\n+@item -melinux-stacksize=@var{n}\n+@opindex melinux-stacksize\n+Only available with the @samp{cris-axis-aout} target.  Arranges for\n+indications in the program to the kernel loader that the stack of the\n+program should be set to @var{n} bytes.\n+\n+@item -metrax4\n+@itemx -metrax100\n+@opindex metrax4\n+@opindex metrax100\n+The options @option{-metrax4} and @option{-metrax100} are synonyms for\n+@option{-march=v3} and @option{-march=v8} respectively.\n+\n+@item -mpdebug\n+@opindex mpdebug\n+Enable CRIS-specific verbose debug-related information in the assembly\n+code.  This option also has the effect to turn off the @samp{#NO_APP}\n+formatted-code indicator to the assembler at the beginning of the\n+assembly file.\n+\n+@item -mcc-init\n+@opindex mcc-init\n+Do not use condition-code results from previous instruction; always emit\n+compare and test instructions before use of condition codes.\n+\n+@item -mno-side-effects\n+@opindex mno-side-effects\n+Do not emit instructions with side-effects in addressing modes other than\n+post-increment.\n+\n+@item -mstack-align\n+@itemx -mno-stack-align\n+@itemx -mdata-align\n+@itemx -mno-data-align\n+@itemx -mconst-align\n+@itemx -mno-const-align\n+@opindex mstack-align\n+@opindex mno-stack-align\n+@opindex mdata-align\n+@opindex mno-data-align\n+@opindex mconst-align\n+@opindex mno-const-align\n+These options (no-options) arranges (eliminate arrangements) for the\n+stack-frame, individual data and constants to be aligned for the maximum\n+single data access size for the chosen CPU model.  The default is to\n+arrange for 32-bit alignment.  ABI details such as structure layout are\n+not affected by these options.\n+\n+@item -m32-bit\n+@itemx -m16-bit\n+@itemx -m8-bit\n+@opindex m32-bit\n+@opindex m16-bit\n+@opindex m8-bit\n+Similar to the stack- data- and const-align options above, these options\n+arrange for stack-frame, writable data and constants to all be 32-bit,\n+16-bit or 8-bit aligned.  The default is 32-bit alignment.\n+\n+@item -mno-prologue-epilogue\n+@itemx -mprologue-epilogue\n+@opindex mno-prologue-epilogue\n+@opindex mprologue-epilogue\n+With @option{-mno-prologue-epilogue}, the normal function prologue and\n+epilogue that sets up the stack-frame are omitted and no return\n+instructions or return sequences are generated in the code.  Use this\n+option only together with visual inspection of the compiled code: no\n+warnings or errors are generated when call-saved registers must be saved,\n+or storage for local variable needs to be allocated.\n+\n+@item -mno-gotplt\n+@itemx -mgotplt\n+@opindex mno-gotplt\n+@opindex mgotplt\n+With @option{-fpic} and @option{-fPIC}, don't generate (do generate)\n+instruction sequences that load addresses for functions from the PLT part\n+of the GOT rather than (traditional on other architectures) calls to the\n+PLT.  The default is @option{-mgotplt}.\n+\n+@item -maout\n+@opindex maout\n+Legacy no-op option only recognized with the cris-axis-aout target.\n+\n+@item -melf\n+@opindex melf\n+Legacy no-op option only recognized with the cris-axis-elf and\n+cris-axis-linux-gnu targets.\n+\n+@item -melinux\n+@opindex melinux\n+Only recognized with the cris-axis-aout target, where it selects a\n+GNU/linux-like multilib, include files and instruction set for\n+@option{-march=v8}.\n+\n+@item -mlinux\n+@opindex mlinux\n+Legacy no-op option only recognized with the cris-axis-linux-gnu target.\n+\n+@item -sim\n+@opindex sim\n+This option, recognized for the cris-axis-aout and cris-axis-elf arranges\n+to link with input-output functions from a simulator library.  Code,\n+initialized data and zero-initialized data are allocated consecutively.\n+\n+@item -sim2\n+@opindex sim2\n+Like @option{-sim}, but pass linker options to locate initialized data at\n+0x40000000 and zero-initialized data at 0x80000000.\n+@end table\n+\n \n @node Code Gen Options\n @section Options for Code Generation Conventions"}]}