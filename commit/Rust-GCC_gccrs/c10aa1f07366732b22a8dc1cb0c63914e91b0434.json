{"sha": "c10aa1f07366732b22a8dc1cb0c63914e91b0434", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzEwYWExZjA3MzY2NzMyYjIyYThkYzFjYjBjNjM5MTRlOTFiMDQzNA==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-05-13T12:27:30Z"}, "committer": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2020-05-13T12:27:30Z"}, "message": "Add gcc-changelog related scripts.\n\n\t* gcc-changelog/git_check_commit.py: New file.\n\t* gcc-changelog/git_commit.py: New file.\n\t* gcc-changelog/git_email.py: New file.\n\t* gcc-changelog/git_repository.py: New file.\n\t* gcc-changelog/git_update_version.py: New file.", "tree": {"sha": "da7a74d1d2b274d68a1657308fc9e6f83bcda5a4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/da7a74d1d2b274d68a1657308fc9e6f83bcda5a4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c10aa1f07366732b22a8dc1cb0c63914e91b0434", "comment_count": 0, "verification": {"verified": false, "reason": "unknown_key", "signature": "-----BEGIN PGP SIGNATURE-----\n\niQEzBAABCAAdFiEE6I4wzqqylQBfXaRhTcGC3A+nN4UFAl6757IACgkQTcGC3A+n\nN4XIvQgAuRIcE4d8GxDvXyH79z2603WZGXAG7IwccdhwPlInsNYZdWT3mkzI4C3K\nXGbrIBzp5SW1OW3+L7bpeaVM4Ud5s4BU8iqBeT8yTTZ4tTpXYD/fpDCkAxNK4y3C\nnzvja1yJZh604YGaCUgMvuTB+egv1unGvsrReNLcvv3K2O/Ng7rokthC0Q2mo9lM\n8r3QHFuBjle5Hg4rsfUyMB2N3iOYM+GFKkIAFB0KhJR8oUC7JK2eiSYLAxmtE7QG\njUpLDj/yoJw8Q/chXSABq9j6XcGdM96QVQ5l5tH23fKKDEYm0iNjiMTfVvfKUEDu\nfqg+9CRLuNvgWA0fLHGvOMImx2H0Mw==\n=xD4b\n-----END PGP SIGNATURE-----", "payload": "tree da7a74d1d2b274d68a1657308fc9e6f83bcda5a4\nparent 18edc195442291525e04f0fa4d5ef972155117da\nauthor Martin Liska <mliska@suse.cz> 1589372850 +0200\ncommitter Martin Liska <mliska@suse.cz> 1589372850 +0200\n\nAdd gcc-changelog related scripts.\n\n\t* gcc-changelog/git_check_commit.py: New file.\n\t* gcc-changelog/git_commit.py: New file.\n\t* gcc-changelog/git_email.py: New file.\n\t* gcc-changelog/git_repository.py: New file.\n\t* gcc-changelog/git_update_version.py: New file.\n"}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10aa1f07366732b22a8dc1cb0c63914e91b0434", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c10aa1f07366732b22a8dc1cb0c63914e91b0434", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c10aa1f07366732b22a8dc1cb0c63914e91b0434/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "18edc195442291525e04f0fa4d5ef972155117da", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/18edc195442291525e04f0fa4d5ef972155117da", "html_url": "https://github.com/Rust-GCC/gccrs/commit/18edc195442291525e04f0fa4d5ef972155117da"}], "stats": {"total": 850, "additions": 850, "deletions": 0}, "files": [{"sha": "ae5823ba2d914ce6c6783030a865468c9bbe08d6", "filename": "contrib/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2FChangeLog?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -1,3 +1,11 @@\n+2020-05-13  Martin Liska  <mliska@suse.cz>\n+\n+\t* gcc-changelog/git_check_commit.py: New file.\n+\t* gcc-changelog/git_commit.py: New file.\n+\t* gcc-changelog/git_email.py: New file.\n+\t* gcc-changelog/git_repository.py: New file.\n+\t* gcc-changelog/git_update_version.py: New file.\n+\n 2020-04-17  Martin Liska  <mliska@suse.cz>\n \n \t* vimrc: We do not want to modify tab options"}, {"sha": "b2d1d08a2424d5ef470de9bc072572f46a53ff89", "filename": "contrib/gcc-changelog/git_check_commit.py", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_check_commit.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_check_commit.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_check_commit.py?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -0,0 +1,49 @@\n+#!/usr/bin/env python3\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+import argparse\n+\n+from git_repository import parse_git_revisions\n+\n+parser = argparse.ArgumentParser(description='Check git ChangeLog format '\n+                                 'of a commit')\n+parser.add_argument('revisions',\n+                    help='Git revisions (e.g. hash~5..hash or just hash)')\n+parser.add_argument('-g', '--git-path', default='.',\n+                    help='Path to git repository')\n+parser.add_argument('-p', '--print-changelog', action='store_true',\n+                    help='Print final changelog entires')\n+parser.add_argument('-n', '--allow-non-strict-mode', action='store_true',\n+                    help='Allow non-strict mode (change in both ChangeLog and '\n+                    'other files.')\n+args = parser.parse_args()\n+\n+retval = 0\n+for git_commit in parse_git_revisions(args.git_path, args.revisions,\n+                                      not args.allow_non_strict_mode):\n+    print('Checking %s' % git_commit.hexsha)\n+    if git_commit.success:\n+        print('OK')\n+        if args.print_changelog:\n+            git_commit.print_output()\n+    else:\n+        for error in git_commit.errors:\n+            print('ERR: %s' % error)\n+        retval = 1\n+\n+exit(retval)"}, {"sha": "a434f949ee69d3d030f5eca037a1a76226adfdf5", "filename": "contrib/gcc-changelog/git_commit.py", "status": "added", "additions": 536, "deletions": 0, "changes": 536, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_commit.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_commit.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_commit.py?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -0,0 +1,536 @@\n+#!/usr/bin/env python3\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+import os\n+import re\n+\n+changelog_locations = set([\n+    'config',\n+    'contrib',\n+    'contrib/header-tools',\n+    'contrib/reghunt',\n+    'contrib/regression',\n+    'fixincludes',\n+    'gcc/ada',\n+    'gcc/analyzer',\n+    'gcc/brig',\n+    'gcc/c',\n+    'gcc/c-family',\n+    'gcc',\n+    'gcc/cp',\n+    'gcc/d',\n+    'gcc/fortran',\n+    'gcc/go',\n+    'gcc/jit',\n+    'gcc/lto',\n+    'gcc/objc',\n+    'gcc/objcp',\n+    'gcc/po',\n+    'gcc/testsuite',\n+    'gnattools',\n+    'gotools',\n+    'include',\n+    'intl',\n+    'libada',\n+    'libatomic',\n+    'libbacktrace',\n+    'libcc1',\n+    'libcpp',\n+    'libcpp/po',\n+    'libdecnumber',\n+    'libffi',\n+    'libgcc',\n+    'libgcc/config/avr/libf7',\n+    'libgcc/config/libbid',\n+    'libgfortran',\n+    'libgomp',\n+    'libhsail-rt',\n+    'libiberty',\n+    'libitm',\n+    'libobjc',\n+    'liboffloadmic',\n+    'libphobos',\n+    'libquadmath',\n+    'libsanitizer',\n+    'libssp',\n+    'libstdc++-v3',\n+    'libvtv',\n+    'lto-plugin',\n+    'maintainer-scripts',\n+    'zlib'])\n+\n+bug_components = set([\n+    'ada',\n+    'analyzer',\n+    'boehm-gc',\n+    'bootstrap',\n+    'c',\n+    'c++',\n+    'd',\n+    'debug',\n+    'demangler',\n+    'driver',\n+    'fastjar',\n+    'fortran',\n+    'gcov-profile',\n+    'go',\n+    'hsa',\n+    'inline-asm',\n+    'ipa',\n+    'java',\n+    'jit',\n+    'libbacktrace',\n+    'libf2c',\n+    'libffi',\n+    'libfortran',\n+    'libgcc',\n+    'libgcj',\n+    'libgomp',\n+    'libitm',\n+    'libobjc',\n+    'libquadmath',\n+    'libstdc++',\n+    'lto',\n+    'middle-end',\n+    'modula2',\n+    'objc',\n+    'objc++',\n+    'other',\n+    'pch',\n+    'pending',\n+    'plugins',\n+    'preprocessor',\n+    'regression',\n+    'rtl-optimization',\n+    'sanitizer',\n+    'spam',\n+    'target',\n+    'testsuite',\n+    'translation',\n+    'tree-optimization',\n+    'web'])\n+\n+ignored_prefixes = [\n+    'gcc/d/dmd/',\n+    'gcc/go/frontend/',\n+    'libgo/',\n+    'libphobos/libdruntime',\n+    'libphobos/src/',\n+    'libsanitizer/',\n+    ]\n+\n+misc_files = [\n+    'gcc/DATESTAMP',\n+    'gcc/BASE-VER',\n+    'gcc/DEV-PHASE'\n+    ]\n+\n+author_line_regex = \\\n+        re.compile(r'^(?P<datetime>\\d{4}-\\d{2}-\\d{2})\\ {2}(?P<name>.*  <.*>)')\n+additional_author_regex = re.compile(r'^\\t(?P<spaces>\\ *)?(?P<name>.*  <.*>)')\n+changelog_regex = re.compile(r'^([a-z0-9+-/]*)/ChangeLog:?')\n+pr_regex = re.compile(r'\\tPR (?P<component>[a-z+-]+\\/)?([0-9]+)$')\n+star_prefix_regex = re.compile(r'\\t\\*(?P<spaces>\\ *)(?P<content>.*)')\n+\n+LINE_LIMIT = 100\n+TAB_WIDTH = 8\n+CO_AUTHORED_BY_PREFIX = 'co-authored-by: '\n+\n+\n+class Error:\n+    def __init__(self, message, line=None):\n+        self.message = message\n+        self.line = line\n+\n+    def __repr__(self):\n+        s = self.message\n+        if self.line:\n+            s += ':\"%s\"' % self.line\n+        return s\n+\n+\n+class ChangeLogEntry:\n+    def __init__(self, folder, authors, prs):\n+        self.folder = folder\n+        # Python2 has not 'copy' function\n+        self.author_lines = list(authors)\n+        self.initial_prs = list(prs)\n+        self.prs = list(prs)\n+        self.lines = []\n+\n+    @property\n+    def files(self):\n+        files = []\n+        for line in self.lines:\n+            m = star_prefix_regex.match(line)\n+            if m:\n+                line = m.group('content')\n+                if '(' in line:\n+                    line = line[:line.index('(')]\n+                if ':' in line:\n+                    line = line[:line.index(':')]\n+                for file in line.split(','):\n+                    file = file.strip()\n+                    if file:\n+                        files.append(file)\n+        return files\n+\n+    @property\n+    def datetime(self):\n+        for author in self.author_lines:\n+            if author[1]:\n+                return author[1]\n+        return None\n+\n+    @property\n+    def authors(self):\n+        return [author_line[0] for author_line in self.author_lines]\n+\n+    @property\n+    def is_empty(self):\n+        return not self.lines and self.prs == self.initial_prs\n+\n+\n+class GitCommit:\n+    def __init__(self, hexsha, date, author, body, modified_files,\n+                 strict=True):\n+        self.hexsha = hexsha\n+        self.lines = body\n+        self.modified_files = modified_files\n+        self.message = None\n+        self.changes = None\n+        self.changelog_entries = []\n+        self.errors = []\n+        self.date = date\n+        self.author = author\n+        self.top_level_authors = []\n+        self.co_authors = []\n+        self.top_level_prs = []\n+\n+        project_files = [f for f in self.modified_files\n+                         if self.is_changelog_filename(f[0])\n+                         or f[0] in misc_files]\n+        if len(project_files) == len(self.modified_files):\n+            # All modified files are only MISC files\n+            return\n+        elif project_files and strict:\n+            self.errors.append(Error('ChangeLog, DATESTAMP, BASE-VER and '\n+                                     'DEV-PHASE updates should be done '\n+                                     'separately from normal commits'))\n+            return\n+\n+        self.parse_lines()\n+        if self.changes:\n+            self.parse_changelog()\n+            self.deduce_changelog_locations()\n+            if not self.errors:\n+                self.check_mentioned_files()\n+                self.check_for_correct_changelog()\n+\n+    @property\n+    def success(self):\n+        return not self.errors\n+\n+    @property\n+    def new_files(self):\n+        return [x[0] for x in self.modified_files if x[1] == 'A']\n+\n+    @classmethod\n+    def is_changelog_filename(cls, path):\n+        return path.endswith('/ChangeLog') or path == 'ChangeLog'\n+\n+    @classmethod\n+    def find_changelog_location(cls, name):\n+        if name.startswith('\\t'):\n+            name = name[1:]\n+        if name.endswith(':'):\n+            name = name[:-1]\n+        if name.endswith('/'):\n+            name = name[:-1]\n+        return name if name in changelog_locations else None\n+\n+    @classmethod\n+    def format_git_author(cls, author):\n+        assert '<' in author\n+        return author.replace('<', ' <')\n+\n+    @classmethod\n+    def parse_git_name_status(cls, string):\n+        modified_files = []\n+        for entry in string.split('\\n'):\n+            parts = entry.split('\\t')\n+            t = parts[0]\n+            if t == 'A' or t == 'D' or t == 'M':\n+                modified_files.append((parts[1], t))\n+            elif t == 'R':\n+                modified_files.append((parts[1], 'D'))\n+                modified_files.append((parts[2], 'A'))\n+        return modified_files\n+\n+    def parse_lines(self):\n+        body = self.lines\n+\n+        for i, b in enumerate(body):\n+            if not b:\n+                continue\n+            if (changelog_regex.match(b) or self.find_changelog_location(b)\n+                    or star_prefix_regex.match(b) or pr_regex.match(b)\n+                    or author_line_regex.match(b)):\n+                self.changes = body[i:]\n+                return\n+        self.errors.append(Error('cannot find a ChangeLog location in '\n+                                 'message'))\n+\n+    def parse_changelog(self):\n+        last_entry = None\n+        will_deduce = False\n+        for line in self.changes:\n+            if not line:\n+                if last_entry and will_deduce:\n+                    last_entry = None\n+                continue\n+            if line != line.rstrip():\n+                self.errors.append(Error('trailing whitespace', line))\n+            if len(line.replace('\\t', ' ' * TAB_WIDTH)) > LINE_LIMIT:\n+                self.errors.append(Error('line limit exceeds %d characters'\n+                                         % LINE_LIMIT, line))\n+            m = changelog_regex.match(line)\n+            if m:\n+                last_entry = ChangeLogEntry(m.group(1), self.top_level_authors,\n+                                            self.top_level_prs)\n+                self.changelog_entries.append(last_entry)\n+            elif self.find_changelog_location(line):\n+                last_entry = ChangeLogEntry(self.find_changelog_location(line),\n+                                            self.top_level_authors,\n+                                            self.top_level_prs)\n+                self.changelog_entries.append(last_entry)\n+            else:\n+                author_tuple = None\n+                pr_line = None\n+                if author_line_regex.match(line):\n+                    m = author_line_regex.match(line)\n+                    author_tuple = (m.group('name'), m.group('datetime'))\n+                elif additional_author_regex.match(line):\n+                    m = additional_author_regex.match(line)\n+                    if len(m.group('spaces')) != 4:\n+                        msg = 'additional author must prepend with tab ' \\\n+                              'and 4 spaces'\n+                        self.errors.append(Error(msg, line))\n+                    else:\n+                        author_tuple = (m.group('name'), None)\n+                elif pr_regex.match(line):\n+                    component = pr_regex.match(line).group('component')\n+                    if not component:\n+                        self.errors.append(Error('missing PR component', line))\n+                        continue\n+                    elif not component[:-1] in bug_components:\n+                        self.errors.append(Error('invalid PR component', line))\n+                        continue\n+                    else:\n+                        pr_line = line.lstrip()\n+\n+                if line.lower().startswith(CO_AUTHORED_BY_PREFIX):\n+                    name = line[len(CO_AUTHORED_BY_PREFIX):]\n+                    author = self.format_git_author(name)\n+                    self.co_authors.append(author)\n+                    continue\n+\n+                # ChangeLog name will be deduced later\n+                if not last_entry:\n+                    if author_tuple:\n+                        self.top_level_authors.append(author_tuple)\n+                        continue\n+                    elif pr_line:\n+                        # append to top_level_prs only when we haven't met\n+                        # a ChangeLog entry\n+                        if (pr_line not in self.top_level_prs\n+                                and not self.changelog_entries):\n+                            self.top_level_prs.append(pr_line)\n+                        continue\n+                    else:\n+                        last_entry = ChangeLogEntry(None,\n+                                                    self.top_level_authors,\n+                                                    self.top_level_prs)\n+                        self.changelog_entries.append(last_entry)\n+                        will_deduce = True\n+                elif author_tuple:\n+                    last_entry.author_lines.append(author_tuple)\n+                    continue\n+\n+                if not line.startswith('\\t'):\n+                    err = Error('line should start with a tab', line)\n+                    self.errors.append(err)\n+                elif pr_line:\n+                    last_entry.prs.append(pr_line)\n+                else:\n+                    m = star_prefix_regex.match(line)\n+                    if m:\n+                        if len(m.group('spaces')) != 1:\n+                            err = Error('one space should follow asterisk',\n+                                        line)\n+                            self.errors.append(err)\n+                        else:\n+                            last_entry.lines.append(line)\n+                    else:\n+                        if last_entry.is_empty:\n+                            msg = 'first line should start with a tab, ' \\\n+                                  'asterisk and space'\n+                            self.errors.append(Error(msg, line))\n+                        else:\n+                            last_entry.lines.append(line)\n+\n+    def get_file_changelog_location(self, changelog_file):\n+        for file in self.modified_files:\n+            if file[0] == changelog_file:\n+                # root ChangeLog file\n+                return ''\n+            index = file[0].find('/' + changelog_file)\n+            if index != -1:\n+                return file[0][:index]\n+        return None\n+\n+    def deduce_changelog_locations(self):\n+        for entry in self.changelog_entries:\n+            if not entry.folder:\n+                changelog = None\n+                for file in entry.files:\n+                    location = self.get_file_changelog_location(file)\n+                    if (location == ''\n+                       or (location and location in changelog_locations)):\n+                        if changelog and changelog != location:\n+                            msg = 'could not deduce ChangeLog file, ' \\\n+                                  'not unique location'\n+                            self.errors.append(Error(msg))\n+                            return\n+                        changelog = location\n+                if changelog is not None:\n+                    entry.folder = changelog\n+                else:\n+                    msg = 'could not deduce ChangeLog file'\n+                    self.errors.append(Error(msg))\n+\n+    @classmethod\n+    def in_ignored_location(cls, path):\n+        for ignored in ignored_prefixes:\n+            if path.startswith(ignored):\n+                return True\n+        return False\n+\n+    @classmethod\n+    def get_changelog_by_path(cls, path):\n+        components = path.split('/')\n+        while components:\n+            if '/'.join(components) in changelog_locations:\n+                break\n+            components = components[:-1]\n+        return '/'.join(components)\n+\n+    def check_mentioned_files(self):\n+        folder_count = len([x.folder for x in self.changelog_entries])\n+        assert folder_count == len(self.changelog_entries)\n+\n+        mentioned_files = set()\n+        for entry in self.changelog_entries:\n+            if not entry.files:\n+                msg = 'ChangeLog must contain a file entry'\n+                self.errors.append(Error(msg, entry.folder))\n+            assert not entry.folder.endswith('/')\n+            for file in entry.files:\n+                if not self.is_changelog_filename(file):\n+                    mentioned_files.add(os.path.join(entry.folder, file))\n+\n+        cand = [x[0] for x in self.modified_files\n+                if not self.is_changelog_filename(x[0])]\n+        changed_files = set(cand)\n+        for file in sorted(mentioned_files - changed_files):\n+            self.errors.append(Error('file not changed in a patch', file))\n+        for file in sorted(changed_files - mentioned_files):\n+            if not self.in_ignored_location(file):\n+                if file in self.new_files:\n+                    changelog_location = self.get_changelog_by_path(file)\n+                    # Python2: we cannot use next(filter(...))\n+                    entries = filter(lambda x: x.folder == changelog_location,\n+                                     self.changelog_entries)\n+                    entries = list(entries)\n+                    entry = entries[0] if entries else None\n+                    if not entry:\n+                        prs = self.top_level_prs\n+                        if not prs:\n+                            # if all ChangeLog entries have identical PRs\n+                            # then use them\n+                            prs = self.changelog_entries[0].prs\n+                            for entry in self.changelog_entries:\n+                                if entry.prs != prs:\n+                                    prs = []\n+                                    break\n+                        entry = ChangeLogEntry(changelog_location,\n+                                               self.top_level_authors,\n+                                               prs)\n+                        self.changelog_entries.append(entry)\n+                    # strip prefix of the file\n+                    assert file.startswith(entry.folder)\n+                    file = file[len(entry.folder):].lstrip('/')\n+                    entry.lines.append('\\t* %s: New file.' % file)\n+                else:\n+                    msg = 'changed file not mentioned in a ChangeLog'\n+                    self.errors.append(Error(msg, file))\n+\n+    def check_for_correct_changelog(self):\n+        for entry in self.changelog_entries:\n+            for file in entry.files:\n+                full_path = os.path.join(entry.folder, file)\n+                changelog_location = self.get_changelog_by_path(full_path)\n+                if changelog_location != entry.folder:\n+                    msg = 'wrong ChangeLog location \"%s\", should be \"%s\"'\n+                    err = Error(msg % (entry.folder, changelog_location), file)\n+                    self.errors.append(err)\n+\n+    def to_changelog_entries(self):\n+        for entry in self.changelog_entries:\n+            output = ''\n+            timestamp = entry.datetime\n+            if not timestamp:\n+                timestamp = self.date.strftime('%Y-%m-%d')\n+            authors = entry.authors if entry.authors else [self.author]\n+            # add Co-Authored-By authors to all ChangeLog entries\n+            for author in self.co_authors:\n+                if author not in authors:\n+                    authors.append(author)\n+\n+            for i, author in enumerate(authors):\n+                if i == 0:\n+                    output += '%s  %s\\n' % (timestamp, author)\n+                else:\n+                    output += '\\t    %s\\n' % author\n+            output += '\\n'\n+            for pr in entry.prs:\n+                output += '\\t%s\\n' % pr\n+            for line in entry.lines:\n+                output += line + '\\n'\n+            yield (entry.folder, output.rstrip())\n+\n+    def print_output(self):\n+        for entry, output in self.to_changelog_entries():\n+            print('@@CL %s' % entry)\n+            print(output)\n+        print('@@CL')\n+\n+    def print_errors(self):\n+        print('Errors:')\n+        for error in self.errors:\n+            print(error)"}, {"sha": "e1d6b70e80c0b85ce652a6048786343c4f65b367", "filename": "contrib/gcc-changelog/git_email.py", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_email.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_email.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_email.py?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -0,0 +1,92 @@\n+#!/usr/bin/env python3\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+import os\n+import sys\n+from itertools import takewhile\n+\n+from dateutil.parser import parse\n+\n+from git_commit import GitCommit\n+\n+from unidiff import PatchSet\n+\n+DATE_PREFIX = 'Date: '\n+FROM_PREFIX = 'From: '\n+\n+\n+class GitEmail(GitCommit):\n+    def __init__(self, filename, strict=False):\n+        self.filename = filename\n+        diff = PatchSet.from_filename(filename)\n+        date = None\n+        author = None\n+\n+        lines = open(self.filename).read().splitlines()\n+        lines = list(takewhile(lambda line: line != '---', lines))\n+        for line in lines:\n+            if line.startswith(DATE_PREFIX):\n+                date = parse(line[len(DATE_PREFIX):])\n+            elif line.startswith(FROM_PREFIX):\n+                author = GitCommit.format_git_author(line[len(FROM_PREFIX):])\n+        header = list(takewhile(lambda line: line != '', lines))\n+        body = lines[len(header) + 1:]\n+\n+        modified_files = []\n+        for f in diff:\n+            if f.is_added_file:\n+                t = 'A'\n+            elif f.is_removed_file:\n+                t = 'D'\n+            else:\n+                t = 'M'\n+            modified_files.append((f.path, t))\n+        super().__init__(None, date, author, body, modified_files,\n+                         strict=strict)\n+\n+\n+if __name__ == '__main__':\n+    if len(sys.argv) == 1:\n+        allfiles = []\n+        for root, _dirs, files in os.walk('patches'):\n+            for f in files:\n+                full = os.path.join(root, f)\n+                allfiles.append(full)\n+\n+        success = 0\n+        for full in sorted(allfiles):\n+            email = GitEmail(full, False)\n+            print(email.filename)\n+            if email.success:\n+                success += 1\n+                print('  OK')\n+            else:\n+                for error in email.errors:\n+                    print('  ERR: %s' % error)\n+\n+        print()\n+        print('Successfully parsed: %d/%d' % (success, len(allfiles)))\n+    else:\n+        email = GitEmail(sys.argv[1], False)\n+        if email.success:\n+            print('OK')\n+            email.print_output()\n+        else:\n+            if not email.lines:\n+                print('Error: patch contains no parsed lines', file=sys.stderr)\n+            email.print_errors()"}, {"sha": "0473fe73fba1ab89e89bec12852cd39e46b148e8", "filename": "contrib/gcc-changelog/git_repository.py", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_repository.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_repository.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_repository.py?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -0,0 +1,60 @@\n+#!/usr/bin/env python3\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+from datetime import datetime\n+\n+try:\n+    from git import Repo\n+except ImportError:\n+    print('Cannot import GitPython package, please install the package:')\n+    print('  Fedora, openSUSE: python3-GitPython')\n+    print('  Debian, Ubuntu: python3-git')\n+    exit(1)\n+\n+from git_commit import GitCommit\n+\n+\n+def parse_git_revisions(repo_path, revisions, strict=False):\n+    repo = Repo(repo_path)\n+\n+    parsed_commits = []\n+    if '..' in revisions:\n+        commits = list(repo.iter_commits(revisions))\n+    else:\n+        commits = [repo.commit(revisions)]\n+\n+    for commit in commits:\n+        diff = repo.commit(commit.hexsha + '~').diff(commit.hexsha)\n+\n+        modified_files = []\n+        for file in diff:\n+            if file.new_file:\n+                t = 'A'\n+            elif file.deleted_file:\n+                t = 'D'\n+            else:\n+                t = 'M'\n+            modified_files.append((file.b_path, t))\n+\n+        date = datetime.utcfromtimestamp(commit.committed_date)\n+        author = '%s  <%s>' % (commit.author.name, commit.author.email)\n+        git_commit = GitCommit(commit.hexsha, date, author,\n+                               commit.message.split('\\n'), modified_files,\n+                               strict=strict)\n+        parsed_commits.append(git_commit)\n+    return parsed_commits"}, {"sha": "c66b4d68e6896ac28ecb9890eada6826922cb6c7", "filename": "contrib/gcc-changelog/git_update_version.py", "status": "added", "additions": 105, "deletions": 0, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_update_version.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c10aa1f07366732b22a8dc1cb0c63914e91b0434/contrib%2Fgcc-changelog%2Fgit_update_version.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/contrib%2Fgcc-changelog%2Fgit_update_version.py?ref=c10aa1f07366732b22a8dc1cb0c63914e91b0434", "patch": "@@ -0,0 +1,105 @@\n+#!/usr/bin/env python3\n+#\n+# This file is part of GCC.\n+#\n+# GCC is free software; you can redistribute it and/or modify it under\n+# the terms of the GNU General Public License as published by the Free\n+# Software Foundation; either version 3, or (at your option) any later\n+# version.\n+#\n+# GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+# WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+# FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+# for more details.\n+#\n+# You should have received a copy of the GNU General Public License\n+# along with GCC; see the file COPYING3.  If not see\n+# <http://www.gnu.org/licenses/>.  */\n+\n+import argparse\n+import datetime\n+import os\n+\n+from git import Repo\n+\n+from git_repository import parse_git_revisions\n+\n+# TODO: remove sparta suffix\n+current_timestamp = datetime.datetime.now().strftime('%Y%m%d sparta\\n')\n+\n+\n+def read_timestamp(path):\n+    return open(path).read()\n+\n+\n+def prepend_to_changelog_files(repo, folder, git_commit):\n+    if not git_commit.success:\n+        for error in git_commit.errors:\n+            print(error)\n+        # TODO: add error message\n+        return\n+    for entry, output in git_commit.to_changelog_entries():\n+        # TODO\n+        full_path = os.path.join(folder, entry, 'ChangeLog.test')\n+        print('writting to %s' % full_path)\n+        if os.path.exists(full_path):\n+            content = open(full_path).read()\n+        else:\n+            content = ''\n+        with open(full_path, 'w+') as f:\n+            f.write(output)\n+            if content:\n+                f.write('\\n\\n')\n+                f.write(content)\n+        repo.git.add(full_path)\n+\n+\n+active_refs = ['master', 'releases/gcc-8', 'releases/gcc-9', 'releases/gcc-10']\n+\n+parser = argparse.ArgumentParser(description='Update DATESTAMP and generate '\n+                                 'ChangeLog entries')\n+parser.add_argument('-g', '--git-path', default='.',\n+                    help='Path to git repository')\n+args = parser.parse_args()\n+\n+repo = Repo(args.git_path)\n+origin = repo.remotes['origin']\n+\n+for ref in origin.refs:\n+    assert ref.name.startswith('origin/')\n+    name = ref.name[len('origin/'):]\n+    if name in active_refs:\n+        if name in repo.branches:\n+            branch = repo.branches[name]\n+        else:\n+            branch = repo.create_head(name, ref).set_tracking_branch(ref)\n+        origin.pull(rebase=True)\n+        branch.checkout()\n+        print('=== Working on: %s ===' % branch)\n+        assert not repo.index.diff(None)\n+        commit = branch.commit\n+        commit_count = 1\n+        while commit:\n+            if (commit.author.email == 'gccadmin@gcc.gnu.org'\n+                    and commit.message.strip() == 'Daily bump.'):\n+                break\n+            commit = commit.parents[0]\n+            commit_count += 1\n+\n+        print('%d revisions since last Daily bump' % commit_count)\n+        datestamp_path = os.path.join(args.git_path, 'gcc/DATESTAMP')\n+        if read_timestamp(datestamp_path) != current_timestamp:\n+            print('DATESTAMP will be changed:')\n+            # TODO: set strict=True after testing period\n+            commits = parse_git_revisions(args.git_path, '%s..HEAD'\n+                                          % commit.hexsha, strict=False)\n+            for git_commit in commits:\n+                prepend_to_changelog_files(repo, args.git_path, git_commit)\n+            # update timestamp\n+            with open(datestamp_path, 'w+') as f:\n+                f.write(current_timestamp)\n+            repo.git.add(datestamp_path)\n+            repo.index.commit('Daily bump.')\n+            # TODO: push the repository\n+        else:\n+            print('DATESTAMP unchanged')"}]}