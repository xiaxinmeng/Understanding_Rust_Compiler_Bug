{"sha": "e1b243a800307b7a731b5b3cf69a2d784498923b", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTFiMjQzYTgwMDMwN2I3YTczMWI1YjNjZjY5YTJkNzg0NDk4OTIzYg==", "commit": {"author": {"name": "Jakub Jelinek", "email": "jakub@redhat.com", "date": "2009-10-02T15:01:22Z"}, "committer": {"name": "Jakub Jelinek", "email": "jakub@gcc.gnu.org", "date": "2009-10-02T15:01:22Z"}, "message": "re PR bootstrap/41404 (expr.c undefined reference while linking jc1)\n\n\tPR debug/41404\n\tPR debug/41353\n\t* cfgexpand.c (expand_debug_expr) <case STRING_CST>: Don't create\n\tCONST_STRING if STRING_CST contains embedded '\\0's or doesn't end with\n\t'\\0'.\n\t(expand_debug_expr) <case VAR_DECL>: For TREE_STATIC !DECL_EXTERNAL\n\tvars use DECL_RTL with resetting it back to NULL afterwards.\n\t* dwarf2out.c (same_dw_val_p): For dw_val_class_addr compare with\n\trtx_equal_p instead of asserting it is a SYMBOL_REF.\n\t(value_format): For dw_val_class_addr only use DW_FORM_addr if\n\tthe attribute type allows it, otherwise use DW_FORM_dataN.\n\t(mem_loc_descriptor): Handle CONST_STRING.\n\t(add_const_value_attribute): Handle CONST_STRING using add_AT_addr.\n\tHandle MEM with CONST_STRING address using add_AT_string.\n\t(rtl_for_decl_init): Return MEM with CONST_STRING address instead of\n\tCONST_STRING for const arrays initialized with a string literal.\n\t(resolve_one_addr, resolve_addr_in_expr, resolve_addr): New functions.\n\t(dwarf2out_finish): Call resolve_addr.\n\n\t* gcc.dg/guality/pr41404-1.c: New test.\n\t* gcc.dg/guality/pr41353-2.c: New test.\n\nFrom-SVN: r152403", "tree": {"sha": "c18228efb40a0e59c5eb72d9e3b4378820263cdd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c18228efb40a0e59c5eb72d9e3b4378820263cdd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e1b243a800307b7a731b5b3cf69a2d784498923b", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b243a800307b7a731b5b3cf69a2d784498923b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e1b243a800307b7a731b5b3cf69a2d784498923b", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e1b243a800307b7a731b5b3cf69a2d784498923b/comments", "author": {"login": "jakubjelinek", "id": 9370665, "node_id": "MDQ6VXNlcjkzNzA2NjU=", "avatar_url": "https://avatars.githubusercontent.com/u/9370665?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jakubjelinek", "html_url": "https://github.com/jakubjelinek", "followers_url": "https://api.github.com/users/jakubjelinek/followers", "following_url": "https://api.github.com/users/jakubjelinek/following{/other_user}", "gists_url": "https://api.github.com/users/jakubjelinek/gists{/gist_id}", "starred_url": "https://api.github.com/users/jakubjelinek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jakubjelinek/subscriptions", "organizations_url": "https://api.github.com/users/jakubjelinek/orgs", "repos_url": "https://api.github.com/users/jakubjelinek/repos", "events_url": "https://api.github.com/users/jakubjelinek/events{/privacy}", "received_events_url": "https://api.github.com/users/jakubjelinek/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "b1d42460aef1a4c02d7c35301c2c4e81d5ed3419", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b1d42460aef1a4c02d7c35301c2c4e81d5ed3419", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b1d42460aef1a4c02d7c35301c2c4e81d5ed3419"}], "stats": {"total": 272, "additions": 261, "deletions": 11}, "files": [{"sha": "00a6055e1add4f99f085eb17491a5eaa19eb9f16", "filename": "gcc/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -1,3 +1,24 @@\n+2009-10-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/41404\n+\tPR debug/41353\n+\t* cfgexpand.c (expand_debug_expr) <case STRING_CST>: Don't create\n+\tCONST_STRING if STRING_CST contains embedded '\\0's or doesn't end with\n+\t'\\0'.\n+\t(expand_debug_expr) <case VAR_DECL>: For TREE_STATIC !DECL_EXTERNAL\n+\tvars use DECL_RTL with resetting it back to NULL afterwards.\n+\t* dwarf2out.c (same_dw_val_p): For dw_val_class_addr compare with\n+\trtx_equal_p instead of asserting it is a SYMBOL_REF.\n+\t(value_format): For dw_val_class_addr only use DW_FORM_addr if\n+\tthe attribute type allows it, otherwise use DW_FORM_dataN.\n+\t(mem_loc_descriptor): Handle CONST_STRING.\n+\t(add_const_value_attribute): Handle CONST_STRING using add_AT_addr.\n+\tHandle MEM with CONST_STRING address using add_AT_string.\n+\t(rtl_for_decl_init): Return MEM with CONST_STRING address instead of\n+\tCONST_STRING for const arrays initialized with a string literal.\n+\t(resolve_one_addr, resolve_addr_in_expr, resolve_addr): New functions.\n+\t(dwarf2out_finish): Call resolve_addr.\n+\n 2009-10-02  Andreas Schwab  <schwab@linux-m68k.org>\n \t    Maxim Kuvyrkov  <maxim@codesourcery.com>\n  "}, {"sha": "2117ee3bc527d15345c797c2ad340cd83d26452e", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 20, "deletions": 3, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -2337,6 +2337,9 @@ expand_debug_expr (tree exp)\n     case STRING_CST:\n       if (!lookup_constant_def (exp))\n \t{\n+\t  if (strlen (TREE_STRING_POINTER (exp)) + 1\n+\t      != (size_t) TREE_STRING_LENGTH (exp))\n+\t    return NULL_RTX;\n \t  op0 = gen_rtx_CONST_STRING (Pmode, TREE_STRING_POINTER (exp));\n \t  op0 = gen_rtx_MEM (BLKmode, op0);\n \t  set_mem_attributes (op0, exp, 0);\n@@ -2368,9 +2371,23 @@ expand_debug_expr (tree exp)\n \n       /* This decl was probably optimized away.  */\n       if (!op0)\n-\treturn NULL;\n-\n-      op0 = copy_rtx (op0);\n+\t{\n+\t  if (TREE_CODE (exp) != VAR_DECL\n+\t      || DECL_EXTERNAL (exp)\n+\t      || !TREE_STATIC (exp)\n+\t      || !DECL_NAME (exp)\n+\t      || DECL_HARD_REGISTER (exp))\n+\t    return NULL;\n+\n+\t  op0 = DECL_RTL (exp);\n+ \t  SET_DECL_RTL (exp, NULL);\n+\t  if (!MEM_P (op0)\n+\t      || GET_CODE (XEXP (op0, 0)) != SYMBOL_REF\n+\t      || SYMBOL_REF_DECL (XEXP (op0, 0)) != exp)\n+\t    return NULL;\n+\t}\n+      else\n+\top0 = copy_rtx (op0);\n \n       if (GET_MODE (op0) == BLKmode)\n \t{"}, {"sha": "3a0e4f39af1e8425f8bf33abd8f8cccf199ca656", "filename": "gcc/dwarf2out.c", "status": "modified", "additions": 148, "deletions": 8, "changes": 156, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Fdwarf2out.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Fdwarf2out.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdwarf2out.c?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -5948,6 +5948,7 @@ static dw_loc_descr_ref multiple_reg_loc_descriptor (rtx, rtx,\n static dw_loc_descr_ref based_loc_descr (rtx, HOST_WIDE_INT,\n \t\t\t\t\t enum var_init_status);\n static int is_based_loc (const_rtx);\n+static int resolve_one_addr (rtx *, void *);\n static dw_loc_descr_ref mem_loc_descriptor (rtx, enum machine_mode mode,\n \t\t\t\t\t    enum var_init_status);\n static dw_loc_descr_ref concat_loc_descriptor (rtx, rtx,\n@@ -7905,8 +7906,7 @@ same_dw_val_p (const dw_val_node *v1, const dw_val_node *v2, int *mark)\n       r2 = v2->v.val_addr;\n       if (GET_CODE (r1) != GET_CODE (r2))\n \treturn 0;\n-      gcc_assert (GET_CODE (r1) == SYMBOL_REF);\n-      return !strcmp (XSTR (r1, 0), XSTR (r2, 0));\n+      return !rtx_equal_p (r1, r2);\n \n     case dw_val_class_offset:\n       return v1->v.val_offset == v2->v.val_offset;\n@@ -8662,7 +8662,30 @@ value_format (dw_attr_ref a)\n   switch (a->dw_attr_val.val_class)\n     {\n     case dw_val_class_addr:\n-      return DW_FORM_addr;\n+      /* Only very few attributes allow DW_FORM_addr.  */\n+      switch (a->dw_attr)\n+\t{\n+\tcase DW_AT_low_pc:\n+\tcase DW_AT_high_pc:\n+\tcase DW_AT_entry_pc:\n+\tcase DW_AT_trampoline:\n+\t  return DW_FORM_addr;\n+\tdefault:\n+\t  break;\n+\t}\n+      switch (DWARF2_ADDR_SIZE)\n+\t{\n+\tcase 1:\n+\t  return DW_FORM_data1;\n+\tcase 2:\n+\t  return DW_FORM_data2;\n+\tcase 4:\n+\t  return DW_FORM_data4;\n+\tcase 8:\n+\t  return DW_FORM_data8;\n+\tdefault:\n+\t  gcc_unreachable ();\n+\t}\n     case dw_val_class_range_list:\n     case dw_val_class_offset:\n     case dw_val_class_loc_list:\n@@ -11345,6 +11368,7 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       if (!const_ok_for_output (rtl))\n \tbreak;\n \n+    symref:\n       mem_loc_result = new_loc_descr (DW_OP_addr, 0, 0);\n       mem_loc_result->dw_loc_oprnd1.val_class = dw_val_class_addr;\n       mem_loc_result->dw_loc_oprnd1.v.val_addr = rtl;\n@@ -11759,8 +11783,8 @@ mem_loc_descriptor (rtx rtl, enum machine_mode mode,\n       break;\n \n     case CONST_STRING:\n-      /* These can't easily be tracked, see PR41404.  */\n-      break;\n+      resolve_one_addr (&rtl, NULL);\n+      goto symref;\n \n     default:\n #ifdef ENABLE_CHECKING\n@@ -13525,7 +13549,9 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n       return true;\n \n     case CONST_STRING:\n-      add_AT_string (die, DW_AT_const_value, XSTR (rtl, 0));\n+      resolve_one_addr (&rtl, NULL);\n+      add_AT_addr (die, DW_AT_const_value, rtl);\n+      VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n       return true;\n \n     case CONST:\n@@ -13558,6 +13584,16 @@ add_const_value_attribute (dw_die_ref die, rtx rtl)\n     case CONST_FIXED:\n       return false;\n \n+    case MEM:\n+      if (GET_CODE (XEXP (rtl, 0)) == CONST_STRING\n+\t  && MEM_READONLY_P (rtl)\n+\t  && GET_MODE (rtl) == BLKmode)\n+\t{\n+\t  add_AT_string (die, DW_AT_const_value, XSTR (XEXP (rtl, 0), 0));\n+\t  return true;\n+\t}\n+      return false;\n+\n     default:\n       /* No other kinds of rtx should be possible here.  */\n       gcc_unreachable ();\n@@ -13629,8 +13665,12 @@ rtl_for_decl_init (tree init, tree type)\n \t\t\t       TREE_STRING_LENGTH (init) - 1) == 0\n \t  && ((size_t) TREE_STRING_LENGTH (init)\n \t      == strlen (TREE_STRING_POINTER (init)) + 1))\n-\trtl = gen_rtx_CONST_STRING (VOIDmode,\n-\t\t\t\t    ggc_strdup (TREE_STRING_POINTER (init)));\n+\t{\n+\t  rtl = gen_rtx_CONST_STRING (VOIDmode,\n+\t\t\t\t      ggc_strdup (TREE_STRING_POINTER (init)));\n+\t  rtl = gen_rtx_MEM (BLKmode, rtl);\n+\t  MEM_READONLY_P (rtl) = 1;\n+\t}\n     }\n   /* Other aggregates, and complex values, could be represented using\n      CONCAT: FIXME!  */\n@@ -18982,6 +19022,104 @@ move_linkage_attr (dw_die_ref die)\n     }\n }\n \n+/* Helper function for resolve_addr, attempt to resolve\n+   one CONST_STRING, return non-zero if not successful.  Similarly verify that\n+   SYMBOL_REFs refer to variables emitted in the current CU.  */\n+\n+static int\n+resolve_one_addr (rtx *addr, void *data ATTRIBUTE_UNUSED)\n+{\n+  rtx rtl = *addr;\n+\n+  if (GET_CODE (rtl) == CONST_STRING)\n+    {\n+      size_t len = strlen (XSTR (rtl, 0)) + 1;\n+      tree t = build_string (len, XSTR (rtl, 0));\n+      tree tlen = build_int_cst (NULL_TREE, len - 1);\n+      TREE_TYPE (t)\n+\t= build_array_type (char_type_node, build_index_type (tlen));\n+      rtl = lookup_constant_def (t);\n+      if (!rtl || !MEM_P (rtl))\n+\treturn 1;\n+      rtl = XEXP (rtl, 0);\n+      VEC_safe_push (rtx, gc, used_rtx_array, rtl);\n+      *addr = rtl;\n+      return 0;\n+    }\n+\n+  if (GET_CODE (rtl) == SYMBOL_REF\n+      && SYMBOL_REF_DECL (rtl)\n+      && TREE_CODE (SYMBOL_REF_DECL (rtl)) == VAR_DECL\n+      && !TREE_ASM_WRITTEN (SYMBOL_REF_DECL (rtl)))\n+    return 1;\n+\n+  if (GET_CODE (rtl) == CONST\n+      && for_each_rtx (&XEXP (rtl, 0), resolve_one_addr, NULL))\n+    return 1;\n+\n+  return 0;\n+}\n+\n+/* Helper function for resolve_addr, handle one location\n+   expression, return false if at least one CONST_STRING or SYMBOL_REF in\n+   the location list couldn't be resolved.  */\n+\n+static bool\n+resolve_addr_in_expr (dw_loc_descr_ref loc)\n+{\n+  for (; loc; loc = loc->dw_loc_next)\n+    if ((loc->dw_loc_opc == DW_OP_addr\n+\t && resolve_one_addr (&loc->dw_loc_oprnd1.v.val_addr, NULL))\n+\t|| (loc->dw_loc_opc == DW_OP_implicit_value\n+\t    && loc->dw_loc_oprnd2.val_class == dw_val_class_addr\n+\t    && resolve_one_addr (&loc->dw_loc_oprnd2.v.val_addr, NULL)))\n+      return false;\n+  return true;\n+}\n+\n+/* Resolve DW_OP_addr and DW_AT_const_value CONST_STRING arguments to\n+   an address in .rodata section if the string literal is emitted there,\n+   or remove the containing location list or replace DW_AT_const_value\n+   with DW_AT_location and empty location expression, if it isn't found\n+   in .rodata.  Similarly for SYMBOL_REFs, keep only those that refer\n+   to something that has been emitted in the current CU.  */\n+\n+static void\n+resolve_addr (dw_die_ref die)\n+{\n+  dw_die_ref c;\n+  dw_attr_ref a;\n+  dw_loc_list_ref curr;\n+  unsigned ix;\n+\n+  for (ix = 0; VEC_iterate (dw_attr_node, die->die_attr, ix, a); ix++)\n+    switch (AT_class (a))\n+      {\n+      case dw_val_class_loc_list:\n+\tfor (curr = AT_loc_list (a); curr != NULL; curr = curr->dw_loc_next)\n+\t  if (!resolve_addr_in_expr (curr->expr))\n+\t    curr->expr = NULL;\n+\tbreak;\n+      case dw_val_class_loc:\n+\tif (!resolve_addr_in_expr (AT_loc (a)))\n+\t  a->dw_attr_val.v.val_loc = NULL;\n+\tbreak;\n+      case dw_val_class_addr:\n+\tif (a->dw_attr == DW_AT_const_value\n+\t    && resolve_one_addr (&a->dw_attr_val.v.val_addr, NULL))\n+\t  {\n+\t    a->dw_attr = DW_AT_location;\n+\t    a->dw_attr_val.val_class = dw_val_class_loc;\n+\t    a->dw_attr_val.v.val_loc = NULL;\n+\t  }\n+\tbreak;\n+      default:\n+\tbreak;\n+      }\n+\n+  FOR_EACH_CHILD (die, c, resolve_addr (c));\n+}\n+\n /* Output stuff that dwarf requires at the end of every file,\n    and generate the DWARF-2 debugging info.  */\n \n@@ -19072,6 +19210,8 @@ dwarf2out_finish (const char *filename)\n \n   limbo_die_list = NULL;\n \n+  resolve_addr (comp_unit_die);\n+\n   for (node = deferred_asm_name; node; node = node->next)\n     {\n       tree decl = node->created_for;"}, {"sha": "4bbabcb3fce3ba4d4d82a330f06d86794ac2821e", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -1,3 +1,10 @@\n+2009-10-02  Jakub Jelinek  <jakub@redhat.com>\n+\n+\tPR debug/41404\n+\tPR debug/41353\n+\t* gcc.dg/guality/pr41404-1.c: New test.\n+\t* gcc.dg/guality/pr41353-2.c: New test.\n+\n 2009-10-02  H.J. Lu  <hongjiu.lu@intel.com>\n \n \tPR testsuite/41546"}, {"sha": "3ff8d3691c8edc007fd977db1434a69d7b4692cb", "filename": "gcc/testsuite/gcc.dg/guality/pr41353-2.c", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41353-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41353-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41353-2.c?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -0,0 +1,24 @@\n+/* PR debug/41353 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+int varh;\n+int vari = 17, varj;\n+\n+__attribute__((noinline)) int\n+f1 (void)\n+{\n+  int vari1 = 2 * vari; /* { dg-final { gdb-test 13 \"vari1\" \"2 * 17\" } } */\n+  int vari2 = 3 * vari; /* { dg-final { gdb-test 13 \"vari2\" \"3 * 17\" } } */\n+  return varj;\n+}\n+\n+int (*volatile fnp1) (void) = f1;\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  asm volatile (\"\" : : \"r\" (&fnp1) : \"memory\");\n+  fnp1 ();\n+  return 0;\n+}"}, {"sha": "59a8293e62f81c060cfb9e600f1b5f90ae1ff1a6", "filename": "gcc/testsuite/gcc.dg/guality/pr41404-1.c", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41404-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e1b243a800307b7a731b5b3cf69a2d784498923b/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41404-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fguality%2Fpr41404-1.c?ref=e1b243a800307b7a731b5b3cf69a2d784498923b", "patch": "@@ -0,0 +1,41 @@\n+/* PR debug/41404 */\n+/* { dg-do run } */\n+/* { dg-options \"-g\" } */\n+\n+__attribute__ ((noinline))\n+int bar1 (int i)\n+{\n+  const char *foo = \"foo\";\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  i++;\t/* { dg-final { gdb-test 10 \"*foo\" \"'f'\" } } */\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  foo = \"bar\";\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  i++;\t/* { dg-final { gdb-test 14 \"*foo\" \"'b'\" } } */\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  return i;\n+}\n+\n+__attribute__ ((noinline))\n+int bar2 (int i)\n+{\n+  const char *foo = \"foo\";\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  i++;\t/* { dg-final { gdb-test 24 \"*foo\" \"'f'\" } } */\n+  asm volatile (\"\" : \"+r\" (i) : : \"memory\");\n+  return i;\n+}\n+\n+__attribute__ ((noinline))\n+const char *baz (int i)\n+{\n+  return i ? \"foo\" : \"bar\";\n+}\n+\n+int\n+main (void)\n+{\n+  bar1 (6);\n+  bar2 (6);\n+  return 0;\n+}"}]}