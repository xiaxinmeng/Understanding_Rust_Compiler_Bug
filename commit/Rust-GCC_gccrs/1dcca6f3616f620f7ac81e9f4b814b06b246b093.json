{"sha": "1dcca6f3616f620f7ac81e9f4b814b06b246b093", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWRjY2E2ZjM2MTZmNjIwZjdhYzgxZTlmNGI4MTRiMDZiMjQ2YjA5Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2005-11-16T17:04:41Z"}, "committer": {"name": "Daniel Jacobowitz", "email": "drow@gcc.gnu.org", "date": "2005-11-16T17:04:41Z"}, "message": "unwind-arm.h: Reorder interface function declarations.\n\n2005-11-16  Nathan Sidwell  <nathan@codesourcery.com>\ngcc/\n\t* config/arm/unwind-arm.h: Reorder interface function declarations.\n\t(_URC_END_OF_STACK): New enumeration value.\n\t(_US_UNWIND_ACTION_MASK, _US_FORCE_UNWIND, _US_END_OF_STACK): Likewise.\n\t(struct _Unwind_Control_Block): Document reserved field use.\n\t(_Unwind_Stop_Fn): New typedef.\n\t(_Unwind_ForcedUnwind): Declare.\n\t(_Unwind_Resume_or_Rethrow): Declare.\n\t* config/arm/libunwind.S (UNWIND_WRAPER): Add nargs\n\targument.  Adjust.\n\t(_Unwind_Resume_or_Rethrow, _Unwind_ForcedUnwind): New.\n\t* config/arm/unwind-arm.c (UCB_FORCED_STOP_FN)\n\t(UCB_FORCED_STOP_ARG): New.\n\t(search_EIT_table): Update boundary condition checks.\n\t(get_eit_entry): Return _URC_END_OF_STACK when cannot unwind.\n\t(unwind_phase2): Replace for with do..while.\n\t(unwind_phase2_forced): New.\n\t(__gnu_Unwind_RaiseException): Replace for with do..while.\n\t(__gnu_Unwind_ForcedUnwind): New.\n\t(__gnu_Unwind_Resume): Set FORCE_UNWIND flag, if forced unwinding.\n\tUse appropriate phase2 unwinder.\n\t(__gnu_Unwind_Resume_or_Rethrow): New.\n\t(__gnu_unwind_pr_common): Cope with forced unwinding.\ngcc/testsuite/\n\t* g++.dg/eh/forced1.C: Adjust to cope with ARM EABI\n\tstructures.\n\t* g++.dg/eh/forced2.C: Likewise.\n\t* g++.dg/eh/forced3.C: Likewise.\n\t* g++.dg/eh/forced4.C: Likewise.\nlibstdc++-v3/\n\t* libsupc++/eh_arm.cc (__cxa_begin_cleanup): Remember a\n\tforeign exception too.\n\t(__gnu_end_cleanup): Recover a foreign exception too.\n\t* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): Cope\n\twith forced unwinding.\n\t* libsupc++/eh_throw.cc (__cxxabiv1::__cxa_rethrow): Use\n\t_Unwind_Resume_or_Rethrow for ARM EABI.\n\nFrom-SVN: r107089", "tree": {"sha": "334b3d2a842b79dc3b040fb2439effee2404892f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/334b3d2a842b79dc3b040fb2439effee2404892f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1dcca6f3616f620f7ac81e9f4b814b06b246b093", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcca6f3616f620f7ac81e9f4b814b06b246b093", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1dcca6f3616f620f7ac81e9f4b814b06b246b093", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1dcca6f3616f620f7ac81e9f4b814b06b246b093/comments", "author": null, "committer": null, "parents": [{"sha": "8656214b84c3e789deffe8f7b465bd1c886b2a03", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8656214b84c3e789deffe8f7b465bd1c886b2a03", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8656214b84c3e789deffe8f7b465bd1c886b2a03"}], "stats": {"total": 336, "additions": 254, "deletions": 82}, "files": [{"sha": "34205f18fbb22ae064603d9199566cd8f348cce0", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -1,3 +1,28 @@\n+2005-11-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* config/arm/unwind-arm.h: Reorder interface function declarations.\n+\t(_URC_END_OF_STACK): New enumeration value.\n+\t(_US_UNWIND_ACTION_MASK, _US_FORCE_UNWIND, _US_END_OF_STACK): Likewise.\n+\t(struct _Unwind_Control_Block): Document reserved field use.\n+\t(_Unwind_Stop_Fn): New typedef.\n+\t(_Unwind_ForcedUnwind): Declare.\n+\t(_Unwind_Resume_or_Rethrow): Declare.\n+\t* gcc/config/arm/libunwind.S (UNWIND_WRAPER): Add nargs\n+\targument.  Adjust.\n+\t(_Unwind_Resume_or_Rethrow, _Unwind_ForcedUnwind): New.\n+\t* config/arm/unwind-arm.c (UCB_FORCED_STOP_FN)\n+\t(UCB_FORCED_STOP_ARG): New.\n+\t(search_EIT_table): Update boundary condition checks.\n+\t(get_eit_entry): Return _URC_END_OF_STACK when cannot unwind.\n+\t(unwind_phase2): Replace for with do..while.\n+\t(unwind_phase2_forced): New.\n+\t(__gnu_Unwind_RaiseException): Replace for with do..while.\n+\t(__gnu_Unwind_ForcedUnwind): New.\n+\t(__gnu_Unwind_Resume): Set FORCE_UNWIND flag, if forced unwinding.\n+\tUse appropriate phase2 unwinder.\n+\t(__gnu_Unwind_Resume_or_Rethrow): New.\n+\t(__gnu_unwind_pr_common): Cope with forced unwinding.\n+\n 2005-11-16  David Edelsohn  <edelsohn@gnu.org>\n \n \tPR target/24772"}, {"sha": "06e13107d2ab5a474ea696af626c260ebede31e8", "filename": "gcc/config/arm/libunwind.S", "status": "modified", "additions": 7, "deletions": 5, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Flibunwind.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Flibunwind.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Flibunwind.S?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -78,7 +78,7 @@ ARM_FUNC_START gnu_Unwind_Save_VFP\n \n /* Wrappers to save core registers, then call the real routine.   */\n \n-.macro  UNWIND_WRAPPER name\n+.macro  UNWIND_WRAPPER name nargs\n \tARM_FUNC_START \\name\n \t/* Create a phase2_vrs structure.  */\n \t/* Split reg push in two to ensure the correct value for sp.  */\n@@ -89,8 +89,8 @@ ARM_FUNC_START gnu_Unwind_Save_VFP\n \tmov r3, #0\n \tstmfd sp!, {r2, r3}\n \n-\t/* Point r1 at the block.  Pass r0 unchanged.  */\n-\tadd r1, sp, #4\n+\t/* Point r1 at the block.  Pass r[0..nargs) unchanged.  */\n+\tadd r\\nargs, sp, #4\n #if defined(__thumb__)\n \t/* Switch back to thumb mode to avoid interworking hassle.  */\n \tadr ip, .L1_\\name\n@@ -112,7 +112,9 @@ ARM_FUNC_START gnu_Unwind_Save_VFP\n \tUNPREFIX \\name\n .endm\n \n-UNWIND_WRAPPER _Unwind_RaiseException\n-UNWIND_WRAPPER _Unwind_Resume\n+UNWIND_WRAPPER _Unwind_RaiseException 1\n+UNWIND_WRAPPER _Unwind_Resume 1\n+UNWIND_WRAPPER _Unwind_Resume_or_Rethrow 1\n+UNWIND_WRAPPER _Unwind_ForcedUnwind 3\n \n #endif  /* __symbian__ */"}, {"sha": "4d703dbf09afe4fe4abc549694655c17a0f6ee59", "filename": "gcc/config/arm/unwind-arm.c", "status": "modified", "additions": 112, "deletions": 18, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Funwind-arm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Funwind-arm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.c?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -51,8 +51,10 @@ __gnu_Unwind_Find_exidx (_Unwind_Ptr, int *);\n #define EXIDX_CANTUNWIND 1\n #define uint32_highbit (((_uw) 1) << 31)\n \n+#define UCB_FORCED_STOP_FN(ucbp) ((ucbp)->unwinder_cache.reserved1)\n #define UCB_PR_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved2)\n #define UCB_SAVED_CALLSITE_ADDR(ucbp) ((ucbp)->unwinder_cache.reserved3)\n+#define UCB_FORCED_STOP_ARG(ucb) ((ucbp)->unwinder_cache.reserved4)\n \n struct core_regs\n {\n@@ -356,17 +358,17 @@ search_EIT_table (const __EIT_entry * table, int nrec, _uw return_address)\n       n = (left + right) / 2;\n       this_fn = selfrel_offset31 (&table[n].fnoffset);\n       if (n != nrec - 1)\n-\tnext_fn = selfrel_offset31 (&table[n + 1].fnoffset);\n+\tnext_fn = selfrel_offset31 (&table[n + 1].fnoffset) - 1;\n       else\n-\tnext_fn = ~(_uw) 0;\n+\tnext_fn = (_uw)0 - 1;\n \n       if (return_address < this_fn)\n \t{\n \t  if (n == left)\n \t    return (__EIT_entry *) 0;\n \t  right = n - 1;\n \t}\n-      else if (return_address < next_fn)\n+      else if (return_address <= next_fn)\n \treturn &table[n];\n       else\n \tleft = n + 1;\n@@ -419,7 +421,7 @@ get_eit_entry (_Unwind_Control_Block *ucbp, _uw return_address)\n   if (eitp->content == EXIDX_CANTUNWIND)\n     {\n       UCB_PR_ADDR (ucbp) = 0;\n-      return _URC_FAILURE;\n+      return _URC_END_OF_STACK;\n     }\n \n   /* Obtain the address of the \"real\" __EHT_Header word.  */\n@@ -472,28 +474,77 @@ unwind_phase2 (_Unwind_Control_Block * ucbp, phase2_vrs * vrs)\n {\n   _Unwind_Reason_Code pr_result;\n \n-  for(;;)\n+  do\n     {\n       /* Find the entry for this routine.  */\n       if (get_eit_entry (ucbp, vrs->core.r[R_PC]) != _URC_OK)\n \tabort ();\n \n       UCB_SAVED_CALLSITE_ADDR (ucbp) = vrs->core.r[R_PC];\n-      \n+\n       /* Call the pr to decide what to do.  */\n       pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_UNWIND_FRAME_STARTING, ucbp, (_Unwind_Context *) vrs);\n-\n-      if (pr_result != _URC_CONTINUE_UNWIND)\n-\tbreak;\n     }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n   \n   if (pr_result != _URC_INSTALL_CONTEXT)\n     abort();\n   \n   restore_core_regs (&vrs->core);\n }\n \n+/* Perform phase2 forced unwinding.  */\n+\n+static _Unwind_Reason_Code\n+unwind_phase2_forced (_Unwind_Control_Block *ucbp, phase2_vrs *entry_vrs)\n+{\n+  _Unwind_Stop_Fn stop_fn = (_Unwind_Stop_Fn) UCB_FORCED_STOP_FN (ucbp);\n+  void *stop_arg = (void *)UCB_FORCED_STOP_ARG (ucbp);\n+  _Unwind_Reason_Code pr_result;\n+\n+  /* Unwind until we reach a propagation barrier.  */\n+  do\n+    {\n+      _Unwind_State action;\n+      _Unwind_Reason_Code entry_code;\n+      _Unwind_Reason_Code stop_code;\n+\n+      /* Find the entry for this routine.  */\n+      entry_code = get_eit_entry (ucbp, entry_vrs->core.r[R_PC]);\n+\n+      action = _US_UNWIND_FRAME_STARTING | _US_FORCE_UNWIND;\n+      if (entry_code == _URC_END_OF_STACK)\n+\taction |= _US_END_OF_STACK;\n+      else if (entry_code != _URC_OK)\n+\treturn _URC_FAILURE;\n+\n+      stop_code = stop_fn (1, action, ucbp->exception_class, ucbp,\n+\t\t\t   (void *)entry_vrs, stop_arg);\n+      if (stop_code != _URC_NO_REASON)\n+\treturn _URC_FAILURE;\n+\n+      if (entry_code == _URC_END_OF_STACK)\n+\treturn entry_code;\n+\n+      UCB_SAVED_CALLSITE_ADDR (ucbp) = entry_vrs->core.r[R_PC];\n+\n+      /* Call the pr to decide what to do.  */\n+      pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n+\t(action, ucbp, (void *) entry_vrs);\n+    }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n+\n+  if (pr_result != _URC_INSTALL_CONTEXT)\n+    {\n+      /* Some sort of failure has occurred in the pr and probably the\n+\t pr returned _URC_FAILURE.  */\n+      return _URC_FAILURE;\n+    }\n+\n+  restore_core_regs (&entry_vrs->core);\n+}\n+\n /* Perform phase1 unwinding.  UCBP is the exception being thrown, and\n    entry_VRS is the register state on entry to _Unwind_RaiseException.  */\n \n@@ -516,7 +567,7 @@ __gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n   saved_vrs.demand_save_flags = ~(_uw) 0;\n   \n   /* Unwind until we reach a propagation barrier.  */\n-  for (;;)\n+  do\n     {\n       /* Find the entry for this routine.  */\n       if (get_eit_entry (ucbp, saved_vrs.core.r[R_PC]) != _URC_OK)\n@@ -525,10 +576,8 @@ __gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n       /* Call the pr to decide what to do.  */\n       pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n \t(_US_VIRTUAL_UNWIND_FRAME, ucbp, (void *) &saved_vrs);\n-\n-      if (pr_result != _URC_CONTINUE_UNWIND)\n-\tbreak;\n     }\n+  while (pr_result == _URC_CONTINUE_UNWIND);\n \n   /* We've unwound as far as we want to go, so restore the original\n      register state.  */\n@@ -546,20 +595,43 @@ __gnu_Unwind_RaiseException (_Unwind_Control_Block * ucbp,\n /* Resume unwinding after a cleanup has been run.  UCBP is the exception\n    being thrown and ENTRY_VRS is the register state on entry to\n    _Unwind_Resume.  */\n+_Unwind_Reason_Code\n+__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *,\n+\t\t\t   _Unwind_Stop_Fn, void *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_ForcedUnwind (_Unwind_Control_Block *ucbp,\n+\t\t\t   _Unwind_Stop_Fn stop_fn, void *stop_arg,\n+\t\t\t   phase2_vrs *entry_vrs)\n+{\n+  UCB_FORCED_STOP_FN (ucbp) = (_uw) stop_fn;\n+  UCB_FORCED_STOP_ARG (ucbp) = (_uw) stop_arg;\n+\n+  /* Set the pc to the call site.  */\n+  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n+\n+  return unwind_phase2_forced (ucbp, entry_vrs);\n+}\n+\n _Unwind_Reason_Code\n __gnu_Unwind_Resume (_Unwind_Control_Block *, phase2_vrs *);\n \n _Unwind_Reason_Code\n __gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n {\n   _Unwind_Reason_Code pr_result;\n+  _Unwind_State action;\n \n   /* Recover the saved address.  */\n   entry_vrs->core.r[R_PC] = UCB_SAVED_CALLSITE_ADDR (ucbp);\n-  \n+\n   /* Call the cached PR.  */\n+  action = _US_UNWIND_FRAME_RESUME;\n+  if (UCB_FORCED_STOP_FN (ucbp))\n+    action |= _US_FORCE_UNWIND;\n+\n   pr_result = ((personality_routine) UCB_PR_ADDR (ucbp))\n-\t(_US_UNWIND_FRAME_RESUME, ucbp, (_Unwind_Context *) entry_vrs);\n+\t(action, ucbp, (_Unwind_Context *) entry_vrs);\n \n   switch (pr_result)\n     {\n@@ -569,13 +641,32 @@ __gnu_Unwind_Resume (_Unwind_Control_Block * ucbp, phase2_vrs * entry_vrs)\n \n     case _URC_CONTINUE_UNWIND:\n       /* Continue unwinding the next frame.  */\n-      unwind_phase2 (ucbp, entry_vrs);\n+      if (UCB_FORCED_STOP_FN (ucbp))\n+\treturn unwind_phase2_forced (ucbp, entry_vrs);\n+      else\n+\tunwind_phase2 (ucbp, entry_vrs);\n \n     default:\n       abort ();\n     }\n }\n \n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block *, phase2_vrs *);\n+\n+_Unwind_Reason_Code\n+__gnu_Unwind_Resume_or_Rethrow (_Unwind_Control_Block * ucbp,\n+\t\t\t\tphase2_vrs * entry_vrs)\n+{\n+  if (!UCB_FORCED_STOP_FN (ucbp))\n+    return __gnu_Unwind_RaiseException (ucbp, entry_vrs);\n+\n+  /* Set the pc to the call site.  */\n+  entry_vrs->core.r[R_PC] = entry_vrs->core.r[R_LR];\n+  /* Continue unwinding the next frame.  */\n+  return unwind_phase2_forced (ucbp, entry_vrs);\n+}\n+\n /* Clean up an exception object when unwinding is complete.  */\n void\n _Unwind_Complete (_Unwind_Control_Block * ucbp __attribute__((unused)))\n@@ -619,6 +710,9 @@ __gnu_unwind_pr_common (_Unwind_State state,\n   _uw rtti_count;\n   int phase2_call_unexpected_after_unwind = 0;\n   int in_range = 0;\n+  int forced_unwind = state & _US_FORCE_UNWIND;\n+\n+  state &= _US_ACTION_MASK;\n \n   data = (_uw *) ucbp->pr_cache.ehtp;\n   uws.data = *(data++);\n@@ -748,9 +842,9 @@ __gnu_unwind_pr_common (_Unwind_State state,\n \t      /* Exception specification.  */\n \t      if (state == _US_VIRTUAL_UNWIND_FRAME)\n \t\t{\n-\t\t  if (in_range)\n+\t\t  if (in_range && (!forced_unwind || !rtti_count))\n \t\t    {\n-\t\t      /* Match against teh exception specification.  */\n+\t\t      /* Match against the exception specification.  */\n \t\t      _uw i;\n \t\t      _uw rtti;\n \t\t      void *matched;"}, {"sha": "f0c545ff797948f7bab3ab83f66318e83c175fd3", "filename": "gcc/config/arm/unwind-arm.h", "status": "modified", "additions": 41, "deletions": 32, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Funwind-arm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Fconfig%2Farm%2Funwind-arm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Farm%2Funwind-arm.h?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -1,5 +1,5 @@\n /* Header file for the ARM EABI unwinder\n-   Copyright (C) 2003, 2004  Free Software Foundation, Inc.\n+   Copyright (C) 2003, 2004, 2005  Free Software Foundation, Inc.\n    Contributed by Paul Brook\n \n    This file is free software; you can redistribute it and/or modify it\n@@ -54,39 +54,52 @@ extern \"C\" {\n     {\n       _URC_OK = 0,       /* operation completed successfully */\n       _URC_FOREIGN_EXCEPTION_CAUGHT = 1,\n+      _URC_END_OF_STACK = 5,\n       _URC_HANDLER_FOUND = 6,\n       _URC_INSTALL_CONTEXT = 7,\n       _URC_CONTINUE_UNWIND = 8,\n       _URC_FAILURE = 9   /* unspecified failure of some kind */\n     }\n   _Unwind_Reason_Code;\n-  \n+\n   typedef enum\n     {\n       _US_VIRTUAL_UNWIND_FRAME = 0,\n       _US_UNWIND_FRAME_STARTING = 1,\n-      _US_UNWIND_FRAME_RESUME = 2\n+      _US_UNWIND_FRAME_RESUME = 2,\n+      _US_ACTION_MASK = 3,\n+      _US_FORCE_UNWIND = 8,\n+      _US_END_OF_STACK = 16\n     }\n   _Unwind_State;\n-  \n+\n+  /* Provided only for for compatibility with existing code.  */\n+  typedef int _Unwind_Action;\n+#define _UA_SEARCH_PHASE\t1\n+#define _UA_CLEANUP_PHASE\t2\n+#define _UA_HANDLER_FRAME\t4\n+#define _UA_FORCE_UNWIND\t8\n+#define _UA_END_OF_STACK\t16\n+#define _URC_NO_REASON \t_URC_OK\n+\n   typedef struct _Unwind_Control_Block _Unwind_Control_Block;\n   typedef struct _Unwind_Context _Unwind_Context;\n   typedef _uw _Unwind_EHT_Header;\n-  \n-  \n+\n+\n   /* UCB: */\n-  \n+\n   struct _Unwind_Control_Block\n     {\n       char exception_class[8];\n       void (*exception_cleanup)(_Unwind_Reason_Code, _Unwind_Control_Block *);\n       /* Unwinder cache, private fields for the unwinder's use */\n       struct\n \t{\n-\t  _uw reserved1;\t/* init reserved1 to 0, then don't touch */\n-\t  _uw reserved2;\n-\t  _uw reserved3;\n-\t  _uw reserved4;\n+\t  _uw reserved1;  /* Forced unwind stop fn, 0 if not forced */\n+\t  _uw reserved2;  /* Personality routine address */\n+\t  _uw reserved3;  /* Saved callsite address */\n+\t  _uw reserved4;  /* Forced unwind stop arg */\n \t  _uw reserved5;\n \t}\n       unwinder_cache;\n@@ -114,14 +127,9 @@ extern \"C\" {\n       pr_cache;\n       long long int :0;\t/* Force alignment to 8-byte boundary */\n     };\n-  \n-  /* Interface functions: */\n-  _Unwind_Reason_Code _Unwind_RaiseException(_Unwind_Control_Block *ucbp);\n-  void __attribute__((noreturn)) _Unwind_Resume(_Unwind_Control_Block *ucbp);\n-  void _Unwind_Complete(_Unwind_Control_Block *ucbp);\n \n   /* Virtual Register Set*/\n-        \n+\n   typedef enum\n     {\n       _UVRSC_CORE = 0,      /* integer register */\n@@ -131,7 +139,7 @@ extern \"C\" {\n       _UVRSC_WMMXC = 4      /* Intel WMMX control register */\n     }\n   _Unwind_VRS_RegClass;\n-  \n+\n   typedef enum\n     {\n       _UVRSD_UINT32 = 0,\n@@ -142,13 +150,13 @@ extern \"C\" {\n       _UVRSD_DOUBLE = 5\n     }\n   _Unwind_VRS_DataRepresentation;\n-  \n+\n   typedef enum\n     {\n       _UVRSR_OK = 0,\n       _UVRSR_NOT_IMPLEMENTED = 1,\n       _UVRSR_FAILED = 2\n-    } \n+    }\n   _Unwind_VRS_Result;\n \n   /* Frame unwinding state.  */\n@@ -171,11 +179,11 @@ extern \"C\" {\n   _Unwind_VRS_Result _Unwind_VRS_Set(_Unwind_Context *, _Unwind_VRS_RegClass,\n                                      _uw, _Unwind_VRS_DataRepresentation,\n                                      void *);\n-  \n+\n   _Unwind_VRS_Result _Unwind_VRS_Get(_Unwind_Context *, _Unwind_VRS_RegClass,\n                                      _uw, _Unwind_VRS_DataRepresentation,\n                                      void *);\n-  \n+\n   _Unwind_VRS_Result _Unwind_VRS_Pop(_Unwind_Context *, _Unwind_VRS_RegClass,\n                                      _uw, _Unwind_VRS_DataRepresentation);\n \n@@ -200,6 +208,17 @@ extern \"C\" {\n       abort ();\n     }\n \n+  /* Interface functions: */\n+  _Unwind_Reason_Code _Unwind_RaiseException(_Unwind_Control_Block *ucbp);\n+  void __attribute__((noreturn)) _Unwind_Resume(_Unwind_Control_Block *ucbp);\n+  _Unwind_Reason_Code _Unwind_Resume_or_Rethrow (_Unwind_Control_Block *ucbp);\n+\n+  typedef _Unwind_Reason_Code (*_Unwind_Stop_Fn)\n+       (int, _Unwind_Action, _Unwind_Exception_Class,\n+\t_Unwind_Control_Block *, struct _Unwind_Context *, void *);\n+  _Unwind_Reason_Code _Unwind_ForcedUnwind (_Unwind_Control_Block *,\n+\t\t\t\t\t    _Unwind_Stop_Fn, void *);\n+  void _Unwind_Complete(_Unwind_Control_Block *ucbp);\n   void _Unwind_DeleteException (_Unwind_Exception *);\n \n   _Unwind_Reason_Code __gnu_unwind_frame (_Unwind_Control_Block *,\n@@ -254,16 +273,6 @@ extern \"C\" {\n #define _Unwind_SetIP(context, val) \\\n   _Unwind_SetGR (context, 15, val | (_Unwind_GetGR (context, 15) & 1))\n \n-  /* Provided only for for compatibility with existing code.  */\n-  typedef int _Unwind_Action;\n-#define _UA_SEARCH_PHASE\t1\n-#define _UA_CLEANUP_PHASE\t2\n-#define _UA_HANDLER_FRAME\t4\n-#define _UA_FORCE_UNWIND\t8\n-#define _UA_END_OF_STACK\t16\n-\n-#define _URC_NO_REASON _URC_OK\n-\n #ifdef __cplusplus\n }   /* extern \"C\" */\n #endif"}, {"sha": "63f6361687b64dbd07af517164a33058bcb30d4b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -1,3 +1,11 @@\n+2005-11-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* g++.dg/eh/forced1.C: Adjust to cope with ARM EABI\n+\tstructures.\n+\t* g++.dg/eh/forced2.C: Likewise.\n+\t* g++.dg/eh/forced3.C: Likewise.\n+\t* g++.dg/eh/forced4.C: Likewise.\n+\n 2005-11-11  Mike Stump  <mrs@apple.com>\n \n \t* g++.old-deja/g++.mike/unused.C: Add."}, {"sha": "b0200813ece8a63ad69be552a489f114a98726a7", "filename": "gcc/testsuite/g++.dg/eh/forced1.C", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced1.C?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -6,6 +6,7 @@\n \n #include <unwind.h>\n #include <stdlib.h>\n+#include <string.h>\n \n static int test = 0;\n \n@@ -35,7 +36,8 @@ force_unwind_cleanup (_Unwind_Reason_Code, struct _Unwind_Exception *)\n static void force_unwind ()\n {\n   _Unwind_Exception *exc = new _Unwind_Exception;\n-  exc->exception_class = 0;\n+  // exception_class might not be a scalar.\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n   exc->exception_cleanup = force_unwind_cleanup;\n \n #ifndef __USING_SJLJ_EXCEPTIONS__\n@@ -54,15 +56,14 @@ struct S\n   ~S() { test |= bit; }\n };\n   \n-static void doit ()\n+static __attribute__ ((noinline)) void doit ()\n {\n   try {\n     S four(4);\n \n     try {\n       S one(1);\n       force_unwind ();\n-  \n     } catch(...) { \n       test |= 2;\n       throw;"}, {"sha": "54586a006172d278f6cc39973ba63c75f9ea200d", "filename": "gcc/testsuite/g++.dg/eh/forced2.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced2.C?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -6,6 +6,7 @@\n \n #include <unwind.h>\n #include <stdlib.h>\n+#include <string.h>\n \n static _Unwind_Reason_Code\n force_unwind_stop (int version, _Unwind_Action actions,\n@@ -29,7 +30,8 @@ static void\n force_unwind ()\n {\n   _Unwind_Exception *exc = new _Unwind_Exception;\n-  exc->exception_class = 0;\n+  // exception_class might not be a scalar.\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n   exc->exception_cleanup = force_unwind_cleanup;\n \n #ifndef __USING_SJLJ_EXCEPTIONS__"}, {"sha": "96319d44ecd2955d65910ee269ea8e105d5ea9ef", "filename": "gcc/testsuite/g++.dg/eh/forced3.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced3.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced3.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced3.C?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -7,6 +7,7 @@\n #include <unwind.h>\n #include <stdlib.h>\n #include <exception>\n+#include <string.h>\n \n static _Unwind_Reason_Code\n force_unwind_stop (int version, _Unwind_Action actions,\n@@ -24,7 +25,8 @@ static void __attribute__((noreturn))\n force_unwind ()\n {\n   _Unwind_Exception *exc = new _Unwind_Exception;\n-  exc->exception_class = 0;\n+  // exception_class might not be a scalar.\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n   exc->exception_cleanup = 0;\n \n #ifndef __USING_SJLJ_EXCEPTIONS__"}, {"sha": "17fd94a40641884fed83982425868d17b56e4a9f", "filename": "gcc/testsuite/g++.dg/eh/forced4.C", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced4.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced4.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Feh%2Fforced4.C?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -6,6 +6,7 @@\n \n #include <unwind.h>\n #include <stdlib.h>\n+#include <string.h>\n \n static _Unwind_Reason_Code\n force_unwind_stop (int version, _Unwind_Action actions,\n@@ -23,7 +24,8 @@ static void __attribute__((noreturn))\n force_unwind ()\n {\n   _Unwind_Exception *exc = new _Unwind_Exception;\n-  exc->exception_class = 0;\n+  // exception_class might not be a scalar.\n+  memset (&exc->exception_class, 0, sizeof (exc->exception_class));\n   exc->exception_cleanup = 0;\n \n #ifndef __USING_SJLJ_EXCEPTIONS__"}, {"sha": "f84cefddd917c5a0582836dddeb35c853805bdc5", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -1,3 +1,13 @@\n+2005-11-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\t* libsupc++/eh_arm.cc (__cxa_begin_cleanup): Remember a\n+\tforeign exception too.\n+\t(__gnu_end_cleanup): Recover a foreign exception too.\n+\t* libsupc++/eh_personality.cc (PERSONALITY_FUNCTION): Cope\n+\twith forced unwinding.\n+\t* libsupc++/eh_throw.cc (__cxxabiv1::__cxa_rethrow): Use\n+\t_Unwind_Resume_or_Rethrow for ARM EABI.\n+\n 2005-11-14  Geoffrey Keating  <geoffk@apple.com>\n \n \t* acinclude.m4 (GLIBCXX_CHECK_LINKER_FEATURES): Don't check for"}, {"sha": "269b2ec95af725a01ccf2ee934e69a1d5dcdd378", "filename": "libstdc++-v3/libsupc++/eh_arm.cc", "status": "modified", "additions": 30, "deletions": 13, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_arm.cc?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -89,20 +89,31 @@ __cxa_begin_cleanup(_Unwind_Exception* ue_header)\n {\n   __cxa_eh_globals *globals = __cxa_get_globals();\n   __cxa_exception *header = __get_exception_header_from_ue(ue_header);\n+  bool native = __is_gxx_exception_class(header->unwindHeader.exception_class);\n \n-  if (!__is_gxx_exception_class(header->unwindHeader.exception_class))\n+\n+  if (native)\n     {\n-      // TODO: cleanups with foreign exceptions.\n-      return false;\n+      header->propagationCount++;\n+      // Add it to the chain if this is the first time we've seen this\n+      // exception.\n+      if (header->propagationCount == 1)\n+\t{\n+\t  header->nextPropagatingException = globals->propagatingExceptions;\n+\t  globals->propagatingExceptions = header;\n+\t}\n     }\n-  header->propagationCount++;\n-  // Add it to the chain if this is the first time we've seen this exception.\n-  if (header->propagationCount == 1)\n+  else\n     {\n-      header->nextPropagatingException = globals->propagatingExceptions;\n+      // Remember the exception object, so end_cleanup can return it.\n+      // These cannot be stacked, so we must abort if we already have\n+      // a propagating exception.\n+      if (globals->propagatingExceptions)\n+\tstd::terminate ();\n       globals->propagatingExceptions = header;\n     }\n-  return true;\n+\n+  return !native;\n }\n \n // Do the work for __cxa_end_cleanup.  Returns the currently propagating\n@@ -119,13 +130,19 @@ __gnu_end_cleanup(void)\n   if (!header)\n     std::terminate();\n \n-  header->propagationCount--;\n-  if (header->propagationCount == 0)\n+  if (__is_gxx_exception_class(header->unwindHeader.exception_class))\n     {\n-      // Remove exception from chain.\n-      globals->propagatingExceptions = header->nextPropagatingException;\n-      header->nextPropagatingException = NULL;\n+      header->propagationCount--;\n+      if (header->propagationCount == 0)\n+\t{\n+\t  // Remove exception from chain.\n+\t  globals->propagatingExceptions = header->nextPropagatingException;\n+\t  header->nextPropagatingException = NULL;\n+\t}\n     }\n+  else\n+    globals->propagatingExceptions = NULL;\n+\n   return &header->unwindHeader;\n }\n "}, {"sha": "f07864f1d6fa3994d436bf7b79aa76030a0a610a", "filename": "libstdc++-v3/libsupc++/eh_personality.cc", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_personality.cc?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -369,15 +369,16 @@ PERSONALITY_FUNCTION (int version,\n #ifdef __ARM_EABI_UNWINDER__\n   _Unwind_Action actions;\n \n-  switch (state)\n+  switch (state & _US_ACTION_MASK)\n     {\n     case _US_VIRTUAL_UNWIND_FRAME:\n       actions = _UA_SEARCH_PHASE;\n       break;\n \n     case _US_UNWIND_FRAME_STARTING:\n       actions = _UA_CLEANUP_PHASE;\n-      if (ue_header->barrier_cache.sp == _Unwind_GetGR(context, 13))\n+      if (!(state & _US_FORCE_UNWIND)\n+\t  && ue_header->barrier_cache.sp == _Unwind_GetGR(context, 13))\n \tactions |= _UA_HANDLER_FRAME;\n       break;\n \n@@ -388,6 +389,7 @@ PERSONALITY_FUNCTION (int version,\n     default:\n       abort();\n     }\n+  actions |= state & _US_FORCE_UNWIND;\n \n   // We don't know which runtime we're working with, so can't check this.\n   // However the ABI routines hide this from us, and we don't actually need\n@@ -523,13 +525,13 @@ PERSONALITY_FUNCTION (int version,\n       // exception class, there's no exception type.\n       // ??? What to do about GNU Java and GNU Ada exceptions.\n \n-#ifdef __ARM_EABI_UNWINDER__\n-      throw_type = ue_header;\n-#else\n       if ((actions & _UA_FORCE_UNWIND)\n \t  || foreign_exception)\n \tthrow_type = 0;\n       else\n+#ifdef __ARM_EABI_UNWINDER__\n+\tthrow_type = ue_header;\n+#else\n \tthrow_type = xh->exceptionType;\n #endif\n \n@@ -613,7 +615,6 @@ PERSONALITY_FUNCTION (int version,\n \n  install_context:\n   \n-#ifndef __ARM_EABI_UNWINDER__\n   // We can't use any of the cxa routines with foreign exceptions,\n   // because they all expect ue_header to be a struct __cxa_exception.\n   // So in that case, call terminate or unexpected directly.\n@@ -631,7 +632,6 @@ PERSONALITY_FUNCTION (int version,\n \t}\n     }\n   else\n-#endif\n     {\n       if (found_type == found_terminate)\n \t__cxa_call_terminate(ue_header);"}, {"sha": "9f26be008abfe642c761b8f03bf6f0b5662aeb40", "filename": "libstdc++-v3/libsupc++/eh_throw.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1dcca6f3616f620f7ac81e9f4b814b06b246b093/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Flibsupc%2B%2B%2Feh_throw.cc?ref=1dcca6f3616f620f7ac81e9f4b814b06b246b093", "patch": "@@ -97,7 +97,7 @@ __cxxabiv1::__cxa_rethrow ()\n #ifdef _GLIBCXX_SJLJ_EXCEPTIONS\n       _Unwind_SjLj_Resume_or_Rethrow (&header->unwindHeader);\n #else\n-#if defined(_LIBUNWIND_STD_ABI) || defined (__ARM_EABI_UNWINDER__)\n+#if defined(_LIBUNWIND_STD_ABI)\n       _Unwind_RaiseException (&header->unwindHeader);\n #else\n       _Unwind_Resume_or_Rethrow (&header->unwindHeader);"}]}