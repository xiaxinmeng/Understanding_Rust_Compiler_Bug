{"sha": "6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmRkOGY0YmI2MTU0YjBkODE5MGEwOTM2OWRjNTFiMmFjZDQyN2I5Mw==", "commit": {"author": {"name": "Bill Schmidt", "email": "wschmidt@linux.ibm.com", "date": "2012-07-26T13:10:04Z"}, "committer": {"name": "William Schmidt", "email": "wschmidt@gcc.gnu.org", "date": "2012-07-26T13:10:04Z"}, "message": "tree-ssa-loop-ivopts.c (mbc_entry_hash): Remove.\n\n2012-07-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n\n\t* tree-ssa-loop-ivopts.c (mbc_entry_hash): Remove.\n\t(mbc_entry_eq): Likewise.\n\t(mult_costs): Likewise.\n\t(cost_tables_exist): Likewise.\n\t(initialize_costs): Likewise.\n\t(finalize_costs): Likewise.\n\t(tree_ssa_iv_optimize_init): Remove call to initialize_costs.\n\t(add_regs_cost): Remove.\n\t(multiply_regs_cost): Likewise.\n\t(add_const_cost): Likewise.\n\t(extend_or_trunc_reg_cost): Likewise.\n\t(negate_reg_cost): Likewise.\n\t(struct mbc_entry): Likewise.\n\t(multiply_by_const_cost): Likewise.\n\t(get_address_cost): Change add_regs_cost calls to add_cost lookups;\n\tchange multiply_by_const_cost to mult_by_coeff_cost.\n\t(force_expr_to_var_cost): Likewise.\n\t(difference_cost): Change multiply_by_const_cost to mult_by_coeff_cost.\n\t(get_computation_cost_at): Change add_regs_cost calls to add_cost\n\tlookups; change multiply_by_const_cost to mult_by_coeff_cost.\n\t(determine_iv_cost): Change add_regs_cost calls to add_cost lookups.\n\t(tree_ssa_iv_optimize_finalize): Remove call to finalize_costs.\n\t* tree-ssa-address.c (expmed.h): New #include.\n\t(most_expensive_mult_to_index): Change multiply_by_const_cost to\n\tmult_by_coeff_cost.\n\t* gimple-ssa-strength-reduction.c (expmed.h): New #include.\n\t(stmt_cost): Change to use mult_by_coeff_cost, mul_cost, add_cost,\n\tneg_cost, and convert_cost instead of IVOPTS interfaces.\n\t(execute_strength_reduction): Remove calls to initialize_costs and\n\tfinalize_costs.\n\t* expmed.c (struct init_expmed_rtl): Add convert rtx_def.\n\t(init_expmed_one_mode): Initialize convert rtx_def; initialize\n\tx_convert_cost for related modes.\n\t(mult_by_coeff_cost): New function.\n\t* expmed.h (NUM_MODE_INT): New #define.\n\t(struct target_expmed): Add x_convert_cost matrix.\n\t(set_convert_cost): New inline function.\n\t(convert_cost): Likewise.\n\t(mult_by_coeff_cost): New extern decl.\n\t* tree-flow.h (initialize_costs): Remove decl.\n\t(finalize_costs): Likewise.\n\t(multiply_by_const_cost): Likewise.\n\t(add_regs_cost): Likewise.\n\t(multiply_regs_cost): Likewise.\n\t(add_const_cost): Likewise.\n\t(extend_or_trunc_reg_cost): Likewise.\n\t(negate_reg_cost): Likewise.\n\t* Makefile.in (gimple-ssa-strength-reduction.o): Update dependencies.\n\t(tree-ssa-address.o): Update dependencies.\n\nFrom-SVN: r189890", "tree": {"sha": "d1c32e077e8672a0302c870fe8ff5a2256a82879", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d1c32e077e8672a0302c870fe8ff5a2256a82879"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/comments", "author": null, "committer": null, "parents": [{"sha": "0263463dd114d7ea50230ae6c53e7031615b2ec8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0263463dd114d7ea50230ae6c53e7031615b2ec8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0263463dd114d7ea50230ae6c53e7031615b2ec8"}], "stats": {"total": 489, "additions": 171, "deletions": 318}, "files": [{"sha": "6f75076377b3b18b170d4eac1c763da1cedd5ca6", "filename": "gcc/ChangeLog", "status": "modified", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -1,3 +1,55 @@\n+2012-07-26  Bill Schmidt  <wschmidt@linux.ibm.com>\n+\n+\t* tree-ssa-loop-ivopts.c (mbc_entry_hash): Remove.\n+\t(mbc_entry_eq): Likewise.\n+\t(mult_costs): Likewise.\n+\t(cost_tables_exist): Likewise.\n+\t(initialize_costs): Likewise.\n+\t(finalize_costs): Likewise.\n+\t(tree_ssa_iv_optimize_init): Remove call to initialize_costs.\n+\t(add_regs_cost): Remove.\n+\t(multiply_regs_cost): Likewise.\n+\t(add_const_cost): Likewise.\n+\t(extend_or_trunc_reg_cost): Likewise.\n+\t(negate_reg_cost): Likewise.\n+\t(struct mbc_entry): Likewise.\n+\t(multiply_by_const_cost): Likewise.\n+\t(get_address_cost): Change add_regs_cost calls to add_cost lookups;\n+\tchange multiply_by_const_cost to mult_by_coeff_cost.\n+\t(force_expr_to_var_cost): Likewise.\n+\t(difference_cost): Change multiply_by_const_cost to mult_by_coeff_cost.\n+\t(get_computation_cost_at): Change add_regs_cost calls to add_cost\n+\tlookups; change multiply_by_const_cost to mult_by_coeff_cost.\n+\t(determine_iv_cost): Change add_regs_cost calls to add_cost lookups.\n+\t(tree_ssa_iv_optimize_finalize): Remove call to finalize_costs.\n+\t* tree-ssa-address.c (expmed.h): New #include.\n+\t(most_expensive_mult_to_index): Change multiply_by_const_cost to\n+\tmult_by_coeff_cost.\n+\t* gimple-ssa-strength-reduction.c (expmed.h): New #include.\n+\t(stmt_cost): Change to use mult_by_coeff_cost, mul_cost, add_cost,\n+\tneg_cost, and convert_cost instead of IVOPTS interfaces.\n+\t(execute_strength_reduction): Remove calls to initialize_costs and\n+\tfinalize_costs.\n+\t* expmed.c (struct init_expmed_rtl): Add convert rtx_def.\n+\t(init_expmed_one_mode): Initialize convert rtx_def; initialize\n+\tx_convert_cost for related modes.\n+\t(mult_by_coeff_cost): New function.\n+\t* expmed.h (NUM_MODE_INT): New #define.\n+\t(struct target_expmed): Add x_convert_cost matrix.\n+\t(set_convert_cost): New inline function.\n+\t(convert_cost): Likewise.\n+\t(mult_by_coeff_cost): New extern decl.\n+\t* tree-flow.h (initialize_costs): Remove decl.\n+\t(finalize_costs): Likewise.\n+\t(multiply_by_const_cost): Likewise.\n+\t(add_regs_cost): Likewise.\n+\t(multiply_regs_cost): Likewise.\n+\t(add_const_cost): Likewise.\n+\t(extend_or_trunc_reg_cost): Likewise.\n+\t(negate_reg_cost): Likewise.\n+\t* Makefile.in (gimple-ssa-strength-reduction.o): Update dependencies.\n+\t(tree-ssa-address.o): Update dependencies.\n+\n 2012-07-26  Steven Bosscher  <steven@gcc.gnu.org>\n \n \t* bitmap.h: Add explanation of sparse set as linked-list bitmap."}, {"sha": "7633282c575afc8a75c1923b7232b7b665d370af", "filename": "gcc/Makefile.in", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FMakefile.in?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -2355,7 +2355,7 @@ gimple-ssa-strength-reduction.o : gimple-ssa-strength-reduction.c $(CONFIG_H) \\\n    $(SYSTEM_H) coretypes.h $(TREE_H) $(GIMPLE_H) $(BASIC_BLOCK_H) \\\n    $(TREE_PASS_H) $(CFGLOOP_H) $(TREE_PRETTY_PRINT_H) \\\n    $(GIMPLE_PRETTY_PRINT_H) alloc-pool.h $(TREE_FLOW_H) domwalk.h \\\n-   pointer-set.h\n+   pointer-set.h expmed.h\n tree-vrp.o : tree-vrp.c $(CONFIG_H) $(SYSTEM_H) coretypes.h $(TM_H) $(TREE_H) \\\n    $(TREE_FLOW_H) $(TREE_PASS_H) $(DIAGNOSTIC_CORE_H) $(GGC_H) \\\n    $(BASIC_BLOCK_H) tree-ssa-propagate.h $(FLAGS_H) $(TREE_DUMP_H) \\\n@@ -2423,7 +2423,7 @@ tree-ssa-address.o : tree-ssa-address.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(DIAGNOSTIC_H) $(TM_H) coretypes.h dumpfile.h \\\n    $(FLAGS_H) $(TREE_INLINE_H) $(RECOG_H) insn-config.h \\\n    $(EXPR_H) gt-tree-ssa-address.h $(GGC_H) tree-affine.h $(TARGET_H) \\\n-   $(TREE_PRETTY_PRINT_H)\n+   $(TREE_PRETTY_PRINT_H) expmed.h\n tree-ssa-loop-niter.o : tree-ssa-loop-niter.c $(TREE_FLOW_H) $(CONFIG_H) \\\n    $(SYSTEM_H) $(TREE_H) $(TM_P_H) $(CFGLOOP_H) $(PARAMS_H) \\\n    $(TREE_INLINE_H) $(DIAGNOSTIC_H) $(TM_H) coretypes.h dumpfile.h \\"}, {"sha": "e660a3f65a174daa2d7bbeecb8f671162c39a661", "filename": "gcc/expmed.c", "status": "modified", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fexpmed.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fexpmed.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.c?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -112,6 +112,7 @@ struct init_expmed_rtl\n   struct rtx_def shift_add;\trtunion shift_add_fld1;\n   struct rtx_def shift_sub0;\trtunion shift_sub0_fld1;\n   struct rtx_def shift_sub1;\trtunion shift_sub1_fld1;\n+  struct rtx_def convert;\n \n   rtx pow2[MAX_BITS_PER_WORD];\n   rtx cint[MAX_BITS_PER_WORD];\n@@ -122,6 +123,7 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \t\t      enum machine_mode mode, int speed)\n {\n   int m, n, mode_bitsize;\n+  enum machine_mode mode_from;\n \n   mode_bitsize = GET_MODE_UNIT_BITSIZE (mode);\n \n@@ -139,6 +141,7 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n   PUT_MODE (&all->shift_add, mode);\n   PUT_MODE (&all->shift_sub0, mode);\n   PUT_MODE (&all->shift_sub1, mode);\n+  PUT_MODE (&all->convert, mode);\n \n   add_cost[speed][mode] = set_src_cost (&all->plus, speed);\n   neg_cost[speed][mode] = set_src_cost (&all->neg, speed);\n@@ -183,6 +186,30 @@ init_expmed_one_mode (struct init_expmed_rtl *all,\n \t  mul_highpart_cost[speed][mode]\n \t    = set_src_cost (&all->wide_trunc, speed);\n \t}\n+\n+      for (mode_from = GET_CLASS_NARROWEST_MODE (MODE_INT);\n+\t   mode_from != VOIDmode;\n+\t   mode_from = GET_MODE_WIDER_MODE (mode_from))\n+\tif (mode != mode_from)\n+\t  {\n+\t    unsigned short size_to = GET_MODE_SIZE (mode);\n+\t    unsigned short size_from = GET_MODE_SIZE (mode_from);\n+\t    if (size_to < size_from)\n+\t      {\n+\t\tPUT_CODE (&all->convert, TRUNCATE);\n+\t\tPUT_MODE (&all->reg, mode_from);\n+\t\tset_convert_cost (mode, mode_from, speed,\n+\t\t\t\t  set_src_cost (&all->convert, speed));\n+\t      }\n+\t    else if (size_from < size_to)\n+\t      {\n+\t\t/* Assume cost of zero-extend and sign-extend is the same.  */\n+\t\tPUT_CODE (&all->convert, ZERO_EXTEND);\n+\t\tPUT_MODE (&all->reg, mode_from);\n+\t\tset_convert_cost (mode, mode_from, speed,\n+\t\t\t\t  set_src_cost (&all->convert, speed));\n+\t      }\n+\t  }\n     }\n }\n \n@@ -262,6 +289,9 @@ init_expmed (void)\n   XEXP (&all.shift_sub1, 0) = &all.reg;\n   XEXP (&all.shift_sub1, 1) = &all.shift_mult;\n \n+  PUT_CODE (&all.convert, TRUNCATE);\n+  XEXP (&all.convert, 0) = &all.reg;\n+\n   for (speed = 0; speed < 2; speed++)\n     {\n       crtl->maybe_hot_insn_p = speed;\n@@ -3262,6 +3292,24 @@ expand_mult (enum machine_mode mode, rtx op0, rtx op1, rtx target,\n   return op0;\n }\n \n+/* Return a cost estimate for multiplying a register by the given\n+   COEFFicient in the given MODE and SPEED.  */\n+\n+int\n+mult_by_coeff_cost (HOST_WIDE_INT coeff, enum machine_mode mode, bool speed)\n+{\n+  int max_cost;\n+  struct algorithm algorithm;\n+  enum mult_variant variant;\n+\n+  rtx fake_reg = gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1);\n+  max_cost = set_src_cost (gen_rtx_MULT (mode, fake_reg, fake_reg), speed);\n+  if (choose_mult_variant (mode, coeff, &algorithm, &variant, max_cost))\n+    return algorithm.cost.cost;\n+  else\n+    return max_cost;\n+}\n+\n /* Perform a widening multiplication and return an rtx for the result.\n    MODE is mode of value; OP0 and OP1 are what to multiply (rtx's);\n    TARGET is a suggestion for where to store the result (an rtx)."}, {"sha": "ea141bc26294306c7efb919ba05be0d538b22ba9", "filename": "gcc/expmed.h", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fexpmed.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fexpmed.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpmed.h?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -124,6 +124,8 @@ struct alg_hash_entry {\n #define NUM_ALG_HASH_ENTRIES 307\n #endif\n \n+#define NUM_MODE_INT (MAX_MODE_INT - MIN_MODE_INT + 1)\n+\n /* Target-dependent globals.  */\n struct target_expmed {\n   /* Each entry of ALG_HASH caches alg_code for some integer.  This is\n@@ -155,6 +157,11 @@ struct target_expmed {\n   int x_udiv_cost[2][NUM_MACHINE_MODES];\n   int x_mul_widen_cost[2][NUM_MACHINE_MODES];\n   int x_mul_highpart_cost[2][NUM_MACHINE_MODES];\n+\n+  /* Conversion costs are only defined between two scalar integer modes\n+     of different sizes.  The first machine mode is the destination mode,\n+     and the second is the source mode.  */\n+  int x_convert_cost[2][NUM_MODE_INT][NUM_MODE_INT];\n };\n \n extern struct target_expmed default_target_expmed;\n@@ -197,4 +204,43 @@ extern struct target_expmed *this_target_expmed;\n #define mul_highpart_cost \\\n   (this_target_expmed->x_mul_highpart_cost)\n \n+/* Set the COST for converting from FROM_MODE to TO_MODE when optimizing\n+   for SPEED.  */\n+\n+static inline void\n+set_convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n+\t\t  bool speed, int cost)\n+{\n+  int to_idx, from_idx;\n+\n+  gcc_assert (to_mode >= MIN_MODE_INT\n+\t      && to_mode <= MAX_MODE_INT\n+\t      && from_mode >= MIN_MODE_INT\n+\t      && from_mode <= MAX_MODE_INT);\n+\n+  to_idx = to_mode - MIN_MODE_INT;\n+  from_idx = from_mode - MIN_MODE_INT;\n+  this_target_expmed->x_convert_cost[speed][to_idx][from_idx] = cost;\n+}\n+\n+/* Return the cost for converting from FROM_MODE to TO_MODE when optimizing\n+   for SPEED.  */\n+\n+static inline int\n+convert_cost (enum machine_mode to_mode, enum machine_mode from_mode,\n+\t      bool speed)\n+{\n+  int to_idx, from_idx;\n+\n+  gcc_assert (to_mode >= MIN_MODE_INT\n+\t      && to_mode <= MAX_MODE_INT\n+\t      && from_mode >= MIN_MODE_INT\n+\t      && from_mode <= MAX_MODE_INT);\n+\n+  to_idx = to_mode - MIN_MODE_INT;\n+  from_idx = from_mode - MIN_MODE_INT;\n+  return this_target_expmed->x_convert_cost[speed][to_idx][from_idx];\n+}\n+\n+extern int mult_by_coeff_cost (HOST_WIDE_INT, enum machine_mode, bool);\n #endif"}, {"sha": "afeb70fdeb099bffd6b39d0c5ab59f88c2f4b076", "filename": "gcc/gimple-ssa-strength-reduction.c", "status": "modified", "additions": 6, "deletions": 16, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fgimple-ssa-strength-reduction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Fgimple-ssa-strength-reduction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple-ssa-strength-reduction.c?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -54,6 +54,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-flow.h\"\n #include \"domwalk.h\"\n #include \"pointer-set.h\"\n+#include \"expmed.h\"\n \f\n /* Information about a strength reduction candidate.  Each statement\n    in the candidate table represents an expression of one of the\n@@ -340,29 +341,22 @@ stmt_cost (gimple gs, bool speed)\n       rhs2 = gimple_assign_rhs2 (gs);\n \n       if (host_integerp (rhs2, 0))\n-\treturn multiply_by_const_cost (TREE_INT_CST_LOW (rhs2), lhs_mode,\n-\t\t\t\t       speed);\n+\treturn mult_by_coeff_cost (TREE_INT_CST_LOW (rhs2), lhs_mode, speed);\n \n       gcc_assert (TREE_CODE (rhs1) != INTEGER_CST);\n-      return multiply_regs_cost (TYPE_MODE (TREE_TYPE (lhs)), speed);\n+      return mul_cost[speed][lhs_mode];\n \n     case PLUS_EXPR:\n     case POINTER_PLUS_EXPR:\n     case MINUS_EXPR:\n       rhs2 = gimple_assign_rhs2 (gs);\n-\n-      if (host_integerp (rhs2, 0))\n-\treturn add_const_cost (TYPE_MODE (TREE_TYPE (rhs1)), speed);\n-\n-      gcc_assert (TREE_CODE (rhs1) != INTEGER_CST);\n-      return add_regs_cost (lhs_mode, speed);\n+      return add_cost[speed][lhs_mode];\n \n     case NEGATE_EXPR:\n-      return negate_reg_cost (lhs_mode, speed);\n+      return neg_cost[speed][lhs_mode];\n \n     case NOP_EXPR:\n-      return extend_or_trunc_reg_cost (TREE_TYPE (lhs), TREE_TYPE (rhs1),\n-\t\t\t\t       speed);\n+      return convert_cost (lhs_mode, TYPE_MODE (TREE_TYPE (rhs1)), speed);\n \n     /* Note that we don't assign costs to copies that in most cases\n        will go away.  */\n@@ -1460,9 +1454,6 @@ execute_strength_reduction (void)\n      back edges, and this gives us dominator information as well.  */\n   loop_optimizer_init (AVOID_CFG_MODIFICATIONS);\n \n-  /* Initialize costs tables in IVOPTS.  */\n-  initialize_costs ();\n-\n   /* Set up callbacks for the generic dominator tree walker.  */\n   walk_data.dom_direction = CDI_DOMINATORS;\n   walk_data.initialize_block_local_data = NULL;\n@@ -1493,7 +1484,6 @@ execute_strength_reduction (void)\n   pointer_map_destroy (stmt_cand_map);\n   VEC_free (slsr_cand_t, heap, cand_vec);\n   obstack_free (&cand_obstack, NULL);\n-  finalize_costs ();\n \n   return 0;\n }"}, {"sha": "9ed6c0c7bcb4ae594a8c3ada1a1a7bd85c4222f1", "filename": "gcc/tree-flow.h", "status": "modified", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-flow.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-flow.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-flow.h?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -806,14 +806,6 @@ bool expr_invariant_in_loop_p (struct loop *, tree);\n bool stmt_invariant_in_loop_p (struct loop *, gimple);\n bool multiplier_allowed_in_address_p (HOST_WIDE_INT, enum machine_mode,\n \t\t\t\t      addr_space_t);\n-void initialize_costs (void);\n-void finalize_costs (void);\n-unsigned multiply_by_const_cost (HOST_WIDE_INT, enum machine_mode, bool);\n-unsigned add_regs_cost (enum machine_mode, bool);\n-unsigned multiply_regs_cost (enum machine_mode, bool);\n-unsigned add_const_cost (enum machine_mode, bool);\n-unsigned extend_or_trunc_reg_cost (tree, tree, bool);\n-unsigned negate_reg_cost (enum machine_mode, bool);\n bool may_be_nonaddressable_p (tree expr);\n \n /* In tree-ssa-threadupdate.c.  */"}, {"sha": "ddab7d85e59e5bd4ab50ea1de53eca67e42472cd", "filename": "gcc/tree-ssa-address.c", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-ssa-address.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-ssa-address.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-address.c?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -42,6 +42,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"expr.h\"\n #include \"ggc.h\"\n #include \"target.h\"\n+#include \"expmed.h\"\n \n /* TODO -- handling of symbols (according to Richard Hendersons\n    comments, http://gcc.gnu.org/ml/gcc-patches/2005-04/msg00949.html):\n@@ -554,7 +555,7 @@ most_expensive_mult_to_index (tree type, struct mem_address *parts,\n \t  || !multiplier_allowed_in_address_p (coef, TYPE_MODE (type), as))\n \tcontinue;\n \n-      acost = multiply_by_const_cost (coef, address_mode, speed);\n+      acost = mult_by_coeff_cost (coef, address_mode, speed);\n \n       if (acost > best_mult_cost)\n \t{"}, {"sha": "0d3e1bf0d56075a9aaee88d2ddc2dfa7a8370a09", "filename": "gcc/tree-ssa-loop-ivopts.c", "status": "modified", "additions": 15, "deletions": 291, "changes": 306, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-ssa-loop-ivopts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6dd8f4bb6154b0d8190a09369dc51b2acd427b93/gcc%2Ftree-ssa-loop-ivopts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivopts.c?ref=6dd8f4bb6154b0d8190a09369dc51b2acd427b93", "patch": "@@ -88,9 +88,6 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-ssa-propagate.h\"\n #include \"expmed.h\"\n \n-static hashval_t mbc_entry_hash (const void *);\n-static int mbc_entry_eq (const void*, const void *);\n-\n /* FIXME: Expressions are expanded to RTL in this pass to determine the\n    cost of different addressing modes.  This should be moved to a TBD\n    interface between the GIMPLE and RTL worlds.  */\n@@ -381,11 +378,6 @@ struct iv_ca_delta\n \n static VEC(tree,heap) *decl_rtl_to_reset;\n \n-/* Cached costs for multiplies by constants, and a flag to indicate\n-   when they're valid.  */\n-static htab_t mult_costs[2];\n-static bool cost_tables_exist = false;\n-\n static comp_cost force_expr_to_var_cost (tree, bool);\n \n /* Number of uses recorded in DATA.  */\n@@ -851,26 +843,6 @@ htab_inv_expr_hash (const void *ent)\n   return expr->hash;\n }\n \n-/* Allocate data structures for the cost model.  */\n-\n-void\n-initialize_costs (void)\n-{\n-  mult_costs[0] = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n-  mult_costs[1] = htab_create (100, mbc_entry_hash, mbc_entry_eq, free);\n-  cost_tables_exist = true;\n-}\n-\n-/* Release data structures for the cost model.  */\n-\n-void\n-finalize_costs (void)\n-{\n-  cost_tables_exist = false;\n-  htab_delete (mult_costs[0]);\n-  htab_delete (mult_costs[1]);\n-}\n-\n /* Initializes data structures used by the iv optimization pass, stored\n    in DATA.  */\n \n@@ -889,8 +861,6 @@ tree_ssa_iv_optimize_init (struct ivopts_data *data)\n                                     htab_inv_expr_eq, free);\n   data->inv_expr_id = 0;\n   decl_rtl_to_reset = VEC_alloc (tree, heap, 20);\n-\n-  initialize_costs ();\n }\n \n /* Returns a memory object to that EXPR points.  In case we are able to\n@@ -3077,250 +3047,6 @@ adjust_setup_cost (struct ivopts_data *data, unsigned cost)\n     return cost;\n }\n \n-/* Returns cost of addition in MODE.  */\n-\n-unsigned\n-add_regs_cost (enum machine_mode mode, bool speed)\n-{\n-  static unsigned costs[NUM_MACHINE_MODES][2];\n-  rtx seq;\n-  unsigned cost;\n-\n-  if (costs[mode][speed])\n-    return costs[mode][speed];\n-\n-  start_sequence ();\n-  force_operand (gen_rtx_fmt_ee (PLUS, mode,\n-\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n-\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 2)),\n-\t\t NULL_RTX);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-  if (!cost)\n-    cost = 1;\n-\n-  costs[mode][speed] = cost;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Addition in %s costs %d\\n\",\n-\t     GET_MODE_NAME (mode), cost);\n-  return cost;\n-}\n-\n-/* Returns cost of multiplication in MODE.  */\n-\n-unsigned\n-multiply_regs_cost (enum machine_mode mode, bool speed)\n-{\n-  static unsigned costs[NUM_MACHINE_MODES][2];\n-  rtx seq;\n-  unsigned cost;\n-\n-  if (costs[mode][speed])\n-    return costs[mode][speed];\n-\n-  start_sequence ();\n-  force_operand (gen_rtx_fmt_ee (MULT, mode,\n-\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n-\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 2)),\n-\t\t NULL_RTX);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-  if (!cost)\n-    cost = 1;\n-\n-  costs[mode][speed] = cost;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Multiplication in %s costs %d\\n\",\n-\t     GET_MODE_NAME (mode), cost);\n-  return cost;\n-}\n-\n-/* Returns cost of addition with a constant in MODE.  */\n-\n-unsigned\n-add_const_cost (enum machine_mode mode, bool speed)\n-{\n-  static unsigned costs[NUM_MACHINE_MODES][2];\n-  rtx seq;\n-  unsigned cost;\n-\n-  if (costs[mode][speed])\n-    return costs[mode][speed];\n-\n-  /* Arbitrarily generate insns for x + 2, as the exact constant\n-     shouldn't matter.  */\n-  start_sequence ();\n-  force_operand (gen_rtx_fmt_ee (PLUS, mode,\n-\t\t\t\t gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n-\t\t\t\t gen_int_mode (2, mode)),\n-\t\t NULL_RTX);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-  if (!cost)\n-    cost = 1;\n-\n-  costs[mode][speed] = cost;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Addition to constant in %s costs %d\\n\",\n-\t     GET_MODE_NAME (mode), cost);\n-  return cost;\n-}\n-\n-/* Returns cost of extend or truncate in MODE.  */\n-\n-unsigned\n-extend_or_trunc_reg_cost (tree type_to, tree type_from, bool speed)\n-{\n-  static unsigned costs[NUM_MACHINE_MODES][NUM_MACHINE_MODES][2];\n-  rtx seq;\n-  unsigned cost;\n-  enum machine_mode mode_to = TYPE_MODE (type_to);\n-  enum machine_mode mode_from = TYPE_MODE (type_from);\n-  tree size_to = TYPE_SIZE (type_to);\n-  tree size_from = TYPE_SIZE (type_from);\n-  enum rtx_code code;\n-\n-  gcc_assert (TREE_CODE (size_to) == INTEGER_CST\n-\t      && TREE_CODE (size_from) == INTEGER_CST);\n-\n-  if (costs[mode_to][mode_from][speed])\n-    return costs[mode_to][mode_from][speed];\n-\n-  if (tree_int_cst_lt (size_to, size_from))\n-    code = TRUNCATE;\n-  else if (TYPE_UNSIGNED (type_to))\n-    code = ZERO_EXTEND;\n-  else\n-    code = SIGN_EXTEND;\n-\n-  start_sequence ();\n-  gen_rtx_fmt_e (code, mode_to,\n-\t\t gen_raw_REG (mode_from, LAST_VIRTUAL_REGISTER + 1));\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-  if (!cost)\n-    cost = 1;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Conversion from %s to %s costs %d\\n\",\n-\t     GET_MODE_NAME (mode_to), GET_MODE_NAME (mode_from), cost);\n-\n-  costs[mode_to][mode_from][speed] = cost;\n-  return cost;\n-}\n-\n-/* Returns cost of negation in MODE.  */\n-\n-unsigned\n-negate_reg_cost (enum machine_mode mode, bool speed)\n-{\n-  static unsigned costs[NUM_MACHINE_MODES][2];\n-  rtx seq;\n-  unsigned cost;\n-\n-  if (costs[mode][speed])\n-    return costs[mode][speed];\n-\n-  start_sequence ();\n-  force_operand (gen_rtx_fmt_e (NEG, mode,\n-\t\t\t\tgen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1)),\n-\t\t NULL_RTX);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-  if (!cost)\n-    cost = 1;\n-\n-  costs[mode][speed] = cost;\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Negation in %s costs %d\\n\",\n-\t     GET_MODE_NAME (mode), cost);\n-  return cost;\n-}\n-\n-/* Entry in a hashtable of already known costs for multiplication.  */\n-struct mbc_entry\n-{\n-  HOST_WIDE_INT cst;\t\t/* The constant to multiply by.  */\n-  enum machine_mode mode;\t/* In mode.  */\n-  unsigned cost;\t\t/* The cost.  */\n-};\n-\n-/* Counts hash value for the ENTRY.  */\n-\n-static hashval_t\n-mbc_entry_hash (const void *entry)\n-{\n-  const struct mbc_entry *e = (const struct mbc_entry *) entry;\n-\n-  return 57 * (hashval_t) e->mode + (hashval_t) (e->cst % 877);\n-}\n-\n-/* Compares the hash table entries ENTRY1 and ENTRY2.  */\n-\n-static int\n-mbc_entry_eq (const void *entry1, const void *entry2)\n-{\n-  const struct mbc_entry *e1 = (const struct mbc_entry *) entry1;\n-  const struct mbc_entry *e2 = (const struct mbc_entry *) entry2;\n-\n-  return (e1->mode == e2->mode\n-\t  && e1->cst == e2->cst);\n-}\n-\n-/* Returns cost of multiplication by constant CST in MODE.  */\n-\n-unsigned\n-multiply_by_const_cost (HOST_WIDE_INT cst, enum machine_mode mode, bool speed)\n-{\n-  struct mbc_entry **cached, act;\n-  rtx seq;\n-  unsigned cost;\n-\n-  gcc_assert (cost_tables_exist);\n-\n-  act.mode = mode;\n-  act.cst = cst;\n-  cached = (struct mbc_entry **)\n-    htab_find_slot (mult_costs[speed], &act, INSERT);\n-    \n-  if (*cached)\n-    return (*cached)->cost;\n-\n-  *cached = XNEW (struct mbc_entry);\n-  (*cached)->mode = mode;\n-  (*cached)->cst = cst;\n-\n-  start_sequence ();\n-  expand_mult (mode, gen_raw_REG (mode, LAST_VIRTUAL_REGISTER + 1),\n-\t       gen_int_mode (cst, mode), NULL_RTX, 0);\n-  seq = get_insns ();\n-  end_sequence ();\n-\n-  cost = seq_cost (seq, speed);\n-\n-  if (dump_file && (dump_flags & TDF_DETAILS))\n-    fprintf (dump_file, \"Multiplication by %d in %s costs %d\\n\",\n-\t     (int) cst, GET_MODE_NAME (mode), cost);\n-\n-  (*cached)->cost = cost;\n-\n-  return cost;\n-}\n-\n /* Returns true if multiplying by RATIO is allowed in an address.  Test the\n    validity for a memory reference accessing memory of mode MODE in\n    address space AS.  */\n@@ -3582,7 +3308,7 @@ get_address_cost (bool symbol_present, bool var_present,\n \t If VAR_PRESENT is true, try whether the mode with\n \t SYMBOL_PRESENT = false is cheaper even with cost of addition, and\n \t if this is the case, use it.  */\n-      add_c = add_regs_cost (address_mode, speed);\n+      add_c = add_cost[speed][address_mode];\n       for (i = 0; i < 8; i++)\n \t{\n \t  var_p = i & 1;\n@@ -3663,10 +3389,10 @@ get_address_cost (bool symbol_present, bool var_present,\n \t     && multiplier_allowed_in_address_p (ratio, mem_mode, as));\n \n   if (ratio != 1 && !ratio_p)\n-    cost += multiply_by_const_cost (ratio, address_mode, speed);\n+    cost += mult_by_coeff_cost (ratio, address_mode, speed);\n \n   if (s_offset && !offset_p && !symbol_present)\n-    cost += add_regs_cost (address_mode, speed);\n+    cost += add_cost[speed][address_mode];\n \n   if (may_autoinc)\n     *may_autoinc = autoinc;\n@@ -3833,7 +3559,7 @@ force_expr_to_var_cost (tree expr, bool speed)\n     case PLUS_EXPR:\n     case MINUS_EXPR:\n     case NEGATE_EXPR:\n-      cost = new_cost (add_regs_cost (mode, speed), 0);\n+      cost = new_cost (add_cost[speed][mode], 0);\n       if (TREE_CODE (expr) != NEGATE_EXPR)\n         {\n           tree mult = NULL_TREE;\n@@ -3853,11 +3579,11 @@ force_expr_to_var_cost (tree expr, bool speed)\n \n     case MULT_EXPR:\n       if (cst_and_fits_in_hwi (op0))\n-\tcost = new_cost (multiply_by_const_cost (int_cst_value (op0),\n-\t\t\t\t\t\t mode, speed), 0);\n+\tcost = new_cost (mult_by_coeff_cost (int_cst_value (op0),\n+\t\t\t\t\t     mode, speed), 0);\n       else if (cst_and_fits_in_hwi (op1))\n-\tcost = new_cost (multiply_by_const_cost (int_cst_value (op1),\n-\t\t\t\t\t\t mode, speed), 0);\n+\tcost = new_cost (mult_by_coeff_cost (int_cst_value (op1),\n+\t\t\t\t\t     mode, speed), 0);\n       else\n \treturn new_cost (target_spill_cost [speed], 0);\n       break;\n@@ -4023,7 +3749,7 @@ difference_cost (struct ivopts_data *data,\n   if (integer_zerop (e1))\n     {\n       comp_cost cost = force_var_cost (data, e2, depends_on);\n-      cost.cost += multiply_by_const_cost (-1, mode, data->speed);\n+      cost.cost += mult_by_coeff_cost (-1, mode, data->speed);\n       return cost;\n     }\n \n@@ -4334,7 +4060,7 @@ get_computation_cost_at (struct ivopts_data *data,\n \t\t\t\t\t &symbol_present, &var_present,\n \t\t\t\t\t &offset, depends_on));\n       cost.cost /= avg_loop_niter (data->current_loop);\n-      cost.cost += add_regs_cost (TYPE_MODE (ctype), data->speed);\n+      cost.cost += add_cost[data->speed][TYPE_MODE (ctype)];\n     }\n \n   if (inv_expr_id)\n@@ -4367,26 +4093,26 @@ get_computation_cost_at (struct ivopts_data *data,\n   if (!symbol_present && !var_present && !offset)\n     {\n       if (ratio != 1)\n-\tcost.cost += multiply_by_const_cost (ratio, TYPE_MODE (ctype), speed);\n+\tcost.cost += mult_by_coeff_cost (ratio, TYPE_MODE (ctype), speed);\n       return cost;\n     }\n \n   /* Symbol + offset should be compile-time computable so consider that they\n       are added once to the variable, if present.  */\n   if (var_present && (symbol_present || offset))\n     cost.cost += adjust_setup_cost (data,\n-\t\t\t\t    add_regs_cost (TYPE_MODE (ctype), speed));\n+\t\t\t\t    add_cost[speed][TYPE_MODE (ctype)]);\n \n   /* Having offset does not affect runtime cost in case it is added to\n      symbol, but it increases complexity.  */\n   if (offset)\n     cost.complexity++;\n \n-  cost.cost += add_regs_cost (TYPE_MODE (ctype), speed);\n+  cost.cost += add_cost[speed][TYPE_MODE (ctype)];\n \n   aratio = ratio > 0 ? ratio : -ratio;\n   if (aratio != 1)\n-    cost.cost += multiply_by_const_cost (aratio, TYPE_MODE (ctype), speed);\n+    cost.cost += mult_by_coeff_cost (aratio, TYPE_MODE (ctype), speed);\n   return cost;\n \n fallback:\n@@ -5232,7 +4958,7 @@ determine_iv_cost (struct ivopts_data *data, struct iv_cand *cand)\n      or a const set.  */\n   if (cost_base.cost == 0)\n     cost_base.cost = COSTS_N_INSNS (1);\n-  cost_step = add_regs_cost (TYPE_MODE (TREE_TYPE (base)), data->speed);\n+  cost_step = add_cost[data->speed][TYPE_MODE (TREE_TYPE (base))];\n \n   cost = cost_step + adjust_setup_cost (data, cost_base.cost);\n \n@@ -6804,8 +6530,6 @@ tree_ssa_iv_optimize_finalize (struct ivopts_data *data)\n   VEC_free (iv_use_p, heap, data->iv_uses);\n   VEC_free (iv_cand_p, heap, data->iv_candidates);\n   htab_delete (data->inv_expr_tab);\n-\n-  finalize_costs ();\n }\n \n /* Returns true if the loop body BODY includes any function calls.  */"}]}