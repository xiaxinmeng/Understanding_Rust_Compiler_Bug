{"sha": "fe920c2d9f479c2b17d6963973cf11efe0169293", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmU5MjBjMmQ5ZjQ3OWMyYjE3ZDY5NjM5NzNjZjExZWZlMDE2OTI5Mw==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2017-09-01T19:00:42Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2017-09-01T19:00:42Z"}, "message": "cp-tree.h (resort_type_method_vec): Move declaration to ...\n\n\t* cp-tree.h (resort_type_method_vec): Move declaration to ...\n\t* name-lookup.h (resort_type_method_vec): ... here.\n\t(set_class_bindings): Lose 2nd arg.\n\t* class.c (finish_struct_1, finish_struct): Adjust\n\tset_class_bindings call.  Don't call finish_struct_methods.\n\t(resort_data, method_name_cmp, resort_method_name_cmp,\n\tresort_type_method_vec, finish_struct_methods): Move to ...\n\t* name-lookup.c (resort_data, method_name_cmp,\n\tresort_method_name_cmp, resort_type_method_vec): ... here.\n\t(set_class_bindings): Lose fields arg.  Swallow finish_struct_methods.\n\nFrom-SVN: r251609", "tree": {"sha": "c0d88f5d8f3f436d5dc59db6a43da3de0dbcc103", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c0d88f5d8f3f436d5dc59db6a43da3de0dbcc103"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe920c2d9f479c2b17d6963973cf11efe0169293", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe920c2d9f479c2b17d6963973cf11efe0169293", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe920c2d9f479c2b17d6963973cf11efe0169293", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe920c2d9f479c2b17d6963973cf11efe0169293/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "61abf964185ad736e1cd400dcd2583acfc050b4b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/61abf964185ad736e1cd400dcd2583acfc050b4b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/61abf964185ad736e1cd400dcd2583acfc050b4b"}], "stats": {"total": 158, "additions": 76, "deletions": 82}, "files": [{"sha": "55cf4a02e8206e81fc89dc186ef55cc7c3a555d2", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=fe920c2d9f479c2b17d6963973cf11efe0169293", "patch": "@@ -1,5 +1,16 @@\n 2017-09-01  Nathan Sidwell  <nathan@acm.org>\n \n+\t* cp-tree.h (resort_type_method_vec): Move declaration to ...\n+\t* name-lookup.h (resort_type_method_vec): ... here.\n+\t(set_class_bindings): Lose 2nd arg.\n+\t* class.c (finish_struct_1, finish_struct): Adjust\n+\tset_class_bindings call.  Don't call finish_struct_methods.\n+\t(resort_data, method_name_cmp, resort_method_name_cmp,\n+\tresort_type_method_vec, finish_struct_methods): Move to ...\n+\t* name-lookup.c (resort_data, method_name_cmp,\n+\tresort_method_name_cmp, resort_type_method_vec): ... here.\n+\t(set_class_bindings): Lose fields arg.  Swallow finish_struct_methods.\n+\n \t* class.c (finish_struct): Call set_class_bindings for the\n \ttemplate case too.\n "}, {"sha": "e5f237cb0525cc55eaf0c9c1960b1acb29975c1d", "filename": "gcc/cp/class.c", "status": "modified", "additions": 2, "deletions": 77, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=fe920c2d9f479c2b17d6963973cf11efe0169293", "patch": "@@ -129,10 +129,7 @@ static void handle_using_decl (tree, tree);\n static tree dfs_modify_vtables (tree, void *);\n static tree modify_all_vtables (tree, tree);\n static void determine_primary_bases (tree);\n-static void finish_struct_methods (tree);\n static void maybe_warn_about_overly_private_class (tree);\n-static int method_name_cmp (const void *, const void *);\n-static int resort_method_name_cmp (const void *, const void *);\n static void add_implicitly_declared_members (tree, tree*, int, int);\n static tree fixed_type_or_null (tree, int *, int *);\n static tree build_simple_base_path (tree expr, tree binfo);\n@@ -2247,76 +2244,6 @@ maybe_warn_about_overly_private_class (tree t)\n     }\n }\n \n-static struct {\n-  gt_pointer_operator new_value;\n-  void *cookie;\n-} resort_data;\n-\n-/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n-\n-static int\n-method_name_cmp (const void* m1_p, const void* m2_p)\n-{\n-  const tree *const m1 = (const tree *) m1_p;\n-  const tree *const m2 = (const tree *) m2_p;\n-\n-  if (OVL_NAME (*m1) < OVL_NAME (*m2))\n-    return -1;\n-  return 1;\n-}\n-\n-/* This routine compares two fields like method_name_cmp but using the\n-   pointer operator in resort_field_decl_data.  */\n-\n-static int\n-resort_method_name_cmp (const void* m1_p, const void* m2_p)\n-{\n-  const tree *const m1 = (const tree *) m1_p;\n-  const tree *const m2 = (const tree *) m2_p;\n-\n-  tree n1 = OVL_NAME (*m1);\n-  tree n2 = OVL_NAME (*m2);\n-  resort_data.new_value (&n1, resort_data.cookie);\n-  resort_data.new_value (&n2, resort_data.cookie);\n-  if (n1 < n2)\n-    return -1;\n-  return 1;\n-}\n-\n-/* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n-\n-void\n-resort_type_method_vec (void* obj,\n-\t\t\tvoid* /*orig_obj*/,\n-\t\t\tgt_pointer_operator new_value,\n-\t\t\tvoid* cookie)\n-{\n-  if (vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj)\n-    {\n-      resort_data.new_value = new_value;\n-      resort_data.cookie = cookie;\n-      qsort (method_vec->address (), method_vec->length (), sizeof (tree),\n-\t     resort_method_name_cmp);\n-    }\n-}\n-\n-/* Warn about duplicate methods in fn_fields.\n-\n-   Sort methods that are not special (i.e., constructors, destructors,\n-   and type conversion operators) so that we can find them faster in\n-   search.  */\n-\n-static void\n-finish_struct_methods (tree t)\n-{\n-  vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (t);\n-  if (!method_vec)\n-    return;\n-\n-  qsort (method_vec->address (), method_vec->length (),\n-\t sizeof (tree), method_name_cmp);\n-}\n-\n /* Make BINFO's vtable have N entries, including RTTI entries,\n    vbase and vcall offsets, etc.  Set its type and call the back end\n    to lay it out.  */\n@@ -6966,8 +6893,7 @@ finish_struct_1 (tree t)\n   layout_class_type (t, &virtuals);\n   /* COMPLETE_TYPE_P is now true.  */\n \n-  finish_struct_methods (t);\n-  set_class_bindings (t, TYPE_FIELDS (t));\n+  set_class_bindings (t);\n \n   if (CLASSTYPE_AS_BASE (t) != t)\n     /* We use the base type for trivial assignments, and hence it\n@@ -7187,8 +7113,7 @@ finish_struct (tree t, tree attributes)\n       TYPE_SIZE_UNIT (t) = size_zero_node;\n       /* COMPLETE_TYPE_P is now true.  */\n \n-      finish_struct_methods (t);\n-      set_class_bindings (t, TYPE_FIELDS (t));\n+      set_class_bindings (t);\n \n       /* We need to emit an error message if this type was used as a parameter\n \t and it is an abstract type, even if it is a template. We construct"}, {"sha": "432faa9da14879dc777c6a3fdd0aef91a1dc3db1", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=fe920c2d9f479c2b17d6963973cf11efe0169293", "patch": "@@ -5952,8 +5952,6 @@ extern tree convert_to_base_statically\t\t(tree, tree);\n extern tree build_vtbl_ref\t\t\t(tree, tree);\n extern tree build_vfn_ref\t\t\t(tree, tree);\n extern tree get_vtable_decl\t\t\t(tree, int);\n-extern void resort_type_method_vec\t\t(void *, void *,\n-\t\t\t\t\t\t gt_pointer_operator, void *);\n extern bool add_method\t\t\t\t(tree, tree, bool);\n extern tree declared_access\t\t\t(tree);\n extern tree currently_open_class\t\t(tree);"}, {"sha": "f4b9ff1f85893004fec8443a73a9756097692311", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 60, "deletions": 2, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=fe920c2d9f479c2b17d6963973cf11efe0169293", "patch": "@@ -1312,6 +1312,59 @@ lookup_fnfields_slot (tree type, tree name)\n   return lookup_fnfields_slot_nolazy (type, name);\n }\n \n+static struct {\n+  gt_pointer_operator new_value;\n+  void *cookie;\n+} resort_data;\n+\n+/* Comparison function to compare two TYPE_METHOD_VEC entries by name.  */\n+\n+static int\n+method_name_cmp (const void* m1_p, const void* m2_p)\n+{\n+  const tree *const m1 = (const tree *) m1_p;\n+  const tree *const m2 = (const tree *) m2_p;\n+\n+  if (OVL_NAME (*m1) < OVL_NAME (*m2))\n+    return -1;\n+  return 1;\n+}\n+\n+/* This routine compares two fields like method_name_cmp but using the\n+   pointer operator in resort_field_decl_data.  */\n+\n+static int\n+resort_method_name_cmp (const void* m1_p, const void* m2_p)\n+{\n+  const tree *const m1 = (const tree *) m1_p;\n+  const tree *const m2 = (const tree *) m2_p;\n+\n+  tree n1 = OVL_NAME (*m1);\n+  tree n2 = OVL_NAME (*m2);\n+  resort_data.new_value (&n1, resort_data.cookie);\n+  resort_data.new_value (&n2, resort_data.cookie);\n+  if (n1 < n2)\n+    return -1;\n+  return 1;\n+}\n+\n+/* Resort TYPE_METHOD_VEC because pointers have been reordered.  */\n+\n+void\n+resort_type_method_vec (void* obj,\n+\t\t\tvoid* /*orig_obj*/,\n+\t\t\tgt_pointer_operator new_value,\n+\t\t\tvoid* cookie)\n+{\n+  if (vec<tree, va_gc> *method_vec = (vec<tree, va_gc> *) obj)\n+    {\n+      resort_data.new_value = new_value;\n+      resort_data.cookie = cookie;\n+      qsort (method_vec->address (), method_vec->length (), sizeof (tree),\n+\t     resort_method_name_cmp);\n+    }\n+}\n+\n /* Allocate and return an instance of struct sorted_fields_type with\n    N fields.  */\n \n@@ -1383,11 +1436,16 @@ add_enum_fields_to_record_type (tree enumtype,\n }\n \n /* Insert FIELDS into KLASS for the sorted case if the FIELDS count is\n-   big enough.  */\n+   big enough.  Sort the METHOD_VEC too.  */\n \n void \n-set_class_bindings (tree klass, tree fields)\n+set_class_bindings (tree klass)\n {\n+  if (vec<tree, va_gc> *method_vec = CLASSTYPE_METHOD_VEC (klass))\n+    qsort (method_vec->address (), method_vec->length (),\n+\t   sizeof (tree), method_name_cmp);\n+\n+  tree fields = TYPE_FIELDS (klass);\n   int n_fields = count_fields (fields);\n   if (n_fields >= 8)\n     {"}, {"sha": "94d2aaa49173619a4cec040ec1669f5fabf58b6c", "filename": "gcc/cp/name-lookup.h", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fname-lookup.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe920c2d9f479c2b17d6963973cf11efe0169293/gcc%2Fcp%2Fname-lookup.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.h?ref=fe920c2d9f479c2b17d6963973cf11efe0169293", "patch": "@@ -322,7 +322,9 @@ extern tree lookup_arg_dependent (tree, tree, vec<tree, va_gc> *);\n extern tree lookup_field_1\t\t\t(tree, tree, bool);\n extern tree lookup_fnfields_slot\t\t(tree, tree);\n extern tree lookup_fnfields_slot_nolazy\t\t(tree, tree);\n-extern void set_class_bindings (tree, tree);\n+extern void resort_type_method_vec (void *, void *,\n+\t\t\t\t    gt_pointer_operator, void *);\n+extern void set_class_bindings (tree);\n extern void insert_late_enum_def_bindings (tree, tree);\n extern tree innermost_non_namespace_value (tree);\n extern cxx_binding *outer_binding (tree, cxx_binding *, bool);"}]}