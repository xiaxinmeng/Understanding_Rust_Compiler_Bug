{"sha": "0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlNWEzMmYzMWU5NDZhNDJmMDdkMjVmN2ZkYWE3Y2JiYTU3YTk5NA==", "commit": {"author": {"name": "Ayal Zaks", "email": "zaks@il.ibm.com", "date": "2008-02-25T11:28:10Z"}, "committer": {"name": "Revital Eres", "email": "revitale@gcc.gnu.org", "date": "2008-02-25T11:28:10Z"}, "message": "SMS: Revisit order of insns within a row\n\nCo-Authored-By: Revital Eres <eres@il.ibm.com>\n\nFrom-SVN: r132615", "tree": {"sha": "641ae3c29d4bd54356e7b7104c172fa2c71b6303", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/641ae3c29d4bd54356e7b7104c172fa2c71b6303"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de5a32f31e946a42f07d25f7fdaa7cbba57a994/comments", "author": null, "committer": null, "parents": [{"sha": "d4cba6d4428b397b7fd4e0d602f1d076ee363aea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4cba6d4428b397b7fd4e0d602f1d076ee363aea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4cba6d4428b397b7fd4e0d602f1d076ee363aea"}], "stats": {"total": 53, "additions": 39, "deletions": 14}, "files": [{"sha": "5b2f80f007bc0ae81922019b47ea144b83147984", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de5a32f31e946a42f07d25f7fdaa7cbba57a994/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de5a32f31e946a42f07d25f7fdaa7cbba57a994/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "patch": "@@ -1,3 +1,9 @@\n+2008-02-25  Ayal Zaks  <zaks@il.ibm.com>\n+\tRevital Eres  <eres@il.ibm.com>\n+\n+\t* modulo-sched.c (calculate_must_precede_follow): Address TODO\n+\tregarding the order of two dependent insns in the same row.\n+\n 2008-02-25  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* stor-layout.c (layout_decl): Do not bump the alignment of a"}, {"sha": "3d710ad6a434c4195d1832c1c1c8d1947d7ad4fe", "filename": "gcc/modulo-sched.c", "status": "modified", "additions": 33, "deletions": 14, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de5a32f31e946a42f07d25f7fdaa7cbba57a994/gcc%2Fmodulo-sched.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de5a32f31e946a42f07d25f7fdaa7cbba57a994/gcc%2Fmodulo-sched.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmodulo-sched.c?ref=0de5a32f31e946a42f07d25f7fdaa7cbba57a994", "patch": "@@ -1587,18 +1587,17 @@ get_sched_window (partial_schedule_ptr ps, int *nodes_order, int i,\n \n /* Calculate MUST_PRECEDE/MUST_FOLLOW bitmaps of U_NODE; which is the\n    node currently been scheduled.  At the end of the calculation\n-   MUST_PRECEDE/MUST_FOLLOW contains all predecessors/successors of U_NODE\n-   which are in SCHED_NODES (already scheduled nodes) and scheduled at\n-   the same row as the first/last row of U_NODE's scheduling window.\n+   MUST_PRECEDE/MUST_FOLLOW contains all predecessors/successors of\n+   U_NODE which are (1) already scheduled in the first/last row of\n+   U_NODE's scheduling window, (2) whose dependence inequality with U\n+   becomes an equality when U is scheduled in this same row, and (3)\n+   whose dependence latency is zero.\n+\n    The first and last rows are calculated using the following parameters:\n    START/END rows - The cycles that begins/ends the traversal on the window;\n    searching for an empty cycle to schedule U_NODE.\n    STEP - The direction in which we traverse the window.\n-   II - The initiation interval.\n-   TODO: We can add an insn to the must_precede/must_follow bitmap only\n-   if it has tight dependence to U and they are both scheduled in the\n-   same row.  The current check is more conservative and content with\n-   the fact that both U and the insn are scheduled in the same row.  */\n+   II - The initiation interval.  */\n \n static void\n calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n@@ -1607,7 +1606,6 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n {\n   ddg_edge_ptr e;\n   int first_cycle_in_window, last_cycle_in_window;\n-  int first_row_in_window, last_row_in_window;\n \n   gcc_assert (must_precede && must_follow);\n \n@@ -1621,18 +1619,27 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n   first_cycle_in_window = (step == 1) ? start : end - step;\n   last_cycle_in_window = (step == 1) ? end - step : start;\n \n-  first_row_in_window = SMODULO (first_cycle_in_window, ii);\n-  last_row_in_window = SMODULO (last_cycle_in_window, ii);\n-\n   sbitmap_zero (must_precede);\n   sbitmap_zero (must_follow);\n \n   if (dump_file)\n     fprintf (dump_file, \"\\nmust_precede: \");\n \n+  /* Instead of checking if:\n+      (SMODULO (SCHED_TIME (e->src), ii) == first_row_in_window)\n+      && ((SCHED_TIME (e->src) + e->latency - (e->distance * ii)) ==\n+             first_cycle_in_window)\n+      && e->latency == 0\n+     we use the fact that latency is non-negative:\n+      SCHED_TIME (e->src) - (e->distance * ii) <=\n+      SCHED_TIME (e->src) + e->latency - (e->distance * ii)) <=\n+      first_cycle_in_window\n+     and check only if\n+      SCHED_TIME (e->src) - (e->distance * ii) == first_cycle_in_window  */\n   for (e = u_node->in; e != 0; e = e->next_in)\n     if (TEST_BIT (sched_nodes, e->src->cuid)\n-\t&& (SMODULO (SCHED_TIME (e->src), ii) == first_row_in_window))\n+\t&& ((SCHED_TIME (e->src) - (e->distance * ii)) ==\n+             first_cycle_in_window))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"%d \", e->src->cuid);\n@@ -1643,9 +1650,21 @@ calculate_must_precede_follow (ddg_node_ptr u_node, int start, int end,\n   if (dump_file)\n     fprintf (dump_file, \"\\nmust_follow: \");\n \n+  /* Instead of checking if:\n+      (SMODULO (SCHED_TIME (e->dest), ii) == last_row_in_window)\n+      && ((SCHED_TIME (e->dest) - e->latency + (e->distance * ii)) ==\n+             last_cycle_in_window)\n+      && e->latency == 0\n+     we use the fact that latency is non-negative:\n+      SCHED_TIME (e->dest) + (e->distance * ii) >=\n+      SCHED_TIME (e->dest) - e->latency + (e->distance * ii)) >= \n+      last_cycle_in_window\n+     and check only if\n+      SCHED_TIME (e->dest) + (e->distance * ii) == last_cycle_in_window  */\n   for (e = u_node->out; e != 0; e = e->next_out)\n     if (TEST_BIT (sched_nodes, e->dest->cuid)\n-\t&& (SMODULO (SCHED_TIME (e->dest), ii) == last_row_in_window))\n+\t&& ((SCHED_TIME (e->dest) + (e->distance * ii)) ==\n+             last_cycle_in_window))\n       {\n \tif (dump_file)\n \t  fprintf (dump_file, \"%d \", e->dest->cuid);"}]}