{"sha": "de5206613ed98eac1e9b142079458314b66ada83", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZGU1MjA2NjEzZWQ5OGVhYzFlOWIxNDIwNzk0NTgzMTRiNjZhZGE4Mw==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T18:49:55Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1993-07-23T18:49:55Z"}, "message": "Output most constructors an element at a time.\n\n(digest_init): Deleted code for raw constructors.\n(process_init_constructor): Function deleted.\n(start_init, finish_init): New functions.\n(really_start_incremental_init)\n(push_init_level, check_init_type_bitfields, pop_init_level)\n(set_init_index, set_init_label, process_init_element)\n(output_init_element, output_pending_init_elements): New functions.\n\nFrom-SVN: r4973", "tree": {"sha": "9166ad9222fd32a908f5c02fcebae6ac2d310f9d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9166ad9222fd32a908f5c02fcebae6ac2d310f9d"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/de5206613ed98eac1e9b142079458314b66ada83", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5206613ed98eac1e9b142079458314b66ada83", "html_url": "https://github.com/Rust-GCC/gccrs/commit/de5206613ed98eac1e9b142079458314b66ada83", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/de5206613ed98eac1e9b142079458314b66ada83/comments", "author": null, "committer": null, "parents": [{"sha": "8380e2f2ec70c0bd568b7f6adecebf2656c14e57", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8380e2f2ec70c0bd568b7f6adecebf2656c14e57", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8380e2f2ec70c0bd568b7f6adecebf2656c14e57"}], "stats": {"total": 1598, "additions": 996, "deletions": 602}, "files": [{"sha": "8c88dbb34520f88b9a42a1c6d8d9d5dc5b598d54", "filename": "gcc/c-typeck.c", "status": "modified", "additions": 996, "deletions": 602, "changes": 1598, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/de5206613ed98eac1e9b142079458314b66ada83/gcc%2Fc-typeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/de5206613ed98eac1e9b142079458314b66ada83/gcc%2Fc-typeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-typeck.c?ref=de5206613ed98eac1e9b142079458314b66ada83", "patch": "@@ -55,13 +55,14 @@ static tree unary_complex_lvalue ();\n static tree process_init_constructor ();\n static tree convert_arguments ();\n static char *get_spelling ();\n-tree digest_init ();\n+static tree digest_init ();\n static void pedantic_lvalue_warning ();\n tree truthvalue_conversion ();\n void incomplete_type_error ();\n void readonly_warning ();\n static tree internal_build_compound_expr ();\n \n+void process_init_element ();\n \f\n /* Do `exp = require_complete_type (exp);' to make sure exp\n    does not have an incomplete type.  (That includes void types.)  */\n@@ -4831,25 +4832,15 @@ static tree free_tree_list = NULL_TREE;\n    (That is true for all nested calls to digest_init.)  */\n \n tree\n-digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n+digest_init (type, init, tail, require_constant, constructor_constant)\n      tree type, init, *tail;\n      int require_constant, constructor_constant;\n-     char *ofwhat;\n {\n   enum tree_code code = TREE_CODE (type);\n   tree element = 0;\n   tree old_tail_contents;\n-  /* Nonzero if INIT is a braced grouping, which comes in as a CONSTRUCTOR\n-     tree node which has no TREE_TYPE.  */\n-  int raw_constructor\n-    = TREE_CODE (init) == CONSTRUCTOR && TREE_TYPE (init) == 0;\n   tree inside_init = init;\n \n-  /* Make sure there is just one \"partially bracketed\" message\n-     per top-level initializer or constructor.  */\n-  if (ofwhat != 0)\n-    partial_bracket_mentioned = 0;\n-\n   /* By default, assume we use one element from a list.\n      We correct this later in the cases where it is not true.\n \n@@ -4876,16 +4867,6 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n   if (TREE_CODE (init) == NON_LVALUE_EXPR)\n     inside_init = TREE_OPERAND (init, 0);\n \n-  if (inside_init && raw_constructor\n-      && CONSTRUCTOR_ELTS (inside_init) != 0\n-      && TREE_CHAIN (CONSTRUCTOR_ELTS (inside_init)) == 0)\n-    {\n-      element = TREE_VALUE (CONSTRUCTOR_ELTS (inside_init));\n-      /* Strip NON_LVALUE_EXPRs since we aren't using as an lvalue.  */\n-      if (element && TREE_CODE (element) == NON_LVALUE_EXPR)\n-\telement = TREE_OPERAND (element, 0);\n-    }\n-\n   /* Initialization of an array of chars from a string constant\n      optionally enclosed in braces.  */\n \n@@ -4907,15 +4888,15 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t      && TYPE_PRECISION (typ1) == TYPE_PRECISION (char_type_node))\n \t    {\n \t      error_init (\"char-array%s initialized from wide string\",\n-\t\t\t  \" `%s'\", ofwhat);\n+\t\t\t  \" `%s'\", NULL);\n \t      return error_mark_node;\n \t    }\n \t  if ((TYPE_MAIN_VARIANT (TREE_TYPE (TREE_TYPE (string)))\n \t       == char_type_node)\n \t      && TYPE_PRECISION (typ1) != TYPE_PRECISION (char_type_node))\n \t    {\n \t      error_init (\"int-array%s initialized from non-wide string\",\n-\t\t\t  \" `%s'\", ofwhat);\n+\t\t\t  \" `%s'\", NULL);\n \t      return error_mark_node;\n \t    }\n \n@@ -4934,15 +4915,14 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t\t     : 1))\n \t\tpedwarn_init (\n \t\t  \"initializer-string for array of chars%s is too long\",\n-\t\t  \" `%s'\", ofwhat);\n+\t\t  \" `%s'\", NULL);\n \t    }\n \t  return string;\n \t}\n     }\n \n-  /* Any type except an array can be initialized\n-     from an expression of the same type, optionally with braces.\n-     For an array, this is allowed only for a string constant.  */\n+  /* Any type can be initialized\n+     from an expression of the same type, optionally with braces.  */\n \n   if (inside_init && TREE_TYPE (inside_init) != 0\n       && ((TYPE_MAIN_VARIANT (TREE_TYPE (inside_init))\n@@ -4959,10 +4939,11 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n \t  && (TREE_CODE (TREE_TYPE (inside_init)) == ARRAY_TYPE\n \t      || TREE_CODE (TREE_TYPE (inside_init)) == FUNCTION_TYPE))\n \tinside_init = default_conversion (inside_init);\n-      else if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST)\n+      else if (code == ARRAY_TYPE && TREE_CODE (inside_init) != STRING_CST\n+\t       && TREE_CODE (inside_init) != CONSTRUCTOR)\n \t{\n \t  error_init (\"array%s initialized from non-constant array expression\",\n-\t\t      \" `%s'\", ofwhat);\n+\t\t      \" `%s'\", NULL);\n \t  return error_mark_node;\n \t}\n \n@@ -4973,14 +4954,14 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n       if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  inside_init = error_mark_node;\n \t}\n \n@@ -4994,7 +4975,7 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n       if (code == ARRAY_TYPE)\n \t{\n \t  error_init (\"array%s initialized from non-constant array expression\",\n-\t\t      \" `%s'\", ofwhat);\n+\t\t      \" `%s'\", NULL);\n \t  return error_mark_node;\n \t}\n       if (pedantic && (code == RECORD_TYPE || code == UNION_TYPE))\n@@ -5005,123 +4986,47 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n       if (require_constant && ! TREE_CONSTANT (element))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  element = error_mark_node;\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (element, TREE_TYPE (element)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  element = error_mark_node;\n \t}\n \n       return element;\n     }\n \n-  /* Check for initializing a union by its first field.\n-     Such an initializer must use braces.  */\n-\n-  if (code == UNION_TYPE)\n-    {\n-      tree result;\n-      tree field = TYPE_FIELDS (type);\n-\n-      /* Find the first named field.  ANSI decided in September 1990\n-\t that only named fields count here.  */\n-      while (field && DECL_NAME (field) == 0)\n-\tfield = TREE_CHAIN (field);\n-\n-      if (field == 0)\n-\t{\n-\t  error_init (\"union%s with no named members cannot be initialized\",\n-\t\t      \" `%s'\", ofwhat);\n-\t  return error_mark_node;\n-\t}\n-\n-      if (raw_constructor)\n-\tresult = process_init_constructor (type, inside_init, NULL_PTR,\n-\t\t\t\t\t   require_constant,\n-\t\t\t\t\t   constructor_constant, ofwhat);\n-      else if (tail != 0)\n-\t{\n-\t  *tail = old_tail_contents;\n-\t  free_tree_list = NULL_TREE;\n-\t  result = process_init_constructor (type, NULL_TREE, tail,\n-\t\t\t\t\t     require_constant,\n-\t\t\t\t\t     constructor_constant, ofwhat);\n-\t}\n-      else\n-\tresult = 0;\n-\n-      if (result)\n-\treturn result;\n-    }\n-\n   /* Handle scalar types, including conversions.  */\n \n   if (code == INTEGER_TYPE || code == REAL_TYPE || code == POINTER_TYPE\n       || code == ENUMERAL_TYPE || code == COMPLEX_TYPE)\n     {\n-      if (raw_constructor)\n-\t{\n-\t  if (element == 0)\n-\t    {\n-\t      error_init (\n-\t \t  \"initializer for scalar%s requires one element\",\n-\t\t  \" `%s'\", ofwhat);\n-\t      return error_mark_node;\n-\t    }\n-\t  else\n-\t    {\n-\t      /* Deal with extra levels of {...}.  */\n-\t      if (TREE_CODE (element) == CONSTRUCTOR\n-\t\t  && TREE_TYPE (element) == 0)\n-\t\t{\n-\t\t  error_init (\n-\t\t\t      \"initializer for scalar%s requires one element\",\n-\t\t\t      \" `%s'\", ofwhat);\n-\t\t  return error_mark_node;\n-\t\t}\n-\t      inside_init = element;\n-\t    }\n-\t}\n-\n-#if 0  /* A non-raw constructor is an actual expression.  */\n-      if (TREE_CODE (inside_init) == CONSTRUCTOR)\n-\t{\n-\t  error_init (\"initializer for scalar%s has extra braces\",\n-\t\t      \" `%s'\", ofwhat);\n-\t  return error_mark_node;\n-\t}\n-#endif\n-\n       SAVE_SPELLING_DEPTH\n \t({\n-\t  if (ofwhat)\n-\t    push_string (ofwhat);\n-\t  if (!raw_constructor)\n-\t    inside_init = init;\n \t  /* Note that convert_for_assignment calls default_conversion\n \t     for arrays and functions.  We must not call it in the\n \t     case where inside_init is a null pointer constant.  */\n \t  inside_init\n-\t    = convert_for_assignment (type, inside_init, \n+\t    = convert_for_assignment (type, init, \n \t\t\t\t      &initialization_message,\n \t\t\t\t      NULL_TREE, NULL_TREE, 0);\n \t});\n \n       if (require_constant && ! TREE_CONSTANT (inside_init))\n \t{\n \t  error_init (\"initializer element%s is not constant\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  inside_init = error_mark_node;\n \t}\n       else if (require_constant\n \t       && initializer_constant_valid_p (inside_init, TREE_TYPE (inside_init)) == 0)\n \t{\n \t  error_init (\"initializer element%s is not computable at load time\",\n-\t\t      \" for `%s'\", ofwhat);\n+\t\t      \" for `%s'\", NULL);\n \t  inside_init = error_mark_node;\n \t}\n \n@@ -5133,582 +5038,1071 @@ digest_init (type, init, tail, require_constant, constructor_constant, ofwhat)\n   if (TYPE_SIZE (type) && TREE_CODE (TYPE_SIZE (type)) != INTEGER_CST)\n     {\n       error_init (\"variable-sized object%s may not be initialized\",\n-\t\t  \" `%s'\", ofwhat);\n+\t\t  \" `%s'\", NULL);\n       return error_mark_node;\n     }\n \n-  if (code == ARRAY_TYPE || code == RECORD_TYPE)\n-    {\n-      if (raw_constructor)\n-\treturn process_init_constructor (type, inside_init,\n-\t\t\t\t\t NULL_PTR, constructor_constant,\n-\t\t\t\t\t constructor_constant, ofwhat);\n-      else if (tail != 0)\n-\t{\n-\t  *tail = old_tail_contents;\n-\t  free_tree_list = NULL_TREE;\n-\t  return process_init_constructor (type, NULL_TREE, tail,\n-\t\t\t\t\t   constructor_constant,\n-\t\t\t\t\t   constructor_constant, ofwhat);\n-\t}\n-      else if (flag_traditional)\n-\t/* Traditionally one can say `char x[100] = 0;'.  */\n-\treturn process_init_constructor (type,\n-\t\t\t\t\t build_nt (CONSTRUCTOR, NULL_TREE,\n-\t\t\t\t\t\t   tree_cons (NULL_TREE,\n-\t\t\t\t\t\t\t      inside_init,\n-\t\t\t\t\t\t\t      NULL_TREE)),\n-\t\t\t\t\t NULL_PTR, constructor_constant,\n-\t\t\t\t\t constructor_constant, ofwhat);\n-    }\n-\n-  error_init (\"invalid initializer%s\", \" for `%s'\", ofwhat);\n+  error_init (\"invalid initializer%s\", \" for `%s'\", NULL);\n   return error_mark_node;\n }\n \f\n-/* Process a constructor for a variable of type TYPE.\n-   The constructor elements may be specified either with INIT or with ELTS,\n-   only one of which should be non-null.\n+/* Handle initializers that use braces.  */\n \n-   If INIT is specified, it is a CONSTRUCTOR node which is specifically\n-   and solely for initializing this datum.\n+static void output_pending_init_elements ();\n+static void check_init_type_bitfields ();\n \n-   If ELTS is specified, it is the address of a variable containing\n-   a list of expressions.  We take as many elements as we need\n-   from the head of the list and update the list.\n+/* Type of object we are accumulating a constructor for.\n+   This type is always a RECORD_TYPE, UNION_TYPE or ARRAY_TYPE.  */\n+static tree constructor_type;\n \n-   In the resulting constructor, TREE_CONSTANT is set if all elts are\n-   constant, and TREE_STATIC is set if, in addition, all elts are simple enough\n-   constants that the assembler and linker can compute them.\n+/* For a RECORD_TYPE or UNION_TYPE, this is the chain of fields\n+   left to fill.  */\n+static tree constructor_fields;\n \n-   The argument CONSTANT_VALUE says to print an error if either the\n-   value or any element is not a constant.\n+/* For an ARRAY_TYPE, this is the specified index\n+   at which to store the next element we get.\n+   This is a special INTEGER_CST node that we modify in place.  */\n+static tree constructor_index;\n \n-   The argument CONSTANT_ELEMENT says to print an error if an element\n-   of an aggregate is not constant.  It does not apply to a value\n-   which is not a constructor.  \n+/* For an ARRAY_TYPE, this is the end index of the range\n+   to intitialize with the next element, or NULL in the ordinary case\n+   where the element is used just once.  */\n+static tree constructor_range_end;\n \n-   OFWHAT is a character string describing the object being initialized,\n-   for error messages.  It might be \"variable\" or \"variable.member\"\n-   or \"variable[17].member[5]\".\n+/* For an ARRAY_TYPE, this is the maximum index.  */\n+static tree constructor_max_index;\n \n-   If OFWHAT is null, the description string is stored on the spelling\n-   stack.  That is always true for recursive calls.  */\n+/* For a RECORD_TYPE, this is the first field not yet written out.  */\n+static tree constructor_unfilled_fields;\n \n-static tree\n-process_init_constructor (type, init, elts, constant_value, constant_element,\n-\t\t\t  ofwhat)\n-     tree type, init, *elts;\n-     int constant_value, constant_element;\n-     char *ofwhat;\n+/* For an ARRAY_TYPE, this is the index of the first element\n+   not yet written out.\n+   This is a special INTEGER_CST node that we modify in place.  */\n+static tree constructor_unfilled_index;\n+\n+/* If we are saving up the elements rather than allocating them,\n+   this is the list of elements so far (in reverse order,\n+   most recent first).  */\n+static tree constructor_elements;\n+\n+/* 1 if so far this constructor's elements are all compile-time constants.  */\n+static int constructor_constant;\n+\n+/* 1 if so far this constructor's elements are all valid address constants.  */\n+static int constructor_simple;\n+\n+/* 1 if this constructor is erroneous so far.  */\n+static int constructor_erroneous;\n+\n+/* 1 if have called defer_addressed_constants.  */\n+static int constructor_subconstants_deferred;\n+\n+/* List of pending elements at this constructor level.\n+   These are elements encountered out of order\n+   which belong at places we haven't reached yet in actually\n+   writing the output.  */\n+static tree constructor_pending_elts;\n+\n+/* The SPELLING_DEPTH of this constructor.  */\n+static int constructor_depth;\n+\n+/* 1 if this constructor level was entered implicitly.  */\n+static int constructor_implicit;\n+\n+static int require_constant_value;\n+static int require_constant_elements;\n+\n+/* 1 if it is ok to output this constructor as we read it.\n+   0 means must accumulate a CONSTRUCTOR expression.  */\n+static int constructor_incremental;\n+\n+/* DECL node for which an initializer is being read.\n+   0 means we are reading a constructor expression\n+   such as (struct foo) {...}.  */\n+static tree constructor_decl;\n+\n+/* start_init saves the ASMSPEC arg here for really_start_incremental_init.  */\n+static char *constructor_asmspec;\n+\n+/* Nonzero if this is an initializer for a top-level decl.  */\n+static int constructor_top_level;\n+\n+/* When we finish reading a constructor expression\n+   (constructor_decl is 0), the CONSTRUCTOR goes here.  */\n+static tree constructor_result;\n+\n+struct constructor_stack\n {\n-  register tree tail;\n-  /* List of the elements of the result constructor,\n-     in reverse order.  */\n-  register tree members = NULL;\n-  tree result;\n-  int allconstant = 1;\n-  int allsimple = 1;\n-  int erroneous = 0;\n-  int depth = SPELLING_DEPTH ();\n+  struct constructor_stack *next;\n+  tree type;\n+  tree fields;\n+  tree index;\n+  tree range_end;\n+  tree max_index;\n+  tree unfilled_index;\n+  tree unfilled_fields;\n+  tree elements;\n+  int offset;\n+  tree pending_elts;\n+  int depth;\n+  char constant;\n+  char simple;\n+  char implicit;\n+  char incremental;\n+  char erroneous;\n+  char outer;\n+};\n \n-  if (ofwhat)\n-    push_string (ofwhat);\n+struct constructor_stack *constructor_stack;\n \n-  /* Make TAIL be the list of elements to use for the initialization,\n-     no matter how the data was given to us.  */\n+/* This stack records separate initializers that are nested.\n+   Nested initializers can't happen in ANSI C, but GNU C allows them\n+   in cases like { ... (struct foo) { ... } ... }.  */\n \n-  if (elts)\n+struct initializer_stack\n+{\n+  struct initializer_stack *next;\n+  tree decl;\n+  char *asmspec;\n+  struct constructor_stack *constructor_stack;\n+  struct spelling *spelling;\n+  struct spelling *spelling_base;\n+  int spelling_size;\n+  char top_level;\n+  char incremental;\n+  char require_constant_value;\n+  char require_constant_elements;\n+  char deferred;\n+};\n+\n+struct initializer_stack *initializer_stack;\n+\f\n+/* Prepare to parse and output the initializer for variable DECL.  */\n+\n+void\n+start_init (decl, asmspec, top_level)\n+     tree decl;\n+     char *asmspec;\n+     int top_level;\n+{\n+  char *locus;\n+  struct initializer_stack *p\n+    = (struct initializer_stack *) xmalloc (sizeof (struct initializer_stack));\n+\n+  p->decl = constructor_decl;\n+  p->asmspec = constructor_asmspec;\n+  p->incremental = constructor_incremental;\n+  p->require_constant_value = require_constant_value;\n+  p->require_constant_elements = require_constant_elements;\n+  p->constructor_stack = constructor_stack;\n+  p->spelling = spelling;\n+  p->spelling_base = spelling_base;\n+  p->spelling_size = spelling_size;\n+  p->deferred = constructor_subconstants_deferred;\n+  p->top_level = constructor_top_level;\n+  p->next = 0;\n+  initializer_stack = p;\n+\n+  constructor_decl = decl;\n+  constructor_incremental = top_level;\n+  constructor_asmspec = asmspec;\n+  constructor_subconstants_deferred = 0;\n+  constructor_top_level = top_level;\n+\n+  if (decl != 0)\n     {\n-      if (warn_missing_braces)\n-\t{\n-\t  if (! partial_bracket_mentioned)\n-\t    warning (\"aggregate has a partly bracketed initializer\");\n-\t  partial_bracket_mentioned = 1;\n-\t}\n-      tail = *elts;\n+      require_constant_value = TREE_STATIC (decl);\n+      require_constant_elements = TREE_STATIC (decl) || pedantic;\n+      locus = IDENTIFIER_POINTER (DECL_NAME (decl));\n+      constructor_incremental |= TREE_STATIC (decl);\n     }\n   else\n-    tail = CONSTRUCTOR_ELTS (init);\n+    {\n+      require_constant_value = 0;\n+      require_constant_elements = 0;\n+      locus = \"(anonymous)\";\n+    }\n \n-  /* Gobble as many elements as needed, and make a constructor or initial value\n-     for each element of this aggregate.  Chain them together in result.\n-     If there are too few, use 0 for each scalar ultimate component.  */\n+  constructor_stack = 0;\n \n-  if (TREE_CODE (type) == ARRAY_TYPE)\n-    {\n-      tree min_index, max_index;\n-      /* These are non-zero only within a range initializer.  */\n-      tree start_index = 0, end_index = 0;\n-      /* Within a range, this is the value for the elts in the range.  */\n-      tree range_val = 0;\n-      /* Do arithmetic using double integers, but don't use fold/build,\n-\t because these allocate a new tree object everytime they are called,\n-\t thus resulting in gcc using too much memory for large\n-\t initializers.  */\n-      union tree_node current_index_node, members_index_node;\n-      tree current_index = &current_index_node;\n-      tree members_index = &members_index_node;\n-      TREE_TYPE (current_index) = integer_type_node;\n-      TREE_TYPE (members_index) = integer_type_node;\n-\n-      /* If we have array bounds, set our bounds from that.  Otherwise,\n-\t we have a lower bound of zero and an unknown upper bound.  */\n-      if (TYPE_DOMAIN (type))\n-\t{\n-\t  min_index = TYPE_MIN_VALUE (TYPE_DOMAIN (type));\n-\t  max_index = TYPE_MAX_VALUE (TYPE_DOMAIN (type));\n-\t}\n-      else\n-\t{\n-\t  min_index = integer_zero_node;\n-\t  max_index = 0;\n-\t}\n+  spelling_base = 0;\n+  spelling_size = 0;\n+  RESTORE_SPELLING_DEPTH (0);\n \n-      TREE_INT_CST_LOW (members_index) = TREE_INT_CST_LOW (min_index);\n-      TREE_INT_CST_HIGH (members_index) = TREE_INT_CST_HIGH (min_index);\n+  if (locus)\n+    push_string (locus);\n+}\n \n-      /* Don't leave the loop based on index if the next item has an explicit\n-\t index value that will override it. */\n+void\n+finish_init ()\n+{\n+  struct initializer_stack *p = initializer_stack;\n \n-      for (TREE_INT_CST_LOW (current_index) = TREE_INT_CST_LOW (min_index),\n-\t   TREE_INT_CST_HIGH (current_index) = TREE_INT_CST_HIGH (min_index);\n-\t   tail != 0 || end_index;\n-\t   add_double (TREE_INT_CST_LOW (current_index),\n-\t\t       TREE_INT_CST_HIGH (current_index), 1, 0,\n-\t\t       &TREE_INT_CST_LOW (current_index),\n-\t\t       &TREE_INT_CST_HIGH (current_index)))\n-\t{\n-\t  register tree next1 = 0;\n+  /* Output subconstants (string constants, usually)\n+     that were referenced within this initializer and saved up.\n+     Must do this if and only if we called defer_addressed_constants.  */\n+  if (constructor_subconstants_deferred)\n+    output_deferred_addressed_constants ();\n \n-\t  /* Handle the case where we are inside of a range.\n-\t     current_index increments through the range,\n-\t     so just keep reusing the same element of TAIL\n-\t     until the end of the range.  */\n-\t  if (end_index != 0)\n-\t    {\n-\t      next1 = range_val;\n-\t      if (!tree_int_cst_lt (current_index, end_index))\n-\t\tend_index = 0;\n-\t    }\n+  /* Free the whole constructor stack of this initializer.  */\n+  while (constructor_stack)\n+    {\n+      struct constructor_stack *q = constructor_stack;\n+      constructor_stack = q->next;\n+      free (q);\n+    }\n \n-\t  /* If this element specifies an index,\n-\t     move to that index before storing it in the new list.  */\n-\t  else if (TREE_PURPOSE (tail) != 0)\n-\t    {\n-\t      int win = 0;\n-\t      tree index = TREE_PURPOSE (tail);\n+  /* Pop back to the data of the outer initializer (if any).  */\n+  constructor_decl = p->decl;\n+  constructor_asmspec = p->asmspec;\n+  constructor_incremental = p->incremental;\n+  require_constant_value = p->require_constant_value;\n+  require_constant_elements = p->require_constant_elements;\n+  constructor_stack = p->constructor_stack;\n+  spelling = p->spelling;\n+  spelling_base = p->spelling_base;\n+  spelling_size = p->spelling_size;\n+  constructor_subconstants_deferred = p->deferred;\n+  constructor_top_level = p->top_level;\n+  initializer_stack = p->next;\n+  free (p);\n+}\n+\f\n+/* Call here when we see the initializer is surrounded by braces.\n+   This is instead of a call to push_init_level;\n+   it is matched by a call to pop_init_level.\n \n-\t      if (index && (TREE_CODE (index) == NON_LVALUE_EXPR\n-\t\t\t    || TREE_CODE (index) == NOP_EXPR))\n-\t\tindex = TREE_OPERAND (index, 0);\n+   TYPE is the type to initialize, for a constructor expression.\n+   For an initializer for a decl, TYPE is zero.  */\n \n-\t      /* Begin a range.  */\n-\t      if (TREE_CODE (index) == TREE_LIST)\n-\t\t{\n-\t\t  start_index = TREE_PURPOSE (index);\n-\t\t  end_index = TREE_PURPOSE (TREE_CHAIN (index));\n-\n-\t\t  /* Expose constants.  It Doesn't matter if we change\n-\t\t     the mode.*/\n-\t\t  if (end_index\n-\t\t      && (TREE_CODE (end_index) == NON_LVALUE_EXPR\n-\t\t\t  || TREE_CODE (end_index) == NOP_EXPR))\n-\t\t    end_index = TREE_OPERAND (end_index, 0);\n-\t\t  if (start_index\n-\t\t      && (TREE_CODE (start_index) == NON_LVALUE_EXPR\n-\t\t\t  || TREE_CODE (start_index) == NOP_EXPR))\n-\t\t    start_index = TREE_OPERAND (start_index, 0);\n-\n-\t\t  constant_expression_warning (start_index);\n-\t\t  constant_expression_warning (end_index);\n-\n-\t\t  if ((TREE_CODE (start_index) == IDENTIFIER_NODE) \n-\t\t      || (TREE_CODE (end_index) == IDENTIFIER_NODE))\n-\t\t    error (\"field name used as index in array initializer\");\n-\t\t  else if ((TREE_CODE (start_index) != INTEGER_CST)\n-\t\t\t   || (TREE_CODE (end_index) != INTEGER_CST))\n-\t\t    error (\"non-constant or non-integer array index in initializer\");\n-\t\t  else if (tree_int_cst_lt (start_index, min_index)\n-\t\t\t   || (max_index && tree_int_cst_lt (max_index, start_index))\n-\t\t\t   || tree_int_cst_lt (end_index, min_index)\n-\t\t\t   || (max_index && tree_int_cst_lt (max_index, end_index)))\n-\t\t    error (\"array index out of range in initializer\");\n-\t\t  else if (tree_int_cst_lt (end_index, start_index))\n-\t\t    {\n-\t\t      /* If the range is empty, don't initialize any elements,\n-\t\t\t but do reset current_index for the next initializer\n-\t\t\t element.  */\n-\t\t      warning (\"empty array initializer range\");\n-\t\t      tail = TREE_CHAIN (tail);\n-\t\t      TREE_INT_CST_LOW (current_index)\n-\t\t\t= TREE_INT_CST_LOW (end_index);\n-\t\t      TREE_INT_CST_HIGH (current_index)\n-\t\t\t= TREE_INT_CST_HIGH (end_index);\n-\t\t      continue;\n-\t\t    }\n-\t\t  else\n-\t\t    {\n-\t\t      TREE_INT_CST_LOW (current_index)\n-\t\t\t= TREE_INT_CST_LOW (start_index);\n-\t\t      TREE_INT_CST_HIGH (current_index)\n-\t\t\t= TREE_INT_CST_HIGH (start_index);\n-\t\t      win = 1;\n-\t\t      /* See if the first element is also the last.  */\n-\t\t      if (!tree_int_cst_lt (current_index, end_index))\n-\t\t\tend_index = 0;\n-\t\t    }\n-\t\t}\n-\t      else if (TREE_CODE (index) == IDENTIFIER_NODE)\n-\t\terror (\"field name used as index in array initializer\");\n-\t      else if (TREE_CODE (index) != INTEGER_CST)\n-\t\terror (\"non-constant array index in initializer\");\n-\t      else if (tree_int_cst_lt (index, min_index)\n-\t\t       || (max_index && tree_int_cst_lt (max_index, index)))\n-\t\terror (\"array index out of range in initializer\");\n-\t      else\n-\t\t{\n-\t\t  constant_expression_warning (index);\n-\t\t  TREE_INT_CST_LOW (current_index) = TREE_INT_CST_LOW (index);\n-\t\t  TREE_INT_CST_HIGH (current_index)\n-\t\t    = TREE_INT_CST_HIGH (index);\n-\t\t  win = 1;\n-\t\t}\n+void\n+really_start_incremental_init (type)\n+     tree type;\n+{\n+  struct constructor_stack *p\n+    = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n+\n+  if (type == 0)\n+    type = TREE_TYPE (constructor_decl);\n+\n+  /* Turn off constructor_incremental if type is a struct with bitfields.\n+     Do this before the first push, so that the corrected value\n+     is available in finish_init.  */\n+  check_init_type_bitfields (type);\n+\n+  p->type = constructor_type;\n+  p->fields = constructor_fields;\n+  p->index = constructor_index;\n+  p->range_end = constructor_range_end;\n+  p->max_index = constructor_max_index;\n+  p->unfilled_index = constructor_unfilled_index;\n+  p->unfilled_fields = constructor_unfilled_fields;\n+  p->elements = 0;\n+  p->constant = constructor_constant;\n+  p->simple = constructor_simple;\n+  p->erroneous = constructor_erroneous;\n+  p->pending_elts = constructor_pending_elts;\n+  p->depth = constructor_depth;\n+  p->implicit = 0;\n+  p->incremental = constructor_incremental;\n+  p->outer = 0;\n+  p->next = 0;\n+  constructor_stack = p;\n+\n+  constructor_constant = 1;\n+  constructor_simple = 1;\n+  constructor_depth = SPELLING_DEPTH ();\n+  constructor_elements = 0;\n+  constructor_pending_elts = 0;\n+  constructor_type = type;\n+\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE\n+      || TREE_CODE (constructor_type) == UNION_TYPE)\n+    {\n+      constructor_fields = TYPE_FIELDS (constructor_type);\n+      constructor_unfilled_fields = constructor_fields;\n+    }\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      constructor_index = copy_node (integer_zero_node);\n+      constructor_range_end = 0;\n+      constructor_unfilled_index = copy_node (integer_zero_node);\n+      if (TYPE_DOMAIN (constructor_type))\n+\tconstructor_max_index\n+\t  = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n+    }\n+  else\n+    {\n+      /* Handle the case of int x = {5}; */\n+      constructor_fields = constructor_type;\n+      constructor_unfilled_fields = constructor_type;\n+    }\n \n-\t      if (!win)\n-\t\t{\n-\t\t  /* If there was an error, end the current range.  */\n-\t\t  end_index = 0;\n-\t\t  TREE_VALUE (tail) = error_mark_node;\n-\t\t}\n-\t    }\n+  if (constructor_incremental)\n+    {\n+      int momentary = suspend_momentary ();\n+      push_obstacks_nochange ();\n+      if (TREE_PERMANENT (constructor_decl))\n+\tend_temporary_allocation ();\n+      make_decl_rtl (constructor_decl, constructor_asmspec,\n+\t\t     constructor_top_level);\n+      assemble_variable (constructor_decl, constructor_top_level, 0, 1);\n+      pop_obstacks ();\n+      resume_momentary (momentary);\n+    }\n \n-\t  if (max_index && tree_int_cst_lt (max_index, current_index))\n-\t    break;  /* Stop if we've indeed run out of elements. */\n+  if (constructor_incremental)\n+    {\n+      defer_addressed_constants ();\n+      constructor_subconstants_deferred = 1;\n+    }\n+}\n+\f\n+/* Push down into a subobject, for initialization.\n+   If this is for an explicit set of braces, IMPLICIT is 0.\n+   If it is because the next element belongs at a lower level,\n+   IMPLICIT is 1.  */\n \n-\t  /* Now digest the value specified.  */\n-\t  if (next1 != 0)\n-\t    ;\n-\t  else if (TREE_VALUE (tail) != 0)\n-\t    {\n-\t      tree tail1 = tail;\n-\n-\t      /* Build the element of this array, with \"[]\" notation.  For\n-\t\t error messages, we assume that the index fits within a\n-\t\t host int.  */\n-\t      SAVE_SPELLING_DEPTH\n-\t\t({\n-\t\t  push_array_bounds (TREE_INT_CST_LOW (current_index));\n-\t\t  next1 = digest_init (TYPE_MAIN_VARIANT (TREE_TYPE (type)),\n-\t\t\t\t       TREE_VALUE (tail), &tail1,\n-\t\t\t\t       /* Both of these are the same because\n-\t\t\t\t\t  a value here is an elt overall.  */\n-\t\t\t\t       constant_element, constant_element,\n-\t\t\t\t       NULL_PTR);\n-\t\t});\n-\n-\t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n-\t\tabort ();\n-\t      if (tail == tail1 && TYPE_DOMAIN (type) == 0)\n-\t\t{\n-\t\t  error_init (\n-\t\t    \"non-empty initializer for array%s of empty elements\",\n-\t\t    \" `%s'\", NULL_PTR);\n-\t\t  /* Just ignore what we were supposed to use.  */\n-\t\t  tail1 = 0;\n-\t\t}\n-\t      tail = tail1;\n-\t    }\n-\t  else\n-\t    {\n-\t      next1 = error_mark_node;\n-\t      tail = TREE_CHAIN (tail);\n-\t    }\n+void\n+push_init_level (implicit)\n+     int implicit;\n+{\n+  struct constructor_stack *p\n+    = (struct constructor_stack *) xmalloc (sizeof (struct constructor_stack));\n+  p->type = constructor_type;\n+  p->fields = constructor_fields;\n+  p->index = constructor_index;\n+  p->range_end = constructor_range_end;\n+  p->max_index = constructor_max_index;\n+  p->unfilled_index = constructor_unfilled_index;\n+  p->unfilled_fields = constructor_unfilled_fields;\n+  p->elements = constructor_elements;\n+  p->constant = constructor_constant;\n+  p->simple = constructor_simple;\n+  p->erroneous = constructor_erroneous;\n+  p->pending_elts = constructor_pending_elts;\n+  p->depth = constructor_depth;\n+  p->implicit = implicit;\n+  p->incremental = constructor_incremental;\n+  p->outer = 0;\n+  p->next = constructor_stack;\n+  constructor_stack = p;\n+\n+  constructor_constant = 1;\n+  constructor_simple = 1;\n+  constructor_depth = SPELLING_DEPTH ();\n+  constructor_elements = 0;\n+  constructor_pending_elts = 0;\n+\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE\n+      || TREE_CODE (constructor_type) == UNION_TYPE)\n+    {\n+      constructor_type = TREE_TYPE (constructor_fields);\n+      push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n+    }\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      constructor_type = TREE_TYPE (constructor_type);\n+      push_array_bounds (TREE_INT_CST_LOW (constructor_index));\n+    }\n \n-\t  if (end_index != 0)\n-\t    range_val = next1;\n+  /* Turn off constructor_incremental if type is a struct with bitfields.  */\n+  check_init_type_bitfields (constructor_type);\n \n-\t  if (next1 == error_mark_node)\n-\t    erroneous = 1;\n-\t  else if (!TREE_CONSTANT (next1))\n-\t    allconstant = 0;\n-\t  else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n-\t    allsimple = 0;\n+  if (TREE_CODE (constructor_type) == RECORD_TYPE\n+      || TREE_CODE (constructor_type) == UNION_TYPE)\n+    {\n+      constructor_fields = TYPE_FIELDS (constructor_type);\n+      constructor_unfilled_fields = constructor_fields;\n+    }\n+  else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+    {\n+      constructor_index = copy_node (integer_zero_node);\n+      constructor_range_end = 0;\n+      constructor_unfilled_index = copy_node (integer_zero_node);\n+      if (TYPE_DOMAIN (constructor_type))\n+\tconstructor_max_index\n+\t  = TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type));\n+    }\n+  else\n+    {\n+      error_init (\"braces where a scalar is expected%s\", \" for `%s'\", NULL);\n+      constructor_fields = constructor_type;\n+      constructor_unfilled_fields = constructor_type;\n+    }\n+}\n \n-\t  /* Now store NEXT1 in the list, I elements from the *end*.\n-\t     Make the list longer if necessary.  */\n-\t  while (! tree_int_cst_lt (current_index, members_index))\n-\t    {\n-\t      if (free_tree_list)\n-\t\t{\n-\t\t  TREE_CHAIN (free_tree_list) = members;\n-\t\t  TREE_PURPOSE (free_tree_list) = NULL_TREE;\n-\t\t  TREE_VALUE (free_tree_list) = NULL_TREE;\n-\t\t  members = free_tree_list;\n-\t\t  free_tree_list = NULL_TREE;\n-\t\t}\n-\t      else\n-\t\tmembers = tree_cons (NULL_TREE, NULL_TREE, members);\n-\t      add_double (TREE_INT_CST_LOW (members_index),\n-\t\t\t  TREE_INT_CST_HIGH (members_index), 1, 0,\n-\t\t\t  &TREE_INT_CST_LOW (members_index),\n-\t\t\t  &TREE_INT_CST_HIGH (members_index));\n-\t    }\n+/* Don't read a struct incrementally if it has any bitfields,\n+   because the incremental reading code doesn't know how to\n+   handle bitfields yet.  */\n \n+static void\n+check_init_type_bitfields (type)\n+     tree type;\n+{\n+  if (TREE_CODE (type) == RECORD_TYPE)\n+    {\n+      tree tail;\n+      for (tail = TYPE_FIELDS (type); tail;\n+\t   tail = TREE_CHAIN (tail))\n+\tif (DECL_BIT_FIELD (tail))\n \t  {\n-\t    tree temp;\n-\t    union tree_node idx_node;\n-\t    tree idx = &idx_node;\n-\t    TREE_TYPE (idx) = integer_type_node;\n-\n-\t    temp = members;\n-\t    for (add_double (TREE_INT_CST_LOW (members_index),\n-\t\t\t     TREE_INT_CST_HIGH (members_index), -1, -1,\n-\t\t\t     &TREE_INT_CST_LOW (idx),\n-\t\t\t     &TREE_INT_CST_HIGH (idx));\n-\t\t tree_int_cst_lt (current_index, idx);\n-\t\t add_double (TREE_INT_CST_LOW (idx),\n-\t\t\t     TREE_INT_CST_HIGH (idx), -1, -1,\n-\t\t\t     &TREE_INT_CST_LOW (idx),\n-\t\t\t     &TREE_INT_CST_HIGH (idx)))\n-\t      temp = TREE_CHAIN (temp);\n-\t    TREE_VALUE (temp) = next1;\n+\t    constructor_incremental = 0;\n+\t    break;\n \t  }\n-\t}\n     }\n-  if (TREE_CODE (type) == RECORD_TYPE)\n+}\n+\n+/* At the end of an implicit or explicit brace level, \n+   finish up that level of constructor.\n+   If we were outputting the elements as they are read, return 0\n+   from inner levels (process_init_element ignores that),\n+   but return error_mark_node from the outermost level\n+   (that's what we want to put in DECL_INITIAL).\n+   Otherwise, return a CONSTRUCTOR expression.  */\n+\n+tree\n+pop_init_level (implicit)\n+     int implicit;\n+{\n+  struct constructor_stack *p;\n+  int size;\n+  tree constructor = 0;\n+\n+  if (implicit == 0)\n     {\n-      register tree field;\n-      int members_length = 0;\n-      int i;\n+      /* When we come to an explicit close brace,\n+\t pop any inner levels that didn't have explicit braces.  */\n+      while (constructor_stack->implicit)\n+\tprocess_init_element (pop_init_level (1));\n+    }\n \n-      /* Don't leave the loop based on field just yet; see if next item\n-\t overrides the expected field first. */\n+  p = constructor_stack;\n+  size = int_size_in_bytes (constructor_type);\n \n-      for (field = TYPE_FIELDS (type), i = 0; tail;\n-\t   field = TREE_CHAIN (field), i++)\n+  /* Now output all pending elements.  */\n+  output_pending_init_elements (1);\n+\n+  /* Pad out the end of the structure.  */\n+  \n+  if (! constructor_incremental)\n+    {\n+      if (constructor_erroneous)\n+\tconstructor = error_mark_node;\n+      else\n \t{\n-\t  register tree next1;\n+\t  int momentary = suspend_momentary ();\n+\n+\t  constructor = build (CONSTRUCTOR, constructor_type, NULL_TREE,\n+\t\t\t       nreverse (constructor_elements));\n+\t  if (constructor_constant)\n+\t    TREE_CONSTANT (constructor) = 1;\n+\t  if (constructor_constant && constructor_simple)\n+\t    TREE_STATIC (constructor) = 1;\n+\t  resume_momentary (momentary);\n+\t}\n+    }\n+  else\n+    {\n+      tree filled;\n+      int momentary = suspend_momentary ();\n \n-\t  /* If this element specifies a field, \n-\t     move to that field before storing it in the new list.  */\n-\t  if (TREE_PURPOSE (tail) != 0)\n+      if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t{\n+\t  tree tail;\n+\t  /* Find the last field written out.  */\n+\t  for (tail = TYPE_FIELDS (constructor_type); tail;\n+\t       tail = TREE_CHAIN (tail))\n+\t    if (TREE_CHAIN (tail) == constructor_unfilled_fields)\n+\t      break;\n+\t  /* Find the offset of the end of that field.  */\n+\t  filled = size_binop (CEIL_DIV_EXPR,\n+\t\t\t       size_binop (PLUS_EXPR,\n+\t\t\t\t\t   DECL_FIELD_BITPOS (tail),\n+\t\t\t\t\t   DECL_SIZE (tail)),\n+\t\t\t       size_int (BITS_PER_UNIT));\n+\t}\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\t{\n+\t  /* If initializing an array of unknown size,\n+\t     determine the size now.  */\n+\t  if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t      && TYPE_DOMAIN (constructor_type) == 0)\n \t    {\n-\t      int win = 0;\n+\t      tree maxindex\n+\t\t= size_binop (MINUS_EXPR,\n+\t\t\t      constructor_unfilled_index,\n+\t\t\t      integer_one_node);\n+\n+\t      push_obstacks_nochange ();\n+\t      if (TREE_PERMANENT (constructor_type))\n+\t\tend_temporary_allocation ();\n+\t      maxindex = copy_node (maxindex);\n+\t      TYPE_DOMAIN (constructor_type) = build_index_type (maxindex);\n+\t      TREE_TYPE (maxindex) = TYPE_DOMAIN (constructor_type);\n+\n+\t      /* We shouldn't have an incomplete array type within\n+\t\t some other type.  */\n+\t      if (constructor_stack->next)\n+\t\tabort ();\n \n-\t      if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n-\t\terror (\"index value instead of field name in structure initializer\");\n-\t      else\n-\t\t{\n-\t\t  tree temp;\n-\t\t  int j;\n-\t\t  for (temp = TYPE_FIELDS (type), j = 0;\n-\t\t       temp;\n-\t\t       temp = TREE_CHAIN (temp), j++)\n-\t\t    if (DECL_NAME (temp) == TREE_PURPOSE (tail))\n-\t\t      break;\n-\t\t  if (temp)\n-\t\t    field = temp, i = j, win = 1;\n-\t\t  else\n-\t\t    error (\"no field `%s' in structure being initialized\",\n-\t\t\t   IDENTIFIER_POINTER (TREE_PURPOSE (tail))); \n-\t\t}\n-\t      if (!win)\n-\t\tTREE_VALUE (tail) = error_mark_node;\n+\t      if (pedantic\n+\t\t  && tree_int_cst_lt (TYPE_MAX_VALUE (TYPE_DOMAIN (constructor_type)),\n+\t\t\t\t      integer_zero_node))\n+\t\terror_with_decl (constructor_decl, \"zero-size array `%s'\");\n+\t      layout_type (constructor_type);\n+\t      size = int_size_in_bytes (constructor_type);\n+\t      pop_obstacks ();\n \t    }\n \n-\t  if (field == 0)\n-\t    break;  /* No more fields to init. */\n+\t  filled = size_binop (MULT_EXPR, constructor_unfilled_index,\n+\t\t\t       size_in_bytes (TREE_TYPE (constructor_type)));\n+\t}\n+      else\n+\tfilled = 0;\n \n-\t  if (! DECL_NAME (field))\n-\t    {\n-\t      next1 = integer_zero_node;\n-\t    }\n-\t  else if (TREE_VALUE (tail) != 0)\n-\t    {\n-\t      tree tail1 = tail;\n-\n-\t      /* Build the name of this member, with a \".\" for membership.  */\n-\t      SAVE_SPELLING_DEPTH\n-\t\t({\n-\t\t  push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t\t  next1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t       TREE_VALUE (tail), &tail1,\n-\t\t\t\t       constant_element, constant_element,\n-\t\t\t\t       NULL_PTR);\n-\t\t});\n-\t      if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n-\t\tabort ();\n-\t      tail = tail1;\n-\t    }\n-\t  else\n+      if (filled != 0)\n+\tassemble_zeros (size - TREE_INT_CST_LOW (filled));\n+\n+      resume_momentary (momentary);\n+    }\n+\n+\t  \n+  constructor_type = p->type;\n+  constructor_fields = p->fields;\n+  constructor_index = p->index;\n+  constructor_range_end = p->range_end;\n+  constructor_max_index = p->max_index;\n+  constructor_unfilled_index = p->unfilled_index;\n+  constructor_unfilled_fields = p->unfilled_fields;\n+  constructor_elements = p->elements;\n+  constructor_constant = p->constant;\n+  constructor_simple = p->simple;\n+  constructor_erroneous = p->erroneous;\n+  constructor_pending_elts = p->pending_elts;\n+  constructor_depth = p->depth;\n+  constructor_incremental = p->incremental;\n+  RESTORE_SPELLING_DEPTH (constructor_depth);\n+\n+  constructor_stack = p->next;\n+  free (p);\n+\n+  if (constructor == 0)\n+    {\n+      if (constructor_stack == 0)\n+\treturn error_mark_node;\n+      return NULL_TREE;\n+    }\n+  return constructor;\n+}\n+\n+/* Within an array initializer, specify the next index to be initialized.\n+   FIRST is that index.  If LAST is nonzero, then initialize a range\n+   of indices, running from FIRST through LAST.  */\n+\n+void\n+set_init_index (first, last)\n+     tree first, last;\n+{\n+  if (tree_int_cst_lt (first, constructor_unfilled_index))\n+    error_init (\"duplicate array index in initializer%s\", \" for `%s'\", NULL);\n+  else\n+    {\n+      TREE_INT_CST_LOW (constructor_index)\n+\t= TREE_INT_CST_LOW (first);\n+      TREE_INT_CST_HIGH (constructor_index)\n+\t= TREE_INT_CST_HIGH (first);\n+\n+      if (last != 0 && tree_int_cst_lt (last, first))\n+\terror_init (\"empty index range in initializer%s\", \" for `%s'\", NULL);\n+      else\n+\tconstructor_range_end = last;\n+    }\n+}\n+\n+/* Within a struct initializer, specify the next field to be initialized.  */\n+\n+void \n+set_init_label (fieldname)\n+     tree fieldname;\n+{\n+  tree tail;\n+  int passed = 0;\n+\n+  for (tail = TYPE_FIELDS (constructor_type); tail;\n+       tail = TREE_CHAIN (tail))\n+    {\n+      if (tail == constructor_unfilled_fields)\n+\tpassed = 1;\n+      if (DECL_NAME (tail) == fieldname)\n+\tbreak;\n+    }\n+\n+  if (tail == 0)\n+    error (\"unknown field `%s' specified in initializer\",\n+\t   IDENTIFIER_POINTER (fieldname));\n+  else if (!passed)\n+    error (\"field `%s' already initialized\",\n+\t   IDENTIFIER_POINTER (fieldname));\n+  else\n+    constructor_fields = tail;\n+}\n+\f\n+/* \"Output\" the next constructor element.\n+   At top level, really output it to assembler code now.\n+   Otherwise, collect it in a list from which we will make a CONSTRUCTOR.\n+   TYPE is the data type that the containing data type wants here.\n+   FIELD is the field (a FIELD_DECL) or the index that this element fills.\n+\n+   PENDING if non-nil means output pending elements that belong\n+   right after this element.  (PENDING is normally 1;\n+   it is 0 while outputting pending elements, to avoid recursion.)  */\n+\n+void\n+output_init_element (value, type, field, pending)\n+     tree value, type, field;\n+     int pending;\n+{\n+  int duplicate = 0;\n+\n+  if (require_constant_value && ! TREE_CONSTANT (value))\n+    {\n+      error_init (\"initializer element%s is not constant\",\n+\t\t  \" for `%s'\", NULL);\n+      value = error_mark_node;\n+    }\n+  else if (require_constant_elements\n+\t   && initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n+    {\n+      error_init (\"initializer element%s is not computable at load time\",\n+\t\t  \" for `%s'\", NULL);\n+      value = error_mark_node;\n+    }\n+\n+  /* If this element duplicates one on constructor_pending_elts,\n+     print a message and ignore it.  Don't do this when we're\n+     processing elements taken off constructor_pending_elts,\n+     because we'd always get spurious errors.  */\n+  if (pending)\n+    {\n+      if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t{\n+\t  if (purpose_member (field, constructor_pending_elts))\n \t    {\n-\t      next1 = error_mark_node;\n-\t      tail = TREE_CHAIN (tail);\n+\t      error_init (\"duplicate initializer%s\", \" for `%s'\", NULL);\n+\t      duplicate = 1;\n \t    }\n+\t}\n+      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\t{\n+\t  tree tail;\n+\t  for (tail = constructor_pending_elts; tail;\n+\t       tail = TREE_CHAIN (tail))\n+\t    if (TREE_PURPOSE (tail) != 0\n+\t\t&& TREE_CODE (TREE_PURPOSE (tail)) == INTEGER_CST\n+\t\t&& tree_int_cst_equal (TREE_PURPOSE (tail), constructor_index))\n+\t      break;\n \n-\t  if (next1 == error_mark_node)\n-\t    erroneous = 1;\n-\t  else if (!TREE_CONSTANT (next1))\n-\t    allconstant = 0;\n-\t  else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n-\t    allsimple = 0;\n-\n-\t  /* Now store NEXT1 in the list, I elements from the *end*.\n-\t     Make the list longer if necessary.  */\n-\t  while (i >= members_length)\n+\t  if (tail != 0)\n \t    {\n-\t      if (free_tree_list)\n-\t\t{\n-\t\t  TREE_CHAIN (free_tree_list) = members;\n-\t\t  TREE_PURPOSE (free_tree_list) = NULL_TREE;\n-\t\t  TREE_VALUE (free_tree_list) = NULL_TREE;\n-\t\t  members = free_tree_list;\n-\t\t  free_tree_list = NULL_TREE;\n-\t\t}\n-\t      else\n-\t\tmembers = tree_cons (NULL_TREE, NULL_TREE, members);\n-\t      members_length++;\n+\t      error_init (\"duplicate initializer%s\", \" for `%s'\", NULL);\n+\t      duplicate = 1;\n \t    }\n-\t  {\n-\t    tree temp;\n-\t    int j;\n-\n-\t    temp = members;\n-\t    for (j = members_length - 1; j > i; j--)\n-\t      temp = TREE_CHAIN (temp);\n-\t    TREE_VALUE (temp) = next1;\n-\t    TREE_PURPOSE (temp) = field;\n-\t  }\n \t}\n     }\n-  if (TREE_CODE (type) == UNION_TYPE)\n-    {\n-      register tree field = TYPE_FIELDS (type);\n-      register tree next1;\n-\n-      /* Find the first named field.  ANSI decided in September 1990\n-\t that only named fields count here.  */\n-      while (field && DECL_NAME (field) == 0)\n-\tfield = TREE_CHAIN (field);\n \n-      /* For a union, get the initializer for 1 fld.  */\n+  /* If this element doesn't come next in sequence,\n+     put it on constructor_pending_elts.  */\n+  if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+      && !tree_int_cst_equal (field, constructor_unfilled_index))\n+    {\n+      if (! duplicate)\n+\tconstructor_pending_elts\n+\t  = tree_cons (field,\n+\t\t       digest_init (type, value, (tree *)NULL,\n+\t\t\t\t    require_constant_value,\n+\t\t\t\t    require_constant_elements),\n+\t\t       constructor_pending_elts);\n+    }\n+  else if ((TREE_CODE (constructor_type) == RECORD_TYPE\n+\t    || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t   && field != constructor_unfilled_fields)\n+    {\n+      if (!duplicate)\n+\tconstructor_pending_elts\n+\t  = tree_cons (field,\n+\t\t       digest_init (type, value, (tree *)NULL,\n+\t\t\t\t    require_constant_value,\n+\t\t\t\t    require_constant_elements),\n+\t\t       constructor_pending_elts);\n+    }\n+  else\n+    {\n+      /* Otherwise, output this element either to\n+\t constructor_elements or to the assembler file.  */\n \n-      if (tail == 0)\n+      if (!duplicate)\n \t{\n-\t  error (\"empty initializer for union\");\n-\t  tail = build_tree_list (0, 0);\n+\t  if (! constructor_incremental)\n+\t    constructor_elements\n+\t      = tree_cons ((TREE_CODE (constructor_type) != ARRAY_TYPE\n+\t\t\t    ? field : NULL),\n+\t\t\t   digest_init (type, value, (tree *)NULL,\n+\t\t\t\t\trequire_constant_value,\n+\t\t\t\t\trequire_constant_elements),\n+\t\t\t   constructor_elements);\n+\t  else\n+\t    output_constant (value, int_size_in_bytes (type));\n \t}\n \n-      /* If this element specifies a field, initialize via that field.  */\n-      if (TREE_PURPOSE (tail) != 0)\n+      /* Advance the variable that indicates sequential elements output.  */\n+      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n-\t  int win = 0;\n+\t  tree tem = size_binop (PLUS_EXPR, constructor_unfilled_index,\n+\t\t\t\t integer_one_node);\n+\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n+\t    = TREE_INT_CST_LOW (tem);\n+\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n+\t    = TREE_INT_CST_HIGH (tem);\n+\t}\n+      else if (TREE_CODE (constructor_type) == RECORD_TYPE)\n+\tconstructor_unfilled_fields = TREE_CHAIN (constructor_unfilled_fields);\n+      else if (TREE_CODE (constructor_type) == UNION_TYPE)\n+\tconstructor_unfilled_fields = 0;\n+\n+      /* Now output any pending elements which have become next.  */\n+      if (pending)\n+\toutput_pending_init_elements (0);\n+    }\n+}\n \n-\t  if (TREE_CODE (TREE_PURPOSE (tail)) == FIELD_DECL)\n-\t    /* Handle the case of a call by build_c_cast.  */\n-\t    field = TREE_PURPOSE (tail), win = 1;\n-\t  else if (TREE_CODE (TREE_PURPOSE (tail)) != IDENTIFIER_NODE)\n-\t    error (\"index value instead of field name in union initializer\");\n-\t  else\n+/* Output any pending elements which have become next.\n+   As we output elements, constructor_unfilled_{fields,index}\n+   advances, which may cause other elements to become next;\n+   if so, they too are output.\n+\n+   If ALL is 0, we return when there are\n+   no more pending elements to output now.\n+\n+   If ALL is 1, we output space as necessary so that\n+   we can output all the pending elements.  */\n+\n+static void\n+output_pending_init_elements (all)\n+     int all;\n+{\n+  tree tail;\n+  tree next;\n+\n+ retry:\n+\n+  /* Look thru the whole pending list.\n+     If we find an element that should be output now,\n+     output it.  Otherwise, set NEXT to the element\n+     that comes first among those still pending.  */\n+     \n+  next = 0;\n+  for (tail = constructor_pending_elts; tail;\n+       tail = TREE_CHAIN (tail))\n+    {\n+      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\t{\n+\t  if (tree_int_cst_equal (TREE_PURPOSE (tail),\n+\t\t\t\t  constructor_unfilled_index))\n \t    {\n-\t      tree temp;\n-\t      for (temp = TYPE_FIELDS (type);\n-\t\t   temp;\n-\t\t   temp = TREE_CHAIN (temp))\n-\t\tif (DECL_NAME (temp) == TREE_PURPOSE (tail))\n-\t\t  break;\n-\t      if (temp)\n-\t\tfield = temp, win = 1;\n-\t      else\n-\t\terror (\"no field `%s' in union being initialized\",\n-\t\t       IDENTIFIER_POINTER (TREE_PURPOSE (tail)));\n+\t      output_init_element (TREE_VALUE (tail), TREE_TYPE (constructor_type),\n+\t\t\t\t   constructor_unfilled_index, 0);\n+\t      goto retry;\n+\t    }\n+\t  else if (tree_int_cst_lt (TREE_PURPOSE (tail),\n+\t\t\t\t    constructor_unfilled_index))\n+\t    ;\n+\t  else if (next == 0\n+\t\t   || tree_int_cst_lt (TREE_PURPOSE (tail),\n+\t\t\t\t\t  next))\n+\t    next = TREE_PURPOSE (tail);\n+\t}\n+      else if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t       || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t{\n+\t  if (TREE_PURPOSE (tail) == constructor_unfilled_fields)\n+\t    {\n+\t      output_init_element (TREE_VALUE (tail),\n+\t\t\t\t   TREE_TYPE (constructor_unfilled_fields),\n+\t\t\t\t   constructor_unfilled_fields,\n+\t\t\t\t   0);\n+\t      goto retry;\n \t    }\n-\t  if (!win)\n-\t    TREE_VALUE (tail) = error_mark_node;\n+\t  else if (tree_int_cst_lt (DECL_FIELD_BITPOS (TREE_PURPOSE (tail)),\n+\t\t\t\t    DECL_FIELD_BITPOS (constructor_unfilled_fields)))\n+\t    ;\n+\t  else if (next == 0\n+\t\t   || tree_int_cst_lt (DECL_FIELD_BITPOS (TREE_PURPOSE (tail)),\n+\t\t\t\t       DECL_FIELD_BITPOS (next)))\n+\t    next = TREE_PURPOSE (tail);\n \t}\n+    }\n+\n+  /* Ordinarily return, but not if we want to output all\n+     and there are elements left.  */\n+  if (! (all && next != 0))\n+    return;\n+\n+  /* Generate space up to the position of NEXT.  */\n+  if (constructor_incremental)\n+    {\n+      tree filled;\n+      tree nextpos_tree;\n \n-      if (TREE_VALUE (tail) != 0)\n+      if (TREE_CODE (constructor_type) == RECORD_TYPE\n+\t  || TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n-\t  tree tail1 = tail;\n-\n-\t  /* Build the name of this member, with a \".\" for membership.  */\n-\t  SAVE_SPELLING_DEPTH\n-\t    ({\n-\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (field)));\n-\t      next1 = digest_init (TREE_TYPE (field),\n-\t\t\t\t   TREE_VALUE (tail), &tail1,\n-\t\t\t\t   constant_value, constant_element, NULL_PTR);\n-\t    });\n-\t  if (tail1 != 0 && TREE_CODE (tail1) != TREE_LIST)\n-\t    abort ();\n-\t  tail = tail1;\n+\t  /* Find the last field written out.  */\n+\t  for (tail = TYPE_FIELDS (constructor_type); tail;\n+\t       tail = TREE_CHAIN (tail))\n+\t    if (TREE_CHAIN (tail) == constructor_unfilled_fields)\n+\t      break;\n+\t  /* Find the offset of the end of that field.  */\n+\t  filled = size_binop (CEIL_DIV_EXPR,\n+\t\t\t       size_binop (PLUS_EXPR,\n+\t\t\t\t\t   DECL_FIELD_BITPOS (tail),\n+\t\t\t\t\t   DECL_SIZE (tail)),\n+\t\t\t       size_int (BITS_PER_UNIT));\n+\t  nextpos_tree = size_binop (CEIL_DIV_EXPR,\n+\t\t\t\t     DECL_FIELD_BITPOS (next),\n+\t\t\t\t     size_int (BITS_PER_UNIT));\n+\t  constructor_unfilled_fields = next;\n \t}\n-      else\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n \t{\n-\t  next1 = error_mark_node;\n-\t  tail = TREE_CHAIN (tail);\n+\t  filled = size_binop (MULT_EXPR, constructor_unfilled_index,\n+\t\t\t       size_in_bytes (TREE_TYPE (constructor_type)));\n+\t  nextpos_tree\n+\t    = size_binop (MULT_EXPR, next,\n+\t\t\t  size_in_bytes (TREE_TYPE (constructor_type)));\n+\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n+\t    = TREE_INT_CST_LOW (next);\n+\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n+\t    = TREE_INT_CST_HIGH (next);\n \t}\n+      else\n+\tfilled = 0;\n \n-      if (next1 == error_mark_node)\n-\terroneous = 1;\n-      else if (!TREE_CONSTANT (next1))\n-\tallconstant = 0;\n-      else if (initializer_constant_valid_p (next1, TREE_TYPE (next1)) == 0)\n-\tallsimple = 0; \n-     if (free_tree_list)\n+      if (filled)\n \t{\n-\t  TREE_CHAIN (free_tree_list) = members;\n-\t  TREE_PURPOSE (free_tree_list) = field;\n-\t  TREE_VALUE (free_tree_list) = next1;\n-\t  members = free_tree_list;\n-\t  free_tree_list = NULL_TREE;\n+\t  int nextpos = TREE_INT_CST_LOW (nextpos_tree);\n+\n+\t  assemble_zeros (nextpos - TREE_INT_CST_LOW (filled));\n \t}\n+    }\n+\n+  goto retry;\n+}\n+\f\n+/* Add one non-braced element to the current constructor level.\n+   This adjusts the current position within the constructor's type.\n+   This may also start or terminate implicit levels\n+   to handle a partly-braced initializer.\n+\n+   Once this has found the correct level for the new element,\n+   it calls output_init_element.\n+\n+   Note: if we are incrementally outputting this constructor,\n+   this function may be called with a null argument\n+   representing a sub-constructor that was already incrementally output.\n+   When that happens, we output nothing, but we do the bookkeeping\n+   to skip past that element of the current constructor.  */\n+\n+void\n+process_init_element (value)\n+     tree value;\n+{\n+  if (value != 0)\n+    value = default_conversion (value);\n+\n+  if (value == 0)\n+    ;\n+  else if (value == error_mark_node)\n+    constructor_erroneous = 1;\n+  else if (!TREE_CONSTANT (value))\n+    constructor_constant = 0;\n+  else if (initializer_constant_valid_p (value, TREE_TYPE (value)) == 0)\n+    constructor_simple = 0;\n+\n+  /* If we've exhausted any levels that didn't have braces,\n+     pop them now.  */\n+  while (constructor_stack->implicit)\n+    {\n+      if ((TREE_CODE (constructor_type) == RECORD_TYPE\n+\t   || TREE_CODE (constructor_type) == UNION_TYPE)\n+\t  && constructor_fields == 0)\n+\tprocess_init_element (pop_init_level (1));\n+      else if (TREE_CODE (constructor_type) == ARRAY_TYPE\n+\t       && tree_int_cst_lt (constructor_max_index, constructor_index))\n+\tprocess_init_element (pop_init_level (1));\n       else\n-\tmembers = tree_cons (field, next1, members);\n+\tbreak;\n     }\n \n-  /* If arguments were specified as a list, just remove the ones we used.  */\n-  if (elts)\n-    *elts = tail;\n-  /* If arguments were specified as a constructor,\n-     complain unless we used all the elements of the constructor.  */\n-  else if (tail)\n+  while (1)\n     {\n-      if (TREE_CODE (type) == UNION_TYPE)\n+      if (TREE_CODE (constructor_type) == RECORD_TYPE)\n \t{\n-\t  pedwarn_init (\"excess elements in union initializer%s\",\n-\t\t\t\" after `%s'\", NULL_PTR);\n+\t  tree fieldtype;\n+\t  enum tree_code fieldcode;\n+\n+\t  if (constructor_fields == 0)\n+\t    {\n+\t      pedwarn_init (\"excess elements in struct initializer%s\",\n+\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      break;\n+\t    }\n+\n+\t  fieldtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_fields));\n+\t  fieldcode = TREE_CODE (fieldtype);\n+\n+\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t      && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n+\t\t  || fieldcode == UNION_TYPE))\n+\t    {\n+\t      push_init_level (1);\n+\t      continue;\n+\t    }\n+\n+\t  if (value)\n+\t    {\n+\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n+\t      output_init_element (value, fieldtype, constructor_fields, 1);\n+\t      RESTORE_SPELLING_DEPTH (constructor_depth);\n+\t    }\n+\t  else\n+\t    /* If we are doing the bookkeeping for an element that was\n+\t       directly output as a constructor,\n+\t       we must update constructor_unfilled_fields.  */\n+\t    constructor_unfilled_fields = TREE_CHAIN (constructor_fields);\n+\n+\t  constructor_fields = TREE_CHAIN (constructor_fields);\n+\t  break;\n \t}\n-      else\n+      if (TREE_CODE (constructor_type) == UNION_TYPE)\n \t{\n-\t  pedwarn_init (\"excess elements in aggregate initializer%s\",\n-\t\t\t\" after `%s'\", NULL_PTR);\n+\t  tree fieldtype;\n+\t  enum tree_code fieldcode;\n+\n+\t  if (constructor_fields == 0)\n+\t    {\n+\t      pedwarn_init (\"excess elements in union initializer%s\",\n+\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      break;\n+\t    }\n+\n+\t  fieldtype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_fields));\n+\t  fieldcode = TREE_CODE (fieldtype);\n+\n+\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != fieldtype\n+\t      && (fieldcode == RECORD_TYPE || fieldcode == ARRAY_TYPE\n+\t\t  || fieldcode == UNION_TYPE))\n+\t    {\n+\t      push_init_level (1);\n+\t      continue;\n+\t    }\n+\n+\t  if (value)\n+\t    {\n+\t      push_member_name (IDENTIFIER_POINTER (DECL_NAME (constructor_fields)));\n+\t      output_init_element (value, fieldtype, constructor_fields, 1);\n+\t      RESTORE_SPELLING_DEPTH (constructor_depth);\n+\t    }\n+\t  else\n+\t    /* If we are doing the bookkeeping for an element that was\n+\t       directly output as a constructor,\n+\t       we must update constructor_unfilled_fields.  */\n+\t    constructor_unfilled_fields = 0;\n+\n+\t  constructor_fields = 0;\n+\t  break;\n \t}\n-    }\n+      if (TREE_CODE (constructor_type) == ARRAY_TYPE)\n+\t{\n+\t  tree elttype = TYPE_MAIN_VARIANT (TREE_TYPE (constructor_type));\n+\t  enum tree_code eltcode = TREE_CODE (elttype);\n+\n+\t  if (value != 0 && TYPE_MAIN_VARIANT (TREE_TYPE (value)) != elttype\n+\t      && (eltcode == RECORD_TYPE || eltcode == ARRAY_TYPE\n+\t\t  || eltcode == UNION_TYPE))\n+\t    {\n+\t      push_init_level (1);\n+\t      continue;\n+\t    }\n+\n+\t  if (constructor_max_index != 0\n+\t      && tree_int_cst_lt (constructor_max_index, constructor_index))\n+\t    {\n+\t      pedwarn_init (\"excess elements in array initializer%s\",\n+\t\t\t    \" after `%s'\", NULL_PTR);\n+\t      break;\n+\t    }\n \n-  /* It might be possible to use SAVE_SPELLING_DEPTH, but I suspect that\n-     some preprocessor somewhere won't accept that much text as an argument.\n-     It's also likely to make debugging difficult.  */\n+\t  /* Now output the actual element.\n+\t     Ordinarily, output once.\n+\t     If there is a range, repeat it till we advance past the range.  */\n+\t  do\n+\t    {\n+\t      tree tem;\n \n-  RESTORE_SPELLING_DEPTH (depth);\n+\t      if (value)\n+\t\t{\n+\t\t  push_array_bounds (TREE_INT_CST_LOW (constructor_index));\n+\t\t  output_init_element (value, elttype, constructor_index, 1);\n+\t\t  RESTORE_SPELLING_DEPTH (constructor_depth);\n+\t\t}\n \n-  if (erroneous)\n-    return error_mark_node;\n+\t      tem = size_binop (PLUS_EXPR, constructor_index,\n+\t\t\t\tinteger_one_node);\n+\t      TREE_INT_CST_LOW (constructor_index)\n+\t\t= TREE_INT_CST_LOW (tem);\n+\t      TREE_INT_CST_HIGH (constructor_index)\n+\t\t= TREE_INT_CST_HIGH (tem);\n+\n+\t      if (!value)\n+\t\t/* If we are doing the bookkeeping for an element that was\n+\t\t   directly output as a constructor,\n+\t\t   we must update constructor_unfilled_index.  */\n+\t\t{\n+\t\t  TREE_INT_CST_LOW (constructor_unfilled_index)\n+\t\t    = TREE_INT_CST_LOW (constructor_index);\n+\t\t  TREE_INT_CST_HIGH (constructor_unfilled_index)\n+\t\t    = TREE_INT_CST_HIGH (constructor_index);\n+\t\t}\n+\t    }\n+\t  while (! (constructor_range_end == 0\n+\t\t    || tree_int_cst_lt (constructor_range_end,\n+\t\t\t\t\tconstructor_index)));\n \n-  if (elts)\n-    result = build (CONSTRUCTOR, type, NULL_TREE, nreverse (members));\n-  else\n-    {\n-      result = init;\n-      CONSTRUCTOR_ELTS (result) = nreverse (members);\n-      TREE_TYPE (result) = type;\n-      TREE_CONSTANT (result) = 0;\n-      TREE_STATIC (result) = 0;\n+\t  break;\n+\t}\n+\n+      /* Handle the sole element allowed in a braced initializer\n+\t for a scalar variable.  */\n+      if (constructor_fields == 0)\n+\t{\n+\t  pedwarn_init (\"excess elements in scalar initializer%s\",\n+\t\t\t\" after `%s'\", NULL_PTR);\n+\t  break;\n+\t}\n+\n+      if (value)\n+\toutput_init_element (value, constructor_type, NULL_TREE, 1);\n+      constructor_fields = 0;\n+      break;\n     }\n-  if (allconstant) TREE_CONSTANT (result) = 1;\n-  if (allconstant && allsimple) TREE_STATIC (result) = 1;\n-  return result;\n+\n+  /* If the (lexically) previous elments are not now saved,\n+     we can discard the storage for them.  */\n+  if (constructor_incremental && constructor_pending_elts == 0)\n+    clear_momentary ();\n }\n \f\n /* Expand an ASM statement with operands, handling output operands"}]}