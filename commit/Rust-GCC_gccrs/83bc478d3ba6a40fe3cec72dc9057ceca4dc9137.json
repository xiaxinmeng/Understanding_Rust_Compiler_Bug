{"sha": "83bc478d3ba6a40fe3cec72dc9057ceca4dc9137", "node_id": "C_kwDOANBUbNoAKDgzYmM0NzhkM2JhNmE0MGZlM2NlYzcyZGM5MDU3Y2VjYTRkYzkxMzc", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-03-10T11:40:02Z"}, "committer": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2022-03-10T12:40:25Z"}, "message": "tree-optimization/102943 - avoid (re-)computing dominance bitmap\n\nCurrently back_propagate_equivalences tries to optimize dominance\nqueries in a smart way but it fails to notice that when fast indexes\nare available the dominance query is fast (when called from DOM).\nIt also re-computes the dominance bitmap for each equivalence recorded\non an edge, which for FP are usually several.  Finally it fails to\nuse the tree bitmap view for efficiency.  Overall this cuts 7\nseconds of compile-time from originally 77 in the slowest LTRANS\nunit when building 521.wrf_r.\n\n2022-03-10  Richard Biener  <rguenther@suse.de>\n\n\tPR tree-optimization/102943\n\t* tree-ssa-dom.cc (back_propagate_equivalences): Only\n\tpopulate the dominance bitmap if fast queries are not\n\tavailable.  Use a tree view bitmap.\n\t(record_temporary_equivalences): Cache the dominance bitmap\n\tacross all equivalences on the edge.", "tree": {"sha": "38eca9bcd873f5336ccebe2e2f08ca757f9a1edf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/38eca9bcd873f5336ccebe2e2f08ca757f9a1edf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137", "html_url": "https://github.com/Rust-GCC/gccrs/commit/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "cfaa2fac42f6f4bddb197dc1fc601f2ba136f9f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/cfaa2fac42f6f4bddb197dc1fc601f2ba136f9f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/cfaa2fac42f6f4bddb197dc1fc601f2ba136f9f0"}], "stats": {"total": 58, "additions": 35, "deletions": 23}, "files": [{"sha": "21745bf31d3f48989206efa67bd0541621368737", "filename": "gcc/tree-ssa-dom.cc", "status": "modified", "additions": 35, "deletions": 23, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137/gcc%2Ftree-ssa-dom.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/83bc478d3ba6a40fe3cec72dc9057ceca4dc9137/gcc%2Ftree-ssa-dom.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-dom.cc?ref=83bc478d3ba6a40fe3cec72dc9057ceca4dc9137", "patch": "@@ -1025,12 +1025,13 @@ dom_valueize (tree t)\n    additional equivalences that are valid on edge E.  */\n static void\n back_propagate_equivalences (tree lhs, edge e,\n-\t\t\t     class const_and_copies *const_and_copies)\n+\t\t\t     class const_and_copies *const_and_copies,\n+\t\t\t     bitmap *domby)\n {\n   use_operand_p use_p;\n   imm_use_iterator iter;\n-  bitmap domby = NULL;\n   basic_block dest = e->dest;\n+  bool domok = (dom_info_state (CDI_DOMINATORS) == DOM_OK);\n \n   /* Iterate over the uses of LHS to see if any dominate E->dest.\n      If so, they may create useful equivalences too.\n@@ -1053,27 +1054,38 @@ back_propagate_equivalences (tree lhs, edge e,\n       if (!lhs2 || TREE_CODE (lhs2) != SSA_NAME)\n \tcontinue;\n \n-      /* Profiling has shown the domination tests here can be fairly\n-\t expensive.  We get significant improvements by building the\n-\t set of blocks that dominate BB.  We can then just test\n-\t for set membership below.\n-\n-\t We also initialize the set lazily since often the only uses\n-\t are going to be in the same block as DEST.  */\n-      if (!domby)\n+      if (domok)\n \t{\n-\t  domby = BITMAP_ALLOC (NULL);\n-\t  basic_block bb = get_immediate_dominator (CDI_DOMINATORS, dest);\n-\t  while (bb)\n+\t  if (!dominated_by_p (CDI_DOMINATORS, dest, gimple_bb (use_stmt)))\n+\t    continue;\n+\t}\n+      else\n+\t{\n+\t  /* Profiling has shown the domination tests here can be fairly\n+\t     expensive when the fast indexes are not computed.\n+\t     We get significant improvements by building the\n+\t     set of blocks that dominate BB.  We can then just test\n+\t     for set membership below.\n+\n+\t     We also initialize the set lazily since often the only uses\n+\t     are going to be in the same block as DEST.  */\n+\n+\t  if (!*domby)\n \t    {\n-\t      bitmap_set_bit (domby, bb->index);\n-\t      bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t      *domby = BITMAP_ALLOC (NULL);\n+\t      bitmap_tree_view (*domby);\n+\t      basic_block bb = get_immediate_dominator (CDI_DOMINATORS, dest);\n+\t      while (bb)\n+\t\t{\n+\t\t  bitmap_set_bit (*domby, bb->index);\n+\t\t  bb = get_immediate_dominator (CDI_DOMINATORS, bb);\n+\t\t}\n \t    }\n-\t}\n \n-      /* This tests if USE_STMT does not dominate DEST.  */\n-      if (!bitmap_bit_p (domby, gimple_bb (use_stmt)->index))\n-\tcontinue;\n+\t  /* This tests if USE_STMT does not dominate DEST.  */\n+\t  if (!bitmap_bit_p (*domby, gimple_bb (use_stmt)->index))\n+\t    continue;\n+\t}\n \n       /* At this point USE_STMT dominates DEST and may result in a\n \t useful equivalence.  Try to simplify its RHS to a constant\n@@ -1083,9 +1095,6 @@ back_propagate_equivalences (tree lhs, edge e,\n       if (res && (TREE_CODE (res) == SSA_NAME || is_gimple_min_invariant (res)))\n \trecord_equality (lhs2, res, const_and_copies);\n     }\n-\n-  if (domby)\n-    BITMAP_FREE (domby);\n }\n \n /* Record into CONST_AND_COPIES and AVAIL_EXPRS_STACK any equivalences implied\n@@ -1110,6 +1119,7 @@ record_temporary_equivalences (edge e,\n       for (i = 0; edge_info->cond_equivalences.iterate (i, &eq); ++i)\n \tavail_exprs_stack->record_cond (eq);\n \n+      bitmap domby = NULL;\n       edge_info::equiv_pair *seq;\n       for (i = 0; edge_info->simple_equivalences.iterate (i, &seq); ++i)\n \t{\n@@ -1146,8 +1156,10 @@ record_temporary_equivalences (edge e,\n \t  /* Any equivalence found for LHS may result in additional\n \t     equivalences for other uses of LHS that we have already\n \t     processed.  */\n-\t  back_propagate_equivalences (lhs, e, const_and_copies);\n+\t  back_propagate_equivalences (lhs, e, const_and_copies, &domby);\n \t}\n+      if (domby)\n+\tBITMAP_FREE (domby);\n     }\n }\n "}]}