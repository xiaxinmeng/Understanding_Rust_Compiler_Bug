{"sha": "75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzVhOTdiNTllMWViNGNlZjI4ZmQ4N2M5YzQ1YjdjMTU2MjBhODRiOA==", "commit": {"author": {"name": "H.J. Lu", "email": "hjl.tools@gmail.com", "date": "2019-04-03T04:44:55Z"}, "committer": {"name": "liuhongt", "email": "hongtao.liu@intel.com", "date": "2021-09-18T07:00:12Z"}, "message": "AVX512FP16: Add scalar/vector bitwise operations, including\n\n1. FP16 vector xor/ior/and/andnot/abs/neg\n2. FP16 scalar abs/neg/copysign/xorsign\n\ngcc/ChangeLog:\n\n\t* config/i386/i386-expand.c (ix86_expand_fp_absneg_operator):\n\tHandle HFmode.\n\t(ix86_expand_copysign): Ditto.\n\t(ix86_expand_xorsign): Ditto.\n\t* config/i386/i386.c (ix86_build_const_vector): Handle HF vector\n\tmodes.\n\t(ix86_build_signbit_mask): Ditto.\n\t(ix86_can_change_mode_class): Ditto.\n\t* config/i386/i386.md\n\t(SSEMODEF): Add HFmode.\n\t(ssevecmodef): Ditto.\n\t(<code>hf2): New define_expand.\n\t(*<code>hf2_1): New define_insn_and_split.\n\t(copysign<mode>): Extend to support HFmode under AVX512FP16.\n\t(xorsign<mode>): Ditto.\n\t* config/i386/sse.md (VFB): New mode iterator.\n\t(VFB_128_256): Ditto.\n\t(VFB_512): Ditto.\n\t(sseintvecmode2): Support HF vector mode.\n\t(<code><mode>2): Use new mode iterator.\n\t(*<code><mode>2): Ditto.\n\t(copysign<mode>3): Ditto.\n\t(xorsign<mode>3): Ditto.\n\t(<code><mode>3<mask_name>): Ditto.\n\t(<code><mode>3<mask_name>): Ditto.\n\t(<sse>_andnot<mode>3<mask_name>): Adjust for HF vector mode.\n\t(<sse>_andnot<mode>3<mask_name>): Ditto.\n\t(*<code><mode>3<mask_name>): Ditto.\n\t(*<code><mode>3<mask_name>): Ditto.", "tree": {"sha": "0ba14879b1a69e25889a50bfd89cae74a18bf5ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0ba14879b1a69e25889a50bfd89cae74a18bf5ec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": {"login": "algebra84", "id": 22926165, "node_id": "MDQ6VXNlcjIyOTI2MTY1", "avatar_url": "https://avatars.githubusercontent.com/u/22926165?v=4", "gravatar_id": "", "url": "https://api.github.com/users/algebra84", "html_url": "https://github.com/algebra84", "followers_url": "https://api.github.com/users/algebra84/followers", "following_url": "https://api.github.com/users/algebra84/following{/other_user}", "gists_url": "https://api.github.com/users/algebra84/gists{/gist_id}", "starred_url": "https://api.github.com/users/algebra84/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/algebra84/subscriptions", "organizations_url": "https://api.github.com/users/algebra84/orgs", "repos_url": "https://api.github.com/users/algebra84/repos", "events_url": "https://api.github.com/users/algebra84/events{/privacy}", "received_events_url": "https://api.github.com/users/algebra84/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "630a1249a0053ef61fe50a31a348e78dfb229c22", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/630a1249a0053ef61fe50a31a348e78dfb229c22", "html_url": "https://github.com/Rust-GCC/gccrs/commit/630a1249a0053ef61fe50a31a348e78dfb229c22"}], "stats": {"total": 192, "additions": 130, "deletions": 62}, "files": [{"sha": "3ec032b999407aa3e056eb8e546ebfdcc97afc0a", "filename": "gcc/config/i386/i386-expand.c", "status": "modified", "additions": 12, "deletions": 4, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386-expand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-expand.c?ref=75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "patch": "@@ -1981,8 +1981,12 @@ ix86_expand_fp_absneg_operator (enum rtx_code code, machine_mode mode,\n   machine_mode vmode = mode;\n   rtvec par;\n \n-  if (vector_mode || mode == TFmode)\n-    use_sse = true;\n+  if (vector_mode || mode == TFmode || mode == HFmode)\n+    {\n+      use_sse = true;\n+      if (mode == HFmode)\n+\tvmode = V8HFmode;\n+    }\n   else if (TARGET_SSE_MATH)\n     {\n       use_sse = SSE_FLOAT_MODE_P (mode);\n@@ -2123,7 +2127,9 @@ ix86_expand_copysign (rtx operands[])\n \n   mode = GET_MODE (operands[0]);\n \n-  if (mode == SFmode)\n+  if (mode == HFmode)\n+    vmode = V8HFmode;\n+  else if (mode == SFmode)\n     vmode = V4SFmode;\n   else if (mode == DFmode)\n     vmode = V2DFmode;\n@@ -2182,7 +2188,9 @@ ix86_expand_xorsign (rtx operands[])\n \n   mode = GET_MODE (dest);\n \n-  if (mode == SFmode)\n+  if (mode == HFmode)\n+    vmode = V8HFmode;\n+  else if (mode == SFmode)\n     vmode = V4SFmode;\n   else if (mode == DFmode)\n     vmode = V2DFmode;"}, {"sha": "ba89e111d28151ede573298256bfc84cff8d3d0e", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "patch": "@@ -15561,6 +15561,9 @@ ix86_build_const_vector (machine_mode mode, bool vect, rtx value)\n     case E_V2DImode:\n       gcc_assert (vect);\n       /* FALLTHRU */\n+    case E_V8HFmode:\n+    case E_V16HFmode:\n+    case E_V32HFmode:\n     case E_V16SFmode:\n     case E_V8SFmode:\n     case E_V4SFmode:\n@@ -15599,6 +15602,13 @@ ix86_build_signbit_mask (machine_mode mode, bool vect, bool invert)\n \n   switch (mode)\n     {\n+    case E_V8HFmode:\n+    case E_V16HFmode:\n+    case E_V32HFmode:\n+      vec_mode = mode;\n+      imode = HImode;\n+      break;\n+\n     case E_V16SImode:\n     case E_V16SFmode:\n     case E_V8SImode:"}, {"sha": "188f431510a15738805ce21bf488d17b52dc3517", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 31, "deletions": 7, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "patch": "@@ -1237,8 +1237,8 @@\n (define_mode_iterator X87MODEFH [HF SF DF XF])\n \n ;; All SSE floating point modes\n-(define_mode_iterator SSEMODEF [SF DF TF])\n-(define_mode_attr ssevecmodef [(SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n+(define_mode_iterator SSEMODEF [HF SF DF TF])\n+(define_mode_attr ssevecmodef [(HF \"V8HF\") (SF \"V4SF\") (DF \"V2DF\") (TF \"TF\")])\n \n ;; SSE instruction suffix for various modes\n (define_mode_attr ssemodesuffix\n@@ -10732,6 +10732,12 @@\n }\n   [(set_attr \"isa\" \"noavx,noavx,avx,avx\")])\n \n+(define_expand \"<code>hf2\"\n+  [(set (match_operand:HF 0 \"register_operand\")\n+\t(absneg:HF (match_operand:HF 1 \"register_operand\")))]\n+  \"TARGET_AVX512FP16\"\n+  \"ix86_expand_fp_absneg_operator (<CODE>, HFmode, operands); DONE;\")\n+\n (define_expand \"<code><mode>2\"\n   [(set (match_operand:X87MODEF 0 \"register_operand\")\n \t(absneg:X87MODEF (match_operand:X87MODEF 1 \"register_operand\")))]\n@@ -10762,6 +10768,22 @@\n   [(const_int 0)]\n   \"ix86_split_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n+(define_insn_and_split \"*<code>hf2_1\"\n+  [(set (match_operand:HF 0 \"register_operand\" \"=Yv\")\n+\t(absneg:HF\n+\t  (match_operand:HF 1 \"register_operand\" \"Yv\")))\n+   (use (match_operand:V8HF 2 \"vector_operand\" \"Yvm\"))\n+   (clobber (reg:CC FLAGS_REG))]\n+  \"TARGET_AVX512FP16\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(set (match_dup 0)\n+\t(<absneg_op>:V8HF (match_dup 1) (match_dup 2)))]\n+{\n+  operands[0] = lowpart_subreg (V8HFmode, operands[0], HFmode);\n+  operands[1] = lowpart_subreg (V8HFmode, operands[1], HFmode);\n+})\n+\n (define_insn \"*<code><mode>2_1\"\n   [(set (match_operand:MODEF 0 \"register_operand\" \"=x,x,Yv,f,!r\")\n \t(absneg:MODEF\n@@ -10862,14 +10884,16 @@\n    (match_operand:SSEMODEF 1 \"nonmemory_operand\")\n    (match_operand:SSEMODEF 2 \"register_operand\")]\n   \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n-   || (TARGET_SSE && (<MODE>mode == TFmode))\"\n+   || (TARGET_SSE && (<MODE>mode == TFmode))\n+   || (TARGET_AVX512FP16 && (<MODE>mode ==HFmode))\"\n   \"ix86_expand_copysign (operands); DONE;\")\n \n (define_expand \"xorsign<mode>3\"\n-  [(match_operand:MODEF 0 \"register_operand\")\n-   (match_operand:MODEF 1 \"register_operand\")\n-   (match_operand:MODEF 2 \"register_operand\")]\n-  \"SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH\"\n+  [(match_operand:MODEFH 0 \"register_operand\")\n+   (match_operand:MODEFH 1 \"register_operand\")\n+   (match_operand:MODEFH 2 \"register_operand\")]\n+  \"(SSE_FLOAT_MODE_P (<MODE>mode) && TARGET_SSE_MATH)\n+  || <MODE>mode == HFmode\"\n {\n   if (rtx_equal_p (operands[1], operands[2]))\n     emit_insn (gen_abs<mode>2 (operands[0], operands[1]));"}, {"sha": "3b5c05be034408b5b6fbd16abb690335425b23d7", "filename": "gcc/config/i386/sse.md", "status": "modified", "additions": 77, "deletions": 51, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fsse.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/75a97b59e1eb4cef28fd87c9c45b7c15620a84b8/gcc%2Fconfig%2Fi386%2Fsse.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fsse.md?ref=75a97b59e1eb4cef28fd87c9c45b7c15620a84b8", "patch": "@@ -319,11 +319,26 @@\n    (V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n    (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n \n+;; 128-, 256- and 512-bit float vector modes for bitwise operations\n+(define_mode_iterator VFB\n+  [(V32HF \"TARGET_AVX512FP16\")\n+   (V16HF \"TARGET_AVX512FP16\")\n+   (V8HF \"TARGET_AVX512FP16\")\n+   (V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF\n+   (V8DF \"TARGET_AVX512F\") (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n+\n ;; 128- and 256-bit float vector modes\n (define_mode_iterator VF_128_256\n   [(V8SF \"TARGET_AVX\") V4SF\n    (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n \n+;; 128- and 256-bit float vector modes for bitwise operations\n+(define_mode_iterator VFB_128_256\n+  [(V16HF \"TARGET_AVX512FP16\")\n+   (V8HF \"TARGET_AVX512FP16\")\n+   (V8SF \"TARGET_AVX\") V4SF\n+   (V4DF \"TARGET_AVX\") (V2DF \"TARGET_SSE2\")])\n+\n ;; All SFmode vector float modes\n (define_mode_iterator VF1\n   [(V16SF \"TARGET_AVX512F\") (V8SF \"TARGET_AVX\") V4SF])\n@@ -376,6 +391,10 @@\n (define_mode_iterator VF_512\n   [V16SF V8DF])\n \n+;; All 512bit vector float modes for bitwise operations\n+(define_mode_iterator VFB_512\n+  [(V32HF \"TARGET_AVX512FP16\") V16SF V8DF])\n+\n (define_mode_iterator VI48_AVX512VL\n   [V16SI (V8SI  \"TARGET_AVX512VL\") (V4SI  \"TARGET_AVX512VL\")\n    V8DI  (V4DI  \"TARGET_AVX512VL\") (V2DI  \"TARGET_AVX512VL\")])\n@@ -954,7 +973,8 @@\n \n (define_mode_attr sseintvecmode2\n   [(V8DF \"XI\") (V4DF \"OI\") (V2DF \"TI\")\n-   (V8SF \"OI\") (V4SF \"TI\")])\n+   (V8SF \"OI\") (V4SF \"TI\")\n+   (V16HF \"OI\") (V8HF \"TI\")])\n \n (define_mode_attr sseintvecmodelower\n   [(V16SF \"v16si\") (V8DF \"v8di\")\n@@ -2030,22 +2050,22 @@\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n (define_expand \"<code><mode>2\"\n-  [(set (match_operand:VF 0 \"register_operand\")\n-\t(absneg:VF\n-\t  (match_operand:VF 1 \"register_operand\")))]\n+  [(set (match_operand:VFB 0 \"register_operand\")\n+\t(absneg:VFB\n+\t  (match_operand:VFB 1 \"register_operand\")))]\n   \"TARGET_SSE\"\n   \"ix86_expand_fp_absneg_operator (<CODE>, <MODE>mode, operands); DONE;\")\n \n (define_insn_and_split \"*<code><mode>2\"\n-  [(set (match_operand:VF 0 \"register_operand\" \"=x,x,v,v\")\n-\t(absneg:VF\n-\t  (match_operand:VF 1 \"vector_operand\" \"0,xBm,v,m\")))\n-   (use (match_operand:VF 2 \"vector_operand\" \"xBm,0,vm,v\"))]\n+  [(set (match_operand:VFB 0 \"register_operand\" \"=x,x,v,v\")\n+\t(absneg:VFB\n+\t  (match_operand:VFB 1 \"vector_operand\" \"0,xBm,v,m\")))\n+   (use (match_operand:VFB 2 \"vector_operand\" \"xBm,0,vm,v\"))]\n   \"TARGET_SSE\"\n   \"#\"\n   \"&& reload_completed\"\n   [(set (match_dup 0)\n-\t(<absneg_op>:VF (match_dup 1) (match_dup 2)))]\n+\t(<absneg_op>:VFB (match_dup 1) (match_dup 2)))]\n {\n   if (TARGET_AVX)\n     {\n@@ -4073,11 +4093,11 @@\n ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\n \n (define_insn \"<sse>_andnot<mode>3<mask_name>\"\n-  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,x,v,v\")\n-\t(and:VF_128_256\n-\t  (not:VF_128_256\n-\t    (match_operand:VF_128_256 1 \"register_operand\" \"0,x,v,v\"))\n-\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n+  [(set (match_operand:VFB_128_256 0 \"register_operand\" \"=x,x,v,v\")\n+\t(and:VFB_128_256\n+\t  (not:VFB_128_256\n+\t    (match_operand:VFB_128_256 1 \"register_operand\" \"0,x,v,v\"))\n+\t  (match_operand:VFB_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\"\n {\n   char buf[128];\n@@ -4100,6 +4120,8 @@\n \n   switch (get_attr_mode (insn))\n     {\n+    case MODE_V16HF:\n+    case MODE_V8HF:\n     case MODE_V8SF:\n     case MODE_V4SF:\n       suffix = \"ps\";\n@@ -4138,11 +4160,11 @@\n \t      (const_string \"<MODE>\")))])\n \n (define_insn \"<sse>_andnot<mode>3<mask_name>\"\n-  [(set (match_operand:VF_512 0 \"register_operand\" \"=v\")\n-\t(and:VF_512\n-\t  (not:VF_512\n-\t    (match_operand:VF_512 1 \"register_operand\" \"v\"))\n-\t  (match_operand:VF_512 2 \"nonimmediate_operand\" \"vm\")))]\n+  [(set (match_operand:VFB_512 0 \"register_operand\" \"=v\")\n+\t(and:VFB_512\n+\t  (not:VFB_512\n+\t    (match_operand:VFB_512 1 \"register_operand\" \"v\"))\n+\t  (match_operand:VFB_512 2 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX512F\"\n {\n   char buf[128];\n@@ -4152,8 +4174,9 @@\n   suffix = \"<ssemodesuffix>\";\n   ops = \"\";\n \n-  /* There is no vandnp[sd] in avx512f.  Use vpandn[qd].  */\n-  if (!TARGET_AVX512DQ)\n+  /* Since there are no vandnp[sd] without AVX512DQ nor vandnph,\n+     use vp<logic>[dq].  */\n+  if (!TARGET_AVX512DQ || <MODE>mode == V32HFmode)\n     {\n       suffix = GET_MODE_INNER (<MODE>mode) == DFmode ? \"q\" : \"d\";\n       ops = \"p\";\n@@ -4173,26 +4196,26 @@\n \t\t      (const_string \"XI\")))])\n \n (define_expand \"<code><mode>3<mask_name>\"\n-  [(set (match_operand:VF_128_256 0 \"register_operand\")\n-       (any_logic:VF_128_256\n-         (match_operand:VF_128_256 1 \"vector_operand\")\n-         (match_operand:VF_128_256 2 \"vector_operand\")))]\n+  [(set (match_operand:VFB_128_256 0 \"register_operand\")\n+       (any_logic:VFB_128_256\n+         (match_operand:VFB_128_256 1 \"vector_operand\")\n+         (match_operand:VFB_128_256 2 \"vector_operand\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_expand \"<code><mode>3<mask_name>\"\n-  [(set (match_operand:VF_512 0 \"register_operand\")\n-       (any_logic:VF_512\n-         (match_operand:VF_512 1 \"nonimmediate_operand\")\n-         (match_operand:VF_512 2 \"nonimmediate_operand\")))]\n+  [(set (match_operand:VFB_512 0 \"register_operand\")\n+       (any_logic:VFB_512\n+         (match_operand:VFB_512 1 \"nonimmediate_operand\")\n+         (match_operand:VFB_512 2 \"nonimmediate_operand\")))]\n   \"TARGET_AVX512F\"\n   \"ix86_fixup_binary_operands_no_copy (<CODE>, <MODE>mode, operands);\")\n \n (define_insn \"*<code><mode>3<mask_name>\"\n-  [(set (match_operand:VF_128_256 0 \"register_operand\" \"=x,x,v,v\")\n-\t(any_logic:VF_128_256\n-\t  (match_operand:VF_128_256 1 \"vector_operand\" \"%0,x,v,v\")\n-\t  (match_operand:VF_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n+  [(set (match_operand:VFB_128_256 0 \"register_operand\" \"=x,x,v,v\")\n+\t(any_logic:VFB_128_256\n+\t  (match_operand:VFB_128_256 1 \"vector_operand\" \"%0,x,v,v\")\n+\t  (match_operand:VFB_128_256 2 \"vector_operand\" \"xBm,xm,vm,vm\")))]\n   \"TARGET_SSE && <mask_avx512vl_condition>\n    && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n {\n@@ -4216,6 +4239,8 @@\n \n   switch (get_attr_mode (insn))\n     {\n+    case MODE_V16HF:\n+    case MODE_V8HF:\n     case MODE_V8SF:\n     case MODE_V4SF:\n       suffix = \"ps\";\n@@ -4254,10 +4279,10 @@\n \t      (const_string \"<MODE>\")))])\n \n (define_insn \"*<code><mode>3<mask_name>\"\n-  [(set (match_operand:VF_512 0 \"register_operand\" \"=v\")\n-\t(any_logic:VF_512\n-\t  (match_operand:VF_512 1 \"nonimmediate_operand\" \"%v\")\n-\t  (match_operand:VF_512 2 \"nonimmediate_operand\" \"vm\")))]\n+  [(set (match_operand:VFB_512 0 \"register_operand\" \"=v\")\n+\t(any_logic:VFB_512\n+\t  (match_operand:VFB_512 1 \"nonimmediate_operand\" \"%v\")\n+\t  (match_operand:VFB_512 2 \"nonimmediate_operand\" \"vm\")))]\n   \"TARGET_AVX512F && !(MEM_P (operands[1]) && MEM_P (operands[2]))\"\n {\n   char buf[128];\n@@ -4267,8 +4292,9 @@\n   suffix = \"<ssemodesuffix>\";\n   ops = \"\";\n \n-  /* There is no v<logic>p[sd] in avx512f.  Use vp<logic>[dq].  */\n-  if (!TARGET_AVX512DQ)\n+  /* Since there are no v<logic>p[sd] without AVX512DQ nor v<logic>ph,\n+     use vp<logic>[dq].  */\n+  if (!TARGET_AVX512DQ || <MODE>mode == V32HFmode)\n     {\n       suffix = GET_MODE_INNER (<MODE>mode) == DFmode ? \"q\" : \"d\";\n       ops = \"p\";\n@@ -4289,14 +4315,14 @@\n \n (define_expand \"copysign<mode>3\"\n   [(set (match_dup 4)\n-\t(and:VF\n-\t  (not:VF (match_dup 3))\n-\t  (match_operand:VF 1 \"vector_operand\")))\n+\t(and:VFB\n+\t  (not:VFB (match_dup 3))\n+\t  (match_operand:VFB 1 \"vector_operand\")))\n    (set (match_dup 5)\n-\t(and:VF (match_dup 3)\n-\t\t(match_operand:VF 2 \"vector_operand\")))\n-   (set (match_operand:VF 0 \"register_operand\")\n-\t(ior:VF (match_dup 4) (match_dup 5)))]\n+\t(and:VFB (match_dup 3)\n+\t\t (match_operand:VFB 2 \"vector_operand\")))\n+   (set (match_operand:VFB 0 \"register_operand\")\n+\t(ior:VFB (match_dup 4) (match_dup 5)))]\n   \"TARGET_SSE\"\n {\n   operands[3] = ix86_build_signbit_mask (<MODE>mode, 1, 0);\n@@ -4307,11 +4333,11 @@\n \n (define_expand \"xorsign<mode>3\"\n   [(set (match_dup 4)\n-\t(and:VF (match_dup 3)\n-\t\t(match_operand:VF 2 \"vector_operand\")))\n-   (set (match_operand:VF 0 \"register_operand\")\n-\t(xor:VF (match_dup 4)\n-\t\t(match_operand:VF 1 \"vector_operand\")))]\n+\t(and:VFB (match_dup 3)\n+\t\t(match_operand:VFB 2 \"vector_operand\")))\n+   (set (match_operand:VFB 0 \"register_operand\")\n+\t(xor:VFB (match_dup 4)\n+\t\t (match_operand:VFB 1 \"vector_operand\")))]\n   \"TARGET_SSE\"\n {\n   operands[3] = ix86_build_signbit_mask (<MODE>mode, 1, 0);"}]}