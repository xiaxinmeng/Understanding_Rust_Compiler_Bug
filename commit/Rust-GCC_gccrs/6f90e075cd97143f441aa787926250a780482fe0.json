{"sha": "6f90e075cd97143f441aa787926250a780482fe0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmY5MGUwNzVjZDk3MTQzZjQ0MWFhNzg3OTI2MjUwYTc4MDQ4MmZlMA==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-05T17:27:49Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1992-05-05T17:27:49Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r905", "tree": {"sha": "487841743bc3aaf704ff84a33e716f54944fb89c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/487841743bc3aaf704ff84a33e716f54944fb89c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6f90e075cd97143f441aa787926250a780482fe0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f90e075cd97143f441aa787926250a780482fe0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f90e075cd97143f441aa787926250a780482fe0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f90e075cd97143f441aa787926250a780482fe0/comments", "author": null, "committer": null, "parents": [{"sha": "f6eed26d8041cda74e0d2cff541db2f033873e28", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f6eed26d8041cda74e0d2cff541db2f033873e28", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f6eed26d8041cda74e0d2cff541db2f033873e28"}], "stats": {"total": 68, "additions": 55, "deletions": 13}, "files": [{"sha": "90cdb8acbc996d09c3b9fc86a628678fdf045a49", "filename": "gcc/calls.c", "status": "modified", "additions": 29, "deletions": 11, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fcalls.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fcalls.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcalls.c?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -432,6 +432,9 @@ expand_call (exp, target, ignore)\n #endif\n #endif\n \n+  /* Size of the stack reserved for paramter registers.  */\n+  int reg_parm_stack_space = 0;\n+\n   /* 1 if scanning parms front to back, -1 if scanning back to front.  */\n   int inc;\n   /* Address of space preallocated for stack parms\n@@ -513,6 +516,14 @@ expand_call (exp, target, ignore)\n \n   is_volatile = TYPE_VOLATILE (TREE_TYPE (TREE_TYPE (p)));\n \n+#ifdef REG_PARM_STACK_SPACE\n+#ifdef MAYBE_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = MAYBE_REG_PARM_STACK_SPACE;\n+#else\n+  reg_parm_stack_space = REG_PARM_STACK_SPACE (fndecl);\n+#endif\n+#endif\n+\n   /* Warn if this value is an aggregate type,\n      regardless of which calling convention we are using for it.  */\n   if (warn_aggregate_return\n@@ -844,7 +855,7 @@ expand_call (exp, target, ignore)\n       /* Compute the stack-size of this argument.  */\n       if (args[i].reg == 0 || args[i].partial != 0\n #ifdef REG_PARM_STACK_SPACE\n-\t  || REG_PARM_STACK_SPACE (fndecl) > 0\n+\t  || reg_parm_stack_space > 0\n #endif\n \t  || args[i].pass_on_stack)\n \tlocate_and_pad_parm (TYPE_MODE (type), type,\n@@ -896,6 +907,11 @@ expand_call (exp, target, ignore)\n \t\t\t    argpos < n_named_args);\n     }\n \n+#ifdef FINAL_REG_PARM_STACK_SPACE\n+  reg_parm_stack_space = FINAL_REG_PARM_STACK_SPACE (args_size.constant,\n+\t\t\t\t\t\t     args_size.var);\n+#endif\n+      \n   /* Compute the actual size of the argument block required.  The variable\n      and constant sizes must be combined, the size may have to be rounded,\n      and there may be a minimum required size.  */\n@@ -920,7 +936,7 @@ expand_call (exp, target, ignore)\n #endif\n \n #ifdef REG_PARM_STACK_SPACE\n-      if (REG_PARM_STACK_SPACE (fndecl) > 0)\n+      if (reg_parm_stack_space > 0)\n \t{\n \t  args_size.var\n \t    = size_binop (MAX_EXPR, args_size.var,\n@@ -931,7 +947,7 @@ expand_call (exp, target, ignore)\n \t     the size of the block we need.  So make the adjustment.  */\n \t  args_size.var\n \t    = size_binop (MINUS_EXPR, args_size.var,\n-\t\t\t  size_int (REG_PARM_STACK_SPACE (fndecl)));\n+\t\t\t  size_int (reg_parm_stack_space));\n #endif\n \t}\n #endif\n@@ -945,9 +961,9 @@ expand_call (exp, target, ignore)\n \n #ifdef REG_PARM_STACK_SPACE\n       args_size.constant = MAX (args_size.constant,\n-\t\t\t\tREG_PARM_STACK_SPACE (fndecl));\n+\t\t\t\treg_parm_stack_space);\n #ifndef OUTGOING_REG_PARM_STACK_SPACE\n-      args_size.constant -= REG_PARM_STACK_SPACE (fndecl);\n+      args_size.constant -= reg_parm_stack_space;\n #endif\n #endif\n     }\n@@ -1082,7 +1098,7 @@ expand_call (exp, target, ignore)\n       /* Since we will be writing into the entire argument area, the\n \t map must be allocated for its entire size, not just the part that\n \t is the responsibility of the caller.  */\n-      needed += REG_PARM_STACK_SPACE (fndecl);\n+      needed += reg_parm_stack_space;\n #endif\n \n #ifdef ARGS_GROW_DOWNWARD\n@@ -1246,7 +1262,7 @@ expand_call (exp, target, ignore)\n \n      Here we compute the boundary of the that needs to be saved, if any.  */\n \n-  for (i = 0; i < REG_PARM_STACK_SPACE (fndecl); i++)\n+  for (i = 0; i < reg_parm_stack_space; i++)\n     {\n       if (i >=  highest_outgoing_arg_in_use\n \t  || stack_usage_map[i] == 0)\n@@ -1299,15 +1315,15 @@ expand_call (exp, target, ignore)\n   for (i = 0; i < num_actuals; i++)\n     if (args[i].reg == 0 || args[i].pass_on_stack)\n       store_one_arg (&args[i], argblock, may_be_alloca,\n-\t\t     args_size.var != 0, fndecl);\n+\t\t     args_size.var != 0, fndecl, reg_parm_stack_space);\n \n   /* Now store any partially-in-registers parm.\n      This is the last place a block-move can happen.  */\n   if (reg_parm_seen)\n     for (i = 0; i < num_actuals; i++)\n       if (args[i].partial != 0 && ! args[i].pass_on_stack)\n \tstore_one_arg (&args[i], argblock, may_be_alloca,\n-\t\t       args_size.var != 0, fndecl);\n+\t\t       args_size.var != 0, fndecl, reg_parm_stack_space);\n \n #ifndef PUSH_ARGS_REVERSED\n #ifdef STACK_BOUNDARY\n@@ -1618,12 +1634,14 @@ target_for_arg (type, size, args_addr, offset)\n    FNDECL is the declaration of the function we are calling.  */\n \n static void\n-store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl)\n+store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl,\n+\t       reg_parm_stack_space)\n      struct arg_data *arg;\n      rtx argblock;\n      int may_be_alloca;\n      int variable_size;\n      tree fndecl;\n+     int reg_parm_stack_space;\n {\n   register tree pval = arg->tree_value;\n   rtx reg = 0;\n@@ -1662,7 +1680,7 @@ store_one_arg (arg, argblock, may_be_alloca, variable_size, fndecl)\n #ifdef REG_PARM_STACK_SPACE\n \t    /* Don't store things in the fixed argument area at this point;\n \t       it has already been saved.  */\n-\t    && i > REG_PARM_STACK_SPACE (fndecl)\n+\t    && i > reg_parm_stack_space\n #endif\n \t    )\n \t  break;"}, {"sha": "beb3e2b5dec611e54e9418be6271670cd19c2d54", "filename": "gcc/cse.c", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -524,10 +524,21 @@ struct write_data\n \t   || XEXP (X, 0) == virtual_stack_vars_rtx\t\t\\\n \t   || XEXP (X, 0) == virtual_incoming_args_rtx)))\n \n-/* Similar, but also allows reference to the stack pointer.  */\n+/* Similar, but also allows reference to the stack pointer.\n+\n+   This used to include FIXED_BASE_PLUS_P, however, we can't assume that\n+   arg_pointer_rtx by itself is nonzero, because on at least one machine,\n+   the i960, the arg pointer is zero when it is unused.  */\n \n #define NONZERO_BASE_PLUS_P(X)\t\t\t\t\t\\\n-  (FIXED_BASE_PLUS_P (X)\t\t\t\t\t\\\n+  ((X) == frame_pointer_rtx\t\t\t\t\t\\\n+   || (X) == virtual_stack_vars_rtx\t\t\t\t\\\n+   || (X) == virtual_incoming_args_rtx\t\t\t\t\\\n+   || (GET_CODE (X) == PLUS && GET_CODE (XEXP (X, 1)) == CONST_INT \\\n+       && (XEXP (X, 0) == frame_pointer_rtx\t\t\t\\\n+\t   || XEXP (X, 0) == arg_pointer_rtx\t\t\t\\\n+\t   || XEXP (X, 0) == virtual_stack_vars_rtx\t\t\\\n+\t   || XEXP (X, 0) == virtual_incoming_args_rtx))\t\\\n    || (X) == stack_pointer_rtx\t\t\t\t\t\\\n    || (X) == virtual_stack_dynamic_rtx\t\t\t\t\\\n    || (X) == virtual_outgoing_args_rtx\t\t\t\t\\"}, {"sha": "680e258c071b1609ca333373aea9eb20892f6523", "filename": "gcc/expr.c", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -3681,6 +3681,9 @@ expand_expr (exp, target, tmode, modifier)\n \t  temp = simplify_binary_operation (PLUS, mode, XEXP (op1, 0), op0);\n \t  if (temp != 0)\n \t    op0 = temp;\n+\t  /* Ensure that MULT comes first if there is one.  */\n+\t  else if (GET_CODE (op0) == MULT)\n+\t    op0 = gen_rtx (PLUS, mode, op0, XEXP (op1, 0));\n \t  else\n \t    op0 = gen_rtx (PLUS, mode, XEXP (op1, 0), op0);\n "}, {"sha": "c9a9e9520842351ffebd7ad5f11c5aadd48c0684", "filename": "gcc/function.c", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -2916,9 +2916,11 @@ assign_parms (fndecl, second_time)\n      minimum length.  */\n \n #ifdef REG_PARM_STACK_SPACE\n+#ifndef MAYBE_REG_PARM_STACK_SPACE\n   current_function_args_size = MAX (current_function_args_size,\n \t\t\t\t    REG_PARM_STACK_SPACE (fndecl));\n #endif\n+#endif\n \n #ifdef STACK_BOUNDARY\n #define STACK_BYTES (STACK_BOUNDARY / BITS_PER_UNIT)"}, {"sha": "bb81825d71a7e4864c1b6bffa6e1ed5c623e6077", "filename": "gcc/ginclude/stdarg.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fginclude%2Fstdarg.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fginclude%2Fstdarg.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fstdarg.h?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -25,6 +25,9 @@\n #ifdef __sparc__\n #include \"va-sparc.h\"\n #else\n+#ifdef __i960__\n+#include \"va-i960.h\"\n+#else\n \n #ifdef _HIDDEN_VA_LIST  /* On OSF1, this means varargs.h is \"half-loaded\".  */\n #undef _VA_LIST\n@@ -56,6 +59,7 @@ void va_end (va_list);\t\t/* Defined in libgcc.a */\n  (AP += __va_rounded_size (TYPE),\t\t\t\t\t\\\n   *((TYPE *) (AP - __va_rounded_size (TYPE))))\n \n+#endif /* not i960 */\n #endif /* not sparc */\n #endif /* not mips */\n #endif /* not hp9000s800 */"}, {"sha": "214bf6d9cee178179b5d63cd5187d7516f32d6d5", "filename": "gcc/ginclude/varargs.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fginclude%2Fvarargs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6f90e075cd97143f441aa787926250a780482fe0/gcc%2Fginclude%2Fvarargs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fginclude%2Fvarargs.h?ref=6f90e075cd97143f441aa787926250a780482fe0", "patch": "@@ -28,6 +28,9 @@\n #ifdef __hp9000s800__\n #include \"va-hp800.h\"\n #else\n+#ifdef __i960__\n+#include \"va-i960.h\"\n+#else\n \n #ifdef __NeXT__\n \n@@ -95,6 +98,7 @@ typedef char * __va___list;\n  (AP += __va_rounded_size (TYPE),\t\t\t\t\t\\\n   *((TYPE *) (AP - __va_rounded_size (TYPE))))\n \n+#endif /* not i960 */\n #endif /* not hp800 */\n #endif /* not m88k */\n #endif /* not pyr */"}]}