{"sha": "1018981977de9f2056cdfcd8173458e85a3751f2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTAxODk4MTk3N2RlOWYyMDU2Y2RmY2Q4MTczNDU4ZTg1YTM3NTFmMg==", "commit": {"author": {"name": "Maxim Ostapenko", "email": "m.ostapenko@samsung.com", "date": "2016-11-08T22:04:09Z"}, "committer": {"name": "Maxim Ostapenko", "email": "chefmax@gcc.gnu.org", "date": "2016-11-08T22:04:09Z"}, "message": "All source files: Merge from upstream 285547.\n\nlibsanitizer/\n\n\t* All source files: Merge from upstream 285547.\n\t* configure.tgt (SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS): New\n\tvariable.\n\t* configure.ac (SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS): Handle it.\n\t* asan/Makefile.am (asan_files): Add new files.\n\t* asan/Makefile.in: Regenerate.\n\t* ubsan/Makefile.in: Likewise.\n\t* lsan/Makefile.in: Likewise.\n\t* tsan/Makefile.am (tsan_files): Add new files.\n\t* tsan/Makefile.in: Regenerate.\n\t* sanitizer_common/Makefile.am (sanitizer_common_files): Add new files.\n\t(EXTRA_libsanitizer_common_la_SOURCES): Define.\n\t(libsanitizer_common_la_LIBADD): Likewise.\n\t(libsanitizer_common_la_DEPENDENCIES): Likewise.\n\t* sanitizer_common/Makefile.in: Regenerate.\n\t* interception/Makefile.in: Likewise.\n\t* libbacktace/Makefile.in: Likewise.\n\t* Makefile.in: Likewise.\n\t* configure: Likewise.\n\t* merge.sh: Handle builtins/assembly.h merging.\n\t* builtins/assembly.h: New file.\n\t* asan/libtool-version: Bump the libasan SONAME.\n\nFrom-SVN: r241977", "tree": {"sha": "9c1a8b279416b5f379d7631c1b7f36ab18797212", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9c1a8b279416b5f379d7631c1b7f36ab18797212"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1018981977de9f2056cdfcd8173458e85a3751f2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1018981977de9f2056cdfcd8173458e85a3751f2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1018981977de9f2056cdfcd8173458e85a3751f2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1018981977de9f2056cdfcd8173458e85a3751f2/comments", "author": null, "committer": null, "parents": [{"sha": "f31d9224e6346c775648139ae3f5acf3b70582e0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f31d9224e6346c775648139ae3f5acf3b70582e0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f31d9224e6346c775648139ae3f5acf3b70582e0"}], "stats": {"total": 19916, "additions": 14569, "deletions": 5347}, "files": [{"sha": "a490230f594c1438e3b7a0a3a4b715019d18f615", "filename": "libsanitizer/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FChangeLog?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -1,3 +1,28 @@\n+2016-11-09  Maxim Ostapenko  <m.ostapenko@samsung.com>\n+\n+\t* All source files: Merge from upstream 285547.\n+\t* configure.tgt (SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS): New\n+\tvariable.\n+\t* configure.ac (SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS): Handle it.\n+\t* asan/Makefile.am (asan_files): Add new files.\n+\t* asan/Makefile.in: Regenerate.\n+\t* ubsan/Makefile.in: Likewise.\n+\t* lsan/Makefile.in: Likewise.\n+\t* tsan/Makefile.am (tsan_files): Add new files.\n+\t* tsan/Makefile.in: Regenerate.\n+\t* sanitizer_common/Makefile.am (sanitizer_common_files): Add new files.\n+\t(EXTRA_libsanitizer_common_la_SOURCES): Define.\n+\t(libsanitizer_common_la_LIBADD): Likewise.\n+\t(libsanitizer_common_la_DEPENDENCIES): Likewise.\n+\t* sanitizer_common/Makefile.in: Regenerate.\n+\t* interception/Makefile.in: Likewise.\n+\t* libbacktace/Makefile.in: Likewise.\n+\t* Makefile.in: Likewise.\n+\t* configure: Likewise.\n+\t* merge.sh: Handle builtins/assembly.h merging.\n+\t* builtins/assembly.h: New file.\n+\t* asan/libtool-version: Bump the libasan SONAME.\n+\n 2016-09-21  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR sanitizer/77567"}, {"sha": "21c2f390e9728be4b0bde2b125c531da9dc04d2c", "filename": "libsanitizer/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMERGE?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -1,4 +1,4 @@\n-253555\n+285547\n \n The first line of this file holds the svn revision number of the\n last merge done from the master library sources."}, {"sha": "28ba4b8e46a1d118e56dfdf3872e07e314197e50", "filename": "libsanitizer/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -210,6 +210,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@"}, {"sha": "bfd28c0388e4edca5c05f0adfd625f99c82908d4", "filename": "libsanitizer/asan/Makefile.am", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.am?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -19,6 +19,8 @@ asan_files = \\\n \tasan_activation.cc \\\n \tasan_allocator.cc \\\n \tasan_debugging.cc \\\n+\tasan_descriptions.cc \\\n+\tasan_errors.cc \\\n \tasan_fake_stack.cc \\\n \tasan_flags.cc \\\n \tasan_globals.cc \\\n@@ -28,6 +30,7 @@ asan_files = \\\n \tasan_malloc_linux.cc \\\n \tasan_malloc_mac.cc \\\n \tasan_malloc_win.cc \\\n+\tasan_memory_profile.cc \\\n \tasan_new_delete.cc \\\n \tasan_poisoning.cc \\\n \tasan_posix.cc \\"}, {"sha": "2d9f4a7b815e6a763cfce6edf419e1d81692ba7f", "filename": "libsanitizer/asan/Makefile.in", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -112,9 +112,10 @@ libasan_la_DEPENDENCIES =  \\\n \t$(top_builddir)/lsan/libsanitizer_lsan.la $(am__append_2) \\\n \t$(am__append_3) $(am__DEPENDENCIES_1)\n am__objects_1 = asan_activation.lo asan_allocator.lo asan_debugging.lo \\\n-\tasan_fake_stack.lo asan_flags.lo asan_globals.lo \\\n-\tasan_interceptors.lo asan_linux.lo asan_mac.lo \\\n-\tasan_malloc_linux.lo asan_malloc_mac.lo asan_malloc_win.lo \\\n+\tasan_descriptions.lo asan_errors.lo asan_fake_stack.lo \\\n+\tasan_flags.lo asan_globals.lo asan_interceptors.lo \\\n+\tasan_linux.lo asan_mac.lo asan_malloc_linux.lo \\\n+\tasan_malloc_mac.lo asan_malloc_win.lo asan_memory_profile.lo \\\n \tasan_new_delete.lo asan_poisoning.lo asan_posix.lo \\\n \tasan_report.lo asan_rtl.lo asan_stack.lo asan_stats.lo \\\n \tasan_suppressions.lo asan_thread.lo asan_win.lo \\\n@@ -219,6 +220,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@\n@@ -308,6 +310,8 @@ asan_files = \\\n \tasan_activation.cc \\\n \tasan_allocator.cc \\\n \tasan_debugging.cc \\\n+\tasan_descriptions.cc \\\n+\tasan_errors.cc \\\n \tasan_fake_stack.cc \\\n \tasan_flags.cc \\\n \tasan_globals.cc \\\n@@ -317,6 +321,7 @@ asan_files = \\\n \tasan_malloc_linux.cc \\\n \tasan_malloc_mac.cc \\\n \tasan_malloc_win.cc \\\n+\tasan_memory_profile.cc \\\n \tasan_new_delete.cc \\\n \tasan_poisoning.cc \\\n \tasan_posix.cc \\\n@@ -454,6 +459,8 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_activation.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_debugging.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_descriptions.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_errors.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_fake_stack.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_globals.Plo@am__quote@\n@@ -463,6 +470,7 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_malloc_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_memory_profile.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_new_delete.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_poisoning.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/asan_posix.Plo@am__quote@"}, {"sha": "ecd767c5985d0624a66cfddc0dd5947ffea1ef80", "filename": "libsanitizer/asan/asan_activation.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_activation.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_activation.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_activation.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -45,6 +45,7 @@ static struct AsanDeactivatedFlags {\n     FlagParser parser;\n     RegisterActivationFlags(&parser, &f, &cf);\n \n+    cf.SetDefaults();\n     // Copy the current activation flags.\n     allocator_options.CopyTo(&f, &cf);\n     cf.malloc_context_size = malloc_context_size;\n@@ -59,12 +60,7 @@ static struct AsanDeactivatedFlags {\n       parser.ParseString(env);\n     }\n \n-    // Override from getprop asan.options.\n-    char buf[100];\n-    GetExtraActivationFlags(buf, sizeof(buf));\n-    parser.ParseString(buf);\n-\n-    SetVerbosity(cf.verbosity);\n+    InitializeCommonFlags(&cf);\n \n     if (Verbosity()) ReportUnrecognizedFlags();\n "}, {"sha": "d3ddb904d58e0bfe21e8ce08e02ad9d45dfcbba9", "filename": "libsanitizer/asan/asan_allocator.cc", "status": "modified", "additions": 83, "deletions": 23, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -221,7 +221,7 @@ void AllocatorOptions::CopyTo(Flags *f, CommonFlags *cf) {\n \n struct Allocator {\n   static const uptr kMaxAllowedMallocSize =\n-      FIRST_32_SECOND_64(3UL << 30, 1UL << 40);\n+      FIRST_32_SECOND_64(3UL << 30, 1ULL << 40);\n   static const uptr kMaxThreadLocalQuarantine =\n       FIRST_32_SECOND_64(1 << 18, 1 << 20);\n \n@@ -264,9 +264,43 @@ struct Allocator {\n     SharedInitCode(options);\n   }\n \n+  void RePoisonChunk(uptr chunk) {\n+    // This could a user-facing chunk (with redzones), or some internal\n+    // housekeeping chunk, like TransferBatch. Start by assuming the former.\n+    AsanChunk *ac = GetAsanChunk((void *)chunk);\n+    uptr allocated_size = allocator.GetActuallyAllocatedSize((void *)ac);\n+    uptr beg = ac->Beg();\n+    uptr end = ac->Beg() + ac->UsedSize(true);\n+    uptr chunk_end = chunk + allocated_size;\n+    if (chunk < beg && beg < end && end <= chunk_end) {\n+      // Looks like a valid AsanChunk. Or maybe not. Be conservative and only\n+      // poison the redzones.\n+      PoisonShadow(chunk, beg - chunk, kAsanHeapLeftRedzoneMagic);\n+      uptr end_aligned_down = RoundDownTo(end, SHADOW_GRANULARITY);\n+      FastPoisonShadowPartialRightRedzone(\n+          end_aligned_down, end - end_aligned_down,\n+          chunk_end - end_aligned_down, kAsanHeapLeftRedzoneMagic);\n+    } else {\n+      // This can not be an AsanChunk. Poison everything. It may be reused as\n+      // AsanChunk later.\n+      PoisonShadow(chunk, allocated_size, kAsanHeapLeftRedzoneMagic);\n+    }\n+  }\n+\n   void ReInitialize(const AllocatorOptions &options) {\n     allocator.SetMayReturnNull(options.may_return_null);\n     SharedInitCode(options);\n+\n+    // Poison all existing allocation's redzones.\n+    if (CanPoisonMemory()) {\n+      allocator.ForceLock();\n+      allocator.ForEachChunk(\n+          [](uptr chunk, void *alloc) {\n+            ((Allocator *)alloc)->RePoisonChunk(chunk);\n+          },\n+          this);\n+      allocator.ForceUnlock();\n+    }\n   }\n \n   void GetOptions(AllocatorOptions *options) const {\n@@ -354,7 +388,7 @@ struct Allocator {\n     if (size > kMaxAllowedMallocSize || needed_size > kMaxAllowedMallocSize) {\n       Report(\"WARNING: AddressSanitizer failed to allocate 0x%zx bytes\\n\",\n              (void*)size);\n-      return allocator.ReturnNullOrDie();\n+      return allocator.ReturnNullOrDieOnBadRequest();\n     }\n \n     AsanThread *t = GetCurrentThread();\n@@ -371,8 +405,7 @@ struct Allocator {\n           allocator.Allocate(cache, needed_size, 8, false, check_rss_limit);\n     }\n \n-    if (!allocated)\n-      return allocator.ReturnNullOrDie();\n+    if (!allocated) return allocator.ReturnNullOrDieOnOOM();\n \n     if (*(u8 *)MEM_TO_SHADOW((uptr)allocated) == 0 && CanPoisonMemory()) {\n       // Heap poisoning is enabled, but the allocator provides an unpoisoned\n@@ -455,29 +488,28 @@ struct Allocator {\n     return res;\n   }\n \n-  void AtomicallySetQuarantineFlag(AsanChunk *m, void *ptr,\n+  // Set quarantine flag if chunk is allocated, issue ASan error report on\n+  // available and quarantined chunks. Return true on success, false otherwise.\n+  bool AtomicallySetQuarantineFlagIfAllocated(AsanChunk *m, void *ptr,\n                                    BufferedStackTrace *stack) {\n     u8 old_chunk_state = CHUNK_ALLOCATED;\n     // Flip the chunk_state atomically to avoid race on double-free.\n-    if (!atomic_compare_exchange_strong((atomic_uint8_t*)m, &old_chunk_state,\n-                                        CHUNK_QUARANTINE, memory_order_acquire))\n+    if (!atomic_compare_exchange_strong((atomic_uint8_t *)m, &old_chunk_state,\n+                                        CHUNK_QUARANTINE,\n+                                        memory_order_acquire)) {\n       ReportInvalidFree(ptr, old_chunk_state, stack);\n+      // It's not safe to push a chunk in quarantine on invalid free.\n+      return false;\n+    }\n     CHECK_EQ(CHUNK_ALLOCATED, old_chunk_state);\n+    return true;\n   }\n \n   // Expects the chunk to already be marked as quarantined by using\n-  // AtomicallySetQuarantineFlag.\n+  // AtomicallySetQuarantineFlagIfAllocated.\n   void QuarantineChunk(AsanChunk *m, void *ptr, BufferedStackTrace *stack,\n                        AllocType alloc_type) {\n     CHECK_EQ(m->chunk_state, CHUNK_QUARANTINE);\n-\n-    if (m->alloc_type != alloc_type) {\n-      if (atomic_load(&alloc_dealloc_mismatch, memory_order_acquire)) {\n-        ReportAllocTypeMismatch((uptr)ptr, stack, (AllocType)m->alloc_type,\n-                                (AllocType)alloc_type);\n-      }\n-    }\n-\n     CHECK_GE(m->alloc_tid, 0);\n     if (SANITIZER_WORDSIZE == 64)  // On 32-bits this resides in user area.\n       CHECK_EQ(m->free_tid, kInvalidTid);\n@@ -514,13 +546,24 @@ struct Allocator {\n \n     uptr chunk_beg = p - kChunkHeaderSize;\n     AsanChunk *m = reinterpret_cast<AsanChunk *>(chunk_beg);\n+\n+    ASAN_FREE_HOOK(ptr);\n+    // Must mark the chunk as quarantined before any changes to its metadata.\n+    // Do not quarantine given chunk if we failed to set CHUNK_QUARANTINE flag.\n+    if (!AtomicallySetQuarantineFlagIfAllocated(m, ptr, stack)) return;\n+\n+    if (m->alloc_type != alloc_type) {\n+      if (atomic_load(&alloc_dealloc_mismatch, memory_order_acquire)) {\n+        ReportAllocTypeMismatch((uptr)ptr, stack, (AllocType)m->alloc_type,\n+                                (AllocType)alloc_type);\n+      }\n+    }\n+\n     if (delete_size && flags()->new_delete_type_mismatch &&\n         delete_size != m->UsedSize()) {\n       ReportNewDeleteSizeMismatch(p, delete_size, stack);\n     }\n-    ASAN_FREE_HOOK(ptr);\n-    // Must mark the chunk as quarantined before any changes to its metadata.\n-    AtomicallySetQuarantineFlag(m, ptr, stack);\n+\n     QuarantineChunk(m, ptr, stack, alloc_type);\n   }\n \n@@ -551,7 +594,7 @@ struct Allocator {\n \n   void *Calloc(uptr nmemb, uptr size, BufferedStackTrace *stack) {\n     if (CallocShouldReturnNullDueToOverflow(size, nmemb))\n-      return allocator.ReturnNullOrDie();\n+      return allocator.ReturnNullOrDieOnBadRequest();\n     void *ptr = Allocate(nmemb * size, 8, stack, FROM_MALLOC, false);\n     // If the memory comes from the secondary allocator no need to clear it\n     // as it comes directly from mmap.\n@@ -642,6 +685,8 @@ struct Allocator {\n     fallback_mutex.Unlock();\n     allocator.ForceUnlock();\n   }\n+\n+  void ReleaseToOS() { allocator.ReleaseToOS(); }\n };\n \n static Allocator instance(LINKER_INITIALIZED);\n@@ -653,11 +698,17 @@ static AsanAllocator &get_allocator() {\n bool AsanChunkView::IsValid() {\n   return chunk_ && chunk_->chunk_state != CHUNK_AVAILABLE;\n }\n+bool AsanChunkView::IsAllocated() {\n+  return chunk_ && chunk_->chunk_state == CHUNK_ALLOCATED;\n+}\n uptr AsanChunkView::Beg() { return chunk_->Beg(); }\n uptr AsanChunkView::End() { return Beg() + UsedSize(); }\n uptr AsanChunkView::UsedSize() { return chunk_->UsedSize(); }\n uptr AsanChunkView::AllocTid() { return chunk_->alloc_tid; }\n uptr AsanChunkView::FreeTid() { return chunk_->free_tid; }\n+AllocType AsanChunkView::GetAllocType() {\n+  return (AllocType)chunk_->alloc_type;\n+}\n \n static StackTrace GetStackTraceFromId(u32 id) {\n   CHECK(id);\n@@ -666,16 +717,22 @@ static StackTrace GetStackTraceFromId(u32 id) {\n   return res;\n }\n \n+u32 AsanChunkView::GetAllocStackId() { return chunk_->alloc_context_id; }\n+u32 AsanChunkView::GetFreeStackId() { return chunk_->free_context_id; }\n+\n StackTrace AsanChunkView::GetAllocStack() {\n-  return GetStackTraceFromId(chunk_->alloc_context_id);\n+  return GetStackTraceFromId(GetAllocStackId());\n }\n \n StackTrace AsanChunkView::GetFreeStack() {\n-  return GetStackTraceFromId(chunk_->free_context_id);\n+  return GetStackTraceFromId(GetFreeStackId());\n }\n \n+void ReleaseToOS() { instance.ReleaseToOS(); }\n+\n void InitializeAllocator(const AllocatorOptions &options) {\n   instance.Initialize(options);\n+  SetAllocatorReleaseToOSCallback(ReleaseToOS);\n }\n \n void ReInitializeAllocator(const AllocatorOptions &options) {\n@@ -689,6 +746,9 @@ void GetAllocatorOptions(AllocatorOptions *options) {\n AsanChunkView FindHeapChunkByAddress(uptr addr) {\n   return instance.FindHeapChunkByAddress(addr);\n }\n+AsanChunkView FindHeapChunkByAllocBeg(uptr addr) {\n+  return AsanChunkView(instance.GetAsanChunk(reinterpret_cast<void*>(addr)));\n+}\n \n void AsanThreadLocalMallocStorage::CommitBack() {\n   instance.CommitBack(this);\n@@ -752,7 +812,7 @@ int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n   return 0;\n }\n \n-uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp) {\n+uptr asan_malloc_usable_size(const void *ptr, uptr pc, uptr bp) {\n   if (!ptr) return 0;\n   uptr usable_size = instance.AllocationSize(reinterpret_cast<uptr>(ptr));\n   if (flags()->check_malloc_usable_size && (usable_size == 0)) {"}, {"sha": "7eeddadd5472ee919485d207350bd7c82bc10e6c", "filename": "libsanitizer/asan/asan_allocator.h", "status": "modified", "additions": 33, "deletions": 10, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_allocator.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -47,16 +47,20 @@ void GetAllocatorOptions(AllocatorOptions *options);\n class AsanChunkView {\n  public:\n   explicit AsanChunkView(AsanChunk *chunk) : chunk_(chunk) {}\n-  bool IsValid();   // Checks if AsanChunkView points to a valid allocated\n-                    // or quarantined chunk.\n-  uptr Beg();       // First byte of user memory.\n-  uptr End();       // Last byte of user memory.\n-  uptr UsedSize();  // Size requested by the user.\n+  bool IsValid();        // Checks if AsanChunkView points to a valid allocated\n+                         // or quarantined chunk.\n+  bool IsAllocated();    // Checks if the memory is currently allocated.\n+  uptr Beg();            // First byte of user memory.\n+  uptr End();            // Last byte of user memory.\n+  uptr UsedSize();       // Size requested by the user.\n   uptr AllocTid();\n   uptr FreeTid();\n   bool Eq(const AsanChunkView &c) const { return chunk_ == c.chunk_; }\n+  u32 GetAllocStackId();\n+  u32 GetFreeStackId();\n   StackTrace GetAllocStack();\n   StackTrace GetFreeStack();\n+  AllocType GetAllocType();\n   bool AddrIsInside(uptr addr, uptr access_size, sptr *offset) {\n     if (addr >= Beg() && (addr + access_size) <= End()) {\n       *offset = addr - Beg();\n@@ -85,6 +89,7 @@ class AsanChunkView {\n };\n \n AsanChunkView FindHeapChunkByAddress(uptr address);\n+AsanChunkView FindHeapChunkByAllocBeg(uptr address);\n \n // List of AsanChunks with total size.\n class AsanChunkFifoList: public IntrusiveList<AsanChunk> {\n@@ -112,18 +117,36 @@ struct AsanMapUnmapCallback {\n # if defined(__powerpc64__)\n const uptr kAllocatorSpace =  0xa0000000000ULL;\n const uptr kAllocatorSize  =  0x20000000000ULL;  // 2T.\n+typedef DefaultSizeClassMap SizeClassMap;\n+# elif defined(__aarch64__) && SANITIZER_ANDROID\n+const uptr kAllocatorSpace =  0x3000000000ULL;\n+const uptr kAllocatorSize  =  0x2000000000ULL;  // 128G.\n+typedef VeryCompactSizeClassMap SizeClassMap;\n # elif defined(__aarch64__)\n-// AArch64/SANITIZIER_CAN_USER_ALLOCATOR64 is only for 42-bit VMA\n+// AArch64/SANITIZER_CAN_USER_ALLOCATOR64 is only for 42-bit VMA\n // so no need to different values for different VMA.\n const uptr kAllocatorSpace =  0x10000000000ULL;\n const uptr kAllocatorSize  =  0x10000000000ULL;  // 3T.\n+typedef DefaultSizeClassMap SizeClassMap;\n+# elif SANITIZER_WINDOWS\n+const uptr kAllocatorSpace = ~(uptr)0;\n+const uptr kAllocatorSize  =  0x8000000000ULL;  // 500G\n+typedef DefaultSizeClassMap SizeClassMap;\n # else\n const uptr kAllocatorSpace = 0x600000000000ULL;\n const uptr kAllocatorSize  =  0x40000000000ULL;  // 4T.\n-# endif\n typedef DefaultSizeClassMap SizeClassMap;\n-typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize, 0 /*metadata*/,\n-    SizeClassMap, AsanMapUnmapCallback> PrimaryAllocator;\n+# endif\n+struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n+  static const uptr kSpaceBeg = kAllocatorSpace;\n+  static const uptr kSpaceSize = kAllocatorSize;\n+  static const uptr kMetadataSize = 0;\n+  typedef __asan::SizeClassMap SizeClassMap;\n+  typedef AsanMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+\n+typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n #else  // Fallback to SizeClassAllocator32.\n static const uptr kRegionSizeLog = 20;\n static const uptr kNumRegions = SANITIZER_MMAP_RANGE_SIZE >> kRegionSizeLog;\n@@ -169,7 +192,7 @@ void *asan_pvalloc(uptr size, BufferedStackTrace *stack);\n \n int asan_posix_memalign(void **memptr, uptr alignment, uptr size,\n                         BufferedStackTrace *stack);\n-uptr asan_malloc_usable_size(void *ptr, uptr pc, uptr bp);\n+uptr asan_malloc_usable_size(const void *ptr, uptr pc, uptr bp);\n \n uptr asan_mz_size(const void *ptr);\n void asan_mz_force_lock();"}, {"sha": "1c8d0df8f6e2a81884dfcceaf983b49deed25bbe", "filename": "libsanitizer/asan/asan_debugging.cc", "status": "modified", "additions": 65, "deletions": 60, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_debugging.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -12,74 +12,39 @@\n //===----------------------------------------------------------------------===//\n \n #include \"asan_allocator.h\"\n+#include \"asan_descriptions.h\"\n #include \"asan_flags.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n #include \"asan_thread.h\"\n \n-namespace __asan {\n-\n-void GetInfoForStackVar(uptr addr, AddressDescription *descr, AsanThread *t) {\n-  descr->name[0] = 0;\n-  descr->region_address = 0;\n-  descr->region_size = 0;\n-  descr->region_kind = \"stack\";\n+namespace {\n+using namespace __asan;\n \n-  AsanThread::StackFrameAccess access;\n-  if (!t->GetStackFrameAccessByAddr(addr, &access))\n-    return;\n+static void FindInfoForStackVar(uptr addr, const char *frame_descr, uptr offset,\n+                                char *name, uptr name_size,\n+                                uptr &region_address, uptr &region_size) {\n   InternalMmapVector<StackVarDescr> vars(16);\n-  if (!ParseFrameDescription(access.frame_descr, &vars)) {\n+  if (!ParseFrameDescription(frame_descr, &vars)) {\n     return;\n   }\n \n   for (uptr i = 0; i < vars.size(); i++) {\n-    if (access.offset <= vars[i].beg + vars[i].size) {\n-      internal_strncat(descr->name, vars[i].name_pos,\n-                       Min(descr->name_size, vars[i].name_len));\n-      descr->region_address = addr - (access.offset - vars[i].beg);\n-      descr->region_size = vars[i].size;\n+    if (offset <= vars[i].beg + vars[i].size) {\n+      // We use name_len + 1 because strlcpy will guarantee a \\0 at the end, so\n+      // if we're limiting the copy due to name_len, we add 1 to ensure we copy\n+      // the whole name and then terminate with '\\0'.\n+      internal_strlcpy(name, vars[i].name_pos,\n+                       Min(name_size, vars[i].name_len + 1));\n+      region_address = addr - (offset - vars[i].beg);\n+      region_size = vars[i].size;\n       return;\n     }\n   }\n }\n \n-void GetInfoForHeapAddress(uptr addr, AddressDescription *descr) {\n-  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n-\n-  descr->name[0] = 0;\n-  descr->region_address = 0;\n-  descr->region_size = 0;\n-\n-  if (!chunk.IsValid()) {\n-    descr->region_kind = \"heap-invalid\";\n-    return;\n-  }\n-\n-  descr->region_address = chunk.Beg();\n-  descr->region_size = chunk.UsedSize();\n-  descr->region_kind = \"heap\";\n-}\n-\n-void AsanLocateAddress(uptr addr, AddressDescription *descr) {\n-  if (DescribeAddressIfShadow(addr, descr, /* print */ false)) {\n-    return;\n-  }\n-  if (GetInfoForAddressIfGlobal(addr, descr)) {\n-    return;\n-  }\n-  asanThreadRegistry().Lock();\n-  AsanThread *thread = FindThreadByStackAddress(addr);\n-  asanThreadRegistry().Unlock();\n-  if (thread) {\n-    GetInfoForStackVar(addr, descr, thread);\n-    return;\n-  }\n-  GetInfoForHeapAddress(addr, descr);\n-}\n-\n-static uptr AsanGetStack(uptr addr, uptr *trace, u32 size, u32 *thread_id,\n+uptr AsanGetStack(uptr addr, uptr *trace, u32 size, u32 *thread_id,\n                          bool alloc_stack) {\n   AsanChunkView chunk = FindHeapChunkByAddress(addr);\n   if (!chunk.IsValid()) return 0;\n@@ -106,18 +71,58 @@ static uptr AsanGetStack(uptr addr, uptr *trace, u32 size, u32 *thread_id,\n   return 0;\n }\n \n-} // namespace __asan\n-\n-using namespace __asan;\n+}  // namespace\n \n SANITIZER_INTERFACE_ATTRIBUTE\n const char *__asan_locate_address(uptr addr, char *name, uptr name_size,\n-                                  uptr *region_address, uptr *region_size) {\n-  AddressDescription descr = { name, name_size, 0, 0, nullptr };\n-  AsanLocateAddress(addr, &descr);\n-  if (region_address) *region_address = descr.region_address;\n-  if (region_size) *region_size = descr.region_size;\n-  return descr.region_kind;\n+                                  uptr *region_address_ptr,\n+                                  uptr *region_size_ptr) {\n+  AddressDescription descr(addr);\n+  uptr region_address = 0;\n+  uptr region_size = 0;\n+  const char *region_kind = nullptr;\n+  if (name && name_size > 0) name[0] = 0;\n+\n+  if (auto shadow = descr.AsShadow()) {\n+    // region_{address,size} are already 0\n+    switch (shadow->kind) {\n+      case kShadowKindLow:\n+        region_kind = \"low shadow\";\n+        break;\n+      case kShadowKindGap:\n+        region_kind = \"shadow gap\";\n+        break;\n+      case kShadowKindHigh:\n+        region_kind = \"high shadow\";\n+        break;\n+    }\n+  } else if (auto heap = descr.AsHeap()) {\n+    region_kind = \"heap\";\n+    region_address = heap->chunk_access.chunk_begin;\n+    region_size = heap->chunk_access.chunk_size;\n+  } else if (auto stack = descr.AsStack()) {\n+    region_kind = \"stack\";\n+    if (!stack->frame_descr) {\n+      // region_{address,size} are already 0\n+    } else {\n+      FindInfoForStackVar(addr, stack->frame_descr, stack->offset, name,\n+                          name_size, region_address, region_size);\n+    }\n+  } else if (auto global = descr.AsGlobal()) {\n+    region_kind = \"global\";\n+    auto &g = global->globals[0];\n+    internal_strlcpy(name, g.name, name_size);\n+    region_address = g.beg;\n+    region_size = g.size;\n+  } else {\n+    // region_{address,size} are already 0\n+    region_kind = \"heap-invalid\";\n+  }\n+\n+  CHECK(region_kind);\n+  if (region_address_ptr) *region_address_ptr = region_address;\n+  if (region_size_ptr) *region_size_ptr = region_size;\n+  return region_kind;\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE"}, {"sha": "35d1619f2d968b6e2165c113d0174352587de975", "filename": "libsanitizer/asan/asan_descriptions.cc", "status": "added", "additions": 484, "deletions": 0, "changes": 484, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_descriptions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_descriptions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,484 @@\n+//===-- asan_descriptions.cc ------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan functions for getting information about an address and/or printing it.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_descriptions.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+\n+namespace __asan {\n+\n+// Return \" (thread_name) \" or an empty string if the name is empty.\n+const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n+                                      uptr buff_len) {\n+  const char *name = t->name;\n+  if (name[0] == '\\0') return \"\";\n+  buff[0] = 0;\n+  internal_strncat(buff, \" (\", 3);\n+  internal_strncat(buff, name, buff_len - 4);\n+  internal_strncat(buff, \")\", 2);\n+  return buff;\n+}\n+\n+const char *ThreadNameWithParenthesis(u32 tid, char buff[], uptr buff_len) {\n+  if (tid == kInvalidTid) return \"\";\n+  asanThreadRegistry().CheckLocked();\n+  AsanThreadContext *t = GetThreadContextByTidLocked(tid);\n+  return ThreadNameWithParenthesis(t, buff, buff_len);\n+}\n+\n+void DescribeThread(AsanThreadContext *context) {\n+  CHECK(context);\n+  asanThreadRegistry().CheckLocked();\n+  // No need to announce the main thread.\n+  if (context->tid == 0 || context->announced) {\n+    return;\n+  }\n+  context->announced = true;\n+  char tname[128];\n+  InternalScopedString str(1024);\n+  str.append(\"Thread T%d%s\", context->tid,\n+             ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n+  if (context->parent_tid == kInvalidTid) {\n+    str.append(\" created by unknown thread\\n\");\n+    Printf(\"%s\", str.data());\n+    return;\n+  }\n+  str.append(\n+      \" created by T%d%s here:\\n\", context->parent_tid,\n+      ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n+  Printf(\"%s\", str.data());\n+  StackDepotGet(context->stack_id).Print();\n+  // Recursively described parent thread if needed.\n+  if (flags()->print_full_thread_history) {\n+    AsanThreadContext *parent_context =\n+        GetThreadContextByTidLocked(context->parent_tid);\n+    DescribeThread(parent_context);\n+  }\n+}\n+\n+// Shadow descriptions\n+static bool GetShadowKind(uptr addr, ShadowKind *shadow_kind) {\n+  CHECK(!AddrIsInMem(addr));\n+  if (AddrIsInShadowGap(addr)) {\n+    *shadow_kind = kShadowKindGap;\n+  } else if (AddrIsInHighShadow(addr)) {\n+    *shadow_kind = kShadowKindHigh;\n+  } else if (AddrIsInLowShadow(addr)) {\n+    *shadow_kind = kShadowKindLow;\n+  } else {\n+    CHECK(0 && \"Address is not in memory and not in shadow?\");\n+    return false;\n+  }\n+  return true;\n+}\n+\n+bool DescribeAddressIfShadow(uptr addr) {\n+  ShadowAddressDescription descr;\n+  if (!GetShadowAddressInformation(addr, &descr)) return false;\n+  descr.Print();\n+  return true;\n+}\n+\n+bool GetShadowAddressInformation(uptr addr, ShadowAddressDescription *descr) {\n+  if (AddrIsInMem(addr)) return false;\n+  ShadowKind shadow_kind;\n+  if (!GetShadowKind(addr, &shadow_kind)) return false;\n+  if (shadow_kind != kShadowKindGap) descr->shadow_byte = *(u8 *)addr;\n+  descr->addr = addr;\n+  descr->kind = shadow_kind;\n+  return true;\n+}\n+\n+// Heap descriptions\n+static void GetAccessToHeapChunkInformation(ChunkAccess *descr,\n+                                            AsanChunkView chunk, uptr addr,\n+                                            uptr access_size) {\n+  descr->bad_addr = addr;\n+  if (chunk.AddrIsAtLeft(addr, access_size, &descr->offset)) {\n+    descr->access_type = kAccessTypeLeft;\n+  } else if (chunk.AddrIsAtRight(addr, access_size, &descr->offset)) {\n+    descr->access_type = kAccessTypeRight;\n+    if (descr->offset < 0) {\n+      descr->bad_addr -= descr->offset;\n+      descr->offset = 0;\n+    }\n+  } else if (chunk.AddrIsInside(addr, access_size, &descr->offset)) {\n+    descr->access_type = kAccessTypeInside;\n+  } else {\n+    descr->access_type = kAccessTypeUnknown;\n+  }\n+  descr->chunk_begin = chunk.Beg();\n+  descr->chunk_size = chunk.UsedSize();\n+  descr->alloc_type = chunk.GetAllocType();\n+}\n+\n+static void PrintHeapChunkAccess(uptr addr, const ChunkAccess &descr) {\n+  Decorator d;\n+  InternalScopedString str(4096);\n+  str.append(\"%s\", d.Location());\n+  switch (descr.access_type) {\n+    case kAccessTypeLeft:\n+      str.append(\"%p is located %zd bytes to the left of\",\n+                 (void *)descr.bad_addr, descr.offset);\n+      break;\n+    case kAccessTypeRight:\n+      str.append(\"%p is located %zd bytes to the right of\",\n+                 (void *)descr.bad_addr, descr.offset);\n+      break;\n+    case kAccessTypeInside:\n+      str.append(\"%p is located %zd bytes inside of\", (void *)descr.bad_addr,\n+                 descr.offset);\n+      break;\n+    case kAccessTypeUnknown:\n+      str.append(\n+          \"%p is located somewhere around (this is AddressSanitizer bug!)\",\n+          (void *)descr.bad_addr);\n+  }\n+  str.append(\" %zu-byte region [%p,%p)\\n\", descr.chunk_size,\n+             (void *)descr.chunk_begin,\n+             (void *)(descr.chunk_begin + descr.chunk_size));\n+  str.append(\"%s\", d.EndLocation());\n+  Printf(\"%s\", str.data());\n+}\n+\n+bool GetHeapAddressInformation(uptr addr, uptr access_size,\n+                               HeapAddressDescription *descr) {\n+  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n+  if (!chunk.IsValid()) {\n+    return false;\n+  }\n+  descr->addr = addr;\n+  GetAccessToHeapChunkInformation(&descr->chunk_access, chunk, addr,\n+                                  access_size);\n+  CHECK_NE(chunk.AllocTid(), kInvalidTid);\n+  descr->alloc_tid = chunk.AllocTid();\n+  descr->alloc_stack_id = chunk.GetAllocStackId();\n+  descr->free_tid = chunk.FreeTid();\n+  if (descr->free_tid != kInvalidTid)\n+    descr->free_stack_id = chunk.GetFreeStackId();\n+  return true;\n+}\n+\n+static StackTrace GetStackTraceFromId(u32 id) {\n+  CHECK(id);\n+  StackTrace res = StackDepotGet(id);\n+  CHECK(res.trace);\n+  return res;\n+}\n+\n+bool DescribeAddressIfHeap(uptr addr, uptr access_size) {\n+  HeapAddressDescription descr;\n+  if (!GetHeapAddressInformation(addr, access_size, &descr)) {\n+    Printf(\n+        \"AddressSanitizer can not describe address in more detail \"\n+        \"(wild memory access suspected).\\n\");\n+    return false;\n+  }\n+  descr.Print();\n+  return true;\n+}\n+\n+// Stack descriptions\n+bool GetStackAddressInformation(uptr addr, uptr access_size,\n+                                StackAddressDescription *descr) {\n+  AsanThread *t = FindThreadByStackAddress(addr);\n+  if (!t) return false;\n+\n+  descr->addr = addr;\n+  descr->tid = t->tid();\n+  // Try to fetch precise stack frame for this access.\n+  AsanThread::StackFrameAccess access;\n+  if (!t->GetStackFrameAccessByAddr(addr, &access)) {\n+    descr->frame_descr = nullptr;\n+    return true;\n+  }\n+\n+  descr->offset = access.offset;\n+  descr->access_size = access_size;\n+  descr->frame_pc = access.frame_pc;\n+  descr->frame_descr = access.frame_descr;\n+\n+#if SANITIZER_PPC64V1\n+  // On PowerPC64 ELFv1, the address of a function actually points to a\n+  // three-doubleword data structure with the first field containing\n+  // the address of the function's code.\n+  descr->frame_pc = *reinterpret_cast<uptr *>(descr->frame_pc);\n+#endif\n+  descr->frame_pc += 16;\n+\n+  return true;\n+}\n+\n+static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n+                                          uptr access_size, uptr prev_var_end,\n+                                          uptr next_var_beg) {\n+  uptr var_end = var.beg + var.size;\n+  uptr addr_end = addr + access_size;\n+  const char *pos_descr = nullptr;\n+  // If the variable [var.beg, var_end) is the nearest variable to the\n+  // current memory access, indicate it in the log.\n+  if (addr >= var.beg) {\n+    if (addr_end <= var_end)\n+      pos_descr = \"is inside\";  // May happen if this is a use-after-return.\n+    else if (addr < var_end)\n+      pos_descr = \"partially overflows\";\n+    else if (addr_end <= next_var_beg &&\n+             next_var_beg - addr_end >= addr - var_end)\n+      pos_descr = \"overflows\";\n+  } else {\n+    if (addr_end > var.beg)\n+      pos_descr = \"partially underflows\";\n+    else if (addr >= prev_var_end && addr - prev_var_end >= var.beg - addr_end)\n+      pos_descr = \"underflows\";\n+  }\n+  InternalScopedString str(1024);\n+  str.append(\"    [%zd, %zd)\", var.beg, var_end);\n+  // Render variable name.\n+  str.append(\" '\");\n+  for (uptr i = 0; i < var.name_len; ++i) {\n+    str.append(\"%c\", var.name_pos[i]);\n+  }\n+  str.append(\"'\");\n+  if (pos_descr) {\n+    Decorator d;\n+    // FIXME: we may want to also print the size of the access here,\n+    // but in case of accesses generated by memset it may be confusing.\n+    str.append(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n+               d.Location(), addr, pos_descr, d.EndLocation());\n+  } else {\n+    str.append(\"\\n\");\n+  }\n+  Printf(\"%s\", str.data());\n+}\n+\n+bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n+  StackAddressDescription descr;\n+  if (!GetStackAddressInformation(addr, access_size, &descr)) return false;\n+  descr.Print();\n+  return true;\n+}\n+\n+// Global descriptions\n+static void DescribeAddressRelativeToGlobal(uptr addr, uptr access_size,\n+                                            const __asan_global &g) {\n+  InternalScopedString str(4096);\n+  Decorator d;\n+  str.append(\"%s\", d.Location());\n+  if (addr < g.beg) {\n+    str.append(\"%p is located %zd bytes to the left\", (void *)addr,\n+               g.beg - addr);\n+  } else if (addr + access_size > g.beg + g.size) {\n+    if (addr < g.beg + g.size) addr = g.beg + g.size;\n+    str.append(\"%p is located %zd bytes to the right\", (void *)addr,\n+               addr - (g.beg + g.size));\n+  } else {\n+    // Can it happen?\n+    str.append(\"%p is located %zd bytes inside\", (void *)addr, addr - g.beg);\n+  }\n+  str.append(\" of global variable '%s' defined in '\",\n+             MaybeDemangleGlobalName(g.name));\n+  PrintGlobalLocation(&str, g);\n+  str.append(\"' (0x%zx) of size %zu\\n\", g.beg, g.size);\n+  str.append(\"%s\", d.EndLocation());\n+  PrintGlobalNameIfASCII(&str, g);\n+  Printf(\"%s\", str.data());\n+}\n+\n+bool GetGlobalAddressInformation(uptr addr, uptr access_size,\n+                                 GlobalAddressDescription *descr) {\n+  descr->addr = addr;\n+  int globals_num = GetGlobalsForAddress(addr, descr->globals, descr->reg_sites,\n+                                         ARRAY_SIZE(descr->globals));\n+  descr->size = globals_num;\n+  descr->access_size = access_size;\n+  return globals_num != 0;\n+}\n+\n+bool DescribeAddressIfGlobal(uptr addr, uptr access_size,\n+                             const char *bug_type) {\n+  GlobalAddressDescription descr;\n+  if (!GetGlobalAddressInformation(addr, access_size, &descr)) return false;\n+\n+  descr.Print(bug_type);\n+  return true;\n+}\n+\n+void ShadowAddressDescription::Print() const {\n+  Printf(\"Address %p is located in the %s area.\\n\", addr, ShadowNames[kind]);\n+}\n+\n+void GlobalAddressDescription::Print(const char *bug_type) const {\n+  for (int i = 0; i < size; i++) {\n+    DescribeAddressRelativeToGlobal(addr, access_size, globals[i]);\n+    if (bug_type &&\n+        0 == internal_strcmp(bug_type, \"initialization-order-fiasco\") &&\n+        reg_sites[i]) {\n+      Printf(\"  registered at:\\n\");\n+      StackDepotGet(reg_sites[i]).Print();\n+    }\n+  }\n+}\n+\n+void StackAddressDescription::Print() const {\n+  Decorator d;\n+  char tname[128];\n+  Printf(\"%s\", d.Location());\n+  Printf(\"Address %p is located in stack of thread T%d%s\", addr, tid,\n+         ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+\n+  if (!frame_descr) {\n+    Printf(\"%s\\n\", d.EndLocation());\n+    return;\n+  }\n+  Printf(\" at offset %zu in frame%s\\n\", offset, d.EndLocation());\n+\n+  // Now we print the frame where the alloca has happened.\n+  // We print this frame as a stack trace with one element.\n+  // The symbolizer may print more than one frame if inlining was involved.\n+  // The frame numbers may be different than those in the stack trace printed\n+  // previously. That's unfortunate, but I have no better solution,\n+  // especially given that the alloca may be from entirely different place\n+  // (e.g. use-after-scope, or different thread's stack).\n+  Printf(\"%s\", d.EndLocation());\n+  StackTrace alloca_stack(&frame_pc, 1);\n+  alloca_stack.Print();\n+\n+  InternalMmapVector<StackVarDescr> vars(16);\n+  if (!ParseFrameDescription(frame_descr, &vars)) {\n+    Printf(\n+        \"AddressSanitizer can't parse the stack frame \"\n+        \"descriptor: |%s|\\n\",\n+        frame_descr);\n+    // 'addr' is a stack address, so return true even if we can't parse frame\n+    return;\n+  }\n+  uptr n_objects = vars.size();\n+  // Report the number of stack objects.\n+  Printf(\"  This frame has %zu object(s):\\n\", n_objects);\n+\n+  // Report all objects in this frame.\n+  for (uptr i = 0; i < n_objects; i++) {\n+    uptr prev_var_end = i ? vars[i - 1].beg + vars[i - 1].size : 0;\n+    uptr next_var_beg = i + 1 < n_objects ? vars[i + 1].beg : ~(0UL);\n+    PrintAccessAndVarIntersection(vars[i], offset, access_size, prev_var_end,\n+                                  next_var_beg);\n+  }\n+  Printf(\n+      \"HINT: this may be a false positive if your program uses \"\n+      \"some custom stack unwind mechanism or swapcontext\\n\");\n+  if (SANITIZER_WINDOWS)\n+    Printf(\"      (longjmp, SEH and C++ exceptions *are* supported)\\n\");\n+  else\n+    Printf(\"      (longjmp and C++ exceptions *are* supported)\\n\");\n+\n+  DescribeThread(GetThreadContextByTidLocked(tid));\n+}\n+\n+void HeapAddressDescription::Print() const {\n+  PrintHeapChunkAccess(addr, chunk_access);\n+\n+  asanThreadRegistry().CheckLocked();\n+  AsanThreadContext *alloc_thread = GetThreadContextByTidLocked(alloc_tid);\n+  StackTrace alloc_stack = GetStackTraceFromId(alloc_stack_id);\n+\n+  char tname[128];\n+  Decorator d;\n+  AsanThreadContext *free_thread = nullptr;\n+  if (free_tid != kInvalidTid) {\n+    free_thread = GetThreadContextByTidLocked(free_tid);\n+    Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n+           free_thread->tid,\n+           ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n+           d.EndAllocation());\n+    StackTrace free_stack = GetStackTraceFromId(free_stack_id);\n+    free_stack.Print();\n+    Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\", d.Allocation(),\n+           alloc_thread->tid,\n+           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n+           d.EndAllocation());\n+  } else {\n+    Printf(\"%sallocated by thread T%d%s here:%s\\n\", d.Allocation(),\n+           alloc_thread->tid,\n+           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n+           d.EndAllocation());\n+  }\n+  alloc_stack.Print();\n+  DescribeThread(GetCurrentThread());\n+  if (free_thread) DescribeThread(free_thread);\n+  DescribeThread(alloc_thread);\n+}\n+\n+AddressDescription::AddressDescription(uptr addr, uptr access_size,\n+                                       bool shouldLockThreadRegistry) {\n+  if (GetShadowAddressInformation(addr, &data.shadow)) {\n+    data.kind = kAddressKindShadow;\n+    return;\n+  }\n+  if (GetHeapAddressInformation(addr, access_size, &data.heap)) {\n+    data.kind = kAddressKindHeap;\n+    return;\n+  }\n+\n+  bool isStackMemory = false;\n+  if (shouldLockThreadRegistry) {\n+    ThreadRegistryLock l(&asanThreadRegistry());\n+    isStackMemory = GetStackAddressInformation(addr, access_size, &data.stack);\n+  } else {\n+    isStackMemory = GetStackAddressInformation(addr, access_size, &data.stack);\n+  }\n+  if (isStackMemory) {\n+    data.kind = kAddressKindStack;\n+    return;\n+  }\n+\n+  if (GetGlobalAddressInformation(addr, access_size, &data.global)) {\n+    data.kind = kAddressKindGlobal;\n+    return;\n+  }\n+  data.kind = kAddressKindWild;\n+  addr = 0;\n+}\n+\n+void PrintAddressDescription(uptr addr, uptr access_size,\n+                             const char *bug_type) {\n+  ShadowAddressDescription shadow_descr;\n+  if (GetShadowAddressInformation(addr, &shadow_descr)) {\n+    shadow_descr.Print();\n+    return;\n+  }\n+\n+  GlobalAddressDescription global_descr;\n+  if (GetGlobalAddressInformation(addr, access_size, &global_descr)) {\n+    global_descr.Print(bug_type);\n+    return;\n+  }\n+\n+  StackAddressDescription stack_descr;\n+  if (GetStackAddressInformation(addr, access_size, &stack_descr)) {\n+    stack_descr.Print();\n+    return;\n+  }\n+\n+  HeapAddressDescription heap_descr;\n+  if (GetHeapAddressInformation(addr, access_size, &heap_descr)) {\n+    heap_descr.Print();\n+    return;\n+  }\n+\n+  // We exhausted our possibilities. Bail out.\n+  Printf(\n+      \"AddressSanitizer can not describe address in more detail \"\n+      \"(wild memory access suspected).\\n\");\n+}\n+}  // namespace __asan"}, {"sha": "584b9ba6491dd93b2009201f21dd8aba173babf2", "filename": "libsanitizer/asan/asan_descriptions.h", "status": "added", "additions": 251, "deletions": 0, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_descriptions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_descriptions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_descriptions.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,251 @@\n+//===-- asan_descriptions.h -------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for asan_descriptions.cc.\n+// TODO(filcab): Most struct definitions should move to the interface headers.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_DESCRIPTIONS_H\n+#define ASAN_DESCRIPTIONS_H\n+\n+#include \"asan_allocator.h\"\n+#include \"asan_thread.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_report_decorator.h\"\n+\n+namespace __asan {\n+\n+void DescribeThread(AsanThreadContext *context);\n+static inline void DescribeThread(AsanThread *t) {\n+  if (t) DescribeThread(t->context());\n+}\n+const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n+                                      uptr buff_len);\n+const char *ThreadNameWithParenthesis(u32 tid, char buff[], uptr buff_len);\n+\n+class Decorator : public __sanitizer::SanitizerCommonDecorator {\n+ public:\n+  Decorator() : SanitizerCommonDecorator() {}\n+  const char *Access() { return Blue(); }\n+  const char *EndAccess() { return Default(); }\n+  const char *Location() { return Green(); }\n+  const char *EndLocation() { return Default(); }\n+  const char *Allocation() { return Magenta(); }\n+  const char *EndAllocation() { return Default(); }\n+\n+  const char *ShadowByte(u8 byte) {\n+    switch (byte) {\n+      case kAsanHeapLeftRedzoneMagic:\n+      case kAsanArrayCookieMagic:\n+        return Red();\n+      case kAsanHeapFreeMagic:\n+        return Magenta();\n+      case kAsanStackLeftRedzoneMagic:\n+      case kAsanStackMidRedzoneMagic:\n+      case kAsanStackRightRedzoneMagic:\n+        return Red();\n+      case kAsanStackAfterReturnMagic:\n+        return Magenta();\n+      case kAsanInitializationOrderMagic:\n+        return Cyan();\n+      case kAsanUserPoisonedMemoryMagic:\n+      case kAsanContiguousContainerOOBMagic:\n+      case kAsanAllocaLeftMagic:\n+      case kAsanAllocaRightMagic:\n+        return Blue();\n+      case kAsanStackUseAfterScopeMagic:\n+        return Magenta();\n+      case kAsanGlobalRedzoneMagic:\n+        return Red();\n+      case kAsanInternalHeapMagic:\n+        return Yellow();\n+      case kAsanIntraObjectRedzone:\n+        return Yellow();\n+      default:\n+        return Default();\n+    }\n+  }\n+  const char *EndShadowByte() { return Default(); }\n+  const char *MemoryByte() { return Magenta(); }\n+  const char *EndMemoryByte() { return Default(); }\n+};\n+\n+enum ShadowKind : u8 {\n+  kShadowKindLow,\n+  kShadowKindGap,\n+  kShadowKindHigh,\n+};\n+static const char *const ShadowNames[] = {\"low shadow\", \"shadow gap\",\n+                                          \"high shadow\"};\n+\n+struct ShadowAddressDescription {\n+  uptr addr;\n+  ShadowKind kind;\n+  u8 shadow_byte;\n+\n+  void Print() const;\n+};\n+\n+bool GetShadowAddressInformation(uptr addr, ShadowAddressDescription *descr);\n+bool DescribeAddressIfShadow(uptr addr);\n+\n+enum AccessType {\n+  kAccessTypeLeft,\n+  kAccessTypeRight,\n+  kAccessTypeInside,\n+  kAccessTypeUnknown,  // This means we have an AddressSanitizer bug!\n+};\n+\n+struct ChunkAccess {\n+  uptr bad_addr;\n+  sptr offset;\n+  uptr chunk_begin;\n+  uptr chunk_size;\n+  u32 access_type : 2;\n+  u32 alloc_type : 2;\n+};\n+\n+struct HeapAddressDescription {\n+  uptr addr;\n+  uptr alloc_tid;\n+  uptr free_tid;\n+  u32 alloc_stack_id;\n+  u32 free_stack_id;\n+  ChunkAccess chunk_access;\n+\n+  void Print() const;\n+};\n+\n+bool GetHeapAddressInformation(uptr addr, uptr access_size,\n+                               HeapAddressDescription *descr);\n+bool DescribeAddressIfHeap(uptr addr, uptr access_size = 1);\n+\n+struct StackAddressDescription {\n+  uptr addr;\n+  uptr tid;\n+  uptr offset;\n+  uptr frame_pc;\n+  uptr access_size;\n+  const char *frame_descr;\n+\n+  void Print() const;\n+};\n+\n+bool GetStackAddressInformation(uptr addr, uptr access_size,\n+                                StackAddressDescription *descr);\n+\n+struct GlobalAddressDescription {\n+  uptr addr;\n+  // Assume address is close to at most four globals.\n+  static const int kMaxGlobals = 4;\n+  __asan_global globals[kMaxGlobals];\n+  u32 reg_sites[kMaxGlobals];\n+  uptr access_size;\n+  u8 size;\n+\n+  void Print(const char *bug_type = \"\") const;\n+};\n+\n+bool GetGlobalAddressInformation(uptr addr, uptr access_size,\n+                                 GlobalAddressDescription *descr);\n+bool DescribeAddressIfGlobal(uptr addr, uptr access_size, const char *bug_type);\n+\n+// General function to describe an address. Will try to describe the address as\n+// a shadow, global (variable), stack, or heap address.\n+// bug_type is optional and is used for checking if we're reporting an\n+// initialization-order-fiasco\n+// The proper access_size should be passed for stack, global, and heap\n+// addresses. Defaults to 1.\n+// Each of the *AddressDescription functions has its own Print() member, which\n+// may take access_size and bug_type parameters if needed.\n+void PrintAddressDescription(uptr addr, uptr access_size = 1,\n+                             const char *bug_type = \"\");\n+\n+enum AddressKind {\n+  kAddressKindWild,\n+  kAddressKindShadow,\n+  kAddressKindHeap,\n+  kAddressKindStack,\n+  kAddressKindGlobal,\n+};\n+\n+class AddressDescription {\n+  struct AddressDescriptionData {\n+    AddressKind kind;\n+    union {\n+      ShadowAddressDescription shadow;\n+      HeapAddressDescription heap;\n+      StackAddressDescription stack;\n+      GlobalAddressDescription global;\n+      uptr addr;\n+    };\n+  };\n+\n+  AddressDescriptionData data;\n+\n+ public:\n+  AddressDescription() = default;\n+  // shouldLockThreadRegistry allows us to skip locking if we're sure we already\n+  // have done it.\n+  AddressDescription(uptr addr, bool shouldLockThreadRegistry = true)\n+      : AddressDescription(addr, 1, shouldLockThreadRegistry) {}\n+  AddressDescription(uptr addr, uptr access_size,\n+                     bool shouldLockThreadRegistry = true);\n+\n+  uptr Address() const {\n+    switch (data.kind) {\n+      case kAddressKindWild:\n+        return data.addr;\n+      case kAddressKindShadow:\n+        return data.shadow.addr;\n+      case kAddressKindHeap:\n+        return data.heap.addr;\n+      case kAddressKindStack:\n+        return data.stack.addr;\n+      case kAddressKindGlobal:\n+        return data.global.addr;\n+    }\n+    UNREACHABLE(\"AddressInformation kind is invalid\");\n+  }\n+  void Print(const char *bug_descr = nullptr) const {\n+    switch (data.kind) {\n+      case kAddressKindWild:\n+        Printf(\"Address %p is a wild pointer.\\n\", data.addr);\n+        return;\n+      case kAddressKindShadow:\n+        return data.shadow.Print();\n+      case kAddressKindHeap:\n+        return data.heap.Print();\n+      case kAddressKindStack:\n+        return data.stack.Print();\n+      case kAddressKindGlobal:\n+        // initialization-order-fiasco has a special Print()\n+        return data.global.Print(bug_descr);\n+    }\n+    UNREACHABLE(\"AddressInformation kind is invalid\");\n+  }\n+\n+  void StoreTo(AddressDescriptionData *dst) const { *dst = data; }\n+\n+  const ShadowAddressDescription *AsShadow() const {\n+    return data.kind == kAddressKindShadow ? &data.shadow : nullptr;\n+  }\n+  const HeapAddressDescription *AsHeap() const {\n+    return data.kind == kAddressKindHeap ? &data.heap : nullptr;\n+  }\n+  const StackAddressDescription *AsStack() const {\n+    return data.kind == kAddressKindStack ? &data.stack : nullptr;\n+  }\n+  const GlobalAddressDescription *AsGlobal() const {\n+    return data.kind == kAddressKindGlobal ? &data.global : nullptr;\n+  }\n+};\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_DESCRIPTIONS_H"}, {"sha": "73c4cca843be02c4215a5ada2d2633161d827e6d", "filename": "libsanitizer/asan/asan_errors.cc", "status": "added", "additions": 494, "deletions": 0, "changes": 494, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_errors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_errors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,494 @@\n+//===-- asan_errors.cc ------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan implementation for error structures.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"asan_errors.h\"\n+#include <signal.h>\n+#include \"asan_descriptions.h\"\n+#include \"asan_mapping.h\"\n+#include \"asan_report.h\"\n+#include \"asan_stack.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+\n+namespace __asan {\n+\n+void ErrorStackOverflow::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\n+      \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n+      \" (pc %p bp %p sp %p T%d)\\n\",\n+      (void *)addr, (void *)pc, (void *)bp, (void *)sp, tid);\n+  Printf(\"%s\", d.EndWarning());\n+  scariness.Print();\n+  BufferedStackTrace stack;\n+  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,\n+                                  common_flags()->fast_unwind_on_fatal);\n+  stack.Print();\n+  ReportErrorSummary(\"stack-overflow\", &stack);\n+}\n+\n+static void MaybeDumpInstructionBytes(uptr pc) {\n+  if (!flags()->dump_instruction_bytes || (pc < GetPageSizeCached())) return;\n+  InternalScopedString str(1024);\n+  str.append(\"First 16 instruction bytes at pc: \");\n+  if (IsAccessibleMemoryRange(pc, 16)) {\n+    for (int i = 0; i < 16; ++i) {\n+      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i], /*in_shadow*/ false, \" \");\n+    }\n+    str.append(\"\\n\");\n+  } else {\n+    str.append(\"unaccessible\\n\");\n+  }\n+  Report(\"%s\", str.data());\n+}\n+\n+void ErrorDeadlySignal::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  const char *description = DescribeSignalOrException(signo);\n+  Report(\n+      \"ERROR: AddressSanitizer: %s on unknown address %p (pc %p bp %p sp %p \"\n+      \"T%d)\\n\",\n+      description, (void *)addr, (void *)pc, (void *)bp, (void *)sp, tid);\n+  Printf(\"%s\", d.EndWarning());\n+  if (pc < GetPageSizeCached()) Report(\"Hint: pc points to the zero page.\\n\");\n+  if (is_memory_access) {\n+    const char *access_type =\n+        write_flag == SignalContext::WRITE\n+            ? \"WRITE\"\n+            : (write_flag == SignalContext::READ ? \"READ\" : \"UNKNOWN\");\n+    Report(\"The signal is caused by a %s memory access.\\n\", access_type);\n+    if (addr < GetPageSizeCached())\n+      Report(\"Hint: address points to the zero page.\\n\");\n+  }\n+  scariness.Print();\n+  BufferedStackTrace stack;\n+  GetStackTraceWithPcBpAndContext(&stack, kStackTraceMax, pc, bp, context,\n+                                  common_flags()->fast_unwind_on_fatal);\n+  stack.Print();\n+  MaybeDumpInstructionBytes(pc);\n+  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n+  ReportErrorSummary(description, &stack);\n+}\n+\n+void ErrorDoubleFree::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  char tname[128];\n+  Report(\n+      \"ERROR: AddressSanitizer: attempting double-free on %p in \"\n+      \"thread T%d%s:\\n\",\n+      addr_description.addr, tid,\n+      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+  Printf(\"%s\", d.EndWarning());\n+  scariness.Print();\n+  GET_STACK_TRACE_FATAL(second_free_stack->trace[0],\n+                        second_free_stack->top_frame_bp);\n+  stack.Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"double-free\", &stack);\n+}\n+\n+void ErrorNewDeleteSizeMismatch::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  char tname[128];\n+  Report(\n+      \"ERROR: AddressSanitizer: new-delete-type-mismatch on %p in thread \"\n+      \"T%d%s:\\n\",\n+      addr_description.addr, tid,\n+      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+  Printf(\"%s  object passed to delete has wrong type:\\n\", d.EndWarning());\n+  Printf(\n+      \"  size of the allocated type:   %zd bytes;\\n\"\n+      \"  size of the deallocated type: %zd bytes.\\n\",\n+      addr_description.chunk_access.chunk_size, delete_size);\n+  CHECK_GT(free_stack->size, 0);\n+  scariness.Print();\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  stack.Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"new-delete-type-mismatch\", &stack);\n+  Report(\n+      \"HINT: if you don't care about these errors you may set \"\n+      \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n+}\n+\n+void ErrorFreeNotMalloced::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  char tname[128];\n+  Report(\n+      \"ERROR: AddressSanitizer: attempting free on address \"\n+      \"which was not malloc()-ed: %p in thread T%d%s\\n\",\n+      addr_description.Address(), tid,\n+      ThreadNameWithParenthesis(tid, tname, sizeof(tname)));\n+  Printf(\"%s\", d.EndWarning());\n+  CHECK_GT(free_stack->size, 0);\n+  scariness.Print();\n+  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n+  stack.Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"bad-free\", &stack);\n+}\n+\n+void ErrorAllocTypeMismatch::Print() {\n+  static const char *alloc_names[] = {\"INVALID\", \"malloc\", \"operator new\",\n+                                      \"operator new []\"};\n+  static const char *dealloc_names[] = {\"INVALID\", \"free\", \"operator delete\",\n+                                        \"operator delete []\"};\n+  CHECK_NE(alloc_type, dealloc_type);\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: alloc-dealloc-mismatch (%s vs %s) on %p\\n\",\n+         alloc_names[alloc_type], dealloc_names[dealloc_type],\n+         addr_description.addr);\n+  Printf(\"%s\", d.EndWarning());\n+  CHECK_GT(dealloc_stack->size, 0);\n+  scariness.Print();\n+  GET_STACK_TRACE_FATAL(dealloc_stack->trace[0], dealloc_stack->top_frame_bp);\n+  stack.Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n+  Report(\n+      \"HINT: if you don't care about these errors you may set \"\n+      \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n+}\n+\n+void ErrorMallocUsableSizeNotOwned::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\n+      \"ERROR: AddressSanitizer: attempting to call malloc_usable_size() for \"\n+      \"pointer which is not owned: %p\\n\",\n+      addr_description.Address());\n+  Printf(\"%s\", d.EndWarning());\n+  stack->Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n+}\n+\n+void ErrorSanitizerGetAllocatedSizeNotOwned::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\n+      \"ERROR: AddressSanitizer: attempting to call \"\n+      \"__sanitizer_get_allocated_size() for pointer which is not owned: %p\\n\",\n+      addr_description.Address());\n+  Printf(\"%s\", d.EndWarning());\n+  stack->Print();\n+  addr_description.Print();\n+  ReportErrorSummary(\"bad-__sanitizer_get_allocated_size\", stack);\n+}\n+\n+void ErrorStringFunctionMemoryRangesOverlap::Print() {\n+  Decorator d;\n+  char bug_type[100];\n+  internal_snprintf(bug_type, sizeof(bug_type), \"%s-param-overlap\", function);\n+  Printf(\"%s\", d.Warning());\n+  Report(\n+      \"ERROR: AddressSanitizer: %s: memory ranges [%p,%p) and [%p, %p) \"\n+      \"overlap\\n\",\n+      bug_type, addr1_description.Address(),\n+      addr1_description.Address() + length1, addr2_description.Address(),\n+      addr2_description.Address() + length2);\n+  Printf(\"%s\", d.EndWarning());\n+  scariness.Print();\n+  stack->Print();\n+  addr1_description.Print();\n+  addr2_description.Print();\n+  ReportErrorSummary(bug_type, stack);\n+}\n+\n+void ErrorStringFunctionSizeOverflow::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  const char *bug_type = \"negative-size-param\";\n+  Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\", bug_type, size);\n+  Printf(\"%s\", d.EndWarning());\n+  scariness.Print();\n+  stack->Print();\n+  addr_description.Print();\n+  ReportErrorSummary(bug_type, stack);\n+}\n+\n+void ErrorBadParamsToAnnotateContiguousContainer::Print() {\n+  Report(\n+      \"ERROR: AddressSanitizer: bad parameters to \"\n+      \"__sanitizer_annotate_contiguous_container:\\n\"\n+      \"      beg     : %p\\n\"\n+      \"      end     : %p\\n\"\n+      \"      old_mid : %p\\n\"\n+      \"      new_mid : %p\\n\",\n+      beg, end, old_mid, new_mid);\n+  uptr granularity = SHADOW_GRANULARITY;\n+  if (!IsAligned(beg, granularity))\n+    Report(\"ERROR: beg is not aligned by %d\\n\", granularity);\n+  stack->Print();\n+  ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n+}\n+\n+void ErrorODRViolation::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: odr-violation (%p):\\n\", global1.beg);\n+  Printf(\"%s\", d.EndWarning());\n+  InternalScopedString g1_loc(256), g2_loc(256);\n+  PrintGlobalLocation(&g1_loc, global1);\n+  PrintGlobalLocation(&g2_loc, global2);\n+  Printf(\"  [1] size=%zd '%s' %s\\n\", global1.size,\n+         MaybeDemangleGlobalName(global1.name), g1_loc.data());\n+  Printf(\"  [2] size=%zd '%s' %s\\n\", global2.size,\n+         MaybeDemangleGlobalName(global2.name), g2_loc.data());\n+  if (stack_id1 && stack_id2) {\n+    Printf(\"These globals were registered at these points:\\n\");\n+    Printf(\"  [1]:\\n\");\n+    StackDepotGet(stack_id1).Print();\n+    Printf(\"  [2]:\\n\");\n+    StackDepotGet(stack_id2).Print();\n+  }\n+  Report(\n+      \"HINT: if you don't care about these errors you may set \"\n+      \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n+  InternalScopedString error_msg(256);\n+  error_msg.append(\"odr-violation: global '%s' at %s\",\n+                   MaybeDemangleGlobalName(global1.name), g1_loc.data());\n+  ReportErrorSummary(error_msg.data());\n+}\n+\n+void ErrorInvalidPointerPair::Print() {\n+  const char *bug_type = \"invalid-pointer-pair\";\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  Report(\"ERROR: AddressSanitizer: invalid-pointer-pair: %p %p\\n\",\n+         addr1_description.Address(), addr2_description.Address());\n+  Printf(\"%s\", d.EndWarning());\n+  GET_STACK_TRACE_FATAL(pc, bp);\n+  stack.Print();\n+  addr1_description.Print();\n+  addr2_description.Print();\n+  ReportErrorSummary(bug_type, &stack);\n+}\n+\n+static bool AdjacentShadowValuesAreFullyPoisoned(u8 *s) {\n+  return s[-1] > 127 && s[1] > 127;\n+}\n+\n+ErrorGeneric::ErrorGeneric(u32 tid, uptr pc_, uptr bp_, uptr sp_, uptr addr,\n+                           bool is_write_, uptr access_size_)\n+    : ErrorBase(tid),\n+      addr_description(addr, access_size_, /*shouldLockThreadRegistry=*/false),\n+      pc(pc_),\n+      bp(bp_),\n+      sp(sp_),\n+      access_size(access_size_),\n+      is_write(is_write_),\n+      shadow_val(0) {\n+  scariness.Clear();\n+  if (access_size) {\n+    if (access_size <= 9) {\n+      char desr[] = \"?-byte\";\n+      desr[0] = '0' + access_size;\n+      scariness.Scare(access_size + access_size / 2, desr);\n+    } else if (access_size >= 10) {\n+      scariness.Scare(15, \"multi-byte\");\n+    }\n+    is_write ? scariness.Scare(20, \"write\") : scariness.Scare(1, \"read\");\n+\n+    // Determine the error type.\n+    bug_descr = \"unknown-crash\";\n+    if (AddrIsInMem(addr)) {\n+      u8 *shadow_addr = (u8 *)MemToShadow(addr);\n+      // If we are accessing 16 bytes, look at the second shadow byte.\n+      if (*shadow_addr == 0 && access_size > SHADOW_GRANULARITY) shadow_addr++;\n+      // If we are in the partial right redzone, look at the next shadow byte.\n+      if (*shadow_addr > 0 && *shadow_addr < 128) shadow_addr++;\n+      bool far_from_bounds = false;\n+      shadow_val = *shadow_addr;\n+      int bug_type_score = 0;\n+      // For use-after-frees reads are almost as bad as writes.\n+      int read_after_free_bonus = 0;\n+      switch (shadow_val) {\n+        case kAsanHeapLeftRedzoneMagic:\n+        case kAsanArrayCookieMagic:\n+          bug_descr = \"heap-buffer-overflow\";\n+          bug_type_score = 10;\n+          far_from_bounds = AdjacentShadowValuesAreFullyPoisoned(shadow_addr);\n+          break;\n+        case kAsanHeapFreeMagic:\n+          bug_descr = \"heap-use-after-free\";\n+          bug_type_score = 20;\n+          if (!is_write) read_after_free_bonus = 18;\n+          break;\n+        case kAsanStackLeftRedzoneMagic:\n+          bug_descr = \"stack-buffer-underflow\";\n+          bug_type_score = 25;\n+          far_from_bounds = AdjacentShadowValuesAreFullyPoisoned(shadow_addr);\n+          break;\n+        case kAsanInitializationOrderMagic:\n+          bug_descr = \"initialization-order-fiasco\";\n+          bug_type_score = 1;\n+          break;\n+        case kAsanStackMidRedzoneMagic:\n+        case kAsanStackRightRedzoneMagic:\n+          bug_descr = \"stack-buffer-overflow\";\n+          bug_type_score = 25;\n+          far_from_bounds = AdjacentShadowValuesAreFullyPoisoned(shadow_addr);\n+          break;\n+        case kAsanStackAfterReturnMagic:\n+          bug_descr = \"stack-use-after-return\";\n+          bug_type_score = 30;\n+          if (!is_write) read_after_free_bonus = 18;\n+          break;\n+        case kAsanUserPoisonedMemoryMagic:\n+          bug_descr = \"use-after-poison\";\n+          bug_type_score = 20;\n+          break;\n+        case kAsanContiguousContainerOOBMagic:\n+          bug_descr = \"container-overflow\";\n+          bug_type_score = 10;\n+          break;\n+        case kAsanStackUseAfterScopeMagic:\n+          bug_descr = \"stack-use-after-scope\";\n+          bug_type_score = 10;\n+          break;\n+        case kAsanGlobalRedzoneMagic:\n+          bug_descr = \"global-buffer-overflow\";\n+          bug_type_score = 10;\n+          far_from_bounds = AdjacentShadowValuesAreFullyPoisoned(shadow_addr);\n+          break;\n+        case kAsanIntraObjectRedzone:\n+          bug_descr = \"intra-object-overflow\";\n+          bug_type_score = 10;\n+          break;\n+        case kAsanAllocaLeftMagic:\n+        case kAsanAllocaRightMagic:\n+          bug_descr = \"dynamic-stack-buffer-overflow\";\n+          bug_type_score = 25;\n+          far_from_bounds = AdjacentShadowValuesAreFullyPoisoned(shadow_addr);\n+          break;\n+      }\n+      scariness.Scare(bug_type_score + read_after_free_bonus, bug_descr);\n+      if (far_from_bounds) scariness.Scare(10, \"far-from-bounds\");\n+    }\n+  }\n+}\n+\n+static void PrintContainerOverflowHint() {\n+  Printf(\"HINT: if you don't care about these errors you may set \"\n+         \"ASAN_OPTIONS=detect_container_overflow=0.\\n\"\n+         \"If you suspect a false positive see also: \"\n+         \"https://github.com/google/sanitizers/wiki/\"\n+         \"AddressSanitizerContainerOverflow.\\n\");\n+}\n+\n+static void PrintShadowByte(InternalScopedString *str, const char *before,\n+    u8 byte, const char *after = \"\\n\") {\n+  PrintMemoryByte(str, before, byte, /*in_shadow*/true, after);\n+}\n+\n+static void PrintLegend(InternalScopedString *str) {\n+  str->append(\n+      \"Shadow byte legend (one shadow byte represents %d \"\n+      \"application bytes):\\n\",\n+      (int)SHADOW_GRANULARITY);\n+  PrintShadowByte(str, \"  Addressable:           \", 0);\n+  str->append(\"  Partially addressable: \");\n+  for (u8 i = 1; i < SHADOW_GRANULARITY; i++) PrintShadowByte(str, \"\", i, \" \");\n+  str->append(\"\\n\");\n+  PrintShadowByte(str, \"  Heap left redzone:       \",\n+                  kAsanHeapLeftRedzoneMagic);\n+  PrintShadowByte(str, \"  Freed heap region:       \", kAsanHeapFreeMagic);\n+  PrintShadowByte(str, \"  Stack left redzone:      \",\n+                  kAsanStackLeftRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack mid redzone:       \",\n+                  kAsanStackMidRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack right redzone:     \",\n+                  kAsanStackRightRedzoneMagic);\n+  PrintShadowByte(str, \"  Stack after return:      \",\n+                  kAsanStackAfterReturnMagic);\n+  PrintShadowByte(str, \"  Stack use after scope:   \",\n+                  kAsanStackUseAfterScopeMagic);\n+  PrintShadowByte(str, \"  Global redzone:          \", kAsanGlobalRedzoneMagic);\n+  PrintShadowByte(str, \"  Global init order:       \",\n+                  kAsanInitializationOrderMagic);\n+  PrintShadowByte(str, \"  Poisoned by user:        \",\n+                  kAsanUserPoisonedMemoryMagic);\n+  PrintShadowByte(str, \"  Container overflow:      \",\n+                  kAsanContiguousContainerOOBMagic);\n+  PrintShadowByte(str, \"  Array cookie:            \",\n+                  kAsanArrayCookieMagic);\n+  PrintShadowByte(str, \"  Intra object redzone:    \",\n+                  kAsanIntraObjectRedzone);\n+  PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n+  PrintShadowByte(str, \"  Left alloca redzone:     \", kAsanAllocaLeftMagic);\n+  PrintShadowByte(str, \"  Right alloca redzone:    \", kAsanAllocaRightMagic);\n+}\n+\n+static void PrintShadowBytes(InternalScopedString *str, const char *before,\n+                             u8 *bytes, u8 *guilty, uptr n) {\n+  Decorator d;\n+  if (before) str->append(\"%s%p:\", before, bytes);\n+  for (uptr i = 0; i < n; i++) {\n+    u8 *p = bytes + i;\n+    const char *before =\n+        p == guilty ? \"[\" : (p - 1 == guilty && i != 0) ? \"\" : \" \";\n+    const char *after = p == guilty ? \"]\" : \"\";\n+    PrintShadowByte(str, before, *p, after);\n+  }\n+  str->append(\"\\n\");\n+}\n+\n+static void PrintShadowMemoryForAddress(uptr addr) {\n+  if (!AddrIsInMem(addr)) return;\n+  uptr shadow_addr = MemToShadow(addr);\n+  const uptr n_bytes_per_row = 16;\n+  uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n+  InternalScopedString str(4096 * 8);\n+  str.append(\"Shadow bytes around the buggy address:\\n\");\n+  for (int i = -5; i <= 5; i++) {\n+    const char *prefix = (i == 0) ? \"=>\" : \"  \";\n+    PrintShadowBytes(&str, prefix, (u8 *)(aligned_shadow + i * n_bytes_per_row),\n+                     (u8 *)shadow_addr, n_bytes_per_row);\n+  }\n+  if (flags()->print_legend) PrintLegend(&str);\n+  Printf(\"%s\", str.data());\n+}\n+\n+void ErrorGeneric::Print() {\n+  Decorator d;\n+  Printf(\"%s\", d.Warning());\n+  uptr addr = addr_description.Address();\n+  Report(\"ERROR: AddressSanitizer: %s on address %p at pc %p bp %p sp %p\\n\",\n+         bug_descr, (void *)addr, pc, bp, sp);\n+  Printf(\"%s\", d.EndWarning());\n+\n+  char tname[128];\n+  Printf(\"%s%s of size %zu at %p thread T%d%s%s\\n\", d.Access(),\n+         access_size ? (is_write ? \"WRITE\" : \"READ\") : \"ACCESS\", access_size,\n+         (void *)addr, tid,\n+         ThreadNameWithParenthesis(tid, tname, sizeof(tname)), d.EndAccess());\n+\n+  scariness.Print();\n+  GET_STACK_TRACE_FATAL(pc, bp);\n+  stack.Print();\n+\n+  // Pass bug_descr because we have a special case for\n+  // initialization-order-fiasco\n+  addr_description.Print(bug_descr);\n+  if (shadow_val == kAsanContiguousContainerOOBMagic)\n+    PrintContainerOverflowHint();\n+  ReportErrorSummary(bug_descr, &stack);\n+  PrintShadowMemoryForAddress(addr);\n+}\n+\n+}  // namespace __asan"}, {"sha": "6262dcf350647cd1747651b9388e767f54d933fc", "filename": "libsanitizer/asan/asan_errors.h", "status": "added", "additions": 376, "deletions": 0, "changes": 376, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_errors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_errors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_errors.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,376 @@\n+//===-- asan_errors.h -------------------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// ASan-private header for error structures.\n+//===----------------------------------------------------------------------===//\n+#ifndef ASAN_ERRORS_H\n+#define ASAN_ERRORS_H\n+\n+#include \"asan_descriptions.h\"\n+#include \"asan_scariness_score.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+\n+namespace __asan {\n+\n+struct ErrorBase {\n+  ErrorBase() = default;\n+  explicit ErrorBase(u32 tid_) : tid(tid_) {}\n+  ScarinessScoreBase scariness;\n+  u32 tid;\n+};\n+\n+struct ErrorStackOverflow : ErrorBase {\n+  uptr addr, pc, bp, sp;\n+  // ErrorStackOverflow never owns the context.\n+  void *context;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorStackOverflow() = default;\n+  ErrorStackOverflow(u32 tid, const SignalContext &sig)\n+      : ErrorBase(tid),\n+        addr(sig.addr),\n+        pc(sig.pc),\n+        bp(sig.bp),\n+        sp(sig.sp),\n+        context(sig.context) {\n+    scariness.Clear();\n+    scariness.Scare(10, \"stack-overflow\");\n+  }\n+  void Print();\n+};\n+\n+struct ErrorDeadlySignal : ErrorBase {\n+  uptr addr, pc, bp, sp;\n+  // ErrorDeadlySignal never owns the context.\n+  void *context;\n+  int signo;\n+  SignalContext::WriteFlag write_flag;\n+  bool is_memory_access;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorDeadlySignal() = default;\n+  ErrorDeadlySignal(u32 tid, const SignalContext &sig, int signo_)\n+      : ErrorBase(tid),\n+        addr(sig.addr),\n+        pc(sig.pc),\n+        bp(sig.bp),\n+        sp(sig.sp),\n+        context(sig.context),\n+        signo(signo_),\n+        write_flag(sig.write_flag),\n+        is_memory_access(sig.is_memory_access) {\n+    scariness.Clear();\n+    if (is_memory_access) {\n+      if (addr < GetPageSizeCached()) {\n+        scariness.Scare(10, \"null-deref\");\n+      } else if (addr == pc) {\n+        scariness.Scare(60, \"wild-jump\");\n+      } else if (write_flag == SignalContext::WRITE) {\n+        scariness.Scare(30, \"wild-addr-write\");\n+      } else if (write_flag == SignalContext::READ) {\n+        scariness.Scare(20, \"wild-addr-read\");\n+      } else {\n+        scariness.Scare(25, \"wild-addr\");\n+      }\n+    } else {\n+      scariness.Scare(10, \"signal\");\n+    }\n+  }\n+  void Print();\n+};\n+\n+struct ErrorDoubleFree : ErrorBase {\n+  // ErrorDoubleFree doesn't own the stack trace.\n+  const BufferedStackTrace *second_free_stack;\n+  HeapAddressDescription addr_description;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorDoubleFree() = default;\n+  ErrorDoubleFree(u32 tid, BufferedStackTrace *stack, uptr addr)\n+      : ErrorBase(tid), second_free_stack(stack) {\n+    CHECK_GT(second_free_stack->size, 0);\n+    GetHeapAddressInformation(addr, 1, &addr_description);\n+    scariness.Clear();\n+    scariness.Scare(42, \"double-free\");\n+  }\n+  void Print();\n+};\n+\n+struct ErrorNewDeleteSizeMismatch : ErrorBase {\n+  // ErrorNewDeleteSizeMismatch doesn't own the stack trace.\n+  const BufferedStackTrace *free_stack;\n+  HeapAddressDescription addr_description;\n+  uptr delete_size;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorNewDeleteSizeMismatch() = default;\n+  ErrorNewDeleteSizeMismatch(u32 tid, BufferedStackTrace *stack, uptr addr,\n+                             uptr delete_size_)\n+      : ErrorBase(tid), free_stack(stack), delete_size(delete_size_) {\n+    GetHeapAddressInformation(addr, 1, &addr_description);\n+    scariness.Clear();\n+    scariness.Scare(10, \"new-delete-type-mismatch\");\n+  }\n+  void Print();\n+};\n+\n+struct ErrorFreeNotMalloced : ErrorBase {\n+  // ErrorFreeNotMalloced doesn't own the stack trace.\n+  const BufferedStackTrace *free_stack;\n+  AddressDescription addr_description;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorFreeNotMalloced() = default;\n+  ErrorFreeNotMalloced(u32 tid, BufferedStackTrace *stack, uptr addr)\n+      : ErrorBase(tid),\n+        free_stack(stack),\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n+    scariness.Clear();\n+    scariness.Scare(40, \"bad-free\");\n+  }\n+  void Print();\n+};\n+\n+struct ErrorAllocTypeMismatch : ErrorBase {\n+  // ErrorAllocTypeMismatch doesn't own the stack trace.\n+  const BufferedStackTrace *dealloc_stack;\n+  HeapAddressDescription addr_description;\n+  AllocType alloc_type, dealloc_type;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorAllocTypeMismatch() = default;\n+  ErrorAllocTypeMismatch(u32 tid, BufferedStackTrace *stack, uptr addr,\n+                         AllocType alloc_type_, AllocType dealloc_type_)\n+      : ErrorBase(tid),\n+        dealloc_stack(stack),\n+        alloc_type(alloc_type_),\n+        dealloc_type(dealloc_type_) {\n+    GetHeapAddressInformation(addr, 1, &addr_description);\n+    scariness.Clear();\n+    scariness.Scare(10, \"alloc-dealloc-mismatch\");\n+  };\n+  void Print();\n+};\n+\n+struct ErrorMallocUsableSizeNotOwned : ErrorBase {\n+  // ErrorMallocUsableSizeNotOwned doesn't own the stack trace.\n+  const BufferedStackTrace *stack;\n+  AddressDescription addr_description;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorMallocUsableSizeNotOwned() = default;\n+  ErrorMallocUsableSizeNotOwned(u32 tid, BufferedStackTrace *stack_, uptr addr)\n+      : ErrorBase(tid),\n+        stack(stack_),\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n+    scariness.Clear();\n+  }\n+  void Print();\n+};\n+\n+struct ErrorSanitizerGetAllocatedSizeNotOwned : ErrorBase {\n+  // ErrorSanitizerGetAllocatedSizeNotOwned doesn't own the stack trace.\n+  const BufferedStackTrace *stack;\n+  AddressDescription addr_description;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorSanitizerGetAllocatedSizeNotOwned() = default;\n+  ErrorSanitizerGetAllocatedSizeNotOwned(u32 tid, BufferedStackTrace *stack_,\n+                                         uptr addr)\n+      : ErrorBase(tid),\n+        stack(stack_),\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false) {\n+    scariness.Clear();\n+  }\n+  void Print();\n+};\n+\n+struct ErrorStringFunctionMemoryRangesOverlap : ErrorBase {\n+  // ErrorStringFunctionMemoryRangesOverlap doesn't own the stack trace.\n+  const BufferedStackTrace *stack;\n+  uptr length1, length2;\n+  AddressDescription addr1_description;\n+  AddressDescription addr2_description;\n+  const char *function;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorStringFunctionMemoryRangesOverlap() = default;\n+  ErrorStringFunctionMemoryRangesOverlap(u32 tid, BufferedStackTrace *stack_,\n+                                         uptr addr1, uptr length1_, uptr addr2,\n+                                         uptr length2_, const char *function_)\n+      : ErrorBase(tid),\n+        stack(stack_),\n+        length1(length1_),\n+        length2(length2_),\n+        addr1_description(addr1, length1, /*shouldLockThreadRegistry=*/false),\n+        addr2_description(addr2, length2, /*shouldLockThreadRegistry=*/false),\n+        function(function_) {\n+    char bug_type[100];\n+    internal_snprintf(bug_type, sizeof(bug_type), \"%s-param-overlap\", function);\n+    scariness.Clear();\n+    scariness.Scare(10, bug_type);\n+  }\n+  void Print();\n+};\n+\n+struct ErrorStringFunctionSizeOverflow : ErrorBase {\n+  // ErrorStringFunctionSizeOverflow doesn't own the stack trace.\n+  const BufferedStackTrace *stack;\n+  AddressDescription addr_description;\n+  uptr size;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorStringFunctionSizeOverflow() = default;\n+  ErrorStringFunctionSizeOverflow(u32 tid, BufferedStackTrace *stack_,\n+                                  uptr addr, uptr size_)\n+      : ErrorBase(tid),\n+        stack(stack_),\n+        addr_description(addr, /*shouldLockThreadRegistry=*/false),\n+        size(size_) {\n+    scariness.Clear();\n+    scariness.Scare(10, \"negative-size-param\");\n+  }\n+  void Print();\n+};\n+\n+struct ErrorBadParamsToAnnotateContiguousContainer : ErrorBase {\n+  // ErrorBadParamsToAnnotateContiguousContainer doesn't own the stack trace.\n+  const BufferedStackTrace *stack;\n+  uptr beg, end, old_mid, new_mid;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorBadParamsToAnnotateContiguousContainer() = default;\n+  // PS4: Do we want an AddressDescription for beg?\n+  ErrorBadParamsToAnnotateContiguousContainer(u32 tid,\n+                                              BufferedStackTrace *stack_,\n+                                              uptr beg_, uptr end_,\n+                                              uptr old_mid_, uptr new_mid_)\n+      : ErrorBase(tid),\n+        stack(stack_),\n+        beg(beg_),\n+        end(end_),\n+        old_mid(old_mid_),\n+        new_mid(new_mid_) {}\n+  void Print();\n+};\n+\n+struct ErrorODRViolation : ErrorBase {\n+  __asan_global global1, global2;\n+  u32 stack_id1, stack_id2;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorODRViolation() = default;\n+  ErrorODRViolation(u32 tid, const __asan_global *g1, u32 stack_id1_,\n+                    const __asan_global *g2, u32 stack_id2_)\n+      : ErrorBase(tid),\n+        global1(*g1),\n+        global2(*g2),\n+        stack_id1(stack_id1_),\n+        stack_id2(stack_id2_) {}\n+  void Print();\n+};\n+\n+struct ErrorInvalidPointerPair : ErrorBase {\n+  uptr pc, bp, sp;\n+  AddressDescription addr1_description;\n+  AddressDescription addr2_description;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorInvalidPointerPair() = default;\n+  ErrorInvalidPointerPair(u32 tid, uptr pc_, uptr bp_, uptr sp_, uptr p1,\n+                          uptr p2)\n+      : ErrorBase(tid),\n+        pc(pc_),\n+        bp(bp_),\n+        sp(sp_),\n+        addr1_description(p1, 1, /*shouldLockThreadRegistry=*/false),\n+        addr2_description(p2, 1, /*shouldLockThreadRegistry=*/false) {}\n+  void Print();\n+};\n+\n+struct ErrorGeneric : ErrorBase {\n+  AddressDescription addr_description;\n+  uptr pc, bp, sp;\n+  uptr access_size;\n+  const char *bug_descr;\n+  bool is_write;\n+  u8 shadow_val;\n+  // VS2013 doesn't implement unrestricted unions, so we need a trivial default\n+  // constructor\n+  ErrorGeneric() = default;\n+  ErrorGeneric(u32 tid, uptr addr, uptr pc_, uptr bp_, uptr sp_, bool is_write_,\n+               uptr access_size_);\n+  void Print();\n+};\n+\n+// clang-format off\n+#define ASAN_FOR_EACH_ERROR_KIND(macro)         \\\n+  macro(StackOverflow)                          \\\n+  macro(DeadlySignal)                           \\\n+  macro(DoubleFree)                             \\\n+  macro(NewDeleteSizeMismatch)                  \\\n+  macro(FreeNotMalloced)                        \\\n+  macro(AllocTypeMismatch)                      \\\n+  macro(MallocUsableSizeNotOwned)               \\\n+  macro(SanitizerGetAllocatedSizeNotOwned)      \\\n+  macro(StringFunctionMemoryRangesOverlap)      \\\n+  macro(StringFunctionSizeOverflow)             \\\n+  macro(BadParamsToAnnotateContiguousContainer) \\\n+  macro(ODRViolation)                           \\\n+  macro(InvalidPointerPair)                     \\\n+  macro(Generic)\n+// clang-format on\n+\n+#define ASAN_DEFINE_ERROR_KIND(name) kErrorKind##name,\n+#define ASAN_ERROR_DESCRIPTION_MEMBER(name) Error##name name;\n+#define ASAN_ERROR_DESCRIPTION_CONSTRUCTOR(name) \\\n+  ErrorDescription(Error##name const &e) : kind(kErrorKind##name), name(e) {}\n+#define ASAN_ERROR_DESCRIPTION_PRINT(name) \\\n+  case kErrorKind##name:                   \\\n+    return name.Print();\n+\n+enum ErrorKind {\n+  kErrorKindInvalid = 0,\n+  ASAN_FOR_EACH_ERROR_KIND(ASAN_DEFINE_ERROR_KIND)\n+};\n+\n+struct ErrorDescription {\n+  ErrorKind kind;\n+  // We're using a tagged union because it allows us to have a trivially\n+  // copiable type and use the same structures as the public interface.\n+  //\n+  // We can add a wrapper around it to make it \"more c++-like\", but that would\n+  // add a lot of code and the benefit wouldn't be that big.\n+  union {\n+    ASAN_FOR_EACH_ERROR_KIND(ASAN_ERROR_DESCRIPTION_MEMBER)\n+  };\n+\n+  ErrorDescription() { internal_memset(this, 0, sizeof(*this)); }\n+  ASAN_FOR_EACH_ERROR_KIND(ASAN_ERROR_DESCRIPTION_CONSTRUCTOR)\n+\n+  bool IsValid() { return kind != kErrorKindInvalid; }\n+  void Print() {\n+    switch (kind) {\n+      ASAN_FOR_EACH_ERROR_KIND(ASAN_ERROR_DESCRIPTION_PRINT)\n+      case kErrorKindInvalid:\n+        CHECK(0);\n+    }\n+    CHECK(0);\n+  }\n+};\n+\n+#undef ASAN_FOR_EACH_ERROR_KIND\n+#undef ASAN_DEFINE_ERROR_KIND\n+#undef ASAN_ERROR_DESCRIPTION_MEMBER\n+#undef ASAN_ERROR_DESCRIPTION_CONSTRUCTOR\n+#undef ASAN_ERROR_DESCRIPTION_PRINT\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_ERRORS_H"}, {"sha": "bf7566a334ead8c1f1d4fb6663ea4d749f165a09", "filename": "libsanitizer/asan/asan_fake_stack.cc", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_fake_stack.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -29,7 +29,7 @@ ALWAYS_INLINE void SetShadow(uptr ptr, uptr size, uptr class_id, u64 magic) {\n   CHECK_EQ(SHADOW_SCALE, 3);  // This code expects SHADOW_SCALE=3.\n   u64 *shadow = reinterpret_cast<u64*>(MemToShadow(ptr));\n   if (class_id <= 6) {\n-    for (uptr i = 0; i < (1U << class_id); i++) {\n+    for (uptr i = 0; i < (((uptr)1) << class_id); i++) {\n       shadow[i] = magic;\n       // Make sure this does not become memset.\n       SanitizerBreakOptimization(nullptr);\n@@ -98,7 +98,7 @@ FakeFrame *FakeStack::Allocate(uptr stack_size_log, uptr class_id,\n     // if the signal arrives between checking and setting flags[pos], the\n     // signal handler's fake stack will start from a different hint_position\n     // and so will not touch this particular byte. So, it is safe to do this\n-    // with regular non-atimic load and store (at least I was not able to make\n+    // with regular non-atomic load and store (at least I was not able to make\n     // this code crash).\n     if (flags[pos]) continue;\n     flags[pos] = 1;\n@@ -119,7 +119,7 @@ uptr FakeStack::AddrIsInFakeStack(uptr ptr, uptr *frame_beg, uptr *frame_end) {\n   uptr class_id = (ptr - beg) >> stack_size_log;\n   uptr base = beg + (class_id << stack_size_log);\n   CHECK_LE(base, ptr);\n-  CHECK_LT(ptr, base + (1UL << stack_size_log));\n+  CHECK_LT(ptr, base + (((uptr)1) << stack_size_log));\n   uptr pos = (ptr - base) >> (kMinStackFrameSizeLog + class_id);\n   uptr res = base + pos * BytesInSizeClass(class_id);\n   *frame_end = res + BytesInSizeClass(class_id);"}, {"sha": "6ac61ddd24e9ff7f4fb58498a332b8b1a005d946", "filename": "libsanitizer/asan/asan_fake_stack.h", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_fake_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_fake_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_fake_stack.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -50,7 +50,7 @@ struct FakeFrame {\n // Allocate() flips the appropriate allocation flag atomically, thus achieving\n // async-signal safety.\n // This allocator does not have quarantine per se, but it tries to allocate the\n-// frames in round robin fasion to maximize the delay between a deallocation\n+// frames in round robin fashion to maximize the delay between a deallocation\n // and the next allocation.\n class FakeStack {\n   static const uptr kMinStackFrameSizeLog = 6;  // Min frame is 64B.\n@@ -67,12 +67,12 @@ class FakeStack {\n \n   // stack_size_log is at least 15 (stack_size >= 32K).\n   static uptr SizeRequiredForFlags(uptr stack_size_log) {\n-    return 1UL << (stack_size_log + 1 - kMinStackFrameSizeLog);\n+    return ((uptr)1) << (stack_size_log + 1 - kMinStackFrameSizeLog);\n   }\n \n   // Each size class occupies stack_size bytes.\n   static uptr SizeRequiredForFrames(uptr stack_size_log) {\n-    return (1ULL << stack_size_log) * kNumberOfSizeClasses;\n+    return (((uptr)1) << stack_size_log) * kNumberOfSizeClasses;\n   }\n \n   // Number of bytes requires for the whole object.\n@@ -89,20 +89,20 @@ class FakeStack {\n   // and so on.\n   static uptr FlagsOffset(uptr stack_size_log, uptr class_id) {\n     uptr t = kNumberOfSizeClasses - 1 - class_id;\n-    const uptr all_ones = (1 << (kNumberOfSizeClasses - 1)) - 1;\n+    const uptr all_ones = (((uptr)1) << (kNumberOfSizeClasses - 1)) - 1;\n     return ((all_ones >> t) << t) << (stack_size_log - 15);\n   }\n \n   static uptr NumberOfFrames(uptr stack_size_log, uptr class_id) {\n-    return 1UL << (stack_size_log - kMinStackFrameSizeLog - class_id);\n+    return ((uptr)1) << (stack_size_log - kMinStackFrameSizeLog - class_id);\n   }\n \n-  // Divide n by the numbe of frames in size class.\n+  // Divide n by the number of frames in size class.\n   static uptr ModuloNumberOfFrames(uptr stack_size_log, uptr class_id, uptr n) {\n     return n & (NumberOfFrames(stack_size_log, class_id) - 1);\n   }\n \n-  // The the pointer to the flags of the given class_id.\n+  // The pointer to the flags of the given class_id.\n   u8 *GetFlags(uptr stack_size_log, uptr class_id) {\n     return reinterpret_cast<u8 *>(this) + kFlagsOffset +\n            FlagsOffset(stack_size_log, class_id);\n@@ -112,7 +112,8 @@ class FakeStack {\n   u8 *GetFrame(uptr stack_size_log, uptr class_id, uptr pos) {\n     return reinterpret_cast<u8 *>(this) + kFlagsOffset +\n            SizeRequiredForFlags(stack_size_log) +\n-           (1 << stack_size_log) * class_id + BytesInSizeClass(class_id) * pos;\n+           (((uptr)1) << stack_size_log) * class_id +\n+           BytesInSizeClass(class_id) * pos;\n   }\n \n   // Allocate the fake frame.\n@@ -135,7 +136,7 @@ class FakeStack {\n \n   // Number of bytes in a fake frame of this size class.\n   static uptr BytesInSizeClass(uptr class_id) {\n-    return 1UL << (class_id + kMinStackFrameSizeLog);\n+    return ((uptr)1) << (class_id + kMinStackFrameSizeLog);\n   }\n \n   // The fake frame is guaranteed to have a right redzone.\n@@ -157,7 +158,7 @@ class FakeStack {\n   static const uptr kFlagsOffset = 4096;  // This is were the flags begin.\n   // Must match the number of uses of DEFINE_STACK_MALLOC_FREE_WITH_CLASS_ID\n   COMPILER_CHECK(kNumberOfSizeClasses == 11);\n-  static const uptr kMaxStackMallocSize = 1 << kMaxStackFrameSizeLog;\n+  static const uptr kMaxStackMallocSize = ((uptr)1) << kMaxStackFrameSizeLog;\n \n   uptr hint_position_[kNumberOfSizeClasses];\n   uptr stack_size_log_;"}, {"sha": "c18174beed0a9b230dd3e1cf7dbae2b6b9104f6f", "filename": "libsanitizer/asan/asan_flags.cc", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -114,15 +114,7 @@ void InitializeFlags() {\n   ubsan_parser.ParseString(GetEnv(\"UBSAN_OPTIONS\"));\n #endif\n \n-  // Let activation flags override current settings. On Android they come\n-  // from a system property. On other platforms this is no-op.\n-  if (!flags()->start_deactivated) {\n-    char buf[100];\n-    GetExtraActivationFlags(buf, sizeof(buf));\n-    asan_parser.ParseString(buf);\n-  }\n-\n-  SetVerbosity(common_flags()->verbosity);\n+  InitializeCommonFlags();\n \n   // TODO(eugenis): dump all flags at verbosity>=2?\n   if (Verbosity()) ReportUnrecognizedFlags();\n@@ -165,6 +157,14 @@ void InitializeFlags() {\n         (ASAN_LOW_MEMORY) ? 1UL << 6 : 1UL << 8;\n     f->quarantine_size_mb = kDefaultQuarantineSizeMb;\n   }\n+  if (!f->replace_str && common_flags()->intercept_strlen) {\n+    Report(\"WARNING: strlen interceptor is enabled even though replace_str=0. \"\n+           \"Use intercept_strlen=0 to disable it.\");\n+  }\n+  if (!f->replace_str && common_flags()->intercept_strchr) {\n+    Report(\"WARNING: strchr* interceptors are enabled even though \"\n+           \"replace_str=0. Use intercept_strchr=0 to disable them.\");\n+  }\n }\n \n }  // namespace __asan"}, {"sha": "34493eededfc17e84c0fe20dc654564d746077c5", "filename": "libsanitizer/asan/asan_flags.inc", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_flags.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -41,10 +41,7 @@ ASAN_FLAG(\n     \"If set, uses custom wrappers and replacements for libc string functions \"\n     \"to find more errors.\")\n ASAN_FLAG(bool, replace_intrin, true,\n-          \"If set, uses custom wrappers for memset/memcpy/memmove intinsics.\")\n-ASAN_FLAG(bool, mac_ignore_invalid_free, false,\n-          \"Ignore invalid free() calls to work around some bugs. Used on OS X \"\n-          \"only.\")\n+          \"If set, uses custom wrappers for memset/memcpy/memmove intrinsics.\")\n ASAN_FLAG(bool, detect_stack_use_after_return, false,\n           \"Enables stack-use-after-return checking at run-time.\")\n ASAN_FLAG(int, min_uar_stack_size_log, 16, // We can't do smaller anyway.\n@@ -78,6 +75,8 @@ ASAN_FLAG(bool, print_stats, false,\n           \"Print various statistics after printing an error message or if \"\n           \"atexit=1.\")\n ASAN_FLAG(bool, print_legend, true, \"Print the legend for the shadow bytes.\")\n+ASAN_FLAG(bool, print_scariness, false,\n+          \"Print the scariness score. Experimental.\")\n ASAN_FLAG(bool, atexit, false,\n           \"If set, prints ASan exit stats even after program terminates \"\n           \"successfully.\")\n@@ -97,15 +96,15 @@ ASAN_FLAG(bool, poison_array_cookie, true,\n           \"Poison (or not) the array cookie after operator new[].\")\n \n // Turn off alloc/dealloc mismatch checker on Mac and Windows for now.\n-// https://code.google.com/p/address-sanitizer/issues/detail?id=131\n-// https://code.google.com/p/address-sanitizer/issues/detail?id=309\n+// https://github.com/google/sanitizers/issues/131\n+// https://github.com/google/sanitizers/issues/309\n // TODO(glider,timurrrr): Fix known issues and enable this back.\n ASAN_FLAG(bool, alloc_dealloc_mismatch,\n-          (SANITIZER_MAC == 0) && (SANITIZER_WINDOWS == 0),\n+          !SANITIZER_MAC && !SANITIZER_WINDOWS && !SANITIZER_ANDROID,\n           \"Report errors on malloc/delete, new/free, new/delete[], etc.\")\n \n ASAN_FLAG(bool, new_delete_type_mismatch, true,\n-          \"Report errors on mismatch betwen size of new and delete.\")\n+          \"Report errors on mismatch between size of new and delete.\")\n ASAN_FLAG(\n     bool, strict_init_order, false,\n     \"If true, assume that dynamic initializers can never access globals from \"\n@@ -124,8 +123,8 @@ ASAN_FLAG(\n     \"The bigger the value the harder we try.\")\n ASAN_FLAG(\n     bool, detect_container_overflow, true,\n-    \"If true, honor the container overflow  annotations. \"\n-    \"See https://code.google.com/p/address-sanitizer/wiki/ContainerOverflow\")\n+    \"If true, honor the container overflow annotations. See \"\n+    \"https://github.com/google/sanitizers/wiki/AddressSanitizerContainerOverflow\")\n ASAN_FLAG(int, detect_odr_violation, 2,\n           \"If >=2, detect violation of One-Definition-Rule (ODR); \"\n           \"If ==1, detect ODR-violation only if the two variables \"\n@@ -136,3 +135,5 @@ ASAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n ASAN_FLAG(bool, halt_on_error, true,\n           \"Crash the program after printing the first error report \"\n           \"(WARNING: USE AT YOUR OWN RISK!)\")\n+ASAN_FLAG(bool, use_odr_indicator, false,\n+          \"Use special ODR indicator symbol for ODR violation detection\")"}, {"sha": "007fce72be011dcd3a7654ae6dc913f2dab1e23f", "filename": "libsanitizer/asan/asan_globals.cc", "status": "modified", "additions": 142, "deletions": 24, "changes": 166, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_globals.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_globals.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_globals.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -23,6 +23,7 @@\n #include \"sanitizer_common/sanitizer_mutex.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_symbolizer.h\"\n \n namespace __asan {\n \n@@ -121,16 +122,68 @@ int GetGlobalsForAddress(uptr addr, Global *globals, u32 *reg_sites,\n   return res;\n }\n \n-bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr) {\n-  Global g = {};\n-  if (GetGlobalsForAddress(addr, &g, nullptr, 1)) {\n-    internal_strncpy(descr->name, g.name, descr->name_size);\n-    descr->region_address = g.beg;\n-    descr->region_size = g.size;\n-    descr->region_kind = \"global\";\n-    return true;\n+enum GlobalSymbolState {\n+  UNREGISTERED = 0,\n+  REGISTERED = 1\n+};\n+\n+// Check ODR violation for given global G via special ODR indicator. We use\n+// this method in case compiler instruments global variables through their\n+// local aliases.\n+static void CheckODRViolationViaIndicator(const Global *g) {\n+  u8 *odr_indicator = reinterpret_cast<u8 *>(g->odr_indicator);\n+  if (*odr_indicator == UNREGISTERED) {\n+    *odr_indicator = REGISTERED;\n+    return;\n+  }\n+  // If *odr_indicator is DEFINED, some module have already registered\n+  // externally visible symbol with the same name. This is an ODR violation.\n+  for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+    if (g->odr_indicator == l->g->odr_indicator &&\n+        (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+        !IsODRViolationSuppressed(g->name))\n+      ReportODRViolation(g, FindRegistrationSite(g),\n+                         l->g, FindRegistrationSite(l->g));\n+  }\n+}\n+\n+// Check ODR violation for given global G by checking if it's already poisoned.\n+// We use this method in case compiler doesn't use private aliases for global\n+// variables.\n+static void CheckODRViolationViaPoisoning(const Global *g) {\n+  if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n+    // This check may not be enough: if the first global is much larger\n+    // the entire redzone of the second global may be within the first global.\n+    for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n+      if (g->beg == l->g->beg &&\n+          (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n+          !IsODRViolationSuppressed(g->name))\n+        ReportODRViolation(g, FindRegistrationSite(g),\n+                           l->g, FindRegistrationSite(l->g));\n+    }\n   }\n-  return false;\n+}\n+\n+// Clang provides two different ways for global variables protection:\n+// it can poison the global itself or its private alias. In former\n+// case we may poison same symbol multiple times, that can help us to\n+// cheaply detect ODR violation: if we try to poison an already poisoned\n+// global, we have ODR violation error.\n+// In latter case, we poison each symbol exactly once, so we use special\n+// indicator symbol to perform similar check.\n+// In either case, compiler provides a special odr_indicator field to Global\n+// structure, that can contain two kinds of values:\n+//   1) Non-zero value. In this case, odr_indicator is an address of\n+//      corresponding indicator variable for given global.\n+//   2) Zero. This means that we don't use private aliases for global variables\n+//      and can freely check ODR violation with the first method.\n+//\n+// This routine chooses between two different methods of ODR violation\n+// detection.\n+static inline bool UseODRIndicator(const Global *g) {\n+  // Use ODR indicator method iff use_odr_indicator flag is set and\n+  // indicator symbol address is not 0.\n+  return flags()->use_odr_indicator && g->odr_indicator > 0;\n }\n \n // Register a global variable.\n@@ -142,24 +195,24 @@ static void RegisterGlobal(const Global *g) {\n     ReportGlobal(*g, \"Added\");\n   CHECK(flags()->report_globals);\n   CHECK(AddrIsInMem(g->beg));\n-  CHECK(AddrIsAlignedByGranularity(g->beg));\n+  if (!AddrIsAlignedByGranularity(g->beg)) {\n+    Report(\"The following global variable is not properly aligned.\\n\");\n+    Report(\"This may happen if another global with the same name\\n\");\n+    Report(\"resides in another non-instrumented module.\\n\");\n+    Report(\"Or the global comes from a C file built w/o -fno-common.\\n\");\n+    Report(\"In either case this is likely an ODR violation bug,\\n\");\n+    Report(\"but AddressSanitizer can not provide more details.\\n\");\n+    ReportODRViolation(g, FindRegistrationSite(g), g, FindRegistrationSite(g));\n+    CHECK(AddrIsAlignedByGranularity(g->beg));\n+  }\n   CHECK(AddrIsAlignedByGranularity(g->size_with_redzone));\n-  // This \"ODR violation\" detection is fundamentally incompatible with\n-  // how GCC registers globals.  Disable as useless until rewritten upstream.\n-  if (0 && flags()->detect_odr_violation) {\n+  if (flags()->detect_odr_violation) {\n     // Try detecting ODR (One Definition Rule) violation, i.e. the situation\n     // where two globals with the same name are defined in different modules.\n-    if (__asan_region_is_poisoned(g->beg, g->size_with_redzone)) {\n-      // This check may not be enough: if the first global is much larger\n-      // the entire redzone of the second global may be within the first global.\n-      for (ListOfGlobals *l = list_of_all_globals; l; l = l->next) {\n-        if (g->beg == l->g->beg &&\n-            (flags()->detect_odr_violation >= 2 || g->size != l->g->size) &&\n-            !IsODRViolationSuppressed(g->name))\n-          ReportODRViolation(g, FindRegistrationSite(g),\n-                             l->g, FindRegistrationSite(l->g));\n-      }\n-    }\n+    if (UseODRIndicator(g))\n+      CheckODRViolationViaIndicator(g);\n+    else\n+      CheckODRViolationViaPoisoning(g);\n   }\n   if (CanPoisonMemory())\n     PoisonRedZones(*g);\n@@ -190,6 +243,12 @@ static void UnregisterGlobal(const Global *g) {\n   // We unpoison the shadow memory for the global but we do not remove it from\n   // the list because that would require O(n^2) time with the current list\n   // implementation. It might not be worth doing anyway.\n+\n+  // Release ODR indicator.\n+  if (UseODRIndicator(g)) {\n+    u8 *odr_indicator = reinterpret_cast<u8 *>(g->odr_indicator);\n+    *odr_indicator = UNREGISTERED;\n+  }\n }\n \n void StopInitOrderChecking() {\n@@ -207,11 +266,70 @@ void StopInitOrderChecking() {\n   }\n }\n \n+static bool IsASCII(unsigned char c) { return /*0x00 <= c &&*/ c <= 0x7F; }\n+\n+const char *MaybeDemangleGlobalName(const char *name) {\n+  // We can spoil names of globals with C linkage, so use an heuristic\n+  // approach to check if the name should be demangled.\n+  bool should_demangle = false;\n+  if (name[0] == '_' && name[1] == 'Z')\n+    should_demangle = true;\n+  else if (SANITIZER_WINDOWS && name[0] == '\\01' && name[1] == '?')\n+    should_demangle = true;\n+\n+  return should_demangle ? Symbolizer::GetOrInit()->Demangle(name) : name;\n+}\n+\n+// Check if the global is a zero-terminated ASCII string. If so, print it.\n+void PrintGlobalNameIfASCII(InternalScopedString *str, const __asan_global &g) {\n+  for (uptr p = g.beg; p < g.beg + g.size - 1; p++) {\n+    unsigned char c = *(unsigned char *)p;\n+    if (c == '\\0' || !IsASCII(c)) return;\n+  }\n+  if (*(char *)(g.beg + g.size - 1) != '\\0') return;\n+  str->append(\"  '%s' is ascii string '%s'\\n\", MaybeDemangleGlobalName(g.name),\n+              (char *)g.beg);\n+}\n+\n+static const char *GlobalFilename(const __asan_global &g) {\n+  const char *res = g.module_name;\n+  // Prefer the filename from source location, if is available.\n+  if (g.location) res = g.location->filename;\n+  CHECK(res);\n+  return res;\n+}\n+\n+void PrintGlobalLocation(InternalScopedString *str, const __asan_global &g) {\n+  str->append(\"%s\", GlobalFilename(g));\n+  if (!g.location) return;\n+  if (g.location->line_no) str->append(\":%d\", g.location->line_no);\n+  if (g.location->column_no) str->append(\":%d\", g.location->column_no);\n+}\n+\n } // namespace __asan\n \n // ---------------------- Interface ---------------- {{{1\n using namespace __asan;  // NOLINT\n \n+\n+// Apply __asan_register_globals to all globals found in the same loaded\n+// executable or shared library as `flag'. The flag tracks whether globals have\n+// already been registered or not for this image.\n+void __asan_register_image_globals(uptr *flag) {\n+  if (*flag)\n+    return;\n+  AsanApplyToGlobals(__asan_register_globals, flag);\n+  *flag = 1;\n+}\n+\n+// This mirrors __asan_register_image_globals.\n+void __asan_unregister_image_globals(uptr *flag) {\n+  if (!*flag)\n+    return;\n+  AsanApplyToGlobals(__asan_unregister_globals, flag);\n+  *flag = 0;\n+}\n+\n // Register an array of globals.\n void __asan_register_globals(__asan_global *globals, uptr n) {\n   if (!flags()->report_globals) return;"}, {"sha": "51e8324fc136f00728cfe3caec331557e48622d7", "filename": "libsanitizer/asan/asan_init_version.h", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_init_version.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_init_version.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_init_version.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -17,16 +17,20 @@ extern \"C\" {\n   // Every time the ASan ABI changes we also change the version number in the\n   // __asan_init function name.  Objects built with incompatible ASan ABI\n   // versions will not link with run-time.\n+  //\n   // Changes between ABI versions:\n   // v1=>v2: added 'module_name' to __asan_global\n   // v2=>v3: stack frame description (created by the compiler)\n-  //         contains the function PC as the 3-rd field (see\n-  //         DescribeAddressIfStack).\n-  // v3=>v4: added '__asan_global_source_location' to __asan_global.\n+  //         contains the function PC as the 3rd field (see\n+  //         DescribeAddressIfStack)\n+  // v3=>v4: added '__asan_global_source_location' to __asan_global\n   // v4=>v5: changed the semantics and format of __asan_stack_malloc_ and\n-  //         __asan_stack_free_ functions.\n+  //         __asan_stack_free_ functions\n   // v5=>v6: changed the name of the version check symbol\n-  #define __asan_version_mismatch_check __asan_version_mismatch_check_v6\n+  // v6=>v7: added 'odr_indicator' to __asan_global\n+  // v7=>v8: added '__asan_(un)register_image_globals' functions for dead\n+  //         stripping support on Mach-O platforms\n+  #define __asan_version_mismatch_check __asan_version_mismatch_check_v8\n }\n \n #endif  // ASAN_INIT_VERSION_H"}, {"sha": "743abe51481340eba71fa14f446089186960c830", "filename": "libsanitizer/asan/asan_interceptors.cc", "status": "modified", "additions": 46, "deletions": 60, "changes": 106, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -19,6 +19,7 @@\n #include \"asan_stack.h\"\n #include \"asan_stats.h\"\n #include \"asan_suppressions.h\"\n+#include \"lsan/lsan_common.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n \n #if SANITIZER_POSIX\n@@ -108,7 +109,7 @@ static inline bool RangesOverlap(const char *offset1, uptr length1,\n } while (0)\n \n static inline uptr MaybeRealStrnlen(const char *s, uptr maxlen) {\n-#if ASAN_INTERCEPT_STRNLEN\n+#if SANITIZER_INTERCEPT_STRNLEN\n   if (REAL(strnlen)) {\n     return REAL(strnlen)(s, maxlen);\n   }\n@@ -141,6 +142,8 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   (void) ctx;                                                                  \\\n \n #define COMMON_INTERCEPT_FUNCTION(name) ASAN_INTERCEPT_FUNC(name)\n+#define COMMON_INTERCEPT_FUNCTION_VER(name, ver)                          \\\n+  ASAN_INTERCEPT_FUNC_VER(name, ver)\n #define COMMON_INTERCEPTOR_WRITE_RANGE(ctx, ptr, size) \\\n   ASAN_WRITE_RANGE(ctx, ptr, size)\n #define COMMON_INTERCEPTOR_READ_RANGE(ctx, ptr, size) \\\n@@ -176,7 +179,7 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   } while (false)\n #define COMMON_INTERCEPTOR_BLOCK_REAL(name) REAL(name)\n // Strict init-order checking is dlopen-hostile:\n-// https://code.google.com/p/address-sanitizer/issues/detail?id=178\n+// https://github.com/google/sanitizers/issues/178\n #define COMMON_INTERCEPTOR_ON_DLOPEN(filename, flag)                           \\\n   if (flags()->strict_init_order) {                                            \\\n     StopInitOrderChecking();                                                   \\\n@@ -193,6 +196,10 @@ DECLARE_REAL_AND_INTERCEPTOR(void, free, void *)\n   } else {                                                                     \\\n     *begin = *end = 0;                                                         \\\n   }\n+// Asan needs custom handling of these:\n+#undef SANITIZER_INTERCEPT_MEMSET\n+#undef SANITIZER_INTERCEPT_MEMMOVE\n+#undef SANITIZER_INTERCEPT_MEMCPY\n #include \"sanitizer_common/sanitizer_common_interceptors.inc\"\n \n // Syscall interceptors don't have contexts, we don't support suppressions\n@@ -216,6 +223,7 @@ struct ThreadStartParam {\n   atomic_uintptr_t is_registered;\n };\n \n+#if ASAN_INTERCEPT_PTHREAD_CREATE\n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   ThreadStartParam *param = reinterpret_cast<ThreadStartParam *>(arg);\n   AsanThread *t = nullptr;\n@@ -226,7 +234,6 @@ static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   return t->ThreadStart(GetTid(), &param->is_registered);\n }\n \n-#if ASAN_INTERCEPT_PTHREAD_CREATE\n INTERCEPTOR(int, pthread_create, void *thread,\n     void *attr, void *(*start_routine)(void*), void *arg) {\n   EnsureMainThreadIDIsCorrect();\n@@ -240,7 +247,17 @@ INTERCEPTOR(int, pthread_create, void *thread,\n   ThreadStartParam param;\n   atomic_store(&param.t, 0, memory_order_relaxed);\n   atomic_store(&param.is_registered, 0, memory_order_relaxed);\n-  int result = REAL(pthread_create)(thread, attr, asan_thread_start, &param);\n+  int result;\n+  {\n+    // Ignore all allocations made by pthread_create: thread stack/TLS may be\n+    // stored by pthread for future reuse even after thread destruction, and\n+    // the linked list it's stored in doesn't even hold valid pointers to the\n+    // objects, the latter are calculated by obscure pointer arithmetic.\n+#if CAN_SANITIZE_LEAKS\n+    __lsan::ScopedInterceptorDisabler disabler;\n+#endif\n+    result = REAL(pthread_create)(thread, attr, asan_thread_start, &param);\n+  }\n   if (result == 0) {\n     u32 current_tid = GetCurrentTidOrInvalid();\n     AsanThread *t =\n@@ -269,23 +286,26 @@ DEFINE_REAL_PTHREAD_FUNCTIONS\n \n #if SANITIZER_ANDROID\n INTERCEPTOR(void*, bsd_signal, int signum, void *handler) {\n-  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n+  if (!IsHandledDeadlySignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n     return REAL(bsd_signal)(signum, handler);\n   }\n   return 0;\n }\n #endif\n \n INTERCEPTOR(void*, signal, int signum, void *handler) {\n-  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n+  if (!IsHandledDeadlySignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n     return REAL(signal)(signum, handler);\n   }\n   return nullptr;\n }\n \n INTERCEPTOR(int, sigaction, int signum, const struct sigaction *act,\n                             struct sigaction *oldact) {\n-  if (!IsDeadlySignal(signum) || common_flags()->allow_user_segv_handler) {\n+  if (!IsHandledDeadlySignal(signum) ||\n+      common_flags()->allow_user_segv_handler) {\n     return REAL(sigaction)(signum, act, oldact);\n   }\n   return 0;\n@@ -451,25 +471,6 @@ INTERCEPTOR(void*, memset, void *block, int c, uptr size) {\n   ASAN_MEMSET_IMPL(ctx, block, c, size);\n }\n \n-INTERCEPTOR(char*, strchr, const char *str, int c) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, strchr);\n-  if (UNLIKELY(!asan_inited)) return internal_strchr(str, c);\n-  // strchr is called inside create_purgeable_zone() when MallocGuardEdges=1 is\n-  // used.\n-  if (asan_init_is_running) {\n-    return REAL(strchr)(str, c);\n-  }\n-  ENSURE_ASAN_INITED();\n-  char *result = REAL(strchr)(str, c);\n-  if (flags()->replace_str) {\n-    uptr len = REAL(strlen)(str);\n-    uptr bytes_read = (result ? result - str : len) + 1;\n-    ASAN_READ_STRING_OF_LEN(ctx, str, len, bytes_read);\n-  }\n-  return result;\n-}\n-\n #if ASAN_INTERCEPT_INDEX\n # if ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n INTERCEPTOR(char*, index, const char *string, int c)\n@@ -547,7 +548,6 @@ INTERCEPTOR(char*, strcpy, char *to, const char *from) {  // NOLINT\n   return REAL(strcpy)(to, from);  // NOLINT\n }\n \n-#if ASAN_INTERCEPT_STRDUP\n INTERCEPTOR(char*, strdup, const char *s) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, strdup);\n@@ -562,29 +562,28 @@ INTERCEPTOR(char*, strdup, const char *s) {\n   REAL(memcpy)(new_mem, s, length + 1);\n   return reinterpret_cast<char*>(new_mem);\n }\n-#endif\n \n-INTERCEPTOR(SIZE_T, strlen, const char *s) {\n+#if ASAN_INTERCEPT___STRDUP\n+INTERCEPTOR(char*, __strdup, const char *s) {\n   void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, strlen);\n-  if (UNLIKELY(!asan_inited)) return internal_strlen(s);\n-  // strlen is called from malloc_default_purgeable_zone()\n-  // in __asan::ReplaceSystemAlloc() on Mac.\n-  if (asan_init_is_running) {\n-    return REAL(strlen)(s);\n-  }\n+  ASAN_INTERCEPTOR_ENTER(ctx, strdup);\n+  if (UNLIKELY(!asan_inited)) return internal_strdup(s);\n   ENSURE_ASAN_INITED();\n-  SIZE_T length = REAL(strlen)(s);\n+  uptr length = REAL(strlen)(s);\n   if (flags()->replace_str) {\n     ASAN_READ_RANGE(ctx, s, length + 1);\n   }\n-  return length;\n+  GET_STACK_TRACE_MALLOC;\n+  void *new_mem = asan_malloc(length + 1, &stack);\n+  REAL(memcpy)(new_mem, s, length + 1);\n+  return reinterpret_cast<char*>(new_mem);\n }\n+#endif // ASAN_INTERCEPT___STRDUP\n \n INTERCEPTOR(SIZE_T, wcslen, const wchar_t *s) {\n   void *ctx;\n   ASAN_INTERCEPTOR_ENTER(ctx, wcslen);\n-  SIZE_T length = REAL(wcslen)(s);\n+  SIZE_T length = internal_wcslen(s);\n   if (!asan_init_is_running) {\n     ENSURE_ASAN_INITED();\n     ASAN_READ_RANGE(ctx, s, (length + 1) * sizeof(wchar_t));\n@@ -605,19 +604,6 @@ INTERCEPTOR(char*, strncpy, char *to, const char *from, uptr size) {\n   return REAL(strncpy)(to, from, size);\n }\n \n-#if ASAN_INTERCEPT_STRNLEN\n-INTERCEPTOR(uptr, strnlen, const char *s, uptr maxlen) {\n-  void *ctx;\n-  ASAN_INTERCEPTOR_ENTER(ctx, strnlen);\n-  ENSURE_ASAN_INITED();\n-  uptr length = REAL(strnlen)(s, maxlen);\n-  if (flags()->replace_str) {\n-    ASAN_READ_RANGE(ctx, s, Min(length + 1, maxlen));\n-  }\n-  return length;\n-}\n-#endif  // ASAN_INTERCEPT_STRNLEN\n-\n INTERCEPTOR(long, strtol, const char *nptr,  // NOLINT\n             char **endptr, int base) {\n   void *ctx;\n@@ -700,12 +686,12 @@ INTERCEPTOR(long long, atoll, const char *nptr) {  // NOLINT\n }\n #endif  // ASAN_INTERCEPT_ATOLL_AND_STRTOLL\n \n+#if ASAN_INTERCEPT___CXA_ATEXIT\n static void AtCxaAtexit(void *unused) {\n   (void)unused;\n   StopInitOrderChecking();\n }\n \n-#if ASAN_INTERCEPT___CXA_ATEXIT\n INTERCEPTOR(int, __cxa_atexit, void (*func)(void *), void *arg,\n             void *dso_handle) {\n #if SANITIZER_MAC\n@@ -732,30 +718,30 @@ INTERCEPTOR(int, fork, void) {\n namespace __asan {\n void InitializeAsanInterceptors() {\n   static bool was_called_once;\n-  CHECK(was_called_once == false);\n+  CHECK(!was_called_once);\n   was_called_once = true;\n   InitializeCommonInterceptors();\n \n   // Intercept mem* functions.\n   ASAN_INTERCEPT_FUNC(memmove);\n   ASAN_INTERCEPT_FUNC(memset);\n   if (PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE) {\n+    // In asan, REAL(memmove) is not used, but it is used in msan.\n     ASAN_INTERCEPT_FUNC(memcpy);\n+  } else {\n+    ASSIGN_REAL(memcpy, memmove);\n   }\n+  CHECK(REAL(memcpy));\n \n   // Intercept str* functions.\n   ASAN_INTERCEPT_FUNC(strcat);  // NOLINT\n-  ASAN_INTERCEPT_FUNC(strchr);\n   ASAN_INTERCEPT_FUNC(strcpy);  // NOLINT\n-  ASAN_INTERCEPT_FUNC(strlen);\n   ASAN_INTERCEPT_FUNC(wcslen);\n   ASAN_INTERCEPT_FUNC(strncat);\n   ASAN_INTERCEPT_FUNC(strncpy);\n-#if ASAN_INTERCEPT_STRDUP\n   ASAN_INTERCEPT_FUNC(strdup);\n-#endif\n-#if ASAN_INTERCEPT_STRNLEN\n-  ASAN_INTERCEPT_FUNC(strnlen);\n+#if ASAN_INTERCEPT___STRDUP\n+  ASAN_INTERCEPT_FUNC(__strdup);\n #endif\n #if ASAN_INTERCEPT_INDEX && ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX\n   ASAN_INTERCEPT_FUNC(index);"}, {"sha": "7053bb7faf51913a18b590e10278993528ae2b71", "filename": "libsanitizer/asan/asan_interceptors.h", "status": "modified", "additions": 6, "deletions": 8, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interceptors.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -21,14 +21,12 @@\n #if !SANITIZER_WINDOWS\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 1\n # define ASAN_INTERCEPT__LONGJMP 1\n-# define ASAN_INTERCEPT_STRDUP 1\n # define ASAN_INTERCEPT_INDEX 1\n # define ASAN_INTERCEPT_PTHREAD_CREATE 1\n # define ASAN_INTERCEPT_FORK 1\n #else\n # define ASAN_INTERCEPT_ATOLL_AND_STRTOLL 0\n # define ASAN_INTERCEPT__LONGJMP 0\n-# define ASAN_INTERCEPT_STRDUP 0\n # define ASAN_INTERCEPT_INDEX 0\n # define ASAN_INTERCEPT_PTHREAD_CREATE 0\n # define ASAN_INTERCEPT_FORK 0\n@@ -40,12 +38,6 @@\n # define ASAN_USE_ALIAS_ATTRIBUTE_FOR_INDEX 0\n #endif\n \n-#if !SANITIZER_MAC\n-# define ASAN_INTERCEPT_STRNLEN 1\n-#else\n-# define ASAN_INTERCEPT_STRNLEN 0\n-#endif\n-\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n # define ASAN_INTERCEPT_SWAPCONTEXT 1\n #else\n@@ -78,6 +70,12 @@\n # define ASAN_INTERCEPT___CXA_ATEXIT 0\n #endif\n \n+#if SANITIZER_LINUX && !SANITIZER_ANDROID\n+# define ASAN_INTERCEPT___STRDUP 1\n+#else\n+# define ASAN_INTERCEPT___STRDUP 0\n+#endif\n+\n DECLARE_REAL(int, memcmp, const void *a1, const void *a2, uptr size)\n DECLARE_REAL(void*, memcpy, void *to, const void *from, uptr size)\n DECLARE_REAL(void*, memset, void *block, int c, uptr size)"}, {"sha": "05605a8065f0f85bf2a4496302173f12635e348b", "filename": "libsanitizer/asan/asan_interface_internal.h", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_interface_internal.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -21,6 +21,8 @@\n #include \"asan_init_version.h\"\n \n using __sanitizer::uptr;\n+using __sanitizer::u64;\n+using __sanitizer::u32;\n \n extern \"C\" {\n   // This function should be called at the very beginning of the process,\n@@ -52,8 +54,17 @@ extern \"C\" {\n     uptr has_dynamic_init;   // Non-zero if the global has dynamic initializer.\n     __asan_global_source_location *location;  // Source location of a global,\n                                               // or NULL if it is unknown.\n+    uptr odr_indicator;      // The address of the ODR indicator symbol.\n   };\n \n+  // These functions can be called on some platforms to find globals in the same\n+  // loaded image as `flag' and apply __asan_(un)register_globals to them,\n+  // filtering out redundant calls.\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_register_image_globals(uptr *flag);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_unregister_image_globals(uptr *flag);\n+\n   // These two functions should be called by the instrumented code.\n   // 'globals' is an array of structures describing 'n' globals.\n   SANITIZER_INTERFACE_ATTRIBUTE\n@@ -68,6 +79,20 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __asan_after_dynamic_init();\n \n+  // Sets bytes of the given range of the shadow memory into specific value.\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_00(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_f1(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_f2(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_f3(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_f5(uptr addr, uptr size);\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __asan_set_shadow_f8(uptr addr, uptr size);\n+\n   // These two functions are used by instrumented code in the\n   // use-after-scope mode. They mark memory for local variables as\n   // unaddressable when they leave scope and addressable before the\n@@ -145,6 +170,9 @@ extern \"C\" {\n   SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n   /* OPTIONAL */ const char* __asan_default_options();\n \n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  extern uptr __asan_shadow_memory_dynamic_address;\n+\n   // Global flag, copy of ASAN_OPTIONS=detect_stack_use_after_return\n   SANITIZER_INTERFACE_ATTRIBUTE\n   extern int __asan_option_detect_stack_use_after_return;"}, {"sha": "15a28ff777bba7d0e63b29e5e1019ee4de4de2ab", "filename": "libsanitizer/asan/asan_internal.h", "status": "modified", "additions": 27, "deletions": 11, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_internal.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -34,9 +34,9 @@\n // If set, values like allocator chunk size, as well as defaults for some flags\n // will be changed towards less memory overhead.\n #ifndef ASAN_LOW_MEMORY\n-#if SANITIZER_WORDSIZE == 32\n+# if SANITIZER_IOS || (SANITIZER_WORDSIZE == 32)\n #  define ASAN_LOW_MEMORY 1\n-#else\n+# else\n #  define ASAN_LOW_MEMORY 0\n # endif\n #endif\n@@ -60,6 +60,12 @@ using __sanitizer::StackTrace;\n \n void AsanInitFromRtl();\n \n+// asan_win.cc\n+void InitializePlatformExceptionHandlers();\n+\n+// asan_win.cc / asan_posix.cc\n+const char *DescribeSignalOrException(int signo);\n+\n // asan_rtl.cc\n void NORETURN ShowStatsAndAbort();\n \n@@ -71,10 +77,15 @@ void *AsanDoesNotSupportStaticLinkage();\n void AsanCheckDynamicRTPrereqs();\n void AsanCheckIncompatibleRT();\n \n+// Support function for __asan_(un)register_image_globals. Searches for the\n+// loaded image containing `needle' and then enumerates all global metadata\n+// structures declared in that image, applying `op' (e.g.,\n+// __asan_(un)register_globals) to them.\n+typedef void (*globals_op_fptr)(__asan_global *, uptr);\n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle);\n+\n void AsanOnDeadlySignal(int, void *siginfo, void *context);\n \n-void DisableReexec();\n-void MaybeReexec();\n void ReadContextStack(void *context, uptr *stack, uptr *ssize);\n void StopInitOrderChecking();\n \n@@ -95,32 +106,37 @@ void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name);\n bool PlatformHasDifferentMemcpyAndMemmove();\n # define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE \\\n     (PlatformHasDifferentMemcpyAndMemmove())\n+#elif SANITIZER_WINDOWS64\n+# define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE false\n #else\n # define PLATFORM_HAS_DIFFERENT_MEMCPY_AND_MEMMOVE true\n #endif  // SANITIZER_MAC\n \n // Add convenient macro for interface functions that may be represented as\n // weak hooks.\n-#define ASAN_MALLOC_HOOK(ptr, size) \\\n-  if (&__sanitizer_malloc_hook) __sanitizer_malloc_hook(ptr, size)\n-#define ASAN_FREE_HOOK(ptr) \\\n-  if (&__sanitizer_free_hook) __sanitizer_free_hook(ptr)\n+#define ASAN_MALLOC_HOOK(ptr, size)                                   \\\n+  do {                                                                \\\n+    if (&__sanitizer_malloc_hook) __sanitizer_malloc_hook(ptr, size); \\\n+    RunMallocHooks(ptr, size);                                        \\\n+  } while (false)\n+#define ASAN_FREE_HOOK(ptr)                                 \\\n+  do {                                                      \\\n+    if (&__sanitizer_free_hook) __sanitizer_free_hook(ptr); \\\n+    RunFreeHooks(ptr);                                      \\\n+  } while (false)\n #define ASAN_ON_ERROR() \\\n   if (&__asan_on_error) __asan_on_error()\n \n extern int asan_inited;\n // Used to avoid infinite recursion in __asan_init().\n extern bool asan_init_is_running;\n extern void (*death_callback)(void);\n-\n // These magic values are written to shadow for better error reporting.\n const int kAsanHeapLeftRedzoneMagic = 0xfa;\n-const int kAsanHeapRightRedzoneMagic = 0xfb;\n const int kAsanHeapFreeMagic = 0xfd;\n const int kAsanStackLeftRedzoneMagic = 0xf1;\n const int kAsanStackMidRedzoneMagic = 0xf2;\n const int kAsanStackRightRedzoneMagic = 0xf3;\n-const int kAsanStackPartialRedzoneMagic = 0xf4;\n const int kAsanStackAfterReturnMagic = 0xf5;\n const int kAsanInitializationOrderMagic = 0xf6;\n const int kAsanUserPoisonedMemoryMagic = 0xf7;"}, {"sha": "9f058df71a5b604a4414eeb94a88c27d133d0417", "filename": "libsanitizer/asan/asan_linux.cc", "status": "modified", "additions": 5, "deletions": 8, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -67,20 +67,17 @@ asan_rt_version_t  __asan_rt_version;\n namespace __asan {\n \n void InitializePlatformInterceptors() {}\n-\n-void DisableReexec() {\n-  // No need to re-exec on Linux.\n-}\n-\n-void MaybeReexec() {\n-  // No need to re-exec on Linux.\n-}\n+void InitializePlatformExceptionHandlers() {}\n \n void *AsanDoesNotSupportStaticLinkage() {\n   // This will fail to link with -static.\n   return &_DYNAMIC;  // defined in link.h\n }\n \n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n+  UNIMPLEMENTED();\n+}\n+\n #if SANITIZER_ANDROID\n // FIXME: should we do anything for Android?\n void AsanCheckDynamicRTPrereqs() {}"}, {"sha": "4bf79be1728b6e3e6ad8edb9dc39040919775c36", "filename": "libsanitizer/asan/asan_mac.cc", "status": "modified", "additions": 34, "deletions": 184, "changes": 218, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -22,18 +22,11 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mac.h\"\n \n-#if !SANITIZER_IOS\n-#include <crt_externs.h>  // for _NSGetArgv and _NSGetEnviron\n-#else\n-extern \"C\" {\n-  extern char ***_NSGetArgv(void);\n-}\n-#endif\n-\n-#include <dlfcn.h>  // for dladdr()\n+#include <dlfcn.h>\n #include <fcntl.h>\n #include <libkern/OSAtomic.h>\n #include <mach-o/dyld.h>\n+#include <mach-o/getsect.h>\n #include <mach-o/loader.h>\n #include <pthread.h>\n #include <stdlib.h>  // for free()\n@@ -43,193 +36,26 @@ extern \"C\" {\n #include <sys/ucontext.h>\n #include <unistd.h>\n \n+// from <crt_externs.h>, but we don't have that file on iOS\n+extern \"C\" {\n+  extern char ***_NSGetArgv(void);\n+  extern char ***_NSGetEnviron(void);\n+}\n+\n namespace __asan {\n \n void InitializePlatformInterceptors() {}\n+void InitializePlatformExceptionHandlers() {}\n \n bool PlatformHasDifferentMemcpyAndMemmove() {\n   // On OS X 10.7 memcpy() and memmove() are both resolved\n   // into memmove$VARIANT$sse42.\n-  // See also http://code.google.com/p/address-sanitizer/issues/detail?id=34.\n+  // See also https://github.com/google/sanitizers/issues/34.\n   // TODO(glider): need to check dynamically that memcpy() and memmove() are\n   // actually the same function.\n   return GetMacosVersion() == MACOS_VERSION_SNOW_LEOPARD;\n }\n \n-extern \"C\"\n-void __asan_init();\n-\n-static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n-LowLevelAllocator allocator_for_env;\n-\n-// Change the value of the env var |name|, leaking the original value.\n-// If |name_value| is NULL, the variable is deleted from the environment,\n-// otherwise the corresponding \"NAME=value\" string is replaced with\n-// |name_value|.\n-void LeakyResetEnv(const char *name, const char *name_value) {\n-  char **env = GetEnviron();\n-  uptr name_len = internal_strlen(name);\n-  while (*env != 0) {\n-    uptr len = internal_strlen(*env);\n-    if (len > name_len) {\n-      const char *p = *env;\n-      if (!internal_memcmp(p, name, name_len) && p[name_len] == '=') {\n-        // Match.\n-        if (name_value) {\n-          // Replace the old value with the new one.\n-          *env = const_cast<char*>(name_value);\n-        } else {\n-          // Shift the subsequent pointers back.\n-          char **del = env;\n-          do {\n-            del[0] = del[1];\n-          } while (*del++);\n-        }\n-      }\n-    }\n-    env++;\n-  }\n-}\n-\n-static bool reexec_disabled = false;\n-\n-void DisableReexec() {\n-  reexec_disabled = true;\n-}\n-\n-extern \"C\" SANITIZER_WEAK_ATTRIBUTE double dyldVersionNumber;\n-static const double kMinDyldVersionWithAutoInterposition = 360.0;\n-\n-bool DyldNeedsEnvVariable() {\n-  // Although sanitizer support was added to LLVM on OS X 10.7+, GCC users\n-  // still may want use them on older systems. On older Darwin platforms, dyld\n-  // doesn't export dyldVersionNumber symbol and we simply return true.\n-  if (!&dyldVersionNumber) return true;\n-  // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n-  // DYLD_INSERT_LIBRARIES is not set. However, checking OS version via\n-  // GetMacosVersion() doesn't work for the simulator. Let's instead check\n-  // `dyldVersionNumber`, which is exported by dyld, against a known version\n-  // number from the first OS release where this appeared.\n-  return dyldVersionNumber < kMinDyldVersionWithAutoInterposition;\n-}\n-\n-void MaybeReexec() {\n-  if (reexec_disabled) return;\n-\n-  // Make sure the dynamic ASan runtime library is preloaded so that the\n-  // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n-  // ourselves.\n-  Dl_info info;\n-  CHECK(dladdr((void*)((uptr)__asan_init), &info));\n-  char *dyld_insert_libraries =\n-      const_cast<char*>(GetEnv(kDyldInsertLibraries));\n-  uptr old_env_len = dyld_insert_libraries ?\n-      internal_strlen(dyld_insert_libraries) : 0;\n-  uptr fname_len = internal_strlen(info.dli_fname);\n-  const char *dylib_name = StripModuleName(info.dli_fname);\n-  uptr dylib_name_len = internal_strlen(dylib_name);\n-\n-  bool lib_is_in_env =\n-      dyld_insert_libraries && REAL(strstr)(dyld_insert_libraries, dylib_name);\n-  if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n-    // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n-    // library.\n-    char program_name[1024];\n-    uint32_t buf_size = sizeof(program_name);\n-    _NSGetExecutablePath(program_name, &buf_size);\n-    char *new_env = const_cast<char*>(info.dli_fname);\n-    if (dyld_insert_libraries) {\n-      // Append the runtime dylib name to the existing value of\n-      // DYLD_INSERT_LIBRARIES.\n-      new_env = (char*)allocator_for_env.Allocate(old_env_len + fname_len + 2);\n-      internal_strncpy(new_env, dyld_insert_libraries, old_env_len);\n-      new_env[old_env_len] = ':';\n-      // Copy fname_len and add a trailing zero.\n-      internal_strncpy(new_env + old_env_len + 1, info.dli_fname,\n-                       fname_len + 1);\n-      // Ok to use setenv() since the wrappers don't depend on the value of\n-      // asan_inited.\n-      setenv(kDyldInsertLibraries, new_env, /*overwrite*/1);\n-    } else {\n-      // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n-      setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n-    }\n-    VReport(1, \"exec()-ing the program with\\n\");\n-    VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n-    VReport(1, \"to enable ASan wrappers.\\n\");\n-    execv(program_name, *_NSGetArgv());\n-\n-    // We get here only if execv() failed.\n-    Report(\"ERROR: The process is launched without DYLD_INSERT_LIBRARIES, \"\n-           \"which is required for ASan to work. ASan tried to set the \"\n-           \"environment variable and re-execute itself, but execv() failed, \"\n-           \"possibly because of sandbox restrictions. Make sure to launch the \"\n-           \"executable with:\\n%s=%s\\n\", kDyldInsertLibraries, new_env);\n-    CHECK(\"execv failed\" && 0);\n-  }\n-\n-  if (!lib_is_in_env)\n-    return;\n-\n-  // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n-  // the dylib from the environment variable, because interceptors are installed\n-  // and we don't want our children to inherit the variable.\n-\n-  uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n-  // Allocate memory to hold the previous env var name, its value, the '='\n-  // sign and the '\\0' char.\n-  char *new_env = (char*)allocator_for_env.Allocate(\n-      old_env_len + 2 + env_name_len);\n-  CHECK(new_env);\n-  internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n-  internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n-  new_env[env_name_len] = '=';\n-  char *new_env_pos = new_env + env_name_len + 1;\n-\n-  // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n-  char *piece_start = dyld_insert_libraries;\n-  char *piece_end = NULL;\n-  char *old_env_end = dyld_insert_libraries + old_env_len;\n-  do {\n-    if (piece_start[0] == ':') piece_start++;\n-    piece_end = REAL(strchr)(piece_start, ':');\n-    if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n-    if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n-    uptr piece_len = piece_end - piece_start;\n-\n-    char *filename_start =\n-        (char *)internal_memrchr(piece_start, '/', piece_len);\n-    uptr filename_len = piece_len;\n-    if (filename_start) {\n-      filename_start += 1;\n-      filename_len = piece_len - (filename_start - piece_start);\n-    } else {\n-      filename_start = piece_start;\n-    }\n-\n-    // If the current piece isn't the runtime library name,\n-    // append it to new_env.\n-    if ((dylib_name_len != filename_len) ||\n-        (internal_memcmp(filename_start, dylib_name, dylib_name_len) != 0)) {\n-      if (new_env_pos != new_env + env_name_len + 1) {\n-        new_env_pos[0] = ':';\n-        new_env_pos++;\n-      }\n-      internal_strncpy(new_env_pos, piece_start, piece_len);\n-      new_env_pos += piece_len;\n-    }\n-    // Move on to the next piece.\n-    piece_start = piece_end;\n-  } while (piece_start < old_env_end);\n-\n-  // Can't use setenv() here, because it requires the allocator to be\n-  // initialized.\n-  // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n-  // a separate function called after InitializeAllocator().\n-  if (new_env_pos == new_env + env_name_len + 1) new_env = NULL;\n-  LeakyResetEnv(kDyldInsertLibraries, new_env);\n-}\n-\n // No-op. Mac does not support static linkage anyway.\n void *AsanDoesNotSupportStaticLinkage() {\n   return 0;\n@@ -241,6 +67,30 @@ void AsanCheckDynamicRTPrereqs() {}\n // No-op. Mac does not support static linkage anyway.\n void AsanCheckIncompatibleRT() {}\n \n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n+  // Find the Mach-O header for the image containing the needle\n+  Dl_info info;\n+  int err = dladdr(needle, &info);\n+  if (err == 0) return;\n+\n+#if __LP64__\n+  const struct mach_header_64 *mh = (struct mach_header_64 *)info.dli_fbase;\n+#else\n+  const struct mach_header *mh = (struct mach_header *)info.dli_fbase;\n+#endif\n+\n+  // Look up the __asan_globals section in that image and register its globals\n+  unsigned long size = 0;\n+  __asan_global *globals = (__asan_global *)getsectiondata(\n+      mh,\n+      \"__DATA\", \"__asan_globals\",\n+      &size);\n+\n+  if (!globals) return;\n+  if (size % sizeof(__asan_global) != 0) return;\n+  op(globals, size / sizeof(__asan_global));\n+}\n+\n void ReadContextStack(void *context, uptr *stack, uptr *ssize) {\n   UNIMPLEMENTED();\n }"}, {"sha": "cc50a388495f58e5b851c5d9a3f0483432288654", "filename": "libsanitizer/asan/asan_malloc_linux.cc", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -76,7 +76,13 @@ INTERCEPTOR(void*, realloc, void *ptr, uptr size) {\n   if (UNLIKELY(IsInDlsymAllocPool(ptr))) {\n     uptr offset = (uptr)ptr - (uptr)alloc_memory_for_dlsym;\n     uptr copy_size = Min(size, kDlsymAllocPoolSize - offset);\n-    void *new_ptr = asan_malloc(size, &stack);\n+    void *new_ptr;\n+    if (UNLIKELY(!asan_inited)) {\n+      new_ptr = AllocateFromLocalPool(size);\n+    } else {\n+      copy_size = size;\n+      new_ptr = asan_malloc(copy_size, &stack);\n+    }\n     internal_memcpy(new_ptr, ptr, copy_size);\n     return new_ptr;\n   }\n@@ -96,7 +102,7 @@ INTERCEPTOR(void*, aligned_alloc, uptr boundary, uptr size) {\n INTERCEPTOR(void*, __libc_memalign, uptr boundary, uptr size) {\n   GET_STACK_TRACE_MALLOC;\n   void *res = asan_memalign(boundary, size, &stack, FROM_MALLOC);\n-  DTLS_on_libc_memalign(res, size * boundary);\n+  DTLS_on_libc_memalign(res, size);\n   return res;\n }\n "}, {"sha": "1ca665d84c5b8dd9068450702fe480c5596d4dde", "filename": "libsanitizer/asan/asan_malloc_mac.cc", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -52,10 +52,6 @@ using namespace __asan;\n #define COMMON_MALLOC_REPORT_UNKNOWN_REALLOC(ptr, zone_ptr, zone_name) \\\n   GET_STACK_TRACE_FREE; \\\n   ReportMacMzReallocUnknown((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n-#define COMMON_MALLOC_IGNORE_INVALID_FREE flags()->mac_ignore_invalid_free\n-#define COMMON_MALLOC_REPORT_FREE_UNALLOCATED(ptr, zone_ptr, zone_name) \\\n-  GET_STACK_TRACE_FREE; \\\n-  WarnMacFreeUnallocated((uptr)ptr, (uptr)zone_ptr, zone_name, &stack);\n #define COMMON_MALLOC_NAMESPACE __asan\n \n #include \"sanitizer_common/sanitizer_malloc_mac.inc\""}, {"sha": "f38cd054bb077fa9a780b0633d887cdf371197be", "filename": "libsanitizer/asan/asan_malloc_win.cc", "status": "modified", "additions": 109, "deletions": 30, "changes": 139, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_malloc_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_malloc_win.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -12,6 +12,8 @@\n \n #include \"sanitizer_common/sanitizer_platform.h\"\n #if SANITIZER_WINDOWS\n+#define WIN32_LEAN_AND_MEAN\n+#include <windows.h>\n \n #include \"asan_allocator.h\"\n #include \"asan_interceptors.h\"\n@@ -46,6 +48,11 @@ void _free_dbg(void *ptr, int) {\n   free(ptr);\n }\n \n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void _free_base(void *ptr) {\n+  free(ptr);\n+}\n+\n ALLOCATION_FUNCTION_ATTRIBUTE\n void cfree(void *ptr) {\n   CHECK(!\"cfree() should not be used on Windows\");\n@@ -57,6 +64,11 @@ void *malloc(size_t size) {\n   return asan_malloc(size, &stack);\n }\n \n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_malloc_base(size_t size) {\n+  return malloc(size);\n+}\n+\n ALLOCATION_FUNCTION_ATTRIBUTE\n void *_malloc_dbg(size_t size, int, const char *, int) {\n   return malloc(size);\n@@ -68,6 +80,11 @@ void *calloc(size_t nmemb, size_t size) {\n   return asan_calloc(nmemb, size, &stack);\n }\n \n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_calloc_base(size_t nmemb, size_t size) {\n+  return calloc(nmemb, size);\n+}\n+\n ALLOCATION_FUNCTION_ATTRIBUTE\n void *_calloc_dbg(size_t nmemb, size_t size, int, const char *, int) {\n   return calloc(nmemb, size);\n@@ -90,6 +107,11 @@ void *_realloc_dbg(void *ptr, size_t size, int) {\n   return 0;\n }\n \n+ALLOCATION_FUNCTION_ATTRIBUTE\n+void *_realloc_base(void *ptr, size_t size) {\n+  return realloc(ptr, size);\n+}\n+\n ALLOCATION_FUNCTION_ATTRIBUTE\n void *_recalloc(void *p, size_t n, size_t elem_size) {\n   if (!p)\n@@ -101,7 +123,12 @@ void *_recalloc(void *p, size_t n, size_t elem_size) {\n }\n \n ALLOCATION_FUNCTION_ATTRIBUTE\n-size_t _msize(void *ptr) {\n+void *_recalloc_base(void *p, size_t n, size_t elem_size) {\n+  return _recalloc(p, n, elem_size);\n+}\n+\n+ALLOCATION_FUNCTION_ATTRIBUTE\n+size_t _msize(const void *ptr) {\n   GET_CURRENT_PC_BP_SP;\n   (void)sp;\n   return asan_malloc_usable_size(ptr, pc, bp);\n@@ -137,38 +164,90 @@ int _CrtSetReportMode(int, int) {\n }\n }  // extern \"C\"\n \n+INTERCEPTOR_WINAPI(LPVOID, HeapAlloc, HANDLE hHeap, DWORD dwFlags,\n+                   SIZE_T dwBytes) {\n+  GET_STACK_TRACE_MALLOC;\n+  void *p = asan_malloc(dwBytes, &stack);\n+  // Reading MSDN suggests that the *entire* usable allocation is zeroed out.\n+  // Otherwise it is difficult to HeapReAlloc with HEAP_ZERO_MEMORY.\n+  // https://blogs.msdn.microsoft.com/oldnewthing/20120316-00/?p=8083\n+  if (dwFlags == HEAP_ZERO_MEMORY)\n+    internal_memset(p, 0, asan_mz_size(p));\n+  else\n+    CHECK(dwFlags == 0 && \"unsupported heap flags\");\n+  return p;\n+}\n+\n+INTERCEPTOR_WINAPI(BOOL, HeapFree, HANDLE hHeap, DWORD dwFlags, LPVOID lpMem) {\n+  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n+  GET_STACK_TRACE_FREE;\n+  asan_free(lpMem, &stack, FROM_MALLOC);\n+  return true;\n+}\n+\n+INTERCEPTOR_WINAPI(LPVOID, HeapReAlloc, HANDLE hHeap, DWORD dwFlags,\n+                   LPVOID lpMem, SIZE_T dwBytes) {\n+  GET_STACK_TRACE_MALLOC;\n+  // Realloc should never reallocate in place.\n+  if (dwFlags & HEAP_REALLOC_IN_PLACE_ONLY)\n+    return nullptr;\n+  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n+  return asan_realloc(lpMem, dwBytes, &stack);\n+}\n+\n+INTERCEPTOR_WINAPI(SIZE_T, HeapSize, HANDLE hHeap, DWORD dwFlags,\n+                   LPCVOID lpMem) {\n+  CHECK(dwFlags == 0 && \"unsupported heap flags\");\n+  GET_CURRENT_PC_BP_SP;\n+  (void)sp;\n+  return asan_malloc_usable_size(lpMem, pc, bp);\n+}\n+\n namespace __asan {\n+\n+static void TryToOverrideFunction(const char *fname, uptr new_func) {\n+  // Failure here is not fatal. The CRT may not be present, and different CRT\n+  // versions use different symbols.\n+  if (!__interception::OverrideFunction(fname, new_func))\n+    VPrintf(2, \"Failed to override function %s\\n\", fname);\n+}\n+\n void ReplaceSystemMalloc() {\n #if defined(ASAN_DYNAMIC)\n-  // We don't check the result because CRT might not be used in the process.\n-  __interception::OverrideFunction(\"free\", (uptr)free);\n-  __interception::OverrideFunction(\"malloc\", (uptr)malloc);\n-  __interception::OverrideFunction(\"_malloc_crt\", (uptr)malloc);\n-  __interception::OverrideFunction(\"calloc\", (uptr)calloc);\n-  __interception::OverrideFunction(\"_calloc_crt\", (uptr)calloc);\n-  __interception::OverrideFunction(\"realloc\", (uptr)realloc);\n-  __interception::OverrideFunction(\"_realloc_crt\", (uptr)realloc);\n-  __interception::OverrideFunction(\"_recalloc\", (uptr)_recalloc);\n-  __interception::OverrideFunction(\"_recalloc_crt\", (uptr)_recalloc);\n-  __interception::OverrideFunction(\"_msize\", (uptr)_msize);\n-  __interception::OverrideFunction(\"_expand\", (uptr)_expand);\n-\n-  // Override different versions of 'operator new' and 'operator delete'.\n-  // No need to override the nothrow versions as they just wrap the throw\n-  // versions.\n-  // FIXME: Unfortunately, MSVC miscompiles the statements that take the\n-  // addresses of the array versions of these operators,\n-  // see https://connect.microsoft.com/VisualStudio/feedbackdetail/view/946992\n-  // We might want to try to work around this by [inline] assembly or compiling\n-  // parts of the RTL with Clang.\n-  void *(*op_new)(size_t sz) = operator new;\n-  void (*op_delete)(void *p) = operator delete;\n-  void *(*op_array_new)(size_t sz) = operator new[];\n-  void (*op_array_delete)(void *p) = operator delete[];\n-  __interception::OverrideFunction(\"??2@YAPAXI@Z\", (uptr)op_new);\n-  __interception::OverrideFunction(\"??3@YAXPAX@Z\", (uptr)op_delete);\n-  __interception::OverrideFunction(\"??_U@YAPAXI@Z\", (uptr)op_array_new);\n-  __interception::OverrideFunction(\"??_V@YAXPAX@Z\", (uptr)op_array_delete);\n+  TryToOverrideFunction(\"free\", (uptr)free);\n+  TryToOverrideFunction(\"_free_base\", (uptr)free);\n+  TryToOverrideFunction(\"malloc\", (uptr)malloc);\n+  TryToOverrideFunction(\"_malloc_base\", (uptr)malloc);\n+  TryToOverrideFunction(\"_malloc_crt\", (uptr)malloc);\n+  TryToOverrideFunction(\"calloc\", (uptr)calloc);\n+  TryToOverrideFunction(\"_calloc_base\", (uptr)calloc);\n+  TryToOverrideFunction(\"_calloc_crt\", (uptr)calloc);\n+  TryToOverrideFunction(\"realloc\", (uptr)realloc);\n+  TryToOverrideFunction(\"_realloc_base\", (uptr)realloc);\n+  TryToOverrideFunction(\"_realloc_crt\", (uptr)realloc);\n+  TryToOverrideFunction(\"_recalloc\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_recalloc_base\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_recalloc_crt\", (uptr)_recalloc);\n+  TryToOverrideFunction(\"_msize\", (uptr)_msize);\n+  TryToOverrideFunction(\"_expand\", (uptr)_expand);\n+  TryToOverrideFunction(\"_expand_base\", (uptr)_expand);\n+\n+  // Recent versions of ucrtbase.dll appear to be built with PGO and LTCG, which\n+  // enable cross-module inlining. This means our _malloc_base hook won't catch\n+  // all CRT allocations. This code here patches the import table of\n+  // ucrtbase.dll so that all attempts to use the lower-level win32 heap\n+  // allocation API will be directed to ASan's heap. We don't currently\n+  // intercept all calls to HeapAlloc. If we did, we would have to check on\n+  // HeapFree whether the pointer came from ASan of from the system.\n+#define INTERCEPT_UCRT_FUNCTION(func)                                         \\\n+  if (!INTERCEPT_FUNCTION_DLLIMPORT(\"ucrtbase.dll\",                           \\\n+                                    \"api-ms-win-core-heap-l1-1-0.dll\", func)) \\\n+    VPrintf(2, \"Failed to intercept ucrtbase.dll import %s\\n\", #func);\n+  INTERCEPT_UCRT_FUNCTION(HeapAlloc);\n+  INTERCEPT_UCRT_FUNCTION(HeapFree);\n+  INTERCEPT_UCRT_FUNCTION(HeapReAlloc);\n+  INTERCEPT_UCRT_FUNCTION(HeapSize);\n+#undef INTERCEPT_UCRT_FUNCTION\n #endif\n }\n }  // namespace __asan"}, {"sha": "b9fa5f79481734fa879a7fc5055e706a05deda78", "filename": "libsanitizer/asan/asan_mapping.h", "status": "modified", "additions": 51, "deletions": 26, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_mapping.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_mapping.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_mapping.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -15,7 +15,7 @@\n #include \"asan_internal.h\"\n \n // The full explanation of the memory mapping could be found here:\n-// http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm\n+// https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm\n //\n // Typical shadow mapping on Linux/x86_64 with SHADOW_OFFSET == 0x00007fff8000:\n // || `[0x10007fff8000, 0x7fffffffffff]` || HighMem    ||\n@@ -85,6 +85,20 @@\n // || `[0x08000000000, 0x08fffffffff]` || lowshadow  ||\n // || `[0x00000000000, 0x07fffffffff]` || lowmem     ||\n //\n+// Default Linux/S390 mapping:\n+// || `[0x30000000, 0x7fffffff]` || HighMem    ||\n+// || `[0x26000000, 0x2fffffff]` || HighShadow ||\n+// || `[0x24000000, 0x25ffffff]` || ShadowGap  ||\n+// || `[0x20000000, 0x23ffffff]` || LowShadow  ||\n+// || `[0x00000000, 0x1fffffff]` || LowMem     ||\n+//\n+// Default Linux/SystemZ mapping:\n+// || `[0x14000000000000, 0x1fffffffffffff]` || HighMem    ||\n+// || `[0x12800000000000, 0x13ffffffffffff]` || HighShadow ||\n+// || `[0x12000000000000, 0x127fffffffffff]` || ShadowGap  ||\n+// || `[0x10000000000000, 0x11ffffffffffff]` || LowShadow  ||\n+// || `[0x00000000000000, 0x0fffffffffffff]` || LowMem     ||\n+//\n // Shadow mapping on FreeBSD/x86-64 with SHADOW_OFFSET == 0x400000000000:\n // || `[0x500000000000, 0x7fffffffffff]` || HighMem    ||\n // || `[0x4a0000000000, 0x4fffffffffff]` || HighShadow ||\n@@ -109,17 +123,19 @@\n // || `[0x00000000, 0x2fffffff]` || LowMem     ||\n \n static const u64 kDefaultShadowScale = 3;\n+static const u64 kDefaultShadowSentinel = ~(uptr)0;\n static const u64 kDefaultShadowOffset32 = 1ULL << 29;  // 0x20000000\n static const u64 kDefaultShadowOffset64 = 1ULL << 44;\n static const u64 kDefaultShort64bitShadowOffset = 0x7FFF8000;  // < 2G.\n static const u64 kIosShadowOffset32 = 1ULL << 30;  // 0x40000000\n-static const u64 kIosShadowOffset64 = 0x130000000;\n+static const u64 kIosShadowOffset64 = 0x120200000;\n static const u64 kIosSimShadowOffset32 = 1ULL << 30;\n static const u64 kIosSimShadowOffset64 = kDefaultShadowOffset64;\n static const u64 kAArch64_ShadowOffset64 = 1ULL << 36;\n static const u64 kMIPS32_ShadowOffset32 = 0x0aaa0000;\n static const u64 kMIPS64_ShadowOffset64 = 1ULL << 37;\n static const u64 kPPC64_ShadowOffset64 = 1ULL << 41;\n+static const u64 kSystemZ_ShadowOffset64 = 1ULL << 52;\n static const u64 kFreeBSD_ShadowOffset32 = 1ULL << 30;  // 0x40000000\n static const u64 kFreeBSD_ShadowOffset64 = 1ULL << 46;  // 0x400000000000\n static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n@@ -136,28 +152,36 @@ static const u64 kWindowsShadowOffset32 = 3ULL << 28;  // 0x30000000\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset32\n #  elif SANITIZER_WINDOWS\n #    define SHADOW_OFFSET kWindowsShadowOffset32\n-#  elif SANITIZER_IOSSIM\n-#    define SHADOW_OFFSET kIosSimShadowOffset32\n #  elif SANITIZER_IOS\n-#    define SHADOW_OFFSET kIosShadowOffset32\n+#    if SANITIZER_IOSSIM\n+#      define SHADOW_OFFSET kIosSimShadowOffset32\n+#    else\n+#      define SHADOW_OFFSET kIosShadowOffset32\n+#    endif\n #  else\n #    define SHADOW_OFFSET kDefaultShadowOffset32\n #  endif\n #else\n-#  if defined(__aarch64__)\n+#  if SANITIZER_IOS\n+#    if SANITIZER_IOSSIM\n+#      define SHADOW_OFFSET kIosSimShadowOffset64\n+#    else\n+#      define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n+#    endif\n+#  elif defined(__aarch64__)\n #    define SHADOW_OFFSET kAArch64_ShadowOffset64\n #  elif defined(__powerpc64__)\n #    define SHADOW_OFFSET kPPC64_ShadowOffset64\n+#  elif defined(__s390x__)\n+#    define SHADOW_OFFSET kSystemZ_ShadowOffset64\n #  elif SANITIZER_FREEBSD\n #    define SHADOW_OFFSET kFreeBSD_ShadowOffset64\n #  elif SANITIZER_MAC\n #   define SHADOW_OFFSET kDefaultShadowOffset64\n #  elif defined(__mips64)\n #   define SHADOW_OFFSET kMIPS64_ShadowOffset64\n-#  elif SANITIZER_IOSSIM\n-#    define SHADOW_OFFSET kIosSimShadowOffset64\n-#  elif SANITIZER_IOS\n-#    define SHADOW_OFFSET kIosShadowOffset64\n+#  elif SANITIZER_WINDOWS64\n+#   define SHADOW_OFFSET __asan_shadow_memory_dynamic_address\n #  else\n #   define SHADOW_OFFSET kDefaultShort64bitShadowOffset\n #  endif\n@@ -243,9 +267,25 @@ static inline bool AddrIsInMidMem(uptr a) {\n   return kMidMemBeg && a >= kMidMemBeg && a <= kMidMemEnd;\n }\n \n+static inline bool AddrIsInShadowGap(uptr a) {\n+  PROFILE_ASAN_MAPPING();\n+  if (kMidMemBeg) {\n+    if (a <= kShadowGapEnd)\n+      return SHADOW_OFFSET == 0 || a >= kShadowGapBeg;\n+    return (a >= kShadowGap2Beg && a <= kShadowGap2End) ||\n+           (a >= kShadowGap3Beg && a <= kShadowGap3End);\n+  }\n+  // In zero-based shadow mode we treat addresses near zero as addresses\n+  // in shadow gap as well.\n+  if (SHADOW_OFFSET == 0)\n+    return a <= kShadowGapEnd;\n+  return a >= kShadowGapBeg && a <= kShadowGapEnd;\n+}\n+\n static inline bool AddrIsInMem(uptr a) {\n   PROFILE_ASAN_MAPPING();\n-  return AddrIsInLowMem(a) || AddrIsInMidMem(a) || AddrIsInHighMem(a);\n+  return AddrIsInLowMem(a) || AddrIsInMidMem(a) || AddrIsInHighMem(a) ||\n+      (flags()->protect_shadow_gap == 0 && AddrIsInShadowGap(a));\n }\n \n static inline uptr MemToShadow(uptr p) {\n@@ -269,21 +309,6 @@ static inline bool AddrIsInShadow(uptr a) {\n   return AddrIsInLowShadow(a) || AddrIsInMidShadow(a) || AddrIsInHighShadow(a);\n }\n \n-static inline bool AddrIsInShadowGap(uptr a) {\n-  PROFILE_ASAN_MAPPING();\n-  if (kMidMemBeg) {\n-    if (a <= kShadowGapEnd)\n-      return SHADOW_OFFSET == 0 || a >= kShadowGapBeg;\n-    return (a >= kShadowGap2Beg && a <= kShadowGap2End) ||\n-           (a >= kShadowGap3Beg && a <= kShadowGap3End);\n-  }\n-  // In zero-based shadow mode we treat addresses near zero as addresses\n-  // in shadow gap as well.\n-  if (SHADOW_OFFSET == 0)\n-    return a <= kShadowGapEnd;\n-  return a >= kShadowGapBeg && a <= kShadowGapEnd;\n-}\n-\n static inline bool AddrIsAlignedByGranularity(uptr a) {\n   PROFILE_ASAN_MAPPING();\n   return (a & (SHADOW_GRANULARITY - 1)) == 0;"}, {"sha": "5a2578596ad365796c091a478e354ce9865a8a77", "filename": "libsanitizer/asan/asan_memory_profile.cc", "status": "added", "additions": 98, "deletions": 0, "changes": 98, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_memory_profile.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_memory_profile.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,98 @@\n+//===-- asan_memory_profile.cc.cc -----------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// This file implements __sanitizer_print_memory_profile.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_stackdepot.h\"\n+#include \"sanitizer_common/sanitizer_stacktrace.h\"\n+#include \"sanitizer_common/sanitizer_stoptheworld.h\"\n+#include \"lsan/lsan_common.h\"\n+#include \"asan/asan_allocator.h\"\n+\n+#if CAN_SANITIZE_LEAKS\n+\n+namespace __asan {\n+\n+struct AllocationSite {\n+  u32 id;\n+  uptr total_size;\n+  uptr count;\n+};\n+\n+class HeapProfile {\n+ public:\n+  HeapProfile() : allocations_(1024) {}\n+  void Insert(u32 id, uptr size) {\n+    total_allocated_ += size;\n+    total_count_++;\n+    // Linear lookup will be good enough for most cases (although not all).\n+    for (uptr i = 0; i < allocations_.size(); i++) {\n+      if (allocations_[i].id == id) {\n+        allocations_[i].total_size += size;\n+        allocations_[i].count++;\n+        return;\n+      }\n+    }\n+    allocations_.push_back({id, size, 1});\n+  }\n+\n+  void Print(uptr top_percent) {\n+    InternalSort(&allocations_, allocations_.size(),\n+                 [](const AllocationSite &a, const AllocationSite &b) {\n+                   return a.total_size > b.total_size;\n+                 });\n+    CHECK(total_allocated_);\n+    uptr total_shown = 0;\n+    Printf(\"Live Heap Allocations: %zd bytes from %zd allocations; \"\n+           \"showing top %zd%%\\n\", total_allocated_, total_count_, top_percent);\n+    for (uptr i = 0; i < allocations_.size(); i++) {\n+      auto &a = allocations_[i];\n+      Printf(\"%zd byte(s) (%zd%%) in %zd allocation(s)\\n\", a.total_size,\n+             a.total_size * 100 / total_allocated_, a.count);\n+      StackDepotGet(a.id).Print();\n+      total_shown += a.total_size;\n+      if (total_shown * 100 / total_allocated_ > top_percent)\n+        break;\n+    }\n+  }\n+\n+ private:\n+  uptr total_allocated_ = 0;\n+  uptr total_count_ = 0;\n+  InternalMmapVector<AllocationSite> allocations_;\n+};\n+\n+static void ChunkCallback(uptr chunk, void *arg) {\n+  HeapProfile *hp = reinterpret_cast<HeapProfile*>(arg);\n+  AsanChunkView cv = FindHeapChunkByAllocBeg(chunk);\n+  if (!cv.IsAllocated()) return;\n+  u32 id = cv.GetAllocStackId();\n+  if (!id) return;\n+  hp->Insert(id, cv.UsedSize());\n+}\n+\n+static void MemoryProfileCB(const SuspendedThreadsList &suspended_threads_list,\n+                            void *argument) {\n+  HeapProfile hp;\n+  __lsan::ForEachChunk(ChunkCallback, &hp);\n+  hp.Print(reinterpret_cast<uptr>(argument));\n+}\n+\n+}  // namespace __asan\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_print_memory_profile(uptr top_percent) {\n+  __sanitizer::StopTheWorld(__asan::MemoryProfileCB, (void*)top_percent);\n+}\n+}  // extern \"C\"\n+\n+#endif  // CAN_SANITIZE_LEAKS"}, {"sha": "2c4642cb27e5678f5f4bef361dbb1dab68df774a", "filename": "libsanitizer/asan/asan_new_delete.cc", "status": "modified", "additions": 18, "deletions": 2, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_new_delete.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -18,9 +18,25 @@\n \n #include <stddef.h>\n \n-// C++ operators can't have visibility attributes on Windows.\n+// C++ operators can't have dllexport attributes on Windows. We export them\n+// anyway by passing extra -export flags to the linker, which is exactly that\n+// dllexport would normally do. We need to export them in order to make the\n+// VS2015 dynamic CRT (MD) work.\n #if SANITIZER_WINDOWS\n # define CXX_OPERATOR_ATTRIBUTE\n+# ifdef _WIN64\n+#  pragma comment(linker, \"/export:??2@YAPEAX_K@Z\")   // operator new\n+#  pragma comment(linker, \"/export:??3@YAXPEAX@Z\")    // operator delete\n+#  pragma comment(linker, \"/export:??3@YAXPEAX_K@Z\")  // sized operator delete\n+#  pragma comment(linker, \"/export:??_U@YAPEAX_K@Z\")  // operator new[]\n+#  pragma comment(linker, \"/export:??_V@YAXPEAX@Z\")   // operator delete[]\n+# else\n+#  pragma comment(linker, \"/export:??2@YAPAXI@Z\")   // operator new\n+#  pragma comment(linker, \"/export:??3@YAXPAX@Z\")   // operator delete\n+#  pragma comment(linker, \"/export:??3@YAXPAXI@Z\")  // sized operator delete\n+#  pragma comment(linker, \"/export:??_U@YAPAXI@Z\")  // operator new[]\n+#  pragma comment(linker, \"/export:??_V@YAXPAX@Z\")  // operator delete[]\n+# endif\n #else\n # define CXX_OPERATOR_ATTRIBUTE INTERCEPTOR_ATTRIBUTE\n #endif\n@@ -37,7 +53,7 @@ using namespace __asan;  // NOLINT\n #endif  // SANITIZER_FREEBSD && SANITIZER_WORDSIZE == 32\n \n // This code has issues on OSX.\n-// See https://code.google.com/p/address-sanitizer/issues/detail?id=131.\n+// See https://github.com/google/sanitizers/issues/131.\n \n // Fake std::nothrow_t and std::align_val_t to avoid including <new>.\n namespace std {"}, {"sha": "8fe2bd42bdbd6e123dc1e0329303f70cab20042b", "filename": "libsanitizer/asan/asan_poisoning.cc", "status": "modified", "additions": 34, "deletions": 10, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_poisoning.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_poisoning.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -67,7 +67,7 @@ void FlushUnneededASanShadowMemory(uptr p, uptr size) {\n     uptr page_size = GetPageSizeCached();\n     uptr shadow_beg = RoundUpTo(MemToShadow(p), page_size);\n     uptr shadow_end = RoundDownTo(MemToShadow(p + size), page_size);\n-    FlushUnneededShadowMemory(shadow_beg, shadow_end - shadow_beg);\n+    ReleaseMemoryToOS(shadow_beg, shadow_end - shadow_beg);\n }\n \n void AsanPoisonOrUnpoisonIntraObjectRedzone(uptr ptr, uptr size, bool poison) {\n@@ -100,7 +100,7 @@ using namespace __asan;  // NOLINT\n // that user program (un)poisons the memory it owns. It poisons memory\n // conservatively, and unpoisons progressively to make sure asan shadow\n // mapping invariant is preserved (see detailed mapping description here:\n-// http://code.google.com/p/address-sanitizer/wiki/AddressSanitizerAlgorithm).\n+// https://github.com/google/sanitizers/wiki/AddressSanitizerAlgorithm).\n //\n // * if user asks to poison region [left, right), the program poisons\n // at least [left, AlignDown(right)).\n@@ -115,9 +115,9 @@ void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n   if (beg.chunk == end.chunk) {\n-    CHECK(beg.offset < end.offset);\n+    CHECK_LT(beg.offset, end.offset);\n     s8 value = beg.value;\n-    CHECK(value == end.value);\n+    CHECK_EQ(value, end.value);\n     // We can only poison memory if the byte in end.offset is unaddressable.\n     // No need to re-poison memory if it is poisoned already.\n     if (value > 0 && value <= end.offset) {\n@@ -129,7 +129,7 @@ void __asan_poison_memory_region(void const volatile *addr, uptr size) {\n     }\n     return;\n   }\n-  CHECK(beg.chunk < end.chunk);\n+  CHECK_LT(beg.chunk, end.chunk);\n   if (beg.offset > 0) {\n     // Mark bytes from beg.offset as unaddressable.\n     if (beg.value == 0) {\n@@ -155,17 +155,17 @@ void __asan_unpoison_memory_region(void const volatile *addr, uptr size) {\n   ShadowSegmentEndpoint beg(beg_addr);\n   ShadowSegmentEndpoint end(end_addr);\n   if (beg.chunk == end.chunk) {\n-    CHECK(beg.offset < end.offset);\n+    CHECK_LT(beg.offset, end.offset);\n     s8 value = beg.value;\n-    CHECK(value == end.value);\n+    CHECK_EQ(value, end.value);\n     // We unpoison memory bytes up to enbytes up to end.offset if it is not\n     // unpoisoned already.\n     if (value != 0) {\n       *beg.chunk = Max(value, end.offset);\n     }\n     return;\n   }\n-  CHECK(beg.chunk < end.chunk);\n+  CHECK_LT(beg.chunk, end.chunk);\n   if (beg.offset > 0) {\n     *beg.chunk = 0;\n     beg.chunk++;\n@@ -312,6 +312,30 @@ static void PoisonAlignedStackMemory(uptr addr, uptr size, bool do_poison) {\n   }\n }\n \n+void __asan_set_shadow_00(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0, size);\n+}\n+\n+void __asan_set_shadow_f1(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0xf1, size);\n+}\n+\n+void __asan_set_shadow_f2(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0xf2, size);\n+}\n+\n+void __asan_set_shadow_f3(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0xf3, size);\n+}\n+\n+void __asan_set_shadow_f5(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0xf5, size);\n+}\n+\n+void __asan_set_shadow_f8(uptr addr, uptr size) {\n+  REAL(memset)((void *)addr, 0xf8, size);\n+}\n+\n void __asan_poison_stack_memory(uptr addr, uptr size) {\n   VReport(1, \"poisoning: %p %zx\\n\", (void *)addr, size);\n   PoisonAlignedStackMemory(addr, size, true);\n@@ -341,7 +365,7 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n                                                  &stack);\n   }\n   CHECK_LE(end - beg,\n-           FIRST_32_SECOND_64(1UL << 30, 1UL << 34)); // Sanity check.\n+           FIRST_32_SECOND_64(1UL << 30, 1ULL << 34)); // Sanity check.\n \n   uptr a = RoundDownTo(Min(old_mid, new_mid), granularity);\n   uptr c = RoundUpTo(Max(old_mid, new_mid), granularity);\n@@ -352,7 +376,7 @@ void __sanitizer_annotate_contiguous_container(const void *beg_p,\n   // Make a quick sanity check that we are indeed in this state.\n   //\n   // FIXME: Two of these three checks are disabled until we fix\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=258.\n+  // https://github.com/google/sanitizers/issues/258.\n   // if (d1 != d2)\n   //  CHECK_EQ(*(u8*)MemToShadow(d1), old_mid - d1);\n   if (a + granularity <= d1)"}, {"sha": "4ddcbc314d4b0c31d52b76d85bffc7886122a37e", "filename": "libsanitizer/asan/asan_poisoning.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_poisoning.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_poisoning.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_poisoning.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -84,7 +84,7 @@ ALWAYS_INLINE void FastPoisonShadowPartialRightRedzone(\n   }\n }\n \n-// Calls __sanitizer::FlushUnneededShadowMemory() on\n+// Calls __sanitizer::ReleaseMemoryToOS() on\n // [MemToShadow(p), MemToShadow(p+size)] with proper rounding.\n void FlushUnneededASanShadowMemory(uptr p, uptr size);\n "}, {"sha": "532afb37f1abd38e2f2513d1823ad66e594fbb31", "filename": "libsanitizer/asan/asan_posix.cc", "status": "modified", "additions": 25, "deletions": 5, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_posix.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -31,17 +31,39 @@\n \n namespace __asan {\n \n+const char *DescribeSignalOrException(int signo) {\n+  switch (signo) {\n+    case SIGFPE:\n+      return \"FPE\";\n+    case SIGILL:\n+      return \"ILL\";\n+    case SIGABRT:\n+      return \"ABRT\";\n+    default:\n+      return \"SEGV\";\n+  }\n+}\n+\n void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   ScopedDeadlySignal signal_scope(GetCurrentThread());\n   int code = (int)((siginfo_t*)siginfo)->si_code;\n-  // Write the first message using the bullet-proof write.\n-  if (18 != internal_write(2, \"ASAN:DEADLYSIGNAL\\n\", 18)) Die();\n+  // Write the first message using fd=2, just in case.\n+  // It may actually fail to write in case stderr is closed.\n+  internal_write(2, \"ASAN:DEADLYSIGNAL\\n\", 18);\n   SignalContext sig = SignalContext::Create(siginfo, context);\n \n   // Access at a reasonable offset above SP, or slightly below it (to account\n   // for x86_64 or PowerPC redzone, ARM push of multiple registers, etc) is\n   // probably a stack overflow.\n+#ifdef __s390__\n+  // On s390, the fault address in siginfo points to start of the page, not\n+  // to the precise word that was accessed.  Mask off the low bits of sp to\n+  // take it into account.\n+  bool IsStackAccess = sig.addr >= (sig.sp & ~0xFFF) &&\n+                       sig.addr < sig.sp + 0xFFFF;\n+#else\n   bool IsStackAccess = sig.addr + 512 > sig.sp && sig.addr < sig.sp + 0xFFFF;\n+#endif\n \n #if __powerpc__\n   // Large stack frames can be allocated with e.g.\n@@ -73,10 +95,8 @@ void AsanOnDeadlySignal(int signo, void *siginfo, void *context) {\n   // unaligned memory access.\n   if (IsStackAccess && (code == si_SEGV_MAPERR || code == si_SEGV_ACCERR))\n     ReportStackOverflow(sig);\n-  else if (signo == SIGFPE)\n-    ReportDeadlySignal(\"FPE\", sig);\n   else\n-    ReportDeadlySignal(\"SEGV\", sig);\n+    ReportDeadlySignal(signo, sig);\n }\n \n // ---------------------- TSD ---------------- {{{1"}, {"sha": "84d67646b403a6e03934c1cec6650e024c642f5f", "filename": "libsanitizer/asan/asan_report.cc", "status": "modified", "additions": 151, "deletions": 838, "changes": 989, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -10,10 +10,13 @@\n // This file contains error reporting code.\n //===----------------------------------------------------------------------===//\n \n+#include \"asan_errors.h\"\n #include \"asan_flags.h\"\n+#include \"asan_descriptions.h\"\n #include \"asan_internal.h\"\n #include \"asan_mapping.h\"\n #include \"asan_report.h\"\n+#include \"asan_scariness_score.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n #include \"sanitizer_common/sanitizer_common.h\"\n@@ -28,188 +31,38 @@ namespace __asan {\n static void (*error_report_callback)(const char*);\n static char *error_message_buffer = nullptr;\n static uptr error_message_buffer_pos = 0;\n-static uptr error_message_buffer_size = 0;\n-\n-struct ReportData {\n-  uptr pc;\n-  uptr sp;\n-  uptr bp;\n-  uptr addr;\n-  bool is_write;\n-  uptr access_size;\n-  const char *description;\n-};\n-\n-static bool report_happened = false;\n-static ReportData report_data = {};\n+static BlockingMutex error_message_buf_mutex(LINKER_INITIALIZED);\n+static const unsigned kAsanBuggyPcPoolSize = 25;\n+static __sanitizer::atomic_uintptr_t AsanBuggyPcPool[kAsanBuggyPcPoolSize];\n \n void AppendToErrorMessageBuffer(const char *buffer) {\n-  if (error_message_buffer) {\n-    uptr length = internal_strlen(buffer);\n-    CHECK_GE(error_message_buffer_size, error_message_buffer_pos);\n-    uptr remaining = error_message_buffer_size - error_message_buffer_pos;\n-    internal_strncpy(error_message_buffer + error_message_buffer_pos,\n-                     buffer, remaining);\n-    error_message_buffer[error_message_buffer_size - 1] = '\\0';\n-    // FIXME: reallocate the buffer instead of truncating the message.\n-    error_message_buffer_pos += Min(remaining, length);\n+  BlockingMutexLock l(&error_message_buf_mutex);\n+  if (!error_message_buffer) {\n+    error_message_buffer =\n+      (char*)MmapOrDieQuietly(kErrorMessageBufferSize, __func__);\n+    error_message_buffer_pos = 0;\n   }\n+  uptr length = internal_strlen(buffer);\n+  RAW_CHECK(kErrorMessageBufferSize >= error_message_buffer_pos);\n+  uptr remaining = kErrorMessageBufferSize - error_message_buffer_pos;\n+  internal_strncpy(error_message_buffer + error_message_buffer_pos,\n+                   buffer, remaining);\n+  error_message_buffer[kErrorMessageBufferSize - 1] = '\\0';\n+  // FIXME: reallocate the buffer instead of truncating the message.\n+  error_message_buffer_pos += Min(remaining, length);\n }\n \n-// ---------------------- Decorator ------------------------------ {{{1\n-class Decorator: public __sanitizer::SanitizerCommonDecorator {\n- public:\n-  Decorator() : SanitizerCommonDecorator() { }\n-  const char *Access()     { return Blue(); }\n-  const char *EndAccess()  { return Default(); }\n-  const char *Location()   { return Green(); }\n-  const char *EndLocation() { return Default(); }\n-  const char *Allocation()  { return Magenta(); }\n-  const char *EndAllocation()  { return Default(); }\n-\n-  const char *ShadowByte(u8 byte) {\n-    switch (byte) {\n-      case kAsanHeapLeftRedzoneMagic:\n-      case kAsanHeapRightRedzoneMagic:\n-      case kAsanArrayCookieMagic:\n-        return Red();\n-      case kAsanHeapFreeMagic:\n-        return Magenta();\n-      case kAsanStackLeftRedzoneMagic:\n-      case kAsanStackMidRedzoneMagic:\n-      case kAsanStackRightRedzoneMagic:\n-      case kAsanStackPartialRedzoneMagic:\n-        return Red();\n-      case kAsanStackAfterReturnMagic:\n-        return Magenta();\n-      case kAsanInitializationOrderMagic:\n-        return Cyan();\n-      case kAsanUserPoisonedMemoryMagic:\n-      case kAsanContiguousContainerOOBMagic:\n-      case kAsanAllocaLeftMagic:\n-      case kAsanAllocaRightMagic:\n-        return Blue();\n-      case kAsanStackUseAfterScopeMagic:\n-        return Magenta();\n-      case kAsanGlobalRedzoneMagic:\n-        return Red();\n-      case kAsanInternalHeapMagic:\n-        return Yellow();\n-      case kAsanIntraObjectRedzone:\n-        return Yellow();\n-      default:\n-        return Default();\n-    }\n-  }\n-  const char *EndShadowByte() { return Default(); }\n-  const char *MemoryByte() { return Magenta(); }\n-  const char *EndMemoryByte() { return Default(); }\n-};\n-\n // ---------------------- Helper functions ----------------------- {{{1\n \n-static void PrintMemoryByte(InternalScopedString *str, const char *before,\n-    u8 byte, bool in_shadow, const char *after = \"\\n\") {\n+void PrintMemoryByte(InternalScopedString *str, const char *before, u8 byte,\n+                     bool in_shadow, const char *after) {\n   Decorator d;\n   str->append(\"%s%s%x%x%s%s\", before,\n               in_shadow ? d.ShadowByte(byte) : d.MemoryByte(),\n               byte >> 4, byte & 15,\n               in_shadow ? d.EndShadowByte() : d.EndMemoryByte(), after);\n }\n \n-static void PrintShadowByte(InternalScopedString *str, const char *before,\n-    u8 byte, const char *after = \"\\n\") {\n-  PrintMemoryByte(str, before, byte, /*in_shadow*/true, after);\n-}\n-\n-static void PrintShadowBytes(InternalScopedString *str, const char *before,\n-                             u8 *bytes, u8 *guilty, uptr n) {\n-  Decorator d;\n-  if (before) str->append(\"%s%p:\", before, bytes);\n-  for (uptr i = 0; i < n; i++) {\n-    u8 *p = bytes + i;\n-    const char *before =\n-        p == guilty ? \"[\" : (p - 1 == guilty && i != 0) ? \"\" : \" \";\n-    const char *after = p == guilty ? \"]\" : \"\";\n-    PrintShadowByte(str, before, *p, after);\n-  }\n-  str->append(\"\\n\");\n-}\n-\n-static void PrintLegend(InternalScopedString *str) {\n-  str->append(\n-      \"Shadow byte legend (one shadow byte represents %d \"\n-      \"application bytes):\\n\",\n-      (int)SHADOW_GRANULARITY);\n-  PrintShadowByte(str, \"  Addressable:           \", 0);\n-  str->append(\"  Partially addressable: \");\n-  for (u8 i = 1; i < SHADOW_GRANULARITY; i++) PrintShadowByte(str, \"\", i, \" \");\n-  str->append(\"\\n\");\n-  PrintShadowByte(str, \"  Heap left redzone:       \",\n-                  kAsanHeapLeftRedzoneMagic);\n-  PrintShadowByte(str, \"  Heap right redzone:      \",\n-                  kAsanHeapRightRedzoneMagic);\n-  PrintShadowByte(str, \"  Freed heap region:       \", kAsanHeapFreeMagic);\n-  PrintShadowByte(str, \"  Stack left redzone:      \",\n-                  kAsanStackLeftRedzoneMagic);\n-  PrintShadowByte(str, \"  Stack mid redzone:       \",\n-                  kAsanStackMidRedzoneMagic);\n-  PrintShadowByte(str, \"  Stack right redzone:     \",\n-                  kAsanStackRightRedzoneMagic);\n-  PrintShadowByte(str, \"  Stack partial redzone:   \",\n-                  kAsanStackPartialRedzoneMagic);\n-  PrintShadowByte(str, \"  Stack after return:      \",\n-                  kAsanStackAfterReturnMagic);\n-  PrintShadowByte(str, \"  Stack use after scope:   \",\n-                  kAsanStackUseAfterScopeMagic);\n-  PrintShadowByte(str, \"  Global redzone:          \", kAsanGlobalRedzoneMagic);\n-  PrintShadowByte(str, \"  Global init order:       \",\n-                  kAsanInitializationOrderMagic);\n-  PrintShadowByte(str, \"  Poisoned by user:        \",\n-                  kAsanUserPoisonedMemoryMagic);\n-  PrintShadowByte(str, \"  Container overflow:      \",\n-                  kAsanContiguousContainerOOBMagic);\n-  PrintShadowByte(str, \"  Array cookie:            \",\n-                  kAsanArrayCookieMagic);\n-  PrintShadowByte(str, \"  Intra object redzone:    \",\n-                  kAsanIntraObjectRedzone);\n-  PrintShadowByte(str, \"  ASan internal:           \", kAsanInternalHeapMagic);\n-  PrintShadowByte(str, \"  Left alloca redzone:     \", kAsanAllocaLeftMagic);\n-  PrintShadowByte(str, \"  Right alloca redzone:    \", kAsanAllocaRightMagic);\n-}\n-\n-void MaybeDumpInstructionBytes(uptr pc) {\n-  if (!flags()->dump_instruction_bytes || (pc < GetPageSizeCached()))\n-    return;\n-  InternalScopedString str(1024);\n-  str.append(\"First 16 instruction bytes at pc: \");\n-  if (IsAccessibleMemoryRange(pc, 16)) {\n-    for (int i = 0; i < 16; ++i) {\n-      PrintMemoryByte(&str, \"\", ((u8 *)pc)[i], /*in_shadow*/false, \" \");\n-    }\n-    str.append(\"\\n\");\n-  } else {\n-    str.append(\"unaccessible\\n\");\n-  }\n-  Report(\"%s\", str.data());\n-}\n-\n-static void PrintShadowMemoryForAddress(uptr addr) {\n-  if (!AddrIsInMem(addr)) return;\n-  uptr shadow_addr = MemToShadow(addr);\n-  const uptr n_bytes_per_row = 16;\n-  uptr aligned_shadow = shadow_addr & ~(n_bytes_per_row - 1);\n-  InternalScopedString str(4096 * 8);\n-  str.append(\"Shadow bytes around the buggy address:\\n\");\n-  for (int i = -5; i <= 5; i++) {\n-    const char *prefix = (i == 0) ? \"=>\" : \"  \";\n-    PrintShadowBytes(&str, prefix, (u8 *)(aligned_shadow + i * n_bytes_per_row),\n-                     (u8 *)shadow_addr, n_bytes_per_row);\n-  }\n-  if (flags()->print_legend) PrintLegend(&str);\n-  Printf(\"%s\", str.data());\n-}\n-\n static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n                                 const char *zone_name) {\n   if (zone_ptr) {\n@@ -225,191 +78,8 @@ static void PrintZoneForPointer(uptr ptr, uptr zone_ptr,\n   }\n }\n \n-static void DescribeThread(AsanThread *t) {\n-  if (t)\n-    DescribeThread(t->context());\n-}\n-\n // ---------------------- Address Descriptions ------------------- {{{1\n \n-static bool IsASCII(unsigned char c) {\n-  return /*0x00 <= c &&*/ c <= 0x7F;\n-}\n-\n-static const char *MaybeDemangleGlobalName(const char *name) {\n-  // We can spoil names of globals with C linkage, so use an heuristic\n-  // approach to check if the name should be demangled.\n-  bool should_demangle = false;\n-  if (name[0] == '_' && name[1] == 'Z')\n-    should_demangle = true;\n-  else if (SANITIZER_WINDOWS && name[0] == '\\01' && name[1] == '?')\n-    should_demangle = true;\n-\n-  return should_demangle ? Symbolizer::GetOrInit()->Demangle(name) : name;\n-}\n-\n-// Check if the global is a zero-terminated ASCII string. If so, print it.\n-static void PrintGlobalNameIfASCII(InternalScopedString *str,\n-                                   const __asan_global &g) {\n-  for (uptr p = g.beg; p < g.beg + g.size - 1; p++) {\n-    unsigned char c = *(unsigned char*)p;\n-    if (c == '\\0' || !IsASCII(c)) return;\n-  }\n-  if (*(char*)(g.beg + g.size - 1) != '\\0') return;\n-  str->append(\"  '%s' is ascii string '%s'\\n\", MaybeDemangleGlobalName(g.name),\n-              (char *)g.beg);\n-}\n-\n-static const char *GlobalFilename(const __asan_global &g) {\n-  const char *res = g.module_name;\n-  // Prefer the filename from source location, if is available.\n-  if (g.location)\n-    res = g.location->filename;\n-  CHECK(res);\n-  return res;\n-}\n-\n-static void PrintGlobalLocation(InternalScopedString *str,\n-                                const __asan_global &g) {\n-  str->append(\"%s\", GlobalFilename(g));\n-  if (!g.location)\n-    return;\n-  if (g.location->line_no)\n-    str->append(\":%d\", g.location->line_no);\n-  if (g.location->column_no)\n-    str->append(\":%d\", g.location->column_no);\n-}\n-\n-static void DescribeAddressRelativeToGlobal(uptr addr, uptr size,\n-                                            const __asan_global &g) {\n-  InternalScopedString str(4096);\n-  Decorator d;\n-  str.append(\"%s\", d.Location());\n-  if (addr < g.beg) {\n-    str.append(\"%p is located %zd bytes to the left\", (void *)addr,\n-               g.beg - addr);\n-  } else if (addr + size > g.beg + g.size) {\n-    if (addr < g.beg + g.size)\n-      addr = g.beg + g.size;\n-    str.append(\"%p is located %zd bytes to the right\", (void *)addr,\n-               addr - (g.beg + g.size));\n-  } else {\n-    // Can it happen?\n-    str.append(\"%p is located %zd bytes inside\", (void *)addr, addr - g.beg);\n-  }\n-  str.append(\" of global variable '%s' defined in '\",\n-             MaybeDemangleGlobalName(g.name));\n-  PrintGlobalLocation(&str, g);\n-  str.append(\"' (0x%zx) of size %zu\\n\", g.beg, g.size);\n-  str.append(\"%s\", d.EndLocation());\n-  PrintGlobalNameIfASCII(&str, g);\n-  Printf(\"%s\", str.data());\n-}\n-\n-static bool DescribeAddressIfGlobal(uptr addr, uptr size,\n-                                    const char *bug_type) {\n-  // Assume address is close to at most four globals.\n-  const int kMaxGlobalsInReport = 4;\n-  __asan_global globals[kMaxGlobalsInReport];\n-  u32 reg_sites[kMaxGlobalsInReport];\n-  int globals_num =\n-      GetGlobalsForAddress(addr, globals, reg_sites, ARRAY_SIZE(globals));\n-  if (globals_num == 0)\n-    return false;\n-  for (int i = 0; i < globals_num; i++) {\n-    DescribeAddressRelativeToGlobal(addr, size, globals[i]);\n-    if (0 == internal_strcmp(bug_type, \"initialization-order-fiasco\") &&\n-        reg_sites[i]) {\n-      Printf(\"  registered at:\\n\");\n-      StackDepotGet(reg_sites[i]).Print();\n-    }\n-  }\n-  return true;\n-}\n-\n-bool DescribeAddressIfShadow(uptr addr, AddressDescription *descr, bool print) {\n-  if (AddrIsInMem(addr))\n-    return false;\n-  const char *area_type = nullptr;\n-  if (AddrIsInShadowGap(addr)) area_type = \"shadow gap\";\n-  else if (AddrIsInHighShadow(addr)) area_type = \"high shadow\";\n-  else if (AddrIsInLowShadow(addr)) area_type = \"low shadow\";\n-  if (area_type != nullptr) {\n-    if (print) {\n-      Printf(\"Address %p is located in the %s area.\\n\", addr, area_type);\n-    } else {\n-      CHECK(descr);\n-      descr->region_kind = area_type;\n-    }\n-    return true;\n-  }\n-  CHECK(0 && \"Address is not in memory and not in shadow?\");\n-  return false;\n-}\n-\n-// Return \" (thread_name) \" or an empty string if the name is empty.\n-const char *ThreadNameWithParenthesis(AsanThreadContext *t, char buff[],\n-                                      uptr buff_len) {\n-  const char *name = t->name;\n-  if (name[0] == '\\0') return \"\";\n-  buff[0] = 0;\n-  internal_strncat(buff, \" (\", 3);\n-  internal_strncat(buff, name, buff_len - 4);\n-  internal_strncat(buff, \")\", 2);\n-  return buff;\n-}\n-\n-const char *ThreadNameWithParenthesis(u32 tid, char buff[],\n-                                      uptr buff_len) {\n-  if (tid == kInvalidTid) return \"\";\n-  asanThreadRegistry().CheckLocked();\n-  AsanThreadContext *t = GetThreadContextByTidLocked(tid);\n-  return ThreadNameWithParenthesis(t, buff, buff_len);\n-}\n-\n-static void PrintAccessAndVarIntersection(const StackVarDescr &var, uptr addr,\n-                                          uptr access_size, uptr prev_var_end,\n-                                          uptr next_var_beg) {\n-  uptr var_end = var.beg + var.size;\n-  uptr addr_end = addr + access_size;\n-  const char *pos_descr = nullptr;\n-  // If the variable [var.beg, var_end) is the nearest variable to the\n-  // current memory access, indicate it in the log.\n-  if (addr >= var.beg) {\n-    if (addr_end <= var_end)\n-      pos_descr = \"is inside\";  // May happen if this is a use-after-return.\n-    else if (addr < var_end)\n-      pos_descr = \"partially overflows\";\n-    else if (addr_end <= next_var_beg &&\n-             next_var_beg - addr_end >= addr - var_end)\n-      pos_descr = \"overflows\";\n-  } else {\n-    if (addr_end > var.beg)\n-      pos_descr = \"partially underflows\";\n-    else if (addr >= prev_var_end &&\n-             addr - prev_var_end >= var.beg - addr_end)\n-      pos_descr = \"underflows\";\n-  }\n-  InternalScopedString str(1024);\n-  str.append(\"    [%zd, %zd)\", var.beg, var_end);\n-  // Render variable name.\n-  str.append(\" '\");\n-  for (uptr i = 0; i < var.name_len; ++i) {\n-    str.append(\"%c\", var.name_pos[i]);\n-  }\n-  str.append(\"'\");\n-  if (pos_descr) {\n-    Decorator d;\n-    // FIXME: we may want to also print the size of the access here,\n-    // but in case of accesses generated by memset it may be confusing.\n-    str.append(\"%s <== Memory access at offset %zd %s this variable%s\\n\",\n-               d.Location(), addr, pos_descr, d.EndLocation());\n-  } else {\n-    str.append(\"\\n\");\n-  }\n-  Printf(\"%s\", str.data());\n-}\n-\n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars) {\n   CHECK(frame_descr);\n@@ -437,195 +107,17 @@ bool ParseFrameDescription(const char *frame_descr,\n   return true;\n }\n \n-bool DescribeAddressIfStack(uptr addr, uptr access_size) {\n-  AsanThread *t = FindThreadByStackAddress(addr);\n-  if (!t) return false;\n-\n-  Decorator d;\n-  char tname[128];\n-  Printf(\"%s\", d.Location());\n-  Printf(\"Address %p is located in stack of thread T%d%s\", addr, t->tid(),\n-         ThreadNameWithParenthesis(t->tid(), tname, sizeof(tname)));\n-\n-  // Try to fetch precise stack frame for this access.\n-  AsanThread::StackFrameAccess access;\n-  if (!t->GetStackFrameAccessByAddr(addr, &access)) {\n-    Printf(\"%s\\n\", d.EndLocation());\n-    return true;\n-  }\n-  Printf(\" at offset %zu in frame%s\\n\", access.offset, d.EndLocation());\n-\n-  // Now we print the frame where the alloca has happened.\n-  // We print this frame as a stack trace with one element.\n-  // The symbolizer may print more than one frame if inlining was involved.\n-  // The frame numbers may be different than those in the stack trace printed\n-  // previously. That's unfortunate, but I have no better solution,\n-  // especially given that the alloca may be from entirely different place\n-  // (e.g. use-after-scope, or different thread's stack).\n-#if defined(__powerpc64__) && defined(__BIG_ENDIAN__)\n-  // On PowerPC64 ELFv1, the address of a function actually points to a\n-  // three-doubleword data structure with the first field containing\n-  // the address of the function's code.\n-  access.frame_pc = *reinterpret_cast<uptr *>(access.frame_pc);\n-#endif\n-  access.frame_pc += 16;\n-  Printf(\"%s\", d.EndLocation());\n-  StackTrace alloca_stack(&access.frame_pc, 1);\n-  alloca_stack.Print();\n-\n-  InternalMmapVector<StackVarDescr> vars(16);\n-  if (!ParseFrameDescription(access.frame_descr, &vars)) {\n-    Printf(\"AddressSanitizer can't parse the stack frame \"\n-           \"descriptor: |%s|\\n\", access.frame_descr);\n-    // 'addr' is a stack address, so return true even if we can't parse frame\n-    return true;\n-  }\n-  uptr n_objects = vars.size();\n-  // Report the number of stack objects.\n-  Printf(\"  This frame has %zu object(s):\\n\", n_objects);\n-\n-  // Report all objects in this frame.\n-  for (uptr i = 0; i < n_objects; i++) {\n-    uptr prev_var_end = i ? vars[i - 1].beg + vars[i - 1].size : 0;\n-    uptr next_var_beg = i + 1 < n_objects ? vars[i + 1].beg : ~(0UL);\n-    PrintAccessAndVarIntersection(vars[i], access.offset, access_size,\n-                                  prev_var_end, next_var_beg);\n-  }\n-  Printf(\"HINT: this may be a false positive if your program uses \"\n-         \"some custom stack unwind mechanism or swapcontext\\n\");\n-  if (SANITIZER_WINDOWS)\n-    Printf(\"      (longjmp, SEH and C++ exceptions *are* supported)\\n\");\n-  else\n-    Printf(\"      (longjmp and C++ exceptions *are* supported)\\n\");\n-\n-  DescribeThread(t);\n-  return true;\n-}\n-\n-static void DescribeAccessToHeapChunk(AsanChunkView chunk, uptr addr,\n-                                      uptr access_size) {\n-  sptr offset;\n-  Decorator d;\n-  InternalScopedString str(4096);\n-  str.append(\"%s\", d.Location());\n-  if (chunk.AddrIsAtLeft(addr, access_size, &offset)) {\n-    str.append(\"%p is located %zd bytes to the left of\", (void *)addr, offset);\n-  } else if (chunk.AddrIsAtRight(addr, access_size, &offset)) {\n-    if (offset < 0) {\n-      addr -= offset;\n-      offset = 0;\n-    }\n-    str.append(\"%p is located %zd bytes to the right of\", (void *)addr, offset);\n-  } else if (chunk.AddrIsInside(addr, access_size, &offset)) {\n-    str.append(\"%p is located %zd bytes inside of\", (void*)addr, offset);\n-  } else {\n-    str.append(\"%p is located somewhere around (this is AddressSanitizer bug!)\",\n-               (void *)addr);\n-  }\n-  str.append(\" %zu-byte region [%p,%p)\\n\", chunk.UsedSize(),\n-             (void *)(chunk.Beg()), (void *)(chunk.End()));\n-  str.append(\"%s\", d.EndLocation());\n-  Printf(\"%s\", str.data());\n-}\n-\n-void DescribeHeapAddress(uptr addr, uptr access_size) {\n-  AsanChunkView chunk = FindHeapChunkByAddress(addr);\n-  if (!chunk.IsValid()) {\n-    Printf(\"AddressSanitizer can not describe address in more detail \"\n-           \"(wild memory access suspected).\\n\");\n-    return;\n-  }\n-  DescribeAccessToHeapChunk(chunk, addr, access_size);\n-  CHECK(chunk.AllocTid() != kInvalidTid);\n-  asanThreadRegistry().CheckLocked();\n-  AsanThreadContext *alloc_thread =\n-      GetThreadContextByTidLocked(chunk.AllocTid());\n-  StackTrace alloc_stack = chunk.GetAllocStack();\n-  char tname[128];\n-  Decorator d;\n-  AsanThreadContext *free_thread = nullptr;\n-  if (chunk.FreeTid() != kInvalidTid) {\n-    free_thread = GetThreadContextByTidLocked(chunk.FreeTid());\n-    Printf(\"%sfreed by thread T%d%s here:%s\\n\", d.Allocation(),\n-           free_thread->tid,\n-           ThreadNameWithParenthesis(free_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n-    StackTrace free_stack = chunk.GetFreeStack();\n-    free_stack.Print();\n-    Printf(\"%spreviously allocated by thread T%d%s here:%s\\n\",\n-           d.Allocation(), alloc_thread->tid,\n-           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n-  } else {\n-    Printf(\"%sallocated by thread T%d%s here:%s\\n\", d.Allocation(),\n-           alloc_thread->tid,\n-           ThreadNameWithParenthesis(alloc_thread, tname, sizeof(tname)),\n-           d.EndAllocation());\n-  }\n-  alloc_stack.Print();\n-  DescribeThread(GetCurrentThread());\n-  if (free_thread)\n-    DescribeThread(free_thread);\n-  DescribeThread(alloc_thread);\n-}\n-\n-static void DescribeAddress(uptr addr, uptr access_size, const char *bug_type) {\n-  // Check if this is shadow or shadow gap.\n-  if (DescribeAddressIfShadow(addr))\n-    return;\n-  CHECK(AddrIsInMem(addr));\n-  if (DescribeAddressIfGlobal(addr, access_size, bug_type))\n-    return;\n-  if (DescribeAddressIfStack(addr, access_size))\n-    return;\n-  // Assume it is a heap address.\n-  DescribeHeapAddress(addr, access_size);\n-}\n-\n-// ------------------- Thread description -------------------- {{{1\n-\n-void DescribeThread(AsanThreadContext *context) {\n-  CHECK(context);\n-  asanThreadRegistry().CheckLocked();\n-  // No need to announce the main thread.\n-  if (context->tid == 0 || context->announced) {\n-    return;\n-  }\n-  context->announced = true;\n-  char tname[128];\n-  InternalScopedString str(1024);\n-  str.append(\"Thread T%d%s\", context->tid,\n-             ThreadNameWithParenthesis(context->tid, tname, sizeof(tname)));\n-  if (context->parent_tid == kInvalidTid) {\n-    str.append(\" created by unknown thread\\n\");\n-    Printf(\"%s\", str.data());\n-    return;\n-  }\n-  str.append(\n-      \" created by T%d%s here:\\n\", context->parent_tid,\n-      ThreadNameWithParenthesis(context->parent_tid, tname, sizeof(tname)));\n-  Printf(\"%s\", str.data());\n-  StackDepotGet(context->stack_id).Print();\n-  // Recursively described parent thread if needed.\n-  if (flags()->print_full_thread_history) {\n-    AsanThreadContext *parent_context =\n-        GetThreadContextByTidLocked(context->parent_tid);\n-    DescribeThread(parent_context);\n-  }\n-}\n-\n // -------------------- Different kinds of reports ----------------- {{{1\n \n // Use ScopedInErrorReport to run common actions just before and\n // immediately after printing error report.\n class ScopedInErrorReport {\n  public:\n-  explicit ScopedInErrorReport(ReportData *report = nullptr,\n-                               bool fatal = false) {\n+  explicit ScopedInErrorReport(bool fatal = false) {\n     halt_on_error_ = fatal || flags()->halt_on_error;\n \n     if (lock_.TryLock()) {\n-      StartReporting(report);\n+      StartReporting();\n       return;\n     }\n \n@@ -667,20 +159,44 @@ class ScopedInErrorReport {\n       lock_.Lock();\n     }\n \n-    StartReporting(report);\n+    StartReporting();\n   }\n \n   ~ScopedInErrorReport() {\n+    ASAN_ON_ERROR();\n+    if (current_error_.IsValid()) current_error_.Print();\n+\n     // Make sure the current thread is announced.\n     DescribeThread(GetCurrentThread());\n     // We may want to grab this lock again when printing stats.\n     asanThreadRegistry().Unlock();\n     // Print memory stats.\n     if (flags()->print_stats)\n       __asan_print_accumulated_stats();\n+\n+    if (common_flags()->print_cmdline)\n+      PrintCmdline();\n+\n+    // Copy the message buffer so that we could start logging without holding a\n+    // lock that gets aquired during printing.\n+    InternalScopedBuffer<char> buffer_copy(kErrorMessageBufferSize);\n+    {\n+      BlockingMutexLock l(&error_message_buf_mutex);\n+      internal_memcpy(buffer_copy.data(),\n+                      error_message_buffer, kErrorMessageBufferSize);\n+    }\n+\n+    LogFullErrorReport(buffer_copy.data());\n+\n     if (error_report_callback) {\n-      error_report_callback(error_message_buffer);\n+      error_report_callback(buffer_copy.data());\n     }\n+\n+    // In halt_on_error = false mode, reset the current error object (before\n+    // unlocking).\n+    if (!halt_on_error_)\n+      internal_memset(&current_error_, 0, sizeof(current_error_));\n+\n     CommonSanitizerReportMutex.Unlock();\n     reporting_thread_tid_ = kInvalidTid;\n     lock_.Unlock();\n@@ -690,11 +206,18 @@ class ScopedInErrorReport {\n     }\n   }\n \n+  void ReportError(const ErrorDescription &description) {\n+    // Can only report one error per ScopedInErrorReport.\n+    CHECK_EQ(current_error_.kind, kErrorKindInvalid);\n+    current_error_ = description;\n+  }\n+\n+  static ErrorDescription &CurrentError() {\n+    return current_error_;\n+  }\n+\n  private:\n-  void StartReporting(ReportData *report) {\n-    if (report) report_data = *report;\n-    report_happened = true;\n-    ASAN_ON_ERROR();\n+  void StartReporting() {\n     // Make sure the registry and sanitizer report mutexes are locked while\n     // we're printing an error report.\n     // We can lock them only here to avoid self-deadlock in case of\n@@ -708,249 +231,113 @@ class ScopedInErrorReport {\n \n   static StaticSpinMutex lock_;\n   static u32 reporting_thread_tid_;\n+  // Error currently being reported. This enables the destructor to interact\n+  // with the debugger and point it to an error description.\n+  static ErrorDescription current_error_;\n   bool halt_on_error_;\n };\n \n StaticSpinMutex ScopedInErrorReport::lock_;\n-u32 ScopedInErrorReport::reporting_thread_tid_;\n+u32 ScopedInErrorReport::reporting_thread_tid_ = kInvalidTid;\n+ErrorDescription ScopedInErrorReport::current_error_;\n \n void ReportStackOverflow(const SignalContext &sig) {\n-  ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\n-      \"ERROR: AddressSanitizer: stack-overflow on address %p\"\n-      \" (pc %p bp %p sp %p T%d)\\n\",\n-      (void *)sig.addr, (void *)sig.pc, (void *)sig.bp, (void *)sig.sp,\n-      GetCurrentTidOrInvalid());\n-  Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_SIGNAL(sig);\n-  stack.Print();\n-  ReportErrorSummary(\"stack-overflow\", &stack);\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorStackOverflow error(GetCurrentTidOrInvalid(), sig);\n+  in_report.ReportError(error);\n }\n \n-void ReportDeadlySignal(const char *description, const SignalContext &sig) {\n-  ScopedInErrorReport in_report(/*report*/nullptr, /*fatal*/true);\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\n-      \"ERROR: AddressSanitizer: %s on unknown address %p\"\n-      \" (pc %p bp %p sp %p T%d)\\n\",\n-      description, (void *)sig.addr, (void *)sig.pc, (void *)sig.bp,\n-      (void *)sig.sp, GetCurrentTidOrInvalid());\n-  if (sig.pc < GetPageSizeCached()) {\n-    Report(\"Hint: pc points to the zero page.\\n\");\n-  }\n-  Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_SIGNAL(sig);\n-  stack.Print();\n-  MaybeDumpInstructionBytes(sig.pc);\n-  Printf(\"AddressSanitizer can not provide additional info.\\n\");\n-  ReportErrorSummary(description, &stack);\n+void ReportDeadlySignal(int signo, const SignalContext &sig) {\n+  ScopedInErrorReport in_report(/*fatal*/ true);\n+  ErrorDeadlySignal error(GetCurrentTidOrInvalid(), sig, signo);\n+  in_report.ReportError(error);\n }\n \n void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n-  u32 curr_tid = GetCurrentTidOrInvalid();\n-  Report(\"ERROR: AddressSanitizer: attempting double-free on %p in \"\n-         \"thread T%d%s:\\n\",\n-         addr, curr_tid,\n-         ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n-  Printf(\"%s\", d.EndWarning());\n-  CHECK_GT(free_stack->size, 0);\n-  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  stack.Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"double-free\", &stack);\n+  ErrorDoubleFree error(GetCurrentTidOrInvalid(), free_stack, addr);\n+  in_report.ReportError(error);\n }\n \n void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n                                  BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n-  u32 curr_tid = GetCurrentTidOrInvalid();\n-  Report(\"ERROR: AddressSanitizer: new-delete-type-mismatch on %p in \"\n-         \"thread T%d%s:\\n\",\n-         addr, curr_tid,\n-         ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n-  Printf(\"%s  object passed to delete has wrong type:\\n\", d.EndWarning());\n-  Printf(\"  size of the allocated type:   %zd bytes;\\n\"\n-         \"  size of the deallocated type: %zd bytes.\\n\",\n-         asan_mz_size(reinterpret_cast<void*>(addr)), delete_size);\n-  CHECK_GT(free_stack->size, 0);\n-  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  stack.Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"new-delete-type-mismatch\", &stack);\n-  Report(\"HINT: if you don't care about these errors you may set \"\n-         \"ASAN_OPTIONS=new_delete_type_mismatch=0\\n\");\n+  ErrorNewDeleteSizeMismatch error(GetCurrentTidOrInvalid(), free_stack, addr,\n+                                   delete_size);\n+  in_report.ReportError(error);\n }\n \n void ReportFreeNotMalloced(uptr addr, BufferedStackTrace *free_stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  char tname[128];\n-  u32 curr_tid = GetCurrentTidOrInvalid();\n-  Report(\"ERROR: AddressSanitizer: attempting free on address \"\n-             \"which was not malloc()-ed: %p in thread T%d%s\\n\", addr,\n-         curr_tid, ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)));\n-  Printf(\"%s\", d.EndWarning());\n-  CHECK_GT(free_stack->size, 0);\n-  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  stack.Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"bad-free\", &stack);\n+  ErrorFreeNotMalloced error(GetCurrentTidOrInvalid(), free_stack, addr);\n+  in_report.ReportError(error);\n }\n \n void ReportAllocTypeMismatch(uptr addr, BufferedStackTrace *free_stack,\n                              AllocType alloc_type,\n                              AllocType dealloc_type) {\n-  static const char *alloc_names[] =\n-    {\"INVALID\", \"malloc\", \"operator new\", \"operator new []\"};\n-  static const char *dealloc_names[] =\n-    {\"INVALID\", \"free\", \"operator delete\", \"operator delete []\"};\n-  CHECK_NE(alloc_type, dealloc_type);\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: alloc-dealloc-mismatch (%s vs %s) on %p\\n\",\n-        alloc_names[alloc_type], dealloc_names[dealloc_type], addr);\n-  Printf(\"%s\", d.EndWarning());\n-  CHECK_GT(free_stack->size, 0);\n-  GET_STACK_TRACE_FATAL(free_stack->trace[0], free_stack->top_frame_bp);\n-  stack.Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"alloc-dealloc-mismatch\", &stack);\n-  Report(\"HINT: if you don't care about these errors you may set \"\n-         \"ASAN_OPTIONS=alloc_dealloc_mismatch=0\\n\");\n+  ErrorAllocTypeMismatch error(GetCurrentTidOrInvalid(), free_stack, addr,\n+                               alloc_type, dealloc_type);\n+  in_report.ReportError(error);\n }\n \n void ReportMallocUsableSizeNotOwned(uptr addr, BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: attempting to call \"\n-             \"malloc_usable_size() for pointer which is \"\n-             \"not owned: %p\\n\", addr);\n-  Printf(\"%s\", d.EndWarning());\n-  stack->Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"bad-malloc_usable_size\", stack);\n+  ErrorMallocUsableSizeNotOwned error(GetCurrentTidOrInvalid(), stack, addr);\n+  in_report.ReportError(error);\n }\n \n void ReportSanitizerGetAllocatedSizeNotOwned(uptr addr,\n                                              BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: attempting to call \"\n-             \"__sanitizer_get_allocated_size() for pointer which is \"\n-             \"not owned: %p\\n\", addr);\n-  Printf(\"%s\", d.EndWarning());\n-  stack->Print();\n-  DescribeHeapAddress(addr, 1);\n-  ReportErrorSummary(\"bad-__sanitizer_get_allocated_size\", stack);\n+  ErrorSanitizerGetAllocatedSizeNotOwned error(GetCurrentTidOrInvalid(), stack,\n+                                               addr);\n+  in_report.ReportError(error);\n }\n \n void ReportStringFunctionMemoryRangesOverlap(const char *function,\n                                              const char *offset1, uptr length1,\n                                              const char *offset2, uptr length2,\n                                              BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  char bug_type[100];\n-  internal_snprintf(bug_type, sizeof(bug_type), \"%s-param-overlap\", function);\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: %s: \"\n-             \"memory ranges [%p,%p) and [%p, %p) overlap\\n\", \\\n-             bug_type, offset1, offset1 + length1, offset2, offset2 + length2);\n-  Printf(\"%s\", d.EndWarning());\n-  stack->Print();\n-  DescribeAddress((uptr)offset1, length1, bug_type);\n-  DescribeAddress((uptr)offset2, length2, bug_type);\n-  ReportErrorSummary(bug_type, stack);\n+  ErrorStringFunctionMemoryRangesOverlap error(\n+      GetCurrentTidOrInvalid(), stack, (uptr)offset1, length1, (uptr)offset2,\n+      length2, function);\n+  in_report.ReportError(error);\n }\n \n void ReportStringFunctionSizeOverflow(uptr offset, uptr size,\n                                       BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  const char *bug_type = \"negative-size-param\";\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: %s: (size=%zd)\\n\", bug_type, size);\n-  Printf(\"%s\", d.EndWarning());\n-  stack->Print();\n-  DescribeAddress(offset, size, bug_type);\n-  ReportErrorSummary(bug_type, stack);\n+  ErrorStringFunctionSizeOverflow error(GetCurrentTidOrInvalid(), stack, offset,\n+                                        size);\n+  in_report.ReportError(error);\n }\n \n void ReportBadParamsToAnnotateContiguousContainer(uptr beg, uptr end,\n                                                   uptr old_mid, uptr new_mid,\n                                                   BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n-  Report(\"ERROR: AddressSanitizer: bad parameters to \"\n-         \"__sanitizer_annotate_contiguous_container:\\n\"\n-         \"      beg     : %p\\n\"\n-         \"      end     : %p\\n\"\n-         \"      old_mid : %p\\n\"\n-         \"      new_mid : %p\\n\",\n-         beg, end, old_mid, new_mid);\n-  uptr granularity = SHADOW_GRANULARITY;\n-  if (!IsAligned(beg, granularity))\n-    Report(\"ERROR: beg is not aligned by %d\\n\", granularity);\n-  stack->Print();\n-  ReportErrorSummary(\"bad-__sanitizer_annotate_contiguous_container\", stack);\n+  ErrorBadParamsToAnnotateContiguousContainer error(\n+      GetCurrentTidOrInvalid(), stack, beg, end, old_mid, new_mid);\n+  in_report.ReportError(error);\n }\n \n void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n                         const __asan_global *g2, u32 stack_id2) {\n   ScopedInErrorReport in_report;\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: odr-violation (%p):\\n\", g1->beg);\n-  Printf(\"%s\", d.EndWarning());\n-  InternalScopedString g1_loc(256), g2_loc(256);\n-  PrintGlobalLocation(&g1_loc, *g1);\n-  PrintGlobalLocation(&g2_loc, *g2);\n-  Printf(\"  [1] size=%zd '%s' %s\\n\", g1->size,\n-         MaybeDemangleGlobalName(g1->name), g1_loc.data());\n-  Printf(\"  [2] size=%zd '%s' %s\\n\", g2->size,\n-         MaybeDemangleGlobalName(g2->name), g2_loc.data());\n-  if (stack_id1 && stack_id2) {\n-    Printf(\"These globals were registered at these points:\\n\");\n-    Printf(\"  [1]:\\n\");\n-    StackDepotGet(stack_id1).Print();\n-    Printf(\"  [2]:\\n\");\n-    StackDepotGet(stack_id2).Print();\n-  }\n-  Report(\"HINT: if you don't care about these errors you may set \"\n-         \"ASAN_OPTIONS=detect_odr_violation=0\\n\");\n-  InternalScopedString error_msg(256);\n-  error_msg.append(\"odr-violation: global '%s' at %s\",\n-                   MaybeDemangleGlobalName(g1->name), g1_loc.data());\n-  ReportErrorSummary(error_msg.data());\n+  ErrorODRViolation error(GetCurrentTidOrInvalid(), g1, stack_id1, g2,\n+                          stack_id2);\n+  in_report.ReportError(error);\n }\n \n // ----------------------- CheckForInvalidPointerPair ----------- {{{1\n-static NOINLINE void\n-ReportInvalidPointerPair(uptr pc, uptr bp, uptr sp, uptr a1, uptr a2) {\n+static NOINLINE void ReportInvalidPointerPair(uptr pc, uptr bp, uptr sp,\n+                                              uptr a1, uptr a2) {\n   ScopedInErrorReport in_report;\n-  const char *bug_type = \"invalid-pointer-pair\";\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: invalid-pointer-pair: %p %p\\n\", a1, a2);\n-  Printf(\"%s\", d.EndWarning());\n-  GET_STACK_TRACE_FATAL(pc, bp);\n-  stack.Print();\n-  DescribeAddress(a1, 1, bug_type);\n-  DescribeAddress(a2, 1, bug_type);\n-  ReportErrorSummary(bug_type, &stack);\n+  ErrorInvalidPointerPair error(GetCurrentTidOrInvalid(), pc, bp, sp, a1, a2);\n+  in_report.ReportError(error);\n }\n \n static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n@@ -959,26 +346,15 @@ static INLINE void CheckForInvalidPointerPair(void *p1, void *p2) {\n   uptr a2 = reinterpret_cast<uptr>(p2);\n   AsanChunkView chunk1 = FindHeapChunkByAddress(a1);\n   AsanChunkView chunk2 = FindHeapChunkByAddress(a2);\n-  bool valid1 = chunk1.IsValid();\n-  bool valid2 = chunk2.IsValid();\n-  if ((valid1 != valid2) || (valid1 && valid2 && !chunk1.Eq(chunk2))) {\n-    GET_CALLER_PC_BP_SP;                                              \\\n+  bool valid1 = chunk1.IsAllocated();\n+  bool valid2 = chunk2.IsAllocated();\n+  if (!valid1 || !valid2 || !chunk1.Eq(chunk2)) {\n+    GET_CALLER_PC_BP_SP;\n     return ReportInvalidPointerPair(pc, bp, sp, a1, a2);\n   }\n }\n // ----------------------- Mac-specific reports ----------------- {{{1\n \n-void WarnMacFreeUnallocated(uptr addr, uptr zone_ptr, const char *zone_name,\n-                            BufferedStackTrace *stack) {\n-  // Just print a warning here.\n-  Printf(\"free_common(%p) -- attempting to free unallocated memory.\\n\"\n-             \"AddressSanitizer is ignoring this error on Mac OS now.\\n\",\n-             addr);\n-  PrintZoneForPointer(addr, zone_ptr, zone_name);\n-  stack->Print();\n-  DescribeHeapAddress(addr, 1);\n-}\n-\n void ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n                                BufferedStackTrace *stack) {\n   ScopedInErrorReport in_report;\n@@ -987,22 +363,26 @@ void ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n              addr);\n   PrintZoneForPointer(addr, zone_ptr, zone_name);\n   stack->Print();\n-  DescribeHeapAddress(addr, 1);\n+  DescribeAddressIfHeap(addr);\n }\n \n-void ReportMacCfReallocUnknown(uptr addr, uptr zone_ptr, const char *zone_name,\n-                               BufferedStackTrace *stack) {\n-  ScopedInErrorReport in_report;\n-  Printf(\"cf_realloc(%p) -- attempting to realloc unallocated memory.\\n\"\n-             \"This is an unrecoverable problem, exiting now.\\n\",\n-             addr);\n-  PrintZoneForPointer(addr, zone_ptr, zone_name);\n-  stack->Print();\n-  DescribeHeapAddress(addr, 1);\n+// -------------- SuppressErrorReport -------------- {{{1\n+// Avoid error reports duplicating for ASan recover mode.\n+static bool SuppressErrorReport(uptr pc) {\n+  if (!common_flags()->suppress_equal_pcs) return false;\n+  for (unsigned i = 0; i < kAsanBuggyPcPoolSize; i++) {\n+    uptr cmp = atomic_load_relaxed(&AsanBuggyPcPool[i]);\n+    if (cmp == 0 && atomic_compare_exchange_strong(&AsanBuggyPcPool[i], &cmp,\n+                                                   pc, memory_order_relaxed))\n+      return false;\n+    if (cmp == pc) return true;\n+  }\n+  Die();\n }\n \n void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n                         uptr access_size, u32 exp, bool fatal) {\n+  if (!fatal && SuppressErrorReport(pc)) return;\n   ENABLE_FRAME_POINTER;\n \n   // Optimization experiments.\n@@ -1014,87 +394,10 @@ void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n   // The reaction to a non-zero value of exp is to be defined.\n   (void)exp;\n \n-  // Determine the error type.\n-  const char *bug_descr = \"unknown-crash\";\n-  if (AddrIsInMem(addr)) {\n-    u8 *shadow_addr = (u8*)MemToShadow(addr);\n-    // If we are accessing 16 bytes, look at the second shadow byte.\n-    if (*shadow_addr == 0 && access_size > SHADOW_GRANULARITY)\n-      shadow_addr++;\n-    // If we are in the partial right redzone, look at the next shadow byte.\n-    if (*shadow_addr > 0 && *shadow_addr < 128)\n-      shadow_addr++;\n-    switch (*shadow_addr) {\n-      case kAsanHeapLeftRedzoneMagic:\n-      case kAsanHeapRightRedzoneMagic:\n-      case kAsanArrayCookieMagic:\n-        bug_descr = \"heap-buffer-overflow\";\n-        break;\n-      case kAsanHeapFreeMagic:\n-        bug_descr = \"heap-use-after-free\";\n-        break;\n-      case kAsanStackLeftRedzoneMagic:\n-        bug_descr = \"stack-buffer-underflow\";\n-        break;\n-      case kAsanInitializationOrderMagic:\n-        bug_descr = \"initialization-order-fiasco\";\n-        break;\n-      case kAsanStackMidRedzoneMagic:\n-      case kAsanStackRightRedzoneMagic:\n-      case kAsanStackPartialRedzoneMagic:\n-        bug_descr = \"stack-buffer-overflow\";\n-        break;\n-      case kAsanStackAfterReturnMagic:\n-        bug_descr = \"stack-use-after-return\";\n-        break;\n-      case kAsanUserPoisonedMemoryMagic:\n-        bug_descr = \"use-after-poison\";\n-        break;\n-      case kAsanContiguousContainerOOBMagic:\n-        bug_descr = \"container-overflow\";\n-        break;\n-      case kAsanStackUseAfterScopeMagic:\n-        bug_descr = \"stack-use-after-scope\";\n-        break;\n-      case kAsanGlobalRedzoneMagic:\n-        bug_descr = \"global-buffer-overflow\";\n-        break;\n-      case kAsanIntraObjectRedzone:\n-        bug_descr = \"intra-object-overflow\";\n-        break;\n-      case kAsanAllocaLeftMagic:\n-      case kAsanAllocaRightMagic:\n-        bug_descr = \"dynamic-stack-buffer-overflow\";\n-        break;\n-    }\n-  }\n-\n-  ReportData report = { pc, sp, bp, addr, (bool)is_write, access_size,\n-                        bug_descr };\n-  ScopedInErrorReport in_report(&report, fatal);\n-\n-  Decorator d;\n-  Printf(\"%s\", d.Warning());\n-  Report(\"ERROR: AddressSanitizer: %s on address \"\n-             \"%p at pc %p bp %p sp %p\\n\",\n-             bug_descr, (void*)addr, pc, bp, sp);\n-  Printf(\"%s\", d.EndWarning());\n-\n-  u32 curr_tid = GetCurrentTidOrInvalid();\n-  char tname[128];\n-  Printf(\"%s%s of size %zu at %p thread T%d%s%s\\n\",\n-         d.Access(),\n-         access_size ? (is_write ? \"WRITE\" : \"READ\") : \"ACCESS\",\n-         access_size, (void*)addr, curr_tid,\n-         ThreadNameWithParenthesis(curr_tid, tname, sizeof(tname)),\n-         d.EndAccess());\n-\n-  GET_STACK_TRACE_FATAL(pc, bp);\n-  stack.Print();\n-\n-  DescribeAddress(addr, access_size, bug_descr);\n-  ReportErrorSummary(bug_descr, &stack);\n-  PrintShadowMemoryForAddress(addr);\n+  ScopedInErrorReport in_report(fatal);\n+  ErrorGeneric error(GetCurrentTidOrInvalid(), pc, bp, sp, addr, is_write,\n+                     access_size);\n+  in_report.ReportError(error);\n }\n \n }  // namespace __asan\n@@ -1110,52 +413,62 @@ void __asan_report_error(uptr pc, uptr bp, uptr sp, uptr addr, int is_write,\n }\n \n void NOINLINE __asan_set_error_report_callback(void (*callback)(const char*)) {\n+  BlockingMutexLock l(&error_message_buf_mutex);\n   error_report_callback = callback;\n-  if (callback) {\n-    error_message_buffer_size = 1 << 16;\n-    error_message_buffer =\n-        (char*)MmapOrDie(error_message_buffer_size, __func__);\n-    error_message_buffer_pos = 0;\n-  }\n }\n \n void __asan_describe_address(uptr addr) {\n   // Thread registry must be locked while we're describing an address.\n   asanThreadRegistry().Lock();\n-  DescribeAddress(addr, 1, \"\");\n+  PrintAddressDescription(addr, 1, \"\");\n   asanThreadRegistry().Unlock();\n }\n \n int __asan_report_present() {\n-  return report_happened ? 1 : 0;\n+  return ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric;\n }\n \n uptr __asan_get_report_pc() {\n-  return report_data.pc;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.pc;\n+  return 0;\n }\n \n uptr __asan_get_report_bp() {\n-  return report_data.bp;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.bp;\n+  return 0;\n }\n \n uptr __asan_get_report_sp() {\n-  return report_data.sp;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.sp;\n+  return 0;\n }\n \n uptr __asan_get_report_address() {\n-  return report_data.addr;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError()\n+        .Generic.addr_description.Address();\n+  return 0;\n }\n \n int __asan_get_report_access_type() {\n-  return report_data.is_write ? 1 : 0;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.is_write;\n+  return 0;\n }\n \n uptr __asan_get_report_access_size() {\n-  return report_data.access_size;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.access_size;\n+  return 0;\n }\n \n const char *__asan_get_report_description() {\n-  return report_data.description;\n+  if (ScopedInErrorReport::CurrentError().kind == kErrorKindGeneric)\n+    return ScopedInErrorReport::CurrentError().Generic.bug_descr;\n+  return nullptr;\n }\n \n extern \"C\" {"}, {"sha": "111b8400153932c643443fb7c00c7586a6600b5f", "filename": "libsanitizer/asan/asan_report.h", "status": "modified", "additions": 9, "deletions": 17, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_report.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -23,34 +23,28 @@ struct StackVarDescr {\n   uptr name_len;\n };\n \n-struct AddressDescription {\n-  char *name;\n-  uptr name_size;\n-  uptr region_address;\n-  uptr region_size;\n-  const char *region_kind;\n-};\n-\n // Returns the number of globals close to the provided address and copies\n // them to \"globals\" array.\n int GetGlobalsForAddress(uptr addr, __asan_global *globals, u32 *reg_sites,\n                          int max_globals);\n-bool GetInfoForAddressIfGlobal(uptr addr, AddressDescription *descr);\n+\n+const char *MaybeDemangleGlobalName(const char *name);\n+void PrintGlobalNameIfASCII(InternalScopedString *str, const __asan_global &g);\n+void PrintGlobalLocation(InternalScopedString *str, const __asan_global &g);\n+\n+void PrintMemoryByte(InternalScopedString *str, const char *before, u8 byte,\n+                     bool in_shadow, const char *after = \"\\n\");\n+\n // The following functions prints address description depending\n // on the memory type (shadow/heap/stack/global).\n-void DescribeHeapAddress(uptr addr, uptr access_size);\n-bool DescribeAddressIfShadow(uptr addr, AddressDescription *descr = nullptr,\n-                             bool print = true);\n bool ParseFrameDescription(const char *frame_descr,\n                            InternalMmapVector<StackVarDescr> *vars);\n-bool DescribeAddressIfStack(uptr addr, uptr access_size);\n-void DescribeThread(AsanThreadContext *context);\n \n // Different kinds of error reports.\n void ReportGenericError(uptr pc, uptr bp, uptr sp, uptr addr, bool is_write,\n                         uptr access_size, u32 exp, bool fatal);\n void ReportStackOverflow(const SignalContext &sig);\n-void ReportDeadlySignal(const char *description, const SignalContext &sig);\n+void ReportDeadlySignal(int signo, const SignalContext &sig);\n void ReportNewDeleteSizeMismatch(uptr addr, uptr delete_size,\n                                  BufferedStackTrace *free_stack);\n void ReportDoubleFree(uptr addr, BufferedStackTrace *free_stack);\n@@ -75,8 +69,6 @@ void ReportODRViolation(const __asan_global *g1, u32 stack_id1,\n                         const __asan_global *g2, u32 stack_id2);\n \n // Mac-specific errors and warnings.\n-void WarnMacFreeUnallocated(uptr addr, uptr zone_ptr, const char *zone_name,\n-                            BufferedStackTrace *stack);\n void ReportMacMzReallocUnknown(uptr addr, uptr zone_ptr,\n                                const char *zone_name,\n                                BufferedStackTrace *stack);"}, {"sha": "38009d2905f29a3d48ea990bb0774fd0e0f5a221", "filename": "libsanitizer/asan/asan_rtl.cc", "status": "modified", "additions": 74, "deletions": 15, "changes": 89, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_rtl.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -30,6 +30,7 @@\n #include \"ubsan/ubsan_init.h\"\n #include \"ubsan/ubsan_platform.h\"\n \n+uptr __asan_shadow_memory_dynamic_address;  // Global interface symbol.\n int __asan_option_detect_stack_use_after_return;  // Global interface symbol.\n uptr *__asan_test_only_reported_buggy_pointer;  // Used only for testing asan.\n \n@@ -84,8 +85,8 @@ void ShowStatsAndAbort() {\n // Reserve memory range [beg, end].\n // We need to use inclusive range because end+1 may not be representable.\n void ReserveShadowMemoryRange(uptr beg, uptr end, const char *name) {\n-  CHECK_EQ((beg % GetPageSizeCached()), 0);\n-  CHECK_EQ(((end + 1) % GetPageSizeCached()), 0);\n+  CHECK_EQ((beg % GetMmapGranularity()), 0);\n+  CHECK_EQ(((end + 1) % GetMmapGranularity()), 0);\n   uptr size = end - beg + 1;\n   DecreaseTotalMmap(size);  // Don't count the shadow against mmap_limit_mb.\n   void *res = MmapFixedNoReserve(beg, size, name);\n@@ -261,6 +262,7 @@ static NOINLINE void force_interface_symbols() {\n   volatile int fake_condition = 0;  // prevent dead condition elimination.\n   // __asan_report_* functions are noreturn, so we need a switch to prevent\n   // the compiler from removing any of them.\n+  // clang-format off\n   switch (fake_condition) {\n     case 1: __asan_report_load1(0); break;\n     case 2: __asan_report_load2(0); break;\n@@ -300,7 +302,14 @@ static NOINLINE void force_interface_symbols() {\n     case 37: __asan_unpoison_stack_memory(0, 0); break;\n     case 38: __asan_region_is_poisoned(0, 0); break;\n     case 39: __asan_describe_address(0); break;\n+    case 40: __asan_set_shadow_00(0, 0); break;\n+    case 41: __asan_set_shadow_f1(0, 0); break;\n+    case 42: __asan_set_shadow_f2(0, 0); break;\n+    case 43: __asan_set_shadow_f3(0, 0); break;\n+    case 44: __asan_set_shadow_f5(0, 0); break;\n+    case 45: __asan_set_shadow_f8(0, 0); break;\n   }\n+  // clang-format on\n }\n \n static void asan_atexit() {\n@@ -318,26 +327,39 @@ static void InitializeHighMemEnd() {\n   kHighMemEnd = GetMaxVirtualAddress();\n   // Increase kHighMemEnd to make sure it's properly\n   // aligned together with kHighMemBeg:\n-  kHighMemEnd |= SHADOW_GRANULARITY * GetPageSizeCached() - 1;\n+  kHighMemEnd |= SHADOW_GRANULARITY * GetMmapGranularity() - 1;\n #endif  // !ASAN_FIXED_MAPPING\n-  CHECK_EQ((kHighMemBeg % GetPageSizeCached()), 0);\n+  CHECK_EQ((kHighMemBeg % GetMmapGranularity()), 0);\n }\n \n static void ProtectGap(uptr addr, uptr size) {\n-  if (!flags()->protect_shadow_gap)\n+  if (!flags()->protect_shadow_gap) {\n+    // The shadow gap is unprotected, so there is a chance that someone\n+    // is actually using this memory. Which means it needs a shadow...\n+    uptr GapShadowBeg = RoundDownTo(MEM_TO_SHADOW(addr), GetPageSizeCached());\n+    uptr GapShadowEnd =\n+        RoundUpTo(MEM_TO_SHADOW(addr + size), GetPageSizeCached()) - 1;\n+    if (Verbosity())\n+      Printf(\"protect_shadow_gap=0:\"\n+             \" not protecting shadow gap, allocating gap's shadow\\n\"\n+             \"|| `[%p, %p]` || ShadowGap's shadow ||\\n\", GapShadowBeg,\n+             GapShadowEnd);\n+    ReserveShadowMemoryRange(GapShadowBeg, GapShadowEnd,\n+                             \"unprotected gap shadow\");\n     return;\n-  void *res = MmapNoAccess(addr, size, \"shadow gap\");\n+  }\n+  void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n   if (addr == (uptr)res)\n     return;\n   // A few pages at the start of the address space can not be protected.\n   // But we really want to protect as much as possible, to prevent this memory\n   // being returned as a result of a non-FIXED mmap().\n   if (addr == kZeroBaseShadowStart) {\n-    uptr step = GetPageSizeCached();\n+    uptr step = GetMmapGranularity();\n     while (size > step && addr < kZeroBaseMaxShadowStart) {\n       addr += step;\n       size -= step;\n-      void *res = MmapNoAccess(addr, size, \"shadow gap\");\n+      void *res = MmapFixedNoAccess(addr, size, \"shadow gap\");\n       if (addr == (uptr)res)\n         return;\n     }\n@@ -413,10 +435,13 @@ static void AsanInitInternal() {\n \n   AsanCheckIncompatibleRT();\n   AsanCheckDynamicRTPrereqs();\n+  AvoidCVE_2016_2143();\n \n   SetCanPoisonMemory(flags()->poison_heap);\n   SetMallocContextSize(common_flags()->malloc_context_size);\n \n+  InitializePlatformExceptionHandlers();\n+\n   InitializeHighMemEnd();\n \n   // Make sure we are not statically linked.\n@@ -429,7 +454,6 @@ static void AsanInitInternal() {\n \n   __sanitizer_set_report_path(common_flags()->log_path);\n \n-  // Enable UAR detection, if required.\n   __asan_option_detect_stack_use_after_return =\n       flags()->detect_stack_use_after_return;\n \n@@ -448,7 +472,30 @@ static void AsanInitInternal() {\n \n   ReplaceSystemMalloc();\n \n+  // Set the shadow memory address to uninitialized.\n+  __asan_shadow_memory_dynamic_address = kDefaultShadowSentinel;\n+\n   uptr shadow_start = kLowShadowBeg;\n+  // Detect if a dynamic shadow address must used and find a available location\n+  // when necessary. When dynamic address is used, the macro |kLowShadowBeg|\n+  // expands to |__asan_shadow_memory_dynamic_address| which is\n+  // |kDefaultShadowSentinel|.\n+  if (shadow_start == kDefaultShadowSentinel) {\n+    __asan_shadow_memory_dynamic_address = 0;\n+    CHECK_EQ(0, kLowShadowBeg);\n+\n+    uptr granularity = GetMmapGranularity();\n+    uptr alignment = 8 * granularity;\n+    uptr left_padding = granularity;\n+    uptr space_size = kHighShadowEnd + left_padding;\n+\n+    shadow_start = FindAvailableMemoryRange(space_size, alignment, granularity);\n+    CHECK_NE((uptr)0, shadow_start);\n+    CHECK(IsAligned(shadow_start, alignment));\n+  }\n+  // Update the shadow memory address (potentially) used by instrumentation.\n+  __asan_shadow_memory_dynamic_address = shadow_start;\n+\n   if (kLowShadowBeg)\n     shadow_start -= GetMmapGranularity();\n   bool full_shadow_is_available =\n@@ -537,19 +584,28 @@ static void AsanInitInternal() {\n   force_interface_symbols();  // no-op.\n   SanitizerInitializeUnwinder();\n \n-#if CAN_SANITIZE_LEAKS\n-  __lsan::InitCommonLsan();\n-  if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n-    Atexit(__lsan::DoLeakCheck);\n+  if (CAN_SANITIZE_LEAKS) {\n+    __lsan::InitCommonLsan();\n+    if (common_flags()->detect_leaks && common_flags()->leak_check_at_exit) {\n+      Atexit(__lsan::DoLeakCheck);\n+    }\n   }\n-#endif  // CAN_SANITIZE_LEAKS\n \n #if CAN_SANITIZE_UB\n   __ubsan::InitAsPlugin();\n #endif\n \n   InitializeSuppressions();\n \n+  if (CAN_SANITIZE_LEAKS) {\n+    // LateInitialize() calls dlsym, which can allocate an error string buffer\n+    // in the TLS.  Let's ignore the allocation to avoid reporting a leak.\n+    __lsan::ScopedInterceptorDisabler disabler;\n+    Symbolizer::LateInitialize();\n+  } else {\n+    Symbolizer::LateInitialize();\n+  }\n+\n   VReport(1, \"AddressSanitizer Init done\\n\");\n }\n \n@@ -579,6 +635,9 @@ static AsanInitializer asan_initializer;\n using namespace __asan;  // NOLINT\n \n void NOINLINE __asan_handle_no_return() {\n+  if (asan_init_is_running)\n+    return;\n+\n   int local_stack;\n   AsanThread *curr_thread = GetCurrentThread();\n   uptr PageSize = GetPageSizeCached();\n@@ -603,7 +662,7 @@ void NOINLINE __asan_handle_no_return() {\n            \"stack top: %p; bottom %p; size: %p (%zd)\\n\"\n            \"False positive error reports may follow\\n\"\n            \"For details see \"\n-           \"http://code.google.com/p/address-sanitizer/issues/detail?id=189\\n\",\n+           \"https://github.com/google/sanitizers/issues/189\\n\",\n            top, bottom, top - bottom, top - bottom);\n     return;\n   }"}, {"sha": "d72fce69d6421722dd6ee9e22ed814910da670c9", "filename": "libsanitizer/asan/asan_scariness_score.h", "status": "added", "additions": 72, "deletions": 0, "changes": 72, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_scariness_score.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_scariness_score.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_scariness_score.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,72 @@\n+//===-- asan_scariness_score.h ----------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of AddressSanitizer, an address sanity checker.\n+//\n+// Compute the level of scariness of the error message.\n+// Don't expect any deep science here, just a set of heuristics that suggest\n+// that e.g. 1-byte-read-global-buffer-overflow is less scary than\n+// 8-byte-write-stack-use-after-return.\n+//\n+// Every error report has one or more features, such as memory access size,\n+// type (read or write), type of accessed memory (e.g. free-d heap, or a global\n+// redzone), etc. Every such feature has an int score and a string description.\n+// The overall score is the sum of all feature scores and the description\n+// is a concatenation of feature descriptions.\n+// Examples:\n+//  17 (4-byte-read-heap-buffer-overflow)\n+//  65 (multi-byte-write-stack-use-after-return)\n+//  10 (null-deref)\n+//\n+//===----------------------------------------------------------------------===//\n+\n+#ifndef ASAN_SCARINESS_SCORE_H\n+#define ASAN_SCARINESS_SCORE_H\n+\n+#include \"asan_flags.h\"\n+#include \"sanitizer_common/sanitizer_common.h\"\n+#include \"sanitizer_common/sanitizer_libc.h\"\n+\n+namespace __asan {\n+struct ScarinessScoreBase {\n+  void Clear() {\n+    descr[0] = 0;\n+    score = 0;\n+  }\n+  void Scare(int add_to_score, const char *reason) {\n+    if (descr[0])\n+      internal_strlcat(descr, \"-\", sizeof(descr));\n+    internal_strlcat(descr, reason, sizeof(descr));\n+    score += add_to_score;\n+  };\n+  int GetScore() const { return score; }\n+  const char *GetDescription() const { return descr; }\n+  void Print() {\n+    if (score && flags()->print_scariness)\n+      Printf(\"SCARINESS: %d (%s)\\n\", score, descr);\n+  }\n+  static void PrintSimple(int score, const char *descr) {\n+    ScarinessScoreBase SSB;\n+    SSB.Clear();\n+    SSB.Scare(score, descr);\n+    SSB.Print();\n+  }\n+\n+ private:\n+  int score;\n+  char descr[1024];\n+};\n+\n+struct ScarinessScore : ScarinessScoreBase {\n+  ScarinessScore() {\n+    Clear();\n+  }\n+};\n+\n+}  // namespace __asan\n+\n+#endif  // ASAN_SCARINESS_SCORE_H"}, {"sha": "2b8738156ea00b65f0b6ef1ec3417b77961709dd", "filename": "libsanitizer/asan/asan_stack.h", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_stack.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_stack.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_stack.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -46,7 +46,10 @@ void GetStackTraceWithPcBpAndContext(BufferedStackTrace *stack, uptr max_depth,\n       uptr stack_top = t->stack_top();\n       uptr stack_bottom = t->stack_bottom();\n       ScopedUnwinding unwind_scope(t);\n-      stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom, fast);\n+      if (!SANITIZER_MIPS || IsValidFrame(bp, stack_top, stack_bottom)) {\n+        stack->Unwind(max_depth, pc, bp, context, stack_top, stack_bottom,\n+                      fast);\n+      }\n     } else if (!t && !fast) {\n       /* If GetCurrentThread() has failed, try to do slow unwind anyways. */\n       stack->Unwind(max_depth, pc, bp, context, 0, 0, false);"}, {"sha": "1dc9d474240d8abe1f611c32a7e75e6f5fc83523", "filename": "libsanitizer/asan/asan_suppressions.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_suppressions.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -87,6 +87,7 @@ bool IsStackTraceSuppressed(const StackTrace *stack) {\n \n     if (suppression_ctx->HasSuppressionType(kInterceptorViaFunction)) {\n       SymbolizedStack *frames = symbolizer->SymbolizePC(addr);\n+      CHECK(frames);\n       for (SymbolizedStack *cur = frames; cur; cur = cur->next) {\n         const char *function_name = cur->info.function;\n         if (!function_name) {"}, {"sha": "818e1261400515e65bb6625fef5091672f5829cb", "filename": "libsanitizer/asan/asan_thread.cc", "status": "modified", "additions": 117, "deletions": 6, "changes": 123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -118,6 +118,77 @@ void AsanThread::Destroy() {\n   DTLS_Destroy();\n }\n \n+void AsanThread::StartSwitchFiber(FakeStack **fake_stack_save, uptr bottom,\n+                                  uptr size) {\n+  if (atomic_load(&stack_switching_, memory_order_relaxed)) {\n+    Report(\"ERROR: starting fiber switch while in fiber switch\\n\");\n+    Die();\n+  }\n+\n+  next_stack_bottom_ = bottom;\n+  next_stack_top_ = bottom + size;\n+  atomic_store(&stack_switching_, 1, memory_order_release);\n+\n+  FakeStack *current_fake_stack = fake_stack_;\n+  if (fake_stack_save)\n+    *fake_stack_save = fake_stack_;\n+  fake_stack_ = nullptr;\n+  SetTLSFakeStack(nullptr);\n+  // if fake_stack_save is null, the fiber will die, delete the fakestack\n+  if (!fake_stack_save && current_fake_stack)\n+    current_fake_stack->Destroy(this->tid());\n+}\n+\n+void AsanThread::FinishSwitchFiber(FakeStack *fake_stack_save,\n+                                   uptr *bottom_old,\n+                                   uptr *size_old) {\n+  if (!atomic_load(&stack_switching_, memory_order_relaxed)) {\n+    Report(\"ERROR: finishing a fiber switch that has not started\\n\");\n+    Die();\n+  }\n+\n+  if (fake_stack_save) {\n+    SetTLSFakeStack(fake_stack_save);\n+    fake_stack_ = fake_stack_save;\n+  }\n+\n+  if (bottom_old)\n+    *bottom_old = stack_bottom_;\n+  if (size_old)\n+    *size_old = stack_top_ - stack_bottom_;\n+  stack_bottom_ = next_stack_bottom_;\n+  stack_top_ = next_stack_top_;\n+  atomic_store(&stack_switching_, 0, memory_order_release);\n+  next_stack_top_ = 0;\n+  next_stack_bottom_ = 0;\n+}\n+\n+inline AsanThread::StackBounds AsanThread::GetStackBounds() const {\n+  if (!atomic_load(&stack_switching_, memory_order_acquire))\n+    return StackBounds{stack_bottom_, stack_top_};  // NOLINT\n+  char local;\n+  const uptr cur_stack = (uptr)&local;\n+  // Note: need to check next stack first, because FinishSwitchFiber\n+  // may be in process of overwriting stack_top_/bottom_. But in such case\n+  // we are already on the next stack.\n+  if (cur_stack >= next_stack_bottom_ && cur_stack < next_stack_top_)\n+    return StackBounds{next_stack_bottom_, next_stack_top_};  // NOLINT\n+  return StackBounds{stack_bottom_, stack_top_};              // NOLINT\n+}\n+\n+uptr AsanThread::stack_top() {\n+  return GetStackBounds().top;\n+}\n+\n+uptr AsanThread::stack_bottom() {\n+  return GetStackBounds().bottom;\n+}\n+\n+uptr AsanThread::stack_size() {\n+  const auto bounds = GetStackBounds();\n+  return bounds.top - bounds.bottom;\n+}\n+\n // We want to create the FakeStack lazyly on the first use, but not eralier\n // than the stack size is known and the procedure has to be async-signal safe.\n FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n@@ -148,6 +219,8 @@ FakeStack *AsanThread::AsyncSignalSafeLazyInitFakeStack() {\n }\n \n void AsanThread::Init() {\n+  next_stack_top_ = next_stack_bottom_ = 0;\n+  atomic_store(&stack_switching_, false, memory_order_release);\n   fake_stack_ = nullptr;  // Will be initialized lazily if needed.\n   CHECK_EQ(this->stack_size(), 0U);\n   SetThreadStackAndTls();\n@@ -193,10 +266,12 @@ thread_return_t AsanThread::ThreadStart(\n \n void AsanThread::SetThreadStackAndTls() {\n   uptr tls_size = 0;\n-  GetThreadStackAndTls(tid() == 0, &stack_bottom_, &stack_size_, &tls_begin_,\n-                       &tls_size);\n-  stack_top_ = stack_bottom_ + stack_size_;\n+  uptr stack_size = 0;\n+  GetThreadStackAndTls(tid() == 0, const_cast<uptr *>(&stack_bottom_),\n+                       const_cast<uptr *>(&stack_size), &tls_begin_, &tls_size);\n+  stack_top_ = stack_bottom_ + stack_size;\n   tls_end_ = tls_begin_ + tls_size;\n+  dtls_ = DTLS_Get();\n \n   int local;\n   CHECK(AddrIsInStack((uptr)&local));\n@@ -247,6 +322,11 @@ bool AsanThread::GetStackFrameAccessByAddr(uptr addr,\n   return true;\n }\n \n+bool AsanThread::AddrIsInStack(uptr addr) {\n+  const auto bounds = GetStackBounds();\n+  return addr >= bounds.bottom && addr < bounds.top;\n+}\n+\n static bool ThreadStackContainsAddress(ThreadContextBase *tctx_base,\n                                        void *addr) {\n   AsanThreadContext *tctx = static_cast<AsanThreadContext*>(tctx_base);\n@@ -269,7 +349,7 @@ AsanThread *GetCurrentThread() {\n       // limits, so only do this magic on Android, and only if the found thread\n       // is the main thread.\n       AsanThreadContext *tctx = GetThreadContextByTidLocked(0);\n-      if (ThreadStackContainsAddress(tctx, &context)) {\n+      if (tctx && ThreadStackContainsAddress(tctx, &context)) {\n         SetCurrentThread(tctx->thread);\n         return tctx->thread;\n       }\n@@ -320,8 +400,8 @@ __asan::AsanThread *GetAsanThreadByOsIDLocked(uptr os_id) {\n // --- Implementation of LSan-specific functions --- {{{1\n namespace __lsan {\n bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n-                           uptr *tls_begin, uptr *tls_end,\n-                           uptr *cache_begin, uptr *cache_end) {\n+                           uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n+                           uptr *cache_end, DTLS **dtls) {\n   __asan::AsanThread *t = __asan::GetAsanThreadByOsIDLocked(os_id);\n   if (!t) return false;\n   *stack_begin = t->stack_bottom();\n@@ -331,6 +411,7 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   // ASan doesn't keep allocator caches in TLS, so these are unused.\n   *cache_begin = 0;\n   *cache_end = 0;\n+  *dtls = t->dtls();\n   return true;\n }\n \n@@ -353,3 +434,33 @@ void EnsureMainThreadIDIsCorrect() {\n   __asan::EnsureMainThreadIDIsCorrect();\n }\n } // namespace __lsan\n+\n+// ---------------------- Interface ---------------- {{{1\n+using namespace __asan;  // NOLINT\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_start_switch_fiber(void **fakestacksave, const void *bottom,\n+                                    uptr size) {\n+  AsanThread *t = GetCurrentThread();\n+  if (!t) {\n+    VReport(1, \"__asan_start_switch_fiber called from unknown thread\\n\");\n+    return;\n+  }\n+  t->StartSwitchFiber((FakeStack**)fakestacksave, (uptr)bottom, size);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_finish_switch_fiber(void* fakestack,\n+                                     const void **bottom_old,\n+                                     uptr *size_old) {\n+  AsanThread *t = GetCurrentThread();\n+  if (!t) {\n+    VReport(1, \"__asan_finish_switch_fiber called from unknown thread\\n\");\n+    return;\n+  }\n+  t->FinishSwitchFiber((FakeStack*)fakestack,\n+                       (uptr*)bottom_old,\n+                       (uptr*)size_old);\n+}\n+}"}, {"sha": "c51a58ad0bb870004e56e1bda6c1acafe6444ab7", "filename": "libsanitizer/asan/asan_thread.h", "status": "modified", "additions": 31, "deletions": 10, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_thread.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -21,6 +21,10 @@\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n \n+namespace __sanitizer {\n+struct DTLS;\n+}  // namespace __sanitizer\n+\n namespace __asan {\n \n const u32 kInvalidTid = 0xffffff;  // Must fit into 24 bits.\n@@ -60,11 +64,12 @@ class AsanThread {\n   thread_return_t ThreadStart(uptr os_id,\n                               atomic_uintptr_t *signal_thread_is_registered);\n \n-  uptr stack_top() { return stack_top_; }\n-  uptr stack_bottom() { return stack_bottom_; }\n-  uptr stack_size() { return stack_size_; }\n+  uptr stack_top();\n+  uptr stack_bottom();\n+  uptr stack_size();\n   uptr tls_begin() { return tls_begin_; }\n   uptr tls_end() { return tls_end_; }\n+  DTLS *dtls() { return dtls_; }\n   u32 tid() { return context_->tid; }\n   AsanThreadContext *context() { return context_; }\n   void set_context(AsanThreadContext *context) { context_ = context; }\n@@ -76,9 +81,7 @@ class AsanThread {\n   };\n   bool GetStackFrameAccessByAddr(uptr addr, StackFrameAccess *access);\n \n-  bool AddrIsInStack(uptr addr) {\n-    return addr >= stack_bottom_ && addr < stack_top_;\n-  }\n+  bool AddrIsInStack(uptr addr);\n \n   void DeleteFakeStack(int tid) {\n     if (!fake_stack_) return;\n@@ -88,13 +91,20 @@ class AsanThread {\n     t->Destroy(tid);\n   }\n \n+  void StartSwitchFiber(FakeStack **fake_stack_save, uptr bottom, uptr size);\n+  void FinishSwitchFiber(FakeStack *fake_stack_save, uptr *bottom_old,\n+                         uptr *size_old);\n+\n   bool has_fake_stack() {\n-    return (reinterpret_cast<uptr>(fake_stack_) > 1);\n+    return !atomic_load(&stack_switching_, memory_order_relaxed) &&\n+           (reinterpret_cast<uptr>(fake_stack_) > 1);\n   }\n \n   FakeStack *fake_stack() {\n     if (!__asan_option_detect_stack_use_after_return)\n       return nullptr;\n+    if (atomic_load(&stack_switching_, memory_order_relaxed))\n+      return nullptr;\n     if (!has_fake_stack())\n       return AsyncSignalSafeLazyInitFakeStack();\n     return fake_stack_;\n@@ -120,16 +130,27 @@ class AsanThread {\n   void ClearShadowForThreadStackAndTLS();\n   FakeStack *AsyncSignalSafeLazyInitFakeStack();\n \n+  struct StackBounds {\n+    uptr bottom;\n+    uptr top;\n+  };\n+  StackBounds GetStackBounds() const;\n+\n   AsanThreadContext *context_;\n   thread_callback_t start_routine_;\n   void *arg_;\n+\n   uptr stack_top_;\n   uptr stack_bottom_;\n-  // stack_size_ == stack_top_ - stack_bottom_;\n-  // It needs to be set in a async-signal-safe manner.\n-  uptr stack_size_;\n+  // these variables are used when the thread is about to switch stack\n+  uptr next_stack_top_;\n+  uptr next_stack_bottom_;\n+  // true if switching is in progress\n+  atomic_uint8_t stack_switching_;\n+\n   uptr tls_begin_;\n   uptr tls_end_;\n+  DTLS *dtls_;\n \n   FakeStack *fake_stack_;\n   AsanThreadLocalMallocStorage malloc_storage_;"}, {"sha": "efd82bfc3b0a6408fd1fa70fa1ba01234a1464cb", "filename": "libsanitizer/asan/asan_win.cc", "status": "modified", "additions": 148, "deletions": 58, "changes": 206, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -22,6 +22,7 @@\n #include \"asan_report.h\"\n #include \"asan_stack.h\"\n #include \"asan_thread.h\"\n+#include \"asan_mapping.h\"\n #include \"sanitizer_common/sanitizer_libc.h\"\n #include \"sanitizer_common/sanitizer_mutex.h\"\n \n@@ -34,7 +35,13 @@ int __asan_should_detect_stack_use_after_return() {\n   return __asan_option_detect_stack_use_after_return;\n }\n \n-// -------------------- A workaround for the abscence of weak symbols ----- {{{\n+SANITIZER_INTERFACE_ATTRIBUTE\n+uptr __asan_get_shadow_memory_dynamic_address() {\n+  __asan_init();\n+  return __asan_shadow_memory_dynamic_address;\n+}\n+\n+// -------------------- A workaround for the absence of weak symbols ----- {{{\n // We don't have a direct equivalent of weak symbols when using MSVC, but we can\n // use the /alternatename directive to tell the linker to default a specific\n // symbol to a specific value, which works nicely for allocator hooks and\n@@ -44,21 +51,49 @@ void __sanitizer_default_free_hook(void *ptr) { }\n const char* __asan_default_default_options() { return \"\"; }\n const char* __asan_default_default_suppressions() { return \"\"; }\n void __asan_default_on_error() {}\n+// 64-bit msvc will not prepend an underscore for symbols.\n+#ifdef _WIN64\n+#pragma comment(linker, \"/alternatename:__sanitizer_malloc_hook=__sanitizer_default_malloc_hook\")  // NOLINT\n+#pragma comment(linker, \"/alternatename:__sanitizer_free_hook=__sanitizer_default_free_hook\")      // NOLINT\n+#pragma comment(linker, \"/alternatename:__asan_default_options=__asan_default_default_options\")    // NOLINT\n+#pragma comment(linker, \"/alternatename:__asan_default_suppressions=__asan_default_default_suppressions\")    // NOLINT\n+#pragma comment(linker, \"/alternatename:__asan_on_error=__asan_default_on_error\")                  // NOLINT\n+#else\n #pragma comment(linker, \"/alternatename:___sanitizer_malloc_hook=___sanitizer_default_malloc_hook\")  // NOLINT\n #pragma comment(linker, \"/alternatename:___sanitizer_free_hook=___sanitizer_default_free_hook\")      // NOLINT\n #pragma comment(linker, \"/alternatename:___asan_default_options=___asan_default_default_options\")    // NOLINT\n #pragma comment(linker, \"/alternatename:___asan_default_suppressions=___asan_default_default_suppressions\")    // NOLINT\n #pragma comment(linker, \"/alternatename:___asan_on_error=___asan_default_on_error\")                  // NOLINT\n+#endif\n // }}}\n }  // extern \"C\"\n \n-// ---------------------- Windows-specific inteceptors ---------------- {{{\n+// ---------------------- Windows-specific interceptors ---------------- {{{\n+INTERCEPTOR_WINAPI(void, RtlRaiseException, EXCEPTION_RECORD *ExceptionRecord) {\n+  CHECK(REAL(RtlRaiseException));\n+  // This is a noreturn function, unless it's one of the exceptions raised to\n+  // communicate with the debugger, such as the one from OutputDebugString.\n+  if (ExceptionRecord->ExceptionCode != DBG_PRINTEXCEPTION_C)\n+    __asan_handle_no_return();\n+  REAL(RtlRaiseException)(ExceptionRecord);\n+}\n+\n INTERCEPTOR_WINAPI(void, RaiseException, void *a, void *b, void *c, void *d) {\n   CHECK(REAL(RaiseException));\n   __asan_handle_no_return();\n   REAL(RaiseException)(a, b, c, d);\n }\n \n+#ifdef _WIN64\n+\n+INTERCEPTOR_WINAPI(int, __C_specific_handler, void *a, void *b, void *c, void *d) {  // NOLINT\n+  CHECK(REAL(__C_specific_handler));\n+  __asan_handle_no_return();\n+  return REAL(__C_specific_handler)(a, b, c, d);\n+}\n+\n+#else\n+\n INTERCEPTOR(int, _except_handler3, void *a, void *b, void *c, void *d) {\n   CHECK(REAL(_except_handler3));\n   __asan_handle_no_return();\n@@ -74,6 +109,7 @@ INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n   __asan_handle_no_return();\n   return REAL(_except_handler4)(a, b, c, d);\n }\n+#endif\n \n static thread_return_t THREAD_CALLING_CONV asan_thread_start(void *arg) {\n   AsanThread *t = (AsanThread*)arg;\n@@ -99,52 +135,33 @@ INTERCEPTOR_WINAPI(DWORD, CreateThread,\n                             asan_thread_start, t, thr_flags, tid);\n }\n \n-namespace {\n-BlockingMutex mu_for_thread_tracking(LINKER_INITIALIZED);\n-\n-void EnsureWorkerThreadRegistered() {\n-  // FIXME: GetCurrentThread relies on TSD, which might not play well with\n-  // system thread pools.  We might want to use something like reference\n-  // counting to zero out GetCurrentThread() underlying storage when the last\n-  // work item finishes?  Or can we disable reclaiming of threads in the pool?\n-  BlockingMutexLock l(&mu_for_thread_tracking);\n-  if (__asan::GetCurrentThread())\n-    return;\n-\n-  AsanThread *t = AsanThread::Create(\n-      /* start_routine */ nullptr, /* arg */ nullptr,\n-      /* parent_tid */ -1, /* stack */ nullptr, /* detached */ true);\n-  t->Init();\n-  asanThreadRegistry().StartThread(t->tid(), 0, 0);\n-  SetCurrentThread(t);\n-}\n-}  // namespace\n-\n-INTERCEPTOR_WINAPI(DWORD, NtWaitForWorkViaWorkerFactory, DWORD a, DWORD b) {\n-  // NtWaitForWorkViaWorkerFactory is called from system worker pool threads to\n-  // query work scheduled by BindIoCompletionCallback, QueueUserWorkItem, etc.\n-  // System worker pool threads are created at arbitraty point in time and\n-  // without using CreateThread, so we wrap NtWaitForWorkViaWorkerFactory\n-  // instead and don't register a specific parent_tid/stack.\n-  EnsureWorkerThreadRegistered();\n-  return REAL(NtWaitForWorkViaWorkerFactory)(a, b);\n-}\n-\n // }}}\n \n namespace __asan {\n \n void InitializePlatformInterceptors() {\n   ASAN_INTERCEPT_FUNC(CreateThread);\n-  ASAN_INTERCEPT_FUNC(RaiseException);\n+\n+#ifdef _WIN64\n+  ASAN_INTERCEPT_FUNC(__C_specific_handler);\n+#else\n   ASAN_INTERCEPT_FUNC(_except_handler3);\n   ASAN_INTERCEPT_FUNC(_except_handler4);\n+#endif\n+\n+  // Try to intercept kernel32!RaiseException, and if that fails, intercept\n+  // ntdll!RtlRaiseException instead.\n+  if (!::__interception::OverrideFunction(\"RaiseException\",\n+                                          (uptr)WRAP(RaiseException),\n+                                          (uptr *)&REAL(RaiseException))) {\n+    CHECK(::__interception::OverrideFunction(\"RtlRaiseException\",\n+                                             (uptr)WRAP(RtlRaiseException),\n+                                             (uptr *)&REAL(RtlRaiseException)));\n+  }\n+}\n \n-  // NtWaitForWorkViaWorkerFactory is always linked dynamically.\n-  CHECK(::__interception::OverrideFunction(\n-      \"NtWaitForWorkViaWorkerFactory\",\n-      (uptr)WRAP(NtWaitForWorkViaWorkerFactory),\n-      (uptr *)&REAL(NtWaitForWorkViaWorkerFactory)));\n+void AsanApplyToGlobals(globals_op_fptr op, const void *needle) {\n+  UNIMPLEMENTED();\n }\n \n // ---------------------- TSD ---------------- {{{\n@@ -173,14 +190,6 @@ void PlatformTSDDtor(void *tsd) {\n // }}}\n \n // ---------------------- Various stuff ---------------- {{{\n-void DisableReexec() {\n-  // No need to re-exec on Windows.\n-}\n-\n-void MaybeReexec() {\n-  // No need to re-exec on Windows.\n-}\n-\n void *AsanDoesNotSupportStaticLinkage() {\n #if defined(_DEBUG)\n #error Please build the runtime with a non-debug CRT: /MD or /MT\n@@ -200,20 +209,95 @@ void AsanOnDeadlySignal(int, void *siginfo, void *context) {\n   UNIMPLEMENTED();\n }\n \n+#if SANITIZER_WINDOWS64\n+// Exception handler for dealing with shadow memory.\n+static LONG CALLBACK\n+ShadowExceptionHandler(PEXCEPTION_POINTERS exception_pointers) {\n+  uptr page_size = GetPageSizeCached();\n+  // Only handle access violations.\n+  if (exception_pointers->ExceptionRecord->ExceptionCode !=\n+      EXCEPTION_ACCESS_VIOLATION) {\n+    return EXCEPTION_CONTINUE_SEARCH;\n+  }\n+\n+  // Only handle access violations that land within the shadow memory.\n+  uptr addr =\n+      (uptr)(exception_pointers->ExceptionRecord->ExceptionInformation[1]);\n+\n+  // Check valid shadow range.\n+  if (!AddrIsInShadow(addr)) return EXCEPTION_CONTINUE_SEARCH;\n+\n+  // This is an access violation while trying to read from the shadow. Commit\n+  // the relevant page and let execution continue.\n+\n+  // Determine the address of the page that is being accessed.\n+  uptr page = RoundDownTo(addr, page_size);\n+\n+  // Query the existing page.\n+  MEMORY_BASIC_INFORMATION mem_info = {};\n+  if (::VirtualQuery((LPVOID)page, &mem_info, sizeof(mem_info)) == 0)\n+    return EXCEPTION_CONTINUE_SEARCH;\n+\n+  // Commit the page.\n+  uptr result =\n+      (uptr)::VirtualAlloc((LPVOID)page, page_size, MEM_COMMIT, PAGE_READWRITE);\n+  if (result != page) return EXCEPTION_CONTINUE_SEARCH;\n+\n+  // The page mapping succeeded, so continue execution as usual.\n+  return EXCEPTION_CONTINUE_EXECUTION;\n+}\n+\n+#endif\n+\n+void InitializePlatformExceptionHandlers() {\n+#if SANITIZER_WINDOWS64\n+  // On Win64, we map memory on demand with access violation handler.\n+  // Install our exception handler.\n+  CHECK(AddVectoredExceptionHandler(TRUE, &ShadowExceptionHandler));\n+#endif\n+}\n+\n static LPTOP_LEVEL_EXCEPTION_FILTER default_seh_handler;\n \n+// Check based on flags if we should report this exception.\n+static bool ShouldReportDeadlyException(unsigned code) {\n+  switch (code) {\n+    case EXCEPTION_ACCESS_VIOLATION:\n+    case EXCEPTION_IN_PAGE_ERROR:\n+      return common_flags()->handle_segv;\n+    case EXCEPTION_BREAKPOINT:\n+    case EXCEPTION_ILLEGAL_INSTRUCTION: {\n+      return common_flags()->handle_sigill;\n+    }\n+  }\n+  return false;\n+}\n+\n+// Return the textual name for this exception.\n+const char *DescribeSignalOrException(int signo) {\n+  unsigned code = signo;\n+  // Get the string description of the exception if this is a known deadly\n+  // exception.\n+  switch (code) {\n+    case EXCEPTION_ACCESS_VIOLATION:\n+      return \"access-violation\";\n+    case EXCEPTION_IN_PAGE_ERROR:\n+      return \"in-page-error\";\n+    case EXCEPTION_BREAKPOINT:\n+      return \"breakpoint\";\n+    case EXCEPTION_ILLEGAL_INSTRUCTION:\n+      return \"illegal-instruction\";\n+  }\n+  return nullptr;\n+}\n+\n static long WINAPI SEHHandler(EXCEPTION_POINTERS *info) {\n   EXCEPTION_RECORD *exception_record = info->ExceptionRecord;\n   CONTEXT *context = info->ContextRecord;\n \n-  if (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION ||\n-      exception_record->ExceptionCode == EXCEPTION_IN_PAGE_ERROR) {\n-    const char *description =\n-        (exception_record->ExceptionCode == EXCEPTION_ACCESS_VIOLATION)\n-            ? \"access-violation\"\n-            : \"in-page-error\";\n+  if (ShouldReportDeadlyException(exception_record->ExceptionCode)) {\n     SignalContext sig = SignalContext::Create(exception_record, context);\n-    ReportDeadlySignal(description, sig);\n+    ReportDeadlySignal(exception_record->ExceptionCode, sig);\n   }\n \n   // FIXME: Handle EXCEPTION_STACK_OVERFLOW here.\n@@ -248,10 +332,16 @@ int __asan_set_seh_filter() {\n }\n \n #if !ASAN_DYNAMIC\n-// Put a pointer to __asan_set_seh_filter at the end of the global list\n-// of C initializers, after the default EH is set by the CRT.\n-#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n-__declspec(allocate(\".CRT$XIZ\"))\n+// The CRT runs initializers in this order:\n+// - C initializers, from XIA to XIZ\n+// - C++ initializers, from XCA to XCZ\n+// Prior to 2015, the CRT set the unhandled exception filter at priority XIY,\n+// near the end of C initialization. Starting in 2015, it was moved to the\n+// beginning of C++ initialization. We set our priority to XCAB to run\n+// immediately after the CRT runs. This way, our exception filter is called\n+// first and we can delegate to their filter if appropriate.\n+#pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n+__declspec(allocate(\".CRT$XCAB\"))\n     int (*__intercept_seh)() = __asan_set_seh_filter;\n #endif\n // }}}"}, {"sha": "f7c9a37bf796d8c3603a0d7d07a3eec422437bcd", "filename": "libsanitizer/asan/asan_win_dll_thunk.cc", "status": "modified", "additions": 38, "deletions": 6, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dll_thunk.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -10,16 +10,16 @@\n // This file defines a family of thunks that should be statically linked into\n // the DLLs that have ASan instrumentation in order to delegate the calls to the\n // shared runtime that lives in the main binary.\n-// See https://code.google.com/p/address-sanitizer/issues/detail?id=209 for the\n-// details.\n+// See https://github.com/google/sanitizers/issues/209 for the details.\n //===----------------------------------------------------------------------===//\n \n-// Only compile this code when buidling asan_dll_thunk.lib\n+// Only compile this code when building asan_dll_thunk.lib\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DLL_THUNK\n #include \"asan_init_version.h\"\n #include \"interception/interception.h\"\n+#include \"sanitizer_common/sanitizer_platform_interceptors.h\"\n \n // ---------- Function interception helper functions and macros ----------- {{{1\n extern \"C\" {\n@@ -28,6 +28,8 @@ void *__stdcall GetProcAddress(void *module, const char *proc_name);\n void abort();\n }\n \n+using namespace __sanitizer;\n+\n static uptr getRealProcAddressOrDie(const char *name) {\n   uptr ret =\n       __interception::InternalGetProcAddress((void *)GetModuleHandleA(0), name);\n@@ -196,9 +198,11 @@ static void InterceptHooks();\n // Don't use the INTERFACE_FUNCTION machinery for this function as we actually\n // want to call it in the __asan_init interceptor.\n WRAP_W_V(__asan_should_detect_stack_use_after_return)\n+WRAP_W_V(__asan_get_shadow_memory_dynamic_address)\n \n extern \"C\" {\n   int __asan_option_detect_stack_use_after_return;\n+  uptr __asan_shadow_memory_dynamic_address;\n \n   // Manually wrap __asan_init as we need to initialize\n   // __asan_option_detect_stack_use_after_return afterwards.\n@@ -212,7 +216,8 @@ extern \"C\" {\n     fn();\n     __asan_option_detect_stack_use_after_return =\n         (__asan_should_detect_stack_use_after_return() != 0);\n-\n+    __asan_shadow_memory_dynamic_address =\n+        (uptr)__asan_get_shadow_memory_dynamic_address();\n     InterceptHooks();\n   }\n }\n@@ -255,6 +260,13 @@ INTERFACE_FUNCTION(__asan_memcpy);\n INTERFACE_FUNCTION(__asan_memset);\n INTERFACE_FUNCTION(__asan_memmove);\n \n+INTERFACE_FUNCTION(__asan_set_shadow_00);\n+INTERFACE_FUNCTION(__asan_set_shadow_f1);\n+INTERFACE_FUNCTION(__asan_set_shadow_f2);\n+INTERFACE_FUNCTION(__asan_set_shadow_f3);\n+INTERFACE_FUNCTION(__asan_set_shadow_f5);\n+INTERFACE_FUNCTION(__asan_set_shadow_f8);\n+\n INTERFACE_FUNCTION(__asan_alloca_poison);\n INTERFACE_FUNCTION(__asan_allocas_unpoison);\n \n@@ -309,8 +321,6 @@ INTERFACE_FUNCTION(__sanitizer_cov_init)\n INTERFACE_FUNCTION(__sanitizer_cov_module_init)\n INTERFACE_FUNCTION(__sanitizer_cov_trace_basic_block)\n INTERFACE_FUNCTION(__sanitizer_cov_trace_func_enter)\n-INTERFACE_FUNCTION(__sanitizer_cov_trace_cmp)\n-INTERFACE_FUNCTION(__sanitizer_cov_trace_switch)\n INTERFACE_FUNCTION(__sanitizer_cov_with_check)\n INTERFACE_FUNCTION(__sanitizer_get_allocated_size)\n INTERFACE_FUNCTION(__sanitizer_get_coverage_guards)\n@@ -324,6 +334,8 @@ INTERFACE_FUNCTION(__sanitizer_get_total_unique_coverage)\n INTERFACE_FUNCTION(__sanitizer_get_unmapped_bytes)\n INTERFACE_FUNCTION(__sanitizer_maybe_open_cov_file)\n INTERFACE_FUNCTION(__sanitizer_print_stack_trace)\n+INTERFACE_FUNCTION(__sanitizer_symbolize_pc)\n+INTERFACE_FUNCTION(__sanitizer_symbolize_global)\n INTERFACE_FUNCTION(__sanitizer_ptr_cmp)\n INTERFACE_FUNCTION(__sanitizer_ptr_sub)\n INTERFACE_FUNCTION(__sanitizer_report_error_summary)\n@@ -333,30 +345,39 @@ INTERFACE_FUNCTION(__sanitizer_update_counter_bitset_and_clear_counters)\n INTERFACE_FUNCTION(__sanitizer_sandbox_on_notify)\n INTERFACE_FUNCTION(__sanitizer_set_death_callback)\n INTERFACE_FUNCTION(__sanitizer_set_report_path)\n+INTERFACE_FUNCTION(__sanitizer_set_report_fd)\n INTERFACE_FUNCTION(__sanitizer_unaligned_load16)\n INTERFACE_FUNCTION(__sanitizer_unaligned_load32)\n INTERFACE_FUNCTION(__sanitizer_unaligned_load64)\n INTERFACE_FUNCTION(__sanitizer_unaligned_store16)\n INTERFACE_FUNCTION(__sanitizer_unaligned_store32)\n INTERFACE_FUNCTION(__sanitizer_unaligned_store64)\n INTERFACE_FUNCTION(__sanitizer_verify_contiguous_container)\n+INTERFACE_FUNCTION(__sanitizer_install_malloc_and_free_hooks)\n+INTERFACE_FUNCTION(__sanitizer_start_switch_fiber)\n+INTERFACE_FUNCTION(__sanitizer_finish_switch_fiber)\n \n // TODO(timurrrr): Add more interface functions on the as-needed basis.\n \n // ----------------- Memory allocation functions ---------------------\n WRAP_V_W(free)\n+WRAP_V_W(_free_base)\n WRAP_V_WW(_free_dbg)\n \n WRAP_W_W(malloc)\n+WRAP_W_W(_malloc_base)\n WRAP_W_WWWW(_malloc_dbg)\n \n WRAP_W_WW(calloc)\n+WRAP_W_WW(_calloc_base)\n WRAP_W_WWWWW(_calloc_dbg)\n WRAP_W_WWW(_calloc_impl)\n \n WRAP_W_WW(realloc)\n+WRAP_W_WW(_realloc_base)\n WRAP_W_WWW(_realloc_dbg)\n WRAP_W_WWW(_recalloc)\n+WRAP_W_WWW(_recalloc_base)\n \n WRAP_W_W(_msize)\n WRAP_W_W(_expand)\n@@ -369,6 +390,10 @@ WRAP_W_W(_expand_dbg)\n \n INTERCEPT_LIBRARY_FUNCTION(atoi);\n INTERCEPT_LIBRARY_FUNCTION(atol);\n+\n+#ifdef _WIN64\n+INTERCEPT_LIBRARY_FUNCTION(__C_specific_handler);\n+#else\n INTERCEPT_LIBRARY_FUNCTION(_except_handler3);\n \n // _except_handler4 checks -GS cookie which is different for each module, so we\n@@ -377,10 +402,13 @@ INTERCEPTOR(int, _except_handler4, void *a, void *b, void *c, void *d) {\n   __asan_handle_no_return();\n   return REAL(_except_handler4)(a, b, c, d);\n }\n+#endif\n \n INTERCEPT_LIBRARY_FUNCTION(frexp);\n INTERCEPT_LIBRARY_FUNCTION(longjmp);\n+#if SANITIZER_INTERCEPT_MEMCHR\n INTERCEPT_LIBRARY_FUNCTION(memchr);\n+#endif\n INTERCEPT_LIBRARY_FUNCTION(memcmp);\n INTERCEPT_LIBRARY_FUNCTION(memcpy);\n INTERCEPT_LIBRARY_FUNCTION(memmove);\n@@ -390,12 +418,14 @@ INTERCEPT_LIBRARY_FUNCTION(strchr);\n INTERCEPT_LIBRARY_FUNCTION(strcmp);\n INTERCEPT_LIBRARY_FUNCTION(strcpy);  // NOLINT\n INTERCEPT_LIBRARY_FUNCTION(strcspn);\n+INTERCEPT_LIBRARY_FUNCTION(strdup);\n INTERCEPT_LIBRARY_FUNCTION(strlen);\n INTERCEPT_LIBRARY_FUNCTION(strncat);\n INTERCEPT_LIBRARY_FUNCTION(strncmp);\n INTERCEPT_LIBRARY_FUNCTION(strncpy);\n INTERCEPT_LIBRARY_FUNCTION(strnlen);\n INTERCEPT_LIBRARY_FUNCTION(strpbrk);\n+INTERCEPT_LIBRARY_FUNCTION(strrchr);\n INTERCEPT_LIBRARY_FUNCTION(strspn);\n INTERCEPT_LIBRARY_FUNCTION(strstr);\n INTERCEPT_LIBRARY_FUNCTION(strtol);\n@@ -405,7 +435,9 @@ INTERCEPT_LIBRARY_FUNCTION(wcslen);\n // is defined.\n void InterceptHooks() {\n   INTERCEPT_HOOKS();\n+#ifndef _WIN64\n   INTERCEPT_FUNCTION(_except_handler4);\n+#endif\n }\n \n // We want to call __asan_init before C/C++ initializers/constructors are"}, {"sha": "8989159cc52fbb75000cdd377fa3c48a15ab8db6", "filename": "libsanitizer/asan/asan_win_dynamic_runtime_thunk.cc", "status": "modified", "additions": 14, "deletions": 9, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Fasan_win_dynamic_runtime_thunk.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -1,4 +1,4 @@\n-//===-- asan_win_uar_thunk.cc ---------------------------------------------===//\n+//===-- asan_win_dynamic_runtime_thunk.cc ---------------------------------===//\n //\n // This file is distributed under the University of Illinois Open Source\n // License. See LICENSE.TXT for details.\n@@ -14,11 +14,11 @@\n // This includes:\n //  - forwarding the detect_stack_use_after_return runtime option\n //  - working around deficiencies of the MD runtime\n-//  - installing a custom SEH handlerx\n+//  - installing a custom SEH handler\n //\n //===----------------------------------------------------------------------===//\n \n-// Only compile this code when buidling asan_dynamic_runtime_thunk.lib\n+// Only compile this code when building asan_dynamic_runtime_thunk.lib\n // Using #ifdef rather than relying on Makefiles etc.\n // simplifies the build procedure.\n #ifdef ASAN_DYNAMIC_RUNTIME_THUNK\n@@ -27,7 +27,7 @@\n \n // First, declare CRT sections we'll be using in this file\n #pragma section(\".CRT$XID\", long, read)  // NOLINT\n-#pragma section(\".CRT$XIZ\", long, read)  // NOLINT\n+#pragma section(\".CRT$XCAB\", long, read)  // NOLINT\n #pragma section(\".CRT$XTW\", long, read)  // NOLINT\n #pragma section(\".CRT$XTY\", long, read)  // NOLINT\n \n@@ -40,12 +40,16 @@\n // attribute adds __imp_ prefix to the symbol name of a variable.\n // Since in general we don't know if a given TU is going to be used\n // with a MT or MD runtime and we don't want to use ugly __imp_ names on Windows\n-// just to work around this issue, let's clone the a variable that is\n-// constant after initialization anyways.\n+// just to work around this issue, let's clone the variable that is constant\n+// after initialization anyways.\n extern \"C\" {\n __declspec(dllimport) int __asan_should_detect_stack_use_after_return();\n int __asan_option_detect_stack_use_after_return =\n     __asan_should_detect_stack_use_after_return();\n+\n+__declspec(dllimport) void* __asan_get_shadow_memory_dynamic_address();\n+void* __asan_shadow_memory_dynamic_address =\n+    __asan_get_shadow_memory_dynamic_address();\n }\n \n ////////////////////////////////////////////////////////////////////////////////\n@@ -57,6 +61,7 @@ int __asan_option_detect_stack_use_after_return =\n // using atexit() that calls a small subset of C terminators\n // where LLVM global_dtors is placed.  Fingers crossed, no other C terminators\n // are there.\n+extern \"C\" int __cdecl atexit(void (__cdecl *f)(void));\n extern \"C\" void __cdecl _initterm(void *a, void *b);\n \n namespace {\n@@ -70,6 +75,7 @@ void UnregisterGlobals() {\n int ScheduleUnregisterGlobals() {\n   return atexit(UnregisterGlobals);\n }\n+}  // namespace\n \n // We need to call 'atexit(UnregisterGlobals);' as early as possible, but after\n // atexit() is initialized (.CRT$XIC).  As this is executed before C++\n@@ -78,8 +84,6 @@ int ScheduleUnregisterGlobals() {\n __declspec(allocate(\".CRT$XID\"))\n int (*__asan_schedule_unregister_globals)() = ScheduleUnregisterGlobals;\n \n-}  // namespace\n-\n ////////////////////////////////////////////////////////////////////////////////\n // ASan SEH handling.\n // We need to set the ASan-specific SEH handler at the end of CRT initialization\n@@ -90,7 +94,8 @@ static int SetSEHFilter() { return __asan_set_seh_filter(); }\n \n // Unfortunately, putting a pointer to __asan_set_seh_filter into\n // __asan_intercept_seh gets optimized out, so we have to use an extra function.\n-__declspec(allocate(\".CRT$XIZ\")) int (*__asan_seh_interceptor)() = SetSEHFilter;\n+__declspec(allocate(\".CRT$XCAB\")) int (*__asan_seh_interceptor)() =\n+    SetSEHFilter;\n }\n \n #endif // ASAN_DYNAMIC_RUNTIME_THUNK"}, {"sha": "0f14ee341856dff7b02ae79f80061c55cf2ba8af", "filename": "libsanitizer/asan/libtool-version", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Flibtool-version", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fasan%2Flibtool-version", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fasan%2Flibtool-version?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -3,4 +3,4 @@\n # a separate file so that version updates don't involve re-running\n # automake.\n # CURRENT:REVISION:AGE\n-3:0:0\n+4:0:0"}, {"sha": "5e36b5a5edf379cf30c2b843c2ef5c875d54837a", "filename": "libsanitizer/builtins/assembly.h", "status": "added", "additions": 169, "deletions": 0, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fbuiltins%2Fassembly.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fbuiltins%2Fassembly.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fbuiltins%2Fassembly.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,169 @@\n+/* ===-- assembly.h - compiler-rt assembler support macros -----------------===\n+ *\n+ *                     The LLVM Compiler Infrastructure\n+ *\n+ * This file is dual licensed under the MIT and the University of Illinois Open\n+ * Source Licenses. See LICENSE.TXT for details.\n+ *\n+ * ===----------------------------------------------------------------------===\n+ *\n+ * This file defines macros for use in compiler-rt assembler source.\n+ * This file is not part of the interface of this library.\n+ *\n+ * ===----------------------------------------------------------------------===\n+ */\n+\n+#ifndef COMPILERRT_ASSEMBLY_H\n+#define COMPILERRT_ASSEMBLY_H\n+\n+#if defined(__POWERPC__) || defined(__powerpc__) || defined(__ppc__)\n+#define SEPARATOR @\n+#else\n+#define SEPARATOR ;\n+#endif\n+\n+#if defined(__APPLE__)\n+#define HIDDEN(name) .private_extern name\n+#define LOCAL_LABEL(name) L_##name\n+// tell linker it can break up file at label boundaries\n+#define FILE_LEVEL_DIRECTIVE .subsections_via_symbols\n+#define SYMBOL_IS_FUNC(name)\n+#define CONST_SECTION .const\n+\n+#define NO_EXEC_STACK_DIRECTIVE\n+\n+#elif defined(__ELF__)\n+\n+#define HIDDEN(name) .hidden name\n+#define LOCAL_LABEL(name) .L_##name\n+#define FILE_LEVEL_DIRECTIVE\n+#if defined(__arm__)\n+#define SYMBOL_IS_FUNC(name) .type name,%function\n+#else\n+#define SYMBOL_IS_FUNC(name) .type name,@function\n+#endif\n+#define CONST_SECTION .section .rodata\n+\n+#if defined(__GNU__) || defined(__ANDROID__) || defined(__FreeBSD__)\n+#define NO_EXEC_STACK_DIRECTIVE .section .note.GNU-stack,\"\",%progbits\n+#else\n+#define NO_EXEC_STACK_DIRECTIVE\n+#endif\n+\n+#else // !__APPLE__ && !__ELF__\n+\n+#define HIDDEN(name)\n+#define LOCAL_LABEL(name) .L ## name\n+#define FILE_LEVEL_DIRECTIVE\n+#define SYMBOL_IS_FUNC(name)                                                   \\\n+  .def name SEPARATOR                                                          \\\n+    .scl 2 SEPARATOR                                                           \\\n+    .type 32 SEPARATOR                                                         \\\n+  .endef\n+#define CONST_SECTION .section .rdata,\"rd\"\n+\n+#define NO_EXEC_STACK_DIRECTIVE\n+\n+#endif\n+\n+#if defined(__arm__)\n+#if defined(__ARM_ARCH_4T__) || __ARM_ARCH >= 5\n+#define ARM_HAS_BX\n+#endif\n+#if !defined(__ARM_FEATURE_CLZ) &&                                             \\\n+    (__ARM_ARCH >= 6 || (__ARM_ARCH == 5 && !defined(__ARM_ARCH_5__)))\n+#define __ARM_FEATURE_CLZ\n+#endif\n+\n+#ifdef ARM_HAS_BX\n+#define JMP(r) bx r\n+#define JMPc(r, c) bx##c r\n+#else\n+#define JMP(r) mov pc, r\n+#define JMPc(r, c) mov##c pc, r\n+#endif\n+\n+// pop {pc} can't switch Thumb mode on ARMv4T\n+#if __ARM_ARCH >= 5\n+#define POP_PC() pop {pc}\n+#else\n+#define POP_PC()                                                               \\\n+  pop {ip};                                                                    \\\n+  JMP(ip)\n+#endif\n+\n+#if __ARM_ARCH_ISA_THUMB == 2\n+#define IT(cond)  it cond\n+#define ITT(cond) itt cond\n+#else\n+#define IT(cond)\n+#define ITT(cond)\n+#endif\n+\n+#if __ARM_ARCH_ISA_THUMB == 2\n+#define WIDE(op) op.w\n+#else\n+#define WIDE(op) op\n+#endif\n+#endif\n+\n+#define GLUE2(a, b) a##b\n+#define GLUE(a, b) GLUE2(a, b)\n+#define SYMBOL_NAME(name) GLUE(__USER_LABEL_PREFIX__, name)\n+\n+#ifdef VISIBILITY_HIDDEN\n+#define DECLARE_SYMBOL_VISIBILITY(name)                                        \\\n+  HIDDEN(SYMBOL_NAME(name)) SEPARATOR\n+#else\n+#define DECLARE_SYMBOL_VISIBILITY(name)\n+#endif\n+\n+#define DEFINE_COMPILERRT_FUNCTION(name)                                       \\\n+  FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n+  .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n+  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n+  DECLARE_SYMBOL_VISIBILITY(name)                                              \\\n+  SYMBOL_NAME(name):\n+\n+#define DEFINE_COMPILERRT_THUMB_FUNCTION(name)                                 \\\n+  FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n+  .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n+  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n+  DECLARE_SYMBOL_VISIBILITY(name) SEPARATOR                                    \\\n+  .thumb_func SEPARATOR                                                        \\\n+  SYMBOL_NAME(name):\n+\n+#define DEFINE_COMPILERRT_PRIVATE_FUNCTION(name)                               \\\n+  FILE_LEVEL_DIRECTIVE SEPARATOR                                               \\\n+  .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n+  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n+  HIDDEN(SYMBOL_NAME(name)) SEPARATOR                                          \\\n+  SYMBOL_NAME(name):\n+\n+#define DEFINE_COMPILERRT_PRIVATE_FUNCTION_UNMANGLED(name)                     \\\n+  .globl name SEPARATOR                                                        \\\n+  SYMBOL_IS_FUNC(name) SEPARATOR                                               \\\n+  HIDDEN(name) SEPARATOR                                                       \\\n+  name:\n+\n+#define DEFINE_COMPILERRT_FUNCTION_ALIAS(name, target)                         \\\n+  .globl SYMBOL_NAME(name) SEPARATOR                                           \\\n+  SYMBOL_IS_FUNC(SYMBOL_NAME(name)) SEPARATOR                                  \\\n+  DECLARE_SYMBOL_VISIBILITY(SYMBOL_NAME(name)) SEPARATOR                       \\\n+  .set SYMBOL_NAME(name), SYMBOL_NAME(target) SEPARATOR\n+\n+#if defined(__ARM_EABI__)\n+#define DEFINE_AEABI_FUNCTION_ALIAS(aeabi_name, name)                          \\\n+  DEFINE_COMPILERRT_FUNCTION_ALIAS(aeabi_name, name)\n+#else\n+#define DEFINE_AEABI_FUNCTION_ALIAS(aeabi_name, name)\n+#endif\n+\n+#ifdef __ELF__\n+#define END_COMPILERRT_FUNCTION(name)                                          \\\n+  .size SYMBOL_NAME(name), . - SYMBOL_NAME(name)\n+#else\n+#define END_COMPILERRT_FUNCTION(name)\n+#endif\n+\n+#endif /* COMPILERRT_ASSEMBLY_H */"}, {"sha": "b6c715b09f748e858156c41c0080ea67275c2e5f", "filename": "libsanitizer/configure", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -604,6 +604,7 @@ ac_subst_vars='am__EXEEXT_FALSE\n am__EXEEXT_TRUE\n LTLIBOBJS\n LIBOBJS\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS\n TSAN_TARGET_DEPENDENT_OBJECTS\n LIBBACKTRACE_SUPPORTED_FALSE\n LIBBACKTRACE_SUPPORTED_TRUE\n@@ -12027,7 +12028,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12030 \"configure\"\n+#line 12031 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -12133,7 +12134,7 @@ else\n   lt_dlunknown=0; lt_dlno_uscore=1; lt_dlneed_uscore=2\n   lt_status=$lt_dlunknown\n   cat > conftest.$ac_ext <<_LT_EOF\n-#line 12136 \"configure\"\n+#line 12137 \"configure\"\n #include \"confdefs.h\"\n \n #if HAVE_DLFCN_H\n@@ -16498,6 +16499,7 @@ fi\n \n \n \n+\n cat >confcache <<\\_ACEOF\n # This file is a shell script that caches the results of configure\n # tests run on this system so they can be shared between configure"}, {"sha": "e901849807435c0965a5676e0cbf825f579df83b", "filename": "libsanitizer/configure.ac", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.ac?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -375,5 +375,6 @@ _EOF\n fi\n \n AC_SUBST([TSAN_TARGET_DEPENDENT_OBJECTS])\n+AC_SUBST([SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS])\n \n AC_OUTPUT"}, {"sha": "8d884f4bf52de90979e0ccf10a3c50c8f1dc5383", "filename": "libsanitizer/configure.tgt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure.tgt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fconfigure.tgt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fconfigure.tgt?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -20,12 +20,14 @@\n \n # Filter out unsupported systems.\n TSAN_TARGET_DEPENDENT_OBJECTS=\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS=\n case \"${target}\" in\n   x86_64-*-linux* | i?86-*-linux*)\n \tif test x$ac_cv_sizeof_void_p = x8; then\n \t\tTSAN_SUPPORTED=yes\n \t\tLSAN_SUPPORTED=yes\n \t\tTSAN_TARGET_DEPENDENT_OBJECTS=tsan_rtl_amd64.lo\n+\t\tSANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS=sanitizer_linux_x86_64.lo\n \tfi\n \t;;\n   powerpc*-*-linux*)"}, {"sha": "d4801e9ff0cb47817336034c9e24beae7dc4ddaf", "filename": "libsanitizer/include/sanitizer/allocator_interface.h", "status": "modified", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fallocator_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -57,6 +57,23 @@ extern \"C\" {\n        deallocation of \"ptr\". */\n   void __sanitizer_malloc_hook(const volatile void *ptr, size_t size);\n   void __sanitizer_free_hook(const volatile void *ptr);\n+\n+  /* Installs a pair of hooks for malloc/free.\n+     Several (currently, 5) hook pairs may be installed, they are executed\n+     in the order they were installed and after calling\n+     __sanitizer_malloc_hook/__sanitizer_free_hook.\n+     Unlike __sanitizer_malloc_hook/__sanitizer_free_hook these hooks can be\n+     chained and do not rely on weak symbols working on the platform, but\n+     require __sanitizer_install_malloc_and_free_hooks to be called at startup\n+     and thus will not be called on malloc/free very early in the process.\n+     Returns the number of hooks currently installed or 0 on failure.\n+     Not thread-safe, should be called in the main thread before starting\n+     other threads.\n+  */\n+  int __sanitizer_install_malloc_and_free_hooks(\n+      void (*malloc_hook)(const volatile void *, size_t),\n+      void (*free_hook)(const volatile void *));\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "fd38c55a235b083af723445a611127b32e3828a3", "filename": "libsanitizer/include/sanitizer/common_interface_defs.h", "status": "modified", "additions": 56, "deletions": 2, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcommon_interface_defs.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -39,6 +39,9 @@ extern \"C\" {\n \n   // Tell the tools to write their reports to \"path.<pid>\" instead of stderr.\n   void __sanitizer_set_report_path(const char *path);\n+  // Tell the tools to write their reports to the provided file descriptor\n+  // (casted to void *).\n+  void __sanitizer_set_report_fd(void *fd);\n \n   // Notify the tools that the sandbox is going to be turned on. The reserved\n   // parameter will be used in the future to hold a structure with functions\n@@ -112,6 +115,16 @@ extern \"C\" {\n   // Print the stack trace leading to this call. Useful for debugging user code.\n   void __sanitizer_print_stack_trace();\n \n+  // Symbolizes the supplied 'pc' using the format string 'fmt'.\n+  // Outputs at most 'out_buf_size' bytes into 'out_buf'.\n+  // The format syntax is described in\n+  // lib/sanitizer_common/sanitizer_stacktrace_printer.h.\n+  void __sanitizer_symbolize_pc(void *pc, const char *fmt, char *out_buf,\n+                                size_t out_buf_size);\n+  // Same as __sanitizer_symbolize_pc, but for data section (i.e. globals).\n+  void __sanitizer_symbolize_global(void *data_ptr, const char *fmt,\n+                                    char *out_buf, size_t out_buf_size);\n+\n   // Sets the callback to be called right before death on error.\n   // Passing 0 will unset the callback.\n   void __sanitizer_set_death_callback(void (*callback)(void));\n@@ -123,9 +136,50 @@ extern \"C\" {\n   // to know what is being passed to libc functions, e.g. memcmp.\n   // FIXME: implement more hooks.\n   void __sanitizer_weak_hook_memcmp(void *called_pc, const void *s1,\n-                                    const void *s2, size_t n);\n+                                    const void *s2, size_t n, int result);\n   void __sanitizer_weak_hook_strncmp(void *called_pc, const char *s1,\n-                                    const char *s2, size_t n);\n+                                    const char *s2, size_t n, int result);\n+  void __sanitizer_weak_hook_strncasecmp(void *called_pc, const char *s1,\n+                                         const char *s2, size_t n, int result);\n+  void __sanitizer_weak_hook_strcmp(void *called_pc, const char *s1,\n+                                    const char *s2, int result);\n+  void __sanitizer_weak_hook_strcasecmp(void *called_pc, const char *s1,\n+                                        const char *s2, int result);\n+  void __sanitizer_weak_hook_strstr(void *called_pc, const char *s1,\n+                                    const char *s2, char *result);\n+  void __sanitizer_weak_hook_strcasestr(void *called_pc, const char *s1,\n+                                        const char *s2, char *result);\n+  void __sanitizer_weak_hook_memmem(void *called_pc,\n+                                    const void *s1, size_t len1,\n+                                    const void *s2, size_t len2, void *result);\n+\n+  // Prints stack traces for all live heap allocations ordered by total\n+  // allocation size until `top_percent` of total live heap is shown.\n+  // `top_percent` should be between 1 and 100.\n+  // Experimental feature currently available only with asan on Linux/x86_64.\n+  void __sanitizer_print_memory_profile(size_t top_percent);\n+\n+  // Fiber annotation interface.\n+  // Before switching to a different stack, one must call\n+  // __sanitizer_start_switch_fiber with a pointer to the bottom of the\n+  // destination stack and its size. When code starts running on the new stack,\n+  // it must call __sanitizer_finish_switch_fiber to finalize the switch.\n+  // The start_switch function takes a void** to store the current fake stack if\n+  // there is one (it is needed when detect_stack_use_after_return is enabled).\n+  // When restoring a stack, this pointer must be given to the finish_switch\n+  // function. In most cases, this void* can be stored on the stack just before\n+  // switching.  When leaving a fiber definitely, null must be passed as first\n+  // argument to the start_switch function so that the fake stack is destroyed.\n+  // If you do not want support for stack use-after-return detection, you can\n+  // always pass null to these two functions.\n+  // Note that the fake stack mechanism is disabled during fiber switch, so if a\n+  // signal callback runs during the switch, it will not benefit from the stack\n+  // use-after-return detection.\n+  void __sanitizer_start_switch_fiber(void **fake_stack_save,\n+                                      const void *bottom, size_t size);\n+  void __sanitizer_finish_switch_fiber(void *fake_stack_save,\n+                                       const void **bottom_old,\n+                                       size_t *size_old);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "ffb956c39db59327e421919320d0181ea4351c73", "filename": "libsanitizer/include/sanitizer/coverage_interface.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fcoverage_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -56,6 +56,7 @@ extern \"C\" {\n   // __sanitizer_get_number_of_counters bytes long and 8-aligned.\n   uintptr_t\n   __sanitizer_update_counter_bitset_and_clear_counters(uint8_t *bitset);\n+\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "cd18f34fc00be8ff57f1c4c290acd6b3ab98ee0f", "filename": "libsanitizer/include/sanitizer/esan_interface.h", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Fesan_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,48 @@\n+//===-- sanitizer/esan_interface.h ------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of EfficiencySanitizer, a family of performance tuners.\n+//\n+// Public interface header.\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ESAN_INTERFACE_H\n+#define SANITIZER_ESAN_INTERFACE_H\n+\n+#include <sanitizer/common_interface_defs.h>\n+\n+// We declare our interface routines as weak to allow the user to avoid\n+// ifdefs and instead use this pattern to allow building the same sources\n+// with and without our runtime library:\n+//     if (__esan_report)\n+//       __esan_report();\n+#ifdef _MSC_VER\n+/* selectany is as close to weak as we'll get. */\n+#define COMPILER_RT_WEAK __declspec(selectany)\n+#elif __GNUC__\n+#define COMPILER_RT_WEAK __attribute__((weak))\n+#else\n+#define COMPILER_RT_WEAK\n+#endif\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+// This function can be called mid-run (or at the end of a run for\n+// a server process that doesn't shut down normally) to request that\n+// data for that point in the run be reported from the tool.\n+void COMPILER_RT_WEAK __esan_report();\n+\n+// This function returns the number of samples that the esan tool has collected\n+// to this point.  This is useful for testing.\n+unsigned int COMPILER_RT_WEAK __esan_get_sample_count();\n+\n+#ifdef __cplusplus\n+} // extern \"C\"\n+#endif\n+\n+#endif // SANITIZER_ESAN_INTERFACE_H"}, {"sha": "34bb29124060a9283576cffb50499fbb76f523ed", "filename": "libsanitizer/include/sanitizer/linux_syscall_hooks.h", "status": "modified", "additions": 18, "deletions": 5, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finclude%2Fsanitizer%2Flinux_syscall_hooks.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -1833,6 +1833,17 @@\n   __sanitizer_syscall_pre_impl_vfork()\n #define __sanitizer_syscall_post_vfork(res) \\\n   __sanitizer_syscall_post_impl_vfork(res)\n+#define __sanitizer_syscall_pre_sigaction(signum, act, oldact)                 \\\n+  __sanitizer_syscall_pre_impl_sigaction((long)signum, (long)act, (long)oldact)\n+#define __sanitizer_syscall_post_sigaction(res, signum, act, oldact)           \\\n+  __sanitizer_syscall_post_impl_sigaction(res, (long)signum, (long)act,        \\\n+                                          (long)oldact)\n+#define __sanitizer_syscall_pre_rt_sigaction(signum, act, oldact, sz)          \\\n+  __sanitizer_syscall_pre_impl_rt_sigaction((long)signum, (long)act,           \\\n+                                            (long)oldact, (long)sz)\n+#define __sanitizer_syscall_post_rt_sigaction(res, signum, act, oldact, sz)    \\\n+  __sanitizer_syscall_post_impl_rt_sigaction(res, (long)signum, (long)act,     \\\n+                                             (long)oldact, (long)sz)\n \n // And now a few syscalls we don't handle yet.\n #define __sanitizer_syscall_pre_afs_syscall(...)\n@@ -1887,7 +1898,6 @@\n #define __sanitizer_syscall_pre_query_module(...)\n #define __sanitizer_syscall_pre_readahead(...)\n #define __sanitizer_syscall_pre_readdir(...)\n-#define __sanitizer_syscall_pre_rt_sigaction(...)\n #define __sanitizer_syscall_pre_rt_sigreturn(...)\n #define __sanitizer_syscall_pre_rt_sigsuspend(...)\n #define __sanitizer_syscall_pre_security(...)\n@@ -1901,7 +1911,6 @@\n #define __sanitizer_syscall_pre_setreuid32(...)\n #define __sanitizer_syscall_pre_set_thread_area(...)\n #define __sanitizer_syscall_pre_setuid32(...)\n-#define __sanitizer_syscall_pre_sigaction(...)\n #define __sanitizer_syscall_pre_sigaltstack(...)\n #define __sanitizer_syscall_pre_sigreturn(...)\n #define __sanitizer_syscall_pre_sigsuspend(...)\n@@ -1969,7 +1978,6 @@\n #define __sanitizer_syscall_post_query_module(res, ...)\n #define __sanitizer_syscall_post_readahead(res, ...)\n #define __sanitizer_syscall_post_readdir(res, ...)\n-#define __sanitizer_syscall_post_rt_sigaction(res, ...)\n #define __sanitizer_syscall_post_rt_sigreturn(res, ...)\n #define __sanitizer_syscall_post_rt_sigsuspend(res, ...)\n #define __sanitizer_syscall_post_security(res, ...)\n@@ -1983,7 +1991,6 @@\n #define __sanitizer_syscall_post_setreuid32(res, ...)\n #define __sanitizer_syscall_post_set_thread_area(res, ...)\n #define __sanitizer_syscall_post_setuid32(res, ...)\n-#define __sanitizer_syscall_post_sigaction(res, ...)\n #define __sanitizer_syscall_post_sigaltstack(res, ...)\n #define __sanitizer_syscall_post_sigreturn(res, ...)\n #define __sanitizer_syscall_post_sigsuspend(res, ...)\n@@ -3060,7 +3067,13 @@ void __sanitizer_syscall_pre_impl_fork();\n void __sanitizer_syscall_post_impl_fork(long res);\n void __sanitizer_syscall_pre_impl_vfork();\n void __sanitizer_syscall_post_impl_vfork(long res);\n-\n+void __sanitizer_syscall_pre_impl_sigaction(long signum, long act, long oldact);\n+void __sanitizer_syscall_post_impl_sigaction(long res, long signum, long act,\n+                                             long oldact);\n+void __sanitizer_syscall_pre_impl_rt_sigaction(long signum, long act,\n+                                               long oldact, long sz);\n+void __sanitizer_syscall_post_impl_rt_sigaction(long res, long signum, long act,\n+                                                long oldact, long sz);\n #ifdef __cplusplus\n }  // extern \"C\"\n #endif"}, {"sha": "550c8f5c3f98bc34b820c4c7348a464e2fa141d7", "filename": "libsanitizer/interception/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -169,6 +169,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@"}, {"sha": "0db36ddf28ee62aed92e82dce3cf0d2faa286b5d", "filename": "libsanitizer/interception/interception.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -90,8 +90,8 @@ typedef __sanitizer::OFF64_T OFF64_T;\n \n // Just a pair of pointers.\n struct interpose_substitution {\n-  const uptr replacement;\n-  const uptr original;\n+  const __sanitizer::uptr replacement;\n+  const __sanitizer::uptr original;\n };\n \n // For a function foo() create a global pair of pointers { wrap_foo, foo } in\n@@ -156,10 +156,12 @@ const interpose_substitution substitution_##func_name[] \\\n     namespace __interception { \\\n       extern FUNC_TYPE(func) PTR_TO_REAL(func); \\\n     }\n+# define ASSIGN_REAL(dst, src) REAL(dst) = REAL(src)\n #else  // __APPLE__\n # define REAL(x) x\n # define DECLARE_REAL(ret_type, func, ...) \\\n     extern \"C\" ret_type func(__VA_ARGS__);\n+# define ASSIGN_REAL(x, y)\n #endif  // __APPLE__\n \n #define DECLARE_REAL_AND_INTERCEPTOR(ret_type, func, ...) \\"}, {"sha": "fa81162097ef4bcde038ac0ba5962f4ada075d30", "filename": "libsanitizer/interception/interception_win.cc", "status": "modified", "additions": 861, "deletions": 134, "changes": 995, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -8,19 +8,178 @@\n // This file is a part of AddressSanitizer, an address sanity checker.\n //\n // Windows-specific interception methods.\n+//\n+// This file is implementing several hooking techniques to intercept calls\n+// to functions. The hooks are dynamically installed by modifying the assembly\n+// code.\n+//\n+// The hooking techniques are making assumptions on the way the code is\n+// generated and are safe under these assumptions.\n+//\n+// On 64-bit architecture, there is no direct 64-bit jump instruction. To allow\n+// arbitrary branching on the whole memory space, the notion of trampoline\n+// region is used. A trampoline region is a memory space withing 2G boundary\n+// where it is safe to add custom assembly code to build 64-bit jumps.\n+//\n+// Hooking techniques\n+// ==================\n+//\n+// 1) Detour\n+//\n+//    The Detour hooking technique is assuming the presence of an header with\n+//    padding and an overridable 2-bytes nop instruction (mov edi, edi). The\n+//    nop instruction can safely be replaced by a 2-bytes jump without any need\n+//    to save the instruction. A jump to the target is encoded in the function\n+//    header and the nop instruction is replaced by a short jump to the header.\n+//\n+//        head:  5 x nop                 head:  jmp <hook>\n+//        func:  mov edi, edi    -->     func:  jmp short <head>\n+//               [...]                   real:  [...]\n+//\n+//    This technique is only implemented on 32-bit architecture.\n+//    Most of the time, Windows API are hookable with the detour technique.\n+//\n+// 2) Redirect Jump\n+//\n+//    The redirect jump is applicable when the first instruction is a direct\n+//    jump. The instruction is replaced by jump to the hook.\n+//\n+//        func:  jmp <label>     -->     func:  jmp <hook>\n+//\n+//    On an 64-bit architecture, a trampoline is inserted.\n+//\n+//        func:  jmp <label>     -->     func:  jmp <tramp>\n+//                                              [...]\n+//\n+//                                   [trampoline]\n+//                                      tramp:  jmp QWORD [addr]\n+//                                       addr:  .bytes <hook>\n+//\n+//    Note: <real> is equilavent to <label>.\n+//\n+// 3) HotPatch\n+//\n+//    The HotPatch hooking is assuming the presence of an header with padding\n+//    and a first instruction with at least 2-bytes.\n+//\n+//    The reason to enforce the 2-bytes limitation is to provide the minimal\n+//    space to encode a short jump. HotPatch technique is only rewriting one\n+//    instruction to avoid breaking a sequence of instructions containing a\n+//    branching target.\n+//\n+//    Assumptions are enforced by MSVC compiler by using the /HOTPATCH flag.\n+//      see: https://msdn.microsoft.com/en-us/library/ms173507.aspx\n+//    Default padding length is 5 bytes in 32-bits and 6 bytes in 64-bits.\n+//\n+//        head:   5 x nop                head:  jmp <hook>\n+//        func:   <instr>        -->     func:  jmp short <head>\n+//                [...]                  body:  [...]\n+//\n+//                                   [trampoline]\n+//                                       real:  <instr>\n+//                                              jmp <body>\n+//\n+//    On an 64-bit architecture:\n+//\n+//        head:   6 x nop                head:  jmp QWORD [addr1]\n+//        func:   <instr>        -->     func:  jmp short <head>\n+//                [...]                  body:  [...]\n+//\n+//                                   [trampoline]\n+//                                      addr1:  .bytes <hook>\n+//                                       real:  <instr>\n+//                                              jmp QWORD [addr2]\n+//                                      addr2:  .bytes <body>\n+//\n+// 4) Trampoline\n+//\n+//    The Trampoline hooking technique is the most aggressive one. It is\n+//    assuming that there is a sequence of instructions that can be safely\n+//    replaced by a jump (enough room and no incoming branches).\n+//\n+//    Unfortunately, these assumptions can't be safely presumed and code may\n+//    be broken after hooking.\n+//\n+//        func:   <instr>        -->     func:  jmp <hook>\n+//                <instr>\n+//                [...]                  body:  [...]\n+//\n+//                                   [trampoline]\n+//                                       real:  <instr>\n+//                                              <instr>\n+//                                              jmp <body>\n+//\n+//    On an 64-bit architecture:\n+//\n+//        func:   <instr>        -->     func:  jmp QWORD [addr1]\n+//                <instr>\n+//                [...]                  body:  [...]\n+//\n+//                                   [trampoline]\n+//                                      addr1:  .bytes <hook>\n+//                                       real:  <instr>\n+//                                              <instr>\n+//                                              jmp QWORD [addr2]\n+//                                      addr2:  .bytes <body>\n //===----------------------------------------------------------------------===//\n \n #ifdef _WIN32\n \n #include \"interception.h\"\n+#include \"sanitizer_common/sanitizer_platform.h\"\n #define WIN32_LEAN_AND_MEAN\n #include <windows.h>\n \n namespace __interception {\n \n+static const int kAddressLength = FIRST_32_SECOND_64(4, 8);\n+static const int kJumpInstructionLength = 5;\n+static const int kShortJumpInstructionLength = 2;\n+static const int kIndirectJumpInstructionLength = 6;\n+static const int kBranchLength =\n+    FIRST_32_SECOND_64(kJumpInstructionLength, kIndirectJumpInstructionLength);\n+static const int kDirectBranchLength = kBranchLength + kAddressLength;\n+\n+static void InterceptionFailed() {\n+  // Do we have a good way to abort with an error message here?\n+  __debugbreak();\n+}\n+\n+static bool DistanceIsWithin2Gig(uptr from, uptr target) {\n+  if (from < target)\n+    return target - from <= (uptr)0x7FFFFFFFU;\n+  else\n+    return from - target <= (uptr)0x80000000U;\n+}\n+\n+static uptr GetMmapGranularity() {\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+  return si.dwAllocationGranularity;\n+}\n+\n+static uptr RoundUpTo(uptr size, uptr boundary) {\n+  return (size + boundary - 1) & ~(boundary - 1);\n+}\n+\n // FIXME: internal_str* and internal_mem* functions should be moved from the\n // ASan sources into interception/.\n \n+static size_t _strlen(const char *str) {\n+  const char* p = str;\n+  while (*p != '\\0') ++p;\n+  return p - str;\n+}\n+\n+static char* _strchr(char* str, char c) {\n+  while (*str) {\n+    if (*str == c)\n+      return str;\n+    ++str;\n+  }\n+  return nullptr;\n+}\n+\n static void _memset(void *p, int value, size_t sz) {\n   for (size_t i = 0; i < sz; ++i)\n     ((char*)p)[i] = (char)value;\n@@ -33,163 +192,641 @@ static void _memcpy(void *dst, void *src, size_t sz) {\n     dst_c[i] = src_c[i];\n }\n \n-static void WriteJumpInstruction(char *jmp_from, char *to) {\n-  // jmp XXYYZZWW = E9 WW ZZ YY XX, where XXYYZZWW is an offset fromt jmp_from\n-  // to the next instruction to the destination.\n-  ptrdiff_t offset = to - jmp_from - 5;\n-  *jmp_from = '\\xE9';\n-  *(ptrdiff_t*)(jmp_from + 1) = offset;\n-}\n-\n-static char *GetMemoryForTrampoline(size_t size) {\n-  // Trampolines are allocated from a common pool.\n-  const int POOL_SIZE = 1024;\n-  static char *pool = NULL;\n-  static size_t pool_used = 0;\n-  if (!pool) {\n-    pool = (char *)VirtualAlloc(NULL, POOL_SIZE, MEM_RESERVE | MEM_COMMIT,\n-                                PAGE_EXECUTE_READWRITE);\n-    // FIXME: Might want to apply PAGE_EXECUTE_READ access after all the\n-    // interceptors are in place.\n-    if (!pool)\n-      return NULL;\n-    _memset(pool, 0xCC /* int 3 */, POOL_SIZE);\n+static bool ChangeMemoryProtection(\n+    uptr address, uptr size, DWORD *old_protection) {\n+  return ::VirtualProtect((void*)address, size,\n+                          PAGE_EXECUTE_READWRITE,\n+                          old_protection) != FALSE;\n+}\n+\n+static bool RestoreMemoryProtection(\n+    uptr address, uptr size, DWORD old_protection) {\n+  DWORD unused;\n+  return ::VirtualProtect((void*)address, size,\n+                          old_protection,\n+                          &unused) != FALSE;\n+}\n+\n+static bool IsMemoryPadding(uptr address, uptr size) {\n+  u8* function = (u8*)address;\n+  for (size_t i = 0; i < size; ++i)\n+    if (function[i] != 0x90 && function[i] != 0xCC)\n+      return false;\n+  return true;\n+}\n+\n+static const u8 kHintNop10Bytes[] = {\n+  0x66, 0x66, 0x0F, 0x1F, 0x84,\n+  0x00, 0x00, 0x00, 0x00, 0x00\n+};\n+\n+template<class T>\n+static bool FunctionHasPrefix(uptr address, const T &pattern) {\n+  u8* function = (u8*)address - sizeof(pattern);\n+  for (size_t i = 0; i < sizeof(pattern); ++i)\n+    if (function[i] != pattern[i])\n+      return false;\n+  return true;\n+}\n+\n+static bool FunctionHasPadding(uptr address, uptr size) {\n+  if (IsMemoryPadding(address - size, size))\n+    return true;\n+  if (size <= sizeof(kHintNop10Bytes) &&\n+      FunctionHasPrefix(address, kHintNop10Bytes))\n+    return true;\n+  return false;\n+}\n+\n+static void WritePadding(uptr from, uptr size) {\n+  _memset((void*)from, 0xCC, (size_t)size);\n+}\n+\n+static void WriteJumpInstruction(uptr from, uptr target) {\n+  if (!DistanceIsWithin2Gig(from + kJumpInstructionLength, target))\n+    InterceptionFailed();\n+  ptrdiff_t offset = target - from - kJumpInstructionLength;\n+  *(u8*)from = 0xE9;\n+  *(u32*)(from + 1) = offset;\n+}\n+\n+static void WriteShortJumpInstruction(uptr from, uptr target) {\n+  sptr offset = target - from - kShortJumpInstructionLength;\n+  if (offset < -128 || offset > 127)\n+    InterceptionFailed();\n+  *(u8*)from = 0xEB;\n+  *(u8*)(from + 1) = (u8)offset;\n+}\n+\n+#if SANITIZER_WINDOWS64\n+static void WriteIndirectJumpInstruction(uptr from, uptr indirect_target) {\n+  // jmp [rip + <offset>] = FF 25 <offset> where <offset> is a relative\n+  // offset.\n+  // The offset is the distance from then end of the jump instruction to the\n+  // memory location containing the targeted address. The displacement is still\n+  // 32-bit in x64, so indirect_target must be located within +/- 2GB range.\n+  int offset = indirect_target - from - kIndirectJumpInstructionLength;\n+  if (!DistanceIsWithin2Gig(from + kIndirectJumpInstructionLength,\n+                            indirect_target)) {\n+    InterceptionFailed();\n   }\n+  *(u16*)from = 0x25FF;\n+  *(u32*)(from + 2) = offset;\n+}\n+#endif\n+\n+static void WriteBranch(\n+    uptr from, uptr indirect_target, uptr target) {\n+#if SANITIZER_WINDOWS64\n+  WriteIndirectJumpInstruction(from, indirect_target);\n+  *(u64*)indirect_target = target;\n+#else\n+  (void)indirect_target;\n+  WriteJumpInstruction(from, target);\n+#endif\n+}\n+\n+static void WriteDirectBranch(uptr from, uptr target) {\n+#if SANITIZER_WINDOWS64\n+  // Emit an indirect jump through immediately following bytes:\n+  //   jmp [rip + kBranchLength]\n+  //   .quad <target>\n+  WriteBranch(from, from + kBranchLength, target);\n+#else\n+  WriteJumpInstruction(from, target);\n+#endif\n+}\n+\n+struct TrampolineMemoryRegion {\n+  uptr content;\n+  uptr allocated_size;\n+  uptr max_size;\n+};\n+\n+static const uptr kTrampolineScanLimitRange = 1 << 31;  // 2 gig\n+static const int kMaxTrampolineRegion = 1024;\n+static TrampolineMemoryRegion TrampolineRegions[kMaxTrampolineRegion];\n \n-  if (pool_used + size > POOL_SIZE)\n-    return NULL;\n+static void *AllocateTrampolineRegion(uptr image_address, size_t granularity) {\n+#if SANITIZER_WINDOWS64\n+  uptr address = image_address;\n+  uptr scanned = 0;\n+  while (scanned < kTrampolineScanLimitRange) {\n+    MEMORY_BASIC_INFORMATION info;\n+    if (!::VirtualQuery((void*)address, &info, sizeof(info)))\n+      return nullptr;\n \n-  char *ret = pool + pool_used;\n-  pool_used += size;\n-  return ret;\n+    // Check whether a region can be allocated at |address|.\n+    if (info.State == MEM_FREE && info.RegionSize >= granularity) {\n+      void *page = ::VirtualAlloc((void*)RoundUpTo(address, granularity),\n+                                  granularity,\n+                                  MEM_RESERVE | MEM_COMMIT,\n+                                  PAGE_EXECUTE_READWRITE);\n+      return page;\n+    }\n+\n+    // Move to the next region.\n+    address = (uptr)info.BaseAddress + info.RegionSize;\n+    scanned += info.RegionSize;\n+  }\n+  return nullptr;\n+#else\n+  return ::VirtualAlloc(nullptr,\n+                        granularity,\n+                        MEM_RESERVE | MEM_COMMIT,\n+                        PAGE_EXECUTE_READWRITE);\n+#endif\n+}\n+\n+// Used by unittests to release mapped memory space.\n+void TestOnlyReleaseTrampolineRegions() {\n+  for (size_t bucket = 0; bucket < kMaxTrampolineRegion; ++bucket) {\n+    TrampolineMemoryRegion *current = &TrampolineRegions[bucket];\n+    if (current->content == 0)\n+      return;\n+    ::VirtualFree((void*)current->content, 0, MEM_RELEASE);\n+    current->content = 0;\n+  }\n+}\n+\n+static uptr AllocateMemoryForTrampoline(uptr image_address, size_t size) {\n+  // Find a region within 2G with enough space to allocate |size| bytes.\n+  TrampolineMemoryRegion *region = nullptr;\n+  for (size_t bucket = 0; bucket < kMaxTrampolineRegion; ++bucket) {\n+    TrampolineMemoryRegion* current = &TrampolineRegions[bucket];\n+    if (current->content == 0) {\n+      // No valid region found, allocate a new region.\n+      size_t bucket_size = GetMmapGranularity();\n+      void *content = AllocateTrampolineRegion(image_address, bucket_size);\n+      if (content == nullptr)\n+        return 0U;\n+\n+      current->content = (uptr)content;\n+      current->allocated_size = 0;\n+      current->max_size = bucket_size;\n+      region = current;\n+      break;\n+    } else if (current->max_size - current->allocated_size > size) {\n+#if SANITIZER_WINDOWS64\n+        // In 64-bits, the memory space must be allocated within 2G boundary.\n+        uptr next_address = current->content + current->allocated_size;\n+        if (next_address < image_address ||\n+            next_address - image_address >= 0x7FFF0000)\n+          continue;\n+#endif\n+      // The space can be allocated in the current region.\n+      region = current;\n+      break;\n+    }\n+  }\n+\n+  // Failed to find a region.\n+  if (region == nullptr)\n+    return 0U;\n+\n+  // Allocate the space in the current region.\n+  uptr allocated_space = region->content + region->allocated_size;\n+  region->allocated_size += size;\n+  WritePadding(allocated_space, size);\n+\n+  return allocated_space;\n }\n \n // Returns 0 on error.\n-static size_t RoundUpToInstrBoundary(size_t size, char *code) {\n+static size_t GetInstructionSize(uptr address, size_t* rel_offset = nullptr) {\n+  switch (*(u64*)address) {\n+    case 0x90909090909006EB:  // stub: jmp over 6 x nop.\n+      return 8;\n+  }\n+\n+  switch (*(u8*)address) {\n+    case 0x90:  // 90 : nop\n+      return 1;\n+\n+    case 0x50:  // push eax / rax\n+    case 0x51:  // push ecx / rcx\n+    case 0x52:  // push edx / rdx\n+    case 0x53:  // push ebx / rbx\n+    case 0x54:  // push esp / rsp\n+    case 0x55:  // push ebp / rbp\n+    case 0x56:  // push esi / rsi\n+    case 0x57:  // push edi / rdi\n+    case 0x5D:  // pop ebp / rbp\n+      return 1;\n+\n+    case 0x6A:  // 6A XX = push XX\n+      return 2;\n+\n+    case 0xb8:  // b8 XX XX XX XX : mov eax, XX XX XX XX\n+    case 0xB9:  // b9 XX XX XX XX : mov ecx, XX XX XX XX\n+      return 5;\n+\n+    // Cannot overwrite control-instruction. Return 0 to indicate failure.\n+    case 0xE9:  // E9 XX XX XX XX : jmp <label>\n+    case 0xE8:  // E8 XX XX XX XX : call <func>\n+    case 0xC3:  // C3 : ret\n+    case 0xEB:  // EB XX : jmp XX (short jump)\n+    case 0x70:  // 7Y YY : jy XX (short conditional jump)\n+    case 0x71:\n+    case 0x72:\n+    case 0x73:\n+    case 0x74:\n+    case 0x75:\n+    case 0x76:\n+    case 0x77:\n+    case 0x78:\n+    case 0x79:\n+    case 0x7A:\n+    case 0x7B:\n+    case 0x7C:\n+    case 0x7D:\n+    case 0x7E:\n+    case 0x7F:\n+      return 0;\n+  }\n+\n+  switch (*(u16*)(address)) {\n+    case 0xFF8B:  // 8B FF : mov edi, edi\n+    case 0xEC8B:  // 8B EC : mov ebp, esp\n+    case 0xc889:  // 89 C8 : mov eax, ecx\n+    case 0xC18B:  // 8B C1 : mov eax, ecx\n+    case 0xC033:  // 33 C0 : xor eax, eax\n+    case 0xC933:  // 33 C9 : xor ecx, ecx\n+    case 0xD233:  // 33 D2 : xor edx, edx\n+      return 2;\n+\n+    // Cannot overwrite control-instruction. Return 0 to indicate failure.\n+    case 0x25FF:  // FF 25 XX XX XX XX : jmp [XXXXXXXX]\n+      return 0;\n+  }\n+\n+  switch (0x00FFFFFF & *(u32*)address) {\n+    case 0x24A48D:  // 8D A4 24 XX XX XX XX : lea esp, [esp + XX XX XX XX]\n+      return 7;\n+  }\n+\n+#if SANITIZER_WINDOWS64\n+  switch (*(u8*)address) {\n+    case 0xA1:  // A1 XX XX XX XX XX XX XX XX :\n+                //   movabs eax, dword ptr ds:[XXXXXXXX]\n+      return 8;\n+  }\n+\n+  switch (*(u16*)address) {\n+    case 0x5040:  // push rax\n+    case 0x5140:  // push rcx\n+    case 0x5240:  // push rdx\n+    case 0x5340:  // push rbx\n+    case 0x5440:  // push rsp\n+    case 0x5540:  // push rbp\n+    case 0x5640:  // push rsi\n+    case 0x5740:  // push rdi\n+    case 0x5441:  // push r12\n+    case 0x5541:  // push r13\n+    case 0x5641:  // push r14\n+    case 0x5741:  // push r15\n+    case 0x9066:  // Two-byte NOP\n+      return 2;\n+  }\n+\n+  switch (0x00FFFFFF & *(u32*)address) {\n+    case 0xe58948:    // 48 8b c4 : mov rbp, rsp\n+    case 0xc18b48:    // 48 8b c1 : mov rax, rcx\n+    case 0xc48b48:    // 48 8b c4 : mov rax, rsp\n+    case 0xd9f748:    // 48 f7 d9 : neg rcx\n+    case 0xd12b48:    // 48 2b d1 : sub rdx, rcx\n+    case 0x07c1f6:    // f6 c1 07 : test cl, 0x7\n+    case 0xc98548:    // 48 85 C9 : test rcx, rcx\n+    case 0xc0854d:    // 4d 85 c0 : test r8, r8\n+    case 0xc2b60f:    // 0f b6 c2 : movzx eax, dl\n+    case 0xc03345:    // 45 33 c0 : xor r8d, r8d\n+    case 0xdb3345:    // 45 33 DB : xor r11d, r11d\n+    case 0xd98b4c:    // 4c 8b d9 : mov r11, rcx\n+    case 0xd28b4c:    // 4c 8b d2 : mov r10, rdx\n+    case 0xc98b4c:    // 4C 8B C9 : mov r9, rcx\n+    case 0xd2b60f:    // 0f b6 d2 : movzx edx, dl\n+    case 0xca2b48:    // 48 2b ca : sub rcx, rdx\n+    case 0x10b70f:    // 0f b7 10 : movzx edx, WORD PTR [rax]\n+    case 0xc00b4d:    // 3d 0b c0 : or r8, r8\n+    case 0xd18b48:    // 48 8b d1 : mov rdx, rcx\n+    case 0xdc8b4c:    // 4c 8b dc : mov r11, rsp\n+    case 0xd18b4c:    // 4c 8b d1 : mov r10, rcx\n+      return 3;\n+\n+    case 0xec8348:    // 48 83 ec XX : sub rsp, XX\n+    case 0xf88349:    // 49 83 f8 XX : cmp r8, XX\n+    case 0x588948:    // 48 89 58 XX : mov QWORD PTR[rax + XX], rbx\n+      return 4;\n+\n+    case 0xec8148:    // 48 81 EC XX XX XX XX : sub rsp, XXXXXXXX\n+      return 7;\n+\n+    case 0x058b48:    // 48 8b 05 XX XX XX XX :\n+                      //   mov rax, QWORD PTR [rip + XXXXXXXX]\n+    case 0x25ff48:    // 48 ff 25 XX XX XX XX :\n+                      //   rex.W jmp QWORD PTR [rip + XXXXXXXX]\n+\n+      // Instructions having offset relative to 'rip' need offset adjustment.\n+      if (rel_offset)\n+        *rel_offset = 3;\n+      return 7;\n+\n+    case 0x2444c7:    // C7 44 24 XX YY YY YY YY\n+                      //   mov dword ptr [rsp + XX], YYYYYYYY\n+      return 8;\n+  }\n+\n+  switch (*(u32*)(address)) {\n+    case 0x24448b48:  // 48 8b 44 24 XX : mov rax, QWORD ptr [rsp + XX]\n+    case 0x246c8948:  // 48 89 6C 24 XX : mov QWORD ptr [rsp + XX], rbp\n+    case 0x245c8948:  // 48 89 5c 24 XX : mov QWORD PTR [rsp + XX], rbx\n+    case 0x24748948:  // 48 89 74 24 XX : mov QWORD PTR [rsp + XX], rsi\n+      return 5;\n+  }\n+\n+#else\n+\n+  switch (*(u8*)address) {\n+    case 0xA1:  // A1 XX XX XX XX :  mov eax, dword ptr ds:[XXXXXXXX]\n+      return 5;\n+  }\n+  switch (*(u16*)address) {\n+    case 0x458B:  // 8B 45 XX : mov eax, dword ptr [ebp + XX]\n+    case 0x5D8B:  // 8B 5D XX : mov ebx, dword ptr [ebp + XX]\n+    case 0x7D8B:  // 8B 7D XX : mov edi, dword ptr [ebp + XX]\n+    case 0xEC83:  // 83 EC XX : sub esp, XX\n+    case 0x75FF:  // FF 75 XX : push dword ptr [ebp + XX]\n+      return 3;\n+    case 0xC1F7:  // F7 C1 XX YY ZZ WW : test ecx, WWZZYYXX\n+    case 0x25FF:  // FF 25 XX YY ZZ WW : jmp dword ptr ds:[WWZZYYXX]\n+      return 6;\n+    case 0x3D83:  // 83 3D XX YY ZZ WW TT : cmp TT, WWZZYYXX\n+      return 7;\n+    case 0x7D83:  // 83 7D XX YY : cmp dword ptr [ebp + XX], YY\n+      return 4;\n+  }\n+\n+  switch (0x00FFFFFF & *(u32*)address) {\n+    case 0x24448A:  // 8A 44 24 XX : mov eal, dword ptr [esp + XX]\n+    case 0x24448B:  // 8B 44 24 XX : mov eax, dword ptr [esp + XX]\n+    case 0x244C8B:  // 8B 4C 24 XX : mov ecx, dword ptr [esp + XX]\n+    case 0x24548B:  // 8B 54 24 XX : mov edx, dword ptr [esp + XX]\n+    case 0x24748B:  // 8B 74 24 XX : mov esi, dword ptr [esp + XX]\n+    case 0x247C8B:  // 8B 7C 24 XX : mov edi, dword ptr [esp + XX]\n+      return 4;\n+  }\n+\n+  switch (*(u32*)address) {\n+    case 0x2444B60F:  // 0F B6 44 24 XX : movzx eax, byte ptr [esp + XX]\n+      return 5;\n+  }\n+#endif\n+\n+  // Unknown instruction!\n+  // FIXME: Unknown instruction failures might happen when we add a new\n+  // interceptor or a new compiler version. In either case, they should result\n+  // in visible and readable error messages. However, merely calling abort()\n+  // leads to an infinite recursion in CheckFailed.\n+  InterceptionFailed();\n+  return 0;\n+}\n+\n+// Returns 0 on error.\n+static size_t RoundUpToInstrBoundary(size_t size, uptr address) {\n   size_t cursor = 0;\n   while (cursor < size) {\n-    switch (code[cursor]) {\n-      case '\\x51':  // push ecx\n-      case '\\x52':  // push edx\n-      case '\\x53':  // push ebx\n-      case '\\x54':  // push esp\n-      case '\\x55':  // push ebp\n-      case '\\x56':  // push esi\n-      case '\\x57':  // push edi\n-      case '\\x5D':  // pop ebp\n-        cursor++;\n-        continue;\n-      case '\\x6A':  // 6A XX = push XX\n-        cursor += 2;\n-        continue;\n-      case '\\xE9':  // E9 XX YY ZZ WW = jmp WWZZYYXX\n-      case '\\xB8':  // B8 XX YY ZZ WW = mov eax, WWZZYYXX\n-        cursor += 5;\n-        continue;\n-    }\n-    switch (*(unsigned short*)(code + cursor)) {  // NOLINT\n-      case 0xFF8B:  // 8B FF = mov edi, edi\n-      case 0xEC8B:  // 8B EC = mov ebp, esp\n-      case 0xC033:  // 33 C0 = xor eax, eax\n-        cursor += 2;\n-        continue;\n-      case 0x458B:  // 8B 45 XX = mov eax, dword ptr [ebp+XXh]\n-      case 0x5D8B:  // 8B 5D XX = mov ebx, dword ptr [ebp+XXh]\n-      case 0xEC83:  // 83 EC XX = sub esp, XX\n-      case 0x75FF:  // FF 75 XX = push dword ptr [ebp+XXh]\n-        cursor += 3;\n-        continue;\n-      case 0xC1F7:  // F7 C1 XX YY ZZ WW = test ecx, WWZZYYXX\n-      case 0x25FF:  // FF 25 XX YY ZZ WW = jmp dword ptr ds:[WWZZYYXX]\n-        cursor += 6;\n-        continue;\n-      case 0x3D83:  // 83 3D XX YY ZZ WW TT = cmp TT, WWZZYYXX\n-        cursor += 7;\n-        continue;\n-    }\n-    switch (0x00FFFFFF & *(unsigned int*)(code + cursor)) {\n-      case 0x24448A:  // 8A 44 24 XX = mov eal, dword ptr [esp+XXh]\n-      case 0x24448B:  // 8B 44 24 XX = mov eax, dword ptr [esp+XXh]\n-      case 0x244C8B:  // 8B 4C 24 XX = mov ecx, dword ptr [esp+XXh]\n-      case 0x24548B:  // 8B 54 24 XX = mov edx, dword ptr [esp+XXh]\n-      case 0x24748B:  // 8B 74 24 XX = mov esi, dword ptr [esp+XXh]\n-      case 0x247C8B:  // 8B 7C 24 XX = mov edi, dword ptr [esp+XXh]\n-        cursor += 4;\n-        continue;\n+    size_t instruction_size = GetInstructionSize(address + cursor);\n+    if (!instruction_size)\n+      return 0;\n+    cursor += instruction_size;\n+  }\n+  return cursor;\n+}\n+\n+static bool CopyInstructions(uptr to, uptr from, size_t size) {\n+  size_t cursor = 0;\n+  while (cursor != size) {\n+    size_t rel_offset = 0;\n+    size_t instruction_size = GetInstructionSize(from + cursor, &rel_offset);\n+    _memcpy((void*)(to + cursor), (void*)(from + cursor),\n+            (size_t)instruction_size);\n+    if (rel_offset) {\n+      uptr delta = to - from;\n+      uptr relocated_offset = *(u32*)(to + cursor + rel_offset) - delta;\n+#if SANITIZER_WINDOWS64\n+      if (relocated_offset + 0x80000000U >= 0xFFFFFFFFU)\n+        return false;\n+#endif\n+      *(u32*)(to + cursor + rel_offset) = relocated_offset;\n     }\n+    cursor += instruction_size;\n+  }\n+  return true;\n+}\n \n-    // Unknown instruction!\n-    // FIXME: Unknown instruction failures might happen when we add a new\n-    // interceptor or a new compiler version. In either case, they should result\n-    // in visible and readable error messages. However, merely calling abort()\n-    // leads to an infinite recursion in CheckFailed.\n-    // Do we have a good way to abort with an error message here?\n-    __debugbreak();\n-    return 0;\n+\n+#if !SANITIZER_WINDOWS64\n+bool OverrideFunctionWithDetour(\n+    uptr old_func, uptr new_func, uptr *orig_old_func) {\n+  const int kDetourHeaderLen = 5;\n+  const u16 kDetourInstruction = 0xFF8B;\n+\n+  uptr header = (uptr)old_func - kDetourHeaderLen;\n+  uptr patch_length = kDetourHeaderLen + kShortJumpInstructionLength;\n+\n+  // Validate that the function is hookable.\n+  if (*(u16*)old_func != kDetourInstruction ||\n+      !IsMemoryPadding(header, kDetourHeaderLen))\n+    return false;\n+\n+  // Change memory protection to writable.\n+  DWORD protection = 0;\n+  if (!ChangeMemoryProtection(header, patch_length, &protection))\n+    return false;\n+\n+  // Write a relative jump to the redirected function.\n+  WriteJumpInstruction(header, new_func);\n+\n+  // Write the short jump to the function prefix.\n+  WriteShortJumpInstruction(old_func, header);\n+\n+  // Restore previous memory protection.\n+  if (!RestoreMemoryProtection(header, patch_length, protection))\n+    return false;\n+\n+  if (orig_old_func)\n+    *orig_old_func = old_func + kShortJumpInstructionLength;\n+\n+  return true;\n+}\n+#endif\n+\n+bool OverrideFunctionWithRedirectJump(\n+    uptr old_func, uptr new_func, uptr *orig_old_func) {\n+  // Check whether the first instruction is a relative jump.\n+  if (*(u8*)old_func != 0xE9)\n+    return false;\n+\n+  if (orig_old_func) {\n+    uptr relative_offset = *(u32*)(old_func + 1);\n+    uptr absolute_target = old_func + relative_offset + kJumpInstructionLength;\n+    *orig_old_func = absolute_target;\n   }\n \n-  return cursor;\n+#if SANITIZER_WINDOWS64\n+  // If needed, get memory space for a trampoline jump.\n+  uptr trampoline = AllocateMemoryForTrampoline(old_func, kDirectBranchLength);\n+  if (!trampoline)\n+    return false;\n+  WriteDirectBranch(trampoline, new_func);\n+#endif\n+\n+  // Change memory protection to writable.\n+  DWORD protection = 0;\n+  if (!ChangeMemoryProtection(old_func, kJumpInstructionLength, &protection))\n+    return false;\n+\n+  // Write a relative jump to the redirected function.\n+  WriteJumpInstruction(old_func, FIRST_32_SECOND_64(new_func, trampoline));\n+\n+  // Restore previous memory protection.\n+  if (!RestoreMemoryProtection(old_func, kJumpInstructionLength, protection))\n+    return false;\n+\n+  return true;\n }\n \n-bool OverrideFunction(uptr old_func, uptr new_func, uptr *orig_old_func) {\n-#ifdef _WIN64\n-#error OverrideFunction is not yet supported on x64\n+bool OverrideFunctionWithHotPatch(\n+    uptr old_func, uptr new_func, uptr *orig_old_func) {\n+  const int kHotPatchHeaderLen = kBranchLength;\n+\n+  uptr header = (uptr)old_func - kHotPatchHeaderLen;\n+  uptr patch_length = kHotPatchHeaderLen + kShortJumpInstructionLength;\n+\n+  // Validate that the function is hot patchable.\n+  size_t instruction_size = GetInstructionSize(old_func);\n+  if (instruction_size < kShortJumpInstructionLength ||\n+      !FunctionHasPadding(old_func, kHotPatchHeaderLen))\n+    return false;\n+\n+  if (orig_old_func) {\n+    // Put the needed instructions into the trampoline bytes.\n+    uptr trampoline_length = instruction_size + kDirectBranchLength;\n+    uptr trampoline = AllocateMemoryForTrampoline(old_func, trampoline_length);\n+    if (!trampoline)\n+      return false;\n+    if (!CopyInstructions(trampoline, old_func, instruction_size))\n+      return false;\n+    WriteDirectBranch(trampoline + instruction_size,\n+                      old_func + instruction_size);\n+    *orig_old_func = trampoline;\n+  }\n+\n+  // If needed, get memory space for indirect address.\n+  uptr indirect_address = 0;\n+#if SANITIZER_WINDOWS64\n+  indirect_address = AllocateMemoryForTrampoline(old_func, kAddressLength);\n+  if (!indirect_address)\n+    return false;\n #endif\n-  // Function overriding works basically like this:\n-  // We write \"jmp <new_func>\" (5 bytes) at the beginning of the 'old_func'\n-  // to override it.\n-  // We might want to be able to execute the original 'old_func' from the\n-  // wrapper, in this case we need to keep the leading 5+ bytes ('head')\n-  // of the original code somewhere with a \"jmp <old_func+head>\".\n-  // We call these 'head'+5 bytes of instructions a \"trampoline\".\n-  char *old_bytes = (char *)old_func;\n-\n-  // We'll need at least 5 bytes for a 'jmp'.\n-  size_t head = 5;\n+\n+  // Change memory protection to writable.\n+  DWORD protection = 0;\n+  if (!ChangeMemoryProtection(header, patch_length, &protection))\n+    return false;\n+\n+  // Write jumps to the redirected function.\n+  WriteBranch(header, indirect_address, new_func);\n+  WriteShortJumpInstruction(old_func, header);\n+\n+  // Restore previous memory protection.\n+  if (!RestoreMemoryProtection(header, patch_length, protection))\n+    return false;\n+\n+  return true;\n+}\n+\n+bool OverrideFunctionWithTrampoline(\n+    uptr old_func, uptr new_func, uptr *orig_old_func) {\n+\n+  size_t instructions_length = kBranchLength;\n+  size_t padding_length = 0;\n+  uptr indirect_address = 0;\n+\n   if (orig_old_func) {\n     // Find out the number of bytes of the instructions we need to copy\n-    // to the trampoline and store it in 'head'.\n-    head = RoundUpToInstrBoundary(head, old_bytes);\n-    if (!head)\n+    // to the trampoline.\n+    instructions_length = RoundUpToInstrBoundary(kBranchLength, old_func);\n+    if (!instructions_length)\n       return false;\n \n     // Put the needed instructions into the trampoline bytes.\n-    char *trampoline = GetMemoryForTrampoline(head + 5);\n+    uptr trampoline_length = instructions_length + kDirectBranchLength;\n+    uptr trampoline = AllocateMemoryForTrampoline(old_func, trampoline_length);\n     if (!trampoline)\n       return false;\n-    _memcpy(trampoline, old_bytes, head);\n-    WriteJumpInstruction(trampoline + head, old_bytes + head);\n-    *orig_old_func = (uptr)trampoline;\n+    if (!CopyInstructions(trampoline, old_func, instructions_length))\n+      return false;\n+    WriteDirectBranch(trampoline + instructions_length,\n+                      old_func + instructions_length);\n+    *orig_old_func = trampoline;\n   }\n \n-  // Now put the \"jmp <new_func>\" instruction at the original code location.\n-  // We should preserve the EXECUTE flag as some of our own code might be\n-  // located in the same page (sic!).  FIXME: might consider putting the\n-  // __interception code into a separate section or something?\n-  DWORD old_prot, unused_prot;\n-  if (!VirtualProtect((void *)old_bytes, head, PAGE_EXECUTE_READWRITE,\n-                      &old_prot))\n+#if SANITIZER_WINDOWS64\n+  // Check if the targeted address can be encoded in the function padding.\n+  // Otherwise, allocate it in the trampoline region.\n+  if (IsMemoryPadding(old_func - kAddressLength, kAddressLength)) {\n+    indirect_address = old_func - kAddressLength;\n+    padding_length = kAddressLength;\n+  } else {\n+    indirect_address = AllocateMemoryForTrampoline(old_func, kAddressLength);\n+    if (!indirect_address)\n+      return false;\n+  }\n+#endif\n+\n+  // Change memory protection to writable.\n+  uptr patch_address = old_func - padding_length;\n+  uptr patch_length = instructions_length + padding_length;\n+  DWORD protection = 0;\n+  if (!ChangeMemoryProtection(patch_address, patch_length, &protection))\n     return false;\n \n-  WriteJumpInstruction(old_bytes, (char *)new_func);\n-  _memset(old_bytes + 5, 0xCC /* int 3 */, head - 5);\n+  // Patch the original function.\n+  WriteBranch(old_func, indirect_address, new_func);\n \n-  // Restore the original permissions.\n-  if (!VirtualProtect((void *)old_bytes, head, old_prot, &unused_prot))\n-    return false;  // not clear if this failure bothers us.\n+  // Restore previous memory protection.\n+  if (!RestoreMemoryProtection(patch_address, patch_length, protection))\n+    return false;\n \n   return true;\n }\n \n+bool OverrideFunction(\n+    uptr old_func, uptr new_func, uptr *orig_old_func) {\n+#if !SANITIZER_WINDOWS64\n+  if (OverrideFunctionWithDetour(old_func, new_func, orig_old_func))\n+    return true;\n+#endif\n+  if (OverrideFunctionWithRedirectJump(old_func, new_func, orig_old_func))\n+    return true;\n+  if (OverrideFunctionWithHotPatch(old_func, new_func, orig_old_func))\n+    return true;\n+  if (OverrideFunctionWithTrampoline(old_func, new_func, orig_old_func))\n+    return true;\n+  return false;\n+}\n+\n static void **InterestingDLLsAvailable() {\n-  const char *InterestingDLLs[] = {\n-    \"kernel32.dll\",\n-    \"msvcr110.dll\", // VS2012\n-    \"msvcr120.dll\", // VS2013\n-    // NTDLL should go last as it exports some functions that we should override\n-    // in the CRT [presumably only used internally].\n-    \"ntdll.dll\", NULL\n-  };\n+  static const char *InterestingDLLs[] = {\n+      \"kernel32.dll\",\n+      \"msvcr110.dll\",      // VS2012\n+      \"msvcr120.dll\",      // VS2013\n+      \"vcruntime140.dll\",  // VS2015\n+      \"ucrtbase.dll\",      // Universal CRT\n+      // NTDLL should go last as it exports some functions that we should\n+      // override in the CRT [presumably only used internally].\n+      \"ntdll.dll\", NULL};\n   static void *result[ARRAY_SIZE(InterestingDLLs)] = { 0 };\n   if (!result[0]) {\n     for (size_t i = 0, j = 0; InterestingDLLs[i]; ++i) {\n@@ -244,26 +881,116 @@ uptr InternalGetProcAddress(void *module, const char *func_name) {\n     if (!strcmp(func_name, name)) {\n       DWORD index = ordinals[i];\n       RVAPtr<char> func(module, functions[index]);\n+\n+      // Handle forwarded functions.\n+      DWORD offset = functions[index];\n+      if (offset >= export_directory->VirtualAddress &&\n+          offset < export_directory->VirtualAddress + export_directory->Size) {\n+        // An entry for a forwarded function is a string with the following\n+        // format: \"<module> . <function_name>\" that is stored into the\n+        // exported directory.\n+        char function_name[256];\n+        size_t funtion_name_length = _strlen(func);\n+        if (funtion_name_length >= sizeof(function_name) - 1)\n+          InterceptionFailed();\n+\n+        _memcpy(function_name, func, funtion_name_length);\n+        function_name[funtion_name_length] = '\\0';\n+        char* separator = _strchr(function_name, '.');\n+        if (!separator)\n+          InterceptionFailed();\n+        *separator = '\\0';\n+\n+        void* redirected_module = GetModuleHandleA(function_name);\n+        if (!redirected_module)\n+          InterceptionFailed();\n+        return InternalGetProcAddress(redirected_module, separator + 1);\n+      }\n+\n       return (uptr)(char *)func;\n     }\n   }\n \n   return 0;\n }\n \n-static bool GetFunctionAddressInDLLs(const char *func_name, uptr *func_addr) {\n-  *func_addr = 0;\n+bool OverrideFunction(\n+    const char *func_name, uptr new_func, uptr *orig_old_func) {\n+  bool hooked = false;\n   void **DLLs = InterestingDLLsAvailable();\n-  for (size_t i = 0; *func_addr == 0 && DLLs[i]; ++i)\n-    *func_addr = InternalGetProcAddress(DLLs[i], func_name);\n-  return (*func_addr != 0);\n+  for (size_t i = 0; DLLs[i]; ++i) {\n+    uptr func_addr = InternalGetProcAddress(DLLs[i], func_name);\n+    if (func_addr &&\n+        OverrideFunction(func_addr, new_func, orig_old_func)) {\n+      hooked = true;\n+    }\n+  }\n+  return hooked;\n }\n \n-bool OverrideFunction(const char *name, uptr new_func, uptr *orig_old_func) {\n-  uptr orig_func;\n-  if (!GetFunctionAddressInDLLs(name, &orig_func))\n+bool OverrideImportedFunction(const char *module_to_patch,\n+                              const char *imported_module,\n+                              const char *function_name, uptr new_function,\n+                              uptr *orig_old_func) {\n+  HMODULE module = GetModuleHandleA(module_to_patch);\n+  if (!module)\n+    return false;\n+\n+  // Check that the module header is full and present.\n+  RVAPtr<IMAGE_DOS_HEADER> dos_stub(module, 0);\n+  RVAPtr<IMAGE_NT_HEADERS> headers(module, dos_stub->e_lfanew);\n+  if (!module || dos_stub->e_magic != IMAGE_DOS_SIGNATURE || // \"MZ\"\n+      headers->Signature != IMAGE_NT_SIGNATURE ||            // \"PE\\0\\0\"\n+      headers->FileHeader.SizeOfOptionalHeader <\n+          sizeof(IMAGE_OPTIONAL_HEADER)) {\n     return false;\n-  return OverrideFunction(orig_func, new_func, orig_old_func);\n+  }\n+\n+  IMAGE_DATA_DIRECTORY *import_directory =\n+      &headers->OptionalHeader.DataDirectory[IMAGE_DIRECTORY_ENTRY_IMPORT];\n+\n+  // Iterate the list of imported DLLs. FirstThunk will be null for the last\n+  // entry.\n+  RVAPtr<IMAGE_IMPORT_DESCRIPTOR> imports(module,\n+                                          import_directory->VirtualAddress);\n+  for (; imports->FirstThunk != 0; ++imports) {\n+    RVAPtr<const char> modname(module, imports->Name);\n+    if (_stricmp(&*modname, imported_module) == 0)\n+      break;\n+  }\n+  if (imports->FirstThunk == 0)\n+    return false;\n+\n+  // We have two parallel arrays: the import address table (IAT) and the table\n+  // of names. They start out containing the same data, but the loader rewrites\n+  // the IAT to hold imported addresses and leaves the name table in\n+  // OriginalFirstThunk alone.\n+  RVAPtr<IMAGE_THUNK_DATA> name_table(module, imports->OriginalFirstThunk);\n+  RVAPtr<IMAGE_THUNK_DATA> iat(module, imports->FirstThunk);\n+  for (; name_table->u1.Ordinal != 0; ++name_table, ++iat) {\n+    if (!IMAGE_SNAP_BY_ORDINAL(name_table->u1.Ordinal)) {\n+      RVAPtr<IMAGE_IMPORT_BY_NAME> import_by_name(\n+          module, name_table->u1.ForwarderString);\n+      const char *funcname = &import_by_name->Name[0];\n+      if (strcmp(funcname, function_name) == 0)\n+        break;\n+    }\n+  }\n+  if (name_table->u1.Ordinal == 0)\n+    return false;\n+\n+  // Now we have the correct IAT entry. Do the swap. We have to make the page\n+  // read/write first.\n+  if (orig_old_func)\n+    *orig_old_func = iat->u1.AddressOfData;\n+  DWORD old_prot, unused_prot;\n+  if (!VirtualProtect(&iat->u1.AddressOfData, 4, PAGE_EXECUTE_READWRITE,\n+                      &old_prot))\n+    return false;\n+  iat->u1.AddressOfData = new_function;\n+  if (!VirtualProtect(&iat->u1.AddressOfData, 4, old_prot, &unused_prot))\n+    return false;  // Not clear if this failure bothers us.\n+  return true;\n }\n \n }  // namespace __interception"}, {"sha": "f092d18d28f85919238a6775ba156b4d09a535fd", "filename": "libsanitizer/interception/interception_win.h", "status": "modified", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception_win.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Finterception%2Finterception_win.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Finterception%2Finterception_win.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,6 +32,31 @@ bool OverrideFunction(const char *name, uptr new_func, uptr *orig_old_func = 0);\n // Windows-only replacement for GetProcAddress. Useful for some sanitizers.\n uptr InternalGetProcAddress(void *module, const char *func_name);\n \n+// Overrides a function only when it is called from a specific DLL. For example,\n+// this is used to override calls to HeapAlloc/HeapFree from ucrtbase without\n+// affecting other third party libraries.\n+bool OverrideImportedFunction(const char *module_to_patch,\n+                              const char *imported_module,\n+                              const char *function_name, uptr new_function,\n+                              uptr *orig_old_func);\n+\n+#if !SANITIZER_WINDOWS64\n+// Exposed for unittests\n+bool OverrideFunctionWithDetour(\n+    uptr old_func, uptr new_func, uptr *orig_old_func);\n+#endif\n+\n+// Exposed for unittests\n+bool OverrideFunctionWithRedirectJump(\n+    uptr old_func, uptr new_func, uptr *orig_old_func);\n+bool OverrideFunctionWithHotPatch(\n+    uptr old_func, uptr new_func, uptr *orig_old_func);\n+bool OverrideFunctionWithTrampoline(\n+    uptr old_func, uptr new_func, uptr *orig_old_func);\n+\n+// Exposed for unittests\n+void TestOnlyReleaseTrampolineRegions();\n+\n }  // namespace __interception\n \n #if defined(INTERCEPTION_DYNAMIC_CRT)\n@@ -48,5 +73,10 @@ uptr InternalGetProcAddress(void *module, const char *func_name);\n \n #define INTERCEPT_FUNCTION_VER_WIN(func, symver) INTERCEPT_FUNCTION_WIN(func)\n \n+#define INTERCEPT_FUNCTION_DLLIMPORT(user_dll, provider_dll, func)       \\\n+  ::__interception::OverrideImportedFunction(                            \\\n+      user_dll, provider_dll, #func, (::__interception::uptr)WRAP(func), \\\n+      (::__interception::uptr *)&REAL(func))\n+\n #endif  // INTERCEPTION_WIN_H\n #endif  // _WIN32"}, {"sha": "3a618ecb838e5ab4d8a8a92e2f4526f7063ea369", "filename": "libsanitizer/libbacktrace/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flibbacktrace%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flibbacktrace%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flibbacktrace%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -211,6 +211,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@"}, {"sha": "a0c8ae9b7c67e04389583f49b109c7e0a50cb679", "filename": "libsanitizer/lsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -210,6 +210,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@"}, {"sha": "2ded5544c7101a50dafb5ee6393b0e409f7a01ba", "filename": "libsanitizer/lsan/lsan.cc", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -41,6 +41,7 @@ static void InitializeFlags() {\n     cf.CopyFrom(*common_flags());\n     cf.external_symbolizer_path = GetEnv(\"LSAN_SYMBOLIZER_PATH\");\n     cf.malloc_context_size = 30;\n+    cf.intercept_tls_get_addr = true;\n     cf.detect_leaks = true;\n     cf.exitcode = 23;\n     OverrideCommonFlags(cf);\n@@ -69,6 +70,7 @@ extern \"C\" void __lsan_init() {\n   lsan_init_is_running = true;\n   SanitizerToolName = \"LeakSanitizer\";\n   CacheBinaryName();\n+  AvoidCVE_2016_2143();\n   InitializeFlags();\n   InitCommonLsan();\n   InitializeAllocator();"}, {"sha": "6d2d427b27d47e3ec9c5b027d2a67fb2a5e4cab0", "filename": "libsanitizer/lsan/lsan.h", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -22,8 +22,11 @@\n       stack_top = t->stack_end();                                              \\\n       stack_bottom = t->stack_begin();                                         \\\n     }                                                                          \\\n-    stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(),    \\\n-                 /* context */ 0, stack_top, stack_bottom, fast);              \\\n+    if (!SANITIZER_MIPS ||                                                     \\\n+        IsValidFrame(GET_CURRENT_FRAME(), stack_top, stack_bottom)) {          \\\n+      stack.Unwind(max_size, StackTrace::GetCurrentPc(), GET_CURRENT_FRAME(),  \\\n+                   /* context */ 0, stack_top, stack_bottom, fast);            \\\n+    }                                                                          \\\n   }\n \n #define GET_STACK_TRACE_FATAL \\"}, {"sha": "0d2fceac71b8976a557355686a02b96709e692fe", "filename": "libsanitizer/lsan/lsan_allocator.cc", "status": "modified", "additions": 13, "deletions": 4, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_allocator.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -41,10 +41,17 @@ typedef SizeClassAllocator32<0, SANITIZER_MMAP_RANGE_SIZE,\n     PrimaryAllocator;\n #else\n static const uptr kMaxAllowedMallocSize = 8UL << 30;\n-static const uptr kAllocatorSpace = 0x600000000000ULL;\n-static const uptr kAllocatorSize = 0x40000000000ULL; // 4T.\n-typedef SizeClassAllocator64<kAllocatorSpace, kAllocatorSize,\n-        sizeof(ChunkMetadata), DefaultSizeClassMap> PrimaryAllocator;\n+\n+struct AP64 {  // Allocator64 parameters. Deliberately using a short name.\n+  static const uptr kSpaceBeg = 0x600000000000ULL;\n+  static const uptr kSpaceSize =  0x40000000000ULL; // 4T.\n+  static const uptr kMetadataSize = sizeof(ChunkMetadata);\n+  typedef DefaultSizeClassMap SizeClassMap;\n+  typedef NoOpMapUnmapCallback MapUnmapCallback;\n+  static const uptr kFlags = 0;\n+};\n+\n+typedef SizeClassAllocator64<AP64> PrimaryAllocator;\n #endif\n typedef SizeClassAllocatorLocalCache<PrimaryAllocator> AllocatorCache;\n typedef LargeMmapAllocator<> SecondaryAllocator;\n@@ -97,11 +104,13 @@ void *Allocate(const StackTrace &stack, uptr size, uptr alignment,\n     memset(p, 0, size);\n   RegisterAllocation(stack, p, size);\n   if (&__sanitizer_malloc_hook) __sanitizer_malloc_hook(p, size);\n+  RunMallocHooks(p, size);\n   return p;\n }\n \n void Deallocate(void *p) {\n   if (&__sanitizer_free_hook) __sanitizer_free_hook(p);\n+  RunFreeHooks(p);\n   RegisterDeallocation(p);\n   allocator.Deallocate(&cache, p);\n }"}, {"sha": "41024e11873499d193394459971419433e8409ad", "filename": "libsanitizer/lsan/lsan_common.cc", "status": "modified", "additions": 48, "deletions": 9, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -21,6 +21,7 @@\n #include \"sanitizer_common/sanitizer_stacktrace.h\"\n #include \"sanitizer_common/sanitizer_suppressions.h\"\n #include \"sanitizer_common/sanitizer_report_decorator.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n \n #if CAN_SANITIZE_LEAKS\n namespace __lsan {\n@@ -29,8 +30,17 @@ namespace __lsan {\n // also to protect the global list of root regions.\n BlockingMutex global_mutex(LINKER_INITIALIZED);\n \n+__attribute__((tls_model(\"initial-exec\")))\n THREADLOCAL int disable_counter;\n bool DisabledInThisThread() { return disable_counter > 0; }\n+void DisableInThisThread() { disable_counter++; }\n+void EnableInThisThread() {\n+  if (!disable_counter && common_flags()->detect_leaks) {\n+    Report(\"Unmatched call to __lsan_enable().\\n\");\n+    Die();\n+  }\n+  disable_counter--;\n+}\n \n Flags lsan_flags;\n \n@@ -183,9 +193,10 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n     uptr os_id = static_cast<uptr>(suspended_threads.GetThreadID(i));\n     LOG_THREADS(\"Processing thread %d.\\n\", os_id);\n     uptr stack_begin, stack_end, tls_begin, tls_end, cache_begin, cache_end;\n+    DTLS *dtls;\n     bool thread_found = GetThreadRangesLocked(os_id, &stack_begin, &stack_end,\n                                               &tls_begin, &tls_end,\n-                                              &cache_begin, &cache_end);\n+                                              &cache_begin, &cache_end, &dtls);\n     if (!thread_found) {\n       // If a thread can't be found in the thread registry, it's probably in the\n       // process of destruction. Log this event and move on.\n@@ -209,9 +220,18 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n       LOG_THREADS(\"Stack at %p-%p (SP = %p).\\n\", stack_begin, stack_end, sp);\n       if (sp < stack_begin || sp >= stack_end) {\n         // SP is outside the recorded stack range (e.g. the thread is running a\n-        // signal handler on alternate stack). Again, consider the entire stack\n-        // range to be reachable.\n+        // signal handler on alternate stack, or swapcontext was used).\n+        // Again, consider the entire stack range to be reachable.\n         LOG_THREADS(\"WARNING: stack pointer not in stack range.\\n\");\n+        uptr page_size = GetPageSizeCached();\n+        int skipped = 0;\n+        while (stack_begin < stack_end &&\n+               !IsAccessibleMemoryRange(stack_begin, 1)) {\n+          skipped++;\n+          stack_begin += page_size;\n+        }\n+        LOG_THREADS(\"Skipped %d guard page(s) to obtain stack %p-%p.\\n\",\n+                    skipped, stack_begin, stack_end);\n       } else {\n         // Shrink the stack range to ignore out-of-scope values.\n         stack_begin = sp;\n@@ -236,6 +256,17 @@ static void ProcessThreads(SuspendedThreadsList const &suspended_threads,\n         if (tls_end > cache_end)\n           ScanRangeForPointers(cache_end, tls_end, frontier, \"TLS\", kReachable);\n       }\n+      if (dtls) {\n+        for (uptr j = 0; j < dtls->dtv_size; ++j) {\n+          uptr dtls_beg = dtls->dtv[j].beg;\n+          uptr dtls_end = dtls_beg + dtls->dtv[j].size;\n+          if (dtls_beg < dtls_end) {\n+            LOG_THREADS(\"DTLS %zu at %p-%p.\\n\", j, dtls_beg, dtls_end);\n+            ScanRangeForPointers(dtls_beg, dtls_end, frontier, \"DTLS\",\n+                                 kReachable);\n+          }\n+        }\n+      }\n     }\n   }\n }\n@@ -414,6 +445,11 @@ static bool CheckForLeaks() {\n \n   if (!param.success) {\n     Report(\"LeakSanitizer has encountered a fatal error.\\n\");\n+    Report(\n+        \"HINT: For debugging, try setting environment variable \"\n+        \"LSAN_OPTIONS=verbosity=1:log_threads=1\\n\");\n+    Report(\n+        \"HINT: LeakSanitizer does not work under ptrace (strace, gdb, etc)\\n\");\n     Die();\n   }\n   param.leak_report.ApplySuppressions();\n@@ -615,6 +651,13 @@ uptr LeakReport::UnsuppressedLeakCount() {\n }\n \n } // namespace __lsan\n+#else // CAN_SANITIZE_LEAKS\n+namespace __lsan {\n+void InitCommonLsan() { }\n+void DoLeakCheck() { }\n+void DisableInThisThread() { }\n+void EnableInThisThread() { }\n+}\n #endif // CAN_SANITIZE_LEAKS\n \n using namespace __lsan;  // NOLINT\n@@ -680,18 +723,14 @@ void __lsan_unregister_root_region(const void *begin, uptr size) {\n SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_disable() {\n #if CAN_SANITIZE_LEAKS\n-  __lsan::disable_counter++;\n+  __lsan::DisableInThisThread();\n #endif\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n void __lsan_enable() {\n #if CAN_SANITIZE_LEAKS\n-  if (!__lsan::disable_counter && common_flags()->detect_leaks) {\n-    Report(\"Unmatched call to __lsan_enable().\\n\");\n-    Die();\n-  }\n-  __lsan::disable_counter--;\n+  __lsan::EnableInThisThread();\n #endif\n }\n "}, {"sha": "1091b84f108b65b7891d8c8b76bdbc2a7e0efad7", "filename": "libsanitizer/lsan/lsan_common.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -29,6 +29,7 @@\n \n namespace __sanitizer {\n class FlagParser;\n+struct DTLS;\n }\n \n namespace __lsan {\n@@ -116,6 +117,16 @@ void InitCommonLsan();\n void DoLeakCheck();\n bool DisabledInThisThread();\n \n+// Used to implement __lsan::ScopedDisabler.\n+void DisableInThisThread();\n+void EnableInThisThread();\n+// Can be used to ignore memory allocated by an intercepted\n+// function.\n+struct ScopedInterceptorDisabler {\n+  ScopedInterceptorDisabler() { DisableInThisThread(); }\n+  ~ScopedInterceptorDisabler() { EnableInThisThread(); }\n+};\n+\n // Special case for \"new T[0]\" where T is a type with DTOR.\n // new T[0] will allocate one word for the array size (0) and store a pointer\n // to the end of allocated chunk.\n@@ -139,8 +150,8 @@ bool WordIsPoisoned(uptr addr);\n void LockThreadRegistry();\n void UnlockThreadRegistry();\n bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n-                           uptr *tls_begin, uptr *tls_end,\n-                           uptr *cache_begin, uptr *cache_end);\n+                           uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n+                           uptr *cache_end, DTLS **dtls);\n void ForEachExtraStackRange(uptr os_id, RangeIteratorCallback callback,\n                             void *arg);\n // If called from the main thread, updates the main thread's TID in the thread"}, {"sha": "abbb61f07c922242575d601f7cffa26bda3fa92f", "filename": "libsanitizer/lsan/lsan_common_linux.cc", "status": "modified", "additions": 28, "deletions": 21, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_common_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_common_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -24,30 +24,33 @@\n namespace __lsan {\n \n static const char kLinkerName[] = \"ld\";\n-// We request 2 modules matching \"ld\", so we can print a warning if there's more\n-// than one match. But only the first one is actually used.\n-static char linker_placeholder[2 * sizeof(LoadedModule)] ALIGNED(64);\n+\n+static char linker_placeholder[sizeof(LoadedModule)] ALIGNED(64);\n static LoadedModule *linker = nullptr;\n \n static bool IsLinker(const char* full_name) {\n   return LibraryNameIs(full_name, kLinkerName);\n }\n \n void InitializePlatformSpecificModules() {\n-  internal_memset(linker_placeholder, 0, sizeof(linker_placeholder));\n-  uptr num_matches = GetListOfModules(\n-      reinterpret_cast<LoadedModule *>(linker_placeholder), 2, IsLinker);\n-  if (num_matches == 1) {\n-    linker = reinterpret_cast<LoadedModule *>(linker_placeholder);\n-    return;\n+  ListOfModules modules;\n+  modules.init();\n+  for (LoadedModule &module : modules) {\n+    if (!IsLinker(module.full_name())) continue;\n+    if (linker == nullptr) {\n+      linker = reinterpret_cast<LoadedModule *>(linker_placeholder);\n+      *linker = module;\n+      module = LoadedModule();\n+    } else {\n+      VReport(1, \"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n+              \"TLS will not be handled correctly.\\n\", kLinkerName);\n+      linker->clear();\n+      linker = nullptr;\n+      return;\n+    }\n   }\n-  if (num_matches == 0)\n-    VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n-            \"TLS will not be handled correctly.\\n\");\n-  else if (num_matches > 1)\n-    VReport(1, \"LeakSanitizer: Multiple modules match \\\"%s\\\". \"\n-            \"TLS will not be handled correctly.\\n\", kLinkerName);\n-  linker = nullptr;\n+  VReport(1, \"LeakSanitizer: Dynamic linker not found. \"\n+             \"TLS will not be handled correctly.\\n\");\n }\n \n static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n@@ -66,7 +69,7 @@ static int ProcessGlobalRegionsCallback(struct dl_phdr_info *info, size_t size,\n     GetAllocatorGlobalRange(&allocator_begin, &allocator_end);\n     if (begin <= allocator_begin && allocator_begin < end) {\n       CHECK_LE(allocator_begin, allocator_end);\n-      CHECK_LT(allocator_end, end);\n+      CHECK_LE(allocator_end, end);\n       if (begin < allocator_begin)\n         ScanRangeForPointers(begin, allocator_begin, frontier, \"GLOBAL\",\n                              kReachable);\n@@ -98,6 +101,7 @@ static uptr GetCallerPC(u32 stack_id, StackDepotReverseMap *map) {\n struct ProcessPlatformAllocParam {\n   Frontier *frontier;\n   StackDepotReverseMap *stack_depot_reverse_map;\n+  bool skip_linker_allocations;\n };\n \n // ForEachChunk callback. Identifies unreachable chunks which must be treated as\n@@ -115,7 +119,8 @@ static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n       caller_pc = GetCallerPC(stack_id, param->stack_depot_reverse_map);\n     // If caller_pc is unknown, this chunk may be allocated in a coroutine. Mark\n     // it as reachable, as we can't properly report its allocation stack anyway.\n-    if (caller_pc == 0 || linker->containsAddress(caller_pc)) {\n+    if (caller_pc == 0 || (param->skip_linker_allocations &&\n+                           linker->containsAddress(caller_pc))) {\n       m.set_tag(kReachable);\n       param->frontier->push_back(chunk);\n     }\n@@ -140,10 +145,12 @@ static void ProcessPlatformSpecificAllocationsCb(uptr chunk, void *arg) {\n // guaranteed to include all dynamic TLS blocks (and possibly other allocations\n // which we don't care about).\n void ProcessPlatformSpecificAllocations(Frontier *frontier) {\n-  if (!flags()->use_tls) return;\n-  if (!linker) return;\n   StackDepotReverseMap stack_depot_reverse_map;\n-  ProcessPlatformAllocParam arg = {frontier, &stack_depot_reverse_map};\n+  ProcessPlatformAllocParam arg;\n+  arg.frontier = frontier;\n+  arg.stack_depot_reverse_map = &stack_depot_reverse_map;\n+  arg.skip_linker_allocations =\n+      flags()->use_tls && flags()->use_ld_allocations && linker != nullptr;\n   ForEachChunk(ProcessPlatformSpecificAllocationsCb, &arg);\n }\n "}, {"sha": "98611257494c271fa65c8a60babdb8e7d62da087", "filename": "libsanitizer/lsan/lsan_flags.inc", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_flags.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,6 +32,10 @@ LSAN_FLAG(bool, use_tls, true,\n           \"Root set: include TLS and thread-specific storage\")\n LSAN_FLAG(bool, use_root_regions, true,\n           \"Root set: include regions added via __lsan_register_root_region().\")\n+LSAN_FLAG(bool, use_ld_allocations, true,\n+          \"Root set: mark as reachable all allocations made from dynamic \"\n+          \"linker. This was the old way to handle dynamic TLS, and will \"\n+          \"be removed soon. Do not use this flag.\")\n \n LSAN_FLAG(bool, use_unaligned, false, \"Consider unaligned pointers valid.\")\n LSAN_FLAG(bool, use_poisoned, false,"}, {"sha": "160ed5979c4f2cdac1a46f0a37e15033f57e0c19", "filename": "libsanitizer/lsan/lsan_interceptors.cc", "status": "modified", "additions": 19, "deletions": 6, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_interceptors.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -18,8 +18,10 @@\n #include \"sanitizer_common/sanitizer_internal_defs.h\"\n #include \"sanitizer_common/sanitizer_linux.h\"\n #include \"sanitizer_common/sanitizer_platform_limits_posix.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan.h\"\n #include \"lsan_allocator.h\"\n+#include \"lsan_common.h\"\n #include \"lsan_thread.h\"\n \n using namespace __lsan;\n@@ -102,6 +104,14 @@ INTERCEPTOR(int, posix_memalign, void **memptr, uptr alignment, uptr size) {\n   return 0;\n }\n \n+INTERCEPTOR(void *, __libc_memalign, uptr alignment, uptr size) {\n+  ENSURE_LSAN_INITED;\n+  GET_STACK_TRACE_MALLOC;\n+  void *res = Allocate(stack, size, alignment, kAlwaysClearMemory);\n+  DTLS_on_libc_memalign(res, size);\n+  return res;\n+}\n+\n INTERCEPTOR(void*, valloc, uptr size) {\n   ENSURE_LSAN_INITED;\n   GET_STACK_TRACE_MALLOC;\n@@ -172,11 +182,6 @@ void operator delete[](void *ptr, std::nothrow_t const &) {\n   OPERATOR_DELETE_BODY;\n }\n \n-// We need this to intercept the __libc_memalign calls that are used to\n-// allocate dynamic TLS space in ld-linux.so.\n-INTERCEPTOR(void *, __libc_memalign, uptr align, uptr s)\n-    ALIAS(WRAPPER_NAME(memalign));\n-\n ///// Thread initialization and finalization. /////\n \n static unsigned g_thread_finalize_key;\n@@ -235,7 +240,15 @@ INTERCEPTOR(int, pthread_create, void *th, void *attr,\n   p.callback = callback;\n   p.param = param;\n   atomic_store(&p.tid, 0, memory_order_relaxed);\n-  int res = REAL(pthread_create)(th, attr, __lsan_thread_start_func, &p);\n+  int res;\n+  {\n+    // Ignore all allocations made by pthread_create: thread stack/TLS may be\n+    // stored by pthread for future reuse even after thread destruction, and\n+    // the linked list it's stored in doesn't even hold valid pointers to the\n+    // objects, the latter are calculated by obscure pointer arithmetic.\n+    ScopedInterceptorDisabler disabler;\n+    res = REAL(pthread_create)(th, attr, __lsan_thread_start_func, &p);\n+  }\n   if (res == 0) {\n     int tid = ThreadCreate(GetCurrentThread(), *(uptr *)th, detached);\n     CHECK_NE(tid, 0);"}, {"sha": "af5ad47913f4ed436ab2a6c6121c2d65bf4592f3", "filename": "libsanitizer/lsan/lsan_thread.cc", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -15,6 +15,7 @@\n #include \"sanitizer_common/sanitizer_common.h\"\n #include \"sanitizer_common/sanitizer_placement_new.h\"\n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n+#include \"sanitizer_common/sanitizer_tls_get_addr.h\"\n #include \"lsan_allocator.h\"\n \n namespace __lsan {\n@@ -33,7 +34,7 @@ static const uptr kMaxThreads = 1 << 13;\n static const uptr kThreadQuarantineSize = 64;\n \n void InitializeThreadRegistry() {\n-  static char thread_registry_placeholder[sizeof(ThreadRegistry)] ALIGNED(64);\n+  static ALIGNED(64) char thread_registry_placeholder[sizeof(ThreadRegistry)];\n   thread_registry = new(thread_registry_placeholder)\n     ThreadRegistry(CreateThreadContext, kMaxThreads, kThreadQuarantineSize);\n }\n@@ -47,18 +48,20 @@ void SetCurrentThread(u32 tid) {\n }\n \n ThreadContext::ThreadContext(int tid)\n-  : ThreadContextBase(tid),\n-    stack_begin_(0),\n-    stack_end_(0),\n-    cache_begin_(0),\n-    cache_end_(0),\n-    tls_begin_(0),\n-    tls_end_(0) {}\n+    : ThreadContextBase(tid),\n+      stack_begin_(0),\n+      stack_end_(0),\n+      cache_begin_(0),\n+      cache_end_(0),\n+      tls_begin_(0),\n+      tls_end_(0),\n+      dtls_(nullptr) {}\n \n struct OnStartedArgs {\n   uptr stack_begin, stack_end,\n        cache_begin, cache_end,\n        tls_begin, tls_end;\n+  DTLS *dtls;\n };\n \n void ThreadContext::OnStarted(void *arg) {\n@@ -69,10 +72,12 @@ void ThreadContext::OnStarted(void *arg) {\n   tls_end_ = args->tls_end;\n   cache_begin_ = args->cache_begin;\n   cache_end_ = args->cache_end;\n+  dtls_ = args->dtls;\n }\n \n void ThreadContext::OnFinished() {\n   AllocatorThreadFinish();\n+  DTLS_Destroy();\n }\n \n u32 ThreadCreate(u32 parent_tid, uptr user_id, bool detached) {\n@@ -89,6 +94,7 @@ void ThreadStart(u32 tid, uptr os_id) {\n   args.stack_end = args.stack_begin + stack_size;\n   args.tls_end = args.tls_begin + tls_size;\n   GetAllocatorCacheRange(&args.cache_begin, &args.cache_end);\n+  args.dtls = DTLS_Get();\n   thread_registry->StartThread(tid, os_id, &args);\n }\n \n@@ -129,8 +135,8 @@ void EnsureMainThreadIDIsCorrect() {\n ///// Interface to the common LSan module. /////\n \n bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n-                           uptr *tls_begin, uptr *tls_end,\n-                           uptr *cache_begin, uptr *cache_end) {\n+                           uptr *tls_begin, uptr *tls_end, uptr *cache_begin,\n+                           uptr *cache_end, DTLS **dtls) {\n   ThreadContext *context = static_cast<ThreadContext *>(\n       thread_registry->FindThreadContextByOsIDLocked(os_id));\n   if (!context) return false;\n@@ -140,6 +146,7 @@ bool GetThreadRangesLocked(uptr os_id, uptr *stack_begin, uptr *stack_end,\n   *tls_end = context->tls_end();\n   *cache_begin = context->cache_begin();\n   *cache_end = context->cache_end();\n+  *dtls = context->dtls();\n   return true;\n }\n "}, {"sha": "dafd8af0a297ef8ef09ecbb9ad889d9fceca4514", "filename": "libsanitizer/lsan/lsan_thread.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_thread.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Flsan%2Flsan_thread.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Flsan%2Flsan_thread.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -15,6 +15,10 @@\n \n #include \"sanitizer_common/sanitizer_thread_registry.h\"\n \n+namespace __sanitizer {\n+struct DTLS;\n+}\n+\n namespace __lsan {\n \n class ThreadContext : public ThreadContextBase {\n@@ -28,10 +32,13 @@ class ThreadContext : public ThreadContextBase {\n   uptr tls_end() { return tls_end_; }\n   uptr cache_begin() { return cache_begin_; }\n   uptr cache_end() { return cache_end_; }\n+  DTLS *dtls() { return dtls_; }\n+\n  private:\n   uptr stack_begin_, stack_end_,\n        cache_begin_, cache_end_,\n        tls_begin_, tls_end_;\n+  DTLS *dtls_;\n };\n \n void InitializeThreadRegistry();"}, {"sha": "b332102773344efb15061880bc844d4a5301475c", "filename": "libsanitizer/merge.sh", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fmerge.sh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fmerge.sh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fmerge.sh?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -72,6 +72,10 @@ merge lib/sanitizer_common sanitizer_common\n merge lib/interception interception\n merge lib/ubsan ubsan\n \n+# Need to merge lib/builtins/assembly.h file:\n+mkdir -p builtins\n+cp -v upstream/lib/builtins/assembly.h builtins/assembly.h\n+\n rm -rf upstream\n \n # Update the MERGE file."}, {"sha": "8b6336fd3ade88307fe5bd41e165eb4e9e2886f0", "filename": "libsanitizer/sanitizer_common/Makefile.am", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.am?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,6 +32,7 @@ sanitizer_common_files = \\\n \tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n+\tsanitizer_linux_s390.cc \\\n \tsanitizer_mac.cc \\\n \tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n@@ -55,13 +56,17 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_libcdep.cc \\\n \tsanitizer_symbolizer_posix_libcdep.cc \\\n \tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_termination.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n \tsanitizer_unwind_linux_libcdep.cc \\\n \tsanitizer_win.cc\n \n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n+EXTRA_libsanitizer_common_la_SOURCES = sanitizer_linux_mips64.S sanitizer_linux_x86_64.S\n+libsanitizer_common_la_LIBADD = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n+libsanitizer_common_la_DEPENDENCIES =  $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and"}, {"sha": "052802e176a6845559cc72a1442f1d094854d8d2", "filename": "libsanitizer/sanitizer_common/Makefile.in", "status": "modified", "additions": 54, "deletions": 8, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -79,16 +79,16 @@ CONFIG_HEADER = $(top_builddir)/config.h\n CONFIG_CLEAN_FILES =\n CONFIG_CLEAN_VPATH_FILES =\n LTLIBRARIES = $(noinst_LTLIBRARIES)\n-libsanitizer_common_la_LIBADD =\n+am__DEPENDENCIES_1 =\n am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_common_libcdep.lo sanitizer_coverage_libcdep.lo \\\n \tsanitizer_coverage_mapping_libcdep.lo \\\n \tsanitizer_deadlock_detector1.lo \\\n \tsanitizer_deadlock_detector2.lo sanitizer_flags.lo \\\n \tsanitizer_flag_parser.lo sanitizer_libc.lo \\\n \tsanitizer_libignore.lo sanitizer_linux.lo \\\n-\tsanitizer_linux_libcdep.lo sanitizer_mac.lo \\\n-\tsanitizer_persistent_allocator.lo \\\n+\tsanitizer_linux_libcdep.lo sanitizer_linux_s390.lo \\\n+\tsanitizer_mac.lo sanitizer_persistent_allocator.lo \\\n \tsanitizer_platform_limits_linux.lo \\\n \tsanitizer_platform_limits_posix.lo sanitizer_posix.lo \\\n \tsanitizer_posix_libcdep.lo sanitizer_printf.lo \\\n@@ -102,15 +102,20 @@ am__objects_1 = sanitizer_allocator.lo sanitizer_common.lo \\\n \tsanitizer_symbolizer_libbacktrace.lo \\\n \tsanitizer_symbolizer_libcdep.lo \\\n \tsanitizer_symbolizer_posix_libcdep.lo \\\n-\tsanitizer_symbolizer_win.lo sanitizer_thread_registry.lo \\\n-\tsanitizer_tls_get_addr.lo sanitizer_unwind_linux_libcdep.lo \\\n-\tsanitizer_win.lo\n+\tsanitizer_symbolizer_win.lo sanitizer_termination.lo \\\n+\tsanitizer_thread_registry.lo sanitizer_tls_get_addr.lo \\\n+\tsanitizer_unwind_linux_libcdep.lo sanitizer_win.lo\n am_libsanitizer_common_la_OBJECTS = $(am__objects_1)\n libsanitizer_common_la_OBJECTS = $(am_libsanitizer_common_la_OBJECTS)\n DEFAULT_INCLUDES = -I.@am__isrc@ -I$(top_builddir)\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n am__depfiles_maybe = depfiles\n am__mv = mv -f\n+CPPASCOMPILE = $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n+LTCPPASCOMPILE = $(LIBTOOL) $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CCAS) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CCASFLAGS) $(CCASFLAGS)\n CXXCOMPILE = $(CXX) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n \t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CXXFLAGS) $(CXXFLAGS)\n LTCXXCOMPILE = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n@@ -120,7 +125,17 @@ CXXLD = $(CXX)\n CXXLINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CXXLD) $(AM_CXXFLAGS) $(CXXFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n-SOURCES = $(libsanitizer_common_la_SOURCES)\n+COMPILE = $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) \\\n+\t$(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+LTCOMPILE = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) \\\n+\t$(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS)\n+CCLD = $(CC)\n+LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n+\t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n+\t$(LDFLAGS) -o $@\n+SOURCES = $(libsanitizer_common_la_SOURCES) \\\n+\t$(EXTRA_libsanitizer_common_la_SOURCES)\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n     n|no|NO) false;; \\\n@@ -198,6 +213,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@\n@@ -296,6 +312,7 @@ sanitizer_common_files = \\\n \tsanitizer_libignore.cc \\\n \tsanitizer_linux.cc \\\n \tsanitizer_linux_libcdep.cc \\\n+\tsanitizer_linux_s390.cc \\\n \tsanitizer_mac.cc \\\n \tsanitizer_persistent_allocator.cc \\\n \tsanitizer_platform_limits_linux.cc \\\n@@ -319,12 +336,16 @@ sanitizer_common_files = \\\n \tsanitizer_symbolizer_libcdep.cc \\\n \tsanitizer_symbolizer_posix_libcdep.cc \\\n \tsanitizer_symbolizer_win.cc \\\n+\tsanitizer_termination.cc \\\n \tsanitizer_thread_registry.cc \\\n \tsanitizer_tls_get_addr.cc \\\n \tsanitizer_unwind_linux_libcdep.cc \\\n \tsanitizer_win.cc\n \n libsanitizer_common_la_SOURCES = $(sanitizer_common_files) \n+EXTRA_libsanitizer_common_la_SOURCES = sanitizer_linux_mips64.S sanitizer_linux_x86_64.S\n+libsanitizer_common_la_LIBADD = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n+libsanitizer_common_la_DEPENDENCIES = $(SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS)\n \n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n@@ -368,7 +389,7 @@ MAKEOVERRIDES =\n all: all-am\n \n .SUFFIXES:\n-.SUFFIXES: .cc .lo .o .obj\n+.SUFFIXES: .S .cc .lo .o .obj\n $(srcdir)/Makefile.in: @MAINTAINER_MODE_TRUE@ $(srcdir)/Makefile.am  $(am__configure_deps)\n \t@for dep in $?; do \\\n \t  case '$(am__configure_deps)' in \\\n@@ -430,6 +451,9 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_libignore.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_libcdep.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_mips64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_s390.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_linux_x86_64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_persistent_allocator.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_platform_limits_linux.Plo@am__quote@\n@@ -453,11 +477,33 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_posix_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_symbolizer_win.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_termination.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_thread_registry.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_tls_get_addr.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_unwind_linux_libcdep.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/sanitizer_win.Plo@am__quote@\n \n+.S.o:\n+@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(CPPASCOMPILE) -c -o $@ $<\n+\n+.S.obj:\n+@am__fastdepCCAS_TRUE@\t$(CPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ `$(CYGPATH_W) '$<'`\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=no @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(CPPASCOMPILE) -c -o $@ `$(CYGPATH_W) '$<'`\n+\n+.S.lo:\n+@am__fastdepCCAS_TRUE@\t$(LTCPPASCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n+@am__fastdepCCAS_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Plo\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tsource='$<' object='$@' libtool=yes @AMDEPBACKSLASH@\n+@AMDEP_TRUE@@am__fastdepCCAS_FALSE@\tDEPDIR=$(DEPDIR) $(CCASDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n+@am__fastdepCCAS_FALSE@\t$(LTCPPASCOMPILE) -c -o $@ $<\n+\n .cc.o:\n @am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n @am__fastdepCXX_TRUE@\t$(am__mv) $(DEPDIR)/$*.Tpo $(DEPDIR)/$*.Po"}, {"sha": "2755853acbcd4f68e2da420c19c574c69f5bd695", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.cc", "status": "modified", "additions": 90, "deletions": 17, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -11,39 +11,72 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_allocator.h\"\n+\n #include \"sanitizer_allocator_internal.h\"\n+#include \"sanitizer_atomic.h\"\n #include \"sanitizer_common.h\"\n \n namespace __sanitizer {\n \n // ThreadSanitizer for Go uses libc malloc/free.\n-#if defined(SANITIZER_GO) || defined(SANITIZER_USE_MALLOC)\n+#if SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n # if SANITIZER_LINUX && !SANITIZER_ANDROID\n extern \"C\" void *__libc_malloc(uptr size);\n+#  if !SANITIZER_GO\n+extern \"C\" void *__libc_memalign(uptr alignment, uptr size);\n+#  endif\n+extern \"C\" void *__libc_realloc(void *ptr, uptr size);\n extern \"C\" void __libc_free(void *ptr);\n-#  define LIBC_MALLOC __libc_malloc\n-#  define LIBC_FREE __libc_free\n # else\n #  include <stdlib.h>\n-#  define LIBC_MALLOC malloc\n-#  define LIBC_FREE free\n+#  define __libc_malloc malloc\n+#  if !SANITIZER_GO\n+static void *__libc_memalign(uptr alignment, uptr size) {\n+  void *p;\n+  uptr error = posix_memalign(&p, alignment, size);\n+  if (error) return nullptr;\n+  return p;\n+}\n+#  endif\n+#  define __libc_realloc realloc\n+#  define __libc_free free\n # endif\n \n-static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {\n+static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache,\n+                              uptr alignment) {\n+  (void)cache;\n+#if !SANITIZER_GO\n+  if (alignment == 0)\n+    return __libc_malloc(size);\n+  else\n+    return __libc_memalign(alignment, size);\n+#else\n+  // Windows does not provide __libc_memalign/posix_memalign. It provides\n+  // __aligned_malloc, but the allocated blocks can't be passed to free,\n+  // they need to be passed to __aligned_free. InternalAlloc interface does\n+  // not account for such requirement. Alignemnt does not seem to be used\n+  // anywhere in runtime, so just call __libc_malloc for now.\n+  DCHECK_EQ(alignment, 0);\n+  return __libc_malloc(size);\n+#endif\n+}\n+\n+static void *RawInternalRealloc(void *ptr, uptr size,\n+                                InternalAllocatorCache *cache) {\n   (void)cache;\n-  return LIBC_MALLOC(size);\n+  return __libc_realloc(ptr, size);\n }\n \n static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n   (void)cache;\n-  LIBC_FREE(ptr);\n+  __libc_free(ptr);\n }\n \n InternalAllocator *internal_allocator() {\n   return 0;\n }\n \n-#else // SANITIZER_GO\n+#else  // SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n \n static ALIGNED(64) char internal_alloc_placeholder[sizeof(InternalAllocator)];\n static atomic_uint8_t internal_allocator_initialized;\n@@ -66,13 +99,26 @@ InternalAllocator *internal_allocator() {\n   return internal_allocator_instance;\n }\n \n-static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache) {\n+static void *RawInternalAlloc(uptr size, InternalAllocatorCache *cache,\n+                              uptr alignment) {\n+  if (alignment == 0) alignment = 8;\n+  if (cache == 0) {\n+    SpinMutexLock l(&internal_allocator_cache_mu);\n+    return internal_allocator()->Allocate(&internal_allocator_cache, size,\n+                                          alignment, false);\n+  }\n+  return internal_allocator()->Allocate(cache, size, alignment, false);\n+}\n+\n+static void *RawInternalRealloc(void *ptr, uptr size,\n+                                InternalAllocatorCache *cache) {\n+  uptr alignment = 8;\n   if (cache == 0) {\n     SpinMutexLock l(&internal_allocator_cache_mu);\n-    return internal_allocator()->Allocate(&internal_allocator_cache, size, 8,\n-                                          false);\n+    return internal_allocator()->Reallocate(&internal_allocator_cache, ptr,\n+                                            size, alignment);\n   }\n-  return internal_allocator()->Allocate(cache, size, 8, false);\n+  return internal_allocator()->Reallocate(cache, ptr, size, alignment);\n }\n \n static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n@@ -83,20 +129,42 @@ static void RawInternalFree(void *ptr, InternalAllocatorCache *cache) {\n   internal_allocator()->Deallocate(cache, ptr);\n }\n \n-#endif // SANITIZER_GO\n+#endif  // SANITIZER_GO || defined(SANITIZER_USE_MALLOC)\n \n const u64 kBlockMagic = 0x6A6CB03ABCEBC041ull;\n \n-void *InternalAlloc(uptr size, InternalAllocatorCache *cache) {\n+void *InternalAlloc(uptr size, InternalAllocatorCache *cache, uptr alignment) {\n   if (size + sizeof(u64) < size)\n     return nullptr;\n-  void *p = RawInternalAlloc(size + sizeof(u64), cache);\n+  void *p = RawInternalAlloc(size + sizeof(u64), cache, alignment);\n   if (!p)\n     return nullptr;\n   ((u64*)p)[0] = kBlockMagic;\n   return (char*)p + sizeof(u64);\n }\n \n+void *InternalRealloc(void *addr, uptr size, InternalAllocatorCache *cache) {\n+  if (!addr)\n+    return InternalAlloc(size, cache);\n+  if (size + sizeof(u64) < size)\n+    return nullptr;\n+  addr = (char*)addr - sizeof(u64);\n+  size = size + sizeof(u64);\n+  CHECK_EQ(kBlockMagic, ((u64*)addr)[0]);\n+  void *p = RawInternalRealloc(addr, size, cache);\n+  if (!p)\n+    return nullptr;\n+  return (char*)p + sizeof(u64);\n+}\n+\n+void *InternalCalloc(uptr count, uptr size, InternalAllocatorCache *cache) {\n+  if (CallocShouldReturnNullDueToOverflow(count, size))\n+    return internal_allocator()->ReturnNullOrDieOnBadRequest();\n+  void *p = InternalAlloc(count * size, cache);\n+  if (p) internal_memset(p, 0, count * size);\n+  return p;\n+}\n+\n void InternalFree(void *addr, InternalAllocatorCache *cache) {\n   if (!addr)\n     return;\n@@ -138,7 +206,12 @@ bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n) {\n   return (max / size) < n;\n }\n \n-void NORETURN ReportAllocatorCannotReturnNull() {\n+static atomic_uint8_t reporting_out_of_memory = {0};\n+\n+bool IsReportingOOM() { return atomic_load_relaxed(&reporting_out_of_memory); }\n+\n+void NORETURN ReportAllocatorCannotReturnNull(bool out_of_memory) {\n+  if (out_of_memory) atomic_store_relaxed(&reporting_out_of_memory, 1);\n   Report(\"%s's allocator is terminating the process instead of returning 0\\n\",\n          SanitizerToolName);\n   Report(\"If you don't like this behavior set allocator_may_return_null=1\\n\");"}, {"sha": "ba50acddbbf3452e959da0339f85fb10c62f3f65", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator.h", "status": "modified", "additions": 15, "deletions": 1413, "changes": 1428, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -18,271 +18,16 @@\n #include \"sanitizer_list.h\"\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_lfstack.h\"\n+#include \"sanitizer_procmaps.h\"\n \n namespace __sanitizer {\n \n-// Prints error message and kills the program.\n-void NORETURN ReportAllocatorCannotReturnNull();\n-\n-// SizeClassMap maps allocation sizes into size classes and back.\n-// Class 0 corresponds to size 0.\n-// Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).\n-// Next 4 classes: 256 + i * 64  (i = 1 to 4).\n-// Next 4 classes: 512 + i * 128 (i = 1 to 4).\n-// ...\n-// Next 4 classes: 2^k + i * 2^(k-2) (i = 1 to 4).\n-// Last class corresponds to kMaxSize = 1 << kMaxSizeLog.\n-//\n-// This structure of the size class map gives us:\n-//   - Efficient table-free class-to-size and size-to-class functions.\n-//   - Difference between two consequent size classes is betweed 14% and 25%\n-//\n-// This class also gives a hint to a thread-caching allocator about the amount\n-// of chunks that need to be cached per-thread:\n-//  - kMaxNumCached is the maximal number of chunks per size class.\n-//  - (1 << kMaxBytesCachedLog) is the maximal number of bytes per size class.\n-//\n-// Part of output of SizeClassMap::Print():\n-// c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0\n-// c01 => s: 16 diff: +16 00% l 4 cached: 256 4096; id 1\n-// c02 => s: 32 diff: +16 100% l 5 cached: 256 8192; id 2\n-// c03 => s: 48 diff: +16 50% l 5 cached: 256 12288; id 3\n-// c04 => s: 64 diff: +16 33% l 6 cached: 256 16384; id 4\n-// c05 => s: 80 diff: +16 25% l 6 cached: 256 20480; id 5\n-// c06 => s: 96 diff: +16 20% l 6 cached: 256 24576; id 6\n-// c07 => s: 112 diff: +16 16% l 6 cached: 256 28672; id 7\n-//\n-// c08 => s: 128 diff: +16 14% l 7 cached: 256 32768; id 8\n-// c09 => s: 144 diff: +16 12% l 7 cached: 256 36864; id 9\n-// c10 => s: 160 diff: +16 11% l 7 cached: 256 40960; id 10\n-// c11 => s: 176 diff: +16 10% l 7 cached: 256 45056; id 11\n-// c12 => s: 192 diff: +16 09% l 7 cached: 256 49152; id 12\n-// c13 => s: 208 diff: +16 08% l 7 cached: 256 53248; id 13\n-// c14 => s: 224 diff: +16 07% l 7 cached: 256 57344; id 14\n-// c15 => s: 240 diff: +16 07% l 7 cached: 256 61440; id 15\n-//\n-// c16 => s: 256 diff: +16 06% l 8 cached: 256 65536; id 16\n-// c17 => s: 320 diff: +64 25% l 8 cached: 204 65280; id 17\n-// c18 => s: 384 diff: +64 20% l 8 cached: 170 65280; id 18\n-// c19 => s: 448 diff: +64 16% l 8 cached: 146 65408; id 19\n-//\n-// c20 => s: 512 diff: +64 14% l 9 cached: 128 65536; id 20\n-// c21 => s: 640 diff: +128 25% l 9 cached: 102 65280; id 21\n-// c22 => s: 768 diff: +128 20% l 9 cached: 85 65280; id 22\n-// c23 => s: 896 diff: +128 16% l 9 cached: 73 65408; id 23\n-//\n-// c24 => s: 1024 diff: +128 14% l 10 cached: 64 65536; id 24\n-// c25 => s: 1280 diff: +256 25% l 10 cached: 51 65280; id 25\n-// c26 => s: 1536 diff: +256 20% l 10 cached: 42 64512; id 26\n-// c27 => s: 1792 diff: +256 16% l 10 cached: 36 64512; id 27\n-//\n-// ...\n-//\n-// c48 => s: 65536 diff: +8192 14% l 16 cached: 1 65536; id 48\n-// c49 => s: 81920 diff: +16384 25% l 16 cached: 1 81920; id 49\n-// c50 => s: 98304 diff: +16384 20% l 16 cached: 1 98304; id 50\n-// c51 => s: 114688 diff: +16384 16% l 16 cached: 1 114688; id 51\n-//\n-// c52 => s: 131072 diff: +16384 14% l 17 cached: 1 131072; id 52\n-\n-template <uptr kMaxSizeLog, uptr kMaxNumCachedT, uptr kMaxBytesCachedLog>\n-class SizeClassMap {\n-  static const uptr kMinSizeLog = 4;\n-  static const uptr kMidSizeLog = kMinSizeLog + 4;\n-  static const uptr kMinSize = 1 << kMinSizeLog;\n-  static const uptr kMidSize = 1 << kMidSizeLog;\n-  static const uptr kMidClass = kMidSize / kMinSize;\n-  static const uptr S = 2;\n-  static const uptr M = (1 << S) - 1;\n-\n- public:\n-  static const uptr kMaxNumCached = kMaxNumCachedT;\n-  // We transfer chunks between central and thread-local free lists in batches.\n-  // For small size classes we allocate batches separately.\n-  // For large size classes we use one of the chunks to store the batch.\n-  struct TransferBatch {\n-    TransferBatch *next;\n-    uptr count;\n-    void *batch[kMaxNumCached];\n-  };\n-\n-  static const uptr kMaxSize = 1UL << kMaxSizeLog;\n-  static const uptr kNumClasses =\n-      kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1;\n-  COMPILER_CHECK(kNumClasses >= 32 && kNumClasses <= 256);\n-  static const uptr kNumClassesRounded =\n-      kNumClasses == 32  ? 32 :\n-      kNumClasses <= 64  ? 64 :\n-      kNumClasses <= 128 ? 128 : 256;\n-\n-  static uptr Size(uptr class_id) {\n-    if (class_id <= kMidClass)\n-      return kMinSize * class_id;\n-    class_id -= kMidClass;\n-    uptr t = kMidSize << (class_id >> S);\n-    return t + (t >> S) * (class_id & M);\n-  }\n-\n-  static uptr ClassID(uptr size) {\n-    if (size <= kMidSize)\n-      return (size + kMinSize - 1) >> kMinSizeLog;\n-    if (size > kMaxSize) return 0;\n-    uptr l = MostSignificantSetBitIndex(size);\n-    uptr hbits = (size >> (l - S)) & M;\n-    uptr lbits = size & ((1 << (l - S)) - 1);\n-    uptr l1 = l - kMidSizeLog;\n-    return kMidClass + (l1 << S) + hbits + (lbits > 0);\n-  }\n-\n-  static uptr MaxCached(uptr class_id) {\n-    if (class_id == 0) return 0;\n-    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);\n-    return Max<uptr>(1, Min(kMaxNumCached, n));\n-  }\n-\n-  static void Print() {\n-    uptr prev_s = 0;\n-    uptr total_cached = 0;\n-    for (uptr i = 0; i < kNumClasses; i++) {\n-      uptr s = Size(i);\n-      if (s >= kMidSize / 2 && (s & (s - 1)) == 0)\n-        Printf(\"\\n\");\n-      uptr d = s - prev_s;\n-      uptr p = prev_s ? (d * 100 / prev_s) : 0;\n-      uptr l = s ? MostSignificantSetBitIndex(s) : 0;\n-      uptr cached = MaxCached(i) * s;\n-      Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n-             \"cached: %zd %zd; id %zd\\n\",\n-             i, Size(i), d, p, l, MaxCached(i), cached, ClassID(s));\n-      total_cached += cached;\n-      prev_s = s;\n-    }\n-    Printf(\"Total cached: %zd\\n\", total_cached);\n-  }\n-\n-  static bool SizeClassRequiresSeparateTransferBatch(uptr class_id) {\n-    return Size(class_id) < sizeof(TransferBatch) -\n-        sizeof(uptr) * (kMaxNumCached - MaxCached(class_id));\n-  }\n-\n-  static void Validate() {\n-    for (uptr c = 1; c < kNumClasses; c++) {\n-      // Printf(\"Validate: c%zd\\n\", c);\n-      uptr s = Size(c);\n-      CHECK_NE(s, 0U);\n-      CHECK_EQ(ClassID(s), c);\n-      if (c != kNumClasses - 1)\n-        CHECK_EQ(ClassID(s + 1), c + 1);\n-      CHECK_EQ(ClassID(s - 1), c);\n-      if (c)\n-        CHECK_GT(Size(c), Size(c-1));\n-    }\n-    CHECK_EQ(ClassID(kMaxSize + 1), 0);\n-\n-    for (uptr s = 1; s <= kMaxSize; s++) {\n-      uptr c = ClassID(s);\n-      // Printf(\"s%zd => c%zd\\n\", s, c);\n-      CHECK_LT(c, kNumClasses);\n-      CHECK_GE(Size(c), s);\n-      if (c > 0)\n-        CHECK_LT(Size(c-1), s);\n-    }\n-  }\n-};\n+// Returns true if ReportAllocatorCannotReturnNull(true) was called.\n+// Can be use to avoid memory hungry operations.\n+bool IsReportingOOM();\n \n-typedef SizeClassMap<17, 128, 16> DefaultSizeClassMap;\n-typedef SizeClassMap<17, 64,  14> CompactSizeClassMap;\n-template<class SizeClassAllocator> struct SizeClassAllocatorLocalCache;\n-\n-// Memory allocator statistics\n-enum AllocatorStat {\n-  AllocatorStatAllocated,\n-  AllocatorStatMapped,\n-  AllocatorStatCount\n-};\n-\n-typedef uptr AllocatorStatCounters[AllocatorStatCount];\n-\n-// Per-thread stats, live in per-thread cache.\n-class AllocatorStats {\n- public:\n-  void Init() {\n-    internal_memset(this, 0, sizeof(*this));\n-  }\n-  void InitLinkerInitialized() {}\n-\n-  void Add(AllocatorStat i, uptr v) {\n-    v += atomic_load(&stats_[i], memory_order_relaxed);\n-    atomic_store(&stats_[i], v, memory_order_relaxed);\n-  }\n-\n-  void Sub(AllocatorStat i, uptr v) {\n-    v = atomic_load(&stats_[i], memory_order_relaxed) - v;\n-    atomic_store(&stats_[i], v, memory_order_relaxed);\n-  }\n-\n-  void Set(AllocatorStat i, uptr v) {\n-    atomic_store(&stats_[i], v, memory_order_relaxed);\n-  }\n-\n-  uptr Get(AllocatorStat i) const {\n-    return atomic_load(&stats_[i], memory_order_relaxed);\n-  }\n-\n- private:\n-  friend class AllocatorGlobalStats;\n-  AllocatorStats *next_;\n-  AllocatorStats *prev_;\n-  atomic_uintptr_t stats_[AllocatorStatCount];\n-};\n-\n-// Global stats, used for aggregation and querying.\n-class AllocatorGlobalStats : public AllocatorStats {\n- public:\n-  void InitLinkerInitialized() {\n-    next_ = this;\n-    prev_ = this;\n-  }\n-  void Init() {\n-    internal_memset(this, 0, sizeof(*this));\n-    InitLinkerInitialized();\n-  }\n-\n-  void Register(AllocatorStats *s) {\n-    SpinMutexLock l(&mu_);\n-    s->next_ = next_;\n-    s->prev_ = this;\n-    next_->prev_ = s;\n-    next_ = s;\n-  }\n-\n-  void Unregister(AllocatorStats *s) {\n-    SpinMutexLock l(&mu_);\n-    s->prev_->next_ = s->next_;\n-    s->next_->prev_ = s->prev_;\n-    for (int i = 0; i < AllocatorStatCount; i++)\n-      Add(AllocatorStat(i), s->Get(AllocatorStat(i)));\n-  }\n-\n-  void Get(AllocatorStatCounters s) const {\n-    internal_memset(s, 0, AllocatorStatCount * sizeof(uptr));\n-    SpinMutexLock l(&mu_);\n-    const AllocatorStats *stats = this;\n-    for (;;) {\n-      for (int i = 0; i < AllocatorStatCount; i++)\n-        s[i] += stats->Get(AllocatorStat(i));\n-      stats = stats->next_;\n-      if (stats == this)\n-        break;\n-    }\n-    // All stats must be non-negative.\n-    for (int i = 0; i < AllocatorStatCount; i++)\n-      s[i] = ((sptr)s[i]) >= 0 ? s[i] : 0;\n-  }\n-\n- private:\n-  mutable SpinMutex mu_;\n-};\n+// Prints error message and kills the program.\n+void NORETURN ReportAllocatorCannotReturnNull(bool out_of_memory);\n \n // Allocators call these callbacks on mmap/munmap.\n struct NoOpMapUnmapCallback {\n@@ -293,1161 +38,18 @@ struct NoOpMapUnmapCallback {\n // Callback type for iterating over chunks.\n typedef void (*ForEachChunkCallback)(uptr chunk, void *arg);\n \n-// SizeClassAllocator64 -- allocator for 64-bit address space.\n-//\n-// Space: a portion of address space of kSpaceSize bytes starting at\n-// a fixed address (kSpaceBeg). Both constants are powers of two and\n-// kSpaceBeg is kSpaceSize-aligned.\n-// At the beginning the entire space is mprotect-ed, then small parts of it\n-// are mapped on demand.\n-//\n-// Region: a part of Space dedicated to a single size class.\n-// There are kNumClasses Regions of equal size.\n-//\n-// UserChunk: a piece of memory returned to user.\n-// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.\n-//\n-// A Region looks like this:\n-// UserChunk1 ... UserChunkN <gap> MetaChunkN ... MetaChunk1\n-template <const uptr kSpaceBeg, const uptr kSpaceSize,\n-          const uptr kMetadataSize, class SizeClassMap,\n-          class MapUnmapCallback = NoOpMapUnmapCallback>\n-class SizeClassAllocator64 {\n- public:\n-  typedef typename SizeClassMap::TransferBatch Batch;\n-  typedef SizeClassAllocator64<kSpaceBeg, kSpaceSize, kMetadataSize,\n-      SizeClassMap, MapUnmapCallback> ThisT;\n-  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;\n-\n-  void Init() {\n-    CHECK_EQ(kSpaceBeg,\n-             reinterpret_cast<uptr>(MmapNoAccess(kSpaceBeg, kSpaceSize)));\n-    MapWithCallback(kSpaceEnd, AdditionalSize());\n-  }\n-\n-  void MapWithCallback(uptr beg, uptr size) {\n-    CHECK_EQ(beg, reinterpret_cast<uptr>(MmapFixedOrDie(beg, size)));\n-    MapUnmapCallback().OnMap(beg, size);\n-  }\n-\n-  void UnmapWithCallback(uptr beg, uptr size) {\n-    MapUnmapCallback().OnUnmap(beg, size);\n-    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n-  }\n-\n-  static bool CanAllocate(uptr size, uptr alignment) {\n-    return size <= SizeClassMap::kMaxSize &&\n-      alignment <= SizeClassMap::kMaxSize;\n-  }\n-\n-  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n-                                uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    RegionInfo *region = GetRegionInfo(class_id);\n-    Batch *b = region->free_list.Pop();\n-    if (!b)\n-      b = PopulateFreeList(stat, c, class_id, region);\n-    region->n_allocated += b->count;\n-    return b;\n-  }\n-\n-  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {\n-    RegionInfo *region = GetRegionInfo(class_id);\n-    CHECK_GT(b->count, 0);\n-    region->free_list.Push(b);\n-    region->n_freed += b->count;\n-  }\n-\n-  static bool PointerIsMine(const void *p) {\n-    return reinterpret_cast<uptr>(p) / kSpaceSize == kSpaceBeg / kSpaceSize;\n-  }\n-\n-  static uptr GetSizeClass(const void *p) {\n-    return (reinterpret_cast<uptr>(p) / kRegionSize) % kNumClassesRounded;\n-  }\n-\n-  void *GetBlockBegin(const void *p) {\n-    uptr class_id = GetSizeClass(p);\n-    uptr size = SizeClassMap::Size(class_id);\n-    if (!size) return nullptr;\n-    uptr chunk_idx = GetChunkIdx((uptr)p, size);\n-    uptr reg_beg = (uptr)p & ~(kRegionSize - 1);\n-    uptr beg = chunk_idx * size;\n-    uptr next_beg = beg + size;\n-    if (class_id >= kNumClasses) return nullptr;\n-    RegionInfo *region = GetRegionInfo(class_id);\n-    if (region->mapped_user >= next_beg)\n-      return reinterpret_cast<void*>(reg_beg + beg);\n-    return nullptr;\n-  }\n-\n-  static uptr GetActuallyAllocatedSize(void *p) {\n-    CHECK(PointerIsMine(p));\n-    return SizeClassMap::Size(GetSizeClass(p));\n-  }\n-\n-  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n-\n-  void *GetMetaData(const void *p) {\n-    uptr class_id = GetSizeClass(p);\n-    uptr size = SizeClassMap::Size(class_id);\n-    uptr chunk_idx = GetChunkIdx(reinterpret_cast<uptr>(p), size);\n-    return reinterpret_cast<void*>(kSpaceBeg + (kRegionSize * (class_id + 1)) -\n-                                   (1 + chunk_idx) * kMetadataSize);\n-  }\n-\n-  uptr TotalMemoryUsed() {\n-    uptr res = 0;\n-    for (uptr i = 0; i < kNumClasses; i++)\n-      res += GetRegionInfo(i)->allocated_user;\n-    return res;\n-  }\n-\n-  // Test-only.\n-  void TestOnlyUnmap() {\n-    UnmapWithCallback(kSpaceBeg, kSpaceSize + AdditionalSize());\n-  }\n-\n-  void PrintStats() {\n-    uptr total_mapped = 0;\n-    uptr n_allocated = 0;\n-    uptr n_freed = 0;\n-    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n-      RegionInfo *region = GetRegionInfo(class_id);\n-      total_mapped += region->mapped_user;\n-      n_allocated += region->n_allocated;\n-      n_freed += region->n_freed;\n-    }\n-    Printf(\"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; \"\n-           \"remains %zd\\n\",\n-           total_mapped >> 20, n_allocated, n_allocated - n_freed);\n-    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n-      RegionInfo *region = GetRegionInfo(class_id);\n-      if (region->mapped_user == 0) continue;\n-      Printf(\"  %02zd (%zd): total: %zd K allocs: %zd remains: %zd\\n\",\n-             class_id,\n-             SizeClassMap::Size(class_id),\n-             region->mapped_user >> 10,\n-             region->n_allocated,\n-             region->n_allocated - region->n_freed);\n-    }\n-  }\n-\n-  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n-  // introspection API.\n-  void ForceLock() {\n-    for (uptr i = 0; i < kNumClasses; i++) {\n-      GetRegionInfo(i)->mutex.Lock();\n-    }\n-  }\n-\n-  void ForceUnlock() {\n-    for (int i = (int)kNumClasses - 1; i >= 0; i--) {\n-      GetRegionInfo(i)->mutex.Unlock();\n-    }\n-  }\n-\n-  // Iterate over all existing chunks.\n-  // The allocator must be locked when calling this function.\n-  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n-      RegionInfo *region = GetRegionInfo(class_id);\n-      uptr chunk_size = SizeClassMap::Size(class_id);\n-      uptr region_beg = kSpaceBeg + class_id * kRegionSize;\n-      for (uptr chunk = region_beg;\n-           chunk < region_beg + region->allocated_user;\n-           chunk += chunk_size) {\n-        // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n-        callback(chunk, arg);\n-      }\n-    }\n-  }\n-\n-  static uptr AdditionalSize() {\n-    return RoundUpTo(sizeof(RegionInfo) * kNumClassesRounded,\n-                     GetPageSizeCached());\n-  }\n-\n-  typedef SizeClassMap SizeClassMapT;\n-  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n-  static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n-\n- private:\n-  static const uptr kRegionSize = kSpaceSize / kNumClassesRounded;\n-  static const uptr kSpaceEnd = kSpaceBeg + kSpaceSize;\n-  COMPILER_CHECK(kSpaceBeg % kSpaceSize == 0);\n-  // kRegionSize must be >= 2^32.\n-  COMPILER_CHECK((kRegionSize) >= (1ULL << (SANITIZER_WORDSIZE / 2)));\n-  // Populate the free list with at most this number of bytes at once\n-  // or with one element if its size is greater.\n-  static const uptr kPopulateSize = 1 << 14;\n-  // Call mmap for user memory with at least this size.\n-  static const uptr kUserMapSize = 1 << 16;\n-  // Call mmap for metadata memory with at least this size.\n-  static const uptr kMetaMapSize = 1 << 16;\n-\n-  struct RegionInfo {\n-    BlockingMutex mutex;\n-    LFStack<Batch> free_list;\n-    uptr allocated_user;  // Bytes allocated for user memory.\n-    uptr allocated_meta;  // Bytes allocated for metadata.\n-    uptr mapped_user;  // Bytes mapped for user memory.\n-    uptr mapped_meta;  // Bytes mapped for metadata.\n-    uptr n_allocated, n_freed;  // Just stats.\n-  };\n-  COMPILER_CHECK(sizeof(RegionInfo) >= kCacheLineSize);\n-\n-  RegionInfo *GetRegionInfo(uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    RegionInfo *regions = reinterpret_cast<RegionInfo*>(kSpaceBeg + kSpaceSize);\n-    return &regions[class_id];\n-  }\n-\n-  static uptr GetChunkIdx(uptr chunk, uptr size) {\n-    uptr offset = chunk % kRegionSize;\n-    // Here we divide by a non-constant. This is costly.\n-    // size always fits into 32-bits. If the offset fits too, use 32-bit div.\n-    if (offset >> (SANITIZER_WORDSIZE / 2))\n-      return offset / size;\n-    return (u32)offset / (u32)size;\n-  }\n-\n-  NOINLINE Batch* PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n-                                   uptr class_id, RegionInfo *region) {\n-    BlockingMutexLock l(&region->mutex);\n-    Batch *b = region->free_list.Pop();\n-    if (b)\n-      return b;\n-    uptr size = SizeClassMap::Size(class_id);\n-    uptr count = size < kPopulateSize ? SizeClassMap::MaxCached(class_id) : 1;\n-    uptr beg_idx = region->allocated_user;\n-    uptr end_idx = beg_idx + count * size;\n-    uptr region_beg = kSpaceBeg + kRegionSize * class_id;\n-    if (end_idx + size > region->mapped_user) {\n-      // Do the mmap for the user memory.\n-      uptr map_size = kUserMapSize;\n-      while (end_idx + size > region->mapped_user + map_size)\n-        map_size += kUserMapSize;\n-      CHECK_GE(region->mapped_user + map_size, end_idx);\n-      MapWithCallback(region_beg + region->mapped_user, map_size);\n-      stat->Add(AllocatorStatMapped, map_size);\n-      region->mapped_user += map_size;\n-    }\n-    uptr total_count = (region->mapped_user - beg_idx - size)\n-        / size / count * count;\n-    region->allocated_meta += total_count * kMetadataSize;\n-    if (region->allocated_meta > region->mapped_meta) {\n-      uptr map_size = kMetaMapSize;\n-      while (region->allocated_meta > region->mapped_meta + map_size)\n-        map_size += kMetaMapSize;\n-      // Do the mmap for the metadata.\n-      CHECK_GE(region->mapped_meta + map_size, region->allocated_meta);\n-      MapWithCallback(region_beg + kRegionSize -\n-                      region->mapped_meta - map_size, map_size);\n-      region->mapped_meta += map_size;\n-    }\n-    CHECK_LE(region->allocated_meta, region->mapped_meta);\n-    if (region->mapped_user + region->mapped_meta > kRegionSize) {\n-      Printf(\"%s: Out of memory. Dying. \", SanitizerToolName);\n-      Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n-          kRegionSize / 1024 / 1024, size);\n-      Die();\n-    }\n-    for (;;) {\n-      if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n-        b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n-      else\n-        b = (Batch*)(region_beg + beg_idx);\n-      b->count = count;\n-      for (uptr i = 0; i < count; i++)\n-        b->batch[i] = (void*)(region_beg + beg_idx + i * size);\n-      region->allocated_user += count * size;\n-      CHECK_LE(region->allocated_user, region->mapped_user);\n-      beg_idx += count * size;\n-      if (beg_idx + count * size + size > region->mapped_user)\n-        break;\n-      CHECK_GT(b->count, 0);\n-      region->free_list.Push(b);\n-    }\n-    return b;\n-  }\n-};\n-\n-// Maps integers in rage [0, kSize) to u8 values.\n-template<u64 kSize>\n-class FlatByteMap {\n- public:\n-  void TestOnlyInit() {\n-    internal_memset(map_, 0, sizeof(map_));\n-  }\n-\n-  void set(uptr idx, u8 val) {\n-    CHECK_LT(idx, kSize);\n-    CHECK_EQ(0U, map_[idx]);\n-    map_[idx] = val;\n-  }\n-  u8 operator[] (uptr idx) {\n-    CHECK_LT(idx, kSize);\n-    // FIXME: CHECK may be too expensive here.\n-    return map_[idx];\n-  }\n- private:\n-  u8 map_[kSize];\n-};\n-\n-// TwoLevelByteMap maps integers in range [0, kSize1*kSize2) to u8 values.\n-// It is implemented as a two-dimensional array: array of kSize1 pointers\n-// to kSize2-byte arrays. The secondary arrays are mmaped on demand.\n-// Each value is initially zero and can be set to something else only once.\n-// Setting and getting values from multiple threads is safe w/o extra locking.\n-template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>\n-class TwoLevelByteMap {\n- public:\n-  void TestOnlyInit() {\n-    internal_memset(map1_, 0, sizeof(map1_));\n-    mu_.Init();\n-  }\n-\n-  void TestOnlyUnmap() {\n-    for (uptr i = 0; i < kSize1; i++) {\n-      u8 *p = Get(i);\n-      if (!p) continue;\n-      MapUnmapCallback().OnUnmap(reinterpret_cast<uptr>(p), kSize2);\n-      UnmapOrDie(p, kSize2);\n-    }\n-  }\n-\n-  uptr size() const { return kSize1 * kSize2; }\n-  uptr size1() const { return kSize1; }\n-  uptr size2() const { return kSize2; }\n-\n-  void set(uptr idx, u8 val) {\n-    CHECK_LT(idx, kSize1 * kSize2);\n-    u8 *map2 = GetOrCreate(idx / kSize2);\n-    CHECK_EQ(0U, map2[idx % kSize2]);\n-    map2[idx % kSize2] = val;\n-  }\n-\n-  u8 operator[] (uptr idx) const {\n-    CHECK_LT(idx, kSize1 * kSize2);\n-    u8 *map2 = Get(idx / kSize2);\n-    if (!map2) return 0;\n-    return map2[idx % kSize2];\n-  }\n-\n- private:\n-  u8 *Get(uptr idx) const {\n-    CHECK_LT(idx, kSize1);\n-    return reinterpret_cast<u8 *>(\n-        atomic_load(&map1_[idx], memory_order_acquire));\n-  }\n-\n-  u8 *GetOrCreate(uptr idx) {\n-    u8 *res = Get(idx);\n-    if (!res) {\n-      SpinMutexLock l(&mu_);\n-      if (!(res = Get(idx))) {\n-        res = (u8*)MmapOrDie(kSize2, \"TwoLevelByteMap\");\n-        MapUnmapCallback().OnMap(reinterpret_cast<uptr>(res), kSize2);\n-        atomic_store(&map1_[idx], reinterpret_cast<uptr>(res),\n-                     memory_order_release);\n-      }\n-    }\n-    return res;\n-  }\n-\n-  atomic_uintptr_t map1_[kSize1];\n-  StaticSpinMutex mu_;\n-};\n-\n-// SizeClassAllocator32 -- allocator for 32-bit address space.\n-// This allocator can theoretically be used on 64-bit arch, but there it is less\n-// efficient than SizeClassAllocator64.\n-//\n-// [kSpaceBeg, kSpaceBeg + kSpaceSize) is the range of addresses which can\n-// be returned by MmapOrDie().\n-//\n-// Region:\n-//   a result of a single call to MmapAlignedOrDie(kRegionSize, kRegionSize).\n-// Since the regions are aligned by kRegionSize, there are exactly\n-// kNumPossibleRegions possible regions in the address space and so we keep\n-// a ByteMap possible_regions to store the size classes of each Region.\n-// 0 size class means the region is not used by the allocator.\n-//\n-// One Region is used to allocate chunks of a single size class.\n-// A Region looks like this:\n-// UserChunk1 .. UserChunkN <gap> MetaChunkN .. MetaChunk1\n-//\n-// In order to avoid false sharing the objects of this class should be\n-// chache-line aligned.\n-template <const uptr kSpaceBeg, const u64 kSpaceSize,\n-          const uptr kMetadataSize, class SizeClassMap,\n-          const uptr kRegionSizeLog,\n-          class ByteMap,\n-          class MapUnmapCallback = NoOpMapUnmapCallback>\n-class SizeClassAllocator32 {\n- public:\n-  typedef typename SizeClassMap::TransferBatch Batch;\n-  typedef SizeClassAllocator32<kSpaceBeg, kSpaceSize, kMetadataSize,\n-      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;\n-  typedef SizeClassAllocatorLocalCache<ThisT> AllocatorCache;\n-\n-  void Init() {\n-    possible_regions.TestOnlyInit();\n-    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n-  }\n-\n-  void *MapWithCallback(uptr size) {\n-    size = RoundUpTo(size, GetPageSizeCached());\n-    void *res = MmapOrDie(size, \"SizeClassAllocator32\");\n-    MapUnmapCallback().OnMap((uptr)res, size);\n-    return res;\n-  }\n-\n-  void UnmapWithCallback(uptr beg, uptr size) {\n-    MapUnmapCallback().OnUnmap(beg, size);\n-    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n-  }\n-\n-  static bool CanAllocate(uptr size, uptr alignment) {\n-    return size <= SizeClassMap::kMaxSize &&\n-      alignment <= SizeClassMap::kMaxSize;\n-  }\n-\n-  void *GetMetaData(const void *p) {\n-    CHECK(PointerIsMine(p));\n-    uptr mem = reinterpret_cast<uptr>(p);\n-    uptr beg = ComputeRegionBeg(mem);\n-    uptr size = SizeClassMap::Size(GetSizeClass(p));\n-    u32 offset = mem - beg;\n-    uptr n = offset / (u32)size;  // 32-bit division\n-    uptr meta = (beg + kRegionSize) - (n + 1) * kMetadataSize;\n-    return reinterpret_cast<void*>(meta);\n-  }\n-\n-  NOINLINE Batch* AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n-                                uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n-    SpinMutexLock l(&sci->mutex);\n-    if (sci->free_list.empty())\n-      PopulateFreeList(stat, c, sci, class_id);\n-    CHECK(!sci->free_list.empty());\n-    Batch *b = sci->free_list.front();\n-    sci->free_list.pop_front();\n-    return b;\n-  }\n-\n-  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id, Batch *b) {\n-    CHECK_LT(class_id, kNumClasses);\n-    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n-    SpinMutexLock l(&sci->mutex);\n-    CHECK_GT(b->count, 0);\n-    sci->free_list.push_front(b);\n-  }\n-\n-  bool PointerIsMine(const void *p) {\n-    return GetSizeClass(p) != 0;\n-  }\n-\n-  uptr GetSizeClass(const void *p) {\n-    return possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];\n-  }\n-\n-  void *GetBlockBegin(const void *p) {\n-    CHECK(PointerIsMine(p));\n-    uptr mem = reinterpret_cast<uptr>(p);\n-    uptr beg = ComputeRegionBeg(mem);\n-    uptr size = SizeClassMap::Size(GetSizeClass(p));\n-    u32 offset = mem - beg;\n-    u32 n = offset / (u32)size;  // 32-bit division\n-    uptr res = beg + (n * (u32)size);\n-    return reinterpret_cast<void*>(res);\n-  }\n-\n-  uptr GetActuallyAllocatedSize(void *p) {\n-    CHECK(PointerIsMine(p));\n-    return SizeClassMap::Size(GetSizeClass(p));\n-  }\n-\n-  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n-\n-  uptr TotalMemoryUsed() {\n-    // No need to lock here.\n-    uptr res = 0;\n-    for (uptr i = 0; i < kNumPossibleRegions; i++)\n-      if (possible_regions[i])\n-        res += kRegionSize;\n-    return res;\n-  }\n-\n-  void TestOnlyUnmap() {\n-    for (uptr i = 0; i < kNumPossibleRegions; i++)\n-      if (possible_regions[i])\n-        UnmapWithCallback((i * kRegionSize), kRegionSize);\n-  }\n-\n-  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n-  // introspection API.\n-  void ForceLock() {\n-    for (uptr i = 0; i < kNumClasses; i++) {\n-      GetSizeClassInfo(i)->mutex.Lock();\n-    }\n-  }\n-\n-  void ForceUnlock() {\n-    for (int i = kNumClasses - 1; i >= 0; i--) {\n-      GetSizeClassInfo(i)->mutex.Unlock();\n-    }\n-  }\n-\n-  // Iterate over all existing chunks.\n-  // The allocator must be locked when calling this function.\n-  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-    for (uptr region = 0; region < kNumPossibleRegions; region++)\n-      if (possible_regions[region]) {\n-        uptr chunk_size = SizeClassMap::Size(possible_regions[region]);\n-        uptr max_chunks_in_region = kRegionSize / (chunk_size + kMetadataSize);\n-        uptr region_beg = region * kRegionSize;\n-        for (uptr chunk = region_beg;\n-             chunk < region_beg + max_chunks_in_region * chunk_size;\n-             chunk += chunk_size) {\n-          // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n-          callback(chunk, arg);\n-        }\n-      }\n-  }\n-\n-  void PrintStats() {\n-  }\n-\n-  static uptr AdditionalSize() {\n-    return 0;\n-  }\n-\n-  typedef SizeClassMap SizeClassMapT;\n-  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n-\n- private:\n-  static const uptr kRegionSize = 1 << kRegionSizeLog;\n-  static const uptr kNumPossibleRegions = kSpaceSize / kRegionSize;\n-\n-  struct SizeClassInfo {\n-    SpinMutex mutex;\n-    IntrusiveList<Batch> free_list;\n-    char padding[kCacheLineSize - sizeof(uptr) - sizeof(IntrusiveList<Batch>)];\n-  };\n-  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);\n-\n-  uptr ComputeRegionId(uptr mem) {\n-    uptr res = mem >> kRegionSizeLog;\n-    CHECK_LT(res, kNumPossibleRegions);\n-    return res;\n-  }\n-\n-  uptr ComputeRegionBeg(uptr mem) {\n-    return mem & ~(kRegionSize - 1);\n-  }\n-\n-  uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,\n-                                      \"SizeClassAllocator32\"));\n-    MapUnmapCallback().OnMap(res, kRegionSize);\n-    stat->Add(AllocatorStatMapped, kRegionSize);\n-    CHECK_EQ(0U, (res & (kRegionSize - 1)));\n-    possible_regions.set(ComputeRegionId(res), static_cast<u8>(class_id));\n-    return res;\n-  }\n-\n-  SizeClassInfo *GetSizeClassInfo(uptr class_id) {\n-    CHECK_LT(class_id, kNumClasses);\n-    return &size_class_info_array[class_id];\n-  }\n-\n-  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n-                        SizeClassInfo *sci, uptr class_id) {\n-    uptr size = SizeClassMap::Size(class_id);\n-    uptr reg = AllocateRegion(stat, class_id);\n-    uptr n_chunks = kRegionSize / (size + kMetadataSize);\n-    uptr max_count = SizeClassMap::MaxCached(class_id);\n-    Batch *b = nullptr;\n-    for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n-      if (!b) {\n-        if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n-          b = (Batch*)c->Allocate(this, SizeClassMap::ClassID(sizeof(Batch)));\n-        else\n-          b = (Batch*)i;\n-        b->count = 0;\n-      }\n-      b->batch[b->count++] = (void*)i;\n-      if (b->count == max_count) {\n-        CHECK_GT(b->count, 0);\n-        sci->free_list.push_back(b);\n-        b = nullptr;\n-      }\n-    }\n-    if (b) {\n-      CHECK_GT(b->count, 0);\n-      sci->free_list.push_back(b);\n-    }\n-  }\n-\n-  ByteMap possible_regions;\n-  SizeClassInfo size_class_info_array[kNumClasses];\n-};\n-\n-// Objects of this type should be used as local caches for SizeClassAllocator64\n-// or SizeClassAllocator32. Since the typical use of this class is to have one\n-// object per thread in TLS, is has to be POD.\n-template<class SizeClassAllocator>\n-struct SizeClassAllocatorLocalCache {\n-  typedef SizeClassAllocator Allocator;\n-  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n-\n-  void Init(AllocatorGlobalStats *s) {\n-    stats_.Init();\n-    if (s)\n-      s->Register(&stats_);\n-  }\n-\n-  void Destroy(SizeClassAllocator *allocator, AllocatorGlobalStats *s) {\n-    Drain(allocator);\n-    if (s)\n-      s->Unregister(&stats_);\n-  }\n-\n-  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n-    CHECK_NE(class_id, 0UL);\n-    CHECK_LT(class_id, kNumClasses);\n-    stats_.Add(AllocatorStatAllocated, SizeClassMap::Size(class_id));\n-    PerClass *c = &per_class_[class_id];\n-    if (UNLIKELY(c->count == 0))\n-      Refill(allocator, class_id);\n-    void *res = c->batch[--c->count];\n-    PREFETCH(c->batch[c->count - 1]);\n-    return res;\n-  }\n-\n-  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n-    CHECK_NE(class_id, 0UL);\n-    CHECK_LT(class_id, kNumClasses);\n-    // If the first allocator call on a new thread is a deallocation, then\n-    // max_count will be zero, leading to check failure.\n-    InitCache();\n-    stats_.Sub(AllocatorStatAllocated, SizeClassMap::Size(class_id));\n-    PerClass *c = &per_class_[class_id];\n-    CHECK_NE(c->max_count, 0UL);\n-    if (UNLIKELY(c->count == c->max_count))\n-      Drain(allocator, class_id);\n-    c->batch[c->count++] = p;\n-  }\n-\n-  void Drain(SizeClassAllocator *allocator) {\n-    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n-      PerClass *c = &per_class_[class_id];\n-      while (c->count > 0)\n-        Drain(allocator, class_id);\n-    }\n-  }\n-\n-  // private:\n-  typedef typename SizeClassAllocator::SizeClassMapT SizeClassMap;\n-  typedef typename SizeClassMap::TransferBatch Batch;\n-  struct PerClass {\n-    uptr count;\n-    uptr max_count;\n-    void *batch[2 * SizeClassMap::kMaxNumCached];\n-  };\n-  PerClass per_class_[kNumClasses];\n-  AllocatorStats stats_;\n-\n-  void InitCache() {\n-    if (per_class_[1].max_count)\n-      return;\n-    for (uptr i = 0; i < kNumClasses; i++) {\n-      PerClass *c = &per_class_[i];\n-      c->max_count = 2 * SizeClassMap::MaxCached(i);\n-    }\n-  }\n-\n-  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {\n-    InitCache();\n-    PerClass *c = &per_class_[class_id];\n-    Batch *b = allocator->AllocateBatch(&stats_, this, class_id);\n-    CHECK_GT(b->count, 0);\n-    for (uptr i = 0; i < b->count; i++)\n-      c->batch[i] = b->batch[i];\n-    c->count = b->count;\n-    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n-      Deallocate(allocator, SizeClassMap::ClassID(sizeof(Batch)), b);\n-  }\n-\n-  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n-    InitCache();\n-    PerClass *c = &per_class_[class_id];\n-    Batch *b;\n-    if (SizeClassMap::SizeClassRequiresSeparateTransferBatch(class_id))\n-      b = (Batch*)Allocate(allocator, SizeClassMap::ClassID(sizeof(Batch)));\n-    else\n-      b = (Batch*)c->batch[0];\n-    uptr cnt = Min(c->max_count / 2, c->count);\n-    for (uptr i = 0; i < cnt; i++) {\n-      b->batch[i] = c->batch[i];\n-      c->batch[i] = c->batch[i + c->max_count / 2];\n-    }\n-    b->count = cnt;\n-    c->count -= cnt;\n-    CHECK_GT(b->count, 0);\n-    allocator->DeallocateBatch(&stats_, class_id, b);\n-  }\n-};\n-\n-// This class can (de)allocate only large chunks of memory using mmap/unmap.\n-// The main purpose of this allocator is to cover large and rare allocation\n-// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n-template <class MapUnmapCallback = NoOpMapUnmapCallback>\n-class LargeMmapAllocator {\n- public:\n-  void InitLinkerInitialized(bool may_return_null) {\n-    page_size_ = GetPageSizeCached();\n-    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n-  }\n-\n-  void Init(bool may_return_null) {\n-    internal_memset(this, 0, sizeof(*this));\n-    InitLinkerInitialized(may_return_null);\n-  }\n-\n-  void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {\n-    CHECK(IsPowerOfTwo(alignment));\n-    uptr map_size = RoundUpMapSize(size);\n-    if (alignment > page_size_)\n-      map_size += alignment;\n-    // Overflow.\n-    if (map_size < size)\n-      return ReturnNullOrDie();\n-    uptr map_beg = reinterpret_cast<uptr>(\n-        MmapOrDie(map_size, \"LargeMmapAllocator\"));\n-    CHECK(IsAligned(map_beg, page_size_));\n-    MapUnmapCallback().OnMap(map_beg, map_size);\n-    uptr map_end = map_beg + map_size;\n-    uptr res = map_beg + page_size_;\n-    if (res & (alignment - 1))  // Align.\n-      res += alignment - (res & (alignment - 1));\n-    CHECK(IsAligned(res, alignment));\n-    CHECK(IsAligned(res, page_size_));\n-    CHECK_GE(res + size, map_beg);\n-    CHECK_LE(res + size, map_end);\n-    Header *h = GetHeader(res);\n-    h->size = size;\n-    h->map_beg = map_beg;\n-    h->map_size = map_size;\n-    uptr size_log = MostSignificantSetBitIndex(map_size);\n-    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));\n-    {\n-      SpinMutexLock l(&mutex_);\n-      uptr idx = n_chunks_++;\n-      chunks_sorted_ = false;\n-      CHECK_LT(idx, kMaxNumChunks);\n-      h->chunk_idx = idx;\n-      chunks_[idx] = h;\n-      stats.n_allocs++;\n-      stats.currently_allocated += map_size;\n-      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);\n-      stats.by_size_log[size_log]++;\n-      stat->Add(AllocatorStatAllocated, map_size);\n-      stat->Add(AllocatorStatMapped, map_size);\n-    }\n-    return reinterpret_cast<void*>(res);\n-  }\n-\n-  void *ReturnNullOrDie() {\n-    if (atomic_load(&may_return_null_, memory_order_acquire))\n-      return nullptr;\n-    ReportAllocatorCannotReturnNull();\n-  }\n-\n-  void SetMayReturnNull(bool may_return_null) {\n-    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n-  }\n-\n-  void Deallocate(AllocatorStats *stat, void *p) {\n-    Header *h = GetHeader(p);\n-    {\n-      SpinMutexLock l(&mutex_);\n-      uptr idx = h->chunk_idx;\n-      CHECK_EQ(chunks_[idx], h);\n-      CHECK_LT(idx, n_chunks_);\n-      chunks_[idx] = chunks_[n_chunks_ - 1];\n-      chunks_[idx]->chunk_idx = idx;\n-      n_chunks_--;\n-      chunks_sorted_ = false;\n-      stats.n_frees++;\n-      stats.currently_allocated -= h->map_size;\n-      stat->Sub(AllocatorStatAllocated, h->map_size);\n-      stat->Sub(AllocatorStatMapped, h->map_size);\n-    }\n-    MapUnmapCallback().OnUnmap(h->map_beg, h->map_size);\n-    UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);\n-  }\n-\n-  uptr TotalMemoryUsed() {\n-    SpinMutexLock l(&mutex_);\n-    uptr res = 0;\n-    for (uptr i = 0; i < n_chunks_; i++) {\n-      Header *h = chunks_[i];\n-      CHECK_EQ(h->chunk_idx, i);\n-      res += RoundUpMapSize(h->size);\n-    }\n-    return res;\n-  }\n-\n-  bool PointerIsMine(const void *p) {\n-    return GetBlockBegin(p) != nullptr;\n-  }\n-\n-  uptr GetActuallyAllocatedSize(void *p) {\n-    return RoundUpTo(GetHeader(p)->size, page_size_);\n-  }\n-\n-  // At least page_size_/2 metadata bytes is available.\n-  void *GetMetaData(const void *p) {\n-    // Too slow: CHECK_EQ(p, GetBlockBegin(p));\n-    if (!IsAligned(reinterpret_cast<uptr>(p), page_size_)) {\n-      Printf(\"%s: bad pointer %p\\n\", SanitizerToolName, p);\n-      CHECK(IsAligned(reinterpret_cast<uptr>(p), page_size_));\n-    }\n-    return GetHeader(p) + 1;\n-  }\n-\n-  void *GetBlockBegin(const void *ptr) {\n-    uptr p = reinterpret_cast<uptr>(ptr);\n-    SpinMutexLock l(&mutex_);\n-    uptr nearest_chunk = 0;\n-    // Cache-friendly linear search.\n-    for (uptr i = 0; i < n_chunks_; i++) {\n-      uptr ch = reinterpret_cast<uptr>(chunks_[i]);\n-      if (p < ch) continue;  // p is at left to this chunk, skip it.\n-      if (p - ch < p - nearest_chunk)\n-        nearest_chunk = ch;\n-    }\n-    if (!nearest_chunk)\n-      return nullptr;\n-    Header *h = reinterpret_cast<Header *>(nearest_chunk);\n-    CHECK_GE(nearest_chunk, h->map_beg);\n-    CHECK_LT(nearest_chunk, h->map_beg + h->map_size);\n-    CHECK_LE(nearest_chunk, p);\n-    if (h->map_beg + h->map_size <= p)\n-      return nullptr;\n-    return GetUser(h);\n-  }\n-\n-  // This function does the same as GetBlockBegin, but is much faster.\n-  // Must be called with the allocator locked.\n-  void *GetBlockBeginFastLocked(void *ptr) {\n-    mutex_.CheckLocked();\n-    uptr p = reinterpret_cast<uptr>(ptr);\n-    uptr n = n_chunks_;\n-    if (!n) return nullptr;\n-    if (!chunks_sorted_) {\n-      // Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.\n-      SortArray(reinterpret_cast<uptr*>(chunks_), n);\n-      for (uptr i = 0; i < n; i++)\n-        chunks_[i]->chunk_idx = i;\n-      chunks_sorted_ = true;\n-      min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n-      max_mmap_ = reinterpret_cast<uptr>(chunks_[n - 1]) +\n-          chunks_[n - 1]->map_size;\n-    }\n-    if (p < min_mmap_ || p >= max_mmap_)\n-      return nullptr;\n-    uptr beg = 0, end = n - 1;\n-    // This loop is a log(n) lower_bound. It does not check for the exact match\n-    // to avoid expensive cache-thrashing loads.\n-    while (end - beg >= 2) {\n-      uptr mid = (beg + end) / 2;  // Invariant: mid >= beg + 1\n-      if (p < reinterpret_cast<uptr>(chunks_[mid]))\n-        end = mid - 1;  // We are not interested in chunks_[mid].\n-      else\n-        beg = mid;  // chunks_[mid] may still be what we want.\n-    }\n-\n-    if (beg < end) {\n-      CHECK_EQ(beg + 1, end);\n-      // There are 2 chunks left, choose one.\n-      if (p >= reinterpret_cast<uptr>(chunks_[end]))\n-        beg = end;\n-    }\n-\n-    Header *h = chunks_[beg];\n-    if (h->map_beg + h->map_size <= p || p < h->map_beg)\n-      return nullptr;\n-    return GetUser(h);\n-  }\n-\n-  void PrintStats() {\n-    Printf(\"Stats: LargeMmapAllocator: allocated %zd times, \"\n-           \"remains %zd (%zd K) max %zd M; by size logs: \",\n-           stats.n_allocs, stats.n_allocs - stats.n_frees,\n-           stats.currently_allocated >> 10, stats.max_allocated >> 20);\n-    for (uptr i = 0; i < ARRAY_SIZE(stats.by_size_log); i++) {\n-      uptr c = stats.by_size_log[i];\n-      if (!c) continue;\n-      Printf(\"%zd:%zd; \", i, c);\n-    }\n-    Printf(\"\\n\");\n-  }\n-\n-  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n-  // introspection API.\n-  void ForceLock() {\n-    mutex_.Lock();\n-  }\n-\n-  void ForceUnlock() {\n-    mutex_.Unlock();\n-  }\n-\n-  // Iterate over all existing chunks.\n-  // The allocator must be locked when calling this function.\n-  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-    for (uptr i = 0; i < n_chunks_; i++)\n-      callback(reinterpret_cast<uptr>(GetUser(chunks_[i])), arg);\n-  }\n-\n- private:\n-  static const int kMaxNumChunks = 1 << FIRST_32_SECOND_64(15, 18);\n-  struct Header {\n-    uptr map_beg;\n-    uptr map_size;\n-    uptr size;\n-    uptr chunk_idx;\n-  };\n-\n-  Header *GetHeader(uptr p) {\n-    CHECK(IsAligned(p, page_size_));\n-    return reinterpret_cast<Header*>(p - page_size_);\n-  }\n-  Header *GetHeader(const void *p) {\n-    return GetHeader(reinterpret_cast<uptr>(p));\n-  }\n-\n-  void *GetUser(Header *h) {\n-    CHECK(IsAligned((uptr)h, page_size_));\n-    return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n-  }\n-\n-  uptr RoundUpMapSize(uptr size) {\n-    return RoundUpTo(size, page_size_) + page_size_;\n-  }\n-\n-  uptr page_size_;\n-  Header *chunks_[kMaxNumChunks];\n-  uptr n_chunks_;\n-  uptr min_mmap_, max_mmap_;\n-  bool chunks_sorted_;\n-  struct Stats {\n-    uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n-  } stats;\n-  atomic_uint8_t may_return_null_;\n-  SpinMutex mutex_;\n-};\n-\n-// This class implements a complete memory allocator by using two\n-// internal allocators:\n-// PrimaryAllocator is efficient, but may not allocate some sizes (alignments).\n-//  When allocating 2^x bytes it should return 2^x aligned chunk.\n-// PrimaryAllocator is used via a local AllocatorCache.\n-// SecondaryAllocator can allocate anything, but is not efficient.\n-template <class PrimaryAllocator, class AllocatorCache,\n-          class SecondaryAllocator>  // NOLINT\n-class CombinedAllocator {\n- public:\n-  void InitCommon(bool may_return_null) {\n-    primary_.Init();\n-    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n-  }\n-\n-  void InitLinkerInitialized(bool may_return_null) {\n-    secondary_.InitLinkerInitialized(may_return_null);\n-    stats_.InitLinkerInitialized();\n-    InitCommon(may_return_null);\n-  }\n-\n-  void Init(bool may_return_null) {\n-    secondary_.Init(may_return_null);\n-    stats_.Init();\n-    InitCommon(may_return_null);\n-  }\n-\n-  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n-                 bool cleared = false, bool check_rss_limit = false) {\n-    // Returning 0 on malloc(0) may break a lot of code.\n-    if (size == 0)\n-      size = 1;\n-    if (size + alignment < size)\n-      return ReturnNullOrDie();\n-    if (check_rss_limit && RssLimitIsExceeded())\n-      return ReturnNullOrDie();\n-    if (alignment > 8)\n-      size = RoundUpTo(size, alignment);\n-    void *res;\n-    bool from_primary = primary_.CanAllocate(size, alignment);\n-    if (from_primary)\n-      res = cache->Allocate(&primary_, primary_.ClassID(size));\n-    else\n-      res = secondary_.Allocate(&stats_, size, alignment);\n-    if (alignment > 8)\n-      CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n-    if (cleared && res && from_primary)\n-      internal_bzero_aligned16(res, RoundUpTo(size, 16));\n-    return res;\n-  }\n-\n-  bool MayReturnNull() const {\n-    return atomic_load(&may_return_null_, memory_order_acquire);\n-  }\n-\n-  void *ReturnNullOrDie() {\n-    if (MayReturnNull())\n-      return nullptr;\n-    ReportAllocatorCannotReturnNull();\n-  }\n-\n-  void SetMayReturnNull(bool may_return_null) {\n-    secondary_.SetMayReturnNull(may_return_null);\n-    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n-  }\n-\n-  bool RssLimitIsExceeded() {\n-    return atomic_load(&rss_limit_is_exceeded_, memory_order_acquire);\n-  }\n-\n-  void SetRssLimitIsExceeded(bool rss_limit_is_exceeded) {\n-    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,\n-                 memory_order_release);\n-  }\n-\n-  void Deallocate(AllocatorCache *cache, void *p) {\n-    if (!p) return;\n-    if (primary_.PointerIsMine(p))\n-      cache->Deallocate(&primary_, primary_.GetSizeClass(p), p);\n-    else\n-      secondary_.Deallocate(&stats_, p);\n-  }\n-\n-  void *Reallocate(AllocatorCache *cache, void *p, uptr new_size,\n-                   uptr alignment) {\n-    if (!p)\n-      return Allocate(cache, new_size, alignment);\n-    if (!new_size) {\n-      Deallocate(cache, p);\n-      return nullptr;\n-    }\n-    CHECK(PointerIsMine(p));\n-    uptr old_size = GetActuallyAllocatedSize(p);\n-    uptr memcpy_size = Min(new_size, old_size);\n-    void *new_p = Allocate(cache, new_size, alignment);\n-    if (new_p)\n-      internal_memcpy(new_p, p, memcpy_size);\n-    Deallocate(cache, p);\n-    return new_p;\n-  }\n-\n-  bool PointerIsMine(void *p) {\n-    if (primary_.PointerIsMine(p))\n-      return true;\n-    return secondary_.PointerIsMine(p);\n-  }\n-\n-  bool FromPrimary(void *p) {\n-    return primary_.PointerIsMine(p);\n-  }\n-\n-  void *GetMetaData(const void *p) {\n-    if (primary_.PointerIsMine(p))\n-      return primary_.GetMetaData(p);\n-    return secondary_.GetMetaData(p);\n-  }\n-\n-  void *GetBlockBegin(const void *p) {\n-    if (primary_.PointerIsMine(p))\n-      return primary_.GetBlockBegin(p);\n-    return secondary_.GetBlockBegin(p);\n-  }\n-\n-  // This function does the same as GetBlockBegin, but is much faster.\n-  // Must be called with the allocator locked.\n-  void *GetBlockBeginFastLocked(void *p) {\n-    if (primary_.PointerIsMine(p))\n-      return primary_.GetBlockBegin(p);\n-    return secondary_.GetBlockBeginFastLocked(p);\n-  }\n-\n-  uptr GetActuallyAllocatedSize(void *p) {\n-    if (primary_.PointerIsMine(p))\n-      return primary_.GetActuallyAllocatedSize(p);\n-    return secondary_.GetActuallyAllocatedSize(p);\n-  }\n-\n-  uptr TotalMemoryUsed() {\n-    return primary_.TotalMemoryUsed() + secondary_.TotalMemoryUsed();\n-  }\n-\n-  void TestOnlyUnmap() { primary_.TestOnlyUnmap(); }\n-\n-  void InitCache(AllocatorCache *cache) {\n-    cache->Init(&stats_);\n-  }\n-\n-  void DestroyCache(AllocatorCache *cache) {\n-    cache->Destroy(&primary_, &stats_);\n-  }\n-\n-  void SwallowCache(AllocatorCache *cache) {\n-    cache->Drain(&primary_);\n-  }\n-\n-  void GetStats(AllocatorStatCounters s) const {\n-    stats_.Get(s);\n-  }\n-\n-  void PrintStats() {\n-    primary_.PrintStats();\n-    secondary_.PrintStats();\n-  }\n-\n-  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n-  // introspection API.\n-  void ForceLock() {\n-    primary_.ForceLock();\n-    secondary_.ForceLock();\n-  }\n-\n-  void ForceUnlock() {\n-    secondary_.ForceUnlock();\n-    primary_.ForceUnlock();\n-  }\n-\n-  // Iterate over all existing chunks.\n-  // The allocator must be locked when calling this function.\n-  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n-    primary_.ForEachChunk(callback, arg);\n-    secondary_.ForEachChunk(callback, arg);\n-  }\n-\n- private:\n-  PrimaryAllocator primary_;\n-  SecondaryAllocator secondary_;\n-  AllocatorGlobalStats stats_;\n-  atomic_uint8_t may_return_null_;\n-  atomic_uint8_t rss_limit_is_exceeded_;\n-};\n-\n // Returns true if calloc(size, n) should return 0 due to overflow in size*n.\n bool CallocShouldReturnNullDueToOverflow(uptr size, uptr n);\n \n+#include \"sanitizer_allocator_size_class_map.h\"\n+#include \"sanitizer_allocator_stats.h\"\n+#include \"sanitizer_allocator_primary64.h\"\n+#include \"sanitizer_allocator_bytemap.h\"\n+#include \"sanitizer_allocator_primary32.h\"\n+#include \"sanitizer_allocator_local_cache.h\"\n+#include \"sanitizer_allocator_secondary.h\"\n+#include \"sanitizer_allocator_combined.h\"\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_ALLOCATOR_H"}, {"sha": "5e768ce9ef976a39709bff9ead4e52f7ea314aad", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_bytemap.h", "status": "added", "additions": 100, "deletions": 0, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_bytemap.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,100 @@\n+//===-- sanitizer_allocator_bytemap.h ---------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// Maps integers in rage [0, kSize) to u8 values.\n+template<u64 kSize>\n+class FlatByteMap {\n+ public:\n+  void TestOnlyInit() {\n+    internal_memset(map_, 0, sizeof(map_));\n+  }\n+\n+  void set(uptr idx, u8 val) {\n+    CHECK_LT(idx, kSize);\n+    CHECK_EQ(0U, map_[idx]);\n+    map_[idx] = val;\n+  }\n+  u8 operator[] (uptr idx) {\n+    CHECK_LT(idx, kSize);\n+    // FIXME: CHECK may be too expensive here.\n+    return map_[idx];\n+  }\n+ private:\n+  u8 map_[kSize];\n+};\n+\n+// TwoLevelByteMap maps integers in range [0, kSize1*kSize2) to u8 values.\n+// It is implemented as a two-dimensional array: array of kSize1 pointers\n+// to kSize2-byte arrays. The secondary arrays are mmaped on demand.\n+// Each value is initially zero and can be set to something else only once.\n+// Setting and getting values from multiple threads is safe w/o extra locking.\n+template <u64 kSize1, u64 kSize2, class MapUnmapCallback = NoOpMapUnmapCallback>\n+class TwoLevelByteMap {\n+ public:\n+  void TestOnlyInit() {\n+    internal_memset(map1_, 0, sizeof(map1_));\n+    mu_.Init();\n+  }\n+\n+  void TestOnlyUnmap() {\n+    for (uptr i = 0; i < kSize1; i++) {\n+      u8 *p = Get(i);\n+      if (!p) continue;\n+      MapUnmapCallback().OnUnmap(reinterpret_cast<uptr>(p), kSize2);\n+      UnmapOrDie(p, kSize2);\n+    }\n+  }\n+\n+  uptr size() const { return kSize1 * kSize2; }\n+  uptr size1() const { return kSize1; }\n+  uptr size2() const { return kSize2; }\n+\n+  void set(uptr idx, u8 val) {\n+    CHECK_LT(idx, kSize1 * kSize2);\n+    u8 *map2 = GetOrCreate(idx / kSize2);\n+    CHECK_EQ(0U, map2[idx % kSize2]);\n+    map2[idx % kSize2] = val;\n+  }\n+\n+  u8 operator[] (uptr idx) const {\n+    CHECK_LT(idx, kSize1 * kSize2);\n+    u8 *map2 = Get(idx / kSize2);\n+    if (!map2) return 0;\n+    return map2[idx % kSize2];\n+  }\n+\n+ private:\n+  u8 *Get(uptr idx) const {\n+    CHECK_LT(idx, kSize1);\n+    return reinterpret_cast<u8 *>(\n+        atomic_load(&map1_[idx], memory_order_acquire));\n+  }\n+\n+  u8 *GetOrCreate(uptr idx) {\n+    u8 *res = Get(idx);\n+    if (!res) {\n+      SpinMutexLock l(&mu_);\n+      if (!(res = Get(idx))) {\n+        res = (u8*)MmapOrDie(kSize2, \"TwoLevelByteMap\");\n+        MapUnmapCallback().OnMap(reinterpret_cast<uptr>(res), kSize2);\n+        atomic_store(&map1_[idx], reinterpret_cast<uptr>(res),\n+                     memory_order_release);\n+      }\n+    }\n+    return res;\n+  }\n+\n+  atomic_uintptr_t map1_[kSize1];\n+  StaticSpinMutex mu_;\n+};"}, {"sha": "4dc9ca7401f706df9f9203ba0c8617d59f62d7c9", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_combined.h", "status": "added", "additions": 209, "deletions": 0, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_combined.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,209 @@\n+//===-- sanitizer_allocator_combined.h --------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// This class implements a complete memory allocator by using two\n+// internal allocators:\n+// PrimaryAllocator is efficient, but may not allocate some sizes (alignments).\n+//  When allocating 2^x bytes it should return 2^x aligned chunk.\n+// PrimaryAllocator is used via a local AllocatorCache.\n+// SecondaryAllocator can allocate anything, but is not efficient.\n+template <class PrimaryAllocator, class AllocatorCache,\n+          class SecondaryAllocator>  // NOLINT\n+class CombinedAllocator {\n+ public:\n+  void InitCommon(bool may_return_null) {\n+    primary_.Init();\n+    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n+  }\n+\n+  void InitLinkerInitialized(bool may_return_null) {\n+    secondary_.InitLinkerInitialized(may_return_null);\n+    stats_.InitLinkerInitialized();\n+    InitCommon(may_return_null);\n+  }\n+\n+  void Init(bool may_return_null) {\n+    secondary_.Init(may_return_null);\n+    stats_.Init();\n+    InitCommon(may_return_null);\n+  }\n+\n+  void *Allocate(AllocatorCache *cache, uptr size, uptr alignment,\n+                 bool cleared = false, bool check_rss_limit = false) {\n+    // Returning 0 on malloc(0) may break a lot of code.\n+    if (size == 0)\n+      size = 1;\n+    if (size + alignment < size) return ReturnNullOrDieOnBadRequest();\n+    if (check_rss_limit && RssLimitIsExceeded()) return ReturnNullOrDieOnOOM();\n+    if (alignment > 8)\n+      size = RoundUpTo(size, alignment);\n+    void *res;\n+    bool from_primary = primary_.CanAllocate(size, alignment);\n+    if (from_primary)\n+      res = cache->Allocate(&primary_, primary_.ClassID(size));\n+    else\n+      res = secondary_.Allocate(&stats_, size, alignment);\n+    if (alignment > 8)\n+      CHECK_EQ(reinterpret_cast<uptr>(res) & (alignment - 1), 0);\n+    if (cleared && res && from_primary)\n+      internal_bzero_aligned16(res, RoundUpTo(size, 16));\n+    return res;\n+  }\n+\n+  bool MayReturnNull() const {\n+    return atomic_load(&may_return_null_, memory_order_acquire);\n+  }\n+\n+  void *ReturnNullOrDieOnBadRequest() {\n+    if (MayReturnNull())\n+      return nullptr;\n+    ReportAllocatorCannotReturnNull(false);\n+  }\n+\n+  void *ReturnNullOrDieOnOOM() {\n+    if (MayReturnNull()) return nullptr;\n+    ReportAllocatorCannotReturnNull(true);\n+  }\n+\n+  void SetMayReturnNull(bool may_return_null) {\n+    secondary_.SetMayReturnNull(may_return_null);\n+    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n+  }\n+\n+  bool RssLimitIsExceeded() {\n+    return atomic_load(&rss_limit_is_exceeded_, memory_order_acquire);\n+  }\n+\n+  void SetRssLimitIsExceeded(bool rss_limit_is_exceeded) {\n+    atomic_store(&rss_limit_is_exceeded_, rss_limit_is_exceeded,\n+                 memory_order_release);\n+  }\n+\n+  void Deallocate(AllocatorCache *cache, void *p) {\n+    if (!p) return;\n+    if (primary_.PointerIsMine(p))\n+      cache->Deallocate(&primary_, primary_.GetSizeClass(p), p);\n+    else\n+      secondary_.Deallocate(&stats_, p);\n+  }\n+\n+  void *Reallocate(AllocatorCache *cache, void *p, uptr new_size,\n+                   uptr alignment) {\n+    if (!p)\n+      return Allocate(cache, new_size, alignment);\n+    if (!new_size) {\n+      Deallocate(cache, p);\n+      return nullptr;\n+    }\n+    CHECK(PointerIsMine(p));\n+    uptr old_size = GetActuallyAllocatedSize(p);\n+    uptr memcpy_size = Min(new_size, old_size);\n+    void *new_p = Allocate(cache, new_size, alignment);\n+    if (new_p)\n+      internal_memcpy(new_p, p, memcpy_size);\n+    Deallocate(cache, p);\n+    return new_p;\n+  }\n+\n+  bool PointerIsMine(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return true;\n+    return secondary_.PointerIsMine(p);\n+  }\n+\n+  bool FromPrimary(void *p) {\n+    return primary_.PointerIsMine(p);\n+  }\n+\n+  void *GetMetaData(const void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetMetaData(p);\n+    return secondary_.GetMetaData(p);\n+  }\n+\n+  void *GetBlockBegin(const void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetBlockBegin(p);\n+    return secondary_.GetBlockBegin(p);\n+  }\n+\n+  // This function does the same as GetBlockBegin, but is much faster.\n+  // Must be called with the allocator locked.\n+  void *GetBlockBeginFastLocked(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetBlockBegin(p);\n+    return secondary_.GetBlockBeginFastLocked(p);\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    if (primary_.PointerIsMine(p))\n+      return primary_.GetActuallyAllocatedSize(p);\n+    return secondary_.GetActuallyAllocatedSize(p);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    return primary_.TotalMemoryUsed() + secondary_.TotalMemoryUsed();\n+  }\n+\n+  void TestOnlyUnmap() { primary_.TestOnlyUnmap(); }\n+\n+  void InitCache(AllocatorCache *cache) {\n+    cache->Init(&stats_);\n+  }\n+\n+  void DestroyCache(AllocatorCache *cache) {\n+    cache->Destroy(&primary_, &stats_);\n+  }\n+\n+  void SwallowCache(AllocatorCache *cache) {\n+    cache->Drain(&primary_);\n+  }\n+\n+  void GetStats(AllocatorStatCounters s) const {\n+    stats_.Get(s);\n+  }\n+\n+  void PrintStats() {\n+    primary_.PrintStats();\n+    secondary_.PrintStats();\n+  }\n+\n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    primary_.ForceLock();\n+    secondary_.ForceLock();\n+  }\n+\n+  void ForceUnlock() {\n+    secondary_.ForceUnlock();\n+    primary_.ForceUnlock();\n+  }\n+\n+  void ReleaseToOS() { primary_.ReleaseToOS(); }\n+\n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    primary_.ForEachChunk(callback, arg);\n+    secondary_.ForEachChunk(callback, arg);\n+  }\n+\n+ private:\n+  PrimaryAllocator primary_;\n+  SecondaryAllocator secondary_;\n+  AllocatorGlobalStats stats_;\n+  atomic_uint8_t may_return_null_;\n+  atomic_uint8_t rss_limit_is_exceeded_;\n+};"}, {"sha": "166f8c22049245565e5b6a27c2e10d2049f7f9d8", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_interface.h", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -27,10 +27,18 @@ SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_heap_size();\n SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_free_bytes();\n SANITIZER_INTERFACE_ATTRIBUTE uptr __sanitizer_get_unmapped_bytes();\n \n+SANITIZER_INTERFACE_ATTRIBUTE int __sanitizer_install_malloc_and_free_hooks(\n+    void (*malloc_hook)(const void *, uptr),\n+    void (*free_hook)(const void *));\n+\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n     /* OPTIONAL */ void __sanitizer_malloc_hook(void *ptr, uptr size);\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n     /* OPTIONAL */ void __sanitizer_free_hook(void *ptr);\n+\n+\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+    void __sanitizer_print_memory_profile(int top_percent);\n }  // extern \"C\"\n \n #endif  // SANITIZER_ALLOCATOR_INTERFACE_H"}, {"sha": "6a8da8f3584af21873520132bd19479262cccf14", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_internal.h", "status": "modified", "additions": 8, "deletions": 3, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_internal.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -43,7 +43,12 @@ typedef SizeClassAllocatorLocalCache<PrimaryInternalAllocator>\n typedef CombinedAllocator<PrimaryInternalAllocator, InternalAllocatorCache,\n                           LargeMmapAllocator<> > InternalAllocator;\n \n-void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr);\n+void *InternalAlloc(uptr size, InternalAllocatorCache *cache = nullptr,\n+                    uptr alignment = 0);\n+void *InternalRealloc(void *p, uptr size,\n+                      InternalAllocatorCache *cache = nullptr);\n+void *InternalCalloc(uptr countr, uptr size,\n+                     InternalAllocatorCache *cache = nullptr);\n void InternalFree(void *p, InternalAllocatorCache *cache = nullptr);\n InternalAllocator *internal_allocator();\n \n@@ -54,8 +59,8 @@ enum InternalAllocEnum {\n } // namespace __sanitizer\n \n inline void *operator new(__sanitizer::operator_new_size_type size,\n-                          InternalAllocEnum) {\n-  return InternalAlloc(size);\n+                          __sanitizer::InternalAllocEnum) {\n+  return __sanitizer::InternalAlloc(size);\n }\n \n #endif // SANITIZER_ALLOCATOR_INTERNAL_H"}, {"sha": "40ef0781adbb7b95db6bf9f02a66fbbeb6427727", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_local_cache.h", "status": "added", "additions": 246, "deletions": 0, "changes": 246, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_local_cache.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,246 @@\n+//===-- sanitizer_allocator_local_cache.h -----------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// Objects of this type should be used as local caches for SizeClassAllocator64\n+// or SizeClassAllocator32. Since the typical use of this class is to have one\n+// object per thread in TLS, is has to be POD.\n+template<class SizeClassAllocator>\n+struct SizeClassAllocatorLocalCache\n+    : SizeClassAllocator::AllocatorCache {\n+};\n+\n+// Cache used by SizeClassAllocator64.\n+template <class SizeClassAllocator>\n+struct SizeClassAllocator64LocalCache {\n+  typedef SizeClassAllocator Allocator;\n+  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n+  typedef typename Allocator::SizeClassMapT SizeClassMap;\n+  typedef typename Allocator::CompactPtrT CompactPtrT;\n+\n+  void Init(AllocatorGlobalStats *s) {\n+    stats_.Init();\n+    if (s)\n+      s->Register(&stats_);\n+  }\n+\n+  void Destroy(SizeClassAllocator *allocator, AllocatorGlobalStats *s) {\n+    Drain(allocator);\n+    if (s)\n+      s->Unregister(&stats_);\n+  }\n+\n+  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n+    CHECK_NE(class_id, 0UL);\n+    CHECK_LT(class_id, kNumClasses);\n+    stats_.Add(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n+    PerClass *c = &per_class_[class_id];\n+    if (UNLIKELY(c->count == 0))\n+      Refill(c, allocator, class_id);\n+    CHECK_GT(c->count, 0);\n+    CompactPtrT chunk = c->chunks[--c->count];\n+    void *res = reinterpret_cast<void *>(allocator->CompactPtrToPointer(\n+        allocator->GetRegionBeginBySizeClass(class_id), chunk));\n+    return res;\n+  }\n+\n+  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n+    CHECK_NE(class_id, 0UL);\n+    CHECK_LT(class_id, kNumClasses);\n+    // If the first allocator call on a new thread is a deallocation, then\n+    // max_count will be zero, leading to check failure.\n+    InitCache();\n+    stats_.Sub(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n+    PerClass *c = &per_class_[class_id];\n+    CHECK_NE(c->max_count, 0UL);\n+    if (UNLIKELY(c->count == c->max_count))\n+      Drain(c, allocator, class_id, c->max_count / 2);\n+    CompactPtrT chunk = allocator->PointerToCompactPtr(\n+        allocator->GetRegionBeginBySizeClass(class_id),\n+        reinterpret_cast<uptr>(p));\n+    c->chunks[c->count++] = chunk;\n+  }\n+\n+  void Drain(SizeClassAllocator *allocator) {\n+    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n+      PerClass *c = &per_class_[class_id];\n+      while (c->count > 0)\n+        Drain(c, allocator, class_id, c->count);\n+    }\n+  }\n+\n+  // private:\n+  struct PerClass {\n+    u32 count;\n+    u32 max_count;\n+    CompactPtrT chunks[2 * SizeClassMap::kMaxNumCachedHint];\n+  };\n+  PerClass per_class_[kNumClasses];\n+  AllocatorStats stats_;\n+\n+  void InitCache() {\n+    if (per_class_[1].max_count)\n+      return;\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      PerClass *c = &per_class_[i];\n+      c->max_count = 2 * SizeClassMap::MaxCachedHint(i);\n+    }\n+  }\n+\n+  NOINLINE void Refill(PerClass *c, SizeClassAllocator *allocator,\n+                       uptr class_id) {\n+    InitCache();\n+    uptr num_requested_chunks = SizeClassMap::MaxCachedHint(class_id);\n+    allocator->GetFromAllocator(&stats_, class_id, c->chunks,\n+                                num_requested_chunks);\n+    c->count = num_requested_chunks;\n+  }\n+\n+  NOINLINE void Drain(PerClass *c, SizeClassAllocator *allocator, uptr class_id,\n+                      uptr count) {\n+    InitCache();\n+    CHECK_GE(c->count, count);\n+    uptr first_idx_to_drain = c->count - count;\n+    c->count -= count;\n+    allocator->ReturnToAllocator(&stats_, class_id,\n+                                 &c->chunks[first_idx_to_drain], count);\n+  }\n+};\n+\n+// Cache used by SizeClassAllocator32.\n+template <class SizeClassAllocator>\n+struct SizeClassAllocator32LocalCache {\n+  typedef SizeClassAllocator Allocator;\n+  typedef typename Allocator::TransferBatch TransferBatch;\n+  static const uptr kNumClasses = SizeClassAllocator::kNumClasses;\n+\n+  void Init(AllocatorGlobalStats *s) {\n+    stats_.Init();\n+    if (s)\n+      s->Register(&stats_);\n+  }\n+\n+  void Destroy(SizeClassAllocator *allocator, AllocatorGlobalStats *s) {\n+    Drain(allocator);\n+    if (s)\n+      s->Unregister(&stats_);\n+  }\n+\n+  void *Allocate(SizeClassAllocator *allocator, uptr class_id) {\n+    CHECK_NE(class_id, 0UL);\n+    CHECK_LT(class_id, kNumClasses);\n+    stats_.Add(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n+    PerClass *c = &per_class_[class_id];\n+    if (UNLIKELY(c->count == 0))\n+      Refill(allocator, class_id);\n+    void *res = c->batch[--c->count];\n+    PREFETCH(c->batch[c->count - 1]);\n+    return res;\n+  }\n+\n+  void Deallocate(SizeClassAllocator *allocator, uptr class_id, void *p) {\n+    CHECK_NE(class_id, 0UL);\n+    CHECK_LT(class_id, kNumClasses);\n+    // If the first allocator call on a new thread is a deallocation, then\n+    // max_count will be zero, leading to check failure.\n+    InitCache();\n+    stats_.Sub(AllocatorStatAllocated, Allocator::ClassIdToSize(class_id));\n+    PerClass *c = &per_class_[class_id];\n+    CHECK_NE(c->max_count, 0UL);\n+    if (UNLIKELY(c->count == c->max_count))\n+      Drain(allocator, class_id);\n+    c->batch[c->count++] = p;\n+  }\n+\n+  void Drain(SizeClassAllocator *allocator) {\n+    for (uptr class_id = 0; class_id < kNumClasses; class_id++) {\n+      PerClass *c = &per_class_[class_id];\n+      while (c->count > 0)\n+        Drain(allocator, class_id);\n+    }\n+  }\n+\n+  // private:\n+  typedef typename SizeClassAllocator::SizeClassMapT SizeClassMap;\n+  struct PerClass {\n+    uptr count;\n+    uptr max_count;\n+    void *batch[2 * TransferBatch::kMaxNumCached];\n+  };\n+  PerClass per_class_[kNumClasses];\n+  AllocatorStats stats_;\n+\n+  void InitCache() {\n+    if (per_class_[1].max_count)\n+      return;\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      PerClass *c = &per_class_[i];\n+      c->max_count = 2 * TransferBatch::MaxCached(i);\n+    }\n+  }\n+\n+  // TransferBatch class is declared in SizeClassAllocator.\n+  // We transfer chunks between central and thread-local free lists in batches.\n+  // For small size classes we allocate batches separately.\n+  // For large size classes we may use one of the chunks to store the batch.\n+  // sizeof(TransferBatch) must be a power of 2 for more efficient allocation.\n+  static uptr SizeClassForTransferBatch(uptr class_id) {\n+    if (Allocator::ClassIdToSize(class_id) <\n+        TransferBatch::AllocationSizeRequiredForNElements(\n+            TransferBatch::MaxCached(class_id)))\n+      return SizeClassMap::ClassID(sizeof(TransferBatch));\n+    return 0;\n+  }\n+\n+  // Returns a TransferBatch suitable for class_id.\n+  // For small size classes allocates the batch from the allocator.\n+  // For large size classes simply returns b.\n+  TransferBatch *CreateBatch(uptr class_id, SizeClassAllocator *allocator,\n+                             TransferBatch *b) {\n+    if (uptr batch_class_id = SizeClassForTransferBatch(class_id))\n+      return (TransferBatch*)Allocate(allocator, batch_class_id);\n+    return b;\n+  }\n+\n+  // Destroys TransferBatch b.\n+  // For small size classes deallocates b to the allocator.\n+  // Does notthing for large size classes.\n+  void DestroyBatch(uptr class_id, SizeClassAllocator *allocator,\n+                    TransferBatch *b) {\n+    if (uptr batch_class_id = SizeClassForTransferBatch(class_id))\n+      Deallocate(allocator, batch_class_id, b);\n+  }\n+\n+  NOINLINE void Refill(SizeClassAllocator *allocator, uptr class_id) {\n+    InitCache();\n+    PerClass *c = &per_class_[class_id];\n+    TransferBatch *b = allocator->AllocateBatch(&stats_, this, class_id);\n+    CHECK_GT(b->Count(), 0);\n+    b->CopyToArray(c->batch);\n+    c->count = b->Count();\n+    DestroyBatch(class_id, allocator, b);\n+  }\n+\n+  NOINLINE void Drain(SizeClassAllocator *allocator, uptr class_id) {\n+    InitCache();\n+    PerClass *c = &per_class_[class_id];\n+    uptr cnt = Min(c->max_count / 2, c->count);\n+    uptr first_idx_to_drain = c->count - cnt;\n+    TransferBatch *b = CreateBatch(\n+        class_id, allocator, (TransferBatch *)c->batch[first_idx_to_drain]);\n+    b->SetFromArray(allocator->GetRegionBeginBySizeClass(class_id),\n+                    &c->batch[first_idx_to_drain], cnt);\n+    c->count -= cnt;\n+    allocator->DeallocateBatch(&stats_, class_id, b);\n+  }\n+};"}, {"sha": "989b87a192345218dbd422e7d0d6b8ab44b4180f", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary32.h", "status": "added", "additions": 302, "deletions": 0, "changes": 302, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary32.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,302 @@\n+//===-- sanitizer_allocator_primary32.h -------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+template<class SizeClassAllocator> struct SizeClassAllocator32LocalCache;\n+\n+// SizeClassAllocator32 -- allocator for 32-bit address space.\n+// This allocator can theoretically be used on 64-bit arch, but there it is less\n+// efficient than SizeClassAllocator64.\n+//\n+// [kSpaceBeg, kSpaceBeg + kSpaceSize) is the range of addresses which can\n+// be returned by MmapOrDie().\n+//\n+// Region:\n+//   a result of a single call to MmapAlignedOrDie(kRegionSize, kRegionSize).\n+// Since the regions are aligned by kRegionSize, there are exactly\n+// kNumPossibleRegions possible regions in the address space and so we keep\n+// a ByteMap possible_regions to store the size classes of each Region.\n+// 0 size class means the region is not used by the allocator.\n+//\n+// One Region is used to allocate chunks of a single size class.\n+// A Region looks like this:\n+// UserChunk1 .. UserChunkN <gap> MetaChunkN .. MetaChunk1\n+//\n+// In order to avoid false sharing the objects of this class should be\n+// chache-line aligned.\n+template <const uptr kSpaceBeg, const u64 kSpaceSize,\n+          const uptr kMetadataSize, class SizeClassMap,\n+          const uptr kRegionSizeLog,\n+          class ByteMap,\n+          class MapUnmapCallback = NoOpMapUnmapCallback>\n+class SizeClassAllocator32 {\n+ public:\n+  struct TransferBatch {\n+    static const uptr kMaxNumCached = SizeClassMap::kMaxNumCachedHint - 2;\n+    void SetFromArray(uptr region_beg_unused, void *batch[], uptr count) {\n+      count_ = count;\n+      CHECK_LE(count_, kMaxNumCached);\n+      for (uptr i = 0; i < count; i++)\n+        batch_[i] = batch[i];\n+    }\n+    uptr Count() const { return count_; }\n+    void Clear() { count_ = 0; }\n+    void Add(void *ptr) {\n+      batch_[count_++] = ptr;\n+      CHECK_LE(count_, kMaxNumCached);\n+    }\n+    void CopyToArray(void *to_batch[]) {\n+      for (uptr i = 0, n = Count(); i < n; i++)\n+        to_batch[i] = batch_[i];\n+    }\n+\n+    // How much memory do we need for a batch containing n elements.\n+    static uptr AllocationSizeRequiredForNElements(uptr n) {\n+      return sizeof(uptr) * 2 + sizeof(void *) * n;\n+    }\n+    static uptr MaxCached(uptr class_id) {\n+      return Min(kMaxNumCached, SizeClassMap::MaxCachedHint(class_id));\n+    }\n+\n+    TransferBatch *next;\n+\n+   private:\n+    uptr count_;\n+    void *batch_[kMaxNumCached];\n+  };\n+\n+  static const uptr kBatchSize = sizeof(TransferBatch);\n+  COMPILER_CHECK((kBatchSize & (kBatchSize - 1)) == 0);\n+  COMPILER_CHECK(sizeof(TransferBatch) ==\n+                 SizeClassMap::kMaxNumCachedHint * sizeof(uptr));\n+\n+  static uptr ClassIdToSize(uptr class_id) {\n+    return SizeClassMap::Size(class_id);\n+  }\n+\n+  typedef SizeClassAllocator32<kSpaceBeg, kSpaceSize, kMetadataSize,\n+      SizeClassMap, kRegionSizeLog, ByteMap, MapUnmapCallback> ThisT;\n+  typedef SizeClassAllocator32LocalCache<ThisT> AllocatorCache;\n+\n+  void Init() {\n+    possible_regions.TestOnlyInit();\n+    internal_memset(size_class_info_array, 0, sizeof(size_class_info_array));\n+  }\n+\n+  void *MapWithCallback(uptr size) {\n+    size = RoundUpTo(size, GetPageSizeCached());\n+    void *res = MmapOrDie(size, \"SizeClassAllocator32\");\n+    MapUnmapCallback().OnMap((uptr)res, size);\n+    return res;\n+  }\n+\n+  void UnmapWithCallback(uptr beg, uptr size) {\n+    MapUnmapCallback().OnUnmap(beg, size);\n+    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n+  }\n+\n+  static bool CanAllocate(uptr size, uptr alignment) {\n+    return size <= SizeClassMap::kMaxSize &&\n+      alignment <= SizeClassMap::kMaxSize;\n+  }\n+\n+  void *GetMetaData(const void *p) {\n+    CHECK(PointerIsMine(p));\n+    uptr mem = reinterpret_cast<uptr>(p);\n+    uptr beg = ComputeRegionBeg(mem);\n+    uptr size = ClassIdToSize(GetSizeClass(p));\n+    u32 offset = mem - beg;\n+    uptr n = offset / (u32)size;  // 32-bit division\n+    uptr meta = (beg + kRegionSize) - (n + 1) * kMetadataSize;\n+    return reinterpret_cast<void*>(meta);\n+  }\n+\n+  NOINLINE TransferBatch *AllocateBatch(AllocatorStats *stat, AllocatorCache *c,\n+                                        uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n+    SpinMutexLock l(&sci->mutex);\n+    if (sci->free_list.empty())\n+      PopulateFreeList(stat, c, sci, class_id);\n+    CHECK(!sci->free_list.empty());\n+    TransferBatch *b = sci->free_list.front();\n+    sci->free_list.pop_front();\n+    return b;\n+  }\n+\n+  NOINLINE void DeallocateBatch(AllocatorStats *stat, uptr class_id,\n+                                TransferBatch *b) {\n+    CHECK_LT(class_id, kNumClasses);\n+    SizeClassInfo *sci = GetSizeClassInfo(class_id);\n+    SpinMutexLock l(&sci->mutex);\n+    CHECK_GT(b->Count(), 0);\n+    sci->free_list.push_front(b);\n+  }\n+\n+  uptr GetRegionBeginBySizeClass(uptr class_id) { return 0; }\n+\n+  bool PointerIsMine(const void *p) {\n+    uptr mem = reinterpret_cast<uptr>(p);\n+    if (mem < kSpaceBeg || mem >= kSpaceBeg + kSpaceSize)\n+      return false;\n+    return GetSizeClass(p) != 0;\n+  }\n+\n+  uptr GetSizeClass(const void *p) {\n+    return possible_regions[ComputeRegionId(reinterpret_cast<uptr>(p))];\n+  }\n+\n+  void *GetBlockBegin(const void *p) {\n+    CHECK(PointerIsMine(p));\n+    uptr mem = reinterpret_cast<uptr>(p);\n+    uptr beg = ComputeRegionBeg(mem);\n+    uptr size = ClassIdToSize(GetSizeClass(p));\n+    u32 offset = mem - beg;\n+    u32 n = offset / (u32)size;  // 32-bit division\n+    uptr res = beg + (n * (u32)size);\n+    return reinterpret_cast<void*>(res);\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    CHECK(PointerIsMine(p));\n+    return ClassIdToSize(GetSizeClass(p));\n+  }\n+\n+  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n+\n+  uptr TotalMemoryUsed() {\n+    // No need to lock here.\n+    uptr res = 0;\n+    for (uptr i = 0; i < kNumPossibleRegions; i++)\n+      if (possible_regions[i])\n+        res += kRegionSize;\n+    return res;\n+  }\n+\n+  void TestOnlyUnmap() {\n+    for (uptr i = 0; i < kNumPossibleRegions; i++)\n+      if (possible_regions[i])\n+        UnmapWithCallback((i * kRegionSize), kRegionSize);\n+  }\n+\n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      GetSizeClassInfo(i)->mutex.Lock();\n+    }\n+  }\n+\n+  void ForceUnlock() {\n+    for (int i = kNumClasses - 1; i >= 0; i--) {\n+      GetSizeClassInfo(i)->mutex.Unlock();\n+    }\n+  }\n+\n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr region = 0; region < kNumPossibleRegions; region++)\n+      if (possible_regions[region]) {\n+        uptr chunk_size = ClassIdToSize(possible_regions[region]);\n+        uptr max_chunks_in_region = kRegionSize / (chunk_size + kMetadataSize);\n+        uptr region_beg = region * kRegionSize;\n+        for (uptr chunk = region_beg;\n+             chunk < region_beg + max_chunks_in_region * chunk_size;\n+             chunk += chunk_size) {\n+          // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n+          callback(chunk, arg);\n+        }\n+      }\n+  }\n+\n+  void PrintStats() {\n+  }\n+\n+  static uptr AdditionalSize() {\n+    return 0;\n+  }\n+\n+  // This is empty here. Currently only implemented in 64-bit allocator.\n+  void ReleaseToOS() { }\n+\n+\n+  typedef SizeClassMap SizeClassMapT;\n+  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n+\n+ private:\n+  static const uptr kRegionSize = 1 << kRegionSizeLog;\n+  static const uptr kNumPossibleRegions = kSpaceSize / kRegionSize;\n+\n+  struct SizeClassInfo {\n+    SpinMutex mutex;\n+    IntrusiveList<TransferBatch> free_list;\n+    char padding[kCacheLineSize - sizeof(uptr) -\n+                 sizeof(IntrusiveList<TransferBatch>)];\n+  };\n+  COMPILER_CHECK(sizeof(SizeClassInfo) == kCacheLineSize);\n+\n+  uptr ComputeRegionId(uptr mem) {\n+    uptr res = mem >> kRegionSizeLog;\n+    CHECK_LT(res, kNumPossibleRegions);\n+    return res;\n+  }\n+\n+  uptr ComputeRegionBeg(uptr mem) {\n+    return mem & ~(kRegionSize - 1);\n+  }\n+\n+  uptr AllocateRegion(AllocatorStats *stat, uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    uptr res = reinterpret_cast<uptr>(MmapAlignedOrDie(kRegionSize, kRegionSize,\n+                                      \"SizeClassAllocator32\"));\n+    MapUnmapCallback().OnMap(res, kRegionSize);\n+    stat->Add(AllocatorStatMapped, kRegionSize);\n+    CHECK_EQ(0U, (res & (kRegionSize - 1)));\n+    possible_regions.set(ComputeRegionId(res), static_cast<u8>(class_id));\n+    return res;\n+  }\n+\n+  SizeClassInfo *GetSizeClassInfo(uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    return &size_class_info_array[class_id];\n+  }\n+\n+  void PopulateFreeList(AllocatorStats *stat, AllocatorCache *c,\n+                        SizeClassInfo *sci, uptr class_id) {\n+    uptr size = ClassIdToSize(class_id);\n+    uptr reg = AllocateRegion(stat, class_id);\n+    uptr n_chunks = kRegionSize / (size + kMetadataSize);\n+    uptr max_count = TransferBatch::MaxCached(class_id);\n+    TransferBatch *b = nullptr;\n+    for (uptr i = reg; i < reg + n_chunks * size; i += size) {\n+      if (!b) {\n+        b = c->CreateBatch(class_id, this, (TransferBatch*)i);\n+        b->Clear();\n+      }\n+      b->Add((void*)i);\n+      if (b->Count() == max_count) {\n+        CHECK_GT(b->Count(), 0);\n+        sci->free_list.push_back(b);\n+        b = nullptr;\n+      }\n+    }\n+    if (b) {\n+      CHECK_GT(b->Count(), 0);\n+      sci->free_list.push_back(b);\n+    }\n+  }\n+\n+  ByteMap possible_regions;\n+  SizeClassInfo size_class_info_array[kNumClasses];\n+};"}, {"sha": "620639afbfdb2a13a5e0fbf1b29533e30ee8c5db", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_primary64.h", "status": "added", "additions": 503, "deletions": 0, "changes": 503, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_primary64.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,503 @@\n+//===-- sanitizer_allocator_primary64.h -------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+template<class SizeClassAllocator> struct SizeClassAllocator64LocalCache;\n+\n+// SizeClassAllocator64 -- allocator for 64-bit address space.\n+// The template parameter Params is a class containing the actual parameters.\n+//\n+// Space: a portion of address space of kSpaceSize bytes starting at SpaceBeg.\n+// If kSpaceBeg is ~0 then SpaceBeg is chosen dynamically my mmap.\n+// Otherwise SpaceBeg=kSpaceBeg (fixed address).\n+// kSpaceSize is a power of two.\n+// At the beginning the entire space is mprotect-ed, then small parts of it\n+// are mapped on demand.\n+//\n+// Region: a part of Space dedicated to a single size class.\n+// There are kNumClasses Regions of equal size.\n+//\n+// UserChunk: a piece of memory returned to user.\n+// MetaChunk: kMetadataSize bytes of metadata associated with a UserChunk.\n+\n+// FreeArray is an array free-d chunks (stored as 4-byte offsets)\n+//\n+// A Region looks like this:\n+// UserChunk1 ... UserChunkN <gap> MetaChunkN ... MetaChunk1 FreeArray\n+\n+struct SizeClassAllocator64FlagMasks {  //  Bit masks.\n+  enum {\n+    kRandomShuffleChunks = 1,\n+  };\n+};\n+\n+template <class Params>\n+class SizeClassAllocator64 {\n+ public:\n+  static const uptr kSpaceBeg = Params::kSpaceBeg;\n+  static const uptr kSpaceSize = Params::kSpaceSize;\n+  static const uptr kMetadataSize = Params::kMetadataSize;\n+  typedef typename Params::SizeClassMap SizeClassMap;\n+  typedef typename Params::MapUnmapCallback MapUnmapCallback;\n+\n+  static const bool kRandomShuffleChunks =\n+      Params::kFlags & SizeClassAllocator64FlagMasks::kRandomShuffleChunks;\n+\n+  typedef SizeClassAllocator64<Params> ThisT;\n+  typedef SizeClassAllocator64LocalCache<ThisT> AllocatorCache;\n+\n+  // When we know the size class (the region base) we can represent a pointer\n+  // as a 4-byte integer (offset from the region start shifted right by 4).\n+  typedef u32 CompactPtrT;\n+  static const uptr kCompactPtrScale = 4;\n+  CompactPtrT PointerToCompactPtr(uptr base, uptr ptr) {\n+    return static_cast<CompactPtrT>((ptr - base) >> kCompactPtrScale);\n+  }\n+  uptr CompactPtrToPointer(uptr base, CompactPtrT ptr32) {\n+    return base + (static_cast<uptr>(ptr32) << kCompactPtrScale);\n+  }\n+\n+  void Init() {\n+    uptr TotalSpaceSize = kSpaceSize + AdditionalSize();\n+    if (kUsingConstantSpaceBeg) {\n+      CHECK_EQ(kSpaceBeg, reinterpret_cast<uptr>(\n+                              MmapFixedNoAccess(kSpaceBeg, TotalSpaceSize)));\n+    } else {\n+      NonConstSpaceBeg =\n+          reinterpret_cast<uptr>(MmapNoAccess(TotalSpaceSize));\n+      CHECK_NE(NonConstSpaceBeg, ~(uptr)0);\n+    }\n+    MapWithCallback(SpaceEnd(), AdditionalSize());\n+  }\n+\n+  void MapWithCallback(uptr beg, uptr size) {\n+    CHECK_EQ(beg, reinterpret_cast<uptr>(MmapFixedOrDie(beg, size)));\n+    MapUnmapCallback().OnMap(beg, size);\n+  }\n+\n+  void UnmapWithCallback(uptr beg, uptr size) {\n+    MapUnmapCallback().OnUnmap(beg, size);\n+    UnmapOrDie(reinterpret_cast<void *>(beg), size);\n+  }\n+\n+  static bool CanAllocate(uptr size, uptr alignment) {\n+    return size <= SizeClassMap::kMaxSize &&\n+      alignment <= SizeClassMap::kMaxSize;\n+  }\n+\n+  NOINLINE void ReturnToAllocator(AllocatorStats *stat, uptr class_id,\n+                                  const CompactPtrT *chunks, uptr n_chunks) {\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    CompactPtrT *free_array = GetFreeArray(region_beg);\n+\n+    BlockingMutexLock l(&region->mutex);\n+    uptr old_num_chunks = region->num_freed_chunks;\n+    uptr new_num_freed_chunks = old_num_chunks + n_chunks;\n+    EnsureFreeArraySpace(region, region_beg, new_num_freed_chunks);\n+    for (uptr i = 0; i < n_chunks; i++)\n+      free_array[old_num_chunks + i] = chunks[i];\n+    region->num_freed_chunks = new_num_freed_chunks;\n+    region->n_freed += n_chunks;\n+  }\n+\n+  NOINLINE void GetFromAllocator(AllocatorStats *stat, uptr class_id,\n+                                 CompactPtrT *chunks, uptr n_chunks) {\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    CompactPtrT *free_array = GetFreeArray(region_beg);\n+\n+    BlockingMutexLock l(&region->mutex);\n+    if (UNLIKELY(region->num_freed_chunks < n_chunks)) {\n+      PopulateFreeArray(stat, class_id, region,\n+                        n_chunks - region->num_freed_chunks);\n+      CHECK_GE(region->num_freed_chunks, n_chunks);\n+    }\n+    region->num_freed_chunks -= n_chunks;\n+    uptr base_idx = region->num_freed_chunks;\n+    for (uptr i = 0; i < n_chunks; i++)\n+      chunks[i] = free_array[base_idx + i];\n+    region->n_allocated += n_chunks;\n+  }\n+\n+\n+  bool PointerIsMine(const void *p) {\n+    uptr P = reinterpret_cast<uptr>(p);\n+    if (kUsingConstantSpaceBeg && (kSpaceBeg % kSpaceSize) == 0)\n+      return P / kSpaceSize == kSpaceBeg / kSpaceSize;\n+    return P >= SpaceBeg() && P < SpaceEnd();\n+  }\n+\n+  uptr GetRegionBegin(const void *p) {\n+    if (kUsingConstantSpaceBeg)\n+      return reinterpret_cast<uptr>(p) & ~(kRegionSize - 1);\n+    uptr space_beg = SpaceBeg();\n+    return ((reinterpret_cast<uptr>(p)  - space_beg) & ~(kRegionSize - 1)) +\n+        space_beg;\n+  }\n+\n+  uptr GetRegionBeginBySizeClass(uptr class_id) {\n+    return SpaceBeg() + kRegionSize * class_id;\n+  }\n+\n+  uptr GetSizeClass(const void *p) {\n+    if (kUsingConstantSpaceBeg && (kSpaceBeg % kSpaceSize) == 0)\n+      return ((reinterpret_cast<uptr>(p)) / kRegionSize) % kNumClassesRounded;\n+    return ((reinterpret_cast<uptr>(p) - SpaceBeg()) / kRegionSize) %\n+           kNumClassesRounded;\n+  }\n+\n+  void *GetBlockBegin(const void *p) {\n+    uptr class_id = GetSizeClass(p);\n+    uptr size = ClassIdToSize(class_id);\n+    if (!size) return nullptr;\n+    uptr chunk_idx = GetChunkIdx((uptr)p, size);\n+    uptr reg_beg = GetRegionBegin(p);\n+    uptr beg = chunk_idx * size;\n+    uptr next_beg = beg + size;\n+    if (class_id >= kNumClasses) return nullptr;\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    if (region->mapped_user >= next_beg)\n+      return reinterpret_cast<void*>(reg_beg + beg);\n+    return nullptr;\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    CHECK(PointerIsMine(p));\n+    return ClassIdToSize(GetSizeClass(p));\n+  }\n+\n+  uptr ClassID(uptr size) { return SizeClassMap::ClassID(size); }\n+\n+  void *GetMetaData(const void *p) {\n+    uptr class_id = GetSizeClass(p);\n+    uptr size = ClassIdToSize(class_id);\n+    uptr chunk_idx = GetChunkIdx(reinterpret_cast<uptr>(p), size);\n+    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    return reinterpret_cast<void *>(GetMetadataEnd(region_beg) -\n+                                    (1 + chunk_idx) * kMetadataSize);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    uptr res = 0;\n+    for (uptr i = 0; i < kNumClasses; i++)\n+      res += GetRegionInfo(i)->allocated_user;\n+    return res;\n+  }\n+\n+  // Test-only.\n+  void TestOnlyUnmap() {\n+    UnmapWithCallback(SpaceBeg(), kSpaceSize + AdditionalSize());\n+  }\n+\n+  static void FillMemoryProfile(uptr start, uptr rss, bool file, uptr *stats,\n+                           uptr stats_size) {\n+    for (uptr class_id = 0; class_id < stats_size; class_id++)\n+      if (stats[class_id] == start)\n+        stats[class_id] = rss;\n+  }\n+\n+  void PrintStats(uptr class_id, uptr rss) {\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    if (region->mapped_user == 0) return;\n+    uptr in_use = region->n_allocated - region->n_freed;\n+    uptr avail_chunks = region->allocated_user / ClassIdToSize(class_id);\n+    Printf(\n+        \"  %02zd (%zd): mapped: %zdK allocs: %zd frees: %zd inuse: %zd \"\n+        \"num_freed_chunks %zd\"\n+        \" avail: %zd rss: %zdK releases: %zd\\n\",\n+        class_id, ClassIdToSize(class_id), region->mapped_user >> 10,\n+        region->n_allocated, region->n_freed, in_use,\n+        region->num_freed_chunks, avail_chunks, rss >> 10,\n+        region->rtoi.num_releases);\n+  }\n+\n+  void PrintStats() {\n+    uptr total_mapped = 0;\n+    uptr n_allocated = 0;\n+    uptr n_freed = 0;\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n+      RegionInfo *region = GetRegionInfo(class_id);\n+      total_mapped += region->mapped_user;\n+      n_allocated += region->n_allocated;\n+      n_freed += region->n_freed;\n+    }\n+    Printf(\"Stats: SizeClassAllocator64: %zdM mapped in %zd allocations; \"\n+           \"remains %zd\\n\",\n+           total_mapped >> 20, n_allocated, n_allocated - n_freed);\n+    uptr rss_stats[kNumClasses];\n+    for (uptr class_id = 0; class_id < kNumClasses; class_id++)\n+      rss_stats[class_id] = SpaceBeg() + kRegionSize * class_id;\n+    GetMemoryProfile(FillMemoryProfile, rss_stats, kNumClasses);\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++)\n+      PrintStats(class_id, rss_stats[class_id]);\n+  }\n+\n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      GetRegionInfo(i)->mutex.Lock();\n+    }\n+  }\n+\n+  void ForceUnlock() {\n+    for (int i = (int)kNumClasses - 1; i >= 0; i--) {\n+      GetRegionInfo(i)->mutex.Unlock();\n+    }\n+  }\n+\n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++) {\n+      RegionInfo *region = GetRegionInfo(class_id);\n+      uptr chunk_size = ClassIdToSize(class_id);\n+      uptr region_beg = SpaceBeg() + class_id * kRegionSize;\n+      for (uptr chunk = region_beg;\n+           chunk < region_beg + region->allocated_user;\n+           chunk += chunk_size) {\n+        // Too slow: CHECK_EQ((void *)chunk, GetBlockBegin((void *)chunk));\n+        callback(chunk, arg);\n+      }\n+    }\n+  }\n+\n+  static uptr ClassIdToSize(uptr class_id) {\n+    return SizeClassMap::Size(class_id);\n+  }\n+\n+  static uptr AdditionalSize() {\n+    return RoundUpTo(sizeof(RegionInfo) * kNumClassesRounded,\n+                     GetPageSizeCached());\n+  }\n+\n+  void ReleaseToOS() {\n+    for (uptr class_id = 1; class_id < kNumClasses; class_id++)\n+      ReleaseToOS(class_id);\n+  }\n+\n+  typedef SizeClassMap SizeClassMapT;\n+  static const uptr kNumClasses = SizeClassMap::kNumClasses;\n+  static const uptr kNumClassesRounded = SizeClassMap::kNumClassesRounded;\n+\n+ private:\n+  static const uptr kRegionSize = kSpaceSize / kNumClassesRounded;\n+  // FreeArray is the array of free-d chunks (stored as 4-byte offsets).\n+  // In the worst case it may reguire kRegionSize/SizeClassMap::kMinSize\n+  // elements, but in reality this will not happen. For simplicity we\n+  // dedicate 1/8 of the region's virtual space to FreeArray.\n+  static const uptr kFreeArraySize = kRegionSize / 8;\n+\n+  static const bool kUsingConstantSpaceBeg = kSpaceBeg != ~(uptr)0;\n+  uptr NonConstSpaceBeg;\n+  uptr SpaceBeg() const {\n+    return kUsingConstantSpaceBeg ? kSpaceBeg : NonConstSpaceBeg;\n+  }\n+  uptr SpaceEnd() const { return  SpaceBeg() + kSpaceSize; }\n+  // kRegionSize must be >= 2^32.\n+  COMPILER_CHECK((kRegionSize) >= (1ULL << (SANITIZER_WORDSIZE / 2)));\n+  // kRegionSize must be <= 2^36, see CompactPtrT.\n+  COMPILER_CHECK((kRegionSize) <= (1ULL << (SANITIZER_WORDSIZE / 2 + 4)));\n+  // Call mmap for user memory with at least this size.\n+  static const uptr kUserMapSize = 1 << 16;\n+  // Call mmap for metadata memory with at least this size.\n+  static const uptr kMetaMapSize = 1 << 16;\n+  // Call mmap for free array memory with at least this size.\n+  static const uptr kFreeArrayMapSize = 1 << 16;\n+  // Granularity of ReleaseToOs (aka madvise).\n+  static const uptr kReleaseToOsGranularity = 1 << 12;\n+\n+  struct ReleaseToOsInfo {\n+    uptr n_freed_at_last_release;\n+    uptr num_releases;\n+  };\n+\n+  struct RegionInfo {\n+    BlockingMutex mutex;\n+    uptr num_freed_chunks;  // Number of elements in the freearray.\n+    uptr mapped_free_array;  // Bytes mapped for freearray.\n+    uptr allocated_user;  // Bytes allocated for user memory.\n+    uptr allocated_meta;  // Bytes allocated for metadata.\n+    uptr mapped_user;  // Bytes mapped for user memory.\n+    uptr mapped_meta;  // Bytes mapped for metadata.\n+    u32 rand_state; // Seed for random shuffle, used if kRandomShuffleChunks.\n+    uptr n_allocated, n_freed;  // Just stats.\n+    ReleaseToOsInfo rtoi;\n+  };\n+  COMPILER_CHECK(sizeof(RegionInfo) >= kCacheLineSize);\n+\n+  u32 Rand(u32 *state) {  // ANSI C linear congruential PRNG.\n+    return (*state = *state * 1103515245 + 12345) >> 16;\n+  }\n+\n+  u32 RandN(u32 *state, u32 n) { return Rand(state) % n; }  // [0, n)\n+\n+  void RandomShuffle(u32 *a, u32 n, u32 *rand_state) {\n+    if (n <= 1) return;\n+    for (u32 i = n - 1; i > 0; i--)\n+      Swap(a[i], a[RandN(rand_state, i + 1)]);\n+  }\n+\n+  RegionInfo *GetRegionInfo(uptr class_id) {\n+    CHECK_LT(class_id, kNumClasses);\n+    RegionInfo *regions =\n+        reinterpret_cast<RegionInfo *>(SpaceBeg() + kSpaceSize);\n+    return &regions[class_id];\n+  }\n+\n+  uptr GetMetadataEnd(uptr region_beg) {\n+    return region_beg + kRegionSize - kFreeArraySize;\n+  }\n+\n+  uptr GetChunkIdx(uptr chunk, uptr size) {\n+    if (!kUsingConstantSpaceBeg)\n+      chunk -= SpaceBeg();\n+\n+    uptr offset = chunk % kRegionSize;\n+    // Here we divide by a non-constant. This is costly.\n+    // size always fits into 32-bits. If the offset fits too, use 32-bit div.\n+    if (offset >> (SANITIZER_WORDSIZE / 2))\n+      return offset / size;\n+    return (u32)offset / (u32)size;\n+  }\n+\n+  CompactPtrT *GetFreeArray(uptr region_beg) {\n+    return reinterpret_cast<CompactPtrT *>(region_beg + kRegionSize -\n+                                           kFreeArraySize);\n+  }\n+\n+  void EnsureFreeArraySpace(RegionInfo *region, uptr region_beg,\n+                            uptr num_freed_chunks) {\n+    uptr needed_space = num_freed_chunks * sizeof(CompactPtrT);\n+    if (region->mapped_free_array < needed_space) {\n+      CHECK_LE(needed_space, kFreeArraySize);\n+      uptr new_mapped_free_array = RoundUpTo(needed_space, kFreeArrayMapSize);\n+      uptr current_map_end = reinterpret_cast<uptr>(GetFreeArray(region_beg)) +\n+                             region->mapped_free_array;\n+      uptr new_map_size = new_mapped_free_array - region->mapped_free_array;\n+      MapWithCallback(current_map_end, new_map_size);\n+      region->mapped_free_array = new_mapped_free_array;\n+    }\n+  }\n+\n+\n+  NOINLINE void PopulateFreeArray(AllocatorStats *stat, uptr class_id,\n+                                  RegionInfo *region, uptr requested_count) {\n+    // region->mutex is held.\n+    uptr size = ClassIdToSize(class_id);\n+    uptr beg_idx = region->allocated_user;\n+    uptr end_idx = beg_idx + requested_count * size;\n+    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    if (end_idx > region->mapped_user) {\n+      if (!kUsingConstantSpaceBeg && region->mapped_user == 0)\n+        region->rand_state = static_cast<u32>(region_beg >> 12);  // From ASLR.\n+      // Do the mmap for the user memory.\n+      uptr map_size = kUserMapSize;\n+      while (end_idx > region->mapped_user + map_size)\n+        map_size += kUserMapSize;\n+      CHECK_GE(region->mapped_user + map_size, end_idx);\n+      MapWithCallback(region_beg + region->mapped_user, map_size);\n+      stat->Add(AllocatorStatMapped, map_size);\n+      region->mapped_user += map_size;\n+    }\n+    CompactPtrT *free_array = GetFreeArray(region_beg);\n+    uptr total_count = (region->mapped_user - beg_idx) / size;\n+    uptr num_freed_chunks = region->num_freed_chunks;\n+    EnsureFreeArraySpace(region, region_beg, num_freed_chunks + total_count);\n+    for (uptr i = 0; i < total_count; i++) {\n+      uptr chunk = beg_idx + i * size;\n+      free_array[num_freed_chunks + total_count - 1 - i] =\n+          PointerToCompactPtr(0, chunk);\n+    }\n+    if (kRandomShuffleChunks)\n+      RandomShuffle(&free_array[num_freed_chunks], total_count,\n+                    &region->rand_state);\n+    region->num_freed_chunks += total_count;\n+    region->allocated_user += total_count * size;\n+    CHECK_LE(region->allocated_user, region->mapped_user);\n+\n+    region->allocated_meta += total_count * kMetadataSize;\n+    if (region->allocated_meta > region->mapped_meta) {\n+      uptr map_size = kMetaMapSize;\n+      while (region->allocated_meta > region->mapped_meta + map_size)\n+        map_size += kMetaMapSize;\n+      // Do the mmap for the metadata.\n+      CHECK_GE(region->mapped_meta + map_size, region->allocated_meta);\n+      MapWithCallback(GetMetadataEnd(region_beg) -\n+                      region->mapped_meta - map_size, map_size);\n+      region->mapped_meta += map_size;\n+    }\n+    CHECK_LE(region->allocated_meta, region->mapped_meta);\n+    if (region->mapped_user + region->mapped_meta >\n+        kRegionSize - kFreeArraySize) {\n+      Printf(\"%s: Out of memory. Dying. \", SanitizerToolName);\n+      Printf(\"The process has exhausted %zuMB for size class %zu.\\n\",\n+          kRegionSize / 1024 / 1024, size);\n+      Die();\n+    }\n+  }\n+\n+  bool MaybeReleaseChunkRange(uptr region_beg, uptr chunk_size,\n+                              CompactPtrT first, CompactPtrT last) {\n+    uptr beg_ptr = CompactPtrToPointer(region_beg, first);\n+    uptr end_ptr = CompactPtrToPointer(region_beg, last) + chunk_size;\n+    CHECK_GE(end_ptr - beg_ptr, kReleaseToOsGranularity);\n+    beg_ptr = RoundUpTo(beg_ptr, kReleaseToOsGranularity);\n+    end_ptr = RoundDownTo(end_ptr, kReleaseToOsGranularity);\n+    if (end_ptr == beg_ptr) return false;\n+    ReleaseMemoryToOS(beg_ptr, end_ptr - beg_ptr);\n+    return true;\n+  }\n+\n+  // Releases some RAM back to OS.\n+  // Algorithm:\n+  // * Lock the region.\n+  // * Sort the chunks.\n+  // * Find ranges fully covered by free-d chunks\n+  // * Release them to OS with madvise.\n+  //\n+  // TODO(kcc): make sure we don't do it too frequently.\n+  void ReleaseToOS(uptr class_id) {\n+    RegionInfo *region = GetRegionInfo(class_id);\n+    uptr region_beg = GetRegionBeginBySizeClass(class_id);\n+    CompactPtrT *free_array = GetFreeArray(region_beg);\n+    uptr chunk_size = ClassIdToSize(class_id);\n+    uptr scaled_chunk_size = chunk_size >> kCompactPtrScale;\n+    const uptr kScaledGranularity = kReleaseToOsGranularity >> kCompactPtrScale;\n+    BlockingMutexLock l(&region->mutex);\n+    uptr n = region->num_freed_chunks;\n+    if (n * chunk_size < kReleaseToOsGranularity)\n+      return;   // No chance to release anything.\n+    if ((region->rtoi.n_freed_at_last_release - region->n_freed) * chunk_size <\n+        kReleaseToOsGranularity)\n+      return;  // Nothing new to release.\n+    SortArray(free_array, n);\n+    uptr beg = free_array[0];\n+    uptr prev = free_array[0];\n+    for (uptr i = 1; i < n; i++) {\n+      uptr chunk = free_array[i];\n+      CHECK_GT(chunk, prev);\n+      if (chunk - prev != scaled_chunk_size) {\n+        CHECK_GT(chunk - prev, scaled_chunk_size);\n+        if (prev + scaled_chunk_size - beg >= kScaledGranularity) {\n+          MaybeReleaseChunkRange(region_beg, chunk_size, beg, prev);\n+          region->rtoi.n_freed_at_last_release = region->n_freed;\n+          region->rtoi.num_releases++;\n+        }\n+        beg = chunk;\n+      }\n+      prev = chunk;\n+    }\n+  }\n+};"}, {"sha": "91c2ecc5b2655cfe04aa13becab5ebebbb5272c9", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_secondary.h", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_secondary.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,271 @@\n+//===-- sanitizer_allocator_secondary.h -------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// This class can (de)allocate only large chunks of memory using mmap/unmap.\n+// The main purpose of this allocator is to cover large and rare allocation\n+// sizes not covered by more efficient allocators (e.g. SizeClassAllocator64).\n+template <class MapUnmapCallback = NoOpMapUnmapCallback>\n+class LargeMmapAllocator {\n+ public:\n+  void InitLinkerInitialized(bool may_return_null) {\n+    page_size_ = GetPageSizeCached();\n+    atomic_store(&may_return_null_, may_return_null, memory_order_relaxed);\n+  }\n+\n+  void Init(bool may_return_null) {\n+    internal_memset(this, 0, sizeof(*this));\n+    InitLinkerInitialized(may_return_null);\n+  }\n+\n+  void *Allocate(AllocatorStats *stat, uptr size, uptr alignment) {\n+    CHECK(IsPowerOfTwo(alignment));\n+    uptr map_size = RoundUpMapSize(size);\n+    if (alignment > page_size_)\n+      map_size += alignment;\n+    // Overflow.\n+    if (map_size < size) return ReturnNullOrDieOnBadRequest();\n+    uptr map_beg = reinterpret_cast<uptr>(\n+        MmapOrDie(map_size, \"LargeMmapAllocator\"));\n+    CHECK(IsAligned(map_beg, page_size_));\n+    MapUnmapCallback().OnMap(map_beg, map_size);\n+    uptr map_end = map_beg + map_size;\n+    uptr res = map_beg + page_size_;\n+    if (res & (alignment - 1))  // Align.\n+      res += alignment - (res & (alignment - 1));\n+    CHECK(IsAligned(res, alignment));\n+    CHECK(IsAligned(res, page_size_));\n+    CHECK_GE(res + size, map_beg);\n+    CHECK_LE(res + size, map_end);\n+    Header *h = GetHeader(res);\n+    h->size = size;\n+    h->map_beg = map_beg;\n+    h->map_size = map_size;\n+    uptr size_log = MostSignificantSetBitIndex(map_size);\n+    CHECK_LT(size_log, ARRAY_SIZE(stats.by_size_log));\n+    {\n+      SpinMutexLock l(&mutex_);\n+      uptr idx = n_chunks_++;\n+      chunks_sorted_ = false;\n+      CHECK_LT(idx, kMaxNumChunks);\n+      h->chunk_idx = idx;\n+      chunks_[idx] = h;\n+      stats.n_allocs++;\n+      stats.currently_allocated += map_size;\n+      stats.max_allocated = Max(stats.max_allocated, stats.currently_allocated);\n+      stats.by_size_log[size_log]++;\n+      stat->Add(AllocatorStatAllocated, map_size);\n+      stat->Add(AllocatorStatMapped, map_size);\n+    }\n+    return reinterpret_cast<void*>(res);\n+  }\n+\n+  bool MayReturnNull() const {\n+    return atomic_load(&may_return_null_, memory_order_acquire);\n+  }\n+\n+  void *ReturnNullOrDieOnBadRequest() {\n+    if (MayReturnNull()) return nullptr;\n+    ReportAllocatorCannotReturnNull(false);\n+  }\n+\n+  void *ReturnNullOrDieOnOOM() {\n+    if (MayReturnNull()) return nullptr;\n+    ReportAllocatorCannotReturnNull(true);\n+  }\n+\n+  void SetMayReturnNull(bool may_return_null) {\n+    atomic_store(&may_return_null_, may_return_null, memory_order_release);\n+  }\n+\n+  void Deallocate(AllocatorStats *stat, void *p) {\n+    Header *h = GetHeader(p);\n+    {\n+      SpinMutexLock l(&mutex_);\n+      uptr idx = h->chunk_idx;\n+      CHECK_EQ(chunks_[idx], h);\n+      CHECK_LT(idx, n_chunks_);\n+      chunks_[idx] = chunks_[n_chunks_ - 1];\n+      chunks_[idx]->chunk_idx = idx;\n+      n_chunks_--;\n+      chunks_sorted_ = false;\n+      stats.n_frees++;\n+      stats.currently_allocated -= h->map_size;\n+      stat->Sub(AllocatorStatAllocated, h->map_size);\n+      stat->Sub(AllocatorStatMapped, h->map_size);\n+    }\n+    MapUnmapCallback().OnUnmap(h->map_beg, h->map_size);\n+    UnmapOrDie(reinterpret_cast<void*>(h->map_beg), h->map_size);\n+  }\n+\n+  uptr TotalMemoryUsed() {\n+    SpinMutexLock l(&mutex_);\n+    uptr res = 0;\n+    for (uptr i = 0; i < n_chunks_; i++) {\n+      Header *h = chunks_[i];\n+      CHECK_EQ(h->chunk_idx, i);\n+      res += RoundUpMapSize(h->size);\n+    }\n+    return res;\n+  }\n+\n+  bool PointerIsMine(const void *p) {\n+    return GetBlockBegin(p) != nullptr;\n+  }\n+\n+  uptr GetActuallyAllocatedSize(void *p) {\n+    return RoundUpTo(GetHeader(p)->size, page_size_);\n+  }\n+\n+  // At least page_size_/2 metadata bytes is available.\n+  void *GetMetaData(const void *p) {\n+    // Too slow: CHECK_EQ(p, GetBlockBegin(p));\n+    if (!IsAligned(reinterpret_cast<uptr>(p), page_size_)) {\n+      Printf(\"%s: bad pointer %p\\n\", SanitizerToolName, p);\n+      CHECK(IsAligned(reinterpret_cast<uptr>(p), page_size_));\n+    }\n+    return GetHeader(p) + 1;\n+  }\n+\n+  void *GetBlockBegin(const void *ptr) {\n+    uptr p = reinterpret_cast<uptr>(ptr);\n+    SpinMutexLock l(&mutex_);\n+    uptr nearest_chunk = 0;\n+    // Cache-friendly linear search.\n+    for (uptr i = 0; i < n_chunks_; i++) {\n+      uptr ch = reinterpret_cast<uptr>(chunks_[i]);\n+      if (p < ch) continue;  // p is at left to this chunk, skip it.\n+      if (p - ch < p - nearest_chunk)\n+        nearest_chunk = ch;\n+    }\n+    if (!nearest_chunk)\n+      return nullptr;\n+    Header *h = reinterpret_cast<Header *>(nearest_chunk);\n+    CHECK_GE(nearest_chunk, h->map_beg);\n+    CHECK_LT(nearest_chunk, h->map_beg + h->map_size);\n+    CHECK_LE(nearest_chunk, p);\n+    if (h->map_beg + h->map_size <= p)\n+      return nullptr;\n+    return GetUser(h);\n+  }\n+\n+  // This function does the same as GetBlockBegin, but is much faster.\n+  // Must be called with the allocator locked.\n+  void *GetBlockBeginFastLocked(void *ptr) {\n+    mutex_.CheckLocked();\n+    uptr p = reinterpret_cast<uptr>(ptr);\n+    uptr n = n_chunks_;\n+    if (!n) return nullptr;\n+    if (!chunks_sorted_) {\n+      // Do one-time sort. chunks_sorted_ is reset in Allocate/Deallocate.\n+      SortArray(reinterpret_cast<uptr*>(chunks_), n);\n+      for (uptr i = 0; i < n; i++)\n+        chunks_[i]->chunk_idx = i;\n+      chunks_sorted_ = true;\n+      min_mmap_ = reinterpret_cast<uptr>(chunks_[0]);\n+      max_mmap_ = reinterpret_cast<uptr>(chunks_[n - 1]) +\n+          chunks_[n - 1]->map_size;\n+    }\n+    if (p < min_mmap_ || p >= max_mmap_)\n+      return nullptr;\n+    uptr beg = 0, end = n - 1;\n+    // This loop is a log(n) lower_bound. It does not check for the exact match\n+    // to avoid expensive cache-thrashing loads.\n+    while (end - beg >= 2) {\n+      uptr mid = (beg + end) / 2;  // Invariant: mid >= beg + 1\n+      if (p < reinterpret_cast<uptr>(chunks_[mid]))\n+        end = mid - 1;  // We are not interested in chunks_[mid].\n+      else\n+        beg = mid;  // chunks_[mid] may still be what we want.\n+    }\n+\n+    if (beg < end) {\n+      CHECK_EQ(beg + 1, end);\n+      // There are 2 chunks left, choose one.\n+      if (p >= reinterpret_cast<uptr>(chunks_[end]))\n+        beg = end;\n+    }\n+\n+    Header *h = chunks_[beg];\n+    if (h->map_beg + h->map_size <= p || p < h->map_beg)\n+      return nullptr;\n+    return GetUser(h);\n+  }\n+\n+  void PrintStats() {\n+    Printf(\"Stats: LargeMmapAllocator: allocated %zd times, \"\n+           \"remains %zd (%zd K) max %zd M; by size logs: \",\n+           stats.n_allocs, stats.n_allocs - stats.n_frees,\n+           stats.currently_allocated >> 10, stats.max_allocated >> 20);\n+    for (uptr i = 0; i < ARRAY_SIZE(stats.by_size_log); i++) {\n+      uptr c = stats.by_size_log[i];\n+      if (!c) continue;\n+      Printf(\"%zd:%zd; \", i, c);\n+    }\n+    Printf(\"\\n\");\n+  }\n+\n+  // ForceLock() and ForceUnlock() are needed to implement Darwin malloc zone\n+  // introspection API.\n+  void ForceLock() {\n+    mutex_.Lock();\n+  }\n+\n+  void ForceUnlock() {\n+    mutex_.Unlock();\n+  }\n+\n+  // Iterate over all existing chunks.\n+  // The allocator must be locked when calling this function.\n+  void ForEachChunk(ForEachChunkCallback callback, void *arg) {\n+    for (uptr i = 0; i < n_chunks_; i++)\n+      callback(reinterpret_cast<uptr>(GetUser(chunks_[i])), arg);\n+  }\n+\n+ private:\n+  static const int kMaxNumChunks = 1 << FIRST_32_SECOND_64(15, 18);\n+  struct Header {\n+    uptr map_beg;\n+    uptr map_size;\n+    uptr size;\n+    uptr chunk_idx;\n+  };\n+\n+  Header *GetHeader(uptr p) {\n+    CHECK(IsAligned(p, page_size_));\n+    return reinterpret_cast<Header*>(p - page_size_);\n+  }\n+  Header *GetHeader(const void *p) {\n+    return GetHeader(reinterpret_cast<uptr>(p));\n+  }\n+\n+  void *GetUser(Header *h) {\n+    CHECK(IsAligned((uptr)h, page_size_));\n+    return reinterpret_cast<void*>(reinterpret_cast<uptr>(h) + page_size_);\n+  }\n+\n+  uptr RoundUpMapSize(uptr size) {\n+    return RoundUpTo(size, page_size_) + page_size_;\n+  }\n+\n+  uptr page_size_;\n+  Header *chunks_[kMaxNumChunks];\n+  uptr n_chunks_;\n+  uptr min_mmap_, max_mmap_;\n+  bool chunks_sorted_;\n+  struct Stats {\n+    uptr n_allocs, n_frees, currently_allocated, max_allocated, by_size_log[64];\n+  } stats;\n+  atomic_uint8_t may_return_null_;\n+  SpinMutex mutex_;\n+};"}, {"sha": "4cda021a947af90452abf360a3fdacaa2b95d4eb", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_size_class_map.h", "status": "added", "additions": 215, "deletions": 0, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_size_class_map.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,215 @@\n+//===-- sanitizer_allocator_size_class_map.h --------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// SizeClassMap maps allocation sizes into size classes and back.\n+// Class 0 always corresponds to size 0.\n+// The other sizes are controlled by the template parameters:\n+//   kMinSizeLog: defines the class 1    as 2^kMinSizeLog.\n+//   kMaxSizeLog: defines the last class as 2^kMaxSizeLog.\n+//   kMidSizeLog: the classes starting from 1 increase with step\n+//                2^kMinSizeLog until 2^kMidSizeLog.\n+//   kNumBits: the number of non-zero bits in sizes after 2^kMidSizeLog.\n+//             E.g. with kNumBits==3 all size classes after 2^kMidSizeLog\n+//             look like 0b1xx0..0, where x is either 0 or 1.\n+//\n+// Example: kNumBits=3, kMidSizeLog=4, kMidSizeLog=8, kMaxSizeLog=17:\n+//\n+// Classes 1 - 16 correspond to sizes 16 to 256 (size = class_id * 16).\n+// Next 4 classes: 256 + i * 64  (i = 1 to 4).\n+// Next 4 classes: 512 + i * 128 (i = 1 to 4).\n+// ...\n+// Next 4 classes: 2^k + i * 2^(k-2) (i = 1 to 4).\n+// Last class corresponds to kMaxSize = 1 << kMaxSizeLog.\n+//\n+// This structure of the size class map gives us:\n+//   - Efficient table-free class-to-size and size-to-class functions.\n+//   - Difference between two consequent size classes is between 14% and 25%\n+//\n+// This class also gives a hint to a thread-caching allocator about the amount\n+// of chunks that need to be cached per-thread:\n+//  - kMaxNumCachedHint is a hint for maximal number of chunks per size class.\n+//    The actual number is computed in TransferBatch.\n+//  - (1 << kMaxBytesCachedLog) is the maximal number of bytes per size class.\n+//\n+// Part of output of SizeClassMap::Print():\n+// c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0\n+// c01 => s: 16 diff: +16 00% l 4 cached: 256 4096; id 1\n+// c02 => s: 32 diff: +16 100% l 5 cached: 256 8192; id 2\n+// c03 => s: 48 diff: +16 50% l 5 cached: 256 12288; id 3\n+// c04 => s: 64 diff: +16 33% l 6 cached: 256 16384; id 4\n+// c05 => s: 80 diff: +16 25% l 6 cached: 256 20480; id 5\n+// c06 => s: 96 diff: +16 20% l 6 cached: 256 24576; id 6\n+// c07 => s: 112 diff: +16 16% l 6 cached: 256 28672; id 7\n+//\n+// c08 => s: 128 diff: +16 14% l 7 cached: 256 32768; id 8\n+// c09 => s: 144 diff: +16 12% l 7 cached: 256 36864; id 9\n+// c10 => s: 160 diff: +16 11% l 7 cached: 256 40960; id 10\n+// c11 => s: 176 diff: +16 10% l 7 cached: 256 45056; id 11\n+// c12 => s: 192 diff: +16 09% l 7 cached: 256 49152; id 12\n+// c13 => s: 208 diff: +16 08% l 7 cached: 256 53248; id 13\n+// c14 => s: 224 diff: +16 07% l 7 cached: 256 57344; id 14\n+// c15 => s: 240 diff: +16 07% l 7 cached: 256 61440; id 15\n+//\n+// c16 => s: 256 diff: +16 06% l 8 cached: 256 65536; id 16\n+// c17 => s: 320 diff: +64 25% l 8 cached: 204 65280; id 17\n+// c18 => s: 384 diff: +64 20% l 8 cached: 170 65280; id 18\n+// c19 => s: 448 diff: +64 16% l 8 cached: 146 65408; id 19\n+//\n+// c20 => s: 512 diff: +64 14% l 9 cached: 128 65536; id 20\n+// c21 => s: 640 diff: +128 25% l 9 cached: 102 65280; id 21\n+// c22 => s: 768 diff: +128 20% l 9 cached: 85 65280; id 22\n+// c23 => s: 896 diff: +128 16% l 9 cached: 73 65408; id 23\n+//\n+// c24 => s: 1024 diff: +128 14% l 10 cached: 64 65536; id 24\n+// c25 => s: 1280 diff: +256 25% l 10 cached: 51 65280; id 25\n+// c26 => s: 1536 diff: +256 20% l 10 cached: 42 64512; id 26\n+// c27 => s: 1792 diff: +256 16% l 10 cached: 36 64512; id 27\n+//\n+// ...\n+//\n+// c48 => s: 65536 diff: +8192 14% l 16 cached: 1 65536; id 48\n+// c49 => s: 81920 diff: +16384 25% l 16 cached: 1 81920; id 49\n+// c50 => s: 98304 diff: +16384 20% l 16 cached: 1 98304; id 50\n+// c51 => s: 114688 diff: +16384 16% l 16 cached: 1 114688; id 51\n+//\n+// c52 => s: 131072 diff: +16384 14% l 17 cached: 1 131072; id 52\n+//\n+//\n+// Another example (kNumBits=2):\n+// c00 => s: 0 diff: +0 00% l 0 cached: 0 0; id 0\n+// c01 => s: 32 diff: +32 00% l 5 cached: 64 2048; id 1\n+// c02 => s: 64 diff: +32 100% l 6 cached: 64 4096; id 2\n+// c03 => s: 96 diff: +32 50% l 6 cached: 64 6144; id 3\n+// c04 => s: 128 diff: +32 33% l 7 cached: 64 8192; id 4\n+// c05 => s: 160 diff: +32 25% l 7 cached: 64 10240; id 5\n+// c06 => s: 192 diff: +32 20% l 7 cached: 64 12288; id 6\n+// c07 => s: 224 diff: +32 16% l 7 cached: 64 14336; id 7\n+// c08 => s: 256 diff: +32 14% l 8 cached: 64 16384; id 8\n+// c09 => s: 384 diff: +128 50% l 8 cached: 42 16128; id 9\n+// c10 => s: 512 diff: +128 33% l 9 cached: 32 16384; id 10\n+// c11 => s: 768 diff: +256 50% l 9 cached: 21 16128; id 11\n+// c12 => s: 1024 diff: +256 33% l 10 cached: 16 16384; id 12\n+// c13 => s: 1536 diff: +512 50% l 10 cached: 10 15360; id 13\n+// c14 => s: 2048 diff: +512 33% l 11 cached: 8 16384; id 14\n+// c15 => s: 3072 diff: +1024 50% l 11 cached: 5 15360; id 15\n+// c16 => s: 4096 diff: +1024 33% l 12 cached: 4 16384; id 16\n+// c17 => s: 6144 diff: +2048 50% l 12 cached: 2 12288; id 17\n+// c18 => s: 8192 diff: +2048 33% l 13 cached: 2 16384; id 18\n+// c19 => s: 12288 diff: +4096 50% l 13 cached: 1 12288; id 19\n+// c20 => s: 16384 diff: +4096 33% l 14 cached: 1 16384; id 20\n+// c21 => s: 24576 diff: +8192 50% l 14 cached: 1 24576; id 21\n+// c22 => s: 32768 diff: +8192 33% l 15 cached: 1 32768; id 22\n+// c23 => s: 49152 diff: +16384 50% l 15 cached: 1 49152; id 23\n+// c24 => s: 65536 diff: +16384 33% l 16 cached: 1 65536; id 24\n+// c25 => s: 98304 diff: +32768 50% l 16 cached: 1 98304; id 25\n+// c26 => s: 131072 diff: +32768 33% l 17 cached: 1 131072; id 26\n+\n+template <uptr kNumBits, uptr kMinSizeLog, uptr kMidSizeLog, uptr kMaxSizeLog,\n+          uptr kMaxNumCachedHintT, uptr kMaxBytesCachedLog>\n+class SizeClassMap {\n+  static const uptr kMinSize = 1 << kMinSizeLog;\n+  static const uptr kMidSize = 1 << kMidSizeLog;\n+  static const uptr kMidClass = kMidSize / kMinSize;\n+  static const uptr S = kNumBits - 1;\n+  static const uptr M = (1 << S) - 1;\n+\n+ public:\n+  // kMaxNumCachedHintT is a power of two. It serves as a hint\n+  // for the size of TransferBatch, the actual size could be a bit smaller.\n+  static const uptr kMaxNumCachedHint = kMaxNumCachedHintT;\n+  COMPILER_CHECK((kMaxNumCachedHint & (kMaxNumCachedHint - 1)) == 0);\n+\n+  static const uptr kMaxSize = 1UL << kMaxSizeLog;\n+  static const uptr kNumClasses =\n+      kMidClass + ((kMaxSizeLog - kMidSizeLog) << S) + 1;\n+  static const uptr kLargestClassID = kNumClasses - 2;\n+  COMPILER_CHECK(kNumClasses >= 16 && kNumClasses <= 256);\n+  static const uptr kNumClassesRounded =\n+      kNumClasses <= 32  ? 32 :\n+      kNumClasses <= 64  ? 64 :\n+      kNumClasses <= 128 ? 128 : 256;\n+\n+  static uptr Size(uptr class_id) {\n+    if (class_id <= kMidClass)\n+      return kMinSize * class_id;\n+    class_id -= kMidClass;\n+    uptr t = kMidSize << (class_id >> S);\n+    return t + (t >> S) * (class_id & M);\n+  }\n+\n+  static uptr ClassID(uptr size) {\n+    if (size <= kMidSize)\n+      return (size + kMinSize - 1) >> kMinSizeLog;\n+    if (size > kMaxSize) return 0;\n+    uptr l = MostSignificantSetBitIndex(size);\n+    uptr hbits = (size >> (l - S)) & M;\n+    uptr lbits = size & ((1 << (l - S)) - 1);\n+    uptr l1 = l - kMidSizeLog;\n+    return kMidClass + (l1 << S) + hbits + (lbits > 0);\n+  }\n+\n+  static uptr MaxCachedHint(uptr class_id) {\n+    if (class_id == 0) return 0;\n+    uptr n = (1UL << kMaxBytesCachedLog) / Size(class_id);\n+    return Max<uptr>(1, Min(kMaxNumCachedHint, n));\n+  }\n+\n+  static void Print() {\n+    uptr prev_s = 0;\n+    uptr total_cached = 0;\n+    for (uptr i = 0; i < kNumClasses; i++) {\n+      uptr s = Size(i);\n+      if (s >= kMidSize / 2 && (s & (s - 1)) == 0)\n+        Printf(\"\\n\");\n+      uptr d = s - prev_s;\n+      uptr p = prev_s ? (d * 100 / prev_s) : 0;\n+      uptr l = s ? MostSignificantSetBitIndex(s) : 0;\n+      uptr cached = MaxCachedHint(i) * s;\n+      Printf(\"c%02zd => s: %zd diff: +%zd %02zd%% l %zd \"\n+             \"cached: %zd %zd; id %zd\\n\",\n+             i, Size(i), d, p, l, MaxCachedHint(i), cached, ClassID(s));\n+      total_cached += cached;\n+      prev_s = s;\n+    }\n+    Printf(\"Total cached: %zd\\n\", total_cached);\n+  }\n+\n+  static void Validate() {\n+    for (uptr c = 1; c < kNumClasses; c++) {\n+      // Printf(\"Validate: c%zd\\n\", c);\n+      uptr s = Size(c);\n+      CHECK_NE(s, 0U);\n+      CHECK_EQ(ClassID(s), c);\n+      if (c != kNumClasses - 1)\n+        CHECK_EQ(ClassID(s + 1), c + 1);\n+      CHECK_EQ(ClassID(s - 1), c);\n+      if (c)\n+        CHECK_GT(Size(c), Size(c-1));\n+    }\n+    CHECK_EQ(ClassID(kMaxSize + 1), 0);\n+\n+    for (uptr s = 1; s <= kMaxSize; s++) {\n+      uptr c = ClassID(s);\n+      // Printf(\"s%zd => c%zd\\n\", s, c);\n+      CHECK_LT(c, kNumClasses);\n+      CHECK_GE(Size(c), s);\n+      if (c > 0)\n+        CHECK_LT(Size(c-1), s);\n+    }\n+  }\n+};\n+\n+typedef SizeClassMap<3, 4, 8, 17, 128, 16> DefaultSizeClassMap;\n+typedef SizeClassMap<3, 4, 8, 17, 64, 14> CompactSizeClassMap;\n+typedef SizeClassMap<2, 5, 9, 16, 64, 14> VeryCompactSizeClassMap;"}, {"sha": "e336b5d365a55808d2d7d9388f53865ced886673", "filename": "libsanitizer/sanitizer_common/sanitizer_allocator_stats.h", "status": "added", "additions": 103, "deletions": 0, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_allocator_stats.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,103 @@\n+//===-- sanitizer_allocator_stats.h -----------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// Part of the Sanitizer Allocator.\n+//\n+//===----------------------------------------------------------------------===//\n+#ifndef SANITIZER_ALLOCATOR_H\n+#error This file must be included inside sanitizer_allocator.h\n+#endif\n+\n+// Memory allocator statistics\n+enum AllocatorStat {\n+  AllocatorStatAllocated,\n+  AllocatorStatMapped,\n+  AllocatorStatCount\n+};\n+\n+typedef uptr AllocatorStatCounters[AllocatorStatCount];\n+\n+// Per-thread stats, live in per-thread cache.\n+class AllocatorStats {\n+ public:\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+  }\n+  void InitLinkerInitialized() {}\n+\n+  void Add(AllocatorStat i, uptr v) {\n+    v += atomic_load(&stats_[i], memory_order_relaxed);\n+    atomic_store(&stats_[i], v, memory_order_relaxed);\n+  }\n+\n+  void Sub(AllocatorStat i, uptr v) {\n+    v = atomic_load(&stats_[i], memory_order_relaxed) - v;\n+    atomic_store(&stats_[i], v, memory_order_relaxed);\n+  }\n+\n+  void Set(AllocatorStat i, uptr v) {\n+    atomic_store(&stats_[i], v, memory_order_relaxed);\n+  }\n+\n+  uptr Get(AllocatorStat i) const {\n+    return atomic_load(&stats_[i], memory_order_relaxed);\n+  }\n+\n+ private:\n+  friend class AllocatorGlobalStats;\n+  AllocatorStats *next_;\n+  AllocatorStats *prev_;\n+  atomic_uintptr_t stats_[AllocatorStatCount];\n+};\n+\n+// Global stats, used for aggregation and querying.\n+class AllocatorGlobalStats : public AllocatorStats {\n+ public:\n+  void InitLinkerInitialized() {\n+    next_ = this;\n+    prev_ = this;\n+  }\n+  void Init() {\n+    internal_memset(this, 0, sizeof(*this));\n+    InitLinkerInitialized();\n+  }\n+\n+  void Register(AllocatorStats *s) {\n+    SpinMutexLock l(&mu_);\n+    s->next_ = next_;\n+    s->prev_ = this;\n+    next_->prev_ = s;\n+    next_ = s;\n+  }\n+\n+  void Unregister(AllocatorStats *s) {\n+    SpinMutexLock l(&mu_);\n+    s->prev_->next_ = s->next_;\n+    s->next_->prev_ = s->prev_;\n+    for (int i = 0; i < AllocatorStatCount; i++)\n+      Add(AllocatorStat(i), s->Get(AllocatorStat(i)));\n+  }\n+\n+  void Get(AllocatorStatCounters s) const {\n+    internal_memset(s, 0, AllocatorStatCount * sizeof(uptr));\n+    SpinMutexLock l(&mu_);\n+    const AllocatorStats *stats = this;\n+    for (;;) {\n+      for (int i = 0; i < AllocatorStatCount; i++)\n+        s[i] += stats->Get(AllocatorStat(i));\n+      stats = stats->next_;\n+      if (stats == this)\n+        break;\n+    }\n+    // All stats must be non-negative.\n+    for (int i = 0; i < AllocatorStatCount; i++)\n+      s[i] = ((sptr)s[i]) >= 0 ? s[i] : 0;\n+  }\n+\n+ private:\n+  mutable SpinMutex mu_;\n+};"}, {"sha": "737ccbb716db06b0d75e8fa3f3b25607671d2c57", "filename": "libsanitizer/sanitizer_common/sanitizer_asm.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_asm.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -40,3 +40,17 @@\n # define CFI_DEF_CFA(reg, n)\n # define CFI_RESTORE(reg)\n #endif\n+\n+#if !defined(__APPLE__)\n+# define ASM_HIDDEN(symbol) .hidden symbol\n+# define ASM_TYPE_FUNCTION(symbol) .type symbol, @function\n+# define ASM_SIZE(symbol) .size symbol, .-symbol\n+# define ASM_TSAN_SYMBOL(symbol) symbol\n+# define ASM_TSAN_SYMBOL_INTERCEPTOR(symbol) symbol\n+#else\n+# define ASM_HIDDEN(symbol)\n+# define ASM_TYPE_FUNCTION(symbol)\n+# define ASM_SIZE(symbol)\n+# define ASM_TSAN_SYMBOL(symbol) _##symbol\n+# define ASM_TSAN_SYMBOL_INTERCEPTOR(symbol) _wrap_##symbol\n+#endif"}, {"sha": "4ae87142d4670f6eeb7ab8e71b87fcc4315d17b7", "filename": "libsanitizer/sanitizer_common/sanitizer_atomic_msvc.h", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_atomic_msvc.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -31,6 +31,10 @@ extern \"C\" long _InterlockedExchange(    // NOLINT\n extern \"C\" long _InterlockedExchangeAdd(  // NOLINT\n     long volatile * Addend, long Value);  // NOLINT\n #pragma intrinsic(_InterlockedExchangeAdd)\n+extern \"C\" char _InterlockedCompareExchange8(  // NOLINT\n+    char volatile *Destination,                // NOLINT\n+    char Exchange, char Comparand);            // NOLINT\n+#pragma intrinsic(_InterlockedCompareExchange8)\n extern \"C\" short _InterlockedCompareExchange16(  // NOLINT\n     short volatile *Destination,                 // NOLINT\n     short Exchange, short Comparand);            // NOLINT\n@@ -169,15 +173,17 @@ INLINE u32 atomic_exchange(volatile atomic_uint32_t *a,\n   return (u32)_InterlockedExchange((volatile long*)&a->val_dont_use, v);\n }\n \n-#ifndef _WIN64\n-\n INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n                                            u8 *cmp,\n                                            u8 xchgv,\n                                            memory_order mo) {\n   (void)mo;\n   DCHECK(!((uptr)a % sizeof(*a)));\n   u8 cmpv = *cmp;\n+#ifdef _WIN64\n+  u8 prev = (u8)_InterlockedCompareExchange8(\n+      (volatile char*)&a->val_dont_use, (char)xchgv, (char)cmpv);\n+#else\n   u8 prev;\n   __asm {\n     mov al, cmpv\n@@ -186,14 +192,13 @@ INLINE bool atomic_compare_exchange_strong(volatile atomic_uint8_t *a,\n     lock cmpxchg [ecx], dl\n     mov prev, al\n   }\n+#endif\n   if (prev == cmpv)\n     return true;\n   *cmp = prev;\n   return false;\n }\n \n-#endif\n-\n INLINE bool atomic_compare_exchange_strong(volatile atomic_uintptr_t *a,\n                                            uptr *cmp,\n                                            uptr xchg,"}, {"sha": "b445f613b85c2a4219964591c7d95fdf255137b1", "filename": "libsanitizer/sanitizer_common/sanitizer_common.cc", "status": "modified", "additions": 117, "deletions": 92, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -10,6 +10,7 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+#include \"sanitizer_allocator_interface.h\"\n #include \"sanitizer_allocator_internal.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_libc.h\"\n@@ -22,13 +23,7 @@ namespace __sanitizer {\n const char *SanitizerToolName = \"SanitizerTool\";\n \n atomic_uint32_t current_verbosity;\n-\n-uptr GetPageSizeCached() {\n-  static uptr PageSize;\n-  if (!PageSize)\n-    PageSize = GetPageSize();\n-  return PageSize;\n-}\n+uptr PageSizeCached;\n \n StaticSpinMutex report_file_mu;\n ReportFile report_file = {&report_file_mu, kStderrFd, \"\", \"\", 0};\n@@ -103,78 +98,21 @@ uptr stoptheworld_tracer_pid = 0;\n // writing to the same log file.\n uptr stoptheworld_tracer_ppid = 0;\n \n-static const int kMaxNumOfInternalDieCallbacks = 5;\n-static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];\n-\n-bool AddDieCallback(DieCallbackType callback) {\n-  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n-    if (InternalDieCallbacks[i] == nullptr) {\n-      InternalDieCallbacks[i] = callback;\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-bool RemoveDieCallback(DieCallbackType callback) {\n-  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n-    if (InternalDieCallbacks[i] == callback) {\n-      internal_memmove(&InternalDieCallbacks[i], &InternalDieCallbacks[i + 1],\n-                       sizeof(InternalDieCallbacks[0]) *\n-                           (kMaxNumOfInternalDieCallbacks - i - 1));\n-      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n-static DieCallbackType UserDieCallback;\n-void SetUserDieCallback(DieCallbackType callback) {\n-  UserDieCallback = callback;\n-}\n-\n-void NORETURN Die() {\n-  if (UserDieCallback)\n-    UserDieCallback();\n-  for (int i = kMaxNumOfInternalDieCallbacks - 1; i >= 0; i--) {\n-    if (InternalDieCallbacks[i])\n-      InternalDieCallbacks[i]();\n-  }\n-  if (common_flags()->abort_on_error)\n-    Abort();\n-  internal__exit(common_flags()->exitcode);\n-}\n-\n-static CheckFailedCallbackType CheckFailedCallback;\n-void SetCheckFailedCallback(CheckFailedCallbackType callback) {\n-  CheckFailedCallback = callback;\n-}\n-\n-void NORETURN CheckFailed(const char *file, int line, const char *cond,\n-                          u64 v1, u64 v2) {\n-  if (CheckFailedCallback) {\n-    CheckFailedCallback(file, line, cond, v1, v2);\n-  }\n-  Report(\"Sanitizer CHECK failed: %s:%d %s (%lld, %lld)\\n\", file, line, cond,\n-                                                            v1, v2);\n-  Die();\n-}\n-\n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n-                                      const char *mmap_type, error_t err) {\n+                                      const char *mmap_type, error_t err,\n+                                      bool raw_report) {\n   static int recursion_count;\n-  if (recursion_count) {\n+  if (raw_report || recursion_count) {\n+    // If raw report is requested or we went into recursion, just die.\n     // The Report() and CHECK calls below may call mmap recursively and fail.\n-    // If we went into recursion, just die.\n     RawWrite(\"ERROR: Failed to mmap\\n\");\n     Die();\n   }\n   recursion_count++;\n   Report(\"ERROR: %s failed to \"\n          \"%s 0x%zx (%zd) bytes of %s (error code: %d)\\n\",\n          SanitizerToolName, mmap_type, size, size, mem_type, err);\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n   DumpProcessMap();\n #endif\n   UNREACHABLE(\"unable to mmap\");\n@@ -217,6 +155,7 @@ bool ReadFileToBuffer(const char *file_name, char **buff, uptr *buff_size,\n }\n \n typedef bool UptrComparisonFunction(const uptr &a, const uptr &b);\n+typedef bool U32ComparisonFunction(const u32 &a, const u32 &b);\n \n template<class T>\n static inline bool CompareLess(const T &a, const T &b) {\n@@ -227,25 +166,8 @@ void SortArray(uptr *array, uptr size) {\n   InternalSort<uptr*, UptrComparisonFunction>(&array, size, CompareLess);\n }\n \n-// We want to map a chunk of address space aligned to 'alignment'.\n-// We do it by maping a bit more and then unmaping redundant pieces.\n-// We probably can do it with fewer syscalls in some OS-dependent way.\n-void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n-// uptr PageSize = GetPageSizeCached();\n-  CHECK(IsPowerOfTwo(size));\n-  CHECK(IsPowerOfTwo(alignment));\n-  uptr map_size = size + alignment;\n-  uptr map_res = (uptr)MmapOrDie(map_size, mem_type);\n-  uptr map_end = map_res + map_size;\n-  uptr res = map_res;\n-  if (res & (alignment - 1))  // Not aligned.\n-    res = (map_res + alignment) & ~(alignment - 1);\n-  uptr end = res + size;\n-  if (res != map_res)\n-    UnmapOrDie((void*)map_res, res - map_res);\n-  if (end != map_end)\n-    UnmapOrDie((void*)end, map_end - end);\n-  return (void*)res;\n+void SortArray(u32 *array, uptr size) {\n+  InternalSort<u32*, U32ComparisonFunction>(&array, size, CompareLess);\n }\n \n const char *StripPathPrefix(const char *filepath,\n@@ -283,7 +205,7 @@ void ReportErrorSummary(const char *error_message) {\n   __sanitizer_report_error_summary(buff.data());\n }\n \n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n void ReportErrorSummary(const char *error_type, const AddressInfo &info) {\n   if (!common_flags()->print_summary)\n     return;\n@@ -295,6 +217,40 @@ void ReportErrorSummary(const char *error_type, const AddressInfo &info) {\n }\n #endif\n \n+// Removes the ANSI escape sequences from the input string (in-place).\n+void RemoveANSIEscapeSequencesFromString(char *str) {\n+  if (!str)\n+    return;\n+\n+  // We are going to remove the escape sequences in place.\n+  char *s = str;\n+  char *z = str;\n+  while (*s != '\\0') {\n+    CHECK_GE(s, z);\n+    // Skip over ANSI escape sequences with pointer 's'.\n+    if (*s == '\\033' && *(s + 1) == '[') {\n+      s = internal_strchrnul(s, 'm');\n+      if (*s == '\\0') {\n+        break;\n+      }\n+      s++;\n+      continue;\n+    }\n+    // 's' now points at a character we want to keep. Copy over the buffer\n+    // content if the escape sequence has been perviously skipped andadvance\n+    // both pointers.\n+    if (s != z)\n+      *z = *s;\n+\n+    // If we have not seen an escape sequence, just advance both pointers.\n+    z++;\n+    s++;\n+  }\n+\n+  // Null terminate the string.\n+  *z = '\\0';\n+}\n+\n void LoadedModule::set(const char *module_name, uptr base_address) {\n   clear();\n   full_name_ = internal_strdup(module_name);\n@@ -318,9 +274,8 @@ void LoadedModule::addAddressRange(uptr beg, uptr end, bool executable) {\n }\n \n bool LoadedModule::containsAddress(uptr address) const {\n-  for (Iterator iter = ranges(); iter.hasNext();) {\n-    const AddressRange *r = iter.next();\n-    if (r->beg <= address && address < r->end)\n+  for (const AddressRange &r : ranges()) {\n+    if (r.beg <= address && address < r.end)\n       return true;\n   }\n   return false;\n@@ -387,6 +342,10 @@ bool TemplateMatch(const char *templ, const char *str) {\n static const char kPathSeparator = SANITIZER_WINDOWS ? ';' : ':';\n \n char *FindPathToBinary(const char *name) {\n+  if (FileExists(name)) {\n+    return internal_strdup(name);\n+  }\n+\n   const char *path = GetEnv(\"PATH\");\n   if (!path)\n     return nullptr;\n@@ -451,6 +410,53 @@ uptr ReadBinaryNameCached(/*out*/char *buf, uptr buf_len) {\n   return name_len;\n }\n \n+void PrintCmdline() {\n+  char **argv = GetArgv();\n+  if (!argv) return;\n+  Printf(\"\\nCommand: \");\n+  for (uptr i = 0; argv[i]; ++i)\n+    Printf(\"%s \", argv[i]);\n+  Printf(\"\\n\\n\");\n+}\n+\n+// Malloc hooks.\n+static const int kMaxMallocFreeHooks = 5;\n+struct MallocFreeHook {\n+  void (*malloc_hook)(const void *, uptr);\n+  void (*free_hook)(const void *);\n+};\n+\n+static MallocFreeHook MFHooks[kMaxMallocFreeHooks];\n+\n+void RunMallocHooks(const void *ptr, uptr size) {\n+  for (int i = 0; i < kMaxMallocFreeHooks; i++) {\n+    auto hook = MFHooks[i].malloc_hook;\n+    if (!hook) return;\n+    hook(ptr, size);\n+  }\n+}\n+\n+void RunFreeHooks(const void *ptr) {\n+  for (int i = 0; i < kMaxMallocFreeHooks; i++) {\n+    auto hook = MFHooks[i].free_hook;\n+    if (!hook) return;\n+    hook(ptr);\n+  }\n+}\n+\n+static int InstallMallocFreeHooks(void (*malloc_hook)(const void *, uptr),\n+                                  void (*free_hook)(const void *)) {\n+  if (!malloc_hook || !free_hook) return 0;\n+  for (int i = 0; i < kMaxMallocFreeHooks; i++) {\n+    if (MFHooks[i].malloc_hook == nullptr) {\n+      MFHooks[i].malloc_hook = malloc_hook;\n+      MFHooks[i].free_hook = free_hook;\n+      return i + 1;\n+    }\n+  }\n+  return 0;\n+}\n+\n } // namespace __sanitizer\n \n using namespace __sanitizer;  // NOLINT\n@@ -460,6 +466,11 @@ void __sanitizer_set_report_path(const char *path) {\n   report_file.SetReportPath(path);\n }\n \n+void __sanitizer_set_report_fd(void *fd) {\n+  report_file.fd = (fd_t)reinterpret_cast<uptr>(fd);\n+  report_file.fd_pid = internal_getpid();\n+}\n+\n void __sanitizer_report_error_summary(const char *error_summary) {\n   Printf(\"%s\\n\", error_summary);\n }\n@@ -468,4 +479,18 @@ SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_set_death_callback(void (*callback)(void)) {\n   SetUserDieCallback(callback);\n }\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __sanitizer_install_malloc_and_free_hooks(void (*malloc_hook)(const void *,\n+                                                                  uptr),\n+                                              void (*free_hook)(const void *)) {\n+  return InstallMallocFreeHooks(malloc_hook, free_hook);\n+}\n+\n+#if !SANITIZER_GO && !SANITIZER_SUPPORTS_WEAK_HOOKS\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_print_memory_profile(int top_percent) {\n+  (void)top_percent;\n+}\n+#endif\n } // extern \"C\""}, {"sha": "3e079ab7ad1b6a347d1c25254be35b5e16adbfe5", "filename": "libsanitizer/sanitizer_common/sanitizer_common.h", "status": "modified", "additions": 170, "deletions": 45, "changes": 215, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -21,7 +21,7 @@\n #include \"sanitizer_list.h\"\n #include \"sanitizer_mutex.h\"\n \n-#ifdef _MSC_VER\n+#if defined(_MSC_VER) && !defined(__clang__)\n extern \"C\" void _ReadWriteBarrier();\n #pragma intrinsic(_ReadWriteBarrier)\n #endif\n@@ -42,11 +42,10 @@ const uptr kWordSizeInBits = 8 * kWordSize;\n \n const uptr kMaxPathLength = 4096;\n \n-// 16K loaded modules should be enough for everyone.\n-static const uptr kMaxNumberOfModules = 1 << 14;\n-\n const uptr kMaxThreadStackSize = 1 << 30;  // 1Gb\n \n+static const uptr kErrorMessageBufferSize = 1 << 16;\n+\n // Denotes fake PC values that come from JIT/JAVA/etc.\n // For such PC values __tsan_symbolize_external() will be called.\n const u64 kExternalPCBit = 1ULL << 60;\n@@ -62,7 +61,12 @@ INLINE int Verbosity() {\n }\n \n uptr GetPageSize();\n-uptr GetPageSizeCached();\n+extern uptr PageSizeCached;\n+INLINE uptr GetPageSizeCached() {\n+  if (!PageSizeCached)\n+    PageSizeCached = GetPageSize();\n+  return PageSizeCached;\n+}\n uptr GetMmapGranularity();\n uptr GetMaxVirtualAddress();\n // Threads\n@@ -74,54 +78,64 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size);\n \n // Memory management\n-void *MmapOrDie(uptr size, const char *mem_type);\n+void *MmapOrDie(uptr size, const char *mem_type, bool raw_report = false);\n+INLINE void *MmapOrDieQuietly(uptr size, const char *mem_type) {\n+  return MmapOrDie(size, mem_type, /*raw_report*/ true);\n+}\n void UnmapOrDie(void *addr, uptr size);\n void *MmapFixedNoReserve(uptr fixed_addr, uptr size,\n                          const char *name = nullptr);\n void *MmapNoReserveOrDie(uptr size, const char *mem_type);\n void *MmapFixedOrDie(uptr fixed_addr, uptr size);\n-void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\n+void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name = nullptr);\n+void *MmapNoAccess(uptr size);\n // Map aligned chunk of address space; size and alignment are powers of two.\n void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type);\n-// Disallow access to a memory range.  Use MmapNoAccess to allocate an\n+// Disallow access to a memory range.  Use MmapFixedNoAccess to allocate an\n // unaccessible memory.\n bool MprotectNoAccess(uptr addr, uptr size);\n+bool MprotectReadOnly(uptr addr, uptr size);\n+\n+// Find an available address space.\n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding);\n \n // Used to check if we can map shadow memory to a fixed location.\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end);\n-void FlushUnneededShadowMemory(uptr addr, uptr size);\n+void ReleaseMemoryToOS(uptr addr, uptr size);\n void IncreaseTotalMmap(uptr size);\n void DecreaseTotalMmap(uptr size);\n uptr GetRSS();\n void NoHugePagesInRegion(uptr addr, uptr length);\n void DontDumpShadowMemory(uptr addr, uptr length);\n // Check if the built VMA size matches the runtime one.\n void CheckVMASize();\n+void RunMallocHooks(const void *ptr, uptr size);\n+void RunFreeHooks(const void *ptr);\n \n // InternalScopedBuffer can be used instead of large stack arrays to\n // keep frame size low.\n // FIXME: use InternalAlloc instead of MmapOrDie once\n // InternalAlloc is made libc-free.\n-template<typename T>\n+template <typename T>\n class InternalScopedBuffer {\n  public:\n   explicit InternalScopedBuffer(uptr cnt) {\n     cnt_ = cnt;\n-    ptr_ = (T*)MmapOrDie(cnt * sizeof(T), \"InternalScopedBuffer\");\n-  }\n-  ~InternalScopedBuffer() {\n-    UnmapOrDie(ptr_, cnt_ * sizeof(T));\n+    ptr_ = (T *)MmapOrDie(cnt * sizeof(T), \"InternalScopedBuffer\");\n   }\n+  ~InternalScopedBuffer() { UnmapOrDie(ptr_, cnt_ * sizeof(T)); }\n   T &operator[](uptr i) { return ptr_[i]; }\n   T *data() { return ptr_; }\n   uptr size() { return cnt_ * sizeof(T); }\n \n  private:\n   T *ptr_;\n   uptr cnt_;\n-  // Disallow evil constructors.\n-  InternalScopedBuffer(const InternalScopedBuffer&);\n-  void operator=(const InternalScopedBuffer&);\n+  // Disallow copies and moves.\n+  InternalScopedBuffer(const InternalScopedBuffer &) = delete;\n+  InternalScopedBuffer &operator=(const InternalScopedBuffer &) = delete;\n+  InternalScopedBuffer(InternalScopedBuffer &&) = delete;\n+  InternalScopedBuffer &operator=(InternalScopedBuffer &&) = delete;\n };\n \n class InternalScopedString : public InternalScopedBuffer<char> {\n@@ -160,6 +174,7 @@ void SetLowLevelAllocateCallback(LowLevelAllocateCallback callback);\n // IO\n void RawWrite(const char *buffer);\n bool ColorizeReports();\n+void RemoveANSIEscapeSequencesFromString(char *buffer);\n void Printf(const char *format, ...);\n void Report(const char *format, ...);\n void SetPrintfAndReportCallback(void (*callback)(const char *));\n@@ -271,10 +286,27 @@ const char *GetPwd();\n char *FindPathToBinary(const char *name);\n bool IsPathSeparator(const char c);\n bool IsAbsolutePath(const char *path);\n+// Starts a subprocess and returs its pid.\n+// If *_fd parameters are not kInvalidFd their corresponding input/output\n+// streams will be redirect to the file. The files will always be closed\n+// in parent process even in case of an error.\n+// The child process will close all fds after STDERR_FILENO\n+// before passing control to a program.\n+pid_t StartSubprocess(const char *filename, const char *const argv[],\n+                      fd_t stdin_fd = kInvalidFd, fd_t stdout_fd = kInvalidFd,\n+                      fd_t stderr_fd = kInvalidFd);\n+// Checks if specified process is still running\n+bool IsProcessRunning(pid_t pid);\n+// Waits for the process to finish and returns its exit code.\n+// Returns -1 in case of an error.\n+int WaitForProcess(pid_t pid);\n \n u32 GetUid();\n void ReExec();\n+char **GetArgv();\n+void PrintCmdline();\n bool StackSizeIsUnlimited();\n+uptr GetStackSizeLimitInBytes();\n void SetStackSizeLimitInBytes(uptr limit);\n bool AddressSpaceIsUnlimited();\n void SetAddressSpaceUnlimited();\n@@ -299,6 +331,7 @@ void SleepForMillis(int millis);\n u64 NanoTime();\n int Atexit(void (*function)(void));\n void SortArray(uptr *array, uptr size);\n+void SortArray(u32 *array, uptr size);\n bool TemplateMatch(const char *templ, const char *str);\n \n // Exit\n@@ -307,7 +340,8 @@ void NORETURN Die();\n void NORETURN\n CheckFailed(const char *file, int line, const char *cond, u64 v1, u64 v2);\n void NORETURN ReportMmapFailureAndDie(uptr size, const char *mem_type,\n-                                      const char *mmap_type, error_t err);\n+                                      const char *mmap_type, error_t err,\n+                                      bool raw_report = false);\n \n // Set the name of the current thread to 'name', return true on succees.\n // The name may be truncated to a system-dependent limit.\n@@ -339,9 +373,15 @@ void SetCheckFailedCallback(CheckFailedCallbackType callback);\n // The callback should be registered once at the tool init time.\n void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded));\n \n+// Callback to be called when we want to try releasing unused allocator memory\n+// back to the OS.\n+typedef void (*AllocatorReleaseToOSCallback)();\n+// The callback should be registered once at the tool init time.\n+void SetAllocatorReleaseToOSCallback(AllocatorReleaseToOSCallback Callback);\n+\n // Functions related to signal handling.\n typedef void (*SignalHandlerType)(int, void *, void *);\n-bool IsDeadlySignal(int signum);\n+bool IsHandledDeadlySignal(int signum);\n void InstallDeadlySignalHandlers(SignalHandlerType handler);\n // Alternative signal stack (POSIX-only).\n void SetAlternateSignalStack();\n@@ -357,7 +397,7 @@ void ReportErrorSummary(const char *error_message);\n //   error_type file:line[:column][ function]\n void ReportErrorSummary(const char *error_type, const AddressInfo &info);\n // Same as above, but obtains AddressInfo by symbolizing top stack trace frame.\n-void ReportErrorSummary(const char *error_type, StackTrace *trace);\n+void ReportErrorSummary(const char *error_type, const StackTrace *trace);\n \n // Math\n #if SANITIZER_WINDOWS && !defined(__clang__) && !defined(__GNUC__)\n@@ -414,13 +454,13 @@ INLINE uptr RoundUpToPowerOfTwo(uptr size) {\n   if (IsPowerOfTwo(size)) return size;\n \n   uptr up = MostSignificantSetBitIndex(size);\n-  CHECK(size < (1ULL << (up + 1)));\n-  CHECK(size > (1ULL << up));\n+  CHECK_LT(size, (1ULL << (up + 1)));\n+  CHECK_GT(size, (1ULL << up));\n   return 1ULL << (up + 1);\n }\n \n INLINE uptr RoundUpTo(uptr size, uptr boundary) {\n-  CHECK(IsPowerOfTwo(boundary));\n+  RAW_CHECK(IsPowerOfTwo(boundary));\n   return (size + boundary - 1) & ~(boundary - 1);\n }\n \n@@ -487,7 +527,7 @@ class InternalMmapVectorNoCtor {\n       uptr new_capacity = RoundUpToPowerOfTwo(size_ + 1);\n       Resize(new_capacity);\n     }\n-    data_[size_++] = element;\n+    internal_memcpy(&data_[size_++], &element, sizeof(T));\n   }\n   T &back() {\n     CHECK_GT(size_, 0);\n@@ -513,6 +553,19 @@ class InternalMmapVectorNoCtor {\n   void clear() { size_ = 0; }\n   bool empty() const { return size() == 0; }\n \n+  const T *begin() const {\n+    return data();\n+  }\n+  T *begin() {\n+    return data();\n+  }\n+  const T *end() const {\n+    return data() + size();\n+  }\n+  T *end() {\n+    return data() + size();\n+  }\n+\n  private:\n   void Resize(uptr new_capacity) {\n     CHECK_GT(new_capacity, 0);\n@@ -619,22 +672,41 @@ class LoadedModule {\n         : next(nullptr), beg(beg), end(end), executable(executable) {}\n   };\n \n-  typedef IntrusiveList<AddressRange>::ConstIterator Iterator;\n-  Iterator ranges() const { return Iterator(&ranges_); }\n+  const IntrusiveList<AddressRange> &ranges() const { return ranges_; }\n \n  private:\n   char *full_name_;  // Owned.\n   uptr base_address_;\n   IntrusiveList<AddressRange> ranges_;\n };\n \n-// OS-dependent function that fills array with descriptions of at most\n-// \"max_modules\" currently loaded modules. Returns the number of\n-// initialized modules. If filter is nonzero, ignores modules for which\n-// filter(full_name) is false.\n-typedef bool (*string_predicate_t)(const char *);\n-uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n-                      string_predicate_t filter);\n+// List of LoadedModules. OS-dependent implementation is responsible for\n+// filling this information.\n+class ListOfModules {\n+ public:\n+  ListOfModules() : modules_(kInitialCapacity) {}\n+  ~ListOfModules() { clear(); }\n+  void init();\n+  const LoadedModule *begin() const { return modules_.begin(); }\n+  LoadedModule *begin() { return modules_.begin(); }\n+  const LoadedModule *end() const { return modules_.end(); }\n+  LoadedModule *end() { return modules_.end(); }\n+  uptr size() const { return modules_.size(); }\n+  const LoadedModule &operator[](uptr i) const {\n+    CHECK_LT(i, modules_.size());\n+    return modules_[i];\n+  }\n+\n+ private:\n+  void clear() {\n+    for (auto &module : modules_) module.clear();\n+    modules_.clear();\n+  }\n+\n+  InternalMmapVector<LoadedModule> modules_;\n+  // We rarely have more than 16K loaded modules.\n+  static const uptr kInitialCapacity = 1 << 14;\n+};\n \n // Callback type for iterating over a set of memory ranges.\n typedef void (*RangeIteratorCallback)(uptr begin, uptr end, void *arg);\n@@ -646,22 +718,34 @@ enum AndroidApiLevel {\n   ANDROID_POST_LOLLIPOP = 23\n };\n \n+void WriteToSyslog(const char *buffer);\n+\n+#if SANITIZER_MAC\n+void LogFullErrorReport(const char *buffer);\n+#else\n+INLINE void LogFullErrorReport(const char *buffer) {}\n+#endif\n+\n+#if SANITIZER_LINUX || SANITIZER_MAC\n+void WriteOneLineToSyslog(const char *s);\n+void LogMessageOnPrintf(const char *str);\n+#else\n+INLINE void WriteOneLineToSyslog(const char *s) {}\n+INLINE void LogMessageOnPrintf(const char *str) {}\n+#endif\n+\n #if SANITIZER_LINUX\n // Initialize Android logging. Any writes before this are silently lost.\n void AndroidLogInit();\n-void WriteToSyslog(const char *buffer);\n #else\n INLINE void AndroidLogInit() {}\n-INLINE void WriteToSyslog(const char *buffer) {}\n #endif\n \n #if SANITIZER_ANDROID\n-void GetExtraActivationFlags(char *buf, uptr size);\n void SanitizerInitializeUnwinder();\n AndroidApiLevel AndroidGetApiLevel();\n #else\n INLINE void AndroidLogWrite(const char *buffer_unused) {}\n-INLINE void GetExtraActivationFlags(char *buf, uptr size) { *buf = '\\0'; }\n INLINE void SanitizerInitializeUnwinder() {}\n INLINE AndroidApiLevel AndroidGetApiLevel() { return ANDROID_NOT_ANDROID; }\n #endif\n@@ -686,7 +770,7 @@ void MaybeStartBackgroudThread();\n // compiler from recognising it and turning it into an actual call to\n // memset/memcpy/etc.\n static inline void SanitizerBreakOptimization(void *arg) {\n-#if _MSC_VER && !defined(__clang__)\n+#if defined(_MSC_VER) && !defined(__clang__)\n   _ReadWriteBarrier();\n #else\n   __asm__ __volatile__(\"\" : : \"r\" (arg) : \"memory\");\n@@ -699,27 +783,68 @@ struct SignalContext {\n   uptr pc;\n   uptr sp;\n   uptr bp;\n+  bool is_memory_access;\n \n-  SignalContext(void *context, uptr addr, uptr pc, uptr sp, uptr bp) :\n-      context(context), addr(addr), pc(pc), sp(sp), bp(bp) {\n-  }\n+  enum WriteFlag { UNKNOWN, READ, WRITE } write_flag;\n+\n+  SignalContext(void *context, uptr addr, uptr pc, uptr sp, uptr bp,\n+                bool is_memory_access, WriteFlag write_flag)\n+      : context(context),\n+        addr(addr),\n+        pc(pc),\n+        sp(sp),\n+        bp(bp),\n+        is_memory_access(is_memory_access),\n+        write_flag(write_flag) {}\n \n   // Creates signal context in a platform-specific manner.\n   static SignalContext Create(void *siginfo, void *context);\n+\n+  // Returns true if the \"context\" indicates a memory write.\n+  static WriteFlag GetWriteFlag(void *context);\n };\n \n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp);\n \n-}  // namespace __sanitizer\n+void MaybeReexec();\n \n-inline void *operator new(__sanitizer::operator_new_size_type size,\n-                          __sanitizer::LowLevelAllocator &alloc) {\n-  return alloc.Allocate(size);\n+template <typename Fn>\n+class RunOnDestruction {\n+ public:\n+  explicit RunOnDestruction(Fn fn) : fn_(fn) {}\n+  ~RunOnDestruction() { fn_(); }\n+\n+ private:\n+  Fn fn_;\n+};\n+\n+// A simple scope guard. Usage:\n+// auto cleanup = at_scope_exit([]{ do_cleanup; });\n+template <typename Fn>\n+RunOnDestruction<Fn> at_scope_exit(Fn fn) {\n+  return RunOnDestruction<Fn>(fn);\n }\n \n+// Linux on 64-bit s390 had a nasty bug that crashes the whole machine\n+// if a process uses virtual memory over 4TB (as many sanitizers like\n+// to do).  This function will abort the process if running on a kernel\n+// that looks vulnerable.\n+#if SANITIZER_LINUX && SANITIZER_S390_64\n+void AvoidCVE_2016_2143();\n+#else\n+INLINE void AvoidCVE_2016_2143() {}\n+#endif\n+\n struct StackDepotStats {\n   uptr n_uniq_ids;\n   uptr allocated;\n };\n \n+}  // namespace __sanitizer\n+\n+inline void *operator new(__sanitizer::operator_new_size_type size,\n+                          __sanitizer::LowLevelAllocator &alloc) {\n+  return alloc.Allocate(size);\n+}\n+\n #endif  // SANITIZER_COMMON_H"}, {"sha": "38390ed9621564b81ae1d95180287cb8f6b152cc", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors.inc", "status": "modified", "additions": 791, "deletions": 175, "changes": 966, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "a68534c5a0a98b5983ba63b9c7466643e78893f0", "filename": "libsanitizer/sanitizer_common/sanitizer_common_interceptors_ioctl.inc", "status": "modified", "additions": 21, "deletions": 17, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_interceptors_ioctl.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -51,25 +51,9 @@ static void ioctl_table_fill() {\n   _(FIONBIO, READ, sizeof(int));\n   _(FIONCLEX, NONE, 0);\n   _(FIOSETOWN, READ, sizeof(int));\n-  _(SIOCADDMULTI, READ, struct_ifreq_sz);\n   _(SIOCATMARK, WRITE, sizeof(int));\n-  _(SIOCDELMULTI, READ, struct_ifreq_sz);\n-  _(SIOCGIFADDR, WRITE, struct_ifreq_sz);\n-  _(SIOCGIFBRDADDR, WRITE, struct_ifreq_sz);\n   _(SIOCGIFCONF, CUSTOM, 0);\n-  _(SIOCGIFDSTADDR, WRITE, struct_ifreq_sz);\n-  _(SIOCGIFFLAGS, WRITE, struct_ifreq_sz);\n-  _(SIOCGIFMETRIC, WRITE, struct_ifreq_sz);\n-  _(SIOCGIFMTU, WRITE, struct_ifreq_sz);\n-  _(SIOCGIFNETMASK, WRITE, struct_ifreq_sz);\n   _(SIOCGPGRP, WRITE, sizeof(int));\n-  _(SIOCSIFADDR, READ, struct_ifreq_sz);\n-  _(SIOCSIFBRDADDR, READ, struct_ifreq_sz);\n-  _(SIOCSIFDSTADDR, READ, struct_ifreq_sz);\n-  _(SIOCSIFFLAGS, READ, struct_ifreq_sz);\n-  _(SIOCSIFMETRIC, READ, struct_ifreq_sz);\n-  _(SIOCSIFMTU, READ, struct_ifreq_sz);\n-  _(SIOCSIFNETMASK, READ, struct_ifreq_sz);\n   _(SIOCSPGRP, READ, sizeof(int));\n   _(TIOCCONS, NONE, 0);\n   _(TIOCEXCL, NONE, 0);\n@@ -90,6 +74,25 @@ static void ioctl_table_fill() {\n   _(TIOCSTI, READ, sizeof(char));\n   _(TIOCSWINSZ, READ, struct_winsize_sz);\n \n+#if !SANITIZER_IOS\n+  _(SIOCADDMULTI, READ, struct_ifreq_sz);\n+  _(SIOCDELMULTI, READ, struct_ifreq_sz);\n+  _(SIOCGIFADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFBRDADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFDSTADDR, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFFLAGS, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMETRIC, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFMTU, WRITE, struct_ifreq_sz);\n+  _(SIOCGIFNETMASK, WRITE, struct_ifreq_sz);\n+  _(SIOCSIFADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFBRDADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFDSTADDR, READ, struct_ifreq_sz);\n+  _(SIOCSIFFLAGS, READ, struct_ifreq_sz);\n+  _(SIOCSIFMETRIC, READ, struct_ifreq_sz);\n+  _(SIOCSIFMTU, READ, struct_ifreq_sz);\n+  _(SIOCSIFNETMASK, READ, struct_ifreq_sz);\n+#endif\n+\n #if (SANITIZER_LINUX && !SANITIZER_ANDROID)\n   _(SIOCGETSGCNT, WRITE, struct_sioc_sg_req_sz);\n   _(SIOCGETVIFCNT, WRITE, struct_sioc_vif_req_sz);\n@@ -578,7 +581,8 @@ static void ioctl_common_pre(void *ctx, const ioctl_desc *desc, int d,\n     return;\n   if (request == IOCTL_SIOCGIFCONF) {\n     struct __sanitizer_ifconf *ifc = (__sanitizer_ifconf *)arg;\n-    COMMON_INTERCEPTOR_READ_RANGE(ctx, &ifc->ifc_len, sizeof(ifc->ifc_len));\n+    COMMON_INTERCEPTOR_READ_RANGE(ctx, (char*)&ifc->ifc_len,\n+                                  sizeof(ifc->ifc_len));\n   }\n }\n "}, {"sha": "8c9fa98f835f4aa4ee1f284f2f73d403fe758453", "filename": "libsanitizer/sanitizer_common/sanitizer_common_libcdep.cc", "status": "modified", "additions": 49, "deletions": 6, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -10,6 +10,8 @@\n //===----------------------------------------------------------------------===//\n \n #include \"sanitizer_common.h\"\n+\n+#include \"sanitizer_allocator_interface.h\"\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_stackdepot.h\"\n #include \"sanitizer_stacktrace.h\"\n@@ -43,7 +45,8 @@ void SetSandboxingCallback(void (*f)()) {\n   sandboxing_callback = f;\n }\n \n-void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n+void ReportErrorSummary(const char *error_type, const StackTrace *stack) {\n+#if !SANITIZER_GO\n   if (!common_flags()->print_summary)\n     return;\n   if (stack->size == 0) {\n@@ -56,6 +59,7 @@ void ReportErrorSummary(const char *error_type, StackTrace *stack) {\n   SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n   ReportErrorSummary(error_type, frame->info);\n   frame->ClearAll();\n+#endif\n }\n \n static void (*SoftRssLimitExceededCallback)(bool exceeded);\n@@ -64,12 +68,22 @@ void SetSoftRssLimitExceededCallback(void (*Callback)(bool exceeded)) {\n   SoftRssLimitExceededCallback = Callback;\n }\n \n+static AllocatorReleaseToOSCallback ReleseCallback;\n+void SetAllocatorReleaseToOSCallback(AllocatorReleaseToOSCallback Callback) {\n+  CHECK_EQ(ReleseCallback, nullptr);\n+  ReleseCallback = Callback;\n+}\n+\n+#if SANITIZER_LINUX && !SANITIZER_GO\n void BackgroundThread(void *arg) {\n   uptr hard_rss_limit_mb = common_flags()->hard_rss_limit_mb;\n   uptr soft_rss_limit_mb = common_flags()->soft_rss_limit_mb;\n+  bool heap_profile = common_flags()->heap_profile;\n+  bool allocator_release_to_os = common_flags()->allocator_release_to_os;\n   uptr prev_reported_rss = 0;\n   uptr prev_reported_stack_depot_size = 0;\n   bool reached_soft_rss_limit = false;\n+  uptr rss_during_last_reported_profile = 0;\n   while (true) {\n     SleepForMillis(100);\n     uptr current_rss_mb = GetRSS() >> 20;\n@@ -111,14 +125,43 @@ void BackgroundThread(void *arg) {\n           SoftRssLimitExceededCallback(false);\n       }\n     }\n+    if (allocator_release_to_os && ReleseCallback) ReleseCallback();\n+    if (heap_profile &&\n+        current_rss_mb > rss_during_last_reported_profile * 1.1) {\n+      Printf(\"\\n\\nHEAP PROFILE at RSS %zdMb\\n\", current_rss_mb);\n+      __sanitizer_print_memory_profile(90);\n+      rss_during_last_reported_profile = current_rss_mb;\n+    }\n   }\n }\n+#endif\n+\n+void WriteToSyslog(const char *msg) {\n+  InternalScopedString msg_copy(kErrorMessageBufferSize);\n+  msg_copy.append(\"%s\", msg);\n+  char *p = msg_copy.data();\n+  char *q;\n+\n+  // Print one line at a time.\n+  // syslog, at least on Android, has an implicit message length limit.\n+  do {\n+    q = internal_strchr(p, '\\n');\n+    if (q)\n+      *q = '\\0';\n+    WriteOneLineToSyslog(p);\n+    if (q)\n+      p = q + 1;\n+  } while (q);\n+}\n \n void MaybeStartBackgroudThread() {\n-#if SANITIZER_LINUX  // Need to implement/test on other platforms.\n+#if SANITIZER_LINUX && \\\n+    !SANITIZER_GO  // Need to implement/test on other platforms.\n   // Start the background thread if one of the rss limits is given.\n   if (!common_flags()->hard_rss_limit_mb &&\n-      !common_flags()->soft_rss_limit_mb) return;\n+      !common_flags()->soft_rss_limit_mb &&\n+      !common_flags()->allocator_release_to_os &&\n+      !common_flags()->heap_profile) return;\n   if (!&real_pthread_create) return;  // Can't spawn the thread anyway.\n   internal_start_thread(BackgroundThread, nullptr);\n #endif\n@@ -128,7 +171,7 @@ void MaybeStartBackgroudThread() {\n \n void NOINLINE\n __sanitizer_sandbox_on_notify(__sanitizer_sandbox_arguments *args) {\n-  PrepareForSandboxing(args);\n-  if (sandboxing_callback)\n-    sandboxing_callback();\n+  __sanitizer::PrepareForSandboxing(args);\n+  if (__sanitizer::sandboxing_callback)\n+    __sanitizer::sandboxing_callback();\n }"}, {"sha": "6fd5ef74274ce6bd35c0731d84737415a4e03c8d", "filename": "libsanitizer/sanitizer_common/sanitizer_common_syscalls.inc", "status": "modified", "additions": 44, "deletions": 14, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_common_syscalls.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -1235,17 +1235,15 @@ POST_SYSCALL(fcntl64)(long res, long fd, long cmd, long arg) {}\n PRE_SYSCALL(pipe)(void *fildes) {}\n \n POST_SYSCALL(pipe)(long res, void *fildes) {\n-  if (res >= 0) {\n-    if (fildes) POST_WRITE(fildes, sizeof(int));\n-  }\n+  if (res >= 0)\n+    if (fildes) POST_WRITE(fildes, sizeof(int) * 2);\n }\n \n PRE_SYSCALL(pipe2)(void *fildes, long flags) {}\n \n POST_SYSCALL(pipe2)(long res, void *fildes, long flags) {\n-  if (res >= 0) {\n-    if (fildes) POST_WRITE(fildes, sizeof(int));\n-  }\n+  if (res >= 0)\n+    if (fildes) POST_WRITE(fildes, sizeof(int) * 2);\n }\n \n PRE_SYSCALL(dup)(long fildes) {}\n@@ -1878,13 +1876,11 @@ PRE_SYSCALL(socket)(long arg0, long arg1, long arg2) {}\n \n POST_SYSCALL(socket)(long res, long arg0, long arg1, long arg2) {}\n \n-PRE_SYSCALL(socketpair)(long arg0, long arg1, long arg2, void *arg3) {}\n+PRE_SYSCALL(socketpair)(long arg0, long arg1, long arg2, int *sv) {}\n \n-POST_SYSCALL(socketpair)(long res, long arg0, long arg1, long arg2,\n-                         void *arg3) {\n-  if (res >= 0) {\n-    if (arg3) POST_WRITE(arg3, sizeof(int));\n-  }\n+POST_SYSCALL(socketpair)(long res, long arg0, long arg1, long arg2, int *sv) {\n+  if (res >= 0)\n+    if (sv) POST_WRITE(sv, sizeof(int) * 2);\n }\n \n PRE_SYSCALL(socketcall)(long call, void *args) {}\n@@ -2299,7 +2295,7 @@ POST_SYSCALL(ni_syscall)(long res) {}\n PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n #if !SANITIZER_ANDROID && \\\n     (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-     defined(__powerpc64__) || defined(__aarch64__))\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__))\n   if (data) {\n     if (request == ptrace_setregs) {\n       PRE_READ((void *)data, struct_user_regs_struct_sz);\n@@ -2320,7 +2316,7 @@ PRE_SYSCALL(ptrace)(long request, long pid, long addr, long data) {\n POST_SYSCALL(ptrace)(long res, long request, long pid, long addr, long data) {\n #if !SANITIZER_ANDROID && \\\n     (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-     defined(__powerpc64__) || defined(__aarch64__))\n+     defined(__powerpc64__) || defined(__aarch64__) || defined(__s390__))\n   if (res >= 0 && data) {\n     // Note that this is different from the interceptor in\n     // sanitizer_common_interceptors.inc.\n@@ -2842,6 +2838,40 @@ PRE_SYSCALL(vfork)() {\n POST_SYSCALL(vfork)(long res) {\n   COMMON_SYSCALL_POST_FORK(res);\n }\n+\n+PRE_SYSCALL(sigaction)(long signum, const __sanitizer_kernel_sigaction_t *act,\n+                       __sanitizer_kernel_sigaction_t *oldact) {\n+  if (act) {\n+    PRE_READ(&act->sigaction, sizeof(act->sigaction));\n+    PRE_READ(&act->sa_flags, sizeof(act->sa_flags));\n+    PRE_READ(&act->sa_mask, sizeof(act->sa_mask));\n+  }\n+}\n+\n+POST_SYSCALL(sigaction)(long res, long signum,\n+                        const __sanitizer_kernel_sigaction_t *act,\n+                        __sanitizer_kernel_sigaction_t *oldact) {\n+  if (res >= 0 && oldact) POST_WRITE(oldact, sizeof(*oldact));\n+}\n+\n+PRE_SYSCALL(rt_sigaction)(long signum,\n+                          const __sanitizer_kernel_sigaction_t *act,\n+                          __sanitizer_kernel_sigaction_t *oldact, SIZE_T sz) {\n+  if (act) {\n+    PRE_READ(&act->sigaction, sizeof(act->sigaction));\n+    PRE_READ(&act->sa_flags, sizeof(act->sa_flags));\n+    PRE_READ(&act->sa_mask, sz);\n+  }\n+}\n+\n+POST_SYSCALL(rt_sigaction)(long res, long signum,\n+                           const __sanitizer_kernel_sigaction_t *act,\n+                           __sanitizer_kernel_sigaction_t *oldact, SIZE_T sz) {\n+  if (res >= 0 && oldact) {\n+    SIZE_T oldact_sz = ((char *)&oldact->sa_mask) - ((char *)oldact) + sz;\n+    POST_WRITE(oldact, oldact_sz);\n+  }\n+}\n }  // extern \"C\"\n \n #undef PRE_SYSCALL"}, {"sha": "dd8620beaac0a9b945127e047b4000ef3baa89af", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_libcdep.cc", "status": "modified", "additions": 124, "deletions": 37, "changes": 161, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -45,8 +45,12 @@\n #include \"sanitizer_symbolizer.h\"\n #include \"sanitizer_flags.h\"\n \n+using namespace __sanitizer;\n+\n static const u64 kMagic64 = 0xC0BFFFFFFFFFFF64ULL;\n static const u64 kMagic32 = 0xC0BFFFFFFFFFFF32ULL;\n+static const uptr kNumWordsForMagic = SANITIZER_WORDSIZE == 64 ? 1 : 2;\n+static const u64 kMagic = SANITIZER_WORDSIZE == 64 ? kMagic64 : kMagic32;\n \n static atomic_uint32_t dump_once_guard;  // Ensure that CovDump runs only once.\n \n@@ -94,7 +98,7 @@ class CoverageData {\n   void DumpAll();\n \n   ALWAYS_INLINE\n-  void TraceBasicBlock(s32 *id);\n+  void TraceBasicBlock(u32 *id);\n \n   void InitializeGuardArray(s32 *guards);\n   void InitializeGuards(s32 *guards, uptr n, const char *module_name,\n@@ -105,17 +109,23 @@ class CoverageData {\n   uptr Update8bitCounterBitsetAndClearCounters(u8 *bitset);\n \n   uptr *data();\n-  uptr size();\n+  uptr size() const;\n \n  private:\n+  struct NamedPcRange {\n+    const char *copied_module_name;\n+    uptr beg, end; // elements [beg,end) in pc_array.\n+  };\n+\n   void DirectOpen();\n   void UpdateModuleNameVec(uptr caller_pc, uptr range_beg, uptr range_end);\n+  void GetRangeOffsets(const NamedPcRange& r, Symbolizer* s,\n+      InternalMmapVector<uptr>* offsets) const;\n \n   // Maximal size pc array may ever grow.\n   // We MmapNoReserve this space to ensure that the array is contiguous.\n-  static const uptr kPcArrayMaxSize = FIRST_32_SECOND_64(\n-      1 << (SANITIZER_ANDROID ? 24 : (SANITIZER_WINDOWS ? 27 : 26)),\n-      1 << 27);\n+  static const uptr kPcArrayMaxSize =\n+      FIRST_32_SECOND_64(1 << (SANITIZER_ANDROID ? 24 : 26), 1 << 27);\n   // The amount file mapping for the pc array is grown by.\n   static const uptr kPcArrayMmapSize = 64 * 1024;\n \n@@ -134,11 +144,6 @@ class CoverageData {\n   // Vector of coverage guard arrays, protected by mu.\n   InternalMmapVectorNoCtor<s32*> guard_array_vec;\n \n-  struct NamedPcRange {\n-    const char *copied_module_name;\n-    uptr beg, end; // elements [beg,end) in pc_array.\n-  };\n-\n   // Vector of module and compilation unit pc ranges.\n   InternalMmapVectorNoCtor<NamedPcRange> comp_unit_name_vec;\n   InternalMmapVectorNoCtor<NamedPcRange> module_name_vec;\n@@ -510,7 +515,7 @@ uptr *CoverageData::data() {\n   return pc_array;\n }\n \n-uptr CoverageData::size() {\n+uptr CoverageData::size() const {\n   return atomic_load(&pc_array_index, memory_order_relaxed);\n }\n \n@@ -680,11 +685,11 @@ void CoverageData::DumpCallerCalleePairs() {\n // it once and then cache in the provided 'cache' storage.\n //\n // This function will eventually be inlined by the compiler.\n-void CoverageData::TraceBasicBlock(s32 *id) {\n+void CoverageData::TraceBasicBlock(u32 *id) {\n   // Will trap here if\n   //  1. coverage is not enabled at run-time.\n   //  2. The array tr_event_array is full.\n-  *tr_event_pointer = static_cast<u32>(*id - 1);\n+  *tr_event_pointer = *id - 1;\n   tr_event_pointer++;\n }\n \n@@ -740,41 +745,96 @@ void CoverageData::DumpAsBitSet() {\n   }\n }\n \n+\n+void CoverageData::GetRangeOffsets(const NamedPcRange& r, Symbolizer* sym,\n+    InternalMmapVector<uptr>* offsets) const {\n+  offsets->clear();\n+  for (uptr i = 0; i < kNumWordsForMagic; i++)\n+    offsets->push_back(0);\n+  CHECK(r.copied_module_name);\n+  CHECK_LE(r.beg, r.end);\n+  CHECK_LE(r.end, size());\n+  for (uptr i = r.beg; i < r.end; i++) {\n+    uptr pc = UnbundlePc(pc_array[i]);\n+    uptr counter = UnbundleCounter(pc_array[i]);\n+    if (!pc) continue; // Not visited.\n+    uptr offset = 0;\n+    sym->GetModuleNameAndOffsetForPC(pc, nullptr, &offset);\n+    offsets->push_back(BundlePcAndCounter(offset, counter));\n+  }\n+\n+  CHECK_GE(offsets->size(), kNumWordsForMagic);\n+  SortArray(offsets->data(), offsets->size());\n+  for (uptr i = 0; i < offsets->size(); i++)\n+    (*offsets)[i] = UnbundlePc((*offsets)[i]);\n+}\n+\n+static void GenerateHtmlReport(const InternalMmapVector<char *> &cov_files) {\n+  if (!common_flags()->html_cov_report) {\n+    return;\n+  }\n+  char *sancov_path = FindPathToBinary(common_flags()->sancov_path);\n+  if (sancov_path == nullptr) {\n+    return;\n+  }\n+\n+  InternalMmapVector<char *> sancov_argv(cov_files.size() * 2 + 3);\n+  sancov_argv.push_back(sancov_path);\n+  sancov_argv.push_back(internal_strdup(\"-html-report\"));\n+  auto argv_deleter = at_scope_exit([&] {\n+    for (uptr i = 0; i < sancov_argv.size(); ++i) {\n+      InternalFree(sancov_argv[i]);\n+    }\n+  });\n+\n+  for (const auto &cov_file : cov_files) {\n+    sancov_argv.push_back(internal_strdup(cov_file));\n+  }\n+\n+  {\n+    ListOfModules modules;\n+    modules.init();\n+    for (const LoadedModule &module : modules) {\n+      sancov_argv.push_back(internal_strdup(module.full_name()));\n+    }\n+  }\n+\n+  InternalScopedString report_path(kMaxPathLength);\n+  fd_t report_fd =\n+      CovOpenFile(&report_path, false /* packed */, GetProcessName(), \"html\");\n+  int pid = StartSubprocess(sancov_argv[0], sancov_argv.data(),\n+                            kInvalidFd /* stdin */, report_fd /* std_out */);\n+  if (pid > 0) {\n+    int result = WaitForProcess(pid);\n+    if (result == 0)\n+      Printf(\"coverage report generated to %s\\n\", report_path.data());\n+  }\n+}\n+\n void CoverageData::DumpOffsets() {\n   auto sym = Symbolizer::GetOrInit();\n   if (!common_flags()->coverage_pcs) return;\n   CHECK_NE(sym, nullptr);\n   InternalMmapVector<uptr> offsets(0);\n   InternalScopedString path(kMaxPathLength);\n-  for (uptr m = 0; m < module_name_vec.size(); m++) {\n-    offsets.clear();\n-    uptr num_words_for_magic = SANITIZER_WORDSIZE == 64 ? 1 : 2;\n-    for (uptr i = 0; i < num_words_for_magic; i++)\n-      offsets.push_back(0);\n-    auto r = module_name_vec[m];\n-    CHECK(r.copied_module_name);\n-    CHECK_LE(r.beg, r.end);\n-    CHECK_LE(r.end, size());\n-    for (uptr i = r.beg; i < r.end; i++) {\n-      uptr pc = UnbundlePc(pc_array[i]);\n-      uptr counter = UnbundleCounter(pc_array[i]);\n-      if (!pc) continue; // Not visited.\n-      uptr offset = 0;\n-      sym->GetModuleNameAndOffsetForPC(pc, nullptr, &offset);\n-      offsets.push_back(BundlePcAndCounter(offset, counter));\n+\n+  InternalMmapVector<char *> cov_files(module_name_vec.size());\n+  auto cov_files_deleter = at_scope_exit([&] {\n+    for (uptr i = 0; i < cov_files.size(); ++i) {\n+      InternalFree(cov_files[i]);\n     }\n+  });\n \n-    CHECK_GE(offsets.size(), num_words_for_magic);\n-    SortArray(offsets.data(), offsets.size());\n-    for (uptr i = 0; i < offsets.size(); i++)\n-      offsets[i] = UnbundlePc(offsets[i]);\n+  for (uptr m = 0; m < module_name_vec.size(); m++) {\n+    auto r = module_name_vec[m];\n+    GetRangeOffsets(r, sym, &offsets);\n \n-    uptr num_offsets = offsets.size() - num_words_for_magic;\n+    uptr num_offsets = offsets.size() - kNumWordsForMagic;\n     u64 *magic_p = reinterpret_cast<u64*>(offsets.data());\n     CHECK_EQ(*magic_p, 0ULL);\n     // FIXME: we may want to write 32-bit offsets even in 64-mode\n     // if all the offsets are small enough.\n-    *magic_p = SANITIZER_WORDSIZE == 64 ? kMagic64 : kMagic32;\n+    *magic_p = kMagic;\n \n     const char *module_name = StripModuleName(r.copied_module_name);\n     if (cov_sandboxed) {\n@@ -789,11 +849,14 @@ void CoverageData::DumpOffsets() {\n       if (fd == kInvalidFd) continue;\n       WriteToFile(fd, offsets.data(), offsets.size() * sizeof(offsets[0]));\n       CloseFile(fd);\n+      cov_files.push_back(internal_strdup(path.data()));\n       VReport(1, \" CovDump: %s: %zd PCs written\\n\", path.data(), num_offsets);\n     }\n   }\n   if (cov_fd != kInvalidFd)\n     CloseFile(cov_fd);\n+\n+  GenerateHtmlReport(cov_files);\n }\n \n void CoverageData::DumpAll() {\n@@ -918,11 +981,13 @@ uptr __sanitizer_get_total_unique_caller_callee_pairs() {\n }\n \n SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_cov_trace_func_enter(s32 *id) {\n+void __sanitizer_cov_trace_func_enter(u32 *id) {\n+  __sanitizer_cov_with_check(id);\n   coverage_data.TraceBasicBlock(id);\n }\n SANITIZER_INTERFACE_ATTRIBUTE\n-void __sanitizer_cov_trace_basic_block(s32 *id) {\n+void __sanitizer_cov_trace_basic_block(u32 *id) {\n+  __sanitizer_cov_with_check(id);\n   coverage_data.TraceBasicBlock(id);\n }\n SANITIZER_INTERFACE_ATTRIBUTE\n@@ -949,8 +1014,30 @@ uptr __sanitizer_update_counter_bitset_and_clear_counters(u8 *bitset) {\n   return coverage_data.Update8bitCounterBitsetAndClearCounters(bitset);\n }\n // Default empty implementations (weak). Users should redefine them.\n+#if !SANITIZER_WINDOWS  // weak does not work on Windows.\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void __sanitizer_cov_trace_cmp() {}\n SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_cmp1() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_cmp2() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_cmp4() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_cmp8() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void __sanitizer_cov_trace_switch() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_div4() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_div8() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_gep() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_pc_guard() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_pc_indir() {}\n+SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n+void __sanitizer_cov_trace_pc_guard_init() {}\n+#endif  // !SANITIZER_WINDOWS\n } // extern \"C\""}, {"sha": "b2e724ab221a8a3aa56d2c7ec15bde8f71a4fe4b", "filename": "libsanitizer/sanitizer_common/sanitizer_coverage_mapping_libcdep.cc", "status": "modified", "additions": 9, "deletions": 14, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_coverage_mapping_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -70,26 +70,21 @@ void CovUpdateMapping(const char *coverage_dir, uptr caller_pc) {\n   InternalScopedString text(kMaxTextSize);\n \n   {\n-    InternalScopedBuffer<LoadedModule> modules(kMaxNumberOfModules);\n-    CHECK(modules.data());\n-    int n_modules = GetListOfModules(modules.data(), kMaxNumberOfModules,\n-                                     /* filter */ nullptr);\n-\n     text.append(\"%d\\n\", sizeof(uptr) * 8);\n-    for (int i = 0; i < n_modules; ++i) {\n-      const char *module_name = StripModuleName(modules[i].full_name());\n-      uptr base = modules[i].base_address();\n-      for (auto iter = modules[i].ranges(); iter.hasNext();) {\n-        const auto *range = iter.next();\n-        if (range->executable) {\n-          uptr start = range->beg;\n-          uptr end = range->end;\n+    ListOfModules modules;\n+    modules.init();\n+    for (const LoadedModule &module : modules) {\n+      const char *module_name = StripModuleName(module.full_name());\n+      uptr base = module.base_address();\n+      for (const auto &range : module.ranges()) {\n+        if (range.executable) {\n+          uptr start = range.beg;\n+          uptr end = range.end;\n           text.append(\"%zx %zx %zx %s\\n\", start, end, base, module_name);\n           if (caller_pc && caller_pc >= start && caller_pc < end)\n             cached_mapping.SetModuleRange(start, end);\n         }\n       }\n-      modules[i].clear();\n     }\n   }\n "}, {"sha": "e2aedc24da9e2f3acba0be48aeb10548bc197137", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector1.cc", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector1.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -117,11 +117,16 @@ void DD::MutexBeforeLock(DDCallback *cb,\n \n void DD::ReportDeadlock(DDCallback *cb, DDMutex *m) {\n   DDLogicalThread *lt = cb->lt;\n-  uptr path[10];\n+  uptr path[20];\n   uptr len = dd.findPathToLock(&lt->dd, m->id, path, ARRAY_SIZE(path));\n-  CHECK_GT(len, 0U);  // Hm.. cycle of 10 locks? I'd like to see that.\n+  if (len == 0U) {\n+    // A cycle of 20+ locks? Well, that's a bit odd...\n+    Printf(\"WARNING: too long mutex cycle found\\n\");\n+    return;\n+  }\n   CHECK_EQ(m->id, path[0]);\n   lt->report_pending = true;\n+  len = Min<uptr>(len, DDReport::kMaxLoopSize);\n   DDReport *rep = &lt->rep;\n   rep->n = len;\n   for (uptr i = 0; i < len; i++) {"}, {"sha": "f8da20612dbdb10494f6049de873f1bff63628e5", "filename": "libsanitizer/sanitizer_common/sanitizer_deadlock_detector_interface.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_deadlock_detector_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -49,7 +49,7 @@ struct DDFlags {\n };\n \n struct DDReport {\n-  enum { kMaxLoopSize = 8 };\n+  enum { kMaxLoopSize = 20 };\n   int n;  // number of entries in loop\n   struct {\n     u64 thr_ctx;   // user thread context"}, {"sha": "5f69e58ffb27222a04b42870ffb40c88fbb6a4fb", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.cc", "status": "modified", "additions": 42, "deletions": 14, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -28,11 +28,6 @@ struct FlagDescription {\n \n IntrusiveList<FlagDescription> flag_descriptions;\n \n-// If set, the tool will install its own SEGV signal handler by default.\n-#ifndef SANITIZER_NEEDS_SEGV\n-# define SANITIZER_NEEDS_SEGV 1\n-#endif\n-\n void CommonFlags::SetDefaults() {\n #define COMMON_FLAG(Type, Name, DefaultValue, Description) Name = DefaultValue;\n #include \"sanitizer_flags.inc\"\n@@ -43,17 +38,44 @@ void CommonFlags::CopyFrom(const CommonFlags &other) {\n   internal_memcpy(this, &other, sizeof(*this));\n }\n \n-// Copy the string from \"s\" to \"out\", replacing \"%b\" with the binary basename.\n-static void SubstituteBinaryName(const char *s, char *out, uptr out_size) {\n+// Copy the string from \"s\" to \"out\", making the following substitutions:\n+// %b = binary basename\n+// %p = pid\n+void SubstituteForFlagValue(const char *s, char *out, uptr out_size) {\n   char *out_end = out + out_size;\n   while (*s && out < out_end - 1) {\n-    if (s[0] != '%' || s[1] != 'b') { *out++ = *s++; continue; }\n-    const char *base = GetProcessName();\n-    CHECK(base);\n-    while (*base && out < out_end - 1)\n-      *out++ = *base++;\n-    s += 2; // skip \"%b\"\n+    if (s[0] != '%') {\n+      *out++ = *s++;\n+      continue;\n+    }\n+    switch (s[1]) {\n+      case 'b': {\n+        const char *base = GetProcessName();\n+        CHECK(base);\n+        while (*base && out < out_end - 1)\n+          *out++ = *base++;\n+        s += 2; // skip \"%b\"\n+        break;\n+      }\n+      case 'p': {\n+        int pid = internal_getpid();\n+        char buf[32];\n+        char *buf_pos = buf + 32;\n+        do {\n+          *--buf_pos = (pid % 10) + '0';\n+          pid /= 10;\n+        } while (pid);\n+        while (buf_pos < buf + 32 && out < out_end - 1)\n+          *out++ = *buf_pos++;\n+        s += 2; // skip \"%p\"\n+        break;\n+      }\n+      default:\n+        *out++ = *s++;\n+        break;\n+    }\n   }\n+  CHECK(out < out_end - 1);\n   *out = '\\0';\n }\n \n@@ -67,7 +89,7 @@ class FlagHandlerInclude : public FlagHandlerBase {\n   bool Parse(const char *value) final {\n     if (internal_strchr(value, '%')) {\n       char *buf = (char *)MmapOrDie(kMaxPathLength, \"FlagHandlerInclude\");\n-      SubstituteBinaryName(value, buf, kMaxPathLength);\n+      SubstituteForFlagValue(value, buf, kMaxPathLength);\n       bool res = parser_->ParseFile(buf, ignore_missing_);\n       UnmapOrDie(buf, kMaxPathLength);\n       return res;\n@@ -97,4 +119,10 @@ void RegisterCommonFlags(FlagParser *parser, CommonFlags *cf) {\n   RegisterIncludeFlags(parser, cf);\n }\n \n+void InitializeCommonFlags(CommonFlags *cf) {\n+  // need to record coverage to generate coverage report.\n+  cf->coverage |= cf->html_cov_report;\n+  SetVerbosity(cf->verbosity);\n+}\n+\n }  // namespace __sanitizer"}, {"sha": "ff64af10ff5ae8e1e16fd7a7367e7e5acff14436", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -44,10 +44,17 @@ inline void OverrideCommonFlags(const CommonFlags &cf) {\n   common_flags_dont_use.CopyFrom(cf);\n }\n \n+void SubstituteForFlagValue(const char *s, char *out, uptr out_size);\n+\n class FlagParser;\n void RegisterCommonFlags(FlagParser *parser,\n                          CommonFlags *cf = &common_flags_dont_use);\n void RegisterIncludeFlags(FlagParser *parser, CommonFlags *cf);\n+\n+// Should be called after parsing all flags. Sets up common flag values\n+// and perform initializations common to all sanitizers (e.g. setting\n+// verbosity).\n+void InitializeCommonFlags(CommonFlags *cf = &common_flags_dont_use);\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_FLAGS_H"}, {"sha": "ccc0e416f4a6f4e42ef884d8a0ab0ee09e5ad2d2", "filename": "libsanitizer/sanitizer_common/sanitizer_flags.inc", "status": "modified", "additions": 42, "deletions": 7, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_flags.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -54,7 +54,7 @@ COMMON_FLAG(\n     \"Mention name of executable when reporting error and \"\n     \"append executable name to logs (as in \\\"log_path.exe_name.pid\\\").\")\n COMMON_FLAG(\n-    bool, log_to_syslog, SANITIZER_ANDROID,\n+    bool, log_to_syslog, SANITIZER_ANDROID || SANITIZER_MAC,\n     \"Write all sanitizer output to syslog in addition to other means of \"\n     \"logging.\")\n COMMON_FLAG(\n@@ -73,10 +73,12 @@ COMMON_FLAG(bool, print_summary, true,\n             \"If false, disable printing error summaries in addition to error \"\n             \"reports.\")\n COMMON_FLAG(bool, check_printf, true, \"Check printf arguments.\")\n-COMMON_FLAG(bool, handle_segv, SANITIZER_NEEDS_SEGV,\n+COMMON_FLAG(bool, handle_segv, true,\n             \"If set, registers the tool's custom SIGSEGV/SIGBUS handler.\")\n COMMON_FLAG(bool, handle_abort, false,\n             \"If set, registers the tool's custom SIGABRT handler.\")\n+COMMON_FLAG(bool, handle_sigill, false,\n+            \"If set, registers the tool's custom SIGILL handler.\")\n COMMON_FLAG(bool, handle_sigfpe, true,\n             \"If set, registers the tool's custom SIGFPE handler.\")\n COMMON_FLAG(bool, allow_user_segv_handler, false,\n@@ -114,6 +116,10 @@ COMMON_FLAG(uptr, soft_rss_limit_mb, 0,\n             \" until the RSS goes below the soft limit.\"\n             \" This limit does not affect memory allocations other than\"\n             \" malloc/new.\")\n+COMMON_FLAG(bool, heap_profile, false, \"Experimental heap profiler, asan-only\")\n+COMMON_FLAG(bool, allocator_release_to_os, false,\n+            \"Experimental. If true, try to periodically release unused\"\n+            \" memory to the OS.\\n\")\n COMMON_FLAG(bool, can_use_proc_maps_statm, true,\n             \"If false, do not attempt to read /proc/maps/statm.\"\n             \" Mostly useful for testing sanitizers.\")\n@@ -146,10 +152,10 @@ COMMON_FLAG(bool, full_address_space, false,\n COMMON_FLAG(bool, print_suppressions, true,\n             \"Print matched suppressions at exit.\")\n COMMON_FLAG(\n-    bool, disable_coredump, (SANITIZER_WORDSIZE == 64),\n-    \"Disable core dumping. By default, disable_core=1 on 64-bit to avoid \"\n-    \"dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n-    \"default and for sanitizers that don't reserve lots of virtual memory.\")\n+    bool, disable_coredump, (SANITIZER_WORDSIZE == 64) && !SANITIZER_GO,\n+    \"Disable core dumping. By default, disable_coredump=1 on 64-bit to avoid\"\n+    \" dumping a 16T+ core file. Ignored on OSes that don't dump core by\"\n+    \" default and for sanitizers that don't reserve lots of virtual memory.\")\n COMMON_FLAG(bool, use_madv_dontdump, true,\n           \"If set, instructs kernel to not store the (huge) shadow \"\n           \"in core file.\")\n@@ -158,6 +164,11 @@ COMMON_FLAG(bool, symbolize_inline_frames, true,\n COMMON_FLAG(bool, symbolize_vs_style, false,\n             \"Print file locations in Visual Studio style (e.g: \"\n             \" file(10,42): ...\")\n+COMMON_FLAG(int, dedup_token_length, 0,\n+            \"If positive, after printing a stack trace also print a short \"\n+            \"string token based on this number of frames that will simplify \"\n+            \"deduplication of the reports. \"\n+            \"Example: 'DEDUP_TOKEN: foo-bar-main'. Default is 0.\")\n COMMON_FLAG(const char *, stack_trace_format, \"DEFAULT\",\n             \"Format string used to render stack frames. \"\n             \"See sanitizer_stacktrace_printer.h for the format description. \"\n@@ -175,18 +186,42 @@ COMMON_FLAG(bool, intercept_strspn, true,\n COMMON_FLAG(bool, intercept_strpbrk, true,\n             \"If set, uses custom wrappers for strpbrk function \"\n             \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strlen, true,\n+            \"If set, uses custom wrappers for strlen and strnlen functions \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_strchr, true,\n+            \"If set, uses custom wrappers for strchr, strchrnul, and strrchr \"\n+            \"functions to find more errors.\")\n COMMON_FLAG(bool, intercept_memcmp, true,\n             \"If set, uses custom wrappers for memcmp function \"\n             \"to find more errors.\")\n COMMON_FLAG(bool, strict_memcmp, true,\n           \"If true, assume that memcmp(p1, p2, n) always reads n bytes before \"\n           \"comparing p1 and p2.\")\n+COMMON_FLAG(bool, intercept_memmem, true,\n+            \"If set, uses a wrapper for memmem() to find more errors.\")\n+COMMON_FLAG(bool, intercept_intrin, true,\n+            \"If set, uses custom wrappers for memset/memcpy/memmove \"\n+            \"intrinsics to find more errors.\")\n+COMMON_FLAG(bool, intercept_stat, true,\n+            \"If set, uses custom wrappers for *stat functions \"\n+            \"to find more errors.\")\n+COMMON_FLAG(bool, intercept_send, true,\n+            \"If set, uses custom wrappers for send* functions \"\n+            \"to find more errors.\")\n COMMON_FLAG(bool, decorate_proc_maps, false, \"If set, decorate sanitizer \"\n                                              \"mappings in /proc/self/maps with \"\n                                              \"user-readable names\")\n COMMON_FLAG(int, exitcode, 1, \"Override the program exit status if the tool \"\n                               \"found an error\")\n COMMON_FLAG(\n-    bool, abort_on_error, SANITIZER_MAC,\n+    bool, abort_on_error, SANITIZER_ANDROID || SANITIZER_MAC,\n     \"If set, the tool calls abort() instead of _exit() after printing the \"\n     \"error report.\")\n+COMMON_FLAG(bool, suppress_equal_pcs, true,\n+            \"Deduplicate multiple reports for single source location in \"\n+            \"halt_on_error=false mode (asan only).\")\n+COMMON_FLAG(bool, print_cmdline, false, \"Print command line on crash \"\n+            \"(asan only).\")\n+COMMON_FLAG(bool, html_cov_report, false, \"Generate html coverage report.\")\n+COMMON_FLAG(const char *, sancov_path, \"sancov\", \"Sancov tool location.\")"}, {"sha": "34e80c3b50f8b56dc7a3d0b0954b001c85827680", "filename": "libsanitizer/sanitizer_common/sanitizer_interface_internal.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_interface_internal.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -23,6 +23,10 @@ extern \"C\" {\n   // The special values are \"stdout\" and \"stderr\".\n   SANITIZER_INTERFACE_ATTRIBUTE\n   void __sanitizer_set_report_path(const char *path);\n+  // Tell the tools to write their reports to the provided file descriptor\n+  // (casted to void *).\n+  SANITIZER_INTERFACE_ATTRIBUTE\n+  void __sanitizer_set_report_fd(void *fd);\n \n   typedef struct {\n       int coverage_sandboxed;"}, {"sha": "b9c906669deef97287547d647eef13bebcd1b611", "filename": "libsanitizer/sanitizer_common/sanitizer_internal_defs.h", "status": "modified", "additions": 42, "deletions": 11, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_internal_defs.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -22,15 +22,15 @@\n # define SANITIZER_INTERFACE_ATTRIBUTE __declspec(dllexport)\n // FIXME find out what we need on Windows, if anything.\n # define SANITIZER_WEAK_ATTRIBUTE\n-#elif defined(SANITIZER_GO)\n+#elif SANITIZER_GO\n # define SANITIZER_INTERFACE_ATTRIBUTE\n # define SANITIZER_WEAK_ATTRIBUTE\n #else\n # define SANITIZER_INTERFACE_ATTRIBUTE __attribute__((visibility(\"default\")))\n # define SANITIZER_WEAK_ATTRIBUTE  __attribute__((weak))\n #endif\n \n-#if (SANITIZER_LINUX || SANITIZER_WINDOWS) && !defined(SANITIZER_GO)\n+#if (SANITIZER_LINUX || SANITIZER_WINDOWS) && !SANITIZER_GO\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 1\n #else\n # define SANITIZER_SUPPORTS_WEAK_HOOKS 0\n@@ -87,6 +87,7 @@ typedef unsigned error_t;\n typedef int fd_t;\n typedef int error_t;\n #endif\n+typedef int pid_t;\n \n // WARNING: OFF_T may be different from OS type off_t, depending on the value of\n // _FILE_OFFSET_BITS. This definition of OFF_T matches the ABI of system calls\n@@ -103,19 +104,25 @@ typedef u64  OFF64_T;\n #if (SANITIZER_WORDSIZE == 64) || SANITIZER_MAC\n typedef uptr operator_new_size_type;\n #else\n+# if defined(__s390__) && !defined(__s390x__)\n+// Special case: 31-bit s390 has unsigned long as size_t.\n+typedef unsigned long operator_new_size_type;\n+# else\n typedef u32 operator_new_size_type;\n+# endif\n #endif\n-}  // namespace __sanitizer\n \n \n-using namespace __sanitizer;  // NOLINT\n // ----------- ATTENTION -------------\n // This header should NOT include any other headers to avoid portability issues.\n \n // Common defs.\n #define INLINE inline\n #define INTERFACE_ATTRIBUTE SANITIZER_INTERFACE_ATTRIBUTE\n-#define WEAK SANITIZER_WEAK_ATTRIBUTE\n+#define SANITIZER_WEAK_DEFAULT_IMPL \\\n+  extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n+#define SANITIZER_WEAK_CXX_DEFAULT_IMPL \\\n+  extern \"C++\" SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE NOINLINE\n \n // Platform-specific defs.\n #if defined(_MSC_VER)\n@@ -129,7 +136,7 @@ using namespace __sanitizer;  // NOLINT\n # define THREADLOCAL   __declspec(thread)\n # define LIKELY(x) (x)\n # define UNLIKELY(x) (x)\n-# define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */\n+# define PREFETCH(x) /* _mm_prefetch(x, _MM_HINT_NTA) */ (void)0\n #else  // _MSC_VER\n # define ALWAYS_INLINE inline __attribute__((always_inline))\n # define ALIAS(x) __attribute__((alias(x)))\n@@ -173,7 +180,9 @@ typedef ALIGNED(1) s32 us32;\n typedef ALIGNED(1) s64 us64;\n \n #if SANITIZER_WINDOWS\n+}  // namespace __sanitizer\n typedef unsigned long DWORD;  // NOLINT\n+namespace __sanitizer {\n typedef DWORD thread_return_t;\n # define THREAD_CALLING_CONV __stdcall\n #else  // _WIN32\n@@ -183,14 +192,12 @@ typedef void* thread_return_t;\n typedef thread_return_t (THREAD_CALLING_CONV *thread_callback_t)(void* arg);\n \n // NOTE: Functions below must be defined in each run-time.\n-namespace __sanitizer {\n void NORETURN Die();\n \n // FIXME: No, this shouldn't be in the sanitizer interface.\n SANITIZER_INTERFACE_ATTRIBUTE\n void NORETURN CheckFailed(const char *file, int line, const char *cond,\n                           u64 v1, u64 v2);\n-}  // namespace __sanitizer\n \n // Check macro\n #define RAW_CHECK_MSG(expr, msg) do { \\\n@@ -282,14 +289,23 @@ enum LinkerInitialized { LINKER_INITIALIZED = 0 };\n #if !defined(_MSC_VER) || defined(__clang__)\n # define GET_CALLER_PC() (uptr)__builtin_return_address(0)\n # define GET_CURRENT_FRAME() (uptr)__builtin_frame_address(0)\n+inline void Trap() {\n+  __builtin_trap();\n+}\n #else\n extern \"C\" void* _ReturnAddress(void);\n+extern \"C\" void* _AddressOfReturnAddress(void);\n # pragma intrinsic(_ReturnAddress)\n+# pragma intrinsic(_AddressOfReturnAddress)\n # define GET_CALLER_PC() (uptr)_ReturnAddress()\n // CaptureStackBackTrace doesn't need to know BP on Windows.\n-// FIXME: This macro is still used when printing error reports though it's not\n-// clear if the BP value is needed in the ASan reports on Windows.\n-# define GET_CURRENT_FRAME() (uptr)0xDEADBEEF\n+# define GET_CURRENT_FRAME() (((uptr)_AddressOfReturnAddress()) + sizeof(uptr))\n+\n+extern \"C\" void __ud2(void);\n+# pragma intrinsic(__ud2)\n+inline void Trap() {\n+  __ud2();\n+}\n #endif\n \n #define HANDLE_EINTR(res, f)                                       \\\n@@ -308,4 +324,19 @@ extern \"C\" void* _ReturnAddress(void);\n     (void)enable_fp;                                               \\\n   } while (0)\n \n+}  // namespace __sanitizer\n+\n+namespace __asan  { using namespace __sanitizer; }  // NOLINT\n+namespace __dsan  { using namespace __sanitizer; }  // NOLINT\n+namespace __dfsan { using namespace __sanitizer; }  // NOLINT\n+namespace __esan  { using namespace __sanitizer; }  // NOLINT\n+namespace __lsan  { using namespace __sanitizer; }  // NOLINT\n+namespace __msan  { using namespace __sanitizer; }  // NOLINT\n+namespace __tsan  { using namespace __sanitizer; }  // NOLINT\n+namespace __scudo { using namespace __sanitizer; }  // NOLINT\n+namespace __ubsan { using namespace __sanitizer; }  // NOLINT\n+namespace __xray  { using namespace __sanitizer; }  // NOLINT\n+namespace __interception  { using namespace __sanitizer; }  // NOLINT\n+\n+\n #endif  // SANITIZER_DEFS_H"}, {"sha": "82d37675e479421afed9704ab06963918c510076", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.cc", "status": "modified", "additions": 31, "deletions": 1, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -72,7 +72,7 @@ void *internal_memmove(void *dest, const void *src, uptr n) {\n \n // Semi-fast bzero for 16-aligned data. Still far from peak performance.\n void internal_bzero_aligned16(void *s, uptr n) {\n-  struct S16 { u64 a, b; } ALIGNED(16);\n+  struct ALIGNED(16) S16 { u64 a, b; };\n   CHECK_EQ((reinterpret_cast<uptr>(s) | n) & 15, 0);\n   for (S16 *p = reinterpret_cast<S16*>(s), *end = p + n / 16; p < end; p++) {\n     p->a = p->b = 0;\n@@ -173,6 +173,19 @@ uptr internal_strlen(const char *s) {\n   return i;\n }\n \n+uptr internal_strlcat(char *dst, const char *src, uptr maxlen) {\n+  const uptr srclen = internal_strlen(src);\n+  const uptr dstlen = internal_strnlen(dst, maxlen);\n+  if (dstlen == maxlen) return maxlen + srclen;\n+  if (srclen < maxlen - dstlen) {\n+    internal_memmove(dst + dstlen, src, srclen + 1);\n+  } else {\n+    internal_memmove(dst + dstlen, src, maxlen - dstlen - 1);\n+    dst[maxlen - 1] = '\\0';\n+  }\n+  return dstlen + srclen;\n+}\n+\n char *internal_strncat(char *dst, const char *src, uptr n) {\n   uptr len = internal_strlen(dst);\n   uptr i;\n@@ -182,6 +195,17 @@ char *internal_strncat(char *dst, const char *src, uptr n) {\n   return dst;\n }\n \n+uptr internal_strlcpy(char *dst, const char *src, uptr maxlen) {\n+  const uptr srclen = internal_strlen(src);\n+  if (srclen < maxlen) {\n+    internal_memmove(dst, src, srclen + 1);\n+  } else if (maxlen != 0) {\n+    internal_memmove(dst, src, maxlen - 1);\n+    dst[maxlen - 1] = '\\0';\n+  }\n+  return srclen;\n+}\n+\n char *internal_strncpy(char *dst, const char *src, uptr n) {\n   uptr i;\n   for (i = 0; i < n && src[i]; i++)\n@@ -208,6 +232,12 @@ char *internal_strstr(const char *haystack, const char *needle) {\n   return nullptr;\n }\n \n+uptr internal_wcslen(const wchar_t *s) {\n+  uptr i = 0;\n+  while (s[i]) i++;\n+  return i;\n+}\n+\n s64 internal_simple_strtoll(const char *nptr, char **endptr, int base) {\n   CHECK_EQ(base, 10);\n   while (IsSpace(*nptr)) nptr++;"}, {"sha": "d26ec8704c0832daebb9333b283b34427e358f2a", "filename": "libsanitizer/sanitizer_common/sanitizer_libc.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_libc.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -41,12 +41,15 @@ uptr internal_strcspn(const char *s, const char *reject);\n char *internal_strdup(const char *s);\n char *internal_strndup(const char *s, uptr n);\n uptr internal_strlen(const char *s);\n+uptr internal_strlcat(char *dst, const char *src, uptr maxlen);\n char *internal_strncat(char *dst, const char *src, uptr n);\n int internal_strncmp(const char *s1, const char *s2, uptr n);\n+uptr internal_strlcpy(char *dst, const char *src, uptr maxlen);\n char *internal_strncpy(char *dst, const char *src, uptr n);\n uptr internal_strnlen(const char *s, uptr maxlen);\n char *internal_strrchr(const char *s, int c);\n // This is O(N^2), but we are not using it in hot places.\n+uptr internal_wcslen(const wchar_t *s);\n char *internal_strstr(const char *haystack, const char *needle);\n // Works only for base=10 and doesn't set errno.\n s64 internal_simple_strtoll(const char *nptr, char **endptr, int base);\n@@ -57,15 +60,18 @@ int internal_snprintf(char *buffer, uptr length, const char *format, ...);\n bool mem_is_zero(const char *mem, uptr size);\n \n // I/O\n-const fd_t kInvalidFd = (fd_t)-1;\n-const fd_t kStdinFd = 0;\n-const fd_t kStdoutFd = (fd_t)1;\n-const fd_t kStderrFd = (fd_t)2;\n+// Define these as macros so we can use them in linker initialized global\n+// structs without dynamic initialization.\n+#define kInvalidFd ((fd_t)-1)\n+#define kStdinFd ((fd_t)0)\n+#define kStdoutFd ((fd_t)1)\n+#define kStderrFd ((fd_t)2)\n \n uptr internal_ftruncate(fd_t fd, uptr size);\n \n // OS\n void NORETURN internal__exit(int exitcode);\n+unsigned int internal_sleep(unsigned int seconds);\n \n uptr internal_getpid();\n uptr internal_getppid();"}, {"sha": "806fcd5e2847945124cfd9f8b422a590d655dd42", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.cc", "status": "modified", "additions": 267, "deletions": 16, "changes": 283, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -58,7 +58,10 @@\n #include <unistd.h>\n \n #if SANITIZER_FREEBSD\n+#include <sys/exec.h>\n #include <sys/sysctl.h>\n+#include <vm/vm_param.h>\n+#include <vm/pmap.h>\n #include <machine/atomic.h>\n extern \"C\" {\n // <sys/umtx.h> must be included after <errno.h> and <sys/types.h> on\n@@ -87,12 +90,19 @@ const int FUTEX_WAKE = 1;\n // Are we using 32-bit or 64-bit Linux syscalls?\n // x32 (which defines __x86_64__) has SANITIZER_WORDSIZE == 32\n // but it still needs to use 64-bit syscalls.\n-#if SANITIZER_LINUX && (defined(__x86_64__) || SANITIZER_WORDSIZE == 64)\n+#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__powerpc64__) || \\\n+    SANITIZER_WORDSIZE == 64)\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 1\n #else\n # define SANITIZER_LINUX_USES_64BIT_SYSCALLS 0\n #endif\n \n+#if defined(__x86_64__) || SANITIZER_MIPS64\n+extern \"C\" {\n+extern void internal_sigreturn();\n+}\n+#endif\n+\n namespace __sanitizer {\n \n #if SANITIZER_LINUX && defined(__x86_64__)\n@@ -104,6 +114,7 @@ namespace __sanitizer {\n #endif\n \n // --------------- sanitizer_libc.h\n+#if !SANITIZER_S390\n uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n                    OFF_T offset) {\n #if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n@@ -116,6 +127,7 @@ uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n                           offset / 4096);\n #endif\n }\n+#endif // !SANITIZER_S390\n \n uptr internal_munmap(void *addr, uptr length) {\n   return internal_syscall(SYSCALL(munmap), (uptr)addr, length);\n@@ -238,7 +250,15 @@ uptr internal_lstat(const char *path, void *buf) {\n   return internal_syscall(SYSCALL(newfstatat), AT_FDCWD, (uptr)path,\n                          (uptr)buf, AT_SYMLINK_NOFOLLOW);\n #elif SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+# if SANITIZER_MIPS64\n+  // For mips64, lstat syscall fills buffer in the format of kernel_stat\n+  struct kernel_stat kbuf;\n+  int res = internal_syscall(SYSCALL(lstat), path, &kbuf);\n+  kernel_stat_to_stat(&kbuf, (struct stat *)buf);\n+  return res;\n+# else\n   return internal_syscall(SYSCALL(lstat), (uptr)path, (uptr)buf);\n+# endif\n #else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(lstat64), path, &buf64);\n@@ -249,7 +269,15 @@ uptr internal_lstat(const char *path, void *buf) {\n \n uptr internal_fstat(fd_t fd, void *buf) {\n #if SANITIZER_FREEBSD || SANITIZER_LINUX_USES_64BIT_SYSCALLS\n+# if SANITIZER_MIPS64\n+  // For mips64, fstat syscall fills buffer in the format of kernel_stat\n+  struct kernel_stat kbuf;\n+  int res = internal_syscall(SYSCALL(fstat), fd, &kbuf);\n+  kernel_stat_to_stat(&kbuf, (struct stat *)buf);\n+  return res;\n+# else\n   return internal_syscall(SYSCALL(fstat), fd, (uptr)buf);\n+# endif\n #else\n   struct stat64 buf64;\n   int res = internal_syscall(SYSCALL(fstat64), fd, &buf64);\n@@ -312,6 +340,15 @@ void internal__exit(int exitcode) {\n   Die();  // Unreachable.\n }\n \n+unsigned int internal_sleep(unsigned int seconds) {\n+  struct timespec ts;\n+  ts.tv_sec = 1;\n+  ts.tv_nsec = 0;\n+  int res = internal_syscall(SYSCALL(nanosleep), &ts, &ts);\n+  if (res) return ts.tv_sec;\n+  return 0;\n+}\n+\n uptr internal_execve(const char *filename, char *const argv[],\n                      char *const envp[]) {\n   return internal_syscall(SYSCALL(execve), (uptr)filename, (uptr)argv,\n@@ -392,11 +429,13 @@ const char *GetEnv(const char *name) {\n #endif\n }\n \n+#if !SANITIZER_FREEBSD\n extern \"C\" {\n   SANITIZER_WEAK_ATTRIBUTE extern void *__libc_stack_end;\n }\n+#endif\n \n-#if !SANITIZER_GO\n+#if !SANITIZER_GO && !SANITIZER_FREEBSD\n static void ReadNullSepFileToArray(const char *path, char ***arr,\n                                    int arr_size) {\n   char *buff;\n@@ -421,7 +460,8 @@ static void ReadNullSepFileToArray(const char *path, char ***arr,\n }\n #endif\n \n-static void GetArgsAndEnv(char*** argv, char*** envp) {\n+static void GetArgsAndEnv(char ***argv, char ***envp) {\n+#if !SANITIZER_FREEBSD\n #if !SANITIZER_GO\n   if (&__libc_stack_end) {\n #endif\n@@ -436,6 +476,25 @@ static void GetArgsAndEnv(char*** argv, char*** envp) {\n     ReadNullSepFileToArray(\"/proc/self/environ\", envp, kMaxEnvp);\n   }\n #endif\n+#else\n+  // On FreeBSD, retrieving the argument and environment arrays is done via the\n+  // kern.ps_strings sysctl, which returns a pointer to a structure containing\n+  // this information. See also <sys/exec.h>.\n+  ps_strings *pss;\n+  size_t sz = sizeof(pss);\n+  if (sysctlbyname(\"kern.ps_strings\", &pss, &sz, NULL, 0) == -1) {\n+    Printf(\"sysctl kern.ps_strings failed\\n\");\n+    Die();\n+  }\n+  *argv = pss->ps_argvstr;\n+  *envp = pss->ps_envstr;\n+#endif\n+}\n+\n+char **GetArgv() {\n+  char **argv, **envp;\n+  GetArgsAndEnv(&argv, &envp);\n+  return argv;\n }\n \n void ReExec() {\n@@ -561,7 +620,8 @@ int internal_fork() {\n \n #if SANITIZER_LINUX\n #define SA_RESTORER 0x04000000\n-// Doesn't set sa_restorer, use with caution (see below).\n+// Doesn't set sa_restorer if the caller did not set it, so use with caution\n+//(see below).\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n   __sanitizer_kernel_sigaction_t k_act, k_oldact;\n   internal_memset(&k_act, 0, sizeof(__sanitizer_kernel_sigaction_t));\n@@ -583,7 +643,9 @@ int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n     // rt_sigaction, so we need to do the same (we'll need to reimplement the\n     // restorers; for x86_64 the restorer address can be obtained from\n     // oldact->sa_restorer upon a call to sigaction(xxx, NULL, oldact).\n+#if !SANITIZER_ANDROID || !SANITIZER_MIPS32\n     k_act.sa_restorer = u_act->sa_restorer;\n+#endif\n   }\n \n   uptr result = internal_syscall(SYSCALL(rt_sigaction), (uptr)signum,\n@@ -597,10 +659,31 @@ int internal_sigaction_norestorer(int signum, const void *act, void *oldact) {\n     internal_memcpy(&u_oldact->sa_mask, &k_oldact.sa_mask,\n                     sizeof(__sanitizer_kernel_sigset_t));\n     u_oldact->sa_flags = k_oldact.sa_flags;\n+#if !SANITIZER_ANDROID || !SANITIZER_MIPS32\n     u_oldact->sa_restorer = k_oldact.sa_restorer;\n+#endif\n   }\n   return result;\n }\n+\n+// Invokes sigaction via a raw syscall with a restorer, but does not support\n+// all platforms yet.\n+// We disable for Go simply because we have not yet added to buildgo.sh.\n+#if (defined(__x86_64__) || SANITIZER_MIPS64) && !SANITIZER_GO\n+int internal_sigaction_syscall(int signum, const void *act, void *oldact) {\n+  if (act == nullptr)\n+    return internal_sigaction_norestorer(signum, act, oldact);\n+  __sanitizer_sigaction u_adjust;\n+  internal_memcpy(&u_adjust, act, sizeof(u_adjust));\n+#if !SANITIZER_ANDROID || !SANITIZER_MIPS32\n+    if (u_adjust.sa_restorer == nullptr) {\n+      u_adjust.sa_restorer = internal_sigreturn;\n+    }\n+#endif\n+    return internal_sigaction_norestorer(signum, (const void *)&u_adjust,\n+                                         oldact);\n+}\n+#endif // defined(__x86_64__) && !SANITIZER_GO\n #endif  // SANITIZER_LINUX\n \n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n@@ -620,6 +703,10 @@ void internal_sigfillset(__sanitizer_sigset_t *set) {\n   internal_memset(set, 0xff, sizeof(*set));\n }\n \n+void internal_sigemptyset(__sanitizer_sigset_t *set) {\n+  internal_memset(set, 0, sizeof(*set));\n+}\n+\n #if SANITIZER_LINUX\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n   signum -= 1;\n@@ -630,6 +717,16 @@ void internal_sigdelset(__sanitizer_sigset_t *set, int signum) {\n   const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n   k_set->sig[idx] &= ~(1 << bit);\n }\n+\n+bool internal_sigismember(__sanitizer_sigset_t *set, int signum) {\n+  signum -= 1;\n+  CHECK_GE(signum, 0);\n+  CHECK_LT(signum, sizeof(*set) * 8);\n+  __sanitizer_kernel_sigset_t *k_set = (__sanitizer_kernel_sigset_t *)set;\n+  const uptr idx = signum / (sizeof(k_set->sig[0]) * 8);\n+  const uptr bit = signum % (sizeof(k_set->sig[0]) * 8);\n+  return k_set->sig[idx] & (1 << bit);\n+}\n #endif  // SANITIZER_LINUX\n \n // ThreadLister implementation.\n@@ -701,7 +798,10 @@ bool ThreadLister::GetDirectoryEntries() {\n }\n \n uptr GetPageSize() {\n-#if SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n+// Android post-M sysconf(_SC_PAGESIZE) crashes if called from .preinit_array.\n+#if SANITIZER_ANDROID\n+  return 4096;\n+#elif SANITIZER_LINUX && (defined(__x86_64__) || defined(__i386__))\n   return EXEC_PAGESIZE;\n #else\n   return sysconf(_SC_PAGESIZE);  // EXEC_PAGESIZE may not be trustworthy.\n@@ -908,8 +1008,18 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        \"bnez $2,1f;\\n\"\n \n                        /* Call \"fn(arg)\". */\n+#if SANITIZER_WORDSIZE == 32\n+#ifdef __BIG_ENDIAN__\n+                       \"lw $25,4($29);\\n\"\n+                       \"lw $4,12($29);\\n\"\n+#else\n+                       \"lw $25,0($29);\\n\"\n+                       \"lw $4,8($29);\\n\"\n+#endif\n+#else\n                        \"ld $25,0($29);\\n\"\n                        \"ld $4,8($29);\\n\"\n+#endif\n                        \"jal $25;\\n\"\n \n                        /* Call _exit($v0). */\n@@ -981,18 +1091,91 @@ uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                        : \"x30\", \"memory\");\n   return res;\n }\n-#endif  // defined(__x86_64__) && SANITIZER_LINUX\n+#elif defined(__powerpc64__)\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                   int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  long long res;\n+/* Stack frame offsets.  */\n+#if _CALL_ELF != 2\n+#define FRAME_MIN_SIZE         112\n+#define FRAME_TOC_SAVE         40\n+#else\n+#define FRAME_MIN_SIZE         32\n+#define FRAME_TOC_SAVE         24\n+#endif\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  child_stack = (char *)child_stack - 2 * sizeof(unsigned long long);\n+  ((unsigned long long *)child_stack)[0] = (uptr)fn;\n+  ((unsigned long long *)child_stack)[1] = (uptr)arg;\n \n-#if SANITIZER_ANDROID\n-#define PROP_VALUE_MAX 92\n-extern \"C\" SANITIZER_WEAK_ATTRIBUTE int __system_property_get(const char *name,\n-                                                              char *value);\n-void GetExtraActivationFlags(char *buf, uptr size) {\n-  CHECK(size > PROP_VALUE_MAX);\n-  CHECK(&__system_property_get);\n-  __system_property_get(\"asan.options\", buf);\n+  register int (*__fn)(void *) __asm__(\"r3\") = fn;\n+  register void *__cstack      __asm__(\"r4\") = child_stack;\n+  register int __flags         __asm__(\"r5\") = flags;\n+  register void * __arg        __asm__(\"r6\") = arg;\n+  register int * __ptidptr     __asm__(\"r7\") = parent_tidptr;\n+  register void * __newtls     __asm__(\"r8\") = newtls;\n+  register int * __ctidptr     __asm__(\"r9\") = child_tidptr;\n+\n+ __asm__ __volatile__(\n+           /* fn, arg, child_stack are saved acrVoss the syscall */\n+           \"mr 28, %5\\n\\t\"\n+           \"mr 29, %6\\n\\t\"\n+           \"mr 27, %8\\n\\t\"\n+\n+           /* syscall\n+             r3 == flags\n+             r4 == child_stack\n+             r5 == parent_tidptr\n+             r6 == newtls\n+             r7 == child_tidptr */\n+           \"mr 3, %7\\n\\t\"\n+           \"mr 5, %9\\n\\t\"\n+           \"mr 6, %10\\n\\t\"\n+           \"mr 7, %11\\n\\t\"\n+           \"li 0, %3\\n\\t\"\n+           \"sc\\n\\t\"\n+\n+           /* Test if syscall was successful */\n+           \"cmpdi  cr1, 3, 0\\n\\t\"\n+           \"crandc cr1*4+eq, cr1*4+eq, cr0*4+so\\n\\t\"\n+           \"bne-   cr1, 1f\\n\\t\"\n+\n+           /* Do the function call */\n+           \"std   2, %13(1)\\n\\t\"\n+#if _CALL_ELF != 2\n+           \"ld    0, 0(28)\\n\\t\"\n+           \"ld    2, 8(28)\\n\\t\"\n+           \"mtctr 0\\n\\t\"\n+#else\n+           \"mr    12, 28\\n\\t\"\n+           \"mtctr 12\\n\\t\"\n+#endif\n+           \"mr    3, 27\\n\\t\"\n+           \"bctrl\\n\\t\"\n+           \"ld    2, %13(1)\\n\\t\"\n+\n+           /* Call _exit(r3) */\n+           \"li 0, %4\\n\\t\"\n+           \"sc\\n\\t\"\n+\n+           /* Return to parent */\n+           \"1:\\n\\t\"\n+           \"mr %0, 3\\n\\t\"\n+             : \"=r\" (res)\n+             : \"0\" (-1), \"i\" (EINVAL),\n+               \"i\" (__NR_clone), \"i\" (__NR_exit),\n+               \"r\" (__fn), \"r\" (__cstack), \"r\" (__flags),\n+               \"r\" (__arg), \"r\" (__ptidptr), \"r\" (__newtls),\n+               \"r\" (__ctidptr), \"i\" (FRAME_MIN_SIZE), \"i\" (FRAME_TOC_SAVE)\n+             : \"cr0\", \"cr1\", \"memory\", \"ctr\",\n+               \"r0\", \"r29\", \"r27\", \"r28\");\n+  return res;\n }\n+#endif  // defined(__x86_64__) && SANITIZER_LINUX\n \n+#if SANITIZER_ANDROID\n #if __ANDROID_API__ < 21\n extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n     int (*)(struct dl_phdr_info *, size_t, void *), void *);\n@@ -1035,15 +1218,17 @@ AndroidApiLevel AndroidGetApiLevel() {\n \n #endif\n \n-bool IsDeadlySignal(int signum) {\n+bool IsHandledDeadlySignal(int signum) {\n   if (common_flags()->handle_abort && signum == SIGABRT)\n     return true;\n+  if (common_flags()->handle_sigill && signum == SIGILL)\n+    return true;\n   if (common_flags()->handle_sigfpe && signum == SIGFPE)\n     return true;\n   return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n }\n \n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n void *internal_start_thread(void(*func)(void *arg), void *arg) {\n   // Start the thread with signals blocked, otherwise it can steal user signals.\n   __sanitizer_sigset_t set, old;\n@@ -1069,6 +1254,54 @@ void *internal_start_thread(void (*func)(void *), void *arg) { return 0; }\n void internal_join_thread(void *th) {}\n #endif\n \n+#if defined(__aarch64__)\n+// Android headers in the older NDK releases miss this definition.\n+struct __sanitizer_esr_context {\n+  struct _aarch64_ctx head;\n+  uint64_t esr;\n+};\n+\n+static bool Aarch64GetESR(ucontext_t *ucontext, u64 *esr) {\n+  static const u32 kEsrMagic = 0x45535201;\n+  u8 *aux = ucontext->uc_mcontext.__reserved;\n+  while (true) {\n+    _aarch64_ctx *ctx = (_aarch64_ctx *)aux;\n+    if (ctx->size == 0) break;\n+    if (ctx->magic == kEsrMagic) {\n+      *esr = ((__sanitizer_esr_context *)ctx)->esr;\n+      return true;\n+    }\n+    aux += ctx->size;\n+  }\n+  return false;\n+}\n+#endif\n+\n+SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n+  ucontext_t *ucontext = (ucontext_t *)context;\n+#if defined(__x86_64__) || defined(__i386__)\n+  static const uptr PF_WRITE = 1U << 1;\n+#if SANITIZER_FREEBSD\n+  uptr err = ucontext->uc_mcontext.mc_err;\n+#else\n+  uptr err = ucontext->uc_mcontext.gregs[REG_ERR];\n+#endif\n+  return err & PF_WRITE ? WRITE : READ;\n+#elif defined(__arm__)\n+  static const uptr FSR_WRITE = 1U << 11;\n+  uptr fsr = ucontext->uc_mcontext.error_code;\n+  return fsr & FSR_WRITE ? WRITE : READ;\n+#elif defined(__aarch64__)\n+  static const u64 ESR_ELx_WNR = 1U << 6;\n+  u64 esr;\n+  if (!Aarch64GetESR(ucontext, &esr)) return UNKNOWN;\n+  return esr & ESR_ELx_WNR ? WRITE : READ;\n+#else\n+  (void)ucontext;\n+  return UNKNOWN;  // FIXME: Implement.\n+#endif\n+}\n+\n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n #if defined(__arm__)\n   ucontext_t *ucontext = (ucontext_t*)context;\n@@ -1136,11 +1369,29 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   *pc = ucontext->uc_mcontext.pc;\n   *bp = ucontext->uc_mcontext.gregs[30];\n   *sp = ucontext->uc_mcontext.gregs[29];\n+#elif defined(__s390__)\n+  ucontext_t *ucontext = (ucontext_t*)context;\n+# if defined(__s390x__)\n+  *pc = ucontext->uc_mcontext.psw.addr;\n+# else\n+  *pc = ucontext->uc_mcontext.psw.addr & 0x7fffffff;\n+# endif\n+  *bp = ucontext->uc_mcontext.gregs[11];\n+  *sp = ucontext->uc_mcontext.gregs[15];\n #else\n # error \"Unsupported arch\"\n #endif\n }\n \n+void MaybeReexec() {\n+  // No need to re-exec on Linux.\n+}\n+\n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding) {\n+  UNREACHABLE(\"FindAvailableMemoryRange is not available\");\n+  return 0;\n+}\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_FREEBSD || SANITIZER_LINUX"}, {"sha": "895bfc18195c4f534ec0c83c6d9a4d3001b77d97", "filename": "libsanitizer/sanitizer_common/sanitizer_linux.h", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,7 +32,6 @@ uptr internal_sigaltstack(const struct sigaltstack* ss,\n                           struct sigaltstack* oss);\n uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n     __sanitizer_sigset_t *oldset);\n-void internal_sigfillset(__sanitizer_sigset_t *set);\n \n // Linux-only syscalls.\n #if SANITIZER_LINUX\n@@ -41,8 +40,13 @@ uptr internal_prctl(int option, uptr arg2, uptr arg3, uptr arg4, uptr arg5);\n // (like the process-wide error reporting SEGV handler) must use\n // internal_sigaction instead.\n int internal_sigaction_norestorer(int signum, const void *act, void *oldact);\n+#if (defined(__x86_64__) || SANITIZER_MIPS64) && !SANITIZER_GO\n+// Uses a raw system call to avoid interceptors.\n+int internal_sigaction_syscall(int signum, const void *act, void *oldact);\n+#endif\n void internal_sigdelset(__sanitizer_sigset_t *set, int signum);\n-#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__)\n+#if defined(__x86_64__) || defined(__mips__) || defined(__aarch64__) \\\n+  || defined(__powerpc64__) || defined(__s390__)\n uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n                     int *parent_tidptr, void *newtls, int *child_tidptr);\n #endif"}, {"sha": "63e70660cf355a6ffc2f177170f9abb2c99aad7a", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_libcdep.cc", "status": "modified", "additions": 55, "deletions": 65, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,6 +32,7 @@\n #include <pthread.h>\n #include <signal.h>\n #include <sys/resource.h>\n+#include <syslog.h>\n \n #if SANITIZER_FREEBSD\n #include <pthread_np.h>\n@@ -49,8 +50,6 @@\n \n #if SANITIZER_ANDROID && __ANDROID_API__ < 21\n #include <android/log.h>\n-#else\n-#include <syslog.h>\n #endif\n \n #if !SANITIZER_ANDROID\n@@ -156,34 +155,14 @@ bool SanitizerGetThreadName(char *name, int max_len) {\n \n #if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n static uptr g_tls_size;\n-#endif\n \n #ifdef __i386__\n # define DL_INTERNAL_FUNCTION __attribute__((regparm(3), stdcall))\n #else\n # define DL_INTERNAL_FUNCTION\n #endif\n \n-#if defined(__mips__) || defined(__powerpc64__)\n-// TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n-// head structure. It lies before the static tls blocks.\n-static uptr TlsPreTcbSize() {\n-# if defined(__mips__)\n-  const uptr kTcbHead = 16; // sizeof (tcbhead_t)\n-# elif defined(__powerpc64__)\n-  const uptr kTcbHead = 88; // sizeof (tcbhead_t)\n-# endif\n-  const uptr kTlsAlign = 16;\n-  const uptr kTlsPreTcbSize =\n-    (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n-  InitTlsSize();\n-  g_tls_size = (g_tls_size + kTlsPreTcbSize + kTlsAlign -1) & ~(kTlsAlign - 1);\n-  return kTlsPreTcbSize;\n-}\n-#endif\n-\n void InitTlsSize() {\n-#if !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n // all current supported platforms have 16 bytes stack alignment\n   const size_t kStackAlign = 16;\n   typedef void (*get_tls_func)(size_t*, size_t*) DL_INTERNAL_FUNCTION;\n@@ -199,11 +178,13 @@ void InitTlsSize() {\n   if (tls_align < kStackAlign)\n     tls_align = kStackAlign;\n   g_tls_size = RoundUpTo(tls_size, tls_align);\n-#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n }\n+#else\n+void InitTlsSize() { }\n+#endif  // !SANITIZER_FREEBSD && !SANITIZER_ANDROID && !SANITIZER_GO\n \n #if (defined(__x86_64__) || defined(__i386__) || defined(__mips__) \\\n-    || defined(__aarch64__) || defined(__powerpc64__)) \\\n+    || defined(__aarch64__) || defined(__powerpc64__) || defined(__s390__)) \\\n     && SANITIZER_LINUX && !SANITIZER_ANDROID\n // sizeof(struct pthread) from glibc.\n static atomic_uintptr_t kThreadDescriptorSize;\n@@ -220,6 +201,11 @@ uptr ThreadDescriptorSize() {\n     char *end;\n     int minor = internal_simple_strtoll(buf + 8, &end, 10);\n     if (end != buf + 8 && (*end == '\\0' || *end == '.')) {\n+      int patch = 0;\n+      if (*end == '.')\n+        // strtoll will return 0 if no valid conversion could be performed\n+        patch = internal_simple_strtoll(end + 1, nullptr, 10);\n+\n       /* sizeof(struct pthread) values from various glibc versions.  */\n       if (SANITIZER_X32)\n         val = 1728;  // Assume only one particular version for x32.\n@@ -233,9 +219,9 @@ uptr ThreadDescriptorSize() {\n         val = FIRST_32_SECOND_64(1136, 1712);\n       else if (minor == 10)\n         val = FIRST_32_SECOND_64(1168, 1776);\n-      else if (minor <= 12)\n+      else if (minor == 11 || (minor == 12 && patch == 1))\n         val = FIRST_32_SECOND_64(1168, 2288);\n-      else if (minor == 13)\n+      else if (minor <= 13)\n         val = FIRST_32_SECOND_64(1168, 2304);\n       else\n         val = FIRST_32_SECOND_64(1216, 2304);\n@@ -260,6 +246,9 @@ uptr ThreadDescriptorSize() {\n   val = 1776; // from glibc.ppc64le 2.20-8.fc21\n   atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n   return val;\n+#elif defined(__s390__)\n+  val = FIRST_32_SECOND_64(1152, 1776); // valid for glibc 2.22\n+  atomic_store(&kThreadDescriptorSize, val, memory_order_relaxed);\n #endif\n   return 0;\n }\n@@ -271,6 +260,24 @@ uptr ThreadSelfOffset() {\n   return kThreadSelfOffset;\n }\n \n+#if defined(__mips__) || defined(__powerpc64__)\n+// TlsPreTcbSize includes size of struct pthread_descr and size of tcb\n+// head structure. It lies before the static tls blocks.\n+static uptr TlsPreTcbSize() {\n+# if defined(__mips__)\n+  const uptr kTcbHead = 16; // sizeof (tcbhead_t)\n+# elif defined(__powerpc64__)\n+  const uptr kTcbHead = 88; // sizeof (tcbhead_t)\n+# endif\n+  const uptr kTlsAlign = 16;\n+  const uptr kTlsPreTcbSize =\n+    (ThreadDescriptorSize() + kTcbHead + kTlsAlign - 1) & ~(kTlsAlign - 1);\n+  InitTlsSize();\n+  g_tls_size = (g_tls_size + kTlsPreTcbSize + kTlsAlign -1) & ~(kTlsAlign - 1);\n+  return kTlsPreTcbSize;\n+}\n+#endif\n+\n uptr ThreadSelf() {\n   uptr descr_addr;\n # if defined(__i386__)\n@@ -290,6 +297,9 @@ uptr ThreadSelf() {\n                 .set pop\" : \"=r\" (thread_pointer));\n   descr_addr = thread_pointer - kTlsTcbOffset - TlsPreTcbSize();\n # elif defined(__aarch64__)\n+  descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer()) -\n+                                      ThreadDescriptorSize();\n+# elif defined(__s390__)\n   descr_addr = reinterpret_cast<uptr>(__builtin_thread_pointer());\n # elif defined(__powerpc64__)\n   // PPC64LE uses TLS variant I. The thread pointer (in GPR 13)\n@@ -330,7 +340,7 @@ uptr ThreadSelf() {\n #if !SANITIZER_GO\n static void GetTls(uptr *addr, uptr *size) {\n #if SANITIZER_LINUX && !SANITIZER_ANDROID\n-# if defined(__x86_64__) || defined(__i386__)\n+# if defined(__x86_64__) || defined(__i386__) || defined(__s390__)\n   *addr = ThreadSelf();\n   *size = GetTlsSize();\n   *addr -= *size;\n@@ -410,17 +420,12 @@ typedef ElfW(Phdr) Elf_Phdr;\n # endif\n \n struct DlIteratePhdrData {\n-  LoadedModule *modules;\n-  uptr current_n;\n+  InternalMmapVector<LoadedModule> *modules;\n   bool first;\n-  uptr max_n;\n-  string_predicate_t filter;\n };\n \n static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n   DlIteratePhdrData *data = (DlIteratePhdrData*)arg;\n-  if (data->current_n == data->max_n)\n-    return 0;\n   InternalScopedString module_name(kMaxPathLength);\n   if (data->first) {\n     data->first = false;\n@@ -431,20 +436,18 @@ static int dl_iterate_phdr_cb(dl_phdr_info *info, size_t size, void *arg) {\n   }\n   if (module_name[0] == '\\0')\n     return 0;\n-  if (data->filter && !data->filter(module_name.data()))\n-    return 0;\n-  LoadedModule *cur_module = &data->modules[data->current_n];\n-  cur_module->set(module_name.data(), info->dlpi_addr);\n-  data->current_n++;\n+  LoadedModule cur_module;\n+  cur_module.set(module_name.data(), info->dlpi_addr);\n   for (int i = 0; i < info->dlpi_phnum; i++) {\n     const Elf_Phdr *phdr = &info->dlpi_phdr[i];\n     if (phdr->p_type == PT_LOAD) {\n       uptr cur_beg = info->dlpi_addr + phdr->p_vaddr;\n       uptr cur_end = cur_beg + phdr->p_memsz;\n       bool executable = phdr->p_flags & PF_X;\n-      cur_module->addAddressRange(cur_beg, cur_end, executable);\n+      cur_module.addAddressRange(cur_beg, cur_end, executable);\n     }\n   }\n+  data->modules->push_back(cur_module);\n   return 0;\n }\n \n@@ -453,22 +456,21 @@ extern \"C\" __attribute__((weak)) int dl_iterate_phdr(\n     int (*)(struct dl_phdr_info *, size_t, void *), void *);\n #endif\n \n-uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n-                      string_predicate_t filter) {\n+void ListOfModules::init() {\n+  clear();\n #if SANITIZER_ANDROID && __ANDROID_API__ <= 22\n   u32 api_level = AndroidGetApiLevel();\n   // Fall back to /proc/maps if dl_iterate_phdr is unavailable or broken.\n   // The runtime check allows the same library to work with\n   // both K and L (and future) Android releases.\n   if (api_level <= ANDROID_LOLLIPOP_MR1) { // L or earlier\n     MemoryMappingLayout memory_mapping(false);\n-    return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n+    memory_mapping.DumpListOfModules(&modules_);\n+    return;\n   }\n #endif\n-  CHECK(modules);\n-  DlIteratePhdrData data = {modules, 0, true, max_modules, filter};\n+  DlIteratePhdrData data = {&modules_, true};\n   dl_iterate_phdr(dl_iterate_phdr_cb, &data);\n-  return data.current_n;\n }\n \n // getrusage does not give us the current RSS, only the max RSS.\n@@ -519,44 +521,32 @@ uptr GetRSS() {\n static atomic_uint8_t android_log_initialized;\n \n void AndroidLogInit() {\n+  openlog(GetProcessName(), 0, LOG_USER);\n   atomic_store(&android_log_initialized, 1, memory_order_release);\n }\n \n-static bool IsSyslogAvailable() {\n+static bool ShouldLogAfterPrintf() {\n   return atomic_load(&android_log_initialized, memory_order_acquire);\n }\n #else\n void AndroidLogInit() {}\n \n-static bool IsSyslogAvailable() { return true; }\n+static bool ShouldLogAfterPrintf() { return true; }\n #endif  // SANITIZER_ANDROID\n \n-static void WriteOneLineToSyslog(const char *s) {\n+void WriteOneLineToSyslog(const char *s) {\n #if SANITIZER_ANDROID &&__ANDROID_API__ < 21\n   __android_log_write(ANDROID_LOG_INFO, NULL, s);\n #else\n   syslog(LOG_INFO, \"%s\", s);\n #endif\n }\n \n-void WriteToSyslog(const char *buffer) {\n-  if (!IsSyslogAvailable())\n-    return;\n-  char *copy = internal_strdup(buffer);\n-  char *p = copy;\n-  char *q;\n-  // syslog, at least on Android, has an implicit message length limit.\n-  // Print one line at a time.\n-  do {\n-    q = internal_strchr(p, '\\n');\n-    if (q)\n-      *q = '\\0';\n-    WriteOneLineToSyslog(p);\n-    if (q)\n-      p = q + 1;\n-  } while (q);\n-  InternalFree(copy);\n+void LogMessageOnPrintf(const char *str) {\n+  if (common_flags()->log_to_syslog && ShouldLogAfterPrintf())\n+    WriteToSyslog(str);\n }\n+\n #endif // SANITIZER_LINUX\n \n } // namespace __sanitizer"}, {"sha": "0b76f3a473a234a0ad79abacb6e415a22d1cf80c", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_mips64.S", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_mips64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,21 @@\n+// This file is dual licensed under the MIT and the University of Illinois Open\n+// Avoid being marked as needing an executable stack:\n+#if defined(__linux__) && defined(__ELF__)\n+.section .note.GNU-stack,\"\",%progbits\n+#endif\n+\n+// Further contents are mips64 only:\n+#if defined(__linux__) && defined(__mips64)\n+\n+.section .text\n+.set noreorder\n+.globl internal_sigreturn\n+.type internal_sigreturn, @function\n+internal_sigreturn:\n+\n+        li $v0,5211 // #5211 is for SYS_rt_sigreturn\n+        syscall\n+\n+.size internal_sigreturn, .-internal_sigreturn\n+\n+#endif // defined(__linux__) && defined(__mips64)"}, {"sha": "c7d647528abac21c54f5f5216fd1bc3fd7346c5c", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_s390.cc", "status": "added", "additions": 189, "deletions": 0, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_s390.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,189 @@\n+//===-- sanitizer_linux_s390.cc -------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is shared between AddressSanitizer and ThreadSanitizer\n+// run-time libraries and implements s390-linux-specific functions from\n+// sanitizer_libc.h.\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_platform.h\"\n+\n+#if SANITIZER_LINUX && SANITIZER_S390\n+\n+#include \"sanitizer_libc.h\"\n+#include \"sanitizer_linux.h\"\n+\n+#include <errno.h>\n+#include <sys/syscall.h>\n+#include <sys/utsname.h>\n+#include <unistd.h>\n+\n+namespace __sanitizer {\n+\n+// --------------- sanitizer_libc.h\n+uptr internal_mmap(void *addr, uptr length, int prot, int flags, int fd,\n+                   OFF_T offset) {\n+  struct s390_mmap_params {\n+    unsigned long addr;\n+    unsigned long length;\n+    unsigned long prot;\n+    unsigned long flags;\n+    unsigned long fd;\n+    unsigned long offset;\n+  } params = {\n+    (unsigned long)addr,\n+    (unsigned long)length,\n+    (unsigned long)prot,\n+    (unsigned long)flags,\n+    (unsigned long)fd,\n+# ifdef __s390x__\n+    (unsigned long)offset,\n+# else\n+    (unsigned long)(offset / 4096),\n+# endif\n+  };\n+# ifdef __s390x__\n+  return syscall(__NR_mmap, &params);\n+# else\n+  return syscall(__NR_mmap2, &params);\n+# endif\n+}\n+\n+uptr internal_clone(int (*fn)(void *), void *child_stack, int flags, void *arg,\n+                    int *parent_tidptr, void *newtls, int *child_tidptr) {\n+  if (!fn || !child_stack)\n+    return -EINVAL;\n+  CHECK_EQ(0, (uptr)child_stack % 16);\n+  // Minimum frame size.\n+#ifdef __s390x__\n+  child_stack = (char *)child_stack - 160;\n+#else\n+  child_stack = (char *)child_stack - 96;\n+#endif\n+  // Terminate unwind chain.\n+  ((unsigned long *)child_stack)[0] = 0;\n+  // And pass parameters.\n+  ((unsigned long *)child_stack)[1] = (uptr)fn;\n+  ((unsigned long *)child_stack)[2] = (uptr)arg;\n+  register long res __asm__(\"r2\");\n+  register void *__cstack      __asm__(\"r2\") = child_stack;\n+  register int __flags         __asm__(\"r3\") = flags;\n+  register int * __ptidptr     __asm__(\"r4\") = parent_tidptr;\n+  register int * __ctidptr     __asm__(\"r5\") = child_tidptr;\n+  register void * __newtls     __asm__(\"r6\") = newtls;\n+\n+  __asm__ __volatile__(\n+                       /* Clone. */\n+                       \"svc    %1\\n\"\n+\n+                       /* if (%r2 != 0)\n+                        *   return;\n+                        */\n+#ifdef __s390x__\n+                       \"cghi   %%r2, 0\\n\"\n+#else\n+                       \"chi    %%r2, 0\\n\"\n+#endif\n+                       \"jne    1f\\n\"\n+\n+                       /* Call \"fn(arg)\". */\n+#ifdef __s390x__\n+                       \"lmg    %%r1, %%r2, 8(%%r15)\\n\"\n+#else\n+                       \"lm     %%r1, %%r2, 4(%%r15)\\n\"\n+#endif\n+                       \"basr   %%r14, %%r1\\n\"\n+\n+                       /* Call _exit(%r2). */\n+                       \"svc %2\\n\"\n+\n+                       /* Return to parent. */\n+                     \"1:\\n\"\n+                       : \"=r\" (res)\n+                       : \"i\"(__NR_clone), \"i\"(__NR_exit),\n+                         \"r\"(__cstack),\n+                         \"r\"(__flags),\n+                         \"r\"(__ptidptr),\n+                         \"r\"(__ctidptr),\n+                         \"r\"(__newtls)\n+                       : \"memory\", \"cc\");\n+  return res;\n+}\n+\n+#if SANITIZER_S390_64\n+static bool FixedCVE_2016_2143() {\n+  // Try to determine if the running kernel has a fix for CVE-2016-2143,\n+  // return false if in doubt (better safe than sorry).  Distros may want to\n+  // adjust this for their own kernels.\n+  struct utsname buf;\n+  unsigned int major, minor, patch = 0;\n+  // This should never fail, but just in case...\n+  if (uname(&buf))\n+    return false;\n+  char *ptr = buf.release;\n+  major = internal_simple_strtoll(ptr, &ptr, 10);\n+  // At least first 2 should be matched.\n+  if (ptr[0] != '.')\n+    return false;\n+  minor = internal_simple_strtoll(ptr+1, &ptr, 10);\n+  // Third is optional.\n+  if (ptr[0] == '.')\n+    patch = internal_simple_strtoll(ptr+1, &ptr, 10);\n+  if (major < 3) {\n+    // <3.0 is bad.\n+    return false;\n+  } else if (major == 3) {\n+    // 3.2.79+ is OK.\n+    if (minor == 2 && patch >= 79)\n+      return true;\n+    // 3.12.58+ is OK.\n+    if (minor == 12 && patch >= 58)\n+      return true;\n+    // Otherwise, bad.\n+    return false;\n+  } else if (major == 4) {\n+    // 4.1.21+ is OK.\n+    if (minor == 1 && patch >= 21)\n+      return true;\n+    // 4.4.6+ is OK.\n+    if (minor == 4 && patch >= 6)\n+      return true;\n+    // Otherwise, OK if 4.5+.\n+    return minor >= 5;\n+  } else {\n+    // Linux 5 and up are fine.\n+    return true;\n+  }\n+}\n+\n+void AvoidCVE_2016_2143() {\n+  // Older kernels are affected by CVE-2016-2143 - they will crash hard\n+  // if someone uses 4-level page tables (ie. virtual addresses >= 4TB)\n+  // and fork() in the same process.  Unfortunately, sanitizers tend to\n+  // require such addresses.  Since this is very likely to crash the whole\n+  // machine (sanitizers themselves use fork() for llvm-symbolizer, for one),\n+  // abort the process at initialization instead.\n+  if (FixedCVE_2016_2143())\n+    return;\n+  if (GetEnv(\"SANITIZER_IGNORE_CVE_2016_2143\"))\n+    return;\n+  Report(\n+    \"ERROR: Your kernel seems to be vulnerable to CVE-2016-2143.  Using ASan,\\n\"\n+    \"MSan, TSan, DFSan or LSan with such kernel can and will crash your\\n\"\n+    \"machine, or worse.\\n\"\n+    \"\\n\"\n+    \"If you are certain your kernel is not vulnerable (you have compiled it\\n\"\n+    \"yourself, or are using an unrecognized distribution kernel), you can\\n\"\n+    \"override this safety check by exporting SANITIZER_IGNORE_CVE_2016_2143\\n\"\n+    \"with any value.\\n\");\n+  Die();\n+}\n+#endif\n+\n+} // namespace __sanitizer\n+\n+#endif // SANITIZER_LINUX && SANITIZER_S390"}, {"sha": "6b892116ff4c33dc7654a8932e58d8434b6adc2c", "filename": "libsanitizer/sanitizer_common/sanitizer_linux_x86_64.S", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_linux_x86_64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,23 @@\n+// This file is dual licensed under the MIT and the University of Illinois Open\n+// Avoid being marked as needing an executable stack:\n+#if defined(__linux__) && defined(__ELF__)\n+.section .note.GNU-stack,\"\",%progbits\n+#endif\n+\n+// Further contents are x86_64-only:\n+#if defined(__linux__) && defined(__x86_64__)\n+\n+#include \"../builtins/assembly.h\"\n+\n+// If the \"naked\" function attribute were supported for x86 we could\n+// do this via inline asm.\n+.text\n+.balign 4\n+DEFINE_COMPILERRT_FUNCTION(internal_sigreturn)\n+        mov           $0xf,             %eax    // 0xf == SYS_rt_sigreturn\n+        mov           %rcx,             %r10\n+        syscall\n+        ret                                     // Won't normally reach here.\n+END_COMPILERRT_FUNCTION(internal_sigreturn)\n+\n+#endif // defined(__linux__) && defined(__x86_64__)"}, {"sha": "190c7e67cf0fa031ed2fc5831e6a01cb97377869", "filename": "libsanitizer/sanitizer_common/sanitizer_list.h", "status": "modified", "additions": 21, "deletions": 11, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_list.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -69,7 +69,9 @@ struct IntrusiveList {\n   }\n \n   Item *front() { return first_; }\n+  const Item *front() const { return first_; }\n   Item *back() { return last_; }\n+  const Item *back() const { return last_; }\n \n   void append_front(IntrusiveList<Item> *l) {\n     CHECK_NE(this, l);\n@@ -114,24 +116,32 @@ struct IntrusiveList {\n     }\n   }\n \n-  template<class ListTy, class ItemTy>\n+  template<class ItemTy>\n   class IteratorBase {\n    public:\n-    explicit IteratorBase(ListTy *list)\n-        : list_(list), current_(list->first_) { }\n-    ItemTy *next() {\n-      ItemTy *ret = current_;\n-      if (current_) current_ = current_->next;\n-      return ret;\n+    explicit IteratorBase(ItemTy *current) : current_(current) {}\n+    IteratorBase &operator++() {\n+      current_ = current_->next;\n+      return *this;\n+    }\n+    bool operator!=(IteratorBase other) const {\n+      return current_ != other.current_;\n+    }\n+    ItemTy &operator*() {\n+      return *current_;\n     }\n-    bool hasNext() const { return current_ != nullptr; }\n    private:\n-    ListTy *list_;\n     ItemTy *current_;\n   };\n \n-  typedef IteratorBase<IntrusiveList<Item>, Item> Iterator;\n-  typedef IteratorBase<const IntrusiveList<Item>, const Item> ConstIterator;\n+  typedef IteratorBase<Item> Iterator;\n+  typedef IteratorBase<const Item> ConstIterator;\n+\n+  Iterator begin() { return Iterator(first_); }\n+  Iterator end() { return Iterator(0); }\n+\n+  ConstIterator begin() const { return ConstIterator(first_); }\n+  ConstIterator end() const { return ConstIterator(0); }\n \n // private, don't use directly.\n   uptr size_;"}, {"sha": "4408d1dccb961d82e9cb1c859a9547ad570d8f38", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.cc", "status": "modified", "additions": 394, "deletions": 12, "changes": 406, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -11,6 +11,7 @@\n \n #include \"sanitizer_platform.h\"\n #if SANITIZER_MAC\n+#include \"sanitizer_mac.h\"\n \n // Use 64-bit inodes in file operations. ASan does not support OS X 10.5, so\n // the clients will most certainly use 64-bit ones as well.\n@@ -23,7 +24,6 @@\n #include \"sanitizer_flags.h\"\n #include \"sanitizer_internal_defs.h\"\n #include \"sanitizer_libc.h\"\n-#include \"sanitizer_mac.h\"\n #include \"sanitizer_placement_new.h\"\n #include \"sanitizer_platform_limits_posix.h\"\n #include \"sanitizer_procmaps.h\"\n@@ -34,6 +34,23 @@\n extern char **environ;\n #endif\n \n+#if defined(__has_include) && __has_include(<os/trace.h>)\n+#define SANITIZER_OS_TRACE 1\n+#include <os/trace.h>\n+#else\n+#define SANITIZER_OS_TRACE 0\n+#endif\n+\n+#if !SANITIZER_IOS\n+#include <crt_externs.h>  // for _NSGetArgv and _NSGetEnviron\n+#else\n+extern \"C\" {\n+  extern char ***_NSGetArgv(void);\n+}\n+#endif\n+\n+#include <asl.h>\n+#include <dlfcn.h>  // for dladdr()\n #include <errno.h>\n #include <fcntl.h>\n #include <libkern/OSAtomic.h>\n@@ -49,21 +66,45 @@ extern char **environ;\n #include <sys/stat.h>\n #include <sys/sysctl.h>\n #include <sys/types.h>\n+#include <sys/wait.h>\n #include <unistd.h>\n+#include <util.h>\n+\n+// From <crt_externs.h>, but we don't have that file on iOS.\n+extern \"C\" {\n+  extern char ***_NSGetArgv(void);\n+  extern char ***_NSGetEnviron(void);\n+}\n+\n+// From <mach/mach_vm.h>, but we don't have that file on iOS.\n+extern \"C\" {\n+  extern kern_return_t mach_vm_region_recurse(\n+    vm_map_t target_task,\n+    mach_vm_address_t *address,\n+    mach_vm_size_t *size,\n+    natural_t *nesting_depth,\n+    vm_region_recurse_info_t info,\n+    mach_msg_type_number_t *infoCnt);\n+}\n \n namespace __sanitizer {\n \n #include \"sanitizer_syscall_generic.inc\"\n \n+// Direct syscalls, don't call libmalloc hooks.\n+extern \"C\" void *__mmap(void *addr, size_t len, int prot, int flags, int fildes,\n+                        off_t off);\n+extern \"C\" int __munmap(void *, size_t);\n+\n // ---------------------- sanitizer_libc.h\n uptr internal_mmap(void *addr, size_t length, int prot, int flags,\n                    int fd, u64 offset) {\n   if (fd == -1) fd = VM_MAKE_TAG(VM_MEMORY_ANALYSIS_TOOL);\n-  return (uptr)mmap(addr, length, prot, flags, fd, offset);\n+  return (uptr)__mmap(addr, length, prot, flags, fd, offset);\n }\n \n uptr internal_munmap(void *addr, uptr length) {\n-  return munmap(addr, length);\n+  return __munmap(addr, length);\n }\n \n int internal_mprotect(void *addr, uptr length, int prot) {\n@@ -129,6 +170,10 @@ void internal__exit(int exitcode) {\n   _exit(exitcode);\n }\n \n+unsigned int internal_sleep(unsigned int seconds) {\n+  return sleep(seconds);\n+}\n+\n uptr internal_getpid() {\n   return getpid();\n }\n@@ -145,9 +190,34 @@ uptr internal_sigprocmask(int how, __sanitizer_sigset_t *set,\n   return sigprocmask(how, set, oldset);\n }\n \n+// Doesn't call pthread_atfork() handlers.\n+extern \"C\" pid_t __fork(void);\n+\n int internal_fork() {\n-  // TODO(glider): this may call user's pthread_atfork() handlers which is bad.\n-  return fork();\n+  return __fork();\n+}\n+\n+int internal_forkpty(int *amaster) {\n+  int master, slave;\n+  if (openpty(&master, &slave, nullptr, nullptr, nullptr) == -1) return -1;\n+  int pid = __fork();\n+  if (pid == -1) {\n+    close(master);\n+    close(slave);\n+    return -1;\n+  }\n+  if (pid == 0) {\n+    close(master);\n+    if (login_tty(slave) != 0) {\n+      // We already forked, there's not much we can do.  Let's quit.\n+      Report(\"login_tty failed (errno %d)\\n\", errno);\n+      internal__exit(1);\n+    }\n+  } else {\n+    *amaster = master;\n+    close(slave);\n+  }\n+  return pid;\n }\n \n uptr internal_rename(const char *oldpath, const char *newpath) {\n@@ -158,6 +228,15 @@ uptr internal_ftruncate(fd_t fd, uptr size) {\n   return ftruncate(fd, size);\n }\n \n+uptr internal_execve(const char *filename, char *const argv[],\n+                     char *const envp[]) {\n+  return execve(filename, argv, envp);\n+}\n+\n+uptr internal_waitpid(int pid, int *status, int options) {\n+  return waitpid(pid, status, options);\n+}\n+\n // ----------------- sanitizer_common.h\n bool FileExists(const char *filename) {\n   struct stat st;\n@@ -168,7 +247,10 @@ bool FileExists(const char *filename) {\n }\n \n uptr GetTid() {\n-  return reinterpret_cast<uptr>(pthread_self());\n+  // FIXME: This can potentially get truncated on 32-bit, where uptr is 4 bytes.\n+  uint64_t tid;\n+  pthread_threadid_np(nullptr, &tid);\n+  return tid;\n }\n \n void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n@@ -178,7 +260,7 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n   uptr stacksize = pthread_get_stacksize_np(pthread_self());\n   // pthread_get_stacksize_np() returns an incorrect stack size for the main\n   // thread on Mavericks. See\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=261\n+  // https://github.com/google/sanitizers/issues/261\n   if ((GetMacosVersion() >= MACOS_VERSION_MAVERICKS) && at_initialization &&\n       stacksize == (1 << 19))  {\n     struct rlimit rl;\n@@ -289,7 +371,7 @@ void InitTlsSize() {\n \n void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size) {\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n   uptr stack_top, stack_bottom;\n   GetThreadStackTopAndBottom(main, &stack_top, &stack_bottom);\n   *stk_addr = stack_bottom;\n@@ -304,13 +386,18 @@ void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n #endif\n }\n \n-uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n-                      string_predicate_t filter) {\n+void ListOfModules::init() {\n+  clear();\n   MemoryMappingLayout memory_mapping(false);\n-  return memory_mapping.DumpListOfModules(modules, max_modules, filter);\n+  memory_mapping.DumpListOfModules(&modules_);\n }\n \n-bool IsDeadlySignal(int signum) {\n+bool IsHandledDeadlySignal(int signum) {\n+  if ((SANITIZER_WATCHOS || SANITIZER_TVOS) && !(SANITIZER_IOSSIM))\n+    // Handling fatal signals on watchOS and tvOS devices is disallowed.\n+    return false;\n+  if (common_flags()->handle_abort && signum == SIGABRT)\n+    return true;\n   return (signum == SIGSEGV || signum == SIGBUS) && common_flags()->handle_segv;\n }\n \n@@ -382,6 +469,70 @@ void *internal_start_thread(void(*func)(void *arg), void *arg) {\n \n void internal_join_thread(void *th) { pthread_join((pthread_t)th, 0); }\n \n+#if !SANITIZER_GO\n+static BlockingMutex syslog_lock(LINKER_INITIALIZED);\n+#endif\n+\n+void WriteOneLineToSyslog(const char *s) {\n+#if !SANITIZER_GO\n+  syslog_lock.CheckLocked();\n+  asl_log(nullptr, nullptr, ASL_LEVEL_ERR, \"%s\", s);\n+#endif\n+}\n+\n+void LogMessageOnPrintf(const char *str) {\n+  // Log all printf output to CrashLog.\n+  if (common_flags()->abort_on_error)\n+    CRAppendCrashLogMessage(str);\n+}\n+\n+void LogFullErrorReport(const char *buffer) {\n+#if !SANITIZER_GO\n+  // Log with os_trace. This will make it into the crash log.\n+#if SANITIZER_OS_TRACE\n+  if (GetMacosVersion() >= MACOS_VERSION_YOSEMITE) {\n+    // os_trace requires the message (format parameter) to be a string literal.\n+    if (internal_strncmp(SanitizerToolName, \"AddressSanitizer\",\n+                         sizeof(\"AddressSanitizer\") - 1) == 0)\n+      os_trace(\"Address Sanitizer reported a failure.\");\n+    else if (internal_strncmp(SanitizerToolName, \"UndefinedBehaviorSanitizer\",\n+                              sizeof(\"UndefinedBehaviorSanitizer\") - 1) == 0)\n+      os_trace(\"Undefined Behavior Sanitizer reported a failure.\");\n+    else if (internal_strncmp(SanitizerToolName, \"ThreadSanitizer\",\n+                              sizeof(\"ThreadSanitizer\") - 1) == 0)\n+      os_trace(\"Thread Sanitizer reported a failure.\");\n+    else\n+      os_trace(\"Sanitizer tool reported a failure.\");\n+\n+    if (common_flags()->log_to_syslog)\n+      os_trace(\"Consult syslog for more information.\");\n+  }\n+#endif\n+\n+  // Log to syslog.\n+  // The logging on OS X may call pthread_create so we need the threading\n+  // environment to be fully initialized. Also, this should never be called when\n+  // holding the thread registry lock since that may result in a deadlock. If\n+  // the reporting thread holds the thread registry mutex, and asl_log waits\n+  // for GCD to dispatch a new thread, the process will deadlock, because the\n+  // pthread_create wrapper needs to acquire the lock as well.\n+  BlockingMutexLock l(&syslog_lock);\n+  if (common_flags()->log_to_syslog)\n+    WriteToSyslog(buffer);\n+\n+  // The report is added to CrashLog as part of logging all of Printf output.\n+#endif\n+}\n+\n+SignalContext::WriteFlag SignalContext::GetWriteFlag(void *context) {\n+#if defined(__x86_64__) || defined(__i386__)\n+  ucontext_t *ucontext = static_cast<ucontext_t*>(context);\n+  return ucontext->uc_mcontext->__es.__err & 2 /*T_PF_WRITE*/ ? WRITE : READ;\n+#else\n+  return UNKNOWN;\n+#endif\n+}\n+\n void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n   ucontext_t *ucontext = (ucontext_t*)context;\n # if defined(__aarch64__)\n@@ -409,6 +560,237 @@ void GetPcSpBp(void *context, uptr *pc, uptr *sp, uptr *bp) {\n # endif\n }\n \n+#if !SANITIZER_GO\n+static const char kDyldInsertLibraries[] = \"DYLD_INSERT_LIBRARIES\";\n+LowLevelAllocator allocator_for_env;\n+\n+// Change the value of the env var |name|, leaking the original value.\n+// If |name_value| is NULL, the variable is deleted from the environment,\n+// otherwise the corresponding \"NAME=value\" string is replaced with\n+// |name_value|.\n+void LeakyResetEnv(const char *name, const char *name_value) {\n+  char **env = GetEnviron();\n+  uptr name_len = internal_strlen(name);\n+  while (*env != 0) {\n+    uptr len = internal_strlen(*env);\n+    if (len > name_len) {\n+      const char *p = *env;\n+      if (!internal_memcmp(p, name, name_len) && p[name_len] == '=') {\n+        // Match.\n+        if (name_value) {\n+          // Replace the old value with the new one.\n+          *env = const_cast<char*>(name_value);\n+        } else {\n+          // Shift the subsequent pointers back.\n+          char **del = env;\n+          do {\n+            del[0] = del[1];\n+          } while (*del++);\n+        }\n+      }\n+    }\n+    env++;\n+  }\n+}\n+\n+SANITIZER_WEAK_CXX_DEFAULT_IMPL\n+bool ReexecDisabled() {\n+  return false;\n+}\n+\n+extern \"C\" SANITIZER_WEAK_ATTRIBUTE double dyldVersionNumber;\n+static const double kMinDyldVersionWithAutoInterposition = 360.0;\n+\n+bool DyldNeedsEnvVariable() {\n+  // Although sanitizer support was added to LLVM on OS X 10.7+, GCC users\n+  // still may want use them on older systems. On older Darwin platforms, dyld\n+  // doesn't export dyldVersionNumber symbol and we simply return true.\n+  if (!&dyldVersionNumber) return true;\n+  // If running on OS X 10.11+ or iOS 9.0+, dyld will interpose even if\n+  // DYLD_INSERT_LIBRARIES is not set. However, checking OS version via\n+  // GetMacosVersion() doesn't work for the simulator. Let's instead check\n+  // `dyldVersionNumber`, which is exported by dyld, against a known version\n+  // number from the first OS release where this appeared.\n+  return dyldVersionNumber < kMinDyldVersionWithAutoInterposition;\n+}\n+\n+void MaybeReexec() {\n+  if (ReexecDisabled()) return;\n+\n+  // Make sure the dynamic runtime library is preloaded so that the\n+  // wrappers work. If it is not, set DYLD_INSERT_LIBRARIES and re-exec\n+  // ourselves.\n+  Dl_info info;\n+  RAW_CHECK(dladdr((void*)((uptr)&__sanitizer_report_error_summary), &info));\n+  char *dyld_insert_libraries =\n+      const_cast<char*>(GetEnv(kDyldInsertLibraries));\n+  uptr old_env_len = dyld_insert_libraries ?\n+      internal_strlen(dyld_insert_libraries) : 0;\n+  uptr fname_len = internal_strlen(info.dli_fname);\n+  const char *dylib_name = StripModuleName(info.dli_fname);\n+  uptr dylib_name_len = internal_strlen(dylib_name);\n+\n+  bool lib_is_in_env = dyld_insert_libraries &&\n+                       internal_strstr(dyld_insert_libraries, dylib_name);\n+  if (DyldNeedsEnvVariable() && !lib_is_in_env) {\n+    // DYLD_INSERT_LIBRARIES is not set or does not contain the runtime\n+    // library.\n+    InternalScopedString program_name(1024);\n+    uint32_t buf_size = program_name.size();\n+    _NSGetExecutablePath(program_name.data(), &buf_size);\n+    char *new_env = const_cast<char*>(info.dli_fname);\n+    if (dyld_insert_libraries) {\n+      // Append the runtime dylib name to the existing value of\n+      // DYLD_INSERT_LIBRARIES.\n+      new_env = (char*)allocator_for_env.Allocate(old_env_len + fname_len + 2);\n+      internal_strncpy(new_env, dyld_insert_libraries, old_env_len);\n+      new_env[old_env_len] = ':';\n+      // Copy fname_len and add a trailing zero.\n+      internal_strncpy(new_env + old_env_len + 1, info.dli_fname,\n+                       fname_len + 1);\n+      // Ok to use setenv() since the wrappers don't depend on the value of\n+      // asan_inited.\n+      setenv(kDyldInsertLibraries, new_env, /*overwrite*/1);\n+    } else {\n+      // Set DYLD_INSERT_LIBRARIES equal to the runtime dylib name.\n+      setenv(kDyldInsertLibraries, info.dli_fname, /*overwrite*/0);\n+    }\n+    VReport(1, \"exec()-ing the program with\\n\");\n+    VReport(1, \"%s=%s\\n\", kDyldInsertLibraries, new_env);\n+    VReport(1, \"to enable wrappers.\\n\");\n+    execv(program_name.data(), *_NSGetArgv());\n+\n+    // We get here only if execv() failed.\n+    Report(\"ERROR: The process is launched without DYLD_INSERT_LIBRARIES, \"\n+           \"which is required for the sanitizer to work. We tried to set the \"\n+           \"environment variable and re-execute itself, but execv() failed, \"\n+           \"possibly because of sandbox restrictions. Make sure to launch the \"\n+           \"executable with:\\n%s=%s\\n\", kDyldInsertLibraries, new_env);\n+    RAW_CHECK(\"execv failed\" && 0);\n+  }\n+\n+  // Verify that interceptors really work.  We'll use dlsym to locate\n+  // \"pthread_create\", if interceptors are working, it should really point to\n+  // \"wrap_pthread_create\" within our own dylib.\n+  Dl_info info_pthread_create;\n+  void *dlopen_addr = dlsym(RTLD_DEFAULT, \"pthread_create\");\n+  RAW_CHECK(dladdr(dlopen_addr, &info_pthread_create));\n+  if (internal_strcmp(info.dli_fname, info_pthread_create.dli_fname) != 0) {\n+    Report(\n+        \"ERROR: Interceptors are not working. This may be because %s is \"\n+        \"loaded too late (e.g. via dlopen). Please launch the executable \"\n+        \"with:\\n%s=%s\\n\",\n+        SanitizerToolName, kDyldInsertLibraries, info.dli_fname);\n+    RAW_CHECK(\"interceptors not installed\" && 0);\n+  }\n+\n+  if (!lib_is_in_env)\n+    return;\n+\n+  // DYLD_INSERT_LIBRARIES is set and contains the runtime library. Let's remove\n+  // the dylib from the environment variable, because interceptors are installed\n+  // and we don't want our children to inherit the variable.\n+\n+  uptr env_name_len = internal_strlen(kDyldInsertLibraries);\n+  // Allocate memory to hold the previous env var name, its value, the '='\n+  // sign and the '\\0' char.\n+  char *new_env = (char*)allocator_for_env.Allocate(\n+      old_env_len + 2 + env_name_len);\n+  RAW_CHECK(new_env);\n+  internal_memset(new_env, '\\0', old_env_len + 2 + env_name_len);\n+  internal_strncpy(new_env, kDyldInsertLibraries, env_name_len);\n+  new_env[env_name_len] = '=';\n+  char *new_env_pos = new_env + env_name_len + 1;\n+\n+  // Iterate over colon-separated pieces of |dyld_insert_libraries|.\n+  char *piece_start = dyld_insert_libraries;\n+  char *piece_end = NULL;\n+  char *old_env_end = dyld_insert_libraries + old_env_len;\n+  do {\n+    if (piece_start[0] == ':') piece_start++;\n+    piece_end = internal_strchr(piece_start, ':');\n+    if (!piece_end) piece_end = dyld_insert_libraries + old_env_len;\n+    if ((uptr)(piece_start - dyld_insert_libraries) > old_env_len) break;\n+    uptr piece_len = piece_end - piece_start;\n+\n+    char *filename_start =\n+        (char *)internal_memrchr(piece_start, '/', piece_len);\n+    uptr filename_len = piece_len;\n+    if (filename_start) {\n+      filename_start += 1;\n+      filename_len = piece_len - (filename_start - piece_start);\n+    } else {\n+      filename_start = piece_start;\n+    }\n+\n+    // If the current piece isn't the runtime library name,\n+    // append it to new_env.\n+    if ((dylib_name_len != filename_len) ||\n+        (internal_memcmp(filename_start, dylib_name, dylib_name_len) != 0)) {\n+      if (new_env_pos != new_env + env_name_len + 1) {\n+        new_env_pos[0] = ':';\n+        new_env_pos++;\n+      }\n+      internal_strncpy(new_env_pos, piece_start, piece_len);\n+      new_env_pos += piece_len;\n+    }\n+    // Move on to the next piece.\n+    piece_start = piece_end;\n+  } while (piece_start < old_env_end);\n+\n+  // Can't use setenv() here, because it requires the allocator to be\n+  // initialized.\n+  // FIXME: instead of filtering DYLD_INSERT_LIBRARIES here, do it in\n+  // a separate function called after InitializeAllocator().\n+  if (new_env_pos == new_env + env_name_len + 1) new_env = NULL;\n+  LeakyResetEnv(kDyldInsertLibraries, new_env);\n+}\n+#endif  // SANITIZER_GO\n+\n+char **GetArgv() {\n+  return *_NSGetArgv();\n+}\n+\n+uptr FindAvailableMemoryRange(uptr shadow_size,\n+                              uptr alignment,\n+                              uptr left_padding) {\n+  typedef vm_region_submap_short_info_data_64_t RegionInfo;\n+  enum { kRegionInfoSize = VM_REGION_SUBMAP_SHORT_INFO_COUNT_64 };\n+  // Start searching for available memory region past PAGEZERO, which is\n+  // 4KB on 32-bit and 4GB on 64-bit.\n+  mach_vm_address_t start_address =\n+    (SANITIZER_WORDSIZE == 32) ? 0x000000001000 : 0x000100000000;\n+\n+  mach_vm_address_t address = start_address;\n+  mach_vm_address_t free_begin = start_address;\n+  kern_return_t kr = KERN_SUCCESS;\n+  while (kr == KERN_SUCCESS) {\n+    mach_vm_size_t vmsize = 0;\n+    natural_t depth = 0;\n+    RegionInfo vminfo;\n+    mach_msg_type_number_t count = kRegionInfoSize;\n+    kr = mach_vm_region_recurse(mach_task_self(), &address, &vmsize, &depth,\n+                                (vm_region_info_t)&vminfo, &count);\n+    if (free_begin != address) {\n+      // We found a free region [free_begin..address-1].\n+      uptr shadow_address = RoundUpTo((uptr)free_begin + left_padding,\n+                                      alignment);\n+      if (shadow_address + shadow_size < (uptr)address) {\n+        return shadow_address;\n+      }\n+    }\n+    // Move to the next region.\n+    address += vmsize;\n+    free_begin = address;\n+  }\n+\n+  // We looked at all free regions and could not find one large enough.\n+  return 0;\n+}\n+\n+// FIXME implement on this platform.\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) { }\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_MAC"}, {"sha": "4bea069189f94d41418a6741031e62ce635b63cc", "filename": "libsanitizer/sanitizer_common/sanitizer_mac.h", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_mac.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -11,6 +11,7 @@\n #ifndef SANITIZER_MAC_H\n #define SANITIZER_MAC_H\n \n+#include \"sanitizer_common.h\"\n #include \"sanitizer_platform.h\"\n #if SANITIZER_MAC\n #include \"sanitizer_posix.h\"\n@@ -35,5 +36,22 @@ char **GetEnviron();\n \n }  // namespace __sanitizer\n \n+extern \"C\" {\n+static char __crashreporter_info_buff__[__sanitizer::kErrorMessageBufferSize] =\n+  {};\n+static const char *__crashreporter_info__ __attribute__((__used__)) =\n+  &__crashreporter_info_buff__[0];\n+asm(\".desc ___crashreporter_info__, 0x10\");\n+} // extern \"C\"\n+\n+namespace __sanitizer {\n+static BlockingMutex crashreporter_info_mutex(LINKER_INITIALIZED);\n+\n+INLINE void CRAppendCrashLogMessage(const char *msg) {\n+  BlockingMutexLock l(&crashreporter_info_mutex);\n+  internal_strlcat(__crashreporter_info_buff__, msg,\n+                   sizeof(__crashreporter_info_buff__)); }\n+}  // namespace __sanitizer\n+\n #endif  // SANITIZER_MAC\n #endif  // SANITIZER_MAC_H"}, {"sha": "93fb19e922cd9d4ca293b0b930b497ab7fb3dc1d", "filename": "libsanitizer/sanitizer_common/sanitizer_malloc_mac.inc", "status": "modified", "additions": 8, "deletions": 18, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_malloc_mac.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -25,7 +25,7 @@\n #include \"sanitizer_common/sanitizer_mac.h\"\n \n // Similar code is used in Google Perftools,\n-// http://code.google.com/p/google-perftools.\n+// https://github.com/gperftools/gperftools.\n \n static malloc_zone_t sanitizer_zone;\n \n@@ -54,7 +54,7 @@ INTERCEPTOR(malloc_zone_t *, malloc_default_zone, void) {\n \n INTERCEPTOR(malloc_zone_t *, malloc_default_purgeable_zone, void) {\n   // FIXME: ASan should support purgeable allocations.\n-  // https://code.google.com/p/address-sanitizer/issues/detail?id=139\n+  // https://github.com/google/sanitizers/issues/139\n   COMMON_MALLOC_ENTER();\n   return &sanitizer_zone;\n }\n@@ -182,28 +182,18 @@ void *__sanitizer_mz_valloc(malloc_zone_t *zone, size_t size) {\n   return p;\n }\n \n-#define GET_ZONE_FOR_PTR(ptr) \\\n-  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n-  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n-\n-void ALWAYS_INLINE free_common(void *context, void *ptr) {\n-  if (!ptr) return;\n-  // FIXME: need to retire this flag.\n-  if (!COMMON_MALLOC_IGNORE_INVALID_FREE) {\n-    COMMON_MALLOC_FREE(ptr);\n-  } else {\n-    GET_ZONE_FOR_PTR(ptr);\n-    COMMON_MALLOC_REPORT_FREE_UNALLOCATED(ptr, zone_ptr, zone_name);\n-  }\n-}\n-\n // TODO(glider): the allocation callbacks need to be refactored.\n extern \"C\"\n SANITIZER_INTERFACE_ATTRIBUTE\n void __sanitizer_mz_free(malloc_zone_t *zone, void *ptr) {\n-  free_common(zone, ptr);\n+  if (!ptr) return;\n+  COMMON_MALLOC_FREE(ptr);\n }\n \n+#define GET_ZONE_FOR_PTR(ptr) \\\n+  malloc_zone_t *zone_ptr = malloc_zone_from_ptr(ptr); \\\n+  const char *zone_name = (zone_ptr == 0) ? 0 : zone_ptr->zone_name\n+\n extern \"C\"\n SANITIZER_INTERFACE_ATTRIBUTE\n void *__sanitizer_mz_realloc(malloc_zone_t *zone, void *ptr, size_t new_size) {"}, {"sha": "428709d55ec33767cca3704805ffeff9ff8d5845", "filename": "libsanitizer/sanitizer_common/sanitizer_platform.h", "status": "modified", "additions": 101, "deletions": 10, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -47,12 +47,30 @@\n # define SANITIZER_IOSSIM  0\n #endif\n \n+#if defined(__APPLE__) && TARGET_OS_IPHONE && TARGET_OS_WATCH\n+# define SANITIZER_WATCHOS 1\n+#else\n+# define SANITIZER_WATCHOS 0\n+#endif\n+\n+#if defined(__APPLE__) && TARGET_OS_IPHONE && TARGET_OS_TV\n+# define SANITIZER_TVOS 1\n+#else\n+# define SANITIZER_TVOS 0\n+#endif\n+\n #if defined(_WIN32)\n # define SANITIZER_WINDOWS 1\n #else\n # define SANITIZER_WINDOWS 0\n #endif\n \n+#if defined(_WIN64)\n+# define SANITIZER_WINDOWS64 1\n+#else\n+# define SANITIZER_WINDOWS64 0\n+#endif\n+\n #if defined(__ANDROID__)\n # define SANITIZER_ANDROID 1\n #else\n@@ -79,14 +97,67 @@\n # define SANITIZER_X32 0\n #endif\n \n-// VMA size definition for architecture that support multiple sizes.\n-// AArch64 has 3 VMA sizes: 39, 42 and 48.\n-#if !defined(SANITIZER_AARCH64_VMA)\n-# define SANITIZER_AARCH64_VMA 39\n+#if defined(__mips__)\n+# define SANITIZER_MIPS 1\n+# if defined(__mips64)\n+#  define SANITIZER_MIPS32 0\n+#  define SANITIZER_MIPS64 1\n+# else\n+#  define SANITIZER_MIPS32 1\n+#  define SANITIZER_MIPS64 0\n+# endif\n #else\n-# if SANITIZER_AARCH64_VMA != 39 && SANITIZER_AARCH64_VMA != 42\n-#  error \"invalid SANITIZER_AARCH64_VMA size\"\n+# define SANITIZER_MIPS 0\n+# define SANITIZER_MIPS32 0\n+# define SANITIZER_MIPS64 0\n+#endif\n+\n+#if defined(__s390__)\n+# define SANITIZER_S390 1\n+# if defined(__s390x__)\n+#  define SANITIZER_S390_31 0\n+#  define SANITIZER_S390_64 1\n+# else\n+#  define SANITIZER_S390_31 1\n+#  define SANITIZER_S390_64 0\n+# endif\n+#else\n+# define SANITIZER_S390 0\n+# define SANITIZER_S390_31 0\n+# define SANITIZER_S390_64 0\n+#endif\n+\n+#if defined(__powerpc__)\n+# define SANITIZER_PPC 1\n+# if defined(__powerpc64__)\n+#  define SANITIZER_PPC32 0\n+#  define SANITIZER_PPC64 1\n+// 64-bit PPC has two ABIs (v1 and v2).  The old powerpc64 target is\n+// big-endian, and uses v1 ABI (known for its function descriptors),\n+// while the new powerpc64le target is little-endian and uses v2.\n+// In theory, you could convince gcc to compile for their evil twins\n+// (eg. big-endian v2), but you won't find such combinations in the wild\n+// (it'd require bootstrapping a whole system, which would be quite painful\n+// - there's no target triple for that).  LLVM doesn't support them either.\n+#  if _CALL_ELF == 2\n+#   define SANITIZER_PPC64V1 0\n+#   define SANITIZER_PPC64V2 1\n+#  else\n+#   define SANITIZER_PPC64V1 1\n+#   define SANITIZER_PPC64V2 0\n+#  endif\n+# else\n+#  define SANITIZER_PPC32 1\n+#  define SANITIZER_PPC64 0\n+#  define SANITIZER_PPC64V1 0\n+#  define SANITIZER_PPC64V2 0\n # endif\n+#else\n+# define SANITIZER_PPC 0\n+# define SANITIZER_PPC32 0\n+# define SANITIZER_PPC64 0\n+# define SANITIZER_PPC64V1 0\n+# define SANITIZER_PPC64V2 0\n #endif\n \n // By default we allow to use SizeClassAllocator64 on 64-bit platform.\n@@ -95,7 +166,9 @@\n // For such platforms build this code with -DSANITIZER_CAN_USE_ALLOCATOR64=0 or\n // change the definition of SANITIZER_CAN_USE_ALLOCATOR64 here.\n #ifndef SANITIZER_CAN_USE_ALLOCATOR64\n-# if defined(__mips64) || defined(__aarch64__)\n+# if SANITIZER_ANDROID && defined(__aarch64__)\n+#  define SANITIZER_CAN_USE_ALLOCATOR64 1\n+# elif defined(__mips64) || defined(__aarch64__)\n #  define SANITIZER_CAN_USE_ALLOCATOR64 0\n # else\n #  define SANITIZER_CAN_USE_ALLOCATOR64 (SANITIZER_WORDSIZE == 64)\n@@ -107,6 +180,8 @@\n // will still work but will consume more memory for TwoLevelByteMap.\n #if defined(__mips__)\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 40)\n+#elif defined(__aarch64__)\n+# define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 48)\n #else\n # define SANITIZER_MMAP_RANGE_SIZE FIRST_32_SECOND_64(1ULL << 32, 1ULL << 47)\n #endif\n@@ -135,10 +210,8 @@\n #define SANITIZER_USES_UID16_SYSCALLS 0\n #endif\n \n-#if defined(__mips__) || (defined(__aarch64__) && SANITIZER_AARCH64_VMA == 39)\n+#if defined(__mips__)\n # define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 10)\n-#elif defined(__aarch64__) && SANITIZER_AARCH64_VMA == 42\n-# define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 11)\n #else\n # define SANITIZER_POINTER_FORMAT_LENGTH FIRST_32_SECOND_64(8, 12)\n #endif\n@@ -160,4 +233,22 @@\n # define MSC_PREREQ(version) 0\n #endif\n \n+#if defined(__arm64__) && SANITIZER_IOS\n+# define SANITIZER_NON_UNIQUE_TYPEINFO 1\n+#else\n+# define SANITIZER_NON_UNIQUE_TYPEINFO 0\n+#endif\n+\n+// On linux, some architectures had an ABI transition from 64-bit long double\n+// (ie. same as double) to 128-bit long double.  On those, glibc symbols\n+// involving long doubles come in two versions, and we need to pass the\n+// correct one to dlvsym when intercepting them.\n+#if SANITIZER_LINUX && (SANITIZER_S390 || SANITIZER_PPC32 || SANITIZER_PPC64V1)\n+#define SANITIZER_NLDBL_VERSION \"GLIBC_2.4\"\n+#endif\n+\n+#if SANITIZER_GO == 0\n+# define SANITIZER_GO 0\n+#endif\n+\n #endif // SANITIZER_PLATFORM_H"}, {"sha": "2a8860581870f203e6f2b8be9ab3d979d57148da", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_interceptors.h", "status": "modified", "additions": 52, "deletions": 3, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_interceptors.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -27,6 +27,12 @@\n # define SI_LINUX_NOT_ANDROID 0\n #endif\n \n+#if SANITIZER_ANDROID\n+# define SI_ANDROID 1\n+#else\n+# define SI_ANDROID 0\n+#endif\n+\n #if SANITIZER_FREEBSD\n # define SI_FREEBSD 1\n #else\n@@ -41,8 +47,10 @@\n \n #if SANITIZER_MAC\n # define SI_MAC 1\n+# define SI_NOT_MAC 0\n #else\n # define SI_MAC 0\n+# define SI_NOT_MAC 1\n #endif\n \n #if SANITIZER_IOS\n@@ -51,14 +59,30 @@\n # define SI_IOS 0\n #endif\n \n+#if !SANITIZER_WINDOWS && !SANITIZER_MAC\n+# define SI_UNIX_NOT_MAC 1\n+#else\n+# define SI_UNIX_NOT_MAC 0\n+#endif\n+\n+#define SANITIZER_INTERCEPT_STRLEN 1\n+#define SANITIZER_INTERCEPT_STRNLEN SI_NOT_MAC\n #define SANITIZER_INTERCEPT_STRCMP 1\n #define SANITIZER_INTERCEPT_STRSTR 1\n #define SANITIZER_INTERCEPT_STRCASESTR SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_STRCHR 1\n+#define SANITIZER_INTERCEPT_STRCHRNUL SI_UNIX_NOT_MAC\n+#define SANITIZER_INTERCEPT_STRRCHR 1\n #define SANITIZER_INTERCEPT_STRSPN 1\n #define SANITIZER_INTERCEPT_STRPBRK 1\n #define SANITIZER_INTERCEPT_TEXTDOMAIN SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_STRCASECMP SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_MEMSET 1\n+#define SANITIZER_INTERCEPT_MEMMOVE 1\n+#define SANITIZER_INTERCEPT_MEMCPY 1\n #define SANITIZER_INTERCEPT_MEMCMP 1\n+// FIXME: enable memmem on Windows.\n+#define SANITIZER_INTERCEPT_MEMMEM SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MEMCHR 1\n #define SANITIZER_INTERCEPT_MEMRCHR SI_FREEBSD || SI_LINUX\n \n@@ -123,15 +147,21 @@\n #define SANITIZER_INTERCEPT_ACCEPT4 SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_MODF SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_RECVMSG SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SENDMSG SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETPEERNAME SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_IOCTL SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_INET_ATON SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SYSINFO SI_LINUX\n #define SANITIZER_INTERCEPT_READDIR SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_READDIR64 SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_PTRACE SI_LINUX_NOT_ANDROID && \\\n+#if SI_LINUX_NOT_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n+    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+    defined(__s390__))\n+#define SANITIZER_INTERCEPT_PTRACE 1\n+#else\n+#define SANITIZER_INTERCEPT_PTRACE 0\n+#endif\n #define SANITIZER_INTERCEPT_SETLOCALE SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GETCWD SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_GET_CURRENT_DIR_NAME SI_LINUX_NOT_ANDROID\n@@ -203,6 +233,7 @@\n #define SANITIZER_INTERCEPT_PTHREAD_BARRIERATTR_GETPSHARED SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_TMPNAM SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_TMPNAM_R SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT_TTYNAME_R SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_TEMPNAM SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_SINCOS SI_LINUX\n #define SANITIZER_INTERCEPT_REMQUO SI_NOT_WINDOWS\n@@ -235,7 +266,11 @@\n #define SANITIZER_INTERCEPT_IF_INDEXTONAME \\\n   SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_CAPGET SI_LINUX_NOT_ANDROID\n-#define SANITIZER_INTERCEPT_AEABI_MEM SI_LINUX && defined(__arm__)\n+#if SI_LINUX && defined(__arm__)\n+#define SANITIZER_INTERCEPT_AEABI_MEM 1\n+#else\n+#define SANITIZER_INTERCEPT_AEABI_MEM 0\n+#endif\n #define SANITIZER_INTERCEPT___BZERO SI_MAC\n #define SANITIZER_INTERCEPT_FTIME !SI_FREEBSD && SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_XDR SI_LINUX_NOT_ANDROID\n@@ -247,8 +282,12 @@\n #define SANITIZER_INTERCEPT_OBSTACK SI_LINUX_NOT_ANDROID\n #define SANITIZER_INTERCEPT_FFLUSH SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_FCLOSE SI_NOT_WINDOWS\n+\n+#ifndef SANITIZER_INTERCEPT_DLOPEN_DLCLOSE\n #define SANITIZER_INTERCEPT_DLOPEN_DLCLOSE \\\n     SI_FREEBSD || SI_LINUX_NOT_ANDROID || SI_MAC\n+#endif\n+\n #define SANITIZER_INTERCEPT_GETPASS SI_LINUX_NOT_ANDROID || SI_MAC\n #define SANITIZER_INTERCEPT_TIMERFD SI_LINUX_NOT_ANDROID\n \n@@ -258,7 +297,17 @@\n #define SANITIZER_INTERCEPT_PTHREAD_SETCANCEL SI_NOT_WINDOWS\n #define SANITIZER_INTERCEPT_MINCORE SI_LINUX\n #define SANITIZER_INTERCEPT_PROCESS_VM_READV SI_LINUX\n+#define SANITIZER_INTERCEPT_CTERMID SI_LINUX || SI_MAC || SI_FREEBSD\n+#define SANITIZER_INTERCEPT_CTERMID_R SI_MAC || SI_FREEBSD\n \n #define SANITIZER_INTERCEPTOR_HOOKS SI_LINUX\n+#define SANITIZER_INTERCEPT_RECV_RECVFROM SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_SEND_SENDTO SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT_EVENTFD_READ_WRITE SI_LINUX\n \n+#define SANITIZER_INTERCEPT_STAT (SI_FREEBSD || SI_MAC || SI_ANDROID)\n+#define SANITIZER_INTERCEPT___XSTAT !SANITIZER_INTERCEPT_STAT && SI_NOT_WINDOWS\n+#define SANITIZER_INTERCEPT___XSTAT64 SI_LINUX_NOT_ANDROID\n+#define SANITIZER_INTERCEPT___LXSTAT SANITIZER_INTERCEPT___XSTAT\n+#define SANITIZER_INTERCEPT___LXSTAT64 SI_LINUX_NOT_ANDROID\n #endif  // #ifndef SANITIZER_PLATFORM_INTERCEPTORS_H"}, {"sha": "edc67301935916903ebd111557aed391f48bd4ce", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_linux.cc", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -26,7 +26,7 @@\n // With old kernels (and even new kernels on powerpc) asm/stat.h uses types that\n // are not defined anywhere in userspace headers. Fake them. This seems to work\n // fine with newer headers, too.\n-#include <asm/posix_types.h>\n+#include <linux/posix_types.h>\n #if defined(__x86_64__) ||  defined(__mips__)\n #include <sys/stat.h>\n #else\n@@ -36,7 +36,6 @@\n #define uid_t __kernel_uid_t\n #define gid_t __kernel_gid_t\n #define off_t __kernel_off_t\n-#define time_t __kernel_time_t\n // This header seems to contain the definitions of _kernel_ stat* structs.\n #include <asm/stat.h>\n #undef ino_t\n@@ -54,14 +53,16 @@\n #include <linux/perf_event.h>\n #endif\n \n+using namespace __sanitizer;\n+\n namespace __sanitizer {\n #if !SANITIZER_ANDROID\n   unsigned struct_statfs64_sz = sizeof(struct statfs64);\n #endif\n }  // namespace __sanitizer\n \n #if !defined(__powerpc64__) && !defined(__x86_64__) && !defined(__aarch64__)\\\n-                            && !defined(__mips__) && !defined(__sparc__)\n+                            && !defined(__mips__) && !defined(__s390__)\n COMPILER_CHECK(struct___old_kernel_stat_sz == sizeof(struct __old_kernel_stat));\n #endif\n "}, {"sha": "7bf76c4e7152444f7288f1010c22b731424e5378", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.cc", "status": "modified", "additions": 25, "deletions": 6, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -121,6 +121,10 @@\n #  include <asm/ptrace.h>\n #  ifdef __arm__\n typedef struct user_fpregs elf_fpregset_t;\n+#   define ARM_VFPREGS_SIZE_ASAN (32 * 8 /*fpregs*/ + 4 /*fpscr*/)\n+#   if !defined(ARM_VFPREGS_SIZE)\n+#     define ARM_VFPREGS_SIZE ARM_VFPREGS_SIZE_ASAN\n+#   endif\n #  endif\n # endif\n # include <semaphore.h>\n@@ -305,23 +309,28 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n     (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-      defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n+      defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+      defined(__s390__))\n #if defined(__mips64) || defined(__powerpc64__) || defined(__arm__)\n   unsigned struct_user_regs_struct_sz = sizeof(struct pt_regs);\n   unsigned struct_user_fpregs_struct_sz = sizeof(elf_fpregset_t);\n #elif defined(__aarch64__)\n   unsigned struct_user_regs_struct_sz = sizeof(struct user_pt_regs);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpsimd_state);\n+#elif defined(__s390__)\n+  unsigned struct_user_regs_struct_sz = sizeof(struct _user_regs_struct);\n+  unsigned struct_user_fpregs_struct_sz = sizeof(struct _user_fpregs_struct);\n #else\n   unsigned struct_user_regs_struct_sz = sizeof(struct user_regs_struct);\n   unsigned struct_user_fpregs_struct_sz = sizeof(struct user_fpregs_struct);\n #endif // __mips64 || __powerpc64__ || __aarch64__\n #if defined(__x86_64) || defined(__mips64) || defined(__powerpc64__) || \\\n-    defined(__aarch64__) || defined(__arm__)\n+    defined(__aarch64__) || defined(__arm__) || defined(__s390__)\n   unsigned struct_user_fpxregs_struct_sz = 0;\n #else\n   unsigned struct_user_fpxregs_struct_sz = sizeof(struct user_fpxregs_struct);\n #endif // __x86_64 || __mips64 || __powerpc64__ || __aarch64__ || __arm__\n+// || __s390__\n #ifdef __arm__\n   unsigned struct_user_vfpregs_struct_sz = ARM_VFPREGS_SIZE;\n #else\n@@ -926,6 +935,8 @@ unsigned struct_ElfW_Phdr_sz = sizeof(Elf_Phdr);\n   const int si_SEGV_ACCERR = SEGV_ACCERR;\n } // namespace __sanitizer\n \n+using namespace __sanitizer;\n+\n COMPILER_CHECK(sizeof(__sanitizer_pthread_attr_t) >= sizeof(pthread_attr_t));\n \n COMPILER_CHECK(sizeof(socklen_t) == sizeof(unsigned));\n@@ -1049,8 +1060,15 @@ COMPILER_CHECK(sizeof(__sanitizer_sigaction) == sizeof(struct sigaction));\n // Can't write checks for sa_handler and sa_sigaction due to them being\n // preprocessor macros.\n CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_mask);\n+#ifndef __GLIBC_PREREQ\n+#define __GLIBC_PREREQ(x, y) 0\n+#endif\n+#if !defined(__s390x__) || __GLIBC_PREREQ (2, 20)\n+// On s390x glibc 2.19 and earlier sa_flags was unsigned long, and sa_resv\n+// didn't exist.\n CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_flags);\n-#if SANITIZER_LINUX\n+#endif\n+#if SANITIZER_LINUX && (!SANITIZER_ANDROID || !SANITIZER_MIPS32)\n CHECK_STRUCT_SIZE_AND_OFFSET(sigaction, sa_restorer);\n #endif\n \n@@ -1121,9 +1139,6 @@ CHECK_SIZE_AND_OFFSET(ipc_perm, uid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, gid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, cuid);\n CHECK_SIZE_AND_OFFSET(ipc_perm, cgid);\n-#ifndef __GLIBC_PREREQ\n-#define __GLIBC_PREREQ(x, y) 0\n-#endif\n #if !defined(__aarch64__) || !SANITIZER_LINUX || __GLIBC_PREREQ (2, 21)\n /* On aarch64 glibc 2.20 and earlier provided incorrect mode field.  */\n CHECK_SIZE_AND_OFFSET(ipc_perm, mode);\n@@ -1262,4 +1277,8 @@ CHECK_SIZE_AND_OFFSET(cookie_io_functions_t, close);\n CHECK_TYPE_SIZE(sem_t);\n #endif\n \n+#if SANITIZER_LINUX && defined(__arm__)\n+COMPILER_CHECK(ARM_VFPREGS_SIZE == ARM_VFPREGS_SIZE_ASAN);\n+#endif\n+\n #endif // SANITIZER_LINUX || SANITIZER_FREEBSD || SANITIZER_MAC"}, {"sha": "17906d303368a1b8929d05740059ceec0acaadbf", "filename": "libsanitizer/sanitizer_common/sanitizer_platform_limits_posix.h", "status": "modified", "additions": 47, "deletions": 65, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_platform_limits_posix.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -18,7 +18,7 @@\n \n #if SANITIZER_FREEBSD\n // FreeBSD's dlopen() returns a pointer to an Obj_Entry structure that\n-// incroporates the map structure.\n+// incorporates the map structure.\n # define GET_LINK_MAP_BY_DLOPEN_HANDLE(handle) \\\n     ((link_map*)((handle) == nullptr ? nullptr : ((char*)(handle) + 544)))\n #else\n@@ -75,20 +75,16 @@ namespace __sanitizer {\n   const unsigned struct_kernel_stat_sz = 144;\n   const unsigned struct_kernel_stat64_sz = 104;\n #elif defined(__mips__)\n-  #if SANITIZER_WORDSIZE == 64\n-  const unsigned struct_kernel_stat_sz = 216;\n-  #else\n-  const unsigned struct_kernel_stat_sz = 144;\n-  #endif\n+  const unsigned struct_kernel_stat_sz =\n+                 SANITIZER_ANDROID ? FIRST_32_SECOND_64(104, 128) :\n+                                     FIRST_32_SECOND_64(144, 216);\n   const unsigned struct_kernel_stat64_sz = 104;\n-#elif defined(__sparc__) && defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n-  const unsigned struct_kernel_stat_sz = 104;\n-  const unsigned struct_kernel_stat64_sz = 144;\n-#elif defined(__sparc__) && !defined(__arch64__)\n-  const unsigned struct___old_kernel_stat_sz = 0;\n+#elif defined(__s390__) && !defined(__s390x__)\n   const unsigned struct_kernel_stat_sz = 64;\n   const unsigned struct_kernel_stat64_sz = 104;\n+#elif defined(__s390x__)\n+  const unsigned struct_kernel_stat_sz = 144;\n+  const unsigned struct_kernel_stat64_sz = 0;\n #endif\n   struct __sanitizer_perf_event_attr {\n     unsigned type;\n@@ -109,9 +105,9 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX || SANITIZER_FREEBSD\n \n-#if defined(__powerpc64__)\n+#if defined(__powerpc64__) || defined(__s390__)\n   const unsigned struct___old_kernel_stat_sz = 0;\n-#elif !defined(__sparc__)\n+#else\n   const unsigned struct___old_kernel_stat_sz = 32;\n #endif\n \n@@ -196,24 +192,12 @@ namespace __sanitizer {\n     unsigned __seq;\n     u64 __unused1;\n     u64 __unused2;\n-#elif defined(__mips__) || defined(__aarch64__)\n+#elif defined(__mips__) || defined(__aarch64__) || defined(__s390x__)\n     unsigned int mode;\n     unsigned short __seq;\n     unsigned short __pad1;\n     unsigned long __unused1;\n     unsigned long __unused2;\n-#elif defined(__sparc__)\n-# if defined(__arch64__)\n-    unsigned mode;\n-    unsigned short __pad1;\n-# else\n-    unsigned short __pad1;\n-    unsigned short mode;\n-    unsigned short __pad2;\n-# endif\n-    unsigned short __seq;\n-    unsigned long long __unused1;\n-    unsigned long long __unused2;\n #else\n     unsigned short mode;\n     unsigned short __pad1;\n@@ -231,26 +215,6 @@ namespace __sanitizer {\n \n   struct __sanitizer_shmid_ds {\n     __sanitizer_ipc_perm shm_perm;\n-  #if defined(__sparc__)\n-  # if !defined(__arch64__)\n-    u32 __pad1;\n-  # endif\n-    long shm_atime;\n-  # if !defined(__arch64__)\n-    u32 __pad2;\n-  # endif\n-    long shm_dtime;\n-  # if !defined(__arch64__)\n-    u32 __pad3;\n-  # endif\n-    long shm_ctime;\n-    uptr shm_segsz;\n-    int shm_cpid;\n-    int shm_lpid;\n-    unsigned long shm_nattch;\n-    unsigned long __glibc_reserved1;\n-    unsigned long __glibc_reserved2;\n-  #else    \n   #ifndef __powerpc__\n     uptr shm_segsz;\n   #elif !defined(__powerpc64__)\n@@ -288,7 +252,6 @@ namespace __sanitizer {\n     uptr __unused4;\n     uptr __unused5;\n   #endif\n-#endif\n   };\n #elif SANITIZER_FREEBSD\n   struct __sanitizer_ipc_perm {\n@@ -555,7 +518,11 @@ namespace __sanitizer {\n   };\n \n #if SANITIZER_ANDROID\n+# if SANITIZER_MIPS\n+  typedef unsigned long __sanitizer_sigset_t[16/sizeof(unsigned long)];\n+# else\n   typedef unsigned long __sanitizer_sigset_t;\n+# endif\n #elif SANITIZER_MAC\n   typedef unsigned __sanitizer_sigset_t;\n #elif SANITIZER_LINUX\n@@ -581,6 +548,15 @@ namespace __sanitizer {\n     __sanitizer_sigset_t sa_mask;\n     void (*sa_restorer)();\n   };\n+#elif SANITIZER_ANDROID && SANITIZER_MIPS32  // check this before WORDSIZE == 32\n+  struct __sanitizer_sigaction {\n+    unsigned sa_flags;\n+    union {\n+      void (*sigaction)(int sig, void *siginfo, void *uctx);\n+      void (*handler)(int sig);\n+    };\n+    __sanitizer_sigset_t sa_mask;\n+  };\n #elif SANITIZER_ANDROID && (SANITIZER_WORDSIZE == 32)\n   struct __sanitizer_sigaction {\n     union {\n@@ -603,21 +579,24 @@ namespace __sanitizer {\n #if SANITIZER_FREEBSD\n     int sa_flags;\n     __sanitizer_sigset_t sa_mask;\n+#else\n+#if defined(__s390x__)\n+    int sa_resv;\n #else\n     __sanitizer_sigset_t sa_mask;\n+#endif\n #ifndef __mips__\n-#if defined(__sparc__)\n-    unsigned long sa_flags;\n-#else\n     int sa_flags;\n #endif\n #endif\n-#endif\n #if SANITIZER_LINUX\n     void (*sa_restorer)();\n #endif\n #if defined(__mips__) && (SANITIZER_WORDSIZE == 32)\n     int sa_resv[1];\n+#endif\n+#if defined(__s390x__)\n+    __sanitizer_sigset_t sa_mask;\n #endif\n   };\n #endif // !SANITIZER_ANDROID\n@@ -626,7 +605,7 @@ namespace __sanitizer {\n   typedef __sanitizer_sigset_t __sanitizer_kernel_sigset_t;\n #elif defined(__mips__)\n   struct __sanitizer_kernel_sigset_t {\n-    u8 sig[16];\n+    uptr sig[2];\n   };\n #else\n   struct __sanitizer_kernel_sigset_t {\n@@ -635,6 +614,17 @@ namespace __sanitizer {\n #endif\n \n   // Linux system headers define the 'sa_handler' and 'sa_sigaction' macros.\n+#if SANITIZER_MIPS\n+  struct __sanitizer_kernel_sigaction_t {\n+    unsigned int sa_flags;\n+    union {\n+      void (*handler)(int signo);\n+      void (*sigaction)(int signo, void *info, void *ctx);\n+    };\n+    __sanitizer_kernel_sigset_t sa_mask;\n+    void (*sa_restorer)(void);\n+  };\n+#else\n   struct __sanitizer_kernel_sigaction_t {\n     union {\n       void (*handler)(int signo);\n@@ -644,6 +634,7 @@ namespace __sanitizer {\n     void (*sa_restorer)(void);\n     __sanitizer_kernel_sigset_t sa_mask;\n   };\n+#endif\n \n   extern uptr sig_ign;\n   extern uptr sig_dfl;\n@@ -779,7 +770,8 @@ namespace __sanitizer {\n \n #if SANITIZER_LINUX && !SANITIZER_ANDROID && \\\n   (defined(__i386) || defined(__x86_64) || defined(__mips64) || \\\n-    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__))\n+    defined(__powerpc64__) || defined(__aarch64__) || defined(__arm__) || \\\n+    defined(__s390__))\n   extern unsigned struct_user_regs_struct_sz;\n   extern unsigned struct_user_fpregs_struct_sz;\n   extern unsigned struct_user_fpxregs_struct_sz;\n@@ -857,7 +849,7 @@ struct __sanitizer_cookie_io_functions_t {\n \n #define IOC_NRBITS 8\n #define IOC_TYPEBITS 8\n-#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__) || defined(__sparc__)\n+#if defined(__powerpc__) || defined(__powerpc64__) || defined(__mips__)\n #define IOC_SIZEBITS 13\n #define IOC_DIRBITS 3\n #define IOC_NONE 1U\n@@ -887,17 +879,7 @@ struct __sanitizer_cookie_io_functions_t {\n #define IOC_DIR(nr) (((nr) >> IOC_DIRSHIFT) & IOC_DIRMASK)\n #define IOC_TYPE(nr) (((nr) >> IOC_TYPESHIFT) & IOC_TYPEMASK)\n #define IOC_NR(nr) (((nr) >> IOC_NRSHIFT) & IOC_NRMASK)\n-\n-#if defined(__sparc__)\n-// In sparc the 14 bits SIZE field overlaps with the\n-// least significant bit of DIR, so either IOC_READ or\n-// IOC_WRITE shall be 1 in order to get a non-zero SIZE.\n-# define IOC_SIZE(nr)                       \\\n-  ((((((nr) >> 29) & 0x7) & (4U|2U)) == 0)? \\\n-   0 : (((nr) >> 16) & 0x3fff))\n-#else\n #define IOC_SIZE(nr) (((nr) >> IOC_SIZESHIFT) & IOC_SIZEMASK)\n-#endif\n \n   extern unsigned struct_ifreq_sz;\n   extern unsigned struct_termios_sz;"}, {"sha": "d10213d917f924b4e086e47affd8b9b8352b60b4", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.cc", "status": "modified", "additions": 42, "deletions": 21, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -87,7 +87,11 @@ static uptr GetKernelAreaSize() {\n \n uptr GetMaxVirtualAddress() {\n #if SANITIZER_WORDSIZE == 64\n-# if defined(__powerpc64__) || defined(__aarch64__)\n+# if defined(__aarch64__) && SANITIZER_IOS && !SANITIZER_IOSSIM\n+  // Ideally, we would derive the upper bound from MACH_VM_MAX_ADDRESS. The\n+  // upper bound can change depending on the device.\n+  return 0x200000000 - 1;\n+# elif defined(__powerpc64__) || defined(__aarch64__)\n   // On PowerPC64 we have two different address space layouts: 44- and 46-bit.\n   // We somehow need to figure out which one we are using now and choose\n   // one of 0x00000fffffffffffUL and 0x00003fffffffffffUL.\n@@ -98,26 +102,32 @@ uptr GetMaxVirtualAddress() {\n   return (1ULL << (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1)) - 1;\n # elif defined(__mips64)\n   return (1ULL << 40) - 1;  // 0x000000ffffffffffUL;\n+# elif defined(__s390x__)\n+  return (1ULL << 53) - 1;  // 0x001fffffffffffffUL;\n # else\n   return (1ULL << 47) - 1;  // 0x00007fffffffffffUL;\n # endif\n #else  // SANITIZER_WORDSIZE == 32\n+# if defined(__s390__)\n+  return (1ULL << 31) - 1;  // 0x7fffffff;\n+# else\n   uptr res = (1ULL << 32) - 1;  // 0xffffffff;\n   if (!common_flags()->full_address_space)\n     res -= GetKernelAreaSize();\n   CHECK_LT(reinterpret_cast<uptr>(&res), res);\n   return res;\n+# endif\n #endif  // SANITIZER_WORDSIZE\n }\n \n-void *MmapOrDie(uptr size, const char *mem_type) {\n+void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n   size = RoundUpTo(size, GetPageSizeCached());\n   uptr res = internal_mmap(nullptr, size,\n                            PROT_READ | PROT_WRITE,\n                            MAP_PRIVATE | MAP_ANON, -1, 0);\n   int reserrno;\n   if (internal_iserror(res, &reserrno))\n-    ReportMmapFailureAndDie(size, mem_type, \"allocate\", reserrno);\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\", reserrno, raw_report);\n   IncreaseTotalMmap(size);\n   return (void *)res;\n }\n@@ -133,6 +143,26 @@ void UnmapOrDie(void *addr, uptr size) {\n   DecreaseTotalMmap(size);\n }\n \n+// We want to map a chunk of address space aligned to 'alignment'.\n+// We do it by maping a bit more and then unmaping redundant pieces.\n+// We probably can do it with fewer syscalls in some OS-dependent way.\n+void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n+  CHECK(IsPowerOfTwo(size));\n+  CHECK(IsPowerOfTwo(alignment));\n+  uptr map_size = size + alignment;\n+  uptr map_res = (uptr)MmapOrDie(map_size, mem_type);\n+  uptr map_end = map_res + map_size;\n+  uptr res = map_res;\n+  if (res & (alignment - 1))  // Not aligned.\n+    res = (map_res + alignment) & ~(alignment - 1);\n+  uptr end = res + size;\n+  if (res != map_res)\n+    UnmapOrDie((void*)map_res, res - map_res);\n+  if (end != map_end)\n+    UnmapOrDie((void*)end, map_end - end);\n+  return (void*)res;\n+}\n+\n void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n   uptr PageSize = GetPageSizeCached();\n   uptr p = internal_mmap(nullptr,\n@@ -169,6 +199,10 @@ bool MprotectNoAccess(uptr addr, uptr size) {\n   return 0 == internal_mprotect((void*)addr, size, PROT_NONE);\n }\n \n+bool MprotectReadOnly(uptr addr, uptr size) {\n+  return 0 == internal_mprotect((void *)addr, size, PROT_READ);\n+}\n+\n fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *errno_p) {\n   int flags;\n   switch (mode) {\n@@ -313,26 +347,13 @@ bool GetCodeRangeForFile(const char *module, uptr *start, uptr *end) {\n }\n \n SignalContext SignalContext::Create(void *siginfo, void *context) {\n-  uptr addr = (uptr)((siginfo_t*)siginfo)->si_addr;\n+  auto si = (siginfo_t *)siginfo;\n+  uptr addr = (uptr)si->si_addr;\n   uptr pc, sp, bp;\n   GetPcSpBp(context, &pc, &sp, &bp);\n-  return SignalContext(context, addr, pc, sp, bp);\n-}\n-\n-// This function check is the built VMA matches the runtime one for\n-// architectures with multiple VMA size.\n-void CheckVMASize() {\n-#ifdef __aarch64__\n-  static const unsigned kBuiltVMA = SANITIZER_AARCH64_VMA;\n-  unsigned maxRuntimeVMA =\n-    (MostSignificantSetBitIndex(GET_CURRENT_FRAME()) + 1);\n-  if (kBuiltVMA != maxRuntimeVMA) {\n-    Printf(\"WARNING: %s runtime VMA is not the one built for.\\n\",\n-      SanitizerToolName);\n-    Printf(\"\\tBuilt VMA:   %u bits\\n\", kBuiltVMA);\n-    Printf(\"\\tRuntime VMA: %u bits\\n\", maxRuntimeVMA);\n-  }\n-#endif\n+  WriteFlag write_flag = GetWriteFlag(context);\n+  bool is_memory_access = si->si_signo == SIGSEGV;\n+  return SignalContext(context, addr, pc, sp, bp, is_memory_access, write_flag);\n }\n \n } // namespace __sanitizer"}, {"sha": "68b34babdeb8f87dcdd84c161ae05722beb4d007", "filename": "libsanitizer/sanitizer_common/sanitizer_posix.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -14,6 +14,7 @@\n // ----------- ATTENTION -------------\n // This header should NOT include any other headers from sanitizer runtime.\n #include \"sanitizer_internal_defs.h\"\n+#include \"sanitizer_platform_limits_posix.h\"\n \n #if !SANITIZER_POSIX\n // Make it hard to accidentally use any of functions declared in this file:\n@@ -52,6 +53,7 @@ uptr internal_ptrace(int request, int pid, void *addr, void *data);\n uptr internal_waitpid(int pid, int *status, int options);\n \n int internal_fork();\n+int internal_forkpty(int *amaster);\n \n // These functions call appropriate pthread_ functions directly, bypassing\n // the interceptor. They are weak and may not be present in some tools.\n@@ -74,8 +76,15 @@ int real_pthread_join(void *th, void **ret);\n \n int my_pthread_attr_getstack(void *attr, void **addr, uptr *size);\n \n+// A routine named real_sigaction() must be implemented by each sanitizer in\n+// order for internal_sigaction() to bypass interceptors.\n int internal_sigaction(int signum, const void *act, void *oldact);\n+void internal_sigfillset(__sanitizer_sigset_t *set);\n+void internal_sigemptyset(__sanitizer_sigset_t *set);\n+bool internal_sigismember(__sanitizer_sigset_t *set, int signum);\n \n+uptr internal_execve(const char *filename, char *const argv[],\n+                     char *const envp[]);\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_POSIX_H"}, {"sha": "335aad1660e5f0fc9d5977e94ae112d6c9d39a94", "filename": "libsanitizer/sanitizer_common/sanitizer_posix_libcdep.cc", "status": "modified", "additions": 101, "deletions": 6, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_posix_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -32,6 +32,7 @@\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n+#include <sys/wait.h>\n #include <unistd.h>\n \n #if SANITIZER_FREEBSD\n@@ -41,6 +42,8 @@\n #define MAP_NORESERVE 0\n #endif\n \n+typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n+\n namespace __sanitizer {\n \n u32 GetUid() {\n@@ -51,7 +54,7 @@ uptr GetThreadSelf() {\n   return (uptr)pthread_self();\n }\n \n-void FlushUnneededShadowMemory(uptr addr, uptr size) {\n+void ReleaseMemoryToOS(uptr addr, uptr size) {\n   madvise((void*)addr, size, MADV_DONTNEED);\n }\n \n@@ -95,6 +98,10 @@ bool StackSizeIsUnlimited() {\n   return (stack_size == RLIM_INFINITY);\n }\n \n+uptr GetStackSizeLimitInBytes() {\n+  return (uptr)getlim(RLIMIT_STACK);\n+}\n+\n void SetStackSizeLimitInBytes(uptr limit) {\n   setlim(RLIMIT_STACK, (rlim_t)limit);\n   CHECK(!StackSizeIsUnlimited());\n@@ -119,11 +126,21 @@ void SleepForMillis(int millis) {\n }\n \n void Abort() {\n+#if !SANITIZER_GO\n+  // If we are handling SIGABRT, unhandle it first.\n+  if (IsHandledDeadlySignal(SIGABRT)) {\n+    struct sigaction sigact;\n+    internal_memset(&sigact, 0, sizeof(sigact));\n+    sigact.sa_sigaction = (sa_sigaction_t)SIG_DFL;\n+    internal_sigaction(SIGABRT, &sigact, nullptr);\n+  }\n+#endif\n+\n   abort();\n }\n \n int Atexit(void (*function)(void)) {\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n   return atexit(function);\n #else\n   return 0;\n@@ -134,7 +151,7 @@ bool SupportsColoredOutput(fd_t fd) {\n   return isatty(fd) != 0;\n }\n \n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n // TODO(glider): different tools may require different altstack size.\n static const uptr kAltStackSize = SIGSTKSZ * 4;  // SIGSTKSZ is not enough.\n \n@@ -163,10 +180,9 @@ void UnsetAlternateSignalStack() {\n   UnmapOrDie(oldstack.ss_sp, oldstack.ss_size);\n }\n \n-typedef void (*sa_sigaction_t)(int, siginfo_t *, void *);\n static void MaybeInstallSigaction(int signum,\n                                   SignalHandlerType handler) {\n-  if (!IsDeadlySignal(signum))\n+  if (!IsHandledDeadlySignal(signum))\n     return;\n   struct sigaction sigact;\n   internal_memset(&sigact, 0, sizeof(sigact));\n@@ -188,6 +204,7 @@ void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n   MaybeInstallSigaction(SIGBUS, handler);\n   MaybeInstallSigaction(SIGABRT, handler);\n   MaybeInstallSigaction(SIGFPE, handler);\n+  MaybeInstallSigaction(SIGILL, handler);\n }\n #endif  // SANITIZER_GO\n \n@@ -266,7 +283,7 @@ void *MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n   return (void *)p;\n }\n \n-void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {\n+void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name) {\n   int fd = name ? GetNamedMappingFd(name, size) : -1;\n   unsigned flags = MAP_PRIVATE | MAP_FIXED | MAP_NORESERVE;\n   if (fd == -1) flags |= MAP_ANON;\n@@ -275,6 +292,11 @@ void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {\n                                0);\n }\n \n+void *MmapNoAccess(uptr size) {\n+  unsigned flags = MAP_PRIVATE | MAP_ANON | MAP_NORESERVE;\n+  return (void *)internal_mmap(nullptr, size, PROT_NONE, flags, -1, 0);\n+}\n+\n // This function is defined elsewhere if we intercepted pthread_attr_getstack.\n extern \"C\" {\n SANITIZER_WEAK_ATTRIBUTE int\n@@ -317,6 +339,79 @@ void AdjustStackSize(void *attr_) {\n }\n #endif // !SANITIZER_GO\n \n+pid_t StartSubprocess(const char *program, const char *const argv[],\n+                      fd_t stdin_fd, fd_t stdout_fd, fd_t stderr_fd) {\n+  auto file_closer = at_scope_exit([&] {\n+    if (stdin_fd != kInvalidFd) {\n+      internal_close(stdin_fd);\n+    }\n+    if (stdout_fd != kInvalidFd) {\n+      internal_close(stdout_fd);\n+    }\n+    if (stderr_fd != kInvalidFd) {\n+      internal_close(stderr_fd);\n+    }\n+  });\n+\n+  int pid = internal_fork();\n+\n+  if (pid < 0) {\n+    int rverrno;\n+    if (internal_iserror(pid, &rverrno)) {\n+      Report(\"WARNING: failed to fork (errno %d)\\n\", rverrno);\n+    }\n+    return pid;\n+  }\n+\n+  if (pid == 0) {\n+    // Child subprocess\n+    if (stdin_fd != kInvalidFd) {\n+      internal_close(STDIN_FILENO);\n+      internal_dup2(stdin_fd, STDIN_FILENO);\n+      internal_close(stdin_fd);\n+    }\n+    if (stdout_fd != kInvalidFd) {\n+      internal_close(STDOUT_FILENO);\n+      internal_dup2(stdout_fd, STDOUT_FILENO);\n+      internal_close(stdout_fd);\n+    }\n+    if (stderr_fd != kInvalidFd) {\n+      internal_close(STDERR_FILENO);\n+      internal_dup2(stderr_fd, STDERR_FILENO);\n+      internal_close(stderr_fd);\n+    }\n+\n+    for (int fd = sysconf(_SC_OPEN_MAX); fd > 2; fd--) internal_close(fd);\n+\n+    execv(program, const_cast<char **>(&argv[0]));\n+    internal__exit(1);\n+  }\n+\n+  return pid;\n+}\n+\n+bool IsProcessRunning(pid_t pid) {\n+  int process_status;\n+  uptr waitpid_status = internal_waitpid(pid, &process_status, WNOHANG);\n+  int local_errno;\n+  if (internal_iserror(waitpid_status, &local_errno)) {\n+    VReport(1, \"Waiting on the process failed (errno %d).\\n\", local_errno);\n+    return false;\n+  }\n+  return waitpid_status == 0;\n+}\n+\n+int WaitForProcess(pid_t pid) {\n+  int process_status;\n+  uptr waitpid_status = internal_waitpid(pid, &process_status, 0);\n+  int local_errno;\n+  if (internal_iserror(waitpid_status, &local_errno)) {\n+    VReport(1, \"Waiting on the process failed (errno %d).\\n\", local_errno);\n+    return -1;\n+  }\n+  return process_status;\n+}\n+\n } // namespace __sanitizer\n \n #endif // SANITIZER_POSIX"}, {"sha": "c11113da244ee58de5d729cbb3783c481a4c33e8", "filename": "libsanitizer/sanitizer_common/sanitizer_printf.cc", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_printf.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -211,7 +211,7 @@ SANITIZER_INTERFACE_ATTRIBUTE SANITIZER_WEAK_ATTRIBUTE\n void OnPrint(const char *str) {\n   (void)str;\n }\n-#elif defined(SANITIZER_GO) && defined(TSAN_EXTERNAL_HOOKS)\n+#elif SANITIZER_GO && defined(TSAN_EXTERNAL_HOOKS)\n void OnPrint(const char *str);\n #else\n void OnPrint(const char *str) {\n@@ -276,9 +276,12 @@ static void SharedPrintfCode(bool append_pid, const char *format,\n #   undef CHECK_NEEDED_LENGTH\n   }\n   RawWrite(buffer);\n-  if (common_flags()->log_to_syslog)\n-    WriteToSyslog(buffer);\n+\n+  // Remove color sequences from the message.\n+  RemoveANSIEscapeSequencesFromString(buffer);\n   CallPrintfAndReportCallback(buffer);\n+  LogMessageOnPrintf(buffer);\n+\n   // If we had mapped any memory, clean up.\n   if (buffer != local_buffer)\n     UnmapOrDie((void *)buffer, buffer_size);"}, {"sha": "0183a0941119a6b6bdc52a6d1a60933326f630b3", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps.h", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -41,9 +41,8 @@ class MemoryMappingLayout {\n   // instead of aborting.\n   static void CacheMemoryMappings();\n \n-  // Stores the list of mapped objects into an array.\n-  uptr DumpListOfModules(LoadedModule *modules, uptr max_modules,\n-                         string_predicate_t filter);\n+  // Adds all mapped objects into a vector.\n+  void DumpListOfModules(InternalMmapVector<LoadedModule> *modules);\n \n   // Memory protection masks.\n   static const uptr kProtectionRead = 1;"}, {"sha": "c725c2e7b6642e2678974375e042174583fbf23f", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_common.cc", "status": "modified", "additions": 8, "deletions": 14, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_common.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -114,22 +114,17 @@ void MemoryMappingLayout::LoadFromCache() {\n   }\n }\n \n-uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n-                                            uptr max_modules,\n-                                            string_predicate_t filter) {\n+void MemoryMappingLayout::DumpListOfModules(\n+    InternalMmapVector<LoadedModule> *modules) {\n   Reset();\n   uptr cur_beg, cur_end, cur_offset, prot;\n   InternalScopedString module_name(kMaxPathLength);\n-  uptr n_modules = 0;\n-  for (uptr i = 0; n_modules < max_modules &&\n-                       Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n-                            module_name.size(), &prot);\n+  for (uptr i = 0; Next(&cur_beg, &cur_end, &cur_offset, module_name.data(),\n+                        module_name.size(), &prot);\n        i++) {\n     const char *cur_name = module_name.data();\n     if (cur_name[0] == '\\0')\n       continue;\n-    if (filter && !filter(cur_name))\n-      continue;\n     // Don't subtract 'cur_beg' from the first entry:\n     // * If a binary is compiled w/o -pie, then the first entry in\n     //   process maps is likely the binary itself (all dynamic libs\n@@ -142,12 +137,11 @@ uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n     //   shadow memory of the tool), so the module can't be the\n     //   first entry.\n     uptr base_address = (i ? cur_beg : 0) - cur_offset;\n-    LoadedModule *cur_module = &modules[n_modules];\n-    cur_module->set(cur_name, base_address);\n-    cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n-    n_modules++;\n+    LoadedModule cur_module;\n+    cur_module.set(cur_name, base_address);\n+    cur_module.addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n+    modules->push_back(cur_module);\n   }\n-  return n_modules;\n }\n \n void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) {"}, {"sha": "10918e5439882cac517b5372cda27f5871622158", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_linux.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -65,7 +65,7 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n   while (IsDecimal(*current_))\n     current_++;\n   // Qemu may lack the trailing space.\n-  // http://code.google.com/p/address-sanitizer/issues/detail?id=160\n+  // https://github.com/google/sanitizers/issues/160\n   // CHECK_EQ(*current_++, ' ');\n   // Skip spaces.\n   while (current_ < next_line && *current_ == ' ')"}, {"sha": "81829a7c2842d0a393d958d190a50c43f4082d15", "filename": "libsanitizer/sanitizer_common/sanitizer_procmaps_mac.cc", "status": "modified", "additions": 10, "deletions": 16, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_procmaps_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -63,7 +63,7 @@ void MemoryMappingLayout::LoadFromCache() {\n }\n \n // Next and NextSegmentLoad were inspired by base/sysinfo.cc in\n-// Google Perftools, http://code.google.com/p/google-perftools.\n+// Google Perftools, https://github.com/gperftools/gperftools.\n \n // NextSegmentLoad scans the current image for the next segment load command\n // and returns the start and end addresses and file offset of the corresponding\n@@ -153,34 +153,28 @@ bool MemoryMappingLayout::Next(uptr *start, uptr *end, uptr *offset,\n   return false;\n }\n \n-uptr MemoryMappingLayout::DumpListOfModules(LoadedModule *modules,\n-                                            uptr max_modules,\n-                                            string_predicate_t filter) {\n+void MemoryMappingLayout::DumpListOfModules(\n+    InternalMmapVector<LoadedModule> *modules) {\n   Reset();\n   uptr cur_beg, cur_end, prot;\n   InternalScopedString module_name(kMaxPathLength);\n-  uptr n_modules = 0;\n-  for (uptr i = 0; n_modules < max_modules &&\n-                       Next(&cur_beg, &cur_end, 0, module_name.data(),\n-                            module_name.size(), &prot);\n+  for (uptr i = 0; Next(&cur_beg, &cur_end, 0, module_name.data(),\n+                        module_name.size(), &prot);\n        i++) {\n     const char *cur_name = module_name.data();\n     if (cur_name[0] == '\\0')\n       continue;\n-    if (filter && !filter(cur_name))\n-      continue;\n     LoadedModule *cur_module = nullptr;\n-    if (n_modules > 0 &&\n-        0 == internal_strcmp(cur_name, modules[n_modules - 1].full_name())) {\n-      cur_module = &modules[n_modules - 1];\n+    if (!modules->empty() &&\n+        0 == internal_strcmp(cur_name, modules->back().full_name())) {\n+      cur_module = &modules->back();\n     } else {\n-      cur_module = &modules[n_modules];\n+      modules->push_back(LoadedModule());\n+      cur_module = &modules->back();\n       cur_module->set(cur_name, cur_beg);\n-      n_modules++;\n     }\n     cur_module->addAddressRange(cur_beg, cur_end, prot & kProtectionExecute);\n   }\n-  return n_modules;\n }\n \n }  // namespace __sanitizer"}, {"sha": "9e9268f2a5d26b7e677270be717b4d57dff99747", "filename": "libsanitizer/sanitizer_common/sanitizer_quarantine.h", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_quarantine.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -99,10 +99,12 @@ class Quarantine {\n   void NOINLINE DoRecycle(Cache *c, Callback cb) {\n     while (QuarantineBatch *b = c->DequeueBatch()) {\n       const uptr kPrefetch = 16;\n+      CHECK(kPrefetch <= ARRAY_SIZE(b->batch));\n       for (uptr i = 0; i < kPrefetch; i++)\n         PREFETCH(b->batch[i]);\n-      for (uptr i = 0; i < b->count; i++) {\n-        PREFETCH(b->batch[i + kPrefetch]);\n+      for (uptr i = 0, count = b->count; i < count; i++) {\n+        if (i + kPrefetch < count)\n+          PREFETCH(b->batch[i + kPrefetch]);\n         cb.Recycle((Node*)b->batch[i]);\n       }\n       cb.Deallocate(b);"}, {"sha": "531f256c04898f116029c5d7543f9c5449e5101c", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.cc", "status": "modified", "additions": 11, "deletions": 8, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -38,11 +38,6 @@ void BufferedStackTrace::Init(const uptr *pcs, uptr cnt, uptr extra_top_pc) {\n   top_frame_bp = 0;\n }\n \n-// Check if given pointer points into allocated stack area.\n-static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n-  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);\n-}\n-\n // In GCC on ARM bp points to saved lr, not fp, so we should check the next\n // cell in stack to be a saved frame pointer. GetCanonicFrame returns the\n // pointer to saved frame pointer in any case.\n@@ -60,15 +55,16 @@ static inline uhwptr *GetCanonicFrame(uptr bp,\n   // Nope, this does not look right either. This means the frame after next does\n   // not have a valid frame pointer, but we can still extract the caller PC.\n   // Unfortunately, there is no way to decide between GCC and LLVM frame\n-  // layouts. Assume GCC.\n-  return bp_prev - 1;\n+  // layouts. Assume LLVM.\n+  return bp_prev;\n #else\n   return (uhwptr*)bp;\n #endif\n }\n \n void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n                                          uptr stack_bottom, u32 max_depth) {\n+  const uptr kPageSize = GetPageSizeCached();\n   CHECK_GE(max_depth, 2);\n   trace_buffer[0] = pc;\n   size = 1;\n@@ -90,9 +86,16 @@ void BufferedStackTrace::FastUnwindStack(uptr pc, uptr bp, uptr stack_top,\n         !IsAligned((uptr)caller_frame, sizeof(uhwptr)))\n       break;\n     uhwptr pc1 = caller_frame[2];\n+#elif defined(__s390__)\n+    uhwptr pc1 = frame[14];\n #else\n     uhwptr pc1 = frame[1];\n #endif\n+    // Let's assume that any pointer in the 0th page (i.e. <0x1000 on i386 and\n+    // x86_64) is invalid and stop unwinding here.  If we're adding support for\n+    // a platform where this isn't true, we need to reconsider this check.\n+    if (pc1 < kPageSize)\n+      break;\n     if (pc1 != pc) {\n       trace_buffer[size++] = (uptr) pc1;\n     }\n@@ -116,7 +119,7 @@ void BufferedStackTrace::PopStackFrames(uptr count) {\n uptr BufferedStackTrace::LocatePcInTrace(uptr pc) {\n   // Use threshold to find PC in stack trace, as PC we want to unwind from may\n   // slightly differ from return address in the actual unwinded stack trace.\n-  const int kPcThreshold = 304;\n+  const int kPcThreshold = 350;\n   for (uptr i = 0; i < size; ++i) {\n     if (MatchPc(pc, trace[i], kPcThreshold))\n       return i;"}, {"sha": "c59dbd558838da65979ed046c19bed320c616419", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace.h", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -27,7 +27,7 @@ static const u32 kStackTraceMax = 256;\n \n // Fast unwind is the only option on Mac for now; we will need to\n // revisit this macro when slow unwind works on Mac, see\n-// https://code.google.com/p/address-sanitizer/issues/detail?id=137\n+// https://github.com/google/sanitizers/issues/137\n #if SANITIZER_MAC\n # define SANITIZER_CAN_SLOW_UNWIND 0\n #else\n@@ -108,6 +108,11 @@ struct BufferedStackTrace : public StackTrace {\n   void operator=(const BufferedStackTrace &);\n };\n \n+// Check if given pointer points into allocated stack area.\n+static inline bool IsValidFrame(uptr frame, uptr stack_top, uptr stack_bottom) {\n+  return frame > stack_bottom && frame < stack_top - 2 * sizeof (uhwptr);\n+}\n+\n }  // namespace __sanitizer\n \n // Use this macro if you want to print stack trace with the caller"}, {"sha": "ac3ee3a019c2de657c2547b341b065c95b81873e", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_libcdep.cc", "status": "modified", "additions": 44, "deletions": 0, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -23,6 +23,8 @@ void StackTrace::Print() const {\n     return;\n   }\n   InternalScopedString frame_desc(GetPageSizeCached() * 2);\n+  InternalScopedString dedup_token(GetPageSizeCached());\n+  int dedup_frames = common_flags()->dedup_token_length;\n   uptr frame_num = 0;\n   for (uptr i = 0; i < size && trace[i]; i++) {\n     // PCs in stack traces are actually the return addresses, that is,\n@@ -36,11 +38,18 @@ void StackTrace::Print() const {\n                   cur->info, common_flags()->symbolize_vs_style,\n                   common_flags()->strip_path_prefix);\n       Printf(\"%s\\n\", frame_desc.data());\n+      if (dedup_frames-- > 0) {\n+        if (dedup_token.length())\n+          dedup_token.append(\"--\");\n+        dedup_token.append(cur->info.function);\n+      }\n     }\n     frames->ClearAll();\n   }\n   // Always print a trailing empty line after stack trace.\n   Printf(\"\\n\");\n+  if (dedup_token.length())\n+    Printf(\"DEDUP_TOKEN: %s\\n\", dedup_token.data());\n }\n \n void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n@@ -72,3 +81,38 @@ void BufferedStackTrace::Unwind(u32 max_depth, uptr pc, uptr bp, void *context,\n }\n \n }  // namespace __sanitizer\n+using namespace __sanitizer;\n+\n+extern \"C\" {\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_symbolize_pc(uptr pc, const char *fmt, char *out_buf,\n+                              uptr out_buf_size) {\n+  if (!out_buf_size) return;\n+  pc = StackTrace::GetPreviousInstructionPc(pc);\n+  SymbolizedStack *frame = Symbolizer::GetOrInit()->SymbolizePC(pc);\n+  if (!frame) {\n+    internal_strncpy(out_buf, \"<can't symbolize>\", out_buf_size);\n+    out_buf[out_buf_size - 1] = 0;\n+    return;\n+  }\n+  InternalScopedString frame_desc(GetPageSizeCached());\n+  RenderFrame(&frame_desc, fmt, 0, frame->info,\n+              common_flags()->symbolize_vs_style,\n+              common_flags()->strip_path_prefix);\n+  internal_strncpy(out_buf, frame_desc.data(), out_buf_size);\n+  out_buf[out_buf_size - 1] = 0;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void __sanitizer_symbolize_global(uptr data_addr, const char *fmt,\n+                                  char *out_buf, uptr out_buf_size) {\n+  if (!out_buf_size) return;\n+  out_buf[0] = 0;\n+  DataInfo DI;\n+  if (!Symbolizer::GetOrInit()->SymbolizeData(data_addr, &DI)) return;\n+  InternalScopedString data_desc(GetPageSizeCached());\n+  RenderData(&data_desc, fmt, &DI, common_flags()->strip_path_prefix);\n+  internal_strncpy(out_buf, data_desc.data(), out_buf_size);\n+  out_buf[out_buf_size - 1] = 0;\n+}\n+}  // extern \"C\""}, {"sha": "de78c7ac8d1daa046d0546ca20d911f846c551ae", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.cc", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -114,6 +114,35 @@ void RenderFrame(InternalScopedString *buffer, const char *format, int frame_no,\n   }\n }\n \n+void RenderData(InternalScopedString *buffer, const char *format,\n+                const DataInfo *DI, const char *strip_path_prefix) {\n+  for (const char *p = format; *p != '\\0'; p++) {\n+    if (*p != '%') {\n+      buffer->append(\"%c\", *p);\n+      continue;\n+    }\n+    p++;\n+    switch (*p) {\n+      case '%':\n+        buffer->append(\"%%\");\n+        break;\n+      case 's':\n+        buffer->append(\"%s\", StripPathPrefix(DI->file, strip_path_prefix));\n+        break;\n+      case 'l':\n+        buffer->append(\"%d\", DI->line);\n+        break;\n+      case 'g':\n+        buffer->append(\"%s\", DI->name);\n+        break;\n+      default:\n+        Report(\"Unsupported specifier in stack frame format: %c (0x%zx)!\\n\", *p,\n+               *p);\n+        Die();\n+    }\n+  }\n+}\n+\n void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n                           int line, int column, bool vs_style,\n                           const char *strip_path_prefix) {"}, {"sha": "6726f141f225b9c307d5cf3889d4533daad5a32a", "filename": "libsanitizer/sanitizer_common/sanitizer_stacktrace_printer.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stacktrace_printer.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -57,6 +57,13 @@ void RenderSourceLocation(InternalScopedString *buffer, const char *file,\n void RenderModuleLocation(InternalScopedString *buffer, const char *module,\n                           uptr offset, const char *strip_path_prefix);\n \n+// Same as RenderFrame, but for data section (global variables).\n+// Accepts %s, %l from above.\n+// Also accepts:\n+//   %g - name of the global variable.\n+void RenderData(InternalScopedString *buffer, const char *format,\n+                const DataInfo *DI, const char *strip_path_prefix = \"\");\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_STACKTRACE_PRINTER_H"}, {"sha": "891386dc0ba79d4bf5aa9154a2db679c17df73f8", "filename": "libsanitizer/sanitizer_common/sanitizer_stoptheworld_linux_libcdep.cc", "status": "modified", "additions": 25, "deletions": 9, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_stoptheworld_linux_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -13,7 +13,8 @@\n #include \"sanitizer_platform.h\"\n \n #if SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__) || \\\n-                        defined(__aarch64__))\n+                        defined(__aarch64__) || defined(__powerpc64__) || \\\n+                        defined(__s390__))\n \n #include \"sanitizer_stoptheworld.h\"\n \n@@ -36,6 +37,9 @@\n #  include <asm/ptrace.h>\n # endif\n # include <sys/user.h>  // for user_regs_struct\n+# if SANITIZER_ANDROID && SANITIZER_MIPS\n+#   include <asm/reg.h>  // for mips SP register in sys/user.h\n+# endif\n #endif\n #include <sys/wait.h> // for signal-related stuff\n \n@@ -73,10 +77,10 @@\n // thread-local variables used by libc will be shared between the tracer task\n // and the thread which spawned it.\n \n-COMPILER_CHECK(sizeof(SuspendedThreadID) == sizeof(pid_t));\n-\n namespace __sanitizer {\n \n+COMPILER_CHECK(sizeof(SuspendedThreadID) == sizeof(pid_t));\n+\n // Structure for passing arguments into the tracer thread.\n struct TracerThreadArgument {\n   StopTheWorldCallback callback;\n@@ -184,6 +188,7 @@ void ThreadSuspender::KillAllThreads() {\n bool ThreadSuspender::SuspendAllThreads() {\n   ThreadLister thread_lister(pid_);\n   bool added_threads;\n+  bool first_iteration = true;\n   do {\n     // Run through the directory entries once.\n     added_threads = false;\n@@ -193,12 +198,13 @@ bool ThreadSuspender::SuspendAllThreads() {\n         added_threads = true;\n       tid = thread_lister.GetNextTID();\n     }\n-    if (thread_lister.error()) {\n+    if (thread_lister.error() || (first_iteration && !added_threads)) {\n       // Detach threads and fail.\n       ResumeAllThreads();\n       return false;\n     }\n     thread_lister.Reset();\n+    first_iteration = false;\n   } while (added_threads);\n   return true;\n }\n@@ -227,8 +233,8 @@ static void TracerThreadDieCallback() {\n // Signal handler to wake up suspended threads when the tracer thread dies.\n static void TracerThreadSignalHandler(int signum, void *siginfo, void *uctx) {\n   SignalContext ctx = SignalContext::Create(siginfo, uctx);\n-  VPrintf(1, \"Tracer caught signal %d: addr=0x%zx pc=0x%zx sp=0x%zx\\n\",\n-      signum, ctx.addr, ctx.pc, ctx.sp);\n+  Printf(\"Tracer caught signal %d: addr=0x%zx pc=0x%zx sp=0x%zx\\n\", signum,\n+         ctx.addr, ctx.pc, ctx.sp);\n   ThreadSuspender *inst = thread_suspender_instance;\n   if (inst) {\n     if (signum == SIGABRT)\n@@ -465,13 +471,22 @@ typedef pt_regs regs_struct;\n \n #elif defined(__mips__)\n typedef struct user regs_struct;\n-#define REG_SP regs[EF_REG29]\n+# if SANITIZER_ANDROID\n+#  define REG_SP regs[EF_R29]\n+# else\n+#  define REG_SP regs[EF_REG29]\n+# endif\n \n #elif defined(__aarch64__)\n typedef struct user_pt_regs regs_struct;\n #define REG_SP sp\n #define ARCH_IOVEC_FOR_GETREGSET\n \n+#elif defined(__s390__)\n+typedef _user_regs_struct regs_struct;\n+#define REG_SP gprs[15]\n+#define ARCH_IOVEC_FOR_GETREGSET\n+\n #else\n #error \"Unsupported architecture\"\n #endif // SANITIZER_ANDROID && defined(__arm__)\n@@ -509,5 +524,6 @@ uptr SuspendedThreadsList::RegisterCount() {\n }\n } // namespace __sanitizer\n \n-#endif // SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__)\n-       // || defined(__aarch64__)\n+#endif  // SANITIZER_LINUX && (defined(__x86_64__) || defined(__mips__)\n+        // || defined(__aarch64__) || defined(__powerpc64__)\n+        // || defined(__s390__)"}, {"sha": "bfdff59a35cd21740237c174e49b84dfb4404ad8", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -125,7 +125,7 @@ void SuppressionContext::Parse(const char *str) {\n         Printf(\"%s: failed to parse suppressions\\n\", SanitizerToolName);\n         Die();\n       }\n-      Suppression s = {};\n+      Suppression s;\n       s.type = suppression_types_[type];\n       s.templ = (char*)InternalAlloc(end2 - line + 1);\n       internal_memcpy(s.templ, line, end2 - line);"}, {"sha": "ed6d7baae8460ed27db093544fe543669bebd24d", "filename": "libsanitizer/sanitizer_common/sanitizer_suppressions.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_suppressions.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -18,6 +18,7 @@\n namespace __sanitizer {\n \n struct Suppression {\n+  Suppression() { internal_memset(this, 0, sizeof(*this)); }\n   const char *type;\n   char *templ;\n   atomic_uint32_t hit_count;\n@@ -40,7 +41,7 @@ class SuppressionContext {\n   void GetMatched(InternalMmapVector<Suppression *> *matched);\n \n  private:\n-  static const int kMaxSuppressionTypes = 16;\n+  static const int kMaxSuppressionTypes = 32;\n   const char **const suppression_types_;\n   const int suppression_types_num_;\n "}, {"sha": "3557415aeabd5c14ba10abeb1dbf415ac64a5d8e", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.cc", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -58,6 +58,7 @@ DataInfo::DataInfo() {\n \n void DataInfo::Clear() {\n   InternalFree(module);\n+  InternalFree(file);\n   InternalFree(name);\n   internal_memset(this, 0, sizeof(DataInfo));\n }\n@@ -94,7 +95,7 @@ const char *Symbolizer::ModuleNameOwner::GetOwnedCopy(const char *str) {\n }\n \n Symbolizer::Symbolizer(IntrusiveList<SymbolizerTool> tools)\n-    : module_names_(&mu_), n_modules_(0), modules_fresh_(false), tools_(tools),\n+    : module_names_(&mu_), modules_(), modules_fresh_(false), tools_(tools),\n       start_hook_(0), end_hook_(0) {}\n \n Symbolizer::SymbolizerScope::SymbolizerScope(const Symbolizer *sym)"}, {"sha": "2b90b42e2ba0dd21040d657ee1f72ea7d51c52b5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer.h", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -63,6 +63,8 @@ struct DataInfo {\n   // (de)allocated using sanitizer internal allocator.\n   char *module;\n   uptr module_offset;\n+  char *file;\n+  uptr line;\n   char *name;\n   uptr start;\n   uptr size;\n@@ -78,6 +80,7 @@ class Symbolizer final {\n   /// Initialize and return platform-specific implementation of symbolizer\n   /// (if it wasn't already initialized).\n   static Symbolizer *GetOrInit();\n+  static void LateInitialize();\n   // Returns a list of symbolized frames for a given address (containing\n   // all inlined functions, if necessary).\n   SymbolizedStack *SymbolizePC(uptr address);\n@@ -111,6 +114,8 @@ class Symbolizer final {\n   void AddHooks(StartSymbolizationHook start_hook,\n                 EndSymbolizationHook end_hook);\n \n+  const LoadedModule *FindModuleForAddress(uptr address);\n+\n  private:\n   // GetModuleNameAndOffsetForPC has to return a string to the caller.\n   // Since the corresponding module might get unloaded later, we should create\n@@ -137,9 +142,7 @@ class Symbolizer final {\n \n   bool FindModuleNameAndOffsetForAddress(uptr address, const char **module_name,\n                                          uptr *module_offset);\n-  LoadedModule *FindModuleForAddress(uptr address);\n-  LoadedModule modules_[kMaxNumberOfModules];\n-  uptr n_modules_;\n+  ListOfModules modules_;\n   // If stale, need to reload the modules before looking up addresses.\n   bool modules_fresh_;\n \n@@ -155,7 +158,6 @@ class Symbolizer final {\n   // always synchronized.\n   BlockingMutex mu_;\n \n-  typedef IntrusiveList<SymbolizerTool>::Iterator Iterator;\n   IntrusiveList<SymbolizerTool> tools_;\n \n   explicit Symbolizer(IntrusiveList<SymbolizerTool> tools);\n@@ -173,6 +175,10 @@ class Symbolizer final {\n   };\n };\n \n+#ifdef SANITIZER_WINDOWS\n+void InitializeDbgHelpIfNeeded();\n+#endif\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_SYMBOLIZER_H"}, {"sha": "119cb6884630837f36e174a9c4fb4a0a1c9eee74", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_internal.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_internal.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -26,7 +26,7 @@ const char *ExtractUptr(const char *str, const char *delims, uptr *result);\n const char *ExtractTokenUpToDelimiter(const char *str, const char *delimiter,\n                                       char **result);\n \n-const char *DemangleCXXABI(const char *name);\n+const char *DemangleSwiftAndCXX(const char *name);\n \n // SymbolizerTool is an interface that is implemented by individual \"tools\"\n // that can perform symbolication (external llvm-symbolizer, libbacktrace,"}, {"sha": "45eb11a4d3b62fe5bf7377c42491cb36e6b577f5", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_libcdep.cc", "status": "modified", "additions": 24, "deletions": 24, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -67,10 +67,9 @@ SymbolizedStack *Symbolizer::SymbolizePC(uptr addr) {\n     return res;\n   // Always fill data about module name and offset.\n   res->info.FillModuleInfo(module_name, module_offset);\n-  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n-    auto *tool = iter.next();\n+  for (auto &tool : tools_) {\n     SymbolizerScope sym_scope(this);\n-    if (tool->SymbolizePC(addr, res)) {\n+    if (tool.SymbolizePC(addr, res)) {\n       return res;\n     }\n   }\n@@ -86,10 +85,9 @@ bool Symbolizer::SymbolizeData(uptr addr, DataInfo *info) {\n   info->Clear();\n   info->module = internal_strdup(module_name);\n   info->module_offset = module_offset;\n-  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n-    auto *tool = iter.next();\n+  for (auto &tool : tools_) {\n     SymbolizerScope sym_scope(this);\n-    if (tool->SymbolizeData(addr, info)) {\n+    if (tool.SymbolizeData(addr, info)) {\n       return true;\n     }\n   }\n@@ -111,19 +109,17 @@ bool Symbolizer::GetModuleNameAndOffsetForPC(uptr pc, const char **module_name,\n \n void Symbolizer::Flush() {\n   BlockingMutexLock l(&mu_);\n-  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n-    auto *tool = iter.next();\n+  for (auto &tool : tools_) {\n     SymbolizerScope sym_scope(this);\n-    tool->Flush();\n+    tool.Flush();\n   }\n }\n \n const char *Symbolizer::Demangle(const char *name) {\n   BlockingMutexLock l(&mu_);\n-  for (auto iter = Iterator(&tools_); iter.hasNext();) {\n-    auto *tool = iter.next();\n+  for (auto &tool : tools_) {\n     SymbolizerScope sym_scope(this);\n-    if (const char *demangled = tool->Demangle(name))\n+    if (const char *demangled = tool.Demangle(name))\n       return demangled;\n   }\n   return PlatformDemangle(name);\n@@ -137,27 +133,23 @@ void Symbolizer::PrepareForSandboxing() {\n bool Symbolizer::FindModuleNameAndOffsetForAddress(uptr address,\n                                                    const char **module_name,\n                                                    uptr *module_offset) {\n-  LoadedModule *module = FindModuleForAddress(address);\n-  if (module == 0)\n+  const LoadedModule *module = FindModuleForAddress(address);\n+  if (module == nullptr)\n     return false;\n   *module_name = module->full_name();\n   *module_offset = address - module->base_address();\n   return true;\n }\n \n-LoadedModule *Symbolizer::FindModuleForAddress(uptr address) {\n+const LoadedModule *Symbolizer::FindModuleForAddress(uptr address) {\n   bool modules_were_reloaded = false;\n   if (!modules_fresh_) {\n-    for (uptr i = 0; i < n_modules_; i++)\n-      modules_[i].clear();\n-    n_modules_ =\n-        GetListOfModules(modules_, kMaxNumberOfModules, /* filter */ nullptr);\n-    CHECK_GT(n_modules_, 0);\n-    CHECK_LT(n_modules_, kMaxNumberOfModules);\n+    modules_.init();\n+    RAW_CHECK(modules_.size() > 0);\n     modules_fresh_ = true;\n     modules_were_reloaded = true;\n   }\n-  for (uptr i = 0; i < n_modules_; i++) {\n+  for (uptr i = 0; i < modules_.size(); i++) {\n     if (modules_[i].containsAddress(address)) {\n       return &modules_[i];\n     }\n@@ -211,10 +203,18 @@ class LLVMSymbolizerProcess : public SymbolizerProcess {\n     const char* const kSymbolizerArch = \"--default-arch=x86_64\";\n #elif defined(__i386__)\n     const char* const kSymbolizerArch = \"--default-arch=i386\";\n-#elif defined(__powerpc64__) && defined(__BIG_ENDIAN__)\n+#elif defined(__aarch64__)\n+    const char* const kSymbolizerArch = \"--default-arch=arm64\";\n+#elif defined(__arm__)\n+    const char* const kSymbolizerArch = \"--default-arch=arm\";\n+#elif defined(__powerpc64__) && __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n     const char* const kSymbolizerArch = \"--default-arch=powerpc64\";\n-#elif defined(__powerpc64__) && defined(__LITTLE_ENDIAN__)\n+#elif defined(__powerpc64__) && __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__\n     const char* const kSymbolizerArch = \"--default-arch=powerpc64le\";\n+#elif defined(__s390x__)\n+    const char* const kSymbolizerArch = \"--default-arch=s390x\";\n+#elif defined(__s390__)\n+    const char* const kSymbolizerArch = \"--default-arch=s390\";\n #else\n     const char* const kSymbolizerArch = \"--default-arch=unknown\";\n #endif"}, {"sha": "249ccdf83773d126aae9839db32308605334a948", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_mac.cc", "status": "modified", "additions": 11, "deletions": 26, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -17,20 +17,21 @@\n #include \"sanitizer_mac.h\"\n #include \"sanitizer_symbolizer_mac.h\"\n \n-namespace __sanitizer {\n-\n #include <dlfcn.h>\n #include <errno.h>\n #include <stdlib.h>\n #include <sys/wait.h>\n #include <unistd.h>\n #include <util.h>\n \n+namespace __sanitizer {\n+\n bool DlAddrSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   Dl_info info;\n   int result = dladdr((const void *)addr, &info);\n   if (!result) return false;\n-  const char *demangled = DemangleCXXABI(info.dli_sname);\n+  const char *demangled = DemangleSwiftAndCXX(info.dli_sname);\n+  if (!demangled) return false;\n   stack->info.function = internal_strdup(demangled);\n   return true;\n }\n@@ -39,7 +40,7 @@ bool DlAddrSymbolizer::SymbolizeData(uptr addr, DataInfo *datainfo) {\n   Dl_info info;\n   int result = dladdr((const void *)addr, &info);\n   if (!result) return false;\n-  const char *demangled = DemangleCXXABI(info.dli_sname);\n+  const char *demangled = DemangleSwiftAndCXX(info.dli_sname);\n   datainfo->name = internal_strdup(demangled);\n   datainfo->start = (uptr)info.dli_saddr;\n   return true;\n@@ -77,23 +78,6 @@ class AtosSymbolizerProcess : public SymbolizerProcess {\n   char pid_str_[16];\n };\n \n-static const char *kAtosErrorMessages[] = {\n-  \"atos cannot examine process\",\n-  \"unable to get permission to examine process\",\n-  \"An admin user name and password is required\",\n-  \"could not load inserted library\",\n-  \"architecture mismatch between analysis process\",\n-};\n-\n-static bool IsAtosErrorMessage(const char *str) {\n-  for (uptr i = 0; i < ARRAY_SIZE(kAtosErrorMessages); i++) {\n-    if (internal_strstr(str, kAtosErrorMessages[i])) {\n-      return true;\n-    }\n-  }\n-  return false;\n-}\n-\n static bool ParseCommandOutput(const char *str, uptr addr, char **out_name,\n                                char **out_module, char **out_file, uptr *line,\n                                uptr *start_address) {\n@@ -110,15 +94,15 @@ static bool ParseCommandOutput(const char *str, uptr addr, char **out_name,\n   //   0xdeadbeef (in library.dylib)\n   //   0xdeadbeef\n \n-  if (IsAtosErrorMessage(trim)) {\n-    Report(\"atos returned an error: %s\\n\", trim);\n+  const char *rest = trim;\n+  char *symbol_name;\n+  rest = ExtractTokenUpToDelimiter(rest, \" (in \", &symbol_name);\n+  if (rest[0] == '\\0') {\n+    InternalFree(symbol_name);\n     InternalFree(trim);\n     return false;\n   }\n \n-  const char *rest = trim;\n-  char *symbol_name;\n-  rest = ExtractTokenUpToDelimiter(rest, \" (in \", &symbol_name);\n   if (internal_strncmp(symbol_name, \"0x\", 2) != 0)\n     *out_name = symbol_name;\n   else\n@@ -149,6 +133,7 @@ AtosSymbolizer::AtosSymbolizer(const char *path, LowLevelAllocator *allocator)\n \n bool AtosSymbolizer::SymbolizePC(uptr addr, SymbolizedStack *stack) {\n   if (!process_) return false;\n+  if (addr == 0) return false;\n   char command[32];\n   internal_snprintf(command, sizeof(command), \"0x%zx\\n\", addr);\n   const char *buf = process_->SendCommand(command);"}, {"sha": "3fcd7d04880e771ac9262e607c1529b0b1863019", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_posix_libcdep.cc", "status": "modified", "additions": 70, "deletions": 37, "changes": 107, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_posix_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -24,7 +24,9 @@\n #include \"sanitizer_symbolizer_libbacktrace.h\"\n #include \"sanitizer_symbolizer_mac.h\"\n \n+#include <dlfcn.h>   // for dlsym()\n #include <errno.h>\n+#include <stdint.h>\n #include <stdlib.h>\n #include <sys/wait.h>\n #include <unistd.h>\n@@ -59,6 +61,44 @@ const char *DemangleCXXABI(const char *name) {\n   return name;\n }\n \n+// As of now, there are no headers for the Swift runtime. Once they are\n+// present, we will weakly link since we do not require Swift runtime to be\n+// linked.\n+typedef char *(*swift_demangle_ft)(const char *mangledName,\n+                                   size_t mangledNameLength, char *outputBuffer,\n+                                   size_t *outputBufferSize, uint32_t flags);\n+static swift_demangle_ft swift_demangle_f;\n+\n+// This must not happen lazily at symbolication time, because dlsym uses\n+// malloc and thread-local storage, which is not a good thing to do during\n+// symbolication.\n+static void InitializeSwiftDemangler() {\n+  swift_demangle_f = (swift_demangle_ft)dlsym(RTLD_DEFAULT, \"swift_demangle\");\n+}\n+\n+// Attempts to demangle a Swift name. The demangler will return nullptr if a\n+// non-Swift name is passed in.\n+const char *DemangleSwift(const char *name) {\n+  if (!name) return nullptr;\n+\n+  // Check if we are dealing with a Swift mangled name first.\n+  if (name[0] != '_' || name[1] != 'T') {\n+    return nullptr;\n+  }\n+\n+  if (swift_demangle_f)\n+    return swift_demangle_f(name, internal_strlen(name), 0, 0, 0);\n+\n+  return nullptr;\n+}\n+\n+const char *DemangleSwiftAndCXX(const char *name) {\n+  if (!name) return nullptr;\n+  if (const char *swift_demangled_name = DemangleSwift(name))\n+    return swift_demangled_name;\n+  return DemangleCXXABI(name);\n+}\n+\n bool SymbolizerProcess::StartSymbolizerSubprocess() {\n   if (!FileExists(path_)) {\n     if (!reported_invalid_path_) {\n@@ -72,15 +112,27 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n   if (use_forkpty_) {\n #if SANITIZER_MAC\n     fd_t fd = kInvalidFd;\n+\n+    // forkpty redirects stdout and stderr into a single stream, so we would\n+    // receive error messages as standard replies. To avoid that, let's dup\n+    // stderr and restore it in the child.\n+    int saved_stderr = dup(STDERR_FILENO);\n+    CHECK_GE(saved_stderr, 0);\n+\n     // Use forkpty to disable buffering in the new terminal.\n-    pid = forkpty(&fd, 0, 0, 0);\n+    pid = internal_forkpty(&fd);\n     if (pid == -1) {\n       // forkpty() failed.\n       Report(\"WARNING: failed to fork external symbolizer (errno: %d)\\n\",\n              errno);\n       return false;\n     } else if (pid == 0) {\n       // Child subprocess.\n+\n+      // Restore stderr.\n+      CHECK_GE(dup2(saved_stderr, STDERR_FILENO), 0);\n+      close(saved_stderr);\n+\n       const char *argv[kArgVMax];\n       GetArgV(path_, argv);\n       execv(path_, const_cast<char **>(&argv[0]));\n@@ -90,6 +142,8 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n     // Continue execution in parent process.\n     input_fd_ = output_fd_ = fd;\n \n+    close(saved_stderr);\n+\n     // Disable echo in the new terminal, disable CR.\n     struct termios termflags;\n     tcgetattr(fd, &termflags);\n@@ -135,47 +189,23 @@ bool SymbolizerProcess::StartSymbolizerSubprocess() {\n     CHECK(infd);\n     CHECK(outfd);\n \n-    // Real fork() may call user callbacks registered with pthread_atfork().\n-    pid = internal_fork();\n-    if (pid == -1) {\n-      // Fork() failed.\n+    const char *argv[kArgVMax];\n+    GetArgV(path_, argv);\n+    pid = StartSubprocess(path_, argv, /* stdin */ outfd[0],\n+                          /* stdout */ infd[1]);\n+    if (pid < 0) {\n       internal_close(infd[0]);\n-      internal_close(infd[1]);\n-      internal_close(outfd[0]);\n       internal_close(outfd[1]);\n-      Report(\"WARNING: failed to fork external symbolizer \"\n-             \" (errno: %d)\\n\", errno);\n       return false;\n-    } else if (pid == 0) {\n-      // Child subprocess.\n-      internal_close(STDOUT_FILENO);\n-      internal_close(STDIN_FILENO);\n-      internal_dup2(outfd[0], STDIN_FILENO);\n-      internal_dup2(infd[1], STDOUT_FILENO);\n-      internal_close(outfd[0]);\n-      internal_close(outfd[1]);\n-      internal_close(infd[0]);\n-      internal_close(infd[1]);\n-      for (int fd = sysconf(_SC_OPEN_MAX); fd > 2; fd--)\n-        internal_close(fd);\n-      const char *argv[kArgVMax];\n-      GetArgV(path_, argv);\n-      execv(path_, const_cast<char **>(&argv[0]));\n-      internal__exit(1);\n     }\n \n-    // Continue execution in parent process.\n-    internal_close(outfd[0]);\n-    internal_close(infd[1]);\n     input_fd_ = infd[0];\n     output_fd_ = outfd[1];\n   }\n \n   // Check that symbolizer subprocess started successfully.\n-  int pid_status;\n   SleepForMillis(kSymbolizerStartupTimeMillis);\n-  int exited_pid = waitpid(pid, &pid_status, WNOHANG);\n-  if (exited_pid != 0) {\n+  if (!IsProcessRunning(pid)) {\n     // Either waitpid failed, or child has already exited.\n     Report(\"WARNING: external symbolizer didn't start up correctly!\\n\");\n     return false;\n@@ -372,7 +402,7 @@ class InternalSymbolizer : public SymbolizerTool {\n #endif  // SANITIZER_SUPPORTS_WEAK_HOOKS\n \n const char *Symbolizer::PlatformDemangle(const char *name) {\n-  return DemangleCXXABI(name);\n+  return DemangleSwiftAndCXX(name);\n }\n \n void Symbolizer::PlatformPrepareForSandboxing() {}\n@@ -431,7 +461,9 @@ static void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n     VReport(2, \"Symbolizer is disabled.\\n\");\n     return;\n   }\n-  if (SymbolizerTool *tool = InternalSymbolizer::get(allocator)) {\n+  if (IsReportingOOM()) {\n+    VReport(2, \"Cannot use internal symbolizer: out of memory\\n\");\n+  } else if (SymbolizerTool *tool = InternalSymbolizer::get(allocator)) {\n     VReport(2, \"Using internal symbolizer.\\n\");\n     list->push_back(tool);\n     return;\n@@ -450,10 +482,6 @@ static void ChooseSymbolizerTools(IntrusiveList<SymbolizerTool> *list,\n   VReport(2, \"Using dladdr symbolizer.\\n\");\n   list->push_back(new(*allocator) DlAddrSymbolizer());\n #endif  // SANITIZER_MAC\n-\n-  if (list->size() == 0) {\n-    Report(\"WARNING: no internal or external symbolizer found.\\n\");\n-  }\n }\n \n Symbolizer *Symbolizer::PlatformInit() {\n@@ -463,6 +491,11 @@ Symbolizer *Symbolizer::PlatformInit() {\n   return new(symbolizer_allocator_) Symbolizer(list);\n }\n \n+void Symbolizer::LateInitialize() {\n+  Symbolizer::GetOrInit();\n+  InitializeSwiftDemangler();\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // SANITIZER_POSIX"}, {"sha": "95fda7ec42e007e8aacc96c832bfa855cb1c1994", "filename": "libsanitizer/sanitizer_common/sanitizer_symbolizer_win.cc", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_symbolizer_win.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -40,6 +40,8 @@ bool TrySymInitialize() {\n   // FIXME: We don't call SymCleanup() on exit yet - should we?\n }\n \n+}  // namespace\n+\n // Initializes DbgHelp library, if it's not yet initialized. Calls to this\n // function should be synchronized with respect to other calls to DbgHelp API\n // (e.g. from WinSymbolizerTool).\n@@ -95,8 +97,6 @@ void InitializeDbgHelpIfNeeded() {\n   }\n }\n \n-}  // namespace\n-\n bool WinSymbolizerTool::SymbolizePC(uptr addr, SymbolizedStack *frame) {\n   InitializeDbgHelpIfNeeded();\n \n@@ -277,6 +277,10 @@ Symbolizer *Symbolizer::PlatformInit() {\n   return new(symbolizer_allocator_) Symbolizer(list);\n }\n \n+void Symbolizer::LateInitialize() {\n+  Symbolizer::GetOrInit();\n+}\n+\n }  // namespace __sanitizer\n \n #endif  // _WIN32"}, {"sha": "6d7335112b37715cfc972075c781fe8802996fd9", "filename": "libsanitizer/sanitizer_common/sanitizer_termination.cc", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_termination.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,84 @@\n+//===-- sanitizer_termination.cc --------------------------------*- C++ -*-===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+///\n+/// This file contains the Sanitizer termination functions CheckFailed and Die,\n+/// and the callback functionalities associated with them.\n+///\n+//===----------------------------------------------------------------------===//\n+\n+#include \"sanitizer_common.h\"\n+#include \"sanitizer_libc.h\"\n+\n+namespace __sanitizer {\n+\n+static const int kMaxNumOfInternalDieCallbacks = 5;\n+static DieCallbackType InternalDieCallbacks[kMaxNumOfInternalDieCallbacks];\n+\n+bool AddDieCallback(DieCallbackType callback) {\n+  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n+    if (InternalDieCallbacks[i] == nullptr) {\n+      InternalDieCallbacks[i] = callback;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+bool RemoveDieCallback(DieCallbackType callback) {\n+  for (int i = 0; i < kMaxNumOfInternalDieCallbacks; i++) {\n+    if (InternalDieCallbacks[i] == callback) {\n+      internal_memmove(&InternalDieCallbacks[i], &InternalDieCallbacks[i + 1],\n+                       sizeof(InternalDieCallbacks[0]) *\n+                           (kMaxNumOfInternalDieCallbacks - i - 1));\n+      InternalDieCallbacks[kMaxNumOfInternalDieCallbacks - 1] = nullptr;\n+      return true;\n+    }\n+  }\n+  return false;\n+}\n+\n+static DieCallbackType UserDieCallback;\n+void SetUserDieCallback(DieCallbackType callback) {\n+  UserDieCallback = callback;\n+}\n+\n+void NORETURN Die() {\n+  if (UserDieCallback)\n+    UserDieCallback();\n+  for (int i = kMaxNumOfInternalDieCallbacks - 1; i >= 0; i--) {\n+    if (InternalDieCallbacks[i])\n+      InternalDieCallbacks[i]();\n+  }\n+  if (common_flags()->abort_on_error)\n+    Abort();\n+  internal__exit(common_flags()->exitcode);\n+}\n+\n+static CheckFailedCallbackType CheckFailedCallback;\n+void SetCheckFailedCallback(CheckFailedCallbackType callback) {\n+  CheckFailedCallback = callback;\n+}\n+\n+const int kSecondsToSleepWhenRecursiveCheckFailed = 2;\n+\n+void NORETURN CheckFailed(const char *file, int line, const char *cond,\n+                          u64 v1, u64 v2) {\n+  static atomic_uint32_t num_calls;\n+  if (atomic_fetch_add(&num_calls, 1, memory_order_relaxed) > 10) {\n+    SleepForSeconds(kSecondsToSleepWhenRecursiveCheckFailed);\n+    Trap();\n+  }\n+\n+  if (CheckFailedCallback) {\n+    CheckFailedCallback(file, line, cond, v1, v2);\n+  }\n+  Report(\"Sanitizer CHECK failed: %s:%d %s (%lld, %lld)\\n\", file, line, cond,\n+                                                            v1, v2);\n+  Die();\n+}\n+\n+} // namespace __sanitizer"}, {"sha": "c865d2cad84ee5acd42c41a292c81c61ba759203", "filename": "libsanitizer/sanitizer_common/sanitizer_thread_registry.cc", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_thread_registry.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -129,7 +129,7 @@ u32 ThreadRegistry::CreateThread(uptr user_id, bool detached, u32 parent_tid,\n     tctx = context_factory_(tid);\n     threads_[tid] = tctx;\n   } else {\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n     Report(\"%s: Thread limit (%u threads) exceeded. Dying.\\n\",\n            SanitizerToolName, max_threads_);\n #else\n@@ -275,6 +275,8 @@ void ThreadRegistry::StartThread(u32 tid, uptr os_id, void *arg) {\n }\n \n void ThreadRegistry::QuarantinePush(ThreadContextBase *tctx) {\n+  if (tctx->tid == 0)\n+    return;  // Don't reuse the main thread.  It's a special snowflake.\n   dead_threads_.push_back(tctx);\n   if (dead_threads_.size() <= thread_quarantine_size_)\n     return;"}, {"sha": "229225d95dd6ab3524cd19b3b2662bd661bf3f01", "filename": "libsanitizer/sanitizer_common/sanitizer_tls_get_addr.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_tls_get_addr.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -76,7 +76,7 @@ void DTLS_Destroy() {\n   DTLS_Deallocate(dtls.dtv, s);\n }\n \n-#if defined(__powerpc64__)\n+#if defined(__powerpc64__) || defined(__mips__)\n // This is glibc's TLS_DTV_OFFSET:\n // \"Dynamic thread vector pointers point 0x8000 past the start of each\n //  TLS block.\""}, {"sha": "eb1c133e4f4e6af5a3e4b9cec1171e0c3e4bad10", "filename": "libsanitizer/sanitizer_common/sanitizer_unwind_linux_libcdep.cc", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_unwind_linux_libcdep.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -46,6 +46,11 @@ unwind_backtrace_signal_arch_func unwind_backtrace_signal_arch;\n \n #if SANITIZER_ANDROID\n void SanitizerInitializeUnwinder() {\n+  if (AndroidGetApiLevel() >= ANDROID_LOLLIPOP_MR1) return;\n+\n+  // Pre-lollipop Android can not unwind through signal handler frames with\n+  // libgcc unwinder, but it has a libcorkscrew.so library with the necessary\n+  // workarounds.\n   void *p = dlopen(\"libcorkscrew.so\", RTLD_LAZY);\n   if (!p) {\n     VReport(1,\n@@ -101,6 +106,11 @@ _Unwind_Reason_Code Unwind_Trace(struct _Unwind_Context *ctx, void *param) {\n   UnwindTraceArg *arg = (UnwindTraceArg*)param;\n   CHECK_LT(arg->stack->size, arg->max_depth);\n   uptr pc = Unwind_GetIP(ctx);\n+  const uptr kPageSize = GetPageSizeCached();\n+  // Let's assume that any pointer in the 0th page (i.e. <0x1000 on i386 and\n+  // x86_64) is invalid and stop unwinding here.  If we're adding support for\n+  // a platform where this isn't true, we need to reconsider this check.\n+  if (pc < kPageSize) return UNWIND_STOP;\n   arg->stack->trace_buffer[arg->stack->size++] = pc;\n   if (arg->stack->size == arg->max_depth) return UNWIND_STOP;\n   return UNWIND_CONTINUE;"}, {"sha": "785883ce7675ed8b66cfabc58d24ddf8c2120a9d", "filename": "libsanitizer/sanitizer_common/sanitizer_win.cc", "status": "modified", "additions": 219, "deletions": 53, "changes": 272, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fsanitizer_common%2Fsanitizer_win.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -25,21 +25,25 @@\n #include \"sanitizer_libc.h\"\n #include \"sanitizer_mutex.h\"\n #include \"sanitizer_placement_new.h\"\n+#include \"sanitizer_procmaps.h\"\n #include \"sanitizer_stacktrace.h\"\n+#include \"sanitizer_symbolizer.h\"\n \n namespace __sanitizer {\n \n #include \"sanitizer_syscall_generic.inc\"\n \n // --------------------- sanitizer_common.h\n uptr GetPageSize() {\n-  // FIXME: there is an API for getting the system page size (GetSystemInfo or\n-  // GetNativeSystemInfo), but if we use it here we get test failures elsewhere.\n-  return 1U << 14;\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+  return si.dwPageSize;\n }\n \n uptr GetMmapGranularity() {\n-  return 1U << 16;  // FIXME: is this configurable?\n+  SYSTEM_INFO si;\n+  GetSystemInfo(&si);\n+  return si.dwAllocationGranularity;\n }\n \n uptr GetMaxVirtualAddress() {\n@@ -81,78 +85,188 @@ void GetThreadStackTopAndBottom(bool at_initialization, uptr *stack_top,\n }\n #endif  // #if !SANITIZER_GO\n \n-void *MmapOrDie(uptr size, const char *mem_type) {\n+void *MmapOrDie(uptr size, const char *mem_type, bool raw_report) {\n   void *rv = VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n   if (rv == 0)\n-    ReportMmapFailureAndDie(size, mem_type, \"allocate\", GetLastError());\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\",\n+                            GetLastError(), raw_report);\n   return rv;\n }\n \n void UnmapOrDie(void *addr, uptr size) {\n   if (!size || !addr)\n     return;\n \n-  if (VirtualFree(addr, size, MEM_DECOMMIT) == 0) {\n-    Report(\"ERROR: %s failed to \"\n-           \"deallocate 0x%zx (%zd) bytes at address %p (error code: %d)\\n\",\n-           SanitizerToolName, size, size, addr, GetLastError());\n-    CHECK(\"unable to unmap\" && 0);\n+  MEMORY_BASIC_INFORMATION mbi;\n+  CHECK(VirtualQuery(addr, &mbi, sizeof(mbi)));\n+\n+  // MEM_RELEASE can only be used to unmap whole regions previously mapped with\n+  // VirtualAlloc. So we first try MEM_RELEASE since it is better, and if that\n+  // fails try MEM_DECOMMIT.\n+  if (VirtualFree(addr, 0, MEM_RELEASE) == 0) {\n+    if (VirtualFree(addr, size, MEM_DECOMMIT) == 0) {\n+      Report(\"ERROR: %s failed to \"\n+             \"deallocate 0x%zx (%zd) bytes at address %p (error code: %d)\\n\",\n+             SanitizerToolName, size, size, addr, GetLastError());\n+      CHECK(\"unable to unmap\" && 0);\n+    }\n   }\n }\n \n+// We want to map a chunk of address space aligned to 'alignment'.\n+void *MmapAlignedOrDie(uptr size, uptr alignment, const char *mem_type) {\n+  CHECK(IsPowerOfTwo(size));\n+  CHECK(IsPowerOfTwo(alignment));\n+\n+  // Windows will align our allocations to at least 64K.\n+  alignment = Max(alignment, GetMmapGranularity());\n+\n+  uptr mapped_addr =\n+      (uptr)VirtualAlloc(0, size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n+  if (!mapped_addr)\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate aligned\", GetLastError());\n+\n+  // If we got it right on the first try, return. Otherwise, unmap it and go to\n+  // the slow path.\n+  if (IsAligned(mapped_addr, alignment))\n+    return (void*)mapped_addr;\n+  if (VirtualFree((void *)mapped_addr, 0, MEM_RELEASE) == 0)\n+    ReportMmapFailureAndDie(size, mem_type, \"deallocate\", GetLastError());\n+\n+  // If we didn't get an aligned address, overallocate, find an aligned address,\n+  // unmap, and try to allocate at that aligned address.\n+  int retries = 0;\n+  const int kMaxRetries = 10;\n+  for (; retries < kMaxRetries &&\n+         (mapped_addr == 0 || !IsAligned(mapped_addr, alignment));\n+       retries++) {\n+    // Overallocate size + alignment bytes.\n+    mapped_addr =\n+        (uptr)VirtualAlloc(0, size + alignment, MEM_RESERVE, PAGE_NOACCESS);\n+    if (!mapped_addr)\n+      ReportMmapFailureAndDie(size, mem_type, \"allocate aligned\",\n+                              GetLastError());\n+\n+    // Find the aligned address.\n+    uptr aligned_addr = RoundUpTo(mapped_addr, alignment);\n+\n+    // Free the overallocation.\n+    if (VirtualFree((void *)mapped_addr, 0, MEM_RELEASE) == 0)\n+      ReportMmapFailureAndDie(size, mem_type, \"deallocate\", GetLastError());\n+\n+    // Attempt to allocate exactly the number of bytes we need at the aligned\n+    // address. This may fail for a number of reasons, in which case we continue\n+    // the loop.\n+    mapped_addr = (uptr)VirtualAlloc((void *)aligned_addr, size,\n+                                     MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n+  }\n+\n+  // Fail if we can't make this work quickly.\n+  if (retries == kMaxRetries && mapped_addr == 0)\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate aligned\", GetLastError());\n+\n+  return (void *)mapped_addr;\n+}\n+\n void *MmapFixedNoReserve(uptr fixed_addr, uptr size, const char *name) {\n   // FIXME: is this really \"NoReserve\"? On Win32 this does not matter much,\n   // but on Win64 it does.\n-  (void)name; // unsupported\n-  void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n-      MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);\n+  (void)name;  // unsupported\n+#if !SANITIZER_GO && SANITIZER_WINDOWS64\n+  // On asan/Windows64, use MEM_COMMIT would result in error\n+  // 1455:ERROR_COMMITMENT_LIMIT.\n+  // Asan uses exception handler to commit page on demand.\n+  void *p = VirtualAlloc((LPVOID)fixed_addr, size, MEM_RESERVE, PAGE_READWRITE);\n+#else\n+  void *p = VirtualAlloc((LPVOID)fixed_addr, size, MEM_RESERVE | MEM_COMMIT,\n+                         PAGE_READWRITE);\n+#endif\n   if (p == 0)\n     Report(\"ERROR: %s failed to \"\n            \"allocate %p (%zd) bytes at %p (error code: %d)\\n\",\n            SanitizerToolName, size, size, fixed_addr, GetLastError());\n   return p;\n }\n \n+// Memory space mapped by 'MmapFixedOrDie' must have been reserved by\n+// 'MmapFixedNoAccess'.\n void *MmapFixedOrDie(uptr fixed_addr, uptr size) {\n-  return MmapFixedNoReserve(fixed_addr, size);\n+  void *p = VirtualAlloc((LPVOID)fixed_addr, size,\n+      MEM_COMMIT, PAGE_READWRITE);\n+  if (p == 0) {\n+    char mem_type[30];\n+    internal_snprintf(mem_type, sizeof(mem_type), \"memory at address 0x%zx\",\n+                      fixed_addr);\n+    ReportMmapFailureAndDie(size, mem_type, \"allocate\", GetLastError());\n+  }\n+  return p;\n }\n \n void *MmapNoReserveOrDie(uptr size, const char *mem_type) {\n   // FIXME: make this really NoReserve?\n   return MmapOrDie(size, mem_type);\n }\n \n-void *MmapNoAccess(uptr fixed_addr, uptr size, const char *name) {\n+void *MmapFixedNoAccess(uptr fixed_addr, uptr size, const char *name) {\n   (void)name; // unsupported\n   void *res = VirtualAlloc((LPVOID)fixed_addr, size,\n-                           MEM_RESERVE | MEM_COMMIT, PAGE_NOACCESS);\n+                           MEM_RESERVE, PAGE_NOACCESS);\n   if (res == 0)\n     Report(\"WARNING: %s failed to \"\n            \"mprotect %p (%zd) bytes at %p (error code: %d)\\n\",\n            SanitizerToolName, size, size, fixed_addr, GetLastError());\n   return res;\n }\n \n+void *MmapNoAccess(uptr size) {\n+  void *res = VirtualAlloc(nullptr, size, MEM_RESERVE, PAGE_NOACCESS);\n+  if (res == 0)\n+    Report(\"WARNING: %s failed to \"\n+           \"mprotect %p (%zd) bytes (error code: %d)\\n\",\n+           SanitizerToolName, size, size, GetLastError());\n+  return res;\n+}\n+\n bool MprotectNoAccess(uptr addr, uptr size) {\n   DWORD old_protection;\n   return VirtualProtect((LPVOID)addr, size, PAGE_NOACCESS, &old_protection);\n }\n \n \n-void FlushUnneededShadowMemory(uptr addr, uptr size) {\n+void ReleaseMemoryToOS(uptr addr, uptr size) {\n   // This is almost useless on 32-bits.\n   // FIXME: add madvise-analog when we move to 64-bits.\n }\n \n void NoHugePagesInRegion(uptr addr, uptr size) {\n-  // FIXME: probably similar to FlushUnneededShadowMemory.\n+  // FIXME: probably similar to ReleaseMemoryToOS.\n }\n \n void DontDumpShadowMemory(uptr addr, uptr length) {\n   // This is almost useless on 32-bits.\n   // FIXME: add madvise-analog when we move to 64-bits.\n }\n \n+uptr FindAvailableMemoryRange(uptr size, uptr alignment, uptr left_padding) {\n+  uptr address = 0;\n+  while (true) {\n+    MEMORY_BASIC_INFORMATION info;\n+    if (!::VirtualQuery((void*)address, &info, sizeof(info)))\n+      return 0;\n+\n+    if (info.State == MEM_FREE) {\n+      uptr shadow_address = RoundUpTo((uptr)info.BaseAddress + left_padding,\n+                                      alignment);\n+      if (shadow_address + size < (uptr)info.BaseAddress + info.RegionSize)\n+        return shadow_address;\n+    }\n+\n+    // Move to the next region.\n+    address = (uptr)info.BaseAddress + info.RegionSize;\n+  }\n+  return 0;\n+}\n+\n bool MemoryRangeIsAvailable(uptr range_start, uptr range_end) {\n   MEMORY_BASIC_INFORMATION mbi;\n   CHECK(VirtualQuery((void *)range_start, &mbi, sizeof(mbi)));\n@@ -218,7 +332,7 @@ struct ModuleInfo {\n   uptr end_address;\n };\n \n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n int CompareModulesBase(const void *pl, const void *pr) {\n   const ModuleInfo *l = (ModuleInfo *)pl, *r = (ModuleInfo *)pr;\n   if (l->base_address < r->base_address)\n@@ -228,18 +342,18 @@ int CompareModulesBase(const void *pl, const void *pr) {\n #endif\n }  // namespace\n \n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n void DumpProcessMap() {\n   Report(\"Dumping process modules:\\n\");\n-  InternalScopedBuffer<LoadedModule> modules(kMaxNumberOfModules);\n-  uptr num_modules =\n-      GetListOfModules(modules.data(), kMaxNumberOfModules, nullptr);\n+  ListOfModules modules;\n+  modules.init();\n+  uptr num_modules = modules.size();\n \n   InternalScopedBuffer<ModuleInfo> module_infos(num_modules);\n   for (size_t i = 0; i < num_modules; ++i) {\n     module_infos[i].filepath = modules[i].full_name();\n-    module_infos[i].base_address = modules[i].base_address();\n-    module_infos[i].end_address = modules[i].ranges().next()->end;\n+    module_infos[i].base_address = modules[i].ranges().front()->beg;\n+    module_infos[i].end_address = modules[i].ranges().back()->end;\n   }\n   qsort(module_infos.data(), num_modules, sizeof(ModuleInfo),\n         CompareModulesBase);\n@@ -314,6 +428,7 @@ void Abort() {\n   internal__exit(3);\n }\n \n+#if !SANITIZER_GO\n // Read the file to extract the ImageBase field from the PE header. If ASLR is\n // disabled and this virtual address is available, the loader will typically\n // load the image at this address. Therefore, we call it the preferred base. Any\n@@ -366,9 +481,8 @@ static uptr GetPreferredBase(const char *modname) {\n   return (uptr)pe_header->ImageBase;\n }\n \n-#ifndef SANITIZER_GO\n-uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n-                      string_predicate_t filter) {\n+void ListOfModules::init() {\n+  clear();\n   HANDLE cur_process = GetCurrentProcess();\n \n   // Query the list of modules.  Start by assuming there are no more than 256\n@@ -390,10 +504,8 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n   }\n \n   // |num_modules| is the number of modules actually present,\n-  // |count| is the number of modules we return.\n-  size_t nun_modules = bytes_required / sizeof(HMODULE),\n-         count = 0;\n-  for (size_t i = 0; i < nun_modules && count < max_modules; ++i) {\n+  size_t num_modules = bytes_required / sizeof(HMODULE);\n+  for (size_t i = 0; i < num_modules; ++i) {\n     HMODULE handle = hmodules[i];\n     MODULEINFO mi;\n     if (!GetModuleInformation(cur_process, handle, &mi, sizeof(mi)))\n@@ -411,9 +523,6 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n                               &module_name[0], kMaxPathLength, NULL, NULL);\n     module_name[module_name_len] = '\\0';\n \n-    if (filter && !filter(module_name))\n-      continue;\n-\n     uptr base_address = (uptr)mi.lpBaseOfDll;\n     uptr end_address = (uptr)mi.lpBaseOfDll + mi.SizeOfImage;\n \n@@ -424,15 +533,13 @@ uptr GetListOfModules(LoadedModule *modules, uptr max_modules,\n     uptr preferred_base = GetPreferredBase(&module_name[0]);\n     uptr adjusted_base = base_address - preferred_base;\n \n-    LoadedModule *cur_module = &modules[count];\n-    cur_module->set(module_name, adjusted_base);\n+    LoadedModule cur_module;\n+    cur_module.set(module_name, adjusted_base);\n     // We add the whole module as one single address range.\n-    cur_module->addAddressRange(base_address, end_address, /*executable*/ true);\n-    count++;\n+    cur_module.addAddressRange(base_address, end_address, /*executable*/ true);\n+    modules_.push_back(cur_module);\n   }\n   UnmapOrDie(hmodules, modules_buffer_size);\n-\n-  return count;\n };\n \n // We can't use atexit() directly at __asan_init time as the CRT is not fully\n@@ -459,14 +566,15 @@ __declspec(allocate(\".CRT$XID\")) int (*__run_atexit)() = RunAtexit;\n \n // ------------------ sanitizer_libc.h\n fd_t OpenFile(const char *filename, FileAccessMode mode, error_t *last_error) {\n+  // FIXME: Use the wide variants to handle Unicode filenames.\n   fd_t res;\n   if (mode == RdOnly) {\n-    res = CreateFile(filename, GENERIC_READ,\n-                     FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n-                     nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n+    res = CreateFileA(filename, GENERIC_READ,\n+                      FILE_SHARE_READ | FILE_SHARE_WRITE | FILE_SHARE_DELETE,\n+                      nullptr, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, nullptr);\n   } else if (mode == WrOnly) {\n-    res = CreateFile(filename, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS,\n-                     FILE_ATTRIBUTE_NORMAL, nullptr);\n+    res = CreateFileA(filename, GENERIC_WRITE, 0, nullptr, CREATE_ALWAYS,\n+                      FILE_ATTRIBUTE_NORMAL, nullptr);\n   } else {\n     UNIMPLEMENTED();\n   }\n@@ -613,7 +721,7 @@ void InitTlsSize() {\n \n void GetThreadStackAndTls(bool main, uptr *stk_addr, uptr *stk_size,\n                           uptr *tls_addr, uptr *tls_size) {\n-#ifdef SANITIZER_GO\n+#if SANITIZER_GO\n   *stk_addr = 0;\n   *stk_size = 0;\n   *tls_addr = 0;\n@@ -634,7 +742,7 @@ void BufferedStackTrace::SlowUnwindStack(uptr pc, u32 max_depth) {\n   // FIXME: CaptureStackBackTrace might be too slow for us.\n   // FIXME: Compare with StackWalk64.\n   // FIXME: Look at LLVMUnhandledExceptionFilter in Signals.inc\n-  size = CaptureStackBackTrace(2, Min(max_depth, kStackTraceMax),\n+  size = CaptureStackBackTrace(1, Min(max_depth, kStackTraceMax),\n                                (void**)trace, 0);\n   if (size == 0)\n     return;\n@@ -649,6 +757,9 @@ void BufferedStackTrace::SlowUnwindStackWithContext(uptr pc, void *context,\n   CONTEXT ctx = *(CONTEXT *)context;\n   STACKFRAME64 stack_frame;\n   memset(&stack_frame, 0, sizeof(stack_frame));\n+\n+  InitializeDbgHelpIfNeeded();\n+\n   size = 0;\n #if defined(_WIN64)\n   int machine_type = IMAGE_FILE_MACHINE_AMD64;\n@@ -697,7 +808,7 @@ void InstallDeadlySignalHandlers(SignalHandlerType handler) {\n   // FIXME: Decide what to do on Windows.\n }\n \n-bool IsDeadlySignal(int signum) {\n+bool IsHandledDeadlySignal(int signum) {\n   // FIXME: Decide what to do on Windows.\n   return false;\n }\n@@ -728,8 +839,8 @@ bool IsAccessibleMemoryRange(uptr beg, uptr size) {\n }\n \n SignalContext SignalContext::Create(void *siginfo, void *context) {\n-  EXCEPTION_RECORD *exception_record = (EXCEPTION_RECORD*)siginfo;\n-  CONTEXT *context_record = (CONTEXT*)context;\n+  EXCEPTION_RECORD *exception_record = (EXCEPTION_RECORD *)siginfo;\n+  CONTEXT *context_record = (CONTEXT *)context;\n \n   uptr pc = (uptr)exception_record->ExceptionAddress;\n #ifdef _WIN64\n@@ -741,7 +852,19 @@ SignalContext SignalContext::Create(void *siginfo, void *context) {\n #endif\n   uptr access_addr = exception_record->ExceptionInformation[1];\n \n-  return SignalContext(context, access_addr, pc, sp, bp);\n+  // The contents of this array are documented at\n+  // https://msdn.microsoft.com/en-us/library/windows/desktop/aa363082(v=vs.85).aspx\n+  // The first element indicates read as 0, write as 1, or execute as 8.  The\n+  // second element is the faulting address.\n+  WriteFlag write_flag = SignalContext::UNKNOWN;\n+  switch (exception_record->ExceptionInformation[0]) {\n+  case 0: write_flag = SignalContext::READ; break;\n+  case 1: write_flag = SignalContext::WRITE; break;\n+  case 8: write_flag = SignalContext::UNKNOWN; break;\n+  }\n+  bool is_memory_access = write_flag != SignalContext::UNKNOWN;\n+  return SignalContext(context, access_addr, pc, sp, bp, is_memory_access,\n+                       write_flag);\n }\n \n uptr ReadBinaryName(/*out*/char *buf, uptr buf_len) {\n@@ -759,6 +882,49 @@ void CheckVMASize() {\n   // Do nothing.\n }\n \n+void MaybeReexec() {\n+  // No need to re-exec on Windows.\n+}\n+\n+char **GetArgv() {\n+  // FIXME: Actually implement this function.\n+  return 0;\n+}\n+\n+pid_t StartSubprocess(const char *program, const char *const argv[],\n+                      fd_t stdin_fd, fd_t stdout_fd, fd_t stderr_fd) {\n+  // FIXME: implement on this platform\n+  // Should be implemented based on\n+  // SymbolizerProcess::StarAtSymbolizerSubprocess\n+  // from lib/sanitizer_common/sanitizer_symbolizer_win.cc.\n+  return -1;\n+}\n+\n+bool IsProcessRunning(pid_t pid) {\n+  // FIXME: implement on this platform.\n+  return false;\n+}\n+\n+int WaitForProcess(pid_t pid) { return -1; }\n+\n+// FIXME implement on this platform.\n+void GetMemoryProfile(fill_profile_f cb, uptr *stats, uptr stats_size) { }\n+\n+\n }  // namespace __sanitizer\n \n+#if !SANITIZER_GO\n+// Workaround to implement weak hooks on Windows. COFF doesn't directly support\n+// weak symbols, but it does support /alternatename, which is similar. If the\n+// user does not override the hook, we will use this default definition instead\n+// of null.\n+extern \"C\" void __sanitizer_print_memory_profile(int top_percent) {}\n+\n+#ifdef _WIN64\n+#pragma comment(linker, \"/alternatename:__sanitizer_print_memory_profile=__sanitizer_default_print_memory_profile\") // NOLINT\n+#else\n+#pragma comment(linker, \"/alternatename:___sanitizer_print_memory_profile=___sanitizer_default_print_memory_profile\") // NOLINT\n+#endif\n+#endif\n+\n #endif  // _WIN32"}, {"sha": "7a0c29711433dc89947c5444eb204f9cfc7589e4", "filename": "libsanitizer/tsan/Makefile.am", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.am?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -10,13 +10,16 @@ AM_CXXFLAGS += -std=gnu++11\n ACLOCAL_AMFLAGS = -I m4\n \n toolexeclib_LTLIBRARIES = libtsan.la\n+nodist_toolexeclib_HEADERS = libtsan_preinit.o\n \n tsan_files = \\\n \ttsan_clock.cc \\\n+\ttsan_debugging.cc \\\n \ttsan_fd.cc \\\n \ttsan_flags.cc \\\n \ttsan_ignoreset.cc \\\n \ttsan_interceptors.cc \\\n+\ttsan_interceptors_mac.cc \\\n \ttsan_interface_ann.cc \\\n \ttsan_interface_atomic.cc \\\n \ttsan_interface.cc \\\n@@ -35,6 +38,7 @@ tsan_files = \\\n \ttsan_report.cc \\\n \ttsan_rtl.cc \\\n \ttsan_rtl_mutex.cc \\\n+\ttsan_rtl_proc.cc \\\n \ttsan_rtl_report.cc \\\n \ttsan_rtl_thread.cc \\\n \ttsan_stack_trace.cc \\\n@@ -44,7 +48,7 @@ tsan_files = \\\n \ttsan_sync.cc \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S\n libtsan_la_LIBADD = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n libtsan_la_DEPENDENCIES = $(top_builddir)/sanitizer_common/libsanitizer_common.la $(top_builddir)/interception/libinterception.la $(TSAN_TARGET_DEPENDENT_OBJECTS)\n if LIBBACKTRACE_SUPPORTED\n@@ -54,6 +58,9 @@ endif\n libtsan_la_LIBADD += $(LIBSTDCXX_RAW_CXX_LDFLAGS)\n libtsan_la_LDFLAGS = -version-info `grep -v '^\\#' $(srcdir)/libtool-version` $(link_libtsan)\n \n+libtsan_preinit.o: tsan_preinit.o\n+\tcp $< $@\n+\n # Work around what appears to be a GNU make bug handling MAKEFLAGS\n # values defined in terms of make variables, as is the case for CC and\n # friends when we are called from the top level Makefile."}, {"sha": "4d4ec47becc28497c99cde24bf4730391abe2404", "filename": "libsanitizer/tsan/Makefile.in", "status": "modified", "additions": 60, "deletions": 18, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -15,6 +15,7 @@\n \n @SET_MAKE@\n \n+\n VPATH = @srcdir@\n am__make_dryrun = \\\n   { \\\n@@ -101,20 +102,22 @@ am__uninstall_files_from_dir = { \\\n     || { echo \" ( cd '$$dir' && rm -f\" $$files \")\"; \\\n          $(am__cd) \"$$dir\" && rm -f $$files; }; \\\n   }\n-am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\"\n+am__installdirs = \"$(DESTDIR)$(toolexeclibdir)\" \\\n+\t\"$(DESTDIR)$(toolexeclibdir)\"\n LTLIBRARIES = $(toolexeclib_LTLIBRARIES)\n am__DEPENDENCIES_1 =\n-am__objects_1 = tsan_clock.lo tsan_fd.lo tsan_flags.lo \\\n-\ttsan_ignoreset.lo tsan_interceptors.lo tsan_interface_ann.lo \\\n+am__objects_1 = tsan_clock.lo tsan_debugging.lo tsan_fd.lo \\\n+\ttsan_flags.lo tsan_ignoreset.lo tsan_interceptors.lo \\\n+\ttsan_interceptors_mac.lo tsan_interface_ann.lo \\\n \ttsan_interface_atomic.lo tsan_interface.lo \\\n \ttsan_interface_java.lo tsan_libdispatch_mac.lo \\\n \ttsan_malloc_mac.lo tsan_md5.lo tsan_mman.lo tsan_mutex.lo \\\n \ttsan_mutexset.lo tsan_new_delete.lo tsan_platform_linux.lo \\\n \ttsan_platform_mac.lo tsan_platform_posix.lo \\\n \ttsan_platform_windows.lo tsan_report.lo tsan_rtl.lo \\\n-\ttsan_rtl_mutex.lo tsan_rtl_report.lo tsan_rtl_thread.lo \\\n-\ttsan_stack_trace.lo tsan_stat.lo tsan_suppressions.lo \\\n-\ttsan_symbolize.lo tsan_sync.lo\n+\ttsan_rtl_mutex.lo tsan_rtl_proc.lo tsan_rtl_report.lo \\\n+\ttsan_rtl_thread.lo tsan_stack_trace.lo tsan_stat.lo \\\n+\ttsan_suppressions.lo tsan_symbolize.lo tsan_sync.lo\n am_libtsan_la_OBJECTS = $(am__objects_1)\n libtsan_la_OBJECTS = $(am_libtsan_la_OBJECTS)\n libtsan_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -153,6 +156,7 @@ am__can_run_installinfo = \\\n     n|no|NO) false;; \\\n     *) (install-info --version) >/dev/null 2>&1;; \\\n   esac\n+HEADERS = $(nodist_toolexeclib_HEADERS)\n ETAGS = etags\n CTAGS = ctags\n ACLOCAL = @ACLOCAL@\n@@ -225,6 +229,7 @@ PACKAGE_VERSION = @PACKAGE_VERSION@\n PATH_SEPARATOR = @PATH_SEPARATOR@\n RANLIB = @RANLIB@\n RPC_DEFS = @RPC_DEFS@\n+SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS = @SANITIZER_COMMON_TARGET_DEPENDENT_OBJECTS@\n SED = @SED@\n SET_MAKE = @SET_MAKE@\n SHELL = @SHELL@\n@@ -309,12 +314,15 @@ AM_CXXFLAGS = -Wall -W -Wno-unused-parameter -Wwrite-strings -pedantic \\\n \t-std=gnu++11\n ACLOCAL_AMFLAGS = -I m4\n toolexeclib_LTLIBRARIES = libtsan.la\n+nodist_toolexeclib_HEADERS = libtsan_preinit.o\n tsan_files = \\\n \ttsan_clock.cc \\\n+\ttsan_debugging.cc \\\n \ttsan_fd.cc \\\n \ttsan_flags.cc \\\n \ttsan_ignoreset.cc \\\n \ttsan_interceptors.cc \\\n+\ttsan_interceptors_mac.cc \\\n \ttsan_interface_ann.cc \\\n \ttsan_interface_atomic.cc \\\n \ttsan_interface.cc \\\n@@ -333,6 +341,7 @@ tsan_files = \\\n \ttsan_report.cc \\\n \ttsan_rtl.cc \\\n \ttsan_rtl_mutex.cc \\\n+\ttsan_rtl_proc.cc \\\n \ttsan_rtl_report.cc \\\n \ttsan_rtl_thread.cc \\\n \ttsan_stack_trace.cc \\\n@@ -342,7 +351,7 @@ tsan_files = \\\n \ttsan_sync.cc \n \n libtsan_la_SOURCES = $(tsan_files)\n-EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S\n+EXTRA_libtsan_la_SOURCES = tsan_rtl_amd64.S tsan_rtl_aarch64.S tsan_rtl_mips64.S tsan_rtl_ppc64.S\n libtsan_la_LIBADD =  \\\n \t$(top_builddir)/sanitizer_common/libsanitizer_common.la \\\n \t$(top_builddir)/interception/libinterception.la \\\n@@ -469,10 +478,12 @@ distclean-compile:\n \t-rm -f *.tab.c\n \n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_clock.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_debugging.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_fd.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_flags.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_ignoreset.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interceptors.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interceptors_mac.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_ann.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_interface_atomic.Plo@am__quote@\n@@ -492,7 +503,10 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_aarch64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_amd64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mips64.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_mutex.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_ppc64.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_proc.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_report.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_rtl_thread.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/tsan_stack_trace.Plo@am__quote@\n@@ -548,6 +562,27 @@ mostlyclean-libtool:\n \n clean-libtool:\n \t-rm -rf .libs _libs\n+install-nodist_toolexeclibHEADERS: $(nodist_toolexeclib_HEADERS)\n+\t@$(NORMAL_INSTALL)\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tif test -n \"$$list\"; then \\\n+\t  echo \" $(MKDIR_P) '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(MKDIR_P) \"$(DESTDIR)$(toolexeclibdir)\" || exit 1; \\\n+\tfi; \\\n+\tfor p in $$list; do \\\n+\t  if test -f \"$$p\"; then d=; else d=\"$(srcdir)/\"; fi; \\\n+\t  echo \"$$d$$p\"; \\\n+\tdone | $(am__base_list) | \\\n+\twhile read files; do \\\n+\t  echo \" $(INSTALL_HEADER) $$files '$(DESTDIR)$(toolexeclibdir)'\"; \\\n+\t  $(INSTALL_HEADER) $$files \"$(DESTDIR)$(toolexeclibdir)\" || exit $$?; \\\n+\tdone\n+\n+uninstall-nodist_toolexeclibHEADERS:\n+\t@$(NORMAL_UNINSTALL)\n+\t@list='$(nodist_toolexeclib_HEADERS)'; test -n \"$(toolexeclibdir)\" || list=; \\\n+\tfiles=`for p in $$list; do echo $$p; done | sed -e 's|^.*/||'`; \\\n+\tdir='$(DESTDIR)$(toolexeclibdir)'; $(am__uninstall_files_from_dir)\n \n ID: $(HEADERS) $(SOURCES) $(LISP) $(TAGS_FILES)\n \tlist='$(SOURCES) $(HEADERS) $(LISP) $(TAGS_FILES)'; \\\n@@ -602,9 +637,9 @@ distclean-tags:\n \t-rm -f TAGS ID GTAGS GRTAGS GSYMS GPATH tags\n check-am: all-am\n check: check-am\n-all-am: Makefile $(LTLIBRARIES)\n+all-am: Makefile $(LTLIBRARIES) $(HEADERS)\n installdirs:\n-\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n+\tfor dir in \"$(DESTDIR)$(toolexeclibdir)\" \"$(DESTDIR)$(toolexeclibdir)\"; do \\\n \t  test -z \"$$dir\" || $(MKDIR_P) \"$$dir\"; \\\n \tdone\n install: install-am\n@@ -666,7 +701,8 @@ install-dvi: install-dvi-am\n \n install-dvi-am:\n \n-install-exec-am: install-toolexeclibLTLIBRARIES\n+install-exec-am: install-nodist_toolexeclibHEADERS \\\n+\tinstall-toolexeclibLTLIBRARIES\n \n install-html: install-html-am\n \n@@ -706,7 +742,8 @@ ps: ps-am\n \n ps-am:\n \n-uninstall-am: uninstall-toolexeclibLTLIBRARIES\n+uninstall-am: uninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n \n .MAKE: install-am install-strip\n \n@@ -717,13 +754,18 @@ uninstall-am: uninstall-toolexeclibLTLIBRARIES\n \tinstall-am install-data install-data-am install-dvi \\\n \tinstall-dvi-am install-exec install-exec-am install-html \\\n \tinstall-html-am install-info install-info-am install-man \\\n-\tinstall-pdf install-pdf-am install-ps install-ps-am \\\n-\tinstall-strip install-toolexeclibLTLIBRARIES installcheck \\\n-\tinstallcheck-am installdirs maintainer-clean \\\n-\tmaintainer-clean-generic mostlyclean mostlyclean-compile \\\n-\tmostlyclean-generic mostlyclean-libtool pdf pdf-am ps ps-am \\\n-\ttags uninstall uninstall-am uninstall-toolexeclibLTLIBRARIES\n-\n+\tinstall-nodist_toolexeclibHEADERS install-pdf install-pdf-am \\\n+\tinstall-ps install-ps-am install-strip \\\n+\tinstall-toolexeclibLTLIBRARIES installcheck installcheck-am \\\n+\tinstalldirs maintainer-clean maintainer-clean-generic \\\n+\tmostlyclean mostlyclean-compile mostlyclean-generic \\\n+\tmostlyclean-libtool pdf pdf-am ps ps-am tags uninstall \\\n+\tuninstall-am uninstall-nodist_toolexeclibHEADERS \\\n+\tuninstall-toolexeclibLTLIBRARIES\n+\n+\n+libtsan_preinit.o: tsan_preinit.o\n+\tcp $< $@\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "23f9228a672095f33ab48bf2d027b1e00cc37bd9", "filename": "libsanitizer/tsan/tsan_clock.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_clock.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_clock.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_clock.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -80,7 +80,7 @@\n \n // We don't have ThreadState in these methods, so this is an ugly hack that\n // works only in C++.\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n # define CPP_STAT_INC(typ) StatInc(cur_thread(), typ)\n #else\n # define CPP_STAT_INC(typ) (void)0"}, {"sha": "d26d4828b15dbde113f0058594e4e46d7f045aa4", "filename": "libsanitizer/tsan/tsan_debugging.cc", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_debugging.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_debugging.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -0,0 +1,160 @@\n+//===-- tsan_debugging.cc -------------------------------------------------===//\n+//\n+// This file is distributed under the University of Illinois Open Source\n+// License. See LICENSE.TXT for details.\n+//\n+//===----------------------------------------------------------------------===//\n+//\n+// This file is a part of ThreadSanitizer (TSan), a race detector.\n+//\n+// TSan debugging API implementation.\n+//===----------------------------------------------------------------------===//\n+#include \"tsan_interface.h\"\n+#include \"tsan_report.h\"\n+#include \"tsan_rtl.h\"\n+\n+using namespace __tsan;\n+\n+static const char *ReportTypeDescription(ReportType typ) {\n+  if (typ == ReportTypeRace) return \"data-race\";\n+  if (typ == ReportTypeVptrRace) return \"data-race-vptr\";\n+  if (typ == ReportTypeUseAfterFree) return \"heap-use-after-free\";\n+  if (typ == ReportTypeVptrUseAfterFree) return \"heap-use-after-free-vptr\";\n+  if (typ == ReportTypeThreadLeak) return \"thread-leak\";\n+  if (typ == ReportTypeMutexDestroyLocked) return \"locked-mutex-destroy\";\n+  if (typ == ReportTypeMutexDoubleLock) return \"mutex-double-lock\";\n+  if (typ == ReportTypeMutexInvalidAccess) return \"mutex-invalid-access\";\n+  if (typ == ReportTypeMutexBadUnlock) return \"mutex-bad-unlock\";\n+  if (typ == ReportTypeMutexBadReadLock) return \"mutex-bad-read-lock\";\n+  if (typ == ReportTypeMutexBadReadUnlock) return \"mutex-bad-read-unlock\";\n+  if (typ == ReportTypeSignalUnsafe) return \"signal-unsafe-call\";\n+  if (typ == ReportTypeErrnoInSignal) return \"errno-in-signal-handler\";\n+  if (typ == ReportTypeDeadlock) return \"lock-order-inversion\";\n+  return \"\";\n+}\n+\n+static const char *ReportLocationTypeDescription(ReportLocationType typ) {\n+  if (typ == ReportLocationGlobal) return \"global\";\n+  if (typ == ReportLocationHeap) return \"heap\";\n+  if (typ == ReportLocationStack) return \"stack\";\n+  if (typ == ReportLocationTLS) return \"tls\";\n+  if (typ == ReportLocationFD) return \"fd\";\n+  return \"\";\n+}\n+\n+static void CopyTrace(SymbolizedStack *first_frame, void **trace,\n+                      uptr trace_size) {\n+  uptr i = 0;\n+  for (SymbolizedStack *frame = first_frame; frame != nullptr;\n+       frame = frame->next) {\n+    trace[i++] = (void *)frame->info.address;\n+    if (i >= trace_size) break;\n+  }\n+}\n+\n+// Meant to be called by the debugger.\n+SANITIZER_INTERFACE_ATTRIBUTE\n+void *__tsan_get_current_report() {\n+  return const_cast<ReportDesc*>(cur_thread()->current_report);\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_data(void *report, const char **description, int *count,\n+                           int *stack_count, int *mop_count, int *loc_count,\n+                           int *mutex_count, int *thread_count,\n+                           int *unique_tid_count, void **sleep_trace,\n+                           uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  *description = ReportTypeDescription(rep->typ);\n+  *count = rep->count;\n+  *stack_count = rep->stacks.Size();\n+  *mop_count = rep->mops.Size();\n+  *loc_count = rep->locs.Size();\n+  *mutex_count = rep->mutexes.Size();\n+  *thread_count = rep->threads.Size();\n+  *unique_tid_count = rep->unique_tids.Size();\n+  if (rep->sleep) CopyTrace(rep->sleep->frames, sleep_trace, trace_size);\n+  return 1;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_stack(void *report, uptr idx, void **trace,\n+                            uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->stacks.Size());\n+  ReportStack *stack = rep->stacks[idx];\n+  if (stack) CopyTrace(stack->frames, trace, trace_size);\n+  return stack ? 1 : 0;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_mop(void *report, uptr idx, int *tid, void **addr,\n+                          int *size, int *write, int *atomic, void **trace,\n+                          uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->mops.Size());\n+  ReportMop *mop = rep->mops[idx];\n+  *tid = mop->tid;\n+  *addr = (void *)mop->addr;\n+  *size = mop->size;\n+  *write = mop->write ? 1 : 0;\n+  *atomic = mop->atomic ? 1 : 0;\n+  if (mop->stack) CopyTrace(mop->stack->frames, trace, trace_size);\n+  return 1;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_loc(void *report, uptr idx, const char **type,\n+                          void **addr, uptr *start, uptr *size, int *tid,\n+                          int *fd, int *suppressable, void **trace,\n+                          uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->locs.Size());\n+  ReportLocation *loc = rep->locs[idx];\n+  *type = ReportLocationTypeDescription(loc->type);\n+  *addr = (void *)loc->global.start;\n+  *start = loc->heap_chunk_start;\n+  *size = loc->heap_chunk_size;\n+  *tid = loc->tid;\n+  *fd = loc->fd;\n+  *suppressable = loc->suppressable;\n+  if (loc->stack) CopyTrace(loc->stack->frames, trace, trace_size);\n+  return 1;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_mutex(void *report, uptr idx, uptr *mutex_id, void **addr,\n+                            int *destroyed, void **trace, uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->mutexes.Size());\n+  ReportMutex *mutex = rep->mutexes[idx];\n+  *mutex_id = mutex->id;\n+  *addr = (void *)mutex->addr;\n+  *destroyed = mutex->destroyed;\n+  if (mutex->stack) CopyTrace(mutex->stack->frames, trace, trace_size);\n+  return 1;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_thread(void *report, uptr idx, int *tid, uptr *os_id,\n+                             int *running, const char **name, int *parent_tid,\n+                             void **trace, uptr trace_size) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->threads.Size());\n+  ReportThread *thread = rep->threads[idx];\n+  *tid = thread->id;\n+  *os_id = thread->os_id;\n+  *running = thread->running;\n+  *name = thread->name;\n+  *parent_tid = thread->parent_tid;\n+  if (thread->stack) CopyTrace(thread->stack->frames, trace, trace_size);\n+  return 1;\n+}\n+\n+SANITIZER_INTERFACE_ATTRIBUTE\n+int __tsan_get_report_unique_tid(void *report, uptr idx, int *tid) {\n+  const ReportDesc *rep = (ReportDesc *)report;\n+  CHECK_LT(idx, rep->unique_tids.Size());\n+  *tid = rep->unique_tids[idx];\n+  return 1;\n+}"}, {"sha": "e540526caa220339aaf93f639429561807d4a107", "filename": "libsanitizer/tsan/tsan_defs.h", "status": "modified", "additions": 7, "deletions": 15, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_defs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_defs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_defs.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -27,27 +27,18 @@\n #endif\n \n #ifndef TSAN_CONTAINS_UBSAN\n-# define TSAN_CONTAINS_UBSAN (CAN_SANITIZE_UB && !defined(SANITIZER_GO))\n+# if CAN_SANITIZE_UB && !SANITIZER_GO\n+#  define TSAN_CONTAINS_UBSAN 1\n+# else\n+#  define TSAN_CONTAINS_UBSAN 0\n+# endif\n #endif\n \n namespace __tsan {\n \n-#ifdef SANITIZER_GO\n-const bool kGoMode = true;\n-const bool kCppMode = false;\n-const char *const kTsanOptionsEnv = \"GORACE\";\n-// Go linker does not support weak symbols.\n-#define CPP_WEAK\n-#else\n-const bool kGoMode = false;\n-const bool kCppMode = true;\n-const char *const kTsanOptionsEnv = \"TSAN_OPTIONS\";\n-#define CPP_WEAK WEAK\n-#endif\n-\n const int kTidBits = 13;\n const unsigned kMaxTid = 1 << kTidBits;\n-#ifndef SANITIZER_GO\n+#if !SANITIZER_GO\n const unsigned kMaxTidInClock = kMaxTid * 2;  // This includes msb 'freed' bit.\n #else\n const unsigned kMaxTidInClock = kMaxTid;  // Go does not track freed memory.\n@@ -146,6 +137,7 @@ struct MD5Hash {\n \n MD5Hash md5_hash(const void *data, uptr size);\n \n+struct Processor;\n struct ThreadState;\n class ThreadContext;\n struct Context;"}, {"sha": "780ff6f4c8e5c387ab9c0d7b42dd65ba40f13ee2", "filename": "libsanitizer/tsan/tsan_dense_alloc.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_dense_alloc.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -106,7 +106,7 @@ class DenseSlabAlloc {\n       // Reserve 0 as invalid index.\n       IndexT start = fillpos_ == 0 ? 1 : 0;\n       for (IndexT i = start; i < kL2Size; i++) {\n-        new(batch + i) T();\n+        new(batch + i) T;\n         *(IndexT*)(batch + i) = i + 1 + fillpos_ * kL2Size;\n       }\n       *(IndexT*)(batch + kL2Size - 1) = 0;"}, {"sha": "5064a0fe65396252b1dabbd770118b8cfc8a2da4", "filename": "libsanitizer/tsan/tsan_flags.cc", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -27,8 +27,8 @@ Flags *flags() {\n #ifdef TSAN_EXTERNAL_HOOKS\n extern \"C\" const char* __tsan_default_options();\n #else\n-extern \"C\" SANITIZER_INTERFACE_ATTRIBUTE\n-const char *WEAK __tsan_default_options() {\n+SANITIZER_WEAK_DEFAULT_IMPL\n+const char *__tsan_default_options() {\n   return \"\";\n }\n #endif\n@@ -59,7 +59,7 @@ void InitializeFlags(Flags *f, const char *env) {\n     CommonFlags cf;\n     cf.CopyFrom(*common_flags());\n     cf.allow_addr2line = true;\n-    if (kGoMode) {\n+    if (SANITIZER_GO) {\n       // Does not work as expected for Go: runtime handles SIGABRT and crashes.\n       cf.abort_on_error = false;\n       // Go does not have mutexes.\n@@ -69,6 +69,7 @@ void InitializeFlags(Flags *f, const char *env) {\n     cf.print_suppressions = false;\n     cf.stack_trace_format = \"    #%n %f %S %M\";\n     cf.exitcode = 66;\n+    cf.intercept_tls_get_addr = true;\n     OverrideCommonFlags(cf);\n   }\n \n@@ -106,7 +107,7 @@ void InitializeFlags(Flags *f, const char *env) {\n     f->report_signal_unsafe = false;\n   }\n \n-  SetVerbosity(common_flags()->verbosity);\n+  InitializeCommonFlags();\n \n   if (Verbosity()) ReportUnrecognizedFlags();\n "}, {"sha": "78f5e80fd5cccf932867afe5523901fc22cf2c6f", "filename": "libsanitizer/tsan/tsan_flags.inc", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_flags.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_flags.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_flags.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2", "patch": "@@ -59,8 +59,9 @@ TSAN_FLAG(bool, stop_on_start, false,\n           \"Stops on start until __tsan_resume() is called (for debugging).\")\n TSAN_FLAG(bool, running_on_valgrind, false,\n           \"Controls whether RunningOnValgrind() returns true or false.\")\n+// There are a lot of goroutines in Go, so we use smaller history.\n TSAN_FLAG(\n-    int, history_size, kGoMode ? 1 : 3, // There are a lot of goroutines in Go.\n+    int, history_size, SANITIZER_GO ? 1 : 3,\n     \"Per-thread history size, controls how many previous memory accesses \"\n     \"are remembered per thread.  Possible values are [0..7]. \"\n     \"history_size=0 amounts to 32K memory accesses.  Each next value doubles \"\n@@ -74,3 +75,7 @@ TSAN_FLAG(int, io_sync, 1,\n TSAN_FLAG(bool, die_after_fork, true,\n           \"Die after multi-threaded fork if the child creates new threads.\")\n TSAN_FLAG(const char *, suppressions, \"\", \"Suppressions file name.\")\n+TSAN_FLAG(bool, ignore_interceptors_accesses, false,\n+          \"Ignore reads and writes from all interceptors.\")\n+TSAN_FLAG(bool, shared_ptr_interceptor, true,\n+          \"Track atomic reference counting in libc++ shared_ptr and weak_ptr.\")"}, {"sha": "bf5f2d5b66ce177b27640f554d54a19d38d384c3", "filename": "libsanitizer/tsan/tsan_interceptors.cc", "status": "modified", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "97fa5085a789d75aafc2d23d9d4681d266069826", "filename": "libsanitizer/tsan/tsan_interceptors.h", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "eaf866d6c75c62c7e282769237a7a7b92e27d4c9", "filename": "libsanitizer/tsan/tsan_interceptors_mac.cc", "status": "added", "additions": 357, "deletions": 0, "changes": 357, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interceptors_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "066dde6f54324b36e4f2be75150f40e06f467a93", "filename": "libsanitizer/tsan/tsan_interface.h", "status": "modified", "additions": 291, "deletions": 0, "changes": 291, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "5c5c34f3b8761c9210d1c049cdb8681dbaebcd2c", "filename": "libsanitizer/tsan/tsan_interface_atomic.cc", "status": "modified", "additions": 10, "deletions": 33, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_atomic.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "d1638f2aa9d3c37f913507694fd9360aa8e0b564", "filename": "libsanitizer/tsan/tsan_interface_java.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_interface_java.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_interface_java.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "10c70a831c63eb1514bd7ce5331b8ab23deda5b0", "filename": "libsanitizer/tsan/tsan_libdispatch_mac.cc", "status": "modified", "additions": 611, "deletions": 2, "changes": 613, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_libdispatch_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "cc1031a584fa9f9204a664509206f2e6129ca1f6", "filename": "libsanitizer/tsan/tsan_malloc_mac.cc", "status": "modified", "additions": 17, "deletions": 26, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_malloc_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "152c2de28d86e200022d7627be9a6ee5ddf599e5", "filename": "libsanitizer/tsan/tsan_mman.cc", "status": "modified", "additions": 87, "deletions": 31, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mman.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mman.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "d49c9a9e9f24eaac231b8e60a6a5d2cea24518bf", "filename": "libsanitizer/tsan/tsan_mman.h", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mman.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mman.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mman.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "9b105cf201be2b3ec95cef02db6c9af4762b1c37", "filename": "libsanitizer/tsan/tsan_mutex.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "bd1000f0b29e1da28b3f26cbb9b9e2b3a0c9c877", "filename": "libsanitizer/tsan/tsan_mutex.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutex.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutex.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutex.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "b2c60b9a826f5f4b3030e21a906dba1ee67c7659", "filename": "libsanitizer/tsan/tsan_mutexset.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_mutexset.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_mutexset.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "606cdd659f40e5b2fe52318606e0b2af54392ea6", "filename": "libsanitizer/tsan/tsan_new_delete.cc", "status": "modified", "additions": 2, "deletions": 6, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_new_delete.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_new_delete.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "368edc21ce47299a7ba8610eb22472ba99ab01c6", "filename": "libsanitizer/tsan/tsan_platform.h", "status": "modified", "additions": 663, "deletions": 197, "changes": 860, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "2ed5718a12e3c546ab3fe58d51a0392e22173e77", "filename": "libsanitizer/tsan/tsan_platform_linux.cc", "status": "modified", "additions": 119, "deletions": 60, "changes": 179, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_linux.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "ff5131e75bb3c5737a81e5029495a72fa99e5942", "filename": "libsanitizer/tsan/tsan_platform_mac.cc", "status": "modified", "additions": 27, "deletions": 22, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_mac.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "0a3b61a08dc4a0c19e19f89fc424658e21c55c7f", "filename": "libsanitizer/tsan/tsan_platform_posix.cc", "status": "modified", "additions": 50, "deletions": 23, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_posix.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "54ec6a655dfc148858720b530046a2c3ed06f695", "filename": "libsanitizer/tsan/tsan_platform_windows.cc", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_platform_windows.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "15bd10ad96bc358fa69618f8ec5e5a45a9230f1b", "filename": "libsanitizer/tsan/tsan_ppc_regs.h", "status": "added", "additions": 94, "deletions": 0, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_ppc_regs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_ppc_regs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_ppc_regs.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "d5d1659c09b69e2628db18c29cd385695c291d09", "filename": "libsanitizer/tsan/tsan_preinit.cc", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_preinit.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_preinit.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_preinit.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "ba3e34fbfa5055c9a2a46a71b92925f489b011d8", "filename": "libsanitizer/tsan/tsan_report.cc", "status": "modified", "additions": 43, "deletions": 9, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "e51ed4f50f8ea55255682d0173e97524d5bede63", "filename": "libsanitizer/tsan/tsan_report.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_report.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_report.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_report.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "07fa165e939c198a4c84cf2e7fac4acb8f7fe82d", "filename": "libsanitizer/tsan/tsan_rtl.cc", "status": "modified", "additions": 71, "deletions": 43, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "522c76002a1bba90d6eff940a97587edafeab1bd", "filename": "libsanitizer/tsan/tsan_rtl.h", "status": "modified", "additions": 68, "deletions": 22, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "ab5a830d60c06038c9b2ba6829e1a1a8984194d3", "filename": "libsanitizer/tsan/tsan_rtl_aarch64.S", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_aarch64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "caa832375e52d9c1b23b00d4533b75da7ceeb43e", "filename": "libsanitizer/tsan/tsan_rtl_amd64.S", "status": "modified", "additions": 69, "deletions": 32, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_amd64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "b1c9d8bb12d893fc4453485d5e8ef28df36b0f90", "filename": "libsanitizer/tsan/tsan_rtl_mips64.S", "status": "added", "additions": 212, "deletions": 0, "changes": 212, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_mips64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_mips64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mips64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "e575bbfb7e9e8089810bad7d1bc5c1f983dfc810", "filename": "libsanitizer/tsan/tsan_rtl_mutex.cc", "status": "modified", "additions": 39, "deletions": 28, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_mutex.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "81d309fbd2ff7571d818b7ba2cd056751d055bb3", "filename": "libsanitizer/tsan/tsan_rtl_ppc64.S", "status": "added", "additions": 286, "deletions": 0, "changes": 286, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_ppc64.S?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "1b0a9b38938a28ded316ecbbb240431df687a0f7", "filename": "libsanitizer/tsan/tsan_rtl_proc.cc", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_proc.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_proc.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_proc.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "8f2882485e61ee1d7c023d1f291dde8d8ab72dfe", "filename": "libsanitizer/tsan/tsan_rtl_report.cc", "status": "modified", "additions": 47, "deletions": 24, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_report.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "6c4b74e2a76b91732585161d109341f738d9b508", "filename": "libsanitizer/tsan/tsan_rtl_thread.cc", "status": "modified", "additions": 20, "deletions": 26, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_rtl_thread.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "740cb86c69e371745f5b4082712b3b7b053696f0", "filename": "libsanitizer/tsan/tsan_stat.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_stat.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_stat.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "788adeb56eaf335334022808bb3490effdd6e72b", "filename": "libsanitizer/tsan/tsan_stat.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_stat.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_stat.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_stat.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "dc862b1b9adc1cd497aab139377a67ecdcd7a1b1", "filename": "libsanitizer/tsan/tsan_suppressions.cc", "status": "modified", "additions": 9, "deletions": 6, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_suppressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_suppressions.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "7b04782d1ad72c440ab2b911f324fcca59c7a78a", "filename": "libsanitizer/tsan/tsan_symbolize.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_symbolize.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_symbolize.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "0ee2295e69e952ea9a77d49b3945b30fd6ec3d04", "filename": "libsanitizer/tsan/tsan_sync.cc", "status": "modified", "additions": 39, "deletions": 30, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_sync.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_sync.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "48d7027b428e3807eb1f890a54b29f10cfd64908", "filename": "libsanitizer/tsan/tsan_sync.h", "status": "modified", "additions": 10, "deletions": 10, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_sync.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_sync.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_sync.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "1ea733bfd07a19f7ea417c33664febdab12c5f4f", "filename": "libsanitizer/tsan/tsan_trace.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_trace.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Ftsan%2Ftsan_trace.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Ftsan%2Ftsan_trace.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "a816d095f6a29aac804633592c8c61c43b37ea21", "filename": "libsanitizer/ubsan/Makefile.in", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2FMakefile.in?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "ea85877198a7b0a0a7c6d225d93ad684db67bddc", "filename": "libsanitizer/ubsan/ubsan_checks.inc", "status": "modified", "additions": 24, "deletions": 32, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_checks.inc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_checks.inc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_checks.inc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "b6e982a170e7d6ba3402e383c0ba4fd26293f00b", "filename": "libsanitizer/ubsan/ubsan_diag.cc", "status": "modified", "additions": 133, "deletions": 96, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_diag.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_diag.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "3456aaa72c555a02f64c4d04edae4736c72e6272", "filename": "libsanitizer/ubsan/ubsan_diag.h", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_diag.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_diag.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_diag.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "19f5de1727e12d7b87d5cdb41fa091cad4374f78", "filename": "libsanitizer/ubsan/ubsan_flags.cc", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_flags.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_flags.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_flags.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "0e343d32307cc1e7c74f7fdd0d16cc31111f21c6", "filename": "libsanitizer/ubsan/ubsan_handlers.cc", "status": "modified", "additions": 164, "deletions": 90, "changes": 254, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "ef741ca58efed8ebdd1bea515126aa821f6fc4f5", "filename": "libsanitizer/ubsan/ubsan_handlers.h", "status": "modified", "additions": 15, "deletions": 4, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "015a9ffee022ec91256b0ca013514f71505f8f8d", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.cc", "status": "modified", "additions": 65, "deletions": 40, "changes": 105, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "37382359b1e50ecf2c36ebe9ed20d390046899e1", "filename": "libsanitizer/ubsan/ubsan_handlers_cxx.h", "status": "modified", "additions": 0, "deletions": 14, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_handlers_cxx.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "07f748109e725bb8bf73a66f4747fef525658e1f", "filename": "libsanitizer/ubsan/ubsan_init.cc", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_init.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_init.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_init.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "fa4e1a191aa379f89b10ec74b5cec581173b68a5", "filename": "libsanitizer/ubsan/ubsan_platform.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_platform.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_platform.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_platform.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "610fcb44ea7dc27d92e02ff885cdcf9835486476", "filename": "libsanitizer/ubsan/ubsan_type_hash.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_type_hash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash.h?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "790b126815d5a37db708c8e783ac4064e5ee277c", "filename": "libsanitizer/ubsan/ubsan_type_hash_itanium.cc", "status": "modified", "additions": 16, "deletions": 6, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_type_hash_itanium.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}, {"sha": "3e158f92e07135309f5bf184d4f31de0c45f9f56", "filename": "libsanitizer/ubsan/ubsan_value.cc", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_value.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1018981977de9f2056cdfcd8173458e85a3751f2/libsanitizer%2Fubsan%2Fubsan_value.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libsanitizer%2Fubsan%2Fubsan_value.cc?ref=1018981977de9f2056cdfcd8173458e85a3751f2"}]}