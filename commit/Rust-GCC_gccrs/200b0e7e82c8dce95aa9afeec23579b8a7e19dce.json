{"sha": "200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjAwYjBlN2U4MmM4ZGNlOTVhYTlhZmVlYzIzNTc5YjhhN2UxOWRjZQ==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-07-30T13:45:11Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-07-30T13:45:11Z"}, "message": "Deduce automatically number of cores for -flto option.\n\n2019-07-30  Martin Liska  <mliska@suse.cz>\n\n\t* doc/invoke.texi: Document new behavior.\n\t* lto-wrapper.c (cpuset_popcount): New function\n\tis a copy of libgomp/config/linux/proc.c.\n\t(init_num_threads): Likewise.\n\t(run_gcc): Automatically detect core count for -flto.\n\t(jobserver_active_p): New function.\n\nFrom-SVN: r273908", "tree": {"sha": "a5efa797445792b12e8b6eead11a19bb753419bc", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a5efa797445792b12e8b6eead11a19bb753419bc"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "html_url": "https://github.com/Rust-GCC/gccrs/commit/200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "029ca38849484689c7cea5757f6eb646404264ec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/029ca38849484689c7cea5757f6eb646404264ec", "html_url": "https://github.com/Rust-GCC/gccrs/commit/029ca38849484689c7cea5757f6eb646404264ec"}], "stats": {"total": 179, "additions": 171, "deletions": 8}, "files": [{"sha": "b921f1e2671111e30085f94ac16bb3dd3afd8a56", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "patch": "@@ -1,3 +1,12 @@\n+2019-07-30  Martin Liska  <mliska@suse.cz>\n+\n+\t* doc/invoke.texi: Document new behavior.\n+\t* lto-wrapper.c (cpuset_popcount): New function\n+\tis a copy of libgomp/config/linux/proc.c.\n+\t(init_num_threads): Likewise.\n+\t(run_gcc): Automatically detect core count for -flto.\n+\t(jobserver_active_p): New function.\n+\n 2019-07-30  Richard Biener  <rguenther@suse.de>\n \n \tPR tree-optimization/91257"}, {"sha": "c27a40719bc156cf41937ad6bc53cbb4ed551a15", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "patch": "@@ -10396,7 +10396,8 @@ If you specify the optional @var{n}, the optimization and code\n generation done at link time is executed in parallel using @var{n}\n parallel jobs by utilizing an installed @command{make} program.  The\n environment variable @env{MAKE} may be used to override the program\n-used.  The default value for @var{n} is 1.\n+used.  The default value for @var{n} is automatically detected based\n+on number of cores.\n \n You can also specify @option{-flto=jobserver} to use GNU make's\n job server mode to determine the number of parallel jobs. This"}, {"sha": "353187c60434f43a445e708dcfbf53c857f8cdc1", "filename": "gcc/lto-wrapper.c", "status": "modified", "additions": 160, "deletions": 7, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2Flto-wrapper.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/200b0e7e82c8dce95aa9afeec23579b8a7e19dce/gcc%2Flto-wrapper.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Flto-wrapper.c?ref=200b0e7e82c8dce95aa9afeec23579b8a7e19dce", "patch": "@@ -1110,6 +1110,136 @@ cmp_priority (const void *a, const void *b)\n   return *((const int *)b)-*((const int *)a);\n }\n \n+/* Number of CPUs that can be used for parallel LTRANS phase.  */\n+\n+static unsigned long nthreads_var = 0;\n+\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+unsigned long cpuset_size;\n+static unsigned long get_cpuset_size;\n+cpu_set_t *cpusetp;\n+\n+unsigned long\n+static cpuset_popcount (unsigned long cpusetsize, cpu_set_t *cpusetp)\n+{\n+#ifdef CPU_COUNT_S\n+  /* glibc 2.7 and above provide a macro for this.  */\n+  return CPU_COUNT_S (cpusetsize, cpusetp);\n+#else\n+#ifdef CPU_COUNT\n+  if (cpusetsize == sizeof (cpu_set_t))\n+    /* glibc 2.6 and above provide a macro for this.  */\n+    return CPU_COUNT (cpusetp);\n+#endif\n+  size_t i;\n+  unsigned long ret = 0;\n+  STATIC_ASSERT (sizeof (cpusetp->__bits[0]) == sizeof (unsigned long int));\n+  for (i = 0; i < cpusetsize / sizeof (cpusetp->__bits[0]); i++)\n+    {\n+      unsigned long int mask = cpusetp->__bits[i];\n+      if (mask == 0)\n+\tcontinue;\n+      ret += __builtin_popcountl (mask);\n+    }\n+  return ret;\n+#endif\n+}\n+#endif\n+\n+/* At startup, determine the default number of threads.  It would seem\n+   this should be related to the number of cpus online.  */\n+\n+static void\n+init_num_threads (void)\n+{\n+#ifdef HAVE_PTHREAD_AFFINITY_NP\n+#if defined (_SC_NPROCESSORS_CONF) && defined (CPU_ALLOC_SIZE)\n+  cpuset_size = sysconf (_SC_NPROCESSORS_CONF);\n+  cpuset_size = CPU_ALLOC_SIZE (cpuset_size);\n+#else\n+  cpuset_size = sizeof (cpu_set_t);\n+#endif\n+\n+  cpusetp = (cpu_set_t *) xmalloc (gomp_cpuset_size);\n+  do\n+    {\n+      int ret = pthread_getaffinity_np (pthread_self (), gomp_cpuset_size,\n+\t\t\t\t\tcpusetp);\n+      if (ret == 0)\n+\t{\n+\t  /* Count only the CPUs this process can use.  */\n+\t  nthreads_var = cpuset_popcount (cpuset_size, cpusetp);\n+\t  if (nthreads_var == 0)\n+\t    break;\n+\t  get_cpuset_size = cpuset_size;\n+#ifdef CPU_ALLOC_SIZE\n+\t  unsigned long i;\n+\t  for (i = cpuset_size * 8; i; i--)\n+\t    if (CPU_ISSET_S (i - 1, cpuset_size, cpusetp))\n+\t      break;\n+\t  cpuset_size = CPU_ALLOC_SIZE (i);\n+#endif\n+\t  return;\n+\t}\n+      if (ret != EINVAL)\n+\tbreak;\n+#ifdef CPU_ALLOC_SIZE\n+      if (cpuset_size < sizeof (cpu_set_t))\n+\tcpuset_size = sizeof (cpu_set_t);\n+      else\n+\tcpuset_size = cpuset_size * 2;\n+      if (cpuset_size < 8 * sizeof (cpu_set_t))\n+\tcpusetp\n+\t  = (cpu_set_t *) realloc (cpusetp, cpuset_size);\n+      else\n+\t{\n+\t  /* Avoid fatal if too large memory allocation would be\n+\t     requested, e.g. kernel returning EINVAL all the time.  */\n+\t  void *p = realloc (cpusetp, cpuset_size);\n+\t  if (p == NULL)\n+\t    break;\n+\t  cpusetp = (cpu_set_t *) p;\n+\t}\n+#else\n+      break;\n+#endif\n+    }\n+  while (1);\n+  cpuset_size = 0;\n+  nthreads_var = 1;\n+  free (cpusetp);\n+  cpusetp = NULL;\n+#endif\n+#ifdef _SC_NPROCESSORS_ONLN\n+  nthreads_var = sysconf (_SC_NPROCESSORS_ONLN);\n+#endif\n+}\n+\n+/* FIXME: once using -std=c11, we can use std::thread::hardware_concurrency.  */\n+\n+/* Return true when a jobserver is running and can accept a job.  */\n+\n+static bool\n+jobserver_active_p (void)\n+{\n+  const char *makeflags = getenv (\"MAKEFLAGS\");\n+  if (makeflags == NULL)\n+    return false;\n+\n+  const char *needle = \"--jobserver-auth=\";\n+  const char *n = strstr (makeflags, needle);\n+  if (n == NULL)\n+    return false;\n+\n+  int rfd = -1;\n+  int wfd = -1;\n+\n+  return ((sscanf(n, \"--jobserver-auth=%d,%d\", &rfd, &wfd) == 2)\n+\t  && rfd > 0\n+\t  && wfd > 0\n+\t  && fcntl (rfd, F_GETFD) >= 0\n+\t  && fcntl (wfd, F_GETFD) >= 0);\n+}\n \n /* Execute gcc. ARGC is the number of arguments. ARGV contains the arguments. */\n \n@@ -1122,8 +1252,10 @@ run_gcc (unsigned argc, char *argv[])\n   char *list_option_full = NULL;\n   const char *linker_output = NULL;\n   const char *collect_gcc, *collect_gcc_options;\n-  int parallel = 0;\n+  /* Make linking parallel by default.  */\n+  int parallel = 1;\n   int jobserver = 0;\n+  int auto_parallel = 0;\n   bool no_partition = false;\n   struct cl_decoded_option *fdecoded_options = NULL;\n   struct cl_decoded_option *offload_fdecoded_options = NULL;\n@@ -1247,10 +1379,7 @@ run_gcc (unsigned argc, char *argv[])\n \n \tcase OPT_flto_:\n \t  if (strcmp (option->arg, \"jobserver\") == 0)\n-\t    {\n-\t      jobserver = 1;\n-\t      parallel = 1;\n-\t    }\n+\t    jobserver = 1;\n \t  else\n \t    {\n \t      parallel = atoi (option->arg);\n@@ -1291,8 +1420,17 @@ run_gcc (unsigned argc, char *argv[])\n     {\n       lto_mode = LTO_MODE_LTO;\n       jobserver = 0;\n+      auto_parallel = 0;\n       parallel = 0;\n     }\n+  else if (!jobserver && parallel)\n+    {\n+      /* If there's no explicit usage of jobserver and\n+\t parallel is enabled, then automatically detect\n+\t jobserver or number of cores.  */\n+      auto_parallel = 1;\n+      jobserver = jobserver_active_p ();\n+    }\n \n   if (linker_output)\n     {\n@@ -1484,7 +1622,21 @@ run_gcc (unsigned argc, char *argv[])\n       strcpy (tmp, ltrans_output_file);\n \n       if (jobserver)\n-\tobstack_ptr_grow (&argv_obstack, xstrdup (\"-fwpa=jobserver\"));\n+\t{\n+\t  if (verbose)\n+\t    fprintf (stderr, \"Using make jobserver\\n\");\n+\t  obstack_ptr_grow (&argv_obstack, xstrdup (\"-fwpa=jobserver\"));\n+\t}\n+      else if (auto_parallel)\n+\t{\n+\t  char buf[256];\n+\t  init_num_threads ();\n+\t  if (verbose)\n+\t    fprintf (stderr, \"LTO parallelism level set to %ld\\n\",\n+\t\t     nthreads_var);\n+\t  sprintf (buf, \"-fwpa=%ld\", nthreads_var);\n+\t  obstack_ptr_grow (&argv_obstack, xstrdup (buf));\n+\t}\n       else if (parallel > 1)\n \t{\n \t  char buf[256];\n@@ -1692,7 +1844,8 @@ run_gcc (unsigned argc, char *argv[])\n \t  i = 3;\n \t  if (!jobserver)\n \t    {\n-\t      snprintf (jobs, 31, \"-j%d\", parallel);\n+\t      snprintf (jobs, 31, \"-j%ld\",\n+\t\t\tauto_parallel ? nthreads_var : parallel);\n \t      new_argv[i++] = jobs;\n \t    }\n \t  new_argv[i++] = \"all\";"}]}