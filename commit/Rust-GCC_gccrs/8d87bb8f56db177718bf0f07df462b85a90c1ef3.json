{"sha": "8d87bb8f56db177718bf0f07df462b85a90c1ef3", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQ4N2JiOGY1NmRiMTc3NzE4YmYwZjA3ZGY0NjJiODVhOTBjMWVmMw==", "commit": {"author": {"name": "Eric Botcazou", "email": "ebotcazou@adacore.com", "date": "2020-10-13T16:15:40Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2020-11-26T08:40:00Z"}, "message": "[Ada] Add support for 128-bit fixed-point types on 64-bit platforms\n\ngcc/ada/\n\n\t* Makefile.rtl (GNATRTL_NONTASKING_OBJS): Likewise.\n\t(GNATRTL_128BIT_OBJS): Likewise.\n\t(GNATRTL_128BIT_PAIRS): Add new 128-bit variants.\n\t* cstand.adb (Create_Standard): Create Standard_Integer_128.\n\t* doc/gnat_rm/implementation_defined_characteristics.rst: Document\n\tnew limits on 64-bit platforms in entry for 3.5.9(10).\n\t* gnat_rm.texi: Regenerate.\n\t* exp_attr.adb: Add with and use clauses for Urealp.\n\t(Expand_N_Attribute_Reference) <Attribute_Fore>: Call new routines\n\tfor decimal fixed-point types and common ordinary fixed-point types.\n\t* exp_ch4.adb (Real_Range_Check): Extend conversion trick to all\n\tordinary fixed-point types and use Small_Integer_Type_For.\n\t* exp_fixd.adb: Add with and use clauses for Ttypes.\n\t(Build_Divide): Add special case for 32-bit values and deal with\n\t128-bit types.\n\t(Build_Double_Divide): Deal with 128-bit types.\n\t(Build_Double_Divide_Code): Likewise.  Do not apply conversions\n\tbefore calling Build_Multiply.\n\t(Build_Multiply): Likewise.  Add special case for 32-bit values.\n\t(Build_Scaled_Divide): Deal with 128-bit types.\n\t(Build_Scaled_Divide_Code): Likewise.  Fix size computation.  Do not\n\tapply conversions before calling Build_Multiply.\n\t(Do_Multiply_Fixed_Fixed): Minor tweak.\n\t(Integer_Literal): Deal with 128-bit values.\n\t* exp_imgv.adb (Has_Decimal_Small): Delete.\n\t(Expand_Image_Attribute): Call new routines for common ordinary\n\tfixed-point types.\n\t(Expand_Value_Attribute): Likewise.\n\t(Expand_Width_Attribute): Add new expansion for fixed-point types.\n\t* freeze.adb (Freeze_Entity): Move error checks for ordinary\n\tfixed-point types to...\n\t(Freeze_Fixed_Point_Type): ...here.  Deal with 128-bit types and\n\tadjust limitations for 32-bnt and 64-bit types.\n\t* rtsfind.ads (RTU_Id): Add entries for new System_Fore, System_Img,\n\tand System_Val units and remove them for obsolete units.\n\t(RE_Id): Add entries for Double_Divide128, Scaled_Divide128, the new\n\tFore, Image, Value routines and remove them for obsolete units.\n\t(RE_Unit_Table): Likewise.\n\t* sem_ch3.adb (Decimal_Fixed_Point_Type_Declaration): Deal with\n\t128-bit types.\n\t* stand.ads (Standard_Entity_Type): Add Standard_Integer_128.\n\t* uintp.ads (Uint_31): New deferred constant.\n\t(Uint_Minus_18): Likewise.\n\t(Uint_Minus_31): Likewise.\n\t(Uint_Minus_76): Likewise.\n\t(Uint_Minus_127): Likewise.\n\t* urealp.ads (Ureal_2_31): New function.\n\t(Ureal_2_63): Likewise.\n\t(Ureal_2_127): Likewise.\n\t(Ureal_2_M_127): Likewise.\n\t(Ureal_2_10_18): Likewise.\n\t(Ureal_M_2_10_18): Likewise.\n\t(Ureal_9_10_36): Likewise.\n\t(Ureal_M_9_10_36): Likewise.\n\t(Ureal_10_76): Likewise.\n\t(Ureal_M_10_76): Likewise.\n\t(Ureal_10_36): Delete.\n\t(Ureal_M_10_36): Likewise.\n\t* urealp.adb (UR_2_10_18): New variable.\n\t(UR_9_10_36): Likewise.\n\t(UR_10_76): Likewise.\n\t(UR_M_2_10_18): Likewise.\n\t(UR_M_9_10_36): Likewise.\n\t(UR_M_10_76): Likewise.\n\t(UR_2_31): Likewise.\n\t(UR_2_63): Likewise.\n\t(UR_2_127): Likewise.\n\t(UR_2_M_127): Likewise.\n\t(UR_10_36): Delete.\n\t(UR_M_10_36): Likewise.\n\t(Initialize): Initialize them.\n\t(UR_Write): Do not use awkward Ada literal style.\n\t(Ureal_2_10_18): New function.\n\t(Ureal_9_10_36): Likewise.\n\t(Ureal_10_76): Likewise.\n\t(Ureal_2_31): Likewise.\n\t(Ureal_2_63): Likewise.\n\t(Ureal_2_127): Likewise.\n\t(Ureal_2_M_127): Likewise.\n\t(Ureal_M_2_10_18): Likewise.\n\t(Ureal_M_9_10_36): Likewise.\n\t(Ureal_10_76): Likewise.\n\t(Ureal_M_10_76): Likewise.\n\t(Ureal_10_36): Delete.\n\t(Ureal_M_10_36): Likewise.\n\t* libgnat/a-decima__128.ads: New file.\n\t* libgnat/a-tideau.ads, libgnat/a-tideau.adb: Reimplement as\n\tgeneric unit.\n\t* libgnat/a-tideio.adb: Reimplement.\n\t* libgnat/a-tideio__128.adb: New file.\n\t* libgnat/a-tifiau.ads, libgnat/a-tifiau.adb: New generic unit.\n\t* libgnat/a-tifiio.adb: Move bulk of implementation to s-imagef\n\tand reimplement.\n\t* libgnat/a-tifiio__128.adb: New file.\n\t* libgnat/a-tiflau.adb (Get): Minor consistency fix.\n\t(Gets): Likewise.\n\t* libgnat/a-wtdeau.ads, libgnat/a-wtdeau.adb: Reimplement as\n\tgeneric unit.\n\t* libgnat/a-wtdeio.adb: Reimplement.\n\t* libgnat/a-wtdeio__128.adb: New file.\n\t* libgnat/a-wtfiau.ads, libgnat/a-wtfiau.adb: New generic unit.\n\t* libgnat/a-wtfiio.adb: Reimplement.\n\t* libgnat/a-wtfiio__128.adb: New file.\n\t* libgnat/a-ztdeau.ads, libgnat/a-ztdeau.adb: Reimplement as\n\tgeneric unit.\n\t* libgnat/a-ztdeio.adb: Reimplement.\n\t* libgnat/a-ztdeio__128.adb: New file.\n\t* libgnat/a-ztfiau.ads, libgnat/a-ztfiau.adb: New generic unit.\n\t* libgnat/a-ztfiio.adb: Reimplement.\n\t* libgnat/a-ztfiio__128.adb: New file.\n\t* libgnat/g-rannum.adb (Random_Decimal_Fixed): Use a subtype of the\n\tappropiate size for the instantiation.\n\t(Random_Ordinary_Fixed): Likewise.\n\t* libgnat/s-arit32.ads, libgnat/s-arit32.adb: New support unit.\n\t* libgnat/s-fode128.ads: New instantiation.\n\t* libgnat/s-fode32.ads: Likewise.\n\t* libgnat/s-fode64.ads: Likewise.\n\t* libgnat/s-fofi128.ads: Likewise.\n\t* libgnat/s-fofi32.ads: Likewise.\n\t* libgnat/s-fofi64.ads: Likewise.\n\t* libgnat/s-fore_d.ads, libgnat/s-fore_d.adb: New generic unit.\n\t* libgnat/s-fore_f.ads, libgnat/s-fore_f.adb: Likewise.\n\t* libgnat/s-fore.ads, libgnat/s-fore.adb: Rename into...\n\t* libgnat/s-forrea.ads, libgnat/s-forrea.adb: ...this.\n\t* libgnat/s-imaged.ads, libgnat/s-imaged.adb: New generic unit.\n\t* libgnat/s-imagef.ads, libgnat/s-imagef.adb: Likewise, taken\n\tfrom a-tifiio.adb.\n\t* libgnat/s-imde128.ads: New instantiation.\n\t* libgnat/s-imde32.ads: Likewise.\n\t* libgnat/s-imde64.ads: Likewise.\n\t* libgnat/s-imfi128.ads: Likewise.\n\t* libgnat/s-imfi32.ads: Likewise.\n\t* libgnat/s-imfi64.ads: Likewise.\n\t* libgnat/s-imgdec.ads, libgnat/s-imgdec.adb: Delete.\n\t* libgnat/s-imglld.ads, libgnat/s-imglld.adb: Likewise.\n\t* libgnat/s-imgrea.adb (Set_Image_Real): Replace Sign local variable\n\twith Minus local variable for the sake of consistency.\n\t* libgnat/s-imguti.ads, libgnat/s-imguti.adb: New support unit.\n\t* libgnat/s-vade128.ads: New instantiation.\n\t* libgnat/s-vade32.ads: Likewise.\n\t* libgnat/s-vade64.ads: Likewise.\n\t* libgnat/s-vafi128.ads: Likewise.\n\t* libgnat/s-vafi32.ads: Likewise.\n\t* libgnat/s-vafi64.ads: Likewise.\n\t* libgnat/s-valdec.ads, libgnat/s-valdec.adb: Delete.\n\t* libgnat/s-vallld.ads, libgnat/s-vallld.adb: Likewise.\n\t* libgnat/s-valued.ads, libgnat/s-valued.adb: New generic unit.\n\t* libgnat/s-valuef.ads, libgnat/s-valuef.adb: Likewise.\n\t* libgnat/s-valuei.adb: Minor rewording.\n\t* libgnat/s-valrea.adb: Move bulk of implementation to...\n\t* libgnat/s-valuer.ads, libgnat/s-valuer.adb: ...here.  New\n\tgeneric unit.\n\t* libgnat/system-aix.ads (Max_Mantissa): Adjust.\n\t* libgnat/system-darwin-arm.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-darwin-ppc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-darwin-x86.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-djgpp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-dragonfly-x86_64.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-freebsd.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-hpux-ia64.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-hpux.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-alpha.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-arm.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-hppa.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-ia64.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-m68k.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-mips.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-ppc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-riscv.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-s390.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-sh4.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-sparc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-linux-x86.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-lynxos178-ppc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-lynxos178-x86.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-mingw.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-qnx-aarch64.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-rtems.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-solaris-sparc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-solaris-x86.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-arm-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-arm-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-arm.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-e500-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-e500-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-e500-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-e500-vthread.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc-ravenscar.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc-vthread.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-ppc.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-x86-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-x86-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-x86-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-x86-vthread.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks-x86.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-aarch64-rtp-smp.ads (Max_Mantissa):\n\tLikewise.\n\t* libgnat/system-vxworks7-aarch64.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-arm-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-arm.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-e500-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-e500-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-e500-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-ppc-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-ppc-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-ppc-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-ppc64-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-ppc64-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-x86-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-x86-rtp-smp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-x86-rtp.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-x86_64-kernel.ads (Max_Mantissa): Likewise.\n\t* libgnat/system-vxworks7-x86_64-rtp-smp.ads (Max_Mantissa): Likewise.\n\ngcc/testsuite/\n\n\t* gnat.dg/multfixed.adb: Robustify.", "tree": {"sha": "5ddfd280acc3b622ece98a581674aff7e1a04a91", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5ddfd280acc3b622ece98a581674aff7e1a04a91"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d87bb8f56db177718bf0f07df462b85a90c1ef3", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d87bb8f56db177718bf0f07df462b85a90c1ef3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d87bb8f56db177718bf0f07df462b85a90c1ef3", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d87bb8f56db177718bf0f07df462b85a90c1ef3/comments", "author": null, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0938e5145854954f5143e08d25fbad231c6cfa90", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0938e5145854954f5143e08d25fbad231c6cfa90", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0938e5145854954f5143e08d25fbad231c6cfa90"}], "stats": {"total": 9741, "additions": 7391, "deletions": 2350}, "files": [{"sha": "97792b43e517b737fab83ee3e202e82e3ea8cb32", "filename": "gcc/ada/Makefile.rtl", "status": "modified", "additions": 38, "deletions": 5, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2FMakefile.rtl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2FMakefile.rtl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FMakefile.rtl?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -344,6 +344,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-tideio$(objext) \\\n   a-tienau$(objext) \\\n   a-tienio$(objext) \\\n+  a-tifiau$(objext) \\\n   a-tifiio$(objext) \\\n   a-tiflau$(objext) \\\n   a-tiflio$(objext) \\\n@@ -371,6 +372,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-wtedit$(objext) \\\n   a-wtenau$(objext) \\\n   a-wtenio$(objext) \\\n+  a-wtfiau$(objext) \\\n   a-wtfiio$(objext) \\\n   a-wtflau$(objext) \\\n   a-wtflio$(objext) \\\n@@ -394,6 +396,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   a-ztenau$(objext) \\\n   a-ztenio$(objext) \\\n   a-ztexio$(objext) \\\n+  a-ztfiau$(objext) \\\n   a-ztfiio$(objext) \\\n   a-ztflau$(objext) \\\n   a-ztflio$(objext) \\\n@@ -520,6 +523,7 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-aomoar$(objext) \\\n   s-aotase$(objext) \\\n   s-aridou$(objext) \\\n+  s-arit32$(objext) \\\n   s-arit64$(objext) \\\n   s-assert$(objext) \\\n   s-atacco$(objext) \\\n@@ -599,30 +603,41 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-finmas$(objext) \\\n   s-finroo$(objext) \\\n   s-flocon$(objext) \\\n-  s-fore$(objext)   \\\n+  s-fode32$(objext) \\\n+  s-fode64$(objext) \\\n+  s-fofi32$(objext) \\\n+  s-fofi64$(objext) \\\n+  s-fore_d$(objext) \\\n+  s-fore_f$(objext) \\\n+  s-forrea$(objext) \\\n   s-gearop$(objext) \\\n   s-genbig$(objext) \\\n   s-geveop$(objext) \\\n   s-gloloc$(objext) \\\n   s-htable$(objext) \\\n   s-imageb$(objext) \\\n+  s-imaged$(objext) \\\n+  s-imagef$(objext) \\\n   s-imagei$(objext) \\\n   s-imageu$(objext) \\\n   s-imagew$(objext) \\\n+  s-imde32$(objext) \\\n+  s-imde64$(objext) \\\n   s-imenne$(objext) \\\n+  s-imfi32$(objext) \\\n+  s-imfi64$(objext) \\\n   s-imgbiu$(objext) \\\n   s-imgboo$(objext) \\\n   s-imgcha$(objext) \\\n-  s-imgdec$(objext) \\\n   s-imgenu$(objext) \\\n   s-imgint$(objext) \\\n   s-imgllb$(objext) \\\n-  s-imglld$(objext) \\\n   s-imglli$(objext) \\\n   s-imgllu$(objext) \\\n   s-imgllw$(objext) \\\n   s-imgrea$(objext) \\\n   s-imguns$(objext) \\\n+  s-imguti$(objext) \\\n   s-imgwch$(objext) \\\n   s-imgwiu$(objext) \\\n   s-io$(objext)     \\\n@@ -736,14 +751,19 @@ GNATRTL_NONTASKING_OBJS= \\\n   s-utf_32$(objext) \\\n   s-valboo$(objext) \\\n   s-valcha$(objext) \\\n-  s-valdec$(objext) \\\n+  s-vade32$(objext) \\\n+  s-vade64$(objext) \\\n+  s-vafi32$(objext) \\\n+  s-vafi64$(objext) \\\n   s-valenu$(objext) \\\n   s-valint$(objext) \\\n-  s-vallld$(objext) \\\n   s-vallli$(objext) \\\n   s-valllu$(objext) \\\n   s-valrea$(objext) \\\n+  s-valued$(objext) \\\n+  s-valuef$(objext) \\\n   s-valuei$(objext) \\\n+  s-valuer$(objext) \\\n   s-valueu$(objext) \\\n   s-valuns$(objext) \\\n   s-valuti$(objext) \\\n@@ -885,10 +905,17 @@ TRASYM_DWARF_UNIX_OBJS = $(TRASYM_DWARF_COMMON_OBJS) s-mmauni$(objext)\n TRASYM_DWARF_MINGW_OBJS = $(TRASYM_DWARF_COMMON_OBJS)\n \n GNATRTL_128BIT_PAIRS = \\\n+  a-decima.ads<libgnat/a-decima__128.ads \\\n+  a-tideio.adb<libgnat/a-tideio__128.adb \\\n+  a-tifiio.adb<libgnat/a-tifiio__128.adb \\\n   a-tiinio.adb<libgnat/a-tiinio__128.adb \\\n   a-timoio.adb<libgnat/a-timoio__128.adb \\\n+  a-wtdeio.adb<libgnat/a-wtdeio__128.adb \\\n+  a-wtfiio.adb<libgnat/a-wtfiio__128.adb \\\n   a-wtinio.adb<libgnat/a-wtinio__128.adb \\\n   a-wtmoio.adb<libgnat/a-wtmoio__128.adb \\\n+  a-ztdeio.adb<libgnat/a-ztdeio__128.adb \\\n+  a-ztfiio.adb<libgnat/a-ztfiio__128.adb \\\n   a-ztinio.adb<libgnat/a-ztinio__128.adb \\\n   a-ztmoio.adb<libgnat/a-ztmoio__128.adb \\\n   i-cexten.ads<libgnat/i-cexten__128.ads \\\n@@ -903,6 +930,10 @@ GNATRTL_128BIT_OBJS = \\\n   s-exnllli$(objext) \\\n   s-expllli$(objext) \\\n   s-explllu$(objext) \\\n+  s-fode128$(objext) \\\n+  s-fofi128$(objext) \\\n+  s-imde128$(objext) \\\n+  s-imfi128$(objext) \\\n   s-imglllb$(objext) \\\n   s-imgllli$(objext) \\\n   s-imglllu$(objext) \\\n@@ -970,6 +1001,8 @@ GNATRTL_128BIT_OBJS = \\\n   s-pack125$(objext) \\\n   s-pack126$(objext) \\\n   s-pack127$(objext) \\\n+  s-vade128$(objext) \\\n+  s-vafi128$(objext) \\\n   s-valllli$(objext) \\\n   s-vallllu$(objext) \\\n   s-widllli$(objext) \\"}, {"sha": "36634c796809b591fac9d53edf614bf9a9877dbc", "filename": "gcc/ada/cstand.adb", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fcstand.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fcstand.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fcstand.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -1326,6 +1326,12 @@ package body CStand is\n       Set_Scope (Standard_Integer_64, Standard_Standard);\n       Build_Signed_Integer_Type (Standard_Integer_64, 64);\n \n+      Standard_Integer_128 := New_Standard_Entity (\"integer_128\");\n+      Decl := New_Node (N_Full_Type_Declaration, Stloc);\n+      Set_Defining_Identifier (Decl, Standard_Integer_128);\n+      Set_Scope (Standard_Integer_128, Standard_Standard);\n+      Build_Signed_Integer_Type (Standard_Integer_128, 128);\n+\n       --  Standard_*_Unsigned subtypes are not user visible, but they are\n       --  used internally. They are unsigned types with the same length as\n       --  the correspondingly named signed integer types."}, {"sha": "7dc28c2689123dfbed90e2135bbeedec1f88819b", "filename": "gcc/ada/doc/gnat_rm/implementation_defined_characteristics.rst", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fdoc%2Fgnat_rm%2Fimplementation_defined_characteristics.rst?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -153,16 +153,26 @@ The small is the largest power of two that does not exceed the delta.\n   \"What combinations of small, range, and digits are\n   supported for fixed point types.  See 3.5.9(10).\"\n \n-For an ordinary fixed point type, the small must lie in 2.0**(-80) .. 2.0**80\n-and the range in -10.0**36 .. 10.0**36; any combination is permitted that\n-does not result in a mantissa larger than 63 bits. However, if the mantissa\n-is larger than 53 bits on machines where Long_Long_Float is 64 bits (true\n-of all architectures except x86), then the output from Text_IO may be\n-accurate to only 53 bits, rather than the full mantissa.  This is because\n-floating-point conversions may be used to convert fixed point.\n-\n-For a decimal fixed point type, the small must lie in 10.0**(-18) .. 10.0**18\n-and the digits in 1 .. 18.\n+For an ordinary fixed point type, on 32-bit platforms, the small must lie in\n+2.0**(-80) .. 2.0**80 and the range in -9.0E+36 .. 9.0E+36; any combination\n+is permitted that does not result in a mantissa larger than 63 bits.\n+\n+On 64-bit platforms, the small must lie in 2.0**(-127) .. 2.0**127 and the\n+range in -1.0E+76 .. 1.0E+76; any combination is permitted that does not\n+result in a mantissa larger than 63 bits, and any combination is permitted\n+that results in a mantissa between 64 and 127 bits if the small is either\n+an integer or the reciprocal of an integer.\n+\n+If the small is either an integer or the reciprocal of an integer, which\n+is the case if no ``small`` clause is provided, then the operations of the\n+fixed point type are entirely implemented by means of integer instructions.\n+In the other cases, some operations, in particular input and output, may be\n+implemented by means of floating-point instructions and may be affected by\n+accuracy issues on architectures other than x86.\n+\n+For a decimal fixed point type, on 32-bit platforms, the small must lie in\n+1.0E-18 .. 1.0E+18 and the digits in 1 .. 18.  On 64-bit platforms, the\n+small must lie in 1.0E-38 .. 1.0E+38 and the digits in 1 .. 38.\n \n *\n   \"The result of ``Tags.Expanded_Name`` for types declared"}, {"sha": "ad47f48651f3c695463f95457ea0c755e91e468b", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 112, "deletions": 18, "changes": 130, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -67,6 +67,7 @@ with Tbuild;   use Tbuild;\n with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Uname;    use Uname;\n+with Urealp;   use Urealp;\n with Validsw;  use Validsw;\n \n package body Exp_Attr is\n@@ -3615,31 +3616,124 @@ package body Exp_Attr is\n \n       --  expands into\n \n-      --    Result_Type (System.Fore (Universal_Real (Type'First)),\n-      --                              Universal_Real (Type'Last))\n+      --    System.Fore_xx (ftyp (Typ'First), ftyp (Typ'Last) [,pm])\n+\n+      --    For decimal fixed-point types\n+      --      xx   = Decimal{32,64,128}\n+      --      ftyp = Integer_{32,64,128}\n+      --      pm   = Typ'Scale\n+\n+      --    For the most common ordinary fixed-point types\n+      --      xx   = Fixed{32,64,128}\n+      --      ftyp = Integer_{32,64,128}\n+      --      pm   = Typ'Small\n+      --             1.0 / Typ'Small\n+\n+      --    For other ordinary fixed-point types\n+      --      xx   = Real\n+      --      ftyp = Universal_Real\n+      --      pm   = none\n \n       --  Note that we know that the type is a nonstatic subtype, or Fore would\n-      --  have itself been computed dynamically in Eval_Attribute.\n+      --  have been computed statically in Eval_Attribute.\n \n       when Attribute_Fore =>\n-         Rewrite (N,\n-           Convert_To (Typ,\n-             Make_Function_Call (Loc,\n-               Name                   =>\n-                 New_Occurrence_Of (RTE (RE_Fore), Loc),\n+         declare\n+            Arg_List : List_Id;\n+            Fid      : RE_Id;\n+            Ftyp     : Entity_Id;\n \n-               Parameter_Associations => New_List (\n-                 Convert_To (Universal_Real,\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-                     Attribute_Name => Name_First)),\n+         begin\n+            if Is_Decimal_Fixed_Point_Type (Ptyp) then\n+               if Esize (Ptyp) <= 32 then\n+                  Fid  := RE_Fore_Decimal32;\n+                  Ftyp := RTE (RE_Integer_32);\n+               elsif Esize (Ptyp) <= 64 then\n+                  Fid  := RE_Fore_Decimal64;\n+                  Ftyp := RTE (RE_Integer_64);\n+               else\n+                  Fid  := RE_Fore_Decimal128;\n+                  Ftyp := RTE (RE_Integer_128);\n+               end if;\n \n-                 Convert_To (Universal_Real,\n-                   Make_Attribute_Reference (Loc,\n-                     Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-                     Attribute_Name => Name_Last))))));\n+            else\n+               declare\n+                  Num : constant Uint := Norm_Num (Small_Value (Ptyp));\n+                  Den : constant Uint := Norm_Den (Small_Value (Ptyp));\n+                  Max : constant Uint := UI_Max (Num, Den);\n+                  Min : constant Uint := UI_Min (Num, Den);\n+                  Siz : constant Uint := Esize (Ptyp);\n \n-         Analyze_And_Resolve (N, Typ);\n+               begin\n+                  if Siz <= 32\n+                    and then Min = Uint_1\n+                    and then Max <= Uint_2 ** 31\n+                  then\n+                     Fid  := RE_Fore_Fixed32;\n+                     Ftyp := RTE (RE_Integer_32);\n+                  elsif Siz <= 64\n+                    and then Min = Uint_1\n+                    and then Max <= Uint_2 ** 63\n+                  then\n+                     Fid  := RE_Fore_Fixed64;\n+                     Ftyp := RTE (RE_Integer_64);\n+                  elsif System_Max_Integer_Size = 128\n+                    and then Min = Uint_1\n+                    and then Max <= Uint_2 ** 127\n+                  then\n+                     Fid  := RE_Fore_Fixed128;\n+                     Ftyp := RTE (RE_Integer_128);\n+                  else\n+                     Fid  := RE_Fore_Real;\n+                     Ftyp := Universal_Real;\n+                  end if;\n+               end;\n+            end if;\n+\n+            Arg_List := New_List (\n+              Convert_To (Ftyp,\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+                  Attribute_Name => Name_First)));\n+\n+            Append_To (Arg_List,\n+              Convert_To (Ftyp,\n+                Make_Attribute_Reference (Loc,\n+                  Prefix         => New_Occurrence_Of (Ptyp, Loc),\n+                  Attribute_Name => Name_Last)));\n+\n+            --  For decimal, append Scale and also set to do literal conversion\n+\n+            if Is_Decimal_Fixed_Point_Type (Ptyp) then\n+               Set_Conversion_OK (First (Arg_List));\n+               Set_Conversion_OK (Next (First (Arg_List)));\n+\n+               Append_To (Arg_List,\n+                 Make_Integer_Literal (Loc, Scale_Value (Ptyp)));\n+\n+            --  For ordinary fixed-point types, append Num, Den parameters\n+            --  and also set to do literal conversion\n+\n+            elsif Fid /= RE_Fore_Real then\n+               Set_Conversion_OK (First (Arg_List));\n+               Set_Conversion_OK (Next (First (Arg_List)));\n+\n+               Append_To (Arg_List,\n+                 Make_Integer_Literal (Loc, -Norm_Num (Small_Value (Ptyp))));\n+\n+               Append_To (Arg_List,\n+                 Make_Integer_Literal (Loc, -Norm_Den (Small_Value (Ptyp))));\n+            end if;\n+\n+            Rewrite (N,\n+              Convert_To (Typ,\n+                Make_Function_Call (Loc,\n+                  Name                   =>\n+                    New_Occurrence_Of (RTE (Fid), Loc),\n+                  Parameter_Associations => Arg_List)));\n+\n+            Analyze_And_Resolve (N, Typ);\n+         end;\n \n       --------------\n       -- Fraction --"}, {"sha": "74b8f27eaea45dad546c84d37354a96665517320", "filename": "gcc/ada/exp_ch4.adb", "status": "modified", "additions": 8, "deletions": 21, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_ch4.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_ch4.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch4.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -11879,33 +11879,20 @@ package body Exp_Ch4 is\n          --  which used to fail when Fix_Val was a bound of the type and\n          --  the 'Small was not a representable number.\n          --  This transformation requires an integer type large enough to\n-         --  accommodate a fixed-point value. This will not be the case\n-         --  in systems where Duration is larger than Long_Integer.\n+         --  accommodate a fixed-point value.\n \n          if Is_Ordinary_Fixed_Point_Type (Target_Type)\n            and then Is_Floating_Point_Type (Etype (Expr))\n-           and then RM_Size (Btyp) <= RM_Size (Standard_Long_Integer)\n+           and then RM_Size (Btyp) <= System_Max_Integer_Size\n            and then Nkind (Lo) = N_Real_Literal\n            and then Nkind (Hi) = N_Real_Literal\n          then\n             declare\n                Expr_Id : constant Entity_Id := Make_Temporary (Loc, 'T', Conv);\n-               Int_Type : Entity_Id;\n+               Int_Typ : constant Entity_Id :=\n+                           Small_Integer_Type_For (RM_Size (Btyp), False);\n \n             begin\n-               --  Find an integer type of the appropriate size to perform an\n-               --  unchecked conversion to the target fixed-point type.\n-\n-               if RM_Size (Btyp) > RM_Size (Standard_Integer) then\n-                  Int_Type := Standard_Long_Integer;\n-\n-               elsif RM_Size (Btyp) > RM_Size (Standard_Short_Integer) then\n-                  Int_Type := Standard_Integer;\n-\n-               else\n-                  Int_Type := Standard_Short_Integer;\n-               end if;\n-\n                --  Generate a temporary with the integer value. Required in the\n                --  CCG compiler to ensure that run-time checks reference this\n                --  integer expression (instead of the resulting fixed-point\n@@ -11915,23 +11902,23 @@ package body Exp_Ch4 is\n                Insert_Action (N,\n                  Make_Object_Declaration (Loc,\n                    Defining_Identifier => Expr_Id,\n-                   Object_Definition   => New_Occurrence_Of (Int_Type, Loc),\n+                   Object_Definition   => New_Occurrence_Of (Int_Typ, Loc),\n                    Constant_Present    => True,\n                    Expression          =>\n-                     Convert_To (Int_Type, Expression (Conv))));\n+                     Convert_To (Int_Typ, Expression (Conv))));\n \n                --  Create integer objects for range checking of result.\n \n                Lo_Arg :=\n                  Unchecked_Convert_To\n-                   (Int_Type, New_Occurrence_Of (Expr_Id, Loc));\n+                   (Int_Typ, New_Occurrence_Of (Expr_Id, Loc));\n \n                Lo_Val :=\n                  Make_Integer_Literal (Loc, Corresponding_Integer_Value (Lo));\n \n                Hi_Arg :=\n                  Unchecked_Convert_To\n-                   (Int_Type, New_Occurrence_Of (Expr_Id, Loc));\n+                   (Int_Typ, New_Occurrence_Of (Expr_Id, Loc));\n \n                Hi_Val :=\n                  Make_Integer_Literal (Loc, Corresponding_Integer_Value (Hi));"}, {"sha": "d6819699c0caeb7d208b5988d28a19232063d871", "filename": "gcc/ada/exp_fixd.adb", "status": "modified", "additions": 109, "deletions": 73, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_fixd.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_fixd.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_fixd.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -40,6 +40,7 @@ with Sinfo;    use Sinfo;\n with Snames;   use Snames;\n with Stand;    use Stand;\n with Tbuild;   use Tbuild;\n+with Ttypes;   use Ttypes;\n with Uintp;    use Uintp;\n with Urealp;   use Urealp;\n \n@@ -116,9 +117,8 @@ package body Exp_Fixd is\n    --  case the types need not be the same, and Build_Multiply chooses a type\n    --  long enough to hold the product (i.e. twice the size of the longer of\n    --  the two operand types), and both operands are converted to this type.\n-   --  The Etype of the result is also set to this value. However, the result\n-   --  can never overflow Integer_64, so this is the largest type that is ever\n-   --  generated. On return, the resulting node is analyzed and has Etype set.\n+   --  The Etype of the result is also set to this value. On return, the\n+   --  resulting node is analyzed and has Etype set.\n \n    function Build_Rem (N : Node_Id; L, R : Node_Id) return Node_Id;\n    --  Builds an N_Op_Rem node from the given left and right operand\n@@ -194,12 +194,13 @@ package body Exp_Fixd is\n       V        : Uint;\n       Negative : Boolean := False) return Node_Id;\n    --  Given a non-negative universal integer value, build a typed integer\n-   --  literal node, using the smallest applicable standard integer type. If\n-   --  and only if Negative is true a negative literal is built. If V exceeds\n-   --  2**63-1, the largest value allowed for perfect result set scaling\n-   --  factors (see RM G.2.3(22)), then Empty is returned. The node N provides\n-   --  the Sloc value for the constructed literal. The Etype of the resulting\n-   --  literal is correctly set, and it is marked as analyzed.\n+   --  literal node, using the smallest applicable standard integer type.\n+   --  If Negative is true, then a negative literal is built. If V exceeds\n+   --  2**(System_Max_Integer_Size - 1) - 1, the largest value allowed for\n+   --  perfect result set scaling factors (see RM G.2.3(22)), then Empty is\n+   --  returned. The node N provides the Sloc value for the constructed\n+   --  literal. The Etype of the resulting literal is correctly set, and it\n+   --  is marked as analyzed.\n \n    function Real_Literal (N : Node_Id; V : Ureal) return Node_Id;\n    --  Build a real literal node from the given value, the Etype of the\n@@ -347,22 +348,25 @@ package body Exp_Fixd is\n             return L;\n          end if;\n \n+         --  Otherwise we need to figure out the correct result type size\n          --  First figure out the effective sizes of the operands. Normally\n          --  the effective size of an operand is the RM_Size of the operand.\n          --  But a special case arises with operands whose size is known at\n          --  compile time. In this case, we can use the actual value of the\n-         --  operand to get its size if it would fit signed in 8 or 16 bits.\n+         --  operand to get its size if it would fit in signed 8/16/32 bits.\n \n          Left_Size := UI_To_Int (RM_Size (Left_Type));\n \n          if Compile_Time_Known_Value (L) then\n             declare\n                Val : constant Uint := Expr_Value (L);\n             begin\n-               if Val < Int'(2 ** 7) then\n+               if Val < Uint_2 ** 7 then\n                   Left_Size := 8;\n-               elsif Val < Int'(2 ** 15) then\n+               elsif Val < Uint_2 ** 15 then\n                   Left_Size := 16;\n+               elsif Val < Uint_2 ** 31 then\n+                  Left_Size := 32;\n                end if;\n             end;\n          end if;\n@@ -394,8 +398,11 @@ package body Exp_Fixd is\n          elsif Rsize <= 32 then\n             Result_Type := Standard_Integer_32;\n \n-         else\n+         elsif Rsize <= 64 or else System_Max_Integer_Size < 128 then\n             Result_Type := Standard_Integer_64;\n+\n+         else\n+            Result_Type := Standard_Integer_128;\n          end if;\n \n          Rnode :=\n@@ -446,18 +453,17 @@ package body Exp_Fixd is\n       Expr   : Node_Id;\n \n    begin\n-      --  If denominator fits in 64 bits, we can build the operations directly\n-      --  without causing any intermediate overflow, so that's what we do.\n+      --  If the denominator fits in Max_Integer_Size bits, we can build the\n+      --  operations directly without causing any intermediate overflow.\n \n-      if Nat'Max (Y_Size, Z_Size) <= 32 then\n-         return\n-           Build_Divide (N, X, Build_Multiply (N, Y, Z));\n+      if 2 * Nat'Max (Y_Size, Z_Size) <= System_Max_Integer_Size then\n+         return Build_Divide (N, X, Build_Multiply (N, Y, Z));\n \n       --  Otherwise we use the runtime routine\n \n-      --    [Qnn : Interfaces.Integer_64,\n-      --     Rnn : Interfaces.Integer_64;\n-      --     Double_Divide (X, Y, Z, Qnn, Rnn, Round);\n+      --    [Qnn : Interfaces.Integer_{64|128};\n+      --     Rnn : Interfaces.Integer_{64|128};\n+      --     Double_Divide{64|128} (X, Y, Z, Qnn, Rnn, Round);\n       --     Qnn]\n \n       else\n@@ -489,18 +495,18 @@ package body Exp_Fixd is\n    -- Build_Double_Divide_Code --\n    ------------------------------\n \n-   --  If the denominator can be computed in 64-bits, we build\n+   --  If the denominator can be computed in Max_Integer_Size bits, we build\n \n    --    [Nnn : constant typ := typ (X);\n    --     Dnn : constant typ := typ (Y) * typ (Z)\n    --     Qnn : constant typ := Nnn / Dnn;\n-   --     Rnn : constant typ := Nnn / Dnn;\n+   --     Rnn : constant typ := Nnn rem Dnn;\n \n-   --  If the numerator cannot be computed in 64 bits, we build\n+   --  If the denominator cannot be computed in Max_Integer_Size bits, we build\n \n-   --    [Qnn : typ;\n-   --     Rnn : typ;\n-   --     Double_Divide (X, Y, Z, Qnn, Rnn, Round);]\n+   --    [Qnn : Interfaces.Integer_{64|128};\n+   --     Rnn : Interfaces.Integer_{64|128};\n+   --     Double_Divide{64|128} (X, Y, Z, Qnn, Rnn, Round);]\n \n    procedure Build_Double_Divide_Code\n      (N        : Node_Id;\n@@ -514,6 +520,7 @@ package body Exp_Fixd is\n       Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n       Z_Size : constant Nat := UI_To_Int (Esize (Etype (Z)));\n \n+      QR_Id  : RE_Id;\n       QR_Siz : Nat;\n       QR_Typ : Entity_Id;\n \n@@ -524,22 +531,36 @@ package body Exp_Fixd is\n       Rnd : Entity_Id;\n \n    begin\n-      --  Find type that will allow computation of numerator\n+      --  Find type that will allow computation of denominator\n \n       QR_Siz := Nat'Max (X_Size, 2 * Nat'Max (Y_Size, Z_Size));\n \n       if QR_Siz <= 16 then\n          QR_Typ := Standard_Integer_16;\n+         QR_Id  := RE_Null;\n+\n       elsif QR_Siz <= 32 then\n          QR_Typ := Standard_Integer_32;\n+         QR_Id  := RE_Null;\n+\n       elsif QR_Siz <= 64 then\n          QR_Typ := Standard_Integer_64;\n+         QR_Id  := RE_Null;\n+\n+      elsif QR_Siz <= 128 and then System_Max_Integer_Size = 128 then\n+         QR_Typ := Standard_Integer_128;\n+         QR_Id  := RE_Null;\n \n-      --  For more than 64, bits, we use the 64-bit integer defined in\n+      --  For more than Max_Integer_Size bits, we use the integer defined in\n       --  Interfaces, so that it can be handled by the runtime routine.\n \n-      else\n+      elsif System_Max_Integer_Size < 128 then\n          QR_Typ := RTE (RE_Integer_64);\n+         QR_Id  := RE_Double_Divide64;\n+\n+      else\n+         QR_Typ := RTE (RE_Integer_128);\n+         QR_Id  := RE_Double_Divide128;\n       end if;\n \n       --  Define quotient and remainder, and set their Etypes, so\n@@ -551,9 +572,9 @@ package body Exp_Fixd is\n       Set_Etype (Qnn, QR_Typ);\n       Set_Etype (Rnn, QR_Typ);\n \n-      --  Case that we can compute the denominator in 64 bits\n+      --  Case that we can compute the denominator in Max_Integer_Size bits\n \n-      if QR_Siz <= 64 then\n+      if QR_Siz <= System_Max_Integer_Size then\n \n          --  Create temporaries for numerator and denominator and set Etypes,\n          --  so that New_Occurrence_Of picks them up for Build_xxx calls.\n@@ -569,16 +590,13 @@ package body Exp_Fixd is\n              Defining_Identifier => Nnn,\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc),\n              Constant_Present    => True,\n-             Expression => Build_Conversion (N, QR_Typ, X)),\n+             Expression          => Build_Conversion (N, QR_Typ, X)),\n \n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Dnn,\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc),\n              Constant_Present    => True,\n-             Expression =>\n-               Build_Multiply (N,\n-                 Build_Conversion (N, QR_Typ, Y),\n-                 Build_Conversion (N, QR_Typ, Z))));\n+             Expression          => Build_Multiply (N, Y, Z)));\n \n          Quo :=\n            Build_Divide (N,\n@@ -604,8 +622,8 @@ package body Exp_Fixd is\n                  New_Occurrence_Of (Nnn, Loc),\n                  New_Occurrence_Of (Dnn, Loc))));\n \n-      --  Case where denominator does not fit in 64 bits, so we have to\n-      --  call the runtime routine to compute the quotient and remainder\n+      --  Case where denominator does not fit in Max_Integer_Size bits, we have\n+      --  to call the runtime routine to compute the quotient and remainder.\n \n       else\n          Rnd := Boolean_Literals (Rounded_Result_Set (N));\n@@ -620,7 +638,7 @@ package body Exp_Fixd is\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc)),\n \n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Double_Divide64), Loc),\n+             Name => New_Occurrence_Of (RTE (QR_Id), Loc),\n              Parameter_Associations => New_List (\n                Build_Conversion (N, QR_Typ, X),\n                Build_Conversion (N, QR_Typ, Y),\n@@ -674,18 +692,20 @@ package body Exp_Fixd is\n          --  the effective size of an operand is the RM_Size of the operand.\n          --  But a special case arises with operands whose size is known at\n          --  compile time. In this case, we can use the actual value of the\n-         --  operand to get its size if it would fit signed in 8 or 16 bits.\n+         --  operand to get its size if it would fit in signed 8/16/32 bits.\n \n          Left_Size := UI_To_Int (RM_Size (Left_Type));\n \n          if Compile_Time_Known_Value (L) then\n             declare\n                Val : constant Uint := Expr_Value (L);\n             begin\n-               if Val < Int'(2 ** 7) then\n+               if Val < Uint_2 ** 7 then\n                   Left_Size := 8;\n-               elsif Val < Int'(2 ** 15) then\n+               elsif Val < Uint_2 ** 15 then\n                   Left_Size := 16;\n+               elsif Val < Uint_2 ** 31 then\n+                  Left_Size := 32;\n                end if;\n             end;\n          end if;\n@@ -718,8 +738,11 @@ package body Exp_Fixd is\n          elsif Rsize <= 32 then\n             Result_Type := Standard_Integer_32;\n \n-         else\n+         elsif Rsize <= 64 or else System_Max_Integer_Size < 128 then\n             Result_Type := Standard_Integer_64;\n+\n+         else\n+            Result_Type := Standard_Integer_128;\n          end if;\n \n          Rnode :=\n@@ -810,18 +833,17 @@ package body Exp_Fixd is\n       Expr   : Node_Id;\n \n    begin\n-      --  If numerator fits in 64 bits, we can build the operations directly\n-      --  without causing any intermediate overflow, so that's what we do.\n+      --  If the numerator fits in Max_Integer_Size bits, we can build the\n+      --  operations directly without causing any intermediate overflow.\n \n-      if Nat'Max (X_Size, Y_Size) <= 32 then\n-         return\n-           Build_Divide (N, Build_Multiply (N, X, Y), Z);\n+      if 2 * Nat'Max (X_Size, Y_Size) <= System_Max_Integer_Size then\n+         return Build_Divide (N, Build_Multiply (N, X, Y), Z);\n \n       --  Otherwise we use the runtime routine\n \n-      --    [Qnn : Integer_64,\n-      --     Rnn : Integer_64;\n-      --     Scaled_Divide (X, Y, Z, Qnn, Rnn, Round);\n+      --    [Qnn : Integer_{64|128},\n+      --     Rnn : Integer_{64|128};\n+      --     Scaled_Divide{64|128} (X, Y, Z, Qnn, Rnn, Round);\n       --     Qnn]\n \n       else\n@@ -850,18 +872,18 @@ package body Exp_Fixd is\n    -- Build_Scaled_Divide_Code --\n    ------------------------------\n \n-   --  If the numerator can be computed in 64-bits, we build\n+   --  If the numerator can be computed in Max_Integer_Size bits, we build\n \n    --    [Nnn : constant typ := typ (X) * typ (Y);\n    --     Dnn : constant typ := typ (Z)\n    --     Qnn : constant typ := Nnn / Dnn;\n-   --     Rnn : constant typ := Nnn / Dnn;\n+   --     Rnn : constant typ := Nnn rem Dnn;\n \n-   --  If the numerator cannot be computed in 64 bits, we build\n+   --  If the numerator cannot be computed in Max_Integer_Size bits, we build\n \n-   --    [Qnn : Interfaces.Integer_64;\n-   --     Rnn : Interfaces.Integer_64;\n-   --     Scaled_Divide (X, Y, Z, Qnn, Rnn, Round);]\n+   --    [Qnn : Interfaces.Integer_{64|128};\n+   --     Rnn : Interfaces.Integer_{64|128};\n+   --     Scaled_Divide_{64|128} (X, Y, Z, Qnn, Rnn, Round);]\n \n    procedure Build_Scaled_Divide_Code\n      (N        : Node_Id;\n@@ -875,6 +897,7 @@ package body Exp_Fixd is\n       Y_Size : constant Nat := UI_To_Int (Esize (Etype (Y)));\n       Z_Size : constant Nat := UI_To_Int (Esize (Etype (Z)));\n \n+      QR_Id  : RE_Id;\n       QR_Siz : Nat;\n       QR_Typ : Entity_Id;\n \n@@ -887,20 +910,34 @@ package body Exp_Fixd is\n    begin\n       --  Find type that will allow computation of numerator\n \n-      QR_Siz := Nat'Max (X_Size, 2 * Nat'Max (Y_Size, Z_Size));\n+      QR_Siz := Nat'Max (2 * Nat'Max (X_Size, Y_Size), Z_Size);\n \n       if QR_Siz <= 16 then\n          QR_Typ := Standard_Integer_16;\n+         QR_Id  := RE_Null;\n+\n       elsif QR_Siz <= 32 then\n          QR_Typ := Standard_Integer_32;\n+         QR_Id  := RE_Null;\n+\n       elsif QR_Siz <= 64 then\n          QR_Typ := Standard_Integer_64;\n+         QR_Id  := RE_Null;\n \n-      --  For more than 64, bits, we use the 64-bit integer defined in\n+      elsif QR_Siz <= 128 and then System_Max_Integer_Size = 128 then\n+         QR_Typ := Standard_Integer_128;\n+         QR_Id  := RE_Null;\n+\n+      --  For more than Max_Integer_Size bits, we use the integer defined in\n       --  Interfaces, so that it can be handled by the runtime routine.\n \n-      else\n+      elsif System_Max_Integer_Size < 128 then\n          QR_Typ := RTE (RE_Integer_64);\n+         QR_Id  := RE_Scaled_Divide64;\n+\n+      else\n+         QR_Typ := RTE (RE_Integer_128);\n+         QR_Id  := RE_Scaled_Divide128;\n       end if;\n \n       --  Define quotient and remainder, and set their Etypes, so\n@@ -912,9 +949,9 @@ package body Exp_Fixd is\n       Set_Etype (Qnn, QR_Typ);\n       Set_Etype (Rnn, QR_Typ);\n \n-      --  Case that we can compute the numerator in 64 bits\n+      --  Case that we can compute the numerator in Max_Integer_Size bits\n \n-      if QR_Siz <= 64 then\n+      if QR_Siz <= System_Max_Integer_Size then\n          Nnn := Make_Temporary (Loc, 'N');\n          Dnn := Make_Temporary (Loc, 'D');\n \n@@ -928,16 +965,13 @@ package body Exp_Fixd is\n              Defining_Identifier => Nnn,\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc),\n              Constant_Present    => True,\n-             Expression =>\n-               Build_Multiply (N,\n-                 Build_Conversion (N, QR_Typ, X),\n-                 Build_Conversion (N, QR_Typ, Y))),\n+             Expression          => Build_Multiply (N, X, Y)),\n \n            Make_Object_Declaration (Loc,\n              Defining_Identifier => Dnn,\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc),\n              Constant_Present    => True,\n-             Expression => Build_Conversion (N, QR_Typ, Z)));\n+             Expression          => Build_Conversion (N, QR_Typ, Z)));\n \n          Quo :=\n            Build_Divide (N,\n@@ -961,8 +995,8 @@ package body Exp_Fixd is\n                  New_Occurrence_Of (Nnn, Loc),\n                  New_Occurrence_Of (Dnn, Loc))));\n \n-      --  Case where numerator does not fit in 64 bits, so we have to\n-      --  call the runtime routine to compute the quotient and remainder\n+      --  Case where numerator does not fit in Max_Integer_Size bits, we have\n+      --  to call the runtime routine to compute the quotient and remainder.\n \n       else\n          Rnd := Boolean_Literals (Rounded_Result_Set (N));\n@@ -977,7 +1011,7 @@ package body Exp_Fixd is\n              Object_Definition   => New_Occurrence_Of (QR_Typ, Loc)),\n \n            Make_Procedure_Call_Statement (Loc,\n-             Name => New_Occurrence_Of (RTE (RE_Scaled_Divide64), Loc),\n+             Name => New_Occurrence_Of (RTE (QR_Id), Loc),\n              Parameter_Associations => New_List (\n                Build_Conversion (N, QR_Typ, X),\n                Build_Conversion (N, QR_Typ, Y),\n@@ -1374,8 +1408,7 @@ package body Exp_Fixd is\n \n          if Present (Lit_Int) then\n             Set_Result (N,\n-              Build_Multiply (N, Build_Multiply (N, Left, Right),\n-                Lit_Int));\n+              Build_Multiply (N, Build_Multiply (N, Left, Right), Lit_Int));\n             return;\n          end if;\n \n@@ -2380,6 +2413,9 @@ package body Exp_Fixd is\n       elsif V < Uint_2 ** 63 then\n          T := Standard_Integer_64;\n \n+      elsif V < Uint_2 ** 127 and then System_Max_Integer_Size = 128 then\n+         T := Standard_Integer_128;\n+\n       else\n          return Empty;\n       end if;"}, {"sha": "d5db5b3f017abb8380ae3ed108bd7df79216e05e", "filename": "gcc/ada/exp_imgv.adb", "status": "modified", "additions": 203, "deletions": 101, "changes": 304, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_imgv.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fexp_imgv.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_imgv.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -49,11 +49,6 @@ with Urealp;   use Urealp;\n \n package body Exp_Imgv is\n \n-   function Has_Decimal_Small (E : Entity_Id) return Boolean;\n-   --  Applies to all entities. True for a Decimal_Fixed_Point_Type, or an\n-   --  Ordinary_Fixed_Point_Type with a small that is a negative power of ten.\n-   --  Shouldn't this be in einfo.adb or sem_aux.adb???\n-\n    procedure Rewrite_Object_Image\n      (N         : Node_Id;\n       Pref      : Entity_Id;\n@@ -219,21 +214,13 @@ package body Exp_Imgv is\n    --      xx = Boolean\n    --      tv = Boolean (Expr)\n \n-   --    For signed integer types with size <= Integer'Size\n-   --      xx = Integer\n-   --      tv = Integer (Expr)\n-\n-   --    For other signed integer types\n-   --      xx = Long_Long_Integer\n-   --      tv = Long_Long_Integer (Expr)\n-\n-   --    For modular types with modulus <= System.Unsigned_Types.Unsigned\n-   --      xx = Unsigned\n-   --      tv = System.Unsigned_Types.Unsigned (Expr)\n+   --    For signed integer types\n+   --      xx = [Long_Long_[Long_]]Integer\n+   --      tv = [Long_Long_[Long_]]Integer (Expr)\n \n-   --    For other modular integer types\n-   --      xx = Long_Long_Unsigned\n-   --      tv = System.Unsigned_Types.Long_Long_Unsigned (Expr)\n+   --    For modular types\n+   --      xx = [Long_Long_[Long_]]Unsigned\n+   --      tv = System.Unsigned_Types.[Long_Long_[Long_]]Unsigned (Expr)\n \n    --    For types whose root type is Wide_Character\n    --      xx = Wide_Character\n@@ -249,21 +236,24 @@ package body Exp_Imgv is\n    --      tv = Long_Long_Float (Expr)\n    --      pm = typ'Digits (typ = subtype of expression)\n \n-   --    For ordinary fixed-point types\n+   --    For decimal fixed-point types\n+   --      xx = Decimal{32,64,128}\n+   --      tv = Integer_{32,64,128} (Expr)? [convert with no scaling]\n+   --      pm = typ'Scale (typ = subtype of expression)\n+\n+   --    For the most common ordinary fixed-point types\n+   --      xx = Fixed{32,64,128}\n+   --      tv = Integer_{32,64,128} (Expr) [convert with no scaling]\n+   --      pm = typ'Small (typ = subtype of expression)\n+   --           1.0 / typ'Small\n+   --           (Integer_{32,64,128} x typ'Small)'Fore\n+   --           typ'Aft\n+\n+   --    For other ordinary fixed-point types\n    --      xx = Ordinary_Fixed_Point\n    --      tv = Long_Long_Float (Expr)\n    --      pm = typ'Aft (typ = subtype of expression)\n \n-   --    For decimal fixed-point types with size = Integer'Size\n-   --      xx = Decimal\n-   --      tv = Integer (Expr)\n-   --      pm = typ'Scale (typ = subtype of expression)\n-\n-   --    For decimal fixed-point types with size > Integer'Size\n-   --      xx = Long_Long_Decimal\n-   --      tv = Long_Long_Integer?(Expr) [convert with no scaling]\n-   --      pm = typ'Scale (typ = subtype of expression)\n-\n    --  For enumeration types other than those declared in package Standard\n    --  or System, Snn, Pnn, are expanded as above, but the call looks like:\n \n@@ -593,18 +583,50 @@ package body Exp_Imgv is\n             Tent := RTE (RE_Long_Long_Long_Unsigned);\n          end if;\n \n-      elsif Is_Fixed_Point_Type (Rtyp) and then Has_Decimal_Small (Rtyp) then\n-         if UI_To_Int (Esize (Rtyp)) <= Standard_Integer_Size then\n-            Imid := RE_Image_Decimal;\n-            Tent := Standard_Integer;\n+      elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n+         if Esize (Rtyp) <= 32 then\n+            Imid := RE_Image_Decimal32;\n+            Tent := RTE (RE_Integer_32);\n+         elsif Esize (Rtyp) <= 64 then\n+            Imid := RE_Image_Decimal64;\n+            Tent := RTE (RE_Integer_64);\n          else\n-            Imid := RE_Image_Long_Long_Decimal;\n-            Tent := Standard_Long_Long_Integer;\n+            Imid := RE_Image_Decimal128;\n+            Tent := RTE (RE_Integer_128);\n          end if;\n \n       elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n-         Imid := RE_Image_Ordinary_Fixed_Point;\n-         Tent := Standard_Long_Long_Float;\n+         declare\n+            Num : constant Uint := Norm_Num (Small_Value (Rtyp));\n+            Den : constant Uint := Norm_Den (Small_Value (Rtyp));\n+            Max : constant Uint := UI_Max (Num, Den);\n+            Min : constant Uint := UI_Min (Num, Den);\n+            Siz : constant Uint := Esize (Rtyp);\n+\n+         begin\n+            if Siz <= 32\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 31\n+            then\n+               Imid := RE_Image_Fixed32;\n+               Tent := RTE (RE_Integer_32);\n+            elsif Siz <= 64\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 63\n+            then\n+               Imid := RE_Image_Fixed64;\n+               Tent := RTE (RE_Integer_64);\n+            elsif System_Max_Integer_Size = 128\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 127\n+            then\n+               Imid := RE_Image_Fixed128;\n+               Tent := RTE (RE_Integer_128);\n+            else\n+               Imid := RE_Image_Ordinary_Fixed_Point;\n+               Tent := Standard_Long_Long_Float;\n+            end if;\n+         end;\n \n       elsif Is_Floating_Point_Type (Rtyp) then\n          Imid := RE_Image_Floating_Point;\n@@ -746,29 +768,45 @@ package body Exp_Imgv is\n              Prefix         => New_Occurrence_Of (Ptyp, Loc),\n              Attribute_Name => Name_Digits));\n \n-      --  For ordinary fixed-point types, append Aft parameter\n+      --  For decimal, append Scale and also set to do literal conversion\n \n-      elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n-         Append_To (Arg_List,\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-             Attribute_Name => Name_Aft));\n+      elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n+         Set_Conversion_OK (First (Arg_List));\n+\n+         Append_To (Arg_List, Make_Integer_Literal (Loc, Scale_Value (Ptyp)));\n \n-         if Has_Decimal_Small (Rtyp) then\n+      --  For ordinary fixed-point types, append Num, Den, Fore, Aft parameters\n+      --  and also set to do literal conversion.\n+\n+      elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n+         if Imid /= RE_Image_Ordinary_Fixed_Point then\n             Set_Conversion_OK (First (Arg_List));\n-            Set_Etype (First (Arg_List), Tent);\n-         end if;\n \n-      --  For decimal, append Scale and also set to do literal conversion\n+            Append_To (Arg_List,\n+              Make_Integer_Literal (Loc, -Norm_Num (Small_Value (Ptyp))));\n \n-      elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n-         Append_To (Arg_List,\n-           Make_Attribute_Reference (Loc,\n-             Prefix         => New_Occurrence_Of (Ptyp, Loc),\n-             Attribute_Name => Name_Scale));\n+            Append_To (Arg_List,\n+              Make_Integer_Literal (Loc, -Norm_Den (Small_Value (Ptyp))));\n \n-         Set_Conversion_OK (First (Arg_List));\n-         Set_Etype (First (Arg_List), Tent);\n+            --  We want to compute the Fore value for the fixed point type\n+            --  whose mantissa type is Tent and whose small is typ'Small.\n+\n+            declare\n+               T : Ureal := Uint_2 ** (Esize (Tent) - 1) * Small_Value (Ptyp);\n+               F : Nat   := 2;\n+\n+            begin\n+               while T >= Ureal_10 loop\n+                  F := F + 1;\n+                  T := T / Ureal_10;\n+               end loop;\n+\n+               Append_To (Arg_List,\n+                  Make_Integer_Literal (Loc, UI_From_Int (F)));\n+            end;\n+         end if;\n+\n+         Append_To (Arg_List, Make_Integer_Literal (Loc, Aft_Value (Ptyp)));\n \n       --  For Wide_Character, append Ada 2005 indication\n \n@@ -827,35 +865,29 @@ package body Exp_Imgv is\n    --    For types whose root type is Boolean\n    --      xx = Boolean\n \n-   --    For signed integer types with size <= Integer'Size\n-   --      xx = Integer\n-\n-   --    For other signed integer types\n-   --      xx = Long_Long_Integer\n-\n-   --    For modular types with modulus <= System.Unsigned_Types.Unsigned\n-   --      xx = Unsigned\n+   --    For signed integer types\n+   --      xx = [Long_Long_[Long_]]Integer\n \n-   --    For other modular integer types\n-   --      xx = Long_Long_Unsigned\n+   --    For modular types\n+   --      xx = [Long_Long_[Long_]]Unsigned\n \n-   --    For floating-point types and ordinary fixed-point types\n+   --    For floating-point types\n    --      xx = Real\n \n-   --  For Wide_[Wide_]Character types, typ'Value (X) expands into:\n+   --  For decimal fixed-point types, typ'Value (X) expands into\n \n-   --    btyp (Value_xx (X, EM))\n+   --    btyp?(Value_Decimal{32,64,128} (X, typ'Scale));\n \n-   --  where btyp is the base type of the prefix, and EM is the encoding method\n+   --  For the most common ordinary fixed-point types\n \n-   --  For decimal types with size <= Integer'Size, typ'Value (X)\n-   --  expands into\n+   --    btyp?(Value_Fixed{32,64,128} (X, S, 1.0 / S));\n+   --    where S = typ'Small\n \n-   --    btyp?(Value_Decimal (X, typ'Scale));\n+   --  For Wide_[Wide_]Character types, typ'Value (X) expands into:\n \n-   --  For all other decimal types, typ'Value (X) expands into\n+   --    btyp (Value_xx (X, EM))\n \n-   --    btyp?(Value_Long_Long_Decimal (X, typ'Scale))\n+   --  where btyp is the base type of the prefix, and EM is the encoding method\n \n    --  For enumeration types other than those derived from types Boolean,\n    --  Character, Wide_[Wide_]Character in Standard, typ'Value (X) expands to:\n@@ -923,16 +955,15 @@ package body Exp_Imgv is\n          end if;\n \n       elsif Is_Decimal_Fixed_Point_Type (Rtyp) then\n-         if UI_To_Int (Esize (Rtyp)) <= Standard_Integer_Size then\n-            Vid := RE_Value_Decimal;\n+         if Esize (Rtyp) <= 32 and then abs (Scale_Value (Rtyp)) <= 9 then\n+            Vid := RE_Value_Decimal32;\n+         elsif Esize (Rtyp) <= 64 and then abs (Scale_Value (Rtyp)) <= 18 then\n+            Vid := RE_Value_Decimal64;\n          else\n-            Vid := RE_Value_Long_Long_Decimal;\n+            Vid := RE_Value_Decimal128;\n          end if;\n \n-         Append_To (Args,\n-           Make_Attribute_Reference (Loc,\n-             Prefix => New_Occurrence_Of (Typ, Loc),\n-             Attribute_Name => Name_Scale));\n+         Append_To (Args, Make_Integer_Literal (Loc, Scale_Value (Rtyp)));\n \n          Rewrite (N,\n            OK_Convert_To (Btyp,\n@@ -944,7 +975,54 @@ package body Exp_Imgv is\n          Analyze_And_Resolve (N, Btyp);\n          return;\n \n-      elsif Is_Real_Type (Rtyp) then\n+      elsif Is_Ordinary_Fixed_Point_Type (Rtyp) then\n+         declare\n+            Num : constant Uint := Norm_Num (Small_Value (Rtyp));\n+            Den : constant Uint := Norm_Den (Small_Value (Rtyp));\n+            Max : constant Uint := UI_Max (Num, Den);\n+            Min : constant Uint := UI_Min (Num, Den);\n+            Siz : constant Uint := Esize (Rtyp);\n+\n+         begin\n+            if Siz <= 32\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 31\n+            then\n+               Vid := RE_Value_Fixed32;\n+            elsif Siz <= 64\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 63\n+            then\n+               Vid := RE_Value_Fixed64;\n+            elsif System_Max_Integer_Size = 128\n+              and then Min = Uint_1\n+              and then Max <= Uint_2 ** 127\n+            then\n+               Vid := RE_Value_Fixed128;\n+            else\n+               Vid := RE_Value_Real;\n+            end if;\n+\n+            if Vid /= RE_Value_Real then\n+               Append_To (Args,\n+                 Make_Integer_Literal (Loc, -Norm_Num (Small_Value (Rtyp))));\n+\n+               Append_To (Args,\n+                 Make_Integer_Literal (Loc, -Norm_Den (Small_Value (Rtyp))));\n+\n+               Rewrite (N,\n+                 OK_Convert_To (Btyp,\n+                   Make_Function_Call (Loc,\n+                     Name => New_Occurrence_Of (RTE (Vid), Loc),\n+                     Parameter_Associations => Args)));\n+\n+               Set_Etype (N, Btyp);\n+               Analyze_And_Resolve (N, Btyp);\n+               return;\n+            end if;\n+         end;\n+\n+      elsif Is_Floating_Point_Type (Rtyp) then\n          Vid := RE_Value_Real;\n \n       --  Only other possibility is user-defined enumeration type\n@@ -1286,12 +1364,12 @@ package body Exp_Imgv is\n    --      yy = Boolean\n \n    --    For signed integer types\n-   --      xx = Width_Long_Long_Integer\n-   --      yy = Long_Long_Integer\n+   --      xx = Width_[Long_Long_[Long_]]Integer\n+   --      yy = [Long_Long_[Long_]]Integer\n \n    --    For modular integer types\n-   --      xx = Width_Long_Long_Unsigned\n-   --      yy = Long_Long_Unsigned\n+   --      xx = Width_[Long_Long_[Long_]]Unsigned\n+   --      yy = [Long_Long_[Long_]]Unsigned\n \n    --  For types derived from Wide_Character, typ'Width expands into\n \n@@ -1329,7 +1407,11 @@ package body Exp_Imgv is\n    --      Wide_Wide_Character (typ'First),\n    --      Wide_Wide_Character (typ'Last));\n \n-   --  For real types, typ'Width and typ'Wide_[Wide_]Width expand into\n+   --  For fixed point types, typ'Width and typ'Wide_[Wide_]Width expand into\n+\n+   --    if Ptyp'First > Ptyp'Last then 0 else Ptyp'Fore + 1 + Ptyp'Aft end if\n+\n+   --  and for floating point types, they expand into\n \n    --    if Ptyp'First > Ptyp'Last then 0 else btyp'Width end if\n \n@@ -1451,9 +1533,41 @@ package body Exp_Imgv is\n             YY := RTE (RE_Long_Long_Long_Unsigned);\n          end if;\n \n-      --  Real types\n+      --  Fixed point types\n \n-      elsif Is_Real_Type (Rtyp) then\n+      elsif Is_Fixed_Point_Type (Rtyp) then\n+         Rewrite (N,\n+           Make_If_Expression (Loc,\n+             Expressions => New_List (\n+\n+               Make_Op_Gt (Loc,\n+                 Left_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ptyp, Loc),\n+                     Attribute_Name => Name_First),\n+\n+                 Right_Opnd =>\n+                   Make_Attribute_Reference (Loc,\n+                     Prefix => New_Occurrence_Of (Ptyp, Loc),\n+                     Attribute_Name => Name_Last)),\n+\n+               Make_Integer_Literal (Loc, 0),\n+\n+               Make_Op_Add (Loc,\n+                 Make_Attribute_Reference (Loc,\n+                   Prefix => New_Occurrence_Of (Ptyp, Loc),\n+                   Attribute_Name => Name_Fore),\n+\n+                 Make_Op_Add (Loc,\n+                   Make_Integer_Literal (Loc, 1),\n+                   Make_Integer_Literal (Loc, Aft_Value (Ptyp)))))));\n+\n+         Analyze_And_Resolve (N, Typ);\n+         return;\n+\n+      --  Floating point types\n+\n+      elsif Is_Floating_Point_Type (Rtyp) then\n          Rewrite (N,\n            Make_If_Expression (Loc,\n              Expressions => New_List (\n@@ -1680,18 +1794,6 @@ package body Exp_Imgv is\n       Analyze_And_Resolve (N, Typ);\n    end Expand_Width_Attribute;\n \n-   -----------------------\n-   -- Has_Decimal_Small --\n-   -----------------------\n-\n-   function Has_Decimal_Small (E : Entity_Id) return Boolean is\n-   begin\n-      return Is_Decimal_Fixed_Point_Type (E)\n-        or else\n-          (Is_Ordinary_Fixed_Point_Type (E)\n-             and then Ureal_10**Aft_Value (E) * Small_Value (E) = Ureal_1);\n-   end Has_Decimal_Small;\n-\n    --------------------------\n    -- Rewrite_Object_Image --\n    --------------------------"}, {"sha": "ce86fac56154f49189f57c6cc5bea7a1721ed684", "filename": "gcc/ada/freeze.adb", "status": "modified", "additions": 137, "deletions": 35, "changes": 172, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Ffreeze.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Ffreeze.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ffreeze.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -6339,35 +6339,6 @@ package body Freeze is\n          if Is_Fixed_Point_Type (E) then\n             Freeze_Fixed_Point_Type (E);\n \n-            --  Some error checks required for ordinary fixed-point type. Defer\n-            --  these till the freeze-point since we need the small and range\n-            --  values. We only do these checks for base types\n-\n-            if Is_Ordinary_Fixed_Point_Type (E) and then Is_Base_Type (E) then\n-               if Small_Value (E) < Ureal_2_M_80 then\n-                  Error_Msg_Name_1 := Name_Small;\n-                  Error_Msg_N\n-                    (\"`&''%` too small, minimum allowed is 2.0'*'*(-80)\", E);\n-\n-               elsif Small_Value (E) > Ureal_2_80 then\n-                  Error_Msg_Name_1 := Name_Small;\n-                  Error_Msg_N\n-                    (\"`&''%` too large, maximum allowed is 2.0'*'*80\", E);\n-               end if;\n-\n-               if Expr_Value_R (Type_Low_Bound (E)) < Ureal_M_10_36 then\n-                  Error_Msg_Name_1 := Name_First;\n-                  Error_Msg_N\n-                    (\"`&''%` too small, minimum allowed is -10.0'*'*36\", E);\n-               end if;\n-\n-               if Expr_Value_R (Type_High_Bound (E)) > Ureal_10_36 then\n-                  Error_Msg_Name_1 := Name_Last;\n-                  Error_Msg_N\n-                    (\"`&''%` too large, maximum allowed is 10.0'*'*36\", E);\n-               end if;\n-            end if;\n-\n          elsif Is_Enumeration_Type (E) then\n             Freeze_Enumeration_Type (E);\n \n@@ -8123,6 +8094,12 @@ package body Freeze is\n       --  Returns size of type with given bounds. Also leaves these\n       --  bounds set as the current bounds of the Typ.\n \n+      function Larger (A, B : Ureal) return Boolean;\n+      --  Returns true if A > B with a margin of Typ'Small\n+\n+      function Smaller (A, B : Ureal) return Boolean;\n+      --  Returns true if A < B with a margin of Typ'Small\n+\n       -----------\n       -- Fsize --\n       -----------\n@@ -8134,6 +8111,24 @@ package body Freeze is\n          return Minimum_Size (Typ);\n       end Fsize;\n \n+      ------------\n+      -- Larger --\n+      ------------\n+\n+      function Larger (A, B : Ureal) return Boolean is\n+      begin\n+         return A > B and then A - Small > B;\n+      end Larger;\n+\n+      -------------\n+      -- Smaller --\n+      -------------\n+\n+      function Smaller (A, B : Ureal) return Boolean is\n+      begin\n+         return A < B and then A + Small < B;\n+      end Smaller;\n+\n    --  Start of processing for Freeze_Fixed_Point_Type\n \n    begin\n@@ -8155,7 +8150,7 @@ package body Freeze is\n          if Present (Atype) then\n             Set_Esize (Typ, Esize (Atype));\n          else\n-            Set_Esize (Typ, Esize (Base_Type (Typ)));\n+            Set_Esize (Typ, Esize (Btyp));\n          end if;\n       end if;\n \n@@ -8435,6 +8430,110 @@ package body Freeze is\n             Set_Realval (Hi, Actual_Hi);\n          end Fudge;\n \n+         --  Enforce some limitations for ordinary fixed-point types. They come\n+         --  from an exact algorithm used to implement Text_IO.Fixed_IO and the\n+         --  Fore, Image and Value attributes. The requirement on the Small is\n+         --  to lie in the range 2**(-(Siz - 1)) .. 2**(Siz - 1) for a type of\n+         --  Siz bits (Siz=32,64,128) and the requirement on the bounds is to\n+         --  be smaller in magnitude than 10.0**N * 2**(Siz - 1), where N is\n+         --  given by the formula N = floor ((Siz - 1) * log 2 / log 10).\n+\n+         --  If the bounds of a 32-bit type are too large, force 64-bit type\n+\n+         if Actual_Size <= 32\n+           and then Small <= Ureal_2_31\n+           and then (Smaller (Expr_Value_R (Lo), Ureal_M_2_10_18)\n+                      or else Larger (Expr_Value_R (Hi), Ureal_2_10_18))\n+         then\n+            Actual_Size := 33;\n+         end if;\n+\n+         --  If the bounds of a 64-bit type are too large, force 128-bit type\n+\n+         if System_Max_Integer_Size = 128\n+           and then Actual_Size <= 64\n+           and then Small <= Ureal_2_63\n+           and then (Smaller (Expr_Value_R (Lo), Ureal_M_9_10_36)\n+                      or else Larger (Expr_Value_R (Hi), Ureal_9_10_36))\n+         then\n+            Actual_Size := 65;\n+         end if;\n+\n+         --  Give error messages for first subtypes and not base types, as the\n+         --  bounds of base types are always maximum for their size, see below.\n+\n+         if System_Max_Integer_Size < 128 and then Typ /= Btyp then\n+\n+            --  See the 128-bit case below for the reason why we cannot test\n+            --  against the 2**(-63) .. 2**63 range. This quirk should have\n+            --  been kludged around as in the 128-bit case below, but it was\n+            --  not and we end up with a ludicrous range as a result???\n+\n+            if Small < Ureal_2_M_80 then\n+               Error_Msg_Name_1 := Name_Small;\n+               Error_Msg_N\n+                 (\"`&''%` too small, minimum allowed is 2.0'*'*(-80)\", Typ);\n+\n+            elsif Small > Ureal_2_80 then\n+               Error_Msg_Name_1 := Name_Small;\n+               Error_Msg_N\n+                 (\"`&''%` too large, maximum allowed is 2.0'*'*80\", Typ);\n+            end if;\n+\n+            if Smaller (Expr_Value_R (Lo), Ureal_M_9_10_36) then\n+               Error_Msg_Name_1 := Name_First;\n+               Error_Msg_N\n+                 (\"`&''%` too small, minimum allowed is -9.0E+36\", Typ);\n+            end if;\n+\n+            if Larger (Expr_Value_R (Hi), Ureal_9_10_36) then\n+               Error_Msg_Name_1 := Name_Last;\n+               Error_Msg_N\n+                 (\"`&''%` too large, maximum allowed is 9.0E+36\", Typ);\n+            end if;\n+\n+         elsif System_Max_Integer_Size = 128 and then Typ /= Btyp then\n+\n+            --  ACATS c35902d tests a delta equal to 2**(-(Max_Mantissa + 1))\n+            --  but we cannot really support anything smaller than Fine_Delta\n+            --  because of the way we implement I/O for fixed point types???\n+\n+            if Small = Ureal_2_M_128 then\n+               null;\n+\n+            elsif Small < Ureal_2_M_127 then\n+               Error_Msg_Name_1 := Name_Small;\n+               Error_Msg_N\n+                 (\"`&''%` too small, minimum allowed is 2.0'*'*(-127)\", Typ);\n+\n+            elsif Small > Ureal_2_127 then\n+               Error_Msg_Name_1 := Name_Small;\n+               Error_Msg_N\n+                 (\"`&''%` too large, maximum allowed is 2.0'*'*127\", Typ);\n+            end if;\n+\n+            if Actual_Size > 64\n+              and then Norm_Num (Small) /= Uint_1\n+              and then Norm_Den (Small) /= Uint_1\n+            then\n+               Error_Msg_Name_1 := Name_Small;\n+               Error_Msg_N\n+                 (\"`&''%` not an integer or reciprocal of an integer\", Typ);\n+            end if;\n+\n+            if Smaller (Expr_Value_R (Lo), Ureal_M_10_76) then\n+               Error_Msg_Name_1 := Name_First;\n+               Error_Msg_N\n+                 (\"`&''%` too small, minimum allowed is -1.0E+76\", Typ);\n+            end if;\n+\n+            if Larger (Expr_Value_R (Hi), Ureal_10_76) then\n+               Error_Msg_Name_1 := Name_Last;\n+               Error_Msg_N\n+                 (\"`&''%` too large, maximum allowed is 1.0E+76\", Typ);\n+            end if;\n+         end if;\n+\n       --  For the decimal case, none of this fudging is required, since there\n       --  are no end-point problems in the decimal case (the end-points are\n       --  always included).\n@@ -8446,12 +8545,13 @@ package body Freeze is\n       --  At this stage, the actual size has been calculated and the proper\n       --  required bounds are stored in the low and high bounds.\n \n-      if Actual_Size > 64 then\n+      if Actual_Size > System_Max_Integer_Size then\n          Error_Msg_Uint_1 := UI_From_Int (Actual_Size);\n+         Error_Msg_Uint_2 := UI_From_Int (System_Max_Integer_Size);\n          Error_Msg_N\n-           (\"size required (^) for type& too large, maximum allowed is 64\",\n+           (\"size required (^) for type& too large, maximum allowed is ^\",\n             Typ);\n-         Actual_Size := 64;\n+         Actual_Size := System_Max_Integer_Size;\n       end if;\n \n       --  Check size against explicit given size\n@@ -8477,8 +8577,10 @@ package body Freeze is\n             Actual_Size := 16;\n          elsif Actual_Size <= 32 then\n             Actual_Size := 32;\n-         else\n+         elsif Actual_Size <= 64 then\n             Actual_Size := 64;\n+         else\n+            Actual_Size := 128;\n          end if;\n \n          Init_Esize (Typ, Actual_Size);\n@@ -8489,7 +8591,7 @@ package body Freeze is\n       --  the full width of the allocated size in bits, to avoid junk range\n       --  checks on intermediate computations.\n \n-      if Base_Type (Typ) = Typ then\n+      if Typ = Btyp then\n          Set_Realval (Lo, -(Small * (Uint_2 ** (Actual_Size - 1))));\n          Set_Realval (Hi,  (Small * (Uint_2 ** (Actual_Size - 1) - 1)));\n       end if;"}, {"sha": "66665206c4c9f56408b8f56867d75e38adc51b2c", "filename": "gcc/ada/gnat_rm.texi", "status": "modified", "additions": 20, "deletions": 10, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fgnat_rm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fgnat_rm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fgnat_rm.texi?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -15709,16 +15709,26 @@ The small is the largest power of two that does not exceed the delta.\n supported for fixed point types.  See 3.5.9(10).\"\n @end itemize\n \n-For an ordinary fixed point type, the small must lie in 2.0**(-80) .. 2.0**80\n-and the range in -10.0**36 .. 10.0**36; any combination is permitted that\n-does not result in a mantissa larger than 63 bits. However, if the mantissa\n-is larger than 53 bits on machines where Long_Long_Float is 64 bits (true\n-of all architectures except x86), then the output from Text_IO may be\n-accurate to only 53 bits, rather than the full mantissa.  This is because\n-floating-point conversions may be used to convert fixed point.\n-\n-For a decimal fixed point type, the small must lie in 10.0**(-18) .. 10.0**18\n-and the digits in 1 .. 18.\n+For an ordinary fixed point type, on 32-bit platforms, the small must lie in\n+2.0**(-80) .. 2.0**80 and the range in -9.0E+36 .. 9.0E+36; any combination\n+is permitted that does not result in a mantissa larger than 63 bits.\n+\n+On 64-bit platforms, the small must lie in 2.0**(-127) .. 2.0**127 and the\n+range in -1.0E+76 .. 1.0E+76; any combination is permitted that does not\n+result in a mantissa larger than 63 bits, and any combination is permitted\n+that results in a mantissa between 64 and 127 bits if the small is either\n+an integer or the reciprocal of an integer.\n+\n+If the small is either an integer or the reciprocal of an integer, which\n+is the case if no @code{small} clause is provided, then the operations of the\n+fixed point type are entirely implemented by means of integer instructions.\n+In the other cases, some operations, in particular input and output, may be\n+implemented by means of floating-point instructions and may be affected by\n+accuracy issues on architectures other than x86.\n+\n+For a decimal fixed point type, on 32-bit platforms, the small must lie in\n+1.0E-18 .. 1.0E+18 and the digits in 1 .. 18.  On 64-bit platforms, the\n+small must lie in 1.0E-38 .. 1.0E+38 and the digits in 1 .. 38.\n \n \n @itemize *"}, {"sha": "b29b010bab1b8a0acb529605041cf8881f431042", "filename": "gcc/ada/libgnat/a-decima__128.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-decima__128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-decima__128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-decima__128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                          A D A . D E C I M A L                           --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- This specification is derived from the Ada Reference Manual for use with --\n+-- GNAT. The copyright notice above, and the license provisions that follow --\n+-- apply solely to the  contents of the part following the private keyword. --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This is the 128-bit version of this package\n+\n+package Ada.Decimal is\n+   pragma Pure;\n+\n+   --  The compiler makes a number of assumptions based on the following five\n+   --  constants (e.g. there is an assumption that decimal values can always\n+   --  be represented in 128-bit signed binary form), so code modifications are\n+   --  required to increase these constants.\n+\n+   Max_Scale : constant := +38;\n+   Min_Scale : constant := -38;\n+\n+   Min_Delta : constant := 1.0E-38;\n+   Max_Delta : constant := 1.0E+38;\n+\n+   Max_Decimal_Digits : constant := 38;\n+\n+   generic\n+      type Dividend_Type  is delta <> digits <>;\n+      type Divisor_Type   is delta <> digits <>;\n+      type Quotient_Type  is delta <> digits <>;\n+      type Remainder_Type is delta <> digits <>;\n+\n+   procedure Divide\n+     (Dividend  : Dividend_Type;\n+      Divisor   : Divisor_Type;\n+      Quotient  : out Quotient_Type;\n+      Remainder : out Remainder_Type);\n+\n+private\n+   pragma Inline (Divide);\n+\n+end Ada.Decimal;"}, {"sha": "5878234dde459c70c9aad9fcec174d2b3e6f7409", "filename": "gcc/ada/libgnat/a-tideau.adb", "status": "modified", "additions": 39, "deletions": 148, "changes": 187, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tideau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -32,26 +32,21 @@\n with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n with Ada.Text_IO.Float_Aux;   use Ada.Text_IO.Float_Aux;\n \n-with System.Img_Dec; use System.Img_Dec;\n-with System.Img_LLD; use System.Img_LLD;\n-with System.Val_Dec; use System.Val_Dec;\n-with System.Val_LLD; use System.Val_LLD;\n-\n package body Ada.Text_IO.Decimal_Aux is\n \n-   -------------\n-   -- Get_Dec --\n-   -------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   function Get_Dec\n+   function Get\n      (File  : File_Type;\n       Width : Field;\n-      Scale : Integer) return Integer\n+      Scale : Integer) return Int\n    is\n       Buf  : String (1 .. Field'Last);\n       Ptr  : aliased Integer;\n       Stop : Integer := 0;\n-      Item : Integer;\n+      Item : Int;\n \n    begin\n       if Width /= 0 then\n@@ -62,114 +57,42 @@ package body Ada.Text_IO.Decimal_Aux is\n          Ptr := 1;\n       end if;\n \n-      Item := Scan_Decimal (Buf, Ptr'Access, Stop, Scale);\n+      Item := Scan (Buf, Ptr'Access, Stop, Scale);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n       return Item;\n-   end Get_Dec;\n-\n-   -------------\n-   -- Get_LLD --\n-   -------------\n-\n-   function Get_LLD\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Long_Long_Integer\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer;\n-      Stop : Integer := 0;\n-      Item : Long_Long_Integer;\n+   end Get;\n \n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Real (File, Buf, Stop);\n-         Ptr := 1;\n-      end if;\n+   ----------\n+   -- Gets --\n+   ----------\n \n-      Item := Scan_Long_Long_Decimal (Buf, Ptr'Access, Stop, Scale);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-      return Item;\n-   end Get_LLD;\n-\n-   --------------\n-   -- Gets_Dec --\n-   --------------\n-\n-   function Gets_Dec\n+   function Gets\n      (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer\n+      Last  : out Positive;\n+      Scale : Integer) return Int\n    is\n       Pos  : aliased Integer;\n-      Item : Integer;\n+      Item : Int;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n+      Item := Scan (From, Pos'Access, From'Last, Scale);\n+      Last := Pos - 1;\n       return Item;\n \n    exception\n       when Constraint_Error =>\n-         Last.all := Pos - 1;\n+         Last := Pos - 1;\n          raise Data_Error;\n-   end Gets_Dec;\n-\n-   --------------\n-   -- Gets_LLD --\n-   --------------\n-\n-   function Gets_LLD\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer\n-   is\n-      Pos  : aliased Integer;\n-      Item : Long_Long_Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n-      return Item;\n-\n-   exception\n-      when Constraint_Error =>\n-         Last.all := Pos - 1;\n-         raise Data_Error;\n-   end Gets_LLD;\n-\n-   -------------\n-   -- Put_Dec --\n-   -------------\n+   end Gets;\n \n-   procedure Put_Dec\n-     (File  : File_Type;\n-      Item  : Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Dec;\n-\n-   -------------\n-   -- Put_LLD --\n-   -------------\n+   ---------\n+   -- Put --\n+   ---------\n \n-   procedure Put_LLD\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n@@ -179,83 +102,51 @@ package body Ada.Text_IO.Decimal_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLD;\n+   end Put;\n \n-   --------------\n-   -- Puts_Dec --\n-   --------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Puts_Dec\n+   procedure Puts\n      (To    : out String;\n-      Item  : Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer)\n    is\n-      Buf  : String (1 .. Field'Last);\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n       Fore : Integer;\n       Ptr  : Natural := 0;\n \n    begin\n-      --  Compute Fore, allowing for Aft digits and the decimal dot\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n \n-      Fore := To'Length - Field'Max (1, Aft) - 1;\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n \n-      --  Allow for Exp and two more for E+ or E- if exponent present\n+      --  Allow for Exp and one more for E if exponent present\n \n       if Exp /= 0 then\n-         Fore := Fore - 2 - Exp;\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n       end if;\n \n       --  Make sure we have enough room\n \n-      if Fore < 1 then\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n          raise Layout_Error;\n       end if;\n \n       --  Do the conversion and check length of result\n \n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Dec;\n-\n-   --------------\n-   -- Puts_LLD --\n-   --------------\n-\n-   procedure Puts_LLD\n-     (To    : out String;\n-      Item  : Long_Long_Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Fore : Integer;\n-      Ptr  : Natural := 0;\n-\n-   begin\n-      Fore :=\n-        (if Exp = 0 then To'Length - 1 - Aft else To'Length - 2 - Aft - Exp);\n-\n-      if Fore < 1 then\n-         raise Layout_Error;\n-      end if;\n-\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLD;\n+   end Puts;\n \n end Ada.Text_IO.Decimal_Aux;"}, {"sha": "522e3515186ed5dcd6a7a46ba89181b7025552ca", "filename": "gcc/ada/libgnat/a-tideau.ads", "status": "modified", "additions": 33, "deletions": 41, "changes": 74, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tideau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -29,62 +29,54 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Text_IO.Decimal_IO that are\n---  shared among separate instantiations of this package. The routines in\n---  the package are identical semantically to those declared in Text_IO,\n---  except that default values have been supplied by the generic, and the\n---  Num parameter has been replaced by Integer or Long_Long_Integer, with\n---  an additional Scale parameter giving the value of Num'Scale. In addition\n---  the Get routines return the value rather than store it in an Out parameter.\n+--  This package contains the implementation for Ada.Text_IO.Decimal_IO. The\n+--  routines in this package are identical semantically to those in Decimal_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there is an\n+--  additional Scale parameter giving the value of Num'Scale. In addition the\n+--  Get routines return the value rather than store it in an Out parameter.\n \n-private package Ada.Text_IO.Decimal_Aux is\n+private generic\n+   type Int is range <>;\n \n-   function Get_Dec\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Integer;\n+   with function Scan\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Scale : Integer) return Int;\n \n-   function Get_LLD\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Long_Long_Integer;\n+   with procedure Set_Image\n+     (V     : Int;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural);\n+\n+package Ada.Text_IO.Decimal_Aux is\n \n-   procedure Put_Dec\n+   function Get\n      (File  : File_Type;\n-      Item  : Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+      Width : Field;\n+      Scale : Integer) return Int;\n \n-   procedure Put_LLD\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);\n \n-   function Gets_Dec\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer;\n-\n-   function Gets_LLD\n+   function Gets\n      (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer;\n-\n-   procedure Puts_Dec\n-     (To    : out String;\n-      Item  : Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+      Last  : out Positive;\n+      Scale : Integer) return Int;\n \n-   procedure Puts_LLD\n+   procedure Puts\n      (To    : out String;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);"}, {"sha": "f71cf2df85f01a389a6e3ca4a53209c6958c7d1b", "filename": "gcc/ada/libgnat/a-tideio.adb", "status": "modified", "additions": 39, "deletions": 19, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tideio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -29,11 +29,35 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Interfaces;\n with Ada.Text_IO.Decimal_Aux;\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n \n package body Ada.Text_IO.Decimal_IO is\n \n-   package Aux renames Ada.Text_IO.Decimal_Aux;\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Aux32 is new\n+     Ada.Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   Need64 : constant Boolean := Num'Size > 32;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n \n    Scale : constant Integer := Num'Scale;\n \n@@ -49,10 +73,10 @@ package body Ada.Text_IO.Decimal_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if Num'Size > Integer'Size then\n-         Item := Num'Fixed_Value (Aux.Get_LLD (File, Width, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n       else\n-         Item := Num'Fixed_Value (Aux.Get_Dec (File, Width, Scale));\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n       end if;\n \n    exception\n@@ -75,12 +99,10 @@ package body Ada.Text_IO.Decimal_IO is\n       pragma Unsuppress (Range_Check);\n \n    begin\n-      if Num'Size > Integer'Size then\n-         Item := Num'Fixed_Value\n-                   (Aux.Gets_LLD (From, Last'Unrestricted_Access, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (From, Last, Scale));\n       else\n-         Item := Num'Fixed_Value\n-                   (Aux.Gets_Dec (From, Last'Unrestricted_Access, Scale));\n+         Item := Num'Fixed_Value (Aux32.Gets (From, Last, Scale));\n       end if;\n \n    exception\n@@ -99,13 +121,12 @@ package body Ada.Text_IO.Decimal_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if Num'Size > Integer'Size then\n-         Aux.Put_LLD\n-           (File, Long_Long_Integer'Integer_Value (Item),\n-            Fore, Aft, Exp, Scale);\n+      if Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       else\n-         Aux.Put_Dec\n-           (File, Integer'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       end if;\n    end Put;\n \n@@ -126,11 +147,10 @@ package body Ada.Text_IO.Decimal_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if Num'Size > Integer'Size then\n-         Aux.Puts_LLD\n-           (To, Long_Long_Integer'Integer_Value (Item), Aft, Exp, Scale);\n+      if Need64 then\n+         Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp, Scale);\n       else\n-         Aux.Puts_Dec (To, Integer'Integer_Value (Item), Aft, Exp, Scale);\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp, Scale);\n       end if;\n    end Put;\n "}, {"sha": "a8cdf9f918e2973bb6b9ab9bcb48f831eece16d1", "filename": "gcc/ada/libgnat/a-tideio__128.adb", "status": "added", "additions": 177, "deletions": 0, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tideio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tideio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,177 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               A D A . T E X T _ I O . D E C I M A L _ I O                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces;\n+with Ada.Text_IO.Decimal_Aux;\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Img_Decimal_128; use System.Img_Decimal_128;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n+with System.Val_Decimal_128; use System.Val_Decimal_128;\n+\n+package body Ada.Text_IO.Decimal_IO is\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   package Aux128 is new\n+     Ada.Text_IO.Decimal_Aux\n+       (Int128,\n+        Scan_Decimal128,\n+        Set_Image_Decimal128);\n+\n+   Need64  : constant Boolean := Num'Size > 32;\n+   Need128 : constant Boolean := Num'Size > 64;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable, where type Int64 is acceptable and where an Int128\n+   --  is needed. These boolean constants are used to test for these cases and\n+   --  since it is a constant, only code for the relevant case will be included\n+   --  in the instance.\n+\n+   Scale : constant Integer := Num'Scale;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Get (File, Width, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_In, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Gets (From, Last, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (From, Last, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Gets (From, Last, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if Need128 then\n+         Aux128.Put\n+           (File, Int128'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      else\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Out, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if Need128 then\n+         Aux128.Puts (To, Int128'Integer_Value (Item), Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp, Scale);\n+      else\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp, Scale);\n+      end if;\n+   end Put;\n+\n+end Ada.Text_IO.Decimal_IO;"}, {"sha": "92595524febb77d750950df1e310774e929f4344", "filename": "gcc/ada/libgnat/a-tifiau.adb", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,160 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . T E X T _ I O . F I X E D _ A U X                --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Text_IO.Generic_Aux; use Ada.Text_IO.Generic_Aux;\n+with Ada.Text_IO.Float_Aux;   use Ada.Text_IO.Float_Aux;\n+\n+package body Ada.Text_IO.Fixed_Aux is\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int\n+   is\n+      Buf  : String (1 .. Field'Last);\n+      Ptr  : aliased Integer;\n+      Stop : Integer := 0;\n+      Item : Int;\n+\n+   begin\n+      if Width /= 0 then\n+         Load_Width (File, Width, Buf, Stop);\n+         String_Skip (Buf, Ptr);\n+      else\n+         Load_Real (File, Buf, Stop);\n+         Ptr := 1;\n+      end if;\n+\n+      Item := Scan (Buf, Ptr'Access, Stop, Num, Den);\n+      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n+      return Item;\n+   end Get;\n+\n+   ----------\n+   -- Gets --\n+   ----------\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int\n+   is\n+      Pos  : aliased Integer;\n+      Item : Int;\n+\n+   begin\n+      String_Skip (From, Pos);\n+      Item := Scan (From, Pos'Access, From'Last, Num, Den);\n+      Last := Pos - 1;\n+      return Item;\n+\n+   exception\n+      when Constraint_Error =>\n+         Last := Pos - 1;\n+         raise Data_Error;\n+   end Gets;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf : String (1 .. Field'Last);\n+      Ptr : Natural := 0;\n+\n+   begin\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+      Put_Item (File, Buf (1 .. Ptr));\n+   end Put;\n+\n+   ----------\n+   -- Puts --\n+   ----------\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n+      Fore : Integer;\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n+\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n+\n+      --  Allow for Exp and one more for E if exponent present\n+\n+      if Exp /= 0 then\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n+      end if;\n+\n+      --  Make sure we have enough room\n+\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n+         raise Layout_Error;\n+      end if;\n+\n+      --  Do the conversion and check length of result\n+\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+\n+      if Ptr > To'Length then\n+         raise Layout_Error;\n+      else\n+         To := Buf (1 .. Ptr);\n+      end if;\n+   end Puts;\n+\n+end Ada.Text_IO.Fixed_Aux;"}, {"sha": "32701c51fc86dadb7b8108bde0b3f22778c4bd7e", "filename": "gcc/ada/libgnat/a-tifiau.ads", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . T E X T _ I O . F I X E D _ A U X                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the implementation for Ada.Text_IO.Fixed_IO. The\n+--  routines in this package are identical semantically to those in Fixed_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there are\n+--  additional Num and Den parameters giving the value of Num'Small, as well\n+--  as For0 and Aft0 giving some properties of Num'Small. In addition the Get\n+--  routines return the value rather than store it in an Out parameter.\n+\n+private generic\n+   type Int is range <>;\n+\n+   with function Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int;\n+      Den : Int) return Int;\n+\n+   with procedure Set_Image\n+     (V    : Int;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n+package Ada.Text_IO.Fixed_Aux is\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int;\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int;\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+end Ada.Text_IO.Fixed_Aux;"}, {"sha": "67cb917d5eb46d7c31be4cceea15ccd1996a003a", "filename": "gcc/ada/libgnat/a-tifiio.adb", "status": "modified", "additions": 109, "deletions": 488, "changes": 597, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -140,168 +140,70 @@\n --  solution. The downside however may be a too limited set of acceptable\n --  fixed point types.\n \n-with Interfaces;                        use Interfaces;\n-with System.Arith_64;                   use System.Arith_64;\n-with System.Img_Real;                   use System.Img_Real;\n-with Ada.Text_IO;                       use Ada.Text_IO;\n+with Interfaces;\n+with Ada.Text_IO.Fixed_Aux;\n with Ada.Text_IO.Float_Aux;\n-with Ada.Text_IO.Generic_Aux;\n+with System.Img_Fixed_32; use System.Img_Fixed_32;\n+with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Val_Fixed_32; use System.Val_Fixed_32;\n+with System.Val_Fixed_64; use System.Val_Fixed_64;\n \n package body Ada.Text_IO.Fixed_IO is\n \n-   --  Note: we still use the floating-point I/O routines for input of\n-   --  ordinary fixed-point and output using exponent format. This will\n-   --  result in inaccuracies for fixed point types with a small that is\n-   --  not a power of two, and for types that require more precision than\n-   --  is available in Long_Long_Float.\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n \n-   package Aux renames Ada.Text_IO.Float_Aux;\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n \n-   Extra_Layout_Space : constant Field := 5 + Num'Fore;\n-   --  Extra space that may be needed for output of sign, decimal point,\n-   --  exponent indication and mandatory decimals after and before the\n-   --  decimal point. A string with length\n+   package Aux32 is new\n+     Ada.Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n \n-   --    Fore + Aft + Exp + Extra_Layout_Space\n-\n-   --  is always long enough for formatting any fixed point number.\n-\n-   --  Implementation of Put routines\n-\n-   --  The following section describes a specific implementation choice for\n-   --  performing base conversions needed for output of values of a fixed\n-   --  point type T with small T'Small. The goal is to be able to output\n-   --  all values of types with a precision of 64 bits and a delta of at\n-   --  least 2.0**(-63), as these are current GNAT limitations already.\n-\n-   --  The chosen algorithm uses fixed precision integer arithmetic for\n-   --  reasons of simplicity and efficiency. It is important to understand\n-   --  in what ways the most simple and accurate approach to fixed point I/O\n-   --  is limiting, before considering more complicated schemes.\n-\n-   --  Without loss of generality assume T has a range (-2.0**63) * T'Small\n-   --  .. (2.0**63 - 1) * T'Small, and is output with Aft digits after the\n-   --  decimal point and T'Fore - 1 before. If T'Small is integer, or\n-   --  1.0 / T'Small is integer, let S = T'Small and E = 0. For other T'Small,\n-   --  let S and E be integers such that S / 10**E best approximates T'Small\n-   --  and S is in the range 10**17 .. 10**18 - 1. The extra decimal scaling\n-   --  factor 10**E can be trivially handled during final output, by adjusting\n-   --  the decimal point or exponent.\n-\n-   --  The idea is to convert a value X * S of type T to a 64-bit integer value\n-   --  Q equal to 10.0**D * (X * S) rounded to the nearest integer, using only\n-   --  a scaled integer divide of the form\n-\n-   --     Q := (X * Y) / Z,\n-\n-   --  where the variables X, Y, Z are 64-bit integers, and both multiplication\n-   --  and division are done using full intermediate precision. Then the final\n-   --  decimal value to be output is\n-\n-   --     Q * 10**(E-D)\n-\n-   --  This value can be written to the output file or to the result string\n-   --  according to the format described in RM A.3.10. The details of this\n-   --  operation are omitted here.\n-\n-   --  A 64-bit value can represent all integers with 18 decimal digits, but\n-   --  not all with 19 decimal digits. If the total number of requested ouput\n-   --  digits (Fore - 1) + Aft is greater than 18 then, for purposes of the\n-   --  conversion, Aft is adjusted to 18 - (Fore - 1). In that case, trailing\n-   --  zeros can complete the output after writing the first 18 significant\n-   --  digits, or the technique described in the next section can be used.\n-\n-   --  The final expression for D is\n-\n-   --     D := Integer'Max (-18, Integer'Min (Aft, 18 - (Fore - 1)));\n-\n-   --  For Y and Z the following expressions can be derived:\n-\n-   --     Q = X * S * (10.0**D) = (X * Y) / Z\n-\n-   --     S * 10.0**D = Y / Z;\n-\n-   --  If S is an integer greater than or equal to one, then Fore must be at\n-   --  least 20 in order to print T'First, which is at most -2.0**63. This\n-   --  means that D < 0, so use\n-\n-   --    (1)   Y = -S and Z = -10**(-D)\n-\n-   --  If 1.0 / S is an integer greater than one, use\n-\n-   --    (2)   Y = -10**D and Z = -(1.0 / S), for D >= 0\n-\n-   --  or\n-\n-   --    (3)   Y = -1 and Z = -(1.0 / S) * 10**(-D), for D < 0\n-\n-   --  Negative values are used for nominator Y and denominator Z, so that S\n-   --  can have a maximum value of 2.0**63 and a minimum of 2.0**(-63).\n-   --  For Z in -1 .. -9, Fore will still be 20, and D will be negative, as\n-   --  (-2.0**63) / -9 is greater than 10**18. In these cases there is room\n-   --  in the denominator for the extra decimal scaling required, so case (3)\n-   --  will not overflow.\n-\n-   --  Extra Precision\n-\n-   --  Using a scaled divide which truncates and returns a remainder R,\n-   --  another K trailing digits can be calculated by computing the value\n-   --  (R * (10.0**K)) / Z using another scaled divide. This procedure\n-   --  can be repeated to compute an arbitrary number of digits in linear\n-   --  time and storage. The last scaled divide should be rounded, with\n-   --  a possible carry propagating to the more significant digits, to\n-   --  ensure correct rounding of the unit in the last place.\n-\n-   --  A variant of this technique is to limit the value of Q to 9 decimal\n-   --  digits, since 32-bit integers can be much more efficient than 64-bit\n-   --  integers to output.\n-\n-   pragma Assert (System.Fine_Delta >= 2.0**(-63));\n-   pragma Assert (Num'Small in 2.0**(-80) .. 2.0**80);\n-   pragma Assert (Num'Fore <= 37);\n-\n-   Max_Digits : constant := 18;\n-   --  Maximum number of decimal digits that can be represented in a\n-   --  64-bit signed number, see above\n-\n-   --  The constants E0 .. E5 implement a binary search for the appropriate\n-   --  power of ten to scale the small so that it has one digit before the\n-   --  decimal point.\n-\n-   subtype Int is Integer;\n-   E0 : constant Int := -(25 * Boolean'Pos (Num'Small >= 1.0E1));\n-   E1 : constant Int := E0 + 13 * Boolean'Pos (Num'Small * 10.0**E0 < 1.0E-13);\n-   E2 : constant Int := E1 +  6 * Boolean'Pos (Num'Small * 10.0**E1 < 1.0E-6);\n-   E3 : constant Int := E2 +  3 * Boolean'Pos (Num'Small * 10.0**E2 < 1.0E-3);\n-   E4 : constant Int := E3 +  2 * Boolean'Pos (Num'Small * 10.0**E3 < 1.0E-1);\n-   E5 : constant Int := E4 +  1 * Boolean'Pos (Num'Small * 10.0**E4 < 1.0E-0);\n-\n-   Scale : constant Integer := E5;\n-\n-   pragma Assert (Num'Small * 10.0**Scale >= 1.0\n-                   and then Num'Small * 10.0**Scale < 10.0);\n+   package Aux64 is new\n+     Ada.Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n \n    Exact : constant Boolean :=\n      (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n-        or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small)\n-        or else Num'Small >= 10.0**Max_Digits)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n      and then Num'Small >= 2.0**(-63)\n      and then Num'Small <= 2.0**63;\n-   --  True iff a 64-bit numerator and denominator can be calculated such that\n-   --  their ratio exactly represents the small of Num.\n-\n-   procedure Put\n-     (To   : out String;\n-      Last : out Natural;\n-      Item : Num;\n-      Fore : Integer;\n-      Aft  : Field;\n-      Exp  : Field);\n-   --  Actual output function, used internally by all other Put routines.\n-   --  The formal Fore is an Integer, not a Field, because the routine is\n-   --  also called from the version of Put that performs I/O to a string,\n-   --  where the starting position depends on the size of the String, and\n-   --  bears no relation to the bounds of Field.\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n+\n+   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   --  T'Size - 1 for the selected Int{32,64}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 18 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+18);\n+   F2 : constant Natural :=\n+          F1 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+9);\n+   F3 : constant Natural :=\n+          F2 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+5);\n+   F4 : constant Natural :=\n+          F3 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+3);\n+   F5 : constant Natural :=\n+          F4 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+2);\n+   F6 : constant Natural :=\n+          F5 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F6;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64} and\n+   --  whose small is Num'Small.\n \n    ---------\n    -- Get --\n@@ -313,8 +215,22 @@ package body Ada.Text_IO.Fixed_IO is\n       Width : Field := 0)\n    is\n       pragma Unsuppress (Range_Check);\n+\n    begin\n-      Aux.Get (File, Long_Long_Float (Item), Width);\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -323,11 +239,8 @@ package body Ada.Text_IO.Fixed_IO is\n      (Item  : out Num;\n       Width : Field := 0)\n    is\n-      pragma Unsuppress (Range_Check);\n    begin\n-      Aux.Get (Current_In, Long_Long_Float (Item), Width);\n-   exception\n-      when Constraint_Error => raise Data_Error;\n+      Get (Current_Input, Item, Width);\n    end Get;\n \n    procedure Get\n@@ -336,8 +249,22 @@ package body Ada.Text_IO.Fixed_IO is\n       Last : out Positive)\n    is\n       pragma Unsuppress (Range_Check);\n+\n    begin\n-      Aux.Gets (From, Long_Long_Float (Item), Last);\n+      if not Exact then\n+         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (From, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (From, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -353,11 +280,20 @@ package body Ada.Text_IO.Fixed_IO is\n       Aft  : Field := Default_Aft;\n       Exp  : Field := Default_Exp)\n    is\n-      S    : String (1 .. Fore + Aft + Exp + Extra_Layout_Space);\n-      Last : Natural;\n    begin\n-      Put (S, Last, Item, Fore, Aft, Exp);\n-      Generic_Aux.Put_Item (File, S (1 .. Last));\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n    end Put;\n \n    procedure Put\n@@ -366,11 +302,8 @@ package body Ada.Text_IO.Fixed_IO is\n       Aft  : Field := Default_Aft;\n       Exp  : Field := Default_Exp)\n    is\n-      S    : String (1 .. Fore + Aft + Exp + Extra_Layout_Space);\n-      Last : Natural;\n    begin\n-      Put (S, Last, Item, Fore, Aft, Exp);\n-      Generic_Aux.Put_Item (Text_IO.Current_Out, S (1 .. Last));\n+      Put (Current_Out, Item, Fore, Aft, Exp);\n    end Put;\n \n    procedure Put\n@@ -379,332 +312,20 @@ package body Ada.Text_IO.Fixed_IO is\n       Aft  : Field := Default_Aft;\n       Exp  : Field := Default_Exp)\n    is\n-      Fore : constant Integer :=\n-        To'Length\n-          - 1                      -- Decimal point\n-          - Field'Max (1, Aft)     -- Decimal part\n-          - Boolean'Pos (Exp /= 0) -- Exponent indicator\n-          - Exp;                   -- Exponent\n-\n-      Last : Natural;\n-\n-   begin\n-      if Fore - Boolean'Pos (Item < 0.0) < 1 then\n-         raise Layout_Error;\n-      end if;\n-\n-      Put (To, Last, Item, Fore, Aft, Exp);\n-\n-      if Last /= To'Last then\n-         raise Layout_Error;\n-      end if;\n-   end Put;\n-\n-   procedure Put\n-     (To   : out String;\n-      Last : out Natural;\n-      Item : Num;\n-      Fore : Integer;\n-      Aft  : Field;\n-      Exp  : Field)\n-   is\n-      subtype Digit is Int64 range 0 .. 9;\n-\n-      X   : constant Int64   := Int64'Integer_Value (Item);\n-      A   : constant Field   := Field'Max (Aft, 1);\n-      Neg : constant Boolean := (Item < 0.0);\n-      Pos : Integer := 0;  -- Next digit X has value X * 10.0**Pos;\n-\n-      procedure Put_Character (C : Character);\n-      pragma Inline (Put_Character);\n-      --  Add C to the output string To, updating Last\n-\n-      procedure Put_Digit (X : Digit);\n-      --  Add digit X to the output string (going from left to right), updating\n-      --  Last and Pos, and inserting the sign, leading zeros or a decimal\n-      --  point when necessary. After outputting the first digit, Pos must not\n-      --  be changed outside Put_Digit anymore.\n-\n-      procedure Put_Int64 (X : Int64; Scale : Integer);\n-      --  Output the decimal number abs X * 10**Scale\n-\n-      procedure Put_Scaled\n-        (X, Y, Z : Int64;\n-         A       : Field;\n-         E       : Integer);\n-      --  Output the decimal number (X * Y / Z) * 10**E, producing A digits\n-      --  after the decimal point and rounding the final digit. The value\n-      --  X * Y / Z is computed with full precision, but must be in the\n-      --  range of Int64.\n-\n-      -------------------\n-      -- Put_Character --\n-      -------------------\n-\n-      procedure Put_Character (C : Character) is\n-      begin\n-         Last := Last + 1;\n-\n-         --  Never put a character outside of string To. Exception Layout_Error\n-         --  will be raised later if Last is greater than To'Last.\n-\n-         if Last <= To'Last then\n-            To (Last) := C;\n-         end if;\n-      end Put_Character;\n-\n-      ---------------\n-      -- Put_Digit --\n-      ---------------\n-\n-      procedure Put_Digit (X : Digit) is\n-         Digs : constant array (Digit) of Character := \"0123456789\";\n-\n-      begin\n-         if Last = To'First - 1 then\n-            if X /= 0 or else Pos <= 0 then\n-\n-               --  Before outputting first digit, include leading space,\n-               --  possible minus sign and, if the first digit is fractional,\n-               --  decimal seperator and leading zeros.\n-\n-               --  The Fore part has Pos + 1 + Boolean'Pos (Neg) characters,\n-               --  if Pos >= 0 and otherwise has a single zero digit plus minus\n-               --  sign if negative. Add leading space if necessary.\n-\n-               for J in Integer'Max (0, Pos) + 2 + Boolean'Pos (Neg) .. Fore\n-               loop\n-                  Put_Character (' ');\n-               end loop;\n-\n-               --  Output minus sign, if number is negative\n-\n-               if Neg then\n-                  Put_Character ('-');\n-               end if;\n-\n-               --  If starting with fractional digit, output leading zeros\n-\n-               if Pos < 0 then\n-                  Put_Character ('0');\n-                  Put_Character ('.');\n-\n-                  for J in Pos .. -2 loop\n-                     Put_Character ('0');\n-                  end loop;\n-               end if;\n-\n-               Put_Character (Digs (X));\n-            end if;\n-\n-         else\n-            --  This is not the first digit to be output, so the only\n-            --  special handling is that for the decimal point\n-\n-            if Pos = -1 then\n-               Put_Character ('.');\n-            end if;\n-\n-            Put_Character (Digs (X));\n-         end if;\n-\n-         Pos := Pos - 1;\n-      end Put_Digit;\n-\n-      ---------------\n-      -- Put_Int64 --\n-      ---------------\n-\n-      procedure Put_Int64 (X : Int64; Scale : Integer) is\n-      begin\n-         if X = 0 then\n-            return;\n-         end if;\n-\n-         if X not in -9 .. 9 then\n-            Put_Int64 (X / 10, Scale + 1);\n-         end if;\n-\n-         --  Use Put_Digit to advance Pos. This fixes a case where the second\n-         --  or later Scaled_Divide would omit leading zeroes, resulting in\n-         --  too few digits produced and a Layout_Error as result.\n-\n-         while Pos > Scale loop\n-            Put_Digit (0);\n-         end loop;\n-\n-         --  If and only if more than one digit is output before the decimal\n-         --  point, pos will be unequal to scale when outputting the first\n-         --  digit.\n-\n-         pragma Assert (Pos = Scale or else Last = To'First - 1);\n-\n-         Pos := Scale;\n-\n-         Put_Digit (abs (X rem 10));\n-      end Put_Int64;\n-\n-      ----------------\n-      -- Put_Scaled --\n-      ----------------\n-\n-      procedure Put_Scaled\n-        (X, Y, Z : Int64;\n-         A       : Field;\n-         E       : Integer)\n-      is\n-         pragma Assert (E >= -Max_Digits);\n-         AA : constant Field := Integer'Max (E + A, 0);\n-         N  : constant Natural := (AA + Max_Digits - 1) / Max_Digits + 1;\n-\n-         Q  : array (0 .. N - 1) of Int64 := (others => 0);\n-         --  Each element of Q has Max_Digits decimal digits, except the\n-         --  last, which has AA rem Max_Digits. Only Q (Q'First) may have an\n-         --  absolute value equal to or larger than 10**Max_Digits. Only the\n-         --  absolute value of the elements is significant, not the sign.\n-\n-         XX : Int64 := X;\n-         YY : Int64 := Y;\n-\n-      begin\n-         for J in Q'Range loop\n-            exit when XX = 0;\n-\n-            if J > 0 then\n-               YY := 10**(Integer'Min (Max_Digits, AA - (J - 1) * Max_Digits));\n-            end if;\n-\n-            Scaled_Divide64 (XX, YY, Z, Q (J), R => XX, Round => False);\n-         end loop;\n-\n-         if -E > A then\n-            pragma Assert (N = 1);\n-\n-            Discard_Extra_Digits : declare\n-               Factor : constant Int64 := 10**(-E - A);\n-\n-            begin\n-               --  The scaling factors were such that the first division\n-               --  produced more digits than requested. So divide away extra\n-               --  digits and compute new remainder for later rounding.\n-\n-               if abs (Q (0) rem Factor) >= Factor / 2 then\n-                  Q (0) := abs (Q (0) / Factor) + 1;\n-               else\n-                  Q (0) := Q (0) / Factor;\n-               end if;\n-\n-               XX := 0;\n-            end Discard_Extra_Digits;\n-         end if;\n-\n-         --  At this point XX is a remainder and we need to determine if the\n-         --  quotient in Q must be rounded away from zero.\n-\n-         --  As XX is less than the divisor, it is safe to take its absolute\n-         --  without chance of overflow. The check to see if XX is at least\n-         --  half the absolute value of the divisor must be done carefully to\n-         --  avoid overflow or lose precision.\n-\n-         XX := abs XX;\n-\n-         if XX >= 2**62\n-            or else (Z < 0 and then (-XX) * 2 <= Z)\n-            or else (Z >= 0 and then XX * 2 >= Z)\n-         then\n-            --  OK, rounding is necessary. As the sign is not significant,\n-            --  take advantage of the fact that an extra negative value will\n-            --  always be available when propagating the carry.\n-\n-            Q (Q'Last) := -abs Q (Q'Last) - 1;\n-\n-            Propagate_Carry :\n-            for J in reverse 1 .. Q'Last loop\n-               if Q (J) = YY or else Q (J) = -YY then\n-                  Q (J) := 0;\n-                  Q (J - 1) := -abs Q (J - 1) - 1;\n-\n-               else\n-                  exit Propagate_Carry;\n-               end if;\n-            end loop Propagate_Carry;\n-         end if;\n-\n-         for J in Q'First .. Q'Last - 1 loop\n-            Put_Int64 (Q (J), E - J * Max_Digits);\n-         end loop;\n-\n-         Put_Int64 (Q (Q'Last), -A);\n-      end Put_Scaled;\n-\n-   --  Start of processing for Put\n-\n    begin\n-      Last := To'First - 1;\n-\n-      if Exp /= 0 then\n-\n-         --  With the Exp format, it is not known how many output digits to\n-         --  generate, as leading zeros must be ignored. Computing too many\n-         --  digits and then truncating the output will not give the closest\n-         --  output, it is necessary to round at the correct digit.\n-\n-         --  The general approach is as follows: as long as no digits have\n-         --  been generated, compute the Aft next digits (without rounding).\n-         --  Once a non-zero digit is generated, determine the exact number\n-         --  of digits remaining and compute them with rounding.\n-\n-         --  Since a large number of iterations might be necessary in case\n-         --  of Aft = 1, the following optimization would be desirable.\n-\n-         --  Count the number Z of leading zero bits in the integer\n-         --  representation of X, and start with producing Aft + Z * 1000 /\n-         --  3322 digits in the first scaled division.\n-\n-         --  However, the floating-point routines are still used now ???\n-\n-         System.Img_Real.Set_Image_Real (Long_Long_Float (Item), To, Last,\n-            Fore, Aft, Exp);\n-         return;\n-      end if;\n-\n-      if Exact then\n-         declare\n-            D : constant Integer := Integer'Min (A, Max_Digits\n-                                                            - (Num'Fore - 1));\n-            Y : constant Int64   := Int64'Min (Int64 (-Num'Small), -1)\n-                                     * 10**Integer'Max (0, D);\n-            Z : constant Int64   := Int64'Min (Int64 (-(1.0 / Num'Small)), -1)\n-                                     * 10**Integer'Max (0, -D);\n-         begin\n-            Put_Scaled (X, Y, Z, A, -D);\n-         end;\n-\n-      else -- not Exact\n-         declare\n-            E : constant Integer := Max_Digits - 1 + Scale;\n-            D : constant Integer := Scale - 1;\n-            Y : constant Int64   := Int64 (-Num'Small * 10.0**E);\n-            Z : constant Int64   := -10**Max_Digits;\n-         begin\n-            Put_Scaled (X, Y, Z, A, -D);\n-         end;\n+      if not Exact then\n+         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n       end if;\n-\n-      --  If only zero digits encountered, unit digit has not been output yet\n-\n-      if Last < To'First then\n-         Pos := 0;\n-\n-      elsif Last > To'Last then\n-         raise Layout_Error; -- Not enough room in the output variable\n-      end if;\n-\n-      --  Always output digits up to the first one after the decimal point\n-\n-      while Pos >= -A loop\n-         Put_Digit (0);\n-      end loop;\n    end Put;\n \n end Ada.Text_IO.Fixed_IO;"}, {"sha": "f164209c3b3927e63d94cae2288f38f613f74a6c", "filename": "gcc/ada/libgnat/a-tifiio__128.adb", "status": "added", "additions": 365, "deletions": 0, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tifiio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,365 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 A D A . T E X T _ I O . F I X E D _ I O                  --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  Fixed point I/O\n+--  ---------------\n+\n+--  The following text documents implementation details of the fixed point\n+--  input/output routines in the GNAT runtime. The first part describes the\n+--  general properties of fixed point types as defined by the Ada standard,\n+--  including the Information Systems Annex.\n+\n+--  Subsequently these are reduced to implementation constraints and the impact\n+--  of these constraints on a few possible approaches to input/output is given.\n+--  Based on this analysis, a specific implementation is selected for use in\n+--  the GNAT runtime. Finally, the chosen algorithm is analyzed numerically in\n+--  order to provide user-level documentation on limits for range and precision\n+--  of fixed point types as well as accuracy of input/output conversions.\n+\n+--  -------------------------------------------\n+--  - General Properties of Fixed Point Types -\n+--  -------------------------------------------\n+\n+--  Operations on fixed point types, other than input/output, are not important\n+--  for the purpose of this document. Only the set of values that a fixed point\n+--  type can represent and the input/output operations are significant.\n+\n+--  Values\n+--  ------\n+\n+--  The set of values of a fixed point type comprise the integral multiples of\n+--  a number called the small of the type. The small can be either a power of\n+--  two, a power of ten or (if the implementation allows) an arbitrary strictly\n+--  positive real value.\n+\n+--  Implementations need to support ordinary fixed point types with a precision\n+--  of at least 24 bits, and (in order to comply with the Information Systems\n+--  Annex) decimal fixed point types with at least 18 digits. For the rest, no\n+--  requirements exist for the minimal small and range that must be supported.\n+\n+--  Operations\n+--  ----------\n+\n+--  'Image and 'Wide_Image (see RM 3.5(34))\n+\n+--          These attributes return a decimal real literal best approximating\n+--          the value (rounded away from zero if halfway between) with a\n+--          single leading character that is either a minus sign or a space,\n+--          one or more digits before the decimal point (with no redundant\n+--          leading zeros), a decimal point, and N digits after the decimal\n+--          point. For a subtype S, the value of N is S'Aft, the smallest\n+--          positive integer such that (10**N)*S'Delta is greater or equal to\n+--          one, see RM 3.5.10(5).\n+\n+--          For an arbitrary small, this means large number arithmetic needs\n+--          to be performed.\n+\n+--  Put (see RM A.10.9(22-26))\n+\n+--          The requirements for Put add no extra constraints over the image\n+--          attributes, although it would be nice to be able to output more\n+--          than S'Aft digits after the decimal point for values of subtype S.\n+\n+--  'Value and 'Wide_Value attribute (RM 3.5(40-55))\n+\n+--          Since the input can be given in any base in the range 2..16,\n+--          accurate conversion to a fixed point number may require\n+--          arbitrary precision arithmetic if there is no limit on the\n+--          magnitude of the small of the fixed point type.\n+\n+--  Get (see RM A.10.9(12-21))\n+\n+--          The requirements for Get are identical to those of the Value\n+--          attribute.\n+\n+--  ------------------------------\n+--  - Implementation Constraints -\n+--  ------------------------------\n+\n+--  The requirements listed above for the input/output operations lead to\n+--  significant complexity, if no constraints are put on supported smalls.\n+\n+--  Implementation Strategies\n+--  -------------------------\n+\n+--  * Floating point arithmetic\n+--  * Arbitrary-precision integer arithmetic\n+--  * Fixed-precision integer arithmetic\n+\n+--  Although it seems convenient to convert fixed point numbers to floating\n+--  point and then print them, this leads to a number of restrictions.\n+--  The first one is precision. The widest floating-point type generally\n+--  available has 53 bits of mantissa. This means that Fine_Delta cannot\n+--  be less than 2.0**(-53).\n+\n+--  In GNAT, Fine_Delta is 2.0**(-63), and Duration for example is a 64-bit\n+--  type. This means that a floating-point type with 63 bits of mantissa needs\n+--  to be used, which is only generally available on the x86 architecture. It\n+--  would still be possible to use multi-precision floating point to perform\n+--  calculations using longer mantissas, but this is a much harder approach.\n+\n+--  The base conversions needed for input/output of (non-decimal) fixed point\n+--  types can be seen as pairs of integer multiplications and divisions.\n+\n+--  Arbitrary-precision integer arithmetic would be suitable for the job at\n+--  hand, but has the drawback that it is very heavy implementation-wise.\n+--  Especially in embedded systems, where fixed point types are often used,\n+--  it may not be desirable to require large amounts of storage and time\n+--  for fixed I/O operations.\n+\n+--  Fixed-precision integer arithmetic has the advantage of simplicity and\n+--  speed. For the most common fixed point types this would be a perfect\n+--  solution. The downside however may be a too limited set of acceptable\n+--  fixed point types.\n+\n+with Interfaces;\n+with Ada.Text_IO.Fixed_Aux;\n+with Ada.Text_IO.Float_Aux;\n+with System.Img_Fixed_32;  use System.Img_Fixed_32;\n+with System.Img_Fixed_64;  use System.Img_Fixed_64;\n+with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Val_Fixed_32;  use System.Val_Fixed_32;\n+with System.Val_Fixed_64;  use System.Val_Fixed_64;\n+with System.Val_Fixed_128; use System.Val_Fixed_128;\n+\n+package body Ada.Text_IO.Fixed_IO is\n+\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n+\n+   subtype Int32  is Interfaces.Integer_32;\n+   subtype Int64  is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n+\n+   package Aux64 is new\n+     Ada.Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n+\n+   package Aux128 is new\n+     Ada.Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n+\n+   Exact : constant Boolean :=\n+     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n+     and then Num'Small >= 2.0**(-127)\n+     and then Num'Small <= 2.0**127;\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   Need_128 : constant Boolean :=\n+     Num'Object_Size > 64\n+       or else Num'Small > 2.0**63\n+       or else Num'Small < 2.0**(-63);\n+   --  Throughout this generic body, we distinguish between the cases where\n+   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n+   --  type Int128 is needed. These boolean constants are used to test for\n+   --  these cases and since they are constant, only code for the relevant\n+   --  case will be really included in the instance.\n+\n+   E : constant Natural :=\n+         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+   --  T'Size - 1 for the selected Int{32,64,128}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 38 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+38);\n+   F2 : constant Natural :=\n+          F1 + 19 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+19);\n+   F3 : constant Natural :=\n+          F2 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+9);\n+   F4 : constant Natural :=\n+          F3 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+5);\n+   F5 : constant Natural :=\n+          F4 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+3);\n+   F6 : constant Natural :=\n+          F5 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+2);\n+   F7 : constant Natural :=\n+          F6 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F6) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F7;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64,128} and\n+   --  whose small is Num'Small.\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Get (File, Width,\n+                                Int128 (-Float'Ceiling (Num'Small)),\n+                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Gets (From, Long_Long_Float (Item), Last);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Gets (From, Last,\n+                                 Int128 (-Float'Ceiling (Num'Small)),\n+                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (From, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (From, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     Int128 (-Float'Ceiling (Num'Small)),\n+                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Out, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if not Exact then\n+         Float_Aux.Puts (To, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Puts (To, Int128'Integer_Value (Item), Aft, Exp,\n+                      Int128 (-Float'Ceiling (Num'Small)),\n+                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                      For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Puts (To, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (To, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      end if;\n+   end Put;\n+\n+end Ada.Text_IO.Fixed_IO;"}, {"sha": "ddb52a5eebf178a6ac98ee1bacb744b6cb2e3f52", "filename": "gcc/ada/libgnat/a-tiflau.adb", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-tiflau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -47,18 +47,18 @@ package body Ada.Text_IO.Float_Aux is\n    is\n       Buf  : String (1 .. Field'Last);\n       Stop : Integer := 0;\n-      Ptr  : aliased Integer := 1;\n+      Ptr  : aliased Integer;\n \n    begin\n       if Width /= 0 then\n          Load_Width (File, Width, Buf, Stop);\n          String_Skip (Buf, Ptr);\n       else\n          Load_Real (File, Buf, Stop);\n+         Ptr := 1;\n       end if;\n \n       Item := Scan_Real (Buf, Ptr'Access, Stop);\n-\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n    end Get;\n \n@@ -79,8 +79,7 @@ package body Ada.Text_IO.Float_Aux is\n       Last := Pos - 1;\n \n    exception\n-      when Constraint_Error =>\n-         raise Data_Error;\n+      when Constraint_Error => raise Data_Error;\n    end Gets;\n \n    ---------------"}, {"sha": "268ba4da606e9220118d2588136b90fc78c29c60", "filename": "gcc/ada/libgnat/a-wtdeau.adb", "status": "modified", "additions": 39, "deletions": 152, "changes": 191, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtdeau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -32,54 +32,21 @@\n with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n with Ada.Wide_Text_IO.Float_Aux;   use Ada.Wide_Text_IO.Float_Aux;\n \n-with System.Img_Dec; use System.Img_Dec;\n-with System.Img_LLD; use System.Img_LLD;\n-with System.Val_Dec; use System.Val_Dec;\n-with System.Val_LLD; use System.Val_LLD;\n-\n package body Ada.Wide_Text_IO.Decimal_Aux is\n \n-   -------------\n-   -- Get_Dec --\n-   -------------\n-\n-   function Get_Dec\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Integer\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer;\n-      Stop : Integer := 0;\n-      Item : Integer;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Real (File, Buf, Stop);\n-         Ptr := 1;\n-      end if;\n-\n-      Item := Scan_Decimal (Buf, Ptr'Access, Stop, Scale);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-      return Item;\n-   end Get_Dec;\n-\n-   -------------\n-   -- Get_LLD --\n-   -------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   function Get_LLD\n+   function Get\n      (File  : File_Type;\n       Width : Field;\n-      Scale : Integer) return Long_Long_Integer\n+      Scale : Integer) return Int\n    is\n       Buf  : String (1 .. Field'Last);\n       Ptr  : aliased Integer;\n       Stop : Integer := 0;\n-      Item : Long_Long_Integer;\n+      Item : Int;\n \n    begin\n       if Width /= 0 then\n@@ -90,68 +57,42 @@ package body Ada.Wide_Text_IO.Decimal_Aux is\n          Ptr := 1;\n       end if;\n \n-      Item := Scan_Long_Long_Decimal (Buf, Ptr'Access, Stop, Scale);\n+      Item := Scan (Buf, Ptr'Access, Stop, Scale);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n       return Item;\n-   end Get_LLD;\n-\n-   --------------\n-   -- Gets_Dec --\n-   --------------\n-\n-   function Gets_Dec\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer\n-   is\n-      Pos  : aliased Integer;\n-      Item : Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n-      return Item;\n+   end Get;\n \n-   exception\n-      when Constraint_Error =>\n-         Last.all := Pos - 1;\n-         raise Data_Error;\n-\n-   end Gets_Dec;\n+   ----------\n+   -- Gets --\n+   ----------\n \n-   --------------\n-   -- Gets_LLD --\n-   --------------\n-\n-   function Gets_LLD\n+   function Gets\n      (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer\n+      Last  : out Positive;\n+      Scale : Integer) return Int\n    is\n       Pos  : aliased Integer;\n-      Item : Long_Long_Integer;\n+      Item : Int;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n+      Item := Scan (From, Pos'Access, From'Last, Scale);\n+      Last := Pos - 1;\n       return Item;\n \n    exception\n       when Constraint_Error =>\n-         Last.all := Pos - 1;\n+         Last := Pos - 1;\n          raise Data_Error;\n+   end Gets;\n \n-   end Gets_LLD;\n-\n-   -------------\n-   -- Put_Dec --\n-   -------------\n+   ---------\n+   -- Put --\n+   ---------\n \n-   procedure Put_Dec\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n@@ -161,105 +102,51 @@ package body Ada.Wide_Text_IO.Decimal_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Dec;\n+   end Put;\n \n-   -------------\n-   -- Put_LLD --\n-   -------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Put_LLD\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLD;\n-\n-   --------------\n-   -- Puts_Dec --\n-   --------------\n-\n-   procedure Puts_Dec\n+   procedure Puts\n      (To    : out String;\n-      Item  : Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer)\n    is\n-      Buf  : String (1 .. Field'Last);\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n       Fore : Integer;\n       Ptr  : Natural := 0;\n \n    begin\n-      --  Compute Fore, allowing for Aft digits and the decimal dot\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n \n-      Fore := To'Length - Field'Max (1, Aft) - 1;\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n \n-      --  Allow for Exp and two more for E+ or E- if exponent present\n+      --  Allow for Exp and one more for E if exponent present\n \n       if Exp /= 0 then\n-         Fore := Fore - 2 - Exp;\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n       end if;\n \n       --  Make sure we have enough room\n \n-      if Fore < 1 then\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n          raise Layout_Error;\n       end if;\n \n       --  Do the conversion and check length of result\n \n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Dec;\n-\n-   --------------\n-   -- Puts_LLD --\n-   --------------\n-\n-   procedure Puts_LLD\n-     (To    : out String;\n-      Item  : Long_Long_Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Fore : Integer;\n-      Ptr  : Natural := 0;\n-\n-   begin\n-      Fore :=\n-        (if Exp = 0\n-         then To'Length - 1 - Aft\n-         else To'Length - 2 - Aft - Exp);\n-\n-      if Fore < 1 then\n-         raise Layout_Error;\n-      end if;\n-\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLD;\n+   end Puts;\n \n end Ada.Wide_Text_IO.Decimal_Aux;"}, {"sha": "5c0c4d6766a301543696c4c877e4e65fa46715a7", "filename": "gcc/ada/libgnat/a-wtdeau.ads", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtdeau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -29,63 +29,54 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Wide_Text_IO.Decimal_IO\n---  that are shared among separate instantiations of this package. The\n---  routines in the package are identical semantically to those declared\n---  in Wide_Text_IO, except that default values have been supplied by the\n---  generic, and the Num parameter has been replaced by Integer or\n---  Long_Long_Integer, with an additional Scale parameter giving the\n---  value of Num'Scale. In addition the Get routines return the value\n---  rather than store it in an Out parameter.\n+--  This package contains the implementation for Ada.Wide_Text_IO.Decimal_IO.\n+--  Routines in this package are identical semantically to those in Decimal_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there is an\n+--  additional Scale parameter giving the value of Num'Scale. In addition the\n+--  Get routines return the value rather than store it in an Out parameter.\n \n-private package Ada.Wide_Text_IO.Decimal_Aux is\n+private generic\n+   type Int is range <>;\n \n-   function Get_Dec\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Integer;\n+   with function Scan\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Scale : Integer) return Int;\n \n-   function Get_LLD\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Long_Long_Integer;\n+   with procedure Set_Image\n+     (V     : Int;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural);\n \n-   function Gets_Dec\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer;\n+package Ada.Wide_Text_IO.Decimal_Aux is\n \n-   function Gets_LLD\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer;\n-\n-   procedure Put_Dec\n+   function Get\n      (File  : File_Type;\n-      Item  : Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+      Width : Field;\n+      Scale : Integer) return Int;\n \n-   procedure Put_LLD\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);\n \n-   procedure Puts_Dec\n-     (To    : out String;\n-      Item  : Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+   function Gets\n+     (From  : String;\n+      Last  : out Positive;\n+      Scale : Integer) return Int;\n \n-   procedure Puts_LLD\n+   procedure Puts\n      (To    : out String;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);"}, {"sha": "b432cac6ce0a10371c70ca273faa131ae4c6ad3f", "filename": "gcc/ada/libgnat/a-wtdeio.adb", "status": "modified", "additions": 43, "deletions": 25, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtdeio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -30,13 +30,35 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Text_IO.Decimal_Aux;\n-\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n with System.WCh_Con; use System.WCh_Con;\n with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Text_IO.Decimal_IO is\n \n-   package Aux renames Ada.Wide_Text_IO.Decimal_Aux;\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Aux32 is new\n+     Ada.Wide_Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   Need64 : constant Boolean := Num'Size > 32;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n \n    Scale : constant Integer := Num'Scale;\n \n@@ -49,12 +71,15 @@ package body Ada.Wide_Text_IO.Decimal_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      if Num'Size > Integer'Size then\n-         Item := Num'Fixed_Value (Aux.Get_LLD (File, Width, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n       else\n-         Item := Num'Fixed_Value (Aux.Get_Dec (File, Width, Scale));\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n       end if;\n+\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -72,23 +97,19 @@ package body Ada.Wide_Text_IO.Decimal_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if Num'Size > Integer'Size then\n-         --  Item := Num'Fixed_Value\n-         --  should write above, but gets assert error ???\n-         Item := Num\n-                   (Aux.Gets_LLD (S, Last'Unrestricted_Access, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (S, Last, Scale));\n       else\n-         --  Item := Num'Fixed_Value\n-         --  should write above, but gets assert error ???\n-         Item := Num\n-                   (Aux.Gets_Dec (S, Last'Unrestricted_Access, Scale));\n+         Item := Num'Fixed_Value (Aux32.Gets (S, Last, Scale));\n       end if;\n \n    exception\n@@ -107,13 +128,12 @@ package body Ada.Wide_Text_IO.Decimal_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if Num'Size > Integer'Size then\n-         Aux.Put_LLD\n-           (File, Long_Long_Integer'Integer_Value (Item),\n-            Fore, Aft, Exp, Scale);\n+      if Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       else\n-         Aux.Put_Dec\n-           (File, Integer'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       end if;\n    end Put;\n \n@@ -136,12 +156,10 @@ package body Ada.Wide_Text_IO.Decimal_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if Num'Size > Integer'Size then\n-         Aux.Puts_LLD\n-           (S, Long_Long_Integer'Integer_Value (Item), Aft, Exp, Scale);\n-\n+      if Need64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp, Scale);\n       else\n-         Aux.Puts_Dec (S, Integer'Integer_Value (Item), Aft, Exp, Scale);\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp, Scale);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "6e23e083ecb30c7095fba0f1c5d1d8ecb24afe8c", "filename": "gcc/ada/libgnat/a-wtdeio__128.adb", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtdeio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtdeio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,190 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--           A D A . W I D E _ T E X T _ I O . D E C I M A L _ I O          --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO.Decimal_Aux;\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Img_Decimal_128; use System.Img_Decimal_128;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n+with System.Val_Decimal_128; use System.Val_Decimal_128;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Text_IO.Decimal_IO is\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Wide_Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   package Aux128 is new\n+     Ada.Wide_Text_IO.Decimal_Aux\n+       (Int128,\n+        Scan_Decimal128,\n+        Set_Image_Decimal128);\n+\n+   Need64  : constant Boolean := Num'Size > 32;\n+   Need128 : constant Boolean := Num'Size > 64;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable, where type Int64 is acceptable and where an Int128\n+   --  is needed. These boolean constants are used to test for these cases and\n+   --  since it is a constant, only code for the relevant case will be included\n+   --  in the instance.\n+\n+   Scale : constant Integer := Num'Scale;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Get (File, Width, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Gets (S, Last, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (S, Last, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Gets (S, Last, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if Need128 then\n+         Aux128.Put\n+           (File, Int128'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      else\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Output, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp, Scale);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp, Scale);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Text_IO.Decimal_IO;"}, {"sha": "d4a153413af5288f3f3ec319cdad6faaf5f3cccd", "filename": "gcc/ada/libgnat/a-wtfiau.adb", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,160 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . W I D E _ T E X T _ I O . F I X E D _ I O            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Text_IO.Generic_Aux; use Ada.Wide_Text_IO.Generic_Aux;\n+with Ada.Wide_Text_IO.Float_Aux;   use Ada.Wide_Text_IO.Float_Aux;\n+\n+package body Ada.Wide_Text_IO.Fixed_Aux is\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int\n+   is\n+      Buf  : String (1 .. Field'Last);\n+      Ptr  : aliased Integer;\n+      Stop : Integer := 0;\n+      Item : Int;\n+\n+   begin\n+      if Width /= 0 then\n+         Load_Width (File, Width, Buf, Stop);\n+         String_Skip (Buf, Ptr);\n+      else\n+         Load_Real (File, Buf, Stop);\n+         Ptr := 1;\n+      end if;\n+\n+      Item := Scan (Buf, Ptr'Access, Stop, Num, Den);\n+      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n+      return Item;\n+   end Get;\n+\n+   ----------\n+   -- Gets --\n+   ----------\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int\n+   is\n+      Pos  : aliased Integer;\n+      Item : Int;\n+\n+   begin\n+      String_Skip (From, Pos);\n+      Item := Scan (From, Pos'Access, From'Last, Num, Den);\n+      Last := Pos - 1;\n+      return Item;\n+\n+   exception\n+      when Constraint_Error =>\n+         Last := Pos - 1;\n+         raise Data_Error;\n+   end Gets;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf : String (1 .. Field'Last);\n+      Ptr : Natural := 0;\n+\n+   begin\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+      Put_Item (File, Buf (1 .. Ptr));\n+   end Put;\n+\n+   ----------\n+   -- Puts --\n+   ----------\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n+      Fore : Integer;\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n+\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n+\n+      --  Allow for Exp and one more for E if exponent present\n+\n+      if Exp /= 0 then\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n+      end if;\n+\n+      --  Make sure we have enough room\n+\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n+         raise Layout_Error;\n+      end if;\n+\n+      --  Do the conversion and check length of result\n+\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+\n+      if Ptr > To'Length then\n+         raise Layout_Error;\n+      else\n+         To := Buf (1 .. Ptr);\n+      end if;\n+   end Puts;\n+\n+end Ada.Wide_Text_IO.Fixed_Aux;"}, {"sha": "f487931d1f354630ed27dcd13fbc450de67c1ae1", "filename": "gcc/ada/libgnat/a-wtfiau.ads", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . W I D E _ T E X T _ I O . F I X E D _ I O            --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the implementation for Ada.Wide_Text_IO.Fixed_IO.\n+--  Routines in this package are identical semantically to those in Fixed_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there are\n+--  additional Num and Den parameters giving the value of Num'Small, as well\n+--  as For0 and Aft0 giving some properties of Num'Small. In addition the Get\n+--  routines return the value rather than store it in an Out parameter.\n+\n+private generic\n+   type Int is range <>;\n+\n+   with function Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int;\n+      Den : Int) return Int;\n+\n+   with procedure Set_Image\n+     (V    : Int;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n+package Ada.Wide_Text_IO.Fixed_Aux is\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int;\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int;\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+end Ada.Wide_Text_IO.Fixed_Aux;"}, {"sha": "00990af87d26c783ae4ccc97ac37422a17b15837", "filename": "gcc/ada/libgnat/a-wtfiio.adb", "status": "modified", "additions": 119, "deletions": 8, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---     A D A . T E X T _ I O . W I D E _ T E X T _ I O . F I X E D _ I O    --\n+--             A D A . W I D E _ T E X T _ I O . F I X E D _ I O            --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -29,13 +29,72 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Interfaces;\n+with Ada.Wide_Text_IO.Fixed_Aux;\n with Ada.Wide_Text_IO.Float_Aux;\n-with System.WCh_Con; use System.WCh_Con;\n-with System.WCh_WtS; use System.WCh_WtS;\n+with System.Img_Fixed_32; use System.Img_Fixed_32;\n+with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Val_Fixed_32; use System.Val_Fixed_32;\n+with System.Val_Fixed_64; use System.Val_Fixed_64;\n+with System.WCh_Con;      use System.WCh_Con;\n+with System.WCh_WtS;      use System.WCh_WtS;\n \n package body Ada.Wide_Text_IO.Fixed_IO is\n \n-   package Aux renames Ada.Wide_Text_IO.Float_Aux;\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Aux32 is new\n+     Ada.Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n+\n+   Exact : constant Boolean :=\n+     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n+     and then Num'Small >= 2.0**(-63)\n+     and then Num'Small <= 2.0**63;\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n+\n+   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   --  T'Size - 1 for the selected Int{32,64}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 18 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+18);\n+   F2 : constant Natural :=\n+          F1 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+9);\n+   F3 : constant Natural :=\n+          F2 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+5);\n+   F4 : constant Natural :=\n+          F3 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+3);\n+   F5 : constant Natural :=\n+          F4 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+2);\n+   F6 : constant Natural :=\n+          F5 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F6;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64} and\n+   --  whose small is Num'Small.\n \n    ---------\n    -- Get --\n@@ -46,8 +105,22 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      Aux.Get (File, Long_Long_Float (Item), Width);\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n \n    exception\n       when Constraint_Error => raise Data_Error;\n@@ -66,14 +139,28 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      Aux.Gets (S, Long_Long_Float (Item), Last);\n+      if not Exact then\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (S, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n \n    exception\n       when Constraint_Error => raise Data_Error;\n@@ -91,7 +178,19 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n    end Put;\n \n    procedure Put\n@@ -113,7 +212,19 @@ package body Ada.Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      if not Exact then\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      end if;\n \n       for J in S'Range loop\n          To (J) := Wide_Character'Val (Character'Pos (S (J)));"}, {"sha": "7607d5cccf72ec2c20d6b2a4905c0a7d2b68ead2", "filename": "gcc/ada/libgnat/a-wtfiio__128.adb", "status": "added", "additions": 267, "deletions": 0, "changes": 267, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-wtfiio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,267 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--             A D A . W I D E _ T E X T _ I O . F I X E D _ I O            --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces;\n+with Ada.Wide_Text_IO.Fixed_Aux;\n+with Ada.Wide_Text_IO.Float_Aux;\n+with System.Img_Fixed_32;  use System.Img_Fixed_32;\n+with System.Img_Fixed_64;  use System.Img_Fixed_64;\n+with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Val_Fixed_32;  use System.Val_Fixed_32;\n+with System.Val_Fixed_64;  use System.Val_Fixed_64;\n+with System.Val_Fixed_128; use System.Val_Fixed_128;\n+with System.WCh_Con;       use System.WCh_Con;\n+with System.WCh_WtS;       use System.WCh_WtS;\n+\n+package body Ada.Wide_Text_IO.Fixed_IO is\n+\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n+\n+   subtype Int32  is Interfaces.Integer_32;\n+   subtype Int64  is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n+\n+   package Aux128 is new\n+     Ada.Wide_Text_IO.Fixed_Aux (Int128, Scan_Fixed128, Set_Image_Fixed128);\n+\n+   Exact : constant Boolean :=\n+     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n+     and then Num'Small >= 2.0**(-127)\n+     and then Num'Small <= 2.0**127;\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   Need_128 : constant Boolean :=\n+     Num'Object_Size > 64\n+       or else Num'Small > 2.0**63\n+       or else Num'Small < 2.0**(-63);\n+   --  Throughout this generic body, we distinguish between the cases where\n+   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n+   --  type Int128 is needed. These boolean constants are used to test for\n+   --  these cases and since they are constant, only code for the relevant\n+   --  case will be really included in the instance.\n+\n+   E : constant Natural :=\n+         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+   --  T'Size - 1 for the selected Int{32,64,128}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 38 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+38);\n+   F2 : constant Natural :=\n+          F1 + 19 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+19);\n+   F3 : constant Natural :=\n+          F2 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+9);\n+   F4 : constant Natural :=\n+          F3 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+5);\n+   F5 : constant Natural :=\n+          F4 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+3);\n+   F6 : constant Natural :=\n+          F5 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+2);\n+   F7 : constant Natural :=\n+          F6 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F6) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F7;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64,128} and\n+   --  whose small is Num'Small.\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Get (File, Width,\n+                                Int128 (-Float'Ceiling (Num'Small)),\n+                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Gets (S, Last,\n+                                 Int128 (-Float'Ceiling (Num'Small)),\n+                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (S, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     Int128 (-Float'Ceiling (Num'Small)),\n+                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Output, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n+                      Int128 (-Float'Ceiling (Num'Small)),\n+                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                      For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      end if;\n+      for J in S'Range loop\n+         To (J) := Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Text_IO.Fixed_IO;"}, {"sha": "6c2af9f2ce128d572f77ad8e9699239c53327024", "filename": "gcc/ada/libgnat/a-ztdeau.adb", "status": "modified", "additions": 39, "deletions": 150, "changes": 189, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztdeau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -32,54 +32,21 @@\n with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n with Ada.Wide_Wide_Text_IO.Float_Aux;   use Ada.Wide_Wide_Text_IO.Float_Aux;\n \n-with System.Img_Dec; use System.Img_Dec;\n-with System.Img_LLD; use System.Img_LLD;\n-with System.Val_Dec; use System.Val_Dec;\n-with System.Val_LLD; use System.Val_LLD;\n-\n package body Ada.Wide_Wide_Text_IO.Decimal_Aux is\n \n-   -------------\n-   -- Get_Dec --\n-   -------------\n-\n-   function Get_Dec\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Integer\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Ptr  : aliased Integer;\n-      Stop : Integer := 0;\n-      Item : Integer;\n-\n-   begin\n-      if Width /= 0 then\n-         Load_Width (File, Width, Buf, Stop);\n-         String_Skip (Buf, Ptr);\n-      else\n-         Load_Real (File, Buf, Stop);\n-         Ptr := 1;\n-      end if;\n-\n-      Item := Scan_Decimal (Buf, Ptr'Access, Stop, Scale);\n-      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n-      return Item;\n-   end Get_Dec;\n-\n-   -------------\n-   -- Get_LLD --\n-   -------------\n+   ---------\n+   -- Get --\n+   ---------\n \n-   function Get_LLD\n+   function Get\n      (File  : File_Type;\n       Width : Field;\n-      Scale : Integer) return Long_Long_Integer\n+      Scale : Integer) return Int\n    is\n       Buf  : String (1 .. Field'Last);\n       Ptr  : aliased Integer;\n       Stop : Integer := 0;\n-      Item : Long_Long_Integer;\n+      Item : Int;\n \n    begin\n       if Width /= 0 then\n@@ -90,68 +57,42 @@ package body Ada.Wide_Wide_Text_IO.Decimal_Aux is\n          Ptr := 1;\n       end if;\n \n-      Item := Scan_Long_Long_Decimal (Buf, Ptr'Access, Stop, Scale);\n+      Item := Scan (Buf, Ptr'Access, Stop, Scale);\n       Check_End_Of_Field (Buf, Stop, Ptr, Width);\n       return Item;\n-   end Get_LLD;\n-\n-   --------------\n-   -- Gets_Dec --\n-   --------------\n-\n-   function Gets_Dec\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer\n-   is\n-      Pos  : aliased Integer;\n-      Item : Integer;\n-\n-   begin\n-      String_Skip (From, Pos);\n-      Item := Scan_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n-      return Item;\n+   end Get;\n \n-   exception\n-      when Constraint_Error =>\n-         Last.all := Pos - 1;\n-         raise Data_Error;\n-\n-   end Gets_Dec;\n+   ----------\n+   -- Gets --\n+   ----------\n \n-   --------------\n-   -- Gets_LLD --\n-   --------------\n-\n-   function Gets_LLD\n+   function Gets\n      (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer\n+      Last  : out Positive;\n+      Scale : Integer) return Int\n    is\n       Pos  : aliased Integer;\n-      Item : Long_Long_Integer;\n+      Item : Int;\n \n    begin\n       String_Skip (From, Pos);\n-      Item := Scan_Long_Long_Decimal (From, Pos'Access, From'Last, Scale);\n-      Last.all := Pos - 1;\n+      Item := Scan (From, Pos'Access, From'Last, Scale);\n+      Last := Pos - 1;\n       return Item;\n \n    exception\n       when Constraint_Error =>\n-         Last.all := Pos - 1;\n+         Last := Pos - 1;\n          raise Data_Error;\n+   end Gets;\n \n-   end Gets_LLD;\n-\n-   -------------\n-   -- Put_Dec --\n-   -------------\n+   ---------\n+   -- Put --\n+   ---------\n \n-   procedure Put_Dec\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n@@ -161,103 +102,51 @@ package body Ada.Wide_Wide_Text_IO.Decimal_Aux is\n       Ptr : Natural := 0;\n \n    begin\n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n       Put_Item (File, Buf (1 .. Ptr));\n-   end Put_Dec;\n+   end Put;\n \n-   -------------\n-   -- Put_LLD --\n-   -------------\n+   ----------\n+   -- Puts --\n+   ----------\n \n-   procedure Put_LLD\n-     (File  : File_Type;\n-      Item  : Long_Long_Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf : String (1 .. Field'Last);\n-      Ptr : Natural := 0;\n-\n-   begin\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-      Put_Item (File, Buf (1 .. Ptr));\n-   end Put_LLD;\n-\n-   --------------\n-   -- Puts_Dec --\n-   --------------\n-\n-   procedure Puts_Dec\n+   procedure Puts\n      (To    : out String;\n-      Item  : Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer)\n    is\n-      Buf  : String (1 .. Field'Last);\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n       Fore : Integer;\n       Ptr  : Natural := 0;\n \n    begin\n-      --  Compute Fore, allowing for Aft digits and the decimal dot\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n \n-      Fore := To'Length - Field'Max (1, Aft) - 1;\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n \n-      --  Allow for Exp and two more for E+ or E- if exponent present\n+      --  Allow for Exp and one more for E if exponent present\n \n       if Exp /= 0 then\n-         Fore := Fore - 2 - Exp;\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n       end if;\n \n       --  Make sure we have enough room\n \n-      if Fore < 1 then\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n          raise Layout_Error;\n       end if;\n \n       --  Do the conversion and check length of result\n \n-      Set_Image_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n-\n-      if Ptr > To'Length then\n-         raise Layout_Error;\n-      else\n-         To := Buf (1 .. Ptr);\n-      end if;\n-   end Puts_Dec;\n-\n-   --------------\n-   -- Puts_LLD --\n-   --------------\n-\n-   procedure Puts_LLD\n-     (To    : out String;\n-      Item  : Long_Long_Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer)\n-   is\n-      Buf  : String (1 .. Field'Last);\n-      Fore : Integer;\n-      Ptr  : Natural := 0;\n-\n-   begin\n-      Fore :=\n-        (if Exp = 0 then To'Length - 1 - Aft else To'Length - 2 - Aft - Exp);\n-\n-      if Fore < 1 then\n-         raise Layout_Error;\n-      end if;\n-\n-      Set_Image_Long_Long_Decimal (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n+      Set_Image (Item, Buf, Ptr, Scale, Fore, Aft, Exp);\n \n       if Ptr > To'Length then\n          raise Layout_Error;\n       else\n          To := Buf (1 .. Ptr);\n       end if;\n-   end Puts_LLD;\n+   end Puts;\n \n end Ada.Wide_Wide_Text_IO.Decimal_Aux;"}, {"sha": "962f47921106d86042581dd9a79cda75e3e4a5d3", "filename": "gcc/ada/libgnat/a-ztdeau.ads", "status": "modified", "additions": 33, "deletions": 42, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztdeau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -29,63 +29,54 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routines for Ada.Wide_Wide_Text_IO.Decimal_IO\n---  that are shared among separate instantiations of this package. The\n---  routines in the package are identical semantically to those declared\n---  in Wide_Wide_Text_IO, except that default values have been supplied by the\n---  generic, and the Num parameter has been replaced by Integer or\n---  Long_Long_Integer, with an additional Scale parameter giving the\n---  value of Num'Scale. In addition the Get routines return the value\n---  rather than store it in an Out parameter.\n+--  This package contains implementation for Ada.Wide_Wide_Text_IO.Decimal_IO\n+--  Routines in this package are identical semantically to those in Decimal_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there is an\n+--  additional Scale parameter giving the value of Num'Scale. In addition the\n+--  Get routines return the value rather than store it in an Out parameter.\n \n-private package Ada.Wide_Wide_Text_IO.Decimal_Aux is\n+private generic\n+   type Int is range <>;\n \n-   function Get_Dec\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Integer;\n+   with function Scan\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Scale : Integer) return Int;\n \n-   function Get_LLD\n-     (File  : File_Type;\n-      Width : Field;\n-      Scale : Integer) return Long_Long_Integer;\n+   with procedure Set_Image\n+     (V     : Int;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural);\n \n-   function Gets_Dec\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Integer;\n+package Ada.Wide_Wide_Text_IO.Decimal_Aux is\n \n-   function Gets_LLD\n-     (From  : String;\n-      Last  : not null access Positive;\n-      Scale : Integer) return Long_Long_Integer;\n-\n-   procedure Put_Dec\n+   function Get\n      (File  : File_Type;\n-      Item  : Integer;\n-      Fore  : Field;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+      Width : Field;\n+      Scale : Integer) return Int;\n \n-   procedure Put_LLD\n+   procedure Put\n      (File  : File_Type;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Fore  : Field;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);\n \n-   procedure Puts_Dec\n-     (To    : out String;\n-      Item  : Integer;\n-      Aft   : Field;\n-      Exp   : Field;\n-      Scale : Integer);\n+   function Gets\n+     (From  : String;\n+      Last  : out Positive;\n+      Scale : Integer) return Int;\n \n-   procedure Puts_LLD\n+   procedure Puts\n      (To    : out String;\n-      Item  : Long_Long_Integer;\n+      Item  : Int;\n       Aft   : Field;\n       Exp   : Field;\n       Scale : Integer);"}, {"sha": "cd269149734e93c91198bf0248253539fc4156fd", "filename": "gcc/ada/libgnat/a-ztdeio.adb", "status": "modified", "additions": 43, "deletions": 34, "changes": 77, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztdeio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -30,13 +30,35 @@\n ------------------------------------------------------------------------------\n \n with Ada.Wide_Wide_Text_IO.Decimal_Aux;\n-\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n with System.WCh_Con; use System.WCh_Con;\n with System.WCh_WtS; use System.WCh_WtS;\n \n package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n \n-   package Aux renames Ada.Wide_Wide_Text_IO.Decimal_Aux;\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Aux32 is new\n+     Ada.Wide_Wide_Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Wide_Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   Need64 : constant Boolean := Num'Size > 32;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n \n    Scale : constant Integer := Num'Scale;\n \n@@ -49,12 +71,15 @@ package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      if Num'Size > Integer'Size then\n-         Item := Num'Fixed_Value (Aux.Get_LLD (File, Width, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n       else\n-         Item := Num'Fixed_Value (Aux.Get_Dec (File, Width, Scale));\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n       end if;\n+\n    exception\n       when Constraint_Error => raise Data_Error;\n    end Get;\n@@ -72,23 +97,19 @@ package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      if Num'Size > Integer'Size then\n-         --  Item := Num'Fixed_Value\n-         --  should write above, but gets assert error ???\n-         Item := Num\n-                   (Aux.Gets_LLD (S, Last'Unrestricted_Access, Scale));\n+      if Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (S, Last, Scale));\n       else\n-         --  Item := Num'Fixed_Value\n-         --  should write above, but gets assert error ???\n-         Item := Num\n-                   (Aux.Gets_Dec (S, Last'Unrestricted_Access, Scale));\n+         Item := Num'Fixed_Value (Aux32.Gets (S, Last, Scale));\n       end if;\n \n    exception\n@@ -107,18 +128,12 @@ package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      if Num'Size > Integer'Size then\n-         Aux.Put_LLD\n---           (File, Long_Long_Integer'Integer_Value (Item),\n---  ???\n-           (File, Long_Long_Integer (Item),\n-            Fore, Aft, Exp, Scale);\n+      if Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       else\n-         Aux.Put_Dec\n---           (File, Integer'Integer_Value (Item), Fore, Aft, Exp, Scale);\n---  ???\n-           (File, Integer (Item), Fore, Aft, Exp, Scale);\n-\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n       end if;\n    end Put;\n \n@@ -141,16 +156,10 @@ package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      if Num'Size > Integer'Size then\n---       Aux.Puts_LLD\n---         (S, Long_Long_Integer'Integer_Value (Item), Aft, Exp, Scale);\n---  ???\n-         Aux.Puts_LLD\n-           (S, Long_Long_Integer (Item), Aft, Exp, Scale);\n+      if Need64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp, Scale);\n       else\n---       Aux.Puts_Dec (S, Integer'Integer_Value (Item), Aft, Exp, Scale);\n---  ???\n-         Aux.Puts_Dec (S, Integer (Item), Aft, Exp, Scale);\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp, Scale);\n       end if;\n \n       for J in S'Range loop"}, {"sha": "e160a01c85d3c983993238117bb48e0fbc525a30", "filename": "gcc/ada/libgnat/a-ztdeio__128.adb", "status": "added", "additions": 190, "deletions": 0, "changes": 190, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztdeio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztdeio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,190 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--      A D A . W I D E _ W I D E _ T E X T _ I O . D E C I M A L _ I O     --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO.Decimal_Aux;\n+with System.Img_Decimal_32;  use System.Img_Decimal_32;\n+with System.Img_Decimal_64;  use System.Img_Decimal_64;\n+with System.Img_Decimal_128; use System.Img_Decimal_128;\n+with System.Val_Decimal_32;  use System.Val_Decimal_32;\n+with System.Val_Decimal_64;  use System.Val_Decimal_64;\n+with System.Val_Decimal_128; use System.Val_Decimal_128;\n+with System.WCh_Con;  use System.WCh_Con;\n+with System.WCh_WtS;  use System.WCh_WtS;\n+\n+package body Ada.Wide_Wide_Text_IO.Decimal_IO is\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Wide_Wide_Text_IO.Decimal_Aux\n+       (Int32,\n+        Scan_Decimal32,\n+        Set_Image_Decimal32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Wide_Text_IO.Decimal_Aux\n+       (Int64,\n+        Scan_Decimal64,\n+        Set_Image_Decimal64);\n+\n+   package Aux128 is new\n+     Ada.Wide_Wide_Text_IO.Decimal_Aux\n+       (Int128,\n+        Scan_Decimal128,\n+        Set_Image_Decimal128);\n+\n+   Need64  : constant Boolean := Num'Size > 32;\n+   Need128 : constant Boolean := Num'Size > 64;\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable, where type Int64 is acceptable and where an Int128\n+   --  is needed. These boolean constants are used to test for these cases and\n+   --  since it is a constant, only code for the relevant case will be included\n+   --  in the instance.\n+\n+   Scale : constant Integer := Num'Scale;\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Get (File, Width, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Get (File, Width, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Get (File, Width, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if Need128 then\n+         Item := Num'Fixed_Value (Aux128.Gets (S, Last, Scale));\n+      elsif Need64 then\n+         Item := Num'Fixed_Value (Aux64.Gets (S, Last, Scale));\n+      else\n+         Item := Num'Fixed_Value (Aux32.Gets (S, Last, Scale));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if Need128 then\n+         Aux128.Put\n+           (File, Int128'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Put\n+           (File, Int64'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      else\n+         Aux32.Put\n+           (File, Int32'Integer_Value (Item), Fore, Aft, Exp, Scale);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Output, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_Wide_String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if Need128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp, Scale);\n+      elsif Need64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp, Scale);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp, Scale);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Wide_Text_IO.Decimal_IO;"}, {"sha": "f26a16a41ae1f781b16f29c3b9bc1790975b3684", "filename": "gcc/ada/libgnat/a-ztfiau.adb", "status": "added", "additions": 160, "deletions": 0, "changes": 160, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiau.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiau.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiau.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,160 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--        A D A . W I D E _ W I D E _ T E X T _ I O . F I X E D _ I O       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Wide_Wide_Text_IO.Generic_Aux; use Ada.Wide_Wide_Text_IO.Generic_Aux;\n+with Ada.Wide_Wide_Text_IO.Float_Aux;   use Ada.Wide_Wide_Text_IO.Float_Aux;\n+\n+package body Ada.Wide_Wide_Text_IO.Fixed_Aux is\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int\n+   is\n+      Buf  : String (1 .. Field'Last);\n+      Ptr  : aliased Integer;\n+      Stop : Integer := 0;\n+      Item : Int;\n+\n+   begin\n+      if Width /= 0 then\n+         Load_Width (File, Width, Buf, Stop);\n+         String_Skip (Buf, Ptr);\n+      else\n+         Load_Real (File, Buf, Stop);\n+         Ptr := 1;\n+      end if;\n+\n+      Item := Scan (Buf, Ptr'Access, Stop, Num, Den);\n+      Check_End_Of_Field (Buf, Stop, Ptr, Width);\n+      return Item;\n+   end Get;\n+\n+   ----------\n+   -- Gets --\n+   ----------\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int\n+   is\n+      Pos  : aliased Integer;\n+      Item : Int;\n+\n+   begin\n+      String_Skip (From, Pos);\n+      Item := Scan (From, Pos'Access, From'Last, Num, Den);\n+      Last := Pos - 1;\n+      return Item;\n+\n+   exception\n+      when Constraint_Error =>\n+         Last := Pos - 1;\n+         raise Data_Error;\n+   end Gets;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf : String (1 .. Field'Last);\n+      Ptr : Natural := 0;\n+\n+   begin\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+      Put_Item (File, Buf (1 .. Ptr));\n+   end Put;\n+\n+   ----------\n+   -- Puts --\n+   ----------\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      Buf  : String (1 .. Positive'Max (Field'Last, To'Length));\n+      Fore : Integer;\n+      Ptr  : Natural := 0;\n+\n+   begin\n+      --  Compute Fore, allowing for the decimal dot and Aft digits\n+\n+      Fore := To'Length - 1 - Field'Max (1, Aft);\n+\n+      --  Allow for Exp and one more for E if exponent present\n+\n+      if Exp /= 0 then\n+         Fore := Fore - 1 - Field'Max (2, Exp);\n+      end if;\n+\n+      --  Make sure we have enough room\n+\n+      if Fore < 1 + Boolean'Pos (Item < 0) then\n+         raise Layout_Error;\n+      end if;\n+\n+      --  Do the conversion and check length of result\n+\n+      Set_Image (Item, Buf, Ptr, Num, Den, For0, Aft0, Fore, Aft, Exp);\n+\n+      if Ptr > To'Length then\n+         raise Layout_Error;\n+      else\n+         To := Buf (1 .. Ptr);\n+      end if;\n+   end Puts;\n+\n+end Ada.Wide_Wide_Text_IO.Fixed_Aux;"}, {"sha": "aac4e42648136e5fa8f4645c892e9faa6dfca3dc", "filename": "gcc/ada/libgnat/a-ztfiau.ads", "status": "added", "additions": 97, "deletions": 0, "changes": 97, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiau.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiau.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiau.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,97 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--        A D A . W I D E _ W I D E _ T E X T _ I O . F I X E D _ I O       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the implementation for Ada.Wide_Wide_Text_IO.Fixed_IO\n+--  Routines in this package are identical semantically to those in Fixed_IO,\n+--  except that the default parameters have been removed because they are\n+--  supplied explicitly by the calls from within these units, and there are\n+--  additional Num and Den parameters giving the value of Num'Small, as well\n+--  as For0 and Aft0 giving some properties of Num'Small. In addition the Get\n+--  routines return the value rather than store it in an Out parameter.\n+\n+private generic\n+   type Int is range <>;\n+\n+   with function Scan\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int;\n+      Den : Int) return Int;\n+\n+   with procedure Set_Image\n+     (V    : Int;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+\n+package Ada.Wide_Wide_Text_IO.Fixed_Aux is\n+\n+   function Get\n+     (File  : File_Type;\n+      Width : Field;\n+      Num   : Int;\n+      Den   : Int) return Int;\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Int;\n+      Fore : Field;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+   function Gets\n+     (From : String;\n+      Last : out Positive;\n+      Num  : Int;\n+      Den  : Int) return Int;\n+\n+   procedure Puts\n+     (To   : out String;\n+      Item : Int;\n+      Aft  : Field;\n+      Exp  : Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n+\n+end Ada.Wide_Wide_Text_IO.Fixed_Aux;"}, {"sha": "16e552d9733cc81b76079d42e7094b626c4eb320", "filename": "gcc/ada/libgnat/a-ztfiio.adb", "status": "modified", "additions": 119, "deletions": 8, "changes": 127, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---     A D A . T E X T _ I O . W I D E _ T E X T _ I O . F I X E D _ I O    --\n+--        A D A . W I D E _ W I D E _ T E X T _ I O . F I X E D _ I O       --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -29,13 +29,72 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n+with Interfaces;\n+with Ada.Wide_Wide_Text_IO.Fixed_Aux;\n with Ada.Wide_Wide_Text_IO.Float_Aux;\n-with System.WCh_Con; use System.WCh_Con;\n-with System.WCh_WtS; use System.WCh_WtS;\n+with System.Img_Fixed_32; use System.Img_Fixed_32;\n+with System.Img_Fixed_64; use System.Img_Fixed_64;\n+with System.Val_Fixed_32; use System.Val_Fixed_32;\n+with System.Val_Fixed_64; use System.Val_Fixed_64;\n+with System.WCh_Con;      use System.WCh_Con;\n+with System.WCh_WtS;      use System.WCh_WtS;\n \n package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n \n-   package Aux renames Ada.Wide_Wide_Text_IO.Float_Aux;\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Aux32 is new\n+     Ada.Wide_Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n+\n+   Exact : constant Boolean :=\n+     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n+     and then Num'Small >= 2.0**(-63)\n+     and then Num'Small <= 2.0**63;\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   --  Throughout this generic body, we distinguish between the case where type\n+   --  Int32 is acceptable and where type Int64 is needed. This Boolean is used\n+   --  to test for these cases and since it is a constant, only code for the\n+   --  relevant case will be included in the instance.\n+\n+   E : constant Natural := 31 + 32 * Boolean'Pos (Need_64);\n+   --  T'Size - 1 for the selected Int{32,64}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 18 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+18);\n+   F2 : constant Natural :=\n+          F1 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+9);\n+   F3 : constant Natural :=\n+          F2 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+5);\n+   F4 : constant Natural :=\n+          F3 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+3);\n+   F5 : constant Natural :=\n+          F4 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+2);\n+   F6 : constant Natural :=\n+          F5 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F6;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64} and\n+   --  whose small is Num'Small.\n \n    ---------\n    -- Get --\n@@ -46,8 +105,22 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       Item  : out Num;\n       Width : Field := 0)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n    begin\n-      Aux.Get (File, Long_Long_Float (Item), Width);\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n \n    exception\n       when Constraint_Error => raise Data_Error;\n@@ -66,14 +139,28 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       Item : out Num;\n       Last : out Positive)\n    is\n+      pragma Unsuppress (Range_Check);\n+\n       S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n       --  String on which we do the actual conversion. Note that the method\n       --  used for wide character encoding is irrelevant, since if there is\n       --  a character outside the Standard.Character range then the call to\n       --  Aux.Gets will raise Data_Error in any case.\n \n    begin\n-      Aux.Gets (S, Long_Long_Float (Item), Last);\n+      if not Exact then\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (S, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n \n    exception\n       when Constraint_Error => raise Data_Error;\n@@ -91,7 +178,19 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       Exp  : Field := Default_Exp)\n    is\n    begin\n-      Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n    end Put;\n \n    procedure Put\n@@ -113,7 +212,19 @@ package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n       S : String (To'First .. To'Last);\n \n    begin\n-      Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      if not Exact then\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      end if;\n \n       for J in S'Range loop\n          To (J) := Wide_Wide_Character'Val (Character'Pos (S (J)));"}, {"sha": "02ad61372ef4cfcf5163087f0b5834788765f645", "filename": "gcc/ada/libgnat/a-ztfiio__128.adb", "status": "added", "additions": 269, "deletions": 0, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fa-ztfiio__128.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,269 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--        A D A . W I D E _ W I D E _ T E X T _ I O . F I X E D _ I O       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Interfaces;\n+with Ada.Wide_Wide_Text_IO.Fixed_Aux;\n+with Ada.Wide_Wide_Text_IO.Float_Aux;\n+with System.Img_Fixed_32;  use System.Img_Fixed_32;\n+with System.Img_Fixed_64;  use System.Img_Fixed_64;\n+with System.Img_Fixed_128; use System.Img_Fixed_128;\n+with System.Val_Fixed_32;  use System.Val_Fixed_32;\n+with System.Val_Fixed_64;  use System.Val_Fixed_64;\n+with System.Val_Fixed_128; use System.Val_Fixed_128;\n+with System.WCh_Con;       use System.WCh_Con;\n+with System.WCh_WtS;       use System.WCh_WtS;\n+\n+package body Ada.Wide_Wide_Text_IO.Fixed_IO is\n+\n+   --  Note: we still use the floating-point I/O routines for types whose small\n+   --  is not a sufficiently small integer or the reciprocal thereof. This will\n+   --  result in inaccuracies for fixed point types that require more precision\n+   --  than is available in Long_Long_Float.\n+\n+   subtype Int32  is Interfaces.Integer_32;\n+   subtype Int64  is Interfaces.Integer_64;\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Aux32 is new\n+     Ada.Wide_Wide_Text_IO.Fixed_Aux (Int32, Scan_Fixed32, Set_Image_Fixed32);\n+\n+   package Aux64 is new\n+     Ada.Wide_Wide_Text_IO.Fixed_Aux (Int64, Scan_Fixed64, Set_Image_Fixed64);\n+\n+   package Aux128 is new\n+     Ada.Wide_Wide_Text_IO.Fixed_Aux\n+      (Int128, Scan_Fixed128, Set_Image_Fixed128);\n+\n+   Exact : constant Boolean :=\n+     (Float'Floor (Num'Small) = Float'Ceiling (Num'Small)\n+       or else Float'Floor (1.0 / Num'Small) = Float'Ceiling (1.0 / Num'Small))\n+     and then Num'Small >= 2.0**(-127)\n+     and then Num'Small <= 2.0**127;\n+   --  True if the exact algorithm implemented in Fixed_Aux can be used. The\n+   --  condition is a Small which is either an integer or the reciprocal of an\n+   --  integer with the appropriate magnitude.\n+\n+   Need_64 : constant Boolean :=\n+     Num'Object_Size > 32\n+       or else Num'Small > 2.0**31\n+       or else Num'Small < 2.0**(-31);\n+   Need_128 : constant Boolean :=\n+     Num'Object_Size > 64\n+       or else Num'Small > 2.0**63\n+       or else Num'Small < 2.0**(-63);\n+   --  Throughout this generic body, we distinguish between the cases where\n+   --  type Int32 is acceptable, where type Int64 is acceptable, and where\n+   --  type Int128 is needed. These boolean constants are used to test for\n+   --  these cases and since they are constant, only code for the relevant\n+   --  case will be really included in the instance.\n+\n+   E : constant Natural :=\n+         31 + 32 * Boolean'Pos (Need_64) + 64 * Boolean'Pos (Need_128);\n+   --  T'Size - 1 for the selected Int{32,64,128}\n+\n+   F0 : constant Natural := 0;\n+   F1 : constant Natural :=\n+          F0 + 38 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F0) >= 1.0E+38);\n+   F2 : constant Natural :=\n+          F1 + 19 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F1) >= 1.0E+19);\n+   F3 : constant Natural :=\n+          F2 +  9 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F2) >= 1.0E+9);\n+   F4 : constant Natural :=\n+          F3 +  5 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F3) >= 1.0E+5);\n+   F5 : constant Natural :=\n+          F4 +  3 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F4) >= 1.0E+3);\n+   F6 : constant Natural :=\n+          F5 +  2 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F5) >= 1.0E+2);\n+   F7 : constant Natural :=\n+          F6 +  1 * Boolean'Pos (2.0**E * Num'Small * 10.0**(-F6) >= 1.0E+1);\n+   --  Binary search for the number of digits - 1 before the decimal point of\n+   --  the product 2.0**E * Num'Small.\n+\n+   For0 : constant Natural := 2 + F7;\n+   --  Fore value for the fixed point type whose mantissa is Int{32,64,128} and\n+   --  whose small is Num'Small.\n+\n+   ---------\n+   -- Get --\n+   ---------\n+\n+   procedure Get\n+     (File  : File_Type;\n+      Item  : out Num;\n+      Width : Field := 0)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Get (File, Long_Long_Float (Item), Width);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Get (File, Width,\n+                                Int128 (-Float'Ceiling (Num'Small)),\n+                                Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Get (File, Width,\n+                               Int64 (-Float'Ceiling (Num'Small)),\n+                               Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Get (File, Width,\n+                               Int32 (-Float'Ceiling (Num'Small)),\n+                               Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   procedure Get\n+     (Item  : out Num;\n+      Width : Field := 0)\n+   is\n+   begin\n+      Get (Current_Input, Item, Width);\n+   end Get;\n+\n+   procedure Get\n+     (From : Wide_Wide_String;\n+      Item : out Num;\n+      Last : out Positive)\n+   is\n+      pragma Unsuppress (Range_Check);\n+\n+      S : constant String := Wide_Wide_String_To_String (From, WCEM_Upper);\n+      --  String on which we do the actual conversion. Note that the method\n+      --  used for wide character encoding is irrelevant, since if there is\n+      --  a character outside the Standard.Character range then the call to\n+      --  Aux.Gets will raise Data_Error in any case.\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Gets (S, Long_Long_Float (Item), Last);\n+      elsif Need_128 then\n+         Item := Num'Fixed_Value\n+                   (Aux128.Gets (S, Last,\n+                                 Int128 (-Float'Ceiling (Num'Small)),\n+                                 Int128 (-Float'Ceiling (1.0 / Num'Small))));\n+      elsif Need_64 then\n+         Item := Num'Fixed_Value\n+                   (Aux64.Gets (S, Last,\n+                                Int64 (-Float'Ceiling (Num'Small)),\n+                                Int64 (-Float'Ceiling (1.0 / Num'Small))));\n+      else\n+         Item := Num'Fixed_Value\n+                   (Aux32.Gets (S, Last,\n+                                Int32 (-Float'Ceiling (Num'Small)),\n+                                Int32 (-Float'Ceiling (1.0 / Num'Small))));\n+      end if;\n+\n+   exception\n+      when Constraint_Error => raise Data_Error;\n+   end Get;\n+\n+   ---------\n+   -- Put --\n+   ---------\n+\n+   procedure Put\n+     (File : File_Type;\n+      Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      if not Exact then\n+         Float_Aux.Put (File, Long_Long_Float (Item), Fore, Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Put (File, Int128'Integer_Value (Item), Fore, Aft, Exp,\n+                     Int128 (-Float'Ceiling (Num'Small)),\n+                     Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Put (File, Int64'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int64 (-Float'Ceiling (Num'Small)),\n+                    Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      else\n+         Aux32.Put (File, Int32'Integer_Value (Item), Fore, Aft, Exp,\n+                    Int32 (-Float'Ceiling (Num'Small)),\n+                    Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                    For0, Num'Aft);\n+      end if;\n+   end Put;\n+\n+   procedure Put\n+     (Item : Num;\n+      Fore : Field := Default_Fore;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+   begin\n+      Put (Current_Output, Item, Fore, Aft, Exp);\n+   end Put;\n+\n+   procedure Put\n+     (To   : out Wide_Wide_String;\n+      Item : Num;\n+      Aft  : Field := Default_Aft;\n+      Exp  : Field := Default_Exp)\n+   is\n+      S : String (To'First .. To'Last);\n+\n+   begin\n+      if not Exact then\n+         Float_Aux.Puts (S, Long_Long_Float (Item), Aft, Exp);\n+      elsif Need_128 then\n+         Aux128.Puts (S, Int128'Integer_Value (Item), Aft, Exp,\n+                      Int128 (-Float'Ceiling (Num'Small)),\n+                      Int128 (-Float'Ceiling (1.0 / Num'Small)),\n+                      For0, Num'Aft);\n+      elsif Need_64 then\n+         Aux64.Puts (S, Int64'Integer_Value (Item), Aft, Exp,\n+                     Int64 (-Float'Ceiling (Num'Small)),\n+                     Int64 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      else\n+         Aux32.Puts (S, Int32'Integer_Value (Item), Aft, Exp,\n+                     Int32 (-Float'Ceiling (Num'Small)),\n+                     Int32 (-Float'Ceiling (1.0 / Num'Small)),\n+                     For0, Num'Aft);\n+      end if;\n+\n+      for J in S'Range loop\n+         To (J) := Wide_Wide_Character'Val (Character'Pos (S (J)));\n+      end loop;\n+   end Put;\n+\n+end Ada.Wide_Wide_Text_IO.Fixed_IO;"}, {"sha": "9c6693b79a6e27cbc8803db5e2d4cfffef820cc7", "filename": "gcc/ada/libgnat/g-rannum.adb", "status": "modified", "additions": 60, "deletions": 10, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fg-rannum.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fg-rannum.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fg-rannum.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -100,12 +100,37 @@ is\n       Min : Result_Subtype := Default_Min;\n       Max : Result_Subtype := Result_Subtype'Last) return Result_Subtype\n    is\n-      subtype IntV is Integer_64 range\n-        Integer_64'Integer_Value (Min) ..\n-        Integer_64'Integer_Value (Max);\n-      function R is new Random_Discrete (Integer_64, IntV'First);\n    begin\n-      return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+      if Result_Subtype'Base'Size > 64 then\n+         declare\n+            subtype IntV is Integer_128 range\n+              Integer_128'Integer_Value (Min) ..\n+              Integer_128'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_128, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+\n+      elsif Result_Subtype'Base'Size > 32 then\n+         declare\n+            subtype IntV is Integer_64 range\n+              Integer_64'Integer_Value (Min) ..\n+              Integer_64'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_64, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+\n+      else\n+         declare\n+            subtype IntV is Integer_32 range\n+              Integer_32'Integer_Value (Min) ..\n+              Integer_32'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_32, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+      end if;\n    end Random_Decimal_Fixed;\n \n    ---------------------------\n@@ -117,12 +142,37 @@ is\n       Min : Result_Subtype := Default_Min;\n       Max : Result_Subtype := Result_Subtype'Last) return Result_Subtype\n    is\n-      subtype IntV is Integer_64 range\n-        Integer_64'Integer_Value (Min) ..\n-        Integer_64'Integer_Value (Max);\n-      function R is new Random_Discrete (Integer_64, IntV'First);\n    begin\n-      return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+      if Result_Subtype'Base'Size > 64 then\n+         declare\n+            subtype IntV is Integer_128 range\n+              Integer_128'Integer_Value (Min) ..\n+              Integer_128'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_128, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+\n+      elsif Result_Subtype'Base'Size > 32 then\n+         declare\n+            subtype IntV is Integer_64 range\n+              Integer_64'Integer_Value (Min) ..\n+              Integer_64'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_64, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+\n+      else\n+         declare\n+            subtype IntV is Integer_32 range\n+              Integer_32'Integer_Value (Min) ..\n+              Integer_32'Integer_Value (Max);\n+            function R is new Random_Discrete (Integer_32, IntV'First);\n+         begin\n+            return Result_Subtype'Fixed_Value (R (Gen, IntV'First, IntV'Last));\n+         end;\n+      end if;\n    end Random_Ordinary_Fixed;\n \n    ------------"}, {"sha": "742f2e123cfa94433dfd39ec2bdec96ab196e659", "filename": "gcc/ada/libgnat/s-arit32.adb", "status": "added", "additions": 182, "deletions": 0, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-arit32.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-arit32.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit32.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,182 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . A R I T H _ 3 2                       --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with Ada.Unchecked_Conversion;\n+\n+package body System.Arith_32 is\n+\n+   pragma Suppress (Overflow_Check);\n+   pragma Suppress (Range_Check);\n+\n+   subtype Uns32 is Interfaces.Unsigned_32;\n+   subtype Uns64 is Interfaces.Unsigned_64;\n+\n+   use Interfaces;\n+\n+   function To_Int is new Ada.Unchecked_Conversion (Uns32, Int32);\n+\n+   -----------------------\n+   -- Local Subprograms --\n+   -----------------------\n+\n+   function \"abs\" (X : Int32) return Uns32 is\n+     (if X = Int32'First\n+      then 2**31\n+      else Uns32 (Int32'(abs X)));\n+   --  Convert absolute value of X to unsigned. Note that we can't just use\n+   --  the expression of the Else since it overflows for X = Int32'First.\n+\n+   function Hi (A : Uns64) return Uns32 is (Uns32 (Shift_Right (A, 32)));\n+   --  High order half of 64-bit value\n+\n+   function To_Neg_Int (A : Uns32) return Int32;\n+   --  Convert to negative integer equivalent. If the input is in the range\n+   --  0 .. 2**31, then the corresponding nonpositive signed integer (obtained\n+   --  by negating the given value) is returned, otherwise constraint error is\n+   --  raised.\n+\n+   function To_Pos_Int (A : Uns32) return Int32;\n+   --  Convert to positive integer equivalent. If the input is in the range\n+   --  0 .. 2**31 - 1, then the corresponding nonnegative signed integer is\n+   --  returned, otherwise constraint error is raised.\n+\n+   procedure Raise_Error;\n+   pragma No_Return (Raise_Error);\n+   --  Raise constraint error with appropriate message\n+\n+   -----------------\n+   -- Raise_Error --\n+   -----------------\n+\n+   procedure Raise_Error is\n+   begin\n+      raise Constraint_Error with \"32-bit arithmetic overflow\";\n+   end Raise_Error;\n+\n+   -------------------\n+   -- Scaled_Divide --\n+   -------------------\n+\n+   procedure Scaled_Divide32\n+     (X, Y, Z : Int32;\n+      Q, R    : out Int32;\n+      Round   : Boolean)\n+   is\n+      Xu  : constant Uns32 := abs X;\n+      Yu  : constant Uns32 := abs Y;\n+      Zu  : constant Uns32 := abs Z;\n+\n+      D   : Uns64;\n+      --  The dividend\n+\n+      Qu : Uns32;\n+      Ru : Uns32;\n+      --  Unsigned quotient and remainder\n+\n+   begin\n+      --  First do the 64-bit multiplication\n+\n+      D := Uns64 (Xu) * Uns64 (Yu);\n+\n+      --  If dividend is too large, raise error\n+\n+      if Hi (D) >= Zu then\n+         Raise_Error;\n+\n+      --  Then do the 64-bit division\n+\n+      else\n+         Qu := Uns32 (D / Uns64 (Zu));\n+         Ru := Uns32 (D rem Uns64 (Zu));\n+      end if;\n+\n+      --  Deal with rounding case\n+\n+      if Round and then Ru > (Zu - Uns32'(1)) / Uns32'(2) then\n+\n+         --  Protect against wrapping around when rounding, by signaling\n+         --  an overflow when the quotient is too large.\n+\n+         if Qu = Uns32'Last then\n+            Raise_Error;\n+         end if;\n+\n+         Qu := Qu + Uns32'(1);\n+      end if;\n+\n+      --  Set final signs (RM 4.5.5(27-30))\n+\n+      --  Case of dividend (X * Y) sign positive\n+\n+      if (X >= 0 and then Y >= 0) or else (X < 0 and then Y < 0) then\n+         R := To_Pos_Int (Ru);\n+         Q := (if Z > 0 then To_Pos_Int (Qu) else To_Neg_Int (Qu));\n+\n+      --  Case of dividend (X * Y) sign negative\n+\n+      else\n+         R := To_Neg_Int (Ru);\n+         Q := (if Z > 0 then To_Neg_Int (Qu) else To_Pos_Int (Qu));\n+      end if;\n+   end Scaled_Divide32;\n+\n+   ----------------\n+   -- To_Neg_Int --\n+   ----------------\n+\n+   function To_Neg_Int (A : Uns32) return Int32 is\n+      R : constant Int32 :=\n+        (if A = 2**31 then Int32'First else -To_Int (A));\n+      --  Note that we can't just use the expression of the Else, because it\n+      --  overflows for A = 2**31.\n+   begin\n+      if R <= 0 then\n+         return R;\n+      else\n+         Raise_Error;\n+      end if;\n+   end To_Neg_Int;\n+\n+   ----------------\n+   -- To_Pos_Int --\n+   ----------------\n+\n+   function To_Pos_Int (A : Uns32) return Int32 is\n+      R : constant Int32 := To_Int (A);\n+   begin\n+      if R >= 0 then\n+         return R;\n+      else\n+         Raise_Error;\n+      end if;\n+   end To_Pos_Int;\n+\n+end System.Arith_32;"}, {"sha": "565685561abcb5859e02b76e9a308f813d01edf8", "filename": "gcc/ada/libgnat/s-arit32.ads", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-arit32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-arit32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-arit32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,55 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . A R I T H _ 3 2                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This unit provides software routines for doing arithmetic on 32-bit\n+--  signed integer values in cases where either overflow checking is\n+--  required, or intermediate results are longer than 32 bits.\n+\n+with Interfaces;\n+\n+package System.Arith_32 is\n+   pragma Pure;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+\n+   procedure Scaled_Divide32\n+     (X, Y, Z : Int32;\n+      Q, R    : out Int32;\n+      Round   : Boolean);\n+   --  Performs the division of (X * Y) / Z, storing the quotient in Q\n+   --  and the remainder in R. Constraint_Error is raised if Z is zero,\n+   --  or if the quotient does not fit in 32 bits. Round indicates if\n+   --  the result should be rounded. If Round is False, then Q, R are\n+   --  the normal quotient and remainder from a truncating division.\n+   --  If Round is True, then Q is the rounded quotient. The remainder\n+   --  R is not affected by the setting of the Round flag.\n+\n+end System.Arith_32;"}, {"sha": "200a020640b4382bae0ec54740016721cbaad5d5", "filename": "gcc/ada/libgnat/s-fode128.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fode128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--              S Y S T E M . F O R E _ D E C I M A L _ 1 2 8               --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for decimal\n+--  fixed point types up to 128-bit mantissa.\n+\n+with Interfaces;\n+with System.Fore_D;\n+\n+package System.Fore_Decimal_128 is\n+   pragma Pure;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Impl is new Fore_D (Int128);\n+\n+   function Fore_Decimal128 (Lo, Hi : Int128; Scale : Integer) return Natural\n+     renames Impl.Fore_Decimal;\n+\n+end System.Fore_Decimal_128;"}, {"sha": "15c07a41e385fcf177deaee28ff189c242ee5051", "filename": "gcc/ada/libgnat/s-fode32.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fode32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . F O R E _ D E C I M A L _ 3 2                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for decimal\n+--  fixed point types up to 32-bit mantissa.\n+\n+with Interfaces;\n+with System.Fore_D;\n+\n+package System.Fore_Decimal_32 is\n+   pragma Pure;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+\n+   package Impl is new Fore_D (Int32);\n+\n+   function Fore_Decimal32 (Lo, Hi : Int32; Scale : Integer) return Natural\n+     renames Impl.Fore_Decimal;\n+\n+end System.Fore_Decimal_32;"}, {"sha": "7e98185d1ba2fca90d3bd9d510ba78a53d814f09", "filename": "gcc/ada/libgnat/s-fode64.ads", "status": "added", "additions": 48, "deletions": 0, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fode64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fode64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,48 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . F O R E _ D E C I M A L _ 6 4                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for decimal\n+--  fixed point types up to 64-bit mantissa.\n+\n+with Interfaces;\n+with System.Fore_D;\n+\n+package System.Fore_Decimal_64 is\n+   pragma Pure;\n+\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Impl is new Fore_D (Int64);\n+\n+   function Fore_Decimal64 (Lo, Hi : Int64; Scale : Integer) return Natural\n+     renames Impl.Fore_Decimal;\n+\n+end System.Fore_Decimal_64;"}, {"sha": "d580ec82a2a660add7a9af64f2e09c8580a8a5ca", "filename": "gcc/ada/libgnat/s-fofi128.ads", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . F O F I _ 1 2 8                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for ordinary\n+--  fixed point types up to 128-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_128;\n+with System.Fore_F;\n+\n+package System.Fore_Fixed_128 is\n+   pragma Pure;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Impl is new Fore_F (Int128, Arith_128.Scaled_Divide128);\n+\n+   function Fore_Fixed128 (Lo, Hi, Num, Den : Int128) return Natural\n+     renames Impl.Fore_Fixed;\n+\n+end System.Fore_Fixed_128;"}, {"sha": "5e48f555dea4afd4f219a1e7ed0711f56816d4a3", "filename": "gcc/ada/libgnat/s-fofi32.ads", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . F O R E _ F I X E D _ 3 2                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for ordinary\n+--  fixed point types up to 32-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_32;\n+with System.Fore_F;\n+\n+package System.Fore_Fixed_32 is\n+   pragma Pure;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+\n+   package Impl is new Fore_F (Int32, Arith_32.Scaled_Divide32);\n+\n+   function Fore_Fixed32 (Lo, Hi, Num, Den : Int32) return Natural\n+     renames Impl.Fore_Fixed;\n+\n+end System.Fore_Fixed_32;"}, {"sha": "588fac48428ba0faaf781f0ff52bc0bcb39300f3", "filename": "gcc/ada/libgnat/s-fofi64.ads", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fofi64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,49 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . F O R E _ F I X E D _ 6 4                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the 'Fore attribute for ordinary\n+--  fixed point types up to 64-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_64;\n+with System.Fore_F;\n+\n+package System.Fore_Fixed_64 is\n+   pragma Pure;\n+\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Impl is new Fore_F (Int64, Arith_64.Scaled_Divide64);\n+\n+   function Fore_Fixed64 (Lo, Hi, Num, Den : Int64) return Natural\n+     renames Impl.Fore_Fixed;\n+\n+end System.Fore_Fixed_64;"}, {"sha": "1141c67fcd344afec8782a1a01e96bd431861b66", "filename": "gcc/ada/libgnat/s-fore_d.adb", "status": "added", "additions": 62, "deletions": 0, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_d.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_d.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_d.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,62 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . F O R E _ D                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Fore_D is\n+\n+   ------------------\n+   -- Fore_Decimal --\n+   ------------------\n+\n+   function Fore_Decimal (Lo, Hi : Int; Scale : Integer) return Natural is\n+\n+      function Negative_Abs (Val : Int) return Int is\n+        (if Val <= 0 then Val else -Val);\n+      --  Return the opposite of the absolute value of Val\n+\n+      T : Int := Int'Min (Negative_Abs (Lo), Negative_Abs (Hi));\n+      F : Natural;\n+\n+   begin\n+      --  Initial value of 2 allows for sign and mandatory single digit\n+\n+      F := 2;\n+\n+      --  Loop to increase Fore as needed to include full range of values\n+\n+      while T <= -10 loop\n+         T := T / 10;\n+         F := F + 1;\n+      end loop;\n+\n+      return Natural'Max (F - Scale, 2);\n+   end Fore_Decimal;\n+\n+end System.Fore_D;"}, {"sha": "25e3449ecc111459c2ac3237fdb0a26a957c6601", "filename": "gcc/ada/libgnat/s-fore_d.ads", "status": "added", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_d.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_d.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_d.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,47 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . F O R E _ D                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the Fore attribute of decimal\n+--  fixed point types.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+package System.Fore_D is\n+   pragma Pure;\n+\n+   function Fore_Decimal (Lo, Hi : Int; Scale : Integer) return Natural;\n+   --  Compute Fore attribute value for a decimal fixed point type. The\n+   --  parameters are the low and high bounds (in units of delta) and the\n+   --  scale.\n+\n+end System.Fore_D;"}, {"sha": "b63d8d4b5b03d599f942a419b847277095d5755a", "filename": "gcc/ada/libgnat/s-fore_f.adb", "status": "added", "additions": 109, "deletions": 0, "changes": 109, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_f.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,109 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . F O R E _ F                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+package body System.Fore_F is\n+\n+   Maxdigs : constant Natural := Int'Width - 2;\n+   --  Maximum number of decimal digits that can be represented in an Int.\n+   --  The \"-2\" accounts for the sign and one extra digit, since we need the\n+   --  maximum number of 9's that can be represented, e.g. for the 64-bit case,\n+   --  Integer_64'Width is 20 since the maximum value is approximately 9.2E+18\n+   --  and has 19 digits, but the maximum number of 9's that can be represented\n+   --  in Integer_64 is only 18.\n+\n+   --  The prerequisite of the implementation is that the scaled divide does\n+   --  not overflow, which means that the absolute value of the bounds of\n+   --  the subtype must be smaller than 10**Maxdigs * 2**(Int'Size - 1).\n+   --  Otherwise Constraint_Error is raised by the scaled divide operation.\n+\n+   ----------------\n+   -- Fore_Fixed --\n+   ----------------\n+\n+   function Fore_Fixed (Lo, Hi, Num, Den : Int) return Natural is\n+      pragma Assert (Num < 0 and then Den < 0);\n+      --  Accept only negative numbers to allow -2**(Int'Size - 1)\n+\n+      function Negative_Abs (Val : Int) return Int is\n+        (if Val <= 0 then Val else -Val);\n+      --  Return the opposite of the absolute value of Val\n+\n+      T : Int := Int'Min (Negative_Abs (Lo), Negative_Abs (Hi));\n+      F : Natural;\n+\n+   begin\n+      --  Initial value of 2 allows for sign and mandatory single digit\n+\n+      F := 2;\n+\n+      --  If the Small is 1, then no scaling is needed\n+\n+      if Num = -1 and then Den = -1 then\n+         null;\n+\n+      --  The easy case is when the Small is the reciprocal of an integer\n+\n+      elsif Num = -1 then\n+         T := T / Den;\n+\n+      --  If the Small is an integer, compute Q and R such that\n+\n+      --    T * Small = Q * 10**Maxdigs - R\n+\n+      --  then reason on Q if it is non-zero or else on R.\n+\n+      else pragma Assert (Den = -1);\n+         declare\n+            Q, R : Int;\n+\n+         begin\n+            Scaled_Divide (T, Num, -10**Maxdigs, Q, R, Round => False);\n+\n+            if Q /= 0 then\n+               T := Q;\n+               F := F + Maxdigs;\n+            else\n+               T := R;\n+            end if;\n+         end;\n+      end if;\n+\n+      --  Loop to increase Fore as needed to include full range of values\n+\n+      while T <= -10 or else T >= 10 loop\n+         T := T / 10;\n+         F := F + 1;\n+      end loop;\n+\n+      return F;\n+   end Fore_Fixed;\n+\n+end System.Fore_F;"}, {"sha": "15fcb72fddb38bf6e27c010cf19bd22fbf746c02", "filename": "gcc/ada/libgnat/s-fore_f.ads", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-fore_f.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,51 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                        S Y S T E M . F O R E _ F                         --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routine used for the Fore attribute of ordinary\n+--  fixed point types whose Small is an integer or its reciprocal.\n+\n+generic\n+\n+   type Int is range <>;\n+\n+   with procedure Scaled_Divide\n+          (X, Y, Z : Int;\n+           Q, R : out Int;\n+           Round : Boolean);\n+\n+package System.Fore_F is\n+   pragma Pure;\n+\n+   function Fore_Fixed (Lo, Hi, Num, Den : Int) return Natural;\n+   --  Compute Fore attribute value for an ordinary fixed point type with small\n+   --  Num/Den. The parameters are the low and high bounds (in units of small).\n+\n+end System.Fore_F;"}, {"sha": "cb74dc60c590b6292cf636ec9d933badb603df1e", "filename": "gcc/ada/libgnat/s-forrea.adb", "status": "renamed", "additions": 13, "deletions": 12, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-forrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-forrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-forrea.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                          S Y S T E M . F O R E                           --\n+--                     S Y S T E M . F O R E _ R E A L                      --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n@@ -29,28 +29,29 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-package body System.Fore is\n+package body System.Fore_Real is\n \n-   ----------\n-   -- Fore --\n-   ----------\n+   ---------------\n+   -- Fore_Real --\n+   ---------------\n \n-   function Fore (Lo, Hi : Long_Long_Float) return Natural is\n+   function Fore_Real (Lo, Hi : Long_Long_Float) return Natural is\n       T : Long_Long_Float := Long_Long_Float'Max (abs Lo, abs Hi);\n-      R : Natural;\n+      F : Natural;\n \n    begin\n       --  Initial value of 2 allows for sign and mandatory single digit\n \n-      R := 2;\n+      F := 2;\n \n       --  Loop to increase Fore as needed to include full range of values\n \n       while T >= 10.0 loop\n          T := T / 10.0;\n-         R := R + 1;\n+         F := F + 1;\n       end loop;\n \n-      return R;\n-   end Fore;\n-end System.Fore;\n+      return F;\n+   end Fore_Real;\n+\n+end System.Fore_Real;", "previous_filename": "gcc/ada/libgnat/s-fore.adb"}, {"sha": "6b0a211c091b5fed917c40132596306f421f3326", "filename": "gcc/ada/libgnat/s-forrea.ads", "status": "renamed", "additions": 8, "deletions": 7, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-forrea.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-forrea.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-forrea.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,7 +2,7 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                          S Y S T E M . F O R E                           --\n+--                     S Y S T E M . F O R E _ R E A L                      --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n@@ -29,13 +29,14 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains the routine used for the 'Fore attribute\n+--  This package contains the routine used for the Fore attribute of ordinary\n+--  fixed point types whose Small is neither an integer nor its reciprocal.\n \n-package System.Fore is\n+package System.Fore_Real is\n    pragma Pure;\n \n-   function Fore (Lo, Hi : Long_Long_Float) return Natural;\n-   --  Compute Fore attribute value for a fixed-point type. The parameters\n-   --  are the low and high bounds values, converted to Long_Long_Float.\n+   function Fore_Real (Lo, Hi : Long_Long_Float) return Natural;\n+   --  Compute Fore attribute value for a fixed point type. The parameters\n+   --  are the low and high bounds, converted to Long_Long_Float.\n \n-end System.Fore;\n+end System.Fore_Real;", "previous_filename": "gcc/ada/libgnat/s-fore.ads"}, {"sha": "726b9d8056109a83b64a144987890b41d68a6e5c", "filename": "gcc/ada/libgnat/s-imaged.adb", "status": "renamed", "additions": 19, "deletions": 20, "changes": 39, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imaged.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imaged.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imaged.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . I M G _ L L D                        --\n+--                        S Y S T E M . I M A G E _ D                       --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,16 +29,16 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Img_Dec; use System.Img_Dec;\n+with System.Img_Util; use System.Img_Util;\n \n-package body System.Img_LLD is\n+package body System.Image_D is\n \n-   -----------------------------\n-   -- Image_Long_Long_Decimal --\n-   ----------------------------\n+   -------------------\n+   -- Image_Decimal --\n+   -------------------\n \n-   procedure Image_Long_Long_Decimal\n-     (V     : Long_Long_Integer;\n+   procedure Image_Decimal\n+     (V     : Int;\n       S     : in out String;\n       P     : out Natural;\n       Scale : Integer)\n@@ -55,28 +55,27 @@ package body System.Img_LLD is\n          P := 0;\n       end if;\n \n-      Set_Image_Long_Long_Decimal\n-        (V, S, P, Scale, 1, Integer'Max (1, Scale), 0);\n-   end Image_Long_Long_Decimal;\n+      Set_Image_Decimal (V, S, P, Scale, 1, Integer'Max (1, Scale), 0);\n+   end Image_Decimal;\n \n-   ---------------------------------\n-   -- Set_Image_Long_Long_Decimal --\n-   ---------------------------------\n+   -----------------------\n+   -- Set_Image_Decimal --\n+   -----------------------\n \n-   procedure Set_Image_Long_Long_Decimal\n-     (V     : Long_Long_Integer;\n+   procedure Set_Image_Decimal\n+     (V     : Int;\n       S     : in out String;\n       P     : in out Natural;\n       Scale : Integer;\n       Fore  : Natural;\n       Aft   : Natural;\n       Exp   : Natural)\n    is\n-      Digs : String := Long_Long_Integer'Image (V);\n+      Digs : String := Int'Image (V);\n       --  Sign and digits of decimal value\n \n    begin\n       Set_Decimal_Digits (Digs, Digs'Length, S, P, Scale, Fore, Aft, Exp);\n-   end Set_Image_Long_Long_Decimal;\n+   end Set_Image_Decimal;\n \n-end System.Img_LLD;\n+end System.Image_D;", "previous_filename": "gcc/ada/libgnat/s-imglld.adb"}, {"sha": "5c3f82a859477d024ecae1f45d5a02073b975975", "filename": "gcc/ada/libgnat/s-imaged.ads", "status": "renamed", "additions": 23, "deletions": 18, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imaged.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imaged.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imaged.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . I M G _ L L D                        --\n+--                       S Y S T E M . I M A G E _ D                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,39 +29,44 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Image for decimal fixed types where the size of the corresponding integer\n---  type does exceeds Integer'Size (also used for Text_IO.Decimal_IO output)\n+--  This package contains the routines for supporting the Image attribute for\n+--  decimal fixed point types, and also for conversion operations required in\n+--  Text_IO.Decimal_IO for such types.\n \n-package System.Img_LLD is\n+generic\n+\n+   type Int is range <>;\n+\n+package System.Image_D is\n    pragma Pure;\n \n-   procedure Image_Long_Long_Decimal\n-     (V     : Long_Long_Integer;\n+   procedure Image_Decimal\n+     (V     : Int;\n       S     : in out String;\n       P     : out Natural;\n       Scale : Integer);\n    --  Computes fixed_type'Image (V), where V is the integer value (in units of\n-   --  delta) of a decimal type whose Scale is as given and store the result in\n-   --  S (P + 1 .. L), updating P to the value of L. The image is given by the\n+   --  delta) of a decimal type whose Scale is as given and stores the result\n+   --  S (1 .. P), updating P to the value of L. The image is given by the\n    --  rules in RM 3.5(34) for fixed-point type image functions. The caller\n-   --  guarantees that S is long enough to hold the result. S need not have a\n-   --  lower bound of 1.\n+   --  guarantees that S is long enough to hold the result and has a lower\n+   --  bound of 1.\n \n-   procedure Set_Image_Long_Long_Decimal\n-     (V     : Long_Long_Integer;\n+   procedure Set_Image_Decimal\n+     (V     : Int;\n       S     : in out String;\n       P     : in out Natural;\n       Scale : Integer;\n       Fore  : Natural;\n       Aft   : Natural;\n       Exp   : Natural);\n    --  Sets the image of V, where V is the integer value (in units of delta)\n-   --  of a decimal type with the given Scale, starting at S (P + 1), updating\n-   --  P to point to the last character stored, the caller promises that the\n-   --  buffer is large enough and no check is made for this. Constraint_Error\n+   --  of a decimal type with the specified Scale, starting at S (P + 1) and\n+   --  updating P to point to the last character stored, the caller promises\n+   --  that the buffer is large enough and no check is made. Constraint_Error\n    --  will not necessarily be raised if this requirement is violated, since\n    --  it is perfectly valid to compile this unit with checks off. The Fore,\n    --  Aft and Exp values can be set to any valid values for the case of use\n-   --  by Text_IO.Decimal_IO. Note that there is no leading space stored.\n+   --  by Text_IO.Decimal_IO.\n \n-end System.Img_LLD;\n+end System.Image_D;", "previous_filename": "gcc/ada/libgnat/s-imglld.ads"}, {"sha": "2328474149fef1bc47ecfa407a973c059f0c8627", "filename": "gcc/ada/libgnat/s-imagef.adb", "status": "added", "additions": 287, "deletions": 0, "changes": 287, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imagef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,287 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . I M A G E _ F                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Image_I;\n+with System.Img_Util; use System.Img_Util;\n+\n+package body System.Image_F is\n+\n+   package Image_I is new System.Image_I (Int);\n+\n+   procedure Set_Image_Integer\n+     (V : Int;\n+      S : in out String;\n+      P : in out Natural)\n+     renames Image_I.Set_Image_Integer;\n+\n+   --  The following section describes a specific implementation choice for\n+   --  performing base conversions needed for output of values of a fixed\n+   --  point type T with small T'Small. The goal is to be able to output\n+   --  all values of fixed point types with a precision of 64 bits and a\n+   --  small in the range 2.0**(-63) .. 2.0**63. The reasoning can easily\n+   --  be adapted to fixed point types with a precision of 32 or 128 bits.\n+\n+   --  The chosen algorithm uses fixed precision integer arithmetic for\n+   --  reasons of simplicity and efficiency. It is important to understand\n+   --  in what ways the most simple and accurate approach to fixed point I/O\n+   --  is limiting, before considering more complicated schemes.\n+\n+   --  Without loss of generality assume T has a range (-2.0**63) * T'Small\n+   --  .. (2.0**63 - 1) * T'Small, and is output with Aft digits after the\n+   --  decimal point and T'Fore - 1 before. If T'Small is integer, or\n+   --  1.0 / T'Small is integer, let S = T'Small.\n+\n+   --  The idea is to convert a value X * S of type T to a 64-bit integer value\n+   --  Q equal to 10.0**D * (X * S) rounded to the nearest integer, using only\n+   --  a scaled integer divide of the form\n+\n+   --     Q = (X * Y) / Z,\n+\n+   --  where the variables X, Y, Z are 64-bit integers, and both multiplication\n+   --  and division are done using full intermediate precision. Then the final\n+   --  decimal value to be output is\n+\n+   --     Q * 10**(-D)\n+\n+   --  This value can be written to the output file or to the result string\n+   --  according to the format described in RM A.3.10. The details of this\n+   --  operation are omitted here.\n+\n+   --  A 64-bit value can represent all integers with 18 decimal digits, but\n+   --  not all with 19 decimal digits. If the total number of requested ouput\n+   --  digits (Fore - 1) + Aft is greater than 18 then, for purposes of the\n+   --  conversion, Aft is adjusted to 18 - (Fore - 1). In that case, trailing\n+   --  zeros can complete the output after writing the first 18 significant\n+   --  digits, or the technique described in the next section can be used.\n+   --  In addition, D cannot be smaller than -18, in order for 10.0**(-D) to\n+   --  fit in a 64-bit integer.\n+\n+   --  The final expression for D is\n+\n+   --     D = Integer'Max (-18, Integer'Min (Aft, 18 - (Fore - 1)));\n+\n+   --  For Y and Z the following expressions can be derived:\n+\n+   --     Q = X * S * (10.0**D) = (X * Y) / Z\n+\n+   --  If S is an integer greater than or equal to one, then Fore must be at\n+   --  least 20 in order to print T'First, which is at most -2.0**63. This\n+   --  means that D < 0, so use\n+\n+   --    (1)   Y = -S and Z = -10**(-D)\n+\n+   --  If 1.0 / S is an integer greater than one, use\n+\n+   --    (2)   Y = -10**D and Z = -(1.0 / S), for D >= 0\n+\n+   --  or\n+\n+   --    (3)   Y = -1 and Z = -(1.0 / S) * 10**(-D), for D < 0\n+\n+   --  Negative values are used for nominator Y and denominator Z, so that S\n+   --  can have a maximum value of 2.0**63 and a minimum of 2.0**(-63). For\n+   --  -(1.0 / S) in -1 .. -9, Fore will still be 20, and D will be negative,\n+   --  as (-2.0**63) / -9 is greater than 10**18. In these cases there is room\n+   --  in the denominator for the extra decimal scaling required, so case (3)\n+   --  will not overflow.\n+\n+   --  Using a scaled divide which truncates and returns a remainder R,\n+   --  another K trailing digits can be calculated by computing the value\n+   --  (R * (10.0**K)) / Z using another scaled divide. This procedure\n+   --  can be repeated to compute an arbitrary number of digits in linear\n+   --  time and storage. The last scaled divide should be rounded, with\n+   --  a possible carry propagating to the more significant digits, to\n+   --  ensure correct rounding of the unit in the last place.\n+\n+   Maxdigs : constant Natural := Int'Width - 2;\n+   --  Maximum number of decimal digits that can be represented in an Int.\n+   --  The \"-2\" accounts for the sign and one extra digit, since we need the\n+   --  maximum number of 9's that can be represented, e.g. for the 64-bit case,\n+   --  Integer_64'Width is 20 since the maximum value is approximately 9.2E+18\n+   --  and has 19 digits, but the maximum number of 9's that can be represented\n+   --  in Integer_64 is only 18.\n+\n+   --  The prerequisite of the implementation is that the first scaled divide\n+   --  does not overflow, which means that the absolute value of the input X\n+   --  must always be smaller than 10**Maxdigs * 2**(Int'Size - 1). Otherwise\n+   --  Constraint_Error is raised by the scaled divide operation.\n+\n+   -----------------\n+   -- Image_Fixed --\n+   -----------------\n+\n+   procedure Image_Fixed\n+     (V    : Int;\n+      S    : in out String;\n+      P    : out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+   is\n+      pragma Assert (S'First = 1);\n+\n+   begin\n+      --  Add space at start for non-negative numbers\n+\n+      if V >= 0 then\n+         S (1) := ' ';\n+         P := 1;\n+      else\n+         P := 0;\n+      end if;\n+\n+      Set_Image_Fixed (V, S, P, Num, Den, For0, Aft0, 1, Aft0, 0);\n+   end Image_Fixed;\n+\n+   ---------------------\n+   -- Set_Image_Fixed --\n+   ---------------------\n+\n+   procedure Set_Image_Fixed\n+     (V    : Int;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+   is\n+      pragma Assert (Num < 0 and then Den < 0);\n+      --  Accept only negative numbers to allow -2**(Int'Size - 1)\n+\n+      pragma Assert (Num = -1 or else Den = -1);\n+      --  Accept only integer or reciprocal of integer to control the\n+      --  magnitude of the arithmetic operations below.\n+\n+      A : constant Natural :=\n+            Boolean'Pos (Exp > 0) * Aft0 + Natural'Max (Aft, 1) + 1;\n+      --  Number of digits after the decimal point to be computed. If Exp is\n+      --  positive, we need to compute Aft decimal digits after the first non\n+      --  zero digit and we are guaranteed there is at least one in the first\n+      --  Aft0 digits (unless V is zero). In both cases, we compute one more\n+      --  digit than requested so that Set_Decimal_Digits can round at Aft.\n+\n+      D : constant Integer :=\n+            Integer'Max (-Maxdigs, Integer'Min (A, Maxdigs - (For0 - 1)));\n+      Y : constant Int     := Num * 10**Integer'Max (0, D);\n+      Z : constant Int     := Den * 10**Integer'Max (0, -D);\n+      --  See the description of the algorithm above\n+\n+      AF : constant Natural := A - D;\n+      --  Number of remaining digits to be computed after the first round. It\n+      --  is larger than A if the first round does not compute all the digits\n+      --  before the decimal point, i.e. (For0 - 1) larger than Maxdigs.\n+\n+      N : constant Natural := 1 + (AF + Maxdigs - 1) / Maxdigs;\n+      --  Number of rounds of scaled divide to be performed\n+\n+      Q : Int;\n+      --  Quotient of the scaled divide in this round. Only the first round\n+      --  may yield more than Maxdigs digits. The sign is not significant.\n+\n+      Buf : String (1 .. Maxdigs);\n+      Len : Natural;\n+      --  Buffer for the image of the quotient\n+\n+      Digs  : String (1 .. N * Maxdigs + 1);\n+      Ndigs : Natural := 0;\n+      --  Concatenated image of the successive quotients\n+\n+      Scale : Integer := 0;\n+      --  Exponent such that the result is Digs (1 .. NDigs) * 10**(-Scale)\n+\n+      XX : Int := V;\n+      YY : Int := Y;\n+      --  First two operands of the scaled divide\n+\n+   begin\n+      --  Set the first character like Image, either minus or space\n+\n+      Digs (1) := (if V < 0 then '-' else ' ');\n+      Ndigs := 1;\n+\n+      for J in 1 .. N loop\n+         exit when XX = 0;\n+\n+         Scaled_Divide (XX, YY, Z, Q, R => XX, Round => False);\n+\n+         if J = 1 then\n+            if Q /= 0 then\n+               Set_Image_Integer (abs Q, Digs, Ndigs);\n+            end if;\n+\n+            Scale := Scale + D;\n+\n+            --  Prepare for next round, if any\n+\n+            YY := 10**Maxdigs;\n+\n+         else\n+            Len := 0;\n+            Set_Image_Integer (abs Q, Buf, Len);\n+\n+            if Ndigs = 1 then\n+               Digs (2 .. Len + 1) := Buf (1 .. Len);\n+               Ndigs := Len + 1;\n+\n+            else\n+               --  Pad the output with zeroes up to Maxdigs\n+\n+               for K in 1 .. Maxdigs - Len loop\n+                  Digs (Ndigs + K) := '0';\n+               end loop;\n+\n+               for K in 1 .. Len loop\n+                  Digs (Ndigs + Maxdigs - Len + K) := Buf (K);\n+               end loop;\n+\n+               Ndigs := Ndigs + Maxdigs;\n+            end if;\n+\n+            Scale := Scale + Maxdigs;\n+         end if;\n+      end loop;\n+\n+      --  If no digit was output, this is zero\n+\n+      if Ndigs = 1 then\n+         Digs (1 .. 2) := \" 0\";\n+         Ndigs := 2;\n+      end if;\n+\n+      Set_Decimal_Digits (Digs, Ndigs, S, P, Scale, Fore, Aft, Exp);\n+   end Set_Image_Fixed;\n+\n+end System.Image_F;"}, {"sha": "bd1fb15814b29134d679536db875dd3cc0e6148f", "filename": "gcc/ada/libgnat/s-imagef.ads", "status": "renamed", "additions": 53, "deletions": 47, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imagef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imagef.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . I M G _ D E C                        --\n+--                       S Y S T E M . I M A G E _ F                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,55 +29,61 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  Image for decimal fixed types where the size of the corresponding integer\n---  type does not exceed Integer'Size (also used for Text_IO.Decimal_IO output)\n+--  This package contains the routines for supporting the Image attribute for\n+--  ordinary fixed point types whose Small is an integer or its reciprocal,\n+--  and also for conversion operations required in Text_IO.Fixed_IO for such\n+--  types.\n \n-package System.Img_Dec is\n+generic\n+\n+   type Int is range <>;\n+\n+   with procedure Scaled_Divide\n+          (X, Y, Z : Int;\n+           Q, R : out Int;\n+           Round : Boolean);\n+\n+package System.Image_F is\n    pragma Pure;\n \n-   procedure Image_Decimal\n-     (V     : Integer;\n-      S     : in out String;\n-      P     : out Natural;\n-      Scale : Integer);\n+   procedure Image_Fixed\n+     (V    : Int;\n+      S    : in out String;\n+      P    : out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural);\n    --  Computes fixed_type'Image (V), where V is the integer value (in units of\n-   --  delta) of a decimal type whose Scale is as given and stores the result\n-   --  S (1 .. P), updating P to the value of L. The image is given by the\n-   --  rules in RM 3.5(34) for fixed-point type image functions. The caller\n-   --  guarantees that S is long enough to hold the result. S need not have a\n-   --  lower bound of 1.\n+   --  small) of an ordinary fixed point type with small Num/Den, and stores\n+   --  the result in S (1 .. P), updating P on return. The result is computed\n+   --  according to the rules for image for fixed-point types (RM 3.5(34)).\n+   --  For0 and Aft0 are the values of the Fore and Aft attributes for the\n+   --  fixed point type whose mantissa type is Int and whose small is Num/Den.\n+   --  This function is used only for fixed point whose Small is an integer or\n+   --  its reciprocal (see package System.Img_Real for the handling of other\n+   --  ordinary fixed-point types). The caller guarantees that S is long enough\n+   --  to hold the result and has a lower bound of 1.\n \n-   procedure Set_Image_Decimal\n-     (V     : Integer;\n-      S     : in out String;\n-      P     : in out Natural;\n-      Scale : Integer;\n-      Fore  : Natural;\n-      Aft   : Natural;\n-      Exp   : Natural);\n-   --  Sets the image of V, where V is the integer value (in units of delta)\n-   --  of a decimal type with the given Scale, starting at S (P + 1), updating\n-   --  P to point to the last character stored, the caller promises that the\n-   --  buffer is large enough and no check is made for this. Constraint_Error\n+   procedure Set_Image_Fixed\n+     (V    : Int;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int;\n+      Den  : Int;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural);\n+   --  Sets the image of V, where V is the integer value (in units of small)\n+   --  of a fixed point type with small Num/Den, starting at S (P + 1) and\n+   --  updating P to point to the last character stored, the caller promises\n+   --  that the buffer is large enough and no check is made. Constraint_Error\n    --  will not necessarily be raised if this requirement is violated, since\n-   --  it is perfectly valid to compile this unit with checks off. The Fore,\n-   --  Aft and Exp values can be set to any valid values for the case of use\n-   --  by Text_IO.Decimal_IO. Note that there is no leading space stored.\n-\n-   procedure Set_Decimal_Digits\n-     (Digs  : in out String;\n-      NDigs : Natural;\n-      S     : out String;\n-      P     : in out Natural;\n-      Scale : Integer;\n-      Fore  : Natural;\n-      Aft   : Natural;\n-      Exp   : Natural);\n-   --  This procedure has the same semantics as Set_Image_Decimal, except that\n-   --  the value in Digs (1 .. NDigs) is given as a string of decimal digits\n-   --  preceded by either a minus sign or a space (i.e. the integer image of\n-   --  the value in units of delta). The call may destroy the value in Digs,\n-   --  which is why Digs is in-out (this happens if rounding is required).\n-   --  Set_Decimal_Digits is shared by all the decimal image routines.\n+   --  it is perfectly valid to compile this unit with checks off. For0 and\n+   --  Aft0 are the values of the Fore and Aft attributes for the fixed point\n+   --  type whose mantissa type is Int and whose small is Num/Den. The Fore,\n+   --  Aft and Exp can be set to any valid values for use by Text_IO.Fixed_IO.\n \n-end System.Img_Dec;\n+end System.Image_F;", "previous_filename": "gcc/ada/libgnat/s-imgdec.ads"}, {"sha": "cffd0c04c320d937b5df757e1c13c8c53d70b86c", "filename": "gcc/ada/libgnat/s-imde128.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--               S Y S T E M . I M G _ D E C I M A L _ 1 2 8                --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  decimal fixed point types up to 128-bit mantissa, and also for conversion\n+--  operations required in Text_IO.Decimal_IO for them.\n+\n+with Interfaces;\n+with System.Image_D;\n+\n+package System.Img_Decimal_128 is\n+   pragma Pure;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Impl is new Image_D (Int128);\n+\n+   procedure Image_Decimal128\n+     (V     : Int128;\n+      S     : in out String;\n+      P     : out Natural;\n+      Scale : Integer)\n+     renames Impl.Image_Decimal;\n+\n+   procedure Set_Image_Decimal128\n+     (V     : Int128;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural)\n+     renames Impl.Set_Image_Decimal;\n+\n+end System.Img_Decimal_128;"}, {"sha": "bf19e9cbbcd7f149ff616b669ac1e23df39e925c", "filename": "gcc/ada/libgnat/s-imde32.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . I M G _ D E C I M A L _ 3 2                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  decimal fixed point types up to 32-bit mantissa, and also for conversion\n+--  operations required in Text_IO.Decimal_IO for such types.\n+\n+with Interfaces;\n+with System.Image_D;\n+\n+package System.Img_Decimal_32 is\n+   pragma Pure;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+\n+   package Impl is new Image_D (Int32);\n+\n+   procedure Image_Decimal32\n+     (V     : Int32;\n+      S     : in out String;\n+      P     : out Natural;\n+      Scale : Integer)\n+     renames Impl.Image_Decimal;\n+\n+   procedure Set_Image_Decimal32\n+     (V     : Int32;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural)\n+     renames Impl.Set_Image_Decimal;\n+\n+end System.Img_Decimal_32;"}, {"sha": "dfc8403ff01f573a8402455d3003e9b66e2e7293", "filename": "gcc/ada/libgnat/s-imde64.ads", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imde64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imde64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,63 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . I M G _ D E C I M A L _ 6 4                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  decimal fixed point types up to 64-bit mantissa, and also for conversion\n+--  operations required in Text_IO.Decimal_IO for such types.\n+\n+with Interfaces;\n+with System.Image_D;\n+\n+package System.Img_Decimal_64 is\n+   pragma Pure;\n+\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Impl is new Image_D (Int64);\n+\n+   procedure Image_Decimal64\n+     (V     : Int64;\n+      S     : in out String;\n+      P     : out Natural;\n+      Scale : Integer)\n+     renames Impl.Image_Decimal;\n+\n+   procedure Set_Image_Decimal64\n+     (V     : Int64;\n+      S     : in out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural)\n+     renames Impl.Set_Image_Decimal;\n+\n+end System.Img_Decimal_64;"}, {"sha": "24fdf974c7eeccd641bbe6e96a731b6f16a687e9", "filename": "gcc/ada/libgnat/s-imfi128.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . I M G _ F I X E D _ 1 2 8                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  ordinary fixed point types up to 128-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_128;\n+with System.Image_F;\n+\n+package System.Img_Fixed_128 is\n+   pragma Pure;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+\n+   package Impl is new Image_F (Int128, Arith_128.Scaled_Divide128);\n+\n+   procedure Image_Fixed128\n+     (V    : Int128;\n+      S    : in out String;\n+      P    : out Natural;\n+      Num  : Int128;\n+      Den  : Int128;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+     renames Impl.Image_Fixed;\n+\n+   procedure Set_Image_Fixed128\n+     (V    : Int128;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int128;\n+      Den  : Int128;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Fixed;\n+\n+end System.Img_Fixed_128;"}, {"sha": "8c425dfa33f2a8a676c8a443aab60416d1c09d21", "filename": "gcc/ada/libgnat/s-imfi32.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . I M G _ F I X E D _ 3 2                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  ordinary fixed point types up to 32-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_32;\n+with System.Image_F;\n+\n+package System.Img_Fixed_32 is\n+   pragma Pure;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+\n+   package Impl is new Image_F (Int32, Arith_32.Scaled_Divide32);\n+\n+   procedure Image_Fixed32\n+     (V    : Int32;\n+      S    : in out String;\n+      P    : out Natural;\n+      Num  : Int32;\n+      Den  : Int32;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+     renames Impl.Image_Fixed;\n+\n+   procedure Set_Image_Fixed32\n+     (V    : Int32;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int32;\n+      Den  : Int32;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Fixed;\n+\n+end System.Img_Fixed_32;"}, {"sha": "9045bf6d9b8b6e44e9a1d0721835ecb201e839d5", "filename": "gcc/ada/libgnat/s-imfi64.ads", "status": "added", "additions": 69, "deletions": 0, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imfi64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,69 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . I M G _ F I X E D _ 6 4                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains the routines for supporting the Image attribute for\n+--  ordinary fixed point types up to 64-bit small and mantissa.\n+\n+with Interfaces;\n+with System.Arith_64;\n+with System.Image_F;\n+\n+package System.Img_Fixed_64 is\n+   pragma Pure;\n+\n+   subtype Int64 is Interfaces.Integer_64;\n+\n+   package Impl is new Image_F (Int64, Arith_64.Scaled_Divide64);\n+\n+   procedure Image_Fixed64\n+     (V    : Int64;\n+      S    : in out String;\n+      P    : out Natural;\n+      Num  : Int64;\n+      Den  : Int64;\n+      For0 : Natural;\n+      Aft0 : Natural)\n+     renames Impl.Image_Fixed;\n+\n+   procedure Set_Image_Fixed64\n+     (V    : Int64;\n+      S    : in out String;\n+      P    : in out Natural;\n+      Num  : Int64;\n+      Den  : Int64;\n+      For0 : Natural;\n+      Aft0 : Natural;\n+      Fore : Natural;\n+      Aft  : Natural;\n+      Exp  : Natural)\n+     renames Impl.Set_Image_Fixed;\n+\n+end System.Img_Fixed_64;"}, {"sha": "03d30bdf9d733c08b623a9e82a2389f9d9274b1d", "filename": "gcc/ada/libgnat/s-imgrea.adb", "status": "modified", "additions": 17, "deletions": 21, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imgrea.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -47,18 +47,17 @@ package body System.Img_Real is\n    --  in very high precision floating-point output.\n \n    --  Note that in the following, the \"-2\" accounts for the sign and one\n-   --  extra digits, since we need the maximum number of 9's that can be\n-   --  supported, e.g. for the normal 64 bit case, Long_Long_Integer'Width\n-   --  is 21, since the maximum value (approx 1.6 * 10**19) has 20 digits,\n-   --  but the maximum number of 9's that can be supported is 19.\n+   --  extra digit, since we need the maximum number of 9's that can be\n+   --  represented, e.g. for the 64-bit case, Long_Long_Unsigned'Width is\n+   --  21, since the maximum value (approx 1.8E+19) has 20 digits, but the\n+   --  maximum number of 9's that can be represented is only 19.\n \n    Maxdigs : constant :=\n                Natural'Min\n                  (Long_Long_Unsigned'Width - 2, Long_Long_Float'Digits);\n \n    Unsdigs : constant := Unsigned'Width - 2;\n    --  Number of digits that can be converted using type Unsigned\n-   --  See above for the explanation of the -2.\n \n    Maxscaling : constant := 5000;\n    --  Max decimal scaling required during conversion of floating-point\n@@ -88,11 +87,8 @@ package body System.Img_Real is\n       --  Decide whether a blank should be prepended before the call to\n       --  Set_Image_Real. We generate a blank for positive values, and\n       --  also for positive zeroes. For negative zeroes, we generate a\n-      --  space only if Signed_Zeroes is True (the RM only permits the\n-      --  output of -0.0 on targets where this is the case). We can of\n-      --  course still see a -0.0 on a target where Signed_Zeroes is\n-      --  False (since this attribute refers to the proper handling of\n-      --  negative zeroes, not to their existence). We do not generate\n+      --  blank only if Signed_Zeros is False (the RM only permits the\n+      --  output of -0.0 when Signed_Zeros is True). We do not generate\n       --  a blank for positive infinity, since we output an explicit +.\n \n       if (not Is_Negative (V) and then V <= Long_Long_Float'Last)\n@@ -150,7 +146,7 @@ package body System.Img_Real is\n       Exp  : Natural)\n    is\n       NFrac : constant Natural := Natural'Max (Aft, 1);\n-      Sign  : Character;\n+      Minus : Boolean;\n       X     : Long_Long_Float;\n       Scale : Integer;\n       Expon : Integer;\n@@ -419,7 +415,7 @@ package body System.Img_Real is\n \n       procedure Set_Blanks_And_Sign (N : Integer) is\n       begin\n-         if Sign = '-' then\n+         if Minus then\n             for J in 1 .. N - 1 loop\n                Set (' ');\n             end loop;\n@@ -483,10 +479,10 @@ package body System.Img_Real is\n    --  Start of processing for Set_Image_Real\n \n    begin\n-      --  We call the floating-point processor reset routine so that we can\n-      --  be sure the floating-point processor is properly set for conversion\n-      --  calls. This is notably need on Windows, where calls to the operating\n-      --  system randomly reset the processor into 64-bit mode.\n+      --  We call the floating-point processor reset routine so we can be sure\n+      --  that the processor is properly set for conversions. This is notably\n+      --  needed on Windows, where calls to the operating system randomly reset\n+      --  the processor into 64-bit mode.\n \n       System.Float_Control.Reset;\n \n@@ -539,21 +535,21 @@ package body System.Img_Real is\n \n       if V > 0.0 then\n          X := V;\n-         Sign := '+';\n+         Minus := False;\n \n       --  Negative values\n \n       elsif V < 0.0 then\n          X := -V;\n-         Sign := '-';\n+         Minus := True;\n \n       --  Zero values\n \n       elsif V = 0.0 then\n          if Long_Long_Float'Signed_Zeros and then Is_Negative (V) then\n-            Sign := '-';\n+            Minus := True;\n          else\n-            Sign := '+';\n+            Minus := False;\n          end if;\n \n          Set_Blanks_And_Sign (Fore - 1);\n@@ -578,7 +574,7 @@ package body System.Img_Real is\n          raise Constraint_Error;\n       end if;\n \n-      --  X and Sign are set here, and X is known to be a valid,\n+      --  X and Minus are set here, and X is known to be a valid,\n       --  non-zero floating-point number.\n \n       --  Case of non-zero value with Exp = 0"}, {"sha": "571fb675cc14722348e1c357df469a003dfb5936", "filename": "gcc/ada/libgnat/s-imguti.adb", "status": "renamed", "additions": 12, "deletions": 63, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imguti.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imguti.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT RUN-TIME COMPONENTS                         --\n --                                                                          --\n---                        S Y S T E M . I M G _ D E C                       --\n+--                      S Y S T E M . I M G _ U T I L                       --\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,34 +29,9 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Img_Int; use System.Img_Int;\n+with System.Img_Uns; use System.Img_Uns;\n \n-package body System.Img_Dec is\n-\n-   -------------------\n-   -- Image_Decimal --\n-   -------------------\n-\n-   procedure Image_Decimal\n-     (V     : Integer;\n-      S     : in out String;\n-      P     : out Natural;\n-      Scale : Integer)\n-   is\n-      pragma Assert (S'First = 1);\n-\n-   begin\n-      --  Add space at start for non-negative numbers\n-\n-      if V >= 0 then\n-         S (1) := ' ';\n-         P := 1;\n-      else\n-         P := 0;\n-      end if;\n-\n-      Set_Image_Decimal (V, S, P, Scale, 1, Integer'Max (1, Scale), 0);\n-   end Image_Decimal;\n+package body System.Img_Util is\n \n    ------------------------\n    -- Set_Decimal_Digits --\n@@ -121,8 +96,8 @@ package body System.Img_Dec is\n       procedure Set_Blanks_And_Sign (N : Integer);\n       --  Sets leading blanks and minus sign if needed. N is the number of\n       --  positions to be filled (a minus sign is output even if N is zero\n-      --  or negative, For a positive value, if N is non-positive, then\n-      --  a leading blank is filled.\n+      --  or negative, but for a positive value, if N is non-positive, then\n+      --  the call has no effect).\n \n       procedure Set_Digits (S, E : Natural);\n       pragma Inline (Set_Digits);\n@@ -219,9 +194,6 @@ package body System.Img_Dec is\n          --  Constraint_Error will not necessarily be raised if this\n          --  requirement is violated, since it is perfectly valid to compile\n          --  this unit with checks off.\n-         --\n-         --  Due to codepeer limitation, codepeer should be used with switch:\n-         --   -no-propagation system.img_dec.set_decimal_digits.set\n          P := P + 1;\n          S (P) := C;\n       end Set;\n@@ -231,20 +203,16 @@ package body System.Img_Dec is\n       -------------------------\n \n       procedure Set_Blanks_And_Sign (N : Integer) is\n-         W : Integer := N;\n-\n       begin\n          if Minus then\n-            W := W - 1;\n-\n-            for J in 1 .. W loop\n+            for J in 1 .. N - 1 loop\n                Set (' ');\n             end loop;\n \n             Set ('-');\n \n          else\n-            for J in 1 .. W loop\n+            for J in 1 .. N loop\n                Set (' ');\n             end loop;\n          end if;\n@@ -305,15 +273,16 @@ package body System.Img_Dec is\n          --  exponent of +0.\n \n          Expon := (if Zero then 0 else Digits_Before_Point - 1);\n+\n          Set ('E');\n          ND := 0;\n \n          if Expon >= 0 then\n             Set ('+');\n-            Set_Image_Integer (Expon, Digs, ND);\n+            Set_Image_Unsigned (Unsigned (Expon), Digs, ND);\n          else\n             Set ('-');\n-            Set_Image_Integer (-Expon, Digs, ND);\n+            Set_Image_Unsigned (Unsigned (-Expon), Digs, ND);\n          end if;\n \n          Set_Zeroes (Exp - ND - 1);\n@@ -431,24 +400,4 @@ package body System.Img_Dec is\n       end if;\n    end Set_Decimal_Digits;\n \n-   -----------------------\n-   -- Set_Image_Decimal --\n-   -----------------------\n-\n-   procedure Set_Image_Decimal\n-     (V     : Integer;\n-      S     : in out String;\n-      P     : in out Natural;\n-      Scale : Integer;\n-      Fore  : Natural;\n-      Aft   : Natural;\n-      Exp   : Natural)\n-   is\n-      Digs : String := Integer'Image (V);\n-      --  Sign and digits of decimal value\n-\n-   begin\n-      Set_Decimal_Digits (Digs, Digs'Length, S, P, Scale, Fore, Aft, Exp);\n-   end Set_Image_Decimal;\n-\n-end System.Img_Dec;\n+end System.Img_Util;", "previous_filename": "gcc/ada/libgnat/s-imgdec.adb"}, {"sha": "f980bb7d5e1553e1d43627049826a159a8ef1e99", "filename": "gcc/ada/libgnat/s-imguti.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-imguti.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-imguti.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT RUN-TIME COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . I M G _ U T I L                       --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package provides some common utilities used by the s-imgxxx files\n+\n+package System.Img_Util is\n+   pragma Pure;\n+\n+   procedure Set_Decimal_Digits\n+     (Digs  : in out String;\n+      NDigs : Natural;\n+      S     : out String;\n+      P     : in out Natural;\n+      Scale : Integer;\n+      Fore  : Natural;\n+      Aft   : Natural;\n+      Exp   : Natural);\n+   --  Sets the image of Digs (1 .. NDigs), which is a string of decimal digits\n+   --  preceded by either a minus sign or a space, i.e. the integer image of\n+   --  the value in units of delta of a decimal fixed point type with the given\n+   --  Scale, starting at S (P + 1), updating P to point to the last character\n+   --  stored, the caller promises that the buffer is large enough and no check\n+   --  is made for this. Constraint_Error will not necessarily be raised if the\n+   --  requirement is violated since it is perfectly valid to compile this unit\n+   --  with checks off. The Fore, Aft and Exp values can be set to any valid\n+   --  values for the case of use by Text_IO.Decimal_IO. Note that there is no\n+   --  leading space stored. The call may destroy the value in Digs, which is\n+   --  why Digs is in-out (this happens if rounding is required).\n+\n+end System.Img_Util;"}, {"sha": "8edc7424e094baa0eb102840007a479dadf31556", "filename": "gcc/ada/libgnat/s-vade128.ads", "status": "renamed", "additions": 23, "deletions": 31, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vade128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . V A L _ D E C                        --\n+--               S Y S T E M . V A L _ D E C I M A L _ 1 2 8                --\n --                                                                          --\n---                                 B o d y                                  --\n+--                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,40 +29,32 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Val_Real; use System.Val_Real;\n+--  This package contains routines for scanning values for decimal fixed point\n+--  types up to 128-bit mantissa, for use in Text_IO.Decimal_IO, and the Value\n+--  attribute for such decimal types.\n \n-package body System.Val_Dec is\n+with Interfaces;\n+with System.Arith_128;\n+with System.Value_D;\n \n-   ------------------\n-   -- Scan_Decimal --\n-   ------------------\n+package System.Val_Decimal_128 is\n+   pragma Preelaborate;\n \n-   --  For decimal types where Size < Integer'Size, it is fine to use\n-   --  the floating-point circuit, since it certainly has sufficient\n-   --  precision for any reasonable hardware, and we just don't support\n-   --  things on junk hardware.\n+   subtype Int128 is Interfaces.Integer_128;\n+   subtype Uns128 is Interfaces.Unsigned_128;\n \n-   function Scan_Decimal\n+   package Impl is new Value_D (Int128, Uns128, Arith_128.Scaled_Divide128);\n+\n+   function Scan_Decimal128\n      (Str   : String;\n       Ptr   : not null access Integer;\n       Max   : Integer;\n-      Scale : Integer) return Integer\n-   is\n-      Val : Long_Long_Float;\n-   begin\n-      Val := Scan_Real (Str, Ptr, Max);\n-      return Integer (Val * 10.0 ** Scale);\n-   end Scan_Decimal;\n-\n-   -------------------\n-   -- Value_Decimal --\n-   -------------------\n+      Scale : Integer) return Int128\n+     renames Impl.Scan_Decimal;\n \n-   --  Again, we use the real circuit for this purpose\n-\n-   function Value_Decimal (Str : String; Scale : Integer) return Integer is\n-   begin\n-      return Integer (Value_Real (Str) * 10.0 ** Scale);\n-   end Value_Decimal;\n+   function Value_Decimal128\n+     (Str   : String;\n+      Scale : Integer) return Int128\n+    renames Impl.Value_Decimal;\n \n-end System.Val_Dec;\n+end System.Val_Decimal_128;", "previous_filename": "gcc/ada/libgnat/s-valdec.adb"}, {"sha": "b86ae52db18106d85566cdad363c0a8d4ded3ccc", "filename": "gcc/ada/libgnat/s-vade32.ads", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vade32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,58 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                S Y S T E M . V A L _ D E C I M A L _ 3 2                 --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning values for decimal fixed point\n+--  types up to 32-bit mantissa, for use in Text_IO.Decimal_IO, and the Value\n+--  attribute for such decimal types.\n+\n+with Interfaces;\n+with System.Arith_32;\n+with System.Value_D;\n+\n+package System.Val_Decimal_32 is\n+   pragma Preelaborate;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Uns32 is Interfaces.Unsigned_32;\n+\n+   package Impl is new Value_D (Int32, Uns32, Arith_32.Scaled_Divide32);\n+\n+   function Scan_Decimal32\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Scale : Integer) return Int32\n+     renames Impl.Scan_Decimal;\n+\n+   function Value_Decimal32 (Str : String; Scale : Integer) return Int32\n+     renames Impl.Value_Decimal;\n+\n+end System.Val_Decimal_32;"}, {"sha": "d3a5b4f9718483a7a593ec99dd13d720f2eb3cb6", "filename": "gcc/ada/libgnat/s-vade64.ads", "status": "renamed", "additions": 22, "deletions": 32, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vade64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vade64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . V A L _ L L D                        --\n+--                S Y S T E M . V A L _ D E C I M A L _ 6 4                 --\n --                                                                          --\n---                                 B o d y                                  --\n+--                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,42 +29,32 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Val_Real; use System.Val_Real;\n+--  This package contains routines for scanning values for decimal fixed point\n+--  types up to 64-bit mantissa, for use in Text_IO.Decimal_IO, and the Value\n+--  attribute for such decimal types.\n \n-package body System.Val_LLD is\n+with Interfaces;\n+with System.Arith_64;\n+with System.Value_D;\n \n-   ----------------------------\n-   -- Scan_Long_Long_Decimal --\n-   ----------------------------\n+package System.Val_Decimal_64 is\n+   pragma Preelaborate;\n \n-   --  We use the floating-point circuit for now, this will be OK on a PC,\n-   --  but definitely does NOT have the required precision if the longest\n-   --  float type is IEEE double. This must be fixed in the future ???\n+   subtype Int64 is Interfaces.Integer_64;\n+   subtype Uns64 is Interfaces.Unsigned_64;\n \n-   function Scan_Long_Long_Decimal\n+   package Impl is new Value_D (Int64, Uns64, Arith_64.Scaled_Divide64);\n+\n+   function Scan_Decimal64\n      (Str   : String;\n       Ptr   : not null access Integer;\n       Max   : Integer;\n-      Scale : Integer) return Long_Long_Integer\n-   is\n-      Val : Long_Long_Float;\n-   begin\n-      Val := Scan_Real (Str, Ptr, Max);\n-      return Long_Long_Integer (Val * 10.0 ** Scale);\n-   end Scan_Long_Long_Decimal;\n-\n-   -----------------------------\n-   -- Value_Long_Long_Decimal --\n-   -----------------------------\n-\n-   --  Again we cheat and use floating-point ???\n+      Scale : Integer) return Int64\n+     renames Impl.Scan_Decimal;\n \n-   function Value_Long_Long_Decimal\n+   function Value_Decimal64\n      (Str   : String;\n-      Scale : Integer) return Long_Long_Integer\n-   is\n-   begin\n-      return Long_Long_Integer (Value_Real (Str) * 10.0 ** Scale);\n-   end Value_Long_Long_Decimal;\n+      Scale : Integer) return Int64\n+    renames Impl.Value_Decimal;\n \n-end System.Val_LLD;\n+end System.Val_Decimal_64;", "previous_filename": "gcc/ada/libgnat/s-vallld.adb"}, {"sha": "03fbe8049f7943c47abb9144cbab4e5b8b892fc8", "filename": "gcc/ada/libgnat/s-vafi128.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi128.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi128.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vafi128.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                 S Y S T E M . V A L _ F I X E D _ 1 2 8                  --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning values for ordinary fixed point\n+--  types up to 128-bit small and mantissa, for use in Text_IO.Decimal_IO, and\n+--  the Value attribute for such decimal types.\n+\n+with Interfaces;\n+with System.Arith_128;\n+with System.Value_F;\n+\n+package System.Val_Fixed_128 is\n+   pragma Preelaborate;\n+\n+   subtype Int128 is Interfaces.Integer_128;\n+   subtype Uns128 is Interfaces.Unsigned_128;\n+\n+   package Impl is new Value_F (Int128, Uns128, Arith_128.Scaled_Divide128);\n+\n+   function Scan_Fixed128\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int128;\n+      Den : Int128) return Int128\n+     renames Impl.Scan_Fixed;\n+\n+   function Value_Fixed128\n+     (Str : String; Num : Int128; Den : Int128) return Int128\n+     renames Impl.Value_Fixed;\n+\n+end System.Val_Fixed_128;"}, {"sha": "6235a827010b3d0d4e7bad73c50b693aaa502865", "filename": "gcc/ada/libgnat/s-vafi32.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi32.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi32.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vafi32.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . V A L _ F I X E D _ 3 2                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning values for decimal fixed point\n+--  types up to 32-bit small and mantissa, for use in Text_IO.Decimal_IO, and\n+--  the Value attribute for such decimal types.\n+\n+with Interfaces;\n+with System.Arith_32;\n+with System.Value_F;\n+\n+package System.Val_Fixed_32 is\n+   pragma Preelaborate;\n+\n+   subtype Int32 is Interfaces.Integer_32;\n+   subtype Uns32 is Interfaces.Unsigned_32;\n+\n+   package Impl is new Value_F (Int32, Uns32, Arith_32.Scaled_Divide32);\n+\n+   function Scan_Fixed32\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int32;\n+      Den : Int32) return Int32\n+     renames Impl.Scan_Fixed;\n+\n+   function Value_Fixed32\n+     (Str : String; Num : Int32; Den : Int32) return Int32\n+     renames Impl.Value_Fixed;\n+\n+end System.Val_Fixed_32;"}, {"sha": "9f98df47ed3ab7b32792d4ac35fcc9ea46c4cced", "filename": "gcc/ada/libgnat/s-vafi64.ads", "status": "added", "additions": 60, "deletions": 0, "changes": 60, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-vafi64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-vafi64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,60 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                  S Y S T E M . V A L _ F I X E D _ 6 4                   --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning values for decimal fixed point\n+--  types up to 64-bit small and mantissa, for use in Text_IO.Decimal_IO, and\n+--  the Value attribute for such decimal types.\n+\n+with Interfaces;\n+with System.Arith_64;\n+with System.Value_F;\n+\n+package System.Val_Fixed_64 is\n+   pragma Preelaborate;\n+\n+   subtype Int64 is Interfaces.Integer_64;\n+   subtype Uns64 is Interfaces.Unsigned_64;\n+\n+   package Impl is new Value_F (Int64, Uns64, Arith_64.Scaled_Divide64);\n+\n+   function Scan_Fixed64\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int64;\n+      Den : Int64) return Int64\n+     renames Impl.Scan_Fixed;\n+\n+   function Value_Fixed64\n+     (Str : String; Num : Int64; Den : Int64) return Int64\n+     renames Impl.Value_Fixed;\n+\n+end System.Val_Fixed_64;"}, {"sha": "693b261657d9617bbe166b5b99192e995fe5fe8d", "filename": "gcc/ada/libgnat/s-valrea.adb", "status": "modified", "additions": 52, "deletions": 470, "changes": 522, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valrea.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valrea.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -29,282 +29,58 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n-with System.Val_Util;      use System.Val_Util;\n with System.Float_Control;\n+with System.Unsigned_Types; use System.Unsigned_Types;\n+with System.Val_Util;       use System.Val_Util;\n+with System.Value_R;\n \n package body System.Val_Real is\n \n-   procedure Scan_Integral_Digits\n-      (Str            : String;\n-       Index          : in out Integer;\n-       Max            : Integer;\n-       Value          : out Long_Long_Integer;\n-       Scale          : out Integer;\n-       Base_Violation : in out Boolean;\n-       Base           : Long_Long_Integer := 10;\n-       Base_Specified : Boolean := False);\n-   --  Scan the integral part of a real (i.e: before decimal separator)\n-   --\n-   --  The string parsed is Str (Index .. Max), and after the call Index will\n-   --  point to the first non parsed character.\n-   --\n-   --  For each digit parsed either value := value * base + digit, or scale\n-   --  is incremented by 1.\n-   --\n-   --  Base_Violation will be set to True a digit found is not part of the Base\n-\n-   procedure Scan_Decimal_Digits\n-      (Str            : String;\n-       Index          : in out Integer;\n-       Max            : Integer;\n-       Value          : in out Long_Long_Integer;\n-       Scale          : in out Integer;\n-       Base_Violation : in out Boolean;\n-       Base           : Long_Long_Integer := 10;\n-       Base_Specified : Boolean := False);\n-   --  Scan the decimal part of a real (i.e: after decimal separator)\n-   --\n-   --  The string parsed is Str (Index .. Max), and after the call Index will\n-   --  point to the first non parsed character.\n-   --\n-   --  For each digit parsed value = value * base + digit and scale is\n-   --  decremented by 1. If precision limit is reached remaining digits are\n-   --  still parsed but ignored.\n-   --\n-   --  Base_Violation will be set to True a digit found is not part of the Base\n-\n-   subtype Char_As_Digit is Long_Long_Integer range -2 .. 15;\n-   subtype Valid_Digit is Char_As_Digit range 0 .. Char_As_Digit'Last;\n-   Underscore : constant Char_As_Digit := -2;\n-   E_Digit : constant Char_As_Digit := 14;\n-\n-   function As_Digit (C : Character) return Char_As_Digit;\n-   --  Given a character return the digit it represent. If the character is\n-   --  not a digit then a negative value is returned, -2 for underscore and\n-   --  -1 for any other character.\n-\n-   Precision_Limit : constant Long_Long_Integer :=\n-      2 ** (Long_Long_Float'Machine_Mantissa - 1) - 1;\n-   --  This is an upper bound for the number of bits used to represent the\n-   --  mantissa. Beyond that number, any digits parsed are useless.\n-\n-   --------------\n-   -- As_Digit --\n-   --------------\n-\n-   function As_Digit (C : Character) return Char_As_Digit is\n-   begin\n-      case C is\n-         when '0' .. '9' =>\n-            return Character'Pos (C) - Character'Pos ('0');\n-         when 'a' .. 'f' =>\n-            return Character'Pos (C) - (Character'Pos ('a') - 10);\n-         when 'A' .. 'F' =>\n-            return Character'Pos (C) - (Character'Pos ('A') - 10);\n-         when '_' =>\n-            return Underscore;\n-         when others =>\n-            return -1;\n-      end case;\n-   end As_Digit;\n-\n-   -------------------------\n-   -- Scan_Decimal_Digits --\n-   -------------------------\n-\n-   procedure Scan_Decimal_Digits\n-      (Str            : String;\n-       Index          : in out Integer;\n-       Max            : Integer;\n-       Value          : in out Long_Long_Integer;\n-       Scale          : in out Integer;\n-       Base_Violation : in out Boolean;\n-       Base           : Long_Long_Integer := 10;\n-       Base_Specified : Boolean := False)\n-\n+   package Impl is new Value_R (Long_Long_Unsigned, Floating => True);\n+\n+   function Integer_to_Real\n+     (Str   : String;\n+      Val   : Long_Long_Unsigned;\n+      Base  : Unsigned;\n+      Scale : Integer;\n+      Minus : Boolean) return Long_Long_Float;\n+   --  Convert the real value from integer to real representation\n+\n+   ---------------------\n+   -- Integer_to_Real --\n+   ---------------------\n+\n+   function Integer_to_Real\n+     (Str   : String;\n+      Val   : Long_Long_Unsigned;\n+      Base  : Unsigned;\n+      Scale : Integer;\n+      Minus : Boolean) return Long_Long_Float\n    is\n-      Precision_Limit_Reached : Boolean := False;\n-      --  Set to True if addition of a digit will cause Value to be superior\n-      --  to Precision_Limit.\n-\n-      Digit : Char_As_Digit;\n-      --  The current digit.\n+      pragma Unsuppress (Range_Check);\n \n-      Trailing_Zeros : Natural := 0;\n-      --  Number of trailing zeros at a given point.\n+      R_Val : Long_Long_Float;\n \n    begin\n-      pragma Assert (Base in 2 .. 16);\n-\n-      --  If initial Scale is not 0 then it means that Precision_Limit was\n-      --  reached during integral part scanning.\n-      if Scale > 0 then\n-         Precision_Limit_Reached := True;\n-      end if;\n-\n-      --  The function precondition is that the first character is a valid\n-      --  digit.\n-      Digit := As_Digit (Str (Index));\n-\n-      loop\n-         --  Check if base is correct. If the base is not specified the digit\n-         --  E or e cannot be considered as a base violation as it can be used\n-         --  for exponentiation.\n-         if Digit >= Base then\n-            if Base_Specified then\n-               Base_Violation := True;\n-            elsif Digit = E_Digit then\n-               return;\n-            else\n-               Base_Violation := True;\n-            end if;\n-         end if;\n-\n-         --  If precision limit has been reached just ignore any remaining\n-         --  digits for the computation of Value and Scale. The scanning\n-         --  should continue only to assess the validity of the string\n-         if not Precision_Limit_Reached then\n-            if Digit = 0 then\n-               --  Trailing '0' digits are ignored unless a non-zero digit is\n-               --  found.\n-               Trailing_Zeros := Trailing_Zeros + 1;\n-            else\n-\n-               --  Handle accumulated zeros.\n-               for J in 1 .. Trailing_Zeros loop\n-                  if Value > Precision_Limit / Base then\n-                     Precision_Limit_Reached := True;\n-                     exit;\n-                  else\n-                     Value := Value * Base;\n-                     Scale := Scale - 1;\n-                  end if;\n-               end loop;\n-\n-               --  Reset trailing zero counter\n-               Trailing_Zeros := 0;\n-\n-               --  Handle current non zero digit\n-               if Value > (Precision_Limit - Digit) / Base then\n-                  Precision_Limit_Reached := True;\n-               else\n-                  Value := Value * Base + Digit;\n-                  Scale := Scale - 1;\n-               end if;\n-            end if;\n-         end if;\n+      --  We call the floating-point processor reset routine so we can be sure\n+      --  that the processor is properly set for conversions. This is notably\n+      --  needed on Windows, where calls to the operating system randomly reset\n+      --  the processor into 64-bit mode.\n \n-         --  Check next character\n-         Index := Index + 1;\n-\n-         if Index > Max then\n-            return;\n-         end if;\n-\n-         Digit := As_Digit (Str (Index));\n-\n-         if Digit < 0 then\n-            if Digit = Underscore and Index + 1 <= Max then\n-               --  Underscore is only allowed if followed by a digit\n-               Digit := As_Digit (Str (Index + 1));\n-               if Digit in Valid_Digit then\n-                  Index := Index + 1;\n-               else\n-                  return;\n-               end if;\n-            else\n-               --  Neither a valid underscore nor a digit.\n-               return;\n-            end if;\n-         end if;\n-      end loop;\n-   end Scan_Decimal_Digits;\n-\n-   --------------------------\n-   -- Scan_Integral_Digits --\n-   --------------------------\n-\n-   procedure Scan_Integral_Digits\n-      (Str            : String;\n-       Index          : in out Integer;\n-       Max            : Integer;\n-       Value          : out Long_Long_Integer;\n-       Scale          : out Integer;\n-       Base_Violation : in out Boolean;\n-       Base           : Long_Long_Integer := 10;\n-       Base_Specified : Boolean := False)\n-   is\n-      Precision_Limit_Reached : Boolean := False;\n-      --  Set to True if addition of a digit will cause Value to be superior\n-      --  to Precision_Limit.\n-\n-      Digit : Char_As_Digit;\n-      --  The current digit\n-   begin\n-\n-      --  Initialize Scale and Value\n-      Value := 0;\n-      Scale := 0;\n-\n-      --  The function precondition is that the first character is a valid\n-      --  digit.\n-      Digit := As_Digit (Str (Index));\n-\n-      loop\n-         --  Check if base is correct. If the base is not specified the digit\n-         --  E or e cannot be considered as a base violation as it can be used\n-         --  for exponentiation.\n-         if Digit >= Base then\n-            if Base_Specified then\n-               Base_Violation := True;\n-            elsif Digit = E_Digit then\n-               return;\n-            else\n-               Base_Violation := True;\n-            end if;\n-         end if;\n-\n-         if Precision_Limit_Reached then\n-            --  Precision limit has been reached so just update the exponent\n-            Scale := Scale + 1;\n-         else\n-            pragma Assert (Base /= 0);\n+      System.Float_Control.Reset;\n \n-            if Value > (Precision_Limit - Digit) / Base then\n-               --  Updating Value will overflow so ignore this digit and any\n-               --  following ones. Only update the scale\n-               Precision_Limit_Reached := True;\n-               Scale := Scale + 1;\n-            else\n-               Value := Value * Base + Digit;\n-            end if;\n-         end if;\n+      --  Compute the final value\n \n-         --  Look for the next character\n-         Index := Index + 1;\n-         if Index > Max then\n-            return;\n-         end if;\n+      R_Val := Long_Long_Float (Val) * Long_Long_Float (Base) ** Scale;\n \n-         Digit := As_Digit (Str (Index));\n+      --  Finally deal with initial minus sign, note that this processing is\n+      --  done even if Uval is zero, so that -0.0 is correctly interpreted.\n \n-         if Digit not in Valid_Digit then\n-            --  Next character is not a digit. In that case stop scanning\n-            --  unless the next chracter is an underscore followed by a digit.\n-            if Digit = Underscore and Index + 1 <= Max then\n-               Digit := As_Digit (Str (Index + 1));\n-               if Digit in Valid_Digit then\n-                  Index := Index + 1;\n-               else\n-                  return;\n-               end if;\n-            else\n-               return;\n-            end if;\n-         end if;\n-      end loop;\n+      return (if Minus then -R_Val else R_Val);\n \n-   end Scan_Integral_Digits;\n+   exception\n+      when Constraint_Error => Bad_Value (Str);\n+   end Integer_to_Real;\n \n    ---------------\n    -- Scan_Real --\n@@ -315,228 +91,34 @@ package body System.Val_Real is\n        Ptr : not null access Integer;\n        Max : Integer)\n       return Long_Long_Float\n-\n    is\n-      Start : Positive;\n-      --  Position of starting non-blank character\n-\n+      Base  : Unsigned;\n+      Scale : Integer;\n+      Extra : Unsigned;\n       Minus : Boolean;\n-      --  Set to True if minus sign is present, otherwise to False\n-\n-      Index : Integer;\n-      --  Local copy of string pointer\n-\n-      Int_Value : Long_Long_Integer := -1;\n-      --  Mantissa as an Integer\n-\n-      Int_Scale : Integer := 0;\n-      --  Exponent value\n-\n-      Base_Violation : Boolean := False;\n-      --  If True some digits where not in the base. The float is still scan\n-      --  till the end even if an error will be raised.\n-\n-      Uval : Long_Long_Float := 0.0;\n-      --  Contain the final value at the end of the function\n-\n-      After_Point : Boolean := False;\n-      --  True if a decimal should be parsed\n-\n-      Base : Long_Long_Integer := 10;\n-      --  Current base (default: 10)\n-\n-      Base_Char : Character := ASCII.NUL;\n-      --  Character used to set the base. If Nul this means that default\n-      --  base is used.\n+      Val   : Long_Long_Unsigned;\n \n    begin\n-      --  We do not tolerate strings with Str'Last = Positive'Last\n-\n-      if Str'Last = Positive'Last then\n-         raise Program_Error with\n-           \"string upper bound is Positive'Last, not supported\";\n-      end if;\n-\n-      --  We call the floating-point processor reset routine so that we can\n-      --  be sure the floating-point processor is properly set for conversion\n-      --  calls. This is notably need on Windows, where calls to the operating\n-      --  system randomly reset the processor into 64-bit mode.\n-\n-      System.Float_Control.Reset;\n-\n-      --  Scan the optional sign\n-      Scan_Sign (Str, Ptr, Max, Minus, Start);\n-      Index := Ptr.all;\n-      Ptr.all := Start;\n-\n-      --  First character can be either a decimal digit or a dot.\n-      if Str (Index) in '0' .. '9' then\n-         pragma Annotate\n-           (CodePeer, Intentional,\n-            \"test always true\", \"defensive code below\");\n-\n-         --  If this is a digit it can indicates either the float decimal\n-         --  part or the base to use\n-         Scan_Integral_Digits\n-            (Str,\n-             Index,\n-             Max            => Max,\n-             Value          => Int_Value,\n-             Scale          => Int_Scale,\n-             Base_Violation => Base_Violation,\n-             Base           => 10);\n-      elsif Str (Index) = '.' and then\n-         --  A dot is only allowed if followed by a digit.\n-         Index < Max and then\n-         Str (Index + 1) in '0' .. '9'\n-      then\n-         --  Initial point, allowed only if followed by digit (RM 3.5(47))\n-         After_Point := True;\n-         Index := Index + 1;\n-         Int_Value := 0;\n-      else\n-         Bad_Value (Str);\n-      end if;\n-\n-      --  Check if the first number encountered is a base\n-      if Index < Max and then\n-         (Str (Index) = '#' or else Str (Index) = ':')\n-      then\n-         Base_Char := Str (Index);\n-         Base := Int_Value;\n-\n-         --  Reset Int_Value to indicate that parsing of integral value should\n-         --  be done\n-         Int_Value := -1;\n-         if Base < 2 or else Base > 16 then\n-            Base_Violation := True;\n-            Base := 16;\n-         end if;\n-\n-         Index := Index + 1;\n-\n-         if Str (Index) = '.' and then\n-            Index < Max and then\n-            As_Digit (Str (Index + 1)) in Valid_Digit\n-         then\n-            After_Point := True;\n-            Index := Index + 1;\n-            Int_Value := 0;\n-         end if;\n-      end if;\n-\n-      --  Does scanning of integral part needed\n-      if Int_Value < 0 then\n-         if Index > Max or else As_Digit (Str (Index)) not in Valid_Digit then\n-            Bad_Value (Str);\n-         end if;\n-\n-         Scan_Integral_Digits\n-            (Str,\n-             Index,\n-             Max => Max,\n-             Value => Int_Value,\n-             Scale => Int_Scale,\n-             Base_Violation => Base_Violation,\n-             Base => Base,\n-             Base_Specified => Base_Char /= ASCII.NUL);\n-      end if;\n-\n-      --  Do we have a dot ?\n-      if not After_Point and then\n-         Index <= Max and then\n-         Str (Index) = '.'\n-      then\n-         --  At this stage if After_Point was not set, this means that an\n-         --  integral part has been found. Thus the dot is valid even if not\n-         --  followed by a digit.\n-         if Index < Max and then As_Digit (Str (Index + 1)) in Valid_Digit then\n-            After_Point := True;\n-         end if;\n-\n-         Index := Index + 1;\n-      end if;\n-\n-      if After_Point then\n-         --  Parse decimal part\n-         Scan_Decimal_Digits\n-            (Str,\n-             Index,\n-             Max => Max,\n-             Value => Int_Value,\n-             Scale => Int_Scale,\n-             Base_Violation => Base_Violation,\n-             Base => Base,\n-             Base_Specified => Base_Char /= ASCII.NUL);\n-      end if;\n-\n-      --  If an explicit base was specified ensure that the delimiter is found\n-      if Base_Char /= ASCII.NUL then\n-         if Index > Max or else Str (Index) /= Base_Char then\n-            Bad_Value (Str);\n-         else\n-            Index := Index + 1;\n-         end if;\n-      end if;\n-\n-      --  Compute the final value\n-      Uval := Long_Long_Float (Int_Value);\n-\n-      --  Update pointer and scan exponent.\n-      Ptr.all := Index;\n-\n-      Int_Scale := Int_Scale + Scan_Exponent (Str,\n-                                              Ptr,\n-                                              Max,\n-                                              Real => True);\n-\n-      Uval := Uval * Long_Long_Float (Base) ** Int_Scale;\n-\n-      --  Here is where we check for a bad based number\n-      if Base_Violation then\n-         Bad_Value (Str);\n-\n-      --  If OK, then deal with initial minus sign, note that this processing\n-      --  is done even if Uval is zero, so that -0.0 is correctly interpreted.\n-      else\n-         if Minus then\n-            return -Uval;\n-         else\n-            return Uval;\n-         end if;\n-      end if;\n+      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, Scale, Extra, Minus);\n \n+      return Integer_to_Real (Str, Val, Base, Scale, Minus);\n    end Scan_Real;\n \n    ----------------\n    -- Value_Real --\n    ----------------\n \n    function Value_Real (Str : String) return Long_Long_Float is\n-   begin\n-      --  We have to special case Str'Last = Positive'Last because the normal\n-      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n-      --  deal with this by converting to a subtype which fixes the bounds.\n-\n-      if Str'Last = Positive'Last then\n-         declare\n-            subtype NT is String (1 .. Str'Length);\n-         begin\n-            return Value_Real (NT (Str));\n-         end;\n+      Base  : Unsigned;\n+      Scale : Integer;\n+      Extra : Unsigned;\n+      Minus : Boolean;\n+      Val   : Long_Long_Unsigned;\n \n-      --  Normal case where Str'Last < Positive'Last\n+   begin\n+      Val := Impl.Value_Raw_Real (Str, Base, Scale, Extra, Minus);\n \n-      else\n-         declare\n-            V : Long_Long_Float;\n-            P : aliased Integer := Str'First;\n-         begin\n-            V := Scan_Real (Str, P'Access, Str'Last);\n-            Scan_Trailing_Blanks (Str, P);\n-            return V;\n-         end;\n-      end if;\n+      return Integer_to_Real (Str, Val, Base, Scale, Minus);\n    end Value_Real;\n \n end System.Val_Real;"}, {"sha": "5fa8a99648c069535b89695ca6e9219c73bdbfce", "filename": "gcc/ada/libgnat/s-valued.adb", "status": "added", "additions": 257, "deletions": 0, "changes": 257, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valued.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valued.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,257 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ D                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Unsigned_Types; use System.Unsigned_Types;\n+with System.Val_Util;       use System.Val_Util;\n+with System.Value_R;\n+\n+package body System.Value_D is\n+\n+   package Impl is new Value_R (Uns, Floating => False);\n+\n+   function Integer_to_Decimal\n+     (Str    : String;\n+      Val    : Uns;\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Minus  : Boolean;\n+      Scale  : Integer) return Int;\n+   --  Convert the real value from integer to decimal representation\n+\n+   ------------------------\n+   -- Integer_to_Decimal --\n+   ------------------------\n+\n+   function Integer_to_Decimal\n+     (Str    : String;\n+      Val    : Uns;\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Minus  : Boolean;\n+      Scale  : Integer) return Int\n+   is\n+      function Safe_Expont\n+        (Base   : Int;\n+         Exp    : in out Natural;\n+         Factor : Int) return Int;\n+      --  Return (Base ** Exp) * Factor if the computation does not overflow,\n+      --  or else the number of the form (Base ** K) * Factor with the largest\n+      --  magnitude if the former computation overflows. In both cases, Exp is\n+      --  updated to contain the remaining power in the computation. Note that\n+      --  Factor is expected to be positive in this context.\n+\n+      function Unsigned_To_Signed (Val : Uns) return Int;\n+      --  Convert an integer value from unsigned to signed representation\n+\n+      -----------------\n+      -- Safe_Expont --\n+      -----------------\n+\n+      function Safe_Expont\n+        (Base   : Int;\n+         Exp    : in out Natural;\n+         Factor : Int) return Int\n+      is\n+         pragma Assert (Base /= 0 and then Factor > 0);\n+\n+         Max : constant Int := Int'Last / Base;\n+\n+         Result : Int := Factor;\n+\n+      begin\n+         while Exp > 0 and then Result <= Max loop\n+            Result := Result * Base;\n+            Exp    := Exp - 1;\n+         end loop;\n+\n+         return Result;\n+      end Safe_Expont;\n+\n+      ------------------------\n+      -- Unsigned_To_Signed --\n+      ------------------------\n+\n+      function Unsigned_To_Signed (Val : Uns) return Int is\n+      begin\n+         --  Deal with overflow cases, and also with largest negative number\n+\n+         if Val > Uns (Int'Last) then\n+            if Minus and then Val = Uns (-(Int'First)) then\n+               return Int'First;\n+            else\n+               Bad_Value (Str);\n+            end if;\n+\n+         --  Negative values\n+\n+         elsif Minus then\n+            return -(Int (Val));\n+\n+         --  Positive values\n+\n+         else\n+            return Int (Val);\n+         end if;\n+      end Unsigned_To_Signed;\n+\n+   begin\n+      --  If the base of the value is 10 or its scaling factor is zero, then\n+      --  add the scales (they are defined in the opposite sense) and apply\n+      --  the result to the value, checking for overflow in the process.\n+\n+      if Base = 10 or else ScaleB = 0 then\n+         declare\n+            S : Integer := ScaleB + Scale;\n+            V : Uns     := Val;\n+\n+         begin\n+            while S < 0 loop\n+               V := V / 10;\n+               S := S + 1;\n+            end loop;\n+\n+            while S > 0 loop\n+               if V <= Uns'Last / 10 then\n+                  V := V * 10;\n+                  S := S - 1;\n+               else\n+                  Bad_Value (Str);\n+               end if;\n+            end loop;\n+\n+            return Unsigned_To_Signed (V);\n+         end;\n+\n+      --  If the base of the value is not 10, use a scaled divide operation\n+      --  to compute Val * (Base ** ScaleB) * (10 ** Scale).\n+\n+      else\n+         declare\n+            B : constant Int     := Int (Base);\n+            S : constant Integer := ScaleB;\n+\n+            V : Uns := Val;\n+\n+            Y, Z, Q, R : Int;\n+\n+         begin\n+            --  If S is too negative, then drop trailing digits\n+\n+            if S < 0 then\n+               declare\n+                  LS : Integer := -S;\n+\n+               begin\n+                  Y := 10 ** Integer'Max (0, Scale);\n+                  Z := Safe_Expont (B, LS, 10 ** Integer'Max (0, -Scale));\n+\n+                  for J in 1 .. LS loop\n+                     V := V / Uns (B);\n+                  end loop;\n+               end;\n+\n+            --  If S is too positive, then scale V up, which may then overflow\n+\n+            elsif S > 0 then\n+               declare\n+                  LS  : Integer := S;\n+\n+               begin\n+                  Y := Safe_Expont (B, LS, 10 ** Integer'Max (0, Scale));\n+                  Z := 10 ** Integer'Max (0, -Scale);\n+\n+                  for J in 1 .. LS loop\n+                     if V <= Uns'Last / Uns (B) then\n+                        V := V * Uns (B);\n+                     else\n+                        Bad_Value (Str);\n+                     end if;\n+                  end loop;\n+               end;\n+\n+            --  The case S equal to zero should have been handled earlier\n+\n+            else\n+               raise Program_Error;\n+            end if;\n+\n+            --  Perform a scale divide operation with rounding to match 'Image\n+\n+            Scaled_Divide (Unsigned_To_Signed (V), Y, Z, Q, R, Round => True);\n+\n+            return Q;\n+         end;\n+      end if;\n+\n+   exception\n+      when Constraint_Error => Bad_Value (Str);\n+   end Integer_to_Decimal;\n+\n+   ------------------\n+   -- Scan_Decimal --\n+   ------------------\n+\n+   function Scan_Decimal\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Scale : Integer) return Int\n+   is\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Val    : Uns;\n+\n+   begin\n+      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, ScaleB, Extra, Minus);\n+\n+      return Integer_to_Decimal (Str, Val, Base, ScaleB, Minus, Scale);\n+   end Scan_Decimal;\n+\n+   -------------------\n+   -- Value_Decimal --\n+   -------------------\n+\n+   function Value_Decimal (Str : String; Scale : Integer) return Int is\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Val    : Uns;\n+\n+   begin\n+      Val := Impl.Value_Raw_Real (Str, Base, ScaleB, Extra, Minus);\n+\n+      return Integer_to_Decimal (Str, Val, Base, ScaleB, Minus, Scale);\n+   end Value_Decimal;\n+\n+end System.Value_D;"}, {"sha": "e27e1714c178ad9247dddb1dbf97bb40612615b2", "filename": "gcc/ada/libgnat/s-valued.ads", "status": "renamed", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valued.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valued.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valued.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . V A L _ D E C                        --\n+--                       S Y S T E M . V A L U E _ D                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---            Copyright (C) 1992-2020, Free Software Foundation, Inc.       --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,18 +29,29 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains routines for scanning decimal values where the size\n---  of the type is no greater than Standard.Integer'Size, for use in Text_IO.\n---  Decimal_IO, and the Value attribute for such decimal types.\n+--  This package contains the routines for supporting the Value attribute for\n+--  decimal fixed point types, and also for conversion operations required in\n+--  Text_IO.Decimal_IO for such types.\n \n-package System.Val_Dec is\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+   with procedure Scaled_Divide\n+          (X, Y, Z : Int;\n+           Q, R : out Int;\n+           Round : Boolean);\n+\n+package System.Value_D is\n    pragma Preelaborate;\n \n    function Scan_Decimal\n      (Str   : String;\n       Ptr   : not null access Integer;\n       Max   : Integer;\n-      Scale : Integer) return Integer;\n+      Scale : Integer) return Int;\n    --  This function scans the string starting at Str (Ptr.all) for a valid\n    --  real literal according to the syntax described in (RM 3.5(43)). The\n    --  substring scanned extends no further than Str (Max). There are three\n@@ -49,8 +60,8 @@ package System.Val_Dec is\n    --  If a valid real literal is found after scanning past any initial spaces,\n    --  then Ptr.all is updated past the last character of the literal (but\n    --  trailing spaces are not scanned out). The value returned is the value\n-   --  Integer'Integer_Value (decimal-literal-value), using the given Scale\n-   --  to determine this value.\n+   --  Int'Integer_Value (decimal-literal-value), using the given Scale to\n+   --  determine this value.\n    --\n    --  If no valid real literal is found, then Ptr.all points either to an\n    --  initial non-digit character, or to Max + 1 if the field is all spaces\n@@ -68,13 +79,12 @@ package System.Val_Dec is\n    --  special case of an all-blank string, and Ptr is unchanged, and hence\n    --  is greater than Max as required in this case.\n \n-   function Value_Decimal (Str : String; Scale : Integer) return Integer;\n-   --  Used in computing X'Value (Str) where X is a decimal fixed-point type\n-   --  whose size does not exceed Standard.Integer'Size. Str is the string\n-   --  argument of the attribute. Constraint_Error is raised if the string\n-   --  is malformed or if the value is out of range of Integer (not the\n-   --  range of the fixed-point type, that check must be done by the caller.\n-   --  Otherwise the value returned is the value Integer'Integer_Value\n+   function Value_Decimal (Str : String; Scale : Integer) return Int;\n+   --  Used in computing X'Value (Str) where X is a decimal fixed-point type.\n+   --  Str is the string argument of the attribute. Constraint_Error is raised\n+   --  if the string is malformed or if the value is out of range of Int (not\n+   --  the range of the fixed-point type, which must be done by the caller).\n+   --  Otherwise the value returned is the value Int'Integer_Value\n    --  (decimal-literal-value), using Scale to determine this value.\n \n-end System.Val_Dec;\n+end System.Value_D;", "previous_filename": "gcc/ada/libgnat/s-valdec.ads"}, {"sha": "f3ed5fa972c178e8d7dc8bdaebaf90dba009af65", "filename": "gcc/ada/libgnat/s-valuef.adb", "status": "added", "additions": 332, "deletions": 0, "changes": 332, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuef.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,332 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ F                        --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Unsigned_Types; use System.Unsigned_Types;\n+with System.Val_Util;       use System.Val_Util;\n+with System.Value_R;\n+\n+package body System.Value_F is\n+\n+   package Impl is new Value_R (Uns, Floating => False);\n+\n+   function Integer_To_Fixed\n+     (Str    : String;\n+      Val    : Uns;\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Num    : Int;\n+      Den    : Int) return Int;\n+   --  Convert the real value from integer to fixed point representation\n+\n+   --  The goal is to compute Val * (Base ** ScaleB) / (Num / Den) with correct\n+   --  rounding for all decimal values output by Typ'Image, that is to say up\n+   --  to Typ'Aft decimal digits. Unlike for the output, the RM does not say\n+   --  what the rounding must be for the input, but a reasonable exegesis of\n+   --  the intent is that Typ'Value o Typ'Image should be the identity, which\n+   --  is made possible because 'Aft is defined such that 'Image is injective.\n+\n+   --  For a type with a mantissa of M bits including the sign, the number N1\n+   --  of decimal digits required to represent all the numbers is given by:\n+\n+   --    N1 = ceil ((M - 1) * log 2 / log 10) [N1 = 10/19/39 for M = 32/64/128]\n+\n+   --  but this mantissa can represent any set of contiguous numbers with only\n+   --  N2 different decimal digits where:\n+\n+   --    N2 = floor ((M - 1) * log 2 / log 10) [N2 = 9/18/38 for M = 32/64/128]\n+\n+   --  Of course N1 = N2 + 1 holds, which means both that Val may not contain\n+   --  enough significant bits to represent all the values of the type and that\n+   --  1 extra decimal digit contains the information for the missing bits.\n+\n+   --  Therefore the actual computation to be performed is\n+\n+   --    V = (Val * Base + Extra) * (Base ** (ScaleB - 1)) / (Num / Den)\n+\n+   --  using two steps of scaled divide if Extra is non-zero\n+\n+   --    (1)  Val * ((Base ** ScaleB) * Den) = Q1 * Num + R1\n+\n+   --    (2)  Extra * ((Base ** ScaleB) * Den) = Q2 * (-Base) + R2\n+\n+   --  which yields after dividing (1) by Num and (2) by Num * Base and summing\n+\n+   --    V = Q1 + (R1 - Q2) / Num + R2 / (Num * Base)\n+\n+   --  but we get rid of the third term by using a rounding divide for (2).\n+\n+   ----------------------\n+   -- Integer_To_Fixed --\n+   ----------------------\n+\n+   function Integer_To_Fixed\n+     (Str    : String;\n+      Val    : Uns;\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Num    : Int;\n+      Den    : Int) return Int\n+   is\n+      pragma Assert (Base in 2 .. 16);\n+\n+      pragma Assert (Extra < Base);\n+      --  Accept only one extra digit after those used for Val\n+\n+      pragma Assert (Num < 0 and then Den < 0);\n+      --  Accept only negative numbers to allow -2**(Int'Size - 1)\n+\n+      function Safe_Expont\n+        (Base   : Int;\n+         Exp    : in out Natural;\n+         Factor : Int) return Int;\n+      --  Return (Base ** Exp) * Factor if the computation does not overflow,\n+      --  or else the number of the form (Base ** K) * Factor with the largest\n+      --  magnitude if the former computation overflows. In both cases, Exp is\n+      --  updated to contain the remaining power in the computation. Note that\n+      --  Factor is expected to be negative in this context.\n+\n+      function Unsigned_To_Signed (Val : Uns) return Int;\n+      --  Convert an integer value from unsigned to signed representation\n+\n+      -----------------\n+      -- Safe_Expont --\n+      -----------------\n+\n+      function Safe_Expont\n+        (Base   : Int;\n+         Exp    : in out Natural;\n+         Factor : Int) return Int\n+      is\n+         pragma Assert (Base /= 0 and then Factor < 0);\n+\n+         Min : constant Int := Int'First / Base;\n+\n+         Result : Int := Factor;\n+\n+      begin\n+         while Exp > 0 and then Result >= Min loop\n+            Result := Result * Base;\n+            Exp    := Exp - 1;\n+         end loop;\n+\n+         return Result;\n+      end Safe_Expont;\n+\n+      ------------------------\n+      -- Unsigned_To_Signed --\n+      ------------------------\n+\n+      function Unsigned_To_Signed (Val : Uns) return Int is\n+      begin\n+         --  Deal with overflow cases, and also with largest negative number\n+\n+         if Val > Uns (Int'Last) then\n+            if Minus and then Val = Uns (-(Int'First)) then\n+               return Int'First;\n+            else\n+               Bad_Value (Str);\n+            end if;\n+\n+         --  Negative values\n+\n+         elsif Minus then\n+            return -(Int (Val));\n+\n+         --  Positive values\n+\n+         else\n+            return Int (Val);\n+         end if;\n+      end Unsigned_To_Signed;\n+\n+      --  Local variables\n+\n+      B : constant Int := Int (Base);\n+\n+      V : Uns     := Val;\n+      S : Integer := ScaleB;\n+      E : Uns     := Uns (Extra);\n+      N : Int     := Num;\n+      D : Int     := Den;\n+\n+      Y, Z, Q1, R1, Q2, R2 : Int;\n+\n+   begin\n+      --  We will use a scaled divide operation for which we must control the\n+      --  magnitude of operands so that an overflow exception is not unduly\n+      --  raised during the computation. The only real concern is the exponent\n+      --  ScaleB so first try to reduce its magnitude in an exact manner.\n+\n+      while S < 0 and then (D rem B) = 0 loop\n+         D := D / B;\n+         S := S + 1;\n+      end loop;\n+\n+      while S > 0 and then (N rem B) = 0 loop\n+         N := N / B;\n+         S := S - 1;\n+      end loop;\n+\n+      --  If S is still too negative, then drop trailing digits, but preserve\n+      --  the last dropped digit.\n+\n+      if S < 0 then\n+         declare\n+            LS : Integer := -S;\n+\n+         begin\n+            Y := D;\n+            Z := Safe_Expont (B, LS, N);\n+\n+            for J in 1 .. LS loop\n+               E := V rem Uns (B);\n+               V := V / Uns (B);\n+            end loop;\n+         end;\n+\n+      --  If S is still too positive, then scale V up, which may then overflow\n+\n+      elsif S > 0 then\n+         declare\n+            LS  : Integer := S;\n+\n+         begin\n+            Y := Safe_Expont (B, LS, D);\n+            Z := N;\n+\n+            for J in 1 .. LS loop\n+               if V <= Uns'Last / Uns (B) then\n+                  V := V * Uns (B);\n+               else\n+                  Bad_Value (Str);\n+               end if;\n+            end loop;\n+         end;\n+\n+      --  If S is zero, then proceed directly\n+\n+      else\n+         Y := D;\n+         Z := N;\n+      end if;\n+\n+      --  Perform a scaled divide operation with final rounding to match Image\n+      --  using two steps if there is an extra digit available. The second and\n+      --  third operands are always negative so the sign of the quotient is the\n+      --  sign of the first operand and the sign of the remainder the opposite.\n+\n+      if E /= 0 then\n+         Scaled_Divide (Unsigned_To_Signed (V), Y, Z, Q1, R1, Round => False);\n+         Scaled_Divide (Unsigned_To_Signed (E), Y, -B, Q2, R2, Round => True);\n+\n+         --  Avoid an overflow during the subtraction. Note that Q2 is smaller\n+         --  than Y and R1 smaller than Z in magnitude, so it is safe to take\n+         --  their absolute value.\n+\n+         if abs Q2 >= 2 ** (Int'Size - 2)\n+           or else abs R1 >= 2 ** (Int'Size - 2)\n+         then\n+            declare\n+               Bit : constant Int := Q2 rem 2;\n+\n+            begin\n+               Q2 := (Q2 - Bit) / 2;\n+               R1 := (R1 - Bit) / 2;\n+               Y  := -2;\n+            end;\n+\n+         else\n+            Y := -1;\n+         end if;\n+\n+         Scaled_Divide (Q2 - R1, Y, Z, Q2, R2, Round => True);\n+\n+         return Q1 + Q2;\n+\n+      else\n+         Scaled_Divide (Unsigned_To_Signed (V), Y, Z, Q1, R1, Round => True);\n+\n+         return Q1;\n+      end if;\n+\n+   exception\n+      when Constraint_Error => Bad_Value (Str);\n+   end Integer_To_Fixed;\n+\n+   ----------------\n+   -- Scan_Fixed --\n+   ----------------\n+\n+   function Scan_Fixed\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int;\n+      Den : Int) return Int\n+   is\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Val    : Uns;\n+\n+   begin\n+      Val := Impl.Scan_Raw_Real (Str, Ptr, Max, Base, ScaleB, Extra, Minus);\n+\n+      return Integer_To_Fixed (Str, Val, Base, ScaleB, Extra, Minus, Num, Den);\n+   end Scan_Fixed;\n+\n+   -----------------\n+   -- Value_Fixed --\n+   -----------------\n+\n+   function Value_Fixed\n+     (Str : String;\n+      Num : Int;\n+      Den : Int) return Int\n+   is\n+      Base   : Unsigned;\n+      ScaleB : Integer;\n+      Extra  : Unsigned;\n+      Minus  : Boolean;\n+      Val    : Uns;\n+\n+   begin\n+      Val := Impl.Value_Raw_Real (Str, Base, ScaleB, Extra, Minus);\n+\n+      return Integer_To_Fixed (Str, Val, Base, ScaleB, Extra, Minus, Num, Den);\n+   end Value_Fixed;\n+\n+end System.Value_F;"}, {"sha": "fac8c236c4f3dee76f9443c80a65dca7261a424a", "filename": "gcc/ada/libgnat/s-valuef.ads", "status": "renamed", "additions": 36, "deletions": 23, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuef.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuef.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuef.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -2,11 +2,11 @@\n --                                                                          --\n --                         GNAT COMPILER COMPONENTS                         --\n --                                                                          --\n---                       S Y S T E M . V A L _ L L D                        --\n+--                       S Y S T E M . V A L U E _ F                        --\n --                                                                          --\n --                                 S p e c                                  --\n --                                                                          --\n---          Copyright (C) 1992-2020, Free Software Foundation, Inc.         --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -29,18 +29,30 @@\n --                                                                          --\n ------------------------------------------------------------------------------\n \n---  This package contains routines for scanning decimal values where the size\n---  of the type is greater than Standard.Integer'Size, for use in Text_IO.\n---  Decimal_IO, and the Value attribute for such decimal types.\n+--  This package contains the routines for supporting the Value attribute for\n+--  ordinary fixed point types, and also for conversion operations required in\n+--  Text_IO.Fixed_IO for such types.\n \n-package System.Val_LLD is\n+generic\n+\n+   type Int is range <>;\n+\n+   type Uns is mod <>;\n+\n+   with procedure Scaled_Divide\n+          (X, Y, Z : Int;\n+           Q, R : out Int;\n+           Round : Boolean);\n+\n+package System.Value_F is\n    pragma Preelaborate;\n \n-   function Scan_Long_Long_Decimal\n-     (Str   : String;\n-      Ptr   : not null access Integer;\n-      Max   : Integer;\n-      Scale : Integer) return Long_Long_Integer;\n+   function Scan_Fixed\n+     (Str : String;\n+      Ptr : not null access Integer;\n+      Max : Integer;\n+      Num : Int;\n+      Den : Int) return Int;\n    --  This function scans the string starting at Str (Ptr.all) for a valid\n    --  real literal according to the syntax described in (RM 3.5(43)). The\n    --  substring scanned extends no further than Str (Max). There are three\n@@ -49,8 +61,8 @@ package System.Val_LLD is\n    --  If a valid real literal is found after scanning past any initial spaces,\n    --  then Ptr.all is updated past the last character of the literal (but\n    --  trailing spaces are not scanned out). The value returned is the value\n-   --  Long_Long_Integer'Integer_Value (decimal-literal-value), using the given\n-   --  Scale to determine this value.\n+   --  Int'Integer_Value (decimal-literal-value), using the given Num/Den to\n+   --  determine this value.\n    --\n    --  If no valid real literal is found, then Ptr.all points either to an\n    --  initial non-digit character, or to Max + 1 if the field is all spaces\n@@ -68,14 +80,15 @@ package System.Val_LLD is\n    --  special case of an all-blank string, and Ptr is unchanged, and hence\n    --  is greater than Max as required in this case.\n \n-   function Value_Long_Long_Decimal\n-     (Str   : String;\n-      Scale : Integer) return Long_Long_Integer;\n-   --  Used in computing X'Value (Str) where X is a decimal types whose size\n-   --  exceeds Standard.Integer'Size. Str is the string argument of the\n-   --  attribute. Constraint_Error is raised if the string is malformed\n-   --  or if the value is out of range, otherwise the value returned is the\n-   --  value Long_Long_Integer'Integer_Value (decimal-literal-value), using\n-   --  the given Scale to determine this value.\n+   function Value_Fixed\n+     (Str : String;\n+      Num : Int;\n+      Den : Int) return Int;\n+   --  Used in computing X'Value (Str) where X is an ordinary fixed-point type.\n+   --  Str is the string argument of the attribute. Constraint_Error is raised\n+   --  if the string is malformed or if the value is out of range of Int (not\n+   --  the range of the fixed-point type, which must be done by the caller).\n+   --  Otherwise the value returned is the value Int'Integer_Value\n+   --  (decimal-literal-value), using Small Num/Den to determine this value.\n \n-end System.Val_LLD;\n+end System.Value_F;", "previous_filename": "gcc/ada/libgnat/s-vallld.ads"}, {"sha": "ac5a7761c65c0d07beecb01f81388e6acf921a08", "filename": "gcc/ada/libgnat/s-valuei.adb", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuei.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuei.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -61,7 +61,7 @@ package body System.Value_I is\n \n       Uval := Scan_Raw_Unsigned (Str, Ptr, Max);\n \n-      --  Deal with overflow cases, and also with maximum negative number\n+      --  Deal with overflow cases, and also with largest negative number\n \n       if Uval > Uns (Int'Last) then\n          if Minus and then Uval = Uns (-(Int'First)) then"}, {"sha": "a91fbb868691dd0f6982d2a263a06c9e95403ed2", "filename": "gcc/ada/libgnat/s-valuer.adb", "status": "added", "additions": 582, "deletions": 0, "changes": 582, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuer.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,582 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                      S Y S T E M . V A L U E _ R                         --\n+--                                                                          --\n+--                                 B o d y                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+with System.Val_Util; use System.Val_Util;\n+\n+package body System.Value_R is\n+\n+   F_Limit : constant Uns := 2 ** (Long_Long_Float'Machine_Mantissa - 1);\n+   I_Limit : constant Uns := 2 ** (Uns'Size - 1);\n+   --  Absolute value of largest representable signed integer\n+\n+   Precision_Limit : constant Uns := (if Floating then F_Limit else I_Limit);\n+   --  Limit beyond which additional digits are dropped\n+\n+   subtype Char_As_Digit is Unsigned range 0 .. 17;\n+   subtype Valid_Digit is Char_As_Digit range 0 .. 15;\n+   E_Digit     : constant Char_As_Digit := 14;\n+   Underscore  : constant Char_As_Digit := 16;\n+   Not_A_Digit : constant Char_As_Digit := 17;\n+\n+   function As_Digit (C : Character) return Char_As_Digit;\n+   --  Given a character return the digit it represents\n+\n+   procedure Scan_Decimal_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : in out Uns;\n+       Scale          : in out Integer;\n+       Extra          : in out Char_As_Digit;\n+       Base_Violation : in out Boolean;\n+       Base           : Unsigned;\n+       Base_Specified : Boolean);\n+   --  Scan the decimal part of a real (i.e. after decimal separator)\n+   --\n+   --  The string parsed is Str (Index .. Max) and after the call Index will\n+   --  point to the first non-parsed character.\n+   --\n+   --  For each digit parsed, Value = Value * Base + Digit and Scale is\n+   --  decremented by 1. If precision limit is reached, remaining digits are\n+   --  still parsed but ignored, except for the first which is stored in Extra.\n+   --\n+   --  Base_Violation is set to True if a digit found is not part of the Base\n+   --\n+   --  If Base_Specified is set, then the base was specified in the real\n+\n+   procedure Scan_Integral_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : out Uns;\n+       Scale          : out Integer;\n+       Extra          : out Char_As_Digit;\n+       Base_Violation : in out Boolean;\n+       Base           : Unsigned;\n+       Base_Specified : Boolean);\n+   --  Scan the integral part of a real (i.e. before decimal separator)\n+   --\n+   --  The string parsed is Str (Index .. Max) and after the call Index will\n+   --  point to the first non-parsed character.\n+   --\n+   --  For each digit parsed, either Value := Value * Base + Digit or Scale\n+   --  is incremented by 1 if precision limit is reached, in which case the\n+   --  remaining digits are still parsed but ignored, except for the first\n+   --  which is stored in Extra.\n+   --\n+   --  Base_Violation is set to True if a digit found is not part of the Base\n+   --\n+   --  If Base_Specified is set, then the base was specified in the real\n+\n+   --------------\n+   -- As_Digit --\n+   --------------\n+\n+   function As_Digit (C : Character) return Char_As_Digit is\n+   begin\n+      case C is\n+         when '0' .. '9' =>\n+            return Character'Pos (C) - Character'Pos ('0');\n+         when 'a' .. 'f' =>\n+            return Character'Pos (C) - (Character'Pos ('a') - 10);\n+         when 'A' .. 'F' =>\n+            return Character'Pos (C) - (Character'Pos ('A') - 10);\n+         when '_' =>\n+            return Underscore;\n+         when others =>\n+            return Not_A_Digit;\n+      end case;\n+   end As_Digit;\n+\n+   -------------------------\n+   -- Scan_Decimal_Digits --\n+   -------------------------\n+\n+   procedure Scan_Decimal_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : in out Uns;\n+       Scale          : in out Integer;\n+       Extra          : in out Char_As_Digit;\n+       Base_Violation : in out Boolean;\n+       Base           : Unsigned;\n+       Base_Specified : Boolean)\n+\n+   is\n+      pragma Assert (Base in 2 .. 16);\n+\n+      Umax : constant Uns := (Precision_Limit - Uns (Base) + 1) / Uns (Base);\n+      --  Max value which cannot overflow on accumulating next digit\n+\n+      UmaxB : constant Uns := Precision_Limit / Uns (Base);\n+      --  Numbers bigger than UmaxB overflow if multiplied by base\n+\n+      Precision_Limit_Reached : Boolean := False;\n+      --  Set to True if addition of a digit will cause Value to be superior\n+      --  to Precision_Limit.\n+\n+      Digit : Char_As_Digit;\n+      --  The current digit\n+\n+      Temp : Uns;\n+      --  Temporary\n+\n+      Trailing_Zeros : Natural := 0;\n+      --  Number of trailing zeros at a given point\n+\n+   begin\n+      --  If initial Scale is not 0 then it means that Precision_Limit was\n+      --  reached during scanning of the integral part.\n+\n+      if Scale > 0 then\n+         Precision_Limit_Reached := True;\n+      else\n+         Extra := 0;\n+      end if;\n+\n+      --  The function precondition is that the first character is a valid\n+      --  digit.\n+\n+      Digit := As_Digit (Str (Index));\n+\n+      loop\n+         --  Check if base is correct. If the base is not specified, the digit\n+         --  E or e cannot be considered as a base violation as it can be used\n+         --  for exponentiation.\n+\n+         if Digit >= Base then\n+            if Base_Specified then\n+               Base_Violation := True;\n+            elsif Digit = E_Digit then\n+               return;\n+            else\n+               Base_Violation := True;\n+            end if;\n+         end if;\n+\n+         --  If precision limit has been reached, just ignore any remaining\n+         --  digits for the computation of Value and Scale, but store the\n+         --  first in Extra. The scanning should continue only to assess the\n+         --  validity of the string.\n+\n+         if not Precision_Limit_Reached then\n+\n+            --  Trailing '0' digits are ignored until a non-zero digit is found\n+\n+            if Digit = 0 then\n+               Trailing_Zeros := Trailing_Zeros + 1;\n+\n+            else\n+               --  Handle accumulated zeros.\n+\n+               for J in 1 .. Trailing_Zeros loop\n+                  if Value <= UmaxB then\n+                     Value := Value * Uns (Base);\n+                     Scale := Scale - 1;\n+\n+                  else\n+                     Precision_Limit_Reached := True;\n+                     exit;\n+                  end if;\n+               end loop;\n+\n+               --  Reset trailing zero counter\n+\n+               Trailing_Zeros := 0;\n+\n+               --  Handle current non zero digit\n+\n+               Temp := Value * Uns (Base) + Uns (Digit);\n+\n+               if Value <= Umax\n+                   or else (Value <= UmaxB and then Temp <= Precision_Limit)\n+               then\n+                  Value := Temp;\n+                  Scale := Scale - 1;\n+\n+               else\n+                  Extra := Digit;\n+                  Precision_Limit_Reached := True;\n+               end if;\n+            end if;\n+         end if;\n+\n+         --  Check next character\n+\n+         Index := Index + 1;\n+\n+         if Index > Max then\n+            return;\n+         end if;\n+\n+         Digit := As_Digit (Str (Index));\n+\n+         if Digit not in Valid_Digit then\n+\n+            --  Underscore is only allowed if followed by a digit\n+\n+            if Digit = Underscore and Index + 1 <= Max then\n+\n+               Digit := As_Digit (Str (Index + 1));\n+               if Digit in Valid_Digit then\n+                  Index := Index + 1;\n+               else\n+                  return;\n+               end if;\n+\n+            --  Neither a valid underscore nor a digit\n+\n+            else\n+               return;\n+            end if;\n+         end if;\n+      end loop;\n+   end Scan_Decimal_Digits;\n+\n+   --------------------------\n+   -- Scan_Integral_Digits --\n+   --------------------------\n+\n+   procedure Scan_Integral_Digits\n+      (Str            : String;\n+       Index          : in out Integer;\n+       Max            : Integer;\n+       Value          : out Uns;\n+       Scale          : out Integer;\n+       Extra          : out Char_As_Digit;\n+       Base_Violation : in out Boolean;\n+       Base           : Unsigned;\n+       Base_Specified : Boolean)\n+   is\n+      pragma Assert (Base in 2 .. 16);\n+\n+      Umax : constant Uns := (Precision_Limit - Uns (Base) + 1) / Uns (Base);\n+      --  Max value which cannot overflow on accumulating next digit\n+\n+      UmaxB : constant Uns := Precision_Limit / Uns (Base);\n+      --  Numbers bigger than UmaxB overflow if multiplied by base\n+\n+      Precision_Limit_Reached : Boolean := False;\n+      --  Set to True if addition of a digit will cause Value to be superior\n+      --  to Precision_Limit.\n+\n+      Digit : Char_As_Digit;\n+      --  The current digit\n+\n+      Temp : Uns;\n+      --  Temporary\n+\n+   begin\n+      --  Initialize Value, Scale and Extra\n+\n+      Value := 0;\n+      Scale := 0;\n+      Extra := 0;\n+\n+      --  The function precondition is that the first character is a valid\n+      --  digit.\n+\n+      Digit := As_Digit (Str (Index));\n+\n+      loop\n+         --  Check if base is correct. If the base is not specified, the digit\n+         --  E or e cannot be considered as a base violation as it can be used\n+         --  for exponentiation.\n+\n+         if Digit >= Base then\n+            if Base_Specified then\n+               Base_Violation := True;\n+            elsif Digit = E_Digit then\n+               return;\n+            else\n+               Base_Violation := True;\n+            end if;\n+         end if;\n+\n+         --  If precision limit has been reached, just ignore any remaining\n+         --  digits for the computation of Value, but update Scale and store\n+         --  the first in Extra. The scanning should continue only to assess\n+         --  the validity of the string.\n+\n+         if Precision_Limit_Reached then\n+            Scale := Scale + 1;\n+\n+         else\n+            Temp := Value * Uns (Base) + Uns (Digit);\n+\n+            if Value <= Umax\n+              or else (Value <= UmaxB and then Temp <= Precision_Limit)\n+            then\n+               Value := Temp;\n+\n+            else\n+               Extra := Digit;\n+               Precision_Limit_Reached := True;\n+               Scale := Scale + 1;\n+            end if;\n+         end if;\n+\n+         --  Look for the next character\n+\n+         Index := Index + 1;\n+         if Index > Max then\n+            return;\n+         end if;\n+\n+         Digit := As_Digit (Str (Index));\n+\n+         if Digit not in Valid_Digit then\n+\n+            --  Next character is not a digit. In that case stop scanning\n+            --  unless the next chracter is an underscore followed by a digit.\n+\n+            if Digit = Underscore and Index + 1 <= Max then\n+               Digit := As_Digit (Str (Index + 1));\n+               if Digit in Valid_Digit then\n+                  Index := Index + 1;\n+               else\n+                  return;\n+               end if;\n+            else\n+               return;\n+            end if;\n+         end if;\n+      end loop;\n+\n+   end Scan_Integral_Digits;\n+\n+   -------------------\n+   -- Scan_Raw_Real --\n+   -------------------\n+\n+   function Scan_Raw_Real\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Base  : out Unsigned;\n+      Scale : out Integer;\n+      Extra : out Unsigned;\n+      Minus : out Boolean) return Uns\n+   is\n+      After_Point : Boolean;\n+      --  True if a decimal should be parsed\n+\n+      Base_Char : Character := ASCII.NUL;\n+      --  Character used to set the base. If Nul this means that default\n+      --  base is used.\n+\n+      Base_Violation : Boolean := False;\n+      --  If True some digits where not in the base. The real is still scanned\n+      --  till the end even if an error will be raised.\n+\n+      Index : Integer;\n+      --  Local copy of string pointer\n+\n+      Start : Positive;\n+      --  Position of starting non-blank character\n+\n+      Value : Uns;\n+      --  Mantissa as an Integer\n+\n+   begin\n+      --  The default base is 10\n+\n+      Base := 10;\n+\n+      --  We do not tolerate strings with Str'Last = Positive'Last\n+\n+      if Str'Last = Positive'Last then\n+         raise Program_Error with\n+           \"string upper bound is Positive'Last, not supported\";\n+      end if;\n+\n+      --  Scan the optional sign\n+\n+      Scan_Sign (Str, Ptr, Max, Minus, Start);\n+      Index := Ptr.all;\n+      Ptr.all := Start;\n+\n+      --  First character can be either a decimal digit or a dot\n+\n+      if Str (Index) in '0' .. '9' then\n+         After_Point := False;\n+\n+         pragma Annotate\n+           (CodePeer, Intentional, \"test always true\", \"defensive code below\");\n+\n+         --  If this is a digit it can indicates either the float decimal\n+         --  part or the base to use.\n+\n+         Scan_Integral_Digits\n+           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n+            Base_Violation, Base, Base_Specified => False);\n+\n+      --  A dot is allowed only if followed by a digit (RM 3.5(47))\n+\n+      elsif Str (Index) = '.'\n+        and then Index < Max\n+        and then Str (Index + 1) in '0' .. '9'\n+      then\n+         After_Point := True;\n+         Index := Index + 1;\n+         Value := 0;\n+         Scale := 0;\n+         Extra := 0;\n+\n+      else\n+         Bad_Value (Str);\n+      end if;\n+\n+      --  Check if the first number encountered is a base\n+\n+      if Index < Max\n+        and then (Str (Index) = '#' or else Str (Index) = ':')\n+      then\n+         Base_Char := Str (Index);\n+         Base := Unsigned (Value);\n+\n+         if Base < 2 or else Base > 16 then\n+            Base_Violation := True;\n+            Base := 16;\n+         end if;\n+\n+         Index := Index + 1;\n+\n+         if Str (Index) = '.'\n+           and then Index < Max\n+           and then As_Digit (Str (Index + 1)) in Valid_Digit\n+         then\n+            After_Point := True;\n+            Index := Index + 1;\n+            Value := 0;\n+         end if;\n+      end if;\n+\n+      --  Scan the integral part if still necessary\n+\n+      if Base_Char /= ASCII.NUL and then not After_Point then\n+         if Index > Max or else As_Digit (Str (Index)) not in Valid_Digit then\n+            Bad_Value (Str);\n+         end if;\n+\n+         Scan_Integral_Digits\n+           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n+            Base_Violation, Base, Base_Specified => Base_Char /= ASCII.NUL);\n+      end if;\n+\n+      --  Do we have a dot?\n+\n+      if not After_Point and then Index <= Max and then Str (Index) = '.' then\n+\n+         --  At this stage if After_Point was not set, this means that an\n+         --  integral part has been found. Thus the dot is valid even if not\n+         --  followed by a digit.\n+\n+         if Index < Max and then As_Digit (Str (Index + 1)) in Valid_Digit then\n+            After_Point := True;\n+         end if;\n+\n+         Index := Index + 1;\n+      end if;\n+\n+      --  Scan the decimal part\n+\n+      if After_Point then\n+         Scan_Decimal_Digits\n+           (Str, Index, Max, Value, Scale, Char_As_Digit (Extra),\n+            Base_Violation, Base, Base_Specified => Base_Char /= ASCII.NUL);\n+      end if;\n+\n+      --  If an explicit base was specified ensure that the delimiter is found\n+\n+      if Base_Char /= ASCII.NUL then\n+         if Index > Max or else Str (Index) /= Base_Char then\n+            Bad_Value (Str);\n+         else\n+            Index := Index + 1;\n+         end if;\n+      end if;\n+\n+      --  Update pointer and scan exponent\n+\n+      Ptr.all := Index;\n+      Scale := Scale + Scan_Exponent (Str, Ptr, Max, Real => True);\n+\n+      --  Here is where we check for a bad based number\n+\n+      if Base_Violation then\n+         Bad_Value (Str);\n+      else\n+         return Value;\n+      end if;\n+\n+   end Scan_Raw_Real;\n+\n+   --------------------\n+   -- Value_Raw_Real --\n+   --------------------\n+\n+   function Value_Raw_Real\n+     (Str   : String;\n+      Base  : out Unsigned;\n+      Scale : out Integer;\n+      Extra : out Unsigned;\n+      Minus : out Boolean) return Uns\n+   is\n+   begin\n+      --  We have to special case Str'Last = Positive'Last because the normal\n+      --  circuit ends up setting P to Str'Last + 1 which is out of bounds. We\n+      --  deal with this by converting to a subtype which fixes the bounds.\n+\n+      if Str'Last = Positive'Last then\n+         declare\n+            subtype NT is String (1 .. Str'Length);\n+         begin\n+            return Value_Raw_Real (NT (Str), Base, Scale, Extra, Minus);\n+         end;\n+\n+      --  Normal case where Str'Last < Positive'Last\n+\n+      else\n+         declare\n+            V : Uns;\n+            P : aliased Integer := Str'First;\n+         begin\n+            V := Scan_Raw_Real\n+                   (Str, P'Access, Str'Last, Base, Scale, Extra, Minus);\n+            Scan_Trailing_Blanks (Str, P);\n+            return V;\n+         end;\n+      end if;\n+   end Value_Raw_Real;\n+\n+end System.Value_R;"}, {"sha": "8d2f3fde11a10152adc798fa178f92495c686323", "filename": "gcc/ada/libgnat/s-valuer.ads", "status": "added", "additions": 99, "deletions": 0, "changes": 99, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fs-valuer.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fs-valuer.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -0,0 +1,99 @@\n+------------------------------------------------------------------------------\n+--                                                                          --\n+--                         GNAT COMPILER COMPONENTS                         --\n+--                                                                          --\n+--                       S Y S T E M . V A L U E _ R                        --\n+--                                                                          --\n+--                                 S p e c                                  --\n+--                                                                          --\n+--            Copyright (C) 2020, Free Software Foundation, Inc.            --\n+--                                                                          --\n+-- GNAT is free software;  you can  redistribute it  and/or modify it under --\n+-- terms of the  GNU General Public License as published  by the Free Soft- --\n+-- ware  Foundation;  either version 3,  or (at your option) any later ver- --\n+-- sion.  GNAT is distributed in the hope that it will be useful, but WITH- --\n+-- OUT ANY WARRANTY;  without even the  implied warranty of MERCHANTABILITY --\n+-- or FITNESS FOR A PARTICULAR PURPOSE.                                     --\n+--                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n+-- You should have received a copy of the GNU General Public License and    --\n+-- a copy of the GCC Runtime Library Exception along with this program;     --\n+-- see the files COPYING3 and COPYING.RUNTIME respectively.  If not, see    --\n+-- <http://www.gnu.org/licenses/>.                                          --\n+--                                                                          --\n+-- GNAT was originally developed  by the GNAT team at  New York University. --\n+-- Extensive contributions were provided by Ada Core Technologies Inc.      --\n+--                                                                          --\n+------------------------------------------------------------------------------\n+\n+--  This package contains routines for scanning real values for use in\n+--  Text_IO.Decimal_IO, Fixed_IO, Float_IO and the Value attribute.\n+\n+with System.Unsigned_Types; use System.Unsigned_Types;\n+\n+generic\n+\n+   type Uns is mod <>;\n+\n+   Floating : Boolean;\n+\n+package System.Value_R is\n+   pragma Preelaborate;\n+\n+   function Scan_Raw_Real\n+     (Str   : String;\n+      Ptr   : not null access Integer;\n+      Max   : Integer;\n+      Base  : out Unsigned;\n+      Scale : out Integer;\n+      Extra : out Unsigned;\n+      Minus : out Boolean) return Uns;\n+   --  This function scans the string starting at Str (Ptr.all) for a valid\n+   --  real literal according to the syntax described in (RM 3.5(43)). The\n+   --  substring scanned extends no further than Str (Max). There are three\n+   --  cases for the return:\n+   --\n+   --  If a valid real is found after scanning past any initial spaces, then\n+   --  Ptr.all is updated past the last character of the real (but trailing\n+   --  spaces are not scanned out) and the Base, Scale, Extra and Minus out\n+   --  parameters are set; if Val is the result of the call, then the real\n+   --  represented by the literal is equal to\n+   --\n+   --    (Val * Base + Extra) * (Base ** (Scale - 1))\n+   --\n+   --  with the negative sign if Minus is true.\n+   --\n+   --  If no valid real is found, then Ptr.all points either to an initial\n+   --  non-blank character, or to Max + 1 if the field is all spaces and the\n+   --  exception Constraint_Error is raised.\n+   --\n+   --  If a syntactically valid real is scanned, but the value is out of\n+   --  range, or, in the based case, the base value is out of range or there\n+   --  is an out of range digit, then Ptr.all points past the real literal,\n+   --  and Constraint_Error is raised.\n+   --\n+   --  Note: these rules correspond to the requirements for leaving the\n+   --  pointer positioned in Text_Io.Get\n+   --\n+   --  Note: if Str is null, i.e. if Max is less than Ptr, then this is a\n+   --  special case of an all-blank string, and Ptr is unchanged, and hence\n+   --  is greater than Max as required in this case.\n+   --\n+   --  Note: this routine should not be called with Str'Last = Positive'Last.\n+   --  If this occurs Program_Error is raised with a message noting that this\n+   --  case is not supported. Most such cases are eliminated by the caller.\n+\n+   function Value_Raw_Real\n+     (Str   : String;\n+      Base  : out Unsigned;\n+      Scale : out Integer;\n+      Extra : out Unsigned;\n+      Minus : out Boolean) return Uns;\n+   --  Used in computing X'Value (Str) where X is a real type. Str is the\n+   --  string argument of the attribute. Constraint_Error is raised if the\n+   --  string is malformed.\n+\n+end System.Value_R;"}, {"sha": "e346759c0fe84cc76d1cdaeb3da06f14ca505b95", "filename": "gcc/ada/libgnat/system-aix.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-aix.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-aix.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-aix.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "e1af6825068999d00fed9532fc68b186a362403a", "filename": "gcc/ada/libgnat/system-darwin-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-darwin-arm.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "0b746cc2a9f4325fb1f0ed809d92f633add220e9", "filename": "gcc/ada/libgnat/system-darwin-ppc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-darwin-ppc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "e27379e0ee0f1400671acc1b61e3cfe3af455e58", "filename": "gcc/ada/libgnat/system-darwin-x86.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-darwin-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-darwin-x86.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "35d9381fd647f069d2c444557be007fb427553d4", "filename": "gcc/ada/libgnat/system-djgpp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-djgpp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-djgpp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-djgpp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "80da5afb02ed1242719b01286e2910242e2e7c4e", "filename": "gcc/ada/libgnat/system-dragonfly-x86_64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-dragonfly-x86_64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-dragonfly-x86_64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-dragonfly-x86_64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "e8765b82786abc4ddc243100b512664780133b05", "filename": "gcc/ada/libgnat/system-freebsd.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-freebsd.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-freebsd.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-freebsd.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "12252db584ddceed4ee6fdec791996287fc3d1d0", "filename": "gcc/ada/libgnat/system-hpux-ia64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-hpux-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-hpux-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-hpux-ia64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "71a1668b532c9f63ce66a71fca6f40cbb90208a1", "filename": "gcc/ada/libgnat/system-hpux.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-hpux.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-hpux.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-hpux.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "d639630eec0f1137feef55d94ece8d769cac6711", "filename": "gcc/ada/libgnat/system-linux-alpha.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-alpha.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-alpha.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-alpha.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 1024.0;"}, {"sha": "6831aad74ec84771fb39aebf82497c554e14b687", "filename": "gcc/ada/libgnat/system-linux-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-arm.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "669289db3a72b935d009ae04336a61b819906af3", "filename": "gcc/ada/libgnat/system-linux-hppa.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-hppa.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-hppa.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-hppa.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "1dca30c64f08a14d27518b51503ea7b7a84d2388", "filename": "gcc/ada/libgnat/system-linux-ia64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-ia64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-ia64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-ia64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "6a98466714c9431963556462f4c7a2d731c07c2d", "filename": "gcc/ada/libgnat/system-linux-m68k.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-m68k.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-m68k.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-m68k.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "8476f900e37ea5d024c0ca113f06620ed65790c8", "filename": "gcc/ada/libgnat/system-linux-mips.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-mips.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-mips.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-mips.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "9785c9a7d0619c8ce0a3baa79cf4ce0312a7e87b", "filename": "gcc/ada/libgnat/system-linux-ppc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-ppc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "a298bcd0a4ae595d439ed473e0854e62c277eaff", "filename": "gcc/ada/libgnat/system-linux-riscv.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-riscv.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-riscv.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-riscv.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "3d80ce7748b1922e14f09b70daa431929d45a97c", "filename": "gcc/ada/libgnat/system-linux-s390.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-s390.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-s390.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-s390.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "6227bdb9f05a93c24d863db603b0236c285707b1", "filename": "gcc/ada/libgnat/system-linux-sh4.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-sh4.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-sh4.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-sh4.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "0549a8510d011666d38a4d992a81015f022a38da", "filename": "gcc/ada/libgnat/system-linux-sparc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-sparc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "5b2b77fd08f334ce25cfd7db090e4108e28aba7f", "filename": "gcc/ada/libgnat/system-linux-x86.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-linux-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-linux-x86.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "70de803a73dca4da9db0c9d1198e236a0e97d4fa", "filename": "gcc/ada/libgnat/system-lynxos178-ppc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-ppc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "b14f48b2082b7f518ef2286900f7704c137b08e4", "filename": "gcc/ada/libgnat/system-lynxos178-x86.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-lynxos178-x86.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "c05dee7e61c8abf3562ab613acb0636d11a9c2db", "filename": "gcc/ada/libgnat/system-mingw.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-mingw.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-mingw.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-mingw.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "f3316c32366cf4a183b2316fdbab251f3e041e1d", "filename": "gcc/ada/libgnat/system-qnx-aarch64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-qnx-aarch64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.000_001;"}, {"sha": "8907d9e16e33010bd97ad7894f6f17590dbda8d0", "filename": "gcc/ada/libgnat/system-rtems.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-rtems.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-rtems.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-rtems.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -61,7 +61,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "f211eeda8dd35cc928f71dfd2d879de96e037ba7", "filename": "gcc/ada/libgnat/system-solaris-sparc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-solaris-sparc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-solaris-sparc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-solaris-sparc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "82fe6568add6993dd4cdfb42b1b6af62e00fa7f7", "filename": "gcc/ada/libgnat/system-solaris-x86.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-solaris-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-solaris-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-solaris-x86.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 0.01;"}, {"sha": "7412611ceb544f9977565b1b1edabb9de4c177a6", "filename": "gcc/ada/libgnat/system-vxworks-arm-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "697f35196b566a03982741446dec668076d42936", "filename": "gcc/ada/libgnat/system-vxworks-arm-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "5f767b229febc28f0eff1271468b3399cf2261f8", "filename": "gcc/ada/libgnat/system-vxworks-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-arm.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "2d64186eb709bc0677dde13c0559d7c3530bfcae", "filename": "gcc/ada/libgnat/system-vxworks-e500-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "46cd6e718a43dcbc09f493d8848f70e7ecfdcd2f", "filename": "gcc/ada/libgnat/system-vxworks-e500-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "c232fe018e75ae04d1567a3888ecdc189024d15f", "filename": "gcc/ada/libgnat/system-vxworks-e500-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "929a6421c02d45994598bd2d22be1542c959e151", "filename": "gcc/ada/libgnat/system-vxworks-e500-vthread.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-vthread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-vthread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-e500-vthread.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "63cebb7d8d7f50fee7481cee06dc808e59d4811c", "filename": "gcc/ada/libgnat/system-vxworks-ppc-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "4347a01831246d7a2813bfbcb01e3914d311a3f9", "filename": "gcc/ada/libgnat/system-vxworks-ppc-ravenscar.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-ravenscar.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-ravenscar.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-ravenscar.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -82,7 +82,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "469c0f3e588719959e297892a8cd85180fc3dd4e", "filename": "gcc/ada/libgnat/system-vxworks-ppc-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "8fba1b0f94459dc69d13598de4da01697cd0cf06", "filename": "gcc/ada/libgnat/system-vxworks-ppc-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "a4f4eb2eb86d70d7e334c4d82a10ed291447d2a9", "filename": "gcc/ada/libgnat/system-vxworks-ppc-vthread.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-vthread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-vthread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc-vthread.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "67d936a7a1ca1422255e30a1506092e91639b5e1", "filename": "gcc/ada/libgnat/system-vxworks-ppc.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-ppc.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "e4d03446d8ee32c80977c70319f6078d7511dc93", "filename": "gcc/ada/libgnat/system-vxworks-x86-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "f2a41425c0e297f0144ab5c1532afbdc86a9e33a", "filename": "gcc/ada/libgnat/system-vxworks-x86-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "d597600a1947a556c69447edcf673098434a22f4", "filename": "gcc/ada/libgnat/system-vxworks-x86-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "a1eb8f0f6c7aea54f752a8067de8d9a78a22fd7e", "filename": "gcc/ada/libgnat/system-vxworks-x86-vthread.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-vthread.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-vthread.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86-vthread.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "226a3dc8dc7468d1d613f777a2ad488cb246400f", "filename": "gcc/ada/libgnat/system-vxworks-x86.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks-x86.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "e2ed214288f92610fa386f07841c00e63a855367", "filename": "gcc/ada/libgnat/system-vxworks7-aarch64-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "ef1211b36580ea09545a970a024ff06588cde781", "filename": "gcc/ada/libgnat/system-vxworks7-aarch64.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-aarch64.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "2b4c64eba4e6e6ffeec266cd6023eaf2387e2188", "filename": "gcc/ada/libgnat/system-vxworks7-arm-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "5f767b229febc28f0eff1271468b3399cf2261f8", "filename": "gcc/ada/libgnat/system-vxworks7-arm.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-arm.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "4182a1fd87c06c60f5d17f1d29d91a48abd82eca", "filename": "gcc/ada/libgnat/system-vxworks7-e500-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "d4a303b03b70db814801268ece6ad92babad2e87", "filename": "gcc/ada/libgnat/system-vxworks7-e500-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "c7acf958c2cf3d913bb276add332d3553b7519a7", "filename": "gcc/ada/libgnat/system-vxworks7-e500-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-e500-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "71d06b453b5e4c1eae13ea51e5d6ee9c60aaabc4", "filename": "gcc/ada/libgnat/system-vxworks7-ppc-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "387961426f318c4402209d79f9935dae9d352d50", "filename": "gcc/ada/libgnat/system-vxworks7-ppc-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "b5393cd1f53a1029d6ddc26ce44a3aa06f4f0b29", "filename": "gcc/ada/libgnat/system-vxworks7-ppc-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "94f69eeeabb00b1758dacd56ee2b714287fe0e0e", "filename": "gcc/ada/libgnat/system-vxworks7-ppc64-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "bafa41d3d82c7128b931ed01728a1d8a74014d1c", "filename": "gcc/ada/libgnat/system-vxworks7-ppc64-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-ppc64-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -59,7 +59,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "ae0c39fb0cd55dbd35134443dfe8fb7cbae0a0d5", "filename": "gcc/ada/libgnat/system-vxworks7-x86-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "4681bbaf627da89171fba97525107946abb7ccf1", "filename": "gcc/ada/libgnat/system-vxworks7-x86-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "6b176d1dea17096e78f2c43566bf7dc65619e5c5", "filename": "gcc/ada/libgnat/system-vxworks7-x86-rtp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86-rtp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "eadf5ee1b84d9ac21ec91409d4e028ac128a1577", "filename": "gcc/ada/libgnat/system-vxworks7-x86_64-kernel.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-kernel.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "a97b80a9290cd7fa3cbdb23dc6aa7b4f53ea3b71", "filename": "gcc/ada/libgnat/system-vxworks7-x86_64-rtp-smp.ads", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Flibgnat%2Fsystem-vxworks7-x86_64-rtp-smp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -57,7 +57,7 @@ package System is\n    Max_Base_Digits       : constant := Long_Long_Float'Digits;\n    Max_Digits            : constant := Long_Long_Float'Digits;\n \n-   Max_Mantissa          : constant := 63;\n+   Max_Mantissa          : constant := Standard'Max_Integer_Size - 1;\n    Fine_Delta            : constant := 2.0 ** (-Max_Mantissa);\n \n    Tick                  : constant := 1.0 / 60.0;"}, {"sha": "c1ea69511cb1910454a62e45f312716100a072ed", "filename": "gcc/ada/rtsfind.ads", "status": "modified", "additions": 89, "deletions": 19, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Frtsfind.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Frtsfind.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Frtsfind.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -249,14 +249,24 @@ package Rtsfind is\n       System_Fat_VAX_G_Float,\n       System_Finalization_Masters,\n       System_Finalization_Root,\n-      System_Fore,\n+      System_Fore_Decimal_32,\n+      System_Fore_Decimal_64,\n+      System_Fore_Decimal_128,\n+      System_Fore_Fixed_32,\n+      System_Fore_Fixed_64,\n+      System_Fore_Fixed_128,\n+      System_Fore_Real,\n       System_Img_Bool,\n       System_Img_Char,\n-      System_Img_Dec,\n+      System_Img_Decimal_32,\n+      System_Img_Decimal_64,\n+      System_Img_Decimal_128,\n       System_Img_Enum,\n       System_Img_Enum_New,\n+      System_Img_Fixed_32,\n+      System_Img_Fixed_64,\n+      System_Img_Fixed_128,\n       System_Img_Int,\n-      System_Img_LLD,\n       System_Img_LLI,\n       System_Img_LLLI,\n       System_Img_LLU,\n@@ -417,10 +427,14 @@ package Rtsfind is\n       System_Unsigned_Types,\n       System_Val_Bool,\n       System_Val_Char,\n-      System_Val_Dec,\n+      System_Val_Decimal_32,\n+      System_Val_Decimal_64,\n+      System_Val_Decimal_128,\n       System_Val_Enum,\n+      System_Val_Fixed_32,\n+      System_Val_Fixed_64,\n+      System_Val_Fixed_128,\n       System_Val_Int,\n-      System_Val_LLD,\n       System_Val_LLI,\n       System_Val_LLLI,\n       System_Val_LLU,\n@@ -756,8 +770,10 @@ package Rtsfind is\n      RE_Subtract_With_Ovflo_Check64,     -- System.Arith_64\n \n      RE_Add_With_Ovflo_Check128,         -- System.Arith_128\n+     RE_Double_Divide128,                -- System.Arith_128\n      RE_Multiply_With_Ovflo_Check128,    -- System.Arith_128\n      RE_Subtract_With_Ovflo_Check128,    -- System.Arith_128\n+     RE_Scaled_Divide128,                -- System.Arith_128\n \n      RE_Create_AST_Handler,              -- System.AST_Handling\n \n@@ -943,23 +959,37 @@ package Rtsfind is\n      RE_Root_Controlled,                 -- System.Finalization_Root\n      RE_Root_Controlled_Ptr,             -- System.Finalization_Root\n \n-     RE_Fore,                            -- System.Fore\n+     RE_Fore_Decimal32,                  -- System.Fore_Decimal_32\n+\n+     RE_Fore_Decimal64,                  -- System.Fore_Decimal_64\n+\n+     RE_Fore_Decimal128,                 -- System.Fore_Decimal_128\n+\n+     RE_Fore_Fixed32,                    -- System.Fore_Fixed_32\n+\n+     RE_Fore_Fixed64,                    -- System.Fore_Fixed_64\n+\n+     RE_Fore_Fixed128,                   -- System.Fore_Fixed_128\n+\n+     RE_Fore_Real,                       -- System.Fore_Real\n \n      RE_Image_Boolean,                   -- System.Img_Bool\n \n      RE_Image_Character,                 -- System.Img_Char\n      RE_Image_Character_05,              -- System.Img_Char\n \n-     RE_Image_Decimal,                   -- System.Img_Dec\n+     RE_Image_Decimal32,                 -- System.Img_Decimal_32\n+\n+     RE_Image_Decimal64,                 -- System.Img_Decimal_64\n+\n+     RE_Image_Decimal128,                -- System.Img_Decimal_128\n \n      RE_Image_Enumeration_8,             -- System.Img_Enum_New\n      RE_Image_Enumeration_16,            -- System.Img_Enum_New\n      RE_Image_Enumeration_32,            -- System.Img_Enum_New\n \n      RE_Image_Integer,                   -- System.Img_Int\n \n-     RE_Image_Long_Long_Decimal,         -- System.Img_LLD\n-\n      RE_Image_Long_Long_Integer,         -- System.Img_LLI\n \n      RE_Image_Long_Long_Long_Integer,    -- System.Img_LLLI\n@@ -968,6 +998,10 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Long_Unsigned,   -- System.Img_LLLU\n \n+     RE_Image_Fixed32,                   -- System.Img_Fixed_32\n+     RE_Image_Fixed64,                   -- System.Img_Fixed_64\n+     RE_Image_Fixed128,                  -- System.Img_Fixed_128\n+\n      RE_Image_Ordinary_Fixed_Point,      -- System.Img_Real\n      RE_Image_Floating_Point,            -- System.Img_Real\n \n@@ -1991,15 +2025,23 @@ package Rtsfind is\n \n      RE_Value_Character,                 -- System.Val_Char\n \n-     RE_Value_Decimal,                   -- System.Val_Dec\n+     RE_Value_Decimal32,                 -- System_Val_Decimal_32\n+\n+     RE_Value_Decimal64,                 -- System_Val_Decimal_64\n+\n+     RE_Value_Decimal128,                -- System_Val_Decimal_128\n \n      RE_Value_Enumeration_8,             -- System.Val_Enum\n      RE_Value_Enumeration_16,            -- System.Val_Enum\n      RE_Value_Enumeration_32,            -- System.Val_Enum\n \n-     RE_Value_Integer,                   -- System.Val_Int\n+     RE_Value_Fixed32,                   -- System_Val_Fixed_32\n+\n+     RE_Value_Fixed64,                   -- System_Val_Fixed_64\n \n-     RE_Value_Long_Long_Decimal,         -- System.Val_LLD\n+     RE_Value_Fixed128,                  -- System_Val_Fixed_128\n+\n+     RE_Value_Integer,                   -- System.Val_Int\n \n      RE_Value_Long_Long_Integer,         -- System.Val_LLI\n \n@@ -2403,8 +2445,10 @@ package Rtsfind is\n      RE_Subtract_With_Ovflo_Check64      => System_Arith_64,\n \n      RE_Add_With_Ovflo_Check128          => System_Arith_128,\n+     RE_Double_Divide128                 => System_Arith_128,\n      RE_Multiply_With_Ovflo_Check128     => System_Arith_128,\n      RE_Subtract_With_Ovflo_Check128     => System_Arith_128,\n+     RE_Scaled_Divide128                 => System_Arith_128,\n \n      RE_Create_AST_Handler               => System_AST_Handling,\n \n@@ -2596,23 +2640,37 @@ package Rtsfind is\n      RE_Root_Controlled                  => System_Finalization_Root,\n      RE_Root_Controlled_Ptr              => System_Finalization_Root,\n \n-     RE_Fore                             => System_Fore,\n+     RE_Fore_Decimal32                   => System_Fore_Decimal_32,\n+\n+     RE_Fore_Decimal64                   => System_Fore_Decimal_64,\n+\n+     RE_Fore_Decimal128                  => System_Fore_Decimal_128,\n+\n+     RE_Fore_Fixed32                     => System_Fore_Fixed_32,\n+\n+     RE_Fore_Fixed64                     => System_Fore_Fixed_64,\n+\n+     RE_Fore_Fixed128                    => System_Fore_Fixed_128,\n+\n+     RE_Fore_Real                        => System_Fore_Real,\n \n      RE_Image_Boolean                    => System_Img_Bool,\n \n      RE_Image_Character                  => System_Img_Char,\n      RE_Image_Character_05               => System_Img_Char,\n \n-     RE_Image_Decimal                    => System_Img_Dec,\n+     RE_Image_Decimal32                  => System_Img_Decimal_32,\n+\n+     RE_Image_Decimal64                  => System_Img_Decimal_64,\n+\n+     RE_Image_Decimal128                 => System_Img_Decimal_128,\n \n      RE_Image_Enumeration_8              => System_Img_Enum_New,\n      RE_Image_Enumeration_16             => System_Img_Enum_New,\n      RE_Image_Enumeration_32             => System_Img_Enum_New,\n \n      RE_Image_Integer                    => System_Img_Int,\n \n-     RE_Image_Long_Long_Decimal          => System_Img_LLD,\n-\n      RE_Image_Long_Long_Integer          => System_Img_LLI,\n \n      RE_Image_Long_Long_Long_Integer     => System_Img_LLLI,\n@@ -2621,6 +2679,10 @@ package Rtsfind is\n \n      RE_Image_Long_Long_Long_Unsigned    => System_Img_LLLU,\n \n+     RE_Image_Fixed32                    => System_Img_Fixed_32,\n+     RE_Image_Fixed64                    => System_Img_Fixed_64,\n+     RE_Image_Fixed128                   => System_Img_Fixed_128,\n+\n      RE_Image_Ordinary_Fixed_Point       => System_Img_Real,\n      RE_Image_Floating_Point             => System_Img_Real,\n \n@@ -3644,15 +3706,23 @@ package Rtsfind is\n \n      RE_Value_Character                  => System_Val_Char,\n \n-     RE_Value_Decimal                    => System_Val_Dec,\n+     RE_Value_Decimal32                  => System_Val_Decimal_32,\n+\n+     RE_Value_Decimal64                  => System_Val_Decimal_64,\n+\n+     RE_Value_Decimal128                 => System_Val_Decimal_128,\n \n      RE_Value_Enumeration_8              => System_Val_Enum,\n      RE_Value_Enumeration_16             => System_Val_Enum,\n      RE_Value_Enumeration_32             => System_Val_Enum,\n \n-     RE_Value_Integer                    => System_Val_Int,\n+     RE_Value_Fixed32                    => System_Val_Fixed_32,\n+\n+     RE_Value_Fixed64                    => System_Val_Fixed_64,\n \n-     RE_Value_Long_Long_Decimal          => System_Val_LLD,\n+     RE_Value_Fixed128                   => System_Val_Fixed_128,\n+\n+     RE_Value_Integer                    => System_Val_Int,\n \n      RE_Value_Long_Long_Integer          => System_Val_LLI,\n "}, {"sha": "f487f7345873c49d825fb2ed7bc666b306bf0bfa", "filename": "gcc/ada/sem_ch3.adb", "status": "modified", "additions": 16, "deletions": 9, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fsem_ch3.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fsem_ch3.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch3.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -14945,6 +14945,10 @@ package body Sem_Ch3 is\n       Loc           : constant Source_Ptr := Sloc (Def);\n       Digs_Expr     : constant Node_Id    := Digits_Expression (Def);\n       Delta_Expr    : constant Node_Id    := Delta_Expression (Def);\n+      Max_Digits    : constant Nat        :=\n+                        (if System_Max_Integer_Size = 128 then 38 else 18);\n+      --  Maximum number of digits that can be represented in an integer\n+\n       Implicit_Base : Entity_Id;\n       Digs_Val      : Uint;\n       Delta_Val     : Ureal;\n@@ -14982,9 +14986,10 @@ package body Sem_Ch3 is\n                Scale_Val := Scale_Val + 1;\n             end loop;\n \n-            if Scale_Val > 18 then\n-               Error_Msg_N (\"scale exceeds maximum value of 18\", Def);\n-               Scale_Val := UI_From_Int (+18);\n+            if Scale_Val > Max_Digits then\n+               Error_Msg_Uint_1 := UI_From_Int (Max_Digits);\n+               Error_Msg_N (\"scale exceeds maximum value of ^\", Def);\n+               Scale_Val := UI_From_Int (Max_Digits);\n             end if;\n \n          else\n@@ -14993,9 +14998,10 @@ package body Sem_Ch3 is\n                Scale_Val := Scale_Val - 1;\n             end loop;\n \n-            if Scale_Val < -18 then\n-               Error_Msg_N (\"scale is less than minimum value of -18\", Def);\n-               Scale_Val := UI_From_Int (-18);\n+            if Scale_Val < -Max_Digits then\n+               Error_Msg_Uint_1 := UI_From_Int (-Max_Digits);\n+               Error_Msg_N (\"scale is less than minimum value of ^\", Def);\n+               Scale_Val := UI_From_Int (-Max_Digits);\n             end if;\n          end if;\n \n@@ -15017,9 +15023,10 @@ package body Sem_Ch3 is\n       Check_Digits_Expression (Digs_Expr);\n       Digs_Val := Expr_Value (Digs_Expr);\n \n-      if Digs_Val > 18 then\n-         Digs_Val := UI_From_Int (+18);\n-         Error_Msg_N (\"digits value out of range, maximum is 18\", Digs_Expr);\n+      if Digs_Val > Max_Digits then\n+         Error_Msg_Uint_1 := UI_From_Int (Max_Digits);\n+         Error_Msg_N (\"digits value out of range, maximum is ^\", Digs_Expr);\n+         Digs_Val := UI_From_Int (Max_Digits);\n       end if;\n \n       Set_Digits_Value (Implicit_Base, Digs_Val);"}, {"sha": "848239fafb0cbeb149b6cb63e053b042b4afd1f5", "filename": "gcc/ada/stand.ads", "status": "modified", "additions": 5, "deletions": 4, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fstand.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fstand.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fstand.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -451,10 +451,11 @@ package Stand is\n    --  universal integer and universal real, it is never used for runtime\n    --  calculations).\n \n-   Standard_Integer_8  : Entity_Id;\n-   Standard_Integer_16 : Entity_Id;\n-   Standard_Integer_32 : Entity_Id;\n-   Standard_Integer_64 : Entity_Id;\n+   Standard_Integer_8   : Entity_Id;\n+   Standard_Integer_16  : Entity_Id;\n+   Standard_Integer_32  : Entity_Id;\n+   Standard_Integer_64  : Entity_Id;\n+   Standard_Integer_128 : Entity_Id;\n    --  These are signed integer types with the indicated sizes. Used for the\n    --  underlying implementation types for fixed-point and enumeration types.\n "}, {"sha": "5f1f759a44eec58241d2efd31c36876b87bb2510", "filename": "gcc/ada/uintp.ads", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fuintp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Fuintp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fuintp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -63,6 +63,7 @@ package Uintp is\n    Uint_15  : constant Uint;\n    Uint_16  : constant Uint;\n    Uint_24  : constant Uint;\n+   Uint_31  : constant Uint;\n    Uint_32  : constant Uint;\n    Uint_63  : constant Uint;\n    Uint_64  : constant Uint;\n@@ -80,9 +81,13 @@ package Uintp is\n    Uint_Minus_8   : constant Uint;\n    Uint_Minus_9   : constant Uint;\n    Uint_Minus_12  : constant Uint;\n+   Uint_Minus_18  : constant Uint;\n+   Uint_Minus_31  : constant Uint;\n    Uint_Minus_36  : constant Uint;\n    Uint_Minus_63  : constant Uint;\n+   Uint_Minus_76  : constant Uint;\n    Uint_Minus_80  : constant Uint;\n+   Uint_Minus_127 : constant Uint;\n    Uint_Minus_128 : constant Uint;\n \n    type UI_Vector is array (Pos range <>) of Int;\n@@ -470,6 +475,7 @@ private\n    Uint_15  : constant Uint := Uint (Uint_Direct_Bias + 15);\n    Uint_16  : constant Uint := Uint (Uint_Direct_Bias + 16);\n    Uint_24  : constant Uint := Uint (Uint_Direct_Bias + 24);\n+   Uint_31  : constant Uint := Uint (Uint_Direct_Bias + 31);\n    Uint_32  : constant Uint := Uint (Uint_Direct_Bias + 32);\n    Uint_63  : constant Uint := Uint (Uint_Direct_Bias + 63);\n    Uint_64  : constant Uint := Uint (Uint_Direct_Bias + 64);\n@@ -487,9 +493,13 @@ private\n    Uint_Minus_8   : constant Uint := Uint (Uint_Direct_Bias - 8);\n    Uint_Minus_9   : constant Uint := Uint (Uint_Direct_Bias - 9);\n    Uint_Minus_12  : constant Uint := Uint (Uint_Direct_Bias - 12);\n+   Uint_Minus_18  : constant Uint := Uint (Uint_Direct_Bias - 18);\n+   Uint_Minus_31  : constant Uint := Uint (Uint_Direct_Bias - 31);\n    Uint_Minus_36  : constant Uint := Uint (Uint_Direct_Bias - 36);\n    Uint_Minus_63  : constant Uint := Uint (Uint_Direct_Bias - 63);\n+   Uint_Minus_76  : constant Uint := Uint (Uint_Direct_Bias - 76);\n    Uint_Minus_80  : constant Uint := Uint (Uint_Direct_Bias - 80);\n+   Uint_Minus_127 : constant Uint := Uint (Uint_Direct_Bias - 127);\n    Uint_Minus_128 : constant Uint := Uint (Uint_Direct_Bias - 128);\n \n    Uint_Max_Simple_Mul : constant := Uint_Direct_Bias + 2**15;"}, {"sha": "88cb6815e080f552f2f0158548a78e3df9a2d597", "filename": "gcc/ada/urealp.adb", "status": "modified", "additions": 124, "deletions": 44, "changes": 168, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Furealp.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Furealp.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -73,20 +73,28 @@ package body Urealp is\n    --  The following universal reals are the values returned by the constant\n    --  functions. They are initialized by the initialization procedure.\n \n-   UR_0       : Ureal;\n-   UR_M_0     : Ureal;\n-   UR_Tenth   : Ureal;\n-   UR_Half    : Ureal;\n-   UR_1       : Ureal;\n-   UR_2       : Ureal;\n-   UR_10      : Ureal;\n-   UR_10_36   : Ureal;\n-   UR_M_10_36 : Ureal;\n-   UR_100     : Ureal;\n-   UR_2_128   : Ureal;\n-   UR_2_80    : Ureal;\n-   UR_2_M_128 : Ureal;\n-   UR_2_M_80  : Ureal;\n+   UR_0         : Ureal;\n+   UR_M_0       : Ureal;\n+   UR_Tenth     : Ureal;\n+   UR_Half      : Ureal;\n+   UR_1         : Ureal;\n+   UR_2         : Ureal;\n+   UR_10        : Ureal;\n+   UR_2_10_18   : Ureal;\n+   UR_9_10_36   : Ureal;\n+   UR_10_76     : Ureal;\n+   UR_M_2_10_18 : Ureal;\n+   UR_M_9_10_36 : Ureal;\n+   UR_M_10_76   : Ureal;\n+   UR_100       : Ureal;\n+   UR_2_127     : Ureal;\n+   UR_2_128     : Ureal;\n+   UR_2_31      : Ureal;\n+   UR_2_63      : Ureal;\n+   UR_2_80      : Ureal;\n+   UR_2_M_127   : Ureal;\n+   UR_2_M_128   : Ureal;\n+   UR_2_M_80    : Ureal;\n \n    Normalized_Real : Ureal := No_Ureal;\n    --  Used to memoize Norm_Num and Norm_Den, if either of these functions\n@@ -288,20 +296,28 @@ package body Urealp is\n    procedure Initialize is\n    begin\n       Ureals.Init;\n-      UR_0       := UR_From_Components (Uint_0, Uint_1,         0, False);\n-      UR_M_0     := UR_From_Components (Uint_0, Uint_1,         0, True);\n-      UR_Half    := UR_From_Components (Uint_1, Uint_1,         2, False);\n-      UR_Tenth   := UR_From_Components (Uint_1, Uint_1,        10, False);\n-      UR_1       := UR_From_Components (Uint_1, Uint_1,         0, False);\n-      UR_2       := UR_From_Components (Uint_1, Uint_Minus_1,   2, False);\n-      UR_10      := UR_From_Components (Uint_1, Uint_Minus_1,  10, False);\n-      UR_10_36   := UR_From_Components (Uint_1, Uint_Minus_36, 10, False);\n-      UR_M_10_36 := UR_From_Components (Uint_1, Uint_Minus_36, 10, True);\n-      UR_100     := UR_From_Components (Uint_1, Uint_Minus_2,  10, False);\n-      UR_2_128   := UR_From_Components (Uint_1, Uint_Minus_128, 2, False);\n-      UR_2_M_128 := UR_From_Components (Uint_1, Uint_128,       2, False);\n-      UR_2_80    := UR_From_Components (Uint_1, Uint_Minus_80,  2, False);\n-      UR_2_M_80  := UR_From_Components (Uint_1, Uint_80,        2, False);\n+      UR_0         := UR_From_Components (Uint_0, Uint_1,         0, False);\n+      UR_M_0       := UR_From_Components (Uint_0, Uint_1,         0, True);\n+      UR_Half      := UR_From_Components (Uint_1, Uint_1,         2, False);\n+      UR_Tenth     := UR_From_Components (Uint_1, Uint_1,        10, False);\n+      UR_1         := UR_From_Components (Uint_1, Uint_1,         0, False);\n+      UR_2         := UR_From_Components (Uint_1, Uint_Minus_1,   2, False);\n+      UR_10        := UR_From_Components (Uint_1, Uint_Minus_1,  10, False);\n+      UR_2_10_18   := UR_From_Components (Uint_2, Uint_Minus_18, 10, False);\n+      UR_9_10_36   := UR_From_Components (Uint_9, Uint_Minus_36, 10, False);\n+      UR_10_76     := UR_From_Components (Uint_1, Uint_Minus_76, 10, False);\n+      UR_M_2_10_18 := UR_From_Components (Uint_2, Uint_Minus_18, 10, True);\n+      UR_M_9_10_36 := UR_From_Components (Uint_9, Uint_Minus_36, 10, True);\n+      UR_M_10_76   := UR_From_Components (Uint_1, Uint_Minus_76, 10, True);\n+      UR_100       := UR_From_Components (Uint_1, Uint_Minus_2,  10, False);\n+      UR_2_127     := UR_From_Components (Uint_1, Uint_Minus_127, 2, False);\n+      UR_2_M_127   := UR_From_Components (Uint_1, Uint_127,       2, False);\n+      UR_2_128     := UR_From_Components (Uint_1, Uint_Minus_128, 2, False);\n+      UR_2_M_128   := UR_From_Components (Uint_1, Uint_128,       2, False);\n+      UR_2_31      := UR_From_Components (Uint_1, Uint_Minus_31,  2, False);\n+      UR_2_63      := UR_From_Components (Uint_1, Uint_Minus_63,  2, False);\n+      UR_2_80      := UR_From_Components (Uint_1, Uint_Minus_80,  2, False);\n+      UR_2_M_80    := UR_From_Components (Uint_1, Uint_80,        2, False);\n    end Initialize;\n \n    ----------------\n@@ -1408,14 +1424,6 @@ package body Urealp is\n             UI_Write (Int (UI_Image_Length - 1) - Val.Den, Decimal);\n          end if;\n \n-      --  Constants in a base other than 10 can still be easily written in\n-      --  normal Ada literal style if the numerator is one.\n-\n-      elsif Val.Rbase /= 0 and then Val.Num = 1 then\n-         Write_Int (Val.Rbase);\n-         Write_Str (\"#1.0#E\");\n-         UI_Write (-Val.Den);\n-\n       --  Other constants with a base other than 10 are written using one of\n       --  the following forms, depending on the sign of the number and the\n       --  sign of the exponent (= minus denominator value). See that we are\n@@ -1525,14 +1533,50 @@ package body Urealp is\n       return UR_100;\n    end Ureal_100;\n \n+   -------------------\n+   -- Ureal_2_10_18 --\n+   -------------------\n+\n+   function Ureal_2_10_18 return Ureal is\n+   begin\n+      return UR_2_10_18;\n+   end Ureal_2_10_18;\n+\n+   -------------------\n+   -- Ureal_9_10_36 --\n+   -------------------\n+\n+   function Ureal_9_10_36 return Ureal is\n+   begin\n+      return UR_9_10_36;\n+   end Ureal_9_10_36;\n+\n    -----------------\n-   -- Ureal_10_36 --\n+   -- Ureal_10_76 --\n    -----------------\n \n-   function Ureal_10_36 return Ureal is\n+   function Ureal_10_76 return Ureal is\n+   begin\n+      return UR_10_76;\n+   end Ureal_10_76;\n+\n+   ----------------\n+   -- Ureal_2_31 --\n+   ----------------\n+\n+   function Ureal_2_31 return Ureal is\n+   begin\n+      return UR_2_31;\n+   end Ureal_2_31;\n+\n+   ----------------\n+   -- Ureal_2_63 --\n+   ----------------\n+\n+   function Ureal_2_63 return Ureal is\n    begin\n-      return UR_10_36;\n-   end Ureal_10_36;\n+      return UR_2_63;\n+   end Ureal_2_63;\n \n    ----------------\n    -- Ureal_2_80 --\n@@ -1543,6 +1587,15 @@ package body Urealp is\n       return UR_2_80;\n    end Ureal_2_80;\n \n+   -----------------\n+   -- Ureal_2_127 --\n+   -----------------\n+\n+   function Ureal_2_127 return Ureal is\n+   begin\n+      return UR_2_127;\n+   end Ureal_2_127;\n+\n    -----------------\n    -- Ureal_2_128 --\n    -----------------\n@@ -1561,6 +1614,15 @@ package body Urealp is\n       return UR_2_M_80;\n    end Ureal_2_M_80;\n \n+   -------------------\n+   -- Ureal_2_M_127 --\n+   -------------------\n+\n+   function Ureal_2_M_127 return Ureal is\n+   begin\n+      return UR_2_M_127;\n+   end Ureal_2_M_127;\n+\n    -------------------\n    -- Ureal_2_M_128 --\n    -------------------\n@@ -1588,14 +1650,32 @@ package body Urealp is\n       return UR_M_0;\n    end Ureal_M_0;\n \n+   ---------------------\n+   -- Ureal_M_2_10_18 --\n+   ---------------------\n+\n+   function Ureal_M_2_10_18 return Ureal is\n+   begin\n+      return UR_M_2_10_18;\n+   end Ureal_M_2_10_18;\n+\n+   ---------------------\n+   -- Ureal_M_9_10_36 --\n+   ---------------------\n+\n+   function Ureal_M_9_10_36 return Ureal is\n+   begin\n+      return UR_M_9_10_36;\n+   end Ureal_M_9_10_36;\n+\n    -------------------\n-   -- Ureal_M_10_36 --\n+   -- Ureal_M_10_76 --\n    -------------------\n \n-   function Ureal_M_10_36 return Ureal is\n+   function Ureal_M_10_76 return Ureal is\n    begin\n-      return UR_M_10_36;\n-   end Ureal_M_10_36;\n+      return UR_M_10_76;\n+   end Ureal_M_10_76;\n \n    -----------------\n    -- Ureal_Tenth --"}, {"sha": "3f747359ee71ffff8cc9f426e6360b2c34b28dd5", "filename": "gcc/ada/urealp.ads", "status": "modified", "additions": 28, "deletions": 4, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Furealp.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Fada%2Furealp.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Furealp.ads?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -106,23 +106,47 @@ package Urealp is\n    function Ureal_100 return Ureal;\n    --  Returns value 100.0\n \n+   function Ureal_2_31 return Ureal;\n+   --  Returns value 2.0 ** 31\n+\n+   function Ureal_2_63 return Ureal;\n+   --  Returns value 2.0 ** 63\n+\n    function Ureal_2_80 return Ureal;\n    --  Returns value 2.0 ** 80\n \n    function Ureal_2_M_80 return Ureal;\n    --  Returns value 2.0 ** (-80)\n \n+   function Ureal_2_127 return Ureal;\n+   --  Returns value 2.0 ** 127\n+\n+   function Ureal_2_M_127 return Ureal;\n+   --  Returns value 2.0 ** (-127)\n+\n    function Ureal_2_128 return Ureal;\n    --  Returns value 2.0 ** 128\n \n    function Ureal_2_M_128 return Ureal;\n    --  Returns value 2.0 ** (-128)\n \n-   function Ureal_10_36 return Ureal;\n-   --  Returns value 10.0 ** 36\n+   function Ureal_2_10_18 return Ureal;\n+   --  Returns value 2.0 * 10.0 ** 18\n+\n+   function Ureal_M_2_10_18 return Ureal;\n+   --  Returns value -2.0 * 10.0 ** 18\n+\n+   function Ureal_9_10_36 return Ureal;\n+   --  Returns value 9.0 * 10.0 ** 36\n+\n+   function Ureal_M_9_10_36 return Ureal;\n+   --  Returns value -9.0 * 10.0 ** 36\n+\n+   function Ureal_10_76 return Ureal;\n+   --  Returns value 10.0 ** 76\n \n-   function Ureal_M_10_36 return Ureal;\n-   --  Returns value -10.0 ** 36\n+   function Ureal_M_10_76 return Ureal;\n+   --  Returns value -10.0 ** 76\n \n    -----------------\n    -- Subprograms --"}, {"sha": "6eeda8876b6c7e9209d2702d4c4ebd7ffee20eae", "filename": "gcc/testsuite/gnat.dg/multfixed.adb", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d87bb8f56db177718bf0f07df462b85a90c1ef3/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgnat.dg%2Fmultfixed.adb?ref=8d87bb8f56db177718bf0f07df462b85a90c1ef3", "patch": "@@ -1,6 +1,7 @@\n --  { dg-do run }\n \n with Ada.Exceptions; use Ada.Exceptions;\n+with Ada.Strings.Fixed; use Ada.Strings.Fixed;\n \n procedure Multfixed is\n    Z : constant := 4387648782261400837.0;\n@@ -18,7 +19,7 @@ begin\n    raise Program_Error;\n exception\n    when Exc : Constraint_Error =>\n-      if Exception_Message (Exc) /= \"System.Arith_64.Impl.Raise_Error: Double arithmetic overflow\" then\n+      if Count (Exception_Message (Exc), \"overflow\") = 0 then\n          raise Program_Error;\n       end if;\n end Multfixed;"}]}