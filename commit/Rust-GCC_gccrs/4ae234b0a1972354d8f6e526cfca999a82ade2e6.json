{"sha": "4ae234b0a1972354d8f6e526cfca999a82ade2e6", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGFlMjM0YjBhMTk3MjM1NGQ4ZjZlNTI2Y2ZjYTk5OWE4MmFkZTJlNg==", "commit": {"author": {"name": "Geoffrey Keating", "email": "geoffk@apple.com", "date": "2005-06-12T03:43:12Z"}, "committer": {"name": "Geoffrey Keating", "email": "geoffk@gcc.gnu.org", "date": "2005-06-12T03:43:12Z"}, "message": "predicates.md (reg_or_arith_cint_operand): Delete.\n\n\t* config/rs6000/predicates.md (reg_or_arith_cint_operand): Delete.\n\t(reg_or_add_cint_operand): Rename from reg_or_add_cint64_operand.\n\tHandle SImode.\n\t(reg_or_sub_cint_operand): Likewise.\n\t(mask_operand): Handle DImode.\n\t(mask64_operand): Delete.\n\t(and64_operand): Delete.\n\t* config/rs6000/rs6000.c (num_insns_constant): Use mask_operand\n\tinstead of mask64_operand.\n\t(print_operand): Likewise.\n\t(rs6000_rtx_costs): Use mask_operand and reg_or_add_cint_operand and\n\treg_or_sub_cint_operand instead of *64_* variants.\n\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT): Use mask_operand\n\tinstead of mask64_operand.\n\t* config/rs6000/rs6000.md: Use mask_operand and and_operand instead\n\tof *64_* variants.\n\t(FP): New.\n\t(add_op2): Delete.\n\t(add<mode>3): Use reg_or_add_cint_operand.\n\t(sub_op2): Delete.\n\t(sub<mode>3): Use reg_or_sub_cint_operand.\n\t(udiv<mode>3, div<mode>3, div<mode>3_no_mq, mod<mode>3,\n\tmov<mode>_internal2, mov<mode>, cmp<mode>, cmp<mode>,\n\tcmp<mode>_internal1, indirect_jump<mode>, ctr<mode>,\n\tctr<mode>_internal1, ctr<mode>_internal2, ctr<mode>_internal5,\n\tctr<mode>_internal6, save_fpregs_<mode>, return_internal_<mode>,\n\treturn_and_restore_fpregs_<mode>, eh_set_lr_<mode>,\n\tvarious unnamed patterns): New.\n\t(udivsi3, divsi3, divsi3_no_mq, modsi3, movsi_internal2, movsi,\n\tcmpsi, cmpsi_internal1, indirect_jumpsi, ctrsi, ctrsi_internal1,\n\tctrsi_internal2, ctrsi_internal5, ctrsi_internal6, save_fpregs_si,\n\treturn_internal_si, return_and_restore_fpregs_si, eh_set_lr_si,\n\tudivdi3, divdi3, divdi3_no_mq, moddi3, movdi_internal2, movdi,\n\tcmpdi, cmpdi_internal1, indirect_jumpdi, ctrdi, ctrdi_internal1,\n\tctrdi_internal2, ctrdi_internal5, ctrdi_internal6, save_fpregs_di,\n\treturn_internal_di, return_and_restore_fpregs_di, eh_set_lr_di,\n\tmovhi, movqi, cmpsf, cmpdf, cmptf, various unnamed patterns):\n\tDelete.\n\nFrom-SVN: r100852", "tree": {"sha": "582152b94163b35aeb026813fb56a7e27e616a4e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/582152b94163b35aeb026813fb56a7e27e616a4e"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4ae234b0a1972354d8f6e526cfca999a82ade2e6", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae234b0a1972354d8f6e526cfca999a82ade2e6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ae234b0a1972354d8f6e526cfca999a82ade2e6", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ae234b0a1972354d8f6e526cfca999a82ade2e6/comments", "author": {"login": "geoffk01", "id": 31905243, "node_id": "MDQ6VXNlcjMxOTA1MjQz", "avatar_url": "https://avatars.githubusercontent.com/u/31905243?v=4", "gravatar_id": "", "url": "https://api.github.com/users/geoffk01", "html_url": "https://github.com/geoffk01", "followers_url": "https://api.github.com/users/geoffk01/followers", "following_url": "https://api.github.com/users/geoffk01/following{/other_user}", "gists_url": "https://api.github.com/users/geoffk01/gists{/gist_id}", "starred_url": "https://api.github.com/users/geoffk01/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/geoffk01/subscriptions", "organizations_url": "https://api.github.com/users/geoffk01/orgs", "repos_url": "https://api.github.com/users/geoffk01/repos", "events_url": "https://api.github.com/users/geoffk01/events{/privacy}", "received_events_url": "https://api.github.com/users/geoffk01/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "58b82d2b1a414470ea15282f5642bcfc0029e184", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58b82d2b1a414470ea15282f5642bcfc0029e184", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58b82d2b1a414470ea15282f5642bcfc0029e184"}], "stats": {"total": 1064, "additions": 261, "deletions": 803}, "files": [{"sha": "4a6d731acb1c03427e0335fc38243b87b4ecf217", "filename": "gcc/ChangeLog", "status": "modified", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4ae234b0a1972354d8f6e526cfca999a82ade2e6", "patch": "@@ -1,3 +1,44 @@\n+2005-06-11  Geoffrey Keating  <geoffk@apple.com>\n+\n+\t* config/rs6000/predicates.md (reg_or_arith_cint_operand): Delete.\n+\t(reg_or_add_cint_operand): Rename from reg_or_add_cint64_operand.\n+\tHandle SImode.\n+\t(reg_or_sub_cint_operand): Likewise.\n+\t(mask_operand): Handle DImode.\n+\t(mask64_operand): Delete.\n+\t(and64_operand): Delete.\n+\t* config/rs6000/rs6000.c (num_insns_constant): Use mask_operand\n+\tinstead of mask64_operand.\n+\t(print_operand): Likewise.\n+\t(rs6000_rtx_costs): Use mask_operand and reg_or_add_cint_operand and\n+\treg_or_sub_cint_operand instead of *64_* variants.\n+\t* config/rs6000/rs6000.h (EXTRA_CONSTRAINT): Use mask_operand\n+\tinstead of mask64_operand.\n+\t* config/rs6000/rs6000.md: Use mask_operand and and_operand instead\n+\tof *64_* variants.\n+\t(FP): New.\n+\t(add_op2): Delete.\n+\t(add<mode>3): Use reg_or_add_cint_operand.\n+\t(sub_op2): Delete.\n+\t(sub<mode>3): Use reg_or_sub_cint_operand.\n+\t(udiv<mode>3, div<mode>3, div<mode>3_no_mq, mod<mode>3,\n+\tmov<mode>_internal2, mov<mode>, cmp<mode>, cmp<mode>,\n+\tcmp<mode>_internal1, indirect_jump<mode>, ctr<mode>,\n+\tctr<mode>_internal1, ctr<mode>_internal2, ctr<mode>_internal5,\n+\tctr<mode>_internal6, save_fpregs_<mode>, return_internal_<mode>,\n+\treturn_and_restore_fpregs_<mode>, eh_set_lr_<mode>,\n+\tvarious unnamed patterns): New.\n+\t(udivsi3, divsi3, divsi3_no_mq, modsi3, movsi_internal2, movsi,\n+\tcmpsi, cmpsi_internal1, indirect_jumpsi, ctrsi, ctrsi_internal1,\n+\tctrsi_internal2, ctrsi_internal5, ctrsi_internal6, save_fpregs_si,\n+\treturn_internal_si, return_and_restore_fpregs_si, eh_set_lr_si,\n+\tudivdi3, divdi3, divdi3_no_mq, moddi3, movdi_internal2, movdi,\n+\tcmpdi, cmpdi_internal1, indirect_jumpdi, ctrdi, ctrdi_internal1,\n+\tctrdi_internal2, ctrdi_internal5, ctrdi_internal6, save_fpregs_di,\n+\treturn_internal_di, return_and_restore_fpregs_di, eh_set_lr_di,\n+\tmovhi, movqi, cmpsf, cmpdf, cmptf, various unnamed patterns):\n+\tDelete.\n+\n 2005-06-11  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n \n \t* rtl.h (to_rtx_code): Remove."}, {"sha": "cba7337882579fbe6e4e8311a338a4fcf0cba69e", "filename": "gcc/config/rs6000/predicates.md", "status": "modified", "additions": 35, "deletions": 67, "changes": 102, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Fpredicates.md?ref=4ae234b0a1972354d8f6e526cfca999a82ade2e6", "patch": "@@ -143,30 +143,25 @@\n \t\t\t\t\t   (TARGET_32BIT ? 'L' : 'J'))\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n-;; Return 1 if op is a 32-bit signed constant integer valid for arithmetic\n+;; Return 1 if op is a constant integer valid for addition\n ;; or non-special register.\n-(define_predicate \"reg_or_arith_cint_operand\"\n+(define_predicate \"reg_or_add_cint_operand\"\n   (if_then_else (match_code \"const_int\")\n-    (match_test \"HOST_BITS_PER_WIDE_INT == 32\n-\t\t || ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80000000)\n-\t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n-    (match_operand 0 \"gpc_reg_operand\")))\n-\n-;; Return 1 if op is a 32-bit signed constant integer valid for 64-bit addition\n-;; or non-special register.\n-(define_predicate \"reg_or_add_cint64_operand\"\n-  (if_then_else (match_code \"const_int\")\n-    (match_test \"(HOST_BITS_PER_WIDE_INT == 32 && INTVAL (op) < 0x7fff8000)\n+    (match_test \"(HOST_BITS_PER_WIDE_INT == 32\n+\t\t  && (mode == SImode || INTVAL (op) < 0x7fff8000))\n \t\t || ((unsigned HOST_WIDE_INT) (INTVAL (op) + 0x80008000)\n \t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n-;; Return 1 if op is a 32-bit constant integer valid for 64-bit subtraction\n+;; Return 1 if op is a constant integer valid for subtraction\n ;; or non-special register.\n-(define_predicate \"reg_or_sub_cint64_operand\"\n+(define_predicate \"reg_or_sub_cint_operand\"\n   (if_then_else (match_code \"const_int\")\n-    (match_test \"(HOST_BITS_PER_WIDE_INT == 32 && INTVAL (op) < 0x7fff8000)\n-\t\t || ((unsigned HOST_WIDE_INT) ((- INTVAL (op)) + 0x80008000)\n+    (match_test \"(HOST_BITS_PER_WIDE_INT == 32\n+\t\t  && (mode == SImode || - INTVAL (op) < 0x7fff8000))\n+\t\t || ((unsigned HOST_WIDE_INT) (- INTVAL (op) \n+\t\t\t\t\t       + (mode == SImode\n+\t\t\t\t\t\t  ? 0x80000000 : 0x80008000))\n \t\t     < (unsigned HOST_WIDE_INT) 0x100000000ll)\")\n     (match_operand 0 \"gpc_reg_operand\")))\n \n@@ -439,10 +434,14 @@\n        (and (not (match_operand 0 \"logical_operand\"))\n \t    (match_operand 0 \"reg_or_logical_cint_operand\"))))\n \n-;; Return 1 if op is a constant that can be encoded in a 32-bit mask (no\n-;; more than two 1->0 or 0->1 transitions).  Reject all ones and all\n-;; zeros, since these should have been optimized away and confuse the\n-;; making of MB and ME.\n+;; For SImode, return 1 if op is a constant that can be encoded in a\n+;; 32-bit mask (no more than two 1->0 or 0->1 transitions).  Reject\n+;; all ones and all zeros, since these should have been optimized away\n+;; and confuse the making of MB and ME.\n+;; For DImode, return 1 if the operand is a constant that is a\n+;; PowerPC64 mask (no more than one 1->0 or 0->1 transitions).  Reject\n+;; all zeros, since zero should have been optimized away and confuses\n+;; the making of MB and ME.\n (define_predicate \"mask_operand\"\n   (match_code \"const_int\")\n {\n@@ -452,29 +451,32 @@\n \n   /* Fail in 64-bit mode if the mask wraps around because the upper\n      32-bits of the mask will all be 1s, contrary to GCC's internal view.  */\n-  if (TARGET_POWERPC64 && (c & 0x80000001) == 0x80000001)\n+  if (mode == SImode && TARGET_POWERPC64 && (c & 0x80000001) == 0x80000001)\n+    return 0;\n+\n+  /* Reject all zeros or all ones in 32-bit mode.  */\n+  if (c == 0 || (mode == SImode && c == -1))\n     return 0;\n \n   /* We don't change the number of transitions by inverting,\n      so make sure we start with the LS bit zero.  */\n   if (c & 1)\n     c = ~c;\n \n-  /* Reject all zeros or all ones.  */\n-  if (c == 0)\n-    return 0;\n-\n   /* Find the first transition.  */\n   lsb = c & -c;\n \n-  /* Invert to look for a second transition.  */\n-  c = ~c;\n+  if (mode == SImode)\n+    {\n+      /* Invert to look for a second transition.  */\n+      c = ~c;\n \n-  /* Erase first transition.  */\n-  c &= -lsb;\n+      /* Erase first transition.  */\n+      c &= -lsb;\n \n-  /* Find the second transition (if any).  */\n-  lsb = c & -c;\n+      /* Find the second transition (if any).  */\n+      lsb = c & -c;\n+    }\n \n   /* Match if all the bits above are 1's (or c is zero).  */\n   return c == -lsb;\n@@ -502,33 +504,7 @@\n   return c == -lsb;\n })\n \n-;; Return 1 if the operand is a constant that is a PowerPC64 mask (no more\n-;; than one 1->0 or 0->1 transitions).  Reject all zeros, since zero\n-;; should have been optimized away and confuses the making of MB and ME.\n-(define_predicate \"mask64_operand\"\n-  (match_code \"const_int\")\n-{\n-  HOST_WIDE_INT c, lsb;\n-\n-  c = INTVAL (op);\n-\n-  /* Reject all zeros.  */\n-  if (c == 0)\n-    return 0;\n-\n-  /* We don't change the number of transitions by inverting,\n-     so make sure we start with the LS bit zero.  */\n-  if (c & 1)\n-    c = ~c;\n-\n-  /* Find the transition, and check that all bits above are 1's.  */\n-  lsb = c & -c;\n-\n-  /* Match if all the bits above are 1's (or c is zero).  */\n-  return c == -lsb;\n-})\n-\n-;; Like mask64_operand, but allow up to three transitions.  This\n+;; Like mask_operand, but allow up to three transitions.  This\n ;; predicate is used by insn patterns that generate two rldicl or\n ;; rldicr machine insns.\n (define_predicate \"mask64_2_operand\"\n@@ -537,15 +513,7 @@\n   return mask64_1or2_operand (op, mode, false);\n })\n \n-;; Return 1 if the operand is either a non-special register or a constant\n-;; that can be used as the operand of a PowerPC64 logical AND insn.\n-(define_predicate \"and64_operand\"\n-  (ior (match_operand 0 \"mask64_operand\")\n-       (if_then_else (match_test \"fixed_regs[CR0_REGNO]\")\n-\t (match_operand 0 \"gpc_reg_operand\")\n-\t (match_operand 0 \"logical_operand\"))))\n-\n-;; Like and64_operand, but also match constants that can be implemented\n+;; Like and_operand, but also match constants that can be implemented\n ;; with two rldicl or rldicr insns.\n (define_predicate \"and64_2_operand\"\n   (ior (and (match_code \"const_int\")"}, {"sha": "db7f851a5ac73b157da1f00c786b7f72cdc8806f", "filename": "gcc/config/rs6000/rs6000.c", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.c?ref=4ae234b0a1972354d8f6e526cfca999a82ade2e6", "patch": "@@ -1948,7 +1948,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n     case CONST_INT:\n #if HOST_BITS_PER_WIDE_INT == 64\n       if ((INTVAL (op) >> 31) != 0 && (INTVAL (op) >> 31) != -1\n-\t  && mask64_operand (op, mode))\n+\t  && mask_operand (op, mode))\n \treturn 2;\n       else\n #endif\n@@ -1990,7 +1990,7 @@ num_insns_constant (rtx op, enum machine_mode mode)\n \t\t|| (high == -1 && low < 0))\n \t      return num_insns_constant_wide (low);\n \t    \n-\t    else if (mask64_operand (op, mode))\n+\t    else if (mask_operand (op, mode))\n \t      return 2;\n \t    \n \t    else if (low == 0)\n@@ -9880,7 +9880,7 @@ print_operand (FILE *file, rtx x, int code)\n       /* PowerPC64 mask position.  All 0's is excluded.\n \t CONST_INT 32-bit mask is considered sign-extended so any\n \t transition must occur within the CONST_INT, not on the boundary.  */\n-      if (! mask64_operand (x, DImode))\n+      if (! mask_operand (x, DImode))\n \toutput_operand_lossage (\"invalid %%S value\");\n \n       uval = INT_LOWPART (x);\n@@ -17594,9 +17594,9 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  return true;\n \t}\n       else if ((outer_code == PLUS\n-\t\t&& reg_or_add_cint64_operand (x, VOIDmode))\n+\t\t&& reg_or_add_cint_operand (x, VOIDmode))\n \t       || (outer_code == MINUS\n-\t\t   && reg_or_sub_cint64_operand (x, VOIDmode))\n+\t\t   && reg_or_sub_cint_operand (x, VOIDmode))\n \t       || ((outer_code == SET\n \t\t    || outer_code == IOR\n \t\t    || outer_code == XOR)\n@@ -17613,7 +17613,7 @@ rs6000_rtx_costs (rtx x, int code, int outer_code, int *total)\n \t  && ((outer_code == AND\n \t       && (CONST_OK_FOR_LETTER_P (INTVAL (x), 'K')\n \t\t   || CONST_OK_FOR_LETTER_P (INTVAL (x), 'L')\n-\t\t   || mask64_operand (x, DImode)))\n+\t\t   || mask_operand (x, DImode)))\n \t      || ((outer_code == IOR || outer_code == XOR)\n \t\t  && CONST_DOUBLE_HIGH (x) == 0\n \t\t  && (CONST_DOUBLE_LOW (x)"}, {"sha": "1e970283e15e0eb1b1353ca3bfc93ceefe71f194", "filename": "gcc/config/rs6000/rs6000.h", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.h?ref=4ae234b0a1972354d8f6e526cfca999a82ade2e6", "patch": "@@ -1099,14 +1099,14 @@ enum reg_class\n #define EXTRA_CONSTRAINT(OP, C)\t\t\t\t\t\t\\\n   ((C) == 'Q' ? GET_CODE (OP) == MEM && GET_CODE (XEXP (OP, 0)) == REG\t\\\n    : (C) == 'R' ? legitimate_constant_pool_address_p (OP)\t\t\\\n-   : (C) == 'S' ? mask64_operand (OP, DImode)\t\t\t\t\\\n+   : (C) == 'S' ? mask_operand (OP, DImode)\t\t\t\t\\\n    : (C) == 'T' ? mask_operand (OP, SImode)\t\t\t\t\\\n    : (C) == 'U' ? (DEFAULT_ABI == ABI_V4\t\t\t\t\\\n \t\t   && small_data_operand (OP, GET_MODE (OP)))\t\t\\\n    : (C) == 't' ? (mask64_2_operand (OP, DImode)\t\t\t\\\n \t\t   && (fixed_regs[CR0_REGNO]\t\t\t\t\\\n \t\t       || !logical_operand (OP, DImode))\t\t\\\n-\t\t   && !mask64_operand (OP, DImode))\t\t\t\\\n+\t\t   && !mask_operand (OP, DImode))\t\t\t\\\n    : (C) == 'W' ? (easy_vector_constant (OP, GET_MODE (OP)))\t\t\\\n    : (C) == 'Y' ? (word_offset_memref_operand (OP, GET_MODE (OP)))      \\\n    : (C) == 'Z' ? (indexed_or_indirect_operand (OP, GET_MODE (OP)))\t\\"}, {"sha": "8e4fd3551d0e8058c40f7c4e14248cb1a10c59bf", "filename": "gcc/config/rs6000/rs6000.md", "status": "modified", "additions": 177, "deletions": 728, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4ae234b0a1972354d8f6e526cfca999a82ade2e6/gcc%2Fconfig%2Frs6000%2Frs6000.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Frs6000%2Frs6000.md?ref=4ae234b0a1972354d8f6e526cfca999a82ade2e6", "patch": "@@ -134,6 +134,12 @@\n ; (one with a '.') will compare.\n (define_mode_macro P [(SI \"TARGET_32BIT\") (DI \"TARGET_64BIT\")])\n \n+; Any hardware-supported floating-point mode\n+(define_mode_macro FP [(SF \"TARGET_HARD_FLOAT\")\n+  (DF \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\")\n+  (TF \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n+   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\")])\n+\n ; Various instructions that come in SI and DI forms.\n (define_mode_attr larx [(SI \"lwarx\") (DI \"ldarx\")])\n (define_mode_attr stcx [(SI \"stwcx.\") (DI \"stdcx.\")])\n@@ -1007,13 +1013,10 @@\n \n ;; Fixed-point arithmetic insns.\n \n-(define_mode_attr add_op2 [(SI \"reg_or_arith_cint_operand\")\n-\t\t\t   (DI \"reg_or_add_cint64_operand\")])\n-\n (define_expand \"add<mode>3\"\n   [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n \t(plus:SDI (match_operand:SDI 1 \"gpc_reg_operand\" \"\")\n-\t\t  (match_operand:SDI 2 \"<add_op2>\" \"\")))]\n+\t\t  (match_operand:SDI 2 \"reg_or_add_cint_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1321,13 +1324,10 @@\n \t\t    (const_int 0)))]\n   \"\")\n \n-(define_mode_attr sub_op2 [(SI \"reg_or_arith_cint_operand\")\n-\t\t\t   (DI \"reg_or_sub_cint64_operand\")])\n-\n (define_expand \"sub<mode>3\"\n   [(set (match_operand:SDI 0 \"gpc_reg_operand\" \"\")\n \t(minus:SDI (match_operand:SDI 1 \"reg_or_short_operand\" \"\")\n-\t\t   (match_operand:SDI 2 \"<sub_op2>\" \"\")))]\n+\t\t   (match_operand:SDI 2 \"reg_or_sub_cint_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -1945,10 +1945,10 @@\n   \"divs %0,%1,%2\"\n   [(set_attr \"type\" \"idiv\")])\n \n-(define_expand \"udivsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-        (udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-                 (match_operand:SI 2 \"gpc_reg_operand\" \"\")))]\n+(define_expand \"udiv<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+        (udiv:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"\")))]\n   \"TARGET_POWERPC || (! TARGET_POWER && ! TARGET_POWERPC)\"\n   \"\n {\n@@ -1977,21 +1977,21 @@\n   [(set_attr \"type\" \"idiv\")])\n \n (define_insn \"*udivsi3_no_mq\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (udiv:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-                 (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+        (udiv:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t  (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC && ! TARGET_POWER\"\n-  \"divwu %0,%1,%2\"\n+  \"div<wd>u %0,%1,%2\"\n   [(set_attr \"type\" \"idiv\")])\n \n ;; For powers of two we can do srai/aze for divide and then adjust for\n ;; modulus.  If it isn't a power of two, FAIL on POWER so divmodsi4 will be\n ;; used; for PowerPC, force operands into register and do a normal divide;\n ;; for AIX common-mode, use quoss call on register operands.\n-(define_expand \"divsi3\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:SI 2 \"reg_or_cint_operand\" \"\")))]\n+(define_expand \"div<mode>3\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t(div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t (match_operand:GPR 2 \"reg_or_cint_operand\" \"\")))]\n   \"\"\n   \"\n {\n@@ -2029,18 +2029,18 @@\n   \"divw %0,%1,%2\"\n   [(set_attr \"type\" \"idiv\")])\n \n-(define_insn \"*divsi3_no_mq\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-        (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-                (match_operand:SI 2 \"gpc_reg_operand\" \"r\")))]\n+(define_insn \"*div<mode>3_no_mq\"\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+        (div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:GPR 2 \"gpc_reg_operand\" \"r\")))]\n   \"TARGET_POWERPC && ! TARGET_POWER\"\n-  \"divw %0,%1,%2\"\n+  \"div<wd> %0,%1,%2\"\n   [(set_attr \"type\" \"idiv\")])\n \n-(define_expand \"modsi3\"\n-  [(use (match_operand:SI 0 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:SI 1 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:SI 2 \"reg_or_cint_operand\" \"\"))]\n+(define_expand \"mod<mode>3\"\n+  [(use (match_operand:GPR 0 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:GPR 1 \"gpc_reg_operand\" \"\"))\n+   (use (match_operand:GPR 2 \"reg_or_cint_operand\" \"\"))]\n   \"\"\n   \"\n {\n@@ -2053,75 +2053,77 @@\n       || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n     FAIL;\n \n-  temp1 = gen_reg_rtx (SImode);\n-  temp2 = gen_reg_rtx (SImode);\n+  temp1 = gen_reg_rtx (<MODE>mode);\n+  temp2 = gen_reg_rtx (<MODE>mode);\n \n-  emit_insn (gen_divsi3 (temp1, operands[1], operands[2]));\n-  emit_insn (gen_ashlsi3 (temp2, temp1, GEN_INT (i)));\n-  emit_insn (gen_subsi3 (operands[0], operands[1], temp2));\n+  emit_insn (gen_div<mode>3 (temp1, operands[1], operands[2]));\n+  emit_insn (gen_ashl<mode>3 (temp2, temp1, GEN_INT (i)));\n+  emit_insn (gen_sub<mode>3 (operands[0], operands[1], temp2));\n   DONE;\n }\")\n \n (define_insn \"\"\n-  [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n-\t(div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:SI 2 \"exact_log2_cint_operand\" \"N\")))]\n+  [(set (match_operand:GPR 0 \"gpc_reg_operand\" \"=r\")\n+\t(div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t (match_operand:GPR 2 \"exact_log2_cint_operand\" \"N\")))]\n   \"\"\n-  \"{srai|srawi} %0,%1,%p2\\;{aze|addze} %0,%0\"\n+  \"{srai|sra<wd>i} %0,%1,%p2\\;{aze|addze} %0,%0\"\n   [(set_attr \"type\" \"two\")\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"N,N\"))\n+\t(compare:CC (div:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t   (match_operand:P 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"=r,r\"))]\n+   (clobber (match_scratch:P 3 \"=r,r\"))]\n   \"\"\n   \"@\n-   {srai|srawi} %3,%1,%p2\\;{aze.|addze.} %3,%3\n+   {srai|sra<wd>i} %3,%1,%p2\\;{aze.|addze.} %3,%3\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"8,12\")])\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"\"))\n+\t(compare:CC (div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:GPR 2 \"exact_log2_cint_operand\"\n+\t\t\t      \"\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))]\n+   (clobber (match_scratch:GPR 3 \"\"))]\n   \"reload_completed\"\n   [(set (match_dup 3)\n-\t(div:SI (match_dup 1) (match_dup 2)))\n+\t(div:<MODE> (match_dup 1) (match_dup 2)))\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n \t\t    (const_int 0)))]\n   \"\")\n \n (define_insn \"\"\n   [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"N,N\"))\n+\t(compare:CC (div:P (match_operand:P 1 \"gpc_reg_operand\" \"r,r\")\n+\t\t\t   (match_operand:P 2 \"exact_log2_cint_operand\" \"N,N\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(div:SI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r\")\n+\t(div:P (match_dup 1) (match_dup 2)))]\n   \"\"\n   \"@\n-   {srai|srawi} %0,%1,%p2\\;{aze.|addze.} %0,%0\n+   {srai|sra<wd>i} %0,%1,%p2\\;{aze.|addze.} %0,%0\n    #\"\n   [(set_attr \"type\" \"compare\")\n    (set_attr \"length\" \"8,12\")])\n \n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (div:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"exact_log2_cint_operand\" \"\"))\n+\t(compare:CC (div:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:GPR 2 \"exact_log2_cint_operand\"\n+\t\t\t      \"\"))\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(div:SI (match_dup 1) (match_dup 2)))]\n+   (set (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+\t(div:GPR (match_dup 1) (match_dup 2)))]\n   \"reload_completed\"\n   [(set (match_dup 0)\n-\t(div:SI (match_dup 1) (match_dup 2)))\n+\t(div:<MODE> (match_dup 1) (match_dup 2)))\n    (set (match_dup 3)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n@@ -2362,15 +2364,15 @@\n \n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (and:SI (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:SI 2 \"and_operand\" \"\"))\n+\t(compare:CC (and:GPR (match_operand:GPR 1 \"gpc_reg_operand\" \"\")\n+\t\t\t     (match_operand:GPR 2 \"and_operand\" \"\"))\n \t\t    (const_int 0)))\n-   (clobber (match_scratch:SI 3 \"\"))\n+   (clobber (match_scratch:GPR 3 \"\"))\n    (clobber (match_scratch:CC 4 \"\"))]\n   \"reload_completed\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (and:SI (match_dup 1)\n-\t\t\t   (match_dup 2)))\n+\t\t   (and:<MODE> (match_dup 1)\n+\t\t\t       (match_dup 2)))\n \t      (clobber (match_dup 4))])\n    (set (match_dup 0)\n \t(compare:CC (match_dup 3)\n@@ -6033,127 +6035,6 @@\n   \"mulhdu %0,%1,%2\"\n   [(set_attr \"type\" \"lmul\")])\n \n-(define_expand \"divdi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\")))]\n-  \"TARGET_POWERPC64\"\n-  \"\n-{\n-  if (GET_CODE (operands[2]) == CONST_INT\n-      && INTVAL (operands[2]) > 0\n-      && exact_log2 (INTVAL (operands[2])) >= 0)\n-    ;\n-  else\n-    operands[2] = force_reg (DImode, operands[2]);\n-}\")\n-\n-(define_expand \"moddi3\"\n-  [(use (match_operand:DI 0 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:DI 1 \"gpc_reg_operand\" \"\"))\n-   (use (match_operand:DI 2 \"reg_or_cint_operand\" \"\"))]\n-  \"TARGET_POWERPC64\"\n-  \"\n-{\n-  int i;\n-  rtx temp1;\n-  rtx temp2;\n-\n-  if (GET_CODE (operands[2]) != CONST_INT\n-      || INTVAL (operands[2]) <= 0\n-      || (i = exact_log2 (INTVAL (operands[2]))) < 0)\n-    FAIL;\n-\n-  temp1 = gen_reg_rtx (DImode);\n-  temp2 = gen_reg_rtx (DImode);\n-\n-  emit_insn (gen_divdi3 (temp1, operands[1], operands[2]));\n-  emit_insn (gen_ashldi3 (temp2, temp1, GEN_INT (i)));\n-  emit_insn (gen_subdi3 (operands[0], operands[1], temp2));\n-  DONE;\n-}\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-\t(div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t(match_operand:DI 2 \"exact_log2_cint_operand\" \"N\")))]\n-  \"TARGET_POWERPC64\"\n-  \"sradi %0,%1,%p2\\;addze %0,%0\"\n-  [(set_attr \"type\" \"two\")\n-   (set_attr \"length\" \"8\")])\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"N,N\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"=r,r\"))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   sradi %3,%1,%p2\\;addze. %3,%3\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 3)\n-\t(div:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 0)\n-\t(compare:CC (match_dup 3)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:CC 3 \"cc_reg_operand\" \"=x,?y\")\n-\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n-\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"N,N\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n-\t(div:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   sradi %0,%1,%p2\\;addze. %0,%0\n-   #\"\n-  [(set_attr \"type\" \"compare\")\n-   (set_attr \"length\" \"8,12\")])\n-\n-(define_split\n-  [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"exact_log2_cint_operand\" \"\"))\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(div:DI (match_dup 1) (match_dup 2)))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0)\n-\t(div:DI (match_dup 1) (match_dup 2)))\n-   (set (match_dup 3)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n-\n-(define_insn \"\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-        (div:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_POWERPC64\"\n-  \"divd %0,%1,%2\"\n-  [(set_attr \"type\" \"ldiv\")])\n-\n-(define_insn \"udivdi3\"\n-  [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n-        (udiv:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-                 (match_operand:DI 2 \"gpc_reg_operand\" \"r\")))]\n-  \"TARGET_POWERPC64\"\n-  \"divdu %0,%1,%2\"\n-  [(set_attr \"type\" \"ldiv\")])\n-\n (define_insn \"rotldi3\"\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n@@ -6221,7 +6102,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:DI 2 \"reg_or_cint_operand\" \"ri\"))\n-\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n+\t\t(match_operand:DI 3 \"mask_operand\" \"n\")))]\n   \"TARGET_POWERPC64\"\n   \"rld%I2c%B3 %0,%1,%H2,%S3\")\n \n@@ -6230,7 +6111,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n+\t\t     (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n   \"TARGET_64BIT\"\n@@ -6245,7 +6126,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t     (match_operand:DI 3 \"mask_operand\" \"\"))\n \t\t    (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\"\n@@ -6263,7 +6144,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"ri,ri\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n+\t\t     (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6279,7 +6160,7 @@\n \t(compare:CC (and:DI\n \t\t     (rotate:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t(match_operand:DI 2 \"reg_or_cint_operand\" \"\"))\n-\t\t     (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t     (match_operand:DI 3 \"mask_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (rotate:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6677,7 +6558,7 @@\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"=r\")\n \t(and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n \t\t\t   (match_operand:SI 2 \"const_int_operand\" \"i\"))\n-\t\t(match_operand:DI 3 \"mask64_operand\" \"n\")))]\n+\t\t(match_operand:DI 3 \"mask_operand\" \"n\")))]\n   \"TARGET_POWERPC64 && includes_rldicr_lshift_p (operands[2], operands[3])\"\n   \"rldicr %0,%1,%H2,%S3\")\n \n@@ -6686,7 +6567,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n+\t\t (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"=r,r\"))]\n   \"TARGET_64BIT && includes_rldicr_lshift_p (operands[2], operands[3])\"\n@@ -6701,7 +6582,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask_operand\" \"\"))\n \t (const_int 0)))\n    (clobber (match_scratch:DI 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n@@ -6719,7 +6600,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"r,r\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"i,i\"))\n-\t\t    (match_operand:DI 3 \"mask64_operand\" \"n,n\"))\n+\t\t    (match_operand:DI 3 \"mask_operand\" \"n,n\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6735,7 +6616,7 @@\n \t(compare:CC\n \t (and:DI (ashift:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n \t\t\t    (match_operand:SI 2 \"const_int_operand\" \"\"))\n-\t\t (match_operand:DI 3 \"mask64_operand\" \"\"))\n+\t\t (match_operand:DI 3 \"mask_operand\" \"\"))\n \t (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (ashift:DI (match_dup 1) (match_dup 2)) (match_dup 3)))]\n@@ -6940,7 +6821,7 @@\n    (clobber (match_scratch:CC 3 \"\"))]\n   \"TARGET_POWERPC64\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask64_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 4))\n@@ -6975,23 +6856,6 @@\n   [(set_attr \"type\" \"compare,delayed_compare,compare,compare,delayed_compare,compare,compare,compare,compare,compare\")\n    (set_attr \"length\" \"4,4,4,4,8,8,8,8,8,12\")])\n \n-(define_split\n-  [(set (match_operand:CC 0 \"cc_reg_not_cr0_operand\" \"\")\n-        (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-                            (match_operand:DI 2 \"and64_operand\" \"\"))\n-                    (const_int 0)))\n-   (clobber (match_scratch:DI 3 \"\"))\n-   (clobber (match_scratch:CC 4 \"\"))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-                   (and:DI (match_dup 1)\n-                           (match_dup 2)))\n-              (clobber (match_dup 4))])\n-   (set (match_dup 0)\n-        (compare:CC (match_dup 3)\n-                    (const_int 0)))]\n-  \"\")\n-\n (define_split\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"\")\n         (compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n@@ -7001,7 +6865,7 @@\n    (clobber (match_scratch:CC 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask64_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\"\n   [(set (match_dup 3)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 5))\n@@ -7043,7 +6907,7 @@\n (define_split\n   [(set (match_operand:CC 3 \"cc_reg_not_cr0_operand\" \"\")\n \t(compare:CC (and:DI (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t    (match_operand:DI 2 \"and64_operand\" \"\"))\n+\t\t\t    (match_operand:DI 2 \"and_operand\" \"\"))\n \t\t    (const_int 0)))\n    (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n \t(and:DI (match_dup 1) (match_dup 2)))\n@@ -7067,7 +6931,7 @@\n    (clobber (match_scratch:CC 4 \"\"))]\n   \"TARGET_POWERPC64 && reload_completed\n     && (fixed_regs[CR0_REGNO] || !logical_operand (operands[2], DImode))\n-    && !mask64_operand (operands[2], DImode)\"\n+    && !mask_operand (operands[2], DImode)\"\n   [(set (match_dup 0)\n \t(and:DI (rotate:DI (match_dup 1)\n \t\t\t   (match_dup 5))\n@@ -7445,12 +7309,6 @@\n ;; do the load 16-bits at a time.  We could do this by loading from memory,\n ;; and this is even supposed to be faster, but it is simpler not to get\n ;; integers in the TOC.\n-(define_expand \"movsi\"\n-  [(set (match_operand:SI 0 \"general_operand\" \"\")\n-\t(match_operand:SI 1 \"any_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], SImode); DONE; }\")\n-\n (define_insn \"movsi_low\"\n   [(set (match_operand:SI 0 \"gpc_reg_operand\" \"=r\")\n         (mem:SI (lo_sum:SI (match_operand:SI 1 \"gpc_reg_operand\" \"b\")\n@@ -7504,37 +7362,31 @@\n     FAIL;\n }\")\n \n-(define_insn \"*movsi_internal2\"\n+(define_insn \"*mov<mode>_internal2\"\n   [(set (match_operand:CC 2 \"cc_reg_operand\" \"=y,x,?y\")\n-\t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"0,r,r\")\n+\t(compare:CC (match_operand:P 1 \"gpc_reg_operand\" \"0,r,r\")\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"=r,r,r\") (match_dup 1))]\n-  \"TARGET_32BIT\"\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"=r,r,r\") (match_dup 1))]\n+  \"\"\n   \"@\n-   {cmpi|cmpwi} %2,%0,0\n+   {cmpi|cmp<wd>i} %2,%0,0\n    mr. %0,%1\n    #\"\n   [(set_attr \"type\" \"cmp,compare,cmp\")\n    (set_attr \"length\" \"4,4,8\")])\n \n (define_split\n   [(set (match_operand:CC 2 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t(compare:CC (match_operand:P 1 \"gpc_reg_operand\" \"\")\n \t\t    (const_int 0)))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\") (match_dup 1))]\n-  \"TARGET_32BIT && reload_completed\"\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"\") (match_dup 1))]\n+  \"reload_completed\"\n   [(set (match_dup 0) (match_dup 1))\n    (set (match_dup 2)\n \t(compare:CC (match_dup 0)\n \t\t    (const_int 0)))]\n   \"\")\n \f\n-(define_expand \"movhi\"\n-  [(set (match_operand:HI 0 \"general_operand\" \"\")\n-\t(match_operand:HI 1 \"any_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], HImode); DONE; }\")\n-\n (define_insn \"*movhi_internal\"\n   [(set (match_operand:HI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*q,*c*l,*h\")\n \t(match_operand:HI 1 \"input_operand\" \"r,m,r,i,*h,r,r,0\"))]\n@@ -7551,11 +7403,11 @@\n    {cror 0,0,0|nop}\"\n   [(set_attr \"type\" \"*,load,store,*,mfjmpr,*,mtjmpr,*\")])\n \n-(define_expand \"movqi\"\n-  [(set (match_operand:QI 0 \"general_operand\" \"\")\n-\t(match_operand:QI 1 \"any_operand\" \"\"))]\n+(define_expand \"mov<mode>\"\n+  [(set (match_operand:INT 0 \"general_operand\" \"\")\n+\t(match_operand:INT 1 \"any_operand\" \"\"))]\n   \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], QImode); DONE; }\")\n+  \"{ rs6000_emit_move (operands[0], operands[1], <MODE>mode); DONE; }\")\n \n (define_insn \"*movqi_internal\"\n   [(set (match_operand:QI 0 \"nonimmediate_operand\" \"=r,r,m,r,r,*q,*c*l,*h\")\n@@ -8204,11 +8056,6 @@\n \f\n ;; Next come the multi-word integer load and store and the load and store\n ;; multiple insns.\n-(define_expand \"movdi\"\n-  [(set (match_operand:DI 0 \"general_operand\" \"\")\n-\t(match_operand:DI 1 \"any_operand\" \"\"))]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], DImode); DONE; }\")\n \n ; List r->r after r->\"o<>\", otherwise reload will try to reload a\n ; non-offsettable address by using r->r which won't make progress.\n@@ -8298,7 +8145,7 @@\n ;; Use (and:DI (rotate:DI ...)) to avoid anddi3 unnecessary clobber.\n (define_split\n   [(set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(match_operand:DI 1 \"mask64_operand\" \"\"))]\n+\t(match_operand:DI 1 \"mask_operand\" \"\"))]\n   \"TARGET_POWERPC64 && num_insns_constant (operands[1], DImode) > 1\"\n   [(set (match_dup 0) (const_int -1))\n    (set (match_dup 0)\n@@ -8340,41 +8187,10 @@\n   else\n     FAIL;\n }\")\n-\n-(define_insn \"*movdi_internal2\"\n-  [(set (match_operand:CC 2 \"cc_reg_operand\" \"=y,x,?y\")\n-\t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"0,r,r\")\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"=r,r,r\") (match_dup 1))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   cmpdi %2,%0,0\n-   mr. %0,%1\n-   #\"\n-  [(set_attr \"type\" \"cmp,compare,cmp\")\n-   (set_attr \"length\" \"4,4,8\")])\n-\n-(define_split\n-  [(set (match_operand:CC 2 \"cc_reg_not_cr0_operand\" \"\")\n-\t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t    (const_int 0)))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\") (match_dup 1))]\n-  \"TARGET_POWERPC64 && reload_completed\"\n-  [(set (match_dup 0) (match_dup 1))\n-   (set (match_dup 2)\n-\t(compare:CC (match_dup 0)\n-\t\t    (const_int 0)))]\n-  \"\")\n \f\n ;; TImode is similar, except that we usually want to compute the address into\n ;; a register and use lsi/stsi (the exception is during reload).  MQ is also\n ;; clobbered in stsi for POWER, so we need a SCRATCH for it.\n-(define_expand \"movti\"\n-  [(parallel [(set (match_operand:TI 0 \"general_operand\" \"\")\n-\t\t   (match_operand:TI 1 \"general_operand\" \"\"))\n-\t      (clobber (scratch:SI))])]\n-  \"\"\n-  \"{ rs6000_emit_move (operands[0], operands[1], TImode); DONE; }\")\n \n ;; We say that MQ is clobbered in the last alternative because the first\n ;; alternative would never get used otherwise since it would need a reload\n@@ -8878,8 +8694,8 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n+\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n    (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n@@ -8901,30 +8717,6 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:DI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:DI 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (reg:SI  6))\n-   (clobber (reg:SI  7))\n-   (clobber (reg:SI  8))\n-   (clobber (reg:SI  9))\n-   (clobber (reg:SI 10))\n-   (clobber (reg:SI 11))\n-   (clobber (reg:SI 12))\n-   (clobber (match_scratch:SI 5 \"X\"))]\n-  \"TARGET_STRING && TARGET_POWERPC64\n-   && ((INTVAL (operands[2]) > 24 && INTVAL (operands[2]) < 32)\n-       || INTVAL (operands[2]) == 0)\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 12)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 12)\n-   && REGNO (operands[4]) == 5\"\n-  \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n ;; Move up to 24 bytes at a time.  The fixed registers are needed because the\n ;; register allocator doesn't have a clue about allocating 6 word registers.\n ;; rD/rS = r5 is preferred, efficient form.\n@@ -8965,8 +8757,8 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n+\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n    (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n@@ -8985,27 +8777,6 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:DI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:DI 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (reg:SI  6))\n-   (clobber (reg:SI  7))\n-   (clobber (reg:SI  8))\n-   (clobber (reg:SI  9))\n-   (clobber (reg:SI 10))\n-   (clobber (match_scratch:SI 5 \"X\"))]\n-  \"TARGET_STRING && TARGET_POWERPC64\n-   && INTVAL (operands[2]) > 16 && INTVAL (operands[2]) <= 32\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 10)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 10)\n-   && REGNO (operands[4]) == 5\"\n-  \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n ;; Move up to 16 bytes at a time, using 4 fixed registers to avoid spill\n ;; problems with TImode.\n ;; rD/rS = r5 is preferred, efficient form.\n@@ -9042,8 +8813,8 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n+\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n    (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n@@ -9060,25 +8831,6 @@\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n \n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:DI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:DI 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_operand:SI 4 \"gpc_reg_operand\" \"=r\"))\n-   (clobber (reg:SI 6))\n-   (clobber (reg:SI 7))\n-   (clobber (reg:SI 8))\n-   (clobber (match_scratch:SI 5 \"X\"))]\n-  \"TARGET_STRING && TARGET_POWERPC64\n-   && INTVAL (operands[2]) > 8 && INTVAL (operands[2]) <= 16\n-   && (REGNO (operands[0]) < 5 || REGNO (operands[0]) > 8)\n-   && (REGNO (operands[1]) < 5 || REGNO (operands[1]) > 8)\n-   && REGNO (operands[4]) == 5\"\n-  \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n ;; Move up to 8 bytes at a time.\n (define_expand \"movmemsi_2reg\"\n   [(parallel [(set (match_operand 0 \"\" \"\")\n@@ -9141,8 +8893,8 @@\n    (set_attr \"length\" \"8\")])\n \n (define_insn \"\"\n-  [(set (mem:BLK (match_operand:SI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:SI 1 \"gpc_reg_operand\" \"b\")))\n+  [(set (mem:BLK (match_operand:P 0 \"gpc_reg_operand\" \"b\"))\n+\t(mem:BLK (match_operand:P 1 \"gpc_reg_operand\" \"b\")))\n    (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n    (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n    (clobber (match_scratch:SI 4 \"=&r\"))\n@@ -9152,20 +8904,6 @@\n   \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n   [(set_attr \"type\" \"load\")\n    (set_attr \"length\" \"8\")])\n-\n-(define_insn \"\"\n-  [(set (mem:BLK (match_operand:DI 0 \"gpc_reg_operand\" \"b\"))\n-\t(mem:BLK (match_operand:DI 1 \"gpc_reg_operand\" \"b\")))\n-   (use (match_operand:SI 2 \"immediate_operand\" \"i\"))\n-   (use (match_operand:SI 3 \"immediate_operand\" \"i\"))\n-   (clobber (match_scratch:SI 4 \"=&r\"))\n-   (clobber (match_scratch:SI 5 \"X\"))]\n-  \"TARGET_STRING && TARGET_POWERPC64\n-   && INTVAL (operands[2]) > 0 && INTVAL (operands[2]) <= 4\"\n-  \"{lsi|lswi} %4,%1,%2\\;{stsi|stswi} %4,%0,%2\"\n-  [(set_attr \"type\" \"load\")\n-   (set_attr \"length\" \"8\")])\n-\n \f\n ;; Define insns that do load or store with update.  Some of these we can\n ;; get by using pre-decrement or pre-increment, but the hardware can also\n@@ -10762,73 +10500,29 @@\n ;; Start with the DEFINE_EXPANDs to generate the rtl for compares, scc\n ;; insns, and branches.  We store the operands of compares until we see\n ;; how it is used.\n-(define_expand \"cmpsi\"\n+(define_expand \"cmp<mode>\"\n   [(set (cc0)\n-        (compare (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-  \t\t (match_operand:SI 1 \"reg_or_short_operand\" \"\")))]\n+        (compare (match_operand:GPR 0 \"gpc_reg_operand\" \"\")\n+  \t\t (match_operand:GPR 1 \"reg_or_short_operand\" \"\")))]\n   \"\"\n   \"\n {\n   /* Take care of the possibility that operands[1] might be negative but\n      this might be a logical operation.  That insn doesn't exist.  */\n   if (GET_CODE (operands[1]) == CONST_INT\n       && INTVAL (operands[1]) < 0)\n-    operands[1] = force_reg (SImode, operands[1]);\n-\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = operands[1];\n-  rs6000_compare_fp_p = 0;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdi\"\n-  [(set (cc0)\n-        (compare (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-  \t\t (match_operand:DI 1 \"reg_or_short_operand\" \"\")))]\n-  \"TARGET_POWERPC64\"\n-  \"\n-{\n-  /* Take care of the possibility that operands[1] might be negative but\n-     this might be a logical operation.  That insn doesn't exist.  */\n-  if (GET_CODE (operands[1]) == CONST_INT\n-      && INTVAL (operands[1]) < 0)\n-    operands[1] = force_reg (DImode, operands[1]);\n+    operands[1] = force_reg (<MODE>mode, operands[1]);\n \n   rs6000_compare_op0 = operands[0];\n   rs6000_compare_op1 = operands[1];\n   rs6000_compare_fp_p = 0;\n   DONE;\n }\")\n \n-(define_expand \"cmpsf\"\n-  [(set (cc0) (compare (match_operand:SF 0 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:SF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT\"\n-  \"\n-{\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = operands[1];\n-  rs6000_compare_fp_p = 1;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmpdf\"\n-  [(set (cc0) (compare (match_operand:DF 0 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:DF 1 \"gpc_reg_operand\" \"\")))]\n-  \"TARGET_HARD_FLOAT && (TARGET_FPRS || TARGET_E500_DOUBLE)\"\n-  \"\n-{\n-  rs6000_compare_op0 = operands[0];\n-  rs6000_compare_op1 = operands[1];\n-  rs6000_compare_fp_p = 1;\n-  DONE;\n-}\")\n-\n-(define_expand \"cmptf\"\n-  [(set (cc0) (compare (match_operand:TF 0 \"gpc_reg_operand\" \"\")\n-\t\t       (match_operand:TF 1 \"gpc_reg_operand\" \"\")))]\n-  \"(DEFAULT_ABI == ABI_AIX || DEFAULT_ABI == ABI_DARWIN)\n-   && TARGET_HARD_FLOAT && TARGET_FPRS && TARGET_LONG_DOUBLE_128\"\n+(define_expand \"cmp<mode>\"\n+  [(set (cc0) (compare (match_operand:FP 0 \"gpc_reg_operand\" \"\")\n+\t\t       (match_operand:FP 1 \"gpc_reg_operand\" \"\")))]\n+  \"\"\n   \"\n {\n   rs6000_compare_op0 = operands[0];\n@@ -11063,20 +10757,12 @@\n \n \f\n ;; Here are the actual compare insns.\n-(define_insn \"*cmpsi_internal1\"\n+(define_insn \"*cmp<mode>_internal1\"\n   [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CC (match_operand:SI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:SI 2 \"reg_or_short_operand\" \"rI\")))]\n+\t(compare:CC (match_operand:GPR 1 \"gpc_reg_operand\" \"r\")\n+\t\t    (match_operand:GPR 2 \"reg_or_short_operand\" \"rI\")))]\n   \"\"\n-  \"{cmp%I2|cmpw%I2} %0,%1,%2\"\n-  [(set_attr \"type\" \"cmp\")])\n-\n-(define_insn \"*cmpdi_internal1\"\n-  [(set (match_operand:CC 0 \"cc_reg_operand\" \"=y\")\n-\t(compare:CC (match_operand:DI 1 \"gpc_reg_operand\" \"r\")\n-\t\t    (match_operand:DI 2 \"reg_or_short_operand\" \"rI\")))]\n-  \"TARGET_POWERPC64\"\n-  \"cmpd%I2 %0,%1,%2\"\n+  \"{cmp%I2|cmp<wd>%I2} %0,%1,%2\"\n   [(set_attr \"type\" \"cmp\")])\n \n ;; If we are comparing a register for equality with a large constant,\n@@ -13765,33 +13451,16 @@\n   [(set_attr \"type\" \"jmpreg\")])\n \n (define_expand \"indirect_jump\"\n-  [(set (pc) (match_operand 0 \"register_operand\" \"\"))]\n-  \"\"\n-  \"\n-{\n-  if (TARGET_32BIT)\n-    emit_jump_insn (gen_indirect_jumpsi (operands[0]));\n-  else\n-    emit_jump_insn (gen_indirect_jumpdi (operands[0]));\n-  DONE;\n-}\")\n+  [(set (pc) (match_operand 0 \"register_operand\" \"\"))])\n \n-(define_insn \"indirect_jumpsi\"\n-  [(set (pc) (match_operand:SI 0 \"register_operand\" \"c,*l\"))]\n-  \"TARGET_32BIT\"\n+(define_insn \"*indirect_jump<mode>\"\n+  [(set (pc) (match_operand:P 0 \"register_operand\" \"c,*l\"))]\n+  \"\"\n   \"@\n    bctr\n    {br|blr}\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n-(define_insn \"indirect_jumpdi\"\n-  [(set (pc) (match_operand:DI 0 \"register_operand\" \"c,*l\"))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   bctr\n-   blr\"\n-  [(set_attr \"type\" \"jmpreg\")])\n-\n ;; Table jump for switch statements:\n (define_expand \"tablejump\"\n   [(use (match_operand 0 \"\" \"\"))\n@@ -13836,24 +13505,14 @@\n \n (define_insn \"\"\n   [(set (pc)\n-\t(match_operand:SI 0 \"register_operand\" \"c,*l\"))\n+\t(match_operand:P 0 \"register_operand\" \"c,*l\"))\n    (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_32BIT\"\n+  \"\"\n   \"@\n    bctr\n    {br|blr}\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n-(define_insn \"\"\n-  [(set (pc)\n-\t(match_operand:DI 0 \"register_operand\" \"c,*l\"))\n-   (use (label_ref (match_operand 1 \"\" \"\")))]\n-  \"TARGET_64BIT\"\n-  \"@\n-   bctr\n-   blr\"\n-  [(set_attr \"type\" \"jmpreg\")])\n-\n (define_insn \"nop\"\n   [(const_int 0)]\n   \"\"\n@@ -13889,32 +13548,18 @@\n   DONE;\n }\")\n \n-(define_expand \"ctrsi\"\n+(define_expand \"ctr<mode>\"\n   [(parallel [(set (pc)\n-\t\t   (if_then_else (ne (match_operand:SI 0 \"register_operand\" \"\")\n+\t\t   (if_then_else (ne (match_operand:P 0 \"register_operand\" \"\")\n \t\t\t\t     (const_int 1))\n \t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n \t\t\t\t (pc)))\n \t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 0)\n+\t\t   (plus:P (match_dup 0)\n \t\t\t    (const_int -1)))\n \t      (clobber (match_scratch:CC 2 \"\"))\n-\t      (clobber (match_scratch:SI 3 \"\"))])]\n-  \"TARGET_32BIT\"\n-  \"\")\n-\n-(define_expand \"ctrdi\"\n-  [(parallel [(set (pc)\n-\t\t   (if_then_else (ne (match_operand:DI 0 \"register_operand\" \"\")\n-\t\t\t\t     (const_int 1))\n-\t\t\t\t (label_ref (match_operand 1 \"\" \"\"))\n-\t\t\t\t (pc)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:DI (match_dup 0)\n-\t\t\t    (const_int -1)))\n-\t      (clobber (match_scratch:CC 2 \"\"))\n-\t      (clobber (match_scratch:DI 3 \"\"))])]\n-  \"TARGET_64BIT\"\n+\t      (clobber (match_scratch:P 3 \"\"))])]\n+  \"\"\n   \"\")\n \n ;; We need to be able to do this for any operand, including MEM, or we\n@@ -13923,66 +13568,18 @@\n ;; For the length attribute to be calculated correctly, the\n ;; label MUST be operand 0.\n \n-(define_insn \"*ctrsi_internal1\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"c,*r,*r,*r\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:SI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_32BIT\"\n-  \"*\n-{\n-  if (which_alternative != 0)\n-    return \\\"#\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"{bdn|bdnz} %l0\\\";\n-  else\n-    return \\\"bdz $+8\\;b %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"*,12,16,16\")])\n-\n-(define_insn \"*ctrsi_internal2\"\n-  [(set (pc)\n-\t(if_then_else (ne (match_operand:SI 1 \"register_operand\" \"c,*r,*r,*r\")\n-\t\t\t  (const_int 1))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:SI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_32BIT\"\n-  \"*\n-{\n-  if (which_alternative != 0)\n-    return \\\"#\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"bdz %l0\\\";\n-  else\n-    return \\\"{bdn|bdnz} $+8\\;b %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"*,12,16,16\")])\n-\n-(define_insn \"*ctrdi_internal1\"\n+(define_insn \"*ctr<mode>_internal1\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:DI 1 \"register_operand\" \"c,*r,*r,*r\")\n+\t(if_then_else (ne (match_operand:P 1 \"register_operand\" \"c,*r,*r,*r\")\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_operand:DI 2 \"nonimmediate_operand\" \"=1,*r,m,*c*l\")\n-\t(plus:DI (match_dup 1)\n+   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n+\t(plus:P (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:DI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:P 4 \"=X,X,&r,r\"))]\n+  \"\"\n   \"*\n {\n   if (which_alternative != 0)\n@@ -13995,18 +13592,18 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"*,12,16,16\")])\n \n-(define_insn \"*ctrdi_internal2\"\n+(define_insn \"*ctr<mode>_internal2\"\n   [(set (pc)\n-\t(if_then_else (ne (match_operand:DI 1 \"register_operand\" \"c,*r,*r,*r\")\n+\t(if_then_else (ne (match_operand:P 1 \"register_operand\" \"c,*r,*r,*r\")\n \t\t\t  (const_int 1))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-   (set (match_operand:DI 2 \"nonimmediate_operand\" \"=1,*r,m,*c*l\")\n-\t(plus:DI (match_dup 1)\n+   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n+\t(plus:P (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:DI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:P 4 \"=X,X,&r,r\"))]\n+  \"\"\n   \"*\n {\n   if (which_alternative != 0)\n@@ -14021,66 +13618,18 @@\n \n ;; Similar but use EQ\n \n-(define_insn \"*ctrsi_internal5\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_operand:SI 1 \"register_operand\" \"c,*r,*r,*r\")\n-\t\t\t  (const_int 1))\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))\n-\t\t      (pc)))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:SI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_32BIT\"\n-  \"*\n-{\n-  if (which_alternative != 0)\n-    return \\\"#\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"bdz %l0\\\";\n-  else\n-    return \\\"{bdn|bdnz} $+8\\;b %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"*,12,16,16\")])\n-\n-(define_insn \"*ctrsi_internal6\"\n+(define_insn \"*ctr<mode>_internal5\"\n   [(set (pc)\n-\t(if_then_else (eq (match_operand:SI 1 \"register_operand\" \"c,*r,*r,*r\")\n-\t\t\t  (const_int 1))\n-\t\t      (pc)\n-\t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-   (set (match_operand:SI 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:SI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_32BIT\"\n-  \"*\n-{\n-  if (which_alternative != 0)\n-    return \\\"#\\\";\n-  else if (get_attr_length (insn) == 4)\n-    return \\\"{bdn|bdnz} %l0\\\";\n-  else\n-    return \\\"bdz $+8\\;b %l0\\\";\n-}\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"*,12,16,16\")])\n-\n-(define_insn \"*ctrdi_internal5\"\n-  [(set (pc)\n-\t(if_then_else (eq (match_operand:DI 1 \"register_operand\" \"c,*r,*r,*r\")\n+\t(if_then_else (eq (match_operand:P 1 \"register_operand\" \"c,*r,*r,*r\")\n \t\t\t  (const_int 1))\n \t\t      (label_ref (match_operand 0 \"\" \"\"))\n \t\t      (pc)))\n-   (set (match_operand:DI 2 \"nonimmediate_operand\" \"=1,*r,m,*c*l\")\n-\t(plus:DI (match_dup 1)\n+   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n+\t(plus:P (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:DI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:P 4 \"=X,X,&r,r\"))]\n+  \"\"\n   \"*\n {\n   if (which_alternative != 0)\n@@ -14093,18 +13642,18 @@\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"*,12,16,16\")])\n \n-(define_insn \"*ctrdi_internal6\"\n+(define_insn \"*ctr<mode>_internal6\"\n   [(set (pc)\n-\t(if_then_else (eq (match_operand:DI 1 \"register_operand\" \"c,*r,*r,*r\")\n+\t(if_then_else (eq (match_operand:P 1 \"register_operand\" \"c,*r,*r,*r\")\n \t\t\t  (const_int 1))\n \t\t      (pc)\n \t\t      (label_ref (match_operand 0 \"\" \"\"))))\n-   (set (match_operand:DI 2 \"nonimmediate_operand\" \"=1,*r,m,*c*l\")\n-\t(plus:DI (match_dup 1)\n+   (set (match_operand:P 2 \"nonimmediate_operand\" \"=1,*r,m,*q*c*l\")\n+\t(plus:P (match_dup 1)\n \t\t (const_int -1)))\n    (clobber (match_scratch:CC 3 \"=X,&x,&x,&x\"))\n-   (clobber (match_scratch:DI 4 \"=X,X,&r,r\"))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:P 4 \"=X,X,&r,r\"))]\n+  \"\"\n   \"*\n {\n   if (which_alternative != 0)\n@@ -14122,77 +13671,21 @@\n (define_split\n   [(set (pc)\n \t(if_then_else (match_operator 2 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t       (const_int 1)])\n-\t\t      (match_operand 5 \"\" \"\")\n-\t\t      (match_operand 6 \"\" \"\")))\n-   (set (match_operand:SI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:SI (match_dup 1)\n-\t\t (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"\"))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (compare:CC (plus:SI (match_dup 1)\n-\t\t\t\t\t(const_int -1))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 0)\n-\t\t   (plus:SI (match_dup 1)\n-\t\t\t    (const_int -1)))])\n-   (set (pc) (if_then_else (match_dup 7)\n-\t\t\t   (match_dup 5)\n-\t\t\t   (match_dup 6)))]\n-  \"\n-{ operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[2]), VOIDmode,\n-\t\t\t\toperands[3], const0_rtx); }\")\n-\n-(define_split\n-  [(set (pc)\n-\t(if_then_else (match_operator 2 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:SI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t\t      [(match_operand:P 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t       (const_int 1)])\n \t\t      (match_operand 5 \"\" \"\")\n \t\t      (match_operand 6 \"\" \"\")))\n-   (set (match_operand:SI 0 \"nonimmediate_operand\" \"\")\n-\t(plus:SI (match_dup 1) (const_int -1)))\n-   (clobber (match_scratch:CC 3 \"\"))\n-   (clobber (match_scratch:SI 4 \"\"))]\n-  \"TARGET_32BIT && reload_completed\n-   && ! gpc_reg_operand (operands[0], SImode)\"\n-  [(parallel [(set (match_dup 3)\n-\t\t   (compare:CC (plus:SI (match_dup 1)\n-\t\t\t\t\t(const_int -1))\n-\t\t\t       (const_int 0)))\n-\t      (set (match_dup 4)\n-\t\t   (plus:SI (match_dup 1)\n-\t\t\t    (const_int -1)))])\n-   (set (match_dup 0)\n-\t(match_dup 4))\n-   (set (pc) (if_then_else (match_dup 7)\n-\t\t\t   (match_dup 5)\n-\t\t\t   (match_dup 6)))]\n-  \"\n-{ operands[7] = gen_rtx_fmt_ee (GET_CODE (operands[2]), VOIDmode,\n-\t\t\t\toperands[3], const0_rtx); }\")\n-(define_split\n-  [(set (pc)\n-\t(if_then_else (match_operator 2 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n-\t\t\t\t       (const_int 1)])\n-\t\t      (match_operand 5 \"\" \"\")\n-\t\t      (match_operand 6 \"\" \"\")))\n-   (set (match_operand:DI 0 \"gpc_reg_operand\" \"\")\n-\t(plus:DI (match_dup 1)\n-\t\t (const_int -1)))\n+   (set (match_operand:P 0 \"gpc_reg_operand\" \"\")\n+\t(plus:P (match_dup 1) (const_int -1)))\n    (clobber (match_scratch:CC 3 \"\"))\n-   (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_64BIT && reload_completed\"\n+   (clobber (match_scratch:P 4 \"\"))]\n+  \"reload_completed\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (compare:CC (plus:DI (match_dup 1)\n+\t\t   (compare:CC (plus:P (match_dup 1)\n \t\t\t\t\t(const_int -1))\n \t\t\t       (const_int 0)))\n \t      (set (match_dup 0)\n-\t\t   (plus:DI (match_dup 1)\n+\t\t   (plus:P (match_dup 1)\n \t\t\t    (const_int -1)))])\n    (set (pc) (if_then_else (match_dup 7)\n \t\t\t   (match_dup 5)\n@@ -14204,22 +13697,21 @@\n (define_split\n   [(set (pc)\n \t(if_then_else (match_operator 2 \"comparison_operator\"\n-\t\t\t\t      [(match_operand:DI 1 \"gpc_reg_operand\" \"\")\n+\t\t\t\t      [(match_operand:P 1 \"gpc_reg_operand\" \"\")\n \t\t\t\t       (const_int 1)])\n \t\t      (match_operand 5 \"\" \"\")\n \t\t      (match_operand 6 \"\" \"\")))\n-   (set (match_operand:DI 0 \"nonimmediate_operand\" \"\")\n-\t(plus:DI (match_dup 1) (const_int -1)))\n+   (set (match_operand:P 0 \"nonimmediate_operand\" \"\")\n+\t(plus:P (match_dup 1) (const_int -1)))\n    (clobber (match_scratch:CC 3 \"\"))\n-   (clobber (match_scratch:DI 4 \"\"))]\n-  \"TARGET_64BIT && reload_completed\n-   && ! gpc_reg_operand (operands[0], DImode)\"\n+   (clobber (match_scratch:P 4 \"\"))]\n+  \"reload_completed && ! gpc_reg_operand (operands[0], SImode)\"\n   [(parallel [(set (match_dup 3)\n-\t\t   (compare:CC (plus:DI (match_dup 1)\n+\t\t   (compare:CC (plus:P (match_dup 1)\n \t\t\t\t\t(const_int -1))\n \t\t\t       (const_int 0)))\n \t      (set (match_dup 4)\n-\t\t   (plus:DI (match_dup 1)\n+\t\t   (plus:P (match_dup 1)\n \t\t\t    (const_int -1)))])\n    (set (match_dup 0)\n \t(match_dup 4))\n@@ -14246,19 +13738,11 @@\n \n (define_insn \"\"\n   [(trap_if (match_operator 0 \"trap_comparison_operator\"\n-                            [(match_operand:SI 1 \"register_operand\" \"r\")\n-                             (match_operand:SI 2 \"reg_or_short_operand\" \"rI\")])\n+                            [(match_operand:GPR 1 \"register_operand\" \"r\")\n+                             (match_operand:GPR 2 \"reg_or_short_operand\" \"rI\")])\n \t    (const_int 0))]\n   \"\"\n-  \"{t|tw}%V0%I2 %1,%2\")\n-\n-(define_insn \"\"\n-  [(trap_if (match_operator 0 \"trap_comparison_operator\"\n-                            [(match_operand:DI 1 \"register_operand\" \"r\")\n-                             (match_operand:DI 2 \"reg_or_short_operand\" \"rI\")])\n-\t    (const_int 0))]\n-  \"TARGET_POWERPC64\"\n-  \"td%V0%I2 %1,%2\")\n+  \"{t|t<wd>}%V0%I2 %1,%2\")\n \f\n ;; Insns related to generating the function prologue and epilogue.\n \n@@ -14308,24 +13792,13 @@\n   \"TARGET_MULTIPLE\"\n   \"{stm|stmw} %2,%1\")\n \n-(define_insn \"*save_fpregs_si\"\n+(define_insn \"*save_fpregs_<mode>\"\n   [(match_parallel 0 \"any_parallel_operand\"\n-\t\t   [(clobber (match_operand:SI 1 \"register_operand\" \"=l\"))\n-\t\t    (use (match_operand:SI 2 \"call_operand\" \"s\"))\n+\t\t   [(clobber (match_operand:P 1 \"register_operand\" \"=l\"))\n+\t\t    (use (match_operand:P 2 \"call_operand\" \"s\"))\n \t\t    (set (match_operand:DF 3 \"memory_operand\" \"=m\")\n \t\t\t (match_operand:DF 4 \"gpc_reg_operand\" \"f\"))])]\n-  \"TARGET_32BIT\"\n-  \"bl %z2\"\n-  [(set_attr \"type\" \"branch\")\n-   (set_attr \"length\" \"4\")])\n-\n-(define_insn \"*save_fpregs_di\"\n-  [(match_parallel 0 \"any_parallel_operand\"\n-\t\t   [(clobber (match_operand:DI 1 \"register_operand\" \"=l\"))\n-\t\t    (use (match_operand:DI 2 \"call_operand\" \"s\"))\n-\t\t    (set (match_operand:DF 3 \"memory_operand\" \"=m\")\n-\t\t\t (match_operand:DF 4 \"gpc_reg_operand\" \"f\"))])]\n-  \"TARGET_64BIT\"\n+  \"\"\n   \"bl %z2\"\n   [(set_attr \"type\" \"branch\")\n    (set_attr \"length\" \"4\")])\n@@ -14401,41 +13874,24 @@\n   \"TARGET_MULTIPLE\"\n   \"{lm|lmw} %1,%2\")\n \n-(define_insn \"*return_internal_si\"\n-  [(return)\n-   (use (match_operand:SI 0 \"register_operand\" \"lc\"))]\n-  \"TARGET_32BIT\"\n-  \"b%T0\"\n-  [(set_attr \"type\" \"jmpreg\")])\n-\n-(define_insn \"*return_internal_di\"\n+(define_insn \"*return_internal_<mode>\"\n   [(return)\n-   (use (match_operand:DI 0 \"register_operand\" \"lc\"))]\n-  \"TARGET_64BIT\"\n+   (use (match_operand:P 0 \"register_operand\" \"lc\"))]\n+  \"\"\n   \"b%T0\"\n   [(set_attr \"type\" \"jmpreg\")])\n \n ; FIXME: This would probably be somewhat simpler if the Cygnus sibcall\n ; stuff was in GCC.  Oh, and \"any_parallel_operand\" is a bit flexible...\n \n-(define_insn \"*return_and_restore_fpregs_si\"\n- [(match_parallel 0 \"any_parallel_operand\"\n-                  [(return)\n-\t\t   (use (match_operand:SI 1 \"register_operand\" \"l\"))\n-\t\t   (use (match_operand:SI 2 \"call_operand\" \"s\"))\n-\t\t   (set (match_operand:DF 3 \"gpc_reg_operand\" \"=f\")\n-\t\t\t(match_operand:DF 4 \"memory_operand\" \"m\"))])]\n- \"TARGET_32BIT\"\n- \"b %z2\")\n-\n-(define_insn \"*return_and_restore_fpregs_di\"\n+(define_insn \"*return_and_restore_fpregs_<mode>\"\n  [(match_parallel 0 \"any_parallel_operand\"\n                   [(return)\n-\t\t   (use (match_operand:DI 1 \"register_operand\" \"l\"))\n-\t\t   (use (match_operand:DI 2 \"call_operand\" \"s\"))\n+\t\t   (use (match_operand:P 1 \"register_operand\" \"l\"))\n+\t\t   (use (match_operand:P 2 \"call_operand\" \"s\"))\n \t\t   (set (match_operand:DF 3 \"gpc_reg_operand\" \"=f\")\n \t\t\t(match_operand:DF 4 \"memory_operand\" \"m\"))])]\n- \"TARGET_64BIT\"\n+ \"\"\n  \"b %z2\")\n \n ; This is used in compiling the unwind routines.\n@@ -14452,18 +13908,11 @@\n }\")\n \n ; We can't expand this before we know where the link register is stored.\n-(define_insn \"eh_set_lr_si\"\n-  [(unspec_volatile [(match_operand:SI 0 \"register_operand\" \"r\")]\n+(define_insn \"eh_set_lr_<mode>\"\n+  [(unspec_volatile [(match_operand:P 0 \"register_operand\" \"r\")]\n   \t\t    UNSPECV_EH_RR)\n-   (clobber (match_scratch:SI 1 \"=&b\"))]\n-  \"TARGET_32BIT\"\n-  \"#\")\n-\n-(define_insn \"eh_set_lr_di\"\n-  [(unspec_volatile [(match_operand:DI 0 \"register_operand\" \"r\")]\n-  \t\t    UNSPECV_EH_RR)\n-   (clobber (match_scratch:DI 1 \"=&b\"))]\n-  \"TARGET_64BIT\"\n+   (clobber (match_scratch:P 1 \"=&b\"))]\n+  \"\"\n   \"#\")\n \n (define_split"}]}