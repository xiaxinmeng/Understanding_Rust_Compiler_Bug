{"sha": "69a4e898c8f508f0c56c72c791a38bc432e9fa69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjlhNGU4OThjOGY1MDhmMGM1NmM3MmM3OTFhMzhiYzQzMmU5ZmE2OQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2016-04-17T16:04:05Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2016-04-17T16:04:05Z"}, "message": "re PR c++/70018 (Possible issue around IPO and C++ comdats discovered as pure/const)\n\n\n\tPR ipa/70018\n\t* cgraph.h (cgraph_node::set_const_flag,\n\tcgraph_node::set_pure_flag): Update prototype to return bool;\n\tupdate comment.\n\t* cgraph.c (cgraph_node::call_for_symbol_thunks_and_aliases): Thunks\n\tof interposable symbol are interposable, too.\n\t(cgraph_set_const_flag_1): Rename to ...\n\t(set_const_flag_1): ... this one; change to self recursive function\n\tinstead of call_for_symbol_thunks_and_aliases. Handle correctly\n\tclearnig the flag in all variants and also virtual thunks of const\n\tfunctions are pure; track if any change was done.\n\t(cgraph_node::set_const_flag): Update.\n\t(struct set_pure_flag_info): New struct.\n\t(cgraph_set_pure_flag_1): Rename to ...\n\t(set_pure_flag_1): ... this one; take set_pure_flag_info parameter\n\trather than pointer encoded flags; track if any changes was done;\n\thandle correctly clearning flag and setting flag of aliases already\n\tdeclared const.\n\t(cgraph_node::set_pure_flag): Update.\n\t(cgraph_node::set_nothrow_flag): Handle correctly clearning the flag.\n\nFrom-SVN: r235081", "tree": {"sha": "dab34f7a272189308734eab631e4f507410d806b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/dab34f7a272189308734eab631e4f507410d806b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/69a4e898c8f508f0c56c72c791a38bc432e9fa69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69a4e898c8f508f0c56c72c791a38bc432e9fa69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/69a4e898c8f508f0c56c72c791a38bc432e9fa69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/69a4e898c8f508f0c56c72c791a38bc432e9fa69/comments", "author": null, "committer": null, "parents": [{"sha": "b3de2446458bf8c61a8e54d6bd424bafe7ab479e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b3de2446458bf8c61a8e54d6bd424bafe7ab479e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b3de2446458bf8c61a8e54d6bd424bafe7ab479e"}], "stats": {"total": 266, "additions": 211, "deletions": 55}, "files": [{"sha": "1e9ef9b93c67d7c6803ed300e1007e2edd4fde0f", "filename": "gcc/ChangeLog", "status": "modified", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=69a4e898c8f508f0c56c72c791a38bc432e9fa69", "patch": "@@ -1,3 +1,26 @@\n+2016-04-17  Jan Hubicka  <jh@suse.cz>\n+\n+\tPR ipa/70018\n+\t* cgraph.h (cgraph_node::set_const_flag,\n+\tcgraph_node::set_pure_flag): Update prototype to return bool;\n+\tupdate comment.\n+\t* cgraph.c (cgraph_node::call_for_symbol_thunks_and_aliases): Thunks\n+\tof interposable symbol are interposable, too.\n+\t(cgraph_set_const_flag_1): Rename to ...\n+\t(set_const_flag_1): ... this one; change to self recursive function\n+\tinstead of call_for_symbol_thunks_and_aliases. Handle correctly\n+\tclearnig the flag in all variants and also virtual thunks of const\n+\tfunctions are pure; track if any change was done.\n+\t(cgraph_node::set_const_flag): Update.\n+\t(struct set_pure_flag_info): New struct.\n+\t(cgraph_set_pure_flag_1): Rename to ...\n+\t(set_pure_flag_1): ... this one; take set_pure_flag_info parameter\n+\trather than pointer encoded flags; track if any changes was done;\n+\thandle correctly clearning flag and setting flag of aliases already\n+\tdeclared const.\n+\t(cgraph_node::set_pure_flag): Update.\n+\t(cgraph_node::set_nothrow_flag): Handle correctly clearning the flag.\n+\n 2016-04-17  Tom de Vries  <tom@codesourcery.com>\n \n \tPR other/70433"}, {"sha": "d8cb52695109ab69df7cd7a0063da8359c9b4d98", "filename": "gcc/cgraph.c", "status": "modified", "additions": 172, "deletions": 50, "changes": 222, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2Fcgraph.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2Fcgraph.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.c?ref=69a4e898c8f508f0c56c72c791a38bc432e9fa69", "patch": "@@ -2308,6 +2308,8 @@ cgraph_node::call_for_symbol_thunks_and_aliases (bool (*callback)\n \t\t\t\t\t\t     exclude_virtual_thunks))\n \t  return true;\n     }\n+  if (get_availability () <= AVAIL_INTERPOSABLE)\n+    return false;\n   for (e = callers; e; e = e->next_caller)\n     if (e->caller->thunk.thunk_p\n \t&& (include_overwritable\n@@ -2376,95 +2378,215 @@ void\n cgraph_node::set_nothrow_flag (bool nothrow)\n {\n   call_for_symbol_thunks_and_aliases (cgraph_set_nothrow_flag_1,\n-\t\t\t\t    (void *)(size_t)nothrow, false);\n+\t\t\t\t      (void *)(size_t)nothrow, nothrow == true);\n }\n \n-/* Worker to set const flag.  */\n+/* Worker to set_const_flag.  */\n \n-static bool\n-cgraph_set_const_flag_1 (cgraph_node *node, void *data)\n+static void\n+set_const_flag_1 (cgraph_node *node, bool set_const, bool looping,\n+\t\t  bool *changed)\n {\n   /* Static constructors and destructors without a side effect can be\n      optimized out.  */\n-  if (data && !((size_t)data & 2))\n+  if (set_const && !looping)\n     {\n       if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t  *changed = true;\n+\t}\n       if (DECL_STATIC_DESTRUCTOR (node->decl))\n-\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t{\n+\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t  *changed = true;\n+\t}\n+    }\n+  if (!set_const)\n+    {\n+      if (TREE_READONLY (node->decl))\n+\t{\n+          TREE_READONLY (node->decl) = 0;\n+          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  *changed = true;\n+\t}\n     }\n+  else\n+    {\n+      /* Consider function:\n \n-  /* Consider function:\n+\t bool a(int *p)\n+\t {\n+\t   return *p==*p;\n+\t }\n \n-     bool a(int *p)\n-     {\n-       return *p==*p;\n-     }\n+\t During early optimization we will turn this into:\n \n-     During early optimization we will turn this into:\n+\t bool a(int *p)\n+\t {\n+\t   return true;\n+\t }\n \n-     bool a(int *p)\n-     {\n-       return true;\n-     }\n+\t Now if this function will be detected as CONST however when interposed\n+\t it may end up being just pure.  We always must assume the worst\n+\t scenario here.  */\n+      if (TREE_READONLY (node->decl))\n+\t{\n+\t  if (!looping && DECL_LOOPING_CONST_OR_PURE_P (node->decl))\n+\t    {\n+              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t      *changed = true;\n+\t    }\n+\t}\n+      else if (node->binds_to_current_def_p ())\n+\t{\n+\t  TREE_READONLY (node->decl) = true;\n+          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n+\t  DECL_PURE_P (node->decl) = false;\n+\t  *changed = true;\n+\t}\n+      else\n+\t{\n+\t  if (dump_file && (dump_flags & TDF_DETAILS))\n+\t    fprintf (dump_file, \"Dropping state to PURE because function does \"\n+\t\t     \"not bind to current def.\\n\");\n+\t  if (!DECL_PURE_P (node->decl))\n+\t    {\n+\t      DECL_PURE_P (node->decl) = true;\n+              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = looping;\n+\t      *changed = true;\n+\t    }\n+\t  else if (!looping && DECL_LOOPING_CONST_OR_PURE_P (node->decl))\n+\t    {\n+              DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t      *changed = true;\n+\t    }\n+\t}\n+    }\n \n-     Now if this function will be detected as CONST however when interposed it\n-     may end up being just pure.  We always must assume the worst scenario here.\n-   */\n-  if (TREE_READONLY (node->decl))\n-    ;\n-  else if (node->binds_to_current_def_p ())\n-    TREE_READONLY (node->decl) = data != NULL;\n-  else\n+  ipa_ref *ref;\n+  FOR_EACH_ALIAS (node, ref)\n     {\n-      if (dump_file && (dump_flags & TDF_DETAILS))\n-\tfprintf (dump_file, \"Dropping state to PURE because function does \"\n-\t\t \"not bind to current def.\\n\");\n-      DECL_PURE_P (node->decl) = data != NULL;\n+      cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+      if (!set_const || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\tset_const_flag_1 (alias, set_const, looping, changed);\n     }\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n-  return false;\n+  for (cgraph_edge *e = node->callers; e; e = e->next_caller)\n+    if (e->caller->thunk.thunk_p\n+\t&& (!set_const || e->caller->get_availability () > AVAIL_INTERPOSABLE))\n+      {\n+\t/* Virtual thunks access virtual offset in the vtable, so they can\n+\t   only be pure, never const.  */\n+        if (set_const\n+\t    && (e->caller->thunk.virtual_offset_p\n+\t        || !node->binds_to_current_def_p (e->caller)))\n+\t  *changed |= e->caller->set_pure_flag (true, looping);\n+\telse\n+\t  set_const_flag_1 (e->caller, set_const, looping, changed);\n+      }\n }\n \n-/* Set TREE_READONLY on cgraph_node's decl and on aliases of the node\n-   if any to READONLY.  */\n+/* If SET_CONST is true, mark function, aliases and thunks to be ECF_CONST.\n+   If SET_CONST if false, clear the flag.\n \n-void\n-cgraph_node::set_const_flag (bool readonly, bool looping)\n+   When setting the flag be careful about possible interposition and\n+   do not set the flag for functions that can be interposet and set pure\n+   flag for functions that can bind to other definition. \n+\n+   Return true if any change was done. */\n+\n+bool\n+cgraph_node::set_const_flag (bool set_const, bool looping)\n {\n-  call_for_symbol_thunks_and_aliases (cgraph_set_const_flag_1,\n-\t\t\t\t    (void *)(size_t)(readonly + (int)looping * 2),\n-\t\t\t\t    false, true);\n+  bool changed = false;\n+  if (!set_const || get_availability () > AVAIL_INTERPOSABLE)\n+    set_const_flag_1 (this, set_const, looping, &changed);\n+  else\n+    {\n+      ipa_ref *ref;\n+\n+      FOR_EACH_ALIAS (this, ref)\n+\t{\n+\t  cgraph_node *alias = dyn_cast <cgraph_node *> (ref->referring);\n+\t  if (!set_const || alias->get_availability () > AVAIL_INTERPOSABLE)\n+\t    set_const_flag_1 (alias, set_const, looping, &changed);\n+\t}\n+    }\n+  return changed;\n }\n \n-/* Worker to set pure flag.  */\n+/* Info used by set_pure_flag_1.  */\n+\n+struct\n+set_pure_flag_info\n+{\n+  bool pure;\n+  bool looping;\n+  bool changed;\n+};\n+\n+/* Worker to set_pure_flag.  */\n \n static bool\n-cgraph_set_pure_flag_1 (cgraph_node *node, void *data)\n+set_pure_flag_1 (cgraph_node *node, void *data)\n {\n+  struct set_pure_flag_info *info = (struct set_pure_flag_info *)data;\n   /* Static constructors and destructors without a side effect can be\n      optimized out.  */\n-  if (data && !((size_t)data & 2))\n+  if (info->pure && !info->looping)\n     {\n       if (DECL_STATIC_CONSTRUCTOR (node->decl))\n-\tDECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t{\n+\t  DECL_STATIC_CONSTRUCTOR (node->decl) = 0;\n+\t  info->changed = true;\n+\t}\n       if (DECL_STATIC_DESTRUCTOR (node->decl))\n-\tDECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t{\n+\t  DECL_STATIC_DESTRUCTOR (node->decl) = 0;\n+\t  info->changed = true;\n+\t}\n+    }\n+  if (info->pure)\n+    {\n+      if (!DECL_PURE_P (node->decl) && !TREE_READONLY (node->decl))\n+\t{\n+          DECL_PURE_P (node->decl) = true;\n+          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = info->looping;\n+\t  info->changed = true;\n+\t}\n+      else if (DECL_LOOPING_CONST_OR_PURE_P (node->decl)\n+\t       && !info->looping)\n+\t{\n+          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  info->changed = true;\n+\t}\n+    }\n+  else\n+    {\n+      if (DECL_PURE_P (node->decl))\n+\t{\n+          DECL_PURE_P (node->decl) = false;\n+          DECL_LOOPING_CONST_OR_PURE_P (node->decl) = false;\n+\t  info->changed = true;\n+\t}\n     }\n-  DECL_PURE_P (node->decl) = data != NULL;\n-  DECL_LOOPING_CONST_OR_PURE_P (node->decl) = ((size_t)data & 2) != 0;\n   return false;\n }\n \n /* Set DECL_PURE_P on cgraph_node's decl and on aliases of the node\n-   if any to PURE.  */\n+   if any to PURE.\n \n-void\n+   When setting the flag, be careful about possible interposition.\n+   Return true if any change was done. */\n+\n+bool\n cgraph_node::set_pure_flag (bool pure, bool looping)\n {\n-  call_for_symbol_thunks_and_aliases (cgraph_set_pure_flag_1,\n-\t\t\t\t    (void *)(size_t)(pure + (int)looping * 2),\n-\t\t\t\t    false, true);\n+  struct set_pure_flag_info info = {pure, looping, false};\n+  if (!pure)\n+    looping = false;\n+  call_for_symbol_thunks_and_aliases (set_pure_flag_1, &info, !pure, true);\n+  return info.changed;\n }\n \n /* Return true when cgraph_node can not return or throw and thus"}, {"sha": "71e31a4f1e3126cf4c0ac31dbe147e39d647d18d", "filename": "gcc/cgraph.h", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/69a4e898c8f508f0c56c72c791a38bc432e9fa69/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=69a4e898c8f508f0c56c72c791a38bc432e9fa69", "patch": "@@ -1113,13 +1113,24 @@ struct GTY((tag (\"SYMTAB_FUNCTION\"))) cgraph_node : public symtab_node {\n      if any to NOTHROW.  */\n   void set_nothrow_flag (bool nothrow);\n \n-  /* Set TREE_READONLY on cgraph_node's decl and on aliases of the node\n-     if any to READONLY.  */\n-  void set_const_flag (bool readonly, bool looping);\n+  /* If SET_CONST is true, mark function, aliases and thunks to be ECF_CONST.\n+    If SET_CONST if false, clear the flag.\n+\n+    When setting the flag be careful about possible interposition and\n+    do not set the flag for functions that can be interposet and set pure\n+    flag for functions that can bind to other definition. \n+\n+    Return true if any change was done. */\n+\n+  bool set_const_flag (bool set_const, bool looping);\n \n   /* Set DECL_PURE_P on cgraph_node's decl and on aliases of the node\n-     if any to PURE.  */\n-  void set_pure_flag (bool pure, bool looping);\n+     if any to PURE.\n+\n+     When setting the flag, be careful about possible interposition.\n+     Return true if any change was done. */\n+\n+  bool set_pure_flag (bool pure, bool looping);\n \n   /* Call callback on function and aliases associated to the function.\n      When INCLUDE_OVERWRITABLE is false, overwritable aliases and thunks are"}]}