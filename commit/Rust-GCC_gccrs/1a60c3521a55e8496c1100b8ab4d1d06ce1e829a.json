{"sha": "1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWE2MGMzNTIxYTU1ZTg0OTZjMTEwMGI4YWI0ZDFkMDZjZTFlODI5YQ==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2011-09-06T14:36:00Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2011-09-06T14:36:00Z"}, "message": "re PR tree-optimization/48149 (Piecewise complex pass-through not optimized)\n\n2011-09-06  Richard Guenther  <rguenther@suse.de>\n\n\tPR tree-optimization/48149\n\t* tree-ssa-sccvn.c (vn_get_expr_for): Simplify.  Fix tuplification bug.\n\t(vn_valueize): Move earlier.\n\t(valueize_expr): Use vn_valueize.\n\t(simplify_binary_expression): Simplify, also combine COMPLEX_EXPR\n\toperands.\n\t(simplify_unary_expression): Simplify.\n\n\t* gcc.dg/tree-ssa/ssa-fre-32.c: New testcase.\n\nFrom-SVN: r178597", "tree": {"sha": "52fa46d8c273e0f8d35783d45f0ace038f3ee670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/52fa46d8c273e0f8d35783d45f0ace038f3ee670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "ef417be1471baff2d413b8e7d33f71acc7a0d9a9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef417be1471baff2d413b8e7d33f71acc7a0d9a9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef417be1471baff2d413b8e7d33f71acc7a0d9a9"}], "stats": {"total": 151, "additions": 93, "deletions": 58}, "files": [{"sha": "3109216d5e3856a97d294dd3692ad9c44fab5d07", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "patch": "@@ -1,3 +1,13 @@\n+2011-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48149\n+\t* tree-ssa-sccvn.c (vn_get_expr_for): Simplify.  Fix tuplification bug.\n+\t(vn_valueize): Move earlier.\n+\t(valueize_expr): Use vn_valueize.\n+\t(simplify_binary_expression): Simplify, also combine COMPLEX_EXPR\n+\toperands.\n+\t(simplify_unary_expression): Simplify.\n+\n 2011-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48317"}, {"sha": "c1c00737e32f75254da0c76a79e84b057dc43c2f", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "patch": "@@ -1,3 +1,8 @@\n+2011-09-06  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR tree-optimization/48149\n+\t* gcc.dg/tree-ssa/ssa-fre-32.c: New testcase.\n+\n 2011-09-06  Richard Guenther  <rguenther@suse.de>\n \n \tPR tree-optimization/48317"}, {"sha": "537fd5a6bcbe9a7ab06a997eb89cce656b3e2884", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-32.c", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-32.c?ref=1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "patch": "@@ -0,0 +1,28 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O -fdump-tree-fre1-details\" } */\n+\n+_Complex float \n+foo (_Complex float x)\n+{    \n+  float r = __real x;\n+  float i = __imag x;\n+  _Complex float z;\n+  __real z = r;\n+  __imag z = i;\n+  return z;\n+} \n+\n+_Complex float \n+bar (_Complex float x)\n+{    \n+  float r = __real x;\n+  float i = __imag x;\n+  _Complex float z = x;\n+  __real z = r;\n+  __imag z = i;\n+  return z;\n+} \n+\n+/* We should CSE all the way to replace the final assignment to z with x.  */\n+/* { dg-final { scan-tree-dump-times \"with x_1\\\\\\(D\\\\\\) in z\" 3 \"fre1\" } } */\n+/* { dg-final { cleanup-tree-dump \"fre1\" } } */"}, {"sha": "811cb65b42450e1ab035bb5c159e70b00e718736", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 50, "deletions": 58, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1a60c3521a55e8496c1100b8ab4d1d06ce1e829a/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=1a60c3521a55e8496c1100b8ab4d1d06ce1e829a", "patch": "@@ -217,6 +217,7 @@ vn_get_expr_for (tree name)\n   vn_ssa_aux_t vn = VN_INFO (name);\n   gimple def_stmt;\n   tree expr = NULL_TREE;\n+  enum tree_code code;\n \n   if (vn->valnum == VN_TOP)\n     return name;\n@@ -241,37 +242,34 @@ vn_get_expr_for (tree name)\n   /* Otherwise use the defining statement to build the expression.  */\n   def_stmt = SSA_NAME_DEF_STMT (vn->valnum);\n \n-  /* If the value number is a default-definition or a PHI result\n-     use it directly.  */\n-  if (gimple_nop_p (def_stmt)\n-      || gimple_code (def_stmt) == GIMPLE_PHI)\n-    return vn->valnum;\n-\n+  /* If the value number is not an assignment use it directly.  */\n   if (!is_gimple_assign (def_stmt))\n     return vn->valnum;\n \n   /* FIXME tuples.  This is incomplete and likely will miss some\n      simplifications.  */\n-  switch (TREE_CODE_CLASS (gimple_assign_rhs_code (def_stmt)))\n+  code = gimple_assign_rhs_code (def_stmt);\n+  switch (TREE_CODE_CLASS (code))\n     {\n     case tcc_reference:\n-      if ((gimple_assign_rhs_code (def_stmt) == VIEW_CONVERT_EXPR\n-\t   || gimple_assign_rhs_code (def_stmt) == REALPART_EXPR\n-\t   || gimple_assign_rhs_code (def_stmt) == IMAGPART_EXPR)\n-\t  && TREE_CODE (gimple_assign_rhs1 (def_stmt)) == SSA_NAME)\n-\texpr = fold_build1 (gimple_assign_rhs_code (def_stmt),\n+      if ((code == REALPART_EXPR\n+\t   || code == IMAGPART_EXPR\n+\t   || code == VIEW_CONVERT_EXPR)\n+\t  && TREE_CODE (TREE_OPERAND (gimple_assign_rhs1 (def_stmt),\n+\t\t\t\t      0)) == SSA_NAME)\n+\texpr = fold_build1 (code,\n \t\t\t    gimple_expr_type (def_stmt),\n \t\t\t    TREE_OPERAND (gimple_assign_rhs1 (def_stmt), 0));\n       break;\n \n     case tcc_unary:\n-      expr = fold_build1 (gimple_assign_rhs_code (def_stmt),\n+      expr = fold_build1 (code,\n \t\t\t  gimple_expr_type (def_stmt),\n \t\t\t  gimple_assign_rhs1 (def_stmt));\n       break;\n \n     case tcc_binary:\n-      expr = fold_build2 (gimple_assign_rhs_code (def_stmt),\n+      expr = fold_build2 (code,\n \t\t\t  gimple_expr_type (def_stmt),\n \t\t\t  gimple_assign_rhs1 (def_stmt),\n \t\t\t  gimple_assign_rhs2 (def_stmt));\n@@ -2822,6 +2820,19 @@ stmt_has_constants (gimple stmt)\n   return false;\n }\n \n+/* Valueize NAME if it is an SSA name, otherwise just return it.  */\n+\n+static inline tree\n+vn_valueize (tree name)\n+{\n+  if (TREE_CODE (name) == SSA_NAME)\n+    {\n+      tree tem = SSA_VAL (name);\n+      return tem == VN_TOP ? name : tem;\n+    }\n+  return name;\n+}\n+\n /* Replace SSA_NAMES in expr with their value numbers, and return the\n    result.\n    This is performed in place. */\n@@ -2831,21 +2842,13 @@ valueize_expr (tree expr)\n {\n   switch (TREE_CODE_CLASS (TREE_CODE (expr)))\n     {\n-    case tcc_unary:\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == SSA_NAME\n-\t  && SSA_VAL (TREE_OPERAND (expr, 0)) != VN_TOP)\n-\tTREE_OPERAND (expr, 0) = SSA_VAL (TREE_OPERAND (expr, 0));\n-      break;\n     case tcc_binary:\n-      if (TREE_CODE (TREE_OPERAND (expr, 0)) == SSA_NAME\n-\t  && SSA_VAL (TREE_OPERAND (expr, 0)) != VN_TOP)\n-\tTREE_OPERAND (expr, 0) = SSA_VAL (TREE_OPERAND (expr, 0));\n-      if (TREE_CODE (TREE_OPERAND (expr, 1)) == SSA_NAME\n-\t  && SSA_VAL (TREE_OPERAND (expr, 1)) != VN_TOP)\n-\tTREE_OPERAND (expr, 1) = SSA_VAL (TREE_OPERAND (expr, 1));\n-      break;\n-    default:\n+      TREE_OPERAND (expr, 1) = vn_valueize (TREE_OPERAND (expr, 1));\n+      /* Fallthru.  */\n+    case tcc_unary:\n+      TREE_OPERAND (expr, 0) = vn_valueize (TREE_OPERAND (expr, 0));\n       break;\n+    default:;\n     }\n   return expr;\n }\n@@ -2859,6 +2862,7 @@ simplify_binary_expression (gimple stmt)\n   tree result = NULL_TREE;\n   tree op0 = gimple_assign_rhs1 (stmt);\n   tree op1 = gimple_assign_rhs2 (stmt);\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n \n   /* This will not catch every single case we could combine, but will\n      catch those with constants.  The goal here is to simultaneously\n@@ -2867,23 +2871,25 @@ simplify_binary_expression (gimple stmt)\n   if (TREE_CODE (op0) == SSA_NAME)\n     {\n       if (VN_INFO (op0)->has_constants\n-\t  || TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_comparison)\n+\t  || TREE_CODE_CLASS (code) == tcc_comparison\n+\t  || code == COMPLEX_EXPR)\n \top0 = valueize_expr (vn_get_expr_for (op0));\n-      else if (SSA_VAL (op0) != VN_TOP && SSA_VAL (op0) != op0)\n-\top0 = SSA_VAL (op0);\n+      else\n+\top0 = vn_valueize (op0);\n     }\n \n   if (TREE_CODE (op1) == SSA_NAME)\n     {\n-      if (VN_INFO (op1)->has_constants)\n+      if (VN_INFO (op1)->has_constants\n+\t  || code == COMPLEX_EXPR)\n \top1 = valueize_expr (vn_get_expr_for (op1));\n-      else if (SSA_VAL (op1) != VN_TOP && SSA_VAL (op1) != op1)\n-\top1 = SSA_VAL (op1);\n+      else\n+\top1 = vn_valueize (op1);\n     }\n \n   /* Pointer plus constant can be represented as invariant address.\n      Do so to allow further propatation, see also tree forwprop.  */\n-  if (gimple_assign_rhs_code (stmt) == POINTER_PLUS_EXPR\n+  if (code == POINTER_PLUS_EXPR\n       && host_integerp (op1, 1)\n       && TREE_CODE (op0) == ADDR_EXPR\n       && is_gimple_min_invariant (op0))\n@@ -2898,8 +2904,7 @@ simplify_binary_expression (gimple stmt)\n \n   fold_defer_overflow_warnings ();\n \n-  result = fold_binary (gimple_assign_rhs_code (stmt),\n-\t\t        gimple_expr_type (stmt), op0, op1);\n+  result = fold_binary (code, gimple_expr_type (stmt), op0, op1);\n   if (result)\n     STRIP_USELESS_TYPE_CONVERSION (result);\n \n@@ -2924,12 +2929,13 @@ simplify_unary_expression (gimple stmt)\n {\n   tree result = NULL_TREE;\n   tree orig_op0, op0 = gimple_assign_rhs1 (stmt);\n+  enum tree_code code = gimple_assign_rhs_code (stmt);\n \n   /* We handle some tcc_reference codes here that are all\n      GIMPLE_ASSIGN_SINGLE codes.  */\n-  if (gimple_assign_rhs_code (stmt) == REALPART_EXPR\n-      || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR\n-      || gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR)\n+  if (code == REALPART_EXPR\n+      || code == IMAGPART_EXPR\n+      || code == VIEW_CONVERT_EXPR)\n     op0 = TREE_OPERAND (op0, 0);\n \n   if (TREE_CODE (op0) != SSA_NAME)\n@@ -2938,10 +2944,10 @@ simplify_unary_expression (gimple stmt)\n   orig_op0 = op0;\n   if (VN_INFO (op0)->has_constants)\n     op0 = valueize_expr (vn_get_expr_for (op0));\n-  else if (gimple_assign_cast_p (stmt)\n-\t   || gimple_assign_rhs_code (stmt) == REALPART_EXPR\n-\t   || gimple_assign_rhs_code (stmt) == IMAGPART_EXPR\n-\t   || gimple_assign_rhs_code (stmt) == VIEW_CONVERT_EXPR)\n+  else if (CONVERT_EXPR_CODE_P (code)\n+\t   || code == REALPART_EXPR\n+\t   || code == IMAGPART_EXPR\n+\t   || code == VIEW_CONVERT_EXPR)\n     {\n       /* We want to do tree-combining on conversion-like expressions.\n          Make sure we feed only SSA_NAMEs or constants to fold though.  */\n@@ -2958,8 +2964,7 @@ simplify_unary_expression (gimple stmt)\n   if (op0 == orig_op0)\n     return NULL_TREE;\n \n-  result = fold_unary_ignore_overflow (gimple_assign_rhs_code (stmt),\n-\t\t\t\t       gimple_expr_type (stmt), op0);\n+  result = fold_unary_ignore_overflow (code, gimple_expr_type (stmt), op0);\n   if (result)\n     {\n       STRIP_USELESS_TYPE_CONVERSION (result);\n@@ -2970,19 +2975,6 @@ simplify_unary_expression (gimple stmt)\n   return NULL_TREE;\n }\n \n-/* Valueize NAME if it is an SSA name, otherwise just return it.  */\n-\n-static inline tree\n-vn_valueize (tree name)\n-{\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      tree tem = SSA_VAL (name);\n-      return tem == VN_TOP ? name : tem;\n-    }\n-  return name;\n-}\n-\n /* Try to simplify RHS using equivalences and constant folding.  */\n \n static tree"}]}