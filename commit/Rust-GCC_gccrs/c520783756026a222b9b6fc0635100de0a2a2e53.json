{"sha": "c520783756026a222b9b6fc0635100de0a2a2e53", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YzUyMDc4Mzc1NjAyNmEyMjJiOWI2ZmMwNjM1MTAwZGUwYTJhMmU1Mw==", "commit": {"author": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-04-29T08:08:44Z"}, "committer": {"name": "Paolo Bonzini", "email": "bonzini@gcc.gnu.org", "date": "2004-04-29T08:08:44Z"}, "message": "Complete last checkin:\n\n2004-04-29  Paolo Bonzini  <bonzini@gnu.org>\n\n\tComplete last checkin:\n        * combine.c (combine_simplify_rtx): Adjust call to use\n        simplify_relational_operation.  Do not use SELECT_CC_MODE\n        when a comparison already has a MODE_CC mode.\n\nFrom-SVN: r81283", "tree": {"sha": "f512c399873dcc24a30925a5e4ed736f66625763", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f512c399873dcc24a30925a5e4ed736f66625763"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/c520783756026a222b9b6fc0635100de0a2a2e53", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c520783756026a222b9b6fc0635100de0a2a2e53", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c520783756026a222b9b6fc0635100de0a2a2e53", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c520783756026a222b9b6fc0635100de0a2a2e53/comments", "author": null, "committer": null, "parents": [{"sha": "c6fb08ad284af074092aa4fb9edd1a9a44014b49", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c6fb08ad284af074092aa4fb9edd1a9a44014b49", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c6fb08ad284af074092aa4fb9edd1a9a44014b49"}], "stats": {"total": 424, "additions": 225, "deletions": 199}, "files": [{"sha": "eea9bf2849d66bf2095301652cea2ad51fe594b9", "filename": "gcc/combine.c", "status": "modified", "additions": 225, "deletions": 199, "changes": 424, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/c520783756026a222b9b6fc0635100de0a2a2e53/gcc%2Fcombine.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/c520783756026a222b9b6fc0635100de0a2a2e53/gcc%2Fcombine.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcombine.c?ref=c520783756026a222b9b6fc0635100de0a2a2e53", "patch": "@@ -143,103 +143,13 @@ static int max_uid_cuid;\n \n static unsigned int combine_max_regno;\n \n-struct reg_stat {\n-  /* Record last point of death of (hard or pseudo) register n.  */\n-  rtx\t\t\t\tlast_death;\n+/* Record last point of death of (hard or pseudo) register n.  */\n \n-  /* Record last point of modification of (hard or pseudo) register n.  */\n-  rtx\t\t\t\tlast_set;\n+static rtx *reg_last_death;\n \n-  /* The next group of fields allows the recording of the last value assigned\n-     to (hard or pseudo) register n.  We use this information to see if an\n-     operation being processed is redundant given a prior operation performed\n-     on the register.  For example, an `and' with a constant is redundant if\n-     all the zero bits are already known to be turned off.\n+/* Record last point of modification of (hard or pseudo) register n.  */\n \n-     We use an approach similar to that used by cse, but change it in the\n-     following ways:\n-\n-     (1) We do not want to reinitialize at each label.\n-     (2) It is useful, but not critical, to know the actual value assigned\n-         to a register.  Often just its form is helpful.\n-\n-     Therefore, we maintain the following fields:\n-\n-     last_set_value\t\tthe last value assigned\n-     last_set_label\t\trecords the value of label_tick when the\n-\t\t\t\tregister was assigned\n-     last_set_table_tick\trecords the value of label_tick when a\n-\t\t\t\tvalue using the register is assigned\n-     last_set_invalid\t\tset to nonzero when it is not valid\n-\t\t\t\tto use the value of this register in some\n-\t\t\t\tregister's value\n-\n-     To understand the usage of these tables, it is important to understand\n-     the distinction between the value in last_set_value being valid and\n-     the register being validly contained in some other expression in the\n-     table.\n-\n-     (The next two parameters are out of date).\n-\n-     reg_stat[i].last_set_value is valid if it is nonzero, and either\n-     reg_n_sets[i] is 1 or reg_stat[i].last_set_label == label_tick.\n-\n-     Register I may validly appear in any expression returned for the value\n-     of another register if reg_n_sets[i] is 1.  It may also appear in the\n-     value for register J if reg_stat[j].last_set_invalid is zero, or\n-     reg_stat[i].last_set_label < reg_stat[j].last_set_label.\n-\n-     If an expression is found in the table containing a register which may\n-     not validly appear in an expression, the register is replaced by\n-     something that won't match, (clobber (const_int 0)).  */\n-\n-  /* Record last value assigned to (hard or pseudo) register n.  */\n-\n-  rtx\t\t\t\tlast_set_value;\n-\n-  /* Record the value of label_tick when an expression involving register n\n-     is placed in last_set_value.  */\n-\n-  int\t\t\t\tlast_set_table_tick;\n-\n-  /* Record the value of label_tick when the value for register n is placed in\n-     last_set_value.  */\n-\n-  int\t\t\t\tlast_set_label;\n-\n-  /* These fields are maintained in parallel with last_set_value and are\n-     used to store the mode in which the register was last set, te bits\n-     that were known to be zero when it was last set, and the number of\n-     sign bits copies it was known to have when it was last set.  */\n-\n-  unsigned HOST_WIDE_INT\tlast_set_nonzero_bits;\n-  char\t\t\t\tlast_set_sign_bit_copies;\n-  ENUM_BITFIELD(machine_mode)\tlast_set_mode : 8; \n-\n-  /* Set nonzero if references to register n in expressions should not be\n-     used.  last_set_invalid is set nonzero when this register is being\n-     assigned to and last_set_table_tick == label_tick.  */\n-\n-  char\t\t\t\tlast_set_invalid;\n-\n-  /* Some registers that are set more than once and used in more than one\n-     basic block are nevertheless always set in similar ways.  For example,\n-     a QImode register may be loaded from memory in two places on a machine\n-     where byte loads zero extend.\n-\n-     We record in the following fields if a register has some leading bits\n-     that are always equal to the sign bit, and what we know about the\n-     nonzero bits of a register, specifically which bits are known to be\n-     zero.\n-\n-     If an entry is zero, it means that we don't know anything special.  */\n-\n-  unsigned char\t\t\tsign_bit_copies;\n-\n-  unsigned HOST_WIDE_INT\tnonzero_bits;\n-};\n-\n-static struct reg_stat *reg_stat;\n+static rtx *reg_last_set;\n \n /* Record the cuid of the last insn that invalidated memory\n    (anything that writes memory, and subroutine calls, but not pushes).  */\n@@ -287,23 +197,110 @@ static basic_block this_basic_block;\n    those blocks as starting points.  */\n static sbitmap refresh_blocks;\n \f\n+/* The next group of arrays allows the recording of the last value assigned\n+   to (hard or pseudo) register n.  We use this information to see if an\n+   operation being processed is redundant given a prior operation performed\n+   on the register.  For example, an `and' with a constant is redundant if\n+   all the zero bits are already known to be turned off.\n+\n+   We use an approach similar to that used by cse, but change it in the\n+   following ways:\n+\n+   (1) We do not want to reinitialize at each label.\n+   (2) It is useful, but not critical, to know the actual value assigned\n+       to a register.  Often just its form is helpful.\n+\n+   Therefore, we maintain the following arrays:\n+\n+   reg_last_set_value\t\tthe last value assigned\n+   reg_last_set_label\t\trecords the value of label_tick when the\n+\t\t\t\tregister was assigned\n+   reg_last_set_table_tick\trecords the value of label_tick when a\n+\t\t\t\tvalue using the register is assigned\n+   reg_last_set_invalid\t\tset to nonzero when it is not valid\n+\t\t\t\tto use the value of this register in some\n+\t\t\t\tregister's value\n+\n+   To understand the usage of these tables, it is important to understand\n+   the distinction between the value in reg_last_set_value being valid\n+   and the register being validly contained in some other expression in the\n+   table.\n+\n+   Entry I in reg_last_set_value is valid if it is nonzero, and either\n+   reg_n_sets[i] is 1 or reg_last_set_label[i] == label_tick.\n+\n+   Register I may validly appear in any expression returned for the value\n+   of another register if reg_n_sets[i] is 1.  It may also appear in the\n+   value for register J if reg_last_set_label[i] < reg_last_set_label[j] or\n+   reg_last_set_invalid[j] is zero.\n+\n+   If an expression is found in the table containing a register which may\n+   not validly appear in an expression, the register is replaced by\n+   something that won't match, (clobber (const_int 0)).\n+\n+   reg_last_set_invalid[i] is set nonzero when register I is being assigned\n+   to and reg_last_set_table_tick[i] == label_tick.  */\n+\n+/* Record last value assigned to (hard or pseudo) register n.  */\n+\n+static rtx *reg_last_set_value;\n+\n+/* Record the value of label_tick when the value for register n is placed in\n+   reg_last_set_value[n].  */\n+\n+static int *reg_last_set_label;\n+\n+/* Record the value of label_tick when an expression involving register n\n+   is placed in reg_last_set_value.  */\n+\n+static int *reg_last_set_table_tick;\n+\n+/* Set nonzero if references to register n in expressions should not be\n+   used.  */\n+\n+static char *reg_last_set_invalid;\n+\n /* Incremented for each label.  */\n \n static int label_tick;\n \n-/* Mode used to compute significance in reg_stat[].nonzero_bits.  It is the\n-   largest integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n+/* Some registers that are set more than once and used in more than one\n+   basic block are nevertheless always set in similar ways.  For example,\n+   a QImode register may be loaded from memory in two places on a machine\n+   where byte loads zero extend.\n+\n+   We record in the following array what we know about the nonzero\n+   bits of a register, specifically which bits are known to be zero.\n+\n+   If an entry is zero, it means that we don't know anything special.  */\n+\n+static unsigned HOST_WIDE_INT *reg_nonzero_bits;\n+\n+/* Mode used to compute significance in reg_nonzero_bits.  It is the largest\n+   integer mode that can fit in HOST_BITS_PER_WIDE_INT.  */\n \n static enum machine_mode nonzero_bits_mode;\n \n-/* Nonzero when reg_stat[].nonzero_bits and reg_stat[].sign_bit_copies can\n-   be safely used.  It is zero while computing them and after combine has\n-   completed.  This former test prevents propagating values based on\n-   previously set values, which can be incorrect if a variable is modified\n-   in a loop.  */\n+/* Nonzero if we know that a register has some leading bits that are always\n+   equal to the sign bit.  */\n+\n+static unsigned char *reg_sign_bit_copies;\n+\n+/* Nonzero when reg_nonzero_bits and reg_sign_bit_copies can be safely used.\n+   It is zero while computing them and after combine has completed.  This\n+   former test prevents propagating values based on previously set values,\n+   which can be incorrect if a variable is modified in a loop.  */\n \n static int nonzero_sign_valid;\n \n+/* These arrays are maintained in parallel with reg_last_set_value\n+   and are used to store the mode in which the register was last set,\n+   the bits that were known to be zero when it was last set, and the\n+   number of sign bits copies it was known to have when it was last set.  */\n+\n+static enum machine_mode *reg_last_set_mode;\n+static unsigned HOST_WIDE_INT *reg_last_set_nonzero_bits;\n+static char *reg_last_set_sign_bit_copies;\n \f\n /* Record one modification to rtl structure\n    to be undone by storing old_contents into *where.\n@@ -339,7 +336,7 @@ static int n_occurrences;\n \n static void do_SUBST (rtx *, rtx);\n static void do_SUBST_INT (int *, int);\n-static void init_reg_last (void);\n+static void init_reg_last_arrays (void);\n static void setup_incoming_promotions (void);\n static void set_nonzero_bits_and_sign_copies (rtx, rtx, void *);\n static int cant_combine_insn_p (rtx);\n@@ -526,7 +523,20 @@ combine_instructions (rtx f, unsigned int nregs)\n      See comments in gen_lowpart_for_combine.  */\n   gen_lowpart = gen_lowpart_for_combine;\n \n-  reg_stat = xcalloc (nregs, sizeof (struct reg_stat));\n+  reg_nonzero_bits = xcalloc (nregs, sizeof (unsigned HOST_WIDE_INT));\n+  reg_sign_bit_copies = xcalloc (nregs, sizeof (unsigned char));\n+\n+  reg_last_death = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set_value = xmalloc (nregs * sizeof (rtx));\n+  reg_last_set_table_tick = xmalloc (nregs * sizeof (int));\n+  reg_last_set_label = xmalloc (nregs * sizeof (int));\n+  reg_last_set_invalid = xmalloc (nregs * sizeof (char));\n+  reg_last_set_mode = xmalloc (nregs * sizeof (enum machine_mode));\n+  reg_last_set_nonzero_bits = xmalloc (nregs * sizeof (HOST_WIDE_INT));\n+  reg_last_set_sign_bit_copies = xmalloc (nregs * sizeof (char));\n+\n+  init_reg_last_arrays ();\n \n   init_recog_no_volatile ();\n \n@@ -541,8 +551,8 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   nonzero_bits_mode = mode_for_size (HOST_BITS_PER_WIDE_INT, MODE_INT, 0);\n \n-  /* Don't use reg_stat[].nonzero_bits when computing it.  This can cause\n-     problems when, for example, we have j <<= 1 in a loop.  */\n+  /* Don't use reg_nonzero_bits when computing it.  This can cause problems\n+     when, for example, we have j <<= 1 in a loop.  */\n \n   nonzero_sign_valid = 0;\n \n@@ -595,7 +605,7 @@ combine_instructions (rtx f, unsigned int nregs)\n   label_tick = 1;\n   last_call_cuid = 0;\n   mem_last_set = 0;\n-  init_reg_last ();\n+  init_reg_last_arrays ();\n   setup_incoming_promotions ();\n \n   FOR_EACH_BB (this_basic_block)\n@@ -758,7 +768,17 @@ combine_instructions (rtx f, unsigned int nregs)\n \n   /* Clean up.  */\n   sbitmap_free (refresh_blocks);\n-  free (reg_stat);\n+  free (reg_nonzero_bits);\n+  free (reg_sign_bit_copies);\n+  free (reg_last_death);\n+  free (reg_last_set);\n+  free (reg_last_set_value);\n+  free (reg_last_set_table_tick);\n+  free (reg_last_set_label);\n+  free (reg_last_set_invalid);\n+  free (reg_last_set_mode);\n+  free (reg_last_set_nonzero_bits);\n+  free (reg_last_set_sign_bit_copies);\n   free (uid_cuid);\n \n   {\n@@ -785,14 +805,22 @@ combine_instructions (rtx f, unsigned int nregs)\n   return new_direct_jump_p;\n }\n \n-/* Wipe the last_xxx fields of reg_stat in preparation for another pass.  */\n+/* Wipe the reg_last_xxx arrays in preparation for another pass.  */\n \n static void\n-init_reg_last (void)\n+init_reg_last_arrays (void)\n {\n-  unsigned int i;\n-  for (i = 0; i < combine_max_regno; i++)\n-    memset (reg_stat + i, 0, offsetof (struct reg_stat, sign_bit_copies));\n+  unsigned int nregs = combine_max_regno;\n+\n+  memset (reg_last_death, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set_value, 0, nregs * sizeof (rtx));\n+  memset (reg_last_set_table_tick, 0, nregs * sizeof (int));\n+  memset (reg_last_set_label, 0, nregs * sizeof (int));\n+  memset (reg_last_set_invalid, 0, nregs * sizeof (char));\n+  memset (reg_last_set_mode, 0, nregs * sizeof (enum machine_mode));\n+  memset (reg_last_set_nonzero_bits, 0, nregs * sizeof (HOST_WIDE_INT));\n+  memset (reg_last_set_sign_bit_copies, 0, nregs * sizeof (char));\n }\n \f\n /* Set up any promoted values for incoming argument registers.  */\n@@ -850,8 +878,8 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n     {\n       if (set == 0 || GET_CODE (set) == CLOBBER)\n \t{\n-\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_sign_bit_copies[REGNO (x)] = 1;\n \t  return;\n \t}\n \n@@ -873,7 +901,7 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than a word and SRC is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_stat[].nonzero_bits because some\n+\t     sign-extend it for use in reg_nonzero_bits because some\n \t     machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n@@ -892,18 +920,18 @@ set_nonzero_bits_and_sign_copies (rtx x, rtx set,\n #endif\n \n \t  /* Don't call nonzero_bits if it cannot change anything.  */\n-\t  if (reg_stat[REGNO (x)].nonzero_bits != ~(unsigned HOST_WIDE_INT) 0)\n-\t    reg_stat[REGNO (x)].nonzero_bits\n+\t  if (reg_nonzero_bits[REGNO (x)] != ~(unsigned HOST_WIDE_INT) 0)\n+\t    reg_nonzero_bits[REGNO (x)]\n \t      |= nonzero_bits (src, nonzero_bits_mode);\n \t  num = num_sign_bit_copies (SET_SRC (set), GET_MODE (x));\n-\t  if (reg_stat[REGNO (x)].sign_bit_copies == 0\n-\t      || reg_stat[REGNO (x)].sign_bit_copies > num)\n-\t    reg_stat[REGNO (x)].sign_bit_copies = num;\n+\t  if (reg_sign_bit_copies[REGNO (x)] == 0\n+\t      || reg_sign_bit_copies[REGNO (x)] > num)\n+\t    reg_sign_bit_copies[REGNO (x)] = num;\n \t}\n       else\n \t{\n-\t  reg_stat[REGNO (x)].nonzero_bits = GET_MODE_MASK (GET_MODE (x));\n-\t  reg_stat[REGNO (x)].sign_bit_copies = 1;\n+\t  reg_nonzero_bits[REGNO (x)] = GET_MODE_MASK (GET_MODE (x));\n+\t  reg_sign_bit_copies[REGNO (x)] = 1;\n \t}\n     }\n }\n@@ -1073,7 +1101,7 @@ can_combine_p (rtx insn, rtx i3, rtx pred ATTRIBUTE_UNUSED, rtx succ,\n \t does not use any registers whose values alter in between.  However,\n \t If the insns are adjacent, a use can't cross a set even though we\n \t think it might (this can happen for a sequence of insns each setting\n-\t the same destination; last_set of that register might point to\n+\t the same destination; reg_last_set of that register might point to\n \t a NOTE).  If INSN has a REG_EQUIV note, the register is always\n \t equivalent to the memory so the substitution is valid even if there\n \t are intervening stores.  Also, don't move a volatile asm or\n@@ -2303,18 +2331,18 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t   && GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) != STRICT_LOW_PART\n \t   && ! (temp = SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t (GET_CODE (temp) == REG\n-\t\t  && reg_stat[REGNO (temp)].nonzero_bits != 0\n+\t\t  && reg_nonzero_bits[REGNO (temp)] != 0\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t  && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t  && (reg_stat[REGNO (temp)].nonzero_bits\n+\t\t  && (reg_nonzero_bits[REGNO (temp)]\n \t\t      != GET_MODE_MASK (word_mode))))\n \t   && ! (GET_CODE (SET_DEST (XVECEXP (newpat, 0, 1))) == SUBREG\n \t\t && (temp = SUBREG_REG (SET_DEST (XVECEXP (newpat, 0, 1))),\n \t\t     (GET_CODE (temp) == REG\n-\t\t      && reg_stat[REGNO (temp)].nonzero_bits != 0\n+\t\t      && reg_nonzero_bits[REGNO (temp)] != 0\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < BITS_PER_WORD\n \t\t      && GET_MODE_BITSIZE (GET_MODE (temp)) < HOST_BITS_PER_INT\n-\t\t      && (reg_stat[REGNO (temp)].nonzero_bits\n+\t\t      && (reg_nonzero_bits[REGNO (temp)]\n \t\t\t  != GET_MODE_MASK (word_mode)))))\n \t   && ! reg_overlap_mentioned_p (SET_DEST (XVECEXP (newpat, 0, 1)),\n \t\t\t\t\t SET_SRC (XVECEXP (newpat, 0, 1)))\n@@ -2755,10 +2783,9 @@ try_combine (rtx i3, rtx i2, rtx i1, int *new_direct_jump_p)\n \t  REG_N_SETS (regno)--;\n       }\n \n-    /* Update reg_stat[].nonzero_bits et al for any changes that may have\n-       been made to this insn.  The order of\n-       set_nonzero_bits_and_sign_copies() is important.  Because newi2pat\n-       can affect nonzero_bits of newpat */\n+    /* Update reg_nonzero_bits et al for any changes that may have been made\n+       to this insn.  The order of set_nonzero_bits_and_sign_copies() is\n+       important.  Because newi2pat can affect nonzero_bits of newpat */\n     if (newi2pat)\n       note_stores (newi2pat, set_nonzero_bits_and_sign_copies, NULL);\n     note_stores (newpat, set_nonzero_bits_and_sign_copies, NULL);\n@@ -8144,17 +8171,17 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n \t value.  Otherwise, use the previously-computed global nonzero bits\n \t for this register.  */\n \n-      if (reg_stat[REGNO (x)].last_set_value != 0\n-\t  && (reg_stat[REGNO (x)].last_set_mode == mode\n-\t      || (GET_MODE_CLASS (reg_stat[REGNO (x)].last_set_mode) == MODE_INT\n+      if (reg_last_set_value[REGNO (x)] != 0\n+\t  && (reg_last_set_mode[REGNO (x)] == mode\n+\t      || (GET_MODE_CLASS (reg_last_set_mode[REGNO (x)]) == MODE_INT\n \t\t  && GET_MODE_CLASS (mode) == MODE_INT))\n-\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n+\t  && (reg_last_set_label[REGNO (x)] == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n-\treturn reg_stat[REGNO (x)].last_set_nonzero_bits & nonzero;\n+\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n+\treturn reg_last_set_nonzero_bits[REGNO (x)] & nonzero;\n \n       tem = get_last_value (x);\n \n@@ -8163,8 +8190,8 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #ifdef SHORT_IMMEDIATES_SIGN_EXTEND\n \t  /* If X is narrower than MODE and TEM is a non-negative\n \t     constant that would appear negative in the mode of X,\n-\t     sign-extend it for use in reg_stat[].nonzero_bits because\n-\t     some machines (maybe most) will actually do the sign-extension\n+\t     sign-extend it for use in reg_nonzero_bits because some\n+\t     machines (maybe most) will actually do the sign-extension\n \t     and this is the conservative approach.\n \n \t     ??? For 2.5, try to tighten up the MD files in this regard\n@@ -8182,9 +8209,9 @@ nonzero_bits1 (rtx x, enum machine_mode mode, rtx known_x,\n #endif\n \t  return nonzero_bits_with_known (tem, mode) & nonzero;\n \t}\n-      else if (nonzero_sign_valid && reg_stat[REGNO (x)].nonzero_bits)\n+      else if (nonzero_sign_valid && reg_nonzero_bits[REGNO (x)])\n \t{\n-\t  unsigned HOST_WIDE_INT mask = reg_stat[REGNO (x)].nonzero_bits;\n+\t  unsigned HOST_WIDE_INT mask = reg_nonzero_bits[REGNO (x)];\n \n \t  if (GET_MODE_BITSIZE (GET_MODE (x)) < mode_width)\n \t    /* We don't know anything about the upper bits.  */\n@@ -8640,23 +8667,23 @@ num_sign_bit_copies1 (rtx x, enum machine_mode mode, rtx known_x,\n \treturn GET_MODE_BITSIZE (Pmode) - GET_MODE_BITSIZE (ptr_mode) + 1;\n #endif\n \n-      if (reg_stat[REGNO (x)].last_set_value != 0\n-\t  && reg_stat[REGNO (x)].last_set_mode == mode\n-\t  && (reg_stat[REGNO (x)].last_set_label == label_tick\n+      if (reg_last_set_value[REGNO (x)] != 0\n+\t  && reg_last_set_mode[REGNO (x)] == mode\n+\t  && (reg_last_set_label[REGNO (x)] == label_tick\n \t      || (REGNO (x) >= FIRST_PSEUDO_REGISTER\n \t\t  && REG_N_SETS (REGNO (x)) == 1\n \t\t  && ! REGNO_REG_SET_P (ENTRY_BLOCK_PTR->next_bb->global_live_at_start,\n \t\t\t\t\tREGNO (x))))\n-\t  && INSN_CUID (reg_stat[REGNO (x)].last_set) < subst_low_cuid)\n-\treturn reg_stat[REGNO (x)].last_set_sign_bit_copies;\n+\t  && INSN_CUID (reg_last_set[REGNO (x)]) < subst_low_cuid)\n+\treturn reg_last_set_sign_bit_copies[REGNO (x)];\n \n       tem = get_last_value (x);\n       if (tem != 0)\n \treturn num_sign_bit_copies_with_known (tem, mode);\n \n-      if (nonzero_sign_valid && reg_stat[REGNO (x)].sign_bit_copies != 0\n+      if (nonzero_sign_valid && reg_sign_bit_copies[REGNO (x)] != 0\n \t  && GET_MODE_BITSIZE (GET_MODE (x)) == bitwidth)\n-\treturn reg_stat[REGNO (x)].sign_bit_copies;\n+\treturn reg_sign_bit_copies[REGNO (x)];\n       break;\n \n     case MEM:\n@@ -11340,7 +11367,7 @@ reversed_comparison (rtx exp, enum machine_mode mode, rtx op0, rtx op1)\n }\n \f\n /* Utility function for following routine.  Called when X is part of a value\n-   being stored into last_set_value.  Sets last_set_table_tick\n+   being stored into reg_last_set_value.  Sets reg_last_set_table_tick\n    for each register mentioned.  Similar to mention_regs in cse.c  */\n \n static void\n@@ -11359,7 +11386,7 @@ update_table_tick (rtx x)\n       unsigned int r;\n \n       for (r = regno; r < endregno; r++)\n-\treg_stat[r].last_set_table_tick = label_tick;\n+\treg_last_set_table_tick[r] = label_tick;\n \n       return;\n     }\n@@ -11407,9 +11434,8 @@ update_table_tick (rtx x)\n \n /* Record that REG is set to VALUE in insn INSN.  If VALUE is zero, we\n    are saying that the register is clobbered and we no longer know its\n-   value.  If INSN is zero, don't update reg_stat[].last_set; this is\n-   only permitted with VALUE also zero and is used to invalidate the\n-   register.  */\n+   value.  If INSN is zero, don't update reg_last_set; this is only permitted\n+   with VALUE also zero and is used to invalidate the register.  */\n \n static void\n record_value_for_reg (rtx reg, rtx insn, rtx value)\n@@ -11453,13 +11479,13 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n   for (i = regno; i < endregno; i++)\n     {\n       if (insn)\n-\treg_stat[i].last_set = insn;\n+\treg_last_set[i] = insn;\n \n-      reg_stat[i].last_set_value = 0;\n-      reg_stat[i].last_set_mode = 0;\n-      reg_stat[i].last_set_nonzero_bits = 0;\n-      reg_stat[i].last_set_sign_bit_copies = 0;\n-      reg_stat[i].last_death = 0;\n+      reg_last_set_value[i] = 0;\n+      reg_last_set_mode[i] = 0;\n+      reg_last_set_nonzero_bits[i] = 0;\n+      reg_last_set_sign_bit_copies[i] = 0;\n+      reg_last_death[i] = 0;\n     }\n \n   /* Mark registers that are being referenced in this value.  */\n@@ -11475,40 +11501,40 @@ record_value_for_reg (rtx reg, rtx insn, rtx value)\n \n   for (i = regno; i < endregno; i++)\n     {\n-      reg_stat[i].last_set_label = label_tick;\n-      if (value && reg_stat[i].last_set_table_tick == label_tick)\n-\treg_stat[i].last_set_invalid = 1;\n+      reg_last_set_label[i] = label_tick;\n+      if (value && reg_last_set_table_tick[i] == label_tick)\n+\treg_last_set_invalid[i] = 1;\n       else\n-\treg_stat[i].last_set_invalid = 0;\n+\treg_last_set_invalid[i] = 0;\n     }\n \n   /* The value being assigned might refer to X (like in \"x++;\").  In that\n      case, we must replace it with (clobber (const_int 0)) to prevent\n      infinite loops.  */\n   if (value && ! get_last_value_validate (&value, insn,\n-\t\t\t\t\t  reg_stat[regno].last_set_label, 0))\n+\t\t\t\t\t  reg_last_set_label[regno], 0))\n     {\n       value = copy_rtx (value);\n       if (! get_last_value_validate (&value, insn,\n-\t\t\t\t     reg_stat[regno].last_set_label, 1))\n+\t\t\t\t     reg_last_set_label[regno], 1))\n \tvalue = 0;\n     }\n \n   /* For the main register being modified, update the value, the mode, the\n      nonzero bits, and the number of sign bit copies.  */\n \n-  reg_stat[regno].last_set_value = value;\n+  reg_last_set_value[regno] = value;\n \n   if (value)\n     {\n       enum machine_mode mode = GET_MODE (reg);\n       subst_low_cuid = INSN_CUID (insn);\n-      reg_stat[regno].last_set_mode = mode;\n+      reg_last_set_mode[regno] = mode;\n       if (GET_MODE_CLASS (mode) == MODE_INT\n \t  && GET_MODE_BITSIZE (mode) <= HOST_BITS_PER_WIDE_INT)\n \tmode = nonzero_bits_mode;\n-      reg_stat[regno].last_set_nonzero_bits = nonzero_bits (value, mode);\n-      reg_stat[regno].last_set_sign_bit_copies\n+      reg_last_set_nonzero_bits[regno] = nonzero_bits (value, mode);\n+      reg_last_set_sign_bit_copies[regno]\n \t= num_sign_bit_copies (value, GET_MODE (reg));\n     }\n }\n@@ -11553,11 +11579,11 @@ record_dead_and_set_regs_1 (rtx dest, rtx setter, void *data)\n    for the things done by INSN.  This is the last thing done in processing\n    INSN in the combiner loop.\n \n-   We update reg_stat[], in particular fields last_set, last_set_value,\n-   last_set_mode, last_set_nonzero_bits, last_set_sign_bit_copies,\n-   last_death, and also the similar information mem_last_set (which insn\n-   most recently modified memory) and last_call_cuid (which insn was the\n-   most recent subroutine call).  */\n+   We update reg_last_set, reg_last_set_value, reg_last_set_mode,\n+   reg_last_set_nonzero_bits, reg_last_set_sign_bit_copies, reg_last_death,\n+   and also the similar information mem_last_set (which insn most recently\n+   modified memory) and last_call_cuid (which insn was the most recent\n+   subroutine call).  */\n \n static void\n record_dead_and_set_regs (rtx insn)\n@@ -11577,7 +11603,7 @@ record_dead_and_set_regs (rtx insn)\n \t\t       : 1);\n \n \t  for (i = regno; i < endregno; i++)\n-\t    reg_stat[i].last_death = insn;\n+\t    reg_last_death[i] = insn;\n \t}\n       else if (REG_NOTE_KIND (link) == REG_INC)\n \trecord_value_for_reg (XEXP (link, 0), insn, NULL_RTX);\n@@ -11588,11 +11614,11 @@ record_dead_and_set_regs (rtx insn)\n       for (i = 0; i < FIRST_PSEUDO_REGISTER; i++)\n \tif (TEST_HARD_REG_BIT (regs_invalidated_by_call, i))\n \t  {\n-\t    reg_stat[i].last_set_value = 0;\n-\t    reg_stat[i].last_set_mode = 0;\n-\t    reg_stat[i].last_set_nonzero_bits = 0;\n-\t    reg_stat[i].last_set_sign_bit_copies = 0;\n-\t    reg_stat[i].last_death = 0;\n+\t    reg_last_set_value[i] = 0;\n+\t    reg_last_set_mode[i] = 0;\n+\t    reg_last_set_nonzero_bits[i] = 0;\n+\t    reg_last_set_sign_bit_copies[i] = 0;\n+\t    reg_last_death[i] = 0;\n \t  }\n \n       last_call_cuid = mem_last_set = INSN_CUID (insn);\n@@ -11640,10 +11666,10 @@ record_promoted_value (rtx insn, rtx subreg)\n \t  continue;\n \t}\n \n-      if (reg_stat[regno].last_set == insn)\n+      if (reg_last_set[regno] == insn)\n \t{\n \t  if (SUBREG_PROMOTED_UNSIGNED_P (subreg) > 0)\n-\t    reg_stat[regno].last_set_nonzero_bits &= GET_MODE_MASK (mode);\n+\t    reg_last_set_nonzero_bits[regno] &= GET_MODE_MASK (mode);\n \t}\n \n       if (GET_CODE (SET_SRC (set)) == REG)\n@@ -11713,14 +11739,14 @@ get_last_value_validate (rtx *loc, rtx insn, int tick, int replace)\n       unsigned int j;\n \n       for (j = regno; j < endregno; j++)\n-\tif (reg_stat[j].last_set_invalid\n+\tif (reg_last_set_invalid[j]\n \t    /* If this is a pseudo-register that was only set once and not\n \t       live at the beginning of the function, it is always valid.  */\n \t    || (! (regno >= FIRST_PSEUDO_REGISTER\n \t\t   && REG_N_SETS (regno) == 1\n \t\t   && (! REGNO_REG_SET_P\n \t\t       (ENTRY_BLOCK_PTR->next_bb->global_live_at_start, regno)))\n-\t\t&& reg_stat[j].last_set_label > tick))\n+\t\t&& reg_last_set_label[j] > tick))\n \t  {\n \t    if (replace)\n \t      *loc = gen_rtx_CLOBBER (GET_MODE (x), const0_rtx);\n@@ -11812,7 +11838,7 @@ get_last_value (rtx x)\n     return 0;\n \n   regno = REGNO (x);\n-  value = reg_stat[regno].last_set_value;\n+  value = reg_last_set_value[regno];\n \n   /* If we don't have a value, or if it isn't for this basic block and\n      it's either a hard register, set more than once, or it's a live\n@@ -11825,7 +11851,7 @@ get_last_value (rtx x)\n      block.  */\n \n   if (value == 0\n-      || (reg_stat[regno].last_set_label != label_tick\n+      || (reg_last_set_label[regno] != label_tick\n \t  && (regno < FIRST_PSEUDO_REGISTER\n \t      || REG_N_SETS (regno) != 1\n \t      || (REGNO_REG_SET_P\n@@ -11834,20 +11860,20 @@ get_last_value (rtx x)\n \n   /* If the value was set in a later insn than the ones we are processing,\n      we can't use it even if the register was only set once.  */\n-  if (INSN_CUID (reg_stat[regno].last_set) >= subst_low_cuid)\n+  if (INSN_CUID (reg_last_set[regno]) >= subst_low_cuid)\n     return 0;\n \n   /* If the value has all its registers valid, return it.  */\n-  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n-\t\t\t       reg_stat[regno].last_set_label, 0))\n+  if (get_last_value_validate (&value, reg_last_set[regno],\n+\t\t\t       reg_last_set_label[regno], 0))\n     return value;\n \n   /* Otherwise, make a copy and replace any invalid register with\n      (clobber (const_int 0)).  If that fails for some reason, return 0.  */\n \n   value = copy_rtx (value);\n-  if (get_last_value_validate (&value, reg_stat[regno].last_set,\n-\t\t\t       reg_stat[regno].last_set_label, 1))\n+  if (get_last_value_validate (&value, reg_last_set[regno],\n+\t\t\t       reg_last_set_label[regno], 1))\n     return value;\n \n   return 0;\n@@ -11876,8 +11902,8 @@ use_crosses_set_p (rtx x, int from_cuid)\n \treturn 1;\n #endif\n       for (; regno < endreg; regno++)\n-\tif (reg_stat[regno].last_set\n-\t    && INSN_CUID (reg_stat[regno].last_set) > from_cuid)\n+\tif (reg_last_set[regno]\n+\t    && INSN_CUID (reg_last_set[regno]) > from_cuid)\n \t  return 1;\n       return 0;\n     }\n@@ -12137,7 +12163,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n   if (code == REG)\n     {\n       unsigned int regno = REGNO (x);\n-      rtx where_dead = reg_stat[regno].last_death;\n+      rtx where_dead = reg_last_death[regno];\n       rtx before_dead, after_dead;\n \n       /* Don't move the register if it gets killed in between from and to.  */\n@@ -12164,7 +12190,7 @@ move_deaths (rtx x, rtx maybe_kill_insn, int from_cuid, rtx to_insn,\n \t  rtx note = remove_death (regno, where_dead);\n \n \t  /* It is possible for the call above to return 0.  This can occur\n-\t     when last_death points to I2 or I1 that we combined with.\n+\t     when reg_last_death points to I2 or I1 that we combined with.\n \t     In that case make a new note.\n \n \t     We must also check for the case where X is a hard register\n@@ -12771,14 +12797,14 @@ distribute_notes (rtx notes, rtx from_insn, rtx i3, rtx i2)\n \t\t  || reg_bitfield_target_p (XEXP (note, 0), PATTERN (place)))\n \t\t{\n \t\t  /* Unless the register previously died in PLACE, clear\n-\t\t     last_death.  [I no longer understand why this is\n+\t\t     reg_last_death.  [I no longer understand why this is\n \t\t     being done.] */\n-\t\t  if (reg_stat[regno].last_death != place)\n-\t\t    reg_stat[regno].last_death = 0;\n+\t\t  if (reg_last_death[regno] != place)\n+\t\t    reg_last_death[regno] = 0;\n \t\t  place = 0;\n \t\t}\n \t      else\n-\t\treg_stat[regno].last_death = place;\n+\t\treg_last_death[regno] = place;\n \n \t      /* If this is a death note for a hard reg that is occupying\n \t\t multiple registers, ensure that we are still using all"}]}