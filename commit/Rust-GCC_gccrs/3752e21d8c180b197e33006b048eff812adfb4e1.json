{"sha": "3752e21d8c180b197e33006b048eff812adfb4e1", "node_id": "C_kwDOANBUbNoAKDM3NTJlMjFkOGMxODBiMTk3ZTMzMDA2YjA0OGVmZjgxMmFkZmI0ZTE", "commit": {"author": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-24T17:43:01Z"}, "committer": {"name": "David Malcolm", "email": "dmalcolm@redhat.com", "date": "2022-06-24T17:43:01Z"}, "message": "analyzer: whitespace cleanups\n\nClean up whitespace in preparation for a follow-up patch.\n\nNo functional change intended.\n\ngcc/analyzer/ChangeLog:\n\t* call-string.cc (call_string::calc_recursion_depth): Whitespace\n\tcleanups.\n\t(call_string::cmp): Likewise.\n\t(call_string::get_caller_node): Likewise.\n\t(call_string::validate): Likewise.\n\t* engine.cc (dynamic_call_info_t::add_events_to_path): Likewise.\n\t(exploded_graph::get_per_function_data): Likewise.\n\t(exploded_graph::maybe_create_dynamic_call): Likewise.\n\t(exploded_graph::maybe_create_dynamic_call): Likewise.\n\t(exploded_graph::process_node): Likewise.\n\nSigned-off-by: David Malcolm <dmalcolm@redhat.com>", "tree": {"sha": "c7e82b8ef98368ba3ec0c5dcd007c49a62178c26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c7e82b8ef98368ba3ec0c5dcd007c49a62178c26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/3752e21d8c180b197e33006b048eff812adfb4e1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3752e21d8c180b197e33006b048eff812adfb4e1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3752e21d8c180b197e33006b048eff812adfb4e1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3752e21d8c180b197e33006b048eff812adfb4e1/comments", "author": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "committer": {"login": "davidmalcolm", "id": 1553248, "node_id": "MDQ6VXNlcjE1NTMyNDg=", "avatar_url": "https://avatars.githubusercontent.com/u/1553248?v=4", "gravatar_id": "", "url": "https://api.github.com/users/davidmalcolm", "html_url": "https://github.com/davidmalcolm", "followers_url": "https://api.github.com/users/davidmalcolm/followers", "following_url": "https://api.github.com/users/davidmalcolm/following{/other_user}", "gists_url": "https://api.github.com/users/davidmalcolm/gists{/gist_id}", "starred_url": "https://api.github.com/users/davidmalcolm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/davidmalcolm/subscriptions", "organizations_url": "https://api.github.com/users/davidmalcolm/orgs", "repos_url": "https://api.github.com/users/davidmalcolm/repos", "events_url": "https://api.github.com/users/davidmalcolm/events{/privacy}", "received_events_url": "https://api.github.com/users/davidmalcolm/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "eb2887a19fee305b6d052d30dcfd321704f2ef09", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/eb2887a19fee305b6d052d30dcfd321704f2ef09", "html_url": "https://github.com/Rust-GCC/gccrs/commit/eb2887a19fee305b6d052d30dcfd321704f2ef09"}], "stats": {"total": 271, "additions": 135, "deletions": 136}, "files": [{"sha": "2ccd3ccd6fba4d26ac1e11ee89e0793808f9f433", "filename": "gcc/analyzer/call-string.cc", "status": "modified", "additions": 8, "deletions": 10, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3752e21d8c180b197e33006b048eff812adfb4e1/gcc%2Fanalyzer%2Fcall-string.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3752e21d8c180b197e33006b048eff812adfb4e1/gcc%2Fanalyzer%2Fcall-string.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fcall-string.cc?ref=3752e21d8c180b197e33006b048eff812adfb4e1", "patch": "@@ -206,7 +206,7 @@ call_string::calc_recursion_depth () const\n {\n   if (m_elements.is_empty ())\n     return 0;\n-  const call_string::element_t top_return_sedge \n+  const call_string::element_t top_return_sedge\n     = m_elements[m_elements.length () - 1];\n \n   int result = 0;\n@@ -247,12 +247,12 @@ call_string::cmp (const call_string &a,\n       /* Otherwise, compare the node pairs.  */\n       const call_string::element_t a_node_pair = a[i];\n       const call_string::element_t b_node_pair = b[i];\n-      int src_cmp \n-      \t= a_node_pair.m_callee->m_index - b_node_pair.m_callee->m_index;\n+      int src_cmp\n+\t= a_node_pair.m_callee->m_index - b_node_pair.m_callee->m_index;\n       if (src_cmp)\n \treturn src_cmp;\n-      int dest_cmp \n-      \t= a_node_pair.m_caller->m_index - b_node_pair.m_caller->m_index;\n+      int dest_cmp\n+\t= a_node_pair.m_caller->m_index - b_node_pair.m_caller->m_index;\n       if (dest_cmp)\n \treturn dest_cmp;\n       i++;\n@@ -272,7 +272,7 @@ call_string::get_callee_node () const\n \n /* Return the pointer to caller of the topmost call in the stack,\n    or NULL if stack is empty.  */\n-const supernode * \n+const supernode *\n call_string::get_caller_node () const\n {\n   if(m_elements.is_empty ())\n@@ -295,10 +295,8 @@ call_string::validate () const\n   int i;\n   FOR_EACH_VEC_ELT (m_elements, i, e)\n     if (i > 0)\n-    {\n-      gcc_assert (e->get_caller_function () == \n-      \t\t  m_elements[i - 1].get_callee_function ());\n-    }\n+      gcc_assert (e->get_caller_function () ==\n+\t\t  m_elements[i - 1].get_callee_function ());\n }\n \n #endif /* #if ENABLE_ANALYZER */"}, {"sha": "51dfe29823002ba3c9d1a29e6ba54f5ea9dc33cc", "filename": "gcc/analyzer/engine.cc", "status": "modified", "additions": 127, "deletions": 126, "changes": 253, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/3752e21d8c180b197e33006b048eff812adfb4e1/gcc%2Fanalyzer%2Fengine.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/3752e21d8c180b197e33006b048eff812adfb4e1/gcc%2Fanalyzer%2Fengine.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fanalyzer%2Fengine.cc?ref=3752e21d8c180b197e33006b048eff812adfb4e1", "patch": "@@ -1853,18 +1853,19 @@ dynamic_call_info_t::add_events_to_path (checker_path *emission_path,\n   const int dest_stack_depth = dest_point.get_stack_depth ();\n \n   if (m_is_returning_call)\n-    emission_path->add_event (new return_event (eedge, (m_dynamic_call\n-\t                   \t\t\t        ? m_dynamic_call->location\n-\t           \t   \t\t                : UNKNOWN_LOCATION),\n-\t          \t      dest_point.get_fndecl (),\n-\t          \t      dest_stack_depth));\n+    emission_path->add_event (new return_event (eedge,\n+\t\t\t\t\t\t(m_dynamic_call\n+\t\t\t\t\t\t ? m_dynamic_call->location\n+\t\t\t\t\t\t : UNKNOWN_LOCATION),\n+\t\t\t\t\t\tdest_point.get_fndecl (),\n+\t\t\t\t\t\tdest_stack_depth));\n   else\n-    emission_path->add_event (new call_event (eedge, (m_dynamic_call\n-\t                   \t\t\t      ? m_dynamic_call->location\n-\t           \t   \t\t              : UNKNOWN_LOCATION),\n-\t          \t      src_point.get_fndecl (),\n-\t          \t      src_stack_depth));\n-\n+    emission_path->add_event (new call_event (eedge,\n+\t\t\t\t\t      (m_dynamic_call\n+\t\t\t\t\t       ? m_dynamic_call->location\n+\t\t\t\t\t       : UNKNOWN_LOCATION),\n+\t\t\t\t\t      src_point.get_fndecl (),\n+\t\t\t\t\t      src_stack_depth));\n }\n \n /* class rewind_info_t : public custom_edge_info.  */\n@@ -2825,7 +2826,7 @@ per_function_data *\n exploded_graph::get_per_function_data (function *fun) const\n {\n   if (per_function_data **slot\n-        = const_cast <per_function_data_t &> (m_per_function_data).get (fun))\n+\t= const_cast <per_function_data_t &> (m_per_function_data).get (fun))\n     return *slot;\n \n   return NULL;\n@@ -3537,7 +3538,7 @@ state_change_requires_new_enode_p (const program_state &old_state,\n   return false;\n }\n \n-/* Create enodes and eedges for the function calls that doesn't have an \n+/* Create enodes and eedges for the function calls that doesn't have an\n    underlying call superedge.\n \n    Such case occurs when GCC's middle end didn't know which function to\n@@ -3548,12 +3549,12 @@ state_change_requires_new_enode_p (const program_state &old_state,\n \n bool\n exploded_graph::maybe_create_dynamic_call (const gcall *call,\n-                                           tree fn_decl,\n-                                           exploded_node *node,\n-                                           program_state next_state,\n-                                           program_point &next_point,\n-                                           uncertainty_t *uncertainty,\n-                                           logger *logger)\n+\t\t\t\t\t   tree fn_decl,\n+\t\t\t\t\t   exploded_node *node,\n+\t\t\t\t\t   program_state next_state,\n+\t\t\t\t\t   program_point &next_point,\n+\t\t\t\t\t   uncertainty_t *uncertainty,\n+\t\t\t\t\t   logger *logger)\n {\n   LOG_FUNC (logger);\n \n@@ -3566,44 +3567,44 @@ exploded_graph::maybe_create_dynamic_call (const gcall *call,\n       supernode *sn_exit = sg.get_node_for_function_exit (fun);\n \n       program_point new_point\n-        = program_point::before_supernode (sn_entry,\n-                                           NULL,\n-                                           this_point->get_call_string ());\n+\t= program_point::before_supernode (sn_entry,\n+\t\t\t\t\t   NULL,\n+\t\t\t\t\t   this_point->get_call_string ());\n \n       new_point.push_to_call_stack (sn_exit,\n-                                    next_point.get_supernode());\n+\t\t\t\t    next_point.get_supernode());\n \n       /* Impose a maximum recursion depth and don't analyze paths\n-         that exceed it further.\n-         This is something of a blunt workaround, but it only\n-         applies to recursion (and mutual recursion), not to\n-         general call stacks.  */\n+\t that exceed it further.\n+\t This is something of a blunt workaround, but it only\n+\t applies to recursion (and mutual recursion), not to\n+\t general call stacks.  */\n       if (new_point.get_call_string ().calc_recursion_depth ()\n-          > param_analyzer_max_recursion_depth)\n+\t  > param_analyzer_max_recursion_depth)\n       {\n-        if (logger)\n-          logger->log (\"rejecting call edge: recursion limit exceeded\");\n-        return false;\n+\tif (logger)\n+\t  logger->log (\"rejecting call edge: recursion limit exceeded\");\n+\treturn false;\n       }\n \n       next_state.push_call (*this, node, call, uncertainty);\n \n       if (next_state.m_valid)\n-        {\n-          if (logger)\n-            logger->log (\"Discovered call to %s [SN: %i -> SN: %i]\",\n-                          function_name(fun),\n-                          this_point->get_supernode ()->m_index,\n-                          sn_entry->m_index);\n-\n-          exploded_node *enode = get_or_create_node (new_point,\n-                                                     next_state,\n-                                                     node);\n-          if (enode)\n-            add_edge (node,enode, NULL,\n-                      new dynamic_call_info_t (call));\n-          return true;\n-        }\n+\t{\n+\t  if (logger)\n+\t    logger->log (\"Discovered call to %s [SN: %i -> SN: %i]\",\n+\t\t\t function_name(fun),\n+\t\t\t this_point->get_supernode ()->m_index,\n+\t\t\t sn_entry->m_index);\n+\n+\t  exploded_node *enode = get_or_create_node (new_point,\n+\t\t\t\t\t\t     next_state,\n+\t\t\t\t\t\t     node);\n+\t  if (enode)\n+\t    add_edge (node,enode, NULL,\n+\t\t      new dynamic_call_info_t (call));\n+\t  return true;\n+\t}\n     }\n   return false;\n }\n@@ -3933,8 +3934,8 @@ exploded_graph::process_node (exploded_node *node)\n       break;\n     case PK_AFTER_SUPERNODE:\n       {\n-        bool found_a_superedge = false;\n-        bool is_an_exit_block = false;\n+\tbool found_a_superedge = false;\n+\tbool is_an_exit_block = false;\n \t/* If this is an EXIT BB, detect leaks, and potentially\n \t   create a function summary.  */\n \tif (point.get_supernode ()->return_p ())\n@@ -3978,54 +3979,54 @@ exploded_graph::process_node (exploded_node *node)\n \t    program_state next_state (state);\n \t    uncertainty_t uncertainty;\n \n-            /* Make use the current state and try to discover and analyse\n-               indirect function calls (a call that doesn't have an underlying\n-               cgraph edge representing call).\n-\n-               Some examples of such calls are virtual function calls\n-               and calls that happen via a function pointer.  */\n-            if (succ->m_kind == SUPEREDGE_INTRAPROCEDURAL_CALL\n-            \t&& !(succ->get_any_callgraph_edge ()))\n-              {\n-                const gcall *call\n-                  = point.get_supernode ()->get_final_call ();\n-\n-                impl_region_model_context ctxt (*this,\n-                                                node,\n-                                                &state,\n-                                                &next_state,\n-                                                &uncertainty,\n+\t    /* Make use the current state and try to discover and analyse\n+\t       indirect function calls (a call that doesn't have an underlying\n+\t       cgraph edge representing call).\n+\n+\t       Some examples of such calls are virtual function calls\n+\t       and calls that happen via a function pointer.  */\n+\t    if (succ->m_kind == SUPEREDGE_INTRAPROCEDURAL_CALL\n+\t\t&& !(succ->get_any_callgraph_edge ()))\n+\t      {\n+\t\tconst gcall *call\n+\t\t  = point.get_supernode ()->get_final_call ();\n+\n+\t\timpl_region_model_context ctxt (*this,\n+\t\t\t\t\t\tnode,\n+\t\t\t\t\t\t&state,\n+\t\t\t\t\t\t&next_state,\n+\t\t\t\t\t\t&uncertainty,\n \t\t\t\t\t\tNULL,\n-                                                point.get_stmt());\n-\n-                region_model *model = state.m_region_model;\n-                bool call_discovered = false;\n-\n-                if (tree fn_decl = model->get_fndecl_for_call(call,&ctxt))\n-                  call_discovered = maybe_create_dynamic_call (call,\n-                                                               fn_decl,\n-                                                               node,\n-                                                               next_state,\n-                                                               next_point,\n-                                                               &uncertainty,\n-                                                               logger);\n-                if (!call_discovered)\n-                  {\n-                     /* An unknown function or a special function was called \n-                        at this point, in such case, don't terminate the \n-                        analysis of the current function.\n-\n-                        The analyzer handles calls to such functions while\n-                        analysing the stmt itself, so the function call\n-                        must have been handled by the anlyzer till now.  */\n-                     exploded_node *next\n-                       = get_or_create_node (next_point,\n-                                             next_state,\n-                                             node);\n-                     if (next)\n-                       add_edge (node, next, succ);\n-                  }\n-              }\n+\t\t\t\t\t\tpoint.get_stmt());\n+\n+\t\tregion_model *model = state.m_region_model;\n+\t\tbool call_discovered = false;\n+\n+\t\tif (tree fn_decl = model->get_fndecl_for_call (call, &ctxt))\n+\t\t  call_discovered = maybe_create_dynamic_call (call,\n+\t\t\t\t\t\t\t       fn_decl,\n+\t\t\t\t\t\t\t       node,\n+\t\t\t\t\t\t\t       next_state,\n+\t\t\t\t\t\t\t       next_point,\n+\t\t\t\t\t\t\t       &uncertainty,\n+\t\t\t\t\t\t\t       logger);\n+\t\tif (!call_discovered)\n+\t\t  {\n+\t\t    /* An unknown function or a special function was called\n+\t\t       at this point, in such case, don't terminate the\n+\t\t       analysis of the current function.\n+\n+\t\t       The analyzer handles calls to such functions while\n+\t\t       analysing the stmt itself, so the function call\n+\t\t       must have been handled by the anlyzer till now.  */\n+\t\t    exploded_node *next\n+\t\t      = get_or_create_node (next_point,\n+\t\t\t\t\t    next_state,\n+\t\t\t\t\t    node);\n+\t\t    if (next)\n+\t\t      add_edge (node, next, succ);\n+\t\t  }\n+\t      }\n \n \t    if (!node->on_edge (*this, succ, &next_point, &next_state,\n \t\t\t\t&uncertainty))\n@@ -4041,37 +4042,37 @@ exploded_graph::process_node (exploded_node *node)\n \t      add_edge (node, next, succ);\n \t  }\n \n-        /* Return from the calls which doesn't have a return superedge.\n-    \t   Such case occurs when GCC's middle end didn't knew which function to\n-    \t   call but analyzer did.  */\n-        if((is_an_exit_block && !found_a_superedge)\n-           && (!point.get_call_string ().empty_p ()))\n-          {\n-            const call_string cs = point.get_call_string ();\n-            program_point next_point\n-              = program_point::before_supernode (cs.get_caller_node (),\n-                                                 NULL,\n-                                                 cs);\n-            program_state next_state (state);\n-            uncertainty_t uncertainty;\n-\n-            const gcall *call\n-              = next_point.get_supernode ()->get_returning_call ();\n-\n-            if(call)\n-              next_state.returning_call (*this, node, call, &uncertainty);\n-\n-            if (next_state.m_valid)\n-              {\n-                next_point.pop_from_call_stack ();\n-                exploded_node *enode = get_or_create_node (next_point,\n-                                                           next_state,\n-                                                           node);\n-                if (enode)\n-                  add_edge (node, enode, NULL,\n-                            new dynamic_call_info_t (call, true));\n-              }\n-          }\n+\t/* Return from the calls which doesn't have a return superedge.\n+\t   Such case occurs when GCC's middle end didn't knew which function to\n+\t   call but analyzer did.  */\n+\tif ((is_an_exit_block && !found_a_superedge)\n+\t    && (!point.get_call_string ().empty_p ()))\n+\t  {\n+\t    const call_string cs = point.get_call_string ();\n+\t    program_point next_point\n+\t      = program_point::before_supernode (cs.get_caller_node (),\n+\t\t\t\t\t\t NULL,\n+\t\t\t\t\t\t cs);\n+\t    program_state next_state (state);\n+\t    uncertainty_t uncertainty;\n+\n+\t    const gcall *call\n+\t      = next_point.get_supernode ()->get_returning_call ();\n+\n+\t    if (call)\n+\t      next_state.returning_call (*this, node, call, &uncertainty);\n+\n+\t    if (next_state.m_valid)\n+\t      {\n+\t\tnext_point.pop_from_call_stack ();\n+\t\texploded_node *enode = get_or_create_node (next_point,\n+\t\t\t\t\t\t\t   next_state,\n+\t\t\t\t\t\t\t   node);\n+\t\tif (enode)\n+\t\t  add_edge (node, enode, NULL,\n+\t\t\t    new dynamic_call_info_t (call, true));\n+\t      }\n+\t  }\n       }\n       break;\n     }"}]}