{"sha": "30d69925b65208f1de5af08fd05918ad0b6c805c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzBkNjk5MjViNjUyMDhmMWRlNWFmMDhmZDA1OTE4YWQwYjZjODA1Yw==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-25T02:24:39Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-12-25T02:24:39Z"}, "message": "(simplify_binary_operation, case PLUS, MINUS):\n\nSimplify such things as (X >> 1) - X.\n\nFrom-SVN: r6308", "tree": {"sha": "11fd584dd2aeb54d5f0eea97a64cd6dbed7eebfd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/11fd584dd2aeb54d5f0eea97a64cd6dbed7eebfd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/30d69925b65208f1de5af08fd05918ad0b6c805c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d69925b65208f1de5af08fd05918ad0b6c805c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/30d69925b65208f1de5af08fd05918ad0b6c805c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/30d69925b65208f1de5af08fd05918ad0b6c805c/comments", "author": null, "committer": null, "parents": [{"sha": "6e7f952e96c08b97602e80d0961265090c707242", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6e7f952e96c08b97602e80d0961265090c707242", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6e7f952e96c08b97602e80d0961265090c707242"}], "stats": {"total": 108, "additions": 108, "deletions": 0}, "files": [{"sha": "b863e947041305f50d59a29d9403e76e3f18b859", "filename": "gcc/cse.c", "status": "modified", "additions": 108, "deletions": 0, "changes": 108, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/30d69925b65208f1de5af08fd05918ad0b6c805c/gcc%2Fcse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/30d69925b65208f1de5af08fd05918ad0b6c805c/gcc%2Fcse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcse.c?ref=30d69925b65208f1de5af08fd05918ad0b6c805c", "patch": "@@ -3477,6 +3477,60 @@ simplify_binary_operation (code, mode, op0, op1)\n \t\t   && GET_CODE (op0) == CONST_INT)\n \t    return plus_constant (op1, INTVAL (op0));\n \n+\t  /* See if this is something like X * C - X or vice versa or\n+\t     if the multiplication is written as a shift.  If so, we can\n+\t     distribute and make a new multiply, shift, or maybe just\n+\t     have X (if C is 2 in the example above).  But don't make\n+\t     real multiply if we didn't have one before.  */\n+\n+\t  if (! FLOAT_MODE_P (mode))\n+\t    {\n+\t      HOST_WIDE_INT coeff0 = 1, coeff1 = 1;\n+\t      rtx lhs = op0, rhs = op1;\n+\t      int had_mult = 0;\n+\n+\t      if (GET_CODE (lhs) == NEG)\n+\t\tcoeff0 = -1, lhs = XEXP (lhs, 0);\n+\t      else if (GET_CODE (lhs) == MULT\n+\t\t       && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n+\t\t{\n+\t\t  coeff0 = INTVAL (XEXP (lhs, 1)), lhs = XEXP (lhs, 0);\n+\t\t  had_mult = 1;\n+\t\t}\n+\t      else if (GET_CODE (lhs) == ASHIFT\n+\t\t       && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t\t       && INTVAL (XEXP (lhs, 1)) >= 0\n+\t\t       && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  coeff0 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t\t  lhs = XEXP (lhs, 0);\n+\t\t}\n+\n+\t      if (GET_CODE (rhs) == NEG)\n+\t\tcoeff1 = -1, rhs = XEXP (rhs, 0);\n+\t      else if (GET_CODE (rhs) == MULT\n+\t\t       && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n+\t\t{\n+\t\t  coeff1 = INTVAL (XEXP (rhs, 1)), rhs = XEXP (rhs, 0);\n+\t\t  had_mult = 1;\n+\t\t}\n+\t      else if (GET_CODE (rhs) == ASHIFT\n+\t\t       && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+\t\t       && INTVAL (XEXP (rhs, 1)) >= 0\n+\t\t       && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  coeff1 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n+\t\t  rhs = XEXP (rhs, 0);\n+\t\t}\n+\n+\t      if (rtx_equal_p (lhs, rhs))\n+\t\t{\n+\t\t  tem = cse_gen_binary (MULT, mode, lhs,\n+\t\t\t\t\tGEN_INT (coeff0 + coeff1));\n+\t\t  return (GET_CODE (tem) == MULT && ! had_mult) ? 0 : tem;\n+\t\t}\n+\t    }\n+\n \t  /* If one of the operands is a PLUS or a MINUS, see if we can\n \t     simplify this by the associative law. \n \t     Don't use the associative law for floating point.\n@@ -3532,6 +3586,60 @@ simplify_binary_operation (code, mode, op0, op1)\n \t  if (op1 == CONST0_RTX (mode))\n \t    return op0;\n \n+\t  /* See if this is something like X * C - X or vice versa or\n+\t     if the multiplication is written as a shift.  If so, we can\n+\t     distribute and make a new multiply, shift, or maybe just\n+\t     have X (if C is 2 in the example above).  But don't make\n+\t     real multiply if we didn't have one before.  */\n+\n+\t  if (! FLOAT_MODE_P (mode))\n+\t    {\n+\t      HOST_WIDE_INT coeff0 = 1, coeff1 = 1;\n+\t      rtx lhs = op0, rhs = op1;\n+\t      int had_mult = 0;\n+\n+\t      if (GET_CODE (lhs) == NEG)\n+\t\tcoeff0 = -1, lhs = XEXP (lhs, 0);\n+\t      else if (GET_CODE (lhs) == MULT\n+\t\t       && GET_CODE (XEXP (lhs, 1)) == CONST_INT)\n+\t\t{\n+\t\t  coeff0 = INTVAL (XEXP (lhs, 1)), lhs = XEXP (lhs, 0);\n+\t\t  had_mult = 1;\n+\t\t}\n+\t      else if (GET_CODE (lhs) == ASHIFT\n+\t\t       && GET_CODE (XEXP (lhs, 1)) == CONST_INT\n+\t\t       && INTVAL (XEXP (lhs, 1)) >= 0\n+\t\t       && INTVAL (XEXP (lhs, 1)) < HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  coeff0 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (lhs, 1));\n+\t\t  lhs = XEXP (lhs, 0);\n+\t\t}\n+\n+\t      if (GET_CODE (rhs) == NEG)\n+\t\tcoeff1 = - 1, rhs = XEXP (rhs, 0);\n+\t      else if (GET_CODE (rhs) == MULT\n+\t\t       && GET_CODE (XEXP (rhs, 1)) == CONST_INT)\n+\t\t{\n+\t\t  coeff1 = INTVAL (XEXP (rhs, 1)), rhs = XEXP (rhs, 0);\n+\t\t  had_mult = 1;\n+\t\t}\n+\t      else if (GET_CODE (rhs) == ASHIFT\n+\t\t       && GET_CODE (XEXP (rhs, 1)) == CONST_INT\n+\t\t       && INTVAL (XEXP (rhs, 1)) >= 0\n+\t\t       && INTVAL (XEXP (rhs, 1)) < HOST_BITS_PER_WIDE_INT)\n+\t\t{\n+\t\t  coeff1 = ((HOST_WIDE_INT) 1) << INTVAL (XEXP (rhs, 1));\n+\t\t  rhs = XEXP (rhs, 0);\n+\t\t}\n+\n+\t      if (rtx_equal_p (lhs, rhs))\n+\t\t{\n+\t\t  tem = cse_gen_binary (MULT, mode, lhs,\n+\t\t\t\t\tGEN_INT (coeff0 - coeff1));\n+\t\t  return (GET_CODE (tem) == MULT && ! had_mult) ? 0 : tem;\n+\t\t}\n+\t    }\n+\n \t  /* (a - (-b)) -> (a + b).  */\n \t  if (GET_CODE (op1) == NEG)\n \t    return cse_gen_binary (PLUS, mode, op0, XEXP (op1, 0));"}]}