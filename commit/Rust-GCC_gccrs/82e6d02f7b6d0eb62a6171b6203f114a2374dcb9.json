{"sha": "82e6d02f7b6d0eb62a6171b6203f114a2374dcb9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ODJlNmQwMmY3YjZkMGViNjJhNjE3MWI2MjAzZjExNGEyMzc0ZGNiOQ==", "commit": {"author": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-15T14:00:22Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2008-05-15T14:00:22Z"}, "message": "statistics.c: New file.\n\n2008-05-15  Richard Guenther  <rguenther@suse.de>\n\n        * statistics.c: New file.\n\nFrom-SVN: r135359", "tree": {"sha": "2fe188cd57d9dde5aef010ffd919f676883da48b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2fe188cd57d9dde5aef010ffd919f676883da48b"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9/comments", "author": null, "committer": null, "parents": [{"sha": "9fe0cb7d88323ad1be17248b06fd6b071c0a8552", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9fe0cb7d88323ad1be17248b06fd6b071c0a8552", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9fe0cb7d88323ad1be17248b06fd6b071c0a8552"}], "stats": {"total": 342, "additions": 342, "deletions": 0}, "files": [{"sha": "1f0090c7e7b1ac0f56a0f748934cf63f6042639d", "filename": "gcc/statistics.c", "status": "added", "additions": 342, "deletions": 0, "changes": 342, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9/gcc%2Fstatistics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/82e6d02f7b6d0eb62a6171b6203f114a2374dcb9/gcc%2Fstatistics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstatistics.c?ref=82e6d02f7b6d0eb62a6171b6203f114a2374dcb9", "patch": "@@ -0,0 +1,342 @@\n+/* Optimization statistics functions.\n+   Copyright (C) 2008\n+   Free Software Foundation, Inc.\n+   Contributed by Richard Guenther  <rguenther@suse.de>\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tree-pass.h\"\n+#include \"tree-dump.h\"\n+#include \"statistics.h\"\n+#include \"hashtab.h\"\n+#include \"tm.h\"\n+#include \"function.h\"\n+\n+static int statistics_dump_nr;\n+static int statistics_dump_flags;\n+static FILE *statistics_dump_file;\n+\n+/* Statistics entry.  A integer counter associated to a string ID\n+   and value.  */\n+\n+typedef struct statistics_counter_s {\n+  const char *id;\n+  int val;\n+  bool histogram_p;\n+  unsigned HOST_WIDE_INT count;\n+  unsigned HOST_WIDE_INT prev_dumped_count;\n+} statistics_counter_t;\n+\n+/* Array of statistic hashes, indexed by pass id.  */\n+static htab_t *statistics_hashes;\n+static unsigned nr_statistics_hashes;\n+\n+/* Hash a statistic counter by its string ID.  */\n+\n+static hashval_t\n+hash_statistics_hash (const void *p)\n+{\n+  statistics_counter_t *c = (statistics_counter_t *)p;\n+  return htab_hash_string (c->id) + c->val;\n+}\n+\n+/* Compare two statistic counters by their string IDs.  */\n+\n+static int\n+hash_statistics_eq (const void *p, const void *q)\n+{\n+  statistics_counter_t *c1 = (statistics_counter_t *)p;\n+  statistics_counter_t *c2 = (statistics_counter_t *)q;\n+  return c1->val == c2->val && strcmp (c1->id, c2->id) == 0;\n+}\n+\n+/* Free a statistics entry.  */\n+\n+static void\n+hash_statistics_free (void *p)\n+{\n+  free ((void *)((statistics_counter_t *)p)->id);\n+  free (p);\n+}\n+\n+/* Return the current hashtable to be used for recording or printing\n+   statistics.  */\n+\n+static htab_t\n+curr_statistics_hash (void)\n+{\n+  unsigned idx = current_pass->static_pass_number;\n+\n+  if (idx < nr_statistics_hashes\n+      && statistics_hashes[idx] != NULL)\n+    return statistics_hashes[idx];\n+\n+  if (idx >= nr_statistics_hashes)\n+    {\n+      statistics_hashes = xrealloc (statistics_hashes,\n+\t\t\t\t    (idx + 1) * sizeof (htab_t));\n+      memset (statistics_hashes + nr_statistics_hashes, 0,\n+\t      (idx + 1 - nr_statistics_hashes) * sizeof (htab_t));\n+      nr_statistics_hashes = idx + 1;\n+    }\n+\n+  statistics_hashes[idx] = htab_create (15, hash_statistics_hash,\n+\t\t\t\t\thash_statistics_eq,\n+\t\t\t\t\thash_statistics_free);\n+\n+  return statistics_hashes[idx];\n+}\n+\n+/* Helper for statistics_fini_pass.  Print the counter difference\n+   since the last dump for the pass dump files.  */\n+\n+static int\n+statistics_fini_pass_1 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  unsigned HOST_WIDE_INT count = counter->count - counter->prev_dumped_count;\n+  if (count == 0)\n+    return 1;\n+  if (counter->histogram_p)\n+    fprintf (dump_file, \"%s == %d: \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     counter->id, counter->val, count);\n+  else\n+    fprintf (dump_file, \"%s: \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     counter->id, count);\n+  counter->prev_dumped_count = counter->count;\n+  return 1;\n+}\n+\n+/* Helper for statistics_fini_pass.  Print the counter difference\n+   since the last dump for the statistics dump.  */\n+\n+static int\n+statistics_fini_pass_2 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  unsigned HOST_WIDE_INT count = counter->count - counter->prev_dumped_count;\n+  if (count == 0)\n+    return 1;\n+  counter->prev_dumped_count = counter->count;\n+  if (counter->histogram_p)\n+    fprintf (statistics_dump_file,\n+\t     \"%d %s \\\"%s == %d\\\" \\\"%s\\\" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     current_pass->static_pass_number,\n+\t     current_pass->name,\n+\t     counter->id, counter->val,\n+\t     cfun ? IDENTIFIER_POINTER (DECL_NAME (cfun->decl)) : \"(nofn)\",\n+\t     count);\n+  else\n+    fprintf (statistics_dump_file,\n+\t     \"%d %s \\\"%s\\\" \\\"%s\\\" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     current_pass->static_pass_number,\n+\t     current_pass->name,\n+\t     counter->id,\n+\t     cfun ? IDENTIFIER_POINTER (DECL_NAME (cfun->decl)) : \"(nofn)\",\n+\t     count);\n+  counter->prev_dumped_count = counter->count;\n+  return 1;\n+}\n+\n+/* Helper for statistics_fini_pass, reset the counters.  */\n+\n+static int\n+statistics_fini_pass_3 (void **slot, void *data ATTRIBUTE_UNUSED)\n+{\n+  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  counter->prev_dumped_count = counter->count;\n+  return 1;\n+}\n+\n+/* Dump the current statistics incrementally.  */\n+\n+void\n+statistics_fini_pass (void)\n+{\n+  if (current_pass->static_pass_number == -1)\n+    return;\n+\n+  if (dump_file\n+      && dump_flags & TDF_STATS)\n+    {\n+      fprintf (dump_file, \"\\n\");\n+      fprintf (dump_file, \"Pass statistics:\\n\");\n+      fprintf (dump_file, \"----------------\\n\");\n+      htab_traverse_noresize (curr_statistics_hash (),\n+\t\t\t      statistics_fini_pass_1, NULL);\n+      fprintf (dump_file, \"\\n\");\n+    }\n+  if (statistics_dump_file\n+      && !(statistics_dump_flags & TDF_STATS\n+\t   || statistics_dump_flags & TDF_DETAILS))\n+    htab_traverse_noresize (curr_statistics_hash (),\n+\t\t\t    statistics_fini_pass_2, NULL);\n+  htab_traverse_noresize (curr_statistics_hash (),\n+\t\t\t  statistics_fini_pass_3, NULL);\n+}\n+\n+/* Helper for printing summary information.  */\n+\n+static int\n+statistics_fini_1 (void **slot, void *data)\n+{\n+  struct opt_pass *pass = (struct opt_pass *)data;\n+  statistics_counter_t *counter = (statistics_counter_t *)*slot;\n+  if (counter->count == 0)\n+    return 1;\n+  if (counter->histogram_p)\n+    fprintf (statistics_dump_file,\n+\t     \"%d %s \\\"%s == %d\\\" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     pass->static_pass_number,\n+\t     pass->name,\n+\t     counter->id, counter->val,\n+\t     counter->count);\n+  else\n+    fprintf (statistics_dump_file,\n+\t     \"%d %s \\\"%s\\\" \" HOST_WIDE_INT_PRINT_DEC \"\\n\",\n+\t     pass->static_pass_number,\n+\t     pass->name,\n+\t     counter->id,\n+\t     counter->count);\n+  return 1;\n+}\n+\n+/* Finish the statistics and dump summary information.  */\n+\n+void\n+statistics_fini (void)\n+{\n+  if (!statistics_dump_file)\n+    return;\n+\n+  if (statistics_dump_flags & TDF_STATS)\n+    {\n+      unsigned i;\n+      for (i = 0; i < nr_statistics_hashes; ++i)\n+\tif (statistics_hashes[i] != NULL\n+\t    && get_pass_for_id (i) != NULL)\n+\t  htab_traverse_noresize (statistics_hashes[i],\n+\t\t\t\t  statistics_fini_1, get_pass_for_id (i));\n+    }\n+\n+  dump_end (statistics_dump_nr, statistics_dump_file);\n+}\n+\n+/* Register the statistics dump file.  */\n+\n+void\n+statistics_early_init (void)\n+{\n+  statistics_dump_nr = dump_register (\".statistics\", \"statistics\",\n+\t\t\t\t      \"statistics\", TDF_TREE);\n+}\n+\n+/* Init the statistics.  */\n+\n+void\n+statistics_init (void)\n+{\n+  statistics_dump_file = dump_begin (statistics_dump_nr, NULL);\n+  statistics_dump_flags = get_dump_file_info (statistics_dump_nr)->flags;\n+}\n+\n+/* Lookup or add a statistics counter in the hashtable HASH with ID, VAL\n+   and HISTOGRAM_P.  */\n+\n+static statistics_counter_t *\n+lookup_or_add_counter (htab_t hash, const char *id, int val,\n+\t\t       bool histogram_p)\n+{\n+  statistics_counter_t **counter;\n+  statistics_counter_t c;\n+  c.id = id;\n+  c.val = val;\n+  counter = (statistics_counter_t **) htab_find_slot (hash, &c, INSERT);\n+  if (!*counter)\n+    {\n+      *counter = XNEW (struct statistics_counter_s);\n+      (*counter)->id = xstrdup (id);\n+      (*counter)->val = val;\n+      (*counter)->histogram_p = histogram_p;\n+      (*counter)->prev_dumped_count = 0;\n+      (*counter)->count = 0;\n+    }\n+  return *counter;\n+}\n+\n+/* Add statistics information about event ID in function FN.\n+   This will increment the counter associated with ID by INCR.\n+   It will also dump the event to the global statistics file if requested.  */\n+\n+void\n+statistics_counter_event (struct function *fn, const char *id, int incr)\n+{\n+  statistics_counter_t *counter;\n+\n+  if ((!(dump_flags & TDF_STATS)\n+       && !statistics_dump_file)\n+      || incr == 0)\n+    return;\n+\n+  counter = lookup_or_add_counter (curr_statistics_hash (), id, 0, false);\n+  gcc_assert (!counter->histogram_p);\n+  counter->count += incr;\n+\n+  if (!statistics_dump_file\n+      || !(statistics_dump_flags & TDF_DETAILS))\n+    return;\n+\n+  fprintf (statistics_dump_file,\n+\t   \"%d %s \\\"%s\\\" \\\"%s\\\" %d\\n\",\n+\t   current_pass->static_pass_number,\n+\t   current_pass->name,\n+\t   id,\n+\t   fn ? IDENTIFIER_POINTER (DECL_NAME (fn->decl)) : \"(nofn)\",\n+\t   incr);\n+}\n+\n+/* Add statistics information about event ID in function FN with the\n+   histogram value VAL.\n+   It will dump the event to the global statistics file if requested.  */\n+\n+void\n+statistics_histogram_event (struct function *fn, const char *id, int val)\n+{\n+  statistics_counter_t *counter;\n+\n+  if (!(dump_flags & TDF_STATS)\n+      && !statistics_dump_file)\n+    return;\n+\n+  counter = lookup_or_add_counter (curr_statistics_hash (), id, val, true);\n+  gcc_assert (counter->histogram_p);\n+  counter->count += 1;\n+\n+  if (!statistics_dump_file\n+      || !(statistics_dump_flags & TDF_DETAILS))\n+    return;\n+\n+  fprintf (statistics_dump_file,\n+\t   \"%d %s \\\"%s == %d\\\" \\\"%s\\\" 1\\n\",\n+\t   current_pass->static_pass_number,\n+\t   current_pass->name,\n+\t   id, val,\n+\t   fn ? IDENTIFIER_POINTER (DECL_NAME (fn->decl)) : \"(nofn)\");\n+}"}]}