{"sha": "374caa503bcf9605a85f8b68c79ca2d918c96fb0", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6Mzc0Y2FhNTAzYmNmOTYwNWE4NWY4YjY4Yzc5Y2EyZDkxOGM5NmZiMA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@wasabisystems.com", "date": "2003-12-15T14:37:25Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2003-12-15T14:37:25Z"}, "message": "Fix handling of constructor/destructor of standard substitution:\n\n\t* cp-demangle.c (struct d_standard_sub_info): Define.\n\t(d_substitution): Add prefix argument.  Change all callers.\n\tRework handling of standard substitutions to print full name when\n\tqualifying a constructor/destructor, or when DMGL_VERBOSE is set.\n\t* testsuite/demangle-expected: Add test case.\n\n\tFix handling of negative literal constants:\n\t* cp-demangle.c (enum d_comp_type): Add D_COMP_LITERAL_NEG.\n\t(d_dump, d_make_comp): Handle D_COMP_LITERAL_NEG.\n\t(d_expr_primary): Use D_COMP_LITERAL_NEG for a negative number.\n\t(d_print_comp): Handle D_COMP_LITERAL_NEG.\n\t* testsuite/demangle-expected: Add test case.\n\nFrom-SVN: r74632", "tree": {"sha": "ceddf800710ca602c6497bf9eb391a6baf0c777f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ceddf800710ca602c6497bf9eb391a6baf0c777f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/374caa503bcf9605a85f8b68c79ca2d918c96fb0", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374caa503bcf9605a85f8b68c79ca2d918c96fb0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/374caa503bcf9605a85f8b68c79ca2d918c96fb0", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/374caa503bcf9605a85f8b68c79ca2d918c96fb0/comments", "author": null, "committer": null, "parents": [{"sha": "58cd2515ae19e8aac09b3615b0a105e055bb4081", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58cd2515ae19e8aac09b3615b0a105e055bb4081", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58cd2515ae19e8aac09b3615b0a105e055bb4081"}], "stats": {"total": 162, "additions": 129, "deletions": 33}, "files": [{"sha": "a2a430e39927bdc8b5ef87540892df96e0bdd5c8", "filename": "libiberty/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2FChangeLog?ref=374caa503bcf9605a85f8b68c79ca2d918c96fb0", "patch": "@@ -1,3 +1,19 @@\n+2003-12-15  Ian Lance Taylor  <ian@wasabisystems.com>\n+\n+\tFix handling of constructor/destructor of standard substitution:\n+\t* cp-demangle.c (struct d_standard_sub_info): Define.\n+\t(d_substitution): Add prefix argument.  Change all callers.\n+\tRework handling of standard substitutions to print full name when\n+\tqualifying a constructor/destructor, or when DMGL_VERBOSE is set.\n+\t* testsuite/demangle-expected: Add test case.\n+\n+\tFix handling of negative literal constants:\n+\t* cp-demangle.c (enum d_comp_type): Add D_COMP_LITERAL_NEG.\n+\t(d_dump, d_make_comp): Handle D_COMP_LITERAL_NEG.\n+\t(d_expr_primary): Use D_COMP_LITERAL_NEG for a negative number.\n+\t(d_print_comp): Handle D_COMP_LITERAL_NEG.\n+\t* testsuite/demangle-expected: Add test case.\n+\n 2003-12-04  Ian Lance Taylor  <ian@wasabisystems.com>\n \n \t* cp-demangle.c (IS_UPPER, IS_LOWER): Define."}, {"sha": "e675752bbaacfaffc7a4fd833a89f8b846503f9d", "filename": "libiberty/cp-demangle.c", "status": "modified", "additions": 102, "deletions": 32, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2Fcp-demangle.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2Fcp-demangle.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Fcp-demangle.c?ref=374caa503bcf9605a85f8b68c79ca2d918c96fb0", "patch": "@@ -141,6 +141,23 @@ struct d_builtin_type_info\n   enum d_builtin_type_print print;\n };\n \n+/* Information we keep for the standard substitutions.  */\n+\n+struct d_standard_sub_info\n+{\n+  /* The code for this substitution.  */\n+  char code;\n+  /* The simple string it expands to.  */\n+  const char *simple_expansion;\n+  /* The results of a full, verbose, expansion.  This is used when\n+     qualifying a constructor/destructor, or when in verbose mode.  */\n+  const char *full_expansion;\n+  /* What to set the last_name field of d_info to; NULL if we should\n+     not set it.  This is only relevant when qualifying a\n+     constructor/destructor.  */\n+  const char *set_last_name;\n+};\n+\n /* Component types found in mangled names.  */\n \n enum d_comp_type\n@@ -239,7 +256,9 @@ enum d_comp_type\n   D_COMP_TRINARY_ARG1,\n   D_COMP_TRINARY_ARG2,\n   /* A literal.  */\n-  D_COMP_LITERAL\n+  D_COMP_LITERAL,\n+  /* A negative literal.  */\n+  D_COMP_LITERAL_NEG\n };\n \n /* A component of the mangled name.  */\n@@ -489,7 +508,7 @@ static struct d_comp *d_expr_primary PARAMS ((struct d_info *));\n static struct d_comp *d_local_name PARAMS ((struct d_info *));\n static int d_discriminator PARAMS ((struct d_info *));\n static int d_add_substitution PARAMS ((struct d_info *, struct d_comp *));\n-static struct d_comp *d_substitution PARAMS ((struct d_info *));\n+static struct d_comp *d_substitution PARAMS ((struct d_info *, int));\n static void d_print_resize PARAMS ((struct d_print_info *, size_t));\n static void d_print_append_char PARAMS ((struct d_print_info *, int));\n static void d_print_append_buffer PARAMS ((struct d_print_info *, const char *,\n@@ -683,6 +702,9 @@ d_dump (dc, indent)\n     case D_COMP_LITERAL:\n       printf (\"literal\\n\");\n       break;\n+    case D_COMP_LITERAL_NEG:\n+      printf (\"negative literal\\n\");\n+      break;\n     }\n \n   d_dump (d_left (dc), indent + 2);\n@@ -737,6 +759,7 @@ d_make_comp (di, type, left, right)\n     case D_COMP_TRINARY_ARG1:\n     case D_COMP_TRINARY_ARG2:\n     case D_COMP_LITERAL:\n+    case D_COMP_LITERAL_NEG:\n       if (left == NULL || right == NULL)\n \treturn NULL;\n       break;\n@@ -1087,7 +1110,7 @@ d_name (di)\n \n \tif (d_peek_next_char (di) != 't')\n \t  {\n-\t    dc = d_substitution (di);\n+\t    dc = d_substitution (di, 0);\n \t    subst = 1;\n \t  }\n \telse\n@@ -1202,7 +1225,7 @@ d_prefix (di)\n \t  || peek == 'D')\n \tdc = d_unqualified_name (di);\n       else if (peek == 'S')\n-\tdc = d_substitution (di);\n+\tdc = d_substitution (di, 1);\n       else if (peek == 'I')\n \t{\n \t  if (ret == NULL)\n@@ -1776,7 +1799,7 @@ d_type (di)\n \t    || peek_next == '_'\n \t    || IS_UPPER (peek_next))\n \t  {\n-\t    ret = d_substitution (di);\n+\t    ret = d_substitution (di, 0);\n \t    /* The substituted name may have been a template name and\n \t       may be followed by tepmlate args.  */\n \t    if (d_peek_char (di) == 'I')\n@@ -2254,6 +2277,7 @@ d_expr_primary (di)\n   else\n     {\n       struct d_comp *type;\n+      enum d_comp_type t;\n       const char *s;\n \n       type = d_type (di);\n@@ -2269,11 +2293,16 @@ d_expr_primary (di)\n \t constant in any readable form anyhow.  We don't attempt to\n \t handle these cases.  */\n \n+      t = D_COMP_LITERAL;\n+      if (d_peek_char (di) == 'n')\n+\t{\n+\t  t = D_COMP_LITERAL_NEG;\n+\t  d_advance (di, 1);\n+\t}\n       s = d_str (di);\n       while (d_peek_char (di) != 'E')\n \td_advance (di, 1);\n-      ret = d_make_comp (di, D_COMP_LITERAL, type,\n-\t\t\t d_make_name (di, s, d_str (di) - s));\n+      ret = d_make_comp (di, t, type, d_make_name (di, s, d_str (di) - s));\n     }\n   if (d_next_char (di) != 'E')\n     return NULL;\n@@ -2363,11 +2392,39 @@ d_add_substitution (di, dc)\n                   ::= Si\n                   ::= So\n                   ::= Sd\n+\n+   If PREFIX is non-zero, then this type is being used as a prefix in\n+   a qualified name.  In this case, for the standard substitutions, we\n+   need to check whether we are being used as a prefix for a\n+   constructor or destructor, and return a full template name.\n+   Otherwise we will get something like std::iostream::~iostream()\n+   which does not correspond particularly well to any function which\n+   actually appears in the source.\n */\n \n+static const struct d_standard_sub_info standard_subs[] =\n+{\n+  { 't', \"std\", \"std\", NULL },\n+  { 'a', \"std::allocator\", \"std::allocator\", \"allocator\" },\n+  { 'b', \"std::basic_string\", \"std::basic_string\", \"basic_string\" },\n+  { 's', \"std::string\",\n+    \"std::basic_string<char, std::char_traits<char>, std::allocator<char> >\",\n+    \"basic_string\" },\n+  { 'i', \"std::istream\",\n+    \"std::basic_istream<char, std::char_traits<char> >\",\n+    \"basic_istream\" },\n+  { 'o', \"std::ostream\",\n+    \"std::basic_ostream<char, std::char_traits<char> >\",\n+    \"basic_ostream\" },\n+  { 'd', \"std::iostream\",\n+    \"std::basic_iostream<char, std::char_traits<char> >\",\n+    \"basic_iostream\" }\n+};\n+\n static struct d_comp *\n-d_substitution (di)\n+d_substitution (di, prefix)\n      struct d_info *di;\n+     int prefix;\n {\n   char c;\n \n@@ -2404,31 +2461,36 @@ d_substitution (di)\n     }\n   else\n     {\n-      switch (c)\n+      int verbose;\n+      const struct d_standard_sub_info *p;\n+      const struct d_standard_sub_info *pend;\n+\n+      verbose = (di->options & DMGL_VERBOSE) != 0;\n+      if (! verbose && prefix)\n \t{\n-\tcase 't':\n-\t  return d_make_sub (di, \"std\");\n-\tcase 'a':\n-\t  di->last_name = d_make_sub (di, \"allocator\");\n-\t  return d_make_sub (di, \"std::allocator\");\n-\tcase 'b':\n-\t  di->last_name = d_make_sub (di, \"basic_string\");\n-\t  return d_make_sub (di, \"std::basic_string\");\n-\tcase 's':\n-\t  di->last_name = d_make_sub (di, \"string\");\n-\t  return d_make_sub (di, \"std::string\");\n-\tcase 'i':\n-\t  di->last_name = d_make_sub (di, \"istream\");\n-\t  return d_make_sub (di, \"std::istream\");\n-\tcase 'o':\n-\t  di->last_name = d_make_sub (di, \"ostream\");\n-\t  return d_make_sub (di, \"std::ostream\");\n-\tcase 'd':\n-\t  di->last_name = d_make_sub (di, \"iostream\");\n-\t  return d_make_sub (di, \"std::iostream\");\n-\tdefault:\n-\t  return NULL;\n+\t  char peek;\n+\n+\t  peek = d_peek_char (di);\n+\t  if (peek == 'C' || peek == 'D')\n+\t    verbose = 1;\n \t}\n+\n+      pend = (&standard_subs[0]\n+\t      + sizeof standard_subs / sizeof standard_subs[0]);\n+      for (p = &standard_subs[0]; p < pend; ++p)\n+\t{\n+\t  if (c == p->code)\n+\t    {\n+\t      if (p->set_last_name != NULL)\n+\t\tdi->last_name = d_make_sub (di, p->set_last_name);\n+\t      if (verbose)\n+\t\treturn d_make_sub (di, p->full_expansion);\n+\t      else\n+\t\treturn d_make_sub (di, p->simple_expansion);\n+\t    }\n+\t}\n+\n+      return NULL;\n     }\n }\n \n@@ -3031,6 +3093,7 @@ d_print_comp (dpi, dc)\n       return;\n \n     case D_COMP_LITERAL:\n+    case D_COMP_LITERAL_NEG:\n       /* For some builtin types, produce simpler output.  */\n       if (d_left (dc)->type == D_COMP_BUILTIN_TYPE)\n \t{\n@@ -3039,6 +3102,8 @@ d_print_comp (dpi, dc)\n \t    case D_PRINT_INT:\n \t      if (d_right (dc)->type == D_COMP_NAME)\n \t\t{\n+\t\t  if (dc->type == D_COMP_LITERAL_NEG)\n+\t\t    d_append_char (dpi, '-');\n \t\t  d_print_comp (dpi, d_right (dc));\n \t\t  return;\n \t\t}\n@@ -3047,6 +3112,8 @@ d_print_comp (dpi, dc)\n \t    case D_PRINT_LONG:\n \t      if (d_right (dc)->type == D_COMP_NAME)\n \t\t{\n+\t\t  if (dc->type == D_COMP_LITERAL_NEG)\n+\t\t    d_append_char (dpi, '-');\n \t\t  d_print_comp (dpi, d_right (dc));\n \t\t  d_append_char (dpi, 'l');\n \t\t  return;\n@@ -3055,7 +3122,8 @@ d_print_comp (dpi, dc)\n \n \t    case D_PRINT_BOOL:\n \t      if (d_right (dc)->type == D_COMP_NAME\n-\t\t  && d_right (dc)->u.s_name.len == 1)\n+\t\t  && d_right (dc)->u.s_name.len == 1\n+\t\t  && dc->type == D_COMP_LITERAL)\n \t\t{\n \t\t  switch (d_right (dc)->u.s_name.s[0])\n \t\t    {\n@@ -3079,6 +3147,8 @@ d_print_comp (dpi, dc)\n       d_append_char (dpi, '(');\n       d_print_comp (dpi, d_left (dc));\n       d_append_char (dpi, ')');\n+      if (dc->type == D_COMP_LITERAL_NEG)\n+\td_append_char (dpi, '-');\n       d_print_comp (dpi, d_right (dc));\n       return;\n "}, {"sha": "b39e2f4386b4829f467dab976856bf5812688562", "filename": "libiberty/testsuite/demangle-expected", "status": "modified", "additions": 11, "deletions": 1, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2Ftestsuite%2Fdemangle-expected", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/374caa503bcf9605a85f8b68c79ca2d918c96fb0/libiberty%2Ftestsuite%2Fdemangle-expected", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libiberty%2Ftestsuite%2Fdemangle-expected?ref=374caa503bcf9605a85f8b68c79ca2d918c96fb0", "patch": "@@ -2905,7 +2905,17 @@ bool std::operator< <file_path, std::string>(std::pair<file_path, std::string> c\n --format=gnu-v3\n _Z9hairyfuncM1YKFPVPFrPA2_PM1XKFKPA3_ilEPcEiE\n hairyfunc(int (* const (X::** (* restrict (* volatile*(Y::*)(int) const)(char*)) [2])(long) const) [3])\n-# \n+#\n+# Check that negative numbers are handled correctly.\n+--format=gnu-v3\n+_Z1fILin1EEvv\n+void f<-1>()\n+#\n+# Check a destructor of a standard substitution.\n+--format=gnu-v3\n+_ZNSdD0Ev\n+std::basic_iostream<char, std::char_traits<char> >::~basic_iostream()\n+#\n # This caused an infinite loop.\n #\n # This is generated by an EDG compiler (kcc 4.0).  To demangle it"}]}