{"sha": "fe43084ca31636ee5c997cc9c37f88e71a59293c", "node_id": "C_kwDOANBUbNoAKGZlNDMwODRjYTMxNjM2ZWU1Yzk5N2NjOWMzN2Y4OGU3MWE1OTI5M2M", "commit": {"author": {"name": "Ed Schonberg", "email": "schonberg@adacore.com", "date": "2021-07-27T14:55:07Z"}, "committer": {"name": "Pierre-Marie de Rodat", "email": "derodat@adacore.com", "date": "2021-09-23T13:06:15Z"}, "message": "[Ada] Ada2022: implementation of AI12-0212 : iterator specs in array aggregates\n\ngcc/ada/\n\n\t* sem_aggr.adb (Resolve_Array_Aggregate): Check the validity of\n\tan array aggregate all of whose components are iterated\n\tcomponent associations.\n\t* exp_aggr.adb (Expand_Array_Aggregate,\n\tTwo_Pass_Aggregate_Expansion): implement two-pass algorithm and\n\treplace original aggregate with resulting temporary, to ensure\n\tthat a proper length check is performed if context is\n\tconstrained. Use attributes Pos and Val to handle index types of\n\tany discrete type.", "tree": {"sha": "904051d08f02dec75716fb8f7d22cf7312c2f551", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/904051d08f02dec75716fb8f7d22cf7312c2f551"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fe43084ca31636ee5c997cc9c37f88e71a59293c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43084ca31636ee5c997cc9c37f88e71a59293c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fe43084ca31636ee5c997cc9c37f88e71a59293c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fe43084ca31636ee5c997cc9c37f88e71a59293c/comments", "author": {"login": "Edschonberg", "id": 6352375, "node_id": "MDQ6VXNlcjYzNTIzNzU=", "avatar_url": "https://avatars.githubusercontent.com/u/6352375?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Edschonberg", "html_url": "https://github.com/Edschonberg", "followers_url": "https://api.github.com/users/Edschonberg/followers", "following_url": "https://api.github.com/users/Edschonberg/following{/other_user}", "gists_url": "https://api.github.com/users/Edschonberg/gists{/gist_id}", "starred_url": "https://api.github.com/users/Edschonberg/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Edschonberg/subscriptions", "organizations_url": "https://api.github.com/users/Edschonberg/orgs", "repos_url": "https://api.github.com/users/Edschonberg/repos", "events_url": "https://api.github.com/users/Edschonberg/events{/privacy}", "received_events_url": "https://api.github.com/users/Edschonberg/received_events", "type": "User", "site_admin": false}, "committer": {"login": "pmderodat", "id": 758452, "node_id": "MDQ6VXNlcjc1ODQ1Mg==", "avatar_url": "https://avatars.githubusercontent.com/u/758452?v=4", "gravatar_id": "", "url": "https://api.github.com/users/pmderodat", "html_url": "https://github.com/pmderodat", "followers_url": "https://api.github.com/users/pmderodat/followers", "following_url": "https://api.github.com/users/pmderodat/following{/other_user}", "gists_url": "https://api.github.com/users/pmderodat/gists{/gist_id}", "starred_url": "https://api.github.com/users/pmderodat/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/pmderodat/subscriptions", "organizations_url": "https://api.github.com/users/pmderodat/orgs", "repos_url": "https://api.github.com/users/pmderodat/repos", "events_url": "https://api.github.com/users/pmderodat/events{/privacy}", "received_events_url": "https://api.github.com/users/pmderodat/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "c06539752d77126689ee49fc3e4a8add2a4980e3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/c06539752d77126689ee49fc3e4a8add2a4980e3", "html_url": "https://github.com/Rust-GCC/gccrs/commit/c06539752d77126689ee49fc3e4a8add2a4980e3"}], "stats": {"total": 359, "additions": 329, "deletions": 30}, "files": [{"sha": "a16ee9e850c01c664a3496cd7e203bd8c5102555", "filename": "gcc/ada/exp_aggr.adb", "status": "modified", "additions": 207, "deletions": 2, "changes": 209, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe43084ca31636ee5c997cc9c37f88e71a59293c/gcc%2Fada%2Fexp_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe43084ca31636ee5c997cc9c37f88e71a59293c/gcc%2Fada%2Fexp_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_aggr.adb?ref=fe43084ca31636ee5c997cc9c37f88e71a59293c", "patch": "@@ -5718,6 +5718,15 @@ package body Exp_Aggr is\n       --  built directly into the target of the assignment it must be free\n       --  of side effects. N is the LHS of an assignment.\n \n+      procedure Two_Pass_Aggregate_Expansion (N : Node_Id);\n+      --  If the aggregate consists only of iterated associations then the\n+      --  aggregate is constructed in two steps:\n+      --  a) Build an expression to compute the number of elements\n+      --     generated by each iterator, and use the expression to allocate\n+      --     the destination aggregate.\n+      --  b) Generate the loops corresponding to each iterator to insert\n+      --     the elements in their proper positions.\n+\n       ----------------------------\n       -- Build_Constrained_Type --\n       ----------------------------\n@@ -6334,6 +6343,185 @@ package body Exp_Aggr is\n          end if;\n       end Safe_Left_Hand_Side;\n \n+      ----------------------------------\n+      -- Two_Pass_Aggregate_Expansion --\n+      ----------------------------------\n+\n+      procedure Two_Pass_Aggregate_Expansion (N : Node_Id) is\n+         Loc        : constant Source_Ptr := Sloc (N);\n+         Comp_Type  : constant Entity_Id := Etype (N);\n+         Index_Id   : constant Entity_Id := Make_Temporary (Loc, 'I', N);\n+         Index_Type : constant Entity_Id := Etype (First_Index (Etype (N)));\n+         Size_Id    : constant Entity_Id := Make_Temporary (Loc, 'I', N);\n+         TmpE       : constant Entity_Id := Make_Temporary (Loc, 'A', N);\n+\n+         Assoc    : Node_Id := First (Component_Associations (N));\n+         Incr     : Node_Id;\n+         Iter     : Node_Id;\n+         New_Comp : Node_Id;\n+         One_Loop : Node_Id;\n+\n+         Size_Expr_Code : List_Id;\n+         Insertion_Code : List_Id := New_List;\n+\n+      begin\n+         Size_Expr_Code := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Size_Id,\n+             Object_Definition   => New_Occurrence_Of (Standard_Integer, Loc),\n+             Expression          => Make_Integer_Literal (Loc, 0)));\n+\n+         --  First pass: execute the iterators to count the number of elements\n+         --  that will be generated.\n+\n+         while Present (Assoc) loop\n+            Iter := Iterator_Specification (Assoc);\n+            Incr := Make_Assignment_Statement (Loc,\n+                      Name => New_Occurrence_Of (Size_Id, Loc),\n+                      Expression =>\n+                        Make_Op_Add (Loc,\n+                         Left_Opnd  => New_Occurrence_Of (Size_Id, Loc),\n+                         Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+\n+            One_Loop := Make_Loop_Statement (Loc,\n+              Iteration_Scheme =>\n+                Make_Iteration_Scheme (Loc,\n+                  Iterator_Specification =>  New_Copy_Tree (Iter)),\n+                Statements => New_List (Incr));\n+\n+            Append (One_Loop, Size_Expr_Code);\n+            Next (Assoc);\n+         end loop;\n+\n+         Insert_Actions (N, Size_Expr_Code);\n+\n+         --  Build a constrained subtype with the calculated length\n+         --  and declare the proper bounded aggregate object.\n+         --  The index type is some discrete type, so the bounds of the\n+         --  constructed array are computed as T'Val (T'Pos (ineger bound));\n+\n+         declare\n+            Pos_Lo : constant Node_Id :=\n+              Make_Attribute_Reference (Loc,\n+                Prefix => New_Occurrence_Of (Index_Type, Loc),\n+                Attribute_Name => Name_Pos,\n+                Expressions => New_List (\n+                  Make_Attribute_Reference (Loc,\n+                    Prefix => New_Occurrence_Of (Index_Type, Loc),\n+                    Attribute_Name => Name_First)));\n+\n+            Aggr_Lo : constant Node_Id :=\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => New_Occurrence_Of (Index_Type, Loc),\n+                 Attribute_Name => Name_Val,\n+                 Expressions => New_List (New_Copy_Tree (Pos_Lo)));\n+\n+            --  Hi = Index_type'Pos (Lo + Size -1).\n+\n+            Pos_Hi : constant Node_Id :=\n+               Make_Op_Add (Loc,\n+                 Left_Opnd => New_Copy_Tree (Pos_Lo),\n+                 Right_Opnd =>\n+                   Make_Op_Subtract (Loc,\n+                     Left_Opnd  => New_Occurrence_Of (Size_Id, Loc),\n+                     Right_Opnd => Make_Integer_Literal (Loc, 1)));\n+\n+            --  Corresponding index value\n+\n+            Aggr_Hi : constant Node_Id :=\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => New_Occurrence_Of (Index_Type, Loc),\n+                 Attribute_Name => Name_Val,\n+                 Expressions => New_List (New_Copy_Tree (Pos_Hi)));\n+\n+            SubE : constant Entity_Id := Make_Temporary (Loc, 'T');\n+            SubD : constant Node_Id :=\n+              Make_Subtype_Declaration (Loc,\n+                Defining_Identifier => SubE,\n+                Subtype_Indication  =>\n+                  Make_Subtype_Indication (Loc,\n+                    Subtype_Mark =>\n+                      New_Occurrence_Of (Etype (Comp_Type), Loc),\n+                    Constraint =>\n+                      Make_Index_Or_Discriminant_Constraint\n+                        (Loc,\n+                         Constraints =>\n+                           New_List (Make_Range (Loc, Aggr_Lo, Aggr_Hi)))));\n+\n+               --  Create a temporary array of the above subtype which\n+               --  will be used to capture the aggregate assignments.\n+\n+               TmpD : constant Node_Id :=\n+                 Make_Object_Declaration (Loc,\n+                   Defining_Identifier => TmpE,\n+                   Object_Definition   => New_Occurrence_Of (SubE, Loc));\n+         begin\n+            Insert_Actions (N, New_List (SubD, TmpD));\n+         end;\n+\n+         --  Second pass: use the iterators to generate the elements of the\n+         --  aggregate. Insertion index starts at Index_Type'First. We\n+         --  assume that the second evaluation of each iterator generates\n+         --  the same number of elements as the first pass, and consider\n+         --  that the execution is erroneous (even if the RM does not state\n+         --  this explicitly) if the number of elements generated differs\n+         --  between first and second pass.\n+\n+         Assoc := First (Component_Associations (N));\n+\n+         --  Initialize insertion position to first array component.\n+\n+         Insertion_Code := New_List (\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Index_Id,\n+             Object_Definition   =>\n+               New_Occurrence_Of (Index_Type, Loc),\n+             Expression =>\n+               Make_Attribute_Reference (Loc,\n+                 Prefix => New_Occurrence_Of (Index_Type, Loc),\n+                 Attribute_Name => Name_First)));\n+\n+         while Present (Assoc) loop\n+            Iter := Iterator_Specification (Assoc);\n+            New_Comp := Make_Assignment_Statement (Loc,\n+               Name =>\n+                 Make_Indexed_Component (Loc,\n+                    Prefix => New_Occurrence_Of (TmpE, Loc),\n+                    Expressions =>\n+                      New_List (New_Occurrence_Of (Index_Id, Loc))),\n+               Expression => New_Copy_Tree (Expression (Assoc)));\n+\n+            --  Advance index position for insertion.\n+\n+            Incr := Make_Assignment_Statement (Loc,\n+                      Name => New_Occurrence_Of (Index_Id, Loc),\n+                      Expression =>\n+                        Make_Attribute_Reference (Loc,\n+                          Prefix =>\n+                            New_Occurrence_Of (Index_Type, Loc),\n+                          Attribute_Name => Name_Succ,\n+                          Expressions =>\n+                            New_List (New_Occurrence_Of (Index_Id, Loc))));\n+\n+            One_Loop := Make_Loop_Statement (Loc,\n+              Iteration_Scheme =>\n+                Make_Iteration_Scheme (Loc,\n+                  Iterator_Specification =>  Copy_Separate_Tree (Iter)),\n+                Statements => New_List (New_Comp, Incr));\n+\n+            Append (One_Loop, Insertion_Code);\n+            Next (Assoc);\n+         end loop;\n+\n+         Insert_Actions (N, Insertion_Code);\n+\n+         --  Depending on context this may not work for build-in-place\n+         --  arrays ???\n+\n+         Rewrite (N, New_Occurrence_Of (TmpE, Loc));\n+\n+      end Two_Pass_Aggregate_Expansion;\n+\n       --  Local variables\n \n       Tmp : Entity_Id;\n@@ -6371,6 +6559,16 @@ package body Exp_Aggr is\n       then\n          return;\n \n+      elsif Present (Component_Associations (N))\n+         and then\n+            Nkind (First (Component_Associations (N)))\n+               = N_Iterated_Component_Association\n+           and then Present\n+             (Iterator_Specification (First (Component_Associations (N))))\n+      then\n+         Two_Pass_Aggregate_Expansion (N);\n+         return;\n+\n       --  Do not attempt expansion if error already detected. We may reach this\n       --  point in spite of previous errors when compiling with -gnatq, to\n       --  force all possible errors (this is the usual ACATS mode).\n@@ -7038,6 +7236,9 @@ package body Exp_Aggr is\n       --  or Element_Association with non-static bounds, build an expression\n       --  to be used as the allocated size of the container. This may be an\n       --  overestimate if a filter is present, but is a safe approximation.\n+      --  If bounds are dynamic the aggregate is created in two passes, and\n+      --  the first generates a loop for the sole purpose of computing the\n+      --  number of elements that will be generated on the seocnd pass.\n \n       procedure Expand_Iterated_Component (Comp : Node_Id);\n       --  Handle iterated_component_association and iterated_Element\n@@ -7185,7 +7386,11 @@ package body Exp_Aggr is\n             return Build_Siz_Exp (First (Discrete_Choices (Comp)));\n \n          elsif Nkind (Comp) = N_Iterated_Element_Association then\n-            return -1;    --  ??? build expression for size of the domain\n+            return -1;\n+\n+            --  TBD : Create code for a loop and add to generated code,\n+            --  as is done for array aggregates with iterated element\n+            --  associations, instead of using Append operations.\n \n          else\n             return -1;\n@@ -7217,7 +7422,7 @@ package body Exp_Aggr is\n \n             if Present (Iterator_Specification (Comp)) then\n \n-               --  Either an Iterator_Specification of a Loop_Parameter_\n+               --  Either an Iterator_Specification or a Loop_Parameter_\n                --  Specification is present.\n \n                L_Iteration_Scheme :="}, {"sha": "732f0f39a48f3c3d5e7a9df15fa795a382a997aa", "filename": "gcc/ada/sem_aggr.adb", "status": "modified", "additions": 122, "deletions": 28, "changes": 150, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fe43084ca31636ee5c997cc9c37f88e71a59293c/gcc%2Fada%2Fsem_aggr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fe43084ca31636ee5c997cc9c37f88e71a59293c/gcc%2Fada%2Fsem_aggr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_aggr.adb?ref=fe43084ca31636ee5c997cc9c37f88e71a59293c", "patch": "@@ -545,6 +545,14 @@ package body Sem_Aggr is\n       --  Make sure that the list of index constraints is properly attached to\n       --  the tree, and then collect the aggregate bounds.\n \n+      --  If no aggregaate bounds have been set, this is an aggregate with\n+      --  iterator specifications and a dynamic size to be determined by\n+      --  first pass of expanded code.\n+\n+      if No (Aggregate_Bounds (N)) then\n+         return Typ;\n+      end if;\n+\n       Set_Parent (Index_Constraints, N);\n       Collect_Aggr_Bounds (N, 1);\n \n@@ -1597,6 +1605,8 @@ package body Sem_Aggr is\n          Loc : constant Source_Ptr := Sloc (N);\n          Id  : constant Entity_Id  := Defining_Identifier (N);\n \n+         Id_Typ : Entity_Id;\n+\n          -----------------------\n          -- Remove_References --\n          -----------------------\n@@ -1630,42 +1640,63 @@ package body Sem_Aggr is\n       --  Start of processing for Resolve_Iterated_Component_Association\n \n       begin\n-         --  An element iterator specification cannot appear in\n-         --  an array aggregate because it does not provide index\n-         --  values for the association. This must be a semantic\n-         --  check because the parser cannot tell whether this is\n-         --  an array aggregate or a container aggregate.\n-\n          if Present (Iterator_Specification (N)) then\n-            Error_Msg_N (\"container element Iterator cannot appear \"\n-              & \"in an array aggregate\", N);\n-            return;\n-         end if;\n+            Analyze (Name (Iterator_Specification (N)));\n \n-         Choice := First (Discrete_Choices (N));\n+            --  We assume that the domain of iteration cannot be overloaded.\n \n-         while Present (Choice) loop\n-            if Nkind (Choice) = N_Others_Choice then\n-               Others_Present := True;\n+            declare\n+               Domain : constant Node_Id := Name (Iterator_Specification (N));\n+               D_Type : constant Entity_Id := Etype (Domain);\n+               Elt    : Entity_Id;\n+            begin\n+               if Is_Array_Type (D_Type) then\n+                  Id_Typ := Component_Type (D_Type);\n \n-            else\n-               Analyze (Choice);\n+               else\n+                  if Has_Aspect (D_Type, Aspect_Iterable) then\n+                     Elt :=\n+                       Get_Iterable_Type_Primitive (D_Type, Name_Element);\n+                     if No (Elt) then\n+                        Error_Msg_N\n+                          (\"missing Element primitive for iteration\", Domain);\n+                     else\n+                        Id_Typ := Etype (Elt);\n+                     end if;\n+                  else\n+                     Error_Msg_N (\"cannot iterate over\", Domain);\n+                  end if;\n+               end if;\n+            end;\n \n-               --  Choice can be a subtype name, a range, or an expression\n+         else\n+            Id_Typ := Index_Typ;\n+            Choice := First (Discrete_Choices (N));\n \n-               if Is_Entity_Name (Choice)\n-                 and then Is_Type (Entity (Choice))\n-                 and then Base_Type (Entity (Choice)) = Base_Type (Index_Typ)\n-               then\n-                  null;\n+            while Present (Choice) loop\n+               if Nkind (Choice) = N_Others_Choice then\n+                  Others_Present := True;\n \n                else\n-                  Analyze_And_Resolve (Choice, Index_Typ);\n+                  Analyze (Choice);\n+\n+                  --  Choice can be a subtype name, a range, or an expression\n+\n+                  if Is_Entity_Name (Choice)\n+                    and then Is_Type (Entity (Choice))\n+                    and then\n+                      Base_Type (Entity (Choice)) = Base_Type (Index_Typ)\n+                  then\n+                     null;\n+\n+                  else\n+                     Analyze_And_Resolve (Choice, Index_Typ);\n+                  end if;\n                end if;\n-            end if;\n \n-            Next (Choice);\n-         end loop;\n+               Next (Choice);\n+            end loop;\n+         end if;\n \n          --  Create a scope in which to introduce an index, which is usually\n          --  visible in the expression for the component, and needed for its\n@@ -1681,7 +1712,7 @@ package body Sem_Aggr is\n          --  directly visible.\n \n          Enter_Name (Id);\n-         Set_Etype (Id, Index_Typ);\n+         Set_Etype (Id, Id_Typ);\n          Mutate_Ekind (Id, E_Variable);\n          Set_Scope (Id, Ent);\n \n@@ -1735,6 +1766,12 @@ package body Sem_Aggr is\n       Delete_Choice : Boolean;\n       --  Used when replacing a subtype choice with predicate by a list\n \n+      Has_Iterator_Specifications : Boolean := False;\n+      --  Flag to indicate that all named associations are iterated component\n+      --  associations with iterator specifications, in which case the\n+      --  expansion will create two loops: one to evaluate the size and one\n+      --  to generate the elements (4.3.3 (20.2/5)).\n+\n       Nb_Elements : Uint := Uint_0;\n       --  The number of elements in a positional aggregate\n \n@@ -1756,6 +1793,54 @@ package body Sem_Aggr is\n       --  STEP 1: make sure the aggregate is correctly formatted\n \n       if Present (Component_Associations (N)) then\n+\n+         --  Verify that all or none of the component associations\n+         --  include an iterator specification.\n+\n+         Assoc := First (Component_Associations (N));\n+         if Nkind (Assoc) = N_Iterated_Component_Association\n+           and then Present (Iterator_Specification (Assoc))\n+         then\n+            --  All other component associations must have an iterator spec.\n+\n+            Next (Assoc);\n+            while Present (Assoc) loop\n+               if Nkind (Assoc) /= N_Iterated_Component_Association\n+                 or else No (Iterator_Specification (Assoc))\n+               then\n+                  Error_Msg_N (\"mixed iterated component association\"\n+                   & \" (RM 4.4.3 (17.1/5))\",\n+                      Assoc);\n+                  return False;\n+               end if;\n+\n+               Next (Assoc);\n+            end loop;\n+\n+            Has_Iterator_Specifications := True;\n+\n+         else\n+            --  or none of them do.\n+\n+            Next (Assoc);\n+            while Present (Assoc) loop\n+               if Nkind (Assoc) = N_Iterated_Component_Association\n+                 and then Present (Iterator_Specification (Assoc))\n+               then\n+                  Error_Msg_N (\"mixed iterated component association\"\n+                    & \" (RM 4.4.3 (17.1/5))\",\n+                      Assoc);\n+                  return False;\n+               end if;\n+\n+               Next (Assoc);\n+            end loop;\n+\n+            while Present (Assoc) loop\n+               Next (Assoc);\n+            end loop;\n+         end if;\n+\n          Assoc := First (Component_Associations (N));\n          while Present (Assoc) loop\n             if Nkind (Assoc) = N_Iterated_Component_Association then\n@@ -1948,9 +2033,12 @@ package body Sem_Aggr is\n \n          begin\n             --  STEP 2 (A): Check discrete choices validity\n+            --  No need if this is an element iteration.\n \n             Assoc := First (Component_Associations (N));\n-            while Present (Assoc) loop\n+            while Present (Assoc)\n+              and then Present (Choice_List (Assoc))\n+            loop\n                Prev_Nb_Discrete_Choices := Nb_Discrete_Choices;\n                Choice := First (Choice_List (Assoc));\n \n@@ -2391,6 +2479,12 @@ package body Sem_Aggr is\n                end Check_Choices;\n             end if;\n \n+            if Has_Iterator_Specifications then\n+               --  Bounds will be determined dynamically.\n+\n+               return Success;\n+            end if;\n+\n             --  STEP 2 (B): Compute aggregate bounds and min/max choices values\n \n             if Nb_Discrete_Choices > 0 then"}]}