{"sha": "e895113a67a061c20fbb16be60c2d90eb6ba084a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTg5NTExM2E2N2EwNjFjMjBmYmIxNmJlNjBjMmQ5MGViNmJhMDg0YQ==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@codesourcery.com", "date": "2003-08-16T13:32:11Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2003-08-16T13:32:11Z"}, "message": "re PR c++/11512 (Spurious warning for comma-operator in templates)\n\n\tPR c++/11512\n\t* stmt.c (expand_expr_stmt_value): Don't warn about any void\n\ttyped expression.\ncp:\n\tPR c++/11512\n\t* cvt.c (convert_to_void): Indicate which side of conditional has\n\tno effects, and rhs of comma operator. Test for no sideeffect\n\texpressions here and always build a convert expr.\n\t* init.c (expand_default_init): Convert the init to void.\n\t* typeck.c (build_x_compound_expr): Do not check for side effects\n\there.\n\t(build_compound_expr): Do not convert lhs when building a\n\ttemplate.\ntestsuite:\n\tPR C++/11512\n\t* g++.dg/template/warn1.C: New.\n\nFrom-SVN: r70505", "tree": {"sha": "0432e7399477735a910c874de61c6edf041c4dbe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0432e7399477735a910c874de61c6edf041c4dbe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e895113a67a061c20fbb16be60c2d90eb6ba084a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e895113a67a061c20fbb16be60c2d90eb6ba084a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e895113a67a061c20fbb16be60c2d90eb6ba084a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e895113a67a061c20fbb16be60c2d90eb6ba084a/comments", "author": null, "committer": null, "parents": [{"sha": "e767b5be438a67c59f8f23b6214fcbb7183a8092", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e767b5be438a67c59f8f23b6214fcbb7183a8092", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e767b5be438a67c59f8f23b6214fcbb7183a8092"}], "stats": {"total": 124, "additions": 85, "deletions": 39}, "files": [{"sha": "d764ebf6e07d453066d3e4161a985a19fc2f654c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -1,3 +1,9 @@\n+2003-08-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11512\n+\t* stmt.c (expand_expr_stmt_value): Don't warn about any void\n+\ttyped expression.\n+\n 2003-08-16  Jan Hubicka  <jh@suse.cz>\n \n \t* i386.c (ix86_fntype_regparm): Rename from ..."}, {"sha": "1651a9e579d97612090cde718ffeb182cd1f02a5", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -1,3 +1,15 @@\n+2003-08-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR c++/11512\n+\t* cvt.c (convert_to_void): Indicate which side of conditional has\n+\tno effects, and rhs of comma operator. Test for no sideeffect\n+\texpressions here and always build a convert expr.\n+\t* init.c (expand_default_init): Convert the init to void.\n+\t* typeck.c (build_x_compound_expr): Do not check for side effects\n+\there.\n+\t(build_compound_expr): Do not convert lhs when building a\n+\ttemplate.\n+\n 2003-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* cp-tree.def (NON_DEPENDENT_EXPR): Add operand."}, {"sha": "0a8e4789b29ef1a55d657e03f6a114d9b9ee21a0", "filename": "gcc/cp/cvt.c", "status": "modified", "additions": 11, "deletions": 10, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Fcvt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Fcvt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcvt.c?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -812,8 +812,12 @@ convert_to_void (tree expr, const char *implicit)\n         /* The two parts of a cond expr might be separate lvalues.  */\n         tree op1 = TREE_OPERAND (expr,1);\n         tree op2 = TREE_OPERAND (expr,2);\n-        tree new_op1 = convert_to_void (op1, implicit);\n-        tree new_op2 = convert_to_void (op2, implicit);\n+        tree new_op1 = convert_to_void\n+\t  (op1, (implicit && !TREE_SIDE_EFFECTS (op2)\n+\t\t ? \"second operand of conditional\" : NULL));\n+        tree new_op2 = convert_to_void\n+\t  (op2, (implicit && !TREE_SIDE_EFFECTS (op1)\n+\t\t ? \"third operand of conditional\" : NULL));\n         \n \texpr = build (COND_EXPR, TREE_TYPE (new_op1),\n \t\t      TREE_OPERAND (expr, 0), new_op1, new_op2);\n@@ -824,7 +828,8 @@ convert_to_void (tree expr, const char *implicit)\n       {\n         /* The second part of a compound expr contains the value.  */\n         tree op1 = TREE_OPERAND (expr,1);\n-        tree new_op1 = convert_to_void (op1, implicit);\n+        tree new_op1 = convert_to_void\n+\t  (op1, implicit ? \"right-hand operand of comma\" : NULL);\n         \n         if (new_op1 != op1)\n \t  {\n@@ -901,13 +906,9 @@ convert_to_void (tree expr, const char *implicit)\n   \n   if (expr != error_mark_node && !VOID_TYPE_P (TREE_TYPE (expr)))\n     {\n-      /* FIXME: This is where we should check for expressions with no\n-         effects.  At the moment we do that in both build_x_component_expr\n-         and expand_expr_stmt -- inconsistently too.  For the moment\n-         leave implicit void conversions unadorned so that expand_expr_stmt\n-         has a chance of detecting some of the cases.  */\n-      if (!implicit)\n-        expr = build1 (CONVERT_EXPR, void_type_node, expr);\n+      if (implicit && !TREE_SIDE_EFFECTS (expr) && warn_unused_value)\n+\twarning (\"%s has no effect\", implicit);\n+      expr = build1 (CONVERT_EXPR, void_type_node, expr);\n     }\n   return expr;\n }"}, {"sha": "c2b371114e3db135007bb9ea6cd2013d02cb0942", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -1229,7 +1229,7 @@ expand_default_init (tree binfo, tree true_exp, tree exp, tree init, int flags)\n \n   rval = build_special_member_call (exp, ctor_name, parms, binfo, flags);\n   if (TREE_SIDE_EFFECTS (rval))\n-    finish_expr_stmt (rval);\n+    finish_expr_stmt (convert_to_void (rval, NULL));\n }\n \n /* This function is responsible for initializing EXP with INIT"}, {"sha": "21186ebca818468671d000664501f1ba747dd24e", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 9, "deletions": 19, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -4296,21 +4296,7 @@ build_x_compound_expr (tree op1, tree op2)\n \n   result = build_new_op (COMPOUND_EXPR, LOOKUP_NORMAL, op1, op2, NULL_TREE);\n   if (!result)\n-    {\n-      if (! TREE_SIDE_EFFECTS (op1))\n-\t{\n-\t  /* FIXME: This test should be in the implicit cast to void\n-\t     of the LHS.  */\n-\t  /* the left-hand operand of a comma expression is like an expression\n-\t     statement: we should warn if it doesn't have any side-effects,\n-\t     unless it was explicitly cast to (void).  */\n-\t  if (warn_unused_value\n-\t      && !(TREE_CODE (op1) == CONVERT_EXPR\n-\t\t   && VOID_TYPE_P (TREE_TYPE (op1))))\n-\t    warning(\"left-hand operand of comma expression has no effect\");\n-\t}\n-      result = build_compound_expr (op1, op2);\n-    }\n+    result = build_compound_expr (op1, op2);\n \n   if (processing_template_decl && result != error_mark_node)\n     return build_min (COMPOUND_EXPR, TREE_TYPE (result), \n@@ -4323,18 +4309,22 @@ build_x_compound_expr (tree op1, tree op2)\n tree\n build_compound_expr (tree lhs, tree rhs)\n {\n-  lhs = decl_constant_value (lhs);\n-  lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n+  if (!processing_template_decl)\n+    {\n+      lhs = decl_constant_value (lhs);\n+      lhs = convert_to_void (lhs, \"left-hand operand of comma\");\n+    }\n+  \n   if (lhs == error_mark_node || rhs == error_mark_node)\n     return error_mark_node;\n-\n+  \n   if (TREE_CODE (rhs) == TARGET_EXPR)\n     {\n       /* If the rhs is a TARGET_EXPR, then build the compound\n          expression inside the target_expr's initializer. This\n \t helps the compiler to eliminate unncessary temporaries.  */\n       tree init = TREE_OPERAND (rhs, 1);\n-\n+      \n       init = build (COMPOUND_EXPR, TREE_TYPE (init), lhs, init);\n       TREE_OPERAND (rhs, 1) = init;\n       "}, {"sha": "defbb70df21fa26ca37cd2dd9eda1311cbad3f89", "filename": "gcc/stmt.c", "status": "modified", "additions": 5, "deletions": 9, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -2152,17 +2152,13 @@ expand_expr_stmt_value (tree exp, int want_value, int maybe_last)\n      except for last statement in ({...}) where they may be useful.  */\n   if (! want_value\n       && (expr_stmts_for_value == 0 || ! maybe_last)\n-      && exp != error_mark_node)\n+      && exp != error_mark_node\n+      && warn_unused_value)\n     {\n-      if (! TREE_SIDE_EFFECTS (exp))\n-\t{\n-\t  if (warn_unused_value\n-\t      && !(TREE_CODE (exp) == CONVERT_EXPR\n-\t\t   && VOID_TYPE_P (TREE_TYPE (exp))))\n-\t    warning (\"%Hstatement with no effect\", &emit_locus);\n-\t}\n-      else if (warn_unused_value)\n+      if (TREE_SIDE_EFFECTS (exp))\n \twarn_if_unused_value (exp);\n+      else if (!VOID_TYPE_P (TREE_TYPE (exp)))\n+\twarning (\"%Hstatement with no effect\", &emit_locus);\n     }\n \n   /* If EXP is of function type and we are expanding statements for"}, {"sha": "47e7e9725e612ce4ae34b26200f202c0de391ae6", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -1,3 +1,8 @@\n+2003-08-16  Nathan Sidwell  <nathan@codesourcery.com>\n+\n+\tPR C++/11512\n+\t* g++.dg/template/warn1.C: New.\n+\n 2003-08-15  Nathan Sidwell  <nathan@codesourcery.com>\n \n \t* g++.dg/template/error2.C: New test."}, {"sha": "827c65e24c59e070f656be5633b01a6bc54e80ef", "filename": "gcc/testsuite/g++.dg/template/warn1.C", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e895113a67a061c20fbb16be60c2d90eb6ba084a/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftemplate%2Fwarn1.C?ref=e895113a67a061c20fbb16be60c2d90eb6ba084a", "patch": "@@ -0,0 +1,36 @@\n+// { dg-do compile }\n+// { dg-options \"-Wall\" }\n+\n+// Copyright (C) 2003 Free Software Foundation, Inc.\n+// Contributed by Nathan Sidwell 14 Aug 2003 <nathan@codesourcery.com>\n+\n+// PR 11512. erroneous warnings\n+\n+template <class T>  void Foo(T i) \n+{ \n+  i++, i++;\n+  i, i++; // { dg-warning \"left-hand operand\" \"\" }\n+  i++, i; // { dg-warning \"right-hand operand\" \"\" }\n+  for (;; --i, ++i)\n+    ;\n+} \n+ \n+void Bar ()\n+{ \n+  Foo (1);  // { dg-error \"instantiated\" \"\" }\n+}\n+\n+struct M {};\n+\n+struct C\n+{\n+  M m;\n+  C () :m (M ()) {}\n+};\n+\n+\n+void Baz (int i)\n+{\n+  i ? i + 1 : i + 2; // { dg-error \"operand of\" \"\" }\n+  i ? i++ : 0;\n+}"}]}