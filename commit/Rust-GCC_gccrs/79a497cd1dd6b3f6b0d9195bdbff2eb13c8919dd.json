{"sha": "79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzlhNDk3Y2QxZGQ2YjNmNmIwZDkxOTViZGJmZjJlYjEzYzg5MTlkZA==", "commit": {"author": {"name": "Janis Johnson", "email": "janis187@us.ibm.com", "date": "2002-05-10T20:48:32Z"}, "committer": {"name": "Janis Johnson", "email": "janis@gcc.gnu.org", "date": "2002-05-10T20:48:32Z"}, "message": "loop.c: (PREFETCH_EXTREME_DIFFERENCE, PREFETCH_BEFORE_LOOP): New.\n\n\t* loop.c: (PREFETCH_EXTREME_DIFFERENCE, PREFETCH_BEFORE_LOOP): New.\n\t(PREFETCH_CONDITIONAL): Renamed from PREFETCH_NOT_ALWAYS.\n\t(struct prefetch_info): Fix spelling of member bytes_accessed.\n\t(emit_prefetch_instructions): Make dump messages more regular;\n\trestructure code to add more dump messages; use new macros for\n\theuristics. (There are no code generation changes in any of this).\n\nFrom-SVN: r53371", "tree": {"sha": "fe686b5c19f3a51d8f460078905b75b178bde2ab", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe686b5c19f3a51d8f460078905b75b178bde2ab"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "html_url": "https://github.com/Rust-GCC/gccrs/commit/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd/comments", "author": null, "committer": null, "parents": [{"sha": "7440af146e17a8ba291f11da9a94c1da28380f00", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7440af146e17a8ba291f11da9a94c1da28380f00", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7440af146e17a8ba291f11da9a94c1da28380f00"}], "stats": {"total": 209, "additions": 140, "deletions": 69}, "files": [{"sha": "bc20fd32eba547040725605654effdc5561b0d0c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "patch": "@@ -1,3 +1,12 @@\n+2002-05-10  Janis Johnson  <janis187@us.ibm.com>\n+\n+\t* loop.c: (PREFETCH_EXTREME_DIFFERENCE, PREFETCH_BEFORE_LOOP): New.\n+\t(PREFETCH_CONDITIONAL): Renamed from PREFETCH_NOT_ALWAYS.\n+\t(struct prefetch_info): Fix spelling of member bytes_accessed.\n+\t(emit_prefetch_instructions): Make dump messages more regular;\n+\trestructure code to add more dump messages; use new macros for\n+\theuristics. (There are no code generation changes in any of this).\n+\n 2002-05-10  David S. Miller  <davem@redhat.com>\n \n \t* rtl.h (INSN_ANNULLED_BRANCH_P): Accept INSN too, update comment."}, {"sha": "3735d795e3a80921db7849a0766c56c803e9ca33", "filename": "gcc/loop.c", "status": "modified", "additions": 131, "deletions": 69, "changes": 200, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd/gcc%2Floop.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd/gcc%2Floop.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Floop.c?ref=79a497cd1dd6b3f6b0d9195bdbff2eb13c8919dd", "patch": "@@ -124,14 +124,26 @@ Software Foundation, 59 Temple Place - Suite 330, Boston, MA\n #define PREFETCH_EXTREME_STRIDE 4096\n #endif\n \n+/* Define a limit to how far apart indices can be and still be merged\n+   into a single prefetch.  */\n+#ifndef PREFETCH_EXTREME_DIFFERENCE\n+#define PREFETCH_EXTREME_DIFFERENCE 4096\n+#endif\n+\n+/* Issue prefetch instructions before the loop to fetch data to be used\n+   in the first few loop iterations.  */\n+#ifndef PREFETCH_BEFORE_LOOP\n+#define PREFETCH_BEFORE_LOOP 1\n+#endif\n+\n /* Do not handle reversed order prefetches (negative stride).  */\n #ifndef PREFETCH_NO_REVERSE_ORDER\n #define PREFETCH_NO_REVERSE_ORDER 1\n #endif\n \n-/* Prefetch even if the GIV is not always executed.  */\n-#ifndef PREFETCH_NOT_ALWAYS\n-#define PREFETCH_NOT_ALWAYS 0\n+/* Prefetch even if the GIV is in conditional code.  */\n+#ifndef PREFETCH_CONDITIONAL\n+#define PREFETCH_CONDITIONAL 0\n #endif\n \n /* If the loop requires more prefetches than the target can process in\n@@ -3569,7 +3581,7 @@ struct prefetch_info\n   HOST_WIDE_INT index;\n   HOST_WIDE_INT stride;\t\t/* Prefetch stride in bytes in each\n \t\t\t\t   iteration.  */\n-  unsigned int bytes_accesed;\t/* Sum of sizes of all acceses to this\n+  unsigned int bytes_accessed;\t/* Sum of sizes of all acceses to this\n \t\t\t\t   prefetch area in one iteration.  */\n   unsigned int total_bytes;\t/* Total bytes loop will access in this block.\n \t\t\t\t   This is set only for loops with known\n@@ -3781,18 +3793,19 @@ emit_prefetch_instructions (loop)\n   if (PREFETCH_NO_CALL && LOOP_INFO (loop)->has_call)\n     {\n       if (loop_dump_stream)\n-\tfprintf (loop_dump_stream, \"Prefetch: ignoring loop - has call.\\n\");\n+\tfprintf (loop_dump_stream, \"Prefetch: ignoring loop: has call.\\n\");\n \n       return;\n     }\n \n+  /* Don't prefetch in loops known to have few iterations.  */\n   if (PREFETCH_NO_LOW_LOOPCNT\n       && LOOP_INFO (loop)->n_iterations\n       && LOOP_INFO (loop)->n_iterations <= PREFETCH_LOW_LOOPCNT)\n     {\n       if (loop_dump_stream)\n \tfprintf (loop_dump_stream,\n-\t\t \"Prefetch: ignoring loop - not enought iterations.\\n\");\n+\t\t \"Prefetch: ignoring loop: not enough iterations.\\n\");\n       return;\n     }\n \n@@ -3813,14 +3826,13 @@ emit_prefetch_instructions (loop)\n \t     BIVs that are executed multiple times; such BIVs ought to be\n \t     handled in the nested loop.  We accept not_every_iteration BIVs,\n \t     since these only result in larger strides and make our\n-\t     heuristics more conservative.\n-\t     ??? What does the last sentence mean?  */\n+\t     heuristics more conservative.  */\n \t  if (GET_CODE (biv->add_val) != CONST_INT)\n \t    {\n \t      if (loop_dump_stream)\n \t\t{\n \t\t  fprintf (loop_dump_stream,\n-\t\t\t   \"Prefetch: biv %i ignored: non-constant addition at insn %i:\",\n+\t\t    \"Prefetch: ignoring biv %d: non-constant addition at insn %d:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n \t\t  print_rtl (loop_dump_stream, biv->add_val);\n \t\t  fprintf (loop_dump_stream, \"\\n\");\n@@ -3833,7 +3845,7 @@ emit_prefetch_instructions (loop)\n \t      if (loop_dump_stream)\n \t\t{\n \t\t  fprintf (loop_dump_stream,\n-\t\t\t   \"Prefetch: biv %i ignored: maybe_multiple at insn %i:\",\n+\t\t\t   \"Prefetch: ignoring biv %d: maybe_multiple at insn %i:\",\n \t\t\t   REGNO (biv->src_reg), INSN_UID (biv->insn));\n \t\t  print_rtl (loop_dump_stream, biv->add_val);\n \t\t  fprintf (loop_dump_stream, \"\\n\");\n@@ -3854,41 +3866,64 @@ emit_prefetch_instructions (loop)\n \t  rtx temp;\n \t  HOST_WIDE_INT index = 0;\n \t  int add = 1;\n-\t  HOST_WIDE_INT stride;\n+\t  HOST_WIDE_INT stride = 0;\n+\t  int stride_sign = 1;\n \t  struct check_store_data d;\n+\t  const char *ignore_reason = NULL;\n \t  int size = GET_MODE_SIZE (GET_MODE (iv));\n \n-\t  /* There are several reasons why an induction variable is not\n-\t     interesting to us.  */\n-\t  if (iv->giv_type != DEST_ADDR\n-\t      /* We are interested only in constant stride memory references\n-\t\t in order to be able to compute density easily.  */\n-\t      || GET_CODE (iv->mult_val) != CONST_INT\n-\t      /* Don't handle reversed order prefetches, since they are usually\n-\t\t ineffective.  Later we may be able to reverse such BIVs.  */\n-\t      || (PREFETCH_NO_REVERSE_ORDER\n-\t\t  && (stride = INTVAL (iv->mult_val) * basestride) < 0)\n-\t      /* Prefetching of accesses with such an extreme stride is probably\n-\t\t not worthwhile, either.  */\n-\t      || (PREFETCH_NO_EXTREME_STRIDE\n-\t\t  && stride > PREFETCH_EXTREME_STRIDE)\n+\t  /* See whether an induction variable is interesting to us and if\n+\t     not, report the reason.  */\n+\t  if (iv->giv_type != DEST_ADDR)\n+\t    ignore_reason = \"giv is not a destination address\";\n+\n+\t  /* We are interested only in constant stride memory references\n+\t     in order to be able to compute density easily.  */\n+\t  else if (GET_CODE (iv->mult_val) != CONST_INT)\n+\t    ignore_reason = \"stride is not constant\";\n+\n+\t  else\n+\t    {\n+\t      stride = INTVAL (iv->mult_val) * basestride;\n+\t      if (stride < 0)\n+\t        {\n+\t\t  stride = -stride;\n+\t\t  stride_sign = -1;\n+\t        }\n+\n+\t      /* On some targets, reversed order prefetches are not\n+\t         worthwhile.  */\n+\t      if (PREFETCH_NO_REVERSE_ORDER && stride_sign < 0)\n+\t\tignore_reason = \"reversed order stride\";\n+\n+\t      /* Prefetch of accesses with an extreme stride might not be\n+\t         worthwhile, either.  */\n+\t      else if (PREFETCH_NO_EXTREME_STRIDE\n+\t\t       && stride > PREFETCH_EXTREME_STRIDE)\n+\t\tignore_reason = \"extreme stride\";\n+\n \t      /* Ignore GIVs with varying add values; we can't predict the\n-\t\t value for the next iteration.  */\n-\t      || !loop_invariant_p (loop, iv->add_val)\n+\t         value for the next iteration.  */\n+\t      else if (!loop_invariant_p (loop, iv->add_val))\n+\t\tignore_reason = \"giv has varying add value\";\n+\n \t      /* Ignore GIVs in the nested loops; they ought to have been\n-\t\t handled already.  */\n-\t      || iv->maybe_multiple)\n+\t         handled already.  */\n+\t      else if (iv->maybe_multiple)\n+\t\tignore_reason = \"giv is in nested loop\";\n+\t    }\n+\n+\t  if (ignore_reason != NULL)\n \t    {\n \t      if (loop_dump_stream)\n-\t\tfprintf (loop_dump_stream, \"Prefetch: Ignoring giv at %i\\n\",\n-\t\t\t INSN_UID (iv->insn));\n+\t\tfprintf (loop_dump_stream,\n+\t\t\t \"Prefetch: ignoring giv at %d: %s.\\n\",\n+\t\t\t INSN_UID (iv->insn), ignore_reason);\n \t      continue;\n \t    }\n \n \t  /* Determine the pointer to the basic array we are examining.  It is\n \t     the sum of the BIV's initial value and the GIV's add_val.  */\n-\t  index = 0;\n-\n \t  address = copy_rtx (iv->add_val);\n \t  temp = copy_rtx (bl->initial_value);\n \n@@ -3901,7 +3936,7 @@ emit_prefetch_instructions (loop)\n \n \t  /* When the GIV is not always executed, we might be better off by\n \t     not dirtying the cache pages.  */\n-\t  if (PREFETCH_NOT_ALWAYS || iv->always_executed)\n+\t  if (PREFETCH_CONDITIONAL || iv->always_executed)\n \t    note_stores (PATTERN (iv->insn), check_store, &d);\n \n \t  /* Attempt to find another prefetch to the same array and see if we\n@@ -3914,13 +3949,14 @@ emit_prefetch_instructions (loop)\n \t\t   just with small difference in constant indexes), merge\n \t\t   the prefetches.  Just do the later and the earlier will\n \t\t   get prefetched from previous iteration.\n-\t\t   4096 is artificial threshold.  It should not be too small,\n+\t\t   The artificial threshold should not be too small,\n \t\t   but also not bigger than small portion of memory usually\n \t\t   traversed by single loop.  */\n-\t\tif (index >= info[i].index && index - info[i].index < 4096)\n+\t\tif (index >= info[i].index\n+\t\t    && index - info[i].index < PREFETCH_EXTREME_DIFFERENCE)\n \t\t  {\n \t\t    info[i].write |= d.mem_write;\n-\t\t    info[i].bytes_accesed += size;\n+\t\t    info[i].bytes_accessed += size;\n \t\t    info[i].index = index;\n \t\t    info[i].giv = iv;\n \t\t    info[i].class = bl;\n@@ -3929,10 +3965,11 @@ emit_prefetch_instructions (loop)\n \t\t    break;\n \t\t  }\n \n-\t\tif (index < info[i].index && info[i].index - index < 4096)\n+\t\tif (index < info[i].index\n+\t\t    && info[i].index - index < PREFETCH_EXTREME_DIFFERENCE)\n \t\t  {\n \t\t    info[i].write |= d.mem_write;\n-\t\t    info[i].bytes_accesed += size;\n+\t\t    info[i].bytes_accessed += size;\n \t\t    add = 0;\n \t\t    break;\n \t\t  }\n@@ -3947,7 +3984,7 @@ emit_prefetch_instructions (loop)\n \t      info[num_prefetches].stride = stride;\n \t      info[num_prefetches].base_address = address;\n \t      info[num_prefetches].write = d.mem_write;\n-\t      info[num_prefetches].bytes_accesed = size;\n+\t      info[num_prefetches].bytes_accessed = size;\n \t      num_prefetches++;\n \t      if (num_prefetches >= MAX_PREFETCHES)\n \t\t{\n@@ -3962,28 +3999,40 @@ emit_prefetch_instructions (loop)\n \n   for (i = 0; i < num_prefetches; i++)\n     {\n-      /* Attempt to calculate the number of bytes fetched by the loop.\n-\t Avoid overflow.  */\n+      int density;\n+\n+      /* Attempt to calculate the total number of bytes fetched by all\n+\t iterations of the loop.  Avoid overflow.  */\n       if (LOOP_INFO (loop)->n_iterations\n           && ((unsigned HOST_WIDE_INT) (0xffffffff / info[i].stride)\n \t      >= LOOP_INFO (loop)->n_iterations))\n \tinfo[i].total_bytes = info[i].stride * LOOP_INFO (loop)->n_iterations;\n       else\n \tinfo[i].total_bytes = 0xffffffff;\n \n-      /* Prefetch is worthwhile only when the loads/stores are dense.  */\n-      if (PREFETCH_ONLY_DENSE_MEM\n-\t  && info[i].bytes_accesed * 256 / info[i].stride > PREFETCH_DENSE_MEM\n-\t  && (info[i].total_bytes / PREFETCH_BLOCK\n-\t      >= PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n-\t{\n-\t  info[i].prefetch_before_loop = 1;\n-\t  info[i].prefetch_in_loop\n-\t    = (info[i].total_bytes / PREFETCH_BLOCK\n-\t       > PREFETCH_BLOCKS_BEFORE_LOOP_MAX);\n-\t}\n+      density = info[i].bytes_accessed * 100 / info[i].stride;\n+\n+      /* Prefetch might be worthwhile only when the loads/stores are dense.  */\n+      if (PREFETCH_ONLY_DENSE_MEM)\n+\tif (density * 256 > PREFETCH_DENSE_MEM * 100\n+\t    && (info[i].total_bytes / PREFETCH_BLOCK\n+\t        >= PREFETCH_BLOCKS_BEFORE_LOOP_MIN))\n+\t  {\n+\t    info[i].prefetch_before_loop = 1;\n+\t    info[i].prefetch_in_loop\n+\t      = (info[i].total_bytes / PREFETCH_BLOCK\n+\t         > PREFETCH_BLOCKS_BEFORE_LOOP_MAX);\n+\t  }\n+        else\n+\t  {\n+\t    info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n+\t    if (loop_dump_stream)\n+\t      fprintf (loop_dump_stream,\n+\t\t  \"Prefetch: ignoring giv at %d: %d%% density is too low.\\n\",\n+\t\t       INSN_UID (info[i].giv->insn), density);\n+\t  }\n       else\n-        info[i].prefetch_in_loop = 0, info[i].prefetch_before_loop = 0;\n+\tinfo[i].prefetch_in_loop = 1, info[i].prefetch_before_loop = 1;\n \n       if (info[i].prefetch_in_loop)\n \t{\n@@ -3999,23 +4048,30 @@ emit_prefetch_instructions (loop)\n     {\n       for (i = 0; i < num_prefetches; i++)\n \t{\n-\t  fprintf (loop_dump_stream, \"Prefetch insn %i address: \",\n+\t  if (info[i].prefetch_in_loop == 0\n+\t      && info[i].prefetch_before_loop == 0)\n+\t    continue;\n+\t  fprintf (loop_dump_stream, \"Prefetch insn: %d\",\n \t\t   INSN_UID (info[i].giv->insn));\n-\t  print_rtl (loop_dump_stream, info[i].base_address);\n-\t  fprintf (loop_dump_stream, \" Index: \");\n-\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].index);\n-\t  fprintf (loop_dump_stream, \" stride: \");\n-\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].stride);\n \t  fprintf (loop_dump_stream,\n-\t\t   \" density: %i%% total_bytes: %u%sin loop: %s before: %s\\n\",\n-\t\t   (int) (info[i].bytes_accesed * 100 / info[i].stride),\n-\t\t   info[i].total_bytes,\n-\t\t   info[i].write ? \" read/write \" : \" read only \",\n+\t\t   \"; in loop: %s; before: %s; %s\\n\",\n \t\t   info[i].prefetch_in_loop ? \"yes\" : \"no\",\n-\t\t   info[i].prefetch_before_loop ? \"yes\" : \"no\");\n+\t\t   info[i].prefetch_before_loop ? \"yes\" : \"no\",\n+\t\t   info[i].write ? \"read/write\" : \"read only\");\n+\t  fprintf (loop_dump_stream,\n+\t\t   \" density: %d%%; bytes_accessed: %u; total_bytes: %u\\n\",\n+\t\t   (int) (info[i].bytes_accessed * 100 / info[i].stride),\n+\t\t   info[i].bytes_accessed, info[i].total_bytes);\n+\t  fprintf (loop_dump_stream, \" index: \");\n+\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].index);\n+\t  fprintf (loop_dump_stream, \"; stride: \");\n+\t  fprintf (loop_dump_stream, HOST_WIDE_INT_PRINT_DEC, info[i].stride);\n+\t  fprintf (loop_dump_stream, \"; address: \");\n+\t  print_rtl (loop_dump_stream, info[i].base_address);\n+\t  fprintf (loop_dump_stream, \"\\n\");\n \t}\n \n-      fprintf (loop_dump_stream, \"Real prefetches needed: %i (write: %i)\\n\",\n+      fprintf (loop_dump_stream, \"Real prefetches needed: %d (write: %d)\\n\",\n \t       num_real_prefetches, num_real_write_prefetches);\n     }\n \n@@ -4024,8 +4080,14 @@ emit_prefetch_instructions (loop)\n \n   ahead = SIMULTANEOUS_PREFETCHES / num_real_prefetches;\n \n-  if (!ahead)\n-    return;\n+  if (ahead == 0)\n+    {\n+      if (loop_dump_stream)\n+\tfprintf (loop_dump_stream,\n+\t\t \"Prefetch: ignoring loop: ahead is zero; %d < %d\\n\",\n+\t\t SIMULTANEOUS_PREFETCHES, num_real_prefetches);\n+      return;\n+    }\n \n   for (i = 0; i < num_prefetches; i++)\n     {\n@@ -4077,7 +4139,7 @@ emit_prefetch_instructions (loop)\n \t    }\n \t}\n \n-      if (info[i].prefetch_before_loop)\n+      if (PREFETCH_BEFORE_LOOP && info[i].prefetch_before_loop)\n \t{\n \t  int y;\n "}]}