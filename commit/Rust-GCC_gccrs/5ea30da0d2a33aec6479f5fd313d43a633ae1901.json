{"sha": "5ea30da0d2a33aec6479f5fd313d43a633ae1901", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWVhMzBkYTBkMmEzM2FlYzY0NzlmNWZkMzEzZDQzYTYzM2FlMTkwMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-05-04T17:23:56Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-05-04T17:23:56Z"}, "message": "tree-outof-ssa.c (edge_leader, [...]): Use VEC instead of VARRAY.\n\n\t* tree-outof-ssa.c (edge_leader, stmt_list,\n\tanalyze_edges_for_bb): Use VEC instead of VARRAY.\n\t(init_analayze_edges_for_bb, fini_analayze_edges_for_bb): New.\n\t(perform_edge_inserts): Call init_analayze_edges_for_bb and\n\tfini_analayze_edges_for_bb.\n\nFrom-SVN: r99222", "tree": {"sha": "404841644a137d6e389d60c051b2497667242e96", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/404841644a137d6e389d60c051b2497667242e96"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5ea30da0d2a33aec6479f5fd313d43a633ae1901", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea30da0d2a33aec6479f5fd313d43a633ae1901", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5ea30da0d2a33aec6479f5fd313d43a633ae1901", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5ea30da0d2a33aec6479f5fd313d43a633ae1901/comments", "author": null, "committer": null, "parents": [{"sha": "10bf9e8a16dd0cca35fb8f553a65b260c89eb7df", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/10bf9e8a16dd0cca35fb8f553a65b260c89eb7df", "html_url": "https://github.com/Rust-GCC/gccrs/commit/10bf9e8a16dd0cca35fb8f553a65b260c89eb7df"}], "stats": {"total": 102, "additions": 63, "deletions": 39}, "files": [{"sha": "dedfdedd571618c3784141e1e567b9ed9a651621", "filename": "gcc/ChangeLog", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea30da0d2a33aec6479f5fd313d43a633ae1901/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea30da0d2a33aec6479f5fd313d43a633ae1901/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5ea30da0d2a33aec6479f5fd313d43a633ae1901", "patch": "@@ -1,3 +1,11 @@\n+2005-05-04  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* tree-outof-ssa.c (edge_leader, stmt_list,\n+\tanalyze_edges_for_bb): Use VEC instead of VARRAY.\n+\t(init_analayze_edges_for_bb, fini_analayze_edges_for_bb): New.\n+\t(perform_edge_inserts): Call init_analayze_edges_for_bb and\n+\tfini_analayze_edges_for_bb.\n+\n 2005-05-04  James E Wilson  <wilson@specifixinc.com>\n \n \tPR driver/21112"}, {"sha": "6fd7808720c7497c7899c6e208b4b1c878ffce28", "filename": "gcc/tree-outof-ssa.c", "status": "modified", "additions": 55, "deletions": 39, "changes": 94, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5ea30da0d2a33aec6479f5fd313d43a633ae1901/gcc%2Ftree-outof-ssa.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5ea30da0d2a33aec6479f5fd313d43a633ae1901/gcc%2Ftree-outof-ssa.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-outof-ssa.c?ref=5ea30da0d2a33aec6479f5fd313d43a633ae1901", "patch": "@@ -1920,10 +1920,12 @@ rewrite_trees (var_map map, tree *values)\n }\n \n \n+DEF_VEC_ALLOC_P(edge,heap);\n+\n /* These are the local work structures used to determine the best place to \n    insert the copies that were placed on edges by the SSA->normal pass..  */\n-static varray_type edge_leader = NULL;\n-static varray_type GTY(()) stmt_list = NULL;\n+static VEC(edge,heap) *edge_leader;\n+static VEC(tree,heap) *stmt_list;\n static bitmap leader_has_match = NULL;\n static edge leader_match = NULL;\n \n@@ -1989,6 +1991,28 @@ identical_stmt_lists_p (edge e1, edge e2)\n }\n \n \n+/* Allocate data structures used in analyze_edges_for_bb.   */\n+\n+static void\n+init_analyze_edges_for_bb (void)\n+{\n+  edge_leader = VEC_alloc (edge, heap, 25);\n+  stmt_list = VEC_alloc (tree, heap, 25);\n+  leader_has_match = BITMAP_ALLOC (NULL);\n+}\n+\n+\n+/* Free data structures used in analyze_edges_for_bb.   */\n+\n+static void\n+fini_analyze_edges_for_bb (void)\n+{\n+  VEC_free (edge, heap, edge_leader);\n+  VEC_free (tree, heap, stmt_list);\n+  BITMAP_FREE (leader_has_match);\n+}\n+\n+\n /* Look at all the incoming edges to block BB, and decide where the best place\n    to insert the stmts on each edge are, and perform those insertions.   Output\n    any debug information to DEBUG_FILE.  */\n@@ -2005,6 +2029,7 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n   tree stmt;\n   edge single_edge = NULL;\n   bool is_label;\n+  edge leader;\n \n   count = 0;\n \n@@ -2065,20 +2090,11 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n     }\n \n   /* Ensure that we have empty worklists.  */\n-  if (edge_leader == NULL)\n-    {\n-      VARRAY_EDGE_INIT (edge_leader, 25, \"edge_leader\");\n-      VARRAY_TREE_INIT (stmt_list, 25, \"stmt_list\");\n-      leader_has_match = BITMAP_ALLOC (NULL);\n-    }\n-  else\n-    {\n #ifdef ENABLE_CHECKING\n-      gcc_assert (VARRAY_ACTIVE_SIZE (edge_leader) == 0);\n-      gcc_assert (VARRAY_ACTIVE_SIZE (stmt_list) == 0);\n-      gcc_assert (bitmap_empty_p (leader_has_match));\n+  gcc_assert (VEC_length (edge, edge_leader) == 0);\n+  gcc_assert (VEC_length (tree, stmt_list) == 0);\n+  gcc_assert (bitmap_empty_p (leader_has_match));\n #endif\n-    }\n \n   /* Find the \"leader\" block for each set of unique stmt lists.  Preference is\n      given to FALLTHRU blocks since they would need a GOTO to arrive at another\n@@ -2092,9 +2108,8 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n \t  bool found = false;\n \n \t  /* Look for the same stmt list in edge leaders list.  */\n-\t  for (x = 0; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n+\t  for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n \t    {\n-\t      edge leader = VARRAY_EDGE (edge_leader, x);\n \t      if (identical_stmt_lists_p (leader, e))\n \t\t{\n \t\t  /* Give this edge the same stmt list pointer.  */\n@@ -2109,19 +2124,19 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n \t  /* If no similar stmt list, add this edge to the leader list.  */\n \t  if (!found)\n \t    {\n-\t      VARRAY_PUSH_EDGE (edge_leader, e);\n-\t      VARRAY_PUSH_TREE (stmt_list, PENDING_STMT (e));\n+\t      VEC_safe_push (edge, heap, edge_leader, e);\n+\t      VEC_safe_push (tree, heap, stmt_list, PENDING_STMT (e));\n \t    }\n \t}\n      }\n \n   /* If there are no similar lists, just issue the stmts.  */\n   if (!have_opportunity)\n     {\n-      for (x = 0; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n-\tbsi_commit_one_edge_insert (VARRAY_EDGE (edge_leader, x), NULL);\n-      VARRAY_POP_ALL (edge_leader);\n-      VARRAY_POP_ALL (stmt_list);\n+      for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n+\tbsi_commit_one_edge_insert (leader, NULL);\n+      VEC_truncate (edge, edge_leader, 0);\n+      VEC_truncate (tree, stmt_list, 0);\n       bitmap_clear (leader_has_match);\n       return;\n     }\n@@ -2134,30 +2149,30 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n   \n   /* For each common list, create a forwarding block and issue the stmt's\n      in that block.  */\n-  for (x = 0 ; x < VARRAY_ACTIVE_SIZE (edge_leader); x++)\n+  for (x = 0; VEC_iterate (edge, edge_leader, x, leader); x++)\n     if (bitmap_bit_p (leader_has_match, x))\n       {\n-\tedge new_edge, leader_edge;\n+\tedge new_edge;\n \tblock_stmt_iterator bsi;\n \ttree curr_stmt_list;\n \n-\tleader_match = leader_edge = VARRAY_EDGE (edge_leader, x);\n+\tleader_match = leader;\n \n \t/* The tree_* cfg manipulation routines use the PENDING_EDGE field\n \t   for various PHI manipulations, so it gets cleared whhen calls are \n \t   made to make_forwarder_block(). So make sure the edge is clear, \n \t   and use the saved stmt list.  */\n-\tPENDING_STMT (leader_edge) = NULL;\n-\tleader_edge->aux = leader_edge;\n-\tcurr_stmt_list = VARRAY_TREE (stmt_list, x);\n+\tPENDING_STMT (leader) = NULL;\n+\tleader->aux = leader;\n+\tcurr_stmt_list = VEC_index (tree, stmt_list, x);\n \n-        new_edge = make_forwarder_block (leader_edge->dest, same_stmt_list_p, \n+        new_edge = make_forwarder_block (leader->dest, same_stmt_list_p, \n \t\t\t\t\t NULL);\n \tbb = new_edge->dest;\n \tif (debug_file)\n \t  {\n \t    fprintf (debug_file, \"Splitting BB %d for Common stmt list.  \", \n-\t\t     leader_edge->dest->index);\n+\t\t     leader->dest->index);\n \t    fprintf (debug_file, \"Original block is now BB%d.\\n\", bb->index);\n \t    print_generic_stmt (debug_file, curr_stmt_list, TDF_VOPS);\n \t  }\n@@ -2170,23 +2185,22 @@ analyze_edges_for_bb (basic_block bb, FILE *debug_file)\n \t\t       e->src->index, e->dest->index);\n \t  }\n \n-\tbsi = bsi_last (leader_edge->dest);\n+\tbsi = bsi_last (leader->dest);\n \tbsi_insert_after (&bsi, curr_stmt_list, BSI_NEW_STMT);\n \n \tleader_match = NULL;\n \t/* We should never get a new block now.  */\n       }\n     else\n       {\n-        e = VARRAY_EDGE (edge_leader, x);\n-\tPENDING_STMT (e) = VARRAY_TREE (stmt_list, x);\n-\tbsi_commit_one_edge_insert (e, NULL);\n+\tPENDING_STMT (leader) = VEC_index (tree, stmt_list, x);\n+\tbsi_commit_one_edge_insert (leader, NULL);\n       }\n \n    \n   /* Clear the working data structures.  */\n-  VARRAY_POP_ALL (edge_leader);\n-  VARRAY_POP_ALL (stmt_list);\n+  VEC_truncate (edge, edge_leader, 0);\n+  VEC_truncate (tree, stmt_list, 0);\n   bitmap_clear (leader_has_match);\n }\n \n@@ -2212,14 +2226,16 @@ perform_edge_inserts (FILE *dump_file)\n   free_dominance_info (CDI_DOMINATORS);\n   free_dominance_info (CDI_POST_DOMINATORS);\n \n+  /* Allocate data structures used in analyze_edges_for_bb.   */\n+  init_analyze_edges_for_bb ();\n+\n   FOR_EACH_BB (bb)\n     analyze_edges_for_bb (bb, dump_file);\n \n   analyze_edges_for_bb (EXIT_BLOCK_PTR, dump_file);\n \n-  /* Clear out any tables which were created.  */\n-  edge_leader = NULL;\n-  BITMAP_FREE (leader_has_match);\n+  /* Free data structures used in analyze_edges_for_bb.   */\n+  fini_analyze_edges_for_bb ();\n \n #ifdef ENABLE_CHECKING\n   {"}]}