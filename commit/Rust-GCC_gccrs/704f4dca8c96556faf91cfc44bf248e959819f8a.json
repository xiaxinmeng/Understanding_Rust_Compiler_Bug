{"sha": "704f4dca8c96556faf91cfc44bf248e959819f8a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzA0ZjRkY2E4Yzk2NTU2ZmFmOTFjZmM0NGJmMjQ4ZTk1OTgxOWY4YQ==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:33:56Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1994-04-21T19:33:56Z"}, "message": "Add prototypes for static functions.\n\n(expand_fixups): New function.\n(fixup_gotos): Now static.\nDon't call bc_fixup_gotos with wrong type (but now probably wrong value).\n(bc_*): Now static.\n(expand_exit_loop_if_false): Call bc_expand_goto_internal with proper null\npointer.\n(expand_decl_init): Call bc_expand_decl_init if writing bytecode.\n\nFrom-SVN: r7121", "tree": {"sha": "2c3270cbc06d8d79af3296638d9c1077a22a8c33", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/2c3270cbc06d8d79af3296638d9c1077a22a8c33"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/704f4dca8c96556faf91cfc44bf248e959819f8a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704f4dca8c96556faf91cfc44bf248e959819f8a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/704f4dca8c96556faf91cfc44bf248e959819f8a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/704f4dca8c96556faf91cfc44bf248e959819f8a/comments", "author": null, "committer": null, "parents": [{"sha": "a035305579ecac7295297db723544014892a36f0", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a035305579ecac7295297db723544014892a36f0", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a035305579ecac7295297db723544014892a36f0"}], "stats": {"total": 49, "additions": 34, "deletions": 15}, "files": [{"sha": "a2a37d5a78b1368529469648fc04ec33424883ba", "filename": "gcc/stmt.c", "status": "modified", "additions": 34, "deletions": 15, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/704f4dca8c96556faf91cfc44bf248e959819f8a/gcc%2Fstmt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/704f4dca8c96556faf91cfc44bf248e959819f8a/gcc%2Fstmt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fstmt.c?ref=704f4dca8c96556faf91cfc44bf248e959819f8a", "patch": "@@ -1085,7 +1085,7 @@ bc_expand_fixup (opcode, label, stack_level)\n    contour from before the beginning of the contour.\n    This is also done if STACK_LEVEL is nonzero.  */\n \n-void\n+static void\n fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n      struct nesting *thisblock;\n      rtx stack_level;\n@@ -1097,7 +1097,10 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n \n   if (output_bytecode)\n     {\n-      bc_fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in);\n+      /* ??? The second arg is the bc stack level, which is not the same\n+\t as STACK_LEVEL.  I have no idea what should go here, so I'll\n+\t just pass 0.  */\n+      bc_fixup_gotos (thisblock, 0, cleanup_list, first_insn, dont_jump_in);\n       return;\n     }\n \n@@ -1238,8 +1241,8 @@ fixup_gotos (thisblock, stack_level, cleanup_list, first_insn, dont_jump_in)\n /* When exiting a binding contour, process all pending gotos requiring fixups.\n    Note: STACK_DEPTH is not altered.\n \n-   The arguments are currently not used in the bytecode compiler, but we may need\n-   them one day for languages other than C.\n+   The arguments are currently not used in the bytecode compiler, but we may\n+   need them one day for languages other than C.\n \n    THISBLOCK is the structure that describes the block being exited.\n    STACK_LEVEL is the rtx for the stack level to restore exiting this contour.\n@@ -2249,7 +2252,8 @@ expand_end_cond ()\n    whose truth is to be tested; if EXITFLAG is nonzero this conditional\n    is to be visible to exit_something.  It is assumed that the caller\n    has pushed the previous context on the cond stack. */\n-void\n+\n+static void\n bc_expand_start_cond (cond, exitflag)\n      tree cond;\n      int exitflag;\n@@ -2270,7 +2274,8 @@ bc_expand_start_cond (cond, exitflag)\n \n /* Generate the label for the end of an if with\n    no else- clause.  */\n-void\n+\n+static void\n bc_expand_end_cond ()\n {\n   struct nesting *thiscond = cond_stack;\n@@ -2280,7 +2285,8 @@ bc_expand_end_cond ()\n \n /* Generate code for the start of the else- clause of\n    an if-then-else.  */\n-void\n+\n+static void\n bc_expand_start_else ()\n {\n   struct nesting *thiscond = cond_stack;\n@@ -2367,6 +2373,7 @@ expand_loop_continue_here ()\n }\n \n /* End a loop.  */\n+\n static void\n bc_expand_end_loop ()\n {\n@@ -2556,7 +2563,7 @@ expand_exit_loop_if_false (whichloop, cond)\n       bc_expand_expr (cond);\n       bc_expand_goto_internal (xjumpifnot,\n \t\t\t       BYTECODE_BC_LABEL (whichloop->exit_label),\n-\t\t\t       NULL_RTX);\n+\t\t\t       NULL_TREE);\n     }\n   else\n     do_jump (cond, whichloop->data.loop.end_label, NULL_RTX);\n@@ -3310,7 +3317,7 @@ expand_end_bindings (vars, mark_ends, dont_jump_in)\n    DONT_JUMP_IN is nonzero if it is not valid to jump into this\n    contour.  */\n \n-void\n+static void\n bc_expand_end_bindings (vars, mark_ends, dont_jump_in)\n      tree vars;\n      int mark_ends;\n@@ -3554,7 +3561,7 @@ expand_decl (decl)\n    compiler sometimes emits cleanups without variables and we will\n    have to deal with those too.  */\n \n-void\n+static void\n bc_expand_decl (decl, cleanup)\n      tree decl;\n      tree cleanup;\n@@ -3602,6 +3609,12 @@ expand_decl_init (decl)\n {\n   int was_used = TREE_USED (decl);\n \n+  if (output_bytecode)\n+    {\n+      bc_expand_decl_init (decl);\n+      return;\n+    }\n+\n   /* If this is a CONST_DECL, we don't have to generate any code, but\n      if DECL_INITIAL is a constant, call expand_expr to force TREE_CST_RTL\n      to be set while in the obstack containing the constant.  If we don't\n@@ -3648,6 +3661,7 @@ expand_decl_init (decl)\n    using newlocalSI and set local variable, which is a pointer to the\n    storage. */\n \n+static void\n bc_expand_variable_local_init (decl)\n      tree decl;\n {\n@@ -3677,7 +3691,8 @@ bc_expand_variable_local_init (decl)\n \n \n /* Emit code to initialize a declaration.  */\n-void\n+\n+static void\n bc_expand_decl_init (decl)\n      tree decl;\n {\n@@ -3956,7 +3971,8 @@ expand_start_case (exit_flag, expr, type, printname)\n \n /* Enter a case statement. It is assumed that the caller has pushed\n    the current context onto the case stack. */\n-void\n+\n+static void\n bc_expand_start_case (thiscase, expr, type, printname)\n      struct nesting *thiscase;\n      tree expr;\n@@ -4269,7 +4285,7 @@ pushcase_range (value1, value2, converter, label, duplicate)\n    bytecode compiler, which was based on gcc 1.37.  It should be\n    merged into pushcase. */\n \n-int\n+static int\n bc_pushcase (value, label)\n      tree value;\n      tree label;\n@@ -4445,7 +4461,8 @@ check_for_full_enumeration_handling (type)\n /* Check that all enumeration literals are covered by the case\n    expressions of a switch.  Also warn if there are any cases\n    that are not elements of the enumerated type.  */\n-void\n+\n+static void\n bc_check_for_full_enumeration_handling (type)\n      tree type;\n {\n@@ -4855,7 +4872,8 @@ expand_end_case (orig_index)\n \n /* Terminate a case statement.  EXPR is the original index\n    expression.  */\n-void\n+\n+static void\n bc_expand_end_case (expr)\n      tree expr;\n {\n@@ -4947,6 +4965,7 @@ bc_expand_end_case (expr)\n \n \n /* Return unique bytecode ID. */\n+\n int \n bc_new_uid ()\n {"}]}