{"sha": "1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MWJlYzljYWFjYjY5MjZkZjZlZTFhN2E2YjdmZjA4YWE4YmQ0OTNmNA==", "commit": {"author": {"name": "Nathan Sidwell", "email": "nathan@acm.org", "date": "2011-11-13T10:26:23Z"}, "committer": {"name": "Nathan Sidwell", "email": "nathan@gcc.gnu.org", "date": "2011-11-13T10:26:23Z"}, "message": "gcov.c (source_prefix, [...]): New globals.\n\n\t* gcov.c (source_prefix, source_length): New globals.\n\t(flag_relative_only): Likewise.\n\t(print_usage, options, process_args): Update.\n\t(generate_results): Use coverage.name, check\n\tflag_relative_only. Adjust messages.\n\t(find_source): Check source_prefix.\n\t(output_lines): Use coverage.name, adjust messages.\n\t* doc/gcov.texi (Invoking Gcov): Document new options.\n\nFrom-SVN: r181335", "tree": {"sha": "db8b1032f2c4a713653809c8dfd7585282f689ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/db8b1032f2c4a713653809c8dfd7585282f689ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/comments", "author": {"login": "urnathan", "id": 13103001, "node_id": "MDQ6VXNlcjEzMTAzMDAx", "avatar_url": "https://avatars.githubusercontent.com/u/13103001?v=4", "gravatar_id": "", "url": "https://api.github.com/users/urnathan", "html_url": "https://github.com/urnathan", "followers_url": "https://api.github.com/users/urnathan/followers", "following_url": "https://api.github.com/users/urnathan/following{/other_user}", "gists_url": "https://api.github.com/users/urnathan/gists{/gist_id}", "starred_url": "https://api.github.com/users/urnathan/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/urnathan/subscriptions", "organizations_url": "https://api.github.com/users/urnathan/orgs", "repos_url": "https://api.github.com/users/urnathan/repos", "events_url": "https://api.github.com/users/urnathan/events{/privacy}", "received_events_url": "https://api.github.com/users/urnathan/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "2c6f792709071cd3492a10b79924674924f7fb1c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2c6f792709071cd3492a10b79924674924f7fb1c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2c6f792709071cd3492a10b79924674924f7fb1c"}], "stats": {"total": 101, "additions": 88, "deletions": 13}, "files": [{"sha": "96c96ae816a3393397b268aa65566ff891680b66", "filename": "gcc/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "patch": "@@ -1,3 +1,14 @@\n+2011-11-13  Nathan Sidwell  <nathan@acm.org>\n+\n+\t* gcov.c (source_prefix, source_length): New globals.\n+\t(flag_relative_only): Likewise.\n+\t(print_usage, options, process_args): Update.\n+\t(generate_results): Use coverage.name, check\n+\tflag_relative_only. Adjust messages.\n+\t(find_source): Check source_prefix.\n+\t(output_lines): Use coverage.name, adjust messages.\n+\t* doc/gcov.texi (Invoking Gcov): Document new options.\n+\n 2011-11-12  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/51060"}, {"sha": "640d52e128467e7d77bc929d7d346d5f159c8be9", "filename": "gcc/doc/gcov.texi", "status": "modified", "additions": 20, "deletions": 2, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2Fdoc%2Fgcov.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2Fdoc%2Fgcov.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Fgcov.texi?ref=1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "patch": "@@ -124,13 +124,16 @@ gcov [@option{-v}|@option{--version}] [@option{-h}|@option{--help}]\n      [@option{-a}|@option{--all-blocks}]\n      [@option{-b}|@option{--branch-probabilities}]\n      [@option{-c}|@option{--branch-counts}]\n+     [@option{-u}|@option{--unconditional-branches}]\n      [@option{-n}|@option{--no-output}]\n      [@option{-l}|@option{--long-file-names}]\n      [@option{-p}|@option{--preserve-paths}]\n+     [@option{-r}|@option{--relative-only}]\n      [@option{-f}|@option{--function-summaries}]\n-     [@option{-o}|@option{--object-directory} @var{directory|file}] @var{sourcefiles}\n-     [@option{-u}|@option{--unconditional-branches}]\n+     [@option{-o}|@option{--object-directory} @var{directory|file}]\n+     [@option{-s}|@option{--source-prefix} @var{directory}]\n      [@option{-d}|@option{--display-progress}]\n+     @var{files}\n @c man end\n @c man begin SEEALSO\n gpl(7), gfdl(7), fsf-funding(7), gcc(1) and the Info entry for @file{gcc}.\n@@ -193,6 +196,13 @@ removed and unremoveable @file{..}\n components renamed to @samp{^}.  This is useful if sourcefiles are in several\n different directories.\n \n+@item -r\n+@itemx --relative-only\n+Only output information about source files with a relative pathname\n+(after source prefix elision).  Absolute paths are usually system\n+header files and coverage of any inline functions therein is normally\n+uninteresting.\n+\n @item -f\n @itemx --function-summaries\n Output summaries for each function in addition to the file level summary.\n@@ -207,6 +217,14 @@ is specified, the data files are in that directory and named after the\n input file name, without its extension.  If a file is specified here,\n the data files are named after that file, without its extension.\n \n+@item -s @var{directory}\n+@itemx --source-prefix @var{directory}\n+A prefix for source file names to remove when generating the output\n+coverage files.  This option is useful when building in a separate\n+directory, and the pathname to the source directory is not wanted when\n+determining the output file names.  Note that this prefix detection is\n+applied before determining whether the source file is absolute.\n+\n @item -u\n @itemx --unconditional-branches\n When branch probabilities are given, include those of unconditional branches."}, {"sha": "038c36d0ac1c6803315fd0740e582f7fb7367e8f", "filename": "gcc/gcov.c", "status": "modified", "additions": 57, "deletions": 11, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2Fgcov.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4/gcc%2Fgcov.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgcov.c?ref=1bec9caacb6926df6ee1a7a6b7ff08aa8bd493f4", "patch": "@@ -333,6 +333,17 @@ static int flag_function_summary = 0;\n \n static char *object_directory = 0;\n \n+/* Source directory prefix.  This is removed from source pathnames\n+   that match, when generating the output file name.  */\n+\n+static char *source_prefix = 0;\n+static size_t source_length = 0;\n+\n+/* Only show data for sources with relative pathnames.  Absolute ones\n+   usually indicate a system header file, which although it may\n+   contain inline functions, is usually uninteresting.  */\n+static int flag_relative_only = 0;\n+\n /* Preserve all pathname components. Needed when object files and\n    source files are in subdirectories. '/' is mangled as '#', '.' is\n    elided and '..' mangled to '^'.  */\n@@ -441,6 +452,8 @@ print_usage (int error_p)\n                                     source files\\n\");\n   fnotice (file, \"  -f, --function-summaries        Output summaries for each function\\n\");\n   fnotice (file, \"  -o, --object-directory DIR|FILE Search for object files in DIR or called FILE\\n\");\n+  fnotice (file, \"  -s, --source-prefix DIR         Source prefix to elide\\n\");\n+  fnotice (file, \"  -r, --relative-only             Only show data for relative sources\\n\");\n   fnotice (file, \"  -p, --preserve-paths            Preserve all pathname components\\n\");\n   fnotice (file, \"  -u, --unconditional-branches    Show unconditional branch counts too\\n\");\n   fnotice (file, \"  -d, --display-progress          Display progress information\\n\");\n@@ -475,8 +488,10 @@ static const struct option options[] =\n   { \"long-file-names\",      no_argument,       NULL, 'l' },\n   { \"function-summaries\",   no_argument,       NULL, 'f' },\n   { \"preserve-paths\",       no_argument,       NULL, 'p' },\n+  { \"relative-only\",        no_argument,       NULL, 'r' },\n   { \"object-directory\",     required_argument, NULL, 'o' },\n   { \"object-file\",          required_argument, NULL, 'o' },\n+  { \"source-prefix\",        required_argument, NULL, 's' },\n   { \"unconditional-branches\", no_argument,     NULL, 'u' },\n   { \"display-progress\",     no_argument,       NULL, 'd' },\n   { 0, 0, 0, 0 }\n@@ -489,7 +504,7 @@ process_args (int argc, char **argv)\n {\n   int opt;\n \n-  while ((opt = getopt_long (argc, argv, \"abcdfhlno:puv\", options, NULL)) != -1)\n+  while ((opt = getopt_long (argc, argv, \"abcdfhlno:s:pruv\", options, NULL)) != -1)\n     {\n       switch (opt)\n \t{\n@@ -517,6 +532,13 @@ process_args (int argc, char **argv)\n \tcase 'o':\n \t  object_directory = optarg;\n \t  break;\n+\tcase 's':\n+\t  source_prefix = optarg;\n+\t  source_length = strlen (source_prefix);\n+\t  break;\n+\tcase 'r':\n+\t  flag_relative_only = 1;\n+\t  break;\n \tcase 'p':\n \t  flag_preserve_paths = 1;\n \t  break;\n@@ -641,33 +663,47 @@ generate_results (const char *file_name)\n       name_map_t *name_map = (name_map_t *)bsearch\n \t(file_name, names, n_names, sizeof (*names), name_search);\n       if (name_map)\n-\tfile_name = sources[name_map->src].name;\n+\tfile_name = sources[name_map->src].coverage.name;\n       else\n \tfile_name = canonicalize_name (file_name);\n     }\n   \n   for (ix = n_sources, src = sources; ix--; src++)\n     {\n+      if (flag_relative_only)\n+\t{\n+\t  /* Ignore this source, if it is an absolute path (after\n+\t     source prefix removal).  */\n+\t  char first = src->coverage.name[0];\n+      \n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+\t  if (first && src->coverage.name[1] == ':')\n+\t    first = src->coverage.name[2]\n+#endif\n+\t    if (IS_DIR_SEPARATOR (first))\n+\t      continue;\n+\t}\n+      \n       accumulate_line_counts (src);\n       function_summary (&src->coverage, \"File\");\n       if (flag_gcov_file && src->coverage.lines)\n \t{\n-\t  char *gcov_file_name = make_gcov_file_name (file_name, src->name);\n+\t  char *gcov_file_name\n+\t    = make_gcov_file_name (file_name, src->coverage.name);\n \t  FILE *gcov_file = fopen (gcov_file_name, \"w\");\n \n \t  if (gcov_file)\n \t    {\n-\t      fnotice (stdout, \"%s:creating '%s'\\n\",\n-\t\t       src->name, gcov_file_name);\n+\t      fnotice (stdout, \"Creating '%s'\\n\", gcov_file_name);\n \t      output_lines (gcov_file, src);\n \t      if (ferror (gcov_file))\n-\t\t    fnotice (stderr, \"%s:error writing output file '%s'\\n\",\n-\t\t\t     src->name, gcov_file_name);\n+\t\t    fnotice (stderr, \"Error writing output file '%s'\\n\",\n+\t\t\t     gcov_file_name);\n \t      fclose (gcov_file);\n \t    }\n \t  else\n-\t    fnotice (stderr, \"%s:could not open output file '%s'\\n\",\n-\t\t     src->name, gcov_file_name);\n+\t    fnotice (stderr, \"Could not open output file '%s'\\n\",\n+\t\t     gcov_file_name);\n \t  free (gcov_file_name);\n \t}\n       fnotice (stdout, \"\\n\");\n@@ -877,6 +913,16 @@ find_source (const char *file_name)\n       memset (src, 0, sizeof (*src));\n       src->name = canon;\n       src->coverage.name = src->name;\n+      if (source_length\n+#if HAVE_DOS_BASED_FILE_SYSTEM\n+\t  /* You lose if separators don't match exactly in the\n+\t     prefix.  */\n+\t  && !strncasecmp (source_prefix, src->coverage.name, source_length)\n+#else\n+\t  && !strncmp (source_prefix, src->coverage.name, source_length)\n+#endif\n+\t  && IS_DIR_SEPARATOR (src->coverage.name[source_length]))\n+\tsrc->coverage.name += source_length + 1;\n       if (!stat (src->name, &status))\n \tsrc->file_time = status.st_mtime;\n     }\n@@ -2079,7 +2125,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n   char const *retval = \"\";\t/* status of source file reading.  */\n   function_t *fn = NULL;\n \n-  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, src->name);\n+  fprintf (gcov_file, \"%9s:%5d:Source:%s\\n\", \"-\", 0, src->coverage.name);\n   if (!multiple_files)\n     {\n       fprintf (gcov_file, \"%9s:%5d:Graph:%s\\n\", \"-\", 0, bbg_file_name);\n@@ -2092,7 +2138,7 @@ output_lines (FILE *gcov_file, const source_t *src)\n   source_file = fopen (src->name, \"r\");\n   if (!source_file)\n     {\n-      fnotice (stderr, \"%s:cannot open source file\\n\", src->name);\n+      fnotice (stderr, \"Cannot open source file %s\\n\", src->name);\n       retval = NULL;\n     }\n   else if (src->file_time == 0)"}]}