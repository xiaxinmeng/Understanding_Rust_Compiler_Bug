{"sha": "8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGQxYTFjYjFiODE2MzgxYmY2MGNiMTIxMWM5M2I4ZWJhMWZlMTQ3Mg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-02-19T08:13:44Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2020-02-19T08:13:44Z"}, "message": "libgomp: Fixes + cleanup for OpenACC's Fortran module + openacc_lib.h\n\n2020-02-19  Tobias Burnus  <tobias@codesourcery.com>\n\n\t* .gitattributes: New; whitespace handling for Fortran's openacc_lib.h.\n\t* config/accel/openacc.f90 (openacc_kinds): Add acc_device_current.\n\t(openacc_internal, acc_on_device_h): Fix argument name; minor cleanup.\n\t* libgomp.texi (Enabling OpenACC): No longer mark as experimental.\n\t(acc_set_device_num): Fix Fortran argument name, use same name for C.\n\t(acc_get_property): Update Fortran interface to post-OpenACC 3.0\n\tcorrections; add note about the previous interface and named constant.\n\t(OpenACC library and environment variables): Fix two typos.\n\t* openacc.f90: Use for all procedures the argument names from the spec\n\tas for \u2026_h they are user visible.\n\t(openacc_kinds): Rename acc_device_property to\n\tacc_device_property_kinds and change value to int32 ; and update users.\n\tRe-add acc_device_property for for backward compatibility.\n\t(acc_get_property_string_h): Clean up as acc_device_property_kind\n\tchanged.\n\t(acc_get_property_h): Likewise and return c_size_t instead of\n\tacc_device_property.\n\t(openacc): Also export acc_device_property_kinds.\n\t(acc_async_test_h, acc_async_test_all_h, acc_on_device_h,\n\tacc_is_present_32_h, acc_is_present_64_h): Simplify logical-return-value\n\thandling; check against /= 0 instead of == 1 to match C.\n\t* openacc_lib.h: Use for all procedures the argument names from the spec\n\tas for \u2026_h they are user visible. Place !GCC$ into the first column to\n\tbe active also for fixed-form souce form.\n\t(acc_device_current, acc_device_property_kind, acc_device_property,\n\tacc_property_memory, acc_property_free_memory, acc_property_name,\n\tacc_property_vendor, acc_property_driver): New named constants.\n\t(acc_get_property, acc_get_property_string): New generic interface.", "tree": {"sha": "baab5a8f2b5eb4dcce96797a167bad8d735719ed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/baab5a8f2b5eb4dcce96797a167bad8d735719ed"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "bfe78b08471fa6daffb8e8e8e70bd5b1d3071ff6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bfe78b08471fa6daffb8e8e8e70bd5b1d3071ff6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bfe78b08471fa6daffb8e8e8e70bd5b1d3071ff6"}], "stats": {"total": 505, "additions": 280, "deletions": 225}, "files": [{"sha": "47e74eb6acd81974a02c4f9409f8fc11111afae8", "filename": "libgomp/.gitattributes", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2F.gitattributes", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2F.gitattributes", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2F.gitattributes?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -0,0 +1,2 @@\n+# For the Fortran file, complain about tabs\n+openacc_lib.h whitespace=tab-in-indent,space-before-tab,trailing-space"}, {"sha": "3c640c7350ba0bd4e20ee7db7808b2dbd8cbf769", "filename": "libgomp/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2FChangeLog?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -1,3 +1,34 @@\n+2020-02-19  Tobias Burnus  <tobias@codesourcery.com>\n+\n+\t* .gitattributes: New; whitespace handling for Fortran's openacc_lib.h.\n+\t* config/accel/openacc.f90 (openacc_kinds): Add acc_device_current.\n+\t(openacc_internal, acc_on_device_h): Fix argument name; minor cleanup.\n+\t* libgomp.texi (Enabling OpenACC): No longer mark as experimental.\n+\t(acc_set_device_num): Fix Fortran argument name, use same name for C.\n+\t(acc_get_property): Update Fortran interface to post-OpenACC 3.0\n+\tcorrections; add note about the previous interface and named constant.\n+\t(OpenACC library and environment variables): Fix two typos.\n+\t* openacc.f90: Use for all procedures the argument names from the spec\n+\tas for \u2026_h they are user visible.\n+\t(openacc_kinds): Rename acc_device_property to\n+\tacc_device_property_kinds and change value to int32 ; and update users.\n+\tRe-add acc_device_property for for backward compatibility.\n+\t(acc_get_property_string_h): Clean up as acc_device_property_kind\n+\tchanged.\n+\t(acc_get_property_h): Likewise and return c_size_t instead of\n+\tacc_device_property.\n+\t(openacc): Also export acc_device_property_kinds.\n+\t(acc_async_test_h, acc_async_test_all_h, acc_on_device_h,\n+\tacc_is_present_32_h, acc_is_present_64_h): Simplify logical-return-value\n+\thandling; check against /= 0 instead of == 1 to match C.\n+\t* openacc_lib.h: Use for all procedures the argument names from the spec\n+\tas for \u2026_h they are user visible. Place !GCC$ into the first column to\n+\tbe active also for fixed-form souce form.\n+\t(acc_device_current, acc_device_property_kind, acc_device_property,\n+\tacc_property_memory, acc_property_free_memory, acc_property_name,\n+\tacc_property_vendor, acc_property_driver): New named constants.\n+\t(acc_get_property, acc_get_property_string): New generic interface.\n+\n 2020-02-13  Frederik Harwath  <frederik@codesourcery.com>\n \n \tPR libgomp/93481"}, {"sha": "275afe43475c475e15a1d03cda47b489ac52335c", "filename": "libgomp/config/accel/openacc.f90", "status": "modified", "additions": 8, "deletions": 11, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fconfig%2Faccel%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fconfig%2Faccel%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fconfig%2Faccel%2Fopenacc.f90?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -44,6 +44,7 @@ module openacc_kinds\n   integer, parameter :: acc_device_kind = int32\n \n   ! Keep in sync with include/gomp-constants.h.\n+  integer (acc_device_kind), parameter :: acc_device_current = -3\n   integer (acc_device_kind), parameter :: acc_device_none = 0\n   integer (acc_device_kind), parameter :: acc_device_default = 1\n   integer (acc_device_kind), parameter :: acc_device_host = 2\n@@ -59,19 +60,19 @@ module openacc_internal\n   implicit none\n \n   interface\n-    function acc_on_device_h (d)\n+    function acc_on_device_h (devicetype)\n       import\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n       logical acc_on_device_h\n     end function\n   end interface\n \n   interface\n-    function acc_on_device_l (d) &\n+    function acc_on_device_l (devicetype) &\n         bind (C, name = \"acc_on_device\")\n       use iso_c_binding, only: c_int\n       integer (c_int) :: acc_on_device_l\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end function\n   end interface\n end module openacc_internal\n@@ -96,14 +97,10 @@ module openacc\n \n end module openacc\n \n-function acc_on_device_h (d)\n+function acc_on_device_h (devicetype)\n   use openacc_internal, only: acc_on_device_l\n   use openacc_kinds\n-  integer (acc_device_kind) d\n+  integer (acc_device_kind) devicetype\n   logical acc_on_device_h\n-  if (acc_on_device_l (d) .eq. 1) then\n-    acc_on_device_h = .TRUE.\n-  else\n-    acc_on_device_h = .FALSE.\n-  end if\n+  acc_on_device_h = acc_on_device_l (devicetype) /= 0\n end function"}, {"sha": "b946743f9b1abcdbfd1add5d8ce406c9acee6dd8", "filename": "libgomp/libgomp.texi", "status": "modified", "additions": 17, "deletions": 10, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Flibgomp.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Flibgomp.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Flibgomp.texi?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -1818,14 +1818,12 @@ flag @option{-fopenacc} must be specified.  This enables the OpenACC directive\n arranges for automatic linking of the OpenACC runtime library \n (@ref{OpenACC Runtime Library Routines}).\n \n+See @uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n+\n A complete description of all OpenACC directives accepted may be found in \n the @uref{https://www.openacc.org, OpenACC} Application Programming\n Interface manual, version 2.6.\n \n-Note that this is an experimental feature and subject to\n-change in future versions of GCC.  See\n-@uref{https://gcc.gnu.org/wiki/OpenACC} for more information.\n-\n \n \n @c ---------------------------------------------------------------------\n@@ -1992,12 +1990,12 @@ parallel or kernels region.\n @table @asis\n @item @emph{Description}\n This function will indicate to the runtime which device number,\n-specified by @var{num}, associated with the specified device\n+specified by @var{devicenum}, associated with the specified device\n type @var{devicetype}.\n \n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n-@item @emph{Prototype}: @tab @code{acc_set_device_num(int num, acc_device_t devicetype);}\n+@item @emph{Prototype}: @tab @code{acc_set_device_num(int devicenum, acc_device_t devicetype);}\n @end multitable\n \n @item @emph{Fortran}:\n@@ -2055,6 +2053,14 @@ The Fortran @code{acc_get_property_string} subroutine returns the string\n retrieved in its fourth argument while the remaining entry points are\n functions, which pass the return value as their result.\n \n+Note for Fortran, only: the OpenACC technical committee corrected and, hence,\n+modified the interface introduced in OpenACC 2.6.  The kind-value parameter\n+@code{acc_device_property} has been renamed to @code{acc_device_property_kind}\n+for consistency and the return type of the @code{acc_get_property} function is\n+now a @code{c_size_t} integer instead of a @code{acc_device_property} integer.\n+The parameter @code{acc_device_property} will continue to be provided,\n+but might be removed in a future version of GCC.\n+\n @item @emph{C/C++}:\n @multitable @columnfractions .20 .80\n @item @emph{Prototype}: @tab @code{size_t acc_get_property(int devicenum, acc_device_t devicetype, acc_device_property_t property);}\n@@ -2065,10 +2071,11 @@ functions, which pass the return value as their result.\n @multitable @columnfractions .20 .80\n @item @emph{Interface}: @tab @code{function acc_get_property(devicenum, devicetype, property)}\n @item @emph{Interface}: @tab @code{subroutine acc_get_property_string(devicenum, devicetype, property, string)}\n+@item                   @tab @code{use ISO_C_Binding, only: c_size_t}\n @item                   @tab @code{integer devicenum}\n @item                   @tab @code{integer(kind=acc_device_kind) devicetype}\n-@item                   @tab @code{integer(kind=acc_device_property) property}\n-@item                   @tab @code{integer(kind=acc_device_property) acc_get_property}\n+@item                   @tab @code{integer(kind=acc_device_property_kind) property}\n+@item                   @tab @code{integer(kind=c_size_t) acc_get_property}\n @item                   @tab @code{character(*) string}\n @end multitable\n \n@@ -3331,8 +3338,8 @@ similarly to the first use case.\n \n There are two environment variables associated with the OpenACC library\n that may be used to control the device type and device number:\n-@env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}, respecively. These two\n-environement variables can be used as an alternative to calling\n+@env{ACC_DEVICE_TYPE} and @env{ACC_DEVICE_NUM}, respectively. These two\n+environment variables can be used as an alternative to calling\n @code{acc_set_device_num()}. As seen in the second use case, the device\n type and device number were specified using @code{acc_set_device_num()}.\n If however, the aforementioned environment variables were set, then the"}, {"sha": "467fb612c548948f561d842cacfc94e05d3910ca", "filename": "libgomp/openacc.f90", "status": "modified", "additions": 128, "deletions": 153, "changes": 281, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fopenacc.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fopenacc.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc.f90?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -31,11 +31,10 @@\n \n module openacc_kinds\n   use iso_fortran_env, only: int32\n-  use iso_c_binding, only: c_size_t\n   implicit none\n \n   public\n-  private :: int32, c_size_t\n+  private :: int32\n \n   ! When adding items, also update 'public' setting in 'module openacc' below.\n \n@@ -51,14 +50,17 @@ module openacc_kinds\n   integer (acc_device_kind), parameter :: acc_device_nvidia = 5\n   integer (acc_device_kind), parameter :: acc_device_radeon = 8\n \n-  integer, parameter :: acc_device_property = c_size_t\n+  integer, parameter :: acc_device_property_kind = int32\n+  ! OpenACC 2.6/2.7/3.0 used acc_device_property; in a spec update the\n+  ! missing '_kind' was added for consistency.  For backward compatibility, keep:\n+  integer, parameter :: acc_device_property = acc_device_property_kind\n \n   ! Keep in sync with 'libgomp/libgomp-plugin.h:goacc_property'.\n-  integer (acc_device_property), parameter :: acc_property_memory = 1\n-  integer (acc_device_property), parameter :: acc_property_free_memory = 2\n-  integer (acc_device_property), parameter :: acc_property_name = int(Z'10001')\n-  integer (acc_device_property), parameter :: acc_property_vendor = int(Z'10002')\n-  integer (acc_device_property), parameter :: acc_property_driver = int(Z'10003')\n+  integer (acc_device_property_kind), parameter :: acc_property_memory = 1\n+  integer (acc_device_property_kind), parameter :: acc_property_free_memory = 2\n+  integer (acc_device_property_kind), parameter :: acc_property_name = int(Z'10001')\n+  integer (acc_device_property_kind), parameter :: acc_property_vendor = int(Z'10002')\n+  integer (acc_device_property_kind), parameter :: acc_property_driver = int(Z'10003')\n \n   integer, parameter :: acc_handle_kind = int32\n \n@@ -72,89 +74,90 @@ module openacc_internal\n   implicit none\n \n   interface\n-    function acc_get_num_devices_h (d)\n+    function acc_get_num_devices_h (devicetype)\n       import\n       integer acc_get_num_devices_h\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n     end function\n \n-    subroutine acc_set_device_type_h (d)\n+    subroutine acc_set_device_type_h (devicetype)\n       import\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n     end subroutine\n \n     function acc_get_device_type_h ()\n       import\n       integer (acc_device_kind) acc_get_device_type_h\n     end function\n \n-    subroutine acc_set_device_num_h (n, d)\n+    subroutine acc_set_device_num_h (devicenum, devicetype)\n       import\n-      integer n\n-      integer (acc_device_kind) d\n+      integer devicenum\n+      integer (acc_device_kind) devicetype\n     end subroutine\n \n-    function acc_get_device_num_h (d)\n+    function acc_get_device_num_h (devicetype)\n       import\n       integer acc_get_device_num_h\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n     end function\n \n-    function acc_get_property_h (n, d, p)\n+    function acc_get_property_h (devicenum, devicetype, property)\n+      use iso_c_binding, only: c_size_t\n       import\n       implicit none (type, external)\n-      integer (acc_device_property) :: acc_get_property_h\n-      integer, value :: n\n-      integer (acc_device_kind), value :: d\n-      integer (acc_device_property), value :: p\n+      integer (c_size_t) :: acc_get_property_h\n+      integer, value :: devicenum\n+      integer (acc_device_kind), value :: devicetype\n+      integer (acc_device_property_kind), value :: property\n     end function\n \n-    subroutine acc_get_property_string_h (n, d, p, s)\n+    subroutine acc_get_property_string_h (devicenum, devicetype, property, string)\n       import\n       implicit none (type, external)\n-      integer, value :: n\n-      integer (acc_device_kind), value :: d\n-      integer (acc_device_property), value :: p\n-      character (*) :: s\n+      integer, value :: devicenum\n+      integer (acc_device_kind), value :: devicetype\n+      integer (acc_device_property_kind), value :: property\n+      character (*) :: string\n     end subroutine\n \n-    function acc_async_test_h (a)\n+    function acc_async_test_h (arg)\n       logical acc_async_test_h\n-      integer a\n+      integer arg\n     end function\n \n     function acc_async_test_all_h ()\n       logical acc_async_test_all_h\n     end function\n \n-    subroutine acc_wait_h (a)\n-      integer a\n+    subroutine acc_wait_h (arg)\n+      integer arg\n     end subroutine\n \n-    subroutine acc_wait_async_h (a1, a2)\n-      integer a1, a2\n+    subroutine acc_wait_async_h (arg, async)\n+      integer arg, async\n     end subroutine\n \n     subroutine acc_wait_all_h ()\n     end subroutine\n \n-    subroutine acc_wait_all_async_h (a)\n-      integer a\n+    subroutine acc_wait_all_async_h (async)\n+      integer async\n     end subroutine\n \n-    subroutine acc_init_h (d)\n+    subroutine acc_init_h (devicetype)\n       import\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n     end subroutine\n \n-    subroutine acc_shutdown_h (d)\n+    subroutine acc_shutdown_h (devicetype)\n       import\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n     end subroutine\n \n-    function acc_on_device_h (d)\n+    function acc_on_device_h (devicetype)\n       import\n-      integer (acc_device_kind) d\n+      integer (acc_device_kind) devicetype\n       logical acc_on_device_h\n     end function\n \n@@ -505,17 +508,17 @@ subroutine acc_update_self_async_array_h (a, async)\n   end interface\n \n   interface\n-    function acc_get_num_devices_l (d) &\n+    function acc_get_num_devices_l (devicetype) &\n         bind (C, name = \"acc_get_num_devices\")\n       use iso_c_binding, only: c_int\n       integer (c_int) :: acc_get_num_devices_l\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end function\n \n-    subroutine acc_set_device_type_l (d) &\n+    subroutine acc_set_device_type_l (devicetype) &\n         bind (C, name = \"acc_set_device_type\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end subroutine\n \n     function acc_get_device_type_l () &\n@@ -524,37 +527,37 @@ function acc_get_device_type_l () &\n       integer (c_int) :: acc_get_device_type_l\n     end function\n \n-    subroutine acc_set_device_num_l (n, d) &\n+    subroutine acc_set_device_num_l (devicenum, devicetype) &\n         bind (C, name = \"acc_set_device_num\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: n, d\n+      integer (c_int), value :: devicenum, devicetype\n     end subroutine\n \n-    function acc_get_device_num_l (d) &\n+    function acc_get_device_num_l (devicetype) &\n         bind (C, name = \"acc_get_device_num\")\n       use iso_c_binding, only: c_int\n       integer (c_int) :: acc_get_device_num_l\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end function\n \n-    function acc_get_property_l (n, d, p) &\n+    function acc_get_property_l (devicenum, devicetype, property) &\n         bind (C, name = \"acc_get_property\")\n       use iso_c_binding, only: c_int, c_size_t\n       implicit none (type, external)\n       integer (c_size_t) :: acc_get_property_l\n-      integer (c_int), value :: n\n-      integer (c_int), value :: d\n-      integer (c_int), value :: p\n+      integer (c_int), value :: devicenum\n+      integer (c_int), value :: devicetype\n+      integer (c_int), value :: property\n     end function\n \n-    function acc_get_property_string_l (n, d, p) &\n+    function acc_get_property_string_l (devicenum, devicetype, property) &\n         bind (C, name = \"acc_get_property_string\")\n       use iso_c_binding, only: c_int, c_ptr\n       implicit none (type, external)\n       type (c_ptr) :: acc_get_property_string_l\n-      integer (c_int), value :: n\n-      integer (c_int), value :: d\n-      integer (c_int), value :: p\n+      integer (c_int), value :: devicenum\n+      integer (c_int), value :: devicetype\n+      integer (c_int), value :: property\n     end function\n \n     function acc_async_test_l (a) &\n@@ -576,40 +579,40 @@ subroutine acc_wait_l (a) &\n       integer (c_int), value :: a\n     end subroutine\n \n-    subroutine acc_wait_async_l (a1, a2) &\n+    subroutine acc_wait_async_l (arg, async) &\n         bind (C, name = \"acc_wait_async\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: a1, a2\n+      integer (c_int), value :: arg, async\n     end subroutine\n \n     subroutine acc_wait_all_l () &\n         bind (C, name = \"acc_wait_all\")\n       use iso_c_binding, only: c_int\n     end subroutine\n \n-    subroutine acc_wait_all_async_l (a) &\n+    subroutine acc_wait_all_async_l (async) &\n         bind (C, name = \"acc_wait_all_async\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: a\n+      integer (c_int), value :: async\n     end subroutine\n \n-    subroutine acc_init_l (d) &\n+    subroutine acc_init_l (devicetype) &\n         bind (C, name = \"acc_init\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end subroutine\n \n-    subroutine acc_shutdown_l (d) &\n+    subroutine acc_shutdown_l (devicetype) &\n         bind (C, name = \"acc_shutdown\")\n       use iso_c_binding, only: c_int\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end subroutine\n \n-    function acc_on_device_l (d) &\n+    function acc_on_device_l (devicetype) &\n         bind (C, name = \"acc_on_device\")\n       use iso_c_binding, only: c_int\n       integer (c_int) :: acc_on_device_l\n-      integer (c_int), value :: d\n+      integer (c_int), value :: devicetype\n     end function\n \n     subroutine acc_copyin_l (a, len) &\n@@ -769,7 +772,7 @@ module openacc\n   public :: acc_device_none, acc_device_default, acc_device_host\n   public :: acc_device_not_host, acc_device_nvidia, acc_device_radeon\n \n-  public :: acc_device_property\n+  public :: acc_device_property_kind, acc_device_property\n   public :: acc_property_memory, acc_property_free_memory\n   public :: acc_property_name, acc_property_vendor, acc_property_driver\n \n@@ -1002,19 +1005,19 @@ module openacc\n \n end module openacc\n \n-function acc_get_num_devices_h (d)\n+function acc_get_num_devices_h (devicetype)\n   use openacc_internal, only: acc_get_num_devices_l\n   use openacc_kinds\n   integer acc_get_num_devices_h\n-  integer (acc_device_kind) d\n-  acc_get_num_devices_h = acc_get_num_devices_l (d)\n+  integer (acc_device_kind) devicetype\n+  acc_get_num_devices_h = acc_get_num_devices_l (devicetype)\n end function\n \n-subroutine acc_set_device_type_h (d)\n+subroutine acc_set_device_type_h (devicetype)\n   use openacc_internal, only: acc_set_device_type_l\n   use openacc_kinds\n-  integer (acc_device_kind) d\n-  call acc_set_device_type_l (d)\n+  integer (acc_device_kind) devicetype\n+  call acc_set_device_type_l (devicetype)\n end subroutine\n \n function acc_get_device_type_h ()\n@@ -1024,54 +1027,47 @@ function acc_get_device_type_h ()\n   acc_get_device_type_h = acc_get_device_type_l ()\n end function\n \n-subroutine acc_set_device_num_h (n, d)\n+subroutine acc_set_device_num_h (devicenum, devicetype)\n   use openacc_internal, only: acc_set_device_num_l\n   use openacc_kinds\n-  integer n\n-  integer (acc_device_kind) d\n-  call acc_set_device_num_l (n, d)\n+  integer devicenum\n+  integer (acc_device_kind) devicetype\n+  call acc_set_device_num_l (devicenum, devicetype)\n end subroutine\n \n-function acc_get_device_num_h (d)\n+function acc_get_device_num_h (devicetype)\n   use openacc_internal, only: acc_get_device_num_l\n   use openacc_kinds\n   integer acc_get_device_num_h\n-  integer (acc_device_kind) d\n-  acc_get_device_num_h = acc_get_device_num_l (d)\n+  integer (acc_device_kind) devicetype\n+  acc_get_device_num_h = acc_get_device_num_l (devicetype)\n end function\n \n-function acc_get_property_h (n, d, p)\n-  use iso_c_binding, only: c_int, c_size_t\n+function acc_get_property_h (devicenum, devicetype, property)\n+  use iso_c_binding, only: c_size_t\n   use openacc_internal, only: acc_get_property_l\n   use openacc_kinds\n   implicit none (type, external)\n-  integer (acc_device_property) :: acc_get_property_h\n-  integer, value :: n\n-  integer (acc_device_kind), value :: d\n-  integer (acc_device_property), value :: p\n-\n-  integer (c_int) :: pint\n-\n-  pint = int (p, c_int)\n-  acc_get_property_h = acc_get_property_l (n, d, pint)\n+  integer (c_size_t) :: acc_get_property_h\n+  integer, value :: devicenum\n+  integer (acc_device_kind), value :: devicetype\n+  integer (acc_device_property_kind), value :: property\n+  acc_get_property_h = acc_get_property_l (devicenum, devicetype, property)\n end function\n \n-subroutine acc_get_property_string_h (n, d, p, s)\n-  use iso_c_binding, only: c_char, c_int, c_ptr, c_f_pointer, c_associated\n+subroutine acc_get_property_string_h (devicenum, devicetype, property, string)\n+  use iso_c_binding, only: c_char, c_size_t, c_ptr, c_f_pointer, c_associated\n   use openacc_internal, only: acc_get_property_string_l\n   use openacc_kinds\n   implicit none (type, external)\n-  integer, value :: n\n-  integer (acc_device_kind), value :: d\n-  integer (acc_device_property), value :: p\n-  character (*) :: s\n+  integer, value :: devicenum\n+  integer (acc_device_kind), value :: devicetype\n+  integer (acc_device_property_kind), value :: property\n+  character (*) :: string\n \n-  integer (c_int) :: pint\n   type (c_ptr) :: cptr\n-  integer :: clen\n+  integer(c_size_t) :: clen, slen, i\n   character (kind=c_char, len=1), pointer, contiguous :: sptr (:)\n-  integer :: slen\n-  integer :: i\n \n   interface\n      function strlen (s) bind (C, name = \"strlen\")\n@@ -1081,90 +1077,77 @@ function strlen (s) bind (C, name = \"strlen\")\n      end function strlen\n   end interface\n \n-  pint = int (p, c_int)\n-  cptr = acc_get_property_string_l (n, d, pint)\n-  s = \"\"\n+  cptr = acc_get_property_string_l (devicenum, devicetype, property)\n+  string = \"\"\n   if (.not. c_associated (cptr)) then\n      return\n   end if\n \n-  clen = int (strlen (cptr))\n+  clen = strlen (cptr)\n   call c_f_pointer (cptr, sptr, [clen])\n \n-  slen = min (clen, len (s))\n+  slen = min (clen, len (string, kind=c_size_t))\n   do i = 1, slen\n-    s (i:i) = sptr (i)\n+    string (i:i) = sptr (i)\n   end do\n end subroutine\n \n-function acc_async_test_h (a)\n+function acc_async_test_h (arg)\n   use openacc_internal, only: acc_async_test_l\n   logical acc_async_test_h\n-  integer a\n-  if (acc_async_test_l (a) .eq. 1) then\n-    acc_async_test_h = .TRUE.\n-  else\n-    acc_async_test_h = .FALSE.\n-  end if\n+  integer arg\n+  acc_async_test_h = acc_async_test_l (arg) /= 0\n end function\n \n function acc_async_test_all_h ()\n   use openacc_internal, only: acc_async_test_all_l\n   logical acc_async_test_all_h\n-  if (acc_async_test_all_l () .eq. 1) then\n-    acc_async_test_all_h = .TRUE.\n-  else\n-    acc_async_test_all_h = .FALSE.\n-  end if\n+  acc_async_test_all_h = acc_async_test_all_l () /= 0\n end function\n \n-subroutine acc_wait_h (a)\n+subroutine acc_wait_h (arg)\n   use openacc_internal, only: acc_wait_l\n-  integer a\n-  call acc_wait_l (a)\n+  integer arg\n+  call acc_wait_l (arg)\n end subroutine\n \n-subroutine acc_wait_async_h (a1, a2)\n+subroutine acc_wait_async_h (arg, async)\n   use openacc_internal, only: acc_wait_async_l\n-  integer a1, a2\n-  call acc_wait_async_l (a1, a2)\n+  integer arg, async\n+  call acc_wait_async_l (arg, async)\n end subroutine\n \n subroutine acc_wait_all_h ()\n   use openacc_internal, only: acc_wait_all_l\n   call acc_wait_all_l ()\n end subroutine\n \n-subroutine acc_wait_all_async_h (a)\n+subroutine acc_wait_all_async_h (async)\n   use openacc_internal, only: acc_wait_all_async_l\n-  integer a\n-  call acc_wait_all_async_l (a)\n+  integer async\n+  call acc_wait_all_async_l (async)\n end subroutine\n \n-subroutine acc_init_h (d)\n+subroutine acc_init_h (devicetype)\n   use openacc_internal, only: acc_init_l\n   use openacc_kinds\n-  integer (acc_device_kind) d\n-  call acc_init_l (d)\n+  integer (acc_device_kind) devicetype\n+  call acc_init_l (devicetype)\n end subroutine\n \n-subroutine acc_shutdown_h (d)\n+subroutine acc_shutdown_h (devicetype)\n   use openacc_internal, only: acc_shutdown_l\n   use openacc_kinds\n-  integer (acc_device_kind) d\n-  call acc_shutdown_l (d)\n+  integer (acc_device_kind) devicetype\n+  call acc_shutdown_l (devicetype)\n end subroutine\n \n-function acc_on_device_h (d)\n+function acc_on_device_h (devicetype)\n   use openacc_internal, only: acc_on_device_l\n   use openacc_kinds\n-  integer (acc_device_kind) d\n+  integer (acc_device_kind) devicetype\n   logical acc_on_device_h\n-  if (acc_on_device_l (d) .eq. 1) then\n-    acc_on_device_h = .TRUE.\n-  else\n-    acc_on_device_h = .FALSE.\n-  end if\n+  acc_on_device_h = acc_on_device_l (devicetype) /= 0\n end function\n \n subroutine acc_copyin_32_h (a, len)\n@@ -1414,11 +1397,7 @@ function acc_is_present_32_h (a, len)\n   !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n   type (*), dimension (*) :: a\n   integer (c_int32_t) len\n-  if (acc_is_present_l (a, int (len, kind = c_size_t)) .eq. 1) then\n-    acc_is_present_32_h = .TRUE.\n-  else\n-    acc_is_present_32_h = .FALSE.\n-  end if\n+  acc_is_present_32_h = acc_is_present_l (a, int (len, kind = c_size_t)) /= 0\n end function\n \n function acc_is_present_64_h (a, len)\n@@ -1428,18 +1407,14 @@ function acc_is_present_64_h (a, len)\n   !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n   type (*), dimension (*) :: a\n   integer (c_int64_t) len\n-  if (acc_is_present_l (a, int (len, kind = c_size_t)) .eq. 1) then\n-    acc_is_present_64_h = .TRUE.\n-  else\n-    acc_is_present_64_h = .FALSE.\n-  end if\n+  acc_is_present_64_h = acc_is_present_l (a, int (len, kind = c_size_t)) /= 0\n end function\n \n function acc_is_present_array_h (a)\n   use openacc_internal, only: acc_is_present_l\n   logical acc_is_present_array_h\n   type (*), dimension (..), contiguous :: a\n-  acc_is_present_array_h = acc_is_present_l (a, sizeof (a)) == 1\n+  acc_is_present_array_h = acc_is_present_l (a, sizeof (a)) /= 0\n end function\n \n subroutine acc_copyin_async_32_h (a, len, async)"}, {"sha": "ee08e9787cc91829d5fb450cab8d7f5b064539e6", "filename": "libgomp/openacc_lib.h", "status": "modified", "additions": 94, "deletions": 51, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fopenacc_lib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8d1a1cb1b816381bf60cb1211c93b8eba1fe1472/libgomp%2Fopenacc_lib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Fopenacc_lib.h?ref=8d1a1cb1b816381bf60cb1211c93b8eba1fe1472", "patch": "@@ -37,6 +37,7 @@\n       integer, parameter :: acc_device_kind = 4\n \n !     Keep in sync with include/gomp-constants.h.\n+      integer (acc_device_kind), parameter :: acc_device_current = -3\n       integer (acc_device_kind), parameter :: acc_device_none = 0\n       integer (acc_device_kind), parameter :: acc_device_default = 1\n       integer (acc_device_kind), parameter :: acc_device_host = 2\n@@ -46,6 +47,23 @@\n       integer (acc_device_kind), parameter :: acc_device_nvidia = 5\n       integer (acc_device_kind), parameter :: acc_device_radeon = 8\n \n+      integer, parameter :: acc_device_property_kind = 4\n+! OpenACC 2.6/2.7/3.0 used acc_device_property; in a spec update the\n+! missing '_kind' was added for consistency.  For backward compatibility, keep:\n+      integer, parameter :: acc_device_property                         &\n+     &    = acc_device_property_kind\n+\n+      integer (acc_device_property_kind), parameter ::                  &\n+     &    acc_property_memory = 1\n+      integer (acc_device_property_kind), parameter ::                  &\n+     &    acc_property_free_memory = 2\n+      integer (acc_device_property_kind), parameter ::                  &\n+     &    acc_property_name = int(Z'10001')\n+      integer (acc_device_property_kind), parameter ::                  &\n+     &    acc_property_vendor = int(Z'10002')\n+      integer (acc_device_property_kind), parameter ::                  &\n+     &    acc_property_driver = int(Z'10003')\n+\n       integer, parameter :: acc_handle_kind = 4\n \n !     Keep in sync with include/gomp-constants.h.\n@@ -55,17 +73,17 @@\n       integer, parameter :: openacc_version = 201711\n \n       interface acc_get_num_devices\n-        function acc_get_num_devices_h (d)\n+        function acc_get_num_devices_h (devicetype)\n           import acc_device_kind\n           integer acc_get_num_devices_h\n-          integer (acc_device_kind) d\n+          integer (acc_device_kind) devicetype\n         end function\n       end interface\n \n       interface acc_set_device_type\n-        subroutine acc_set_device_type_h (d)\n+        subroutine acc_set_device_type_h (devicetype)\n           import acc_device_kind\n-          integer (acc_device_kind) d\n+          integer (acc_device_kind) devicetype\n         end subroutine\n       end interface\n \n@@ -77,25 +95,50 @@\n       end interface\n \n       interface acc_set_device_num\n-        subroutine acc_set_device_num_h (n, d)\n+        subroutine acc_set_device_num_h (devicenum, devicetype)\n           import acc_device_kind\n-          integer n\n-          integer (acc_device_kind) d\n+          integer devicenum\n+          integer (acc_device_kind) devicetype\n         end subroutine\n       end interface\n \n       interface acc_get_device_num\n-        function acc_get_device_num_h (d)\n+        function acc_get_device_num_h (devicetype)\n           import acc_device_kind\n           integer acc_get_device_num_h\n-          integer (acc_device_kind) d\n+          integer (acc_device_kind) devicetype\n         end function\n       end interface\n \n+      interface acc_get_property\n+        function acc_get_property_h (devicenum, devicetype,             &\n+     &                               property)\n+          use iso_c_binding, only: c_size_t\n+          import acc_device_kind, acc_device_property_kind\n+          implicit none (type, external)\n+          integer (c_size_t) :: acc_get_property_h\n+          integer, value :: devicenum\n+          integer (acc_device_kind), value :: devicetype\n+          integer (acc_device_property_kind), value :: property\n+        end function\n+      end interface\n+\n+      interface acc_get_property_string\n+        subroutine acc_get_property_string_h (devicenum, devicetype,    &\n+     &                                        property, string)\n+          import acc_device_kind, acc_device_property_kind\n+          implicit none (type, external)\n+          integer, value :: devicenum\n+          integer (acc_device_kind), value :: devicetype\n+          integer (acc_device_property_kind), value :: property\n+          character (*) :: string\n+        end subroutine\n+      end interface\n+\n       interface acc_async_test\n-        function acc_async_test_h (a)\n+        function acc_async_test_h (arg)\n           logical acc_async_test_h\n-          integer a\n+          integer arg\n         end function\n       end interface\n \n@@ -106,8 +149,8 @@\n       end interface\n \n       interface acc_wait\n-        subroutine acc_wait_h (a)\n-          integer a\n+        subroutine acc_wait_h (arg)\n+          integer arg\n         end subroutine\n       end interface\n \n@@ -117,8 +160,8 @@\n       end interface\n \n       interface acc_wait_async\n-        subroutine acc_wait_async_h (a1, a2)\n-          integer a1, a2\n+        subroutine acc_wait_async_h (arg, async)\n+          integer arg, async\n         end subroutine\n       end interface\n \n@@ -134,8 +177,8 @@\n       end interface\n \n       interface acc_wait_all_async\n-        subroutine acc_wait_all_async_h (a)\n-          integer a\n+        subroutine acc_wait_all_async_h (async)\n+          integer async\n         end subroutine\n       end interface\n \n@@ -167,14 +210,14 @@\n       interface acc_copyin\n         subroutine acc_copyin_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_copyin_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -187,14 +230,14 @@\n       interface acc_present_or_copyin\n         subroutine acc_present_or_copyin_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_present_or_copyin_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -213,14 +256,14 @@\n       interface acc_create\n         subroutine acc_create_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_create_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -233,14 +276,14 @@\n       interface acc_present_or_create\n         subroutine acc_present_or_create_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_present_or_create_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -259,14 +302,14 @@\n       interface acc_copyout\n         subroutine acc_copyout_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_copyout_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -279,14 +322,14 @@\n       interface acc_copyout_finalize\n         subroutine acc_copyout_finalize_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_copyout_finalize_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -299,14 +342,14 @@\n       interface acc_delete\n         subroutine acc_delete_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_delete_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -319,14 +362,14 @@\n       interface acc_delete_finalize\n         subroutine acc_delete_finalize_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_delete_finalize_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -339,14 +382,14 @@\n       interface acc_update_device\n         subroutine acc_update_device_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_update_device_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -359,14 +402,14 @@\n       interface acc_update_self\n         subroutine acc_update_self_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end subroutine\n \n         subroutine acc_update_self_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end subroutine\n@@ -385,15 +428,15 @@\n         function acc_is_present_32_h (a, len)\n           use iso_c_binding, only: c_int32_t\n           logical acc_is_present_32_h\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n         end function\n \n         function acc_is_present_64_h (a, len)\n           use iso_c_binding, only: c_int64_t\n           logical acc_is_present_64_h\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n         end function\n@@ -411,7 +454,7 @@\n         subroutine acc_copyin_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -420,7 +463,7 @@\n         subroutine acc_copyin_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async\n@@ -437,7 +480,7 @@\n         subroutine acc_create_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -446,7 +489,7 @@\n         subroutine acc_create_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async\n@@ -463,7 +506,7 @@\n         subroutine acc_copyout_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -472,7 +515,7 @@\n         subroutine acc_copyout_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async\n@@ -489,7 +532,7 @@\n         subroutine acc_delete_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -498,7 +541,7 @@\n         subroutine acc_delete_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async\n@@ -515,7 +558,7 @@\n         subroutine acc_update_device_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -524,7 +567,7 @@\n         subroutine acc_update_device_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async\n@@ -541,7 +584,7 @@\n         subroutine acc_update_self_async_32_h (a, len, async)\n           use iso_c_binding, only: c_int32_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int32_t) len\n           integer (acc_handle_kind) async\n@@ -550,7 +593,7 @@\n         subroutine acc_update_self_async_64_h (a, len, async)\n           use iso_c_binding, only: c_int64_t\n           import acc_handle_kind\n-          !GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n+!GCC$ ATTRIBUTES NO_ARG_CHECK :: a\n           type (*), dimension (*) :: a\n           integer (c_int64_t) len\n           integer (acc_handle_kind) async"}]}