{"sha": "5329e1a8e1480d536ff96283a6556e51112ba470", "node_id": "C_kwDOANBUbNoAKDUzMjllMWE4ZTE0ODBkNTM2ZmY5NjI4M2E2NTU2ZTUxMTEyYmE0NzA", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-11-21T16:44:50Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2022-12-06T21:38:46Z"}, "message": "libstdc++: Make chrono::hh_mm_ss more compact\n\nThis uses a single byte for the minutes and seconds members, and places\nthe bool member next to those single bytes. This means we do not need 40\nbytes to store a time that can fit in a single 8-byte integer.\n\nWhen there is no subsecond precision we can do away with the _M_ss\nmember altogether. If the subsecond precision is coarse enough, we can\nuse a smaller representation for _M_ss, e.g. hh_mm_ss<milliseconds> only\nneeds uint_least32_t for _M_ss, and hh_mm_ss<duration<long, ratio<1,10>>\nand hh_mm_ss<duration<int8_t, nano>> only need a single byte. In the\nlatter case the type can only ever represent up to 255ns anyway, so we\ndon't need a larger representation type (in such cases, we could even\nremove the _M_h, _M_m and _M_s members, but it's a very unlikely\nscenario that isn't worth optimizing for).\n\nExcept for specializations with a floating-point rep or using higher\nprecision than nanoseconds, hh_mm_ss should now fit in 16 bytes, or even\n12 bytes for x86-32 where alignof(long long) == 4.\n\nlibstdc++-v3/ChangeLog:\n\n\t* include/std/chrono (chrono::hh_mm_ss): Do not use 64-bit\n\trepresentations for all four duration members. Reorder members.\n\t(hh_mm_ss::hh_mm_ss()): Define as defaulted.\n\t(hh_mm_ss::hh_mm_ss(Duration)): Delegate to a new private\n\tconstructor, instead of calling chrono::abs repeatedly.\n\t* testsuite/std/time/hh_mm_ss/1.cc: Check floating-point\n\trepresentations. Check default constructor. Check sizes.", "tree": {"sha": "ce5e86fbc2101af22c5f64ce05c3ec4ee720abb3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ce5e86fbc2101af22c5f64ce05c3ec4ee720abb3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5329e1a8e1480d536ff96283a6556e51112ba470", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5329e1a8e1480d536ff96283a6556e51112ba470", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5329e1a8e1480d536ff96283a6556e51112ba470", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5329e1a8e1480d536ff96283a6556e51112ba470/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "4ba94abf147fe7778a7541849ce27cafee74df9b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4ba94abf147fe7778a7541849ce27cafee74df9b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4ba94abf147fe7778a7541849ce27cafee74df9b"}], "stats": {"total": 201, "additions": 166, "deletions": 35}, "files": [{"sha": "8d73d98e4cb91450166461ec810b3694827c2fb4", "filename": "libstdc++-v3/include/std/chrono", "status": "modified", "additions": 111, "deletions": 34, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329e1a8e1480d536ff96283a6556e51112ba470/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329e1a8e1480d536ff96283a6556e51112ba470/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Fchrono?ref=5329e1a8e1480d536ff96283a6556e51112ba470", "patch": "@@ -41,6 +41,7 @@\n #include <bits/chrono.h>\n \n #if __cplusplus >= 202002L\n+# include <bit>\n # include <sstream>\n # include <string>\n # include <vector>\n@@ -2262,6 +2263,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n     // HH_MM_SS\n \n+    /// @cond undocumented\n     namespace __detail\n     {\n       consteval long long\n@@ -2273,22 +2275,28 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \treturn __r;\n       }\n     }\n+    /// @endcond\n \n+    /** Utility for splitting a duration into hours, minutes, and seconds\n+     *\n+     * This is a convenience type that provides accessors for the constituent\n+     * parts (hours, minutes, seconds and subseconds) of a duration.\n+     *\n+     * @since C++20\n+     */\n     template<typename _Duration>\n       class hh_mm_ss\n       {\n+\tstatic_assert( __is_duration<_Duration>::value );\n+\n       private:\n-\tstatic constexpr int\n+\tstatic consteval int\n \t_S_fractional_width()\n \t{\n-\t  int __multiplicity_2 = 0;\n-\t  int __multiplicity_5 = 0;\n \t  auto __den = _Duration::period::den;\n-\t  while ((__den % 2) == 0)\n-\t    {\n-\t      ++__multiplicity_2;\n-\t      __den /= 2;\n-\t    }\n+\t  const int __multiplicity_2 = std::__countr_zero((uintmax_t)__den);\n+\t  __den >>= __multiplicity_2;\n+\t  int __multiplicity_5 = 0;\n \t  while ((__den % 5) == 0)\n \t    {\n \t      ++__multiplicity_5;\n@@ -2304,6 +2312,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  return __width;\n \t}\n \n+\tconstexpr\n+\thh_mm_ss(_Duration __d, bool __is_neg) noexcept\n+\t: _M_h (duration_cast<chrono::hours>(__d)),\n+\t  _M_m (duration_cast<chrono::minutes>(__d - hours())),\n+\t  _M_s (duration_cast<chrono::seconds>(__d - hours() - minutes())),\n+\t  _M_is_neg(__is_neg)\n+\t{\n+\t  auto __ss = __d - hours() - minutes() - seconds();\n+\t  if constexpr (treat_as_floating_point_v<typename precision::rep>)\n+\t    _M_ss._M_r = __ss.count();\n+\t  else if constexpr (precision::period::den != 1)\n+\t    _M_ss._M_r = duration_cast<precision>(__ss).count();\n+\t}\n+\n       public:\n \tstatic constexpr unsigned fractional_width = {_S_fractional_width()};\n \n@@ -2312,28 +2334,21 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t\t   chrono::seconds::rep>,\n \t\t     ratio<1, __detail::__pow10(fractional_width)>>;\n \n-\tconstexpr\n-\thh_mm_ss() noexcept\n-\t: hh_mm_ss{_Duration::zero()}\n-\t{ }\n+\tconstexpr hh_mm_ss() noexcept = default;\n \n \tconstexpr explicit\n \thh_mm_ss(_Duration __d) noexcept\n-\t: _M_is_neg (__d < _Duration::zero()),\n-\t  _M_h (duration_cast<chrono::hours>(abs(__d))),\n-\t  _M_m (duration_cast<chrono::minutes>(abs(__d) - hours())),\n-\t  _M_s (duration_cast<chrono::seconds>(abs(__d) - hours() - minutes()))\n-\t{\n-\t  if constexpr (treat_as_floating_point_v<typename precision::rep>)\n-\t    _M_ss = abs(__d) - hours() - minutes() - seconds();\n-\t  else\n-\t    _M_ss = duration_cast<precision>(abs(__d) - hours()\n-\t\t\t\t\t     - minutes() - seconds());\n-\t}\n+\t: hh_mm_ss(chrono::abs(__d), __d < _Duration::zero())\n+\t{ }\n \n \tconstexpr bool\n \tis_negative() const noexcept\n-\t{ return _M_is_neg; }\n+\t{\n+\t  if constexpr (!__is_unsigned)\n+\t    return _M_is_neg;\n+\t  else\n+\t    return false;\n+\t}\n \n \tconstexpr chrono::hours\n \thours() const noexcept\n@@ -2349,7 +2364,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \n \tconstexpr precision\n \tsubseconds() const noexcept\n-\t{ return _M_ss; }\n+\t{ return static_cast<precision>(_M_ss); }\n \n \tconstexpr explicit\n \toperator precision() const noexcept\n@@ -2358,20 +2373,82 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \tconstexpr precision\n \tto_duration() const noexcept\n \t{\n-\t  if (_M_is_neg)\n-\t    return -(_M_h + _M_m + _M_s + _M_ss);\n-\t  else\n-\t    return _M_h + _M_m + _M_s + _M_ss;\n+\t  if constexpr (!__is_unsigned)\n+\t    if (_M_is_neg)\n+\t      return -(_M_h + _M_m + _M_s + subseconds());\n+\t  return _M_h + _M_m + _M_s + subseconds();\n \t}\n \n \t// TODO: Implement operator<<.\n \n       private:\n-\tbool _M_is_neg;\n-\tchrono::hours _M_h;\n-\tchrono::minutes _M_m;\n-\tchrono::seconds _M_s;\n-\tprecision _M_ss;\n+\tstatic constexpr bool __is_unsigned\n+\t  = __and_v<is_integral<typename _Duration::rep>,\n+\t\t    is_unsigned<typename _Duration::rep>>;\n+\n+\ttemplate<typename _Ratio>\n+\t  using __byte_duration = duration<unsigned char, _Ratio>;\n+\n+\t// The type of the _M_ss member that holds the subsecond precision.\n+\ttemplate<typename _Dur>\n+\t  struct __subseconds\n+\t  {\n+\t    typename _Dur::rep _M_r{};\n+\n+\t    constexpr explicit\n+\t    operator _Dur() const noexcept\n+\t    { return _Dur(_M_r); }\n+\t  };\n+\n+\t// An empty class if this precision doesn't need subseconds.\n+\ttemplate<typename _Rep>\n+\t  requires (!treat_as_floating_point_v<_Rep>)\n+\t  struct __subseconds<duration<_Rep, ratio<1>>>\n+\t  {\n+\t    constexpr explicit\n+\t    operator duration<_Rep, ratio<1>>() const noexcept\n+\t    { return {}; }\n+\t  };\n+\n+\t// True if the maximum constructor argument can be represented in _Tp.\n+\ttemplate<typename _Tp>\n+\t  static constexpr bool __fits\n+\t    = duration_values<typename _Duration::rep>::max()\n+\t\t<= duration_values<_Tp>::max();\n+\n+\ttemplate<typename _Rep, typename _Period>\n+\t  requires (!treat_as_floating_point_v<_Rep>)\n+\t    && ratio_less_v<_Period, ratio<1, 1>>\n+\t    && (ratio_greater_equal_v<_Period, ratio<1, 250>>\n+\t\t  || __fits<unsigned char>)\n+\t  struct __subseconds<duration<_Rep, _Period>>\n+\t  {\n+\t    unsigned char _M_r{};\n+\n+\t    constexpr explicit\n+\t    operator duration<_Rep, _Period>() const noexcept\n+\t    { return duration<_Rep, _Period>(_M_r); }\n+\t  };\n+\n+\ttemplate<typename _Rep, typename _Period>\n+\t  requires (!treat_as_floating_point_v<_Rep>)\n+\t    && ratio_less_v<_Period, ratio<1, 250>>\n+\t    && (ratio_greater_equal_v<_Period, ratio<1, 4'000'000'000>>\n+\t\t  || __fits<uint_least32_t>)\n+\t  struct __subseconds<duration<_Rep, _Period>>\n+\t  {\n+\t    uint_least32_t _M_r{};\n+\n+\t    constexpr explicit\n+\t    operator duration<_Rep, _Period>() const noexcept\n+\t    { return duration<_Rep, _Period>(_M_r); }\n+\t  };\n+\n+\tchrono::hours\t\t    _M_h{};\n+\t__byte_duration<ratio<60>>  _M_m{};\n+\t__byte_duration<ratio<1>>   _M_s{};\n+\tbool\t\t\t    _M_is_neg{};\n+\t__subseconds<precision>\t    _M_ss{};\n       };\n \n     // 12/24 HOURS FUNCTIONS"}, {"sha": "3f8a838c47797476b161da996ab2e9a502cd4e2e", "filename": "libstdc++-v3/testsuite/std/time/hh_mm_ss/1.cc", "status": "modified", "additions": 55, "deletions": 1, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5329e1a8e1480d536ff96283a6556e51112ba470/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5329e1a8e1480d536ff96283a6556e51112ba470/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2Fstd%2Ftime%2Fhh_mm_ss%2F1.cc?ref=5329e1a8e1480d536ff96283a6556e51112ba470", "patch": "@@ -59,5 +59,59 @@ constexpr_hh_mm_ss()\n \n   static_assert(seconds{hh_mm_ss{100min}} == 100min);\n \n-  // TODO: treat_as_floating_point_v\n+  // treat_as_floating_point_v\n+  using fseconds = duration<double, ratio<1>>;\n+  constexpr hh_mm_ss<fseconds> fsec{0x123.0004p5s};\n+  static_assert(std::is_same_v<hh_mm_ss<fseconds>::precision, fseconds>);\n+  static_assert(fsec.hours() == 2h);\n+  static_assert(fsec.minutes() == 35min);\n+  static_assert(fsec.seconds() == 12s);\n+  static_assert(fsec.subseconds() == 0x.0004p5s);\n+  static_assert(!fsec.is_negative());\n+  static_assert(fsec.to_duration() == 0x123.0004p5s);\n+\n+  using fminutes = duration<double, ratio<60>>;\n+  constexpr hh_mm_ss<fminutes> fmin{-0x1.23p4min};\n+  static_assert(std::is_same_v<hh_mm_ss<fminutes>::precision, fseconds>);\n+  static_assert(fmin.hours() == 0h);\n+  static_assert(fmin.minutes() == 18min);\n+  static_assert(fmin.seconds() == 11s);\n+  static_assert(fmin.subseconds() == 0.25s);\n+  static_assert(fmin.is_negative());\n+  static_assert(fmin.to_duration() == -0x1.23p4min);\n+}\n+\n+constexpr void\n+default_construction()\n+{\n+  using namespace std::chrono;\n+\n+  constexpr hh_mm_ss<seconds> s1;\n+  static_assert(s1.to_duration() == s1.to_duration().zero());\n+  constexpr hh_mm_ss<duration<char>> s2;\n+  static_assert(s2.to_duration() == s2.to_duration().zero());\n+  constexpr hh_mm_ss<duration<int, std::centi>> s3;\n+  static_assert(s3.to_duration() == s3.to_duration().zero());\n+  constexpr hh_mm_ss<duration<long long, std::femto>> s4;\n+  static_assert(s4.to_duration() == s4.to_duration().zero());\n+  constexpr hh_mm_ss<duration<double>> s5;\n+  static_assert(s5.to_duration() == s5.to_duration().zero());\n+}\n+\n+constexpr void\n+size()\n+{\n+  using namespace std::chrono;\n+\n+  struct S0 { long long h; char m; char s; bool neg; };\n+  static_assert(sizeof(hh_mm_ss<seconds>) == sizeof(S0));\n+  struct S1 { long long h; char m; char s; bool neg; char ss; };\n+  static_assert(sizeof(hh_mm_ss<duration<int, std::centi>>) == sizeof(S1));\n+  struct S2 { long long h; char m, s; bool neg; int ss; };\n+  static_assert(sizeof(hh_mm_ss<duration<int, std::milli>>) == sizeof(S2));\n+  static_assert(sizeof(hh_mm_ss<duration<int, std::pico>>) == sizeof(S2));\n+  struct S3 { long long h; char m, s; bool neg; long long ss; };\n+  static_assert(sizeof(hh_mm_ss<duration<long long, std::pico>>) == sizeof(S3));\n+  struct S4 { long long h; char m, s; bool neg; double ss; };\n+  static_assert(sizeof(hh_mm_ss<duration<double, std::micro>>) == sizeof(S4));\n }"}]}