{"sha": "4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGU2ZDE3NDNhMWVjYzVjZjY0Y2VhYTcyNjc0OTQ4MjhjNTEzODNiNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2009-04-04T17:09:45Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2009-04-04T17:09:45Z"}, "message": "except.c (remove_eh_handler): Make static.\n\n\t* except.c (remove_eh_handler): Make static.\n\t(eh_region_must_not_throw_p): Kill.\n\t(expand_resx_expr): Assertize.\n\t(duplicate_eh_regions): Accept callback as parameter; comment.\n\t* except.h (duplicate_eh_regions): New function.\n\t(remap_decl_v): Kill.\n\t(copy_cfg_body): Update call of duplicate_eh_regions.\n\nFrom-SVN: r145542", "tree": {"sha": "158293eb0d8b0ff007c7e3e9274ce328ad42d9c5", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/158293eb0d8b0ff007c7e3e9274ce328ad42d9c5"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/comments", "author": null, "committer": null, "parents": [{"sha": "6f85546f7c47327ca9f4599ea4c11180df915967", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6f85546f7c47327ca9f4599ea4c11180df915967", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6f85546f7c47327ca9f4599ea4c11180df915967"}], "stats": {"total": 408, "additions": 319, "deletions": 89}, "files": [{"sha": "64331da6185d64bb8405bfa21cd036df0b13c769", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "patch": "@@ -1,3 +1,13 @@\n+2009-04-04  Jan Hubicka  <jh@suse.cz>\n+\n+\t* except.c (remove_eh_handler): Make static.\n+\t(eh_region_must_not_throw_p): Kill.\n+\t(expand_resx_expr): Assertize.\n+\t(duplicate_eh_regions): Accept callback as parameter; comment.\n+\t* except.h (duplicate_eh_regions): New function.\n+\t(remap_decl_v): Kill.\n+\t(copy_cfg_body): Update call of duplicate_eh_regions.\n+\n 2009-04-04  Richard Guenther  <rguenther@suse.de>\n \n \t* tree-ssa.c (verify_ssa): With -O0 we do not need VOPs."}, {"sha": "64be6afd2c4a0a56221dd00bbd7f6c3f0c5d6182", "filename": "gcc/except.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Fexcept.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Fexcept.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.c?ref=4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "patch": "@@ -525,6 +525,12 @@ get_eh_region_tree_label (struct eh_region *region)\n   return region->tree_label;\n }\n \n+tree\n+get_eh_region_no_tree_label (int region)\n+{\n+  return VEC_index (eh_region, cfun->eh->region_array, region)->tree_label;\n+}\n+\n void\n set_eh_region_tree_label (struct eh_region *region, tree lab)\n {"}, {"sha": "741c6548339bd923cc4e64365b99061ee7bef9d6", "filename": "gcc/except.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Fexcept.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Fexcept.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexcept.h?ref=4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "patch": "@@ -97,6 +97,7 @@ extern struct eh_region *gen_eh_region_allowed (struct eh_region *, tree);\n extern struct eh_region *gen_eh_region_must_not_throw (struct eh_region *);\n extern int get_eh_region_number (struct eh_region *);\n extern bool get_eh_region_may_contain_throw (struct eh_region *);\n+extern tree get_eh_region_no_tree_label (int);\n extern tree get_eh_region_tree_label (struct eh_region *);\n extern void set_eh_region_tree_label (struct eh_region *, tree);\n "}, {"sha": "7f04068378e1490cb23867fe260d80b439d3a95a", "filename": "gcc/tree-eh.c", "status": "modified", "additions": 302, "deletions": 89, "changes": 391, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Ftree-eh.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4e6d1743a1ecc5cf64ceaa7267494828c51383b4/gcc%2Ftree-eh.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-eh.c?ref=4e6d1743a1ecc5cf64ceaa7267494828c51383b4", "patch": "@@ -2734,13 +2734,17 @@ tree_remove_unreachable_handlers (void)\n    <<<exception object>>> = save_eptr.6351_663;\n    <<<filter object>>> = save_filt.6352_662;\n    resx 1\n+\n+   And various minor variants after DCE or copy propagation.\n  */\n \n static int\n tree_empty_eh_handler_p (basic_block bb)\n {\n   gimple_stmt_iterator gsi;\n   int region;\n+  use_operand_p imm_use;\n+  gimple use_stmt;\n \n   gsi = gsi_last_bb (bb);\n \n@@ -2755,129 +2759,338 @@ tree_empty_eh_handler_p (basic_block bb)\n   gsi_prev (&gsi);\n   if (gsi_end_p (gsi))\n     return 0;\n-  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n-    return 0;\n-  if (TREE_CODE (gimple_assign_lhs (gsi_stmt (gsi))) != FILTER_EXPR)\n-    return 0;\n+  if (gimple_code (gsi_stmt (gsi)) == GIMPLE_ASSIGN)\n+    {\n+      tree filter_tmp;\n+      tree exc_ptr_tmp;\n \n-  /* filter_object set.  */\n-  gsi_prev (&gsi);\n-  if (gsi_end_p (gsi))\n-    return 0;\n-  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n-    return 0;\n-  if (TREE_CODE (gimple_assign_lhs (gsi_stmt (gsi))) != EXC_PTR_EXPR)\n-    return 0;\n+      if (TREE_CODE (gimple_assign_lhs (gsi_stmt (gsi))) != FILTER_EXPR)\n+\treturn 0;\n+      filter_tmp = gimple_assign_rhs1 (gsi_stmt (gsi));\n \n-  /* filter_object get.  */\n-  gsi_prev (&gsi);\n-  if (gsi_end_p (gsi))\n-    return 0;\n-  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n-    return 0;\n-  if (TREE_CODE (gimple_assign_rhs1 (gsi_stmt (gsi))) != EXC_PTR_EXPR)\n-    return 0;\n+      /* filter_object set.  */\n+      gsi_prev (&gsi);\n+      if (gsi_end_p (gsi))\n+\treturn 0;\n+      if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n+\treturn 0;\n+      if (TREE_CODE (gimple_assign_lhs (gsi_stmt (gsi))) != EXC_PTR_EXPR)\n+\treturn 0;\n+      exc_ptr_tmp = gimple_assign_rhs1 (gsi_stmt (gsi));\n+\n+      /* exc_ptr get.  */\n+      if (TREE_CODE (exc_ptr_tmp) != EXC_PTR_EXPR)\n+\t{\n+\t  gsi_prev (&gsi);\n+\t  if (gsi_end_p (gsi))\n+\t    return 0;\n+\t  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n+\t    return 0;\n+\t  if (TREE_CODE (gimple_assign_rhs1 (gsi_stmt (gsi))) != EXC_PTR_EXPR)\n+\t    return 0;\n+\t  if (exc_ptr_tmp != gimple_assign_lhs (gsi_stmt (gsi)))\n+\t    return 0;\n+\t  if (!single_imm_use (exc_ptr_tmp, &imm_use, &use_stmt))\n+\t    return 0;\n+\t}\n \n-  /* filter_object get.  */\n-  gsi_prev (&gsi);\n-  if (gsi_end_p (gsi))\n-    return 0;\n-  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n-    return 0;\n-  if (TREE_CODE (gimple_assign_rhs1 (gsi_stmt (gsi))) != FILTER_EXPR)\n-    return 0;\n+      /* filter_object get.  */\n+      if (TREE_CODE (filter_tmp) != FILTER_EXPR)\n+\t{\n+\t  gsi_prev (&gsi);\n+\t  if (gsi_end_p (gsi))\n+\t    return 0;\n+\t  if (gimple_code (gsi_stmt (gsi)) != GIMPLE_ASSIGN)\n+\t    return 0;\n+\t  if (TREE_CODE (gimple_assign_rhs1 (gsi_stmt (gsi))) != FILTER_EXPR)\n+\t    return 0;\n+\t  if (filter_tmp != gimple_assign_lhs (gsi_stmt (gsi)))\n+\t    return 0;\n+\t  if (!single_imm_use (filter_tmp, &imm_use, &use_stmt))\n+\t    return 0;\n+\t}\n \n-  /* label.  */\n-  gsi_prev (&gsi);\n-  if (gsi_end_p (gsi))\n-    return 0;\n-  if (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n-    return region;\n-  else\n-    return 0;\n+      /* label.  */\n+      gsi_prev (&gsi);\n+      if (gsi_end_p (gsi))\n+\treturn 0;\n+    }\n+  while (gimple_code (gsi_stmt (gsi)) == GIMPLE_LABEL)\n+    {\n+      if (gimple_label_label (gsi_stmt (gsi))\n+      \t  == get_eh_region_no_tree_label (region))\n+        return region;\n+      gsi_prev (&gsi);\n+      if (gsi_end_p (gsi))\n+\treturn 0;\n+    }\n+  return 0;\n+}\n+\n+/* Return true if it is possible to remove basic block BB and propagate\n+   through PHIs.  \n+\n+   This means that every PHI in BB has all uses such that they are PHIs\n+   of basic blocks reachable througt BB and they appears only in use\n+   reachable by the edge from BB to the block contianing the use.  \n+   \n+   This is same as in merge-phi code, but in slightly more general setting\n+   because BB can have multiple successors.  */\n+\n+static bool\n+all_phis_safe_to_merge (basic_block bb)\n+{\n+  gimple_stmt_iterator si;\n+  bool ok = true;\n+\n+  for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple phi = gsi_stmt (si);\n+      tree result = gimple_phi_result (phi);\n+      gimple stmt;\n+      use_operand_p imm_use;\n+      imm_use_iterator imm_iter;\n+\n+      /* If the PHI's result is never used, then we can just\n+\t ignore it.  */\n+      if (has_zero_uses (result))\n+        continue;\n+      /* We can always rebuild virtuals if needed.  */\n+      if (!is_gimple_reg (result))\n+\tcontinue;\n+      FOR_EACH_IMM_USE_STMT (stmt, imm_iter, result)\n+        {\n+\t  if (gimple_code (stmt) != GIMPLE_PHI)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t        fprintf (dump_file,\n+\t\t\t \"PHI result has use in non-PHI statement.\\n\");\n+\t      ok = false;\n+\t      BREAK_FROM_IMM_USE_STMT (imm_iter);\n+\t    }\n+\t  else\n+            FOR_EACH_IMM_USE_ON_STMT (imm_use, imm_iter)\n+\t      {\n+               edge e;\n+\t       e = gimple_phi_arg_edge (stmt, PHI_ARG_INDEX_FROM_USE (imm_use));\n+\t       if (e->src != bb)\n+\t         {\n+\t          if (dump_file && (dump_flags & TDF_DETAILS))\n+\t            fprintf (dump_file, \"PHI has use in PHI not reached from\"\n+\t\t    \t     \"empty cleanup itself.\\n\");\n+\t          ok = false;\n+\t\t  break;\n+\t         }\n+\t      }\n+\t   if (!ok)\n+\t     BREAK_FROM_IMM_USE_STMT (imm_iter);\n+\t }\n+       if (!ok)\n+         return false;\n+    }\n+  return ok;\n }\n \n static bool dominance_info_invalidated;\n \n+/* Information to pass into make_eh_edge_and_update_phi.  */\n+\n+struct update_info\n+{\n+  basic_block bb_to_remove, bb;\n+  edge edge_to_remove;\n+};\n+\n+/* DATA points to update-info structure.\n+   Like make_eh_edge create EH edge from DATA->bb to basic block containing\n+   handler of REGION.  In addition also update PHI operands by copying\n+   operands from DATA->bb_to_remove.  */\n+\n+static void\n+make_eh_edge_and_update_phi (struct eh_region *region, void *data)\n+{\n+  struct update_info *info = (struct update_info *) data;\n+  edge e, e2;\n+  tree lab;\n+  basic_block src, dst;\n+  gimple_stmt_iterator si;\n+\n+  lab = get_eh_region_tree_label (region);\n+\n+  src = info->bb;\n+  dst = label_to_block (lab);\n+\n+  e = find_edge (src, dst);\n+  if (e)\n+    {\n+      gcc_assert (e->flags & EDGE_EH);\n+      e->aux = e;\n+      return;\n+    }\n+  dominance_info_invalidated = true;\n+  e2 = find_edge (info->bb_to_remove, dst);\n+  e = make_edge (src, dst, EDGE_ABNORMAL | EDGE_EH);\n+  e->aux = e;\n+  gcc_assert (e2);\n+  for (si = gsi_start_phis (dst); !gsi_end_p (si); gsi_next (&si))\n+    {\n+      gimple phi = gsi_stmt (si);\n+      tree use = USE_FROM_PTR (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e2));\n+      gimple def = (TREE_CODE (use) == SSA_NAME\n+      \t\t    ? SSA_NAME_DEF_STMT (use) : NULL);\n+\n+      if (def && gimple_bb (def) == info->bb_to_remove)\n+        {\n+\t  use = USE_FROM_PTR (PHI_ARG_DEF_PTR_FROM_EDGE (def,\n+\t  \t\t\t\t\t\t info->edge_to_remove));\n+\t  gcc_assert (info->bb_to_remove == info->edge_to_remove->dest);\n+          def = TREE_CODE (use) == SSA_NAME ? SSA_NAME_DEF_STMT (use) : NULL;\n+\t  gcc_assert (!def\n+\t  \t      || gimple_bb (def) != info->bb_to_remove\n+\t  \t      || !is_gimple_reg (use));\n+        }\n+      SET_USE (PHI_ARG_DEF_PTR_FROM_EDGE (phi, e), use);\n+    }\n+}\n+\n+/* Make EH edges corresponding to STMT while updating PHI nodes after removal\n+   empty cleanup BB_TO_REMOVE joined to BB containing STMT\n+   by EDGE_TO_REMOVE.  */\n+\n+static void\n+update_eh_edges (gimple stmt, basic_block bb_to_remove, edge edge_to_remove)\n+{\n+  int region_nr;\n+  bool is_resx;\n+  bool inlinable = false;\n+  struct update_info info;\n+  edge_iterator ei;\n+  edge e;\n+  int probability_sum = 0;\n+\n+  info.bb_to_remove = bb_to_remove;\n+  info.bb = gimple_bb (stmt);\n+  info.edge_to_remove = edge_to_remove;\n+\n+  if (gimple_code (stmt) == GIMPLE_RESX)\n+    {\n+      region_nr = gimple_resx_region (stmt);\n+      is_resx = true;\n+    }\n+  else\n+    {\n+      region_nr = lookup_stmt_eh_region (stmt);\n+      if (region_nr < 0)\n+\treturn;\n+      is_resx = false;\n+      inlinable = inlinable_call_p (stmt);\n+    }\n+\n+  /* First add new edges as neccesary.  */\n+  foreach_reachable_handler (region_nr, is_resx, inlinable,\n+  \t\t\t     make_eh_edge_and_update_phi, &info);\n+\n+  /* And remove edges we didn't marked. */\n+  for (ei = ei_start (info.bb->succs); (e = ei_safe_edge (ei)); )\n+    {\n+      if ((e->flags & EDGE_EH) && !e->aux && e != edge_to_remove)\n+\t{\n+\t  dominance_info_invalidated = true;\n+\t  remove_edge (e);\n+\t}\n+      else\n+        {\n+\t  e->aux = NULL;\n+\t  probability_sum += e->probability;\n+\t  ei_next (&ei);\n+\t}\n+    }\n+\n+  /* Make CFG profile more consistent assuming that exception will resume to\n+     first available EH handler.  In practice this makes little difference, but\n+     we get fewer consistency errors in the dumps.  */\n+  if (is_resx && EDGE_COUNT (info.bb->succs) && !probability_sum)\n+    EDGE_SUCC (info.bb, 0)->probability = REG_BR_PROB_BASE;\n+}\n+\n /* Look for basic blocks containing empty exception handler and remove them.\n    This is similar to jump forwarding, just across EH edges.  */\n \n static bool\n cleanup_empty_eh (basic_block bb)\n {\n   int region;\n+  gimple_stmt_iterator si;\n \n   /* When handler of EH region winds up to be empty, we can safely\n      remove it.  This leads to inner EH regions to be redirected\n      to outer one, if present in function. So we need to rebuild\n      EH edges in all sources.   */\n-  if ((region = tree_empty_eh_handler_p (bb)))\n+  if ((region = tree_empty_eh_handler_p (bb))\n+      && all_phis_safe_to_merge (bb))\n     {\n-      edge_iterator ei;\n       edge e;\n-      gimple_stmt_iterator si;\n \n       remove_eh_region (region);\n \n-      /* It is safe to mark symbol for renaming because we have abnormal PHI\n-         here.  Once EH edges are made redirectable we might need to add here\n-         similar updating as jump threading does.  */\n-\n-      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n-\t{\n-\t  tree res = PHI_RESULT (gsi_stmt (si));\n-\t  gimple stmt;\n-\t  imm_use_iterator iter;\n-\t  use_operand_p use_p;\n-\n-\t  /* As we are going to delete this block we will release all\n-\t     defs which makes the immediate uses on use stmts invalid.\n-\t     Avoid that by replacing all uses with the bare variable\n-\t     and updating the stmts.  */\n-\t  FOR_EACH_IMM_USE_STMT (stmt, iter, res)\n-\t    {\n-\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n-\t\tSET_USE (use_p, SSA_NAME_VAR (res));\n-\t      update_stmt (stmt);\n-\t    }\n-\t  mark_sym_for_renaming (SSA_NAME_VAR (res));\n-\t}\n-\n-      /* We want to thread over the current receiver to the next reachable\n-         one.  Do so by deleting all outgoing EH edges from all\n-\t predecessors of the receiver block we are going to delete and\n-\t rebuild EH edges for them.  */\n       while ((e = ei_safe_edge (ei_start (bb->preds))))\n \t{\n \t  basic_block src = e->src;\n \t  gcc_assert (e->flags & EDGE_EH);\n-\t  for (ei = ei_start (src->succs); (e = ei_safe_edge (ei));)\n+\t  if (stmt_can_throw_internal (last_stmt (src)))\n+\t    update_eh_edges (last_stmt (src), bb, e);\n+\t  remove_edge (e);\n+\t}\n+      if (dump_file)\n+\tfprintf (dump_file, \"Empty EH handler %i removed\\n\", region);\n+\n+      /* Verify that we eliminated all uses of PHI we are going to remove.\n+         If we didn't, rebuild SSA on affected variable (this is allowed only\n+         for virtuals).  */\n+      for (si = gsi_start_phis (bb); !gsi_end_p (si); gsi_next (&si))\n+        {\n+          gimple phi = gsi_stmt (si);\n+          tree result = gimple_phi_result (phi);\n+          if (!has_zero_uses (result))\n \t    {\n-\t      if (e->flags & EDGE_EH)\n+              use_operand_p use_p;\n+              imm_use_iterator iter;\n+\t      gimple stmt;\n+\n+\t      FOR_EACH_IMM_USE_STMT (stmt, iter, result)\n \t\t{\n-\t\t  remove_edge (e);\n-\t\t  dominance_info_invalidated = true;\n+\t\t  /* We have use, see if it won't disappear after\n+\t\t     removing BB.  */\n+\t\t  if (gimple_bb (stmt) == bb)\n+\t\t    continue;\n+\t\t  if (gimple_code (stmt) == GIMPLE_PHI)\n+\t\t    {\n+\t\t      bool bad = false;\n+\n+\t\t      FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t                if (gimple_phi_arg_edge (stmt,\n+\t\t\t\tPHI_ARG_INDEX_FROM_USE (use_p))->src != bb)\n+\t\t\t  {\n+\t\t\t    bad = true;\n+\t\t\t    break;\n+\t\t\t  }\n+\n+\t\t      if (!bad)\n+\t\t        continue;\n+\t\t    }\n+\n+\t          gcc_assert (!is_gimple_reg (result));\n+\t          mark_sym_for_renaming (SSA_NAME_VAR (result));\n+\t          /* As we are going to delete this block we will release all\n+\t\t     defs which makes the immediate uses on use stmts invalid.\n+\t\t     Avoid that by replacing all uses with the bare variable\n+\t\t     and updating the stmts.  */\n+\t\t  FOR_EACH_IMM_USE_ON_STMT (use_p, iter)\n+\t\t    SET_USE (use_p, SSA_NAME_VAR (result));\n+\t\t  update_stmt (stmt);\n \t\t}\n-\t      else\n-\t\tei_next (&ei);\n \t    }\n-\t  if (!stmt_can_throw_internal (last_stmt (src)))\n-\t    continue;\n-\t  make_eh_edges (last_stmt (src));\n-\t  /* Make sure to also rename symbols that feed into receivers\n-\t     that are now newly reachable from current src.  */\n-\t  FOR_EACH_EDGE (e, ei, src->succs)\n-\t    if (e->flags & EDGE_EH)\n-\t      {\n-\t\tdominance_info_invalidated = true;\n-\t\tfor (si = gsi_start_phis (e->dest); !gsi_end_p (si);\n-\t\t     gsi_next (&si))\n-\t\t  mark_sym_for_renaming (SSA_NAME_VAR\n-\t\t\t\t\t (PHI_RESULT (gsi_stmt (si))));\n-\t      }\n \t}\n-      if (dump_file)\n-\tfprintf (dump_file, \"Empty EH handler %i removed\\n\", region);\n       delete_basic_block (bb);\n       return true;\n     }"}]}