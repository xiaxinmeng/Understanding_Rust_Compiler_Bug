{"sha": "47ee89044df766137024667ede685dd31e395164", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDdlZTg5MDQ0ZGY3NjYxMzcwMjQ2NjdlZGU2ODVkZDMxZTM5NTE2NA==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2001-06-06T07:03:03Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2001-06-06T07:03:03Z"}, "message": "* semantics.c (begin_class_definition): Robustify.\n\nFrom-SVN: r42937", "tree": {"sha": "998675f5fec8669765dfc87eb49169b66b42f636", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/998675f5fec8669765dfc87eb49169b66b42f636"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/47ee89044df766137024667ede685dd31e395164", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ee89044df766137024667ede685dd31e395164", "html_url": "https://github.com/Rust-GCC/gccrs/commit/47ee89044df766137024667ede685dd31e395164", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/47ee89044df766137024667ede685dd31e395164/comments", "author": null, "committer": null, "parents": [{"sha": "1b577f5a5837afa14a231a94161fb3d9a83e9a46", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/1b577f5a5837afa14a231a94161fb3d9a83e9a46", "html_url": "https://github.com/Rust-GCC/gccrs/commit/1b577f5a5837afa14a231a94161fb3d9a83e9a46"}], "stats": {"total": 37, "additions": 30, "deletions": 7}, "files": [{"sha": "829c4da9cbabcc353565d5912e79f6f17380cde7", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ee89044df766137024667ede685dd31e395164/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ee89044df766137024667ede685dd31e395164/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=47ee89044df766137024667ede685dd31e395164", "patch": "@@ -1,5 +1,7 @@\n 2001-06-05  Mark Mitchell  <mark@codesourcery.com>\n \n+\t* semantics.c (begin_class_definition): Robustify.\n+\n \t* pt.c (instantiate_decl): Tell the repository code about the\n \tclones, not the cloned functions.\n \t* repo.c (repo_template_used): Explicitly instantiate the cloned"}, {"sha": "f1a9e77aa7d204d2468087b573186dd17f63359b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 18, "deletions": 7, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ee89044df766137024667ede685dd31e395164/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ee89044df766137024667ede685dd31e395164/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=47ee89044df766137024667ede685dd31e395164", "patch": "@@ -1724,18 +1724,29 @@ begin_class_definition (t)\n       cp_error (\"definition of `%#T' inside template parameter list\", t);\n       return error_mark_node;\n     }\n-  if (t == error_mark_node\n-      || ! IS_AGGR_TYPE (t))\n+\n+  /* In a definition of a member class template, we will get here with\n+     an implicit typename.  */\n+  if (IMPLICIT_TYPENAME_P (t))\n+    t = TREE_TYPE (t);\n+  /* A non-implicit typename comes from code like:\n+\n+       template <typename T> struct A {\n+         template <typename U> struct A<T>::B ...\n+\n+     This is erroneous.  */\n+  else if (TREE_CODE (t) == TYPENAME_TYPE)\n+    {\n+      cp_error (\"invalid definition of qualified type `%T'\", t);\n+      t = error_mark_node;\n+    }\n+\n+  if (t == error_mark_node || ! IS_AGGR_TYPE (t))\n     {\n       t = make_aggr_type (RECORD_TYPE);\n       pushtag (make_anon_name (), t, 0);\n     }\n \n-  /* In a definition of a member class template, we will get here with an\n-     implicit typename, a TYPENAME_TYPE with a type.  */\n-  if (TREE_CODE (t) == TYPENAME_TYPE)\n-    t = TREE_TYPE (t);\n-  \n   /* If we generated a partial instantiation of this type, but now\n      we're seeing a real definition, we're actually looking at a\n      partial specialization.  Consider:"}, {"sha": "2295bea022d728566c37f2bdcef1f374bc254878", "filename": "gcc/testsuite/g++.old-deja/g++.pt/memtemp99.C", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/47ee89044df766137024667ede685dd31e395164/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp99.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/47ee89044df766137024667ede685dd31e395164/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp99.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.old-deja%2Fg%2B%2B.pt%2Fmemtemp99.C?ref=47ee89044df766137024667ede685dd31e395164", "patch": "@@ -0,0 +1,10 @@\n+// Build don't link:\n+// Origin: bitti@cs.tut.fi\n+\n+template<typename T, unsigned int N>\n+class Vector\n+{\n+public:\n+  template<unsigned int I>\n+  class Vector<T,N>::CommaInit { }; // ERROR - invalid definition\n+};"}]}