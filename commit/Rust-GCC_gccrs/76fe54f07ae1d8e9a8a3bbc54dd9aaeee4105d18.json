{"sha": "76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzZmZTU0ZjA3YWUxZDhlOWE4YTNiYmM1NGRkOWFhZWVlNDEwNWQxOA==", "commit": {"author": {"name": "H.J. Lu", "email": "hongjiu.lu@intel.com", "date": "2008-05-26T13:59:56Z"}, "committer": {"name": "H.J. Lu", "email": "hjl@gcc.gnu.org", "date": "2008-05-26T13:59:56Z"}, "message": "re PR middle-end/36253 (Caller-save stack slot may not have proper alignment)\n\n2008-05-26  H.J. Lu  <hongjiu.lu@intel.com>\n\n\tPR middle-end/36253\n\t* caller-save.c (insert_restore): Verify alignment of spill\n\tspace.\n\t(insert_save): Likewise.\n\n\t* cfgexpand.c (LOCAL_ALIGNMENT): Removed.\n\n\t* defaults.h (LOCAL_ALIGNMENT): New. Provide default.\n\t(STACK_SLOT_ALIGNMENT): Likewise.\n\n\t* function.c (LOCAL_ALIGNMENT): Removed.\n\t(get_stack_local_alignment): New.\n\t(assign_stack_local): Use it.  Set alignment on stack slot.\n\t(assign_stack_temp_for_type): Use get_stack_local_alignment.\n\n\t* config/i386/i386.h (LOCAL_ALIGNMENT): Updated.\n\t(STACK_SLOT_ALIGNMENT): New.\n\n\t* config/i386/i386.c (ix86_local_alignment): Handle caller-save\n\tstack slot in XFmode.\n\n\t* doc/tm.texi (STACK_SLOT_ALIGNMENT): New.\n\nFrom-SVN: r135927", "tree": {"sha": "bb649ed6b0709e0e99f74f303514800816a201fe", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/bb649ed6b0709e0e99f74f303514800816a201fe"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "html_url": "https://github.com/Rust-GCC/gccrs/commit/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/comments", "author": {"login": "hjl-tools", "id": 1072356, "node_id": "MDQ6VXNlcjEwNzIzNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/1072356?v=4", "gravatar_id": "", "url": "https://api.github.com/users/hjl-tools", "html_url": "https://github.com/hjl-tools", "followers_url": "https://api.github.com/users/hjl-tools/followers", "following_url": "https://api.github.com/users/hjl-tools/following{/other_user}", "gists_url": "https://api.github.com/users/hjl-tools/gists{/gist_id}", "starred_url": "https://api.github.com/users/hjl-tools/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/hjl-tools/subscriptions", "organizations_url": "https://api.github.com/users/hjl-tools/orgs", "repos_url": "https://api.github.com/users/hjl-tools/repos", "events_url": "https://api.github.com/users/hjl-tools/events{/privacy}", "received_events_url": "https://api.github.com/users/hjl-tools/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e94a83856fa29fc559ab6bfe013ea6cf16f401fa", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e94a83856fa29fc559ab6bfe013ea6cf16f401fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e94a83856fa29fc559ab6bfe013ea6cf16f401fa"}], "stats": {"total": 164, "additions": 122, "deletions": 42}, "files": [{"sha": "a6fad4f55efd1f8e890b0e01ed643c95f218abcf", "filename": "gcc/ChangeLog", "status": "modified", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -1,3 +1,28 @@\n+2008-05-26  H.J. Lu  <hongjiu.lu@intel.com>\n+\n+\tPR middle-end/36253\n+\t* caller-save.c (insert_restore): Verify alignment of spill\n+\tspace.\n+\t(insert_save): Likewise.\n+\n+\t* cfgexpand.c (LOCAL_ALIGNMENT): Removed.\n+\n+\t* defaults.h (LOCAL_ALIGNMENT): New. Provide default.\n+\t(STACK_SLOT_ALIGNMENT): Likewise.\n+\n+\t* function.c (LOCAL_ALIGNMENT): Removed.\n+\t(get_stack_local_alignment): New.\n+\t(assign_stack_local): Use it.  Set alignment on stack slot.\n+\t(assign_stack_temp_for_type): Use get_stack_local_alignment.\n+\n+\t* config/i386/i386.h (LOCAL_ALIGNMENT): Updated.\n+\t(STACK_SLOT_ALIGNMENT): New.\n+\n+\t* config/i386/i386.c (ix86_local_alignment): Handle caller-save\n+\tstack slot in XFmode.\n+\n+\t* doc/tm.texi (STACK_SLOT_ALIGNMENT): New.\n+\n 2008-05-26  Kai Tietz  <kai.tietz@onevision.com>\n \n \tPR/36321"}, {"sha": "c6a685bde9c5a19ba557e965d16ebd11f278b116", "filename": "gcc/caller-save.c", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fcaller-save.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fcaller-save.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcaller-save.c?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -704,6 +704,11 @@ insert_restore (struct insn_chain *chain, int before_p, int regno,\n     mem = adjust_address (mem, save_mode[regno], 0);\n   else\n     mem = copy_rtx (mem);\n+\n+  /* Verify that the alignment of spill space is equal to or greater\n+     than required.  */\n+  gcc_assert (GET_MODE_ALIGNMENT (GET_MODE (mem)) <= MEM_ALIGN (mem));\n+\n   pat = gen_rtx_SET (VOIDmode,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno), mem);\n@@ -776,6 +781,11 @@ insert_save (struct insn_chain *chain, int before_p, int regno,\n     mem = adjust_address (mem, save_mode[regno], 0);\n   else\n     mem = copy_rtx (mem);\n+\n+  /* Verify that the alignment of spill space is equal to or greater\n+     than required.  */\n+  gcc_assert (GET_MODE_ALIGNMENT (GET_MODE (mem)) <= MEM_ALIGN (mem));\n+\n   pat = gen_rtx_SET (VOIDmode, mem,\n \t\t     gen_rtx_REG (GET_MODE (mem),\n \t\t\t\t  regno));"}, {"sha": "ffe2366a1084b63867c8de5aa5ea8b50f842854c", "filename": "gcc/cfgexpand.c", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fcfgexpand.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fcfgexpand.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfgexpand.c?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -86,10 +86,6 @@ add_reg_br_prob_note (rtx last, int probability)\n }\n \n \n-#ifndef LOCAL_ALIGNMENT\n-#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n-#endif\n-\n #ifndef STACK_ALIGNMENT_NEEDED\n #define STACK_ALIGNMENT_NEEDED 1\n #endif"}, {"sha": "6fdea06c51857728953f80fd29e1575adcf177d8", "filename": "gcc/config/i386/i386-protos.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386-protos.h?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -187,7 +187,8 @@ extern void function_arg_advance (CUMULATIVE_ARGS *, enum machine_mode,\n extern int ix86_return_pops_args (tree, tree, int);\n \n extern int ix86_data_alignment (tree, int);\n-extern int ix86_local_alignment (tree, int);\n+extern unsigned int ix86_local_alignment (tree, enum machine_mode,\n+\t\t\t\t\t  unsigned int);\n extern int ix86_constant_alignment (tree, int);\n extern tree ix86_handle_shared_attribute (tree *, tree, tree, int, bool *);\n extern tree ix86_handle_selectany_attribute (tree *, tree, tree, int, bool *);"}, {"sha": "6cac18ae8aa65c46270bcebe015c5114a041d1a5", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 17, "deletions": 6, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -16996,14 +16996,25 @@ ix86_data_alignment (tree type, int align)\n   return align;\n }\n \n-/* Compute the alignment for a local variable.\n-   TYPE is the data type, and ALIGN is the alignment that\n-   the object would ordinarily have.  The value of this macro is used\n-   instead of that alignment to align the object.  */\n+/* Compute the alignment for a local variable or a stack slot.  TYPE is\n+   the data type, MODE is the widest mode available and ALIGN is the\n+   alignment that the object would ordinarily have.  The value of this\n+   macro is used instead of that alignment to align the object.  */\n \n-int\n-ix86_local_alignment (tree type, int align)\n+unsigned int\n+ix86_local_alignment (tree type, enum machine_mode mode,\n+\t\t      unsigned int align)\n {\n+  /* If TYPE is NULL, we are allocating a stack slot for caller-save\n+     register in MODE.  We will return the largest alignment of XF\n+     and DF.  */\n+  if (!type)\n+    {\n+      if (mode == XFmode && align < GET_MODE_ALIGNMENT (DFmode))\n+\talign = GET_MODE_ALIGNMENT (DFmode);\n+      return align;\n+    }\n+\n   /* x86-64 ABI requires arrays greater than 16 bytes to be aligned\n      to 16byte boundary.  */\n   if (TARGET_64BIT)"}, {"sha": "ef8da17af3ff120bc9261350d95cbcbdcd4f23ee", "filename": "gcc/config/i386/i386.h", "status": "modified", "additions": 16, "deletions": 1, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fconfig%2Fi386%2Fi386.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.h?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -902,7 +902,22 @@ enum target_cpu_default\n    One use of this macro is to increase alignment of medium-size\n    data to make it all fit in fewer cache lines.  */\n \n-#define LOCAL_ALIGNMENT(TYPE, ALIGN) ix86_local_alignment ((TYPE), (ALIGN))\n+#define LOCAL_ALIGNMENT(TYPE, ALIGN) \\\n+  ix86_local_alignment ((TYPE), VOIDmode, (ALIGN))\n+\n+/* If defined, a C expression to compute the alignment for stack slot.\n+   TYPE is the data type, MODE is the widest mode available, and ALIGN\n+   is the alignment that the slot would ordinarily have.  The value of\n+   this macro is used instead of that alignment to align the slot.\n+\n+   If this macro is not defined, then ALIGN is used when TYPE is NULL,\n+   Otherwise, LOCAL_ALIGNMENT will be used.\n+\n+   One use of this macro is to set alignment of stack slot to the\n+   maximum alignment of all possible modes which the slot may have.  */\n+\n+#define STACK_SLOT_ALIGNMENT(TYPE, MODE, ALIGN) \\\n+  ix86_local_alignment ((TYPE), (MODE), (ALIGN))\n \n /* If defined, a C expression that gives the alignment boundary, in\n    bits, of an argument with the specified mode and type.  If it is"}, {"sha": "392d22cfabb755ae515a7fa22bf699661e9303dd", "filename": "gcc/defaults.h", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fdefaults.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fdefaults.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdefaults.h?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -940,4 +940,13 @@ along with GCC; see the file COPYING3.  If not see\n #define OUTGOING_REG_PARM_STACK_SPACE(FNTYPE) 0\n #endif\n \n+#ifndef LOCAL_ALIGNMENT\n+#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n+#endif\n+\n+#ifndef STACK_SLOT_ALIGNMENT\n+#define STACK_SLOT_ALIGNMENT(TYPE,MODE,ALIGN) \\\n+  ((TYPE) ? LOCAL_ALIGNMENT ((TYPE), (ALIGN)) : (ALIGN))\n+#endif\n+\n #endif  /* ! GCC_DEFAULTS_H */"}, {"sha": "eeb744bd60dccab9bc2c5c7fb6ea60426e3c628c", "filename": "gcc/doc/tm.texi", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fdoc%2Ftm.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Fdoc%2Ftm.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Ftm.texi?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -1172,6 +1172,21 @@ One use of this macro is to increase alignment of medium-size data to\n make it all fit in fewer cache lines.\n @end defmac\n \n+@defmac STACK_SLOT_ALIGNMENT (@var{type}, @var{mode}, @var{basic-align})\n+If defined, a C expression to compute the alignment for stack slot.\n+@var{type} is the data type, @var{mode} is the widest mode available,\n+and @var{basic-align} is the alignment that the slot would ordinarily\n+have.  The value of this macro is used instead of that alignment to\n+align the slot.\n+\n+If this macro is not defined, then @var{basic-align} is used when\n+@var{type} is @code{NULL}.  Otherwise, @code{LOCAL_ALIGNMENT} will\n+be used.\n+\n+This macro is to set alignment of stack slot to the maximum alignment\n+of all possible modes which the slot may have.\n+@end defmac\n+\n @defmac EMPTY_FIELD_BOUNDARY\n Alignment in bits to be given to a structure bit-field that follows an\n empty field such as @code{int : 0;}."}, {"sha": "845017f7124b09bd93d66cbc8dc6a773b2b350d7", "filename": "gcc/function.c", "status": "modified", "additions": 28, "deletions": 30, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Ffunction.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18/gcc%2Ffunction.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffunction.c?ref=76fe54f07ae1d8e9a8a3bbc54dd9aaeee4105d18", "patch": "@@ -69,10 +69,6 @@ along with GCC; see the file COPYING3.  If not see\n /* So we can assign to cfun in this file.  */\n #undef cfun\n \n-#ifndef LOCAL_ALIGNMENT\n-#define LOCAL_ALIGNMENT(TYPE, ALIGNMENT) ALIGNMENT\n-#endif\n-\n #ifndef STACK_ALIGNMENT_NEEDED\n #define STACK_ALIGNMENT_NEEDED 1\n #endif\n@@ -325,6 +321,26 @@ frame_offset_overflow (HOST_WIDE_INT offset, tree func)\n   return FALSE;\n }\n \n+/* Return stack slot alignment in bits for TYPE and MODE.  */\n+\n+static unsigned int\n+get_stack_local_alignment (tree type, enum machine_mode mode)\n+{\n+  unsigned int alignment;\n+\n+  if (mode == BLKmode)\n+    alignment = BIGGEST_ALIGNMENT;\n+  else\n+    alignment = GET_MODE_ALIGNMENT (mode);\n+\n+  /* Allow the frond-end to (possibly) increase the alignment of this\n+     stack slot.  */\n+  if (! type)\n+    type = lang_hooks.types.type_for_mode (mode, 0);\n+\n+  return STACK_SLOT_ALIGNMENT (type, mode, alignment);\n+}\n+\n /* Allocate a stack slot of SIZE bytes and return a MEM rtx for it\n    with machine mode MODE.\n \n@@ -341,24 +357,12 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n {\n   rtx x, addr;\n   int bigend_correction = 0;\n-  unsigned int alignment;\n+  unsigned int alignment, alignment_in_bits;\n   int frame_off, frame_alignment, frame_phase;\n \n   if (align == 0)\n     {\n-      tree type;\n-\n-      if (mode == BLKmode)\n-\talignment = BIGGEST_ALIGNMENT;\n-      else\n-\talignment = GET_MODE_ALIGNMENT (mode);\n-\n-      /* Allow the target to (possibly) increase the alignment of this\n-\t stack slot.  */\n-      type = lang_hooks.types.type_for_mode (mode, 0);\n-      if (type)\n-\talignment = LOCAL_ALIGNMENT (type, alignment);\n-\n+      alignment = get_stack_local_alignment (NULL, mode);\n       alignment /= BITS_PER_UNIT;\n     }\n   else if (align == -1)\n@@ -378,8 +382,10 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n   if (alignment * BITS_PER_UNIT > PREFERRED_STACK_BOUNDARY)\n     alignment = PREFERRED_STACK_BOUNDARY / BITS_PER_UNIT;\n \n-  if (crtl->stack_alignment_needed < alignment * BITS_PER_UNIT)\n-    crtl->stack_alignment_needed = alignment * BITS_PER_UNIT;\n+  alignment_in_bits = alignment * BITS_PER_UNIT;\n+\n+  if (crtl->stack_alignment_needed < alignment_in_bits)\n+    crtl->stack_alignment_needed = alignment_in_bits;\n \n   /* Calculate how many bytes the start of local variables is off from\n      stack alignment.  */\n@@ -432,6 +438,7 @@ assign_stack_local (enum machine_mode mode, HOST_WIDE_INT size, int align)\n     frame_offset += size;\n \n   x = gen_rtx_MEM (mode, addr);\n+  set_mem_align (x, alignment_in_bits);\n   MEM_NOTRAP_P (x) = 1;\n \n   stack_slot_list\n@@ -544,16 +551,7 @@ assign_stack_temp_for_type (enum machine_mode mode, HOST_WIDE_INT size,\n   /* These are now unused.  */\n   gcc_assert (keep <= 1);\n \n-  if (mode == BLKmode)\n-    align = BIGGEST_ALIGNMENT;\n-  else\n-    align = GET_MODE_ALIGNMENT (mode);\n-\n-  if (! type)\n-    type = lang_hooks.types.type_for_mode (mode, 0);\n-\n-  if (type)\n-    align = LOCAL_ALIGNMENT (type, align);\n+  align = get_stack_local_alignment (type, mode);\n \n   /* Try to find an available, already-allocated temporary of the proper\n      mode which meets the size and alignment requirements.  Choose the"}]}