{"sha": "aaf0766e9f897b2fbce053083d85cb739cb509d2", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YWFmMDc2NmU5Zjg5N2IyZmJjZTA1MzA4M2Q4NWNiNzM5Y2I1MDlkMg==", "commit": {"author": {"name": "Tom Tromey", "email": "tromey@cygnus.com", "date": "2000-02-10T20:31:48Z"}, "committer": {"name": "Tom Tromey", "email": "tromey@gcc.gnu.org", "date": "2000-02-10T20:31:48Z"}, "message": "natNativeThread.cc: New file.\n\n\t* gnu/gcj/jni/natNativeThread.cc: New file.\n\t* gnu/gcj/jni/NativeThread.java: New file.\n\t* java/lang/Thread.java (data): Now a RawData.\n\t* include/jvm.h (_Jv_GetCurrentJNIEnv, _Jv_SetCurrentJNIEnv):\n\tDeclare.\n\t* Makefile.in: Rebuilt.\n\t* Makefile.am (java/lang/Thread.h): New target.\n\t(ordinary_java_source_files): Added NativeThread.java.\n\t(nat_source_files): Added natNativeThread.cc.\n\t* java/lang/natThread.cc: Include <jni.h>\n\t(struct natThread): Added `jni_env' field.\n\t(_Jv_GetCurrentJNIEnv): New function.\n\t(_Jv_SetCurrentJNIEnv): Likewise.\n\t(initialize_native): Initialize jni_env.\n\tInclude RawData.h.\n\t* jni.cc (ThreadGroupClass): New define.\n\t(_Jv_JNI_InvokeFunctions): New structure.\n\t(JNI_GetCreatedJavaVMs): New function.\n\t(the_vm): New global.\n\t(JNI_GetDefaultJavaVMInitArgs): New function.\n\tInclude NativeThread.h.\n\t(NativeThreadClass): New define.\n\t(_Jv_JNI_EnsureLocalCapacity): Return JNI_ERR, not -1.\n\t(_Jv_JNI_DestroyJavaVM): New function.\n\t(_Jv_JNI_AttachCurrentThread): New function.\n\t(_Jv_JNI_DetachCurrentThread): New function.\n\t(_Jv_JNI_GetEnv): New function.\n\t(JNI_CreateJavaVM): New function.\n\t(_Jv_JNI_GetJavaVM): New function.\n\t(_Jv_JNIFunctions): Added entry for GetJavaVM.\n\t* include/jni.h (JavaVMAttachArgs): New structure.\n\t(JNI_EDETACHED): New define.\n\t(JNI_EVERSION): Likewise.\n\t(JavaVM): Define properly.\n\t(struct JNIInvokeInterface): New structure.\n\t(class _Jv_JavaVM): New class.\n\t(JNI_OnLoad, JNI_OnUnload): Declare.\n\t(JNI_GetDefaultJavaVMInitArgs, JNI_CreateJavaVM,\n\tJNI_GetCreatedJavaVMs): Declare.\n\t(JavaVMInitArgs): New typedef.\n\t(JavaVMOption): Likewise.\n\t(JNI_ERR): New define.\n\t(JNI_OK): Likewise.\n\nFrom-SVN: r31901", "tree": {"sha": "893852baae8ef6aa653f36d94ed11d6728aa30ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/893852baae8ef6aa653f36d94ed11d6728aa30ea"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/aaf0766e9f897b2fbce053083d85cb739cb509d2", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf0766e9f897b2fbce053083d85cb739cb509d2", "html_url": "https://github.com/Rust-GCC/gccrs/commit/aaf0766e9f897b2fbce053083d85cb739cb509d2", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/aaf0766e9f897b2fbce053083d85cb739cb509d2/comments", "author": null, "committer": null, "parents": [{"sha": "ef86eabb6c290a9d77d74d63f2b5041a096841d9", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/ef86eabb6c290a9d77d74d63f2b5041a096841d9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/ef86eabb6c290a9d77d74d63f2b5041a096841d9"}], "stats": {"total": 590, "additions": 560, "deletions": 30}, "files": [{"sha": "91485fc98b09abb8175ce4041c9119327523b039", "filename": "libjava/ChangeLog", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FChangeLog?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -1,3 +1,49 @@\n+2000-02-10  Tom Tromey  <tromey@cygnus.com>\n+\n+\t* gnu/gcj/jni/natNativeThread.cc: New file.\n+\t* gnu/gcj/jni/NativeThread.java: New file.\n+\t* java/lang/Thread.java (data): Now a RawData.\n+\t* include/jvm.h (_Jv_GetCurrentJNIEnv, _Jv_SetCurrentJNIEnv):\n+\tDeclare.\n+\t* Makefile.in: Rebuilt.\n+\t* Makefile.am (java/lang/Thread.h): New target.\n+\t(ordinary_java_source_files): Added NativeThread.java.\n+\t(nat_source_files): Added natNativeThread.cc.\n+\t* java/lang/natThread.cc: Include <jni.h>\n+\t(struct natThread): Added `jni_env' field.\n+\t(_Jv_GetCurrentJNIEnv): New function.\n+\t(_Jv_SetCurrentJNIEnv): Likewise.\n+\t(initialize_native): Initialize jni_env.\n+\tInclude RawData.h.\n+\t* jni.cc (ThreadGroupClass): New define.\n+\t(_Jv_JNI_InvokeFunctions): New structure.\n+\t(JNI_GetCreatedJavaVMs): New function.\n+\t(the_vm): New global.\n+\t(JNI_GetDefaultJavaVMInitArgs): New function.\n+\tInclude NativeThread.h.\n+\t(NativeThreadClass): New define.\n+\t(_Jv_JNI_EnsureLocalCapacity): Return JNI_ERR, not -1.\n+\t(_Jv_JNI_DestroyJavaVM): New function.\n+\t(_Jv_JNI_AttachCurrentThread): New function.\n+\t(_Jv_JNI_DetachCurrentThread): New function.\n+\t(_Jv_JNI_GetEnv): New function.\n+\t(JNI_CreateJavaVM): New function.\n+\t(_Jv_JNI_GetJavaVM): New function.\n+\t(_Jv_JNIFunctions): Added entry for GetJavaVM.\n+\t* include/jni.h (JavaVMAttachArgs): New structure.\n+\t(JNI_EDETACHED): New define.\n+\t(JNI_EVERSION): Likewise.\n+\t(JavaVM): Define properly.\n+\t(struct JNIInvokeInterface): New structure.\n+\t(class _Jv_JavaVM): New class.\n+\t(JNI_OnLoad, JNI_OnUnload): Declare.\n+\t(JNI_GetDefaultJavaVMInitArgs, JNI_CreateJavaVM,\n+\tJNI_GetCreatedJavaVMs): Declare.\n+\t(JavaVMInitArgs): New typedef.\n+\t(JavaVMOption): Likewise.\n+\t(JNI_ERR): New define.\n+\t(JNI_OK): Likewise.\n+\n 2000-02-10  Andrew Haley  <aph@cygnus.com>\n \n \t* interpret.cc: Don't include fdlibm.h."}, {"sha": "c22a2c8b99c56ac2c7464ec5e622ed02045f14ee", "filename": "libjava/Makefile.am", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.am?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -221,6 +221,16 @@ java/lang/FirstThread.h: java/lang/FirstThread.class libgcj.zip\n \t\t-friend 'void _Jv_RunMain (const char*, int, const char **);' \\\n \t\t$(basename $<)\n \n+java/lang/Thread.h: java/lang/Thread.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t\t-prepend 'class _Jv_JNIEnv;' \\\n+## Eww.\n+\t\t-prepend 'extern \"Java\" { namespace gnu { namespace gcj { namespace jni { class NativeThread; } } } };' \\\n+\t\t-friend '_Jv_JNIEnv * _Jv_GetCurrentJNIEnv ();' \\\n+\t\t-friend 'void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *env);' \\\n+\t\t-friend 'class gnu::gcj::jni::NativeThread;' \\\n+\t\t$(basename $<)\n+\n java/lang/String.h: java/lang/String.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jchar* _Jv_GetStringChars (jstring str);' \\\n@@ -512,6 +522,7 @@ built_java_source_files = java/lang/ConcreteProcess.java\n ## convert_source_files.  If the .java file has a hand-maintained\n ## header, please list it in special_java_source_files.\n ordinary_java_source_files =  $(convert_source_files) \\\n+gnu/gcj/jni/NativeThread.java \\\n gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n@@ -796,6 +807,7 @@ gnu/gcj/convert/natInput_EUCJIS.cc \\\n gnu/gcj/convert/natInput_SJIS.cc \\\n gnu/gcj/convert/natOutput_EUCJIS.cc \\\n gnu/gcj/convert/natOutput_SJIS.cc \\\n+gnu/gcj/jni/natNativeThread.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/lang/natCharacter.cc \\"}, {"sha": "dada6e9f02821efb859f986b64b27b660336535a", "filename": "libjava/Makefile.in", "status": "modified", "additions": 59, "deletions": 16, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2FMakefile.in?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -326,6 +326,7 @@ java/awt/peer/WindowPeer.java\n built_java_source_files = java/lang/ConcreteProcess.java\n \n ordinary_java_source_files = $(convert_source_files) \\\n+gnu/gcj/jni/NativeThread.java \\\n gnu/gcj/runtime/MethodInvocation.java \\\n gnu/gcj/runtime/VMClassLoader.java \\\n gnu/gcj/text/BaseBreakIterator.java \\\n@@ -610,6 +611,7 @@ gnu/gcj/convert/natInput_EUCJIS.cc \\\n gnu/gcj/convert/natInput_SJIS.cc \\\n gnu/gcj/convert/natOutput_EUCJIS.cc \\\n gnu/gcj/convert/natOutput_SJIS.cc \\\n+gnu/gcj/jni/natNativeThread.cc \\\n java/io/natFile.cc \\\n java/io/natFileDescriptor.cc \\\n java/lang/natCharacter.cc \\\n@@ -730,7 +732,8 @@ LINK = $(LIBTOOL) --mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(LDFLAGS) -o $@\n DATA =  $(data_DATA) $(toolexeclib_DATA)\n \n DIST_COMMON =  README COPYING.LIB ChangeLog Makefile.am Makefile.in NEWS \\\n-THANKS acinclude.m4 aclocal.m4 configure configure.in libgcj.spec.in\n+THANKS acconfig.h acinclude.m4 aclocal.m4 configure configure.in \\\n+include/config.h.in include/stamp-h.in libgcj.spec.in\n \n \n DISTFILES = $(DIST_COMMON) $(SOURCES) $(HEADERS) $(TEXINFOS) $(EXTRA_DIST)\n@@ -752,8 +755,8 @@ DEP_FILES =  .deps/$(srcdir)/$(CONVERT_DIR)/gen-from-JIS.P \\\n .deps/gnu/gcj/convert/Output_JavaSrc.P \\\n .deps/gnu/gcj/convert/Output_SJIS.P .deps/gnu/gcj/convert/Output_UTF8.P \\\n .deps/gnu/gcj/convert/Output_iconv.P \\\n-.deps/gnu/gcj/convert/UnicodeToBytes.P .deps/gnu/gcj/math/MPN.P \\\n-.deps/gnu/gcj/protocol/file/Connection.P \\\n+.deps/gnu/gcj/convert/UnicodeToBytes.P .deps/gnu/gcj/jni/NativeThread.P \\\n+.deps/gnu/gcj/math/MPN.P .deps/gnu/gcj/protocol/file/Connection.P \\\n .deps/gnu/gcj/protocol/file/Handler.P \\\n .deps/gnu/gcj/protocol/http/Connection.P \\\n .deps/gnu/gcj/protocol/http/Handler.P \\\n@@ -955,6 +958,34 @@ config.status: $(srcdir)/configure $(CONFIG_STATUS_DEPENDENCIES)\n \t$(SHELL) ./config.status --recheck\n $(srcdir)/configure: @MAINTAINER_MODE_TRUE@$(srcdir)/configure.in $(ACLOCAL_M4) $(CONFIGURE_DEPENDENCIES)\n \tcd $(srcdir) && $(AUTOCONF)\n+\n+include/config.h: include/stamp-h\n+\t@if test ! -f $@; then \\\n+\t\trm -f include/stamp-h; \\\n+\t\t$(MAKE) include/stamp-h; \\\n+\telse :; fi\n+include/stamp-h: $(srcdir)/include/config.h.in $(top_builddir)/config.status\n+\tcd $(top_builddir) \\\n+\t  && CONFIG_FILES= CONFIG_HEADERS=include/config.h \\\n+\t     $(SHELL) ./config.status\n+\t@echo timestamp > include/stamp-h 2> /dev/null\n+$(srcdir)/include/config.h.in: @MAINTAINER_MODE_TRUE@$(srcdir)/include/stamp-h.in\n+\t@if test ! -f $@; then \\\n+\t\trm -f $(srcdir)/include/stamp-h.in; \\\n+\t\t$(MAKE) $(srcdir)/include/stamp-h.in; \\\n+\telse :; fi\n+$(srcdir)/include/stamp-h.in: $(top_srcdir)/configure.in $(ACLOCAL_M4) acconfig.h\n+\tcd $(top_srcdir) && $(AUTOHEADER)\n+\t@echo timestamp > $(srcdir)/include/stamp-h.in 2> /dev/null\n+\n+mostlyclean-hdr:\n+\n+clean-hdr:\n+\n+distclean-hdr:\n+\t-rm -f include/config.h\n+\n+maintainer-clean-hdr:\n libgcj.spec: $(top_builddir)/config.status libgcj.spec.in\n \tcd $(top_builddir) && CONFIG_FILES=$@ CONFIG_HEADERS= $(SHELL) ./config.status\n \n@@ -1393,31 +1424,33 @@ distclean-generic:\n \t-rm -f config.cache config.log stamp-h stamp-h[0-9]*\n \n maintainer-clean-generic:\n-mostlyclean-am:  mostlyclean-toolexeclibLIBRARIES mostlyclean-compile \\\n-\t\tmostlyclean-libtool mostlyclean-toolexeclibLTLIBRARIES \\\n+mostlyclean-am:  mostlyclean-hdr mostlyclean-toolexeclibLIBRARIES \\\n+\t\tmostlyclean-compile mostlyclean-libtool \\\n+\t\tmostlyclean-toolexeclibLTLIBRARIES \\\n \t\tmostlyclean-binPROGRAMS mostlyclean-noinstPROGRAMS \\\n \t\tmostlyclean-tags mostlyclean-depend mostlyclean-generic\n \n mostlyclean: mostlyclean-recursive\n \n-clean-am:  clean-toolexeclibLIBRARIES clean-compile clean-libtool \\\n-\t\tclean-toolexeclibLTLIBRARIES clean-binPROGRAMS \\\n-\t\tclean-noinstPROGRAMS clean-tags clean-depend \\\n-\t\tclean-generic mostlyclean-am clean-local\n+clean-am:  clean-hdr clean-toolexeclibLIBRARIES clean-compile \\\n+\t\tclean-libtool clean-toolexeclibLTLIBRARIES \\\n+\t\tclean-binPROGRAMS clean-noinstPROGRAMS clean-tags \\\n+\t\tclean-depend clean-generic mostlyclean-am clean-local\n \n clean: clean-recursive\n \n-distclean-am:  distclean-toolexeclibLIBRARIES distclean-compile \\\n-\t\tdistclean-libtool distclean-toolexeclibLTLIBRARIES \\\n-\t\tdistclean-binPROGRAMS distclean-noinstPROGRAMS \\\n-\t\tdistclean-tags distclean-depend distclean-generic \\\n-\t\tclean-am\n+distclean-am:  distclean-hdr distclean-toolexeclibLIBRARIES \\\n+\t\tdistclean-compile distclean-libtool \\\n+\t\tdistclean-toolexeclibLTLIBRARIES distclean-binPROGRAMS \\\n+\t\tdistclean-noinstPROGRAMS distclean-tags \\\n+\t\tdistclean-depend distclean-generic clean-am\n \t-rm -f libtool\n \n distclean: distclean-recursive\n \t-rm -f config.status\n \n-maintainer-clean-am:  maintainer-clean-toolexeclibLIBRARIES \\\n+maintainer-clean-am:  maintainer-clean-hdr \\\n+\t\tmaintainer-clean-toolexeclibLIBRARIES \\\n \t\tmaintainer-clean-compile maintainer-clean-libtool \\\n \t\tmaintainer-clean-toolexeclibLTLIBRARIES \\\n \t\tmaintainer-clean-binPROGRAMS \\\n@@ -1430,7 +1463,8 @@ maintainer-clean-am:  maintainer-clean-toolexeclibLIBRARIES \\\n maintainer-clean: maintainer-clean-recursive\n \t-rm -f config.status\n \n-.PHONY: mostlyclean-toolexeclibLIBRARIES distclean-toolexeclibLIBRARIES \\\n+.PHONY: mostlyclean-hdr distclean-hdr clean-hdr maintainer-clean-hdr \\\n+mostlyclean-toolexeclibLIBRARIES distclean-toolexeclibLIBRARIES \\\n clean-toolexeclibLIBRARIES maintainer-clean-toolexeclibLIBRARIES \\\n uninstall-toolexeclibLIBRARIES install-toolexeclibLIBRARIES \\\n mostlyclean-compile distclean-compile clean-compile \\\n@@ -1514,6 +1548,15 @@ java/lang/FirstThread.h: java/lang/FirstThread.class libgcj.zip\n \t\t-friend 'void _Jv_RunMain (const char*, int, const char **);' \\\n \t\t$(basename $<)\n \n+java/lang/Thread.h: java/lang/Thread.class libgcj.zip\n+\t$(GCJH) -classpath $(top_builddir) \\\n+\t\t-prepend 'class _Jv_JNIEnv;' \\\n+\t\t-prepend 'extern \"Java\" { namespace gnu { namespace gcj { namespace jni { class NativeThread; } } } };' \\\n+\t\t-friend '_Jv_JNIEnv * _Jv_GetCurrentJNIEnv ();' \\\n+\t\t-friend 'void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *env);' \\\n+\t\t-friend 'class gnu::gcj::jni::NativeThread;' \\\n+\t\t$(basename $<)\n+\n java/lang/String.h: java/lang/String.class libgcj.zip\n \t$(GCJH) -classpath $(top_builddir) \\\n \t    -friend 'jchar* _Jv_GetStringChars (jstring str);' \\"}, {"sha": "9ed6d89cfac777f86eaffe7d0fbabd106bb2ba27", "filename": "libjava/gnu/gcj/jni/NativeThread.java", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjni%2FNativeThread.java?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -0,0 +1,28 @@\n+// NativeThread.java - Wrapper for attached user threads.\n+\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+package gnu.gcj.jni;\n+\n+/**\n+ * @author Tom Tromey <tromey@cygnus.com>\n+ * @date February 9, 2000\n+ */\n+\n+public class NativeThread extends Thread\n+{\n+  public NativeThread (ThreadGroup g, String name)\n+  {\n+    super (g, null, name);\n+    alive_flag = true;\n+  }\n+\n+  // Call this to mark the thread as finished.\n+  public native void finish ();\n+}"}, {"sha": "b26c95dba9447163b6cce614d95282d0c26aa7a7", "filename": "libjava/gnu/gcj/jni/natNativeThread.cc", "status": "added", "additions": 24, "deletions": 0, "changes": 24, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fgnu%2Fgcj%2Fjni%2FnatNativeThread.cc?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -0,0 +1,24 @@\n+// natNativeThread.cc - Native side of attached threads.\n+\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n+\n+   This file is part of libgcj.\n+\n+This software is copyrighted work licensed under the terms of the\n+Libgcj License.  Please consult the file \"LIBGCJ_LICENSE\" for\n+details.  */\n+\n+// Written by Tom Tromey <tromey@cygnus.com>\n+\n+#include <config.h>\n+\n+#include <gcj/cni.h>\n+#include <jvm.h>\n+#include <gnu/gcj/jni/NativeThread.h>\n+#include <java/lang/Thread.h>\n+\n+void\n+gnu::gcj::jni::NativeThread::finish ()\n+{\n+  finish_ ();\n+}"}, {"sha": "35477797f40bc366bb74826a5a6384bf8565aab6", "filename": "libjava/include/jni.h", "status": "modified", "additions": 98, "deletions": 3, "changes": 101, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Finclude%2Fjni.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Finclude%2Fjni.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjni.h?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -23,6 +23,7 @@ details.  */\n #include <gcj/javaprims.h>\n \n typedef struct _Jv_JNIEnv JNIEnv;\n+typedef struct _Jv_JavaVM JavaVM;\n \n #define JNI_TRUE true\n #define JNI_FALSE false\n@@ -59,6 +60,7 @@ typedef void *jfieldID;\n typedef void *jmethodID;\n \n typedef const struct JNINativeInterface *JNIEnv;\n+typedef const struct JNIInvokeInterface *JavaVM;\n \n #define JNI_TRUE 1\n #define JNI_TRUE 0\n@@ -76,6 +78,32 @@ typedef jobject jweak;\n #define JNI_COMMIT 1\n #define JNI_ABORT  2\n \n+/* Error codes */\n+#define JNI_OK            0\n+#define JNI_ERR          -1\n+#define JNI_EDETACHED    -2\n+#define JNI_EVERSION     -3\n+\n+#ifdef __cplusplus\n+extern \"C\"\n+{\n+#endif /* __cplusplus */\n+\n+/* These functions might be defined in libraries which we load; the\n+   JNI implementation calls them at the appropriate times.  */\n+extern jint JNI_OnLoad (JavaVM *, void *);\n+extern void JNI_OnUnload (JavaVM *, void *);\n+\n+/* These functions are called by user code to start using the\n+   invocation API.  */\n+extern jint JNI_GetDefaultJavaVMInitArgs (void *);\n+extern jint JNI_CreateJavaVM (JavaVM **, void **, void *);\n+extern jint JNI_GetCreatedJavaVMs(JavaVM **, jsize, jsize *);\n+\n+#ifdef __cplusplus\n+};\n+#endif /* __cplusplus */\n+\n typedef union jvalue\n {\n   jboolean z;\n@@ -99,9 +127,6 @@ typedef struct\n   void *fnPtr;\t\t\t/* Sigh.  */\n } JNINativeMethod;\n \n-/* FIXME: this is just a placeholder.  */\n-typedef int JavaVM;\n-\n struct JNINativeInterface\n {\n   _Jv_func reserved0;\n@@ -1402,4 +1427,74 @@ class _Jv_JNIEnv\n };\n #endif /* __cplusplus */\n \n+/*\n+ * Invocation API.\n+ */\n+\n+struct JNIInvokeInterface\n+{\n+  _Jv_func reserved0;\n+  _Jv_func reserved1;\n+  _Jv_func reserved2;\n+\n+  jint (*DestroyJavaVM)         (JavaVM *);\n+  jint (*AttachCurrentThread)   (JavaVM *, void **, void *);\n+  jint (*DetachCurrentThread)   (JavaVM *);\n+  jint (*GetEnv)                (JavaVM *, void **, jint);\n+};\n+\n+#ifdef __cplusplus\n+\n+class _Jv_JavaVM\n+{\n+public:\n+  const struct JNIInvokeInterface *functions;\n+\n+private:\n+  /* FIXME: other fields.  */\n+\n+public:\n+  jint DestroyJavaVM ()\n+  { return functions->DestroyJavaVM (this); }\n+\n+  jint AttachCurrentThread (void **penv, void *args)\n+  { return functions->AttachCurrentThread (this, penv, args); }\n+\n+  jint DetachCurrentThread ()\n+  { return functions->DetachCurrentThread (this); }\n+\n+  jint GetEnv (void **penv, jint version)\n+  { return functions->GetEnv (this, penv, version); }\n+};\n+#endif /* __cplusplus */\n+\n+typedef struct JavaVMAttachArgs\n+{\n+  jint version;\t\t\t/* Must be JNI_VERSION_1_2.  */\n+  char *name;\t\t\t/* The name of the thread (or NULL).  */\n+  jobject group;\t\t/* Global ref of a ThreadGroup object\n+\t\t\t\t   (or NULL).  */\n+} JavaVMAttachArgs;\n+\n+typedef struct JavaVMOption\n+{\n+  char *optionString;\n+  void *extraInfo;\n+} JavaVMOption;\n+\n+typedef struct JavaVMInitArgs\n+{\n+  /* Must be JNI_VERSION_1_2.  */\n+  jint version;\n+\n+  /* Number of options.  */\n+  jint nOptions;\n+\n+  /* Options to the VM.  */\n+  JavaVMOption *options;\n+\n+  /* Whether we should ignore unrecognized options.  */\n+  jboolean ignoreUnrecognized;\n+} JavaVMInitArgs;\n+\n #endif /* __GCJ_JNI_H__ */"}, {"sha": "d21da78923a3e5d61996e55ceb828440bbb71c7f", "filename": "libjava/include/jvm.h", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Finclude%2Fjvm.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Finclude%2Fjvm.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Finclude%2Fjvm.h?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -207,4 +207,8 @@ void *_Jv_FindSymbolInExecutable (const char *);\n /* Initialize JNI.  */\n extern void _Jv_JNI_Init (void);\n \n+/* Get or set the per-thread JNIEnv used by the invocation API.  */\n+_Jv_JNIEnv *_Jv_GetCurrentJNIEnv ();\n+void _Jv_SetCurrentJNIEnv (_Jv_JNIEnv *);\n+\n #endif /* __JAVA_JVM_H__ */"}, {"sha": "7dbabcf56c51252f9fb12030a5c91f349e8e1f22", "filename": "libjava/java/lang/Thread.java", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjava%2Flang%2FThread.java", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjava%2Flang%2FThread.java", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FThread.java?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -1,6 +1,6 @@\n // Thread.java - Thread class.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -10,6 +10,8 @@\n \n package java.lang;\n \n+import gnu.gcj.RawData;\n+\n /**\n  * @author Tom Tromey <tromey@cygnus.com>\n  * @date August 24, 1998 \n@@ -297,11 +299,8 @@ public String toString ()\n   private boolean interrupt_flag;\n   private boolean alive_flag;\n \n-  // This is a bit odd.  We need a way to represent some data that is\n-  // manipulated only by the native side of this class.  We represent\n-  // it as a Java object reference.  However, it is not actually a\n-  // Java object.\n-  private Object data;\n+  // Our native data.\n+  private RawData data;\n \n   // Next thread number to assign.\n   private static int nextThreadNumber = 0;"}, {"sha": "741f2b587e8ec3adfadce801c88e804ff3f744ca", "filename": "libjava/java/lang/natThread.cc", "status": "modified", "additions": 28, "deletions": 2, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjava%2Flang%2FnatThread.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjava%2Flang%2FnatThread.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjava%2Flang%2FnatThread.cc?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -1,6 +1,6 @@\n // natThread.cc - Native part of Thread class.\n \n-/* Copyright (C) 1998, 1999  Red Hat, Inc.\n+/* Copyright (C) 1998, 1999, 2000  Red Hat, Inc.\n \n    This file is part of libgcj.\n \n@@ -23,6 +23,9 @@ details.  */\n #include <java/lang/IllegalThreadStateException.h>\n #include <java/lang/InterruptedException.h>\n #include <java/lang/NullPointerException.h>\n+#include <gnu/gcj/RawData.h>\n+\n+#include <jni.h>\n \n \f\n \n@@ -40,6 +43,9 @@ struct natThread\n   // This is private data for the thread system layer.\n   _Jv_Thread_t *thread;\n \n+  // Each thread has its own JNI object.\n+  JNIEnv *jni_env;\n+\n   // All threads waiting to join this thread are linked together and\n   // waiting on their respective `interrupt' condition variables.\n   // When this thread exits, it notifies each such thread by\n@@ -83,10 +89,13 @@ java::lang::Thread::initialize_native (void)\n   // own finalizer then we will need to reinitialize this structure at\n   // any \"interesting\" point.\n   natThread *nt = (natThread *) _Jv_AllocBytes (sizeof (natThread));\n-  data = (jobject) nt;\n+  data = reinterpret_cast<gnu::gcj::RawData *> (nt);\n   _Jv_MutexInit (&nt->interrupt_mutex);\n   _Jv_CondInit (&nt->interrupt_cond);\n   _Jv_ThreadInitData (&nt->thread, this);\n+  // FIXME: if JNI_ENV is set we will want to free it.  It is\n+  // malloc()d.\n+  nt->jni_env = NULL;\n   nt->joiner = 0;\n   nt->next = 0;\n }\n@@ -324,3 +333,20 @@ java::lang::Thread::yield (void)\n {\n   _Jv_ThreadYield ();\n }\n+\n+JNIEnv *\n+_Jv_GetCurrentJNIEnv ()\n+{\n+  java::lang::Thread *t = _Jv_ThreadCurrent ();\n+  if (t == NULL)\n+    return NULL;\n+  return ((natThread *) t->data)->jni_env;\n+}\n+\n+void\n+_Jv_SetCurrentJNIEnv (JNIEnv *env)\n+{\n+  java::lang::Thread *t = _Jv_ThreadCurrent ();\n+  JvAssert (t != NULL);\n+  ((natThread *) t->data)->jni_env = env;\n+}"}, {"sha": "6beb6f7f8a49474dd9d8af132fa56b2c854fdfa9", "filename": "libjava/jni.cc", "status": "modified", "additions": 256, "deletions": 3, "changes": 259, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjni.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/aaf0766e9f897b2fbce053083d85cb739cb509d2/libjava%2Fjni.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libjava%2Fjni.cc?ref=aaf0766e9f897b2fbce053083d85cb739cb509d2", "patch": "@@ -36,6 +36,7 @@ details.  */\n #include <java/lang/OutOfMemoryError.h>\n #include <java/util/Hashtable.h>\n #include <java/lang/Integer.h>\n+#include <gnu/gcj/jni/NativeThread.h>\n \n #include <gcj/method.h>\n #include <gcj/field.h>\n@@ -51,6 +52,10 @@ extern java::lang::Class ObjectClass;\n extern java::lang::Class ThrowableClass;\n #define MethodClass _CL_Q44java4lang7reflect6Method\n extern java::lang::Class MethodClass;\n+#define ThreadGroupClass _CL_Q34java4lang11ThreadGroup\n+extern java::lang::Class ThreadGroupClass;\n+#define NativeThreadClass _CL_Q43gnu3gcj3jni12NativeThread\n+extern java::lang::Class ThreadGroupClass;\n \n // This enum is used to select different template instantiations in\n // the invocation code.\n@@ -62,8 +67,9 @@ enum invocation_type\n   constructor\n };\n \n-// Forward declaration.\n+// Forward declarations.\n extern struct JNINativeInterface _Jv_JNIFunctions;\n+extern struct JNIInvokeInterface _Jv_JNI_InvokeFunctions;\n \n // Number of slots in the default frame.  The VM must allow at least\n // 16.\n@@ -89,6 +95,9 @@ struct _Jv_JNI_LocalFrame\n // This holds a reference count for all local and global references.\n static java::util::Hashtable *ref_table;\n \n+// The only VM.\n+static JavaVM *the_vm;\n+\n \f\n \n void\n@@ -178,7 +187,7 @@ _Jv_JNI_EnsureLocalCapacity (JNIEnv *env, jint size)\n     {\n       // FIXME: exception processing.\n       env->ex = new java::lang::OutOfMemoryError;\n-      return -1;\n+      return JNI_ERR;\n     }\n \n   frame->marker = true;\n@@ -1380,6 +1389,238 @@ _Jv_JNIMethod::call (ffi_cif *cif, void *ret, ffi_raw *args, void *__this)\n \n \f\n \n+//\n+// Invocation API.\n+//\n+\n+// An internal helper function.\n+static jint\n+_Jv_JNI_AttachCurrentThread (JavaVM *, jstring name, void **penv, void *args)\n+{\n+  JavaVMAttachArgs *attach = reinterpret_cast<JavaVMAttachArgs *> (args);\n+  java::lang::ThreadGroup *group = NULL;\n+\n+  if (attach)\n+    {\n+      // FIXME: do we really want to support 1.1?\n+      if (attach->version != JNI_VERSION_1_2\n+\t  && attach->version != JNI_VERSION_1_1)\n+\treturn JNI_EVERSION;\n+\n+      JvAssert ((&ThreadGroupClass)->isInstance (attach->group));\n+      group = reinterpret_cast<java::lang::ThreadGroup *> (attach->group);\n+    }\n+\n+  // Attaching an already-attached thread is a no-op.\n+  if (_Jv_ThreadCurrent () != NULL)\n+    return 0;\n+\n+  // FIXME: NULL return?\n+  JNIEnv *env = (JNIEnv *) _Jv_MallocUnchecked (sizeof (JNIEnv));\n+  env->p = &_Jv_JNIFunctions;\n+  env->ex = NULL;\n+  env->klass = NULL;\n+  // FIXME: NULL return?\n+  env->locals\n+    = (_Jv_JNI_LocalFrame *) _Jv_MallocUnchecked (sizeof (_Jv_JNI_LocalFrame)\n+\t\t\t\t\t\t  + (FRAME_SIZE\n+\t\t\t\t\t\t     * sizeof (jobject)));\n+  *penv = reinterpret_cast<void *> (env);\n+\n+  java::lang::Thread *t = new gnu::gcj::jni::NativeThread (group, name);\n+  t = t;\t\t\t// Avoid compiler warning.  Eww.\n+  _Jv_SetCurrentJNIEnv (env);\n+\n+  return 0;\n+}\n+\n+// This is the one actually used by JNI.\n+static jint\n+_Jv_JNI_AttachCurrentThread (JavaVM *vm, void **penv, void *args)\n+{\n+  return _Jv_JNI_AttachCurrentThread (vm, NULL, penv, args);\n+}\n+\n+static jint\n+_Jv_JNI_DestroyJavaVM (JavaVM *vm)\n+{\n+  JvAssert (the_vm && vm == the_vm);\n+\n+  JNIEnv *env;\n+  if (_Jv_ThreadCurrent () != NULL)\n+    {\n+      jint r = _Jv_JNI_AttachCurrentThread (vm,\n+\t\t\t\t\t    JvNewStringLatin1 (\"main\"),\n+\t\t\t\t\t    reinterpret_cast<void **> (&env),\n+\t\t\t\t\t    NULL);\n+      if (r < 0)\n+\treturn r;\n+    }\n+  else\n+    env = _Jv_GetCurrentJNIEnv ();\n+\n+  _Jv_ThreadWait ();\n+\n+  // Docs say that this always returns an error code.\n+  return JNI_ERR;\n+}\n+\n+static jint\n+_Jv_JNI_DetachCurrentThread (JavaVM *)\n+{\n+  java::lang::Thread *t = _Jv_ThreadCurrent ();\n+  if (t == NULL)\n+    return JNI_EDETACHED;\n+\n+  // FIXME: we only allow threads attached via AttachCurrentThread to\n+  // be detached.  I have no idea how we could implement detaching\n+  // other threads, given the requirement that we must release all the\n+  // monitors.  That just seems evil.\n+  JvAssert ((&NativeThreadClass)->isInstance (t));\n+\n+  // FIXME: release the monitors.  We'll take this to mean all\n+  // monitors acquired via the JNI interface.  This means we have to\n+  // keep track of them.\n+\n+  gnu::gcj::jni::NativeThread *nt\n+    = reinterpret_cast<gnu::gcj::jni::NativeThread *> (t);\n+  nt->finish ();\n+\n+  return 0;\n+}\n+\n+static jint\n+_Jv_JNI_GetEnv (JavaVM *, void **penv, jint version)\n+{\n+  if (_Jv_ThreadCurrent () == NULL)\n+    {\n+      *penv = NULL;\n+      return JNI_EDETACHED;\n+    }\n+\n+  // FIXME: do we really want to support 1.1?\n+  if (version != JNI_VERSION_1_2 && version != JNI_VERSION_1_1)\n+    {\n+      *penv = NULL;\n+      return JNI_EVERSION;\n+    }\n+\n+  *penv = (void *) _Jv_GetCurrentJNIEnv ();\n+  return 0;\n+}\n+\n+jint\n+JNI_GetDefaultJavaVMInitArgs (void *args)\n+{\n+  jint version = * (jint *) args;\n+  // Here we only support 1.2.\n+  if (version != JNI_VERSION_1_2)\n+    return JNI_EVERSION;\n+\n+  JavaVMInitArgs *ia = reinterpret_cast<JavaVMInitArgs *> (args);\n+  ia->version = JNI_VERSION_1_2;\n+  ia->nOptions = 0;\n+  ia->options = NULL;\n+  ia->ignoreUnrecognized = true;\n+\n+  return 0;\n+}\n+\n+jint\n+JNI_CreateJavaVM (JavaVM **vm, void **penv, void *args)\n+{\n+  JvAssert (! the_vm);\n+  // FIXME: synchronize\n+  JavaVM *nvm = (JavaVM *) _Jv_MallocUnchecked (sizeof (JavaVM));\n+  if (nvm == NULL)\n+    return JNI_ERR;\n+  nvm->functions = &_Jv_JNI_InvokeFunctions;\n+\n+  // Parse the arguments.\n+  if (args != NULL)\n+    {\n+      jint version = * (jint *) args;\n+      // We only support 1.2.\n+      if (version != JNI_VERSION_1_2)\n+\treturn JNI_EVERSION;\n+      JavaVMInitArgs *ia = reinterpret_cast<JavaVMInitArgs *> (args);\n+      for (int i = 0; i < ia->nOptions; ++i)\n+\t{\n+\t  if (! strcmp (ia->options[i].optionString, \"vfprintf\")\n+\t      || ! strcmp (ia->options[i].optionString, \"exit\")\n+\t      || ! strcmp (ia->options[i].optionString, \"abort\"))\n+\t    {\n+\t      // We are required to recognize these, but for now we\n+\t      // don't handle them in any way.  FIXME.\n+\t      continue;\n+\t    }\n+\t  else if (! strncmp (ia->options[i].optionString,\n+\t\t\t      \"-verbose\", sizeof (\"-verbose\") - 1))\n+\t    {\n+\t      // We don't do anything with this option either.  We\n+\t      // might want to make sure the argument is valid, but we\n+\t      // don't really care all that much for now.\n+\t      continue;\n+\t    }\n+\t  else if (! strncmp (ia->options[i].optionString, \"-D\", 2))\n+\t    {\n+\t      // FIXME.\n+\t      continue;\n+\t    }\n+\t  else if (ia->ignoreUnrecognized)\n+\t    {\n+\t      if (ia->options[i].optionString[0] == '_'\n+\t\t  || ! strncmp (ia->options[i].optionString, \"-X\", 2))\n+\t\tcontinue;\n+\t    }\n+\n+\t  return JNI_ERR;\n+\t}\n+    }\n+\n+  jint r =_Jv_JNI_AttachCurrentThread (nvm, penv, NULL);\n+  if (r < 0)\n+    return r;\n+\n+  the_vm = nvm;\n+  *vm = the_vm;\n+  return 0;\n+}\n+\n+jint\n+JNI_GetCreatedJavaVMs (JavaVM **vm_buffer, jsize buf_len, jsize *n_vms)\n+{\n+  JvAssert (buf_len > 0);\n+  // We only support a single VM.\n+  if (the_vm != NULL)\n+    {\n+      vm_buffer[0] = the_vm;\n+      *n_vms = 1;\n+    }\n+  else\n+    *n_vms = 0;\n+  return 0;\n+}\n+\n+jint\n+_Jv_JNI_GetJavaVM (JNIEnv *, JavaVM **vm)\n+{\n+  // FIXME: synchronize\n+  if (! the_vm)\n+    {\n+      JavaVM *nvm = (JavaVM *) _Jv_MallocUnchecked (sizeof (JavaVM));\n+      if (nvm == NULL)\n+\treturn JNI_ERR;\n+      nvm->functions = &_Jv_JNI_InvokeFunctions;\n+      the_vm = nvm;\n+    }\n+\n+  *vm = the_vm;\n+  return 0;\n+}\n+\n+\f\n+\n #define NOT_IMPL NULL\n #define RESERVED NULL\n \n@@ -1614,7 +1855,7 @@ struct JNINativeInterface _Jv_JNIFunctions =\n   NOT_IMPL /* UnregisterNatives */,\n   _Jv_JNI_MonitorEnter,\n   _Jv_JNI_MonitorExit,\n-  NOT_IMPL /* GetJavaVM */,\n+  _Jv_JNI_GetJavaVM,\n \n   _Jv_JNI_GetStringRegion,\n   _Jv_JNI_GetStringUTFRegion,\n@@ -1628,3 +1869,15 @@ struct JNINativeInterface _Jv_JNIFunctions =\n \n   _Jv_JNI_ExceptionCheck\n };\n+\n+struct JNIInvokeInterface _Jv_JNI_InvokeFunctions =\n+{\n+  RESERVED,\n+  RESERVED,\n+  RESERVED,\n+\n+  _Jv_JNI_DestroyJavaVM,\n+  _Jv_JNI_AttachCurrentThread,\n+  _Jv_JNI_DetachCurrentThread,\n+  _Jv_JNI_GetEnv\n+};"}]}