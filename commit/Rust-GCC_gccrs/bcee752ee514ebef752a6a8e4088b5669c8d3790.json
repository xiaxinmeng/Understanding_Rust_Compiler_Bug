{"sha": "bcee752ee514ebef752a6a8e4088b5669c8d3790", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmNlZTc1MmVlNTE0ZWJlZjc1MmE2YThlNDA4OGI1NjY5YzhkMzc5MA==", "commit": {"author": {"name": "Richard Guenther", "email": "rguenther@suse.de", "date": "2010-07-10T08:39:46Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2010-07-10T08:39:46Z"}, "message": "re PR lto/44889 (Bogus \"type of \u2018nsLayoutModule_NSModule\u2019 does not match original declaration\" waning compiling Mozilla)\n\n2010-07-10  Richard Guenther  <rguenther@suse.de>\n\n\tPR lto/44889\n\t* gimple.c (gimple_fixup_complete_and_incomplete_subtype_p): New\n\thelper function.\n\t(gimple_types_compatible_p): Similar to pointed-to\n\ttypes allow and merge a mix of complete and incomplete aggregate.\n\tUse gimple_fixup_complete_and_incomplete_subtype_p for that.\n\t(iterative_hash_gimple_type): Adjust for that.\n\n\t* gcc.dg/lto/20100709-1_0.c: New testcase.\n\t* gcc.dg/lto/20100709-1_1.c: Likewise.\n\nFrom-SVN: r162032", "tree": {"sha": "f95de652429f2b6544137000cfc168804f88e923", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/f95de652429f2b6544137000cfc168804f88e923"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/bcee752ee514ebef752a6a8e4088b5669c8d3790", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcee752ee514ebef752a6a8e4088b5669c8d3790", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bcee752ee514ebef752a6a8e4088b5669c8d3790", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bcee752ee514ebef752a6a8e4088b5669c8d3790/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "7e9b96974abe5a74beaab2f90d3b47bb52f97db1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7e9b96974abe5a74beaab2f90d3b47bb52f97db1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7e9b96974abe5a74beaab2f90d3b47bb52f97db1"}], "stats": {"total": 166, "additions": 118, "deletions": 48}, "files": [{"sha": "09f71c948327721af7a0fdbcaa8de76003c5a7c9", "filename": "gcc/ChangeLog", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=bcee752ee514ebef752a6a8e4088b5669c8d3790", "patch": "@@ -1,3 +1,13 @@\n+2010-07-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44889\n+\t* gimple.c (gimple_fixup_complete_and_incomplete_subtype_p): New\n+\thelper function.\n+\t(gimple_types_compatible_p): Similar to pointed-to\n+\ttypes allow and merge a mix of complete and incomplete aggregate.\n+\tUse gimple_fixup_complete_and_incomplete_subtype_p for that.\n+\t(iterative_hash_gimple_type): Adjust for that.\n+\n 2010-07-10  Richard Sandiford  <r.sandiford@uk.ibm.com>\n \n \t* tree.h (DECL_REPLACEABLE_P): Strengthen check for weak symbols."}, {"sha": "5606da8a539c6b3427a3bf459a2c947a555f9d45", "filename": "gcc/gimple.c", "status": "modified", "additions": 84, "deletions": 48, "changes": 132, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Fgimple.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Fgimple.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgimple.c?ref=bcee752ee514ebef752a6a8e4088b5669c8d3790", "patch": "@@ -3343,6 +3343,45 @@ gimple_queue_type_fixup (tree context, tree *incomplete, tree complete)\n   VEC_safe_push (type_fixup, heap, gimple_register_type_fixups, &f);\n }\n \n+/* If the type *T1P and the type *T2P are a complete and an incomplete\n+   variant of the same type return true and queue a fixup for the\n+   incomplete one and its CONTEXT.  Return false otherwise.  */\n+\n+static bool\n+gimple_fixup_complete_and_incomplete_subtype_p (tree context1, tree *t1p,\n+\t\t\t\t\t\ttree context2, tree *t2p)\n+{\n+  tree t1 = *t1p;\n+  tree t2 = *t2p;\n+\n+  /* If one pointer points to an incomplete type variant of\n+     the other pointed-to type they are the same.  */\n+  if (TREE_CODE (t1) == TREE_CODE (t2)\n+      && RECORD_OR_UNION_TYPE_P (t1)\n+      && (!COMPLETE_TYPE_P (t1)\n+\t  || !COMPLETE_TYPE_P (t2))\n+      && TYPE_QUALS (t1) == TYPE_QUALS (t2)\n+      && compare_type_names_p (TYPE_MAIN_VARIANT (t1),\n+\t\t\t       TYPE_MAIN_VARIANT (t2), true))\n+    {\n+      /* Replace the pointed-to incomplete type with the complete one.\n+\t ???  This simple name-based merging causes at least some\n+\t of the ICEs in canonicalizing FIELD_DECLs during stmt\n+\t read.  For example in GCC we have two different struct deps\n+\t and we mismatch the use in struct cpp_reader in sched-int.h\n+\t vs. mkdeps.c.  Of course the whole exercise is for TBAA\n+\t with structs which contain pointers to incomplete types\n+\t in one unit and to complete ones in another.  So we\n+\t probably should merge these types only with more context.  */\n+      if (COMPLETE_TYPE_P (t2))\n+\tgimple_queue_type_fixup (context1, t1p, t2);\n+      else\n+\tgimple_queue_type_fixup (context2, t2p, t1);\n+      return true;\n+    }\n+  return false;\n+}\n+\n /* Return 1 iff T1 and T2 are structurally identical.\n    Otherwise, return 0.  */\n \n@@ -3507,33 +3546,35 @@ gimple_types_compatible_p (tree t1, tree t2)\n     case FUNCTION_TYPE:\n       /* Function types are the same if the return type and arguments types\n \t are the same.  */\n-      if (!gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+      if (!gimple_fixup_complete_and_incomplete_subtype_p\n+\t     (t1, &TREE_TYPE (t1), t2, &TREE_TYPE (t2))\n+\t  && !gimple_types_compatible_p (TREE_TYPE (t1), TREE_TYPE (t2)))\n+\tgoto different_types;\n+\n+      if (!targetm.comp_type_attributes (t1, t2))\n \tgoto different_types;\n+\n+      if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n+\tgoto same_types;\n       else\n \t{\n-\t  if (!targetm.comp_type_attributes (t1, t2))\n-\t    goto different_types;\n+\t  tree parms1, parms2;\n \n-\t  if (TYPE_ARG_TYPES (t1) == TYPE_ARG_TYPES (t2))\n-\t    goto same_types;\n-\t  else\n+\t  for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n+\t       parms1 && parms2;\n+\t       parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n \t    {\n-\t      tree parms1, parms2;\n-\n-\t      for (parms1 = TYPE_ARG_TYPES (t1), parms2 = TYPE_ARG_TYPES (t2);\n-\t\t   parms1 && parms2;\n-\t\t   parms1 = TREE_CHAIN (parms1), parms2 = TREE_CHAIN (parms2))\n-\t\t{\n-\t\t  if (!gimple_types_compatible_p (TREE_VALUE (parms1),\n-\t\t\t\t\t     TREE_VALUE (parms2)))\n-\t\t    goto different_types;\n-\t\t}\n-\n-\t      if (parms1 || parms2)\n+\t      if (!gimple_fixup_complete_and_incomplete_subtype_p\n+\t\t    (t1, &TREE_VALUE (parms1), t2, &TREE_VALUE (parms2))\n+\t\t  && !gimple_types_compatible_p (TREE_VALUE (parms1),\n+\t\t\t\t\t\t TREE_VALUE (parms2)))\n \t\tgoto different_types;\n-\n-\t      goto same_types;\n \t    }\n+\n+\t  if (parms1 || parms2)\n+\t    goto different_types;\n+\n+\t  goto same_types;\n \t}\n \n     case OFFSET_TYPE:\n@@ -3556,30 +3597,9 @@ gimple_types_compatible_p (tree t1, tree t2)\n \n \t/* If one pointer points to an incomplete type variant of\n \t   the other pointed-to type they are the same.  */\n-\tif (TREE_CODE (TREE_TYPE (t1)) == TREE_CODE (TREE_TYPE (t2))\n-\t    && RECORD_OR_UNION_TYPE_P (TREE_TYPE (t1))\n-\t    && (!COMPLETE_TYPE_P (TREE_TYPE (t1))\n-\t\t|| !COMPLETE_TYPE_P (TREE_TYPE (t2)))\n-\t    && TYPE_QUALS (TREE_TYPE (t1)) == TYPE_QUALS (TREE_TYPE (t2))\n-\t    && compare_type_names_p (TYPE_MAIN_VARIANT (TREE_TYPE (t1)),\n-\t\t\t\t     TYPE_MAIN_VARIANT (TREE_TYPE (t2)), true))\n-\t  {\n-\t    /* Replace the pointed-to incomplete type with the\n-\t       complete one.\n-\t       ???  This simple name-based merging causes at least some\n-\t       of the ICEs in canonicalizing FIELD_DECLs during stmt\n-\t       read.  For example in GCC we have two different struct deps\n-\t       and we mismatch the use in struct cpp_reader in sched-int.h\n-\t       vs. mkdeps.c.  Of course the whole exercise is for TBAA\n-\t       with structs which contain pointers to incomplete types\n-\t       in one unit and to complete ones in another.  So we\n-\t       probably should merge these types only with more context.  */\n-\t    if (COMPLETE_TYPE_P (TREE_TYPE (t2)))\n-\t      gimple_queue_type_fixup (t1, &TREE_TYPE (t1), TREE_TYPE (t2));\n-\t    else\n-\t      gimple_queue_type_fixup (t2, &TREE_TYPE (t2), TREE_TYPE (t1));\n-\t    goto same_types;\n-\t  }\n+\tif (gimple_fixup_complete_and_incomplete_subtype_p\n+\t      (t1, &TREE_TYPE (t1), t2, &TREE_TYPE (t2)))\n+\t  goto same_types;\n \n \t/* Otherwise, pointer and reference types are the same if the\n \t   pointed-to types are the same.  */\n@@ -3900,13 +3920,29 @@ iterative_hash_gimple_type (tree type, hashval_t val,\n \tv = visit (TYPE_METHOD_BASETYPE (type), state, v,\n \t\t   sccstack, sccstate, sccstate_obstack);\n \n-      v = visit (TREE_TYPE (type), state, v,\n-\t\t sccstack, sccstate, sccstate_obstack);\n+      /* For result types allow mismatch in completeness.  */\n+      if (RECORD_OR_UNION_TYPE_P (TREE_TYPE (type)))\n+\t{\n+\t  v = iterative_hash_hashval_t (TREE_CODE (TREE_TYPE (type)), v);\n+\t  v = iterative_hash_name\n+\t      (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_TYPE (type))), v);\n+\t}\n+      else\n+\tv = visit (TREE_TYPE (type), state, v,\n+\t\t   sccstack, sccstate, sccstate_obstack);\n \n       for (p = TYPE_ARG_TYPES (type), na = 0; p; p = TREE_CHAIN (p))\n \t{\n-\t  v = visit (TREE_VALUE (p), state, v,\n-\t\t     sccstack, sccstate, sccstate_obstack);\n+\t  /* For argument types allow mismatch in completeness.  */\n+\t  if (RECORD_OR_UNION_TYPE_P (TREE_VALUE (p)))\n+\t    {\n+\t      v = iterative_hash_hashval_t (TREE_CODE (TREE_VALUE (p)), v);\n+\t      v = iterative_hash_name\n+\t\t  (TYPE_NAME (TYPE_MAIN_VARIANT (TREE_VALUE (p))), v);\n+\t    }\n+\t  else\n+\t    v = visit (TREE_VALUE (p), state, v,\n+\t\t       sccstack, sccstate, sccstate_obstack);\n \t  na++;\n \t}\n "}, {"sha": "3579537c3795db82e79c2df86ebb422068983c94", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=bcee752ee514ebef752a6a8e4088b5669c8d3790", "patch": "@@ -1,3 +1,9 @@\n+2010-07-10  Richard Guenther  <rguenther@suse.de>\n+\n+\tPR lto/44889\n+\t* gcc.dg/lto/20100709-1_0.c: New testcase.\n+\t* gcc.dg/lto/20100709-1_1.c: Likewise.\n+\n 2010-07-10  Richard Sandiford  <r.sandiford@uk.ibm.com>\n \n \t* gcc.dg/attr-weak-hidden-1.c, gcc.dg/attr-weak-hidden-1a.c: New test."}, {"sha": "33f38f6c204de47fa28da503a81ecf0d30fd80e3", "filename": "gcc/testsuite/gcc.dg/lto/20100709-1_0.c", "status": "added", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_0.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_0.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_0.c?ref=bcee752ee514ebef752a6a8e4088b5669c8d3790", "patch": "@@ -0,0 +1,7 @@\n+/* { dg-lto-do link } */\n+\n+struct X;\n+struct Y {\n+    struct X (*fnptr)(struct X);\n+};\n+struct Y foo;"}, {"sha": "b970795c61db287649aecd6e32b272cfab7737a9", "filename": "gcc/testsuite/gcc.dg/lto/20100709-1_1.c", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/bcee752ee514ebef752a6a8e4088b5669c8d3790/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Flto%2F20100709-1_1.c?ref=bcee752ee514ebef752a6a8e4088b5669c8d3790", "patch": "@@ -0,0 +1,11 @@\n+struct X { int i; };\n+struct Y {\n+    struct X (*fnptr)(struct X);\n+};\n+extern struct Y foo;\n+int main()\n+{\n+  struct X x;\n+  foo.fnptr(x);\n+  return 0;\n+}"}]}