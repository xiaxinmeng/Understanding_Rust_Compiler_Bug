{"sha": "617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NjE3Njk1Y2RjMmIzZDk1MGYxZTRkZWI1ZWE4NWQ1Y2MzMDI5NDNmNA==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-31T07:56:40Z"}, "committer": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2020-10-31T07:56:40Z"}, "message": "Handle fnspec in local ipa-modref\n\n\t* ipa-modref.c (modref_summary::dump): Dump writes_errno.\n\t(parm_map_for_arg): Break out from ...\n\t(merge_call_side_effects): ... here.\n\t(get_access_for_fnspec): New function.\n\t(process_fnspec): New function.\n\t(analyze_call): Use it.\n\t(analyze_stmt): Update.\n\t(analyze_function): Initialize writes_errno.\n\t(modref_summaries::duplicate): Duplicate writes_errno.\n\t* ipa-modref.h (struct modref_summary): Add writes_errno.\n\t* tree-ssa-alias.c (call_may_clobber_ref_p_1): Check errno.", "tree": {"sha": "fe6fdf0e7adbdd1c1aaaac10cbcea3331f083182", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fe6fdf0e7adbdd1c1aaaac10cbcea3331f083182"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/comments", "author": null, "committer": null, "parents": [{"sha": "943cc2a1b70f2d755b4fed97b1c4b49234d92899", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/943cc2a1b70f2d755b4fed97b1c4b49234d92899", "html_url": "https://github.com/Rust-GCC/gccrs/commit/943cc2a1b70f2d755b4fed97b1c4b49234d92899"}], "stats": {"total": 243, "additions": 185, "deletions": 58}, "files": [{"sha": "007cebaa3a2f1d349ea259274dce7042f6b6490b", "filename": "gcc/ipa-modref.c", "status": "modified", "additions": 181, "deletions": 57, "changes": 238, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Fipa-modref.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Fipa-modref.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.c?ref=617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "patch": "@@ -59,6 +59,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"value-range.h\"\n #include \"ipa-prop.h\"\n #include \"ipa-fnsummary.h\"\n+#include \"attr-fnspec.h\"\n \n /* Class (from which there is one global instance) that holds modref summaries\n    for all analyzed functions.  */\n@@ -318,6 +319,8 @@ modref_summary::dump (FILE *out)\n   dump_records (loads, out);\n   fprintf (out, \"  stores:\\n\");\n   dump_records (stores, out);\n+  if (writes_errno)\n+    fprintf (out, \"  Writes errno\\n\");\n }\n \n /* Dump summary.  */\n@@ -511,6 +514,43 @@ ignore_stores_p (tree caller, int flags)\n   return false;\n }\n \n+/* Determine parm_map for argument I of STMT.  */\n+\n+modref_parm_map\n+parm_map_for_arg (gimple *stmt, int i)\n+{\n+  tree op = gimple_call_arg (stmt, i);\n+  bool offset_known;\n+  poly_int64 offset;\n+  struct modref_parm_map parm_map;\n+\n+  offset_known = unadjusted_ptr_and_unit_offset (op, &op, &offset);\n+  if (TREE_CODE (op) == SSA_NAME\n+      && SSA_NAME_IS_DEFAULT_DEF (op)\n+      && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n+    {\n+      int index = 0;\n+      for (tree t = DECL_ARGUMENTS (current_function_decl);\n+\t   t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n+\t{\n+\t  if (!t)\n+\t    {\n+\t      index = -1;\n+\t      break;\n+\t    }\n+\t  index++;\n+\t}\n+      parm_map.parm_index = index;\n+      parm_map.parm_offset_known = offset_known;\n+      parm_map.parm_offset = offset;\n+    }\n+  else if (points_to_local_or_readonly_memory_p (op))\n+    parm_map.parm_index = -2;\n+  else\n+    parm_map.parm_index = -1;\n+  return parm_map;\n+}\n+\n /* Merge side effects of call STMT to function with CALLEE_SUMMARY\n    int CUR_SUMMARY.  Return true if something changed.\n    If IGNORE_STORES is true, do not merge stores.  */\n@@ -527,37 +567,21 @@ merge_call_side_effects (modref_summary *cur_summary,\n     fprintf (dump_file, \" - Merging side effects of %s with parm map:\",\n \t     callee_node->dump_name ());\n \n+  /* We can not safely optimize based on summary of callee if it does\n+     not always bind to current def: it is possible that memory load\n+     was optimized out earlier which may not happen in the interposed\n+     variant.  */\n+  if (!callee_node->binds_to_current_def_p ())\n+    {\n+      if (dump_file)\n+\tfprintf (dump_file, \" - May be interposed: collapsing loads.\\n\");\n+      cur_summary->loads->collapse ();\n+    }\n+\n   parm_map.safe_grow_cleared (gimple_call_num_args (stmt));\n   for (unsigned i = 0; i < gimple_call_num_args (stmt); i++)\n     {\n-      tree op = gimple_call_arg (stmt, i);\n-      bool offset_known;\n-      poly_int64 offset;\n-\n-      offset_known = unadjusted_ptr_and_unit_offset (op, &op, &offset);\n-      if (TREE_CODE (op) == SSA_NAME\n-\t  && SSA_NAME_IS_DEFAULT_DEF (op)\n-\t  && TREE_CODE (SSA_NAME_VAR (op)) == PARM_DECL)\n-\t{\n-\t  int index = 0;\n-\t  for (tree t = DECL_ARGUMENTS (current_function_decl);\n-\t       t != SSA_NAME_VAR (op); t = DECL_CHAIN (t))\n-\t    {\n-\t      if (!t)\n-\t\t{\n-\t\t  index = -1;\n-\t\t  break;\n-\t\t}\n-\t      index++;\n-\t    }\n-\t  parm_map[i].parm_index = index;\n-\t  parm_map[i].parm_offset_known = offset_known;\n-\t  parm_map[i].parm_offset = offset;\n-\t}\n-      else if (points_to_local_or_readonly_memory_p (op))\n-\tparm_map[i].parm_index = -2;\n-      else\n-\tparm_map[i].parm_index = -1;\n+      parm_map[i] = parm_map_for_arg (stmt, i);\n       if (dump_file)\n \t{\n \t  fprintf (dump_file, \" %i\", parm_map[i].parm_index);\n@@ -575,17 +599,138 @@ merge_call_side_effects (modref_summary *cur_summary,\n   /* Merge with callee's summary.  */\n   changed |= cur_summary->loads->merge (callee_summary->loads, &parm_map);\n   if (!ignore_stores)\n-    changed |= cur_summary->stores->merge (callee_summary->stores,\n-\t\t\t\t\t   &parm_map);\n+    {\n+      changed |= cur_summary->stores->merge (callee_summary->stores,\n+\t\t\t\t\t     &parm_map);\n+      if (!cur_summary->writes_errno\n+\t  && callee_summary->writes_errno)\n+\t{\n+\t  cur_summary->writes_errno = true;\n+\t  changed = true;\n+\t}\n+    }\n   return changed;\n }\n \n+/* Return access mode for argument I of call STMT with FNSPEC.  */\n+\n+static modref_access_node\n+get_access_for_fnspec (gcall *call, attr_fnspec &fnspec,\n+\t\t       unsigned int i, modref_parm_map &map)\n+{\n+  tree size = NULL_TREE;\n+  unsigned int size_arg;\n+\n+  if (!fnspec.arg_specified_p (i))\n+    ;\n+  else if (fnspec.arg_max_access_size_given_by_arg_p (i, &size_arg))\n+    size = gimple_call_arg (call, size_arg);\n+  else if (fnspec.arg_access_size_given_by_type_p (i))\n+    {\n+      tree callee = gimple_call_fndecl (call);\n+      tree t = TYPE_ARG_TYPES (TREE_TYPE (callee));\n+\n+      for (unsigned int p = 0; p < i; p++)\n+\tt = TREE_CHAIN (t);\n+      size = TYPE_SIZE_UNIT (TREE_TYPE (TREE_VALUE (t)));\n+    }\n+  modref_access_node a = {0, -1, -1,\n+\t\t\t  map.parm_offset, map.parm_index,\n+\t\t\t  map.parm_offset_known};\n+  poly_int64 size_hwi;\n+  if (size\n+      && poly_int_tree_p (size, &size_hwi)\n+      && coeffs_in_range_p (size_hwi, 0,\n+\t\t\t    HOST_WIDE_INT_MAX / BITS_PER_UNIT))\n+    {\n+      a.size = -1;\n+      a.max_size = size_hwi << LOG2_BITS_PER_UNIT;\n+    }\n+  return a;\n+}\n+\n+/* Apply side effects of call STMT to CUR_SUMMARY using FNSPEC.\n+   If IGNORE_STORES is true ignore them.\n+   Return false if no useful summary can be produced.   */\n+\n+static bool\n+process_fnspec (modref_summary *cur_summary, gcall *call, bool ignore_stores)\n+{\n+  attr_fnspec fnspec = gimple_call_fnspec (call);\n+  if (!fnspec.known_p ())\n+    {\n+      if (dump_file && gimple_call_builtin_p (call, BUILT_IN_NORMAL))\n+\tfprintf (dump_file, \"      Builtin with no fnspec: %s\\n\",\n+\t\t IDENTIFIER_POINTER (DECL_NAME (gimple_call_fndecl (call))));\n+      if (ignore_stores)\n+\t{\n+\t  cur_summary->loads->collapse ();\n+\t  return true;\n+\t}\n+      return false;\n+    }\n+  if (fnspec.global_memory_read_p ())\n+    cur_summary->loads->collapse ();\n+  else\n+    {\n+      for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n+\tif (!POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (call, i))))\n+\t  ;\n+\telse if (!fnspec.arg_specified_p (i)\n+\t\t || fnspec.arg_maybe_read_p (i))\n+\t  {\n+\t    modref_parm_map map = parm_map_for_arg (call, i);\n+\n+\t    if (map.parm_index == -2)\n+\t      continue;\n+\t    if (map.parm_index == -1)\n+\t      {\n+\t\tcur_summary->loads->collapse ();\n+\t\tbreak;\n+\t      }\n+\t    cur_summary->loads->insert (0, 0,\n+\t\t\t\t\tget_access_for_fnspec (call,\n+\t\t\t\t\t\t\t       fnspec, i, map));\n+\t  }\n+    }\n+  if (ignore_stores)\n+    return true;\n+  if (fnspec.global_memory_written_p ())\n+    cur_summary->stores->collapse ();\n+  else\n+    {\n+      for (unsigned int i = 0; i < gimple_call_num_args (call); i++)\n+\tif (!POINTER_TYPE_P (TREE_TYPE (gimple_call_arg (call, i))))\n+\t  ;\n+\telse if (!fnspec.arg_specified_p (i)\n+\t\t || fnspec.arg_maybe_written_p (i))\n+\t  {\n+\t    modref_parm_map map = parm_map_for_arg (call, i);\n+\n+\t    if (map.parm_index == -2)\n+\t      continue;\n+\t    if (map.parm_index == -1)\n+\t      {\n+\t\tcur_summary->stores->collapse ();\n+\t\tbreak;\n+\t      }\n+\t    cur_summary->stores->insert (0, 0,\n+\t\t\t\t\t get_access_for_fnspec (call,\n+\t\t\t\t\t\t\t\tfnspec, i,\n+\t\t\t\t\t\t\t\tmap));\n+\t  }\n+      if (fnspec.errno_maybe_written_p () && flag_errno_math)\n+\tcur_summary->writes_errno = true;\n+    }\n+  return true;\n+}\n+\n /* Analyze function call STMT in function F.\n    Remember recursive calls in RECURSIVE_CALLS.  */\n \n static bool\n analyze_call (modref_summary *cur_summary,\n-\t      gimple *stmt, vec <gimple *> *recursive_calls)\n+\t      gcall *stmt, vec <gimple *> *recursive_calls)\n {\n   /* Check flags on the function call.  In certain cases, analysis can be\n      simplified.  */\n@@ -628,17 +773,6 @@ analyze_call (modref_summary *cur_summary,\n \n   struct cgraph_node *callee_node = cgraph_node::get_create (callee);\n \n-  /* We can not safely optimize based on summary of callee if it does\n-     not always bind to current def: it is possible that memory load\n-     was optimized out earlier which may not happen in the interposed\n-     variant.  */\n-  if (!callee_node->binds_to_current_def_p ())\n-    {\n-      if (dump_file)\n-\tfprintf (dump_file, \" - May be interposed: collapsing loads.\\n\");\n-      cur_summary->loads->collapse ();\n-    }\n-\n   /* If this is a recursive call, the target summary is the same as ours, so\n      there's nothing to do.  */\n   if (recursive_call_p (current_function_decl, callee))\n@@ -656,31 +790,19 @@ analyze_call (modref_summary *cur_summary,\n   callee_node = callee_node->function_symbol (&avail);\n   if (avail <= AVAIL_INTERPOSABLE)\n     {\n-      /* Keep stores summary, but discard all loads for interposable function\n-\t symbols.  */\n-      if (ignore_stores)\n-\t{\n-\t  cur_summary->loads->collapse ();\n-\t  return true;\n-\t}\n       if (dump_file)\n \tfprintf (dump_file, \" - Function availability <= AVAIL_INTERPOSABLE.\\n\");\n-      return false;\n+      return process_fnspec (cur_summary, stmt, ignore_stores);\n     }\n \n   /* Get callee's modref summary.  As above, if there's no summary, we either\n      have to give up or, if stores are ignored, we can just purge loads.  */\n   modref_summary *callee_summary = optimization_summaries->get (callee_node);\n   if (!callee_summary)\n     {\n-      if (ignore_stores)\n-\t{\n-\t  cur_summary->loads->collapse ();\n-\t  return true;\n-\t}\n       if (dump_file)\n \tfprintf (dump_file, \" - No modref summary available for callee.\\n\");\n-      return false;\n+      return process_fnspec (cur_summary, stmt, ignore_stores);\n     }\n \n   merge_call_side_effects (cur_summary, stmt, callee_summary, ignore_stores,\n@@ -786,7 +908,7 @@ analyze_stmt (modref_summary *summary, modref_summary_lto *summary_lto,\n      return false;\n    case GIMPLE_CALL:\n      if (!ipa)\n-       return analyze_call (summary, stmt, recursive_calls);\n+       return analyze_call (summary, as_a <gcall *> (stmt), recursive_calls);\n      return true;\n    default:\n      /* Nothing to do for other types of statements.  */\n@@ -905,6 +1027,7 @@ analyze_function (function *f, bool ipa)\n       summary->stores = modref_records::create_ggc (param_modref_max_bases,\n \t\t\t\t\t\t    param_modref_max_refs,\n \t\t\t\t\t\t    param_modref_max_accesses);\n+      summary->writes_errno = false;\n     }\n   if (lto)\n     {\n@@ -1071,6 +1194,7 @@ modref_summaries::duplicate (cgraph_node *, cgraph_node *dst,\n \t\t\t src_data->loads->max_refs,\n \t\t\t src_data->loads->max_accesses);\n   dst_data->loads->copy_from (src_data->loads);\n+  dst_data->writes_errno = src_data->writes_errno;\n }\n \n /* Called when new clone is inserted to callgraph late.  */"}, {"sha": "31ceffa8d34b0aec0615f8dc040b935b365d8369", "filename": "gcc/ipa-modref.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Fipa-modref.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Fipa-modref.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fipa-modref.h?ref=617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "patch": "@@ -34,6 +34,7 @@ struct GTY(()) modref_summary\n   ~modref_summary ();\n   void dump (FILE *);\n   bool useful_p (int ecf_flags);\n+  bool writes_errno;\n };\n \n modref_summary *get_modref_function_summary (cgraph_node *func);"}, {"sha": "e64011d04dfbc1e82b7cac7f0df6ff2e9a972886", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/617695cdc2b3d950f1e4deb5ea85d5cc302943f4/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=617695cdc2b3d950f1e4deb5ea85d5cc302943f4", "patch": "@@ -2925,7 +2925,9 @@ call_may_clobber_ref_p_1 (gcall *call, ao_ref *ref, bool tbaa_p)\n \t  modref_summary *summary = get_modref_function_summary (node);\n \t  if (summary)\n \t    {\n-\t      if (!modref_may_conflict (call, summary->stores, ref, tbaa_p))\n+\t      if (!modref_may_conflict (call, summary->stores, ref, tbaa_p)\n+\t\t  && (!summary->writes_errno\n+\t\t      || !targetm.ref_may_alias_errno (ref)))\n \t\t{\n \t\t  alias_stats.modref_clobber_no_alias++;\n \t\t  if (dump_file && (dump_flags & TDF_DETAILS))"}]}