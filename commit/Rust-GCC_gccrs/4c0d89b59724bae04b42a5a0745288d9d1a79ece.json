{"sha": "4c0d89b59724bae04b42a5a0745288d9d1a79ece", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGMwZDg5YjU5NzI0YmFlMDRiNDJhNWEwNzQ1Mjg4ZDlkMWE3OWVjZQ==", "commit": {"author": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-14T20:32:25Z"}, "committer": {"name": "Richard Stallman", "email": "rms@gnu.org", "date": "1992-02-14T20:32:25Z"}, "message": "*** empty log message ***\n\nFrom-SVN: r322", "tree": {"sha": "a0bf854d1422f5696cd057803f4f8a0b162cacf2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a0bf854d1422f5696cd057803f4f8a0b162cacf2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4c0d89b59724bae04b42a5a0745288d9d1a79ece", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0d89b59724bae04b42a5a0745288d9d1a79ece", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4c0d89b59724bae04b42a5a0745288d9d1a79ece", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4c0d89b59724bae04b42a5a0745288d9d1a79ece/comments", "author": null, "committer": null, "parents": [{"sha": "2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2d20b9dffe71110b0d8f3889857b0ae27a2f0ec4"}], "stats": {"total": 37, "additions": 30, "deletions": 7}, "files": [{"sha": "cd81f69990123dc8c0967fa901546b51a4988012", "filename": "gcc/config/i386/i386.c", "status": "modified", "additions": 30, "deletions": 7, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4c0d89b59724bae04b42a5a0745288d9d1a79ece/gcc%2Fconfig%2Fi386%2Fi386.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4c0d89b59724bae04b42a5a0745288d9d1a79ece/gcc%2Fconfig%2Fi386%2Fi386.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.c?ref=4c0d89b59724bae04b42a5a0745288d9d1a79ece", "patch": "@@ -42,6 +42,22 @@ char *output_move_const_single ();\n static char *hi_reg_name[] = HI_REGISTER_NAMES;\n static char *qi_reg_name[] = QI_REGISTER_NAMES;\n static char *qi_high_reg_name[] = QI_HIGH_REGISTER_NAMES;\n+\n+/* Array of the smallest class containing reg number REGNO, indexed by\n+   REGNO.  Used by REGNO_REG_CLASS in i386.h. */\n+\n+enum reg_class regclass_map[FIRST_PSEUDO_REGISTER] =\n+{\n+  /* ax, dx, cx, bx */\n+  AREG, DREG, CREG, Q_REGS,\n+  /* si, di, bp, sp */\n+  SIREG, DIREG, INDEX_REGS, GENERAL_REGS,\n+  /* FP registers */\n+  FP_TOP_REG, FP_SECOND_REG, FLOAT_REGS, FLOAT_REGS,\n+  FLOAT_REGS, FLOAT_REGS, FLOAT_REGS, FLOAT_REGS,       \n+  /* arg pointer */\n+  INDEX_REGS\n+};\n \f\n /* Output an insn whose source is a 386 integer register.  SRC is the\n    rtx for the register, and TEMPLATE is the op-code template.  SRC may\n@@ -1227,11 +1243,14 @@ print_operand_address (file, addr)\n    On the 80386, we assume that only test and compare insns, as well\n    as SI, HI, & DI mode ADD, SUB, NEG, AND, IOR, XOR, ASHIFT, LSHIFT,\n    ASHIFTRT, and LSHIFTRT instructions set the condition codes usefully.\n-   Also, we assume that jumps and moves don't affect the condition codes.\n-   All else, clobbers the condition codes, by assumption.\n+   Also, we assume that jumps, moves and sCOND don't affect the condition\n+   codes.  All else clobbers the condition codes, by assumption.\n+\n+   We assume that ALL integer add, minus, etc. instructions effect the\n+   condition codes.  This MUST be consistent with i386.md.\n \n-   We assume that ALL add, minus, etc. instructions effect the condition\n-   codes.  This MUST be consistent with i386.md.  */\n+   We don't record any float test or compare - the redundant test &\n+   compare check in final.c does not handle stack-like regs correctly. */\n \n void\n notice_update_cc (exp)\n@@ -1247,7 +1266,8 @@ notice_update_cc (exp)\n \t the RTX's which we remember the cc's came from.\n \t (Note that moving a constant 0 or 1 MAY set the cc's).  */\n       if (REG_P (SET_DEST (exp))\n-\t  && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM))\n+\t  && (REG_P (SET_SRC (exp)) || GET_CODE (SET_SRC (exp)) == MEM\n+\t      || GET_RTX_CLASS (GET_CODE (SET_SRC (exp))) == '<'))\n \t{\n \t  if (cc_status.value1\n \t      && reg_overlap_mentioned_p (SET_DEST (exp), cc_status.value1))\n@@ -1259,7 +1279,9 @@ notice_update_cc (exp)\n \t}\n       /* Moving register into memory doesn't alter the cc's.\n \t It may invalidate the RTX's which we remember the cc's came from.  */\n-      if (GET_CODE (SET_DEST (exp)) == MEM && REG_P (SET_SRC (exp)))\n+      if (GET_CODE (SET_DEST (exp)) == MEM\n+\t  && (REG_P (SET_SRC (exp))\n+\t      || GET_RTX_CLASS (GET_CODE (SET_SRC (exp))) == '<'))\n \t{\n \t  if (cc_status.value1 && GET_CODE (cc_status.value1) == MEM)\n \t    cc_status.value1 = 0;\n@@ -1321,7 +1343,8 @@ notice_update_cc (exp)\n       if (SET_DEST (XVECEXP (exp, 0, 0)) == cc0_rtx)\n \t{\n \t  CC_STATUS_INIT;\n-\t  cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n+\t  if (! stack_regs_mentioned_p (SET_SRC (XVECEXP (exp, 0, 0))))\n+\t    cc_status.value1 = SET_SRC (XVECEXP (exp, 0, 0));\n \t  return;\n \t}\n       CC_STATUS_INIT;"}]}