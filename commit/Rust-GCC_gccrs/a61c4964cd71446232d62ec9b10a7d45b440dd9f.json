{"sha": "a61c4964cd71446232d62ec9b10a7d45b440dd9f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTYxYzQ5NjRjZDcxNDQ2MjMyZDYyZWM5YjEwYTdkNDViNDQwZGQ5Zg==", "commit": {"author": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-04-21T08:58:29Z"}, "committer": {"name": "Tobias Burnus", "email": "tobias@codesourcery.com", "date": "2021-04-21T08:59:18Z"}, "message": "Fortran/OpenMP: Add 'omp depobj' and 'depend(mutexinoutset:'\n\ngcc/fortran/ChangeLog:\n\n\t* dump-parse-tree.c (show_omp_namelist): Handle depobj + mutexinoutset\n\tin the depend clause.\n\t(show_omp_clauses, show_omp_node, show_code_node): Handle depobj.\n\t* gfortran.h (enum gfc_statement): Add ST_OMP_DEPOBJ.\n\t(enum gfc_omp_depend_op): Add OMP_DEPEND_UNSET,\n\tOMP_DEPEND_MUTEXINOUTSET and OMP_DEPEND_DEPOBJ.\n\t(gfc_omp_clauses): Add destroy, depobj_update and depobj.\n\t(enum gfc_exec_op): Add EXEC_OMP_DEPOBJ\n\t* match.h (gfc_match_omp_depobj): Match 'omp depobj'.\n\t* openmp.c (gfc_match_omp_clauses): Add depobj + mutexinoutset\n\tto depend clause.\n\t(gfc_match_omp_depobj, resolve_omp_clauses, gfc_resolve_omp_directive):\n\tHandle 'omp depobj'.\n\t* parse.c (decode_omp_directive, next_statement, gfc_ascii_statement):\n\tLikewise.\n\t* resolve.c (gfc_resolve_code): Likewise.\n\t* st.c (gfc_free_statement): Likewise.\n\t* trans-openmp.c (gfc_trans_omp_clauses): Handle depobj + mutexinoutset\n\tin the depend clause.\n\t(gfc_trans_omp_depobj, gfc_trans_omp_directive): Handle EXEC_OMP_DEPOBJ.\n\t* trans.c (trans_code): Likewise.\n\nlibgomp/ChangeLog:\n\n\t* testsuite/libgomp.fortran/depobj-1.f90: New test.\n\ngcc/testsuite/ChangeLog:\n\n\t* gfortran.dg/gomp/depobj-1.f90: New test.\n\t* gfortran.dg/gomp/depobj-2.f90: New test.", "tree": {"sha": "5bcf5747a5f62464f217feff8a4a5fb3fd3799b3", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5bcf5747a5f62464f217feff8a4a5fb3fd3799b3"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a61c4964cd71446232d62ec9b10a7d45b440dd9f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c4964cd71446232d62ec9b10a7d45b440dd9f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a61c4964cd71446232d62ec9b10a7d45b440dd9f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a61c4964cd71446232d62ec9b10a7d45b440dd9f/comments", "author": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "committer": {"login": "tob2", "id": 264461, "node_id": "MDQ6VXNlcjI2NDQ2MQ==", "avatar_url": "https://avatars.githubusercontent.com/u/264461?v=4", "gravatar_id": "", "url": "https://api.github.com/users/tob2", "html_url": "https://github.com/tob2", "followers_url": "https://api.github.com/users/tob2/followers", "following_url": "https://api.github.com/users/tob2/following{/other_user}", "gists_url": "https://api.github.com/users/tob2/gists{/gist_id}", "starred_url": "https://api.github.com/users/tob2/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/tob2/subscriptions", "organizations_url": "https://api.github.com/users/tob2/orgs", "repos_url": "https://api.github.com/users/tob2/repos", "events_url": "https://api.github.com/users/tob2/events{/privacy}", "received_events_url": "https://api.github.com/users/tob2/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "b4e17490c917746dc523cd1b4441000b66530695", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b4e17490c917746dc523cd1b4441000b66530695", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b4e17490c917746dc523cd1b4441000b66530695"}], "stats": {"total": 407, "additions": 402, "deletions": 5}, "files": [{"sha": "b50265ac742d85845b6d15691886677e16531117", "filename": "gcc/fortran/dump-parse-tree.c", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fdump-parse-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fdump-parse-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdump-parse-tree.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -1332,6 +1332,10 @@ show_omp_namelist (int list_type, gfc_omp_namelist *n)\n \t  case OMP_DEPEND_IN: fputs (\"in:\", dumpfile); break;\n \t  case OMP_DEPEND_OUT: fputs (\"out:\", dumpfile); break;\n \t  case OMP_DEPEND_INOUT: fputs (\"inout:\", dumpfile); break;\n+\t  case OMP_DEPEND_DEPOBJ: fputs (\"depobj:\", dumpfile); break;\n+\t  case OMP_DEPEND_MUTEXINOUTSET:\n+\t    fputs (\"mutexinoutset:\", dumpfile);\n+\t    break;\n \t  case OMP_DEPEND_SINK_FIRST:\n \t    fputs (\"sink:\", dumpfile);\n \t    while (1)\n@@ -1754,10 +1758,27 @@ show_omp_clauses (gfc_omp_clauses *omp_clauses)\n       show_expr (omp_clauses->if_exprs[i]);\n       fputc (')', dumpfile);\n     }\n+  if (omp_clauses->destroy)\n+    fputs (\" DESTROY\", dumpfile);\n   if (omp_clauses->depend_source)\n     fputs (\" DEPEND(source)\", dumpfile);\n   if (omp_clauses->capture)\n     fputs (\" CAPTURE\", dumpfile);\n+  if (omp_clauses->depobj_update != OMP_DEPEND_UNSET)\n+    {\n+      const char *deptype;\n+      fputs (\" UPDATE(\", dumpfile);\n+      switch (omp_clauses->depobj_update)\n+\t{\n+\tcase OMP_DEPEND_IN: deptype = \"IN\"; break;\n+\tcase OMP_DEPEND_OUT: deptype = \"OUT\"; break;\n+\tcase OMP_DEPEND_INOUT: deptype = \"INOUT\"; break;\n+\tcase OMP_DEPEND_MUTEXINOUTSET: deptype = \"MUTEXINOUTSET\"; break;\n+\tdefault: gcc_unreachable ();\n+\t}\n+      fputs (deptype, dumpfile);\n+      fputc (')', dumpfile);\n+    }\n   if (omp_clauses->atomic_op != GFC_OMP_ATOMIC_UNSET)\n     {\n       const char *atomic_op;\n@@ -1831,6 +1852,7 @@ show_omp_node (int level, gfc_code *c)\n     case EXEC_OMP_FLUSH: name = \"FLUSH\"; break;\n     case EXEC_OMP_MASTER: name = \"MASTER\"; break;\n     case EXEC_OMP_ORDERED: name = \"ORDERED\"; break;\n+    case EXEC_OMP_DEPOBJ: name = \"DEPOBJ\"; break;\n     case EXEC_OMP_PARALLEL: name = \"PARALLEL\"; break;\n     case EXEC_OMP_PARALLEL_DO: name = \"PARALLEL DO\"; break;\n     case EXEC_OMP_PARALLEL_DO_SIMD: name = \"PARALLEL DO SIMD\"; break;\n@@ -1941,6 +1963,15 @@ show_omp_node (int level, gfc_code *c)\n       if (omp_clauses)\n \tfprintf (dumpfile, \" (%s)\", c->ext.omp_clauses->critical_name);\n       break;\n+    case EXEC_OMP_DEPOBJ:\n+      omp_clauses = c->ext.omp_clauses;\n+      if (omp_clauses)\n+\t{\n+\t  fputc ('(', dumpfile);\n+\t  show_expr (c->ext.omp_clauses->depobj);\n+\t  fputc (')', dumpfile);\n+\t}\n+      break;\n     case EXEC_OMP_FLUSH:\n       if (c->ext.omp_namelist)\n \t{\n@@ -1969,6 +2000,7 @@ show_omp_node (int level, gfc_code *c)\n       || c->op == EXEC_OACC_ENTER_DATA || c->op == EXEC_OACC_EXIT_DATA\n       || c->op == EXEC_OMP_TARGET_UPDATE || c->op == EXEC_OMP_TARGET_ENTER_DATA\n       || c->op == EXEC_OMP_TARGET_EXIT_DATA || c->op == EXEC_OMP_SCAN\n+      || c->op == EXEC_OMP_DEPOBJ\n       || (c->op == EXEC_OMP_ORDERED && c->block == NULL))\n     return;\n   if (c->op == EXEC_OMP_SECTIONS || c->op == EXEC_OMP_PARALLEL_SECTIONS)\n@@ -3094,6 +3126,7 @@ show_code_node (int level, gfc_code *c)\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_BARRIER:\n     case EXEC_OMP_CRITICAL:\n+    case EXEC_OMP_DEPOBJ:\n     case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:"}, {"sha": "d12be0cdbab1d0bc399076503713d05714bf7e3b", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 8, "deletions": 4, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -261,7 +261,7 @@ enum gfc_statement\n   ST_OMP_TARGET_PARALLEL_DO_SIMD, ST_OMP_END_TARGET_PARALLEL_DO_SIMD,\n   ST_OMP_TARGET_ENTER_DATA, ST_OMP_TARGET_EXIT_DATA,\n   ST_OMP_TARGET_SIMD, ST_OMP_END_TARGET_SIMD,\n-  ST_OMP_TASKLOOP, ST_OMP_END_TASKLOOP, ST_OMP_SCAN,\n+  ST_OMP_TASKLOOP, ST_OMP_END_TASKLOOP, ST_OMP_SCAN, ST_OMP_DEPOBJ,\n   ST_OMP_TASKLOOP_SIMD, ST_OMP_END_TASKLOOP_SIMD, ST_OMP_ORDERED_DEPEND,\n   ST_OMP_REQUIRES, ST_PROCEDURE, ST_GENERIC, ST_CRITICAL, ST_END_CRITICAL,\n   ST_GET_FCN_CHARACTERISTICS, ST_LOCK, ST_UNLOCK, ST_EVENT_POST,\n@@ -1198,9 +1198,12 @@ enum gfc_omp_reduction_op\n \n enum gfc_omp_depend_op\n {\n+  OMP_DEPEND_UNSET,\n   OMP_DEPEND_IN,\n   OMP_DEPEND_OUT,\n   OMP_DEPEND_INOUT,\n+  OMP_DEPEND_MUTEXINOUTSET,\n+  OMP_DEPEND_DEPOBJ,\n   OMP_DEPEND_SINK_FIRST,\n   OMP_DEPEND_SINK\n };\n@@ -1402,11 +1405,12 @@ typedef struct gfc_omp_clauses\n   bool nowait, ordered, untied, mergeable;\n   bool inbranch, notinbranch, defaultmap, nogroup;\n   bool sched_simd, sched_monotonic, sched_nonmonotonic;\n-  bool simd, threads, depend_source, order_concurrent, capture;\n+  bool simd, threads, depend_source, destroy, order_concurrent, capture;\n   enum gfc_omp_atomic_op atomic_op;\n   enum gfc_omp_memorder memorder;\n   enum gfc_omp_cancel_kind cancel;\n   enum gfc_omp_proc_bind_kind proc_bind;\n+  enum gfc_omp_depend_op depobj_update;\n   struct gfc_expr *safelen_expr;\n   struct gfc_expr *simdlen_expr;\n   struct gfc_expr *num_teams;\n@@ -1417,6 +1421,7 @@ typedef struct gfc_omp_clauses\n   struct gfc_expr *num_tasks;\n   struct gfc_expr *priority;\n   struct gfc_expr *detach;\n+  struct gfc_expr *depobj;\n   struct gfc_expr *if_exprs[OMP_IF_LAST];\n   enum gfc_omp_sched_kind dist_sched_kind;\n   struct gfc_expr *dist_chunk_size;\n@@ -1437,7 +1442,6 @@ typedef struct gfc_omp_clauses\n   unsigned par_auto:1, gang_static:1;\n   unsigned if_present:1, finalize:1;\n   locus loc;\n-\n }\n gfc_omp_clauses;\n \n@@ -2700,7 +2704,7 @@ enum gfc_exec_op\n   EXEC_OMP_TARGET_ENTER_DATA, EXEC_OMP_TARGET_EXIT_DATA,\n   EXEC_OMP_TARGET_PARALLEL, EXEC_OMP_TARGET_PARALLEL_DO,\n   EXEC_OMP_TARGET_PARALLEL_DO_SIMD, EXEC_OMP_TARGET_SIMD,\n-  EXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD, EXEC_OMP_SCAN\n+  EXEC_OMP_TASKLOOP, EXEC_OMP_TASKLOOP_SIMD, EXEC_OMP_SCAN, EXEC_OMP_DEPOBJ\n };\n \n typedef struct gfc_code"}, {"sha": "b72ec67d6651010ac2fadb4d267a41f11179ec97", "filename": "gcc/fortran/match.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fmatch.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fmatch.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fmatch.h?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -160,6 +160,7 @@ match gfc_match_omp_critical (void);\n match gfc_match_omp_declare_reduction (void);\n match gfc_match_omp_declare_simd (void);\n match gfc_match_omp_declare_target (void);\n+match gfc_match_omp_depobj (void);\n match gfc_match_omp_distribute (void);\n match gfc_match_omp_distribute_parallel_do (void);\n match gfc_match_omp_distribute_parallel_do_simd (void);"}, {"sha": "a1b057227b766ec3ace2ef15b938854a2ee1ad7f", "filename": "gcc/fortran/openmp.c", "status": "modified", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fopenmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fopenmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fopenmp.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -1381,6 +1381,10 @@ gfc_match_omp_clauses (gfc_omp_clauses **cp, const omp_mask mask,\n \t\tdepend_op = OMP_DEPEND_IN;\n \t      else if (gfc_match (\"out\") == MATCH_YES)\n \t\tdepend_op = OMP_DEPEND_OUT;\n+\t      else if (gfc_match (\"mutexinoutset\") == MATCH_YES)\n+\t\tdepend_op = OMP_DEPEND_MUTEXINOUTSET;\n+\t      else if (gfc_match (\"depobj\") == MATCH_YES)\n+\t\tdepend_op = OMP_DEPEND_DEPOBJ;\n \t      else if (!c->depend_source\n \t\t       && gfc_match (\"source )\") == MATCH_YES)\n \t\t{\n@@ -2898,6 +2902,86 @@ gfc_match_omp_end_critical (void)\n   return MATCH_YES;\n }\n \n+/* depobj(depobj) depend(dep-type:loc)|destroy|update(dep-type)\n+   dep-type = in/out/inout/mutexinoutset/depobj/source/sink\n+   depend: !source, !sink\n+   update: !source, !sink, !depobj\n+   locator = exactly one list item  .*/\n+match\n+gfc_match_omp_depobj (void)\n+{\n+  gfc_omp_clauses *c = NULL;\n+  gfc_expr *depobj;\n+\n+  if (gfc_match (\" ( %v ) \", &depobj) != MATCH_YES)\n+    {\n+      gfc_error (\"Expected %<( depobj )%> at %C\");\n+      return MATCH_ERROR;\n+    }\n+  if (gfc_match (\"update ( \") == MATCH_YES)\n+    {\n+      c = gfc_get_omp_clauses ();\n+      if (gfc_match (\"inout )\") == MATCH_YES)\n+\tc->depobj_update = OMP_DEPEND_INOUT;\n+      else if (gfc_match (\"in )\") == MATCH_YES)\n+\tc->depobj_update = OMP_DEPEND_IN;\n+      else if (gfc_match (\"out )\") == MATCH_YES)\n+\tc->depobj_update = OMP_DEPEND_OUT;\n+      else if (gfc_match (\"mutexinoutset )\") == MATCH_YES)\n+\tc->depobj_update = OMP_DEPEND_MUTEXINOUTSET;\n+      else\n+\t{\n+\t  gfc_error (\"Expected IN, OUT, INOUT, MUTEXINOUTSET followed by \"\n+\t\t     \"%<)%> at %C\");\n+\t  goto error;\n+\t}\n+    }\n+  else if (gfc_match (\"destroy\") == MATCH_YES)\n+    {\n+      c = gfc_get_omp_clauses ();\n+      c->destroy = true;\n+    }\n+  else if (gfc_match_omp_clauses (&c, omp_mask (OMP_CLAUSE_DEPEND), true, false)\n+\t   != MATCH_YES)\n+    goto error;\n+\n+  if (c->depobj_update == OMP_DEPEND_UNSET && !c->destroy)\n+    {\n+      if (!c->depend_source && !c->lists[OMP_LIST_DEPEND])\n+\t{\n+\t  gfc_error (\"Expected DEPEND, UPDATE, or DESTROY clause at %C\");\n+\t  goto error;\n+\t}\n+      if (c->depend_source\n+\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_SINK_FIRST\n+\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_SINK\n+\t  || c->lists[OMP_LIST_DEPEND]->u.depend_op == OMP_DEPEND_DEPOBJ)\n+\t{\n+\t  gfc_error (\"DEPEND clause at %L of OMP DEPOBJ construct shall not \"\n+\t\t     \"have dependence-type SOURCE, SINK or DEPOBJ\",\n+\t\t     c->lists[OMP_LIST_DEPEND]\n+\t\t     ? &c->lists[OMP_LIST_DEPEND]->where : &gfc_current_locus);\n+\t  goto error;\n+\t}\n+      if (c->lists[OMP_LIST_DEPEND]->next)\n+\t{\n+\t  gfc_error (\"DEPEND clause at %L of OMP DEPOBJ construct shall have \"\n+\t\t     \"only a single locator\",\n+\t\t     &c->lists[OMP_LIST_DEPEND]->next->where);\n+\t  goto error;\n+\t}\n+    }\n+\n+  c->depobj = depobj;\n+  new_st.op = EXEC_OMP_DEPOBJ;\n+  new_st.ext.omp_clauses = c;\n+  return MATCH_YES;\n+\n+error:\n+  gfc_free_expr (depobj);\n+  gfc_free_omp_clauses (c);\n+  return MATCH_ERROR;\n+}\n \n match\n gfc_match_omp_distribute (void)\n@@ -4877,6 +4961,14 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t   \"clause at %L\", &code->loc);\n     }\n \n+  if (omp_clauses->depobj\n+      && (!gfc_resolve_expr (omp_clauses->depobj)\n+\t  || omp_clauses->depobj->ts.type != BT_INTEGER\n+\t  || omp_clauses->depobj->ts.kind != 2 * gfc_index_integer_kind\n+\t  || omp_clauses->depobj->rank != 0))\n+    gfc_error (\"DEPOBJ in DEPOBJ construct at %L shall be a scalar integer \"\n+\t       \"of OMP_DEPEND_KIND kind\", &omp_clauses->depobj->where);\n+\n   /* Check that no symbol appears on multiple clauses, except that\n      a symbol can appear on both firstprivate and lastprivate.  */\n   for (list = 0; list < OMP_LIST_NUM; list++)\n@@ -5173,6 +5265,26 @@ resolve_omp_clauses (gfc_code *code, gfc_omp_clauses *omp_clauses,\n \t\t      gfc_error (\"Only SOURCE or SINK dependence types \"\n \t\t\t\t \"are allowed on ORDERED directive at %L\",\n \t\t\t\t &n->where);\n+\t\t    else if (n->u.depend_op == OMP_DEPEND_DEPOBJ\n+\t\t\t     && !n->expr\n+\t\t\t     && (n->sym->ts.type != BT_INTEGER\n+\t\t\t\t || n->sym->ts.kind\n+\t\t\t\t    != 2 * gfc_index_integer_kind\n+\t\t\t\t || n->sym->attr.dimension))\n+\t\t      gfc_error (\"Locator %qs at %L in DEPEND clause of depobj \"\n+\t\t\t\t \"type shall be a scalar integer of \"\n+\t\t\t\t \"OMP_DEPEND_KIND kind\", n->sym->name,\n+\t\t\t\t &n->where);\n+\t\t    else if (n->u.depend_op == OMP_DEPEND_DEPOBJ\n+\t\t\t     && n->expr\n+\t\t\t     && (!gfc_resolve_expr (n->expr)\n+\t\t\t\t || n->expr->ts.type != BT_INTEGER\n+\t\t\t\t || n->expr->ts.kind\n+\t\t\t\t    != 2 * gfc_index_integer_kind\n+\t\t\t\t || n->expr->rank != 0))\n+\t\t      gfc_error (\"Locator at %L in DEPEND clause of depobj \"\n+\t\t\t\t \"type shall be a scalar integer of \"\n+\t\t\t\t \"OMP_DEPEND_KIND kind\", &n->expr->where);\n \t\t  }\n \t\tgfc_ref *lastref = NULL, *lastslice = NULL;\n \t\tbool resolved = false;\n@@ -7211,6 +7323,7 @@ gfc_resolve_omp_directive (gfc_code *code, gfc_namespace *ns)\n     case EXEC_OMP_TASK:\n     case EXEC_OMP_TEAMS:\n     case EXEC_OMP_WORKSHARE:\n+    case EXEC_OMP_DEPOBJ:\n       if (code->ext.omp_clauses)\n \tresolve_omp_clauses (code, code->ext.omp_clauses, NULL);\n       break;"}, {"sha": "9bbe9e83c8ef4cfb3c7f893271234db432b2ff0b", "filename": "gcc/fortran/parse.c", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fparse.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fparse.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fparse.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -895,6 +895,7 @@ decode_omp_directive (void)\n     case 'd':\n       matchds (\"declare reduction\", gfc_match_omp_declare_reduction,\n \t       ST_OMP_DECLARE_REDUCTION);\n+      matcho (\"depobj\", gfc_match_omp_depobj, ST_OMP_DEPOBJ);\n       matchs (\"distribute parallel do simd\",\n \t      gfc_match_omp_distribute_parallel_do_simd,\n \t      ST_OMP_DISTRIBUTE_PARALLEL_DO_SIMD);\n@@ -1588,7 +1589,7 @@ next_statement (void)\n   case ST_ASSIGNMENT: case ST_ARITHMETIC_IF: case ST_WHERE: case ST_FORALL: \\\n   case ST_LABEL_ASSIGNMENT: case ST_FLUSH: case ST_OMP_FLUSH: \\\n   case ST_OMP_BARRIER: case ST_OMP_TASKWAIT: case ST_OMP_TASKYIELD: \\\n-  case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: \\\n+  case ST_OMP_CANCEL: case ST_OMP_CANCELLATION_POINT: case ST_OMP_DEPOBJ: \\\n   case ST_OMP_TARGET_UPDATE: case ST_OMP_TARGET_ENTER_DATA: \\\n   case ST_OMP_TARGET_EXIT_DATA: case ST_OMP_ORDERED_DEPEND: \\\n   case ST_ERROR_STOP: case ST_OMP_SCAN: case ST_SYNC_ALL: \\\n@@ -2285,6 +2286,9 @@ gfc_ascii_statement (gfc_statement st)\n     case ST_OMP_DECLARE_TARGET:\n       p = \"!$OMP DECLARE TARGET\";\n       break;\n+    case ST_OMP_DEPOBJ:\n+      p = \"!$OMP DEPOBJ\";\n+      break;\n     case ST_OMP_DISTRIBUTE:\n       p = \"!$OMP DISTRIBUTE\";\n       break;"}, {"sha": "5a81387e277a49758a2b068207e5792ea171e25a", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -12198,6 +12198,7 @@ gfc_resolve_code (gfc_code *code, gfc_namespace *ns)\n \tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n \tcase EXEC_OMP_FLUSH:\n+\tcase EXEC_OMP_DEPOBJ:\n \tcase EXEC_OMP_DISTRIBUTE:\n \tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n \tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:"}, {"sha": "9e761996eeca26f42078cbd4e5e4df74dcc6a044", "filename": "gcc/fortran/st.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fst.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Fst.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fst.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -218,6 +218,7 @@ gfc_free_statement (gfc_code *p)\n     case EXEC_OMP_CANCEL:\n     case EXEC_OMP_CANCELLATION_POINT:\n     case EXEC_OMP_CRITICAL:\n+    case EXEC_OMP_DEPOBJ:\n     case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n     case EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:"}, {"sha": "bf3f2617776a218d9b4f53bf9f14073267f4938e", "filename": "gcc/fortran/trans-openmp.c", "status": "modified", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Ftrans-openmp.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Ftrans-openmp.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans-openmp.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -2545,6 +2545,9 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\t  tree decl = gfc_trans_omp_variable (n->sym, false);\n \t\t  if (gfc_omp_privatize_by_reference (decl))\n \t\t    decl = build_fold_indirect_ref (decl);\n+\t\t  if (n->u.depend_op == OMP_DEPEND_DEPOBJ\n+\t\t      && POINTER_TYPE_P (TREE_TYPE (decl)))\n+\t\t    decl = build_fold_indirect_ref (decl);\n \t\t  if (GFC_DESCRIPTOR_TYPE_P (TREE_TYPE (decl)))\n \t\t    {\n \t\t      decl = gfc_conv_descriptor_data_get (decl);\n@@ -2587,6 +2590,13 @@ gfc_trans_omp_clauses (stmtblock_t *block, gfc_omp_clauses *clauses,\n \t\tcase OMP_DEPEND_INOUT:\n \t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_INOUT;\n \t\t  break;\n+\t\tcase OMP_DEPEND_MUTEXINOUTSET:\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node)\n+\t\t    = OMP_CLAUSE_DEPEND_MUTEXINOUTSET;\n+\t\t  break;\n+\t\tcase OMP_DEPEND_DEPOBJ:\n+\t\t  OMP_CLAUSE_DEPEND_KIND (node) = OMP_CLAUSE_DEPEND_DEPOBJ;\n+\t\t  break;\n \t\tdefault:\n \t\t  gcc_unreachable ();\n \t\t}\n@@ -4912,6 +4922,62 @@ gfc_trans_oacc_combined_directive (gfc_code *code)\n   return gfc_finish_block (&block);\n }\n \n+static tree\n+gfc_trans_omp_depobj (gfc_code *code)\n+{\n+  stmtblock_t block;\n+  gfc_se se;\n+  gfc_init_se (&se, NULL);\n+  gfc_init_block (&block);\n+  gfc_conv_expr (&se, code->ext.omp_clauses->depobj);\n+  gcc_assert (se.pre.head == NULL && se.post.head == NULL);\n+  tree depobj = se.expr;\n+  location_t loc = EXPR_LOCATION (depobj);\n+  if (!POINTER_TYPE_P (TREE_TYPE (depobj)))\n+    depobj = gfc_build_addr_expr (NULL, depobj);\n+  depobj = fold_convert (build_pointer_type_for_mode (ptr_type_node,\n+\t\t\t\t\t\t      TYPE_MODE (ptr_type_node),\n+\t\t\t\t\t\t      true), depobj);\n+  gfc_omp_namelist *n = code->ext.omp_clauses->lists[OMP_LIST_DEPEND];\n+  if (n)\n+    {\n+      tree var;\n+      if (n->expr)\n+        var = gfc_convert_expr_to_tree (&block, n->expr);\n+      else\n+\tvar = gfc_get_symbol_decl (n->sym);\n+      if (!POINTER_TYPE_P (TREE_TYPE (var)))\n+        var = gfc_build_addr_expr (NULL, var);\n+      depobj = save_expr (depobj);\n+      tree r = build_fold_indirect_ref_loc (loc, depobj);\n+      gfc_add_expr_to_block (&block,\n+\t\t\t     build2 (MODIFY_EXPR, void_type_node, r, var));\n+    }\n+\n+  /* Only one may be set. */\n+  gcc_assert (((int)(n != NULL) + (int)(code->ext.omp_clauses->destroy)\n+\t      + (int)(code->ext.omp_clauses->depobj_update != OMP_DEPEND_UNSET))\n+\t      == 1);\n+  int k = -1; /* omp_clauses->destroy */\n+  if (!code->ext.omp_clauses->destroy)\n+    switch (code->ext.omp_clauses->depobj_update != OMP_DEPEND_UNSET\n+\t    ? code->ext.omp_clauses->depobj_update : n->u.depend_op)\n+      {\n+      case OMP_DEPEND_IN: k = GOMP_DEPEND_IN; break;\n+      case OMP_DEPEND_OUT: k = GOMP_DEPEND_IN; break;\n+      case OMP_DEPEND_INOUT: k = GOMP_DEPEND_IN; break;\n+      case OMP_DEPEND_MUTEXINOUTSET: k = GOMP_DEPEND_MUTEXINOUTSET; break;\n+      default: gcc_unreachable ();\n+      }\n+  tree t = build_int_cst (ptr_type_node, k);\n+  depobj = build2_loc (loc, POINTER_PLUS_EXPR, TREE_TYPE (depobj), depobj,\n+                       TYPE_SIZE_UNIT (ptr_type_node));\n+  depobj = build_fold_indirect_ref_loc (loc, depobj);\n+  gfc_add_expr_to_block (&block, build2 (MODIFY_EXPR, void_type_node, depobj, t));\n+\n+  return gfc_finish_block (&block);\n+}\n+\n static tree\n gfc_trans_omp_flush (gfc_code *code)\n {\n@@ -6181,6 +6247,8 @@ gfc_trans_omp_directive (gfc_code *code)\n       return gfc_trans_omp_cancellation_point (code);\n     case EXEC_OMP_CRITICAL:\n       return gfc_trans_omp_critical (code);\n+    case EXEC_OMP_DEPOBJ:\n+      return gfc_trans_omp_depobj (code);\n     case EXEC_OMP_DISTRIBUTE:\n     case EXEC_OMP_DO:\n     case EXEC_OMP_SIMD:"}, {"sha": "624c713253998a0d115410d6bc802bd173eabd4e", "filename": "gcc/fortran/trans.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Ftrans.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ffortran%2Ftrans.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Ftrans.c?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -2161,6 +2161,7 @@ trans_code (gfc_code * code, tree cond)\n \tcase EXEC_OMP_CANCEL:\n \tcase EXEC_OMP_CANCELLATION_POINT:\n \tcase EXEC_OMP_CRITICAL:\n+\tcase EXEC_OMP_DEPOBJ:\n \tcase EXEC_OMP_DISTRIBUTE:\n \tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO:\n \tcase EXEC_OMP_DISTRIBUTE_PARALLEL_DO_SIMD:"}, {"sha": "66cfb61060ffa0195f3096293c87ee9a0e0e954e", "filename": "gcc/testsuite/gfortran.dg/gomp/depobj-1.f90", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-1.f90?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -0,0 +1,25 @@\n+! { dg-do compile { target { fortran_integer_16 || ilp32 } } }\n+! omp_depend_kind = 2*intptr_t --> 16 (128 bit) on 64bit-pointer systems\n+!                              --> 8  (128 bit) on 32bit-pointer systems\n+subroutine f1\n+  !use omp_lib   ! N/A in gcc/testsuite\n+  use iso_c_binding, only: c_intptr_t\n+  implicit none\n+  integer, parameter :: omp_depend_kind = 2*c_intptr_t\n+  integer :: a\n+  integer(kind=omp_depend_kind) :: depobj1, depobj2, depobj3, depobj4, depobj5\n+  !$omp depobj(depobj1) depend (in : a)\n+  !$omp depobj(depobj2) depend (out : a)\n+  !$omp depobj(depobj3) depend( inout : a)\n+  !$omp depobj(depobj4) depend(mutexinoutset: a)\n+  !$omp depobj(depobj1) update(out)\n+  !$omp depobj(depobj2) update(mutexinoutset)\n+  !$omp depobj(depobj3) update(in)\n+  !$omp depobj(depobj4) update(inout)\n+  !$omp task depend (depobj: depobj1, depobj2, depobj3)\n+  !$omp end task\n+\n+  !$omp task depend(mutexinoutset: a)\n+  !$omp end task\n+  !$omp depobj(depobj2) destroy\n+end subroutine f1"}, {"sha": "3ffd3d5d01ba218bed177fc95f2969acaff2895f", "filename": "gcc/testsuite/gfortran.dg/gomp/depobj-2.f90", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Fgomp%2Fdepobj-2.f90?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -0,0 +1,33 @@\n+! { dg-do compile { target { fortran_integer_16 || ilp32 } } }\n+! omp_depend_kind = 2*intptr_t --> 16 (128 bit) on 64bit-pointer systems\n+!                              --> 8  (128 bit) on 32bit-pointer systems\n+subroutine f1\n+  !use omp_lib   ! N/A in gcc/testsuite\n+  use iso_c_binding, only: c_intptr_t\n+  implicit none\n+  integer, parameter :: omp_depend_kind = 2*c_intptr_t\n+  integer :: a, b\n+  integer(kind=omp_depend_kind) :: depobj, depobj1(5)\n+  real :: r\n+  integer(1) :: d\n+  \n+  !$omp depobj                                       ! { dg-error \"Expected '\\\\( depobj \\\\)\\'\" }\n+  !$omp depobj(depobj)                               ! { dg-error \"Expected DEPEND, UPDATE, or DESTROY clause\" }\n+  !$omp depobj destroy                               ! { dg-error \"Expected '\\\\( depobj \\\\)\\'\" }\n+  !$omp depobj ( depobj1 ( 1 ) ) depend( inout : a)  ! OK\n+  !$omp depobj(depobj1) depend( inout : a)           ! { dg-error \"DEPOBJ in DEPOBJ construct at .1. shall be a scalar integer of OMP_DEPEND_KIND kind\" }\n+  !$omp depobj(depobj1(:)) depend( inout : a)        ! { dg-error \"DEPOBJ in DEPOBJ construct at .1. shall be a scalar integer of OMP_DEPEND_KIND kind\" }\n+  !$omp depobj(r) depend( inout : a)                 ! { dg-error \"DEPOBJ in DEPOBJ construct at .1. shall be a scalar integer of OMP_DEPEND_KIND kind\" }\n+  !$omp depobj(d) depend( inout : a)                 ! { dg-error \"DEPOBJ in DEPOBJ construct at .1. shall be a scalar integer of OMP_DEPEND_KIND kind\" }\n+  !$omp depobj(depobj) depend( inout : a, b)         ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall have only a single locator\" }\n+  !$omp depobj(depobj) depend(mutexinoutset : a)     ! OK\n+  !$omp depobj(depobj) depend(source)                ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n+  !$omp depobj(depobj) depend(sink : i + 1)          ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n+  !$omp depobj(depobj) update(source)                ! { dg-error \"Expected IN, OUT, INOUT, MUTEXINOUTSET followed by '\\\\)'\" }\n+  !$omp depobj(depobj) update(sink)                  ! { dg-error \"Expected IN, OUT, INOUT, MUTEXINOUTSET followed by '\\\\)'\" }\n+  !$omp depobj(depobj) update(depobj)                ! { dg-error \"Expected IN, OUT, INOUT, MUTEXINOUTSET followed by '\\\\)'\" }\n+\n+  ! Valid in OpenMP 5.1:\n+  !$omp depobj(depobj5) depend(depobj: depobj3)      ! { dg-error \"DEPEND clause at .1. of OMP DEPOBJ construct shall not have dependence-type SOURCE, SINK or DEPOBJ\" }\n+end subroutine f1\n+"}, {"sha": "eb314f67baeb21d740e6e27b6dfef0df0789683c", "filename": "libgomp/testsuite/libgomp.fortran/depobj-1.f90", "status": "added", "additions": 113, "deletions": 0, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a61c4964cd71446232d62ec9b10a7d45b440dd9f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepobj-1.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a61c4964cd71446232d62ec9b10a7d45b440dd9f/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepobj-1.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgomp%2Ftestsuite%2Flibgomp.fortran%2Fdepobj-1.f90?ref=a61c4964cd71446232d62ec9b10a7d45b440dd9f", "patch": "@@ -0,0 +1,113 @@\n+module m\n+!  use omp_lib\n+  implicit none (type, external)\n+integer, parameter :: omp_depend_kind = 16\n+  integer :: xx\n+  integer(omp_depend_kind) :: dd1, dd2\n+contains\n+  subroutine dep\n+    integer :: x\n+    integer(omp_depend_kind) :: d1, d2\n+    x = 1\n+\n+    !$omp depobj (d1) depend(in: x)\n+    !$omp depobj (d2) depend(in: x)\n+    !$omp depobj (d2) update(out)\n+    !$omp parallel\n+      !$omp single\n+        !$omp task shared (x) depend(depobj: d2)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(depobj: d1)\n+          if (x /= 2) &\n+            stop 1\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+    !$omp depobj (d2) destroy\n+    !$omp depobj (d1) destroy\n+  end\n+\n+  subroutine dep2\n+    integer, pointer :: x\n+    integer(omp_depend_kind) :: d1, d2\n+    pointer :: d1\n+    allocate(d1, x)\n+    call dep2i(d1, d2, x)\n+    deallocate(d1)\n+  contains\n+   subroutine dep2i(d1, d2, x)\n+    integer(omp_depend_kind) :: d1\n+    integer(omp_depend_kind), optional :: d2\n+    integer, pointer, optional :: x\n+    pointer :: d1\n+    !$omp parallel\n+      !$omp single\n+        x = 1\n+        !$omp depobj (d1) depend(out: x)\n+        !$omp depobj (d2) depend (in:x)\n+        !$omp depobj(d2)update(in)\n+        !$omp task shared (x) depend(depobj:d1)\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(depobj : d2)\n+          if (x /= 2) &\n+            stop 2\n+        !$omp end task\n+        !$omp taskwait\n+        !$omp depobj(d1)destroy\n+        !$omp depobj(d2) destroy\n+     !$omp end single\n+   !$omp end parallel\n+  end\n+  end\n+\n+  subroutine dep3\n+    integer :: x\n+    integer(omp_depend_kind) :: d(2)\n+    !$omp parallel\n+      x = 1\n+      !$omp single\n+        !$omp depobj(d(1)) depend(out:x)\n+        !$omp depobj(d(2)) depend(in: x)\n+        !$omp task shared (x) depend(depobj: d(1))\n+          x = 2\n+        !$omp end task\n+        !$omp task shared (x) depend(depobj: d(2))\n+          if (x /= 2) &\n+            stop 3\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+    !$omp depobj(d(1)) destroy\n+    !$omp depobj(d(2)) destroy\n+  end\n+\n+  subroutine antidep\n+    xx = 1\n+    !$omp parallel\n+      !$omp single\n+        !$omp task shared(xx) depend(depobj:dd2)\n+          if (xx /= 1) &\n+            stop 4\n+        !$omp end task\n+        !$omp task shared(xx) depend(depobj:dd1)\n+          xx = 2\n+        !$omp end task\n+      !$omp end single\n+    !$omp end parallel\n+  end\n+end module m\n+\n+program main\n+  use m\n+  implicit none (type, external)\n+  call dep ()\n+  call dep2 ()\n+  call dep3 ()\n+  !$omp depobj (dd1) depend (inout: xx)\n+  !$omp depobj (dd2) depend (in : xx)\n+  call antidep ()\n+  !$omp depobj (dd2) destroy\n+  !$omp depobj (dd1) destroy\n+end program main"}]}