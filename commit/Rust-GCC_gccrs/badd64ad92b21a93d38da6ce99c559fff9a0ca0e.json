{"sha": "badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YmFkZDY0YWQ5MmIyMWE5M2QzOGRhNmNlOTljNTU5ZmZmOWEwY2EwZQ==", "commit": {"author": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-30T09:20:18Z"}, "committer": {"name": "Paolo Carlini", "email": "paolo@gcc.gnu.org", "date": "2004-06-30T09:20:18Z"}, "message": "[multiple changes]\n\n2004-06-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n            Paolo Carlini  <pcarlini@suse.de>\n\n\t* include/bits/cpp_type_traits.h: Add __is_pointer and\n\t__is_trivially_copyable.\n\t* include/bits/stl_algobase.h (fill, fill_n): Slightly\n\ttweak to use the latter.\n\t(__copy_backward_dispatch): Remove.\n\t(__copy_backward_aux): Rewrite to use __is_pointer and\n\t__is_trivially_copyable and __copy_backward::copy_b.\n\t(__copy_backward): Rewrite as a class template and two\n\tspecializations.\n\n2004-06-30  Paolo Carlini  <pcarlini@suse.de>\n\n\t* testsuite/25_algorithms/copy.cc: Move to...\n\t* testsuite/25_algorithms/copy/1.cc: ... here, extend.\n\t* testsuite/25_algorithms/copy/2.cc: New.\n\t* testsuite/25_algorithms/copy/3.cc: New.\n\t* testsuite/25_algorithms/copy/4.cc: New.\n\nFrom-SVN: r83897", "tree": {"sha": "47afddb5b21d4a4c5efe39325cfd9faa455b2817", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/47afddb5b21d4a4c5efe39325cfd9faa455b2817"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/comments", "author": null, "committer": null, "parents": [{"sha": "3e1b8dc08b8dcaefa077ab8cc93c877a2b28ee32", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3e1b8dc08b8dcaefa077ab8cc93c877a2b28ee32", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3e1b8dc08b8dcaefa077ab8cc93c877a2b28ee32"}], "stats": {"total": 400, "additions": 302, "deletions": 98}, "files": [{"sha": "92158acffc04f611aabab953e7f4f240c0dd537d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -1,3 +1,24 @@\n+2004-06-30  Gabriel Dos Reis  <gdr@integrable-solutions.net>\n+            Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* include/bits/cpp_type_traits.h: Add __is_pointer and\n+\t__is_trivially_copyable.\n+\t* include/bits/stl_algobase.h (fill, fill_n): Slightly\n+\ttweak to use the latter.\n+\t(__copy_backward_dispatch): Remove.\n+\t(__copy_backward_aux): Rewrite to use __is_pointer and\n+\t__is_trivially_copyable and __copy_backward::copy_b.\n+\t(__copy_backward): Rewrite as a class template and two\n+\tspecializations.\n+\n+2004-06-30  Paolo Carlini  <pcarlini@suse.de>\n+\n+\t* testsuite/25_algorithms/copy.cc: Move to...\n+\t* testsuite/25_algorithms/copy/1.cc: ... here, extend.\n+\t* testsuite/25_algorithms/copy/2.cc: New.\n+\t* testsuite/25_algorithms/copy/3.cc: New.\n+\t* testsuite/25_algorithms/copy/4.cc: New.\n+\n 2004-06-29  Paul Brook  <paul@codesourcery.com>\n \n \t* libsupc++/vec.cc (__cxa_vec_new2, __cxa_vec_new3): Store the"}, {"sha": "bf9254fd20423d09d41031f7493d1e37abd83080", "filename": "libstdc++-v3/include/bits/cpp_type_traits.h", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fcpp_type_traits.h?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -303,6 +303,27 @@ namespace std\n \t};\n     };\n \n+  //\n+  // Pointer types\n+  //\n+  template<typename _Tp>\n+    struct __is_pointer\n+    {\n+      enum\n+\t{\n+\t  _M_type = 0\n+\t};\n+    };\n+\n+  template<typename _Tp>\n+    struct __is_pointer<_Tp*>\n+    {\n+      enum\n+\t{\n+\t  _M_type = 1\n+\t};\n+    };\n+\n   //\n   // An arithmetic type is an integer type or a floating point type\n   //\n@@ -327,6 +348,18 @@ namespace std\n \t};\n     };\n \n+  //\n+  // A trivially copyable type is an arithmetic type or a pointer type\n+  // \n+  template<typename _Tp>\n+    struct __is_trivially_copyable\n+    {\n+      enum\n+\t{\n+\t  _M_type = __is_arithmetic<_Tp>::_M_type || __is_pointer<_Tp>::_M_type\n+\t};\n+    };\n+\n   //\n   // For the immediate use, the following is a good approximation\n   //"}, {"sha": "1b7c4b49ad5d96d09258baed7fe93bf63b4dd432", "filename": "libstdc++-v3/include/bits/stl_algobase.h", "status": "modified", "additions": 52, "deletions": 73, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_algobase.h?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -70,6 +70,7 @@\n #include <iosfwd>\n #include <bits/stl_pair.h>\n #include <bits/type_traits.h>\n+#include <bits/cpp_type_traits.h>\n #include <bits/stl_iterator_base_types.h>\n #include <bits/stl_iterator_base_funcs.h>\n #include <bits/stl_iterator.h>\n@@ -357,79 +358,59 @@ namespace std\n        typedef typename _Is_normal_iterator<_InputIterator>::_Normal __Normal;\n        return std::__copy_ni1(__first, __last, __result, __Normal());\n     }\n-\n-  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2>\n-    inline _BidirectionalIterator2\n-    __copy_backward(_BidirectionalIterator1 __first,\n-\t\t    _BidirectionalIterator1 __last,\n-\t\t    _BidirectionalIterator2 __result,\n-\t\t    bidirectional_iterator_tag)\n-    {\n-      while (__first != __last)\n-        *--__result = *--__last;\n-      return __result;\n-    }\n-\n-  template<typename _RandomAccessIterator, typename _BidirectionalIterator>\n-    inline _BidirectionalIterator\n-    __copy_backward(_RandomAccessIterator __first, _RandomAccessIterator __last,\n-\t\t    _BidirectionalIterator __result, random_access_iterator_tag)\n-    {\n-      typename iterator_traits<_RandomAccessIterator>::difference_type __n;\n-      for (__n = __last - __first; __n > 0; --__n)\n-        *--__result = *--__last;\n-      return __result;\n-    }\n-\n-\n-  // This dispatch class is a workaround for compilers that do not\n-  // have partial ordering of function templates.  All we're doing is\n-  // creating a specialization so that we can turn a call to copy_backward\n-  // into a memmove whenever possible.\n-  template<typename _BidirectionalIterator1, typename _BidirectionalIterator2,\n-           typename _BoolType>\n-    struct __copy_backward_dispatch\n-    {\n-      static _BidirectionalIterator2\n-      copy(_BidirectionalIterator1 __first, _BidirectionalIterator1 __last,\n-\t   _BidirectionalIterator2 __result)\n-      { return std::__copy_backward(__first, __last, __result,\n-\t\t\t\t    std::__iterator_category(__first)); }\n+  \n+  template<bool, typename>\n+    struct __copy_backward\n+    {\n+      template<typename _BI1, typename _BI2>\n+        static _BI2\n+        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)\n+        { \n+\t  while (__first != __last)\n+\t    *--__result = *--__last;\n+\t  return __result;\n+\t}\n     };\n \n-  template<typename _Tp>\n-    struct __copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n-    {\n-      static _Tp*\n-      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)\n-      {\n-\tconst ptrdiff_t _Num = __last - __first;\n-\tstd::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n-\treturn __result - _Num;\n-      }\n+  template<bool _BoolType>\n+    struct __copy_backward<_BoolType, random_access_iterator_tag>\n+    {\n+      template<typename _BI1, typename _BI2>\n+        static _BI2\n+        copy_b(_BI1 __first, _BI1 __last, _BI2 __result)\n+        { \n+\t  typename iterator_traits<_BI1>::difference_type __n;\n+\t  for (__n = __last - __first; __n > 0; --__n)\n+\t    *--__result = *--__last;\n+\t  return __result;\n+\t}\n     };\n \n-  template<typename _Tp>\n-    struct __copy_backward_dispatch<const _Tp*, _Tp*, __true_type>\n-    {\n-      static _Tp*\n-      copy(const _Tp* __first, const _Tp* __last, _Tp* __result)\n-      {\n-\treturn  std::__copy_backward_dispatch<_Tp*, _Tp*, __true_type>\n-\t  ::copy(__first, __last, __result);\n-      }\n+  template<>\n+    struct __copy_backward<true, random_access_iterator_tag>\n+    {\n+      template<typename _Tp>\n+        static _Tp*\n+        copy_b(const _Tp* __first, const _Tp* __last, _Tp* __result)\n+        { \n+\t  const ptrdiff_t _Num = __last - __first;\n+\t  std::memmove(__result - _Num, __first, sizeof(_Tp) * _Num);\n+\t  return __result - _Num;\n+\t}\n     };\n \n   template<typename _BI1, typename _BI2>\n     inline _BI2\n     __copy_backward_aux(_BI1 __first, _BI1 __last, _BI2 __result)\n     {\n-      typedef typename __type_traits<typename iterator_traits<_BI2>::value_type>\n-\t\t\t    ::has_trivial_assignment_operator _Trivial;\n-      return\n-\tstd::__copy_backward_dispatch<_BI1, _BI2, _Trivial>::copy(__first,\n-\t\t\t\t\t\t\t\t  __last,\n-\t\t\t\t\t\t\t\t  __result);\n+      typedef typename iterator_traits<_BI2>::value_type _ValueType;\n+      typedef typename iterator_traits<_BI1>::iterator_category _Category;\n+      const bool __simple = (__is_trivially_copyable<_ValueType>::_M_type\n+\t                     && __is_pointer<_BI1>::_M_type\n+\t                     && __is_pointer<_BI2>::_M_type);\n+\n+      return __copy_backward<__simple, _Category>::copy_b(__first, __last,\n+\t\t\t\t\t\t\t  __result);\n     }\n \n   template <typename _BI1, typename _BI2>\n@@ -499,7 +480,7 @@ namespace std\n \t\t\t\t\t\t\t__result, __Normal());\n     }\n \n-  template<typename>\n+  template<bool>\n     struct __fill\n     {\n       template<typename _ForwardIterator, typename _Tp>\n@@ -513,7 +494,7 @@ namespace std\n     };\n \n   template<>\n-    struct __fill<__true_type>\n+    struct __fill<true>\n     {\n       template<typename _ForwardIterator, typename _Tp>\n         static void\n@@ -546,9 +527,8 @@ namespace std\n \t\t\t\t  _ForwardIterator>)\n       __glibcxx_requires_valid_range(__first, __last);\n \n-      typedef typename __type_traits<_Tp>::has_trivial_copy_constructor\n-\t_Trivial;\n-      std::__fill<_Trivial>::fill(__first, __last, __value);\n+      const bool __trivial = __is_trivially_copyable<_Tp>::_M_type;\n+      std::__fill<__trivial>::fill(__first, __last, __value);\n     }\n \n   // Specialization: for one-byte types we can use memset.\n@@ -576,7 +556,7 @@ namespace std\n     std::memset(__first, static_cast<unsigned char>(__tmp), __last - __first);\n   }\n \n-  template<typename>\n+  template<bool>\n     struct __fill_n\n     {\n       template<typename _OutputIterator, typename _Size, typename _Tp>\n@@ -590,7 +570,7 @@ namespace std\n     };\n \n   template<>\n-    struct __fill_n<__true_type>\n+    struct __fill_n<true>\n     {\n       template<typename _OutputIterator, typename _Size, typename _Tp>\n         static _OutputIterator\n@@ -621,9 +601,8 @@ namespace std\n       // concept requirements\n       __glibcxx_function_requires(_OutputIteratorConcept<_OutputIterator, _Tp>)\n \n-      typedef typename __type_traits<_Tp>::has_trivial_copy_constructor\n-\t_Trivial;\n-      return std::__fill_n<_Trivial>::fill_n(__first, __n, __value);\n+      const bool __trivial = __is_trivially_copyable<_Tp>::_M_type;\n+      return std::__fill_n<__trivial>::fill_n(__first, __n, __value);\n     }\n \n   template<typename _Size>"}, {"sha": "8574522972d2d78b4f1c664d810a59cb42dd8b8d", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/1.cc", "status": "renamed", "additions": 23, "deletions": 25, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F1.cc?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -16,43 +16,41 @@\n // Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n // USA.\n \n-// 25.2.12 [lib.alg.partitions] Partitions.\n+// 25.2.1 [lib.alg.copy] Copy.\n \n #include <algorithm>\n+#include <vector>\n #include <testsuite_hooks.h>\n \n-bool test __attribute__((unused)) = true;\n-\n-const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n-const int N = sizeof(A) / sizeof(int);\n-\n-// copy\n void\n test01()\n {\n-    using std::copy;\n-\n-    int s1[N];\n-    copy(A, A + N, s1);\n-    VERIFY(std::equal(s1, s1 + N, A));\n-}\n-\n-// copy_backward\n-void\n-test02()\n-{\n-    using std::copy_backward;\n-\n-    int s1[N];\n-    copy_backward(A, A + N, s1 + N);\n-    VERIFY(std::equal(s1, s1 + N, A));\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  \n+  int s1[N];\n+  copy(A, A + N, s1);\n+  VERIFY( equal(s1, s1 + N, A) );\n+\n+  vector<int> v1(N);\n+  copy(A, A + N, v1.begin());\n+  VERIFY( equal(v1.begin(), v1.end(), A) );\n+\n+  int s2[N];\n+  copy_backward(A, A + N, s2 + N);\n+  VERIFY( equal(s2, s2 + N, A) );\n+\n+  vector<int> v2(N);\n+  copy_backward(A, A + N, v2.end());\n+  VERIFY( equal(v2.begin(), v2.end(), A) );\n }\n \n int\n main()\n {\n   test01();\n-  test02();\n-\n   return 0;\n }", "previous_filename": "libstdc++-v3/testsuite/25_algorithms/copy.cc"}, {"sha": "d7bd1793e41c3b80553f263ff1686967ac10af31", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/2.cc", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F2.cc?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -0,0 +1,57 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.1 [lib.alg.copy] Copy.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  const vector<int> a(A, A + N);\n+\n+  int s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  vector<int> v1(N);\n+  copy(a.begin(), a.end(), v1.begin());\n+  VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n+\n+  int s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n+\n+  vector<int> v2(N);\n+  copy_backward(a.begin(), a.end(), v2.end());\n+  VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "0453ce816328254f1e3f47133319c647c84c1502", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/3.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F3.cc?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.1 [lib.alg.copy] Copy.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <deque>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  const deque<int> a(A, A + N);\n+\n+  int s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  vector<int> v1(N);\n+  copy(a.begin(), a.end(), v1.begin());\n+  VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n+\n+  int s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n+\n+  vector<int> v2(N);\n+  copy_backward(a.begin(), a.end(), v2.end());\n+  VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}, {"sha": "703adf81c415415faafff4deaa5fa5cdb81cb46e", "filename": "libstdc++-v3/testsuite/25_algorithms/copy/4.cc", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/badd64ad92b21a93d38da6ce99c559fff9a0ca0e/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Ftestsuite%2F25_algorithms%2Fcopy%2F4.cc?ref=badd64ad92b21a93d38da6ce99c559fff9a0ca0e", "patch": "@@ -0,0 +1,58 @@\n+// Copyright (C) 2004 Free Software Foundation, Inc.\n+//\n+// This file is part of the GNU ISO C++ Library.  This library is free\n+// software; you can redistribute it and/or modify it under the\n+// terms of the GNU General Public License as published by the\n+// Free Software Foundation; either version 2, or (at your option)\n+// any later version.\n+\n+// This library is distributed in the hope that it will be useful,\n+// but WITHOUT ANY WARRANTY; without Pred the implied warranty of\n+// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+// GNU General Public License for more details.\n+\n+// You should have received a copy of the GNU General Public License along\n+// with this library; see the file COPYING.  If not, write to the Free\n+// Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307,\n+// USA.\n+\n+// 25.2.1 [lib.alg.copy] Copy.\n+\n+#include <algorithm>\n+#include <vector>\n+#include <list>\n+#include <testsuite_hooks.h>\n+\n+void\n+test01()\n+{\n+  using namespace std;\n+  bool test __attribute__((unused)) = true;\n+\n+  const int A[] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17};\n+  const int N = sizeof(A) / sizeof(int);\n+  const list<int> a(A, A + N);\n+  \n+  int s1[N];\n+  copy(a.begin(), a.end(), s1);\n+  VERIFY( equal(s1, s1 + N, a.begin()) );\n+\n+  vector<int> v1(N);\n+  copy(a.begin(), a.end(), v1.begin());\n+  VERIFY( equal(v1.begin(), v1.end(), a.begin()) );\n+\n+  int s2[N];\n+  copy_backward(a.begin(), a.end(), s2 + N);\n+  VERIFY( equal(s2, s2 + N, a.begin()) );\n+\n+  vector<int> v2(N);\n+  copy_backward(a.begin(), a.end(), v2.end());\n+  VERIFY( equal(v2.begin(), v2.end(), a.begin()) );\n+}\n+\n+int\n+main()\n+{\n+  test01();\n+  return 0;\n+}"}]}