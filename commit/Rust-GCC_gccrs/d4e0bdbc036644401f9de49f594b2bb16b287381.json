{"sha": "d4e0bdbc036644401f9de49f594b2bb16b287381", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDRlMGJkYmMwMzY2NDQ0MDFmOWRlNDlmNTk0YjJiYjE2YjI4NzM4MQ==", "commit": {"author": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-03-05T20:46:50Z"}, "committer": {"name": "Marek Polacek", "email": "polacek@redhat.com", "date": "2021-03-25T20:11:29Z"}, "message": "c++: ICE on invalid with inheriting constructors [PR94751]\n\nThis is an ICE on invalid where we crash because since r269032 we\nkeep error_mark_node around instead of using noexcept_false_spec\nwhen things go wrong; see the walk_field_subobs hunk.\n\nWe crash in deduce_inheriting_ctor which calls synthesized_method_walk\nto deduce the exception-specification, but fails to do so in this case,\nbecause the testcase is invalid so get_nsdmi returns error_mark_node for\nthe member 'c', and per r269032 the error_mark_node propagates back to\ndeduce_inheriting_ctor which subsequently calls build_exception_variant\nwhereon we crash.  I think we should return early if the deduction fails\nand I decided to call mark_used to get an error right away instead of\nhoping that it would get called later.  My worry is that we could forget\nthat there was an error and think that we just deduced noexcept(false).\n\nAnd then I noticed that the test still crashes in C++98.  Here again we\nfailed to deduce the exception-specification in implicitly_declare_fn,\nbut nothing reported an error between synthesized_method_walk and the\nassert.  Well, not much we can do except calling synthesized_method_walk\nagain, this time in the verbose mode and making sure that we did get an\nerror.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94751\n\t* call.c (build_over_call): Maybe call mark_used in case\n\tdeduce_inheriting_ctor fails and return error_mark_node.\n\t* cp-tree.h (deduce_inheriting_ctor): Adjust declaration.\n\t* method.c (deduce_inheriting_ctor): Return bool if the deduction\n\tfails.\n\t(implicitly_declare_fn): If raises is error_mark_node, call\n\tsynthesized_method_walk with diag being true.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94751\n\t* g++.dg/cpp0x/inh-ctor37.C: New test.", "tree": {"sha": "9aff239d30e7a17d1fffca0c5fb9fd2e692607cd", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/9aff239d30e7a17d1fffca0c5fb9fd2e692607cd"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d4e0bdbc036644401f9de49f594b2bb16b287381", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e0bdbc036644401f9de49f594b2bb16b287381", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d4e0bdbc036644401f9de49f594b2bb16b287381", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d4e0bdbc036644401f9de49f594b2bb16b287381/comments", "author": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "committer": {"login": "mpolacek", "id": 10496300, "node_id": "MDQ6VXNlcjEwNDk2MzAw", "avatar_url": "https://avatars.githubusercontent.com/u/10496300?v=4", "gravatar_id": "", "url": "https://api.github.com/users/mpolacek", "html_url": "https://github.com/mpolacek", "followers_url": "https://api.github.com/users/mpolacek/followers", "following_url": "https://api.github.com/users/mpolacek/following{/other_user}", "gists_url": "https://api.github.com/users/mpolacek/gists{/gist_id}", "starred_url": "https://api.github.com/users/mpolacek/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/mpolacek/subscriptions", "organizations_url": "https://api.github.com/users/mpolacek/orgs", "repos_url": "https://api.github.com/users/mpolacek/repos", "events_url": "https://api.github.com/users/mpolacek/events{/privacy}", "received_events_url": "https://api.github.com/users/mpolacek/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "0b86a6438191f720bebf880a2b932cd97d10229a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0b86a6438191f720bebf880a2b932cd97d10229a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0b86a6438191f720bebf880a2b932cd97d10229a"}], "stats": {"total": 59, "additions": 51, "deletions": 8}, "files": [{"sha": "4b81d0ff33311676d5f7e6b1397c0176a479a886", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=d4e0bdbc036644401f9de49f594b2bb16b287381", "patch": "@@ -8947,8 +8947,13 @@ build_over_call (struct z_candidate *cand, int flags, tsubst_flags_t complain)\n   /* OK, we're actually calling this inherited constructor; set its deletedness\n      appropriately.  We can get away with doing this here because calling is\n      the only way to refer to a constructor.  */\n-  if (DECL_INHERITED_CTOR (fn))\n-    deduce_inheriting_ctor (fn);\n+  if (DECL_INHERITED_CTOR (fn)\n+      && !deduce_inheriting_ctor (fn))\n+    {\n+      if (complain & tf_error)\n+\tmark_used (fn);\n+      return error_mark_node;\n+    }\n \n   /* Make =delete work with SFINAE.  */\n   if (DECL_DELETED_FN (fn))"}, {"sha": "f6470524cf8c33e891187a06bc461e42eb69b511", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=d4e0bdbc036644401f9de49f594b2bb16b287381", "patch": "@@ -6915,7 +6915,7 @@ extern bool is_xible\t\t\t\t(enum tree_code, tree, tree);\n extern tree get_defaulted_eh_spec\t\t(tree, tsubst_flags_t = tf_warning_or_error);\n extern bool maybe_explain_implicit_delete\t(tree);\n extern void explain_implicit_non_constexpr\t(tree);\n-extern void deduce_inheriting_ctor\t\t(tree);\n+extern bool deduce_inheriting_ctor\t\t(tree);\n extern bool decl_remember_implicit_trigger_p\t(tree);\n extern void synthesize_method\t\t\t(tree);\n extern tree lazily_declare_fn\t\t\t(special_function_kind,"}, {"sha": "25c1e681b996075038e4819a66580120ff2ee009", "filename": "gcc/cp/method.c", "status": "modified", "additions": 17, "deletions": 5, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=d4e0bdbc036644401f9de49f594b2bb16b287381", "patch": "@@ -2789,9 +2789,9 @@ explain_implicit_non_constexpr (tree decl)\n \n /* DECL is an instantiation of an inheriting constructor template.  Deduce\n    the correct exception-specification and deletedness for this particular\n-   specialization.  */\n+   specialization.  Return true if the deduction succeeds; false otherwise.  */\n \n-void\n+bool\n deduce_inheriting_ctor (tree decl)\n {\n   decl = DECL_ORIGIN (decl);\n@@ -2804,6 +2804,8 @@ deduce_inheriting_ctor (tree decl)\n \t\t\t   /*diag*/false,\n \t\t\t   &inh,\n \t\t\t   FUNCTION_FIRST_USER_PARMTYPE (decl));\n+  if (spec == error_mark_node)\n+    return false;\n   if (TREE_CODE (inherited_ctor_binfo (decl)) != TREE_BINFO)\n     /* Inherited the same constructor from different base subobjects.  */\n     deleted = true;\n@@ -2818,6 +2820,8 @@ deduce_inheriting_ctor (tree decl)\n       TREE_TYPE (clone) = build_exception_variant (TREE_TYPE (clone), spec);\n       SET_DECL_INHERITED_CTOR (clone, inh);\n     }\n+\n+  return true;\n }\n \n /* Implicitly declare the special function indicated by KIND, as a\n@@ -2993,9 +2997,17 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n       if (raises != error_mark_node)\n \tfn_type = build_exception_variant (fn_type, raises);\n       else\n-\t/* Can happen, eg, in C++98 mode for an ill-formed non-static data\n-\t   member initializer (c++/89914).  */\n-\tgcc_assert (seen_error ());\n+\t{\n+\t  /* Can happen, e.g., in C++98 mode for an ill-formed non-static data\n+\t     member initializer (c++/89914).  Also, in C++98, we might have\n+\t     failed to deduce RAISES, so try again but complain this time.  */\n+\t  if (cxx_dialect < cxx11)\n+\t    synthesized_method_walk (type, kind, const_p, nullptr, nullptr,\n+\t\t\t\t     nullptr, nullptr, /*diag=*/true,\n+\t\t\t\t     &inherited_ctor, inherited_parms);\n+\t  /* We should have seen an error at this point.  */\n+\t  gcc_assert (seen_error ());\n+\t}\n     }\n   fn = build_lang_decl (FUNCTION_DECL, name, fn_type);\n   if (kind != sfk_inheriting_constructor)"}, {"sha": "7d12b534d95b6f678f649574e6b6172530ad3926", "filename": "gcc/testsuite/g++.dg/cpp0x/inh-ctor37.C", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor37.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d4e0bdbc036644401f9de49f594b2bb16b287381/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor37.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp0x%2Finh-ctor37.C?ref=d4e0bdbc036644401f9de49f594b2bb16b287381", "patch": "@@ -0,0 +1,26 @@\n+// PR c++/94751\n+// { dg-do compile }\n+// { dg-options \"-w\" }\n+\n+struct A {\n+  A(float);\n+};\n+\n+template<typename T> \n+struct B : A {\n+  using A::A;\n+\n+  struct C {\n+    C(int);\n+  };\n+\n+  C c{ \"foo\" }; // { dg-error \"invalid conversion\" }\n+};\n+\n+struct S { S(B<A> *); };\n+\n+S\n+fn ()\n+{\n+  return S(new B<A>(10.5)); // { dg-error \"no matching function\" \"\" { target c++98_only } }\n+}"}]}