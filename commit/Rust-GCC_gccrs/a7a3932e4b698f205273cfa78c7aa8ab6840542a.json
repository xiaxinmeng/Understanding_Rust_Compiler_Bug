{"sha": "a7a3932e4b698f205273cfa78c7aa8ab6840542a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6YTdhMzkzMmU0YjY5OGYyMDUyNzNjZmE3OGM3YWE4YWI2ODQwNTQyYQ==", "commit": {"author": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-19T14:02:54Z"}, "committer": {"name": "Jonathan Wakely", "email": "jwakely@redhat.com", "date": "2020-06-19T14:02:54Z"}, "message": "libstdc++: Remove redundant std:: qualification\n\n\t* include/bits/stl_pair.h (_Index_tuple): Remove redundant\n\tnamespace qualification.\n\t(pair::pair(tuple<>&, tuple<>&, _Index_tuple, _Index_tuple)):\n\tLikewise.\n\t* include/std/tuple (_Head_base, _Tuple_impl, tuple_size)\n\t(tuple_element, __get_helper, get, __make_tuple_impl)\n\t(__make_1st_indices, __tuple_concater)\n\t(pair::pair(tuple<>&, tuple<>&, _Index_tuple, _Index_tuple)):\n\tLikewise.\n\t* include/std/utility (tuple_element, __is_tuple_like_impl)\n\t(tuple_size, __pair_get, get): Likewise.", "tree": {"sha": "a4a1b805769ccf0c8ab4953de6e6ed885212a0b8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/a4a1b805769ccf0c8ab4953de6e6ed885212a0b8"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/a7a3932e4b698f205273cfa78c7aa8ab6840542a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a3932e4b698f205273cfa78c7aa8ab6840542a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/a7a3932e4b698f205273cfa78c7aa8ab6840542a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/a7a3932e4b698f205273cfa78c7aa8ab6840542a/comments", "author": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "committer": {"login": "jwakely", "id": 1254480, "node_id": "MDQ6VXNlcjEyNTQ0ODA=", "avatar_url": "https://avatars.githubusercontent.com/u/1254480?v=4", "gravatar_id": "", "url": "https://api.github.com/users/jwakely", "html_url": "https://github.com/jwakely", "followers_url": "https://api.github.com/users/jwakely/followers", "following_url": "https://api.github.com/users/jwakely/following{/other_user}", "gists_url": "https://api.github.com/users/jwakely/gists{/gist_id}", "starred_url": "https://api.github.com/users/jwakely/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/jwakely/subscriptions", "organizations_url": "https://api.github.com/users/jwakely/orgs", "repos_url": "https://api.github.com/users/jwakely/repos", "events_url": "https://api.github.com/users/jwakely/events{/privacy}", "received_events_url": "https://api.github.com/users/jwakely/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "abed8b56b92b103275e6871b689862c0495b761b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/abed8b56b92b103275e6871b689862c0495b761b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/abed8b56b92b103275e6871b689862c0495b761b"}], "stats": {"total": 158, "additions": 79, "deletions": 79}, "files": [{"sha": "e5669d5d7ae8891671cb030187ed685239eab8f5", "filename": "libstdc++-v3/include/bits/stl_pair.h", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_pair.h?ref=a7a3932e4b698f205273cfa78c7aa8ab6840542a", "patch": "@@ -89,7 +89,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename...>\n     class tuple;\n \n-  template<std::size_t...>\n+  template<size_t...>\n     struct _Index_tuple;\n \n   // Concept utility functions, reused in conditionally-explicit\n@@ -446,11 +446,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       }\n \n     private:\n-      template<typename... _Args1, std::size_t... _Indexes1,\n-               typename... _Args2, std::size_t... _Indexes2>\n+      template<typename... _Args1, size_t... _Indexes1,\n+\t       typename... _Args2, size_t... _Indexes2>\n \t_GLIBCXX20_CONSTEXPR\n         pair(tuple<_Args1...>&, tuple<_Args2...>&,\n-             _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n+\t     _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>);\n #endif // C++11\n     };\n "}, {"sha": "726ad0aabbb5e2f37b5147856d7c6b867e15047f", "filename": "libstdc++-v3/include/std/tuple", "status": "modified", "additions": 27, "deletions": 27, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Ftuple?ref=a7a3932e4b698f205273cfa78c7aa8ab6840542a", "patch": "@@ -69,11 +69,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     = typename conditional<__is_final(_Tp), false_type,\n \t\t\t   __is_empty_non_tuple<_Tp>>::type;\n \n-  template<std::size_t _Idx, typename _Head,\n+  template<size_t _Idx, typename _Head,\n \t   bool = __empty_not_final<_Head>::value>\n     struct _Head_base;\n \n-  template<std::size_t _Idx, typename _Head>\n+  template<size_t _Idx, typename _Head>\n     struct _Head_base<_Idx, _Head, true>\n     : public _Head\n     {\n@@ -120,7 +120,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       _M_head(const _Head_base& __b) noexcept { return __b; }\n     };\n \n-  template<std::size_t _Idx, typename _Head>\n+  template<size_t _Idx, typename _Head>\n     struct _Head_base<_Idx, _Head, false>\n     {\n       constexpr _Head_base()\n@@ -179,20 +179,20 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * point in the hierarchy; we use it to implement a constant-time\n    * get() operation.\n    */\n-  template<std::size_t _Idx, typename... _Elements>\n+  template<size_t _Idx, typename... _Elements>\n     struct _Tuple_impl;\n \n   /**\n    * Recursive tuple implementation. Here we store the @c Head element\n    * and derive from a @c Tuple_impl containing the remaining elements\n    * (which contains the @c Tail).\n    */\n-  template<std::size_t _Idx, typename _Head, typename... _Tail>\n+  template<size_t _Idx, typename _Head, typename... _Tail>\n     struct _Tuple_impl<_Idx, _Head, _Tail...>\n     : public _Tuple_impl<_Idx + 1, _Tail...>,\n       private _Head_base<_Idx, _Head>\n     {\n-      template<std::size_t, typename...> friend class _Tuple_impl;\n+      template<size_t, typename...> friend class _Tuple_impl;\n \n       typedef _Tuple_impl<_Idx + 1, _Tail...> _Inherited;\n       typedef _Head_base<_Idx, _Head> _Base;\n@@ -337,11 +337,11 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   // Basis case of inheritance recursion.\n-  template<std::size_t _Idx, typename _Head>\n+  template<size_t _Idx, typename _Head>\n     struct _Tuple_impl<_Idx, _Head>\n     : private _Head_base<_Idx, _Head>\n     {\n-      template<std::size_t, typename...> friend class _Tuple_impl;\n+      template<size_t, typename...> friend class _Tuple_impl;\n \n       typedef _Head_base<_Idx, _Head> _Base;\n \n@@ -1244,7 +1244,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   /// class tuple_size\n   template<typename... _Elements>\n     struct tuple_size<tuple<_Elements...>>\n-    : public integral_constant<std::size_t, sizeof...(_Elements)> { };\n+    : public integral_constant<size_t, sizeof...(_Elements)> { };\n \n #if __cplusplus > 201402L\n   template <typename _Tp>\n@@ -1255,7 +1255,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n    * Recursive case for tuple_element: strip off the first element in\n    * the tuple and retrieve the (i-1)th element of the remaining tuple.\n    */\n-  template<std::size_t __i, typename _Head, typename... _Tail>\n+  template<size_t __i, typename _Head, typename... _Tail>\n     struct tuple_element<__i, tuple<_Head, _Tail...> >\n     : tuple_element<__i - 1, tuple<_Tail...> > { };\n \n@@ -1278,30 +1278,30 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t  \"tuple index is in range\");\n     };\n \n-  template<std::size_t __i, typename _Head, typename... _Tail>\n+  template<size_t __i, typename _Head, typename... _Tail>\n     constexpr _Head&\n     __get_helper(_Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n     { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n \n-  template<std::size_t __i, typename _Head, typename... _Tail>\n+  template<size_t __i, typename _Head, typename... _Tail>\n     constexpr const _Head&\n     __get_helper(const _Tuple_impl<__i, _Head, _Tail...>& __t) noexcept\n     { return _Tuple_impl<__i, _Head, _Tail...>::_M_head(__t); }\n \n   /// Return a reference to the ith element of a tuple.\n-  template<std::size_t __i, typename... _Elements>\n+  template<size_t __i, typename... _Elements>\n     constexpr __tuple_element_t<__i, tuple<_Elements...>>&\n     get(tuple<_Elements...>& __t) noexcept\n     { return std::__get_helper<__i>(__t); }\n \n   /// Return a const reference to the ith element of a const tuple.\n-  template<std::size_t __i, typename... _Elements>\n+  template<size_t __i, typename... _Elements>\n     constexpr const __tuple_element_t<__i, tuple<_Elements...>>&\n     get(const tuple<_Elements...>& __t) noexcept\n     { return std::__get_helper<__i>(__t); }\n \n   /// Return an rvalue reference to the ith element of a tuple rvalue.\n-  template<std::size_t __i, typename... _Elements>\n+  template<size_t __i, typename... _Elements>\n     constexpr __tuple_element_t<__i, tuple<_Elements...>>&&\n     get(tuple<_Elements...>&& __t) noexcept\n     {\n@@ -1310,7 +1310,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     }\n \n   /// Return a const rvalue reference to the ith element of a const tuple rvalue.\n-  template<std::size_t __i, typename... _Elements>\n+  template<size_t __i, typename... _Elements>\n     constexpr const __tuple_element_t<__i, tuple<_Elements...>>&&\n     get(const tuple<_Elements...>&& __t) noexcept\n     {\n@@ -1496,15 +1496,15 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n \t\t\t_Tuple, _Nm>\n     { };\n \n-  template<std::size_t _Nm, typename _Tuple, typename... _Tp>\n+  template<size_t _Nm, typename _Tuple, typename... _Tp>\n     struct __make_tuple_impl<_Nm, tuple<_Tp...>, _Tuple, _Nm>\n     {\n       typedef tuple<_Tp...> __type;\n     };\n \n   template<typename _Tuple>\n     struct __do_make_tuple\n-    : __make_tuple_impl<0, tuple<>, _Tuple, std::tuple_size<_Tuple>::value>\n+    : __make_tuple_impl<0, tuple<>, _Tuple, tuple_size<_Tuple>::value>\n     { };\n \n   // Returns the std::tuple equivalent of a tuple-like type.\n@@ -1552,14 +1552,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<>\n     struct __make_1st_indices<>\n     {\n-      typedef std::_Index_tuple<> __type;\n+      typedef _Index_tuple<> __type;\n     };\n \n   template<typename _Tp, typename... _Tpls>\n     struct __make_1st_indices<_Tp, _Tpls...>\n     {\n-      typedef typename std::_Build_index_tuple<std::tuple_size<\n-\ttypename std::remove_reference<_Tp>::type>::value>::__type __type;\n+      typedef typename _Build_index_tuple<tuple_size<\n+\ttypename remove_reference<_Tp>::type>::value>::__type __type;\n     };\n \n   // Performs the actual concatenation by step-wise expanding tuple-like\n@@ -1568,8 +1568,8 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n   template<typename _Ret, typename _Indices, typename... _Tpls>\n     struct __tuple_concater;\n \n-  template<typename _Ret, std::size_t... _Is, typename _Tp, typename... _Tpls>\n-    struct __tuple_concater<_Ret, std::_Index_tuple<_Is...>, _Tp, _Tpls...>\n+  template<typename _Ret, size_t... _Is, typename _Tp, typename... _Tpls>\n+    struct __tuple_concater<_Ret, _Index_tuple<_Is...>, _Tp, _Tpls...>\n     {\n       template<typename... _Us>\n         static constexpr _Ret\n@@ -1584,7 +1584,7 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     };\n \n   template<typename _Ret>\n-    struct __tuple_concater<_Ret, std::_Index_tuple<>>\n+    struct __tuple_concater<_Ret, _Index_tuple<>>\n     {\n       template<typename... _Us>\n \tstatic constexpr _Ret\n@@ -1679,14 +1679,14 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n       { }\n \n   template<class _T1, class _T2>\n-    template<typename... _Args1, std::size_t... _Indexes1,\n-             typename... _Args2, std::size_t... _Indexes2>\n+    template<typename... _Args1, size_t... _Indexes1,\n+\t     typename... _Args2, size_t... _Indexes2>\n       _GLIBCXX20_CONSTEXPR inline\n       pair<_T1, _T2>::\n       pair(tuple<_Args1...>& __tuple1, tuple<_Args2...>& __tuple2,\n \t   _Index_tuple<_Indexes1...>, _Index_tuple<_Indexes2...>)\n       : first(std::forward<_Args1>(std::get<_Indexes1>(__tuple1))...),\n-        second(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)\n+\tsecond(std::forward<_Args2>(std::get<_Indexes2>(__tuple2))...)\n       { }\n \n #if __cplusplus >= 201703L"}, {"sha": "cde375259f76932a1fee130b8773a0129474caf9", "filename": "libstdc++-v3/include/std/utility", "status": "modified", "additions": 48, "deletions": 48, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/a7a3932e4b698f205273cfa78c7aa8ab6840542a/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fstd%2Futility?ref=a7a3932e4b698f205273cfa78c7aa8ab6840542a", "patch": "@@ -110,26 +110,26 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n     : public tuple_size<_Tp> { };\n \n   /// Gives the type of the ith element of a given tuple type.\n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     struct tuple_element;\n \n   // Duplicate of C++14's tuple_element_t for internal use in C++11 mode\n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     using __tuple_element_t = typename tuple_element<__i, _Tp>::type;\n \n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     struct tuple_element<__i, const _Tp>\n     {\n       typedef typename add_const<__tuple_element_t<__i, _Tp>>::type type;\n     };\n \n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     struct tuple_element<__i, volatile _Tp>\n     {\n       typedef typename add_volatile<__tuple_element_t<__i, _Tp>>::type type;\n     };\n \n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     struct tuple_element<__i, const volatile _Tp>\n     {\n       typedef typename add_cv<__tuple_element_t<__i, _Tp>>::type type;\n@@ -141,101 +141,101 @@ _GLIBCXX_BEGIN_NAMESPACE_VERSION\n // of tuple_element<pair<T,U>> and tuple_element<array<T,N>> are defined.\n #define __cpp_lib_tuple_element_t 201402L\n \n-  template<std::size_t __i, typename _Tp>\n+  template<size_t __i, typename _Tp>\n     using tuple_element_t = typename tuple_element<__i, _Tp>::type;\n #endif\n \n   // Various functions which give std::pair a tuple-like interface.\n \n   /// Partial specialization for std::pair\n   template<typename _T1, typename _T2>\n-    struct __is_tuple_like_impl<std::pair<_T1, _T2>> : true_type\n+    struct __is_tuple_like_impl<pair<_T1, _T2>> : true_type\n     { };\n \n   /// Partial specialization for std::pair\n   template<class _Tp1, class _Tp2>\n-    struct tuple_size<std::pair<_Tp1, _Tp2>>\n-    : public integral_constant<std::size_t, 2> { };\n+    struct tuple_size<pair<_Tp1, _Tp2>>\n+    : public integral_constant<size_t, 2> { };\n \n   /// Partial specialization for std::pair\n   template<class _Tp1, class _Tp2>\n-    struct tuple_element<0, std::pair<_Tp1, _Tp2>>\n+    struct tuple_element<0, pair<_Tp1, _Tp2>>\n     { typedef _Tp1 type; };\n \n   /// Partial specialization for std::pair\n   template<class _Tp1, class _Tp2>\n-    struct tuple_element<1, std::pair<_Tp1, _Tp2>>\n+    struct tuple_element<1, pair<_Tp1, _Tp2>>\n     { typedef _Tp2 type; };\n \n-  template<std::size_t _Int>\n+  template<size_t _Int>\n     struct __pair_get;\n \n   template<>\n     struct __pair_get<0>\n     {\n       template<typename _Tp1, typename _Tp2>\n-        static constexpr _Tp1&\n-        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept\n-        { return __pair.first; }\n+\tstatic constexpr _Tp1&\n+\t__get(pair<_Tp1, _Tp2>& __pair) noexcept\n+\t{ return __pair.first; }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr _Tp1&&\n-        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept\n-        { return std::forward<_Tp1>(__pair.first); }\n+\tstatic constexpr _Tp1&&\n+\t__move_get(pair<_Tp1, _Tp2>&& __pair) noexcept\n+\t{ return std::forward<_Tp1>(__pair.first); }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr const _Tp1&\n-        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept\n-        { return __pair.first; }\n+\tstatic constexpr const _Tp1&\n+\t__const_get(const pair<_Tp1, _Tp2>& __pair) noexcept\n+\t{ return __pair.first; }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr const _Tp1&&\n-        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept\n-        { return std::forward<const _Tp1>(__pair.first); }\n+\tstatic constexpr const _Tp1&&\n+\t__const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept\n+\t{ return std::forward<const _Tp1>(__pair.first); }\n     };\n \n   template<>\n     struct __pair_get<1>\n     {\n       template<typename _Tp1, typename _Tp2>\n-        static constexpr _Tp2&\n-        __get(std::pair<_Tp1, _Tp2>& __pair) noexcept\n-        { return __pair.second; }\n+\tstatic constexpr _Tp2&\n+\t__get(pair<_Tp1, _Tp2>& __pair) noexcept\n+\t{ return __pair.second; }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr _Tp2&&\n-        __move_get(std::pair<_Tp1, _Tp2>&& __pair) noexcept\n-        { return std::forward<_Tp2>(__pair.second); }\n+\tstatic constexpr _Tp2&&\n+\t__move_get(pair<_Tp1, _Tp2>&& __pair) noexcept\n+\t{ return std::forward<_Tp2>(__pair.second); }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr const _Tp2&\n-        __const_get(const std::pair<_Tp1, _Tp2>& __pair) noexcept\n-        { return __pair.second; }\n+\tstatic constexpr const _Tp2&\n+\t__const_get(const pair<_Tp1, _Tp2>& __pair) noexcept\n+\t{ return __pair.second; }\n \n       template<typename _Tp1, typename _Tp2>\n-        static constexpr const _Tp2&&\n-        __const_move_get(const std::pair<_Tp1, _Tp2>&& __pair) noexcept\n-        { return std::forward<const _Tp2>(__pair.second); }\n+\tstatic constexpr const _Tp2&&\n+\t__const_move_get(const pair<_Tp1, _Tp2>&& __pair) noexcept\n+\t{ return std::forward<const _Tp2>(__pair.second); }\n     };\n \n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&\n-    get(std::pair<_Tp1, _Tp2>& __in) noexcept\n+  template<size_t _Int, class _Tp1, class _Tp2>\n+    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&\n+    get(pair<_Tp1, _Tp2>& __in) noexcept\n     { return __pair_get<_Int>::__get(__in); }\n \n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-    constexpr typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&\n-    get(std::pair<_Tp1, _Tp2>&& __in) noexcept\n+  template<size_t _Int, class _Tp1, class _Tp2>\n+    constexpr typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&\n+    get(pair<_Tp1, _Tp2>&& __in) noexcept\n     { return __pair_get<_Int>::__move_get(std::move(__in)); }\n \n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&\n-    get(const std::pair<_Tp1, _Tp2>& __in) noexcept\n+  template<size_t _Int, class _Tp1, class _Tp2>\n+    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&\n+    get(const pair<_Tp1, _Tp2>& __in) noexcept\n     { return __pair_get<_Int>::__const_get(__in); }\n \n-  template<std::size_t _Int, class _Tp1, class _Tp2>\n-    constexpr const typename tuple_element<_Int, std::pair<_Tp1, _Tp2>>::type&&\n-    get(const std::pair<_Tp1, _Tp2>&& __in) noexcept\n+  template<size_t _Int, class _Tp1, class _Tp2>\n+    constexpr const typename tuple_element<_Int, pair<_Tp1, _Tp2>>::type&&\n+    get(const pair<_Tp1, _Tp2>&& __in) noexcept\n     { return __pair_get<_Int>::__const_move_get(std::move(__in)); }\n \n #if __cplusplus >= 201402L"}]}