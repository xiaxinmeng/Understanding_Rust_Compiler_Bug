{"sha": "41b6a5e2c06e315f3fc465b78421090d86a51021", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NDFiNmE1ZTJjMDZlMzE1ZjNmYzQ2NWI3ODQyMTA5MGQ4NmE1MTAyMQ==", "commit": {"author": {"name": "Kazu Hirata", "email": "kazu@cs.umass.edu", "date": "2005-04-05T01:59:58Z"}, "committer": {"name": "Kazu Hirata", "email": "kazu@gcc.gnu.org", "date": "2005-04-05T01:59:58Z"}, "message": "m68k-protos.h: Add a prototype for valid_dbcc_comparison_p_2.\n\n\t* config/m68k/m68k-protos.h: Add a prototype for\n\tvalid_dbcc_comparison_p_2.\n\t* config/m68k/m68k.c (not_sp_operand, symbolic_operand,\n\textend_operator, const_uint32_operand, const_sint32_operand,\n\tgeneral_src_operand, nonimmediate_src_operand,\n\tmemory_src_operand, post_inc_operand, pre_dec_operand,\n\tpcrel_address): Move to predicates to predicates.md.\n\t* config/m68k/m68k.h (PREDICATE_CODES): Remove.\n\t* config/m68k/m68k.md: Include predicates.md.\n\t* config/m68k/predicates.md: New.\n\nFrom-SVN: r97595", "tree": {"sha": "5a6f48d552c3daa41428a576776c6e55334e0702", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/5a6f48d552c3daa41428a576776c6e55334e0702"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/41b6a5e2c06e315f3fc465b78421090d86a51021", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b6a5e2c06e315f3fc465b78421090d86a51021", "html_url": "https://github.com/Rust-GCC/gccrs/commit/41b6a5e2c06e315f3fc465b78421090d86a51021", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/41b6a5e2c06e315f3fc465b78421090d86a51021/comments", "author": null, "committer": null, "parents": [{"sha": "acaa3bf7a13e5589d1b554c1a13432900ee2d219", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/acaa3bf7a13e5589d1b554c1a13432900ee2d219", "html_url": "https://github.com/Rust-GCC/gccrs/commit/acaa3bf7a13e5589d1b554c1a13432900ee2d219"}], "stats": {"total": 396, "additions": 213, "deletions": 183}, "files": [{"sha": "99b3d1cbedb07196c1f71172d4f8c3489ffde6da", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -1,3 +1,16 @@\n+2005-04-05  Kazu Hirata  <kazu@cs.umass.edu>\n+\n+\t* config/m68k/m68k-protos.h: Add a prototype for\n+\tvalid_dbcc_comparison_p_2.\n+\t* config/m68k/m68k.c (not_sp_operand, symbolic_operand,\n+\textend_operator, const_uint32_operand, const_sint32_operand,\n+\tgeneral_src_operand, nonimmediate_src_operand,\n+\tmemory_src_operand, post_inc_operand, pre_dec_operand,\n+\tpcrel_address): Move to predicates to predicates.md.\n+\t* config/m68k/m68k.h (PREDICATE_CODES): Remove.\n+\t* config/m68k/m68k.md: Include predicates.md.\n+\t* config/m68k/predicates.md: New.\n+\n 2005-04-04  Roger Sayle  <roger@eyesopen.com>\n \n \t* config/i386/i386.md (*truncdfsf2_i387_1): New pattern."}, {"sha": "0f92d0df89f99f98ac41a710f806d9e7012b8aad", "filename": "gcc/config/m68k/m68k-protos.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k-protos.h?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -50,6 +50,7 @@ extern void print_operand_address (FILE *, rtx);\n extern void print_operand (FILE *, rtx, int);\n extern void notice_update_cc (rtx, rtx);\n extern rtx legitimize_pic_address (rtx, enum machine_mode, rtx);\n+extern int valid_dbcc_comparison_p_2 (rtx, enum machine_mode);\n \n #endif /* RTX_CODE */\n "}, {"sha": "7cf87d383c694b3e78bb97e067655eb0f0ebd457", "filename": "gcc/config/m68k/m68k.c", "status": "modified", "additions": 1, "deletions": 164, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.c?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -912,14 +912,6 @@ m68k_output_function_epilogue (FILE *stream, HOST_WIDE_INT size ATTRIBUTE_UNUSED\n     fprintf (stream, \"\\trts\\n\");\n }\n \f\n-/* Similar to general_operand, but exclude stack_pointer_rtx.  */\n-\n-int\n-not_sp_operand (rtx op, enum machine_mode mode)\n-{\n-  return op != stack_pointer_rtx && nonimmediate_operand (op, mode);\n-}\n-\n /* Return true if X is a valid comparison operator for the dbcc \n    instruction.  \n \n@@ -929,7 +921,7 @@ not_sp_operand (rtx op, enum machine_mode mode)\n    It also rejects some comparisons when CC_NO_OVERFLOW is set.  */\n    \n int\n-valid_dbcc_comparison_p (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n+valid_dbcc_comparison_p_2 (rtx x, enum machine_mode mode ATTRIBUTE_UNUSED)\n {\n   switch (GET_CODE (x))\n     {\n@@ -1283,53 +1275,6 @@ output_btst (rtx *operands, rtx countop, rtx dataop, rtx insn, int signpos)\n     }\n   return \"btst %0,%1\";\n }\n-\f\n-/* Returns true if OP is either a symbol reference or a sum of a symbol\n-   reference and a constant.  */\n-\n-int\n-symbolic_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  switch (GET_CODE (op))\n-    {\n-    case SYMBOL_REF:\n-    case LABEL_REF:\n-      return true;\n-\n-    case CONST:\n-      op = XEXP (op, 0);\n-      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n-\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n-\n-#if 0 /* Deleted, with corresponding change in m68k.h,\n-\t so as to fit the specs.  No CONST_DOUBLE is ever symbolic.  */\n-    case CONST_DOUBLE:\n-      return GET_MODE (op) == mode;\n-#endif\n-\n-    default:\n-      return false;\n-    }\n-}\n-\f\n-/* Check for sign_extend or zero_extend.  Used for bit-count operands.  */\n-\n-int\n-extend_operator(rtx x, enum machine_mode mode)\n-{\n-    if (mode != VOIDmode && GET_MODE(x) != mode)\n-\treturn 0;\n-    switch (GET_CODE(x))\n-\t{\n-\tcase SIGN_EXTEND :\n-\tcase ZERO_EXTEND :\n-\t    return 1;\n-\tdefault :\n-\t    return 0;\n-\t}\n-}\n-\n \f\n /* Legitimize PIC addresses.  If the address is already\n    position-independent, we return ORIG.  Newly generated\n@@ -3047,45 +2992,6 @@ strict_low_part_peephole_ok (enum machine_mode mode, rtx first_insn,\n   return false;\n }\n \n-/* Accept integer operands in the range 0..0xffffffff.  We have to check the\n-   range carefully since this predicate is used in DImode contexts.  Also, we\n-   need some extra crud to make it work when hosted on 64-bit machines.  */\n-\n-int\n-const_uint32_operand (rtx op, enum machine_mode mode)\n-{\n-  /* It doesn't make sense to ask this question with a mode that is\n-     not larger than 32 bits.  */\n-  if (GET_MODE_BITSIZE (mode) <= 32)\n-    abort ();\n-\n-#if HOST_BITS_PER_WIDE_INT > 32\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= 0 && INTVAL (op) <= 0xffffffffL));\n-#else\n-  return (GET_CODE (op) == CONST_INT\n-\t  || (GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_HIGH (op) == 0));\n-#endif\n-}\n-\n-/* Accept integer operands in the range -0x80000000..0x7fffffff.  We have\n-   to check the range carefully since this predicate is used in DImode\n-   contexts.  */\n-\n-int\n-const_sint32_operand (rtx op, enum machine_mode mode)\n-{\n-  /* It doesn't make sense to ask this question with a mode that is\n-     not larger than 32 bits.  */\n-  if (GET_MODE_BITSIZE (mode) <= 32)\n-    abort ();\n-\n-  /* All allowed constants will fit a CONST_INT.  */\n-  return (GET_CODE (op) == CONST_INT\n-\t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n-}\n-\n /* Operand predicates for implementing asymmetric pc-relative addressing\n    on m68k.  The m68k supports pc-relative addressing (mode 7, register 2)\n    when used as a source operand, but not as a destination operand.\n@@ -3143,75 +3049,6 @@ const_sint32_operand (rtx op, enum machine_mode mode)\n    ***************************************************************************/\n \n \n-/* Special case of a general operand that's used as a source operand.\n-   Use this to permit reads from PC-relative memory when -mpcrel\n-   is specified.  */\n-\n-int\n-general_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_PCREL\n-      && GET_CODE (op) == MEM\n-      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == CONST))\n-    return 1;\n-  return general_operand (op, mode);\n-}\n-\n-/* Special case of a nonimmediate operand that's used as a source.\n-   Use this to permit reads from PC-relative memory when -mpcrel\n-   is specified.  */\n-\n-int\n-nonimmediate_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_PCREL && GET_CODE (op) == MEM\n-      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == CONST))\n-    return 1;\n-  return nonimmediate_operand (op, mode);\n-}\n-\n-/* Special case of a memory operand that's used as a source.\n-   Use this to permit reads from PC-relative memory when -mpcrel\n-   is specified.  */\n-\n-int\n-memory_src_operand (rtx op, enum machine_mode mode)\n-{\n-  if (TARGET_PCREL && GET_CODE (op) == MEM\n-      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n-\t  || GET_CODE (XEXP (op, 0)) == CONST))\n-    return 1;\n-  return memory_operand (op, mode);\n-}\n-\n-int\n-post_inc_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC;\n-}\n-\n-int\n-pre_dec_operand (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == PRE_DEC;\n-}\n-\n-/* Predicate that accepts only a pc-relative address.  This is needed\n-   because pc-relative addresses don't satisfy the predicate\n-   \"general_src_operand\".  */\n-\n-int\n-pcrel_address (rtx op, enum machine_mode mode ATTRIBUTE_UNUSED)\n-{\n-  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF\n-\t  || GET_CODE (op) == CONST);\n-}\n-\n const char *\n output_andsi3 (rtx *operands)\n {"}, {"sha": "98a6004d5f745090a9d996d806188c121a47bd07", "filename": "gcc/config/m68k/m68k.h", "status": "modified", "additions": 0, "deletions": 19, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.h?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -1260,22 +1260,3 @@ do { if (cc_prev_status.flags & CC_IN_68881)\t\t\t\\\n /* Variables in m68k.c */\n extern const char *m68k_library_id_string;\n extern int m68k_last_compare_had_fp_operands;\n-\n-\f\n-/* Define the codes that are matched by predicates in m68k.c.  */\n-\n-#define PREDICATE_CODES\t\t\t\t\t\t\t\\\n-  {\"general_src_operand\", {CONST_INT, CONST_DOUBLE, CONST, SYMBOL_REF,\t\\\n-\t\t\t   LABEL_REF, SUBREG, REG, MEM}},\t\t\\\n-  {\"nonimmediate_src_operand\", {SUBREG, REG, MEM}},\t\t\t\\\n-  {\"memory_src_operand\", {SUBREG, MEM}},\t\t\t\t\\\n-  {\"not_sp_operand\", {SUBREG, REG, MEM}},\t\t\t\t\\\n-  {\"pcrel_address\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n-  {\"const_uint32_operand\", {CONST_INT, CONST_DOUBLE}},\t\t\t\\\n-  {\"const_sint32_operand\", {CONST_INT}},\t\t\t\t\\\n-  {\"valid_dbcc_comparison_p\", {EQ, NE, GTU, LTU, GEU, LEU,\t\t\\\n-\t\t\t       GT, LT, GE, LE}},\t\t\t\\\n-  {\"extend_operator\", {SIGN_EXTEND, ZERO_EXTEND}},\t\t\t\\\n-  {\"symbolic_operand\", {SYMBOL_REF, LABEL_REF, CONST}},\t\t\t\\\n-  {\"post_inc_operand\", {MEM}},\t\t\t\t\t\t\\\n-  {\"pre_dec_operand\", {MEM}},"}, {"sha": "3cee90c3c6c46b970f006d57eb00342f0f9193e4", "filename": "gcc/config/m68k/m68k.md", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fm68k.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fm68k.md?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -128,6 +128,8 @@\n   [(A0_REG\t\t8)\n    (SP_REG\t\t15)\n   ])\n+\n+(include \"predicates.md\")\n \f\n (define_insn \"\"\n   [(set (match_operand:DF 0 \"push_operand\" \"=m\")"}, {"sha": "183c4e7d5fc368ff19097b55b2b97b831ab58425", "filename": "gcc/config/m68k/predicates.md", "status": "added", "additions": 196, "deletions": 0, "changes": 196, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/41b6a5e2c06e315f3fc465b78421090d86a51021/gcc%2Fconfig%2Fm68k%2Fpredicates.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fm68k%2Fpredicates.md?ref=41b6a5e2c06e315f3fc465b78421090d86a51021", "patch": "@@ -0,0 +1,196 @@\n+;; Predicate definitions for Motorola 68000.\n+;; Copyright (C) 2005 Free Software Foundation, Inc.\n+;;\n+;; This file is part of GCC.\n+;;\n+;; GCC is free software; you can redistribute it and/or modify\n+;; it under the terms of the GNU General Public License as published by\n+;; the Free Software Foundation; either version 2, or (at your option)\n+;; any later version.\n+;;\n+;; GCC is distributed in the hope that it will be useful,\n+;; but WITHOUT ANY WARRANTY; without even the implied warranty of\n+;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+;; GNU General Public License for more details.\n+;;\n+;; You should have received a copy of the GNU General Public License\n+;; along with GCC; see the file COPYING.  If not, write to\n+;; the Free Software Foundation, 59 Temple Place - Suite 330,\n+;; Boston, MA 02111-1307, USA.\n+\n+;; Special case of a general operand that's used as a source\n+;; operand. Use this to permit reads from PC-relative memory when\n+;; -mpcrel is specified.\n+\n+(define_predicate \"general_src_operand\"\n+  (match_code \"const_int,const_double,const,symbol_ref,label_ref,subreg,reg,mem\")\n+{\n+  if (TARGET_PCREL\n+      && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return general_operand (op, mode);\n+})\n+\n+;; Special case of a nonimmediate operand that's used as a source. Use\n+;; this to permit reads from PC-relative memory when -mpcrel is\n+;; specified.\n+\n+(define_predicate \"nonimmediate_src_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  if (TARGET_PCREL && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return nonimmediate_operand (op, mode);\n+})\n+\n+;; Special case of a memory operand that's used as a source. Use this\n+;; to permit reads from PC-relative memory when -mpcrel is specified.\n+\n+(define_predicate \"memory_src_operand\"\n+  (match_code \"subreg,mem\")\n+{\n+  if (TARGET_PCREL && GET_CODE (op) == MEM\n+      && (GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == LABEL_REF\n+\t  || GET_CODE (XEXP (op, 0)) == CONST))\n+    return 1;\n+  return memory_operand (op, mode);\n+})\n+\n+;; Similar to general_operand, but exclude stack_pointer_rtx.\n+\n+(define_predicate \"not_sp_operand\"\n+  (match_code \"subreg,reg,mem\")\n+{\n+  return op != stack_pointer_rtx && nonimmediate_operand (op, mode);\n+})\n+\n+;; Predicate that accepts only a pc-relative address.  This is needed\n+;; because pc-relative addresses don't satisfy the predicate\n+;; \"general_src_operand\".\n+\n+(define_predicate \"pcrel_address\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  return (GET_CODE (op) == SYMBOL_REF || GET_CODE (op) == LABEL_REF\n+\t  || GET_CODE (op) == CONST);\n+})\n+\n+;; Accept integer operands in the range 0..0xffffffff.  We have to\n+;; check the range carefully since this predicate is used in DImode\n+;; contexts.  Also, we need some extra crud to make it work when\n+;; hosted on 64-bit machines.\n+\n+(define_predicate \"const_uint32_operand\"\n+  (match_code \"const_int,const_double\")\n+{\n+  /* It doesn't make sense to ask this question with a mode that is\n+     not larger than 32 bits.  */\n+  if (GET_MODE_BITSIZE (mode) <= 32)\n+    abort ();\n+\n+#if HOST_BITS_PER_WIDE_INT > 32\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= 0 && INTVAL (op) <= 0xffffffffL));\n+#else\n+  return (GET_CODE (op) == CONST_INT\n+\t  || (GET_CODE (op) == CONST_DOUBLE && CONST_DOUBLE_HIGH (op) == 0));\n+#endif\n+})\n+\n+;; Accept integer operands in the range -0x80000000..0x7fffffff.  We\n+;; have to check the range carefully since this predicate is used in\n+;; DImode contexts.\n+\n+(define_predicate \"const_sint32_operand\"\n+  (match_code \"const_int\")\n+{\n+  /* It doesn't make sense to ask this question with a mode that is\n+     not larger than 32 bits.  */\n+  if (GET_MODE_BITSIZE (mode) <= 32)\n+    abort ();\n+\n+  /* All allowed constants will fit a CONST_INT.  */\n+  return (GET_CODE (op) == CONST_INT\n+\t  && (INTVAL (op) >= (-0x7fffffff - 1) && INTVAL (op) <= 0x7fffffff));\n+})\n+\n+;; Return true if X is a valid comparison operator for the dbcc\n+;; instruction.  Note it rejects floating point comparison\n+;; operators. (In the future we could use Fdbcc).  It also rejects\n+;; some comparisons when CC_NO_OVERFLOW is set.\n+\n+(define_predicate \"valid_dbcc_comparison_p\"\n+  (match_code \"eq,ne,gtu,ltu,geu,leu,gt,lt,ge,le\")\n+{\n+  return valid_dbcc_comparison_p_2 (op, mode);\n+})\n+\n+;; Check for sign_extend or zero_extend.  Used for bit-count operands.\n+\n+(define_predicate \"extend_operator\"\n+  (match_code \"sign_extend,zero_extend\")\n+{\n+  if (mode != VOIDmode && GET_MODE (op) != mode)\n+    return 0;\n+  switch (GET_CODE (op))\n+    {\n+    case SIGN_EXTEND:\n+    case ZERO_EXTEND:\n+      return 1;\n+    default:\n+      return 0;\n+    }\n+})\n+\n+;; Returns true if OP is either a symbol reference or a sum of a\n+;; symbol reference and a constant.\n+\n+(define_predicate \"symbolic_operand\"\n+  (match_code \"symbol_ref,label_ref,const\")\n+{\n+  switch (GET_CODE (op))\n+    {\n+    case SYMBOL_REF:\n+    case LABEL_REF:\n+      return true;\n+\n+    case CONST:\n+      op = XEXP (op, 0);\n+      return ((GET_CODE (XEXP (op, 0)) == SYMBOL_REF\n+\t       || GET_CODE (XEXP (op, 0)) == LABEL_REF)\n+\t      && GET_CODE (XEXP (op, 1)) == CONST_INT);\n+\n+#if 0 /* Deleted, with corresponding change in m68k.h,\n+\t so as to fit the specs.  No CONST_DOUBLE is ever symbolic.  */\n+    case CONST_DOUBLE:\n+      return GET_MODE (op) == mode;\n+#endif\n+\n+    default:\n+      return false;\n+    }\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"post_inc_operand\"\n+  (match_code \"mem\")\n+{\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == POST_INC;\n+})\n+\n+;; TODO: Add a comment here.\n+\n+(define_predicate \"pre_dec_operand\"\n+  (match_code \"mem\")\n+{\n+  return MEM_P (op) && GET_CODE (XEXP (op, 0)) == PRE_DEC;\n+})"}]}