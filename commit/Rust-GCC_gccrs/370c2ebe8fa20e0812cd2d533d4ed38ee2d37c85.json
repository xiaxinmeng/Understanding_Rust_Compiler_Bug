{"sha": "370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MzcwYzJlYmU4ZmEyMGUwODEyY2QyZDUzM2Q0ZWQzOGVlMmQzN2M4NQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@arm.com", "date": "2018-07-03T09:59:37Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2018-07-03T09:59:37Z"}, "message": "[14/n] PR85694: Rework overwidening detection\n\nThis patch is the main part of PR85694.  The aim is to recognise at least:\n\n  signed char *a, *b, *c;\n  ...\n  for (int i = 0; i < 2048; i++)\n    c[i] = (a[i] + b[i]) >> 1;\n\nas an over-widening pattern, since the addition and shift can be done\non shorts rather than ints.  However, it ended up being a lot more\ngeneral than that.\n\nThe current over-widening pattern detection is limited to a few simple\ncases: logical ops with immediate second operands, and shifts by a\nconstant.  These cases are enough for common pixel-format conversion\nand can be detected in a peephole way.\n\nThe loop above requires two generalisations of the current code: support\nfor addition as well as logical ops, and support for non-constant second\noperands.  These are harder to detect in the same peephole way, so the\npatch tries to take a more global approach.\n\nThe idea is to get information about the minimum operation width\nin two ways:\n\n(1) by using the range information attached to the SSA_NAMEs\n    (effectively a forward walk, since the range info is\n    context-independent).\n\n(2) by back-propagating the number of output bits required by\n    users of the result.\n\nAs explained in the comments, there's a balance to be struck between\nnarrowing an individual operation and fitting in with the surrounding\ncode.  The approach is pretty conservative: if we could narrow an\noperation to N bits without changing its semantics, it's OK to do that if:\n\n- no operations later in the chain require more than N bits; or\n\n- all internally-defined inputs are extended from N bits or fewer,\n  and at least one of them is single-use.\n\nSee the comments for the rationale.\n\nI didn't bother adding STMT_VINFO_* wrappers for the new fields\nsince the code seemed more readable without.\n\n2018-06-20  Richard Sandiford  <richard.sandiford@arm.com>\n\ngcc/\n\t* poly-int.h (print_hex): New function.\n\t* dumpfile.h (dump_dec, dump_hex): Declare.\n\t* dumpfile.c (dump_dec, dump_hex): New poly_wide_int functions.\n\t* tree-vectorizer.h (_stmt_vec_info): Add min_output_precision,\n\tmin_input_precision, operation_precision and operation_sign.\n\t* tree-vect-patterns.c (vect_get_range_info): New function.\n\t(vect_same_loop_or_bb_p, vect_single_imm_use)\n\t(vect_operation_fits_smaller_type): Delete.\n\t(vect_look_through_possible_promotion): Add an optional\n\tsingle_use_p parameter.\n\t(vect_recog_over_widening_pattern): Rewrite to use new\n\tstmt_vec_info infomration.  Handle one operation at a time.\n\t(vect_recog_cast_forwprop_pattern, vect_narrowable_type_p)\n\t(vect_truncatable_operation_p, vect_set_operation_type)\n\t(vect_set_min_input_precision): New functions.\n\t(vect_determine_min_output_precision_1): Likewise.\n\t(vect_determine_min_output_precision): Likewise.\n\t(vect_determine_precisions_from_range): Likewise.\n\t(vect_determine_precisions_from_users): Likewise.\n\t(vect_determine_stmt_precisions, vect_determine_precisions): Likewise.\n\t(vect_vect_recog_func_ptrs): Put over_widening first.\n\tAdd cast_forwprop.\n\t(vect_pattern_recog): Call vect_determine_precisions.\n\ngcc/testsuite/\n\t* gcc.dg/vect/vect-widen-mult-u8-u32.c: Check specifically for a\n\twiden_mult pattern.\n\t* gcc.dg/vect/vect-over-widen-1.c: Update the scan tests for new\n\tover-widening messages.\n\t* gcc.dg/vect/vect-over-widen-1-big-array.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-2.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-2-big-array.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-3.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-3-big-array.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-4.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-4-big-array.c: Likewise.\n\t* gcc.dg/vect/bb-slp-over-widen-1.c: New test.\n\t* gcc.dg/vect/bb-slp-over-widen-2.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-5.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-6.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-7.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-8.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-9.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-10.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-11.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-12.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-13.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-14.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-15.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-16.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-17.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-18.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-19.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-20.c: Likewise.\n\t* gcc.dg/vect/vect-over-widen-21.c: Likewise.\n\nFrom-SVN: r262333", "tree": {"sha": "702c8f6f9f77e7b73d3ebba7dd792e61301526e6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/702c8f6f9f77e7b73d3ebba7dd792e61301526e6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "html_url": "https://github.com/Rust-GCC/gccrs/commit/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/comments", "author": {"login": "rsandifo-arm", "id": 28043039, "node_id": "MDQ6VXNlcjI4MDQzMDM5", "avatar_url": "https://avatars.githubusercontent.com/u/28043039?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo-arm", "html_url": "https://github.com/rsandifo-arm", "followers_url": "https://api.github.com/users/rsandifo-arm/followers", "following_url": "https://api.github.com/users/rsandifo-arm/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo-arm/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo-arm/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo-arm/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo-arm/orgs", "repos_url": "https://api.github.com/users/rsandifo-arm/repos", "events_url": "https://api.github.com/users/rsandifo-arm/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo-arm/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3239dde94019f11e6c1a8c6ae2b3f7d944689148", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3239dde94019f11e6c1a8c6ae2b3f7d944689148", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3239dde94019f11e6c1a8c6ae2b3f7d944689148"}], "stats": {"total": 2034, "additions": 1672, "deletions": 362}, "files": [{"sha": "ab97a84fb0bbc65b82a7bc0f46b81663213ae7bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -1,3 +1,29 @@\n+2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* poly-int.h (print_hex): New function.\n+\t* dumpfile.h (dump_dec, dump_hex): Declare.\n+\t* dumpfile.c (dump_dec, dump_hex): New poly_wide_int functions.\n+\t* tree-vectorizer.h (_stmt_vec_info): Add min_output_precision,\n+\tmin_input_precision, operation_precision and operation_sign.\n+\t* tree-vect-patterns.c (vect_get_range_info): New function.\n+\t(vect_same_loop_or_bb_p, vect_single_imm_use)\n+\t(vect_operation_fits_smaller_type): Delete.\n+\t(vect_look_through_possible_promotion): Add an optional\n+\tsingle_use_p parameter.\n+\t(vect_recog_over_widening_pattern): Rewrite to use new\n+\tstmt_vec_info infomration.  Handle one operation at a time.\n+\t(vect_recog_cast_forwprop_pattern, vect_narrowable_type_p)\n+\t(vect_truncatable_operation_p, vect_set_operation_type)\n+\t(vect_set_min_input_precision): New functions.\n+\t(vect_determine_min_output_precision_1): Likewise.\n+\t(vect_determine_min_output_precision): Likewise.\n+\t(vect_determine_precisions_from_range): Likewise.\n+\t(vect_determine_precisions_from_users): Likewise.\n+\t(vect_determine_stmt_precisions, vect_determine_precisions): Likewise.\n+\t(vect_vect_recog_func_ptrs): Put over_widening first.\n+\tAdd cast_forwprop.\n+\t(vect_pattern_recog): Call vect_determine_precisions.\n+\n 2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* tree-vect-patterns.c (vect_mark_pattern_stmts): Remove pattern"}, {"sha": "7ed17960db09aed1a757ab549597356469b101e6", "filename": "gcc/dumpfile.c", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fdumpfile.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fdumpfile.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -633,6 +633,28 @@ template void dump_dec (dump_flags_t, const poly_uint64 &);\n template void dump_dec (dump_flags_t, const poly_offset_int &);\n template void dump_dec (dump_flags_t, const poly_widest_int &);\n \n+void\n+dump_dec (dump_flags_t dump_kind, const poly_wide_int &value, signop sgn)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    print_dec (value, dump_file, sgn);\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    print_dec (value, alt_dump_file, sgn);\n+}\n+\n+/* Output VALUE in hexadecimal to appropriate dump streams.  */\n+\n+void\n+dump_hex (dump_flags_t dump_kind, const poly_wide_int &value)\n+{\n+  if (dump_file && (dump_kind & pflags))\n+    print_hex (value, dump_file);\n+\n+  if (alt_dump_file && (dump_kind & alt_flags))\n+    print_hex (value, alt_dump_file);\n+}\n+\n /* The current dump scope-nesting depth.  */\n \n static int dump_scope_depth;"}, {"sha": "4a71ef70d244cee26baa0575f3033ec112d8af35", "filename": "gcc/dumpfile.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fdumpfile.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fdumpfile.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdumpfile.h?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -439,6 +439,8 @@ extern bool enable_rtl_dump_file (void);\n \n template<unsigned int N, typename C>\n void dump_dec (dump_flags_t, const poly_int<N, C> &);\n+extern void dump_dec (dump_flags_t, const poly_wide_int &, signop);\n+extern void dump_hex (dump_flags_t, const poly_wide_int &);\n \n /* In tree-dump.c  */\n extern void dump_node (const_tree, dump_flags_t, FILE *);"}, {"sha": "b3b61e25e649896e73ff09eeb03284df7277f7be", "filename": "gcc/poly-int.h", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fpoly-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Fpoly-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fpoly-int.h?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -2420,6 +2420,25 @@ print_dec (const poly_int_pod<N, C> &value, FILE *file)\n \t     poly_coeff_traits<C>::signedness ? SIGNED : UNSIGNED);\n }\n \n+/* Use print_hex to print VALUE to FILE.  */\n+\n+template<unsigned int N, typename C>\n+void\n+print_hex (const poly_int_pod<N, C> &value, FILE *file)\n+{\n+  if (value.is_constant ())\n+    print_hex (value.coeffs[0], file);\n+  else\n+    {\n+      fprintf (file, \"[\");\n+      for (unsigned int i = 0; i < N; ++i)\n+\t{\n+\t  print_hex (value.coeffs[i], file);\n+\t  fputc (i == N - 1 ? ']' : ',', file);\n+\t}\n+    }\n+}\n+\n /* Helper for calculating the distance between two points P1 and P2,\n    in cases where known_le (P1, P2).  T1 and T2 are the types of the\n    two positions, in either order.  The coefficients of P2 - P1 have"}, {"sha": "0028d4f88ace6cbfb2b3b99627e4e224659dab72", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -1,3 +1,36 @@\n+2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n+\n+\t* gcc.dg/vect/vect-widen-mult-u8-u32.c: Check specifically for a\n+\twiden_mult pattern.\n+\t* gcc.dg/vect/vect-over-widen-1.c: Update the scan tests for new\n+\tover-widening messages.\n+\t* gcc.dg/vect/vect-over-widen-1-big-array.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-2.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-2-big-array.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-3.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-3-big-array.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-4.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-4-big-array.c: Likewise.\n+\t* gcc.dg/vect/bb-slp-over-widen-1.c: New test.\n+\t* gcc.dg/vect/bb-slp-over-widen-2.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-5.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-6.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-7.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-8.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-9.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-10.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-11.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-12.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-13.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-14.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-15.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-16.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-17.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-18.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-19.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-20.c: Likewise.\n+\t* gcc.dg/vect/vect-over-widen-21.c: Likewise.\n+\n 2018-07-03  Richard Sandiford  <richard.sandiford@arm.com>\n \n \t* gcc.dg/vect/vect-mixed-size-cond-1.c: New test."}, {"sha": "60e7b7929014b0997c2e16e11da150917499326c", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-1.c", "status": "added", "additions": 66, "deletions": 0, "changes": 66, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-1.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,66 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Deliberate use of signed >>.  */\n+#define DEF_LOOP(SIGNEDNESS)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\\\n+  f_##SIGNEDNESS (SIGNEDNESS char *restrict a,\t\\\n+\t\t  SIGNEDNESS char *restrict b,\t\\\n+\t\t  SIGNEDNESS char *restrict c)\t\\\n+  {\t\t\t\t\t\t\\\n+    a[0] = (b[0] + c[0]) >> 1;\t\t\t\\\n+    a[1] = (b[1] + c[1]) >> 1;\t\t\t\\\n+    a[2] = (b[2] + c[2]) >> 1;\t\t\t\\\n+    a[3] = (b[3] + c[3]) >> 1;\t\t\t\\\n+    a[4] = (b[4] + c[4]) >> 1;\t\t\t\\\n+    a[5] = (b[5] + c[5]) >> 1;\t\t\t\\\n+    a[6] = (b[6] + c[6]) >> 1;\t\t\t\\\n+    a[7] = (b[7] + c[7]) >> 1;\t\t\t\\\n+    a[8] = (b[8] + c[8]) >> 1;\t\t\t\\\n+    a[9] = (b[9] + c[9]) >> 1;\t\t\t\\\n+    a[10] = (b[10] + c[10]) >> 1;\t\t\\\n+    a[11] = (b[11] + c[11]) >> 1;\t\t\\\n+    a[12] = (b[12] + c[12]) >> 1;\t\t\\\n+    a[13] = (b[13] + c[13]) >> 1;\t\t\\\n+    a[14] = (b[14] + c[14]) >> 1;\t\t\\\n+    a[15] = (b[15] + c[15]) >> 1;\t\t\\\n+  }\n+\n+DEF_LOOP (signed)\n+DEF_LOOP (unsigned)\n+\n+#define N 16\n+\n+#define TEST_LOOP(SIGNEDNESS, BASE_B, BASE_C)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    SIGNEDNESS char a[N], b[N], c[N];\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = BASE_B + i * 15;\t\t\t\t\\\n+\tc[i] = BASE_C + i * 14;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##SIGNEDNESS (a, b, c);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      if (a[i] != (BASE_B + BASE_C + i * 29) >> 1)\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  TEST_LOOP (signed, -128, -120);\n+  TEST_LOOP (unsigned, 4, 10);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"demoting int to signed short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump \"demoting int to unsigned short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"vect\" } } */"}, {"sha": "b26317cbe19bf81c11aac520abf2469aabf859c7", "filename": "gcc/testsuite/gcc.dg/vect/bb-slp-over-widen-2.c", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fbb-slp-over-widen-2.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,65 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+/* Deliberate use of signed >>.  */\n+#define DEF_LOOP(SIGNEDNESS)\t\t\t\\\n+  void __attribute__ ((noipa))\t\t\t\\\n+  f_##SIGNEDNESS (SIGNEDNESS char *restrict a,\t\\\n+\t\t  SIGNEDNESS char *restrict b,\t\\\n+\t\t  SIGNEDNESS char c)\t\t\\\n+  {\t\t\t\t\t\t\\\n+    a[0] = (b[0] + c) >> 1;\t\t\t\\\n+    a[1] = (b[1] + c) >> 1;\t\t\t\\\n+    a[2] = (b[2] + c) >> 1;\t\t\t\\\n+    a[3] = (b[3] + c) >> 1;\t\t\t\\\n+    a[4] = (b[4] + c) >> 1;\t\t\t\\\n+    a[5] = (b[5] + c) >> 1;\t\t\t\\\n+    a[6] = (b[6] + c) >> 1;\t\t\t\\\n+    a[7] = (b[7] + c) >> 1;\t\t\t\\\n+    a[8] = (b[8] + c) >> 1;\t\t\t\\\n+    a[9] = (b[9] + c) >> 1;\t\t\t\\\n+    a[10] = (b[10] + c) >> 1;\t\t\t\\\n+    a[11] = (b[11] + c) >> 1;\t\t\t\\\n+    a[12] = (b[12] + c) >> 1;\t\t\t\\\n+    a[13] = (b[13] + c) >> 1;\t\t\t\\\n+    a[14] = (b[14] + c) >> 1;\t\t\t\\\n+    a[15] = (b[15] + c) >> 1;\t\t\t\\\n+  }\n+\n+DEF_LOOP (signed)\n+DEF_LOOP (unsigned)\n+\n+#define N 16\n+\n+#define TEST_LOOP(SIGNEDNESS, BASE_B, C)\t\t\\\n+  {\t\t\t\t\t\t\t\\\n+    SIGNEDNESS char a[N], b[N], c[N];\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      {\t\t\t\t\t\t\t\\\n+\tb[i] = BASE_B + i * 15;\t\t\t\t\\\n+\tasm volatile (\"\" ::: \"memory\");\t\t\t\\\n+      }\t\t\t\t\t\t\t\\\n+    f_##SIGNEDNESS (a, b, C);\t\t\t\t\\\n+    for (int i = 0; i < N; ++i)\t\t\t\t\\\n+      if (a[i] != (BASE_B + C + i * 15) >> 1)\t\t\\\n+\t__builtin_abort ();\t\t\t\t\\\n+  }\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  TEST_LOOP (signed, -128, -120);\n+  TEST_LOOP (unsigned, 4, 250);\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump \"demoting int to signed short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump \"demoting int to unsigned short\" \"slp2\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump-times \"basic block vectorized\" 2 \"vect\" } } */"}, {"sha": "9e5f464a88f5f1f0a09baa5d805f940cc360217f", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-1-big-array.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1-big-array.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -58,7 +58,9 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "c2d07974dfb85d55ca2fb6f493dadf2fda060b4f", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-1.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-1.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -62,8 +62,9 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 8 \"vect\" { target vect_sizes_32B_16B } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "394a5a19e0d59fb7ca054ecd64ac909f645dd61d", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-10.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-10.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-10.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-10.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+#endif\n+\n+#include \"vect-over-widen-9.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(unsigned char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "97ab57f12c439169cee9ea8153a33a1e89c97e70", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-11.c", "status": "added", "additions": 63, "deletions": 0, "changes": 63, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-11.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-11.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-11.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,63 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -100\n+#endif\n+\n+#define N 50\n+\n+/* Both range analysis and backward propagation from the truncation show\n+   that these calculations can be done in SIGNEDNESS short, with \"res\"\n+   being extended for the store to d[i].  */\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS char *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c, int *restrict d)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      /* Deliberate use of signed >>.  */\n+      int res = b[i] + c[i];\n+      a[i] = (res + (res >> 1)) >> 2;\n+      d[i] = res;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS char a[N], b[N], c[N];\n+  int d[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, d);\n+  for (int i = 0; i < N; ++i)\n+    {\n+      int res = BASE_B + BASE_C + i * 9;\n+      if (a[i] != ((res + (res >> 1)) >> 2))\n+\t__builtin_abort ();\n+      if (d[i] != res)\n+\t__builtin_abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(signed char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "0d5473ea1668b301f8ca56c37dfe422d82532862", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-12.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-12.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-12.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-12.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+#endif\n+\n+#include \"vect-over-widen-11.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(unsigned char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "b89ed8bf4a7d2edeada5a7681bc9f8d988651132", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-13.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-13.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-13.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-13.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -120\n+#endif\n+\n+#define N 50\n+\n+/* We rely on range analysis to show that these calculations can be done\n+   in SIGNEDNESS short.  */\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS char *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[i] = (b[i] + c[i]) / 2;\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS char a[N], b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (BASE_B + BASE_C + i * 9) / 2)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* / 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* = \\(signed char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "7b5ba2311a071add5b62f21398929a25488b149d", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-14.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-14.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+#endif\n+\n+#include \"vect-over-widen-13.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* = \\(unsigned char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "e898e87fd0bc46f32b726669deb110640ab47eef", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-15.c", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-15.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-15.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-15.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,52 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -120\n+#endif\n+\n+#define N 50\n+\n+/* We rely on range analysis to show that these calculations can be done\n+   in SIGNEDNESS short, with the result being extended to int for the\n+   store.  */\n+void __attribute__ ((noipa))\n+f (int *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c)\n+{\n+  for (int i = 0; i < N; ++i)\n+    a[i] = (b[i] + c[i]) / 2;\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  int a[N];\n+  SIGNEDNESS char b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (BASE_B + BASE_C + i * 9) / 2)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* / 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vect_recog_cast_forwprop_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "04293454d32b0049a9d2e0e87883fe965b6fd2d1", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-16.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-16.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-16.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-16.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+#endif\n+\n+#include \"vect-over-widen-15.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vect_recog_cast_forwprop_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "04482607b04b44a1fcee6ac7a80fea18ed37c913", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-17.c", "status": "added", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-17.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-17.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-17.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,46 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+\n+/* This should not be treated as an over-widening pattern, even though\n+   \"(b[i] & 0xef) | 0x80)\" could be done in unsigned chars.  */\n+\n+void __attribute__ ((noipa))\n+f (unsigned short *restrict a, unsigned short *restrict b)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      unsigned short foo = ((b[i] & 0xef) | 0x80) + (a[i] << 4);\n+      a[i] = foo;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  unsigned short a[N], b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = i * 3;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != ((((i * 3) & 0xef) | 0x80) + (i << 4)))\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {vect_recog_over_widening_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^\\n]*char} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "ecb74d7793eeaa80b0d48479b2be6c68e64c61b0", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-18.c", "status": "added", "additions": 50, "deletions": 0, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-18.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-18.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-18.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,50 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 1024\n+\n+/* This should be treated as an over-widening pattern: we can truncate\n+   b to unsigned char after loading it and do all the computation in\n+   unsigned char.  */\n+\n+void __attribute__ ((noipa))\n+f (unsigned char *restrict a, unsigned short *restrict b)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      unsigned short foo = ((b[i] & 0xef) | 0x80) + (a[i] << 4);\n+      a[i] = foo;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  unsigned char a[N];\n+  unsigned short b[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      a[i] = i;\n+      b[i] = i * 3;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (unsigned char) ((((i * 3) & 0xef) | 0x80) + (i << 4)))\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* &} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* |} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* <<} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vector[^\\n]*char} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "11546fe1a502a02c750ea955f483bc3a8b3a0ac7", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-19.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-19.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-19.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-19.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 111\n+\n+/* This shouldn't be treated as an over-widening operation: it's better\n+   to reuse the extensions of di and ei for di + ei than to add them\n+   as shorts and introduce a third extension.  */\n+\n+void __attribute__ ((noipa))\n+f (unsigned int *restrict a, unsigned int *restrict b,\n+   unsigned int *restrict c, unsigned char *restrict d,\n+   unsigned char *restrict e)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      unsigned int di = d[i];\n+      unsigned int ei = e[i];\n+      a[i] = di;\n+      b[i] = ei;\n+      c[i] = di + ei;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  unsigned int a[N], b[N], c[N];\n+  unsigned char d[N], e[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      d[i] = i * 2 + 3;\n+      e[i] = i + 100;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, d, e);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != i * 2 + 3\n+\t|| b[i] != i + 100\n+\t|| c[i] != i * 3 + 103)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {vect_recog_over_widening_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "82aec9f26517b2e00568f3240ff88d954af29bea", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-2-big-array.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2-big-array.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -57,7 +57,12 @@ int main (void)\n   return 0;\n }\n \n-/* Final value stays in int, so no over-widening is detected at the moment.  */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 0 \"vect\" } } */\n+/* This is an over-widening even though the final result is still an int.\n+   It's better to do one vector of ops on chars and then widen than to\n+   widen and then do 4 vectors of ops on ints.  */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "0bcbd4f1b5315ec84e4aa3bd92e058b6ca9ea0ec", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-2.c", "status": "modified", "additions": 7, "deletions": 2, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-2.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -57,7 +57,12 @@ int main (void)\n   return 0;\n }\n \n-/* Final value stays in int, so no over-widening is detected at the moment.  */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 0 \"vect\" } } */\n+/* This is an over-widening even though the final result is still an int.\n+   It's better to do one vector of ops on chars and then widen than to\n+   widen and then do 4 vectors of ops on ints.  */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "47f970d231ee61c74c7c4d5b3f9e9bab0673cfe2", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-20.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-20.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-20.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-20.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 111\n+\n+/* This shouldn't be treated as an over-widening operation: it's better\n+   to reuse the extensions of di and ei for di + ei than to add them\n+   as shorts and introduce a third extension.  */\n+\n+void __attribute__ ((noipa))\n+f (unsigned int *restrict a, unsigned int *restrict b,\n+   unsigned int *restrict c, unsigned char *restrict d,\n+   unsigned char *restrict e)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      int di = d[i];\n+      int ei = e[i];\n+      a[i] = di;\n+      b[i] = ei;\n+      c[i] = di + ei;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  unsigned int a[N], b[N], c[N];\n+  unsigned char d[N], e[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      d[i] = i * 2 + 3;\n+      e[i] = i + 100;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, d, e);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != i * 2 + 3\n+\t|| b[i] != i + 100\n+\t|| c[i] != i * 3 + 103)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {vect_recog_over_widening_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "6e13f260f1124ef221bae41b31f8f52ae35162d3", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-21.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-21.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-21.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-21.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#define N 111\n+\n+/* This shouldn't be treated as an over-widening operation: it's better\n+   to reuse the extensions of di and ei for di + ei than to add them\n+   as shorts and introduce a third extension.  */\n+\n+void __attribute__ ((noipa))\n+f (unsigned int *restrict a, unsigned int *restrict b,\n+   unsigned int *restrict c, unsigned char *restrict d,\n+   unsigned char *restrict e)\n+{\n+  for (__INTPTR_TYPE__ i = 0; i < N; ++i)\n+    {\n+      a[i] = d[i];\n+      b[i] = e[i];\n+      c[i] = d[i] + e[i];\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  unsigned int a[N], b[N], c[N];\n+  unsigned char d[N], e[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      d[i] = i * 2 + 3;\n+      e[i] = i + 100;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, d, e);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != i * 2 + 3\n+\t|| b[i] != i + 100\n+\t|| c[i] != i * 3 + 103)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump-not {vect_recog_over_widening_pattern: detected} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "37da7c917e4d79316b56f782c873db7f0ffef76a", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-3-big-array.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3-big-array.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -59,7 +59,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target { ! vect_widen_shift } } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 1 \"vect\" { target vect_widen_shift } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 9} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "41384807a45a4028f84a4f40486b834022ca54e6", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-3.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-3.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -57,6 +57,9 @@ int main (void)\n   return 0;\n }\n \n-/* { dg-final { scan-tree-dump \"vect_recog_over_widening_pattern: detected\" \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 9} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "514337c579cf777a6dd4d8b04f0ff5e963ba3c1f", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-4-big-array.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4-big-array.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -62,7 +62,9 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { ! vect_widen_shift } } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "3d536d5ddcc14cfd67c141c144a1d686edace976", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-4.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-4.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -66,8 +66,9 @@ int main (void)\n }\n \n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_shift_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 2 \"vect\" { target vect_widen_shift } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 4 \"vect\" { target { { ! vect_sizes_32B_16B } && { ! vect_widen_shift } } } } } */\n-/* { dg-final { scan-tree-dump-times \"vect_recog_over_widening_pattern: detected\" 8 \"vect\" { target vect_sizes_32B_16B } } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 3} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* << 8} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 5} \"vect\" } } */\n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" } } */\n "}, {"sha": "56d2396e394079861a906ff2ea1db81f2f01a7af", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-5.c", "status": "added", "additions": 51, "deletions": 0, "changes": 51, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-5.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,51 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -100\n+#endif\n+\n+#define N 50\n+\n+/* Both range analysis and backward propagation from the truncation show\n+   that these calculations can be done in SIGNEDNESS short.  */\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS char *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c)\n+{\n+  /* Deliberate use of signed >>.  */\n+  for (int i = 0; i < N; ++i)\n+    a[i] = (b[i] + c[i]) >> 1;\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS char a[N], b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (BASE_B + BASE_C + i * 9) >> 1)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(signed char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "9fe0e056cc4ea6b1c60cde56ada4ce98bb3b1b7e", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-6.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-6.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+\n+#include \"vect-over-widen-5.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(unsigned char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "a8166b385056fedb3a2f22283669fcbdc30eb9b2", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-7.c", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-7.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-7.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-7.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,53 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -100\n+#define D -120\n+#endif\n+\n+#define N 50\n+\n+/* Both range analysis and backward propagation from the truncation show\n+   that these calculations can be done in SIGNEDNESS short.  */\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS char *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c, SIGNEDNESS char d)\n+{\n+  int promoted_d = d;\n+  for (int i = 0; i < N; ++i)\n+    /* Deliberate use of signed >>.  */\n+    a[i] = (b[i] + c[i] + promoted_d) >> 2;\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS char a[N], b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c, D);\n+  for (int i = 0; i < N; ++i)\n+    if (a[i] != (BASE_B + BASE_C + D + i * 9) >> 2)\n+      __builtin_abort ();\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(signed char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "238f577adea9658667864d45a7d2fcd339fdecf8", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-8.c", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-8.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-8.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-8.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,19 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS unsigned\n+#define BASE_B 4\n+#define BASE_C 40\n+#define D 251\n+#endif\n+\n+#include \"vect-over-widen-7.c\"\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(unsigned char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "a50f8198bfd53677b0b019153efc3cb358786484", "filename": "gcc/testsuite/gcc.dg/vect/vect-over-widen-9.c", "status": "added", "additions": 58, "deletions": 0, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-9.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-9.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-over-widen-9.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -0,0 +1,58 @@\n+/* { dg-require-effective-target vect_int } */\n+/* { dg-require-effective-target vect_shift } */\n+/* { dg-require-effective-target vect_pack_trunc } */\n+/* { dg-require-effective-target vect_unpack } */\n+\n+#include \"tree-vect.h\"\n+\n+#ifndef SIGNEDNESS\n+#define SIGNEDNESS signed\n+#define BASE_B -128\n+#define BASE_C -100\n+#endif\n+\n+#define N 50\n+\n+/* Both range analysis and backward propagation from the truncation show\n+   that these calculations can be done in SIGNEDNESS short.  */\n+void __attribute__ ((noipa))\n+f (SIGNEDNESS char *restrict a, SIGNEDNESS char *restrict b,\n+   SIGNEDNESS char *restrict c)\n+{\n+  for (int i = 0; i < N; ++i)\n+    {\n+      /* Deliberate use of signed >>.  */\n+      int res = b[i] + c[i];\n+      a[i] = (res + (res >> 1)) >> 2;\n+    }\n+}\n+\n+int\n+main (void)\n+{\n+  check_vect ();\n+\n+  SIGNEDNESS char a[N], b[N], c[N];\n+  for (int i = 0; i < N; ++i)\n+    {\n+      b[i] = BASE_B + i * 5;\n+      c[i] = BASE_C + i * 4;\n+      asm volatile (\"\" ::: \"memory\");\n+    }\n+  f (a, b, c);\n+  for (int i = 0; i < N; ++i)\n+    {\n+      int res = BASE_B + BASE_C + i * 9;\n+      if (a[i] != ((res + (res >> 1)) >> 2))\n+\t__builtin_abort ();\n+    }\n+\n+  return 0;\n+}\n+\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* \\+ } \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 1} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_over_widening_pattern: detected:[^\\n]* >> 2} \"vect\" } } */\n+/* { dg-final { scan-tree-dump {vect_recog_cast_forwprop_pattern: detected:[^\\n]* \\(signed char\\)} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-not {vector[^ ]* int} \"vect\" } } */\n+/* { dg-final { scan-tree-dump-times \"vectorized 1 loop\" 1 \"vect\" } } */"}, {"sha": "f38859aa7b57b962cfda03fd00164fb741646077", "filename": "gcc/testsuite/gcc.dg/vect/vect-widen-mult-u8-u32.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fvect%2Fvect-widen-mult-u8-u32.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -43,5 +43,5 @@ int main (void)\n \n /* { dg-final { scan-tree-dump-times \"vectorized 1 loops\" 1 \"vect\" { target { vect_widen_mult_qi_to_hi || vect_unpack } } } } */\n /* { dg-final { scan-tree-dump-times \"vect_recog_widen_mult_pattern: detected\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n-/* { dg-final { scan-tree-dump-times \"pattern recognized\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n+/* { dg-final { scan-tree-dump-times \"widen_mult pattern recognized\" 1 \"vect\" { target vect_widen_mult_qi_to_hi_pattern } } } */\n "}, {"sha": "91076f41964b03a0929f719a2a6bd0989221af5e", "filename": "gcc/tree-vect-patterns.c", "status": "modified", "additions": 696, "deletions": 344, "changes": 1040, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftree-vect-patterns.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftree-vect-patterns.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-patterns.c?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -47,6 +47,40 @@ along with GCC; see the file COPYING3.  If not see\n #include \"omp-simd-clone.h\"\n #include \"predict.h\"\n \n+/* Return true if we have a useful VR_RANGE range for VAR, storing it\n+   in *MIN_VALUE and *MAX_VALUE if so.  Note the range in the dump files.  */\n+\n+static bool\n+vect_get_range_info (tree var, wide_int *min_value, wide_int *max_value)\n+{\n+  value_range_type vr_type = get_range_info (var, min_value, max_value);\n+  wide_int nonzero = get_nonzero_bits (var);\n+  signop sgn = TYPE_SIGN (TREE_TYPE (var));\n+  if (intersect_range_with_nonzero_bits (vr_type, min_value, max_value,\n+\t\t\t\t\t nonzero, sgn) == VR_RANGE)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_generic_expr_loc (MSG_NOTE, vect_location, TDF_SLIM, var);\n+\t  dump_printf (MSG_NOTE, \" has range [\");\n+\t  dump_hex (MSG_NOTE, *min_value);\n+\t  dump_printf (MSG_NOTE, \", \");\n+\t  dump_hex (MSG_NOTE, *max_value);\n+\t  dump_printf (MSG_NOTE, \"]\\n\");\n+\t}\n+      return true;\n+    }\n+  else\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_generic_expr_loc (MSG_NOTE, vect_location, TDF_SLIM, var);\n+\t  dump_printf (MSG_NOTE, \" has no range info\\n\");\n+\t}\n+      return false;\n+    }\n+}\n+\n /* Report that we've found an instance of pattern PATTERN in\n    statement STMT.  */\n \n@@ -190,40 +224,6 @@ vect_supportable_direct_optab_p (tree otype, tree_code code,\n   return true;\n }\n \n-/* Check whether STMT2 is in the same loop or basic block as STMT1.\n-   Which of the two applies depends on whether we're currently doing\n-   loop-based or basic-block-based vectorization, as determined by\n-   the vinfo_for_stmt for STMT1 (which must be defined).\n-\n-   If this returns true, vinfo_for_stmt for STMT2 is guaranteed\n-   to be defined as well.  */\n-\n-static bool\n-vect_same_loop_or_bb_p (gimple *stmt1, gimple *stmt2)\n-{\n-  stmt_vec_info stmt_vinfo = vinfo_for_stmt (stmt1);\n-  return vect_stmt_in_region_p (stmt_vinfo->vinfo, stmt2);\n-}\n-\n-/* If the LHS of DEF_STMT has a single use, and that statement is\n-   in the same loop or basic block, return it.  */\n-\n-static gimple *\n-vect_single_imm_use (gimple *def_stmt)\n-{\n-  tree lhs = gimple_assign_lhs (def_stmt);\n-  use_operand_p use_p;\n-  gimple *use_stmt;\n-\n-  if (!single_imm_use (lhs, &use_p, &use_stmt))\n-    return NULL;\n-\n-  if (!vect_same_loop_or_bb_p (def_stmt, use_stmt))\n-    return NULL;\n-\n-  return use_stmt;\n-}\n-\n /* Round bit precision PRECISION up to a full element.  */\n \n static unsigned int\n@@ -347,7 +347,9 @@ vect_unpromoted_value::set_op (tree op_in, vect_def_type dt_in,\n    is possible to convert OP' back to OP using a possible sign change\n    followed by a possible promotion P.  Return this OP', or null if OP is\n    not a vectorizable SSA name.  If there is a promotion P, describe its\n-   input in UNPROM, otherwise describe OP' in UNPROM.\n+   input in UNPROM, otherwise describe OP' in UNPROM.  If SINGLE_USE_P\n+   is nonnull, set *SINGLE_USE_P to false if any of the SSA names involved\n+   have more than one user.\n \n    A successful return means that it is possible to go from OP' to OP\n    via UNPROM.  The cast from OP' to UNPROM is at most a sign change,\n@@ -374,7 +376,8 @@ vect_unpromoted_value::set_op (tree op_in, vect_def_type dt_in,\n \n static tree\n vect_look_through_possible_promotion (vec_info *vinfo, tree op,\n-\t\t\t\t      vect_unpromoted_value *unprom)\n+\t\t\t\t      vect_unpromoted_value *unprom,\n+\t\t\t\t      bool *single_use_p = NULL)\n {\n   tree res = NULL_TREE;\n   tree op_type = TREE_TYPE (op);\n@@ -420,7 +423,14 @@ vect_look_through_possible_promotion (vec_info *vinfo, tree op,\n       if (!def_stmt)\n \tbreak;\n       if (dt == vect_internal_def)\n-\tcaster = vinfo_for_stmt (def_stmt);\n+\t{\n+\t  caster = vinfo_for_stmt (def_stmt);\n+\t  /* Ignore pattern statements, since we don't link uses for them.  */\n+\t  if (single_use_p\n+\t      && !STMT_VINFO_RELATED_STMT (caster)\n+\t      && !has_single_use (res))\n+\t    *single_use_p = false;\n+\t}\n       else\n \tcaster = NULL;\n       gassign *assign = dyn_cast <gassign *> (def_stmt);\n@@ -1371,363 +1381,318 @@ vect_recog_widen_sum_pattern (vec<gimple *> *stmts, tree *type_out)\n   return pattern_stmt;\n }\n \n+/* Recognize cases in which an operation is performed in one type WTYPE\n+   but could be done more efficiently in a narrower type NTYPE.  For example,\n+   if we have:\n \n-/* Return TRUE if the operation in STMT can be performed on a smaller type.\n+     ATYPE a;  // narrower than NTYPE\n+     BTYPE b;  // narrower than NTYPE\n+     WTYPE aw = (WTYPE) a;\n+     WTYPE bw = (WTYPE) b;\n+     WTYPE res = aw + bw;  // only uses of aw and bw\n \n-   Input:\n-   STMT - a statement to check.\n-   DEF - we support operations with two operands, one of which is constant.\n-         The other operand can be defined by a demotion operation, or by a\n-         previous statement in a sequence of over-promoted operations.  In the\n-         later case DEF is used to replace that operand.  (It is defined by a\n-         pattern statement we created for the previous statement in the\n-         sequence).\n-\n-   Input/output:\n-   NEW_TYPE - Output: a smaller type that we are trying to use.  Input: if not\n-         NULL, it's the type of DEF.\n-   STMTS - additional pattern statements.  If a pattern statement (type\n-         conversion) is created in this function, its original statement is\n-         added to STMTS.\n+   then it would be more efficient to do:\n \n-   Output:\n-   OP0, OP1 - if the operation fits a smaller type, OP0 and OP1 are the new\n-         operands to use in the new pattern statement for STMT (will be created\n-         in vect_recog_over_widening_pattern ()).\n-   NEW_DEF_STMT - in case DEF has to be promoted, we create two pattern\n-         statements for STMT: the first one is a type promotion and the second\n-         one is the operation itself.  We return the type promotion statement\n-\t in NEW_DEF_STMT and further store it in STMT_VINFO_PATTERN_DEF_SEQ of\n-         the second pattern statement.  */\n+     NTYPE an = (NTYPE) a;\n+     NTYPE bn = (NTYPE) b;\n+     NTYPE resn = an + bn;\n+     WTYPE res = (WTYPE) resn;\n \n-static bool\n-vect_operation_fits_smaller_type (gimple *stmt, tree def, tree *new_type,\n-\t\t\t\t  tree *op0, tree *op1, gimple **new_def_stmt,\n-\t\t\t\t  vec<gimple *> *stmts)\n-{\n-  enum tree_code code;\n-  tree const_oprnd, oprnd;\n-  tree interm_type = NULL_TREE, half_type, new_oprnd, type;\n-  gimple *def_stmt, *new_stmt;\n-  bool first = false;\n-  bool promotion;\n+   Other situations include things like:\n \n-  *op0 = NULL_TREE;\n-  *op1 = NULL_TREE;\n-  *new_def_stmt = NULL;\n+     ATYPE a;  // NTYPE or narrower\n+     WTYPE aw = (WTYPE) a;\n+     WTYPE res = aw + b;\n \n-  if (!is_gimple_assign (stmt))\n-    return false;\n+   when only \"(NTYPE) res\" is significant.  In that case it's more efficient\n+   to truncate \"b\" and do the operation on NTYPE instead:\n \n-  code = gimple_assign_rhs_code (stmt);\n-  if (code != LSHIFT_EXPR && code != RSHIFT_EXPR\n-      && code != BIT_IOR_EXPR && code != BIT_XOR_EXPR && code != BIT_AND_EXPR)\n-    return false;\n+     NTYPE an = (NTYPE) a;\n+     NTYPE bn = (NTYPE) b;  // truncation\n+     NTYPE resn = an + bn;\n+     WTYPE res = (WTYPE) resn;\n \n-  oprnd = gimple_assign_rhs1 (stmt);\n-  const_oprnd = gimple_assign_rhs2 (stmt);\n-  type = gimple_expr_type (stmt);\n+   All users of \"res\" should then use \"resn\" instead, making the final\n+   statement dead (not marked as relevant).  The final statement is still\n+   needed to maintain the type correctness of the IR.\n \n-  if (TREE_CODE (oprnd) != SSA_NAME\n-      || TREE_CODE (const_oprnd) != INTEGER_CST)\n-    return false;\n+   vect_determine_precisions has already determined the minimum\n+   precison of the operation and the minimum precision required\n+   by users of the result.  */\n \n-  /* If oprnd has other uses besides that in stmt we cannot mark it\n-     as being part of a pattern only.  */\n-  if (!has_single_use (oprnd))\n-    return false;\n+static gimple *\n+vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n+{\n+  gassign *last_stmt = dyn_cast <gassign *> (stmts->pop ());\n+  if (!last_stmt)\n+    return NULL;\n \n-  /* If we are in the middle of a sequence, we use DEF from a previous\n-     statement.  Otherwise, OPRND has to be a result of type promotion.  */\n-  if (*new_type)\n-    {\n-      half_type = *new_type;\n-      oprnd = def;\n-    }\n-  else\n-    {\n-      first = true;\n-      if (!type_conversion_p (oprnd, stmt, false, &half_type, &def_stmt,\n-\t\t\t      &promotion)\n-\t  || !promotion\n-\t  || !vect_same_loop_or_bb_p (stmt, def_stmt))\n-        return false;\n-    }\n+  /* See whether we have found that this operation can be done on a\n+     narrower type without changing its semantics.  */\n+  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n+  unsigned int new_precision = last_stmt_info->operation_precision;\n+  if (!new_precision)\n+    return NULL;\n \n-  /* Can we perform the operation on a smaller type?  */\n-  switch (code)\n+  vec_info *vinfo = last_stmt_info->vinfo;\n+  tree lhs = gimple_assign_lhs (last_stmt);\n+  tree type = TREE_TYPE (lhs);\n+  tree_code code = gimple_assign_rhs_code (last_stmt);\n+\n+  /* Keep the first operand of a COND_EXPR as-is: only the other two\n+     operands are interesting.  */\n+  unsigned int first_op = (code == COND_EXPR ? 2 : 1);\n+\n+  /* Check the operands.  */\n+  unsigned int nops = gimple_num_ops (last_stmt) - first_op;\n+  auto_vec <vect_unpromoted_value, 3> unprom (nops);\n+  unprom.quick_grow (nops);\n+  unsigned int min_precision = 0;\n+  bool single_use_p = false;\n+  for (unsigned int i = 0; i < nops; ++i)\n     {\n-      case BIT_IOR_EXPR:\n-      case BIT_XOR_EXPR:\n-      case BIT_AND_EXPR:\n-        if (!int_fits_type_p (const_oprnd, half_type))\n-          {\n-            /* HALF_TYPE is not enough.  Try a bigger type if possible.  */\n-            if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n-              return false;\n+      tree op = gimple_op (last_stmt, first_op + i);\n+      if (TREE_CODE (op) == INTEGER_CST)\n+\tunprom[i].set_op (op, vect_constant_def);\n+      else if (TREE_CODE (op) == SSA_NAME)\n+\t{\n+\t  bool op_single_use_p = true;\n+\t  if (!vect_look_through_possible_promotion (vinfo, op, &unprom[i],\n+\t\t\t\t\t\t     &op_single_use_p))\n+\t    return NULL;\n+\t  /* If:\n \n-            interm_type = build_nonstandard_integer_type (\n-                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n-            if (!int_fits_type_p (const_oprnd, interm_type))\n-              return false;\n-          }\n+\t     (1) N bits of the result are needed;\n+\t     (2) all inputs are widened from M<N bits; and\n+\t     (3) one operand OP is a single-use SSA name\n \n-        break;\n+\t     we can shift the M->N widening from OP to the output\n+\t     without changing the number or type of extensions involved.\n+\t     This then reduces the number of copies of STMT_INFO.\n \n-      case LSHIFT_EXPR:\n-        /* Try intermediate type - HALF_TYPE is not enough for sure.  */\n-        if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n-          return false;\n+\t     If instead of (3) more than one operand is a single-use SSA name,\n+\t     shifting the extension to the output is even more of a win.\n \n-        /* Check that HALF_TYPE size + shift amount <= INTERM_TYPE size.\n-          (e.g., if the original value was char, the shift amount is at most 8\n-           if we want to use short).  */\n-        if (compare_tree_int (const_oprnd, TYPE_PRECISION (half_type)) == 1)\n-          return false;\n+\t     If instead:\n \n-        interm_type = build_nonstandard_integer_type (\n-                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n+\t     (1) N bits of the result are needed;\n+\t     (2) one operand OP2 is widened from M2<N bits;\n+\t     (3) another operand OP1 is widened from M1<M2 bits; and\n+\t     (4) both OP1 and OP2 are single-use\n \n-        if (!vect_supportable_shift (code, interm_type))\n-          return false;\n+\t     the choice is between:\n \n-        break;\n+\t     (a) truncating OP2 to M1, doing the operation on M1,\n+\t\t and then widening the result to N\n \n-      case RSHIFT_EXPR:\n-        if (vect_supportable_shift (code, half_type))\n-          break;\n+\t     (b) widening OP1 to M2, doing the operation on M2, and then\n+\t\t widening the result to N\n \n-        /* Try intermediate type - HALF_TYPE is not supported.  */\n-        if (TYPE_PRECISION (type) < (TYPE_PRECISION (half_type) * 4))\n-          return false;\n+\t     Both shift the M2->N widening of the inputs to the output.\n+\t     (a) additionally shifts the M1->M2 widening to the output;\n+\t     it requires fewer copies of STMT_INFO but requires an extra\n+\t     M2->M1 truncation.\n \n-        interm_type = build_nonstandard_integer_type (\n-                        TYPE_PRECISION (half_type) * 2, TYPE_UNSIGNED (type));\n+\t     Which is better will depend on the complexity and cost of\n+\t     STMT_INFO, which is hard to predict at this stage.  However,\n+\t     a clear tie-breaker in favor of (b) is the fact that the\n+\t     truncation in (a) increases the length of the operation chain.\n \n-        if (!vect_supportable_shift (code, interm_type))\n-          return false;\n+\t     If instead of (4) only one of OP1 or OP2 is single-use,\n+\t     (b) is still a win over doing the operation in N bits:\n+\t     it still shifts the M2->N widening on the single-use operand\n+\t     to the output and reduces the number of STMT_INFO copies.\n \n-        break;\n+\t     If neither operand is single-use then operating on fewer than\n+\t     N bits might lead to more extensions overall.  Whether it does\n+\t     or not depends on global information about the vectorization\n+\t     region, and whether that's a good trade-off would again\n+\t     depend on the complexity and cost of the statements involved,\n+\t     as well as things like register pressure that are not normally\n+\t     modelled at this stage.  We therefore ignore these cases\n+\t     and just optimize the clear single-use wins above.\n \n-      default:\n-        gcc_unreachable ();\n+\t     Thus we take the maximum precision of the unpromoted operands\n+\t     and record whether any operand is single-use.  */\n+\t  if (unprom[i].dt == vect_internal_def)\n+\t    {\n+\t      min_precision = MAX (min_precision,\n+\t\t\t\t   TYPE_PRECISION (unprom[i].type));\n+\t      single_use_p |= op_single_use_p;\n+\t    }\n+\t}\n     }\n \n-  /* There are four possible cases:\n-     1. OPRND is defined by a type promotion (in that case FIRST is TRUE, it's\n-        the first statement in the sequence)\n-        a. The original, HALF_TYPE, is not enough - we replace the promotion\n-           from HALF_TYPE to TYPE with a promotion to INTERM_TYPE.\n-        b. HALF_TYPE is sufficient, OPRND is set as the RHS of the original\n-           promotion.\n-     2. OPRND is defined by a pattern statement we created.\n-        a. Its type is not sufficient for the operation, we create a new stmt:\n-           a type conversion for OPRND from HALF_TYPE to INTERM_TYPE.  We store\n-           this statement in NEW_DEF_STMT, and it is later put in\n-\t   STMT_VINFO_PATTERN_DEF_SEQ of the pattern statement for STMT.\n-        b. OPRND is good to use in the new statement.  */\n-  if (first)\n-    {\n-      if (interm_type)\n-        {\n-          /* Replace the original type conversion HALF_TYPE->TYPE with\n-             HALF_TYPE->INTERM_TYPE.  */\n-          if (STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)))\n-            {\n-              new_stmt = STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt));\n-              /* Check if the already created pattern stmt is what we need.  */\n-              if (!is_gimple_assign (new_stmt)\n-                  || !CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (new_stmt))\n-                  || TREE_TYPE (gimple_assign_lhs (new_stmt)) != interm_type)\n-                return false;\n-\n-\t      stmts->safe_push (def_stmt);\n-              oprnd = gimple_assign_lhs (new_stmt);\n-            }\n-          else\n-            {\n-              /* Create NEW_OPRND = (INTERM_TYPE) OPRND.  */\n-              oprnd = gimple_assign_rhs1 (def_stmt);\n-\t      new_oprnd = make_ssa_name (interm_type);\n-\t      new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, oprnd);\n-              STMT_VINFO_RELATED_STMT (vinfo_for_stmt (def_stmt)) = new_stmt;\n-              stmts->safe_push (def_stmt);\n-              oprnd = new_oprnd;\n-            }\n-        }\n-      else\n-        {\n-          /* Retrieve the operand before the type promotion.  */\n-          oprnd = gimple_assign_rhs1 (def_stmt);\n-        }\n-    }\n+  /* Although the operation could be done in operation_precision, we have\n+     to balance that against introducing extra truncations or extensions.\n+     Calculate the minimum precision that can be handled efficiently.\n+\n+     The loop above determined that the operation could be handled\n+     efficiently in MIN_PRECISION if SINGLE_USE_P; this would shift an\n+     extension from the inputs to the output without introducing more\n+     instructions, and would reduce the number of instructions required\n+     for STMT_INFO itself.\n+\n+     vect_determine_precisions has also determined that the result only\n+     needs min_output_precision bits.  Truncating by a factor of N times\n+     requires a tree of N - 1 instructions, so if TYPE is N times wider\n+     than min_output_precision, doing the operation in TYPE and truncating\n+     the result requires N + (N - 1) = 2N - 1 instructions per output vector.\n+     In contrast:\n+\n+     - truncating the input to a unary operation and doing the operation\n+       in the new type requires at most N - 1 + 1 = N instructions per\n+       output vector\n+\n+     - doing the same for a binary operation requires at most\n+       (N - 1) * 2 + 1 = 2N - 1 instructions per output vector\n+\n+     Both unary and binary operations require fewer instructions than\n+     this if the operands were extended from a suitable truncated form.\n+     Thus there is usually nothing to lose by doing operations in\n+     min_output_precision bits, but there can be something to gain.  */\n+  if (!single_use_p)\n+    min_precision = last_stmt_info->min_output_precision;\n   else\n-    {\n-      if (interm_type)\n-        {\n-          /* Create a type conversion HALF_TYPE->INTERM_TYPE.  */\n-\t  new_oprnd = make_ssa_name (interm_type);\n-\t  new_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, oprnd);\n-          oprnd = new_oprnd;\n-          *new_def_stmt = new_stmt;\n-        }\n+    min_precision = MIN (min_precision, last_stmt_info->min_output_precision);\n+\n+  /* Apply the minimum efficient precision we just calculated.  */\n+  if (new_precision < min_precision)\n+    new_precision = min_precision;\n+  if (new_precision >= TYPE_PRECISION (type))\n+    return NULL;\n \n-      /* Otherwise, OPRND is already set.  */\n+  vect_pattern_detected (\"vect_recog_over_widening_pattern\", last_stmt);\n+\n+  *type_out = get_vectype_for_scalar_type (type);\n+  if (!*type_out)\n+    return NULL;\n+\n+  /* We've found a viable pattern.  Get the new type of the operation.  */\n+  bool unsigned_p = (last_stmt_info->operation_sign == UNSIGNED);\n+  tree new_type = build_nonstandard_integer_type (new_precision, unsigned_p);\n+\n+  /* We specifically don't check here whether the target supports the\n+     new operation, since it might be something that a later pattern\n+     wants to rewrite anyway.  If targets have a minimum element size\n+     for some optabs, we should pattern-match smaller ops to larger ops\n+     where beneficial.  */\n+  tree new_vectype = get_vectype_for_scalar_type (new_type);\n+  if (!new_vectype)\n+    return NULL;\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"demoting \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, type);\n+      dump_printf (MSG_NOTE, \" to \");\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, new_type);\n+      dump_printf (MSG_NOTE, \"\\n\");\n     }\n \n-  if (interm_type)\n-    *new_type = interm_type;\n-  else\n-    *new_type = half_type;\n+  /* Calculate the rhs operands for an operation on NEW_TYPE.  */\n+  STMT_VINFO_PATTERN_DEF_SEQ (last_stmt_info) = NULL;\n+  tree ops[3] = {};\n+  for (unsigned int i = 1; i < first_op; ++i)\n+    ops[i - 1] = gimple_op (last_stmt, i);\n+  vect_convert_inputs (last_stmt_info, nops, &ops[first_op - 1],\n+\t\t       new_type, &unprom[0], new_vectype);\n+\n+  /* Use the operation to produce a result of type NEW_TYPE.  */\n+  tree new_var = vect_recog_temp_ssa_var (new_type, NULL);\n+  gimple *pattern_stmt = gimple_build_assign (new_var, code,\n+\t\t\t\t\t      ops[0], ops[1], ops[2]);\n+  gimple_set_location (pattern_stmt, gimple_location (last_stmt));\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location,\n+\t\t       \"created pattern stmt: \");\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n+    }\n \n-  *op0 = oprnd;\n-  *op1 = fold_convert (*new_type, const_oprnd);\n+  pattern_stmt = vect_convert_output (last_stmt_info, type,\n+\t\t\t\t      pattern_stmt, new_vectype);\n \n-  return true;\n+  stmts->safe_push (last_stmt);\n+  return pattern_stmt;\n }\n \n+/* Recognize cases in which the input to a cast is wider than its\n+   output, and the input is fed by a widening operation.  Fold this\n+   by removing the unnecessary intermediate widening.  E.g.:\n \n-/* Try to find a statement or a sequence of statements that can be performed\n-   on a smaller type:\n-\n-     type x_t;\n-     TYPE x_T, res0_T, res1_T;\n-   loop:\n-     S1  x_t = *p;\n-     S2  x_T = (TYPE) x_t;\n-     S3  res0_T = op (x_T, C0);\n-     S4  res1_T = op (res0_T, C1);\n-     S5  ... = () res1_T;  - type demotion\n+     unsigned char a;\n+     unsigned int b = (unsigned int) a;\n+     unsigned short c = (unsigned short) b;\n \n-   where type 'TYPE' is at least double the size of type 'type', C0 and C1 are\n-   constants.\n-   Check if S3 and S4 can be done on a smaller type than 'TYPE', it can either\n-   be 'type' or some intermediate type.  For now, we expect S5 to be a type\n-   demotion operation.  We also check that S3 and S4 have only one use.  */\n+   -->\n \n-static gimple *\n-vect_recog_over_widening_pattern (vec<gimple *> *stmts, tree *type_out)\n-{\n-  gimple *stmt = stmts->pop ();\n-  gimple *pattern_stmt = NULL, *new_def_stmt, *prev_stmt = NULL,\n-\t *use_stmt = NULL;\n-  tree op0, op1, vectype = NULL_TREE, use_lhs, use_type;\n-  tree var = NULL_TREE, new_type = NULL_TREE, new_oprnd;\n-  bool first;\n-  tree type = NULL;\n-\n-  first = true;\n-  while (1)\n-    {\n-      if (!vinfo_for_stmt (stmt)\n-          || STMT_VINFO_IN_PATTERN_P (vinfo_for_stmt (stmt)))\n-        return NULL;\n-\n-      new_def_stmt = NULL;\n-      if (!vect_operation_fits_smaller_type (stmt, var, &new_type,\n-                                             &op0, &op1, &new_def_stmt,\n-                                             stmts))\n-        {\n-          if (first)\n-            return NULL;\n-          else\n-            break;\n-        }\n+     unsigned short c = (unsigned short) a;\n \n-      /* STMT can be performed on a smaller type.  Check its uses.  */\n-      use_stmt = vect_single_imm_use (stmt);\n-      if (!use_stmt || !is_gimple_assign (use_stmt))\n-        return NULL;\n-\n-      /* Create pattern statement for STMT.  */\n-      vectype = get_vectype_for_scalar_type (new_type);\n-      if (!vectype)\n-        return NULL;\n-\n-      /* We want to collect all the statements for which we create pattern\n-         statetments, except for the case when the last statement in the\n-         sequence doesn't have a corresponding pattern statement.  In such\n-         case we associate the last pattern statement with the last statement\n-         in the sequence.  Therefore, we only add the original statement to\n-         the list if we know that it is not the last.  */\n-      if (prev_stmt)\n-        stmts->safe_push (prev_stmt);\n-\n-      var = vect_recog_temp_ssa_var (new_type, NULL);\n-      pattern_stmt\n-\t= gimple_build_assign (var, gimple_assign_rhs_code (stmt), op0, op1);\n-      STMT_VINFO_RELATED_STMT (vinfo_for_stmt (stmt)) = pattern_stmt;\n-      new_pattern_def_seq (vinfo_for_stmt (stmt), new_def_stmt);\n+   Although this is rare in input IR, it is an expected side-effect\n+   of the over-widening pattern above.\n \n-      if (dump_enabled_p ())\n-        {\n-          dump_printf_loc (MSG_NOTE, vect_location,\n-                           \"created pattern stmt: \");\n-          dump_gimple_stmt (MSG_NOTE, TDF_SLIM, pattern_stmt, 0);\n-        }\n+   This is beneficial also for integer-to-float conversions, if the\n+   widened integer has more bits than the float, and if the unwidened\n+   input doesn't.  */\n \n-      type = gimple_expr_type (stmt);\n-      prev_stmt = stmt;\n-      stmt = use_stmt;\n+static gimple *\n+vect_recog_cast_forwprop_pattern (vec<gimple *> *stmts, tree *type_out)\n+{\n+  /* Check for a cast, including an integer-to-float conversion.  */\n+  gassign *last_stmt = dyn_cast <gassign *> (stmts->pop ());\n+  if (!last_stmt)\n+    return NULL;\n+  tree_code code = gimple_assign_rhs_code (last_stmt);\n+  if (!CONVERT_EXPR_CODE_P (code) && code != FLOAT_EXPR)\n+    return NULL;\n \n-      first = false;\n-    }\n+  /* Make sure that the rhs is a scalar with a natural bitsize.  */\n+  tree lhs = gimple_assign_lhs (last_stmt);\n+  if (!lhs)\n+    return NULL;\n+  tree lhs_type = TREE_TYPE (lhs);\n+  scalar_mode lhs_mode;\n+  if (VECT_SCALAR_BOOLEAN_TYPE_P (lhs_type)\n+      || !is_a <scalar_mode> (TYPE_MODE (lhs_type), &lhs_mode))\n+    return NULL;\n \n-  /* We got a sequence.  We expect it to end with a type demotion operation.\n-     Otherwise, we quit (for now).  There are three possible cases: the\n-     conversion is to NEW_TYPE (we don't do anything), the conversion is to\n-     a type bigger than NEW_TYPE and/or the signedness of USE_TYPE and\n-     NEW_TYPE differs (we create a new conversion statement).  */\n-  if (CONVERT_EXPR_CODE_P (gimple_assign_rhs_code (use_stmt)))\n-    {\n-      use_lhs = gimple_assign_lhs (use_stmt);\n-      use_type = TREE_TYPE (use_lhs);\n-      /* Support only type demotion or signedess change.  */\n-      if (!INTEGRAL_TYPE_P (use_type)\n-\t  || TYPE_PRECISION (type) <= TYPE_PRECISION (use_type))\n-        return NULL;\n-\n-      /* Check that NEW_TYPE is not bigger than the conversion result.  */\n-      if (TYPE_PRECISION (new_type) > TYPE_PRECISION (use_type))\n-\treturn NULL;\n+  /* Check for a narrowing operation (from a vector point of view).  */\n+  tree rhs = gimple_assign_rhs1 (last_stmt);\n+  tree rhs_type = TREE_TYPE (rhs);\n+  if (!INTEGRAL_TYPE_P (rhs_type)\n+      || VECT_SCALAR_BOOLEAN_TYPE_P (rhs_type)\n+      || TYPE_PRECISION (rhs_type) <= GET_MODE_BITSIZE (lhs_mode))\n+    return NULL;\n \n-      if (TYPE_UNSIGNED (new_type) != TYPE_UNSIGNED (use_type)\n-          || TYPE_PRECISION (new_type) != TYPE_PRECISION (use_type))\n-        {\n-\t  *type_out = get_vectype_for_scalar_type (use_type);\n-\t  if (!*type_out)\n-\t    return NULL;\n+  /* Try to find an unpromoted input.  */\n+  stmt_vec_info last_stmt_info = vinfo_for_stmt (last_stmt);\n+  vec_info *vinfo = last_stmt_info->vinfo;\n+  vect_unpromoted_value unprom;\n+  if (!vect_look_through_possible_promotion (vinfo, rhs, &unprom)\n+      || TYPE_PRECISION (unprom.type) >= TYPE_PRECISION (rhs_type))\n+    return NULL;\n \n-          /* Create NEW_TYPE->USE_TYPE conversion.  */\n-\t  new_oprnd = make_ssa_name (use_type);\n-\t  pattern_stmt = gimple_build_assign (new_oprnd, NOP_EXPR, var);\n-          STMT_VINFO_RELATED_STMT (vinfo_for_stmt (use_stmt)) = pattern_stmt;\n-\n-          /* We created a pattern statement for the last statement in the\n-             sequence, so we don't need to associate it with the pattern\n-             statement created for PREV_STMT.  Therefore, we add PREV_STMT\n-             to the list in order to mark it later in vect_pattern_recog_1.  */\n-          if (prev_stmt)\n-            stmts->safe_push (prev_stmt);\n-        }\n-      else\n-        {\n-          if (prev_stmt)\n-\t    STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (use_stmt))\n-\t       = STMT_VINFO_PATTERN_DEF_SEQ (vinfo_for_stmt (prev_stmt));\n+  /* If the bits above RHS_TYPE matter, make sure that they're the\n+     same when extending from UNPROM as they are when extending from RHS.  */\n+  if (!INTEGRAL_TYPE_P (lhs_type)\n+      && TYPE_SIGN (rhs_type) != TYPE_SIGN (unprom.type))\n+    return NULL;\n \n-\t  *type_out = vectype;\n-        }\n+  /* We can get the same result by casting UNPROM directly, to avoid\n+     the unnecessary widening and narrowing.  */\n+  vect_pattern_detected (\"vect_recog_cast_forwprop_pattern\", last_stmt);\n \n-      stmts->safe_push (use_stmt);\n-    }\n-  else\n-    /* TODO: support general case, create a conversion to the correct type.  */\n+  *type_out = get_vectype_for_scalar_type (lhs_type);\n+  if (!*type_out)\n     return NULL;\n \n-  /* Pattern detected.  */\n-  vect_pattern_detected (\"vect_recog_over_widening_pattern\", stmts->last ());\n+  tree new_var = vect_recog_temp_ssa_var (lhs_type, NULL);\n+  gimple *pattern_stmt = gimple_build_assign (new_var, code, unprom.op);\n+  gimple_set_location (pattern_stmt, gimple_location (last_stmt));\n \n+  stmts->safe_push (last_stmt);\n   return pattern_stmt;\n }\n \n@@ -4205,6 +4170,390 @@ vect_recog_gather_scatter_pattern (vec<gimple *> *stmts, tree *type_out)\n   return pattern_stmt;\n }\n \n+/* Return true if TYPE is a non-boolean integer type.  These are the types\n+   that we want to consider for narrowing.  */\n+\n+static bool\n+vect_narrowable_type_p (tree type)\n+{\n+  return INTEGRAL_TYPE_P (type) && !VECT_SCALAR_BOOLEAN_TYPE_P (type);\n+}\n+\n+/* Return true if the operation given by CODE can be truncated to N bits\n+   when only N bits of the output are needed.  This is only true if bit N+1\n+   of the inputs has no effect on the low N bits of the result.  */\n+\n+static bool\n+vect_truncatable_operation_p (tree_code code)\n+{\n+  switch (code)\n+    {\n+    case PLUS_EXPR:\n+    case MINUS_EXPR:\n+    case MULT_EXPR:\n+    case BIT_AND_EXPR:\n+    case BIT_IOR_EXPR:\n+    case BIT_XOR_EXPR:\n+    case COND_EXPR:\n+      return true;\n+\n+    default:\n+      return false;\n+    }\n+}\n+\n+/* Record that STMT_INFO could be changed from operating on TYPE to\n+   operating on a type with the precision and sign given by PRECISION\n+   and SIGN respectively.  PRECISION is an arbitrary bit precision;\n+   it might not be a whole number of bytes.  */\n+\n+static void\n+vect_set_operation_type (stmt_vec_info stmt_info, tree type,\n+\t\t\t unsigned int precision, signop sign)\n+{\n+  /* Round the precision up to a whole number of bytes.  */\n+  precision = vect_element_precision (precision);\n+  if (precision < TYPE_PRECISION (type)\n+      && (!stmt_info->operation_precision\n+\t  || stmt_info->operation_precision > precision))\n+    {\n+      stmt_info->operation_precision = precision;\n+      stmt_info->operation_sign = sign;\n+    }\n+}\n+\n+/* Record that STMT_INFO only requires MIN_INPUT_PRECISION from its\n+   non-boolean inputs, all of which have type TYPE.  MIN_INPUT_PRECISION\n+   is an arbitrary bit precision; it might not be a whole number of bytes.  */\n+\n+static void\n+vect_set_min_input_precision (stmt_vec_info stmt_info, tree type,\n+\t\t\t      unsigned int min_input_precision)\n+{\n+  /* This operation in isolation only requires the inputs to have\n+     MIN_INPUT_PRECISION of precision,  However, that doesn't mean\n+     that MIN_INPUT_PRECISION is a natural precision for the chain\n+     as a whole.  E.g. consider something like:\n+\n+\t unsigned short *x, *y;\n+\t *y = ((*x & 0xf0) >> 4) | (*y << 4);\n+\n+     The right shift can be done on unsigned chars, and only requires the\n+     result of \"*x & 0xf0\" to be done on unsigned chars.  But taking that\n+     approach would mean turning a natural chain of single-vector unsigned\n+     short operations into one that truncates \"*x\" and then extends\n+     \"(*x & 0xf0) >> 4\", with two vectors for each unsigned short\n+     operation and one vector for each unsigned char operation.\n+     This would be a significant pessimization.\n+\n+     Instead only propagate the maximum of this precision and the precision\n+     required by the users of the result.  This means that we don't pessimize\n+     the case above but continue to optimize things like:\n+\n+\t unsigned char *y;\n+\t unsigned short *x;\n+\t *y = ((*x & 0xf0) >> 4) | (*y << 4);\n+\n+     Here we would truncate two vectors of *x to a single vector of\n+     unsigned chars and use single-vector unsigned char operations for\n+     everything else, rather than doing two unsigned short copies of\n+     \"(*x & 0xf0) >> 4\" and then truncating the result.  */\n+  min_input_precision = MAX (min_input_precision,\n+\t\t\t     stmt_info->min_output_precision);\n+\n+  if (min_input_precision < TYPE_PRECISION (type)\n+      && (!stmt_info->min_input_precision\n+\t  || stmt_info->min_input_precision > min_input_precision))\n+    stmt_info->min_input_precision = min_input_precision;\n+}\n+\n+/* Subroutine of vect_determine_min_output_precision.  Return true if\n+   we can calculate a reduced number of output bits for STMT_INFO,\n+   whose result is LHS.  */\n+\n+static bool\n+vect_determine_min_output_precision_1 (stmt_vec_info stmt_info, tree lhs)\n+{\n+  /* Take the maximum precision required by users of the result.  */\n+  unsigned int precision = 0;\n+  imm_use_iterator iter;\n+  use_operand_p use;\n+  FOR_EACH_IMM_USE_FAST (use, iter, lhs)\n+    {\n+      gimple *use_stmt = USE_STMT (use);\n+      if (is_gimple_debug (use_stmt))\n+\tcontinue;\n+      if (!vect_stmt_in_region_p (stmt_info->vinfo, use_stmt))\n+\treturn false;\n+      stmt_vec_info use_stmt_info = vinfo_for_stmt (use_stmt);\n+      if (!use_stmt_info->min_input_precision)\n+\treturn false;\n+      precision = MAX (precision, use_stmt_info->min_input_precision);\n+    }\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"only the low %d bits of \",\n+\t\t       precision);\n+      dump_generic_expr (MSG_NOTE, TDF_SLIM, lhs);\n+      dump_printf (MSG_NOTE, \" are significant\\n\");\n+    }\n+  stmt_info->min_output_precision = precision;\n+  return true;\n+}\n+\n+/* Calculate min_output_precision for STMT_INFO.  */\n+\n+static void\n+vect_determine_min_output_precision (stmt_vec_info stmt_info)\n+{\n+  /* We're only interested in statements with a narrowable result.  */\n+  tree lhs = gimple_get_lhs (stmt_info->stmt);\n+  if (!lhs\n+      || TREE_CODE (lhs) != SSA_NAME\n+      || !vect_narrowable_type_p (TREE_TYPE (lhs)))\n+    return;\n+\n+  if (!vect_determine_min_output_precision_1 (stmt_info, lhs))\n+    stmt_info->min_output_precision = TYPE_PRECISION (TREE_TYPE (lhs));\n+}\n+\n+/* Use range information to decide whether STMT (described by STMT_INFO)\n+   could be done in a narrower type.  This is effectively a forward\n+   propagation, since it uses context-independent information that applies\n+   to all users of an SSA name.  */\n+\n+static void\n+vect_determine_precisions_from_range (stmt_vec_info stmt_info, gassign *stmt)\n+{\n+  tree lhs = gimple_assign_lhs (stmt);\n+  if (!lhs || TREE_CODE (lhs) != SSA_NAME)\n+    return;\n+\n+  tree type = TREE_TYPE (lhs);\n+  if (!vect_narrowable_type_p (type))\n+    return;\n+\n+  /* First see whether we have any useful range information for the result.  */\n+  unsigned int precision = TYPE_PRECISION (type);\n+  signop sign = TYPE_SIGN (type);\n+  wide_int min_value, max_value;\n+  if (!vect_get_range_info (lhs, &min_value, &max_value))\n+    return;\n+\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  unsigned int nops = gimple_num_ops (stmt);\n+\n+  if (!vect_truncatable_operation_p (code))\n+    /* Check that all relevant input operands are compatible, and update\n+       [MIN_VALUE, MAX_VALUE] to include their ranges.  */\n+    for (unsigned int i = 1; i < nops; ++i)\n+      {\n+\ttree op = gimple_op (stmt, i);\n+\tif (TREE_CODE (op) == INTEGER_CST)\n+\t  {\n+\t    /* Don't require the integer to have RHS_TYPE (which it might\n+\t       not for things like shift amounts, etc.), but do require it\n+\t       to fit the type.  */\n+\t    if (!int_fits_type_p (op, type))\n+\t      return;\n+\n+\t    min_value = wi::min (min_value, wi::to_wide (op, precision), sign);\n+\t    max_value = wi::max (max_value, wi::to_wide (op, precision), sign);\n+\t  }\n+\telse if (TREE_CODE (op) == SSA_NAME)\n+\t  {\n+\t    /* Ignore codes that don't take uniform arguments.  */\n+\t    if (!types_compatible_p (TREE_TYPE (op), type))\n+\t      return;\n+\n+\t    wide_int op_min_value, op_max_value;\n+\t    if (!vect_get_range_info (op, &op_min_value, &op_max_value))\n+\t      return;\n+\n+\t    min_value = wi::min (min_value, op_min_value, sign);\n+\t    max_value = wi::max (max_value, op_max_value, sign);\n+\t  }\n+\telse\n+\t  return;\n+      }\n+\n+  /* Try to switch signed types for unsigned types if we can.\n+     This is better for two reasons.  First, unsigned ops tend\n+     to be cheaper than signed ops.  Second, it means that we can\n+     handle things like:\n+\n+\tsigned char c;\n+\tint res = (int) c & 0xff00; // range [0x0000, 0xff00]\n+\n+     as:\n+\n+\tsigned char c;\n+\tunsigned short res_1 = (unsigned short) c & 0xff00;\n+\tint res = (int) res_1;\n+\n+     where the intermediate result res_1 has unsigned rather than\n+     signed type.  */\n+  if (sign == SIGNED && !wi::neg_p (min_value))\n+    sign = UNSIGNED;\n+\n+  /* See what precision is required for MIN_VALUE and MAX_VALUE.  */\n+  unsigned int precision1 = wi::min_precision (min_value, sign);\n+  unsigned int precision2 = wi::min_precision (max_value, sign);\n+  unsigned int value_precision = MAX (precision1, precision2);\n+  if (value_precision >= precision)\n+    return;\n+\n+  if (dump_enabled_p ())\n+    {\n+      dump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n+\t\t       \" without loss of precision: \",\n+\t\t       sign == SIGNED ? \"signed\" : \"unsigned\",\n+\t\t       value_precision);\n+      dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+    }\n+\n+  vect_set_operation_type (stmt_info, type, value_precision, sign);\n+  vect_set_min_input_precision (stmt_info, type, value_precision);\n+}\n+\n+/* Use information about the users of STMT's result to decide whether\n+   STMT (described by STMT_INFO) could be done in a narrower type.\n+   This is effectively a backward propagation.  */\n+\n+static void\n+vect_determine_precisions_from_users (stmt_vec_info stmt_info, gassign *stmt)\n+{\n+  tree_code code = gimple_assign_rhs_code (stmt);\n+  unsigned int opno = (code == COND_EXPR ? 2 : 1);\n+  tree type = TREE_TYPE (gimple_op (stmt, opno));\n+  if (!vect_narrowable_type_p (type))\n+    return;\n+\n+  unsigned int precision = TYPE_PRECISION (type);\n+  unsigned int operation_precision, min_input_precision;\n+  switch (code)\n+    {\n+    CASE_CONVERT:\n+      /* Only the bits that contribute to the output matter.  Don't change\n+\t the precision of the operation itself.  */\n+      operation_precision = precision;\n+      min_input_precision = stmt_info->min_output_precision;\n+      break;\n+\n+    case LSHIFT_EXPR:\n+    case RSHIFT_EXPR:\n+      {\n+\ttree shift = gimple_assign_rhs2 (stmt);\n+\tif (TREE_CODE (shift) != INTEGER_CST\n+\t    || !wi::ltu_p (wi::to_widest (shift), precision))\n+\t  return;\n+\tunsigned int const_shift = TREE_INT_CST_LOW (shift);\n+\tif (code == LSHIFT_EXPR)\n+\t  {\n+\t    /* We need CONST_SHIFT fewer bits of the input.  */\n+\t    operation_precision = stmt_info->min_output_precision;\n+\t    min_input_precision = (MAX (operation_precision, const_shift)\n+\t\t\t\t    - const_shift);\n+\t  }\n+\telse\n+\t  {\n+\t    /* We need CONST_SHIFT extra bits to do the operation.  */\n+\t    operation_precision = (stmt_info->min_output_precision\n+\t\t\t\t   + const_shift);\n+\t    min_input_precision = operation_precision;\n+\t  }\n+\tbreak;\n+      }\n+\n+    default:\n+      if (vect_truncatable_operation_p (code))\n+\t{\n+\t  /* Input bit N has no effect on output bits N-1 and lower.  */\n+\t  operation_precision = stmt_info->min_output_precision;\n+\t  min_input_precision = operation_precision;\n+\t  break;\n+\t}\n+      return;\n+    }\n+\n+  if (operation_precision < precision)\n+    {\n+      if (dump_enabled_p ())\n+\t{\n+\t  dump_printf_loc (MSG_NOTE, vect_location, \"can narrow to %s:%d\"\n+\t\t\t   \" without affecting users: \",\n+\t\t\t   TYPE_UNSIGNED (type) ? \"unsigned\" : \"signed\",\n+\t\t\t   operation_precision);\n+\t  dump_gimple_stmt (MSG_NOTE, TDF_SLIM, stmt, 0);\n+\t}\n+      vect_set_operation_type (stmt_info, type, operation_precision,\n+\t\t\t       TYPE_SIGN (type));\n+    }\n+  vect_set_min_input_precision (stmt_info, type, min_input_precision);\n+}\n+\n+/* Handle vect_determine_precisions for STMT_INFO, given that we\n+   have already done so for the users of its result.  */\n+\n+void\n+vect_determine_stmt_precisions (stmt_vec_info stmt_info)\n+{\n+  vect_determine_min_output_precision (stmt_info);\n+  if (gassign *stmt = dyn_cast <gassign *> (stmt_info->stmt))\n+    {\n+      vect_determine_precisions_from_range (stmt_info, stmt);\n+      vect_determine_precisions_from_users (stmt_info, stmt);\n+    }\n+}\n+\n+/* Walk backwards through the vectorizable region to determine the\n+   values of these fields:\n+\n+   - min_output_precision\n+   - min_input_precision\n+   - operation_precision\n+   - operation_sign.  */\n+\n+void\n+vect_determine_precisions (vec_info *vinfo)\n+{\n+  DUMP_VECT_SCOPE (\"vect_determine_precisions\");\n+\n+  if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))\n+    {\n+      struct loop *loop = LOOP_VINFO_LOOP (loop_vinfo);\n+      basic_block *bbs = LOOP_VINFO_BBS (loop_vinfo);\n+      unsigned int nbbs = loop->num_nodes;\n+\n+      for (unsigned int i = 0; i < nbbs; i++)\n+\t{\n+\t  basic_block bb = bbs[nbbs - i - 1];\n+\t  for (gimple_stmt_iterator si = gsi_last_bb (bb);\n+\t       !gsi_end_p (si); gsi_prev (&si))\n+\t    vect_determine_stmt_precisions (vinfo_for_stmt (gsi_stmt (si)));\n+\t}\n+    }\n+  else\n+    {\n+      bb_vec_info bb_vinfo = as_a <bb_vec_info> (vinfo);\n+      gimple_stmt_iterator si = bb_vinfo->region_end;\n+      gimple *stmt;\n+      do\n+\t{\n+\t  if (!gsi_stmt (si))\n+\t    si = gsi_last_bb (bb_vinfo->bb);\n+\t  else\n+\t    gsi_prev (&si);\n+\t  stmt = gsi_stmt (si);\n+\t  stmt_vec_info stmt_info = vinfo_for_stmt (stmt);\n+\t  if (stmt_info && STMT_VINFO_VECTORIZABLE (stmt_info))\n+\t    vect_determine_stmt_precisions (stmt_info);\n+\t}\n+      while (stmt != gsi_stmt (bb_vinfo->region_begin));\n+    }\n+}\n+\n typedef gimple *(*vect_recog_func_ptr) (vec<gimple *> *, tree *);\n \n struct vect_recog_func\n@@ -4217,13 +4566,14 @@ struct vect_recog_func\n    taken which means usually the more complex one needs to preceed the\n    less comples onex (widen_sum only after dot_prod or sad for example).  */\n static vect_recog_func vect_vect_recog_func_ptrs[] = {\n+  { vect_recog_over_widening_pattern, \"over_widening\" },\n+  { vect_recog_cast_forwprop_pattern, \"cast_forwprop\" },\n   { vect_recog_widen_mult_pattern, \"widen_mult\" },\n   { vect_recog_dot_prod_pattern, \"dot_prod\" },\n   { vect_recog_sad_pattern, \"sad\" },\n   { vect_recog_widen_sum_pattern, \"widen_sum\" },\n   { vect_recog_pow_pattern, \"pow\" },\n   { vect_recog_widen_shift_pattern, \"widen_shift\" },\n-  { vect_recog_over_widening_pattern, \"over_widening\" },\n   { vect_recog_rotate_pattern, \"rotate\" },\n   { vect_recog_vector_vector_shift_pattern, \"vector_vector_shift\" },\n   { vect_recog_divmod_pattern, \"divmod\" },\n@@ -4502,6 +4852,8 @@ vect_pattern_recog (vec_info *vinfo)\n   unsigned int i, j;\n   auto_vec<gimple *, 1> stmts_to_replace;\n \n+  vect_determine_precisions (vinfo);\n+\n   DUMP_VECT_SCOPE (\"vect_pattern_recog\");\n \n   if (loop_vec_info loop_vinfo = dyn_cast <loop_vec_info> (vinfo))"}, {"sha": "28be41f60f3dd56d42e783bbda54300e7ca54c51", "filename": "gcc/tree-vectorizer.h", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftree-vectorizer.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85/gcc%2Ftree-vectorizer.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vectorizer.h?ref=370c2ebe8fa20e0812cd2d533d4ed38ee2d37c85", "patch": "@@ -899,6 +899,21 @@ typedef struct _stmt_vec_info {\n \n   /* The number of scalar stmt references from active SLP instances.  */\n   unsigned int num_slp_uses;\n+\n+  /* If nonzero, the lhs of the statement could be truncated to this\n+     many bits without affecting any users of the result.  */\n+  unsigned int min_output_precision;\n+\n+  /* If nonzero, all non-boolean input operands have the same precision,\n+     and they could each be truncated to this many bits without changing\n+     the result.  */\n+  unsigned int min_input_precision;\n+\n+  /* If OPERATION_BITS is nonzero, the statement could be performed on\n+     an integer with the sign and number of bits given by OPERATION_SIGN\n+     and OPERATION_BITS without changing the result.  */\n+  unsigned int operation_precision;\n+  signop operation_sign;\n } *stmt_vec_info;\n \n /* Information about a gather/scatter call.  */"}]}