{"sha": "144a5f9d4507713f644f15a5ba4795dec3663435", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTQ0YTVmOWQ0NTA3NzEzZjY0NGYxNWE1YmE0Nzk1ZGVjMzY2MzQzNQ==", "commit": {"author": {"name": "Jeffrey A Law", "email": "law@cygnus.com", "date": "2000-02-11T19:35:57Z"}, "committer": {"name": "Jeff Law", "email": "law@gcc.gnu.org", "date": "2000-02-11T19:35:57Z"}, "message": "jump.c (jump_optimize_1): The first operand in a relational can be a CONST_INT.\n\n\n        * jump.c (jump_optimize_1): The first operand in a relational\n        can be a CONST_INT.\n        * optabs.c (emit_conditional_move): Handle relationals which\n        have a known true/false result.\n\nFrom-SVN: r31929", "tree": {"sha": "4f7c1de9d41848cde64412c8651f3224743ee4d4", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4f7c1de9d41848cde64412c8651f3224743ee4d4"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/144a5f9d4507713f644f15a5ba4795dec3663435", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144a5f9d4507713f644f15a5ba4795dec3663435", "html_url": "https://github.com/Rust-GCC/gccrs/commit/144a5f9d4507713f644f15a5ba4795dec3663435", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/144a5f9d4507713f644f15a5ba4795dec3663435/comments", "author": null, "committer": null, "parents": [{"sha": "2dd8bc01663b0ff2c5dd586102dfe270b145fc45", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/2dd8bc01663b0ff2c5dd586102dfe270b145fc45", "html_url": "https://github.com/Rust-GCC/gccrs/commit/2dd8bc01663b0ff2c5dd586102dfe270b145fc45"}], "stats": {"total": 21, "additions": 18, "deletions": 3}, "files": [{"sha": "a4cdc7354a26814dc49084d2411a9392d89fdde1", "filename": "gcc/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=144a5f9d4507713f644f15a5ba4795dec3663435", "patch": "@@ -1,3 +1,10 @@\n+Feb 11 12:30:53 2000  Jeffrey A Law  (law@cygnus.com)\n+\n+\t* jump.c (jump_optimize_1): The first operand in a relational\n+\tcan be a CONST_INT.\n+\t* optabs.c (emit_conditional_move): Handle relationals which\n+\thave a known true/false result.\n+\n 2000-02-11  Geoff Keating  <geoffk@cygnus.com>\n \n \t* function.c (thread_prologue_and_epilogue_insns): Don't insert"}, {"sha": "d816b126ac471b133a517a23b8e03f95f85dfe00", "filename": "gcc/jump.c", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2Fjump.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2Fjump.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fjump.c?ref=144a5f9d4507713f644f15a5ba4795dec3663435", "patch": "@@ -1305,10 +1305,16 @@ jump_optimize_1 (f, cross_jump, noop_moves, after_regscan, mark_labels_only)\n \t\t   insn?  After all, we're going to delete it.  We'd have\n \t\t   to modify emit_conditional_move to take a comparison rtx\n \t\t   instead or write a new function.  */\n-\t\tcond0 = gen_reg_rtx (GET_MODE (XEXP (temp4, 0)));\n+\n \t\t/* We want the target to be able to simplify comparisons with\n \t\t   zero (and maybe other constants as well), so don't create\n \t\t   pseudos for them.  There's no need to either.  */\n+\t\tif (GET_CODE (XEXP (temp4, 0)) == CONST_INT\n+\t\t    || GET_CODE (XEXP (temp4, 0)) == CONST_DOUBLE)\n+\t\t  cond0 = XEXP (temp4, 0);\n+\t\telse\n+\t\t  cond0 = gen_reg_rtx (GET_MODE (XEXP (temp4, 0)));\n+\n \t\tif (GET_CODE (XEXP (temp4, 1)) == CONST_INT\n \t\t    || GET_CODE (XEXP (temp4, 1)) == CONST_DOUBLE)\n \t\t  cond1 = XEXP (temp4, 1);"}, {"sha": "9ce0c9264607bfb1ea02da8222f8b44b584ff505", "filename": "gcc/optabs.c", "status": "modified", "additions": 4, "deletions": 2, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/144a5f9d4507713f644f15a5ba4795dec3663435/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=144a5f9d4507713f644f15a5ba4795dec3663435", "patch": "@@ -3593,9 +3593,11 @@ emit_conditional_move (target, code, op0, op1, cmode, op2, op3, mode,\n     = compare_from_rtx (op0, op1, code, unsignedp, cmode, NULL_RTX, 0);\n \n   /* ??? Watch for const0_rtx (nop) and const_true_rtx (unconditional)?  */\n+  /* We can get const0_rtx or const_true_rtx in some circumstances.  Just\n+     return NULL and let the caller figure out how best to deal with this\n+     situation.  */\n   if (GET_CODE (comparison) != code)\n-    /* This shouldn't happen.  */\n-    abort ();\n+    return NULL_RTX;\n   \n   insn = GEN_FCN (icode) (subtarget, comparison, op2, op3);\n "}]}