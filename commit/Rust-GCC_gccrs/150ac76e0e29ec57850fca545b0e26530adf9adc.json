{"sha": "150ac76e0e29ec57850fca545b0e26530adf9adc", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTUwYWM3NmUwZTI5ZWM1Nzg1MGZjYTU0NWIwZTI2NTMwYWRmOWFkYw==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T10:20:41Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2012-11-06T10:20:41Z"}, "message": "[multiple changes]\n\n2012-11-06  Robert Dewar  <dewar@adacore.com>\n\n\t* par_sco.adb, bindgen.adb, exp_vfpt.adb, exp_vfpt.ads, exp_ch2.adb,\n\terrout.adb, sem_ch8.adb: Minor reformatting.\n\n2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n\n\t* einfo.adb: Include Loop_Entry_Attributes to the list of\n\tNode/List/Elist10 usage.\n\t(Loop_Entry_Attributes): New routine.\n\t(Set_Loop_Entry_Attributes): New routine.\n\t(Write_Field10_Name): Add an output string for Loop_Entry_Attributes.\n\t* einfo.ads: Define new attribute Loop_Entry_Attributes along\n\twith its usage in nodes.\n\t(Loop_Entry_Attributes): New routine and dedicated pragma Inline.\n\t(Set_Loop_Entry_Attributes): New routine and dedicated pragma Inline.\n\t* exp_attr.adb (Expand_N_Attribute_Reference): Do not expand\n\tAttribute_Loop_Entry here.\n\t* exp_ch5.adb: Add with and use clause for Elists;\n\t(Expand_Loop_Entry_Attributes): New routine.\n\t(Expand_N_Loop_Statement): Add a call to Expand_Loop_Entry_Attributes.\n\t* exp_prag.adb (Expand_Pragma_Loop_Assertion): Specialize the\n\tsearch to include multiple nested loops produced by the expansion\n\tof Ada 2012 array iterator.\n\t* sem_attr.adb: Add with and use clause for Elists.\n\t(Analyze_Attribute): Check the legality of attribute Loop_Entry.\n\t(Resolve_Attribute): Nothing to do for Loop_Entry.\n\t(S14_Attribute): New routine.\n\t* snames.ads-tmpl: Add a comment on entries marked with\n\tHiLite. Add new name Name_Loop_Entry. Add new attribute\n\tAttribute_Loop_Entry.\n\nFrom-SVN: r193227", "tree": {"sha": "44faecf9685467f3cfe0c70f98f98c4a7e9d1616", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/44faecf9685467f3cfe0c70f98f98c4a7e9d1616"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/150ac76e0e29ec57850fca545b0e26530adf9adc", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150ac76e0e29ec57850fca545b0e26530adf9adc", "html_url": "https://github.com/Rust-GCC/gccrs/commit/150ac76e0e29ec57850fca545b0e26530adf9adc", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/150ac76e0e29ec57850fca545b0e26530adf9adc/comments", "author": null, "committer": null, "parents": [{"sha": "fa1ed65806ea3231c762c342de286f9efecd011d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fa1ed65806ea3231c762c342de286f9efecd011d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fa1ed65806ea3231c762c342de286f9efecd011d"}], "stats": {"total": 757, "additions": 721, "deletions": 36}, "files": [{"sha": "e3c04aaeb249830d311271dbb30266d131a8bd48", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -1,3 +1,35 @@\n+2012-11-06  Robert Dewar  <dewar@adacore.com>\n+\n+\t* par_sco.adb, bindgen.adb, exp_vfpt.adb, exp_vfpt.ads, exp_ch2.adb,\n+\terrout.adb, sem_ch8.adb: Minor reformatting.\n+\n+2012-11-06  Hristian Kirtchev  <kirtchev@adacore.com>\n+\n+\t* einfo.adb: Include Loop_Entry_Attributes to the list of\n+\tNode/List/Elist10 usage.\n+\t(Loop_Entry_Attributes): New routine.\n+\t(Set_Loop_Entry_Attributes): New routine.\n+\t(Write_Field10_Name): Add an output string for Loop_Entry_Attributes.\n+\t* einfo.ads: Define new attribute Loop_Entry_Attributes along\n+\twith its usage in nodes.\n+\t(Loop_Entry_Attributes): New routine and dedicated pragma Inline.\n+\t(Set_Loop_Entry_Attributes): New routine and dedicated pragma Inline.\n+\t* exp_attr.adb (Expand_N_Attribute_Reference): Do not expand\n+\tAttribute_Loop_Entry here.\n+\t* exp_ch5.adb: Add with and use clause for Elists;\n+\t(Expand_Loop_Entry_Attributes): New routine.\n+\t(Expand_N_Loop_Statement): Add a call to Expand_Loop_Entry_Attributes.\n+\t* exp_prag.adb (Expand_Pragma_Loop_Assertion): Specialize the\n+\tsearch to include multiple nested loops produced by the expansion\n+\tof Ada 2012 array iterator.\n+\t* sem_attr.adb: Add with and use clause for Elists.\n+\t(Analyze_Attribute): Check the legality of attribute Loop_Entry.\n+\t(Resolve_Attribute): Nothing to do for Loop_Entry.\n+\t(S14_Attribute): New routine.\n+\t* snames.ads-tmpl: Add a comment on entries marked with\n+\tHiLite. Add new name Name_Loop_Entry. Add new attribute\n+\tAttribute_Loop_Entry.\n+\n 2012-11-06  Geert Bosch  <bosch@adacore.com>\n \n \t* eval_fat.adb (Machine, Succ): Fix front end to support static"}, {"sha": "71741441d09b3819264db0df9f1547429b239cd4", "filename": "gcc/ada/bindgen.adb", "status": "modified", "additions": 9, "deletions": 10, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fbindgen.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fbindgen.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fbindgen.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -498,9 +498,9 @@ package body Bindgen is\n            and then Partition_Elaboration_Policy_Specified = 'S'\n          then\n             WBI (\"      procedure Install_Restricted_Handlers_Sequential;\");\n-            WBI (\"      pragma Import (C,\"\n-                   & \"Install_Restricted_Handlers_Sequential,\" &\n-                   \" \"\"__gnat_attach_all_handlers\"\");\");\n+            WBI (\"      pragma Import (C,\" &\n+                 \"Install_Restricted_Handlers_Sequential,\" &\n+                 \" \"\"__gnat_attach_all_handlers\"\");\");\n             WBI (\"\");\n          end if;\n \n@@ -509,7 +509,7 @@ package body Bindgen is\n          then\n             WBI (\"      Partition_Elaboration_Policy : Character;\");\n             WBI (\"      pragma Import (C, Partition_Elaboration_Policy,\" &\n-                  \" \"\"__gnat_partition_elaboration_policy\"\");\");\n+                 \" \"\"__gnat_partition_elaboration_policy\"\");\");\n             WBI (\"\");\n             WBI (\"      procedure Activate_All_Tasks_Sequential;\");\n             WBI (\"      pragma Import (C, Activate_All_Tasks_Sequential,\" &\n@@ -617,16 +617,15 @@ package body Bindgen is\n          WBI (\"      pragma Import (C, Handler_Installed, \" &\n               \"\"\"__gnat_handler_installed\"\");\");\n \n-         --  Import handlers attach procedure for sequential elaboration\n-         --  policy.\n+         --  Import handlers attach procedure for sequential elaboration policy\n \n          if System_Interrupts_Used\n            and then Partition_Elaboration_Policy_Specified = 'S'\n          then\n             WBI (\"      procedure Install_Restricted_Handlers_Sequential;\");\n-            WBI (\"      pragma Import (C,\"\n-                   & \"Install_Restricted_Handlers_Sequential,\" &\n-                   \" \"\"__gnat_attach_all_handlers\"\");\");\n+            WBI (\"      pragma Import (C,\" &\n+                 \"Install_Restricted_Handlers_Sequential,\" &\n+                 \" \"\"__gnat_attach_all_handlers\"\");\");\n             WBI (\"\");\n          end if;\n \n@@ -638,7 +637,7 @@ package body Bindgen is\n          then\n             WBI (\"      Partition_Elaboration_Policy : Character;\");\n             WBI (\"      pragma Import (C, Partition_Elaboration_Policy,\" &\n-                  \" \"\"__gnat_partition_elaboration_policy\"\");\");\n+                 \" \"\"__gnat_partition_elaboration_policy\"\");\");\n             WBI (\"\");\n             WBI (\"      procedure Activate_All_Tasks_Sequential;\");\n             WBI (\"      pragma Import (C, Activate_All_Tasks_Sequential,\" &"}, {"sha": "7e3073ef3845ef59f2337fc12291541ed7e030bf", "filename": "gcc/ada/einfo.adb", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Feinfo.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Feinfo.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -33,6 +33,7 @@ pragma Style_Checks (All_Checks);\n --  Turn off subprogram ordering, not used for this unit\n \n with Atree;  use Atree;\n+with Errout; use Errout;\n with Namet;  use Namet;\n with Nlists; use Nlists;\n with Output; use Output;\n@@ -90,6 +91,7 @@ package body Einfo is\n    --    Discriminal_Link                Node10\n    --    Float_Rep                       Uint10 (but returns Float_Rep_Kind)\n    --    Handler_Records                 List10\n+   --    Loop_Entry_Attributes           Elist10\n    --    Normalized_Position_Max         Uint10\n \n    --    Component_Bit_Offset            Uint11\n@@ -2246,6 +2248,12 @@ package body Einfo is\n       return Node16 (Id);\n    end Lit_Strings;\n \n+   function Loop_Entry_Attributes (Id : E) return L is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      return Elist10 (Id);\n+   end Loop_Entry_Attributes;\n+\n    function Low_Bound_Tested (Id : E) return B is\n    begin\n       return Flag205 (Id);\n@@ -4791,6 +4799,12 @@ package body Einfo is\n       Set_Node16 (Id, V);\n    end Set_Lit_Strings;\n \n+   procedure Set_Loop_Entry_Attributes (Id : E; V : L) is\n+   begin\n+      pragma Assert (Ekind (Id) = E_Loop);\n+      Set_Elist10 (Id, V);\n+   end Set_Loop_Entry_Attributes;\n+\n    procedure Set_Low_Bound_Tested (Id : E; V : B := True) is\n    begin\n       pragma Assert (Is_Formal (Id));\n@@ -6967,6 +6981,7 @@ package body Einfo is\n             --  previous errors.\n \n             elsif No (Etyp) then\n+               Cascaded_Error;\n                return T;\n \n             elsif Is_Private_Type (T) and then Etyp = Full_View (T) then\n@@ -7874,6 +7889,9 @@ package body Einfo is\n               E_Procedure                                  =>\n             Write_Str (\"Handler_Records\");\n \n+         when E_Loop                                       =>\n+            Write_Str (\"Loop_Entry_Attributes\");\n+\n          when E_Component                                  |\n               E_Discriminant                               =>\n             Write_Str (\"Normalized_Position_Max\");"}, {"sha": "e4af8cf23fb96fd67b3e66c16a4780b40b02d0e7", "filename": "gcc/ada/einfo.ads", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Feinfo.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Feinfo.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Feinfo.ads?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -2959,6 +2959,10 @@ package Einfo is\n --       the nature and use of this entity for implementing the Image and\n --       Value attributes for the enumeration type in question.\n \n+--    Loop_Entry_Attributes (Elist10)\n+--       Defined for loop statement scopes. The list contains all Loop_Entry\n+--       attribute references related to the target loop.\n+\n --    Low_Bound_Tested (Flag205)\n --       Defined in all entities. Currently this can only be set True for\n --       formal parameter entries of a standard unconstrained one-dimensional\n@@ -5389,6 +5393,7 @@ package Einfo is\n \n    --  E_Loop\n    --    First_Exit_Statement                (Node8)\n+   --    Loop_Entry_Attributes               (Elist10)\n    --    Has_Exit                            (Flag47)\n    --    Has_Master_Entity                   (Flag21)\n    --    Has_Nested_Block_With_Handler       (Flag101)\n@@ -6309,6 +6314,7 @@ package Einfo is\n    function Limited_View                        (Id : E) return E;\n    function Lit_Indexes                         (Id : E) return E;\n    function Lit_Strings                         (Id : E) return E;\n+   function Loop_Entry_Attributes               (Id : E) return L;\n    function Low_Bound_Tested                    (Id : E) return B;\n    function Machine_Radix_10                    (Id : E) return B;\n    function Master_Id                           (Id : E) return E;\n@@ -6905,6 +6911,7 @@ package Einfo is\n    procedure Set_Limited_View                    (Id : E; V : E);\n    procedure Set_Lit_Indexes                     (Id : E; V : E);\n    procedure Set_Lit_Strings                     (Id : E; V : E);\n+   procedure Set_Loop_Entry_Attributes           (Id : E; V : L);\n    procedure Set_Low_Bound_Tested                (Id : E; V : B := True);\n    procedure Set_Machine_Radix_10                (Id : E; V : B := True);\n    procedure Set_Master_Id                       (Id : E; V : E);\n@@ -7623,6 +7630,7 @@ package Einfo is\n    pragma Inline (Limited_View);\n    pragma Inline (Lit_Indexes);\n    pragma Inline (Lit_Strings);\n+   pragma Inline (Loop_Entry_Attributes);\n    pragma Inline (Low_Bound_Tested);\n    pragma Inline (Machine_Radix_10);\n    pragma Inline (Master_Id);\n@@ -8028,6 +8036,7 @@ package Einfo is\n    pragma Inline (Set_Limited_View);\n    pragma Inline (Set_Lit_Indexes);\n    pragma Inline (Set_Lit_Strings);\n+   pragma Inline (Set_Loop_Entry_Attributes);\n    pragma Inline (Set_Low_Bound_Tested);\n    pragma Inline (Set_Machine_Radix_10);\n    pragma Inline (Set_Master_Id);"}, {"sha": "48bbc983b197f7b89e4d8216d5ddc284c931eee9", "filename": "gcc/ada/errout.adb", "status": "modified", "additions": 6, "deletions": 3, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Ferrout.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Ferrout.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Ferrout.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -18,6 +18,10 @@\n -- Public License  distributed with GNAT; see file COPYING3.  If not, go to --\n -- http://www.gnu.org/licenses for a complete copy of the license.          --\n --                                                                          --\n+-- As a special exception under Section 7 of GPL version 3, you are granted --\n+-- additional permissions described in the GCC Runtime Library Exception,   --\n+-- version 3.1, as published by the Free Software Foundation.               --\n+--                                                                          --\n -- GNAT was originally developed  by the GNAT team at  New York University. --\n -- Extensive contributions were provided by Ada Core Technologies Inc.      --\n --                                                                          --\n@@ -205,10 +209,9 @@ package body Errout is\n    procedure Cascaded_Error is\n    begin\n       --  An anomaly has been detected which is assumed to be a consequence of\n-      --  a previous error. Raise an exception if no serious error has been\n-      --  found so far.\n+      --  a previous error. Raise an exception if no error found previously.\n \n-      if Serious_Errors_Detected = 0 then\n+      if Total_Errors_Detected = 0 then\n          raise Program_Error;\n       end if;\n    end Cascaded_Error;"}, {"sha": "417bad988478151c706bfdddb13348667830929e", "filename": "gcc/ada/exp_attr.adb", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_attr.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -2953,7 +2953,7 @@ package body Exp_Attr is\n       -- Length --\n       ------------\n \n-      when Attribute_Length => declare\n+      when Attribute_Length => Length : declare\n          Ityp : Entity_Id;\n          Xnum : Uint;\n \n@@ -3103,7 +3103,13 @@ package body Exp_Attr is\n          else\n             Apply_Universal_Integer_Attribute_Checks (N);\n          end if;\n-      end;\n+      end Length;\n+\n+      --  The expansion of this attribute is carried out when the target loop\n+      --  is processed. See Expand_Loop_Entry_Attributes for details.\n+\n+      when Attribute_Loop_Entry =>\n+         null;\n \n       -------------\n       -- Machine --"}, {"sha": "64e561cde52f822ed08fd898e0af19230f6ccc5a", "filename": "gcc/ada/exp_ch2.adb", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_ch2.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_ch2.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch2.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -635,8 +635,13 @@ package body Exp_Ch2 is\n    ---------------------------\n \n    procedure Expand_N_Real_Literal (N : Node_Id) is\n+      pragma Unreferenced (N);\n+\n    begin\n-      --  Vax real literal are now allowed by gigi\n+      --  Historically, this routine existed because there were expansion\n+      --  requirements for Vax real literals, but now Vax real literals\n+      --  are now handled by gigi, so this routine no longer does anything.\n+\n       null;\n    end Expand_N_Real_Literal;\n "}, {"sha": "80aabc5acd861e47b8a9daee84b606ae7658a695", "filename": "gcc/ada/exp_ch5.adb", "status": "modified", "additions": 334, "deletions": 4, "changes": 338, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_ch5.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_ch5.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch5.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -28,6 +28,7 @@ with Atree;    use Atree;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Exp_Aggr; use Exp_Aggr;\n with Exp_Ch6;  use Exp_Ch6;\n@@ -110,6 +111,10 @@ package body Exp_Ch5 is\n    procedure Expand_Iterator_Loop_Over_Array (N : Node_Id);\n    --  Expand loop over arrays that uses the form \"for X of C\"\n \n+   procedure Expand_Loop_Entry_Attributes (N : Node_Id);\n+   --  Given a loop statement subject to at least one Loop_Entry attribute,\n+   --  expand both the loop and all related Loop_Entry references.\n+\n    procedure Expand_Predicated_Loop (N : Node_Id);\n    --  Expand for loop over predicated subtype\n \n@@ -1522,6 +1527,324 @@ package body Exp_Ch5 is\n       end;\n    end Expand_Assign_Record;\n \n+   ----------------------------------\n+   -- Expand_Loop_Entry_Attributes --\n+   ----------------------------------\n+\n+   procedure Expand_Loop_Entry_Attributes (N : Node_Id) is\n+      procedure Build_Conditional_Block\n+        (Loc      : Source_Ptr;\n+         Cond     : Node_Id;\n+         Stmt     : Node_Id;\n+         If_Stmt  : out Node_Id;\n+         Blk_Stmt : out Node_Id);\n+      --  Create a block Blk_Stmt with an empty declarative list and a single\n+      --  statement Stmt. The block is encased in an if statement If_Stmt with\n+      --  condition Cond. If_Stmt is Empty when there is no condition provided.\n+\n+      function Is_Array_Iteration (N : Node_Id) return Boolean;\n+      --  Determine whether loop statement N denotes an Ada 2012 iteration over\n+      --  an array object.\n+\n+      -----------------------------\n+      -- Build_Conditional_Block --\n+      -----------------------------\n+\n+      procedure Build_Conditional_Block\n+        (Loc      : Source_Ptr;\n+         Cond     : Node_Id;\n+         Stmt     : Node_Id;\n+         If_Stmt  : out Node_Id;\n+         Blk_Stmt : out Node_Id)\n+      is\n+      begin\n+         Blk_Stmt :=\n+           Make_Block_Statement (Loc,\n+             Declarations               => New_List,\n+             Handled_Statement_Sequence =>\n+               Make_Handled_Sequence_Of_Statements (Loc,\n+                 Statements => New_List (Stmt)));\n+\n+         if Present (Cond) then\n+            If_Stmt :=\n+              Make_If_Statement (Loc,\n+                Condition       => Cond,\n+                Then_Statements => New_List (Blk_Stmt));\n+         else\n+            If_Stmt := Empty;\n+         end if;\n+      end Build_Conditional_Block;\n+\n+      ------------------------\n+      -- Is_Array_Iteration --\n+      ------------------------\n+\n+      function Is_Array_Iteration (N : Node_Id) return Boolean is\n+         Stmt : constant Node_Id := Original_Node (N);\n+         Iter : Node_Id;\n+\n+      begin\n+         if Nkind (Stmt) = N_Loop_Statement\n+           and then Present (Iteration_Scheme (Stmt))\n+           and then Present (Iterator_Specification (Iteration_Scheme (Stmt)))\n+         then\n+            Iter := Iterator_Specification (Iteration_Scheme (Stmt));\n+\n+            return\n+              Of_Present (Iter)\n+                and then Is_Array_Type (Etype (Name (Iter)));\n+         end if;\n+\n+         return False;\n+      end Is_Array_Iteration;\n+\n+      --  Local variables\n+\n+      Loc     : constant Source_Ptr := Sloc (N);\n+      Loop_Id : constant Entity_Id  := Identifier (N);\n+      Scheme  : constant Node_Id    := Iteration_Scheme (N);\n+      Blk     : Node_Id;\n+      LE      : Node_Id;\n+      LE_Elmt : Elmt_Id;\n+      Result  : Node_Id;\n+      Temp    : Entity_Id;\n+      Typ     : Entity_Id;\n+\n+   --  Start of processing for Expand_Loop_Entry_Attributes\n+\n+   begin\n+      --  The loop will never execute after it has been expanded, no point in\n+      --  processing it.\n+\n+      if Is_Null_Loop (N) then\n+         return;\n+\n+      --  A loop without an identifier cannot be referenced in 'Loop_Entry\n+\n+      elsif No (Loop_Id) then\n+         return;\n+\n+      --  The loop is not subject to 'Loop_Entry\n+\n+      elsif No (Loop_Entry_Attributes (Entity (Loop_Id))) then\n+         return;\n+\n+      --  Step 1: Loop transformations\n+\n+      --  While loops are transformed into:\n+\n+      --    if <Condition> then\n+      --       declare\n+      --          Temp1 : constant <type of Pref1> := <Pref1>;\n+      --          . . .\n+      --          TempN : constant <type of PrefN> := <PrefN>;\n+      --       begin\n+      --          loop\n+      --             <original source statements with attribute rewrites>\n+      --             exit when not <Condition>;\n+      --          end loop;\n+      --       end;\n+      --    end if;\n+\n+      --  Note that loops over iterators and containers are already converted\n+      --  into while loops.\n+\n+      elsif Present (Condition (Scheme)) then\n+         declare\n+            Cond : constant Node_Id := Condition (Scheme);\n+\n+         begin\n+            --  Transform the original while loop into an infinite loop where\n+            --  the last statement checks the negated condition. This placement\n+            --  ensures that the condition will not be evaluated twice on the\n+            --  first iteration.\n+\n+            --  Generate:\n+            --    exit when not <Cond>:\n+\n+            Append_To (Statements (N),\n+              Make_Exit_Statement (Loc,\n+                Condition => Make_Op_Not (Loc, New_Copy_Tree (Cond))));\n+\n+            Build_Conditional_Block (Loc,\n+              Cond     => Relocate_Node (Cond),\n+              Stmt     => Relocate_Node (N),\n+              If_Stmt  => Result,\n+              Blk_Stmt => Blk);\n+         end;\n+\n+      --  Ada 2012 iteration over an array is transformed into:\n+\n+      --    if <Array_Nam>'Length (1) > 0\n+      --      and then <Array_Nam>'Length (N) > 0\n+      --    then\n+      --       declare\n+      --          Temp1 : constant <type of Pref1> := <Pref1>;\n+      --          . . .\n+      --          TempN : constant <type of PrefN> := <PrefN>;\n+      --       begin\n+      --          for X in ... loop  --  multiple loops depending on dims\n+      --             <original source statements with attribute rewrites>\n+      --          end loop;\n+      --       end;\n+      --    end if;\n+\n+      elsif Is_Array_Iteration (N) then\n+         declare\n+            Array_Nam : constant Entity_Id :=\n+                          Entity (Name (Iterator_Specification\n+                            (Iteration_Scheme (Original_Node (N)))));\n+            Num_Dims  : constant Pos :=\n+                          Number_Dimensions (Etype (Array_Nam));\n+            Cond      : Node_Id := Empty;\n+            Check     : Node_Id;\n+            Top_Loop  : Node_Id;\n+\n+         begin\n+            --  Generate a check which determines whether all dimensions of\n+            --  the array are non-null.\n+\n+            for Dim in 1 .. Num_Dims loop\n+               Check :=\n+                 Make_Op_Gt (Loc,\n+                   Left_Opnd  =>\n+                     Make_Attribute_Reference (Loc,\n+                       Prefix         => New_Reference_To (Array_Nam, Loc),\n+                       Attribute_Name => Name_Length,\n+                       Expressions    => New_List (\n+                         Make_Integer_Literal (Loc, Dim))),\n+                   Right_Opnd =>\n+                     Make_Integer_Literal (Loc, 0));\n+\n+               if No (Cond) then\n+                  Cond := Check;\n+               else\n+                  Cond :=\n+                    Make_And_Then (Loc,\n+                      Left_Opnd  => Cond,\n+                      Right_Opnd => Check);\n+               end if;\n+            end loop;\n+\n+            Top_Loop := Relocate_Node (N);\n+            Set_Analyzed (Top_Loop);\n+\n+            Build_Conditional_Block (Loc,\n+              Cond     => Cond,\n+              Stmt     => Top_Loop,\n+              If_Stmt  => Result,\n+              Blk_Stmt => Blk);\n+         end;\n+\n+      --  For loops are transformed into:\n+\n+      --    if <Low> <= <High> then\n+      --       declare\n+      --          Temp1 : constant <type of Pref1> := <Pref1>;\n+      --          . . .\n+      --          TempN : constant <type of PrefN> := <PrefN>;\n+      --       begin\n+      --          for <Def_Id> in <Low> .. <High> loop\n+      --             <original source statements with attribute rewrites>\n+      --          end loop;\n+      --       end;\n+      --    end if;\n+\n+      elsif Present (Loop_Parameter_Specification (Scheme)) then\n+         declare\n+            Loop_Spec : constant Node_Id :=\n+                          Loop_Parameter_Specification (Scheme);\n+            Subt_Def  : constant Node_Id :=\n+                          Discrete_Subtype_Definition (Loop_Spec);\n+            Cond      : Node_Id;\n+\n+         begin\n+            --  At this point in the expansion all discrete subtype definitions\n+            --  should be transformed into ranges.\n+\n+            pragma Assert (Nkind (Subt_Def) = N_Range);\n+\n+            --  Generate\n+            --    Low <= High\n+\n+            Cond :=\n+              Make_Op_Le (Loc,\n+                Left_Opnd  => New_Copy_Tree (Low_Bound (Subt_Def)),\n+                Right_Opnd => New_Copy_Tree (High_Bound (Subt_Def)));\n+\n+            Build_Conditional_Block (Loc,\n+              Cond     => Cond,\n+              Stmt     => Relocate_Node (N),\n+              If_Stmt  => Result,\n+              Blk_Stmt => Blk);\n+         end;\n+\n+      --  Infinite loops are transformed into:\n+\n+      --    declare\n+      --       Temp1 : constant <type of Pref1> := <Pref1>;\n+      --       . . .\n+      --       TempN : constant <type of PrefN> := <PrefN>;\n+      --    begin\n+      --       loop\n+      --          <original source statements with attribute rewrites>\n+      --       end loop;\n+      --    end;\n+\n+      else\n+         Build_Conditional_Block (Loc,\n+           Cond     => Empty,\n+           Stmt     => Relocate_Node (N),\n+           If_Stmt  => Result,\n+           Blk_Stmt => Blk);\n+\n+         Result := Blk;\n+      end if;\n+\n+      --  Step 2: Loop_Entry attribute transformations\n+\n+      --  At this point the various loops have been augmented to contain a\n+      --  block. Populate the declarative list of the block with constants\n+      --  which store the value of their relative prefixes at the point of\n+      --  entry in the loop.\n+\n+      LE_Elmt := First_Elmt (Loop_Entry_Attributes (Entity (Loop_Id)));\n+      while Present (LE_Elmt) loop\n+         LE  := Node (LE_Elmt);\n+         Typ := Etype (Prefix (LE));\n+\n+         --  Declare a constant to capture the value of the previx of each\n+         --  Loop_Entry attribute.\n+\n+         --  Generate:\n+         --    Temp : constant <type of Pref> := <Pref>;\n+\n+         Temp := Make_Temporary (Loc, 'P');\n+\n+         Append_To (Declarations (Blk),\n+           Make_Object_Declaration (Loc,\n+             Defining_Identifier => Temp,\n+             Constant_Present    => True,\n+             Object_Definition   => New_Reference_To (Typ, Loc),\n+             Expression          => Relocate_Node (Prefix (LE))));\n+\n+         --  Replace the original attribute with a reference to the constant\n+\n+         Rewrite (LE, New_Reference_To (Temp, Loc));\n+         Set_Etype (LE, Typ);\n+\n+         Next_Elmt (LE_Elmt);\n+      end loop;\n+\n+      --  Destroy the list of Loop_Entry attributes to prevent the infinite\n+      --  expansion when analyzing and expanding the newly generated loops.\n+\n+      Set_Loop_Entry_Attributes (Entity (Loop_Id), No_Elist);\n+\n+      Rewrite (N, Result);\n+      Analyze (N);\n+   end Expand_Loop_Entry_Attributes;\n+\n    -----------------------------------\n    -- Expand_N_Assignment_Statement --\n    -----------------------------------\n@@ -3662,6 +3985,13 @@ package body Exp_Ch5 is\n       then\n          Expand_Iterator_Loop (N);\n       end if;\n+\n+      --  If the loop is subject to at least one Loop_Entry attribute, it\n+      --  requires additional processing.\n+\n+      if Nkind (N) = N_Loop_Statement then\n+         Expand_Loop_Entry_Attributes (N);\n+      end if;\n    end Expand_N_Loop_Statement;\n \n    ----------------------------\n@@ -3854,10 +4184,10 @@ package body Exp_Ch5 is\n             --  Rewrite the loop\n \n             D :=\n-               Make_Object_Declaration (Loc,\n-                 Defining_Identifier => Loop_Id,\n-                 Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n-                 Expression          => Lo_Val (First (Stat)));\n+              Make_Object_Declaration (Loc,\n+                Defining_Identifier => Loop_Id,\n+                Object_Definition   => New_Occurrence_Of (Ltype, Loc),\n+                Expression          => Lo_Val (First (Stat)));\n             Set_Suppress_Assignment_Checks (D);\n \n             Rewrite (N,"}, {"sha": "c21c21c5c80cdf9f64c34432e4f81e84f98b6846", "filename": "gcc/ada/exp_prag.adb", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_prag.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_prag.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_prag.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -1076,12 +1076,18 @@ package body Exp_Prag is\n    --  Start of processing for Expand_Pragma_Loop_Assertion\n \n    begin\n-      --  Locate the enclosing loop for which this assertion applies\n+      --  Locate the enclosing loop for which this assertion applies. In the\n+      --  case of Ada 2012 array iteration, we might be dealing with nested\n+      --  loops. Only the outermost loop has an identifier.\n \n       Loop_Stmt := N;\n-      while Present (Loop_Stmt)\n-        and then Nkind (Loop_Stmt) /= N_Loop_Statement\n-      loop\n+      while Present (Loop_Stmt) loop\n+         if Nkind (Loop_Stmt) = N_Loop_Statement\n+           and then Present (Identifier (Loop_Stmt))\n+         then\n+            exit;\n+         end if;\n+\n          Loop_Stmt := Parent (Loop_Stmt);\n       end loop;\n "}, {"sha": "82d2fe16e7df4745eedcb3f1e2bdf9109218eb79", "filename": "gcc/ada/exp_vfpt.adb", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_vfpt.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_vfpt.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -80,8 +80,8 @@ package body Exp_VFpt is\n    --  +--------------------------------+\n \n    --  Note that the fraction bits are not continuous in memory. Bytes in a\n-   --  words are stored using little endianness, but words are stored using\n-   --  big endianness (PDP endian)\n+   --  words are stored in little endian format, but words are stored using\n+   --  big endian format (PDP endian).\n \n    --  Like Float F but with 55 bits for the fraction.\n "}, {"sha": "db0186694355c2bbc6a715e77a7f38a0d966e877", "filename": "gcc/ada/exp_vfpt.ads", "status": "modified", "additions": 4, "deletions": 4, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_vfpt.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fexp_vfpt.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_vfpt.ads?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -54,10 +54,10 @@ package Exp_VFpt is\n \n    function Get_Vax_Real_Literal_As_Signed (N : Node_Id) return Uint;\n    --  Get the Vax binary representation of a real literal whose type is a Vax\n-   --  floating-point type. This is used by gigi. Previously we expanded\n-   --  real literal to a call to a LIB$OTS routine that performed the\n-   --  conversion. This worked well, but was not efficient and generated huge\n-   --  functions for aggregate initialization.\n+   --  floating-point type. This is used by gigi. Previously we expanded real\n+   --  literal to a call to a LIB$OTS routine that performed the conversion.\n+   --  This worked correctly from a funcional point of view, but was\n+   --  inefficient and generated huge functions for aggregate initializations.\n \n    procedure Expand_Vax_Valid (N : Node_Id);\n    --  The node N is an attribute reference node for the Valid attribute where"}, {"sha": "cec2afefdb263f03425ccdc4fa96d839b9efa1ec", "filename": "gcc/ada/par_sco.adb", "status": "modified", "additions": 24, "deletions": 3, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fpar_sco.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fpar_sco.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fpar_sco.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -34,6 +34,8 @@ with Opt;      use Opt;\n with Output;   use Output;\n with Put_SCOs;\n with SCOs;     use SCOs;\n+with Sem;      use Sem;\n+with Sem_Util; use Sem_Util;\n with Sinfo;    use Sinfo;\n with Sinput;   use Sinput;\n with Snames;   use Snames;\n@@ -926,9 +928,14 @@ package body Par_SCO is\n       Sloc_Range (Orig, Start, Dummy);\n       Index := Condition_Pragma_Hash_Table.Get (Start);\n \n-      --  The test here for zero is to deal with possible previous errors\n+      --  Index can be zero for boolean expressions that do not have SCOs\n+      --  (simple decisions outside of a control flow structure), or in case\n+      --  of a previous error.\n \n-      if Index /= 0 then\n+      if Index = 0 then\n+         return;\n+\n+      else\n          pragma Assert (SCO_Table.Table (Index).C1 = ' ');\n          SCO_Table.Table (Index).C2 := Constant_Condition_Code (Val);\n       end if;\n@@ -942,6 +949,17 @@ package body Par_SCO is\n       Index : Nat;\n \n    begin\n+      --  Nothing to do if not generating SCO, or if we're not processing the\n+      --  original source occurrence of the pragma.\n+\n+      if not (Generate_SCO\n+               and then\n+                 In_Extended_Main_Source_Unit (Cunit_Entity (Current_Sem_Unit))\n+               and then not (In_Instance or In_Inlined_Body))\n+      then\n+         return;\n+      end if;\n+\n       --  Note: the reason we use the Sloc value as the key is that in the\n       --  generic case, the call to this procedure is made on a copy of the\n       --  original node, so we can't use the Node_Id value.\n@@ -950,7 +968,10 @@ package body Par_SCO is\n \n       --  The test here for zero is to deal with possible previous errors\n \n-      if Index /= 0 then\n+      if Index = 0 then\n+         Cascaded_Error;\n+\n+      else\n          declare\n             T : SCO_Table_Entry renames SCO_Table.Table (Index);\n "}, {"sha": "223f387915507aecc6845e914f965bc568fde8b7", "filename": "gcc/ada/sem_attr.adb", "status": "modified", "additions": 249, "deletions": 0, "changes": 249, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsem_attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsem_attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_attr.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -30,6 +30,7 @@ with Casing;   use Casing;\n with Checks;   use Checks;\n with Debug;    use Debug;\n with Einfo;    use Einfo;\n+with Elists;   use Elists;\n with Errout;   use Errout;\n with Eval_Fat;\n with Exp_Dist; use Exp_Dist;\n@@ -375,6 +376,10 @@ package body Sem_Attr is\n       pragma No_Return (Error_Attr);\n       --  Like Error_Attr, but error is posted at the start of the prefix\n \n+      procedure S14_Attribute;\n+      --  Called for all attributes defined for formal verification to check\n+      --  that the S14_Extensions flag is set.\n+\n       procedure Standard_Attribute (Val : Int);\n       --  Used to process attributes whose prefix is package Standard which\n       --  yield values of type Universal_Integer. The attribute reference\n@@ -1950,6 +1955,18 @@ package body Sem_Attr is\n          Set_Etype (N, Standard_Boolean);\n       end Legal_Formal_Attribute;\n \n+      -------------------\n+      -- S14_Attribute --\n+      -------------------\n+\n+      procedure S14_Attribute is\n+      begin\n+         if not Formal_Extensions then\n+            Error_Attr\n+              (\"attribute % requires the use of debug switch -gnatd.V\", N);\n+         end if;\n+      end S14_Attribute;\n+\n       ------------------------\n       -- Standard_Attribute --\n       ------------------------\n@@ -3584,6 +3601,231 @@ package body Sem_Attr is\n               (\"prefix of % attribute must be a protected object\");\n          end if;\n \n+      ----------------\n+      -- Loop_Entry --\n+      ----------------\n+\n+      when Attribute_Loop_Entry => Loop_Entry : declare\n+         procedure Check_References_In_Prefix (Loop_Id : Entity_Id);\n+         --  Inspect the prefix for any uses of entities declared within the\n+         --  related loop. Loop_Id denotes the loop identifier.\n+\n+         --------------------------------\n+         -- Check_References_In_Prefix --\n+         --------------------------------\n+\n+         procedure Check_References_In_Prefix (Loop_Id : Entity_Id) is\n+            Loop_Decl : constant Node_Id := Label_Construct (Parent (Loop_Id));\n+\n+            function Check_Reference (Nod : Node_Id) return Traverse_Result;\n+            --  Determine whether a reference mentions an entity declared\n+            --  within the related loop.\n+\n+            function Declared_Within (Nod : Node_Id) return Boolean;\n+            --  Determine whether Nod appears in the subtree of Loop_Decl\n+\n+            ---------------------\n+            -- Check_Reference --\n+            ---------------------\n+\n+            function Check_Reference (Nod : Node_Id) return Traverse_Result is\n+            begin\n+               if Nkind (Nod) = N_Identifier\n+                 and then Present (Entity (Nod))\n+                 and then Declared_Within (Declaration_Node (Entity (Nod)))\n+               then\n+                  Error_Attr\n+                    (\"prefix of attribute % cannot reference local entities\",\n+                     Nod);\n+                  return Abandon;\n+               else\n+                  return OK;\n+               end if;\n+            end Check_Reference;\n+\n+            procedure Check_References is new Traverse_Proc (Check_Reference);\n+\n+            ---------------------\n+            -- Declared_Within --\n+            ---------------------\n+\n+            function Declared_Within (Nod : Node_Id) return Boolean is\n+               Stmt : Node_Id;\n+\n+            begin\n+               Stmt := Nod;\n+               while Present (Stmt) loop\n+                  if Stmt = Loop_Decl then\n+                     return True;\n+\n+                  --  Prevent the search from going too far\n+\n+                  elsif Nkind_In (Stmt, N_Entry_Body,\n+                                        N_Package_Body,\n+                                        N_Package_Declaration,\n+                                        N_Protected_Body,\n+                                        N_Subprogram_Body,\n+                                        N_Task_Body)\n+                  then\n+                     exit;\n+                  end if;\n+\n+                  Stmt := Parent (Stmt);\n+               end loop;\n+\n+               return False;\n+            end Declared_Within;\n+\n+         --  Start of processing for Check_Prefix_For_Local_References\n+\n+         begin\n+            Check_References (P);\n+         end Check_References_In_Prefix;\n+\n+         --  Local variables\n+\n+         Enclosing_Loop    : Node_Id;\n+         In_Loop_Assertion : Boolean   := False;\n+         Loop_Id           : Entity_Id := Empty;\n+         Scop              : Entity_Id;\n+         Stmt              : Node_Id;\n+\n+      --  Start of processing for Loop_Entry\n+\n+      begin\n+         S14_Attribute;\n+         Check_E1;\n+         Analyze (E1);\n+\n+         --  The prefix must denote an object\n+\n+         if not Is_Object_Reference (P) then\n+            Error_Attr_P (\"prefix of attribute % must denote an object\");\n+         end if;\n+\n+         --  The prefix cannot be of a limited type because the expansion of\n+         --  Loop_Entry must create a constant initialized by the evaluated\n+         --  prefix.\n+\n+         if Is_Immutably_Limited_Type (Etype (P)) then\n+            Error_Attr_P (\"prefix of attribute % cannot be limited\");\n+         end if;\n+\n+         --  The sole argument of a Loop_Entry must be a loop name\n+\n+         if Is_Entity_Name (E1) then\n+            Loop_Id := Entity (E1);\n+         end if;\n+\n+         if No (Loop_Id)\n+           or else Ekind (Loop_Id) /= E_Loop\n+           or else not In_Open_Scopes (Loop_Id)\n+         then\n+            Error_Attr (\"argument of % must be a valid loop name\", E1);\n+            return;\n+         end if;\n+\n+         --  Climb the parent chain to verify the location of the attribute and\n+         --  find the enclosing loop.\n+\n+         Stmt := N;\n+         while Present (Stmt) loop\n+\n+            --  Locate the enclosing Loop_Assertion pragma (if any). Note that\n+            --  when Loop_Assertion is expanded, we must look for an Assertion\n+            --  pragma.\n+\n+            if Nkind (Original_Node (Stmt)) = N_Pragma\n+              and then\n+                (Pragma_Name (Original_Node (Stmt)) = Name_Assert\n+                   or else\n+                 Pragma_Name (Original_Node (Stmt)) = Name_Loop_Assertion)\n+            then\n+               In_Loop_Assertion := True;\n+\n+            --  Locate the enclosing loop (if any). Note that Ada 2012 array\n+            --  iteration may be expanded into several nested loops, we are\n+            --  interested in the outermost one which has the loop identifier.\n+\n+            elsif Nkind (Stmt) = N_Loop_Statement\n+              and then Present (Identifier (Stmt))\n+            then\n+               Enclosing_Loop := Stmt;\n+               exit;\n+\n+            --  Prevent the search from going too far\n+\n+            elsif Nkind_In (Stmt, N_Entry_Body,\n+                                  N_Package_Body,\n+                                  N_Package_Declaration,\n+                                  N_Protected_Body,\n+                                  N_Subprogram_Body,\n+                                  N_Task_Body)\n+            then\n+               exit;\n+            end if;\n+\n+            Stmt := Parent (Stmt);\n+         end loop;\n+\n+         --  Loop_Entry must appear within a Loop_Assertion pragma\n+\n+         if not In_Loop_Assertion then\n+            Error_Attr\n+              (\"attribute % must appear within pragma Loop_Assertion\", N);\n+         end if;\n+\n+         --  A Loop_Entry that applies to a given loop statement shall not\n+         --  appear within a body of accept statement, if this construct is\n+         --  itself enclosed by the given loop statement.\n+\n+         for J in reverse 0 .. Scope_Stack.Last loop\n+            Scop := Scope_Stack.Table (J).Entity;\n+\n+            if Ekind (Scop) = E_Loop and then Scop = Loop_Id then\n+               exit;\n+\n+            elsif Ekind_In (Scop, E_Block, E_Loop, E_Return_Statement) then\n+               null;\n+\n+            else\n+               Error_Attr\n+                 (\"cannot appear in program unit or accept statement\", N);\n+               exit;\n+            end if;\n+         end loop;\n+\n+         --  The prefix cannot mention entities declared within the related\n+         --  loop because they will not be visible once the prefix is moved\n+         --  outside the loop.\n+\n+         Check_References_In_Prefix (Loop_Id);\n+\n+         --  The prefix must denote a static entity if the pragma does not\n+         --  apply to the innermost enclosing loop statement.\n+\n+         if Present (Enclosing_Loop)\n+           and then Entity (Identifier (Enclosing_Loop)) /= Loop_Id\n+           and then not Is_Entity_Name (P)\n+         then\n+            Error_Attr_P (\"prefix of attribute % must denote an entity\");\n+         end if;\n+\n+         Set_Etype (N, Etype (P));\n+\n+         --  Associate the attribute with its related loop\n+\n+         if No (Loop_Entry_Attributes (Loop_Id)) then\n+            Set_Loop_Entry_Attributes (Loop_Id, New_Elmt_List);\n+         end if;\n+\n+         --  A Loop_Entry may be [pre]analyzed several times, depending on the\n+         --  context. Ensure that it appears only once in the attributes list\n+         --  of the related loop.\n+\n+         Append_Unique_Elmt (N, Loop_Entry_Attributes (Loop_Id));\n+      end Loop_Entry;\n+\n       -------------\n       -- Machine --\n       -------------\n@@ -6989,6 +7231,13 @@ package body Sem_Attr is\n          end;\n       end Length;\n \n+      ----------------\n+      -- Loop_Entry --\n+      ----------------\n+\n+      when Attribute_Loop_Entry =>\n+         null;\n+\n       -------------\n       -- Machine --\n       -------------"}, {"sha": "7b937a67ac5e54e477845af2cd1d2b46270278e7", "filename": "gcc/ada/sem_ch8.adb", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsem_ch8.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsem_ch8.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsem_ch8.adb?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -739,9 +739,10 @@ package body Sem_Ch8 is\n             --  expanded. Limited types with discriminants are included.\n \n             elsif Is_Limited_Record (Typ)\n-              or else (Ekind (Typ) = E_Limited_Private_Type\n-                and then Has_Discriminants (Typ)\n-                and then Is_Access_Type (Etype (First_Discriminant (Typ))))\n+              or else\n+                (Ekind (Typ) = E_Limited_Private_Type\n+                  and then Has_Discriminants (Typ)\n+                  and then Is_Access_Type (Etype (First_Discriminant (Typ))))\n             then\n                null;\n "}, {"sha": "864d8ed12c4af84401b6b22c16589270ea81ec40", "filename": "gcc/ada/snames.ads-tmpl", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsnames.ads-tmpl", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/150ac76e0e29ec57850fca545b0e26530adf9adc/gcc%2Fada%2Fsnames.ads-tmpl", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads-tmpl?ref=150ac76e0e29ec57850fca545b0e26530adf9adc", "patch": "@@ -771,6 +771,10 @@ package Snames is\n    --  The entries marked VMS are recognized only in OpenVMS implementations\n    --  of GNAT, and are treated as illegal in all other contexts.\n \n+   --  The entries marked HiLite are attributes that are defined by Hi-Lite\n+   --  and implemented in GNAT operating under formal verification mode. The\n+   --  entries are treated as illegal in all other contexts.\n+\n    First_Attribute_Name                : constant Name_Id := N + $;\n    Name_Abort_Signal                   : constant Name_Id := N + $; -- GNAT\n    Name_Access                         : constant Name_Id := N + $;\n@@ -832,6 +836,7 @@ package Snames is\n    Name_Leading_Part                   : constant Name_Id := N + $;\n    Name_Length                         : constant Name_Id := N + $;\n    Name_Lock_Free                      : constant Name_Id := N + $; -- GNAT\n+   Name_Loop_Entry                     : constant Name_Id := N + $; -- HiLite\n    Name_Machine_Emax                   : constant Name_Id := N + $;\n    Name_Machine_Emin                   : constant Name_Id := N + $;\n    Name_Machine_Mantissa               : constant Name_Id := N + $;\n@@ -1442,6 +1447,7 @@ package Snames is\n       Attribute_Leading_Part,\n       Attribute_Length,\n       Attribute_Lock_Free,\n+      Attribute_Loop_Entry,\n       Attribute_Machine_Emax,\n       Attribute_Machine_Emin,\n       Attribute_Machine_Mantissa,"}]}