{"sha": "7cc61ee413c4f77b89abf53bb524802fd1397e69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6N2NjNjFlZTQxM2M0Zjc3Yjg5YWJmNTNiYjUyNDgwMmZkMTM5N2U2OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "rdsandiford@googlemail.com", "date": "2012-05-31T05:30:31Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2012-05-31T05:30:31Z"}, "message": "ira-int.h (target_ira_int): Rename x_move_cost to x_ira_register_move_cost...\n\ngcc/\n\t* ira-int.h (target_ira_int): Rename x_move_cost to\n\tx_ira_register_move_cost, x_may_move_in_cost to\n\tx_ira_may_move_in_cost and x_may_move_out_cost to\n\tx_ira_may_move_out_cost.  Delete the old fields with\n\tthose names and also x_ira_max_register_move_cost,\n\tx_ira_max_may_move_in_cost and x_ira_max_may_move_out_cost.\n\t(move_cost, may_move_in_cost, may_move_out_cost)\n\t(ira_max_register_move_cost, ira_max_may_move_in_cost)\n\t(ira_max_may_move_out_cost): Delete.\n\t* ira.c (init_move_cost): Rename to...\n\t(ira_init_register_move_cost): ...this, deleting the old\n\tfunction with that name.  Apply above variable renamings.\n\tRetain asserts for null fields.\n\t(ira_init_once): Don't initialize register move costs here.\n\t(free_register_move_costs): Apply above variable renamings.\n\tRemove code for deleted fields.\n\nFrom-SVN: r188047", "tree": {"sha": "50f53252fbc657eb016574d082bcd3ff7edb3484", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/50f53252fbc657eb016574d082bcd3ff7edb3484"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/7cc61ee413c4f77b89abf53bb524802fd1397e69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc61ee413c4f77b89abf53bb524802fd1397e69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/7cc61ee413c4f77b89abf53bb524802fd1397e69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/7cc61ee413c4f77b89abf53bb524802fd1397e69/comments", "author": {"login": "rsandifo", "id": 4235983, "node_id": "MDQ6VXNlcjQyMzU5ODM=", "avatar_url": "https://avatars.githubusercontent.com/u/4235983?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rsandifo", "html_url": "https://github.com/rsandifo", "followers_url": "https://api.github.com/users/rsandifo/followers", "following_url": "https://api.github.com/users/rsandifo/following{/other_user}", "gists_url": "https://api.github.com/users/rsandifo/gists{/gist_id}", "starred_url": "https://api.github.com/users/rsandifo/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rsandifo/subscriptions", "organizations_url": "https://api.github.com/users/rsandifo/orgs", "repos_url": "https://api.github.com/users/rsandifo/repos", "events_url": "https://api.github.com/users/rsandifo/events{/privacy}", "received_events_url": "https://api.github.com/users/rsandifo/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48", "html_url": "https://github.com/Rust-GCC/gccrs/commit/48e3d6e9de8a3f01bdc1d16a65c4106b83c00d48"}], "stats": {"total": 249, "additions": 66, "deletions": 183}, "files": [{"sha": "10f66ba92d3c656d577f1cda603332aa6866fc84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=7cc61ee413c4f77b89abf53bb524802fd1397e69", "patch": "@@ -1,3 +1,22 @@\n+2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n+\n+\t* ira-int.h (target_ira_int): Rename x_move_cost to\n+\tx_ira_register_move_cost, x_may_move_in_cost to\n+\tx_ira_may_move_in_cost and x_may_move_out_cost to\n+\tx_ira_may_move_out_cost.  Delete the old fields with\n+\tthose names and also x_ira_max_register_move_cost,\n+\tx_ira_max_may_move_in_cost and x_ira_max_may_move_out_cost.\n+\t(move_cost, may_move_in_cost, may_move_out_cost)\n+\t(ira_max_register_move_cost, ira_max_may_move_in_cost)\n+\t(ira_max_may_move_out_cost): Delete.\n+\t* ira.c (init_move_cost): Rename to...\n+\t(ira_init_register_move_cost): ...this, deleting the old\n+\tfunction with that name.  Apply above variable renamings.\n+\tRetain asserts for null fields.\n+\t(ira_init_once): Don't initialize register move costs here.\n+\t(free_register_move_costs): Apply above variable renamings.\n+\tRemove code for deleted fields.\n+\n 2012-05-31  Richard Sandiford  <rdsandiford@googlemail.com>\n \n \t* ira.c (init_move_cost): Adjust choice of subclasses to match"}, {"sha": "1fd285dacf72d8e600a5fc94dc1a9614f59889e2", "filename": "gcc/ira-int.h", "status": "modified", "additions": 5, "deletions": 43, "changes": 48, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2Fira-int.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2Fira-int.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira-int.h?ref=7cc61ee413c4f77b89abf53bb524802fd1397e69", "patch": "@@ -771,48 +771,22 @@ struct target_ira_int {\n \n   /* Maximum cost of moving from a register in one class to a register\n      in another class.  Based on TARGET_REGISTER_MOVE_COST.  */\n-  move_table *x_move_cost[MAX_MACHINE_MODE];\n+  move_table *x_ira_register_move_cost[MAX_MACHINE_MODE];\n \n   /* Similar, but here we don't have to move if the first index is a\n      subset of the second so in that case the cost is zero.  */\n-  move_table *x_may_move_in_cost[MAX_MACHINE_MODE];\n+  move_table *x_ira_may_move_in_cost[MAX_MACHINE_MODE];\n \n   /* Similar, but here we don't have to move if the first index is a\n      superset of the second so in that case the cost is zero.  */\n-  move_table *x_may_move_out_cost[MAX_MACHINE_MODE];\n+  move_table *x_ira_may_move_out_cost[MAX_MACHINE_MODE];\n \n   /* Keep track of the last mode we initialized move costs for.  */\n   int x_last_mode_for_init_move_cost;\n \n-  /* Array based on TARGET_REGISTER_MOVE_COST.  Don't use\n-     ira_register_move_cost directly.  Use function of\n-     ira_get_may_move_cost instead.  */\n-  move_table *x_ira_register_move_cost[MAX_MACHINE_MODE];\n-\n-  /* Array analogs of the macros MEMORY_MOVE_COST and\n-     REGISTER_MOVE_COST but they contain maximal cost not minimal as\n-     the previous two ones do.  */\n+  /* Array analog of the macro MEMORY_MOVE_COST but they contain maximal\n+     cost not minimal.  */\n   short int x_ira_max_memory_move_cost[MAX_MACHINE_MODE][N_REG_CLASSES][2];\n-  move_table *x_ira_max_register_move_cost[MAX_MACHINE_MODE];\n-\n-  /* Similar to may_move_in_cost but it is calculated in IRA instead of\n-     regclass.  Another difference we take only available hard registers\n-     into account to figure out that one register class is a subset of\n-     the another one.  Don't use it directly.  Use function of\n-     ira_get_may_move_cost instead.  */\n-  move_table *x_ira_may_move_in_cost[MAX_MACHINE_MODE];\n-\n-  /* Similar to may_move_out_cost but it is calculated in IRA instead of\n-     regclass.  Another difference we take only available hard registers\n-     into account to figure out that one register class is a subset of\n-     the another one.  Don't use it directly.  Use function of\n-     ira_get_may_move_cost instead.  */\n-  move_table *x_ira_may_move_out_cost[MAX_MACHINE_MODE];\n-\n-/* Similar to ira_may_move_in_cost and ira_may_move_out_cost but they\n-   return maximal cost.  */\n-  move_table *x_ira_max_may_move_in_cost[MAX_MACHINE_MODE];\n-  move_table *x_ira_max_may_move_out_cost[MAX_MACHINE_MODE];\n \n   /* Map class->true if class is a possible allocno class, false\n      otherwise. */\n@@ -905,26 +879,14 @@ extern struct target_ira_int *this_target_ira_int;\n \n #define ira_reg_mode_hard_regset \\\n   (this_target_ira_int->x_ira_reg_mode_hard_regset)\n-#define move_cost \\\n-  (this_target_ira_int->x_move_cost)\n-#define may_move_in_cost \\\n-  (this_target_ira_int->x_may_move_in_cost)\n-#define may_move_out_cost \\\n-  (this_target_ira_int->x_may_move_out_cost)\n #define ira_register_move_cost \\\n   (this_target_ira_int->x_ira_register_move_cost)\n #define ira_max_memory_move_cost \\\n   (this_target_ira_int->x_ira_max_memory_move_cost)\n-#define ira_max_register_move_cost \\\n-  (this_target_ira_int->x_ira_max_register_move_cost)\n #define ira_may_move_in_cost \\\n   (this_target_ira_int->x_ira_may_move_in_cost)\n #define ira_may_move_out_cost \\\n   (this_target_ira_int->x_ira_may_move_out_cost)\n-#define ira_max_may_move_in_cost \\\n-  (this_target_ira_int->x_ira_max_may_move_in_cost)\n-#define ira_max_may_move_out_cost \\\n-  (this_target_ira_int->x_ira_max_may_move_out_cost)\n #define ira_reg_allocno_class_p \\\n   (this_target_ira_int->x_ira_reg_allocno_class_p)\n #define ira_reg_pressure_class_p \\"}, {"sha": "81c5180b7d0ae1affb0622a340ad82c3e43fbd06", "filename": "gcc/ira.c", "status": "modified", "additions": 42, "deletions": 140, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2Fira.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/7cc61ee413c4f77b89abf53bb524802fd1397e69/gcc%2Fira.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fira.c?ref=7cc61ee413c4f77b89abf53bb524802fd1397e69", "patch": "@@ -1451,15 +1451,18 @@ clarify_prohibited_class_mode_regs (void)\n \t}\n }\n \f\n-/* Initialize may_move_cost and friends for mode M.  */\n-\n-static void\n-init_move_cost (enum machine_mode mode)\n+/* Allocate and initialize IRA_REGISTER_MOVE_COST, IRA_MAY_MOVE_IN_COST\n+   and IRA_MAY_MOVE_OUT_COST for MODE.  */\n+void\n+ira_init_register_move_cost (enum machine_mode mode)\n {\n   static unsigned short last_move_cost[N_REG_CLASSES][N_REG_CLASSES];\n   bool all_match = true;\n   unsigned int cl1, cl2;\n \n+  ira_assert (ira_register_move_cost[mode] == NULL\n+\t      && ira_may_move_in_cost[mode] == NULL\n+\t      && ira_may_move_out_cost[mode] == NULL);\n   ira_assert (have_regs_of_mode[mode]);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n     if (contains_reg_of_mode[cl1][mode])\n@@ -1479,18 +1482,18 @@ init_move_cost (enum machine_mode mode)\n \t}\n   if (all_match && last_mode_for_init_move_cost != -1)\n     {\n-      move_cost[mode] = move_cost[last_mode_for_init_move_cost];\n-      may_move_in_cost[mode] = may_move_in_cost[last_mode_for_init_move_cost];\n-      may_move_out_cost[mode] = may_move_out_cost[last_mode_for_init_move_cost];\n+      ira_register_move_cost[mode]\n+\t= ira_register_move_cost[last_mode_for_init_move_cost];\n+      ira_may_move_in_cost[mode]\n+\t= ira_may_move_in_cost[last_mode_for_init_move_cost];\n+      ira_may_move_out_cost[mode]\n+\t= ira_may_move_out_cost[last_mode_for_init_move_cost];\n       return;\n     }\n   last_mode_for_init_move_cost = mode;\n-  move_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t* N_REG_CLASSES);\n-  may_move_in_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t       * N_REG_CLASSES);\n-  may_move_out_cost[mode] = (move_table *)xmalloc (sizeof (move_table)\n-\t\t\t\t\t        * N_REG_CLASSES);\n+  ira_register_move_cost[mode] = XNEWVEC (move_table, N_REG_CLASSES);\n+  ira_may_move_in_cost[mode] = XNEWVEC (move_table, N_REG_CLASSES);\n+  ira_may_move_out_cost[mode] = XNEWVEC (move_table, N_REG_CLASSES);\n   for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n     if (contains_reg_of_mode[cl1][mode])\n       for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n@@ -1500,9 +1503,9 @@ init_move_cost (enum machine_mode mode)\n \n \t  if (last_move_cost[cl1][cl2] == 65535)\n \t    {\n-\t      move_cost[mode][cl1][cl2] = 65535;\n-\t      may_move_in_cost[mode][cl1][cl2] = 65535;\n-\t      may_move_out_cost[mode][cl1][cl2] = 65535;\n+\t      ira_register_move_cost[mode][cl1][cl2] = 65535;\n+\t      ira_may_move_in_cost[mode][cl1][cl2] = 65535;\n+\t      ira_may_move_out_cost[mode][cl1][cl2] = 65535;\n \t    }\n \t  else\n \t    {\n@@ -1513,115 +1516,37 @@ init_move_cost (enum machine_mode mode)\n \t\tif (ira_class_hard_regs_num[*p2] > 0\n \t\t    && (ira_reg_class_max_nregs[*p2][mode]\n \t\t\t<= ira_class_hard_regs_num[*p2]))\n-\t\t  cost = MAX (cost, move_cost[mode][cl1][*p2]);\n+\t\t  cost = MAX (cost, ira_register_move_cost[mode][cl1][*p2]);\n \n \t      for (p1 = &reg_class_subclasses[cl1][0];\n \t\t   *p1 != LIM_REG_CLASSES; p1++)\n \t\tif (ira_class_hard_regs_num[*p1] > 0\n \t\t    && (ira_reg_class_max_nregs[*p1][mode]\n \t\t\t<= ira_class_hard_regs_num[*p1]))\n-\t\t  cost = MAX (cost, move_cost[mode][*p1][cl2]);\n+\t\t  cost = MAX (cost, ira_register_move_cost[mode][*p1][cl2]);\n \n \t      ira_assert (cost <= 65535);\n-\t      move_cost[mode][cl1][cl2] = cost;\n+\t      ira_register_move_cost[mode][cl1][cl2] = cost;\n \n \t      if (ira_class_subset_p[cl1][cl2])\n-\t\tmay_move_in_cost[mode][cl1][cl2] = 0;\n+\t\tira_may_move_in_cost[mode][cl1][cl2] = 0;\n \t      else\n-\t\tmay_move_in_cost[mode][cl1][cl2] = cost;\n+\t\tira_may_move_in_cost[mode][cl1][cl2] = cost;\n \n \t      if (ira_class_subset_p[cl2][cl1])\n-\t\tmay_move_out_cost[mode][cl1][cl2] = 0;\n+\t\tira_may_move_out_cost[mode][cl1][cl2] = 0;\n \t      else\n-\t\tmay_move_out_cost[mode][cl1][cl2] = cost;\n+\t\tira_may_move_out_cost[mode][cl1][cl2] = cost;\n \t    }\n \t}\n     else\n       for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n \t{\n-\t  move_cost[mode][cl1][cl2] = 65535;\n-\t  may_move_in_cost[mode][cl1][cl2] = 65535;\n-\t  may_move_out_cost[mode][cl1][cl2] = 65535;\n-\t}\n-}\n-\n-/* Allocate and initialize IRA_REGISTER_MOVE_COST,\n-   IRA_MAX_REGISTER_MOVE_COST, IRA_MAY_MOVE_IN_COST,\n-   IRA_MAY_MOVE_OUT_COST, IRA_MAX_MAY_MOVE_IN_COST, and\n-   IRA_MAX_MAY_MOVE_OUT_COST for MODE if it is not done yet.  */\n-void\n-ira_init_register_move_cost (enum machine_mode mode)\n-{\n-  int cl1, cl2, cl3;\n-\n-  ira_assert (ira_register_move_cost[mode] == NULL\n-\t      && ira_max_register_move_cost[mode] == NULL\n-\t      && ira_may_move_in_cost[mode] == NULL\n-\t      && ira_may_move_out_cost[mode] == NULL\n-\t      && ira_max_may_move_in_cost[mode] == NULL\n-\t      && ira_max_may_move_out_cost[mode] == NULL);\n-  if (move_cost[mode] == NULL)\n-    init_move_cost (mode);\n-  ira_register_move_cost[mode] = move_cost[mode];\n-  /* Don't use ira_allocate because the tables exist out of scope of a\n-     IRA call.  */\n-  ira_max_register_move_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_register_move_cost[mode], ira_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    /* Some subclasses are to small to have enough registers to hold\n-       a value of MODE.  Just ignore them.  */\n-    if (ira_class_hard_regs_num[cl1] > 0\n-\t&& ira_reg_class_max_nregs[cl1][mode] <= ira_class_hard_regs_num[cl1])\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\tif (hard_reg_set_subset_p (reg_class_contents[cl1],\n-\t\t\t\t   reg_class_contents[cl2]))\n-\t  for (cl3 = 0; cl3 < N_REG_CLASSES; cl3++)\n-\t    {\n-\t      gcc_assert (ira_register_move_cost[mode][cl2][cl3]\n-\t\t\t  >= ira_register_move_cost[mode][cl1][cl3]);\n-\t      gcc_assert (ira_register_move_cost[mode][cl3][cl2]\n-\t\t\t  >= ira_register_move_cost[mode][cl3][cl1]);\n-\t    }\n-  ira_may_move_in_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_may_move_in_cost[mode], may_move_in_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  ira_may_move_out_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_may_move_out_cost[mode], may_move_out_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  ira_max_may_move_in_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_may_move_in_cost[mode], ira_max_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  ira_max_may_move_out_cost[mode]\n-    = (move_table *) xmalloc (sizeof (move_table) * N_REG_CLASSES);\n-  memcpy (ira_max_may_move_out_cost[mode], ira_max_register_move_cost[mode],\n-\t  sizeof (move_table) * N_REG_CLASSES);\n-  for (cl1 = 0; cl1 < N_REG_CLASSES; cl1++)\n-    if (contains_reg_of_mode[cl1][mode])\n-      for (cl2 = 0; cl2 < N_REG_CLASSES; cl2++)\n-\t{\n-\t  if (!contains_reg_of_mode[cl2][mode]\n-\t      || ira_class_hard_regs_num[cl2] == 0)\n-\t    continue;\n-\t  if (ira_class_subset_p[cl1][cl2])\n-\t    gcc_assert (ira_may_move_in_cost[mode][cl1][cl2] == 0);\n-\t  if (ira_class_subset_p[cl2][cl1])\n-\t    gcc_assert (ira_may_move_out_cost[mode][cl1][cl2] == 0);\n-\t  if (ira_class_subset_p[cl1][cl2])\n-\t    ira_max_may_move_in_cost[mode][cl1][cl2] = 0;\n-\t  if (ira_class_subset_p[cl2][cl1])\n-\t    ira_max_may_move_out_cost[mode][cl1][cl2] = 0;\n-\t  gcc_assert (ira_may_move_in_cost[mode][cl1][cl2]\n-\t\t      == ira_max_may_move_in_cost[mode][cl1][cl2]);\n-\t  gcc_assert (ira_may_move_out_cost[mode][cl1][cl2]\n-\t\t      == ira_max_may_move_out_cost[mode][cl1][cl2]);\n+\t  ira_register_move_cost[mode][cl1][cl2] = 65535;\n+\t  ira_may_move_in_cost[mode][cl1][cl2] = 65535;\n+\t  ira_may_move_out_cost[mode][cl1][cl2] = 65535;\n \t}\n }\n-\n \f\n \n /* This is called once during compiler work.  It sets up\n@@ -1630,23 +1555,11 @@ ira_init_register_move_cost (enum machine_mode mode)\n void\n ira_init_once (void)\n {\n-  int mode;\n-\n-  for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n-    {\n-      ira_register_move_cost[mode] = NULL;\n-      ira_max_register_move_cost[mode] = NULL;\n-      ira_may_move_in_cost[mode] = NULL;\n-      ira_may_move_out_cost[mode] = NULL;\n-      ira_max_may_move_in_cost[mode] = NULL;\n-      ira_max_may_move_out_cost[mode] = NULL;\n-    }\n   ira_init_costs_once ();\n }\n \n-/* Free ira_max_register_move_cost, ira_may_move_in_cost,\n-   ira_may_move_out_cost, ira_max_may_move_in_cost, and\n-   ira_max_may_move_out_cost for each mode.  */\n+/* Free ira_max_register_move_cost, ira_may_move_in_cost and\n+   ira_may_move_out_cost for each mode.  */\n static void\n free_register_move_costs (void)\n {\n@@ -1655,35 +1568,24 @@ free_register_move_costs (void)\n   /* Reset move_cost and friends, making sure we only free shared\n      table entries once.  */\n   for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n-    if (move_cost[mode])\n+    if (ira_register_move_cost[mode])\n       {\n-\tfor (i = 0; i < mode && move_cost[i] != move_cost[mode]; i++)\n+\tfor (i = 0;\n+\t     i < mode && (ira_register_move_cost[i]\n+\t\t\t  != ira_register_move_cost[mode]);\n+\t     i++)\n \t  ;\n \tif (i == mode)\n \t  {\n-\t    free (move_cost[mode]);\n-\t    free (may_move_in_cost[mode]);\n-\t    free (may_move_out_cost[mode]);\n+\t    free (ira_register_move_cost[mode]);\n+\t    free (ira_may_move_in_cost[mode]);\n+\t    free (ira_may_move_out_cost[mode]);\n \t  }\n       }\n-  memset (move_cost, 0, sizeof move_cost);\n-  memset (may_move_in_cost, 0, sizeof may_move_in_cost);\n-  memset (may_move_out_cost, 0, sizeof may_move_out_cost);\n+  memset (ira_register_move_cost, 0, sizeof ira_register_move_cost);\n+  memset (ira_may_move_in_cost, 0, sizeof ira_may_move_in_cost);\n+  memset (ira_may_move_out_cost, 0, sizeof ira_may_move_out_cost);\n   last_mode_for_init_move_cost = -1;\n-  for (mode = 0; mode < MAX_MACHINE_MODE; mode++)\n-    {\n-      free (ira_max_register_move_cost[mode]);\n-      free (ira_may_move_in_cost[mode]);\n-      free (ira_may_move_out_cost[mode]);\n-      free (ira_max_may_move_in_cost[mode]);\n-      free (ira_max_may_move_out_cost[mode]);\n-      ira_register_move_cost[mode] = NULL;\n-      ira_max_register_move_cost[mode] = NULL;\n-      ira_may_move_in_cost[mode] = NULL;\n-      ira_may_move_out_cost[mode] = NULL;\n-      ira_max_may_move_in_cost[mode] = NULL;\n-      ira_max_may_move_out_cost[mode] = NULL;\n-    }\n }\n \n /* This is called every time when register related information is"}]}