{"sha": "f9f166251f181ddcee64092d89aecbc1166ca706", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjlmMTY2MjUxZjE4MWRkY2VlNjQwOTJkODlhZWNiYzExNjZjYTcwNg==", "commit": {"author": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-23T21:29:55Z"}, "committer": {"name": "Patrick Palka", "email": "ppalka@redhat.com", "date": "2020-04-23T21:29:55Z"}, "message": "c++: Lambda in friend of constrained class [PR94645]\n\nIn the testcase below, when grokfndecl processes the operator() decl for the\nlambda inside the friend function foo, processing_template_decl is rightly 1,\nbut template_class_depth on the lambda's closure type incorrectly returns 0\ninstead of 1.\n\nSince processing_template_decl > template_class_depth, this makes grokfndecl\nthink that the operator() has its own set of template arguments, and so we\nattach the innermost set of constraints -- those belonging to struct l -- to the\noperator() decl.  We then get confused when checking constraints_satisfied_p on\nthe operator() because it doesn't have template information and yet has\nconstraints associated with it.\n\nThis patch fixes template_class_depth to return the correct template nesting\nlevel in cases like these, in that when it hits a friend function it walks into\nthe DECL_FRIEND_CONTEXT of the friend rather than into the CP_DECL_CONTEXT.\n\ngcc/cp/ChangeLog:\n\n\tPR c++/94645\n\t* pt.c (template_class_depth): Walk into the DECL_FRIEND_CONTEXT of a\n\tfriend declaration rather than into its CP_DECL_CONTEXT.\n\ngcc/testsuite/ChangeLog:\n\n\tPR c++/94645\n\t* g++.dg/cpp2a/concepts-lambda6.C: New test.", "tree": {"sha": "8f378f0c2f476461596a4449aebabed0482a84db", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8f378f0c2f476461596a4449aebabed0482a84db"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f9f166251f181ddcee64092d89aecbc1166ca706", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f166251f181ddcee64092d89aecbc1166ca706", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f9f166251f181ddcee64092d89aecbc1166ca706", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f9f166251f181ddcee64092d89aecbc1166ca706/comments", "author": null, "committer": null, "parents": [{"sha": "b78868459fda4de0417e52e1d46388ca75a4e74d", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b78868459fda4de0417e52e1d46388ca75a4e74d", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b78868459fda4de0417e52e1d46388ca75a4e74d"}], "stats": {"total": 37, "additions": 36, "deletions": 1}, "files": [{"sha": "6506f288e0598f54882df9b12fa5722996f85e78", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=f9f166251f181ddcee64092d89aecbc1166ca706", "patch": "@@ -1,3 +1,9 @@\n+2020-04-23  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94645\n+\t* pt.c (template_class_depth): Walk into the DECL_FRIEND_CONTEXT of a\n+\tfriend declaration rather than into its CP_DECL_CONTEXT.\n+\n 2020-04-23 Iain Sandoe <iain@sandoe.co.uk>\n \n \tPR c++/94288"}, {"sha": "66308a2d29584dd86ffcaa668147c5b5ceeb71b5", "filename": "gcc/cp/pt.c", "status": "modified", "additions": 6, "deletions": 1, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Fcp%2Fpt.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Fcp%2Fpt.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fpt.c?ref=f9f166251f181ddcee64092d89aecbc1166ca706", "patch": "@@ -390,7 +390,12 @@ template_class_depth (tree type)\n \t++depth;\n \n       if (DECL_P (type))\n-\ttype = CP_DECL_CONTEXT (type);\n+\t{\n+\t  if (tree fctx = DECL_FRIEND_CONTEXT (type))\n+\t    type = fctx;\n+\t  else\n+\t    type = CP_DECL_CONTEXT (type);\n+\t}\n       else if (LAMBDA_TYPE_P (type) && LAMBDA_TYPE_EXTRA_SCOPE (type))\n \ttype = LAMBDA_TYPE_EXTRA_SCOPE (type);\n       else"}, {"sha": "e0df5bc0a99b0eaa74c9a202257d75c1dc79e310", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f9f166251f181ddcee64092d89aecbc1166ca706", "patch": "@@ -1,3 +1,8 @@\n+2020-04-23  Patrick Palka  <ppalka@redhat.com>\n+\n+\tPR c++/94645\n+\t* g++.dg/cpp2a/concepts-lambda6.C: New test.\n+\n 2019-04-23  Eric Botcazou  <ebotcazou@adacore.com>\n \n \t* g++.dg/opt/store-merging-4.C: New test."}, {"sha": "0b7c04562e9bc29fd544407a294be475736a7200", "filename": "gcc/testsuite/g++.dg/cpp2a/concepts-lambda6.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f9f166251f181ddcee64092d89aecbc1166ca706/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fcpp2a%2Fconcepts-lambda6.C?ref=f9f166251f181ddcee64092d89aecbc1166ca706", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/94645\n+// { dg-do compile { target concepts } }\n+\n+struct unordered_map {\n+  int cend() const noexcept;\n+};\n+\n+template <typename a> concept HasMapInterface = requires(a t) { t.cend(); };\n+\n+template <typename Mapper> requires HasMapInterface<decltype(Mapper::map())>\n+struct l {\n+  friend void foo(l opt) { ([]() {})(); }\n+};\n+\n+struct p {\n+  static unordered_map map();\n+};\n+\n+void g(l<p> *y) { foo(*y); }"}]}