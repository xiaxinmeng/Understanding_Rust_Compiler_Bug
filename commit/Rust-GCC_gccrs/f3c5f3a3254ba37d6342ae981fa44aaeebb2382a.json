{"sha": "f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjNjNWYzYTMyNTRiYTM3ZDYzNDJhZTk4MWZhNDRhYWVlYmIyMzgyYQ==", "commit": {"author": {"name": "Bin Cheng", "email": "bin.cheng@arm.com", "date": "2015-09-17T03:08:41Z"}, "committer": {"name": "Bin Cheng", "email": "amker@gcc.gnu.org", "date": "2015-09-17T03:08:41Z"}, "message": "tree-ssa-loop-niter.c (tree_simplify_using_condition_1): New parameter.\n\n\n\t* tree-ssa-loop-niter.c (tree_simplify_using_condition_1): New\n\tparameter.\n\t(tree_simplify_using_condition): Ditto.\n\t(simplify_using_initial_conditions): Ditto.\n\t(loop_exits_before_overflow): Pass new argument to function\n\tsimplify_using_initial_conditions.  Remove case for type conversions\n\tsimplification.\n\t* tree-ssa-loop-niter.h (simplify_using_initial_conditions): New\n\tparameter.\n\t* tree-scalar-evolution.c (simple_iv): Simplify type conversions\n\tin iv base using loop initial conditions.\n\n\tgcc/testsuite/ChangeLog\n\t* gcc.dg/tree-ssa/loop-bound-2.c: New test.\n\t* gcc.dg/tree-ssa/loop-bound-4.c: New test.\n\t* gcc.dg/tree-ssa/loop-bound-6.c: New test.\n\nFrom-SVN: r227843", "tree": {"sha": "8ed39fce7ced601faeca17f5996649528ce2ca93", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/8ed39fce7ced601faeca17f5996649528ce2ca93"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/comments", "author": null, "committer": null, "parents": [{"sha": "e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e8ae63bb6ccbb7ec3dc5fbfbaf8236b71c59650e"}], "stats": {"total": 368, "additions": 234, "deletions": 134}, "files": [{"sha": "435e2791524c1e85a795a63c1d72b0df5bc44d94", "filename": "gcc/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -1,3 +1,17 @@\n+2015-09-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* tree-ssa-loop-niter.c (tree_simplify_using_condition_1): New\n+\tparameter.\n+\t(tree_simplify_using_condition): Ditto.\n+\t(simplify_using_initial_conditions): Ditto.\n+\t(loop_exits_before_overflow): Pass new argument to function\n+\tsimplify_using_initial_conditions.  Remove case for type conversions\n+\tsimplification.\n+\t* tree-ssa-loop-niter.h (simplify_using_initial_conditions): New\n+\tparameter.\n+\t* tree-scalar-evolution.c (simple_iv): Simplify type conversions\n+\tin iv base using loop initial conditions.\n+\n 2015-09-16  Jeff Law  <law@redhat.com>\n \n \tPR tree-optimization/47679"}, {"sha": "bea92585038d0cd314a02940c09a05b7016fe952", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -1,3 +1,9 @@\n+2015-09-17  Bin Cheng  <bin.cheng@arm.com>\n+\n+\t* gcc.dg/tree-ssa/loop-bound-2.c: New test.\n+\t* gcc.dg/tree-ssa/loop-bound-4.c: New test.\n+\t* gcc.dg/tree-ssa/loop-bound-6.c: New test.\n+\n 2015-09-16  John Marino  <gnugcc@marino.st>\n \n \t* gfortran.dg/read_dir.f90: XFAIL this testcase on DragonFly."}, {"sha": "802dd290e501fc095c4c299366636ffd80372220", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-2.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-2.c?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (signed char s, signed char l)\n+{\n+  signed char i;\n+  int sum = 0;\n+\n+  for (i = s; i < l; i++)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 254\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 255\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"zero if \" \"ivopts\" } } */"}, {"sha": "b9d7d4196aa628d8015f77cedafa3757eb10826e", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-4.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-4.c?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (signed char s, signed char l)\n+{\n+  signed char i;\n+  int sum = 0;\n+\n+  for (i = s; i > l; i--)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 254\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 255\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"zero if \" \"ivopts\" } } */"}, {"sha": "8319434985db9f9f692f44a5c94b89bbd2b23497", "filename": "gcc/testsuite/gcc.dg/tree-ssa/loop-bound-6.c", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Floop-bound-6.c?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -0,0 +1,23 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fdump-tree-ivopts-details\" } */\n+\n+int *a;\n+\n+int\n+foo (signed char s)\n+{\n+  signed char i;\n+  int sum = 0;\n+\n+  for (i = s; i > 0; i--)\n+    {\n+      sum += a[i];\n+    }\n+\n+  return sum;\n+}\n+\n+/* Check loop niter bound information.  */\n+/* { dg-final { scan-tree-dump \"bounded by 126\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"bounded by 127\" \"ivopts\" } } */\n+/* { dg-final { scan-tree-dump-not \"zero if \" \"ivopts\" } } */"}, {"sha": "328846b898c1690e17c468399856e3214dd453bc", "filename": "gcc/tree-scalar-evolution.c", "status": "modified", "additions": 80, "deletions": 2, "changes": 82, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-scalar-evolution.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-scalar-evolution.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-scalar-evolution.c?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -3234,8 +3234,10 @@ bool\n simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n \t   affine_iv *iv, bool allow_nonconstant_step)\n {\n-  tree type, ev;\n-  bool folded_casts;\n+  enum tree_code code;\n+  tree type, ev, base, e, stop;\n+  wide_int extreme;\n+  bool folded_casts, overflow;\n \n   iv->base = NULL_TREE;\n   iv->step = NULL_TREE;\n@@ -3276,6 +3278,82 @@ simple_iv (struct loop *wrto_loop, struct loop *use_loop, tree op,\n   iv->no_overflow = (!folded_casts && ANY_INTEGRAL_TYPE_P (type)\n \t\t     && TYPE_OVERFLOW_UNDEFINED (type));\n \n+  /* Try to simplify iv base:\n+\n+       (signed T) ((unsigned T)base + step) ;; TREE_TYPE (base) == signed T\n+\t == (signed T)(unsigned T)base + step\n+\t == base + step\n+\n+     If we can prove operation (base + step) doesn't overflow or underflow.\n+     Specifically, we try to prove below conditions are satisfied:\n+\n+\t     base <= UPPER_BOUND (type) - step  ;;step > 0\n+\t     base >= LOWER_BOUND (type) - step  ;;step < 0\n+\n+     This is done by proving the reverse conditions are false using loop's\n+     initial conditions.\n+\n+     The is necessary to make loop niter, or iv overflow analysis easier\n+     for below example:\n+\n+       int foo (int *a, signed char s, signed char l)\n+\t {\n+\t   signed char i;\n+\t   for (i = s; i < l; i++)\n+\t     a[i] = 0;\n+\t   return 0;\n+\t  }\n+\n+     Note variable I is firstly converted to type unsigned char, incremented,\n+     then converted back to type signed char.  */\n+\n+  if (wrto_loop->num != use_loop->num)\n+    return true;\n+\n+  if (!CONVERT_EXPR_P (iv->base) || TREE_CODE (iv->step) != INTEGER_CST)\n+    return true;\n+\n+  type = TREE_TYPE (iv->base);\n+  e = TREE_OPERAND (iv->base, 0);\n+  if (TREE_CODE (e) != PLUS_EXPR\n+      || TREE_CODE (TREE_OPERAND (e, 1)) != INTEGER_CST\n+      || !tree_int_cst_equal (iv->step,\n+\t\t\t      fold_convert (type, TREE_OPERAND (e, 1))))\n+    return true;\n+  e = TREE_OPERAND (e, 0);\n+  if (!CONVERT_EXPR_P (e))\n+    return true;\n+  base = TREE_OPERAND (e, 0);\n+  if (!useless_type_conversion_p (type, TREE_TYPE (base)))\n+    return true;\n+\n+  if (tree_int_cst_sign_bit (iv->step))\n+    {\n+      code = LT_EXPR;\n+      extreme = wi::min_value (type);\n+    }\n+  else\n+    {\n+      code = GT_EXPR;\n+      extreme = wi::max_value (type);\n+    }\n+  overflow = false;\n+  extreme = wi::sub (extreme, iv->step, TYPE_SIGN (type), &overflow);\n+  if (overflow)\n+    return true;\n+  e = fold_build2 (code, boolean_type_node, base,\n+\t\t   wide_int_to_tree (type, extreme));\n+  stop = (TREE_CODE (base) == SSA_NAME) ? base : NULL;\n+  e = simplify_using_initial_conditions (use_loop, e, stop);\n+  if (!integer_zerop (e))\n+    return true;\n+\n+  if (POINTER_TYPE_P (TREE_TYPE (base)))\n+    code = POINTER_PLUS_EXPR;\n+  else\n+    code = PLUS_EXPR;\n+\n+  iv->base = fold_build2 (code, TREE_TYPE (base), base, iv->step);\n   return true;\n }\n "}, {"sha": "0309f4adff668d23b7dbcc719fb86ea0ee3c6714", "filename": "gcc/tree-ssa-loop-niter.c", "status": "modified", "additions": 63, "deletions": 132, "changes": 195, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-ssa-loop-niter.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-ssa-loop-niter.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.c?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -1926,7 +1926,7 @@ expand_simple_operations (tree expr, tree stop)\n    expression (or EXPR unchanged, if no simplification was possible).  */\n \n static tree\n-tree_simplify_using_condition_1 (tree cond, tree expr)\n+tree_simplify_using_condition_1 (tree cond, tree expr, tree stop)\n {\n   bool changed;\n   tree e, te, e0, e1, e2, notcond;\n@@ -1941,17 +1941,17 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n     {\n       changed = false;\n \n-      e0 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 0));\n+      e0 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 0), stop);\n       if (TREE_OPERAND (expr, 0) != e0)\n \tchanged = true;\n \n-      e1 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 1));\n+      e1 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 1), stop);\n       if (TREE_OPERAND (expr, 1) != e1)\n \tchanged = true;\n \n       if (code == COND_EXPR)\n \t{\n-\t  e2 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 2));\n+\t  e2 = tree_simplify_using_condition_1 (cond, TREE_OPERAND (expr, 2), stop);\n \t  if (TREE_OPERAND (expr, 2) != e2)\n \t    changed = true;\n \t}\n@@ -2014,7 +2014,7 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n \treturn boolean_true_node;\n     }\n \n-  te = expand_simple_operations (expr);\n+  te = expand_simple_operations (expr, stop);\n \n   /* Check whether COND ==> EXPR.  */\n   notcond = invert_truthvalue (cond);\n@@ -2038,19 +2038,19 @@ tree_simplify_using_condition_1 (tree cond, tree expr)\n    the loop do not cause us to fail.  */\n \n static tree\n-tree_simplify_using_condition (tree cond, tree expr)\n+tree_simplify_using_condition (tree cond, tree expr, tree stop)\n {\n-  cond = expand_simple_operations (cond);\n+  cond = expand_simple_operations (cond, stop);\n \n-  return tree_simplify_using_condition_1 (cond, expr);\n+  return tree_simplify_using_condition_1 (cond, expr, stop);\n }\n \n /* Tries to simplify EXPR using the conditions on entry to LOOP.\n    Returns the simplified expression (or EXPR unchanged, if no\n-   simplification was possible).*/\n+   simplification was possible).  */\n \n-static tree\n-simplify_using_initial_conditions (struct loop *loop, tree expr)\n+tree\n+simplify_using_initial_conditions (struct loop *loop, tree expr, tree stop)\n {\n   edge e;\n   basic_block bb;\n@@ -2082,7 +2082,7 @@ simplify_using_initial_conditions (struct loop *loop, tree expr)\n \t\t\t  gimple_cond_rhs (stmt));\n       if (e->flags & EDGE_FALSE_VALUE)\n \tcond = invert_truthvalue (cond);\n-      expr = tree_simplify_using_condition (cond, expr);\n+      expr = tree_simplify_using_condition (cond, expr, stop);\n       /* Break if EXPR is simplified to const values.  */\n       if (expr && (integer_zerop (expr) || integer_nonzerop (expr)))\n \tbreak;\n@@ -4114,137 +4114,68 @@ loop_exits_before_overflow (tree base, tree step,\n      help of analyzed loop control IV.  This is done only for IVs with\n      constant step because otherwise we don't have the information.  */\n   if (TREE_CODE (step) == INTEGER_CST)\n-    for (civ = loop->control_ivs; civ; civ = civ->next)\n-      {\n-\tenum tree_code code;\n-\ttree stepped, extreme, civ_type = TREE_TYPE (civ->step);\n-\n-\t/* Have to consider type difference because operand_equal_p ignores\n-\t   that for constants.  */\n-\tif (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (civ_type)\n-\t    || element_precision (type) != element_precision (civ_type))\n-\t  continue;\n-\n-\t/* Only consider control IV with same step.  */\n-\tif (!operand_equal_p (step, civ->step, 0))\n-\t  continue;\n-\n-\t/* Done proving if this is a no-overflow control IV.  */\n-\tif (operand_equal_p (base, civ->base, 0))\n-\t  return true;\n-\n-\t/* If this is a before stepping control IV, in other words, we have\n-\n-\t     {civ_base, step} = {base + step, step}\n-\n-\t   Because civ {base + step, step} doesn't overflow during loop\n-\t   iterations, {base, step} will not overflow if we can prove the\n-\t   operation \"base + step\" does not overflow.  Specifically, we try\n-\t   to prove below conditions are satisfied:\n-\n-\t     base <= UPPER_BOUND (type) - step  ;;step > 0\n-\t     base >= LOWER_BOUND (type) - step  ;;step < 0\n-\n-\t   by proving the reverse conditions are false using loop's initial\n-\t   condition.  */\n-\tif (POINTER_TYPE_P (TREE_TYPE (base)))\n-\t  code = POINTER_PLUS_EXPR;\n-\telse\n-\t  code = PLUS_EXPR;\n+    {\n+      tree stop = (TREE_CODE (base) == SSA_NAME) ? base : NULL;\n \n-\tstepped = fold_build2 (code, TREE_TYPE (base), base, step);\n-\tif (operand_equal_p (stepped, civ->base, 0))\n-\t  {\n-\t    if (tree_int_cst_sign_bit (step))\n-\t      {\n-\t\tcode = LT_EXPR;\n-\t\textreme = lower_bound_in_type (type, type);\n-\t      }\n-\t    else\n-\t      {\n-\t\tcode = GT_EXPR;\n-\t\textreme = upper_bound_in_type (type, type);\n-\t      }\n-\t    extreme = fold_build2 (MINUS_EXPR, type, extreme, step);\n-\t    e = fold_build2 (code, boolean_type_node, base, extreme);\n-\t    e = simplify_using_initial_conditions (loop, e);\n-\t    if (integer_zerop (e))\n-\t      return true;\n+      for (civ = loop->control_ivs; civ; civ = civ->next)\n+\t{\n+\t  enum tree_code code;\n+\t  tree stepped, extreme, civ_type = TREE_TYPE (civ->step);\n \n+\t  /* Have to consider type difference because operand_equal_p ignores\n+\t     that for constants.  */\n+\t  if (TYPE_UNSIGNED (type) != TYPE_UNSIGNED (civ_type)\n+\t      || element_precision (type) != element_precision (civ_type))\n \t    continue;\n-\t  }\n-\n-\t/* Similar to above, only in this case we have:\n-\n-\t     {civ_base, step} = {(signed T)((unsigned T)base + step), step}\n-\t     && TREE_TYPE (civ_base) = signed T.\n-\n-\t   We prove that below condition is satisfied:\n-\n-\t     (signed T)((unsigned T)base + step)\n-\t       == (signed T)(unsigned T)base + step\n-\t       == base + step\n \n-\t   because of exact the same reason as above.  This also proves\n-\t   there is no overflow in the operation \"base + step\", thus the\n-\t   induction variable {base, step} during loop iterations.\n+\t  /* Only consider control IV with same step.  */\n+\t  if (!operand_equal_p (step, civ->step, 0))\n+\t    continue;\n \n-\t   This is necessary to handle cases as below:\n+\t  /* Done proving if this is a no-overflow control IV.  */\n+\t  if (operand_equal_p (base, civ->base, 0))\n+\t    return true;\n \n-\t     int foo (int *a, signed char s, signed char l)\n-\t       {\n-\t\t signed char i;\n-\t\t for (i = s; i < l; i++)\n-\t\t   a[i] = 0;\n-\t\t return 0;\n-\t       }\n+\t  /* If this is a before stepping control IV, in other words, we have\n \n-\t   The variable I is firstly converted to type unsigned char,\n-\t   incremented, then converted back to type signed char.  */\n-\tif (!CONVERT_EXPR_P (civ->base) || TREE_TYPE (civ->base) != type)\n-\t  continue;\n-\te = TREE_OPERAND (civ->base, 0);\n-\tif (TREE_CODE (e) != PLUS_EXPR\n-\t    || TREE_CODE (TREE_OPERAND (e, 1)) != INTEGER_CST\n-\t    || !operand_equal_p (step,\n-\t\t\t\t fold_convert (type,\n-\t\t\t\t\t       TREE_OPERAND (e, 1)), 0))\n-\t  continue;\n-\te = TREE_OPERAND (e, 0);\n-\tif (!CONVERT_EXPR_P (e) || !operand_equal_p (e, unsigned_base, 0))\n-\t  continue;\n-\te = TREE_OPERAND (e, 0);\n-\t/* It may still be possible to prove no overflow even if condition\n-\t   \"operand_equal_p (e, base, 0)\" isn't satisfied here, like below\n-\t   example:\n+\t       {civ_base, step} = {base + step, step}\n \n-\t     e             : ssa_var                 ; unsigned long type\n-\t     base          : (int) ssa_var\n-\t     unsigned_base : (unsigned int) ssa_var\n+\t     Because civ {base + step, step} doesn't overflow during loop\n+\t     iterations, {base, step} will not overflow if we can prove the\n+\t     operation \"base + step\" does not overflow.  Specifically, we try\n+\t     to prove below conditions are satisfied:\n \n-\t   Unfortunately this is a rare case observed during GCC profiled\n-\t   bootstrap.  See PR66638 for more information.\n+\t       base <= UPPER_BOUND (type) - step  ;;step > 0\n+\t       base >= LOWER_BOUND (type) - step  ;;step < 0\n \n-\t   For now, we just skip the possibility.  */\n-\tif (!operand_equal_p (e, base, 0))\n-\t  continue;\n+\t     by proving the reverse conditions are false using loop's initial\n+\t     condition.  */\n+\t  if (POINTER_TYPE_P (TREE_TYPE (base)))\n+\t    code = POINTER_PLUS_EXPR;\n+\t  else\n+\t    code = PLUS_EXPR;\n \n-\tif (tree_int_cst_sign_bit (step))\n-\t  {\n-\t    code = LT_EXPR;\n-\t    extreme = lower_bound_in_type (type, type);\n-\t  }\n-\telse\n-\t  {\n-\t    code = GT_EXPR;\n-\t    extreme = upper_bound_in_type (type, type);\n-\t  }\n-\textreme = fold_build2 (MINUS_EXPR, type, extreme, step);\n-\te = fold_build2 (code, boolean_type_node, base, extreme);\n-\te = simplify_using_initial_conditions (loop, e);\n-\tif (integer_zerop (e))\n-\t  return true;\n-      }\n+\t  stepped = fold_build2 (code, TREE_TYPE (base), base, step);\n+\t  if (operand_equal_p (stepped, civ->base, 0))\n+\t    {\n+\t      if (tree_int_cst_sign_bit (step))\n+\t\t{\n+\t\t  code = LT_EXPR;\n+\t\t  extreme = lower_bound_in_type (type, type);\n+\t\t}\n+\t      else\n+\t\t{\n+\t\t  code = GT_EXPR;\n+\t\t  extreme = upper_bound_in_type (type, type);\n+\t\t}\n+\t      extreme = fold_build2 (MINUS_EXPR, type, extreme, step);\n+\t      e = fold_build2 (code, boolean_type_node, base, extreme);\n+\t      e = simplify_using_initial_conditions (loop, e, stop);\n+\t      if (integer_zerop (e))\n+\t\treturn true;\n+\t    }\n+        }\n+    }\n \n   return false;\n }"}, {"sha": "1442fe965d2a350cdd13f26e56e24c1173ba441b", "filename": "gcc/tree-ssa-loop-niter.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-ssa-loop-niter.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f3c5f3a3254ba37d6342ae981fa44aaeebb2382a/gcc%2Ftree-ssa-loop-niter.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-niter.h?ref=f3c5f3a3254ba37d6342ae981fa44aaeebb2382a", "patch": "@@ -21,6 +21,8 @@ along with GCC; see the file COPYING3.  If not see\n #define GCC_TREE_SSA_LOOP_NITER_H\n \n extern tree expand_simple_operations (tree, tree = NULL);\n+extern tree simplify_using_initial_conditions (struct loop *,\n+\t\t\t\t\t       tree, tree = NULL);\n extern bool loop_only_exit_p (const struct loop *, const_edge);\n extern bool number_of_iterations_exit (struct loop *, edge,\n \t\t\t\t       struct tree_niter_desc *niter, bool,"}]}