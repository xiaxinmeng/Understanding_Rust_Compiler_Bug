{"sha": "6c7cf1f021db7313abecc4351b973d521c75bcaa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NmM3Y2YxZjAyMWRiNzMxM2FiZWNjNDM1MWI5NzNkNTIxYzc1YmNhYQ==", "commit": {"author": {"name": "Uros Bizjak", "email": "uros@kss-loka.si", "date": "2004-04-06T19:34:33Z"}, "committer": {"name": "Roger Sayle", "email": "sayle@gcc.gnu.org", "date": "2004-04-06T19:34:33Z"}, "message": "builtins.c: Implement support for sincos function.\n\n2004-04-06  Uros Bizjak  <uros@kss-loka.si>\n\n\t* builtins.c: Implement support for sincos function.\n\t(expand_builtin_mathfn): Remove BUILT_IN_SIN{,F,L} and\n\tBUILT_IN_COS{,F,L}.\n\t(expand_builtin_mathfn_3): New function.\n\t(expand_builtin): Expand BUILT_IN_SIN{,F,L} and\n\tBUILT_IN_COS{,F,L} using expand_builtin_mathfn_3 if\n\tflag_unsafe_math_optimization is set.\n\n\t* optabs.h (enum optab_index): Add new OTI_sincos.\n\t(sincos_optab): Define corresponding macro.\n\n\t* optabs.c (init_optabs): Initialize sincos_optab.\n\t(expand_twoval_unop): New function.\n\n\t* genopinit.c (optabs): Implement sincos_optab using sincos?f3\n\tpatterns.\n\n\t* reg-stack.c (subst_stack_regs_pat): Handle UNSPEC_SINCOS_COS\n\tand UNSPEC_SINCOS_SIN.\n\n\t* config/i386/i386.md (sincosdf3, sincossf3, *sincosextendsfdf3,\n\tsincosxf3): New patterns to implement sincos, sincosf and sincosl\n\tbuilt-ins as inline x87 intrinsics. Define splits for\n\tsindf2, sinsf2, *sinextendsfdf2, sinxf2, cosdf2,\n\tcossf2, *cosextendsfdf2 and cosxf2 patterns from corresponding\n\tsincos patterns.\n\t(sindf2, sinsf2, sinxf2): Rename to *sindf2, *sinsf2, *sinxf2.\n\t(cosdf2, cossf2, cosxf2): Rename to *cosdf2, *cossf2, *cosxf2.\n\n\t(UNSPEC_SINCOS_SIN, UNPEC_SINCOS_COS): New unspecs to represent\n\tx87's unspec insn.\n\n\t* gcc.dg/builtins-36.c: New test.\n\nFrom-SVN: r80463", "tree": {"sha": "154509061a748c219394d85b40f993c80d2f7670", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/154509061a748c219394d85b40f993c80d2f7670"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/6c7cf1f021db7313abecc4351b973d521c75bcaa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7cf1f021db7313abecc4351b973d521c75bcaa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6c7cf1f021db7313abecc4351b973d521c75bcaa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6c7cf1f021db7313abecc4351b973d521c75bcaa/comments", "author": null, "committer": null, "parents": [{"sha": "23bd1514c1a09dfb60b93640f2e70d311745b430", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/23bd1514c1a09dfb60b93640f2e70d311745b430", "html_url": "https://github.com/Rust-GCC/gccrs/commit/23bd1514c1a09dfb60b93640f2e70d311745b430"}], "stats": {"total": 609, "additions": 588, "deletions": 21}, "files": [{"sha": "a6df24a238a99c6215206f917650b3421d9fb72c", "filename": "gcc/ChangeLog", "status": "modified", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -1,3 +1,37 @@\n+2004-04-06  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* builtins.c: Implement support for sincos function.\n+\t(expand_builtin_mathfn): Remove BUILT_IN_SIN{,F,L} and\n+\tBUILT_IN_COS{,F,L}.\n+\t(expand_builtin_mathfn_3): New function.\n+\t(expand_builtin): Expand BUILT_IN_SIN{,F,L} and\n+\tBUILT_IN_COS{,F,L} using expand_builtin_mathfn_3 if\n+\tflag_unsafe_math_optimization is set.\n+\n+\t* optabs.h (enum optab_index): Add new OTI_sincos.\n+\t(sincos_optab): Define corresponding macro.\n+\n+\t* optabs.c (init_optabs): Initialize sincos_optab.\n+\t(expand_twoval_unop): New function.\n+\n+\t* genopinit.c (optabs): Implement sincos_optab using sincos?f3\n+\tpatterns.\n+\n+\t* reg-stack.c (subst_stack_regs_pat): Handle UNSPEC_SINCOS_COS\n+\tand UNSPEC_SINCOS_SIN.\n+\n+\t* config/i386/i386.md (sincosdf3, sincossf3, *sincosextendsfdf3,\n+\tsincosxf3): New patterns to implement sincos, sincosf and sincosl\n+\tbuilt-ins as inline x87 intrinsics. Define splits for\n+\tsindf2, sinsf2, *sinextendsfdf2, sinxf2, cosdf2,\n+\tcossf2, *cosextendsfdf2 and cosxf2 patterns from corresponding\n+\tsincos patterns.\n+\t(sindf2, sinsf2, sinxf2): Rename to *sindf2, *sinsf2, *sinxf2.\n+\t(cosdf2, cossf2, cosxf2): Rename to *cosdf2, *cossf2, *cosxf2.\n+\n+\t(UNSPEC_SINCOS_SIN, UNPEC_SINCOS_COS): New unspecs to represent\n+\tx87's unspec insn.\n+\n 2004-04-06  Devang Patel  <dpatel@apple.com>\n \n \tPR 14467"}, {"sha": "b0d0d48f2fdd2a9fe78931c45a4ee398d66e7cab", "filename": "gcc/builtins.c", "status": "modified", "additions": 147, "deletions": 15, "changes": 162, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fbuiltins.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fbuiltins.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fbuiltins.c?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -94,6 +94,7 @@ static rtx expand_builtin_classify_type (tree);\n static void expand_errno_check (tree, rtx);\n static rtx expand_builtin_mathfn (tree, rtx, rtx);\n static rtx expand_builtin_mathfn_2 (tree, rtx, rtx);\n+static rtx expand_builtin_mathfn_3 (tree, rtx, rtx);\n static rtx expand_builtin_constant_p (tree, enum machine_mode);\n static rtx expand_builtin_args_info (tree);\n static rtx expand_builtin_next_arg (tree);\n@@ -1520,7 +1521,7 @@ expand_errno_check (tree exp, rtx target)\n }\n \n \n-/* Expand a call to one of the builtin math functions (sin, cos, or sqrt).\n+/* Expand a call to one of the builtin math functions (sqrt, exp, or log).\n    Return 0 if a normal call should be emitted rather than expanding the\n    function in-line.  EXP is the expression that is a call to the builtin\n    function; if convenient, the result should be placed in TARGET.\n@@ -1544,14 +1545,6 @@ expand_builtin_mathfn (tree exp, rtx target, rtx subtarget)\n \n   switch (DECL_FUNCTION_CODE (fndecl))\n     {\n-    case BUILT_IN_SIN:\n-    case BUILT_IN_SINF:\n-    case BUILT_IN_SINL:\n-      builtin_optab = sin_optab; break;\n-    case BUILT_IN_COS:\n-    case BUILT_IN_COSF:\n-    case BUILT_IN_COSL:\n-      builtin_optab = cos_optab; break;\n     case BUILT_IN_SQRT:\n     case BUILT_IN_SQRTF:\n     case BUILT_IN_SQRTL:\n@@ -1815,6 +1808,138 @@ expand_builtin_mathfn_2 (tree exp, rtx target, rtx subtarget)\n   return target;\n }\n \n+/* Expand a call to the builtin sin and cos math functions.\n+   Return 0 if a normal call should be emitted rather than expanding the\n+   function in-line.  EXP is the expression that is a call to the builtin\n+   function; if convenient, the result should be placed in TARGET.\n+   SUBTARGET may be used as the target for computing one of EXP's\n+   operands.  */\n+\n+static rtx\n+expand_builtin_mathfn_3 (tree exp, rtx target, rtx subtarget)\n+{\n+  optab builtin_optab;\n+  rtx op0, insns, before_call;\n+  tree fndecl = get_callee_fndecl (exp);\n+  tree arglist = TREE_OPERAND (exp, 1);\n+  enum machine_mode mode;\n+  bool errno_set = false;\n+  tree arg, narg;\n+\n+  if (!validate_arglist (arglist, REAL_TYPE, VOID_TYPE))\n+    return 0;\n+\n+  arg = TREE_VALUE (arglist);\n+\n+  switch (DECL_FUNCTION_CODE (fndecl))\n+    {\n+    case BUILT_IN_SIN:\n+    case BUILT_IN_SINF:\n+    case BUILT_IN_SINL:\n+    case BUILT_IN_COS:\n+    case BUILT_IN_COSF:\n+    case BUILT_IN_COSL:\n+      builtin_optab = sincos_optab; break;\n+    default:\n+      abort ();\n+    }\n+\n+  /* Make a suitable register to place result in.  */\n+  mode = TYPE_MODE (TREE_TYPE (exp));\n+\n+  if (! flag_errno_math || ! HONOR_NANS (mode))\n+    errno_set = false;\n+\n+  /* Check if sincos insn is available, otherwise fallback\n+     to sin or cos insn. */\n+  if (builtin_optab->handlers[(int) mode].insn_code == CODE_FOR_nothing) {\n+    switch (DECL_FUNCTION_CODE (fndecl))\n+      {\n+      case BUILT_IN_SIN:\n+      case BUILT_IN_SINF:\n+      case BUILT_IN_SINL:\n+\tbuiltin_optab = sin_optab; break;\n+      case BUILT_IN_COS:\n+      case BUILT_IN_COSF:\n+      case BUILT_IN_COSL:\n+\tbuiltin_optab = cos_optab; break;\n+      default:\n+\tabort();\n+      }\n+  }\n+\n+  /* Before working hard, check whether the instruction is available.  */\n+  if (builtin_optab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      target = gen_reg_rtx (mode);\n+\n+      /* Wrap the computation of the argument in a SAVE_EXPR, as we may\n+\t need to expand the argument again.  This way, we will not perform\n+\t side-effects more the once.  */\n+      narg = save_expr (arg);\n+      if (narg != arg)\n+\t{\n+\t  arglist = build_tree_list (NULL_TREE, arg);\n+\t  exp = build_function_call_expr (fndecl, arglist);\n+\t}\n+\n+      op0 = expand_expr (arg, subtarget, VOIDmode, 0);\n+\n+      emit_queue ();\n+      start_sequence ();\n+\n+      /* Compute into TARGET.\n+\t Set TARGET to wherever the result comes back.  */\n+      if (builtin_optab == sincos_optab)\n+\t{\n+\t  switch (DECL_FUNCTION_CODE (fndecl))\n+\t    {\n+\t    case BUILT_IN_SIN:\n+\t    case BUILT_IN_SINF:\n+\t    case BUILT_IN_SINL:\n+\t      if (! expand_twoval_unop(builtin_optab, 0, target, op0, 0))    \n+\t\tabort();\n+\t      break;\n+\t    case BUILT_IN_COS:\n+\t    case BUILT_IN_COSF:\n+\t    case BUILT_IN_COSL:\n+\t      if (! expand_twoval_unop(builtin_optab, target, 0, op0, 0))\n+\t\tabort();\n+\t      break;\n+\t    default:\n+\t      abort();\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  target = expand_unop (mode, builtin_optab, op0, target, 0);\n+\t}\n+\n+      if (target != 0)\n+\t{\n+\t  if (errno_set)\n+\t    expand_errno_check (exp, target);\n+\n+\t  /* Output the entire sequence.  */\n+\t  insns = get_insns ();\n+\t  end_sequence ();\n+\t  emit_insn (insns);\n+\t  return target;\n+\t}\n+\n+      /* If we were unable to expand via the builtin, stop the sequence\n+\t (without outputting the insns) and call to the library function\n+\t with the stabilized argument list.  */\n+      end_sequence ();\n+    }\n+\n+  before_call = get_last_insn ();\n+\n+  target = expand_call (exp, target, target == const0_rtx);\n+\n+  return target;\n+}\n+\n /* To evaluate powi(x,n), the floating point value x raised to the\n    constant integer exponent n, we use a hybrid algorithm that\n    combines the \"window method\" with look-up tables.  For an\n@@ -5042,12 +5167,6 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \t and IMAGPART_EXPR.  */\n       abort ();\n \n-    case BUILT_IN_SIN:\n-    case BUILT_IN_SINF:\n-    case BUILT_IN_SINL:\n-    case BUILT_IN_COS:\n-    case BUILT_IN_COSF:\n-    case BUILT_IN_COSL:\n     case BUILT_IN_EXP:\n     case BUILT_IN_EXPF:\n     case BUILT_IN_EXPL:\n@@ -5120,6 +5239,19 @@ expand_builtin (tree exp, rtx target, rtx subtarget, enum machine_mode mode,\n \treturn target;\n       break;\n \n+    case BUILT_IN_SIN:\n+    case BUILT_IN_SINF:\n+    case BUILT_IN_SINL:\n+    case BUILT_IN_COS:\n+    case BUILT_IN_COSF:\n+    case BUILT_IN_COSL:\n+      if (! flag_unsafe_math_optimizations)\n+\tbreak;\n+      target = expand_builtin_mathfn_3 (exp, target, subtarget);\n+      if (target)\n+\treturn target;\n+      break;\n+\n     case BUILT_IN_APPLY_ARGS:\n       return expand_builtin_apply_args ();\n "}, {"sha": "e9afa7730669a493a12881920c017d805e6aeb2b", "filename": "gcc/config/i386/i386.md", "status": "modified", "additions": 159, "deletions": 6, "changes": 165, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fconfig%2Fi386%2Fi386.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fconfig%2Fi386%2Fi386.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fi386%2Fi386.md?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -121,6 +121,9 @@\n    (UNSPEC_FRNDINT\t\t68)\n    (UNSPEC_F2XM1\t\t69)\n \n+   (UNSPEC_SINCOS_COS\t\t80)\n+   (UNSPEC_SINCOS_SIN\t\t81)\n+\n    ; REP instruction\n    (UNSPEC_REP\t\t\t75)\n   ])\n@@ -14916,7 +14919,7 @@\n    (set_attr \"mode\" \"XF\")\n    (set_attr \"athlon_decode\" \"direct\")])\n \n-(define_insn \"sindf2\"\n+(define_insn \"*sindf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] UNSPEC_SIN))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n@@ -14925,7 +14928,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"sinsf2\"\n+(define_insn \"*sinsf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] UNSPEC_SIN))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n@@ -14945,7 +14948,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"sinxf2\"\n+(define_insn \"*sinxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"0\")] UNSPEC_SIN))]\n   \"TARGET_80387 && !TARGET_NO_FANCY_MATH_387\n@@ -14954,7 +14957,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n-(define_insn \"cosdf2\"\n+(define_insn \"*cosdf2\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 1 \"register_operand\" \"0\")] UNSPEC_COS))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n@@ -14963,7 +14966,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"cossf2\"\n+(define_insn \"*cossf2\"\n   [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n \t(unspec:SF [(match_operand:SF 1 \"register_operand\" \"0\")] UNSPEC_COS))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n@@ -14983,7 +14986,7 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"DF\")])\n \n-(define_insn \"cosxf2\"\n+(define_insn \"*cosxf2\"\n   [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n \t(unspec:XF [(match_operand:XF 1 \"register_operand\" \"0\")] UNSPEC_COS))]\n   \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387\n@@ -14992,6 +14995,156 @@\n   [(set_attr \"type\" \"fpspc\")\n    (set_attr \"mode\" \"XF\")])\n \n+;; With sincos pattern defined, sin and cos builtin function will be\n+;; expanded to sincos pattern with one of its outputs left unused. \n+;; Cse pass  will detected, if two sincos patterns can be combined,\n+;; otherwise sincos pattern will be splitted back to sin or cos pattern,\n+;; depending on the unused output.\n+\n+(define_insn \"sincosdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(match_operand:DF 2 \"register_operand\" \"0\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"=u\")\n+        (unspec:DF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n+  \"fsincos\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(unspec:DF [(match_operand:DF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"\")\n+\t(unspec:DF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[0]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 1) (unspec:DF [(match_dup 2)] UNSPEC_SIN))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(unspec:DF [(match_operand:DF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"\")\n+\t(unspec:DF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[1]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 0) (unspec:DF [(match_dup 2)] UNSPEC_COS))]\n+  \"\")\n+\n+(define_insn \"sincossf3\"\n+  [(set (match_operand:SF 0 \"register_operand\" \"=f\")\n+\t(unspec:SF [(match_operand:SF 2 \"register_operand\" \"0\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:SF 1 \"register_operand\" \"=u\")\n+        (unspec:SF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n+  \"fsincos\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"SF\")])\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(unspec:SF [(match_operand:SF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:SF 1 \"register_operand\" \"\")\n+\t(unspec:SF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[0]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 1) (unspec:SF [(match_dup 2)] UNSPEC_SIN))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:SF 0 \"register_operand\" \"\")\n+\t(unspec:SF [(match_operand:SF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:SF 1 \"register_operand\" \"\")\n+\t(unspec:SF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[1]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 0) (unspec:SF [(match_dup 2)] UNSPEC_COS))]\n+  \"\")\n+\n+(define_insn \"*sincosextendsfdf3\"\n+  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n+\t(unspec:DF [(float_extend:DF\n+\t\t     (match_operand:SF 2 \"register_operand\" \"0\"))]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"=u\")\n+        (unspec:DF [(float_extend:DF\n+\t\t     (match_dup 2))] UNSPEC_SINCOS_SIN))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n+  \"fsincos\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"DF\")])\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(unspec:DF [(float_extend:DF\n+\t\t     (match_operand:SF 2 \"register_operand\" \"\"))]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"\")\n+        (unspec:DF [(float_extend:DF\n+\t\t     (match_dup 2))] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[0]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 1) (unspec:DF [(float_extend:DF\n+\t\t\t\t   (match_dup 2))] UNSPEC_SIN))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:DF 0 \"register_operand\" \"\")\n+\t(unspec:DF [(float_extend:DF\n+\t\t     (match_operand:SF 2 \"register_operand\" \"\"))]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:DF 1 \"register_operand\" \"\")\n+        (unspec:DF [(float_extend:DF\n+\t\t     (match_dup 2))] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[1]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 0) (unspec:DF [(float_extend:DF\n+\t\t\t\t   (match_dup 2))] UNSPEC_COS))]\n+  \"\")\n+\n+(define_insn \"sincosxf3\"\n+  [(set (match_operand:XF 0 \"register_operand\" \"=f\")\n+\t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"0\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:XF 1 \"register_operand\" \"=u\")\n+        (unspec:XF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"! TARGET_NO_FANCY_MATH_387 && TARGET_80387 \n+   && flag_unsafe_math_optimizations\"\n+  \"fsincos\"\n+  [(set_attr \"type\" \"fpspc\")\n+   (set_attr \"mode\" \"XF\")])\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:XF 1 \"register_operand\" \"\")\n+\t(unspec:XF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[0]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 1) (unspec:XF [(match_dup 2)] UNSPEC_SIN))]\n+  \"\")\n+\n+(define_split\n+  [(set (match_operand:XF 0 \"register_operand\" \"\")\n+\t(unspec:XF [(match_operand:XF 2 \"register_operand\" \"\")]\n+\t\t   UNSPEC_SINCOS_COS))\n+   (set (match_operand:XF 1 \"register_operand\" \"\")\n+\t(unspec:XF [(match_dup 2)] UNSPEC_SINCOS_SIN))]\n+  \"find_regno_note (insn, REG_UNUSED, REGNO (operands[1]))\n+   && !reload_completed && !reload_in_progress\"\n+  [(set (match_dup 0) (unspec:XF [(match_dup 2)] UNSPEC_COS))]\n+  \"\")\n+\n (define_insn \"atan2df3_1\"\n   [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n \t(unspec:DF [(match_operand:DF 2 \"register_operand\" \"0\")"}, {"sha": "fad18793e50983d1ce6258c315355a22208ab04a", "filename": "gcc/genopinit.c", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fgenopinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Fgenopinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgenopinit.c?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -122,6 +122,7 @@ static const char * const optabs[] =\n   \"round_optab->handlers[$A].insn_code = CODE_FOR_$(round$a2$)\",\n   \"trunc_optab->handlers[$A].insn_code = CODE_FOR_$(trunc$a2$)\",\n   \"nearbyint_optab->handlers[$A].insn_code = CODE_FOR_$(nearbyint$a2$)\",\n+  \"sincos_optab->handlers[$A].insn_code = CODE_FOR_$(sincos$a3$)\",\n   \"sin_optab->handlers[$A].insn_code = CODE_FOR_$(sin$a2$)\",\n   \"cos_optab->handlers[$A].insn_code = CODE_FOR_$(cos$a2$)\",\n   \"exp_optab->handlers[$A].insn_code = CODE_FOR_$(exp$a2$)\","}, {"sha": "5fe24b7d1fbe42c5a2786696061d4f8d0d86c0ba", "filename": "gcc/optabs.c", "status": "modified", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -2147,6 +2147,109 @@ sign_expand_binop (enum machine_mode mode, optab uoptab, optab soptab,\n   return 0;\n }\n \f\n+/* Generate code to perform an operation specified by UNOPPTAB\n+   on operand OP0, with two results to TARG0 and TARG1.\n+   We assume that the order of the operands for the instruction\n+   is TARG0, TARG1, OP0.\n+\n+   Either TARG0 or TARG1 may be zero, but what that means is that\n+   the result is not actually wanted.  We will generate it into\n+   a dummy pseudo-reg and discard it.  They may not both be zero.\n+\n+   Returns 1 if this operation can be performed; 0 if not.  */\n+\n+int\n+expand_twoval_unop (optab unoptab, rtx targ0, rtx targ1, rtx op0,\n+\t\t    int unsignedp)\n+{\n+  enum machine_mode mode = GET_MODE (targ0 ? targ0 : targ1);\n+  enum mode_class class;\n+  enum machine_mode wider_mode;\n+  rtx entry_last = get_last_insn ();\n+  rtx last;\n+\n+  class = GET_MODE_CLASS (mode);\n+\n+  op0 = protect_from_queue (op0, 0);\n+\n+  if (flag_force_mem)\n+    {\n+      op0 = force_not_mem (op0);\n+    }\n+\n+  if (targ0)\n+    targ0 = protect_from_queue (targ0, 1);\n+  else\n+    targ0 = gen_reg_rtx (mode);\n+  if (targ1)\n+    targ1 = protect_from_queue (targ1, 1);\n+  else\n+    targ1 = gen_reg_rtx (mode);\n+\n+  /* Record where to go back to if we fail.  */\n+  last = get_last_insn ();\n+\n+  if (unoptab->handlers[(int) mode].insn_code != CODE_FOR_nothing)\n+    {\n+      int icode = (int) unoptab->handlers[(int) mode].insn_code;\n+      enum machine_mode mode0 = insn_data[icode].operand[2].mode;\n+      rtx pat;\n+      rtx xop0 = op0;\n+\n+      if (GET_MODE (xop0) != VOIDmode\n+\t  && GET_MODE (xop0) != mode0)\n+\txop0 = convert_to_mode (mode0, xop0, unsignedp);\n+\n+      /* Now, if insn doesn't accept these operands, put them into pseudos.  */\n+      if (! (*insn_data[icode].operand[2].predicate) (xop0, mode0))\n+\txop0 = copy_to_mode_reg (mode0, xop0);\n+\n+      /* We could handle this, but we should always be called with a pseudo\n+\t for our targets and all insns should take them as outputs.  */\n+      if (! (*insn_data[icode].operand[0].predicate) (targ0, mode)\n+\t  || ! (*insn_data[icode].operand[1].predicate) (targ1, mode))\n+\tabort ();\n+\n+      pat = GEN_FCN (icode) (targ0, targ1, xop0);\n+      if (pat)\n+\t{\n+\t  emit_insn (pat);\n+\t  return 1;\n+\t}\n+      else\n+\tdelete_insns_since (last);\n+    }\n+\n+  /* It can't be done in this mode.  Can we do it in a wider mode?  */\n+\n+  if (class == MODE_INT || class == MODE_FLOAT || class == MODE_COMPLEX_FLOAT)\n+    {\n+      for (wider_mode = GET_MODE_WIDER_MODE (mode); wider_mode != VOIDmode;\n+\t   wider_mode = GET_MODE_WIDER_MODE (wider_mode))\n+\t{\n+\t  if (unoptab->handlers[(int) wider_mode].insn_code\n+\t      != CODE_FOR_nothing)\n+\t    {\n+\t      rtx t0 = gen_reg_rtx (wider_mode);\n+\t      rtx t1 = gen_reg_rtx (wider_mode);\n+\t      rtx cop0 = convert_modes (wider_mode, mode, op0, unsignedp);\n+\n+\t      if (expand_twoval_unop (unoptab, t0, t1, cop0, unsignedp))\n+\t\t{\n+\t\t  convert_move (targ0, t0, unsignedp);\n+\t\t  convert_move (targ1, t1, unsignedp);\n+\t\t  return 1;\n+\t\t}\n+\t      else\n+\t\tdelete_insns_since (last);\n+\t    }\n+\t}\n+    }\n+\n+  delete_insns_since (entry_last);\n+  return 0;\n+}\n+\f\n /* Generate code to perform an operation specified by BINOPTAB\n    on operands OP0 and OP1, with two results to TARG1 and TARG2.\n    We assume that the order of the operands for the instruction\n@@ -5275,6 +5378,7 @@ init_optabs (void)\n   round_optab = init_optab (UNKNOWN);\n   btrunc_optab = init_optab (UNKNOWN);\n   nearbyint_optab = init_optab (UNKNOWN);\n+  sincos_optab = init_optab (UNKNOWN);\n   sin_optab = init_optab (UNKNOWN);\n   cos_optab = init_optab (UNKNOWN);\n   exp_optab = init_optab (UNKNOWN);"}, {"sha": "524cb678200c444cc4aebd8e1c63958b80c2e6fc", "filename": "gcc/optabs.h", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Foptabs.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Foptabs.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.h?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -148,6 +148,8 @@ enum optab_index\n   OTI_parity,\n   /* Square root */\n   OTI_sqrt,\n+  /* Sine-Cosine */\n+  OTI_sincos,\n   /* Sine */\n   OTI_sin,\n   /* Cosine */\n@@ -264,6 +266,7 @@ extern GTY(()) optab optab_table[OTI_MAX];\n #define popcount_optab (optab_table[OTI_popcount])\n #define parity_optab (optab_table[OTI_parity])\n #define sqrt_optab (optab_table[OTI_sqrt])\n+#define sincos_optab (optab_table[OTI_sincos])\n #define sin_optab (optab_table[OTI_sin])\n #define cos_optab (optab_table[OTI_cos])\n #define exp_optab (optab_table[OTI_exp])\n@@ -386,6 +389,9 @@ extern rtx expand_binop (enum machine_mode, optab, rtx, rtx, rtx, int,\n extern rtx sign_expand_binop (enum machine_mode, optab, optab, rtx, rtx,\n \t\t\t      rtx, int, enum optab_methods);\n \n+/* Generate code to perform an operation on one operand with two results.  */\n+extern int expand_twoval_unop (optab, rtx, rtx, rtx, int);\n+\n /* Generate code to perform an operation on two operands with two results.  */\n extern int expand_twoval_binop (optab, rtx, rtx, rtx, rtx, int);\n "}, {"sha": "f238267987afda11475d01cacdda48298bb98b99", "filename": "gcc/reg-stack.c", "status": "modified", "additions": 54, "deletions": 0, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Freg-stack.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Freg-stack.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freg-stack.c?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -1768,6 +1768,60 @@ subst_stack_regs_pat (rtx insn, stack regstack, rtx pat)\n \t\treplace_reg (dest, FIRST_STACK_REG);\n \t\tbreak;\n \n+\t      case UNSPEC_SINCOS_COS:\n+\t\t/* These insns operate on the top two stack slots,\n+\t\t   first part of one input, double output insn.  */\n+\n+\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n+\n+\t\temit_swap_insn (insn, regstack, *src1);\n+\n+\t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\n+\t\t/* Push the result back onto stack. Empty stack slot\n+\t\t   will be filled in second part of insn. */\n+\t\tif (STACK_REG_P (*dest)) {\n+\t\t  regstack->reg[regstack->top + 1] = REGNO (*dest);\n+\t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t  replace_reg (dest, FIRST_STACK_REG);\n+\t\t}\n+\n+\t\tif (src1_note)\n+\t\t  {\n+\t\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\t    regstack->top--;\n+\t\t    CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t\t  }\n+\t\treplace_reg (src1, FIRST_STACK_REG);\n+\t\tbreak;\n+\n+\t      case UNSPEC_SINCOS_SIN:\n+\t\tsrc1 = get_true_reg (&XVECEXP (pat_src, 0, 0));\n+\n+\t\temit_swap_insn (insn, regstack, *src1);\n+\n+\t\tsrc1_note = find_regno_note (insn, REG_DEAD, REGNO (*src1));\n+\n+\t\t/* Push the result back onto stack. Fill empty slot from\n+\t\t   first part of insn and fix top of stack pointer.  */\n+\t\tif (STACK_REG_P (*dest)) {\n+\t\t  regstack->reg[regstack->top] = REGNO (*dest);\n+\t\t  SET_HARD_REG_BIT (regstack->reg_set, REGNO (*dest));\n+\t\t  replace_reg (dest, FIRST_STACK_REG + 1);\n+\n+\t\t  regstack->top++;\n+\t\t}\n+\n+\t\tif (src1_note)\n+\t\t  {\n+\t\t    replace_reg (&XEXP (src1_note, 0), FIRST_STACK_REG);\n+\t\t    regstack->top--;\n+\t\t    CLEAR_HARD_REG_BIT (regstack->reg_set, REGNO (*src1));\n+\t\t  }\n+\n+\t\treplace_reg (src1, FIRST_STACK_REG);\n+\t\tbreak;\n+\n \t      case UNSPEC_SAHF:\n \t\t/* (unspec [(unspec [(compare)] UNSPEC_FNSTSW)] UNSPEC_SAHF)\n \t\t   The combination matches the PPRO fcomi instruction.  */"}, {"sha": "e4d8c8abfb993d0aa1ac2bc9a68770dcc06d56d2", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -1,3 +1,7 @@\n+2004-04-06  Uros Bizjak  <uros@kss-loka.si>\n+\n+\t* gcc.dg/builtins-36.c: New test.\n+\n 2004-04-06  Paul Brook  <paul@codesourcery.com>\n \n \t* README.gcc: Remove obsolete contraint on testcases."}, {"sha": "dc71198844821374625097759ca228690a838dff", "filename": "gcc/testsuite/gcc.dg/builtins-36.c", "status": "added", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-36.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6c7cf1f021db7313abecc4351b973d521c75bcaa/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-36.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fbuiltins-36.c?ref=6c7cf1f021db7313abecc4351b973d521c75bcaa", "patch": "@@ -0,0 +1,79 @@\n+/* Copyright (C) 2004 Free Software Foundation.\n+\n+   Check sin, sinf, sinl, cos, cosf and cosl built-in functions\n+   eventually compile to sincos, sincosf and sincosl.\n+\n+   Written by Uros Bizjak, 5th April 2004.  */\n+\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -ffast-math\" } */\n+\n+extern double sin(double);\n+extern float sinf(float);\n+extern long double sinl(long double);\n+\n+extern double cos(double);\n+extern float cosf(float);\n+extern long double cosl(long double);\n+\n+\n+double test1(double x)\n+{\n+\tdouble y1, y2;\n+\n+\ty1 = sin(x);\n+\ty2 = cos(x);\n+\n+\treturn y1 - y2;\n+}\n+\n+float test1f(float x)\n+{\n+\tfloat y1, y2;\n+\n+\ty1 = sinf(x);\n+\ty2 = cosf(x);\n+\n+\treturn y1 - y2;\n+}\n+\n+long double test1l(long double x)\n+{\n+\tlong double y1, y2;\n+\n+\ty1 = sinl(x);\n+\ty2 = cosl(x);\n+\n+\treturn y1 - y2;\n+}\n+\n+double test2(double x)\n+{\n+\treturn sin(x);\n+}\n+\n+float test2f(float x)\n+{\n+\treturn sinf(x);\n+}\n+\n+long double test2l(long double x)\n+{\n+\treturn sinl(x);\n+}\n+\n+double test3(double x)\n+{\n+\treturn cos(x);\n+}\n+\n+float test3f(float x)\n+{\n+\treturn cosf(x);\n+}\n+\n+long double test3l(long double x)\n+{\n+\treturn cosl(x);\n+}\n+"}]}