{"sha": "0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDA2NGZiZTliNmQzOTVjNzk0ZmMwMjFkNmRjOTdiNDBmOWQ3YWM5Mg==", "commit": {"author": {"name": "Richard Sandiford", "email": "rsandifo@nildram.co.uk", "date": "2007-10-03T18:39:30Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2007-10-03T18:39:30Z"}, "message": "re PR target/33635 (Bootstrap broken on mips-sgi-irix6.5)\n\ngcc/\n\tPR target/33635\n\t* config/mips/mips-protos.h (mips_split_64bit_move): Rename to...\n\t(mips_split_doubleword_move): ...this.\n\t* config/mips/mips.c (mips_subword): Extend to handle 64-bit words;\n\tuse natural endianness for multi-format FPR values.\n\t(mips_split_64bit_move): Rename to...\n\t(mips_split_doubleword_move): ...this and extend to 64-bit words.\n\tUse move_doubleword_fpr* patterns for moves involving FPRs.\n\t(mips_save_reg): Update the call to mips_split_64bit_move.\n\t(mips_secondary_reload_class): Return NO_REGS for any reload of a\n\tnonzero constant into an FPR if the constant can be forced to memory.\n\t* config/mips/mips.md: Update the splitter calls to\n\tmips_split_64bit_move.\n\t(UNSPEC_LOAD_DF_LOW): Rename to...\n\t(UNSPEC_LOAD_LOW): ...this.\n\t(UNSPEC_LOAD_DF_HIGH): Rename to...\n\t(UNSPEC_LOAD_HIGH): ...this.\n\t(UNSPEC_STORE_DF_HIGH): Rename to...\n\t(UNSPEC_STORE_WORD): ...this.\n\t(SPLITF): New mode iterator.\n\t(HALFMODE): New mode attribute.\n\t(movtf): New expander.\n\t(*movtf_internal): New define_insn_and_split.\n\t(move_doubleword_fpr<mode>): New expander.\n\t(load_df_low, load_df_high, store_df_high, mthc1, mfhc1): Replace\n\twith...\n\t(load_low<mode>, load_high<mode>, store_word<mode>, mthc1<mode>)\n\t(mfhc1<mode>): ...these more general patterns.\n\ngcc/testsuite/\n\tPR target/33635\n\t* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_isa_rev\n\tand mips_forced_be.\n\t(dg-mips-options): Handle -EL and -mel.  Make -mfp64 imply\n\t-mhard-float and a suitable ISA.  Improve handling of -mipsXrY\n\toptions.\n\t* gcc.target/mips/fpr-moves-1.c: New test.\n\t* gcc.target/mips/fpr-moves-2.c: Likewise.\n\t* gcc.target/mips/fpr-moves-3.c: Likewise.\n\t* gcc.target/mips/fpr-moves-4.c: Likewise.\n\t* gcc.target/mips/fpr-moves-5.c: Likewise.\n\t* gcc.target/mips/fpr-moves-6.c: Likewise.\n\t* gcc.target/mips/mips32r2-mxhc1.c: Remove -march=mips32r2\n\nFrom-SVN: r128991", "tree": {"sha": "facac44939a51a8591e7804d091bfb66aeb0c6f6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/facac44939a51a8591e7804d091bfb66aeb0c6f6"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/comments", "author": null, "committer": null, "parents": [{"sha": "f5783e34f97cd9012ae3ee4118a5e3bf642d8aed", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f5783e34f97cd9012ae3ee4118a5e3bf642d8aed", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f5783e34f97cd9012ae3ee4118a5e3bf642d8aed"}], "stats": {"total": 522, "additions": 397, "deletions": 125}, "files": [{"sha": "45a840f72315b13bfd4bdf2f98d790c7fce47127", "filename": "gcc/ChangeLog", "status": "modified", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -1,3 +1,34 @@\n+2007-10-03  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/33635\n+\t* config/mips/mips-protos.h (mips_split_64bit_move): Rename to...\n+\t(mips_split_doubleword_move): ...this.\n+\t* config/mips/mips.c (mips_subword): Extend to handle 64-bit words;\n+\tuse natural endianness for multi-format FPR values.\n+\t(mips_split_64bit_move): Rename to...\n+\t(mips_split_doubleword_move): ...this and extend to 64-bit words.\n+\tUse move_doubleword_fpr* patterns for moves involving FPRs.\n+\t(mips_save_reg): Update the call to mips_split_64bit_move.\n+\t(mips_secondary_reload_class): Return NO_REGS for any reload of a\n+\tnonzero constant into an FPR if the constant can be forced to memory.\n+\t* config/mips/mips.md: Update the splitter calls to\n+\tmips_split_64bit_move.\n+\t(UNSPEC_LOAD_DF_LOW): Rename to...\n+\t(UNSPEC_LOAD_LOW): ...this.\n+\t(UNSPEC_LOAD_DF_HIGH): Rename to...\n+\t(UNSPEC_LOAD_HIGH): ...this.\n+\t(UNSPEC_STORE_DF_HIGH): Rename to...\n+\t(UNSPEC_STORE_WORD): ...this.\n+\t(SPLITF): New mode iterator.\n+\t(HALFMODE): New mode attribute.\n+\t(movtf): New expander.\n+\t(*movtf_internal): New define_insn_and_split.\n+\t(move_doubleword_fpr<mode>): New expander.\n+\t(load_df_low, load_df_high, store_df_high, mthc1, mfhc1): Replace\n+\twith...\n+\t(load_low<mode>, load_high<mode>, store_word<mode>, mthc1<mode>)\n+\t(mfhc1<mode>): ...these more general patterns.\n+\n 2007-10-03  Alexandre Oliva  <aoliva@redhat.com>\n \n \t* cfgrtl.c (rtl_block_ends_with_call_p): Skip notes at the end."}, {"sha": "371fd93447e31ae32be54d635462f6dea8ef5108", "filename": "gcc/config/mips/mips-protos.h", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips-protos.h?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -201,7 +201,7 @@ extern int m16_nsimm8_8 (rtx, enum machine_mode);\n \n extern rtx mips_subword (rtx, int);\n extern bool mips_split_64bit_move_p (rtx, rtx);\n-extern void mips_split_64bit_move (rtx, rtx);\n+extern void mips_split_doubleword_move (rtx, rtx);\n extern const char *mips_output_move (rtx, rtx);\n extern void mips_restore_gp (void);\n #ifdef RTX_CODE"}, {"sha": "64377b54d1d2de7f1ff58f07837ba81b2076d742", "filename": "gcc/config/mips/mips.c", "status": "modified", "additions": 28, "deletions": 62, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -3477,7 +3477,7 @@ mips_address_cost (rtx addr)\n rtx\n mips_subword (rtx op, int high_p)\n {\n-  unsigned int byte;\n+  unsigned int byte, offset;\n   enum machine_mode mode;\n \n   mode = GET_MODE (op);\n@@ -3490,7 +3490,11 @@ mips_subword (rtx op, int high_p)\n     byte = 0;\n \n   if (FP_REG_RTX_P (op))\n-    return gen_rtx_REG (word_mode, high_p ? REGNO (op) + 1 : REGNO (op));\n+    {\n+      /* Paired FPRs are always ordered little-endian.  */\n+      offset = (UNITS_PER_WORD < UNITS_PER_HWFPVALUE ? high_p : byte != 0);\n+      return gen_rtx_REG (word_mode, REGNO (op) + offset);\n+    }\n \n   if (MEM_P (op))\n     return mips_rewrite_small_data (adjust_address (op, word_mode, byte));\n@@ -3524,58 +3528,23 @@ mips_split_64bit_move_p (rtx dest, rtx src)\n }\n \n \n-/* Split a 64-bit move from SRC to DEST assuming that\n-   mips_split_64bit_move_p holds.\n-\n-   Moves into and out of FPRs cause some difficulty here.  Such moves\n-   will always be DFmode, since paired FPRs are not allowed to store\n-   DImode values.  The most natural representation would be two separate\n-   32-bit moves, such as:\n-\n-\t(set (reg:SI $f0) (mem:SI ...))\n-\t(set (reg:SI $f1) (mem:SI ...))\n-\n-   However, the second insn is invalid because odd-numbered FPRs are\n-   not allowed to store independent values.  Use the patterns load_df_low,\n-   load_df_high and store_df_high instead.  */\n+/* Split a doubleword move from SRC to DEST.  On 32-bit targets,\n+   this function handles 64-bit moves for which mips_split_64bit_move_p\n+   holds.  For 64-bit targets, this function handles 128-bit moves.  */\n \n void\n-mips_split_64bit_move (rtx dest, rtx src)\n+mips_split_doubleword_move (rtx dest, rtx src)\n {\n-  if (FP_REG_RTX_P (dest))\n-    {\n-      /* Loading an FPR from memory or from GPRs.  */\n-      if (ISA_HAS_MXHC1)\n-\t{\n-\t  if (GET_MODE (dest) != DFmode)\n-\t    dest = gen_rtx_REG_offset (dest, DFmode, REGNO (dest), 0);\n-\t  emit_insn (gen_load_df_low (dest, mips_subword (src, 0)));\n-\t  emit_insn (gen_mthc1 (dest, mips_subword (src, 1),\n-\t\t\t\tcopy_rtx (dest)));\n-\t}\n-      else\n-\t{\n-\t  emit_insn (gen_load_df_low (copy_rtx (dest),\n-\t\t\t\t      mips_subword (src, 0)));\n-\t  emit_insn (gen_load_df_high (dest, mips_subword (src, 1),\n-\t\t\t\t       copy_rtx (dest)));\n-\t}\n-    }\n-  else if (FP_REG_RTX_P (src))\n+  if (FP_REG_RTX_P (dest) || FP_REG_RTX_P (src))\n     {\n-      /* Storing an FPR into memory or GPRs.  */\n-      if (ISA_HAS_MXHC1)\n-\t{\n-\t  if (GET_MODE (src) != DFmode)\n-\t    src = gen_rtx_REG_offset (src, DFmode, REGNO (src), 0);\n-\t  mips_emit_move (mips_subword (dest, 0), mips_subword (src, 0));\n-\t  emit_insn (gen_mfhc1 (mips_subword (dest, 1), src));\n-\t}\n+      if (!TARGET_64BIT && GET_MODE (dest) == DImode)\n+\temit_insn (gen_move_doubleword_fprdi (dest, src));\n+      else if (!TARGET_64BIT && GET_MODE (dest) == DFmode)\n+\temit_insn (gen_move_doubleword_fprdf (dest, src));\n+      else if (TARGET_64BIT && GET_MODE (dest) == TFmode)\n+\temit_insn (gen_move_doubleword_fprtf (dest, src));\n       else\n-\t{\n-\t  mips_emit_move (mips_subword (dest, 0), mips_subword (src, 0));\n-\t  emit_insn (gen_store_df_high (mips_subword (dest, 1), src));\n-\t}\n+\tgcc_unreachable ();\n     }\n   else\n     {\n@@ -8042,7 +8011,7 @@ mips_save_reg (rtx reg, rtx mem)\n       rtx x1, x2;\n \n       if (mips_split_64bit_move_p (mem, reg))\n-\tmips_split_64bit_move (mem, reg);\n+\tmips_split_doubleword_move (mem, reg);\n       else\n \tmips_emit_move (mem, reg);\n \n@@ -9472,18 +9441,15 @@ mips_secondary_reload_class (enum reg_class class,\n \t/* In this case we can use mtc1, mfc1, dmtc1 or dmfc1.  */\n \treturn NO_REGS;\n \n-      if (mips_mode_ok_for_mov_fmt_p (mode))\n-\t{\n-\t  if (CONSTANT_P (x))\n-\t    /* We can force the constants to memory and use lwc1\n-\t       and ldc1.  As above, we will use pairs of lwc1s if\n-\t       ldc1 is not supported.  */\n-\t    return NO_REGS;\n-\n-\t  if (FP_REG_P (regno))\n-\t    /* In this case we can use mov.fmt.  */\n-\t    return NO_REGS;\n-\t}\n+      if (CONSTANT_P (x) && !targetm.cannot_force_const_mem (x))\n+\t/* We can force the constant to memory and use lwc1\n+\t   and ldc1.  As above, we will use pairs of lwc1s if\n+\t   ldc1 is not supported.  */\n+\treturn NO_REGS;\n+\n+      if (FP_REG_P (regno) && mips_mode_ok_for_mov_fmt_p (mode))\n+\t/* In this case we can use mov.fmt.  */\n+\treturn NO_REGS;\n \n       /* Otherwise, we need to reload through an integer register.  */\n       return GR_REGS;"}, {"sha": "f4b90eb6ee051d3d1a66fc6deb5635cb6be5ca6f", "filename": "gcc/config/mips/mips.md", "status": "modified", "additions": 118, "deletions": 52, "changes": 170, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips.md", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Fconfig%2Fmips%2Fmips.md", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fmips%2Fmips.md?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -24,9 +24,9 @@\n ;; <http://www.gnu.org/licenses/>.\n \n (define_constants\n-  [(UNSPEC_LOAD_DF_LOW\t\t 0)\n-   (UNSPEC_LOAD_DF_HIGH\t\t 1)\n-   (UNSPEC_STORE_DF_HIGH\t 2)\n+  [(UNSPEC_LOAD_LOW\t\t 0)\n+   (UNSPEC_LOAD_HIGH\t\t 1)\n+   (UNSPEC_STORE_WORD\t\t 2)\n    (UNSPEC_GET_FNADDR\t\t 3)\n    (UNSPEC_BLOCKAGE\t\t 4)\n    (UNSPEC_CPRESTORE\t\t 5)\n@@ -498,6 +498,11 @@\n (define_mode_iterator SCALARF [(SF \"TARGET_HARD_FLOAT\")\n \t\t\t       (DF \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\")])\n \n+;; A floating-point mode for which moves involving FPRs may need to be split.\n+(define_mode_iterator SPLITF [(DF \"!TARGET_64BIT\")\n+\t\t\t      (DI \"!TARGET_64BIT\")\n+\t\t\t      (TF \"TARGET_64BIT\")])\n+\n ;; In GPR templates, a string like \"<d>subu\" will expand to \"subu\" in the\n ;; 32-bit version and \"dsubu\" in the 64-bit version.\n (define_mode_attr d [(SI \"\") (DI \"d\")\n@@ -546,6 +551,10 @@\n \t\t\t (V4UQQ \"SI\") (V2UHQ \"SI\") (V2UHA \"SI\")\n \t\t\t (V2HQ \"SI\") (V2HA \"SI\")])\n \n+;; This attribute gives the integer mode that has half the size of\n+;; the controlling mode.\n+(define_mode_attr HALFMODE [(DF \"SI\") (DI \"SI\") (TF \"DI\")])\n+\n ;; This attribute works around the early SB-1 rev2 core \"F2\" erratum:\n ;;\n ;; In certain cases, div.s and div.ps may have a rounding error\n@@ -3999,14 +4008,40 @@\n    (set_attr \"mode\"\t\"DF\")\n    (set_attr \"length\"\t\"8,8,8,*,*\")])\n \n+;; 128-bit floating point moves\n+\n+(define_expand \"movtf\"\n+  [(set (match_operand:TF 0 \"\")\n+\t(match_operand:TF 1 \"\"))]\n+  \"\"\n+{\n+  if (mips_legitimize_move (TFmode, operands[0], operands[1]))\n+    DONE;\n+})\n+\n+;; This pattern handles both hard- and soft-float cases.\n+(define_insn_and_split \"*movtf_internal\"\n+  [(set (match_operand:TF 0 \"nonimmediate_operand\" \"=d,R,f,dR\")\n+\t(match_operand:TF 1 \"move_operand\" \"dGR,dG,dGR,f\"))]\n+  \"\"\n+  \"#\"\n+  \"&& reload_completed\"\n+  [(const_int 0)]\n+{\n+  mips_split_doubleword_move (operands[0], operands[1]);\n+  DONE;\n+}\n+  [(set_attr \"type\" \"multi\")\n+   (set_attr \"length\" \"16\")])\n+\n (define_split\n   [(set (match_operand:DI 0 \"nonimmediate_operand\")\n \t(match_operand:DI 1 \"move_operand\"))]\n   \"reload_completed && !TARGET_64BIT\n    && mips_split_64bit_move_p (operands[0], operands[1])\"\n   [(const_int 0)]\n {\n-  mips_split_64bit_move (operands[0], operands[1]);\n+  mips_split_doubleword_move (operands[0], operands[1]);\n   DONE;\n })\n \n@@ -4017,7 +4052,7 @@\n    && mips_split_64bit_move_p (operands[0], operands[1])\"\n   [(const_int 0)]\n {\n-  mips_split_64bit_move (operands[0], operands[1]);\n+  mips_split_doubleword_move (operands[0], operands[1]);\n   DONE;\n })\n \n@@ -4099,74 +4134,105 @@\n   [(set_attr \"type\" \"mfhilo\")\n    (set_attr \"mode\" \"<MODE>\")])\n \n-;; Patterns for loading or storing part of a paired floating point\n-;; register.  We need them because odd-numbered floating-point registers\n-;; are not fully independent: see mips_split_64bit_move.\n+;; Emit a doubleword move in which exactly one of the operands is\n+;; a floating-point register.  We can't just emit two normal moves\n+;; because of the constraints imposed by the FPU register model;\n+;; see mips_cannot_change_mode_class for details.  Instead, we keep\n+;; the FPR whole and use special patterns to refer to each word of\n+;; the other operand.\n+\n+(define_expand \"move_doubleword_fpr<mode>\"\n+  [(set (match_operand:SPLITF 0)\n+\t(match_operand:SPLITF 1))]\n+  \"\"\n+{\n+  if (FP_REG_RTX_P (operands[0]))\n+    {\n+      rtx low = mips_subword (operands[1], 0);\n+      rtx high = mips_subword (operands[1], 1);\n+      emit_insn (gen_load_low<mode> (operands[0], low));\n+      if (ISA_HAS_MXHC1)\n+ \temit_insn (gen_mthc1<mode> (operands[0], high, operands[0]));\n+      else\n+\temit_insn (gen_load_high<mode> (operands[0], high, operands[0]));\n+    }\n+  else\n+    {\n+      rtx low = mips_subword (operands[0], 0);\n+      rtx high = mips_subword (operands[0], 1);\n+      emit_insn (gen_store_word<mode> (low, operands[1], const0_rtx));\n+      if (ISA_HAS_MXHC1)\n+\temit_insn (gen_mfhc1<mode> (high, operands[1]));\n+      else\n+\temit_insn (gen_store_word<mode> (high, operands[1], const1_rtx));\n+    }\n+  DONE;\n+})\n \n ;; Load the low word of operand 0 with operand 1.\n-(define_insn \"load_df_low\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ,m\")]\n-\t\t   UNSPEC_LOAD_DF_LOW))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+(define_insn \"load_low<mode>\"\n+  [(set (match_operand:SPLITF 0 \"register_operand\" \"=f,f\")\n+\t(unspec:SPLITF [(match_operand:<HALFMODE> 1 \"general_operand\" \"dJ,m\")]\n+\t\t       UNSPEC_LOAD_LOW))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n {\n   operands[0] = mips_subword (operands[0], 0);\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\"\t\"mtc,fpload\")\n-   (set_attr \"mode\"\t\"SF\")])\n+  [(set_attr \"type\" \"mtc,fpload\")\n+   (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Load the high word of operand 0 from operand 1, preserving the value\n ;; in the low word.\n-(define_insn \"load_df_high\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f,f\")\n-\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ,m\")\n-\t\t    (match_operand:DF 2 \"register_operand\" \"0,0\")]\n-\t\t   UNSPEC_LOAD_DF_HIGH))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+(define_insn \"load_high<mode>\"\n+  [(set (match_operand:SPLITF 0 \"register_operand\" \"=f,f\")\n+\t(unspec:SPLITF [(match_operand:<HALFMODE> 1 \"general_operand\" \"dJ,m\")\n+\t\t\t(match_operand:SPLITF 2 \"register_operand\" \"0,0\")]\n+\t\t       UNSPEC_LOAD_HIGH))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n {\n   operands[0] = mips_subword (operands[0], 1);\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\"\t\"mtc,fpload\")\n-   (set_attr \"mode\"\t\"SF\")])\n-\n-;; Store the high word of operand 1 in operand 0.  The corresponding\n-;; low-word move is done in the normal way.\n-(define_insn \"store_df_high\"\n-  [(set (match_operand:SI 0 \"nonimmediate_operand\" \"=d,m\")\n-\t(unspec:SI [(match_operand:DF 1 \"register_operand\" \"f,f\")]\n-\t\t   UNSPEC_STORE_DF_HIGH))]\n-  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT && !TARGET_64BIT\"\n+  [(set_attr \"type\" \"mtc,fpload\")\n+   (set_attr \"mode\" \"<HALFMODE>\")])\n+\n+;; Store one word of operand 1 in operand 0.  Operand 2 is 1 to store the\n+;; high word and 0 to store the low word.\n+(define_insn \"store_word<mode>\"\n+  [(set (match_operand:<HALFMODE> 0 \"nonimmediate_operand\" \"=d,m\")\n+\t(unspec:<HALFMODE> [(match_operand:SPLITF 1 \"register_operand\" \"f,f\")\n+\t\t\t    (match_operand 2 \"const_int_operand\")]\n+\t\t\t   UNSPEC_STORE_WORD))]\n+  \"TARGET_HARD_FLOAT && TARGET_DOUBLE_FLOAT\"\n {\n-  operands[1] = mips_subword (operands[1], 1);\n+  operands[1] = mips_subword (operands[1], INTVAL (operands[2]));\n   return mips_output_move (operands[0], operands[1]);\n }\n-  [(set_attr \"type\"\t\"mfc,fpstore\")\n-   (set_attr \"mode\"\t\"SF\")])\n+  [(set_attr \"type\" \"mfc,fpstore\")\n+   (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Move operand 1 to the high word of operand 0 using mthc1, preserving the\n ;; value in the low word.\n-(define_insn \"mthc1\"\n-  [(set (match_operand:DF 0 \"register_operand\" \"=f\")\n-\t(unspec:DF [(match_operand:SI 1 \"general_operand\" \"dJ\")\n-\t\t    (match_operand:DF 2 \"register_operand\" \"0\")]\n-\t\t    UNSPEC_MTHC1))]\n-  \"TARGET_HARD_FLOAT && !TARGET_64BIT && ISA_HAS_MXHC1\"\n+(define_insn \"mthc1<mode>\"\n+  [(set (match_operand:SPLITF 0 \"register_operand\" \"=f\")\n+\t(unspec:SPLITF [(match_operand:<HALFMODE> 1 \"general_operand\" \"dJ\")\n+\t\t        (match_operand:SPLITF 2 \"register_operand\" \"0\")]\n+\t\t       UNSPEC_MTHC1))]\n+  \"TARGET_HARD_FLOAT && ISA_HAS_MXHC1\"\n   \"mthc1\\t%z1,%0\"\n-  [(set_attr \"type\"\t\"mtc\")\n-   (set_attr \"mode\"\t\"SF\")])\n-\n-;; Move high word of operand 1 to operand 0 using mfhc1.  The corresponding\n-;; low-word move is done in the normal way.\n-(define_insn \"mfhc1\"\n-  [(set (match_operand:SI 0 \"register_operand\" \"=d\")\n-\t(unspec:SI [(match_operand:DF 1 \"register_operand\" \"f\")]\n-\t\t    UNSPEC_MFHC1))]\n-  \"TARGET_HARD_FLOAT && !TARGET_64BIT && ISA_HAS_MXHC1\"\n+  [(set_attr \"type\" \"mtc\")\n+   (set_attr \"mode\" \"<HALFMODE>\")])\n+\n+;; Move high word of operand 1 to operand 0 using mfhc1.\n+(define_insn \"mfhc1<mode>\"\n+  [(set (match_operand:<HALFMODE> 0 \"register_operand\" \"=d\")\n+\t(unspec:<HALFMODE> [(match_operand:SPLITF 1 \"register_operand\" \"f\")]\n+\t\t\t    UNSPEC_MFHC1))]\n+  \"TARGET_HARD_FLOAT && ISA_HAS_MXHC1\"\n   \"mfhc1\\t%0,%1\"\n-  [(set_attr \"type\"\t\"mfc\")\n-   (set_attr \"mode\"\t\"SF\")])\n+  [(set_attr \"type\" \"mfc\")\n+   (set_attr \"mode\" \"<HALFMODE>\")])\n \n ;; Move a constant that satisfies CONST_GP_P into operand 0.\n (define_expand \"load_const_gp\""}, {"sha": "277c25d5e311992f0578a8d0bc5de5f8be4276e0", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -1,3 +1,19 @@\n+2007-10-03  Richard Sandiford  <rsandifo@nildram.co.uk>\n+\n+\tPR target/33635\n+\t* gcc.target/mips/mips.exp (setup_mips_tests): Set mips_isa_rev\n+\tand mips_forced_be.\n+\t(dg-mips-options): Handle -EL and -mel.  Make -mfp64 imply\n+\t-mhard-float and a suitable ISA.  Improve handling of -mipsXrY\n+\toptions.\n+\t* gcc.target/mips/fpr-moves-1.c: New test.\n+\t* gcc.target/mips/fpr-moves-2.c: Likewise.\n+\t* gcc.target/mips/fpr-moves-3.c: Likewise.\n+\t* gcc.target/mips/fpr-moves-4.c: Likewise.\n+\t* gcc.target/mips/fpr-moves-5.c: Likewise.\n+\t* gcc.target/mips/fpr-moves-6.c: Likewise.\n+\t* gcc.target/mips/mips32r2-mxhc1.c: Remove -march=mips32r2\n+\n 2007-10-03  Francois-Xavier Coudert  <fxcoudert@gcc.gnu.org>\n \n \t* gfortran.dg/default_format_1.f90: XFAIL on all darwin targets."}, {"sha": "db2190d18dc11d762c3ad750625c7b26777faed4", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-1.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-1.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-mips-options \"-mabi=32 -mhard-float -mips1 -O2 -EL\" } */\n+\n+NOMIPS16 void\n+foo (double d, double *x)\n+{\n+  *x = d;\n+}\n+\n+NOMIPS16 double\n+bar (double d)\n+{\n+  register double l1 asm (\"$8\") = d;\n+  register double l2 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm volatile (\"#foo\" :: \"f\" (l2));\n+  return l1;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswc1\\t\\\\\\$f12,0\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tswc1\\t\\\\\\$f13,4\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$8,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$9,\\\\\\$f13\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f21\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$8,\\\\\\$f0\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$9,\\\\\\$f1\\n\" } } */"}, {"sha": "fe21ee2a1d980aac05dfab58b56c05c196582227", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-2.c", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-2.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,26 @@\n+/* { dg-mips-options \"-mabi=32 -mhard-float -mips1 -O2 -EB\" } */\n+\n+NOMIPS16 void\n+foo (double d, double *x)\n+{\n+  *x = d;\n+}\n+\n+NOMIPS16 double\n+bar (double d)\n+{\n+  register double l1 asm (\"$8\") = d;\n+  register double l2 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm volatile (\"#foo\" :: \"f\" (l2));\n+  return l1;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tswc1\\t\\\\\\$f12,4\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tswc1\\t\\\\\\$f13,0\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$9,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$8,\\\\\\$f13\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f21\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$9,\\\\\\$f0\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$8,\\\\\\$f1\\n\" } } */"}, {"sha": "a32c6874eaf3af908d846aeb5ee31630467cda70", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-3.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-3.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-3.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-3.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-mips-options \"-mabi=32 -mfp64 -O2 -EL\" } */\n+\n+NOMIPS16 double\n+foo (double d)\n+{\n+  register double l1 asm (\"$8\") = d;\n+  register double l2 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm volatile (\"#foo\" :: \"f\" (l2));\n+  return l1;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$8,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfhc1\\t\\\\\\$9,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmthc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$8,\\\\\\$f0\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmthc1\\t\\\\\\$9,\\\\\\$f0\\n\" } } */"}, {"sha": "4f26f0694e44f18374835d05264845491633e279", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-4.c", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-4.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-4.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-4.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,18 @@\n+/* { dg-mips-options \"-mabi=32 -mfp64 -O2 -EB\" } */\n+\n+NOMIPS16 double\n+foo (double d)\n+{\n+  register double l1 asm (\"$8\") = d;\n+  register double l2 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm volatile (\"#foo\" :: \"f\" (l2));\n+  return l1;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tmfc1\\t\\\\\\$9,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmfhc1\\t\\\\\\$8,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmthc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmtc1\\t\\\\\\$9,\\\\\\$f0\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tmthc1\\t\\\\\\$8,\\\\\\$f0\\n\" } } */"}, {"sha": "7159d381b85013d7f5ae4594f0ae495fd1dedd77", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-5.c", "status": "added", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-5.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-5.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-5.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,33 @@\n+/* { dg-mips-options \"-mabi=64 -mhard-float -O2 -EL\" } */\n+\n+NOMIPS16 void\n+foo (long double d, long double *x)\n+{\n+  *x = d;\n+}\n+\n+NOMIPS16 long double\n+bar (long double d, long double *x)\n+{\n+  register long double l1 asm (\"$8\") = d;\n+  register long double l2 asm (\"$10\") = x[1];\n+  register long double l3 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm (\"#foo\" : \"=d\" (l2) : \"d\" (l2));\n+  asm volatile (\"#foo\" :: \"f\" (l3));\n+  x[1] = l1;\n+  return l2;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tsdc1\\t\\\\\\$f12,0\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsdc1\\t\\\\\\$f13,8\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmfc1\\t\\\\\\$8,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmfc1\\t\\\\\\$9,\\\\\\$f13\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$10,16\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$11,24\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$0,\\\\\\$f21\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$8,16\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$9,24\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$10,\\\\\\$f0\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$11,\\\\\\$f2\\n\" } } */"}, {"sha": "048987a78dee8d2c64f63d73b1acf93742444bcf", "filename": "gcc/testsuite/gcc.target/mips/fpr-moves-6.c", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Ffpr-moves-6.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -0,0 +1,34 @@\n+/* { dg-mips-options \"-mabi=64 -mhard-float -O2 -EB\" } */\n+\n+NOMIPS16 void\n+foo (long double d, long double *x)\n+{\n+  *x = d;\n+}\n+\n+NOMIPS16 long double\n+bar (long double d, long double *x)\n+{\n+  register long double l1 asm (\"$8\") = d;\n+  register long double l2 asm (\"$10\") = x[1];\n+  register long double l3 asm (\"$f20\") = 0.0;\n+  asm (\"#foo\" : \"=d\" (l1) : \"d\" (l1));\n+  asm (\"#foo\" : \"=d\" (l2) : \"d\" (l2));\n+  asm volatile (\"#foo\" :: \"f\" (l3));\n+  x[1] = l1;\n+  return l2;\n+}\n+\n+/* { dg-final { scan-assembler \"\\tsdc1\\t\\\\\\$f12,0\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsdc1\\t\\\\\\$f13,8\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmfc1\\t\\\\\\$8,\\\\\\$f12\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmfc1\\t\\\\\\$9,\\\\\\$f13\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$10,16\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tld\\t\\\\\\$11,24\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$0,\\\\\\$f20\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$0,\\\\\\$f21\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$8,16\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* { dg-final { scan-assembler \"\\tsd\\t\\\\\\$9,24\\\\\\(\\\\\\$6\\\\\\)\\n\" } } */\n+/* We currently move this through a temporary.  */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$10,\\\\\\$f0\\n\" { xfail mips*-*-* } } } */\n+/* { dg-final { scan-assembler \"\\tdmtc1\\t\\\\\\$11,\\\\\\$f2\\n\" } } */"}, {"sha": "68c67d31287763a175aca2ce820dc2c342f7419c", "filename": "gcc/testsuite/gcc.target/mips/mips.exp", "status": "modified", "additions": 47, "deletions": 9, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips.exp?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -29,6 +29,7 @@ load_lib gcc-dg.exp\n # line (as opposed to being overridable defaults).\n #\n #    $mips_isa:\t\t the ISA level specified by __mips\n+#    $mips_isa_rev:\t the ISA revision specified by __mips_isa_rev\n #    $mips_arch:\t the architecture specified by _MIPS_ARCH\n #    $mips_gp64:\t true if 64-bit output is selected\n #    $mips_fp64:\t true if 64-bit FPRs are selected\n@@ -39,11 +40,13 @@ load_lib gcc-dg.exp\n #    $mips_forced_abi:\t true if the command line uses -mabi=*\n #    $mips_forced_regs:  true if the command line uses -mgp* or -mfp*\n #    $mips_forced_float: true if the command line uses -mhard/soft-float\n+#    $mips_forced_be\t true if the command line uses -EB or -meb\n #    $mips_forced_le\t true if the command line uses -EL or -mel\n #    $mips_forced_gp\t true if the command line forces a particular GP mode\n #    $mips_forced_no_er  true if the command line contains -mno-explicit-relocs\n proc setup_mips_tests {} {\n     global mips_isa\n+    global mips_isa_rev\n     global mips_arch\n     global mips_gp64\n     global mips_fp64\n@@ -53,6 +56,7 @@ proc setup_mips_tests {} {\n     global mips_forced_isa\n     global mips_forced_abi\n     global mips_forced_float\n+    global mips_forced_be\n     global mips_forced_le\n     global mips_forced_gp\n     global mips_forced_no_er\n@@ -65,6 +69,11 @@ proc setup_mips_tests {} {\n     set f [open $src \"w\"]\n     puts $f {\n \tint isa = __mips;\n+\t#ifdef __mips_isa_rev\n+\tint isa_rev = __mips_isa_rev;\n+\t#else\n+\tint isa_rev = 1;\n+\t#endif\n \tconst char *arch = _MIPS_ARCH;\n \t#ifdef __mips64\n \tint gp64 = 1;\n@@ -94,6 +103,7 @@ proc setup_mips_tests {} {\n     file delete $src\n \n     regexp {isa = ([^;]*)} $output dummy mips_isa\n+    regexp {isa_rev = ([^;]*)} $output dummy mips_isa_rev\n     regexp {arch = \"([^\"]*)} $output dummy mips_arch\n     set mips_gp64 [regexp {gp64 = 1} $output]\n     set mips_fp64 [regexp {fp64 = 1} $output]\n@@ -104,6 +114,7 @@ proc setup_mips_tests {} {\n     set mips_forced_abi [regexp -- {-mabi} $compiler_flags]\n     set mips_forced_regs [regexp -- {(-mgp|-mfp)} $compiler_flags]\n     set mips_forced_float [regexp -- {-m(hard|soft)-float} $compiler_flags]\n+    set mips_forced_be [regexp -- {-(EB|meb)[[:>:]]} $compiler_flags]\n     set mips_forced_le [regexp -- {-(EL|mel)[[:>:]]} $compiler_flags]\n     set mips_forced_gp [regexp -- {-(G|m(|no-)((extern|local)-sdata|gpopt)|mabicalls|mrtp)} $compiler_flags]\n     set mips_forced_no_er [regexp -- {-mno-explicit-relocs} $compiler_flags]\n@@ -145,6 +156,12 @@ proc is_gp64_flag {flag} {\n #\tif the other flags don't do so.  Skip the test if the multilib\n #\tflags force a 32-bit ABI or a 32-bit architecture.\n #\n+#    -mfp64\n+#\tForce the use of 64-bit floating-point registers on a 32-bit target.\n+#\tAlso force -mhard-float and an architecture that supports such a\n+#\tcombination, unless these things are already specified by other\n+#\tparts of the given flags.\n+#\n #    -mabi=*\n #\tForce a particular ABI.  Skip the test if the multilib flags\n #\tforce a specific ABI or a different register size.\n@@ -160,8 +177,9 @@ proc is_gp64_flag {flag} {\n #\tmultilib flags force a different selection.\n #\n #    -EB\n-#\tSelect big-endian code.  Skip the test if the multilib flags\n-#\tforce a little-endian target.\n+#    -EL\n+#\tSelect the given endianness.  Skip the test if the multilib flags\n+#\tforce the opposite endianness.\n #\n #    -G*\n #    -m(no-)extern-sdata\n@@ -179,6 +197,7 @@ proc dg-mips-options {args} {\n     upvar dg-do-what do_what\n \n     global mips_isa\n+    global mips_isa_rev\n     global mips_arch\n     global mips_gp64\n     global mips_fp64\n@@ -189,6 +208,7 @@ proc dg-mips-options {args} {\n     global mips_forced_abi\n     global mips_forced_regs\n     global mips_forced_float\n+    global mips_forced_be\n     global mips_forced_le\n     global mips_forced_gp\n     global mips_forced_no_er\n@@ -197,6 +217,20 @@ proc dg-mips-options {args} {\n     set matches 1\n \n     # First handle the -mgp* options.  Add an architecture option if necessary.\n+    foreach flag $flags {\n+\tif {$flag == \"-mfp64\"} {\n+\t    if {!$mips_fp64 && $mips_forced_regs} {\n+\t\tset matches 0\n+\t    } else {\n+\t\tif {[lsearch -regexp $flags {^-m(hard|soft)-float$}] < 0} {\n+\t\t    append flags \" -mhard-float\"\n+\t\t}\n+\t\tif {[lsearch -regexp $flags {^(-mips|-march)}] < 0} {\n+\t\t    append flags \" -mips32r2\"\n+\t\t}\n+\t    }\n+\t}\n+    }\n     foreach flag $flags {\n \tif {[is_gp32_flag $flag]\n \t    && ($mips_gp64\n@@ -221,20 +255,20 @@ proc dg-mips-options {args} {\n     }\n     # Handle the other options.\n     foreach flag $flags {\n-\tif {$flag == \"-mfp64\"} {\n-\t    if {$mips_isa < 33 || $mips_float != \"hard\"} {\n-\t\tset matches 0\n-\t    }\n-\t} elseif {[regexp -- {^-mabi=(.*)} $flag dummy abi]} {\n+\tif {[regexp -- {^-mabi=(.*)} $flag dummy abi]} {\n \t    if {$abi != $mips_abi && $mips_forced_abi} {\n \t\tset matches 0\n \t    }\n \t} elseif {[regexp -- {^-march=(.*)} $flag dummy arch]} {\n \t    if {$arch != $mips_arch && $mips_forced_isa} {\n \t\tset matches 0\n \t    }\n-\t} elseif {[regexp -- {^-mips(.*)} $flag dummy isa] && $isa != 16} {\n-\t    if {$isa != $mips_isa && $mips_forced_isa} {\n+\t} elseif {[regexp -- {^-mips(.*)} $flag dummy isa]} {\n+\t    if {![regexp {(.*)r(.*)} $isa dummy isa isa_rev]} {\n+\t\tset isa_rev 1\n+\t    }\n+\t    if {($isa != $mips_isa || $isa_rev != $mips_isa_rev)\n+\t\t&& $mips_forced_isa} {\n \t\tset matches 0\n \t    }\n \t} elseif {[regexp -- {^-m(hard|soft)-float} $flag dummy float]} {\n@@ -245,6 +279,10 @@ proc dg-mips-options {args} {\n \t    if {$mips_forced_le} {\n \t\tset matches 0\n \t    }\n+\t} elseif {[regexp -- {^-(EL|mel)$} $flag]} {\n+\t    if {$mips_forced_be} {\n+\t\tset matches 0\n+\t    }\n \t} elseif {[regexp -- {^-(G|m(|no-)((extern|local)-sdata|gpopt))} $flag]} {\n \t    append flags \" -mno-abicalls\"\n \t    if {$mips_forced_gp} {"}, {"sha": "9257612cc17194d7b73950dd7e46f979939ed914", "filename": "gcc/testsuite/gcc.target/mips/mips32r2-mxhc1.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0064fbe9b6d395c794fc021d6dc97b40f9d7ac92/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fmips%2Fmips32r2-mxhc1.c?ref=0064fbe9b6d395c794fc021d6dc97b40f9d7ac92", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-mips-options \"-O -march=mips32r2 -mabi=32 -mfp64\" } */\n+/* { dg-mips-options \"-O -mabi=32 -mfp64\" } */\n /* { dg-final { scan-assembler \"mthc1\" } } */\n /* { dg-final { scan-assembler \"mfhc1\" } } */\n "}]}