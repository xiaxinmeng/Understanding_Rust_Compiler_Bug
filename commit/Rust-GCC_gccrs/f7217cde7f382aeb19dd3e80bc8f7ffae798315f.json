{"sha": "f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZjcyMTdjZGU3ZjM4MmFlYjE5ZGQzZTgwYmM4ZjdmZmFlNzk4MzE1Zg==", "commit": {"author": {"name": "Jan Hubicka", "email": "hubicka@ucw.cz", "date": "2014-09-19T23:56:52Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2014-09-19T23:56:52Z"}, "message": "re PR c++/61825 (g++.dg/cpp0x/static_assert9.C FAILs)\n\n\n\tPR c++/61825\n\t* c-family/c-common.c (handle_alias_ifunc_attribute): Check\n\tthat visibility change is possible\n\t(handle_weakref_attribute): Likewise.\n\t* cgraph.h (symtab_node): Add method get_create and\n\tfield refuse_visibility_changes.\n\t(symtab_node::get_create): New method.\n\t* fold-const.c (tree_single_nonzero_warnv_p): Use get_create.\n\t* varasm.c (mark_weak): Verify that visibility change is\n\tpossible.\n\n\t* gcc.dg/tree-ssa/nonzero-1.c: Require error to be output.\n\nFrom-SVN: r215409", "tree": {"sha": "d7d5f6d00208bddb323b80ac27eed3ded29bed4a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d7d5f6d00208bddb323b80ac27eed3ded29bed4a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/comments", "author": null, "committer": null, "parents": [{"sha": "3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3f99b0612f7db76b6ed1a25ecce8fa327eec9f61"}], "stats": {"total": 99, "additions": 80, "deletions": 19}, "files": [{"sha": "c345dc174dd16605997cdc2c7dc2fc943a808ddb", "filename": "gcc/ChangeLog", "status": "modified", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -1,3 +1,16 @@\n+2014-09-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR c++/61825\n+\t* c-family/c-common.c (handle_alias_ifunc_attribute): Check\n+\tthat visibility change is possible\n+\t(handle_weakref_attribute): Likewise.\n+\t* cgraph.h (symtab_node): Add method get_create and\n+\tfield refuse_visibility_changes.\n+\t(symtab_node::get_create): New method.\n+\t* fold-const.c (tree_single_nonzero_warnv_p): Use get_create.\n+\t* varasm.c (mark_weak): Verify that visibility change is\n+\tpossible.\n+\n 2014-09-19  Michael Meissner  <meissner@linux.vnet.ibm.com>\n \n \t* config/rs6000/predicates.md (fusion_gpr_mem_load): Move testing"}, {"sha": "818c32d68a0e0af558640954bd2bbd09a02598f3", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -7757,6 +7757,19 @@ handle_alias_ifunc_attribute (bool is_alias, tree *node, tree name, tree args,\n       *no_add_attrs = true;\n     }\n \n+  if (decl_in_symtab_p (*node))\n+    {\n+      struct symtab_node *n = symtab_node::get (decl);\n+      if (n && n->refuse_visibility_changes)\n+\t{\n+\t  if (is_alias)\n+\t    error (\"%+D declared alias after being used\", decl);\n+\t  else\n+\t    error (\"%+D declared ifunc after being used\", decl);\n+\t}\n+    }\n+\n+\n   return NULL_TREE;\n }\n \n@@ -7833,6 +7846,13 @@ handle_weakref_attribute (tree *node, tree ARG_UNUSED (name), tree args,\n       DECL_WEAK (*node) = 1;\n     }\n \n+  if (decl_in_symtab_p (*node))\n+    {\n+      struct symtab_node *n = symtab_node::get (*node);\n+      if (n && n->refuse_visibility_changes)\n+\terror (\"%+D declared weakref after being used\", *node);\n+    }\n+\n   return NULL_TREE;\n }\n "}, {"sha": "a316e406ce7af4e972846eefaffe278f09367f89", "filename": "gcc/cgraph.h", "status": "modified", "additions": 15, "deletions": 1, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fcgraph.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fcgraph.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcgraph.h?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -346,6 +346,10 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n     return decl->decl_with_vis.symtab_node;\n   }\n \n+  /* Try to find a symtab node for declaration DECL and if it does not\n+     exist or if it corresponds to an inline clone, create a new one.  */\n+  static inline symtab_node * get_create (tree node);\n+\n   /* Return the cgraph node that has ASMNAME for its DECL_ASSEMBLER_NAME.\n      Return NULL if there's no such node.  */\n   static symtab_node *get_for_asmname (const_tree asmname);\n@@ -394,7 +398,9 @@ class GTY((desc (\"%h.type\"), tag (\"SYMTAB_SYMBOL\"),\n   unsigned analyzed : 1;\n   /* Set for write-only variables.  */\n   unsigned writeonly : 1;\n-\n+  /* Visibility of symbol was used for further optimization; do not\n+     permit further changes.  */\n+  unsigned refuse_visibility_changes : 1;\n \n   /*** Visibility and linkage flags.  ***/\n \n@@ -2519,4 +2525,12 @@ cgraph_node::mark_force_output (void)\n   gcc_checking_assert (!global.inlined_to);\n }\n \n+inline symtab_node * symtab_node::get_create (tree node)\n+{\n+  if (TREE_CODE (node) == VAR_DECL)\n+    return varpool_node::get_create (node);\n+  else\n+    return cgraph_node::get_create (node);\n+}\n+\n #endif  /* GCC_CGRAPH_H  */"}, {"sha": "5cfc6461a4bf6b24dba870bdc742b879607f3f54", "filename": "gcc/fold-const.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ffold-const.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ffold-const.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffold-const.c?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -15850,7 +15850,7 @@ tree_single_nonzero_warnv_p (tree t, bool *strict_overflow_p)\n \t  {\n \t    struct symtab_node *symbol;\n \n-\t    symbol = symtab_node::get (base);\n+\t    symbol = symtab_node::get_create (base);\n \t    if (symbol)\n \t      return symbol->nonzero_address ();\n \t    else"}, {"sha": "9590fc83dd2c320501e634361a9ddd4b658c386c", "filename": "gcc/symtab.c", "status": "modified", "additions": 18, "deletions": 12, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fsymtab.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fsymtab.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fsymtab.c?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -1811,9 +1811,9 @@ bool\n symtab_node::nonzero_address ()\n {\n   /* Weakrefs may be NULL when their target is not defined.  */\n-  if (this->alias && this->weakref)\n+  if (alias && weakref)\n     {\n-      if (this->analyzed)\n+      if (analyzed)\n \t{\n \t  symtab_node *target = ultimate_alias_target ();\n \n@@ -1828,7 +1828,7 @@ symtab_node::nonzero_address ()\n \t     could be useful to eliminate the NULL pointer checks in LTO\n \t     programs.  */\n \t  if (target->definition && !DECL_EXTERNAL (target->decl))\n-\t    return true;\n+\t      return true;\n \t  if (target->resolution != LDPR_UNKNOWN\n \t      && target->resolution != LDPR_UNDEF\n \t      && flag_delete_null_pointer_checks)\n@@ -1847,22 +1847,28 @@ symtab_node::nonzero_address ()\n      Those are handled by later check for definition.\n \n      When parsing, beware the cases when WEAK attribute is added later.  */\n-  if (!DECL_WEAK (this->decl)\n-      && flag_delete_null_pointer_checks\n-      && symtab->state > PARSING)\n-    return true;\n+  if (!DECL_WEAK (decl)\n+      && flag_delete_null_pointer_checks)\n+    {\n+      refuse_visibility_changes = true;\n+      return true;\n+    }\n \n   /* If target is defined and not extern, we know it will be output and thus\n      it will bind to non-NULL.\n      Play safe for flag_delete_null_pointer_checks where weak definition maye\n      be re-defined by NULL.  */\n-  if (this->definition && !DECL_EXTERNAL (this->decl)\n-      && (flag_delete_null_pointer_checks || !DECL_WEAK (this->decl)))\n-    return true;\n+  if (definition && !DECL_EXTERNAL (decl)\n+      && (flag_delete_null_pointer_checks || !DECL_WEAK (decl)))\n+    {\n+      if (!DECL_WEAK (decl))\n+        refuse_visibility_changes = true;\n+      return true;\n+    }\n \n   /* As the last resort, check the resolution info.  */\n-  if (this->resolution != LDPR_UNKNOWN\n-      && this->resolution != LDPR_UNDEF\n+  if (resolution != LDPR_UNKNOWN\n+      && resolution != LDPR_UNDEF\n       && flag_delete_null_pointer_checks)\n     return true;\n   return false;"}, {"sha": "130c6a75b1d07efbb065a3d42a41f1d16836afb4", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -1,3 +1,8 @@\n+2014-09-19  Jan Hubicka  <hubicka@ucw.cz>\n+\n+\tPR c++/61825\n+\t* gcc.dg/tree-ssa/nonzero-1.c: Require error to be output.\n+\n 2014-09-19  Andi Kleen  <ak@linux.intel.com>\n \n \t* gcc.dg/pg-override.c: Only run on x86 Linux."}, {"sha": "52e4a9a34747020cbcfa3d89c316503ab0b60c36", "filename": "gcc/testsuite/gcc.dg/tree-ssa/nonzero-1.c", "status": "modified", "additions": 2, "deletions": 5, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fnonzero-1.c?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -1,11 +1,8 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n-extern int a;\n+/* { dg-options \"-O2\" } */\n+extern int a; /* { dg-error \"declared weak after being used\" } */\n t()\n {\n   return &a!=0;\n }\n extern int a __attribute__ ((weak));\n-\n-/* { dg-final { scan-tree-dump-not \"return 1\" \"optimized\"} } */\n-/* { dg-final { cleanup-tree-dump \"optimized\" } } */"}, {"sha": "dd3211a2c5c37ae6a8de546e949decd921e90c24", "filename": "gcc/varasm.c", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fvarasm.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/f7217cde7f382aeb19dd3e80bc8f7ffae798315f/gcc%2Fvarasm.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fvarasm.c?ref=f7217cde7f382aeb19dd3e80bc8f7ffae798315f", "patch": "@@ -5230,6 +5230,12 @@ output_constructor (tree exp, unsigned HOST_WIDE_INT size,\n static void\n mark_weak (tree decl)\n {\n+  if (DECL_WEAK (decl))\n+    return;\n+\n+  struct symtab_node *n = symtab_node::get (decl);\n+  if (n && n->refuse_visibility_changes)\n+    error (\"%+D declared weak after being used\", decl);\n   DECL_WEAK (decl) = 1;\n \n   if (DECL_RTL_SET_P (decl)"}]}