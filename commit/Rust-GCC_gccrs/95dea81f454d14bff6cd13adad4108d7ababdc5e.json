{"sha": "95dea81f454d14bff6cd13adad4108d7ababdc5e", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OTVkZWE4MWY0NTRkMTRiZmY2Y2QxM2FkYWQ0MTA4ZDdhYmFiZGM1ZQ==", "commit": {"author": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-25T21:29:29Z"}, "committer": {"name": "Jim Wilson", "email": "wilson@gcc.gnu.org", "date": "1993-04-25T21:29:29Z"}, "message": "(TARGET_HOPE_ALIGN, TARGET_FORCE_ALIGN): Delete.\n\n(TARGET_UNALIGNED_DOUBLES): Define.\n(TARGET_SWITCHES): Delete hope-align, force-align.  Add\nunaligned-doubles and no-unaligned-doubles.\n(ROUND_REG): Delete.\n(FIRST_PARM_OFFSET, FUNCTION_ARG_ADVANCE, FUNCTION_ARG,\nFUNCTION_INCOMING_ARG, FUNCTION_ARG_PARTIAL_NREGS,\nFUNCTION_ARG_BOUNDARY): Delete force-align support.\n(LONG_DOUBLE_TYPE_SIZE): Define to 128.\n\nFrom-SVN: r4223", "tree": {"sha": "054b0e9f8c7f564b319b65f08291e6af105471c7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/054b0e9f8c7f564b319b65f08291e6af105471c7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/95dea81f454d14bff6cd13adad4108d7ababdc5e", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dea81f454d14bff6cd13adad4108d7ababdc5e", "html_url": "https://github.com/Rust-GCC/gccrs/commit/95dea81f454d14bff6cd13adad4108d7ababdc5e", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/95dea81f454d14bff6cd13adad4108d7ababdc5e/comments", "author": null, "committer": null, "parents": [{"sha": "56b7c17e4966ca659a04153a62427eaf8895e3ad", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/56b7c17e4966ca659a04153a62427eaf8895e3ad", "html_url": "https://github.com/Rust-GCC/gccrs/commit/56b7c17e4966ca659a04153a62427eaf8895e3ad"}], "stats": {"total": 85, "additions": 22, "deletions": 63}, "files": [{"sha": "0322d5c0473c855cecd34d3ccf9c30a25bade063", "filename": "gcc/config/sparc/sparc.h", "status": "modified", "additions": 22, "deletions": 63, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/95dea81f454d14bff6cd13adad4108d7ababdc5e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/95dea81f454d14bff6cd13adad4108d7ababdc5e/gcc%2Fconfig%2Fsparc%2Fsparc.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fsparc%2Fsparc.h?ref=95dea81f454d14bff6cd13adad4108d7ababdc5e", "patch": "@@ -42,11 +42,9 @@ the Free Software Foundation, 675 Mass Ave, Cambridge, MA 02139, USA.  */\n \n #define CC1_SPEC \"%{sun4:} %{target:}\"\n \n-#if 0\n-/* Sparc ABI says that long double is 4 words.\n-   ??? This doesn't work yet.  */\n+/* Sparc ABI says that long double is 4 words.  */\n+\n #define LONG_DOUBLE_TYPE_SIZE 128\n-#endif\n \n #define PTRDIFF_TYPE \"int\"\n #define SIZE_TYPE \"int\"\n@@ -107,17 +105,10 @@ extern int target_flags;\n    use fast return insns, but lose some generality.  */\n #define TARGET_EPILOGUE (target_flags & 2)\n \n-/* Nonzero means that reference doublewords as if they were guaranteed\n-   to be aligned...if they aren't, too bad for the user!\n-   Like -dalign in Sun cc.  */\n-#define TARGET_HOPE_ALIGN (target_flags & 16)\n-\n-/* Nonzero means make sure all doubles are on 8-byte boundaries.\n-   This option results in a calling convention that is incompatible with\n-   every other sparc compiler in the world, and thus should only ever be\n-   used for experimenting.  Also, varargs won't work with it, but it doesn't\n-   seem worth trying to fix.  */\n-#define TARGET_FORCE_ALIGN (target_flags & 32)\n+/* Nonzero if we should assume that double pointers might be unaligned.\n+   This can happen when linking gcc compiled code with other compilers,\n+   because the ABI only guarantees 4 byte alignment.  */\n+#define TARGET_UNALIGNED_DOUBLES (target_flags & 4)\n \n /* Nonzero means that we should generate code for a v8 sparc.  */\n #define TARGET_V8 (target_flags & 64)\n@@ -154,8 +145,8 @@ extern int target_flags;\n     {\"soft-float\", -1},\t\t\\\n     {\"epilogue\", 2},\t\t\\\n     {\"no-epilogue\", -2},\t\\\n-    {\"hope-align\", 16},\t\t\\\n-    {\"force-align\", 48},\t\\\n+    {\"unaligned-doubles\", 4},\t\\\n+    {\"no-unaligned-doubles\", -4},\\\n     {\"v8\", 64},\t\t\t\\\n     {\"no-v8\", -64},\t\t\\\n     {\"sparclite\", 128},\t\t\\\n@@ -679,11 +670,8 @@ extern char leaf_reg_backmap[];\n \n /* Offset of first parameter from the argument pointer register value.\n    This is 64 for the ins and locals, plus 4 for the struct-return reg\n-   even if this function isn't going to use it.\n-   If TARGET_FORCE_ALIGN, we must reserve 4 more bytes to ensure that the\n-   stack remains aligned.  */\n-#define FIRST_PARM_OFFSET(FNDECL) \\\n-  (STRUCT_VALUE_OFFSET + UNITS_PER_WORD + (TARGET_FORCE_ALIGN ? 4 : 0))\n+   even if this function isn't going to use it.  */\n+#define FIRST_PARM_OFFSET(FNDECL) (STRUCT_VALUE_OFFSET + UNITS_PER_WORD)\n \n /* When a parameter is passed in a register, stack space is still\n    allocated for it.  */\n@@ -779,13 +767,6 @@ extern char leaf_reg_backmap[];\n #define ROUND_ADVANCE(SIZE)\t\\\n   ((SIZE + UNITS_PER_WORD - 1) / UNITS_PER_WORD)\n \n-/* Round a register number up to a proper boundary for an arg of mode MODE.\n-   Note that we need an odd/even pair for a two-word arg,\n-   since that will become 8-byte aligned when stored in memory.  */\n-#define ROUND_REG(X, MODE) \t\t\t\t\t\\\n- (TARGET_FORCE_ALIGN && GET_MODE_UNIT_SIZE ((MODE)) > 4\t\t\\\n-  ? ((X) + ! ((X) & 1)) : (X))\n-\n /* Initialize a variable CUM of type CUMULATIVE_ARGS\n    for a call to a function whose data type is FNTYPE.\n    For a library call, FNTYPE is 0.\n@@ -800,10 +781,9 @@ extern char leaf_reg_backmap[];\n    (TYPE is null for libcalls where that information may not be available.)  */\n \n #define FUNCTION_ARG_ADVANCE(CUM, MODE, TYPE, NAMED)\t\\\n- ((CUM) = (ROUND_REG ((CUM), (MODE))\t\t\t\\\n-\t   + ((MODE) != BLKmode\t\t\t\t\\\n-\t      ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n-\t      : ROUND_ADVANCE (int_size_in_bytes (TYPE)))))\n+  ((CUM) += ((MODE) != BLKmode\t\t\t\t\\\n+\t     ? ROUND_ADVANCE (GET_MODE_SIZE (MODE))\t\\\n+\t     : ROUND_ADVANCE (int_size_in_bytes (TYPE))))\n \n /* Determine where to put an argument to a function.\n    Value is zero to push the argument on the stack,\n@@ -823,24 +803,22 @@ extern char leaf_reg_backmap[];\n    is at least partially passed in a register unless its data type forbids.  */\n \n #define FUNCTION_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\t\\\n-(ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\t\\\n+((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n  && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n  && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n- ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t    (BASE_PASSING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\t\\\n+ ? gen_rtx (REG, (MODE), (BASE_PASSING_ARG_REG (MODE) + (CUM)))\t\t\\\n  : 0)\n \n /* Define where a function finds its arguments.\n    This is different from FUNCTION_ARG because of register windows.  */\n \n #define FUNCTION_INCOMING_ARG(CUM, MODE, TYPE, NAMED)\t\t\t\\\n-(ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\t\\\n+((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n  && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n  && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n      || (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n- ? gen_rtx (REG, (MODE),\t\t\t\t\t\t\\\n-\t    (BASE_INCOMING_ARG_REG (MODE) + ROUND_REG ((CUM), (MODE))))\t\\\n+ ? gen_rtx (REG, (MODE), (BASE_INCOMING_ARG_REG (MODE) + (CUM)))\t\\\n  : 0)\n \n /* For an arg passed partly in registers and partly in memory,\n@@ -850,15 +828,14 @@ extern char leaf_reg_backmap[];\n    needs partial registers on the Sparc.  */\n \n #define FUNCTION_ARG_PARTIAL_NREGS(CUM, MODE, TYPE, NAMED) \t\t\\\n-  ((ROUND_REG ((CUM), (MODE)) < NPARM_REGS\t\t\t\t\\\n+  ((CUM) < NPARM_REGS\t\t\t\t\t\t\t\\\n     && ((TYPE)==0 || ! TREE_ADDRESSABLE ((tree)(TYPE)))\t\t\t\\\n     && ((TYPE)==0 || (MODE) != BLKmode\t\t\t\t\t\\\n \t|| (TYPE_ALIGN ((TYPE)) % PARM_BOUNDARY == 0))\t\t\t\\\n-    && (ROUND_REG ((CUM), (MODE))\t\t\t\t\t\\\n-\t+ ((MODE) == BLKmode\t\t\t\t\t\t\\\n-\t   ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\t\\\n-\t   : ROUND_ADVANCE (GET_MODE_SIZE (MODE)))) - NPARM_REGS > 0)\t\\\n-   ? (NPARM_REGS - ROUND_REG ((CUM), (MODE)))\t\t\t\t\\\n+    && ((CUM) + ((MODE) == BLKmode\t\t\t\t\t\\\n+\t\t ? ROUND_ADVANCE (int_size_in_bytes (TYPE))\t\t\\\n+\t\t : ROUND_ADVANCE (GET_MODE_SIZE (MODE))) - NPARM_REGS > 0)\\\n+   ? (NPARM_REGS - (CUM))\t\t\t\t\t\t\\\n    : 0)\n \n /* The SPARC ABI stipulates passing struct arguments (of any size) and\n@@ -868,24 +845,6 @@ extern char leaf_reg_backmap[];\n \t    || TREE_CODE (TYPE) == UNION_TYPE))\t\t\t\t\\\n    || (MODE == TFmode))\n \n-/* If defined, a C expression that gives the alignment boundary, in\n-   bits, of an argument with the specified mode and type.  If it is\n-   not defined,  `PARM_BOUNDARY' is used for all arguments.\n-\n-   This definition does nothing special unless TARGET_FORCE_ALIGN;\n-   in that case, it aligns each arg to the natural boundary.  */\n-\n-#define FUNCTION_ARG_BOUNDARY(MODE, TYPE)\t\t\t\\\n- (! TARGET_FORCE_ALIGN\t\t\t\t\t\t\\\n-  ? PARM_BOUNDARY\t\t\t\t\t\t\\\n-  : (((TYPE) != 0)\t\t\t\t\t\t\\\n-     ? (TYPE_ALIGN (TYPE) <= PARM_BOUNDARY\t\t\t\\\n-\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n-\t: TYPE_ALIGN (TYPE))\t\t\t\t\t\\\n-     : (GET_MODE_ALIGNMENT (MODE) <= PARM_BOUNDARY\t\t\\\n-\t? PARM_BOUNDARY\t\t\t\t\t\t\\\n-\t: GET_MODE_ALIGNMENT (MODE))))\n-\n /* Define the information needed to generate branch and scc insns.  This is\n    stored from the compare operation.  Note that we can't use \"rtx\" here\n    since it hasn't been defined!  */"}]}