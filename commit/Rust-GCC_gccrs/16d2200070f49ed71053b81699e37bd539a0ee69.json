{"sha": "16d2200070f49ed71053b81699e37bd539a0ee69", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MTZkMjIwMDA3MGY0OWVkNzEwNTNiODE2OTllMzdiZDUzOWEwZWU2OQ==", "commit": {"author": {"name": "Richard Sandiford", "email": "richard.sandiford@linaro.org", "date": "2017-08-30T11:20:19Z"}, "committer": {"name": "Richard Sandiford", "email": "rsandifo@gcc.gnu.org", "date": "2017-08-30T11:20:19Z"}, "message": "[71/77] Use opt_scalar_mode for mode iterators\n\nThis patch uses opt_scalar_mode when iterating over scalar modes.\n\n2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n\t    Alan Hayward  <alan.hayward@arm.com>\n\t    David Sherwood  <david.sherwood@arm.com>\n\ngcc/\n\t* coretypes.h (opt_scalar_mode): New typedef.\n\t* gdbhooks.py (build_pretty_printers): Handle it.\n\t* machmode.h (mode_iterator::get_2xwider): Add overload for\n\topt_mode<T>.\n\t* emit-rtl.c (init_emit_once): Use opt_scalar_mode when iterating\n\tover scalar modes.\n\t* expr.c (convert_mode_scalar): Likewise.\n\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n\t* optabs.c (expand_float): Likewise.\n\t(expand_fix): Likewise.\n\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n\ngcc/c-family/\n\t* c-common.c (c_common_fixed_point_type_for_size): Use opt_scalar_mode\n\tfor the mode iterator.\n\nCo-Authored-By: Alan Hayward <alan.hayward@arm.com>\nCo-Authored-By: David Sherwood <david.sherwood@arm.com>\n\nFrom-SVN: r251522", "tree": {"sha": "c89eef6816d81c30d7695888167b3345c11aae26", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c89eef6816d81c30d7695888167b3345c11aae26"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/16d2200070f49ed71053b81699e37bd539a0ee69", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d2200070f49ed71053b81699e37bd539a0ee69", "html_url": "https://github.com/Rust-GCC/gccrs/commit/16d2200070f49ed71053b81699e37bd539a0ee69", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/16d2200070f49ed71053b81699e37bd539a0ee69/comments", "author": null, "committer": null, "parents": [{"sha": "f4f6058097d99812ee3eda98d09c23fccdc7ba94", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/f4f6058097d99812ee3eda98d09c23fccdc7ba94", "html_url": "https://github.com/Rust-GCC/gccrs/commit/f4f6058097d99812ee3eda98d09c23fccdc7ba94"}], "stats": {"total": 332, "additions": 198, "deletions": 134}, "files": [{"sha": "1f5302a704e122b43b635d536d7f012d07085c62", "filename": "gcc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -1,3 +1,19 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* coretypes.h (opt_scalar_mode): New typedef.\n+\t* gdbhooks.py (build_pretty_printers): Handle it.\n+\t* machmode.h (mode_iterator::get_2xwider): Add overload for\n+\topt_mode<T>.\n+\t* emit-rtl.c (init_emit_once): Use opt_scalar_mode when iterating\n+\tover scalar modes.\n+\t* expr.c (convert_mode_scalar): Likewise.\n+\t* omp-low.c (omp_clause_aligned_alignment): Likewise.\n+\t* optabs.c (expand_float): Likewise.\n+\t(expand_fix): Likewise.\n+\t* tree-vect-stmts.c (vectorizable_conversion): Likewise.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "a294404ec2efcf1a331791b0e80706d5ad1576ee", "filename": "gcc/c-family/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fc-family%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fc-family%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2FChangeLog?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -1,3 +1,10 @@\n+2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n+\t    Alan Hayward  <alan.hayward@arm.com>\n+\t    David Sherwood  <david.sherwood@arm.com>\n+\n+\t* c-common.c (c_common_fixed_point_type_for_size): Use opt_scalar_mode\n+\tfor the mode iterator.\n+\n 2017-08-30  Richard Sandiford  <richard.sandiford@linaro.org>\n \t    Alan Hayward  <alan.hayward@arm.com>\n \t    David Sherwood  <david.sherwood@arm.com>"}, {"sha": "d959dbc25bbbf8c4246ca11f8913e957ec8160f6", "filename": "gcc/c-family/c-common.c", "status": "modified", "additions": 9, "deletions": 5, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fc-family%2Fc-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fc-family%2Fc-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fc-family%2Fc-common.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -2155,12 +2155,16 @@ c_common_fixed_point_type_for_size (unsigned int ibit, unsigned int fbit,\n   else\n     mclass = unsignedp ? MODE_UACCUM : MODE_ACCUM;\n \n-  machine_mode mode;\n-  FOR_EACH_MODE_IN_CLASS (mode, mclass)\n-    if (GET_MODE_IBIT (mode) >= ibit && GET_MODE_FBIT (mode) >= fbit)\n-      break;\n+  opt_scalar_mode opt_mode;\n+  scalar_mode mode;\n+  FOR_EACH_MODE_IN_CLASS (opt_mode, mclass)\n+    {\n+      mode = opt_mode.require ();\n+      if (GET_MODE_IBIT (mode) >= ibit && GET_MODE_FBIT (mode) >= fbit)\n+\tbreak;\n+    }\n \n-  if (mode == VOIDmode || !targetm.scalar_mode_supported_p (mode))\n+  if (!opt_mode.exists (&mode) || !targetm.scalar_mode_supported_p (mode))\n     {\n       sorry (\"GCC cannot support operators with integer types and \"\n \t     \"fixed-point types that have too many integral and \""}, {"sha": "ffe793e409d8ec0647564e62009e083ce2366b8f", "filename": "gcc/coretypes.h", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fcoretypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fcoretypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcoretypes.h?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -59,6 +59,7 @@ class scalar_mode;\n class scalar_int_mode;\n class scalar_float_mode;\n template<typename> class opt_mode;\n+typedef opt_mode<scalar_mode> opt_scalar_mode;\n typedef opt_mode<scalar_int_mode> opt_scalar_int_mode;\n typedef opt_mode<scalar_float_mode> opt_scalar_float_mode;\n template<typename> class pod_mode;"}, {"sha": "3954648027c7a429b4f9ef9002766ed48808cd8f", "filename": "gcc/emit-rtl.c", "status": "modified", "additions": 49, "deletions": 43, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Femit-rtl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Femit-rtl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Femit-rtl.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -5885,6 +5885,7 @@ init_emit_once (void)\n   int i;\n   machine_mode mode;\n   scalar_float_mode double_mode;\n+  opt_scalar_mode smode_iter;\n \n   /* Initialize the CONST_INT, CONST_WIDE_INT, CONST_DOUBLE,\n      CONST_FIXED, and memory attribute hash tables.  */\n@@ -5999,62 +6000,66 @@ init_emit_once (void)\n       const_tiny_rtx[1][(int) mode] = gen_const_vector (mode, 1);\n     }\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_FRACT)\n+  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_FRACT)\n     {\n-      FCONST0 (mode).data.high = 0;\n-      FCONST0 (mode).data.low = 0;\n-      FCONST0 (mode).mode = mode;\n-      const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST0 (mode), mode);\n+      scalar_mode smode = smode_iter.require ();\n+      FCONST0 (smode).data.high = 0;\n+      FCONST0 (smode).data.low = 0;\n+      FCONST0 (smode).mode = smode;\n+      const_tiny_rtx[0][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST0 (smode), smode);\n     }\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_UFRACT)\n+  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_UFRACT)\n     {\n-      FCONST0 (mode).data.high = 0;\n-      FCONST0 (mode).data.low = 0;\n-      FCONST0 (mode).mode = mode;\n-      const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST0 (mode), mode);\n+      scalar_mode smode = smode_iter.require ();\n+      FCONST0 (smode).data.high = 0;\n+      FCONST0 (smode).data.low = 0;\n+      FCONST0 (smode).mode = smode;\n+      const_tiny_rtx[0][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST0 (smode), smode);\n     }\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_ACCUM)\n+  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_ACCUM)\n     {\n-      FCONST0 (mode).data.high = 0;\n-      FCONST0 (mode).data.low = 0;\n-      FCONST0 (mode).mode = mode;\n-      const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST0 (mode), mode);\n+      scalar_mode smode = smode_iter.require ();\n+      FCONST0 (smode).data.high = 0;\n+      FCONST0 (smode).data.low = 0;\n+      FCONST0 (smode).mode = smode;\n+      const_tiny_rtx[0][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST0 (smode), smode);\n \n       /* We store the value 1.  */\n-      FCONST1 (mode).data.high = 0;\n-      FCONST1 (mode).data.low = 0;\n-      FCONST1 (mode).mode = mode;\n-      FCONST1 (mode).data\n-\t= double_int_one.lshift (GET_MODE_FBIT (mode),\n+      FCONST1 (smode).data.high = 0;\n+      FCONST1 (smode).data.low = 0;\n+      FCONST1 (smode).mode = smode;\n+      FCONST1 (smode).data\n+\t= double_int_one.lshift (GET_MODE_FBIT (smode),\n \t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));\n-      const_tiny_rtx[1][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST1 (mode), mode);\n+\t\t\t\t SIGNED_FIXED_POINT_MODE_P (smode));\n+      const_tiny_rtx[1][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST1 (smode), smode);\n     }\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_UACCUM)\n+  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_UACCUM)\n     {\n-      FCONST0 (mode).data.high = 0;\n-      FCONST0 (mode).data.low = 0;\n-      FCONST0 (mode).mode = mode;\n-      const_tiny_rtx[0][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST0 (mode), mode);\n+      scalar_mode smode = smode_iter.require ();\n+      FCONST0 (smode).data.high = 0;\n+      FCONST0 (smode).data.low = 0;\n+      FCONST0 (smode).mode = smode;\n+      const_tiny_rtx[0][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST0 (smode), smode);\n \n       /* We store the value 1.  */\n-      FCONST1 (mode).data.high = 0;\n-      FCONST1 (mode).data.low = 0;\n-      FCONST1 (mode).mode = mode;\n-      FCONST1 (mode).data\n-\t= double_int_one.lshift (GET_MODE_FBIT (mode),\n+      FCONST1 (smode).data.high = 0;\n+      FCONST1 (smode).data.low = 0;\n+      FCONST1 (smode).mode = smode;\n+      FCONST1 (smode).data\n+\t= double_int_one.lshift (GET_MODE_FBIT (smode),\n \t\t\t\t HOST_BITS_PER_DOUBLE_INT,\n-\t\t\t\t SIGNED_FIXED_POINT_MODE_P (mode));\n-      const_tiny_rtx[1][(int) mode] = CONST_FIXED_FROM_FIXED_VALUE (\n-\t\t\t\t      FCONST1 (mode), mode);\n+\t\t\t\t SIGNED_FIXED_POINT_MODE_P (smode));\n+      const_tiny_rtx[1][(int) smode]\n+\t= CONST_FIXED_FROM_FIXED_VALUE (FCONST1 (smode), smode);\n     }\n \n   FOR_EACH_MODE_IN_CLASS (mode, MODE_VECTOR_FRACT)\n@@ -6087,10 +6092,11 @@ init_emit_once (void)\n   if (STORE_FLAG_VALUE == 1)\n     const_tiny_rtx[1][(int) BImode] = const1_rtx;\n \n-  FOR_EACH_MODE_IN_CLASS (mode, MODE_POINTER_BOUNDS)\n+  FOR_EACH_MODE_IN_CLASS (smode_iter, MODE_POINTER_BOUNDS)\n     {\n-      wide_int wi_zero = wi::zero (GET_MODE_PRECISION (mode));\n-      const_tiny_rtx[0][mode] = immed_wide_int_const (wi_zero, mode);\n+      scalar_mode smode = smode_iter.require ();\n+      wide_int wi_zero = wi::zero (GET_MODE_PRECISION (smode));\n+      const_tiny_rtx[0][smode] = immed_wide_int_const (wi_zero, smode);\n     }\n \n   pc_rtx = gen_rtx_fmt_ (PC, VOIDmode);"}, {"sha": "8656f07299934e86bec8812af0d30d4b464d41de", "filename": "gcc/expr.c", "status": "modified", "additions": 18, "deletions": 13, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -559,23 +559,28 @@ convert_mode_scalar (rtx to, rtx from, int unsignedp)\n \t}\n       else\n \t{\n-\t  machine_mode intermediate;\n+\t  scalar_mode intermediate;\n \t  rtx tmp;\n \t  int shift_amount;\n \n \t  /* Search for a mode to convert via.  */\n-\t  FOR_EACH_MODE_FROM (intermediate, from_mode)\n-\t    if (((can_extend_p (to_mode, intermediate, unsignedp)\n-\t\t  != CODE_FOR_nothing)\n-\t\t || (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (intermediate)\n-\t\t     && TRULY_NOOP_TRUNCATION_MODES_P (to_mode, intermediate)))\n-\t\t&& (can_extend_p (intermediate, from_mode, unsignedp)\n-\t\t    != CODE_FOR_nothing))\n-\t      {\n-\t\tconvert_move (to, convert_to_mode (intermediate, from,\n-\t\t\t\t\t\t   unsignedp), unsignedp);\n-\t\treturn;\n-\t      }\n+\t  opt_scalar_mode intermediate_iter;\n+\t  FOR_EACH_MODE_FROM (intermediate_iter, from_mode)\n+\t    {\n+\t      scalar_mode intermediate = intermediate_iter.require ();\n+\t      if (((can_extend_p (to_mode, intermediate, unsignedp)\n+\t\t    != CODE_FOR_nothing)\n+\t\t   || (GET_MODE_SIZE (to_mode) < GET_MODE_SIZE (intermediate)\n+\t\t       && TRULY_NOOP_TRUNCATION_MODES_P (to_mode,\n+\t\t\t\t\t\t\t intermediate)))\n+\t\t  && (can_extend_p (intermediate, from_mode, unsignedp)\n+\t\t      != CODE_FOR_nothing))\n+\t\t{\n+\t\t  convert_move (to, convert_to_mode (intermediate, from,\n+\t\t\t\t\t\t     unsignedp), unsignedp);\n+\t\t  return;\n+\t\t}\n+\t    }\n \n \t  /* No suitable intermediate mode.\n \t     Generate what we need with\tshifts.  */"}, {"sha": "e5f0cf6f31b9cc1257e366b50a461f1db91534c8", "filename": "gcc/gdbhooks.py", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fgdbhooks.py", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fgdbhooks.py", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgdbhooks.py?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -543,7 +543,8 @@ def build_pretty_printer():\n     pp.add_printer_for_regex(r'opt_mode<(\\S+)>',\n                              'opt_mode', OptMachineModePrinter)\n     pp.add_printer_for_types(['opt_scalar_int_mode',\n-                              'opt_scalar_float_mode'],\n+                              'opt_scalar_float_mode',\n+                              'opt_scalar_mode'],\n                              'opt_mode', OptMachineModePrinter)\n     pp.add_printer_for_regex(r'pod_mode<(\\S+)>',\n                              'pod_mode', MachineModePrinter)"}, {"sha": "5d84a2eca583ec7181bacfaecd2629f032cceef2", "filename": "gcc/machmode.h", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fmachmode.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fmachmode.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fmachmode.h?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -835,6 +835,13 @@ namespace mode_iterator\n   /* Set mode iterator *ITER to the mode that is two times wider than the\n      current one, if such a mode exists.  */\n \n+  template<typename T>\n+  inline void\n+  get_2xwider (opt_mode<T> *iter)\n+  {\n+    *iter = GET_MODE_2XWIDER_MODE (iter->require ());\n+  }\n+\n   inline void\n   get_2xwider (machine_mode *iter)\n   {"}, {"sha": "080f2f4a9941f716a24f5538111bb7da57ee29df", "filename": "gcc/omp-low.c", "status": "modified", "additions": 5, "deletions": 3, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fomp-low.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Fomp-low.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fomp-low.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -3442,16 +3442,18 @@ omp_clause_aligned_alignment (tree clause)\n \n   /* Otherwise return implementation defined alignment.  */\n   unsigned int al = 1;\n-  machine_mode mode, vmode;\n+  opt_scalar_mode mode_iter;\n   int vs = targetm.vectorize.autovectorize_vector_sizes ();\n   if (vs)\n     vs = 1 << floor_log2 (vs);\n   static enum mode_class classes[]\n     = { MODE_INT, MODE_VECTOR_INT, MODE_FLOAT, MODE_VECTOR_FLOAT };\n   for (int i = 0; i < 4; i += 2)\n-    FOR_EACH_MODE_IN_CLASS (mode, classes[i])\n+    /* The for loop above dictates that we only walk through scalar classes.  */\n+    FOR_EACH_MODE_IN_CLASS (mode_iter, classes[i])\n       {\n-\tvmode = targetm.vectorize.preferred_simd_mode (mode);\n+\tscalar_mode mode = mode_iter.require ();\n+\tmachine_mode vmode = targetm.vectorize.preferred_simd_mode (mode);\n \tif (GET_MODE_CLASS (vmode) != classes[i + 1])\n \t  continue;\n \twhile (vs"}, {"sha": "d30e4c6233f996b355bf5456cbabfa14b658ffaa", "filename": "gcc/optabs.c", "status": "modified", "additions": 73, "deletions": 64, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Foptabs.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Foptabs.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Foptabs.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -4692,6 +4692,7 @@ expand_float (rtx to, rtx from, int unsignedp)\n       && is_a <scalar_mode> (GET_MODE (to), &to_mode)\n       && is_a <scalar_mode> (GET_MODE (from), &from_mode))\n     {\n+      opt_scalar_mode fmode_iter;\n       rtx_code_label *label = gen_label_rtx ();\n       rtx temp;\n       REAL_VALUE_TYPE offset;\n@@ -4700,12 +4701,15 @@ expand_float (rtx to, rtx from, int unsignedp)\n \t least as wide as the target.  Using FMODE will avoid rounding woes\n \t with unsigned values greater than the signed maximum value.  */\n \n-      FOR_EACH_MODE_FROM (fmode, to_mode)\n-\tif (GET_MODE_PRECISION (from_mode) < GET_MODE_BITSIZE (fmode)\n-\t    && can_float_p (fmode, from_mode, 0) != CODE_FOR_nothing)\n-\t  break;\n+      FOR_EACH_MODE_FROM (fmode_iter, to_mode)\n+\t{\n+\t  scalar_mode fmode = fmode_iter.require ();\n+\t  if (GET_MODE_PRECISION (from_mode) < GET_MODE_BITSIZE (fmode)\n+\t      && can_float_p (fmode, from_mode, 0) != CODE_FOR_nothing)\n+\t    break;\n+\t}\n \n-      if (fmode == VOIDmode)\n+      if (!fmode_iter.exists (&fmode))\n \t{\n \t  /* There is no such mode.  Pretend the target is wide enough.  */\n \t  fmode = to_mode;\n@@ -4840,6 +4844,7 @@ expand_fix (rtx to, rtx from, int unsignedp)\n   enum insn_code icode;\n   rtx target = to;\n   machine_mode fmode, imode;\n+  opt_scalar_mode fmode_iter;\n   bool must_trunc = false;\n \n   /* We first try to find a pair of modes, one real and one integer, at\n@@ -4911,66 +4916,70 @@ expand_fix (rtx to, rtx from, int unsignedp)\n   if (unsignedp\n       && is_a <scalar_int_mode> (GET_MODE (to), &to_mode)\n       && HWI_COMPUTABLE_MODE_P (to_mode))\n-    FOR_EACH_MODE_FROM (fmode, GET_MODE (from))\n-      if (CODE_FOR_nothing != can_fix_p (to_mode, fmode, 0, &must_trunc)\n-\t  && (!DECIMAL_FLOAT_MODE_P (fmode)\n-\t      || GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (to_mode)))\n-\t{\n-\t  int bitsize;\n-\t  REAL_VALUE_TYPE offset;\n-\t  rtx limit;\n-\t  rtx_code_label *lab1, *lab2;\n-\t  rtx_insn *insn;\n-\n-\t  bitsize = GET_MODE_PRECISION (to_mode);\n-\t  real_2expN (&offset, bitsize - 1, fmode);\n-\t  limit = const_double_from_real_value (offset, fmode);\n-\t  lab1 = gen_label_rtx ();\n-\t  lab2 = gen_label_rtx ();\n-\n-\t  if (fmode != GET_MODE (from))\n-\t    from = convert_to_mode (fmode, from, 0);\n-\n-\t  /* See if we need to do the subtraction.  */\n-\t  do_pending_stack_adjust ();\n-\t  emit_cmp_and_jump_insns (from, limit, GE, NULL_RTX, GET_MODE (from),\n-\t\t\t\t   0, lab1);\n-\n-\t  /* If not, do the signed \"fix\" and branch around fixup code.  */\n-\t  expand_fix (to, from, 0);\n-\t  emit_jump_insn (targetm.gen_jump (lab2));\n-\t  emit_barrier ();\n-\n-\t  /* Otherwise, subtract 2**(N-1), convert to signed number,\n-\t     then add 2**(N-1).  Do the addition using XOR since this\n-\t     will often generate better code.  */\n-\t  emit_label (lab1);\n-\t  target = expand_binop (GET_MODE (from), sub_optab, from, limit,\n-\t\t\t\t NULL_RTX, 0, OPTAB_LIB_WIDEN);\n-\t  expand_fix (to, target, 0);\n-\t  target = expand_binop (to_mode, xor_optab, to,\n-\t\t\t\t gen_int_mode\n-\t\t\t\t (HOST_WIDE_INT_1 << (bitsize - 1),\n-\t\t\t\t  to_mode),\n-\t\t\t\t to, 1, OPTAB_LIB_WIDEN);\n-\n-\t  if (target != to)\n-\t    emit_move_insn (to, target);\n-\n-\t  emit_label (lab2);\n-\n-\t  if (optab_handler (mov_optab, to_mode) != CODE_FOR_nothing)\n-\t    {\n-\t      /* Make a place for a REG_NOTE and add it.  */\n-\t      insn = emit_move_insn (to, to);\n-\t      set_dst_reg_note (insn, REG_EQUAL,\n-\t\t\t\tgen_rtx_fmt_e (UNSIGNED_FIX, to_mode,\n-\t\t\t\t\t       copy_rtx (from)),\n-\t\t\t\tto);\n-\t    }\n+    FOR_EACH_MODE_FROM (fmode_iter, as_a <scalar_mode> (GET_MODE (from)))\n+      {\n+\tscalar_mode fmode = fmode_iter.require ();\n+\tif (CODE_FOR_nothing != can_fix_p (to_mode, fmode,\n+\t\t\t\t\t   0, &must_trunc)\n+\t    && (!DECIMAL_FLOAT_MODE_P (fmode)\n+\t\t|| (GET_MODE_BITSIZE (fmode) > GET_MODE_PRECISION (to_mode))))\n+\t  {\n+\t    int bitsize;\n+\t    REAL_VALUE_TYPE offset;\n+\t    rtx limit;\n+\t    rtx_code_label *lab1, *lab2;\n+\t    rtx_insn *insn;\n+\n+\t    bitsize = GET_MODE_PRECISION (to_mode);\n+\t    real_2expN (&offset, bitsize - 1, fmode);\n+\t    limit = const_double_from_real_value (offset, fmode);\n+\t    lab1 = gen_label_rtx ();\n+\t    lab2 = gen_label_rtx ();\n \n-\t  return;\n-\t}\n+\t    if (fmode != GET_MODE (from))\n+\t      from = convert_to_mode (fmode, from, 0);\n+\n+\t    /* See if we need to do the subtraction.  */\n+\t    do_pending_stack_adjust ();\n+\t    emit_cmp_and_jump_insns (from, limit, GE, NULL_RTX,\n+\t\t\t\t     GET_MODE (from), 0, lab1);\n+\n+\t    /* If not, do the signed \"fix\" and branch around fixup code.  */\n+\t    expand_fix (to, from, 0);\n+\t    emit_jump_insn (targetm.gen_jump (lab2));\n+\t    emit_barrier ();\n+\n+\t    /* Otherwise, subtract 2**(N-1), convert to signed number,\n+\t       then add 2**(N-1).  Do the addition using XOR since this\n+\t       will often generate better code.  */\n+\t    emit_label (lab1);\n+\t    target = expand_binop (GET_MODE (from), sub_optab, from, limit,\n+\t\t\t\t   NULL_RTX, 0, OPTAB_LIB_WIDEN);\n+\t    expand_fix (to, target, 0);\n+\t    target = expand_binop (to_mode, xor_optab, to,\n+\t\t\t\t   gen_int_mode\n+\t\t\t\t   (HOST_WIDE_INT_1 << (bitsize - 1),\n+\t\t\t\t    to_mode),\n+\t\t\t\t   to, 1, OPTAB_LIB_WIDEN);\n+\n+\t    if (target != to)\n+\t      emit_move_insn (to, target);\n+\n+\t    emit_label (lab2);\n+\n+\t    if (optab_handler (mov_optab, to_mode) != CODE_FOR_nothing)\n+\t      {\n+\t\t/* Make a place for a REG_NOTE and add it.  */\n+\t\tinsn = emit_move_insn (to, to);\n+\t\tset_dst_reg_note (insn, REG_EQUAL,\n+\t\t\t\t  gen_rtx_fmt_e (UNSIGNED_FIX, to_mode,\n+\t\t\t\t\t\t copy_rtx (from)),\n+\t\t\t\t  to);\n+\t      }\n+\n+\t    return;\n+\t  }\n+      }\n \n   /* We can't do it with an insn, so use a library call.  But first ensure\n      that the mode of TO is at least as wide as SImode, since those are the"}, {"sha": "14089a65659d26ebdc01e336d6e8f0f2ab13fcbb", "filename": "gcc/tree-vect-stmts.c", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Ftree-vect-stmts.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/16d2200070f49ed71053b81699e37bd539a0ee69/gcc%2Ftree-vect-stmts.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-vect-stmts.c?ref=16d2200070f49ed71053b81699e37bd539a0ee69", "patch": "@@ -4212,8 +4212,10 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n      needs to be generated.  */\n   gcc_assert (ncopies >= 1);\n \n-  machine_mode lhs_mode = SCALAR_TYPE_MODE (lhs_type);\n-  machine_mode rhs_mode = SCALAR_TYPE_MODE (rhs_type);\n+  bool found_mode = false;\n+  scalar_mode lhs_mode = SCALAR_TYPE_MODE (lhs_type);\n+  scalar_mode rhs_mode = SCALAR_TYPE_MODE (rhs_type);\n+  opt_scalar_mode rhs_mode_iter;\n \n   /* Supportable by target?  */\n   switch (modifier)\n@@ -4247,8 +4249,9 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \tgoto unsupported;\n \n       fltsz = GET_MODE_SIZE (lhs_mode);\n-      FOR_EACH_2XWIDER_MODE (rhs_mode, rhs_mode)\n+      FOR_EACH_2XWIDER_MODE (rhs_mode_iter, rhs_mode)\n \t{\n+\t  rhs_mode = rhs_mode_iter.require ();\n \t  if (GET_MODE_SIZE (rhs_mode) > fltsz)\n \t    break;\n \n@@ -4275,10 +4278,13 @@ vectorizable_conversion (gimple *stmt, gimple_stmt_iterator *gsi,\n \t  if (supportable_widening_operation (NOP_EXPR, stmt, cvt_type,\n \t\t\t\t\t      vectype_in, &code1, &code2,\n \t\t\t\t\t      &multi_step_cvt, &interm_types))\n-\t    break;\n+\t    {\n+\t      found_mode = true;\n+\t      break;\n+\t    }\n \t}\n \n-      if (rhs_mode == VOIDmode || GET_MODE_SIZE (rhs_mode) > fltsz)\n+      if (!found_mode)\n \tgoto unsupported;\n \n       if (GET_MODE_SIZE (rhs_mode) == fltsz)"}]}