{"sha": "fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZmMzODE5YzliNDkyNGFlMGNjMGUxOTgyNmJhMjdhZmQ0YTQ2ZjE2OQ==", "commit": {"author": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:34:16Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2016-05-02T10:34:16Z"}, "message": "[multiple changes]\n\n2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n\n\t* exp_ch6.adb (Expand_Call): When inlining a call to a function\n\tdeclared in a package instance, locate the instance node of the\n\tpackage after the actual package declaration. skipping over\n\tpragmas that may have been introduced when the generic unit\n\tcarries aspects that are transformed into pragmas.\n\n2016-05-02  Bob Duff  <duff@adacore.com>\n\n\t* s-memory.adb (Alloc, Realloc): Move checks\n\tfor Size = 0 or size_t'Last into the Result = System.Null_Address\n\tpath for efficiency. Improve comments (based on actual C language\n\trequirements for malloc).\n\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Optimize the\n\tcase where we are using the default Global_Pool_Object, and we\n\tdon't need the heavy finalization machinery.\n\nFrom-SVN: r235745", "tree": {"sha": "fd24ec6706d1850fce6ff19dacedc77549e9d96f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/fd24ec6706d1850fce6ff19dacedc77549e9d96f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "html_url": "https://github.com/Rust-GCC/gccrs/commit/fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/comments", "author": null, "committer": null, "parents": [{"sha": "494a7e453377c5a99277c217005685203b07615b", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/494a7e453377c5a99277c217005685203b07615b", "html_url": "https://github.com/Rust-GCC/gccrs/commit/494a7e453377c5a99277c217005685203b07615b"}], "stats": {"total": 115, "additions": 79, "deletions": 36}, "files": [{"sha": "8764dbb1e85f78b1b1c26efaed8faf67a0b207d9", "filename": "gcc/ada/ChangeLog", "status": "modified", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2FChangeLog?ref=fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "patch": "@@ -1,3 +1,21 @@\n+2016-05-02  Ed Schonberg  <schonberg@adacore.com>\n+\n+\t* exp_ch6.adb (Expand_Call): When inlining a call to a function\n+\tdeclared in a package instance, locate the instance node of the\n+\tpackage after the actual package declaration. skipping over\n+\tpragmas that may have been introduced when the generic unit\n+\tcarries aspects that are transformed into pragmas.\n+\n+2016-05-02  Bob Duff  <duff@adacore.com>\n+\n+\t* s-memory.adb (Alloc, Realloc): Move checks\n+\tfor Size = 0 or size_t'Last into the Result = System.Null_Address\n+\tpath for efficiency. Improve comments (based on actual C language\n+\trequirements for malloc).\n+\t* exp_util.adb (Build_Allocate_Deallocate_Proc): Optimize the\n+\tcase where we are using the default Global_Pool_Object, and we\n+\tdon't need the heavy finalization machinery.\n+\n 2016-05-02  Gary Dismukes  <dismukes@adacore.com>\n \n \t* exp_util.ads, sem_ch12.adb: Minor reformatting."}, {"sha": "aff75ac00bb87e7f213ae5036b627f12f47c9aa0", "filename": "gcc/ada/exp_ch6.adb", "status": "modified", "additions": 16, "deletions": 3, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fexp_ch6.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fexp_ch6.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_ch6.adb?ref=fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "patch": "@@ -3970,8 +3970,9 @@ package body Exp_Ch6 is\n               and then Optimization_Level > 0\n             then\n                declare\n-                  Inst : Entity_Id;\n-                  Decl : Node_Id;\n+                  Decl      : Node_Id;\n+                  Inst      : Entity_Id;\n+                  Inst_Node : Node_Id;\n \n                begin\n                   Inst := Scope (Subp);\n@@ -4001,7 +4002,19 @@ package body Exp_Ch6 is\n                         null;\n \n                      else\n-                        Add_Pending_Instantiation (Next (Decl), Decl);\n+                        --  The instantiation node follows the package\n+                        --  declaration for the instance. If the generic\n+                        --  unit had aspect specifications, they have\n+                        --  been transformed into pragmas in the instance,\n+                        --  and the instance node appears after them.\n+\n+                        Inst_Node := Next (Decl);\n+\n+                        while Nkind (Inst_Node) /= N_Package_Instantiation loop\n+                           Inst_Node := Next (Inst_Node);\n+                        end loop;\n+\n+                        Add_Pending_Instantiation (Inst_Node, Decl);\n                      end if;\n                   end if;\n                end;"}, {"sha": "4ea4cb2bf3b650bfc7525fc7071dc0a14f24aa81", "filename": "gcc/ada/exp_util.adb", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fexp_util.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fexp_util.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fexp_util.adb?ref=fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "patch": "@@ -584,6 +584,14 @@ package body Exp_Util is\n       elsif Is_RTE (Pool_Id, RE_SS_Pool) then\n          return;\n \n+      --  Optimize the case where we are using the default Global_Pool_Object,\n+      --  and we don't need the heavy finalization machinery.\n+\n+      elsif Pool_Id = RTE (RE_Global_Pool_Object)\n+        and then not Needs_Finalization (Desig_Typ)\n+      then\n+         return;\n+\n       --  Do not replicate the machinery if the allocator / free has already\n       --  been expanded and has a custom Allocate / Deallocate.\n "}, {"sha": "009efa2c13a7fa3b0c31368df97f7842dd3b9fa9", "filename": "gcc/ada/s-memory.adb", "status": "modified", "additions": 37, "deletions": 33, "changes": 70, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fs-memory.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/fc3819c9b4924ae0cc0e19826ba27afd4a46f169/gcc%2Fada%2Fs-memory.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fs-memory.adb?ref=fc3819c9b4924ae0cc0e19826ba27afd4a46f169", "patch": "@@ -6,7 +6,7 @@\n --                                                                          --\n --                                 B o d y                                  --\n --                                                                          --\n---          Copyright (C) 2001-2013, Free Software Foundation, Inc.         --\n+--          Copyright (C) 2001-2016, Free Software Foundation, Inc.         --\n --                                                                          --\n -- GNAT is free software;  you can  redistribute it  and/or modify it under --\n -- terms of the  GNU General Public License as published  by the Free Soft- --\n@@ -43,14 +43,12 @@\n \n pragma Compiler_Unit_Warning;\n \n-with Ada.Exceptions;\n-with System.Soft_Links;\n-with System.Parameters;\n with System.CRTL;\n+with System.Parameters;\n+with System.Soft_Links;\n \n package body System.Memory is\n \n-   use Ada.Exceptions;\n    use System.Soft_Links;\n \n    function c_malloc (Size : System.CRTL.size_t) return System.Address\n@@ -68,33 +66,41 @@ package body System.Memory is\n    -----------\n \n    function Alloc (Size : size_t) return System.Address is\n-      Result      : System.Address;\n-      Actual_Size : size_t := Size;\n-\n+      Result : System.Address;\n    begin\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n-      --  Change size from zero to non-zero. We still want a proper pointer\n-      --  for the zero case because pointers to zero length objects have to\n-      --  be distinct, but we can't just go ahead and allocate zero bytes,\n-      --  since some malloc's return zero for a zero argument.\n-\n-      if Size = 0 then\n-         Actual_Size := 1;\n-      end if;\n-\n       if Parameters.No_Abort then\n-         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n+         Result := c_malloc (System.CRTL.size_t (Size));\n       else\n          Abort_Defer.all;\n-         Result := c_malloc (System.CRTL.size_t (Actual_Size));\n+         Result := c_malloc (System.CRTL.size_t (Size));\n          Abort_Undefer.all;\n       end if;\n \n       if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+         --  If Size = 0, we can't allocate 0 bytes, because then two different\n+         --  allocators, one of which has Size = 0, could return pointers that\n+         --  compare equal, which is wrong. (Nonnull pointers compare equal if\n+         --  and only if they designate the same object, and two different\n+         --  allocators allocate two different objects).\n+\n+         --  malloc(0) is defined to allocate a non-zero-sized object (in which\n+         --  case we won't get here, and all is well) or NULL, in which case we\n+         --  get here. We also get here in case of error. So check for the\n+         --  zero-size case, and allocate 1 byte. Otherwise, raise\n+         --  Storage_Error.\n+\n+         --  We check for zero size here, rather than at the start, for\n+         --  efficiency.\n+\n+         if Size = 0 then\n+            return Alloc (1);\n+         end if;\n+\n+         if Size = size_t'Last then\n+            raise Storage_Error with \"object too large\";\n+         end if;\n+\n+         raise Storage_Error with \"heap exhausted\";\n       end if;\n \n       return Result;\n@@ -125,23 +131,21 @@ package body System.Memory is\n       return System.Address\n    is\n       Result      : System.Address;\n-      Actual_Size : constant size_t := Size;\n-\n    begin\n-      if Size = size_t'Last then\n-         Raise_Exception (Storage_Error'Identity, \"object too large\");\n-      end if;\n-\n       if Parameters.No_Abort then\n-         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n+         Result := c_realloc (Ptr, System.CRTL.size_t (Size));\n       else\n          Abort_Defer.all;\n-         Result := c_realloc (Ptr, System.CRTL.size_t (Actual_Size));\n+         Result := c_realloc (Ptr, System.CRTL.size_t (Size));\n          Abort_Undefer.all;\n       end if;\n \n       if Result = System.Null_Address then\n-         Raise_Exception (Storage_Error'Identity, \"heap exhausted\");\n+         if Size = size_t'Last then\n+            raise Storage_Error with \"object too large\";\n+         end if;\n+\n+         raise Storage_Error with \"heap exhausted\";\n       end if;\n \n       return Result;"}]}