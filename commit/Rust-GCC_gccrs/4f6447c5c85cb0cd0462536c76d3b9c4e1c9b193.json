{"sha": "4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NGY2NDQ3YzVjODVjYjBjZDA0NjI1MzZjNzZkM2I5YzRlMWM5YjE5Mw==", "commit": {"author": {"name": "Vincent Celier", "email": "celier@adacore.com", "date": "2007-08-16T12:19:39Z"}, "committer": {"name": "Arnaud Charlet", "email": "charlet@gcc.gnu.org", "date": "2007-08-16T12:19:39Z"}, "message": "prj.ads (Project_Data): Add comments.\n\n2007-08-16  Vincent Celier  <celier@adacore.com>\n\n\t* prj.ads (Project_Data): Add comments.\n\n\t* prj-attr.adb: New attribute Removed_Source_Dirs\n\n\t* prj-nmsc.adb (Get_Directories): Take into account new attribute\n\tRemoved_Source_Dirs\n\n\t* snames.ads, snames.adb: New standard name Removed_Source_Dirs\n\nFrom-SVN: r127544", "tree": {"sha": "b837bc4db55687a58ea88cb60dd8d5494b18532a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/b837bc4db55687a58ea88cb60dd8d5494b18532a"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "html_url": "https://github.com/Rust-GCC/gccrs/commit/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/comments", "author": {"login": "vcelier", "id": 8888056, "node_id": "MDQ6VXNlcjg4ODgwNTY=", "avatar_url": "https://avatars.githubusercontent.com/u/8888056?v=4", "gravatar_id": "", "url": "https://api.github.com/users/vcelier", "html_url": "https://github.com/vcelier", "followers_url": "https://api.github.com/users/vcelier/followers", "following_url": "https://api.github.com/users/vcelier/following{/other_user}", "gists_url": "https://api.github.com/users/vcelier/gists{/gist_id}", "starred_url": "https://api.github.com/users/vcelier/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/vcelier/subscriptions", "organizations_url": "https://api.github.com/users/vcelier/orgs", "repos_url": "https://api.github.com/users/vcelier/repos", "events_url": "https://api.github.com/users/vcelier/events{/privacy}", "received_events_url": "https://api.github.com/users/vcelier/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "e03a78d51aefc65feff0b39a1f6e4cf1fc8c8cc7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e03a78d51aefc65feff0b39a1f6e4cf1fc8c8cc7", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e03a78d51aefc65feff0b39a1f6e4cf1fc8c8cc7"}], "stats": {"total": 486, "additions": 309, "deletions": 177}, "files": [{"sha": "57e9724d6fe1f77f3a92869686a4604825a83a5e", "filename": "gcc/ada/prj-attr.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj-attr.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj-attr.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-attr.adb?ref=4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "patch": "@@ -75,6 +75,7 @@ package body Prj.Attr is\n    \"SVobject_dir#\" &\n    \"SVexec_dir#\" &\n    \"LVsource_dirs#\" &\n+   \"LVremoved_source_dirs#\" &\n \n    --  Source files\n "}, {"sha": "caa210688cb3075855a64c41c099ca8954f095f4", "filename": "gcc/ada/prj-nmsc.adb", "status": "modified", "additions": 275, "deletions": 150, "changes": 425, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj-nmsc.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj-nmsc.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj-nmsc.adb?ref=4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "patch": "@@ -4174,6 +4174,9 @@ package body Prj.Nmsc is\n                elsif Value = \"restricted\" then\n                   Data.Symbol_Data.Symbol_Policy := Restricted;\n \n+               elsif Value = \"direct\" then\n+                  Data.Symbol_Data.Symbol_Policy := Direct;\n+\n                else\n                   Error_Msg\n                     (Project, In_Tree,\n@@ -4196,7 +4199,7 @@ package body Prj.Nmsc is\n             end if;\n \n          else\n-            --  Library_Symbol_File is defined. Check that the file exists\n+            --  Library_Symbol_File is defined.\n \n             Data.Symbol_Data.Symbol_File :=\n               Path_Name_Type (Lib_Symbol_File.Value);\n@@ -4262,43 +4265,28 @@ package body Prj.Nmsc is\n                   Lib_Symbol_File.Location);\n \n             else\n-               OK := not Is_Absolute_Path (Name_Buffer (1 .. Name_Len));\n-\n-               if OK then\n-                  for J in 1 .. Name_Len loop\n-                     if Name_Buffer (J) = '/'\n-                       or else Name_Buffer (J) = Directory_Separator\n-                     then\n-                        OK := False;\n-                        exit;\n-                     end if;\n-                  end loop;\n-               end if;\n-\n-               if not OK then\n-                  Error_Msg_File_1 :=\n-                    File_Name_Type (Lib_Ref_Symbol_File.Value);\n-                  Error_Msg\n-                    (Project, In_Tree,\n-                     \"reference symbol file { name is illegal. \" &\n-                     \"Name canot include directory info.\",\n-                     Lib_Ref_Symbol_File.Location);\n+               if not Is_Absolute_Path (Name_Buffer (1 .. Name_Len)) then\n+                  Name_Len := 0;\n+                  Add_Str_To_Name_Buffer (Get_Name_String (Data.Directory));\n+                  Add_Char_To_Name_Buffer (Directory_Separator);\n+                  Add_Str_To_Name_Buffer\n+                    (Get_Name_String (Lib_Ref_Symbol_File.Value));\n+                  Data.Symbol_Data.Reference := Name_Find;\n                end if;\n \n                if not Is_Regular_File\n-                 (Get_Name_String (Data.Object_Directory) &\n-                  Directory_Separator &\n-                  Get_Name_String (Lib_Ref_Symbol_File.Value))\n+                 (Get_Name_String (Data.Symbol_Data.Reference))\n                then\n                   Error_Msg_File_1 :=\n                     File_Name_Type (Lib_Ref_Symbol_File.Value);\n \n-                  --  For controlled symbol policy, it is an error if the\n-                  --  reference symbol file does not exist. For other symbol\n-                  --  policies, this is just a warning\n+                  --  For controlled and direct symbol policies, it is an error\n+                  --  if the reference symbol file does not exist. For other\n+                  --  symbol policies, this is just a warning\n \n                   Error_Msg_Warn :=\n-                    Data.Symbol_Data.Symbol_Policy /= Controlled;\n+                    Data.Symbol_Data.Symbol_Policy /= Controlled\n+                    and then Data.Symbol_Data.Symbol_Policy /= Direct;\n \n                   Error_Msg\n                     (Project, In_Tree,\n@@ -4316,6 +4304,36 @@ package body Prj.Nmsc is\n                      end if;\n                   end if;\n                end if;\n+\n+               --  If both the reference symbol file and the symbol file are\n+               --  defined, then check that they are not the same file.\n+\n+               if Data.Symbol_Data.Symbol_File /= No_Path then\n+                  Get_Name_String (Data.Symbol_Data.Symbol_File);\n+\n+                  if Name_Len > 0 then\n+                     declare\n+                        Symb_Path : constant String :=\n+                                      Normalize_Pathname\n+                                        (Get_Name_String\n+                                           (Data.Object_Directory) &\n+                                         Directory_Separator &\n+                                         Name_Buffer (1 .. Name_Len));\n+                        Ref_Path  : constant String :=\n+                                      Normalize_Pathname\n+                                        (Get_Name_String\n+                                           (Data.Symbol_Data.Reference));\n+                     begin\n+                        if Symb_Path = Ref_Path then\n+                           Error_Msg\n+                             (Project, In_Tree,\n+                              \"library reference symbol file and library\" &\n+                              \" symbol file cannot be the same file\",\n+                              Lib_Ref_Symbol_File.Location);\n+                        end if;\n+                     end;\n+                  end if;\n+               end if;\n             end if;\n          end if;\n       end if;\n@@ -4794,6 +4812,12 @@ package body Prj.Nmsc is\n                       Util.Value_Of\n                         (Name_Source_Dirs, Data.Decl.Attributes, In_Tree);\n \n+      Removed_Source_Dirs : constant Variable_Value :=\n+                              Util.Value_Of\n+                                (Name_Removed_Source_Dirs,\n+                                 Data.Decl.Attributes,\n+                                 In_Tree);\n+\n       Source_Files : constant Variable_Value :=\n                       Util.Value_Of\n                         (Name_Source_Files, Data.Decl.Attributes, In_Tree);\n@@ -4802,17 +4826,20 @@ package body Prj.Nmsc is\n \n       procedure Find_Source_Dirs\n         (From     : File_Name_Type;\n-         Location : Source_Ptr);\n-      --  Find one or several source directories, and add them\n-      --  to the list of source directories of the project.\n+         Location : Source_Ptr;\n+         Removed  : Boolean := False);\n+      --  Find one or several source directories, and add (or remove, if\n+      --  Removed is True) them to the list of source directories of the\n+      --  project.\n \n       ----------------------\n       -- Find_Source_Dirs --\n       ----------------------\n \n       procedure Find_Source_Dirs\n         (From     : File_Name_Type;\n-         Location : Source_Ptr)\n+         Location : Source_Ptr;\n+         Removed  : Boolean := False)\n       is\n          Directory : constant String := Get_Name_String (From);\n          Element   : String_Element;\n@@ -4830,6 +4857,7 @@ package body Prj.Nmsc is\n             Name     : String (1 .. 250);\n             Last     : Natural;\n             List     : String_List_Id := Data.Source_Dirs;\n+            Prev     : String_List_Id := Nil_String;\n             Element  : String_Element;\n             Found    : Boolean := False;\n \n@@ -4857,11 +4885,12 @@ package body Prj.Nmsc is\n             --  then there is nothing to do, just return. If it is not, put\n             --  it there and continue recursive processing.\n \n-            if Recursive_Dirs.Get (Canonical_Path) then\n-               return;\n-\n-            else\n-               Recursive_Dirs.Set (Canonical_Path, True);\n+            if not Removed then\n+               if Recursive_Dirs.Get (Canonical_Path) then\n+                  return;\n+               else\n+                  Recursive_Dirs.Set (Canonical_Path, True);\n+               end if;\n             end if;\n \n             --  Check if directory is already in list\n@@ -4874,12 +4903,13 @@ package body Prj.Nmsc is\n                   exit when Found;\n                end if;\n \n+               Prev := List;\n                List := Element.Next;\n             end loop;\n \n             --  If directory is not already in list, put it there\n \n-            if not Found then\n+            if (not Removed) and (not Found) then\n                if Current_Verbosity = High then\n                   Write_Str  (\"   \");\n                   Write_Line (The_Path (The_Path'First .. The_Path_Last));\n@@ -4918,6 +4948,15 @@ package body Prj.Nmsc is\n                  (In_Tree.String_Elements);\n                In_Tree.String_Elements.Table (Last_Source_Dir) :=\n                  Element;\n+\n+            elsif Removed and Found then\n+               if Prev = Nil_String then\n+                  Data.Source_Dirs :=\n+                    In_Tree.String_Elements.Table (List).Next;\n+               else\n+                  In_Tree.String_Elements.Table (Prev).Next :=\n+                    In_Tree.String_Elements.Table (List).Next;\n+               end if;\n             end if;\n \n             --  Now look for subdirectories. We do that even when this\n@@ -4973,29 +5012,30 @@ package body Prj.Nmsc is\n       --  Start of processing for Find_Source_Dirs\n \n       begin\n-         if Current_Verbosity = High then\n+         if Current_Verbosity = High and then not Removed then\n             Write_Str (\"Find_Source_Dirs (\"\"\");\n             Write_Str (Directory);\n             Write_Line (\"\"\")\");\n          end if;\n \n-         --  First, check if we are looking for a directory tree,\n-         --  indicated by \"/**\" at the end.\n+         --  First, check if we are looking for a directory tree, indicated\n+         --  by \"/**\" at the end.\n \n          if Directory'Length >= 3\n            and then Directory (Directory'Last - 1 .. Directory'Last) = \"**\"\n            and then (Directory (Directory'Last - 2) = '/'\n                        or else\n                      Directory (Directory'Last - 2) = Directory_Separator)\n          then\n-            Data.Known_Order_Of_Source_Dirs := False;\n+            if not Removed then\n+               Data.Known_Order_Of_Source_Dirs := False;\n+            end if;\n \n             Name_Len := Directory'Length - 3;\n \n             if Name_Len = 0 then\n \n-               --  This is the case of \"/**\": all directories\n-               --  in the file system.\n+               --  Case of \"/**\": all directories in file system\n \n                Name_Len := 1;\n                Name_Buffer (1) := Directory (Directory'First);\n@@ -5038,8 +5078,8 @@ package body Prj.Nmsc is\n                   end if;\n \n                else\n-                  --  We have an existing directory, we register it and all\n-                  --  of its subdirectories.\n+                  --  We have an existing directory, we register it and all of\n+                  --  its subdirectories.\n \n                   if Current_Verbosity = High then\n                      Write_Line (\"Looking for source directories:\");\n@@ -5061,6 +5101,8 @@ package body Prj.Nmsc is\n             declare\n                Path_Name         : Path_Name_Type;\n                Display_Path_Name : Path_Name_Type;\n+               List              : String_List_Id;\n+               Prev              : String_List_Id;\n \n             begin\n                Locate_Directory\n@@ -5087,37 +5129,100 @@ package body Prj.Nmsc is\n                   end if;\n \n                else\n-                  --  As it is an existing directory, we add it to\n-                  --  the list of directories.\n+                  declare\n+                     Path              : constant String :=\n+                                           Get_Name_String (Path_Name) &\n+                                           Directory_Separator;\n+                     Last_Path         : constant Natural :=\n+                                           Compute_Directory_Last (Path);\n+                     Path_Id           : Name_Id;\n+                     Display_Path      : constant String :=\n+                                           Get_Name_String\n+                                             (Display_Path_Name) &\n+                                           Directory_Separator;\n+                     Last_Display_Path : constant Natural :=\n+                                           Compute_Directory_Last\n+                                             (Display_Path);\n+                     Display_Path_Id   : Name_Id;\n \n-                  String_Element_Table.Increment_Last\n-                    (In_Tree.String_Elements);\n-                  Element.Value := Name_Id (Path_Name);\n-                  Element.Display_Value := Name_Id (Display_Path_Name);\n+                  begin\n+                     Name_Len := 0;\n+                     Add_Str_To_Name_Buffer (Path (Path'First .. Last_Path));\n+                     Path_Id := Name_Find;\n+                     Name_Len := 0;\n+                     Add_Str_To_Name_Buffer\n+                       (Display_Path\n+                          (Display_Path'First .. Last_Display_Path));\n+                     Display_Path_Id := Name_Find;\n \n-                  if Last_Source_Dir = Nil_String then\n+                     if not Removed then\n \n-                     --  This is the first source directory\n+                        --  As it is an existing directory, we add it to the\n+                        --  list of directories.\n \n-                     Data.Source_Dirs := String_Element_Table.Last\n-                                        (In_Tree.String_Elements);\n+                        String_Element_Table.Increment_Last\n+                          (In_Tree.String_Elements);\n+                        Element :=\n+                          (Value         => Path_Id,\n+                           Index         => 0,\n+                           Display_Value => Display_Path_Id,\n+                           Location      => No_Location,\n+                           Flag          => False,\n+                           Next          => Nil_String);\n \n-                  else\n-                     --  We already have source directories,\n-                     --  link the previous last to the new one.\n+                        if Last_Source_Dir = Nil_String then\n \n-                     In_Tree.String_Elements.Table\n-                       (Last_Source_Dir).Next :=\n-                         String_Element_Table.Last\n-                           (In_Tree.String_Elements);\n-                  end if;\n+                           --  This is the first source directory\n \n-                  --  And register this source directory as the new last\n+                           Data.Source_Dirs := String_Element_Table.Last\n+                             (In_Tree.String_Elements);\n \n-                  Last_Source_Dir := String_Element_Table.Last\n-                    (In_Tree.String_Elements);\n-                  In_Tree.String_Elements.Table\n-                    (Last_Source_Dir) := Element;\n+                        else\n+                           --  We already have source directories, link the\n+                           --  previous last to the new one.\n+\n+                           In_Tree.String_Elements.Table\n+                             (Last_Source_Dir).Next :=\n+                             String_Element_Table.Last\n+                               (In_Tree.String_Elements);\n+                        end if;\n+\n+                        --  And register this source directory as the new last\n+\n+                        Last_Source_Dir := String_Element_Table.Last\n+                          (In_Tree.String_Elements);\n+                        In_Tree.String_Elements.Table\n+                          (Last_Source_Dir) := Element;\n+\n+                     else\n+                        --  Remove source dir, if present\n+\n+                        List := Data.Source_Dirs;\n+                        Prev := Nil_String;\n+\n+                        --  Look for source dir in current list\n+\n+                        while List /= Nil_String loop\n+                           Element := In_Tree.String_Elements.Table (List);\n+                           exit when Element.Value = Path_Id;\n+                           Prev := List;\n+                           List := Element.Next;\n+                        end loop;\n+\n+                        if List /= Nil_String then\n+                           --  Source dir was found, remove it from the list\n+\n+                           if Prev = Nil_String then\n+                              Data.Source_Dirs :=\n+                                In_Tree.String_Elements.Table (List).Next;\n+\n+                           else\n+                              In_Tree.String_Elements.Table (Prev).Next :=\n+                                In_Tree.String_Elements.Table (List).Next;\n+                           end if;\n+                        end if;\n+                     end if;\n+                  end;\n                end if;\n             end;\n          end if;\n@@ -5219,8 +5324,7 @@ package body Prj.Nmsc is\n                Exec_Dir.Location);\n \n          else\n-            --  We check that the specified object directory\n-            --  does exist.\n+            --  We check that the specified object directory does exist\n \n             Locate_Directory\n               (Project,\n@@ -5273,8 +5377,8 @@ package body Prj.Nmsc is\n \n       elsif Source_Dirs.Default then\n \n-         --  No Source_Dirs specified: the single source directory\n-         --  is the one containing the project file\n+         --  No Source_Dirs specified: the single source directory is the one\n+         --  containing the project file\n \n          String_Element_Table.Increment_Last\n            (In_Tree.String_Elements);\n@@ -5297,10 +5401,10 @@ package body Prj.Nmsc is\n \n       elsif Source_Dirs.Values = Nil_String then\n \n-         --  If Source_Dirs is an empty string list, this means\n-         --  that this project contains no source. For projects that\n-         --  don't extend other projects, this also means that there is no\n-         --  need for an object directory, if not specified.\n+         --  If Source_Dirs is an empty string list, this means that this\n+         --  project contains no source. For projects that don't extend other\n+         --  projects, this also means that there is no need for an object\n+         --  directory, if not specified.\n \n          if Data.Extends = No_Project\n            and then  Data.Object_Directory = Data.Directory\n@@ -5316,8 +5420,7 @@ package body Prj.Nmsc is\n             Element    : String_Element;\n \n          begin\n-            --  We will find the source directories for each\n-            --  element of the list\n+            --  Process the source directories for each element of the list\n \n             while Source_Dir /= Nil_String loop\n                Element :=\n@@ -5329,6 +5432,28 @@ package body Prj.Nmsc is\n          end;\n       end if;\n \n+      if (not Removed_Source_Dirs.Default) and then\n+        Removed_Source_Dirs.Values /= Nil_String then\n+         declare\n+            Source_Dir : String_List_Id;\n+            Element    : String_Element;\n+\n+         begin\n+            --  Process the source directories for each element of the list\n+\n+            Source_Dir := Removed_Source_Dirs.Values;\n+            while Source_Dir /= Nil_String loop\n+               Element :=\n+                 In_Tree.String_Elements.Table (Source_Dir);\n+               Find_Source_Dirs\n+                 (File_Name_Type (Element.Value),\n+                  Element.Location,\n+                  Removed => True);\n+               Source_Dir := Element.Next;\n+            end loop;\n+         end;\n+      end if;\n+\n       if Current_Verbosity = High then\n          Write_Line (\"Putting source directories in canonical cases\");\n       end if;\n@@ -5368,8 +5493,8 @@ package body Prj.Nmsc is\n    begin\n       Data.Mains := Mains.Values;\n \n-      --  If no Mains were specified, and if we are an extending\n-      --  project, inherit the Mains from the project we are extending.\n+      --  If no Mains were specified, and if we are an extending project,\n+      --  inherit the Mains from the project we are extending.\n \n       if Mains.Default then\n          if Data.Extends /= No_Project then\n@@ -5602,8 +5727,8 @@ package body Prj.Nmsc is\n \n          if Name_Buffer (1 .. Name_Len) /= \".\" then\n \n-            --  If Dot_Replacement is not a single dot, then there should\n-            --  not be any dot in the name.\n+            --  If Dot_Replacement is not a single dot, then there should not\n+            --  be any dot in the name.\n \n             for Index in First .. Last loop\n                if File (Index) = '.' then\n@@ -5757,8 +5882,8 @@ package body Prj.Nmsc is\n          return True;\n       end if;\n \n-      --  If dot replacement is a single dot, and first character of\n-      --  suffix is also a dot\n+      --  If dot replacement is a single dot, and first character of suffix is\n+      --  also a dot\n \n       if Dot_Replacement_Is_A_Single_Dot\n         and then Suffix (Suffix'First) = '.'\n@@ -5862,6 +5987,7 @@ package body Prj.Nmsc is\n                      Location);\n             end;\n          end if;\n+\n          if Is_Directory (Full_Path_Name) then\n             declare\n                Normed : constant String :=\n@@ -5903,8 +6029,6 @@ package body Prj.Nmsc is\n       --  Find the path names of the source files in the Source_Names table\n       --  in the source directories and record those that are Ada sources.\n \n---      function Source_Of (File_Name : Name_Id) return Source_Id;\n-\n       procedure Get_Sources_From_File\n         (Path     : String;\n          Location : Source_Ptr);\n@@ -5931,11 +6055,8 @@ package body Prj.Nmsc is\n          Name_Str        : String (1 .. 1_024);\n          Last            : Natural := 0;\n          NL              : Name_Location;\n-\n          Current_Source  : String_List_Id := Nil_String;\n-\n          First_Error     : Boolean := True;\n-\n          Source_Recorded : Boolean := False;\n \n       begin\n@@ -6020,7 +6141,6 @@ package body Prj.Nmsc is\n          --  in a source list file is not found.\n \n          NL := Source_Names.Get_First;\n-\n          while NL /= No_Name_Location loop\n             if not NL.Found then\n                Err_Vars.Error_Msg_File_1 := NL.Name;\n@@ -6080,23 +6200,20 @@ package body Prj.Nmsc is\n       ------------------------\n \n       procedure Search_Directories (For_All_Sources : Boolean) is\n-         Source_Dir      : String_List_Id := Data.Source_Dirs;\n-         Element         : String_Element;\n-         Dir             : Dir_Type;\n-         Name            : String (1 .. 1_000);\n-         Last            : Natural;\n+         Source_Dir : String_List_Id;\n+         Element    : String_Element;\n+         Dir        : Dir_Type;\n+         Name       : String (1 .. 1_000);\n+         Last       : Natural;\n \n          File_Name         : File_Name_Type;\n          Display_File_Name : File_Name_Type;\n-\n          Source            : Source_Id;\n          Source_To_Replace : Source_Id := No_Source;\n          Src_Data          : Source_Data;\n          Add_Src           : Boolean;\n-\n-         Name_Loc        : Name_Location;\n-\n-         Check_Name      : Boolean;\n+         Name_Loc          : Name_Location;\n+         Check_Name        : Boolean;\n \n          Language              : Language_Index;\n          Language_Name         : Name_Id;\n@@ -6121,22 +6238,20 @@ package body Prj.Nmsc is\n          procedure Check_Naming_Schemes is\n             Filename : constant String := Get_Name_String (File_Name);\n             Last     : Positive := Filename'Last;\n-\n             Config   : Language_Config;\n-\n-            Lang     : Name_List_Index  := Data.Languages;\n+            Lang     : Name_List_Index;\n \n             Header_File    : Boolean := False;\n             First_Language : Language_Index;\n \n          begin\n             Unit := No_Name;\n \n+            Lang := Data.Languages;\n             while Lang /= No_Name_List loop\n-\n-               Language := Data.First_Language_Processing;\n                Language_Name := In_Tree.Name_Lists.Table (Lang).Name;\n \n+               Language := Data.First_Language_Processing;\n                while Language /= No_Language_Index loop\n                   if In_Tree.Languages_Data.Table (Language).Name =\n                     Language_Name\n@@ -6146,9 +6261,10 @@ package body Prj.Nmsc is\n                      Config := In_Tree.Languages_Data.Table (Language).Config;\n \n                      if Config.Kind = File_Based then\n-                        --  For file based languages, there is no Unit.\n-                        --  Just check if the file name has the implementation\n-                        --  or, if it is specified, the template suffix of the\n+\n+                        --  For file based languages, there is no Unit. Just\n+                        --  check if the file name has the implementation or,\n+                        --  if it is specified, the template suffix of the\n                         --  language.\n \n                         Unit := No_Name;\n@@ -6225,11 +6341,13 @@ package body Prj.Nmsc is\n                         end if;\n \n                      elsif not Header_File then\n+\n                         --  Unit based language\n \n                         OK := Config.Naming_Data.Dot_Replacement /= No_File;\n \n                         if OK then\n+\n                            --  Check casing\n \n                            case Config.Naming_Data.Casing is\n@@ -6270,7 +6388,6 @@ package body Prj.Nmsc is\n                                  Suffix : constant String :=\n                                    Get_Name_String\n                                      (Config.Naming_Data.Separate_Suffix);\n-\n                               begin\n                                  if Filename'Length > Suffix'Length\n                                    and then\n@@ -6292,7 +6409,6 @@ package body Prj.Nmsc is\n                                  Suffix : constant String :=\n                                    Get_Name_String\n                                      (Config.Naming_Data.Body_Suffix);\n-\n                               begin\n                                  if Filename'Length > Suffix'Length\n                                    and then\n@@ -6314,7 +6430,6 @@ package body Prj.Nmsc is\n                                  Suffix : constant String :=\n                                    Get_Name_String\n                                      (Config.Naming_Data.Spec_Suffix);\n-\n                               begin\n                                  if Filename'Length > Suffix'Length\n                                    and then\n@@ -6331,15 +6446,19 @@ package body Prj.Nmsc is\n                         end if;\n \n                         if OK then\n+\n                            --  Replace dot replacements with dots\n \n                            Name_Len := 0;\n \n                            declare\n-                              J   : Positive := Filename'First;\n+                              J : Positive := Filename'First;\n+\n                               Dot_Replacement : constant String :=\n-                                Get_Name_String\n-                                  (Config.Naming_Data.Dot_Replacement);\n+                                                  Get_Name_String\n+                                                    (Config.Naming_Data.\n+                                                       Dot_Replacement);\n+\n                               Max : constant Positive :=\n                                       Last - Dot_Replacement'Length + 1;\n \n@@ -6354,6 +6473,7 @@ package body Prj.Nmsc is\n                                  then\n                                     Name_Buffer (Name_Len) := '.';\n                                     J := J + Dot_Replacement'Length;\n+\n                                  else\n                                     if Filename (J) = '.' then\n                                        OK := False;\n@@ -6371,8 +6491,10 @@ package body Prj.Nmsc is\n                         end if;\n \n                         if OK then\n+\n                            --  The name buffer should contain the name of the\n                            --  the unit, if it is one.\n+\n                            --  Check that this is a valid unit name\n \n                            Check_Ada_Name (Name_Buffer (1 .. Name_Len), Unit);\n@@ -6418,13 +6540,16 @@ package body Prj.Nmsc is\n             end if;\n          end Check_Naming_Schemes;\n \n+      --  Start of processing for Search_Directories\n+\n       begin\n          if Current_Verbosity = High then\n             Write_Line (\"Looking for sources:\");\n          end if;\n \n-         --  For each subdirectory\n+         --  Loop through subdirectories\n \n+         Source_Dir := Data.Source_Dirs;\n          while Source_Dir /= Nil_String loop\n             begin\n                Element := In_Tree.String_Elements.Table (Source_Dir);\n@@ -6458,7 +6583,6 @@ package body Prj.Nmsc is\n                         if Is_Regular_File\n                           (Source_Directory & Name (1 .. Last))\n                         then\n-\n                            if Current_Verbosity = High then\n                               Write_Str  (\"   Checking \");\n                               Write_Line (Name (1 .. Last));\n@@ -6507,9 +6631,9 @@ package body Prj.Nmsc is\n \n                               else\n                                  if Name_Loc.Found then\n-                                    --  Check if it is allowed to have the\n-                                    --  same file name in several source\n-                                    --  directories.\n+\n+                                    --  Check if it is OK to have the same file\n+                                    --  name in several source directories.\n \n                                     if\n                                       not Data.Known_Order_Of_Source_Dirs\n@@ -6576,6 +6700,7 @@ package body Prj.Nmsc is\n \n                                  if Language = No_Language_Index then\n                                     if Name_Loc.Found then\n+\n                                        --  A file name in a list must be\n                                        --  a source of a language.\n \n@@ -6737,19 +6862,20 @@ package body Prj.Nmsc is\n          if Current_Verbosity = High then\n             Write_Line (\"end Looking for sources.\");\n          end if;\n-\n       end Search_Directories;\n \n+   --  Start of processing for Look_For_Sources\n+\n    begin\n       if Get_Mode = Ada_Only and then\n         Is_A_Language (In_Tree, Data, \"ada\")\n       then\n          declare\n-            Sources          : constant Variable_Value :=\n-                                 Util.Value_Of\n-                                   (Name_Source_Files,\n-                                    Data.Decl.Attributes,\n-                                    In_Tree);\n+            Sources : constant Variable_Value :=\n+                        Util.Value_Of\n+                          (Name_Source_Files,\n+                           Data.Decl.Attributes,\n+                           In_Tree);\n \n             Source_List_File : constant Variable_Value :=\n                                  Util.Value_Of\n@@ -6898,15 +7024,13 @@ package body Prj.Nmsc is\n \n                begin\n                   while Current /= Nil_String loop\n-                     Element :=\n-                       In_Tree.String_Elements.Table (Current);\n+                     Element := In_Tree.String_Elements.Table (Current);\n                      Get_Name_String (Element.Value);\n                      Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n                      Name := Name_Find;\n \n-                     --  If the element has no location, then use the\n-                     --  location of Locally_Removed to report\n-                     --  possible errors.\n+                     --  If the element has no location, then use the location\n+                     --  of Locally_Removed to report possible errors.\n \n                      if Element.Location = No_Location then\n                         Location := Locally_Removed.Location;\n@@ -6990,6 +7114,7 @@ package body Prj.Nmsc is\n       end if;\n \n       if Get_Mode = Ada_Only and then Data.Other_Sources_Present then\n+\n          --  Set Source_Present to False. It will be set back to True\n          --  whenever a source is found.\n \n@@ -7001,8 +7126,8 @@ package body Prj.Nmsc is\n             if Is_Present (Lang, Data, In_Tree) then\n \n                --  Reset the indication that there are sources of this\n-               --  language. It will be set back to True whenever we find a\n-               --  source of the language.\n+               --  language. It will be set back to True whenever we find\n+               --  a source of the language.\n \n                Set (Lang, False, Data, In_Tree);\n \n@@ -7358,6 +7483,7 @@ package body Prj.Nmsc is\n                end;\n \n             elsif not Source_List_File.Default then\n+\n                --  Source_List_File is the name of the file\n                --  that contains the source file names\n \n@@ -7389,13 +7515,11 @@ package body Prj.Nmsc is\n               (For_All_Sources =>\n                  Sources.Default and then Source_List_File.Default);\n \n-            --  If there are sources that are locally removed, mark them as\n-            --  such.\n+            --  If there are locally removed sources, mark them as such\n \n             if not Locally_Removed.Default then\n-\n                declare\n-                  Current  : String_List_Id := Locally_Removed.Values;\n+                  Current  : String_List_Id;\n                   Element  : String_Element;\n                   Location : Source_Ptr;\n                   OK       : Boolean;\n@@ -7404,16 +7528,16 @@ package body Prj.Nmsc is\n                   Src_Data : Source_Data;\n \n                begin\n+                  Current := Locally_Removed.Values;\n                   while Current /= Nil_String loop\n                      Element :=\n                        In_Tree.String_Elements.Table (Current);\n                      Get_Name_String (Element.Value);\n                      Canonical_Case_File_Name (Name_Buffer (1 .. Name_Len));\n                      Name := Name_Find;\n \n-                     --  If the element has no location, then use the\n-                     --  location of Locally_Removed to report\n-                     --  possible errors.\n+                     --  If the element has no location, then use the location\n+                     --  of Locally_Removed to report possible errors.\n \n                      if Element.Location = No_Location then\n                         Location := Locally_Removed.Location;\n@@ -7429,6 +7553,7 @@ package body Prj.Nmsc is\n                         Src_Data := In_Tree.Sources.Table (Source);\n \n                         if Src_Data.File = Name then\n+\n                            --  Check that this is from this project or a\n                            --  project that the current project extends.\n \n@@ -7497,13 +7622,14 @@ package body Prj.Nmsc is\n       In_Tree : Project_Tree_Ref;\n       Kind    : Spec_Or_Body)\n    is\n-      Current : Array_Element_Id := List;\n+      Current : Array_Element_Id;\n       Element : Array_Element;\n       Unit    : Unit_Info;\n \n    begin\n       --  Traverse the list\n \n+      Current := List;\n       while Current /= No_Array_Element loop\n          Element := In_Tree.Array_Elements.Table (Current);\n \n@@ -7641,9 +7767,8 @@ package body Prj.Nmsc is\n                   Write_Line (\"\"\" (ignored).\");\n                end if;\n \n-               --  The file is not included in the source of the project,\n-               --  because it is hidden by the exception.\n-               --  So, there is nothing else to do.\n+               --  The file is not included in the source of the project since\n+               --  it is hidden by the exception. So, nothing else to do.\n \n                return;\n             end if;\n@@ -7692,8 +7817,9 @@ package body Prj.Nmsc is\n             --  Put the unit in unit list\n \n             declare\n-               The_Unit      : Unit_Index :=\n-                 Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n+               The_Unit : Unit_Index :=\n+                            Units_Htable.Get (In_Tree.Units_HT, Unit_Name);\n+\n                The_Unit_Data : Unit_Data;\n \n             begin\n@@ -7870,7 +7996,6 @@ package body Prj.Nmsc is\n       Last           : Natural := 0;\n       NL             : Name_Location;\n       First_Error    : Boolean := True;\n-\n       Suffix         : constant String :=\n                          Body_Suffix_Of (Language, Data, In_Tree);\n \n@@ -8049,7 +8174,8 @@ package body Prj.Nmsc is\n       end if;\n \n       In_Tree.Sources.Table (Id).Replaced_By := Replaced_By;\n-      --  Remove the source from the global list\n+\n+      --  Remove the source from the global source list\n \n       Source := In_Tree.First_Source;\n \n@@ -8132,7 +8258,6 @@ package body Prj.Nmsc is\n          In_Tree.Sources.Table (Source).Next_In_Lang :=\n            Src_Data.Next_In_Lang;\n       end if;\n-\n    end Remove_Source;\n \n    -----------------------"}, {"sha": "a26132eef7a3597c31ee2b300a586c23ca8b5a0b", "filename": "gcc/ada/prj.ads", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fprj.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fprj.ads?ref=4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "patch": "@@ -1029,6 +1029,10 @@ package Prj is\n \n    --  The following record describes a project file representation\n \n+   --  Note that it is not specified if the path names of directories (source,\n+   --  object, library or exec directories) end with or without a directory\n+   --  separator.\n+\n    type Project_Data is record\n       Externally_Built : Boolean := False;\n       --  True if the project is externally built. In such case, the Project"}, {"sha": "1e0a6397ba71d60058ae9fdfe3b9a8aed235fb07", "filename": "gcc/ada/snames.adb", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fsnames.adb", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fsnames.adb", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.adb?ref=4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "patch": "@@ -753,6 +753,7 @@ package body Snames is\n      \"prefix#\" &\n      \"project#\" &\n      \"roots#\" &\n+     \"removed_source_dirs#\" &\n      \"required_switches#\" &\n      \"run_path_option#\" &\n      \"runtime_project#\" &"}, {"sha": "32febd5e27a38a55eb0d29d3c97c9d5afdab178b", "filename": "gcc/ada/snames.ads", "status": "modified", "additions": 28, "deletions": 27, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fsnames.ads", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193/gcc%2Fada%2Fsnames.ads", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fada%2Fsnames.ads?ref=4f6447c5c85cb0cd0462536c76d3b9c4e1c9b193", "patch": "@@ -1069,45 +1069,46 @@ package Snames is\n    Name_Prefix                         : constant Name_Id := N + 692;\n    Name_Project                        : constant Name_Id := N + 693;\n    Name_Roots                          : constant Name_Id := N + 694;\n-   Name_Required_Switches              : constant Name_Id := N + 695;\n-   Name_Run_Path_Option                : constant Name_Id := N + 696;\n-   Name_Runtime_Project                : constant Name_Id := N + 697;\n-   Name_Shared_Library_Minimum_Switches : constant Name_Id := N + 698;\n-   Name_Shared_Library_Prefix          : constant Name_Id := N + 699;\n-   Name_Shared_Library_Suffix          : constant Name_Id := N + 700;\n-   Name_Separate_Suffix                : constant Name_Id := N + 701;\n-   Name_Source_Dirs                    : constant Name_Id := N + 702;\n-   Name_Source_Files                   : constant Name_Id := N + 703;\n-   Name_Source_List_File               : constant Name_Id := N + 704;\n-   Name_Spec                           : constant Name_Id := N + 705;\n-   Name_Spec_Suffix                    : constant Name_Id := N + 706;\n-   Name_Specification                  : constant Name_Id := N + 707;\n-   Name_Specification_Exceptions       : constant Name_Id := N + 708;\n-   Name_Specification_Suffix           : constant Name_Id := N + 709;\n-   Name_Stack                          : constant Name_Id := N + 710;\n-   Name_Switches                       : constant Name_Id := N + 711;\n-   Name_Symbolic_Link_Supported        : constant Name_Id := N + 712;\n-   Name_Toolchain_Description          : constant Name_Id := N + 713;\n-   Name_Toolchain_Version              : constant Name_Id := N + 714;\n+   Name_Removed_Source_Dirs            : constant Name_Id := N + 695;\n+   Name_Required_Switches              : constant Name_Id := N + 696;\n+   Name_Run_Path_Option                : constant Name_Id := N + 697;\n+   Name_Runtime_Project                : constant Name_Id := N + 698;\n+   Name_Shared_Library_Minimum_Switches : constant Name_Id := N + 699;\n+   Name_Shared_Library_Prefix          : constant Name_Id := N + 700;\n+   Name_Shared_Library_Suffix          : constant Name_Id := N + 701;\n+   Name_Separate_Suffix                : constant Name_Id := N + 702;\n+   Name_Source_Dirs                    : constant Name_Id := N + 703;\n+   Name_Source_Files                   : constant Name_Id := N + 704;\n+   Name_Source_List_File               : constant Name_Id := N + 705;\n+   Name_Spec                           : constant Name_Id := N + 706;\n+   Name_Spec_Suffix                    : constant Name_Id := N + 707;\n+   Name_Specification                  : constant Name_Id := N + 708;\n+   Name_Specification_Exceptions       : constant Name_Id := N + 709;\n+   Name_Specification_Suffix           : constant Name_Id := N + 710;\n+   Name_Stack                          : constant Name_Id := N + 711;\n+   Name_Switches                       : constant Name_Id := N + 712;\n+   Name_Symbolic_Link_Supported        : constant Name_Id := N + 713;\n+   Name_Toolchain_Description          : constant Name_Id := N + 714;\n+   Name_Toolchain_Version              : constant Name_Id := N + 715;\n \n    --  Other miscellaneous names used in front end\n \n-   Name_Unaligned_Valid                : constant Name_Id := N + 715;\n+   Name_Unaligned_Valid                : constant Name_Id := N + 716;\n \n    --  Ada 2005 reserved words\n \n-   First_2005_Reserved_Word            : constant Name_Id := N + 716;\n-   Name_Interface                      : constant Name_Id := N + 716;\n-   Name_Overriding                     : constant Name_Id := N + 717;\n-   Name_Synchronized                   : constant Name_Id := N + 718;\n-   Last_2005_Reserved_Word             : constant Name_Id := N + 718;\n+   First_2005_Reserved_Word            : constant Name_Id := N + 717;\n+   Name_Interface                      : constant Name_Id := N + 717;\n+   Name_Overriding                     : constant Name_Id := N + 718;\n+   Name_Synchronized                   : constant Name_Id := N + 719;\n+   Last_2005_Reserved_Word             : constant Name_Id := N + 719;\n \n    subtype Ada_2005_Reserved_Words is\n      Name_Id range First_2005_Reserved_Word .. Last_2005_Reserved_Word;\n \n    --  Mark last defined name for consistency check in Snames body\n \n-   Last_Predefined_Name                : constant Name_Id := N + 718;\n+   Last_Predefined_Name                : constant Name_Id := N + 719;\n \n    ---------------------------------------\n    -- Subtypes Defining Name Categories --"}]}