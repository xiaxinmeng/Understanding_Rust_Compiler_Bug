{"sha": "0275a51bf47f184ab70ad69df15aef52d5997192", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MDI3NWE1MWJmNDdmMTg0YWI3MGFkNjlkZjE1YWVmNTJkNTk5NzE5Mg==", "commit": {"author": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-04T11:57:10Z"}, "committer": {"name": "Richard Kenner", "email": "kenner@gcc.gnu.org", "date": "1993-04-04T11:57:10Z"}, "message": "(rare_destination): New function.\n\n(mostly_true_jump): Refine to use more info about destination and fallthrough;\nnow returns -1 for very unlikely branches.\n(fill_eager_delay_slots, relax_delay_slots): Allow -1 return from\nmostly_true_jump.\n\nFrom-SVN: r4001", "tree": {"sha": "cb1be2222ea45d04d4f4242620c4eefb310b3609", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/cb1be2222ea45d04d4f4242620c4eefb310b3609"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0275a51bf47f184ab70ad69df15aef52d5997192", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0275a51bf47f184ab70ad69df15aef52d5997192", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0275a51bf47f184ab70ad69df15aef52d5997192", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0275a51bf47f184ab70ad69df15aef52d5997192/comments", "author": null, "committer": null, "parents": [{"sha": "e0799b34f8717d8f35845f80585c7e63f1b30981", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e0799b34f8717d8f35845f80585c7e63f1b30981", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e0799b34f8717d8f35845f80585c7e63f1b30981"}], "stats": {"total": 135, "additions": 96, "deletions": 39}, "files": [{"sha": "81b8c512de10216cfbe22706f5dc9b6aeef5955a", "filename": "gcc/reorg.c", "status": "modified", "additions": 96, "deletions": 39, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0275a51bf47f184ab70ad69df15aef52d5997192/gcc%2Freorg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0275a51bf47f184ab70ad69df15aef52d5997192/gcc%2Freorg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Freorg.c?ref=0275a51bf47f184ab70ad69df15aef52d5997192", "patch": "@@ -229,6 +229,7 @@ static void delete_scheduled_jump PROTO((rtx));\n static void note_delay_statistics PROTO((int, int));\n static rtx optimize_skip\tPROTO((rtx));\n static int get_jump_flags PROTO((rtx, rtx));\n+static int rare_destination PROTO((rtx));\n static int mostly_true_jump\tPROTO((rtx, rtx));\n static rtx get_branch_condition\tPROTO((rtx, rtx));\n static int condition_dominates_p PROTO((rtx, rtx));\n@@ -1163,12 +1164,9 @@ get_jump_flags (insn, label)\n \t  case 1:\n \t    flags |= ATTR_FLAG_likely;\n \t    break;\n-\n \t  case 0:\n \t    flags |= ATTR_FLAG_unlikely;\n \t    break;\n-\t  /* mostly_true_jump does not return -1 for very unlikely jumps\n-\t     yet, but it should in the future.  */\n \t  case -1:\n \t    flags |= (ATTR_FLAG_very_unlikely | ATTR_FLAG_unlikely);\n \t    break;\n@@ -1183,10 +1181,54 @@ get_jump_flags (insn, label)\n   return flags;\n }\n \n+/* Return 1 if DEST is a destination that will be branched to rarely (the\n+   return point of a function); return 2 if DEST will be branched to very\n+   rarely (a call to a function that doesn't return).  Otherwise,\n+   return 0.  */\n+\n+static int\n+rare_destination (insn)\n+     rtx insn;\n+{\n+  int jump_count = 0;\n+\n+  for (; insn; insn = NEXT_INSN (insn))\n+    {\n+      if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n+\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n+\n+      switch (GET_CODE (insn))\n+\t{\n+\tcase CODE_LABEL:\n+\t  return 0;\n+\tcase BARRIER:\n+\t  /* A BARRIER can either be after a JUMP_INSN or a CALL_INSN.  We \n+\t     don't scan past JUMP_INSNs, so any barrier we find here must\n+\t     have been after a CALL_INSN and hence mean the call doesn't\n+\t     return.  */\n+\t  return 2;\n+\tcase JUMP_INSN:\n+\t  if (GET_CODE (PATTERN (insn)) == RETURN)\n+\t    return 1;\n+\t  else if (simplejump_p (insn)\n+\t\t   && jump_count++ < 10)\n+\t    insn = JUMP_LABEL (insn);\n+\t  else\n+\t    return 0;\n+\t}\n+    }\n+\n+  /* If we got here it means we hit the end of the function.  So this\n+     is an unlikely destination.  */\n+\n+  return 1;\n+}\n+\n /* Return truth value of the statement that this branch\n    is mostly taken.  If we think that the branch is extremely likely\n    to be taken, we return 2.  If the branch is slightly more likely to be\n-   taken, return 1.  Otherwise, return 0.\n+   taken, return 1.  If the branch is slightly less likely to be taken,\n+   return 0 and if the branch is highly unlikely to be taken, return -1.\n \n    CONDITION, if non-zero, is the condition that JUMP_INSN is testing.  */\n \n@@ -1196,42 +1238,57 @@ mostly_true_jump (jump_insn, condition)\n {\n   rtx target_label = JUMP_LABEL (jump_insn);\n   rtx insn;\n-\n-  /* If this is a conditional return insn, assume it won't return.  */\n-  if (target_label == 0)\n-    return 0;\n-\n-  /* If TARGET_LABEL has no jumps between it and the end of the function,\n-     this is essentially a conditional return, so predict it as false.  */\n-  for (insn = NEXT_INSN (target_label); insn; insn = NEXT_INSN (insn))\n+  int rare_dest = rare_destination (target_label);\n+  int rare_fallthrough = rare_destination (NEXT_INSN (jump_insn));\n+\n+  /* If this is a branch outside a loop, it is highly unlikely.  */\n+  if (GET_CODE (PATTERN (jump_insn)) == SET\n+      && GET_CODE (SET_SRC (PATTERN (jump_insn))) == IF_THEN_ELSE\n+      && ((GET_CODE (XEXP (SET_SRC (PATTERN (jump_insn)), 1)) == LABEL_REF\n+\t   && LABEL_OUTSIDE_LOOP_P (XEXP (SET_SRC (PATTERN (jump_insn)), 1)))\n+\t  || (GET_CODE (XEXP (SET_SRC (PATTERN (jump_insn)), 2)) == LABEL_REF\n+\t      && LABEL_OUTSIDE_LOOP_P (XEXP (SET_SRC (PATTERN (jump_insn)), 2)))))\n+    return -1;\n+\n+  if (target_label)\n     {\n-      if (GET_CODE (insn) == INSN && GET_CODE (PATTERN (insn)) == SEQUENCE)\n-\tinsn = XVECEXP (PATTERN (insn), 0, 0);\n-      if (GET_CODE (insn) == JUMP_INSN)\n-\tbreak;\n+      /* If this is the test of a loop, it is very likely true.  We scan\n+\t backwards from the target label.  If we find a NOTE_INSN_LOOP_BEG\n+\t before the next real insn, we assume the branch is to the top of \n+\t the loop.  */\n+      for (insn = PREV_INSN (target_label);\n+\t   insn && GET_CODE (insn) == NOTE;\n+\t   insn = PREV_INSN (insn))\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n+\t  return 2;\n+\n+      /* If this is a jump to the test of a loop, it is likely true.  We scan\n+\t forwards from the target label.  If we find a NOTE_INSN_LOOP_VTOP\n+\t before the next real insn, we assume the branch is to the loop branch\n+\t test.  */\n+      for (insn = NEXT_INSN (target_label);\n+\t   insn && GET_CODE (insn) == NOTE;\n+\t   insn = PREV_INSN (insn))\n+\tif (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n+\t  return 1;\n     }\n \n-  if (insn == 0)\n-    return 0;\n-\n-  /* If this is the test of a loop, it is very likely true.  We scan backwards\n-     from the target label.  If we find a NOTE_INSN_LOOP_BEG before the next\n-     real insn, we assume the branch is to the top of the loop.  */\n-  for (insn = PREV_INSN (target_label);\n-       insn && GET_CODE (insn) == NOTE;\n-       insn = PREV_INSN (insn))\n-    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_BEG)\n-      return 2;\n+  /* Look at the relative rarities of the fallthough and destination.  If\n+     they differ, we can predict the branch that way. */\n \n-  /* If this is a jump to the test of a loop, it is likely true.  We scan\n-     forwards from the target label.  If we find a NOTE_INSN_LOOP_VTOP\n-     before the next real insn, we assume the branch is to the loop branch\n-     test.  */\n-  for (insn = NEXT_INSN (target_label);\n-       insn && GET_CODE (insn) == NOTE;\n-       insn = PREV_INSN (insn))\n-    if (NOTE_LINE_NUMBER (insn) == NOTE_INSN_LOOP_VTOP)\n+  switch (rare_fallthrough - rare_dest)\n+    {\n+    case -2:\n+      return -1;\n+    case -1:\n+      return 0;\n+    case 0:\n+      break;\n+    case 1:\n       return 1;\n+    case 2:\n+      return 2;\n+    }\n \n   /* If we couldn't figure out what this jump was, assume it won't be \n      taken.  This should be rare.  */\n@@ -3349,7 +3406,7 @@ fill_eager_delay_slots (first)\n \t target, then our fallthrough insns.  If it is not, expected to branch,\n \t try the other order.  */\n \n-      if (prediction)\n+      if (prediction > 0)\n \t{\n \t  delay_list\n \t    = fill_slots_from_thread (insn, condition, insn_at_target,\n@@ -3492,9 +3549,9 @@ relax_delay_slots (first)\n \t  && (other = prev_active_insn (insn)) != 0\n \t  && condjump_p (other)\n \t  && no_labels_between_p (other, insn)\n-\t  && ! mostly_true_jump (other,\n-\t\t\t\t get_branch_condition (other,\n-\t\t\t\t\t\t       JUMP_LABEL (other))))\n+\t  && 0 < mostly_true_jump (other,\n+\t\t\t\t   get_branch_condition (other,\n+\t\t\t\t\t\t\t JUMP_LABEL (other))))\n \t{\n \t  rtx other_target = JUMP_LABEL (other);\n "}]}