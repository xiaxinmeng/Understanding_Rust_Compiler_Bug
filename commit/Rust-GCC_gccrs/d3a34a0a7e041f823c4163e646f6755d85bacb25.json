{"sha": "d3a34a0a7e041f823c4163e646f6755d85bacb25", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZDNhMzRhMGE3ZTA0MWY4MjNjNDE2M2U2NDZmNjc1NWQ4NWJhY2IyNQ==", "commit": {"author": {"name": "Jason Merrill", "email": "jason@yorick.cygnus.com", "date": "1999-08-14T00:42:07Z"}, "committer": {"name": "Jason Merrill", "email": "jason@gcc.gnu.org", "date": "1999-08-14T00:42:07Z"}, "message": "cpplib.c (read_line_number): New fn, split out of...\n\n\t* cpplib.c (read_line_number): New fn, split out of...\n\t(do_line): Here.\n\nFrom-SVN: r28707", "tree": {"sha": "d29784eb7e378d505b67f37e44240c8db48326ff", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/d29784eb7e378d505b67f37e44240c8db48326ff"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/d3a34a0a7e041f823c4163e646f6755d85bacb25", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a34a0a7e041f823c4163e646f6755d85bacb25", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d3a34a0a7e041f823c4163e646f6755d85bacb25", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d3a34a0a7e041f823c4163e646f6755d85bacb25/comments", "author": null, "committer": null, "parents": [{"sha": "8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8dd3f57a9eb02313b4d87ba14c26f5d004d61833", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8dd3f57a9eb02313b4d87ba14c26f5d004d61833"}], "stats": {"total": 74, "additions": 49, "deletions": 25}, "files": [{"sha": "0db08ba40687d4e236313b29b6fd4b592bd49407", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a34a0a7e041f823c4163e646f6755d85bacb25/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a34a0a7e041f823c4163e646f6755d85bacb25/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=d3a34a0a7e041f823c4163e646f6755d85bacb25", "patch": "@@ -1,3 +1,8 @@\n+Fri Aug 13 17:41:55 1999  Jason Merrill  <jason@yorick.cygnus.com>\n+\n+\t* cpplib.c (read_line_number): New fn, split out of...\n+\t(do_line): Here.\n+\n Fri Aug 13 14:18:27 1999  Gavin Romig-Koch  <gavin@cygnus.com>\n \n \ttree.c (lang_unsave_expr_now) : New."}, {"sha": "06b171758a0d7afa701377a2581cdab11ae03723", "filename": "gcc/cpplib.c", "status": "modified", "additions": 44, "deletions": 25, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/d3a34a0a7e041f823c4163e646f6755d85bacb25/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/d3a34a0a7e041f823c4163e646f6755d85bacb25/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=d3a34a0a7e041f823c4163e646f6755d85bacb25", "patch": "@@ -1208,6 +1208,34 @@ do_include (pfile, keyword)\n   return 0;\n }\n \n+/* Subroutine of do_line.  Read next token from PFILE without adding it to\n+   the output buffer.  If it is a number between 1 and 4, store it in *NUM\n+   and return 1; otherwise, return 0 and complain if we aren't at the end\n+   of the directive.  */\n+\n+static int\n+read_line_number (pfile, num)\n+     cpp_reader *pfile;\n+     int *num;\n+{\n+  long save_written = CPP_WRITTEN (pfile);\n+  U_CHAR *p = pfile->token_buffer + save_written;\n+  enum cpp_token token = get_directive_token (pfile);\n+  CPP_SET_WRITTEN (pfile, save_written);\n+\n+  if (token == CPP_NUMBER && *p >= '1' && *p <= '4' && p[1] == '\\0')\n+    {\n+      *num = p[0] - '0';\n+      return 1;\n+    }\n+  else\n+    {\n+      if (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP)\n+\tcpp_error (pfile, \"invalid format `#line' command\");\n+      return 0;\n+    }\n+}\n+\n /* Interpret #line command.\n    Note that the filename string (if any) is treated as if it were an\n    include filename.  That means no escape handling.  */\n@@ -1249,41 +1277,32 @@ do_line (pfile, keyword)\n     {\n       U_CHAR *fname = pfile->token_buffer + old_written + 1;\n       U_CHAR *end_name = CPP_PWRITTEN (pfile) - 1;\n-      long num_start = CPP_WRITTEN (pfile);\n+      int action_number = 0;\n \n-      token = get_directive_token (pfile);\n-      if (token != CPP_VSPACE && token != CPP_EOF && token != CPP_POP)\n+      if (read_line_number (pfile, &action_number))\n \t{\n-\t  U_CHAR *p = pfile->token_buffer + num_start;\n \t  if (CPP_PEDANTIC (pfile))\n \t    cpp_pedwarn (pfile, \"garbage at end of `#line' command\");\n \n-\t  if (token != CPP_NUMBER || *p < '0' || *p > '4' || p[1] != '\\0')\n+\t  if (action_number == 1)\n+\t    {\n+\t      file_change = enter_file;\n+\t      read_line_number (pfile, &action_number);\n+\t    }\n+\t  else if (action_number == 2)\n \t    {\n-\t      cpp_error (pfile, \"invalid format `#line' command\");\n-\t      goto bad_line_directive;\n+\t      file_change = leave_file;\n+\t      read_line_number (pfile, &action_number);\n \t    }\n-\t  if (*p == '1')\n-\t    file_change = enter_file;\n-\t  else if (*p == '2')\n-\t    file_change = leave_file;\n-\t  else if (*p == '3')\n-\t    ip->system_header_p = 1;\n-\t  else /* if (*p == '4') */\n-\t    ip->system_header_p = 2;\n-\n-\t  CPP_SET_WRITTEN (pfile, num_start);\n-\t  token = get_directive_token (pfile);\n-\t  p = pfile->token_buffer + num_start;\n-\t  if (token == CPP_NUMBER && p[1] == '\\0' && (*p == '3' || *p== '4'))\n+\t  if (action_number == 3)\n \t    {\n-\t      ip->system_header_p = *p == '3' ? 1 : 2;\n-\t      token = get_directive_token (pfile);\n+\t      ip->system_header_p = 1;\n+\t      read_line_number (pfile, &action_number);\n \t    }\n-\t  if (token != CPP_VSPACE)\n+\t  if (action_number == 4)\n \t    {\n-\t      cpp_error (pfile, \"invalid format `#line' command\");\n-\t      goto bad_line_directive;\n+\t      ip->system_header_p = 2;\n+\t      read_line_number (pfile, &action_number);\n \t    }\n \t}\n       "}]}