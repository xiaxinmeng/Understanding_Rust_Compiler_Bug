{"sha": "78ea9abc2018243af7f7ada6135144ac90c6ad27", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NzhlYTlhYmMyMDE4MjQzYWY3ZjdhZGE2MTM1MTQ0YWM5MGM2YWQyNw==", "commit": {"author": {"name": "Richard Biener", "email": "rguenther@suse.de", "date": "2018-08-27T10:55:53Z"}, "committer": {"name": "Richard Biener", "email": "rguenth@gcc.gnu.org", "date": "2018-08-27T10:55:53Z"}, "message": "cfganal.h (rev_post_order_and_mark_dfs_back_seme): Declare.\n\n2018-08-27  Richard Biener  <rguenther@suse.de>\n\n\t* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Declare.\n\t* cfganal.c (rev_post_order_and_mark_dfs_back_seme): New function.\n\n\t* tree-ssa-sccvn.h (struct vn_pval): New structure.\n\t(struct vn_nary_op_s): Add unwind_to member.  Add\n\tpredicated_values flag and put result into a union together\n\twith a linked list of vn_pval.\n\t(struct vn_ssa_aux): Add name member to make maintaining\n\ta map of SSA name to vn_ssa_aux possible.  Remove no longer\n\tneeded info, dfsnum, low, visited, on_sccstack, use_processed\n\tand range_info_anti_range_p members.\n\t(run_scc_vn, vn_eliminate, free_scc_vn, vn_valueize): Remove.\n\t(do_rpo_vn, run_rpo_vn, eliminate_with_rpo_vn, free_rpo_vn):\n\tNew functions.\n\t(vn_valueize): New global.\n\t(vn_context_bb): Likewise.\n\t(VN_INFO_RANGE_INFO, VN_INFO_ANTI_RANGE_P, VN_INFO_RANGE_TYPE,\n\tVN_INFO_PTR_INFO): Remove.\n\t* tree-ssa-sccvn.c: ... (rewrite)\n\t(pass_fre::execute): For -O2+ initialize loops and run\n\tRPO VN in optimistic mode (iterating).  For -O1 and -Og\n\trun RPO VN in non-optimistic mode.\n\t* params.def (PARAM_SCCVN_MAX_SCC_SIZE): Remove.\n\t(PARAM_RPO_VN_MAX_LOOP_DEPTH): Add.\n\t* doc/invoke.texi (sccvn-max-scc-size): Remove.\n\t(rpo-vn-max-loop-depth): Document.\n\t* tree-ssa-alias.c (walk_non_aliased_vuses): Stop walking\n\twhen valuezing the VUSE signals we walked out of the region.\n\t* tree-ssa-pre.c (phi_translate_1): Ignore predicated values.\n\t(phi_translate): Set VN context block to use for availability\n\tlookup.\n\t(compute_avail): Likewise.\n\t(pre_valueize): New function.\n\t(pass_pre::execute): Adjust to the RPO VN API.\n\n\t* tree-ssa-loop-ivcanon.c: Include tree-ssa-sccvn.h.\n\t(propagate_constants_for_unrolling): Remove.\n\t(tree_unroll_loops_completely): Perform value-numbering\n\ton the unrolled bodies loop parent.\n\n\t* g++.dg/torture/20180705-1.C: New testcase.\n\t* gcc.dg/tree-ssa/ssa-fre-67.c: Likewise.\n\t* gcc.dg/tree-ssa/ssa-ccp-14.c: Scan FRE dump.\n\t* gcc.dg/tree-ssa/ssa-fre-46.c: Use -O2.\n\t* gcc.dg/tree-ssa/vrp92.c: Disable FRE.\n\t* gcc.dg/pr83666.c: Drop --param=sccvn-max-scc-size option.\n\t* gcc.dg/pr85195.c: Likewise.\n\t* gcc.dg/pr85467.c: Likewise.\n\t* gcc.dg/torture/pr81790.c: Likewise.\n\n\t* gfortran.dg/reassoc_4.f: Change max-completely-peeled-insns\n\tparam to current default.\n\nFrom-SVN: r263875", "tree": {"sha": "54378267ac437a8e59e1ddd669550b60dd8f788f", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/54378267ac437a8e59e1ddd669550b60dd8f788f"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/78ea9abc2018243af7f7ada6135144ac90c6ad27", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ea9abc2018243af7f7ada6135144ac90c6ad27", "html_url": "https://github.com/Rust-GCC/gccrs/commit/78ea9abc2018243af7f7ada6135144ac90c6ad27", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/78ea9abc2018243af7f7ada6135144ac90c6ad27/comments", "author": {"login": "rguenth", "id": 2046526, "node_id": "MDQ6VXNlcjIwNDY1MjY=", "avatar_url": "https://avatars.githubusercontent.com/u/2046526?v=4", "gravatar_id": "", "url": "https://api.github.com/users/rguenth", "html_url": "https://github.com/rguenth", "followers_url": "https://api.github.com/users/rguenth/followers", "following_url": "https://api.github.com/users/rguenth/following{/other_user}", "gists_url": "https://api.github.com/users/rguenth/gists{/gist_id}", "starred_url": "https://api.github.com/users/rguenth/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/rguenth/subscriptions", "organizations_url": "https://api.github.com/users/rguenth/orgs", "repos_url": "https://api.github.com/users/rguenth/repos", "events_url": "https://api.github.com/users/rguenth/events{/privacy}", "received_events_url": "https://api.github.com/users/rguenth/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "8d2d69eba471b77adc69e80f224b841c41f48cf6", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8d2d69eba471b77adc69e80f224b841c41f48cf6", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8d2d69eba471b77adc69e80f224b841c41f48cf6"}], "stats": {"total": 4342, "additions": 2546, "deletions": 1796}, "files": [{"sha": "a4f4f565977e67f197ab48ddee80b8d957c608bc", "filename": "gcc/ChangeLog", "status": "modified", "additions": 42, "deletions": 0, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,3 +1,45 @@\n+2018-08-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* cfganal.h (rev_post_order_and_mark_dfs_back_seme): Declare.\n+\t* cfganal.c (rev_post_order_and_mark_dfs_back_seme): New function.\n+\n+\t* tree-ssa-sccvn.h (struct vn_pval): New structure.\n+\t(struct vn_nary_op_s): Add unwind_to member.  Add\n+\tpredicated_values flag and put result into a union together\n+\twith a linked list of vn_pval.\n+\t(struct vn_ssa_aux): Add name member to make maintaining\n+\ta map of SSA name to vn_ssa_aux possible.  Remove no longer\n+\tneeded info, dfsnum, low, visited, on_sccstack, use_processed\n+\tand range_info_anti_range_p members.\n+\t(run_scc_vn, vn_eliminate, free_scc_vn, vn_valueize): Remove.\n+\t(do_rpo_vn, run_rpo_vn, eliminate_with_rpo_vn, free_rpo_vn):\n+\tNew functions.\n+\t(vn_valueize): New global.\n+\t(vn_context_bb): Likewise.\n+\t(VN_INFO_RANGE_INFO, VN_INFO_ANTI_RANGE_P, VN_INFO_RANGE_TYPE,\n+\tVN_INFO_PTR_INFO): Remove.\n+\t* tree-ssa-sccvn.c: ... (rewrite)\n+\t(pass_fre::execute): For -O2+ initialize loops and run\n+\tRPO VN in optimistic mode (iterating).  For -O1 and -Og\n+\trun RPO VN in non-optimistic mode.\n+\t* params.def (PARAM_SCCVN_MAX_SCC_SIZE): Remove.\n+\t(PARAM_RPO_VN_MAX_LOOP_DEPTH): Add.\n+\t* doc/invoke.texi (sccvn-max-scc-size): Remove.\n+\t(rpo-vn-max-loop-depth): Document.\n+\t* tree-ssa-alias.c (walk_non_aliased_vuses): Stop walking\n+\twhen valuezing the VUSE signals we walked out of the region.\n+\t* tree-ssa-pre.c (phi_translate_1): Ignore predicated values.\n+\t(phi_translate): Set VN context block to use for availability\n+\tlookup.\n+\t(compute_avail): Likewise.\n+\t(pre_valueize): New function.\n+\t(pass_pre::execute): Adjust to the RPO VN API.\n+\n+\t* tree-ssa-loop-ivcanon.c: Include tree-ssa-sccvn.h.\n+\t(propagate_constants_for_unrolling): Remove.\n+\t(tree_unroll_loops_completely): Perform value-numbering\n+\ton the unrolled bodies loop parent.\n+\n 2018-08-27  Richard Biener  <rguenther@suse.de>\n \n \t* tree-ssa-pre.c (compute_antic): Re-use inverted postorder"}, {"sha": "3b80758e8f24cc5c26274aa06c595e81b7fb843e", "filename": "gcc/cfganal.c", "status": "modified", "additions": 114, "deletions": 1, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fcfganal.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fcfganal.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1057,8 +1057,121 @@ pre_and_rev_post_order_compute (int *pre_order, int *rev_post_order,\n   return pre_order_num;\n }\n \n+/* Unlike pre_and_rev_post_order_compute we fill rev_post_order backwards\n+   so iterating in RPO order needs to start with rev_post_order[n - 1]\n+   going to rev_post_order[0].  If FOR_ITERATION is true then try to\n+   make CFG cycles fit into small contiguous regions of the RPO order.\n+   When FOR_ITERATION is true this requires up-to-date loop structures.  */\n+\n+int\n+rev_post_order_and_mark_dfs_back_seme (struct function *fn, edge entry,\n+\t\t\t\t       bitmap exit_bbs, bool for_iteration,\n+\t\t\t\t       int *rev_post_order)\n+{\n+  int pre_order_num = 0;\n+  int rev_post_order_num = 0;\n+\n+  /* Allocate stack for back-tracking up CFG.  Worst case we need\n+     O(n^2) edges but the following should suffice in practice without\n+     a need to re-allocate.  */\n+  auto_vec<edge, 20> stack (2 * n_basic_blocks_for_fn (fn));\n+\n+  int *pre = XNEWVEC (int, 2 * last_basic_block_for_fn (fn));\n+  int *post = pre + last_basic_block_for_fn (fn);\n+\n+  /* BB flag to track nodes that have been visited.  */\n+  auto_bb_flag visited (fn);\n+  /* BB flag to track which nodes have post[] assigned to avoid\n+     zeroing post.  */\n+  auto_bb_flag post_assigned (fn);\n+\n+  /* Push the first edge on to the stack.  */\n+  stack.quick_push (entry);\n+\n+  while (!stack.is_empty ())\n+    {\n+      basic_block src;\n+      basic_block dest;\n+\n+      /* Look at the edge on the top of the stack.  */\n+      int idx = stack.length () - 1;\n+      edge e = stack[idx];\n+      src = e->src;\n+      dest = e->dest;\n+      e->flags &= ~EDGE_DFS_BACK;\n+\n+      /* Check if the edge destination has been visited yet.  */\n+      if (! bitmap_bit_p (exit_bbs, dest->index)\n+\t  && ! (dest->flags & visited))\n+\t{\n+\t  /* Mark that we have visited the destination.  */\n+\t  dest->flags |= visited;\n+\n+\t  pre[dest->index] = pre_order_num++;\n+\n+\t  if (EDGE_COUNT (dest->succs) > 0)\n+\t    {\n+\t      /* Since the DEST node has been visited for the first\n+\t\t time, check its successors.  */\n+\t      /* Push the edge vector in reverse to match previous behavior.  */\n+\t      stack.reserve (EDGE_COUNT (dest->succs));\n+\t      for (int i = EDGE_COUNT (dest->succs) - 1; i >= 0; --i)\n+\t\tstack.quick_push (EDGE_SUCC (dest, i));\n+\t      /* Generalize to handle more successors?  */\n+\t      if (for_iteration\n+\t\t  && EDGE_COUNT (dest->succs) == 2)\n+\t\t{\n+\t\t  edge &e1 = stack[stack.length () - 2];\n+\t\t  if (loop_exit_edge_p (e1->src->loop_father, e1))\n+\t\t    std::swap (e1, stack.last ());\n+\t\t}\n+\t    }\n+\t  else\n+\t    {\n+\t      /* There are no successors for the DEST node so assign\n+\t\t its reverse completion number.  */\n+\t      post[dest->index] = rev_post_order_num;\n+\t      dest->flags |= post_assigned;\n+\t      rev_post_order[rev_post_order_num] = dest->index;\n+\t      rev_post_order_num++;\n+\t    }\n+\t}\n+      else\n+\t{\n+\t  if (dest->flags & visited\n+\t      && src != entry->src\n+\t      && pre[src->index] >= pre[dest->index]\n+\t      && !(dest->flags & post_assigned))\n+\t    e->flags |= EDGE_DFS_BACK;\n+\n+\t  if (idx != 0 && stack[idx - 1]->src != src)\n+\t    {\n+\t      /* There are no more successors for the SRC node\n+\t\t so assign its reverse completion number.  */\n+\t      post[src->index] = rev_post_order_num;\n+\t      src->flags |= post_assigned;\n+\t      rev_post_order[rev_post_order_num] = src->index;\n+\t      rev_post_order_num++;\n+\t    }\n+\n+\t  stack.pop ();\n+\t}\n+    }\n+\n+  XDELETEVEC (pre);\n+\n+  /* Clear the temporarily allocated flags.  */\n+  for (int i = 0; i < rev_post_order_num; ++i)\n+    BASIC_BLOCK_FOR_FN (fn, rev_post_order[i])->flags\n+      &= ~(post_assigned|visited);\n+\n+  return rev_post_order_num;\n+}\n+\n+\n+\n /* Compute the depth first search order on the _reverse_ graph and\n-   store in the array DFS_ORDER, marking the nodes visited in VISITED.\n+   store it in the array DFS_ORDER, marking the nodes visited in VISITED.\n    Returns the number of nodes visited.\n \n    The computation is split into three pieces:"}, {"sha": "122c665f7f6c6ab2a39470dfe4e30c36fad8c9c6", "filename": "gcc/cfganal.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fcfganal.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fcfganal.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcfganal.h?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -67,6 +67,8 @@ extern void inverted_post_order_compute (vec<int> *postorder, sbitmap *start_poi\n extern int pre_and_rev_post_order_compute_fn (struct function *,\n \t\t\t\t\t      int *, int *, bool);\n extern int pre_and_rev_post_order_compute (int *, int *, bool);\n+extern int rev_post_order_and_mark_dfs_back_seme (struct function *, edge,\n+\t\t\t\t\t\t  bitmap, bool, int *);\n extern int dfs_enumerate_from (basic_block, int,\n \t\t\t       bool (*)(const_basic_block, const void *),\n \t\t\t       basic_block *, int, const void *);"}, {"sha": "e37233d6ed44bf175ffc0489f74d0fd21529cd86", "filename": "gcc/doc/invoke.texi", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fdoc%2Finvoke.texi", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fdoc%2Finvoke.texi", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fdoc%2Finvoke.texi?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -11076,11 +11076,12 @@ parameter sets a limit on the length of the sets that are computed,\n which prevents the runaway behavior.  Setting a value of 0 for\n this parameter allows an unlimited set length.\n \n-@item sccvn-max-scc-size\n-Maximum size of a strongly connected component (SCC) during SCCVN\n-processing.  If this limit is hit, SCCVN processing for the whole\n-function is not done and optimizations depending on it are\n-disabled.  The default maximum SCC size is 10000.\n+@item rpo-vn-max-loop-depth\n+Maximum loop depth that is value-numbered optimistically.  The default\n+maximum loop depth is three.  When the limit hits the innermost\n+@var{rpo-vn-max-loop-depth} loops and the outermost loop in the\n+loop nest are value-numbered optimistically and the remaining ones not.\n+The default maximum loop depth is seven.\n \n @item sccvn-max-alias-queries-per-access\n Maximum number of alias-oracle queries we perform when looking for"}, {"sha": "a0ad3ecdad64ac6f1d8bc41e18e21692e1a0823d", "filename": "gcc/params.def", "status": "modified", "additions": 9, "deletions": 9, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fparams.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Fparams.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fparams.def?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -847,15 +847,15 @@ DEFPARAM (PARAM_MAX_PARTIAL_ANTIC_LENGTH,\n \t  \"Maximum length of partial antic set when performing tree pre optimization.\",\n \t  100, 0, 0)\n \n-/* The following is used as a stop-gap limit for cases where really huge\n-   SCCs blow up memory and compile-time use too much.  If we hit this limit,\n-   SCCVN and such FRE and PRE will be not done at all for the current\n-   function.  */\n-\n-DEFPARAM (PARAM_SCCVN_MAX_SCC_SIZE,\n-\t  \"sccvn-max-scc-size\",\n-\t  \"Maximum size of a SCC before SCCVN stops processing a function.\",\n-\t  10000, 10, 0)\n+/* The following is used as a stop-gap limit for cases where really deep\n+   loop nests cause compile-time to blow up.  If we hit this limit,\n+   FRE and PRE will value-number outer loops (but the outermost) in a\n+   loop nest non-optimistically.  */\n+\n+DEFPARAM (PARAM_RPO_VN_MAX_LOOP_DEPTH,\n+\t  \"rpo-vn-max-loop-depth\",\n+\t  \"Maximum depth of a loop nest to fully value-number optimistically.\",\n+\t  7, 2, 0)\n \n /* The following is used as a stop-gap limit for cases where really huge\n    functions blow up compile-time use too much.  It limits the number of"}, {"sha": "ef5da5aae78c8ad821eb5dcb2fc72ae6bd8baee7", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,3 +1,18 @@\n+2018-08-27  Richard Biener  <rguenther@suse.de>\n+\n+\t* g++.dg/torture/20180705-1.C: New testcase.\n+\t* gcc.dg/tree-ssa/ssa-fre-67.c: Likewise.\n+\t* gcc.dg/tree-ssa/ssa-ccp-14.c: Scan FRE dump.\n+\t* gcc.dg/tree-ssa/ssa-fre-46.c: Use -O2.\n+\t* gcc.dg/tree-ssa/vrp92.c: Disable FRE.\n+\t* gcc.dg/pr83666.c: Drop --param=sccvn-max-scc-size option.\n+\t* gcc.dg/pr85195.c: Likewise.\n+\t* gcc.dg/pr85467.c: Likewise.\n+\t* gcc.dg/torture/pr81790.c: Likewise.\n+\n+\t* gfortran.dg/reassoc_4.f: Change max-completely-peeled-insns\n+\tparam to current default.\n+\n 2018-08-27  Jakub Jelinek  <jakub@redhat.com>\n \n \tPR rtl-optimization/87065"}, {"sha": "8460473bee8c6e7bf4ebbd2dfe0c4cf5956ded81", "filename": "gcc/testsuite/g++.dg/torture/20180705-1.C", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20180705-1.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20180705-1.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Ftorture%2F20180705-1.C?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -0,0 +1,30 @@\n+// { dg-do compile }\n+\n+typedef long unsigned int size_t;\n+extern void fancy_abort () __attribute__ ((__noreturn__));\n+class cpp_string_location_reader { };\n+class cpp_substring_ranges {\n+public:\n+    void add_range ();\n+};\n+typedef unsigned char uchar;\n+void\n+cpp_interpret_string_1 (size_t count, cpp_string_location_reader *loc_readers,    cpp_substring_ranges *ranges, uchar c, const uchar *p)\n+{\n+  size_t i;\n+  ((void)(!((loc_readers !=   __null  ) == (ranges !=   __null  )) ? fancy_abort (), 0 : 0));\n+  cpp_string_location_reader *loc_reader = __null;\n+  for (i = 0; i < count; i++) \n+    {\n+      if (loc_readers)  loc_reader = &loc_readers[i];\n+      if (*p == 'R') \tcontinue;\n+      for (;;) \t\n+\t{\n+\t  switch (c)     {\n+\t    case 'x':       if (ranges) ranges->add_range (); break;\n+\t    case '7':       ((void)(!((loc_reader !=   __null  ) == (ranges !=   __null  )) ? fancy_abort (), 0 : 0)); break;\n+\t  }\n+\t  p = 0;\n+\t}\n+    }\n+}"}, {"sha": "1c43c438544d8101cdbdfb076ee90a07a2a72d89", "filename": "gcc/testsuite/gcc.dg/pr83666.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83666.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83666.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr83666.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,6 +1,6 @@\n /* PR debug/83666 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -g --param=sccvn-max-scc-size=10 -Wno-psabi\" } */\n+/* { dg-options \"-O2 -g -Wno-psabi\" } */\n /* { dg-additional-options \"-fno-common\" { target hppa*-*-hpux* } } */\n \n typedef int __attribute__ ((vector_size (64))) V;"}, {"sha": "fb21ee97c5c783493ac45609b736dd88c1f37db5", "filename": "gcc/testsuite/gcc.dg/pr85195.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85195.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85195.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85195.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,6 +1,6 @@\n /* PR middle-end/85195 */\n /* { dg-do compile { target int128 } } */\n-/* { dg-options \"-Wno-psabi -O -fno-tree-ccp --param=sccvn-max-scc-size=10\" } */\n+/* { dg-options \"-Wno-psabi -O -fno-tree-ccp\" } */\n \n typedef __int128 V __attribute__ ((vector_size (16)));\n "}, {"sha": "fad94fcd83ee03ef80e822888bf1f5227582eda4", "filename": "gcc/testsuite/gcc.dg/pr85467.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85467.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85467.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Fpr85467.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,6 +1,6 @@\n /* PR tree-optimization/85467 */\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fno-tree-ccp --param=sccvn-max-scc-size=10\" } */\n+/* { dg-options \"-O2 -fno-tree-ccp\" } */\n \n #define TEST(N, T) \\\n typedef T V##N __attribute__ ((__vector_size__ (sizeof (T))));\t\\"}, {"sha": "b69946f9d10be742d0411a8cbd4acf2255d9cb4e", "filename": "gcc/testsuite/gcc.dg/torture/pr81790.c", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr81790.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr81790.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftorture%2Fpr81790.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,5 +1,4 @@\n /* { dg-do compile } */\n-/* { dg-additional-options \"--param sccvn-max-scc-size=10\" } */\n \n typedef int a __attribute__ ((__vector_size__ (16)));\n typedef struct"}, {"sha": "65e2d5a664bb4d746b4b439973b564de2a4ef436", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-ccp-14.c", "status": "modified", "additions": 5, "deletions": 6, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-ccp-14.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,8 +1,5 @@\n-/* PR tree-optimization/29738.  We used not to realize that \"i\" can never\n-   become nonzero.  */\n-\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdump-tree-optimized\" } */\n+/* { dg-options \"-O2 -fdump-tree-fre1 -fdump-tree-optimized\" } */\n \n int i;\n \n@@ -16,5 +13,7 @@ void bar (void)\n       foo ();\n }\n \n-/* Everything except for the \"i = 0\" assignment should get removed.  */\n-/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\" { xfail *-*-* } } } */\n+/* Everything except for the \"i = 0\" assignment should get removed.  Value\n+   numbering already figures out the if in the loop is never true.  */\n+/* { dg-final { scan-tree-dump-times \"foo\" 0 \"fre1\" } } */\n+/* { dg-final { scan-tree-dump-times \"if\" 0 \"optimized\" } } */"}, {"sha": "8d6eaa3ada0f0ba776ef798c81786e3efbd8d244", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-46.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-46.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-46.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-46.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O -fdump-tree-fre1-details\" } */\n+/* { dg-options \"-O2 -fdump-tree-fre1-details\" } */\n \n int x[1024];\n int foo (int a, int s, unsigned int k)"}, {"sha": "fab1e599b81191f55bd5f0db86760f4c4761cc6d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/ssa-fre-67.c", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-67.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-67.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fssa-fre-67.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -0,0 +1,16 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -fno-tree-ccp -fdump-tree-fre1-stats\" } */\n+\n+int foo()\n+{\n+  int i = 0;\n+  do\n+    {\n+      i++;\n+    }\n+  while (i != 1);\n+  return i;\n+}\n+\n+/* { dg-final { scan-tree-dump \"RPO iteration over 3 blocks visited 3 blocks\" \"fre1\" } } */\n+/* { dg-final { scan-tree-dump \"return 1;\" \"fre1\" } } */"}, {"sha": "5a2dbf0108a896bf002273a6ef28edd42bc5c27d", "filename": "gcc/testsuite/gcc.dg/tree-ssa/vrp92.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp92.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp92.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.dg%2Ftree-ssa%2Fvrp92.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,5 +1,5 @@\n /* { dg-do compile } */\n-/* { dg-options \"-O2 -fdisable-tree-evrp -fdump-tree-vrp1-details -fdisable-tree-ethread\" } */\n+/* { dg-options \"-O2 -fdisable-tree-evrp -fno-tree-fre -fdump-tree-vrp1-details -fdisable-tree-ethread\" } */\n \n void bar (void);\n int foo (int i, int j)"}, {"sha": "07b4affb2a4fe9bc75318bec390e30c679019b07", "filename": "gcc/testsuite/gfortran.dg/reassoc_4.f", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.dg%2Freassoc_4.f?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -1,5 +1,5 @@\n ! { dg-do compile }\n-! { dg-options \"-O3 -ffast-math -fdump-tree-reassoc1 --param max-completely-peeled-insns=400\" }\n+! { dg-options \"-O3 -ffast-math -fdump-tree-reassoc1 --param max-completely-peeled-insns=200\" }\n ! { dg-additional-options \"--param max-completely-peel-times=16\" { target spu-*-* } }\n       subroutine anisonl(w,vo,anisox,s,ii1,jj1,weight)\n       integer ii1,jj1,i1,iii1,j1,jjj1,k1,l1,m1,n1"}, {"sha": "e6e21e8773c1cc0986796a2781f7c52674791b83", "filename": "gcc/tree-ssa-alias.c", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-alias.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-alias.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-alias.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -2783,7 +2783,14 @@ walk_non_aliased_vuses (ao_ref *ref, tree vuse,\n \tbreak;\n \n       if (valueize)\n-\tvuse = valueize (vuse);\n+\t{\n+\t  vuse = valueize (vuse);\n+\t  if (!vuse)\n+\t    {\n+\t      res = NULL;\n+\t      break;\n+\t    }\n+\t}\n       def_stmt = SSA_NAME_DEF_STMT (vuse);\n       if (gimple_nop_p (def_stmt))\n \tbreak;"}, {"sha": "97c2ad9498560133f9352d926d0685085345dac8", "filename": "gcc/tree-ssa-loop-ivcanon.c", "status": "modified", "additions": 9, "deletions": 48, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-loop-ivcanon.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-loop-ivcanon.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-loop-ivcanon.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -63,6 +63,7 @@ along with GCC; see the file COPYING3.  If not see\n #include \"tree-inline.h\"\n #include \"tree-cfgcleanup.h\"\n #include \"builtins.h\"\n+#include \"tree-ssa-sccvn.h\"\n \n /* Specifies types of loops that may be unrolled.  */\n \n@@ -1318,50 +1319,6 @@ canonicalize_induction_variables (void)\n   return 0;\n }\n \n-/* Propagate constant SSA_NAMEs defined in basic block BB.  */\n-\n-static void\n-propagate_constants_for_unrolling (basic_block bb)\n-{\n-  /* Look for degenerate PHI nodes with constant argument.  */\n-  for (gphi_iterator gsi = gsi_start_phis (bb); !gsi_end_p (gsi); )\n-    {\n-      gphi *phi = gsi.phi ();\n-      tree result = gimple_phi_result (phi);\n-      tree arg = gimple_phi_arg_def (phi, 0);\n-\n-      if (! SSA_NAME_OCCURS_IN_ABNORMAL_PHI (result)\n-\t  && gimple_phi_num_args (phi) == 1\n-\t  && CONSTANT_CLASS_P (arg))\n-\t{\n-\t  replace_uses_by (result, arg);\n-\t  gsi_remove (&gsi, true);\n-\t  release_ssa_name (result);\n-\t}\n-      else\n-\tgsi_next (&gsi);\n-    }\n-\n-  /* Look for assignments to SSA names with constant RHS.  */\n-  for (gimple_stmt_iterator gsi = gsi_start_bb (bb); !gsi_end_p (gsi); )\n-    {\n-      gimple *stmt = gsi_stmt (gsi);\n-      tree lhs;\n-\n-      if (is_gimple_assign (stmt)\n-\t  && TREE_CODE_CLASS (gimple_assign_rhs_code (stmt)) == tcc_constant\n-\t  && (lhs = gimple_assign_lhs (stmt), TREE_CODE (lhs) == SSA_NAME)\n-\t  && !SSA_NAME_OCCURS_IN_ABNORMAL_PHI (lhs))\n-\t{\n-\t  replace_uses_by (lhs, gimple_assign_rhs1 (stmt));\n-\t  gsi_remove (&gsi, true);\n-\t  release_ssa_name (lhs);\n-\t}\n-      else\n-\tgsi_next (&gsi);\n-    }\n-}\n-\n /* Process loops from innermost to outer, stopping at the innermost\n    loop we unrolled.  */\n \n@@ -1512,10 +1469,14 @@ tree_unroll_loops_completely (bool may_increase_size, bool unroll_outer)\n \t  EXECUTE_IF_SET_IN_BITMAP (fathers, 0, i, bi)\n \t    {\n \t      loop_p father = get_loop (cfun, i);\n-\t      basic_block *body = get_loop_body_in_dom_order (father);\n-\t      for (unsigned j = 0; j < father->num_nodes; j++)\n-\t\tpropagate_constants_for_unrolling (body[j]);\n-\t      free (body);\n+\t      bitmap exit_bbs = BITMAP_ALLOC (NULL);\n+\t      loop_exit *exit = father->exits->next;\n+\t      while (exit->e)\n+\t\t{\n+\t\t  bitmap_set_bit (exit_bbs, exit->e->dest->index);\n+\t\t  exit = exit->next;\n+\t\t}\n+\t      do_rpo_vn (cfun, loop_preheader_edge (father), exit_bbs);\n \t    }\n \t  BITMAP_FREE (fathers);\n "}, {"sha": "2dce88bd85e4d486d4f0dbb125d6a10e3cc7d050", "filename": "gcc/tree-ssa-pre.c", "status": "modified", "additions": 69, "deletions": 21, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-pre.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-pre.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-pre.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -677,10 +677,10 @@ get_expr_value_id (pre_expr expr)\n   return id;\n }\n \n-/* Return a SCCVN valnum (SSA name or constant) for the PRE value-id VAL.  */\n+/* Return a VN valnum (SSA name or constant) for the PRE value-id VAL.  */\n \n static tree\n-sccvn_valnum_from_value_id (unsigned int val)\n+vn_valnum_from_value_id (unsigned int val)\n {\n   bitmap_iterator bi;\n   unsigned int i;\n@@ -1308,9 +1308,9 @@ get_representative_for (const pre_expr e, basic_block b = NULL)\n      ???  We should be able to re-use this when we insert the statement\n      to compute it.  */\n   name = make_temp_ssa_name (get_expr_type (e), gimple_build_nop (), \"pretmp\");\n-  VN_INFO_GET (name)->value_id = value_id;\n+  VN_INFO (name)->value_id = value_id;\n   VN_INFO (name)->valnum = valnum ? valnum : name;\n-  /* ???  For now mark this SSA name for release by SCCVN.  */\n+  /* ???  For now mark this SSA name for release by VN.  */\n   VN_INFO (name)->needs_insertion = true;\n   add_to_value (value_id, get_or_alloc_expr_for_name (name));\n   if (dump_file && (dump_flags & TDF_DETAILS))\n@@ -1404,7 +1404,22 @@ phi_translate_1 (bitmap_set_t dest,\n \t\t\tconstant = find_leader_in_sets (value_id, dest,\n \t\t\t\t\t\t\tAVAIL_OUT (pred));\n \t\t\tif (constant)\n-\t\t\t  return constant;\n+\t\t\t  {\n+\t\t\t    if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\t\t      {\n+\t\t\t\tfprintf (dump_file, \"simplifying \");\n+\t\t\t\tprint_pre_expr (dump_file, expr);\n+\t\t\t\tfprintf (dump_file, \" translated %d -> %d to \",\n+\t\t\t\t\t phiblock->index, pred->index);\n+\t\t\t\tPRE_EXPR_NARY (expr) = newnary;\n+\t\t\t\tprint_pre_expr (dump_file, expr);\n+\t\t\t\tPRE_EXPR_NARY (expr) = nary;\n+\t\t\t\tfprintf (dump_file, \" to \");\n+\t\t\t\tprint_pre_expr (dump_file, constant);\n+\t\t\t\tfprintf (dump_file, \"\\n\");\n+\t\t\t      }\n+\t\t\t    return constant;\n+\t\t\t  }\n \t\t      }\n \t\t  }\n \t\telse\n@@ -1426,7 +1441,7 @@ phi_translate_1 (bitmap_set_t dest,\n \t    expr = pre_expr_pool.allocate ();\n \t    expr->kind = NARY;\n \t    expr->id = 0;\n-\t    if (nary)\n+\t    if (nary && !nary->predicated_values)\n \t      {\n \t\tPRE_EXPR_NARY (expr) = nary;\n \t\tnew_val_id = nary->value_id;\n@@ -1664,7 +1679,10 @@ phi_translate (bitmap_set_t dest, pre_expr expr,\n     }\n \n   /* Translate.  */\n+  basic_block saved_valueize_bb = vn_context_bb;\n+  vn_context_bb = e->src;\n   phitrans = phi_translate_1 (dest, expr, set1, set2, e);\n+  vn_context_bb = saved_valueize_bb;\n \n   if (slot)\n     {\n@@ -2923,7 +2941,7 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n \n \t  if (forcedname != folded)\n \t    {\n-\t      VN_INFO_GET (forcedname)->valnum = forcedname;\n+\t      VN_INFO (forcedname)->valnum = forcedname;\n \t      VN_INFO (forcedname)->value_id = get_next_value_id ();\n \t      nameexpr = get_or_alloc_expr_for_name (forcedname);\n \t      add_to_value (VN_INFO (forcedname)->value_id, nameexpr);\n@@ -2949,8 +2967,8 @@ create_expression_by_pieces (basic_block block, pre_expr expr,\n      the expression may have been represented.  There is no harm in replacing\n      here.  */\n   value_id = get_expr_value_id (expr);\n-  VN_INFO_GET (name)->value_id = value_id;\n-  VN_INFO (name)->valnum = sccvn_valnum_from_value_id (value_id);\n+  VN_INFO (name)->value_id = value_id;\n+  VN_INFO (name)->valnum = vn_valnum_from_value_id (value_id);\n   if (VN_INFO (name)->valnum == NULL_TREE)\n     VN_INFO (name)->valnum = name;\n   gcc_assert (VN_INFO (name)->valnum != NULL_TREE);\n@@ -3055,8 +3073,8 @@ insert_into_preds_of_block (basic_block block, unsigned int exprnum,\n   temp = make_temp_ssa_name (type, NULL, \"prephitmp\");\n   phi = create_phi_node (temp, block);\n \n-  VN_INFO_GET (temp)->value_id = val;\n-  VN_INFO (temp)->valnum = sccvn_valnum_from_value_id (val);\n+  VN_INFO (temp)->value_id = val;\n+  VN_INFO (temp)->valnum = vn_valnum_from_value_id (val);\n   if (VN_INFO (temp)->valnum == NULL_TREE)\n     VN_INFO (temp)->valnum = temp;\n   bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (temp));\n@@ -3300,8 +3318,8 @@ do_pre_regular_insertion (basic_block block, basic_block dom)\n \t      gimple_stmt_iterator gsi = gsi_after_labels (block);\n \t      gsi_insert_before (&gsi, assign, GSI_NEW_STMT);\n \n-\t      VN_INFO_GET (temp)->value_id = val;\n-\t      VN_INFO (temp)->valnum = sccvn_valnum_from_value_id (val);\n+\t      VN_INFO (temp)->value_id = val;\n+\t      VN_INFO (temp)->valnum = vn_valnum_from_value_id (val);\n \t      if (VN_INFO (temp)->valnum == NULL_TREE)\n \t\tVN_INFO (temp)->valnum = temp;\n \t      bitmap_set_bit (inserted_exprs, SSA_NAME_VERSION (temp));\n@@ -3742,6 +3760,7 @@ compute_avail (void)\n \n       /* Pick a block from the worklist.  */\n       block = worklist[--sp];\n+      vn_context_bb = block;\n \n       /* Initially, the set of available values in BLOCK is that of\n \t its immediate dominator.  */\n@@ -4043,6 +4062,7 @@ compute_avail (void)\n \t   son = next_dom_son (CDI_DOMINATORS, son))\n \tworklist[sp++] = son;\n     }\n+  vn_context_bb = NULL;\n \n   free (worklist);\n }\n@@ -4133,6 +4153,34 @@ class pass_pre : public gimple_opt_pass\n \n }; // class pass_pre\n \n+/* Valueization hook for RPO VN when we are calling back to it\n+   at ANTIC compute time.  */\n+\n+static tree\n+pre_valueize (tree name)\n+{\n+  if (TREE_CODE (name) == SSA_NAME)\n+    {\n+      tree tem = VN_INFO (name)->valnum;\n+      if (tem != VN_TOP && tem != name)\n+\t{\n+\t  if (TREE_CODE (tem) != SSA_NAME\n+\t      || SSA_NAME_IS_DEFAULT_DEF (tem))\n+\t    return tem;\n+\t  /* We create temporary SSA names for representatives that\n+\t     do not have a definition (yet) but are not default defs either\n+\t     assume they are fine to use.  */\n+\t  basic_block def_bb = gimple_bb (SSA_NAME_DEF_STMT (tem));\n+\t  if (! def_bb\n+\t      || dominated_by_p (CDI_DOMINATORS, vn_context_bb, def_bb))\n+\t    return tem;\n+\t  /* ??? Now we could look for a leader.  Ideally we'd somehow\n+\t     expose RPO VN leaders and get rid of AVAIL_OUT as well...  */\n+\t}\n+    }\n+  return name;\n+}\n+\n unsigned int\n pass_pre::execute (function *fun)\n {\n@@ -4141,16 +4189,18 @@ pass_pre::execute (function *fun)\n   do_partial_partial =\n     flag_tree_partial_pre && optimize_function_for_speed_p (fun);\n \n-  /* This has to happen before SCCVN runs because\n+  /* This has to happen before VN runs because\n      loop_optimizer_init may create new phis, etc.  */\n   loop_optimizer_init (LOOPS_NORMAL);\n   split_critical_edges ();\n   scev_initialize ();\n \n-  run_scc_vn (VN_WALK);\n+  run_rpo_vn (VN_WALK);\n \n   init_pre ();\n \n+  vn_valueize = pre_valueize;\n+\n   /* Insert can get quite slow on an incredibly large number of basic\n      blocks due to some quadratic behavior.  Until this behavior is\n      fixed, don't run it when he have an incredibly large number of\n@@ -4179,8 +4229,9 @@ pass_pre::execute (function *fun)\n   statistics_counter_event (fun, \"HOIST inserted\", pre_stats.hoist_insert);\n   statistics_counter_event (fun, \"New PHIs\", pre_stats.phis);\n \n-  /* Remove all the redundant expressions.  */\n-  todo |= vn_eliminate (inserted_exprs);\n+  todo |= eliminate_with_rpo_vn (inserted_exprs);\n+\n+  vn_valueize = NULL;\n \n   /* Because we don't follow exactly the standard PRE algorithm, and decide not\n      to insert PHI nodes sometimes, and because value numbering of casts isn't\n@@ -4193,9 +4244,6 @@ pass_pre::execute (function *fun)\n   scev_finalize ();\n   loop_optimizer_finalize ();\n \n-  /* Restore SSA info before tail-merging as that resets it as well.  */\n-  scc_vn_restore_ssa_info ();\n-\n   /* TODO: tail_merge_optimize may merge all predecessors of a block, in which\n      case we can merge the block with the remaining predecessor of the block.\n      It should either:\n@@ -4205,7 +4253,7 @@ pass_pre::execute (function *fun)\n      - share the cfg cleanup with fini_pre.  */\n   todo |= tail_merge_optimize (todo);\n \n-  free_scc_vn ();\n+  free_rpo_vn ();\n \n   /* Tail merging invalidates the virtual SSA web, together with\n      cfg-cleanup opportunities exposed by PRE this will wreck the"}, {"sha": "c927cb8078f1ad2f70e246c8584fb2d020aa5719", "filename": "gcc/tree-ssa-sccvn.c", "status": "modified", "additions": 2183, "deletions": 1630, "changes": 3813, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-sccvn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-sccvn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.c?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27"}, {"sha": "ea4efd8e23b3dff414ae8d275fc50ba704e2cd9e", "filename": "gcc/tree-ssa-sccvn.h", "status": "modified", "additions": 32, "deletions": 68, "changes": 100, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-sccvn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/78ea9abc2018243af7f7ada6135144ac90c6ad27/gcc%2Ftree-ssa-sccvn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftree-ssa-sccvn.h?ref=78ea9abc2018243af7f7ada6135144ac90c6ad27", "patch": "@@ -28,6 +28,18 @@ bool expressions_equal_p (tree, tree);\n /* TOP of the VN lattice.  */\n extern tree VN_TOP;\n \n+/* A predicated value.  */\n+struct vn_pval\n+{\n+  vn_pval *next;\n+  /* The value of the expression this is attached to is RESULT in\n+     case the expression is computed dominated by one of the blocks\n+     in valid_dominated_by_p.  */\n+  tree result;\n+  unsigned n;\n+  int valid_dominated_by_p[1];\n+};\n+\n /* N-ary operations in the hashtable consist of length operands, an\n    opcode, and a type.  Result is the value number of the operation,\n    and hashcode is stored to avoid having to calculate it\n@@ -36,12 +48,19 @@ extern tree VN_TOP;\n typedef struct vn_nary_op_s\n {\n   vn_nary_op_s *next;\n+  vn_nary_op_s *unwind_to;\n   /* Unique identify that all expressions with the same value have. */\n   unsigned int value_id;\n   ENUM_BITFIELD(tree_code) opcode : 16;\n   unsigned length : 16;\n   hashval_t hashcode;\n-  tree result;\n+  unsigned predicated_values : 1;\n+  union {\n+      /* If ! predicated_values this is the value of the expression.  */\n+      tree result;\n+      /* If predicated_values this is a list of values of the expression.  */\n+      vn_pval *values;\n+  } u;\n   tree type;\n   tree op[1];\n } *vn_nary_op_t;\n@@ -176,48 +195,31 @@ vn_constant_eq_with_type (tree c1, tree c2)\n \n typedef struct vn_ssa_aux\n {\n+  /* SSA name this vn_ssa_aux is associated with in the lattice.  */\n+  tree name;\n   /* Value number. This may be an SSA name or a constant.  */\n   tree valnum;\n   /* Statements to insert if needs_insertion is true.  */\n   gimple_seq expr;\n \n-  /* Saved SSA name info.  */\n-  tree_ssa_name::ssa_name_info_type info;\n-\n   /* Unique identifier that all expressions with the same value have. */\n   unsigned int value_id;\n \n-  /* SCC information.  */\n-  unsigned int dfsnum;\n-  unsigned int low;\n+  /* Whether the SSA_NAME has been processed at least once.  */\n   unsigned visited : 1;\n-  unsigned on_sccstack : 1;\n-\n-  /* Whether the SSA_NAME has been value numbered already.  This is\n-     only saying whether visit_use has been called on it at least\n-     once.  It cannot be used to avoid visitation for SSA_NAME's\n-     involved in non-singleton SCC's.  */\n-  unsigned use_processed : 1;\n \n   /* Whether the SSA_NAME has no defining statement and thus an\n      insertion of such with EXPR as definition is required before\n      a use can be created of it.  */\n   unsigned needs_insertion : 1;\n-\n-  /* Whether range-info is anti-range.  */\n-  unsigned range_info_anti_range_p : 1;\n } *vn_ssa_aux_t;\n \n enum vn_lookup_kind { VN_NOWALK, VN_WALK, VN_WALKREWRITE };\n \n /* Return the value numbering info for an SSA_NAME.  */\n bool has_VN_INFO (tree);\n extern vn_ssa_aux_t VN_INFO (tree);\n-extern vn_ssa_aux_t VN_INFO_GET (tree);\n tree vn_get_expr_for (tree);\n-void run_scc_vn (vn_lookup_kind);\n-unsigned int vn_eliminate (bitmap);\n-void free_scc_vn (void);\n void scc_vn_restore_ssa_info (void);\n tree vn_nary_op_lookup (tree, vn_nary_op_t *);\n tree vn_nary_op_lookup_stmt (gimple *, vn_nary_op_t *);\n@@ -250,55 +252,17 @@ bool value_id_constant_p (unsigned int);\n tree fully_constant_vn_reference_p (vn_reference_t);\n tree vn_nary_simplify (vn_nary_op_t);\n \n-/* Valueize NAME if it is an SSA name, otherwise just return it.  */\n-\n-static inline tree\n-vn_valueize (tree name)\n-{\n-  if (TREE_CODE (name) == SSA_NAME)\n-    {\n-      tree tem = VN_INFO (name)->valnum;\n-      return tem == VN_TOP ? name : tem;\n-    }\n-  return name;\n-}\n+unsigned do_rpo_vn (function *, edge, bitmap);\n+void run_rpo_vn (vn_lookup_kind);\n+unsigned eliminate_with_rpo_vn (bitmap);\n+void free_rpo_vn (void);\n \n-/* Get at the original range info for NAME.  */\n+/* Valueize NAME if it is an SSA name, otherwise just return it.  This hook\n+   is initialized by run_scc_vn.  */\n+extern tree (*vn_valueize) (tree);\n \n-inline range_info_def *\n-VN_INFO_RANGE_INFO (tree name)\n-{\n-  return (VN_INFO (name)->info.range_info\n-\t  ? VN_INFO (name)->info.range_info\n-\t  : SSA_NAME_RANGE_INFO (name));\n-}\n+/* Context that valueization should operate on.  */\n+extern basic_block vn_context_bb;\n \n-/* Whether the original range info of NAME is an anti-range.  */\n-\n-inline bool\n-VN_INFO_ANTI_RANGE_P (tree name)\n-{\n-  return (VN_INFO (name)->info.range_info\n-\t  ? VN_INFO (name)->range_info_anti_range_p\n-\t  : SSA_NAME_ANTI_RANGE_P (name));\n-}\n-\n-/* Get at the original range info kind for NAME.  */\n-\n-inline value_range_type\n-VN_INFO_RANGE_TYPE (tree name)\n-{\n-  return VN_INFO_ANTI_RANGE_P (name) ? VR_ANTI_RANGE : VR_RANGE;\n-}\n-\n-/* Get at the original pointer info for NAME.  */\n-\n-inline ptr_info_def *\n-VN_INFO_PTR_INFO (tree name)\n-{\n-  return (VN_INFO (name)->info.ptr_info\n-\t  ? VN_INFO (name)->info.ptr_info\n-\t  : SSA_NAME_PTR_INFO (name));\n-}\n \n #endif /* TREE_SSA_SCCVN_H  */"}]}