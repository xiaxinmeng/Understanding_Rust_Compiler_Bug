{"sha": "0c22e4415fe9e88acaa99e72d33f4500d557ce68", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGMyMmU0NDE1ZmU5ZTg4YWNhYTk5ZTcyZDMzZjQ1MDBkNTU3Y2U2OA==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-10T03:59:20Z"}, "committer": {"name": "Ian Lance Taylor", "email": "ian@gcc.gnu.org", "date": "2017-01-10T03:59:20Z"}, "message": "compiler, runtime: drop size arguments to hash/equal functions\n    \n    Drop the size arguments for the hash/equal functions stored in type\n    descriptors.  Types know what size they are.  To make this work,\n    generate hash/equal functions for types that can use an identity\n    comparison but are not a standard size and alignment.\n    \n    Drop the multiplications by 33 in the generated hash code and the\n    reflect package hash code.  They are not necessary since we started\n    passing a seed value around, as the seed includes the hash of the\n    earlier values.\n    \n    Copy the algorithms for standard types from the Go 1.7 runtime,\n    replacing the C functions.\n    \n    Reviewed-on: https://go-review.googlesource.com/34983\n\nFrom-SVN: r244256", "tree": {"sha": "ab834b9b0b4730baa18d49e3c47ae5033b722809", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/ab834b9b0b4730baa18d49e3c47ae5033b722809"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0c22e4415fe9e88acaa99e72d33f4500d557ce68", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c22e4415fe9e88acaa99e72d33f4500d557ce68", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0c22e4415fe9e88acaa99e72d33f4500d557ce68", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0c22e4415fe9e88acaa99e72d33f4500d557ce68/comments", "author": null, "committer": null, "parents": [{"sha": "8462d909a7439fb0bf7095144dbf36524c7e61ea", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8462d909a7439fb0bf7095144dbf36524c7e61ea", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8462d909a7439fb0bf7095144dbf36524c7e61ea"}], "stats": {"total": 998, "additions": 510, "deletions": 488}, "files": [{"sha": "73c4d30369631df70b0f34383023801567636427", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -1,4 +1,4 @@\n-189ea81cc758e000325fd6cca7882c252d33f8f0\n+f439989e483b7c2eada6ddcf6e730a791cce603f\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "da721030e88c40606123cd162ea1079067b276b9", "filename": "gcc/go/gofrontend/expressions.cc", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fexpressions.cc?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -5335,7 +5335,6 @@ Binary_expression::lower_array_comparison(Gogo* gogo,\n   Expression_list* args = new Expression_list();\n   args->push_back(this->operand_address(inserter, this->left_));\n   args->push_back(this->operand_address(inserter, this->right_));\n-  args->push_back(Expression::make_type_info(at, TYPE_INFO_SIZE));\n \n   Expression* ret = Expression::make_call(func, args, false, loc);\n "}, {"sha": "4e2d6b46ad0ce1b3d4badebd833d9bea8f17eced", "filename": "gcc/go/gofrontend/gogo.cc", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fgogo.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.cc?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -2343,15 +2343,15 @@ Gogo::clear_file_scope()\n // parse tree is lowered.\n \n void\n-Gogo::queue_specific_type_function(Type* type, Named_type* name,\n+Gogo::queue_specific_type_function(Type* type, Named_type* name, int64_t size,\n \t\t\t\t   const std::string& hash_name,\n \t\t\t\t   Function_type* hash_fntype,\n \t\t\t\t   const std::string& equal_name,\n \t\t\t\t   Function_type* equal_fntype)\n {\n   go_assert(!this->specific_type_functions_are_written_);\n   go_assert(!this->in_global_scope());\n-  Specific_type_function* tsf = new Specific_type_function(type, name,\n+  Specific_type_function* tsf = new Specific_type_function(type, name, size,\n \t\t\t\t\t\t\t   hash_name,\n \t\t\t\t\t\t\t   hash_fntype,\n \t\t\t\t\t\t\t   equal_name,\n@@ -2386,7 +2386,7 @@ Specific_type_functions::type(Type* t)\n     case Type::TYPE_NAMED:\n       {\n \tNamed_type* nt = t->named_type();\n-\tif (!t->compare_is_identity(this->gogo_) && t->is_comparable())\n+\tif (t->needs_specific_type_functions(this->gogo_))\n \t  t->type_functions(this->gogo_, nt, NULL, NULL, &hash_fn, &equal_fn);\n \n \t// If this is a struct type, we don't want to make functions\n@@ -2420,7 +2420,7 @@ Specific_type_functions::type(Type* t)\n \n     case Type::TYPE_STRUCT:\n     case Type::TYPE_ARRAY:\n-      if (!t->compare_is_identity(this->gogo_) && t->is_comparable())\n+      if (t->needs_specific_type_functions(this->gogo_))\n \tt->type_functions(this->gogo_, NULL, NULL, NULL, &hash_fn, &equal_fn);\n       break;\n \n@@ -2443,7 +2443,7 @@ Gogo::write_specific_type_functions()\n     {\n       Specific_type_function* tsf = this->specific_type_functions_.back();\n       this->specific_type_functions_.pop_back();\n-      tsf->type->write_specific_type_functions(this, tsf->name,\n+      tsf->type->write_specific_type_functions(this, tsf->name, tsf->size,\n \t\t\t\t\t       tsf->hash_name,\n \t\t\t\t\t       tsf->hash_fntype,\n \t\t\t\t\t       tsf->equal_name,"}, {"sha": "7c29828231f3afbccda483d7acba55ef0968a65b", "filename": "gcc/go/gofrontend/gogo.h", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Fgogo.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Fgogo.h?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -563,7 +563,7 @@ class Gogo\n   // used when a type-specific function is needed when not at the top\n   // level.\n   void\n-  queue_specific_type_function(Type* type, Named_type* name,\n+  queue_specific_type_function(Type* type, Named_type* name, int64_t size,\n \t\t\t       const std::string& hash_name,\n \t\t\t       Function_type* hash_fntype,\n \t\t\t       const std::string& equal_name,\n@@ -824,17 +824,18 @@ class Gogo\n   {\n     Type* type;\n     Named_type* name;\n+    int64_t size;\n     std::string hash_name;\n     Function_type* hash_fntype;\n     std::string equal_name;\n     Function_type* equal_fntype;\n \n-    Specific_type_function(Type* atype, Named_type* aname,\n+    Specific_type_function(Type* atype, Named_type* aname, int64_t asize,\n \t\t\t   const std::string& ahash_name,\n \t\t\t   Function_type* ahash_fntype,\n \t\t\t   const std::string& aequal_name,\n \t\t\t   Function_type* aequal_fntype)\n-      : type(atype), name(aname), hash_name(ahash_name),\n+      : type(atype), name(aname), size(asize), hash_name(ahash_name),\n \thash_fntype(ahash_fntype), equal_name(aequal_name),\n \tequal_fntype(aequal_fntype)\n     { }"}, {"sha": "0b394c96de73cbda207ef45708b6f225bca453d7", "filename": "gcc/go/gofrontend/types.cc", "status": "modified", "additions": 275, "deletions": 60, "changes": 335, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Ftypes.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.cc?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -1425,7 +1425,9 @@ Type::make_builtin_struct_type(int nfields, ...)\n \n   va_end(ap);\n \n-  return Type::make_struct_type(sfl, bloc);\n+  Struct_type* ret = Type::make_struct_type(sfl, bloc);\n+  ret->set_is_struct_incomparable();\n+  return ret;\n }\n \n // A list of builtin named types.\n@@ -1488,7 +1490,6 @@ Type::make_type_descriptor_type()\n       Typed_identifier_list *params = new Typed_identifier_list();\n       params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n       params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n-      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n       Typed_identifier_list* results = new Typed_identifier_list();\n       results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n@@ -1499,7 +1500,6 @@ Type::make_type_descriptor_type()\n       params = new Typed_identifier_list();\n       params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n       params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n-      params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n       results = new Typed_identifier_list();\n       results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n@@ -1578,6 +1578,51 @@ Type::make_type_descriptor_ptr_type()\n   return ret;\n }\n \n+// Return whether this type needs specially built type functions.\n+// This returns true for types that are comparable and either can not\n+// use an identity comparison, or are a non-standard size.\n+\n+bool\n+Type::needs_specific_type_functions(Gogo* gogo)\n+{\n+  if (!this->is_comparable())\n+    return false;\n+  if (!this->compare_is_identity(gogo))\n+    return true;\n+\n+  // We create a few predeclared types for type descriptors; they are\n+  // really just for the backend and don't need hash or equality\n+  // functions.\n+  Named_type* nt = this->named_type();\n+  if (nt != NULL && Linemap::is_predeclared_location(nt->location()))\n+    return false;\n+\n+  int64_t size, align;\n+  if (!this->backend_type_size(gogo, &size)\n+      || !this->backend_type_align(gogo, &align))\n+    {\n+      go_assert(saw_errors());\n+      return false;\n+    }\n+  // This switch matches the one in Type::type_functions.\n+  switch (size)\n+    {\n+    case 0:\n+    case 1:\n+    case 2:\n+      return align < 2;\n+    case 4:\n+      return align < 4;\n+    case 8:\n+      return align < 8;\n+    case 16:\n+      // 8, not 16, because of how runtime.memequal128 is written.\n+      return align < 8;\n+    default:\n+      return true;\n+    }\n+}\n+\n // Set *HASH_FN and *EQUAL_FN to the runtime functions which compute a\n // hash code for this type and which compare whether two values of\n // this type are equal.  If NAME is not NULL it is the name of this\n@@ -1610,7 +1655,6 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t  params->push_back(Typed_identifier(\"key\", unsafe_pointer_type,\n \t\t\t\t\t     bloc));\n \t  params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n-\t  params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n \t  Typed_identifier_list* results = new Typed_identifier_list();\n \t  results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n@@ -1624,7 +1668,6 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t\t\t\t\t     bloc));\n \t  params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type,\n \t\t\t\t\t     bloc));\n-\t  params->push_back(Typed_identifier(\"key_size\", uintptr_type, bloc));\n \n \t  Typed_identifier_list* results = new Typed_identifier_list();\n \t  results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(),\n@@ -1638,8 +1681,78 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n   const char* equal_fnname;\n   if (this->compare_is_identity(gogo))\n     {\n-      hash_fnname = \"runtime.memhash\";\n-      equal_fnname = \"__go_type_equal_identity\";\n+      int64_t size, align;\n+      if (!this->backend_type_size(gogo, &size)\n+\t  || !this->backend_type_align(gogo, &align))\n+\t{\n+\t  go_assert(saw_errors());\n+\t  return;\n+\t}\n+      bool build_functions = false;\n+      // This switch matches the one in Type::needs_specific_type_functions.\n+      // The alignment tests are because of the memequal functions,\n+      // which assume that the values are aligned as required for an\n+      // integer of that size.\n+      switch (size)\n+\t{\n+\tcase 0:\n+\t  hash_fnname = \"runtime.memhash0\";\n+\t  equal_fnname = \"runtime.memequal0\";\n+\t  break;\n+\tcase 1:\n+\t  hash_fnname = \"runtime.memhash8\";\n+\t  equal_fnname = \"runtime.memequal8\";\n+\t  break;\n+\tcase 2:\n+\t  if (align < 2)\n+\t    build_functions = true;\n+\t  else\n+\t    {\n+\t      hash_fnname = \"runtime.memhash16\";\n+\t      equal_fnname = \"runtime.memequal16\";\n+\t    }\n+\t  break;\n+\tcase 4:\n+\t  if (align < 4)\n+\t    build_functions = true;\n+\t  else\n+\t    {\n+\t      hash_fnname = \"runtime.memhash32\";\n+\t      equal_fnname = \"runtime.memequal32\";\n+\t    }\n+\t  break;\n+\tcase 8:\n+\t  if (align < 8)\n+\t    build_functions = true;\n+\t  else\n+\t    {\n+\t      hash_fnname = \"runtime.memhash64\";\n+\t      equal_fnname = \"runtime.memequal64\";\n+\t    }\n+\t  break;\n+\tcase 16:\n+\t  // 8, not 16, because of how runtime.memequal128 is written.\n+\t  if (align < 8)\n+\t    build_functions = true;\n+\t  else\n+\t    {\n+\t      hash_fnname = \"runtime.memhash128\";\n+\t      equal_fnname = \"runtime.memequal128\";\n+\t    }\n+\t  break;\n+\tdefault:\n+\t  build_functions = true;\n+\t  break;\n+\t}\n+      if (build_functions)\n+\t{\n+\t  // We don't have a built-in function for a type of this size\n+\t  // and alignment.  Build a function to use that calls the\n+\t  // generic hash/equality functions for identity, passing the size.\n+\t  this->specific_type_functions(gogo, name, size, hash_fntype,\n+\t\t\t\t\tequal_fntype, hash_fn, equal_fn);\n+\t  return;\n+\t}\n     }\n   else\n     {\n@@ -1661,26 +1774,48 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t  go_unreachable();\n \n \tcase Type::TYPE_FLOAT:\n-\t  hash_fnname = \"__go_type_hash_float\";\n-\t  equal_fnname = \"__go_type_equal_float\";\n+\t  switch (this->float_type()->bits())\n+\t    {\n+\t    case 32:\n+\t      hash_fnname = \"runtime.f32hash\";\n+\t      equal_fnname = \"runtime.f32equal\";\n+\t      break;\n+\t    case 64:\n+\t      hash_fnname = \"runtime.f64hash\";\n+\t      equal_fnname = \"runtime.f64equal\";\n+\t      break;\n+\t    default:\n+\t      go_unreachable();\n+\t    }\n \t  break;\n \n \tcase Type::TYPE_COMPLEX:\n-\t  hash_fnname = \"__go_type_hash_complex\";\n-\t  equal_fnname = \"__go_type_equal_complex\";\n+\t  switch (this->complex_type()->bits())\n+\t    {\n+\t    case 64:\n+\t      hash_fnname = \"runtime.c64hash\";\n+\t      equal_fnname = \"runtime.c64equal\";\n+\t      break;\n+\t    case 128:\n+\t      hash_fnname = \"runtime.c128hash\";\n+\t      equal_fnname = \"runtime.c128equal\";\n+\t      break;\n+\t    default:\n+\t      go_unreachable();\n+\t    }\n \t  break;\n \n \tcase Type::TYPE_STRING:\n-\t  hash_fnname = \"__go_type_hash_string\";\n-\t  equal_fnname = \"__go_type_equal_string\";\n+\t  hash_fnname = \"runtime.strhash\";\n+\t  equal_fnname = \"runtime.strequal\";\n \t  break;\n \n \tcase Type::TYPE_STRUCT:\n \t  {\n \t    // This is a struct which can not be compared using a\n \t    // simple identity function.  We need to build a function\n \t    // for comparison.\n-\t    this->specific_type_functions(gogo, name, hash_fntype,\n+\t    this->specific_type_functions(gogo, name, -1, hash_fntype,\n \t\t\t\t\t  equal_fntype, hash_fn, equal_fn);\n \t    return;\n \t  }\n@@ -1697,7 +1832,7 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \t      // This is an array which can not be compared using a\n \t      // simple identity function.  We need to build a\n \t      // function for comparison.\n-\t      this->specific_type_functions(gogo, name, hash_fntype,\n+\t      this->specific_type_functions(gogo, name, -1, hash_fntype,\n \t\t\t\t\t    equal_fntype, hash_fn, equal_fn);\n \t      return;\n \t    }\n@@ -1739,11 +1874,13 @@ Type::type_functions(Gogo* gogo, Named_type* name, Function_type* hash_fntype,\n \n Type::Type_functions Type::type_functions_table;\n \n-// Handle a type function which is specific to a type: a struct or\n-// array which can not use an identity comparison.\n+// Handle a type function which is specific to a type: if SIZE == -1,\n+// this is a struct or array that can not use an identity comparison.\n+// Otherwise, it is a type that uses an identity comparison but is not\n+// one of the standard supported sizes.\n \n void\n-Type::specific_type_functions(Gogo* gogo, Named_type* name,\n+Type::specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n \t\t\t      Function_type* hash_fntype,\n \t\t\t      Function_type* equal_fntype,\n \t\t\t      Named_object** hash_fn,\n@@ -1829,19 +1966,21 @@ Type::specific_type_functions(Gogo* gogo, Named_type* name,\n   if (!is_defined_elsewhere)\n     {\n       if (gogo->in_global_scope())\n-\tthis->write_specific_type_functions(gogo, name, hash_name, hash_fntype,\n-\t\t\t\t\t    equal_name, equal_fntype);\n+\tthis->write_specific_type_functions(gogo, name, size, hash_name,\n+\t\t\t\t\t    hash_fntype, equal_name,\n+\t\t\t\t\t    equal_fntype);\n       else\n-\tgogo->queue_specific_type_function(this, name, hash_name, hash_fntype,\n-\t\t\t\t\t   equal_name, equal_fntype);\n+\tgogo->queue_specific_type_function(this, name, size, hash_name,\n+\t\t\t\t\t   hash_fntype, equal_name,\n+\t\t\t\t\t   equal_fntype);\n     }\n }\n \n // Write the hash and equality functions for a type which needs to be\n // written specially.\n \n void\n-Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n+Type::write_specific_type_functions(Gogo* gogo, Named_type* name, int64_t size,\n \t\t\t\t    const std::string& hash_name,\n \t\t\t\t    Function_type* hash_fntype,\n \t\t\t\t    const std::string& equal_name,\n@@ -1862,7 +2001,9 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n   hash_fn->func_value()->set_is_type_specific_function();\n   gogo->start_block(bloc);\n \n-  if (name != NULL && name->real_type()->named_type() != NULL)\n+  if (size != -1)\n+    this->write_identity_hash(gogo, size);\n+  else if (name != NULL && name->real_type()->named_type() != NULL)\n     this->write_named_hash(gogo, name, hash_fntype, equal_fntype);\n   else if (this->struct_type() != NULL)\n     this->struct_type()->write_hash_function(gogo, name, hash_fntype,\n@@ -1883,7 +2024,9 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n   equal_fn->func_value()->set_is_type_specific_function();\n   gogo->start_block(bloc);\n \n-  if (name != NULL && name->real_type()->named_type() != NULL)\n+  if (size != -1)\n+    this->write_identity_equal(gogo, size);\n+  else if (name != NULL && name->real_type()->named_type() != NULL)\n     this->write_named_equal(gogo, name);\n   else if (this->struct_type() != NULL)\n     this->struct_type()->write_equal_function(gogo, name);\n@@ -1902,6 +2045,112 @@ Type::write_specific_type_functions(Gogo* gogo, Named_type* name,\n   equal_fn->func_value()->descriptor(gogo, equal_fn);\n }\n \n+// Write a hash function for a type that can use an identity hash but\n+// is not one of the standard supported sizes.  For example, this\n+// would be used for the type [3]byte.  This builds a return statement\n+// that returns a call to the memhash function, passing the key and\n+// seed from the function arguments (already constructed before this\n+// is called), and the constant size.\n+\n+void\n+Type::write_identity_hash(Gogo* gogo, int64_t size)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  Typed_identifier_list* params = new Typed_identifier_list();\n+  params->push_back(Typed_identifier(\"key\", unsafe_pointer_type, bloc));\n+  params->push_back(Typed_identifier(\"seed\", uintptr_type, bloc));\n+  params->push_back(Typed_identifier(\"size\", uintptr_type, bloc));\n+\n+  Typed_identifier_list* results = new Typed_identifier_list();\n+  results->push_back(Typed_identifier(\"\", uintptr_type, bloc));\n+\n+  Function_type* memhash_fntype = Type::make_function_type(NULL, params,\n+\t\t\t\t\t\t\t   results, bloc);\n+\n+  Named_object* memhash =\n+    Named_object::make_function_declaration(\"runtime.memhash\", NULL,\n+\t\t\t\t\t    memhash_fntype, bloc);\n+  memhash->func_declaration_value()->set_asm_name(\"runtime.memhash\");\n+\n+  Named_object* key_arg = gogo->lookup(\"key\", NULL);\n+  go_assert(key_arg != NULL);\n+  Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n+  go_assert(seed_arg != NULL);\n+\n+  Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n+  Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n+  Expression* size_arg = Expression::make_integer_int64(size, uintptr_type,\n+\t\t\t\t\t\t\tbloc);\n+  Expression_list* args = new Expression_list();\n+  args->push_back(key_ref);\n+  args->push_back(seed_ref);\n+  args->push_back(size_arg);\n+  Expression* func = Expression::make_func_reference(memhash, NULL, bloc);\n+  Expression* call = Expression::make_call(func, args, false, bloc);\n+\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(call);\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n+// Write an equality function for a type that can use an identity\n+// equality comparison but is not one of the standard supported sizes.\n+// For example, this would be used for the type [3]byte.  This builds\n+// a return statement that returns a call to the memequal function,\n+// passing the two keys from the function arguments (already\n+// constructed before this is called), and the constant size.\n+\n+void\n+Type::write_identity_equal(Gogo* gogo, int64_t size)\n+{\n+  Location bloc = Linemap::predeclared_location();\n+\n+  Type* unsafe_pointer_type = Type::make_pointer_type(Type::make_void_type());\n+  Type* uintptr_type = Type::lookup_integer_type(\"uintptr\");\n+\n+  Typed_identifier_list* params = new Typed_identifier_list();\n+  params->push_back(Typed_identifier(\"key1\", unsafe_pointer_type, bloc));\n+  params->push_back(Typed_identifier(\"key2\", unsafe_pointer_type, bloc));\n+  params->push_back(Typed_identifier(\"size\", uintptr_type, bloc));\n+\n+  Typed_identifier_list* results = new Typed_identifier_list();\n+  results->push_back(Typed_identifier(\"\", Type::lookup_bool_type(), bloc));\n+\n+  Function_type* memequal_fntype = Type::make_function_type(NULL, params,\n+\t\t\t\t\t\t\t    results, bloc);\n+\n+  Named_object* memequal =\n+    Named_object::make_function_declaration(\"runtime.memequal\", NULL,\n+\t\t\t\t\t    memequal_fntype, bloc);\n+  memequal->func_declaration_value()->set_asm_name(\"runtime.memequal\");\n+\n+  Named_object* key1_arg = gogo->lookup(\"key1\", NULL);\n+  go_assert(key1_arg != NULL);\n+  Named_object* key2_arg = gogo->lookup(\"key2\", NULL);\n+  go_assert(key2_arg != NULL);\n+\n+  Expression* key1_ref = Expression::make_var_reference(key1_arg, bloc);\n+  Expression* key2_ref = Expression::make_var_reference(key2_arg, bloc);\n+  Expression* size_arg = Expression::make_integer_int64(size, uintptr_type,\n+\t\t\t\t\t\t\tbloc);\n+  Expression_list* args = new Expression_list();\n+  args->push_back(key1_ref);\n+  args->push_back(key2_ref);\n+  args->push_back(size_arg);\n+  Expression* func = Expression::make_func_reference(memequal, NULL, bloc);\n+  Expression* call = Expression::make_call(func, args, false, bloc);\n+\n+  Expression_list* vals = new Expression_list();\n+  vals->push_back(call);\n+  Statement* s = Statement::make_return_statement(vals, bloc);\n+  gogo->add_statement(s);\n+}\n+\n // Write a hash function that simply calls the hash function for a\n // named type.  This is used when one named type is defined as\n // another.  This ensures that this case works when the other named\n@@ -1926,10 +2175,6 @@ Type::write_named_hash(Gogo* gogo, Named_type* name,\n   Named_object* seed_arg = gogo->lookup(\"seed\", NULL);\n   go_assert(seed_arg != NULL);\n \n-  // The size of the type we are going to hash.\n-  Named_object* keysz_arg = gogo->lookup(\"key_size\", NULL);\n-  go_assert(keysz_arg != NULL);\n-\n   Named_object* hash_fn;\n   Named_object* equal_fn;\n   name->real_type()->type_functions(gogo, base_type, hash_fntype, equal_fntype,\n@@ -1938,11 +2183,9 @@ Type::write_named_hash(Gogo* gogo, Named_type* name,\n   // Call the hash function for the base type.\n   Expression* key_ref = Expression::make_var_reference(key_arg, bloc);\n   Expression* seed_ref = Expression::make_var_reference(seed_arg, bloc);\n-  Expression* keysz_ref = Expression::make_var_reference(keysz_arg, bloc);\n   Expression_list* args = new Expression_list();\n   args->push_back(key_ref);\n   args->push_back(seed_ref);\n-  args->push_back(keysz_ref);\n   Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n   Expression* call = Expression::make_call(func, args, false, bloc);\n \n@@ -5410,7 +5653,6 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n   gogo->add_statement(key);\n \n   // Loop over the struct fields.\n-  bool first = true;\n   const Struct_field_list* fields = this->fields_;\n   for (Struct_field_list::const_iterator pf = fields->begin();\n        pf != fields->end();\n@@ -5419,30 +5661,13 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n       if (Gogo::is_sink_name(pf->field_name()))\n \tcontinue;\n \n-      if (first)\n-\tfirst = false;\n-      else\n-\t{\n-\t  // Multiply retval by 33.\n-\t  Expression* i33 = Expression::make_integer_ul(33, uintptr_type,\n-\t\t\t\t\t\t\tbloc);\n-\t  ref = Expression::make_temporary_reference(retval, bloc);\n-\t  Statement* s = Statement::make_assignment_operation(OPERATOR_MULTEQ,\n-\t\t\t\t\t\t\t      ref, i33, bloc);\n-\t  gogo->add_statement(s);\n-\t}\n-\n       // Get a pointer to the value of this field.\n       Expression* offset = Expression::make_struct_field_offset(this, &*pf);\n       ref = Expression::make_temporary_reference(key, bloc);\n       Expression* subkey = Expression::make_binary(OPERATOR_PLUS, ref, offset,\n \t\t\t\t\t\t   bloc);\n       subkey = Expression::make_cast(key_arg_type, subkey, bloc);\n \n-      // Get the size of this field.\n-      Expression* size = Expression::make_type_info(pf->type(),\n-\t\t\t\t\t\t    Expression::TYPE_INFO_SIZE);\n-\n       // Get the hash function to use for the type of this field.\n       Named_object* hash_fn;\n       Named_object* equal_fn;\n@@ -5454,7 +5679,6 @@ Struct_type::write_hash_function(Gogo* gogo, Named_type*,\n       Expression_list* args = new Expression_list();\n       args->push_back(subkey);\n       args->push_back(ref);\n-      args->push_back(size);\n       Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n       Expression* call = Expression::make_call(func, args, false, bloc);\n \n@@ -6295,14 +6519,6 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n \n   gogo->start_block(bloc);\n \n-  // Multiply retval by 33.\n-  Expression* i33 = Expression::make_integer_ul(33, uintptr_type, bloc);\n-\n-  ref = Expression::make_temporary_reference(retval, bloc);\n-  Statement* s = Statement::make_assignment_operation(OPERATOR_MULTEQ, ref,\n-\t\t\t\t\t\t      i33, bloc);\n-  gogo->add_statement(s);\n-\n   // Get the hash function for the element type.\n   Named_object* hash_fn;\n   Named_object* equal_fn;\n@@ -6323,15 +6539,14 @@ Array_type::write_hash_function(Gogo* gogo, Named_type* name,\n   Expression_list* args = new Expression_list();\n   args->push_back(subkey);\n   args->push_back(ref);\n-  args->push_back(ele_size);\n   Expression* func = Expression::make_func_reference(hash_fn, NULL, bloc);\n   Expression* call = Expression::make_call(func, args, false, bloc);\n \n   // Set retval to the result.\n   Temporary_reference_expression* tref =\n     Expression::make_temporary_reference(retval, bloc);\n   tref->set_is_lvalue();\n-  s = Statement::make_assignment(tref, call, bloc);\n+  Statement* s = Statement::make_assignment(tref, call, bloc);\n   gogo->add_statement(s);\n \n   // Increase the element pointer."}, {"sha": "e9c31628ec13cf83723cdfd08c0d5417982cee7f", "filename": "gcc/go/gofrontend/types.h", "status": "modified", "additions": 13, "deletions": 2, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/gcc%2Fgo%2Fgofrontend%2Ftypes.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2Ftypes.h?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -975,6 +975,10 @@ class Type\n   bool\n   is_backend_type_size_known(Gogo*);\n \n+  // Return whether the type needs specially built type functions.\n+  bool\n+  needs_specific_type_functions(Gogo*);\n+\n   // Get the hash and equality functions for a type.\n   void\n   type_functions(Gogo*, Named_type* name, Function_type* hash_fntype,\n@@ -983,7 +987,7 @@ class Type\n \n   // Write the hash and equality type functions.\n   void\n-  write_specific_type_functions(Gogo*, Named_type*,\n+  write_specific_type_functions(Gogo*, Named_type*, int64_t size,\n \t\t\t\tconst std::string& hash_name,\n \t\t\t\tFunction_type* hash_fntype,\n \t\t\t\tconst std::string& equal_name,\n@@ -1206,10 +1210,17 @@ class Type\n   // Build the hash and equality type functions for a type which needs\n   // specific functions.\n   void\n-  specific_type_functions(Gogo*, Named_type*, Function_type* hash_fntype,\n+  specific_type_functions(Gogo*, Named_type*, int64_t size,\n+\t\t\t  Function_type* hash_fntype,\n \t\t\t  Function_type* equal_fntype, Named_object** hash_fn,\n \t\t\t  Named_object** equal_fn);\n \n+  void\n+  write_identity_hash(Gogo*, int64_t size);\n+\n+  void\n+  write_identity_equal(Gogo*, int64_t size);\n+\n   void\n   write_named_hash(Gogo*, Named_type*, Function_type* hash_fntype,\n \t\t   Function_type* equal_fntype);"}, {"sha": "fed411177167b060a1040ab799890550ccc7ca92", "filename": "libgo/Makefile.am", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -446,10 +446,6 @@ runtime_files = \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strslice.c \\\n-\truntime/go-type-complex.c \\\n-\truntime/go-type-float.c \\\n-\truntime/go-type-identity.c \\\n-\truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\"}, {"sha": "581607a96c4d36383dc51754f41301f347b9bec8", "filename": "libgo/Makefile.in", "status": "modified", "additions": 6, "deletions": 43, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -196,13 +196,12 @@ am__objects_5 = aeshash.lo go-assert.lo go-breakpoint.lo go-caller.lo \\\n \tgo-memcmp.lo go-memequal.lo go-memmove.lo go-nanotime.lo \\\n \tgo-now.lo go-new.lo go-nosys.lo go-reflect-call.lo \\\n \tgo-runtime-error.lo go-setenv.lo go-signal.lo go-strslice.lo \\\n-\tgo-type-complex.lo go-type-float.lo go-type-identity.lo \\\n-\tgo-type-string.lo go-typedesc-equal.lo go-unsafe-new.lo \\\n-\tgo-unsafe-newarray.lo go-unsafe-pointer.lo go-unsetenv.lo \\\n-\tgo-unwind.lo go-varargs.lo env_posix.lo heapdump.lo mcache.lo \\\n-\tmcentral.lo $(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo \\\n-\tmsize.lo panic.lo parfor.lo print.lo proc.lo runtime_c.lo \\\n-\tthread.lo $(am__objects_2) yield.lo $(am__objects_3) malloc.lo \\\n+\tgo-typedesc-equal.lo go-unsafe-new.lo go-unsafe-newarray.lo \\\n+\tgo-unsafe-pointer.lo go-unsetenv.lo go-unwind.lo go-varargs.lo \\\n+\tenv_posix.lo heapdump.lo mcache.lo mcentral.lo \\\n+\t$(am__objects_1) mfixalloc.lo mgc0.lo mheap.lo msize.lo \\\n+\tpanic.lo parfor.lo print.lo proc.lo runtime_c.lo thread.lo \\\n+\t$(am__objects_2) yield.lo $(am__objects_3) malloc.lo \\\n \t$(am__objects_4)\n am_libgo_llgo_la_OBJECTS = $(am__objects_5)\n libgo_llgo_la_OBJECTS = $(am_libgo_llgo_la_OBJECTS)\n@@ -793,10 +792,6 @@ runtime_files = \\\n \truntime/go-setenv.c \\\n \truntime/go-signal.c \\\n \truntime/go-strslice.c \\\n-\truntime/go-type-complex.c \\\n-\truntime/go-type-float.c \\\n-\truntime/go-type-identity.c \\\n-\truntime/go-type-string.c \\\n \truntime/go-typedesc-equal.c \\\n \truntime/go-unsafe-new.c \\\n \truntime/go-unsafe-newarray.c \\\n@@ -1479,10 +1474,6 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-setenv.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-signal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-strslice.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-complex.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-float.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-identity.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-type-string.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-typedesc-equal.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-new.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/go-unsafe-newarray.Plo@am__quote@\n@@ -1745,34 +1736,6 @@ go-strslice.lo: runtime/go-strslice.c\n @AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n @am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-strslice.lo `test -f 'runtime/go-strslice.c' || echo '$(srcdir)/'`runtime/go-strslice.c\n \n-go-type-complex.lo: runtime/go-type-complex.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-complex.lo -MD -MP -MF $(DEPDIR)/go-type-complex.Tpo -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-complex.Tpo $(DEPDIR)/go-type-complex.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-complex.c' object='go-type-complex.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-complex.lo `test -f 'runtime/go-type-complex.c' || echo '$(srcdir)/'`runtime/go-type-complex.c\n-\n-go-type-float.lo: runtime/go-type-float.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-float.lo -MD -MP -MF $(DEPDIR)/go-type-float.Tpo -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-float.Tpo $(DEPDIR)/go-type-float.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-float.c' object='go-type-float.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-float.lo `test -f 'runtime/go-type-float.c' || echo '$(srcdir)/'`runtime/go-type-float.c\n-\n-go-type-identity.lo: runtime/go-type-identity.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-identity.lo -MD -MP -MF $(DEPDIR)/go-type-identity.Tpo -c -o go-type-identity.lo `test -f 'runtime/go-type-identity.c' || echo '$(srcdir)/'`runtime/go-type-identity.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-identity.Tpo $(DEPDIR)/go-type-identity.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-identity.c' object='go-type-identity.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-identity.lo `test -f 'runtime/go-type-identity.c' || echo '$(srcdir)/'`runtime/go-type-identity.c\n-\n-go-type-string.lo: runtime/go-type-string.c\n-@am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-type-string.lo -MD -MP -MF $(DEPDIR)/go-type-string.Tpo -c -o go-type-string.lo `test -f 'runtime/go-type-string.c' || echo '$(srcdir)/'`runtime/go-type-string.c\n-@am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-type-string.Tpo $(DEPDIR)/go-type-string.Plo\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tsource='runtime/go-type-string.c' object='go-type-string.lo' libtool=yes @AMDEPBACKSLASH@\n-@AMDEP_TRUE@@am__fastdepCC_FALSE@\tDEPDIR=$(DEPDIR) $(CCDEPMODE) $(depcomp) @AMDEPBACKSLASH@\n-@am__fastdepCC_FALSE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -c -o go-type-string.lo `test -f 'runtime/go-type-string.c' || echo '$(srcdir)/'`runtime/go-type-string.c\n-\n go-typedesc-equal.lo: runtime/go-typedesc-equal.c\n @am__fastdepCC_TRUE@\t$(LIBTOOL)  --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) --mode=compile $(CC) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(AM_CPPFLAGS) $(CPPFLAGS) $(AM_CFLAGS) $(CFLAGS) -MT go-typedesc-equal.lo -MD -MP -MF $(DEPDIR)/go-typedesc-equal.Tpo -c -o go-typedesc-equal.lo `test -f 'runtime/go-typedesc-equal.c' || echo '$(srcdir)/'`runtime/go-typedesc-equal.c\n @am__fastdepCC_TRUE@\t$(am__mv) $(DEPDIR)/go-typedesc-equal.Tpo $(DEPDIR)/go-typedesc-equal.Plo"}, {"sha": "4f13f144327f00ac230b15baa8263fc5936e3945", "filename": "libgo/go/reflect/type.go", "status": "modified", "additions": 11, "deletions": 15, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Freflect%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Freflect%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Freflect%2Ftype.go?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -254,8 +254,8 @@ type rtype struct {\n \tsize       uintptr\n \thash       uint32 // hash of type; avoids computation in hash tables\n \n-\thashfn  func(unsafe.Pointer, uintptr, uintptr) uintptr     // hash function\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool // equality function\n+\thashfn  func(unsafe.Pointer, uintptr) uintptr     // hash function\n+\tequalfn func(unsafe.Pointer, unsafe.Pointer) bool // equality function\n \n \tgc            unsafe.Pointer // garbage collection data\n \tstring        *string        // string form; unnecessary  but undeniably useful\n@@ -2203,23 +2203,20 @@ func StructOf(fields []StructField) Type {\n \t\ttyp.gc = unsafe.Pointer(&gc[0])\n \t}\n \n-\ttyp.hashfn = func(p unsafe.Pointer, seed, size uintptr) uintptr {\n+\ttyp.hashfn = func(p unsafe.Pointer, seed uintptr) uintptr {\n \t\tret := seed\n-\t\tfor i, ft := range typ.fields {\n-\t\t\tif i > 0 {\n-\t\t\t\tret *= 33\n-\t\t\t}\n+\t\tfor _, ft := range typ.fields {\n \t\t\to := unsafe.Pointer(uintptr(p) + ft.offset)\n-\t\t\tret = ft.typ.hashfn(o, ret, ft.typ.size)\n+\t\t\tret = ft.typ.hashfn(o, ret)\n \t\t}\n \t\treturn ret\n \t}\n \n-\ttyp.equalfn = func(p, q unsafe.Pointer, size uintptr) bool {\n+\ttyp.equalfn = func(p, q unsafe.Pointer) bool {\n \t\tfor _, ft := range typ.fields {\n \t\t\tpi := unsafe.Pointer(uintptr(p) + ft.offset)\n \t\t\tqi := unsafe.Pointer(uintptr(q) + ft.offset)\n-\t\t\tif !ft.typ.equalfn(pi, qi, ft.typ.size) {\n+\t\t\tif !ft.typ.equalfn(pi, qi) {\n \t\t\t\treturn false\n \t\t\t}\n \t\t}\n@@ -2348,19 +2345,18 @@ func ArrayOf(count int, elem Type) Type {\n \n \tarray.kind &^= kindDirectIface\n \n-\tarray.hashfn = func(p unsafe.Pointer, seed, size uintptr) uintptr {\n+\tarray.hashfn = func(p unsafe.Pointer, seed uintptr) uintptr {\n \t\tret := seed\n \t\tfor i := 0; i < count; i++ {\n-\t\t\tret *= 33\n-\t\t\tret = typ.hashfn(p, ret, typ.size)\n+\t\t\tret = typ.hashfn(p, ret)\n \t\t\tp = unsafe.Pointer(uintptr(p) + typ.size)\n \t\t}\n \t\treturn ret\n \t}\n \n-\tarray.equalfn = func(p1, p2 unsafe.Pointer, size uintptr) bool {\n+\tarray.equalfn = func(p1, p2 unsafe.Pointer) bool {\n \t\tfor i := 0; i < count; i++ {\n-\t\t\tif !typ.equalfn(p1, p2, typ.size) {\n+\t\t\tif !typ.equalfn(p1, p2) {\n \t\t\t\treturn false\n \t\t\t}\n \t\t\tp1 = unsafe.Pointer(uintptr(p1) + typ.size)"}, {"sha": "426b7f6bab394d5d122cdd3ecf0bde7fb562ece2", "filename": "libgo/go/runtime/alg.go", "status": "modified", "additions": 163, "deletions": 14, "changes": 177, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Falg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Falg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Falg.go?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -12,8 +12,30 @@ import (\n // For gccgo, use go:linkname to rename compiler-called functions to\n // themselves, so that the compiler will export them.\n //\n+//go:linkname memhash0 runtime.memhash0\n+//go:linkname memhash8 runtime.memhash8\n+//go:linkname memhash16 runtime.memhash16\n+//go:linkname memhash32 runtime.memhash32\n+//go:linkname memhash64 runtime.memhash64\n+//go:linkname memhash128 runtime.memhash128\n+//go:linkname strhash runtime.strhash\n+//go:linkname f32hash runtime.f32hash\n+//go:linkname f64hash runtime.f64hash\n+//go:linkname c64hash runtime.c64hash\n+//go:linkname c128hash runtime.c128hash\n //go:linkname interhash runtime.interhash\n //go:linkname nilinterhash runtime.nilinterhash\n+//go:linkname memequal0 runtime.memequal0\n+//go:linkname memequal8 runtime.memequal8\n+//go:linkname memequal16 runtime.memequal16\n+//go:linkname memequal32 runtime.memequal32\n+//go:linkname memequal64 runtime.memequal64\n+//go:linkname memequal128 runtime.memequal128\n+//go:linkname strequal runtime.strequal\n+//go:linkname f32equal runtime.f32equal\n+//go:linkname f64equal runtime.f64equal\n+//go:linkname c64equal runtime.c64equal\n+//go:linkname c128equal runtime.c128equal\n //go:linkname interequal runtime.interequal\n //go:linkname nilinterequal runtime.nilinterequal\n //go:linkname efaceeq runtime.efaceeq\n@@ -32,6 +54,25 @@ const (\n \tc1 = uintptr((8-sys.PtrSize)/4*3267000013 + (sys.PtrSize-4)/4*23344194077549503)\n )\n \n+func memhash0(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn h\n+}\n+func memhash8(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, 1)\n+}\n+func memhash16(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, 2)\n+}\n+func memhash32(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, 4)\n+}\n+func memhash64(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, 8)\n+}\n+func memhash128(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, 16)\n+}\n+\n var useAeshash bool\n \n // in C code\n@@ -46,6 +87,50 @@ func aeshashstr(p unsafe.Pointer, h uintptr) uintptr {\n \treturn aeshashbody(unsafe.Pointer(ps.str), h, uintptr(ps.len), aeskeysched[:])\n }\n \n+func strhash(a unsafe.Pointer, h uintptr) uintptr {\n+\tx := (*stringStruct)(a)\n+\treturn memhash(x.str, h, uintptr(x.len))\n+}\n+\n+// NOTE: Because NaN != NaN, a map can contain any\n+// number of (mostly useless) entries keyed with NaNs.\n+// To avoid long hash chains, we assign a random number\n+// as the hash value for a NaN.\n+\n+func f32hash(p unsafe.Pointer, h uintptr) uintptr {\n+\tf := *(*float32)(p)\n+\tswitch {\n+\tcase f == 0:\n+\t\treturn c1 * (c0 ^ h) // +0, -0\n+\tcase f != f:\n+\t\treturn c1 * (c0 ^ h ^ uintptr(fastrand1())) // any kind of NaN\n+\tdefault:\n+\t\treturn memhash(p, h, 4)\n+\t}\n+}\n+\n+func f64hash(p unsafe.Pointer, h uintptr) uintptr {\n+\tf := *(*float64)(p)\n+\tswitch {\n+\tcase f == 0:\n+\t\treturn c1 * (c0 ^ h) // +0, -0\n+\tcase f != f:\n+\t\treturn c1 * (c0 ^ h ^ uintptr(fastrand1())) // any kind of NaN\n+\tdefault:\n+\t\treturn memhash(p, h, 8)\n+\t}\n+}\n+\n+func c64hash(p unsafe.Pointer, h uintptr) uintptr {\n+\tx := (*[2]float32)(p)\n+\treturn f32hash(unsafe.Pointer(&x[1]), f32hash(unsafe.Pointer(&x[0]), h))\n+}\n+\n+func c128hash(p unsafe.Pointer, h uintptr) uintptr {\n+\tx := (*[2]float64)(p)\n+\treturn f64hash(unsafe.Pointer(&x[1]), f64hash(unsafe.Pointer(&x[0]), h))\n+}\n+\n func interhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n \ta := (*iface)(p)\n \ttab := a.tab\n@@ -58,13 +143,13 @@ func interhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n \t\tpanic(errorString(\"hash of unhashable type \" + *t.string))\n \t}\n \tif isDirectIface(t) {\n-\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0, t.size)\n+\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0)\n \t} else {\n-\t\treturn c1 * fn(a.data, h^c0, t.size)\n+\t\treturn c1 * fn(a.data, h^c0)\n \t}\n }\n \n-func nilinterhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n+func nilinterhash(p unsafe.Pointer, h uintptr) uintptr {\n \ta := (*eface)(p)\n \tt := a._type\n \tif t == nil {\n@@ -75,20 +160,51 @@ func nilinterhash(p unsafe.Pointer, h uintptr, size uintptr) uintptr {\n \t\tpanic(errorString(\"hash of unhashable type \" + *t.string))\n \t}\n \tif isDirectIface(t) {\n-\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0, t.size)\n+\t\treturn c1 * fn(unsafe.Pointer(&a.data), h^c0)\n \t} else {\n-\t\treturn c1 * fn(a.data, h^c0, t.size)\n+\t\treturn c1 * fn(a.data, h^c0)\n \t}\n }\n \n+func memequal0(p, q unsafe.Pointer) bool {\n+\treturn true\n+}\n+func memequal8(p, q unsafe.Pointer) bool {\n+\treturn *(*int8)(p) == *(*int8)(q)\n+}\n+func memequal16(p, q unsafe.Pointer) bool {\n+\treturn *(*int16)(p) == *(*int16)(q)\n+}\n+func memequal32(p, q unsafe.Pointer) bool {\n+\treturn *(*int32)(p) == *(*int32)(q)\n+}\n+func memequal64(p, q unsafe.Pointer) bool {\n+\treturn *(*int64)(p) == *(*int64)(q)\n+}\n+func memequal128(p, q unsafe.Pointer) bool {\n+\treturn *(*[2]int64)(p) == *(*[2]int64)(q)\n+}\n+func f32equal(p, q unsafe.Pointer) bool {\n+\treturn *(*float32)(p) == *(*float32)(q)\n+}\n+func f64equal(p, q unsafe.Pointer) bool {\n+\treturn *(*float64)(p) == *(*float64)(q)\n+}\n+func c64equal(p, q unsafe.Pointer) bool {\n+\treturn *(*complex64)(p) == *(*complex64)(q)\n+}\n+func c128equal(p, q unsafe.Pointer) bool {\n+\treturn *(*complex128)(p) == *(*complex128)(q)\n+}\n+func strequal(p, q unsafe.Pointer) bool {\n+\treturn *(*string)(p) == *(*string)(q)\n+}\n func interequal(p, q unsafe.Pointer, size uintptr) bool {\n \treturn ifaceeq(*(*iface)(p), *(*iface)(q))\n }\n-\n func nilinterequal(p, q unsafe.Pointer, size uintptr) bool {\n \treturn efaceeq(*(*eface)(p), *(*eface)(q))\n }\n-\n func efaceeq(x, y eface) bool {\n \tt := x._type\n \tif !eqtype(t, y._type) {\n@@ -104,9 +220,8 @@ func efaceeq(x, y eface) bool {\n \tif isDirectIface(t) {\n \t\treturn x.data == y.data\n \t}\n-\treturn eq(x.data, y.data, t.size)\n+\treturn eq(x.data, y.data)\n }\n-\n func ifaceeq(x, y iface) bool {\n \txtab := x.tab\n \tif xtab == nil && y.tab == nil {\n@@ -126,7 +241,7 @@ func ifaceeq(x, y iface) bool {\n \tif isDirectIface(t) {\n \t\treturn x.data == y.data\n \t}\n-\treturn eq(x.data, y.data, t.size)\n+\treturn eq(x.data, y.data)\n }\n \n func ifacevaleq(x iface, t *_type, p unsafe.Pointer) bool {\n@@ -144,7 +259,7 @@ func ifacevaleq(x iface, t *_type, p unsafe.Pointer) bool {\n \tif isDirectIface(t) {\n \t\treturn x.data == p\n \t}\n-\treturn eq(x.data, p, t.size)\n+\treturn eq(x.data, p)\n }\n \n func ifaceefaceeq(x iface, y eface) bool {\n@@ -165,7 +280,7 @@ func ifaceefaceeq(x iface, y eface) bool {\n \tif isDirectIface(xt) {\n \t\treturn x.data == y.data\n \t}\n-\treturn eq(x.data, y.data, xt.size)\n+\treturn eq(x.data, y.data)\n }\n \n func efacevaleq(x eface, t *_type, p unsafe.Pointer) bool {\n@@ -182,7 +297,7 @@ func efacevaleq(x eface, t *_type, p unsafe.Pointer) bool {\n \tif isDirectIface(t) {\n \t\treturn x.data == p\n \t}\n-\treturn eq(x.data, p, t.size)\n+\treturn eq(x.data, p)\n }\n \n func eqstring(x, y string) bool {\n@@ -213,13 +328,47 @@ func cmpstring(x, y string) int {\n \treturn 0\n }\n \n+// For the unsafe.Pointer type descriptor in libgo/runtime/go-unsafe-pointer.c.\n+\n+func pointerhash(p unsafe.Pointer, h uintptr) uintptr {\n+\treturn memhash(p, h, unsafe.Sizeof(unsafe.Pointer))\n+}\n+\n+func pointerequal(p, q unsafe.Pointer) bool {\n+\treturn *(*unsafe.Pointer)(p) == *(*unsafe.Pointer)(q)\n+}\n+\n // Force the creation of function descriptors for equality and hash\n // functions.  These will be referenced directly by the compiler.\n var _ = memhash\n+var _ = memhash0\n+var _ = memhash8\n+var _ = memhash16\n+var _ = memhash32\n+var _ = memhash64\n+var _ = memhash128\n+var _ = strhash\n+var _ = f32hash\n+var _ = f64hash\n+var _ = c64hash\n+var _ = c128hash\n var _ = interhash\n-var _ = interequal\n var _ = nilinterhash\n+var _ = memequal0\n+var _ = memequal8\n+var _ = memequal16\n+var _ = memequal32\n+var _ = memequal64\n+var _ = memequal128\n+var _ = f32equal\n+var _ = f64equal\n+var _ = c64equal\n+var _ = c128equal\n+var _ = strequal\n+var _ = interequal\n var _ = nilinterequal\n+var _ = pointerhash\n+var _ = pointerequal\n \n const hashRandomBytes = sys.PtrSize / 4 * 64\n "}, {"sha": "77b33f341f711963d60d59883ba131bcef383461", "filename": "libgo/go/runtime/hashmap.go", "status": "modified", "additions": 15, "deletions": 15, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Fhashmap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Fhashmap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap.go?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -300,7 +300,7 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \t}\n \thashfn := t.key.hashfn\n \tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\thash := hashfn(key, uintptr(h.hash0))\n \tm := uintptr(1)<<h.B - 1\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -322,7 +322,7 @@ func mapaccess1(t *maptype, h *hmap, key unsafe.Pointer) unsafe.Pointer {\n \t\t\tif t.indirectkey {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n \t\t\t\tif t.indirectvalue {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n@@ -355,7 +355,7 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \t}\n \thashfn := t.key.hashfn\n \tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\thash := hashfn(key, uintptr(h.hash0))\n \tm := uintptr(1)<<h.B - 1\n \tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -377,7 +377,7 @@ func mapaccess2(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, bool)\n \t\t\tif t.indirectkey {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n \t\t\t\tif t.indirectvalue {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n@@ -402,7 +402,7 @@ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe\n \t}\n \thashfn := t.key.hashfn\n \tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\thash := hashfn(key, uintptr(h.hash0))\n \tm := uintptr(1)<<h.B - 1\n \tb := (*bmap)(unsafe.Pointer(uintptr(h.buckets) + (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -424,7 +424,7 @@ func mapaccessK(t *maptype, h *hmap, key unsafe.Pointer) (unsafe.Pointer, unsafe\n \t\t\tif t.indirectkey {\n \t\t\t\tk = *((*unsafe.Pointer)(k))\n \t\t\t}\n-\t\t\tif equalfn(key, k, uintptr(t.keysize)) {\n+\t\t\tif equalfn(key, k) {\n \t\t\t\tv := add(unsafe.Pointer(b), dataOffset+bucketCnt*uintptr(t.keysize)+i*uintptr(t.valuesize))\n \t\t\t\tif t.indirectvalue {\n \t\t\t\t\tv = *((*unsafe.Pointer)(v))\n@@ -477,7 +477,7 @@ func mapassign1(t *maptype, h *hmap, key unsafe.Pointer, val unsafe.Pointer) {\n \n \thashfn := t.key.hashfn\n \tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\thash := hashfn(key, uintptr(h.hash0))\n \n \tif h.buckets == nil {\n \t\th.buckets = newarray(t.bucket, 1)\n@@ -512,7 +512,7 @@ again:\n \t\t\tif t.indirectkey {\n \t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t}\n-\t\t\tif !equalfn(key, k2, uintptr(t.keysize)) {\n+\t\t\tif !equalfn(key, k2) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\t// already have a mapping for key. Update it.\n@@ -592,7 +592,7 @@ func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n \n \thashfn := t.key.hashfn\n \tequalfn := t.key.equalfn\n-\thash := hashfn(key, uintptr(h.hash0), uintptr(t.keysize))\n+\thash := hashfn(key, uintptr(h.hash0))\n \tbucket := hash & (uintptr(1)<<h.B - 1)\n \tif h.oldbuckets != nil {\n \t\tgrowWork(t, h, bucket)\n@@ -612,7 +612,7 @@ func mapdelete(t *maptype, h *hmap, key unsafe.Pointer) {\n \t\t\tif t.indirectkey {\n \t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t}\n-\t\t\tif !equalfn(key, k2, uintptr(t.keysize)) {\n+\t\t\tif !equalfn(key, k2) {\n \t\t\t\tcontinue\n \t\t\t}\n \t\t\tmemclr(k, uintptr(t.keysize))\n@@ -760,10 +760,10 @@ next:\n \t\t\t\tif t.indirectkey {\n \t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t\t}\n-\t\t\t\tif t.reflexivekey || equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\tif t.reflexivekey || equalfn(k2, k2) {\n \t\t\t\t\t// If the item in the oldbucket is not destined for\n \t\t\t\t\t// the current new bucket in the iteration, skip it.\n-\t\t\t\t\thash := hashfn(k2, uintptr(h.hash0), uintptr(t.keysize))\n+\t\t\t\t\thash := hashfn(k2, uintptr(h.hash0))\n \t\t\t\t\tif hash&(uintptr(1)<<it.B-1) != checkBucket {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n@@ -797,7 +797,7 @@ next:\n \t\t\t\tif t.indirectkey {\n \t\t\t\t\tk2 = *((*unsafe.Pointer)(k2))\n \t\t\t\t}\n-\t\t\t\tif t.reflexivekey || equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\tif t.reflexivekey || equalfn(k2, k2) {\n \t\t\t\t\t// Check the current hash table for the data.\n \t\t\t\t\t// This code handles the case where the key\n \t\t\t\t\t// has been deleted, updated, or deleted and reinserted.\n@@ -913,9 +913,9 @@ func evacuate(t *maptype, h *hmap, oldbucket uintptr) {\n \t\t\t\t}\n \t\t\t\t// Compute hash to make our evacuation decision (whether we need\n \t\t\t\t// to send this key/value to bucket x or bucket y).\n-\t\t\t\thash := hashfn(k2, uintptr(h.hash0), uintptr(t.keysize))\n+\t\t\t\thash := hashfn(k2, uintptr(h.hash0))\n \t\t\t\tif h.flags&iterator != 0 {\n-\t\t\t\t\tif !t.reflexivekey && !equalfn(k2, k2, uintptr(t.keysize)) {\n+\t\t\t\t\tif !t.reflexivekey && !equalfn(k2, k2) {\n \t\t\t\t\t\t// If key != key (NaNs), then the hash could be (and probably\n \t\t\t\t\t\t// will be) entirely different from the old hash. Moreover,\n \t\t\t\t\t\t// it isn't reproducible. Reproducibility is required in the"}, {"sha": "c6cad9dc8c941ce72ccd9ca1ea26dbcdbccdab05", "filename": "libgo/go/runtime/hashmap_fast.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Fhashmap_fast.go?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -25,7 +25,7 @@ func mapaccess1_fast32(t *maptype, h *hmap, key uint32) unsafe.Pointer {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := uintptr(1)<<h.B - 1\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -70,7 +70,7 @@ func mapaccess2_fast32(t *maptype, h *hmap, key uint32) (unsafe.Pointer, bool) {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := uintptr(1)<<h.B - 1\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -115,7 +115,7 @@ func mapaccess1_fast64(t *maptype, h *hmap, key uint64) unsafe.Pointer {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := uintptr(1)<<h.B - 1\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -160,7 +160,7 @@ func mapaccess2_fast64(t *maptype, h *hmap, key uint64) (unsafe.Pointer, bool) {\n \t\t// One-bucket table. No need to hash.\n \t\tb = (*bmap)(h.buckets)\n \t} else {\n-\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0), uintptr(t.keysize))\n+\t\thash := t.key.hashfn(noescape(unsafe.Pointer(&key)), uintptr(h.hash0))\n \t\tm := uintptr(1)<<h.B - 1\n \t\tb = (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \t\tif c := h.oldbuckets; c != nil {\n@@ -260,7 +260,7 @@ func mapaccess1_faststr(t *maptype, h *hmap, ky string) unsafe.Pointer {\n \t\treturn unsafe.Pointer(&zeroVal[0])\n \t}\n dohash:\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0), uintptr(t.keysize))\n+\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n \tm := uintptr(1)<<h.B - 1\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {\n@@ -363,7 +363,7 @@ func mapaccess2_faststr(t *maptype, h *hmap, ky string) (unsafe.Pointer, bool) {\n \t\treturn unsafe.Pointer(&zeroVal[0]), false\n \t}\n dohash:\n-\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0), uintptr(t.keysize))\n+\thash := t.key.hashfn(noescape(unsafe.Pointer(&ky)), uintptr(h.hash0))\n \tm := uintptr(1)<<h.B - 1\n \tb := (*bmap)(add(h.buckets, (hash&m)*uintptr(t.bucketsize)))\n \tif c := h.oldbuckets; c != nil {"}, {"sha": "cfee35a6fe719b6e3f12332a982f6319d11e8d01", "filename": "libgo/go/runtime/type.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Ftype.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fgo%2Fruntime%2Ftype.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fruntime%2Ftype.go?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -16,8 +16,8 @@ type _type struct {\n \tsize       uintptr\n \thash       uint32\n \n-\thashfn  func(unsafe.Pointer, uintptr, uintptr) uintptr\n-\tequalfn func(unsafe.Pointer, unsafe.Pointer, uintptr) bool\n+\thashfn  func(unsafe.Pointer, uintptr) uintptr\n+\tequalfn func(unsafe.Pointer, unsafe.Pointer) bool\n \n \tgc     unsafe.Pointer\n \tstring *string"}, {"sha": "829572b7bee921134c5446f3c1993d74cae4ea4d", "filename": "libgo/runtime/go-type-complex.c", "status": "removed", "additions": 0, "deletions": 120, "changes": 120, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-complex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-complex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-complex.c?ref=8462d909a7439fb0bf7095144dbf36524c7e61ea", "patch": "@@ -1,120 +0,0 @@\n-/* go-type-complex.c -- hash and equality complex functions.\n-\n-   Copyright 2012 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <complex.h>\n-#include <math.h>\n-#include <stdint.h>\n-#include <string.h>\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-\n-/* Hash function for float types.  */\n-\n-uintptr_t\n-__go_type_hash_complex (const void *vkey, uintptr_t seed, uintptr_t key_size)\n-{\n-  if (key_size == 8)\n-    {\n-      const complex float *cfp;\n-      complex float cf;\n-      float cfr;\n-      float cfi;\n-      uint64_t fi;\n-\n-      cfp = (const complex float *) vkey;\n-      cf = *cfp;\n-\n-      cfr = crealf (cf);\n-      cfi = cimagf (cf);\n-\n-      if (isinf (cfr) || isinf (cfi))\n-\treturn seed;\n-\n-      /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n-\t random so that not all NaNs wind up in the same place.  */\n-      if (isnan (cfr) || isnan (cfi))\n-\treturn runtime_fastrand1 ();\n-\n-      /* Avoid negative zero.  */\n-      if (cfr == 0 && cfi == 0)\n-\treturn seed;\n-      else if (cfr == 0)\n-\tcf = cfi * I;\n-      else if (cfi == 0)\n-\tcf = cfr;\n-\n-      memcpy (&fi, &cf, 8);\n-      return (uintptr_t) cfi ^ seed;\n-    }\n-  else if (key_size == 16)\n-    {\n-      const complex double *cdp;\n-      complex double cd;\n-      double cdr;\n-      double cdi;\n-      uint64_t di[2];\n-\n-      cdp = (const complex double *) vkey;\n-      cd = *cdp;\n-\n-      cdr = creal (cd);\n-      cdi = cimag (cd);\n-\n-      if (isinf (cdr) || isinf (cdi))\n-\treturn seed;\n-\n-      if (isnan (cdr) || isnan (cdi))\n-\treturn runtime_fastrand1 ();\n-\n-      /* Avoid negative zero.  */\n-      if (cdr == 0 && cdi == 0)\n-\treturn seed;\n-      else if (cdr == 0)\n-\tcd = cdi * I;\n-      else if (cdi == 0)\n-\tcd = cdr;\n-\n-      memcpy (&di, &cd, 16);\n-      return di[0] ^ di[1] ^ seed;\n-    }\n-  else\n-    runtime_throw (\"__go_type_hash_complex: invalid complex size\");\n-}\n-\n-const FuncVal __go_type_hash_complex_descriptor =\n-  { (void *) __go_type_hash_complex };\n-\n-/* Equality function for complex types.  */\n-\n-_Bool\n-__go_type_equal_complex (const void *vk1, const void *vk2, uintptr_t key_size)\n-{\n-  if (key_size == 8)\n-    {\n-      const complex float *cfp1;\n-      const complex float *cfp2;\n-      \n-      cfp1 = (const complex float *) vk1;\n-      cfp2 = (const complex float *) vk2;\n-\n-      return *cfp1 == *cfp2;\n-    }\n-  else if (key_size == 16)\n-    {\n-      const complex double *cdp1;\n-      const complex double *cdp2;\n-      \n-      cdp1 = (const complex double *) vk1;\n-      cdp2 = (const complex double *) vk2;\n-\n-      return *cdp1 == *cdp2;\n-    }\n-  else\n-    runtime_throw (\"__go_type_equal_complex: invalid complex size\");\n-}\n-\n-const FuncVal __go_type_equal_complex_descriptor =\n-  { (void *) __go_type_equal_complex };"}, {"sha": "ae0e3367c2122cb5c8ae86acf5c102892e47663a", "filename": "libgo/runtime/go-type-float.c", "status": "removed", "additions": 0, "deletions": 92, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-float.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-float.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-float.c?ref=8462d909a7439fb0bf7095144dbf36524c7e61ea", "patch": "@@ -1,92 +0,0 @@\n-/* go-type-float.c -- hash and equality float functions.\n-\n-   Copyright 2012 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <math.h>\n-#include <stdint.h>\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-\n-/* Hash function for float types.  */\n-\n-uintptr_t\n-__go_type_hash_float (const void *vkey, uintptr_t seed, uintptr_t key_size)\n-{\n-  if (key_size == 4)\n-    {\n-      const float *fp;\n-      float f;\n-      uint32_t si;\n-\n-      fp = (const float *) vkey;\n-      f = *fp;\n-\n-      if (isinf (f) || f == 0)\n-\treturn seed;\n-\n-      /* NaN != NaN, so the hash code of a NaN is irrelevant.  Make it\n-\t random so that not all NaNs wind up in the same place.  */\n-      if (isnan (f))\n-\treturn runtime_fastrand1 ();\n-\n-      memcpy (&si, vkey, 4);\n-      return (uintptr_t) si ^ seed;\n-    }\n-  else if (key_size == 8)\n-    {\n-      const double *dp;\n-      double d;\n-      uint64_t di;\n-\n-      dp = (const double *) vkey;\n-      d = *dp;\n-\n-      if (isinf (d) || d == 0)\n-\treturn seed;\n-\n-      if (isnan (d))\n-\treturn runtime_fastrand1 ();\n-\n-      memcpy (&di, vkey, 8);\n-      return (uintptr_t) di ^ seed;\n-    }\n-  else\n-    runtime_throw (\"__go_type_hash_float: invalid float size\");\n-}\n-\n-const FuncVal __go_type_hash_float_descriptor =\n-  { (void *) __go_type_hash_float };\n-\n-/* Equality function for float types.  */\n-\n-_Bool\n-__go_type_equal_float (const void *vk1, const void *vk2, uintptr_t key_size)\n-{\n-  if (key_size == 4)\n-    {\n-      const float *fp1;\n-      const float *fp2;\n-\n-      fp1 = (const float *) vk1;\n-      fp2 = (const float *) vk2;\n-\n-      return *fp1 == *fp2;\n-    }\n-  else if (key_size == 8)\n-    {\n-      const double *dp1;\n-      const double *dp2;\n-\n-      dp1 = (const double *) vk1;\n-      dp2 = (const double *) vk2;\n-\n-      return *dp1 == *dp2;\n-    }\n-  else\n-    runtime_throw (\"__go_type_equal_float: invalid float size\");\n-}\n-\n-const FuncVal __go_type_equal_float_descriptor =\n-  { (void *) __go_type_equal_float };"}, {"sha": "842fa249bd0c482b47949d31bc4d5045c2c11d26", "filename": "libgo/runtime/go-type-identity.c", "status": "removed", "additions": 0, "deletions": 32, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-identity.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-identity.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-identity.c?ref=8462d909a7439fb0bf7095144dbf36524c7e61ea", "patch": "@@ -1,32 +0,0 @@\n-/* go-type-identity.c -- hash and equality identity functions.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include <stddef.h>\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-\n-/* The hash functions for types that can compare as identity is\n-   written in Go.  */\n-\n-extern uintptr runtime_memhash(void *, uintptr, uintptr)\n-  __asm__ (GOSYM_PREFIX \"runtime.memhash\");\n-\n-const FuncVal __go_type_hash_identity_descriptor =\n-  { (void *) runtime_memhash };\n-\n-/* An identity equality function for a type.  This is used for types\n-   where we can check for equality by checking that the values have\n-   the same bits.  */\n-\n-_Bool\n-__go_type_equal_identity (const void *k1, const void *k2, uintptr_t key_size)\n-{\n-  return __builtin_memcmp (k1, k2, key_size) == 0;\n-}\n-\n-const FuncVal __go_type_equal_identity_descriptor =\n-  { (void *) __go_type_equal_identity };"}, {"sha": "c7277ddb646e59e993ad9cb71a937a3acd8b8ce7", "filename": "libgo/runtime/go-type-string.c", "status": "removed", "additions": 0, "deletions": 49, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-string.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8462d909a7439fb0bf7095144dbf36524c7e61ea/libgo%2Fruntime%2Fgo-type-string.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type-string.c?ref=8462d909a7439fb0bf7095144dbf36524c7e61ea", "patch": "@@ -1,49 +0,0 @@\n-/* go-type-string.c -- hash and equality string functions.\n-\n-   Copyright 2009 The Go Authors. All rights reserved.\n-   Use of this source code is governed by a BSD-style\n-   license that can be found in the LICENSE file.  */\n-\n-#include \"runtime.h\"\n-#include \"go-type.h\"\n-#include \"go-string.h\"\n-\n-/* A string hash function for a map.  */\n-\n-uintptr_t\n-__go_type_hash_string (const void *vkey, uintptr_t seed,\n-\t\t       uintptr_t key_size __attribute__ ((unused)))\n-{\n-  uintptr_t ret;\n-  const String *key;\n-  intgo len;\n-  intgo i;\n-  const byte *p;\n-\n-  ret = seed;\n-  key = (const String *) vkey;\n-  len = key->len;\n-  for (i = 0, p = key->str; i < len; i++, p++)\n-    ret = ret * 33 + *p;\n-  return ret;\n-}\n-\n-const FuncVal __go_type_hash_string_descriptor =\n-  { (void *) __go_type_hash_string };\n-\n-/* A string equality function for a map.  */\n-\n-_Bool\n-__go_type_equal_string (const void *vk1, const void *vk2,\n-\t\t\tuintptr_t key_size __attribute__ ((unused)))\n-{\n-  const String *k1;\n-  const String *k2;\n-\n-  k1 = (const String *) vk1;\n-  k2 = (const String *) vk2;\n-  return __go_ptr_strings_equal (k1, k2);\n-}\n-\n-const FuncVal __go_type_equal_string_descriptor =\n-  { (void *) __go_type_equal_string };"}, {"sha": "e1552548d1e41f7d74ec9619e09208adcfcffb02", "filename": "libgo/runtime/go-type.h", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fruntime%2Fgo-type.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fruntime%2Fgo-type.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-type.h?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -362,24 +362,4 @@ extern _Bool\n __go_type_descriptors_equal(const struct __go_type_descriptor*,\n \t\t\t    const struct __go_type_descriptor*);\n \n-extern const FuncVal __go_type_hash_identity_descriptor;\n-extern _Bool __go_type_equal_identity (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_identity_descriptor;\n-extern uintptr_t __go_type_hash_string (const void *, uintptr_t, uintptr_t);\n-extern const FuncVal __go_type_hash_string_descriptor;\n-extern _Bool __go_type_equal_string (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_string_descriptor;\n-extern uintptr_t __go_type_hash_float (const void *, uintptr_t, uintptr_t);\n-extern const FuncVal __go_type_hash_float_descriptor;\n-extern _Bool __go_type_equal_float (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_float_descriptor;\n-extern uintptr_t __go_type_hash_complex (const void *, uintptr_t, uintptr_t);\n-extern const FuncVal __go_type_hash_complex_descriptor;\n-extern _Bool __go_type_equal_complex (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_complex_descriptor;\n-extern uintptr_t __go_type_hash_interface (const void *, uintptr_t, uintptr_t);\n-extern const FuncVal __go_type_hash_interface_descriptor;\n-extern _Bool __go_type_equal_interface (const void *, const void *, uintptr_t);\n-extern const FuncVal __go_type_equal_interface_descriptor;\n-\n #endif /* !defined(LIBGO_GO_TYPE_H) */"}, {"sha": "b98068365e143692bc4662bfd0cec26b0f9f6a9f", "filename": "libgo/runtime/go-unsafe-pointer.c", "status": "modified", "additions": 9, "deletions": 4, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0c22e4415fe9e88acaa99e72d33f4500d557ce68/libgo%2Fruntime%2Fgo-unsafe-pointer.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fruntime%2Fgo-unsafe-pointer.c?ref=0c22e4415fe9e88acaa99e72d33f4500d557ce68", "patch": "@@ -38,6 +38,11 @@ static const String reflection_string =\n \n const uintptr unsafe_Pointer_gc[] = {sizeof(void*), GC_APTR, 0, GC_END};\n \n+extern const FuncVal runtime_pointerhash_descriptor\n+  __asm__ (GOSYM_PREFIX \"runtime.pointerhash$descriptor\");\n+extern const FuncVal runtime_pointerequal_descriptor\n+  __asm__ (GOSYM_PREFIX \"runtime.pointerequal$descriptor\");\n+\n const struct __go_type_descriptor unsafe_Pointer =\n {\n   /* __code */\n@@ -51,9 +56,9 @@ const struct __go_type_descriptor unsafe_Pointer =\n   /* __hash */\n   78501163U,\n   /* __hashfn */\n-  &__go_type_hash_identity_descriptor,\n+  &runtime_pointerhash_descriptor,\n   /* __equalfn */\n-  &__go_type_equal_identity_descriptor,\n+  &runtime_pointerequal_descriptor,\n   /* __gc */\n   unsafe_Pointer_gc,\n   /* __reflection */\n@@ -94,9 +99,9 @@ const struct __go_ptr_type pointer_unsafe_Pointer =\n     /* __hash */\n     1256018616U,\n     /* __hashfn */\n-    &__go_type_hash_identity_descriptor,\n+    &runtime_pointerhash_descriptor,\n     /* __equalfn */\n-    &__go_type_equal_identity_descriptor,\n+    &runtime_pointerequal_descriptor,\n     /* __gc */\n     unsafe_Pointer_gc,\n     /* __reflection */"}]}