{"sha": "230dedb3272fa440ac35dcfb607c56221b1f18fa", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MjMwZGVkYjMyNzJmYTQ0MGFjMzVkY2ZiNjA3YzU2MjIxYjFmMThmYQ==", "commit": {"author": {"name": "Jan Hubicka", "email": "jh@suse.cz", "date": "2005-11-12T17:35:06Z"}, "committer": {"name": "Jan Hubicka", "email": "hubicka@gcc.gnu.org", "date": "2005-11-12T17:35:06Z"}, "message": "expr.c (expand_expr_real_1): <MAX_EXPR, MIN_EXPR>: Canonicalize to compare against 0 when possible.\n\n\t* expr.c (expand_expr_real_1): <MAX_EXPR, MIN_EXPR>: Canonicalize\n\tto compare against 0 when possible.\n\t* gcc.target/i386/minmax-1.c: New.\n\t* gcc.target/i386/minmax-2.c: New.\n\nFrom-SVN: r106827", "tree": {"sha": "143398328b5dba39ed717e534f55c159e0cba4b7", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/143398328b5dba39ed717e534f55c159e0cba4b7"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/230dedb3272fa440ac35dcfb607c56221b1f18fa", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230dedb3272fa440ac35dcfb607c56221b1f18fa", "html_url": "https://github.com/Rust-GCC/gccrs/commit/230dedb3272fa440ac35dcfb607c56221b1f18fa", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/230dedb3272fa440ac35dcfb607c56221b1f18fa/comments", "author": null, "committer": null, "parents": [{"sha": "df25924573df78683f948a6fda74ece056746268", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/df25924573df78683f948a6fda74ece056746268", "html_url": "https://github.com/Rust-GCC/gccrs/commit/df25924573df78683f948a6fda74ece056746268"}], "stats": {"total": 159, "additions": 105, "deletions": 54}, "files": [{"sha": "3c01cf7391ca752d1d920875ecb66b40b8b7db84", "filename": "gcc/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=230dedb3272fa440ac35dcfb607c56221b1f18fa", "patch": "@@ -1,3 +1,8 @@\n+2005-11-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* expr.c (expand_expr_real_1): <MAX_EXPR, MIN_EXPR>: Canonicalize\n+\tto compare against 0 when possible.\n+\n 2005-11-12  Jie Zhang  <jie.zhang@analog.com>\n \n \t* config/bfin/bfin.h (REGISTER_NAMES, SHORT_REGISTER_NAMES,"}, {"sha": "125e37071d91022c4dd4a4197d8022936469d642", "filename": "gcc/expr.c", "status": "modified", "additions": 77, "deletions": 54, "changes": 131, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fexpr.c?ref=230dedb3272fa440ac35dcfb607c56221b1f18fa", "patch": "@@ -8020,69 +8020,92 @@ expand_expr_real_1 (tree exp, rtx target, enum machine_mode tmode,\n       if (! CONSTANT_P (op1))\n \top1 = force_reg (mode, op1);\n \n-#ifdef HAVE_conditional_move\n-      /* Use a conditional move if possible.  */\n-      if (can_conditionally_move_p (mode))\n-\t{\n-\t  enum rtx_code comparison_code;\n-\t  rtx insn;\n+      {\n+\tenum rtx_code comparison_code;\n+\trtx cmpop1 = op1;\n \n-\t  if (code == MAX_EXPR)\n-\t    comparison_code = unsignedp ? GEU : GE;\n-\t  else\n-\t    comparison_code = unsignedp ? LEU : LE;\n+\tif (code == MAX_EXPR)\n+\t  comparison_code = unsignedp ? GEU : GE;\n+\telse\n+\t  comparison_code = unsignedp ? LEU : LE;\n \n-\t  /* ??? Same problem as in expmed.c: emit_conditional_move\n-\t     forces a stack adjustment via compare_from_rtx, and we\n-\t     lose the stack adjustment if the sequence we are about\n-\t     to create is discarded.  */\n-\t  do_pending_stack_adjust ();\n+\t/* Canonicalize to comparsions against 0.  */\n+\tif (op1 == const1_rtx)\n+\t  {\n+\t    /* Converting (a >= 1 ? a : 1) into (a > 0 ? a : 1)\n+\t       or (a != 0 ? a : 1) for unsigned.\n+\t       For MIN we are safe converting (a <= 1 ? a : 1)\n+\t       into (a <= 0 ? a : 1)  */\n+\t    cmpop1 = const0_rtx;\n+\t    if (code == MAX_EXPR)\n+\t      comparison_code = unsignedp ? NE : GT;\n+\t  }\n+\tif (op1 == constm1_rtx && !unsignedp)\n+\t  {\n+\t    /* Converting (a >= -1 ? a : -1) into (a >= 0 ? a : -1)\n+\t       and (a <= -1 ? a : -1) into (a < 0 ? a : -1) */\n+\t    cmpop1 = const0_rtx;\n+\t    if (code == MIN_EXPR)\n+\t      comparison_code = LT;\n+\t  }\n+#ifdef HAVE_conditional_move\n+\t/* Use a conditional move if possible.  */\n+\tif (can_conditionally_move_p (mode))\n+\t  {\n+\t    rtx insn;\n \n-\t  start_sequence ();\n+\t    /* ??? Same problem as in expmed.c: emit_conditional_move\n+\t       forces a stack adjustment via compare_from_rtx, and we\n+\t       lose the stack adjustment if the sequence we are about\n+\t       to create is discarded.  */\n+\t    do_pending_stack_adjust ();\n \n-\t  /* Try to emit the conditional move.  */\n-\t  insn = emit_conditional_move (target, comparison_code,\n-\t\t\t\t\top0, op1, mode,\n-\t\t\t\t\top0, op1, mode,\n-\t\t\t\t\tunsignedp);\n+\t    start_sequence ();\n \n-\t  /* If we could do the conditional move, emit the sequence,\n-\t     and return.  */\n-\t  if (insn)\n-\t    {\n-\t      rtx seq = get_insns ();\n-\t      end_sequence ();\n-\t      emit_insn (seq);\n-\t      return target;\n-\t    }\n+\t    /* Try to emit the conditional move.  */\n+\t    insn = emit_conditional_move (target, comparison_code,\n+\t\t\t\t\t  op0, cmpop1, mode,\n+\t\t\t\t\t  op0, op1, mode,\n+\t\t\t\t\t  unsignedp);\n \n-\t  /* Otherwise discard the sequence and fall back to code with\n-\t     branches.  */\n-\t  end_sequence ();\n-\t}\n+\t    /* If we could do the conditional move, emit the sequence,\n+\t       and return.  */\n+\t    if (insn)\n+\t      {\n+\t\trtx seq = get_insns ();\n+\t\tend_sequence ();\n+\t\temit_insn (seq);\n+\t\treturn target;\n+\t      }\n+\n+\t    /* Otherwise discard the sequence and fall back to code with\n+\t       branches.  */\n+\t    end_sequence ();\n+\t  }\n #endif\n-      if (target != op0)\n-\temit_move_insn (target, op0);\n+\tif (target != op0)\n+\t  emit_move_insn (target, op0);\n \n-      temp = gen_label_rtx ();\n+\ttemp = gen_label_rtx ();\n \n-      /* If this mode is an integer too wide to compare properly,\n-\t compare word by word.  Rely on cse to optimize constant cases.  */\n-      if (GET_MODE_CLASS (mode) == MODE_INT\n-\t  && ! can_compare_p (GE, mode, ccp_jump))\n-\t{\n-\t  if (code == MAX_EXPR)\n-\t    do_jump_by_parts_greater_rtx (mode, unsignedp, target, op1,\n-\t\t\t\t\t  NULL_RTX, temp);\n-\t  else\n-\t    do_jump_by_parts_greater_rtx (mode, unsignedp, op1, target,\n-\t\t\t\t\t  NULL_RTX, temp);\n-\t}\n-      else\n-\t{\n-\t  do_compare_rtx_and_jump (target, op1, code == MAX_EXPR ? GE : LE,\n-\t\t\t\t   unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n-\t}\n+\t/* If this mode is an integer too wide to compare properly,\n+\t   compare word by word.  Rely on cse to optimize constant cases.  */\n+\tif (GET_MODE_CLASS (mode) == MODE_INT\n+\t    && ! can_compare_p (GE, mode, ccp_jump))\n+\t  {\n+\t    if (code == MAX_EXPR)\n+\t      do_jump_by_parts_greater_rtx (mode, unsignedp, target, op1,\n+\t\t\t\t\t    NULL_RTX, temp);\n+\t    else\n+\t      do_jump_by_parts_greater_rtx (mode, unsignedp, op1, target,\n+\t\t\t\t\t    NULL_RTX, temp);\n+\t  }\n+\telse\n+\t  {\n+\t    do_compare_rtx_and_jump (target, cmpop1, comparison_code,\n+\t\t\t\t     unsignedp, mode, NULL_RTX, NULL_RTX, temp);\n+\t  }\n+      }\n       emit_move_insn (target, op1);\n       emit_label (temp);\n       return target;"}, {"sha": "2767bb5f3dc5bda1896bf54030935b8c7c331893", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=230dedb3272fa440ac35dcfb607c56221b1f18fa", "patch": "@@ -1,3 +1,8 @@\n+2005-11-12  Jan Hubicka  <jh@suse.cz>\n+\n+\t* gcc.target/i386/minmax-1.c: New.\n+\t* gcc.target/i386/minmax-2.c: New.\n+\n 2005-11-12  Kaz Kojima  <kkojima@gcc.gnu.org>\n \n \t* gcc.dg/pr24445.c: Fix for 64-bit targets."}, {"sha": "ca7fb6a91a1e350a55b77c83448e5607113dcf60", "filename": "gcc/testsuite/gcc.target/i386/minmax-1.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-1.c?ref=230dedb3272fa440ac35dcfb607c56221b1f18fa", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2 -march=opteron\" } */\n+/* { dg-final { scan-assembler \"test\" } } */\n+/* { dg-final { scan-assembler-not \"cmp\" } } */\n+#define max(a,b) (((a) > (b))? (a) : (b))\n+t(int a)\n+{\n+  return (max(a,1));\n+}"}, {"sha": "2021aaa07776902ea08a0b5725b01210772592d5", "filename": "gcc/testsuite/gcc.target/i386/minmax-2.c", "status": "added", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/230dedb3272fa440ac35dcfb607c56221b1f18fa/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgcc.target%2Fi386%2Fminmax-2.c?ref=230dedb3272fa440ac35dcfb607c56221b1f18fa", "patch": "@@ -0,0 +1,9 @@\n+/* { dg-do compile } */\n+/* { dg-options \"-O2\" } */\n+/* { dg-final { scan-assembler \"test\" } } */\n+/* { dg-final { scan-assembler-not \"cmp\" } } */\n+#define max(a,b) (((a) > (b))? (a) : (b))\n+t(unsigned int a)\n+{\n+  return (max(a,1));\n+}"}]}