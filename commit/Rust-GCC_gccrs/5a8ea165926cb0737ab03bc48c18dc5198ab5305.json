{"sha": "5a8ea165926cb0737ab03bc48c18dc5198ab5305", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWE4ZWExNjU5MjZjYjA3MzdhYjAzYmM0OGMxOGRjNTE5OGFiNTMwNQ==", "commit": {"author": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-01-02T23:05:27Z"}, "committer": {"name": "Ian Lance Taylor", "email": "iant@golang.org", "date": "2020-01-22T07:53:22Z"}, "message": "libgo: update to Go1.14beta1\n\nReviewed-on: https://go-review.googlesource.com/c/gofrontend/+/214297", "tree": {"sha": "962dc3357c57f019f85658f99e2e753e30201c27", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/962dc3357c57f019f85658f99e2e753e30201c27"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5a8ea165926cb0737ab03bc48c18dc5198ab5305", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8ea165926cb0737ab03bc48c18dc5198ab5305", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5a8ea165926cb0737ab03bc48c18dc5198ab5305", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5a8ea165926cb0737ab03bc48c18dc5198ab5305/comments", "author": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "committer": {"login": "ianlancetaylor", "id": 3194333, "node_id": "MDQ6VXNlcjMxOTQzMzM=", "avatar_url": "https://avatars.githubusercontent.com/u/3194333?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ianlancetaylor", "html_url": "https://github.com/ianlancetaylor", "followers_url": "https://api.github.com/users/ianlancetaylor/followers", "following_url": "https://api.github.com/users/ianlancetaylor/following{/other_user}", "gists_url": "https://api.github.com/users/ianlancetaylor/gists{/gist_id}", "starred_url": "https://api.github.com/users/ianlancetaylor/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ianlancetaylor/subscriptions", "organizations_url": "https://api.github.com/users/ianlancetaylor/orgs", "repos_url": "https://api.github.com/users/ianlancetaylor/repos", "events_url": "https://api.github.com/users/ianlancetaylor/events{/privacy}", "received_events_url": "https://api.github.com/users/ianlancetaylor/received_events", "type": "User", "site_admin": false}, "parents": [{"sha": "6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "html_url": "https://github.com/Rust-GCC/gccrs/commit/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43"}], "stats": {"total": 88465, "additions": 67275, "deletions": 21190}, "files": [{"sha": "dff5fb5bc706e152959b0981cd8177a3e0aced84", "filename": "gcc/go/gofrontend/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gcc%2Fgo%2Fgofrontend%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gcc%2Fgo%2Fgofrontend%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fgo%2Fgofrontend%2FMERGE?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,4 +1,4 @@\n-a69ad9c7d1b45edcf8062a07d3a3c9b6838c04f8\n+c2225a76d1e15f28056596807ebbbc526d4c58da\n \n The first line of this file holds the git revision number of the last\n merge done from the gofrontend repository."}, {"sha": "b6d34315562027031068104ea4b51356fccb897e", "filename": "gotools/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FChangeLog?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,3 +1,9 @@\n+2020-01-21  Ian Lance Taylor  <iant@golang.org>\n+\n+\t* Makefile.am (gofmt$(EXEEXT)): Link against $(LIBGOTOOL).\n+\t(check-go-tool): Copy some vendor directories.\n+\t* Makefile.in: Regenerate.\n+\n 2019-09-06  Ian Lance Taylor  <iant@golang.org>\n \n \t* Makefile.am (check-carchive-test): Just run \"go test\", not \"go"}, {"sha": "47adf9bafeb5b6d400eaa6b0d78864388017e464", "filename": "gotools/Makefile.am", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.am?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -116,7 +116,7 @@ man_MANS = go.1 gofmt.1\n go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n \t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n-\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n+\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBGODEP)\n \t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n vet$(EXEEXT): $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBGODEP)\n@@ -215,6 +215,10 @@ check-go-tool: go$(EXEEXT) $(noinst_PROGRAMS) check-head check-gccgo check-gcc\n \tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n \tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n \tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n+\t$(MKDIR_P) check-go-dir/src/cmd/vendor/golang.org/x\n+\tcp -r $(libgosrcdir)/golang.org/x/mod check-go-dir/src/cmd/vendor/golang.org/x/\n+\tcp -r $(libgosrcdir)/golang.org/x/crypto check-go-dir/src/cmd/vendor/golang.org/x/\n+\tcp -r $(libgosrcdir)/golang.org/x/xerrors check-go-dir/src/cmd/vendor/golang.org/x/\n \tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n \t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n \tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\"}, {"sha": "930189a55ebfdc581ad70233d187d50e04e58c5d", "filename": "gotools/Makefile.in", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/gotools%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gotools%2FMakefile.in?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -820,7 +820,7 @@ mostlyclean-local:\n @NATIVE_TRUE@go$(EXEEXT): $(go_cmd_go_files) $(LIBGOTOOL) $(LIBGODEP)\n @NATIVE_TRUE@\t$(GOLINK) $(go_cmd_go_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@gofmt$(EXEEXT): $(go_cmd_gofmt_files) $(LIBGODEP)\n-@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBS) $(NET_LIBS)\n+@NATIVE_TRUE@\t$(GOLINK) $(go_cmd_gofmt_files) $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@cgo$(EXEEXT): $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBGODEP)\n @NATIVE_TRUE@\t$(GOLINK) $(go_cmd_cgo_files) zdefaultcc.go $(LIBGOTOOL) $(LIBS) $(NET_LIBS)\n @NATIVE_TRUE@vet$(EXEEXT): $(go_cmd_vet_files) $(LIBGOTOOL) $(LIBGODEP)\n@@ -886,6 +886,10 @@ mostlyclean-local:\n @NATIVE_TRUE@\tcp $(libgodir)/zdefaultcc.go check-go-dir/src/cmd/go/internal/cfg/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/go/testdata check-go-dir/src/cmd/go/\n @NATIVE_TRUE@\tcp -r $(cmdsrcdir)/internal check-go-dir/src/cmd/\n+@NATIVE_TRUE@\t$(MKDIR_P) check-go-dir/src/cmd/vendor/golang.org/x\n+@NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/mod check-go-dir/src/cmd/vendor/golang.org/x/\n+@NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/crypto check-go-dir/src/cmd/vendor/golang.org/x/\n+@NATIVE_TRUE@\tcp -r $(libgosrcdir)/golang.org/x/xerrors check-go-dir/src/cmd/vendor/golang.org/x/\n @NATIVE_TRUE@\tcp $(libgodir)/objabi.go check-go-dir/src/cmd/internal/objabi/\n @NATIVE_TRUE@\t@abs_libgodir=`cd $(libgodir) && $(PWD_COMMAND)`; \\\n @NATIVE_TRUE@\tabs_checkdir=`cd check-go-dir && $(PWD_COMMAND)`; \\"}, {"sha": "9c5763972c1d56981d3444b4b545606f9b2dc9bd", "filename": "libgo/MERGE", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMERGE", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMERGE", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMERGE?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,4 +1,4 @@\n-cc8838d645b2b7026c1f3aaceb011775c5ca3a08\n+a5bfd9da1d1b24f326399b6b75558ded14514f23\n \n The first line of this file holds the git revision number of the\n last merge done from the master library sources."}, {"sha": "56d38f57e7d1a69f0e8fd58334bd440a9a28c8ea", "filename": "libgo/Makefile.am", "status": "modified", "additions": 3, "deletions": 1, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.am?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -262,7 +262,8 @@ toolexeclibgohash_DATA = \\\n \thash/adler32.gox \\\n \thash/crc32.gox \\\n \thash/crc64.gox \\\n-\thash/fnv.gox\n+\thash/fnv.gox \\\n+\thash/maphash.gox\n \n toolexeclibgohtmldir = $(toolexeclibgodir)/html\n \n@@ -402,6 +403,7 @@ toolexeclibgounicode_DATA = \\\n noinst_DATA = \\\n \tgolang.org/x/net/nettest.gox \\\n \tinternal/cfg.gox \\\n+\tinternal/obscuretestdata.gox \\\n \tinternal/testenv.gox \\\n \tinternal/trace.gox \\\n \tnet/internal/socktest.gox \\"}, {"sha": "88c687464fc2da3fdba90a65a1c13de560b1307a", "filename": "libgo/Makefile.in", "status": "modified", "additions": 6, "deletions": 4, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FMakefile.in?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -743,7 +743,8 @@ toolexeclibgohash_DATA = \\\n \thash/adler32.gox \\\n \thash/crc32.gox \\\n \thash/crc64.gox \\\n-\thash/fnv.gox\n+\thash/fnv.gox \\\n+\thash/maphash.gox\n \n toolexeclibgohtmldir = $(toolexeclibgodir)/html\n toolexeclibgohtml_DATA = \\\n@@ -861,9 +862,10 @@ toolexeclibgounicode_DATA = \\\n # internal packages nothing will explicitly depend on them.\n # Force them to be built.\n noinst_DATA = golang.org/x/net/nettest.gox internal/cfg.gox \\\n-\tinternal/testenv.gox internal/trace.gox \\\n-\tnet/internal/socktest.gox os/signal/internal/pty.gox \\\n-\truntime/pprof/internal/profile.gox zdefaultcc.go\n+\tinternal/obscuretestdata.gox internal/testenv.gox \\\n+\tinternal/trace.gox net/internal/socktest.gox \\\n+\tos/signal/internal/pty.gox runtime/pprof/internal/profile.gox \\\n+\tzdefaultcc.go\n @LIBGO_IS_RTEMS_FALSE@rtems_task_variable_add_file = \n @LIBGO_IS_RTEMS_TRUE@rtems_task_variable_add_file = runtime/rtems-task-variable-add.c\n runtime_context_asm_file = $(am__append_3)"}, {"sha": "da5318592de75370f17433ccc7d23f05b2f23f86", "filename": "libgo/VERSION", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FVERSION", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2FVERSION", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2FVERSION?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1 +1 @@\n-go1.13\n+go1.14beta1"}, {"sha": "48c4dfdbc91429e82c6767d13c3987bd7797a131", "filename": "libgo/check-packages.txt", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fcheck-packages.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fcheck-packages.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fcheck-packages.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -3,7 +3,6 @@ archive/zip\n bufio\n bytes\n cmd/go/internal/cache\n-cmd/go/internal/dirhash\n cmd/go/internal/generate\n cmd/go/internal/get\n cmd/go/internal/imports\n@@ -13,13 +12,10 @@ cmd/go/internal/lockedfile/internal/filelock\n cmd/go/internal/modconv\n cmd/go/internal/modfetch\n cmd/go/internal/modfetch/codehost\n-cmd/go/internal/modfile\n cmd/go/internal/modload\n-cmd/go/internal/module\n cmd/go/internal/mvs\n cmd/go/internal/par\n cmd/go/internal/search\n-cmd/go/internal/semver\n cmd/go/internal/txtar\n cmd/go/internal/work\n cmd/internal/buildid\n@@ -96,6 +92,7 @@ hash/adler32\n hash/crc32\n hash/crc64\n hash/fnv\n+hash/maphash\n html\n html/template\n image\n@@ -163,6 +160,8 @@ strings\n sync\n sync/atomic\n syscall\n+testing\n+testing/iotest\n testing/quick\n text/scanner\n text/tabwriter"}, {"sha": "385ca9a65cd981e114a242d94443c8fa7698d937", "filename": "libgo/configure", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fconfigure", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fconfigure", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2544,7 +2544,7 @@ ac_compiler_gnu=$ac_cv_c_compiler_gnu\n ac_config_headers=\"$ac_config_headers config.h\"\n \n \n-libtool_VERSION=15:0:0\n+libtool_VERSION=16:0:0\n \n \n # Default to --enable-multilib"}, {"sha": "07c03bcdf2616d3cb98e53061756777e2384951c", "filename": "libgo/configure.ac", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fconfigure.ac", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fconfigure.ac", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fconfigure.ac?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,7 +10,7 @@ AC_INIT(package-unused, version-unused,, libgo)\n AC_CONFIG_SRCDIR(Makefile.am)\n AC_CONFIG_HEADER(config.h)\n \n-libtool_VERSION=15:0:0\n+libtool_VERSION=16:0:0\n AC_SUBST(libtool_VERSION)\n \n AM_ENABLE_MULTILIB(, ..)"}, {"sha": "4f9135b791943774cbda7d8527db9c1e547e7a32", "filename": "libgo/go/archive/tar/reader.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Ftar%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Ftar%2Freader.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -433,7 +433,7 @@ func (tr *Reader) readHeader() (*Header, *block, error) {\n \t\t\t// files generated by a pre-Go1.8 toolchain. If the generated file\n \t\t\t// happened to have a prefix field that parses as valid\n \t\t\t// atime and ctime fields (e.g., when they are valid octal strings),\n-\t\t\t// then it is impossible to distinguish between an valid GNU file\n+\t\t\t// then it is impossible to distinguish between a valid GNU file\n \t\t\t// and an invalid pre-Go1.8 file.\n \t\t\t//\n \t\t\t// See https://golang.org/issues/12594"}, {"sha": "13ff9ddcf42cc33b36484429652526612fa2887c", "filename": "libgo/go/archive/zip/reader.go", "status": "modified", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Freader.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -8,7 +8,6 @@ import (\n \t\"bufio\"\n \t\"encoding/binary\"\n \t\"errors\"\n-\t\"fmt\"\n \t\"hash\"\n \t\"hash/crc32\"\n \t\"io\"\n@@ -84,9 +83,6 @@ func (z *Reader) init(r io.ReaderAt, size int64) error {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tif end.directoryRecords > uint64(size)/fileHeaderLen {\n-\t\treturn fmt.Errorf(\"archive/zip: TOC declares impossible %d files in %d byte zip\", end.directoryRecords, size)\n-\t}\n \tz.r = r\n \tz.File = make([]*File, 0, end.directoryRecords)\n \tz.Comment = end.comment"}, {"sha": "adca87a8b3829c7675145364c84145b7ea7aa4f6", "filename": "libgo/go/archive/zip/reader_test.go", "status": "modified", "additions": 32, "deletions": 14, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Freader_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -8,6 +8,7 @@ import (\n \t\"bytes\"\n \t\"encoding/binary\"\n \t\"encoding/hex\"\n+\t\"internal/obscuretestdata\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -19,11 +20,12 @@ import (\n )\n \n type ZipTest struct {\n-\tName    string\n-\tSource  func() (r io.ReaderAt, size int64) // if non-nil, used instead of testdata/<Name> file\n-\tComment string\n-\tFile    []ZipTestFile\n-\tError   error // the error that Opening this file should return\n+\tName     string\n+\tSource   func() (r io.ReaderAt, size int64) // if non-nil, used instead of testdata/<Name> file\n+\tComment  string\n+\tFile     []ZipTestFile\n+\tObscured bool  // needed for Apple notarization (golang.org/issue/34986)\n+\tError    error // the error that Opening this file should return\n }\n \n type ZipTestFile struct {\n@@ -189,8 +191,12 @@ var tests = []ZipTest{\n \t},\n \t{\n \t\t// created by Go, before we wrote the \"optional\" data\n-\t\t// descriptor signatures (which are required by OS X)\n-\t\tName: \"go-no-datadesc-sig.zip\",\n+\t\t// descriptor signatures (which are required by macOS).\n+\t\t// Use obscured file to avoid Apple\u2019s notarization service\n+\t\t// rejecting the toolchain due to an inability to unzip this archive.\n+\t\t// See golang.org/issue/34986\n+\t\tName:     \"go-no-datadesc-sig.zip.base64\",\n+\t\tObscured: true,\n \t\tFile: []ZipTestFile{\n \t\t\t{\n \t\t\t\tName:     \"foo.txt\",\n@@ -208,7 +214,7 @@ var tests = []ZipTest{\n \t},\n \t{\n \t\t// created by Go, after we wrote the \"optional\" data\n-\t\t// descriptor signatures (which are required by OS X)\n+\t\t// descriptor signatures (which are required by macOS)\n \t\tName: \"go-with-datadesc-sig.zip\",\n \t\tFile: []ZipTestFile{\n \t\t\t{\n@@ -496,8 +502,18 @@ func readTestZip(t *testing.T, zt ZipTest) {\n \t\trat, size := zt.Source()\n \t\tz, err = NewReader(rat, size)\n \t} else {\n+\t\tpath := filepath.Join(\"testdata\", zt.Name)\n+\t\tif zt.Obscured {\n+\t\t\ttf, err := obscuretestdata.DecodeToTempFile(path)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"obscuretestdata.DecodeToTempFile(%s): %v\", path, err)\n+\t\t\t\treturn\n+\t\t\t}\n+\t\t\tdefer os.Remove(tf)\n+\t\t\tpath = tf\n+\t\t}\n \t\tvar rc *ReadCloser\n-\t\trc, err = OpenReader(filepath.Join(\"testdata\", zt.Name))\n+\t\trc, err = OpenReader(path)\n \t\tif err == nil {\n \t\t\tdefer rc.Close()\n \t\t\tz = &rc.Reader\n@@ -981,15 +997,17 @@ func TestIssue10957(t *testing.T) {\n \t}\n }\n \n-// Verify the number of files is sane.\n+// Verify that this particular malformed zip file is rejected.\n func TestIssue10956(t *testing.T) {\n \tdata := []byte(\"PK\\x06\\x06PK\\x06\\a0000\\x00\\x00\\x00\\x00\\x00\\x00\\x00\\x00\" +\n \t\t\"0000PK\\x05\\x06000000000000\" +\n \t\t\"0000\\v\\x00000\\x00\\x00\\x00\\x00\\x00\\x00\\x000\")\n-\t_, err := NewReader(bytes.NewReader(data), int64(len(data)))\n-\tconst want = \"TOC declares impossible 3472328296227680304 files in 57 byte\"\n-\tif err == nil && !strings.Contains(err.Error(), want) {\n-\t\tt.Errorf(\"error = %v; want %q\", err, want)\n+\tr, err := NewReader(bytes.NewReader(data), int64(len(data)))\n+\tif err == nil {\n+\t\tt.Errorf(\"got nil error, want ErrFormat\")\n+\t}\n+\tif r != nil {\n+\t\tt.Errorf(\"got non-nil Reader, want nil\")\n \t}\n }\n "}, {"sha": "c3d593f44f988ab96b59549096903a5c7f7a10d2", "filename": "libgo/go/archive/zip/testdata/go-no-datadesc-sig.zip", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43"}, {"sha": "1c2c071fbe0e7a528f00215cd3134c1e8c016ecc", "filename": "libgo/go/archive/zip/testdata/go-no-datadesc-sig.zip.base64", "status": "added", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip.base64", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip.base64", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Farchive%2Fzip%2Ftestdata%2Fgo-no-datadesc-sig.zip.base64?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1 @@\n+UEsDBBQACAAAAGWHaECoZTJ+BAAAAAQAAAAHABgAZm9vLnR4dFVUBQAD3lVZT3V4CwABBPUBAAAEFAAAAGZvbwqoZTJ+BAAAAAQAAABQSwMEFAAIAAAAZodoQOmzogQEAAAABAAAAAcAGABiYXIudHh0VVQFAAPgVVlPdXgLAAEE9QEAAAQUAAAAYmFyCumzogQEAAAABAAAAFBLAQIUAxQACAAAAGWHaECoZTJ+BAAAAAQAAAAHABgAAAAAAAAAAACkgQAAAABmb28udHh0VVQFAAPeVVlPdXgLAAEE9QEAAAQUAAAAUEsBAhQDFAAIAAAAZodoQOmzogQEAAAABAAAAAcAGAAAAAAAAAAAAKSBTQAAAGJhci50eHRVVAUAA+BVWU91eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCaAAAAmgAAAAAA"}, {"sha": "f0810be3a44e9743542971386338a6176b8aa269", "filename": "libgo/go/bufio/bufio.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbufio%2Fbufio.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbufio%2Fbufio.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -432,6 +432,7 @@ func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n \tvar frag []byte\n \tvar full [][]byte\n \tvar err error\n+\tn := 0\n \tfor {\n \t\tvar e error\n \t\tfrag, e = b.ReadSlice(delim)\n@@ -447,18 +448,15 @@ func (b *Reader) ReadBytes(delim byte) ([]byte, error) {\n \t\tbuf := make([]byte, len(frag))\n \t\tcopy(buf, frag)\n \t\tfull = append(full, buf)\n+\t\tn += len(buf)\n \t}\n \n-\t// Allocate new buffer to hold the full pieces and the fragment.\n-\tn := 0\n-\tfor i := range full {\n-\t\tn += len(full[i])\n-\t}\n \tn += len(frag)\n \n-\t// Copy full pieces and fragment in.\n+\t// Allocate new buffer to hold the full pieces and the fragment.\n \tbuf := make([]byte, n)\n \tn = 0\n+\t// Copy full pieces and fragment in.\n \tfor i := range full {\n \t\tn += copy(buf[n:], full[i])\n \t}\n@@ -708,9 +706,14 @@ func (b *Writer) WriteString(s string) (int, error) {\n // supports the ReadFrom method, and b has no buffered data yet,\n // this calls the underlying ReadFrom without buffering.\n func (b *Writer) ReadFrom(r io.Reader) (n int64, err error) {\n+\tif b.err != nil {\n+\t\treturn 0, b.err\n+\t}\n \tif b.Buffered() == 0 {\n \t\tif w, ok := b.wr.(io.ReaderFrom); ok {\n-\t\t\treturn w.ReadFrom(r)\n+\t\t\tn, err = w.ReadFrom(r)\n+\t\t\tb.err = err\n+\t\t\treturn n, err\n \t\t}\n \t}\n \tvar m int"}, {"sha": "9a9f102f151e78ddf4aae24e6cd1c694ffc213f3", "filename": "libgo/go/bufio/bufio_test.go", "status": "modified", "additions": 46, "deletions": 0, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbufio%2Fbufio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbufio%2Fbufio_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1535,6 +1535,52 @@ func TestPartialReadEOF(t *testing.T) {\n \t}\n }\n \n+type writerWithReadFromError struct{}\n+\n+func (w writerWithReadFromError) ReadFrom(r io.Reader) (int64, error) {\n+\treturn 0, errors.New(\"writerWithReadFromError error\")\n+}\n+\n+func (w writerWithReadFromError) Write(b []byte) (n int, err error) {\n+\treturn 10, nil\n+}\n+\n+func TestWriterReadFromMustSetUnderlyingError(t *testing.T) {\n+\tvar wr = NewWriter(writerWithReadFromError{})\n+\tif _, err := wr.ReadFrom(strings.NewReader(\"test2\")); err == nil {\n+\t\tt.Fatal(\"expected ReadFrom returns error, got nil\")\n+\t}\n+\tif _, err := wr.Write([]byte(\"123\")); err == nil {\n+\t\tt.Fatal(\"expected Write returns error, got nil\")\n+\t}\n+}\n+\n+type writeErrorOnlyWriter struct{}\n+\n+func (w writeErrorOnlyWriter) Write(p []byte) (n int, err error) {\n+\treturn 0, errors.New(\"writeErrorOnlyWriter error\")\n+}\n+\n+// Ensure that previous Write errors are immediately returned\n+// on any ReadFrom. See golang.org/issue/35194.\n+func TestWriterReadFromMustReturnUnderlyingError(t *testing.T) {\n+\tvar wr = NewWriter(writeErrorOnlyWriter{})\n+\ts := \"test1\"\n+\twantBuffered := len(s)\n+\tif _, err := wr.WriteString(s); err != nil {\n+\t\tt.Fatalf(\"unexpected error: %v\", err)\n+\t}\n+\tif err := wr.Flush(); err == nil {\n+\t\tt.Error(\"expected flush error, got nil\")\n+\t}\n+\tif _, err := wr.ReadFrom(strings.NewReader(\"test2\")); err == nil {\n+\t\tt.Fatal(\"expected error, got nil\")\n+\t}\n+\tif buffered := wr.Buffered(); buffered != wantBuffered {\n+\t\tt.Fatalf(\"Buffered = %v; want %v\", buffered, wantBuffered)\n+\t}\n+}\n+\n func BenchmarkReaderCopyOptimal(b *testing.B) {\n \t// Optimal case is where the underlying reader implements io.WriterTo\n \tsrcBuf := bytes.NewBuffer(make([]byte, 8192))"}, {"sha": "e872cc20506b5dc32144b7f947766597c36f0b2e", "filename": "libgo/go/bytes/bytes.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbytes%2Fbytes.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbytes%2Fbytes.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fbytes.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -935,7 +935,8 @@ func ReplaceAll(s, old, new []byte) []byte {\n }\n \n // EqualFold reports whether s and t, interpreted as UTF-8 strings,\n-// are equal under Unicode case-folding.\n+// are equal under Unicode case-folding, which is a more general\n+// form of case-insensitivity.\n func EqualFold(s, t []byte) bool {\n \tfor len(s) != 0 && len(t) != 0 {\n \t\t// Extract first rune from each."}, {"sha": "a595d575d07251f8ece63d82123c72fdf31a2462", "filename": "libgo/go/bytes/compare_test.go", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fbytes%2Fcompare_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fbytes%2Fcompare_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -120,6 +120,39 @@ func TestCompareBytes(t *testing.T) {\n \t}\n }\n \n+func TestEndianBaseCompare(t *testing.T) {\n+\t// This test compares byte slices that are almost identical, except one\n+\t// difference that for some j, a[j]>b[j] and a[j+1]<b[j+1]. If the implementation\n+\t// compares large chunks with wrong endianness, it gets wrong result.\n+\t// no vector register is larger than 512 bytes for now\n+\tconst maxLength = 512\n+\ta := make([]byte, maxLength)\n+\tb := make([]byte, maxLength)\n+\t// randomish but deterministic data. No 0 or 255.\n+\tfor i := 0; i < maxLength; i++ {\n+\t\ta[i] = byte(1 + 31*i%254)\n+\t\tb[i] = byte(1 + 31*i%254)\n+\t}\n+\tfor i := 2; i <= maxLength; i <<= 1 {\n+\t\tfor j := 0; j < i-1; j++ {\n+\t\t\ta[j] = b[j] - 1\n+\t\t\ta[j+1] = b[j+1] + 1\n+\t\t\tcmp := Compare(a[:i], b[:i])\n+\t\t\tif cmp != -1 {\n+\t\t\t\tt.Errorf(`CompareBbigger(%d,%d) = %d`, i, j, cmp)\n+\t\t\t}\n+\t\t\ta[j] = b[j] + 1\n+\t\t\ta[j+1] = b[j+1] - 1\n+\t\t\tcmp = Compare(a[:i], b[:i])\n+\t\t\tif cmp != 1 {\n+\t\t\t\tt.Errorf(`CompareAbigger(%d,%d) = %d`, i, j, cmp)\n+\t\t\t}\n+\t\t\ta[j] = b[j]\n+\t\t\ta[j+1] = b[j+1]\n+\t\t}\n+\t}\n+}\n+\n func BenchmarkCompareBytesEqual(b *testing.B) {\n \tb1 := []byte(\"Hello Gophers!\")\n \tb2 := []byte(\"Hello Gophers!\")"}, {"sha": "8c3bf81bf78925ec0b1bf35ef3cc4bd955c3c4f3", "filename": "libgo/go/cmd/cgo/doc.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fdoc.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -55,7 +55,7 @@ For example:\n \n The default pkg-config tool may be changed by setting the PKG_CONFIG environment variable.\n \n-For security reasons, only a limited set of flags are allowed, notably -D, -I, and -l.\n+For security reasons, only a limited set of flags are allowed, notably -D, -U, -I, and -l.\n To allow additional flags, set CGO_CFLAGS_ALLOW to a regular expression\n matching the new flags. To disallow flags that would otherwise be allowed,\n set CGO_CFLAGS_DISALLOW to a regular expression matching arguments\n@@ -99,7 +99,7 @@ Will be expanded to:\n \n When the Go tool sees that one or more Go files use the special import\n \"C\", it will look for other non-Go files in the directory and compile\n-them as part of the Go package. Any .c, .s, or .S files will be\n+them as part of the Go package. Any .c, .s, .S or .sx files will be\n compiled with the C compiler. Any .cc, .cpp, or .cxx files will be\n compiled with the C++ compiler. Any .f, .F, .for or .f90 files will be\n compiled with the fortran compiler. Any .h, .hh, .hpp, or .hxx files will"}, {"sha": "678b348c89b0727f5e4ea5a22e541f0966d675a5", "filename": "libgo/go/cmd/cgo/gcc.go", "status": "modified", "additions": 14, "deletions": 7, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fgcc.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -834,7 +834,7 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \t// Rewrite C.f(p) to\n \t//    func() {\n \t//            _cgo0 := p\n-\t//            _cgoCheckPointer(_cgo0)\n+\t//            _cgoCheckPointer(_cgo0, nil)\n \t//            C.f(_cgo0)\n \t//    }()\n \t// Using a function literal like this lets us evaluate the\n@@ -852,7 +852,7 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \t//    defer func() func() {\n \t//            _cgo0 := p\n \t//            return func() {\n-\t//                    _cgoCheckPointer(_cgo0)\n+\t//                    _cgoCheckPointer(_cgo0, nil)\n \t//                    C.f(_cgo0)\n \t//            }\n \t//    }()()\n@@ -939,7 +939,7 @@ func (p *Package) rewriteCall(f *File, call *Call) (string, bool) {\n \t\t}\n \n \t\tfmt.Fprintf(&sb, \"_cgo%d := %s; \", i, gofmtPos(arg, origArg.Pos()))\n-\t\tfmt.Fprintf(&sbCheck, \"_cgoCheckPointer(_cgo%d); \", i)\n+\t\tfmt.Fprintf(&sbCheck, \"_cgoCheckPointer(_cgo%d, nil); \", i)\n \t}\n \n \tif call.Deferred {\n@@ -2211,14 +2211,21 @@ func (c *typeConv) FinishType(pos token.Pos) {\n // Type returns a *Type with the same memory layout as\n // dtype when used as the type of a variable or a struct field.\n func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n+\treturn c.loadType(dtype, pos, \"\")\n+}\n+\n+// loadType recursively loads the requested dtype and its dependency graph.\n+func (c *typeConv) loadType(dtype dwarf.Type, pos token.Pos, parent string) *Type {\n \t// Always recompute bad pointer typedefs, as the set of such\n \t// typedefs changes as we see more types.\n \tcheckCache := true\n \tif dtt, ok := dtype.(*dwarf.TypedefType); ok && c.badPointerTypedef(dtt) {\n \t\tcheckCache = false\n \t}\n \n-\tkey := dtype.String()\n+\t// The cache key should be relative to its parent.\n+\t// See issue https://golang.org/issue/31891\n+\tkey := parent + \" > \" + dtype.String()\n \n \tif checkCache {\n \t\tif t, ok := c.m[key]; ok {\n@@ -2258,7 +2265,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t\t// Translate to zero-length array instead.\n \t\t\tcount = 0\n \t\t}\n-\t\tsub := c.Type(dt.Type, pos)\n+\t\tsub := c.loadType(dt.Type, pos, key)\n \t\tt.Align = sub.Align\n \t\tt.Go = &ast.ArrayType{\n \t\t\tLen: c.intExpr(count),\n@@ -2403,7 +2410,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\tc.ptrs[key] = append(c.ptrs[key], t)\n \n \tcase *dwarf.QualType:\n-\t\tt1 := c.Type(dt.Type, pos)\n+\t\tt1 := c.loadType(dt.Type, pos, key)\n \t\tt.Size = t1.Size\n \t\tt.Align = t1.Align\n \t\tt.Go = t1.Go\n@@ -2487,7 +2494,7 @@ func (c *typeConv) Type(dtype dwarf.Type, pos token.Pos) *Type {\n \t\t}\n \t\tname := c.Ident(\"_Ctype_\" + dt.Name)\n \t\tgoIdent[name.Name] = name\n-\t\tsub := c.Type(dt.Type, pos)\n+\t\tsub := c.loadType(dt.Type, pos, key)\n \t\tif c.badPointerTypedef(dt) {\n \t\t\t// Treat this typedef as a uintptr.\n \t\t\ts := *sub"}, {"sha": "4d66e1b24b35ee1c91cb4d87cc4d8f4a1d29220f", "filename": "libgo/go/cmd/cgo/out.go", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fcgo%2Fout.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1638,14 +1638,14 @@ func _cgo_runtime_cgocall(unsafe.Pointer, uintptr) int32\n func _cgo_runtime_cgocallback(unsafe.Pointer, unsafe.Pointer, uintptr, uintptr)\n \n //go:linkname _cgoCheckPointer runtime.cgoCheckPointer\n-func _cgoCheckPointer(interface{}, ...interface{})\n+func _cgoCheckPointer(interface{}, interface{})\n \n //go:linkname _cgoCheckResult runtime.cgoCheckResult\n func _cgoCheckResult(interface{})\n `\n \n const gccgoGoProlog = `\n-func _cgoCheckPointer(interface{}, ...interface{})\n+func _cgoCheckPointer(interface{}, interface{})\n \n func _cgoCheckResult(interface{})\n `\n@@ -1832,16 +1832,16 @@ typedef struct __go_empty_interface {\n \tvoid *__object;\n } Eface;\n \n-extern void runtimeCgoCheckPointer(Eface, Slice)\n+extern void runtimeCgoCheckPointer(Eface, Eface)\n \t__asm__(\"runtime.cgoCheckPointer\")\n \t__attribute__((weak));\n \n-extern void localCgoCheckPointer(Eface, Slice)\n+extern void localCgoCheckPointer(Eface, Eface)\n \t__asm__(\"GCCGOSYMBOLPREF._cgoCheckPointer\");\n \n-void localCgoCheckPointer(Eface ptr, Slice args) {\n+void localCgoCheckPointer(Eface ptr, Eface arg) {\n \tif(runtimeCgoCheckPointer) {\n-\t\truntimeCgoCheckPointer(ptr, args);\n+\t\truntimeCgoCheckPointer(ptr, arg);\n \t}\n }\n "}, {"sha": "54e7a8b5b300edb89ae7c0cda580a1aa1578a1a6", "filename": "libgo/go/cmd/go/alldocs.go", "status": "modified", "additions": 67, "deletions": 20, "changes": 87, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Falldocs.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -110,11 +110,13 @@\n // \t\tThe default is the number of CPUs available.\n // \t-race\n // \t\tenable data race detection.\n-// \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n+// \t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n+// \t\tlinux/ppc64le and linux/arm64 (only for 48-bit VMA).\n // \t-msan\n // \t\tenable interoperation with memory sanitizer.\n // \t\tSupported only on linux/amd64, linux/arm64\n // \t\tand only with Clang/LLVM as the host C compiler.\n+// \t\tOn linux/arm64, pie build mode will be used.\n // \t-v\n // \t\tprint the names of packages as they are compiled.\n // \t-work\n@@ -143,11 +145,21 @@\n // \t-ldflags '[pattern=]arg list'\n // \t\targuments to pass on each go tool link invocation.\n // \t-linkshared\n-// \t\tlink against shared libraries previously created with\n-// \t\t-buildmode=shared.\n+// \t\tbuild code that will be linked against shared libraries previously\n+// \t\tcreated with -buildmode=shared.\n // \t-mod mode\n-// \t\tmodule download mode to use: readonly or vendor.\n+// \t\tmodule download mode to use: readonly, vendor, or mod.\n // \t\tSee 'go help modules' for more.\n+// \t-modcacherw\n+// \t\tleave newly-created directories in the module cache read-write\n+// \t\tinstead of making them read-only.\n+// \t-modfile file\n+// \t\tin module aware mode, read (and possibly write) an alternate go.mod\n+// \t\tfile instead of the one in the module root directory. A file named\n+// \t\t\"go.mod\" must still be present in order to determine the module root\n+// \t\tdirectory, but it is not accessed. When -modfile is specified, an\n+// \t\talternate go.sum file is also used: its path is derived from the\n+// \t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n // \t-pkgdir dir\n // \t\tinstall and load all packages from dir instead of the usual locations.\n // \t\tFor example, when building with a non-standard configuration,\n@@ -361,6 +373,8 @@\n // \t\tTreat a command (package main) like a regular package.\n // \t\tOtherwise package main's exported symbols are hidden\n // \t\twhen showing the package's top-level documentation.\n+// \t-short\n+// \t\tOne-line representation for each symbol.\n // \t-src\n // \t\tShow the full source code for the symbol. This will\n // \t\tdisplay the full Go source of its declaration and\n@@ -431,6 +445,9 @@\n // The -n flag prints commands that would be executed.\n // The -x flag prints commands as they are executed.\n //\n+// The -mod flag's value sets which module download mode\n+// to use: readonly or vendor. See 'go help modules' for more.\n+//\n // To run gofmt with specific options, run gofmt itself.\n //\n // See also: go fix, go vet.\n@@ -993,7 +1010,7 @@\n //\n // Usage:\n //\n-// \tgo mod download [-json] [modules]\n+// \tgo mod download [-x] [-json] [modules]\n //\n // Download downloads the named modules, which can be module patterns selecting\n // dependencies of the main module or module queries of the form path@version.\n@@ -1018,9 +1035,10 @@\n //         Dir      string // absolute path to cached source root directory\n //         Sum      string // checksum for path, version (as in go.sum)\n //         GoModSum string // checksum for go.mod (as in go.sum)\n-//         Latest   bool   // would @latest resolve to this version?\n //     }\n //\n+// The -x flag causes download to print the commands download executes.\n+//\n // See 'go help modules' for more about module queries.\n //\n //\n@@ -1057,12 +1075,17 @@\n // add and drop an exclusion for the given module path and version.\n // Note that -exclude=path@version is a no-op if that exclusion already exists.\n //\n-// The -replace=old[@v]=new[@v] and -dropreplace=old[@v] flags\n-// add and drop a replacement of the given module path and version pair.\n-// If the @v in old@v is omitted, the replacement applies to all versions\n-// with the old module path. If the @v in new@v is omitted, the new path\n-// should be a local module root directory, not a module path.\n-// Note that -replace overrides any existing replacements for old[@v].\n+// The -replace=old[@v]=new[@v] flag adds a replacement of the given\n+// module path and version pair. If the @v in old@v is omitted, a\n+// replacement without a version on the left side is added, which applies\n+// to all versions of the old module path. If the @v in new@v is omitted,\n+// the new path should be a local module root directory, not a module\n+// path. Note that -replace overrides any redundant replacements for old[@v],\n+// so omitting @v will drop existing replacements for specific versions.\n+//\n+// The -dropreplace=old[@v] flag drops a replacement of the given\n+// module path and version pair. If the @v is omitted, a replacement without\n+// a version on the left side is dropped.\n //\n // The -require, -droprequire, -exclude, -dropexclude, -replace,\n // and -dropreplace editing flags may be repeated, and the changes\n@@ -1232,7 +1255,7 @@\n // If the -exec flag is not given, GOOS or GOARCH is different from the system\n // default, and a program named go_$GOOS_$GOARCH_exec can be found\n // on the current search path, 'go run' invokes the binary using that program,\n-// for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n+// for example 'go_js_wasm_exec a.out arguments...'. This allows execution of\n // cross-compiled programs when a simulator or other execution method is\n // available.\n //\n@@ -1504,8 +1527,8 @@\n // extension will be passed to SWIG. Any file with a .swigcxx extension\n // will be passed to SWIG with the -c++ option.\n //\n-// When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n-// or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+// When either cgo or SWIG is used, go build will pass any .c, .m, .s, .S\n+// or .sx files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n // compiler. The CC or CXX environment variables may be set to determine\n // the C or C++ compiler, respectively, to use.\n //\n@@ -1588,6 +1611,10 @@\n // \t\tBecause the entries are space-separated, flag values must\n // \t\tnot contain spaces. Flags listed on the command line\n // \t\tare applied after this list and therefore override it.\n+// \tGOINSECURE\n+// \t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n+// \t\tof module path prefixes that should always be fetched in an insecure\n+// \t\tmanner. Only applies to dependencies that are being fetched directly.\n // \tGOOS\n // \t\tThe operating system for which to compile code.\n // \t\tExamples are linux, darwin, windows, netbsd.\n@@ -1699,8 +1726,10 @@\n // \tGOHOSTOS\n // \t\tThe operating system (GOOS) of the Go toolchain binaries.\n // \tGOMOD\n-// \t\tThe absolute path to the go.mod of the main module,\n-// \t\tor the empty string if not using modules.\n+// \t\tThe absolute path to the go.mod of the main module.\n+// \t\tIf module-aware mode is enabled, but there is no go.mod, GOMOD will be\n+// \t\tos.DevNull (\"/dev/null\" on Unix-like systems, \"NUL\" on Windows).\n+// \t\tIf module-aware mode is disabled, GOMOD will be the empty string.\n // \tGOTOOLDIR\n // \t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n //\n@@ -1724,7 +1753,7 @@\n // \t.m\n // \t\tObjective-C source files. Only useful with cgo, and always\n // \t\tcompiled with the OS-native compiler.\n-// \t.s, .S\n+// \t.s, .S, .sx\n // \t\tAssembler source files.\n // \t\tIf the package uses cgo or SWIG, these will be assembled with the\n // \t\tOS-native assembler (typically gcc (sic)); otherwise they\n@@ -2060,8 +2089,8 @@\n //\n // The GET requests sent to a Go module proxy are:\n //\n-// GET $GOPROXY/<module>/@v/list returns a list of all known versions of the\n-// given module, one per line.\n+// GET $GOPROXY/<module>/@v/list returns a list of known versions of the given\n+// module, one per line.\n //\n // GET $GOPROXY/<module>/@v/<version>.info returns JSON-formatted metadata\n // about that version of the given module.\n@@ -2072,6 +2101,21 @@\n // GET $GOPROXY/<module>/@v/<version>.zip returns the zip archive\n // for that version of the given module.\n //\n+// GET $GOPROXY/<module>/@latest returns JSON-formatted metadata about the\n+// latest known version of the given module in the same format as\n+// <module>/@v/<version>.info. The latest version should be the version of\n+// the module the go command may use if <module>/@v/list is empty or no\n+// listed version is suitable. <module>/@latest is optional and may not\n+// be implemented by a module proxy.\n+//\n+// When resolving the latest version of a module, the go command will request\n+// <module>/@v/list, then, if no suitable versions are found, <module>/@latest.\n+// The go command prefers, in order: the semantically highest release version,\n+// the semantically highest pre-release version, and the chronologically\n+// most recent pseudo-version. In Go 1.12 and earlier, the go command considered\n+// pseudo-versions in <module>/@v/list to be pre-release versions, but this is\n+// no longer true since Go 1.13.\n+//\n // To avoid problems when serving from case-sensitive file systems,\n // the <module> and <version> elements are case-encoded, replacing every\n // uppercase letter with an exclamation mark followed by the corresponding\n@@ -2460,6 +2504,9 @@\n // directory holds the correct copies of dependencies and ignores\n // the dependency descriptions in go.mod.\n //\n+// If invoked with -mod=mod, the go command loads modules from the module cache\n+// even if there is a vendor directory present.\n+//\n // Pseudo-versions\n //\n // The go.mod file and the go command more generally use semantic versions as"}, {"sha": "ebd0c7ad0ad69aa17c2d44d3820badff1d99b14b", "filename": "libgo/go/cmd/go/go_test.go", "status": "modified", "additions": 50, "deletions": 855, "changes": 905, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fgo_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -56,7 +56,7 @@ func tooSlow(t *testing.T) {\n \n func init() {\n \tswitch runtime.GOOS {\n-\tcase \"android\", \"js\", \"nacl\":\n+\tcase \"android\", \"js\":\n \t\tcanRun = false\n \tcase \"darwin\":\n \t\tswitch runtime.GOARCH {\n@@ -206,7 +206,7 @@ func TestMain(m *testing.M) {\n \t\t// (installed in GOROOT/pkg/tool/GOOS_GOARCH).\n \t\t// If these are not the same toolchain, then the entire standard library\n \t\t// will look out of date (the compilers in those two different tool directories\n-\t\t// are built for different architectures and have different buid IDs),\n+\t\t// are built for different architectures and have different build IDs),\n \t\t// which will cause many tests to do unnecessary rebuilds and some\n \t\t// tests to attempt to overwrite the installed standard library.\n \t\t// Bail out entirely in this case.\n@@ -683,8 +683,11 @@ func (tg *testgoData) creatingTemp(path string) {\n \t// If we have changed the working directory, make sure we have\n \t// an absolute path, because we are going to change directory\n \t// back before we remove the temporary.\n-\tif tg.wd != \"\" && !filepath.IsAbs(path) {\n-\t\tpath = filepath.Join(tg.pwd(), path)\n+\tif !filepath.IsAbs(path) {\n+\t\tif tg.wd == \"\" || strings.HasPrefix(tg.wd, testGOROOT) {\n+\t\t\ttg.t.Fatalf(\"internal testsuite error: creatingTemp(%q) within GOROOT/src\", path)\n+\t\t}\n+\t\tpath = filepath.Join(tg.wd, path)\n \t}\n \ttg.must(robustio.RemoveAll(path))\n \ttg.temps = append(tg.temps, path)\n@@ -917,6 +920,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t\"src/runtime\",\n \t\t\"src/internal/bytealg\",\n \t\t\"src/internal/cpu\",\n+\t\t\"src/math/bits\",\n \t\t\"src/unsafe\",\n \t\tfilepath.Join(\"pkg\", runtime.GOOS+\"_\"+runtime.GOARCH),\n \t\tfilepath.Join(\"pkg/tool\", runtime.GOOS+\"_\"+runtime.GOARCH),\n@@ -942,7 +946,7 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\ttg.tempFile(dest, string(data))\n-\t\t\t\tif err := os.Chmod(tg.path(dest), info.Mode()); err != nil {\n+\t\t\t\tif err := os.Chmod(tg.path(dest), info.Mode()|0200); err != nil {\n \t\t\t\t\treturn err\n \t\t\t\t}\n \t\t\t\treturn nil\n@@ -1007,128 +1011,6 @@ func TestNewReleaseRebuildsStalePackagesInGOPATH(t *testing.T) {\n \ttg.wantNotStale(\"p1\", \"\", \"./testgo list claims p1 is stale after building with old release\")\n }\n \n-func testLocalRun(tg *testgoData, exepath, local, match string) {\n-\ttg.t.Helper()\n-\tout, err := exec.Command(exepath).Output()\n-\tif err != nil {\n-\t\ttg.t.Fatalf(\"error running %v: %v\", exepath, err)\n-\t}\n-\tif !regexp.MustCompile(match).Match(out) {\n-\t\ttg.t.Log(string(out))\n-\t\ttg.t.Errorf(\"testdata/%s/easy.go did not generate expected output\", local)\n-\t}\n-}\n-\n-func testLocalEasy(tg *testgoData, local string) {\n-\ttg.t.Helper()\n-\texepath := \"./easy\" + exeSuffix\n-\ttg.creatingTemp(exepath)\n-\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easy.go\"))\n-\ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n-}\n-\n-func testLocalEasySub(tg *testgoData, local string) {\n-\ttg.t.Helper()\n-\texepath := \"./easysub\" + exeSuffix\n-\ttg.creatingTemp(exepath)\n-\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"easysub\", \"main.go\"))\n-\ttestLocalRun(tg, exepath, local, `(?m)^easysub\\.Hello`)\n-}\n-\n-func testLocalHard(tg *testgoData, local string) {\n-\ttg.t.Helper()\n-\texepath := \"./hard\" + exeSuffix\n-\ttg.creatingTemp(exepath)\n-\ttg.run(\"build\", \"-o\", exepath, filepath.Join(\"testdata\", local, \"hard.go\"))\n-\ttestLocalRun(tg, exepath, local, `(?m)^sub\\.Hello`)\n-}\n-\n-func testLocalInstall(tg *testgoData, local string) {\n-\ttg.t.Helper()\n-\ttg.runFail(\"install\", filepath.Join(\"testdata\", local, \"easy.go\"))\n-}\n-\n-func TestLocalImportsEasy(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttestLocalEasy(tg, \"local\")\n-}\n-\n-func TestLocalImportsEasySub(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttestLocalEasySub(tg, \"local\")\n-}\n-\n-func TestLocalImportsHard(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttestLocalHard(tg, \"local\")\n-}\n-\n-func TestLocalImportsGoInstallShouldFail(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttestLocalInstall(tg, \"local\")\n-}\n-\n-const badDirName = `#$%:, &()*;<=>?\\^{}`\n-\n-func copyBad(tg *testgoData) {\n-\ttg.t.Helper()\n-\tif runtime.GOOS == \"windows\" {\n-\t\ttg.t.Skipf(\"skipping test because %q is an invalid directory name\", badDirName)\n-\t}\n-\n-\ttg.must(filepath.Walk(\"testdata/local\",\n-\t\tfunc(path string, info os.FileInfo, err error) error {\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tif info.IsDir() {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\t\t\tvar data []byte\n-\t\t\tdata, err = ioutil.ReadFile(path)\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tnewpath := strings.Replace(path, \"local\", badDirName, 1)\n-\t\t\ttg.tempFile(newpath, string(data))\n-\t\t\treturn nil\n-\t\t}))\n-\ttg.cd(tg.path(\".\"))\n-}\n-\n-func TestBadImportsEasy(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// TODO: tg.parallel()\n-\tcopyBad(tg)\n-\ttestLocalEasy(tg, badDirName)\n-}\n-\n-func TestBadImportsEasySub(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tcopyBad(tg)\n-\ttestLocalEasySub(tg, badDirName)\n-}\n-\n-func TestBadImportsHard(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tcopyBad(tg)\n-\ttestLocalHard(tg, badDirName)\n-}\n-\n-func TestBadImportsGoInstallShouldFail(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tcopyBad(tg)\n-\ttestLocalInstall(tg, badDirName)\n-}\n-\n func TestInternalPackagesInGOROOTAreRespected(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo does not have GOROOT\")\n \ttg := testgo(t)\n@@ -1166,48 +1048,6 @@ func TestRunPkg(t *testing.T) {\n \ttg.grepStderr(\"hello, world\", \"did not find hello, world\")\n }\n \n-func testMove(t *testing.T, vcs, url, base, config string) {\n-\ttestenv.MustHaveExternalNetwork(t)\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempDir(\"src\")\n-\ttg.must(os.Mkdir(tg.path(\".hg\"), 0700))\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.path(\".hg\"), \"hgrc\"), nil, 0600))\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.run(\"get\", \"-d\", url)\n-\ttg.run(\"get\", \"-d\", \"-u\", url)\n-\tswitch vcs {\n-\tcase \"svn\":\n-\t\t// SVN doesn't believe in text files so we can't just edit the config.\n-\t\t// Check out a different repo into the wrong place.\n-\t\ttg.must(robustio.RemoveAll(tg.path(\"src/code.google.com/p/rsc-svn\")))\n-\t\ttg.run(\"get\", \"-d\", \"-u\", \"code.google.com/p/rsc-svn2/trunk\")\n-\t\ttg.must(os.Rename(tg.path(\"src/code.google.com/p/rsc-svn2\"), tg.path(\"src/code.google.com/p/rsc-svn\")))\n-\tdefault:\n-\t\tpath := tg.path(filepath.Join(\"src\", config))\n-\t\tdata, err := ioutil.ReadFile(path)\n-\t\ttg.must(err)\n-\t\tdata = bytes.ReplaceAll(data, []byte(base), []byte(base+\"XXX\"))\n-\t\ttg.must(ioutil.WriteFile(path, data, 0644))\n-\t}\n-\tif vcs == \"git\" {\n-\t\t// git will ask for a username and password when we\n-\t\t// run go get -d -f -u. An empty username and\n-\t\t// password will work. Prevent asking by setting\n-\t\t// GIT_ASKPASS.\n-\t\ttg.creatingTemp(\"sink\" + exeSuffix)\n-\t\ttg.tempFile(\"src/sink/sink.go\", `package main; func main() {}`)\n-\t\ttg.run(\"build\", \"-o\", \"sink\"+exeSuffix, \"sink\")\n-\t\ttg.setenv(\"GIT_ASKPASS\", filepath.Join(tg.pwd(), \"sink\"+exeSuffix))\n-\t}\n-\ttg.runFail(\"get\", \"-d\", \"-u\", url)\n-\ttg.grepStderr(\"is a custom import path for\", \"go get -d -u \"+url+\" failed for wrong reason\")\n-\ttg.runFail(\"get\", \"-d\", \"-f\", \"-u\", url)\n-\ttg.grepStderr(\"validating server certificate|[nN]ot [fF]ound\", \"go get -d -f -u \"+url+\" failed for wrong reason\")\n-}\n-\n func TestInternalPackageErrorsAreHandled(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1222,21 +1062,6 @@ func TestInternalCache(t *testing.T) {\n \ttg.grepStderr(\"internal\", \"did not fail to build p\")\n }\n \n-func TestMoveGit(t *testing.T) {\n-\ttestenv.MustHaveExecPath(t, \"git\")\n-\ttestMove(t, \"git\", \"rsc.io/pdf\", \"pdf\", \"rsc.io/pdf/.git/config\")\n-}\n-\n-func TestMoveHG(t *testing.T) {\n-\ttestenv.MustHaveExecPath(t, \"hg\")\n-\ttestMove(t, \"hg\", \"vcs-test.golang.org/go/custom-hg-hello\", \"custom-hg-hello\", \"vcs-test.golang.org/go/custom-hg-hello/.hg/hgrc\")\n-}\n-\n-// TODO(rsc): Set up a test case on SourceForge (?) for svn.\n-// func testMoveSVN(t *testing.T) {\n-//\ttestMove(t, \"svn\", \"code.google.com/p/rsc-svn/trunk\", \"-\", \"-\")\n-// }\n-\n func TestImportCommandMatch(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1435,17 +1260,6 @@ func TestRelativeImportsInCommandLinePackage(t *testing.T) {\n \ttg.run(append([]string{\"test\"}, files...)...)\n }\n \n-func TestNonCanonicalImportPaths(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"canonical/d\")\n-\ttg.grepStderr(\"package canonical/d\", \"did not report canonical/d\")\n-\ttg.grepStderr(\"imports canonical/b\", \"did not report canonical/b\")\n-\ttg.grepStderr(\"imports canonical/a/: non-canonical\", \"did not report canonical/a/\")\n-}\n-\n func TestVersionControlErrorMessageIncludesCorrectDirectory(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1502,72 +1316,6 @@ func TestRelativeGOBINFail(t *testing.T) {\n \ttg.grepStderr(\"cannot install, GOBIN must be an absolute path\", \"go install must fail if $GOBIN is a relative path\")\n }\n \n-// Test that without $GOBIN set, binaries get installed\n-// into the GOPATH bin directory.\n-func TestInstallIntoGOPATH(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"testdata/bin/go-cmd-test\" + exeSuffix)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"install\", \"go-cmd-test\")\n-\ttg.wantExecutable(\"testdata/bin/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\")\n-}\n-\n-// Issue 12407\n-func TestBuildOutputToDevNull(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tfi1, err1 := os.Lstat(os.DevNull)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"build\", \"-o\", os.DevNull, \"go-cmd-test\")\n-\tfi2, err2 := os.Lstat(os.DevNull)\n-\tif err1 == nil {\n-\t\tif err2 != nil {\n-\t\t\tt.Errorf(\"second stat of /dev/null failed: %v\", err2)\n-\t\t} else if !os.SameFile(fi1, fi2) {\n-\t\t\tt.Errorf(\"/dev/null changed: now %v was %v\", fi1, fi2)\n-\t\t}\n-\t}\n-}\n-\n-// Issue 28549.\n-func TestTestOutputToDevNull(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tfi1, err1 := os.Lstat(os.DevNull)\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.tempFile(\"src/p/p.go\", \"package p\\n\")\n-\ttg.tempFile(\"src/p/p_test.go\", \"package p\\nimport \\\"testing\\\"\\nfunc TestX(t *testing.T) {}\\n\")\n-\ttg.run(\"test\", \"-o\", os.DevNull, \"-c\", \"p\")\n-\ttg.mustNotExist(\"p.test\")\n-\tfi2, err2 := os.Lstat(os.DevNull)\n-\tif err1 == nil {\n-\t\tif err2 != nil {\n-\t\t\tt.Errorf(\"second stat of /dev/null failed: %v\", err2)\n-\t\t} else if !os.SameFile(fi1, fi2) {\n-\t\t\tt.Errorf(\"/dev/null changed: now %v was %v\", fi1, fi2)\n-\t\t}\n-\t}\n-}\n-\n-func TestPackageMainTestImportsArchiveNotBinary(t *testing.T) {\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin\")\n-\ttg.creatingTemp(gobin)\n-\ttg.setenv(\"GOBIN\", gobin)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.must(os.Chtimes(\"./testdata/src/main_test/m.go\", time.Now(), time.Now()))\n-\ttg.sleep()\n-\ttg.run(\"test\", \"main_test\")\n-\ttg.run(\"install\", \"main_test\")\n-\ttg.wantNotStale(\"main_test\", \"\", \"after go install, main listed as stale\")\n-\ttg.run(\"test\", \"main_test\")\n-}\n-\n func TestPackageMainTestCompilerFlags(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -1600,51 +1348,6 @@ func TestPackageNotStaleWithTrailingSlash(t *testing.T) {\n \ttg.wantNotStale(\"io\", \"\", \"with trailing slash in GOROOT, io listed as stale\")\n }\n \n-// With $GOBIN set, binaries get installed to $GOBIN.\n-func TestInstallIntoGOBIN(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin1\")\n-\ttg.creatingTemp(gobin)\n-\ttg.setenv(\"GOBIN\", gobin)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"install\", \"go-cmd-test\")\n-\ttg.wantExecutable(\"testdata/bin1/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin1/go-cmd-test\")\n-}\n-\n-// Issue 11065\n-func TestInstallToCurrentDirectoryCreatesExecutable(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tpkg := filepath.Join(tg.pwd(), \"testdata\", \"src\", \"go-cmd-test\")\n-\ttg.creatingTemp(filepath.Join(pkg, \"go-cmd-test\"+exeSuffix))\n-\ttg.setenv(\"GOBIN\", pkg)\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.cd(pkg)\n-\ttg.run(\"install\")\n-\ttg.wantExecutable(\"go-cmd-test\"+exeSuffix, \"go install did not write to current directory\")\n-}\n-\n-// Without $GOBIN set, installing a program outside $GOPATH should fail\n-// (there is nowhere to install it).\n-func TestInstallWithoutDestinationFails(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.runFail(\"install\", \"testdata/src/go-cmd-test/helloworld.go\")\n-\ttg.grepStderr(\"no install location for .go files listed on command line\", \"wrong error\")\n-}\n-\n-// With $GOBIN set, should install there.\n-func TestInstallToGOBINCommandLinePackage(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tgobin := filepath.Join(tg.pwd(), \"testdata\", \"bin1\")\n-\ttg.creatingTemp(gobin)\n-\ttg.setenv(\"GOBIN\", gobin)\n-\ttg.run(\"install\", \"testdata/src/go-cmd-test/helloworld.go\")\n-\ttg.wantExecutable(\"testdata/bin1/helloworld\"+exeSuffix, \"go install testdata/src/go-cmd-test/helloworld.go did not write testdata/bin1/helloworld\")\n-}\n-\n func TestGoGetNonPkg(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n@@ -1674,94 +1377,6 @@ func TestGoGetTestOnlyPkg(t *testing.T) {\n \ttg.run(\"get\", \"-t\", \"golang.org/x/tour/content...\")\n }\n \n-func TestInstalls(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't install into GOROOT in short mode\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempDir(\"gobin\")\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\tgoroot := runtime.GOROOT()\n-\ttg.setenv(\"GOROOT\", goroot)\n-\n-\t// cmd/fix installs into tool\n-\ttg.run(\"env\", \"GOOS\")\n-\tgoos := strings.TrimSpace(tg.getStdout())\n-\ttg.setenv(\"GOOS\", goos)\n-\ttg.run(\"env\", \"GOARCH\")\n-\tgoarch := strings.TrimSpace(tg.getStdout())\n-\ttg.setenv(\"GOARCH\", goarch)\n-\tfixbin := filepath.Join(goroot, \"pkg\", \"tool\", goos+\"_\"+goarch, \"fix\") + exeSuffix\n-\ttg.must(robustio.RemoveAll(fixbin))\n-\ttg.run(\"install\", \"cmd/fix\")\n-\ttg.wantExecutable(fixbin, \"did not install cmd/fix to $GOROOT/pkg/tool\")\n-\ttg.must(os.Remove(fixbin))\n-\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n-\ttg.run(\"install\", \"cmd/fix\")\n-\ttg.wantExecutable(fixbin, \"did not install cmd/fix to $GOROOT/pkg/tool with $GOBIN set\")\n-\ttg.unsetenv(\"GOBIN\")\n-\n-\t// gopath program installs into GOBIN\n-\ttg.tempFile(\"src/progname/p.go\", `package main; func main() {}`)\n-\ttg.setenv(\"GOBIN\", tg.path(\"gobin\"))\n-\ttg.run(\"install\", \"progname\")\n-\ttg.unsetenv(\"GOBIN\")\n-\ttg.wantExecutable(tg.path(\"gobin/progname\")+exeSuffix, \"did not install progname to $GOBIN/progname\")\n-\n-\t// gopath program installs into GOPATH/bin\n-\ttg.run(\"install\", \"progname\")\n-\ttg.wantExecutable(tg.path(\"bin/progname\")+exeSuffix, \"did not install progname to $GOPATH/bin/progname\")\n-}\n-\n-func TestRejectRelativeDotPathInGOPATHCommandLinePackage(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", \".\")\n-\ttg.runFail(\"build\", \"testdata/src/go-cmd-test/helloworld.go\")\n-\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n-}\n-\n-func TestRejectRelativePathsInGOPATH(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tsep := string(filepath.ListSeparator)\n-\ttg.setenv(\"GOPATH\", sep+filepath.Join(tg.pwd(), \"testdata\")+sep+\".\")\n-\ttg.runFail(\"build\", \"go-cmd-test\")\n-\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n-}\n-\n-func TestRejectRelativePathsInGOPATHCommandLinePackage(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", \"testdata\")\n-\ttg.runFail(\"build\", \"testdata/src/go-cmd-test/helloworld.go\")\n-\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n-}\n-\n-// Issue 21928.\n-func TestRejectBlankPathsInGOPATH(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\tsep := string(filepath.ListSeparator)\n-\ttg.setenv(\"GOPATH\", \" \"+sep+filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"build\", \"go-cmd-test\")\n-\ttg.grepStderr(\"GOPATH entry is relative\", \"expected an error message rejecting relative GOPATH entries\")\n-}\n-\n-// Issue 21928.\n-func TestIgnoreEmptyPathsInGOPATH(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"testdata/bin/go-cmd-test\" + exeSuffix)\n-\tsep := string(filepath.ListSeparator)\n-\ttg.setenv(\"GOPATH\", \"\"+sep+filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.run(\"install\", \"go-cmd-test\")\n-\ttg.wantExecutable(\"testdata/bin/go-cmd-test\"+exeSuffix, \"go install go-cmd-test did not write to testdata/bin/go-cmd-test\")\n-}\n-\n // Issue 4104.\n func TestGoTestWithPackageListedMultipleTimes(t *testing.T) {\n \ttooSlow(t)\n@@ -2547,57 +2162,6 @@ func TestCoverageDotImport(t *testing.T) {\n \tcheckCoverage(tg, data)\n }\n \n-// Check that coverage analysis uses set mode.\n-// Also check that coverage profiles merge correctly.\n-func TestCoverageUsesSetMode(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\ttooSlow(t)\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"testdata/cover.out\")\n-\ttg.run(\"test\", \"-short\", \"-cover\", \"encoding/binary\", \"errors\", \"-coverprofile=testdata/cover.out\")\n-\tdata := tg.getStdout() + tg.getStderr()\n-\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n-\t\tt.Error(err)\n-\t} else {\n-\t\tif !bytes.Contains(out, []byte(\"mode: set\")) {\n-\t\t\tt.Error(\"missing mode: set\")\n-\t\t}\n-\t\tif !bytes.Contains(out, []byte(\"errors.go\")) {\n-\t\t\tt.Error(\"missing errors.go\")\n-\t\t}\n-\t\tif !bytes.Contains(out, []byte(\"binary.go\")) {\n-\t\t\tt.Error(\"missing binary.go\")\n-\t\t}\n-\t\tif bytes.Count(out, []byte(\"mode: set\")) != 1 {\n-\t\t\tt.Error(\"too many mode: set\")\n-\t\t}\n-\t}\n-\tcheckCoverage(tg, data)\n-}\n-\n-func TestCoverageUsesAtomicModeForRace(t *testing.T) {\n-\ttooSlow(t)\n-\tif !canRace {\n-\t\tt.Skip(\"skipping because race detector not supported\")\n-\t}\n-\tskipIfGccgo(t, \"gccgo has no cover tool\")\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"testdata/cover.out\")\n-\ttg.run(\"test\", \"-short\", \"-race\", \"-cover\", \"encoding/binary\", \"-coverprofile=testdata/cover.out\")\n-\tdata := tg.getStdout() + tg.getStderr()\n-\tif out, err := ioutil.ReadFile(\"testdata/cover.out\"); err != nil {\n-\t\tt.Error(err)\n-\t} else {\n-\t\tif !bytes.Contains(out, []byte(\"mode: atomic\")) {\n-\t\t\tt.Error(\"missing mode: atomic\")\n-\t\t}\n-\t}\n-\tcheckCoverage(tg, data)\n-}\n-\n func TestCoverageSyncAtomicImport(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no cover tool\")\n \ttooSlow(t)\n@@ -3092,53 +2656,6 @@ func TestIssue7108(t *testing.T) {\n \ttg.runFail(\"test\", \"notest\")\n }\n \n-// cmd/go: go test -a foo does not rebuild regexp.\n-func TestIssue6844(t *testing.T) {\n-\tif testing.Short() {\n-\t\tt.Skip(\"don't rebuild the standard library in short mode\")\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.creatingTemp(\"deps.test\" + exeSuffix)\n-\ttg.run(\"test\", \"-x\", \"-a\", \"-c\", \"testdata/dep_test.go\")\n-\ttg.grepStderr(\"regexp\", \"go test -x -a -c testdata/dep-test.go did not rebuild regexp\")\n-}\n-\n-func TestBuildDashIInstallsDependencies(t *testing.T) {\n-\ttooSlow(t)\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.tempFile(\"src/x/y/foo/foo.go\", `package foo\n-\t\tfunc F() {}`)\n-\ttg.tempFile(\"src/x/y/bar/bar.go\", `package bar\n-\t\timport \"x/y/foo\"\n-\t\tfunc F() { foo.F() }`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\n-\t// don't let build -i overwrite runtime\n-\ttg.wantNotStale(\"runtime\", \"\", \"must be non-stale before build -i\")\n-\n-\tcheckbar := func(desc string) {\n-\t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n-\t\ttg.grepBoth(\"x/y/foo\", \"first build -i \"+desc+\" did not build x/y/foo\")\n-\t\ttg.run(\"build\", \"-v\", \"-i\", \"x/y/bar\")\n-\t\ttg.grepBothNot(\"x/y/foo\", \"second build -i \"+desc+\" built x/y/foo\")\n-\t}\n-\tcheckbar(\"pkg\")\n-\n-\ttg.creatingTemp(\"bar\" + exeSuffix)\n-\ttg.sleep()\n-\ttg.tempFile(\"src/x/y/foo/foo.go\", `package foo\n-\t\tfunc F() { F() }`)\n-\ttg.tempFile(\"src/x/y/bar/bar.go\", `package main\n-\t\timport \"x/y/foo\"\n-\t\tfunc main() { foo.F() }`)\n-\tcheckbar(\"cmd\")\n-}\n-\n func TestGoBuildTestOnly(t *testing.T) {\n \ttg := testgo(t)\n \tdefer tg.cleanup()\n@@ -3423,95 +2940,6 @@ func TestGoGetDotSlashDownload(t *testing.T) {\n \ttg.run(\"get\", \"./pprof_mac_fix\")\n }\n \n-// Test that you cannot import a main package.\n-// See golang.org/issue/4210 and golang.org/issue/17475.\n-func TestImportMain(t *testing.T) {\n-\ttooSlow(t)\n-\n-\ttg := testgo(t)\n-\ttg.parallel()\n-\tdefer tg.cleanup()\n-\n-\t// Importing package main from that package main's test should work.\n-\ttg.tempFile(\"src/x/main.go\", `package main\n-\t\tvar X int\n-\t\tfunc main() {}`)\n-\ttg.tempFile(\"src/x/main_test.go\", `package main_test\n-\t\timport xmain \"x\"\n-\t\timport \"testing\"\n-\t\tvar _ = xmain.X\n-\t\tfunc TestFoo(t *testing.T) {}\n-\t`)\n-\ttg.setenv(\"GOPATH\", tg.path(\".\"))\n-\ttg.creatingTemp(\"x\" + exeSuffix)\n-\ttg.run(\"build\", \"x\")\n-\ttg.run(\"test\", \"x\")\n-\n-\t// Importing package main from another package should fail.\n-\ttg.tempFile(\"src/p1/p.go\", `package p1\n-\t\timport xmain \"x\"\n-\t\tvar _ = xmain.X\n-\t`)\n-\ttg.runFail(\"build\", \"p1\")\n-\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n-\n-\t// ... even in that package's test.\n-\ttg.tempFile(\"src/p2/p.go\", `package p2\n-\t`)\n-\ttg.tempFile(\"src/p2/p_test.go\", `package p2\n-\t\timport xmain \"x\"\n-\t\timport \"testing\"\n-\t\tvar _ = xmain.X\n-\t\tfunc TestFoo(t *testing.T) {}\n-\t`)\n-\ttg.run(\"build\", \"p2\")\n-\ttg.runFail(\"test\", \"p2\")\n-\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n-\n-\t// ... even if that package's test is an xtest.\n-\ttg.tempFile(\"src/p3/p.go\", `package p\n-\t`)\n-\ttg.tempFile(\"src/p3/p_test.go\", `package p_test\n-\t\timport xmain \"x\"\n-\t\timport \"testing\"\n-\t\tvar _ = xmain.X\n-\t\tfunc TestFoo(t *testing.T) {}\n-\t`)\n-\ttg.run(\"build\", \"p3\")\n-\ttg.runFail(\"test\", \"p3\")\n-\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n-\n-\t// ... even if that package is a package main\n-\ttg.tempFile(\"src/p4/p.go\", `package main\n-\tfunc main() {}\n-\t`)\n-\ttg.tempFile(\"src/p4/p_test.go\", `package main\n-\t\timport xmain \"x\"\n-\t\timport \"testing\"\n-\t\tvar _ = xmain.X\n-\t\tfunc TestFoo(t *testing.T) {}\n-\t`)\n-\ttg.creatingTemp(\"p4\" + exeSuffix)\n-\ttg.run(\"build\", \"p4\")\n-\ttg.runFail(\"test\", \"p4\")\n-\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n-\n-\t// ... even if that package is a package main using an xtest.\n-\ttg.tempFile(\"src/p5/p.go\", `package main\n-\tfunc main() {}\n-\t`)\n-\ttg.tempFile(\"src/p5/p_test.go\", `package main_test\n-\t\timport xmain \"x\"\n-\t\timport \"testing\"\n-\t\tvar _ = xmain.X\n-\t\tfunc TestFoo(t *testing.T) {}\n-\t`)\n-\ttg.creatingTemp(\"p5\" + exeSuffix)\n-\ttg.run(\"build\", \"p5\")\n-\ttg.runFail(\"test\", \"p5\")\n-\ttg.grepStderr(\"import \\\"x\\\" is a program, not an importable package\", \"did not diagnose package main\")\n-}\n-\n // Test that you cannot use a local import in a package\n // accessed by a non-local import (found in a GOPATH/GOROOT).\n // See golang.org/issue/17475.\n@@ -3822,7 +3250,17 @@ func TestGoTestRaceInstallCgo(t *testing.T) {\n \tcgo := strings.TrimSpace(tg.stdout.String())\n \told, err := os.Stat(cgo)\n \ttg.must(err)\n-\ttg.run(\"test\", \"-race\", \"-i\", \"runtime/race\")\n+\n+\t// For this test, we don't actually care whether 'go test -race -i' succeeds.\n+\t// It may fail, for example, if GOROOT was installed from source as root and\n+\t// is now read-only.\n+\t// We only care that \u2014 regardless of whether it succeeds \u2014 it does not\n+\t// overwrite cmd/cgo.\n+\trunArgs := []string{\"test\", \"-race\", \"-i\", \"runtime/race\"}\n+\tif status := tg.doRun(runArgs); status != nil {\n+\t\ttg.t.Logf(\"go %v failure ignored: %v\", runArgs, status)\n+\t}\n+\n \tnew, err := os.Stat(cgo)\n \ttg.must(err)\n \tif !new.ModTime().Equal(old.ModTime()) {\n@@ -4688,23 +4126,19 @@ func copyFile(src, dst string, perm os.FileMode) error {\n \treturn err2\n }\n \n+// TestExecutableGOROOT verifies that the cmd/go binary itself uses\n+// os.Executable (when available) to locate GOROOT.\n func TestExecutableGOROOT(t *testing.T) {\n \tskipIfGccgo(t, \"gccgo has no GOROOT\")\n-\tif runtime.GOOS == \"openbsd\" {\n-\t\tt.Skipf(\"test case does not work on %s, missing os.Executable\", runtime.GOOS)\n-\t}\n \n-\t// Env with no GOROOT.\n-\tvar env []string\n-\tfor _, e := range os.Environ() {\n-\t\tif !strings.HasPrefix(e, \"GOROOT=\") {\n-\t\t\tenv = append(env, e)\n-\t\t}\n-\t}\n+\t// Note: Must not call tg methods inside subtests: tg is attached to outer t.\n+\ttg := testgo(t)\n+\ttg.unsetenv(\"GOROOT\")\n+\tdefer tg.cleanup()\n \n \tcheck := func(t *testing.T, exe, want string) {\n \t\tcmd := exec.Command(exe, \"env\", \"GOROOT\")\n-\t\tcmd.Env = env\n+\t\tcmd.Env = tg.env\n \t\tout, err := cmd.CombinedOutput()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"%s env GOROOT: %v, %s\", exe, err, out)\n@@ -4724,10 +4158,6 @@ func TestExecutableGOROOT(t *testing.T) {\n \t\t}\n \t}\n \n-\t// Note: Must not call tg methods inside subtests: tg is attached to outer t.\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\n \ttg.makeTempdir()\n \ttg.tempDir(\"new/bin\")\n \tnewGoTool := tg.path(\"new/bin/go\" + exeSuffix)\n@@ -4774,8 +4204,9 @@ func TestExecutableGOROOT(t *testing.T) {\n \t\t}\n \n \t\tcmd := exec.Command(newGoTool, \"run\", \"testdata/print_goroot.go\")\n-\t\tcmd.Env = env\n-\t\tout, err := cmd.CombinedOutput()\n+\t\tcmd.Env = tg.env\n+\t\tcmd.Stderr = os.Stderr\n+\t\tout, err := cmd.Output()\n \t\tif err != nil {\n \t\t\tt.Fatalf(\"%s run testdata/print_goroot.go: %v, %s\", newGoTool, err, out)\n \t\t}\n@@ -4807,36 +4238,6 @@ func TestNeedVersion(t *testing.T) {\n \ttg.grepStderr(\"compile\", \"does not match go tool version\")\n }\n \n-// Test that user can override default code generation flags.\n-func TestUserOverrideFlags(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo does not use -gcflags\")\n-\tif !canCgo {\n-\t\tt.Skip(\"skipping because cgo not enabled\")\n-\t}\n-\tif runtime.GOOS != \"linux\" {\n-\t\t// We are testing platform-independent code, so it's\n-\t\t// OK to skip cases that work differently.\n-\t\tt.Skipf(\"skipping on %s because test only works if c-archive implies -shared\", runtime.GOOS)\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\t// Don't call tg.parallel, as creating override.h and override.a may\n-\t// confuse other tests.\n-\ttg.tempFile(\"override.go\", `package main\n-\n-import \"C\"\n-\n-//export GoFunc\n-func GoFunc() {}\n-\n-func main() {}`)\n-\ttg.creatingTemp(\"override.a\")\n-\ttg.creatingTemp(\"override.h\")\n-\ttg.run(\"build\", \"-x\", \"-buildmode=c-archive\", \"-gcflags=all=-shared=false\", tg.path(\"override.go\"))\n-\ttg.grepStderr(\"compile .*-shared .*-shared=false\", \"user can not override code generation flag\")\n-}\n-\n func TestCgoFlagContainsSpace(t *testing.T) {\n \ttooSlow(t)\n \tif !canCgo {\n@@ -4939,35 +4340,31 @@ func TestTestRegexps(t *testing.T) {\n \t//\tBenchmarkXX is run but only with N=1, once\n \t//\tBenchmarkX/Y is run in full, twice\n \twant := `=== RUN   TestX\n+    TestX: x_test.go:6: LOG: X running\n === RUN   TestX/Y\n-    x_test.go:6: LOG: X running\n-        x_test.go:8: LOG: Y running\n+    TestX/Y: x_test.go:8: LOG: Y running\n === RUN   TestXX\n-    z_test.go:10: LOG: XX running\n+    TestXX: z_test.go:10: LOG: XX running\n === RUN   TestX\n+    TestX: x_test.go:6: LOG: X running\n === RUN   TestX/Y\n-    x_test.go:6: LOG: X running\n-        x_test.go:8: LOG: Y running\n+    TestX/Y: x_test.go:8: LOG: Y running\n === RUN   TestXX\n-    z_test.go:10: LOG: XX running\n---- BENCH: BenchmarkX/Y\n-    x_test.go:15: LOG: Y running N=1\n-    x_test.go:15: LOG: Y running N=100\n-    x_test.go:15: LOG: Y running N=10000\n-    x_test.go:15: LOG: Y running N=1000000\n-    x_test.go:15: LOG: Y running N=100000000\n-    x_test.go:15: LOG: Y running N=1000000000\n---- BENCH: BenchmarkX/Y\n-    x_test.go:15: LOG: Y running N=1\n-    x_test.go:15: LOG: Y running N=100\n-    x_test.go:15: LOG: Y running N=10000\n-    x_test.go:15: LOG: Y running N=1000000\n-    x_test.go:15: LOG: Y running N=100000000\n-    x_test.go:15: LOG: Y running N=1000000000\n---- BENCH: BenchmarkX\n-    x_test.go:13: LOG: X running N=1\n---- BENCH: BenchmarkXX\n-    z_test.go:18: LOG: XX running N=1\n+    TestXX: z_test.go:10: LOG: XX running\n+    BenchmarkX: x_test.go:13: LOG: X running N=1\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=10000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100000000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=10000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=100000000\n+    BenchmarkX/Y: x_test.go:15: LOG: Y running N=1000000000\n+    BenchmarkXX: z_test.go:18: LOG: XX running N=1\n `\n \n \thave := strings.Join(lines, \"\")\n@@ -5196,52 +4593,6 @@ func TestUpxCompression(t *testing.T) {\n \t}\n }\n \n-// Test that Go binaries can be run under QEMU in user-emulation mode\n-// (See issue #13024).\n-func TestQEMUUserMode(t *testing.T) {\n-\tif testing.Short() && testenv.Builder() == \"\" {\n-\t\tt.Skipf(\"skipping in -short mode on non-builder\")\n-\t}\n-\n-\ttestArchs := []struct {\n-\t\tg, qemu string\n-\t}{\n-\t\t{\"arm\", \"arm\"},\n-\t\t{\"arm64\", \"aarch64\"},\n-\t}\n-\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.tempFile(\"main.go\", `package main; import \"fmt\"; func main() { fmt.Print(\"hello qemu-user\") }`)\n-\ttg.parallel()\n-\tsrc, obj := tg.path(\"main.go\"), tg.path(\"main\")\n-\n-\tfor _, arch := range testArchs {\n-\t\tarch := arch\n-\t\tt.Run(arch.g, func(t *testing.T) {\n-\t\t\tqemu := \"qemu-\" + arch.qemu\n-\t\t\ttestenv.MustHaveExecPath(t, qemu)\n-\n-\t\t\tout, err := exec.Command(qemu, \"--version\").CombinedOutput()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"%s --version failed: %v\", qemu, err)\n-\t\t\t}\n-\n-\t\t\ttg.setenv(\"GOARCH\", arch.g)\n-\t\t\ttg.run(\"build\", \"-o\", obj, src)\n-\n-\t\t\tout, err = exec.Command(qemu, obj).CombinedOutput()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Logf(\"%s output:\\n%s\\n\", qemu, out)\n-\t\t\t\tt.Fatalf(\"%s failed with %v\", qemu, err)\n-\t\t\t}\n-\t\t\tif want := \"hello qemu-user\"; string(out) != want {\n-\t\t\t\tt.Errorf(\"bad output from %s:\\ngot %s; want %s\", qemu, out, want)\n-\t\t\t}\n-\t\t})\n-\t}\n-}\n-\n func TestCacheListStale(t *testing.T) {\n \ttooSlow(t)\n \tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n@@ -5282,38 +4633,6 @@ func TestCacheCoverage(t *testing.T) {\n \ttg.run(\"test\", \"-cover\", \"-short\", \"math\", \"strings\")\n }\n \n-func TestCacheVet(t *testing.T) {\n-\tskipIfGccgo(t, \"gccgo has no standard packages\")\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n-\t\tt.Skip(\"GODEBUG gocacheverify\")\n-\t}\n-\tif testing.Short() {\n-\t\t// In short mode, reuse cache.\n-\t\t// Test failures may be masked if the cache has just the right entries already\n-\t\t// (not a concern during all.bash, which runs in a clean cache).\n-\t\tif cfg.Getenv(\"GOCACHE\") == \"off\" {\n-\t\t\ttooSlow(t)\n-\t\t}\n-\t} else {\n-\t\ttg.makeTempdir()\n-\t\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n-\t}\n-\n-\t// Check that second vet reuses cgo-derived inputs.\n-\t// The first command could be build instead of vet,\n-\t// except that if the cache is empty and there's a net.a\n-\t// in GOROOT/pkg, the build will not bother to regenerate\n-\t// and cache the cgo outputs, whereas vet always will.\n-\ttg.run(\"vet\", \"os/user\")\n-\ttg.run(\"vet\", \"-x\", \"os/user\")\n-\ttg.grepStderrNot(`^(clang|gcc)`, \"should not have run compiler\")\n-\ttg.grepStderrNot(`[\\\\/]cgo `, \"should not have run cgo\")\n-}\n-\n func TestIssue22588(t *testing.T) {\n \t// Don't get confused by stderr coming from tools.\n \ttg := testgo(t)\n@@ -5503,122 +4822,6 @@ func TestTestCache(t *testing.T) {\n \t}\n }\n \n-func TestTestCacheInputs(t *testing.T) {\n-\ttooSlow(t)\n-\n-\tif strings.Contains(os.Getenv(\"GODEBUG\"), \"gocacheverify\") {\n-\t\tt.Skip(\"GODEBUG gocacheverify\")\n-\t}\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.parallel()\n-\ttg.makeTempdir()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.setenv(\"GOCACHE\", tg.path(\"cache\"))\n-\n-\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"))\n-\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"))\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"x\"), 0644))\n-\told := time.Now().Add(-1 * time.Minute)\n-\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old, old))\n-\tinfo, err := os.Stat(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tt.Logf(\"file.txt: old=%v, info.ModTime=%v\", old, info.ModTime()) // help debug when Chtimes lies about succeeding\n-\ttg.setenv(\"TESTKEY\", \"x\")\n-\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), []byte(\"#!/bin/sh\\nexit 0\\n\"), 0755))\n-\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), old, old))\n-\n-\ttg.run(\"test\", \"testcache\")\n-\ttg.run(\"test\", \"testcache\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.setenv(\"TESTKEY\", \"y\")\n-\ttg.run(\"test\", \"testcache\")\n-\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice env var change\")\n-\ttg.run(\"test\", \"testcache\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n-\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"xxx\"), 0644))\n-\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n-\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file size change\")\n-\ttg.run(\"test\", \"testcache\", \"-run=FileSize\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n-\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"xxxxx\"), 0644))\n-\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n-\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file size change\")\n-\ttg.run(\"test\", \"testcache\", \"-run=Chdir\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old, old))\n-\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n-\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), []byte(\"yyy\"), 0644))\n-\told2 := old.Add(10 * time.Second)\n-\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\"), old2, old2))\n-\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n-\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice file content change\")\n-\ttg.run(\"test\", \"testcache\", \"-run=FileContent\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n-\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\ttg.must(os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/file.txt\")))\n-\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n-\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice directory change\")\n-\ttg.run(\"test\", \"testcache\", \"-run=DirList\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\ttg.tempFile(\"file.txt\", \"\")\n-\ttg.must(ioutil.WriteFile(filepath.Join(tg.pwd(), \"testdata/src/testcache/testcachetmp_test.go\"), []byte(`package testcache\n-\n-\t\timport (\n-\t\t\t\"os\"\n-\t\t\t\"testing\"\n-\t\t)\n-\n-\t\tfunc TestExternalFile(t *testing.T) {\n-\t\t\tos.Open(`+fmt.Sprintf(\"%q\", tg.path(\"file.txt\"))+`)\n-\t\t\t_, err := os.Stat(`+fmt.Sprintf(\"%q\", tg.path(\"file.txt\"))+`)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t}\n-\t`), 0666))\n-\tdefer os.Remove(filepath.Join(tg.pwd(), \"testdata/src/testcache/testcachetmp_test.go\"))\n-\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n-\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\ttg.must(os.Remove(filepath.Join(tg.tempdir, \"file.txt\")))\n-\ttg.run(\"test\", \"testcache\", \"-run=ExternalFile\")\n-\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\n-\tswitch runtime.GOOS {\n-\tcase \"nacl\", \"plan9\", \"windows\":\n-\t\t// no shell scripts\n-\tdefault:\n-\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n-\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n-\t\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\t\ttg.must(os.Chtimes(filepath.Join(tg.pwd(), \"testdata/src/testcache/script.sh\"), old2, old2))\n-\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n-\t\ttg.grepStdoutNot(`\\(cached\\)`, \"did not notice script change\")\n-\t\ttg.run(\"test\", \"testcache\", \"-run=Exec\")\n-\t\ttg.grepStdout(`\\(cached\\)`, \"did not cache\")\n-\t}\n-}\n-\n func TestTestVet(t *testing.T) {\n \ttooSlow(t)\n \ttg := testgo(t)\n@@ -5761,14 +4964,6 @@ func TestInstallDeps(t *testing.T) {\n \ttg.mustExist(p1)\n }\n \n-func TestFmtLoadErrors(t *testing.T) {\n-\ttg := testgo(t)\n-\tdefer tg.cleanup()\n-\ttg.setenv(\"GOPATH\", filepath.Join(tg.pwd(), \"testdata\"))\n-\ttg.runFail(\"fmt\", \"does-not-exist\")\n-\ttg.run(\"fmt\", \"-n\", \"exclude\")\n-}\n-\n func TestGoTestMinusN(t *testing.T) {\n \t// Intent here is to verify that 'go test -n' works without crashing.\n \t// This reuses flag_test.go, but really any test would do."}, {"sha": "9bcab820ce65648dc2c632477592c1672f54acd8", "filename": "libgo/go/cmd/go/help_test.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fhelp_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,8 +2,6 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !nacl\n-\n package main_test\n \n import ("}, {"sha": "6727196816b56c620d8cee65aff4eec60d438658", "filename": "libgo/go/cmd/go/internal/base/flag.go", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fflag.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -33,3 +33,8 @@ func AddBuildFlagsNX(flags *flag.FlagSet) {\n \tflags.BoolVar(&cfg.BuildN, \"n\", false, \"\")\n \tflags.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n }\n+\n+// AddLoadFlags adds the -mod build flag to the flag set.\n+func AddLoadFlags(flags *flag.FlagSet) {\n+\tflags.StringVar(&cfg.BuildMod, \"mod\", \"\", \"\")\n+}"}, {"sha": "2b1507be27cb982c9c91695f504077241b768304", "filename": "libgo/go/cmd/go/internal/base/signal_unix.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fbase%2Fsignal_unix.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build aix darwin dragonfly freebsd hurd js linux nacl netbsd openbsd solaris\n+// +build aix darwin dragonfly freebsd hurd js linux netbsd openbsd solaris\n \n package base\n "}, {"sha": "879739876503b87caf00733c33fa2addb9447d00", "filename": "libgo/go/cmd/go/internal/cache/cache.go", "status": "modified", "additions": 51, "deletions": 18, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcache%2Fcache.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -74,7 +74,22 @@ func (c *Cache) fileName(id [HashSize]byte, key string) string {\n \treturn filepath.Join(c.dir, fmt.Sprintf(\"%02x\", id[0]), fmt.Sprintf(\"%x\", id)+\"-\"+key)\n }\n \n-var errMissing = errors.New(\"cache entry not found\")\n+// An entryNotFoundError indicates that a cache entry was not found, with an\n+// optional underlying reason.\n+type entryNotFoundError struct {\n+\tErr error\n+}\n+\n+func (e *entryNotFoundError) Error() string {\n+\tif e.Err == nil {\n+\t\treturn \"cache entry not found\"\n+\t}\n+\treturn fmt.Sprintf(\"cache entry not found: %v\", e.Err)\n+}\n+\n+func (e *entryNotFoundError) Unwrap() error {\n+\treturn e.Err\n+}\n \n const (\n \t// action entry file is \"v1 <hex id> <hex out> <decimal size space-padded to 20 bytes> <unixnano space-padded to 20 bytes>\\n\"\n@@ -93,6 +108,8 @@ const (\n // GODEBUG=gocacheverify=1.\n var verify = false\n \n+var errVerifyMode = errors.New(\"gocachverify=1\")\n+\n // DebugTest is set when GODEBUG=gocachetest=1 is in the environment.\n var DebugTest = false\n \n@@ -121,7 +138,7 @@ func initEnv() {\n // saved file for that output ID is still available.\n func (c *Cache) Get(id ActionID) (Entry, error) {\n \tif verify {\n-\t\treturn Entry{}, errMissing\n+\t\treturn Entry{}, &entryNotFoundError{Err: errVerifyMode}\n \t}\n \treturn c.get(id)\n }\n@@ -134,47 +151,60 @@ type Entry struct {\n \n // get is Get but does not respect verify mode, so that Put can use it.\n func (c *Cache) get(id ActionID) (Entry, error) {\n-\tmissing := func() (Entry, error) {\n-\t\treturn Entry{}, errMissing\n+\tmissing := func(reason error) (Entry, error) {\n+\t\treturn Entry{}, &entryNotFoundError{Err: reason}\n \t}\n \tf, err := os.Open(c.fileName(id, \"a\"))\n \tif err != nil {\n-\t\treturn missing()\n+\t\treturn missing(err)\n \t}\n \tdefer f.Close()\n \tentry := make([]byte, entrySize+1) // +1 to detect whether f is too long\n-\tif n, err := io.ReadFull(f, entry); n != entrySize || err != io.ErrUnexpectedEOF {\n-\t\treturn missing()\n+\tif n, err := io.ReadFull(f, entry); n > entrySize {\n+\t\treturn missing(errors.New(\"too long\"))\n+\t} else if err != io.ErrUnexpectedEOF {\n+\t\tif err == io.EOF {\n+\t\t\treturn missing(errors.New(\"file is empty\"))\n+\t\t}\n+\t\treturn missing(err)\n+\t} else if n < entrySize {\n+\t\treturn missing(errors.New(\"entry file incomplete\"))\n \t}\n \tif entry[0] != 'v' || entry[1] != '1' || entry[2] != ' ' || entry[3+hexSize] != ' ' || entry[3+hexSize+1+hexSize] != ' ' || entry[3+hexSize+1+hexSize+1+20] != ' ' || entry[entrySize-1] != '\\n' {\n-\t\treturn missing()\n+\t\treturn missing(errors.New(\"invalid header\"))\n \t}\n \teid, entry := entry[3:3+hexSize], entry[3+hexSize:]\n \teout, entry := entry[1:1+hexSize], entry[1+hexSize:]\n \tesize, entry := entry[1:1+20], entry[1+20:]\n \tetime, entry := entry[1:1+20], entry[1+20:]\n \tvar buf [HashSize]byte\n-\tif _, err := hex.Decode(buf[:], eid); err != nil || buf != id {\n-\t\treturn missing()\n+\tif _, err := hex.Decode(buf[:], eid); err != nil {\n+\t\treturn missing(fmt.Errorf(\"decoding ID: %v\", err))\n+\t} else if buf != id {\n+\t\treturn missing(errors.New(\"mismatched ID\"))\n \t}\n \tif _, err := hex.Decode(buf[:], eout); err != nil {\n-\t\treturn missing()\n+\t\treturn missing(fmt.Errorf(\"decoding output ID: %v\", err))\n \t}\n \ti := 0\n \tfor i < len(esize) && esize[i] == ' ' {\n \t\ti++\n \t}\n \tsize, err := strconv.ParseInt(string(esize[i:]), 10, 64)\n-\tif err != nil || size < 0 {\n-\t\treturn missing()\n+\tif err != nil {\n+\t\treturn missing(fmt.Errorf(\"parsing size: %v\", err))\n+\t} else if size < 0 {\n+\t\treturn missing(errors.New(\"negative size\"))\n \t}\n \ti = 0\n \tfor i < len(etime) && etime[i] == ' ' {\n \t\ti++\n \t}\n \ttm, err := strconv.ParseInt(string(etime[i:]), 10, 64)\n-\tif err != nil || tm < 0 {\n-\t\treturn missing()\n+\tif err != nil {\n+\t\treturn missing(fmt.Errorf(\"parsing timestamp: %v\", err))\n+\t} else if tm < 0 {\n+\t\treturn missing(errors.New(\"negative timestamp\"))\n \t}\n \n \tc.used(c.fileName(id, \"a\"))\n@@ -191,8 +221,11 @@ func (c *Cache) GetFile(id ActionID) (file string, entry Entry, err error) {\n \t}\n \tfile = c.OutputFile(entry.OutputID)\n \tinfo, err := os.Stat(file)\n-\tif err != nil || info.Size() != entry.Size {\n-\t\treturn \"\", Entry{}, errMissing\n+\tif err != nil {\n+\t\treturn \"\", Entry{}, &entryNotFoundError{Err: err}\n+\t}\n+\tif info.Size() != entry.Size {\n+\t\treturn \"\", Entry{}, &entryNotFoundError{Err: errors.New(\"file incomplete\")}\n \t}\n \treturn file, entry, nil\n }\n@@ -207,7 +240,7 @@ func (c *Cache) GetBytes(id ActionID) ([]byte, Entry, error) {\n \t}\n \tdata, _ := ioutil.ReadFile(c.OutputFile(entry.OutputID))\n \tif sha256.Sum256(data) != entry.OutputID {\n-\t\treturn nil, entry, errMissing\n+\t\treturn nil, entry, &entryNotFoundError{Err: errors.New(\"bad checksum\")}\n \t}\n \treturn data, entry, nil\n }"}, {"sha": "61dc6bdda664779c6f2e29dd39f97072526f6850", "filename": "libgo/go/cmd/go/internal/cfg/cfg.go", "status": "modified", "additions": 10, "deletions": 5, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fcfg%2Fcfg.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -27,6 +27,7 @@ var (\n \tBuildBuildmode         string // -buildmode flag\n \tBuildContext           = defaultContext()\n \tBuildMod               string             // -mod flag\n+\tBuildModReason         string             // reason -mod flag is set, if set by default\n \tBuildI                 bool               // -i flag\n \tBuildLinkshared        bool               // -linkshared flag\n \tBuildMSan              bool               // -msan flag\n@@ -44,6 +45,9 @@ var (\n \tBuildWork              bool // -work flag\n \tBuildX                 bool // -x flag\n \n+\tModCacheRW bool   // -modcacherw flag\n+\tModFile    string // -modfile flag\n+\n \tCmdName string // \"build\", \"install\", \"list\", \"mod tidy\", etc.\n \n \tDebugActiongraph string // -debug-actiongraph flag (undocumented, unstable)\n@@ -241,11 +245,12 @@ var (\n \tGOPPC64  = envOr(\"GOPPC64\", fmt.Sprintf(\"%s%d\", \"power\", objabi.GOPPC64))\n \tGOWASM   = envOr(\"GOWASM\", fmt.Sprint(objabi.GOWASM))\n \n-\tGOPROXY   = envOr(\"GOPROXY\", \"https://proxy.golang.org,direct\")\n-\tGOSUMDB   = envOr(\"GOSUMDB\", \"sum.golang.org\")\n-\tGOPRIVATE = Getenv(\"GOPRIVATE\")\n-\tGONOPROXY = envOr(\"GONOPROXY\", GOPRIVATE)\n-\tGONOSUMDB = envOr(\"GONOSUMDB\", GOPRIVATE)\n+\tGOPROXY    = envOr(\"GOPROXY\", \"https://proxy.golang.org,direct\")\n+\tGOSUMDB    = envOr(\"GOSUMDB\", \"sum.golang.org\")\n+\tGOPRIVATE  = Getenv(\"GOPRIVATE\")\n+\tGONOPROXY  = envOr(\"GONOPROXY\", GOPRIVATE)\n+\tGONOSUMDB  = envOr(\"GONOSUMDB\", GOPRIVATE)\n+\tGOINSECURE = Getenv(\"GOINSECURE\")\n )\n \n // GetArchEnv returns the name and setting of the"}, {"sha": "5f4bf4e6c8eb022e91f46790b48047b33c8a3bc9", "filename": "libgo/go/cmd/go/internal/clean/clean.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fclean%2Fclean.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -102,7 +102,7 @@ func init() {\n \t// mentioned explicitly in the docs but they\n \t// are part of the build flags.\n \n-\twork.AddBuildFlags(CmdClean)\n+\twork.AddBuildFlags(CmdClean, work.DefaultBuildFlags)\n }\n \n func runClean(cmd *base.Command, args []string) {"}, {"sha": "ed463c1949cca66788742080dd382336fba3450d", "filename": "libgo/go/cmd/go/internal/dirhash/hash_test.go", "status": "removed", "additions": 0, "deletions": 135, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdirhash%2Fhash_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,135 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package dirhash\n-\n-import (\n-\t\"archive/zip\"\n-\t\"crypto/sha256\"\n-\t\"encoding/base64\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func h(s string) string {\n-\treturn fmt.Sprintf(\"%x\", sha256.Sum256([]byte(s)))\n-}\n-\n-func htop(k string, s string) string {\n-\tsum := sha256.Sum256([]byte(s))\n-\treturn k + \":\" + base64.StdEncoding.EncodeToString(sum[:])\n-}\n-\n-func TestHash1(t *testing.T) {\n-\tfiles := []string{\"xyz\", \"abc\"}\n-\topen := func(name string) (io.ReadCloser, error) {\n-\t\treturn ioutil.NopCloser(strings.NewReader(\"data for \" + name)), nil\n-\t}\n-\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"abc\", h(\"data for xyz\"), \"xyz\"))\n-\tout, err := Hash1(files, open)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif out != want {\n-\t\tt.Errorf(\"Hash1(...) = %s, want %s\", out, want)\n-\t}\n-\n-\t_, err = Hash1([]string{\"xyz\", \"a\\nbc\"}, open)\n-\tif err == nil {\n-\t\tt.Error(\"Hash1: expected error on newline in filenames\")\n-\t}\n-}\n-\n-func TestHashDir(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"dirhash-test-\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\tif err := ioutil.WriteFile(filepath.Join(dir, \"xyz\"), []byte(\"data for xyz\"), 0666); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif err := ioutil.WriteFile(filepath.Join(dir, \"abc\"), []byte(\"data for abc\"), 0666); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"prefix/abc\", h(\"data for xyz\"), \"prefix/xyz\"))\n-\tout, err := HashDir(dir, \"prefix\", Hash1)\n-\tif err != nil {\n-\t\tt.Fatalf(\"HashDir: %v\", err)\n-\t}\n-\tif out != want {\n-\t\tt.Errorf(\"HashDir(...) = %s, want %s\", out, want)\n-\t}\n-}\n-\n-func TestHashZip(t *testing.T) {\n-\tf, err := ioutil.TempFile(\"\", \"dirhash-test-\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.Remove(f.Name())\n-\tdefer f.Close()\n-\n-\tz := zip.NewWriter(f)\n-\tw, err := z.Create(\"prefix/xyz\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tw.Write([]byte(\"data for xyz\"))\n-\tw, err = z.Create(\"prefix/abc\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tw.Write([]byte(\"data for abc\"))\n-\tif err := z.Close(); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif err := f.Close(); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\twant := htop(\"h1\", fmt.Sprintf(\"%s  %s\\n%s  %s\\n\", h(\"data for abc\"), \"prefix/abc\", h(\"data for xyz\"), \"prefix/xyz\"))\n-\tout, err := HashZip(f.Name(), Hash1)\n-\tif err != nil {\n-\t\tt.Fatalf(\"HashDir: %v\", err)\n-\t}\n-\tif out != want {\n-\t\tt.Errorf(\"HashDir(...) = %s, want %s\", out, want)\n-\t}\n-}\n-\n-func TestDirFiles(t *testing.T) {\n-\tdir, err := ioutil.TempDir(\"\", \"dirfiles-test-\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer os.RemoveAll(dir)\n-\tif err := ioutil.WriteFile(filepath.Join(dir, \"xyz\"), []byte(\"data for xyz\"), 0666); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif err := ioutil.WriteFile(filepath.Join(dir, \"abc\"), []byte(\"data for abc\"), 0666); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif err := os.Mkdir(filepath.Join(dir, \"subdir\"), 0777); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif err := ioutil.WriteFile(filepath.Join(dir, \"subdir\", \"xyz\"), []byte(\"data for subdir xyz\"), 0666); err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tprefix := \"foo/bar@v2.3.4\"\n-\tout, err := DirFiles(dir, prefix)\n-\tif err != nil {\n-\t\tt.Fatalf(\"DirFiles: %v\", err)\n-\t}\n-\tfor _, file := range out {\n-\t\tif !strings.HasPrefix(file, prefix) {\n-\t\t\tt.Errorf(\"Dir file = %s, want prefix %s\", file, prefix)\n-\t\t}\n-\t}\n-}"}, {"sha": "4ff08bb9289a09bee8e84dd31cdbe69a987e567b", "filename": "libgo/go/cmd/go/internal/doc/doc.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fdoc%2Fdoc.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -114,6 +114,8 @@ Flags:\n \t\tTreat a command (package main) like a regular package.\n \t\tOtherwise package main's exported symbols are hidden\n \t\twhen showing the package's top-level documentation.\n+\t-short\n+\t\tOne-line representation for each symbol.\n \t-src\n \t\tShow the full source code for the symbol. This will\n \t\tdisplay the full Go source of its declaration and"}, {"sha": "d2d5ed95076a2f202bc0a0a35b6c75ce89293fbf", "filename": "libgo/go/cmd/go/internal/envcmd/env.go", "status": "modified", "additions": 66, "deletions": 3, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fenvcmd%2Fenv.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -8,6 +8,7 @@ package envcmd\n import (\n \t\"encoding/json\"\n \t\"fmt\"\n+\t\"go/build\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path/filepath\"\n@@ -75,6 +76,7 @@ func MkEnv() []cfg.EnvVar {\n \t\t{Name: \"GOFLAGS\", Value: cfg.Getenv(\"GOFLAGS\")},\n \t\t{Name: \"GOHOSTARCH\", Value: runtime.GOARCH},\n \t\t{Name: \"GOHOSTOS\", Value: runtime.GOOS},\n+\t\t{Name: \"GOINSECURE\", Value: cfg.GOINSECURE},\n \t\t{Name: \"GONOPROXY\", Value: cfg.GONOPROXY},\n \t\t{Name: \"GONOSUMDB\", Value: cfg.GONOSUMDB},\n \t\t{Name: \"GOOS\", Value: cfg.Goos},\n@@ -237,7 +239,7 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t\tbase.Fatalf(\"go env -w: arguments must be KEY=VALUE: invalid argument: %s\", arg)\n \t\t\t}\n \t\t\tkey, val := arg[:i], arg[i+1:]\n-\t\t\tif err := checkEnvWrite(key, val, env); err != nil {\n+\t\t\tif err := checkEnvWrite(key, val); err != nil {\n \t\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n \t\t\t}\n \t\t\tif _, ok := add[key]; ok {\n@@ -248,6 +250,21 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"warning: go env -w %s=... does not override conflicting OS environment variable\\n\", key)\n \t\t\t}\n \t\t}\n+\n+\t\tgoos, okGOOS := add[\"GOOS\"]\n+\t\tgoarch, okGOARCH := add[\"GOARCH\"]\n+\t\tif okGOOS || okGOARCH {\n+\t\t\tif !okGOOS {\n+\t\t\t\tgoos = cfg.Goos\n+\t\t\t}\n+\t\t\tif !okGOARCH {\n+\t\t\t\tgoarch = cfg.Goarch\n+\t\t\t}\n+\t\t\tif err := work.CheckGOOSARCHPair(goos, goarch); err != nil {\n+\t\t\t\tbase.Fatalf(\"go env -w: %v\", err)\n+\t\t\t}\n+\t\t}\n+\n \t\tupdateEnvFile(add, nil)\n \t\treturn\n \t}\n@@ -259,11 +276,29 @@ func runEnv(cmd *base.Command, args []string) {\n \t\t}\n \t\tdel := make(map[string]bool)\n \t\tfor _, arg := range args {\n-\t\t\tif err := checkEnvWrite(arg, \"\", env); err != nil {\n+\t\t\tif err := checkEnvWrite(arg, \"\"); err != nil {\n \t\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n \t\t\t}\n \t\t\tdel[arg] = true\n \t\t}\n+\t\tif del[\"GOOS\"] || del[\"GOARCH\"] {\n+\t\t\tgoos, goarch := cfg.Goos, cfg.Goarch\n+\t\t\tif del[\"GOOS\"] {\n+\t\t\t\tgoos = getOrigEnv(\"GOOS\")\n+\t\t\t\tif goos == \"\" {\n+\t\t\t\t\tgoos = build.Default.GOOS\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif del[\"GOARCH\"] {\n+\t\t\t\tgoarch = getOrigEnv(\"GOARCH\")\n+\t\t\t\tif goarch == \"\" {\n+\t\t\t\t\tgoarch = build.Default.GOARCH\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif err := work.CheckGOOSARCHPair(goos, goarch); err != nil {\n+\t\t\t\tbase.Fatalf(\"go env -u: %v\", err)\n+\t\t\t}\n+\t\t}\n \t\tupdateEnvFile(nil, del)\n \t\treturn\n \t}\n@@ -330,7 +365,16 @@ func printEnvAsJSON(env []cfg.EnvVar) {\n \t}\n }\n \n-func checkEnvWrite(key, val string, env []cfg.EnvVar) error {\n+func getOrigEnv(key string) string {\n+\tfor _, v := range cfg.OrigEnv {\n+\t\tif strings.HasPrefix(v, key+\"=\") {\n+\t\t\treturn strings.TrimPrefix(v, key+\"=\")\n+\t\t}\n+\t}\n+\treturn \"\"\n+}\n+\n+func checkEnvWrite(key, val string) error {\n \tswitch key {\n \tcase \"GOEXE\", \"GOGCCFLAGS\", \"GOHOSTARCH\", \"GOHOSTOS\", \"GOMOD\", \"GOTOOLDIR\":\n \t\treturn fmt.Errorf(\"%s cannot be modified\", key)\n@@ -343,6 +387,25 @@ func checkEnvWrite(key, val string, env []cfg.EnvVar) error {\n \t\treturn fmt.Errorf(\"unknown go command variable %s\", key)\n \t}\n \n+\t// Some variables can only have one of a few valid values. If set to an\n+\t// invalid value, the next cmd/go invocation might fail immediately,\n+\t// even 'go env -w' itself.\n+\tswitch key {\n+\tcase \"GO111MODULE\":\n+\t\tswitch val {\n+\t\tcase \"\", \"auto\", \"on\", \"off\":\n+\t\tdefault:\n+\t\t\treturn fmt.Errorf(\"invalid %s value %q\", key, val)\n+\t\t}\n+\tcase \"GOPATH\":\n+\t\tif strings.HasPrefix(val, \"~\") {\n+\t\t\treturn fmt.Errorf(\"GOPATH entry cannot start with shell metacharacter '~': %q\", val)\n+\t\t}\n+\t\tif !filepath.IsAbs(val) && val != \"\" {\n+\t\t\treturn fmt.Errorf(\"GOPATH entry is relative; must be absolute path: %q\", val)\n+\t\t}\n+\t}\n+\n \tif !utf8.ValidString(val) {\n \t\treturn fmt.Errorf(\"invalid UTF-8 in %s=... value\", key)\n \t}"}, {"sha": "408af52ffa016632d01ec4d91fed1a6f4ce378d6", "filename": "libgo/go/cmd/go/internal/fmtcmd/fmt.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ffmtcmd%2Ffmt.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -22,6 +22,7 @@ import (\n \n func init() {\n \tbase.AddBuildFlagsNX(&CmdFmt.Flag)\n+\tbase.AddLoadFlags(&CmdFmt.Flag)\n }\n \n var CmdFmt = &base.Command{\n@@ -38,6 +39,9 @@ For more about specifying packages, see 'go help packages'.\n The -n flag prints commands that would be executed.\n The -x flag prints commands as they are executed.\n \n+The -mod flag's value sets which module download mode\n+to use: readonly or vendor. See 'go help modules' for more.\n+\n To run gofmt with specific options, run gofmt itself.\n \n See also: go fix, go vet.\n@@ -68,7 +72,7 @@ func runFmt(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \t\t}\n \t\tif pkg.Error != nil {\n-\t\t\tif strings.HasPrefix(pkg.Error.Err, \"build constraints exclude all Go files\") {\n+\t\t\tif strings.HasPrefix(pkg.Error.Err.Error(), \"build constraints exclude all Go files\") {\n \t\t\t\t// Skip this error, as we will format\n \t\t\t\t// all files regardless.\n \t\t\t} else {"}, {"sha": "198ca1c1b9486703aebb1c4381b2d9af23e85f13", "filename": "libgo/go/cmd/go/internal/generate/generate.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fgenerate%2Fgenerate.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -149,7 +149,7 @@ var (\n )\n \n func init() {\n-\twork.AddBuildFlags(CmdGenerate)\n+\twork.AddBuildFlags(CmdGenerate, work.DefaultBuildFlags)\n \tCmdGenerate.Flag.StringVar(&generateRunFlag, \"run\", \"\", \"\")\n }\n "}, {"sha": "afa6ef455f933da2b985eeaee8b185fa3f3a9687", "filename": "libgo/go/cmd/go/internal/get/discovery.go", "status": "modified", "additions": 8, "deletions": 8, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fdiscovery.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -11,15 +11,15 @@ import (\n \t\"strings\"\n )\n \n-// charsetReader returns a reader for the given charset. Currently\n-// it only supports UTF-8 and ASCII. Otherwise, it returns a meaningful\n+// charsetReader returns a reader that converts from the given charset to UTF-8.\n+// Currently it only supports UTF-8 and ASCII. Otherwise, it returns a meaningful\n // error which is printed by go get, so the user can find why the package\n // wasn't downloaded if the encoding is not supported. Note that, in\n // order to reduce potential errors, ASCII is treated as UTF-8 (i.e. characters\n // greater than 0x7f are not rejected).\n func charsetReader(charset string, input io.Reader) (io.Reader, error) {\n \tswitch strings.ToLower(charset) {\n-\tcase \"ascii\":\n+\tcase \"utf-8\", \"ascii\":\n \t\treturn input, nil\n \tdefault:\n \t\treturn nil, fmt.Errorf(\"can't decode XML document using charset %q\", charset)\n@@ -28,16 +28,16 @@ func charsetReader(charset string, input io.Reader) (io.Reader, error) {\n \n // parseMetaGoImports returns meta imports from the HTML in r.\n // Parsing ends at the end of the <head> section or the beginning of the <body>.\n-func parseMetaGoImports(r io.Reader, mod ModuleMode) (imports []metaImport, err error) {\n+func parseMetaGoImports(r io.Reader, mod ModuleMode) ([]metaImport, error) {\n \td := xml.NewDecoder(r)\n \td.CharsetReader = charsetReader\n \td.Strict = false\n-\tvar t xml.Token\n+\tvar imports []metaImport\n \tfor {\n-\t\tt, err = d.RawToken()\n+\t\tt, err := d.RawToken()\n \t\tif err != nil {\n-\t\t\tif err == io.EOF || len(imports) > 0 {\n-\t\t\t\terr = nil\n+\t\t\tif err != io.EOF && len(imports) == 0 {\n+\t\t\t\treturn nil, err\n \t\t\t}\n \t\t\tbreak\n \t\t}"}, {"sha": "500e3e0da6dd1621f610205f53108e605ff9dbb6", "filename": "libgo/go/cmd/go/internal/get/get.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fget.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -108,7 +108,7 @@ var (\n )\n \n func init() {\n-\twork.AddBuildFlags(CmdGet)\n+\twork.AddBuildFlags(CmdGet, work.OmitModFlag|work.OmitModCommonFlags)\n \tCmdGet.Run = runGet // break init loop\n \tCmdGet.Flag.BoolVar(&Insecure, \"insecure\", Insecure, \"\")\n }\n@@ -274,7 +274,7 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\tstk.Push(arg)\n \t\terr := downloadPackage(p)\n \t\tif err != nil {\n-\t\t\tbase.Errorf(\"%s\", &load.PackageError{ImportStack: stk.Copy(), Err: err.Error()})\n+\t\t\tbase.Errorf(\"%s\", &load.PackageError{ImportStack: stk.Copy(), Err: err})\n \t\t\tstk.Pop()\n \t\t\treturn\n \t\t}\n@@ -355,7 +355,7 @@ func download(arg string, parent *load.Package, stk *load.ImportStack, mode int)\n \t\t\t\tstk.Push(path)\n \t\t\t\terr := &load.PackageError{\n \t\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\t\tErr:         \"must be imported as \" + path[j+len(\"vendor/\"):],\n+\t\t\t\t\tErr:         load.ImportErrorf(path, \"%s must be imported as %s\", path, path[j+len(\"vendor/\"):]),\n \t\t\t\t}\n \t\t\t\tstk.Pop()\n \t\t\t\tbase.Errorf(\"%s\", err)"}, {"sha": "ce2e0cdd709828efab7803c1df744152888e4105", "filename": "libgo/go/cmd/go/internal/get/path.go", "status": "modified", "additions": 1, "deletions": 4, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fpath.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -11,7 +11,7 @@ import (\n \t\"unicode/utf8\"\n )\n \n-// The following functions are copied verbatim from cmd/go/internal/module/module.go,\n+// The following functions are copied verbatim from golang.org/x/mod/module/module.go,\n // with a change to additionally reject Windows short-names,\n // and one to accept arbitrary letters (golang.org/issue/29101).\n //\n@@ -44,9 +44,6 @@ func checkPath(path string, fileName bool) error {\n \tif path[0] == '-' {\n \t\treturn fmt.Errorf(\"leading dash\")\n \t}\n-\tif strings.Contains(path, \"..\") {\n-\t\treturn fmt.Errorf(\"double dot\")\n-\t}\n \tif strings.Contains(path, \"//\") {\n \t\treturn fmt.Errorf(\"double slash\")\n \t}"}, {"sha": "2e4d6388cfe790b4f4337a04febe9eef125dda99", "filename": "libgo/go/cmd/go/internal/get/vcs.go", "status": "modified", "additions": 47, "deletions": 31, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fget%2Fvcs.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -21,6 +21,7 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/web\"\n )\n \n@@ -531,12 +532,12 @@ func (v *vcsCmd) tagSync(dir, tag string) error {\n // A vcsPath describes how to convert an import path into a\n // version control system and repository name.\n type vcsPath struct {\n-\tprefix string                              // prefix this description applies to\n-\tregexp *lazyregexp.Regexp                  // compiled pattern for import path\n-\trepo   string                              // repository to use (expand with match of re)\n-\tvcs    string                              // version control system to use (expand with match of re)\n-\tcheck  func(match map[string]string) error // additional checks\n-\tping   bool                                // ping for scheme to use to download repo\n+\tprefix         string                              // prefix this description applies to\n+\tregexp         *lazyregexp.Regexp                  // compiled pattern for import path\n+\trepo           string                              // repository to use (expand with match of re)\n+\tvcs            string                              // version control system to use (expand with match of re)\n+\tcheck          func(match map[string]string) error // additional checks\n+\tschemelessRepo bool                                // if true, the repo pattern lacks a scheme\n }\n \n // vcsFromDir inspects dir and its parents to determine the\n@@ -657,15 +658,15 @@ const (\n // RepoRootForImportPath analyzes importPath to determine the\n // version control system, and code repository to use.\n func RepoRootForImportPath(importPath string, mod ModuleMode, security web.SecurityMode) (*RepoRoot, error) {\n-\trr, err := repoRootFromVCSPaths(importPath, \"\", security, vcsPaths)\n+\trr, err := repoRootFromVCSPaths(importPath, security, vcsPaths)\n \tif err == errUnknownSite {\n \t\trr, err = repoRootForImportDynamic(importPath, mod, security)\n \t\tif err != nil {\n-\t\t\terr = fmt.Errorf(\"unrecognized import path %q (%v)\", importPath, err)\n+\t\t\terr = load.ImportErrorf(importPath, \"unrecognized import path %q: %v\", importPath, err)\n \t\t}\n \t}\n \tif err != nil {\n-\t\trr1, err1 := repoRootFromVCSPaths(importPath, \"\", security, vcsPathsAfterDynamic)\n+\t\trr1, err1 := repoRootFromVCSPaths(importPath, security, vcsPathsAfterDynamic)\n \t\tif err1 == nil {\n \t\t\trr = rr1\n \t\t\terr = nil\n@@ -676,7 +677,7 @@ func RepoRootForImportPath(importPath string, mod ModuleMode, security web.Secur\n \tif err == nil && strings.Contains(importPath, \"...\") && strings.Contains(rr.Root, \"...\") {\n \t\t// Do not allow wildcards in the repo root.\n \t\trr = nil\n-\t\terr = fmt.Errorf(\"cannot expand ... in %q\", importPath)\n+\t\terr = load.ImportErrorf(importPath, \"cannot expand ... in %q\", importPath)\n \t}\n \treturn rr, err\n }\n@@ -685,8 +686,7 @@ var errUnknownSite = errors.New(\"dynamic lookup required to find mapping\")\n \n // repoRootFromVCSPaths attempts to map importPath to a repoRoot\n // using the mappings defined in vcsPaths.\n-// If scheme is non-empty, that scheme is forced.\n-func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode, vcsPaths []*vcsPath) (*RepoRoot, error) {\n+func repoRootFromVCSPaths(importPath string, security web.SecurityMode, vcsPaths []*vcsPath) (*RepoRoot, error) {\n \t// A common error is to use https://packagepath because that's what\n \t// hg and git require. Diagnose this helpfully.\n \tif prefix := httpPrefix(importPath); prefix != \"\" {\n@@ -701,7 +701,7 @@ func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode,\n \t\tm := srv.regexp.FindStringSubmatch(importPath)\n \t\tif m == nil {\n \t\t\tif srv.prefix != \"\" {\n-\t\t\t\treturn nil, fmt.Errorf(\"invalid %s import path %q\", srv.prefix, importPath)\n+\t\t\t\treturn nil, load.ImportErrorf(importPath, \"invalid %s import path %q\", srv.prefix, importPath)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n@@ -731,26 +731,28 @@ func repoRootFromVCSPaths(importPath, scheme string, security web.SecurityMode,\n \t\tif vcs == nil {\n \t\t\treturn nil, fmt.Errorf(\"unknown version control system %q\", match[\"vcs\"])\n \t\t}\n-\t\tif srv.ping {\n-\t\t\tif scheme != \"\" {\n-\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n-\t\t\t} else {\n-\t\t\t\tfor _, scheme := range vcs.scheme {\n-\t\t\t\t\tif security == web.SecureOnly && !vcs.isSecureScheme(scheme) {\n+\t\tvar repoURL string\n+\t\tif !srv.schemelessRepo {\n+\t\t\trepoURL = match[\"repo\"]\n+\t\t} else {\n+\t\t\tscheme := vcs.scheme[0] // default to first scheme\n+\t\t\trepo := match[\"repo\"]\n+\t\t\tif vcs.pingCmd != \"\" {\n+\t\t\t\t// If we know how to test schemes, scan to find one.\n+\t\t\t\tfor _, s := range vcs.scheme {\n+\t\t\t\t\tif security == web.SecureOnly && !vcs.isSecureScheme(s) {\n \t\t\t\t\t\tcontinue\n \t\t\t\t\t}\n-\t\t\t\t\tif vcs.pingCmd != \"\" && vcs.ping(scheme, match[\"repo\"]) == nil {\n-\t\t\t\t\t\tmatch[\"repo\"] = scheme + \"://\" + match[\"repo\"]\n-\t\t\t\t\t\tgoto Found\n+\t\t\t\t\tif vcs.ping(s, repo) == nil {\n+\t\t\t\t\t\tscheme = s\n+\t\t\t\t\t\tbreak\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\t// No scheme found. Fall back to the first one.\n-\t\t\t\tmatch[\"repo\"] = vcs.scheme[0] + \"://\" + match[\"repo\"]\n-\t\t\tFound:\n \t\t\t}\n+\t\t\trepoURL = scheme + \"://\" + repo\n \t\t}\n \t\trr := &RepoRoot{\n-\t\t\tRepo: match[\"repo\"],\n+\t\t\tRepo: repoURL,\n \t\t\tRoot: match[\"root\"],\n \t\t\tVCS:  vcs.cmd,\n \t\t\tvcs:  vcs,\n@@ -799,6 +801,13 @@ func repoRootForImportDynamic(importPath string, mod ModuleMode, security web.Se\n \tbody := resp.Body\n \tdefer body.Close()\n \timports, err := parseMetaGoImports(body, mod)\n+\tif len(imports) == 0 {\n+\t\tif respErr := resp.Err(); respErr != nil {\n+\t\t\t// If the server's status was not OK, prefer to report that instead of\n+\t\t\t// an XML parse error.\n+\t\t\treturn nil, respErr\n+\t\t}\n+\t}\n \tif err != nil {\n \t\treturn nil, fmt.Errorf(\"parsing %s: %v\", importPath, err)\n \t}\n@@ -904,16 +913,23 @@ func metaImportsForPrefix(importPrefix string, mod ModuleMode, security web.Secu\n \t\t}\n \t\tresp, err := web.Get(security, url)\n \t\tif err != nil {\n-\t\t\treturn setCache(fetchResult{url: url, err: fmt.Errorf(\"fetch %s: %v\", resp.URL, err)})\n+\t\t\treturn setCache(fetchResult{url: url, err: fmt.Errorf(\"fetching %s: %v\", importPrefix, err)})\n \t\t}\n \t\tbody := resp.Body\n \t\tdefer body.Close()\n \t\timports, err := parseMetaGoImports(body, mod)\n+\t\tif len(imports) == 0 {\n+\t\t\tif respErr := resp.Err(); respErr != nil {\n+\t\t\t\t// If the server's status was not OK, prefer to report that instead of\n+\t\t\t\t// an XML parse error.\n+\t\t\t\treturn setCache(fetchResult{url: url, err: respErr})\n+\t\t\t}\n+\t\t}\n \t\tif err != nil {\n \t\t\treturn setCache(fetchResult{url: url, err: fmt.Errorf(\"parsing %s: %v\", resp.URL, err)})\n \t\t}\n \t\tif len(imports) == 0 {\n-\t\t\terr = fmt.Errorf(\"fetch %s: no go-import meta tag\", url)\n+\t\t\terr = fmt.Errorf(\"fetching %s: no go-import meta tag found in %s\", importPrefix, resp.URL)\n \t\t}\n \t\treturn setCache(fetchResult{url: url, imports: imports, err: err})\n \t})\n@@ -962,7 +978,7 @@ func (m ImportMismatchError) Error() string {\n \n // matchGoImport returns the metaImport from imports matching importPath.\n // An error is returned if there are multiple matches.\n-// errNoMatch is returned if none match.\n+// An ImportMismatchError is returned if none match.\n func matchGoImport(imports []metaImport, importPath string) (metaImport, error) {\n \tmatch := -1\n \n@@ -1061,8 +1077,8 @@ var vcsPaths = []*vcsPath{\n \t// General syntax for any server.\n \t// Must be last.\n \t{\n-\t\tregexp: lazyregexp.New(`(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`),\n-\t\tping:   true,\n+\t\tregexp:         lazyregexp.New(`(?P<root>(?P<repo>([a-z0-9.\\-]+\\.)+[a-z0-9.\\-]+(:[0-9]+)?(/~?[A-Za-z0-9_.\\-]+)+?)\\.(?P<vcs>bzr|fossil|git|hg|svn))(/~?[A-Za-z0-9_.\\-]+)*$`),\n+\t\tschemelessRepo: true,\n \t},\n }\n "}, {"sha": "6a843f459a8dd994338ef864ed65f939b28d3080", "filename": "libgo/go/cmd/go/internal/help/helpdoc.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fhelp%2Fhelpdoc.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -21,8 +21,8 @@ http://swig.org/. When running go build, any file with a .swig\n extension will be passed to SWIG. Any file with a .swigcxx extension\n will be passed to SWIG with the -c++ option.\n \n-When either cgo or SWIG is used, go build will pass any .c, .m, .s,\n-or .S files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n+When either cgo or SWIG is used, go build will pass any .c, .m, .s, .S\n+or .sx files to the C compiler, and any .cc, .cpp, .cxx files to the C++\n compiler. The CC or CXX environment variables may be set to determine\n the C or C++ compiler, respectively, to use.\n \t`,\n@@ -506,6 +506,10 @@ General-purpose environment variables:\n \t\tBecause the entries are space-separated, flag values must\n \t\tnot contain spaces. Flags listed on the command line\n \t\tare applied after this list and therefore override it.\n+\tGOINSECURE\n+\t\tComma-separated list of glob patterns (in the syntax of Go's path.Match)\n+\t\tof module path prefixes that should always be fetched in an insecure\n+\t\tmanner. Only applies to dependencies that are being fetched directly.\n \tGOOS\n \t\tThe operating system for which to compile code.\n \t\tExamples are linux, darwin, windows, netbsd.\n@@ -617,8 +621,10 @@ Additional information available from 'go env' but not read from the environment\n \tGOHOSTOS\n \t\tThe operating system (GOOS) of the Go toolchain binaries.\n \tGOMOD\n-\t\tThe absolute path to the go.mod of the main module,\n-\t\tor the empty string if not using modules.\n+\t\tThe absolute path to the go.mod of the main module.\n+\t\tIf module-aware mode is enabled, but there is no go.mod, GOMOD will be\n+\t\tos.DevNull (\"/dev/null\" on Unix-like systems, \"NUL\" on Windows).\n+\t\tIf module-aware mode is disabled, GOMOD will be the empty string.\n \tGOTOOLDIR\n \t\tThe directory where the go tools (compile, cover, doc, etc...) are installed.\n \t`,\n@@ -645,7 +651,7 @@ the extension of the file name. These extensions are:\n \t.m\n \t\tObjective-C source files. Only useful with cgo, and always\n \t\tcompiled with the OS-native compiler.\n-\t.s, .S\n+\t.s, .S, .sx\n \t\tAssembler source files.\n \t\tIf the package uses cgo or SWIG, these will be assembled with the\n \t\tOS-native assembler (typically gcc (sic)); otherwise they"}, {"sha": "eb070eef4c1bede105ba2f45675b259afe681840", "filename": "libgo/go/cmd/go/internal/imports/build.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fimports%2Fbuild.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -210,7 +210,7 @@ var KnownOS = map[string]bool{\n \t\"illumos\":   true,\n \t\"js\":        true,\n \t\"linux\":     true,\n-\t\"nacl\":      true,\n+\t\"nacl\":      true, // legacy; don't remove\n \t\"netbsd\":    true,\n \t\"openbsd\":   true,\n \t\"plan9\":     true,\n@@ -222,7 +222,7 @@ var KnownOS = map[string]bool{\n var KnownArch = map[string]bool{\n \t\"386\":         true,\n \t\"amd64\":       true,\n-\t\"amd64p32\":    true,\n+\t\"amd64p32\":    true, // legacy; don't remove\n \t\"arm\":         true,\n \t\"armbe\":       true,\n \t\"arm64\":       true,"}, {"sha": "b393c67ddb25dfe90a777b454d8f8802c510ea79", "filename": "libgo/go/cmd/go/internal/list/list.go", "status": "modified", "additions": 17, "deletions": 1, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flist%2Flist.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -287,7 +287,7 @@ For more about modules, see 'go help modules'.\n \n func init() {\n \tCmdList.Run = runList // break init cycle\n-\twork.AddBuildFlags(CmdList)\n+\twork.AddBuildFlags(CmdList, work.DefaultBuildFlags)\n }\n \n var (\n@@ -384,6 +384,22 @@ func runList(cmd *base.Command, args []string) {\n \t\tif modload.Init(); !modload.Enabled() {\n \t\t\tbase.Fatalf(\"go list -m: not using modules\")\n \t\t}\n+\n+\t\tmodload.InitMod() // Parses go.mod and sets cfg.BuildMod.\n+\t\tif cfg.BuildMod == \"vendor\" {\n+\t\t\tfor _, arg := range args {\n+\t\t\t\t// In vendor mode, the module graph is incomplete: it contains only the\n+\t\t\t\t// explicit module dependencies and the modules that supply packages in\n+\t\t\t\t// the import graph. Reject queries that imply more information than that.\n+\t\t\t\tif arg == \"all\" {\n+\t\t\t\t\tbase.Fatalf(\"go list -m: can't compute 'all' using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")\n+\t\t\t\t}\n+\t\t\t\tif strings.Contains(arg, \"...\") {\n+\t\t\t\t\tbase.Fatalf(\"go list -m: can't match module patterns using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n \t\tmodload.LoadBuildList()\n \n \t\tmods := modload.ListModules(args, *listU, *listVersions)"}, {"sha": "06b6e23e63327bed4be5bf0485322423783b773c", "filename": "libgo/go/cmd/go/internal/load/pkg.go", "status": "modified", "additions": 174, "deletions": 77, "changes": 251, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,9 +7,11 @@ package load\n \n import (\n \t\"bytes\"\n+\t\"encoding/json\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n+\t\"go/scanner\"\n \t\"go/token\"\n \t\"io/ioutil\"\n \t\"os\"\n@@ -40,7 +42,7 @@ var (\n \tModPackageModuleInfo func(path string) *modinfo.ModulePublic                                                  // return module info for Package struct\n \tModImportPaths       func(args []string) []*search.Match                                                      // expand import paths\n \tModPackageBuildInfo  func(main string, deps []string) string                                                  // return module info to embed in binary\n-\tModInfoProg          func(info string) []byte                                                                 // wrap module info in .go code for binary\n+\tModInfoProg          func(info string, isgccgo bool) []byte                                                   // wrap module info in .go code for binary\n \tModImportFromFiles   func([]string)                                                                           // update go.mod to add modules for imports in these files\n \tModDirImportPath     func(string) string                                                                      // return effective import path for directory\n )\n@@ -304,9 +306,9 @@ func (p *Package) copyBuild(pp *build.Package) {\n type PackageError struct {\n \tImportStack   []string // shortest path from package named on command line to this one\n \tPos           string   // position of error\n-\tErr           string   // the error itself\n-\tIsImportCycle bool     `json:\"-\"` // the error is an import cycle\n-\tHard          bool     `json:\"-\"` // whether the error is soft or hard; soft errors are ignored in some places\n+\tErr           error    // the error itself\n+\tIsImportCycle bool     // the error is an import cycle\n+\tHard          bool     // whether the error is soft or hard; soft errors are ignored in some places\n }\n \n func (p *PackageError) Error() string {\n@@ -317,12 +319,77 @@ func (p *PackageError) Error() string {\n \tif p.Pos != \"\" {\n \t\t// Omit import stack. The full path to the file where the error\n \t\t// is the most important thing.\n-\t\treturn p.Pos + \": \" + p.Err\n+\t\treturn p.Pos + \": \" + p.Err.Error()\n \t}\n-\tif len(p.ImportStack) == 0 {\n-\t\treturn p.Err\n+\n+\t// If the error is an ImportPathError, and the last path on the stack appears\n+\t// in the error message, omit that path from the stack to avoid repetition.\n+\t// If an ImportPathError wraps another ImportPathError that matches the\n+\t// last path on the stack, we don't omit the path. An error like\n+\t// \"package A imports B: error loading C caused by B\" would not be clearer\n+\t// if \"imports B\" were omitted.\n+\tstack := p.ImportStack\n+\tvar ierr ImportPathError\n+\tif len(stack) > 0 && errors.As(p.Err, &ierr) && ierr.ImportPath() == stack[len(stack)-1] {\n+\t\tstack = stack[:len(stack)-1]\n+\t}\n+\tif len(stack) == 0 {\n+\t\treturn p.Err.Error()\n+\t}\n+\treturn \"package \" + strings.Join(stack, \"\\n\\timports \") + \": \" + p.Err.Error()\n+}\n+\n+// PackageError implements MarshalJSON so that Err is marshaled as a string\n+// and non-essential fields are omitted.\n+func (p *PackageError) MarshalJSON() ([]byte, error) {\n+\tperr := struct {\n+\t\tImportStack []string\n+\t\tPos         string\n+\t\tErr         string\n+\t}{p.ImportStack, p.Pos, p.Err.Error()}\n+\treturn json.Marshal(perr)\n+}\n+\n+// ImportPathError is a type of error that prevents a package from being loaded\n+// for a given import path. When such a package is loaded, a *Package is\n+// returned with Err wrapping an ImportPathError: the error is attached to\n+// the imported package, not the importing package.\n+//\n+// The string returned by ImportPath must appear in the string returned by\n+// Error. Errors that wrap ImportPathError (such as PackageError) may omit\n+// the import path.\n+type ImportPathError interface {\n+\terror\n+\tImportPath() string\n+}\n+\n+type importError struct {\n+\timportPath string\n+\terr        error // created with fmt.Errorf\n+}\n+\n+var _ ImportPathError = (*importError)(nil)\n+\n+func ImportErrorf(path, format string, args ...interface{}) ImportPathError {\n+\terr := &importError{importPath: path, err: fmt.Errorf(format, args...)}\n+\tif errStr := err.Error(); !strings.Contains(errStr, path) {\n+\t\tpanic(fmt.Sprintf(\"path %q not in error %q\", path, errStr))\n \t}\n-\treturn \"package \" + strings.Join(p.ImportStack, \"\\n\\timports \") + \": \" + p.Err\n+\treturn err\n+}\n+\n+func (e *importError) Error() string {\n+\treturn e.err.Error()\n+}\n+\n+func (e *importError) Unwrap() error {\n+\t// Don't return e.err directly, since we're only wrapping an error if %w\n+\t// was passed to ImportErrorf.\n+\treturn errors.Unwrap(e.err)\n+}\n+\n+func (e *importError) ImportPath() string {\n+\treturn e.importPath\n }\n \n // An ImportStack is a stack of import paths, possibly with the suffix \" (test)\" appended.\n@@ -489,7 +556,7 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\t\t\tImportPath: path,\n \t\t\t\tError: &PackageError{\n \t\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\t\tErr:         err.Error(),\n+\t\t\t\t\tErr:         err,\n \t\t\t\t},\n \t\t\t},\n \t\t}\n@@ -516,7 +583,7 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\tif !cfg.ModulesEnabled && path != cleanImport(path) {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"non-canonical import path: %q should be %q\", path, pathpkg.Clean(path)),\n+\t\t\t\tErr:         fmt.Errorf(\"non-canonical import path: %q should be %q\", path, pathpkg.Clean(path)),\n \t\t\t}\n \t\t\tp.Incomplete = true\n \t\t}\n@@ -527,7 +594,7 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\treturn setErrorPos(perr, importPos)\n \t}\n \tif mode&ResolveImport != 0 {\n-\t\tif perr := disallowVendor(srcDir, parent, parentPath, path, p, stk); perr != p {\n+\t\tif perr := disallowVendor(srcDir, path, p, stk); perr != p {\n \t\t\treturn setErrorPos(perr, importPos)\n \t\t}\n \t}\n@@ -536,20 +603,22 @@ func loadImport(pre *preload, path, srcDir string, parent *Package, stk *ImportS\n \t\tperr := *p\n \t\tperr.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"import %q is a program, not an importable package\", path),\n+\t\t\tErr:         ImportErrorf(path, \"import %q is a program, not an importable package\", path),\n \t\t}\n \t\treturn setErrorPos(&perr, importPos)\n \t}\n \n \tif p.Internal.Local && parent != nil && !parent.Internal.Local {\n \t\tperr := *p\n-\t\terrMsg := fmt.Sprintf(\"local import %q in non-local package\", path)\n+\t\tvar err error\n \t\tif path == \".\" {\n-\t\t\terrMsg = \"cannot import current directory\"\n+\t\t\terr = ImportErrorf(path, \"%s: cannot import current directory\", path)\n+\t\t} else {\n+\t\t\terr = ImportErrorf(path, \"local import %q in non-local package\", path)\n \t\t}\n \t\tperr.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         errMsg,\n+\t\t\tErr:         err,\n \t\t}\n \t\treturn setErrorPos(&perr, importPos)\n \t}\n@@ -602,6 +671,11 @@ func loadPackageData(path, parentPath, parentDir, parentRoot string, parentIsStd\n \t// we create from the full directory to the package.\n \t// Otherwise it is the usual import path.\n \t// For vendored imports, it is the expanded form.\n+\t//\n+\t// Note that when modules are enabled, local import paths are normally\n+\t// canonicalized by modload.ImportPaths before now. However, if there's an\n+\t// error resolving a local path, it will be returned untransformed\n+\t// so that 'go list -e' reports something useful.\n \timportKey := importSpec{\n \t\tpath:        path,\n \t\tparentPath:  parentPath,\n@@ -1125,7 +1199,7 @@ func reusePackage(p *Package, stk *ImportStack) *Package {\n \t\tif p.Error == nil {\n \t\t\tp.Error = &PackageError{\n \t\t\t\tImportStack:   stk.Copy(),\n-\t\t\t\tErr:           \"import cycle not allowed\",\n+\t\t\t\tErr:           errors.New(\"import cycle not allowed\"),\n \t\t\t\tIsImportCycle: true,\n \t\t\t}\n \t\t}\n@@ -1234,7 +1308,7 @@ func disallowInternal(srcDir string, importer *Package, importerPath string, p *\n \tperr := *p\n \tperr.Error = &PackageError{\n \t\tImportStack: stk.Copy(),\n-\t\tErr:         \"use of internal package \" + p.ImportPath + \" not allowed\",\n+\t\tErr:         ImportErrorf(p.ImportPath, \"use of internal package \"+p.ImportPath+\" not allowed\"),\n \t}\n \tperr.Incomplete = true\n \treturn &perr\n@@ -1259,11 +1333,10 @@ func findInternal(path string) (index int, ok bool) {\n \treturn 0, false\n }\n \n-// disallowVendor checks that srcDir (containing package importerPath, if non-empty)\n-// is allowed to import p as path.\n+// disallowVendor checks that srcDir is allowed to import p as path.\n // If the import is allowed, disallowVendor returns the original package p.\n // If not, it returns a new package containing just an appropriate error.\n-func disallowVendor(srcDir string, importer *Package, importerPath, path string, p *Package, stk *ImportStack) *Package {\n+func disallowVendor(srcDir string, path string, p *Package, stk *ImportStack) *Package {\n \t// The stack includes p.ImportPath.\n \t// If that's the only thing on the stack, we started\n \t// with a name given on the command line, not an\n@@ -1281,7 +1354,7 @@ func disallowVendor(srcDir string, importer *Package, importerPath, path string,\n \t\tperr := *p\n \t\tperr.Error = &PackageError{\n \t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         \"must be imported as \" + path[i+len(\"vendor/\"):],\n+\t\t\tErr:         ImportErrorf(path, \"%s must be imported as %s\", path, path[i+len(\"vendor/\"):]),\n \t\t}\n \t\tperr.Incomplete = true\n \t\treturn &perr\n@@ -1335,7 +1408,7 @@ func disallowVendorVisibility(srcDir string, p *Package, stk *ImportStack) *Pack\n \tperr := *p\n \tperr.Error = &PackageError{\n \t\tImportStack: stk.Copy(),\n-\t\tErr:         \"use of vendored package not allowed\",\n+\t\tErr:         errors.New(\"use of vendored package not allowed\"),\n \t}\n \tperr.Incomplete = true\n \treturn &perr\n@@ -1397,26 +1470,51 @@ var cgoSyscallExclude = map[string]bool{\n \n var foldPath = make(map[string]string)\n \n-// DefaultExecName returns the default executable name\n-// for a package with the import path importPath.\n+// exeFromImportPath returns an executable name\n+// for a package using the import path.\n //\n-// The default executable name is the last element of the import path.\n+// The executable name is the last element of the import path.\n // In module-aware mode, an additional rule is used on import paths\n // consisting of two or more path elements. If the last element is\n // a vN path element specifying the major version, then the\n // second last element of the import path is used instead.\n-func DefaultExecName(importPath string) string {\n-\t_, elem := pathpkg.Split(importPath)\n+func (p *Package) exeFromImportPath() string {\n+\t_, elem := pathpkg.Split(p.ImportPath)\n \tif cfg.ModulesEnabled {\n \t\t// If this is example.com/mycmd/v2, it's more useful to\n \t\t// install it as mycmd than as v2. See golang.org/issue/24667.\n-\t\tif elem != importPath && isVersionElement(elem) {\n-\t\t\t_, elem = pathpkg.Split(pathpkg.Dir(importPath))\n+\t\tif elem != p.ImportPath && isVersionElement(elem) {\n+\t\t\t_, elem = pathpkg.Split(pathpkg.Dir(p.ImportPath))\n \t\t}\n \t}\n \treturn elem\n }\n \n+// exeFromFiles returns an executable name for a package\n+// using the first element in GoFiles or CgoFiles collections without the prefix.\n+//\n+// Returns empty string in case of empty collection.\n+func (p *Package) exeFromFiles() string {\n+\tvar src string\n+\tif len(p.GoFiles) > 0 {\n+\t\tsrc = p.GoFiles[0]\n+\t} else if len(p.CgoFiles) > 0 {\n+\t\tsrc = p.CgoFiles[0]\n+\t} else {\n+\t\treturn \"\"\n+\t}\n+\t_, elem := filepath.Split(src)\n+\treturn elem[:len(elem)-len(\".go\")]\n+}\n+\n+// DefaultExecName returns the default executable name for a package\n+func (p *Package) DefaultExecName() string {\n+\tif p.Internal.CmdlineFiles {\n+\t\treturn p.exeFromFiles()\n+\t}\n+\treturn p.exeFromImportPath()\n+}\n+\n // load populates p using information from bp, err, which should\n // be the result of calling build.Context.Import.\n func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n@@ -1428,17 +1526,30 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\tp.Internal.LocalPrefix = dirToImportPath(p.Dir)\n \t}\n \n+\t// setError sets p.Error if it hasn't already been set. We may proceed\n+\t// after encountering some errors so that 'go list -e' has more complete\n+\t// output. If there's more than one error, we should report the first.\n+\tsetError := func(err error) {\n+\t\tif p.Error == nil {\n+\t\t\tp.Error = &PackageError{\n+\t\t\t\tImportStack: stk.Copy(),\n+\t\t\t\tErr:         err,\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tif err != nil {\n \t\tif _, ok := err.(*build.NoGoError); ok {\n \t\t\terr = &NoGoError{Package: p}\n \t\t}\n \t\tp.Incomplete = true\n-\t\terr = base.ExpandScanner(err)\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         err.Error(),\n+\n+\t\tsetError(base.ExpandScanner(err))\n+\t\tif _, isScanErr := err.(scanner.ErrorList); !isScanErr {\n+\t\t\treturn\n \t\t}\n-\t\treturn\n+\t\t// Fall through if there was an error parsing a file. 'go list -e' should\n+\t\t// still report imports and other metadata.\n \t}\n \n \tuseBindir := p.Name == \"main\"\n@@ -1453,11 +1564,11 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t// Report an error when the old code.google.com/p/go.tools paths are used.\n \t\tif InstallTargetDir(p) == StalePath {\n \t\t\tnewPath := strings.Replace(p.ImportPath, \"code.google.com/p/go.\", \"golang.org/x/\", 1)\n-\t\t\te := fmt.Sprintf(\"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n-\t\t\tp.Error = &PackageError{Err: e}\n+\t\t\te := ImportErrorf(p.ImportPath, \"the %v command has moved; use %v instead.\", p.ImportPath, newPath)\n+\t\t\tsetError(e)\n \t\t\treturn\n \t\t}\n-\t\telem := DefaultExecName(p.ImportPath)\n+\t\telem := p.DefaultExecName()\n \t\tfull := cfg.BuildContext.GOOS + \"_\" + cfg.BuildContext.GOARCH + \"/\" + elem\n \t\tif cfg.BuildContext.GOOS != base.ToolGOOS || cfg.BuildContext.GOARCH != base.ToolGOARCH {\n \t\t\t// Install cross-compiled binaries to subdirectories of bin.\n@@ -1493,7 +1604,10 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\tp.Target = \"\"\n \t} else {\n \t\tp.Target = p.Internal.Build.PkgObj\n-\t\tif cfg.BuildLinkshared {\n+\t\tif cfg.BuildLinkshared && p.Target != \"\" {\n+\t\t\t// TODO(bcmills): The reliance on p.Target implies that -linkshared does\n+\t\t\t// not work for any package that lacks a Target \u2014 such as a non-main\n+\t\t\t// package in module mode. We should probably fix that.\n \t\t\tshlibnamefile := p.Target[:len(p.Target)-2] + \".shlibname\"\n \t\t\tshlib, err := ioutil.ReadFile(shlibnamefile)\n \t\t\tif err != nil && !os.IsNotExist(err) {\n@@ -1564,10 +1678,7 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tinputs := p.AllFiles()\n \tf1, f2 := str.FoldDup(inputs)\n \tif f1 != \"\" {\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"case-insensitive file name collision: %q and %q\", f1, f2),\n-\t\t}\n+\t\tsetError(fmt.Errorf(\"case-insensitive file name collision: %q and %q\", f1, f2))\n \t\treturn\n \t}\n \n@@ -1580,25 +1691,16 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t// so we shouldn't see any _cgo_ files anyway, but just be safe.\n \tfor _, file := range inputs {\n \t\tif !SafeArg(file) || strings.HasPrefix(file, \"_cgo_\") {\n-\t\t\tp.Error = &PackageError{\n-\t\t\t\tImportStack: stk.Copy(),\n-\t\t\t\tErr:         fmt.Sprintf(\"invalid input file name %q\", file),\n-\t\t\t}\n+\t\t\tsetError(fmt.Errorf(\"invalid input file name %q\", file))\n \t\t\treturn\n \t\t}\n \t}\n \tif name := pathpkg.Base(p.ImportPath); !SafeArg(name) {\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"invalid input directory name %q\", name),\n-\t\t}\n+\t\tsetError(fmt.Errorf(\"invalid input directory name %q\", name))\n \t\treturn\n \t}\n \tif !SafeArg(p.ImportPath) {\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         fmt.Sprintf(\"invalid import path %q\", p.ImportPath),\n-\t\t}\n+\t\tsetError(ImportErrorf(p.ImportPath, \"invalid import path %q\", p.ImportPath))\n \t\treturn\n \t}\n \n@@ -1643,31 +1745,24 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \t\t// code; see issue #16050).\n \t}\n \n-\tsetError := func(msg string) {\n-\t\tp.Error = &PackageError{\n-\t\t\tImportStack: stk.Copy(),\n-\t\t\tErr:         msg,\n-\t\t}\n-\t}\n-\n \t// The gc toolchain only permits C source files with cgo or SWIG.\n \tif len(p.CFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() && cfg.BuildContext.Compiler == \"gc\" {\n-\t\tsetError(fmt.Sprintf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")))\n+\t\tsetError(fmt.Errorf(\"C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CFiles, \" \")))\n \t\treturn\n \t}\n \n \t// C++, Objective-C, and Fortran source files are permitted only with cgo or SWIG,\n \t// regardless of toolchain.\n \tif len(p.CXXFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n-\t\tsetError(fmt.Sprintf(\"C++ source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CXXFiles, \" \")))\n+\t\tsetError(fmt.Errorf(\"C++ source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.CXXFiles, \" \")))\n \t\treturn\n \t}\n \tif len(p.MFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n-\t\tsetError(fmt.Sprintf(\"Objective-C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.MFiles, \" \")))\n+\t\tsetError(fmt.Errorf(\"Objective-C source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.MFiles, \" \")))\n \t\treturn\n \t}\n \tif len(p.FFiles) > 0 && !p.UsesCgo() && !p.UsesSwig() {\n-\t\tsetError(fmt.Sprintf(\"Fortran source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.FFiles, \" \")))\n+\t\tsetError(fmt.Errorf(\"Fortran source files not allowed when not using cgo or SWIG: %s\", strings.Join(p.FFiles, \" \")))\n \t\treturn\n \t}\n \n@@ -1676,17 +1771,17 @@ func (p *Package) load(stk *ImportStack, bp *build.Package, err error) {\n \tif other := foldPath[fold]; other == \"\" {\n \t\tfoldPath[fold] = p.ImportPath\n \t} else if other != p.ImportPath {\n-\t\tsetError(fmt.Sprintf(\"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n+\t\tsetError(ImportErrorf(p.ImportPath, \"case-insensitive import collision: %q and %q\", p.ImportPath, other))\n \t\treturn\n \t}\n \n-\tif cfg.ModulesEnabled {\n+\tif cfg.ModulesEnabled && p.Error == nil {\n \t\tmainPath := p.ImportPath\n \t\tif p.Internal.CmdlineFiles {\n \t\t\tmainPath = \"command-line-arguments\"\n \t\t}\n \t\tp.Module = ModPackageModuleInfo(mainPath)\n-\t\tif p.Name == \"main\" {\n+\t\tif p.Name == \"main\" && len(p.DepsErrors) == 0 {\n \t\t\tp.Internal.BuildInfo = ModPackageBuildInfo(mainPath, p.Deps)\n \t\t}\n \t}\n@@ -1956,9 +2051,14 @@ func Packages(args []string) []*Package {\n // cannot be loaded at all.\n // The packages that fail to load will have p.Error != nil.\n func PackagesAndErrors(patterns []string) []*Package {\n-\tif len(patterns) > 0 {\n-\t\tfor _, p := range patterns {\n-\t\t\tif strings.HasSuffix(p, \".go\") {\n+\tfor _, p := range patterns {\n+\t\t// Listing is only supported with all patterns referring to either:\n+\t\t// - Files that are part of the same directory.\n+\t\t// - Explicit package paths or patterns.\n+\t\tif strings.HasSuffix(p, \".go\") {\n+\t\t\t// We need to test whether the path is an actual Go file and not a\n+\t\t\t// package path or pattern ending in '.go' (see golang.org/issue/34653).\n+\t\t\tif fi, err := os.Stat(p); err == nil && !fi.IsDir() {\n \t\t\t\treturn []*Package{GoFilesPackage(patterns)}\n \t\t\t}\n \t\t}\n@@ -2078,7 +2178,7 @@ func GoFilesPackage(gofiles []string) *Package {\n \t\t\tpkg.Internal.CmdlineFiles = true\n \t\t\tpkg.Name = f\n \t\t\tpkg.Error = &PackageError{\n-\t\t\t\tErr: fmt.Sprintf(\"named files must be .go files: %s\", pkg.Name),\n+\t\t\t\tErr: fmt.Errorf(\"named files must be .go files: %s\", pkg.Name),\n \t\t\t}\n \t\t\treturn pkg\n \t\t}\n@@ -2141,11 +2241,8 @@ func GoFilesPackage(gofiles []string) *Package {\n \tpkg.Match = gofiles\n \n \tif pkg.Name == \"main\" {\n-\t\t_, elem := filepath.Split(gofiles[0])\n-\t\texe := elem[:len(elem)-len(\".go\")] + cfg.ExeSuffix\n-\t\tif cfg.BuildO == \"\" {\n-\t\t\tcfg.BuildO = exe\n-\t\t}\n+\t\texe := pkg.DefaultExecName() + cfg.ExeSuffix\n+\n \t\tif cfg.GOBIN != \"\" {\n \t\t\tpkg.Target = filepath.Join(cfg.GOBIN, exe)\n \t\t} else if cfg.ModulesEnabled {"}, {"sha": "1e59fb989c59c29f8ad68e6df9fe5f6740757870", "filename": "libgo/go/cmd/go/internal/load/pkg_test.go", "status": "modified", "additions": 27, "deletions": 17, "changes": 44, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Fpkg_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,39 +5,49 @@ import (\n \t\"testing\"\n )\n \n-func TestDefaultExecName(t *testing.T) {\n+func TestPkgDefaultExecName(t *testing.T) {\n \toldModulesEnabled := cfg.ModulesEnabled\n \tdefer func() { cfg.ModulesEnabled = oldModulesEnabled }()\n \tfor _, tt := range []struct {\n \t\tin         string\n+\t\tfiles      []string\n \t\twantMod    string\n \t\twantGopath string\n \t}{\n-\t\t{\"example.com/mycmd\", \"mycmd\", \"mycmd\"},\n-\t\t{\"example.com/mycmd/v0\", \"v0\", \"v0\"},\n-\t\t{\"example.com/mycmd/v1\", \"v1\", \"v1\"},\n-\t\t{\"example.com/mycmd/v2\", \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n-\t\t{\"example.com/mycmd/v3\", \"mycmd\", \"v3\"}, // Semantic import versioning, use second last element in module mode.\n-\t\t{\"mycmd\", \"mycmd\", \"mycmd\"},\n-\t\t{\"mycmd/v0\", \"v0\", \"v0\"},\n-\t\t{\"mycmd/v1\", \"v1\", \"v1\"},\n-\t\t{\"mycmd/v2\", \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n-\t\t{\"v0\", \"v0\", \"v0\"},\n-\t\t{\"v1\", \"v1\", \"v1\"},\n-\t\t{\"v2\", \"v2\", \"v2\"},\n+\t\t{\"example.com/mycmd\", []string{}, \"mycmd\", \"mycmd\"},\n+\t\t{\"example.com/mycmd/v0\", []string{}, \"v0\", \"v0\"},\n+\t\t{\"example.com/mycmd/v1\", []string{}, \"v1\", \"v1\"},\n+\t\t{\"example.com/mycmd/v2\", []string{}, \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"example.com/mycmd/v3\", []string{}, \"mycmd\", \"v3\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"mycmd\", []string{}, \"mycmd\", \"mycmd\"},\n+\t\t{\"mycmd/v0\", []string{}, \"v0\", \"v0\"},\n+\t\t{\"mycmd/v1\", []string{}, \"v1\", \"v1\"},\n+\t\t{\"mycmd/v2\", []string{}, \"mycmd\", \"v2\"}, // Semantic import versioning, use second last element in module mode.\n+\t\t{\"v0\", []string{}, \"v0\", \"v0\"},\n+\t\t{\"v1\", []string{}, \"v1\", \"v1\"},\n+\t\t{\"v2\", []string{}, \"v2\", \"v2\"},\n+\t\t{\"command-line-arguments\", []string{\"output.go\", \"foo.go\"}, \"output\", \"output\"},\n \t} {\n \t\t{\n \t\t\tcfg.ModulesEnabled = true\n-\t\t\tgotMod := DefaultExecName(tt.in)\n+\t\t\tpkg := new(Package)\n+\t\t\tpkg.ImportPath = tt.in\n+\t\t\tpkg.GoFiles = tt.files\n+\t\t\tpkg.Internal.CmdlineFiles = len(tt.files) > 0\n+\t\t\tgotMod := pkg.DefaultExecName()\n \t\t\tif gotMod != tt.wantMod {\n-\t\t\t\tt.Errorf(\"DefaultExecName(%q) in module mode = %v; want %v\", tt.in, gotMod, tt.wantMod)\n+\t\t\t\tt.Errorf(\"pkg.DefaultExecName with ImportPath = %q in module mode = %v; want %v\", tt.in, gotMod, tt.wantMod)\n \t\t\t}\n \t\t}\n \t\t{\n \t\t\tcfg.ModulesEnabled = false\n-\t\t\tgotGopath := DefaultExecName(tt.in)\n+\t\t\tpkg := new(Package)\n+\t\t\tpkg.ImportPath = tt.in\n+\t\t\tpkg.GoFiles = tt.files\n+\t\t\tpkg.Internal.CmdlineFiles = len(tt.files) > 0\n+\t\t\tgotGopath := pkg.DefaultExecName()\n \t\t\tif gotGopath != tt.wantGopath {\n-\t\t\t\tt.Errorf(\"DefaultExecName(%q) in gopath mode = %v; want %v\", tt.in, gotGopath, tt.wantGopath)\n+\t\t\t\tt.Errorf(\"pkg.DefaultExecName with ImportPath = %q in gopath mode = %v; want %v\", tt.in, gotGopath, tt.wantGopath)\n \t\t\t}\n \t\t}\n \t}"}, {"sha": "fefc7d2e307d9f6facbb30e95cb8e5e26faf0d56", "filename": "libgo/go/cmd/go/internal/load/test.go", "status": "modified", "additions": 10, "deletions": 7, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fload%2Ftest.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -110,7 +110,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t\t\t// non-test copy of a package.\n \t\t\tptestErr = &PackageError{\n \t\t\t\tImportStack:   testImportStack(stk[0], p1, p.ImportPath),\n-\t\t\t\tErr:           \"import cycle not allowed in test\",\n+\t\t\t\tErr:           errors.New(\"import cycle not allowed in test\"),\n \t\t\t\tIsImportCycle: true,\n \t\t\t}\n \t\t}\n@@ -271,7 +271,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \t// afterward that gathers t.Cover information.\n \tt, err := loadTestFuncs(ptest)\n \tif err != nil && pmain.Error == nil {\n-\t\tpmain.Error = &PackageError{Err: err.Error()}\n+\t\tpmain.Error = &PackageError{Err: err}\n \t}\n \tt.Cover = cover\n \tif len(ptest.GoFiles)+len(ptest.CgoFiles) > 0 {\n@@ -322,7 +322,7 @@ func TestPackagesAndErrors(p *Package, cover *TestCover) (pmain, ptest, pxtest *\n \n \tdata, err := formatTestmain(t)\n \tif err != nil && pmain.Error == nil {\n-\t\tpmain.Error = &PackageError{Err: err.Error()}\n+\t\tpmain.Error = &PackageError{Err: err}\n \t}\n \tif data != nil {\n \t\tpmain.Internal.TestmainGo = &data\n@@ -399,10 +399,13 @@ func recompileForTest(pmain, preal, ptest, pxtest *Package) {\n \t\t\t}\n \t\t}\n \n-\t\t// Don't compile build info from a main package. This can happen\n-\t\t// if -coverpkg patterns include main packages, since those packages\n-\t\t// are imported by pmain. See golang.org/issue/30907.\n-\t\tif p.Internal.BuildInfo != \"\" && p != pmain {\n+\t\t// Force main packages the test imports to be built as libraries.\n+\t\t// Normal imports of main packages are forbidden by the package loader,\n+\t\t// but this can still happen if -coverpkg patterns include main packages:\n+\t\t// covered packages are imported by pmain. Linking multiple packages\n+\t\t// compiled with '-p main' causes duplicate symbol errors.\n+\t\t// See golang.org/issue/30907, golang.org/issue/34114.\n+\t\tif p.Name == \"main\" && p != pmain && p != ptest {\n \t\t\tsplit()\n \t\t}\n \t}"}, {"sha": "faf73446f7940db103935eba705170fde44f1a44", "filename": "libgo/go/cmd/go/internal/lockedfile/internal/filelock/filelock_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Finternal%2Ffilelock%2Ffilelock_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// +build !js,!nacl,!plan9\n+// +build !js,!plan9\n \n package filelock_test\n "}, {"sha": "59b2dba44cd2c8b53823edab565f37ce808eaf4d", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile.go", "status": "modified", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -120,3 +120,68 @@ func Write(name string, content io.Reader, perm os.FileMode) (err error) {\n \t}\n \treturn err\n }\n+\n+// Transform invokes t with the result of reading the named file, with its lock\n+// still held.\n+//\n+// If t returns a nil error, Transform then writes the returned contents back to\n+// the file, making a best effort to preserve existing contents on error.\n+//\n+// t must not modify the slice passed to it.\n+func Transform(name string, t func([]byte) ([]byte, error)) (err error) {\n+\tf, err := Edit(name)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer f.Close()\n+\n+\told, err := ioutil.ReadAll(f)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tnew, err := t(old)\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\tif len(new) > len(old) {\n+\t\t// The overall file size is increasing, so write the tail first: if we're\n+\t\t// about to run out of space on the disk, we would rather detect that\n+\t\t// failure before we have overwritten the original contents.\n+\t\tif _, err := f.WriteAt(new[len(old):], int64(len(old))); err != nil {\n+\t\t\t// Make a best effort to remove the incomplete tail.\n+\t\t\tf.Truncate(int64(len(old)))\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\t// We're about to overwrite the old contents. In case of failure, make a best\n+\t// effort to roll back before we close the file.\n+\tdefer func() {\n+\t\tif err != nil {\n+\t\t\tif _, err := f.WriteAt(old, 0); err == nil {\n+\t\t\t\tf.Truncate(int64(len(old)))\n+\t\t\t}\n+\t\t}\n+\t}()\n+\n+\tif len(new) >= len(old) {\n+\t\tif _, err := f.WriteAt(new[:len(old)], 0); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t} else {\n+\t\tif _, err := f.WriteAt(new, 0); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\t// The overall file size is decreasing, so shrink the file to its final size\n+\t\t// after writing. We do this after writing (instead of before) so that if\n+\t\t// the write fails, enough filesystem space will likely still be reserved\n+\t\t// to contain the previous contents.\n+\t\tif err := f.Truncate(int64(len(new))); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\n+\treturn nil\n+}"}, {"sha": "8f7a7d5604a3d37811154e84664797928277652a", "filename": "libgo/go/cmd/go/internal/lockedfile/lockedfile_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Flockedfile_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,8 +2,8 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-// js and nacl do not support inter-process file locking.\n-// +build !js,!nacl\n+// js does not support inter-process file locking.\n+// +build !js\n \n package lockedfile_test\n "}, {"sha": "407d48ea4a35f5cad06b31b70b8b9c8e1aaae681", "filename": "libgo/go/cmd/go/internal/lockedfile/transform_test.go", "status": "added", "additions": 104, "deletions": 0, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Flockedfile%2Ftransform_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,104 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// js does not support inter-process file locking.\n+// +build !js\n+\n+package lockedfile_test\n+\n+import (\n+\t\"bytes\"\n+\t\"encoding/binary\"\n+\t\"math/rand\"\n+\t\"path/filepath\"\n+\t\"testing\"\n+\t\"time\"\n+\n+\t\"cmd/go/internal/lockedfile\"\n+)\n+\n+func isPowerOf2(x int) bool {\n+\treturn x > 0 && x&(x-1) == 0\n+}\n+\n+func roundDownToPowerOf2(x int) int {\n+\tif x <= 0 {\n+\t\tpanic(\"nonpositive x\")\n+\t}\n+\tbit := 1\n+\tfor x != bit {\n+\t\tx = x &^ bit\n+\t\tbit <<= 1\n+\t}\n+\treturn x\n+}\n+\n+func TestTransform(t *testing.T) {\n+\tdir, remove := mustTempDir(t)\n+\tdefer remove()\n+\tpath := filepath.Join(dir, \"blob.bin\")\n+\n+\tconst maxChunkWords = 8 << 10\n+\tbuf := make([]byte, 2*maxChunkWords*8)\n+\tfor i := uint64(0); i < 2*maxChunkWords; i++ {\n+\t\tbinary.LittleEndian.PutUint64(buf[i*8:], i)\n+\t}\n+\tif err := lockedfile.Write(path, bytes.NewReader(buf[:8]), 0666); err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tvar attempts int64 = 128\n+\tif !testing.Short() {\n+\t\tattempts *= 16\n+\t}\n+\tconst parallel = 32\n+\n+\tvar sem = make(chan bool, parallel)\n+\n+\tfor n := attempts; n > 0; n-- {\n+\t\tsem <- true\n+\t\tgo func() {\n+\t\t\tdefer func() { <-sem }()\n+\n+\t\t\ttime.Sleep(time.Duration(rand.Intn(100)) * time.Microsecond)\n+\t\t\tchunkWords := roundDownToPowerOf2(rand.Intn(maxChunkWords) + 1)\n+\t\t\toffset := rand.Intn(chunkWords)\n+\n+\t\t\terr := lockedfile.Transform(path, func(data []byte) (chunk []byte, err error) {\n+\t\t\t\tchunk = buf[offset*8 : (offset+chunkWords)*8]\n+\n+\t\t\t\tif len(data)&^7 != len(data) {\n+\t\t\t\t\tt.Errorf(\"read %d bytes, but each write is an integer multiple of 8 bytes\", len(data))\n+\t\t\t\t\treturn chunk, nil\n+\t\t\t\t}\n+\n+\t\t\t\twords := len(data) / 8\n+\t\t\t\tif !isPowerOf2(words) {\n+\t\t\t\t\tt.Errorf(\"read %d 8-byte words, but each write is a power-of-2 number of words\", words)\n+\t\t\t\t\treturn chunk, nil\n+\t\t\t\t}\n+\n+\t\t\t\tu := binary.LittleEndian.Uint64(data)\n+\t\t\t\tfor i := 1; i < words; i++ {\n+\t\t\t\t\tnext := binary.LittleEndian.Uint64(data[i*8:])\n+\t\t\t\t\tif next != u+1 {\n+\t\t\t\t\t\tt.Errorf(\"wrote sequential integers, but read integer out of sequence at offset %d\", i)\n+\t\t\t\t\t\treturn chunk, nil\n+\t\t\t\t\t}\n+\t\t\t\t\tu = next\n+\t\t\t\t}\n+\n+\t\t\t\treturn chunk, nil\n+\t\t\t})\n+\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"unexpected error from Transform: %v\", err)\n+\t\t\t}\n+\t\t}()\n+\t}\n+\n+\tfor n := parallel; n > 0; n-- {\n+\t\tsem <- true\n+\t}\n+}"}, {"sha": "5db0e46c644f0e8bfb1bebb17e8d10b714bb586f", "filename": "libgo/go/cmd/go/internal/modcmd/download.go", "status": "modified", "additions": 24, "deletions": 34, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fdownload.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,19 +5,21 @@\n package modcmd\n \n import (\n-\t\"cmd/go/internal/cfg\"\n \t\"encoding/json\"\n \t\"os\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var cmdDownload = &base.Command{\n-\tUsageLine: \"go mod download [-json] [modules]\",\n+\tUsageLine: \"go mod download [-x] [-json] [modules]\",\n \tShort:     \"download modules to local cache\",\n \tLong: `\n Download downloads the named modules, which can be module patterns selecting\n@@ -43,9 +45,10 @@ corresponding to this Go struct:\n         Dir      string // absolute path to cached source root directory\n         Sum      string // checksum for path, version (as in go.sum)\n         GoModSum string // checksum for go.mod (as in go.sum)\n-        Latest   bool   // would @latest resolve to this version?\n     }\n \n+The -x flag causes download to print the commands download executes.\n+\n See 'go help modules' for more about module queries.\n \t`,\n }\n@@ -54,6 +57,10 @@ var downloadJSON = cmdDownload.Flag.Bool(\"json\", false, \"\")\n \n func init() {\n \tcmdDownload.Run = runDownload // break init cycle\n+\n+\t// TODO(jayconrod): https://golang.org/issue/35849 Apply -x to other 'go mod' commands.\n+\tcmdDownload.Flag.BoolVar(&cfg.BuildX, \"x\", false, \"\")\n+\twork.AddModCommonFlags(cmdDownload)\n }\n \n type moduleJSON struct {\n@@ -66,7 +73,6 @@ type moduleJSON struct {\n \tDir      string `json:\",omitempty\"`\n \tSum      string `json:\",omitempty\"`\n \tGoModSum string `json:\",omitempty\"`\n-\tLatest   bool   `json:\",omitempty\"`\n }\n \n func runDownload(cmd *base.Command, args []string) {\n@@ -79,6 +85,17 @@ func runDownload(cmd *base.Command, args []string) {\n \t}\n \tif len(args) == 0 {\n \t\targs = []string{\"all\"}\n+\t} else if modload.HasModRoot() {\n+\t\tmodload.InitMod() // to fill Target\n+\t\ttargetAtLatest := modload.Target.Path + \"@latest\"\n+\t\ttargetAtUpgrade := modload.Target.Path + \"@upgrade\"\n+\t\ttargetAtPatch := modload.Target.Path + \"@patch\"\n+\t\tfor _, arg := range args {\n+\t\t\tswitch arg {\n+\t\t\tcase modload.Target.Path, targetAtLatest, targetAtUpgrade, targetAtPatch:\n+\t\t\t\tos.Stderr.WriteString(\"go mod download: skipping argument \" + arg + \" that resolves to the main module\\n\")\n+\t\t\t}\n+\t\t}\n \t}\n \n \tvar mods []*moduleJSON\n@@ -90,7 +107,8 @@ func runDownload(cmd *base.Command, args []string) {\n \t\t\tinfo = info.Replace\n \t\t}\n \t\tif info.Version == \"\" && info.Error == nil {\n-\t\t\t// main module\n+\t\t\t// main module or module replaced with file path.\n+\t\t\t// Nothing to download.\n \t\t\tcontinue\n \t\t}\n \t\tm := &moduleJSON{\n@@ -105,31 +123,6 @@ func runDownload(cmd *base.Command, args []string) {\n \t\twork.Add(m)\n \t}\n \n-\tlatest := map[string]string{} // path \u2192 version\n-\tif *downloadJSON {\n-\t\t// We need to populate the Latest field, but if the main module depends on a\n-\t\t// version newer than latest \u2014 or if the version requested on the command\n-\t\t// line is itself newer than latest \u2014 that's not trivial to determine from\n-\t\t// the info returned by ListModules. Instead, we issue a separate\n-\t\t// ListModules request for \"latest\", which should be inexpensive relative to\n-\t\t// downloading the modules.\n-\t\tvar latestArgs []string\n-\t\tfor _, m := range mods {\n-\t\t\tif m.Error != \"\" {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tlatestArgs = append(latestArgs, m.Path+\"@latest\")\n-\t\t}\n-\n-\t\tif len(latestArgs) > 0 {\n-\t\t\tfor _, info := range modload.ListModules(latestArgs, listU, listVersions) {\n-\t\t\t\tif info.Version != \"\" {\n-\t\t\t\t\tlatest[info.Path] = info.Version\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n \twork.Do(10, func(item interface{}) {\n \t\tm := item.(*moduleJSON)\n \t\tvar err error\n@@ -160,9 +153,6 @@ func runDownload(cmd *base.Command, args []string) {\n \t\t\tm.Error = err.Error()\n \t\t\treturn\n \t\t}\n-\t\tif latest[m.Path] == m.Version {\n-\t\t\tm.Latest = true\n-\t\t}\n \t})\n \n \tif *downloadJSON {"}, {"sha": "dbbfb96e42b5b2d81d509f751d10e4b7876f1a40", "filename": "libgo/go/cmd/go/internal/modcmd/edit.go", "status": "modified", "additions": 36, "deletions": 22, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fedit.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -9,17 +9,19 @@ package modcmd\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n \t\"os\"\n-\t\"path/filepath\"\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfile\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n var cmdEdit = &base.Command{\n@@ -53,12 +55,17 @@ The -exclude=path@version and -dropexclude=path@version flags\n add and drop an exclusion for the given module path and version.\n Note that -exclude=path@version is a no-op if that exclusion already exists.\n \n-The -replace=old[@v]=new[@v] and -dropreplace=old[@v] flags\n-add and drop a replacement of the given module path and version pair.\n-If the @v in old@v is omitted, the replacement applies to all versions\n-with the old module path. If the @v in new@v is omitted, the new path\n-should be a local module root directory, not a module path.\n-Note that -replace overrides any existing replacements for old[@v].\n+The -replace=old[@v]=new[@v] flag adds a replacement of the given\n+module path and version pair. If the @v in old@v is omitted, a\n+replacement without a version on the left side is added, which applies\n+to all versions of the old module path. If the @v in new@v is omitted,\n+the new path should be a local module root directory, not a module\n+path. Note that -replace overrides any redundant replacements for old[@v],\n+so omitting @v will drop existing replacements for specific versions.\n+\n+The -dropreplace=old[@v] flag drops a replacement of the given\n+module path and version pair. If the @v is omitted, a replacement without\n+a version on the left side is dropped.\n \n The -require, -droprequire, -exclude, -dropexclude, -replace,\n and -dropreplace editing flags may be repeated, and the changes\n@@ -130,6 +137,7 @@ func init() {\n \tcmdEdit.Flag.Var(flagFunc(flagReplace), \"replace\", \"\")\n \tcmdEdit.Flag.Var(flagFunc(flagDropExclude), \"dropexclude\", \"\")\n \n+\twork.AddModCommonFlags(cmdEdit)\n \tbase.AddBuildFlagsNX(&cmdEdit.Flag)\n }\n \n@@ -157,11 +165,11 @@ func runEdit(cmd *base.Command, args []string) {\n \tif len(args) == 1 {\n \t\tgomod = args[0]\n \t} else {\n-\t\tgomod = filepath.Join(modload.ModRoot(), \"go.mod\")\n+\t\tgomod = modload.ModFilePath()\n \t}\n \n \tif *editModule != \"\" {\n-\t\tif err := module.CheckPath(*editModule); err != nil {\n+\t\tif err := module.CheckImportPath(*editModule); err != nil {\n \t\t\tbase.Fatalf(\"go mod: invalid -module: %v\", err)\n \t\t}\n \t}\n@@ -172,7 +180,7 @@ func runEdit(cmd *base.Command, args []string) {\n \t\t}\n \t}\n \n-\tdata, err := ioutil.ReadFile(gomod)\n+\tdata, err := lockedfile.Read(gomod)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n@@ -215,13 +223,19 @@ func runEdit(cmd *base.Command, args []string) {\n \t\treturn\n \t}\n \n-\tunlock := modfetch.SideLock()\n-\tdefer unlock()\n-\tlockedData, err := ioutil.ReadFile(gomod)\n-\tif err == nil && !bytes.Equal(lockedData, data) {\n-\t\tbase.Fatalf(\"go: go.mod changed during editing; not overwriting\")\n+\t// Make a best-effort attempt to acquire the side lock, only to exclude\n+\t// previous versions of the 'go' command from making simultaneous edits.\n+\tif unlock, err := modfetch.SideLock(); err == nil {\n+\t\tdefer unlock()\n \t}\n-\tif err := ioutil.WriteFile(gomod, out, 0666); err != nil {\n+\n+\terr = lockedfile.Transform(gomod, func(lockedData []byte) ([]byte, error) {\n+\t\tif !bytes.Equal(lockedData, data) {\n+\t\t\treturn nil, errors.New(\"go.mod changed during editing; not overwriting\")\n+\t\t}\n+\t\treturn out, nil\n+\t})\n+\tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n }\n@@ -233,7 +247,7 @@ func parsePathVersion(flag, arg string) (path, version string) {\n \t\tbase.Fatalf(\"go mod: -%s=%s: need path@version\", flag, arg)\n \t}\n \tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n-\tif err := module.CheckPath(path); err != nil {\n+\tif err := module.CheckImportPath(path); err != nil {\n \t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n \t}\n \n@@ -255,7 +269,7 @@ func parsePath(flag, arg string) (path string) {\n \t\tbase.Fatalf(\"go mod: -%s=%s: need just path, not path@version\", flag, arg)\n \t}\n \tpath = arg\n-\tif err := module.CheckPath(path); err != nil {\n+\tif err := module.CheckImportPath(path); err != nil {\n \t\tbase.Fatalf(\"go mod: -%s=%s: invalid path: %v\", flag, arg, err)\n \t}\n \treturn path\n@@ -269,7 +283,7 @@ func parsePathVersionOptional(adj, arg string, allowDirPath bool) (path, version\n \t} else {\n \t\tpath, version = strings.TrimSpace(arg[:i]), strings.TrimSpace(arg[i+1:])\n \t}\n-\tif err := module.CheckPath(path); err != nil {\n+\tif err := module.CheckImportPath(path); err != nil {\n \t\tif !allowDirPath || !modfile.IsDirectoryPath(path) {\n \t\t\treturn path, version, fmt.Errorf(\"invalid %s path: %v\", adj, err)\n \t\t}"}, {"sha": "27ae9354f3d97792f8d2f11ed455bcfc4c34cebf", "filename": "libgo/go/cmd/go/internal/modcmd/graph.go", "status": "modified", "additions": 8, "deletions": 2, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fgraph.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -8,14 +8,16 @@ package modcmd\n \n import (\n \t\"bufio\"\n-\t\"cmd/go/internal/cfg\"\n \t\"os\"\n \t\"sort\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var cmdGraph = &base.Command{\n@@ -30,6 +32,10 @@ path@version, except for the main module, which has no @version suffix.\n \tRun: runGraph,\n }\n \n+func init() {\n+\twork.AddModCommonFlags(cmdGraph)\n+}\n+\n func runGraph(cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod graph: graph takes no arguments\")"}, {"sha": "714ff2e205ab7f572aa2246ca8c94885290af03c", "filename": "libgo/go/cmd/go/internal/modcmd/init.go", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Finit.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -9,6 +9,7 @@ package modcmd\n import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/work\"\n \t\"os\"\n \t\"strings\"\n )\n@@ -27,6 +28,10 @@ To override this guess, supply the module path as an argument.\n \tRun: runInit,\n }\n \n+func init() {\n+\twork.AddModCommonFlags(cmdInit)\n+}\n+\n func runInit(cmd *base.Command, args []string) {\n \tmodload.CmdModInit = true\n \tif len(args) > 1 {\n@@ -38,7 +43,8 @@ func runInit(cmd *base.Command, args []string) {\n \tif os.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go mod init: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n-\tif _, err := os.Stat(\"go.mod\"); err == nil {\n+\tmodFilePath := modload.ModFilePath()\n+\tif _, err := os.Stat(modFilePath); err == nil {\n \t\tbase.Fatalf(\"go mod init: go.mod already exists\")\n \t}\n \tif strings.Contains(modload.CmdModModule, \"@\") {"}, {"sha": "17505221587745bfc4cef0702f926403a96188b7", "filename": "libgo/go/cmd/go/internal/modcmd/mod.go", "status": "modified", "additions": 8, "deletions": 1, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fmod.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,10 @@\n // Package modcmd implements the ``go mod'' command.\n package modcmd\n \n-import \"cmd/go/internal/base\"\n+import (\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+)\n \n var CmdMod = &base.Command{\n \tUsageLine: \"go mod\",\n@@ -29,3 +32,7 @@ See 'go help modules' for an overview of module functionality.\n \t\tcmdWhy,\n \t},\n }\n+\n+func addModFlags(cmd *base.Command) {\n+\tcmd.Flag.StringVar(&cfg.ModFile, \"modfile\", \"\", \"\")\n+}"}, {"sha": "af2b04c0c20381ec72b0903df3d50b53c695f800", "filename": "libgo/go/cmd/go/internal/modcmd/tidy.go", "status": "modified", "additions": 6, "deletions": 26, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Ftidy.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,14 +7,13 @@\n package modcmd\n \n import (\n-\t\"fmt\"\n-\t\"os\"\n-\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var cmdTidy = &base.Command{\n@@ -35,35 +34,16 @@ to standard error.\n func init() {\n \tcmdTidy.Run = runTidy // break init cycle\n \tcmdTidy.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+\twork.AddModCommonFlags(cmdTidy)\n }\n \n func runTidy(cmd *base.Command, args []string) {\n \tif len(args) > 0 {\n \t\tbase.Fatalf(\"go mod tidy: no arguments allowed\")\n \t}\n \n-\t// LoadALL adds missing modules.\n-\t// Remove unused modules.\n-\tused := make(map[module.Version]bool)\n-\tfor _, pkg := range modload.LoadALL() {\n-\t\tused[modload.PackageModule(pkg)] = true\n-\t}\n-\tused[modload.Target] = true // note: LoadALL initializes Target\n-\n-\tinGoMod := make(map[string]bool)\n-\tfor _, r := range modload.ModFile().Require {\n-\t\tinGoMod[r.Mod.Path] = true\n-\t}\n-\n-\tvar keep []module.Version\n-\tfor _, m := range modload.BuildList() {\n-\t\tif used[m] {\n-\t\t\tkeep = append(keep, m)\n-\t\t} else if cfg.BuildV && inGoMod[m.Path] {\n-\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n-\t\t}\n-\t}\n-\tmodload.SetBuildList(keep)\n+\tmodload.LoadALL()\n+\tmodload.TidyBuildList()\n \tmodTidyGoSum() // updates memory copy; WriteGoMod on next line flushes it out\n \tmodload.WriteGoMod()\n }"}, {"sha": "0c00d1222e06ff7dfd362cf8f25dd0bb61dc286f", "filename": "libgo/go/cmd/go/internal/modcmd/vendor.go", "status": "modified", "additions": 67, "deletions": 11, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fvendor.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -18,7 +18,10 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var cmdVendor = &base.Command{\n@@ -37,6 +40,7 @@ modules and packages to standard error.\n \n func init() {\n \tcmdVendor.Flag.BoolVar(&cfg.BuildV, \"v\", false, \"\")\n+\twork.AddModCommonFlags(cmdVendor)\n }\n \n func runVendor(cmd *base.Command, args []string) {\n@@ -59,19 +63,31 @@ func runVendor(cmd *base.Command, args []string) {\n \t\tmodpkgs[m] = append(modpkgs[m], pkg)\n \t}\n \n+\tincludeAllReplacements := false\n+\tisExplicit := map[module.Version]bool{}\n+\tif gv := modload.ModFile().Go; gv != nil && semver.Compare(\"v\"+gv.Version, \"v1.14\") >= 0 {\n+\t\t// If the Go version is at least 1.14, annotate all explicit 'require' and\n+\t\t// 'replace' targets found in the go.mod file so that we can perform a\n+\t\t// stronger consistency check when -mod=vendor is set.\n+\t\tfor _, r := range modload.ModFile().Require {\n+\t\t\tisExplicit[r.Mod] = true\n+\t\t}\n+\t\tincludeAllReplacements = true\n+\t}\n+\n \tvar buf bytes.Buffer\n \tfor _, m := range modload.BuildList()[1:] {\n-\t\tif pkgs := modpkgs[m]; len(pkgs) > 0 {\n-\t\t\trepl := \"\"\n-\t\t\tif r := modload.Replacement(m); r.Path != \"\" {\n-\t\t\t\trepl = \" => \" + r.Path\n-\t\t\t\tif r.Version != \"\" {\n-\t\t\t\t\trepl += \" \" + r.Version\n-\t\t\t\t}\n-\t\t\t}\n-\t\t\tfmt.Fprintf(&buf, \"# %s %s%s\\n\", m.Path, m.Version, repl)\n+\t\tif pkgs := modpkgs[m]; len(pkgs) > 0 || isExplicit[m] {\n+\t\t\tline := moduleLine(m, modload.Replacement(m))\n+\t\t\tbuf.WriteString(line)\n \t\t\tif cfg.BuildV {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# %s %s%s\\n\", m.Path, m.Version, repl)\n+\t\t\t\tos.Stderr.WriteString(line)\n+\t\t\t}\n+\t\t\tif isExplicit[m] {\n+\t\t\t\tbuf.WriteString(\"## explicit\\n\")\n+\t\t\t\tif cfg.BuildV {\n+\t\t\t\t\tos.Stderr.WriteString(\"## explicit\\n\")\n+\t\t\t\t}\n \t\t\t}\n \t\t\tsort.Strings(pkgs)\n \t\t\tfor _, pkg := range pkgs {\n@@ -83,6 +99,26 @@ func runVendor(cmd *base.Command, args []string) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\tif includeAllReplacements {\n+\t\t// Record unused and wildcard replacements at the end of the modules.txt file:\n+\t\t// without access to the complete build list, the consumer of the vendor\n+\t\t// directory can't otherwise determine that those replacements had no effect.\n+\t\tfor _, r := range modload.ModFile().Replace {\n+\t\t\tif len(modpkgs[r.Old]) > 0 {\n+\t\t\t\t// We we already recorded this replacement in the entry for the replaced\n+\t\t\t\t// module with the packages it provides.\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tline := moduleLine(r.Old, r.New)\n+\t\t\tbuf.WriteString(line)\n+\t\t\tif cfg.BuildV {\n+\t\t\t\tos.Stderr.WriteString(line)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \tif buf.Len() == 0 {\n \t\tfmt.Fprintf(os.Stderr, \"go: no dependencies to vendor\\n\")\n \t\treturn\n@@ -92,6 +128,26 @@ func runVendor(cmd *base.Command, args []string) {\n \t}\n }\n \n+func moduleLine(m, r module.Version) string {\n+\tb := new(strings.Builder)\n+\tb.WriteString(\"# \")\n+\tb.WriteString(m.Path)\n+\tif m.Version != \"\" {\n+\t\tb.WriteString(\" \")\n+\t\tb.WriteString(m.Version)\n+\t}\n+\tif r.Path != \"\" {\n+\t\tb.WriteString(\" => \")\n+\t\tb.WriteString(r.Path)\n+\t\tif r.Version != \"\" {\n+\t\t\tb.WriteString(\" \")\n+\t\t\tb.WriteString(r.Version)\n+\t\t}\n+\t}\n+\tb.WriteString(\"\\n\")\n+\treturn b.String()\n+}\n+\n func vendorPkg(vdir, pkg string) {\n \trealPath := modload.ImportMap(pkg)\n \tif realPath != pkg && modload.ImportMap(realPath) != \"\" {"}, {"sha": "831e5cf85bba46510de1d5e4b2b7fac7690d04d2", "filename": "libgo/go/cmd/go/internal/modcmd/verify.go", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fverify.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,16 +6,18 @@ package modcmd\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/cfg\"\n \t\"fmt\"\n \t\"io/ioutil\"\n \t\"os\"\n \n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/dirhash\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/sumdb/dirhash\"\n )\n \n var cmdVerify = &base.Command{\n@@ -32,13 +34,17 @@ non-zero status.\n \tRun: runVerify,\n }\n \n+func init() {\n+\twork.AddModCommonFlags(cmdVerify)\n+}\n+\n func runVerify(cmd *base.Command, args []string) {\n \tif len(args) != 0 {\n \t\t// NOTE(rsc): Could take a module pattern.\n \t\tbase.Fatalf(\"go mod verify: verify takes no arguments\")\n \t}\n \t// Checks go mod expected behavior\n-\tif !modload.Enabled() {\n+\tif !modload.Enabled() || !modload.HasModRoot() {\n \t\tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t\t} else {"}, {"sha": "40d238519b20b09ab9d3495f5206bea8181e2c13", "filename": "libgo/go/cmd/go/internal/modcmd/why.go", "status": "modified", "additions": 7, "deletions": 3, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodcmd%2Fwhy.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,11 +5,14 @@\n package modcmd\n \n import (\n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n \t\"fmt\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/modload\"\n+\t\"cmd/go/internal/work\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n var cmdWhy = &base.Command{\n@@ -54,6 +57,7 @@ var (\n \n func init() {\n \tcmdWhy.Run = runWhy // break init cycle\n+\twork.AddModCommonFlags(cmdWhy)\n }\n \n func runWhy(cmd *base.Command, args []string) {"}, {"sha": "f465a9f395bb64c14e86ef696277478a382dfc90", "filename": "libgo/go/cmd/go/internal/modconv/convert.go", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -13,10 +13,11 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/semver\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n // ConvertLegacyConfig converts legacy config to modfile."}, {"sha": "a2a26019677dfa3b0db4a9cfcfd46d45271cbc23", "filename": "libgo/go/cmd/go/internal/modconv/convert_test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fconvert_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -19,8 +19,9 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func TestMain(m *testing.M) {"}, {"sha": "2e673c3ab9f63695e970daba042b9f095292b51a", "filename": "libgo/go/cmd/go/internal/modconv/dep.go", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fdep.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -12,9 +12,9 @@ import (\n \t\"strconv\"\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n func ParseGopkgLock(file string, data []byte) (*modfile.File, error) {"}, {"sha": "d1de3f7139dbc0bf70fd0af21005ccea913e7aad", "filename": "libgo/go/cmd/go/internal/modconv/glide.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglide.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseGlideLock(file string, data []byte) (*modfile.File, error) {"}, {"sha": "b8dc20461767e2c3968a06b31e76547ef5fde549", "filename": "libgo/go/cmd/go/internal/modconv/glock.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fglock.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseGLOCKFILE(file string, data []byte) (*modfile.File, error) {"}, {"sha": "09c0fa3ddab8d8659bd584c72f47aa49135e0680", "filename": "libgo/go/cmd/go/internal/modconv/godeps.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fgodeps.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"encoding/json\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseGodepsJSON(file string, data []byte) (*modfile.File, error) {"}, {"sha": "dc0607235f390b529db95a370e27c4820f41ed3d", "filename": "libgo/go/cmd/go/internal/modconv/modconv.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fmodconv.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -4,7 +4,7 @@\n \n package modconv\n \n-import \"cmd/go/internal/modfile\"\n+import \"golang.org/x/mod/modfile\"\n \n var Converters = map[string]func(string, []byte) (*modfile.File, error){\n \t\"GLOCKFILE\":          ParseGLOCKFILE,"}, {"sha": "4649579f65083dadcb31179f00447397c23aabf5", "filename": "libgo/go/cmd/go/internal/modconv/tsv.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Ftsv.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseDependenciesTSV(file string, data []byte) (*modfile.File, error) {"}, {"sha": "9bad2baf8fb63ba333e22b0f171ed4ff2057c5cc", "filename": "libgo/go/cmd/go/internal/modconv/vconf.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvconf.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseVendorConf(file string, data []byte) (*modfile.File, error) {"}, {"sha": "1bd025c980f8dfb216e50df1030d35c22c4aaec6", "filename": "libgo/go/cmd/go/internal/modconv/vjson.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvjson.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"encoding/json\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseVendorJSON(file string, data []byte) (*modfile.File, error) {"}, {"sha": "bcf00083a523620e03b68b18207687175cbaad1d", "filename": "libgo/go/cmd/go/internal/modconv/vmanifest.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvmanifest.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"encoding/json\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseVendorManifest(file string, data []byte) (*modfile.File, error) {"}, {"sha": "cfa41941d558b13c8488e3841803e6aa0353f3f7", "filename": "libgo/go/cmd/go/internal/modconv/vyml.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodconv%2Fvyml.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,8 +7,8 @@ package modconv\n import (\n \t\"strings\"\n \n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n )\n \n func ParseVendorYML(file string, data []byte) (*modfile.File, error) {"}, {"sha": "e4020b0b41e803f56dc2eed8d061d26d7a63f12b", "filename": "libgo/go/cmd/go/internal/modfetch/bootstrap.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fbootstrap.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,7 +6,7 @@\n \n package modfetch\n \n-import \"cmd/go/internal/module\"\n+import \"golang.org/x/mod/module\"\n \n func useSumDB(mod module.Version) bool {\n \treturn false"}, {"sha": "104fce86dda91b02697ea873f5389c262c6e2fc9", "filename": "libgo/go/cmd/go/internal/modfetch/cache.go", "status": "modified", "additions": 38, "deletions": 24, "changes": 62, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcache.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -13,26 +13,28 @@ import (\n \t\"os\"\n \t\"path/filepath\"\n \t\"strings\"\n+\t\"time\"\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/renameio\"\n-\t\"cmd/go/internal/semver\"\n-)\n \n-var QuietLookup bool // do not print about lookups\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+)\n \n var PkgMod string // $GOPATH/pkg/mod; set by package modload\n \n+const logFindingDelay = 1 * time.Second\n+\n func cacheDir(path string) (string, error) {\n \tif PkgMod == \"\" {\n \t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n \t}\n-\tenc, err := module.EncodePath(path)\n+\tenc, err := module.EscapePath(path)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -50,7 +52,7 @@ func CachePath(m module.Version, suffix string) (string, error) {\n \tif module.CanonicalVersion(m.Version) != m.Version {\n \t\treturn \"\", fmt.Errorf(\"non-canonical module version %q\", m.Version)\n \t}\n-\tencVer, err := module.EncodeVersion(m.Version)\n+\tencVer, err := module.EscapeVersion(m.Version)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -63,7 +65,7 @@ func DownloadDir(m module.Version) (string, error) {\n \tif PkgMod == \"\" {\n \t\treturn \"\", fmt.Errorf(\"internal error: modfetch.PkgMod not set\")\n \t}\n-\tenc, err := module.EncodePath(m.Path)\n+\tenc, err := module.EscapePath(m.Path)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -73,7 +75,7 @@ func DownloadDir(m module.Version) (string, error) {\n \tif module.CanonicalVersion(m.Version) != m.Version {\n \t\treturn \"\", fmt.Errorf(\"non-canonical module version %q\", m.Version)\n \t}\n-\tencVer, err := module.EncodeVersion(m.Version)\n+\tencVer, err := module.EscapeVersion(m.Version)\n \tif err != nil {\n \t\treturn \"\", err\n \t}\n@@ -93,22 +95,21 @@ func lockVersion(mod module.Version) (unlock func(), err error) {\n \treturn lockedfile.MutexAt(path).Lock()\n }\n \n-// SideLock locks a file within the module cache that that guards edits to files\n-// outside the cache, such as go.sum and go.mod files in the user's working\n-// directory. It returns a function that must be called to unlock the file.\n-func SideLock() (unlock func()) {\n+// SideLock locks a file within the module cache that that previously guarded\n+// edits to files outside the cache, such as go.sum and go.mod files in the\n+// user's working directory.\n+// If err is nil, the caller MUST eventually call the unlock function.\n+func SideLock() (unlock func(), err error) {\n \tif PkgMod == \"\" {\n \t\tbase.Fatalf(\"go: internal error: modfetch.PkgMod not set\")\n \t}\n+\n \tpath := filepath.Join(PkgMod, \"cache\", \"lock\")\n \tif err := os.MkdirAll(filepath.Dir(path), 0777); err != nil {\n-\t\tbase.Fatalf(\"go: failed to create cache directory %s: %v\", filepath.Dir(path), err)\n+\t\treturn nil, fmt.Errorf(\"failed to create cache directory: %w\", err)\n \t}\n-\tunlock, err := lockedfile.MutexAt(path).Lock()\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: failed to lock file at %v\", path)\n-\t}\n-\treturn unlock\n+\n+\treturn lockedfile.MutexAt(path).Lock()\n }\n \n // A cachingRepo is a cache around an underlying Repo,\n@@ -139,6 +140,11 @@ func (r *cachingRepo) Versions(prefix string) ([]string, error) {\n \t\terr  error\n \t}\n \tc := r.cache.Do(\"versions:\"+prefix, func() interface{} {\n+\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n+\t\t\tfmt.Fprintf(os.Stderr, \"go: finding versions for %s\\n\", r.path)\n+\t\t})\n+\t\tdefer logTimer.Stop()\n+\n \t\tlist, err := r.r.Versions(prefix)\n \t\treturn cached{list, err}\n \t}).(cached)\n@@ -161,9 +167,11 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \t\t\treturn cachedInfo{info, nil}\n \t\t}\n \n-\t\tif !QuietLookup {\n+\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n \t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s %s\\n\", r.path, rev)\n-\t\t}\n+\t\t})\n+\t\tdefer logTimer.Stop()\n+\n \t\tinfo, err = r.r.Stat(rev)\n \t\tif err == nil {\n \t\t\t// If we resolved, say, 1234abcde to v0.0.0-20180604122334-1234abcdef78,\n@@ -191,9 +199,11 @@ func (r *cachingRepo) Stat(rev string) (*RevInfo, error) {\n \n func (r *cachingRepo) Latest() (*RevInfo, error) {\n \tc := r.cache.Do(\"latest:\", func() interface{} {\n-\t\tif !QuietLookup {\n+\t\tlogTimer := time.AfterFunc(logFindingDelay, func() {\n \t\t\tfmt.Fprintf(os.Stderr, \"go: finding %s latest\\n\", r.path)\n-\t\t}\n+\t\t})\n+\t\tdefer logTimer.Stop()\n+\n \t\tinfo, err := r.r.Latest()\n \n \t\t// Save info for likely future Stat call.\n@@ -230,7 +240,9 @@ func (r *cachingRepo) GoMod(version string) ([]byte, error) {\n \n \t\ttext, err = r.r.GoMod(version)\n \t\tif err == nil {\n-\t\t\tcheckGoMod(r.path, version, text)\n+\t\t\tif err := checkGoMod(r.path, version, text); err != nil {\n+\t\t\t\treturn cached{text, err}\n+\t\t\t}\n \t\t\tif err := writeDiskGoMod(file, text); err != nil {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go: writing go.mod cache: %v\\n\", err)\n \t\t\t}\n@@ -490,7 +502,9 @@ func readDiskGoMod(path, rev string) (file string, data []byte, err error) {\n \t}\n \n \tif err == nil {\n-\t\tcheckGoMod(path, rev, data)\n+\t\tif err := checkGoMod(path, rev, data); err != nil {\n+\t\t\treturn \"\", nil, err\n+\t\t}\n \t}\n \n \treturn file, data, err"}, {"sha": "5867288c9669cf1ac22d8d8ef36dfa6ec051e6a6", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/codehost.go", "status": "modified", "additions": 3, "deletions": 4, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fcodehost.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -73,11 +73,10 @@ type Repo interface {\n \t// ReadZip downloads a zip file for the subdir subdirectory\n \t// of the given revision to a new file in a given temporary directory.\n \t// It should refuse to read more than maxSize bytes.\n-\t// It returns a ReadCloser for a streamed copy of the zip file,\n-\t// along with the actual subdirectory (possibly shorter than subdir)\n-\t// contained in the zip file. All files in the zip file are expected to be\n+\t// It returns a ReadCloser for a streamed copy of the zip file.\n+\t// All files in the zip file are expected to be\n \t// nested in a single top-level directory, whose name is not specified.\n-\tReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error)\n+\tReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, err error)\n \n \t// RecentTag returns the most recent tag on rev or one of its predecessors\n \t// with the given prefix and major version."}, {"sha": "e329cbc58e7d1ecdf9f52547d2dec19264e1ecd2", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git.go", "status": "modified", "additions": 56, "deletions": 69, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,9 +6,11 @@ package codehost\n \n import (\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n+\t\"net/url\"\n \t\"os\"\n \t\"os/exec\"\n \t\"path/filepath\"\n@@ -20,7 +22,9 @@ import (\n \n \t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/semver\"\n+\t\"cmd/go/internal/web\"\n+\n+\t\"golang.org/x/mod/semver\"\n )\n \n // GitRepo returns the code repository at the given Git remote reference.\n@@ -34,6 +38,15 @@ func LocalGitRepo(remote string) (Repo, error) {\n \treturn newGitRepoCached(remote, true)\n }\n \n+// A notExistError wraps another error to retain its original text\n+// but makes it opaquely equivalent to os.ErrNotExist.\n+type notExistError struct {\n+\terr error\n+}\n+\n+func (e notExistError) Error() string   { return e.err.Error() }\n+func (notExistError) Is(err error) bool { return err == os.ErrNotExist }\n+\n const gitWorkDirType = \"git3\"\n \n var gitRepoCache par.Cache\n@@ -85,8 +98,9 @@ func newGitRepo(remote string, localOK bool) (Repo, error) {\n \t\t\t\tos.RemoveAll(r.dir)\n \t\t\t\treturn nil, err\n \t\t\t}\n-\t\t\tr.remote = \"origin\"\n \t\t}\n+\t\tr.remoteURL = r.remote\n+\t\tr.remote = \"origin\"\n \t} else {\n \t\t// Local path.\n \t\t// Disallow colon (not in ://) because sometimes\n@@ -113,9 +127,9 @@ func newGitRepo(remote string, localOK bool) (Repo, error) {\n }\n \n type gitRepo struct {\n-\tremote string\n-\tlocal  bool\n-\tdir    string\n+\tremote, remoteURL string\n+\tlocal             bool\n+\tdir               string\n \n \tmu lockedfile.Mutex // protects fetchLevel and git repo state\n \n@@ -166,14 +180,25 @@ func (r *gitRepo) loadRefs() {\n \t// The git protocol sends all known refs and ls-remote filters them on the client side,\n \t// so we might as well record both heads and tags in one shot.\n \t// Most of the time we only care about tags but sometimes we care about heads too.\n-\tout, err := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n-\tif err != nil {\n-\t\tif rerr, ok := err.(*RunError); ok {\n+\tout, gitErr := Run(r.dir, \"git\", \"ls-remote\", \"-q\", r.remote)\n+\tif gitErr != nil {\n+\t\tif rerr, ok := gitErr.(*RunError); ok {\n \t\t\tif bytes.Contains(rerr.Stderr, []byte(\"fatal: could not read Username\")) {\n \t\t\t\trerr.HelpText = \"Confirm the import path was entered correctly.\\nIf this is a private repository, see https://golang.org/doc/faq#git_https for additional information.\"\n \t\t\t}\n \t\t}\n-\t\tr.refsErr = err\n+\n+\t\t// If the remote URL doesn't exist at all, ideally we should treat the whole\n+\t\t// repository as nonexistent by wrapping the error in a notExistError.\n+\t\t// For HTTP and HTTPS, that's easy to detect: we'll try to fetch the URL\n+\t\t// ourselves and see what code it serves.\n+\t\tif u, err := url.Parse(r.remoteURL); err == nil && (u.Scheme == \"http\" || u.Scheme == \"https\") {\n+\t\t\tif _, err := web.GetBytes(u); errors.Is(err, os.ErrNotExist) {\n+\t\t\t\tgitErr = notExistError{gitErr}\n+\t\t\t}\n+\t\t}\n+\n+\t\tr.refsErr = gitErr\n \t\treturn\n \t}\n \n@@ -241,13 +266,6 @@ func (r *gitRepo) findRef(hash string) (ref string, ok bool) {\n \treturn \"\", false\n }\n \n-func unshallow(gitDir string) []string {\n-\tif _, err := os.Stat(filepath.Join(gitDir, \"shallow\")); err == nil {\n-\t\treturn []string{\"--unshallow\"}\n-\t}\n-\treturn []string{}\n-}\n-\n // minHashDigits is the minimum number of digits to require\n // before accepting a hex digit sequence as potentially identifying\n // a specific commit in a git repo. (Of course, users can always\n@@ -397,29 +415,27 @@ func (r *gitRepo) stat(rev string) (*RevInfo, error) {\n // fetchRefsLocked requires that r.mu remain locked for the duration of the call.\n func (r *gitRepo) fetchRefsLocked() error {\n \tif r.fetchLevel < fetchAll {\n-\t\tif err := r.fetchUnshallow(\"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n+\t\t// NOTE: To work around a bug affecting Git clients up to at least 2.23.0\n+\t\t// (2019-08-16), we must first expand the set of local refs, and only then\n+\t\t// unshallow the repository as a separate fetch operation. (See\n+\t\t// golang.org/issue/34266 and\n+\t\t// https://github.com/git/git/blob/4c86140027f4a0d2caaa3ab4bd8bfc5ce3c11c8a/transport.c#L1303-L1309.)\n+\n+\t\tif _, err := Run(r.dir, \"git\", \"fetch\", \"-f\", r.remote, \"refs/heads/*:refs/heads/*\", \"refs/tags/*:refs/tags/*\"); err != nil {\n \t\t\treturn err\n \t\t}\n+\n+\t\tif _, err := os.Stat(filepath.Join(r.dir, \"shallow\")); err == nil {\n+\t\t\tif _, err := Run(r.dir, \"git\", \"fetch\", \"--unshallow\", \"-f\", r.remote); err != nil {\n+\t\t\t\treturn err\n+\t\t\t}\n+\t\t}\n+\n \t\tr.fetchLevel = fetchAll\n \t}\n \treturn nil\n }\n \n-func (r *gitRepo) fetchUnshallow(refSpecs ...string) error {\n-\t// To work around a protocol version 2 bug that breaks --unshallow,\n-\t// add -c protocol.version=0.\n-\t// TODO(rsc): The bug is believed to be server-side, meaning only\n-\t// on Google's Git servers. Once the servers are fixed, drop the\n-\t// protocol.version=0. See Google-internal bug b/110495752.\n-\tvar protoFlag []string\n-\tunshallowFlag := unshallow(r.dir)\n-\tif len(unshallowFlag) > 0 {\n-\t\tprotoFlag = []string{\"-c\", \"protocol.version=0\"}\n-\t}\n-\t_, err := Run(r.dir, \"git\", protoFlag, \"fetch\", unshallowFlag, \"-f\", r.remote, refSpecs)\n-\treturn err\n-}\n-\n // statLocal returns a RevInfo describing rev in the local git repository.\n // It uses version as info.Version.\n func (r *gitRepo) statLocal(version, rev string) (*RevInfo, error) {\n@@ -539,39 +555,10 @@ func (r *gitRepo) ReadFileRevs(revs []string, file string, maxSize int64) (map[s\n \t}\n \tdefer unlock()\n \n-\tvar refs []string\n-\tvar protoFlag []string\n-\tvar unshallowFlag []string\n-\tfor _, tag := range redo {\n-\t\trefs = append(refs, \"refs/tags/\"+tag+\":refs/tags/\"+tag)\n-\t}\n-\tif len(refs) > 1 {\n-\t\tunshallowFlag = unshallow(r.dir)\n-\t\tif len(unshallowFlag) > 0 {\n-\t\t\t// To work around a protocol version 2 bug that breaks --unshallow,\n-\t\t\t// add -c protocol.version=0.\n-\t\t\t// TODO(rsc): The bug is believed to be server-side, meaning only\n-\t\t\t// on Google's Git servers. Once the servers are fixed, drop the\n-\t\t\t// protocol.version=0. See Google-internal bug b/110495752.\n-\t\t\tprotoFlag = []string{\"-c\", \"protocol.version=0\"}\n-\t\t}\n-\t}\n-\tif _, err := Run(r.dir, \"git\", protoFlag, \"fetch\", unshallowFlag, \"-f\", r.remote, refs); err != nil {\n+\tif err := r.fetchRefsLocked(); err != nil {\n \t\treturn nil, err\n \t}\n \n-\t// TODO(bcmills): after the 1.11 freeze, replace the block above with:\n-\t//\tif r.fetchLevel <= fetchSome {\n-\t//\t\tr.fetchLevel = fetchSome\n-\t//\t\tvar refs []string\n-\t//\t\tfor _, tag := range redo {\n-\t//\t\t\trefs = append(refs, \"refs/tags/\"+tag+\":refs/tags/\"+tag)\n-\t//\t\t}\n-\t//\t\tif _, err := Run(r.dir, \"git\", \"fetch\", \"--update-shallow\", \"-f\", r.remote, refs); err != nil {\n-\t//\t\t\treturn nil, err\n-\t//\t\t}\n-\t//\t}\n-\n \tif _, err := r.readFileRevs(redo, file, files); err != nil {\n \t\treturn nil, err\n \t}\n@@ -809,25 +796,25 @@ func (r *gitRepo) DescendsFrom(rev, tag string) (bool, error) {\n \treturn false, err\n }\n \n-func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n+func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, err error) {\n \t// TODO: Use maxSize or drop it.\n \targs := []string{}\n \tif subdir != \"\" {\n \t\targs = append(args, \"--\", subdir)\n \t}\n \tinfo, err := r.Stat(rev) // download rev into local git repo\n \tif err != nil {\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n \n \tunlock, err := r.mu.Lock()\n \tif err != nil {\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n \tdefer unlock()\n \n \tif err := ensureGitAttributes(r.dir); err != nil {\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n \n \t// Incredibly, git produces different archives depending on whether\n@@ -838,12 +825,12 @@ func (r *gitRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \tarchive, err := Run(r.dir, \"git\", \"-c\", \"core.autocrlf=input\", \"-c\", \"core.eol=lf\", \"archive\", \"--format=zip\", \"--prefix=prefix/\", info.Name, args)\n \tif err != nil {\n \t\tif bytes.Contains(err.(*RunError).Stderr, []byte(\"did not match any files\")) {\n-\t\t\treturn nil, \"\", os.ErrNotExist\n+\t\t\treturn nil, os.ErrNotExist\n \t\t}\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n \n-\treturn ioutil.NopCloser(bytes.NewReader(archive)), \"\", nil\n+\treturn ioutil.NopCloser(bytes.NewReader(archive)), nil\n }\n \n // ensureGitAttributes makes sure export-subst and export-ignore features are"}, {"sha": "cc32a1eb51c64de51dee3725fe353f060723291a", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/git_test.go", "status": "modified", "additions": 16, "deletions": 11, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fgit_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -78,7 +78,16 @@ func testMain(m *testing.M) int {\n \n func testRepo(remote string) (Repo, error) {\n \tif remote == \"localGitRepo\" {\n-\t\treturn LocalGitRepo(filepath.ToSlash(localGitRepo))\n+\t\t// Convert absolute path to file URL. LocalGitRepo will not accept\n+\t\t// Windows absolute paths because they look like a host:path remote.\n+\t\t// TODO(golang.org/issue/32456): use url.FromFilePath when implemented.\n+\t\tvar url string\n+\t\tif strings.HasPrefix(localGitRepo, \"/\") {\n+\t\t\turl = \"file://\" + localGitRepo\n+\t\t} else {\n+\t\t\turl = \"file:///\" + filepath.ToSlash(localGitRepo)\n+\t\t}\n+\t\treturn LocalGitRepo(url)\n \t}\n \tkind := \"git\"\n \tfor _, k := range []string{\"hg\"} {\n@@ -246,12 +255,11 @@ func TestReadFile(t *testing.T) {\n }\n \n var readZipTests = []struct {\n-\trepo         string\n-\trev          string\n-\tsubdir       string\n-\tactualSubdir string\n-\terr          string\n-\tfiles        map[string]uint64\n+\trepo   string\n+\trev    string\n+\tsubdir string\n+\terr    string\n+\tfiles  map[string]uint64\n }{\n \t{\n \t\trepo:   gitrepo1,\n@@ -408,7 +416,7 @@ func TestReadZip(t *testing.T) {\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)\n \t\t\t}\n-\t\t\trc, actualSubdir, err := r.ReadZip(tt.rev, tt.subdir, 100000)\n+\t\t\trc, err := r.ReadZip(tt.rev, tt.subdir, 100000)\n \t\t\tif err != nil {\n \t\t\t\tif tt.err == \"\" {\n \t\t\t\t\tt.Fatalf(\"ReadZip: unexpected error %v\", err)\n@@ -425,9 +433,6 @@ func TestReadZip(t *testing.T) {\n \t\t\tif tt.err != \"\" {\n \t\t\t\tt.Fatalf(\"ReadZip: no error, wanted %v\", tt.err)\n \t\t\t}\n-\t\t\tif actualSubdir != tt.actualSubdir {\n-\t\t\t\tt.Fatalf(\"ReadZip: actualSubdir = %q, want %q\", actualSubdir, tt.actualSubdir)\n-\t\t\t}\n \t\t\tzipdata, err := ioutil.ReadAll(rc)\n \t\t\tif err != nil {\n \t\t\t\tt.Fatal(err)"}, {"sha": "835bc53c0ddec138e44b747640f2853fe38d5798", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/shell.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fshell.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -109,7 +109,7 @@ func main() {\n \t\t\tif subdir == \"-\" {\n \t\t\t\tsubdir = \"\"\n \t\t\t}\n-\t\t\trc, _, err := repo.ReadZip(f[1], subdir, 10<<20)\n+\t\t\trc, err := repo.ReadZip(f[1], subdir, 10<<20)\n \t\t\tif err != nil {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"?%s\\n\", err)\n \t\t\t\tcontinue"}, {"sha": "6ec9e59c9c6469533f42d533eb5cbd9ae3afa6f6", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/svn.go", "status": "added", "additions": 154, "deletions": 0, "changes": 154, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fsvn.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fsvn.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fsvn.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,154 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package codehost\n+\n+import (\n+\t\"archive/zip\"\n+\t\"encoding/xml\"\n+\t\"fmt\"\n+\t\"io\"\n+\t\"os\"\n+\t\"path\"\n+\t\"path/filepath\"\n+\t\"time\"\n+)\n+\n+func svnParseStat(rev, out string) (*RevInfo, error) {\n+\tvar log struct {\n+\t\tLogentry struct {\n+\t\t\tRevision int64  `xml:\"revision,attr\"`\n+\t\t\tDate     string `xml:\"date\"`\n+\t\t} `xml:\"logentry\"`\n+\t}\n+\tif err := xml.Unmarshal([]byte(out), &log); err != nil {\n+\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t}\n+\n+\tt, err := time.Parse(time.RFC3339, log.Logentry.Date)\n+\tif err != nil {\n+\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n+\t}\n+\n+\tinfo := &RevInfo{\n+\t\tName:    fmt.Sprintf(\"%d\", log.Logentry.Revision),\n+\t\tShort:   fmt.Sprintf(\"%012d\", log.Logentry.Revision),\n+\t\tTime:    t.UTC(),\n+\t\tVersion: rev,\n+\t}\n+\treturn info, nil\n+}\n+\n+func svnReadZip(dst io.Writer, workDir, rev, subdir, remote string) (err error) {\n+\t// The subversion CLI doesn't provide a command to write the repository\n+\t// directly to an archive, so we need to export it to the local filesystem\n+\t// instead. Unfortunately, the local filesystem might apply arbitrary\n+\t// normalization to the filenames, so we need to obtain those directly.\n+\t//\n+\t// 'svn export' prints the filenames as they are written, but from reading the\n+\t// svn source code (as of revision 1868933), those filenames are encoded using\n+\t// the system locale rather than preserved byte-for-byte from the origin. For\n+\t// our purposes, that won't do, but we don't want to go mucking around with\n+\t// the user's locale settings either \u2014 that could impact error messages, and\n+\t// we don't know what locales the user has available or what LC_* variables\n+\t// their platform supports.\n+\t//\n+\t// Instead, we'll do a two-pass export: first we'll run 'svn list' to get the\n+\t// canonical filenames, then we'll 'svn export' and look for those filenames\n+\t// in the local filesystem. (If there is an encoding problem at that point, we\n+\t// would probably reject the resulting module anyway.)\n+\n+\tremotePath := remote\n+\tif subdir != \"\" {\n+\t\tremotePath += \"/\" + subdir\n+\t}\n+\n+\tout, err := Run(workDir, []string{\n+\t\t\"svn\", \"list\",\n+\t\t\"--non-interactive\",\n+\t\t\"--xml\",\n+\t\t\"--incremental\",\n+\t\t\"--recursive\",\n+\t\t\"--revision\", rev,\n+\t\t\"--\", remotePath,\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\ttype listEntry struct {\n+\t\tKind string `xml:\"kind,attr\"`\n+\t\tName string `xml:\"name\"`\n+\t\tSize int64  `xml:\"size\"`\n+\t}\n+\tvar list struct {\n+\t\tEntries []listEntry `xml:\"entry\"`\n+\t}\n+\tif err := xml.Unmarshal(out, &list); err != nil {\n+\t\treturn vcsErrorf(\"unexpected response from svn list --xml: %v\\n%s\", err, out)\n+\t}\n+\n+\texportDir := filepath.Join(workDir, \"export\")\n+\t// Remove any existing contents from a previous (failed) run.\n+\tif err := os.RemoveAll(exportDir); err != nil {\n+\t\treturn err\n+\t}\n+\tdefer os.RemoveAll(exportDir) // best-effort\n+\n+\t_, err = Run(workDir, []string{\n+\t\t\"svn\", \"export\",\n+\t\t\"--non-interactive\",\n+\t\t\"--quiet\",\n+\n+\t\t// Suppress any platform- or host-dependent transformations.\n+\t\t\"--native-eol\", \"LF\",\n+\t\t\"--ignore-externals\",\n+\t\t\"--ignore-keywords\",\n+\n+\t\t\"--revision\", rev,\n+\t\t\"--\", remotePath,\n+\t\texportDir,\n+\t})\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\n+\t// Scrape the exported files out of the filesystem and encode them in the zipfile.\n+\n+\t// \u201cAll files in the zip file are expected to be\n+\t// nested in a single top-level directory, whose name is not specified.\u201d\n+\t// We'll (arbitrarily) choose the base of the remote path.\n+\tbasePath := path.Join(path.Base(remote), subdir)\n+\n+\tzw := zip.NewWriter(dst)\n+\tfor _, e := range list.Entries {\n+\t\tif e.Kind != \"file\" {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tzf, err := zw.Create(path.Join(basePath, e.Name))\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tf, err := os.Open(filepath.Join(exportDir, e.Name))\n+\t\tif err != nil {\n+\t\t\tif os.IsNotExist(err) {\n+\t\t\t\treturn vcsErrorf(\"file reported by 'svn list', but not written by 'svn export': %s\", e.Name)\n+\t\t\t}\n+\t\t\treturn fmt.Errorf(\"error opening file created by 'svn export': %v\", err)\n+\t\t}\n+\n+\t\tn, err := io.Copy(zf, f)\n+\t\tf.Close()\n+\t\tif err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t\tif n != e.Size {\n+\t\t\treturn vcsErrorf(\"file size differs between 'svn list' and 'svn export': file %s listed as %v bytes, but exported as %v bytes\", e.Name, e.Size, n)\n+\t\t}\n+\t}\n+\n+\treturn zw.Close()\n+}"}, {"sha": "7284557f4ba3377b36ed87ccf8315cf6a4544ae3", "filename": "libgo/go/cmd/go/internal/modfetch/codehost/vcs.go", "status": "modified", "additions": 56, "deletions": 48, "changes": 104, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcodehost%2Fvcs.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,7 @@\n package codehost\n \n import (\n-\t\"encoding/xml\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"internal/lazyregexp\"\n \t\"io\"\n@@ -122,19 +122,20 @@ func newVCSRepo(vcs, remote string) (Repo, error) {\n const vcsWorkDirType = \"vcs1.\"\n \n type vcsCmd struct {\n-\tvcs           string                                            // vcs name \"hg\"\n-\tinit          func(remote string) []string                      // cmd to init repo to track remote\n-\ttags          func(remote string) []string                      // cmd to list local tags\n-\ttagRE         *lazyregexp.Regexp                                // regexp to extract tag names from output of tags cmd\n-\tbranches      func(remote string) []string                      // cmd to list local branches\n-\tbranchRE      *lazyregexp.Regexp                                // regexp to extract branch names from output of tags cmd\n-\tbadLocalRevRE *lazyregexp.Regexp                                // regexp of names that must not be served out of local cache without doing fetch first\n-\tstatLocal     func(rev, remote string) []string                 // cmd to stat local rev\n-\tparseStat     func(rev, out string) (*RevInfo, error)           // cmd to parse output of statLocal\n-\tfetch         []string                                          // cmd to fetch everything from remote\n-\tlatest        string                                            // name of latest commit on remote (tip, HEAD, etc)\n-\treadFile      func(rev, file, remote string) []string           // cmd to read rev's file\n-\treadZip       func(rev, subdir, remote, target string) []string // cmd to read rev's subdir as zip file\n+\tvcs           string                                                         // vcs name \"hg\"\n+\tinit          func(remote string) []string                                   // cmd to init repo to track remote\n+\ttags          func(remote string) []string                                   // cmd to list local tags\n+\ttagRE         *lazyregexp.Regexp                                             // regexp to extract tag names from output of tags cmd\n+\tbranches      func(remote string) []string                                   // cmd to list local branches\n+\tbranchRE      *lazyregexp.Regexp                                             // regexp to extract branch names from output of tags cmd\n+\tbadLocalRevRE *lazyregexp.Regexp                                             // regexp of names that must not be served out of local cache without doing fetch first\n+\tstatLocal     func(rev, remote string) []string                              // cmd to stat local rev\n+\tparseStat     func(rev, out string) (*RevInfo, error)                        // cmd to parse output of statLocal\n+\tfetch         []string                                                       // cmd to fetch everything from remote\n+\tlatest        string                                                         // name of latest commit on remote (tip, HEAD, etc)\n+\treadFile      func(rev, file, remote string) []string                        // cmd to read rev's file\n+\treadZip       func(rev, subdir, remote, target string) []string              // cmd to read rev's subdir as zip file\n+\tdoReadZip     func(dst io.Writer, workDir, rev, subdir, remote string) error // arbitrary function to read rev's subdir as zip file\n }\n \n var re = lazyregexp.New\n@@ -191,7 +192,7 @@ var vcsCmds = map[string]*vcsCmd{\n \t\treadFile: func(rev, file, remote string) []string {\n \t\t\treturn []string{\"svn\", \"cat\", \"--\", remote + \"/\" + file + \"@\" + rev}\n \t\t},\n-\t\t// TODO: zip\n+\t\tdoReadZip: svnReadZip,\n \t},\n \n \t\"bzr\": {\n@@ -417,14 +418,14 @@ func (r *vcsRepo) DescendsFrom(rev, tag string) (bool, error) {\n \treturn false, vcsErrorf(\"DescendsFrom not implemented\")\n }\n \n-func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, actualSubdir string, err error) {\n-\tif r.cmd.readZip == nil {\n-\t\treturn nil, \"\", vcsErrorf(\"ReadZip not implemented for %s\", r.cmd.vcs)\n+func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser, err error) {\n+\tif r.cmd.readZip == nil && r.cmd.doReadZip == nil {\n+\t\treturn nil, vcsErrorf(\"ReadZip not implemented for %s\", r.cmd.vcs)\n \t}\n \n \tunlock, err := r.mu.Lock()\n \tif err != nil {\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n \tdefer unlock()\n \n@@ -433,9 +434,19 @@ func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \t}\n \tf, err := ioutil.TempFile(\"\", \"go-readzip-*.zip\")\n \tif err != nil {\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n-\tif r.cmd.vcs == \"fossil\" {\n+\tif r.cmd.doReadZip != nil {\n+\t\tlw := &limitedWriter{\n+\t\t\tW:               f,\n+\t\t\tN:               maxSize,\n+\t\t\tErrLimitReached: errors.New(\"ReadZip: encoded file exceeds allowed size\"),\n+\t\t}\n+\t\terr = r.cmd.doReadZip(lw, r.dir, rev, subdir, r.remote)\n+\t\tif err == nil {\n+\t\t\t_, err = f.Seek(0, io.SeekStart)\n+\t\t}\n+\t} else if r.cmd.vcs == \"fossil\" {\n \t\t// If you run\n \t\t//\tfossil zip -R .fossil --name prefix trunk /tmp/x.zip\n \t\t// fossil fails with \"unable to create directory /tmp\" [sic].\n@@ -454,9 +465,9 @@ func (r *vcsRepo) ReadZip(rev, subdir string, maxSize int64) (zip io.ReadCloser,\n \tif err != nil {\n \t\tf.Close()\n \t\tos.Remove(f.Name())\n-\t\treturn nil, \"\", err\n+\t\treturn nil, err\n \t}\n-\treturn &deleteCloser{f}, \"\", nil\n+\treturn &deleteCloser{f}, nil\n }\n \n // deleteCloser is a file that gets deleted on Close.\n@@ -502,31 +513,6 @@ func hgParseStat(rev, out string) (*RevInfo, error) {\n \treturn info, nil\n }\n \n-func svnParseStat(rev, out string) (*RevInfo, error) {\n-\tvar log struct {\n-\t\tLogentry struct {\n-\t\t\tRevision int64  `xml:\"revision,attr\"`\n-\t\t\tDate     string `xml:\"date\"`\n-\t\t} `xml:\"logentry\"`\n-\t}\n-\tif err := xml.Unmarshal([]byte(out), &log); err != nil {\n-\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n-\t}\n-\n-\tt, err := time.Parse(time.RFC3339, log.Logentry.Date)\n-\tif err != nil {\n-\t\treturn nil, vcsErrorf(\"unexpected response from svn log --xml: %v\\n%s\", err, out)\n-\t}\n-\n-\tinfo := &RevInfo{\n-\t\tName:    fmt.Sprintf(\"%d\", log.Logentry.Revision),\n-\t\tShort:   fmt.Sprintf(\"%012d\", log.Logentry.Revision),\n-\t\tTime:    t.UTC(),\n-\t\tVersion: rev,\n-\t}\n-\treturn info, nil\n-}\n-\n func bzrParseStat(rev, out string) (*RevInfo, error) {\n \tvar revno int64\n \tvar tm time.Time\n@@ -606,3 +592,25 @@ func fossilParseStat(rev, out string) (*RevInfo, error) {\n \t}\n \treturn nil, vcsErrorf(\"unexpected response from fossil info: %q\", out)\n }\n+\n+type limitedWriter struct {\n+\tW               io.Writer\n+\tN               int64\n+\tErrLimitReached error\n+}\n+\n+func (l *limitedWriter) Write(p []byte) (n int, err error) {\n+\tif l.N > 0 {\n+\t\tmax := len(p)\n+\t\tif l.N < int64(max) {\n+\t\t\tmax = int(l.N)\n+\t\t}\n+\t\tn, err = l.W.Write(p[:max])\n+\t\tl.N -= int64(n)\n+\t\tif err != nil || n >= len(p) {\n+\t\t\treturn n, err\n+\t\t}\n+\t}\n+\n+\treturn n, l.ErrLimitReached\n+}"}, {"sha": "de757ecd27bc19c8a7c2cf38afa90dd6fc25a3e0", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo.go", "status": "modified", "additions": 184, "deletions": 126, "changes": 310, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,19 +6,23 @@ package modfetch\n \n import (\n \t\"archive/zip\"\n+\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"path\"\n+\t\"sort\"\n \t\"strings\"\n \t\"time\"\n \n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+\tmodzip \"golang.org/x/mod/zip\"\n )\n \n // A codeRepo implements modfetch.Repo using an underlying codehost.Repo.\n@@ -140,11 +144,13 @@ func (r *codeRepo) Versions(prefix string) ([]string, error) {\n \t}\n \ttags, err := r.code.Tags(p)\n \tif err != nil {\n-\t\treturn nil, err\n+\t\treturn nil, &module.ModuleError{\n+\t\t\tPath: r.modPath,\n+\t\t\tErr:  err,\n+\t\t}\n \t}\n \n-\tlist := []string{}\n-\tvar incompatible []string\n+\tvar list, incompatible []string\n \tfor _, tag := range tags {\n \t\tif !strings.HasPrefix(tag, p) {\n \t\t\tcontinue\n@@ -156,32 +162,114 @@ func (r *codeRepo) Versions(prefix string) ([]string, error) {\n \t\tif v == \"\" || v != module.CanonicalVersion(v) || IsPseudoVersion(v) {\n \t\t\tcontinue\n \t\t}\n-\t\tif err := module.MatchPathMajor(v, r.pathMajor); err != nil {\n+\n+\t\tif err := module.CheckPathMajor(v, r.pathMajor); err != nil {\n \t\t\tif r.codeDir == \"\" && r.pathMajor == \"\" && semver.Major(v) > \"v1\" {\n \t\t\t\tincompatible = append(incompatible, v)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n+\n \t\tlist = append(list, v)\n \t}\n+\tSortVersions(list)\n+\tSortVersions(incompatible)\n+\n+\treturn r.appendIncompatibleVersions(list, incompatible)\n+}\n \n-\tif len(incompatible) > 0 {\n-\t\t// Check for later versions that were created not following semantic import versioning,\n-\t\t// as indicated by the absence of a go.mod file. Those versions can be addressed\n-\t\t// by referring to them with a +incompatible suffix, as in v17.0.0+incompatible.\n-\t\tfiles, err := r.code.ReadFileRevs(incompatible, \"go.mod\", codehost.MaxGoMod)\n+// appendIncompatibleVersions appends \"+incompatible\" versions to list if\n+// appropriate, returning the final list.\n+//\n+// The incompatible list contains candidate versions without the '+incompatible'\n+// prefix.\n+//\n+// Both list and incompatible must be sorted in semantic order.\n+func (r *codeRepo) appendIncompatibleVersions(list, incompatible []string) ([]string, error) {\n+\tif len(incompatible) == 0 || r.pathMajor != \"\" {\n+\t\t// No +incompatible versions are possible, so no need to check them.\n+\t\treturn list, nil\n+\t}\n+\n+\t// We assume that if the latest release of any major version has a go.mod\n+\t// file, all subsequent major versions will also have go.mod files (and thus\n+\t// be ineligible for use as +incompatible versions).\n+\t// If we're wrong about a major version, users will still be able to 'go get'\n+\t// specific higher versions explicitly \u2014 they just won't affect 'latest' or\n+\t// appear in 'go list'.\n+\t//\n+\t// Conversely, we assume that if the latest release of any major version lacks\n+\t// a go.mod file, all versions also lack go.mod files. If we're wrong, we may\n+\t// include a +incompatible version that isn't really valid, but most\n+\t// operations won't try to use that version anyway.\n+\t//\n+\t// These optimizations bring\n+\t// 'go list -versions -m github.com/openshift/origin' down from 1m58s to 0m37s.\n+\t// That's still not great, but a substantial improvement.\n+\n+\tversionHasGoMod := func(v string) (bool, error) {\n+\t\t_, err := r.code.ReadFile(v, \"go.mod\", codehost.MaxGoMod)\n+\t\tif err == nil {\n+\t\t\treturn true, nil\n+\t\t}\n+\t\tif !os.IsNotExist(err) {\n+\t\t\treturn false, &module.ModuleError{\n+\t\t\t\tPath: r.modPath,\n+\t\t\t\tErr:  err,\n+\t\t\t}\n+\t\t}\n+\t\treturn false, nil\n+\t}\n+\n+\tif len(list) > 0 {\n+\t\tok, err := versionHasGoMod(list[len(list)-1])\n \t\tif err != nil {\n \t\t\treturn nil, err\n \t\t}\n-\t\tfor _, rev := range incompatible {\n-\t\t\tf := files[rev]\n-\t\t\tif os.IsNotExist(f.Err) {\n-\t\t\t\tlist = append(list, rev+\"+incompatible\")\n-\t\t\t}\n+\t\tif ok {\n+\t\t\t// The latest compatible version has a go.mod file, so assume that all\n+\t\t\t// subsequent versions do as well, and do not include any +incompatible\n+\t\t\t// versions. Even if we are wrong, the author clearly intends module\n+\t\t\t// consumers to be on the v0/v1 line instead of a higher +incompatible\n+\t\t\t// version. (See https://golang.org/issue/34189.)\n+\t\t\t//\n+\t\t\t// We know of at least two examples where this behavior is desired\n+\t\t\t// (github.com/russross/blackfriday@v2.0.0 and\n+\t\t\t// github.com/libp2p/go-libp2p@v6.0.23), and (as of 2019-10-29) have no\n+\t\t\t// concrete examples for which it is undesired.\n+\t\t\treturn list, nil\n \t\t}\n \t}\n \n-\tSortVersions(list)\n+\tvar lastMajor string\n+\tfor i, v := range incompatible {\n+\t\tmajor := semver.Major(v)\n+\t\tif major == lastMajor {\n+\t\t\tlist = append(list, v+\"+incompatible\")\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\trem := incompatible[i:]\n+\t\tj := sort.Search(len(rem), func(j int) bool {\n+\t\t\treturn semver.Major(rem[j]) != major\n+\t\t})\n+\t\tlatestAtMajor := rem[j-1]\n+\n+\t\tok, err := versionHasGoMod(latestAtMajor)\n+\t\tif err != nil {\n+\t\t\treturn nil, err\n+\t\t}\n+\t\tif ok {\n+\t\t\t// This major version has a go.mod file, so it is not allowed as\n+\t\t\t// +incompatible. Subsequent major versions are likely to also have\n+\t\t\t// go.mod files, so stop here.\n+\t\t\tbreak\n+\t\t}\n+\n+\t\tlastMajor = major\n+\t\tlist = append(list, v+\"+incompatible\")\n+\t}\n+\n \treturn list, nil\n }\n \n@@ -271,7 +359,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t\t\tPath: r.modPath,\n \t\t\t\tErr: &module.InvalidVersionError{\n \t\t\t\t\tVersion: info2.Version,\n-\t\t\t\t\tErr:     notExistError(err.Error()),\n+\t\t\t\t\tErr:     notExistError{err: err},\n \t\t\t\t},\n \t\t\t}\n \t\t}\n@@ -287,7 +375,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t\t\t}\n \t\t\t}\n \n-\t\t\tif err := module.MatchPathMajor(strings.TrimSuffix(info2.Version, \"+incompatible\"), r.pathMajor); err == nil {\n+\t\t\tif err := module.CheckPathMajor(strings.TrimSuffix(info2.Version, \"+incompatible\"), r.pathMajor); err == nil {\n \t\t\t\treturn nil, invalidf(\"+incompatible suffix not allowed: major version %s is compatible\", semver.Major(info2.Version))\n \t\t\t}\n \t\t}\n@@ -311,7 +399,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t\treturn checkGoMod()\n \t\t}\n \n-\t\tif err := module.MatchPathMajor(info2.Version, r.pathMajor); err != nil {\n+\t\tif err := module.CheckPathMajor(info2.Version, r.pathMajor); err != nil {\n \t\t\tif canUseIncompatible() {\n \t\t\t\tinfo2.Version += \"+incompatible\"\n \t\t\t\treturn checkGoMod()\n@@ -359,7 +447,7 @@ func (r *codeRepo) convert(info *codehost.RevInfo, statVers string) (*RevInfo, e\n \t\t\ttagIsCanonical = true\n \t\t}\n \n-\t\tif err := module.MatchPathMajor(v, r.pathMajor); err != nil {\n+\t\tif err := module.CheckPathMajor(v, r.pathMajor); err != nil {\n \t\t\tif canUseIncompatible() {\n \t\t\t\treturn v + \"+incompatible\", tagIsCanonical\n \t\t\t}\n@@ -458,7 +546,7 @@ func (r *codeRepo) validatePseudoVersion(info *codehost.RevInfo, version string)\n \t\t}\n \t}()\n \n-\tif err := module.MatchPathMajor(version, r.pathMajor); err != nil {\n+\tif err := module.CheckPathMajor(version, r.pathMajor); err != nil {\n \t\treturn err\n \t}\n \n@@ -631,9 +719,6 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \t\t// because of replacement modules. This might be a fork of\n \t\t// the real module, found at a different path, usable only in\n \t\t// a replace directive.\n-\t\t//\n-\t\t// TODO(bcmills): This doesn't seem right. Investigate futher.\n-\t\t// (Notably: why can't we replace foo/v2 with fork-of-foo/v3?)\n \t\tdir2 := path.Join(r.codeDir, r.pathMajor[1:])\n \t\tfile2 = path.Join(dir2, \"go.mod\")\n \t\tgomod2, err2 := r.code.ReadFile(rev, file2, codehost.MaxGoMod)\n@@ -659,11 +744,11 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \n \t// Not v2/go.mod, so it's either go.mod or nothing. Which is it?\n \tif found1 {\n-\t\t// Explicit go.mod with matching module path OK.\n+\t\t// Explicit go.mod with matching major version ok.\n \t\treturn rev, r.codeDir, gomod1, nil\n \t}\n \tif err1 == nil {\n-\t\t// Explicit go.mod with non-matching module path disallowed.\n+\t\t// Explicit go.mod with non-matching major version disallowed.\n \t\tsuffix := \"\"\n \t\tif file2 != \"\" {\n \t\t\tsuffix = fmt.Sprintf(\" (and ...%s/go.mod does not exist)\", r.pathMajor)\n@@ -674,6 +759,9 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \t\tif r.pathMajor != \"\" { // \".v1\", \".v2\" for gopkg.in\n \t\t\treturn \"\", \"\", nil, fmt.Errorf(\"%s has non-...%s module path %q%s at revision %s\", file1, r.pathMajor, mpath1, suffix, rev)\n \t\t}\n+\t\tif _, _, ok := module.SplitPathVersion(mpath1); !ok {\n+\t\t\treturn \"\", \"\", nil, fmt.Errorf(\"%s has malformed module path %q%s at revision %s\", file1, mpath1, suffix, rev)\n+\t\t}\n \t\treturn \"\", \"\", nil, fmt.Errorf(\"%s has post-%s module path %q%s at revision %s\", file1, semver.Major(version), mpath1, suffix, rev)\n \t}\n \n@@ -690,24 +778,43 @@ func (r *codeRepo) findDir(version string) (rev, dir string, gomod []byte, err e\n \treturn \"\", \"\", nil, fmt.Errorf(\"missing %s/go.mod at revision %s\", r.pathPrefix, rev)\n }\n \n+// isMajor reports whether the versions allowed for mpath are compatible with\n+// the major version(s) implied by pathMajor, or false if mpath has an invalid\n+// version suffix.\n func isMajor(mpath, pathMajor string) bool {\n \tif mpath == \"\" {\n+\t\t// If we don't have a path, we don't know what version(s) it is compatible with.\n+\t\treturn false\n+\t}\n+\t_, mpathMajor, ok := module.SplitPathVersion(mpath)\n+\tif !ok {\n+\t\t// An invalid module path is not compatible with any version.\n \t\treturn false\n \t}\n \tif pathMajor == \"\" {\n-\t\t// mpath must NOT have version suffix.\n-\t\ti := len(mpath)\n-\t\tfor i > 0 && '0' <= mpath[i-1] && mpath[i-1] <= '9' {\n-\t\t\ti--\n-\t\t}\n-\t\tif i < len(mpath) && i >= 2 && mpath[i-1] == 'v' && mpath[i-2] == '/' {\n-\t\t\t// Found valid suffix.\n+\t\t// All of the valid versions for a gopkg.in module that requires major\n+\t\t// version v0 or v1 are compatible with the \"v0 or v1\" implied by an empty\n+\t\t// pathMajor.\n+\t\tswitch module.PathMajorPrefix(mpathMajor) {\n+\t\tcase \"\", \"v0\", \"v1\":\n+\t\t\treturn true\n+\t\tdefault:\n \t\t\treturn false\n \t\t}\n-\t\treturn true\n \t}\n-\t// Otherwise pathMajor is \".v1\", \".v2\" (gopkg.in), or \"/v2\", \"/v3\" etc.\n-\treturn strings.HasSuffix(mpath, pathMajor)\n+\tif mpathMajor == \"\" {\n+\t\t// Even if pathMajor is \".v0\" or \".v1\", we can't be sure that a module\n+\t\t// without a suffix is tagged appropriately. Besides, we don't expect clones\n+\t\t// of non-gopkg.in modules to have gopkg.in paths, so a non-empty,\n+\t\t// non-gopkg.in mpath is probably the wrong module for any such pathMajor\n+\t\t// anyway.\n+\t\treturn false\n+\t}\n+\t// If both pathMajor and mpathMajor are non-empty, then we only care that they\n+\t// have the same major-version validation rules. A clone fetched via a /v2\n+\t// path might replace a module with path gopkg.in/foo.v2-unstable, and that's\n+\t// ok.\n+\treturn pathMajor[1:] == mpathMajor[1:]\n }\n \n func (r *codeRepo) GoMod(version string) (data []byte, err error) {\n@@ -774,19 +881,16 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t\t}\n \t}\n \n-\trev, dir, _, err := r.findDir(version)\n+\trev, subdir, _, err := r.findDir(version)\n \tif err != nil {\n \t\treturn err\n \t}\n-\tdl, actualDir, err := r.code.ReadZip(rev, dir, codehost.MaxZipFile)\n+\tdl, err := r.code.ReadZip(rev, subdir, codehost.MaxZipFile)\n \tif err != nil {\n \t\treturn err\n \t}\n \tdefer dl.Close()\n-\tif actualDir != \"\" && !hasPathPrefix(dir, actualDir) {\n-\t\treturn fmt.Errorf(\"internal error: downloading %v %v: dir=%q but actualDir=%q\", r.modPath, rev, dir, actualDir)\n-\t}\n-\tsubdir := strings.Trim(strings.TrimPrefix(dir, actualDir), \"/\")\n+\tsubdir = strings.Trim(subdir, \"/\")\n \n \t// Spool to local file.\n \tf, err := ioutil.TempFile(\"\", \"go-codehost-\")\n@@ -817,13 +921,12 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t\treturn err\n \t}\n \n-\tzw := zip.NewWriter(dst)\n+\tvar files []modzip.File\n \tif subdir != \"\" {\n \t\tsubdir += \"/\"\n \t}\n \thaveLICENSE := false\n \ttopPrefix := \"\"\n-\thaveGoMod := make(map[string]bool)\n \tfor _, zf := range zr.File {\n \t\tif topPrefix == \"\" {\n \t\t\ti := strings.Index(zf.Name, \"/\")\n@@ -835,106 +938,61 @@ func (r *codeRepo) Zip(dst io.Writer, version string) error {\n \t\tif !strings.HasPrefix(zf.Name, topPrefix) {\n \t\t\treturn fmt.Errorf(\"zip file contains more than one top-level directory\")\n \t\t}\n-\t\tdir, file := path.Split(zf.Name)\n-\t\tif file == \"go.mod\" {\n-\t\t\thaveGoMod[dir] = true\n-\t\t}\n-\t}\n-\troot := topPrefix + subdir\n-\tinSubmodule := func(name string) bool {\n-\t\tfor {\n-\t\t\tdir, _ := path.Split(name)\n-\t\t\tif len(dir) <= len(root) {\n-\t\t\t\treturn false\n-\t\t\t}\n-\t\t\tif haveGoMod[dir] {\n-\t\t\t\treturn true\n-\t\t\t}\n-\t\t\tname = dir[:len(dir)-1]\n-\t\t}\n-\t}\n-\n-\tfor _, zf := range zr.File {\n-\t\tif !zf.FileInfo().Mode().IsRegular() {\n-\t\t\t// Skip symlinks (golang.org/issue/27093).\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tif topPrefix == \"\" {\n-\t\t\ti := strings.Index(zf.Name, \"/\")\n-\t\t\tif i < 0 {\n-\t\t\t\treturn fmt.Errorf(\"missing top-level directory prefix\")\n-\t\t\t}\n-\t\t\ttopPrefix = zf.Name[:i+1]\n-\t\t}\n-\t\tif strings.HasSuffix(zf.Name, \"/\") { // drop directory dummy entries\n-\t\t\tcontinue\n-\t\t}\n-\t\tif !strings.HasPrefix(zf.Name, topPrefix) {\n-\t\t\treturn fmt.Errorf(\"zip file contains more than one top-level directory\")\n-\t\t}\n \t\tname := strings.TrimPrefix(zf.Name, topPrefix)\n \t\tif !strings.HasPrefix(name, subdir) {\n \t\t\tcontinue\n \t\t}\n-\t\tif name == \".hg_archival.txt\" {\n-\t\t\t// Inserted by hg archive.\n-\t\t\t// Not correct to drop from other version control systems, but too bad.\n-\t\t\tcontinue\n-\t\t}\n \t\tname = strings.TrimPrefix(name, subdir)\n-\t\tif isVendoredPackage(name) {\n-\t\t\tcontinue\n-\t\t}\n-\t\tif inSubmodule(zf.Name) {\n+\t\tif name == \"\" || strings.HasSuffix(name, \"/\") {\n \t\t\tcontinue\n \t\t}\n-\t\tbase := path.Base(name)\n-\t\tif strings.ToLower(base) == \"go.mod\" && base != \"go.mod\" {\n-\t\t\treturn fmt.Errorf(\"zip file contains %s, want all lower-case go.mod\", zf.Name)\n-\t\t}\n+\t\tfiles = append(files, zipFile{name: name, f: zf})\n \t\tif name == \"LICENSE\" {\n \t\t\thaveLICENSE = true\n \t\t}\n-\t\tsize := int64(zf.UncompressedSize64)\n-\t\tif size < 0 || maxSize < size {\n-\t\t\treturn fmt.Errorf(\"module source tree too big\")\n-\t\t}\n-\t\tmaxSize -= size\n-\n-\t\trc, err := zf.Open()\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tw, err := zw.Create(r.modPrefix(version) + \"/\" + name)\n-\t\tif err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tlr := &io.LimitedReader{R: rc, N: size + 1}\n-\t\tif _, err := io.Copy(w, lr); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif lr.N <= 0 {\n-\t\t\treturn fmt.Errorf(\"individual file too large\")\n-\t\t}\n \t}\n \n \tif !haveLICENSE && subdir != \"\" {\n \t\tdata, err := r.code.ReadFile(rev, \"LICENSE\", codehost.MaxLICENSE)\n \t\tif err == nil {\n-\t\t\tw, err := zw.Create(r.modPrefix(version) + \"/LICENSE\")\n-\t\t\tif err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t\tif _, err := w.Write(data); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n+\t\t\tfiles = append(files, dataFile{name: \"LICENSE\", data: data})\n \t\t}\n \t}\n \n-\treturn zw.Close()\n+\treturn modzip.Create(dst, module.Version{Path: r.modPath, Version: version}, files)\n+}\n+\n+type zipFile struct {\n+\tname string\n+\tf    *zip.File\n+}\n+\n+func (f zipFile) Path() string                 { return f.name }\n+func (f zipFile) Lstat() (os.FileInfo, error)  { return f.f.FileInfo(), nil }\n+func (f zipFile) Open() (io.ReadCloser, error) { return f.f.Open() }\n+\n+type dataFile struct {\n+\tname string\n+\tdata []byte\n+}\n+\n+func (f dataFile) Path() string                { return f.name }\n+func (f dataFile) Lstat() (os.FileInfo, error) { return dataFileInfo{f}, nil }\n+func (f dataFile) Open() (io.ReadCloser, error) {\n+\treturn ioutil.NopCloser(bytes.NewReader(f.data)), nil\n }\n \n+type dataFileInfo struct {\n+\tf dataFile\n+}\n+\n+func (fi dataFileInfo) Name() string       { return path.Base(fi.f.name) }\n+func (fi dataFileInfo) Size() int64        { return int64(len(fi.f.data)) }\n+func (fi dataFileInfo) Mode() os.FileMode  { return 0644 }\n+func (fi dataFileInfo) ModTime() time.Time { return time.Time{} }\n+func (fi dataFileInfo) IsDir() bool        { return false }\n+func (fi dataFileInfo) Sys() interface{}   { return nil }\n+\n // hasPathPrefix reports whether the path s begins with the\n // elements in prefix.\n func hasPathPrefix(s, prefix string) bool {"}, {"sha": "39830948fb0d5ecd430154c836af98d054e715e4", "filename": "libgo/go/cmd/go/internal/modfetch/coderepo_test.go", "status": "modified", "additions": 220, "deletions": 158, "changes": 378, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fcoderepo_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,7 +6,11 @@ package modfetch\n \n import (\n \t\"archive/zip\"\n+\t\"crypto/sha256\"\n+\t\"encoding/hex\"\n+\t\"hash\"\n \t\"internal/testenv\"\n+\t\"io\"\n \t\"io/ioutil\"\n \t\"log\"\n \t\"os\"\n@@ -17,6 +21,8 @@ import (\n \n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch/codehost\"\n+\n+\t\"golang.org/x/mod/sumdb/dirhash\"\n )\n \n func TestMain(m *testing.M) {\n@@ -52,20 +58,22 @@ var altVgotests = map[string]string{\n }\n \n type codeRepoTest struct {\n-\tvcs      string\n-\tpath     string\n-\tlookerr  string\n-\tmpath    string\n-\trev      string\n-\terr      string\n-\tversion  string\n-\tname     string\n-\tshort    string\n-\ttime     time.Time\n-\tgomod    string\n-\tgomoderr string\n-\tzip      []string\n-\tziperr   string\n+\tvcs         string\n+\tpath        string\n+\tlookErr     string\n+\tmpath       string\n+\trev         string\n+\terr         string\n+\tversion     string\n+\tname        string\n+\tshort       string\n+\ttime        time.Time\n+\tgomod       string\n+\tgomodErr    string\n+\tzip         []string\n+\tzipErr      string\n+\tzipSum      string\n+\tzipFileHash string\n }\n \n var codeRepoTests = []codeRepoTest{\n@@ -82,6 +90,8 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"README.md\",\n \t\t\t\"pkg/p.go\",\n \t\t},\n+\t\tzipSum:      \"h1:zVEjciLdlk/TPWCOyZo7k24T+tOKRQC+u8MKq/xS80I=\",\n+\t\tzipFileHash: \"738a00ddbfe8c329dce6b48e1f23c8e22a92db50f3cfb2653caa0d62676bc09c\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -96,6 +106,8 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"README.md\",\n \t\t\t\"pkg/p.go\",\n \t\t},\n+\t\tzipSum:      \"h1:nOznk2xKsLGkTnXe0q9t1Ewt9jxK+oadtafSUqHM3Ec=\",\n+\t\tzipFileHash: \"bacb08f391e29d2eaaef8281b5c129ee6d890e608ee65877e0003c0181a766c8\",\n \t},\n \t{\n \t\tvcs:  \"git\",\n@@ -116,6 +128,8 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"README.md\",\n \t\t\t\"pkg/p.go\",\n \t\t},\n+\t\tzipSum:      \"h1:e040hOoWGeuJLawDjK9DW6med+cz9FxMFYDMOVG8ctQ=\",\n+\t\tzipFileHash: \"74caab65cfbea427c341fa815f3bb0378681d8f0e3cf62a7f207014263ec7be3\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -140,6 +154,8 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"README.md\",\n \t\t\t\"pkg/p.go\",\n \t\t},\n+\t\tzipSum:      \"h1:e040hOoWGeuJLawDjK9DW6med+cz9FxMFYDMOVG8ctQ=\",\n+\t\tzipFileHash: \"74caab65cfbea427c341fa815f3bb0378681d8f0e3cf62a7f207014263ec7be3\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -201,6 +217,8 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"pkg/p.go\",\n \t\t\t\"LICENSE\",\n \t\t},\n+\t\tzipSum:      \"h1:iMsJ/9uQsk6MnZNnJK311f11QiSlmN92Q2aSjCywuJY=\",\n+\t\tzipFileHash: \"95801bfa69c5197ae809af512946d22f22850068527cd78100ae3f176bc8043b\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -217,16 +235,20 @@ var codeRepoTests = []codeRepoTest{\n \t\t\t\"go.mod\",\n \t\t\t\"pkg/p.go\",\n \t\t},\n+\t\tzipSum:      \"h1:M69k7q+8bQ+QUpHov45Z/NoR8rj3DsQJUnXLWvf01+Q=\",\n+\t\tzipFileHash: \"58af45fb248d320ea471f568e006379e2b8d71d6d1663f9b19b2e00fd9ac9265\",\n \t},\n \t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"github.com/rsc/vgotest1/v2\",\n-\t\trev:     \"v2.0.1\",\n-\t\tversion: \"v2.0.1\",\n-\t\tname:    \"ea65f87c8f52c15ea68f3bdd9925ef17e20d91e9\",\n-\t\tshort:   \"ea65f87c8f52\",\n-\t\ttime:    time.Date(2018, 2, 19, 23, 14, 23, 0, time.UTC),\n-\t\tgomod:   \"module \\\"github.com/rsc/vgotest1/v2\\\" // root go.mod\\n\",\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"github.com/rsc/vgotest1/v2\",\n+\t\trev:         \"v2.0.1\",\n+\t\tversion:     \"v2.0.1\",\n+\t\tname:        \"ea65f87c8f52c15ea68f3bdd9925ef17e20d91e9\",\n+\t\tshort:       \"ea65f87c8f52\",\n+\t\ttime:        time.Date(2018, 2, 19, 23, 14, 23, 0, time.UTC),\n+\t\tgomod:       \"module \\\"github.com/rsc/vgotest1/v2\\\" // root go.mod\\n\",\n+\t\tzipSum:      \"h1:QmgYy/zt+uoWhDpcsgrSVzYFvKtBEjl5zT/FRz9GTzA=\",\n+\t\tzipFileHash: \"1aedf1546d322a0121879ddfd6d0e8bfbd916d2cafbeb538ddb440e04b04b9ef\",\n \t},\n \t{\n \t\tvcs:     \"git\",\n@@ -249,25 +271,29 @@ var codeRepoTests = []codeRepoTest{\n \t\terr:     \"github.com/rsc/vgotest1/go.mod and .../v2/go.mod both have .../v2 module paths at revision v2.0.4\",\n \t},\n \t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"github.com/rsc/vgotest1/v2\",\n-\t\trev:     \"v2.0.5\",\n-\t\tversion: \"v2.0.5\",\n-\t\tname:    \"2f615117ce481c8efef46e0cc0b4b4dccfac8fea\",\n-\t\tshort:   \"2f615117ce48\",\n-\t\ttime:    time.Date(2018, 2, 20, 0, 3, 59, 0, time.UTC),\n-\t\tgomod:   \"module \\\"github.com/rsc/vgotest1/v2\\\" // v2/go.mod\\n\",\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"github.com/rsc/vgotest1/v2\",\n+\t\trev:         \"v2.0.5\",\n+\t\tversion:     \"v2.0.5\",\n+\t\tname:        \"2f615117ce481c8efef46e0cc0b4b4dccfac8fea\",\n+\t\tshort:       \"2f615117ce48\",\n+\t\ttime:        time.Date(2018, 2, 20, 0, 3, 59, 0, time.UTC),\n+\t\tgomod:       \"module \\\"github.com/rsc/vgotest1/v2\\\" // v2/go.mod\\n\",\n+\t\tzipSum:      \"h1:RIEb9q1SUSEQOzMn0zfl/LQxGFWlhWEAdeEguf1MLGU=\",\n+\t\tzipFileHash: \"7d92c2c328c5e9b0694101353705d5843746ec1d93a1e986d0da54c8a14dfe6d\",\n \t},\n \t{\n \t\t// redirect to github\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"rsc.io/quote\",\n-\t\trev:     \"v1.0.0\",\n-\t\tversion: \"v1.0.0\",\n-\t\tname:    \"f488df80bcdbd3e5bafdc24ad7d1e79e83edd7e6\",\n-\t\tshort:   \"f488df80bcdb\",\n-\t\ttime:    time.Date(2018, 2, 14, 0, 45, 20, 0, time.UTC),\n-\t\tgomod:   \"module \\\"rsc.io/quote\\\"\\n\",\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"rsc.io/quote\",\n+\t\trev:         \"v1.0.0\",\n+\t\tversion:     \"v1.0.0\",\n+\t\tname:        \"f488df80bcdbd3e5bafdc24ad7d1e79e83edd7e6\",\n+\t\tshort:       \"f488df80bcdb\",\n+\t\ttime:        time.Date(2018, 2, 14, 0, 45, 20, 0, time.UTC),\n+\t\tgomod:       \"module \\\"rsc.io/quote\\\"\\n\",\n+\t\tzipSum:      \"h1:haUSojyo3j2M9g7CEUFG8Na09dtn7QKxvPGaPVQdGwM=\",\n+\t\tzipFileHash: \"5c08ba2c09a364f93704aaa780e7504346102c6ef4fe1333a11f09904a732078\",\n \t},\n \t{\n \t\t// redirect to static hosting proxy\n@@ -281,30 +307,34 @@ var codeRepoTests = []codeRepoTest{\n \t},\n \t{\n \t\t// redirect to googlesource\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"golang.org/x/text\",\n-\t\trev:     \"4e4a3210bb\",\n-\t\tversion: \"v0.3.1-0.20180208041248-4e4a3210bb54\",\n-\t\tname:    \"4e4a3210bb54bb31f6ab2cdca2edcc0b50c420c1\",\n-\t\tshort:   \"4e4a3210bb54\",\n-\t\ttime:    time.Date(2018, 2, 8, 4, 12, 48, 0, time.UTC),\n-\t},\n-\t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"github.com/pkg/errors\",\n-\t\trev:     \"v0.8.0\",\n-\t\tversion: \"v0.8.0\",\n-\t\tname:    \"645ef00459ed84a119197bfb8d8205042c6df63d\",\n-\t\tshort:   \"645ef00459ed\",\n-\t\ttime:    time.Date(2016, 9, 29, 1, 48, 1, 0, time.UTC),\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"golang.org/x/text\",\n+\t\trev:         \"4e4a3210bb\",\n+\t\tversion:     \"v0.3.1-0.20180208041248-4e4a3210bb54\",\n+\t\tname:        \"4e4a3210bb54bb31f6ab2cdca2edcc0b50c420c1\",\n+\t\tshort:       \"4e4a3210bb54\",\n+\t\ttime:        time.Date(2018, 2, 8, 4, 12, 48, 0, time.UTC),\n+\t\tzipSum:      \"h1:Yxu6pHX9X2RECiuw/Q5/4uvajuaowck8zOFKXgbfNBk=\",\n+\t\tzipFileHash: \"ac2c165a5c10aa5a7545dea60a08e019270b982fa6c8bdcb5943931de64922fe\",\n+\t},\n+\t{\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"github.com/pkg/errors\",\n+\t\trev:         \"v0.8.0\",\n+\t\tversion:     \"v0.8.0\",\n+\t\tname:        \"645ef00459ed84a119197bfb8d8205042c6df63d\",\n+\t\tshort:       \"645ef00459ed\",\n+\t\ttime:        time.Date(2016, 9, 29, 1, 48, 1, 0, time.UTC),\n+\t\tzipSum:      \"h1:WdK/asTD0HN+q6hsWO3/vpuAkAr+tw6aNJNDFFf0+qw=\",\n+\t\tzipFileHash: \"e4fa69ba057356614edbc1da881a7d3ebb688505be49f65965686bcb859e2fae\",\n \t},\n \t{\n \t\t// package in subdirectory - custom domain\n \t\t// In general we can't reject these definitively in Lookup,\n \t\t// but gopkg.in is special.\n \t\tvcs:     \"git\",\n \t\tpath:    \"gopkg.in/yaml.v2/abc\",\n-\t\tlookerr: \"invalid module path \\\"gopkg.in/yaml.v2/abc\\\"\",\n+\t\tlookErr: \"invalid module path \\\"gopkg.in/yaml.v2/abc\\\"\",\n \t},\n \t{\n \t\t// package in subdirectory - github\n@@ -315,54 +345,52 @@ var codeRepoTests = []codeRepoTest{\n \t\terr:  \"missing github.com/rsc/quote/buggy/go.mod at revision c4d4236f9242\",\n \t},\n \t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"gopkg.in/yaml.v2\",\n-\t\trev:     \"d670f940\",\n-\t\tversion: \"v2.0.0\",\n-\t\tname:    \"d670f9405373e636a5a2765eea47fac0c9bc91a4\",\n-\t\tshort:   \"d670f9405373\",\n-\t\ttime:    time.Date(2018, 1, 9, 11, 43, 31, 0, time.UTC),\n-\t\tgomod:   \"module gopkg.in/yaml.v2\\n\",\n-\t},\n-\t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"gopkg.in/check.v1\",\n-\t\trev:     \"20d25e280405\",\n-\t\tversion: \"v1.0.0-20161208181325-20d25e280405\",\n-\t\tname:    \"20d25e2804050c1cd24a7eea1e7a6447dd0e74ec\",\n-\t\tshort:   \"20d25e280405\",\n-\t\ttime:    time.Date(2016, 12, 8, 18, 13, 25, 0, time.UTC),\n-\t\tgomod:   \"module gopkg.in/check.v1\\n\",\n-\t},\n-\t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"gopkg.in/yaml.v2\",\n-\t\trev:     \"v2\",\n-\t\tversion: \"v2.2.3-0.20190319135612-7b8349ac747c\",\n-\t\tname:    \"7b8349ac747c6a24702b762d2c4fd9266cf4f1d6\",\n-\t\tshort:   \"7b8349ac747c\",\n-\t\ttime:    time.Date(2019, 03, 19, 13, 56, 12, 0, time.UTC),\n-\t\tgomod:   \"module \\\"gopkg.in/yaml.v2\\\"\\n\\nrequire (\\n\\t\\\"gopkg.in/check.v1\\\" v0.0.0-20161208181325-20d25e280405\\n)\\n\",\n-\t},\n-\t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"vcs-test.golang.org/go/mod/gitrepo1\",\n-\t\trev:     \"master\",\n-\t\tversion: \"v1.2.4-annotated\",\n-\t\tname:    \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n-\t\tshort:   \"ede458df7cd0\",\n-\t\ttime:    time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n-\t\tgomod:   \"module vcs-test.golang.org/go/mod/gitrepo1\\n\",\n-\t},\n-\t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"gopkg.in/natefinch/lumberjack.v2\",\n-\t\trev:     \"latest\",\n-\t\tversion: \"v2.0.0-20170531160350-a96e63847dc3\",\n-\t\tname:    \"a96e63847dc3c67d17befa69c303767e2f84e54f\",\n-\t\tshort:   \"a96e63847dc3\",\n-\t\ttime:    time.Date(2017, 5, 31, 16, 3, 50, 0, time.UTC),\n-\t\tgomod:   \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"gopkg.in/yaml.v2\",\n+\t\trev:         \"d670f940\",\n+\t\tversion:     \"v2.0.0\",\n+\t\tname:        \"d670f9405373e636a5a2765eea47fac0c9bc91a4\",\n+\t\tshort:       \"d670f9405373\",\n+\t\ttime:        time.Date(2018, 1, 9, 11, 43, 31, 0, time.UTC),\n+\t\tgomod:       \"module gopkg.in/yaml.v2\\n\",\n+\t\tzipSum:      \"h1:uUkhRGrsEyx/laRdeS6YIQKIys8pg+lRSRdVMTYjivs=\",\n+\t\tzipFileHash: \"7b0a141b1b0b49772ab4eecfd11dfd6609a94a5e868cab04a3abb1861ffaa877\",\n+\t},\n+\t{\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"gopkg.in/check.v1\",\n+\t\trev:         \"20d25e280405\",\n+\t\tversion:     \"v1.0.0-20161208181325-20d25e280405\",\n+\t\tname:        \"20d25e2804050c1cd24a7eea1e7a6447dd0e74ec\",\n+\t\tshort:       \"20d25e280405\",\n+\t\ttime:        time.Date(2016, 12, 8, 18, 13, 25, 0, time.UTC),\n+\t\tgomod:       \"module gopkg.in/check.v1\\n\",\n+\t\tzipSum:      \"h1:829vOVxxusYHC+IqBtkX5mbKtsY9fheQiQn0MZRVLfQ=\",\n+\t\tzipFileHash: \"9e7cb3f4f1e66d722306442b0dbe1f6f43d74d1736d54c510537bdfb1d6f432f\",\n+\t},\n+\t{\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"vcs-test.golang.org/go/mod/gitrepo1\",\n+\t\trev:         \"master\",\n+\t\tversion:     \"v1.2.4-annotated\",\n+\t\tname:        \"ede458df7cd0fdca520df19a33158086a8a68e81\",\n+\t\tshort:       \"ede458df7cd0\",\n+\t\ttime:        time.Date(2018, 4, 17, 19, 43, 22, 0, time.UTC),\n+\t\tgomod:       \"module vcs-test.golang.org/go/mod/gitrepo1\\n\",\n+\t\tzipSum:      \"h1:YJYZRsM9BHFTlVr8YADjT0cJH8uFIDtoc5NLiVqZEx8=\",\n+\t\tzipFileHash: \"c15e49d58b7a4c37966cbe5bc01a0330cd5f2927e990e1839bda1d407766d9c5\",\n+\t},\n+\t{\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"gopkg.in/natefinch/lumberjack.v2\",\n+\t\trev:         \"latest\",\n+\t\tversion:     \"v2.0.0-20170531160350-a96e63847dc3\",\n+\t\tname:        \"a96e63847dc3c67d17befa69c303767e2f84e54f\",\n+\t\tshort:       \"a96e63847dc3\",\n+\t\ttime:        time.Date(2017, 5, 31, 16, 3, 50, 0, time.UTC),\n+\t\tgomod:       \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n+\t\tzipSum:      \"h1:AFxeG48hTWHhDTQDk/m2gorfVHUEa9vo3tp3D7TzwjI=\",\n+\t\tzipFileHash: \"b5de0da7bbbec76709eef1ac71b6c9ff423b9fbf3bb97b56743450d4937b06d5\",\n \t},\n \t{\n \t\tvcs:  \"git\",\n@@ -381,14 +409,16 @@ var codeRepoTests = []codeRepoTest{\n \t\tgomod:   \"module gopkg.in/natefinch/lumberjack.v2\\n\",\n \t},\n \t{\n-\t\tvcs:     \"git\",\n-\t\tpath:    \"vcs-test.golang.org/go/v2module/v2\",\n-\t\trev:     \"v2.0.0\",\n-\t\tversion: \"v2.0.0\",\n-\t\tname:    \"203b91c896acd173aa719e4cdcb7d463c4b090fa\",\n-\t\tshort:   \"203b91c896ac\",\n-\t\ttime:    time.Date(2019, 4, 3, 15, 52, 15, 0, time.UTC),\n-\t\tgomod:   \"module vcs-test.golang.org/go/v2module/v2\\n\\ngo 1.12\\n\",\n+\t\tvcs:         \"git\",\n+\t\tpath:        \"vcs-test.golang.org/go/v2module/v2\",\n+\t\trev:         \"v2.0.0\",\n+\t\tversion:     \"v2.0.0\",\n+\t\tname:        \"203b91c896acd173aa719e4cdcb7d463c4b090fa\",\n+\t\tshort:       \"203b91c896ac\",\n+\t\ttime:        time.Date(2019, 4, 3, 15, 52, 15, 0, time.UTC),\n+\t\tgomod:       \"module vcs-test.golang.org/go/v2module/v2\\n\\ngo 1.12\\n\",\n+\t\tzipSum:      \"h1:JItBZ+gwA5WvtZEGEbuDL4lUttGtLrs53lmdurq3bOg=\",\n+\t\tzipFileHash: \"9ea9ae1673cffcc44b7fdd3cc89953d68c102449b46c982dbf085e4f2e394da5\",\n \t},\n }\n \n@@ -411,21 +441,23 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t\t}\n \n \t\t\t\t\trepo, err := Lookup(\"direct\", tt.path)\n-\t\t\t\t\tif tt.lookerr != \"\" {\n-\t\t\t\t\t\tif err != nil && err.Error() == tt.lookerr {\n+\t\t\t\t\tif tt.lookErr != \"\" {\n+\t\t\t\t\t\tif err != nil && err.Error() == tt.lookErr {\n \t\t\t\t\t\t\treturn\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tt.Errorf(\"Lookup(%q): %v, want error %q\", tt.path, err, tt.lookerr)\n+\t\t\t\t\t\tt.Errorf(\"Lookup(%q): %v, want error %q\", tt.path, err, tt.lookErr)\n \t\t\t\t\t}\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tt.Fatalf(\"Lookup(%q): %v\", tt.path, err)\n \t\t\t\t\t}\n+\n \t\t\t\t\tif tt.mpath == \"\" {\n \t\t\t\t\t\ttt.mpath = tt.path\n \t\t\t\t\t}\n \t\t\t\t\tif mpath := repo.ModulePath(); mpath != tt.mpath {\n \t\t\t\t\t\tt.Errorf(\"repo.ModulePath() = %q, want %q\", mpath, tt.mpath)\n \t\t\t\t\t}\n+\n \t\t\t\t\tinfo, err := repo.Stat(tt.rev)\n \t\t\t\t\tif err != nil {\n \t\t\t\t\t\tif tt.err != \"\" {\n@@ -451,83 +483,113 @@ func TestCodeRepo(t *testing.T) {\n \t\t\t\t\tif !info.Time.Equal(tt.time) {\n \t\t\t\t\t\tt.Errorf(\"info.Time = %v, want %v\", info.Time, tt.time)\n \t\t\t\t\t}\n-\t\t\t\t\tif tt.gomod != \"\" || tt.gomoderr != \"\" {\n+\n+\t\t\t\t\tif tt.gomod != \"\" || tt.gomodErr != \"\" {\n \t\t\t\t\t\tdata, err := repo.GoMod(tt.version)\n-\t\t\t\t\t\tif err != nil && tt.gomoderr == \"\" {\n+\t\t\t\t\t\tif err != nil && tt.gomodErr == \"\" {\n \t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v\", tt.version, err)\n-\t\t\t\t\t\t} else if err != nil && tt.gomoderr != \"\" {\n-\t\t\t\t\t\t\tif err.Error() != tt.gomoderr {\n-\t\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomoderr)\n+\t\t\t\t\t\t} else if err != nil && tt.gomodErr != \"\" {\n+\t\t\t\t\t\t\tif err.Error() != tt.gomodErr {\n+\t\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q): %v, want %q\", tt.version, err, tt.gomodErr)\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t} else if tt.gomoderr != \"\" {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomoderr)\n+\t\t\t\t\t\t} else if tt.gomodErr != \"\" {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want error %q\", tt.version, data, tt.gomodErr)\n \t\t\t\t\t\t} else if string(data) != tt.gomod {\n \t\t\t\t\t\t\tt.Errorf(\"repo.GoMod(%q) = %q, want %q\", tt.version, data, tt.gomod)\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n-\t\t\t\t\tif tt.zip != nil || tt.ziperr != \"\" {\n+\n+\t\t\t\t\tneedHash := !testing.Short() && (tt.zipFileHash != \"\" || tt.zipSum != \"\")\n+\t\t\t\t\tif tt.zip != nil || tt.zipErr != \"\" || needHash {\n \t\t\t\t\t\tf, err := ioutil.TempFile(tmpdir, tt.version+\".zip.\")\n \t\t\t\t\t\tif err != nil {\n \t\t\t\t\t\t\tt.Fatalf(\"ioutil.TempFile: %v\", err)\n \t\t\t\t\t\t}\n \t\t\t\t\t\tzipfile := f.Name()\n-\t\t\t\t\t\terr = repo.Zip(f, tt.version)\n+\t\t\t\t\t\tdefer func() {\n+\t\t\t\t\t\t\tf.Close()\n+\t\t\t\t\t\t\tos.Remove(zipfile)\n+\t\t\t\t\t\t}()\n+\n+\t\t\t\t\t\tvar w io.Writer\n+\t\t\t\t\t\tvar h hash.Hash\n+\t\t\t\t\t\tif needHash {\n+\t\t\t\t\t\t\th = sha256.New()\n+\t\t\t\t\t\t\tw = io.MultiWriter(f, h)\n+\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\tw = f\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\terr = repo.Zip(w, tt.version)\n \t\t\t\t\t\tf.Close()\n \t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tif tt.ziperr != \"\" {\n-\t\t\t\t\t\t\t\tif err.Error() == tt.ziperr {\n+\t\t\t\t\t\t\tif tt.zipErr != \"\" {\n+\t\t\t\t\t\t\t\tif err.Error() == tt.zipErr {\n \t\t\t\t\t\t\t\t\treturn\n \t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.ziperr)\n+\t\t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v, want error %q\", tt.version, err, tt.zipErr)\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\tt.Fatalf(\"repo.Zip(%q): %v\", tt.version, err)\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tif tt.ziperr != \"\" {\n-\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.ziperr)\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n-\t\t\t\t\t\tz, err := zip.OpenReader(zipfile)\n-\t\t\t\t\t\tif err != nil {\n-\t\t\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n+\t\t\t\t\t\tif tt.zipErr != \"\" {\n+\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): success, want error %q\", tt.version, tt.zipErr)\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tvar names []string\n-\t\t\t\t\t\tfor _, file := range z.File {\n-\t\t\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n-\t\t\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n-\t\t\t\t\t\t\t\tcontinue\n+\n+\t\t\t\t\t\tif tt.zip != nil {\n+\t\t\t\t\t\t\tprefix := tt.path + \"@\" + tt.version + \"/\"\n+\t\t\t\t\t\t\tz, err := zip.OpenReader(zipfile)\n+\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\tt.Fatalf(\"open zip %s: %v\", zipfile, err)\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tvar names []string\n+\t\t\t\t\t\t\tfor _, file := range z.File {\n+\t\t\t\t\t\t\t\tif !strings.HasPrefix(file.Name, prefix) {\n+\t\t\t\t\t\t\t\t\tt.Errorf(\"zip entry %v does not start with prefix %v\", file.Name, prefix)\n+\t\t\t\t\t\t\t\t\tcontinue\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tz.Close()\n+\t\t\t\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n+\t\t\t\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n \t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tnames = append(names, file.Name[len(prefix):])\n \t\t\t\t\t\t}\n-\t\t\t\t\t\tz.Close()\n-\t\t\t\t\t\tif !reflect.DeepEqual(names, tt.zip) {\n-\t\t\t\t\t\t\tt.Fatalf(\"zip = %v\\nwant %v\\n\", names, tt.zip)\n+\n+\t\t\t\t\t\tif needHash {\n+\t\t\t\t\t\t\tsum, err := dirhash.HashZip(zipfile, dirhash.Hash1)\n+\t\t\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): %v\", tt.version, err)\n+\t\t\t\t\t\t\t} else if sum != tt.zipSum {\n+\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with sum %q, want %q\", tt.version, sum, tt.zipSum)\n+\t\t\t\t\t\t\t} else if zipFileHash := hex.EncodeToString(h.Sum(nil)); zipFileHash != tt.zipFileHash {\n+\t\t\t\t\t\t\t\tt.Errorf(\"repo.Zip(%q): got file with hash %q, want %q (but content has correct sum)\", tt.version, zipFileHash, tt.zipFileHash)\n+\t\t\t\t\t\t\t}\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n \t\t\t}\n \t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n \t\t\tif strings.HasPrefix(tt.path, vgotest1git) {\n \t\t\t\tfor vcs, alt := range altVgotests {\n-\t\t\t\t\t// Note: Communicating with f through tt; should be cleaned up.\n-\t\t\t\t\told := tt\n-\t\t\t\t\ttt.vcs = vcs\n-\t\t\t\t\ttt.path = alt + strings.TrimPrefix(tt.path, vgotest1git)\n-\t\t\t\t\tif strings.HasPrefix(tt.mpath, vgotest1git) {\n-\t\t\t\t\t\ttt.mpath = alt + strings.TrimPrefix(tt.mpath, vgotest1git)\n+\t\t\t\t\taltTest := tt\n+\t\t\t\t\taltTest.vcs = vcs\n+\t\t\t\t\taltTest.path = alt + strings.TrimPrefix(altTest.path, vgotest1git)\n+\t\t\t\t\tif strings.HasPrefix(altTest.mpath, vgotest1git) {\n+\t\t\t\t\t\taltTest.mpath = alt + strings.TrimPrefix(altTest.mpath, vgotest1git)\n \t\t\t\t\t}\n \t\t\t\t\tvar m map[string]string\n \t\t\t\t\tif alt == vgotest1hg {\n \t\t\t\t\t\tm = hgmap\n \t\t\t\t\t}\n-\t\t\t\t\ttt.version = remap(tt.version, m)\n-\t\t\t\t\ttt.name = remap(tt.name, m)\n-\t\t\t\t\ttt.short = remap(tt.short, m)\n-\t\t\t\t\ttt.rev = remap(tt.rev, m)\n-\t\t\t\t\ttt.err = remap(tt.err, m)\n-\t\t\t\t\ttt.gomoderr = remap(tt.gomoderr, m)\n-\t\t\t\t\ttt.ziperr = remap(tt.ziperr, m)\n-\t\t\t\t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\")+\"/\"+tt.rev, f(tt))\n-\t\t\t\t\ttt = old\n+\t\t\t\t\taltTest.version = remap(altTest.version, m)\n+\t\t\t\t\taltTest.name = remap(altTest.name, m)\n+\t\t\t\t\taltTest.short = remap(altTest.short, m)\n+\t\t\t\t\taltTest.rev = remap(altTest.rev, m)\n+\t\t\t\t\taltTest.err = remap(altTest.err, m)\n+\t\t\t\t\taltTest.gomodErr = remap(altTest.gomodErr, m)\n+\t\t\t\t\taltTest.zipErr = remap(altTest.zipErr, m)\n+\t\t\t\t\taltTest.zipSum = \"\"\n+\t\t\t\t\taltTest.zipFileHash = \"\"\n+\t\t\t\t\tt.Run(strings.ReplaceAll(altTest.path, \"/\", \"_\")+\"/\"+altTest.rev, f(altTest))\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -575,7 +637,7 @@ var codeRepoVersionsTests = []struct {\n \t{\n \t\tvcs:      \"git\",\n \t\tpath:     \"github.com/rsc/vgotest1\",\n-\t\tversions: []string{\"v0.0.0\", \"v0.0.1\", \"v1.0.0\", \"v1.0.1\", \"v1.0.2\", \"v1.0.3\", \"v1.1.0\", \"v2.0.0+incompatible\"},\n+\t\tversions: []string{\"v0.0.0\", \"v0.0.1\", \"v1.0.0\", \"v1.0.1\", \"v1.0.2\", \"v1.0.3\", \"v1.1.0\"},\n \t},\n \t{\n \t\tvcs:      \"git\","}, {"sha": "54fbd92b43ec146987910e51ae5db66672abc508", "filename": "libgo/go/cmd/go/internal/modfetch/fetch.go", "status": "modified", "additions": 129, "deletions": 87, "changes": 216, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Ffetch.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,6 +7,7 @@ package modfetch\n import (\n \t\"archive/zip\"\n \t\"bytes\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n@@ -18,10 +19,13 @@ import (\n \n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/dirhash\"\n-\t\"cmd/go/internal/module\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/renameio\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/sumdb/dirhash\"\n+\tmodzip \"golang.org/x/mod/zip\"\n )\n \n var downloadCache par.Cache\n@@ -69,10 +73,6 @@ func download(mod module.Version, dir string) (err error) {\n \t\treturn err\n \t}\n \n-\tif cfg.CmdName != \"mod download\" {\n-\t\tfmt.Fprintf(os.Stderr, \"go: extracting %s %s\\n\", mod.Path, mod.Version)\n-\t}\n-\n \tunlock, err := lockVersion(mod)\n \tif err != nil {\n \t\treturn err\n@@ -114,8 +114,7 @@ func download(mod module.Version, dir string) (err error) {\n \t\t}\n \t}()\n \n-\tmodpath := mod.Path + \"@\" + mod.Version\n-\tif err := Unzip(tmpDir, zipfile, modpath, 0); err != nil {\n+\tif err := modzip.Unzip(tmpDir, mod, zipfile); err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"-> %s\\n\", err)\n \t\treturn err\n \t}\n@@ -124,9 +123,11 @@ func download(mod module.Version, dir string) (err error) {\n \t\treturn err\n \t}\n \n-\t// Make dir read-only only *after* renaming it.\n-\t// os.Rename was observed to fail for read-only directories on macOS.\n-\tmakeDirsReadOnly(dir)\n+\tif !cfg.ModCacheRW {\n+\t\t// Make dir read-only only *after* renaming it.\n+\t\t// os.Rename was observed to fail for read-only directories on macOS.\n+\t\tmakeDirsReadOnly(dir)\n+\t}\n \treturn nil\n }\n \n@@ -249,7 +250,9 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \tif err != nil {\n \t\treturn err\n \t}\n-\tcheckModSum(mod, hash)\n+\tif err := checkModSum(mod, hash); err != nil {\n+\t\treturn err\n+\t}\n \n \tif err := renameio.WriteFile(zipfile+\"hash\", []byte(hash), 0666); err != nil {\n \t\treturn err\n@@ -263,6 +266,45 @@ func downloadZip(mod module.Version, zipfile string) (err error) {\n \treturn nil\n }\n \n+// makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir\n+// and its transitive contents.\n+func makeDirsReadOnly(dir string) {\n+\ttype pathMode struct {\n+\t\tpath string\n+\t\tmode os.FileMode\n+\t}\n+\tvar dirs []pathMode // in lexical order\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err == nil && info.Mode()&0222 != 0 {\n+\t\t\tif info.IsDir() {\n+\t\t\t\tdirs = append(dirs, pathMode{path, info.Mode()})\n+\t\t\t}\n+\t\t}\n+\t\treturn nil\n+\t})\n+\n+\t// Run over list backward to chmod children before parents.\n+\tfor i := len(dirs) - 1; i >= 0; i-- {\n+\t\tos.Chmod(dirs[i].path, dirs[i].mode&^0222)\n+\t}\n+}\n+\n+// RemoveAll removes a directory written by Download or Unzip, first applying\n+// any permission changes needed to do so.\n+func RemoveAll(dir string) error {\n+\t// Module cache has 0555 directories; make them writable in order to remove content.\n+\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n+\t\tif err != nil {\n+\t\t\treturn nil // ignore errors walking in file system\n+\t\t}\n+\t\tif info.IsDir() {\n+\t\t\tos.Chmod(path, 0777)\n+\t\t}\n+\t\treturn nil\n+\t})\n+\treturn os.RemoveAll(dir)\n+}\n+\n var GoSumFile string // path to go.sum; set by package modload\n \n type modSum struct {\n@@ -281,21 +323,22 @@ var goSum struct {\n }\n \n // initGoSum initializes the go.sum data.\n-// It reports whether use of go.sum is now enabled.\n+// The boolean it returns reports whether the\n+// use of go.sum is now enabled.\n // The goSum lock must be held.\n-func initGoSum() bool {\n+func initGoSum() (bool, error) {\n \tif GoSumFile == \"\" {\n-\t\treturn false\n+\t\treturn false, nil\n \t}\n \tif goSum.m != nil {\n-\t\treturn true\n+\t\treturn true, nil\n \t}\n \n \tgoSum.m = make(map[module.Version][]string)\n \tgoSum.checked = make(map[modSum]bool)\n-\tdata, err := renameio.ReadFile(GoSumFile)\n+\tdata, err := lockedfile.Read(GoSumFile)\n \tif err != nil && !os.IsNotExist(err) {\n-\t\tbase.Fatalf(\"go: %v\", err)\n+\t\treturn false, err\n \t}\n \tgoSum.enabled = true\n \treadGoSum(goSum.m, GoSumFile, data)\n@@ -313,7 +356,7 @@ func initGoSum() bool {\n \t\t}\n \t\tgoSum.modverify = alt\n \t}\n-\treturn true\n+\treturn true, nil\n }\n \n // emptyGoModHash is the hash of a 1-file tree containing a 0-length go.mod.\n@@ -323,7 +366,7 @@ const emptyGoModHash = \"h1:G7mAYYxgmS0lVkHyy2hEOLQCFB0DlQFTMLWggykrydY=\"\n \n // readGoSum parses data, which is the content of file,\n // and adds it to goSum.m. The goSum lock must be held.\n-func readGoSum(dst map[module.Version][]string, file string, data []byte) {\n+func readGoSum(dst map[module.Version][]string, file string, data []byte) error {\n \tlineno := 0\n \tfor len(data) > 0 {\n \t\tvar line []byte\n@@ -340,7 +383,7 @@ func readGoSum(dst map[module.Version][]string, file string, data []byte) {\n \t\t\tcontinue\n \t\t}\n \t\tif len(f) != 3 {\n-\t\t\tbase.Fatalf(\"go: malformed go.sum:\\n%s:%d: wrong number of fields %v\", file, lineno, len(f))\n+\t\t\treturn fmt.Errorf(\"malformed go.sum:\\n%s:%d: wrong number of fields %v\", file, lineno, len(f))\n \t\t}\n \t\tif f[2] == emptyGoModHash {\n \t\t\t// Old bug; drop it.\n@@ -349,6 +392,7 @@ func readGoSum(dst map[module.Version][]string, file string, data []byte) {\n \t\tmod := module.Version{Path: f[0], Version: f[1]}\n \t\tdst[mod] = append(dst[mod], f[2])\n \t}\n+\treturn nil\n }\n \n // checkMod checks the given module's checksum.\n@@ -361,22 +405,24 @@ func checkMod(mod module.Version) {\n \t// Do the file I/O before acquiring the go.sum lock.\n \tziphash, err := CachePath(mod, \"ziphash\")\n \tif err != nil {\n-\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n \tdata, err := renameio.ReadFile(ziphash)\n \tif err != nil {\n-\t\tif os.IsNotExist(err) {\n+\t\tif errors.Is(err, os.ErrNotExist) {\n \t\t\t// This can happen if someone does rm -rf GOPATH/src/cache/download. So it goes.\n \t\t\treturn\n \t\t}\n-\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, err))\n \t}\n \th := strings.TrimSpace(string(data))\n \tif !strings.HasPrefix(h, \"h1:\") {\n-\t\tbase.Fatalf(\"verifying %s@%s: unexpected ziphash: %q\", mod.Path, mod.Version, h)\n+\t\tbase.Fatalf(\"verifying %v\", module.VersionError(mod, fmt.Errorf(\"unexpected ziphash: %q\", h)))\n \t}\n \n-\tcheckModSum(mod, h)\n+\tif err := checkModSum(mod, h); err != nil {\n+\t\tbase.Fatalf(\"%s\", err)\n+\t}\n }\n \n // goModSum returns the checksum for the go.mod contents.\n@@ -388,37 +434,42 @@ func goModSum(data []byte) (string, error) {\n \n // checkGoMod checks the given module's go.mod checksum;\n // data is the go.mod content.\n-func checkGoMod(path, version string, data []byte) {\n+func checkGoMod(path, version string, data []byte) error {\n \th, err := goModSum(data)\n \tif err != nil {\n-\t\tbase.Fatalf(\"verifying %s %s go.mod: %v\", path, version, err)\n+\t\treturn &module.ModuleError{Path: path, Version: version, Err: fmt.Errorf(\"verifying go.mod: %v\", err)}\n \t}\n \n-\tcheckModSum(module.Version{Path: path, Version: version + \"/go.mod\"}, h)\n+\treturn checkModSum(module.Version{Path: path, Version: version + \"/go.mod\"}, h)\n }\n \n // checkModSum checks that the recorded checksum for mod is h.\n-func checkModSum(mod module.Version, h string) {\n+func checkModSum(mod module.Version, h string) error {\n \t// We lock goSum when manipulating it,\n \t// but we arrange to release the lock when calling checkSumDB,\n \t// so that parallel calls to checkModHash can execute parallel calls\n \t// to checkSumDB.\n \n \t// Check whether mod+h is listed in go.sum already. If so, we're done.\n \tgoSum.mu.Lock()\n-\tinited := initGoSum()\n+\tinited, err := initGoSum()\n+\tif err != nil {\n+\t\treturn err\n+\t}\n \tdone := inited && haveModSumLocked(mod, h)\n \tgoSum.mu.Unlock()\n \n \tif done {\n-\t\treturn\n+\t\treturn nil\n \t}\n \n \t// Not listed, so we want to add them.\n \t// Consult checksum database if appropriate.\n \tif useSumDB(mod) {\n \t\t// Calls base.Fatalf if mismatch detected.\n-\t\tcheckSumDB(mod, h)\n+\t\tif err := checkSumDB(mod, h); err != nil {\n+\t\t\treturn err\n+\t\t}\n \t}\n \n \t// Add mod+h to go.sum, if it hasn't appeared already.\n@@ -427,6 +478,7 @@ func checkModSum(mod module.Version, h string) {\n \t\taddModSumLocked(mod, h)\n \t\tgoSum.mu.Unlock()\n \t}\n+\treturn nil\n }\n \n // haveModSumLocked reports whether the pair mod,h is already listed in go.sum.\n@@ -460,22 +512,23 @@ func addModSumLocked(mod module.Version, h string) {\n \n // checkSumDB checks the mod, h pair against the Go checksum database.\n // It calls base.Fatalf if the hash is to be rejected.\n-func checkSumDB(mod module.Version, h string) {\n+func checkSumDB(mod module.Version, h string) error {\n \tdb, lines, err := lookupSumDB(mod)\n \tif err != nil {\n-\t\tbase.Fatalf(\"verifying %s@%s: %v\", mod.Path, mod.Version, err)\n+\t\treturn module.VersionError(mod, fmt.Errorf(\"verifying module: %v\", err))\n \t}\n \n \thave := mod.Path + \" \" + mod.Version + \" \" + h\n \tprefix := mod.Path + \" \" + mod.Version + \" h1:\"\n \tfor _, line := range lines {\n \t\tif line == have {\n-\t\t\treturn\n+\t\t\treturn nil\n \t\t}\n \t\tif strings.HasPrefix(line, prefix) {\n-\t\t\tbase.Fatalf(\"verifying %s@%s: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s: %v\"+sumdbMismatch, mod.Path, mod.Version, h, db, line[len(prefix)-len(\"h1:\"):])\n+\t\t\treturn module.VersionError(mod, fmt.Errorf(\"verifying module: checksum mismatch\\n\\tdownloaded: %v\\n\\t%s: %v\"+sumdbMismatch, h, db, line[len(prefix)-len(\"h1:\"):]))\n \t\t}\n \t}\n+\treturn nil\n }\n \n // Sum returns the checksum for the downloaded copy of the given module,\n@@ -516,60 +569,45 @@ func WriteGoSum() {\n \t\tbase.Fatalf(\"go: updates to go.sum needed, disabled by -mod=readonly\")\n \t}\n \n-\t// We want to avoid races between creating the lockfile and deleting it, but\n-\t// we also don't want to leave a permanent lockfile in the user's repository.\n-\t//\n-\t// On top of that, if we crash while writing go.sum, we don't want to lose the\n-\t// sums that were already present in the file, so it's important that we write\n-\t// the file by renaming rather than truncating \u2014 which means that we can't\n-\t// lock the go.sum file itself.\n-\t//\n-\t// Instead, we'll lock a distinguished file in the cache directory: that will\n-\t// only race if the user runs `go clean -modcache` concurrently with a command\n-\t// that updates go.sum, and that's already racy to begin with.\n-\t//\n-\t// We'll end up slightly over-synchronizing go.sum writes if the user runs a\n-\t// bunch of go commands that update sums in separate modules simultaneously,\n-\t// but that's unlikely to matter in practice.\n-\n-\tunlock := SideLock()\n-\tdefer unlock()\n+\t// Make a best-effort attempt to acquire the side lock, only to exclude\n+\t// previous versions of the 'go' command from making simultaneous edits.\n+\tif unlock, err := SideLock(); err == nil {\n+\t\tdefer unlock()\n+\t}\n \n-\tif !goSum.overwrite {\n-\t\t// Re-read the go.sum file to incorporate any sums added by other processes\n-\t\t// in the meantime.\n-\t\tdata, err := renameio.ReadFile(GoSumFile)\n-\t\tif err != nil && !os.IsNotExist(err) {\n-\t\t\tbase.Fatalf(\"go: re-reading go.sum: %v\", err)\n-\t\t}\n-\n-\t\t// Add only the sums that we actually checked: the user may have edited or\n-\t\t// truncated the file to remove erroneous hashes, and we shouldn't restore\n-\t\t// them without good reason.\n-\t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n-\t\treadGoSum(goSum.m, GoSumFile, data)\n-\t\tfor ms := range goSum.checked {\n-\t\t\taddModSumLocked(ms.mod, ms.sum)\n-\t\t\tgoSum.dirty = true\n+\terr := lockedfile.Transform(GoSumFile, func(data []byte) ([]byte, error) {\n+\t\tif !goSum.overwrite {\n+\t\t\t// Incorporate any sums added by other processes in the meantime.\n+\t\t\t// Add only the sums that we actually checked: the user may have edited or\n+\t\t\t// truncated the file to remove erroneous hashes, and we shouldn't restore\n+\t\t\t// them without good reason.\n+\t\t\tgoSum.m = make(map[module.Version][]string, len(goSum.m))\n+\t\t\treadGoSum(goSum.m, GoSumFile, data)\n+\t\t\tfor ms := range goSum.checked {\n+\t\t\t\taddModSumLocked(ms.mod, ms.sum)\n+\t\t\t\tgoSum.dirty = true\n+\t\t\t}\n \t\t}\n-\t}\n \n-\tvar mods []module.Version\n-\tfor m := range goSum.m {\n-\t\tmods = append(mods, m)\n-\t}\n-\tmodule.Sort(mods)\n-\tvar buf bytes.Buffer\n-\tfor _, m := range mods {\n-\t\tlist := goSum.m[m]\n-\t\tsort.Strings(list)\n-\t\tfor _, h := range list {\n-\t\t\tfmt.Fprintf(&buf, \"%s %s %s\\n\", m.Path, m.Version, h)\n+\t\tvar mods []module.Version\n+\t\tfor m := range goSum.m {\n+\t\t\tmods = append(mods, m)\n \t\t}\n-\t}\n+\t\tmodule.Sort(mods)\n+\n+\t\tvar buf bytes.Buffer\n+\t\tfor _, m := range mods {\n+\t\t\tlist := goSum.m[m]\n+\t\t\tsort.Strings(list)\n+\t\t\tfor _, h := range list {\n+\t\t\t\tfmt.Fprintf(&buf, \"%s %s %s\\n\", m.Path, m.Version, h)\n+\t\t\t}\n+\t\t}\n+\t\treturn buf.Bytes(), nil\n+\t})\n \n-\tif err := renameio.WriteFile(GoSumFile, buf.Bytes(), 0666); err != nil {\n-\t\tbase.Fatalf(\"go: writing go.sum: %v\", err)\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: updating go.sum: %v\", err)\n \t}\n \n \tgoSum.checked = make(map[modSum]bool)\n@@ -585,7 +623,11 @@ func WriteGoSum() {\n func TrimGoSum(keep map[module.Version]bool) {\n \tgoSum.mu.Lock()\n \tdefer goSum.mu.Unlock()\n-\tif !initGoSum() {\n+\tinited, err := initGoSum()\n+\tif err != nil {\n+\t\tbase.Fatalf(\"%s\", err)\n+\t}\n+\tif !inited {\n \t\treturn\n \t}\n "}, {"sha": "8420432d6cdf8db4c68aff4c07c4f545ccb555f1", "filename": "libgo/go/cmd/go/internal/modfetch/insecure.go", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Finsecure.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,16 @@\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package modfetch\n+\n+import (\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/get\"\n+\t\"cmd/go/internal/str\"\n+)\n+\n+// allowInsecure reports whether we are allowed to fetch this path in an insecure manner.\n+func allowInsecure(path string) bool {\n+\treturn get.Insecure || str.GlobsMatchPath(cfg.GOINSECURE, path)\n+}"}, {"sha": "dcea71adb3af7dcbe85a46ec8ebdafa096b189d8", "filename": "libgo/go/cmd/go/internal/modfetch/proxy.go", "status": "modified", "additions": 40, "deletions": 9, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fproxy.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -22,9 +22,10 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n \t\"cmd/go/internal/web\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var HelpGoproxy = &base.Command{\n@@ -38,8 +39,8 @@ can be a module proxy.\n \n The GET requests sent to a Go module proxy are:\n \n-GET $GOPROXY/<module>/@v/list returns a list of all known versions of the\n-given module, one per line.\n+GET $GOPROXY/<module>/@v/list returns a list of known versions of the given\n+module, one per line.\n \n GET $GOPROXY/<module>/@v/<version>.info returns JSON-formatted metadata\n about that version of the given module.\n@@ -50,6 +51,21 @@ for that version of the given module.\n GET $GOPROXY/<module>/@v/<version>.zip returns the zip archive\n for that version of the given module.\n \n+GET $GOPROXY/<module>/@latest returns JSON-formatted metadata about the\n+latest known version of the given module in the same format as\n+<module>/@v/<version>.info. The latest version should be the version of\n+the module the go command may use if <module>/@v/list is empty or no\n+listed version is suitable. <module>/@latest is optional and may not\n+be implemented by a module proxy.\n+\n+When resolving the latest version of a module, the go command will request\n+<module>/@v/list, then, if no suitable versions are found, <module>/@latest.\n+The go command prefers, in order: the semantically highest release version,\n+the semantically highest pre-release version, and the chronologically\n+most recent pseudo-version. In Go 1.12 and earlier, the go command considered\n+pseudo-versions in <module>/@v/list to be pre-release versions, but this is\n+no longer true since Go 1.13.\n+\n To avoid problems when serving from case-sensitive file systems,\n the <module> and <version> elements are case-encoded, replacing every\n uppercase letter with an exclamation mark followed by the corresponding\n@@ -150,13 +166,28 @@ func TryProxies(f func(proxy string) error) error {\n \t\treturn f(\"off\")\n \t}\n \n+\tvar lastAttemptErr error\n \tfor _, proxy := range proxies {\n \t\terr = f(proxy)\n \t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\tlastAttemptErr = err\n \t\t\tbreak\n \t\t}\n+\n+\t\t// The error indicates that the module does not exist.\n+\t\t// In general we prefer to report the last such error,\n+\t\t// because it indicates the error that occurs after all other\n+\t\t// options have been exhausted.\n+\t\t//\n+\t\t// However, for modules in the NOPROXY list, the most useful error occurs\n+\t\t// first (with proxy set to \"noproxy\"), and the subsequent errors are all\n+\t\t// errNoProxy (which is not particularly helpful). Do not overwrite a more\n+\t\t// useful error with errNoproxy.\n+\t\tif lastAttemptErr == nil || !errors.Is(err, errNoproxy) {\n+\t\t\tlastAttemptErr = err\n+\t\t}\n \t}\n-\treturn err\n+\treturn lastAttemptErr\n }\n \n type proxyRepo struct {\n@@ -182,7 +213,7 @@ func newProxyRepo(baseURL, path string) (Repo, error) {\n \t\treturn nil, fmt.Errorf(\"invalid proxy URL scheme (must be https, http, file): %s\", web.Redacted(base))\n \t}\n \n-\tenc, err := module.EncodePath(path)\n+\tenc, err := module.EscapePath(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n@@ -321,7 +352,7 @@ func (p *proxyRepo) latest() (*RevInfo, error) {\n }\n \n func (p *proxyRepo) Stat(rev string) (*RevInfo, error) {\n-\tencRev, err := module.EncodeVersion(rev)\n+\tencRev, err := module.EscapeVersion(rev)\n \tif err != nil {\n \t\treturn nil, p.versionError(rev, err)\n \t}\n@@ -362,7 +393,7 @@ func (p *proxyRepo) GoMod(version string) ([]byte, error) {\n \t\treturn nil, p.versionError(version, fmt.Errorf(\"internal error: version passed to GoMod is not canonical\"))\n \t}\n \n-\tencVer, err := module.EncodeVersion(version)\n+\tencVer, err := module.EscapeVersion(version)\n \tif err != nil {\n \t\treturn nil, p.versionError(version, err)\n \t}\n@@ -378,7 +409,7 @@ func (p *proxyRepo) Zip(dst io.Writer, version string) error {\n \t\treturn p.versionError(version, fmt.Errorf(\"internal error: version passed to Zip is not canonical\"))\n \t}\n \n-\tencVer, err := module.EncodeVersion(version)\n+\tencVer, err := module.EscapeVersion(version)\n \tif err != nil {\n \t\treturn p.versionError(version, err)\n \t}"}, {"sha": "57dee11d0710ded8e4fef5ce7d31484dc8a39de0", "filename": "libgo/go/cmd/go/internal/modfetch/pseudo.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fpseudo.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -40,9 +40,10 @@ import (\n \t\"strings\"\n \t\"time\"\n \n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/semver\"\n \t\"internal/lazyregexp\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var pseudoVersionRE = lazyregexp.New(`^v[0-9]+\\.(0\\.0-|\\d+\\.\\d+-([^+]*\\.)?0\\.)\\d{14}-[A-Za-z0-9]+(\\+[0-9A-Za-z-]+(\\.[0-9A-Za-z-]+)*)?$`)"}, {"sha": "f03bdd8d038a436f6eee89e9acfbaa5aa6a604f7", "filename": "libgo/go/cmd/go/internal/modfetch/repo.go", "status": "modified", "additions": 36, "deletions": 14, "changes": 50, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Frepo.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,6 @@\n package modfetch\n \n import (\n-\t\"errors\"\n \t\"fmt\"\n \t\"io\"\n \t\"os\"\n@@ -17,9 +16,10 @@ import (\n \t\"cmd/go/internal/get\"\n \t\"cmd/go/internal/modfetch/codehost\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/semver\"\n \t\"cmd/go/internal/str\"\n \tweb \"cmd/go/internal/web\"\n+\n+\t\"golang.org/x/mod/semver\"\n )\n \n const traceRepo = false // trace all repo actions, for debugging\n@@ -34,7 +34,7 @@ type Repo interface {\n \t// Pseudo-versions are not included.\n \t// Versions should be returned sorted in semver order\n \t// (implementations can use SortVersions).\n-\tVersions(prefix string) (tags []string, err error)\n+\tVersions(prefix string) ([]string, error)\n \n \t// Stat returns information about the revision rev.\n \t// A revision can be any identifier known to the underlying service:\n@@ -55,7 +55,7 @@ type Repo interface {\n \n // A Rev describes a single revision in a module repository.\n type RevInfo struct {\n-\tVersion string    // version string\n+\tVersion string    // suggested version string for this revision\n \tTime    time.Time // commit time\n \n \t// These fields are used for Stat of arbitrary rev,\n@@ -214,7 +214,7 @@ func Lookup(proxy, path string) (Repo, error) {\n // lookup returns the module with the given module path.\n func lookup(proxy, path string) (r Repo, err error) {\n \tif cfg.BuildMod == \"vendor\" {\n-\t\treturn nil, errModVendor\n+\t\treturn nil, errLookupDisabled\n \t}\n \n \tif str.GlobsMatchPath(cfg.GONOPROXY, path) {\n@@ -238,22 +238,33 @@ func lookup(proxy, path string) (r Repo, err error) {\n \t}\n }\n \n+type lookupDisabledError struct{}\n+\n+func (lookupDisabledError) Error() string {\n+\tif cfg.BuildModReason == \"\" {\n+\t\treturn fmt.Sprintf(\"module lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t}\n+\treturn fmt.Sprintf(\"module lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n+}\n+\n+var errLookupDisabled error = lookupDisabledError{}\n+\n var (\n-\terrModVendor       = errors.New(\"module lookup disabled by -mod=vendor\")\n-\terrProxyOff        = notExistError(\"module lookup disabled by GOPROXY=off\")\n-\terrNoproxy   error = notExistError(\"disabled by GOPRIVATE/GONOPROXY\")\n-\terrUseProxy  error = notExistError(\"path does not match GOPRIVATE/GONOPROXY\")\n+\terrProxyOff       = notExistErrorf(\"module lookup disabled by GOPROXY=off\")\n+\terrNoproxy  error = notExistErrorf(\"disabled by GOPRIVATE/GONOPROXY\")\n+\terrUseProxy error = notExistErrorf(\"path does not match GOPRIVATE/GONOPROXY\")\n )\n \n func lookupDirect(path string) (Repo, error) {\n \tsecurity := web.SecureOnly\n-\tif get.Insecure {\n+\n+\tif allowInsecure(path) {\n \t\tsecurity = web.Insecure\n \t}\n \trr, err := get.RepoRootForImportPath(path, get.PreferMod, security)\n \tif err != nil {\n \t\t// We don't know where to find code for a module with this path.\n-\t\treturn nil, notExistError(err.Error())\n+\t\treturn nil, notExistError{err: err}\n \t}\n \n \tif rr.VCS == \"mod\" {\n@@ -292,7 +303,7 @@ func ImportRepoRev(path, rev string) (Repo, *RevInfo, error) {\n \t// version control system, we ignore meta tags about modules\n \t// and use only direct source control entries (get.IgnoreMod).\n \tsecurity := web.SecureOnly\n-\tif get.Insecure {\n+\tif allowInsecure(path) {\n \t\tsecurity = web.Insecure\n \t}\n \trr, err := get.RepoRootForImportPath(path, get.IgnoreMod, security)\n@@ -397,11 +408,22 @@ func (l *loggingRepo) Zip(dst io.Writer, version string) error {\n }\n \n // A notExistError is like os.ErrNotExist, but with a custom message\n-type notExistError string\n+type notExistError struct {\n+\terr error\n+}\n+\n+func notExistErrorf(format string, args ...interface{}) error {\n+\treturn notExistError{fmt.Errorf(format, args...)}\n+}\n \n func (e notExistError) Error() string {\n-\treturn string(e)\n+\treturn e.err.Error()\n }\n+\n func (notExistError) Is(target error) bool {\n \treturn target == os.ErrNotExist\n }\n+\n+func (e notExistError) Unwrap() error {\n+\treturn e.err\n+}"}, {"sha": "1ed71dfb85c763017cdba7fd841f2e88d6ab7cf9", "filename": "libgo/go/cmd/go/internal/modfetch/sumdb.go", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fsumdb.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -24,11 +24,11 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/get\"\n \t\"cmd/go/internal/lockedfile\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/note\"\n \t\"cmd/go/internal/str\"\n-\t\"cmd/go/internal/sumweb\"\n \t\"cmd/go/internal/web\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/sumdb\"\n+\t\"golang.org/x/mod/sumdb/note\"\n )\n \n // useSumDB reports whether to use the Go checksum database for the given module.\n@@ -52,11 +52,11 @@ func lookupSumDB(mod module.Version) (dbname string, lines []string, err error)\n var (\n \tdbOnce sync.Once\n \tdbName string\n-\tdb     *sumweb.Conn\n+\tdb     *sumdb.Client\n \tdbErr  error\n )\n \n-func dbDial() (dbName string, db *sumweb.Conn, err error) {\n+func dbDial() (dbName string, db *sumdb.Client, err error) {\n \t// $GOSUMDB can be \"key\" or \"key url\",\n \t// and the key can be a full verifier key\n \t// or a host on our list of known keys.\n@@ -106,7 +106,7 @@ func dbDial() (dbName string, db *sumweb.Conn, err error) {\n \t\tbase = u\n \t}\n \n-\treturn name, sumweb.NewConn(&dbClient{key: key[0], name: name, direct: direct, base: base}), nil\n+\treturn name, sumdb.NewClient(&dbClient{key: key[0], name: name, direct: direct, base: base}), nil\n }\n \n type dbClient struct {\n@@ -227,7 +227,7 @@ func (*dbClient) WriteConfig(file string, old, new []byte) error {\n \t\treturn err\n \t}\n \tif len(data) > 0 && !bytes.Equal(data, old) {\n-\t\treturn sumweb.ErrWriteConflict\n+\t\treturn sumdb.ErrWriteConflict\n \t}\n \tif _, err := f.Seek(0, 0); err != nil {\n \t\treturn err"}, {"sha": "ac13ede257b61dde833b4e636355978031af1089", "filename": "libgo/go/cmd/go/internal/modfetch/unzip.go", "status": "removed", "additions": 0, "deletions": 173, "changes": 173, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Funzip.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,173 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modfetch\n-\n-import (\n-\t\"archive/zip\"\n-\t\"fmt\"\n-\t\"io\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"path\"\n-\t\"path/filepath\"\n-\t\"strings\"\n-\n-\t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/str\"\n-)\n-\n-func Unzip(dir, zipfile, prefix string, maxSize int64) error {\n-\t// TODO(bcmills): The maxSize parameter is invariantly 0. Remove it.\n-\tif maxSize == 0 {\n-\t\tmaxSize = codehost.MaxZipFile\n-\t}\n-\n-\t// Directory can exist, but must be empty.\n-\tfiles, _ := ioutil.ReadDir(dir)\n-\tif len(files) > 0 {\n-\t\treturn fmt.Errorf(\"target directory %v exists and is not empty\", dir)\n-\t}\n-\tif err := os.MkdirAll(dir, 0777); err != nil {\n-\t\treturn err\n-\t}\n-\n-\tf, err := os.Open(zipfile)\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\tdefer f.Close()\n-\tinfo, err := f.Stat()\n-\tif err != nil {\n-\t\treturn err\n-\t}\n-\n-\tz, err := zip.NewReader(f, info.Size())\n-\tif err != nil {\n-\t\treturn fmt.Errorf(\"unzip %v: %s\", zipfile, err)\n-\t}\n-\n-\tfoldPath := make(map[string]string)\n-\tvar checkFold func(string) error\n-\tcheckFold = func(name string) error {\n-\t\tfold := str.ToFold(name)\n-\t\tif foldPath[fold] == name {\n-\t\t\treturn nil\n-\t\t}\n-\t\tdir := path.Dir(name)\n-\t\tif dir != \".\" {\n-\t\t\tif err := checkFold(dir); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\t\tif foldPath[fold] == \"\" {\n-\t\t\tfoldPath[fold] = name\n-\t\t\treturn nil\n-\t\t}\n-\t\tother := foldPath[fold]\n-\t\treturn fmt.Errorf(\"unzip %v: case-insensitive file name collision: %q and %q\", zipfile, other, name)\n-\t}\n-\n-\t// Check total size, valid file names.\n-\tvar size int64\n-\tfor _, zf := range z.File {\n-\t\tif !str.HasPathPrefix(zf.Name, prefix) {\n-\t\t\treturn fmt.Errorf(\"unzip %v: unexpected file name %s\", zipfile, zf.Name)\n-\t\t}\n-\t\tif zf.Name == prefix || strings.HasSuffix(zf.Name, \"/\") {\n-\t\t\tcontinue\n-\t\t}\n-\t\tname := zf.Name[len(prefix)+1:]\n-\t\tif err := module.CheckFilePath(name); err != nil {\n-\t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n-\t\t}\n-\t\tif err := checkFold(name); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tif path.Clean(zf.Name) != zf.Name || strings.HasPrefix(zf.Name[len(prefix)+1:], \"/\") {\n-\t\t\treturn fmt.Errorf(\"unzip %v: invalid file name %s\", zipfile, zf.Name)\n-\t\t}\n-\t\ts := int64(zf.UncompressedSize64)\n-\t\tif s < 0 || maxSize-size < s {\n-\t\t\treturn fmt.Errorf(\"unzip %v: content too large\", zipfile)\n-\t\t}\n-\t\tsize += s\n-\t}\n-\n-\t// Unzip, enforcing sizes checked earlier.\n-\tfor _, zf := range z.File {\n-\t\tif zf.Name == prefix || strings.HasSuffix(zf.Name, \"/\") {\n-\t\t\tcontinue\n-\t\t}\n-\t\tname := zf.Name[len(prefix):]\n-\t\tdst := filepath.Join(dir, name)\n-\t\tif err := os.MkdirAll(filepath.Dir(dst), 0777); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t\tw, err := os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_EXCL, 0444)\n-\t\tif err != nil {\n-\t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n-\t\t}\n-\t\tr, err := zf.Open()\n-\t\tif err != nil {\n-\t\t\tw.Close()\n-\t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n-\t\t}\n-\t\tlr := &io.LimitedReader{R: r, N: int64(zf.UncompressedSize64) + 1}\n-\t\t_, err = io.Copy(w, lr)\n-\t\tr.Close()\n-\t\tif err != nil {\n-\t\t\tw.Close()\n-\t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n-\t\t}\n-\t\tif err := w.Close(); err != nil {\n-\t\t\treturn fmt.Errorf(\"unzip %v: %v\", zipfile, err)\n-\t\t}\n-\t\tif lr.N <= 0 {\n-\t\t\treturn fmt.Errorf(\"unzip %v: content too large\", zipfile)\n-\t\t}\n-\t}\n-\n-\treturn nil\n-}\n-\n-// makeDirsReadOnly makes a best-effort attempt to remove write permissions for dir\n-// and its transitive contents.\n-func makeDirsReadOnly(dir string) {\n-\ttype pathMode struct {\n-\t\tpath string\n-\t\tmode os.FileMode\n-\t}\n-\tvar dirs []pathMode // in lexical order\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n-\t\tif err == nil && info.Mode()&0222 != 0 {\n-\t\t\tif info.IsDir() {\n-\t\t\t\tdirs = append(dirs, pathMode{path, info.Mode()})\n-\t\t\t}\n-\t\t}\n-\t\treturn nil\n-\t})\n-\n-\t// Run over list backward to chmod children before parents.\n-\tfor i := len(dirs) - 1; i >= 0; i-- {\n-\t\tos.Chmod(dirs[i].path, dirs[i].mode&^0222)\n-\t}\n-}\n-\n-// RemoveAll removes a directory written by Download or Unzip, first applying\n-// any permission changes needed to do so.\n-func RemoveAll(dir string) error {\n-\t// Module cache has 0555 directories; make them writable in order to remove content.\n-\tfilepath.Walk(dir, func(path string, info os.FileInfo, err error) error {\n-\t\tif err != nil {\n-\t\t\treturn nil // ignore errors walking in file system\n-\t\t}\n-\t\tif info.IsDir() {\n-\t\t\tos.Chmod(path, 0777)\n-\t\t}\n-\t\treturn nil\n-\t})\n-\treturn os.RemoveAll(dir)\n-}"}, {"sha": "6eb8d7fd839fb2fad7a14a1a97605b675edef9ff", "filename": "libgo/go/cmd/go/internal/modfetch/zip_sum_test/testdata/zip_sums.csv", "status": "added", "additions": 2124, "deletions": 0, "changes": 2124, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Ftestdata%2Fzip_sums.csv?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305"}, {"sha": "331d634d10278b0cd836ddcbe79ae2d634432a3c", "filename": "libgo/go/cmd/go/internal/modfetch/zip_sum_test/zip_sum_test.go", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfetch%2Fzip_sum_test%2Fzip_sum_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,230 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package zip_sum_test tests that the module zip files produced by modfetch\n+// have consistent content sums. Ideally the zip files themselves are also\n+// stable over time, though this is not strictly necessary.\n+//\n+// This test loads a table from testdata/zip_sums.csv. The table has columns\n+// for module path, version, content sum, and zip file hash. The table\n+// includes a large number of real modules. The test downloads these modules\n+// in direct mode and verifies the zip files.\n+//\n+// This test is very slow, and it depends on outside modules that change\n+// frequently, so this is a manual test. To enable it, pass the -zipsum flag.\n+package zip_sum_test\n+\n+import (\n+\t\"crypto/sha256\"\n+\t\"encoding/csv\"\n+\t\"encoding/hex\"\n+\t\"flag\"\n+\t\"fmt\"\n+\t\"internal/testenv\"\n+\t\"io\"\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+\t\"testing\"\n+\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modload\"\n+\n+\t\"golang.org/x/mod/module\"\n+)\n+\n+var (\n+\tupdateTestData = flag.Bool(\"u\", false, \"when set, tests may update files in testdata instead of failing\")\n+\tenableZipSum   = flag.Bool(\"zipsum\", false, \"enable TestZipSums\")\n+\tdebugZipSum    = flag.Bool(\"testwork\", false, \"when set, TestZipSums will preserve its test directory\")\n+\tmodCacheDir    = flag.String(\"zipsumcache\", \"\", \"module cache to use instead of temp directory\")\n+\tshardCount     = flag.Int(\"zipsumshardcount\", 1, \"number of shards to divide TestZipSums into\")\n+\tshardIndex     = flag.Int(\"zipsumshard\", 0, \"index of TestZipSums shard to test (0 <= zipsumshard < zipsumshardcount)\")\n+)\n+\n+const zipSumsPath = \"testdata/zip_sums.csv\"\n+\n+type zipSumTest struct {\n+\tm                     module.Version\n+\twantSum, wantFileHash string\n+}\n+\n+func TestZipSums(t *testing.T) {\n+\tif !*enableZipSum {\n+\t\t// This test is very slow and heavily dependent on external repositories.\n+\t\t// Only run it explicitly.\n+\t\tt.Skip(\"TestZipSum not enabled with -zipsum\")\n+\t}\n+\tif *shardCount < 1 {\n+\t\tt.Fatal(\"-zipsumshardcount must be a positive integer\")\n+\t}\n+\tif *shardIndex < 0 || *shardCount <= *shardIndex {\n+\t\tt.Fatal(\"-zipsumshard must be between 0 and -zipsumshardcount\")\n+\t}\n+\n+\ttestenv.MustHaveGoBuild(t)\n+\ttestenv.MustHaveExternalNetwork(t)\n+\ttestenv.MustHaveExecPath(t, \"bzr\")\n+\ttestenv.MustHaveExecPath(t, \"git\")\n+\t// TODO(jayconrod): add hg, svn, and fossil modules to testdata.\n+\t// Could not find any for now.\n+\n+\ttests, err := readZipSumTests()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\n+\tif *modCacheDir != \"\" {\n+\t\tcfg.BuildContext.GOPATH = *modCacheDir\n+\t} else {\n+\t\ttmpDir, err := ioutil.TempDir(\"\", \"TestZipSums\")\n+\t\tif err != nil {\n+\t\t\tt.Fatal(err)\n+\t\t}\n+\t\tif *debugZipSum {\n+\t\t\tfmt.Fprintf(os.Stderr, \"TestZipSums: modCacheDir: %s\\n\", tmpDir)\n+\t\t} else {\n+\t\t\tdefer os.RemoveAll(tmpDir)\n+\t\t}\n+\t\tcfg.BuildContext.GOPATH = tmpDir\n+\t}\n+\n+\tcfg.GOPROXY = \"direct\"\n+\tcfg.GOSUMDB = \"off\"\n+\tmodload.Init()\n+\n+\t// Shard tests by downloading only every nth module when shard flags are set.\n+\t// This makes it easier to test small groups of modules quickly. We avoid\n+\t// testing similarly named modules together (the list is sorted by module\n+\t// path and version).\n+\tif *shardCount > 1 {\n+\t\tr := *shardIndex\n+\t\tw := 0\n+\t\tfor r < len(tests) {\n+\t\t\ttests[w] = tests[r]\n+\t\t\tw++\n+\t\t\tr += *shardCount\n+\t\t}\n+\t\ttests = tests[:w]\n+\t}\n+\n+\t// Download modules with a rate limit. We may run out of file descriptors\n+\t// or cause timeouts without a limit.\n+\tneedUpdate := false\n+\tfor i := range tests {\n+\t\ttest := &tests[i]\n+\t\tname := fmt.Sprintf(\"%s@%s\", strings.ReplaceAll(test.m.Path, \"/\", \"_\"), test.m.Version)\n+\t\tt.Run(name, func(t *testing.T) {\n+\t\t\tt.Parallel()\n+\t\t\tzipPath, err := modfetch.DownloadZip(test.m)\n+\t\t\tif err != nil {\n+\t\t\t\tif *updateTestData {\n+\t\t\t\t\tt.Logf(\"%s: could not download module: %s (will remove from testdata)\", test.m, err)\n+\t\t\t\t\ttest.m.Path = \"\" // mark for deletion\n+\t\t\t\t\tneedUpdate = true\n+\t\t\t\t} else {\n+\t\t\t\t\tt.Errorf(\"%s: could not download mdoule: %s\", test.m, err)\n+\t\t\t\t}\n+\t\t\t\treturn\n+\t\t\t}\n+\n+\t\t\tsum := modfetch.Sum(test.m)\n+\t\t\tif sum != test.wantSum {\n+\t\t\t\tif *updateTestData {\n+\t\t\t\t\tt.Logf(\"%s: updating content sum to %s\", test.m, sum)\n+\t\t\t\t\ttest.wantSum = sum\n+\t\t\t\t\tneedUpdate = true\n+\t\t\t\t} else {\n+\t\t\t\t\tt.Errorf(\"%s: got content sum %s; want sum %s\", test.m, sum, test.wantSum)\n+\t\t\t\t\treturn\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\th := sha256.New()\n+\t\t\tf, err := os.Open(zipPath)\n+\t\t\tif err != nil {\n+\t\t\t\tt.Errorf(\"%s: %v\", test.m, err)\n+\t\t\t}\n+\t\t\tdefer f.Close()\n+\t\t\tif _, err := io.Copy(h, f); err != nil {\n+\t\t\t\tt.Errorf(\"%s: %v\", test.m, err)\n+\t\t\t}\n+\t\t\tzipHash := hex.EncodeToString(h.Sum(nil))\n+\t\t\tif zipHash != test.wantFileHash {\n+\t\t\t\tif *updateTestData {\n+\t\t\t\t\tt.Logf(\"%s: updating zip file hash to %s\", test.m, zipHash)\n+\t\t\t\t\ttest.wantFileHash = zipHash\n+\t\t\t\t\tneedUpdate = true\n+\t\t\t\t} else {\n+\t\t\t\t\tt.Errorf(\"%s: got zip file hash %s; want hash %s (but content sum matches)\", test.m, zipHash, test.wantFileHash)\n+\t\t\t\t}\n+\t\t\t}\n+\t\t})\n+\t}\n+\n+\tif needUpdate {\n+\t\t// Remove tests marked for deletion\n+\t\tr, w := 0, 0\n+\t\tfor r < len(tests) {\n+\t\t\tif tests[r].m.Path != \"\" {\n+\t\t\t\ttests[w] = tests[r]\n+\t\t\t\tw++\n+\t\t\t}\n+\t\t\tr++\n+\t\t}\n+\t\ttests = tests[:w]\n+\n+\t\tif err := writeZipSumTests(tests); err != nil {\n+\t\t\tt.Error(err)\n+\t\t}\n+\t}\n+}\n+\n+func readZipSumTests() ([]zipSumTest, error) {\n+\tf, err := os.Open(filepath.FromSlash(zipSumsPath))\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\tdefer f.Close()\n+\tr := csv.NewReader(f)\n+\n+\tvar tests []zipSumTest\n+\tfor {\n+\t\tline, err := r.Read()\n+\t\tif err == io.EOF {\n+\t\t\tbreak\n+\t\t} else if err != nil {\n+\t\t\treturn nil, err\n+\t\t} else if len(line) != 4 {\n+\t\t\treturn nil, fmt.Errorf(\"%s:%d: malformed line\", f.Name(), len(tests)+1)\n+\t\t}\n+\t\ttest := zipSumTest{m: module.Version{Path: line[0], Version: line[1]}, wantSum: line[2], wantFileHash: line[3]}\n+\t\ttests = append(tests, test)\n+\t}\n+\treturn tests, nil\n+}\n+\n+func writeZipSumTests(tests []zipSumTest) (err error) {\n+\tf, err := os.Create(filepath.FromSlash(zipSumsPath))\n+\tif err != nil {\n+\t\treturn err\n+\t}\n+\tdefer func() {\n+\t\tif cerr := f.Close(); err == nil && cerr != nil {\n+\t\t\terr = cerr\n+\t\t}\n+\t}()\n+\tw := csv.NewWriter(f)\n+\tline := make([]string, 0, 4)\n+\tfor _, test := range tests {\n+\t\tline = append(line[:0], test.m.Path, test.m.Version, test.wantSum, test.wantFileHash)\n+\t\tif err := w.Write(line); err != nil {\n+\t\t\treturn err\n+\t\t}\n+\t}\n+\tw.Flush()\n+\treturn nil\n+}"}, {"sha": "c94b3848a0e163a4d4220f0f39e00a390cd38c23", "filename": "libgo/go/cmd/go/internal/modfile/gopkgin.go", "status": "removed", "additions": 0, "deletions": 47, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fgopkgin.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,47 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// TODO: Figure out what gopkg.in should do.\n-\n-package modfile\n-\n-import \"strings\"\n-\n-// ParseGopkgIn splits gopkg.in import paths into their constituent parts\n-func ParseGopkgIn(path string) (root, repo, major, subdir string, ok bool) {\n-\tif !strings.HasPrefix(path, \"gopkg.in/\") {\n-\t\treturn\n-\t}\n-\tf := strings.Split(path, \"/\")\n-\tif len(f) >= 2 {\n-\t\tif elem, v, ok := dotV(f[1]); ok {\n-\t\t\troot = strings.Join(f[:2], \"/\")\n-\t\t\trepo = \"github.com/go-\" + elem + \"/\" + elem\n-\t\t\tmajor = v\n-\t\t\tsubdir = strings.Join(f[2:], \"/\")\n-\t\t\treturn root, repo, major, subdir, true\n-\t\t}\n-\t}\n-\tif len(f) >= 3 {\n-\t\tif elem, v, ok := dotV(f[2]); ok {\n-\t\t\troot = strings.Join(f[:3], \"/\")\n-\t\t\trepo = \"github.com/\" + f[1] + \"/\" + elem\n-\t\t\tmajor = v\n-\t\t\tsubdir = strings.Join(f[3:], \"/\")\n-\t\t\treturn root, repo, major, subdir, true\n-\t\t}\n-\t}\n-\treturn\n-}\n-\n-func dotV(name string) (elem, v string, ok bool) {\n-\ti := len(name) - 1\n-\tfor i >= 0 && '0' <= name[i] && name[i] <= '9' {\n-\t\ti--\n-\t}\n-\tif i <= 2 || i+1 >= len(name) || name[i-1] != '.' || name[i] != 'v' || name[i+1] == '0' && len(name) != i+2 {\n-\t\treturn \"\", \"\", false\n-\t}\n-\treturn name[:i-1], name[i:], true\n-}"}, {"sha": "8cb1a3908c53f268cbb4b6d3217ba1ac0d1ab76e", "filename": "libgo/go/cmd/go/internal/modfile/read_test.go", "status": "removed", "additions": 0, "deletions": 365, "changes": 365, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Fread_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,365 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modfile\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"os/exec\"\n-\t\"path/filepath\"\n-\t\"reflect\"\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-// exists reports whether the named file exists.\n-func exists(name string) bool {\n-\t_, err := os.Stat(name)\n-\treturn err == nil\n-}\n-\n-// Test that reading and then writing the golden files\n-// does not change their output.\n-func TestPrintGolden(t *testing.T) {\n-\touts, err := filepath.Glob(\"testdata/*.golden\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tfor _, out := range outs {\n-\t\ttestPrint(t, out, out)\n-\t}\n-}\n-\n-// testPrint is a helper for testing the printer.\n-// It reads the file named in, reformats it, and compares\n-// the result to the file named out.\n-func testPrint(t *testing.T, in, out string) {\n-\tdata, err := ioutil.ReadFile(in)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tgolden, err := ioutil.ReadFile(out)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tbase := \"testdata/\" + filepath.Base(in)\n-\tf, err := parse(in, data)\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\n-\tndata := Format(f)\n-\n-\tif !bytes.Equal(ndata, golden) {\n-\t\tt.Errorf(\"formatted %s incorrectly: diff shows -golden, +ours\", base)\n-\t\ttdiff(t, string(golden), string(ndata))\n-\t\treturn\n-\t}\n-}\n-\n-func TestParseLax(t *testing.T) {\n-\tbadFile := []byte(`module m\n-\t\tsurprise attack\n-\t\tx y (\n-\t\t\tz\n-\t\t)\n-\t\texclude v1.2.3\n-\t\treplace <-!!!\n-\t`)\n-\t_, err := ParseLax(\"file\", badFile, nil)\n-\tif err != nil {\n-\t\tt.Fatalf(\"ParseLax did not ignore irrelevant errors: %v\", err)\n-\t}\n-}\n-\n-// Test that when files in the testdata directory are parsed\n-// and printed and parsed again, we get the same parse tree\n-// both times.\n-func TestPrintParse(t *testing.T) {\n-\touts, err := filepath.Glob(\"testdata/*\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tfor _, out := range outs {\n-\t\tdata, err := ioutil.ReadFile(out)\n-\t\tif err != nil {\n-\t\t\tt.Error(err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tbase := \"testdata/\" + filepath.Base(out)\n-\t\tf, err := parse(base, data)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"parsing original: %v\", err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\tndata := Format(f)\n-\t\tf2, err := parse(base, ndata)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"parsing reformatted: %v\", err)\n-\t\t\tcontinue\n-\t\t}\n-\n-\t\teq := eqchecker{file: base}\n-\t\tif err := eq.check(f, f2); err != nil {\n-\t\t\tt.Errorf(\"not equal (parse/Format/parse): %v\", err)\n-\t\t}\n-\n-\t\tpf1, err := Parse(base, data, nil)\n-\t\tif err != nil {\n-\t\t\tswitch base {\n-\t\t\tcase \"testdata/replace2.in\", \"testdata/gopkg.in.golden\":\n-\t\t\t\tt.Errorf(\"should parse %v: %v\", base, err)\n-\t\t\t}\n-\t\t}\n-\t\tif err == nil {\n-\t\t\tpf2, err := Parse(base, ndata, nil)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"Parsing reformatted: %v\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\teq := eqchecker{file: base}\n-\t\t\tif err := eq.check(pf1, pf2); err != nil {\n-\t\t\t\tt.Errorf(\"not equal (parse/Format/Parse): %v\", err)\n-\t\t\t}\n-\n-\t\t\tndata2, err := pf1.Format()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"reformat: %v\", err)\n-\t\t\t}\n-\t\t\tpf3, err := Parse(base, ndata2, nil)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Errorf(\"Parsing reformatted2: %v\", err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\teq = eqchecker{file: base}\n-\t\t\tif err := eq.check(pf1, pf3); err != nil {\n-\t\t\t\tt.Errorf(\"not equal (Parse/Format/Parse): %v\", err)\n-\t\t\t}\n-\t\t\tndata = ndata2\n-\t\t}\n-\n-\t\tif strings.HasSuffix(out, \".in\") {\n-\t\t\tgolden, err := ioutil.ReadFile(strings.TrimSuffix(out, \".in\") + \".golden\")\n-\t\t\tif err != nil {\n-\t\t\t\tt.Error(err)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tif !bytes.Equal(ndata, golden) {\n-\t\t\t\tt.Errorf(\"formatted %s incorrectly: diff shows -golden, +ours\", base)\n-\t\t\t\ttdiff(t, string(golden), string(ndata))\n-\t\t\t\treturn\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// An eqchecker holds state for checking the equality of two parse trees.\n-type eqchecker struct {\n-\tfile string\n-\tpos  Position\n-}\n-\n-// errorf returns an error described by the printf-style format and arguments,\n-// inserting the current file position before the error text.\n-func (eq *eqchecker) errorf(format string, args ...interface{}) error {\n-\treturn fmt.Errorf(\"%s:%d: %s\", eq.file, eq.pos.Line,\n-\t\tfmt.Sprintf(format, args...))\n-}\n-\n-// check checks that v and w represent the same parse tree.\n-// If not, it returns an error describing the first difference.\n-func (eq *eqchecker) check(v, w interface{}) error {\n-\treturn eq.checkValue(reflect.ValueOf(v), reflect.ValueOf(w))\n-}\n-\n-var (\n-\tposType      = reflect.TypeOf(Position{})\n-\tcommentsType = reflect.TypeOf(Comments{})\n-)\n-\n-// checkValue checks that v and w represent the same parse tree.\n-// If not, it returns an error describing the first difference.\n-func (eq *eqchecker) checkValue(v, w reflect.Value) error {\n-\t// inner returns the innermost expression for v.\n-\t// if v is a non-nil interface value, it returns the concrete\n-\t// value in the interface.\n-\tinner := func(v reflect.Value) reflect.Value {\n-\t\tfor {\n-\t\t\tif v.Kind() == reflect.Interface && !v.IsNil() {\n-\t\t\t\tv = v.Elem()\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tbreak\n-\t\t}\n-\t\treturn v\n-\t}\n-\n-\tv = inner(v)\n-\tw = inner(w)\n-\tif v.Kind() == reflect.Invalid && w.Kind() == reflect.Invalid {\n-\t\treturn nil\n-\t}\n-\tif v.Kind() == reflect.Invalid {\n-\t\treturn eq.errorf(\"nil interface became %s\", w.Type())\n-\t}\n-\tif w.Kind() == reflect.Invalid {\n-\t\treturn eq.errorf(\"%s became nil interface\", v.Type())\n-\t}\n-\n-\tif v.Type() != w.Type() {\n-\t\treturn eq.errorf(\"%s became %s\", v.Type(), w.Type())\n-\t}\n-\n-\tif p, ok := v.Interface().(Expr); ok {\n-\t\teq.pos, _ = p.Span()\n-\t}\n-\n-\tswitch v.Kind() {\n-\tdefault:\n-\t\treturn eq.errorf(\"unexpected type %s\", v.Type())\n-\n-\tcase reflect.Bool, reflect.Int, reflect.String:\n-\t\tvi := v.Interface()\n-\t\twi := w.Interface()\n-\t\tif vi != wi {\n-\t\t\treturn eq.errorf(\"%v became %v\", vi, wi)\n-\t\t}\n-\n-\tcase reflect.Slice:\n-\t\tvl := v.Len()\n-\t\twl := w.Len()\n-\t\tfor i := 0; i < vl || i < wl; i++ {\n-\t\t\tif i >= vl {\n-\t\t\t\treturn eq.errorf(\"unexpected %s\", w.Index(i).Type())\n-\t\t\t}\n-\t\t\tif i >= wl {\n-\t\t\t\treturn eq.errorf(\"missing %s\", v.Index(i).Type())\n-\t\t\t}\n-\t\t\tif err := eq.checkValue(v.Index(i), w.Index(i)); err != nil {\n-\t\t\t\treturn err\n-\t\t\t}\n-\t\t}\n-\n-\tcase reflect.Struct:\n-\t\t// Fields in struct must match.\n-\t\tt := v.Type()\n-\t\tn := t.NumField()\n-\t\tfor i := 0; i < n; i++ {\n-\t\t\ttf := t.Field(i)\n-\t\t\tswitch {\n-\t\t\tdefault:\n-\t\t\t\tif err := eq.checkValue(v.Field(i), w.Field(i)); err != nil {\n-\t\t\t\t\treturn err\n-\t\t\t\t}\n-\n-\t\t\tcase tf.Type == posType: // ignore positions\n-\t\t\tcase tf.Type == commentsType: // ignore comment assignment\n-\t\t\t}\n-\t\t}\n-\n-\tcase reflect.Ptr, reflect.Interface:\n-\t\tif v.IsNil() != w.IsNil() {\n-\t\t\tif v.IsNil() {\n-\t\t\t\treturn eq.errorf(\"unexpected %s\", w.Elem().Type())\n-\t\t\t}\n-\t\t\treturn eq.errorf(\"missing %s\", v.Elem().Type())\n-\t\t}\n-\t\tif err := eq.checkValue(v.Elem(), w.Elem()); err != nil {\n-\t\t\treturn err\n-\t\t}\n-\t}\n-\treturn nil\n-}\n-\n-// diff returns the output of running diff on b1 and b2.\n-func diff(b1, b2 []byte) (data []byte, err error) {\n-\tf1, err := ioutil.TempFile(\"\", \"testdiff\")\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer os.Remove(f1.Name())\n-\tdefer f1.Close()\n-\n-\tf2, err := ioutil.TempFile(\"\", \"testdiff\")\n-\tif err != nil {\n-\t\treturn nil, err\n-\t}\n-\tdefer os.Remove(f2.Name())\n-\tdefer f2.Close()\n-\n-\tf1.Write(b1)\n-\tf2.Write(b2)\n-\n-\tdata, err = exec.Command(\"diff\", \"-u\", f1.Name(), f2.Name()).CombinedOutput()\n-\tif len(data) > 0 {\n-\t\t// diff exits with a non-zero status when the files don't match.\n-\t\t// Ignore that failure as long as we get output.\n-\t\terr = nil\n-\t}\n-\treturn\n-}\n-\n-// tdiff logs the diff output to t.Error.\n-func tdiff(t *testing.T, a, b string) {\n-\tdata, err := diff([]byte(a), []byte(b))\n-\tif err != nil {\n-\t\tt.Error(err)\n-\t\treturn\n-\t}\n-\tt.Error(string(data))\n-}\n-\n-var modulePathTests = []struct {\n-\tinput    []byte\n-\texpected string\n-}{\n-\t{input: []byte(\"module \\\"github.com/rsc/vgotest\\\"\"), expected: \"github.com/rsc/vgotest\"},\n-\t{input: []byte(\"module github.com/rsc/vgotest\"), expected: \"github.com/rsc/vgotest\"},\n-\t{input: []byte(\"module  \\\"github.com/rsc/vgotest\\\"\"), expected: \"github.com/rsc/vgotest\"},\n-\t{input: []byte(\"module  github.com/rsc/vgotest\"), expected: \"github.com/rsc/vgotest\"},\n-\t{input: []byte(\"module `github.com/rsc/vgotest`\"), expected: \"github.com/rsc/vgotest\"},\n-\t{input: []byte(\"module \\\"github.com/rsc/vgotest/v2\\\"\"), expected: \"github.com/rsc/vgotest/v2\"},\n-\t{input: []byte(\"module github.com/rsc/vgotest/v2\"), expected: \"github.com/rsc/vgotest/v2\"},\n-\t{input: []byte(\"module \\\"gopkg.in/yaml.v2\\\"\"), expected: \"gopkg.in/yaml.v2\"},\n-\t{input: []byte(\"module gopkg.in/yaml.v2\"), expected: \"gopkg.in/yaml.v2\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\\"\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\n\\\"\"), expected: \"\"},\n-\t{input: []byte(\"module gopkg.in/check.v1\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\\"\\r\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module gopkg.in/check.v1\\r\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\\"\\n\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module gopkg.in/check.v1\\n\\n\"), expected: \"gopkg.in/check.v1\"},\n-\t{input: []byte(\"module \\n\\\"gopkg.in/check.v1\\\"\\n\\n\"), expected: \"\"},\n-\t{input: []byte(\"module \\ngopkg.in/check.v1\\n\\n\"), expected: \"\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\\"asd\"), expected: \"\"},\n-\t{input: []byte(\"module \\n\\\"gopkg.in/check.v1\\\"\\n\\n\"), expected: \"\"},\n-\t{input: []byte(\"module \\ngopkg.in/check.v1\\n\\n\"), expected: \"\"},\n-\t{input: []byte(\"module \\\"gopkg.in/check.v1\\\"asd\"), expected: \"\"},\n-\t{input: []byte(\"module  \\nmodule a/b/c \"), expected: \"a/b/c\"},\n-\t{input: []byte(\"module \\\"   \\\"\"), expected: \"   \"},\n-\t{input: []byte(\"module   \"), expected: \"\"},\n-\t{input: []byte(\"module \\\"  a/b/c  \\\"\"), expected: \"  a/b/c  \"},\n-\t{input: []byte(\"module \\\"github.com/rsc/vgotest1\\\" // with a comment\"), expected: \"github.com/rsc/vgotest1\"},\n-}\n-\n-func TestModulePath(t *testing.T) {\n-\tfor _, test := range modulePathTests {\n-\t\tt.Run(string(test.input), func(t *testing.T) {\n-\t\t\tresult := ModulePath(test.input)\n-\t\t\tif result != test.expected {\n-\t\t\t\tt.Fatalf(\"ModulePath(%q): %s, want %s\", string(test.input), result, test.expected)\n-\t\t\t}\n-\t\t})\n-\t}\n-}"}, {"sha": "b88ad62916845b2b72d4eef9a49ccb0215b6e3e0", "filename": "libgo/go/cmd/go/internal/modfile/rule_test.go", "status": "removed", "additions": 0, "deletions": 90, "changes": 90, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Frule_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,90 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package modfile\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"testing\"\n-)\n-\n-var addRequireTests = []struct {\n-\tin   string\n-\tpath string\n-\tvers string\n-\tout  string\n-}{\n-\t{\n-\t\t`\n-\t\tmodule m\n-\t\trequire x.y/z v1.2.3\n-\t\t`,\n-\t\t\"x.y/z\", \"v1.5.6\",\n-\t\t`\n-\t\tmodule m\n-\t\trequire x.y/z v1.5.6\n-\t\t`,\n-\t},\n-\t{\n-\t\t`\n-\t\tmodule m\n-\t\trequire x.y/z v1.2.3\n-\t\t`,\n-\t\t\"x.y/w\", \"v1.5.6\",\n-\t\t`\n-\t\tmodule m\n-\t\trequire (\n-\t\t\tx.y/z v1.2.3\n-\t\t\tx.y/w v1.5.6\n-\t\t)\n-\t\t`,\n-\t},\n-\t{\n-\t\t`\n-\t\tmodule m\n-\t\trequire x.y/z v1.2.3\n-\t\trequire x.y/q/v2 v2.3.4\n-\t\t`,\n-\t\t\"x.y/w\", \"v1.5.6\",\n-\t\t`\n-\t\tmodule m\n-\t\trequire x.y/z v1.2.3\n-\t\trequire (\n-\t\t\tx.y/q/v2 v2.3.4\n-\t\t\tx.y/w v1.5.6\n-\t\t)\n-\t\t`,\n-\t},\n-}\n-\n-func TestAddRequire(t *testing.T) {\n-\tfor i, tt := range addRequireTests {\n-\t\tt.Run(fmt.Sprintf(\"#%d\", i), func(t *testing.T) {\n-\t\t\tf, err := Parse(\"in\", []byte(tt.in), nil)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tg, err := Parse(\"out\", []byte(tt.out), nil)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tgolden, err := g.Format()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\n-\t\t\tif err := f.AddRequire(tt.path, tt.vers); err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tout, err := f.Format()\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif !bytes.Equal(out, golden) {\n-\t\t\t\tt.Errorf(\"have:\\n%s\\nwant:\\n%s\", out, golden)\n-\t\t\t}\n-\t\t})\n-\t}\n-}"}, {"sha": "4aa2d634fc92aae932db31c85f4b30ecb0dc7b26", "filename": "libgo/go/cmd/go/internal/modfile/testdata/block.golden", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,29 +0,0 @@\n-// comment\n-x \"y\" z\n-\n-// block\n-block ( // block-eol\n-\t// x-before-line\n-\n-\t\"x\" ( y // x-eol\n-\t\"x1\"\n-\t\"x2\"\n-\t// line\n-\t\"x3\"\n-\t\"x4\"\n-\n-\t\"x5\"\n-\n-\t// y-line\n-\t\"y\" //  y-eol\n-\n-\t\"z\" // z-eol\n-) // block-eol2\n-\n-block2 (\n-\tx\n-\ty\n-\tz\n-)\n-\n-// eof"}, {"sha": "1dfae65f5c0f080da0f924eec8a188930df00498", "filename": "libgo/go/cmd/go/internal/modfile/testdata/block.in", "status": "removed", "additions": 0, "deletions": 29, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fblock.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,29 +0,0 @@\n-// comment\n-x \"y\" z\n-\n-// block\n-block ( // block-eol\n-\t// x-before-line\n-\t\n-\t\"x\" ( y // x-eol\n-\t\"x1\"\n-\t\"x2\"\n-\t// line\n-\t\"x3\"\n-\t\"x4\"\n-\t\n-\t\"x5\"\n-\t\n-\t// y-line\n-\t\"y\" //  y-eol\n-\t\n-\t\"z\" // z-eol\n-) // block-eol2\n-\n-\n-block2 (x\n-\ty\n-\tz\n-)\n-\n-// eof"}, {"sha": "75f3b84478c35048432005b3bc3f1354e2c6bc94", "filename": "libgo/go/cmd/go/internal/modfile/testdata/comment.golden", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,10 +0,0 @@\n-// comment\n-module \"x\" // eol\n-\n-// mid comment\n-\n-// comment 2\n-// comment 2 line 2\n-module \"y\" // eoy\n-\n-// comment 3"}, {"sha": "bfc2492b26450c8f4d3671cdd0ba898b46cf2e3b", "filename": "libgo/go/cmd/go/internal/modfile/testdata/comment.in", "status": "removed", "additions": 0, "deletions": 8, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fcomment.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,8 +0,0 @@\n-// comment\n-module \"x\" // eol\n-// mid comment\n-\n-// comment 2\n-// comment 2 line 2\n-module \"y\" // eoy\n-// comment 3"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/internal/modfile/testdata/empty.golden", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43"}, {"sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391", "filename": "libgo/go/cmd/go/internal/modfile/testdata/empty.in", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fempty.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43"}, {"sha": "41669b3a737bb148d4f4df9d209e2a13ccc129b8", "filename": "libgo/go/cmd/go/internal/modfile/testdata/gopkg.in.golden", "status": "removed", "additions": 0, "deletions": 6, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fgopkg.in.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,6 +0,0 @@\n-module x\n-\n-require (\n-\tgopkg.in/mgo.v2 v2.0.0-20160818020120-3f83fa500528\n-\tgopkg.in/yaml.v2 v2.2.1\n-)"}, {"sha": "78ba94398c3b56416443b67d6ac56bc755d5197c", "filename": "libgo/go/cmd/go/internal/modfile/testdata/module.golden", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1 +0,0 @@\n-module abc"}, {"sha": "08f383623f912fc029b24c7eb01187139d0f365a", "filename": "libgo/go/cmd/go/internal/modfile/testdata/module.in", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Fmodule.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1 +0,0 @@\n-module \"abc\""}, {"sha": "5d6abcfcdadb27a7741a1822c71a2bf040d76198", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace.golden", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,5 +0,0 @@\n-module abc\n-\n-replace xyz v1.2.3 => /tmp/z\n-\n-replace xyz v1.3.4 => my/xyz v1.3.4-me"}, {"sha": "685249946a26fd741cfd62123feca42430420b2d", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace.in", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,5 +0,0 @@\n-module \"abc\"\n-\n-replace \"xyz\" v1.2.3 => \"/tmp/z\"\n-\n-replace \"xyz\" v1.3.4 => \"my/xyz\" v1.3.4-me"}, {"sha": "e1d9c728df4e4551d48b5586606cf2923ad56e07", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace2.golden", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,10 +0,0 @@\n-module abc\n-\n-replace (\n-\txyz v1.2.3 => /tmp/z\n-\txyz v1.3.4 => my/xyz v1.3.4-me\n-\txyz v1.4.5 => \"/tmp/my dir\"\n-\txyz v1.5.6 => my/xyz v1.5.6\n-\n-\txyz => my/other/xyz v1.5.4\n-)"}, {"sha": "786469866f90aa7ca48e89f90b0a862ebc138dd9", "filename": "libgo/go/cmd/go/internal/modfile/testdata/replace2.in", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Freplace2.in?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,10 +0,0 @@\n-module \"abc\"\n-\n-replace (\n-\t\"xyz\" v1.2.3 => \"/tmp/z\"\n-\t\"xyz\" v1.3.4 => \"my/xyz\" \"v1.3.4-me\"\n-\txyz \"v1.4.5\" => \"/tmp/my dir\"\n-\txyz v1.5.6 => my/xyz v1.5.6\n-\n-\txyz => my/other/xyz v1.5.4\n-)"}, {"sha": "8a5c725894858ba36199eccb6ee2625e5f729420", "filename": "libgo/go/cmd/go/internal/modfile/testdata/rule1.golden", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodfile%2Ftestdata%2Frule1.golden?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,7 +0,0 @@\n-module \"x\"\n-\n-module \"y\"\n-\n-require \"x\"\n-\n-require x"}, {"sha": "2a0f6346581a12b9356c5fc267384833150203ae", "filename": "libgo/go/cmd/go/internal/modget/get.go", "status": "modified", "additions": 58, "deletions": 27, "changes": 85, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodget%2Fget.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,25 +6,26 @@\n package modget\n \n import (\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"os\"\n+\t\"path/filepath\"\n+\t\"sort\"\n+\t\"strings\"\n+\t\"sync\"\n+\n \t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/get\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modload\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/semver\"\n \t\"cmd/go/internal/work\"\n-\t\"errors\"\n-\t\"fmt\"\n-\t\"os\"\n-\t\"path/filepath\"\n-\t\"sort\"\n-\t\"strings\"\n-\t\"sync\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var CmdGet = &base.Command{\n@@ -199,7 +200,7 @@ func (v *upgradeFlag) Set(s string) error {\n func (v *upgradeFlag) String() string { return \"\" }\n \n func init() {\n-\twork.AddBuildFlags(CmdGet)\n+\twork.AddBuildFlags(CmdGet, work.OmitModFlag)\n \tCmdGet.Run = runGet // break init loop\n \tCmdGet.Flag.BoolVar(&get.Insecure, \"insecure\", get.Insecure, \"\")\n \tCmdGet.Flag.Var(&getU, \"u\", \"\")\n@@ -256,11 +257,6 @@ type query struct {\n }\n \n func runGet(cmd *base.Command, args []string) {\n-\t// -mod=readonly has no effect on \"go get\".\n-\tif cfg.BuildMod == \"readonly\" {\n-\t\tcfg.BuildMod = \"\"\n-\t}\n-\n \tswitch getU {\n \tcase \"\", \"upgrade\", \"patch\":\n \t\t// ok\n@@ -278,10 +274,6 @@ func runGet(cmd *base.Command, args []string) {\n \t}\n \tmodload.LoadTests = *getT\n \n-\tif cfg.BuildMod == \"vendor\" {\n-\t\tbase.Fatalf(\"go get: disabled by -mod=%s\", cfg.BuildMod)\n-\t}\n-\n \tbuildList := modload.LoadBuildList()\n \tbuildList = buildList[:len(buildList):len(buildList)] // copy on append\n \tversionByPath := make(map[string]string)\n@@ -294,6 +286,10 @@ func runGet(cmd *base.Command, args []string) {\n \t// what was requested.\n \tmodload.DisallowWriteGoMod()\n \n+\t// Allow looking up modules for import paths outside of a module.\n+\t// 'go get' is expected to do this, unlike other commands.\n+\tmodload.AllowMissingModuleImports()\n+\n \t// Parse command-line arguments and report errors. The command-line\n \t// arguments are of the form path@version or simply path, with implicit\n \t// @upgrade. path@none is \"downgrade away\".\n@@ -364,6 +360,10 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t// upgrade golang.org/x/tools.\n \n \t\tcase path == \"all\":\n+\t\t\t// If there is no main module, \"all\" is not meaningful.\n+\t\t\tif !modload.HasModRoot() {\n+\t\t\t\tbase.Errorf(`go get %s: cannot match \"all\": working directory is not part of a module`, arg)\n+\t\t\t}\n \t\t\t// Don't query modules until we load packages. We'll automatically\n \t\t\t// look up any missing modules.\n \n@@ -372,13 +372,15 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\tcontinue\n \n \t\tdefault:\n-\t\t\t// The argument is a package path.\n-\t\t\tif pkgs := modload.TargetPackages(path); len(pkgs) != 0 {\n-\t\t\t\t// The path is in the main module. Nothing to query.\n-\t\t\t\tif vers != \"upgrade\" && vers != \"patch\" {\n-\t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n+\t\t\t// The argument is a package or module path.\n+\t\t\tif modload.HasModRoot() {\n+\t\t\t\tif pkgs := modload.TargetPackages(path); len(pkgs) != 0 {\n+\t\t\t\t\t// The path is in the main module. Nothing to query.\n+\t\t\t\t\tif vers != \"upgrade\" && vers != \"patch\" {\n+\t\t\t\t\t\tbase.Errorf(\"go get %s: can't request explicit version of path in main module\", arg)\n+\t\t\t\t\t}\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tcontinue\n \t\t\t}\n \n \t\t\tfirst := path\n@@ -452,10 +454,13 @@ func runGet(cmd *base.Command, args []string) {\n \t// This includes explicitly requested modules that don't have a root package\n \t// and modules with a target version of \"none\".\n \tvar wg sync.WaitGroup\n+\tvar modOnlyMu sync.Mutex\n \tmodOnly := make(map[string]*query)\n \tfor _, q := range queries {\n \t\tif q.m.Version == \"none\" {\n+\t\t\tmodOnlyMu.Lock()\n \t\t\tmodOnly[q.m.Path] = q\n+\t\t\tmodOnlyMu.Unlock()\n \t\t\tcontinue\n \t\t}\n \t\tif q.path == q.m.Path {\n@@ -464,7 +469,9 @@ func runGet(cmd *base.Command, args []string) {\n \t\t\t\tif hasPkg, err := modload.ModuleHasRootPackage(q.m); err != nil {\n \t\t\t\t\tbase.Errorf(\"go get: %v\", err)\n \t\t\t\t} else if !hasPkg {\n+\t\t\t\t\tmodOnlyMu.Lock()\n \t\t\t\t\tmodOnly[q.m.Path] = q\n+\t\t\t\t\tmodOnlyMu.Unlock()\n \t\t\t\t}\n \t\t\t\twg.Done()\n \t\t\t}(q)\n@@ -763,6 +770,9 @@ func getQuery(path, vers string, prevM module.Version, forceModulePath bool) (mo\n \n \t\tinfo, err := modload.Query(path, vers, prevM.Version, modload.Allowed)\n \t\tif err == nil {\n+\t\t\tif info.Version != vers && info.Version != prevM.Version {\n+\t\t\t\tlogOncef(\"go: %s %s => %s\", path, vers, info.Version)\n+\t\t\t}\n \t\t\treturn module.Version{Path: path, Version: info.Version}, nil\n \t\t}\n \n@@ -791,14 +801,23 @@ func getQuery(path, vers string, prevM module.Version, forceModulePath bool) (mo\n \t\tif !strings.Contains(path, \"...\") {\n \t\t\tvar modErr *modload.PackageNotInModuleError\n \t\t\tif errors.As(err, &modErr) && modErr.Mod.Path == path {\n+\t\t\t\tif modErr.Mod.Version != vers {\n+\t\t\t\t\tlogOncef(\"go: %s %s => %s\", path, vers, modErr.Mod.Version)\n+\t\t\t\t}\n \t\t\t\treturn modErr.Mod, nil\n \t\t\t}\n \t\t}\n \n \t\treturn module.Version{}, err\n \t}\n \n-\treturn results[0].Mod, nil\n+\tm := results[0].Mod\n+\tif m.Path != path {\n+\t\tlogOncef(\"go: found %s in %s %s\", path, m.Path, m.Version)\n+\t} else if m.Version != vers {\n+\t\tlogOncef(\"go: %s %s => %s\", path, vers, m.Version)\n+\t}\n+\treturn m, nil\n }\n \n // An upgrader adapts an underlying mvs.Reqs to apply an\n@@ -955,6 +974,9 @@ func (u *upgrader) Upgrade(m module.Version) (module.Version, error) {\n \t\treturn m, nil\n \t}\n \n+\tif info.Version != m.Version {\n+\t\tlogOncef(\"go: %s %s => %s\", m.Path, getU, info.Version)\n+\t}\n \treturn module.Version{Path: m.Path, Version: info.Version}, nil\n }\n \n@@ -983,3 +1005,12 @@ func (r *lostUpgradeReqs) Required(mod module.Version) ([]module.Version, error)\n \t}\n \treturn r.Reqs.Required(mod)\n }\n+\n+var loggedLines sync.Map\n+\n+func logOncef(format string, args ...interface{}) {\n+\tmsg := fmt.Sprintf(format, args...)\n+\tif _, dup := loggedLines.LoadOrStore(msg, true); !dup {\n+\t\tfmt.Fprintln(os.Stderr, msg)\n+\t}\n+}"}, {"sha": "292fd45a4a6066984a7e44e4ed7bc7655f6e2848", "filename": "libgo/go/cmd/go/internal/modload/build.go", "status": "modified", "additions": 83, "deletions": 29, "changes": 112, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fbuild.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,20 +6,22 @@ package modload\n \n import (\n \t\"bytes\"\n-\t\"cmd/go/internal/base\"\n-\t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modinfo\"\n-\t\"cmd/go/internal/module\"\n-\t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/semver\"\n \t\"encoding/hex\"\n \t\"fmt\"\n \t\"internal/goroot\"\n \t\"os\"\n \t\"path/filepath\"\n \t\"runtime/debug\"\n \t\"strings\"\n+\n+\t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/modfetch\"\n+\t\"cmd/go/internal/modinfo\"\n+\t\"cmd/go/internal/search\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var (\n@@ -43,11 +45,19 @@ func findStandardImportPath(path string) string {\n \treturn \"\"\n }\n \n+// PackageModuleInfo returns information about the module that provides\n+// a given package. If modules are not enabled or if the package is in the\n+// standard library or if the package was not successfully loaded with\n+// ImportPaths or a similar loading function, nil is returned.\n func PackageModuleInfo(pkgpath string) *modinfo.ModulePublic {\n \tif isStandardImportPath(pkgpath) || !Enabled() {\n \t\treturn nil\n \t}\n-\treturn moduleInfo(findModule(pkgpath, pkgpath), true)\n+\tm, ok := findModule(pkgpath)\n+\tif !ok {\n+\t\treturn nil\n+\t}\n+\treturn moduleInfo(m, true)\n }\n \n func ModuleInfo(path string) *modinfo.ModulePublic {\n@@ -119,13 +129,8 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\tinfo.GoVersion = loaded.goVersion[m.Path]\n \t}\n \n-\tif cfg.BuildMod == \"vendor\" {\n-\t\tinfo.Dir = filepath.Join(ModRoot(), \"vendor\", m.Path)\n-\t\treturn info\n-\t}\n-\n-\t// complete fills in the extra fields in m.\n-\tcomplete := func(m *modinfo.ModulePublic) {\n+\t// completeFromModCache fills in the extra fields in m using the module cache.\n+\tcompleteFromModCache := func(m *modinfo.ModulePublic) {\n \t\tif m.Version != \"\" {\n \t\t\tif q, err := Query(m.Path, m.Version, \"\", nil); err != nil {\n \t\t\t\tm.Error = &modinfo.ModuleError{Err: err.Error()}\n@@ -151,13 +156,21 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t}\n \n \tif !fromBuildList {\n-\t\tcomplete(info)\n+\t\tcompleteFromModCache(info) // Will set m.Error in vendor mode.\n \t\treturn info\n \t}\n \n \tr := Replacement(m)\n \tif r.Path == \"\" {\n-\t\tcomplete(info)\n+\t\tif cfg.BuildMod == \"vendor\" {\n+\t\t\t// It's tempting to fill in the \"Dir\" field to point within the vendor\n+\t\t\t// directory, but that would be misleading: the vendor directory contains\n+\t\t\t// a flattened package tree, not complete modules, and it can even\n+\t\t\t// interleave packages from different modules if one module path is a\n+\t\t\t// prefix of the other.\n+\t\t} else {\n+\t\t\tcompleteFromModCache(info)\n+\t\t}\n \t\treturn info\n \t}\n \n@@ -176,23 +189,29 @@ func moduleInfo(m module.Version, fromBuildList bool) *modinfo.ModulePublic {\n \t\t} else {\n \t\t\tinfo.Replace.Dir = filepath.Join(ModRoot(), r.Path)\n \t\t}\n+\t\tinfo.Replace.GoMod = filepath.Join(info.Replace.Dir, \"go.mod\")\n+\t}\n+\tif cfg.BuildMod != \"vendor\" {\n+\t\tcompleteFromModCache(info.Replace)\n+\t\tinfo.Dir = info.Replace.Dir\n+\t\tinfo.GoMod = info.Replace.GoMod\n \t}\n-\tcomplete(info.Replace)\n-\tinfo.Dir = info.Replace.Dir\n-\tinfo.GoMod = filepath.Join(info.Dir, \"go.mod\")\n \treturn info\n }\n \n+// PackageBuildInfo returns a string containing module version information\n+// for modules providing packages named by path and deps. path and deps must\n+// name packages that were resolved successfully with ImportPaths or one of\n+// the Load functions.\n func PackageBuildInfo(path string, deps []string) string {\n \tif isStandardImportPath(path) || !Enabled() {\n \t\treturn \"\"\n \t}\n-\n-\ttarget := findModule(path, path)\n+\ttarget := mustFindModule(path, path)\n \tmdeps := make(map[module.Version]bool)\n \tfor _, dep := range deps {\n \t\tif !isStandardImportPath(dep) {\n-\t\t\tmdeps[findModule(path, dep)] = true\n+\t\t\tmdeps[mustFindModule(path, dep)] = true\n \t\t}\n \t}\n \tvar mods []module.Version\n@@ -227,9 +246,12 @@ func PackageBuildInfo(path string, deps []string) string {\n \treturn buf.String()\n }\n \n-// findModule returns the module containing the package at path,\n-// needed to build the package at target.\n-func findModule(target, path string) module.Version {\n+// mustFindModule is like findModule, but it calls base.Fatalf if the\n+// module can't be found.\n+//\n+// TODO(jayconrod): remove this. Callers should use findModule and return\n+// errors instead of relying on base.Fatalf.\n+func mustFindModule(target, path string) module.Version {\n \tpkg, ok := loaded.pkgCache.Get(path).(*loadPkg)\n \tif ok {\n \t\tif pkg.err != nil {\n@@ -249,17 +271,49 @@ func findModule(target, path string) module.Version {\n \tpanic(\"unreachable\")\n }\n \n-func ModInfoProg(info string) []byte {\n+// findModule searches for the module that contains the package at path.\n+// If the package was loaded with ImportPaths or one of the other loading\n+// functions, its containing module and true are returned. Otherwise,\n+// module.Version{} and false are returend.\n+func findModule(path string) (module.Version, bool) {\n+\tif pkg, ok := loaded.pkgCache.Get(path).(*loadPkg); ok {\n+\t\treturn pkg.mod, pkg.mod != module.Version{}\n+\t}\n+\tif path == \"command-line-arguments\" {\n+\t\treturn Target, true\n+\t}\n+\treturn module.Version{}, false\n+}\n+\n+func ModInfoProg(info string, isgccgo bool) []byte {\n \t// Inject a variable with the debug information as runtime.modinfo,\n \t// but compile it in package main so that it is specific to the binary.\n \t// The variable must be a literal so that it will have the correct value\n \t// before the initializer for package main runs.\n \t//\n-\t// The runtime startup code refers to the variable, which keeps it live in all binaries.\n-\treturn []byte(fmt.Sprintf(`package main\n+\t// The runtime startup code refers to the variable, which keeps it live\n+\t// in all binaries.\n+\t//\n+\t// Note: we use an alternate recipe below for gccgo (based on an\n+\t// init function) due to the fact that gccgo does not support\n+\t// applying a \"//go:linkname\" directive to a variable. This has\n+\t// drawbacks in that other packages may want to look at the module\n+\t// info in their init functions (see issue 29628), which won't\n+\t// work for gccgo. See also issue 30344.\n+\n+\tif !isgccgo {\n+\t\treturn []byte(fmt.Sprintf(`package main\n import _ \"unsafe\"\n //go:linkname __set_modinfo__ runtime.setmodinfo\n func __set_modinfo__(string)\n func init() { __set_modinfo__(%q) }\n \t`, string(infoStart)+info+string(infoEnd)))\n+\t} else {\n+\t\treturn []byte(fmt.Sprintf(`package main\n+import _ \"unsafe\"\n+//go:linkname __set_debug_modinfo__ runtime.setmodinfo\n+func __set_debug_modinfo__(string)\n+func init() { __set_debug_modinfo__(%q) }\n+\t`, string(infoStart)+info+string(infoEnd)))\n+\t}\n }"}, {"sha": "b47f3dedb372b5228133fa92fe8569c7f0980631", "filename": "libgo/go/cmd/go/internal/modload/help.go", "status": "modified", "additions": 3, "deletions": 0, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fhelp.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -179,6 +179,9 @@ If invoked with -mod=vendor, the go command assumes that the vendor\n directory holds the correct copies of dependencies and ignores\n the dependency descriptions in go.mod.\n \n+If invoked with -mod=mod, the go command loads modules from the module cache\n+even if there is a vendor directory present.\n+\n Pseudo-versions\n \n The go.mod file and the go command more generally use semantic versions as"}, {"sha": "9ae2900e4691e5fd97e379450a08766b2b533f96", "filename": "libgo/go/cmd/go/internal/modload/import.go", "status": "modified", "additions": 103, "deletions": 31, "changes": 134, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,6 @@\n package modload\n \n import (\n-\t\"bytes\"\n \t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n@@ -17,31 +16,81 @@ import (\n \t\"time\"\n \n \t\"cmd/go/internal/cfg\"\n+\t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/semver\"\n-\t\"cmd/go/internal/str\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n type ImportMissingError struct {\n-\tImportPath string\n-\tModule     module.Version\n+\tPath     string\n+\tModule   module.Version\n+\tQueryErr error\n \n \t// newMissingVersion is set to a newer version of Module if one is present\n \t// in the build list. When set, we can't automatically upgrade.\n \tnewMissingVersion string\n }\n \n+var _ load.ImportPathError = (*ImportMissingError)(nil)\n+\n func (e *ImportMissingError) Error() string {\n \tif e.Module.Path == \"\" {\n-\t\tif str.HasPathPrefix(e.ImportPath, \"cmd\") {\n-\t\t\treturn fmt.Sprintf(\"package %s is not in GOROOT (%s)\", e.ImportPath, filepath.Join(cfg.GOROOT, \"src\", e.ImportPath))\n+\t\tif search.IsStandardImportPath(e.Path) {\n+\t\t\treturn fmt.Sprintf(\"package %s is not in GOROOT (%s)\", e.Path, filepath.Join(cfg.GOROOT, \"src\", e.Path))\n+\t\t}\n+\t\tif e.QueryErr != nil {\n+\t\t\treturn fmt.Sprintf(\"cannot find module providing package %s: %v\", e.Path, e.QueryErr)\n+\t\t}\n+\t\treturn \"cannot find module providing package \" + e.Path\n+\t}\n+\treturn fmt.Sprintf(\"missing module for import: %s@%s provides %s\", e.Module.Path, e.Module.Version, e.Path)\n+}\n+\n+func (e *ImportMissingError) Unwrap() error {\n+\treturn e.QueryErr\n+}\n+\n+func (e *ImportMissingError) ImportPath() string {\n+\treturn e.Path\n+}\n+\n+// An AmbiguousImportError indicates an import of a package found in multiple\n+// modules in the build list, or found in both the main module and its vendor\n+// directory.\n+type AmbiguousImportError struct {\n+\tImportPath string\n+\tDirs       []string\n+\tModules    []module.Version // Either empty or 1:1 with Dirs.\n+}\n+\n+func (e *AmbiguousImportError) Error() string {\n+\tlocType := \"modules\"\n+\tif len(e.Modules) == 0 {\n+\t\tlocType = \"directories\"\n+\t}\n+\n+\tvar buf strings.Builder\n+\tfmt.Fprintf(&buf, \"ambiguous import: found package %s in multiple %s:\", e.ImportPath, locType)\n+\n+\tfor i, dir := range e.Dirs {\n+\t\tbuf.WriteString(\"\\n\\t\")\n+\t\tif i < len(e.Modules) {\n+\t\t\tm := e.Modules[i]\n+\t\t\tbuf.WriteString(m.Path)\n+\t\t\tif m.Version != \"\" {\n+\t\t\t\tfmt.Fprintf(&buf, \" %s\", m.Version)\n+\t\t\t}\n+\t\t\tfmt.Fprintf(&buf, \" (%s)\", dir)\n+\t\t} else {\n+\t\t\tbuf.WriteString(dir)\n \t\t}\n-\t\treturn \"cannot find module providing package \" + e.ImportPath\n \t}\n-\treturn \"missing module for import: \" + e.Module.Path + \"@\" + e.Module.Version + \" provides \" + e.ImportPath\n+\n+\treturn buf.String()\n }\n \n // Import finds the module and directory in the build list\n@@ -68,8 +117,8 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t}\n \n \t// Is the package in the standard library?\n-\tif search.IsStandardImportPath(path) &&\n-\t\tgoroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n+\tpathIsStd := search.IsStandardImportPath(path)\n+\tif pathIsStd && goroot.IsStandardPackage(cfg.GOROOT, cfg.BuildContext.Compiler, path) {\n \t\tif targetInGorootSrc {\n \t\t\tif dir, ok := dirInModule(path, targetPrefix, ModRoot(), true); ok {\n \t\t\t\treturn Target, dir, nil\n@@ -78,17 +127,14 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\tdir := filepath.Join(cfg.GOROOT, \"src\", path)\n \t\treturn module.Version{}, dir, nil\n \t}\n-\tif str.HasPathPrefix(path, \"cmd\") {\n-\t\treturn module.Version{}, \"\", &ImportMissingError{ImportPath: path}\n-\t}\n \n \t// -mod=vendor is special.\n \t// Everything must be in the main module or the main module's vendor directory.\n \tif cfg.BuildMod == \"vendor\" {\n \t\tmainDir, mainOK := dirInModule(path, targetPrefix, ModRoot(), true)\n \t\tvendorDir, vendorOK := dirInModule(path, \"\", filepath.Join(ModRoot(), \"vendor\"), false)\n \t\tif mainOK && vendorOK {\n-\t\t\treturn module.Version{}, \"\", fmt.Errorf(\"ambiguous import: found %s in multiple directories:\\n\\t%s\\n\\t%s\", path, mainDir, vendorDir)\n+\t\t\treturn module.Version{}, \"\", &AmbiguousImportError{ImportPath: path, Dirs: []string{mainDir, vendorDir}}\n \t\t}\n \t\t// Prefer to return main directory if there is one,\n \t\t// Note that we're not checking that the package exists.\n@@ -97,7 +143,7 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\treturn Target, mainDir, nil\n \t\t}\n \t\treadVendorList()\n-\t\treturn vendorMap[path], vendorDir, nil\n+\t\treturn vendorPkgModule[path], vendorDir, nil\n \t}\n \n \t// Check each module on the build list.\n@@ -128,22 +174,26 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\treturn mods[0], dirs[0], nil\n \t}\n \tif len(mods) > 0 {\n-\t\tvar buf bytes.Buffer\n-\t\tfmt.Fprintf(&buf, \"ambiguous import: found %s in multiple modules:\", path)\n-\t\tfor i, m := range mods {\n-\t\t\tfmt.Fprintf(&buf, \"\\n\\t%s\", m.Path)\n-\t\t\tif m.Version != \"\" {\n-\t\t\t\tfmt.Fprintf(&buf, \" %s\", m.Version)\n-\t\t\t}\n-\t\t\tfmt.Fprintf(&buf, \" (%s)\", dirs[i])\n-\t\t}\n-\t\treturn module.Version{}, \"\", errors.New(buf.String())\n+\t\treturn module.Version{}, \"\", &AmbiguousImportError{ImportPath: path, Dirs: dirs, Modules: mods}\n \t}\n \n \t// Look up module containing the package, for addition to the build list.\n \t// Goal is to determine the module, download it to dir, and return m, dir, ErrMissing.\n \tif cfg.BuildMod == \"readonly\" {\n-\t\treturn module.Version{}, \"\", fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t\tvar queryErr error\n+\t\tif !pathIsStd {\n+\t\t\tif cfg.BuildModReason == \"\" {\n+\t\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\", cfg.BuildMod)\n+\t\t\t}\n+\t\t\tqueryErr = fmt.Errorf(\"import lookup disabled by -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n+\t\t}\n+\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: queryErr}\n+\t}\n+\tif modRoot == \"\" && !allowMissingModuleImports {\n+\t\treturn module.Version{}, \"\", &ImportMissingError{\n+\t\t\tPath:     path,\n+\t\t\tQueryErr: errors.New(\"working directory is not part of a module\"),\n+\t\t}\n \t}\n \n \t// Not on build list.\n@@ -187,17 +237,39 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\t}\n \t\t\t_, ok := dirInModule(path, m.Path, root, isLocal)\n \t\t\tif ok {\n-\t\t\t\treturn m, \"\", &ImportMissingError{ImportPath: path, Module: m}\n+\t\t\t\treturn m, \"\", &ImportMissingError{Path: path, Module: m}\n \t\t\t}\n \t\t}\n+\t\tif len(mods) > 0 && module.CheckPath(path) != nil {\n+\t\t\t// The package path is not valid to fetch remotely,\n+\t\t\t// so it can only exist if in a replaced module,\n+\t\t\t// and we know from the above loop that it is not.\n+\t\t\treturn module.Version{}, \"\", &PackageNotInModuleError{\n+\t\t\t\tMod:         mods[0],\n+\t\t\t\tQuery:       \"latest\",\n+\t\t\t\tPattern:     path,\n+\t\t\t\tReplacement: Replacement(mods[0]),\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tif pathIsStd {\n+\t\t// This package isn't in the standard library, isn't in any module already\n+\t\t// in the build list, and isn't in any other module that the user has\n+\t\t// shimmed in via a \"replace\" directive.\n+\t\t// Moreover, the import path is reserved for the standard library, so\n+\t\t// QueryPackage cannot possibly find a module containing this package.\n+\t\t//\n+\t\t// Instead of trying QueryPackage, report an ImportMissingError immediately.\n+\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path}\n \t}\n \n \tcandidates, err := QueryPackage(path, \"latest\", Allowed)\n \tif err != nil {\n \t\tif errors.Is(err, os.ErrNotExist) {\n \t\t\t// Return \"cannot find module providing package [\u2026]\" instead of whatever\n \t\t\t// low-level error QueryPackage produced.\n-\t\t\treturn module.Version{}, \"\", &ImportMissingError{ImportPath: path}\n+\t\t\treturn module.Version{}, \"\", &ImportMissingError{Path: path, QueryErr: err}\n \t\t} else {\n \t\t\treturn module.Version{}, \"\", err\n \t\t}\n@@ -222,7 +294,7 @@ func Import(path string) (m module.Version, dir string, err error) {\n \t\t\t}\n \t\t}\n \t}\n-\treturn m, \"\", &ImportMissingError{ImportPath: path, Module: m, newMissingVersion: newMissingVersion}\n+\treturn m, \"\", &ImportMissingError{Path: path, Module: m, newMissingVersion: newMissingVersion}\n }\n \n // maybeInModule reports whether, syntactically,"}, {"sha": "accc60eecdf37e57bf6225461a200f09927220dc", "filename": "libgo/go/cmd/go/internal/modload/import_test.go", "status": "modified", "additions": 5, "deletions": 1, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fimport_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -21,7 +21,7 @@ var importTests = []struct {\n \t},\n \t{\n \t\tpath: \"golang.org/x/net\",\n-\t\terr:  \"module golang.org/x/net@.* found, but does not contain package golang.org/x/net\",\n+\t\terr:  `module golang.org/x/net@.* found \\(v0.0.0-.*\\), but does not contain package golang.org/x/net`,\n \t},\n \t{\n \t\tpath: \"golang.org/x/text\",\n@@ -44,6 +44,10 @@ var importTests = []struct {\n func TestImport(t *testing.T) {\n \ttestenv.MustHaveExternalNetwork(t)\n \ttestenv.MustHaveExecPath(t, \"git\")\n+\tdefer func(old bool) {\n+\t\tallowMissingModuleImports = old\n+\t}(allowMissingModuleImports)\n+\tAllowMissingModuleImports()\n \n \tfor _, tt := range importTests {\n \t\tt.Run(strings.ReplaceAll(tt.path, \"/\", \"_\"), func(t *testing.T) {"}, {"sha": "61cbdf2c543264f3f5b37bb61df709bcf104cfa3", "filename": "libgo/go/cmd/go/internal/modload/init.go", "status": "modified", "additions": 477, "deletions": 140, "changes": 617, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Finit.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,6 +7,7 @@ package modload\n import (\n \t\"bytes\"\n \t\"encoding/json\"\n+\t\"errors\"\n \t\"fmt\"\n \t\"go/build\"\n \t\"internal/lazyregexp\"\n@@ -22,26 +23,24 @@ import (\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/load\"\n+\t\"cmd/go/internal/lockedfile\"\n \t\"cmd/go/internal/modconv\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/mvs\"\n-\t\"cmd/go/internal/renameio\"\n \t\"cmd/go/internal/search\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n var (\n-\tcwd            string // TODO(bcmills): Is this redundant with base.Cwd?\n \tmustUseModules = false\n \tinitialized    bool\n \n-\tmodRoot     string\n-\tmodFile     *modfile.File\n-\tmodFileData []byte\n-\texcluded    map[module.Version]bool\n-\tTarget      module.Version\n+\tmodRoot string\n+\tTarget  module.Version\n \n \t// targetPrefix is the path prefix for packages in Target, without a trailing\n \t// slash. For most modules, targetPrefix is just Target.Path, but the\n@@ -56,8 +55,31 @@ var (\n \n \tCmdModInit   bool   // running 'go mod init'\n \tCmdModModule string // module argument for 'go mod init'\n+\n+\tallowMissingModuleImports bool\n )\n \n+var modFile *modfile.File\n+\n+// A modFileIndex is an index of data corresponding to a modFile\n+// at a specific point in time.\n+type modFileIndex struct {\n+\tdata         []byte\n+\tdataNeedsFix bool // true if fixVersion applied a change while parsing data\n+\tmodule       module.Version\n+\tgoVersion    string\n+\trequire      map[module.Version]requireMeta\n+\treplace      map[module.Version]module.Version\n+\texclude      map[module.Version]bool\n+}\n+\n+// index is the index of the go.mod file as of when it was last read or written.\n+var index *modFileIndex\n+\n+type requireMeta struct {\n+\tindirect bool\n+}\n+\n // ModFile returns the parsed go.mod file.\n //\n // Note that after calling ImportPaths or LoadBuildList,\n@@ -89,6 +111,9 @@ func Init() {\n \t}\n \tinitialized = true\n \n+\t// Keep in sync with WillBeEnabled. We perform extra validation here, and\n+\t// there are lots of diagnostics and side effects, so we can't use\n+\t// WillBeEnabled directly.\n \tenv := cfg.Getenv(\"GO111MODULE\")\n \tswitch env {\n \tdefault:\n@@ -129,18 +154,15 @@ func Init() {\n \t\tos.Setenv(\"GIT_SSH_COMMAND\", \"ssh -o ControlMaster=no\")\n \t}\n \n-\tvar err error\n-\tcwd, err = os.Getwd()\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n-\t}\n-\n \tif CmdModInit {\n \t\t// Running 'go mod init': go.mod will be created in current directory.\n-\t\tmodRoot = cwd\n+\t\tmodRoot = base.Cwd\n \t} else {\n-\t\tmodRoot = findModuleRoot(cwd)\n+\t\tmodRoot = findModuleRoot(base.Cwd)\n \t\tif modRoot == \"\" {\n+\t\t\tif cfg.ModFile != \"\" {\n+\t\t\t\tbase.Fatalf(\"go: cannot find main module, but -modfile was set.\\n\\t-modfile cannot be used to set the module root directory.\")\n+\t\t\t}\n \t\t\tif !mustUseModules {\n \t\t\t\t// GO111MODULE is 'auto', and we can't find a module root.\n \t\t\t\t// Stay in GOPATH mode.\n@@ -156,6 +178,9 @@ func Init() {\n \t\t\tfmt.Fprintf(os.Stderr, \"go: warning: ignoring go.mod in system temp root %v\\n\", os.TempDir())\n \t\t}\n \t}\n+\tif cfg.ModFile != \"\" && !strings.HasSuffix(cfg.ModFile, \".mod\") {\n+\t\tbase.Fatalf(\"go: -modfile=%s: file does not have .mod extension\", cfg.ModFile)\n+\t}\n \n \t// We're in module mode. Install the hooks to make it work.\n \n@@ -198,30 +223,23 @@ func Init() {\n \tif modRoot == \"\" {\n \t\t// We're in module mode, but not inside a module.\n \t\t//\n-\t\t// If the command is 'go get' or 'go list' and all of the args are in the\n-\t\t// same existing module, we could use that module's download directory in\n-\t\t// the module cache as the module root, applying any replacements and/or\n-\t\t// exclusions specified by that module. However, that would leave us in a\n-\t\t// strange state: we want 'go get' to be consistent with 'go list', and 'go\n-\t\t// list' should be able to operate on multiple modules. Moreover, the 'get'\n-\t\t// target might specify relative file paths (e.g. in the same repository) as\n-\t\t// replacements, and we would not be able to apply those anyway: we would\n-\t\t// need to either error out or ignore just those replacements, when a build\n-\t\t// from an empty module could proceed without error.\n+\t\t// Commands like 'go build', 'go run', 'go list' have no go.mod file to\n+\t\t// read or write. They would need to find and download the latest versions\n+\t\t// of a potentially large number of modules with no way to save version\n+\t\t// information. We can succeed slowly (but not reproducibly), but that's\n+\t\t// not usually a good experience.\n \t\t//\n-\t\t// Instead, we'll operate as though we're in some ephemeral external module,\n-\t\t// ignoring all replacements and exclusions uniformly.\n-\n-\t\t// Normally we check sums using the go.sum file from the main module, but\n-\t\t// without a main module we do not have an authoritative go.sum file.\n+\t\t// Instead, we forbid resolving import paths to modules other than std and\n+\t\t// cmd. Users may still build packages specified with .go files on the\n+\t\t// command line, but they'll see an error if those files import anything\n+\t\t// outside std.\n \t\t//\n-\t\t// TODO(bcmills): In Go 1.13, check sums when outside the main module.\n+\t\t// This can be overridden by calling AllowMissingModuleImports.\n+\t\t// For example, 'go get' does this, since it is expected to resolve paths.\n \t\t//\n-\t\t// One possible approach is to merge the go.sum files from all of the\n-\t\t// modules we download: that doesn't protect us against bad top-level\n-\t\t// modules, but it at least ensures consistency for transitive dependencies.\n+\t\t// See golang.org/issue/32027.\n \t} else {\n-\t\tmodfetch.GoSumFile = filepath.Join(modRoot, \"go.sum\")\n+\t\tmodfetch.GoSumFile = strings.TrimSuffix(ModFilePath(), \".mod\") + \".sum\"\n \t\tsearch.SetModRoot(modRoot)\n \t}\n }\n@@ -237,6 +255,54 @@ func init() {\n \t}\n }\n \n+// WillBeEnabled checks whether modules should be enabled but does not\n+// initialize modules by installing hooks. If Init has already been called,\n+// WillBeEnabled returns the same result as Enabled.\n+//\n+// This function is needed to break a cycle. The main package needs to know\n+// whether modules are enabled in order to install the module or GOPATH version\n+// of 'go get', but Init reads the -modfile flag in 'go get', so it shouldn't\n+// be called until the command is installed and flags are parsed. Instead of\n+// calling Init and Enabled, the main package can call this function.\n+func WillBeEnabled() bool {\n+\tif modRoot != \"\" || mustUseModules {\n+\t\treturn true\n+\t}\n+\tif initialized {\n+\t\treturn false\n+\t}\n+\n+\t// Keep in sync with Init. Init does extra validation and prints warnings or\n+\t// exits, so it can't call this function directly.\n+\tenv := cfg.Getenv(\"GO111MODULE\")\n+\tswitch env {\n+\tcase \"on\":\n+\t\treturn true\n+\tcase \"auto\", \"\":\n+\t\tbreak\n+\tdefault:\n+\t\treturn false\n+\t}\n+\n+\tif CmdModInit {\n+\t\t// Running 'go mod init': go.mod will be created in current directory.\n+\t\treturn true\n+\t}\n+\tif modRoot := findModuleRoot(base.Cwd); modRoot == \"\" {\n+\t\t// GO111MODULE is 'auto', and we can't find a module root.\n+\t\t// Stay in GOPATH mode.\n+\t\treturn false\n+\t} else if search.InDir(modRoot, os.TempDir()) == \".\" {\n+\t\t// If you create /tmp/go.mod for experimenting,\n+\t\t// then any tests that create work directories under /tmp\n+\t\t// will find it and get modules when they're not expecting them.\n+\t\t// It's a bit of a peculiar thing to disallow but quite mysterious\n+\t\t// when it happens. See golang.org/issue/26708.\n+\t\treturn false\n+\t}\n+\treturn true\n+}\n+\n // Enabled reports whether modules are (or must be) enabled.\n // If modules are enabled but there is no main module, Enabled returns true\n // and then the first use of module information will call die\n@@ -263,6 +329,20 @@ func HasModRoot() bool {\n \treturn modRoot != \"\"\n }\n \n+// ModFilePath returns the effective path of the go.mod file. Normally, this\n+// \"go.mod\" in the directory returned by ModRoot, but the -modfile flag may\n+// change its location. ModFilePath calls base.Fatalf if there is no main\n+// module, even if -modfile is set.\n+func ModFilePath() string {\n+\tif !HasModRoot() {\n+\t\tdie()\n+\t}\n+\tif cfg.ModFile != \"\" {\n+\t\treturn cfg.ModFile\n+\t}\n+\treturn filepath.Join(modRoot, \"go.mod\")\n+}\n+\n // printStackInDie causes die to print a stack trace.\n //\n // It is enabled by the testgo tag, and helps to diagnose paths that\n@@ -276,24 +356,25 @@ func die() {\n \tif cfg.Getenv(\"GO111MODULE\") == \"off\" {\n \t\tbase.Fatalf(\"go: modules disabled by GO111MODULE=off; see 'go help modules'\")\n \t}\n-\tif cwd != \"\" {\n-\t\tif dir, name := findAltConfig(cwd); dir != \"\" {\n-\t\t\trel, err := filepath.Rel(cwd, dir)\n-\t\t\tif err != nil {\n-\t\t\t\trel = dir\n-\t\t\t}\n-\t\t\tcdCmd := \"\"\n-\t\t\tif rel != \".\" {\n-\t\t\t\tcdCmd = fmt.Sprintf(\"cd %s && \", rel)\n-\t\t\t}\n-\t\t\tbase.Fatalf(\"go: cannot find main module, but found %s in %s\\n\\tto create a module there, run:\\n\\t%sgo mod init\", name, dir, cdCmd)\n+\tif dir, name := findAltConfig(base.Cwd); dir != \"\" {\n+\t\trel, err := filepath.Rel(base.Cwd, dir)\n+\t\tif err != nil {\n+\t\t\trel = dir\n \t\t}\n+\t\tcdCmd := \"\"\n+\t\tif rel != \".\" {\n+\t\t\tcdCmd = fmt.Sprintf(\"cd %s && \", rel)\n+\t\t}\n+\t\tbase.Fatalf(\"go: cannot find main module, but found %s in %s\\n\\tto create a module there, run:\\n\\t%sgo mod init\", name, dir, cdCmd)\n \t}\n \tbase.Fatalf(\"go: cannot find main module; see 'go help modules'\")\n }\n \n // InitMod sets Target and, if there is a main module, parses the initial build\n // list from its go.mod file, creating and populating that file if needed.\n+//\n+// As a side-effect, InitMod sets a default for cfg.BuildMod if it does not\n+// already have an explicit value.\n func InitMod() {\n \tif len(buildList) > 0 {\n \t\treturn\n@@ -315,19 +396,20 @@ func InitMod() {\n \t\treturn\n \t}\n \n-\tgomod := filepath.Join(modRoot, \"go.mod\")\n-\tdata, err := renameio.ReadFile(gomod)\n+\tgomod := ModFilePath()\n+\tdata, err := lockedfile.Read(gomod)\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n \n-\tf, err := modfile.Parse(gomod, data, fixVersion)\n+\tvar fixed bool\n+\tf, err := modfile.Parse(gomod, data, fixVersion(&fixed))\n \tif err != nil {\n \t\t// Errors returned by modfile.Parse begin with file:line.\n \t\tbase.Fatalf(\"go: errors parsing go.mod:\\n%s\\n\", err)\n \t}\n \tmodFile = f\n-\tmodFileData = data\n+\tindex = indexModFile(data, f, fixed)\n \n \tif len(f.Syntax.Stmt) == 0 || f.Module == nil {\n \t\t// Empty mod file. Must add module path.\n@@ -344,20 +426,77 @@ func InitMod() {\n \t\tlegacyModInit()\n \t}\n \n-\texcluded = make(map[module.Version]bool)\n-\tfor _, x := range f.Exclude {\n-\t\texcluded[x.Mod] = true\n-\t}\n \tmodFileToBuildList()\n-\tstdVendorMode()\n-\tWriteGoMod()\n+\tsetDefaultBuildMod()\n+\tif cfg.BuildMod == \"vendor\" {\n+\t\treadVendorList()\n+\t\tcheckVendorConsistency()\n+\t} else {\n+\t\t// TODO(golang.org/issue/33326): if cfg.BuildMod != \"readonly\"?\n+\t\tWriteGoMod()\n+\t}\n+}\n+\n+// fixVersion returns a modfile.VersionFixer implemented using the Query function.\n+//\n+// It resolves commit hashes and branch names to versions,\n+// canonicalizes versions that appeared in early vgo drafts,\n+// and does nothing for versions that already appear to be canonical.\n+//\n+// The VersionFixer sets 'fixed' if it ever returns a non-canonical version.\n+func fixVersion(fixed *bool) modfile.VersionFixer {\n+\treturn func(path, vers string) (resolved string, err error) {\n+\t\tdefer func() {\n+\t\t\tif err == nil && resolved != vers {\n+\t\t\t\t*fixed = true\n+\t\t\t}\n+\t\t}()\n+\n+\t\t// Special case: remove the old -gopkgin- hack.\n+\t\tif strings.HasPrefix(path, \"gopkg.in/\") && strings.Contains(vers, \"-gopkgin-\") {\n+\t\t\tvers = vers[strings.Index(vers, \"-gopkgin-\")+len(\"-gopkgin-\"):]\n+\t\t}\n+\n+\t\t// fixVersion is called speculatively on every\n+\t\t// module, version pair from every go.mod file.\n+\t\t// Avoid the query if it looks OK.\n+\t\t_, pathMajor, ok := module.SplitPathVersion(path)\n+\t\tif !ok {\n+\t\t\treturn \"\", &module.ModuleError{\n+\t\t\t\tPath: path,\n+\t\t\t\tErr: &module.InvalidVersionError{\n+\t\t\t\t\tVersion: vers,\n+\t\t\t\t\tErr:     fmt.Errorf(\"malformed module path %q\", path),\n+\t\t\t\t},\n+\t\t\t}\n+\t\t}\n+\t\tif vers != \"\" && module.CanonicalVersion(vers) == vers {\n+\t\t\tif err := module.CheckPathMajor(vers, pathMajor); err == nil {\n+\t\t\t\treturn vers, nil\n+\t\t\t}\n+\t\t}\n+\n+\t\tinfo, err := Query(path, vers, \"\", nil)\n+\t\tif err != nil {\n+\t\t\treturn \"\", err\n+\t\t}\n+\t\treturn info.Version, nil\n+\t}\n+}\n+\n+// AllowMissingModuleImports allows import paths to be resolved to modules\n+// when there is no module root. Normally, this is forbidden because it's slow\n+// and there's no way to make the result reproducible, but some commands\n+// like 'go get' are expected to do this.\n+func AllowMissingModuleImports() {\n+\tallowMissingModuleImports = true\n }\n \n // modFileToBuildList initializes buildList from the modFile.\n func modFileToBuildList() {\n \tTarget = modFile.Module.Mod\n \ttargetPrefix = Target.Path\n-\tif rel := search.InDir(cwd, cfg.GOROOTsrc); rel != \"\" {\n+\tif rel := search.InDir(base.Cwd, cfg.GOROOTsrc); rel != \"\" {\n \t\ttargetInGorootSrc = true\n \t\tif Target.Path == \"std\" {\n \t\t\ttargetPrefix = \"\"\n@@ -371,45 +510,144 @@ func modFileToBuildList() {\n \tbuildList = list\n }\n \n-// stdVendorMode applies inside $GOROOT/src.\n-// It checks that the go.mod matches vendor/modules.txt\n-// and then sets -mod=vendor unless this is a command\n-// that has to do explicitly with modules.\n-func stdVendorMode() {\n-\tif !targetInGorootSrc {\n+// setDefaultBuildMod sets a default value for cfg.BuildMod\n+// if it is currently empty.\n+func setDefaultBuildMod() {\n+\tif cfg.BuildMod != \"\" {\n+\t\t// Don't override an explicit '-mod=' argument.\n \t\treturn\n \t}\n+\tcfg.BuildMod = \"mod\"\n \tif cfg.CmdName == \"get\" || strings.HasPrefix(cfg.CmdName, \"mod \") {\n+\t\t// Don't set -mod implicitly for commands whose purpose is to\n+\t\t// manipulate the build list.\n+\t\treturn\n+\t}\n+\tif modRoot == \"\" {\n \t\treturn\n \t}\n \n+\tif fi, err := os.Stat(filepath.Join(modRoot, \"vendor\")); err == nil && fi.IsDir() {\n+\t\tmodGo := \"unspecified\"\n+\t\tif index.goVersion != \"\" {\n+\t\t\tif semver.Compare(\"v\"+index.goVersion, \"v1.14\") >= 0 {\n+\t\t\t\t// The Go version is at least 1.14, and a vendor directory exists.\n+\t\t\t\t// Set -mod=vendor by default.\n+\t\t\t\tcfg.BuildMod = \"vendor\"\n+\t\t\t\tcfg.BuildModReason = \"Go version in go.mod is at least 1.14 and vendor directory exists.\"\n+\t\t\t\treturn\n+\t\t\t} else {\n+\t\t\t\tmodGo = index.goVersion\n+\t\t\t}\n+\t\t}\n+\n+\t\t// Since a vendor directory exists, we have a non-trivial reason for\n+\t\t// choosing -mod=mod, although it probably won't be used for anything.\n+\t\t// Record the reason anyway for consistency.\n+\t\t// It may be overridden if we switch to mod=readonly below.\n+\t\tcfg.BuildModReason = fmt.Sprintf(\"Go version in go.mod is %s.\", modGo)\n+\t}\n+\n+\tp := ModFilePath()\n+\tif fi, err := os.Stat(p); err == nil && !hasWritePerm(p, fi) {\n+\t\tcfg.BuildMod = \"readonly\"\n+\t\tcfg.BuildModReason = \"go.mod file is read-only.\"\n+\t}\n+}\n+\n+// checkVendorConsistency verifies that the vendor/modules.txt file matches (if\n+// go 1.14) or at least does not contradict (go 1.13 or earlier) the\n+// requirements and replacements listed in the main module's go.mod file.\n+func checkVendorConsistency() {\n \treadVendorList()\n-BuildList:\n-\tfor _, m := range buildList {\n-\t\tif m.Path == \"cmd\" || m.Path == \"std\" {\n-\t\t\tcontinue\n+\n+\tpre114 := false\n+\tif modFile.Go == nil || semver.Compare(\"v\"+modFile.Go.Version, \"v1.14\") < 0 {\n+\t\t// Go versions before 1.14 did not include enough information in\n+\t\t// vendor/modules.txt to check for consistency.\n+\t\t// If we know that we're on an earlier version, relax the consistency check.\n+\t\tpre114 = true\n+\t}\n+\n+\tvendErrors := new(strings.Builder)\n+\tvendErrorf := func(mod module.Version, format string, args ...interface{}) {\n+\t\tdetail := fmt.Sprintf(format, args...)\n+\t\tif mod.Version == \"\" {\n+\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s: %s\", mod.Path, detail)\n+\t\t} else {\n+\t\t\tfmt.Fprintf(vendErrors, \"\\n\\t%s@%s: %s\", mod.Path, mod.Version, detail)\n \t\t}\n-\t\tfor _, v := range vendorList {\n-\t\t\tif m.Path == v.Path {\n-\t\t\t\tif m.Version != v.Version {\n-\t\t\t\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:\\n\"+\n-\t\t\t\t\t\t\"\\tgo.mod requires %s %s but vendor/modules.txt has %s.\\n\"+\n-\t\t\t\t\t\t\"\\trun 'go mod tidy; go mod vendor' to sync\",\n-\t\t\t\t\t\tmodRoot, m.Path, m.Version, v.Version)\n+\t}\n+\n+\tfor _, r := range modFile.Require {\n+\t\tif !vendorMeta[r.Mod].Explicit {\n+\t\t\tif pre114 {\n+\t\t\t\t// Before 1.14, modules.txt did not indicate whether modules were listed\n+\t\t\t\t// explicitly in the main module's go.mod file.\n+\t\t\t\t// However, we can at least detect a version mismatch if packages were\n+\t\t\t\t// vendored from a non-matching version.\n+\t\t\t\tif vv, ok := vendorVersion[r.Mod.Path]; ok && vv != r.Mod.Version {\n+\t\t\t\t\tvendErrorf(r.Mod, fmt.Sprintf(\"is explicitly required in go.mod, but vendor/modules.txt indicates %s@%s\", r.Mod.Path, vv))\n \t\t\t\t}\n-\t\t\t\tcontinue BuildList\n+\t\t\t} else {\n+\t\t\t\tvendErrorf(r.Mod, \"is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt\")\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tdescribe := func(m module.Version) string {\n+\t\tif m.Version == \"\" {\n+\t\t\treturn m.Path\n+\t\t}\n+\t\treturn m.Path + \"@\" + m.Version\n+\t}\n+\n+\t// We need to verify *all* replacements that occur in modfile: even if they\n+\t// don't directly apply to any module in the vendor list, the replacement\n+\t// go.mod file can affect the selected versions of other (transitive)\n+\t// dependencies\n+\tfor _, r := range modFile.Replace {\n+\t\tvr := vendorMeta[r.Old].Replacement\n+\t\tif vr == (module.Version{}) {\n+\t\t\tif pre114 && (r.Old.Version == \"\" || vendorVersion[r.Old.Path] != r.Old.Version) {\n+\t\t\t\t// Before 1.14, modules.txt omitted wildcard replacements and\n+\t\t\t\t// replacements for modules that did not have any packages to vendor.\n+\t\t\t} else {\n+\t\t\t\tvendErrorf(r.Old, \"is replaced in go.mod, but not marked as replaced in vendor/modules.txt\")\n+\t\t\t}\n+\t\t} else if vr != r.New {\n+\t\t\tvendErrorf(r.Old, \"is replaced by %s in go.mod, but marked as replaced by %s in vendor/modules.txt\", describe(r.New), describe(vr))\n+\t\t}\n+\t}\n+\n+\tfor _, mod := range vendorList {\n+\t\tmeta := vendorMeta[mod]\n+\t\tif meta.Explicit {\n+\t\t\tif _, inGoMod := index.require[mod]; !inGoMod {\n+\t\t\t\tvendErrorf(mod, \"is marked as explicit in vendor/modules.txt, but not explicitly required in go.mod\")\n \t\t\t}\n \t\t}\n-\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:\\n\"+\n-\t\t\t\"\\tgo.mod requires %s %s but vendor/modules.txt does not include it.\\n\"+\n-\t\t\t\"\\trun 'go mod tidy; go mod vendor' to sync\", modRoot, m.Path, m.Version)\n \t}\n-\tcfg.BuildMod = \"vendor\"\n+\n+\tfor _, mod := range vendorReplaced {\n+\t\tr := Replacement(mod)\n+\t\tif r == (module.Version{}) {\n+\t\t\tvendErrorf(mod, \"is marked as replaced in vendor/modules.txt, but not replaced in go.mod\")\n+\t\t\tcontinue\n+\t\t}\n+\t\tif meta := vendorMeta[mod]; r != meta.Replacement {\n+\t\t\tvendErrorf(mod, \"is marked as replaced by %s in vendor/modules.txt, but replaced by %s in go.mod\", describe(meta.Replacement), describe(r))\n+\t\t}\n+\t}\n+\n+\tif vendErrors.Len() > 0 {\n+\t\tbase.Fatalf(\"go: inconsistent vendoring in %s:%s\\n\\nrun 'go mod vendor' to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory\", modRoot, vendErrors)\n+\t}\n }\n \n // Allowed reports whether module m is allowed (not excluded) by the main module's go.mod.\n func Allowed(m module.Version) bool {\n-\treturn !excluded[m]\n+\treturn index == nil || !index.exclude[m]\n }\n \n func legacyModInit() {\n@@ -478,6 +716,9 @@ var altConfigs = []string{\n }\n \n func findModuleRoot(dir string) (root string) {\n+\tif dir == \"\" {\n+\t\tpanic(\"dir not set\")\n+\t}\n \tdir = filepath.Clean(dir)\n \n \t// Look for enclosing go.mod.\n@@ -495,6 +736,9 @@ func findModuleRoot(dir string) (root string) {\n }\n \n func findAltConfig(dir string) (root, name string) {\n+\tif dir == \"\" {\n+\t\tpanic(\"dir not set\")\n+\t}\n \tdir = filepath.Clean(dir)\n \tfor {\n \t\tfor _, name := range altConfigs {\n@@ -625,16 +869,17 @@ func AllowWriteGoMod() {\n \tallowWriteGoMod = true\n }\n \n-// MinReqs returns a Reqs with minimal dependencies of Target,\n+// MinReqs returns a Reqs with minimal additional dependencies of Target,\n // as will be written to go.mod.\n func MinReqs() mvs.Reqs {\n-\tvar direct []string\n+\tvar retain []string\n \tfor _, m := range buildList[1:] {\n-\t\tif loaded.direct[m.Path] {\n-\t\t\tdirect = append(direct, m.Path)\n+\t\t_, explicit := index.require[m]\n+\t\tif explicit || loaded.direct[m.Path] {\n+\t\t\tretain = append(retain, m.Path)\n \t\t}\n \t}\n-\tmin, err := mvs.Req(Target, buildList, direct, Reqs())\n+\tmin, err := mvs.Req(Target, retain, Reqs())\n \tif err != nil {\n \t\tbase.Fatalf(\"go: %v\", err)\n \t}\n@@ -655,7 +900,9 @@ func WriteGoMod() {\n \t\treturn\n \t}\n \n-\taddGoStmt()\n+\tif cfg.BuildMod != \"readonly\" {\n+\t\taddGoStmt()\n+\t}\n \n \tif loaded != nil {\n \t\treqs := MinReqs()\n@@ -672,87 +919,177 @@ func WriteGoMod() {\n \t\t}\n \t\tmodFile.SetRequire(list)\n \t}\n+\tmodFile.Cleanup()\n \n-\tmodFile.Cleanup() // clean file after edits\n-\tnew, err := modFile.Format()\n-\tif err != nil {\n-\t\tbase.Fatalf(\"go: %v\", err)\n-\t}\n-\n-\tdirty := !bytes.Equal(new, modFileData)\n+\tdirty := index.modFileIsDirty(modFile)\n \tif dirty && cfg.BuildMod == \"readonly\" {\n \t\t// If we're about to fail due to -mod=readonly,\n \t\t// prefer to report a dirty go.mod over a dirty go.sum\n-\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t\tif cfg.BuildModReason != \"\" {\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\\n\\t(%s)\", cfg.BuildModReason)\n+\t\t} else {\n+\t\t\tbase.Fatalf(\"go: updates to go.mod needed, disabled by -mod=readonly\")\n+\t\t}\n \t}\n \t// Always update go.sum, even if we didn't change go.mod: we may have\n \t// downloaded modules that we didn't have before.\n \tmodfetch.WriteGoSum()\n \n-\tif !dirty {\n-\t\t// We don't need to modify go.mod from what we read previously.\n+\tif !dirty && cfg.CmdName != \"mod tidy\" {\n+\t\t// The go.mod file has the same semantic content that it had before\n+\t\t// (but not necessarily the same exact bytes).\n \t\t// Ignore any intervening edits.\n \t\treturn\n \t}\n \n-\tunlock := modfetch.SideLock()\n-\tdefer unlock()\n+\tnew, err := modFile.Format()\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\tdefer func() {\n+\t\t// At this point we have determined to make the go.mod file on disk equal to new.\n+\t\tindex = indexModFile(new, modFile, false)\n+\t}()\n+\n+\t// Make a best-effort attempt to acquire the side lock, only to exclude\n+\t// previous versions of the 'go' command from making simultaneous edits.\n+\tif unlock, err := modfetch.SideLock(); err == nil {\n+\t\tdefer unlock()\n+\t}\n \n-\tfile := filepath.Join(modRoot, \"go.mod\")\n-\told, err := renameio.ReadFile(file)\n-\tif !bytes.Equal(old, modFileData) {\n+\terrNoChange := errors.New(\"no update needed\")\n+\n+\terr = lockedfile.Transform(ModFilePath(), func(old []byte) ([]byte, error) {\n \t\tif bytes.Equal(old, new) {\n-\t\t\t// Some other process wrote the same go.mod file that we were about to write.\n-\t\t\tmodFileData = new\n-\t\t\treturn\n+\t\t\t// The go.mod file is already equal to new, possibly as the result of some\n+\t\t\t// other process.\n+\t\t\treturn nil, errNoChange\n \t\t}\n-\t\tif err != nil {\n-\t\t\tbase.Fatalf(\"go: can't determine whether go.mod has changed: %v\", err)\n+\n+\t\tif index != nil && !bytes.Equal(old, index.data) {\n+\t\t\t// The contents of the go.mod file have changed. In theory we could add all\n+\t\t\t// of the new modules to the build list, recompute, and check whether any\n+\t\t\t// module in *our* build list got bumped to a different version, but that's\n+\t\t\t// a lot of work for marginal benefit. Instead, fail the command: if users\n+\t\t\t// want to run concurrent commands, they need to start with a complete,\n+\t\t\t// consistent module definition.\n+\t\t\treturn nil, fmt.Errorf(\"existing contents have changed since last read\")\n \t\t}\n-\t\t// The contents of the go.mod file have changed. In theory we could add all\n-\t\t// of the new modules to the build list, recompute, and check whether any\n-\t\t// module in *our* build list got bumped to a different version, but that's\n-\t\t// a lot of work for marginal benefit. Instead, fail the command: if users\n-\t\t// want to run concurrent commands, they need to start with a complete,\n-\t\t// consistent module definition.\n-\t\tbase.Fatalf(\"go: updates to go.mod needed, but contents have changed\")\n \n+\t\treturn new, nil\n+\t})\n+\n+\tif err != nil && err != errNoChange {\n+\t\tbase.Fatalf(\"go: updating go.mod: %v\", err)\n+\t}\n+}\n+\n+// indexModFile rebuilds the index of modFile.\n+// If modFile has been changed since it was first read,\n+// modFile.Cleanup must be called before indexModFile.\n+func indexModFile(data []byte, modFile *modfile.File, needsFix bool) *modFileIndex {\n+\ti := new(modFileIndex)\n+\ti.data = data\n+\ti.dataNeedsFix = needsFix\n+\n+\ti.module = module.Version{}\n+\tif modFile.Module != nil {\n+\t\ti.module = modFile.Module.Mod\n+\t}\n+\n+\ti.goVersion = \"\"\n+\tif modFile.Go != nil {\n+\t\ti.goVersion = modFile.Go.Version\n+\t}\n+\n+\ti.require = make(map[module.Version]requireMeta, len(modFile.Require))\n+\tfor _, r := range modFile.Require {\n+\t\ti.require[r.Mod] = requireMeta{indirect: r.Indirect}\n+\t}\n+\n+\ti.replace = make(map[module.Version]module.Version, len(modFile.Replace))\n+\tfor _, r := range modFile.Replace {\n+\t\tif prev, dup := i.replace[r.Old]; dup && prev != r.New {\n+\t\t\tbase.Fatalf(\"go: conflicting replacements for %v:\\n\\t%v\\n\\t%v\", r.Old, prev, r.New)\n+\t\t}\n+\t\ti.replace[r.Old] = r.New\n \t}\n \n-\tif err := renameio.WriteFile(file, new, 0666); err != nil {\n-\t\tbase.Fatalf(\"error writing go.mod: %v\", err)\n+\ti.exclude = make(map[module.Version]bool, len(modFile.Exclude))\n+\tfor _, x := range modFile.Exclude {\n+\t\ti.exclude[x.Mod] = true\n \t}\n-\tmodFileData = new\n+\n+\treturn i\n }\n \n-func fixVersion(path, vers string) (string, error) {\n-\t// Special case: remove the old -gopkgin- hack.\n-\tif strings.HasPrefix(path, \"gopkg.in/\") && strings.Contains(vers, \"-gopkgin-\") {\n-\t\tvers = vers[strings.Index(vers, \"-gopkgin-\")+len(\"-gopkgin-\"):]\n+// modFileIsDirty reports whether the go.mod file differs meaningfully\n+// from what was indexed.\n+// If modFile has been changed (even cosmetically) since it was first read,\n+// modFile.Cleanup must be called before modFileIsDirty.\n+func (i *modFileIndex) modFileIsDirty(modFile *modfile.File) bool {\n+\tif i == nil {\n+\t\treturn modFile != nil\n+\t}\n+\n+\tif i.dataNeedsFix {\n+\t\treturn true\n \t}\n \n-\t// fixVersion is called speculatively on every\n-\t// module, version pair from every go.mod file.\n-\t// Avoid the query if it looks OK.\n-\t_, pathMajor, ok := module.SplitPathVersion(path)\n-\tif !ok {\n-\t\treturn \"\", &module.ModuleError{\n-\t\t\tPath: path,\n-\t\t\tErr: &module.InvalidVersionError{\n-\t\t\t\tVersion: vers,\n-\t\t\t\tErr:     fmt.Errorf(\"malformed module path %q\", path),\n-\t\t\t},\n+\tif modFile.Module == nil {\n+\t\tif i.module != (module.Version{}) {\n+\t\t\treturn true\n \t\t}\n+\t} else if modFile.Module.Mod != i.module {\n+\t\treturn true\n \t}\n-\tif vers != \"\" && module.CanonicalVersion(vers) == vers {\n-\t\tif err := module.MatchPathMajor(vers, pathMajor); err == nil {\n-\t\t\treturn vers, nil\n+\n+\tif modFile.Go == nil {\n+\t\tif i.goVersion != \"\" {\n+\t\t\treturn true\n+\t\t}\n+\t} else if modFile.Go.Version != i.goVersion {\n+\t\tif i.goVersion == \"\" && cfg.BuildMod == \"readonly\" {\n+\t\t\t// go.mod files did not always require a 'go' version, so do not error out\n+\t\t\t// if one is missing \u2014 we may be inside an older module in the module\n+\t\t\t// cache, and should bias toward providing useful behavior.\n+\t\t} else {\n+\t\t\treturn true\n \t\t}\n \t}\n \n-\tinfo, err := Query(path, vers, \"\", nil)\n-\tif err != nil {\n-\t\treturn \"\", err\n+\tif len(modFile.Require) != len(i.require) ||\n+\t\tlen(modFile.Replace) != len(i.replace) ||\n+\t\tlen(modFile.Exclude) != len(i.exclude) {\n+\t\treturn true\n+\t}\n+\n+\tfor _, r := range modFile.Require {\n+\t\tif meta, ok := i.require[r.Mod]; !ok {\n+\t\t\treturn true\n+\t\t} else if r.Indirect != meta.indirect {\n+\t\t\tif cfg.BuildMod == \"readonly\" {\n+\t\t\t\t// The module's requirements are consistent; only the \"// indirect\"\n+\t\t\t\t// comments that are wrong. But those are only guaranteed to be accurate\n+\t\t\t\t// after a \"go mod tidy\" \u2014 it's a good idea to run those before\n+\t\t\t\t// committing a change, but it's certainly not mandatory.\n+\t\t\t} else {\n+\t\t\t\treturn true\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tfor _, r := range modFile.Replace {\n+\t\tif r.New != i.replace[r.Old] {\n+\t\t\treturn true\n+\t\t}\n \t}\n-\treturn info.Version, nil\n+\n+\tfor _, x := range modFile.Exclude {\n+\t\tif !i.exclude[x.Mod] {\n+\t\t\treturn true\n+\t\t}\n+\t}\n+\n+\treturn false\n }"}, {"sha": "9400793bcb253b3e7547ea7e6773b22f9d3c4bfb", "filename": "libgo/go/cmd/go/internal/modload/list.go", "status": "modified", "additions": 20, "deletions": 5, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Flist.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -11,10 +11,12 @@ import (\n \t\"strings\"\n \n \t\"cmd/go/internal/base\"\n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modinfo\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n func ListModules(args []string, listU, listVersions bool) []*modinfo.ModulePublic {\n@@ -55,6 +57,9 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\tif search.IsRelativePath(arg) {\n \t\t\tbase.Fatalf(\"go: cannot use relative path %s to specify module\", arg)\n \t\t}\n+\t\tif !HasModRoot() && (arg == \"all\" || strings.Contains(arg, \"...\")) {\n+\t\t\tbase.Fatalf(\"go: cannot match %q: working directory is not part of a module\", arg)\n+\t\t}\n \t\tif i := strings.Index(arg, \"@\"); i >= 0 {\n \t\t\tpath := arg[:i]\n \t\t\tvers := arg[i+1:]\n@@ -121,10 +126,20 @@ func listModules(args []string, listVersions bool) []*modinfo.ModulePublic {\n \t\t\t\t\t}\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n-\t\t\t\t\tPath:  arg,\n-\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"not a known dependency\")),\n-\t\t\t\t})\n+\t\t\t\tif cfg.BuildMod == \"vendor\" {\n+\t\t\t\t\t// In vendor mode, we can't determine whether a missing module is \u201ca\n+\t\t\t\t\t// known dependency\u201d because the module graph is incomplete.\n+\t\t\t\t\t// Give a more explicit error message.\n+\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n+\t\t\t\t\t\tPath:  arg,\n+\t\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"can't resolve module using the vendor directory\\n\\t(Use -mod=mod or -mod=readonly to bypass.)\")),\n+\t\t\t\t\t})\n+\t\t\t\t} else {\n+\t\t\t\t\tmods = append(mods, &modinfo.ModulePublic{\n+\t\t\t\t\t\tPath:  arg,\n+\t\t\t\t\t\tError: modinfoError(arg, \"\", errors.New(\"not a known dependency\")),\n+\t\t\t\t\t})\n+\t\t\t\t}\n \t\t\t} else {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"warning: pattern %q matched no module dependencies\\n\", arg)\n \t\t\t}"}, {"sha": "408c79022b4abcd2ee7b3c0227b38448fcb4dddb", "filename": "libgo/go/cmd/go/internal/modload/load.go", "status": "modified", "additions": 167, "deletions": 62, "changes": 229, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fload.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -22,13 +22,14 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/modfile\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/mvs\"\n \t\"cmd/go/internal/par\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/semver\"\n \t\"cmd/go/internal/str\"\n+\n+\t\"golang.org/x/mod/modfile\"\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n // buildList is the list of modules to use for building packages.\n@@ -93,11 +94,11 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t\t\tpkgs := m.Pkgs\n \t\t\t\tm.Pkgs = m.Pkgs[:0]\n \t\t\t\tfor _, pkg := range pkgs {\n-\t\t\t\t\tdir := pkg\n-\t\t\t\t\tif !filepath.IsAbs(dir) {\n-\t\t\t\t\t\tdir = filepath.Join(cwd, pkg)\n+\t\t\t\t\tvar dir string\n+\t\t\t\t\tif !filepath.IsAbs(pkg) {\n+\t\t\t\t\t\tdir = filepath.Join(base.Cwd, pkg)\n \t\t\t\t\t} else {\n-\t\t\t\t\t\tdir = filepath.Clean(dir)\n+\t\t\t\t\t\tdir = filepath.Clean(pkg)\n \t\t\t\t\t}\n \n \t\t\t\t\t// golang.org/issue/32917: We should resolve a relative path to a\n@@ -211,11 +212,17 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \n \t// One last pass to finalize wildcards.\n \tupdateMatches(matches, false)\n+\tcheckMultiplePaths()\n+\tWriteGoMod()\n+\n+\treturn matches\n+}\n \n-\t// A given module path may be used as itself or as a replacement for another\n-\t// module, but not both at the same time. Otherwise, the aliasing behavior is\n-\t// too subtle (see https://golang.org/issue/26607), and we don't want to\n-\t// commit to a specific behavior at this point.\n+// checkMultiplePaths verifies that a given module path is used as itself\n+// or as a replacement for another module, but not both at the same time.\n+//\n+// (See https://golang.org/issue/26607 and https://golang.org/issue/34650.)\n+func checkMultiplePaths() {\n \tfirstPath := make(map[module.Version]string, len(buildList))\n \tfor _, mod := range buildList {\n \t\tsrc := mod\n@@ -229,9 +236,6 @@ func ImportPathsQuiet(patterns []string, tags map[string]bool) []*search.Match {\n \t\t}\n \t}\n \tbase.ExitIfErrors()\n-\tWriteGoMod()\n-\n-\treturn matches\n }\n \n // pathInModuleCache returns the import path of the directory dir,\n@@ -318,7 +322,7 @@ func DirImportPath(dir string) string {\n \t}\n \n \tif !filepath.IsAbs(dir) {\n-\t\tdir = filepath.Join(cwd, dir)\n+\t\tdir = filepath.Join(base.Cwd, dir)\n \t} else {\n \t\tdir = filepath.Clean(dir)\n \t}\n@@ -383,6 +387,7 @@ func loadAll(testAll bool) []string {\n \t}\n \tall := TargetPackages(\"...\")\n \tloaded.load(func() []string { return all })\n+\tcheckMultiplePaths()\n \tWriteGoMod()\n \n \tvar paths []string\n@@ -401,6 +406,10 @@ func loadAll(testAll bool) []string {\n // matching pattern, which may be relative to the working directory, under all\n // build tag settings.\n func TargetPackages(pattern string) []string {\n+\t// TargetPackages is relative to the main module, so ensure that the main\n+\t// module is a thing that can contain packages.\n+\tModRoot()\n+\n \treturn matchPackages(pattern, imports.AnyTags(), false, []module.Version{Target})\n }\n \n@@ -419,6 +428,37 @@ func SetBuildList(list []module.Version) {\n \tbuildList = append([]module.Version{}, list...)\n }\n \n+// TidyBuildList trims the build list to the minimal requirements needed to\n+// retain the same versions of all packages from the preceding Load* or\n+// ImportPaths* call.\n+func TidyBuildList() {\n+\tused := map[module.Version]bool{Target: true}\n+\tfor _, pkg := range loaded.pkgs {\n+\t\tused[pkg.mod] = true\n+\t}\n+\n+\tkeep := []module.Version{Target}\n+\tvar direct []string\n+\tfor _, m := range buildList[1:] {\n+\t\tif used[m] {\n+\t\t\tkeep = append(keep, m)\n+\t\t\tif loaded.direct[m.Path] {\n+\t\t\t\tdirect = append(direct, m.Path)\n+\t\t\t}\n+\t\t} else if cfg.BuildV {\n+\t\t\tif _, ok := index.require[m]; ok {\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"unused %s\\n\", m.Path)\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tmin, err := mvs.Req(Target, direct, &mvsReqs{buildList: keep})\n+\tif err != nil {\n+\t\tbase.Fatalf(\"go: %v\", err)\n+\t}\n+\tbuildList = append([]module.Version{Target}, min...)\n+}\n+\n // ImportMap returns the actual package import path\n // for an import path found in source code.\n // If the given import path does not appear in the source code\n@@ -621,6 +661,7 @@ func (ld *loader) load(roots func() []string) {\n \t\t\t\tadded[pkg.path] = true\n \t\t\t\tnumAdded++\n \t\t\t\tif !haveMod[err.Module] {\n+\t\t\t\t\tfmt.Fprintf(os.Stderr, \"go: found %s in %s %s\\n\", pkg.path, err.Module.Path, err.Module.Version)\n \t\t\t\t\thaveMod[err.Module] = true\n \t\t\t\t\tmodAddedBy[err.Module] = pkg\n \t\t\t\t\tbuildList = append(buildList, err.Module)\n@@ -960,21 +1001,15 @@ func WhyDepth(path string) int {\n // If there is no replacement for mod, Replacement returns\n // a module.Version with Path == \"\".\n func Replacement(mod module.Version) module.Version {\n-\tif modFile == nil {\n-\t\t// Happens during testing and if invoking 'go get' or 'go list' outside a module.\n-\t\treturn module.Version{}\n-\t}\n-\n-\tvar found *modfile.Replace\n-\tfor _, r := range modFile.Replace {\n-\t\tif r.Old.Path == mod.Path && (r.Old.Version == \"\" || r.Old.Version == mod.Version) {\n-\t\t\tfound = r // keep going\n+\tif index != nil {\n+\t\tif r, ok := index.replace[mod]; ok {\n+\t\t\treturn r\n+\t\t}\n+\t\tif r, ok := index.replace[module.Version{Path: mod.Path}]; ok {\n+\t\t\treturn r\n \t\t}\n \t}\n-\tif found == nil {\n-\t\treturn module.Version{}\n-\t}\n-\treturn found.New\n+\treturn module.Version{}\n }\n \n // mvsReqs implements mvs.Reqs for module semantic versions,\n@@ -1007,15 +1042,17 @@ func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n \t\t\treturn cached{nil, err}\n \t\t}\n \t\tfor i, mv := range list {\n-\t\t\tfor excluded[mv] {\n-\t\t\t\tmv1, err := r.next(mv)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\treturn cached{nil, err}\n-\t\t\t\t}\n-\t\t\t\tif mv1.Version == \"none\" {\n-\t\t\t\t\treturn cached{nil, fmt.Errorf(\"%s(%s) depends on excluded %s(%s) with no newer version available\", mod.Path, mod.Version, mv.Path, mv.Version)}\n+\t\t\tif index != nil {\n+\t\t\t\tfor index.exclude[mv] {\n+\t\t\t\t\tmv1, err := r.next(mv)\n+\t\t\t\t\tif err != nil {\n+\t\t\t\t\t\treturn cached{nil, err}\n+\t\t\t\t\t}\n+\t\t\t\t\tif mv1.Version == \"none\" {\n+\t\t\t\t\t\treturn cached{nil, fmt.Errorf(\"%s(%s) depends on excluded %s(%s) with no newer version available\", mod.Path, mod.Version, mv.Path, mv.Version)}\n+\t\t\t\t\t}\n+\t\t\t\t\tmv = mv1\n \t\t\t\t}\n-\t\t\t\tmv = mv1\n \t\t\t}\n \t\t\tlist[i] = mv\n \t\t}\n@@ -1028,30 +1065,106 @@ func (r *mvsReqs) Required(mod module.Version) ([]module.Version, error) {\n \n var vendorOnce sync.Once\n \n+type vendorMetadata struct {\n+\tExplicit    bool\n+\tReplacement module.Version\n+}\n+\n var (\n-\tvendorList []module.Version\n-\tvendorMap  map[string]module.Version\n+\tvendorList      []module.Version          // modules that contribute packages to the build, in order of appearance\n+\tvendorReplaced  []module.Version          // all replaced modules; may or may not also contribute packages\n+\tvendorVersion   map[string]string         // module path \u2192 selected version (if known)\n+\tvendorPkgModule map[string]module.Version // package \u2192 containing module\n+\tvendorMeta      map[module.Version]vendorMetadata\n )\n \n // readVendorList reads the list of vendored modules from vendor/modules.txt.\n func readVendorList() {\n \tvendorOnce.Do(func() {\n \t\tvendorList = nil\n-\t\tvendorMap = make(map[string]module.Version)\n-\t\tdata, _ := ioutil.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n-\t\tvar m module.Version\n+\t\tvendorPkgModule = make(map[string]module.Version)\n+\t\tvendorVersion = make(map[string]string)\n+\t\tvendorMeta = make(map[module.Version]vendorMetadata)\n+\t\tdata, err := ioutil.ReadFile(filepath.Join(ModRoot(), \"vendor/modules.txt\"))\n+\t\tif err != nil {\n+\t\t\tif !errors.Is(err, os.ErrNotExist) {\n+\t\t\t\tbase.Fatalf(\"go: %s\", err)\n+\t\t\t}\n+\t\t\treturn\n+\t\t}\n+\n+\t\tvar mod module.Version\n \t\tfor _, line := range strings.Split(string(data), \"\\n\") {\n \t\t\tif strings.HasPrefix(line, \"# \") {\n \t\t\t\tf := strings.Fields(line)\n-\t\t\t\tm = module.Version{}\n-\t\t\t\tif len(f) == 3 && semver.IsValid(f[2]) {\n-\t\t\t\t\tm = module.Version{Path: f[1], Version: f[2]}\n-\t\t\t\t\tvendorList = append(vendorList, m)\n+\n+\t\t\t\tif len(f) < 3 {\n+\t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t} else if m.Path != \"\" {\n-\t\t\t\tf := strings.Fields(line)\n-\t\t\t\tif len(f) == 1 {\n-\t\t\t\t\tvendorMap[f[0]] = m\n+\t\t\t\tif semver.IsValid(f[2]) {\n+\t\t\t\t\t// A module, but we don't yet know whether it is in the build list or\n+\t\t\t\t\t// only included to indicate a replacement.\n+\t\t\t\t\tmod = module.Version{Path: f[1], Version: f[2]}\n+\t\t\t\t\tf = f[3:]\n+\t\t\t\t} else if f[2] == \"=>\" {\n+\t\t\t\t\t// A wildcard replacement found in the main module's go.mod file.\n+\t\t\t\t\tmod = module.Version{Path: f[1]}\n+\t\t\t\t\tf = f[2:]\n+\t\t\t\t} else {\n+\t\t\t\t\t// Not a version or a wildcard replacement.\n+\t\t\t\t\t// We don't know how to interpret this module line, so ignore it.\n+\t\t\t\t\tmod = module.Version{}\n+\t\t\t\t\tcontinue\n+\t\t\t\t}\n+\n+\t\t\t\tif len(f) >= 2 && f[0] == \"=>\" {\n+\t\t\t\t\tmeta := vendorMeta[mod]\n+\t\t\t\t\tif len(f) == 2 {\n+\t\t\t\t\t\t// File replacement.\n+\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1]}\n+\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n+\t\t\t\t\t} else if len(f) == 3 && semver.IsValid(f[2]) {\n+\t\t\t\t\t\t// Path and version replacement.\n+\t\t\t\t\t\tmeta.Replacement = module.Version{Path: f[1], Version: f[2]}\n+\t\t\t\t\t\tvendorReplaced = append(vendorReplaced, mod)\n+\t\t\t\t\t} else {\n+\t\t\t\t\t\t// We don't understand this replacement. Ignore it.\n+\t\t\t\t\t}\n+\t\t\t\t\tvendorMeta[mod] = meta\n+\t\t\t\t}\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\t// Not a module line. Must be a package within a module or a metadata\n+\t\t\t// directive, either of which requires a preceding module line.\n+\t\t\tif mod.Path == \"\" {\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif strings.HasPrefix(line, \"## \") {\n+\t\t\t\t// Metadata. Take the union of annotations across multiple lines, if present.\n+\t\t\t\tmeta := vendorMeta[mod]\n+\t\t\t\tfor _, entry := range strings.Split(strings.TrimPrefix(line, \"## \"), \";\") {\n+\t\t\t\t\tentry = strings.TrimSpace(entry)\n+\t\t\t\t\tif entry == \"explicit\" {\n+\t\t\t\t\t\tmeta.Explicit = true\n+\t\t\t\t\t}\n+\t\t\t\t\t// All other tokens are reserved for future use.\n+\t\t\t\t}\n+\t\t\t\tvendorMeta[mod] = meta\n+\t\t\t\tcontinue\n+\t\t\t}\n+\n+\t\t\tif f := strings.Fields(line); len(f) == 1 && module.CheckImportPath(f[0]) == nil {\n+\t\t\t\t// A package within the current module.\n+\t\t\t\tvendorPkgModule[f[0]] = mod\n+\n+\t\t\t\t// Since this module provides a package for the build, we know that it\n+\t\t\t\t// is in the build list and is the selected version of its path.\n+\t\t\t\t// If this information is new, record it.\n+\t\t\t\tif v, ok := vendorVersion[mod.Path]; !ok || semver.Compare(v, mod.Version) < 0 {\n+\t\t\t\t\tvendorList = append(vendorList, mod)\n+\t\t\t\t\tvendorVersion[mod.Path] = mod.Version\n \t\t\t\t}\n \t\t\t}\n \t\t}\n@@ -1082,19 +1195,6 @@ func (r *mvsReqs) required(mod module.Version) ([]module.Version, error) {\n \t\treturn append([]module.Version(nil), vendorList...), nil\n \t}\n \n-\tif targetInGorootSrc {\n-\t\t// When inside \"std\" or \"cmd\", only fetch and read go.mod files if we're\n-\t\t// explicitly running a command that can change the module graph. If we have\n-\t\t// to resolve a new dependency, we might pick the wrong version, but 'go mod\n-\t\t// tidy' will fix it \u2014 and new standard-library dependencies should be rare\n-\t\t// anyway.\n-\t\t//\n-\t\t// TODO(golang.org/issue/30240): Drop this special-case.\n-\t\tif cfg.CmdName != \"get\" && !strings.HasPrefix(cfg.CmdName, \"mod \") {\n-\t\t\treturn nil, nil\n-\t\t}\n-\t}\n-\n \torigPath := mod.Path\n \tif repl := Replacement(mod); repl.Path != \"\" {\n \t\tif repl.Version == \"\" {\n@@ -1209,6 +1309,11 @@ func (*mvsReqs) next(m module.Version) (module.Version, error) {\n \treturn module.Version{Path: m.Path, Version: \"none\"}, nil\n }\n \n+// fetch downloads the given module (or its replacement)\n+// and returns its location.\n+//\n+// The isLocal return value reports whether the replacement,\n+// if any, is local to the filesystem.\n func fetch(mod module.Version) (dir string, isLocal bool, err error) {\n \tif mod == Target {\n \t\treturn ModRoot(), true, nil"}, {"sha": "53278b91002043bfd0c5038798996fb9cad99de9", "filename": "libgo/go/cmd/go/internal/modload/query.go", "status": "modified", "additions": 147, "deletions": 34, "changes": 181, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -9,15 +9,18 @@ import (\n \t\"fmt\"\n \t\"os\"\n \tpathpkg \"path\"\n+\t\"path/filepath\"\n \t\"strings\"\n \t\"sync\"\n \n+\t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n \t\"cmd/go/internal/modfetch\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/search\"\n-\t\"cmd/go/internal/semver\"\n \t\"cmd/go/internal/str\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n )\n \n // Query looks up a revision of a given module given a version query string.\n@@ -61,10 +64,24 @@ func Query(path, query, current string, allowed func(module.Version) bool) (*mod\n \treturn info, err\n }\n \n+var errQueryDisabled error = queryDisabledError{}\n+\n+type queryDisabledError struct{}\n+\n+func (queryDisabledError) Error() string {\n+\tif cfg.BuildModReason == \"\" {\n+\t\treturn fmt.Sprintf(\"cannot query module due to -mod=%s\", cfg.BuildMod)\n+\t}\n+\treturn fmt.Sprintf(\"cannot query module due to -mod=%s\\n\\t(%s)\", cfg.BuildMod, cfg.BuildModReason)\n+}\n+\n func queryProxy(proxy, path, query, current string, allowed func(module.Version) bool) (*modfetch.RevInfo, error) {\n \tif current != \"\" && !semver.IsValid(current) {\n \t\treturn nil, fmt.Errorf(\"invalid previous version %q\", current)\n \t}\n+\tif cfg.BuildMod != \"\" && cfg.BuildMod != \"mod\" {\n+\t\treturn nil, errQueryDisabled\n+\t}\n \tif allowed == nil {\n \t\tallowed = func(module.Version) bool { return true }\n \t}\n@@ -74,10 +91,20 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \tbadVersion := func(v string) (*modfetch.RevInfo, error) {\n \t\treturn nil, fmt.Errorf(\"invalid semantic version %q in range %q\", v, query)\n \t}\n-\tvar ok func(module.Version) bool\n-\tvar prefix string\n-\tvar preferOlder bool\n-\tvar mayUseLatest bool\n+\tmatchesMajor := func(v string) bool {\n+\t\t_, pathMajor, ok := module.SplitPathVersion(path)\n+\t\tif !ok {\n+\t\t\treturn false\n+\t\t}\n+\t\treturn module.CheckPathMajor(v, pathMajor) == nil\n+\t}\n+\tvar (\n+\t\tok                 func(module.Version) bool\n+\t\tprefix             string\n+\t\tpreferOlder        bool\n+\t\tmayUseLatest       bool\n+\t\tpreferIncompatible bool = strings.HasSuffix(current, \"+incompatible\")\n+\t)\n \tswitch {\n \tcase query == \"latest\":\n \t\tok = allowed\n@@ -110,6 +137,9 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\tok = func(m module.Version) bool {\n \t\t\treturn semver.Compare(m.Version, v) <= 0 && allowed(m)\n \t\t}\n+\t\tif !matchesMajor(v) {\n+\t\t\tpreferIncompatible = true\n+\t\t}\n \n \tcase strings.HasPrefix(query, \"<\"):\n \t\tv := query[len(\"<\"):]\n@@ -119,6 +149,9 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\tok = func(m module.Version) bool {\n \t\t\treturn semver.Compare(m.Version, v) < 0 && allowed(m)\n \t\t}\n+\t\tif !matchesMajor(v) {\n+\t\t\tpreferIncompatible = true\n+\t\t}\n \n \tcase strings.HasPrefix(query, \">=\"):\n \t\tv := query[len(\">=\"):]\n@@ -129,6 +162,9 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\t\treturn semver.Compare(m.Version, v) >= 0 && allowed(m)\n \t\t}\n \t\tpreferOlder = true\n+\t\tif !matchesMajor(v) {\n+\t\t\tpreferIncompatible = true\n+\t\t}\n \n \tcase strings.HasPrefix(query, \">\"):\n \t\tv := query[len(\">\"):]\n@@ -143,12 +179,18 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t\t\treturn semver.Compare(m.Version, v) > 0 && allowed(m)\n \t\t}\n \t\tpreferOlder = true\n+\t\tif !matchesMajor(v) {\n+\t\t\tpreferIncompatible = true\n+\t\t}\n \n \tcase semver.IsValid(query) && isSemverPrefix(query):\n \t\tok = func(m module.Version) bool {\n \t\t\treturn matchSemverPrefix(query, m.Version) && allowed(m)\n \t\t}\n \t\tprefix = query + \".\"\n+\t\tif !matchesMajor(query) {\n+\t\t\tpreferIncompatible = true\n+\t\t}\n \n \tdefault:\n \t\t// Direct lookup of semantic version or commit identifier.\n@@ -201,6 +243,10 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n+\treleases, prereleases, err := filterVersions(path, versions, ok, preferIncompatible)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n \n \tlookup := func(v string) (*modfetch.RevInfo, error) {\n \t\trev, err := repo.Stat(v)\n@@ -221,28 +267,18 @@ func queryProxy(proxy, path, query, current string, allowed func(module.Version)\n \t}\n \n \tif preferOlder {\n-\t\tfor _, v := range versions {\n-\t\t\tif semver.Prerelease(v) == \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn lookup(v)\n-\t\t\t}\n+\t\tif len(releases) > 0 {\n+\t\t\treturn lookup(releases[0])\n \t\t}\n-\t\tfor _, v := range versions {\n-\t\t\tif semver.Prerelease(v) != \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn lookup(v)\n-\t\t\t}\n+\t\tif len(prereleases) > 0 {\n+\t\t\treturn lookup(prereleases[0])\n \t\t}\n \t} else {\n-\t\tfor i := len(versions) - 1; i >= 0; i-- {\n-\t\t\tv := versions[i]\n-\t\t\tif semver.Prerelease(v) == \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn lookup(v)\n-\t\t\t}\n+\t\tif len(releases) > 0 {\n+\t\t\treturn lookup(releases[len(releases)-1])\n \t\t}\n-\t\tfor i := len(versions) - 1; i >= 0; i-- {\n-\t\t\tv := versions[i]\n-\t\t\tif semver.Prerelease(v) != \"\" && ok(module.Version{Path: path, Version: v}) {\n-\t\t\t\treturn lookup(v)\n-\t\t\t}\n+\t\tif len(prereleases) > 0 {\n+\t\t\treturn lookup(prereleases[len(prereleases)-1])\n \t\t}\n \t}\n \n@@ -286,6 +322,52 @@ func matchSemverPrefix(p, v string) bool {\n \treturn len(v) > len(p) && v[len(p)] == '.' && v[:len(p)] == p && semver.Prerelease(v) == \"\"\n }\n \n+// filterVersions classifies versions into releases and pre-releases, filtering\n+// out:\n+// \t1. versions that do not satisfy the 'ok' predicate, and\n+// \t2. \"+incompatible\" versions, if a compatible one satisfies the predicate\n+// \t   and the incompatible version is not preferred.\n+func filterVersions(path string, versions []string, ok func(module.Version) bool, preferIncompatible bool) (releases, prereleases []string, err error) {\n+\tvar lastCompatible string\n+\tfor _, v := range versions {\n+\t\tif !ok(module.Version{Path: path, Version: v}) {\n+\t\t\tcontinue\n+\t\t}\n+\n+\t\tif !preferIncompatible {\n+\t\t\tif !strings.HasSuffix(v, \"+incompatible\") {\n+\t\t\t\tlastCompatible = v\n+\t\t\t} else if lastCompatible != \"\" {\n+\t\t\t\t// If the latest compatible version is allowed and has a go.mod file,\n+\t\t\t\t// ignore any version with a higher (+incompatible) major version. (See\n+\t\t\t\t// https://golang.org/issue/34165.) Note that we even prefer a\n+\t\t\t\t// compatible pre-release over an incompatible release.\n+\n+\t\t\t\tok, err := versionHasGoMod(module.Version{Path: path, Version: lastCompatible})\n+\t\t\t\tif err != nil {\n+\t\t\t\t\treturn nil, nil, err\n+\t\t\t\t}\n+\t\t\t\tif ok {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\n+\t\t\t\t// No acceptable compatible release has a go.mod file, so the versioning\n+\t\t\t\t// for the module might not be module-aware, and we should respect\n+\t\t\t\t// legacy major-version tags.\n+\t\t\t\tpreferIncompatible = true\n+\t\t\t}\n+\t\t}\n+\n+\t\tif semver.Prerelease(v) != \"\" {\n+\t\t\tprereleases = append(prereleases, v)\n+\t\t} else {\n+\t\t\treleases = append(releases, v)\n+\t\t}\n+\t}\n+\n+\treturn releases, prereleases, nil\n+}\n+\n type QueryResult struct {\n \tMod      module.Version\n \tRev      *modfetch.RevInfo\n@@ -381,9 +463,10 @@ func QueryPattern(pattern, query string, allowed func(module.Version) bool) ([]Q\n \t\t\tr.Packages = match(r.Mod, root, isLocal)\n \t\t\tif len(r.Packages) == 0 {\n \t\t\t\treturn r, &PackageNotInModuleError{\n-\t\t\t\t\tMod:     r.Mod,\n-\t\t\t\t\tQuery:   query,\n-\t\t\t\t\tPattern: pattern,\n+\t\t\t\t\tMod:         r.Mod,\n+\t\t\t\t\tReplacement: Replacement(r.Mod),\n+\t\t\t\t\tQuery:       query,\n+\t\t\t\t\tPattern:     pattern,\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn r, nil\n@@ -471,7 +554,17 @@ func queryPrefixModules(candidateModules []string, queryModule func(path string)\n \t\t\t\t\tnotExistErr = rErr\n \t\t\t\t}\n \t\t\t} else if err == nil {\n-\t\t\t\terr = r.err\n+\t\t\t\tif len(found) > 0 || noPackage != nil {\n+\t\t\t\t\t// golang.org/issue/34094: If we have already found a module that\n+\t\t\t\t\t// could potentially contain the target package, ignore unclassified\n+\t\t\t\t\t// errors for modules with shorter paths.\n+\n+\t\t\t\t\t// golang.org/issue/34383 is a special case of this: if we have\n+\t\t\t\t\t// already found example.com/foo/v2@v2.0.0 with a matching go.mod\n+\t\t\t\t\t// file, ignore the error from example.com/foo@v2.0.0.\n+\t\t\t\t} else {\n+\t\t\t\t\terr = r.err\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -526,21 +619,32 @@ func (e *NoMatchingVersionError) Error() string {\n // code for the versions it knows about, and thus did not have the opportunity\n // to return a non-400 status code to suppress fallback.\n type PackageNotInModuleError struct {\n-\tMod     module.Version\n-\tQuery   string\n-\tPattern string\n+\tMod         module.Version\n+\tReplacement module.Version\n+\tQuery       string\n+\tPattern     string\n }\n \n func (e *PackageNotInModuleError) Error() string {\n \tfound := \"\"\n-\tif e.Query != e.Mod.Version {\n+\tif r := e.Replacement; r.Path != \"\" {\n+\t\treplacement := r.Path\n+\t\tif r.Version != \"\" {\n+\t\t\treplacement = fmt.Sprintf(\"%s@%s\", r.Path, r.Version)\n+\t\t}\n+\t\tif e.Query == e.Mod.Version {\n+\t\t\tfound = fmt.Sprintf(\" (replaced by %s)\", replacement)\n+\t\t} else {\n+\t\t\tfound = fmt.Sprintf(\" (%s, replaced by %s)\", e.Mod.Version, replacement)\n+\t\t}\n+\t} else if e.Query != e.Mod.Version {\n \t\tfound = fmt.Sprintf(\" (%s)\", e.Mod.Version)\n \t}\n \n \tif strings.Contains(e.Pattern, \"...\") {\n-\t\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain packages matching %s\", e.Mod.Path, e.Query, found, e.Pattern)\n+\t\treturn fmt.Sprintf(\"module %s@%s found%s, but does not contain packages matching %s\", e.Mod.Path, e.Query, found, e.Pattern)\n \t}\n-\treturn fmt.Sprintf(\"module %s@%s%s found, but does not contain package %s\", e.Mod.Path, e.Query, found, e.Pattern)\n+\treturn fmt.Sprintf(\"module %s@%s found%s, but does not contain package %s\", e.Mod.Path, e.Query, found, e.Pattern)\n }\n \n // ModuleHasRootPackage returns whether module m contains a package m.Path.\n@@ -552,3 +656,12 @@ func ModuleHasRootPackage(m module.Version) (bool, error) {\n \t_, ok := dirInModule(m.Path, m.Path, root, isLocal)\n \treturn ok, nil\n }\n+\n+func versionHasGoMod(m module.Version) (bool, error) {\n+\troot, _, err := fetch(m)\n+\tif err != nil {\n+\t\treturn false, err\n+\t}\n+\tfi, err := os.Stat(filepath.Join(root, \"go.mod\"))\n+\treturn err == nil && !fi.IsDir(), nil\n+}"}, {"sha": "9c91c05e5f821442950b8f24473b42c78e246643", "filename": "libgo/go/cmd/go/internal/modload/query_test.go", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fquery_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -17,7 +17,8 @@ import (\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n func TestMain(m *testing.M) {"}, {"sha": "a303f51858a6e0d06ce5f8baa9c563ec4ea8e29c", "filename": "libgo/go/cmd/go/internal/modload/search.go", "status": "modified", "additions": 15, "deletions": 10, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fsearch.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -13,8 +13,9 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cfg\"\n \t\"cmd/go/internal/imports\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/search\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n // matchPackages returns a list of packages in the list of modules\n@@ -48,16 +49,20 @@ func matchPackages(pattern string, tags map[string]bool, useStd bool, modules []\n \t\t\t\treturn nil\n \t\t\t}\n \n-\t\t\t// Don't use GOROOT/src but do walk down into it.\n-\t\t\tif path == root && importPathRoot == \"\" {\n-\t\t\t\treturn nil\n-\t\t\t}\n-\n \t\t\twant := true\n-\t\t\t// Avoid .foo, _foo, and testdata directory trees.\n-\t\t\t_, elem := filepath.Split(path)\n-\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n-\t\t\t\twant = false\n+\t\t\telem := \"\"\n+\n+\t\t\t// Don't use GOROOT/src but do walk down into it.\n+\t\t\tif path == root {\n+\t\t\t\tif importPathRoot == \"\" {\n+\t\t\t\t\treturn nil\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\t// Avoid .foo, _foo, and testdata subdirectory trees.\n+\t\t\t\t_, elem = filepath.Split(path)\n+\t\t\t\tif strings.HasPrefix(elem, \".\") || strings.HasPrefix(elem, \"_\") || elem == \"testdata\" {\n+\t\t\t\t\twant = false\n+\t\t\t\t}\n \t\t\t}\n \n \t\t\tname := importPathRoot + filepath.ToSlash(path[len(root):])"}, {"sha": "931aaf1577bf2535c46f8f0a66b1552eea8a3e18", "filename": "libgo/go/cmd/go/internal/modload/stat_openfile.go", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_openfile.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,27 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build aix js,wasm plan9\n+\n+// On plan9, per http://9p.io/magic/man2html/2/access: \u201cSince file permissions\n+// are checked by the server and group information is not known to the client,\n+// access must open the file to check permissions.\u201d\n+//\n+// aix and js,wasm are similar, in that they do not define syscall.Access.\n+\n+package modload\n+\n+import (\n+\t\"os\"\n+)\n+\n+// hasWritePerm reports whether the current user has permission to write to the\n+// file with the given info.\n+func hasWritePerm(path string, _ os.FileInfo) bool {\n+\tif f, err := os.OpenFile(path, os.O_WRONLY, 0); err == nil {\n+\t\tf.Close()\n+\t\treturn true\n+\t}\n+\treturn false\n+}"}, {"sha": "a53d17e93a8a67a3b42744f4a4d9f50ae3f220c8", "filename": "libgo/go/cmd/go/internal/modload/stat_unix.go", "status": "added", "additions": 31, "deletions": 0, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_unix.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,31 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build darwin dragonfly freebsd hurd linux netbsd openbsd solaris\n+\n+package modload\n+\n+import (\n+\t\"os\"\n+\t\"syscall\"\n+)\n+\n+// hasWritePerm reports whether the current user has permission to write to the\n+// file with the given info.\n+//\n+// Although the root user on most Unix systems can write to files even without\n+// permission, hasWritePerm reports false if no appropriate permission bit is\n+// set even if the current user is root.\n+func hasWritePerm(path string, fi os.FileInfo) bool {\n+\tif os.Getuid() == 0 {\n+\t\t// The root user can access any file, but we still want to default to\n+\t\t// read-only mode if the go.mod file is marked as globally non-writable.\n+\t\t// (If the user really intends not to be in readonly mode, they can\n+\t\t// pass -mod=mod explicitly.)\n+\t\treturn fi.Mode()&0222 != 0\n+\t}\n+\n+\tconst W_OK = 0x2\n+\treturn syscall.Access(path, W_OK) == nil\n+}"}, {"sha": "d7826cfc6b88152b158ed3304cb497c0b4e33dbc", "filename": "libgo/go/cmd/go/internal/modload/stat_windows.go", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Fstat_windows.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,23 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows\n+\n+package modload\n+\n+import (\n+\t\"os\"\n+)\n+\n+// hasWritePerm reports whether the current user has permission to write to the\n+// file with the given info.\n+func hasWritePerm(_ string, fi os.FileInfo) bool {\n+\t// Windows has a read-only attribute independent of ACLs, so use that to\n+\t// determine whether the file is intended to be overwritten.\n+\t//\n+\t// Per https://golang.org/pkg/os/#Chmod:\n+\t// \u201cOn Windows, only the 0200 bit (owner writable) of mode is used; it\n+\t// controls whether the file's read-only attribute is set or cleared.\u201d\n+\treturn fi.Mode()&0200 != 0\n+}"}, {"sha": "6b34f5be39367a381b3dc7a7b9fee49ed2c0ffc4", "filename": "libgo/go/cmd/go/internal/modload/testgo.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodload%2Ftestgo.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build testgo\n+// +build testgo\n \n package modload\n "}, {"sha": "b9f07bf57d549c6509d29d601c7f8d2fb33a41f6", "filename": "libgo/go/cmd/go/internal/module/module_test.go", "status": "removed", "additions": 0, "deletions": 319, "changes": 319, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmodule%2Fmodule_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,319 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package module\n-\n-import \"testing\"\n-\n-var checkTests = []struct {\n-\tpath    string\n-\tversion string\n-\tok      bool\n-}{\n-\t{\"rsc.io/quote\", \"0.1.0\", false},\n-\t{\"rsc io/quote\", \"v1.0.0\", false},\n-\n-\t{\"github.com/go-yaml/yaml\", \"v0.8.0\", true},\n-\t{\"github.com/go-yaml/yaml\", \"v1.0.0\", true},\n-\t{\"github.com/go-yaml/yaml\", \"v2.0.0\", false},\n-\t{\"github.com/go-yaml/yaml\", \"v2.1.5\", false},\n-\t{\"github.com/go-yaml/yaml\", \"v3.0.0\", false},\n-\n-\t{\"github.com/go-yaml/yaml/v2\", \"v1.0.0\", false},\n-\t{\"github.com/go-yaml/yaml/v2\", \"v2.0.0\", true},\n-\t{\"github.com/go-yaml/yaml/v2\", \"v2.1.5\", true},\n-\t{\"github.com/go-yaml/yaml/v2\", \"v3.0.0\", false},\n-\n-\t{\"gopkg.in/yaml.v0\", \"v0.8.0\", true},\n-\t{\"gopkg.in/yaml.v0\", \"v1.0.0\", false},\n-\t{\"gopkg.in/yaml.v0\", \"v2.0.0\", false},\n-\t{\"gopkg.in/yaml.v0\", \"v2.1.5\", false},\n-\t{\"gopkg.in/yaml.v0\", \"v3.0.0\", false},\n-\n-\t{\"gopkg.in/yaml.v1\", \"v0.8.0\", false},\n-\t{\"gopkg.in/yaml.v1\", \"v1.0.0\", true},\n-\t{\"gopkg.in/yaml.v1\", \"v2.0.0\", false},\n-\t{\"gopkg.in/yaml.v1\", \"v2.1.5\", false},\n-\t{\"gopkg.in/yaml.v1\", \"v3.0.0\", false},\n-\n-\t// For gopkg.in, .v1 means v1 only (not v0).\n-\t// But early versions of vgo still generated v0 pseudo-versions for it.\n-\t// Even though now we'd generate those as v1 pseudo-versions,\n-\t// we accept the old pseudo-versions to avoid breaking existing go.mod files.\n-\t// For example gopkg.in/yaml.v2@v2.2.1's go.mod requires check.v1 at a v0 pseudo-version.\n-\t{\"gopkg.in/check.v1\", \"v0.0.0\", false},\n-\t{\"gopkg.in/check.v1\", \"v0.0.0-20160102150405-abcdef123456\", true},\n-\n-\t{\"gopkg.in/yaml.v2\", \"v1.0.0\", false},\n-\t{\"gopkg.in/yaml.v2\", \"v2.0.0\", true},\n-\t{\"gopkg.in/yaml.v2\", \"v2.1.5\", true},\n-\t{\"gopkg.in/yaml.v2\", \"v3.0.0\", false},\n-\n-\t{\"rsc.io/quote\", \"v17.0.0\", false},\n-\t{\"rsc.io/quote\", \"v17.0.0+incompatible\", true},\n-}\n-\n-func TestCheck(t *testing.T) {\n-\tfor _, tt := range checkTests {\n-\t\terr := Check(tt.path, tt.version)\n-\t\tif tt.ok && err != nil {\n-\t\t\tt.Errorf(\"Check(%q, %q) = %v, wanted nil error\", tt.path, tt.version, err)\n-\t\t} else if !tt.ok && err == nil {\n-\t\t\tt.Errorf(\"Check(%q, %q) succeeded, wanted error\", tt.path, tt.version)\n-\t\t}\n-\t}\n-}\n-\n-var checkPathTests = []struct {\n-\tpath     string\n-\tok       bool\n-\timportOK bool\n-\tfileOK   bool\n-}{\n-\t{\"x.y/z\", true, true, true},\n-\t{\"x.y\", true, true, true},\n-\n-\t{\"\", false, false, false},\n-\t{\"x.y/\\xFFz\", false, false, false},\n-\t{\"/x.y/z\", false, false, false},\n-\t{\"x./z\", false, false, false},\n-\t{\".x/z\", false, false, true},\n-\t{\"-x/z\", false, false, false},\n-\t{\"x..y/z\", false, false, false},\n-\t{\"x.y/z/../../w\", false, false, false},\n-\t{\"x.y//z\", false, false, false},\n-\t{\"x.y/z//w\", false, false, false},\n-\t{\"x.y/z/\", false, false, false},\n-\n-\t{\"x.y/z/v0\", false, true, true},\n-\t{\"x.y/z/v1\", false, true, true},\n-\t{\"x.y/z/v2\", true, true, true},\n-\t{\"x.y/z/v2.0\", false, true, true},\n-\t{\"X.y/z\", false, true, true},\n-\n-\t{\"!x.y/z\", false, false, true},\n-\t{\"_x.y/z\", false, true, true},\n-\t{\"x.y!/z\", false, false, true},\n-\t{\"x.y\\\"/z\", false, false, false},\n-\t{\"x.y#/z\", false, false, true},\n-\t{\"x.y$/z\", false, false, true},\n-\t{\"x.y%/z\", false, false, true},\n-\t{\"x.y&/z\", false, false, true},\n-\t{\"x.y'/z\", false, false, false},\n-\t{\"x.y(/z\", false, false, true},\n-\t{\"x.y)/z\", false, false, true},\n-\t{\"x.y*/z\", false, false, false},\n-\t{\"x.y+/z\", false, true, true},\n-\t{\"x.y,/z\", false, false, true},\n-\t{\"x.y-/z\", true, true, true},\n-\t{\"x.y./zt\", false, false, false},\n-\t{\"x.y:/z\", false, false, false},\n-\t{\"x.y;/z\", false, false, false},\n-\t{\"x.y</z\", false, false, false},\n-\t{\"x.y=/z\", false, false, true},\n-\t{\"x.y>/z\", false, false, false},\n-\t{\"x.y?/z\", false, false, false},\n-\t{\"x.y@/z\", false, false, true},\n-\t{\"x.y[/z\", false, false, true},\n-\t{\"x.y\\\\/z\", false, false, false},\n-\t{\"x.y]/z\", false, false, true},\n-\t{\"x.y^/z\", false, false, true},\n-\t{\"x.y_/z\", false, true, true},\n-\t{\"x.y`/z\", false, false, false},\n-\t{\"x.y{/z\", false, false, true},\n-\t{\"x.y}/z\", false, false, true},\n-\t{\"x.y~/z\", false, true, true},\n-\t{\"x.y/z!\", false, false, true},\n-\t{\"x.y/z\\\"\", false, false, false},\n-\t{\"x.y/z#\", false, false, true},\n-\t{\"x.y/z$\", false, false, true},\n-\t{\"x.y/z%\", false, false, true},\n-\t{\"x.y/z&\", false, false, true},\n-\t{\"x.y/z'\", false, false, false},\n-\t{\"x.y/z(\", false, false, true},\n-\t{\"x.y/z)\", false, false, true},\n-\t{\"x.y/z*\", false, false, false},\n-\t{\"x.y/z+\", true, true, true},\n-\t{\"x.y/z,\", false, false, true},\n-\t{\"x.y/z-\", true, true, true},\n-\t{\"x.y/z.t\", true, true, true},\n-\t{\"x.y/z/t\", true, true, true},\n-\t{\"x.y/z:\", false, false, false},\n-\t{\"x.y/z;\", false, false, false},\n-\t{\"x.y/z<\", false, false, false},\n-\t{\"x.y/z=\", false, false, true},\n-\t{\"x.y/z>\", false, false, false},\n-\t{\"x.y/z?\", false, false, false},\n-\t{\"x.y/z@\", false, false, true},\n-\t{\"x.y/z[\", false, false, true},\n-\t{\"x.y/z\\\\\", false, false, false},\n-\t{\"x.y/z]\", false, false, true},\n-\t{\"x.y/z^\", false, false, true},\n-\t{\"x.y/z_\", true, true, true},\n-\t{\"x.y/z`\", false, false, false},\n-\t{\"x.y/z{\", false, false, true},\n-\t{\"x.y/z}\", false, false, true},\n-\t{\"x.y/z~\", true, true, true},\n-\t{\"x.y/x.foo\", true, true, true},\n-\t{\"x.y/aux.foo\", false, false, false},\n-\t{\"x.y/prn\", false, false, false},\n-\t{\"x.y/prn2\", true, true, true},\n-\t{\"x.y/com\", true, true, true},\n-\t{\"x.y/com1\", false, false, false},\n-\t{\"x.y/com1.txt\", false, false, false},\n-\t{\"x.y/calm1\", true, true, true},\n-\t{\"github.com/!123/logrus\", false, false, true},\n-\n-\t// TODO: CL 41822 allowed Unicode letters in old \"go get\"\n-\t// without due consideration of the implications, and only on github.com (!).\n-\t// For now, we disallow non-ASCII characters in module mode,\n-\t// in both module paths and general import paths,\n-\t// until we can get the implications right.\n-\t// When we do, we'll enable them everywhere, not just for GitHub.\n-\t{\"github.com/user/unicode/\u0438\u0441\u043f\u044b\u0442\u0430\u043d\u0438\u0435\", false, false, true},\n-\n-\t{\"../x\", false, false, false},\n-\t{\"./y\", false, false, false},\n-\t{\"x:y\", false, false, false},\n-\t{`\\temp\\foo`, false, false, false},\n-\t{\".gitignore\", false, false, true},\n-\t{\".github/ISSUE_TEMPLATE\", false, false, true},\n-\t{\"x\u263ay\", false, false, false},\n-}\n-\n-func TestCheckPath(t *testing.T) {\n-\tfor _, tt := range checkPathTests {\n-\t\terr := CheckPath(tt.path)\n-\t\tif tt.ok && err != nil {\n-\t\t\tt.Errorf(\"CheckPath(%q) = %v, wanted nil error\", tt.path, err)\n-\t\t} else if !tt.ok && err == nil {\n-\t\t\tt.Errorf(\"CheckPath(%q) succeeded, wanted error\", tt.path)\n-\t\t}\n-\n-\t\terr = CheckImportPath(tt.path)\n-\t\tif tt.importOK && err != nil {\n-\t\t\tt.Errorf(\"CheckImportPath(%q) = %v, wanted nil error\", tt.path, err)\n-\t\t} else if !tt.importOK && err == nil {\n-\t\t\tt.Errorf(\"CheckImportPath(%q) succeeded, wanted error\", tt.path)\n-\t\t}\n-\n-\t\terr = CheckFilePath(tt.path)\n-\t\tif tt.fileOK && err != nil {\n-\t\t\tt.Errorf(\"CheckFilePath(%q) = %v, wanted nil error\", tt.path, err)\n-\t\t} else if !tt.fileOK && err == nil {\n-\t\t\tt.Errorf(\"CheckFilePath(%q) succeeded, wanted error\", tt.path)\n-\t\t}\n-\t}\n-}\n-\n-var splitPathVersionTests = []struct {\n-\tpathPrefix string\n-\tversion    string\n-}{\n-\t{\"x.y/z\", \"\"},\n-\t{\"x.y/z\", \"/v2\"},\n-\t{\"x.y/z\", \"/v3\"},\n-\t{\"x.y/v\", \"\"},\n-\t{\"gopkg.in/yaml\", \".v0\"},\n-\t{\"gopkg.in/yaml\", \".v1\"},\n-\t{\"gopkg.in/yaml\", \".v2\"},\n-\t{\"gopkg.in/yaml\", \".v3\"},\n-}\n-\n-func TestSplitPathVersion(t *testing.T) {\n-\tfor _, tt := range splitPathVersionTests {\n-\t\tpathPrefix, version, ok := SplitPathVersion(tt.pathPrefix + tt.version)\n-\t\tif pathPrefix != tt.pathPrefix || version != tt.version || !ok {\n-\t\t\tt.Errorf(\"SplitPathVersion(%q) = %q, %q, %v, want %q, %q, true\", tt.pathPrefix+tt.version, pathPrefix, version, ok, tt.pathPrefix, tt.version)\n-\t\t}\n-\t}\n-\n-\tfor _, tt := range checkPathTests {\n-\t\tpathPrefix, version, ok := SplitPathVersion(tt.path)\n-\t\tif pathPrefix+version != tt.path {\n-\t\t\tt.Errorf(\"SplitPathVersion(%q) = %q, %q, %v, doesn't add to input\", tt.path, pathPrefix, version, ok)\n-\t\t}\n-\t}\n-}\n-\n-var encodeTests = []struct {\n-\tpath string\n-\tenc  string // empty means same as path\n-}{\n-\t{path: \"ascii.com/abcdefghijklmnopqrstuvwxyz.-+/~_0123456789\"},\n-\t{path: \"github.com/GoogleCloudPlatform/omega\", enc: \"github.com/!google!cloud!platform/omega\"},\n-}\n-\n-func TestEncodePath(t *testing.T) {\n-\t// Check invalid paths.\n-\tfor _, tt := range checkPathTests {\n-\t\tif !tt.ok {\n-\t\t\t_, err := EncodePath(tt.path)\n-\t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"EncodePath(%q): succeeded, want error (invalid path)\", tt.path)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Check encodings.\n-\tfor _, tt := range encodeTests {\n-\t\tenc, err := EncodePath(tt.path)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"EncodePath(%q): unexpected error: %v\", tt.path, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\twant := tt.enc\n-\t\tif want == \"\" {\n-\t\t\twant = tt.path\n-\t\t}\n-\t\tif enc != want {\n-\t\t\tt.Errorf(\"EncodePath(%q) = %q, want %q\", tt.path, enc, want)\n-\t\t}\n-\t}\n-}\n-\n-var badDecode = []string{\n-\t\"github.com/GoogleCloudPlatform/omega\",\n-\t\"github.com/!google!cloud!platform!/omega\",\n-\t\"github.com/!0google!cloud!platform/omega\",\n-\t\"github.com/!_google!cloud!platform/omega\",\n-\t\"github.com/!!google!cloud!platform/omega\",\n-\t\"\",\n-}\n-\n-func TestDecodePath(t *testing.T) {\n-\t// Check invalid decodings.\n-\tfor _, bad := range badDecode {\n-\t\t_, err := DecodePath(bad)\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"DecodePath(%q): succeeded, want error (invalid decoding)\", bad)\n-\t\t}\n-\t}\n-\n-\t// Check invalid paths (or maybe decodings).\n-\tfor _, tt := range checkPathTests {\n-\t\tif !tt.ok {\n-\t\t\tpath, err := DecodePath(tt.path)\n-\t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"DecodePath(%q) = %q, want error (invalid path)\", tt.path, path)\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Check encodings.\n-\tfor _, tt := range encodeTests {\n-\t\tenc := tt.enc\n-\t\tif enc == \"\" {\n-\t\t\tenc = tt.path\n-\t\t}\n-\t\tpath, err := DecodePath(enc)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"DecodePath(%q): unexpected error: %v\", enc, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif path != tt.path {\n-\t\t\tt.Errorf(\"DecodePath(%q) = %q, want %q\", enc, path, tt.path)\n-\t\t}\n-\t}\n-}"}, {"sha": "dd3b3ccb865ecfedb49e909c15462853e8db8b15", "filename": "libgo/go/cmd/go/internal/mvs/mvs.go", "status": "modified", "additions": 11, "deletions": 5, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -13,8 +13,9 @@ import (\n \t\"sync\"\n \t\"sync/atomic\"\n \n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n+\n+\t\"golang.org/x/mod/module\"\n )\n \n // A Reqs is the requirement graph on which Minimal Version Selection (MVS) operates.\n@@ -250,10 +251,15 @@ func buildList(target module.Version, reqs Reqs, upgrade func(module.Version) (m\n \treturn list, nil\n }\n \n-// Req returns the minimal requirement list for the target module\n-// that results in the given build list, with the constraint that all\n-// module paths listed in base must appear in the returned list.\n-func Req(target module.Version, list []module.Version, base []string, reqs Reqs) ([]module.Version, error) {\n+// Req returns the minimal requirement list for the target module,\n+// with the constraint that all module paths listed in base must\n+// appear in the returned list.\n+func Req(target module.Version, base []string, reqs Reqs) ([]module.Version, error) {\n+\tlist, err := BuildList(target, reqs)\n+\tif err != nil {\n+\t\treturn nil, err\n+\t}\n+\n \t// Note: Not running in parallel because we assume\n \t// that list came from a previous operation that paged\n \t// in all the requirements, so there's no I/O to overlap now."}, {"sha": "9a30a8c3ac0679ccdb123571588eda1e544cef5c", "filename": "libgo/go/cmd/go/internal/mvs/mvs_test.go", "status": "modified", "additions": 25, "deletions": 7, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fmvs%2Fmvs_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,7 +10,7 @@ import (\n \t\"strings\"\n \t\"testing\"\n \n-\t\"cmd/go/internal/module\"\n+\t\"golang.org/x/mod/module\"\n )\n \n var tests = `\n@@ -280,6 +280,20 @@ D2:\n build A: A B1 C1 D1\n upgrade* A: A B2 C2 D2\n \n+# Cycles with multiple possible solutions.\n+# (golang.org/issue/34086)\n+name: cycle3\n+M: A1 C2\n+A1: B1\n+B1: C1\n+B2: C2\n+C1:\n+C2: B2\n+build M: M A1 B2 C2\n+req M: A1 B2\n+req M A: A1 B2\n+req M C: A1 C2\n+\n # Requirement minimization.\n \n name: req1\n@@ -390,7 +404,15 @@ func Test(t *testing.T) {\n \t\t\tfns = append(fns, func(t *testing.T) {\n \t\t\t\tlist, err := Upgrade(m(kf[1]), reqs, ms(kf[2:])...)\n \t\t\t\tif err == nil {\n-\t\t\t\t\tlist, err = Req(m(kf[1]), list, nil, reqs)\n+\t\t\t\t\t// Copy the reqs map, but substitute the upgraded requirements in\n+\t\t\t\t\t// place of the target's original requirements.\n+\t\t\t\t\tupReqs := make(reqsMap, len(reqs))\n+\t\t\t\t\tfor m, r := range reqs {\n+\t\t\t\t\t\tupReqs[m] = r\n+\t\t\t\t\t}\n+\t\t\t\t\tupReqs[m(kf[1])] = list\n+\n+\t\t\t\t\tlist, err = Req(m(kf[1]), nil, upReqs)\n \t\t\t\t}\n \t\t\t\tcheckList(t, key, list, err, val)\n \t\t\t})\n@@ -418,11 +440,7 @@ func Test(t *testing.T) {\n \t\t\t\tt.Fatalf(\"req takes at least one argument: %q\", line)\n \t\t\t}\n \t\t\tfns = append(fns, func(t *testing.T) {\n-\t\t\t\tlist, err := BuildList(m(kf[1]), reqs)\n-\t\t\t\tif err != nil {\n-\t\t\t\t\tt.Fatal(err)\n-\t\t\t\t}\n-\t\t\t\tlist, err = Req(m(kf[1]), list, kf[2:], reqs)\n+\t\t\t\tlist, err := Req(m(kf[1]), kf[2:], reqs)\n \t\t\t\tcheckList(t, key, list, err, val)\n \t\t\t})\n \t\t\tcontinue"}, {"sha": "53554b4c23fb041f2ee252412fb36df057214763", "filename": "libgo/go/cmd/go/internal/note/example_test.go", "status": "removed", "additions": 0, "deletions": 128, "changes": 128, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fexample_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,128 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package note_test\n-\n-import (\n-\t\"fmt\"\n-\t\"io\"\n-\t\"os\"\n-\n-\t\"cmd/go/internal/note\"\n-)\n-\n-func ExampleSign() {\n-\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n-\ttext := \"If you think cryptography is the answer to your problem,\\n\" +\n-\t\t\"then you don't know what your problem is.\\n\"\n-\n-\tsigner, err := note.NewSigner(skey)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\n-\tmsg, err := note.Sign(&note.Note{Text: text}, signer)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\tos.Stdout.Write(msg)\n-\n-\t// Output:\n-\t// If you think cryptography is the answer to your problem,\n-\t// then you don't know what your problem is.\n-\t//\n-\t// \u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n-}\n-\n-func ExampleOpen() {\n-\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n-\t\t\"then you don't know what your problem is.\\n\" +\n-\t\t\"\\n\" +\n-\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n-\n-\tverifier, err := note.NewVerifier(vkey)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\tverifiers := note.VerifierList(verifier)\n-\n-\tn, err := note.Open(msg, verifiers)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\tfmt.Printf(\"%s (%08x):\\n%s\", n.Sigs[0].Name, n.Sigs[0].Hash, n.Text)\n-\n-\t// Output:\n-\t// PeterNeumann (c74f20a3):\n-\t// If you think cryptography is the answer to your problem,\n-\t// then you don't know what your problem is.\n-}\n-\n-var rand = struct {\n-\tReader io.Reader\n-}{\n-\tzeroReader{},\n-}\n-\n-type zeroReader struct{}\n-\n-func (zeroReader) Read(buf []byte) (int, error) {\n-\tfor i := range buf {\n-\t\tbuf[i] = 0\n-\t}\n-\treturn len(buf), nil\n-}\n-\n-func ExampleSign_add_signatures() {\n-\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n-\t\t\"then you don't know what your problem is.\\n\" +\n-\t\t\"\\n\" +\n-\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n-\n-\tverifier, err := note.NewVerifier(vkey)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\tverifiers := note.VerifierList(verifier)\n-\n-\tn, err := note.Open([]byte(msg), verifiers)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\n-\tskey, vkey, err := note.GenerateKey(rand.Reader, \"EnochRoot\")\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\t_ = vkey // give to verifiers\n-\n-\tme, err := note.NewSigner(skey)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\n-\tmsg, err = note.Sign(n, me)\n-\tif err != nil {\n-\t\tfmt.Println(err)\n-\t\treturn\n-\t}\n-\tos.Stdout.Write(msg)\n-\n-\t// Output:\n-\t// If you think cryptography is the answer to your problem,\n-\t// then you don't know what your problem is.\n-\t//\n-\t// \u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n-\t// \u2014 EnochRoot rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\n-}"}, {"sha": "729324647e747680e9eff985e4278f793d7c7633", "filename": "libgo/go/cmd/go/internal/note/note_test.go", "status": "removed", "additions": 0, "deletions": 472, "changes": 472, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fnote%2Fnote_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,472 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package note\n-\n-import (\n-\t\"crypto/ed25519\"\n-\t\"crypto/rand\"\n-\t\"errors\"\n-\t\"strings\"\n-\t\"testing\"\n-\t\"testing/iotest\"\n-)\n-\n-func TestNewVerifier(t *testing.T) {\n-\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\t_, err := NewVerifier(vkey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// Check various manglings are not accepted.\n-\tbadKey := func(k string) {\n-\t\t_, err := NewVerifier(k)\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"NewVerifier(%q) succeeded, should have failed\", k)\n-\t\t}\n-\t}\n-\n-\tb := []byte(vkey)\n-\tfor i := 0; i <= len(b); i++ {\n-\t\tfor j := i + 1; j <= len(b); j++ {\n-\t\t\tif i != 0 || j != len(b) {\n-\t\t\t\tbadKey(string(b[i:j]))\n-\t\t\t}\n-\t\t}\n-\t}\n-\tfor i := 0; i < len(b); i++ {\n-\t\tb[i]++\n-\t\tbadKey(string(b))\n-\t\tb[i]--\n-\t}\n-\n-\tbadKey(\"PeterNeumann+cc469956+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TWBADKEY==\") // wrong length key, with adjusted key hash\n-\tbadKey(\"PeterNeumann+173116ae+ZRpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\")         // unknown algorithm, with adjusted key hash\n-}\n-\n-func TestNewSigner(t *testing.T) {\n-\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n-\t_, err := NewSigner(skey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// Check various manglings are not accepted.\n-\tb := []byte(skey)\n-\tfor i := 0; i <= len(b); i++ {\n-\t\tfor j := i + 1; j <= len(b); j++ {\n-\t\t\tif i == 0 && j == len(b) {\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\t_, err := NewSigner(string(b[i:j]))\n-\t\t\tif err == nil {\n-\t\t\t\tt.Errorf(\"NewSigner(%q) succeeded, should have failed\", b[i:j])\n-\t\t\t}\n-\t\t}\n-\t}\n-\tfor i := 0; i < len(b); i++ {\n-\t\tb[i]++\n-\t\t_, err := NewSigner(string(b))\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"NewSigner(%q) succeeded, should have failed\", b)\n-\t\t}\n-\t\tb[i]--\n-\t}\n-}\n-\n-func testSignerAndVerifier(t *testing.T, Name string, signer Signer, verifier Verifier) {\n-\tif name := signer.Name(); name != Name {\n-\t\tt.Errorf(\"signer.Name() = %q, want %q\", name, Name)\n-\t}\n-\tif name := verifier.Name(); name != Name {\n-\t\tt.Errorf(\"verifier.Name() = %q, want %q\", name, Name)\n-\t}\n-\tshash := signer.KeyHash()\n-\tvhash := verifier.KeyHash()\n-\tif shash != vhash {\n-\t\tt.Errorf(\"signer.KeyHash() = %#08x != verifier.KeyHash() = %#08x\", shash, vhash)\n-\t}\n-\n-\tmsg := []byte(\"hi\")\n-\tsig, err := signer.Sign(msg)\n-\tif err != nil {\n-\t\tt.Fatalf(\"signer.Sign: %v\", err)\n-\t}\n-\tif !verifier.Verify(msg, sig) {\n-\t\tt.Fatalf(\"verifier.Verify failed on signature returned by signer.Sign\")\n-\t}\n-\tsig[0]++\n-\tif verifier.Verify(msg, sig) {\n-\t\tt.Fatalf(\"verifier.Verify succceeded on corrupt signature\")\n-\t}\n-\tsig[0]--\n-\tmsg[0]++\n-\tif verifier.Verify(msg, sig) {\n-\t\tt.Fatalf(\"verifier.Verify succceeded on corrupt message\")\n-\t}\n-}\n-\n-func TestGenerateKey(t *testing.T) {\n-\t// Generate key pair, make sure it is all self-consistent.\n-\tconst Name = \"EnochRoot\"\n-\n-\tskey, vkey, err := GenerateKey(rand.Reader, Name)\n-\tif err != nil {\n-\t\tt.Fatalf(\"GenerateKey: %v\", err)\n-\t}\n-\tsigner, err := NewSigner(skey)\n-\tif err != nil {\n-\t\tt.Fatalf(\"NewSigner: %v\", err)\n-\t}\n-\tverifier, err := NewVerifier(vkey)\n-\tif err != nil {\n-\t\tt.Fatalf(\"NewVerifier: %v\", err)\n-\t}\n-\n-\ttestSignerAndVerifier(t, Name, signer, verifier)\n-\n-\t// Check that GenerateKey returns error from rand reader.\n-\t_, _, err = GenerateKey(iotest.TimeoutReader(iotest.OneByteReader(rand.Reader)), Name)\n-\tif err == nil {\n-\t\tt.Fatalf(\"GenerateKey succeeded with error-returning rand reader\")\n-\t}\n-}\n-\n-func TestFromEd25519(t *testing.T) {\n-\tconst Name = \"EnochRoot\"\n-\n-\tpub, priv, err := ed25519.GenerateKey(rand.Reader)\n-\tif err != nil {\n-\t\tt.Fatalf(\"GenerateKey: %v\", err)\n-\t}\n-\tsigner, err := newSignerFromEd25519Seed(Name, priv.Seed())\n-\tif err != nil {\n-\t\tt.Fatalf(\"newSignerFromEd25519Seed: %v\", err)\n-\t}\n-\tvkey, err := NewEd25519VerifierKey(Name, pub)\n-\tif err != nil {\n-\t\tt.Fatalf(\"NewEd25519VerifierKey: %v\", err)\n-\t}\n-\tverifier, err := NewVerifier(vkey)\n-\tif err != nil {\n-\t\tt.Fatalf(\"NewVerifier: %v\", err)\n-\t}\n-\n-\ttestSignerAndVerifier(t, Name, signer, verifier)\n-\n-\t// Check that wrong key sizes return errors.\n-\t_, err = NewEd25519VerifierKey(Name, pub[:len(pub)-1])\n-\tif err == nil {\n-\t\tt.Errorf(\"NewEd25519VerifierKey succeeded with a seed of the wrong size\")\n-\t}\n-}\n-\n-// newSignerFromEd25519Seed constructs a new signer from a verifier name and a\n-// crypto/ed25519 private key seed.\n-func newSignerFromEd25519Seed(name string, seed []byte) (Signer, error) {\n-\tif len(seed) != ed25519.SeedSize {\n-\t\treturn nil, errors.New(\"invalid seed size\")\n-\t}\n-\tpriv := ed25519.NewKeyFromSeed(seed)\n-\tpub := priv[32:]\n-\n-\tpubkey := append([]byte{algEd25519}, pub...)\n-\thash := keyHash(name, pubkey)\n-\n-\ts := &signer{\n-\t\tname: name,\n-\t\thash: uint32(hash),\n-\t\tsign: func(msg []byte) ([]byte, error) {\n-\t\t\treturn ed25519.Sign(priv, msg), nil\n-\t\t},\n-\t}\n-\treturn s, nil\n-}\n-\n-func TestSign(t *testing.T) {\n-\tskey := \"PRIVATE+KEY+PeterNeumann+c74f20a3+AYEKFALVFGyNhPJEMzD1QIDr+Y7hfZx09iUvxdXHKDFz\"\n-\ttext := \"If you think cryptography is the answer to your problem,\\n\" +\n-\t\t\"then you don't know what your problem is.\\n\"\n-\n-\tsigner, err := NewSigner(skey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tmsg, err := Sign(&Note{Text: text}, signer)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\twant := `If you think cryptography is the answer to your problem,\n-then you don't know what your problem is.\n-\n-\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\n-`\n-\tif string(msg) != want {\n-\t\tt.Errorf(\"Sign: wrong output\\nhave:\\n%s\\nwant:\\n%s\", msg, want)\n-\t}\n-\n-\t// Check that existing signature is replaced by new one.\n-\tmsg, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"PeterNeumann\", Hash: 0xc74f20a3, Base64: \"BADSIGN=\"}}}, signer)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif string(msg) != want {\n-\t\tt.Errorf(\"Sign replacing signature: wrong output\\nhave:\\n%s\\nwant:\\n%s\", msg, want)\n-\t}\n-\n-\t// Check various bad inputs.\n-\t_, err = Sign(&Note{Text: \"abc\"}, signer)\n-\tif err == nil || err.Error() != \"malformed note\" {\n-\t\tt.Fatalf(\"Sign with short text: %v, want malformed note error\", err)\n-\t}\n-\n-\t_, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"a+b\", Base64: \"ABCD\"}}})\n-\tif err == nil || err.Error() != \"malformed note\" {\n-\t\tt.Fatalf(\"Sign with bad name: %v, want malformed note error\", err)\n-\t}\n-\n-\t_, err = Sign(&Note{Text: text, Sigs: []Signature{{Name: \"PeterNeumann\", Hash: 0xc74f20a3, Base64: \"BADHASH=\"}}})\n-\tif err == nil || err.Error() != \"malformed note\" {\n-\t\tt.Fatalf(\"Sign with bad pre-filled signature: %v, want malformed note error\", err)\n-\t}\n-\n-\t_, err = Sign(&Note{Text: text}, &badSigner{signer})\n-\tif err == nil || err.Error() != \"invalid signer\" {\n-\t\tt.Fatalf(\"Sign with bad signer: %v, want invalid signer error\", err)\n-\t}\n-\n-\t_, err = Sign(&Note{Text: text}, &errSigner{signer})\n-\tif err != errSurprise {\n-\t\tt.Fatalf(\"Sign with failing signer: %v, want errSurprise\", err)\n-\t}\n-}\n-\n-func TestVerifierList(t *testing.T) {\n-\tpeterKey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\tpeterVerifier, err := NewVerifier(peterKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tenochKey := \"EnochRoot+af0cfe78+ATtqJ7zOtqQtYqOo0CpvDXNlMhV3HeJDpjrASKGLWdop\"\n-\tenochVerifier, err := NewVerifier(enochKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tlist := VerifierList(peterVerifier, enochVerifier, enochVerifier)\n-\tv, err := list.Verifier(\"PeterNeumann\", 0xc74f20a3)\n-\tif v != peterVerifier || err != nil {\n-\t\tt.Fatalf(\"list.Verifier(peter) = %v, %v, want %v, nil\", v, err, peterVerifier)\n-\t}\n-\tv, err = list.Verifier(\"PeterNeumann\", 0xc74f20a4)\n-\tif v != nil || err == nil || err.Error() != \"unknown key PeterNeumann+c74f20a4\" {\n-\t\tt.Fatalf(\"list.Verifier(peter bad hash) = %v, %v, want nil, unknown key error\", v, err)\n-\t}\n-\n-\tv, err = list.Verifier(\"PeterNeuman\", 0xc74f20a3)\n-\tif v != nil || err == nil || err.Error() != \"unknown key PeterNeuman+c74f20a3\" {\n-\t\tt.Fatalf(\"list.Verifier(peter bad name) = %v, %v, want nil, unknown key error\", v, err)\n-\t}\n-\tv, err = list.Verifier(\"EnochRoot\", 0xaf0cfe78)\n-\tif v != nil || err == nil || err.Error() != \"ambiguous key EnochRoot+af0cfe78\" {\n-\t\tt.Fatalf(\"list.Verifier(enoch) = %v, %v, want nil, ambiguous key error\", v, err)\n-\t}\n-}\n-\n-type badSigner struct {\n-\tSigner\n-}\n-\n-func (b *badSigner) Name() string {\n-\treturn \"bad name\"\n-}\n-\n-var errSurprise = errors.New(\"surprise!\")\n-\n-type errSigner struct {\n-\tSigner\n-}\n-\n-func (e *errSigner) Sign([]byte) ([]byte, error) {\n-\treturn nil, errSurprise\n-}\n-\n-func TestOpen(t *testing.T) {\n-\tpeterKey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\tpeterVerifier, err := NewVerifier(peterKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tenochKey := \"EnochRoot+af0cfe78+ATtqJ7zOtqQtYqOo0CpvDXNlMhV3HeJDpjrASKGLWdop\"\n-\tenochVerifier, err := NewVerifier(enochKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\ttext := `If you think cryptography is the answer to your problem,\n-then you don't know what your problem is.\n-`\n-\tpeterSig := \"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\"\n-\tenochSig := \"\u2014 EnochRoot rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\\n\"\n-\n-\tpeter := Signature{\"PeterNeumann\", 0xc74f20a3, \"x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\"}\n-\tenoch := Signature{\"EnochRoot\", 0xaf0cfe78, \"rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\"}\n-\n-\t// Check one signature verified, one not.\n-\tn, err := Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList(peterVerifier))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif n.Text != text {\n-\t\tt.Errorf(\"n.Text = %q, want %q\", n.Text, text)\n-\t}\n-\tif len(n.Sigs) != 1 || n.Sigs[0] != peter {\n-\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n-\t}\n-\tif len(n.UnverifiedSigs) != 1 || n.UnverifiedSigs[0] != enoch {\n-\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n-\t}\n-\n-\t// Check both verified.\n-\tn, err = Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList(peterVerifier, enochVerifier))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif len(n.Sigs) != 2 || n.Sigs[0] != peter || n.Sigs[1] != enoch {\n-\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter, enoch})\n-\t}\n-\tif len(n.UnverifiedSigs) != 0 {\n-\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{})\n-\t}\n-\n-\t// Check both unverified.\n-\tn, err = Open([]byte(text+\"\\n\"+peterSig+enochSig), VerifierList())\n-\tif n != nil || err == nil {\n-\t\tt.Fatalf(\"Open unverified = %v, %v, want nil, error\", n, err)\n-\t}\n-\te, ok := err.(*UnverifiedNoteError)\n-\tif !ok {\n-\t\tt.Fatalf(\"Open unverified: err is %T, want *UnverifiedNoteError\", err)\n-\t}\n-\tif err.Error() != \"note has no verifiable signatures\" {\n-\t\tt.Fatalf(\"Open unverified: err.Error() = %q, want %q\", err.Error(), \"note has no verifiable signatures\")\n-\t}\n-\n-\tn = e.Note\n-\tif n == nil {\n-\t\tt.Fatalf(\"Open unverified: missing note in UnverifiedNoteError\")\n-\t}\n-\tif len(n.Sigs) != 0 {\n-\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{})\n-\t}\n-\tif len(n.UnverifiedSigs) != 2 || n.UnverifiedSigs[0] != peter || n.UnverifiedSigs[1] != enoch {\n-\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter, enoch})\n-\t}\n-\n-\t// Check duplicated verifier.\n-\t_, err = Open([]byte(text+\"\\n\"+enochSig), VerifierList(enochVerifier, peterVerifier, enochVerifier))\n-\tif err == nil || err.Error() != \"ambiguous key EnochRoot+af0cfe78\" {\n-\t\tt.Fatalf(\"Open with duplicated verifier: err=%v, want ambiguous key\", err)\n-\t}\n-\n-\t// Check unused duplicated verifier.\n-\t_, err = Open([]byte(text+\"\\n\"+peterSig), VerifierList(enochVerifier, peterVerifier, enochVerifier))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\t// Check too many signatures.\n-\tn, err = Open([]byte(text+\"\\n\"+strings.Repeat(peterSig, 101)), VerifierList(peterVerifier))\n-\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n-\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, malformed note error\", n, err)\n-\t}\n-\tn, err = Open([]byte(text+\"\\n\"+strings.Repeat(peterSig, 101)), VerifierList())\n-\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n-\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, malformed note error\", n, err)\n-\t}\n-\n-\t// Invalid signature.\n-\tn, err = Open([]byte(text+\"\\n\"+peterSig[:60]+\"ABCD\"+peterSig[60:]), VerifierList(peterVerifier))\n-\tif n != nil || err == nil || err.Error() != \"invalid signature for key PeterNeumann+c74f20a3\" {\n-\t\tt.Fatalf(\"Open too many verified signatures = %v, %v, want nil, invalid signature error\", n, err)\n-\t}\n-\n-\t// Duplicated verified and unverified signatures.\n-\tenochABCD := Signature{\"EnochRoot\", 0xaf0cfe78, \"rwz+eBzmZa0SO3NbfRGzPCpDckykFXSdeX+MNtCOXm2/5n\" + \"ABCD\" + \"2tiOHp+vAF1aGrQ5ovTG01oOTGwnWLox33WWd1RvMc+QQ=\"}\n-\tn, err = Open([]byte(text+\"\\n\"+peterSig+peterSig+enochSig+enochSig+enochSig[:60]+\"ABCD\"+enochSig[60:]), VerifierList(peterVerifier))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif len(n.Sigs) != 1 || n.Sigs[0] != peter {\n-\t\tt.Errorf(\"n.Sigs:\\nhave %v\\nwant %v\", n.Sigs, []Signature{peter})\n-\t}\n-\tif len(n.UnverifiedSigs) != 2 || n.UnverifiedSigs[0] != enoch || n.UnverifiedSigs[1] != enochABCD {\n-\t\tt.Errorf(\"n.UnverifiedSigs:\\nhave %v\\nwant %v\", n.UnverifiedSigs, []Signature{enoch, enochABCD})\n-\t}\n-\n-\t// Invalid encoded message syntax.\n-\tbadMsgs := []string{\n-\t\ttext,\n-\t\ttext + \"\\n\",\n-\t\ttext + \"\\n\" + peterSig[:len(peterSig)-1],\n-\t\t\"\\x01\" + text + \"\\n\" + peterSig,\n-\t\t\"\\xff\" + text + \"\\n\" + peterSig,\n-\t\ttext + \"\\n\" + \"\u2014 Bad Name x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\",\n-\t\ttext + \"\\n\" + peterSig + \"Unexpected line.\\n\",\n-\t}\n-\tfor _, msg := range badMsgs {\n-\t\tn, err := Open([]byte(msg), VerifierList(peterVerifier))\n-\t\tif n != nil || err == nil || err.Error() != \"malformed note\" {\n-\t\t\tt.Fatalf(\"Open bad msg = %v, %v, want nil, malformed note error\\nmsg:\\n%s\", n, err, msg)\n-\t\t}\n-\t}\n-}\n-\n-func BenchmarkOpen(b *testing.B) {\n-\tvkey := \"PeterNeumann+c74f20a3+ARpc2QcUPDhMQegwxbzhKqiBfsVkmqq/LDE4izWy10TW\"\n-\tmsg := []byte(\"If you think cryptography is the answer to your problem,\\n\" +\n-\t\t\"then you don't know what your problem is.\\n\" +\n-\t\t\"\\n\" +\n-\t\t\"\u2014 PeterNeumann x08go/ZJkuBS9UG/SffcvIAQxVBtiFupLLr8pAcElZInNIuGUgYN1FFYC2pZSNXgKvqfqdngotpRZb6KE6RyyBwJnAM=\\n\")\n-\n-\tverifier, err := NewVerifier(vkey)\n-\tif err != nil {\n-\t\tb.Fatal(err)\n-\t}\n-\tverifiers := VerifierList(verifier)\n-\tverifiers0 := VerifierList()\n-\n-\t// Try with 0 signatures and 1 signature so we can tell how much each signature adds.\n-\n-\tb.Run(\"Sig0\", func(b *testing.B) {\n-\t\tfor i := 0; i < b.N; i++ {\n-\t\t\t_, err := Open(msg, verifiers0)\n-\t\t\te, ok := err.(*UnverifiedNoteError)\n-\t\t\tif !ok {\n-\t\t\t\tb.Fatal(\"expected UnverifiedNoteError\")\n-\t\t\t}\n-\t\t\tn := e.Note\n-\t\t\tif len(n.Sigs) != 0 || len(n.UnverifiedSigs) != 1 {\n-\t\t\t\tb.Fatal(\"wrong signature count\")\n-\t\t\t}\n-\t\t}\n-\t})\n-\n-\tb.Run(\"Sig1\", func(b *testing.B) {\n-\t\tfor i := 0; i < b.N; i++ {\n-\t\t\tn, err := Open(msg, verifiers)\n-\t\t\tif err != nil {\n-\t\t\t\tb.Fatal(err)\n-\t\t\t}\n-\t\t\tif len(n.Sigs) != 1 || len(n.UnverifiedSigs) != 0 {\n-\t\t\t\tb.Fatal(\"wrong signature count\")\n-\t\t\t}\n-\t\t}\n-\t})\n-}"}, {"sha": "ee2f3ba1bb8f7f956d88f57d328f7ee9abb18fa4", "filename": "libgo/go/cmd/go/internal/renameio/renameio_test.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Frenameio_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build !plan9\n+// +build !plan9\n \n package renameio\n \n@@ -131,10 +131,18 @@ func TestConcurrentReadsAndWrites(t *testing.T) {\n \t}\n \n \tvar minReadSuccesses int64 = attempts\n-\tif runtime.GOOS == \"windows\" {\n+\n+\tswitch runtime.GOOS {\n+\tcase \"windows\":\n \t\t// Windows produces frequent \"Access is denied\" errors under heavy rename load.\n-\t\t// As long as those are the only errors and *some* of the writes succeed, we're happy.\n+\t\t// As long as those are the only errors and *some* of the reads succeed, we're happy.\n \t\tminReadSuccesses = attempts / 4\n+\n+\tcase \"darwin\":\n+\t\t// The filesystem on macOS 10.14 occasionally fails with \"no such file or\n+\t\t// directory\" errors. See https://golang.org/issue/33041. The flake rate is\n+\t\t// fairly low, so ensure that at least 75% of attempts succeed.\n+\t\tminReadSuccesses = attempts - (attempts / 4)\n \t}\n \n \tif readSuccesses < minReadSuccesses {"}, {"sha": "d75d67c9a939a60cbf310f135416ce0a8b2a55a6", "filename": "libgo/go/cmd/go/internal/renameio/umask_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frenameio%2Fumask_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build !nacl,!plan9,!windows,!js\n+// +build !plan9,!windows,!js\n \n package renameio\n \n@@ -19,6 +19,7 @@ func TestWriteFileModeAppliesUmask(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to create temporary directory: %v\", err)\n \t}\n+\tdefer os.RemoveAll(dir)\n \n \tconst mode = 0644\n \tconst umask = 0007\n@@ -29,7 +30,6 @@ func TestWriteFileModeAppliesUmask(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatalf(\"Failed to write file: %v\", err)\n \t}\n-\tdefer os.RemoveAll(dir)\n \n \tfi, err := os.Stat(file)\n \tif err != nil {"}, {"sha": "99fd8ebc2fff18afa6764b3e8c2a0fd26caa9241", "filename": "libgo/go/cmd/go/internal/robustio/robustio_darwin.go", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_darwin.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_darwin.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_darwin.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,21 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package robustio\n+\n+import (\n+\t\"errors\"\n+\t\"syscall\"\n+)\n+\n+const errFileNotFound = syscall.ENOENT\n+\n+// isEphemeralError returns true if err may be resolved by waiting.\n+func isEphemeralError(err error) bool {\n+\tvar errno syscall.Errno\n+\tif errors.As(err, &errno) {\n+\t\treturn errno == errFileNotFound\n+\t}\n+\treturn false\n+}"}, {"sha": "e57c8c74c4c6a4c97484cd9ff6dcc8773a2e3362", "filename": "libgo/go/cmd/go/internal/robustio/robustio_flaky.go", "status": "added", "additions": 92, "deletions": 0, "changes": 92, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_flaky.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,92 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// +build windows darwin\n+\n+package robustio\n+\n+import (\n+\t\"errors\"\n+\t\"io/ioutil\"\n+\t\"math/rand\"\n+\t\"os\"\n+\t\"syscall\"\n+\t\"time\"\n+)\n+\n+const arbitraryTimeout = 500 * time.Millisecond\n+\n+// retry retries ephemeral errors from f up to an arbitrary timeout\n+// to work around filesystem flakiness on Windows and Darwin.\n+func retry(f func() (err error, mayRetry bool)) error {\n+\tvar (\n+\t\tbestErr     error\n+\t\tlowestErrno syscall.Errno\n+\t\tstart       time.Time\n+\t\tnextSleep   time.Duration = 1 * time.Millisecond\n+\t)\n+\tfor {\n+\t\terr, mayRetry := f()\n+\t\tif err == nil || !mayRetry {\n+\t\t\treturn err\n+\t\t}\n+\n+\t\tvar errno syscall.Errno\n+\t\tif errors.As(err, &errno) && (lowestErrno == 0 || errno < lowestErrno) {\n+\t\t\tbestErr = err\n+\t\t\tlowestErrno = errno\n+\t\t} else if bestErr == nil {\n+\t\t\tbestErr = err\n+\t\t}\n+\n+\t\tif start.IsZero() {\n+\t\t\tstart = time.Now()\n+\t\t} else if d := time.Since(start) + nextSleep; d >= arbitraryTimeout {\n+\t\t\tbreak\n+\t\t}\n+\t\ttime.Sleep(nextSleep)\n+\t\tnextSleep += time.Duration(rand.Int63n(int64(nextSleep)))\n+\t}\n+\n+\treturn bestErr\n+}\n+\n+// rename is like os.Rename, but retries ephemeral errors.\n+//\n+// On Windows it wraps os.Rename, which (as of 2019-06-04) uses MoveFileEx with\n+// MOVEFILE_REPLACE_EXISTING.\n+//\n+// Windows also provides a different system call, ReplaceFile,\n+// that provides similar semantics, but perhaps preserves more metadata. (The\n+// documentation on the differences between the two is very sparse.)\n+//\n+// Empirical error rates with MoveFileEx are lower under modest concurrency, so\n+// for now we're sticking with what the os package already provides.\n+func rename(oldpath, newpath string) (err error) {\n+\treturn retry(func() (err error, mayRetry bool) {\n+\t\terr = os.Rename(oldpath, newpath)\n+\t\treturn err, isEphemeralError(err)\n+\t})\n+}\n+\n+// readFile is like ioutil.ReadFile, but retries ephemeral errors.\n+func readFile(filename string) ([]byte, error) {\n+\tvar b []byte\n+\terr := retry(func() (err error, mayRetry bool) {\n+\t\tb, err = ioutil.ReadFile(filename)\n+\n+\t\t// Unlike in rename, we do not retry errFileNotFound here: it can occur\n+\t\t// as a spurious error, but the file may also genuinely not exist, so the\n+\t\t// increase in robustness is probably not worth the extra latency.\n+\t\treturn err, isEphemeralError(err) && !errors.Is(err, errFileNotFound)\n+\t})\n+\treturn b, err\n+}\n+\n+func removeAll(path string) error {\n+\treturn retry(func() (err error, mayRetry bool) {\n+\t\terr = os.RemoveAll(path)\n+\t\treturn err, isEphemeralError(err)\n+\t})\n+}"}, {"sha": "907b556858712ddf46d0812d76e3b6e18907b7bc", "filename": "libgo/go/cmd/go/internal/robustio/robustio_other.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_other.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build !windows\n+// +build !windows,!darwin\n \n package robustio\n "}, {"sha": "687dcb66f83d15d0be4c7d45f4652a236afb2ac2", "filename": "libgo/go/cmd/go/internal/robustio/robustio_windows.go", "status": "modified", "additions": 1, "deletions": 79, "changes": 80, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frobustio%2Frobustio_windows.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,88 +7,10 @@ package robustio\n import (\n \t\"errors\"\n \t\"internal/syscall/windows\"\n-\t\"io/ioutil\"\n-\t\"math/rand\"\n-\t\"os\"\n \t\"syscall\"\n-\t\"time\"\n )\n \n-const arbitraryTimeout = 500 * time.Millisecond\n-\n-// retry retries ephemeral errors from f up to an arbitrary timeout\n-// to work around spurious filesystem errors on Windows\n-func retry(f func() (err error, mayRetry bool)) error {\n-\tvar (\n-\t\tbestErr     error\n-\t\tlowestErrno syscall.Errno\n-\t\tstart       time.Time\n-\t\tnextSleep   time.Duration = 1 * time.Millisecond\n-\t)\n-\tfor {\n-\t\terr, mayRetry := f()\n-\t\tif err == nil || !mayRetry {\n-\t\t\treturn err\n-\t\t}\n-\n-\t\tvar errno syscall.Errno\n-\t\tif errors.As(err, &errno) && (lowestErrno == 0 || errno < lowestErrno) {\n-\t\t\tbestErr = err\n-\t\t\tlowestErrno = errno\n-\t\t} else if bestErr == nil {\n-\t\t\tbestErr = err\n-\t\t}\n-\n-\t\tif start.IsZero() {\n-\t\t\tstart = time.Now()\n-\t\t} else if d := time.Since(start) + nextSleep; d >= arbitraryTimeout {\n-\t\t\tbreak\n-\t\t}\n-\t\ttime.Sleep(nextSleep)\n-\t\tnextSleep += time.Duration(rand.Int63n(int64(nextSleep)))\n-\t}\n-\n-\treturn bestErr\n-}\n-\n-// rename is like os.Rename, but retries ephemeral errors.\n-//\n-// It wraps os.Rename, which (as of 2019-06-04) uses MoveFileEx with\n-// MOVEFILE_REPLACE_EXISTING.\n-//\n-// Windows also provides a different system call, ReplaceFile,\n-// that provides similar semantics, but perhaps preserves more metadata. (The\n-// documentation on the differences between the two is very sparse.)\n-//\n-// Empirical error rates with MoveFileEx are lower under modest concurrency, so\n-// for now we're sticking with what the os package already provides.\n-func rename(oldpath, newpath string) (err error) {\n-\treturn retry(func() (err error, mayRetry bool) {\n-\t\terr = os.Rename(oldpath, newpath)\n-\t\treturn err, isEphemeralError(err)\n-\t})\n-}\n-\n-// readFile is like ioutil.ReadFile, but retries ephemeral errors.\n-func readFile(filename string) ([]byte, error) {\n-\tvar b []byte\n-\terr := retry(func() (err error, mayRetry bool) {\n-\t\tb, err = ioutil.ReadFile(filename)\n-\n-\t\t// Unlike in rename, we do not retry ERROR_FILE_NOT_FOUND here: it can occur\n-\t\t// as a spurious error, but the file may also genuinely not exist, so the\n-\t\t// increase in robustness is probably not worth the extra latency.\n-\t\treturn err, isEphemeralError(err) && !errors.Is(err, syscall.ERROR_FILE_NOT_FOUND)\n-\t})\n-\treturn b, err\n-}\n-\n-func removeAll(path string) error {\n-\treturn retry(func() (err error, mayRetry bool) {\n-\t\terr = os.RemoveAll(path)\n-\t\treturn err, isEphemeralError(err)\n-\t})\n-}\n+const errFileNotFound = syscall.ERROR_FILE_NOT_FOUND\n \n // isEphemeralError returns true if err may be resolved by waiting.\n func isEphemeralError(err error) bool {"}, {"sha": "2edae38ccaa797d4851203a40a854799a2340cb5", "filename": "libgo/go/cmd/go/internal/run/run.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Frun%2Frun.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -33,7 +33,7 @@ If the -exec flag is given, 'go run' invokes the binary using xprog:\n If the -exec flag is not given, GOOS or GOARCH is different from the system\n default, and a program named go_$GOOS_$GOARCH_exec can be found\n on the current search path, 'go run' invokes the binary using that program,\n-for example 'go_nacl_386_exec a.out arguments...'. This allows execution of\n+for example 'go_js_wasm_exec a.out arguments...'. This allows execution of\n cross-compiled programs when a simulator or other execution method is\n available.\n \n@@ -49,7 +49,7 @@ See also: go build.\n func init() {\n \tCmdRun.Run = runRun // break init loop\n \n-\twork.AddBuildFlags(CmdRun)\n+\twork.AddBuildFlags(CmdRun, work.DefaultBuildFlags)\n \tCmdRun.Flag.Var((*base.StringsFlag)(&work.ExecCmd), \"exec\", \"\")\n }\n "}, {"sha": "ad33e60af144406f8ab6be34af38d963146f92cd", "filename": "libgo/go/cmd/go/internal/search/search.go", "status": "modified", "additions": 56, "deletions": 28, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -125,32 +125,43 @@ func SetModRoot(dir string) {\n \tmodRoot = dir\n }\n \n-// MatchPackagesInFS is like allPackages but is passed a pattern\n-// beginning ./ or ../, meaning it should scan the tree rooted\n-// at the given directory. There are ... in the pattern too.\n-// (See go help packages for pattern syntax.)\n+// MatchPackagesInFS is like MatchPackages but is passed a pattern that\n+// begins with an absolute path or \"./\" or \"../\". On Windows, the pattern may\n+// use slash or backslash separators or a mix of both.\n+//\n+// MatchPackagesInFS scans the tree rooted at the directory that contains the\n+// first \"...\" wildcard and returns a match with packages that\n func MatchPackagesInFS(pattern string) *Match {\n \tm := &Match{\n \t\tPattern: pattern,\n \t\tLiteral: false,\n \t}\n \n+\t// Clean the path and create a matching predicate.\n+\t// filepath.Clean removes \"./\" prefixes (and \".\\\" on Windows). We need to\n+\t// preserve these, since they are meaningful in MatchPattern and in\n+\t// returned import paths.\n+\tcleanPattern := filepath.Clean(pattern)\n+\tisLocal := strings.HasPrefix(pattern, \"./\") || (os.PathSeparator == '\\\\' && strings.HasPrefix(pattern, `.\\`))\n+\tprefix := \"\"\n+\tif cleanPattern != \".\" && isLocal {\n+\t\tprefix = \"./\"\n+\t\tcleanPattern = \".\" + string(os.PathSeparator) + cleanPattern\n+\t}\n+\tslashPattern := filepath.ToSlash(cleanPattern)\n+\tmatch := MatchPattern(slashPattern)\n+\n \t// Find directory to begin the scan.\n \t// Could be smarter but this one optimization\n \t// is enough for now, since ... is usually at the\n \t// end of a path.\n-\ti := strings.Index(pattern, \"...\")\n-\tdir, _ := path.Split(pattern[:i])\n+\ti := strings.Index(cleanPattern, \"...\")\n+\tdir, _ := filepath.Split(cleanPattern[:i])\n \n \t// pattern begins with ./ or ../.\n \t// path.Clean will discard the ./ but not the ../.\n \t// We need to preserve the ./ for pattern matching\n \t// and in the returned import paths.\n-\tprefix := \"\"\n-\tif strings.HasPrefix(pattern, \"./\") {\n-\t\tprefix = \"./\"\n-\t}\n-\tmatch := MatchPattern(pattern)\n \n \tif modRoot != \"\" {\n \t\tabs, err := filepath.Abs(dir)\n@@ -241,7 +252,7 @@ func TreeCanMatchPattern(pattern string) func(name string) bool {\n //\n // First, /... at the end of the pattern can match an empty string,\n // so that net/... matches both net and packages in its subdirectories, like net/http.\n-// Second, any slash-separted pattern element containing a wildcard never\n+// Second, any slash-separated pattern element containing a wildcard never\n // participates in a match of the \"vendor\" element in the path of a vendored\n // package, so that ./... does not match packages in subdirectories of\n // ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do.\n@@ -361,32 +372,49 @@ func ImportPathsQuiet(patterns []string) []*Match {\n \treturn out\n }\n \n-// CleanPatterns returns the patterns to use for the given\n-// command line. It canonicalizes the patterns but does not\n-// evaluate any matches.\n+// CleanPatterns returns the patterns to use for the given command line. It\n+// canonicalizes the patterns but does not evaluate any matches. For patterns\n+// that are not local or absolute paths, it preserves text after '@' to avoid\n+// modifying version queries.\n func CleanPatterns(patterns []string) []string {\n \tif len(patterns) == 0 {\n \t\treturn []string{\".\"}\n \t}\n \tvar out []string\n \tfor _, a := range patterns {\n-\t\t// Arguments are supposed to be import paths, but\n-\t\t// as a courtesy to Windows developers, rewrite \\ to /\n-\t\t// in command-line arguments. Handles .\\... and so on.\n-\t\tif filepath.Separator == '\\\\' {\n-\t\t\ta = strings.ReplaceAll(a, `\\`, `/`)\n+\t\tvar p, v string\n+\t\tif build.IsLocalImport(a) || filepath.IsAbs(a) {\n+\t\t\tp = a\n+\t\t} else if i := strings.IndexByte(a, '@'); i < 0 {\n+\t\t\tp = a\n+\t\t} else {\n+\t\t\tp = a[:i]\n+\t\t\tv = a[i:]\n \t\t}\n \n-\t\t// Put argument in canonical form, but preserve leading ./.\n-\t\tif strings.HasPrefix(a, \"./\") {\n-\t\t\ta = \"./\" + path.Clean(a)\n-\t\t\tif a == \"./.\" {\n-\t\t\t\ta = \".\"\n-\t\t\t}\n+\t\t// Arguments may be either file paths or import paths.\n+\t\t// As a courtesy to Windows developers, rewrite \\ to /\n+\t\t// in arguments that look like import paths.\n+\t\t// Don't replace slashes in absolute paths.\n+\t\tif filepath.IsAbs(p) {\n+\t\t\tp = filepath.Clean(p)\n \t\t} else {\n-\t\t\ta = path.Clean(a)\n+\t\t\tif filepath.Separator == '\\\\' {\n+\t\t\t\tp = strings.ReplaceAll(p, `\\`, `/`)\n+\t\t\t}\n+\n+\t\t\t// Put argument in canonical form, but preserve leading ./.\n+\t\t\tif strings.HasPrefix(p, \"./\") {\n+\t\t\t\tp = \"./\" + path.Clean(p)\n+\t\t\t\tif p == \"./.\" {\n+\t\t\t\t\tp = \".\"\n+\t\t\t\t}\n+\t\t\t} else {\n+\t\t\t\tp = path.Clean(p)\n+\t\t\t}\n \t\t}\n-\t\tout = append(out, a)\n+\n+\t\tout = append(out, p+v)\n \t}\n \treturn out\n }"}, {"sha": "5f27daf3fb848d643882f91e0d442ebf9eaaa266", "filename": "libgo/go/cmd/go/internal/search/search_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsearch%2Fsearch_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -33,7 +33,7 @@ var matchPatternTests = `\n \tmatch net net/http\n \tnot not/http not/net/http netchan\n \n-\t# Second, any slash-separted pattern element containing a wildcard never\n+\t# Second, any slash-separated pattern element containing a wildcard never\n \t# participates in a match of the \"vendor\" element in the path of a vendored\n \t# package, so that ./... does not match packages in subdirectories of\n \t# ./vendor or ./mycode/vendor, but ./vendor/... and ./mycode/vendor/... do."}, {"sha": "77025a44abd60a36f8e21eeb000b71f5e8d62409", "filename": "libgo/go/cmd/go/internal/semver/semver_test.go", "status": "removed", "additions": 0, "deletions": 183, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsemver%2Fsemver_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,183 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package semver\n-\n-import (\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-var tests = []struct {\n-\tin  string\n-\tout string\n-}{\n-\t{\"bad\", \"\"},\n-\t{\"v1-alpha.beta.gamma\", \"\"},\n-\t{\"v1-pre\", \"\"},\n-\t{\"v1+meta\", \"\"},\n-\t{\"v1-pre+meta\", \"\"},\n-\t{\"v1.2-pre\", \"\"},\n-\t{\"v1.2+meta\", \"\"},\n-\t{\"v1.2-pre+meta\", \"\"},\n-\t{\"v1.0.0-alpha\", \"v1.0.0-alpha\"},\n-\t{\"v1.0.0-alpha.1\", \"v1.0.0-alpha.1\"},\n-\t{\"v1.0.0-alpha.beta\", \"v1.0.0-alpha.beta\"},\n-\t{\"v1.0.0-beta\", \"v1.0.0-beta\"},\n-\t{\"v1.0.0-beta.2\", \"v1.0.0-beta.2\"},\n-\t{\"v1.0.0-beta.11\", \"v1.0.0-beta.11\"},\n-\t{\"v1.0.0-rc.1\", \"v1.0.0-rc.1\"},\n-\t{\"v1\", \"v1.0.0\"},\n-\t{\"v1.0\", \"v1.0.0\"},\n-\t{\"v1.0.0\", \"v1.0.0\"},\n-\t{\"v1.2\", \"v1.2.0\"},\n-\t{\"v1.2.0\", \"v1.2.0\"},\n-\t{\"v1.2.3-456\", \"v1.2.3-456\"},\n-\t{\"v1.2.3-456.789\", \"v1.2.3-456.789\"},\n-\t{\"v1.2.3-456-789\", \"v1.2.3-456-789\"},\n-\t{\"v1.2.3-456a\", \"v1.2.3-456a\"},\n-\t{\"v1.2.3-pre\", \"v1.2.3-pre\"},\n-\t{\"v1.2.3-pre+meta\", \"v1.2.3-pre\"},\n-\t{\"v1.2.3-pre.1\", \"v1.2.3-pre.1\"},\n-\t{\"v1.2.3-zzz\", \"v1.2.3-zzz\"},\n-\t{\"v1.2.3\", \"v1.2.3\"},\n-\t{\"v1.2.3+meta\", \"v1.2.3\"},\n-\t{\"v1.2.3+meta-pre\", \"v1.2.3\"},\n-\t{\"v1.2.3+meta-pre.sha.256a\", \"v1.2.3\"},\n-}\n-\n-func TestIsValid(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tok := IsValid(tt.in)\n-\t\tif ok != (tt.out != \"\") {\n-\t\t\tt.Errorf(\"IsValid(%q) = %v, want %v\", tt.in, ok, !ok)\n-\t\t}\n-\t}\n-}\n-\n-func TestCanonical(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tout := Canonical(tt.in)\n-\t\tif out != tt.out {\n-\t\t\tt.Errorf(\"Canonical(%q) = %q, want %q\", tt.in, out, tt.out)\n-\t\t}\n-\t}\n-}\n-\n-func TestMajor(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tout := Major(tt.in)\n-\t\twant := \"\"\n-\t\tif i := strings.Index(tt.out, \".\"); i >= 0 {\n-\t\t\twant = tt.out[:i]\n-\t\t}\n-\t\tif out != want {\n-\t\t\tt.Errorf(\"Major(%q) = %q, want %q\", tt.in, out, want)\n-\t\t}\n-\t}\n-}\n-\n-func TestMajorMinor(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tout := MajorMinor(tt.in)\n-\t\tvar want string\n-\t\tif tt.out != \"\" {\n-\t\t\twant = tt.in\n-\t\t\tif i := strings.Index(want, \"+\"); i >= 0 {\n-\t\t\t\twant = want[:i]\n-\t\t\t}\n-\t\t\tif i := strings.Index(want, \"-\"); i >= 0 {\n-\t\t\t\twant = want[:i]\n-\t\t\t}\n-\t\t\tswitch strings.Count(want, \".\") {\n-\t\t\tcase 0:\n-\t\t\t\twant += \".0\"\n-\t\t\tcase 1:\n-\t\t\t\t// ok\n-\t\t\tcase 2:\n-\t\t\t\twant = want[:strings.LastIndex(want, \".\")]\n-\t\t\t}\n-\t\t}\n-\t\tif out != want {\n-\t\t\tt.Errorf(\"MajorMinor(%q) = %q, want %q\", tt.in, out, want)\n-\t\t}\n-\t}\n-}\n-\n-func TestPrerelease(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tpre := Prerelease(tt.in)\n-\t\tvar want string\n-\t\tif tt.out != \"\" {\n-\t\t\tif i := strings.Index(tt.out, \"-\"); i >= 0 {\n-\t\t\t\twant = tt.out[i:]\n-\t\t\t}\n-\t\t}\n-\t\tif pre != want {\n-\t\t\tt.Errorf(\"Prerelease(%q) = %q, want %q\", tt.in, pre, want)\n-\t\t}\n-\t}\n-}\n-\n-func TestBuild(t *testing.T) {\n-\tfor _, tt := range tests {\n-\t\tbuild := Build(tt.in)\n-\t\tvar want string\n-\t\tif tt.out != \"\" {\n-\t\t\tif i := strings.Index(tt.in, \"+\"); i >= 0 {\n-\t\t\t\twant = tt.in[i:]\n-\t\t\t}\n-\t\t}\n-\t\tif build != want {\n-\t\t\tt.Errorf(\"Build(%q) = %q, want %q\", tt.in, build, want)\n-\t\t}\n-\t}\n-}\n-\n-func TestCompare(t *testing.T) {\n-\tfor i, ti := range tests {\n-\t\tfor j, tj := range tests {\n-\t\t\tcmp := Compare(ti.in, tj.in)\n-\t\t\tvar want int\n-\t\t\tif ti.out == tj.out {\n-\t\t\t\twant = 0\n-\t\t\t} else if i < j {\n-\t\t\t\twant = -1\n-\t\t\t} else {\n-\t\t\t\twant = +1\n-\t\t\t}\n-\t\t\tif cmp != want {\n-\t\t\t\tt.Errorf(\"Compare(%q, %q) = %d, want %d\", ti.in, tj.in, cmp, want)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-func TestMax(t *testing.T) {\n-\tfor i, ti := range tests {\n-\t\tfor j, tj := range tests {\n-\t\t\tmax := Max(ti.in, tj.in)\n-\t\t\twant := Canonical(ti.in)\n-\t\t\tif i < j {\n-\t\t\t\twant = Canonical(tj.in)\n-\t\t\t}\n-\t\t\tif max != want {\n-\t\t\t\tt.Errorf(\"Max(%q, %q) = %q, want %q\", ti.in, tj.in, max, want)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-var (\n-\tv1 = \"v1.0.0+metadata-dash\"\n-\tv2 = \"v1.0.0+metadata-dash1\"\n-)\n-\n-func BenchmarkCompare(b *testing.B) {\n-\tfor i := 0; i < b.N; i++ {\n-\t\tif Compare(v1, v2) != 0 {\n-\t\t\tb.Fatalf(\"bad compare\")\n-\t\t}\n-\t}\n-}"}, {"sha": "83a182adc559764c0c6e1868a0f6e7650e3bb44c", "filename": "libgo/go/cmd/go/internal/sumweb/client_test.go", "status": "removed", "additions": 0, "deletions": 460, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fclient_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,460 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package sumweb\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"strings\"\n-\t\"sync\"\n-\t\"testing\"\n-\n-\t\"cmd/go/internal/note\"\n-\t\"cmd/go/internal/tlog\"\n-)\n-\n-const (\n-\ttestName        = \"localhost.localdev/sumdb\"\n-\ttestVerifierKey = \"localhost.localdev/sumdb+00000c67+AcTrnkbUA+TU4heY3hkjiSES/DSQniBqIeQ/YppAUtK6\"\n-\ttestSignerKey   = \"PRIVATE+KEY+localhost.localdev/sumdb+00000c67+AXu6+oaVaOYuQOFrf1V59JK1owcFlJcHwwXHDfDGxSPk\"\n-)\n-\n-func TestConnLookup(t *testing.T) {\n-\ttc := newTestClient(t)\n-\ttc.mustHaveLatest(1)\n-\n-\t// Basic lookup.\n-\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n-\ttc.mustHaveLatest(3)\n-\n-\t// Everything should now be cached, both for the original package and its /go.mod.\n-\ttc.getOK = false\n-\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n-\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0/go.mod\", \"rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\")\n-\ttc.mustHaveLatest(3)\n-\ttc.getOK = true\n-\ttc.getTileOK = false // the cache has what we need\n-\n-\t// Lookup with multiple returned lines.\n-\ttc.mustLookup(\"rsc.io/quote\", \"v1.5.2\", \"rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=\\nrsc.io/quote v1.5.2 h2:xyzzy\")\n-\ttc.mustHaveLatest(3)\n-\n-\t// Lookup with need for !-encoding.\n-\t// rsc.io/Quote is the only record written after rsc.io/samper,\n-\t// so it is the only one that should need more tiles.\n-\ttc.getTileOK = true\n-\ttc.mustLookup(\"rsc.io/Quote\", \"v1.5.2\", \"rsc.io/Quote v1.5.2 h1:uppercase!=\")\n-\ttc.mustHaveLatest(4)\n-}\n-\n-func TestConnBadTiles(t *testing.T) {\n-\ttc := newTestClient(t)\n-\n-\tflipBits := func() {\n-\t\tfor url, data := range tc.remote {\n-\t\t\tif strings.Contains(url, \"/tile/\") {\n-\t\t\t\tfor i := range data {\n-\t\t\t\t\tdata[i] ^= 0x80\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t}\n-\n-\t// Bad tiles in initial download.\n-\ttc.mustHaveLatest(1)\n-\tflipBits()\n-\t_, err := tc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\")\n-\ttc.mustError(err, \"rsc.io/sampler@v1.3.0: initializing sumweb.Conn: checking tree#1: downloaded inconsistent tile\")\n-\tflipBits()\n-\ttc.newConn()\n-\ttc.mustLookup(\"rsc.io/sampler\", \"v1.3.0\", \"rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\")\n-\n-\t// Bad tiles after initial download.\n-\tflipBits()\n-\t_, err = tc.conn.Lookup(\"rsc.io/Quote\", \"v1.5.2\")\n-\ttc.mustError(err, \"rsc.io/Quote@v1.5.2: checking tree#3 against tree#4: downloaded inconsistent tile\")\n-\tflipBits()\n-\ttc.newConn()\n-\ttc.mustLookup(\"rsc.io/Quote\", \"v1.5.2\", \"rsc.io/Quote v1.5.2 h1:uppercase!=\")\n-\n-\t// Bad starting tree hash looks like bad tiles.\n-\ttc.newConn()\n-\ttext := tlog.FormatTree(tlog.Tree{N: 1, Hash: tlog.Hash{}})\n-\tdata, err := note.Sign(&note.Note{Text: string(text)}, tc.signer)\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\ttc.config[testName+\"/latest\"] = data\n-\t_, err = tc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\")\n-\ttc.mustError(err, \"rsc.io/sampler@v1.3.0: initializing sumweb.Conn: checking tree#1: downloaded inconsistent tile\")\n-}\n-\n-func TestConnFork(t *testing.T) {\n-\ttc := newTestClient(t)\n-\ttc2 := tc.fork()\n-\n-\ttc.addRecord(\"rsc.io/pkg1@v1.5.2\", `rsc.io/pkg1 v1.5.2 h1:hash!=\n-`)\n-\ttc.addRecord(\"rsc.io/pkg1@v1.5.4\", `rsc.io/pkg1 v1.5.4 h1:hash!=\n-`)\n-\ttc.mustLookup(\"rsc.io/pkg1\", \"v1.5.2\", \"rsc.io/pkg1 v1.5.2 h1:hash!=\")\n-\n-\ttc2.addRecord(\"rsc.io/pkg1@v1.5.3\", `rsc.io/pkg1 v1.5.3 h1:hash!=\n-`)\n-\ttc2.addRecord(\"rsc.io/pkg1@v1.5.4\", `rsc.io/pkg1 v1.5.4 h1:hash!=\n-`)\n-\ttc2.mustLookup(\"rsc.io/pkg1\", \"v1.5.4\", \"rsc.io/pkg1 v1.5.4 h1:hash!=\")\n-\n-\tkey := \"/lookup/rsc.io/pkg1@v1.5.2\"\n-\ttc2.remote[key] = tc.remote[key]\n-\t_, err := tc2.conn.Lookup(\"rsc.io/pkg1\", \"v1.5.2\")\n-\ttc2.mustError(err, ErrSecurity.Error())\n-\n-\t/*\n-\t   SECURITY ERROR\n-\t   go.sum database server misbehavior detected!\n-\n-\t   old database:\n-\t   \tgo.sum database tree!\n-\t   \t5\n-\t   \tnWzN20+pwMt62p7jbv1/NlN95ePTlHijabv5zO/s36w=\n-\n-\t   \t\u2014 localhost.localdev/sumdb AAAMZ5/2FVAdMH58kmnz/0h299pwyskEbzDzoa2/YaPdhvLya4YWDFQQxu2TQb5GpwAH4NdWnTwuhILafisyf3CNbgg=\n-\n-\t   new database:\n-\t   \tgo.sum database tree\n-\t   \t6\n-\t   \twc4SkQt52o5W2nQ8To2ARs+mWuUJjss+sdleoiqxMmM=\n-\n-\t   \t\u2014 localhost.localdev/sumdb AAAMZ6oRNswlEZ6ZZhxrCvgl1MBy+nusq4JU+TG6Fe2NihWLqOzb+y2c2kzRLoCr4tvw9o36ucQEnhc20e4nA4Qc/wc=\n-\n-\t   proof of misbehavior:\n-\t   \tT7i+H/8ER4nXOiw4Bj0koZOkGjkxoNvlI34GpvhHhQg=\n-\t   \tNsuejv72de9hYNM5bqFv8rv3gm3zJQwv/DT/WNbLDLA=\n-\t   \tmOmqqZ1aI/lzS94oq/JSbj7pD8Rv9S+xDyi12BtVSHo=\n-\t   \t/7Aw5jVSMM9sFjQhaMg+iiDYPMk6decH7QLOGrL9Lx0=\n-\t*/\n-\n-\twants := []string{\n-\t\t\"SECURITY ERROR\",\n-\t\t\"go.sum database server misbehavior detected!\",\n-\t\t\"old database:\\n\\tgo.sum database tree\\n\\t5\\n\",\n-\t\t\"\u2014 localhost.localdev/sumdb AAAMZ5/2FVAd\",\n-\t\t\"new database:\\n\\tgo.sum database tree\\n\\t6\\n\",\n-\t\t\"\u2014 localhost.localdev/sumdb AAAMZ6oRNswl\",\n-\t\t\"proof of misbehavior:\\n\\tT7i+H/8ER4nXOiw4Bj0k\",\n-\t}\n-\ttext := tc2.security.String()\n-\tfor _, want := range wants {\n-\t\tif !strings.Contains(text, want) {\n-\t\t\tt.Fatalf(\"cannot find %q in security text:\\n%s\", want, text)\n-\t\t}\n-\t}\n-}\n-\n-func TestConnGONOSUMDB(t *testing.T) {\n-\ttc := newTestClient(t)\n-\ttc.conn.SetGONOSUMDB(\"p,*/q\")\n-\ttc.conn.Lookup(\"rsc.io/sampler\", \"v1.3.0\") // initialize before we turn off network\n-\ttc.getOK = false\n-\n-\tok := []string{\n-\t\t\"abc\",\n-\t\t\"a/p\",\n-\t\t\"pq\",\n-\t\t\"q\",\n-\t\t\"n/o/p/q\",\n-\t}\n-\tskip := []string{\n-\t\t\"p\",\n-\t\t\"p/x\",\n-\t\t\"x/q\",\n-\t\t\"x/q/z\",\n-\t}\n-\n-\tfor _, path := range ok {\n-\t\t_, err := tc.conn.Lookup(path, \"v1.0.0\")\n-\t\tif err == ErrGONOSUMDB {\n-\t\t\tt.Errorf(\"Lookup(%q): ErrGONOSUMDB, wanted failed actual lookup\", path)\n-\t\t}\n-\t}\n-\tfor _, path := range skip {\n-\t\t_, err := tc.conn.Lookup(path, \"v1.0.0\")\n-\t\tif err != ErrGONOSUMDB {\n-\t\t\tt.Errorf(\"Lookup(%q): %v, wanted ErrGONOSUMDB\", path, err)\n-\t\t}\n-\t}\n-}\n-\n-// A testClient is a self-contained client-side testing environment.\n-type testClient struct {\n-\tt          *testing.T // active test\n-\tconn       *Conn      // conn being tested\n-\ttileHeight int        // tile height to use (default 2)\n-\tgetOK      bool       // should tc.GetURL succeed?\n-\tgetTileOK  bool       // should tc.GetURL of tiles succeed?\n-\ttreeSize   int64\n-\thashes     []tlog.Hash\n-\tremote     map[string][]byte\n-\tsigner     note.Signer\n-\n-\t// mu protects config, cache, log, security\n-\t// during concurrent use of the exported methods\n-\t// by the conn itself (testClient is the Conn's Client,\n-\t// and the Client methods can both read and write these fields).\n-\t// Unexported methods invoked directly by the test\n-\t// (for example, addRecord) need not hold the mutex:\n-\t// for proper test execution those methods should only\n-\t// be called when the Conn is idle and not using its Client.\n-\t// Not holding the mutex in those methods ensures\n-\t// that if a mistake is made, go test -race will report it.\n-\t// (Holding the mutex would eliminate the race report but\n-\t// not the underlying problem.)\n-\t// Similarly, the get map is not protected by the mutex,\n-\t// because the Client methods only read it.\n-\tmu       sync.Mutex // prot\n-\tconfig   map[string][]byte\n-\tcache    map[string][]byte\n-\tsecurity bytes.Buffer\n-}\n-\n-// newTestClient returns a new testClient that will call t.Fatal on error\n-// and has a few records already available on the remote server.\n-func newTestClient(t *testing.T) *testClient {\n-\ttc := &testClient{\n-\t\tt:          t,\n-\t\ttileHeight: 2,\n-\t\tgetOK:      true,\n-\t\tgetTileOK:  true,\n-\t\tconfig:     make(map[string][]byte),\n-\t\tcache:      make(map[string][]byte),\n-\t\tremote:     make(map[string][]byte),\n-\t}\n-\n-\ttc.config[\"key\"] = []byte(testVerifierKey + \"\\n\")\n-\tvar err error\n-\ttc.signer, err = note.NewSigner(testSignerKey)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\ttc.newConn()\n-\n-\ttc.addRecord(\"rsc.io/quote@v1.5.2\", `rsc.io/quote v1.5.2 h1:w5fcysjrx7yqtD/aO+QwRjYZOKnaM9Uh2b40tElTs3Y=\n-rsc.io/quote v1.5.2/go.mod h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe+TKr0=\n-rsc.io/quote v1.5.2 h2:xyzzy\n-`)\n-\n-\ttc.addRecord(\"golang.org/x/text@v0.0.0-20170915032832-14c0d48ead0c\", `golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:qgOY6WgZOaTkIIMiVjBQcw93ERBE4m30iBm00nkL0i8=\n-golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n-`)\n-\ttc.addRecord(\"rsc.io/sampler@v1.3.0\", `rsc.io/sampler v1.3.0 h1:7uVkIFmeBqHfdjD+gZwtXXI+RODJ2Wc4O7MPEh/QiW4=\n-rsc.io/sampler v1.3.0/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA=\n-`)\n-\ttc.config[testName+\"/latest\"] = tc.signTree(1)\n-\n-\ttc.addRecord(\"rsc.io/!quote@v1.5.2\", `rsc.io/Quote v1.5.2 h1:uppercase!=\n-`)\n-\treturn tc\n-}\n-\n-// newConn resets the Conn associated with tc.\n-// This clears any in-memory cache from the Conn\n-// but not tc's on-disk cache.\n-func (tc *testClient) newConn() {\n-\ttc.conn = NewConn(tc)\n-\ttc.conn.SetTileHeight(tc.tileHeight)\n-}\n-\n-// mustLookup does a lookup for path@vers and checks that the lines that come back match want.\n-func (tc *testClient) mustLookup(path, vers, want string) {\n-\ttc.t.Helper()\n-\tlines, err := tc.conn.Lookup(path, vers)\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\tif strings.Join(lines, \"\\n\") != want {\n-\t\ttc.t.Fatalf(\"Lookup(%q, %q):\\n\\t%s\\nwant:\\n\\t%s\", path, vers, strings.Join(lines, \"\\n\\t\"), strings.Replace(want, \"\\n\", \"\\n\\t\", -1))\n-\t}\n-}\n-\n-// mustHaveLatest checks that the on-disk configuration\n-// for latest is a tree of size n.\n-func (tc *testClient) mustHaveLatest(n int64) {\n-\ttc.t.Helper()\n-\n-\tlatest := tc.config[testName+\"/latest\"]\n-\tlines := strings.Split(string(latest), \"\\n\")\n-\tif len(lines) < 2 || lines[1] != fmt.Sprint(n) {\n-\t\ttc.t.Fatalf(\"/latest should have tree %d, but has:\\n%s\", n, latest)\n-\t}\n-}\n-\n-// mustError checks that err's error string contains the text.\n-func (tc *testClient) mustError(err error, text string) {\n-\ttc.t.Helper()\n-\tif err == nil || !strings.Contains(err.Error(), text) {\n-\t\ttc.t.Fatalf(\"err = %v, want %q\", err, text)\n-\t}\n-}\n-\n-// fork returns a copy of tc.\n-// Changes made to the new copy or to tc are not reflected in the other.\n-func (tc *testClient) fork() *testClient {\n-\ttc2 := &testClient{\n-\t\tt:          tc.t,\n-\t\tgetOK:      tc.getOK,\n-\t\tgetTileOK:  tc.getTileOK,\n-\t\ttileHeight: tc.tileHeight,\n-\t\ttreeSize:   tc.treeSize,\n-\t\thashes:     append([]tlog.Hash{}, tc.hashes...),\n-\t\tsigner:     tc.signer,\n-\t\tconfig:     copyMap(tc.config),\n-\t\tcache:      copyMap(tc.cache),\n-\t\tremote:     copyMap(tc.remote),\n-\t}\n-\ttc2.newConn()\n-\treturn tc2\n-}\n-\n-func copyMap(m map[string][]byte) map[string][]byte {\n-\tm2 := make(map[string][]byte)\n-\tfor k, v := range m {\n-\t\tm2[k] = v\n-\t}\n-\treturn m2\n-}\n-\n-// ReadHashes is tc's implementation of tlog.HashReader, for use with\n-// tlog.TreeHash and so on.\n-func (tc *testClient) ReadHashes(indexes []int64) ([]tlog.Hash, error) {\n-\tvar list []tlog.Hash\n-\tfor _, id := range indexes {\n-\t\tlist = append(list, tc.hashes[id])\n-\t}\n-\treturn list, nil\n-}\n-\n-// addRecord adds a log record using the given (!-encoded) key and data.\n-func (tc *testClient) addRecord(key, data string) {\n-\ttc.t.Helper()\n-\n-\t// Create record, add hashes to log tree.\n-\tid := tc.treeSize\n-\ttc.treeSize++\n-\trec, err := tlog.FormatRecord(id, []byte(data))\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\thashes, err := tlog.StoredHashesForRecordHash(id, tlog.RecordHash([]byte(data)), tc)\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\ttc.hashes = append(tc.hashes, hashes...)\n-\n-\t// Create lookup result.\n-\ttc.remote[\"/lookup/\"+key] = append(rec, tc.signTree(tc.treeSize)...)\n-\n-\t// Create new tiles.\n-\ttiles := tlog.NewTiles(tc.tileHeight, id, tc.treeSize)\n-\tfor _, tile := range tiles {\n-\t\tdata, err := tlog.ReadTileData(tile, tc)\n-\t\tif err != nil {\n-\t\t\ttc.t.Fatal(err)\n-\t\t}\n-\t\ttc.remote[\"/\"+tile.Path()] = data\n-\t\t// TODO delete old partial tiles\n-\t}\n-}\n-\n-// signTree returns the signed head for the tree of the given size.\n-func (tc *testClient) signTree(size int64) []byte {\n-\th, err := tlog.TreeHash(size, tc)\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\ttext := tlog.FormatTree(tlog.Tree{N: size, Hash: h})\n-\tdata, err := note.Sign(&note.Note{Text: string(text)}, tc.signer)\n-\tif err != nil {\n-\t\ttc.t.Fatal(err)\n-\t}\n-\treturn data\n-}\n-\n-// ReadRemote is for tc's implementation of Client.\n-func (tc *testClient) ReadRemote(path string) ([]byte, error) {\n-\t// No mutex here because only the Client should be running\n-\t// and the Client cannot change tc.get.\n-\tif !tc.getOK {\n-\t\treturn nil, fmt.Errorf(\"disallowed remote read %s\", path)\n-\t}\n-\tif strings.Contains(path, \"/tile/\") && !tc.getTileOK {\n-\t\treturn nil, fmt.Errorf(\"disallowed remote tile read %s\", path)\n-\t}\n-\n-\tdata, ok := tc.remote[path]\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"no remote path %s\", path)\n-\t}\n-\treturn data, nil\n-}\n-\n-// ReadConfig is for tc's implementation of Client.\n-func (tc *testClient) ReadConfig(file string) ([]byte, error) {\n-\ttc.mu.Lock()\n-\tdefer tc.mu.Unlock()\n-\n-\tdata, ok := tc.config[file]\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"no config %s\", file)\n-\t}\n-\treturn data, nil\n-}\n-\n-// WriteConfig is for tc's implementation of Client.\n-func (tc *testClient) WriteConfig(file string, old, new []byte) error {\n-\ttc.mu.Lock()\n-\tdefer tc.mu.Unlock()\n-\n-\tdata := tc.config[file]\n-\tif !bytes.Equal(old, data) {\n-\t\treturn ErrWriteConflict\n-\t}\n-\ttc.config[file] = new\n-\treturn nil\n-}\n-\n-// ReadCache is for tc's implementation of Client.\n-func (tc *testClient) ReadCache(file string) ([]byte, error) {\n-\ttc.mu.Lock()\n-\tdefer tc.mu.Unlock()\n-\n-\tdata, ok := tc.cache[file]\n-\tif !ok {\n-\t\treturn nil, fmt.Errorf(\"no cache %s\", file)\n-\t}\n-\treturn data, nil\n-}\n-\n-// WriteCache is for tc's implementation of Client.\n-func (tc *testClient) WriteCache(file string, data []byte) {\n-\ttc.mu.Lock()\n-\tdefer tc.mu.Unlock()\n-\n-\ttc.cache[file] = data\n-}\n-\n-// Log is for tc's implementation of Client.\n-func (tc *testClient) Log(msg string) {\n-\ttc.t.Log(msg)\n-}\n-\n-// SecurityError is for tc's implementation of Client.\n-func (tc *testClient) SecurityError(msg string) {\n-\ttc.mu.Lock()\n-\tdefer tc.mu.Unlock()\n-\n-\tfmt.Fprintf(&tc.security, \"%s\\n\", strings.TrimRight(msg, \"\\n\"))\n-}"}, {"sha": "d044a84f3a818425a173adc85cc4815db7881330", "filename": "libgo/go/cmd/go/internal/sumweb/encode.go", "status": "removed", "additions": 0, "deletions": 167, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,167 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-// FS-safe encoding of module paths and versions.\n-// Copied from cmd/go/internal/module and unexported.\n-\n-package sumweb\n-\n-import (\n-\t\"fmt\"\n-\t\"unicode/utf8\"\n-)\n-\n-// Safe encodings\n-//\n-// Module paths appear as substrings of file system paths\n-// (in the download cache) and of web server URLs in the proxy protocol.\n-// In general we cannot rely on file systems to be case-sensitive,\n-// nor can we rely on web servers, since they read from file systems.\n-// That is, we cannot rely on the file system to keep rsc.io/QUOTE\n-// and rsc.io/quote separate. Windows and macOS don't.\n-// Instead, we must never require two different casings of a file path.\n-// Because we want the download cache to match the proxy protocol,\n-// and because we want the proxy protocol to be possible to serve\n-// from a tree of static files (which might be stored on a case-insensitive\n-// file system), the proxy protocol must never require two different casings\n-// of a URL path either.\n-//\n-// One possibility would be to make the safe encoding be the lowercase\n-// hexadecimal encoding of the actual path bytes. This would avoid ever\n-// needing different casings of a file path, but it would be fairly illegible\n-// to most programmers when those paths appeared in the file system\n-// (including in file paths in compiler errors and stack traces)\n-// in web server logs, and so on. Instead, we want a safe encoding that\n-// leaves most paths unaltered.\n-//\n-// The safe encoding is this:\n-// replace every uppercase letter with an exclamation mark\n-// followed by the letter's lowercase equivalent.\n-//\n-// For example,\n-// github.com/Azure/azure-sdk-for-go ->  github.com/!azure/azure-sdk-for-go.\n-// github.com/GoogleCloudPlatform/cloudsql-proxy -> github.com/!google!cloud!platform/cloudsql-proxy\n-// github.com/Sirupsen/logrus -> github.com/!sirupsen/logrus.\n-//\n-// Import paths that avoid upper-case letters are left unchanged.\n-// Note that because import paths are ASCII-only and avoid various\n-// problematic punctuation (like : < and >), the safe encoding is also ASCII-only\n-// and avoids the same problematic punctuation.\n-//\n-// Import paths have never allowed exclamation marks, so there is no\n-// need to define how to encode a literal !.\n-//\n-// Although paths are disallowed from using Unicode (see pathOK above),\n-// the eventual plan is to allow Unicode letters as well, to assume that\n-// file systems and URLs are Unicode-safe (storing UTF-8), and apply\n-// the !-for-uppercase convention. Note however that not all runes that\n-// are different but case-fold equivalent are an upper/lower pair.\n-// For example, U+004B ('K'), U+006B ('k'), and U+212A ('\u212a' for Kelvin)\n-// are considered to case-fold to each other. When we do add Unicode\n-// letters, we must not assume that upper/lower are the only case-equivalent pairs.\n-// Perhaps the Kelvin symbol would be disallowed entirely, for example.\n-// Or perhaps it would encode as \"!!k\", or perhaps as \"(212A)\".\n-//\n-// Also, it would be nice to allow Unicode marks as well as letters,\n-// but marks include combining marks, and then we must deal not\n-// only with case folding but also normalization: both U+00E9 ('\u00e9')\n-// and U+0065 U+0301 ('e' followed by combining acute accent)\n-// look the same on the page and are treated by some file systems\n-// as the same path. If we do allow Unicode marks in paths, there\n-// must be some kind of normalization to allow only one canonical\n-// encoding of any character used in an import path.\n-\n-// encodePath returns the safe encoding of the given module path.\n-// It fails if the module path is invalid.\n-func encodePath(path string) (encoding string, err error) {\n-\treturn encodeString(path)\n-}\n-\n-// encodeVersion returns the safe encoding of the given module version.\n-// Versions are allowed to be in non-semver form but must be valid file names\n-// and not contain exclamation marks.\n-func encodeVersion(v string) (encoding string, err error) {\n-\treturn encodeString(v)\n-}\n-\n-func encodeString(s string) (encoding string, err error) {\n-\thaveUpper := false\n-\tfor _, r := range s {\n-\t\tif r == '!' || r >= utf8.RuneSelf {\n-\t\t\t// This should be disallowed by CheckPath, but diagnose anyway.\n-\t\t\t// The correctness of the encoding loop below depends on it.\n-\t\t\treturn \"\", fmt.Errorf(\"internal error: inconsistency in EncodePath\")\n-\t\t}\n-\t\tif 'A' <= r && r <= 'Z' {\n-\t\t\thaveUpper = true\n-\t\t}\n-\t}\n-\n-\tif !haveUpper {\n-\t\treturn s, nil\n-\t}\n-\n-\tvar buf []byte\n-\tfor _, r := range s {\n-\t\tif 'A' <= r && r <= 'Z' {\n-\t\t\tbuf = append(buf, '!', byte(r+'a'-'A'))\n-\t\t} else {\n-\t\t\tbuf = append(buf, byte(r))\n-\t\t}\n-\t}\n-\treturn string(buf), nil\n-}\n-\n-// decodePath returns the module path of the given safe encoding.\n-// It fails if the encoding is invalid or encodes an invalid path.\n-func decodePath(encoding string) (path string, err error) {\n-\tpath, ok := decodeString(encoding)\n-\tif !ok {\n-\t\treturn \"\", fmt.Errorf(\"invalid module path encoding %q\", encoding)\n-\t}\n-\treturn path, nil\n-}\n-\n-// decodeVersion returns the version string for the given safe encoding.\n-// It fails if the encoding is invalid or encodes an invalid version.\n-// Versions are allowed to be in non-semver form but must be valid file names\n-// and not contain exclamation marks.\n-func decodeVersion(encoding string) (v string, err error) {\n-\tv, ok := decodeString(encoding)\n-\tif !ok {\n-\t\treturn \"\", fmt.Errorf(\"invalid version encoding %q\", encoding)\n-\t}\n-\treturn v, nil\n-}\n-\n-func decodeString(encoding string) (string, bool) {\n-\tvar buf []byte\n-\n-\tbang := false\n-\tfor _, r := range encoding {\n-\t\tif r >= utf8.RuneSelf {\n-\t\t\treturn \"\", false\n-\t\t}\n-\t\tif bang {\n-\t\t\tbang = false\n-\t\t\tif r < 'a' || 'z' < r {\n-\t\t\t\treturn \"\", false\n-\t\t\t}\n-\t\t\tbuf = append(buf, byte(r+'A'-'a'))\n-\t\t\tcontinue\n-\t\t}\n-\t\tif r == '!' {\n-\t\t\tbang = true\n-\t\t\tcontinue\n-\t\t}\n-\t\tif 'A' <= r && r <= 'Z' {\n-\t\t\treturn \"\", false\n-\t\t}\n-\t\tbuf = append(buf, byte(r))\n-\t}\n-\tif bang {\n-\t\treturn \"\", false\n-\t}\n-\treturn string(buf), true\n-}"}, {"sha": "9ed5e4a9a04bfb5dbc77b534c24c7e26e406bca7", "filename": "libgo/go/cmd/go/internal/sumweb/encode_test.go", "status": "removed", "additions": 0, "deletions": 67, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fsumweb%2Fencode_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,67 +0,0 @@\n-// Copyright 2018 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package sumweb\n-\n-import \"testing\"\n-\n-var encodeTests = []struct {\n-\tpath string\n-\tenc  string // empty means same as path\n-}{\n-\t{path: \"ascii.com/abcdefghijklmnopqrstuvwxyz.-+/~_0123456789\"},\n-\t{path: \"github.com/GoogleCloudPlatform/omega\", enc: \"github.com/!google!cloud!platform/omega\"},\n-}\n-\n-func TestEncodePath(t *testing.T) {\n-\t// Check encodings.\n-\tfor _, tt := range encodeTests {\n-\t\tenc, err := encodePath(tt.path)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"encodePath(%q): unexpected error: %v\", tt.path, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\twant := tt.enc\n-\t\tif want == \"\" {\n-\t\t\twant = tt.path\n-\t\t}\n-\t\tif enc != want {\n-\t\t\tt.Errorf(\"encodePath(%q) = %q, want %q\", tt.path, enc, want)\n-\t\t}\n-\t}\n-}\n-\n-var badDecode = []string{\n-\t\"github.com/GoogleCloudPlatform/omega\",\n-\t\"github.com/!google!cloud!platform!/omega\",\n-\t\"github.com/!0google!cloud!platform/omega\",\n-\t\"github.com/!_google!cloud!platform/omega\",\n-\t\"github.com/!!google!cloud!platform/omega\",\n-}\n-\n-func TestDecodePath(t *testing.T) {\n-\t// Check invalid decodings.\n-\tfor _, bad := range badDecode {\n-\t\t_, err := decodePath(bad)\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"DecodePath(%q): succeeded, want error (invalid decoding)\", bad)\n-\t\t}\n-\t}\n-\n-\t// Check encodings.\n-\tfor _, tt := range encodeTests {\n-\t\tenc := tt.enc\n-\t\tif enc == \"\" {\n-\t\t\tenc = tt.path\n-\t\t}\n-\t\tpath, err := decodePath(enc)\n-\t\tif err != nil {\n-\t\t\tt.Errorf(\"decodePath(%q): unexpected error: %v\", enc, err)\n-\t\t\tcontinue\n-\t\t}\n-\t\tif path != tt.path {\n-\t\t\tt.Errorf(\"decodePath(%q) = %q, want %q\", enc, path, tt.path)\n-\t\t}\n-\t}\n-}"}, {"sha": "fb011d4c03f18f2ed50938c86372cf27789eb0f3", "filename": "libgo/go/cmd/go/internal/test/test.go", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftest.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -572,8 +572,9 @@ func runTest(cmd *base.Command, args []string) {\n \t}\n \n \t// Pass timeout to tests if it exists.\n+\t// Prepend rather than appending so that it appears before positional arguments.\n \tif testActualTimeout > 0 {\n-\t\ttestArgs = append(testArgs, \"-test.timeout=\"+testActualTimeout.String())\n+\t\ttestArgs = append([]string{\"-test.timeout=\" + testActualTimeout.String()}, testArgs...)\n \t}\n \n \t// show passing test output (after buffering) with -v flag.\n@@ -828,7 +829,7 @@ func builderTest(b *work.Builder, p *load.Package) (buildAction, runAction, prin\n \tif p.ImportPath == \"command-line-arguments\" {\n \t\telem = p.Name\n \t} else {\n-\t\telem = load.DefaultExecName(p.ImportPath)\n+\t\telem = p.DefaultExecName()\n \t}\n \ttestBinary := elem + \".test\"\n "}, {"sha": "e214b1532bdaead3ed4daabbaceb7aa028107033", "filename": "libgo/go/cmd/go/internal/test/testflag.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftest%2Ftestflag.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -65,7 +65,7 @@ var testFlagDefn = []*cmdflag.Defn{\n func init() {\n \tcmdflag.AddKnownFlags(\"test\", testFlagDefn)\n \tvar cmd base.Command\n-\twork.AddBuildFlags(&cmd)\n+\twork.AddBuildFlags(&cmd, work.DefaultBuildFlags)\n \tcmd.Flag.VisitAll(func(f *flag.Flag) {\n \t\tif f.Name == \"v\" {\n \t\t\t// test overrides the build -v flag\n@@ -88,7 +88,8 @@ func init() {\n //\tgo test fmt -custom-flag-for-fmt-test\n //\tgo test -x math\n func testFlags(usage func(), args []string) (packageNames, passToTest []string) {\n-\targs = str.StringList(cmdflag.FindGOFLAGS(testFlagDefn), args)\n+\tgoflags := cmdflag.FindGOFLAGS(testFlagDefn)\n+\targs = str.StringList(goflags, args)\n \tinPkg := false\n \tvar explicitArgs []string\n \tfor i := 0; i < len(args); i++ {\n@@ -127,6 +128,9 @@ func testFlags(usage func(), args []string) (packageNames, passToTest []string)\n \t\t\tpassToTest = append(passToTest, args[i])\n \t\t\tcontinue\n \t\t}\n+\t\tif i < len(goflags) {\n+\t\t\tf.Present = false // Not actually present on the command line.\n+\t\t}\n \t\tif f.Value != nil {\n \t\t\tif err := f.Value.Set(value); err != nil {\n \t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)"}, {"sha": "c2d9aebe79a0975baec6c4224b4dae1f72cc4394", "filename": "libgo/go/cmd/go/internal/tlog/ct_test.go", "status": "removed", "additions": 0, "deletions": 96, "changes": 96, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fct_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,96 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tlog\n-\n-import (\n-\t\"encoding/json\"\n-\t\"fmt\"\n-\t\"io/ioutil\"\n-\t\"net/http\"\n-\t\"net/url\"\n-\t\"os\"\n-\t\"testing\"\n-)\n-\n-func TestCertificateTransparency(t *testing.T) {\n-\t// Test that we can verify actual Certificate Transparency proofs.\n-\t// (The other tests check that we can verify our own proofs;\n-\t// this is a test that the two are compatible.)\n-\n-\tif testing.Short() {\n-\t\tt.Skip(\"skipping in -short mode\")\n-\t}\n-\n-\tvar root ctTree\n-\thttpGET(t, \"http://ct.googleapis.com/logs/argon2020/ct/v1/get-sth\", &root)\n-\n-\tvar leaf ctEntries\n-\thttpGET(t, \"http://ct.googleapis.com/logs/argon2020/ct/v1/get-entries?start=10000&end=10000\", &leaf)\n-\thash := RecordHash(leaf.Entries[0].Data)\n-\n-\tvar rp ctRecordProof\n-\thttpGET(t, \"http://ct.googleapis.com/logs/argon2020/ct/v1/get-proof-by-hash?tree_size=\"+fmt.Sprint(root.Size)+\"&hash=\"+url.QueryEscape(hash.String()), &rp)\n-\n-\terr := CheckRecord(rp.Proof, root.Size, root.Hash, 10000, hash)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\n-\tvar tp ctTreeProof\n-\thttpGET(t, \"http://ct.googleapis.com/logs/argon2020/ct/v1/get-sth-consistency?first=3654490&second=\"+fmt.Sprint(root.Size), &tp)\n-\n-\toh, _ := ParseHash(\"AuIZ5V6sDUj1vn3Y1K85oOaQ7y+FJJKtyRTl1edIKBQ=\")\n-\terr = CheckTree(tp.Proof, root.Size, root.Hash, 3654490, oh)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-}\n-\n-type ctTree struct {\n-\tSize int64 `json:\"tree_size\"`\n-\tHash Hash  `json:\"sha256_root_hash\"`\n-}\n-\n-type ctEntries struct {\n-\tEntries []*ctEntry\n-}\n-\n-type ctEntry struct {\n-\tData []byte `json:\"leaf_input\"`\n-}\n-\n-type ctRecordProof struct {\n-\tIndex int64       `json:\"leaf_index\"`\n-\tProof RecordProof `json:\"audit_path\"`\n-}\n-\n-type ctTreeProof struct {\n-\tProof TreeProof `json:\"consistency\"`\n-}\n-\n-func httpGET(t *testing.T, url string, targ interface{}) {\n-\tif testing.Verbose() {\n-\t\tprintln()\n-\t\tprintln(url)\n-\t}\n-\tresp, err := http.Get(url)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdefer resp.Body.Close()\n-\tdata, err := ioutil.ReadAll(resp.Body)\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif testing.Verbose() {\n-\t\tos.Stdout.Write(data)\n-\t}\n-\terr = json.Unmarshal(data, targ)\n-\tif err != nil {\n-\t\tprintln(url)\n-\t\tos.Stdout.Write(data)\n-\t\tt.Fatal(err)\n-\t}\n-}"}, {"sha": "a32d6d214362c91874b2474c036514c4ccebb51e", "filename": "libgo/go/cmd/go/internal/tlog/note_test.go", "status": "removed", "additions": 0, "deletions": 117, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Fnote_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,117 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tlog\n-\n-import (\n-\t\"strings\"\n-\t\"testing\"\n-)\n-\n-func TestFormatTree(t *testing.T) {\n-\tn := int64(123456789012)\n-\th := RecordHash([]byte(\"hello world\"))\n-\tgolden := \"go.sum database tree\\n123456789012\\nTszzRgjTG6xce+z2AG31kAXYKBgQVtCSCE40HmuwBb0=\\n\"\n-\tb := FormatTree(Tree{n, h})\n-\tif string(b) != golden {\n-\t\tt.Errorf(\"FormatTree(...) = %q, want %q\", b, golden)\n-\t}\n-}\n-\n-func TestParseTree(t *testing.T) {\n-\tin := \"go.sum database tree\\n123456789012\\nTszzRgjTG6xce+z2AG31kAXYKBgQVtCSCE40HmuwBb0=\\n\"\n-\tgoldH := RecordHash([]byte(\"hello world\"))\n-\tgoldN := int64(123456789012)\n-\ttree, err := ParseTree([]byte(in))\n-\tif tree.N != goldN || tree.Hash != goldH || err != nil {\n-\t\tt.Fatalf(\"ParseTree(...) = Tree{%d, %v}, %v, want Tree{%d, %v}, nil\", tree.N, tree.Hash, err, goldN, goldH)\n-\t}\n-\n-\t// Check invalid trees.\n-\tvar badTrees = []string{\n-\t\t\"not-\" + in,\n-\t\t\"go.sum database tree\\n0xabcdef\\nTszzRgjTG6xce+z2AG31kAXYKBgQVtCSCE40HmuwBb0=\\n\",\n-\t\t\"go.sum database tree\\n123456789012\\nTszzRgjTG6xce+z2AG31kAXYKBgQVtCSCE40HmuwBTOOBIG=\\n\",\n-\t}\n-\tfor _, bad := range badTrees {\n-\t\t_, err := ParseTree([]byte(bad))\n-\t\tif err == nil {\n-\t\t\tt.Fatalf(\"ParseTree(%q) succeeded, want failure\", in)\n-\t\t}\n-\t}\n-\n-\t// Check junk on end is ignored.\n-\tvar goodTrees = []string{\n-\t\tin + \"JOE\",\n-\t\tin + \"JOE\\n\",\n-\t\tin + strings.Repeat(\"JOE\\n\", 1000),\n-\t}\n-\tfor _, good := range goodTrees {\n-\t\t_, err := ParseTree([]byte(good))\n-\t\tif tree.N != goldN || tree.Hash != goldH || err != nil {\n-\t\t\tt.Fatalf(\"ParseTree(...+%q) = Tree{%d, %v}, %v, want Tree{%d, %v}, nil\", good[len(in):], tree.N, tree.Hash, err, goldN, goldH)\n-\t\t}\n-\t}\n-}\n-\n-func TestFormatRecord(t *testing.T) {\n-\tid := int64(123456789012)\n-\ttext := \"hello, world\\n\"\n-\tgolden := \"123456789012\\nhello, world\\n\\n\"\n-\tmsg, err := FormatRecord(id, []byte(text))\n-\tif err != nil {\n-\t\tt.Fatalf(\"FormatRecord: %v\", err)\n-\t}\n-\tif string(msg) != golden {\n-\t\tt.Fatalf(\"FormatRecord(...) = %q, want %q\", msg, golden)\n-\t}\n-\n-\tvar badTexts = []string{\n-\t\t\"\",\n-\t\t\"hello\\nworld\",\n-\t\t\"hello\\n\\nworld\\n\",\n-\t\t\"hello\\x01world\\n\",\n-\t}\n-\tfor _, bad := range badTexts {\n-\t\tmsg, err := FormatRecord(id, []byte(bad))\n-\t\tif err == nil {\n-\t\t\tt.Errorf(\"FormatRecord(id, %q) = %q, want error\", bad, msg)\n-\t\t}\n-\t}\n-}\n-\n-func TestParseRecord(t *testing.T) {\n-\tin := \"123456789012\\nhello, world\\n\\njunk on end\\x01\\xff\"\n-\tgoldID := int64(123456789012)\n-\tgoldText := \"hello, world\\n\"\n-\tgoldRest := \"junk on end\\x01\\xff\"\n-\tid, text, rest, err := ParseRecord([]byte(in))\n-\tif id != goldID || string(text) != goldText || string(rest) != goldRest || err != nil {\n-\t\tt.Fatalf(\"ParseRecord(%q) = %d, %q, %q, %v, want %d, %q, %q, nil\", in, id, text, rest, err, goldID, goldText, goldRest)\n-\t}\n-\n-\tin = \"123456789012\\nhello, world\\n\\n\"\n-\tid, text, rest, err = ParseRecord([]byte(in))\n-\tif id != goldID || string(text) != goldText || len(rest) != 0 || err != nil {\n-\t\tt.Fatalf(\"ParseRecord(%q) = %d, %q, %q, %v, want %d, %q, %q, nil\", in, id, text, rest, err, goldID, goldText, \"\")\n-\t}\n-\tif rest == nil {\n-\t\tt.Fatalf(\"ParseRecord(%q): rest = []byte(nil), want []byte{}\", in)\n-\t}\n-\n-\t// Check invalid records.\n-\tvar badRecords = []string{\n-\t\t\"not-\" + in,\n-\t\t\"123\\nhello\\x01world\\n\\n\",\n-\t\t\"123\\nhello\\xffworld\\n\\n\",\n-\t\t\"123\\nhello world\\n\",\n-\t\t\"0x123\\nhello world\\n\\n\",\n-\t}\n-\tfor _, bad := range badRecords {\n-\t\tid, text, rest, err := ParseRecord([]byte(bad))\n-\t\tif err == nil {\n-\t\t\tt.Fatalf(\"ParseRecord(%q) = %d, %q, %q, nil, want error\", in, id, text, rest)\n-\t\t}\n-\t}\n-}"}, {"sha": "584e728c1bb558c8252300277daae0ce1a1c0c8d", "filename": "libgo/go/cmd/go/internal/tlog/tlog_test.go", "status": "removed", "additions": 0, "deletions": 269, "changes": 269, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Ftlog%2Ftlog_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,269 +0,0 @@\n-// Copyright 2019 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package tlog\n-\n-import (\n-\t\"bytes\"\n-\t\"fmt\"\n-\t\"testing\"\n-)\n-\n-type testHashStorage []Hash\n-\n-func (t testHashStorage) ReadHash(level int, n int64) (Hash, error) {\n-\treturn t[StoredHashIndex(level, n)], nil\n-}\n-\n-func (t testHashStorage) ReadHashes(index []int64) ([]Hash, error) {\n-\t// It's not required by HashReader that indexes be in increasing order,\n-\t// but check that the functions we are testing only ever ask for\n-\t// indexes in increasing order.\n-\tfor i := 1; i < len(index); i++ {\n-\t\tif index[i-1] >= index[i] {\n-\t\t\tpanic(\"indexes out of order\")\n-\t\t}\n-\t}\n-\n-\tout := make([]Hash, len(index))\n-\tfor i, x := range index {\n-\t\tout[i] = t[x]\n-\t}\n-\treturn out, nil\n-}\n-\n-type testTilesStorage struct {\n-\tunsaved int\n-\tm       map[Tile][]byte\n-}\n-\n-func (t testTilesStorage) Height() int {\n-\treturn 2\n-}\n-\n-func (t *testTilesStorage) SaveTiles(tiles []Tile, data [][]byte) {\n-\tt.unsaved -= len(tiles)\n-}\n-\n-func (t *testTilesStorage) ReadTiles(tiles []Tile) ([][]byte, error) {\n-\tout := make([][]byte, len(tiles))\n-\tfor i, tile := range tiles {\n-\t\tout[i] = t.m[tile]\n-\t}\n-\tt.unsaved += len(tiles)\n-\treturn out, nil\n-}\n-\n-func TestTree(t *testing.T) {\n-\tvar trees []Hash\n-\tvar leafhashes []Hash\n-\tvar storage testHashStorage\n-\ttiles := make(map[Tile][]byte)\n-\tconst testH = 2\n-\tfor i := int64(0); i < 100; i++ {\n-\t\tdata := []byte(fmt.Sprintf(\"leaf %d\", i))\n-\t\thashes, err := StoredHashes(i, data, storage)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\t\tleafhashes = append(leafhashes, RecordHash(data))\n-\t\toldStorage := len(storage)\n-\t\tstorage = append(storage, hashes...)\n-\t\tif count := StoredHashCount(i + 1); count != int64(len(storage)) {\n-\t\t\tt.Errorf(\"StoredHashCount(%d) = %d, have %d StoredHashes\", i+1, count, len(storage))\n-\t\t}\n-\t\tth, err := TreeHash(i+1, storage)\n-\t\tif err != nil {\n-\t\t\tt.Fatal(err)\n-\t\t}\n-\n-\t\tfor _, tile := range NewTiles(testH, i, i+1) {\n-\t\t\tdata, err := ReadTileData(tile, storage)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\told := Tile{H: tile.H, L: tile.L, N: tile.N, W: tile.W - 1}\n-\t\t\toldData := tiles[old]\n-\t\t\tif len(oldData) != len(data)-HashSize || !bytes.Equal(oldData, data[:len(oldData)]) {\n-\t\t\t\tt.Fatalf(\"tile %v not extending earlier tile %v\", tile.Path(), old.Path())\n-\t\t\t}\n-\t\t\ttiles[tile] = data\n-\t\t}\n-\t\tfor _, tile := range NewTiles(testH, 0, i+1) {\n-\t\t\tdata, err := ReadTileData(tile, storage)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif !bytes.Equal(tiles[tile], data) {\n-\t\t\t\tt.Fatalf(\"mismatch at %+v\", tile)\n-\t\t\t}\n-\t\t}\n-\t\tfor _, tile := range NewTiles(testH, i/2, i+1) {\n-\t\t\tdata, err := ReadTileData(tile, storage)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif !bytes.Equal(tiles[tile], data) {\n-\t\t\t\tt.Fatalf(\"mismatch at %+v\", tile)\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Check that all the new hashes are readable from their tiles.\n-\t\tfor j := oldStorage; j < len(storage); j++ {\n-\t\t\ttile := TileForIndex(testH, int64(j))\n-\t\t\tdata, ok := tiles[tile]\n-\t\t\tif !ok {\n-\t\t\t\tt.Log(NewTiles(testH, 0, i+1))\n-\t\t\t\tt.Fatalf(\"TileForIndex(%d, %d) = %v, not yet stored (i=%d, stored %d)\", testH, j, tile.Path(), i, len(storage))\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\th, err := HashFromTile(tile, data, int64(j))\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatal(err)\n-\t\t\t}\n-\t\t\tif h != storage[j] {\n-\t\t\t\tt.Errorf(\"HashFromTile(%v, %d) = %v, want %v\", tile.Path(), int64(j), h, storage[j])\n-\t\t\t}\n-\t\t}\n-\n-\t\ttrees = append(trees, th)\n-\n-\t\t// Check that leaf proofs work, for all trees and leaves so far.\n-\t\tfor j := int64(0); j <= i; j++ {\n-\t\t\tp, err := ProveRecord(i+1, j, storage)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"ProveRecord(%d, %d): %v\", i+1, j, err)\n-\t\t\t}\n-\t\t\tif err := CheckRecord(p, i+1, th, j, leafhashes[j]); err != nil {\n-\t\t\t\tt.Fatalf(\"CheckRecord(%d, %d): %v\", i+1, j, err)\n-\t\t\t}\n-\t\t\tfor k := range p {\n-\t\t\t\tp[k][0] ^= 1\n-\t\t\t\tif err := CheckRecord(p, i+1, th, j, leafhashes[j]); err == nil {\n-\t\t\t\t\tt.Fatalf(\"CheckRecord(%d, %d) succeeded with corrupt proof hash #%d!\", i+1, j, k)\n-\t\t\t\t}\n-\t\t\t\tp[k][0] ^= 1\n-\t\t\t}\n-\t\t}\n-\n-\t\t// Check that leaf proofs work using TileReader.\n-\t\t// To prove a leaf that way, all you have to do is read and verify its hash.\n-\t\tstorage := &testTilesStorage{m: tiles}\n-\t\tthr := TileHashReader(Tree{i + 1, th}, storage)\n-\t\tfor j := int64(0); j <= i; j++ {\n-\t\t\th, err := thr.ReadHashes([]int64{StoredHashIndex(0, j)})\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"TileHashReader(%d).ReadHashes(%d): %v\", i+1, j, err)\n-\t\t\t}\n-\t\t\tif h[0] != leafhashes[j] {\n-\t\t\t\tt.Fatalf(\"TileHashReader(%d).ReadHashes(%d) returned wrong hash\", i+1, j)\n-\t\t\t}\n-\n-\t\t\t// Even though reading the hash suffices,\n-\t\t\t// check we can generate the proof too.\n-\t\t\tp, err := ProveRecord(i+1, j, thr)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"ProveRecord(%d, %d, TileHashReader(%d)): %v\", i+1, j, i+1, err)\n-\t\t\t}\n-\t\t\tif err := CheckRecord(p, i+1, th, j, leafhashes[j]); err != nil {\n-\t\t\t\tt.Fatalf(\"CheckRecord(%d, %d, TileHashReader(%d)): %v\", i+1, j, i+1, err)\n-\t\t\t}\n-\t\t}\n-\t\tif storage.unsaved != 0 {\n-\t\t\tt.Fatalf(\"TileHashReader(%d) did not save %d tiles\", i+1, storage.unsaved)\n-\t\t}\n-\n-\t\t// Check that ReadHashes will give an error if the index is not in the tree.\n-\t\tif _, err := thr.ReadHashes([]int64{(i + 1) * 2}); err == nil {\n-\t\t\tt.Fatalf(\"TileHashReader(%d).ReadHashes(%d) for index not in tree <nil>, want err\", i, i+1)\n-\t\t}\n-\t\tif storage.unsaved != 0 {\n-\t\t\tt.Fatalf(\"TileHashReader(%d) did not save %d tiles\", i+1, storage.unsaved)\n-\t\t}\n-\n-\t\t// Check that tree proofs work, for all trees so far, using TileReader.\n-\t\t// To prove a tree that way, all you have to do is compute and verify its hash.\n-\t\tfor j := int64(0); j <= i; j++ {\n-\t\t\th, err := TreeHash(j+1, thr)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"TreeHash(%d, TileHashReader(%d)): %v\", j, i+1, err)\n-\t\t\t}\n-\t\t\tif h != trees[j] {\n-\t\t\t\tt.Fatalf(\"TreeHash(%d, TileHashReader(%d)) = %x, want %x (%v)\", j, i+1, h[:], trees[j][:], trees[j])\n-\t\t\t}\n-\n-\t\t\t// Even though computing the subtree hash suffices,\n-\t\t\t// check that we can generate the proof too.\n-\t\t\tp, err := ProveTree(i+1, j+1, thr)\n-\t\t\tif err != nil {\n-\t\t\t\tt.Fatalf(\"ProveTree(%d, %d): %v\", i+1, j+1, err)\n-\t\t\t}\n-\t\t\tif err := CheckTree(p, i+1, th, j+1, trees[j]); err != nil {\n-\t\t\t\tt.Fatalf(\"CheckTree(%d, %d): %v [%v]\", i+1, j+1, err, p)\n-\t\t\t}\n-\t\t\tfor k := range p {\n-\t\t\t\tp[k][0] ^= 1\n-\t\t\t\tif err := CheckTree(p, i+1, th, j+1, trees[j]); err == nil {\n-\t\t\t\t\tt.Fatalf(\"CheckTree(%d, %d) succeeded with corrupt proof hash #%d!\", i+1, j+1, k)\n-\t\t\t\t}\n-\t\t\t\tp[k][0] ^= 1\n-\t\t\t}\n-\t\t}\n-\t\tif storage.unsaved != 0 {\n-\t\t\tt.Fatalf(\"TileHashReader(%d) did not save %d tiles\", i+1, storage.unsaved)\n-\t\t}\n-\t}\n-}\n-\n-func TestSplitStoredHashIndex(t *testing.T) {\n-\tfor l := 0; l < 10; l++ {\n-\t\tfor n := int64(0); n < 100; n++ {\n-\t\t\tx := StoredHashIndex(l, n)\n-\t\t\tl1, n1 := SplitStoredHashIndex(x)\n-\t\t\tif l1 != l || n1 != n {\n-\t\t\t\tt.Fatalf(\"StoredHashIndex(%d, %d) = %d, but SplitStoredHashIndex(%d) = %d, %d\", l, n, x, x, l1, n1)\n-\t\t\t}\n-\t\t}\n-\t}\n-}\n-\n-// TODO(rsc): Test invalid paths too, like \"tile/3/5/123/456/078\".\n-var tilePaths = []struct {\n-\tpath string\n-\ttile Tile\n-}{\n-\t{\"tile/4/0/001\", Tile{4, 0, 1, 16}},\n-\t{\"tile/4/0/001.p/5\", Tile{4, 0, 1, 5}},\n-\t{\"tile/3/5/x123/x456/078\", Tile{3, 5, 123456078, 8}},\n-\t{\"tile/3/5/x123/x456/078.p/2\", Tile{3, 5, 123456078, 2}},\n-\t{\"tile/1/0/x003/x057/500\", Tile{1, 0, 3057500, 2}},\n-\t{\"tile/3/5/123/456/078\", Tile{}},\n-\t{\"tile/3/-1/123/456/078\", Tile{}},\n-\t{\"tile/1/data/x003/x057/500\", Tile{1, -1, 3057500, 2}},\n-}\n-\n-func TestTilePath(t *testing.T) {\n-\tfor _, tt := range tilePaths {\n-\t\tif tt.tile.H > 0 {\n-\t\t\tp := tt.tile.Path()\n-\t\t\tif p != tt.path {\n-\t\t\t\tt.Errorf(\"%+v.Path() = %q, want %q\", tt.tile, p, tt.path)\n-\t\t\t}\n-\t\t}\n-\t\ttile, err := ParseTilePath(tt.path)\n-\t\tif err != nil {\n-\t\t\tif tt.tile.H == 0 {\n-\t\t\t\t// Expected error.\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tt.Errorf(\"ParseTilePath(%q): %v\", tt.path, err)\n-\t\t} else if tile != tt.tile {\n-\t\t\tif tt.tile.H == 0 {\n-\t\t\t\tt.Errorf(\"ParseTilePath(%q): expected error, got %+v\", tt.path, tt.tile)\n-\t\t\t\tcontinue\n-\t\t\t}\n-\t\t\tt.Errorf(\"ParseTilePath(%q) = %+v, want %+v\", tt.path, tile, tt.tile)\n-\t\t}\n-\t}\n-}"}, {"sha": "660a739fbbd4d3b9d17a0bd9ea2633971e102130", "filename": "libgo/go/cmd/go/internal/vet/vet.go", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvet.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -51,6 +51,7 @@ func runVet(cmd *base.Command, args []string) {\n \n \twork.BuildInit()\n \twork.VetFlags = vetFlags\n+\twork.VetExplicit = true\n \tif vetTool != \"\" {\n \t\tvar err error\n \t\twork.VetTool, err = filepath.Abs(vetTool)"}, {"sha": "e3de48bbffaa4b4be2252b1d95ab197d2a10db94", "filename": "libgo/go/cmd/go/internal/vet/vetflag.go", "status": "modified", "additions": 6, "deletions": 2, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fvet%2Fvetflag.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -114,7 +114,7 @@ func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n \n \t// Add build flags to vetFlagDefn.\n \tvar cmd base.Command\n-\twork.AddBuildFlags(&cmd)\n+\twork.AddBuildFlags(&cmd, work.DefaultBuildFlags)\n \t// This flag declaration is a placeholder:\n \t// -vettool is actually parsed by the init function above.\n \tcmd.Flag.StringVar(new(string), \"vettool\", \"\", \"path to vet tool binary\")\n@@ -126,7 +126,8 @@ func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n \t})\n \n \t// Process args.\n-\targs = str.StringList(cmdflag.FindGOFLAGS(vetFlagDefn), args)\n+\tgoflags := cmdflag.FindGOFLAGS(vetFlagDefn)\n+\targs = str.StringList(goflags, args)\n \tfor i := 0; i < len(args); i++ {\n \t\tif !strings.HasPrefix(args[i], \"-\") {\n \t\t\treturn args[:i], args[i:]\n@@ -139,6 +140,9 @@ func vetFlags(usage func(), args []string) (passToVet, packageNames []string) {\n \t\t\tbase.SetExitStatus(2)\n \t\t\tbase.Exit()\n \t\t}\n+\t\tif i < len(goflags) {\n+\t\t\tf.Present = false // Not actually present on the command line.\n+\t\t}\n \t\tif f.Value != nil {\n \t\t\tif err := f.Value.Set(value); err != nil {\n \t\t\t\tbase.Fatalf(\"invalid flag argument for -%s: %v\", f.Name, err)"}, {"sha": "ad99eb2f8c392633eb9d41bc5f86b70df2e9a64f", "filename": "libgo/go/cmd/go/internal/web/api.go", "status": "modified", "additions": 122, "deletions": 3, "changes": 125, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fapi.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,12 +10,15 @@\n package web\n \n import (\n+\t\"bytes\"\n \t\"fmt\"\n \t\"io\"\n \t\"io/ioutil\"\n \t\"net/url\"\n \t\"os\"\n \t\"strings\"\n+\t\"unicode\"\n+\t\"unicode/utf8\"\n )\n \n // SecurityMode specifies whether a function should make network\n@@ -34,16 +37,43 @@ type HTTPError struct {\n \tURL        string // redacted\n \tStatus     string\n \tStatusCode int\n+\tErr        error  // underlying error, if known\n+\tDetail     string // limited to maxErrorDetailLines and maxErrorDetailBytes\n }\n \n+const (\n+\tmaxErrorDetailLines = 8\n+\tmaxErrorDetailBytes = maxErrorDetailLines * 81\n+)\n+\n func (e *HTTPError) Error() string {\n+\tif e.Detail != \"\" {\n+\t\tdetailSep := \" \"\n+\t\tif strings.ContainsRune(e.Detail, '\\n') {\n+\t\t\tdetailSep = \"\\n\\t\"\n+\t\t}\n+\t\treturn fmt.Sprintf(\"reading %s: %v\\n\\tserver response:%s%s\", e.URL, e.Status, detailSep, e.Detail)\n+\t}\n+\n+\tif err := e.Err; err != nil {\n+\t\tif pErr, ok := e.Err.(*os.PathError); ok && strings.HasSuffix(e.URL, pErr.Path) {\n+\t\t\t// Remove the redundant copy of the path.\n+\t\t\terr = pErr.Err\n+\t\t}\n+\t\treturn fmt.Sprintf(\"reading %s: %v\", e.URL, err)\n+\t}\n+\n \treturn fmt.Sprintf(\"reading %s: %v\", e.URL, e.Status)\n }\n \n func (e *HTTPError) Is(target error) bool {\n \treturn target == os.ErrNotExist && (e.StatusCode == 404 || e.StatusCode == 410)\n }\n \n+func (e *HTTPError) Unwrap() error {\n+\treturn e.Err\n+}\n+\n // GetBytes returns the body of the requested resource, or an error if the\n // response status was not http.StatusOK.\n //\n@@ -69,16 +99,69 @@ type Response struct {\n \tStatus     string\n \tStatusCode int\n \tHeader     map[string][]string\n-\tBody       io.ReadCloser\n+\tBody       io.ReadCloser // Either the original body or &errorDetail.\n+\n+\tfileErr     error\n+\terrorDetail errorDetailBuffer\n }\n \n // Err returns an *HTTPError corresponding to the response r.\n-// It returns nil if the response r has StatusCode 200 or 0 (unset).\n+// If the response r has StatusCode 200 or 0 (unset), Err returns nil.\n+// Otherwise, Err may read from r.Body in order to extract relevant error detail.\n func (r *Response) Err() error {\n \tif r.StatusCode == 200 || r.StatusCode == 0 {\n \t\treturn nil\n \t}\n-\treturn &HTTPError{URL: r.URL, Status: r.Status, StatusCode: r.StatusCode}\n+\n+\treturn &HTTPError{\n+\t\tURL:        r.URL,\n+\t\tStatus:     r.Status,\n+\t\tStatusCode: r.StatusCode,\n+\t\tErr:        r.fileErr,\n+\t\tDetail:     r.formatErrorDetail(),\n+\t}\n+}\n+\n+// formatErrorDetail converts r.errorDetail (a prefix of the output of r.Body)\n+// into a short, tab-indented summary.\n+func (r *Response) formatErrorDetail() string {\n+\tif r.Body != &r.errorDetail {\n+\t\treturn \"\" // Error detail collection not enabled.\n+\t}\n+\n+\t// Ensure that r.errorDetail has been populated.\n+\t_, _ = io.Copy(ioutil.Discard, r.Body)\n+\n+\ts := r.errorDetail.buf.String()\n+\tif !utf8.ValidString(s) {\n+\t\treturn \"\" // Don't try to recover non-UTF-8 error messages.\n+\t}\n+\tfor _, r := range s {\n+\t\tif !unicode.IsGraphic(r) && !unicode.IsSpace(r) {\n+\t\t\treturn \"\" // Don't let the server do any funny business with the user's terminal.\n+\t\t}\n+\t}\n+\n+\tvar detail strings.Builder\n+\tfor i, line := range strings.Split(s, \"\\n\") {\n+\t\tif strings.TrimSpace(line) == \"\" {\n+\t\t\tbreak // Stop at the first blank line.\n+\t\t}\n+\t\tif i > 0 {\n+\t\t\tdetail.WriteString(\"\\n\\t\")\n+\t\t}\n+\t\tif i >= maxErrorDetailLines {\n+\t\t\tdetail.WriteString(\"[Truncated: too many lines.]\")\n+\t\t\tbreak\n+\t\t}\n+\t\tif detail.Len()+len(line) > maxErrorDetailBytes {\n+\t\t\tdetail.WriteString(\"[Truncated: too long.]\")\n+\t\t\tbreak\n+\t\t}\n+\t\tdetail.WriteString(line)\n+\t}\n+\n+\treturn detail.String()\n }\n \n // Get returns the body of the HTTP or HTTPS resource specified at the given URL.\n@@ -131,3 +214,39 @@ func Join(u *url.URL, path string) *url.URL {\n \tj.RawPath = strings.TrimSuffix(u.RawPath, \"/\") + \"/\" + strings.TrimPrefix(path, \"/\")\n \treturn &j\n }\n+\n+// An errorDetailBuffer is an io.ReadCloser that copies up to\n+// maxErrorDetailLines into a buffer for later inspection.\n+type errorDetailBuffer struct {\n+\tr        io.ReadCloser\n+\tbuf      strings.Builder\n+\tbufLines int\n+}\n+\n+func (b *errorDetailBuffer) Close() error {\n+\treturn b.r.Close()\n+}\n+\n+func (b *errorDetailBuffer) Read(p []byte) (n int, err error) {\n+\tn, err = b.r.Read(p)\n+\n+\t// Copy the first maxErrorDetailLines+1 lines into b.buf,\n+\t// discarding any further lines.\n+\t//\n+\t// Note that the read may begin or end in the middle of a UTF-8 character,\n+\t// so don't try to do anything fancy with characters that encode to larger\n+\t// than one byte.\n+\tif b.bufLines <= maxErrorDetailLines {\n+\t\tfor _, line := range bytes.SplitAfterN(p[:n], []byte(\"\\n\"), maxErrorDetailLines-b.bufLines) {\n+\t\t\tb.buf.Write(line)\n+\t\t\tif len(line) > 0 && line[len(line)-1] == '\\n' {\n+\t\t\t\tb.bufLines++\n+\t\t\t\tif b.bufLines > maxErrorDetailLines {\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\treturn n, err\n+}"}, {"sha": "63394690453dd018a098de3d1b532b94ee35edbb", "filename": "libgo/go/cmd/go/internal/web/file_test.go", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Ffile_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -19,6 +19,8 @@ func TestGetFileURL(t *testing.T) {\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}\n+\tdefer os.Remove(f.Name())\n+\n \tif _, err := f.WriteString(content); err != nil {\n \t\tt.Error(err)\n \t}"}, {"sha": "5e4319b00e9d5b794abf851b0f0c3acd9e4b53a8", "filename": "libgo/go/cmd/go/internal/web/http.go", "status": "modified", "additions": 23, "deletions": 6, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Fhttp.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -14,7 +14,7 @@ package web\n import (\n \t\"crypto/tls\"\n \t\"fmt\"\n-\t\"io/ioutil\"\n+\t\"mime\"\n \t\"net/http\"\n \turlpkg \"net/url\"\n \t\"os\"\n@@ -64,7 +64,7 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\t\tStatus:     \"404 testing\",\n \t\t\tStatusCode: 404,\n \t\t\tHeader:     make(map[string][]string),\n-\t\t\tBody:       ioutil.NopCloser(strings.NewReader(\"\")),\n+\t\t\tBody:       http.NoBody,\n \t\t}\n \t\tif cfg.BuildX {\n \t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", Redacted(url), res.Status, time.Since(start).Seconds())\n@@ -111,7 +111,7 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\tfetched, res, err = fetch(secure)\n \t\tif err != nil {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(url), err)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(secure), err)\n \t\t\t}\n \t\t\tif security != Insecure || url.Scheme == \"https\" {\n \t\t\t\t// HTTPS failed, and we can't fall back to plain HTTP.\n@@ -146,15 +146,15 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t\tinsecure.Scheme = \"http\"\n \t\tif insecure.User != nil && security != Insecure {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure credentials\\n\", Redacted(url))\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: insecure credentials\\n\", Redacted(insecure))\n \t\t\t}\n \t\t\treturn nil, fmt.Errorf(\"refusing to pass credentials to insecure URL: %s\", Redacted(insecure))\n \t\t}\n \n \t\tfetched, res, err = fetch(insecure)\n \t\tif err != nil {\n \t\t\tif cfg.BuildX {\n-\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(url), err)\n+\t\t\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v\\n\", Redacted(insecure), err)\n \t\t\t}\n \t\t\t// HTTP failed, and we already tried HTTPS if applicable.\n \t\t\t// Report the error from the HTTP attempt.\n@@ -165,15 +165,30 @@ func get(security SecurityMode, url *urlpkg.URL) (*Response, error) {\n \t// Note: accepting a non-200 OK here, so people can serve a\n \t// meta import in their http 404 page.\n \tif cfg.BuildX {\n-\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", Redacted(url), res.Status, time.Since(start).Seconds())\n+\t\tfmt.Fprintf(os.Stderr, \"# get %s: %v (%.3fs)\\n\", Redacted(fetched), res.Status, time.Since(start).Seconds())\n \t}\n+\n \tr := &Response{\n \t\tURL:        Redacted(fetched),\n \t\tStatus:     res.Status,\n \t\tStatusCode: res.StatusCode,\n \t\tHeader:     map[string][]string(res.Header),\n \t\tBody:       res.Body,\n \t}\n+\n+\tif res.StatusCode != http.StatusOK {\n+\t\tcontentType := res.Header.Get(\"Content-Type\")\n+\t\tif mediaType, params, _ := mime.ParseMediaType(contentType); mediaType == \"text/plain\" {\n+\t\t\tswitch charset := strings.ToLower(params[\"charset\"]); charset {\n+\t\t\tcase \"us-ascii\", \"utf-8\", \"\":\n+\t\t\t\t// Body claims to be plain text in UTF-8 or a subset thereof.\n+\t\t\t\t// Try to extract a useful error message from it.\n+\t\t\t\tr.errorDetail.r = res.Body\n+\t\t\t\tr.Body = &r.errorDetail\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \treturn r, nil\n }\n \n@@ -190,6 +205,7 @@ func getFile(u *urlpkg.URL) (*Response, error) {\n \t\t\tStatus:     http.StatusText(http.StatusNotFound),\n \t\t\tStatusCode: http.StatusNotFound,\n \t\t\tBody:       http.NoBody,\n+\t\t\tfileErr:    err,\n \t\t}, nil\n \t}\n \n@@ -199,6 +215,7 @@ func getFile(u *urlpkg.URL) (*Response, error) {\n \t\t\tStatus:     http.StatusText(http.StatusForbidden),\n \t\t\tStatusCode: http.StatusForbidden,\n \t\t\tBody:       http.NoBody,\n+\t\t\tfileErr:    err,\n \t\t}, nil\n \t}\n "}, {"sha": "2641ee62bfa5518b7d4500f9df55ffa8207afe3c", "filename": "libgo/go/cmd/go/internal/web/url_other.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build !windows\n+// +build !windows\n \n package web\n "}, {"sha": "aa5663355efb9c262012ed3b31d7954a73c6bc75", "filename": "libgo/go/cmd/go/internal/web/url_other_test.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fweb%2Furl_other_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,7 +2,7 @@\n // Use of this source code is governed by a BSD-style\n // license that can be found in the LICENSE file.\n \n-//+build !windows\n+// +build !windows\n \n package web\n "}, {"sha": "db422fd9935827c098371cfe74954f7526c2c8bb", "filename": "libgo/go/cmd/go/internal/work/action.go", "status": "modified", "additions": 11, "deletions": 3, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Faction.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -291,11 +291,12 @@ func (b *Builder) Init() {\n \t\t}\n \t}\n \n-\tif _, ok := cfg.OSArchSupportsCgo[cfg.Goos+\"/\"+cfg.Goarch]; !ok && cfg.BuildContext.Compiler == \"gc\" {\n-\t\tfmt.Fprintf(os.Stderr, \"cmd/go: unsupported GOOS/GOARCH pair %s/%s\\n\", cfg.Goos, cfg.Goarch)\n+\tif err := CheckGOOSARCHPair(cfg.Goos, cfg.Goarch); err != nil {\n+\t\tfmt.Fprintf(os.Stderr, \"cmd/go: %v\\n\", err)\n \t\tbase.SetExitStatus(2)\n \t\tbase.Exit()\n \t}\n+\n \tfor _, tag := range cfg.BuildContext.BuildTags {\n \t\tif strings.Contains(tag, \",\") {\n \t\t\tfmt.Fprintf(os.Stderr, \"cmd/go: -tags space-separated list contains comma\\n\")\n@@ -305,6 +306,13 @@ func (b *Builder) Init() {\n \t}\n }\n \n+func CheckGOOSARCHPair(goos, goarch string) error {\n+\tif _, ok := cfg.OSArchSupportsCgo[goos+\"/\"+goarch]; !ok && cfg.BuildContext.Compiler == \"gc\" {\n+\t\treturn fmt.Errorf(\"unsupported GOOS/GOARCH pair %s/%s\", goos, goarch)\n+\t}\n+\treturn nil\n+}\n+\n // NewObjdir returns the name of a fresh object directory under b.WorkDir.\n // It is up to the caller to call b.Mkdir on the result at an appropriate time.\n // The result ends in a slash, so that file names in that directory\n@@ -707,7 +715,7 @@ func (b *Builder) addInstallHeaderAction(a *Action) {\n }\n \n // buildmodeShared takes the \"go build\" action a1 into the building of a shared library of a1.Deps.\n-// That is, the input a1 represents \"go build pkgs\" and the result represents \"go build -buidmode=shared pkgs\".\n+// That is, the input a1 represents \"go build pkgs\" and the result represents \"go build -buildmode=shared pkgs\".\n func (b *Builder) buildmodeShared(mode, depMode BuildMode, args []string, pkgs []*load.Package, a1 *Action) *Action {\n \tname, err := libname(args, pkgs)\n \tif err != nil {"}, {"sha": "e3b25c937c345df292676d5ddde5fc0fea172477", "filename": "libgo/go/cmd/go/internal/work/build.go", "status": "modified", "additions": 45, "deletions": 12, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -62,11 +62,13 @@ and test commands:\n \t\tThe default is the number of CPUs available.\n \t-race\n \t\tenable data race detection.\n-\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64 and windows/amd64.\n+\t\tSupported only on linux/amd64, freebsd/amd64, darwin/amd64, windows/amd64,\n+\t\tlinux/ppc64le and linux/arm64 (only for 48-bit VMA).\n \t-msan\n \t\tenable interoperation with memory sanitizer.\n \t\tSupported only on linux/amd64, linux/arm64\n \t\tand only with Clang/LLVM as the host C compiler.\n+\t\tOn linux/arm64, pie build mode will be used.\n \t-v\n \t\tprint the names of packages as they are compiled.\n \t-work\n@@ -95,11 +97,21 @@ and test commands:\n \t-ldflags '[pattern=]arg list'\n \t\targuments to pass on each go tool link invocation.\n \t-linkshared\n-\t\tlink against shared libraries previously created with\n-\t\t-buildmode=shared.\n+\t\tbuild code that will be linked against shared libraries previously\n+\t\tcreated with -buildmode=shared.\n \t-mod mode\n-\t\tmodule download mode to use: readonly or vendor.\n+\t\tmodule download mode to use: readonly, vendor, or mod.\n \t\tSee 'go help modules' for more.\n+\t-modcacherw\n+\t\tleave newly-created directories in the module cache read-write\n+\t\tinstead of making them read-only.\n+\t-modfile file\n+\t\tin module aware mode, read (and possibly write) an alternate go.mod\n+\t\tfile instead of the one in the module root directory. A file named\n+\t\t\"go.mod\" must still be present in order to determine the module root\n+\t\tdirectory, but it is not accessed. When -modfile is specified, an\n+\t\talternate go.sum file is also used: its path is derived from the\n+\t\t-modfile flag by trimming the \".mod\" extension and appending \".sum\".\n \t-pkgdir dir\n \t\tinstall and load all packages from dir instead of the usual locations.\n \t\tFor example, when building with a non-standard configuration,\n@@ -165,8 +177,8 @@ func init() {\n \n \tCmdInstall.Flag.BoolVar(&cfg.BuildI, \"i\", false, \"\")\n \n-\tAddBuildFlags(CmdBuild)\n-\tAddBuildFlags(CmdInstall)\n+\tAddBuildFlags(CmdBuild, DefaultBuildFlags)\n+\tAddBuildFlags(CmdInstall, DefaultBuildFlags)\n }\n \n // Note that flags consulted by other parts of the code\n@@ -214,9 +226,17 @@ func init() {\n \t}\n }\n \n-// addBuildFlags adds the flags common to the build, clean, get,\n+type BuildFlagMask int\n+\n+const (\n+\tDefaultBuildFlags BuildFlagMask = 0\n+\tOmitModFlag       BuildFlagMask = 1 << iota\n+\tOmitModCommonFlags\n+)\n+\n+// AddBuildFlags adds the flags common to the build, clean, get,\n // install, list, run, and test commands.\n-func AddBuildFlags(cmd *base.Command) {\n+func AddBuildFlags(cmd *base.Command, mask BuildFlagMask) {\n \tcmd.Flag.BoolVar(&cfg.BuildA, \"a\", false, \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildN, \"n\", false, \"\")\n \tcmd.Flag.IntVar(&cfg.BuildP, \"p\", cfg.BuildP, \"\")\n@@ -228,7 +248,12 @@ func AddBuildFlags(cmd *base.Command) {\n \tcmd.Flag.StringVar(&cfg.BuildBuildmode, \"buildmode\", \"default\", \"\")\n \tcmd.Flag.Var(&load.BuildGcflags, \"gcflags\", \"\")\n \tcmd.Flag.Var(&load.BuildGccgoflags, \"gccgoflags\", \"\")\n-\tcmd.Flag.StringVar(&cfg.BuildMod, \"mod\", \"\", \"\")\n+\tif mask&OmitModFlag == 0 {\n+\t\tcmd.Flag.StringVar(&cfg.BuildMod, \"mod\", \"\", \"\")\n+\t}\n+\tif mask&OmitModCommonFlags == 0 {\n+\t\tAddModCommonFlags(cmd)\n+\t}\n \tcmd.Flag.StringVar(&cfg.BuildContext.InstallSuffix, \"installsuffix\", \"\", \"\")\n \tcmd.Flag.Var(&load.BuildLdflags, \"ldflags\", \"\")\n \tcmd.Flag.BoolVar(&cfg.BuildLinkshared, \"linkshared\", false, \"\")\n@@ -244,6 +269,13 @@ func AddBuildFlags(cmd *base.Command) {\n \tcmd.Flag.StringVar(&cfg.DebugActiongraph, \"debug-actiongraph\", \"\", \"\")\n }\n \n+// AddModCommonFlags adds the module-related flags common to build commands\n+// and 'go mod' subcommands.\n+func AddModCommonFlags(cmd *base.Command) {\n+\tcmd.Flag.BoolVar(&cfg.ModCacheRW, \"modcacherw\", false, \"\")\n+\tcmd.Flag.StringVar(&cfg.ModFile, \"modfile\", \"\", \"\")\n+}\n+\n // tagsFlag is the implementation of the -tags flag.\n type tagsFlag []string\n \n@@ -318,7 +350,7 @@ func runBuild(cmd *base.Command, args []string) {\n \texplicitO := len(cfg.BuildO) > 0\n \n \tif len(pkgs) == 1 && pkgs[0].Name == \"main\" && cfg.BuildO == \"\" {\n-\t\tcfg.BuildO = load.DefaultExecName(pkgs[0].ImportPath)\n+\t\tcfg.BuildO = pkgs[0].DefaultExecName()\n \t\tcfg.BuildO += cfg.ExeSuffix\n \t}\n \n@@ -362,7 +394,8 @@ func runBuild(cmd *base.Command, args []string) {\n \t\t\t\tif p.Name != \"main\" {\n \t\t\t\t\tcontinue\n \t\t\t\t}\n-\t\t\t\tp.Target = filepath.Join(cfg.BuildO, load.DefaultExecName(p.ImportPath))\n+\n+\t\t\t\tp.Target = filepath.Join(cfg.BuildO, p.DefaultExecName())\n \t\t\t\tp.Target += cfg.ExeSuffix\n \t\t\t\tp.Stale = true\n \t\t\t\tp.StaleReason = \"build -o flag in use\"\n@@ -584,7 +617,7 @@ func InstallPackages(patterns []string, pkgs []*load.Package) {\n \tif len(patterns) == 0 && len(pkgs) == 1 && pkgs[0].Name == \"main\" {\n \t\t// Compute file 'go build' would have created.\n \t\t// If it exists and is an executable file, remove it.\n-\t\ttarg := load.DefaultExecName(pkgs[0].ImportPath)\n+\t\ttarg := pkgs[0].DefaultExecName()\n \t\ttarg += cfg.ExeSuffix\n \t\tif filepath.Join(pkgs[0].Dir, targ) != pkgs[0].Target { // maybe $GOBIN is the current directory\n \t\t\tfi, err := os.Stat(targ)"}, {"sha": "b60f4e27c04a539e693aec00aee069cb7debdb4a", "filename": "libgo/go/cmd/go/internal/work/build_test.go", "status": "modified", "additions": 0, "deletions": 2, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuild_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -221,8 +221,6 @@ func pkgImportPath(pkgpath string) *load.Package {\n // See https://golang.org/issue/18878.\n func TestRespectSetgidDir(t *testing.T) {\n \tswitch runtime.GOOS {\n-\tcase \"nacl\":\n-\t\tt.Skip(\"can't set SetGID bit with chmod on nacl\")\n \tcase \"darwin\":\n \t\tif runtime.GOARCH == \"arm\" || runtime.GOARCH == \"arm64\" {\n \t\t\tt.Skip(\"can't set SetGID bit with chmod on iOS\")"}, {"sha": "7558a3091aa6c7a6646652b78dcc36a39951023b", "filename": "libgo/go/cmd/go/internal/work/buildid.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fbuildid.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -15,7 +15,6 @@ import (\n \t\"cmd/go/internal/base\"\n \t\"cmd/go/internal/cache\"\n \t\"cmd/go/internal/cfg\"\n-\t\"cmd/go/internal/load\"\n \t\"cmd/go/internal/str\"\n \t\"cmd/internal/buildid\"\n )\n@@ -421,7 +420,7 @@ func (b *Builder) fileHash(file string) string {\n // during a's work. The caller should defer b.flushOutput(a), to make sure\n // that flushOutput is eventually called regardless of whether the action\n // succeeds. The flushOutput call must happen after updateBuildID.\n-func (b *Builder) useCache(a *Action, p *load.Package, actionHash cache.ActionID, target string) bool {\n+func (b *Builder) useCache(a *Action, actionHash cache.ActionID, target string) bool {\n \t// The second half of the build ID here is a placeholder for the content hash.\n \t// It's important that the overall buildID be unlikely verging on impossible\n \t// to appear in the output by chance, but that should be taken care of by"}, {"sha": "ba81543fdf7ec705e7e773fbca4f527414b2d8d0", "filename": "libgo/go/cmd/go/internal/work/exec.go", "status": "modified", "additions": 60, "deletions": 61, "changes": 121, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fexec.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -54,8 +54,9 @@ func actionList(root *Action) []*Action {\n \n // do runs the action graph rooted at root.\n func (b *Builder) Do(root *Action) {\n-\tif c := cache.Default(); c != nil && !b.IsCmdList {\n+\tif !b.IsCmdList {\n \t\t// If we're doing real work, take time at the end to trim the cache.\n+\t\tc := cache.Default()\n \t\tdefer c.Trim()\n \t}\n \n@@ -200,13 +201,17 @@ func (b *Builder) buildActionID(a *Action) cache.ActionID {\n \t// same compiler settings and can reuse each other's results.\n \t// If not, the reason is already recorded in buildGcflags.\n \tfmt.Fprintf(h, \"compile\\n\")\n+\t// Only include the package directory if it may affect the output.\n+\t// We trim workspace paths for all packages when -trimpath is set.\n \t// The compiler hides the exact value of $GOROOT\n-\t// when building things in GOROOT,\n-\t// but it does not hide the exact value of $GOPATH.\n-\t// Include the full dir in that case.\n+\t// when building things in GOROOT.\n \t// Assume b.WorkDir is being trimmed properly.\n-\tif !p.Goroot && !strings.HasPrefix(p.Dir, b.WorkDir) {\n+\t// When -trimpath is used with a package built from the module cache,\n+\t// use the module path and version instead of the directory.\n+\tif !p.Goroot && !cfg.BuildTrimpath && !strings.HasPrefix(p.Dir, b.WorkDir) {\n \t\tfmt.Fprintf(h, \"dir %s\\n\", p.Dir)\n+\t} else if cfg.BuildTrimpath && p.Module != nil {\n+\t\tfmt.Fprintf(h, \"module %s@%s\\n\", p.Module.Path, p.Module.Version)\n \t}\n \tfmt.Fprintf(h, \"goos %s goarch %s\\n\", cfg.Goos, cfg.Goarch)\n \tfmt.Fprintf(h, \"import %q\\n\", p.ImportPath)\n@@ -394,7 +399,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\tbit(needCompiledGoFiles, b.NeedCompiledGoFiles)\n \n \tif !p.BinaryOnly {\n-\t\tif b.useCache(a, p, b.buildActionID(a), p.Target) {\n+\t\tif b.useCache(a, b.buildActionID(a), p.Target) {\n \t\t\t// We found the main output in the cache.\n \t\t\t// If we don't need any other outputs, we can stop.\n \t\t\t// Otherwise, we need to write files to a.Objdir (needVet, needCgoHdr).\n@@ -406,15 +411,19 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\tif b.NeedExport {\n \t\t\t\tp.Export = a.built\n \t\t\t}\n-\t\t\tif need&needCompiledGoFiles != 0 && b.loadCachedSrcFiles(a) {\n-\t\t\t\tneed &^= needCompiledGoFiles\n+\t\t\tif need&needCompiledGoFiles != 0 {\n+\t\t\t\tif err := b.loadCachedSrcFiles(a); err == nil {\n+\t\t\t\t\tneed &^= needCompiledGoFiles\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \n \t\t// Source files might be cached, even if the full action is not\n \t\t// (e.g., go list -compiled -find).\n-\t\tif !cachedBuild && need&needCompiledGoFiles != 0 && b.loadCachedSrcFiles(a) {\n-\t\t\tneed &^= needCompiledGoFiles\n+\t\tif !cachedBuild && need&needCompiledGoFiles != 0 {\n+\t\t\tif err := b.loadCachedSrcFiles(a); err == nil {\n+\t\t\t\tneed &^= needCompiledGoFiles\n+\t\t\t}\n \t\t}\n \n \t\tif need == 0 {\n@@ -428,7 +437,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t\t\terr = fmt.Errorf(\"go build %s: %v\", a.Package.ImportPath, err)\n \t\t}\n \t\tif err != nil && b.IsCmdList && b.NeedError && p.Error == nil {\n-\t\t\tp.Error = &load.PackageError{Err: err.Error()}\n+\t\t\tp.Error = &load.PackageError{Err: err}\n \t\t}\n \t}()\n \tif cfg.BuildN {\n@@ -459,16 +468,20 @@ func (b *Builder) build(a *Action) (err error) {\n \tobjdir := a.Objdir\n \n \t// Load cached cgo header, but only if we're skipping the main build (cachedBuild==true).\n-\tif cachedBuild && need&needCgoHdr != 0 && b.loadCachedCgoHdr(a) {\n-\t\tneed &^= needCgoHdr\n+\tif cachedBuild && need&needCgoHdr != 0 {\n+\t\tif err := b.loadCachedCgoHdr(a); err == nil {\n+\t\t\tneed &^= needCgoHdr\n+\t\t}\n \t}\n \n \t// Load cached vet config, but only if that's all we have left\n \t// (need == needVet, not testing just the one bit).\n \t// If we are going to do a full build anyway,\n \t// we're going to regenerate the files below anyway.\n-\tif need == needVet && b.loadCachedVet(a) {\n-\t\tneed &^= needVet\n+\tif need == needVet {\n+\t\tif err := b.loadCachedVet(a); err == nil {\n+\t\t\tneed &^= needVet\n+\t\t}\n \t}\n \tif need == 0 {\n \t\treturn nil\n@@ -615,8 +628,8 @@ func (b *Builder) build(a *Action) (err error) {\n \t\tneed &^= needVet\n \t}\n \tif need&needCompiledGoFiles != 0 {\n-\t\tif !b.loadCachedSrcFiles(a) {\n-\t\t\treturn fmt.Errorf(\"failed to cache compiled Go files\")\n+\t\tif err := b.loadCachedSrcFiles(a); err != nil {\n+\t\t\treturn fmt.Errorf(\"loading compiled Go files from cache: %w\", err)\n \t\t}\n \t\tneed &^= needCompiledGoFiles\n \t}\n@@ -656,7 +669,7 @@ func (b *Builder) build(a *Action) (err error) {\n \t}\n \n \tif p.Internal.BuildInfo != \"\" && cfg.ModulesEnabled {\n-\t\tif err := b.writeFile(objdir+\"_gomod_.go\", load.ModInfoProg(p.Internal.BuildInfo)); err != nil {\n+\t\tif err := b.writeFile(objdir+\"_gomod_.go\", load.ModInfoProg(p.Internal.BuildInfo, cfg.BuildToolchainName == \"gccgo\")); err != nil {\n \t\t\treturn err\n \t\t}\n \t\tgofiles = append(gofiles, objdir+\"_gomod_.go\")\n@@ -790,7 +803,7 @@ func (b *Builder) cacheObjdirFile(a *Action, c *cache.Cache, name string) error\n func (b *Builder) findCachedObjdirFile(a *Action, c *cache.Cache, name string) (string, error) {\n \tfile, _, err := c.GetFile(cache.Subkey(a.actionID, name))\n \tif err != nil {\n-\t\treturn \"\", err\n+\t\treturn \"\", fmt.Errorf(\"loading cached file %s: %w\", name, err)\n \t}\n \treturn file, nil\n }\n@@ -805,26 +818,16 @@ func (b *Builder) loadCachedObjdirFile(a *Action, c *cache.Cache, name string) e\n \n func (b *Builder) cacheCgoHdr(a *Action) {\n \tc := cache.Default()\n-\tif c == nil {\n-\t\treturn\n-\t}\n \tb.cacheObjdirFile(a, c, \"_cgo_install.h\")\n }\n \n-func (b *Builder) loadCachedCgoHdr(a *Action) bool {\n+func (b *Builder) loadCachedCgoHdr(a *Action) error {\n \tc := cache.Default()\n-\tif c == nil {\n-\t\treturn false\n-\t}\n-\terr := b.loadCachedObjdirFile(a, c, \"_cgo_install.h\")\n-\treturn err == nil\n+\treturn b.loadCachedObjdirFile(a, c, \"_cgo_install.h\")\n }\n \n func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string) {\n \tc := cache.Default()\n-\tif c == nil {\n-\t\treturn\n-\t}\n \tvar buf bytes.Buffer\n \tfor _, file := range srcfiles {\n \t\tif !strings.HasPrefix(file, a.Objdir) {\n@@ -844,14 +847,11 @@ func (b *Builder) cacheSrcFiles(a *Action, srcfiles []string) {\n \tc.PutBytes(cache.Subkey(a.actionID, \"srcfiles\"), buf.Bytes())\n }\n \n-func (b *Builder) loadCachedVet(a *Action) bool {\n+func (b *Builder) loadCachedVet(a *Action) error {\n \tc := cache.Default()\n-\tif c == nil {\n-\t\treturn false\n-\t}\n \tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"srcfiles\"))\n \tif err != nil {\n-\t\treturn false\n+\t\treturn fmt.Errorf(\"reading srcfiles list: %w\", err)\n \t}\n \tvar srcfiles []string\n \tfor _, name := range strings.Split(string(list), \"\\n\") {\n@@ -863,22 +863,19 @@ func (b *Builder) loadCachedVet(a *Action) bool {\n \t\t\tcontinue\n \t\t}\n \t\tif err := b.loadCachedObjdirFile(a, c, name); err != nil {\n-\t\t\treturn false\n+\t\t\treturn err\n \t\t}\n \t\tsrcfiles = append(srcfiles, a.Objdir+name)\n \t}\n \tbuildVetConfig(a, srcfiles)\n-\treturn true\n+\treturn nil\n }\n \n-func (b *Builder) loadCachedSrcFiles(a *Action) bool {\n+func (b *Builder) loadCachedSrcFiles(a *Action) error {\n \tc := cache.Default()\n-\tif c == nil {\n-\t\treturn false\n-\t}\n \tlist, _, err := c.GetBytes(cache.Subkey(a.actionID, \"srcfiles\"))\n \tif err != nil {\n-\t\treturn false\n+\t\treturn fmt.Errorf(\"reading srcfiles list: %w\", err)\n \t}\n \tvar files []string\n \tfor _, name := range strings.Split(string(list), \"\\n\") {\n@@ -891,12 +888,12 @@ func (b *Builder) loadCachedSrcFiles(a *Action) bool {\n \t\t}\n \t\tfile, err := b.findCachedObjdirFile(a, c, name)\n \t\tif err != nil {\n-\t\t\treturn false\n+\t\t\treturn fmt.Errorf(\"finding %s: %w\", name, err)\n \t\t}\n \t\tfiles = append(files, file)\n \t}\n \ta.Package.CompiledGoFiles = files\n-\treturn true\n+\treturn nil\n }\n \n // vetConfig is the configuration passed to vet describing a single package.\n@@ -1032,7 +1029,7 @@ func (b *Builder) vet(a *Action) error {\n \t// dependency tree turn on *more* analysis, as here.\n \t// (The unsafeptr check does not write any facts for use by\n \t// later vet runs.)\n-\tif a.Package.Goroot && !VetExplicit {\n+\tif a.Package.Goroot && !VetExplicit && VetTool == \"\" {\n \t\t// Note that $GOROOT/src/buildall.bash\n \t\t// does the same for the misc-compile trybots\n \t\t// and should be updated if these flags are\n@@ -1060,12 +1057,11 @@ func (b *Builder) vet(a *Action) error {\n \t}\n \tkey := cache.ActionID(h.Sum())\n \n-\tif vcfg.VetxOnly {\n-\t\tif c := cache.Default(); c != nil && !cfg.BuildA {\n-\t\t\tif file, _, err := c.GetFile(key); err == nil {\n-\t\t\t\ta.built = file\n-\t\t\t\treturn nil\n-\t\t\t}\n+\tif vcfg.VetxOnly && !cfg.BuildA {\n+\t\tc := cache.Default()\n+\t\tif file, _, err := c.GetFile(key); err == nil {\n+\t\t\ta.built = file\n+\t\t\treturn nil\n \t\t}\n \t}\n \n@@ -1093,9 +1089,7 @@ func (b *Builder) vet(a *Action) error {\n \t// If vet wrote export data, save it for input to future vets.\n \tif f, err := os.Open(vcfg.VetxOutput); err == nil {\n \t\ta.built = vcfg.VetxOutput\n-\t\tif c := cache.Default(); c != nil {\n-\t\t\tc.Put(key, f)\n-\t\t}\n+\t\tcache.Default().Put(key, f)\n \t\tf.Close()\n \t}\n \n@@ -1183,7 +1177,7 @@ func (b *Builder) printLinkerConfig(h io.Writer, p *load.Package) {\n // link is the action for linking a single command.\n // Note that any new influence on this logic must be reported in b.linkActionID above as well.\n func (b *Builder) link(a *Action) (err error) {\n-\tif b.useCache(a, a.Package, b.linkActionID(a), a.Package.Target) || b.IsCmdList {\n+\tif b.useCache(a, b.linkActionID(a), a.Package.Target) || b.IsCmdList {\n \t\treturn nil\n \t}\n \tdefer b.flushOutput(a)\n@@ -1416,7 +1410,7 @@ func (b *Builder) linkSharedActionID(a *Action) cache.ActionID {\n }\n \n func (b *Builder) linkShared(a *Action) (err error) {\n-\tif b.useCache(a, nil, b.linkSharedActionID(a), a.Target) || b.IsCmdList {\n+\tif b.useCache(a, b.linkSharedActionID(a), a.Target) || b.IsCmdList {\n \t\treturn nil\n \t}\n \tdefer b.flushOutput(a)\n@@ -1622,12 +1616,12 @@ func (b *Builder) copyFile(dst, src string, perm os.FileMode, force bool) error\n \n \t// Be careful about removing/overwriting dst.\n \t// Do not remove/overwrite if dst exists and is a directory\n-\t// or a non-object file.\n+\t// or a non-empty non-object file.\n \tif fi, err := os.Stat(dst); err == nil {\n \t\tif fi.IsDir() {\n \t\t\treturn fmt.Errorf(\"build output %q already exists and is a directory\", dst)\n \t\t}\n-\t\tif !force && fi.Mode().IsRegular() && !isObject(dst) {\n+\t\tif !force && fi.Mode().IsRegular() && fi.Size() != 0 && !isObject(dst) {\n \t\t\treturn fmt.Errorf(\"build output %q already exists and is not an object file\", dst)\n \t\t}\n \t}\n@@ -1652,7 +1646,7 @@ func (b *Builder) copyFile(dst, src string, perm os.FileMode, force bool) error\n \t\tdf, err = os.OpenFile(dst, os.O_WRONLY|os.O_CREATE|os.O_TRUNC, perm)\n \t}\n \tif err != nil {\n-\t\treturn err\n+\t\treturn fmt.Errorf(\"copying %s: %w\", src, err) // err should already refer to dst\n \t}\n \n \t_, err = io.Copy(df, sf)\n@@ -1782,6 +1776,11 @@ func (b *Builder) fmtcmd(dir string, format string, args ...interface{}) string\n \t}\n \tif b.WorkDir != \"\" {\n \t\tcmd = strings.ReplaceAll(cmd, b.WorkDir, \"$WORK\")\n+\t\tescaped := strconv.Quote(b.WorkDir)\n+\t\tescaped = escaped[1 : len(escaped)-1] // strip quote characters\n+\t\tif escaped != b.WorkDir {\n+\t\t\tcmd = strings.ReplaceAll(cmd, escaped, \"$WORK\")\n+\t\t}\n \t}\n \treturn cmd\n }\n@@ -2408,7 +2407,7 @@ func (b *Builder) gccArchArgs() []string {\n \tswitch cfg.Goarch {\n \tcase \"386\":\n \t\treturn []string{\"-m32\"}\n-\tcase \"amd64\", \"amd64p32\":\n+\tcase \"amd64\":\n \t\treturn []string{\"-m64\"}\n \tcase \"arm\":\n \t\treturn []string{\"-marm\"} // not thumb"}, {"sha": "57024694cf6e6e7415b21f97d97d9eef194480ac", "filename": "libgo/go/cmd/go/internal/work/gc.go", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgc.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -92,8 +92,7 @@ func (gcToolchain) gc(b *Builder, a *Action, archive string, importcfg []byte, s\n \tif a.buildID != \"\" {\n \t\tgcargs = append(gcargs, \"-buildid\", a.buildID)\n \t}\n-\tplatform := cfg.Goos + \"/\" + cfg.Goarch\n-\tif p.Internal.OmitDebug || platform == \"nacl/amd64p32\" || cfg.Goos == \"plan9\" || cfg.Goarch == \"wasm\" {\n+\tif p.Internal.OmitDebug || cfg.Goos == \"plan9\" || cfg.Goarch == \"wasm\" {\n \t\tgcargs = append(gcargs, \"-dwarf=false\")\n \t}\n \tif strings.HasPrefix(runtimeVersion, \"go1\") && !strings.Contains(os.Args[0], \"go_bootstrap\") {"}, {"sha": "f6fa17da85cfd2720a382ebb53339914d6342411", "filename": "libgo/go/cmd/go/internal/work/gccgo.go", "status": "modified", "additions": 9, "deletions": 2, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fgccgo.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -91,6 +91,10 @@ func (tools gccgoToolchain) gc(b *Builder, a *Action, archive string, importcfg\n \t\t\targs = append(args, \"-I\", root)\n \t\t}\n \t}\n+\tif cfg.BuildTrimpath && b.gccSupportsFlag(args[:1], \"-ffile-prefix-map=a=b\") {\n+\t\targs = append(args, \"-ffile-prefix-map=\"+base.Cwd+\"=.\")\n+\t\targs = append(args, \"-ffile-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")\n+\t}\n \targs = append(args, a.Package.Internal.Gccgoflags...)\n \tfor _, f := range gofiles {\n \t\targs = append(args, mkAbs(p.Dir, f))\n@@ -354,7 +358,7 @@ func (tools gccgoToolchain) link(b *Builder, root *Action, out, importcfg string\n \t\t}\n \n \t\tif haveShlib[filepath.Base(a.Target)] {\n-\t\t\t// This is a shared library we want to link againt.\n+\t\t\t// This is a shared library we want to link against.\n \t\t\tif !addedShlib[a.Target] {\n \t\t\t\tshlibs = append(shlibs, a.Target)\n \t\t\t\taddedShlib[a.Target] = true\n@@ -560,7 +564,10 @@ func (tools gccgoToolchain) cc(b *Builder, a *Action, ofile, cfile string) error\n \t\tdefs = append(defs, \"-fsplit-stack\")\n \t}\n \tdefs = tools.maybePIC(defs)\n-\tif b.gccSupportsFlag(compiler, \"-fdebug-prefix-map=a=b\") {\n+\tif b.gccSupportsFlag(compiler, \"-ffile-prefix-map=a=b\") {\n+\t\tdefs = append(defs, \"-ffile-prefix-map=\"+base.Cwd+\"=.\")\n+\t\tdefs = append(defs, \"-ffile-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")\n+\t} else if b.gccSupportsFlag(compiler, \"-fdebug-prefix-map=a=b\") {\n \t\tdefs = append(defs, \"-fdebug-prefix-map=\"+b.WorkDir+\"=/tmp/go-build\")\n \t}\n \tif b.gccSupportsFlag(compiler, \"-gno-record-gcc-switches\") {"}, {"sha": "9091f986368f4d62bfd576cdea18397d849f0b78", "filename": "libgo/go/cmd/go/internal/work/init.go", "status": "modified", "additions": 53, "deletions": 60, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Finit.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -60,6 +60,11 @@ func instrumentInit() {\n \tmode := \"race\"\n \tif cfg.BuildMSan {\n \t\tmode = \"msan\"\n+\t\t// MSAN does not support non-PIE binaries on ARM64.\n+\t\t// See issue #33712 for details.\n+\t\tif cfg.Goos == \"linux\" && cfg.Goarch == \"arm64\" && cfg.BuildBuildmode == \"default\" {\n+\t\t\tcfg.BuildBuildmode = \"pie\"\n+\t\t}\n \t}\n \tmodeFlag := \"-\" + mode\n \n@@ -81,7 +86,11 @@ func instrumentInit() {\n func buildModeInit() {\n \tgccgo := cfg.BuildToolchainName == \"gccgo\"\n \tvar codegenArg string\n-\tplatform := cfg.Goos + \"/\" + cfg.Goarch\n+\n+\t// Configure the build mode first, then verify that it is supported.\n+\t// That way, if the flag is completely bogus we will prefer to error out with\n+\t// \"-buildmode=%s not supported\" instead of naming the specific platform.\n+\n \tswitch cfg.BuildBuildmode {\n \tcase \"archive\":\n \t\tpkgsFilter = pkgsNotMain\n@@ -90,20 +99,18 @@ func buildModeInit() {\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"darwin/arm\", \"darwin/arm64\":\n-\t\t\t\tcodegenArg = \"-shared\"\n-\t\t\tdefault:\n-\t\t\t\tswitch cfg.Goos {\n-\t\t\t\tcase \"dragonfly\", \"freebsd\", \"illumos\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n-\t\t\t\t\tif platform == \"linux/ppc64\" {\n-\t\t\t\t\t\tbase.Fatalf(\"-buildmode=c-archive not supported on %s\\n\", platform)\n-\t\t\t\t\t}\n-\t\t\t\t\t// Use -shared so that the result is\n-\t\t\t\t\t// suitable for inclusion in a PIE or\n-\t\t\t\t\t// shared library.\n+\t\t\tswitch cfg.Goos {\n+\t\t\tcase \"darwin\":\n+\t\t\t\tswitch cfg.Goarch {\n+\t\t\t\tcase \"arm\", \"arm64\":\n \t\t\t\t\tcodegenArg = \"-shared\"\n \t\t\t\t}\n+\n+\t\t\tcase \"dragonfly\", \"freebsd\", \"illumos\", \"linux\", \"netbsd\", \"openbsd\", \"solaris\":\n+\t\t\t\t// Use -shared so that the result is\n+\t\t\t\t// suitable for inclusion in a PIE or\n+\t\t\t\t// shared library.\n+\t\t\t\tcodegenArg = \"-shared\"\n \t\t\t}\n \t\t}\n \t\tcfg.ExeSuffix = \".a\"\n@@ -113,27 +120,25 @@ func buildModeInit() {\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/386\", \"linux/ppc64le\", \"linux/s390x\",\n-\t\t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n-\t\t\t\t\"freebsd/amd64\":\n+\t\t\tswitch cfg.Goos {\n+\t\t\tcase \"linux\", \"android\", \"freebsd\":\n \t\t\t\tcodegenArg = \"-shared\"\n-\t\t\tcase \"darwin/amd64\", \"darwin/386\":\n-\t\t\tcase \"windows/amd64\", \"windows/386\":\n+\t\t\tcase \"windows\":\n \t\t\t\t// Do not add usual .exe suffix to the .dll file.\n \t\t\t\tcfg.ExeSuffix = \"\"\n-\t\t\tdefault:\n-\t\t\t\tbase.Fatalf(\"-buildmode=c-shared not supported on %s\\n\", platform)\n \t\t\t}\n \t\t}\n \t\tldBuildmode = \"c-shared\"\n \tcase \"default\":\n-\t\tswitch platform {\n-\t\tcase \"android/arm\", \"android/arm64\", \"android/amd64\", \"android/386\":\n+\t\tswitch cfg.Goos {\n+\t\tcase \"android\":\n \t\t\tcodegenArg = \"-shared\"\n \t\t\tldBuildmode = \"pie\"\n-\t\tcase \"darwin/arm\", \"darwin/arm64\":\n-\t\t\tcodegenArg = \"-shared\"\n+\t\tcase \"darwin\":\n+\t\t\tswitch cfg.Goarch {\n+\t\t\tcase \"arm\", \"arm64\":\n+\t\t\t\tcodegenArg = \"-shared\"\n+\t\t\t}\n \t\t\tfallthrough\n \t\tdefault:\n \t\t\tldBuildmode = \"exe\"\n@@ -156,30 +161,15 @@ func buildModeInit() {\n \t\t}\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIE\"\n-\t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\",\n-\t\t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\",\n-\t\t\t\t\"freebsd/amd64\":\n-\t\t\t\tcodegenArg = \"-shared\"\n-\t\t\tcase \"darwin/amd64\":\n-\t\t\t\tcodegenArg = \"-shared\"\n-\t\t\tcase \"aix/ppc64\":\n-\t\t\tdefault:\n-\t\t\t\tbase.Fatalf(\"-buildmode=pie not supported on %s\\n\", platform)\n-\t\t\t}\n+\t\t} else if cfg.Goos != \"aix\" {\n+\t\t\tcodegenArg = \"-shared\"\n \t\t}\n \t\tldBuildmode = \"pie\"\n \tcase \"shared\":\n \t\tpkgsFilter = pkgsNotMain\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\":\n-\t\t\tdefault:\n-\t\t\t\tbase.Fatalf(\"-buildmode=shared not supported on %s\\n\", platform)\n-\t\t\t}\n \t\t\tcodegenArg = \"-dynlink\"\n \t\t}\n \t\tif cfg.BuildO != \"\" {\n@@ -191,33 +181,28 @@ func buildModeInit() {\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/386\", \"linux/s390x\", \"linux/ppc64le\",\n-\t\t\t\t\"android/amd64\", \"android/arm\", \"android/arm64\", \"android/386\":\n-\t\t\tcase \"darwin/amd64\":\n-\t\t\t\t// Skip DWARF generation due to #21647\n-\t\t\t\tforcedLdflags = append(forcedLdflags, \"-w\")\n-\t\t\tdefault:\n-\t\t\t\tbase.Fatalf(\"-buildmode=plugin not supported on %s\\n\", platform)\n-\t\t\t}\n \t\t\tcodegenArg = \"-dynlink\"\n \t\t}\n \t\tcfg.ExeSuffix = \".so\"\n \t\tldBuildmode = \"plugin\"\n \tdefault:\n \t\tbase.Fatalf(\"buildmode=%s not supported\", cfg.BuildBuildmode)\n \t}\n+\n+\tif !sys.BuildModeSupported(cfg.BuildToolchainName, cfg.BuildBuildmode, cfg.Goos, cfg.Goarch) {\n+\t\tbase.Fatalf(\"-buildmode=%s not supported on %s/%s\\n\", cfg.BuildBuildmode, cfg.Goos, cfg.Goarch)\n+\t}\n+\n \tif cfg.BuildLinkshared {\n+\t\tif !sys.BuildModeSupported(cfg.BuildToolchainName, \"shared\", cfg.Goos, cfg.Goarch) {\n+\t\t\tbase.Fatalf(\"-linkshared not supported on %s/%s\\n\", cfg.Goos, cfg.Goarch)\n+\t\t}\n \t\tif gccgo {\n \t\t\tcodegenArg = \"-fPIC\"\n \t\t} else {\n-\t\t\tswitch platform {\n-\t\t\tcase \"linux/386\", \"linux/amd64\", \"linux/arm\", \"linux/arm64\", \"linux/ppc64le\", \"linux/s390x\":\n-\t\t\t\tforcedAsmflags = append(forcedAsmflags, \"-D=GOBUILDMODE_shared=1\")\n-\t\t\tdefault:\n-\t\t\t\tbase.Fatalf(\"-linkshared not supported on %s\\n\", platform)\n-\t\t\t}\n+\t\t\tforcedAsmflags = append(forcedAsmflags, \"-D=GOBUILDMODE_shared=1\")\n \t\t\tcodegenArg = \"-dynlink\"\n+\t\t\tforcedGcflags = append(forcedGcflags, \"-linkshared\")\n \t\t\t// TODO(mwhudson): remove -w when that gets fixed in linker.\n \t\t\tforcedLdflags = append(forcedLdflags, \"-linkshared\", \"-w\")\n \t\t}\n@@ -241,12 +226,20 @@ func buildModeInit() {\n \tswitch cfg.BuildMod {\n \tcase \"\":\n \t\t// ok\n-\tcase \"readonly\", \"vendor\":\n-\t\tif load.ModLookup == nil && !inGOFLAGS(\"-mod\") {\n+\tcase \"readonly\", \"vendor\", \"mod\":\n+\t\tif !cfg.ModulesEnabled && !inGOFLAGS(\"-mod\") {\n \t\t\tbase.Fatalf(\"build flag -mod=%s only valid when using modules\", cfg.BuildMod)\n \t\t}\n \tdefault:\n-\t\tbase.Fatalf(\"-mod=%s not supported (can be '', 'readonly', or 'vendor')\", cfg.BuildMod)\n+\t\tbase.Fatalf(\"-mod=%s not supported (can be '', 'mod', 'readonly', or 'vendor')\", cfg.BuildMod)\n+\t}\n+\tif !cfg.ModulesEnabled {\n+\t\tif cfg.ModCacheRW && !inGOFLAGS(\"-modcacherw\") {\n+\t\t\tbase.Fatalf(\"build flag -modcacherw only valid when using modules\")\n+\t\t}\n+\t\tif cfg.ModFile != \"\" && !inGOFLAGS(\"-mod\") {\n+\t\t\tbase.Fatalf(\"build flag -modfile only valid when using modules\")\n+\t\t}\n \t}\n }\n "}, {"sha": "0ce1664c16fa9be4fa3879123c5b77709132760b", "filename": "libgo/go/cmd/go/internal/work/security.go", "status": "modified", "additions": 12, "deletions": 0, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -43,6 +43,7 @@ var re = lazyregexp.New\n \n var validCompilerFlags = []*lazyregexp.Regexp{\n \tre(`-D([A-Za-z_].*)`),\n+\tre(`-U([A-Za-z_]*)`),\n \tre(`-F([^@\\-].*)`),\n \tre(`-I([^@\\-].*)`),\n \tre(`-O`),\n@@ -51,6 +52,7 @@ var validCompilerFlags = []*lazyregexp.Regexp{\n \tre(`-W([^@,]+)`), // -Wall but not -Wa,-foo.\n \tre(`-Wa,-mbig-obj`),\n \tre(`-Wp,-D([A-Za-z_].*)`),\n+\tre(`-Wp,-U([A-Za-z_]*)`),\n \tre(`-ansi`),\n \tre(`-f(no-)?asynchronous-unwind-tables`),\n \tre(`-f(no-)?blocks`),\n@@ -127,6 +129,7 @@ var validCompilerFlags = []*lazyregexp.Regexp{\n var validCompilerFlagsWithNextArg = []string{\n \t\"-arch\",\n \t\"-D\",\n+\t\"-U\",\n \t\"-I\",\n \t\"-framework\",\n \t\"-isysroot\",\n@@ -280,6 +283,15 @@ Args:\n \t\t\t\t\tcontinue Args\n \t\t\t\t}\n \n+\t\t\t\t// Permit -I= /path, -I $SYSROOT.\n+\t\t\t\tif i+1 < len(list) && arg == \"-I\" {\n+\t\t\t\t\tif (strings.HasPrefix(list[i+1], \"=\") || strings.HasPrefix(list[i+1], \"$SYSROOT\")) &&\n+\t\t\t\t\t\tload.SafeArg(list[i+1][1:]) {\n+\t\t\t\t\t\ti++\n+\t\t\t\t\t\tcontinue Args\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\n \t\t\t\tif i+1 < len(list) {\n \t\t\t\t\treturn fmt.Errorf(\"invalid flag in %s: %s %s (see https://golang.org/s/invalidflag)\", source, arg, list[i+1])\n \t\t\t\t}"}, {"sha": "6b85c40b13bc9750ab930b4dc59503359bbd71a0", "filename": "libgo/go/cmd/go/internal/work/security_test.go", "status": "modified", "additions": 9, "deletions": 0, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Finternal%2Fwork%2Fsecurity_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -12,6 +12,7 @@ import (\n var goodCompilerFlags = [][]string{\n \t{\"-DFOO\"},\n \t{\"-Dfoo=bar\"},\n+\t{\"-Ufoo\"},\n \t{\"-F/Qt\"},\n \t{\"-I/\"},\n \t{\"-I/etc/passwd\"},\n@@ -21,6 +22,8 @@ var goodCompilerFlags = [][]string{\n \t{\"-Osmall\"},\n \t{\"-W\"},\n \t{\"-Wall\"},\n+\t{\"-Wp,-Dfoo=bar\"},\n+\t{\"-Wp,-Ufoo\"},\n \t{\"-fobjc-arc\"},\n \t{\"-fno-objc-arc\"},\n \t{\"-fomit-frame-pointer\"},\n@@ -56,6 +59,9 @@ var goodCompilerFlags = [][]string{\n \t{\"-I\", \".\"},\n \t{\"-I\", \"/etc/passwd\"},\n \t{\"-I\", \"\u4e16\u754c\"},\n+\t{\"-I\", \"=/usr/include/libxml2\"},\n+\t{\"-I\", \"dir\"},\n+\t{\"-I\", \"$SYSROOT/dir\"},\n \t{\"-framework\", \"Chocolate\"},\n \t{\"-x\", \"c\"},\n \t{\"-v\"},\n@@ -64,6 +70,7 @@ var goodCompilerFlags = [][]string{\n var badCompilerFlags = [][]string{\n \t{\"-D@X\"},\n \t{\"-D-X\"},\n+\t{\"-Ufoo=bar\"},\n \t{\"-F@dir\"},\n \t{\"-F-dir\"},\n \t{\"-I@dir\"},\n@@ -83,6 +90,7 @@ var badCompilerFlags = [][]string{\n \t{\"-D\", \"-foo\"},\n \t{\"-I\", \"@foo\"},\n \t{\"-I\", \"-foo\"},\n+\t{\"-I\", \"=@obj\"},\n \t{\"-framework\", \"-Caffeine\"},\n \t{\"-framework\", \"@Home\"},\n \t{\"-x\", \"--c\"},\n@@ -143,6 +151,7 @@ var goodLinkerFlags = [][]string{\n \t{\"-L\", \"framework\"},\n \t{\"-framework\", \"Chocolate\"},\n \t{\"-v\"},\n+\t{\"-Wl,-sectcreate,__TEXT,__info_plist,${SRCDIR}/Info.plist\"},\n \t{\"-Wl,-framework\", \"-Wl,Chocolate\"},\n \t{\"-Wl,-framework,Chocolate\"},\n \t{\"-Wl,-unresolved-symbols=ignore-all\"},"}, {"sha": "bb442b5f8e44f5138332bb47d770588671169f64", "filename": "libgo/go/cmd/go/main.go", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fmain.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -91,7 +91,7 @@ func main() {\n \t}\n \n \tif args[0] == \"get\" || args[0] == \"help\" {\n-\t\tif modload.Init(); !modload.Enabled() {\n+\t\tif !modload.WillBeEnabled() {\n \t\t\t// Replace module-aware get with GOPATH get if appropriate.\n \t\t\t*modget.CmdGet = *get.CmdGet\n \t\t}"}, {"sha": "8214488a59a6cc05bb7e1f4bfbb6f3fbe55e30e7", "filename": "libgo/go/cmd/go/proxy_test.go", "status": "modified", "additions": 24, "deletions": 18, "changes": 42, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fproxy_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -23,14 +23,15 @@ import (\n \t\"sync\"\n \t\"testing\"\n \n-\t\"cmd/go/internal/dirhash\"\n \t\"cmd/go/internal/modfetch\"\n \t\"cmd/go/internal/modfetch/codehost\"\n-\t\"cmd/go/internal/module\"\n \t\"cmd/go/internal/par\"\n-\t\"cmd/go/internal/semver\"\n-\t\"cmd/go/internal/sumweb\"\n \t\"cmd/go/internal/txtar\"\n+\n+\t\"golang.org/x/mod/module\"\n+\t\"golang.org/x/mod/semver\"\n+\t\"golang.org/x/mod/sumdb\"\n+\t\"golang.org/x/mod/sumdb/dirhash\"\n )\n \n var (\n@@ -65,7 +66,7 @@ func StartProxy() {\n \n \t\t// Prepopulate main sumdb.\n \t\tfor _, mod := range modList {\n-\t\t\tsumdbHandler.Server.Lookup(nil, mod.Path+\"@\"+mod.Version)\n+\t\t\tsumdbOps.Lookup(nil, mod)\n \t\t}\n \t})\n }\n@@ -88,15 +89,15 @@ func readModList() {\n \t\t\tcontinue\n \t\t}\n \t\tencPath := strings.ReplaceAll(name[:i], \"_\", \"/\")\n-\t\tpath, err := module.DecodePath(encPath)\n+\t\tpath, err := module.UnescapePath(encPath)\n \t\tif err != nil {\n \t\t\tif encPath != \"example.com/invalidpath/v1\" {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n \t\t\t}\n \t\t\tcontinue\n \t\t}\n \t\tencVers := name[i+1:]\n-\t\tvers, err := module.DecodeVersion(encVers)\n+\t\tvers, err := module.UnescapeVersion(encVers)\n \t\tif err != nil {\n \t\t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n \t\t\tcontinue\n@@ -113,8 +114,13 @@ const (\n \ttestSumDBSignerKey   = \"PRIVATE+KEY+localhost.localdev/sumdb+00000c67+AXu6+oaVaOYuQOFrf1V59JK1owcFlJcHwwXHDfDGxSPk\"\n )\n \n-var sumdbHandler = &sumweb.Handler{Server: sumweb.NewTestServer(testSumDBSignerKey, proxyGoSum)}\n-var sumdbWrongHandler = &sumweb.Handler{Server: sumweb.NewTestServer(testSumDBSignerKey, proxyGoSumWrong)}\n+var (\n+\tsumdbOps    = sumdb.NewTestServer(testSumDBSignerKey, proxyGoSum)\n+\tsumdbServer = sumdb.NewServer(sumdbOps)\n+\n+\tsumdbWrongOps    = sumdb.NewTestServer(testSumDBSignerKey, proxyGoSumWrong)\n+\tsumdbWrongServer = sumdb.NewServer(sumdbWrongOps)\n+)\n \n // proxyHandler serves the Go module proxy protocol.\n // See the proxy section of https://research.swtch.com/vgo-module.\n@@ -155,7 +161,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t// (Client thinks it is talking directly to a sumdb.)\n \tif strings.HasPrefix(path, \"sumdb-direct/\") {\n \t\tr.URL.Path = path[len(\"sumdb-direct\"):]\n-\t\tsumdbHandler.ServeHTTP(w, r)\n+\t\tsumdbServer.ServeHTTP(w, r)\n \t\treturn\n \t}\n \n@@ -164,7 +170,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t// (Client thinks it is talking directly to a sumdb.)\n \tif strings.HasPrefix(path, \"sumdb-wrong/\") {\n \t\tr.URL.Path = path[len(\"sumdb-wrong\"):]\n-\t\tsumdbWrongHandler.ServeHTTP(w, r)\n+\t\tsumdbWrongServer.ServeHTTP(w, r)\n \t\treturn\n \t}\n \n@@ -178,7 +184,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t// Request for $GOPROXY/sumdb/<name>/... goes to sumdb.\n \tif sumdbPrefix := \"sumdb/\" + testSumDBName + \"/\"; strings.HasPrefix(path, sumdbPrefix) {\n \t\tr.URL.Path = path[len(sumdbPrefix)-1:]\n-\t\tsumdbHandler.ServeHTTP(w, r)\n+\t\tsumdbServer.ServeHTTP(w, r)\n \t\treturn\n \t}\n \n@@ -187,7 +193,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t// latest version, including pseudo-versions.\n \tif i := strings.LastIndex(path, \"/@latest\"); i >= 0 {\n \t\tenc := path[:i]\n-\t\tmodPath, err := module.DecodePath(enc)\n+\t\tmodPath, err := module.UnescapePath(enc)\n \t\tif err != nil {\n \t\t\tif !quiet {\n \t\t\t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n@@ -225,7 +231,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\t\treturn\n \t\t}\n \n-\t\tencVers, err := module.EncodeVersion(latest)\n+\t\tencVers, err := module.EscapeVersion(latest)\n \t\tif err != nil {\n \t\t\thttp.Error(w, err.Error(), http.StatusInternalServerError)\n \t\t\treturn\n@@ -240,7 +246,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \tenc, file := path[:i], path[i+len(\"/@v/\"):]\n-\tpath, err := module.DecodePath(enc)\n+\tpath, err := module.UnescapePath(enc)\n \tif err != nil {\n \t\tif !quiet {\n \t\t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n@@ -276,7 +282,7 @@ func proxyHandler(w http.ResponseWriter, r *http.Request) {\n \t\treturn\n \t}\n \tencVers, ext := file[:i], file[i+1:]\n-\tvers, err := module.DecodeVersion(encVers)\n+\tvers, err := module.UnescapeVersion(encVers)\n \tif err != nil {\n \t\tfmt.Fprintf(os.Stderr, \"go proxy_test: %v\\n\", err)\n \t\thttp.NotFound(w, r)\n@@ -397,11 +403,11 @@ var archiveCache par.Cache\n var cmdGoDir, _ = os.Getwd()\n \n func readArchive(path, vers string) (*txtar.Archive, error) {\n-\tenc, err := module.EncodePath(path)\n+\tenc, err := module.EscapePath(path)\n \tif err != nil {\n \t\treturn nil, err\n \t}\n-\tencVers, err := module.EncodeVersion(vers)\n+\tencVers, err := module.EscapeVersion(vers)\n \tif err != nil {\n \t\treturn nil, err\n \t}"}, {"sha": "ec498bbcd763ef2d5faa4b7f140679c2549e3d6c", "filename": "libgo/go/cmd/go/script_test.go", "status": "modified", "additions": 65, "deletions": 21, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Fscript_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -30,6 +30,7 @@ import (\n \t\"cmd/go/internal/robustio\"\n \t\"cmd/go/internal/txtar\"\n \t\"cmd/go/internal/work\"\n+\t\"cmd/internal/sys\"\n )\n \n // TestScript runs the tests in testdata/script/*.txt.\n@@ -117,6 +118,7 @@ func (ts *testScript) setup() {\n \t\t\"GOSUMDB=\" + testSumDBVerifierKey,\n \t\t\"GONOPROXY=\",\n \t\t\"GONOSUMDB=\",\n+\t\t\"PWD=\" + ts.cd,\n \t\ttempEnvName() + \"=\" + filepath.Join(ts.workdir, \"tmp\"),\n \t\t\"devnull=\" + os.DevNull,\n \t\t\"goversion=\" + goVersion(ts),\n@@ -291,6 +293,22 @@ Script:\n \t\t\t\t\t}).(bool)\n \t\t\t\t\tbreak\n \t\t\t\t}\n+\t\t\t\tif strings.HasPrefix(cond.tag, \"GODEBUG:\") {\n+\t\t\t\t\tvalue := strings.TrimPrefix(cond.tag, \"GODEBUG:\")\n+\t\t\t\t\tparts := strings.Split(os.Getenv(\"GODEBUG\"), \",\")\n+\t\t\t\t\tfor _, p := range parts {\n+\t\t\t\t\t\tif strings.TrimSpace(p) == value {\n+\t\t\t\t\t\t\tok = true\n+\t\t\t\t\t\t\tbreak\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n+\t\t\t\tif strings.HasPrefix(cond.tag, \"buildmode:\") {\n+\t\t\t\t\tvalue := strings.TrimPrefix(cond.tag, \"buildmode:\")\n+\t\t\t\t\tok = sys.BuildModeSupported(runtime.Compiler, value, runtime.GOOS, runtime.GOARCH)\n+\t\t\t\t\tbreak\n+\t\t\t\t}\n \t\t\t\tif !imports.KnownArch[cond.tag] && !imports.KnownOS[cond.tag] && cond.tag != \"gc\" && cond.tag != \"gccgo\" {\n \t\t\t\t\tts.fatalf(\"unknown condition %q\", cond.tag)\n \t\t\t\t}\n@@ -414,6 +432,7 @@ func (ts *testScript) cmdCd(neg bool, args []string) {\n \t\tts.fatalf(\"%s is not a directory\", dir)\n \t}\n \tts.cd = dir\n+\tts.envMap[\"PWD\"] = dir\n \tfmt.Fprintf(&ts.log, \"%s\\n\", ts.cd)\n }\n \n@@ -429,7 +448,11 @@ func (ts *testScript) cmdChmod(neg bool, args []string) {\n \tif err != nil || perm&uint64(os.ModePerm) != perm {\n \t\tts.fatalf(\"invalid mode: %s\", args[0])\n \t}\n-\tfor _, path := range args[1:] {\n+\tfor _, arg := range args[1:] {\n+\t\tpath := arg\n+\t\tif !filepath.IsAbs(path) {\n+\t\t\tpath = filepath.Join(ts.cd, arg)\n+\t\t}\n \t\terr := os.Chmod(path, os.FileMode(perm))\n \t\tts.check(err)\n \t}\n@@ -441,24 +464,34 @@ func (ts *testScript) cmdCmp(neg bool, args []string) {\n \t\t// It would be strange to say \"this file can have any content except this precise byte sequence\".\n \t\tts.fatalf(\"unsupported: ! cmp\")\n \t}\n+\tquiet := false\n+\tif len(args) > 0 && args[0] == \"-q\" {\n+\t\tquiet = true\n+\t\targs = args[1:]\n+\t}\n \tif len(args) != 2 {\n \t\tts.fatalf(\"usage: cmp file1 file2\")\n \t}\n-\tts.doCmdCmp(args, false)\n+\tts.doCmdCmp(args, false, quiet)\n }\n \n // cmpenv compares two files with environment variable substitution.\n func (ts *testScript) cmdCmpenv(neg bool, args []string) {\n \tif neg {\n \t\tts.fatalf(\"unsupported: ! cmpenv\")\n \t}\n+\tquiet := false\n+\tif len(args) > 0 && args[0] == \"-q\" {\n+\t\tquiet = true\n+\t\targs = args[1:]\n+\t}\n \tif len(args) != 2 {\n \t\tts.fatalf(\"usage: cmpenv file1 file2\")\n \t}\n-\tts.doCmdCmp(args, true)\n+\tts.doCmdCmp(args, true, quiet)\n }\n \n-func (ts *testScript) doCmdCmp(args []string, env bool) {\n+func (ts *testScript) doCmdCmp(args []string, env, quiet bool) {\n \tname1, name2 := args[0], args[1]\n \tvar text1, text2 string\n \tif name1 == \"stdout\" {\n@@ -484,15 +517,14 @@ func (ts *testScript) doCmdCmp(args []string, env bool) {\n \t\treturn\n \t}\n \n-\tfmt.Fprintf(&ts.log, \"[diff -%s +%s]\\n%s\\n\", name1, name2, diff(text1, text2))\n+\tif !quiet {\n+\t\tfmt.Fprintf(&ts.log, \"[diff -%s +%s]\\n%s\\n\", name1, name2, diff(text1, text2))\n+\t}\n \tts.fatalf(\"%s and %s differ\", name1, name2)\n }\n \n // cp copies files, maybe eventually directories.\n func (ts *testScript) cmdCp(neg bool, args []string) {\n-\tif neg {\n-\t\tts.fatalf(\"unsupported: ! cp\")\n-\t}\n \tif len(args) < 2 {\n \t\tts.fatalf(\"usage: cp src... dst\")\n \t}\n@@ -531,7 +563,14 @@ func (ts *testScript) cmdCp(neg bool, args []string) {\n \t\tif dstDir {\n \t\t\ttarg = filepath.Join(dst, filepath.Base(src))\n \t\t}\n-\t\tts.check(ioutil.WriteFile(targ, data, mode))\n+\t\terr := ioutil.WriteFile(targ, data, mode)\n+\t\tif neg {\n+\t\t\tif err == nil {\n+\t\t\t\tts.fatalf(\"unexpected command success\")\n+\t\t\t}\n+\t\t} else {\n+\t\t\tts.check(err)\n+\t\t}\n \t}\n }\n \n@@ -547,26 +586,31 @@ func (ts *testScript) cmdEnv(neg bool, args []string) {\n \t\targs = args[1:]\n \t}\n \n+\tvar out strings.Builder\n \tif len(args) == 0 {\n \t\tprinted := make(map[string]bool) // env list can have duplicates; only print effective value (from envMap) once\n \t\tfor _, kv := range ts.env {\n \t\t\tk := kv[:strings.Index(kv, \"=\")]\n \t\t\tif !printed[k] {\n-\t\t\t\tfmt.Fprintf(&ts.log, \"%s=%s\\n\", k, ts.envMap[k])\n+\t\t\t\tfmt.Fprintf(&out, \"%s=%s\\n\", k, ts.envMap[k])\n \t\t\t}\n \t\t}\n-\t\treturn\n-\t}\n-\tfor _, env := range args {\n-\t\ti := strings.Index(env, \"=\")\n-\t\tif i < 0 {\n-\t\t\t// Display value instead of setting it.\n-\t\t\tfmt.Fprintf(&ts.log, \"%s=%s\\n\", env, ts.envMap[env])\n-\t\t\tcontinue\n+\t} else {\n+\t\tfor _, env := range args {\n+\t\t\ti := strings.Index(env, \"=\")\n+\t\t\tif i < 0 {\n+\t\t\t\t// Display value instead of setting it.\n+\t\t\t\tfmt.Fprintf(&out, \"%s=%s\\n\", env, ts.envMap[env])\n+\t\t\t\tcontinue\n+\t\t\t}\n+\t\t\tkey, val := env[:i], conv(env[i+1:])\n+\t\t\tts.env = append(ts.env, key+\"=\"+val)\n+\t\t\tts.envMap[key] = val\n \t\t}\n-\t\tkey, val := env[:i], conv(env[i+1:])\n-\t\tts.env = append(ts.env, key+\"=\"+val)\n-\t\tts.envMap[key] = val\n+\t}\n+\tif out.Len() > 0 || len(args) > 0 {\n+\t\tts.stdout = out.String()\n+\t\tts.log.WriteString(out.String())\n \t}\n }\n "}, {"sha": "4eeb517da15acf0bf8bc9f46a344fb85dfb46cda", "filename": "libgo/go/cmd/go/testdata/local/easy.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasy.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,7 +0,0 @@\n-package main\n-\n-import \"./easysub\"\n-\n-func main() {\n-\teasysub.Hello()\n-}"}, {"sha": "07040daee57991188df9d044c1e4502542555bda", "filename": "libgo/go/cmd/go/testdata/local/easysub/easysub.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Feasysub.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,7 +0,0 @@\n-package easysub\n-\n-import \"fmt\"\n-\n-func Hello() {\n-\tfmt.Println(\"easysub.Hello\")\n-}"}, {"sha": "6c30b52362e45ed4d01d567a7452f4c729766165", "filename": "libgo/go/cmd/go/testdata/local/easysub/main.go", "status": "removed", "additions": 0, "deletions": 9, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Feasysub%2Fmain.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,9 +0,0 @@\n-// +build ignore\n-\n-package main\n-\n-import \".\"\n-\n-func main() {\n-\teasysub.Hello()\n-}"}, {"sha": "2ffac3fd73bc65874b0e8edc8141049685622edf", "filename": "libgo/go/cmd/go/testdata/local/hard.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fhard.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,7 +0,0 @@\n-package main\n-\n-import \"./sub\"\n-\n-func main() {\n-\tsub.Hello()\n-}"}, {"sha": "d5dbf6d5fa5bbe0a79e1e3c1163cb7d5d5f25376", "filename": "libgo/go/cmd/go/testdata/local/sub/sub.go", "status": "removed", "additions": 0, "deletions": 12, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,12 +0,0 @@\n-package sub\n-\n-import (\n-\t\"fmt\"\n-\n-\tsubsub \"./sub\"\n-)\n-\n-func Hello() {\n-\tfmt.Println(\"sub.Hello\")\n-\tsubsub.Hello()\n-}"}, {"sha": "4cc72233e13ee42317ed013074331f1ccdadc10b", "filename": "libgo/go/cmd/go/testdata/local/sub/sub/subsub.go", "status": "removed", "additions": 0, "deletions": 7, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Flocal%2Fsub%2Fsub%2Fsubsub.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,7 +0,0 @@\n-package subsub\n-\n-import \"fmt\"\n-\n-func Hello() {\n-\tfmt.Println(\"subsub.Hello\")\n-}"}, {"sha": "4f7f4d7dd21cf50a507b9bfa56bfc6bf027635b7", "filename": "libgo/go/cmd/go/testdata/mod/example.com_dotgo.go_v1.0.0.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotgo.go_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotgo.go_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_dotgo.go_v1.0.0.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,16 @@\n+This module's path ends with \".go\".\n+Based on github.com/nats-io/nats.go.\n+Used in regression tests for golang.org/issue/32483.\n+\n+-- .mod --\n+module example.com/dotgo.go\n+\n+go 1.13\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- go.mod --\n+module example.com/dotgo.go\n+\n+go 1.13\n+-- dotgo.go --\n+package dotgo"}, {"sha": "787b7aedfa40a738e3516a5fe3f2063137e5df68", "filename": "libgo/go/cmd/go/testdata/mod/example.com_stack_v1.0.0.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.0.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.0.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.0.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,18 @@\n+Module with a function that prints file name for the top stack frame.\n+Different versions of this module are identical, but they should return\n+different file names with -trimpath.\n+-- .mod --\n+module example.com/stack\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.0\"}\n+-- stack.go --\n+package stack\n+\n+import \"runtime\"\n+\n+func TopFile() string {\n+\t_, file, _, _ := runtime.Caller(0)\n+\treturn file\n+}"}, {"sha": "c715dd234f70ed8f18001d04c5829d55fe7956a1", "filename": "libgo/go/cmd/go/testdata/mod/example.com_stack_v1.0.1.txt", "status": "added", "additions": 18, "deletions": 0, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.1.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.1.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fexample.com_stack_v1.0.1.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,18 @@\n+Module with a function that prints file name for the top stack frame.\n+Different versions of this module are identical, but they should return\n+different file names with -trimpath.\n+-- .mod --\n+module example.com/stack\n+\n+go 1.14\n+-- .info --\n+{\"Version\":\"v1.0.1\"}\n+-- stack.go --\n+package stack\n+\n+import \"runtime\"\n+\n+func TopFile() string {\n+\t_, file, _, _ := runtime.Caller(0)\n+\treturn file\n+}"}, {"sha": "efff08826ad5ddf894f99a74512f63f13ba3cc19", "filename": "libgo/go/cmd/go/testdata/mod/not-rsc.io_quote_v0.1.0-nomod.txt", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fnot-rsc.io_quote_v0.1.0-nomod.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fnot-rsc.io_quote_v0.1.0-nomod.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fmod%2Fnot-rsc.io_quote_v0.1.0-nomod.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,59 @@\n+Constructed by hand.\n+(derived from rsc.io/quote@e7a685a342, but without an explicit go.mod file.)\n+\n+-- .mod --\n+module \"not-rsc.io/quote\"\n+-- .info --\n+{\"Version\":\"v0.1.0-nomod\",\"Time\":\"2018-02-14T00:51:33Z\"}\n+-- quote.go --\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Package quote collects pithy sayings.\n+package quote // import \"rsc.io/quote\"\n+\n+// Hello returns a greeting.\n+func Hello() string {\n+\treturn \"Hello, world.\"\n+}\n+\n+// Glass returns a useful phrase for world travelers.\n+func Glass() string {\n+\t// See http://www.oocities.org/nodotus/hbglass.html.\n+\treturn \"I can eat glass and it doesn't hurt me.\"\n+}\n+\n+// Go returns a Go proverb.\n+func Go() string {\n+\treturn \"Don't communicate by sharing memory, share memory by communicating.\"\n+}\n+-- quote_test.go --\n+// Copyright 2018 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package quote\n+\n+import \"testing\"\n+\n+func TestHello(t *testing.T) {\n+\thello := \"Hello, world.\"\n+\tif out := Hello(); out != hello {\n+\t\tt.Errorf(\"Hello() = %q, want %q\", out, hello)\n+\t}\n+}\n+\n+func TestGlass(t *testing.T) {\n+\tglass := \"I can eat glass and it doesn't hurt me.\"\n+\tif out := Glass(); out != glass {\n+\t\tt.Errorf(\"Glass() = %q, want %q\", out, glass)\n+\t}\n+}\n+\n+func TestGo(t *testing.T) {\n+\tgo1 := \"Don't communicate by sharing memory. Share memory by communicating.\"\n+\tif out := Go(); out != go1 {\n+\t\tt.Errorf(\"Go() = %q, want %q\", out, go1)\n+\t}\n+}"}, {"sha": "91fbf7d8ec38cd6fd1c23dd7080f4a060420387b", "filename": "libgo/go/cmd/go/testdata/print_goroot.go", "status": "modified", "additions": 5, "deletions": 2, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fprint_goroot.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -4,8 +4,11 @@\n \n package main\n \n-import \"runtime\"\n+import (\n+\t\"fmt\"\n+\t\"runtime\"\n+)\n \n func main() {\n-\tprintln(runtime.GOROOT())\n+\tfmt.Println(runtime.GOROOT())\n }"}, {"sha": "2782a097079877fca8eb0bc1bd14af48b5af5cbd", "filename": "libgo/go/cmd/go/testdata/script/README", "status": "modified", "additions": 10, "deletions": 4, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2FREADME?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -38,6 +38,7 @@ Scripts also have access to these other environment variables:\n \tTMPDIR=$WORK/tmp\n \tdevnull=<value of os.DevNull>\n \tgoversion=<current Go version; for example, 1.12>\n+\t:=<OS-specific path list separator>\n \n The scripts supporting files are unpacked relative to $GOPATH/src (aka $WORK/gopath/src)\n and then the script begins execution in that directory as well. Thus the example above runs\n@@ -77,9 +78,13 @@ should only run when the condition is satisfied. The available conditions are:\n    - [root] for os.Geteuid() == 0\n    - [symlink] for testenv.HasSymlink()\n    - [exec:prog] for whether prog is available for execution (found by exec.LookPath)\n+   - [GODEBUG:value] for whether value is one of the comma-separated entries in the GODEBUG variable\n+   - [buildmode:value] for whether -buildmode=value is supported\n \n A condition can be negated: [!short] means to run the rest of the line\n-when testing.Short() is false.\n+when testing.Short() is false. Multiple conditions may be given for a single\n+command, for example, '[linux] [amd64] skip'. The command will run if all conditions\n+are satisfied.\n \n The commands are:\n \n@@ -105,13 +110,14 @@ The commands are:\n   Like cmp, but environment variables are substituted in the file contents\n   before the comparison. For example, $GOOS is replaced by the target GOOS.\n \n-- cp src... dst\n+- [!] cp src... dst\n   Copy the listed files to the target file or existing directory.\n   src can include \"stdout\" or \"stderr\" to use the standard output or standard error\n   from the most recent exec or go command.\n \n - env [-r] [key=value...]\n-  With no arguments, print the environment (useful for debugging).\n+  With no arguments, print the environment to stdout\n+  (useful for debugging and for verifying initial state).\n   Otherwise add the listed key=value pairs to the environment.\n   The -r flag causes the values to be escaped using regexp.QuoteMeta\n   before being recorded.\n@@ -160,7 +166,7 @@ The commands are:\n \n - [!] stdout [-count=N] pattern\n   Apply the grep command (see above) to the standard output\n-  from the most recent exec, go, or wait command.\n+  from the most recent exec, go, wait, or env command.\n \n - stop [message]\n   Stop the test early (marking it as passing), including the message if given."}, {"sha": "f52250a1b0b52dcdcf27965bb446a9eb5a860514", "filename": "libgo/go/cmd/go/testdata/script/bug.txt", "status": "modified", "additions": 3, "deletions": 2, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbug.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,14 +1,15 @@\n # Verify that go bug creates the appropriate URL issue body\n \n [!linux] skip\n+[gccgo] skip\n \n go install\n env BROWSER=$GOPATH/bin/browser\n go bug\n exists $TMPDIR/browser\n grep '^go version' $TMPDIR/browser\n-[!gccgo] grep '^GOROOT/bin/go version: go version' $TMPDIR/browser\n-[!gccgo] grep '^GOROOT/bin/go tool compile -V: compile version' $TMPDIR/browser\n+grep '^GOROOT/bin/go version: go version' $TMPDIR/browser\n+grep '^GOROOT/bin/go tool compile -V: compile version' $TMPDIR/browser\n grep '^uname -sr: Linux' $TMPDIR/browser\n \n -- go.mod --"}, {"sha": "9a4b9d7b40c7264ea9cec6df11a66006be3a41fe", "filename": "libgo/go/cmd/go/testdata/script/build_cache_trimpath.txt", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_cache_trimpath.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,3 +1,4 @@\n+[short] skip\n env GO111MODULE=on\n \n # Set up fresh GOCACHE.\n@@ -12,9 +13,35 @@ go build -x -o a.out -trimpath\n stderr '(compile|gccgo)( |\\.exe)'\n stderr 'link( |\\.exe)'\n \n+# Two distinct versions of the same module with identical content should\n+# still be cached separately.\n+# Verifies golang.org/issue/35412.\n+go get -d example.com/stack@v1.0.0\n+go run -trimpath printstack.go\n+stdout '^example.com/stack@v1.0.0/stack.go$'\n+go get -d example.com/stack@v1.0.1\n+go run -trimpath printstack.go\n+stdout '^example.com/stack@v1.0.1/stack.go$'\n+\n -- $WORK/hello.go --\n package main\n func main() { println(\"hello\") }\n \n+-- $WORK/printstack.go --\n+// +build ignore\n+\n+package main\n+\n+import (\n+\t\"fmt\"\n+\n+\t\"example.com/stack\"\n+)\n+\n+func main() {\n+\tfmt.Println(stack.TopFile())\n+}\n -- $WORK/go.mod --\n module m\n+\n+go 1.14"}, {"sha": "e0accb10d501413763495e58c0344785947b61a8", "filename": "libgo/go/cmd/go/testdata/script/build_gcflags.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_gcflags.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,21 @@\n+env GO111MODULE=off\n+\n+# Test that the user can override default code generation flags.\n+\n+[gccgo] skip  # gccgo does not use -gcflags\n+[!cgo] skip\n+[!linux] skip  # test only works if c-archive implies -shared\n+[short] skip\n+\n+go build -x -buildmode=c-archive -gcflags=all=-shared=false ./override.go\n+stderr '^.*/compile (.* )?-shared (.* )?-shared=false'\n+\n+-- override.go --\n+package main\n+\n+import \"C\"\n+\n+//export GoFunc\n+func GoFunc() {}\n+\n+func main() {}"}, {"sha": "0e7ebed0f99e28f72e1f3ea77006b4b6354ca534", "filename": "libgo/go/cmd/go/testdata/script/build_i.txt", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_i.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,41 @@\n+env GO111MODULE=off\n+\n+# Test that 'go build -i' installs dependencies of the requested package.\n+\n+[short] skip\n+\n+# Since we are checking installation of dependencies, use a clean cache\n+# to ensure that multiple runs of the test do not interfere.\n+env GOCACHE=$WORK/cache\n+\n+# The initial 'go build -i' for bar should install its dependency foo.\n+\n+go build -v -i x/y/bar\n+stderr 'x/y/foo'    # should be rebuilt\n+go build -v -i x/y/bar\n+! stderr 'x/y/foo'  # should already be installed\n+\n+# After modifying the source files, both packages should be rebuild.\n+\n+cp x/y/foo/foo.go.next x/y/foo/foo.go\n+cp x/y/bar/bar.go.next x/y/bar/bar.go\n+\n+go build -v -i x/y/bar\n+stderr 'x/y/foo'    # should be rebuilt\n+go build -v -i x/y/bar\n+! stderr 'x/y/foo'  # should already be installed\n+\n+-- x/y/foo/foo.go --\n+package foo\n+func F() {}\n+-- x/y/bar/bar.go --\n+package bar\n+import \"x/y/foo\"\n+func F() { foo.F() }\n+-- x/y/foo/foo.go.next --\n+package foo\n+func F() { F() }\n+-- x/y/bar/bar.go.next --\n+package main\n+import \"x/y/foo\"\n+func main() { foo.F() }"}, {"sha": "8afd8b8a2e11af607e639cb2a8eb41982265164b", "filename": "libgo/go/cmd/go/testdata/script/build_multi_main.txt", "status": "modified", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_multi_main.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,6 +10,11 @@ stderr 'no main packages'\n ! go build ./cmd/c1\n stderr 'already exists and is a directory'\n \n+# Verify build -o output correctly local packages\n+mkdir $WORK/local\n+go build -o $WORK/local ./exec.go\n+exists $WORK/local/exec$GOEXE\n+\n -- go.mod --\n module exmod\n \n@@ -29,5 +34,10 @@ package pkg1\n -- pkg2/pkg2.go --\n package pkg2\n \n+-- exec.go --\n+package main\n+\n+func main() {}\n+\n -- c1$GOEXE/keep.txt --\n Create c1 directory."}, {"sha": "cfab80743eabd42a5f2235bbb985e482e29bc085", "filename": "libgo/go/cmd/go/testdata/script/build_trimpath.txt", "status": "modified", "additions": 124, "deletions": 13, "changes": 137, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fbuild_trimpath.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,21 +1,132 @@\n [short] skip\n \n-env -r GOROOT_REGEXP=$GOROOT\n-env -r WORK_REGEXP=$WORK\n-env GOROOT GOROOT_REGEXP WORK WORK_REGEXP\n+# Set up two identical directories that can be used as GOPATH.\n+env GO111MODULE=on\n+mkdir $WORK/a/src/paths $WORK/b/src/paths\n+cp paths.go $WORK/a/src/paths\n+cp paths.go $WORK/b/src/paths\n+cp go.mod $WORK/a/src/paths/\n+cp go.mod $WORK/b/src/paths/\n \n-go build -trimpath -o hello.exe hello.go\n-! grep -q $GOROOT_REGEXP hello.exe\n-! grep -q $WORK_REGEXP hello.exe\n \n-env GO111MODULE=on\n-go build -trimpath -o fortune.exe rsc.io/fortune\n-! grep -q $GOROOT_REGEXP fortune.exe\n-! grep -q $WORK_REGEXP fortune.exe\n+# A binary built without -trimpath should contain the module root dir\n+# and GOROOT for debugging and stack traces.\n+cd $WORK/a/src/paths\n+go build -o $WORK/paths-dbg.exe .\n+exec $WORK/paths-dbg.exe $WORK/paths-dbg.exe\n+stdout 'binary contains module root: true'\n+stdout 'binary contains GOROOT: true'\n+\n+# A binary built with -trimpath should not contain the current workspace\n+# or GOROOT.\n+go build -trimpath -o $WORK/paths-a.exe .\n+exec $WORK/paths-a.exe $WORK/paths-a.exe\n+stdout 'binary contains module root: false'\n+stdout 'binary contains GOROOT: false'\n+\n+# A binary from an external module built with -trimpath should not contain\n+# the current workspace or GOROOT.\n+go get -trimpath rsc.io/fortune\n+exec $WORK/paths-a.exe $GOPATH/bin/fortune$GOEXE\n+stdout 'binary contains module root: false'\n+stdout 'binary contains GOROOT: false'\n+go mod edit -droprequire rsc.io/fortune\n+\n+# Two binaries built from identical packages in different directories\n+# should be identical.\n+cd $WORK/b/src/paths\n+go build -trimpath -o $WORK/paths-b.exe\n+cmp -q $WORK/paths-a.exe $WORK/paths-b.exe\n+\n+\n+# Same sequence of tests but in GOPATH mode.\n+# A binary built without -trimpath should contain GOPATH and GOROOT.\n+env GO111MODULE=off\n+cd $WORK\n+env GOPATH=$WORK/a\n+go build -o paths-dbg.exe paths\n+exec ./paths-dbg.exe paths-dbg.exe\n+stdout 'binary contains GOPATH: true'\n+stdout 'binary contains GOROOT: true'\n+\n+# A binary built with -trimpath should not contain GOPATH or GOROOT.\n+go build -trimpath -o paths-a.exe paths\n+exec ./paths-a.exe paths-a.exe\n+stdout 'binary contains GOPATH: false'\n+stdout 'binary contains GOROOT: false'\n+\n+# Two binaries built from identical packages in different GOPATH roots\n+# should be identical.\n+env GOPATH=$WORK/b\n+go build -trimpath -o paths-b.exe paths\n+cmp -q paths-a.exe paths-b.exe\n+\n \n--- hello.go --\n+# Same sequence of tests but with gccgo.\n+# gccgo does not support builds in module mode.\n+[!exec:gccgo] stop\n+env GOPATH=$WORK/a\n+\n+# A binary built with gccgo without -trimpath should contain the current\n+# GOPATH and GOROOT.\n+go build -compiler=gccgo -o paths-dbg.exe paths\n+exec ./paths-dbg.exe paths-dbg.exe\n+stdout 'binary contains GOPATH: true'\n+stdout 'binary contains GOROOT: false' # gccgo doesn't load std from GOROOT.\n+\n+# A binary built with gccgo with -trimpath should not contain GOPATH or GOROOT.\n+go build -compiler=gccgo -trimpath -o paths-a.exe paths\n+exec ./paths-a.exe paths-a.exe\n+stdout 'binary contains GOPATH: false'\n+stdout 'binary contains GOROOT: false'\n+\n+# Two binaries built from identical packages in different directories\n+# should be identical.\n+env GOPATH=$WORK/b\n+go build -compiler=gccgo -trimpath -o paths-b.exe paths\n+cmp -q paths-a.exe paths-b.exe\n+\n+-- paths.go --\n package main\n-func main() { println(\"hello\") }\n+\n+import (\n+\t\"bytes\"\n+\t\"fmt\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+\t\"os/exec\"\n+\t\"path/filepath\"\n+\t\"strings\"\n+)\n+\n+func main() {\n+\texe := os.Args[1]\n+\tdata, err := ioutil.ReadFile(exe)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\n+\tif os.Getenv(\"GO111MODULE\") == \"on\" {\n+\t\tout, err := exec.Command(\"go\", \"env\", \"GOMOD\").Output()\n+\t\tif err != nil {\n+\t\t\tlog.Fatal(err)\n+\t\t}\n+\t\tmodRoot := filepath.Dir(strings.TrimSpace(string(out)))\n+\t\tcheck(data, \"module root\", modRoot)\n+\t} else {\n+\t\tcheck(data, \"GOPATH\", os.Getenv(\"GOPATH\"))\n+\t}\n+\tcheck(data, \"GOROOT\", os.Getenv(\"GOROOT\"))\n+}\n+\n+func check(data []byte, desc, dir string) {\n+\tcontainsDir := bytes.Contains(data, []byte(dir))\n+\tcontainsSlashDir := bytes.Contains(data, []byte(filepath.ToSlash(dir)))\n+\tfmt.Printf(\"binary contains %s: %v\\n\", desc, containsDir || containsSlashDir)\n+}\n \n -- go.mod --\n-module m\n+module paths\n+\n+go 1.14"}, {"sha": "928024e0340c9c3662f61f291cd4f0d0dc8d6982", "filename": "libgo/go/cmd/go/testdata/script/cache_vet.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_vet.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_vet.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcache_vet.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,22 @@\n+env GO111MODULE=off\n+\n+[short] skip\n+[GODEBUG:gocacheverify=1] skip\n+[gccgo] skip  # gccgo has no standard packages\n+\n+# Start with a clean build cache:\n+# test failures may be masked if the cache has just the right entries already.\n+env GOCACHE=$WORK/cache\n+\n+# Run 'go vet os/user' once to warm up the cache.\n+go vet os/user\n+\n+# Check that second vet reuses cgo-derived inputs.\n+# The first command could be build instead of vet,\n+# except that if the cache is empty and there's a net.a\n+# in GOROOT/pkg, the build will not bother to regenerate\n+# and cache the cgo outputs, whereas vet always will.\n+\n+go vet -x os/user\n+! stderr '^(clang|gcc)'  # should not have run compiler\n+! stderr '[\\\\/]cgo '     # should not have run cgo"}, {"sha": "685c606a413c1edf9e8a4dd55cb19ade88e50caa", "filename": "libgo/go/cmd/go/testdata/script/cmd_import_error.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcmd_import_error.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,7 @@ env GO111MODULE=on\n # a clear error in module mode.\n \n ! go list cmd/unknown\n-stderr '^can''t load package: package cmd/unknown: package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n+stderr '^can''t load package: package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'\n \n go list -f '{{range .DepsErrors}}{{.Err}}{{end}}' x.go\n stdout '^package cmd/unknown is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]cmd[/\\\\]unknown\\)$'"}, {"sha": "20c9199ae7dccec4111d128ca03311bacbfe53b8", "filename": "libgo/go/cmd/go/testdata/script/cover_mod_empty.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_mod_empty.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_mod_empty.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_mod_empty.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,11 @@\n+[gccgo] skip\n+\n+go tool cover -func=cover.out\n+stdout total.*statements.*0.0%\n+\n+go mod init golang.org/issue/33855\n+\n+go tool cover -func=cover.out\n+stdout total.*statements.*0.0%\n+\n+-- cover.out --"}, {"sha": "f8a399d0e6099fe5aa4ce337802aa55ab62fb556", "filename": "libgo/go/cmd/go/testdata/script/cover_modes.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_modes.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_modes.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_modes.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,25 @@\n+env GO111MODULE=off\n+\n+# Coverage analysis should use 'set' mode by default,\n+# and should merge coverage profiles correctly.\n+\n+[short] skip\n+[gccgo] skip # gccgo has no cover tool\n+\n+go test -short -cover encoding/binary errors -coverprofile=$WORK/cover.out\n+! stderr '[^0-9]0\\.0%'\n+! stdout '[^0-9]0\\.0%'\n+\n+grep -count=1 '^mode: set$' $WORK/cover.out\n+grep 'errors\\.go' $WORK/cover.out\n+grep 'binary\\.go' $WORK/cover.out\n+\n+[!race] stop\n+\n+go test -short -race -cover encoding/binary errors -coverprofile=$WORK/cover.out\n+! stderr '[^0-9]0\\.0%'\n+! stdout '[^0-9]0\\.0%'\n+\n+grep -count=1 '^mode: atomic$' $WORK/cover.out\n+grep 'errors\\.go' $WORK/cover.out\n+grep 'binary\\.go' $WORK/cover.out"}, {"sha": "f21cd8b3a8e6e696db21146112aeec8d119fc732", "filename": "libgo/go/cmd/go/testdata/script/cover_pkgall_multiple_mains.txt", "status": "modified", "additions": 12, "deletions": 9, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fcover_pkgall_multiple_mains.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,29 +1,32 @@\n # This test checks that multiple main packages can be tested\n # with -coverpkg=all without duplicate symbol errors.\n-# Verifies golang.org/issue/30374.\n-\n-env GO111MODULE=on\n+# Verifies golang.org/issue/30374, golang.org/issue/34114.\n \n [short] skip\n+cd $GOPATH/src/example.com/cov\n+\n+env GO111MODULE=on\n+go test -coverpkg=all ./...\n \n+env GO111MODULE=off\n go test -coverpkg=all ./...\n \n--- go.mod --\n+-- $GOPATH/src/example.com/cov/go.mod --\n module example.com/cov\n \n--- mainonly/mainonly.go --\n+-- $GOPATH/src/example.com/cov/mainonly/mainonly.go --\n package main\n \n func main() {}\n \n--- mainwithtest/mainwithtest.go --\n+-- $GOPATH/src/example.com/cov/mainwithtest/mainwithtest.go --\n package main\n \n func main() {}\n \n func Foo() {}\n \n--- mainwithtest/mainwithtest_test.go --\n+-- $GOPATH/src/example.com/cov/mainwithtest/mainwithtest_test.go --\n package main\n \n import \"testing\"\n@@ -32,10 +35,10 @@ func TestFoo(t *testing.T) {\n   Foo()\n }\n \n--- xtest/x.go --\n+-- $GOPATH/src/example.com/cov/xtest/x.go --\n package x\n \n--- xtest/x_test.go --\n+-- $GOPATH/src/example.com/cov/xtest/x_test.go --\n package x_test\n \n import \"testing\""}, {"sha": "ccb866aed1a57d90988514000fa5f19105ca5402", "filename": "libgo/go/cmd/go/testdata/script/devnull.txt", "status": "added", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdevnull.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdevnull.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fdevnull.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,26 @@\n+env GO111MODULE=off\n+\n+# Issue 28035: go test -c -o NUL should work.\n+# Issue 28549: go test -c -o /dev/null should not overwrite /dev/null when run as root.\n+cd x\n+cmp $devnull $WORK/empty.txt\n+go test -o=$devnull -c\n+! exists x.test$GOEXE\n+cmp $devnull $WORK/empty.txt\n+\n+# Issue 12407: go build -o /dev/null should succeed.\n+cd ..\n+go build -o $devnull y\n+cmp $devnull $WORK/empty.txt\n+\n+-- x/x_test.go --\n+package x_test\n+import (\n+    \"testing\"\n+)\n+func TestNUL(t *testing.T) {\n+}\n+-- y/y.go --\n+package y\n+func main() {}\n+-- $WORK/empty.txt --"}, {"sha": "1cc08466c96cfc74feef12e4db45ef6a1774d25d", "filename": "libgo/go/cmd/go/testdata/script/env_write.txt", "status": "modified", "additions": 33, "deletions": 0, "changes": 33, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fenv_write.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -85,3 +85,36 @@ stderr 'multiple values for key: GOOS'\n # go env -w rejects missing variables\n ! go env -w GOOS\n stderr 'arguments must be KEY=VALUE: invalid argument: GOOS'\n+\n+# go env -w rejects invalid GO111MODULE values, as otherwise cmd/go would break\n+! go env -w GO111MODULE=badvalue\n+stderr 'invalid GO111MODULE value \"badvalue\"'\n+\n+# go env -w rejects invalid GOPATH values\n+! go env -w GOPATH=~/go\n+stderr 'GOPATH entry cannot start with shell metacharacter'\n+\n+! go env -w GOPATH=./go\n+stderr 'GOPATH entry is relative; must be absolute path'\n+\n+# go env -w/-u checks validity of GOOS/ARCH combinations\n+[gccgo] skip\n+env GOOS=\n+env GOARCH=\n+# check -w doesn't allow invalid GOOS\n+! go env -w GOOS=linuxx\n+stderr 'unsupported GOOS/GOARCH pair linuxx'\n+# check -w doesn't allow invalid GOARCH\n+! go env -w GOARCH=amd644\n+stderr 'unsupported GOOS/GOARCH.*/amd644$'\n+# check -w doesn't allow invalid GOOS with valid GOARCH\n+! go env -w GOOS=linuxx GOARCH=amd64\n+stderr 'unsupported GOOS/GOARCH pair linuxx'\n+# check a valid GOOS and GOARCH values but an incompatible combinations\n+! go env -w GOOS=android GOARCH=s390x\n+stderr 'unsupported GOOS/GOARCH pair android/s390x'\n+# check that -u considers explicit envs\n+go env -w GOOS=linux GOARCH=mips\n+env GOOS=windows\n+! go env -u GOOS\n+stderr 'unsupported GOOS/GOARCH.*windows/mips$'"}, {"sha": "297ec0fe3c7c28d533065de426e99e229388f54b", "filename": "libgo/go/cmd/go/testdata/script/fmt_load_errors.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ffmt_load_errors.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,19 @@\n+env GO111MODULE=off\n+\n+! go fmt does-not-exist\n+\n+go fmt -n exclude\n+stdout 'exclude[/\\\\]x\\.go'\n+stdout 'exclude[/\\\\]x_linux\\.go'\n+\n+-- exclude/empty/x.txt --\n+-- exclude/ignore/_x.go --\n+package x\n+-- exclude/x.go --\n+// +build linux,!linux\n+\n+package x\n+-- exclude/x_linux.go --\n+// +build windows\n+\n+package x"}, {"sha": "b63ba46ced0f1e8756467f27b1f7b944de2dfb74", "filename": "libgo/go/cmd/go/testdata/script/gccgo_m.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_m.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_m.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_m.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,19 @@\n+# It's absurd, but builds with -compiler=gccgo used to fail to build module m.\n+# golang.org/issue/34358\n+\n+env GO111MODULE=off\n+\n+[short] skip\n+\n+cd m\n+go build\n+exists m$GOEXE\n+rm m$GOEXE\n+[exec:gccgo] go build -compiler=gccgo\n+[exec:gccgo] exists m$GOEXE\n+\n+-- m/go.mod --\n+module m\n+-- m/main.go --\n+package main\n+func main() {}"}, {"sha": "7a09a8002ec85634cc043d4aaa0a3f7eccb117bd", "filename": "libgo/go/cmd/go/testdata/script/gccgo_mangle.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_mangle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_mangle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgccgo_mangle.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,15 @@\n+# Issue 33871.\n+\n+cd m/a.0\n+go build\n+\n+-- m/go.mod --\n+module m\n+-- m/a.0/a.go --\n+package a\n+\n+type T int\n+\n+func (t T) M() int {\n+\treturn int(t)\n+}"}, {"sha": "0478d1f75dea2f99b0281dd7b2ec3e76688d732d", "filename": "libgo/go/cmd/go/testdata/script/get_insecure_redirect.txt", "status": "modified", "additions": 2, "deletions": 3, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fget_insecure_redirect.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,11 +1,10 @@\n # golang.org/issue/29591: 'go get' was following plain-HTTP redirects even without -insecure.\n+# golang.org/issue/34049: 'go get' would panic in case of an insecure redirect in GOPATH mode\n \n [!net] skip\n [!exec:git] skip\n \n-env GO111MODULE=on\n-env GOPROXY=direct\n-env GOSUMDB=off\n+env GO111MODULE=off\n \n ! go get -d vcs-test.golang.org/insecure/go/insecure\n stderr 'redirected .* to insecure URL'"}, {"sha": "686d1138b8318e3d0ed5affd6673ee66ead24c96", "filename": "libgo/go/cmd/go/testdata/script/goflags.txt", "status": "modified", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgoflags.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -49,3 +49,11 @@ stderr '^go: invalid boolean value \\\"asdf\\\" for flag -e \\(from (\\$GOFLAGS|%GOFLA\n go env\n stdout GOFLAGS\n \n+# Flags listed in GOFLAGS should be safe to duplicate on the command line.\n+env GOFLAGS=-tags=magic\n+go list -tags=magic\n+go test -tags=magic -c -o $devnull\n+go vet -tags=magic\n+\n+-- foo_test.go --\n+package foo"}, {"sha": "4b42fc593f9ddf4b9927d1bcadfab461ef0b74e5", "filename": "libgo/go/cmd/go/testdata/script/gopath_install.txt", "status": "added", "additions": 53, "deletions": 0, "changes": 53, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_install.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,53 @@\n+# Regression test for 'go install' locations in GOPATH mode.\n+env GO111MODULE=off\n+[short] skip\n+\n+# Without $GOBIN set, binaries should be installed into the GOPATH bin directory.\n+env GOBIN=\n+rm $GOPATH/bin/go-cmd-test$GOEXE\n+go install go-cmd-test\n+exists $GOPATH/bin/go-cmd-test$GOEXE\n+\n+# With $GOBIN set, binaries should be installed to $GOBIN.\n+env GOBIN=$WORK/bin1\n+mkdir -p $GOBIN\n+go install go-cmd-test\n+exists $GOBIN/go-cmd-test$GOEXE\n+\n+# Issue 11065: installing to the current directory should create an executable.\n+cd go-cmd-test\n+env GOBIN=$PWD\n+go install\n+exists ./go-cmd-test$GOEXE\n+cd ..\n+\n+# Without $GOBIN set, installing a program outside $GOPATH should fail\n+# (there is nowhere to install it).\n+env GOPATH= # reset to default ($HOME/go, which does not exist)\n+env GOBIN=\n+! go install go-cmd-test/helloworld.go\n+stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+\n+# With $GOBIN set, should install there.\n+env GOBIN=$WORK/bin1\n+go install go-cmd-test/helloworld.go\n+exists $GOBIN/helloworld$GOEXE\n+\n+# We can't assume that we can write to GOROOT, because it may not be writable.\n+# However, we can check its install location using 'go list'.\n+# cmd/fix should be installed to GOROOT/pkg, not GOPATH/bin.\n+env GOPATH=$PWD\n+go list -f '{{.Target}}' cmd/fix\n+stdout $GOROOT'[/\\\\]pkg[/\\\\]tool[/\\\\]'$GOOS'_'$GOARCH'[/\\\\]fix'$GOEXE'$'\n+\n+# GOBIN should not affect toolchain install locations.\n+env GOBIN=$WORK/bin1\n+go list -f '{{.Target}}' cmd/fix\n+stdout $GOROOT'[/\\\\]pkg[/\\\\]tool[/\\\\]'$GOOS'_'$GOARCH'[/\\\\]fix'$GOEXE'$'\n+\n+-- go-cmd-test/helloworld.go --\n+package main\n+\n+func main() {\n+\tprintln(\"hello world\")\n+}"}, {"sha": "7ee1f83471c631f4b5f41bab1105bdefa76c5973", "filename": "libgo/go/cmd/go/testdata/script/gopath_local.txt", "status": "added", "additions": 117, "deletions": 0, "changes": 117, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_local.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,117 @@\n+env GO111MODULE=off  # Relative imports only work in GOPATH mode.\n+\n+[short] skip\n+\n+# Imports should be resolved relative to the source file.\n+go build testdata/local/easy.go\n+exec ./easy$GOEXE\n+stdout '^easysub\\.Hello'\n+\n+# Ignored files should be able to import the package built from\n+# non-ignored files in the same directory.\n+go build -o easysub$GOEXE testdata/local/easysub/main.go\n+exec ./easysub$GOEXE\n+stdout '^easysub\\.Hello'\n+\n+# Files in relative-imported packages should be able to\n+# use relative imports themselves.\n+go build testdata/local/hard.go\n+exec ./hard$GOEXE\n+stdout '^sub\\.Hello'\n+\n+# Explicit source files listed on the command line should not install without\n+# GOBIN set, since individual source files aren't part of the containing GOPATH.\n+! go install testdata/local/easy.go\n+stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+\n+[windows] stop  # Windows does not allow the ridiculous directory name we're about to use.\n+\n+env BAD_DIR_NAME='#$%:, &()*;<=>?\\^{}'\n+\n+mkdir -p testdata/$BAD_DIR_NAME/easysub\n+mkdir -p testdata/$BAD_DIR_NAME/sub/sub\n+\n+cp testdata/local/easy.go testdata/$BAD_DIR_NAME/easy.go\n+cp testdata/local/easysub/easysub.go testdata/$BAD_DIR_NAME/easysub/easysub.go\n+cp testdata/local/easysub/main.go testdata/$BAD_DIR_NAME/easysub/main.go\n+cp testdata/local/hard.go testdata/$BAD_DIR_NAME/hard.go\n+cp testdata/local/sub/sub.go testdata/$BAD_DIR_NAME/sub/sub.go\n+cp testdata/local/sub/sub/subsub.go testdata/$BAD_DIR_NAME/sub/sub/subsub.go\n+\n+# Imports should be resolved relative to the source file.\n+go build testdata/$BAD_DIR_NAME/easy.go\n+exec ./easy$GOEXE\n+stdout '^easysub\\.Hello'\n+\n+# Ignored files should be able to import the package built from\n+# non-ignored files in the same directory.\n+go build -o easysub$GOEXE testdata/$BAD_DIR_NAME/easysub/main.go\n+exec ./easysub$GOEXE\n+stdout '^easysub\\.Hello'\n+\n+# Files in relative-imported packages should be able to\n+# use relative imports themselves.\n+go build testdata/$BAD_DIR_NAME/hard.go\n+exec ./hard$GOEXE\n+stdout '^sub\\.Hello'\n+\n+# Explicit source files listed on the command line should not install without\n+# GOBIN set, since individual source files aren't part of the containing GOPATH.\n+! go install testdata/$BAD_DIR_NAME/easy.go\n+stderr '^go install: no install location for \\.go files listed on command line \\(GOBIN not set\\)$'\n+\n+-- testdata/local/easy.go --\n+package main\n+\n+import \"./easysub\"\n+\n+func main() {\n+\teasysub.Hello()\n+}\n+-- testdata/local/easysub/easysub.go --\n+package easysub\n+\n+import \"fmt\"\n+\n+func Hello() {\n+\tfmt.Println(\"easysub.Hello\")\n+}\n+-- testdata/local/easysub/main.go --\n+// +build ignore\n+\n+package main\n+\n+import \".\"\n+\n+func main() {\n+\teasysub.Hello()\n+}\n+-- testdata/local/hard.go --\n+package main\n+\n+import \"./sub\"\n+\n+func main() {\n+\tsub.Hello()\n+}\n+-- testdata/local/sub/sub.go --\n+package sub\n+\n+import (\n+\t\"fmt\"\n+\n+\tsubsub \"./sub\"\n+)\n+\n+func Hello() {\n+\tfmt.Println(\"sub.Hello\")\n+\tsubsub.Hello()\n+}\n+-- testdata/local/sub/sub/subsub.go --\n+package subsub\n+\n+import \"fmt\"\n+\n+func Hello() {\n+\tfmt.Println(\"subsub.Hello\")\n+}"}, {"sha": "869980da7c5224c89d6ffe10cd0045a2081c8a2a", "filename": "libgo/go/cmd/go/testdata/script/gopath_moved_repo.txt", "status": "added", "additions": 68, "deletions": 0, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_moved_repo.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,68 @@\n+env GO111MODULE=off\n+\n+# Test that 'go get -u' reports packages whose VCS configurations do not\n+# match their import paths.\n+\n+[!net] skip\n+[short] skip\n+\n+# We need to execute a custom Go program to break the config files.\n+#\n+# git will ask for a username and password when we run 'go get -d -f -u',\n+# so we also need to set GIT_ASKPASS. Conveniently, a single binary can\n+# perform both tasks!\n+\n+go build -o replace.exe replace\n+env GIT_ASKPASS=$PWD/replace.exe\n+\n+\n+# Test that 'go get -u' reports moved git packages.\n+\n+[exec:git] go get -d rsc.io/pdf\n+[exec:git] go get -d -u rsc.io/pdf\n+[exec:git] exec ./replace.exe pdf rsc.io/pdf/.git/config\n+\n+[exec:git] ! go get -d -u rsc.io/pdf\n+[exec:git] stderr 'is a custom import path for'\n+[exec:git] ! go get -d -f -u rsc.io/pdf\n+[exec:git] stderr 'validating server certificate|[nN]ot [fF]ound'\n+\n+\n+# Test that 'go get -u' reports moved Mercurial packages.\n+\n+[exec:hg] go get -d vcs-test.golang.org/go/custom-hg-hello\n+[exec:hg] go get -d -u vcs-test.golang.org/go/custom-hg-hello\n+[exec:hg] exec ./replace.exe custom-hg-hello vcs-test.golang.org/go/custom-hg-hello/.hg/hgrc\n+\n+[exec:hg] ! go get -d -u vcs-test.golang.org/go/custom-hg-hello\n+[exec:hg] stderr 'is a custom import path for'\n+[exec:hg] ! go get -d -f -u vcs-test.golang.org/go/custom-hg-hello\n+[exec:hg] stderr 'validating server certificate|[nN]ot [fF]ound'\n+\n+\n+-- replace/replace.go --\n+package main\n+\n+import (\n+\t\"bytes\"\n+\t\"io/ioutil\"\n+\t\"log\"\n+\t\"os\"\n+)\n+\n+func main() {\n+\tif len(os.Args) < 3 {\n+\t\treturn\n+\t}\n+\n+\tbase := []byte(os.Args[1])\n+\tpath := os.Args[2]\n+\tdata, err := ioutil.ReadFile(path)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\terr = ioutil.WriteFile(path, bytes.ReplaceAll(data, base, append(base, \"XXX\"...)), 0644)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "04265b176f57f15dc3d4ff4b527ad41125644e15", "filename": "libgo/go/cmd/go/testdata/script/gopath_paths.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_paths.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_paths.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fgopath_paths.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,43 @@\n+# Regression test for GOPATH validation in GOPATH mode.\n+env GO111MODULE=off\n+\n+env ORIG_GOPATH=$GOPATH\n+\n+# The literal path '.' in GOPATH should be rejected.\n+env GOPATH=.\n+! go build go-cmd-test/helloworld.go\n+stderr 'GOPATH entry is relative'\n+\n+# It should still be rejected if the requested package can be\n+# found using another entry.\n+env GOPATH=${:}$ORIG_GOPATH${:}.\n+! go build go-cmd-test\n+stderr 'GOPATH entry is relative'\n+\n+# GOPATH cannot be a relative subdirectory of the working directory.\n+env ORIG_GOPATH\n+stdout 'ORIG_GOPATH='$WORK[/\\\\]gopath\n+cd $WORK\n+env GOPATH=gopath\n+! go build gopath/src/go-cmd-test/helloworld.go\n+stderr 'GOPATH entry is relative'\n+\n+# Blank paths in GOPATH should be rejected as relative (issue 21928).\n+env GOPATH=' '${:}$ORIG_GOPATH\n+! go build go-cmd-test\n+stderr 'GOPATH entry is relative'\n+\n+[short] stop\n+\n+# Empty paths in GOPATH should be ignored (issue 21928).\n+env GOPATH=${:}$ORIG_GOPATH\n+env GOPATH\n+go install go-cmd-test\n+exists $ORIG_GOPATH/bin/go-cmd-test$GOEXE\n+\n+-- go-cmd-test/helloworld.go --\n+package main\n+\n+func main() {\n+\tprintln(\"hello world\")\n+}"}, {"sha": "bc2cc4d3370aa01bae0b80232954bce04bcaaa20", "filename": "libgo/go/cmd/go/testdata/script/import_main.txt", "status": "added", "additions": 114, "deletions": 0, "changes": 114, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fimport_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fimport_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fimport_main.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,114 @@\n+env GO111MODULE=off\n+\n+# Test that you cannot import a main package.\n+# See golang.org/issue/4210 and golang.org/issue/17475.\n+\n+[short] skip\n+cd $WORK\n+\n+# Importing package main from that package main's test should work.\n+go build x\n+go test -c x\n+\n+# Importing package main from another package should fail.\n+! go build p1\n+stderr 'import \"x\" is a program, not an importable package'\n+\n+# ... even in that package's test.\n+go build p2\n+! go test -c p2\n+stderr 'import \"x\" is a program, not an importable package'\n+\n+# ... even if that package's test is an xtest.\n+go build p3\n+! go test p3\n+stderr 'import \"x\" is a program, not an importable package'\n+\n+# ... even if that package is a package main\n+go build p4\n+! go test -c p4\n+stderr 'import \"x\" is a program, not an importable package'\n+\n+# ... even if that package is a package main using an xtest.\n+go build p5\n+! go test -c p5\n+stderr 'import \"x\" is a program, not an importable package'\n+\n+-- x/main.go --\n+package main\n+\n+var X int\n+\n+func main() {}\n+-- x/main_test.go --\n+package main_test\n+\n+import (\n+\t\"testing\"\n+\txmain \"x\"\n+)\n+\n+var _ = xmain.X\n+\n+func TestFoo(t *testing.T) {}\n+-- p1/p.go --\n+package p1\n+\n+import xmain \"x\"\n+\n+var _ = xmain.X\n+-- p2/p.go --\n+package p2\n+-- p2/p_test.go --\n+package p2\n+\n+import (\n+\t\"testing\"\n+\txmain \"x\"\n+)\n+\n+var _ = xmain.X\n+\n+func TestFoo(t *testing.T) {}\n+-- p3/p.go --\n+package p\n+-- p3/p_test.go --\n+package p_test\n+\n+import (\n+\t\"testing\"\n+\txmain \"x\"\n+)\n+\n+var _ = xmain.X\n+\n+func TestFoo(t *testing.T) {}\n+-- p4/p.go --\n+package main\n+\n+func main() {}\n+-- p4/p_test.go --\n+package main\n+\n+import (\n+\t\"testing\"\n+\txmain \"x\"\n+)\n+\n+var _ = xmain.X\n+\n+func TestFoo(t *testing.T) {}\n+-- p5/p.go --\n+package main\n+func main() {}\n+-- p5/p_test.go --\n+package main_test\n+\n+import (\n+\t\"testing\"\n+\txmain \"x\"\n+)\n+\n+var _ = xmain.X\n+\n+func TestFoo(t *testing.T) {}"}, {"sha": "4a5d8c8c627a041a7bcefaa21b44c5730e64044f", "filename": "libgo/go/cmd/go/testdata/script/install_cmd_gobin.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cmd_gobin.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,6 +1,6 @@\n # Check that commands in cmd are install to $GOROOT/bin, not $GOBIN.\n # Verifies golang.org/issue/32674.\n-[gccgo] stop\n+[gccgo] skip\n env GOBIN=gobin\n mkdir gobin\n go list -f '{{.Target}}' cmd/go"}, {"sha": "14cf722262087f61b8416999c96af832f07e0f66", "filename": "libgo/go/cmd/go/testdata/script/install_cross_gobin.txt", "status": "modified", "additions": 1, "deletions": 2, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Finstall_cross_gobin.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,11 +1,10 @@\n env GO111MODULE=off\n [!short] skip # rebuilds std for alternate architecture\n+[gccgo] skip\n \n cd mycmd\n go build mycmd\n \n-[gccgo] stop\n-\n # cross-compile install with implicit GOBIN=$GOPATH/bin can make subdirectory\n env GOARCH=386\n [386] env GOARCH=amd64"}, {"sha": "c2ca27acbf9c290be5da0d1cf6604a7df529c9d9", "filename": "libgo/go/cmd/go/testdata/script/link_syso_issue33139.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flink_syso_issue33139.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,43 @@\n+# Test that we can use the external linker with a host syso file that is\n+# embedded in a package, that is referenced by a Go assembly function.\n+# See issue 33139.\n+[!gc] skip\n+[!exec:cc] skip\n+\n+# External linking is not supported on linux/ppc64.\n+# See: https://github.com/golang/go/issues/8912\n+[linux] [ppc64] skip\n+\n+# External linking is not supported on darwin/386 (10.14+).\n+# See: https://github.com/golang/go/issues/31751\n+[darwin] [386] skip\n+\n+cc -c -o syso/objTestImpl.syso syso/src/objTestImpl.c\n+go build -ldflags='-linkmode=external' ./cmd/main.go\n+\n+-- syso/objTest.s --\n+#include \"textflag.h\"\n+\n+TEXT \u00b7ObjTest(SB), NOSPLIT, $0\n+\t// We do not actually execute this function in the test above, thus\n+\t// there is no stack frame setup here.\n+\t// We only care about Go build and/or link errors when referencing\n+\t// the objTestImpl symbol in the syso file.\n+\tJMP objTestImpl(SB)\n+\n+-- syso/pkg.go --\n+package syso\n+\n+func ObjTest()\n+\n+-- syso/src/objTestImpl.c --\n+void objTestImpl() { /* Empty */ }\n+\n+-- cmd/main.go --\n+package main\n+\n+import \"syso\"\n+\n+func main() {\n+\tsyso.ObjTest()\n+}"}, {"sha": "bdb7ffb077a15b3b5c94906baaa829319cb5e67a", "filename": "libgo/go/cmd/go/testdata/script/list_ambiguous_path.txt", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_ambiguous_path.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,38 @@\n+# Ensures that we can correctly list package patterns ending in '.go'.\n+# See golang.org/issue/34653.\n+\n+# A single pattern for a package ending in '.go'.\n+go list ./foo.go\n+stdout '^test/foo.go$'\n+\n+# Multiple patterns for packages including one ending in '.go'.\n+go list ./bar ./foo.go\n+stdout '^test/bar$'\n+stdout '^test/foo.go$'\n+\n+# A single pattern for a Go file.\n+go list ./a.go\n+stdout '^command-line-arguments$'\n+\n+# A single typo-ed pattern for a Go file. This should\n+# treat the wrong pattern as if it were a package.\n+! go list ./foo.go/b.go\n+stderr 'package ./foo.go/b.go: cannot find package \".\"'\n+\n+# Multiple patterns for Go files with a typo. This should\n+# treat the wrong pattern as if it were a non-existint file.\n+! go list ./foo.go/a.go ./foo.go/b.go\n+[plan9] stderr 'stat ./foo.go/b.go: ''./foo.go/b.go'' does not exist'\n+[windows] stderr './foo.go/b.go: The system cannot find the file specified'\n+[!plan9] [!windows] stderr './foo.go/b.go: no such file or directory'\n+\n+-- a.go --\n+package main\n+-- bar/a.go --\n+package bar\n+-- foo.go/a.go --\n+package foo.go\n+-- go.mod --\n+module \"test\"\n+\n+go 1.13"}, {"sha": "7115c365f05198c263694b06da65bfb00b1995c0", "filename": "libgo/go/cmd/go/testdata/script/list_constraints.txt", "status": "added", "additions": 86, "deletions": 0, "changes": 86, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_constraints.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_constraints.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_constraints.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,86 @@\n+# Check that files and their imports are not included in 'go list' output\n+# when they are excluded by build constraints.\n+\n+# Linux and cgo files should be included when building in that configuration.\n+env GOOS=linux\n+env GOARCH=amd64\n+env CGO_ENABLED=1\n+go list -f '{{range .GoFiles}}{{.}} {{end}}'\n+stdout '^cgotag.go empty.go suffix_linux.go tag.go $'\n+go list -f '{{range .CgoFiles}}{{.}} {{end}}'\n+stdout '^cgoimport.go $'\n+go list -f '{{range .Imports}}{{.}} {{end}}'\n+stdout '^C cgoimport cgotag suffix tag $'\n+\n+# Disabling cgo should exclude cgo files and their imports.\n+env CGO_ENABLED=0\n+go list -f '{{range .GoFiles}}{{.}} {{end}}'\n+stdout 'empty.go suffix_linux.go tag.go'\n+go list -f '{{range .CgoFiles}}{{.}} {{end}}'\n+! stdout .\n+go list -f '{{range .Imports}}{{.}} {{end}}'\n+stdout '^suffix tag $'\n+\n+# Changing OS should exclude linux sources.\n+env GOOS=darwin\n+go list -f '{{range .GoFiles}}{{.}} {{end}}'\n+stdout '^empty.go $'\n+go list -f '{{range .Imports}}{{.}} {{end}}'\n+stdout '^$'\n+\n+# Enabling a tag should include files that require it.\n+go list -tags=extra -f '{{range .GoFiles}}{{.}} {{end}}'\n+stdout '^empty.go extra.go $'\n+go list -tags=extra -f '{{range .Imports}}{{.}} {{end}}'\n+stdout '^extra $'\n+\n+# Packages that require a tag should not be listed unless the tag is on.\n+! go list ./tagonly\n+go list -tags=extra ./tagonly\n+stdout m/tagonly\n+\n+-- go.mod --\n+module m\n+\n+go 1.13\n+\n+-- empty.go --\n+package p\n+\n+-- extra.go --\n+// +build extra\n+\n+package p\n+\n+import _ \"extra\"\n+\n+-- suffix_linux.go --\n+package p\n+\n+import _ \"suffix\"\n+\n+-- tag.go --\n+// +build linux\n+\n+package p\n+\n+import _ \"tag\"\n+\n+-- cgotag.go --\n+// +build cgo\n+\n+package p\n+\n+import _ \"cgotag\"\n+\n+-- cgoimport.go --\n+package p\n+\n+import \"C\"\n+\n+import _ \"cgoimport\"\n+\n+-- tagonly/tagonly.go --\n+// +build extra\n+\n+package tagonly"}, {"sha": "baae1e2be83c899d27eef765e3e4dd7ab27881fb", "filename": "libgo/go/cmd/go/testdata/script/list_linkshared.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_linkshared.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_linkshared.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_linkshared.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,16 @@\n+env GO111MODULE=on\n+\n+# golang.org/issue/35759: 'go list -linkshared'\n+# panicked if invoked on a test-only package.\n+\n+[!buildmode:shared] skip\n+\n+go list -f '{{.ImportPath}}: {{.Target}} {{.Shlib}}' -linkshared .\n+stdout '^example.com:  $'\n+\n+-- go.mod --\n+module example.com\n+\n+go 1.14\n+-- x.go --\n+package x"}, {"sha": "5aacaa88fae808a59e1a7a3b426443f51ce82a87", "filename": "libgo/go/cmd/go/testdata/script/list_parse_err.txt", "status": "added", "additions": 17, "deletions": 0, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_parse_err.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,17 @@\n+# 'go list' should report imports, even if some files have parse errors\n+# before the import block.\n+go list -e -f '{{range .Imports}}{{.}} {{end}}'\n+stdout '^fmt '\n+\n+-- go.mod --\n+module m\n+\n+go 1.13\n+\n+-- a.go --\n+package a\n+\n+import \"fmt\"\n+\n+-- b.go --\n+// no package statement"}, {"sha": "74e7d5d74c2b3eea2351b3bc5f9489478d102510", "filename": "libgo/go/cmd/go/testdata/script/list_split_main.txt", "status": "added", "additions": 25, "deletions": 0, "changes": 25, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_split_main.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_split_main.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_split_main.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,25 @@\n+# This test checks that a \"main\" package with an external test package\n+# is recompiled only once.\n+# Verifies golang.org/issue/34321.\n+\n+env GO111MODULE=off\n+\n+go list -e -test -deps -f '{{if not .Standard}}{{.ImportPath}}{{end}}' pkg\n+cmp stdout want\n+\n+-- $GOPATH/src/pkg/pkg.go --\n+package main\n+\n+func main() {}\n+\n+-- $GOPATH/src/pkg/pkg_test.go --\n+package main\n+\n+import \"testing\"\n+\n+func Test(t *testing.T) {}\n+\n+-- want --\n+pkg\n+pkg [pkg.test]\n+pkg.test"}, {"sha": "49069bd2135eae367b6f4b5f50b707c92a7c9c0b", "filename": "libgo/go/cmd/go/testdata/script/list_tags.txt", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Flist_tags.txt?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,10 +0,0 @@\n-env GO111MODULE=off\n-\n-# go list supports -tags\n-go list -tags=thetag ./my...\n-stdout mypkg\n-\n--- mypkg/x.go --\n-// +build thetag\n-\n-package mypkg"}, {"sha": "61e632a29ccf545cb615a592ad92b7363371d76a", "filename": "libgo/go/cmd/go/testdata/script/mod_ambiguous_import.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_ambiguous_import.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,49 @@\n+env GO111MODULE=on\n+\n+cd $WORK\n+\n+# An import provided by two different modules should be flagged as an error.\n+! go build ./importx\n+stderr '^importx[/\\\\]importx.go:2:8: ambiguous import: found package example.com/a/x in multiple modules:\\n\\texample.com/a v0.1.0 \\('$WORK'[/\\\\]a[/\\\\]x\\)\\n\\texample.com/a/x v0.1.0 \\('$WORK'[/\\\\]ax\\)$'\n+\n+# However, it should not be an error if that import is unused.\n+go build ./importy\n+\n+# An import provided by both the main module and the vendor directory\n+# should be flagged as an error only when -mod=vendor is set.\n+# TODO: This error message is a bit redundant.\n+mkdir vendor/example.com/m/importy\n+cp $WORK/importy/importy.go vendor/example.com/m/importy/importy.go\n+go build example.com/m/importy\n+! go build -mod=vendor example.com/m/importy\n+stderr '^can.t load package: package example.com/m/importy: ambiguous import: found package example.com/m/importy in multiple directories:\\n\\t'$WORK'[/\\\\]importy\\n\\t'$WORK'[/\\\\]vendor[/\\\\]example.com[/\\\\]m[/\\\\]importy$'\n+\n+-- $WORK/go.mod --\n+module example.com/m\n+go 1.13\n+require (\n+\texample.com/a v0.1.0\n+\texample.com/a/x v0.1.0\n+)\n+replace (\n+\texample.com/a v0.1.0 => ./a\n+\texample.com/a/x v0.1.0 => ./ax\n+)\n+-- $WORK/importx/importx.go --\n+package importx\n+import _ \"example.com/a/x\"\n+-- $WORK/importy/importy.go --\n+package importy\n+import _ \"example.com/a/y\"\n+-- $WORK/a/go.mod --\n+module example.com/a\n+go 1.14\n+-- $WORK/a/x/x.go --\n+package x\n+-- $WORK/a/y/y.go --\n+package y\n+-- $WORK/ax/go.mod --\n+module example.com/a/x\n+go 1.14\n+-- $WORK/ax/x.go --\n+package x"}, {"sha": "5bcbcd1a188f949690a03647f39147dc41f80031", "filename": "libgo/go/cmd/go/testdata/script/mod_auth.txt", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_auth.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -8,6 +8,8 @@ env GOSUMDB=off\n # basic auth should fail.\n env NETRC=$WORK/empty\n ! go list all\n+stderr '^\\tserver response: ACCESS DENIED, buddy$'\n+stderr '^\\tserver response: File\\? What file\\?$'\n \n # With credentials from a netrc file, it should succeed.\n env NETRC=$WORK/netrc"}, {"sha": "ec0d474382e9b9861d6d9aa111cd2e48329dc18e", "filename": "libgo/go/cmd/go/testdata/script/mod_bad_domain.txt", "status": "modified", "additions": 7, "deletions": 1, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_bad_domain.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,10 +2,16 @@ env GO111MODULE=on\n \n # explicit get should report errors about bad names\n ! go get appengine\n-stderr 'malformed module path \"appengine\": missing dot in first path element'\n+stderr '^go get appengine: package appengine is not in GOROOT \\(.*\\)$'\n ! go get x/y.z\n stderr 'malformed module path \"x/y.z\": missing dot in first path element'\n \n+# 'go list -m' should report errors about module names, never GOROOT.\n+! go list -m -versions appengine\n+stderr 'malformed module path \"appengine\": missing dot in first path element'\n+! go list -m -versions x/y.z\n+stderr 'malformed module path \"x/y.z\": missing dot in first path element'\n+\n # build should report all unsatisfied imports,\n # but should be more definitive about non-module import paths\n ! go build ./useappengine"}, {"sha": "87a099b219c2356f62aa1e6d88e479e398340365", "filename": "libgo/go/cmd/go/testdata/script/mod_build_info_err.txt", "status": "added", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_build_info_err.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,22 @@\n+# This test verifies that line numbers are included in module import errors.\n+# Verifies golang.org/issue/34393.\n+\n+go list -e -deps -f '{{with .Error}}{{.Pos}}: {{.Err}}{{end}}' ./main\n+stdout 'bad[/\\\\]bad.go:3:8: malformed module path \"\ud83d\udc27.example.com/string\": invalid char ''\ud83d\udc27'''\n+\n+-- go.mod --\n+module m\n+\n+go 1.13\n+\n+-- main/main.go --\n+package main\n+\n+import _ \"m/bad\"\n+\n+func main() {}\n+\n+-- bad/bad.go --\n+package bad\n+\n+import _ \"\ud83d\udc27.example.com/string\""}, {"sha": "a5410764bc00f86469f13173f0bf465d87be9cd4", "filename": "libgo/go/cmd/go/testdata/script/mod_cache_rw.txt", "status": "added", "additions": 49, "deletions": 0, "changes": 49, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_cache_rw.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,49 @@\n+# Regression test for golang.org/issue/31481.\n+\n+env GO111MODULE=on\n+\n+# golang.org/issue/31481: an explicit flag should make directories in the module\n+# cache writable in order to work around the historical inability of 'rm -rf' to\n+# forcibly remove files in unwritable directories.\n+go get -modcacherw -d rsc.io/quote@v1.5.2\n+cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n+\n+# After adding an extraneous file, 'go mod verify' should fail.\n+! go mod verify\n+\n+# However, files within those directories should still be read-only to avoid\n+# accidental mutations.\n+[!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/go.mod\n+\n+# If all 'go' commands ran with the flag, the system's 'rm' binary\n+# should be able to remove the module cache if the '-rf' flags are set.\n+[!windows] [exec:rm] exec rm -rf $GOPATH/pkg/mod\n+[!windows] [!exec:rm] go clean -modcache\n+[windows] [exec:cmd.exe] exec cmd.exe /c rmdir /s /q $GOPATH\\pkg\\mod\n+[windows] [!exec:cmd.exe] go clean -modcache\n+! exists $GOPATH/pkg/mod\n+\n+# The directories in the module cache should by default be unwritable,\n+# so that tests and tools will not accidentally add extraneous files to them.\n+# Windows does not respect FILE_ATTRIBUTE_READONLY on directories, according\n+# to MSDN, so there we disable testing whether the directory itself is\n+# unwritable.\n+go get -d rsc.io/quote@latest\n+[!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/go.mod\n+[!windows] [!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n+! exists $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n+\n+\n+# Repeat part of the test with 'go mod download' instead of 'go get' to verify\n+# -modcacherw is supported on 'go mod' subcommands.\n+go clean -modcache\n+go mod download -modcacherw rsc.io/quote\n+cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/extraneous_file.go\n+! go mod verify\n+[!root] ! cp $WORK/extraneous.txt $GOPATH/pkg/mod/rsc.io/quote@v1.5.2/go.mod\n+\n+\n+-- $WORK/extraneous.txt --\n+module oops\n+-- go.mod --\n+module golang.org/issue/31481"}, {"sha": "ddb0c081996ed7653b1adfac836b3d017007d7ce", "filename": "libgo/go/cmd/go/testdata/script/mod_convert_tsv_insecure.txt", "status": "added", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_tsv_insecure.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_tsv_insecure.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_tsv_insecure.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,27 @@\n+env GO111MODULE=on\n+\n+[!net] skip\n+[!exec:git] skip\n+\n+# secure fetch should report insecure warning\n+cd $WORK/test\n+go mod init\n+stderr 'redirected .* to insecure URL'\n+\n+# insecure fetch should not\n+env GOINSECURE=*.golang.org\n+rm go.mod\n+go mod init\n+! stderr 'redirected .* to insecure URL'\n+\n+# insecure fetch invalid path should report insecure warning\n+env GOINSECURE=foo.golang.org\n+rm go.mod\n+go mod init\n+stderr 'redirected .* to insecure URL'\n+\n+-- $WORK/test/dependencies.tsv --\n+vcs-test.golang.org/insecure/go/insecure\tgit\t6fecd21f7c0c\t2019-09-04T18:39:48Z \n+\n+-- $WORK/test/x.go --\n+package x // import \"m\""}, {"sha": "df6db36574f31096ffc9e2c4000fd853e4562389", "filename": "libgo/go/cmd/go/testdata/script/mod_convert_vendor_json.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_json.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_json.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_json.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,7 +10,7 @@ stderr '\\s*cd \\.\\. && go mod init'\n # The command we suggested should succeed.\n cd ..\n go mod init\n-go list -m all\n+go list -m\n stdout '^m$'\n \n -- $WORK/test/vendor/vendor.json --"}, {"sha": "8b6a1414be26b2b3e7f9623d724b8b62710a8d1f", "filename": "libgo/go/cmd/go/testdata/script/mod_convert_vendor_manifest.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_manifest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_manifest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_convert_vendor_manifest.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,7 +10,7 @@ stderr '\\s*cd \\.\\. && go mod init'\n # The command we suggested should succeed.\n cd ..\n go mod init\n-go list -m all\n+go list -m\n stdout '^m$'\n \n -- $WORK/test/vendor/manifest --"}, {"sha": "aac3db00be1eb31ab3aa9842d148413ff21f3c07", "filename": "libgo/go/cmd/go/testdata/script/mod_doc.txt", "status": "modified", "additions": 29, "deletions": 0, "changes": 29, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_doc.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -36,6 +36,35 @@ go doc rsc.io/quote\n ! stdout 'Package quote is located in a GOPATH workspace.'\n stdout 'Package quote collects pithy sayings.'\n \n+# Check that a sensible error message is printed when a package is not found.\n+env GOPROXY=off\n+! go doc example.com/hello\n+stderr '^doc: cannot find module providing package example.com/hello: module lookup disabled by GOPROXY=off$'\n+\n+# When in a module with a vendor directory, doc should use the vendored copies\n+# of the packages. 'std' and 'cmd' are convenient examples of such modules.\n+#\n+# When in those modules, the \"// import\" comment should refer to the same import\n+# path used in source code, not to the absolute path relative to GOROOT.\n+\n+cd $GOROOT/src\n+go doc cryptobyte\n+stdout '// import \"golang.org/x/crypto/cryptobyte\"'\n+\n+cd $GOROOT/src/cmd/go\n+go doc modfile\n+stdout '// import \"golang.org/x/mod/modfile\"'\n+\n+# When outside of the 'std' module, its vendored packages\n+# remain accessible using the 'vendor/' prefix, but report\n+# the correct \"// import\" comment as used within std.\n+cd $GOPATH\n+go doc vendor/golang.org/x/crypto/cryptobyte\n+stdout '// import \"vendor/golang.org/x/crypto/cryptobyte\"'\n+\n+go doc cmd/vendor/golang.org/x/mod/modfile\n+stdout '// import \"cmd/vendor/golang.org/x/mod/modfile\"'\n+\n -- go.mod --\n module x\n require rsc.io/quote v1.5.2"}, {"sha": "3573928a9338d7484b3dc71f173181c14b50c1d9", "filename": "libgo/go/cmd/go/testdata/script/mod_download.txt", "status": "modified", "additions": 14, "deletions": 3, "changes": 17, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -4,6 +4,7 @@ env GOPROXY=$GOPROXY/quiet\n # download with version should print nothing\n go mod download rsc.io/quote@v1.5.0\n ! stdout .\n+! stderr .\n \n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.0.info\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.0.mod\n@@ -17,7 +18,6 @@ stderr 'this.domain.is.invalid'\n stdout '\"Error\": \".*this.domain.is.invalid.*\"'\n \n # download -json with version should print JSON\n-# and download the .info file for the 'latest' version.\n go mod download -json 'rsc.io/quote@<=v1.5.0'\n stdout '^\\t\"Path\": \"rsc.io/quote\"'\n stdout '^\\t\"Version\": \"v1.5.0\"'\n@@ -28,14 +28,13 @@ stdout '^\\t\"Sum\": \"h1:6fJa6E\\+wGadANKkUMlZ0DhXFpoKlslOQDCo259XtdIE=\"'  # hash of\n stdout '^\\t\"GoModSum\": \"h1:LzX7hefJvL54yjefDEDHNONDjII0t9xZLPXsUe\\+TKr0=\"'\n ! stdout '\"Error\"'\n \n-exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n-\n # download queries above should not have added to go.mod.\n go list -m all\n ! stdout rsc.io\n \n # add to go.mod so we can test non-query downloads\n go mod edit -require rsc.io/quote@v1.5.2\n+! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.info\n ! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.mod\n ! exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.5.2.zip\n \n@@ -95,12 +94,24 @@ stderr '^rsc.io/quote@v1.999.999: reading .*/v1.999.999.info: 404 Not Found$'\n ! go mod download -json bad/path\n stdout '^\\t\"Error\": \"module bad/path: not a known dependency\"'\n \n+# download main module returns an error\n+go mod download m\n+stderr '^go mod download: skipping argument m that resolves to the main module\\n'\n+go mod download m@latest\n+stderr '^go mod download: skipping argument m@latest that resolves to the main module\\n'\n+\n # allow go mod download without go.mod\n env GO111MODULE=auto\n rm go.mod\n rm $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.2.1.zip\n go mod download rsc.io/quote@v1.2.1\n exists $GOPATH/pkg/mod/cache/download/rsc.io/quote/@v/v1.2.1.zip\n \n+# download -x with version should print\n+# the underlying commands such as contacting GOPROXY.\n+go mod download -x rsc.io/quote@v1.0.0\n+! stdout .\n+stderr 'get '$GOPROXY\n+\n -- go.mod --\n module m"}, {"sha": "01c35dd993759c8e34cfe4b97c831f389ce1145a", "filename": "libgo/go/cmd/go/testdata/script/mod_download_json.txt", "status": "added", "additions": 10, "deletions": 0, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_json.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,10 @@\n+env GO111MODULE=on\n+env GOPROXY=$GOPROXY/quiet\n+env GOSUMDB=$sumdb' '$proxy/sumdb-wrong\n+\n+# download -json with version should print JSON on sumdb failure\n+! go mod download -json 'rsc.io/quote@<=v1.5.0'\n+stdout '\"Error\": \".*verifying module'\n+\n+-- go.mod --\n+module m"}, {"sha": "60d860e4da49708d979ae9c41d7fb13f0ea26f12", "filename": "libgo/go/cmd/go/testdata/script/mod_download_latest.txt", "status": "removed", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_latest.txt?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,20 +0,0 @@\n-env GO111MODULE=on\n-\n-# If the module is the latest version of itself,\n-# the Latest field should be set.\n-go mod download -json rsc.io/quote@v1.5.2\n-stdout '\"Latest\":\\s*true'\n-\n-# If the module is older than latest, the field should be unset.\n-go mod download -json rsc.io/quote@v1.5.1\n-! stdout '\"Latest\":'\n-\n-# If the module is newer than \"latest\", the field should be unset...\n-go mod download -json rsc.io/quote@v1.5.3-pre1\n-! stdout '\"Latest\":'\n-\n-# ...even if that version is also what is required by the main module.\n-go mod init example.com\n-go mod edit -require rsc.io/quote@v1.5.3-pre1\n-go mod download -json rsc.io/quote@v1.5.3-pre1\n-! stdout '\"Latest\":'"}, {"sha": "f6ab4fe91f0960cd4f133050b344907ddebbacf8", "filename": "libgo/go/cmd/go/testdata/script/mod_download_replace_file.txt", "status": "added", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_replace_file.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_replace_file.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_download_replace_file.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,16 @@\n+# This test checks that 'go mod download' produces no output for\n+# the main module (when specified implicitly) and for a module replaced\n+# with a file path.\n+# Verifies golang.org/issue/35505.\n+go mod download -json all\n+cmp stdout no-output\n+\n+-- go.mod --\n+module example.com/a\n+\n+require example.com/b v1.0.0\n+\n+replace example.com/b => ./local/b\n+-- local/b/go.mod --\n+module example.com/b\n+-- no-output --"}, {"sha": "898d8524acfaff9d1b867763bfd221e4d15097bc", "filename": "libgo/go/cmd/go/testdata/script/mod_edit.txt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -52,6 +52,12 @@ go mod init a.a/b/c\n go mod edit -module x.x/y/z\n cmpenv go.mod go.mod.edit\n \n+# golang.org/issue/30513: don't require go-gettable module paths.\n+cd $WORK/local\n+go mod init foo\n+go mod edit -module local-only -require=other-local@v1.0.0 -replace other-local@v1.0.0=./other\n+cmpenv go.mod go.mod.edit\n+\n -- x.go --\n package x\n \n@@ -159,6 +165,14 @@ exclude x.1 v1.2.0\n replace x.1 => y.1/v2 v2.3.6\n \n require x.3 v1.99.0\n+-- $WORK/local/go.mod.edit --\n+module local-only\n+\n+go $goversion\n+\n+require other-local v1.0.0\n+\n+replace other-local v1.0.0 => ./other\n -- $WORK/go.mod.badfmt --\n module     x.x/y/z\n "}, {"sha": "0f4e093573e3fd515dde3250c2cf3061a3e512e9", "filename": "libgo/go/cmd/go/testdata/script/mod_edit_go.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_edit_go.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,6 +1,6 @@\n # Test support for go mod -edit to set language version.\n \n-[gccgo] stop\n+[gccgo] skip\n \n env GO111MODULE=on\n ! go build"}, {"sha": "729f848156d2d98f60f22059521a9bf5c0451f84", "filename": "libgo/go/cmd/go/testdata/script/mod_empty_err.txt", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_empty_err.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,36 @@\n+# This test checks error messages for non-existant packages in module mode.\n+# Veries golang.org/issue/35414\n+env GO111MODULE=on\n+cd $WORK\n+\n+go list -e -f {{.Error}} .\n+stdout 'package \\.: no Go files in \\$WORK'\n+\n+go list -e -f {{.Error}} ./empty\n+stdout 'package \\./empty: no Go files in \\$WORK[/\\\\]empty'\n+\n+go list -e -f {{.Error}} ./exclude\n+stdout 'package \\./exclude: build constraints exclude all Go files in \\$WORK[/\\\\]exclude'\n+\n+go list -e -f {{.Error}} ./missing\n+stdout 'package \\./missing: cannot find package \".\" in:\\s*\\$WORK[/\\\\]missing'\n+\n+# use 'go build -n' because 'go list' reports no error.\n+! go build -n ./testonly\n+stderr 'example.com/m/testonly: no non-test Go files in \\$WORK[/\\\\]testonly'\n+\n+-- $WORK/go.mod --\n+module example.com/m\n+\n+go 1.14\n+\n+-- $WORK/empty/empty.txt --\n+-- $WORK/exclude/exclude.go --\n+// +build exclude\n+\n+package exclude\n+-- $WORK/testonly/testonly_test.go --\n+package testonly_test\n+-- $WORK/excluded-stdout --\n+package ./excluded: cannot find package \".\" in:\n+\t$WORK/excluded"}, {"sha": "4911fbb613849ad3ed283b8d7e50eb358d0e0e71", "filename": "libgo/go/cmd/go/testdata/script/mod_fs_patterns.txt", "status": "modified", "additions": 33, "deletions": 2, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_fs_patterns.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,7 +1,6 @@\n-# File system pattern searches should skip sub-modules and vendor directories.\n-\n env GO111MODULE=on\n \n+# File system pattern searches should skip sub-modules and vendor directories.\n cd x\n \n # all packages\n@@ -40,6 +39,24 @@ stderr '^can.t load package: package ./nonexist: cannot find package \".\" in:\\n\\t\n ! stderr 'import lookup disabled'\n stderr 'can.t load package: package ./go.mod: cannot find package'\n \n+\n+# File system paths and patterns should allow the '@' character.\n+cd ../@at\n+go list $PWD\n+stdout '^at$'\n+go list $PWD/...\n+stdout '^at$'\n+\n+# The '@' character is not allowed in directory paths that are part of\n+# a package path.\n+cd ../badat/bad@\n+! go list .\n+stderr 'directory . outside available modules'\n+! go list $PWD\n+stderr 'directory . outside available modules'\n+! go list $PWD/...\n+stderr 'directory . outside available modules'\n+\n -- x/go.mod --\n module m\n \n@@ -64,3 +81,17 @@ package z\n \n -- x/y/z/w/w.go --\n package w\n+\n+-- @at/go.mod --\n+module at\n+\n+go 1.14\n+-- @at/at.go --\n+package at\n+\n+-- badat/go.mod --\n+module badat\n+\n+go 1.14\n+-- badat/bad@/bad.go --\n+package bad"}, {"sha": "42ccbcd38a143b49c2f6729881d2791adeb7e786", "filename": "libgo/go/cmd/go/testdata/script/mod_get_direct.txt", "status": "added", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_direct.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,20 @@\n+# Regression test for golang.org/issue/34092: with an empty module cache,\n+# 'GOPROXY=direct go get golang.org/x/tools/gopls@master' did not correctly\n+# resolve the pseudo-version for its dependency on golang.org/x/tools.\n+\n+[short] skip\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+go list -m cloud.google.com/go@master\n+! stdout 'v0.0.0-'\n+\n+-- go.mod --\n+module example.com\n+\n+go 1.14\n+-- go.sum --"}, {"sha": "3755f1763321e66a41cc0b04dcc6b66296404dd7", "filename": "libgo/go/cmd/go/testdata/script/mod_get_insecure_redirect.txt", "status": "added", "additions": 34, "deletions": 0, "changes": 34, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_insecure_redirect.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_insecure_redirect.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_insecure_redirect.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,34 @@\n+# golang.org/issue/29591: 'go get' was following plain-HTTP redirects even without -insecure.\n+\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+! go get -d vcs-test.golang.org/insecure/go/insecure\n+stderr 'redirected .* to insecure URL'\n+\n+go get -d -insecure vcs-test.golang.org/insecure/go/insecure\n+\n+# insecure host\n+env GOINSECURE=vcs-test.golang.org\n+go clean -modcache\n+go get -d vcs-test.golang.org/insecure/go/insecure\n+\n+# insecure glob host\n+env GOINSECURE=*.golang.org\n+go clean -modcache\n+go get -d vcs-test.golang.org/insecure/go/insecure\n+\n+# insecure multiple host\n+env GOINSECURE=somewhere-else.com,*.golang.org\n+go clean -modcache\n+go get -d vcs-test.golang.org/insecure/go/insecure\n+\n+# different insecure host does not fetch\n+env GOINSECURE=somewhere-else.com\n+go clean -modcache\n+! go get -d vcs-test.golang.org/insecure/go/insecure\n+stderr 'redirected .* to insecure URL'"}, {"sha": "367ede9ded45ba5278d47437a4c989bdf44fb2d9", "filename": "libgo/go/cmd/go/testdata/script/mod_get_major.txt", "status": "added", "additions": 23, "deletions": 0, "changes": 23, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_major.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,23 @@\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+# golang.org/issue/34383: if a module path ends in a major-version suffix,\n+# ensure that 'direct' mode can resolve the package to a module.\n+\n+go get -d vcs-test.golang.org/git/v3pkg.git/v3@v3.0.0\n+\n+go list -m vcs-test.golang.org/git/v3pkg.git/v3\n+stdout '^vcs-test.golang.org/git/v3pkg.git/v3 v3.0.0$'\n+\n+go get -d vcs-test.golang.org/git/empty-v2-without-v1.git/v2@v2.0.0\n+\n+go list -m vcs-test.golang.org/git/empty-v2-without-v1.git/v2\n+stdout '^vcs-test.golang.org/git/empty-v2-without-v1.git/v2 v2.0.0$'\n+\n+-- go.mod --\n+module example.com\n+go 1.13"}, {"sha": "5c197bb0b82f771208559b14764948b830612941", "filename": "libgo/go/cmd/go/testdata/script/mod_get_newcycle.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_newcycle.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -11,6 +11,5 @@ go mod init m\n cmp stderr stderr-expected\n \n -- stderr-expected --\n-go: finding example.com/newcycle v1.0.0\n go get: inconsistent versions:\n \texample.com/newcycle/a@v1.0.0 requires example.com/newcycle/a@v1.0.1 (not example.com/newcycle/a@v1.0.0)"}, {"sha": "8adc4b0c06579d96896e68f70faedf6b5dc7714b", "filename": "libgo/go/cmd/go/testdata/script/mod_get_patterns.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_patterns.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -10,11 +10,11 @@ grep 'require rsc.io/quote' go.mod\n \n cp go.mod.orig go.mod\n ! go get -d rsc.io/quote/x...\n-stderr 'go get rsc.io/quote/x...: module rsc.io/quote@upgrade \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x...'\n+stderr 'go get rsc.io/quote/x...: module rsc.io/quote@upgrade found \\(v1.5.2\\), but does not contain packages matching rsc.io/quote/x...'\n ! grep 'require rsc.io/quote' go.mod\n \n ! go get -d rsc.io/quote/x/...\n-stderr 'go get rsc.io/quote/x/...: module rsc.io/quote@upgrade \\(v1.5.2\\) found, but does not contain packages matching rsc.io/quote/x/...'\n+stderr 'go get rsc.io/quote/x/...: module rsc.io/quote@upgrade found \\(v1.5.2\\), but does not contain packages matching rsc.io/quote/x/...'\n ! grep 'require rsc.io/quote' go.mod\n \n # If a pattern matches no packages within a module, the module should not"}, {"sha": "3817fce9b61f87ee027b88c68bcd1ad87fbc199a", "filename": "libgo/go/cmd/go/testdata/script/mod_get_svn.txt", "status": "modified", "additions": 20, "deletions": 11, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_svn.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,17 +1,27 @@\n [!net] skip\n [!exec:svn] skip\n \n+# 'go get' will fall back to svn+ssh once svn fails over protocols like https.\n+# If vcs-test.golang.org isn't in the user's known_hosts file, this will result\n+# in an ssh prompt, which will stop 'go test' entirely\n+#\n+# Unfortunately, there isn't a way to globally disable host checking for ssh,\n+# without modifying the real system's or user's configs. Changing $HOME won't\n+# affect ssh either, as it ignores the environment variable entirely.\n+#\n+# However, a useful trick is pointing SVN_SSH to a program that doesn't exist,\n+# resulting in svn skipping ssh entirely. Alternatives like\n+# SVN_SSH=\"ssh -o StrictHostKeyChecking=no\" didn't avoid the prompt.\n+env SVN_SSH=\"svn_do_not_use_ssh\"\n+\n env GO111MODULE=on\n env GOPROXY=direct\n env GOSUMDB=off\n \n-# Attempting to get a module zip using svn should fail with a reasonable\n-# message instead of a panic.\n-# TODO(golang.org/issue/26092): Really, it shouldn't fail at all.\n-! go get -d vcs-test.golang.org/svn/hello.svn\n-stderr 'ReadZip not implemented for svn'\n-! go install .\n-stderr 'ReadZip not implemented for svn'\n+# Attempting to get a module zip using svn should succeed.\n+go get vcs-test.golang.org/svn/hello.svn@000000000001\n+exists $GOPATH/pkg/mod/cache/download/vcs-test.golang.org/svn/hello.svn/@v/v0.0.0-20170922011245-000000000001.zip\n+exists $GOPATH/bin/hello.svn$GOEXE\n \n # Attempting to get a nonexistent module using svn should fail with a\n # reasonable message instead of a panic.\n@@ -21,7 +31,6 @@ stderr 'go get vcs-test.golang.org/svn/nonexistent.svn: no matching versions for\n \n -- go.mod --\n module golang/go/issues/28943/main\n--- main.go --\n-package main\n-import _ \"vcs-test.golang.org/svn/hello.svn\"\n-func main() {}\n+-- go.sum --\n+vcs-test.golang.org/svn/hello.svn v0.0.0-20170922011245-000000000001 h1:rZjvboXMfQICKXdhx/QHqJ2Y/AQsJVrXnwGqwcTxQiw=\n+vcs-test.golang.org/svn/hello.svn v0.0.0-20170922011245-000000000001/go.mod h1:0memnh/BRLuxiK2zF4rvUgz6ts/fhhB28l3ULFWPusc="}, {"sha": "7b5d90c50b55525c2a1d471880378a9b6f90dd5f", "filename": "libgo/go/cmd/go/testdata/script/mod_get_trailing_slash.txt", "status": "added", "additions": 30, "deletions": 0, "changes": 30, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_get_trailing_slash.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,30 @@\n+# go list should succeed to load a package ending with \".go\" if the path does\n+# not correspond to an existing local file. Listing a pattern ending with\n+# \".go/\" should try to list a package regardless of whether a file exists at the\n+# path without the suffixed \"/\" or not.\n+go list example.com/dotgo.go\n+stdout ^example.com/dotgo.go$\n+go list example.com/dotgo.go/\n+stdout ^example.com/dotgo.go$\n+\n+# go get -d should succeed in either case, with or without a version.\n+# Arguments are interpreted as packages or package patterns with versions,\n+# not source files.\n+go get -d example.com/dotgo.go\n+go get -d example.com/dotgo.go/\n+go get -d example.com/dotgo.go@v1.0.0\n+go get -d example.com/dotgo.go/@v1.0.0\n+\n+# go get (without -d) should also succeed in either case.\n+[short] skip\n+go get example.com/dotgo.go\n+go get example.com/dotgo.go/\n+go get example.com/dotgo.go@v1.0.0\n+go get example.com/dotgo.go/@v1.0.0\n+\n+-- go.mod --\n+module m\n+\n+go 1.13\n+\n+require example.com/dotgo.go v1.0.0"}, {"sha": "d3df2078b072833b9beb058dc3332ecf7013d7c4", "filename": "libgo/go/cmd/go/testdata/script/mod_getmode_vendor.txt", "status": "modified", "additions": 11, "deletions": 4, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getmode_vendor.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -6,14 +6,21 @@ env GOPATH=$WORK/empty\n env GOPROXY=file:///nonexist\n \n go list -mod=vendor\n-go list -mod=vendor -m -f '{{.Path}} {{.Version}} {{.Dir}}' all\n+go list -mod=vendor -f '{{with .Module}}{{.Path}} {{.Version}}{{end}} {{.Dir}}' all\n stdout '^rsc.io/quote v1.5.1 .*vendor[\\\\/]rsc.io[\\\\/]quote$'\n-stdout '^golang.org/x/text v0.0.0.* .*vendor[\\\\/]golang.org[\\\\/]x[\\\\/]text$'\n+stdout '^golang.org/x/text v0.0.0.* .*vendor[\\\\/]golang.org[\\\\/]x[\\\\/]text[\\\\/]language$'\n \n ! go list -mod=vendor -m rsc.io/quote@latest\n-stderr 'module lookup disabled by -mod=vendor'\n+stderr 'go list -m: rsc.io/quote@latest: cannot query module due to -mod=vendor'\n ! go get -mod=vendor -u\n-stderr 'go get: disabled by -mod=vendor'\n+stderr 'flag provided but not defined: -mod'\n+\n+# Since we don't have a complete module graph, 'go list -m' queries\n+# that require the complete graph should fail with a useful error.\n+! go list -mod=vendor -m all\n+stderr 'go list -m: can''t compute ''all'' using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+! go list -mod=vendor -m ...\n+stderr 'go list -m: can''t match module patterns using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n \n -- go.mod --\n module x"}, {"sha": "ccb8d1375aa7dd2dd16fcfa60a20ff295b5ddc99", "filename": "libgo/go/cmd/go/testdata/script/mod_getx.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_getx.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,14 @@\n+[short] skip\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+# 'go get -x' should log URLs with an HTTP or HTTPS scheme.\n+# A bug had caused us to log schemeless URLs instead.\n+go get -x -d golang.org/x/text@v0.1.0\n+stderr '^# get https://golang.org/x/text\\?go-get=1$'\n+stderr '^# get https://golang.org/x/text\\?go-get=1: 200 OK \\([0-9.]+s\\)$'\n+! stderr '^# get //.*'"}, {"sha": "d6216ae2443a17cc72f77fa294e05b45820db2c2", "filename": "libgo/go/cmd/go/testdata/script/mod_go_version_mixed.txt", "status": "added", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_mixed.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_mixed.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_go_version_mixed.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,43 @@\n+# Test that dependencies can use Go language features newer than the\n+# Go version specified by the main module.\n+\n+env GO111MODULE=on\n+\n+go build\n+\n+-- go.mod --\n+module m\n+go 1.12\n+require (\n+\tsub.1 v1.0.0\n+)\n+replace (\n+\tsub.1 => ./sub\n+)\n+\n+-- x.go --\n+package x\n+\n+import \"sub.1\"\n+\n+func F() { sub.F(0, 0) }\n+\n+var A sub.Alias\n+var D sub.Defined\n+\n+-- sub/go.mod --\n+module m\n+go 1.14\n+\n+-- sub/sub.go --\n+package sub\n+\n+// signed shift counts added in Go 1.13\n+func F(l, r int) int { return l << r }\n+\n+type m1 interface { M() }\n+type m2 interface { M() }\n+\n+// overlapping interfaces added in Go 1.14\n+type Alias = interface { m1; m2; M() }\n+type Defined interface { m1; m2; M() }"}, {"sha": "2e08ae03aa383c3447f8638be6851be401789f13", "filename": "libgo/go/cmd/go/testdata/script/mod_goroot_errors.txt", "status": "added", "additions": 55, "deletions": 0, "changes": 55, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_goroot_errors.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,55 @@\n+env GO111MODULE=on\n+\n+[gccgo] skip\n+\n+# Regression test for https://golang.org/issue/34769.\n+# Missing standard-library imports should refer to GOROOT rather than\n+# complaining about a malformed module path.\n+# This is especially important when GOROOT is set incorrectly,\n+# since such an error will occur for every package in std.\n+\n+# Building a nonexistent std package directly should fail usefully.\n+\n+! go build -mod=readonly nonexist\n+! stderr 'import lookup disabled'\n+! stderr 'missing dot'\n+stderr '^can''t load package: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+\n+! go build nonexist\n+! stderr 'import lookup disabled'\n+! stderr 'missing dot'\n+stderr '^can''t load package: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+\n+# Building a nonexistent std package indirectly should also fail usefully.\n+\n+! go build -mod=readonly ./importnonexist\n+! stderr 'import lookup disabled'\n+! stderr 'missing dot'\n+stderr '^importnonexist[/\\\\]x.go:2:8: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+\n+! go build ./importnonexist\n+! stderr 'import lookup disabled'\n+! stderr 'missing dot'\n+stderr '^importnonexist[/\\\\]x.go:2:8: package nonexist is not in GOROOT \\('$GOROOT'[/\\\\]src[/\\\\]nonexist\\)$'\n+\n+# Building an *actual* std package should fail if GOROOT is set to something bogus.\n+\n+[!short] go build ./importjson  # Prove that it works when GOROOT is valid.\n+\n+env GOROOT=$WORK/not-a-valid-goroot\n+! go build ./importjson\n+! stderr 'import lookup disabled'\n+! stderr 'missing dot'\n+stderr 'importjson[/\\\\]x.go:2:8: package encoding/json is not in GOROOT \\('$WORK'[/\\\\]not-a-valid-goroot[/\\\\]src[/\\\\]encoding[/\\\\]json\\)$'\n+\n+-- go.mod --\n+module example.com\n+go 1.14\n+-- importnonexist/x.go --\n+package importnonexist\n+import _ \"nonexist\"\n+-- importjson/x.go --\n+package importjson\n+import _ \"encoding/json\"\n+-- $WORK/not-a-valid-goroot/README --\n+This directory is not a valid GOROOT."}, {"sha": "f582569798b44a17acf06f6379020dbcda8b3fd2", "filename": "libgo/go/cmd/go/testdata/script/mod_in_testdata_dir.txt", "status": "added", "additions": 45, "deletions": 0, "changes": 45, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_in_testdata_dir.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,45 @@\n+# Regression test for golang.org/issue/28481:\n+# 'mod tidy' removed dependencies if the module root was\n+# within a directory named 'testdata' or '_foo'.\n+\n+env GO111MODULE=on\n+\n+# A module should be allowed in a directory named testdata.\n+cd $WORK/testdata\n+go mod init testdata.tld/foo\n+\n+# Building a package within that module should resolve its dependencies.\n+go build\n+grep 'rsc.io/quote' go.mod\n+\n+# Tidying the module should preserve those dependencies.\n+go mod tidy\n+grep 'rsc.io/quote' go.mod\n+\n+[short] stop\n+\n+# Vendoring the module's dependencies should work too.\n+go mod vendor\n+exists vendor/rsc.io/quote\n+\n+# The same should work in directories with names starting with underscores.\n+cd $WORK/_ignored\n+go mod init testdata.tld/foo\n+\n+go build\n+grep 'rsc.io/quote' go.mod\n+\n+go mod tidy\n+grep 'rsc.io/quote' go.mod\n+\n+go mod vendor\n+exists vendor/rsc.io/quote\n+\n+-- $WORK/testdata/main.go --\n+package foo\n+\n+import _ \"rsc.io/quote\"\n+-- $WORK/_ignored/main.go --\n+package foo\n+\n+import _ \"rsc.io/quote\""}, {"sha": "1193d528ece41e6adcdadcc6ce5ee739818c1dfd", "filename": "libgo/go/cmd/go/testdata/script/mod_internal.txt", "status": "modified", "additions": 6, "deletions": 6, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_internal.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,8 +2,7 @@ env GO111MODULE=on\n [short] skip\n \n # golang.org/x/internal should be importable from other golang.org/x modules.\n-rm go.mod\n-go mod init golang.org/x/anything\n+go mod edit -module=golang.org/x/anything\n go build .\n \n # ...and their tests...\n@@ -20,8 +19,7 @@ stderr 'use of internal package golang.org/x/.* not allowed'\n stderr 'use of internal package internal/testenv not allowed'\n \n # Dependencies should be able to use their own internal modules...\n-rm go.mod\n-go mod init golang.org/notx\n+go mod edit -module=golang.org/notx\n go build ./throughdep\n \n # ... but other modules should not, even if they have transitive dependencies.\n@@ -34,8 +32,7 @@ stderr golang.org[/\\\\]notx[/\\\\]useinternal\n stderr 'use of internal package golang.org/x/.* not allowed'\n \n # Replacing an internal module should keep it internal to the same paths.\n-rm go.mod\n-go mod init golang.org/notx\n+go mod edit -module=golang.org/notx\n go mod edit -replace golang.org/x/internal=./replace/golang.org/notx/internal\n go build ./throughdep\n \n@@ -50,6 +47,9 @@ go build ./throughdep\n stderr golang.org[/\\\\]notx[/\\\\]useinternal\n stderr 'use of internal package golang.org/x/.* not allowed'\n \n+-- go.mod --\n+module TBD\n+go 1.12\n -- useinternal.go --\n package useinternal\n import _ \"golang.org/x/internal/subtle\""}, {"sha": "92416a54e474e0a8bb22c6422e1dd2a2fca01154", "filename": "libgo/go/cmd/go/testdata/script/mod_issue35317.txt", "status": "added", "additions": 8, "deletions": 0, "changes": 8, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_issue35317.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,8 @@\n+# Regression test for golang.org/issue/35317:\n+# 'go get' with multiple module-only arguments was racy.\n+\n+env GO111MODULE=on\n+[short] skip\n+\n+go mod init example.com\n+go get golang.org/x/text@v0.3.0 golang.org/x/internal@v0.1.0 golang.org/x/exp@none"}, {"sha": "f6994c1e666bf2da48033b9710c97511033e8f47", "filename": "libgo/go/cmd/go/testdata/script/mod_list_dir.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_dir.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -12,10 +12,10 @@ stdout ^math$\n go list -f '{{.ImportPath}}' .\n stdout ^x$\n ! go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stderr '^can.t load package: package '$WORK'[/\\\\]gopath/pkg/mod/rsc.io/quote@v1.5.2: can only use path@version syntax with .go get.'\n+stderr '^can.t load package: package '$WORK'[/\\\\]gopath[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2: can only use path@version syntax with .go get.'\n \n go list -e -f '{{with .Error}}{{.}}{{end}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n-stdout '^package '$WORK'[/\\\\]gopath/pkg/mod/rsc.io/quote@v1.5.2: can only use path@version syntax with .go get.'\n+stdout '^package '$WORK'[/\\\\]gopath[/\\\\]pkg[/\\\\]mod[/\\\\]rsc.io[/\\\\]quote@v1.5.2: can only use path@version syntax with .go get.'\n go mod download rsc.io/quote@v1.5.2\n go list -f '{{.ImportPath}}' $GOPATH/pkg/mod/rsc.io/quote@v1.5.2\n stdout '^rsc.io/quote$'"}, {"sha": "4969434e52b731ab3f12de70ae9dcfeefb3ac3c7", "filename": "libgo/go/cmd/go/testdata/script/mod_list_e_readonly.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_e_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_e_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_e_readonly.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,15 @@\n+# 'go list -mod=readonly -e should attribute errors\n+# to individual missing packages.\n+# Verifies golang.org/issue/34829.\n+go list -mod=readonly -e -deps -f '{{if .Error}}{{.ImportPath}}: {{.Error}}{{end}}' .\n+stdout 'example.com/missing: use.go:3:8: cannot find module providing package example.com/missing: import lookup disabled by -mod=readonly'\n+\n+-- go.mod --\n+module example.com/m\n+\n+go 1.14\n+\n+-- use.go --\n+package use\n+\n+import _ \"example.com/missing\""}, {"sha": "474df0dc269e4401bc99875f019fa01c0c080985", "filename": "libgo/go/cmd/go/testdata/script/mod_list_upgrade.txt", "status": "modified", "additions": 0, "deletions": 20, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_list_upgrade.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,28 +1,8 @@\n env GO111MODULE=on\n \n-# If the current version is not latest, 'go list -u' should include its upgrade.\n go list -m -u all\n stdout 'rsc.io/quote v1.2.0 \\[v1\\.5\\.2\\]'\n \n-# If the current version is latest, 'go list -u' should omit the upgrade.\n-go get -d rsc.io/quote@v1.5.2\n-go list -m -u all\n-stdout 'rsc.io/quote v1.5.2$'\n-\n-# If the current version is newer than latest, 'go list -u' should\n-# omit the upgrade.\n-go get -d rsc.io/quote@v1.5.3-pre1\n-go list -m -u all\n-stdout 'rsc.io/quote v1.5.3-pre1$'\n-\n-# If the current build list has a higher version and the user asks about\n-# a lower one, -u should report the upgrade for the lower one\n-# but leave the build list unchanged.\n-go list -m -u rsc.io/quote@v1.5.1\n-stdout 'rsc.io/quote v1.5.1 \\[v1.5.2\\]$'\n-go list -m -u rsc.io/quote\n-stdout 'rsc.io/quote v1.5.3-pre1$'\n-\n -- go.mod --\n module x\n require rsc.io/quote v1.2.0"}, {"sha": "2c532f1fda33a6c239c6b675fe729c6c5b27f0cf", "filename": "libgo/go/cmd/go/testdata/script/mod_load_badchain.txt", "status": "modified", "additions": 4, "deletions": 0, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_load_badchain.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -56,11 +56,13 @@ import (\n \n func Test(t *testing.T) {}\n -- update-main-expected --\n+go: example.com/badchain/c upgrade => v1.1.0\n go get: example.com/badchain/c@v1.0.0 updating to\n \texample.com/badchain/c@v1.1.0: parsing go.mod:\n \tmodule declares its path as: badchain.example.com/c\n \t        but was required as: example.com/badchain/c\n -- update-a-expected --\n+go: example.com/badchain/a upgrade => v1.1.0\n go get: example.com/badchain/a@v1.1.0 requires\n \texample.com/badchain/b@v1.1.0 requires\n \texample.com/badchain/c@v1.1.0: parsing go.mod:\n@@ -73,11 +75,13 @@ go: example.com/badchain/a@v1.1.0 requires\n \tmodule declares its path as: badchain.example.com/c\n \t        but was required as: example.com/badchain/c\n -- list-missing-expected --\n+go: found example.com/badchain/c in example.com/badchain/c v1.1.0\n go: m/use imports\n \texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod:\n \tmodule declares its path as: badchain.example.com/c\n \t        but was required as: example.com/badchain/c\n -- list-missing-test-expected --\n+go: found example.com/badchain/c in example.com/badchain/c v1.1.0\n go: m/testuse tested by\n \tm/testuse.test imports\n \texample.com/badchain/c: example.com/badchain/c@v1.1.0: parsing go.mod:"}, {"sha": "8dae85fa88d1508b724e2574b83c786621001d72", "filename": "libgo/go/cmd/go/testdata/script/mod_missing_repo.txt", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missing_repo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missing_repo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missing_repo.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,15 @@\n+# Regression test for golang.org/issue/34094: modules hosted within gitlab.com\n+# subgroups could not be fetched because the server returned bogus go-import\n+# tags for prefixes of the module path.\n+\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+! go get -d vcs-test.golang.org/go/missingrepo/missingrepo-git\n+stderr 'vcs-test.golang.org/go/missingrepo/missingrepo-git: git ls-remote .*: exit status .*'\n+\n+go get -d vcs-test.golang.org/go/missingrepo/missingrepo-git/notmissing"}, {"sha": "319ff8558720811269a920bf49840a818b8236f3", "filename": "libgo/go/cmd/go/testdata/script/mod_missingpkg_prerelease.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_missingpkg_prerelease.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -3,6 +3,11 @@ env GO111MODULE=on\n ! go list use.go\n stderr 'example.com/missingpkg/deprecated: package provided by example.com/missingpkg at latest version v1.0.0 but not at required version v1.0.1-beta'\n \n+-- go.mod --\n+module m\n+\n+go 1.14\n+\n -- use.go --\n package use\n "}, {"sha": "731f53c67218f769dc4dbe3d3583331a991bc9d6", "filename": "libgo/go/cmd/go/testdata/script/mod_modinfo.txt", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_modinfo.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -3,7 +3,8 @@\n # when module is enabled.\n env GO111MODULE=on\n \n-[gccgo] stop\n+# gccgo doesn't support reading modinfo in init functions.\n+[gccgo] skip\n \n cd x\n go mod edit -require=rsc.io/quote@v1.5.2"}, {"sha": "03ef576168c92b9ff853515226552b463204929d", "filename": "libgo/go/cmd/go/testdata/script/mod_outside.txt", "status": "modified", "additions": 118, "deletions": 49, "changes": 167, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_outside.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -17,16 +17,14 @@ go list -m\n stdout '^command-line-arguments$'\n # 'go list' in the working directory should fail even if there is a a 'package\n # main' present: without a main module, we do not know its package path.\n-! go list ./foo\n+! go list ./needmod\n stderr 'cannot find main module'\n \n # 'go list all' lists the transitive import graph of the main module,\n # which is empty if there is no main module.\n go list all\n ! stdout .\n stderr 'warning: \"all\" matched no packages'\n-go list -m all\n-stderr 'warning: pattern \"all\" matched no module dependencies'\n \n # 'go list' on standard-library packages should work, since they do not depend\n # on the contents of any module.\n@@ -38,7 +36,7 @@ go list $GOROOT/src/fmt\n stdout '^fmt$'\n \n # 'go list' should work with file arguments.\n-go list ./foo/foo.go\n+go list ./needmod/needmod.go\n stdout 'command-line-arguments'\n \n # 'go list -m' with an explicit version should resolve that version.\n@@ -49,12 +47,22 @@ stdout 'example.com/version v1.1.0'\n go list -m -versions example.com/version\n stdout 'v1.0.0\\s+v1.0.1\\s+v1.1.0'\n \n-# 'go list -m <mods> all' does not include the dependencies of <mods> in the computation of 'all'.\n-go list -m example.com/printversion@v1.0.0 all\n-stdout 'example.com/printversion v1.0.0'\n-stderr 'warning: pattern \"all\" matched no module dependencies'\n+# 'go list -m all' should fail. \"all\" is not meaningful outside of a module.\n+! go list -m all\n+stderr 'go: cannot match \"all\": working directory is not part of a module'\n+\n+# 'go list -m <mods> all' should also fail.\n+! go list -m example.com/printversion@v1.0.0 all\n+stderr 'go: cannot match \"all\": working directory is not part of a module'\n ! stdout 'example.com/version'\n \n+# 'go list -m' with wildcards should fail. Wildcards match modules in the\n+# build list, so they aren't meaningful outside a module.\n+! go list -m ...\n+stderr 'go: cannot match \"...\": working directory is not part of a module'\n+! go list -m rsc.io/quote/...\n+stderr 'go: cannot match \"rsc.io/quote/...\": working directory is not part of a module'\n+\n \n # 'go clean' should skip the current directory if it isn't in a module.\n go clean -n\n@@ -66,10 +74,9 @@ go mod graph\n ! stdout .\n ! stderr .\n \n-# 'go mod why' should report that nothing is a dependency.\n-go mod why -m example.com/version\n-stdout 'does not need'\n-\n+# 'go mod why' should fail, since there is no main module to depend on anything.\n+! go mod why -m example.com/version\n+stderr 'cannot find main module'\n \n # 'go mod edit', 'go mod tidy', and 'go mod fmt' should fail:\n # there is no go.mod file to edit.\n@@ -81,21 +88,30 @@ stderr 'cannot find main module'\n stderr 'cannot find main module'\n \n \n+# 'go mod download' without arguments should report an error.\n+! go mod download\n+stderr 'no modules specified'\n+\n # 'go mod download' should download exactly the requested module without dependencies.\n rm -r $GOPATH/pkg/mod/cache/download/example.com\n go mod download example.com/printversion@v1.0.0\n exists $GOPATH/pkg/mod/cache/download/example.com/printversion/@v/v1.0.0.zip\n ! exists $GOPATH/pkg/mod/cache/download/example.com/version/@v/v1.0.0.zip\n \n+# 'go mod download all' should fail. \"all\" is not meaningful outside of a module.\n+! go mod download all\n+stderr 'go: cannot match \"all\": working directory is not part of a module'\n+\n+\n # 'go mod vendor' should fail: it starts by clearing the existing vendor\n # directory, and we don't know where that is.\n ! go mod vendor\n stderr 'cannot find main module'\n \n-# 'go mod verify' should succeed: we have no modules to verify.\n-go mod verify\n-stdout 'all modules verified'\n-! stderr .\n+\n+# 'go mod verify' should fail: we have no modules to verify.\n+! go mod verify\n+stderr 'cannot find main module'\n \n \n # 'go get' without arguments implicitly operates on the main module, and thus\n@@ -104,14 +120,13 @@ stdout 'all modules verified'\n stderr 'cannot find main module'\n ! go get -u\n stderr 'cannot find main module'\n-! go get -u ./foo\n+! go get -u ./needmod\n stderr 'cannot find main module'\n \n # 'go get -u all' upgrades the transitive import graph of the main module,\n # which is empty.\n-go get -u all\n-! stdout .\n-stderr 'warning: \"all\" matched no packages'\n+! go get -u all\n+stderr 'go get all: cannot match \"all\": working directory is not part of a module'\n \n # 'go get' should check the proposed module graph for consistency,\n # even though we won't write it anywhere.\n@@ -126,35 +141,75 @@ exists $GOPATH/pkg/mod/example.com/version@v1.0.0\n \n \n # 'go build' without arguments implicitly operates on the current directory, and should fail.\n-cd foo\n+cd needmod\n ! go build\n stderr 'cannot find main module'\n cd ..\n \n # 'go build' of a non-module directory should fail too.\n-! go build ./foo\n+! go build ./needmod\n stderr 'cannot find main module'\n \n-# However, 'go build' should succeed for standard-library packages.\n+# 'go build' of source files should fail if they import anything outside std.\n+! go build -n ./needmod/needmod.go\n+stderr 'needmod[/\\\\]needmod.go:10:2: cannot find module providing package example.com/version: working directory is not part of a module'\n+\n+# 'go build' of source files should succeed if they do not import anything outside std.\n+go build -n -o ignore ./stdonly/stdonly.go\n+\n+# 'go build' should succeed for standard-library packages.\n go build -n fmt\n \n \n-# TODO(golang.org/issue/28992): 'go doc' should document the latest version.\n-# For now it does not.\n+# 'go doc' without arguments implicitly operates on the current directory, and should fail.\n+# TODO(golang.org/issue/32027): currently, it succeeds.\n+cd needmod\n+go doc\n+cd ..\n+\n+# 'go doc' of a non-module directory should also succeed.\n+go doc ./needmod\n+\n+# 'go doc' should succeed for standard-library packages.\n+go doc fmt\n+\n+# 'go doc' should fail for a package path outside a module.\n ! go doc example.com/version\n-stderr 'no such package'\n+stderr 'doc: cannot find module providing package example.com/version: working directory is not part of a module'\n \n # 'go install' with a version should fail due to syntax.\n ! go install example.com/printversion@v1.0.0\n stderr 'can only use path@version syntax with'\n \n+# 'go install' should fail if a package argument must be resolved to a module.\n+! go install example.com/printversion\n+stderr 'cannot find module providing package example.com/printversion: working directory is not part of a module'\n+\n+# 'go install' should fail if a source file imports a package that must be\n+# resolved to a module.\n+! go install ./needmod/needmod.go\n+stderr 'needmod[/\\\\]needmod.go:10:2: cannot find module providing package example.com/version: working directory is not part of a module'\n+\n+\n+# 'go run' with a verison should fail due to syntax.\n+! go run example.com/printversion@v1.0.0\n+stderr 'can only use path@version syntax with'\n+\n+# 'go run' should fail if a package argument must be resolved to a module.\n+! go run example.com/printversion\n+stderr 'cannot find module providing package example.com/printversion: working directory is not part of a module'\n+\n+# 'go run' should fail if a source file imports a package that must be\n+# resolved to a module.\n+! go run ./needmod/needmod.go\n+stderr 'needmod[/\\\\]needmod.go:10:2: cannot find module providing package example.com/version: working directory is not part of a module'\n+\n \n # 'go fmt' should be able to format files outside of a module.\n-go fmt foo/foo.go\n+go fmt needmod/needmod.go\n \n \n # The remainder of the test checks dependencies by linking and running binaries.\n-[short] stop\n \n # 'go get' of a binary without a go.mod should install the requested version,\n # resolving outside dependencies to the latest available versions.\n@@ -180,39 +235,31 @@ stdout 'path is example.com/printversion'\n stdout 'main is example.com/printversion v1.0.0'\n stdout 'using example.com/version v1.0.1'\n \n-# 'go install' without a version should install the latest version\n-# using its minimal module requirements.\n-go install example.com/printversion\n-exec ../bin/printversion\n-stdout 'path is example.com/printversion'\n-stdout 'main is example.com/printversion v1.0.0'\n-stdout 'using example.com/version v1.0.0'\n-\n-# 'go run' should use 'main' as the effective module and import path.\n-go run ./foo/foo.go\n+# 'go run' should work with file arguments if they don't import anything\n+# outside std.\n+go run ./stdonly/stdonly.go\n stdout 'path is command-line-arguments$'\n stdout 'main is command-line-arguments \\(devel\\)'\n-stdout 'using example.com/version v1.1.0'\n \n # 'go generate' should work with file arguments.\n-[exec:touch] go generate ./foo/foo.go\n-[exec:touch] exists ./foo/gen.txt\n+[exec:touch] go generate ./needmod/needmod.go\n+[exec:touch] exists ./needmod/gen.txt\n \n # 'go install' should work with file arguments.\n-go install ./foo/foo.go\n+go install ./stdonly/stdonly.go\n \n # 'go test' should work with file arguments.\n-go test -v ./foo/foo_test.go\n-stdout 'foo was tested'\n+go test -v ./stdonly/stdonly_test.go\n+stdout 'stdonly was tested'\n \n # 'go vet' should work with file arguments.\n-go vet ./foo/foo.go\n+go vet ./stdonly/stdonly.go\n \n \n -- README.txt --\n There is no go.mod file in the working directory.\n \n--- foo/foo.go --\n+-- needmod/needmod.go --\n //go:generate touch gen.txt\n \n package main\n@@ -237,14 +284,36 @@ func main() {\n \t}\n }\n \n--- foo/foo_test.go --\n+-- stdonly/stdonly.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime/debug\"\n+)\n+\n+func main() {\n+\tinfo, ok := debug.ReadBuildInfo()\n+\tif !ok {\n+\t\tpanic(\"missing build info\")\n+\t}\n+\tfmt.Fprintf(os.Stdout, \"path is %s\\n\", info.Path)\n+\tfmt.Fprintf(os.Stdout, \"main is %s %s\\n\", info.Main.Path, info.Main.Version)\n+\tfor _, m := range info.Deps {\n+\t\tfmt.Fprintf(os.Stdout, \"using %s %s\\n\", m.Path, m.Version)\n+\t}\n+}\n+\n+-- stdonly/stdonly_test.go --\n package main\n \n import (\n \t\"fmt\"\n \t\"testing\"\n )\n \n-func TestFoo(t *testing.T) {\n-\tfmt.Println(\"foo was tested\")\n+func Test(t *testing.T) {\n+\tfmt.Println(\"stdonly was tested\")\n }\n+"}, {"sha": "11fb4754f8382faed660a759fc3b8859c4436674", "filename": "libgo/go/cmd/go/testdata/script/mod_permissions.txt", "status": "added", "additions": 57, "deletions": 0, "changes": 57, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_permissions.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,57 @@\n+# Regression test for golang.org/issue/34634: permissions for the go.sum and\n+# go.mod files should be preserved when overwriting them.\n+\n+env GO111MODULE=on\n+[short] skip\n+\n+# Skip platforms that do not have Unix-style file permissions.\n+[windows] skip\n+[plan9] skip\n+\n+chmod 0640 go.mod\n+chmod 0604 go.sum\n+go mod edit -module=golang.org/issue/34634\n+\n+go build .\n+cmp go.mod go.mod.want\n+cmp go.sum go.sum.want\n+\n+go run .\n+stdout 'go.mod: 0640'\n+stdout 'go.sum: 0604'\n+\n+-- read_perm.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t_ \"rsc.io/sampler\"\n+)\n+\n+func main() {\n+\tfor _, name := range []string{\"go.mod\", \"go.sum\"} {\n+\t\tfi, err := os.Stat(name)\n+\t\tif err != nil {\n+\t\t\tfmt.Fprintf(os.Stderr, \"%s: %v\\n\", err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tfmt.Printf(\"%s: 0%o\\n\", name, fi.Mode().Perm())\n+\t}\n+}\n+-- go.mod --\n+module TODO\n+\n+go 1.14\n+-- go.sum --\n+-- go.mod.want --\n+module golang.org/issue/34634\n+\n+go 1.14\n+\n+require rsc.io/sampler v1.99.99\n+-- go.sum.want --\n+golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c h1:pvCbr/wm8HzDD3fVywevekufpn6tCGPY3spdHeZJEsw=\n+golang.org/x/text v0.0.0-20170915032832-14c0d48ead0c/go.mod h1:NqM8EUOU14njkJ3fqMW+pc6Ldnwhi/IjpwHt7yyuwOQ=\n+rsc.io/sampler v1.99.99 h1:iMG9lbEG/8MdeR4lgL+Q8IcwbLNw7ijW7fTiK8Miqts=\n+rsc.io/sampler v1.99.99/go.mod h1:T1hPZKmBbMNahiBKFy5HrXp6adAjACjK9JXDnKaTXpA="}, {"sha": "aa6260f63c82ee1b7a8d0c7e3c1c1dd3ccaa4acd", "filename": "libgo/go/cmd/go/testdata/script/mod_prefer_compatible.txt", "status": "added", "additions": 65, "deletions": 0, "changes": 65, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_prefer_compatible.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_prefer_compatible.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_prefer_compatible.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,65 @@\n+# Regression test for golang.org/issue/34189 and golang.org/issue/34165:\n+# @latest, @upgrade, and @patch should prefer compatible versions over\n+# +incompatible ones, even if offered by a proxy.\n+\n+[!net] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=\n+env GOSUMDB=\n+\n+# github.com/russross/blackfriday v2.0.0+incompatible exists,\n+# and should be resolved if we ask for v2.0 explicitly.\n+\n+go list -m github.com/russross/blackfriday@v2.0\n+stdout '^github.com/russross/blackfriday v2\\.0\\.0\\+incompatible$'\n+\n+# blackfriday v1.5.2 has a go.mod file, so v1.5.2 should be preferred over\n+# v2.0.0+incompatible when resolving latest, upgrade, and patch.\n+\n+go list -m github.com/russross/blackfriday@latest\n+stdout '^github.com/russross/blackfriday v1\\.'\n+\n+go list -m github.com/russross/blackfriday@upgrade\n+stdout '^github.com/russross/blackfriday v1\\.'\n+\n+go list -m github.com/russross/blackfriday@patch\n+stdout '^github.com/russross/blackfriday v1\\.'\n+\n+# If we're fetching directly from version control, ignored +incompatible\n+# versions should also be omitted by 'go list'.\n+\n+# (Note that they may still be included in results from a proxy: in proxy mode,\n+# we would need to fetch the whole zipfile for the latest compatible version in\n+# order to determine whether it contains a go.mod file, and part of the point of\n+# the proxy is to avoid fetching unnecessary data.)\n+\n+[!exec:git] stop\n+env GOPROXY=direct\n+\n+go list -versions -m github.com/russross/blackfriday github.com/russross/blackfriday\n+stdout '^github.com/russross/blackfriday v1\\.5\\.1 v1\\.5\\.2' # and possibly others\n+! stdout ' v2\\.'\n+\n+# However, if the latest compatible version does not include a go.mod file,\n+# +incompatible versions should still be listed, as they may still reflect the\n+# intent of the module author.\n+\n+go list -versions -m github.com/rsc/legacytest\n+stdout '^github.com/rsc/legacytest v1\\.0\\.0 v1\\.1\\.0-pre v1\\.2\\.0 v2\\.0\\.0\\+incompatible'\n+\n+# If we're fetching directly from version control, asking for a commit hash\n+# corresponding to a +incompatible version should continue to produce the\n+# +incompatible version tagged for that commit, even if it is no longer listed.\n+\n+go list -m github.com/russross/blackfriday@cadec560ec52\n+stdout '^github.com/russross/blackfriday v2\\.0\\.0\\+incompatible$'\n+\n+# Similarly, requesting an untagged commit should continue to produce a +incompatible\n+# pseudo-version.\n+\n+go list -m github.com/rsc/legacytest@7303f7796364\n+stdout '^github.com/rsc/legacytest v2\\.0\\.1-0\\.20180717164253-7303f7796364\\+incompatible$'\n+\n+-- go.mod --\n+module github.com/golang.org/issue/34165"}, {"sha": "9cd1a824f0848e05e0597d104dbad18f6a98072c", "filename": "libgo/go/cmd/go/testdata/script/mod_proxy_errors.txt", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_errors.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_errors.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_proxy_errors.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,19 @@\n+[!net] skip\n+\n+env GO111MODULE=on\n+env GOSUMDB=off\n+env GOPROXY=direct\n+\n+# Server responses should be truncated to some reasonable number of lines.\n+# (For now, exactly eight.)\n+! go list -m vcs-test.golang.org/auth/ormanylines@latest\n+stderr '\\tserver response:\\n(.|\\n)*\\tline 8\\n\\t\\[Truncated: too many lines.\\]$'\n+\n+# Server responses should be truncated to some reasonable number of characters.\n+! go list -m vcs-test.golang.org/auth/oronelongline@latest\n+! stderr 'blah{40}'\n+stderr '\\tserver response: \\[Truncated: too long\\.\\]$'\n+\n+# Responses from servers using the 'mod' protocol should be propagated.\n+! go list -m vcs-test.golang.org/go/modauth404@latest\n+stderr '\\tserver response: File\\? What file\\?'"}, {"sha": "1d1771e9cc04911e90e21bee21a062c872ea7f18", "filename": "libgo/go/cmd/go/testdata/script/mod_readonly.txt", "status": "modified", "additions": 53, "deletions": 6, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_readonly.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,30 +2,37 @@ env GO111MODULE=on\n [short] skip\n \n # -mod=readonly must not resolve missing modules nor update go.mod\n-#\n-# TODO(bcmills): 'go list' should suffice, but today it does not fail due to\n-# unresolved imports. When that is fixed, use 'go list' instead of 'go list all'.\n env GOFLAGS=-mod=readonly\n go mod edit -fmt\n cp go.mod go.mod.empty\n ! go list all\n-stderr 'import lookup disabled by -mod=readonly'\n+stderr '^can''t load package: x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly'\n cmp go.mod go.mod.empty\n \n+# -mod=readonly should be set implicitly if the go.mod file is read-only\n+chmod 0400 go.mod\n+env GOFLAGS=\n+! go list all\n+stderr '^can''t load package: x.go:2:8: cannot find module providing package rsc\\.io/quote: import lookup disabled by -mod=readonly\\n\\t\\(go.mod file is read-only\\.\\)$'\n+\n+chmod 0600 go.mod\n+env GOFLAGS=-mod=readonly\n+\n # update go.mod - go get allowed\n go get rsc.io/quote\n grep rsc.io/quote go.mod\n \n # update go.mod - go mod tidy allowed\n cp go.mod.empty go.mod\n go mod tidy\n+cp go.mod go.mod.tidy\n \n # -mod=readonly must succeed once go.mod is up-to-date...\n-go list\n+go list all\n \n # ... even if it needs downloads\n go clean -modcache\n-go list\n+go list all\n \n # -mod=readonly should reject inconsistent go.mod files\n # (ones that would be rewritten).\n@@ -35,6 +42,19 @@ cp go.mod go.mod.inconsistent\n stderr 'go: updates to go.mod needed, disabled by -mod=readonly'\n cmp go.mod go.mod.inconsistent\n \n+# However, it should not reject files missing a 'go' directive,\n+# since that was not always required.\n+cp go.mod.nogo go.mod\n+go list all\n+\n+# Nor should it reject files with redundant (not incorrect)\n+# requirements.\n+cp go.mod.redundant go.mod\n+go list all\n+\n+cp go.mod.indirect go.mod\n+go list all\n+\n -- go.mod --\n module m\n \n@@ -43,3 +63,30 @@ go 1.20\n -- x.go --\n package x\n import _ \"rsc.io/quote\"\n+-- go.mod.nogo --\n+module m\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/testonly v1.0.0 // indirect\n+)\n+-- go.mod.redundant --\n+module m\n+\n+go 1.20\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/sampler v1.3.0 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)\n+-- go.mod.indirect --\n+module m\n+\n+go 1.20\n+\n+require (\n+\trsc.io/quote v1.5.2 // indirect\n+\trsc.io/sampler v1.3.0 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)"}, {"sha": "c21f1720021559032a9c8f9c8876999481126612", "filename": "libgo/go/cmd/go/testdata/script/mod_replace.txt", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -38,6 +38,20 @@ grep 'not-rsc.io/quote/v3 v3.1.0' go.mod\n exec ./a5.exe\n stdout 'Concurrency is not parallelism.'\n \n+# Error messages for modules not found in replacements should\n+# indicate the replacement module.\n+cp go.mod.orig go.mod\n+go mod edit -replace=rsc.io/quote/v3=./local/rsc.io/quote/v3\n+! go get -d rsc.io/quote/v3/missing-package\n+stderr 'module rsc.io/quote/v3@upgrade found \\(v3.0.0, replaced by ./local/rsc.io/quote/v3\\), but does not contain package'\n+\n+# The reported Dir and GoMod for a replaced module should be accurate.\n+cp go.mod.orig go.mod\n+go mod edit -replace=rsc.io/quote/v3=not-rsc.io/quote@v0.1.0-nomod\n+go mod download\n+go list -m -f '{{.Path}} {{.Version}} {{.Dir}} {{.GoMod}}{{with .Replace}} => {{.Path}} {{.Version}} {{.Dir}} {{.GoMod}}{{end}}' rsc.io/quote/v3\n+stdout '^rsc.io/quote/v3 v3.0.0 '$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]not-rsc.io[/\\\\]quote@v0.1.0-nomod '$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]cache[/\\\\]download[/\\\\]not-rsc.io[/\\\\]quote[/\\\\]@v[/\\\\]v0.1.0-nomod.mod => not-rsc.io/quote v0.1.0-nomod '$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]not-rsc.io[/\\\\]quote@v0.1.0-nomod '$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]cache[/\\\\]download[/\\\\]not-rsc.io[/\\\\]quote[/\\\\]@v[/\\\\]v0.1.0-nomod.mod$'\n+\n -- go.mod --\n module quoter\n "}, {"sha": "6608fb1b801129796fa7b188e7eef88719dfb556", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_gopkgin.txt", "status": "added", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_gopkgin.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,28 @@\n+# Regression test for golang.org/issue/34254:\n+# a clone of gopkg.in/[\u2026].vN should be replaceable by\n+# a fork hosted at corp.example.com/[\u2026]/vN,\n+# even if there is an explicit go.mod file containing the\n+# gopkg.in path.\n+\n+[short] skip\n+[!net] skip\n+[!exec:git] skip\n+\n+env GO111MODULE=on\n+env GOPROXY=direct\n+env GOSUMDB=off\n+\n+# Replacing gopkg.in/[\u2026].vN with a repository with a root go.mod file\n+# specifying [\u2026].vN and a compatible version should succeed, even if\n+# the replacement path is not a gopkg.in path.\n+cd dot-to-dot\n+go list gopkg.in/src-d/go-git.v4\n+\n+-- dot-to-dot/go.mod --\n+module golang.org/issue/34254\n+\n+go 1.13\n+\n+require gopkg.in/src-d/go-git.v4 v4.13.1\n+\n+replace gopkg.in/src-d/go-git.v4 v4.13.1 => github.com/src-d/go-git/v4 v4.13.1"}, {"sha": "941ef61d35589b655ab9d4d011d23147f773a373", "filename": "libgo/go/cmd/go/testdata/script/mod_replace_import.txt", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_replace_import.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -23,6 +23,13 @@ stdout 'example.com/y v0.0.0-00010101000000-000000000000 => ./y'\n stdout 'example.com/x/v3 v3.0.0-00010101000000-000000000000 => ./v3'\n stdout 'example.com/v v1.12.0 => ./v12'\n \n+# The go command should print an informative error when the matched\n+# module does not contain a package.\n+cd fail\n+! go list all\n+stdout 'localhost.fail'\n+stderr '^can.t load package: m.go:3:8: module w@latest found \\(v0.0.0-00010101000000-000000000000, replaced by ../w\\), but does not contain package w$'\n+\n -- go.mod --\n module example.com/m\n \n@@ -107,3 +114,16 @@ package v\n module v.localhost\n -- v/v.go --\n package v\n+\n+-- fail/m.go --\n+package main\n+\n+import _ \"w\"\n+\n+func main() {}\n+\n+-- fail/go.mod --\n+module localhost.fail\n+\n+replace w => ../w\n+"}, {"sha": "bff4142ad83a22193aeec9b73386425e02a2f61c", "filename": "libgo/go/cmd/go/testdata/script/mod_retention.txt", "status": "added", "additions": 135, "deletions": 0, "changes": 135, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_retention.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,135 @@\n+# Regression test for golang.org/issue/34822: the 'go' command should prefer not\n+# to update the go.mod file if the changes only affect formatting, and should only\n+# remove redundant requirements in 'go mod tidy'.\n+\n+env GO111MODULE=on\n+[short] skip\n+\n+# Control case: verify that go.mod.tidy is actually tidy.\n+cp go.mod.tidy go.mod\n+go list all\n+cmp go.mod go.mod.tidy\n+\n+\n+# If the only difference in the go.mod file is the line endings,\n+# it should not be overwritten automatically.\n+cp go.mod.crlf go.mod\n+go list all\n+cmp go.mod go.mod.crlf\n+\n+# However, 'go mod tidy' should fix whitespace even if there are no other changes.\n+go mod tidy\n+cmp go.mod go.mod.tidy\n+\n+\n+# Out-of-order requirements should not be overwritten automatically...\n+cp go.mod.unsorted go.mod\n+go list all\n+cmp go.mod go.mod.unsorted\n+\n+# ...but 'go mod edit -fmt' should sort them.\n+go mod edit -fmt\n+cmp go.mod go.mod.tidy\n+\n+\n+# \"// indirect\" comments should be removed if direct dependencies are seen.\n+# changes.\n+cp go.mod.indirect go.mod\n+go list all\n+cmp go.mod go.mod.tidy\n+\n+# \"// indirect\" comments should be added if appropriate.\n+cp go.mod.toodirect go.mod\n+go list all\n+cmp go.mod go.mod.toodirect\n+go mod vendor # loads everything, so adds \"// indirect\" comments.\n+cmp go.mod go.mod.tidy\n+rm -r vendor\n+\n+\n+# Redundant requirements should be preserved...\n+cp go.mod.redundant go.mod\n+go list all\n+cmp go.mod go.mod.redundant\n+go mod vendor\n+cmp go.mod go.mod.redundant\n+rm -r vendor\n+\n+# ...except by 'go mod tidy'.\n+go mod tidy\n+cmp go.mod go.mod.tidy\n+\n+\n+# A missing \"go\" version directive should be added.\n+# However, that should not remove other redundant requirements.\n+cp go.mod.nogo go.mod\n+go list all\n+cmp go.mod go.mod.redundant\n+\n+\n+-- go.mod.tidy --\n+module m\n+\n+go 1.14\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/testonly v1.0.0 // indirect\n+)\n+-- x.go --\n+package x\n+import _ \"rsc.io/quote\"\n+-- go.mod.crlf --\n+module m\r\n+\r\n+go 1.14\r\n+\r\n+require (\r\n+\trsc.io/quote v1.5.2\r\n+\trsc.io/testonly v1.0.0 // indirect\r\n+)\r\n+-- go.mod.unsorted --\n+module m\n+\n+go 1.14\n+\n+require (\n+\trsc.io/testonly v1.0.0 // indirect\n+\trsc.io/quote v1.5.2\n+)\n+-- go.mod.indirect --\n+module m\n+\n+go 1.14\n+\n+require (\n+\trsc.io/quote v1.5.2 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)\n+-- go.mod.toodirect --\n+module m\n+\n+go 1.14\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/testonly v1.0.0\n+)\n+-- go.mod.redundant --\n+module m\n+\n+go 1.14\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/sampler v1.3.0 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)\n+-- go.mod.nogo --\n+module m\n+\n+require (\n+\trsc.io/quote v1.5.2\n+\trsc.io/sampler v1.3.0 // indirect\n+\trsc.io/testonly v1.0.0 // indirect\n+)"}, {"sha": "caf97e9699f9bd89f49587b86ffa72a2d5af197f", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -9,7 +9,7 @@ env dbname=localhost.localdev/sumdb\n cp go.mod.orig go.mod\n env GOSUMDB=$sumdb' '$proxy/sumdb-wrong\n ! go get -d rsc.io/quote\n-stderr 'verifying rsc.io/quote@v1.5.2: checksum mismatch'\n+stderr 'go get rsc.io/quote: rsc.io/quote@v1.5.2: verifying module: checksum mismatch'\n stderr 'downloaded: h1:3fEy'\n stderr 'localhost.localdev/sumdb: h1:wrong'\n stderr 'SECURITY ERROR\\nThis download does NOT match the one reported by the checksum server.'"}, {"sha": "2937b2e4dcd66afce921342bcbf6ae7f13d80a0b", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_cache.txt", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_cache.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -37,7 +37,14 @@ env GOPROXY=$proxy/sumdb-504\n ! go get -d rsc.io/quote@v1.5.2\n stderr 504\n \n+# GOINSECURE does not bypass checksum lookup\n+env GOINSECURE=rsc.io\n+env GOPROXY=$proxy/sumdb-504\n+! go get -d rsc.io/quote@v1.5.2\n+stderr 504\n+\n # but -insecure bypasses the checksum lookup entirely\n+env GOINSECURE=\n go get -d -insecure rsc.io/quote@v1.5.2\n \n # and then it is in go.sum again"}, {"sha": "6108c0a5d36f1979433a4235fb9ab1b6adfa30bc", "filename": "libgo/go/cmd/go/testdata/script/mod_sumdb_file_path.txt", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_sumdb_file_path.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,10 +7,13 @@ env GOPATH=$WORK/gopath1\n # With a file-based proxy with an empty checksum directory,\n # downloading a new module should fail, even if a subsequent\n # proxy contains a more complete mirror of the sum database.\n+#\n+# TODO(bcmills): The error message here is a bit redundant.\n+# It comes from the sumweb package, which isn't yet producing structured errors.\n [windows] env GOPROXY=file:///$WORK/sumproxy,https://proxy.golang.org\n [!windows] env GOPROXY=file://$WORK/sumproxy,https://proxy.golang.org\n ! go get -d golang.org/x/text@v0.3.2\n-stderr '^verifying golang.org/x/text.*: Not Found'\n+stderr '^go get golang.org/x/text@v0.3.2: golang.org/x/text@v0.3.2: verifying module: golang.org/x/text@v0.3.2: reading file://.*/sumdb/sum.golang.org/lookup/golang.org/x/text@v0.3.2: (no such file or directory|.*cannot find the path specified.*)'\n \n # If the proxy does not claim to support the database,\n # checksum verification should fall through to the next proxy,"}, {"sha": "6f520c7720d2fee618d1eeb5dcef0d2b4c000503", "filename": "libgo/go/cmd/go/testdata/script/mod_test_files.txt", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_files.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_files.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_test_files.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -20,6 +20,7 @@ stderr 'use of internal package'\n \n -- foo/go.mod --\n module example.com/foo\n+go 1.12\n require example.com/internal v0.0.0\n replace example.com/internal => ../internal\n "}, {"sha": "b1d9371217c4bf4b5e7f2289505d576bf2ad4d5d", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy.txt", "status": "modified", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -5,7 +5,6 @@ go mod tidy -v\n stderr '^unused y.1'\n ! stderr '^unused [^y]'\n \n-# tidy should not touch existing go line\n grep 'go 1.10' go.mod\n \n go list -m all"}, {"sha": "e46f37d7fa287858299b0aa1f2c8c2d04621d255", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_cycle.txt", "status": "added", "additions": 75, "deletions": 0, "changes": 75, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_cycle.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_cycle.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_cycle.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,75 @@\n+# Regression test for https://golang.org/issue/34086:\n+# 'go mod tidy' produced different go.mod file from other\n+# subcommands when certain kinds of cycles were present\n+# in the build graph.\n+\n+env GO111MODULE=on\n+\n+cp go.mod go.mod.orig\n+go mod tidy\n+cmp go.mod go.mod.orig\n+\n+# If the go.mod file is already tidy, 'go mod graph' should not modify it.\n+go mod graph\n+cmp go.mod go.mod.orig\n+\n+-- go.mod --\n+module root\n+\n+go 1.13\n+\n+replace (\n+\ta v0.1.0 => ./a1\n+\tb v0.1.0 => ./b1\n+\tb v0.2.0 => ./b2\n+\tc v0.1.0 => ./c1\n+\tc v0.2.0 => ./c2\n+)\n+\n+require (\n+\ta v0.1.0\n+\tb v0.2.0 // indirect\n+)\n+-- main.go --\n+package main\n+\n+import _ \"a\"\n+\n+func main() {}\n+\n+-- a1/go.mod --\n+module a\n+\n+go 1.13\n+\n+require b v0.1.0\n+-- a1/a.go --\n+package a\n+\n+import _ \"c\"\n+-- b1/go.mod --\n+module b\n+\n+go 1.13\n+\n+require c v0.1.0\n+-- b2/go.mod --\n+module b\n+\n+go 1.13\n+\n+require c v0.2.0\n+-- c1/go.mod --\n+module c\n+\n+go 1.13\n+-- c2/c.go --\n+package c\n+-- c2/go.mod --\n+module c\n+\n+go 1.13\n+\n+require b v0.2.0\n+-- c2/c.go --\n+package c"}, {"sha": "b6c24ceaf75f245436a0d457fe3aea702050e8e1", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_error.txt", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_error.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -4,12 +4,12 @@ env GO111MODULE=on\n # 'go mod tidy' and 'go mod vendor' should not hide loading errors.\n \n ! go mod tidy\n-stderr '^issue27063 imports\\n\\tnonexist: malformed module path \"nonexist\": missing dot in first path element'\n+stderr '^issue27063 imports\\n\\tnonexist: package nonexist is not in GOROOT \\(.*\\)'\n stderr '^issue27063 imports\\n\\tnonexist.example.com: cannot find module providing package nonexist.example.com'\n stderr '^issue27063 imports\\n\\tissue27063/other imports\\n\\tother.example.com/nonexist: cannot find module providing package other.example.com/nonexist'\n \n ! go mod vendor\n-stderr '^issue27063 imports\\n\\tnonexist: malformed module path \"nonexist\": missing dot in first path element'\n+stderr '^issue27063 imports\\n\\tnonexist: package nonexist is not in GOROOT \\(.*\\)'\n stderr '^issue27063 imports\\n\\tnonexist.example.com: cannot find module providing package nonexist.example.com'\n stderr '^issue27063 imports\\n\\tissue27063/other imports\\n\\tother.example.com/nonexist: cannot find module providing package other.example.com/nonexist'\n "}, {"sha": "c3158f8610e3499250bb10ab5e97998b37062106", "filename": "libgo/go/cmd/go/testdata/script/mod_tidy_replace.txt", "status": "modified", "additions": 26, "deletions": 0, "changes": 26, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_tidy_replace.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -47,6 +47,12 @@ grep 'rsc.io/sampler v1.2.0' go.mod\n cd outside\n go list -m all\n stdout 'rsc.io/sampler v1.3.0'\n+cd ..\n+\n+# The same module can't be used as two different paths.\n+cd multiple-paths\n+! go mod tidy\n+stderr 'rsc.io/quote/v3@v3.0.0 used for two different module paths \\(not-rsc.io/quote/v3 and rsc.io/quote/v3\\)'\n \n -- go.mod --\n module example.com/tidy\n@@ -109,3 +115,23 @@ package b\n module golang.org/issue/30166/b\n \n require golang.org/issue/30166/a v0.0.0\n+-- multiple-paths/main.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"rsc.io/quote/v3\"\n+)\n+\n+func main() {\n+\tfmt.Println(quote.GoV3())\n+}\n+-- multiple-paths/go.mod --\n+module quoter\n+\n+require (\n+\trsc.io/quote/v3 v3.0.0\n+\tnot-rsc.io/quote/v3 v3.0.0\n+)\n+\n+replace not-rsc.io/quote/v3 => rsc.io/quote/v3 v3.0.0"}, {"sha": "bb3e634b3a35dc96c26d34249747205043727b1c", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor.txt", "status": "modified", "additions": 40, "deletions": 16, "changes": 56, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,15 +1,15 @@\n env GO111MODULE=on\n \n-go list -m all\n-stdout '^x v1.0.0 => ./x'\n-stdout '^w'\n-\n+# Without vendoring, a build should succeed unless -mod=vendor is set.\n [!short] go build\n [!short] ! go build -mod=vendor\n \n+# Without vendoring, 'go list' should report the replacement directory for\n+# a package in a replaced module.\n go list -f {{.Dir}} x\n stdout 'src[\\\\/]x'\n \n+# 'go mod vendor' should copy all replaced modules to the vendor directory.\n go mod vendor -v\n stderr '^# x v1.0.0 => ./x'\n stderr '^x'\n@@ -20,28 +20,47 @@ stderr '^z'\n ! stderr '^w'\n grep 'a/foo/bar/b\\na/foo/bar/c' vendor/modules.txt # must be sorted\n \n-go list -f {{.Dir}} x\n+# An explicit '-mod=mod' should ignore the vendor directory.\n+go list -mod=mod -f {{.Dir}} x\n stdout 'src[\\\\/]x'\n \n-go list -f {{.Dir}} -m x\n+go list -mod=mod -f {{.Dir}} -m x\n stdout 'src[\\\\/]x'\n \n+# An explicit '-mod=vendor' should report package directories within\n+# the vendor directory.\n go list -mod=vendor -f {{.Dir}} x\n stdout 'src[\\\\/]vendor[\\\\/]x'\n \n-go list -mod=vendor -f {{.Dir}} -m x\n-stdout 'src[\\\\/]vendor[\\\\/]x'\n-\n-go list -f {{.Dir}} -m w\n+# 'go list -mod=vendor -m' should successfully list vendored modules,\n+# but should not provide a module directory because no directory contains\n+# the complete module.\n+go list -mod=vendor -f '{{.Version}} {{.Dir}}' -m x\n+stdout '^v1.0.0 $'\n+\n+# 'go list -mod=vendor -m' on a transitive dependency that does not\n+# provide vendored packages should give a helpful error rather than\n+# 'not a known dependency'.\n+! go list -mod=vendor -f '{{.Version}} {{.Dir}}' -m diamondright\n+stderr 'go list -m: module diamondright: can''t resolve module using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+\n+# 'go list -mod=mod' should report packages outside the import graph,\n+# but 'go list -mod=vendor' should error out for them.\n+go list -mod=mod -f {{.Dir}} w\n stdout 'src[\\\\/]w'\n-\n ! go list -mod=vendor -f {{.Dir}} w\n stderr 'src[\\\\/]vendor[\\\\/]w'\n \n+go list -mod=mod -f {{.Dir}} diamondright\n+stdout 'src[\\\\/]diamondright'\n+\n+# Test dependencies should not be copied.\n ! exists vendor/x/testdata\n ! exists vendor/a/foo/bar/b/ignored.go\n ! exists vendor/a/foo/bar/b/main_test.go\n \n+# Licenses and other metadata for each module should be copied\n+# if any package within their module is copied.\n exists vendor/a/foo/AUTHORS.txt\n exists vendor/a/foo/CONTRIBUTORS\n exists vendor/a/foo/LICENSE\n@@ -59,14 +78,18 @@ exists vendor/mysite/myname/mypkg/LICENSE.txt\n \n [short] stop\n \n-go build\n+# 'go build' and 'go test' using vendored packages should succeed.\n+go build -mod=mod\n go build -mod=vendor\n go test -mod=vendor . ./subdir\n go test -mod=vendor ./...\n+go fmt -mod=vendor ./...\n \n -- go.mod --\n module m\n \n+go 1.13\n+\n require (\n \ta v1.0.0\n \tdiamondroot v0.0.0\n@@ -252,10 +275,11 @@ require (\n -- diamondroot/x.go --\n package diamondroot\n \n-import (\n-\t_ \"diamondleft\"\n-\t_ \"diamondright\"\n-)\n+import _ \"diamondleft\"\n+-- diamondroot/unused/unused.go --\n+package unused\n+\n+import _ \"diamondright\"\n -- diamondleft/go.mod --\n module diamondleft\n "}, {"sha": "53120dcfa1fc03b0b839139f355c496f3ae0facf", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_auto.txt", "status": "added", "additions": 256, "deletions": 0, "changes": 256, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_auto.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,256 @@\n+# Integration test for golang.org/issue/33848: automatically check and use vendored packages.\n+\n+env GO111MODULE=on\n+\n+[short] skip\n+\n+cd $WORK/auto\n+cp go.mod go.mod.orig\n+cp $WORK/modules-1.13.txt $WORK/auto/modules.txt\n+\n+# An explicit -mod=vendor should force use of the vendor directory.\n+env GOFLAGS=-mod=vendor\n+\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+! go list -m all\n+stderr 'go list -m: can''t compute ''all'' using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+\n+! go list -m -f '{{.Dir}}' all\n+stderr 'go list -m: can''t compute ''all'' using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+\n+# An explicit -mod=mod should force the vendor directory to be ignored.\n+env GOFLAGS=-mod=mod\n+\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+go list -m all\n+stdout '^example.com/auto$'\n+stdout 'example.com/printversion v1.0.0'\n+stdout 'example.com/version v1.0.0'\n+\n+go list -m -f '{{.Dir}}' all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+# If the main module's \"go\" directive says 1.13, we should default to -mod=mod.\n+env GOFLAGS=\n+go mod edit -go=1.13\n+\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+go list -m -f '{{.Dir}}' all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+# A 'go 1.14' directive in the main module's go.mod file should enable\n+# -mod=vendor by default, along with stronger checks for consistency\n+# between the go.mod file and vendor/modules.txt.\n+# A 'go 1.13' vendor/modules.txt file is not usually sufficient\n+# to pass those checks.\n+go mod edit -go=1.14\n+\n+! go list -f {{.Dir}} -tags tools all\n+stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n+stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt'\n+stderr '^\\texample.com/unused: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n+stderr '^\\texample.com/version@v1.2.0: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n+stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+\n+# Module-specific subcommands should continue to load the full module graph.\n+go mod graph\n+stdout '^example.com/printversion@v1.0.0 example.com/version@v1.0.0$'\n+\n+# An explicit -mod=mod should still force the vendor directory to be ignored.\n+env GOFLAGS=-mod=mod\n+\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+go list -m all\n+stdout '^example.com/auto$'\n+stdout 'example.com/printversion v1.0.0'\n+stdout 'example.com/version v1.0.0'\n+\n+go list -m -f '{{.Dir}}' all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$GOPATH'[/\\\\]pkg[/\\\\]mod[/\\\\]example.com[/\\\\]printversion@v1.0.0$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]replacement-version$'\n+\n+# 'go mod vendor' should repair vendor/modules.txt so that the implicit\n+# -mod=vendor works again.\n+env GOFLAGS=\n+\n+go mod edit -go=1.14\n+go mod vendor\n+\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+# ...but 'go list -m' should continue to fail, this time without\n+# referring to a -mod default that the user didn't set.\n+! go list -m all\n+stderr 'go list -m: can''t compute ''all'' using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+\n+! go list -m -f '{{.Dir}}' all\n+stderr 'go list -m: can''t compute ''all'' using the vendor directory\\n\\t\\(Use -mod=mod or -mod=readonly to bypass.\\)'\n+\n+\n+# 'go mod init' should work if there is already a GOPATH-mode vendor directory\n+# present. If there are no module dependencies, -mod=vendor should be used by\n+# default and should not fail the consistency check even though no module\n+# information is present.\n+\n+rm go.mod\n+rm vendor/modules.txt\n+\n+go mod init example.com/auto\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+# If information about dependencies is added to a 1.14 go.mod file, subsequent\n+# list commands should error out if vendor/modules.txt is missing or incomplete.\n+\n+cp go.mod.orig go.mod\n+go mod edit -go=1.14\n+! go list -f {{.Dir}} -tags tools all\n+stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n+stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but not marked as explicit in vendor/modules.txt'\n+stderr '^\\texample.com/unused: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n+stderr '^\\texample.com/version@v1.2.0: is replaced in go.mod, but not marked as replaced in vendor/modules.txt'\n+stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+\n+# If -mod=vendor is set, limited consistency checks should apply even when\n+# the go version is 1.13 or earlier.\n+# An incomplete or missing vendor/modules.txt should resolve the vendored packages...\n+go mod edit -go=1.13\n+go list -mod=vendor -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+# ...but a version mismatch for an explicit dependency should be noticed.\n+cp $WORK/modules-bad-1.13.txt vendor/modules.txt\n+! go list -mod=vendor -f {{.Dir}} -tags tools all\n+stderr '^go: inconsistent vendoring in '$WORK[/\\\\]auto':$'\n+stderr '^\\texample.com/printversion@v1.0.0: is explicitly required in go.mod, but vendor/modules.txt indicates example.com/printversion@v1.1.0$'\n+stderr '\\n\\nrun .go mod vendor. to sync, or use -mod=mod or -mod=readonly to ignore the vendor directory$'\n+\n+# If the go version is still 1.13, 'go mod vendor' should write a\n+# matching vendor/modules.txt containing the corrected 1.13 data.\n+go mod vendor\n+cmp $WORK/modules-1.13.txt vendor/modules.txt\n+\n+go list -mod=vendor -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+# When the version is upgraded to 1.14, 'go mod vendor' should write a\n+# vendor/modules.txt with the updated 1.14 annotations.\n+go mod edit -go=1.14\n+go mod vendor\n+cmp $WORK/modules-1.14.txt vendor/modules.txt\n+\n+# Then, -mod=vendor should kick in automatically and succeed.\n+go list -f {{.Dir}} -tags tools all\n+stdout '^'$WORK'[/\\\\]auto$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]printversion$'\n+stdout '^'$WORK'[/\\\\]auto[/\\\\]vendor[/\\\\]example.com[/\\\\]version$'\n+\n+# 'go get' should update from the network or module cache,\n+# even if a vendor directory is present.\n+go get -u example.com/printversion\n+! go list -f {{.Dir}} -tags tools all\n+stderr '^go: inconsistent vendoring'\n+\n+-- $WORK/auto/go.mod --\n+module example.com/auto\n+\n+go 1.13\n+\n+require example.com/printversion v1.0.0\n+\n+replace (\n+\texample.com/unused => nonexistent.example.com/unused v1.0.0-whatever\n+\texample.com/version v1.0.0 => ./replacement-version\n+\texample.com/version v1.2.0 => nonexistent.example.com/version v1.2.0\n+)\n+-- $WORK/auto/tools.go --\n+// +build tools\n+\n+package auto\n+\n+import _ \"example.com/printversion\"\n+-- $WORK/auto/auto.go --\n+package auto\n+-- $WORK/auto/replacement-version/go.mod --\n+module example.com/version\n+-- $WORK/auto/replacement-version/version.go --\n+package version\n+\n+const V = \"v1.0.0-replaced\"\n+-- $WORK/modules-1.14.txt --\n+# example.com/printversion v1.0.0\n+## explicit\n+example.com/printversion\n+# example.com/version v1.0.0 => ./replacement-version\n+example.com/version\n+# example.com/unused => nonexistent.example.com/unused v1.0.0-whatever\n+# example.com/version v1.2.0 => nonexistent.example.com/version v1.2.0\n+-- $WORK/modules-1.13.txt --\n+# example.com/printversion v1.0.0\n+example.com/printversion\n+# example.com/version v1.0.0 => ./replacement-version\n+example.com/version\n+-- $WORK/modules-bad-1.13.txt --\n+# example.com/printversion v1.1.0\n+example.com/printversion\n+# example.com/version v1.1.0\n+example.com/version\n+-- $WORK/auto/vendor/example.com/printversion/go.mod --\n+module example.com/printversion\n+\n+require example.com/version v1.0.0\n+replace example.com/version v1.0.0 => ../oops v0.0.0\n+exclude example.com/version v1.0.1\n+-- $WORK/auto/vendor/example.com/printversion/printversion.go --\n+package main\n+\n+import (\n+\t\"fmt\"\n+\t\"os\"\n+\t\"runtime/debug\"\n+\n+\t_ \"example.com/version\"\n+)\n+\n+func main() {\n+\tinfo, _ := debug.ReadBuildInfo()\n+\tfmt.Fprintf(os.Stdout, \"path is %s\\n\", info.Path)\n+\tfmt.Fprintf(os.Stdout, \"main is %s %s\\n\", info.Main.Path, info.Main.Version)\n+\tfor _, m := range info.Deps {\n+\t\tfmt.Fprintf(os.Stdout, \"using %s %s\\n\", m.Path, m.Version)\n+\t}\n+}\n+-- $WORK/auto/vendor/example.com/version/version.go --\n+package version\n+\n+const V = \"v1.0.0-replaced\""}, {"sha": "0c359cea6e9668853ca7efc5a56beda3c604ffc7", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_build.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_build.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -32,7 +32,7 @@ stdout m\n \n -- go.mod --\n module m\n-\n+go 1.12\n -- x.go --\n package x\n import _ \"rsc.io/quote\""}, {"sha": "0c1c1d22f5bff1602ea2e7541da02e95fad8b7af", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_replace.txt", "status": "modified", "additions": 29, "deletions": 2, "changes": 31, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_replace.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_replace.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_replace.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,7 +1,7 @@\n env GO111MODULE=on\n \n # Before vendoring, we expect to see the original directory.\n-go list -f '{{.Version}} {{.Dir}}' -m rsc.io/quote/v3\n+go list -f '{{with .Module}}{{.Version}}{{end}} {{.Dir}}' rsc.io/quote/v3\n stdout 'v3.0.0'\n stdout '.*[/\\\\]not-rsc.io[/\\\\]quote[/\\\\]v3'\n \n@@ -15,12 +15,22 @@ go mod vendor\n # without attempting to look up the non-replaced version.\n cmp vendor/rsc.io/quote/v3/quote.go local/not-rsc.io/quote/v3/quote.go\n \n-go list -mod=vendor -f '{{.Version}} {{.Dir}}' -m rsc.io/quote/v3\n+go list -mod=vendor -f '{{with .Module}}{{.Version}}{{end}} {{.Dir}}' rsc.io/quote/v3\n stdout 'v3.0.0'\n stdout '.*[/\\\\]vendor[/\\\\]rsc.io[/\\\\]quote[/\\\\]v3'\n ! stderr 'finding'\n ! stderr 'lookup disabled'\n \n+# 'go list' should provide the original replacement directory as the module's\n+# replacement path.\n+go list -mod=vendor -f '{{with .Module}}{{with .Replace}}{{.Path}}{{end}}{{end}}' rsc.io/quote/v3\n+stdout '.*[/\\\\]not-rsc.io[/\\\\]quote[/\\\\]v3'\n+\n+# The same module can't be used as two different paths.\n+cd multiple-paths\n+! go mod vendor\n+stderr 'rsc.io/quote/v3@v3.0.0 used for two different module paths \\(not-rsc.io/quote/v3 and rsc.io/quote/v3\\)'\n+\n -- go.mod --\n module example.com/replace\n \n@@ -37,3 +47,20 @@ module not-rsc.io/quote/v3\n \n -- local/not-rsc.io/quote/v3/quote.go --\n package quote\n+\n+-- multiple-paths/main.go --\n+package main\n+import (\n+\t\"fmt\"\n+\t\"rsc.io/quote/v3\"\n+)\n+func main() {\n+\tfmt.Println(quote.GoV3())\n+}\n+-- multiple-paths/go.mod --\n+module quoter\n+require (\n+\trsc.io/quote/v3 v3.0.0\n+\tnot-rsc.io/quote/v3 v3.0.0\n+)\n+replace not-rsc.io/quote/v3 => rsc.io/quote/v3 v3.0.0"}, {"sha": "96251bb25ae1bbc7cd72e60e93cae589d31f5733", "filename": "libgo/go/cmd/go/testdata/script/mod_vendor_unused.txt", "status": "added", "additions": 67, "deletions": 0, "changes": 67, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_unused.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_unused.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmod_vendor_unused.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,67 @@\n+# Auxiliary test for inclusion of otherwise-unused replacements in\n+# vendor/modules.txt for golang.org/issue/33848.\n+# We need metadata about replacements in order to verify that modules.txt\n+# remains in sync with the main module's go.mod file.\n+\n+env GO111MODULE=on\n+\n+go mod vendor\n+cmp go1.14-modules.txt vendor/modules.txt\n+\n+-- go.mod --\n+module example.com/foo\n+go 1.14\n+\n+require (\n+\texample.com/a v0.1.0\n+)\n+\n+replace (\n+\texample.com/a v0.1.0 => ./a\n+\texample.com/b v0.1.0 => ./b1\n+\texample.com/b v0.2.0-unused => ./b2\n+\texample.com/c => ./c\n+\texample.com/d v0.1.0 => ./d1\n+\texample.com/d v0.2.0 => ./d2\n+\texample.com/e => example.com/e v0.1.0-unused\n+)\n+-- foo.go --\n+package foo\n+import _ \"example.com/a\"\n+-- a/go.mod --\n+module example.com/a\n+require (\n+\texample.com/b v0.1.0 // indirect\n+\texample.com/c v0.1.0 // indirect\n+)\n+-- a/a.go --\n+package a\n+import _ \"example.com/d\"\n+-- b1/go.mod --\n+module example.com/b\n+require example.com/d v0.1.0\n+-- b2/go.mod --\n+module example.com/b\n+require example.com/c v0.2.0\n+-- c/go.mod --\n+module example.com/c\n+require example.com/d v0.2.0\n+-- d1/go.mod --\n+module example.com/d\n+-- d1/d1.go --\n+package d\n+-- d2/go.mod --\n+module example.com/d\n+-- d2/d2.go --\n+package d\n+-- go1.14-modules.txt --\n+# example.com/a v0.1.0 => ./a\n+## explicit\n+example.com/a\n+# example.com/d v0.2.0 => ./d2\n+example.com/d\n+# example.com/b v0.1.0 => ./b1\n+# example.com/b v0.2.0-unused => ./b2\n+# example.com/c => ./c\n+# example.com/d v0.1.0 => ./d1\n+# example.com/e => example.com/e v0.1.0-unused"}, {"sha": "1409be9599c455d19dd144e9ede372b45feaee79", "filename": "libgo/go/cmd/go/testdata/script/modfile_flag.txt", "status": "added", "additions": 84, "deletions": 0, "changes": 84, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fmodfile_flag.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,84 @@\n+# Tests the behavior of the -modfile flag in commands that support it.\n+# The go.mod file exists but should not be read or written.\n+# Same with go.sum.\n+\n+env GOFLAGS=-modfile=go.alt.mod\n+cp go.mod go.mod.orig\n+cp go.sum go.sum.orig\n+\n+\n+# go mod init should create a new file, even though go.mod already exists.\n+go mod init example.com/m\n+grep example.com/m go.alt.mod\n+\n+# go mod edit should operate on the alternate file\n+go mod edit -require rsc.io/quote@v1.5.2\n+grep rsc.io/quote go.alt.mod\n+\n+# other 'go mod' commands should work. 'go mod vendor' is tested later.\n+go mod download rsc.io/quote\n+go mod graph\n+stdout rsc.io/quote\n+go mod tidy\n+grep rsc.io/quote go.alt.sum\n+go mod verify\n+go mod why rsc.io/quote\n+\n+\n+# 'go list' and other commands with build flags should work.\n+# They should update the alternate go.mod when a dependency is missing.\n+go mod edit -droprequire rsc.io/quote\n+go list .\n+grep rsc.io/quote go.alt.mod\n+go build -n .\n+go test -n .\n+go get -d rsc.io/quote\n+\n+\n+# 'go mod vendor' should work.\n+go mod vendor\n+exists vendor\n+\n+# Automatic vendoring should be broken by editing an explicit requirement\n+# in the alternate go.mod file.\n+go mod edit -require rsc.io/quote@v1.5.1\n+! go list .\n+go list -mod=mod\n+rm vendor\n+\n+\n+# 'go generate' should use the alternate file when resolving packages.\n+# Recursive go commands started with 'go generate' should not get an explicitly\n+# passed -modfile, but they should see arguments from GOFLAGS.\n+cp go.alt.mod go.gen.mod\n+env OLD_GOFLAGS=$GOFLAGS\n+env GOFLAGS=-modfile=go.gen.mod\n+go generate -modfile=go.alt.mod .\n+env GOFLAGS=$OLD_GOFLAGS\n+grep example.com/exclude go.gen.mod\n+! grep example.com/exclude go.alt.mod\n+\n+\n+# The original files should not have been modified.\n+cmp go.mod go.mod.orig\n+cmp go.sum go.sum.orig\n+\n+\n+# If the altnernate mod file does not have a \".mod\" suffix, an error\n+# should be reported.\n+cp go.alt.mod goaltmod\n+! go mod tidy -modfile=goaltmod\n+stderr '-modfile=goaltmod: file does not have .mod extension'\n+\n+-- go.mod --\n+\u0295\u25d4\u03d6\u25d4\u0294\n+-- go.sum --\n+\u0295\u25d4\u03d6\u25d4\u0294\n+-- use.go --\n+package main\n+\n+import _ \"rsc.io/quote\"\n+-- gen.go --\n+//go:generate go mod edit -exclude example.com/exclude@v1.0.0\n+\n+package main"}, {"sha": "7fdc0718ef123c6f0dbb3f68d8a39d2c3868d87b", "filename": "libgo/go/cmd/go/testdata/script/noncanonical_import.txt", "status": "added", "additions": 21, "deletions": 0, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fnoncanonical_import.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,21 @@\n+env GO111MODULE=off\n+\n+! go build canonical/d\n+stderr 'package canonical/d'\n+stderr 'imports canonical/b'\n+stderr 'imports canonical/a/: non-canonical'\n+\n+-- canonical/a/a.go --\n+package a\n+\n+import _ \"c\"\n+-- canonical/b/b.go --\n+package b\n+\n+import _ \"canonical/a/\"\n+-- canonical/a/vendor/c/c.go --\n+package c\n+-- canonical/d/d.go --\n+package d\n+\n+import _ \"canonical/b\""}, {"sha": "1d147b663fe62af62ab320b7baa9516a6a14f833", "filename": "libgo/go/cmd/go/testdata/script/test_bad_example.txt", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_bad_example.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_bad_example.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_bad_example.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,13 @@\n+# Tests that invalid examples are ignored.\n+# Verifies golang.org/issue/35284\n+go test x_test.go\n+\n+-- x_test.go --\n+package  x\n+\n+import \"fmt\"\n+\n+func ExampleThisShouldNotHaveAParameter(thisShouldntExist int) {\n+\tfmt.Println(\"X\")\n+\t// Output:\n+}\n\\ No newline at end of file"}, {"sha": "46faca0f422a429fce6db5da7fd7a533ce9dd65d", "filename": "libgo/go/cmd/go/testdata/script/test_cache_inputs.txt", "status": "added", "additions": 230, "deletions": 0, "changes": 230, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_cache_inputs.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,230 @@\n+env GO111MODULE=off\n+\n+# Test that cached test results are invalidated in response to\n+# changes to the external inputs to the test.\n+\n+[short] skip\n+[GODEBUG:gocacheverify=1] skip\n+\n+# We're testing cache behavior, so start with a clean GOCACHE.\n+env GOCACHE=$WORK/cache\n+\n+# Build a helper binary to invoke os.Chtimes.\n+go build -o mkold$GOEXE mkold.go\n+\n+# Make test input files appear to be a minute old.\n+exec ./mkold$GOEXE 1m testcache/file.txt\n+exec ./mkold$GOEXE 1m testcache/script.sh\n+\n+# If the test reads an environment variable, changes to that variable\n+# should invalidate cached test results.\n+env TESTKEY=x\n+go test testcache -run=TestLookupEnv\n+go test testcache -run=TestLookupEnv\n+stdout '\\(cached\\)'\n+\n+env TESTKEY=y\n+go test testcache -run=TestLookupEnv\n+! stdout '\\(cached\\)'\n+go test testcache -run=TestLookupEnv\n+stdout '\\(cached\\)'\n+\n+# If the test stats a file, changes to the file should invalidate the cache.\n+go test testcache -run=FileSize\n+go test testcache -run=FileSize\n+stdout '\\(cached\\)'\n+\n+cp 4x.txt testcache/file.txt\n+go test testcache -run=FileSize\n+! stdout '\\(cached\\)'\n+go test testcache -run=FileSize\n+stdout '\\(cached\\)'\n+\n+# Files should be tracked even if the test changes its working directory.\n+go test testcache -run=Chdir\n+go test testcache -run=Chdir\n+stdout '\\(cached\\)'\n+cp 6x.txt testcache/file.txt\n+go test testcache -run=Chdir\n+! stdout '\\(cached\\)'\n+go test testcache -run=Chdir\n+stdout '\\(cached\\)'\n+\n+# The content of files should affect caching, provided that the mtime also changes.\n+exec ./mkold$GOEXE 1m testcache/file.txt\n+go test testcache -run=FileContent\n+go test testcache -run=FileContent\n+stdout '\\(cached\\)'\n+cp 2y.txt testcache/file.txt\n+exec ./mkold$GOEXE 50s testcache/file.txt\n+go test testcache -run=FileContent\n+! stdout '\\(cached\\)'\n+go test testcache -run=FileContent\n+stdout '\\(cached\\)'\n+\n+# Directory contents read via os.ReadDirNames should affect caching.\n+go test testcache -run=DirList\n+go test testcache -run=DirList\n+stdout '\\(cached\\)'\n+rm testcache/file.txt\n+go test testcache -run=DirList\n+! stdout '\\(cached\\)'\n+go test testcache -run=DirList\n+stdout '\\(cached\\)'\n+\n+# Files outside GOROOT and GOPATH should not affect caching.\n+env TEST_EXTERNAL_FILE=$WORK/external.txt\n+go test testcache -run=ExternalFile\n+go test testcache -run=ExternalFile\n+stdout '\\(cached\\)'\n+\n+rm $WORK/external.txt\n+go test testcache -run=ExternalFile\n+stdout '\\(cached\\)'\n+\n+# Executables within GOROOT and GOPATH should affect caching,\n+# even if the test does not stat them explicitly.\n+\n+[!exec:/bin/sh] skip\n+chmod 0755 ./testcache/script.sh\n+\n+exec ./mkold$GOEXEC 1m testcache/script.sh\n+go test testcache -run=Exec\n+go test testcache -run=Exec\n+stdout '\\(cached\\)'\n+\n+exec ./mkold$GOEXE 50s testcache/script.sh\n+go test testcache -run=Exec\n+! stdout '\\(cached\\)'\n+go test testcache -run=Exec\n+stdout '\\(cached\\)'\n+\n+-- testcache/file.txt --\n+xx\n+-- 4x.txt --\n+xxxx\n+-- 6x.txt --\n+xxxxxx\n+-- 2y.txt --\n+yy\n+-- $WORK/external.txt --\n+This file is outside of GOPATH.\n+-- testcache/script.sh --\n+#!/bin/sh\n+exit 0\n+-- testcache/testcache_test.go --\n+// Copyright 2017 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package testcache\n+\n+import (\n+\t\"io/ioutil\"\n+\t\"os\"\n+\t\"testing\"\n+)\n+\n+func TestChdir(t *testing.T) {\n+\tos.Chdir(\"..\")\n+\tdefer os.Chdir(\"testcache\")\n+\tinfo, err := os.Stat(\"testcache/file.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif info.Size()%2 != 1 {\n+\t\tt.Fatal(\"even file\")\n+\t}\n+}\n+\n+func TestOddFileContent(t *testing.T) {\n+\tf, err := os.Open(\"file.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tdata, err := ioutil.ReadAll(f)\n+\tf.Close()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif len(data)%2 != 1 {\n+\t\tt.Fatal(\"even file\")\n+\t}\n+}\n+\n+func TestOddFileSize(t *testing.T) {\n+\tinfo, err := os.Stat(\"file.txt\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif info.Size()%2 != 1 {\n+\t\tt.Fatal(\"even file\")\n+\t}\n+}\n+\n+func TestOddGetenv(t *testing.T) {\n+\tval := os.Getenv(\"TESTKEY\")\n+\tif len(val)%2 != 1 {\n+\t\tt.Fatal(\"even env value\")\n+\t}\n+}\n+\n+func TestLookupEnv(t *testing.T) {\n+\t_, ok := os.LookupEnv(\"TESTKEY\")\n+\tif !ok {\n+\t\tt.Fatal(\"env missing\")\n+\t}\n+}\n+\n+func TestDirList(t *testing.T) {\n+\tf, err := os.Open(\".\")\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tf.Readdirnames(-1)\n+\tf.Close()\n+}\n+\n+func TestExec(t *testing.T) {\n+\t// Note: not using os/exec to make sure there is no unexpected stat.\n+\tp, err := os.StartProcess(\"./script.sh\", []string{\"script\"}, new(os.ProcAttr))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tps, err := p.Wait()\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+\tif !ps.Success() {\n+\t\tt.Fatalf(\"script failed: %v\", err)\n+\t}\n+}\n+\n+func TestExternalFile(t *testing.T) {\n+\tos.Open(os.Getenv(\"TEST_EXTERNAL_FILE\"))\n+\t_, err := os.Stat(os.Getenv(\"TEST_EXTERNAL_FILE\"))\n+\tif err != nil {\n+\t\tt.Fatal(err)\n+\t}\n+}\n+-- mkold.go --\n+package main\n+\n+import (\n+\t\"log\"\n+\t\"os\"\n+\t\"time\"\n+)\n+\n+func main() {\n+\td, err := time.ParseDuration(os.Args[1])\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+\tpath := os.Args[2]\n+\told := time.Now().Add(-d)\n+\terr = os.Chtimes(path, old, old)\n+\tif err != nil {\n+\t\tlog.Fatal(err)\n+\t}\n+}"}, {"sha": "63bb8ec3e78149ea2d80589304deec75131b97ca", "filename": "libgo/go/cmd/go/testdata/script/test_compile_binary.txt", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_binary.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_binary.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_binary.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -4,5 +4,5 @@ env GO111MODULE=off\n stderr 'build comment'\n \n -- compile_binary/foo_test.go --\n-//+build foo\n+// +build foo\n package foo"}, {"sha": "912410814f47421cfd7c73abe63250306fd43d2f", "filename": "libgo/go/cmd/go/testdata/script/test_compile_tempfile.txt", "status": "added", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_compile_tempfile.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,11 @@\n+[short] skip\n+\n+# Ensure that the target of 'go build -o' can be an existing, empty file so that\n+# its name can be reserved using ioutil.TempFile or the 'mktemp` command.\n+\n+go build -o empty-file$GOEXE main.go\n+\n+-- main.go --\n+package main\n+func main() {}\n+-- empty-file$GOEXE --"}, {"sha": "33071679a29fba84339032a4e18c7f53e8d9a9c4", "filename": "libgo/go/cmd/go/testdata/script/test_devnull.txt", "status": "removed", "additions": 0, "deletions": 15, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_devnull.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_devnull.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_devnull.txt?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,15 +0,0 @@\n-env GO111MODULE=off\n-\n-# go test -c -o NUL\n-# should work (see golang.org/issue/28035).\n-cd x\n-go test -o=$devnull -c\n-! exists x.test$GOEXE\n-\n--- x/x_test.go --\n-package x_test\n-import (\n-    \"testing\"\n-)\n-func TestNUL(t *testing.T) {\n-}"}, {"sha": "410d923d2378d5fff899a65cff48bb13f00f066c", "filename": "libgo/go/cmd/go/testdata/script/test_main_archive.txt", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_main_archive.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_main_archive.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_main_archive.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,32 @@\n+env GO111MODULE=off\n+\n+# Test that a main_test of 'package main' imports the package,\n+# not the installed binary.\n+\n+[short] skip\n+\n+env GOBIN=$WORK/bin\n+go test main_test\n+go install main_test\n+\n+go list -f '{{.Stale}}' main_test\n+stdout false\n+\n+go test main_test\n+\n+-- main_test/m.go --\n+package main\n+\n+func F()    {}\n+func main() {}\n+-- main_test/m_test.go --\n+package main_test\n+\n+import (\n+\t. \"main_test\"\n+\t\"testing\"\n+)\n+\n+func Test1(t *testing.T) {\n+\tF()\n+}"}, {"sha": "38233c18922a1e9499397307c8f152b49ff725c5", "filename": "libgo/go/cmd/go/testdata/script/test_rebuildall.txt", "status": "added", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_rebuildall.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_rebuildall.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_rebuildall.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,14 @@\n+env GO111MODULE=off\n+\n+# Regression test for golang.org/issue/6844:\n+# 'go test -a' should force dependencies in the standard library to be rebuilt.\n+\n+[short] skip\n+\n+go test -x -a -c testdata/dep_test.go\n+stderr '^.*[/\\\\]compile'$GOEXE'[\"]? (.* )?regexp .*[/\\\\]regexp\\.go'\n+\n+-- testdata/dep_test.go --\n+package deps\n+\n+import _ \"testing\""}, {"sha": "4de4df450821d4ebf9ff9b61b2c4874061118797", "filename": "libgo/go/cmd/go/testdata/script/test_timeout.txt", "status": "modified", "additions": 6, "deletions": 5, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_timeout.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_timeout.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Ftest_timeout.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -2,12 +2,13 @@\n env GO111MODULE=off\n cd a\n \n-# No timeout is passed via 'go test' command.\n-go test -v\n+# If no timeout is set explicitly, 'go test' should set\n+# -test.timeout to its internal deadline.\n+go test -v . --\n stdout '10m0s'\n \n-# Timeout is passed via 'go test' command.\n-go test -v -timeout 30m\n+# An explicit -timeout argument should be propagated to -test.timeout.\n+go test -v -timeout 30m . --\n stdout '30m0s'\n \n -- a/timeout_test.go --\n@@ -19,4 +20,4 @@ import (\n )\n func TestTimeout(t *testing.T) {\n \tfmt.Println(flag.Lookup(\"test.timeout\").Value.String())\n-}\n\\ No newline at end of file\n+}"}, {"sha": "42526247f1e7e62a67222911d01390d648569609", "filename": "libgo/go/cmd/go/testdata/script/version.txt", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fversion.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,13 +1,18 @@\n env GO111MODULE=on\n [short] skip\n \n+# Check that 'go version' and 'go version -m' work on a binary built in module mode.\n go build -o fortune.exe rsc.io/fortune\n go version fortune.exe\n stdout '^fortune.exe: .+'\n go version -m fortune.exe\n stdout '^\\tpath\\trsc.io/fortune'\n stdout '^\\tmod\\trsc.io/fortune\\tv1.0.0'\n \n+# Repeat the test with -buildmode=pie.\n+# TODO(golang.org/issue/27144): don't skip after -buildmode=pie is implemented\n+# on Windows.\n+[windows] skip # -buildmode=pie not supported\n go build -buildmode=pie -o external.exe rsc.io/fortune\n go version external.exe\n stdout '^external.exe: .+'"}, {"sha": "94bfd126c090992fe491bf2857cd391c309b8e39", "filename": "libgo/go/cmd/go/testdata/script/vet_flags.txt", "status": "added", "additions": 37, "deletions": 0, "changes": 37, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fscript%2Fvet_flags.txt?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,37 @@\n+env GO111MODULE=on\n+\n+# gccgo doesn't support vet on the standard library\n+[gccgo] skip\n+\n+# Regression test for issue 35837: \"go vet -<analyzer> <std package>\"\n+# did not apply the requested analyzer.\n+go vet -n -unreachable=false encoding/binary\n+stderr '-unreachable=false'\n+! stderr '-unsafeptr=false'\n+\n+[short] stop\n+env GOCACHE=$WORK/gocache\n+env GOTMPDIR=$WORK/tmp\n+go env GOTMPDIR\n+stdout '/tmp'\n+\n+# \"go test\" on a user package should by default enable an explicit whitelist of analyzers.\n+go test -x -run=none .\n+stderr '[/\\\\]vet'$GOEXE'[\"]? .* -errorsas .* [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+\n+# \"go test\" on a standard package should by default disable an explicit blacklist.\n+go test -x -run=none encoding/binary\n+stderr '[/\\\\]vet'$GOEXE'[\"]? -unsafeptr=false [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+\n+# Both should allow users to override via the -vet flag.\n+go test -x -vet=unreachable -run=none .\n+stderr '[/\\\\]vet'$GOEXE'[\"]? -unreachable [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+go test -x -vet=unreachable -run=none encoding/binary\n+stderr '[/\\\\]vet'$GOEXE'[\"]? -unreachable [\"]?\\$WORK[/\\\\][^ ]*[/\\\\]vet\\.cfg'\n+\n+-- go.mod --\n+module example.com/x\n+-- x.go --\n+package x\n+-- x_test.go --\n+package x"}, {"sha": "486cc4843fde6b06b11027696038b7afb8d1bab1", "filename": "libgo/go/cmd/go/testdata/src/canonical/a/a.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fa.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,3 +0,0 @@\n-package a\n-\n-import _ \"c\""}, {"sha": "7f96c221c2d20dffc1a31ba53fb8476b3a8d0f8a", "filename": "libgo/go/cmd/go/testdata/src/canonical/a/vendor/c/c.go", "status": "removed", "additions": 0, "deletions": 1, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fvendor%2Fc%2Fc.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fvendor%2Fc%2Fc.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fa%2Fvendor%2Fc%2Fc.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1 +0,0 @@\n-package c"}, {"sha": "ce0f4ce3035ccf146ea7ff390f09bff38f06678f", "filename": "libgo/go/cmd/go/testdata/src/canonical/b/b.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fb%2Fb.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,3 +0,0 @@\n-package b\n-\n-import _ \"canonical/a/\""}, {"sha": "ef7dd7dd4616f46a2d6ae0c0b68b917445caf5fa", "filename": "libgo/go/cmd/go/testdata/src/canonical/d/d.go", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fcanonical%2Fd%2Fd.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,3 +0,0 @@\n-package d\n-\n-import _ \"canonical/b\""}, {"sha": "002a5c740c7d288d40d490a43aae9297488a2433", "filename": "libgo/go/cmd/go/testdata/src/go-cmd-test/helloworld.go", "status": "removed", "additions": 0, "deletions": 5, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fgo-cmd-test%2Fhelloworld.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,5 +0,0 @@\n-package main\n-\n-func main() {\n-\tprintln(\"hello world\")\n-}"}, {"sha": "c682f030b4eb33e1dfe819ec320806076ff7131a", "filename": "libgo/go/cmd/go/testdata/src/main_test/m.go", "status": "removed", "additions": 0, "deletions": 4, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,4 +0,0 @@\n-package main\n-\n-func F()    {}\n-func main() {}"}, {"sha": "f865b7734f0e5d56fe6e62dd0f540efc00eb783a", "filename": "libgo/go/cmd/go/testdata/src/main_test/m_test.go", "status": "removed", "additions": 0, "deletions": 10, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Fmain_test%2Fm_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,10 +0,0 @@\n-package main_test\n-\n-import (\n-\t. \"main_test\"\n-\t\"testing\"\n-)\n-\n-func Test1(t *testing.T) {\n-\tF()\n-}"}, {"sha": "9b2d1ea78243d9bc251d59cabad0e079c1a70190", "filename": "libgo/go/cmd/go/testdata/src/testcache/testcache_test.go", "status": "removed", "additions": 0, "deletions": 91, "changes": 91, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgo%2Ftestdata%2Fsrc%2Ftestcache%2Ftestcache_test.go?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43", "patch": "@@ -1,91 +0,0 @@\n-// Copyright 2017 The Go Authors. All rights reserved.\n-// Use of this source code is governed by a BSD-style\n-// license that can be found in the LICENSE file.\n-\n-package testcache\n-\n-import (\n-\t\"io/ioutil\"\n-\t\"os\"\n-\t\"runtime\"\n-\t\"testing\"\n-)\n-\n-func TestChdir(t *testing.T) {\n-\tos.Chdir(\"..\")\n-\tdefer os.Chdir(\"testcache\")\n-\tinfo, err := os.Stat(\"testcache/file.txt\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif info.Size()%2 != 1 {\n-\t\tt.Fatal(\"even file\")\n-\t}\n-}\n-\n-func TestOddFileContent(t *testing.T) {\n-\tf, err := os.Open(\"file.txt\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tdata, err := ioutil.ReadAll(f)\n-\tf.Close()\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif len(data)%2 != 1 {\n-\t\tt.Fatal(\"even file\")\n-\t}\n-}\n-\n-func TestOddFileSize(t *testing.T) {\n-\tinfo, err := os.Stat(\"file.txt\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif info.Size()%2 != 1 {\n-\t\tt.Fatal(\"even file\")\n-\t}\n-}\n-\n-func TestOddGetenv(t *testing.T) {\n-\tval := os.Getenv(\"TESTKEY\")\n-\tif len(val)%2 != 1 {\n-\t\tt.Fatal(\"even env value\")\n-\t}\n-}\n-\n-func TestLookupEnv(t *testing.T) {\n-\t_, ok := os.LookupEnv(\"TESTKEY\")\n-\tif !ok {\n-\t\tt.Fatal(\"env missing\")\n-\t}\n-}\n-\n-func TestDirList(t *testing.T) {\n-\tf, err := os.Open(\".\")\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tf.Readdirnames(-1)\n-\tf.Close()\n-}\n-\n-func TestExec(t *testing.T) {\n-\tif runtime.GOOS == \"plan9\" || runtime.GOOS == \"windows\" || runtime.GOOS == \"nacl\" {\n-\t\tt.Skip(\"non-unix\")\n-\t}\n-\n-\t// Note: not using os/exec to make sure there is no unexpected stat.\n-\tp, err := os.StartProcess(\"./script.sh\", []string{\"script\"}, new(os.ProcAttr))\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tps, err := p.Wait()\n-\tif err != nil {\n-\t\tt.Fatal(err)\n-\t}\n-\tif !ps.Success() {\n-\t\tt.Fatalf(\"script failed: %v\", err)\n-\t}\n-}"}, {"sha": "9e472b2d51c0ba89a8cf0f0bc6d386d969ada84d", "filename": "libgo/go/cmd/gofmt/gofmt.go", "status": "modified", "additions": 6, "deletions": 40, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -16,11 +16,12 @@ import (\n \t\"io\"\n \t\"io/ioutil\"\n \t\"os\"\n-\t\"os/exec\"\n \t\"path/filepath\"\n \t\"runtime\"\n \t\"runtime/pprof\"\n \t\"strings\"\n+\n+\t\"cmd/internal/diff\"\n )\n \n var (\n@@ -141,7 +142,7 @@ func processFile(filename string, in io.Reader, out io.Writer, stdin bool) error\n \t\t\t}\n \t\t}\n \t\tif *doDiff {\n-\t\t\tdata, err := diff(src, res, filename)\n+\t\t\tdata, err := diffWithReplaceTempFile(src, res, filename)\n \t\t\tif err != nil {\n \t\t\t\treturn fmt.Errorf(\"computing diff: %s\", err)\n \t\t\t}\n@@ -227,47 +228,12 @@ func gofmtMain() {\n \t}\n }\n \n-func writeTempFile(dir, prefix string, data []byte) (string, error) {\n-\tfile, err := ioutil.TempFile(dir, prefix)\n-\tif err != nil {\n-\t\treturn \"\", err\n-\t}\n-\t_, err = file.Write(data)\n-\tif err1 := file.Close(); err == nil {\n-\t\terr = err1\n-\t}\n-\tif err != nil {\n-\t\tos.Remove(file.Name())\n-\t\treturn \"\", err\n-\t}\n-\treturn file.Name(), nil\n-}\n-\n-func diff(b1, b2 []byte, filename string) (data []byte, err error) {\n-\tf1, err := writeTempFile(\"\", \"gofmt\", b1)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer os.Remove(f1)\n-\n-\tf2, err := writeTempFile(\"\", \"gofmt\", b2)\n-\tif err != nil {\n-\t\treturn\n-\t}\n-\tdefer os.Remove(f2)\n-\n-\tcmd := \"diff\"\n-\tif runtime.GOOS == \"plan9\" {\n-\t\tcmd = \"/bin/ape/diff\"\n-\t}\n-\n-\tdata, err = exec.Command(cmd, \"-u\", f1, f2).CombinedOutput()\n+func diffWithReplaceTempFile(b1, b2 []byte, filename string) ([]byte, error) {\n+\tdata, err := diff.Diff(\"gofmt\", b1, b2)\n \tif len(data) > 0 {\n-\t\t// diff exits with a non-zero status when the files don't match.\n-\t\t// Ignore that failure as long as we get output.\n \t\treturn replaceTempFilename(data, filename)\n \t}\n-\treturn\n+\treturn data, err\n }\n \n // replaceTempFilename replaces temporary filenames in diff with actual one."}, {"sha": "98d3eb7eb27b3618475e6fab84e77e7643214278", "filename": "libgo/go/cmd/gofmt/gofmt_test.go", "status": "modified", "additions": 2, "deletions": 2, "changes": 4, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Fgofmt_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -112,7 +112,7 @@ func runTest(t *testing.T, in, out string) {\n \t\t}\n \n \t\tt.Errorf(\"(gofmt %s) != %s (see %s.gofmt)\", in, out, in)\n-\t\td, err := diff(expected, got, in)\n+\t\td, err := diffWithReplaceTempFile(expected, got, in)\n \t\tif err == nil {\n \t\t\tt.Errorf(\"%s\", d)\n \t\t}\n@@ -194,7 +194,7 @@ func TestDiff(t *testing.T) {\n \tin := []byte(\"first\\nsecond\\n\")\n \tout := []byte(\"first\\nthird\\n\")\n \tfilename := \"difftest.txt\"\n-\tb, err := diff(in, out, filename)\n+\tb, err := diffWithReplaceTempFile(in, out, filename)\n \tif err != nil {\n \t\tt.Fatal(err)\n \t}"}, {"sha": "bab22e04cdac00284170d792fa7a4812ff769e9d", "filename": "libgo/go/cmd/gofmt/rewrite.go", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Frewrite.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -271,6 +271,12 @@ func subst(m map[string]reflect.Value, pattern reflect.Value, pos reflect.Value)\n \t// Otherwise copy.\n \tswitch p := pattern; p.Kind() {\n \tcase reflect.Slice:\n+\t\tif p.IsNil() {\n+\t\t\t// Do not turn nil slices into empty slices. go/ast\n+\t\t\t// guarantees that certain lists will be nil if not\n+\t\t\t// populated.\n+\t\t\treturn reflect.Zero(p.Type())\n+\t\t}\n \t\tv := reflect.MakeSlice(p.Type(), p.Len(), p.Len())\n \t\tfor i := 0; i < p.Len(); i++ {\n \t\t\tv.Index(i).Set(subst(m, p.Index(i), pos))"}, {"sha": "1125b70cb76c6f7115cf7640cebd6baf2c507c13", "filename": "libgo/go/cmd/gofmt/testdata/import.golden", "status": "modified", "additions": 68, "deletions": 5, "changes": 73, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.golden?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,3 +1,4 @@\n+// package comment\n package main\n \n import (\n@@ -8,11 +9,6 @@ import (\n \t\"math\"\n )\n \n-import (\n-\t\"fmt\"\n-\t\"math\"\n-)\n-\n import (\n \t\"fmt\"\n \n@@ -25,6 +21,10 @@ import (\n \t\"io\"\n )\n \n+// We reset the line numbering to test that\n+// the formatting works independent of line directives\n+//line :19\n+\n import (\n \t\"errors\"\n \t\"fmt\"\n@@ -129,3 +129,66 @@ import (\n \n \t\"dedup_by_group\"\n )\n+\n+import (\n+\t\"fmt\" // for Printf\n+\t/* comment */ io1 \"io\"\n+\t/* comment */ io2 \"io\"\n+\t/* comment */ \"log\"\n+)\n+\n+import (\n+\t\"fmt\"\n+\t/* comment */ io1 \"io\"\n+\t/* comment */ io2 \"io\" // hello\n+\t\"math\"                 /* right side */\n+\t// end\n+)\n+\n+import (\n+\t\"errors\" // for New\n+\t\"fmt\"\n+\t/* comment */ io1 \"io\" /* before */ // after\n+\tio2 \"io\"               // another\n+\t// end\n+)\n+\n+import (\n+\t\"errors\" // for New\n+\t/* left */ \"fmt\" /* right */\n+\t\"log\"            // for Fatal\n+\t/* left */ \"math\" /* right */\n+)\n+\n+import /* why */ /* comment here? */ (\n+\t/* comment */ \"fmt\"\n+\t\"math\"\n+)\n+\n+// Reset it again\n+//line :100\n+\n+// Dedup with different import styles\n+import (\n+\t\"path\"\n+\t. \"path\"\n+\t_ \"path\"\n+\tpathpkg \"path\"\n+)\n+\n+/* comment */\n+import (\n+\t\"fmt\"\n+\t\"math\" // for Abs\n+\t// This is a new run\n+\t\"errors\"\n+\t\"fmt\"\n+)\n+\n+// End an import declaration in the same line\n+// as the last import. See golang.org/issue/33538.\n+// Note: Must be the last (or 2nd last) line of the file.\n+import (\n+\t\"fmt\"\n+\t\"math\"\n+)"}, {"sha": "040b8722d47d3edf1a84c8d214239ff34bccc255", "filename": "libgo/go/cmd/gofmt/testdata/import.input", "status": "modified", "additions": 68, "deletions": 3, "changes": 71, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fimport.input?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -1,3 +1,4 @@\n+// package comment\n package main\n \n import (\n@@ -8,9 +9,6 @@ import (\n \t\"io\"\n )\n \n-import(\"fmt\"\n-\"math\")\n-\n import (\n \t\"fmt\"\n \n@@ -23,6 +21,10 @@ import (\n \t\"io\"\n )\n \n+// We reset the line numbering to test that\n+// the formatting works independent of line directives\n+//line :19\n+\n import (\n \t\"fmt\"\n \t\"math\"\n@@ -132,3 +134,66 @@ import (\n \n \t\"dedup_by_group\"\n )\n+\n+import (\n+\t/* comment */ io1 \"io\"\n+\t\"fmt\" // for Printf\n+\t/* comment */ \"log\"\n+\t/* comment */ io2 \"io\"\n+)\n+\n+import (\n+\t/* comment */ io2 \"io\" // hello\n+\t/* comment */ io1 \"io\"\n+\t\"math\" /* right side */\n+\t\"fmt\"\n+\t// end\n+)\n+\n+import (\n+\t/* comment */ io1 \"io\" /* before */ // after\n+\t\"fmt\"\n+\t\"errors\" // for New\n+\tio2 \"io\" // another\n+\t// end\n+)\n+\n+import (\n+\t/* left */ \"fmt\" /* right */\n+\t\"errors\" // for New\n+\t/* left */ \"math\" /* right */\n+\t\"log\" // for Fatal\n+)\n+\n+import /* why */ /* comment here? */ (\n+\t/* comment */ \"fmt\"\n+\t\"math\"\n+)\n+\n+// Reset it again\n+//line :100\n+\n+// Dedup with different import styles\n+import (\n+\t\"path\"\n+\t. \"path\"\n+\t_ \"path\"\n+\t\"path\"\n+\tpathpkg \"path\"\n+)\n+\n+/* comment */\n+import (\n+\t\"math\" // for Abs\n+\t\"fmt\"\n+\t// This is a new run\n+\t\"errors\"\n+\t\"fmt\"\n+\t\"errors\"\n+)\n+\n+// End an import declaration in the same line\n+// as the last import. See golang.org/issue/33538.\n+// Note: Must be the last (or 2nd last) line of the file.\n+import(\"fmt\"\n+\"math\")\n\\ No newline at end of file"}, {"sha": "5837fd52912daca70267188c34d42298ade76239", "filename": "libgo/go/cmd/gofmt/testdata/issue28082.golden", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.golden?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// testcase for issue #28082\n+\n+func foo() {}\n+\n+func main() {}\n+\n+func bar() {}"}, {"sha": "ab7d2186cea1f9ace37cf0e47b0e581a208dc054", "filename": "libgo/go/cmd/gofmt/testdata/issue28082.input", "status": "added", "additions": 13, "deletions": 0, "changes": 13, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Fissue28082.input?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,13 @@\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+package main\n+\n+// testcase for issue #28082\n+\n+func foo(                                                                                                ) {}\n+\n+func main(                                                                                                      ) {}\n+\n+func bar() {}"}, {"sha": "1dd781fbb094457b6304cddc08ae3814d468216d", "filename": "libgo/go/cmd/gofmt/testdata/rewrite10.golden", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.golden", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.golden", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.golden?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,19 @@\n+//gofmt -r=a->a\n+\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 33103, 33104, and 33105.\n+\n+package pkg\n+\n+func fn() {\n+\t_ = func() {\n+\t\tswitch {\n+\t\tdefault:\n+\t\t}\n+\t}\n+\t_ = func() string {}\n+\t_ = func() { var ptr *string; println(ptr) }\n+}"}, {"sha": "1dd781fbb094457b6304cddc08ae3814d468216d", "filename": "libgo/go/cmd/gofmt/testdata/rewrite10.input", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.input", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.input", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Fgofmt%2Ftestdata%2Frewrite10.input?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -0,0 +1,19 @@\n+//gofmt -r=a->a\n+\n+// Copyright 2019 The Go Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style\n+// license that can be found in the LICENSE file.\n+\n+// Issue 33103, 33104, and 33105.\n+\n+package pkg\n+\n+func fn() {\n+\t_ = func() {\n+\t\tswitch {\n+\t\tdefault:\n+\t\t}\n+\t}\n+\t_ = func() string {}\n+\t_ = func() { var ptr *string; println(ptr) }\n+}"}, {"sha": "904c2c6f377379f96acf5217796e2847e3b105f9", "filename": "libgo/go/cmd/internal/buildid/buildid_test.go", "status": "modified", "additions": 26, "deletions": 15, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5a8ea165926cb0737ab03bc48c18dc5198ab5305/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Fbuildid_test.go?ref=5a8ea165926cb0737ab03bc48c18dc5198ab5305", "patch": "@@ -7,6 +7,7 @@ package buildid\n import (\n \t\"bytes\"\n \t\"crypto/sha256\"\n+\t\"internal/obscuretestdata\"\n \t\"io/ioutil\"\n \t\"os\"\n \t\"reflect\"\n@@ -19,13 +20,6 @@ const (\n )\n \n func TestReadFile(t *testing.T) {\n-\tvar files = []string{\n-\t\t\"p.a\",\n-\t\t\"a.elf\",\n-\t\t\"a.macho\",\n-\t\t\"a.pe\",\n-\t}\n-\n \tf, err := ioutil.TempFile(\"\", \"buildid-test-\")\n \tif err != nil {\n \t\tt.Fatal(err)\n@@ -34,26 +28,43 @@ func TestReadFile(t *testing.T) {\n \tdefer os.Remove(tmp)\n \tf.Close()\n \n-\tfor _, f := range files {\n-\t\tid, err := ReadFile(\"testdata/\" + f)\n+\t// Use obscured files to prevent Apple\u2019s notarization service from\n+\t// mistaking them as candidates for notarization and rejecting the entire\n+\t// toolchain.\n+\t// See golang.org/issue/34986\n+\tvar files = []string{\n+\t\t\"p.a.base64\",\n+\t\t\"a.elf.base64\",\n+\t\t\"a.macho.base64\",\n+\t\t\"a.pe.base64\",\n+\t}\n+\n+\tfor _, name := range files {\n+\t\tf, err := obscuretestdata.DecodeToTempFile(\"testdata/\" + name)\n+\t\tif err != nil {\n+\t\t\tt.Errorf(\"obscuretestdata.DecodeToTempFile(testdata/%s): %v\", name, err)\n+\t\t\tcontinue\n+\t\t}\n+\t\tdefer os.Remove(f)\n+\t\tid, err := ReadFile(f)\n \t\tif id != expectedID || err != nil {\n \t\t\tt.Errorf(\"ReadFile(testdata/%s) = %q, %v, want %q, nil\", f, id, err, expectedID)\n \t\t}\n \t\told := readSize\n \t\treadSize = 2048\n-\t\tid, err = ReadFile(\"testdata/\" + f)\n+\t\tid, err = ReadFile(f)\n \t\treadSize = old\n \t\tif id != expectedID || err != nil {\n-\t\t\tt.Errorf(\"ReadFile(testdata/%s) [readSize=2k] = %q, %v, want %q, nil\", f, id, err, expectedID)\n+\t\t\tt.Errorf(\"ReadFile(%s) [readSize=2k] = %q, %v, want %q, nil\", f, id, err, expectedID)\n \t\t}\n \n-\t\tdata, err := ioutil.ReadFile(\"testdata/\" + f)\n+\t\tdata, err := ioutil.ReadFile(f)\n \t\tif err != nil {\n \t\t\tt.Fatal(err)\n \t\t}\n \t\tm, _, err := FindAndHash(bytes.NewReader(data), expectedID, 1024)\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"FindAndHash(testdata/%s): %v\", f, err)\n+\t\t\tt.Errorf(\"FindAndHash(%s): %v\", f, err)\n \t\t\tcontinue\n \t\t}\n \t\tif err := ioutil.WriteFile(tmp, data, 0666); err != nil {\n@@ -68,7 +79,7 @@ func TestReadFile(t *testing.T) {\n \t\terr = Rewrite(tf, m, newID)\n \t\terr2 := tf.Close()\n \t\tif err != nil {\n-\t\t\tt.Errorf(\"Rewrite(testdata/%s): %v\", f, err)\n+\t\t\tt.Errorf(\"Rewrite(%s): %v\", f, err)\n \t\t\tcontinue\n \t\t}\n \t\tif err2 != nil {\n@@ -77,7 +88,7 @@ func TestReadFile(t *testing.T) {\n \n \t\tid, err = ReadFile(tmp)\n \t\tif id != newID || err != nil {\n-\t\t\tt.Errorf(\"ReadFile(testdata/%s after Rewrite) = %q, %v, want %q, nil\", f, id, err, newID)\n+\t\t\tt.Errorf(\"ReadFile(%s after Rewrite) = %q, %v, want %q, nil\", f, id, err, newID)\n \t\t}\n \t}\n }"}, {"sha": "f63128921aaee5027de1ae83995b183531c0a70f", "filename": "libgo/go/cmd/internal/buildid/testdata/a.elf", "status": "removed", "additions": 0, "deletions": 0, "changes": 0, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/6ac6529e155c9baa0aaaed7aca06bd38ebda5b43/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libgo%2Fgo%2Fcmd%2Finternal%2Fbuildid%2Ftestdata%2Fa.elf?ref=6ac6529e155c9baa0aaaed7aca06bd38ebda5b43"}]}