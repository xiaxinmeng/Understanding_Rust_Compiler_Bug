{"sha": "5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NWNjNTNkNGVjZTA4ZjMxZTRiN2RmZWI1NjNkZjQyZTNjZWM5ZjllOQ==", "commit": {"author": {"name": "Mark Mitchell", "email": "mark@codesourcery.com", "date": "2005-09-06T14:55:06Z"}, "committer": {"name": "Mark Mitchell", "email": "mmitchel@gcc.gnu.org", "date": "2005-09-06T14:55:06Z"}, "message": "re PR c++/9782 (constructor not called on higher-dimensional arrays of template types)\n\n\t* cp-tree.h (rvalue): New function.\n\t* call.c (build_conditional_expr): Use it.\n\t* init.c (build_new_1): Likewise.\n\t* rtti.c (build_dynamic_cast_1): Likewise.\n\t* tree.c (rvalue): New function.\n\t* typeck.c (build_unary_op): Use it.\n\t(build_static_cast_1): Likewise.\n\n\t* g++.dg/expr/cast6.C: New test.\n\n\tPR c++/9782\n\t* init.c (build_new_1): Make sure the entire array type is\n\tcomplete, not just its element types.\n\n\tPR c++/9782\n\t* g++.dg/init/new15.C: New test.\n\nFrom-SVN: r103947", "tree": {"sha": "4835a35a831281082968f68066f0ad2a45dddcec", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/4835a35a831281082968f68066f0ad2a45dddcec"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/comments", "author": null, "committer": null, "parents": [{"sha": "d102ae00ef70b537039d4cfb766a072ec576876a", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/d102ae00ef70b537039d4cfb766a072ec576876a", "html_url": "https://github.com/Rust-GCC/gccrs/commit/d102ae00ef70b537039d4cfb766a072ec576876a"}], "stats": {"total": 94, "additions": 79, "deletions": 15}, "files": [{"sha": "50ce226f8342f14f8e72079232e3fcf89c917bdc", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -1,3 +1,17 @@\n+2005-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* cp-tree.h (rvalue): New function.\n+\t* call.c (build_conditional_expr): Use it.\n+\t* init.c (build_new_1): Likewise.\n+\t* rtti.c (build_dynamic_cast_1): Likewise.\n+\t* tree.c (rvalue): New function.\n+\t* typeck.c (build_unary_op): Use it.\n+\t(build_static_cast_1): Likewise.\n+\n+\tPR c++/9782\n+\t* init.c (build_new_1): Make sure the entire array type is\n+\tcomplete, not just its element types.\n+\n 2005-09-06  Volker Reichelt  <reichelt@igpm.rwth-aachen.de>\n \n \t* decl.c (check_elaborated_type_specifier): Remove redundant check."}, {"sha": "fab01fc95f76b731a63aec468255881855095bbf", "filename": "gcc/cp/call.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -3486,7 +3486,7 @@ build_conditional_expr (tree arg1, tree arg2, tree arg3)\n   /* If this expression is an rvalue, but might be mistaken for an\n      lvalue, we must add a NON_LVALUE_EXPR.  */\n   if (!lvalue_p && real_lvalue_p (result))\n-    result = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n+    result = rvalue (result);\n \n   return result;\n }"}, {"sha": "2803f51da271ad1c842a9c48a34a4762bb135fb8", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 2, "deletions": 1, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -4263,7 +4263,8 @@ extern int cp_cannot_inline_tree_fn\t\t(tree*);\n extern tree cp_add_pending_fn_decls\t\t(void*,tree);\n extern int cp_auto_var_in_fn_p\t\t\t(tree,tree);\n extern tree fold_if_not_in_template\t\t(tree);\n-\n+extern tree rvalue                              (tree);\n+   \n /* in typeck.c */\n extern int string_conv_p\t\t\t(tree, tree, int);\n extern tree cp_truthvalue_conversion\t\t(tree);"}, {"sha": "50b0bcabb46651d49d53aa9da5b1d79f461400ed", "filename": "gcc/cp/init.c", "status": "modified", "additions": 4, "deletions": 5, "changes": 9, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -1838,6 +1838,9 @@ build_new_1 (tree exp)\n \t}\n     }\n \n+  if (!complete_type_or_else (type, exp))\n+    return error_mark_node;\n+\n   /* If our base type is an array, then make sure we know how many elements\n      it has.  */\n   for (elt_type = type;\n@@ -1846,9 +1849,6 @@ build_new_1 (tree exp)\n     nelts = cp_build_binary_op (MULT_EXPR, nelts,\n \t\t\t\tarray_type_nelts_top (elt_type));\n \n-  if (!complete_type_or_else (elt_type, exp))\n-    return error_mark_node;\n-\n   if (TREE_CODE (elt_type) == VOID_TYPE)\n     {\n       error (\"invalid type %<void%> for new\");\n@@ -2227,8 +2227,7 @@ build_new_1 (tree exp)\n   rval = build_nop (pointer_type, rval);\n \n   /* A new-expression is never an lvalue.  */\n-  if (real_lvalue_p (rval))\n-    rval = build1 (NON_LVALUE_EXPR, TREE_TYPE (rval), rval);\n+  rval = rvalue (rval);\n \n   return rval;\n }"}, {"sha": "6d60d4c03598e27e2eff19ba07097b684a2752ea", "filename": "gcc/cp/rtti.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Frtti.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Frtti.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Frtti.c?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -555,7 +555,7 @@ build_dynamic_cast_1 (tree type, tree expr)\n \texpr = build_base_path (PLUS_EXPR, convert_from_reference (expr),\n \t\t\t\tbinfo, 0);\n \tif (TREE_CODE (exprtype) == POINTER_TYPE)\n-\t  expr = non_lvalue (expr);\n+\t  expr = rvalue (expr);\n \treturn expr;\n       }\n   }"}, {"sha": "9c28f13f306ee904dd0db8eb088f98b4fbdf24c2", "filename": "gcc/cp/tree.c", "status": "modified", "additions": 20, "deletions": 0, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Ftree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Ftree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftree.c?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -365,6 +365,26 @@ get_target_expr (tree init)\n   return build_target_expr_with_type (init, TREE_TYPE (init));\n }\n \n+/* EXPR is being used in an rvalue context.  Return a version of EXPR\n+   that is marked as an rvalue.  */\n+\n+tree\n+rvalue (tree expr)\n+{\n+  tree type;\n+  if (real_lvalue_p (expr))\n+    {\n+      type = TREE_TYPE (expr);\n+      /* [basic.lval]\n+\t \n+         Non-class rvalues always have cv-unqualified types.  */\n+      if (!CLASS_TYPE_P (type))\n+\ttype = TYPE_MAIN_VARIANT (type);\n+      expr = build1 (NON_LVALUE_EXPR, type, expr);\n+    }\n+  return expr;\n+}\n+\n \f\n static tree\n build_cplus_array_type_1 (tree elt_type, tree index_type)"}, {"sha": "67f631a31e51021cd6f6deb1b2835c1aa8750c30", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 5, "deletions": 7, "changes": 12, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -3768,8 +3768,7 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \n \t    /* Make sure the result is not an lvalue: a unary plus or minus\n \t       expression is always a rvalue.  */\n-\t    if (real_lvalue_p (arg))\n-\t      arg = build1 (NON_LVALUE_EXPR, TREE_TYPE (arg), arg);\n+\t    arg = rvalue (arg);\n \t  }\n       }\n       break;\n@@ -4016,9 +4015,9 @@ build_unary_op (enum tree_code code, tree xarg, int noconvert)\n \t      tree type = build_pointer_type (TREE_TYPE (TREE_TYPE (arg)));\n \t      arg = build1 (CONVERT_EXPR, type, arg);\n \t    }\n-\t  else if (lvalue_p (arg))\n+\t  else\n \t    /* Don't let this be an lvalue.  */\n-\t    return non_lvalue (arg);\n+\t    arg = rvalue (arg);\n \t  return arg;\n \t}\n \n@@ -4666,9 +4665,8 @@ build_static_cast_1 (tree type, tree expr, bool c_cast_p,\n \n \t If T is a reference type, the result is an lvalue; otherwise,\n \t the result is an rvalue.  */\n-      if (TREE_CODE (type) != REFERENCE_TYPE\n-\t  && real_lvalue_p (result))\n-\tresult = build1 (NON_LVALUE_EXPR, TREE_TYPE (result), result);\n+      if (TREE_CODE (type) != REFERENCE_TYPE)\n+\tresult = rvalue (result);\n       return result;\n     }\n "}, {"sha": "87af08ca7b2fbfc8a23f8cd8982a7c455767d309", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 7, "deletions": 0, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -1,3 +1,10 @@\n+2005-09-06  Mark Mitchell  <mark@codesourcery.com>\n+\n+\t* g++.dg/expr/cast6.C: New test.\n+\n+\tPR c++/9782\n+\t* g++.dg/init/new15.C: New test.\n+\n 2005-09-06  Keith Besaw  <kbesaw@us.ibm.com>\n \n \t* gcc.dg/vect/Os-vect-95.c: New test."}, {"sha": "434a046691ea972fc83c6488302b2d1db0263edf", "filename": "gcc/testsuite/g++.dg/expr/cast6.C", "status": "added", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast6.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast6.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Fexpr%2Fcast6.C?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -0,0 +1,6 @@\n+void f(int &);\n+void f(const int &);\n+int main() {\n+  volatile int x = 2;\n+  f((int)x);\n+}"}, {"sha": "17cf8a80b6852037c3137ad1b33362e0df65abc1", "filename": "gcc/testsuite/g++.dg/init/new15.C", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew15.C", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew15.C", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg%2B%2B.dg%2Finit%2Fnew15.C?ref=5cc53d4ece08f31e4b7dfeb563df42e3cec9f9e9", "patch": "@@ -0,0 +1,19 @@\n+// PR c++/9782\n+\n+extern \"C\" void printf(char *, ...);\n+\n+template <int>\n+struct A {\n+  A() {printf(\"A::A()\\n\");}\n+};\n+\n+\n+struct B {\n+  B() {printf(\"B::B()\\n\");}\n+};\n+\n+\n+int main () {\n+  new A<0>[1][1];\n+  new B   [1][1];\n+}"}]}