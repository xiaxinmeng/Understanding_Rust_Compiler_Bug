{"sha": "58fea6afd912f7c309c156522391b20462372ceb", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NThmZWE2YWZkOTEyZjdjMzA5YzE1NjUyMjM5MWIyMDQ2MjM3MmNlYg==", "commit": {"author": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-08-02T01:13:45Z"}, "committer": {"name": "Zack Weinberg", "email": "zack@gcc.gnu.org", "date": "2000-08-02T01:13:45Z"}, "message": "cpperror.c (v_message): Split into _cpp_begin_message and v_message macro.\n\n\t* cpperror.c (v_message): Split into _cpp_begin_message and\n\tv_message macro.  All callers updated.\n\t(_cpp_begin_message): Do inhibit_errors/inhibit_warnings\n\tchecks here.\n\n\t* cppfiles.c (cpp_syshdr_flags): New function.\n\t(read_include_file): Don't call cpp_output_tokens.  Call\n\tenter_file hook.\n\t* cppinit.c (dump_macros_helper): Moved to cppmain.c.\n\t(cpp_reader_init): Don't initialize token_buffer.  Call\n\t_cpp_init_internal_pragmas.\n\t(cpp_cleanup): Don't clear token_buffer.\n\t(cpp_start_read): Don't worry about output from -D processing.\n\tDon't call cpp_output_tokens.\n\t(cpp_finish): Don't dump macros here.  Don't call\n\tcpp_output_tokens.\n\t* cppmacro.c (_cpp_dump_definition): Rename\n\tcpp_dump_definition.  Write directly to a FILE *.\n\t(dump_funlike_macro): Delete.\n\t(dump_macro_args): New.\n\n\t* cpplex.c (TOKEN_LEN): Convert to inline function.\n\t(_cpp_grow_token_buffer, safe_fwrite, cpp_output_tokens,\n\tcpp_scan_line, _cpp_dump_list): Delete.\n\t(cpp_printf, cpp_output_list): New.\n\t(output_line_command): Don't worry about entering or leaving files.\n\t(cpp_scan_buffer): Just output each token as we hit it.\n\t(process_directive): Don't call cpp_output_tokens.\n\t(_cpp_glue_header_name): Don't use token_buffer.\n\t(output_token, dump_param_spelling): Write directly to a FILE *.\n\n\t* cpplib.c (pass_thru_directive, dump_macro_name,\n\tpragma_dispatch, do_pragma_gcc): Delete.\n\t(do_define, do_undef, parse_include, do_line, do_ident, do_pragma,\n\tdo_pragma_poison, cpp_pop_buffer): Call the appropriate hook\n\tfunctions.\n\t(do_error, do_warning, pragma_dependency): Call\n\t_cpp_begin_message, then cpp_output_list.\n\t(cpp_register_pragma, cpp_register_pragma_space,\n\t_cpp_init_internal_pragmas): New.\n\t(do_pragma): Walk the pragmas table here.\n\t(do_pragma_once, do_pragma_poison, do_pragma_system_header,\n\tdo_pragma_dependency): Return void.\n\t(do_pragma_implementation): Moved to cppmain.c.\n\n\t* cpplib.h: Update prototypes.\n\t (struct cpp_reader): Remove printer, token_buffer,\n\ttoken_buffer_size, and limit.  Add struct cb, and pragmas.\n\t(struct cpp_printer): Remove last_id and written.\n\t(CPP_WRITTEN, CPP_PWRITTEN, CPP_SET_WRITTEN,\n\tCPP_ADJUST_WRITTEN): Delete.\n\t* cpphash.h: Update prototypes.\n\t(ufputs): New wrapper.\n\n\t* cppmain.c (cb_define, cb_undef, cb_include, cb_ident,\n\tcb_enter_file, cb_leave_file, cb_def_pragma): New functions.\n\t(main): Set up callbacks.  Register #pragma implementation.\n\tDump macros from here.\n\nFrom-SVN: r35415", "tree": {"sha": "af945d1943c9c6b458fec03b961f8f0d523896bf", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/af945d1943c9c6b458fec03b961f8f0d523896bf"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/58fea6afd912f7c309c156522391b20462372ceb", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fea6afd912f7c309c156522391b20462372ceb", "html_url": "https://github.com/Rust-GCC/gccrs/commit/58fea6afd912f7c309c156522391b20462372ceb", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/58fea6afd912f7c309c156522391b20462372ceb/comments", "author": null, "committer": null, "parents": [{"sha": "8cd8f856b33bbd6c6627eb0a18e34b046e2163f1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8cd8f856b33bbd6c6627eb0a18e34b046e2163f1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8cd8f856b33bbd6c6627eb0a18e34b046e2163f1"}], "stats": {"total": 1396, "additions": 754, "deletions": 642}, "files": [{"sha": "66921668b880025d4bdb3956d55eb0fa85def441", "filename": "gcc/cpperror.c", "status": "modified", "additions": 89, "deletions": 80, "changes": 169, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpperror.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpperror.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpperror.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -32,10 +32,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.\n static void print_containing_files\tPARAMS ((cpp_reader *, cpp_buffer *));\n static void print_file_and_line\t\tPARAMS ((const char *, unsigned int,\n \t\t\t\t\t\t unsigned int));\n-static void v_message\t\t\tPARAMS ((cpp_reader *, int,\n-\t\t\t\t\t\t const char *,\n-\t\t\t\t\t\t unsigned int, unsigned int,\n-\t\t\t\t\t\t const char *, va_list));\n+\n+#define v_message(msgid, ap) \\\n+do { vfprintf (stderr, _(msgid), ap); putc ('\\n', stderr); } while (0)\n \n /* Print the file names and line numbers of the #include\n    commands which led to the current file.  */\n@@ -92,70 +91,101 @@ print_file_and_line (filename, line, column)\n      const char *filename;\n      unsigned int line, column;\n {\n-  if (filename == 0 || *filename == '\\0')\n-    filename = \"<stdin>\";\n   if (line == 0)\n     fputs (_(\"<command line>: \"), stderr);\n-  else if (column > 0)\n-    fprintf (stderr, \"%s:%u:%u: \", filename, line, column);\n   else\n-    fprintf (stderr, \"%s:%u: \", filename, line);\n+    {\n+      if (filename == 0 || *filename == '\\0')\n+\tfilename = \"<stdin>\";\n+      if (column > 0)\n+\tfprintf (stderr, \"%s:%u:%u: \", filename, line, column);\n+      else\n+\tfprintf (stderr, \"%s:%u: \", filename, line);\n+    }\n }\n \n-/* IS_ERROR is 3 for ICE, 2 for merely \"fatal\" error,\n-   1 for error, 0 for warning.  */\n+/* Set up for an error message: print the file and line, bump the error\n+   counter, etc.\n+   If it returns 0, this error has been suppressed.  */\n \n-static void\n-v_message (pfile, is_error, file, line, col, msg, ap)\n+int\n+_cpp_begin_message (pfile, code, file, line, col)\n      cpp_reader *pfile;\n-     int is_error;\n+     enum error_type code;\n      const char *file;\n      unsigned int line;\n      unsigned int col;\n-     const char *msg;\n-     va_list ap;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n+  int is_warning = 0;\n \n-  if (ip)\n+  switch (code)\n     {\n-      if (file == NULL)\n-\tfile = ip->nominal_fname;\n-      if (line == 0)\n-\tline = _cpp_get_line (pfile, &col);\n-      print_containing_files (pfile, ip);\n-      print_file_and_line (file, line,\n-\t\t\t   CPP_OPTION (pfile, show_column) ? col : 0);\n-    }\n-  else\n-    fprintf (stderr, \"%s: \", progname);\n-\n-  switch (is_error)\n-    {\n-    case 0:\n+    case WARNING:\n       if (! CPP_OPTION (pfile, warnings_are_errors))\n \t{\n-\t  fprintf (stderr, _(\"warning: \"));\n-\t  break;\n+\t  if (CPP_OPTION (pfile, inhibit_warnings))\n+\t    return 0;\n+\t  is_warning = 1;\n+\t}\n+      else\n+\t{\n+\t  if (CPP_OPTION (pfile, inhibit_errors))\n+\t    return 0;\n+\t  if (pfile->errors < CPP_FATAL_LIMIT)\n+\t    pfile->errors++;\n+\t}\n+      break;\n+\n+    case PEDWARN:\n+      if (! CPP_OPTION (pfile, pedantic_errors))\n+\t{\n+\t  if (CPP_OPTION (pfile, inhibit_warnings))\n+\t    return 0;\n+\t  is_warning = 1;\n \t}\n-      /* else fall through */\n-    case 1:\n+      else\n+\t{\n+\t  if (CPP_OPTION (pfile, inhibit_errors))\n+\t    return 0;\n+\t  if (pfile->errors < CPP_FATAL_LIMIT)\n+\t    pfile->errors++;\n+\t}\n+      break;\n+\t\n+    case ERROR:\n+      if (CPP_OPTION (pfile, inhibit_errors))\n+\treturn 0;\n       if (pfile->errors < CPP_FATAL_LIMIT)\n \tpfile->errors++;\n       break;\n-    case 2:\n+      /* Fatal errors cannot be inhibited.  */\n+    case FATAL:\n       pfile->errors = CPP_FATAL_LIMIT;\n       break;\n-    case 3:\n+    case ICE:\n       fprintf (stderr, _(\"internal error: \"));\n       pfile->errors = CPP_FATAL_LIMIT;\n       break;\n-    default:\n-      cpp_ice (pfile, \"bad is_error(%d) in v_message\", is_error);\n     }\n \n-  vfprintf (stderr, _(msg), ap);\n-  putc ('\\n', stderr);\n+  if (ip)\n+    {\n+      if (file == NULL)\n+\tfile = ip->nominal_fname;\n+      if (line == 0)\n+\tline = _cpp_get_line (pfile, &col);\n+      print_containing_files (pfile, ip);\n+      print_file_and_line (file, line,\n+\t\t\t   CPP_OPTION (pfile, show_column) ? col : 0);\n+    }\n+  else\n+    fprintf (stderr, \"%s: \", progname);\n+\n+  if (is_warning)\n+    fputs (_(\"warning: \"), stderr);\n+\n+  return 1;\n }\n \n /* Exported interface.  */\n@@ -179,7 +209,8 @@ cpp_ice VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  v_message (pfile, 3, NULL, 0, 0, msgid, ap);\n+  if (_cpp_begin_message (pfile, ICE, NULL, 0, 0))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -205,7 +236,8 @@ cpp_fatal VPARAMS ((cpp_reader *pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  v_message (pfile, 2, NULL, 0, 0, msgid, ap);\n+  if (_cpp_begin_message (pfile, FATAL, NULL, 0, 0))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -225,10 +257,8 @@ cpp_error VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, inhibit_errors))\n-    return;\n-\n-  v_message (pfile, 1, NULL, 0, 0, msgid, ap);\n+  if (_cpp_begin_message (pfile, ERROR, NULL, 0, 0))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -253,10 +283,8 @@ cpp_error_with_line VPARAMS ((cpp_reader *pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, inhibit_errors))\n-    return;\n-\n-  v_message (pfile, 1, NULL, line, column, msgid, ap);\n+  if (_cpp_begin_message (pfile, ERROR, NULL, line, column))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -285,10 +313,8 @@ cpp_warning VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, inhibit_warnings))\n-    return;\n-\n-  v_message (pfile, 0, NULL, 0, 0, msgid, ap);\n+  if (_cpp_begin_message (pfile, WARNING, NULL, 0, 0))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -313,10 +339,8 @@ cpp_warning_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, inhibit_warnings))\n-    return;\n-\n-  v_message (pfile, 0, NULL, line, column, msgid, ap);\n+  if (_cpp_begin_message (pfile, WARNING, NULL, line, column))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -336,13 +360,8 @@ cpp_pedwarn VPARAMS ((cpp_reader * pfile, const char *msgid, ...))\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, pedantic_errors)\n-      ? CPP_OPTION (pfile, inhibit_errors)\n-      : CPP_OPTION (pfile, inhibit_warnings))\n-    return;\n-\n-  v_message (pfile, CPP_OPTION (pfile, pedantic_errors),\n-\t\t NULL, 0, 0, msgid, ap);\n+  if (_cpp_begin_message (pfile, PEDWARN, NULL, 0, 0))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -367,13 +386,8 @@ cpp_pedwarn_with_line VPARAMS ((cpp_reader * pfile, int line, int column,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, pedantic_errors)\n-      ? CPP_OPTION (pfile, inhibit_errors)\n-      : CPP_OPTION (pfile, inhibit_warnings))\n-    return;\n-\n-  v_message (pfile, CPP_OPTION (pfile, pedantic_errors),\n-\t\t NULL, line, column, msgid, ap);\n+  if (_cpp_begin_message (pfile, PEDWARN, NULL, line, column))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n \n@@ -404,13 +418,8 @@ cpp_pedwarn_with_file_and_line VPARAMS ((cpp_reader *pfile,\n   msgid = va_arg (ap, const char *);\n #endif\n \n-  if (CPP_OPTION (pfile, pedantic_errors)\n-      ? CPP_OPTION (pfile, inhibit_errors)\n-      : CPP_OPTION (pfile, inhibit_warnings))\n-    return;\n-\n-  v_message (pfile, CPP_OPTION (pfile, pedantic_errors),\n-\t\t file, line, col, msgid, ap);\n+  if (_cpp_begin_message (pfile, PEDWARN, file, line, col))\n+    v_message (msgid, ap);\n   va_end(ap);\n }\n "}, {"sha": "2a8f01c38353b1297cac65c27bce1d53d0ad8a8f", "filename": "gcc/cppfiles.c", "status": "modified", "additions": 16, "deletions": 5, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppfiles.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppfiles.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppfiles.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -370,6 +370,20 @@ cpp_make_system_header (pfile, pbuf, flag)\n     pbuf->inc->sysp = flag;\n }\n \n+const char *\n+cpp_syshdr_flags (pfile, pbuf)\n+     cpp_reader *pfile ATTRIBUTE_UNUSED;\n+     cpp_buffer *pbuf;\n+{\n+#ifndef NO_IMPLICIT_EXTERN_C\n+  if (CPP_OPTION (pfile, cplusplus) && pbuf->inc->sysp == 2)\n+    return \" 3 4\";\n+#endif\n+  if (pbuf->inc->sysp)\n+    return \" 3\";\n+  return \"\";\n+}\n+\n /* Report on all files that might benefit from a multiple include guard.\n    Triggered by -H.  */\n void\n@@ -594,11 +608,6 @@ read_include_file (pfile, inc)\n   cpp_buffer *fp;\n   int fd = inc->fd;\n \n-  /* Ensures we dump our current line before entering an include file.  */\n-  if (CPP_BUFFER (pfile) && pfile->printer)\n-    cpp_output_tokens (pfile, pfile->printer,\n-\t\t       CPP_BUF_LINE (CPP_BUFFER (pfile)));\n-\n   fp = cpp_push_buffer (pfile, NULL, 0);\n \n   if (fp == 0)\n@@ -683,6 +692,8 @@ read_include_file (pfile, inc)\n     fp->actual_dir = actual_directory (pfile, inc->name);\n \n   pfile->input_stack_listing_current = 0;\n+  if (pfile->cb.enter_file)\n+    (*pfile->cb.enter_file) (pfile);\n   return 1;\n \n  perror_fail:"}, {"sha": "c5b024427ec10aa1779a8234a073ce78e8b9b86f", "filename": "gcc/cpphash.h", "status": "modified", "additions": 16, "deletions": 4, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpphash.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpphash.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpphash.h?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -210,10 +210,15 @@ extern unsigned char _cpp_IStable[256];\n #define DUMMY_TOKEN     0\n #define NO_DUMMY_TOKEN\t1\n \n+/* In cpperror.c  */\n+enum error_type { WARNING = 0, PEDWARN, ERROR, FATAL, ICE };\n+extern int _cpp_begin_message PARAMS ((cpp_reader *, enum error_type,\n+\t\t\t\t       const char *, unsigned int,\n+\t\t\t\t       unsigned int));\n+\n /* In cppmacro.c */\n extern void _cpp_free_definition\tPARAMS ((cpp_hashnode *));\n extern int _cpp_create_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n-extern void _cpp_dump_definition\tPARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* In cpphash.c */\n extern void _cpp_init_macros\t\tPARAMS ((cpp_reader *));\n@@ -253,9 +258,6 @@ extern int _cpp_equiv_toklists\t\tPARAMS ((const cpp_toklist *,\n extern void _cpp_expand_token_space\tPARAMS ((cpp_toklist *, unsigned int));\n extern void _cpp_reserve_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n extern void _cpp_expand_name_space\tPARAMS ((cpp_toklist *, unsigned int));\n-extern void _cpp_dump_list\t\tPARAMS ((cpp_reader *,\n-\t\t\t\t\t\t const cpp_toklist *,\n-\t\t\t\t\t\t const cpp_token *, int));\n extern int _cpp_equiv_tokens\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const cpp_token *));\n extern void _cpp_run_directive\t\tPARAMS ((cpp_reader *,\n@@ -279,6 +281,7 @@ extern struct answer **_cpp_find_answer\tPARAMS ((cpp_hashnode *,\n \t\t\t\t\t\t const cpp_toklist *));\n extern void _cpp_init_stacks\tPARAMS ((cpp_reader *));\n extern void _cpp_cleanup_stacks\tPARAMS ((cpp_reader *));\n+extern void _cpp_init_internal_pragmas PARAMS ((cpp_reader *));\n \n /* Utility routines and macros.  */\n #define xnew(T)\t\t(T *) xmalloc (sizeof(T))\n@@ -295,6 +298,7 @@ static inline int ustrncmp\tPARAMS ((const U_CHAR *, const U_CHAR *,\n static inline size_t ustrlen\tPARAMS ((const U_CHAR *));\n static inline U_CHAR *uxstrdup\tPARAMS ((const U_CHAR *));\n static inline U_CHAR *ustrchr\tPARAMS ((const U_CHAR *, int));\n+static inline int ufputs\tPARAMS ((const U_CHAR *, FILE *));\n \n static inline int\n ustrcmp (s1, s2)\n@@ -333,4 +337,12 @@ ustrchr (s1, c)\n   return (U_CHAR *) strchr ((const char *)s1, c);\n }\n \n+static inline int\n+ufputs (s, f)\n+     const U_CHAR *s;\n+     FILE *f;\n+{\n+  return fputs ((const char *)s, f);\n+}\n+\n #endif"}, {"sha": "e1bcda9e915be5e43b110ec3582acf336974e45d", "filename": "gcc/cppinit.c", "status": "modified", "additions": 10, "deletions": 48, "changes": 58, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppinit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppinit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppinit.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -114,7 +114,6 @@ static int opt_comp\t\t\tPARAMS ((const void *, const void *));\n static void sort_options\t\tPARAMS ((void));\n #endif\n static int parse_option\t\t\tPARAMS ((const char *));\n-static int dump_macros_helper\t\tPARAMS ((cpp_reader *, cpp_hashnode *));\n \n /* Fourth argument to append_include_chain: chain to use */\n enum { QUOTE = 0, BRACKET, SYSTEM, AFTER };\n@@ -415,10 +414,6 @@ cpp_reader_init (pfile)\n \n   memset ((char *) pfile, 0, sizeof (cpp_reader));\n \n-  pfile->token_buffer_size = 200;\n-  pfile->token_buffer = (U_CHAR *) xmalloc (pfile->token_buffer_size);\n-  CPP_SET_WRITTEN (pfile, 0);\n-\n   CPP_OPTION (pfile, dollars_in_ident) = 1;\n   CPP_OPTION (pfile, cplusplus_comments) = 1;\n   CPP_OPTION (pfile, warn_import) = 1;\n@@ -434,6 +429,7 @@ cpp_reader_init (pfile)\n   _cpp_init_macros (pfile);\n   _cpp_init_stacks (pfile);\n   _cpp_init_includes (pfile);\n+  _cpp_init_internal_pragmas (pfile);\n }\n \n /* Initialize a cpp_printer structure.  As a side effect, open the\n@@ -470,12 +466,6 @@ cpp_cleanup (pfile)\n   while (CPP_BUFFER (pfile) != NULL)\n     cpp_pop_buffer (pfile);\n \n-  if (pfile->token_buffer)\n-    {\n-      free (pfile->token_buffer);\n-      pfile->token_buffer = NULL;\n-    }\n-\n   if (pfile->deps)\n     deps_free (pfile->deps);\n \n@@ -857,18 +847,6 @@ cpp_start_read (pfile, print, fname)\n \n   initialize_dependency_output (pfile);\n \n-  /* -D and friends may produce output, which should be identified\n-     as line 0.  */\n-\n-  CPP_BUFFER (pfile)->lineno = 0;\n-  if (print)\n-    {\n-      print->last_fname = CPP_BUFFER (pfile)->nominal_fname;\n-      print->last_id = pfile->include_depth;\n-      print->written = CPP_WRITTEN (pfile);\n-      print->lineno = 0;\n-    }\n-\n   /* Install __LINE__, etc.  */\n   initialize_builtins (pfile);\n \n@@ -883,12 +861,12 @@ cpp_start_read (pfile, print, fname)\n     }\n   pfile->done_initializing = 1;\n \n-  /* Now flush any output recorded during initialization, and advance\n-     to line 1 of the main input file.  */\n-  CPP_BUFFER (pfile)->lineno = 1;\n-\n-  if (print && ! CPP_OPTION (pfile, no_output))\n-    cpp_output_tokens (pfile, print, 1);\n+  /* We start at line 1 of the main input file.  */\n+  if (print)\n+    {\n+      print->last_fname = CPP_BUFFER (pfile)->nominal_fname;\n+      print->lineno = 1;\n+    }\n \n   /* The -imacros files can be scanned now, but the -include files\n      have to be pushed onto the include stack and processed later,\n@@ -907,9 +885,7 @@ cpp_start_read (pfile, print, fname)\n   p = CPP_OPTION (pfile, pending)->include_head;\n   while (p)\n     {\n-      if (cpp_read_file (pfile, p->arg)\n-\t  && print && ! CPP_OPTION (pfile, no_output))\n-\tcpp_output_tokens (pfile, print, 1);  /* record entry to file */\n+      cpp_read_file (pfile, p->arg);\n       q = p->next;\n       free (p);\n       p = q;\n@@ -921,18 +897,6 @@ cpp_start_read (pfile, print, fname)\n   return 1;\n }\n \n-\n-/* Dump out the hash table.  */\n-static int\n-dump_macros_helper (pfile, hp)\n-     cpp_reader *pfile;\n-     cpp_hashnode *hp;\n-{\n-  if (hp->type == T_MACRO)\n-    _cpp_dump_definition (pfile, hp);\n-  return 1;\n-}\n-\n /* This is called at the end of preprocessing.  It pops the\n    last buffer and writes dependency output.  It should also\n    clear macro definitions, such that you could call cpp_start_read\n@@ -975,13 +939,11 @@ cpp_finish (pfile, print)\n \t}\n     }\n \n-  if (CPP_OPTION (pfile, dump_macros) == dump_only)\n-    cpp_forall_identifiers (pfile, dump_macros_helper);\n-\n   /* Flush any pending output.  */\n   if (print)\n     {\n-      cpp_output_tokens (pfile, print, print->lineno);\n+      if (pfile->need_newline)\n+\tputc ('\\n', print->outf);\n       if (ferror (print->outf) || fclose (print->outf))\n \tcpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n     }"}, {"sha": "d7ae4949b62dcf2435452f523a87440209382c74", "filename": "gcc/cpplex.c", "status": "modified", "additions": 210, "deletions": 250, "changes": 460, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplex.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -24,13 +24,9 @@ Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */\n \n Cleanups to do:-\n \n-o -dM and with _cpp_dump_list: too many \\n output.\n-o Put a printer object in cpp_reader?\n o Check line numbers assigned to all errors.\n o Replace strncmp with memcmp almost everywhere.\n o lex_line's use of cur_token, flags and list->token_used is a bit opaque.\n-o Convert do_ functions to return void.  Kaveh thinks its OK; and said he'll\n-  give it a run when we've got some code.\n o Distinguish integers, floats, and 'other' pp-numbers.\n o Store ints and char constants as binary values.\n o New command-line assertion syntax.\n@@ -101,9 +97,7 @@ static void free_macro_args PARAMS ((macro_args *));\n \n #define auto_expand_name_space(list) \\\n     _cpp_expand_name_space ((list), 1 + (list)->name_cap / 2)\n-static void safe_fwrite\t\tPARAMS ((cpp_reader *, const U_CHAR *,\n-\t\t\t\t\t size_t, FILE *));\n-static void dump_param_spelling PARAMS ((cpp_reader *, const cpp_toklist *,\n+static void dump_param_spelling PARAMS ((FILE *, const cpp_toklist *,\n \t\t\t\t\t unsigned int));\n static void output_line_command PARAMS ((cpp_reader *, cpp_printer *,\n \t\t\t\t\t unsigned int));\n@@ -135,8 +129,8 @@ static cpp_token *stringify_arg PARAMS ((cpp_reader *, const cpp_token *));\n static void expand_context_stack PARAMS ((cpp_reader *));\n static unsigned char * spell_token PARAMS ((cpp_reader *, const cpp_token *,\n \t\t\t\t\t    unsigned char *));\n-static void output_token PARAMS ((cpp_reader *, const cpp_token *,\n-\t\t\t\t  const cpp_token *));\n+static void output_token PARAMS ((cpp_reader *, FILE *, const cpp_token *,\n+\t\t\t\t  const cpp_token *, int));\n typedef unsigned int (* speller) PARAMS ((unsigned char *, cpp_toklist *,\n \t\t\t\t\t  cpp_token *));\n static cpp_token *make_string_token PARAMS ((cpp_token *, const U_CHAR *,\n@@ -189,11 +183,21 @@ static void process_directive PARAMS ((cpp_reader *, const cpp_token *));\n \n /* An upper bound on the number of bytes needed to spell a token,\n    including preceding whitespace.  */\n-#define TOKEN_LEN(token) (5 + (TOKEN_SPELL(token) == SPELL_STRING\t\\\n-\t\t\t       ? (token)->val.str.len\t\t\t\\\n-\t\t\t       : (TOKEN_SPELL(token) == SPELL_IDENT\t\\\n-\t\t\t\t  ? (token)->val.node->length\t\t\\\n-\t\t\t\t  : 0)))\n+static inline size_t TOKEN_LEN PARAMS ((const cpp_token *));\n+static inline size_t\n+TOKEN_LEN (token)\n+     const cpp_token *token;\n+{\n+  size_t len;\n+\n+  switch (TOKEN_SPELL (token))\n+    {\n+    default:\t\tlen = 0;\t\t\tbreak;\n+    case SPELL_STRING:\tlen = token->val.str.len;\tbreak;\n+    case SPELL_IDENT:\tlen = token->val.node->length;\tbreak;\n+    }\n+  return len + 5;\n+}\n \n #define IS_ARG_CONTEXT(c) ((c)->flags & CONTEXT_ARG)\n #define CURRENT_CONTEXT(pfile) ((pfile)->contexts + (pfile)->cur_context)\n@@ -246,44 +250,6 @@ END\n #undef END\n #undef s\n \n-/* Re-allocates PFILE->token_buffer so it will hold at least N more chars.  */\n-\n-void\n-_cpp_grow_token_buffer (pfile, n)\n-     cpp_reader *pfile;\n-     long n;\n-{\n-  long old_written = CPP_WRITTEN (pfile);\n-  pfile->token_buffer_size = n + 2 * pfile->token_buffer_size;\n-  pfile->token_buffer = (U_CHAR *)\n-    xrealloc(pfile->token_buffer, pfile->token_buffer_size);\n-  CPP_SET_WRITTEN (pfile, old_written);\n-}\n-\n-/* Deal with the annoying semantics of fwrite.  */\n-static void\n-safe_fwrite (pfile, buf, len, fp)\n-     cpp_reader *pfile;\n-     const U_CHAR *buf;\n-     size_t len;\n-     FILE *fp;\n-{\n-  size_t count;\n-\n-  while (len)\n-    {\n-      count = fwrite (buf, 1, len, fp);\n-      if (count == 0)\n-\tgoto error;\n-      len -= count;\n-      buf += count;\n-    }\n-  return;\n-\n- error:\n-  cpp_notice_from_errno (pfile, CPP_OPTION (pfile, out_fname));\n-}\n-\n /* Notify the compiler proper that the current line number has jumped,\n    or the current file name has changed.  */\n \n@@ -294,51 +260,30 @@ output_line_command (pfile, print, line)\n      unsigned int line;\n {\n   cpp_buffer *ip = CPP_BUFFER (pfile);\n-  enum { same = 0, enter, leave, rname } change;\n-  static const char * const codes[] = { \"\", \" 1\", \" 2\", \"\" };\n \n   if (line == 0)\n     return;\n \n   /* End the previous line of text.  */\n   if (pfile->need_newline)\n-    putc ('\\n', print->outf);\n+    {\n+      putc ('\\n', print->outf);\n+      print->lineno++;\n+    }\n   pfile->need_newline = 0;\n \n   if (CPP_OPTION (pfile, no_line_commands))\n     return;\n \n-  /* If ip is null, we've been called from cpp_finish, and they just\n-     needed the final flush and trailing newline.  */\n-  if (!ip)\n-    return;\n-\n-  if (pfile->include_depth == print->last_id)\n-    {\n-      /* Determine whether the current filename has changed, and if so,\n-\t how.  'nominal_fname' values are unique, so they can be compared\n-\t by comparing pointers.  */\n-      if (ip->nominal_fname == print->last_fname)\n-\tchange = same;\n-      else\n-\tchange = rname;\n-    }\n-  else\n-    {\n-      if (pfile->include_depth > print->last_id)\n-\tchange = enter;\n-      else\n-\tchange = leave;\n-      print->last_id = pfile->include_depth;\n-    }\n-  print->last_fname = ip->nominal_fname;\n-\n   /* If the current file has not changed, we can output a few newlines\n      instead if we want to increase the line number by a small amount.\n      We cannot do this if print->lineno is zero, because that means we\n      haven't output any line commands yet.  (The very first line\n-     command output is a `same_file' command.)  */\n-  if (change == same && print->lineno > 0\n+     command output is a `same_file' command.)\n+\n+     'nominal_fname' values are unique, so they can be compared by\n+     comparing pointers.  */\n+  if (ip->nominal_fname == print->last_fname && print->lineno > 0\n       && line >= print->lineno && line < print->lineno + 8)\n     {\n       while (line > print->lineno)\n@@ -349,41 +294,41 @@ output_line_command (pfile, print, line)\n       return;\n     }\n \n-#ifndef NO_IMPLICIT_EXTERN_C\n-  if (CPP_OPTION (pfile, cplusplus))\n-    fprintf (print->outf, \"# %u \\\"%s\\\"%s%s%s\\n\", line, ip->nominal_fname,\n-\t     codes[change],\n-\t     ip->inc->sysp ? \" 3\" : \"\",\n-\t     (ip->inc->sysp == 2) ? \" 4\" : \"\");\n-  else\n-#endif\n-    fprintf (print->outf, \"# %u \\\"%s\\\"%s%s\\n\", line, ip->nominal_fname,\n-\t     codes[change],\n-\t     ip->inc->sysp ? \" 3\" : \"\");\n+  fprintf (print->outf, \"# %u \\\"%s\\\"%s\\n\", line, ip->nominal_fname,\n+\t   cpp_syshdr_flags (pfile, ip));\n+\n+  print->last_fname = ip->nominal_fname;\n   print->lineno = line;\n }\n \n-/* Write the contents of the token_buffer to the output stream, and\n-   clear the token_buffer.  Also handles generating line commands and\n-   keeping track of file transitions.  */\n-\n+/* Like fprintf, but writes to a printer object.  You should be sure\n+   always to generate a complete line when you use this function.  */\n void\n-cpp_output_tokens (pfile, print, line)\n-     cpp_reader *pfile;\n-     cpp_printer *print;\n-     unsigned int line;\n-{\n-  if (CPP_WRITTEN (pfile) - print->written)\n-    {\n-      safe_fwrite (pfile, pfile->token_buffer,\n-\t\t   CPP_WRITTEN (pfile) - print->written, print->outf);\n-      pfile->need_newline = 1;\n-      if (print->lineno)\n-\tprint->lineno++;\n+cpp_printf VPARAMS ((cpp_reader *pfile, cpp_printer *print,\n+\t\t     const char *fmt, ...))\n+{\n+  va_list ap;\n+#ifndef ANSI_PROTOTYPES\n+  cpp_reader *pfile;\n+  cpp_printer *print;\n+  const char *fmt;\n+#endif\n \n-      CPP_SET_WRITTEN (pfile, print->written);\n-    }\n-  output_line_command (pfile, print, line);\n+  VA_START (ap, fmt);\n+\n+#ifndef ANSI_PROTOTYPES\n+  pfile = va_arg (ap, cpp_reader *);\n+  print = va_arg (ap, cpp_printer *);\n+  fmt = va_arg (ap, const char *);\n+#endif\n+\n+  /* End the previous line of text.  */\n+  if (pfile->need_newline)\n+    putc ('\\n', print->outf);\n+  pfile->need_newline = 0;\n+\n+  vfprintf (print->outf, fmt, ap);\n+  va_end (ap);\n }\n \n /* Scan until CPP_BUFFER (PFILE) is exhausted, discarding output.  */\n@@ -434,9 +379,6 @@ cpp_scan_buffer (pfile, print)\n \t{\n \t  cpp_pop_buffer (pfile);\n \n-\t  if (CPP_BUFFER (pfile))\n-\t    cpp_output_tokens (pfile, print, CPP_BUF_LINE (CPP_BUFFER (pfile)));\n-\n \t  if (CPP_BUFFER (pfile) == stop)\n \t    return;\n \n@@ -452,48 +394,18 @@ cpp_scan_buffer (pfile, print)\n \t      continue;\n \t    }\n \n-\t  cpp_output_tokens (pfile, print, pfile->token_list.line);\n+\t  output_line_command (pfile, print, pfile->token_list.line);\n \t  prev = 0;\n \t}\n \n       if (token->type != CPP_PLACEMARKER)\n-\toutput_token (pfile, token, prev);\n-\n-      prev = token;\n-    }\n-}\n-\n-/* Scan a single line of the input into the token_buffer.  */\n-int\n-cpp_scan_line (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *token, *prev = 0;\n-\n-  if (pfile->buffer == NULL)\n-    return 0;\n-\n-  do\n-    {\n-      token = cpp_get_token (pfile);\n-      if (token->type == CPP_EOF)\n \t{\n-\t  cpp_pop_buffer (pfile);\n-\t  break;\n+\t  output_token (pfile, print->outf, token, prev, 1);\n+\t  pfile->need_newline = 1;\n \t}\n \n-      /* If the last token on a line results from a macro expansion,\n-\t the check below will fail to stop us from proceeding to the\n-\t next line - so make sure we stick in a newline, at least.  */\n-      if (token->flags & BOL)\n-\tCPP_PUTC (pfile, '\\n');\n-\n-      output_token (pfile, token, prev);\n       prev = token;\n     }\n-  while (pfile->cur_context > 0\n-\t || pfile->contexts[0].posn < pfile->contexts[0].count);\n-  return 1;\n }\n \n /* Helper routine used by parse_include, which can't see spell_token.\n@@ -503,31 +415,38 @@ const cpp_token *\n _cpp_glue_header_name (pfile)\n      cpp_reader *pfile;\n {\n-  unsigned int written = CPP_WRITTEN (pfile);\n   const cpp_token *t;\n   cpp_token *hdr;\n-  U_CHAR *buf;\n-  size_t len;\n+  U_CHAR *buf, *p;\n+  size_t len, avail;\n+\n+  avail = 40;\n+  len = 0;\n+  buf = xmalloc (avail);\n \n   for (;;)\n     {\n       t = _cpp_get_token (pfile);\n       if (t->type == CPP_GREATER || t->type == CPP_EOF)\n \tbreak;\n \n-      CPP_RESERVE (pfile, TOKEN_LEN (t));\n+      if (len + TOKEN_LEN (t) > avail)\n+\t{\n+\t  avail = len + TOKEN_LEN (t) + 40;\n+\t  buf = xrealloc (buf, avail);\n+\t}\n+\n       if (t->flags & PREV_WHITE)\n-\tCPP_PUTC_Q (pfile, ' ');\n-      pfile->limit = spell_token (pfile, t, pfile->limit);\n+\tbuf[len++] = ' ';\n+\n+      p = spell_token (pfile, t, buf + len);\n+      len = (size_t) (p - buf);  /* p known >= buf */\n     }\n \n   if (t->type == CPP_EOF)\n     cpp_error (pfile, \"missing terminating > character\");\n \n-  len = CPP_WRITTEN (pfile) - written;\n-  buf = xmalloc (len);\n-  memcpy (buf, pfile->token_buffer + written, len);\n-  CPP_SET_WRITTEN (pfile, written);\n+  buf = xrealloc (buf, len);\n \n   hdr = get_temp_token (pfile);\n   hdr->type = CPP_HEADER_NAME;\n@@ -1894,51 +1813,150 @@ lex_line (pfile, list)\n }\n \n /* Write the spelling of a token TOKEN, with any appropriate\n-   whitespace before it, to the token_buffer.  PREV is the previous\n-   token, which is used to determine if we need to shove in an extra\n-   space in order to avoid accidental token paste.  */\n+   whitespace before it, to FP.  PREV is the previous token, which\n+   is used to determine if we need to shove in an extra space in order\n+   to avoid accidental token paste.  If WHITE is 0, do not insert any\n+   leading whitespace.  */\n static void\n-output_token (pfile, token, prev)\n+output_token (pfile, fp, token, prev, white)\n      cpp_reader *pfile;\n+     FILE *fp;\n      const cpp_token *token, *prev;\n+     int white;\n {\n-  int dummy;\n-\n-  if (token->col && (token->flags & BOL))\n+  if (white)\n     {\n-      /* Supply enough whitespace to put this token in its original\n-\t column.  Don't bother trying to reconstruct tabs; we can't\n-\t get it right in general, and nothing ought to care.  (Yes,\n-\t some things do care; the fault lies with them.)  */\n-      unsigned char *buffer;\n-      unsigned int spaces = token->col - 1;\n-\n-      CPP_RESERVE (pfile, token->col);\n-      buffer = pfile->limit;\n-\n-      while (spaces--)\n-\t*buffer++ = ' ';\n-      pfile->limit = buffer;\n+      int dummy;\n+\n+      if (token->col && (token->flags & BOL))\n+\t{\n+\t  /* Supply enough whitespace to put this token in its original\n+\t     column.  Don't bother trying to reconstruct tabs; we can't\n+\t     get it right in general, and nothing ought to care.  (Yes,\n+\t     some things do care; the fault lies with them.)  */\n+\t  unsigned int spaces = token->col - 1;\n+      \n+\t  while (spaces--)\n+\t    putc (' ', fp);\n+\t}\n+      else if (token->flags & PREV_WHITE)\n+\tputc (' ', fp);\n+      else\n+      /* Check for and prevent accidental token pasting.\n+\t In addition to the cases handled by can_paste, consider\n+\n+\t a + ++b - if there is not a space between the + and ++, it\n+\t will be misparsed as a++ + b.  But + ## ++ doesn't produce\n+\t a valid token.  */\n+\tif (prev\n+\t    && (can_paste (pfile, prev, token, &dummy) != CPP_EOF\n+\t\t|| (prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n+\t\t|| (prev->type == CPP_MINUS && token->type == CPP_MINUS_MINUS)))\n+\tputc (' ', fp);\n     }\n-  else if (token->flags & PREV_WHITE)\n-    CPP_PUTC (pfile, ' ');\n-  else if (prev)\n+\n+  switch (TOKEN_SPELL (token))\n     {\n-      /* Check for and prevent accidental token pasting.  */\n-      if (can_paste (pfile, prev, token, &dummy) != CPP_EOF)\n-\tCPP_PUTC (pfile, ' ');\n-      /* can_paste doesn't catch all the accidental pastes.\n-\t Consider a + ++b - if there is not a space between the + and ++, it\n-\t will be misparsed as a++ + b.  */\n-      else if ((prev->type == CPP_PLUS && token->type == CPP_PLUS_PLUS)\n-\t       || (prev->type == CPP_MINUS && token->type == CPP_MINUS_MINUS))\n-\tCPP_PUTC (pfile, ' ');\n+    case SPELL_OPERATOR:\n+      {\n+\tconst unsigned char *spelling;\n+\n+\tif (token->flags & DIGRAPH)\n+\t  spelling = digraph_spellings[token->type - CPP_FIRST_DIGRAPH];\n+\telse if (token->flags & NAMED_OP)\n+\t  goto spell_ident;\n+\telse\n+\t  spelling = TOKEN_NAME (token);\n+\n+\tufputs (spelling, fp);\n+      }\n+      break;\n+\n+    case SPELL_IDENT:\n+      spell_ident:\n+      ufputs (token->val.node->name, fp);\n+      break;\n+\n+    case SPELL_STRING:\n+      {\n+\tif (token->type == CPP_WSTRING || token->type == CPP_WCHAR)\n+\t  putc ('L', fp);\n+\n+\tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n+\t  putc ('\"', fp);\n+\tif (token->type == CPP_CHAR || token->type == CPP_WCHAR)\n+\t  putc ('\\'', fp);\n+\n+\tfwrite (token->val.str.text, 1, token->val.str.len, fp);\n+\t\n+\tif (token->type == CPP_STRING || token->type == CPP_WSTRING)\n+\t  putc ('\"', fp);\n+\tif (token->type == CPP_CHAR || token->type == CPP_WCHAR)\n+\t  putc ('\\'', fp);\n+      }\n+      break;\n+\n+    case SPELL_CHAR:\n+      putc (token->val.aux, fp);\n+      break;\n+\n+    case SPELL_NONE:\n+      /* Placemarker or EOF - no output.  (Macro args are handled\n+         elsewhere.  */\n+      break;\n     }\n+}\n+\n+/* Dump the original user's spelling of argument index ARG_NO to the\n+   macro whose expansion is LIST.  */\n+static void\n+dump_param_spelling (fp, list, arg_no)\n+     FILE *fp;\n+     const cpp_toklist *list;\n+     unsigned int arg_no;\n+{\n+  const U_CHAR *param = list->namebuf;\n+\n+  while (arg_no--)\n+    param += ustrlen (param) + 1;\n+  ufputs (param, fp);\n+}\n+\n+/* Output all the tokens of LIST, starting at TOKEN, to FP.  */\n+void\n+cpp_output_list (pfile, fp, list, token)\n+     cpp_reader *pfile;\n+     FILE *fp;\n+     const cpp_toklist *list;\n+     const cpp_token *token;\n+{\n+  const cpp_token *limit = list->tokens + list->tokens_used;\n+  const cpp_token *prev = 0;\n+  int white = 0;\n \n-  CPP_RESERVE (pfile, TOKEN_LEN (token));\n-  pfile->limit = spell_token (pfile, token, pfile->limit);\n+  while (token < limit)\n+    {\n+      /* XXX Find some way we can write macro args from inside\n+\t output_token/spell_token.  */\n+      if (token->type == CPP_MACRO_ARG)\n+\t{\n+\t  if (white && token->flags & PREV_WHITE)\n+\t    putc (' ', fp);\n+\t  if (token->flags & STRINGIFY_ARG)\n+\t    putc ('#', fp);\n+\t  dump_param_spelling (fp, list, token->val.aux);\n+\t}\n+      else\n+\toutput_token (pfile, fp, token, prev, white);\n+      if (token->flags & PASTE_LEFT)\n+\tfputs (\" ##\", fp);\n+      prev = token;\n+      token++;\n+      white = 1;\n+    }\n }\n \n+\n /* Write the spelling of a token TOKEN to BUFFER.  The buffer must\n    already contain the enough space to hold the token's spelling.\n    Returns a pointer to the character after the last character\n@@ -3033,12 +3051,6 @@ process_directive (pfile, token)\n   else if (token[1].type != CPP_NUMBER)\n     cpp_ice (pfile, \"directive begins with %s?!\", TOKEN_NAME (token));\n \n-  /* Flush pending tokens at this point, in case the directive produces\n-     output.  XXX Directive output won't be visible to a direct caller of\n-     cpp_get_token.  */\n-  if (pfile->printer && CPP_WRITTEN (pfile) - pfile->printer->written)\n-    cpp_output_tokens (pfile, pfile->printer, pfile->token_list.line);\n-\n   if (! (d->flags & EXPAND))\n     prev_nme = prevent_macro_expansion (pfile);\n   (void) (*d->handler) (pfile);\n@@ -3464,58 +3476,6 @@ special_symbol (pfile, node, token)\n }\n #undef DSC\n \n-/* Dump the original user's spelling of argument index ARG_NO to the\n-   macro whose expansion is LIST.  */\n-static void\n-dump_param_spelling (pfile, list, arg_no)\n-     cpp_reader *pfile;\n-     const cpp_toklist *list;\n-     unsigned int arg_no;\n-{\n-  const U_CHAR *param = list->namebuf;\n-\n-  while (arg_no--)\n-    param += ustrlen (param) + 1;\n-  CPP_PUTS (pfile, param, ustrlen (param));\n-}\n-\n-/* Dump a token list to the output.  */\n-void\n-_cpp_dump_list (pfile, list, token, flush)\n-     cpp_reader *pfile;\n-     const cpp_toklist *list;\n-     const cpp_token *token;\n-     int flush;\n-{\n-  const cpp_token *limit = list->tokens + list->tokens_used;\n-  const cpp_token *prev = 0;\n-\n-  /* Avoid the CPP_EOF.  */\n-  if (list->directive)\n-    limit--;\n-\n-  while (token < limit)\n-    {\n-      if (token->type == CPP_MACRO_ARG)\n-\t{\n-\t  if (token->flags & PREV_WHITE)\n-\t    CPP_PUTC (pfile, ' ');\n-\t  if (token->flags & STRINGIFY_ARG)\n-\t    CPP_PUTC (pfile, '#');\n-\t  dump_param_spelling (pfile, list, token->val.aux);\n-\t}\n-      else if (token->type != CPP_PLACEMARKER)\n-\toutput_token (pfile, token, prev);\n-      if (token->flags & PASTE_LEFT)\n-\tCPP_PUTS (pfile, \" ##\", 3);\n-      prev = token;\n-      token++;\n-    }\n-\n-  if (flush && pfile->printer)\n-    cpp_output_tokens (pfile, pfile->printer, pfile->token_list.line);\n-}\n-\n /* Allocate pfile->input_buffer, and initialize trigraph_map[]\n    if it hasn't happened already.  */\n "}, {"sha": "ade5ee3a621631106870b4a19cc3ae6facdabdf1", "filename": "gcc/cpplib.c", "status": "modified", "additions": 174, "deletions": 186, "changes": 360, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplib.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplib.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -49,7 +49,6 @@ static int  parse_include\tPARAMS ((cpp_reader *, const U_CHAR *, int,\n \t\t\t\t\t int *));\n static void push_conditional\tPARAMS ((cpp_reader *, int, int,\n \t\t\t\t\t const cpp_hashnode *));\n-static void pass_thru_directive\tPARAMS ((cpp_reader *));\n static int  read_line_number\tPARAMS ((cpp_reader *, int *));\n static int  strtoul_for_line\tPARAMS ((const U_CHAR *, unsigned int,\n \t\t\t\t\t unsigned long *));\n@@ -60,7 +59,6 @@ static const cpp_hashnode *\n \t    detect_if_not_defined PARAMS ((cpp_reader *));\n static cpp_hashnode *\n \t    get_define_node\tPARAMS ((cpp_reader *));\n-static void dump_macro_name \tPARAMS ((cpp_reader *, cpp_hashnode *));\n static void unwind_if_stack\tPARAMS ((cpp_reader *, cpp_buffer *));\n \n /* Utility.  */\n@@ -214,29 +212,6 @@ _cpp_check_linemarker (pfile, token, bol)\n   return &dtable[T_LINE];\n }  \n \n-static void\n-dump_macro_name (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n-{\n-  CPP_PUTS (pfile, \"#define \", sizeof \"#define \" - 1);\n-  CPP_PUTS (pfile, node->name, node->length);\n-}\n-\n-/* Pass the current directive through to the output file.  */\n-static void\n-pass_thru_directive (pfile)\n-     cpp_reader *pfile;\n-{\n-  /* XXX This output may be genuinely needed even when there is no\n-     printer.  */\n-  if (! pfile->printer)\n-    return;\n-  /* Flush first (temporary).  */\n-  cpp_output_tokens (pfile, pfile->printer, pfile->token_list.line);\n-  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 1);\n-}\n-\n static cpp_hashnode *\n get_define_node (pfile)\n      cpp_reader *pfile;\n@@ -288,13 +263,8 @@ do_define (pfile)\n \n   if ((node = get_define_node (pfile)))\n     if (_cpp_create_definition (pfile, node))\n-      {\n-\tif (CPP_OPTION (pfile, debug_output)\n-\t    || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n-\t  _cpp_dump_definition (pfile, node);\n-\telse if (CPP_OPTION (pfile, dump_macros) == dump_names)\n-\t  dump_macro_name (pfile, node);\n-      }\n+      if (pfile->cb.define)\n+\t(*pfile->cb.define) (pfile, node);\n }\n \n /* Remove the definition of a symbol from the symbol table.  */\n@@ -311,12 +281,8 @@ do_undef (pfile)\n      is not currently defined as a macro name.  */\n   if (node && node->type != T_VOID)\n     {\n-      /* If we are generating additional info for debugging (with -g) we\n-\t need to pass through all effective #undef commands.  */\n-      if (CPP_OPTION (pfile, debug_output)\n-\t  || CPP_OPTION (pfile, dump_macros) == dump_definitions\n-\t  || CPP_OPTION (pfile, dump_macros) == dump_names)\n-\tpass_thru_directive (pfile);\n+      if (pfile->cb.undef)\n+\t(*pfile->cb.undef) (pfile, node);\n \n       if (node->type != T_MACRO)\n \tcpp_warning (pfile, \"undefining \\\"%s\\\"\", node->name);\n@@ -362,6 +328,9 @@ parse_include (pfile, dir, trail, strp, lenp, abp)\n   *lenp = name->val.str.len;\n   *strp = name->val.str.text;\n   *abp = (name->type == CPP_HEADER_NAME);\n+\n+  if (pfile->cb.include)\n+    (*pfile->cb.include) (pfile, dir, *strp, *lenp, *abp);\n   return 0;\n }\n \n@@ -377,8 +346,6 @@ do_include (pfile)\n     return;\n \n   _cpp_execute_include (pfile, str, len, 0, 0, ab);\n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (pfile);\n }\n \n static void\n@@ -401,8 +368,6 @@ do_import (pfile)\n     return;\n \n   _cpp_execute_include (pfile, str, len, 1, 0, ab);\n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (pfile);\n }\n \n static void\n@@ -436,8 +401,6 @@ do_include_next (pfile)\n     cpp_warning (pfile, \"#include_next in primary source file\");\n \n   _cpp_execute_include (pfile, str, len, 0, search_start, ab);\n-  if (CPP_OPTION (pfile, dump_includes))\n-    pass_thru_directive (pfile);\n }\n \n /* Subroutine of do_line.  Read next token from PFILE without adding it to\n@@ -504,6 +467,7 @@ do_line (pfile)\n   /* C99 raised the minimum limit on #line numbers.  */\n   unsigned int cap = CPP_OPTION (pfile, c99) ? 2147483647 : 32767;\n   int action_number = 0;\n+  int enter = 0, leave = 0;\n   enum cpp_ttype type;\n   const U_CHAR *str;\n   char *fname;\n@@ -558,18 +522,15 @@ do_line (pfile)\n   if (CPP_PEDANTIC (pfile))\n     cpp_pedwarn (pfile, \"garbage at end of #line\");\n \n-  /* This is somewhat questionable: change the buffer stack\n-     depth so that output_line_command thinks we've stacked\n-     another buffer. */\n   if (action_number == 1)\n     {\n-      pfile->buffer_stack_depth++;\n+      enter = 1;\n       cpp_make_system_header (pfile, ip, 0);\n       read_line_number (pfile, &action_number);\n     }\n   else if (action_number == 2)\n     {\n-      pfile->buffer_stack_depth--;\n+      leave = 1;\n       cpp_make_system_header (pfile, ip, 0);\n       read_line_number (pfile, &action_number);\n     }\n@@ -584,6 +545,11 @@ do_line (pfile)\n       read_line_number (pfile, &action_number);\n     }\n \n+  if (enter && pfile->cb.enter_file)\n+    (*pfile->cb.enter_file) (pfile);\n+  if (leave && pfile->cb.leave_file)\n+    (*pfile->cb.leave_file) (pfile);\n+\n  done:\n   return;\n }\n@@ -598,13 +564,12 @@ static void\n do_error (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *text, *limit;\n-\n-  text = pfile->limit;\n-  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 0);\n-  limit = pfile->limit;\n-  pfile->limit = text;\n-  cpp_error (pfile, \"%.*s\", (int)(limit - text), text);\n+  if (_cpp_begin_message (pfile, ERROR, NULL, 0, 0))\n+    {\n+      cpp_output_list (pfile, stderr, &pfile->token_list,\n+\t\t       pfile->first_directive_token);\n+      putc ('\\n', stderr);\n+    }\n }\n \n /*\n@@ -616,13 +581,12 @@ static void\n do_warning (pfile)\n      cpp_reader *pfile;\n {\n-  U_CHAR *text, *limit;\n-\n-  text = pfile->limit;\n-  _cpp_dump_list (pfile, &pfile->token_list, pfile->first_directive_token, 0);\n-  limit = pfile->limit;\n-  pfile->limit = text;\n-  cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n+  if (_cpp_begin_message (pfile, WARNING, NULL, 0, 0))\n+    {\n+      cpp_output_list (pfile, stderr, &pfile->token_list,\n+\t\t       pfile->first_directive_token);\n+      putc ('\\n', stderr);\n+    }\n }\n \n /* Report program identification.  */\n@@ -631,15 +595,14 @@ static void\n do_ident (pfile)\n      cpp_reader *pfile;\n {\n-  /* Next token should be a string constant.  */\n-  if (_cpp_get_token (pfile)->type == CPP_STRING)\n-    /* And then a newline.  */\n-    if (_cpp_get_token (pfile)->type == CPP_EOF)\n-      {\n-\t/* Good - ship it.  */\n-\tpass_thru_directive (pfile);\n-\treturn;\n-      }\n+  const cpp_token *str = _cpp_get_token (pfile);\n+\n+  if (str->type == CPP_STRING && _cpp_get_token (pfile)->type == CPP_EOF)\n+    {\n+      if (pfile->cb.ident)\n+\t(*pfile->cb.ident) (pfile, str);\n+      return;\n+    }\n \n   cpp_error (pfile, \"invalid #ident\");\n }\n@@ -659,88 +622,154 @@ do_ident (pfile)\n    They return 1 if the token buffer is to be popped, 0 if not. */\n struct pragma_entry\n {\n+  struct pragma_entry *next;\n   const char *name;\n-  int (*handler) PARAMS ((cpp_reader *));\n+  size_t len;\n+  int isnspace;\n+  union {\n+    void (*handler) PARAMS ((cpp_reader *));\n+    struct pragma_entry *space;\n+  } u;\n };\n \n-static int pragma_dispatch             \n-    PARAMS ((cpp_reader *, const struct pragma_entry *, const cpp_hashnode *));\n-static int do_pragma_once\t\tPARAMS ((cpp_reader *));\n-static int do_pragma_implementation\tPARAMS ((cpp_reader *));\n-static int do_pragma_poison\t\tPARAMS ((cpp_reader *));\n-static int do_pragma_system_header\tPARAMS ((cpp_reader *));\n-static int do_pragma_gcc                PARAMS ((cpp_reader *));\n-static int do_pragma_dependency         PARAMS ((cpp_reader *));\n-\n-static const struct pragma_entry top_pragmas[] =\n+void\n+cpp_register_pragma (pfile, space, name, handler)\n+     cpp_reader *pfile;\n+     const char *space;\n+     const char *name;\n+     void (*handler) PARAMS ((cpp_reader *));\n {\n-  {\"once\", do_pragma_once},\n-  {\"implementation\", do_pragma_implementation},\n-  {\"poison\", do_pragma_poison},\n-  {\"GCC\", do_pragma_gcc},\n-  {NULL, NULL}\n-};\n+  struct pragma_entry **x, *new;\n+  size_t len;\n \n-static const struct pragma_entry gcc_pragmas[] =\n-{\n-  {\"implementation\", do_pragma_implementation},\n-  {\"poison\", do_pragma_poison},\n-  {\"system_header\", do_pragma_system_header},\n-  {\"dependency\", do_pragma_dependency},\n-  {NULL, NULL}\n-};\n+  x = &pfile->pragmas;\n+  if (space)\n+    {\n+      struct pragma_entry *p = pfile->pragmas;\n+      len = strlen (space);\n+      while (p)\n+\t{\n+\t  if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n+\t    {\n+\t      x = &p->u.space;\n+\t      goto found;\n+\t    }\n+\t  p = p->next;\n+\t}\n+      cpp_ice (pfile, \"unknown #pragma namespace %s\", space);\n+      return;\n+    }\n+\n+ found:\n+  new = xnew (struct pragma_entry);\n+  new->name = name;\n+  new->len = strlen (name);\n+  new->isnspace = 0;\n+  new->u.handler = handler;\n+\n+  new->next = *x;\n+  *x = new;\n+}\n \n-static int pragma_dispatch (pfile, table, node)\n+void\n+cpp_register_pragma_space (pfile, space)\n      cpp_reader *pfile;\n-     const struct pragma_entry *table;\n-     const cpp_hashnode *node;\n+     const char *space;\n {\n-  const U_CHAR *p = node->name;\n-  size_t len = node->length;\n+  struct pragma_entry *new;\n+  const struct pragma_entry *p = pfile->pragmas;\n+  size_t len = strlen (space);\n+\n+  while (p)\n+    {\n+      if (p->isnspace && p->len == len && !memcmp (p->name, space, len))\n+\t{\n+\t  cpp_ice (pfile, \"#pragma namespace %s already registered\", space);\n+\t  return;\n+\t}\n+      p = p->next;\n+    }\n+\n+  new = xnew (struct pragma_entry);\n+  new->name = space;\n+  new->len = len;\n+  new->isnspace = 1;\n+  new->u.space = 0;\n+\n+  new->next = pfile->pragmas;\n+  pfile->pragmas = new;\n+}\n   \n-  for (; table->name; table++)\n-    if (strlen (table->name) == len && !memcmp (p, table->name, len))\n-      return (*table->handler) (pfile);\n-  return 0;\n+static void do_pragma_once\t\tPARAMS ((cpp_reader *));\n+static void do_pragma_poison\t\tPARAMS ((cpp_reader *));\n+static void do_pragma_system_header\tPARAMS ((cpp_reader *));\n+static void do_pragma_dependency\tPARAMS ((cpp_reader *));\n+\n+void\n+_cpp_init_internal_pragmas (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* top level */\n+  cpp_register_pragma (pfile, 0, \"poison\", do_pragma_poison);\n+  cpp_register_pragma (pfile, 0, \"once\", do_pragma_once);\n+\n+  /* GCC namespace */\n+  cpp_register_pragma_space (pfile, \"GCC\");\n+\n+  cpp_register_pragma (pfile, \"GCC\", \"poison\", do_pragma_poison);\n+  cpp_register_pragma (pfile, \"GCC\", \"system_header\", do_pragma_system_header);\n+  cpp_register_pragma (pfile, \"GCC\", \"dependency\", do_pragma_dependency);\n }\n \n static void\n do_pragma (pfile)\n      cpp_reader *pfile;\n {\n+  const struct pragma_entry *p;\n   const cpp_token *tok;\n-  int pop;\n+  const cpp_hashnode *node;\n+  const U_CHAR *name;\n+  size_t len;\n \n+  p = pfile->pragmas;\n+\n+ new_space:\n   tok = _cpp_get_token (pfile);\n   if (tok->type == CPP_EOF)\n     return;\n-  else if (tok->type != CPP_NAME)\n+\n+  if (tok->type != CPP_NAME)\n     {\n       cpp_error (pfile, \"malformed #pragma directive\");\n       return;\n     }\n \n-  pop = pragma_dispatch (pfile, top_pragmas, tok->val.node);\n-  if (!pop)\n-    pass_thru_directive (pfile);\n-}\n-\n-static int\n-do_pragma_gcc (pfile)\n-     cpp_reader *pfile;\n-{\n-  const cpp_token *tok;\n+  node = tok->val.node;\n+  name = node->name;\n+  len = node->length;\n+  while (p)\n+    {\n+      if (strlen (p->name) == len && !memcmp (p->name, name, len))\n+\t{\n+\t  if (p->isnspace)\n+\t    {\n+\t      p = p->u.space;\n+\t      goto new_space;\n+\t    }\n+\t  else\n+\t    {\n+\t      (*p->u.handler) (pfile);\n+\t      return;\n+\t    }\n+\t}\n+      p = p->next;\n+    }\n \n-  tok = _cpp_get_token (pfile);\n-  if (tok->type == CPP_EOF)\n-    return 1;\n-  else if (tok->type != CPP_NAME)\n-    return 0;\n-  \n-  return pragma_dispatch (pfile, gcc_pragmas, tok->val.node);\n+  if (pfile->cb.def_pragma)\n+    (*pfile->cb.def_pragma) (pfile);\n }\n \n-static int\n+static void\n do_pragma_once (pfile)\n      cpp_reader *pfile;\n {\n@@ -755,55 +784,16 @@ do_pragma_once (pfile)\n     cpp_warning (pfile, \"#pragma once outside include file\");\n   else\n     ip->inc->cmacro = NEVER_REREAD;\n-\n-  return 1;\n }\n \n-static int\n-do_pragma_implementation (pfile)\n-     cpp_reader *pfile;\n-{\n-  /* Be quiet about `#pragma implementation' for a file only if it hasn't\n-     been included yet.  */\n-  const cpp_token *tok = _cpp_get_token (pfile);\n-  char *copy;\n-\n-  if (tok->type == CPP_EOF)\n-    return 0;\n-  else if (tok->type != CPP_STRING\n-\t   || _cpp_get_token (pfile)->type != CPP_EOF)\n-    {\n-      cpp_error (pfile, \"malformed #pragma implementation\");\n-      return 1;\n-    }\n-\n-  /* Make a NUL-terminated copy of the string.  */\n-  copy = alloca (tok->val.str.len + 1);\n-  memcpy (copy, tok->val.str.text, tok->val.str.len);\n-  copy[tok->val.str.len] = '\\0';\n-  \n-  if (cpp_included (pfile, copy))\n-    cpp_warning (pfile,\n-\t \"#pragma implementation for %s appears after file is included\",\n-\t\t copy);\n-  return 0;\n-}\n-\n-static int\n+static void\n do_pragma_poison (pfile)\n      cpp_reader *pfile;\n {\n   /* Poison these symbols so that all subsequent usage produces an\n      error message.  */\n   const cpp_token *tok;\n   cpp_hashnode *hp;\n-  int writeit;\n-\n-  /* As a rule, don't include #pragma poison commands in output,  \n-     unless the user asks for them.  */\n-  writeit = (CPP_OPTION (pfile, debug_output)\n-\t     || CPP_OPTION (pfile, dump_macros) == dump_definitions\n-\t     || CPP_OPTION (pfile, dump_macros) == dump_names);\n \n   for (;;)\n     {\n@@ -813,7 +803,7 @@ do_pragma_poison (pfile)\n       if (tok->type != CPP_NAME)\n \t{\n \t  cpp_error (pfile, \"invalid #pragma poison directive\");\n-\t  return 1;\n+\t  return;\n \t}\n \n       hp = tok->val.node;\n@@ -827,7 +817,9 @@ do_pragma_poison (pfile)\n \t  hp->type = T_POISON;\n \t}\n     }\n-  return !writeit;\n+\n+  if (pfile->cb.poison)\n+    (*pfile->cb.poison) (pfile);\n }\n \n /* Mark the current header as a system header.  This will suppress\n@@ -836,7 +828,7 @@ do_pragma_poison (pfile)\n    conforming C, but cannot be certain that their headers appear in a\n    system include directory.  To prevent abuse, it is rejected in the\n    primary source file.  */\n-static int\n+static void\n do_pragma_system_header (pfile)\n      cpp_reader *pfile;\n {\n@@ -845,14 +837,12 @@ do_pragma_system_header (pfile)\n     cpp_warning (pfile, \"#pragma system_header outside include file\");\n   else\n     cpp_make_system_header (pfile, ip, 1);\n-\n-  return 1;\n }\n \n /* Check the modified date of the current include file against a specified\n    file. Issue a diagnostic, if the specified file is newer. We use this to\n    determine if a fixed header should be refixed.  */\n-static int\n+static void\n do_pragma_dependency (pfile)\n      cpp_reader *pfile;\n {\n@@ -862,7 +852,7 @@ do_pragma_dependency (pfile)\n   char left, right;\n  \n   if (parse_include (pfile, U\"pragma dependency\", 1, &name, &len, &ab))\n-    return 1;\n+    return;\n \n   left = ab ? '<' : '\"';\n   right = ab ? '>' : '\"';\n@@ -876,21 +866,13 @@ do_pragma_dependency (pfile)\n       \n       cpp_warning (pfile, \"current file is older than %c%.*s%c\",\n \t\t   left, (int)len, name, right);\n-      if (msg->type != CPP_EOF)\n+      if (msg->type != CPP_EOF\n+\t  && _cpp_begin_message (pfile, WARNING, NULL, msg->line, msg->col))\n \t{\n-\t  U_CHAR *text, *limit;\n-\n-\t  text = pfile->limit;\n-\t  _cpp_dump_list (pfile, &pfile->token_list, msg, 0);\n-\t  limit = pfile->limit;\n-\t  pfile->limit = text;\n-\t  /* There must be something non-whitespace after. */\n-\t  while (*text == ' ')\n-\t    text++; \n-\t  cpp_warning (pfile, \"%.*s\", (int)(limit - text), text);\n+\t  cpp_output_list (pfile, stderr, &pfile->token_list, msg);\n+\t  putc ('\\n', stderr);\n \t}\n     }\n-  return 1;\n }\n \n /* Just ignore #sccs, on systems where we define it at all.  */\n@@ -1513,15 +1495,21 @@ cpp_buffer *\n cpp_pop_buffer (pfile)\n      cpp_reader *pfile;\n {\n+  int wfb;\n   cpp_buffer *buf = CPP_BUFFER (pfile);\n \n   unwind_if_stack (pfile, buf);\n-  if (buf->inc)\n+  wfb = (buf->inc != 0);\n+  if (wfb)\n     _cpp_pop_file_buffer (pfile, buf);\n \n   CPP_BUFFER (pfile) = CPP_PREV_BUFFER (buf);\n   obstack_free (pfile->buffer_ob, buf);\n   pfile->buffer_stack_depth--;\n+\n+  if (wfb && pfile->cb.leave_file && CPP_BUFFER (pfile))\n+    (*pfile->cb.leave_file) (pfile);\n+  \n   return CPP_BUFFER (pfile);\n }\n "}, {"sha": "20bea99a19ea457428efb31e5753aa0545a2cf42", "filename": "gcc/cpplib.h", "status": "modified", "additions": 33, "deletions": 21, "changes": 54, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplib.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcpplib.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcpplib.h?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -432,19 +432,9 @@ struct cpp_options\n \n struct cpp_reader\n {\n-  /* HACK FIXME.  Maybe make into cpp_printer printer later.  */\n-  cpp_printer *printer;\n-\n   /* Top of buffer stack.  */\n   cpp_buffer *buffer;\n \n-  /* A buffer used for both for cpp_get_token's output, and also internally. */\n-  unsigned char *token_buffer;\n-  /* Allocated size of token_buffer.  CPP_RESERVE allocates space.  */\n-  unsigned int token_buffer_size;\n-  /* End of the written part of token_buffer. */\n-  unsigned char *limit;\n-\n   /* Error counter for exit code */\n   unsigned int errors;\n \n@@ -523,6 +513,23 @@ struct cpp_reader\n      real stack.  See cpplib.c */\n   struct obstack *buffer_ob;\n \n+  /* Pragma table - dynamic, because a library user can add to the\n+     list of recognized pragmas.  */\n+  struct pragma_entry *pragmas;\n+\n+  /* Call backs.  */\n+  struct {\n+    void (*enter_file) PARAMS ((cpp_reader *));\n+    void (*leave_file) PARAMS ((cpp_reader *));\n+    void (*include) PARAMS ((cpp_reader *, const unsigned char *,\n+\t\t\t     const unsigned char *, unsigned int, int));\n+    void (*define) PARAMS ((cpp_reader *, cpp_hashnode *));\n+    void (*undef) PARAMS ((cpp_reader *, cpp_hashnode *));\n+    void (*poison) PARAMS ((cpp_reader *));\n+    void (*ident) PARAMS ((cpp_reader *, const cpp_token *));\n+    void (*def_pragma) PARAMS ((cpp_reader *));\n+  } cb;\n+\n   /* User visible options.  */\n   struct cpp_options opts;\n \n@@ -563,23 +570,13 @@ struct cpp_printer\n {\n   FILE *outf;\t\t\t/* stream to write to */\n   const char *last_fname;\t/* previous file name */\n-  unsigned int last_id;\t\t/* did we just push? */\n   unsigned int lineno;\t\t/* line currently being written */\n-  unsigned int written;\t\t/* low water mark in token buffer */\n };\n \n #define CPP_FATAL_LIMIT 1000\n /* True if we have seen a \"fatal\" error. */\n #define CPP_FATAL_ERRORS(READER) ((READER)->errors >= CPP_FATAL_LIMIT)\n \n-/* Macros for manipulating the token_buffer. */\n-\n-/* Number of characters currently in PFILE's output buffer. */\n-#define CPP_WRITTEN(PFILE) ((size_t)((PFILE)->limit - (PFILE)->token_buffer))\n-#define CPP_PWRITTEN(PFILE) ((PFILE)->limit)\n-#define CPP_ADJUST_WRITTEN(PFILE,DELTA) ((PFILE)->limit += (DELTA))\n-#define CPP_SET_WRITTEN(PFILE,N) ((PFILE)->limit = (PFILE)->token_buffer + (N))\n-\n #define CPP_OPTION(PFILE, OPTION) ((PFILE)->opts.OPTION)\n #define CPP_BUFFER(PFILE) ((PFILE)->buffer)\n #define CPP_BUF_LINE(BUF) ((BUF)->lineno)\n@@ -641,6 +638,12 @@ extern int cpp_handle_options PARAMS ((cpp_reader *, int, char **));\n extern int cpp_handle_option PARAMS ((cpp_reader *, int, char **));\n extern void cpp_reader_init PARAMS ((cpp_reader *));\n extern cpp_printer *cpp_printer_init PARAMS ((cpp_reader *, cpp_printer *));\n+\n+extern void cpp_register_pragma PARAMS ((cpp_reader *,\n+\t\t\t\t\t const char *, const char *,\n+\t\t\t\t\t void (*) PARAMS ((cpp_reader *))));\n+extern void cpp_register_pragma_space PARAMS ((cpp_reader *, const char *));\n+\n extern int cpp_start_read PARAMS ((cpp_reader *, cpp_printer *, const char *));\n extern void cpp_output_tokens PARAMS ((cpp_reader *, cpp_printer *,\n \t\t\t\t       unsigned int));\n@@ -695,21 +698,30 @@ extern cpp_buffer *cpp_push_buffer\tPARAMS ((cpp_reader *,\n extern cpp_buffer *cpp_pop_buffer\tPARAMS ((cpp_reader *));\n extern void cpp_scan_buffer\t\tPARAMS ((cpp_reader *, cpp_printer *));\n extern void cpp_scan_buffer_nooutput\tPARAMS ((cpp_reader *));\n-extern int cpp_scan_line\t\tPARAMS ((cpp_reader *));\n extern int cpp_ideq\t\t\tPARAMS ((const cpp_token *,\n \t\t\t\t\t\t const char *));\n+extern void cpp_printf\t\t\tPARAMS ((cpp_reader *, cpp_printer *,\n+\t\t\t\t\t\t const char *, ...));\n+\n+extern void cpp_output_list\t\tPARAMS ((cpp_reader *, FILE *,\n+\t\t\t\t\t\t const cpp_toklist *,\n+\t\t\t\t\t\t const cpp_token *));\n \n /* In cpphash.c */\n extern cpp_hashnode *cpp_lookup\tPARAMS ((cpp_reader *,\n \t\t\t\t\t const unsigned char *, size_t));\n extern void cpp_forall_identifiers PARAMS ((cpp_reader *,\n \t\t\t\t\t    int (*) PARAMS ((cpp_reader *,\n \t\t\t\t\t\t\t     cpp_hashnode *))));\n+/* In cppmacro.c */\n+extern void cpp_dump_definition PARAMS ((cpp_reader *, FILE *,\n+\t\t\t\t\t const cpp_hashnode *));\n \n /* In cppfiles.c */\n extern int cpp_included\tPARAMS ((cpp_reader *, const char *));\n extern int cpp_read_file PARAMS ((cpp_reader *, const char *));\n extern void cpp_make_system_header PARAMS ((cpp_reader *, cpp_buffer *, int));\n+extern const char *cpp_syshdr_flags PARAMS ((cpp_reader *, cpp_buffer *));\n \n #ifdef __cplusplus\n }"}, {"sha": "5ff49a8d4df2038a2ac152cba0203950766677ae", "filename": "gcc/cppmacro.c", "status": "modified", "additions": 28, "deletions": 41, "changes": 69, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppmacro.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppmacro.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmacro.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -40,7 +40,7 @@ struct macro_info\n   unsigned char flags;\n };\n \n-static void dump_funlike_macro\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+static void dump_macro_args PARAMS ((FILE *, const cpp_toklist *));\n static void count_params PARAMS ((cpp_reader *, struct macro_info *));\n static int is__va_args__ PARAMS ((cpp_reader *, const cpp_token *));\n \n@@ -554,66 +554,53 @@ _cpp_create_definition (pfile, hp)\n   return 1;\n }\n \n-/* Dump the definition of macro MACRO on stdout.  The format is suitable\n-   to be read back in again. */\n+/* Dump the definition of macro MACRO on FP.  The format is suitable\n+   to be read back in again.  Caller is expected to generate the\n+   \"#define NAME\" bit.  */\n \n void\n-_cpp_dump_definition (pfile, hp)\n+cpp_dump_definition (pfile, fp, hp)\n      cpp_reader *pfile;\n-     cpp_hashnode *hp;\n+     FILE *fp;\n+     const cpp_hashnode *hp;\n {\n-  CPP_RESERVE (pfile, hp->length + sizeof \"#define \");\n-  CPP_PUTS_Q (pfile, \"#define \", sizeof \"#define \" - 1);\n-  CPP_PUTS_Q (pfile, hp->name, hp->length);\n+  const cpp_toklist *list = hp->value.expansion;\n \n-  if (hp->type == T_MACRO)\n+  if (hp->type != T_MACRO)\n     {\n-      if (hp->value.expansion->paramc >= 0)\n-\tdump_funlike_macro (pfile, hp);\n-      else\n-\t{\n-\t  const cpp_toklist *list = hp->value.expansion;\n-\t  list->tokens[0].flags &= ~BOL;\n-\t  list->tokens[0].flags |= PREV_WHITE;\n-\t  _cpp_dump_list (pfile, list, list->tokens, 1);\n-\t}\n+      cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n+      return;\n     }\n-  else\n-    cpp_ice (pfile, \"invalid hash type %d in dump_definition\", hp->type);\n \n-  if (CPP_BUFFER (pfile) == 0 || ! pfile->done_initializing)\n-    CPP_PUTC (pfile, '\\n');\n+  if (list->paramc >= 0)\n+    dump_macro_args (fp, list);\n+\n+  putc (' ', fp);\n+  cpp_output_list (pfile, fp, list, list->tokens);\n }\n \n static void\n-dump_funlike_macro (pfile, node)\n-     cpp_reader *pfile;\n-     cpp_hashnode *node;\n+dump_macro_args (fp, list)\n+     FILE *fp;\n+     const cpp_toklist *list;\n {\n-  int i = 0;\n-  const cpp_toklist * list = node->value.expansion;\n-  const U_CHAR *param;\n+  int i;\n+  const U_CHAR *param = list->namebuf;\n \n-  param = list->namebuf;\n-  CPP_PUTC_Q (pfile, '(');\n+  putc ('(', fp);\n   for (i = 0; i++ < list->paramc;)\n     {\n       unsigned int len;\n \n       len = ustrlen (param);\n-      CPP_PUTS (pfile, param, len);\n+      if (!list->flags & VAR_ARGS || ustrcmp (param, U\"__VA_ARGS__\"))\n+\tufputs (param, fp);\n       if (i < list->paramc)\n-\tCPP_PUTS(pfile, \", \", 2);\n+\tfputs (\", \", fp);\n       else if (list->flags & VAR_ARGS)\n-\t{\n-\t  if (!ustrcmp (param, U\"__VA_ARGS__\"))\n-\t    pfile->limit -= sizeof (U\"__VA_ARGS__\") - 1;\n-\t  CPP_PUTS_Q (pfile, \"...\", 3);\n-\t}\n+\tfputs (\"...\", fp);\n+\n       param += len + 1;\n     }\n-  CPP_PUTC (pfile, ')');\n-  list->tokens[0].flags &= ~BOL;\n-  list->tokens[0].flags |= PREV_WHITE;\n-  _cpp_dump_list (pfile, list, list->tokens, 1);\n+  putc (')', fp);\n }"}, {"sha": "0af5442f3f8a5ee99ca4b58a86e86b589d893418", "filename": "gcc/cppmain.c", "status": "modified", "additions": 178, "deletions": 4, "changes": 182, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppmain.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/58fea6afd912f7c309c156522391b20462372ceb/gcc%2Fcppmain.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcppmain.c?ref=58fea6afd912f7c309c156522391b20462372ceb", "patch": "@@ -30,8 +30,23 @@ const char *progname;\n cpp_reader parse_in;\n cpp_printer parse_out;\n \n-\f\n-extern int main\t\t\t\tPARAMS ((int, char **));\n+int main\t\tPARAMS ((int, char **));\n+\n+/* Callback routines for the parser.   Most of these are active only\n+   in specific modes.  */\n+static void cb_define\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+static void cb_undef\tPARAMS ((cpp_reader *, cpp_hashnode *));\n+static void cb_include\tPARAMS ((cpp_reader *, const unsigned char *,\n+\t\t\t\t const unsigned char *, unsigned int, int));\n+\n+static void cb_ident\t  PARAMS ((cpp_reader *, const cpp_token *));\n+static void cb_enter_file PARAMS ((cpp_reader *));\n+static void cb_leave_file PARAMS ((cpp_reader *));\n+static void cb_def_pragma PARAMS ((cpp_reader *));\n+\n+static void do_pragma_implementation PARAMS ((cpp_reader *));\n+static int dump_macros_helper PARAMS ((cpp_reader *, cpp_hashnode *));\n+\n int\n main (argc, argv)\n      int argc;\n@@ -68,8 +83,30 @@ main (argc, argv)\n   print = cpp_printer_init (pfile, &parse_out);\n   if (! print)\n     return (FATAL_EXIT_CODE);\n-  if (! CPP_OPTION (pfile, no_output))\n-    pfile->printer = print;\n+\n+  /* Set callbacks.  */\n+  if (! CPP_OPTION (pfile, no_line_commands)\n+      && ! CPP_OPTION (pfile, no_output))\n+    {\n+      pfile->cb.enter_file = cb_enter_file;\n+      pfile->cb.leave_file = cb_leave_file;\n+    }\n+  if (CPP_OPTION (pfile, dump_includes))\n+    pfile->cb.include  = cb_include;\n+  if (CPP_OPTION (pfile, debug_output)\n+      || CPP_OPTION (pfile, dump_macros) == dump_names\n+      || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n+    {\n+      pfile->cb.define = cb_define;\n+      pfile->cb.undef  = cb_undef;\n+      pfile->cb.poison = cb_def_pragma;\n+    }\n+  pfile->cb.ident      = cb_ident;\n+  pfile->cb.def_pragma = cb_def_pragma;\n+\n+  /* Register one #pragma which needs special handling.  */\n+  cpp_register_pragma(pfile, 0, \"implementation\", do_pragma_implementation);\n+  cpp_register_pragma(pfile, \"GCC\", \"implementation\", do_pragma_implementation);\n \n   if (! cpp_start_read (pfile, print, CPP_OPTION (pfile, in_fname)))\n     return (FATAL_EXIT_CODE);\n@@ -81,10 +118,147 @@ main (argc, argv)\n     while (CPP_BUFFER (pfile) != NULL)\n       cpp_scan_buffer (pfile, print);\n \n+  if (CPP_OPTION (pfile, dump_macros) == dump_only)\n+    cpp_forall_identifiers (pfile, dump_macros_helper);\n+  \n   cpp_finish (pfile, print);\n   cpp_cleanup (pfile);\n \n   if (parse_in.errors)\n     return (FATAL_EXIT_CODE);\n   return (SUCCESS_EXIT_CODE);\n }\n+\n+/* Callbacks */\n+\n+static void\n+cb_ident (pfile, token)\n+     cpp_reader *pfile;\n+     const cpp_token *token;\n+{\n+  cpp_printf (pfile, &parse_out, \"#ident \\\"%.*s\\\"\\n\",\n+\t      (int) token->val.str.len, token->val.str.text);\n+}\n+\n+static void\n+cb_define (pfile, hash)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hash;\n+{\n+  cpp_printf (pfile, &parse_out, \"#define %s\", hash->name);\n+  if (CPP_OPTION (pfile, debug_output)\n+      || CPP_OPTION (pfile, dump_macros) == dump_definitions)\n+    cpp_dump_definition (pfile, parse_out.outf, hash);\n+  putc ('\\n', parse_out.outf);\n+}\n+\n+static void\n+cb_undef (pfile, hash)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hash;\n+{\n+  cpp_printf (pfile, &parse_out, \"#undef %s\\n\", hash->name);\n+}\n+\n+static void\n+cb_include (pfile, dir, str, len, ab)\n+     cpp_reader *pfile;\n+     const unsigned char *dir;\n+     const unsigned char *str;\n+     unsigned int len;\n+     int ab;\n+{\n+  int l, r;\n+  if (ab)\n+    l = '<', r = '>';\n+  else\n+    l = '\"', r = '\"';\n+\n+  cpp_printf (pfile, &parse_out, \"#%s %c%.*s%c\\n\", dir, l, (int) len, str, r);\n+}\n+\n+static void\n+cb_enter_file (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+\n+  cpp_printf (pfile, &parse_out, \"# 1 \\\"%s\\\"%s%s\\n\", ip->nominal_fname,\n+\t      pfile->done_initializing ? \" 1\" : \"\",\n+\t      cpp_syshdr_flags (pfile, ip));\n+\n+  parse_out.lineno = 1;\n+  parse_out.last_fname = ip->nominal_fname;\n+}\n+\n+static void\n+cb_leave_file (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_buffer *ip = CPP_BUFFER (pfile);\n+\n+  cpp_printf (pfile, &parse_out, \"# %u \\\"%s\\\" 2%s\\n\", ip->lineno,\n+\t      ip->nominal_fname, cpp_syshdr_flags (pfile, ip));\n+\n+  parse_out.lineno = ip->lineno;\n+  parse_out.last_fname = ip->nominal_fname;\n+}\n+\n+static void\n+cb_def_pragma (pfile)\n+     cpp_reader *pfile;\n+{\n+  cpp_printf (pfile, &parse_out, \"#pragma \");\n+  cpp_output_list (pfile, parse_out.outf, &pfile->token_list,\n+\t\t   pfile->first_directive_token);\n+  putc ('\\n', parse_out.outf);\n+}\n+\n+static void\n+do_pragma_implementation (pfile)\n+     cpp_reader *pfile;\n+{\n+  /* Be quiet about `#pragma implementation' for a file only if it hasn't\n+     been included yet.  */\n+  const cpp_token *tok = cpp_get_token (pfile);\n+  char *copy;\n+\n+  if (tok->type != CPP_EOF)\n+    {\n+      if (tok->type != CPP_STRING || cpp_get_token (pfile)->type != CPP_EOF)\n+\t{\n+\t  cpp_error (pfile, \"malformed #pragma implementation\");\n+\t  return;\n+\t}\n+\n+      /* Make a NUL-terminated copy of the string.  */\n+      copy = alloca (tok->val.str.len + 1);\n+      memcpy (copy, tok->val.str.text, tok->val.str.len);\n+      copy[tok->val.str.len] = '\\0';\n+  \n+      if (cpp_included (pfile, copy))\n+\tcpp_warning (pfile,\n+\t\t\"#pragma implementation for %s appears after file is included\",\n+\t\t     copy);\n+    }\n+\n+  /* forward to default-pragma handler.  */\n+  cb_def_pragma (pfile);\n+}\n+\n+/* Dump out the hash table.  */\n+static int\n+dump_macros_helper (pfile, hp)\n+     cpp_reader *pfile;\n+     cpp_hashnode *hp;\n+{\n+  if (hp->type == T_MACRO)\n+    {\n+      cpp_printf (pfile, &parse_out, \"#define %s\", hp->name);\n+      cpp_dump_definition (pfile, parse_out.outf, hp);\n+      putc ('\\n', parse_out.outf);\n+    }\n+\n+  return 1;\n+}\n+"}, {"sha": "c09b84270ebc834718865babc05386ae4a302dd8", "filename": "gcc/testsuite/g77.f-torture/compile/20000629-1.x", "status": "removed", "additions": 0, "deletions": 3, "changes": 3, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8cd8f856b33bbd6c6627eb0a18e34b046e2163f1/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20000629-1.x", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8cd8f856b33bbd6c6627eb0a18e34b046e2163f1/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20000629-1.x", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fg77.f-torture%2Fcompile%2F20000629-1.x?ref=8cd8f856b33bbd6c6627eb0a18e34b046e2163f1", "patch": "@@ -1,3 +0,0 @@\n-set torture_compile_xfail \"*-*-*\"\n-\n-return 0"}]}