{"sha": "5326695a6d3585f5c49633813909342098d1714c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTMyNjY5NWE2ZDM1ODVmNWM0OTYzMzgxMzkwOTM0MjA5OGQxNzE0Yw==", "commit": {"author": {"name": "Andrew Stubbs", "email": "ams@codesourcery.com", "date": "2019-01-17T12:33:19Z"}, "committer": {"name": "Andrew Stubbs", "email": "ams@gcc.gnu.org", "date": "2019-01-17T12:33:19Z"}, "message": "GCN back-end code\n\nThis patch contains the major part of the GCN back-end.  The machine\ndescription has been broken out to avoid the mailing list size limit.\n\nThe back-end contains various bits that support OpenACC and OpenMP, but the\nmiddle-end and libgomp patches are missing, as is mkoffload.  I include them\nhere because they're harmless and carving up the files seems like unnecessary\neffort.  The remaining offload support will be posted at a later date.\n\nThe gcn-run.c is a separate tool that can run a GCN program on a GPU using\nthe ROCm drivers and HSA runtime libraries.\n\n2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n\t    Julian Brown  <julian@codesourcery.com>\n\t    Tom de Vries  <tom@codesourcery.com>\n\t    Jan Hubicka  <hubicka@ucw.cz>\n\t    Martin Jambor  <mjambor@suse.cz>\n\n\tgcc/\n\t* common/config/gcn/gcn-common.c: New file.\n\t* config/gcn/driver-gcn.c: New file.\n\t* config/gcn/gcn-builtins.def: New file.\n\t* config/gcn/gcn-hsa.h: New file.\n\t* config/gcn/gcn-modes.def: New file.\n\t* config/gcn/gcn-opts.h: New file.\n\t* config/gcn/gcn-passes.def: New file.\n\t* config/gcn/gcn-protos.h: New file.\n\t* config/gcn/gcn-run.c: New file.\n\t* config/gcn/gcn-tree.c: New file.\n\t* config/gcn/gcn.c: New file.\n\t* config/gcn/gcn.h: New file.\n\t* config/gcn/gcn.opt: New file.\n\t* config/gcn/t-gcn-hsa: New file.\n\n\nCo-Authored-By: Jan Hubicka <hubicka@ucw.cz>\nCo-Authored-By: Julian Brown <julian@codesourcery.com>\nCo-Authored-By: Kwok Cheung Yeung <kcy@codesourcery.com>\nCo-Authored-By: Martin Jambor <mjambor@suse.cz>\nCo-Authored-By: Tom de Vries <tom@codesourcery.com>\n\nFrom-SVN: r268023", "tree": {"sha": "0b323b46ebf2d5431ae2368ba580a0eda11e488c", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/0b323b46ebf2d5431ae2368ba580a0eda11e488c"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/5326695a6d3585f5c49633813909342098d1714c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5326695a6d3585f5c49633813909342098d1714c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/5326695a6d3585f5c49633813909342098d1714c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/5326695a6d3585f5c49633813909342098d1714c/comments", "author": {"login": "ams-cs", "id": 2235130, "node_id": "MDQ6VXNlcjIyMzUxMzA=", "avatar_url": "https://avatars.githubusercontent.com/u/2235130?v=4", "gravatar_id": "", "url": "https://api.github.com/users/ams-cs", "html_url": "https://github.com/ams-cs", "followers_url": "https://api.github.com/users/ams-cs/followers", "following_url": "https://api.github.com/users/ams-cs/following{/other_user}", "gists_url": "https://api.github.com/users/ams-cs/gists{/gist_id}", "starred_url": "https://api.github.com/users/ams-cs/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/ams-cs/subscriptions", "organizations_url": "https://api.github.com/users/ams-cs/orgs", "repos_url": "https://api.github.com/users/ams-cs/repos", "events_url": "https://api.github.com/users/ams-cs/events{/privacy}", "received_events_url": "https://api.github.com/users/ams-cs/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "3d6275e30a850b8e8051163bcd43ddbab2273046", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/3d6275e30a850b8e8051163bcd43ddbab2273046", "html_url": "https://github.com/Rust-GCC/gccrs/commit/3d6275e30a850b8e8051163bcd43ddbab2273046"}], "stats": {"total": 9051, "additions": 9051, "deletions": 0}, "files": [{"sha": "2f1a36f64eff83220bdc73d6b6aeb22baafccc86", "filename": "gcc/ChangeLog", "status": "modified", "additions": 22, "deletions": 0, "changes": 22, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -1,3 +1,25 @@\n+2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n+\t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n+\t    Julian Brown  <julian@codesourcery.com>\n+\t    Tom de Vries  <tom@codesourcery.com>\n+\t    Jan Hubicka  <hubicka@ucw.cz>\n+\t    Martin Jambor  <mjambor@suse.cz>\n+\n+\t* common/config/gcn/gcn-common.c: New file.\n+\t* config/gcn/driver-gcn.c: New file.\n+\t* config/gcn/gcn-builtins.def: New file.\n+\t* config/gcn/gcn-hsa.h: New file.\n+\t* config/gcn/gcn-modes.def: New file.\n+\t* config/gcn/gcn-opts.h: New file.\n+\t* config/gcn/gcn-passes.def: New file.\n+\t* config/gcn/gcn-protos.h: New file.\n+\t* config/gcn/gcn-run.c: New file.\n+\t* config/gcn/gcn-tree.c: New file.\n+\t* config/gcn/gcn.c: New file.\n+\t* config/gcn/gcn.h: New file.\n+\t* config/gcn/gcn.opt: New file.\n+\t* config/gcn/t-gcn-hsa: New file.\n+\n 2019-01-17  Andrew Stubbs  <ams@codesourcery.com>\n \t    Kwok Cheung Yeung  <kcy@codesourcery.com>\n \t    Julian Brown  <julian@codesourcery.com>"}, {"sha": "f34953dc04b1e5e495ddb0184f286831cf1a0364", "filename": "gcc/common/config/gcn/gcn-common.c", "status": "added", "additions": 38, "deletions": 0, "changes": 38, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fcommon%2Fconfig%2Fgcn%2Fgcn-common.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fcommon%2Fconfig%2Fgcn%2Fgcn-common.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcommon%2Fconfig%2Fgcn%2Fgcn-common.c?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,38 @@\n+/* Common hooks for GCN\n+   Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+#include \"common/common-target.h\"\n+#include \"common/common-target-def.h\"\n+#include \"opts.h\"\n+#include \"flags.h\"\n+#include \"params.h\"\n+\n+/* Set default optimization options.  */\n+static const struct default_options gcn_option_optimization_table[] =\n+  {\n+    { OPT_LEVELS_1_PLUS, OPT_fomit_frame_pointer, NULL, 1 },\n+    { OPT_LEVELS_NONE, 0, NULL, 0 }\n+  };\n+\n+#undef  TARGET_OPTION_OPTIMIZATION_TABLE\n+#define TARGET_OPTION_OPTIMIZATION_TABLE gcn_option_optimization_table\n+\n+struct gcc_targetm_common targetm_common = TARGETM_COMMON_INITIALIZER;"}, {"sha": "a5181bc39959046173dee8dca63da41bfe58d0b2", "filename": "gcc/config/gcn/driver-gcn.c", "status": "added", "additions": 32, "deletions": 0, "changes": 32, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fdriver-gcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fdriver-gcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fdriver-gcn.c?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,32 @@\n+/* Subroutines for the gcc driver.\n+   Copyright (C) 2018-2019 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify\n+it under the terms of the GNU General Public License as published by\n+the Free Software Foundation; either version 3, or (at your option)\n+any later version.\n+\n+GCC is distributed in the hope that it will be useful,\n+but WITHOUT ANY WARRANTY; without even the implied warranty of\n+MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+GNU General Public License for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"tm.h\"\n+\n+const char *\n+last_arg_spec_function (int argc, const char **argv)\n+{\n+  if (argc == 0)\n+    return NULL;\n+\n+  return argv[argc-1];\n+}"}, {"sha": "47897607abf8377758ad68e36cde62ddca9d2193", "filename": "gcc/config/gcn/gcn-builtins.def", "status": "added", "additions": 116, "deletions": 0, "changes": 116, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-builtins.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-builtins.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-builtins.def?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,116 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* The first argument to these macros is the return type of the builtin,\n+   the rest are arguments of the builtin.  */\n+#define _A1(a)\t       {a, GCN_BTI_END_OF_PARAMS}\n+#define _A2(a,b)       {a, b, GCN_BTI_END_OF_PARAMS}\n+#define _A3(a,b,c)     {a, b, c, GCN_BTI_END_OF_PARAMS}\n+#define _A4(a,b,c,d)   {a, b, c, d, GCN_BTI_END_OF_PARAMS}\n+#define _A5(a,b,c,d,e) {a, b, c, d, e, GCN_BTI_END_OF_PARAMS}\n+\n+DEF_BUILTIN (FLAT_LOAD_INT32, 1 /*CODE_FOR_flat_load_v64si*/,\n+\t     \"flat_load_int32\", B_INSN,\n+\t     _A3 (GCN_BTI_V64SI, GCN_BTI_EXEC, GCN_BTI_V64SI),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (FLAT_LOAD_PTR_INT32, 2 /*CODE_FOR_flat_load_ptr_v64si */,\n+\t     \"flat_load_ptr_int32\", B_INSN,\n+\t     _A4 (GCN_BTI_V64SI, GCN_BTI_EXEC, GCN_BTI_SIPTR, GCN_BTI_V64SI),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (FLAT_STORE_PTR_INT32, 3 /*CODE_FOR_flat_store_ptr_v64si */,\n+\t     \"flat_store_ptr_int32\", B_INSN,\n+\t     _A5 (GCN_BTI_VOID, GCN_BTI_EXEC, GCN_BTI_SIPTR, GCN_BTI_V64SI,\n+\t\t  GCN_BTI_V64SI),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (FLAT_LOAD_PTR_FLOAT, 2 /*CODE_FOR_flat_load_ptr_v64sf */,\n+\t     \"flat_load_ptr_float\", B_INSN,\n+\t     _A4 (GCN_BTI_V64SF, GCN_BTI_EXEC, GCN_BTI_SFPTR, GCN_BTI_V64SI),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (FLAT_STORE_PTR_FLOAT, 3 /*CODE_FOR_flat_store_ptr_v64sf */,\n+\t     \"flat_store_ptr_float\", B_INSN,\n+\t     _A5 (GCN_BTI_VOID, GCN_BTI_EXEC, GCN_BTI_SFPTR, GCN_BTI_V64SI,\n+\t\t  GCN_BTI_V64SF),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (SQRTVF, 3 /*CODE_FOR_sqrtvf */,\n+\t     \"sqrtvf\", B_INSN,\n+\t     _A2 (GCN_BTI_V64SF, GCN_BTI_V64SF),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (SQRTF, 3 /*CODE_FOR_sqrtf */,\n+\t     \"sqrtf\", B_INSN,\n+\t     _A2 (GCN_BTI_SF, GCN_BTI_SF),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (CMP_SWAP, -1,\n+\t    \"cmp_swap\", B_INSN,\n+\t    _A4 (GCN_BTI_UINT, GCN_BTI_VOIDPTR, GCN_BTI_UINT, GCN_BTI_UINT),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (CMP_SWAPLL, -1,\n+\t    \"cmp_swapll\", B_INSN,\n+\t    _A4 (GCN_BTI_LLUINT,\n+\t\t GCN_BTI_VOIDPTR, GCN_BTI_LLUINT, GCN_BTI_LLUINT),\n+\t    gcn_expand_builtin_1)\n+\n+/* DEF_BUILTIN_BINOP_INT_FP creates many variants of a builtin function for a\n+   given operation.  The first argument will give base to the identifier of a\n+   particular builtin, the second will be used to form the name of the patter\n+   used to expand it to and the third will be used to create the user-visible\n+   builtin identifier.  */\n+\n+DEF_BUILTIN_BINOP_INT_FP (ADD, add, \"add\")\n+DEF_BUILTIN_BINOP_INT_FP (SUB, sub, \"sub\")\n+\n+DEF_BUILTIN_BINOP_INT_FP (AND, and, \"and\")\n+DEF_BUILTIN_BINOP_INT_FP (IOR, ior, \"or\")\n+DEF_BUILTIN_BINOP_INT_FP (XOR, xor, \"xor\")\n+\n+/* OpenMP.  */\n+\n+DEF_BUILTIN (OMP_DIM_SIZE, CODE_FOR_oacc_dim_size,\n+\t     \"dim_size\", B_INSN,\n+\t     _A2 (GCN_BTI_INT, GCN_BTI_INT),\n+\t     gcn_expand_builtin_1)\n+DEF_BUILTIN (OMP_DIM_POS, CODE_FOR_oacc_dim_pos,\n+\t     \"dim_pos\", B_INSN,\n+\t     _A2 (GCN_BTI_INT, GCN_BTI_INT),\n+\t     gcn_expand_builtin_1)\n+\n+/* OpenACC.  */\n+\n+DEF_BUILTIN (ACC_SINGLE_START, -1, \"single_start\", B_INSN, _A1 (GCN_BTI_BOOL),\n+\t     gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (ACC_SINGLE_COPY_START, -1, \"single_copy_start\", B_INSN,\n+\t     _A1 (GCN_BTI_LDS_VOIDPTR), gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (ACC_SINGLE_COPY_END, -1, \"single_copy_end\", B_INSN,\n+\t     _A2 (GCN_BTI_VOID, GCN_BTI_LDS_VOIDPTR), gcn_expand_builtin_1)\n+\n+DEF_BUILTIN (ACC_BARRIER, -1, \"acc_barrier\", B_INSN, _A1 (GCN_BTI_VOID),\n+\t     gcn_expand_builtin_1)\n+\n+\n+#undef _A1\n+#undef _A2\n+#undef _A3\n+#undef _A4\n+#undef _A5"}, {"sha": "2e3746cdab8b6a1ce3f047e1a8350764fc5dc602", "filename": "gcc/config/gcn/gcn-hsa.h", "status": "added", "additions": 115, "deletions": 0, "changes": 115, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-hsa.h?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,115 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef OBJECT_FORMAT_ELF\n+ #error elf.h included before elfos.h\n+#endif\n+\n+#define TEXT_SECTION_ASM_OP \"\\t.section\\t.text\"\n+#define BSS_SECTION_ASM_OP  \"\\t.section\\t.bss\"\n+#define GLOBAL_ASM_OP       \"\\t.globl\\t\"\n+#define DATA_SECTION_ASM_OP \"\\t.data\\t\"\n+#define SET_ASM_OP          \"\\t.set\\t\"\n+#define LOCAL_LABEL_PREFIX  \".\"\n+#define USER_LABEL_PREFIX   \"\"\n+#define ASM_COMMENT_START   \";\"\n+#define TARGET_ASM_NAMED_SECTION default_elf_asm_named_section\n+\n+#define ASM_OUTPUT_ALIGNED_BSS(FILE, DECL, NAME, SIZE, ALIGN) \\\n+\t    asm_output_aligned_bss (FILE, DECL, NAME, SIZE, ALIGN)\n+\n+#undef ASM_DECLARE_FUNCTION_NAME\n+#define ASM_DECLARE_FUNCTION_NAME(FILE, NAME, DECL) \\\n+  gcn_hsa_declare_function_name ((FILE), (NAME), (DECL))\n+\n+/* Unlike GNU as, the LLVM assembler uses log2 alignments.  */\n+#undef ASM_OUTPUT_ALIGNED_COMMON\n+#define ASM_OUTPUT_ALIGNED_COMMON(FILE, NAME, SIZE, ALIGNMENT)\t  \\\n+ (fprintf ((FILE), \"%s\", COMMON_ASM_OP),\t\t\t  \\\n+  assemble_name ((FILE), (NAME)),\t\t\t\t  \\\n+  fprintf ((FILE), \",\" HOST_WIDE_INT_PRINT_UNSIGNED \",%u\\n\",\t  \\\n+\t   (SIZE) > 0 ? (SIZE) : 1, exact_log2 ((ALIGNMENT) / BITS_PER_UNIT)))\n+\n+#define ASM_OUTPUT_LABEL(FILE,NAME) \\\n+  do { assemble_name (FILE, NAME); fputs (\":\\n\", FILE); } while (0)\n+\n+#define ASM_OUTPUT_LABELREF(FILE, NAME) \\\n+  asm_fprintf (FILE, \"%U%s\", default_strip_name_encoding (NAME))\n+\n+extern unsigned int gcn_local_sym_hash (const char *name);\n+\n+#define ASM_OUTPUT_SYMBOL_REF(FILE, X) gcn_asm_output_symbol_ref (FILE, X)\n+\n+#define ASM_OUTPUT_ADDR_DIFF_ELT(FILE, BODY, VALUE, REL) \\\n+  fprintf (FILE, \"\\t.word .L%d-.L%d\\n\", VALUE, REL)\n+\n+#define ASM_OUTPUT_ADDR_VEC_ELT(FILE, VALUE) \\\n+  fprintf (FILE, \"\\t.word .L%d\\n\", VALUE)\n+\n+#define ASM_OUTPUT_ALIGN(FILE,LOG) \\\n+  do { if (LOG!=0) fprintf (FILE, \"\\t.align\\t%d\\n\", 1<<(LOG)); } while (0)\n+#define ASM_OUTPUT_ALIGN_WITH_NOP(FILE,LOG)\t       \\\n+  do {\t\t\t\t\t\t       \\\n+    if (LOG!=0)\t\t\t\t\t       \\\n+      fprintf (FILE, \"\\t.p2alignl\\t%d, 0xBF800000\"     \\\n+\t       \" ; Fill value is 's_nop 0'\\n\", (LOG)); \\\n+  } while (0)\n+\n+#define ASM_APP_ON  \"\"\n+#define ASM_APP_OFF \"\"\n+\n+/* Avoid the default in ../../gcc.c, which adds \"-pthread\", which is not\n+   supported for gcn.  */\n+#define GOMP_SELF_SPECS \"\"\n+\n+/* Use LLVM assembler and linker options.  */\n+#define ASM_SPEC  \"-triple=amdgcn--amdhsa \"\t     \\\n+\t\t  \"%:last_arg(%{march=*:-mcpu=%*}) \" \\\n+\t\t  \"-filetype=obj\"\n+/* Add -mlocal-symbol-id=<source-file-basename> unless the user (or mkoffload)\n+   passes the option explicitly on the command line.  The option also causes\n+   several dump-matching tests to fail in the testsuite, so the option is not\n+   added when or tree dump/compare-debug options used in the testsuite are\n+   present.\n+   This has the potential for surprise, but a user can still use an explicit\n+   -mlocal-symbol-id=<whatever> option manually together with -fdump-tree or\n+   -fcompare-debug options.  */\n+#define CC1_SPEC \"%{!mlocal-symbol-id=*:%{!fdump-tree-*:\"\t\\\n+\t\t \"%{!fdump-ipa-*:%{!fcompare-debug*:-mlocal-symbol-id=%b}}}}\"\n+#define LINK_SPEC \"--pie\"\n+#define LIB_SPEC  \"-lc\"\n+\n+/* Provides a _start symbol to keep the linker happy.  */\n+#define STARTFILE_SPEC \"crt0.o%s\"\n+#define ENDFILE_SPEC   \"\"\n+#define STANDARD_STARTFILE_PREFIX_2 \"\"\n+\n+/* The LLVM assembler rejects multiple -mcpu options, so we must drop\n+   all but the last.  */\n+extern const char *last_arg_spec_function (int argc, const char **argv);\n+#define EXTRA_SPEC_FUNCTIONS\t\\\n+    { \"last_arg\", last_arg_spec_function },\n+\n+#undef LOCAL_INCLUDE_DIR\n+\n+/* FIXME: Review debug info settings.\n+ *        In particular, EH_FRAME_THROUGH_COLLECT2 is probably the wrong\n+ *        thing but stuff fails to build without it.\n+ *        (Debug info is not a big deal until we get a debugger.)  */\n+#define PREFERRED_DEBUGGING_TYPE   DWARF2_DEBUG\n+#define DWARF2_DEBUGGING_INFO      1\n+#define DWARF2_ASM_LINE_DEBUG_INFO 1\n+#define EH_FRAME_THROUGH_COLLECT2  1"}, {"sha": "6d73100c4f4f59019dc080d70ef29d15f5820c7f", "filename": "gcc/config/gcn/gcn-modes.def", "status": "added", "additions": 41, "deletions": 0, "changes": 41, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-modes.def?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,41 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* Half-precision floating point */\n+FLOAT_MODE (HF, 2, 0);\n+/* FIXME: No idea what format it is.  */\n+ADJUST_FLOAT_FORMAT (HF, &ieee_half_format);\n+\n+/* Native vector modes.  */\n+VECTOR_MODE (INT, QI, 64);      /*\t\t  V64QI */\n+VECTOR_MODE (INT, HI, 64);      /*\t\t  V64HI */\n+VECTOR_MODE (INT, SI, 64);      /*\t\t  V64SI */\n+VECTOR_MODE (INT, DI, 64);      /*\t\t  V64DI */\n+VECTOR_MODE (INT, TI, 64);      /*\t\t  V64TI */\n+VECTOR_MODE (FLOAT, HF, 64);    /*\t\t  V64HF */\n+VECTOR_MODE (FLOAT, SF, 64);    /*\t\t  V64SF */\n+VECTOR_MODE (FLOAT, DF, 64);    /*\t\t  V64DF */\n+\n+/* Vector units handle reads independently and thus no large alignment\n+   needed.  */\n+ADJUST_ALIGNMENT (V64QI, 1);\n+ADJUST_ALIGNMENT (V64HI, 2);\n+ADJUST_ALIGNMENT (V64SI, 4);\n+ADJUST_ALIGNMENT (V64DI, 8);\n+ADJUST_ALIGNMENT (V64TI, 16);\n+ADJUST_ALIGNMENT (V64HF, 2);\n+ADJUST_ALIGNMENT (V64SF, 4);\n+ADJUST_ALIGNMENT (V64DF, 8);"}, {"sha": "e2b32b6c4618d98bf5c58f22287f06a3e4a3377e", "filename": "gcc/config/gcn/gcn-opts.h", "status": "added", "additions": 36, "deletions": 0, "changes": 36, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-opts.h?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,36 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCN_OPTS_H\n+#define GCN_OPTS_H\n+\n+/* Which processor to generate code or schedule for.  */\n+enum processor_type\n+{\n+  PROCESSOR_CARRIZO,\n+  PROCESSOR_FIJI,\n+  PROCESSOR_VEGA\n+};\n+\n+/* Set in gcn_option_override.  */\n+extern int gcn_isa;\n+\n+#define TARGET_GCN3 (gcn_isa == 3)\n+#define TARGET_GCN3_PLUS (gcn_isa >= 3)\n+#define TARGET_GCN5 (gcn_isa == 5)\n+#define TARGET_GCN5_PLUS (gcn_isa >= 5)\n+\n+#endif"}, {"sha": "50f583fbbbe89c2f2617735c64762084f495c0a5", "filename": "gcc/config/gcn/gcn-passes.def", "status": "added", "additions": 19, "deletions": 0, "changes": 19, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-passes.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-passes.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-passes.def?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,19 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+   \n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+   \n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+INSERT_PASS_AFTER (pass_omp_target_link, 1, pass_omp_gcn);"}, {"sha": "da7faf29c7013f5e050d721f9e52cb607e0c7241", "filename": "gcc/config/gcn/gcn-protos.h", "status": "added", "additions": 146, "deletions": 0, "changes": 146, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-protos.h?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,146 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef _GCN_PROTOS_\n+#define _GCN_PROTOS_\n+\n+extern void gcn_asm_output_symbol_ref (FILE *file, rtx x);\n+extern tree gcn_builtin_decl (unsigned code, bool initialize_p);\n+extern bool gcn_can_split_p (machine_mode, rtx);\n+extern bool gcn_constant64_p (rtx);\n+extern bool gcn_constant_p (rtx);\n+extern rtx gcn_convert_mask_mode (rtx reg);\n+extern char * gcn_expand_dpp_shr_insn (machine_mode, const char *, int, int);\n+extern void gcn_expand_epilogue ();\n+extern rtx gcn_expand_scaled_offsets (addr_space_t as, rtx base, rtx offsets,\n+\t\t\t\t      rtx scale, bool unsigned_p, rtx exec);\n+extern void gcn_expand_prologue ();\n+extern rtx gcn_expand_reduc_scalar (machine_mode, rtx, int);\n+extern rtx gcn_expand_scalar_to_vector_address (machine_mode, rtx, rtx, rtx);\n+extern void gcn_expand_vector_init (rtx, rtx);\n+extern bool gcn_flat_address_p (rtx, machine_mode);\n+extern bool gcn_fp_constant_p (rtx, bool);\n+extern rtx gcn_full_exec ();\n+extern rtx gcn_full_exec_reg ();\n+extern rtx gcn_gen_undef (machine_mode);\n+extern bool gcn_global_address_p (rtx);\n+extern tree gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n+\t\t\t\t\t\t const char *name);\n+extern void gcn_goacc_adjust_gangprivate_decl (tree var);\n+extern void gcn_goacc_reduction (gcall *call);\n+extern bool gcn_hard_regno_rename_ok (unsigned int from_reg,\n+\t\t\t\t      unsigned int to_reg);\n+extern machine_mode gcn_hard_regno_caller_save_mode (unsigned int regno,\n+\t\t\t\t\t\t     unsigned int nregs,\n+\t\t\t\t\t\t     machine_mode regmode);\n+extern bool gcn_hard_regno_mode_ok (int regno, machine_mode mode);\n+extern int gcn_hard_regno_nregs (int regno, machine_mode mode);\n+extern void gcn_hsa_declare_function_name (FILE *file, const char *name,\n+\t\t\t\t\t   tree decl);\n+extern HOST_WIDE_INT gcn_initial_elimination_offset (int, int);\n+extern bool gcn_inline_constant64_p (rtx);\n+extern bool gcn_inline_constant_p (rtx);\n+extern int gcn_inline_fp_constant_p (rtx, bool);\n+extern reg_class gcn_mode_code_base_reg_class (machine_mode, addr_space_t,\n+\t\t\t\t\t       int, int);\n+extern rtx gcn_oacc_dim_pos (int dim);\n+extern rtx gcn_oacc_dim_size (int dim);\n+extern rtx gcn_operand_doublepart (machine_mode, rtx, int);\n+extern rtx gcn_operand_part (machine_mode, rtx, int);\n+extern bool gcn_regno_mode_code_ok_for_base_p (int, machine_mode,\n+\t\t\t\t\t       addr_space_t, int, int);\n+extern reg_class gcn_regno_reg_class (int regno);\n+extern rtx gcn_scalar_exec ();\n+extern rtx gcn_scalar_exec_reg ();\n+extern bool gcn_scalar_flat_address_p (rtx);\n+extern bool gcn_scalar_flat_mem_p (rtx);\n+extern bool gcn_sgpr_move_p (rtx, rtx);\n+extern bool gcn_valid_move_p (machine_mode, rtx, rtx);\n+extern rtx gcn_vec_constant (machine_mode, int);\n+extern rtx gcn_vec_constant (machine_mode, rtx);\n+extern bool gcn_vgpr_move_p (rtx, rtx);\n+extern void print_operand_address (FILE *file, register rtx addr);\n+extern void print_operand (FILE *file, rtx x, int code);\n+extern bool regno_ok_for_index_p (int);\n+\n+enum gcn_cvt_t\n+{\n+  fix_trunc_cvt,\n+  fixuns_trunc_cvt,\n+  float_cvt,\n+  floatuns_cvt,\n+  extend_cvt,\n+  trunc_cvt\n+};\n+\n+extern bool gcn_valid_cvt_p (machine_mode from, machine_mode to,\n+\t\t\t     enum gcn_cvt_t op);\n+\n+#ifdef TREE_CODE\n+extern void gcn_init_cumulative_args (CUMULATIVE_ARGS *, tree, rtx, tree,\n+\t\t\t\t      int);\n+class gimple_opt_pass;\n+extern gimple_opt_pass *make_pass_omp_gcn (gcc::context *ctxt);\n+#endif\n+\n+/* Return true if MODE is valid for 1 VGPR register.  */\n+\n+inline bool\n+vgpr_1reg_mode_p (machine_mode mode)\n+{\n+  return (mode == SImode || mode == SFmode || mode == HImode || mode == QImode\n+\t  || mode == V64QImode || mode == V64HImode || mode == V64SImode\n+\t  || mode == V64HFmode || mode == V64SFmode || mode == BImode);\n+}\n+\n+/* Return true if MODE is valid for 1 SGPR register.  */\n+\n+inline bool\n+sgpr_1reg_mode_p (machine_mode mode)\n+{\n+  return (mode == SImode || mode == SFmode || mode == HImode\n+\t  || mode == QImode || mode == BImode);\n+}\n+\n+/* Return true if MODE is valid for pair of VGPR registers.  */\n+\n+inline bool\n+vgpr_2reg_mode_p (machine_mode mode)\n+{\n+  return (mode == DImode || mode == DFmode\n+\t  || mode == V64DImode || mode == V64DFmode);\n+}\n+\n+/* Return true if MODE can be handled directly by VGPR operations.  */\n+\n+inline bool\n+vgpr_vector_mode_p (machine_mode mode)\n+{\n+  return (mode == V64QImode || mode == V64HImode\n+\t  || mode == V64SImode || mode == V64DImode\n+\t  || mode == V64HFmode || mode == V64SFmode || mode == V64DFmode);\n+}\n+\n+\n+/* Return true if MODE is valid for pair of SGPR registers.  */\n+\n+inline bool\n+sgpr_2reg_mode_p (machine_mode mode)\n+{\n+  return mode == DImode || mode == DFmode;\n+}\n+\n+#endif"}, {"sha": "58089843ef8a7dfa128bb60803fdde458d6e1a04", "filename": "gcc/config/gcn/gcn-run.c", "status": "added", "additions": 850, "deletions": 0, "changes": 850, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-run.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-run.c?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,850 @@\n+/* Run a stand-alone AMD GCN kernel.\n+\n+   Copyright 2017 Mentor Graphics Corporation\n+   Copyright 2018-2019 Free Software Foundation, Inc.\n+\n+   This program is free software: you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation, either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+/* This program will run a compiled stand-alone GCN kernel on a GPU.\n+\n+   The kernel entry point's signature must use a standard main signature:\n+\n+     int main(int argc, char **argv)\n+*/\n+\n+#include <stdint.h>\n+#include <stdbool.h>\n+#include <stdlib.h>\n+#include <malloc.h>\n+#include <stdio.h>\n+#include <string.h>\n+#include <dlfcn.h>\n+#include <unistd.h>\n+#include <elf.h>\n+#include <signal.h>\n+\n+/* These probably won't be in elf.h for a while.  */\n+#ifndef R_AMDGPU_NONE\n+#define R_AMDGPU_NONE\t\t0\n+#define R_AMDGPU_ABS32_LO\t1\t/* (S + A) & 0xFFFFFFFF  */\n+#define R_AMDGPU_ABS32_HI\t2\t/* (S + A) >> 32  */\n+#define R_AMDGPU_ABS64\t\t3\t/* S + A  */\n+#define R_AMDGPU_REL32\t\t4\t/* S + A - P  */\n+#define R_AMDGPU_REL64\t\t5\t/* S + A - P  */\n+#define R_AMDGPU_ABS32\t\t6\t/* S + A  */\n+#define R_AMDGPU_GOTPCREL\t7\t/* G + GOT + A - P  */\n+#define R_AMDGPU_GOTPCREL32_LO\t8\t/* (G + GOT + A - P) & 0xFFFFFFFF  */\n+#define R_AMDGPU_GOTPCREL32_HI\t9\t/* (G + GOT + A - P) >> 32  */\n+#define R_AMDGPU_REL32_LO\t10\t/* (S + A - P) & 0xFFFFFFFF  */\n+#define R_AMDGPU_REL32_HI\t11\t/* (S + A - P) >> 32  */\n+#define reserved\t\t12\n+#define R_AMDGPU_RELATIVE64\t13\t/* B + A  */\n+#endif\n+\n+#include \"hsa.h\"\n+\n+#ifndef HSA_RUNTIME_LIB\n+#define HSA_RUNTIME_LIB \"libhsa-runtime64.so\"\n+#endif\n+\n+#ifndef VERSION_STRING\n+#define VERSION_STRING \"(version unknown)\"\n+#endif\n+\n+bool debug = false;\n+\n+hsa_agent_t device = { 0 };\n+hsa_queue_t *queue = NULL;\n+uint64_t kernel = 0;\n+hsa_executable_t executable = { 0 };\n+\n+hsa_region_t kernargs_region = { 0 };\n+uint32_t kernarg_segment_size = 0;\n+uint32_t group_segment_size = 0;\n+uint32_t private_segment_size = 0;\n+\n+static void\n+usage (const char *progname)\n+{\n+  printf (\"Usage: %s [options] kernel [kernel-args]\\n\\n\"\n+\t  \"Options:\\n\"\n+\t  \"  --help\\n\"\n+\t  \"  --version\\n\"\n+\t  \"  --debug\\n\", progname);\n+}\n+\n+static void\n+version (const char *progname)\n+{\n+  printf (\"%s \" VERSION_STRING \"\\n\", progname);\n+}\n+\n+/* As an HSA runtime is dlopened, following structure defines the necessary\n+   function pointers.\n+   Code adapted from libgomp.  */\n+\n+struct hsa_runtime_fn_info\n+{\n+  /* HSA runtime.  */\n+  hsa_status_t (*hsa_status_string_fn) (hsa_status_t status,\n+\t\t\t\t\tconst char **status_string);\n+  hsa_status_t (*hsa_agent_get_info_fn) (hsa_agent_t agent,\n+\t\t\t\t\t hsa_agent_info_t attribute,\n+\t\t\t\t\t void *value);\n+  hsa_status_t (*hsa_init_fn) (void);\n+  hsa_status_t (*hsa_iterate_agents_fn)\n+    (hsa_status_t (*callback) (hsa_agent_t agent, void *data), void *data);\n+  hsa_status_t (*hsa_region_get_info_fn) (hsa_region_t region,\n+\t\t\t\t\t  hsa_region_info_t attribute,\n+\t\t\t\t\t  void *value);\n+  hsa_status_t (*hsa_queue_create_fn)\n+    (hsa_agent_t agent, uint32_t size, hsa_queue_type_t type,\n+     void (*callback) (hsa_status_t status, hsa_queue_t *source, void *data),\n+     void *data, uint32_t private_segment_size,\n+     uint32_t group_segment_size, hsa_queue_t **queue);\n+  hsa_status_t (*hsa_agent_iterate_regions_fn)\n+    (hsa_agent_t agent,\n+     hsa_status_t (*callback) (hsa_region_t region, void *data), void *data);\n+  hsa_status_t (*hsa_executable_destroy_fn) (hsa_executable_t executable);\n+  hsa_status_t (*hsa_executable_create_fn)\n+    (hsa_profile_t profile, hsa_executable_state_t executable_state,\n+     const char *options, hsa_executable_t *executable);\n+  hsa_status_t (*hsa_executable_global_variable_define_fn)\n+    (hsa_executable_t executable, const char *variable_name, void *address);\n+  hsa_status_t (*hsa_executable_load_code_object_fn)\n+    (hsa_executable_t executable, hsa_agent_t agent,\n+     hsa_code_object_t code_object, const char *options);\n+  hsa_status_t (*hsa_executable_freeze_fn) (hsa_executable_t executable,\n+\t\t\t\t\t    const char *options);\n+  hsa_status_t (*hsa_signal_create_fn) (hsa_signal_value_t initial_value,\n+\t\t\t\t\tuint32_t num_consumers,\n+\t\t\t\t\tconst hsa_agent_t *consumers,\n+\t\t\t\t\thsa_signal_t *signal);\n+  hsa_status_t (*hsa_memory_allocate_fn) (hsa_region_t region, size_t size,\n+\t\t\t\t\t  void **ptr);\n+  hsa_status_t (*hsa_memory_copy_fn) (void *dst, const void *src,\n+\t\t\t\t      size_t size);\n+  hsa_status_t (*hsa_memory_free_fn) (void *ptr);\n+  hsa_status_t (*hsa_signal_destroy_fn) (hsa_signal_t signal);\n+  hsa_status_t (*hsa_executable_get_symbol_fn)\n+    (hsa_executable_t executable, const char *module_name,\n+     const char *symbol_name, hsa_agent_t agent, int32_t call_convention,\n+     hsa_executable_symbol_t *symbol);\n+  hsa_status_t (*hsa_executable_symbol_get_info_fn)\n+    (hsa_executable_symbol_t executable_symbol,\n+     hsa_executable_symbol_info_t attribute, void *value);\n+  void (*hsa_signal_store_relaxed_fn) (hsa_signal_t signal,\n+\t\t\t\t       hsa_signal_value_t value);\n+  hsa_signal_value_t (*hsa_signal_wait_acquire_fn)\n+    (hsa_signal_t signal, hsa_signal_condition_t condition,\n+     hsa_signal_value_t compare_value, uint64_t timeout_hint,\n+     hsa_wait_state_t wait_state_hint);\n+  hsa_signal_value_t (*hsa_signal_wait_relaxed_fn)\n+    (hsa_signal_t signal, hsa_signal_condition_t condition,\n+     hsa_signal_value_t compare_value, uint64_t timeout_hint,\n+     hsa_wait_state_t wait_state_hint);\n+  hsa_status_t (*hsa_queue_destroy_fn) (hsa_queue_t *queue);\n+  hsa_status_t (*hsa_code_object_deserialize_fn)\n+    (void *serialized_code_object, size_t serialized_code_object_size,\n+     const char *options, hsa_code_object_t *code_object);\n+  uint64_t (*hsa_queue_load_write_index_relaxed_fn)\n+    (const hsa_queue_t *queue);\n+  void (*hsa_queue_store_write_index_relaxed_fn)\n+    (const hsa_queue_t *queue, uint64_t value);\n+  hsa_status_t (*hsa_shut_down_fn) ();\n+};\n+\n+/* HSA runtime functions that are initialized in init_hsa_context.\n+   Code adapted from libgomp.  */\n+\n+static struct hsa_runtime_fn_info hsa_fns;\n+\n+#define DLSYM_FN(function)\t\t\t\t\t \\\n+  *(void**)(&hsa_fns.function##_fn) = dlsym (handle, #function); \\\n+  if (hsa_fns.function##_fn == NULL)\t\t\t\t \\\n+    goto fail;\n+\n+static void\n+init_hsa_runtime_functions (void)\n+{\n+  void *handle = dlopen (HSA_RUNTIME_LIB, RTLD_LAZY);\n+  if (handle == NULL)\n+    {\n+      fprintf (stderr,\n+\t       \"The HSA runtime is required to run GCN kernels on hardware.\\n\"\n+\t       \"%s: File not found or could not be opened\\n\",\n+\t       HSA_RUNTIME_LIB);\n+      exit (1);\n+    }\n+\n+  DLSYM_FN (hsa_status_string)\n+  DLSYM_FN (hsa_agent_get_info)\n+  DLSYM_FN (hsa_init)\n+  DLSYM_FN (hsa_iterate_agents)\n+  DLSYM_FN (hsa_region_get_info)\n+  DLSYM_FN (hsa_queue_create)\n+  DLSYM_FN (hsa_agent_iterate_regions)\n+  DLSYM_FN (hsa_executable_destroy)\n+  DLSYM_FN (hsa_executable_create)\n+  DLSYM_FN (hsa_executable_global_variable_define)\n+  DLSYM_FN (hsa_executable_load_code_object)\n+  DLSYM_FN (hsa_executable_freeze)\n+  DLSYM_FN (hsa_signal_create)\n+  DLSYM_FN (hsa_memory_allocate)\n+  DLSYM_FN (hsa_memory_copy)\n+  DLSYM_FN (hsa_memory_free)\n+  DLSYM_FN (hsa_signal_destroy)\n+  DLSYM_FN (hsa_executable_get_symbol)\n+  DLSYM_FN (hsa_executable_symbol_get_info)\n+  DLSYM_FN (hsa_signal_wait_acquire)\n+  DLSYM_FN (hsa_signal_wait_relaxed)\n+  DLSYM_FN (hsa_signal_store_relaxed)\n+  DLSYM_FN (hsa_queue_destroy)\n+  DLSYM_FN (hsa_code_object_deserialize)\n+  DLSYM_FN (hsa_queue_load_write_index_relaxed)\n+  DLSYM_FN (hsa_queue_store_write_index_relaxed)\n+  DLSYM_FN (hsa_shut_down)\n+\n+  return;\n+\n+fail:\n+  fprintf (stderr, \"Failed to find HSA functions in \" HSA_RUNTIME_LIB \"\\n\");\n+  exit (1);\n+}\n+\n+#undef DLSYM_FN\n+\n+/* Report a fatal error STR together with the HSA error corresponding to\n+   STATUS and terminate execution of the current process.  */\n+\n+static void\n+hsa_fatal (const char *str, hsa_status_t status)\n+{\n+  const char *hsa_error_msg;\n+  hsa_fns.hsa_status_string_fn (status, &hsa_error_msg);\n+  fprintf (stderr, \"%s: FAILED\\nHSA Runtime message: %s\\n\", str,\n+\t   hsa_error_msg);\n+  exit (1);\n+}\n+\n+/* Helper macros to ensure we check the return values from the HSA Runtime.\n+   These just keep the rest of the code a bit cleaner.  */\n+\n+#define XHSA_CMP(FN, CMP, MSG)\t\t   \\\n+  do {\t\t\t\t\t   \\\n+    hsa_status_t status = (FN);\t\t   \\\n+    if (!(CMP))\t\t\t\t   \\\n+      hsa_fatal ((MSG), status);\t   \\\n+    else if (debug)\t\t\t   \\\n+      fprintf (stderr, \"%s: OK\\n\", (MSG)); \\\n+  } while (0)\n+#define XHSA(FN, MSG) XHSA_CMP(FN, status == HSA_STATUS_SUCCESS, MSG)\n+\n+/* Callback of hsa_iterate_agents.\n+   Called once for each available device, and returns \"break\" when a\n+   suitable one has been found.  */\n+\n+static hsa_status_t\n+get_gpu_agent (hsa_agent_t agent, void *data __attribute__ ((unused)))\n+{\n+  hsa_device_type_t device_type;\n+  XHSA (hsa_fns.hsa_agent_get_info_fn (agent, HSA_AGENT_INFO_DEVICE,\n+\t\t\t\t       &device_type),\n+\t\"Get agent type\");\n+\n+  /* Select only GPU devices.  */\n+  /* TODO: support selecting from multiple GPUs.  */\n+  if (HSA_DEVICE_TYPE_GPU == device_type)\n+    {\n+      device = agent;\n+      return HSA_STATUS_INFO_BREAK;\n+    }\n+\n+  /* The device was not suitable.  */\n+  return HSA_STATUS_SUCCESS;\n+}\n+\n+/* Callback of hsa_iterate_regions.\n+   Called once for each available memory region, and returns \"break\" when a\n+   suitable one has been found.  */\n+\n+static hsa_status_t\n+get_kernarg_region (hsa_region_t region, void *data __attribute__ ((unused)))\n+{\n+  /* Reject non-global regions.  */\n+  hsa_region_segment_t segment;\n+  hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_SEGMENT, &segment);\n+  if (HSA_REGION_SEGMENT_GLOBAL != segment)\n+    return HSA_STATUS_SUCCESS;\n+\n+  /* Find a region with the KERNARG flag set.  */\n+  hsa_region_global_flag_t flags;\n+  hsa_fns.hsa_region_get_info_fn (region, HSA_REGION_INFO_GLOBAL_FLAGS,\n+\t\t\t\t  &flags);\n+  if (flags & HSA_REGION_GLOBAL_FLAG_KERNARG)\n+    {\n+      kernargs_region = region;\n+      return HSA_STATUS_INFO_BREAK;\n+    }\n+\n+  /* The region was not suitable.  */\n+  return HSA_STATUS_SUCCESS;\n+}\n+\n+/* Initialize the HSA Runtime library and GPU device.  */\n+\n+static void\n+init_device ()\n+{\n+  /* Load the shared library and find the API functions.  */\n+  init_hsa_runtime_functions ();\n+\n+  /* Initialize the HSA Runtime.  */\n+  XHSA (hsa_fns.hsa_init_fn (),\n+\t\"Initialize run-time\");\n+\n+  /* Select a suitable device.\n+     The call-back function, get_gpu_agent, does the selection.  */\n+  XHSA_CMP (hsa_fns.hsa_iterate_agents_fn (get_gpu_agent, NULL),\n+\t    status == HSA_STATUS_SUCCESS || status == HSA_STATUS_INFO_BREAK,\n+\t    \"Find a device\");\n+\n+  /* Initialize the queue used for launching kernels.  */\n+  uint32_t queue_size = 0;\n+  XHSA (hsa_fns.hsa_agent_get_info_fn (device, HSA_AGENT_INFO_QUEUE_MAX_SIZE,\n+\t\t\t\t       &queue_size),\n+\t\"Find max queue size\");\n+  XHSA (hsa_fns.hsa_queue_create_fn (device, queue_size,\n+\t\t\t\t     HSA_QUEUE_TYPE_SINGLE, NULL,\n+\t\t\t\t     NULL, UINT32_MAX, UINT32_MAX, &queue),\n+\t\"Set up a device queue\");\n+\n+  /* Select a memory region for the kernel arguments.\n+     The call-back function, get_kernarg_region, does the selection.  */\n+  XHSA_CMP (hsa_fns.hsa_agent_iterate_regions_fn (device, get_kernarg_region,\n+\t\t\t\t\t\t  NULL),\n+\t    status == HSA_STATUS_SUCCESS || status == HSA_STATUS_INFO_BREAK,\n+\t    \"Locate kernargs memory\");\n+}\n+\n+\n+/* Read a whole input file.\n+   Code copied from mkoffload. */\n+\n+static char *\n+read_file (const char *filename, size_t *plen)\n+{\n+  size_t alloc = 16384;\n+  size_t base = 0;\n+  char *buffer;\n+\n+  FILE *stream = fopen (filename, \"rb\");\n+  if (!stream)\n+    {\n+      perror (filename);\n+      exit (1);\n+    }\n+\n+  if (!fseek (stream, 0, SEEK_END))\n+    {\n+      /* Get the file size.  */\n+      long s = ftell (stream);\n+      if (s >= 0)\n+\talloc = s + 100;\n+      fseek (stream, 0, SEEK_SET);\n+    }\n+  buffer = malloc (alloc);\n+\n+  for (;;)\n+    {\n+      size_t n = fread (buffer + base, 1, alloc - base - 1, stream);\n+\n+      if (!n)\n+\tbreak;\n+      base += n;\n+      if (base + 1 == alloc)\n+\t{\n+\t  alloc *= 2;\n+\t  buffer = realloc (buffer, alloc);\n+\t}\n+    }\n+  buffer[base] = 0;\n+  *plen = base;\n+\n+  fclose (stream);\n+\n+  return buffer;\n+}\n+\n+/* Read a HSA Code Object (HSACO) from file, and load it into the device.  */\n+\n+static void\n+load_image (const char *filename)\n+{\n+  size_t image_size;\n+  Elf64_Ehdr *image = (void *) read_file (filename, &image_size);\n+\n+  /* An \"executable\" consists of one or more code objects.  */\n+  XHSA (hsa_fns.hsa_executable_create_fn (HSA_PROFILE_FULL,\n+\t\t\t\t\t  HSA_EXECUTABLE_STATE_UNFROZEN, \"\",\n+\t\t\t\t\t  &executable),\n+\t\"Initialize GCN executable\");\n+\n+  /* Hide relocations from the HSA runtime loader.\n+     Keep a copy of the unmodified section headers to use later.  */\n+  Elf64_Shdr *image_sections =\n+    (Elf64_Shdr *) ((char *) image + image->e_shoff);\n+  Elf64_Shdr *sections = malloc (sizeof (Elf64_Shdr) * image->e_shnum);\n+  memcpy (sections, image_sections, sizeof (Elf64_Shdr) * image->e_shnum);\n+  for (int i = image->e_shnum - 1; i >= 0; i--)\n+    {\n+      if (image_sections[i].sh_type == SHT_RELA\n+\t  || image_sections[i].sh_type == SHT_REL)\n+\t/* Change section type to something harmless.  */\n+\timage_sections[i].sh_type = SHT_NOTE;\n+    }\n+\n+  /* Add the HSACO to the executable.  */\n+  hsa_code_object_t co = { 0 };\n+  XHSA (hsa_fns.hsa_code_object_deserialize_fn (image, image_size, NULL, &co),\n+\t\"Deserialize GCN code object\");\n+  XHSA (hsa_fns.hsa_executable_load_code_object_fn (executable, device, co,\n+\t\t\t\t\t\t    \"\"),\n+\t\"Load GCN code object\");\n+\n+  /* We're done modifying he executable.  */\n+  XHSA (hsa_fns.hsa_executable_freeze_fn (executable, \"\"),\n+\t\"Freeze GCN executable\");\n+\n+  /* Locate the \"main\" function, and read the kernel's properties.  */\n+  hsa_executable_symbol_t symbol;\n+  XHSA (hsa_fns.hsa_executable_get_symbol_fn (executable, NULL, \"main\",\n+\t\t\t\t\t      device, 0, &symbol),\n+\t\"Find 'main' function\");\n+  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_OBJECT, &kernel),\n+\t\"Extract kernel object\");\n+  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_KERNARG_SEGMENT_SIZE,\n+\t     &kernarg_segment_size),\n+\t\"Extract kernarg segment size\");\n+  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_GROUP_SEGMENT_SIZE,\n+\t     &group_segment_size),\n+\t\"Extract group segment size\");\n+  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_KERNEL_PRIVATE_SEGMENT_SIZE,\n+\t     &private_segment_size),\n+\t\"Extract private segment size\");\n+\n+  /* Find main function in ELF, and calculate actual load offset.  */\n+  Elf64_Addr load_offset;\n+  XHSA (hsa_fns.hsa_executable_symbol_get_info_fn\n+\t    (symbol, HSA_EXECUTABLE_SYMBOL_INFO_VARIABLE_ADDRESS,\n+\t     &load_offset),\n+\t\"Extract 'main' symbol address\");\n+  for (int i = 0; i < image->e_shnum; i++)\n+    if (sections[i].sh_type == SHT_SYMTAB)\n+      {\n+\tElf64_Shdr *strtab = &sections[sections[i].sh_link];\n+\tchar *strings = (char *) image + strtab->sh_offset;\n+\n+\tfor (size_t offset = 0;\n+\t     offset < sections[i].sh_size;\n+\t     offset += sections[i].sh_entsize)\n+\t  {\n+\t    Elf64_Sym *sym = (Elf64_Sym *) ((char *) image\n+\t\t\t\t\t    + sections[i].sh_offset + offset);\n+\t    if (strcmp (\"main\", strings + sym->st_name) == 0)\n+\t      {\n+\t\tload_offset -= sym->st_value;\n+\t\tgoto found_main;\n+\t      }\n+\t  }\n+      }\n+  /* We only get here when main was not found.\n+     This should never happen.  */\n+  fprintf (stderr, \"Error: main function not found.\\n\");\n+  abort ();\n+found_main:;\n+\n+  /* Find dynamic symbol table.  */\n+  Elf64_Shdr *dynsym = NULL;\n+  for (int i = 0; i < image->e_shnum; i++)\n+    if (sections[i].sh_type == SHT_DYNSYM)\n+      {\n+\tdynsym = &sections[i];\n+\tbreak;\n+      }\n+\n+  /* Fix up relocations.  */\n+  for (int i = 0; i < image->e_shnum; i++)\n+    {\n+      if (sections[i].sh_type == SHT_RELA)\n+\tfor (size_t offset = 0;\n+\t     offset < sections[i].sh_size;\n+\t     offset += sections[i].sh_entsize)\n+\t  {\n+\t    Elf64_Rela *reloc = (Elf64_Rela *) ((char *) image\n+\t\t\t\t\t\t+ sections[i].sh_offset\n+\t\t\t\t\t\t+ offset);\n+\t    Elf64_Sym *sym =\n+\t      (dynsym\n+\t       ? (Elf64_Sym *) ((char *) image\n+\t\t\t\t+ dynsym->sh_offset\n+\t\t\t\t+ (dynsym->sh_entsize\n+\t\t\t\t   * ELF64_R_SYM (reloc->r_info))) : NULL);\n+\n+\t    int64_t S = (sym ? sym->st_value : 0);\n+\t    int64_t P = reloc->r_offset + load_offset;\n+\t    int64_t A = reloc->r_addend;\n+\t    int64_t B = load_offset;\n+\t    int64_t V, size;\n+\t    switch (ELF64_R_TYPE (reloc->r_info))\n+\t      {\n+\t      case R_AMDGPU_ABS32_LO:\n+\t\tV = (S + A) & 0xFFFFFFFF;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      case R_AMDGPU_ABS32_HI:\n+\t\tV = (S + A) >> 32;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      case R_AMDGPU_ABS64:\n+\t\tV = S + A;\n+\t\tsize = 8;\n+\t\tbreak;\n+\t      case R_AMDGPU_REL32:\n+\t\tV = S + A - P;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      case R_AMDGPU_REL64:\n+\t\t/* FIXME\n+\t\t   LLD seems to emit REL64 where the the assembler has ABS64.\n+\t\t   This is clearly wrong because it's not what the compiler\n+\t\t   is expecting.  Let's assume, for now, that it's a bug.\n+\t\t   In any case, GCN kernels are always self contained and\n+\t\t   therefore relative relocations will have been resolved\n+\t\t   already, so this should be a safe workaround.  */\n+\t\tV = S + A /* - P */ ;\n+\t\tsize = 8;\n+\t\tbreak;\n+\t      case R_AMDGPU_ABS32:\n+\t\tV = S + A;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      /* TODO R_AMDGPU_GOTPCREL */\n+\t      /* TODO R_AMDGPU_GOTPCREL32_LO */\n+\t      /* TODO R_AMDGPU_GOTPCREL32_HI */\n+\t      case R_AMDGPU_REL32_LO:\n+\t\tV = (S + A - P) & 0xFFFFFFFF;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      case R_AMDGPU_REL32_HI:\n+\t\tV = (S + A - P) >> 32;\n+\t\tsize = 4;\n+\t\tbreak;\n+\t      case R_AMDGPU_RELATIVE64:\n+\t\tV = B + A;\n+\t\tsize = 8;\n+\t\tbreak;\n+\t      default:\n+\t\tfprintf (stderr, \"Error: unsupported relocation type.\\n\");\n+\t\texit (1);\n+\t      }\n+\t    XHSA (hsa_fns.hsa_memory_copy_fn ((void *) P, &V, size),\n+\t\t  \"Fix up relocation\");\n+\t  }\n+    }\n+}\n+\n+/* Allocate some device memory from the kernargs region.\n+   The returned address will be 32-bit (with excess zeroed on 64-bit host),\n+   and accessible via the same address on both host and target (via\n+   __flat_scalar GCN address space).  */\n+\n+static void *\n+device_malloc (size_t size)\n+{\n+  void *result;\n+  XHSA (hsa_fns.hsa_memory_allocate_fn (kernargs_region, size, &result),\n+\t\"Allocate device memory\");\n+  return result;\n+}\n+\n+/* These are the device pointers that will be transferred to the target.\n+   The HSA Runtime points the kernargs register here.\n+   They correspond to function signature:\n+       int main (int argc, char *argv[], int *return_value)\n+   The compiler expects this, for kernel functions, and will\n+   automatically assign the exit value to *return_value.  */\n+struct kernargs\n+{\n+  /* Kernargs.  */\n+  int32_t argc;\n+  int64_t argv;\n+  int64_t out_ptr;\n+  int64_t heap_ptr;\n+\n+  /* Output data.  */\n+  struct output\n+  {\n+    int return_value;\n+    int next_output;\n+    struct printf_data\n+    {\n+      int written;\n+      char msg[128];\n+      int type;\n+      union\n+      {\n+\tint64_t ivalue;\n+\tdouble dvalue;\n+\tchar text[128];\n+      };\n+    } queue[1000];\n+  } output_data;\n+\n+  struct heap\n+  {\n+    int64_t size;\n+    char data[0];\n+  } heap;\n+};\n+\n+/* Print any console output from the kernel.\n+   We print all entries from print_index to the next entry without a \"written\"\n+   flag.  Subsequent calls should use the returned print_index value to resume\n+   from the same point.  */\n+void\n+gomp_print_output (struct kernargs *kernargs, int *print_index)\n+{\n+  int limit = (sizeof (kernargs->output_data.queue)\n+\t       / sizeof (kernargs->output_data.queue[0]));\n+\n+  int i;\n+  for (i = *print_index; i < limit; i++)\n+    {\n+      struct printf_data *data = &kernargs->output_data.queue[i];\n+\n+      if (!data->written)\n+\tbreak;\n+\n+      switch (data->type)\n+\t{\n+\tcase 0:\n+\t  printf (\"%.128s%ld\\n\", data->msg, data->ivalue);\n+\t  break;\n+\tcase 1:\n+\t  printf (\"%.128s%f\\n\", data->msg, data->dvalue);\n+\t  break;\n+\tcase 2:\n+\t  printf (\"%.128s%.128s\\n\", data->msg, data->text);\n+\t  break;\n+\tcase 3:\n+\t  printf (\"%.128s%.128s\", data->msg, data->text);\n+\t  break;\n+\t}\n+\n+      data->written = 0;\n+    }\n+\n+  if (*print_index < limit && i == limit\n+      && kernargs->output_data.next_output > limit)\n+    printf (\"WARNING: GCN print buffer exhausted.\\n\");\n+\n+  *print_index = i;\n+}\n+\n+/* Execute an already-loaded kernel on the device.  */\n+\n+static void\n+run (void *kernargs)\n+{\n+  /* A \"signal\" is used to launch and monitor the kernel.  */\n+  hsa_signal_t signal;\n+  XHSA (hsa_fns.hsa_signal_create_fn (1, 0, NULL, &signal),\n+\t\"Create signal\");\n+\n+  /* Configure for a single-worker kernel.  */\n+  uint64_t index = hsa_fns.hsa_queue_load_write_index_relaxed_fn (queue);\n+  const uint32_t queueMask = queue->size - 1;\n+  hsa_kernel_dispatch_packet_t *dispatch_packet =\n+    &(((hsa_kernel_dispatch_packet_t *) (queue->base_address))[index &\n+\t\t\t\t\t\t\t       queueMask]);\n+  dispatch_packet->setup |= 3 << HSA_KERNEL_DISPATCH_PACKET_SETUP_DIMENSIONS;\n+  dispatch_packet->workgroup_size_x = (uint16_t) 1;\n+  dispatch_packet->workgroup_size_y = (uint16_t) 64;\n+  dispatch_packet->workgroup_size_z = (uint16_t) 1;\n+  dispatch_packet->grid_size_x = 1;\n+  dispatch_packet->grid_size_y = 64;\n+  dispatch_packet->grid_size_z = 1;\n+  dispatch_packet->completion_signal = signal;\n+  dispatch_packet->kernel_object = kernel;\n+  dispatch_packet->kernarg_address = (void *) kernargs;\n+  dispatch_packet->private_segment_size = private_segment_size;\n+  dispatch_packet->group_segment_size = group_segment_size;\n+\n+  uint16_t header = 0;\n+  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_ACQUIRE_FENCE_SCOPE;\n+  header |= HSA_FENCE_SCOPE_SYSTEM << HSA_PACKET_HEADER_RELEASE_FENCE_SCOPE;\n+  header |= HSA_PACKET_TYPE_KERNEL_DISPATCH << HSA_PACKET_HEADER_TYPE;\n+\n+  __atomic_store_n ((uint32_t *) dispatch_packet,\n+\t\t    header | (dispatch_packet->setup << 16),\n+\t\t    __ATOMIC_RELEASE);\n+\n+  if (debug)\n+    fprintf (stderr, \"Launch kernel\\n\");\n+\n+  hsa_fns.hsa_queue_store_write_index_relaxed_fn (queue, index + 1);\n+  hsa_fns.hsa_signal_store_relaxed_fn (queue->doorbell_signal, index);\n+  /* Kernel running ......  */\n+  int print_index = 0;\n+  while (hsa_fns.hsa_signal_wait_relaxed_fn (signal, HSA_SIGNAL_CONDITION_LT,\n+\t\t\t\t\t     1, 1000000,\n+\t\t\t\t\t     HSA_WAIT_STATE_ACTIVE) != 0)\n+    {\n+      usleep (10000);\n+      gomp_print_output (kernargs, &print_index);\n+    }\n+\n+  gomp_print_output (kernargs, &print_index);\n+\n+  if (debug)\n+    fprintf (stderr, \"Kernel exited\\n\");\n+\n+  XHSA (hsa_fns.hsa_signal_destroy_fn (signal),\n+\t\"Clean up signal\");\n+}\n+\n+int\n+main (int argc, char *argv[])\n+{\n+  int kernel_arg = 0;\n+  for (int i = 1; i < argc; i++)\n+    {\n+      if (!strcmp (argv[i], \"--help\"))\n+\t{\n+\t  usage (argv[0]);\n+\t  return 0;\n+\t}\n+      else if (!strcmp (argv[i], \"--version\"))\n+\t{\n+\t  version (argv[0]);\n+\t  return 0;\n+\t}\n+      else if (!strcmp (argv[i], \"--debug\"))\n+\tdebug = true;\n+      else if (argv[i][0] == '-')\n+\t{\n+\t  usage (argv[0]);\n+\t  return 1;\n+\t}\n+      else\n+\t{\n+\t  kernel_arg = i;\n+\t  break;\n+\t}\n+    }\n+\n+  if (!kernel_arg)\n+    {\n+      /* No kernel arguments were found.  */\n+      usage (argv[0]);\n+      return 1;\n+    }\n+\n+  /* The remaining arguments are for the GCN kernel.  */\n+  int kernel_argc = argc - kernel_arg;\n+  char **kernel_argv = &argv[kernel_arg];\n+\n+  init_device ();\n+  load_image (kernel_argv[0]);\n+\n+  /* Calculate size of function parameters + argv data.  */\n+  size_t args_size = 0;\n+  for (int i = 0; i < kernel_argc; i++)\n+    args_size += strlen (kernel_argv[i]) + 1;\n+\n+  /* Allocate device memory for both function parameters and the argv\n+     data.  */\n+  size_t heap_size = 10 * 1024 * 1024;\t/* 10MB.  */\n+  struct kernargs *kernargs = device_malloc (sizeof (*kernargs) + heap_size);\n+  struct argdata\n+  {\n+    int64_t argv_data[kernel_argc];\n+    char strings[args_size];\n+  } *args = device_malloc (sizeof (struct argdata));\n+\n+  /* Write the data to the target.  */\n+  kernargs->argc = kernel_argc;\n+  kernargs->argv = (int64_t) args->argv_data;\n+  kernargs->out_ptr = (int64_t) &kernargs->output_data;\n+  kernargs->output_data.return_value = 0xcafe0000; /* Default return value. */\n+  kernargs->output_data.next_output = 0;\n+  for (unsigned i = 0; i < (sizeof (kernargs->output_data.queue)\n+\t\t\t    / sizeof (kernargs->output_data.queue[0])); i++)\n+    kernargs->output_data.queue[i].written = 0;\n+  int offset = 0;\n+  for (int i = 0; i < kernel_argc; i++)\n+    {\n+      size_t arg_len = strlen (kernel_argv[i]) + 1;\n+      args->argv_data[i] = (int64_t) &args->strings[offset];\n+      memcpy (&args->strings[offset], kernel_argv[i], arg_len + 1);\n+      offset += arg_len;\n+    }\n+  kernargs->heap_ptr = (int64_t) &kernargs->heap;\n+  kernargs->heap.size = heap_size;\n+\n+  /* Run the kernel on the GPU.  */\n+  run (kernargs);\n+  unsigned int return_value =\n+    (unsigned int) kernargs->output_data.return_value;\n+\n+  unsigned int upper = (return_value & ~0xffff) >> 16;\n+  if (upper == 0xcafe)\n+    printf (\"Kernel exit value was never set\\n\");\n+  else if (upper == 0xffff)\n+    ; /* Set by exit.  */\n+  else if (upper == 0)\n+    ; /* Set by return from main.  */\n+  else\n+    printf (\"Possible kernel exit value corruption, 2 most significant bytes \"\n+\t    \"aren't 0xffff, 0xcafe, or 0: 0x%x\\n\", return_value);\n+\n+  if (upper == 0xffff)\n+    {\n+      unsigned int signal = (return_value >> 8) & 0xff;\n+      if (signal == SIGABRT)\n+\tprintf (\"Kernel aborted\\n\");\n+      else if (signal != 0)\n+\tprintf (\"Kernel received unkown signal\\n\");\n+    }\n+\n+  if (debug)\n+    printf (\"Kernel exit value: %d\\n\", return_value & 0xff);\n+\n+  /* Clean shut down.  */\n+  XHSA (hsa_fns.hsa_memory_free_fn (kernargs),\n+\t\"Clean up device memory\");\n+  XHSA (hsa_fns.hsa_executable_destroy_fn (executable),\n+\t\"Clean up GCN executable\");\n+  XHSA (hsa_fns.hsa_queue_destroy_fn (queue),\n+\t\"Clean up device queue\");\n+  XHSA (hsa_fns.hsa_shut_down_fn (),\n+\t\"Shut down run-time\");\n+\n+  return return_value & 0xff;\n+}"}, {"sha": "c6b6302e9ed4d63339d49767d19c8e4615b725cb", "filename": "gcc/config/gcn/gcn-tree.c", "status": "added", "additions": 721, "deletions": 0, "changes": 721, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn-tree.c?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,721 @@\n+/* Copyright (C) 2017-2019 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+   \n+   GCC is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3, or (at your option) any later\n+   version.\n+   \n+   GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+   WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+   \n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+/* {{{ Includes.  */\n+\n+#include \"config.h\"\n+#include \"system.h\"\n+#include \"coretypes.h\"\n+#include \"backend.h\"\n+#include \"target.h\"\n+#include \"tree.h\"\n+#include \"gimple.h\"\n+#include \"tree-pass.h\"\n+#include \"gimple-iterator.h\"\n+#include \"cfghooks.h\"\n+#include \"cfgloop.h\"\n+#include \"tm_p.h\"\n+#include \"stringpool.h\"\n+#include \"fold-const.h\"\n+#include \"varasm.h\"\n+#include \"omp-low.h\"\n+#include \"omp-general.h\"\n+#include \"internal-fn.h\"\n+#include \"tree-vrp.h\"\n+#include \"tree-ssanames.h\"\n+#include \"tree-ssa-operands.h\"\n+#include \"gimplify.h\"\n+#include \"tree-phinodes.h\"\n+#include \"cgraph.h\"\n+#include \"targhooks.h\"\n+#include \"langhooks-def.h\"\n+\n+/* }}}  */\n+/* {{{ OMP GCN pass.\n+ \n+   This pass is intended to make any GCN-specfic transformations to OpenMP\n+   target regions.\n+ \n+   At present, its only purpose is to convert some \"omp\" built-in functions\n+   to use closer-to-the-metal \"gcn\" built-in functions.  */\n+\n+unsigned int\n+execute_omp_gcn (void)\n+{\n+  tree thr_num_tree = builtin_decl_explicit (BUILT_IN_OMP_GET_THREAD_NUM);\n+  tree thr_num_id = DECL_NAME (thr_num_tree);\n+  tree team_num_tree = builtin_decl_explicit (BUILT_IN_OMP_GET_TEAM_NUM);\n+  tree team_num_id = DECL_NAME (team_num_tree);\n+  basic_block bb;\n+  gimple_stmt_iterator gsi;\n+  unsigned int todo = 0;\n+\n+  FOR_EACH_BB_FN (bb, cfun)\n+    for (gsi = gsi_start_bb (bb); !gsi_end_p (gsi); gsi_next (&gsi))\n+    {\n+      gimple *call = gsi_stmt (gsi);\n+      tree decl;\n+\n+      if (is_gimple_call (call) && (decl = gimple_call_fndecl (call)))\n+\t{\n+\t  tree decl_id = DECL_NAME (decl);\n+\t  tree lhs = gimple_get_lhs (call);\n+\n+\t  if (decl_id == thr_num_id)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"Replace '%s' with __builtin_gcn_dim_pos.\\n\",\n+\t\t\t IDENTIFIER_POINTER (decl_id));\n+\n+\t      /* Transform this:\n+\t         lhs = __builtin_omp_get_thread_num ()\n+\t         to this:\n+\t         lhs = __builtin_gcn_dim_pos (1)  */\n+\t      tree fn = targetm.builtin_decl (GCN_BUILTIN_OMP_DIM_POS, 0);\n+\t      tree fnarg = build_int_cst (unsigned_type_node, 1);\n+\t      gimple *stmt = gimple_build_call (fn, 1, fnarg);\n+\t      gimple_call_set_lhs (stmt, lhs);\n+\t      gsi_replace (&gsi, stmt, true);\n+\n+\t      todo |= TODO_update_ssa;\n+\t    }\n+\t  else if (decl_id == team_num_id)\n+\t    {\n+\t      if (dump_file && (dump_flags & TDF_DETAILS))\n+\t\tfprintf (dump_file,\n+\t\t\t \"Replace '%s' with __builtin_gcn_dim_pos.\\n\",\n+\t\t\t IDENTIFIER_POINTER (decl_id));\n+\n+\t      /* Transform this:\n+\t         lhs = __builtin_omp_get_team_num ()\n+\t         to this:\n+\t         lhs = __builtin_gcn_dim_pos (0)  */\n+\t      tree fn = targetm.builtin_decl (GCN_BUILTIN_OMP_DIM_POS, 0);\n+\t      tree fnarg = build_zero_cst (unsigned_type_node);\n+\t      gimple *stmt = gimple_build_call (fn, 1, fnarg);\n+\t      gimple_call_set_lhs (stmt, lhs);\n+\t      gsi_replace (&gsi, stmt, true);\n+\n+\t      todo |= TODO_update_ssa;\n+\t    }\n+\t}\n+    }\n+\n+  return todo;\n+}\n+\n+namespace\n+{\n+\n+  const pass_data pass_data_omp_gcn = {\n+    GIMPLE_PASS,\n+    \"omp_gcn\",\t\t\t/* name */\n+    OPTGROUP_NONE,\t\t/* optinfo_flags */\n+    TV_NONE,\t\t\t/* tv_id */\n+    0,\t\t\t\t/* properties_required */\n+    0,\t\t\t\t/* properties_provided */\n+    0,\t\t\t\t/* properties_destroyed */\n+    0,\t\t\t\t/* todo_flags_start */\n+    TODO_df_finish,\t\t/* todo_flags_finish */\n+  };\n+\n+  class pass_omp_gcn : public gimple_opt_pass\n+  {\n+  public:\n+    pass_omp_gcn (gcc::context *ctxt)\n+      : gimple_opt_pass (pass_data_omp_gcn, ctxt)\n+    {\n+    }\n+\n+    /* opt_pass methods: */\n+    virtual bool gate (function *)\n+    {\n+      return flag_openmp;\n+    }\n+\n+    virtual unsigned int execute (function *)\n+    {\n+      return execute_omp_gcn ();\n+    }\n+\n+  }; /* class pass_omp_gcn.  */\n+\n+} /* anon namespace.  */\n+\n+gimple_opt_pass *\n+make_pass_omp_gcn (gcc::context *ctxt)\n+{\n+  return new pass_omp_gcn (ctxt);\n+}\n+\n+/* }}}  */\n+/* {{{ OpenACC reductions.  */\n+\n+/* Global lock variable, needed for 128bit worker & gang reductions.  */\n+\n+static GTY(()) tree global_lock_var;\n+\n+/* Lazily generate the global_lock_var decl and return its address.  */\n+\n+static tree\n+gcn_global_lock_addr ()\n+{\n+  tree v = global_lock_var;\n+\n+  if (!v)\n+    {\n+      tree name = get_identifier (\"__reduction_lock\");\n+      tree type = build_qualified_type (unsigned_type_node,\n+\t\t\t\t\tTYPE_QUAL_VOLATILE);\n+      v = build_decl (BUILTINS_LOCATION, VAR_DECL, name, type);\n+      global_lock_var = v;\n+      DECL_ARTIFICIAL (v) = 1;\n+      DECL_EXTERNAL (v) = 1;\n+      TREE_STATIC (v) = 1;\n+      TREE_PUBLIC (v) = 1;\n+      TREE_USED (v) = 1;\n+      mark_addressable (v);\n+      mark_decl_referenced (v);\n+    }\n+\n+  return build_fold_addr_expr (v);\n+}\n+\n+/* Helper function for gcn_reduction_update.\n+\n+   Insert code to locklessly update *PTR with *PTR OP VAR just before\n+   GSI.  We use a lockless scheme for nearly all case, which looks\n+   like:\n+     actual = initval (OP);\n+     do {\n+       guess = actual;\n+       write = guess OP myval;\n+       actual = cmp&swap (ptr, guess, write)\n+     } while (actual bit-different-to guess);\n+   return write;\n+\n+   This relies on a cmp&swap instruction, which is available for 32- and\n+   64-bit types.  Larger types must use a locking scheme.  */\n+\n+static tree\n+gcn_lockless_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t     tree ptr, tree var, tree_code op)\n+{\n+  unsigned fn = GCN_BUILTIN_CMP_SWAP;\n+  tree_code code = NOP_EXPR;\n+  tree arg_type = unsigned_type_node;\n+  tree var_type = TREE_TYPE (var);\n+\n+  if (TREE_CODE (var_type) == COMPLEX_TYPE\n+      || TREE_CODE (var_type) == REAL_TYPE)\n+    code = VIEW_CONVERT_EXPR;\n+\n+  if (TYPE_SIZE (var_type) == TYPE_SIZE (long_long_unsigned_type_node))\n+    {\n+      arg_type = long_long_unsigned_type_node;\n+      fn = GCN_BUILTIN_CMP_SWAPLL;\n+    }\n+\n+  tree swap_fn = gcn_builtin_decl (fn, true);\n+\n+  gimple_seq init_seq = NULL;\n+  tree init_var = make_ssa_name (arg_type);\n+  tree init_expr = omp_reduction_init_op (loc, op, var_type);\n+  init_expr = fold_build1 (code, arg_type, init_expr);\n+  gimplify_assign (init_var, init_expr, &init_seq);\n+  gimple *init_end = gimple_seq_last (init_seq);\n+\n+  gsi_insert_seq_before (gsi, init_seq, GSI_SAME_STMT);\n+\n+  /* Split the block just after the init stmts.  */\n+  basic_block pre_bb = gsi_bb (*gsi);\n+  edge pre_edge = split_block (pre_bb, init_end);\n+  basic_block loop_bb = pre_edge->dest;\n+  pre_bb = pre_edge->src;\n+  /* Reset the iterator.  */\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  tree expect_var = make_ssa_name (arg_type);\n+  tree actual_var = make_ssa_name (arg_type);\n+  tree write_var = make_ssa_name (arg_type);\n+\n+  /* Build and insert the reduction calculation.  */\n+  gimple_seq red_seq = NULL;\n+  tree write_expr = fold_build1 (code, var_type, expect_var);\n+  write_expr = fold_build2 (op, var_type, write_expr, var);\n+  write_expr = fold_build1 (code, arg_type, write_expr);\n+  gimplify_assign (write_var, write_expr, &red_seq);\n+\n+  gsi_insert_seq_before (gsi, red_seq, GSI_SAME_STMT);\n+\n+  /* Build & insert the cmp&swap sequence.  */\n+  gimple_seq latch_seq = NULL;\n+  tree swap_expr = build_call_expr_loc (loc, swap_fn, 3,\n+\t\t\t\t\tptr, expect_var, write_var);\n+  gimplify_assign (actual_var, swap_expr, &latch_seq);\n+\n+  gcond *cond = gimple_build_cond (EQ_EXPR, actual_var, expect_var,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (&latch_seq, cond);\n+\n+  gimple *latch_end = gimple_seq_last (latch_seq);\n+  gsi_insert_seq_before (gsi, latch_seq, GSI_SAME_STMT);\n+\n+  /* Split the block just after the latch stmts.  */\n+  edge post_edge = split_block (loop_bb, latch_end);\n+  basic_block post_bb = post_edge->dest;\n+  loop_bb = post_edge->src;\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  post_edge->flags ^= EDGE_TRUE_VALUE | EDGE_FALLTHRU;\n+  /* post_edge->probability = profile_probability::even ();  */\n+  edge loop_edge = make_edge (loop_bb, loop_bb, EDGE_FALSE_VALUE);\n+  /* loop_edge->probability = profile_probability::even ();  */\n+  set_immediate_dominator (CDI_DOMINATORS, loop_bb, pre_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, post_bb, loop_bb);\n+\n+  gphi *phi = create_phi_node (expect_var, loop_bb);\n+  add_phi_arg (phi, init_var, pre_edge, loc);\n+  add_phi_arg (phi, actual_var, loop_edge, loc);\n+\n+  loop *loop = alloc_loop ();\n+  loop->header = loop_bb;\n+  loop->latch = loop_bb;\n+  add_loop (loop, loop_bb->loop_father);\n+\n+  return fold_build1 (code, var_type, write_var);\n+}\n+\n+/* Helper function for gcn_reduction_update.\n+   \n+   Insert code to lockfully update *PTR with *PTR OP VAR just before\n+   GSI.  This is necessary for types larger than 64 bits, where there\n+   is no cmp&swap instruction to implement a lockless scheme.  We use\n+   a lock variable in global memory.\n+\n+   while (cmp&swap (&lock_var, 0, 1))\n+     continue;\n+   T accum = *ptr;\n+   accum = accum OP var;\n+   *ptr = accum;\n+   cmp&swap (&lock_var, 1, 0);\n+   return accum;\n+\n+   A lock in global memory is necessary to force execution engine\n+   descheduling and avoid resource starvation that can occur if the\n+   lock is in shared memory.  */\n+\n+static tree\n+gcn_lockfull_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t     tree ptr, tree var, tree_code op)\n+{\n+  tree var_type = TREE_TYPE (var);\n+  tree swap_fn = gcn_builtin_decl (GCN_BUILTIN_CMP_SWAP, true);\n+  tree uns_unlocked = build_int_cst (unsigned_type_node, 0);\n+  tree uns_locked = build_int_cst (unsigned_type_node, 1);\n+\n+  /* Split the block just before the gsi.  Insert a gimple nop to make\n+     this easier.  */\n+  gimple *nop = gimple_build_nop ();\n+  gsi_insert_before (gsi, nop, GSI_SAME_STMT);\n+  basic_block entry_bb = gsi_bb (*gsi);\n+  edge entry_edge = split_block (entry_bb, nop);\n+  basic_block lock_bb = entry_edge->dest;\n+  /* Reset the iterator.  */\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  /* Build and insert the locking sequence.  */\n+  gimple_seq lock_seq = NULL;\n+  tree lock_var = make_ssa_name (unsigned_type_node);\n+  tree lock_expr = gcn_global_lock_addr ();\n+  lock_expr = build_call_expr_loc (loc, swap_fn, 3, lock_expr,\n+\t\t\t\t   uns_unlocked, uns_locked);\n+  gimplify_assign (lock_var, lock_expr, &lock_seq);\n+  gcond *cond = gimple_build_cond (EQ_EXPR, lock_var, uns_unlocked,\n+\t\t\t\t   NULL_TREE, NULL_TREE);\n+  gimple_seq_add_stmt (&lock_seq, cond);\n+  gimple *lock_end = gimple_seq_last (lock_seq);\n+  gsi_insert_seq_before (gsi, lock_seq, GSI_SAME_STMT);\n+\n+  /* Split the block just after the lock sequence.  */\n+  edge locked_edge = split_block (lock_bb, lock_end);\n+  basic_block update_bb = locked_edge->dest;\n+  lock_bb = locked_edge->src;\n+  *gsi = gsi_for_stmt (gsi_stmt (*gsi));\n+\n+  /* Create the lock loop.  */\n+  locked_edge->flags ^= EDGE_TRUE_VALUE | EDGE_FALLTHRU;\n+  locked_edge->probability = profile_probability::even ();\n+  edge loop_edge = make_edge (lock_bb, lock_bb, EDGE_FALSE_VALUE);\n+  loop_edge->probability = profile_probability::even ();\n+  set_immediate_dominator (CDI_DOMINATORS, lock_bb, entry_bb);\n+  set_immediate_dominator (CDI_DOMINATORS, update_bb, lock_bb);\n+\n+  /* Create the loop structure.  */\n+  loop *lock_loop = alloc_loop ();\n+  lock_loop->header = lock_bb;\n+  lock_loop->latch = lock_bb;\n+  lock_loop->nb_iterations_estimate = 1;\n+  lock_loop->any_estimate = true;\n+  add_loop (lock_loop, entry_bb->loop_father);\n+\n+  /* Build and insert the reduction calculation.  */\n+  gimple_seq red_seq = NULL;\n+  tree acc_in = make_ssa_name (var_type);\n+  tree ref_in = build_simple_mem_ref (ptr);\n+  TREE_THIS_VOLATILE (ref_in) = 1;\n+  gimplify_assign (acc_in, ref_in, &red_seq);\n+\n+  tree acc_out = make_ssa_name (var_type);\n+  tree update_expr = fold_build2 (op, var_type, ref_in, var);\n+  gimplify_assign (acc_out, update_expr, &red_seq);\n+\n+  tree ref_out = build_simple_mem_ref (ptr);\n+  TREE_THIS_VOLATILE (ref_out) = 1;\n+  gimplify_assign (ref_out, acc_out, &red_seq);\n+\n+  gsi_insert_seq_before (gsi, red_seq, GSI_SAME_STMT);\n+\n+  /* Build & insert the unlock sequence.  */\n+  gimple_seq unlock_seq = NULL;\n+  tree unlock_expr = gcn_global_lock_addr ();\n+  unlock_expr = build_call_expr_loc (loc, swap_fn, 3, unlock_expr,\n+\t\t\t\t     uns_locked, uns_unlocked);\n+  gimplify_and_add (unlock_expr, &unlock_seq);\n+  gsi_insert_seq_before (gsi, unlock_seq, GSI_SAME_STMT);\n+\n+  return acc_out;\n+}\n+\n+/* Emit a sequence to update a reduction accumulator at *PTR with the\n+   value held in VAR using operator OP.  Return the updated value.\n+\n+   TODO: optimize for atomic ops and independent complex ops.  */\n+\n+static tree\n+gcn_reduction_update (location_t loc, gimple_stmt_iterator *gsi,\n+\t\t      tree ptr, tree var, tree_code op)\n+{\n+  tree type = TREE_TYPE (var);\n+  tree size = TYPE_SIZE (type);\n+\n+  if (size == TYPE_SIZE (unsigned_type_node)\n+      || size == TYPE_SIZE (long_long_unsigned_type_node))\n+    return gcn_lockless_update (loc, gsi, ptr, var, op);\n+  else\n+    return gcn_lockfull_update (loc, gsi, ptr, var, op);\n+}\n+\n+/* Return a temporary variable decl to use for an OpenACC worker reduction.  */\n+\n+static tree\n+gcn_goacc_get_worker_red_decl (tree type, unsigned offset)\n+{\n+  machine_function *machfun = cfun->machine;\n+  tree existing_decl;\n+\n+  if (TREE_CODE (type) == REFERENCE_TYPE)\n+    type = TREE_TYPE (type);\n+\n+  tree var_type\n+    = build_qualified_type (type,\n+\t\t\t    (TYPE_QUALS (type)\n+\t\t\t     | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_LDS)));\n+\n+  if (machfun->reduc_decls\n+      && offset < machfun->reduc_decls->length ()\n+      && (existing_decl = (*machfun->reduc_decls)[offset]))\n+    {\n+      gcc_assert (TREE_TYPE (existing_decl) == var_type);\n+      return existing_decl;\n+    }\n+  else\n+    {\n+      char name[50];\n+      sprintf (name, \".oacc_reduction_%u\", offset);\n+      tree decl = create_tmp_var_raw (var_type, name);\n+\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+      TREE_STATIC (decl) = 1;\n+\n+      varpool_node::finalize_decl (decl);\n+\n+      vec_safe_grow_cleared (machfun->reduc_decls, offset + 1);\n+      (*machfun->reduc_decls)[offset] = decl;\n+\n+      return decl;\n+    }\n+\n+  return NULL_TREE;\n+}\n+\n+/* Expand IFN_GOACC_REDUCTION_SETUP.  */\n+\n+static void\n+gcn_goacc_reduction_setup (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  gimple_seq seq = NULL;\n+\n+  push_gimplify_context (true);\n+\n+  if (level != GOMP_DIM_GANG)\n+    {\n+      /* Copy the receiver object.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+\n+      if (!integer_zerop (ref_to_res))\n+\tvar = build_simple_mem_ref (ref_to_res);\n+    }\n+\n+  if (level == GOMP_DIM_WORKER)\n+    {\n+      tree var_type = TREE_TYPE (var);\n+      /* Store incoming value to worker reduction buffer.  */\n+      tree offset = gimple_call_arg (call, 5);\n+      tree decl\n+\t= gcn_goacc_get_worker_red_decl (var_type, TREE_INT_CST_LOW (offset));\n+\n+      gimplify_assign (decl, var, &seq);\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, var, &seq);\n+\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* Expand IFN_GOACC_REDUCTION_INIT.  */\n+\n+static void\n+gcn_goacc_reduction_init (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  enum tree_code rcode\n+    = (enum tree_code) TREE_INT_CST_LOW (gimple_call_arg (call, 4));\n+  tree init = omp_reduction_init_op (gimple_location (call), rcode,\n+\t\t\t\t     TREE_TYPE (var));\n+  gimple_seq seq = NULL;\n+\n+  push_gimplify_context (true);\n+\n+  if (level == GOMP_DIM_GANG)\n+    {\n+      /* If there's no receiver object, propagate the incoming VAR.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+      if (integer_zerop (ref_to_res))\n+\tinit = var;\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, init, &seq);\n+\n+  pop_gimplify_context (NULL);\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* Expand IFN_GOACC_REDUCTION_FINI.  */\n+\n+static void\n+gcn_goacc_reduction_fini (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree ref_to_res = gimple_call_arg (call, 1);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  enum tree_code op\n+    = (enum tree_code) TREE_INT_CST_LOW (gimple_call_arg (call, 4));\n+  gimple_seq seq = NULL;\n+  tree r = NULL_TREE;;\n+\n+  push_gimplify_context (true);\n+\n+  tree accum = NULL_TREE;\n+\n+  if (level == GOMP_DIM_WORKER)\n+    {\n+      tree var_type = TREE_TYPE (var);\n+      tree offset = gimple_call_arg (call, 5);\n+      tree decl\n+\t= gcn_goacc_get_worker_red_decl (var_type, TREE_INT_CST_LOW (offset));\n+\n+      accum = build_fold_addr_expr (decl);\n+    }\n+  else if (integer_zerop (ref_to_res))\n+    r = var;\n+  else\n+    accum = ref_to_res;\n+\n+  if (accum)\n+    {\n+      /* UPDATE the accumulator.  */\n+      gsi_insert_seq_before (&gsi, seq, GSI_SAME_STMT);\n+      seq = NULL;\n+      r = gcn_reduction_update (gimple_location (call), &gsi, accum, var, op);\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, r, &seq);\n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* Expand IFN_GOACC_REDUCTION_TEARDOWN.  */\n+\n+static void\n+gcn_goacc_reduction_teardown (gcall *call)\n+{\n+  gimple_stmt_iterator gsi = gsi_for_stmt (call);\n+  tree lhs = gimple_call_lhs (call);\n+  tree var = gimple_call_arg (call, 2);\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+  gimple_seq seq = NULL;\n+\n+  push_gimplify_context (true);\n+\n+  if (level == GOMP_DIM_WORKER)\n+    {\n+      tree var_type = TREE_TYPE (var);\n+\n+      /* Read the worker reduction buffer.  */\n+      tree offset = gimple_call_arg (call, 5);\n+      tree decl\n+\t= gcn_goacc_get_worker_red_decl (var_type, TREE_INT_CST_LOW (offset));\n+      var = decl;\n+    }\n+\n+  if (level != GOMP_DIM_GANG)\n+    {\n+      /* Write to the receiver object.  */\n+      tree ref_to_res = gimple_call_arg (call, 1);\n+\n+      if (!integer_zerop (ref_to_res))\n+\tgimplify_assign (build_simple_mem_ref (ref_to_res), var, &seq);\n+    }\n+\n+  if (lhs)\n+    gimplify_assign (lhs, var, &seq);\n+\n+  pop_gimplify_context (NULL);\n+\n+  gsi_replace_with_seq (&gsi, seq, true);\n+}\n+\n+/* Implement TARGET_GOACC_REDUCTION.\n+ \n+   Expand calls to the GOACC REDUCTION internal function, into a sequence of\n+   gimple instructions.  */\n+\n+void\n+gcn_goacc_reduction (gcall *call)\n+{\n+  int level = TREE_INT_CST_LOW (gimple_call_arg (call, 3));\n+\n+  if (level == GOMP_DIM_VECTOR)\n+    {\n+      default_goacc_reduction (call);\n+      return;\n+    }\n+\n+  unsigned code = (unsigned) TREE_INT_CST_LOW (gimple_call_arg (call, 0));\n+\n+  switch (code)\n+    {\n+    case IFN_GOACC_REDUCTION_SETUP:\n+      gcn_goacc_reduction_setup (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_INIT:\n+      gcn_goacc_reduction_init (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_FINI:\n+      gcn_goacc_reduction_fini (call);\n+      break;\n+\n+    case IFN_GOACC_REDUCTION_TEARDOWN:\n+      gcn_goacc_reduction_teardown (call);\n+      break;\n+\n+    default:\n+      gcc_unreachable ();\n+    }\n+}\n+\n+/* Implement TARGET_GOACC_ADJUST_PROPAGATION_RECORD.\n+ \n+   Tweak (worker) propagation record, e.g. to put it in shared memory.  */\n+\n+tree\n+gcn_goacc_adjust_propagation_record (tree record_type, bool sender,\n+\t\t\t\t     const char *name)\n+{\n+  tree type = record_type;\n+\n+  TYPE_ADDR_SPACE (type) = ADDR_SPACE_LDS;\n+\n+  if (!sender)\n+    type = build_pointer_type (type);\n+\n+  tree decl = create_tmp_var_raw (type, name);\n+\n+  if (sender)\n+    {\n+      DECL_CONTEXT (decl) = NULL_TREE;\n+      TREE_STATIC (decl) = 1;\n+    }\n+\n+  if (sender)\n+    varpool_node::finalize_decl (decl);\n+\n+  return decl;\n+}\n+\n+void\n+gcn_goacc_adjust_gangprivate_decl (tree var)\n+{\n+  tree type = TREE_TYPE (var);\n+  tree lds_type = build_qualified_type (type,\n+\t\t    TYPE_QUALS_NO_ADDR_SPACE (type)\n+\t\t    | ENCODE_QUAL_ADDR_SPACE (ADDR_SPACE_LDS));\n+  machine_function *machfun = cfun->machine;\n+\n+  TREE_TYPE (var) = lds_type;\n+  TREE_STATIC (var) = 1;\n+\n+  /* We're making VAR static.  We have to mangle the name to avoid collisions\n+     between different local variables that share the same names.  */\n+  lhd_set_decl_assembler_name (var);\n+\n+  varpool_node::finalize_decl (var);\n+\n+  if (machfun)\n+    machfun->use_flat_addressing = true;\n+}\n+\n+/* }}}  */"}, {"sha": "bd8ea55ec030f5c89c3447cf00f3279e1f5792b5", "filename": "gcc/config/gcn/gcn.c", "status": "added", "additions": 6123, "deletions": 0, "changes": 6123, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.c?ref=5326695a6d3585f5c49633813909342098d1714c"}, {"sha": "b3b2d1ad3f93e1a1bb1bc38c322205a283405ba0", "filename": "gcc/config/gcn/gcn.h", "status": "added", "additions": 662, "deletions": 0, "changes": 662, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.h?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,662 @@\n+/* Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+\n+   This file is free software; you can redistribute it and/or modify it under\n+   the terms of the GNU General Public License as published by the Free\n+   Software Foundation; either version 3 of the License, or (at your option)\n+   any later version.\n+\n+   This file is distributed in the hope that it will be useful, but WITHOUT\n+   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+   for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with GCC; see the file COPYING3.  If not see\n+   <http://www.gnu.org/licenses/>.  */\n+\n+#include \"config/gcn/gcn-opts.h\"\n+\n+#define TARGET_CPU_CPP_BUILTINS()\t\\\n+  do\t\t\t\t\t\\\n+    {\t\t\t\t\t\\\n+      builtin_define (\"__AMDGCN__\");\t\\\n+      if (TARGET_GCN3)\t\t\t\\\n+\tbuiltin_define (\"__GCN3__\");\t\\\n+      else if (TARGET_GCN5)\t\t\\\n+\tbuiltin_define (\"__GCN5__\");\t\\\n+    }\t\t\t\t\t\\\n+  while(0)\n+\n+/* Support for a compile-time default architecture and tuning.\n+   The rules are:\n+   --with-arch is ignored if -march is specified.\n+   --with-tune is ignored if -mtune is specified.  */\n+#define OPTION_DEFAULT_SPECS\t\t    \\\n+  {\"arch\", \"%{!march=*:-march=%(VALUE)}\" }, \\\n+  {\"tune\", \"%{!mtune=*:-mtune=%(VALUE)}\" }\n+\n+/* Default target_flags if no switches specified.  */\n+#ifndef TARGET_DEFAULT\n+#define TARGET_DEFAULT 0\n+#endif\n+\n+\f\n+/* Storage Layout */\n+#define BITS_BIG_ENDIAN  0\n+#define BYTES_BIG_ENDIAN 0\n+#define WORDS_BIG_ENDIAN 0\n+\n+#define BITS_PER_WORD 32\n+#define UNITS_PER_WORD (BITS_PER_WORD/BITS_PER_UNIT)\n+#define LIBGCC2_UNITS_PER_WORD 4\n+\n+#define POINTER_SIZE\t     64\n+#define PARM_BOUNDARY\t     64\n+#define STACK_BOUNDARY\t     64\n+#define FUNCTION_BOUNDARY    32\n+#define BIGGEST_ALIGNMENT    64\n+#define EMPTY_FIELD_BOUNDARY 32\n+#define MAX_FIXED_MODE_SIZE  64\n+#define MAX_REGS_PER_ADDRESS 2\n+#define STACK_SIZE_MODE      DImode\n+#define Pmode\t\t     DImode\n+#define CASE_VECTOR_MODE     DImode\n+#define FUNCTION_MODE\t     QImode\n+\n+#define DATA_ALIGNMENT(TYPE,ALIGN) ((ALIGN) > 128 ? (ALIGN) : 128)\n+#define LOCAL_ALIGNMENT(TYPE,ALIGN) ((ALIGN) > 64 ? (ALIGN) : 64)\n+#define STACK_SLOT_ALIGNMENT(TYPE,MODE,ALIGN) ((ALIGN) > 64 ? (ALIGN) : 64)\n+#define STRICT_ALIGNMENT 1\n+\n+/* Type Layout: match what x86_64 does.  */\n+#define INT_TYPE_SIZE\t\t  32\n+#define LONG_TYPE_SIZE\t\t  64\n+#define LONG_LONG_TYPE_SIZE\t  64\n+#define FLOAT_TYPE_SIZE\t\t  32\n+#define DOUBLE_TYPE_SIZE\t  64\n+#define LONG_DOUBLE_TYPE_SIZE\t  64\n+#define DEFAULT_SIGNED_CHAR\t  1\n+#define PCC_BITFIELD_TYPE_MATTERS 1\n+\n+/* Frame Layout */\n+#define FRAME_GROWS_DOWNWARD\t     0\n+#define ARGS_GROW_DOWNWARD\t     1\n+#define STACK_POINTER_OFFSET\t     0\n+#define FIRST_PARM_OFFSET(FNDECL)    0\n+#define DYNAMIC_CHAIN_ADDRESS(FP)    plus_constant (Pmode, (FP), -16)\n+#define INCOMING_RETURN_ADDR_RTX     gen_rtx_REG (Pmode, LINK_REGNUM)\n+#define STACK_DYNAMIC_OFFSET(FNDECL) (-crtl->outgoing_args_size)\n+#define ACCUMULATE_OUTGOING_ARGS     1\n+#define RETURN_ADDR_RTX(COUNT,FRAMEADDR) \\\n+  ((COUNT) == 0 ? get_hard_reg_initial_val (Pmode, LINK_REGNUM) : NULL_RTX)\n+\f\n+/* Register Basics */\n+#define FIRST_SGPR_REG\t    0\n+#define SGPR_REGNO(N)\t    ((N)+FIRST_SGPR_REG)\n+#define LAST_SGPR_REG\t    101\n+\n+#define FLAT_SCRATCH_REG    102\n+#define FLAT_SCRATCH_LO_REG 102\n+#define FLAT_SCRATCH_HI_REG 103\n+#define XNACK_MASK_REG\t    104\n+#define XNACK_MASK_LO_REG   104\n+#define XNACK_MASK_HI_REG   105\n+#define VCC_LO_REG\t    106\n+#define VCC_HI_REG\t    107\n+#define VCCZ_REG\t    108\n+#define TBA_REG\t\t    109\n+#define TBA_LO_REG\t    109\n+#define TBA_HI_REG\t    110\n+#define TMA_REG\t\t    111\n+#define TMA_LO_REG\t    111\n+#define TMA_HI_REG\t    112\n+#define TTMP0_REG\t    113\n+#define TTMP11_REG\t    124\n+#define M0_REG\t\t    125\n+#define EXEC_REG\t    126\n+#define EXEC_LO_REG\t    126\n+#define EXEC_HI_REG\t    127\n+#define EXECZ_REG\t    128\n+#define SCC_REG\t\t    129\n+/* 132-159 are reserved to simplify masks.  */\n+#define FIRST_VGPR_REG\t    160\n+#define VGPR_REGNO(N)\t    ((N)+FIRST_VGPR_REG)\n+#define LAST_VGPR_REG\t    415\n+\n+/* Frame Registers, and other registers */\n+\n+#define HARD_FRAME_POINTER_REGNUM 14\n+#define STACK_POINTER_REGNUM\t  16\n+#define LINK_REGNUM\t\t  18\n+#define EXEC_SAVE_REG\t\t  20\n+#define CC_SAVE_REG\t\t  22\n+#define RETURN_VALUE_REG\t  24\t/* Must be divisible by 4.  */\n+#define STATIC_CHAIN_REGNUM\t  30\n+#define WORK_ITEM_ID_Z_REG\t  162\n+#define SOFT_ARG_REG\t\t  416\n+#define FRAME_POINTER_REGNUM\t  418\n+#define FIRST_PSEUDO_REGISTER\t  420\n+\n+#define FIRST_PARM_REG 24\n+#define NUM_PARM_REGS  6\n+\n+/* There is no arg pointer.  Just choose random fixed register that does\n+   not intefere with anything.  */\n+#define ARG_POINTER_REGNUM SOFT_ARG_REG\n+\n+#define HARD_FRAME_POINTER_IS_ARG_POINTER   0\n+#define HARD_FRAME_POINTER_IS_FRAME_POINTER 0\n+\n+#define SGPR_OR_VGPR_REGNO_P(N) ((N)>=FIRST_VGPR_REG && (N) <= LAST_SGPR_REG)\n+#define SGPR_REGNO_P(N)\t\t((N) <= LAST_SGPR_REG)\n+#define VGPR_REGNO_P(N)\t\t((N)>=FIRST_VGPR_REG && (N) <= LAST_VGPR_REG)\n+#define SSRC_REGNO_P(N)\t\t((N) <= SCC_REG && (N) != VCCZ_REG)\n+#define SDST_REGNO_P(N)\t\t((N) <= EXEC_HI_REG && (N) != VCCZ_REG)\n+#define CC_REG_P(X)\t\t(REG_P (X) && CC_REGNO_P (REGNO (X)))\n+#define CC_REGNO_P(X)\t\t((X) == SCC_REG || (X) == VCC_REG)\n+#define FUNCTION_ARG_REGNO_P(N) \\\n+  ((N) >= FIRST_PARM_REG && (N) < (FIRST_PARM_REG + NUM_PARM_REGS))\n+\n+\f\n+#define FIXED_REGISTERS {\t\t\t    \\\n+    /* Scalars.  */\t\t\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+/*\t\tfp    sp    lr.  */\t\t    \\\n+    0, 0, 0, 0, 1, 1, 1, 1, 0, 0,\t\t    \\\n+/*  exec_save, cc_save */\t\t\t    \\\n+    1, 1, 1, 1, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\t\t    \\\n+    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\t\t    \\\n+    /* Special regs and padding.  */\t\t    \\\n+/*  flat  xnack vcc\t tba   tma   ttmp */\t    \\\n+    1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+/*\t\t\t m0 exec     scc */\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t    \\\n+    /* VGRPs */\t\t\t\t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    /* Other registers.  */\t\t\t    \\\n+    1, 1, 1, 1\t\t\t\t\t    \\\n+}\n+\n+#define CALL_USED_REGISTERS {\t\t\t    \\\n+    /* Scalars.  */\t\t\t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \t\t    \\\n+    1, 1, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \t\t    \\\n+    0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1, 1,\t\t    \\\n+    /* Special regs and padding.  */\t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1,\t\t    \\\n+    /* VGRPs */\t\t\t\t\t    \\\n+    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, \\\n+    /* Other registers.  */\t\t\t    \\\n+    1, 1, 1, 1\t\t\t\t\t    \\\n+}\n+\n+\f\n+#define HARD_REGNO_RENAME_OK(FROM, TO) \\\n+  gcn_hard_regno_rename_ok (FROM, TO)\n+\n+#define HARD_REGNO_CALLER_SAVE_MODE(HARDREG, NREGS, MODE) \\\n+  gcn_hard_regno_caller_save_mode ((HARDREG), (NREGS), (MODE))\n+\n+/* Register Classes */\n+\n+enum reg_class\n+{\n+  NO_REGS,\n+\n+  /* SCC */\n+  SCC_CONDITIONAL_REG,\n+\n+  /* VCCZ */\n+  VCCZ_CONDITIONAL_REG,\n+\n+  /* VCC */\n+  VCC_CONDITIONAL_REG,\n+\n+  /* EXECZ */\n+  EXECZ_CONDITIONAL_REG,\n+\n+  /* SCC VCCZ EXECZ */\n+  ALL_CONDITIONAL_REGS,\n+\n+  /* EXEC */\n+  EXEC_MASK_REG,\n+\n+  /* SGPR0-101 */\n+  SGPR_REGS,\n+\n+  /* SGPR0-101 EXEC_LO/EXEC_HI */\n+  SGPR_EXEC_REGS,\n+\n+  /* SGPR0-101, FLAT_SCRATCH_LO/HI, VCC LO/HI, TBA LO/HI, TMA LO/HI, TTMP0-11,\n+     M0, VCCZ, SCC\n+     (EXEC_LO/HI, EXECZ excluded to prevent compiler misuse.)  */\n+  SGPR_VOP_SRC_REGS,\n+\n+  /* SGPR0-101, FLAT_SCRATCH_LO/HI, XNACK_MASK_LO/HI, VCC LO/HI, TBA LO/HI\n+     TMA LO/HI, TTMP0-11 */\n+  SGPR_MEM_SRC_REGS,\n+\n+  /* SGPR0-101, FLAT_SCRATCH_LO/HI, XNACK_MASK_LO/HI, VCC LO/HI, TBA LO/HI\n+     TMA LO/HI, TTMP0-11, M0, EXEC LO/HI */\n+  SGPR_DST_REGS,\n+\n+  /* SGPR0-101, FLAT_SCRATCH_LO/HI, XNACK_MASK_LO/HI, VCC LO/HI, TBA LO/HI\n+     TMA LO/HI, TTMP0-11 */\n+  SGPR_SRC_REGS,\n+  GENERAL_REGS,\n+  VGPR_REGS,\n+  ALL_GPR_REGS,\n+  SRCDST_REGS,\n+  AFP_REGS,\n+  ALL_REGS,\n+  LIM_REG_CLASSES\n+};\n+\n+#define N_REG_CLASSES (int) LIM_REG_CLASSES\n+\n+#define REG_CLASS_NAMES     \\\n+{  \"NO_REGS\",\t\t    \\\n+   \"SCC_CONDITIONAL_REG\",   \\\n+   \"VCCZ_CONDITIONAL_REG\",  \\\n+   \"VCC_CONDITIONAL_REG\",   \\\n+   \"EXECZ_CONDITIONAL_REG\", \\\n+   \"ALL_CONDITIONAL_REGS\",  \\\n+   \"EXEC_MASK_REG\",\t    \\\n+   \"SGPR_REGS\",\t\t    \\\n+   \"SGPR_EXEC_REGS\",\t    \\\n+   \"SGPR_VOP3A_SRC_REGS\",   \\\n+   \"SGPR_MEM_SRC_REGS\",     \\\n+   \"SGPR_DST_REGS\",\t    \\\n+   \"SGPR_SRC_REGS\",\t    \\\n+   \"GENERAL_REGS\",\t    \\\n+   \"VGPR_REGS\",\t\t    \\\n+   \"ALL_GPR_REGS\",\t    \\\n+   \"SRCDST_REGS\",\t    \\\n+   \"AFP_REGS\",\t\t    \\\n+   \"ALL_REGS\"\t\t    \\\n+}\n+\n+#define NAMED_REG_MASK(N)  (1<<((N)-3*32))\n+#define NAMED_REG_MASK2(N) (1<<((N)-4*32))\n+\n+#define REG_CLASS_CONTENTS {\t\t\t\t\t\t   \\\n+    /* NO_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SCC_CONDITIONAL_REG.  */\t\t\t\t\t\t   \\\n+    {0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     NAMED_REG_MASK2 (SCC_REG), 0, 0, 0,\t\t\t\t   \\\n+     0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* VCCZ_CONDITIONAL_REG.  */\t\t\t\t\t   \\\n+    {0, 0, 0, NAMED_REG_MASK (VCCZ_REG),\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* VCC_CONDITIONAL_REG.  */\t\t\t\t\t\t   \\\n+    {0, 0, 0, NAMED_REG_MASK (VCC_LO_REG)|NAMED_REG_MASK (VCC_HI_REG),\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* EXECZ_CONDITIONAL_REG.  */\t\t\t\t\t   \\\n+    {0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     NAMED_REG_MASK2 (EXECZ_REG), 0, 0, 0,\t\t\t\t   \\\n+     0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* ALL_CONDITIONAL_REGS.  */\t\t\t\t\t   \\\n+    {0, 0, 0, NAMED_REG_MASK (VCCZ_REG),\t\t\t\t   \\\n+     NAMED_REG_MASK2 (EXECZ_REG) | NAMED_REG_MASK2 (SCC_REG), 0, 0, 0,\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* EXEC_MASK_REG.  */\t\t\t\t\t\t   \\\n+    {0, 0, 0, NAMED_REG_MASK (EXEC_LO_REG) | NAMED_REG_MASK (EXEC_HI_REG), \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff, 0xf1,\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_EXEC_REGS.\t*/\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff,\t\t\t\t   \\\n+      0xf1 | NAMED_REG_MASK (EXEC_LO_REG) | NAMED_REG_MASK (EXEC_HI_REG),  \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_VOP_SRC_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff,\t\t\t\t   \\\n+      0xffffffff\t\t\t\t\t\t\t   \\\n+       -NAMED_REG_MASK (EXEC_LO_REG)\t\t\t\t\t   \\\n+       -NAMED_REG_MASK (EXEC_HI_REG),\t\t\t\t\t   \\\n+     NAMED_REG_MASK2 (SCC_REG), 0, 0, 0,\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_MEM_SRC_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff,\t\t\t\t   \\\n+     0xffffffff-NAMED_REG_MASK (VCCZ_REG)-NAMED_REG_MASK (M0_REG)\t   \\\n+     -NAMED_REG_MASK (EXEC_LO_REG)-NAMED_REG_MASK (EXEC_HI_REG),\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_DST_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff,\t\t\t\t   \\\n+     0xffffffff-NAMED_REG_MASK (VCCZ_REG),\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* SGPR_SRC_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     NAMED_REG_MASK2 (EXECZ_REG) | NAMED_REG_MASK2 (SCC_REG), 0, 0, 0,\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* GENERAL_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff, 0xf1,\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0},\t\t\t\t\t\t\t   \\\n+    /* VGPR_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0,\t\t 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0},\t   \\\n+    /* ALL_GPR_REGS.  */\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff, 0xf1,\t\t\t\t   \\\n+     0,\t\t 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0},\t   \\\n+    /* SRCDST_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff,\t\t\t\t   \\\n+     0xffffffff-NAMED_REG_MASK (VCCZ_REG),\t\t\t\t   \\\n+     0,\t\t 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0},\t   \\\n+    /* AFP_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0,\t\t\t\t\t\t\t   \\\n+     0, 0, 0, 0, 0, 0xf},\t\t\t\t\t\t   \\\n+    /* ALL_REGS.  */\t\t\t\t\t\t\t   \\\n+    {0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff,\t\t\t   \\\n+     0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0xffffffff, 0 }}\n+\n+#define REGNO_REG_CLASS(REGNO) gcn_regno_reg_class (REGNO)\n+#define MODE_CODE_BASE_REG_CLASS(MODE, AS, OUTER, INDEX) \\\n+\t gcn_mode_code_base_reg_class (MODE, AS, OUTER, INDEX)\n+#define REGNO_MODE_CODE_OK_FOR_BASE_P(NUM, MODE, AS, OUTER, INDEX) \\\n+\t gcn_regno_mode_code_ok_for_base_p (NUM, MODE, AS, OUTER, INDEX)\n+#define INDEX_REG_CLASS VGPR_REGS\n+#define REGNO_OK_FOR_INDEX_P(regno) regno_ok_for_index_p (regno)\n+\n+\f\n+/* Address spaces.  */\n+enum gcn_address_spaces\n+{\n+  ADDR_SPACE_DEFAULT = 0,\n+  ADDR_SPACE_FLAT,\n+  ADDR_SPACE_SCALAR_FLAT,\n+  ADDR_SPACE_FLAT_SCRATCH,\n+  ADDR_SPACE_LDS,\n+  ADDR_SPACE_GDS,\n+  ADDR_SPACE_SCRATCH,\n+  ADDR_SPACE_GLOBAL\n+};\n+#define REGISTER_TARGET_PRAGMAS() do {                               \\\n+  c_register_addr_space (\"__flat\", ADDR_SPACE_FLAT);                 \\\n+  c_register_addr_space (\"__flat_scratch\", ADDR_SPACE_FLAT_SCRATCH); \\\n+  c_register_addr_space (\"__scalar_flat\", ADDR_SPACE_SCALAR_FLAT);   \\\n+  c_register_addr_space (\"__lds\", ADDR_SPACE_LDS);                   \\\n+  c_register_addr_space (\"__gds\", ADDR_SPACE_GDS);                   \\\n+  c_register_addr_space (\"__global\", ADDR_SPACE_GLOBAL);             \\\n+} while (0);\n+\n+#define STACK_ADDR_SPACE \\\n+  (TARGET_GCN5_PLUS ? ADDR_SPACE_GLOBAL : ADDR_SPACE_FLAT)\n+#define DEFAULT_ADDR_SPACE \\\n+  ((cfun && cfun->machine && !cfun->machine->use_flat_addressing) \\\n+   ? ADDR_SPACE_GLOBAL : ADDR_SPACE_FLAT)\n+#define AS_SCALAR_FLAT_P(AS)   ((AS) == ADDR_SPACE_SCALAR_FLAT)\n+#define AS_FLAT_SCRATCH_P(AS)  ((AS) == ADDR_SPACE_FLAT_SCRATCH)\n+#define AS_FLAT_P(AS)\t       ((AS) == ADDR_SPACE_FLAT \\\n+\t\t\t\t|| ((AS) == ADDR_SPACE_DEFAULT \\\n+\t\t\t\t    && DEFAULT_ADDR_SPACE == ADDR_SPACE_FLAT))\n+#define AS_LDS_P(AS)\t       ((AS) == ADDR_SPACE_LDS)\n+#define AS_GDS_P(AS)\t       ((AS) == ADDR_SPACE_GDS)\n+#define AS_SCRATCH_P(AS)       ((AS) == ADDR_SPACE_SCRATCH)\n+#define AS_GLOBAL_P(AS)        ((AS) == ADDR_SPACE_GLOBAL \\\n+\t\t\t\t|| ((AS) == ADDR_SPACE_DEFAULT \\\n+\t\t\t\t    && DEFAULT_ADDR_SPACE == ADDR_SPACE_GLOBAL))\n+#define AS_ANY_FLAT_P(AS)      (AS_FLAT_SCRATCH_P (AS) || AS_FLAT_P (AS))\n+#define AS_ANY_DS_P(AS)\t       (AS_LDS_P (AS) || AS_GDS_P (AS))\n+\n+\f\n+/* Instruction Output */\n+#define REGISTER_NAMES\t\t\t\t\t\t\t    \\\n+   {\"s0\", \"s1\", \"s2\", \"s3\", \"s4\", \"s5\", \"s6\", \"s7\", \"s8\", \"s9\", \"s10\",\t    \\\n+    \"s11\", \"s12\", \"s13\", \"s14\", \"s15\", \"s16\", \"s17\", \"s18\", \"s19\", \"s20\",   \\\n+    \"s21\", \"s22\", \"s23\", \"s24\", \"s25\", \"s26\", \"s27\", \"s28\", \"s29\", \"s30\",   \\\n+    \"s31\", \"s32\", \"s33\", \"s34\", \"s35\", \"s36\", \"s37\", \"s38\", \"s39\", \"s40\",   \\\n+    \"s41\", \"s42\", \"s43\", \"s44\", \"s45\", \"s46\", \"s47\", \"s48\", \"s49\", \"s50\",   \\\n+    \"s51\", \"s52\", \"s53\", \"s54\", \"s55\", \"s56\", \"s57\", \"s58\", \"s59\", \"s60\",   \\\n+    \"s61\", \"s62\", \"s63\", \"s64\", \"s65\", \"s66\", \"s67\", \"s68\", \"s69\", \"s70\",   \\\n+    \"s71\", \"s72\", \"s73\", \"s74\", \"s75\", \"s76\", \"s77\", \"s78\", \"s79\", \"s80\",   \\\n+    \"s81\", \"s82\", \"s83\", \"s84\", \"s85\", \"s86\", \"s87\", \"s88\", \"s89\", \"s90\",   \\\n+    \"s91\", \"s92\", \"s93\", \"s94\", \"s95\", \"s96\", \"s97\", \"s98\", \"s99\",\t    \\\n+    \"s100\", \"s101\",\t\t\t\t\t\t\t    \\\n+    \"flat_scratch_lo\", \"flat_scratch_hi\", \"xnack_mask_lo\", \"xnack_mask_hi\", \\\n+    \"vcc_lo\", \"vcc_hi\", \"vccz\", \"tba_lo\", \"tba_hi\", \"tma_lo\", \"tma_hi\",     \\\n+    \"ttmp0\", \"ttmp1\", \"ttmp2\", \"ttmp3\", \"ttmp4\", \"ttmp5\", \"ttmp6\", \"ttmp7\", \\\n+    \"ttmp8\", \"ttmp9\", \"ttmp10\", \"ttmp11\", \"m0\", \"exec_lo\", \"exec_hi\",\t    \\\n+    \"execz\", \"scc\",\t\t\t\t\t\t\t    \\\n+    \"res130\", \"res131\", \"res132\", \"res133\", \"res134\", \"res135\", \"res136\",   \\\n+    \"res137\", \"res138\", \"res139\", \"res140\", \"res141\", \"res142\", \"res143\",   \\\n+    \"res144\", \"res145\", \"res146\", \"res147\", \"res148\", \"res149\", \"res150\",   \\\n+    \"res151\", \"res152\", \"res153\", \"res154\", \"res155\", \"res156\", \"res157\",   \\\n+    \"res158\", \"res159\",\t\t\t\t\t\t\t    \\\n+    \"v0\", \"v1\", \"v2\", \"v3\", \"v4\", \"v5\", \"v6\", \"v7\", \"v8\", \"v9\", \"v10\",\t    \\\n+    \"v11\", \"v12\", \"v13\", \"v14\", \"v15\", \"v16\", \"v17\", \"v18\", \"v19\", \"v20\",   \\\n+    \"v21\", \"v22\", \"v23\", \"v24\", \"v25\", \"v26\", \"v27\", \"v28\", \"v29\", \"v30\",   \\\n+    \"v31\", \"v32\", \"v33\", \"v34\", \"v35\", \"v36\", \"v37\", \"v38\", \"v39\", \"v40\",   \\\n+    \"v41\", \"v42\", \"v43\", \"v44\", \"v45\", \"v46\", \"v47\", \"v48\", \"v49\", \"v50\",   \\\n+    \"v51\", \"v52\", \"v53\", \"v54\", \"v55\", \"v56\", \"v57\", \"v58\", \"v59\", \"v60\",   \\\n+    \"v61\", \"v62\", \"v63\", \"v64\", \"v65\", \"v66\", \"v67\", \"v68\", \"v69\", \"v70\",   \\\n+    \"v71\", \"v72\", \"v73\", \"v74\", \"v75\", \"v76\", \"v77\", \"v78\", \"v79\", \"v80\",   \\\n+    \"v81\", \"v82\", \"v83\", \"v84\", \"v85\", \"v86\", \"v87\", \"v88\", \"v89\", \"v90\",   \\\n+    \"v91\", \"v92\", \"v93\", \"v94\", \"v95\", \"v96\", \"v97\", \"v98\", \"v99\", \"v100\",  \\\n+    \"v101\", \"v102\", \"v103\", \"v104\", \"v105\", \"v106\", \"v107\", \"v108\", \"v109\", \\\n+    \"v110\", \"v111\", \"v112\", \"v113\", \"v114\", \"v115\", \"v116\", \"v117\", \"v118\", \\\n+    \"v119\", \"v120\", \"v121\", \"v122\", \"v123\", \"v124\", \"v125\", \"v126\", \"v127\", \\\n+    \"v128\", \"v129\", \"v130\", \"v131\", \"v132\", \"v133\", \"v134\", \"v135\", \"v136\", \\\n+    \"v137\", \"v138\", \"v139\", \"v140\", \"v141\", \"v142\", \"v143\", \"v144\", \"v145\", \\\n+    \"v146\", \"v147\", \"v148\", \"v149\", \"v150\", \"v151\", \"v152\", \"v153\", \"v154\", \\\n+    \"v155\", \"v156\", \"v157\", \"v158\", \"v159\", \"v160\", \"v161\", \"v162\", \"v163\", \\\n+    \"v164\", \"v165\", \"v166\", \"v167\", \"v168\", \"v169\", \"v170\", \"v171\", \"v172\", \\\n+    \"v173\", \"v174\", \"v175\", \"v176\", \"v177\", \"v178\", \"v179\", \"v180\", \"v181\", \\\n+    \"v182\", \"v183\", \"v184\", \"v185\", \"v186\", \"v187\", \"v188\", \"v189\", \"v190\", \\\n+    \"v191\", \"v192\", \"v193\", \"v194\", \"v195\", \"v196\", \"v197\", \"v198\", \"v199\", \\\n+    \"v200\", \"v201\", \"v202\", \"v203\", \"v204\", \"v205\", \"v206\", \"v207\", \"v208\", \\\n+    \"v209\", \"v210\", \"v211\", \"v212\", \"v213\", \"v214\", \"v215\", \"v216\", \"v217\", \\\n+    \"v218\", \"v219\", \"v220\", \"v221\", \"v222\", \"v223\", \"v224\", \"v225\", \"v226\", \\\n+    \"v227\", \"v228\", \"v229\", \"v230\", \"v231\", \"v232\", \"v233\", \"v234\", \"v235\", \\\n+    \"v236\", \"v237\", \"v238\", \"v239\", \"v240\", \"v241\", \"v242\", \"v243\", \"v244\", \\\n+    \"v245\", \"v246\", \"v247\", \"v248\", \"v249\", \"v250\", \"v251\", \"v252\", \"v253\", \\\n+    \"v254\", \"v255\",\t\t\t\t\t\t\t    \\\n+    \"?ap0\", \"?ap1\", \"?fp0\", \"?fp1\" }\n+\n+#define PRINT_OPERAND(FILE, X, CODE)  print_operand(FILE, X, CODE)\n+#define PRINT_OPERAND_ADDRESS(FILE, ADDR)  print_operand_address (FILE, ADDR)\n+#define PRINT_OPERAND_PUNCT_VALID_P(CODE) (CODE == '^')\n+\n+\f\n+/* Register Arguments */\n+\n+#ifndef USED_FOR_TARGET\n+\n+#define GCN_KERNEL_ARG_TYPES 19\n+struct GTY(()) gcn_kernel_args\n+{\n+  long requested;\n+  int reg[GCN_KERNEL_ARG_TYPES];\n+  int order[GCN_KERNEL_ARG_TYPES];\n+  int nargs, nsgprs;\n+};\n+\n+typedef struct gcn_args\n+{\n+  /* True if this isn't a kernel (HSA runtime entrypoint).  */\n+  bool normal_function;\n+  tree fntype;\n+  struct gcn_kernel_args args;\n+  int num;\n+  int offset;\n+  int alignment;\n+} CUMULATIVE_ARGS;\n+#endif\n+\n+#define INIT_CUMULATIVE_ARGS(CUM,FNTYPE,LIBNAME,FNDECL,N_NAMED_ARGS) \\\n+  gcn_init_cumulative_args (&(CUM), (FNTYPE), (LIBNAME), (FNDECL),   \\\n+\t\t\t    (N_NAMED_ARGS) != -1)\n+\n+\f\n+#ifndef USED_FOR_TARGET\n+\n+#include \"hash-table.h\"\n+#include \"hash-map.h\"\n+#include \"vec.h\"\n+\n+struct GTY(()) machine_function\n+{\n+  struct gcn_kernel_args args;\n+  int kernarg_segment_alignment;\n+  int kernarg_segment_byte_size;\n+  /* Frame layout info for normal functions.  */\n+  bool normal_function;\n+  bool need_frame_pointer;\n+  bool lr_needs_saving;\n+  HOST_WIDE_INT outgoing_args_size;\n+  HOST_WIDE_INT pretend_size;\n+  HOST_WIDE_INT local_vars;\n+  HOST_WIDE_INT callee_saves;\n+\n+  unsigned lds_allocated;\n+  hash_map<tree, int> *lds_allocs;\n+\n+  vec<tree, va_gc> *reduc_decls;\n+\n+  bool use_flat_addressing;\n+};\n+#endif\n+\n+\f\n+/* Codes for all the GCN builtins.  */\n+\n+enum gcn_builtin_codes\n+{\n+#define DEF_BUILTIN(fcode, icode, name, type, params, expander) \\\n+  GCN_BUILTIN_ ## fcode,\n+#define DEF_BUILTIN_BINOP_INT_FP(fcode, ic, name)\t\\\n+  GCN_BUILTIN_ ## fcode ## _V64SI,\t\t\t\\\n+  GCN_BUILTIN_ ## fcode ## _V64SI_unspec,\n+#include \"gcn-builtins.def\"\n+#undef DEF_BUILTIN\n+#undef DEF_BUILTIN_BINOP_INT_FP\n+  GCN_BUILTIN_MAX\n+};\n+\n+\f\n+/* Misc */\n+\n+/* We can load/store 128-bit quantities, but having this larger than\n+   MAX_FIXED_MODE_SIZE (which we want to be 64 bits) causes problems.  */\n+#define MOVE_MAX 8\n+\n+#define AVOID_CCMODE_COPIES 1\n+#define SLOW_BYTE_ACCESS 0\n+#define WORD_REGISTER_OPERATIONS 1\n+\n+/* Definitions for register eliminations.\n+\n+   This is an array of structures.  Each structure initializes one pair\n+   of eliminable registers.  The \"from\" register number is given first,\n+   followed by \"to\".  Eliminations of the same \"from\" register are listed\n+   in order of preference.  */\n+\n+#define ELIMINABLE_REGS\t\t\t\t\t\\\n+{{ ARG_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\t\\\n+ { ARG_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, STACK_POINTER_REGNUM },\t\\\n+ { FRAME_POINTER_REGNUM, HARD_FRAME_POINTER_REGNUM }}\n+\n+/* Define the offset between two registers, one to be eliminated, and the\n+   other its replacement, at the start of a routine.  */\n+\n+#define INITIAL_ELIMINATION_OFFSET(FROM, TO, OFFSET)\t\\\n+  ((OFFSET) = gcn_initial_elimination_offset ((FROM), (TO)))\n+\n+\n+/* Define this macro if it is advisable to hold scalars in registers\n+   in a wider mode than that declared by the program.  In such cases,\n+   the value is constrained to be within the bounds of the declared\n+   type, but kept valid in the wider mode.  The signedness of the\n+   extension may differ from that of the type.  */\n+\n+#define PROMOTE_MODE(MODE,UNSIGNEDP,TYPE)\t\t\t\\\n+  if (GET_MODE_CLASS (MODE) == MODE_INT\t\t\t\t\\\n+      && (TYPE == NULL || TREE_CODE (TYPE) != VECTOR_TYPE)\t\\\n+      && GET_MODE_SIZE (MODE) < UNITS_PER_WORD)\t\t\t\\\n+    {\t\t\t\t\t\t\t\t\\\n+      (MODE) = SImode;\t\t\t\t\t\t\\\n+    }\n+\n+/* This needs to match gcn_function_value.  */\n+#define LIBCALL_VALUE(MODE) gen_rtx_REG (MODE, SGPR_REGNO (RETURN_VALUE_REG))\n+\n+\f\n+/* Costs.  */\n+\n+/* Branches are to be dicouraged when theres an alternative.\n+   FIXME: This number is plucked from the air.  */\n+#define BRANCH_COST(SPEED_P, PREDICABLE_P) 10\n+\n+\f\n+/* Profiling */\n+#define FUNCTION_PROFILER(FILE, LABELNO)\n+#define NO_PROFILE_COUNTERS 1\n+#define PROFILE_BEFORE_PROLOGUE 0\n+\n+/* Trampolines */\n+#define TRAMPOLINE_SIZE 36\n+#define TRAMPOLINE_ALIGNMENT 64"}, {"sha": "2fd3996edbad89372979e178fc310279241b1a9e", "filename": "gcc/config/gcn/gcn.opt", "status": "added", "additions": 78, "deletions": 0, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Fgcn.opt", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Fgcn.opt?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,78 @@\n+; Options for the GCN port of the compiler.\n+\n+; Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+;\n+; This file is part of GCC.\n+;\n+; GCC is free software; you can redistribute it and/or modify it under\n+; the terms of the GNU General Public License as published by the Free\n+; Software Foundation; either version 3, or (at your option) any later\n+; version.\n+;\n+; GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+; WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+; FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+; for more details.\n+;\n+; You should have received a copy of the GNU General Public License\n+; along with GCC; see the file COPYING3.  If not see\n+; <http://www.gnu.org/licenses/>.\n+\n+HeaderInclude\n+config/gcn/gcn-opts.h\n+\n+Enum\n+Name(gpu_type) Type(enum processor_type)\n+GCN GPU type to use:\n+\n+EnumValue\n+Enum(gpu_type) String(carrizo) Value(PROCESSOR_CARRIZO)\n+\n+EnumValue\n+Enum(gpu_type) String(fiji) Value(PROCESSOR_FIJI)\n+\n+EnumValue\n+Enum(gpu_type) String(gfx900) Value(PROCESSOR_VEGA)\n+\n+march=\n+Target RejectNegative Joined ToLower Enum(gpu_type) Var(gcn_arch) Init(PROCESSOR_CARRIZO)\n+Specify the name of the target GPU.\n+\n+mtune=\n+Target RejectNegative Joined ToLower Enum(gpu_type) Var(gcn_tune) Init(PROCESSOR_CARRIZO)\n+Specify the name of the target GPU.\n+\n+m32\n+Target Report RejectNegative InverseMask(ABI64)\n+Generate code for a 32-bit ABI.\n+\n+m64\n+Target Report RejectNegative Mask(ABI64)\n+Generate code for a 64-bit ABI.\n+\n+mgomp\n+Target Report RejectNegative\n+Enable OpenMP GPU offloading.\n+\n+bool flag_bypass_init_error = false\n+\n+mbypass-init-error\n+Target Report RejectNegative Var(flag_bypass_init_error)\n+\n+bool flag_worker_partitioning = false\n+\n+macc-experimental-workers\n+Target Report Var(flag_worker_partitioning) Init(1)\n+\n+int stack_size_opt = -1\n+\n+mstack-size=\n+Target Report RejectNegative Joined UInteger Var(stack_size_opt) Init(-1)\n+-mstack-size=<number>\tSet the private segment size per wave-front, in bytes.\n+\n+mlocal-symbol-id=\n+Target RejectNegative Report JoinedOrMissing Var(local_symbol_id) Init(0)\n+\n+Wopenacc-dims\n+Target Var(warn_openacc_dims) Warning\n+Warn about invalid OpenACC dimensions."}, {"sha": "085ba429c9d71fca3fdb2bdbd6bb4b203b905274", "filename": "gcc/config/gcn/t-gcn-hsa", "status": "added", "additions": 52, "deletions": 0, "changes": 52, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Ft-gcn-hsa", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/5326695a6d3585f5c49633813909342098d1714c/gcc%2Fconfig%2Fgcn%2Ft-gcn-hsa", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fconfig%2Fgcn%2Ft-gcn-hsa?ref=5326695a6d3585f5c49633813909342098d1714c", "patch": "@@ -0,0 +1,52 @@\n+#  Copyright (C) 2016-2019 Free Software Foundation, Inc.\n+#\n+#  This file is free software; you can redistribute it and/or modify it under\n+#  the terms of the GNU General Public License as published by the Free\n+#  Software Foundation; either version 3 of the License, or (at your option)\n+#  any later version.\n+#\n+#  This file is distributed in the hope that it will be useful, but WITHOUT\n+#  ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+#  FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+#  for more details.\n+#\n+#  You should have received a copy of the GNU General Public License\n+#  along with GCC; see the file COPYING3.  If not see\n+#  <http://www.gnu.org/licenses/>.\n+\n+GTM_H += $(HASH_TABLE_H)\n+\n+driver-gcn.o: $(srcdir)/config/gcn/driver-gcn.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+\n+CFLAGS-mkoffload.o += $(DRIVER_DEFINES) \\\n+\t-DGCC_INSTALL_NAME=\\\"$(GCC_INSTALL_NAME)\\\"\n+mkoffload.o: $(srcdir)/config/gcn/mkoffload.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+ALL_HOST_OBJS += mkoffload.o\n+\n+mkoffload$(exeext): mkoffload.o collect-utils.o libcommon-target.a \\\n+\t\t      $(LIBIBERTY) $(LIBDEPS)\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ \\\n+\t  mkoffload.o collect-utils.o libcommon-target.a $(LIBIBERTY) $(LIBS)\n+\n+CFLAGS-gcn-run.o += -DVERSION_STRING=$(PKGVERSION_s)\n+COMPILE-gcn-run.o = $(filter-out -fno-rtti,$(COMPILE))\n+gcn-run.o: $(srcdir)/config/gcn/gcn-run.c\n+\t$(COMPILE-gcn-run.o) -x c -std=gnu11 -Wno-error=pedantic $<\n+\t$(POSTCOMPILE)\n+ALL_HOST_OBJS += gcn-run.o\n+\n+gcn-run$(exeext): gcn-run.o\n+\t+$(LINKER) $(ALL_LINKERFLAGS) $(LDFLAGS) -o $@ $< -ldl\n+\n+MULTILIB_OPTIONS = march=gfx900\n+MULTILIB_DIRNAMES = gcn5\n+\n+PASSES_EXTRA += $(srcdir)/config/gcn/gcn-passes.def\n+gcn-tree.o: $(srcdir)/config/gcn/gcn-tree.c\n+\t$(COMPILE) $<\n+\t$(POSTCOMPILE)\n+ALL_HOST_OBJS += gcn-tree.o"}]}