{"sha": "e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTQ4ZGM5OWUyMzRiZmI5Y2JkZDBjOTkyZGMwMjViNDE0MjE3ZmYwYw==", "commit": {"author": {"name": "Martin Liska", "email": "mliska@suse.cz", "date": "2019-05-20T07:53:18Z"}, "committer": {"name": "Martin Liska", "email": "marxin@gcc.gnu.org", "date": "2019-05-20T07:53:18Z"}, "message": "Use capital letters for enum value names.\n\n2019-05-20  Martin Liska  <mliska@suse.cz>\n\n\t* profile-count.h (enum profile_quality): Use capital letters\n\tfor enum value names.  Use the adjusted names.\n\t* profile-count.c: Use the adjusted names.\n\nFrom-SVN: r271397", "tree": {"sha": "726566ae2971b6d24f335caa6d81d760bbd81124", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/726566ae2971b6d24f335caa6d81d760bbd81124"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/comments", "author": {"login": "marxin", "id": 2658545, "node_id": "MDQ6VXNlcjI2NTg1NDU=", "avatar_url": "https://avatars.githubusercontent.com/u/2658545?v=4", "gravatar_id": "", "url": "https://api.github.com/users/marxin", "html_url": "https://github.com/marxin", "followers_url": "https://api.github.com/users/marxin/followers", "following_url": "https://api.github.com/users/marxin/following{/other_user}", "gists_url": "https://api.github.com/users/marxin/gists{/gist_id}", "starred_url": "https://api.github.com/users/marxin/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/marxin/subscriptions", "organizations_url": "https://api.github.com/users/marxin/orgs", "repos_url": "https://api.github.com/users/marxin/repos", "events_url": "https://api.github.com/users/marxin/events{/privacy}", "received_events_url": "https://api.github.com/users/marxin/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "bc374246e211608c4cf9732fb814620a5dfe91b1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/bc374246e211608c4cf9732fb814620a5dfe91b1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/bc374246e211608c4cf9732fb814620a5dfe91b1"}], "stats": {"total": 130, "additions": 68, "deletions": 62}, "files": [{"sha": "9f423ee30fed795700456e8033c078eac6ea609b", "filename": "gcc/ChangeLog", "status": "modified", "additions": 6, "deletions": 0, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2FChangeLog?ref=e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "patch": "@@ -1,3 +1,9 @@\n+2019-05-20  Martin Liska  <mliska@suse.cz>\n+\n+\t* profile-count.h (enum profile_quality): Use capital letters\n+\tfor enum value names.  Use the adjusted names.\n+\t* profile-count.c: Use the adjusted names.\n+\n 2019-05-19  Segher Boessenkool  <segher@kernel.crashing.org>\n \n \t* config/rs6000/constraints.md (define_register_constraint \"wH\"):"}, {"sha": "21c85290d847a214f2ad96bdd839fafa45ae211a", "filename": "gcc/profile-count.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2Fprofile-count.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2Fprofile-count.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.c?ref=e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "patch": "@@ -168,11 +168,11 @@ profile_probability::dump (FILE *f) const\n         fprintf (f, \"always\");\n       else\n         fprintf (f, \"%3.1f%%\", (double)m_val * 100 / max_probability);\n-      if (m_quality == profile_adjusted)\n+      if (m_quality == ADJUSTED)\n \tfprintf (f, \" (adjusted)\");\n-      else if (m_quality == profile_afdo)\n+      else if (m_quality == AFDO)\n \tfprintf (f, \" (auto FDO)\");\n-      else if (m_quality == profile_guessed)\n+      else if (m_quality == GUESSED)\n \tfprintf (f, \" (guessed)\");\n     }\n }"}, {"sha": "715e2586bb0657d5aec073eb91c6aef315a50bf3", "filename": "gcc/profile-count.h", "status": "modified", "additions": 59, "deletions": 59, "changes": 118, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2Fprofile-count.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e48dc99e234bfb9cbdd0c992dc025b414217ff0c/gcc%2Fprofile-count.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fprofile-count.h?ref=e48dc99e234bfb9cbdd0c992dc025b414217ff0c", "patch": "@@ -28,35 +28,35 @@ class profile_count;\n    inside of classes, this is in global namespace.  */\n enum profile_quality {\n   /* Uninitialized value.  */\n-  profile_uninitialized,\n+  UNINITIALIZED_PROFILE,\n   /* Profile is based on static branch prediction heuristics and may\n      or may not match reality.  It is local to function and cannot be compared\n      inter-procedurally.  Never used by probabilities (they are always local).\n    */\n-  profile_guessed_local,\n+  GUESSED_LOCAL,\n   /* Profile was read by feedback and was 0, we used local heuristics to guess\n      better.  This is the case of functions not run in profile fedback.\n      Never used by probabilities.  */\n-  profile_guessed_global0,\n+  GUESSED_GLOBAL0,\n \n-  /* Same as profile_guessed_global0 but global count is adjusted 0.  */\n-  profile_guessed_global0adjusted,\n+  /* Same as GUESSED_GLOBAL0 but global count is adjusted 0.  */\n+  GUESSED_GLOBAL0_ADJUSTED,\n \n   /* Profile is based on static branch prediction heuristics.  It may or may\n      not reflect the reality but it can be compared interprocedurally\n      (for example, we inlined function w/o profile feedback into function\n       with feedback and propagated from that).\n      Never used by probablities.  */\n-  profile_guessed,\n+  GUESSED,\n   /* Profile was determined by autofdo.  */\n-  profile_afdo,\n+  AFDO,\n   /* Profile was originally based on feedback but it was adjusted\n      by code duplicating optimization.  It may not precisely reflect the\n      particular code path.  */\n-  profile_adjusted,\n+  ADJUSTED,\n   /* Profile was read from profile feedback or determined by accurate static\n      method.  */\n-  profile_precise\n+  PRECISE\n };\n \n extern const char *profile_quality_as_string (enum profile_quality);\n@@ -105,7 +105,7 @@ safe_scale_64bit (uint64_t a, uint64_t b, uint64_t c, uint64_t *res)\n    values greater than 1 needs to be represented otherwise.\n \n    In addition to actual value the quality of profile is tracked and propagated\n-   through all operations.  Special value UNINITIALIZED is used for probabilities\n+   through all operations.  Special value UNINITIALIZED_PROFILE is used for probabilities\n    that has not been determined yet (for example bacause of\n    -fno-guess-branch-probability)\n \n@@ -152,7 +152,7 @@ class GTY((user)) profile_probability\n   friend class profile_count;\n public:\n   profile_probability (): m_val (uninitialized_probability),\n-    m_quality (profile_guessed)\n+    m_quality (GUESSED)\n   {}\n \n   profile_probability (uint32_t val, profile_quality quality):\n@@ -164,14 +164,14 @@ class GTY((user)) profile_probability\n     {\n       profile_probability ret;\n       ret.m_val = 0;\n-      ret.m_quality = profile_precise;\n+      ret.m_quality = PRECISE;\n       return ret;\n     }\n   static profile_probability guessed_never ()\n     {\n       profile_probability ret;\n       ret.m_val = 0;\n-      ret.m_quality = profile_guessed;\n+      ret.m_quality = GUESSED;\n       return ret;\n     }\n   static profile_probability very_unlikely ()\n@@ -206,14 +206,14 @@ class GTY((user)) profile_probability\n     {\n       profile_probability ret;\n       ret.m_val = max_probability;\n-      ret.m_quality = profile_guessed;\n+      ret.m_quality = GUESSED;\n       return ret;\n     }\n   static profile_probability always ()\n     {\n       profile_probability ret;\n       ret.m_val = max_probability;\n-      ret.m_quality = profile_precise;\n+      ret.m_quality = PRECISE;\n       return ret;\n     }\n   /* Probabilities which has not been initialized. Either because\n@@ -222,7 +222,7 @@ class GTY((user)) profile_probability\n     {\n       profile_probability c;\n       c.m_val = uninitialized_probability;\n-      c.m_quality = profile_guessed;\n+      c.m_quality = GUESSED;\n       return c;\n     }\n \n@@ -235,7 +235,7 @@ class GTY((user)) profile_probability\n   /* Return true if value can be trusted.  */\n   bool reliable_p () const\n     {\n-      return m_quality >= profile_adjusted;\n+      return m_quality >= ADJUSTED;\n     }\n \n   /* Conversion from and to REG_BR_PROB_BASE integer fixpoint arithmetics.\n@@ -245,7 +245,7 @@ class GTY((user)) profile_probability\n       profile_probability ret;\n       gcc_checking_assert (v >= 0 && v <= REG_BR_PROB_BASE);\n       ret.m_val = RDIV (v * (uint64_t) max_probability, REG_BR_PROB_BASE);\n-      ret.m_quality = profile_guessed;\n+      ret.m_quality = GUESSED;\n       return ret;\n     }\n   int to_reg_br_prob_base () const\n@@ -286,7 +286,7 @@ class GTY((user)) profile_probability\n \t  gcc_checking_assert (tmp <= max_probability);\n \t  ret.m_val = tmp;\n \t}\n-      ret.m_quality = profile_precise;\n+      ret.m_quality = PRECISE;\n       return ret;\n     }\n \n@@ -362,7 +362,7 @@ class GTY((user)) profile_probability\n \treturn profile_probability::uninitialized ();\n       profile_probability ret;\n       ret.m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n-      ret.m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n+      ret.m_quality = MIN (MIN (m_quality, other.m_quality), ADJUSTED);\n       return ret;\n     }\n   profile_probability &operator*= (const profile_probability &other)\n@@ -375,7 +375,7 @@ class GTY((user)) profile_probability\n       else\n \t{\n \t  m_val = RDIV ((uint64_t)m_val * other.m_val, max_probability);\n-\t  m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n+\t  m_quality = MIN (MIN (m_quality, other.m_quality), ADJUSTED);\n \t}\n       return *this;\n     }\n@@ -391,7 +391,7 @@ class GTY((user)) profile_probability\n \t{\n \t  ret.m_val = max_probability;\n           ret.m_quality = MIN (MIN (m_quality, other.m_quality),\n-\t\t\t       profile_guessed);\n+\t\t\t       GUESSED);\n \t  return ret;\n \t}\n       else if (!m_val)\n@@ -403,7 +403,7 @@ class GTY((user)) profile_probability\n \t\t\t\t other.m_val),\n \t\t\t   max_probability);\n \t}\n-      ret.m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n+      ret.m_quality = MIN (MIN (m_quality, other.m_quality), ADJUSTED);\n       return ret;\n     }\n   profile_probability &operator/= (const profile_probability &other)\n@@ -420,7 +420,7 @@ class GTY((user)) profile_probability\n \t    {\n \t      m_val = max_probability;\n               m_quality = MIN (MIN (m_quality, other.m_quality),\n-\t\t\t       profile_guessed);\n+\t\t\t       GUESSED);\n \t      return *this;\n \t    }\n \t  else if (!m_val)\n@@ -432,7 +432,7 @@ class GTY((user)) profile_probability\n \t\t\t\t other.m_val),\n \t\t\t   max_probability);\n \t    }\n-\t  m_quality = MIN (MIN (m_quality, other.m_quality), profile_adjusted);\n+\t  m_quality = MIN (MIN (m_quality, other.m_quality), ADJUSTED);\n \t}\n       return *this;\n     }\n@@ -482,15 +482,15 @@ class GTY((user)) profile_probability\n   profile_probability guessed () const\n     {\n       profile_probability ret = *this;\n-      ret.m_quality = profile_guessed;\n+      ret.m_quality = GUESSED;\n       return ret;\n     }\n \n   /* Return THIS with quality dropped to AFDO.  */\n   profile_probability afdo () const\n     {\n       profile_probability ret = *this;\n-      ret.m_quality = profile_afdo;\n+      ret.m_quality = AFDO;\n       return ret;\n     }\n \n@@ -505,7 +505,7 @@ class GTY((user)) profile_probability\n       uint64_t tmp;\n       safe_scale_64bit (m_val, num, den, &tmp);\n       ret.m_val = MIN (tmp, max_probability);\n-      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      ret.m_quality = MIN (m_quality, ADJUSTED);\n       return ret;\n     }\n \n@@ -528,7 +528,7 @@ class GTY((user)) profile_probability\n \n   bool probably_reliable_p () const\n     {\n-      if (m_quality >= profile_adjusted)\n+      if (m_quality >= ADJUSTED)\n \treturn true;\n       if (!initialized_p ())\n \treturn false;\n@@ -539,10 +539,10 @@ class GTY((user)) profile_probability\n   /* Return false if profile_probability is bogus.  */\n   bool verify () const\n     {\n-      gcc_checking_assert (m_quality != profile_uninitialized);\n+      gcc_checking_assert (m_quality != UNINITIALIZED_PROFILE);\n       if (m_val == uninitialized_probability)\n-\treturn m_quality == profile_guessed;\n-      else if (m_quality < profile_guessed)\n+\treturn m_quality == GUESSED;\n+      else if (m_quality < GUESSED)\n \treturn false;\n       return m_val <= max_probability;\n     }\n@@ -699,14 +699,14 @@ class GTY(()) profile_count\n     {\n       profile_count c;\n       c.m_val = 0;\n-      c.m_quality = profile_adjusted;\n+      c.m_quality = ADJUSTED;\n       return c;\n     }\n   static profile_count guessed_zero ()\n     {\n       profile_count c;\n       c.m_val = 0;\n-      c.m_quality = profile_guessed;\n+      c.m_quality = GUESSED;\n       return c;\n     }\n   static profile_count one ()\n@@ -719,7 +719,7 @@ class GTY(()) profile_count\n     {\n       profile_count c;\n       c.m_val = uninitialized_count;\n-      c.m_quality = profile_guessed_local;\n+      c.m_quality = GUESSED_LOCAL;\n       return c;\n     }\n \n@@ -738,17 +738,17 @@ class GTY(()) profile_count\n   /* Return true if value can be trusted.  */\n   bool reliable_p () const\n     {\n-      return m_quality >= profile_adjusted;\n+      return m_quality >= ADJUSTED;\n     }\n   /* Return true if vlaue can be operated inter-procedurally.  */\n   bool ipa_p () const\n     {\n-      return !initialized_p () || m_quality >= profile_guessed_global0;\n+      return !initialized_p () || m_quality >= GUESSED_GLOBAL0;\n     }\n   /* Return true if quality of profile is precise.  */\n   bool precise_p () const\n     {\n-      return m_quality == profile_precise;\n+      return m_quality == PRECISE;\n     }\n \n   /* Get the value of the count.  */\n@@ -763,8 +763,8 @@ class GTY(()) profile_count\n      that makes it terminate in a way not visible in CFG.  */\n   bool ok_for_merging (profile_count other) const\n     {\n-      if (m_quality < profile_adjusted\n-\t  || other.m_quality < profile_adjusted)\n+      if (m_quality < ADJUSTED\n+\t  || other.m_quality < ADJUSTED)\n \treturn true;\n       return !(other < *this);\n     }\n@@ -851,8 +851,8 @@ class GTY(()) profile_count\n   /* Return false if profile_count is bogus.  */\n   bool verify () const\n     {\n-      gcc_checking_assert (m_quality != profile_uninitialized);\n-      return m_val != uninitialized_count || m_quality == profile_guessed_local;\n+      gcc_checking_assert (m_quality != UNINITIALIZED_PROFILE);\n+      return m_val != uninitialized_count || m_quality == GUESSED_LOCAL;\n     }\n \n   /* Comparsions are three-state and conservative.  False is returned if\n@@ -943,7 +943,7 @@ class GTY(()) profile_count\n       if (ret.m_val == 0)\n \t{\n \t  ret.m_val = 1;\n-          ret.m_quality = MIN (m_quality, profile_adjusted);\n+          ret.m_quality = MIN (m_quality, ADJUSTED);\n \t}\n       return ret;\n     }\n@@ -976,7 +976,7 @@ class GTY(()) profile_count\n \treturn profile_count::uninitialized ();\n       profile_count ret;\n       ret.m_val = RDIV (m_val * prob, REG_BR_PROB_BASE);\n-      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      ret.m_quality = MIN (m_quality, ADJUSTED);\n       return ret;\n     }\n \n@@ -1010,7 +1010,7 @@ class GTY(()) profile_count\n       gcc_checking_assert (num >= 0 && den > 0);\n       safe_scale_64bit (m_val, num, den, &tmp);\n       ret.m_val = MIN (tmp, max_count);\n-      ret.m_quality = MIN (m_quality, profile_adjusted);\n+      ret.m_quality = MIN (m_quality, ADJUSTED);\n       return ret;\n     }\n   profile_count apply_scale (profile_count num, profile_count den) const\n@@ -1029,10 +1029,10 @@ class GTY(()) profile_count\n       uint64_t val;\n       safe_scale_64bit (m_val, num.m_val, den.m_val, &val);\n       ret.m_val = MIN (val, max_count);\n-      ret.m_quality = MIN (MIN (MIN (m_quality, profile_adjusted),\n+      ret.m_quality = MIN (MIN (MIN (m_quality, ADJUSTED),\n \t\t\t        num.m_quality), den.m_quality);\n       if (num.ipa_p () && !ret.ipa_p ())\n-\tret.m_quality = MIN (num.m_quality, profile_guessed);\n+\tret.m_quality = MIN (num.m_quality, GUESSED);\n       return ret;\n     }\n \n@@ -1042,7 +1042,7 @@ class GTY(()) profile_count\n       profile_count ret = *this;\n       if (!initialized_p ())\n \treturn *this;\n-      ret.m_quality = profile_guessed_local;\n+      ret.m_quality = GUESSED_LOCAL;\n       return ret;\n     }\n \n@@ -1052,7 +1052,7 @@ class GTY(()) profile_count\n       profile_count ret = *this;\n       if (!initialized_p ())\n \treturn *this;\n-      ret.m_quality = profile_guessed_global0;\n+      ret.m_quality = GUESSED_GLOBAL0;\n       return ret;\n     }\n \n@@ -1063,27 +1063,27 @@ class GTY(()) profile_count\n       profile_count ret = *this;\n       if (!initialized_p ())\n \treturn *this;\n-      ret.m_quality = profile_guessed_global0adjusted;\n+      ret.m_quality = GUESSED_GLOBAL0_ADJUSTED;\n       return ret;\n     }\n \n   /* Return THIS with quality dropped to GUESSED.  */\n   profile_count guessed () const\n     {\n       profile_count ret = *this;\n-      ret.m_quality = MIN (ret.m_quality, profile_guessed);\n+      ret.m_quality = MIN (ret.m_quality, GUESSED);\n       return ret;\n     }\n \n   /* Return variant of profile counte which is always safe to compare\n      acorss functions.  */\n   profile_count ipa () const\n     {\n-      if (m_quality > profile_guessed_global0adjusted)\n+      if (m_quality > GUESSED_GLOBAL0_ADJUSTED)\n \treturn *this;\n-      if (m_quality == profile_guessed_global0)\n+      if (m_quality == GUESSED_GLOBAL0)\n \treturn profile_count::zero ();\n-      if (m_quality == profile_guessed_global0adjusted)\n+      if (m_quality == GUESSED_GLOBAL0_ADJUSTED)\n \treturn profile_count::adjusted_zero ();\n       return profile_count::uninitialized ();\n     }\n@@ -1092,7 +1092,7 @@ class GTY(()) profile_count\n   profile_count afdo () const\n     {\n       profile_count ret = *this;\n-      ret.m_quality = profile_afdo;\n+      ret.m_quality = AFDO;\n       return ret;\n     }\n \n@@ -1106,22 +1106,22 @@ class GTY(()) profile_count\n       if (!initialized_p () || !overall.initialized_p ()\n \t  || !overall.m_val)\n \treturn profile_probability::uninitialized ();\n-      if (*this == overall && m_quality == profile_precise)\n+      if (*this == overall && m_quality == PRECISE)\n \treturn profile_probability::always ();\n       profile_probability ret;\n       gcc_checking_assert (compatible_p (overall));\n \n       if (overall.m_val < m_val)\n \t{\n \t  ret.m_val = profile_probability::max_probability;\n-\t  ret.m_quality = profile_guessed;\n+\t  ret.m_quality = GUESSED;\n \t  return ret;\n \t}\n       else\n \tret.m_val = RDIV (m_val * profile_probability::max_probability,\n \t\t\t  overall.m_val);\n       ret.m_quality = MIN (MAX (MIN (m_quality, overall.m_quality),\n-\t\t\t\tprofile_guessed), profile_adjusted);\n+\t\t\t\tGUESSED), ADJUSTED);\n       return ret;\n     }\n \n@@ -1154,7 +1154,7 @@ class GTY(()) profile_count\n      Conversions back and forth are used to read the coverage and get it\n      into internal representation.  */\n   static profile_count from_gcov_type (gcov_type v,\n-\t\t\t\t       profile_quality quality = profile_precise);\n+\t\t\t\t       profile_quality quality = PRECISE);\n \n   /* LTO streaming support.  */\n   static profile_count stream_in (struct lto_input_block *);"}]}