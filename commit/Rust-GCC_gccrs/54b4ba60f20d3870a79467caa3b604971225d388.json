{"sha": "54b4ba60f20d3870a79467caa3b604971225d388", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6NTRiNGJhNjBmMjBkMzg3MGE3OTQ2N2NhYTNiNjA0OTcxMjI1ZDM4OA==", "commit": {"author": {"name": "Paul Brook", "email": "paul@codesourcery.com", "date": "2004-05-18T00:48:05Z"}, "committer": {"name": "Paul Brook", "email": "pbrook@gcc.gnu.org", "date": "2004-05-18T00:48:05Z"}, "message": "re PR fortran/13930 (derived type with intent(in) attribute not accepted)\n\n\tPR fortran/13930\n\t* decl.c (add_init_expr_to_sym): Remove incorrect check.\n\t(default_initializer): Move to expr.c.\n\t(variable_decl): Don't assign default initializer to variables.\n\t* expr.c (gfc_default_initializer): Move to here.\n\t* gfortran.h (gfc_default_initializer): Add prototype.\n\t* resolve.c (resolve_symbol): Check for illegal initializers.\n\tAssign default initializer.\ntestsuite/\n\t* gfortran.fortran-torture/execute/der_init_4.f90: New test.\n\nFrom-SVN: r81966", "tree": {"sha": "c59d49b2984c03bcf5e5f018b12cc2f44288e7a1", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c59d49b2984c03bcf5e5f018b12cc2f44288e7a1"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/54b4ba60f20d3870a79467caa3b604971225d388", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b4ba60f20d3870a79467caa3b604971225d388", "html_url": "https://github.com/Rust-GCC/gccrs/commit/54b4ba60f20d3870a79467caa3b604971225d388", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/54b4ba60f20d3870a79467caa3b604971225d388/comments", "author": null, "committer": null, "parents": [{"sha": "b7cefb87f053f26b4354d18f94c4e3baa4266645", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/b7cefb87f053f26b4354d18f94c4e3baa4266645", "html_url": "https://github.com/Rust-GCC/gccrs/commit/b7cefb87f053f26b4354d18f94c4e3baa4266645"}], "stats": {"total": 191, "additions": 129, "deletions": 62}, "files": [{"sha": "e27e6854132894a4d1ebef3f56546ef11451bd62", "filename": "gcc/fortran/ChangeLog", "status": "modified", "additions": 11, "deletions": 0, "changes": 11, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2FChangeLog?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,3 +1,14 @@\n+2004-05-18  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/13930\n+\t* decl.c (add_init_expr_to_sym): Remove incorrect check.\n+\t(default_initializer): Move to expr.c.\n+\t(variable_decl): Don't assign default initializer to variables.\n+\t* expr.c (gfc_default_initializer): Move to here.\n+\t* gfortran.h (gfc_default_initializer): Add prototype.\n+\t* resolve.c (resolve_symbol): Check for illegal initializers.\n+\tAssign default initializer.\n+\n 2004-05-17  Steve Kargl  <kargls@comcast.net>\n \n \t* arith.c (gfc_arith_power): Complex number raised to 0 power is 1."}, {"sha": "84547a4f750f3c0559cbd85909817ef336f8d9f2", "filename": "gcc/fortran/decl.c", "status": "modified", "additions": 6, "deletions": 62, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fdecl.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -254,7 +254,6 @@ static try\n add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t\t      locus * var_locus)\n {\n-  int i;\n   symbol_attribute attr;\n   gfc_symbol *sym;\n   gfc_expr *init;\n@@ -311,19 +310,6 @@ add_init_expr_to_sym (const char *name, gfc_expr ** initp,\n \t  && gfc_check_assign_symbol (sym, init) == FAILURE)\n \treturn FAILURE;\n \n-      for (i = 0; i < sym->attr.dimension; i++)\n-\t{\n-\t  if (sym->as->lower[i] == NULL\n-\t      || sym->as->lower[i]->expr_type != EXPR_CONSTANT\n-\t      || sym->as->upper[i] == NULL\n-\t      || sym->as->upper[i]->expr_type != EXPR_CONSTANT)\n-\t    {\n-\t      gfc_error (\"Array '%s' at %C cannot have initializer\",\n-\t\t\t sym->name);\n-\t      return FAILURE;\n-\t    }\n-\t}\n-\n       /* Add initializer.  Make sure we keep the ranks sane.  */\n       if (sym->attr.dimension && init->rank == 0)\n \tinit->rank = sym->as->rank;\n@@ -447,47 +433,6 @@ gfc_match_null (gfc_expr ** result)\n }\n \n \n-/* Get an expression for a default initializer.  */\n-static gfc_expr *\n-default_initializer (void)\n-{\n-  gfc_constructor *tail;\n-  gfc_expr *init;\n-  gfc_component *c;\n-\n-  init = NULL;\n-\n-  /* First see if we have a default initializer.  */\n-  for (c = current_ts.derived->components; c; c = c->next)\n-    {\n-      if (c->initializer && init == NULL)\n-        init = gfc_get_expr ();\n-    }\n-\n-  if (init == NULL)\n-    return NULL;\n-\n-  init->expr_type = EXPR_STRUCTURE;\n-  init->ts = current_ts;\n-  init->where = current_ts.derived->declared_at;\n-  tail = NULL;\n-  for (c = current_ts.derived->components; c; c = c->next)\n-    {\n-      if (tail == NULL)\n-        init->value.constructor = tail = gfc_get_constructor ();\n-      else\n-        {\n-          tail->next = gfc_get_constructor ();\n-          tail = tail->next;\n-        }\n-\n-      if (c->initializer)\n-        tail->expr = gfc_copy_expr (c->initializer);\n-    }\n-  return init;\n-}\n-\n-\n /* Match a variable name with an optional initializer.  When this\n    subroutine is called, a variable is expected to be parsed next.\n    Depending on what is happening at the moment, updates either the\n@@ -644,18 +589,17 @@ variable_decl (void)\n \t}\n     }\n \n-  if (current_ts.type == BT_DERIVED && !initializer)\n-    {\n-      initializer = default_initializer ();\n-    }\n-\n-  /* Add the initializer.  Note that it is fine if &initializer is\n+  /* Add the initializer.  Note that it is fine if initializer is\n      NULL here, because we sometimes also need to check if a\n      declaration *must* have an initialization expression.  */\n   if (gfc_current_state () != COMP_DERIVED)\n     t = add_init_expr_to_sym (name, &initializer, &var_locus);\n   else\n-    t = build_struct (name, cl, &initializer, &as);\n+    {\n+      if (current_ts.type == BT_DERIVED && !initializer)\n+\tinitializer = gfc_default_initializer (&current_ts);\n+      t = build_struct (name, cl, &initializer, &as);\n+    }\n \n   m = (t == SUCCESS) ? MATCH_YES : MATCH_ERROR;\n "}, {"sha": "bb912c797218d64321a252d067f85429696d18e5", "filename": "gcc/fortran/expr.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fexpr.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fexpr.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fexpr.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1953,3 +1953,46 @@ gfc_check_assign_symbol (gfc_symbol * sym, gfc_expr * rvalue)\n \n   return r;\n }\n+\n+\n+/* Get an expression for a default initializer.  */\n+\n+gfc_expr *\n+gfc_default_initializer (gfc_typespec *ts)\n+{\n+  gfc_constructor *tail;\n+  gfc_expr *init;\n+  gfc_component *c;\n+\n+  init = NULL;\n+\n+  /* See if we have a default initializer.  */\n+  for (c = ts->derived->components; c; c = c->next)\n+    {\n+      if (c->initializer && init == NULL)\n+        init = gfc_get_expr ();\n+    }\n+\n+  if (init == NULL)\n+    return NULL;\n+\n+  /* Build the constructor.  */\n+  init->expr_type = EXPR_STRUCTURE;\n+  init->ts = *ts;\n+  init->where = ts->derived->declared_at;\n+  tail = NULL;\n+  for (c = ts->derived->components; c; c = c->next)\n+    {\n+      if (tail == NULL)\n+        init->value.constructor = tail = gfc_get_constructor ();\n+      else\n+        {\n+          tail->next = gfc_get_constructor ();\n+          tail = tail->next;\n+        }\n+\n+      if (c->initializer)\n+        tail->expr = gfc_copy_expr (c->initializer);\n+    }\n+  return init;\n+}"}, {"sha": "211aafdbbdca45de662e5f6c7c935debbe57afd4", "filename": "gcc/fortran/gfortran.h", "status": "modified", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fgfortran.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fgfortran.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fgfortran.h?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1545,6 +1545,8 @@ try gfc_check_assign (gfc_expr *, gfc_expr *, int);\n try gfc_check_pointer_assign (gfc_expr *, gfc_expr *);\n try gfc_check_assign_symbol (gfc_symbol *, gfc_expr *);\n \n+gfc_expr *gfc_default_initializer (gfc_typespec *);\n+\n /* st.c */\n extern gfc_code new_st;\n "}, {"sha": "ca9208f4cafb6e7600292ce24f555b9beb67fe7e", "filename": "gcc/fortran/resolve.c", "status": "modified", "additions": 47, "deletions": 0, "changes": 47, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fresolve.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ffortran%2Fresolve.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ffortran%2Fresolve.c?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -3687,6 +3687,9 @@ resolve_symbol (gfc_symbol * sym)\n   /* Zero if we are checking a formal namespace.  */\n   static int formal_ns_flag = 1;\n   int formal_ns_save, check_constant, mp_flag;\n+  int i;\n+  const char *whynot;\n+\n \n   if (sym->attr.flavor == FL_UNKNOWN)\n     {\n@@ -3835,6 +3838,50 @@ resolve_symbol (gfc_symbol * sym)\n \t}\n     }\n \n+  if (sym->attr.flavor == FL_VARIABLE)\n+    {\n+      /* Can the sybol have an initializer?  */\n+      whynot = NULL;\n+      if (sym->attr.allocatable)\n+\twhynot = \"Allocatable\";\n+      else if (sym->attr.external)\n+\twhynot = \"External\";\n+      else if (sym->attr.dummy)\n+\twhynot = \"Dummy\";\n+      else if (sym->attr.intrinsic)\n+\twhynot = \"Intrinsic\";\n+      else if (sym->attr.result)\n+\twhynot = \"Function Result\";\n+      else if (sym->attr.dimension && !sym->attr.pointer)\n+\t{\n+\t  /* Don't allow initialization of automatic arrays.  */\n+\t  for (i = 0; i < sym->as->rank; i++)\n+\t    {\n+\t      if (sym->as->lower[i] == NULL\n+\t\t  || sym->as->lower[i]->expr_type != EXPR_CONSTANT\n+\t\t  || sym->as->upper[i] == NULL\n+\t\t  || sym->as->upper[i]->expr_type != EXPR_CONSTANT)\n+\t\t{\n+\t\t  whynot = \"Automatic array\";\n+\t\t  break;\n+\t\t}\n+\t    }\n+\t}\n+\n+      /* Reject illegal initializers.  */\n+      if (sym->value && whynot)\n+\t{\n+\t  gfc_error (\"%s '%s' at %L cannot have an initializer\",\n+\t\t     whynot, sym->name, &sym->declared_at);\n+\t  return;\n+\t}\n+\n+      /* Assign default initializer.  */\n+      if (sym->ts.type == BT_DERIVED && !(sym->value || whynot))\n+\tsym->value = gfc_default_initializer (&sym->ts);\n+    }\n+\n+\n   /* Make sure that intrinsic exist */\n   if (sym->attr.intrinsic\n       && ! gfc_intrinsic_name(sym->name, 0)"}, {"sha": "e48dfaf776b49c2808dc21309439f6f884e2c86b", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -1,3 +1,8 @@\n+2004-05-18  Paul Brook  <paul@codesourcery.com>\n+\n+\tPR fortran/13930\n+\t* gfortran.fortran-torture/execute/der_init_4.f90: New test.\n+\n 2004-05-18  Tobias Schlueter  <tobias.schlueter@physik.uni-muenchen.de>\n \n \t* gfortran.fortran-torture/execute/cmplx.f90: Add test for bug in"}, {"sha": "2b136207aa8e488d63905385a6dfaaa3c3c34b88", "filename": "gcc/testsuite/gfortran.fortran-torture/execute/der_init_4.f90", "status": "added", "additions": 15, "deletions": 0, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fder_init_4.f90", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/54b4ba60f20d3870a79467caa3b604971225d388/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fder_init_4.f90", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fgfortran.fortran-torture%2Fexecute%2Fder_init_4.f90?ref=54b4ba60f20d3870a79467caa3b604971225d388", "patch": "@@ -0,0 +1,15 @@\n+! PR13930\n+! We were trying to assugn a default initializer to dummy variables.\n+program der_init_4\n+  type t\n+    integer :: i = 42\n+  end type\n+\n+  call foo(t(5))\n+contains\n+subroutine foo(a)\n+  type (t), intent(in) :: a\n+\n+  if (a%i .ne. 5) call abort\n+end subroutine\n+end program"}]}