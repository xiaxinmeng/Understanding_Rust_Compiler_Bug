{"sha": "e97cfd97070b27823e55d717b802c4bc95954104", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6ZTk3Y2ZkOTcwNzBiMjc4MjNlNTVkNzE3YjgwMmM0YmM5NTk1NDEwNA==", "commit": {"author": {"name": "Nicola Pero", "email": "nicola.pero@meta-innovation.com", "date": "2010-12-11T19:43:21Z"}, "committer": {"name": "Nicola Pero", "email": "nicola@gcc.gnu.org", "date": "2010-12-11T19:43:21Z"}, "message": "In libobjc/: 2010-12-11 Nicola Pero <nicola.pero@meta-innovation.com>\n\nIn libobjc/:\n2010-12-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * sendmsg.c (selector_resolveClassMethod): New.\n        (selector_resolveInstanceMethod): New.\n        (__objc_resolve_class_method): New.\n        (__objc_resolve_instance_method): New.\n        (get_imp): Call __objc_resolve_class_method or\n        __objc_resolve_instance_method at the appropriate time.\n        (objc_msg_lookup): Same.\n        (class_getClassMethod): Same.\n        (class_getInstanceMethod): Same.\n        (__objc_init_dispatch_tables): Initialize\n        selector_resolveClassMethod and selector_resolveInstanceMethod.\n        * objc/runtime.h: Updated documentation of class_getClassMethod,\n        class_getInstanceMethod and class_getMethodImplementation.\n\nIn gcc/testsuite/:\n2010-12-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n\n        * objc.dg/gnu-api-2-resolve-method.m: New.\n        * obj-c++.dg/gnu-api-2-resolve-method.mm: New.\n\nFrom-SVN: r167712", "tree": {"sha": "c50ecdee614fbdc518483d8012362f18adfbe922", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/c50ecdee614fbdc518483d8012362f18adfbe922"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/e97cfd97070b27823e55d717b802c4bc95954104", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97cfd97070b27823e55d717b802c4bc95954104", "html_url": "https://github.com/Rust-GCC/gccrs/commit/e97cfd97070b27823e55d717b802c4bc95954104", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/e97cfd97070b27823e55d717b802c4bc95954104/comments", "author": {"login": "Nico-31415", "id": 94470564, "node_id": "U_kgDOBaGBpA", "avatar_url": "https://avatars.githubusercontent.com/u/94470564?v=4", "gravatar_id": "", "url": "https://api.github.com/users/Nico-31415", "html_url": "https://github.com/Nico-31415", "followers_url": "https://api.github.com/users/Nico-31415/followers", "following_url": "https://api.github.com/users/Nico-31415/following{/other_user}", "gists_url": "https://api.github.com/users/Nico-31415/gists{/gist_id}", "starred_url": "https://api.github.com/users/Nico-31415/starred{/owner}{/repo}", "subscriptions_url": "https://api.github.com/users/Nico-31415/subscriptions", "organizations_url": "https://api.github.com/users/Nico-31415/orgs", "repos_url": "https://api.github.com/users/Nico-31415/repos", "events_url": "https://api.github.com/users/Nico-31415/events{/privacy}", "received_events_url": "https://api.github.com/users/Nico-31415/received_events", "type": "User", "site_admin": false}, "committer": null, "parents": [{"sha": "375d1239a479316e3fc806708477b98b076673e8", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/375d1239a479316e3fc806708477b98b076673e8", "html_url": "https://github.com/Rust-GCC/gccrs/commit/375d1239a479316e3fc806708477b98b076673e8"}], "stats": {"total": 1348, "additions": 1331, "deletions": 17}, "files": [{"sha": "08baf3439a1cc3e65a09876a7ed0496dd1bade0d", "filename": "gcc/testsuite/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2FChangeLog?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -1,3 +1,8 @@\n+2010-12-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* objc.dg/gnu-api-2-resolve-method.m: New.\n+\t* obj-c++.dg/gnu-api-2-resolve-method.mm: New.\t\n+\n 2010-12-10 Ahmad Sharif <asharif@google.com>\n \n \t* gcc.target/i386/max-stack-align.c: New testcase."}, {"sha": "09f21b9ec63c45b87d758a83159b9c71cc243d64", "filename": "gcc/testsuite/obj-c++.dg/gnu-api-2-resolve-method.mm", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-resolve-method.mm", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-resolve-method.mm", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobj-c%2B%2B.dg%2Fgnu-api-2-resolve-method.mm?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -0,0 +1,563 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+   This is test 'resolve-method', covering +resolveClassMethod: and\n+   +resolveInstanceMethod:.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <iostream>\n+#include <cstring>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+\n+/* A number of tests will try invoking methods that don't exist.  We\n+   want to record the fact, but not abort the program, so we supply\n+   our own fowarding implementation which will invoke the following\n+   function for any method that is not found.  */\n+\n+/* Keep track of how many times a non-existing method was executed.  */\n+static int nonExistingMethodCount = 0;\n+\n+/* Inspired by nil_method in libobjc.  */\n+id nonExisting_method (id receiver __attribute__ ((__unused__)),\n+\t\t       SEL sel __attribute__ ((__unused__)))\n+{\n+  nonExistingMethodCount++;\n+  return nil;\n+}\n+\n+/* Keep track of how many times the forwarding lookup was invoked.  */\n+static int forwardingCount = 0;\n+\n+/* We install this forwarding hook to cause all failed method lookups\n+   to call our 'nonExisting_method' function.  */\n+IMP forward_everything_to_non_existing_method (id receiver __attribute__ ((__unused__)),\n+\t\t\t\t\t       SEL sel __attribute__ ((__unused__)))\n+{\n+  forwardingCount++;\n+  return (IMP)nonExisting_method;\n+}\n+\n+\n+/* 'CountClass' is used to test that +resolveClassMethod: and\n+   +resolveInstanceMethod: are called when expected.  They do nothing\n+   other than recording that they are called.  */\n+@interface CountClass : MyRootClass\n++ (BOOL) resolveClassMethod: (SEL)selector;\n++ (BOOL) resolveInstanceMethod: (SEL)selector;\n++ (void) existingClassMethod;\n+- (void) existingInstanceMethod;\n+@end\n+\n+/* Count how many times the methods are called for class\n+   'CountClass'.  */\n+static int resolveClassMethodCount = 0;\n+static int resolveInstanceMethodCount = 0;\n+\n+@implementation CountClass : MyRootClass\n++ (BOOL) resolveClassMethod: (SEL)selector\n+{\n+  resolveClassMethodCount++;\n+  return NO;\n+}\n++ (BOOL) resolveInstanceMethod: (SEL)selector\n+{\n+  resolveInstanceMethodCount++;\n+  return NO;\n+}\n++ (void) existingClassMethod\n+{\n+  return;\n+}\n+- (void) existingInstanceMethod\n+{\n+  return;\n+}\n+@end\n+\n+@protocol NonExistingStuff\n++ (void) nonExistingClassMethod;\n+- (void) nonExistingInstanceMethod;\n+@end\n+\n+/* Declare a category with some non existing methods, but don't\n+   actually implement them.  */\n+@interface CountClass (NonExistingStuff) <NonExistingStuff>\n+@end\n+\n+\n+/* 'SelfExtendingClass' is used to test that +resolveClassMethod: and\n+   +resolveInstanceMethod: can extend the class.  Any time they are\n+   called, they install the requested method, mapping it to the same\n+   implementation as 'countHits'.  */\n+@interface SelfExtendingClass : MyRootClass\n++ (int) countHits;\n++ (BOOL) resolveClassMethod: (SEL)selector;\n++ (BOOL) resolveInstanceMethod: (SEL)selector;\n+@end\n+\n+/* How many times the countHits method (or a clone) was called.  */\n+static int hitCount = 0;\n+\n+@implementation SelfExtendingClass : MyRootClass\n++ (int) countHits\n+{\n+  hitCount++;\n+  return hitCount;\n+}\n++ (BOOL) resolveClassMethod: (SEL)selector\n+{\n+  /* Duplicate the 'countHits' method into the new method.  */\n+  Method method = class_getClassMethod (self, @selector (countHits));\n+  class_addMethod (object_getClass (self), selector,\n+\t\t   method_getImplementation (method),\n+\t\t   method_getTypeEncoding (method));\n+  resolveClassMethodCount++;\n+  return YES;\n+}\n++ (BOOL) resolveInstanceMethod: (SEL)selector\n+{\n+  /* Duplicate the 'countHits' method into the new method.  */\n+  Method method = class_getClassMethod (self, @selector (countHits));\n+  class_addMethod (self, selector,\n+\t\t   method_getImplementation (method),\n+\t\t   method_getTypeEncoding (method));\n+  resolveInstanceMethodCount++;\n+  return YES;\n+\n+}\n+@end\n+\n+@protocol NonExistingStuff2\n++ (int) nonExistingCountHitsMethod;\n+- (int) nonExistingCountHitsMethod;\n+\n++ (int) nonExistingCountHitsMethod2;\n+- (int) nonExistingCountHitsMethod2;\n+\n++ (int) nonExistingCountHitsMethod3;\n+- (int) nonExistingCountHitsMethod3;\n+@end\n+\n+/* Declare a category with some non existing methods, but don't\n+   actually implement them.  */\n+@interface SelfExtendingClass (NonExistingStuff) <NonExistingStuff2>\n+@end\n+\n+\n+int main ()\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  /* Install our test forwarding hook.  */\n+  __objc_msg_forward2 = forward_everything_to_non_existing_method;\n+\n+  std::cout << \"Testing [+resolveClassMethod:] ...\\n\";\t\n+  {\n+    Method m;\n+    IMP i;\n+\n+    /** CountClass tests.  **/\n+\n+    /* Call an existing method.  No +resolveClassMethod and no\n+       forwarding should be triggered.  */\n+    [CountClass existingClassMethod];\n+\n+    if (resolveClassMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Call a non-existing method.  Both +resolveClassMethod and the\n+       forwarding should be triggered.  */\n+    [CountClass nonExistingClassMethod];\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getClassMethod(), which\n+       should trigger the resolve methods too, but not the\n+       forwarding.  */\n+    m = class_getClassMethod (objc_getClass (\"CountClass\"),\n+\t\t\t      @selector (existingClassMethod));\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    m = class_getClassMethod (objc_getClass (\"CountClass\"),\n+\t\t\t      @selector (nonExistingClassMethod));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getMethodImplementation(),\n+       which should trigger the resolve methods and the forwarding\n+       (but not execute the forwarding, obviously).  */\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"CountClass\")),\n+\t\t\t\t       @selector (existingClassMethod));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"CountClass\")),\n+\t\t\t\t       @selector (nonExistingClassMethod));\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 2)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+\n+    /* Reset the counters for the next test.  */\n+    resolveClassMethodCount = 0;\n+    forwardingCount = 0;\n+    nonExistingMethodCount = 0;\n+\n+\n+    /** SelfExtendingClass tests.  **/\n+\n+    /* Try the direct countHits method first.  No resolving or\n+       forwarding should be triggered.  */\n+    if ([SelfExtendingClass countHits] != 1)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now, try calling a non-existing count method; it should be\n+       installed and invoked.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod] != 2)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod] != 3)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getClassMethod().  */\n+    m = class_getClassMethod (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t      @selector (nonExistingCountHitsMethod2));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod2] != 4)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getMethodImplementation().  */\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"SelfExtendingClass\")),\n+\t\t\t\t       @selector (nonExistingCountHitsMethod3));\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod3] != 5)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+  }\n+\n+  /* Reset the counters for the next test.  */\n+  nonExistingMethodCount = 0;\n+  forwardingCount = 0;\n+  hitCount = 0;\n+\n+  std::cout << \"Testing [+resolveInstanceMethod:] ...\\n\";\t\n+  {\n+    Method m;\n+    IMP i;\n+    CountClass *object = [[CountClass alloc] init];\n+    SelfExtendingClass *object2 = [[SelfExtendingClass alloc] init];\n+\n+    /** CountClass tests.  **/\n+\n+    /* Call an existing method.  No +resolveInstanceMethod and no\n+       forwarding should be triggered.  */\n+    [object existingInstanceMethod];\n+\n+    if (resolveInstanceMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Call a non-existing method.  Both +resolveInstanceMethod and the\n+       forwarding should be triggered.  */\n+    [object nonExistingInstanceMethod];\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getInstanceMethod(), which\n+       should trigger the resolve methods too, but not the\n+       forwarding.  */\n+    m = class_getInstanceMethod (objc_getClass (\"CountClass\"),\n+\t\t\t\t @selector (existingInstanceMethod));\n+    \n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    m = class_getInstanceMethod (objc_getClass (\"CountClass\"),\n+\t\t\t\t @selector (nonExistingInstanceMethod));\n+\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getMethodImplementation(),\n+       which should trigger the resolve methods and the\n+       forwarding.  */\n+    i = class_getMethodImplementation (objc_getClass (\"CountClass\"),\n+\t\t\t\t       @selector (existingInstanceMethod));\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    i = class_getMethodImplementation (objc_getClass (\"CountClass\"),\n+\t\t\t\t       @selector (nonExistingInstanceMethod));\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 2)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Reset the counters for the next test.  */\n+    resolveInstanceMethodCount = 0;\n+    forwardingCount = 0;\n+    nonExistingMethodCount = 0;\n+\n+\n+    /** SelfExtendingClass tests.  **/\n+\n+    /* Try the direct countHits method first.  No resolving or\n+       forwarding should be triggered.  */\n+    if ([SelfExtendingClass countHits] != 1)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now, try calling a non-existing count method; it should be\n+       installed and invoked.  */\n+    if ([object2 nonExistingCountHitsMethod] != 2)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod] != 3)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now try the same tests with class_getInstanceMethod().  */\n+    m = class_getInstanceMethod (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t\t @selector (nonExistingCountHitsMethod2));\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod2] != 4)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getMethodImplementation().  */\n+    i = class_getMethodImplementation (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t\t       @selector (nonExistingCountHitsMethod3));\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod3] != 5)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+  }\n+\n+\n+  return (0);\n+}"}, {"sha": "767dc73cf337b5a41da81ed6fac9839123ebaef8", "filename": "gcc/testsuite/objc.dg/gnu-api-2-resolve-method.m", "status": "added", "additions": 563, "deletions": 0, "changes": 563, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-resolve-method.m", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-resolve-method.m", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Ftestsuite%2Fobjc.dg%2Fgnu-api-2-resolve-method.m?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -0,0 +1,563 @@\n+/* Test the Modern GNU Objective-C Runtime API.\n+\n+   This is test 'resolve-method', covering +resolveClassMethod: and\n+   +resolveInstanceMethod:.  */\n+\n+/* { dg-do run } */\n+/* { dg-skip-if \"\" { *-*-* } { \"-fnext-runtime\" } { \"\" } } */\n+\n+/* To get the modern GNU Objective-C Runtime API, you include\n+   objc/runtime.h.  */\n+#include <objc/runtime.h>\n+#include <stdlib.h>\n+#include <stdio.h>\n+#include <string.h>\n+\n+@interface MyRootClass\n+{ Class isa; }\n++ alloc;\n+- init;\n+@end\n+\n+@implementation MyRootClass\n++ alloc { return class_createInstance (self, 0); }\n+- init  { return self; }\n+@end\n+\n+\n+/* A number of tests will try invoking methods that don't exist.  We\n+   want to record the fact, but not abort the program, so we supply\n+   our own fowarding implementation which will invoke the following\n+   function for any method that is not found.  */\n+\n+/* Keep track of how many times a non-existing method was executed.  */\n+static int nonExistingMethodCount = 0;\n+\n+/* Inspired by nil_method in libobjc.  */\n+id nonExisting_method (id receiver __attribute__ ((__unused__)),\n+\t\t       SEL sel __attribute__ ((__unused__)))\n+{\n+  nonExistingMethodCount++;\n+  return nil;\n+}\n+\n+/* Keep track of how many times the forwarding lookup was invoked.  */\n+static int forwardingCount = 0;\n+\n+/* We install this forwarding hook to cause all failed method lookups\n+   to call our 'nonExisting_method' function.  */\n+IMP forward_everything_to_non_existing_method (id receiver __attribute__ ((__unused__)),\n+\t\t\t\t\t       SEL sel __attribute__ ((__unused__)))\n+{\n+  forwardingCount++;\n+  return (IMP)nonExisting_method;\n+}\n+\n+\n+/* 'CountClass' is used to test that +resolveClassMethod: and\n+   +resolveInstanceMethod: are called when expected.  They do nothing\n+   other than recording that they are called.  */\n+@interface CountClass : MyRootClass\n++ (BOOL) resolveClassMethod: (SEL)selector;\n++ (BOOL) resolveInstanceMethod: (SEL)selector;\n++ (void) existingClassMethod;\n+- (void) existingInstanceMethod;\n+@end\n+\n+/* Count how many times the methods are called for class\n+   'CountClass'.  */\n+static int resolveClassMethodCount = 0;\n+static int resolveInstanceMethodCount = 0;\n+\n+@implementation CountClass : MyRootClass\n++ (BOOL) resolveClassMethod: (SEL)selector\n+{\n+  resolveClassMethodCount++;\n+  return NO;\n+}\n++ (BOOL) resolveInstanceMethod: (SEL)selector\n+{\n+  resolveInstanceMethodCount++;\n+  return NO;\n+}\n++ (void) existingClassMethod\n+{\n+  return;\n+}\n+- (void) existingInstanceMethod\n+{\n+  return;\n+}\n+@end\n+\n+@protocol NonExistingStuff\n++ (void) nonExistingClassMethod;\n+- (void) nonExistingInstanceMethod;\n+@end\n+\n+/* Declare a category with some non existing methods, but don't\n+   actually implement them.  */\n+@interface CountClass (NonExistingStuff) <NonExistingStuff>\n+@end\n+\n+\n+/* 'SelfExtendingClass' is used to test that +resolveClassMethod: and\n+   +resolveInstanceMethod: can extend the class.  Any time they are\n+   called, they install the requested method, mapping it to the same\n+   implementation as 'countHits'.  */\n+@interface SelfExtendingClass : MyRootClass\n++ (int) countHits;\n++ (BOOL) resolveClassMethod: (SEL)selector;\n++ (BOOL) resolveInstanceMethod: (SEL)selector;\n+@end\n+\n+/* How many times the countHits method (or a clone) was called.  */\n+static int hitCount = 0;\n+\n+@implementation SelfExtendingClass : MyRootClass\n++ (int) countHits\n+{\n+  hitCount++;\n+  return hitCount;\n+}\n++ (BOOL) resolveClassMethod: (SEL)selector\n+{\n+  /* Duplicate the 'countHits' method into the new method.  */\n+  Method method = class_getClassMethod (self, @selector (countHits));\n+  class_addMethod (object_getClass (self), selector,\n+\t\t   method_getImplementation (method),\n+\t\t   method_getTypeEncoding (method));\n+  resolveClassMethodCount++;\n+  return YES;\n+}\n++ (BOOL) resolveInstanceMethod: (SEL)selector\n+{\n+  /* Duplicate the 'countHits' method into the new method.  */\n+  Method method = class_getClassMethod (self, @selector (countHits));\n+  class_addMethod (self, selector,\n+\t\t   method_getImplementation (method),\n+\t\t   method_getTypeEncoding (method));\n+  resolveInstanceMethodCount++;\n+  return YES;\n+\n+}\n+@end\n+\n+@protocol NonExistingStuff2\n++ (int) nonExistingCountHitsMethod;\n+- (int) nonExistingCountHitsMethod;\n+\n++ (int) nonExistingCountHitsMethod2;\n+- (int) nonExistingCountHitsMethod2;\n+\n++ (int) nonExistingCountHitsMethod3;\n+- (int) nonExistingCountHitsMethod3;\n+@end\n+\n+/* Declare a category with some non existing methods, but don't\n+   actually implement them.  */\n+@interface SelfExtendingClass (NonExistingStuff) <NonExistingStuff2>\n+@end\n+\n+\n+int main (int argc, void **args)\n+{\n+  /* Functions are tested in alphabetical order.  */\n+\n+  /* Install our test forwarding hook.  */\n+  __objc_msg_forward2 = forward_everything_to_non_existing_method;\n+\n+  printf (\"Testing [+resolveClassMethod:]...\\n\");\n+  {\n+    Method m;\n+    IMP i;\n+\n+    /** CountClass tests.  **/\n+\n+    /* Call an existing method.  No +resolveClassMethod and no\n+       forwarding should be triggered.  */\n+    [CountClass existingClassMethod];\n+\n+    if (resolveClassMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Call a non-existing method.  Both +resolveClassMethod and the\n+       forwarding should be triggered.  */\n+    [CountClass nonExistingClassMethod];\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getClassMethod(), which\n+       should trigger the resolve methods too, but not the\n+       forwarding.  */\n+    m = class_getClassMethod (objc_getClass (\"CountClass\"),\n+\t\t\t      @selector (existingClassMethod));\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    m = class_getClassMethod (objc_getClass (\"CountClass\"),\n+\t\t\t      @selector (nonExistingClassMethod));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getMethodImplementation(),\n+       which should trigger the resolve methods and the forwarding\n+       (but not execute the forwarding, obviously).  */\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"CountClass\")),\n+\t\t\t\t       @selector (existingClassMethod));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"CountClass\")),\n+\t\t\t\t       @selector (nonExistingClassMethod));\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 2)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+\n+    /* Reset the counters for the next test.  */\n+    resolveClassMethodCount = 0;\n+    forwardingCount = 0;\n+    nonExistingMethodCount = 0;\n+\n+\n+    /** SelfExtendingClass tests.  **/\n+\n+    /* Try the direct countHits method first.  No resolving or\n+       forwarding should be triggered.  */\n+    if ([SelfExtendingClass countHits] != 1)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now, try calling a non-existing count method; it should be\n+       installed and invoked.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod] != 2)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod] != 3)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getClassMethod().  */\n+    m = class_getClassMethod (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t      @selector (nonExistingCountHitsMethod2));\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod2] != 4)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getMethodImplementation().  */\n+    i = class_getMethodImplementation (object_getClass (objc_getClass (\"SelfExtendingClass\")),\n+\t\t\t\t       @selector (nonExistingCountHitsMethod3));\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([SelfExtendingClass nonExistingCountHitsMethod3] != 5)\n+      abort ();\n+\n+    if (resolveClassMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+  }\n+\n+  /* Reset the counters for the next test.  */\n+  nonExistingMethodCount = 0;\n+  forwardingCount = 0;\n+  hitCount = 0;\n+\n+  printf (\"Testing [+resolveInstanceMethod:]...\\n\");\n+  {\n+    Method m;\n+    IMP i;\n+    CountClass *object = [[CountClass alloc] init];\n+    SelfExtendingClass *object2 = [[SelfExtendingClass alloc] init];\n+\n+    /** CountClass tests.  **/\n+\n+    /* Call an existing method.  No +resolveInstanceMethod and no\n+       forwarding should be triggered.  */\n+    [object existingInstanceMethod];\n+\n+    if (resolveInstanceMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Call a non-existing method.  Both +resolveInstanceMethod and the\n+       forwarding should be triggered.  */\n+    [object nonExistingInstanceMethod];\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getInstanceMethod(), which\n+       should trigger the resolve methods too, but not the\n+       forwarding.  */\n+    m = class_getInstanceMethod (objc_getClass (\"CountClass\"),\n+\t\t\t\t @selector (existingInstanceMethod));\n+    \n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    m = class_getInstanceMethod (objc_getClass (\"CountClass\"),\n+\t\t\t\t @selector (nonExistingInstanceMethod));\n+\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Now try the same tests with class_getMethodImplementation(),\n+       which should trigger the resolve methods and the\n+       forwarding.  */\n+    i = class_getMethodImplementation (objc_getClass (\"CountClass\"),\n+\t\t\t\t       @selector (existingInstanceMethod));\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 1)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    i = class_getMethodImplementation (objc_getClass (\"CountClass\"),\n+\t\t\t\t       @selector (nonExistingInstanceMethod));\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 2)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 1)\n+      abort ();\n+\n+    /* Reset the counters for the next test.  */\n+    resolveInstanceMethodCount = 0;\n+    forwardingCount = 0;\n+    nonExistingMethodCount = 0;\n+\n+\n+    /** SelfExtendingClass tests.  **/\n+\n+    /* Try the direct countHits method first.  No resolving or\n+       forwarding should be triggered.  */\n+    if ([SelfExtendingClass countHits] != 1)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 0)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now, try calling a non-existing count method; it should be\n+       installed and invoked.  */\n+    if ([object2 nonExistingCountHitsMethod] != 2)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod] != 3)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 1)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Now try the same tests with class_getInstanceMethod().  */\n+    m = class_getInstanceMethod (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t\t @selector (nonExistingCountHitsMethod2));\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod2] != 4)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 2)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+\n+    /* Now try the same tests with class_getMethodImplementation().  */\n+    i = class_getMethodImplementation (objc_getClass (\"SelfExtendingClass\"),\n+\t\t\t\t       @selector (nonExistingCountHitsMethod3));\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+    \n+    if (forwardingCount != 0)\n+      abort ();\n+    \n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+\n+    /* Try it again.  The method has now been installed, so it should\n+       be used and work, but with no additional resolving\n+       involved.  */\n+    if ([object2 nonExistingCountHitsMethod3] != 5)\n+      abort ();\n+\n+    if (resolveInstanceMethodCount != 3)\n+      abort ();\n+\n+    if (forwardingCount != 0)\n+      abort ();\n+\n+    if (nonExistingMethodCount != 0)\n+      abort ();\n+  }\n+\n+\n+  return 0;\n+}"}, {"sha": "fa609a58f86a597f198d59e726572ca87ba684b5", "filename": "libobjc/ChangeLog", "status": "modified", "additions": 16, "deletions": 0, "changes": 16, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2FChangeLog?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -1,3 +1,19 @@\n+2010-12-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n+\n+\t* sendmsg.c (selector_resolveClassMethod): New.\n+\t(selector_resolveInstanceMethod): New.\n+\t(__objc_resolve_class_method): New.\n+\t(__objc_resolve_instance_method): New.\n+\t(get_imp): Call __objc_resolve_class_method or\n+\t__objc_resolve_instance_method at the appropriate time.\n+\t(objc_msg_lookup): Same.\n+\t(class_getClassMethod): Same.\t\n+\t(class_getInstanceMethod): Same.\n+\t(__objc_init_dispatch_tables): Initialize\n+\tselector_resolveClassMethod and selector_resolveInstanceMethod.\n+\t* objc/runtime.h: Updated documentation of class_getClassMethod,\n+\tclass_getInstanceMethod and class_getMethodImplementation.\n+\t\n 2010-12-11  Nicola Pero  <nicola.pero@meta-innovation.com>\n \n \t* objc-private/module-abi-8.h (struct objc_symtab): Updated"}, {"sha": "f5df691fe5279af778245190843c9dc6f0b821af", "filename": "libobjc/objc/runtime.h", "status": "modified", "additions": 15, "deletions": 3, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2Fobjc%2Fruntime.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2Fobjc%2Fruntime.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fobjc%2Fruntime.h?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -590,13 +590,17 @@ objc_disposeClassPair (Class class_);\n /* Return the instance method with selector 'selector' of class\n    'class_', or NULL if the class (or one of its superclasses) does\n    not implement the method.  Return NULL if class_ is Nil or selector\n-   is NULL.  */\n+   is NULL.  Calling this function may trigger a call to\n+   +resolveInstanceMethod:, but does not return a forwarding\n+   function.  */\n objc_EXPORT Method class_getInstanceMethod (Class class_, SEL selector);\n \n /* Return the class method with selector 'selector' of class 'class_',\n    or NULL if the class (or one of its superclasses) does not\n    implement the method.  Return NULL if class_ is Nil or selector is\n-   NULL.  */\n+   NULL.  Calling this function may trigger a call to\n+   +resolveClassMethod:, but does not return a forwarding\n+   function.  */\n objc_EXPORT Method class_getClassMethod (Class class_, SEL selector);\n \n /* Return the IMP (pointer to the function implementing a method) for\n@@ -607,7 +611,15 @@ objc_EXPORT Method class_getClassMethod (Class class_, SEL selector);\n    arguments and return type before calling it.  To get a class\n    method, you can pass the meta-class as the class_ argument (ie, use\n    class_getMethodImplementation (object_getClass (class_),\n-   selector)).  Return NULL if class_ is Nil or selector is NULL.  */\n+   selector)).  Return NULL if class_ is Nil or selector is NULL.\n+   This function first looks for an existing method; if it is not\n+   found, it calls +resolveClassMethod: or +resolveInstanceMethod:\n+   (depending on whether a class or instance method is being looked\n+   up) if it is implemented.  If the method returns YES, then it tries\n+   the look up again (the assumption being that +resolveClassMethod:\n+   or resolveInstanceMethod: will add the method using\n+   class_addMethod()).  If it is still not found, it returns a\n+   forwarding function.  */\n objc_EXPORT IMP class_getMethodImplementation (Class class_, SEL selector);\n \n /* Compatibility Note: the Apple/NeXT runtime has the function"}, {"sha": "4748695938d62857da0562e5ddbd17a556b83eb7", "filename": "libobjc/sendmsg.c", "status": "modified", "additions": 169, "deletions": 14, "changes": 183, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2Fsendmsg.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/e97cfd97070b27823e55d717b802c4bc95954104/libobjc%2Fsendmsg.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libobjc%2Fsendmsg.c?ref=e97cfd97070b27823e55d717b802c4bc95954104", "patch": "@@ -138,6 +138,102 @@ __objc_get_forward_imp (id rcv, SEL sel)\n     }\n }\n \n+/* Selectors for +resolveClassMethod: and +resolveInstanceMethod:.\n+   These are set up at startup.  */\n+static SEL selector_resolveClassMethod = NULL;\n+static SEL selector_resolveInstanceMethod = NULL;\n+\n+/* Internal routines use to resolve a class method using\n+   +resolveClassMethod:.  'class' is always a non-Nil class (*not* a\n+   meta-class), and 'sel' is the selector that we are trying to\n+   resolve.  This must be called when class is not Nil, and the\n+   dispatch table for class methods has already been installed.\n+\n+   This routine tries to call +resolveClassMethod: to give an\n+   opportunity to resolve the method.  If +resolveClassMethod: returns\n+   YES, it tries looking up the method again, and if found, it returns\n+   it.  Else, it returns NULL.  */\n+static inline\n+IMP\n+__objc_resolve_class_method (Class class, SEL sel)\n+{\n+  /* We need to lookup +resolveClassMethod:.  */\n+  BOOL (*resolveMethodIMP) (id, SEL, SEL);\n+\n+  /* The dispatch table for class methods is already installed and we\n+     don't want any forwarding to happen when looking up this method,\n+     so we just look it up directly.  Note that if 'sel' is precisely\n+     +resolveClassMethod:, this would look it up yet again and find\n+     nothing.  That's no problem and there's no recursion.  */\n+  resolveMethodIMP = (BOOL (*) (id, SEL, SEL))sarray_get_safe\n+    (class->class_pointer->dtable, (size_t) selector_resolveClassMethod->sel_id);\n+\n+  if (resolveMethodIMP && resolveMethodIMP ((id)class, selector_resolveClassMethod, sel))\n+    {\n+      /* +resolveClassMethod: returned YES.  Look the method up again.\n+\t We already know the dtable is installed.  */\n+      \n+      /* TODO: There is the case where +resolveClassMethod: is buggy\n+\t and returned YES without actually adding the method.  We\n+\t could maybe print an error message.  */\n+      return sarray_get_safe (class->class_pointer->dtable, (size_t) sel->sel_id);\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Internal routines use to resolve a instance method using\n+   +resolveInstanceMethod:.  'class' is always a non-Nil class, and\n+   'sel' is the selector that we are trying to resolve.  This must be\n+   called when class is not Nil, and the dispatch table for instance\n+   methods has already been installed.\n+\n+   This routine tries to call +resolveInstanceMethod: to give an\n+   opportunity to resolve the method.  If +resolveInstanceMethod:\n+   returns YES, it tries looking up the method again, and if found, it\n+   returns it.  Else, it returns NULL.  */\n+static inline\n+IMP\n+__objc_resolve_instance_method (Class class, SEL sel)\n+{\n+  /* We need to lookup +resolveInstanceMethod:.  */\n+  BOOL (*resolveMethodIMP) (id, SEL, SEL);\n+\n+  /* The dispatch table for class methods may not be already installed\n+     so we have to install it if needed.  */\n+  resolveMethodIMP = sarray_get_safe (class->class_pointer->dtable,\n+\t\t\t\t      (size_t) selector_resolveInstanceMethod->sel_id);\n+  if (resolveMethodIMP == 0)\n+    {\n+      /* Try again after installing the dtable.  */\n+      if (class->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t{\n+\t  objc_mutex_lock (__objc_runtime_mutex);\n+\t  if (class->class_pointer->dtable == __objc_uninstalled_dtable)\n+\t    __objc_install_dispatch_table_for_class (class->class_pointer);\n+\t  objc_mutex_unlock (__objc_runtime_mutex);\n+\t}\n+      resolveMethodIMP = sarray_get_safe (class->class_pointer->dtable,\n+\t\t\t\t\t  (size_t) selector_resolveInstanceMethod->sel_id);\t      \n+    }\n+\n+  if (resolveMethodIMP && resolveMethodIMP ((id)class, selector_resolveInstanceMethod, sel))\n+    {\n+      /* +resolveInstanceMethod: returned YES.  Look the method up\n+\t again.  We already know the dtable is installed.  */\n+      \n+      /* TODO: There is the case where +resolveInstanceMethod: is\n+\t buggy and returned YES without actually adding the method.\n+\t We could maybe print an error message.  */\n+      return sarray_get_safe (class->dtable, (size_t) sel->sel_id);\t\n+    }\n+\n+  return NULL;\n+}\n+\n+/* Temporary definition until we include objc/runtime.h.  */\n+objc_EXPORT Class objc_lookupClass (const char *name);\n+\n /* Given a class and selector, return the selector's implementation.  */\n inline\n IMP\n@@ -188,14 +284,35 @@ get_imp (Class class, SEL sel)\n \t    {\n \t      /* The dispatch table has been installed, and the method\n \t\t is not in the dispatch table.  So the method just\n-\t\t doesn't exist for the class.  Return the forwarding\n-\t\t implementation.  We don't know the receiver (only its\n-\t\t class), so we have to pass 'nil' as the first\n-\t\t argument.  Passing the class as first argument is\n-\t\t wrong because the class is not the receiver; it can\n-\t\t result in us calling a class method when we want an\n-\t\t instance method of the same name.  */\n-             res = __objc_get_forward_imp (nil, sel);\n+\t\t doesn't exist for the class.  */\n+\n+\t      /* Try going through the +resolveClassMethod: or\n+\t\t +resolveInstanceMethod: process.  */\n+\t      if (CLS_ISMETA (class))\n+\t\t{\n+\t\t  /* We have the meta class, but we need to invoke the\n+\t\t     +resolveClassMethod: method on the class.  So, we\n+\t\t     need to obtain the class from the meta class,\n+\t\t     which we do using the fact that both the class\n+\t\t     and the meta-class have the same name.  */\n+\t\t  Class realClass = objc_lookupClass (class->name);\n+\t\t  if (realClass)\n+\t\t    res = __objc_resolve_class_method (realClass, sel);\n+\t\t}\n+\t      else\n+\t\tres = __objc_resolve_instance_method (class, sel);\n+\n+\t      if (res == 0)\n+\t\t{\n+\t\t  /* If that fails, then return the forwarding\n+\t\t     implementation.  We don't know the receiver (only its\n+\t\t     class), so we have to pass 'nil' as the first\n+\t\t     argument.  Passing the class as first argument is\n+\t\t     wrong because the class is not the receiver; it can\n+\t\t     result in us calling a class method when we want an\n+\t\t     instance method of the same name.  */\n+\t\t  res = __objc_get_forward_imp (nil, sel);\n+\t\t}\n \t    }\n \t}\n     }\n@@ -304,9 +421,20 @@ objc_msg_lookup (id receiver, SEL op)\n \t\t\t\t\t(sidx)op->sel_id);\n \t      if (result == 0)\n \t\t{\n-\t\t  /* If the method still just doesn't exist for the\n-\t\t     class, attempt to forward the method. */\n-\t\t  result = __objc_get_forward_imp (receiver, op);\n+\t\t  /* Try going through the +resolveClassMethod: or\n+\t\t     +resolveInstanceMethod: process.  */\n+\t\t  if (CLS_ISMETA (receiver->class_pointer))\n+\t\t    result = __objc_resolve_class_method ((Class)receiver, op);\n+\t\t  else\n+\t\t    result = __objc_resolve_instance_method (receiver->class_pointer,\n+\t\t\t\t\t\t\t     op);\n+\n+\t\t  if (result == 0)\n+\t\t    {\n+\t\t      /* If the method still just doesn't exist for\n+\t\t\t the class, attempt to forward the method. */\n+\t\t      result = __objc_get_forward_imp (receiver, op);\n+\t\t    }\n \t\t}\n \t    }\n \t}\n@@ -343,6 +471,10 @@ void\n __objc_init_dispatch_tables ()\n {\n   __objc_uninstalled_dtable = sarray_new (200, 0);\n+\n+  /* TODO: It would be cool to register typed selectors here.  */\n+  selector_resolveClassMethod = sel_register_name (\"resolveClassMethod:\");\n+  selector_resolveInstanceMethod  =sel_register_name (\"resolveInstanceMethod:\");\n }\n \n /* This function is called by objc_msg_lookup when the\n@@ -566,20 +698,43 @@ class_get_class_method (MetaClass class, SEL op)\n struct objc_method *\n class_getInstanceMethod (Class class_, SEL selector)\n {\n+  struct objc_method *m;\n+\n   if (class_ == Nil  ||  selector == NULL)\n     return NULL;\n \n-  return search_for_method_in_hierarchy (class_, selector);\n+  m = search_for_method_in_hierarchy (class_, selector);\n+  if (m)\n+    return m;\n+\n+  /* Try going through +resolveInstanceMethod:, and do\n+     the search again if successful.  */\n+  if (__objc_resolve_instance_method (class_, selector))\n+    return search_for_method_in_hierarchy (class_, selector);\n+\n+  return NULL;\n }\n \n struct objc_method *\n class_getClassMethod (Class class_, SEL selector)\n {\n+  struct objc_method *m;\n+\n   if (class_ == Nil  ||  selector == NULL)\n     return NULL;\n   \n-  return search_for_method_in_hierarchy (class_->class_pointer, \n-\t\t\t\t\t selector);\n+  m = search_for_method_in_hierarchy (class_->class_pointer, \n+\t\t\t\t      selector);\n+  if (m)\n+    return m;\n+\n+  /* Try going through +resolveClassMethod:, and do the search again\n+     if successful.  */\n+  if (__objc_resolve_class_method (class_, selector))\n+    return search_for_method_in_hierarchy (class_->class_pointer, \n+\t\t\t\t\t   selector);    \n+\n+  return NULL;\n }\n \n BOOL"}]}