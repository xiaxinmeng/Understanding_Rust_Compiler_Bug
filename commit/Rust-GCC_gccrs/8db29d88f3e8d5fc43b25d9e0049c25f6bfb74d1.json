{"sha": "8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6OGRiMjlkODhmM2U4ZDVmYzQzYjI1ZDllMDA0OWMyNWY2YmZiNzRkMQ==", "commit": {"author": {"name": "Alexandre Oliva", "email": "aoliva@redhat.com", "date": "2017-01-31T01:02:03Z"}, "committer": {"name": "Alexandre Oliva", "email": "aoliva@gcc.gnu.org", "date": "2017-01-31T01:02:03Z"}, "message": "Introduce C++ support in libcc1\n\nExtend libcc1's with an API for C++ support.\n\nExtend libcc1's C API to distinguish between integral types with the\nsame width, as in C++.  Likewise for float types.\n\nExport small bits of functionality from the C++ front-end for use in\nlibcc1.  Add support for the C++ front-end to look up names and\naddresses using a libcc1-registered binding oracle.  Add support for\nglobal friends.\n\n\nfor  gcc/cp/ChangeLog\n\n\tIntroduce C++ support in libcc1.\n\t* cp-tree.h (struct lang_identifier): Add oracle_looked_up.\n\t(ansi_opname): Rename to...\n\t(cp_operator_id): ... this.  Adjust all callers.\n\t(ansi_assopname): Rename to...\n\t(cp_assignment_operator_id): ... this.  Adjust all callers.\n\t(cp_literal_operator_id): Declare.\n\t(set_global_friend): Declare.\n\t(is_global_friend): Declare.\n\t(enum cp_oracle_request): New type.\n\t(cp_binding_oracle_function): New type.\n\t(cp_binding_oracle): Declare.\n\t(cp_finish_injected_record_type): Declare.\n\t* friend.c (global_friend): New var.\n\t(set_global_friend): New fn.\n\t(is_global_friend): New fn.\n\t(is_friend): Call is_global_friend.\n\t* name-lookup.c (cp_binding_oracle): New var.\n\t(query_oracle): New fn.\n\t(qualified_lookup_using_namespace): Call query_oracle.\n\t(lookup_name_real_1): Likewise.\n\t* parser.c (cp_literal_operator_id): Drop static.\n\t* search.c (friend_accessible_p): Call is_global_friend.\n\t* semantics.c (is_this_parameter): Accept a variable if the\n\tbinding oracle is enabled.\n\nfor  include/ChangeLog\n\n\tIntroduce C++ support in libcc1.\n\t* gcc-c-fe.def (int_type_v0): Rename from...\n\t(int_type): ... this.  Introduce new version.\n\t(float_type_v0): Rename from...\n\t(float_type): ... this.  Introduce new version.\n\t(char_type): New.\n\t* gcc-c-interface.h (gcc_c_api_version): Add GCC_C_FE_VERSION_1.\n\t(gcc_type_array): Move...\n\t* gcc-interface.h: ... here.\n\t* gcc-cp-fe.def: New.\n\t* gcc-cp-interface.h: New.\n\nfor  libcc1/ChangeLog\n\n\tIntroduce C++ support.\n\t* Makefile.am (AM_CPPFLAGS): Move some -I flags to...\n\t(CPPFLAGS_FOR_C_FAMILY, CPPFLAGS_FOR_C, CPPFLAGS_FOR_CXX): ...\n\tnew macros.\n\t(plugin_LTLIBRARIES): Add libcp1plugin.la.\n\t(BUILT_SOURCES, MOSTLYCLEANFILES): Add...\n\t(cp-compiler-name.h): ... this.  New.\n\t(c-compiler-name.h): Rename all over from...\n\t(compiler-name.h): ... this.  Create it atomically.\n\t(marshall_c_source, marshall_cxx_source): New macros.\n\t(libcc1plugin_la_SOURCES): Rename plugin.cc to libcc1plugin.cc.\n\tAdd marshall_c_source expansion.\n\t(libcc1plugin.lo_CPPFLAGS): New macro.\n\t(libcp1plugin_la_LDFLAGS): Likewise.\n\t(libcp1plugin_la_SOURCES): Likewise.\n\t(libcp1plugin.lo_CPPFLAGS): Likewise.\n\t(libcp1plugin_la_LIBADD): Likewise.\n\t(libcp1plugin_la_DEPENDENCIES): Likewise.\n\t(libcp1plugin_la_LINK): Likewise.\n\t(libcc1_la_SOURCES): Added marshall_c_source and\n\tmarshall_cxx_source expansions.\n\t* Makefile.in: Rebuild.\n\t* compiler-name.h: Rename all over to...\n\t* c-compiler-name.h: ... this.  Define C_COMPILER_NAME instead\n\tof COMPILER_NAME.\n\t* plugin.cc: Rename all over to...\n\t* libcc1plugin.cc: ... this.  Include marshall-c.hh.\n\t(address_rewriter): Drop cleaning up of VLA sizes.\n\t(plugin_build_decl): Mark decls as external.\n\t(plugin_tagbind): Propagate name to all variants.\n\t(build_anonymous_node): New.\n\t(plugin_build_record_type): Use it instead of make_node.\n\t(plugin_build_union_type): Likewise.\n\t(plugin_build_enum_type): Likewise.\n\t(plugin_finish_record_or_union): Update all type variants.\n\t(safe_lookup_builtin_type): New.\n\t(plugin_int_check): Factor out of, and add checks to, ...\n\t(plugin_int_type): ... this.  Rename to...\n\t(plugin_int_type_v0): ... this.\n\t(plugin_int_type): New interface, new implementation.\n\t(plugin_char_type): New.\n\t(plugin_float_type_v0): Rename from...\n\t(plugin_float_type): ... this.  New interface, new implementation.\n\t(plugin_init): Bump handshake version.\n\t* libcc1.cc: Include marshall-c.hh.  Drop gcc-interface.h.\n\t(call_binding_oracle): Rename to...\n\t(c_call_binding_oracle): ... this, into anonymous namespace.\n\t(call_symbol_address): Rename to...\n\t(c_call_symbol_address): ... this, likewise.\n\t(GCC_METHOD#): Move methods into cc1plugin::c:: namespace.\n\t(libcc1::compiler::find): Refer to C_COMPILER_NAME.\n\t(fork_exec): Bump to GCC_C_FE_VERSION_1.\n\t(libcc1_compile): Prefix callbacks with c_.\n\t(gcc_c_fe_context): Accept GCC_C_FE_VERSION_1.\n\t* libcc1.sym: Export gcc_cp_fe_context.\n\t* libcp1.cc: New, mostly copied and adjusted from libcc1.cc.\n\t* libcp1plugin.cc: New, initially copied from libcc1plugin.cc.\n\t* libcp1plugin.sym: New.\n\t* marshall-c.hh: New.  Move C-specific types from...\n\t* marshall.cc: ... this.\n\t(cc1_plugin::marshall_array_start): New.\n\t(cc1_plugin::marshall_array_elmts): New.\n\t(cc1_plugin::marshall for gcc_type_array): Use the above.\n\t(cc1_plugin::unmarshall_array_start): New.\n\t(cc1_plugin::unmarshall_array_elmts): New.\n\t(cc1_plugin::unmarshall for gcc_type_array): Use the above.\n\t* marshall.hh: Declare the new array building blocks.\n\tDrop C-specific unmarshall declarations.\n\t* marshall-cp.hh: New.\n\t* names.cc (GCC_METHOD#): Add LANG:: to method names.\n\t(LANG): Define while including gcc-c-fe.def and gcc-cp-fe.def.\n\t* names.hh: Include gcc-c-fe.def and gcc-cp-fe.def in the\n\tcorresponding namespaces.\n\t* rpc.hh: Don't include marshall.hh.\n\t[GCC_CP_INTERFACE_H] (argument_wrapper): Specialize for\n\tgcc_vbase_array, gcc_cp_template_args, gcc_cp_function_args.\n\nFrom-SVN: r245051", "tree": {"sha": "3901a07d4c4dde00dbe21a5d032c741cfc2aaaa2", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/3901a07d4c4dde00dbe21a5d032c741cfc2aaaa2"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "html_url": "https://github.com/Rust-GCC/gccrs/commit/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/comments", "author": null, "committer": null, "parents": [{"sha": "9f92b93b7b94f128c6b600bc360ec643bcfa9067", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/9f92b93b7b94f128c6b600bc360ec643bcfa9067", "html_url": "https://github.com/Rust-GCC/gccrs/commit/9f92b93b7b94f128c6b600bc360ec643bcfa9067"}], "stats": {"total": 7454, "additions": 7201, "deletions": 253}, "files": [{"sha": "18732c927e3360fce8f5c10ca67d959c13ac8bac", "filename": "gcc/cp/ChangeLog", "status": "modified", "additions": 28, "deletions": 0, "changes": 28, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2FChangeLog?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -1,3 +1,31 @@\n+2017-01-30  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tIntroduce C++ support in libcc1.\n+\t* cp-tree.h (struct lang_identifier): Add oracle_looked_up.\n+\t(ansi_opname): Rename to...\n+\t(cp_operator_id): ... this.  Adjust all callers.\n+\t(ansi_assopname): Rename to...\n+\t(cp_assignment_operator_id): ... this.  Adjust all callers.\n+\t(cp_literal_operator_id): Declare.\n+\t(set_global_friend): Declare.\n+\t(is_global_friend): Declare.\n+\t(enum cp_oracle_request): New type.\n+\t(cp_binding_oracle_function): New type.\n+\t(cp_binding_oracle): Declare.\n+\t(cp_finish_injected_record_type): Declare.\n+\t* friend.c (global_friend): New var.\n+\t(set_global_friend): New fn.\n+\t(is_global_friend): New fn.\n+\t(is_friend): Call is_global_friend.\n+\t* name-lookup.c (cp_binding_oracle): New var.\n+\t(query_oracle): New fn.\n+\t(qualified_lookup_using_namespace): Call query_oracle.\n+\t(lookup_name_real_1): Likewise.\n+\t* parser.c (cp_literal_operator_id): Drop static.\n+\t* search.c (friend_accessible_p): Call is_global_friend.\n+\t* semantics.c (is_this_parameter): Accept a variable if the\n+\tbinding oracle is enabled.\n+\n 2017-01-27  Jason Merrill  <jason@redhat.com>\n \n \tPR c++/78771 - ICE with inherited constructor."}, {"sha": "6533214799d1bf40d68cf8b3bd3d104ebd2a4b75", "filename": "gcc/cp/call.c", "status": "modified", "additions": 7, "deletions": 7, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fcall.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fcall.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcall.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -4426,7 +4426,7 @@ build_op_call_1 (tree obj, vec<tree, va_gc> **args, tsubst_flags_t complain)\n \n   if (TYPE_BINFO (type))\n     {\n-      fns = lookup_fnfields (TYPE_BINFO (type), ansi_opname (CALL_EXPR), 1);\n+      fns = lookup_fnfields (TYPE_BINFO (type), cp_operator_id (CALL_EXPR), 1);\n       if (fns == error_mark_node)\n \treturn error_mark_node;\n     }\n@@ -5136,7 +5136,7 @@ build_conditional_expr_1 (location_t loc, tree arg1, tree arg2, tree arg3,\n       add_builtin_candidates (&candidates,\n \t\t\t      COND_EXPR,\n \t\t\t      NOP_EXPR,\n-\t\t\t      ansi_opname (COND_EXPR),\n+\t\t\t      cp_operator_id (COND_EXPR),\n \t\t\t      args,\n \t\t\t      LOOKUP_NORMAL, complain);\n \n@@ -5559,10 +5559,10 @@ build_new_op_1 (location_t loc, enum tree_code code, int flags, tree arg1,\n     {\n       code2 = TREE_CODE (arg3);\n       arg3 = NULL_TREE;\n-      fnname = ansi_assopname (code2);\n+      fnname = cp_assignment_operator_id (code2);\n     }\n   else\n-    fnname = ansi_opname (code);\n+    fnname = cp_operator_id (code);\n \n   arg1 = prep_operand (arg1);\n \n@@ -6167,7 +6167,7 @@ build_op_delete_call (enum tree_code code, tree addr, tree size,\n \n   type = strip_array_types (TREE_TYPE (TREE_TYPE (addr)));\n \n-  fnname = ansi_opname (code);\n+  fnname = cp_operator_id (code);\n \n   if (CLASS_TYPE_P (type)\n       && COMPLETE_TYPE_P (complete_type (type))\n@@ -8283,7 +8283,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n \t      || name == complete_dtor_identifier\n \t      || name == base_dtor_identifier\n \t      || name == deleting_dtor_identifier\n-\t      || name == ansi_assopname (NOP_EXPR));\n+\t      || name == cp_assignment_operator_id (NOP_EXPR));\n   if (TYPE_P (binfo))\n     {\n       /* Resolve the name.  */\n@@ -8311,7 +8311,7 @@ build_special_member_call (tree instance, tree name, vec<tree, va_gc> **args,\n       if (!same_type_ignoring_top_level_qualifiers_p\n \t  (TREE_TYPE (instance), BINFO_TYPE (binfo)))\n \t{\n-\t  if (name != ansi_assopname (NOP_EXPR))\n+\t  if (name != cp_assignment_operator_id (NOP_EXPR))\n \t    /* For constructors and destructors, either the base is\n \t       non-virtual, or it is virtual but we are doing the\n \t       conversion from a constructor or destructor for the"}, {"sha": "d99ebcdc7dfd8993070e51857bd9178488ac904a", "filename": "gcc/cp/class.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fclass.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fclass.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fclass.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -3254,7 +3254,7 @@ static tree\n dfs_declare_virt_assop_and_dtor (tree binfo, void *data)\n {\n   tree bv, fn, t = (tree)data;\n-  tree opname = ansi_assopname (NOP_EXPR);\n+  tree opname = cp_assignment_operator_id (NOP_EXPR);\n \n   gcc_assert (t && CLASS_TYPE_P (t));\n   gcc_assert (binfo && TREE_CODE (binfo) == TREE_BINFO);\n@@ -5349,7 +5349,7 @@ vbase_has_user_provided_move_assign (tree type)\n {\n   /* Does the type itself have a user-provided move assignment operator?  */\n   for (tree fns\n-\t = lookup_fnfields_slot_nolazy (type, ansi_assopname (NOP_EXPR));\n+\t = lookup_fnfields_slot_nolazy (type, cp_assignment_operator_id (NOP_EXPR));\n        fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n@@ -5513,7 +5513,7 @@ type_has_move_assign (tree t)\n       lazily_declare_fn (sfk_move_assignment, t);\n     }\n \n-  for (fns = lookup_fnfields_slot_nolazy (t, ansi_assopname (NOP_EXPR));\n+  for (fns = lookup_fnfields_slot_nolazy (t, cp_assignment_operator_id (NOP_EXPR));\n        fns; fns = OVL_NEXT (fns))\n     if (move_fn_p (OVL_CURRENT (fns)))\n       return true;\n@@ -5558,7 +5558,7 @@ type_has_user_declared_move_assign (tree t)\n   if (CLASSTYPE_LAZY_MOVE_ASSIGN (t))\n     return false;\n \n-  for (fns = lookup_fnfields_slot_nolazy (t, ansi_assopname (NOP_EXPR));\n+  for (fns = lookup_fnfields_slot_nolazy (t, cp_assignment_operator_id (NOP_EXPR));\n        fns; fns = OVL_NEXT (fns))\n     {\n       tree fn = OVL_CURRENT (fns);\n@@ -5679,7 +5679,7 @@ type_requires_array_cookie (tree type)\n      the array to the deallocation function, so we will need to store\n      a cookie.  */\n   fns = lookup_fnfields (TYPE_BINFO (type),\n-\t\t\t ansi_opname (VEC_DELETE_EXPR),\n+\t\t\t cp_operator_id (VEC_DELETE_EXPR),\n \t\t\t /*protect=*/0);\n   /* If there are no `operator []' members, or the lookup is\n      ambiguous, then we don't need a cookie.  */"}, {"sha": "a744d8372bff6bbd08ba4a6225880a48469bbce2", "filename": "gcc/cp/cp-tree.h", "status": "modified", "additions": 34, "deletions": 6, "changes": 40, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fcp-tree.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fcp-tree.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fcp-tree.h?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -332,6 +332,7 @@ struct GTY(()) lang_identifier {\n   cxx_binding *bindings;\n   tree class_template_info;\n   tree label_value;\n+  bool oracle_looked_up;\n };\n \n /* Return a typed pointer version of T if it designates a\n@@ -1530,15 +1531,17 @@ struct GTY(()) language_function {\n /* True if NAME is the IDENTIFIER_NODE for an overloaded \"operator\n    new\" or \"operator delete\".  */\n #define NEW_DELETE_OPNAME_P(NAME)\t\t\\\n-  ((NAME) == ansi_opname (NEW_EXPR)\t\t\\\n-   || (NAME) == ansi_opname (VEC_NEW_EXPR)\t\\\n-   || (NAME) == ansi_opname (DELETE_EXPR)\t\\\n-   || (NAME) == ansi_opname (VEC_DELETE_EXPR))\n+  ((NAME) == cp_operator_id (NEW_EXPR)\t\t\\\n+   || (NAME) == cp_operator_id (VEC_NEW_EXPR)\t\\\n+   || (NAME) == cp_operator_id (DELETE_EXPR)\t\\\n+   || (NAME) == cp_operator_id (VEC_DELETE_EXPR))\n \n-#define ansi_opname(CODE) \\\n+#define cp_operator_id(CODE) \\\n   (operator_name_info[(int) (CODE)].identifier)\n-#define ansi_assopname(CODE) \\\n+#define cp_assignment_operator_id(CODE) \\\n   (assignment_operator_name_info[(int) (CODE)].identifier)\n+/* In parser.c.  */\n+extern tree cp_literal_operator_id (const char *);\n \n /* TRUE if a tree code represents a statement.  */\n extern bool statement_code_p[MAX_TREE_CODES];\n@@ -6027,6 +6030,9 @@ extern void make_friend_class\t\t\t(tree, tree, bool);\n extern void add_friend\t\t\t\t(tree, tree, bool);\n extern tree do_friend\t\t\t\t(tree, tree, tree, tree, enum overload_flags, bool);\n \n+extern void set_global_friend\t\t\t(tree);\n+extern bool is_global_friend\t\t\t(tree);\n+\n /* in init.c */\n extern tree expand_member_init\t\t\t(tree);\n extern void emit_mem_initializers\t\t(tree);\n@@ -6944,6 +6950,25 @@ extern void suggest_alternatives_for            (location_t, tree, bool);\n extern bool suggest_alternative_in_explicit_scope (location_t, tree, tree);\n extern tree strip_using_decl                    (tree);\n \n+/* Tell the binding oracle what kind of binding we are looking for.  */\n+\n+enum cp_oracle_request\n+{\n+  CP_ORACLE_IDENTIFIER\n+};\n+\n+/* If this is non-NULL, then it is a \"binding oracle\" which can lazily\n+   create bindings when needed by the C compiler.  The oracle is told\n+   the name and type of the binding to create.  It can call pushdecl\n+   or the like to ensure the binding is visible; or do nothing,\n+   leaving the binding untouched.  c-decl.c takes note of when the\n+   oracle has been called and will not call it again if it fails to\n+   create a given binding.  */\n+\n+typedef void cp_binding_oracle_function (enum cp_oracle_request, tree identifier);\n+\n+extern cp_binding_oracle_function *cp_binding_oracle;\n+\n /* in constraint.cc */\n extern void init_constraint_processing          ();\n extern bool constraint_p                        (tree);\n@@ -7009,6 +7034,9 @@ extern void diagnose_constraints                (location_t, tree, tree);\n extern tree decompose_conclusions               (tree);\n extern bool subsumes                            (tree, tree);\n \n+/* In class.c */\n+extern void cp_finish_injected_record_type (tree);\n+\n /* in vtable-class-hierarchy.c */\n extern void vtv_compute_class_hierarchy_transitive_closure (void);\n extern void vtv_generate_init_routine           (void);"}, {"sha": "9bdfd4ff64ba8ad9a5a3827071e5b76d49d50dea", "filename": "gcc/cp/decl.c", "status": "modified", "additions": 3, "deletions": 3, "changes": 6, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fdecl.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fdecl.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -4564,7 +4564,7 @@ static tree\n push_cp_library_fn (enum tree_code operator_code, tree type,\n \t\t    int ecf_flags)\n {\n-  tree fn = build_cp_library_fn (ansi_opname (operator_code),\n+  tree fn = build_cp_library_fn (cp_operator_id (operator_code),\n \t\t\t\t operator_code,\n \t\t\t\t type, ecf_flags);\n   pushdecl (fn);\n@@ -12937,12 +12937,12 @@ grok_op_properties (tree decl, bool complain)\n     do\n       {\n #define DEF_OPERATOR(NAME, CODE, MANGLING, ARITY, ASSN_P)\t\\\n-\tif (ansi_opname (CODE) == name)\t\t\t\t\\\n+\tif (cp_operator_id (CODE) == name)\t\t\t\\\n \t  {\t\t\t\t\t\t\t\\\n \t    operator_code = (CODE);\t\t\t\t\\\n \t    break;\t\t\t\t\t\t\\\n \t  }\t\t\t\t\t\t\t\\\n-\telse if (ansi_assopname (CODE) == name)\t\t\t\\\n+\telse if (cp_assignment_operator_id (CODE) == name)\t\\\n \t  {\t\t\t\t\t\t\t\\\n \t    operator_code = (CODE);\t\t\t\t\\\n \t    DECL_ASSIGNMENT_OPERATOR_P (decl) = 1;\t\t\\"}, {"sha": "86d98202f0d733f4f595940adf089263cdd75942", "filename": "gcc/cp/decl2.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fdecl2.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fdecl2.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fdecl2.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -4386,7 +4386,7 @@ maybe_warn_sized_delete (enum tree_code code)\n   tree sized = NULL_TREE;\n   tree unsized = NULL_TREE;\n \n-  for (tree ovl = IDENTIFIER_GLOBAL_VALUE (ansi_opname (code));\n+  for (tree ovl = IDENTIFIER_GLOBAL_VALUE (cp_operator_id (code));\n        ovl; ovl = OVL_NEXT (ovl))\n     {\n       tree fn = OVL_CURRENT (ovl);"}, {"sha": "3815daef4d5dcce1d6df796f08058779fb78eda3", "filename": "gcc/cp/friend.c", "status": "modified", "additions": 43, "deletions": 0, "changes": 43, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Ffriend.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Ffriend.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ffriend.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -24,6 +24,46 @@ along with GCC; see the file COPYING3.  If not see\n \n /* Friend data structures are described in cp-tree.h.  */\n \n+\n+/* The GLOBAL_FRIEND scope (functions, classes, or templates) is\n+   regarded as a friend of every class.  This is only used by libcc1,\n+   to enable GDB's code snippets to access private members without\n+   disabling access control in general, which could cause different\n+   template overload resolution results when accessibility matters\n+   (e.g. tests for an accessible member).  */\n+\n+static tree global_friend;\n+\n+/* Set the GLOBAL_FRIEND for this compilation session.  It might be\n+   set multiple times, but always to the same scope.  */\n+\n+void\n+set_global_friend (tree scope)\n+{\n+  gcc_checking_assert (scope != NULL_TREE);\n+  gcc_assert (!global_friend || global_friend == scope);\n+  global_friend = scope;\n+}\n+\n+/* Return TRUE if SCOPE is the global friend.  */\n+\n+bool\n+is_global_friend (tree scope)\n+{\n+  gcc_checking_assert (scope != NULL_TREE);\n+\n+  if (global_friend == scope)\n+    return true;\n+\n+  if (!global_friend)\n+    return false;\n+\n+  if (is_specialization_of_friend (global_friend, scope))\n+    return true;\n+\n+  return false;\n+}\n+\n /* Returns nonzero if SUPPLICANT is a friend of TYPE.  */\n \n int\n@@ -36,6 +76,9 @@ is_friend (tree type, tree supplicant)\n   if (supplicant == NULL_TREE || type == NULL_TREE)\n     return 0;\n \n+  if (is_global_friend (supplicant))\n+    return 1;\n+\n   declp = DECL_P (supplicant);\n \n   if (declp)"}, {"sha": "42f1c6192eceeb6f61ba917ef25327662ab9b553", "filename": "gcc/cp/init.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Finit.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Finit.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Finit.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -2924,7 +2924,7 @@ build_new_1 (vec<tree, va_gc> **placement, tree type, tree nelts,\n   tree fnname;\n   tree fns;\n \n-  fnname = ansi_opname (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n+  fnname = cp_operator_id (array_p ? VEC_NEW_EXPR : NEW_EXPR);\n \n   member_new_p = !globally_qualified_p\n \t\t && CLASS_TYPE_P (elt_type)"}, {"sha": "538c80639574bdbd8a104a66b22146e6c081ff81", "filename": "gcc/cp/lambda.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Flambda.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Flambda.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flambda.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -202,7 +202,7 @@ lambda_function (tree lambda)\n   if (CLASSTYPE_TEMPLATE_INSTANTIATION (type)\n       && !COMPLETE_OR_OPEN_TYPE_P (type))\n     return NULL_TREE;\n-  lambda = lookup_member (type, ansi_opname (CALL_EXPR),\n+  lambda = lookup_member (type, cp_operator_id (CALL_EXPR),\n \t\t\t  /*protect=*/0, /*want_type=*/false,\n \t\t\t  tf_warning_or_error);\n   if (lambda)"}, {"sha": "ad6318656ad96cae454f8476d9a93e08b1beb23b", "filename": "gcc/cp/lex.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Flex.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Flex.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Flex.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -433,7 +433,7 @@ unqualified_name_lookup_error (tree name, location_t loc)\n \n   if (IDENTIFIER_OPNAME_P (name))\n     {\n-      if (name != ansi_opname (ERROR_MARK))\n+      if (name != cp_operator_id (ERROR_MARK))\n \terror_at (loc, \"%qD not defined\", name);\n     }\n   else"}, {"sha": "941f9a657e49b791432ec9673543c04ad111c74b", "filename": "gcc/cp/method.c", "status": "modified", "additions": 5, "deletions": 5, "changes": 10, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fmethod.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fmethod.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fmethod.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -812,7 +812,7 @@ do_build_copy_assign (tree fndecl)\n \t  parmvec = make_tree_vector_single (converted_parm);\n \t  finish_expr_stmt\n \t    (build_special_member_call (current_class_ref,\n-\t\t\t\t\tansi_assopname (NOP_EXPR),\n+\t\t\t\t\tcp_assignment_operator_id (NOP_EXPR),\n \t\t\t\t\t&parmvec,\n \t\t\t\t\tbase_binfo,\n \t\t\t\t\tflags,\n@@ -1105,7 +1105,7 @@ get_copy_assign (tree type)\n   int quals = (TYPE_HAS_CONST_COPY_ASSIGN (type)\n \t       ? TYPE_QUAL_CONST : TYPE_UNQUALIFIED);\n   tree argtype = build_stub_type (type, quals, false);\n-  tree fn = locate_fn_flags (type, ansi_assopname (NOP_EXPR), argtype,\n+  tree fn = locate_fn_flags (type, cp_assignment_operator_id (NOP_EXPR), argtype,\n \t\t\t     LOOKUP_NORMAL, tf_warning_or_error);\n   if (fn == error_mark_node)\n     return NULL_TREE;\n@@ -1463,7 +1463,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n     case sfk_move_assignment:\n     case sfk_copy_assignment:\n       assign_p = true;\n-      fnname = ansi_assopname (NOP_EXPR);\n+      fnname = cp_assignment_operator_id (NOP_EXPR);\n       break;\n \n     case sfk_destructor:\n@@ -1622,7 +1622,7 @@ synthesized_method_walk (tree ctype, special_function_kind sfk, bool const_p,\n \n       if (check_vdtor && type_has_virtual_destructor (basetype))\n \t{\n-\t  rval = locate_fn_flags (ctype, ansi_opname (DELETE_EXPR),\n+\t  rval = locate_fn_flags (ctype, cp_operator_id (DELETE_EXPR),\n \t\t\t\t  ptr_type_node, flags, complain);\n \t  /* Unlike for base ctor/op=/dtor, for operator delete it's fine\n \t     to have a null rval (no class-specific op delete).  */\n@@ -1949,7 +1949,7 @@ implicitly_declare_fn (special_function_kind kind, tree type,\n \t  || kind == sfk_move_assignment)\n \t{\n \t  return_type = build_reference_type (type);\n-\t  name = ansi_assopname (NOP_EXPR);\n+\t  name = cp_assignment_operator_id (NOP_EXPR);\n \t}\n       else\n \tname = constructor_name (type);"}, {"sha": "a3cb7eea9072d68863b93c8c502571b29c5cbe8c", "filename": "gcc/cp/name-lookup.c", "status": "modified", "additions": 27, "deletions": 0, "changes": 27, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fname-lookup.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fname-lookup.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fname-lookup.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -92,6 +92,28 @@ get_anonymous_namespace_name (void)\n \n static GTY((deletable)) binding_entry free_binding_entry = NULL;\n \n+/* The binding oracle; see cp-tree.h.  */\n+\n+cp_binding_oracle_function *cp_binding_oracle;\n+\n+/* If we have a binding oracle, ask it for all namespace-scoped\n+   definitions of NAME.  */\n+\n+static inline void\n+query_oracle (tree name)\n+{\n+  if (!cp_binding_oracle)\n+    return;\n+\n+  /* LOOKED_UP holds the set of identifiers that we have already\n+     looked up with the oracle.  */\n+  static hash_set<tree> looked_up;\n+  if (looked_up.add (name))\n+    return;\n+\n+  cp_binding_oracle (CP_ORACLE_IDENTIFIER, name);\n+}\n+\n /* Create a binding_entry object for (NAME, TYPE).  */\n \n static inline binding_entry\n@@ -4706,6 +4728,8 @@ qualified_lookup_using_namespace (tree name, tree scope,\n   /* Look through namespace aliases.  */\n   scope = ORIGINAL_NAMESPACE (scope);\n \n+  query_oracle (name);\n+\n   /* Algorithm: Starting with SCOPE, walk through the set of used\n      namespaces.  For each used namespace, look through its inline\n      namespace set for any bindings and usings.  If no bindings are\n@@ -5030,6 +5054,8 @@ lookup_name_real_1 (tree name, int prefer_type, int nonclass, bool block_p,\n   cxx_binding *iter;\n   tree val = NULL_TREE;\n \n+  query_oracle (name);\n+\n   /* Conversion operators are handled specially because ordinary\n      unqualified name lookup will not find template conversion\n      operators.  */\n@@ -6238,6 +6264,7 @@ pushtag (tree name, tree type, tag_scope scope)\n   timevar_cond_stop (TV_NAME_LOOKUP, subtime);\n   return ret;\n }\n+\n \f\n /* Subroutines for reverting temporarily to top-level for instantiation\n    of templates and such.  We actually need to clear out the class- and"}, {"sha": "592f903a6f98be64a289ab3efcd4bf4b2c7f1ad5", "filename": "gcc/cp/parser.c", "status": "modified", "additions": 50, "deletions": 53, "changes": 103, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fparser.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fparser.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fparser.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -249,9 +249,6 @@ static cp_token_cache *cp_token_cache_new\n static void cp_parser_initial_pragma\n   (cp_token *);\n \n-static tree cp_literal_operator_id\n-  (const char *);\n-\n static void cp_parser_cilk_simd\n   (cp_parser *, cp_token *, bool *);\n static tree cp_parser_cilk_for\n@@ -10279,7 +10276,7 @@ cp_parser_lambda_declarator_opt (cp_parser* parser, tree lambda_expr)\n \n     p = obstack_alloc (&declarator_obstack, 0);\n \n-    declarator = make_id_declarator (NULL_TREE, ansi_opname (CALL_EXPR),\n+    declarator = make_id_declarator (NULL_TREE, cp_operator_id (CALL_EXPR),\n \t\t\t\t     sfk_none);\n \n     quals = (LAMBDA_EXPR_MUTABLE_P (lambda_expr)\n@@ -14297,7 +14294,7 @@ cp_parser_operator_function_id (cp_parser* parser)\n /* Return an identifier node for a user-defined literal operator.\n    The suffix identifier is chained to the operator name identifier.  */\n \n-static tree\n+tree\n cp_literal_operator_id (const char* name)\n {\n   tree identifier;\n@@ -14366,175 +14363,175 @@ cp_parser_operator (cp_parser* parser)\n \t    if (cp_token *close_token\n \t\t= cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE))\n \t      end_loc = close_token->location;\n-\t    id = ansi_opname (op == NEW_EXPR\n+\t    id = cp_operator_id (op == NEW_EXPR\n \t\t\t      ? VEC_NEW_EXPR : VEC_DELETE_EXPR);\n \t  }\n \t/* Otherwise, we have the non-array variant.  */\n \telse\n-\t  id = ansi_opname (op);\n+\t  id = cp_operator_id (op);\n \n \tlocation_t loc = make_location (start_loc, start_loc, end_loc);\n \n \treturn cp_expr (id, loc);\n       }\n \n     case CPP_PLUS:\n-      id = ansi_opname (PLUS_EXPR);\n+      id = cp_operator_id (PLUS_EXPR);\n       break;\n \n     case CPP_MINUS:\n-      id = ansi_opname (MINUS_EXPR);\n+      id = cp_operator_id (MINUS_EXPR);\n       break;\n \n     case CPP_MULT:\n-      id = ansi_opname (MULT_EXPR);\n+      id = cp_operator_id (MULT_EXPR);\n       break;\n \n     case CPP_DIV:\n-      id = ansi_opname (TRUNC_DIV_EXPR);\n+      id = cp_operator_id (TRUNC_DIV_EXPR);\n       break;\n \n     case CPP_MOD:\n-      id = ansi_opname (TRUNC_MOD_EXPR);\n+      id = cp_operator_id (TRUNC_MOD_EXPR);\n       break;\n \n     case CPP_XOR:\n-      id = ansi_opname (BIT_XOR_EXPR);\n+      id = cp_operator_id (BIT_XOR_EXPR);\n       break;\n \n     case CPP_AND:\n-      id = ansi_opname (BIT_AND_EXPR);\n+      id = cp_operator_id (BIT_AND_EXPR);\n       break;\n \n     case CPP_OR:\n-      id = ansi_opname (BIT_IOR_EXPR);\n+      id = cp_operator_id (BIT_IOR_EXPR);\n       break;\n \n     case CPP_COMPL:\n-      id = ansi_opname (BIT_NOT_EXPR);\n+      id = cp_operator_id (BIT_NOT_EXPR);\n       break;\n \n     case CPP_NOT:\n-      id = ansi_opname (TRUTH_NOT_EXPR);\n+      id = cp_operator_id (TRUTH_NOT_EXPR);\n       break;\n \n     case CPP_EQ:\n-      id = ansi_assopname (NOP_EXPR);\n+      id = cp_assignment_operator_id (NOP_EXPR);\n       break;\n \n     case CPP_LESS:\n-      id = ansi_opname (LT_EXPR);\n+      id = cp_operator_id (LT_EXPR);\n       break;\n \n     case CPP_GREATER:\n-      id = ansi_opname (GT_EXPR);\n+      id = cp_operator_id (GT_EXPR);\n       break;\n \n     case CPP_PLUS_EQ:\n-      id = ansi_assopname (PLUS_EXPR);\n+      id = cp_assignment_operator_id (PLUS_EXPR);\n       break;\n \n     case CPP_MINUS_EQ:\n-      id = ansi_assopname (MINUS_EXPR);\n+      id = cp_assignment_operator_id (MINUS_EXPR);\n       break;\n \n     case CPP_MULT_EQ:\n-      id = ansi_assopname (MULT_EXPR);\n+      id = cp_assignment_operator_id (MULT_EXPR);\n       break;\n \n     case CPP_DIV_EQ:\n-      id = ansi_assopname (TRUNC_DIV_EXPR);\n+      id = cp_assignment_operator_id (TRUNC_DIV_EXPR);\n       break;\n \n     case CPP_MOD_EQ:\n-      id = ansi_assopname (TRUNC_MOD_EXPR);\n+      id = cp_assignment_operator_id (TRUNC_MOD_EXPR);\n       break;\n \n     case CPP_XOR_EQ:\n-      id = ansi_assopname (BIT_XOR_EXPR);\n+      id = cp_assignment_operator_id (BIT_XOR_EXPR);\n       break;\n \n     case CPP_AND_EQ:\n-      id = ansi_assopname (BIT_AND_EXPR);\n+      id = cp_assignment_operator_id (BIT_AND_EXPR);\n       break;\n \n     case CPP_OR_EQ:\n-      id = ansi_assopname (BIT_IOR_EXPR);\n+      id = cp_assignment_operator_id (BIT_IOR_EXPR);\n       break;\n \n     case CPP_LSHIFT:\n-      id = ansi_opname (LSHIFT_EXPR);\n+      id = cp_operator_id (LSHIFT_EXPR);\n       break;\n \n     case CPP_RSHIFT:\n-      id = ansi_opname (RSHIFT_EXPR);\n+      id = cp_operator_id (RSHIFT_EXPR);\n       break;\n \n     case CPP_LSHIFT_EQ:\n-      id = ansi_assopname (LSHIFT_EXPR);\n+      id = cp_assignment_operator_id (LSHIFT_EXPR);\n       break;\n \n     case CPP_RSHIFT_EQ:\n-      id = ansi_assopname (RSHIFT_EXPR);\n+      id = cp_assignment_operator_id (RSHIFT_EXPR);\n       break;\n \n     case CPP_EQ_EQ:\n-      id = ansi_opname (EQ_EXPR);\n+      id = cp_operator_id (EQ_EXPR);\n       break;\n \n     case CPP_NOT_EQ:\n-      id = ansi_opname (NE_EXPR);\n+      id = cp_operator_id (NE_EXPR);\n       break;\n \n     case CPP_LESS_EQ:\n-      id = ansi_opname (LE_EXPR);\n+      id = cp_operator_id (LE_EXPR);\n       break;\n \n     case CPP_GREATER_EQ:\n-      id = ansi_opname (GE_EXPR);\n+      id = cp_operator_id (GE_EXPR);\n       break;\n \n     case CPP_AND_AND:\n-      id = ansi_opname (TRUTH_ANDIF_EXPR);\n+      id = cp_operator_id (TRUTH_ANDIF_EXPR);\n       break;\n \n     case CPP_OR_OR:\n-      id = ansi_opname (TRUTH_ORIF_EXPR);\n+      id = cp_operator_id (TRUTH_ORIF_EXPR);\n       break;\n \n     case CPP_PLUS_PLUS:\n-      id = ansi_opname (POSTINCREMENT_EXPR);\n+      id = cp_operator_id (POSTINCREMENT_EXPR);\n       break;\n \n     case CPP_MINUS_MINUS:\n-      id = ansi_opname (PREDECREMENT_EXPR);\n+      id = cp_operator_id (PREDECREMENT_EXPR);\n       break;\n \n     case CPP_COMMA:\n-      id = ansi_opname (COMPOUND_EXPR);\n+      id = cp_operator_id (COMPOUND_EXPR);\n       break;\n \n     case CPP_DEREF_STAR:\n-      id = ansi_opname (MEMBER_REF);\n+      id = cp_operator_id (MEMBER_REF);\n       break;\n \n     case CPP_DEREF:\n-      id = ansi_opname (COMPONENT_REF);\n+      id = cp_operator_id (COMPONENT_REF);\n       break;\n \n     case CPP_OPEN_PAREN:\n       /* Consume the `('.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `)'.  */\n       cp_parser_require (parser, CPP_CLOSE_PAREN, RT_CLOSE_PAREN);\n-      return ansi_opname (CALL_EXPR);\n+      return cp_operator_id (CALL_EXPR);\n \n     case CPP_OPEN_SQUARE:\n       /* Consume the `['.  */\n       cp_lexer_consume_token (parser->lexer);\n       /* Look for the matching `]'.  */\n       cp_parser_require (parser, CPP_CLOSE_SQUARE, RT_CLOSE_SQUARE);\n-      return ansi_opname (ARRAY_REF);\n+      return cp_operator_id (ARRAY_REF);\n \n     case CPP_UTF8STRING:\n     case CPP_UTF8STRING_USERDEF:\n@@ -31991,21 +31988,21 @@ cp_parser_omp_clause_reduction (cp_parser *parser, tree list)\n \t    code = MIN_EXPR;\n \t  else if (strcmp (p, \"max\") == 0)\n \t    code = MAX_EXPR;\n-\t  else if (id == ansi_opname (PLUS_EXPR))\n+\t  else if (id == cp_operator_id (PLUS_EXPR))\n \t    code = PLUS_EXPR;\n-\t  else if (id == ansi_opname (MULT_EXPR))\n+\t  else if (id == cp_operator_id (MULT_EXPR))\n \t    code = MULT_EXPR;\n-\t  else if (id == ansi_opname (MINUS_EXPR))\n+\t  else if (id == cp_operator_id (MINUS_EXPR))\n \t    code = MINUS_EXPR;\n-\t  else if (id == ansi_opname (BIT_AND_EXPR))\n+\t  else if (id == cp_operator_id (BIT_AND_EXPR))\n \t    code = BIT_AND_EXPR;\n-\t  else if (id == ansi_opname (BIT_IOR_EXPR))\n+\t  else if (id == cp_operator_id (BIT_IOR_EXPR))\n \t    code = BIT_IOR_EXPR;\n-\t  else if (id == ansi_opname (BIT_XOR_EXPR))\n+\t  else if (id == cp_operator_id (BIT_XOR_EXPR))\n \t    code = BIT_XOR_EXPR;\n-\t  else if (id == ansi_opname (TRUTH_ANDIF_EXPR))\n+\t  else if (id == cp_operator_id (TRUTH_ANDIF_EXPR))\n \t    code = TRUTH_ANDIF_EXPR;\n-\t  else if (id == ansi_opname (TRUTH_ORIF_EXPR))\n+\t  else if (id == cp_operator_id (TRUTH_ORIF_EXPR))\n \t    code = TRUTH_ORIF_EXPR;\n \t  id = omp_reduction_id (code, id, NULL_TREE);\n \t  tree scope = parser->scope;"}, {"sha": "09c1b4e6456d24682eb3246de361a4e8354f6ba4", "filename": "gcc/cp/search.c", "status": "modified", "additions": 4, "deletions": 1, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fsearch.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fsearch.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsearch.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -782,6 +782,9 @@ friend_accessible_p (tree scope, tree decl, tree type, tree otype)\n   if (!scope)\n     return 0;\n \n+  if (is_global_friend (scope))\n+    return 1;\n+\n   /* Is SCOPE itself a suitable P?  */\n   if (TYPE_P (scope) && protected_accessible_p (decl, scope, type, otype))\n     return 1;\n@@ -1664,7 +1667,7 @@ lookup_fnfields_1 (tree type, tree name)\n \t  if (CLASSTYPE_LAZY_MOVE_CTOR (type))\n \t    lazily_declare_fn (sfk_move_constructor, type);\n \t}\n-      else if (name == ansi_assopname (NOP_EXPR))\n+      else if (name == cp_assignment_operator_id (NOP_EXPR))\n \t{\n \t  if (CLASSTYPE_LAZY_COPY_ASSIGN (type))\n \t    lazily_declare_fn (sfk_copy_assignment, type);"}, {"sha": "bd91e1832f73f1486ddb40b3cdef2664068b9a1b", "filename": "gcc/cp/semantics.c", "status": "modified", "additions": 4, "deletions": 3, "changes": 7, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fsemantics.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Fsemantics.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Fsemantics.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -5107,7 +5107,7 @@ omp_reduction_id (enum tree_code reduction_code, tree reduction_id, tree type)\n     case BIT_IOR_EXPR:\n     case TRUTH_ANDIF_EXPR:\n     case TRUTH_ORIF_EXPR:\n-      reduction_id = ansi_opname (reduction_code);\n+      reduction_id = cp_operator_id (reduction_code);\n       break;\n     case MIN_EXPR:\n       p = \"min\";\n@@ -9012,7 +9012,7 @@ classtype_has_nothrow_assign_or_copy_p (tree type, bool assign_p)\n   if (assign_p)\n     {\n       int ix;\n-      ix = lookup_fnfields_1 (type, ansi_assopname (NOP_EXPR));\n+      ix = lookup_fnfields_1 (type, cp_assignment_operator_id (NOP_EXPR));\n       if (ix < 0)\n \treturn false;\n       fns = (*CLASSTYPE_METHOD_VEC (type))[ix];\n@@ -9295,7 +9295,8 @@ is_this_parameter (tree t)\n {\n   if (!DECL_P (t) || DECL_NAME (t) != this_identifier)\n     return false;\n-  gcc_assert (TREE_CODE (t) == PARM_DECL || is_capture_proxy (t));\n+  gcc_assert (TREE_CODE (t) == PARM_DECL || is_capture_proxy (t)\n+\t      || (cp_binding_oracle && TREE_CODE (t) == VAR_DECL));\n   return true;\n }\n "}, {"sha": "8f66d3c7933c1475b9e2538512a96f44c61e72a3", "filename": "gcc/cp/typeck.c", "status": "modified", "additions": 1, "deletions": 1, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Ftypeck.c", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/gcc%2Fcp%2Ftypeck.c", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/gcc%2Fcp%2Ftypeck.c?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -8881,7 +8881,7 @@ check_return_expr (tree retval, bool *no_warning)\n \n   /* Effective C++ rule 15.  See also start_function.  */\n   if (warn_ecpp\n-      && DECL_NAME (current_function_decl) == ansi_assopname(NOP_EXPR))\n+      && DECL_NAME (current_function_decl) == cp_assignment_operator_id (NOP_EXPR))\n     {\n       bool warn = true;\n "}, {"sha": "43b20717b69dc5f2cc3a428767f0dbf0fd4d60cb", "filename": "include/ChangeLog", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2FChangeLog?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -1,3 +1,17 @@\n+2017-01-30  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tIntroduce C++ support in libcc1.\n+\t* gcc-c-fe.def (int_type_v0): Rename from...\n+\t(int_type): ... this.  Introduce new version.\n+\t(float_type_v0): Rename from...\n+\t(float_type): ... this.  Introduce new version.\n+\t(char_type): New.\n+\t* gcc-c-interface.h (gcc_c_api_version): Add GCC_C_FE_VERSION_1.\n+\t(gcc_type_array): Move...\n+\t* gcc-interface.h: ... here.\n+\t* gcc-cp-fe.def: New.\n+\t* gcc-cp-interface.h: New.\n+\n 2017-01-30  Jan Kratochvil <jan.kratochvil@redhat.com>\n \n \t* gcc-interface.h (enum gcc_base_api_version): Update comment"}, {"sha": "acf1940c0122fbc3579bdc1dcedd23bb745365c9", "filename": "include/gcc-c-fe.def", "status": "modified", "additions": 30, "deletions": 5, "changes": 35, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-c-fe.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-c-fe.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgcc-c-fe.def?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -125,16 +125,18 @@ GCC_METHOD3 (gcc_type, build_function_type,\n \t     const struct gcc_type_array *, /* Argument ARGUMENT_TYPES.  */\n \t     int /* bool */)               /* Argument IS_VARARGS.  */\n \n-/* Return an integer type with the given properties.  */\n+/* Return an integer type with the given properties.\n+   Deprecated in v1, use int_type instead.  */\n \n-GCC_METHOD2 (gcc_type, int_type,\n+GCC_METHOD2 (gcc_type, int_type_v0,\n \t     int /* bool */,               /* Argument IS_UNSIGNED.  */\n \t     unsigned long)                /* Argument SIZE_IN_BYTES.  */\n \n-/* Return a floating point type with the given properties.  */\n+/* Return a floating point type with the given properties.\n+   Deprecated in v1, use float_type instead.  */\n \n-GCC_METHOD1 (gcc_type, float_type,\n-\t     unsigned long)\t\t\t/* Argument SIZE_IN_BYTES.  */\n+GCC_METHOD1 (gcc_type, float_type_v0,\n+\t     unsigned long)                /* Argument SIZE_IN_BYTES.  */\n \n /* Return the 'void' type.  */\n \n@@ -195,3 +197,26 @@ GCC_METHOD5 (int /* bool */, build_constant,\n \n GCC_METHOD1 (gcc_type, error,\n \t     const char *)\t\t /* Argument MESSAGE.  */\n+\n+/* Return an integer type with the given properties.  If BUILTIN_NAME\n+   is non-NULL, it must name a builtin integral type with the given\n+   signedness and size, and that is the type that will be returned.  */\n+\n+GCC_METHOD3 (gcc_type, int_type,\n+\t     int /* bool */,               /* Argument IS_UNSIGNED.  */\n+\t     unsigned long,                /* Argument SIZE_IN_BYTES.  */\n+\t     const char *)\t\t   /* Argument BUILTIN_NAME.  */\n+\n+/* Return the 'char' type, a distinct type from both 'signed char' and\n+   'unsigned char' returned by int_type.  */\n+\n+GCC_METHOD0 (gcc_type, char_type)\n+\n+/* Return a floating point type with the given properties.  If BUILTIN_NAME\n+   is non-NULL, it must name a builtin integral type with the given\n+   signedness and size, and that is the type that will be returned.  */\n+\n+GCC_METHOD2 (gcc_type, float_type,\n+\t     unsigned long,                /* Argument SIZE_IN_BYTES.  */\n+\t     const char *)\t\t   /* Argument BUILTIN_NAME.  */\n+"}, {"sha": "e048c863070d6c90cc547a47b6f9e80f7b4a8f33", "filename": "include/gcc-c-interface.h", "status": "modified", "additions": 6, "deletions": 15, "changes": 21, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-c-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-c-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgcc-c-interface.h?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -41,7 +41,11 @@ struct gcc_c_context;\n \n enum gcc_c_api_version\n {\n-  GCC_C_FE_VERSION_0 = 0\n+  GCC_C_FE_VERSION_0 = 0,\n+\n+  /* Added char_type.  Added new version of int_type and float_type,\n+     deprecated int_type_v0 and float_type_v0.  */\n+  GCC_C_FE_VERSION_1 = 1\n };\n \n /* Qualifiers.  */\n@@ -111,19 +115,6 @@ typedef gcc_address gcc_c_symbol_address_function (void *datum,\n \t\t\t\t\t\t   struct gcc_c_context *ctxt,\n \t\t\t\t\t\t   const char *identifier);\n \n-/* An array of types used for creating a function type.  */\n-\n-struct gcc_type_array\n-{\n-  /* Number of elements.  */\n-\n-  int n_elements;\n-\n-  /* The elements.  */\n-\n-  gcc_type *elements;\n-};\n-\n /* The vtable used by the C front end.  */\n \n struct gcc_c_fe_vtable\n@@ -146,7 +137,7 @@ struct gcc_c_fe_vtable\n      provides the declaration.\n \n      DATUM is an arbitrary piece of data that is passed back verbatim\n-     to the callbakcs in requests.  */\n+     to the callbacks in requests.  */\n \n   void (*set_callbacks) (struct gcc_c_context *self,\n \t\t\t gcc_c_oracle_function *binding_oracle,"}, {"sha": "c367c1db1eba82c7a9260898be7b8055bc24a8b6", "filename": "include/gcc-cp-fe.def", "status": "added", "additions": 1050, "deletions": 0, "changes": 1050, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-cp-fe.def", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-cp-fe.def", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgcc-cp-fe.def?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,1050 @@\n+/* Interface between GCC C++ FE and GDB  -*- c -*-\n+\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+\n+\n+/* Push namespace NAME as the current binding level, to which\n+   newly-introduced decls will be bound.  An empty string identifies\n+   the global namespace, whereas NULL identifies an anonymous\n+   namespace.  A namespace named NAME is created in the current scope,\n+   if needed.\n+\n+   If the newly-created namespace is to be an inline namespace, see\n+   make_namespace_inline.  */\n+\n+GCC_METHOD1 (int /* bool */, push_namespace,\n+\t     const char *)\t      /* Argument NAME.  */\n+\n+/* Push TYPE as the current binding level, making its members visible\n+   for name lookup.  The current scope before the call must be the\n+   scope in which the class was declared.  This should be used if the\n+   definition of a class is already finished, but one wishes to define\n+   a nested class, or to enter the scope of one of its member\n+   functions.  */\n+\n+GCC_METHOD1 (int /* bool */, push_class,\n+\t     gcc_type)\t\t/* Argument TYPE.  */\n+\n+/* Push FUNCTION_DECL as the current (empty) binding level (see\n+   reactivate_decl).  The current enclosing scope before the call must\n+   be the scope in which the function was declared.  */\n+\n+GCC_METHOD1 (int /* bool */, push_function,\n+\t     gcc_decl)\t     /* Argument FUNCTION_DECL.  */\n+\n+/* Make DECL visible (again?) within SCOPE.  When SCOPE is NULL, it\n+   means the current scope; if it is not NULL, it must name a function\n+   that is currently active, even if not at the top of the binding\n+   chain.\n+\n+   This function can be used to make e.g. a global function or\n+   variable visible in a namespace or local scope (overriding another\n+   enclosing definition of the same name), but its most common\n+   expected use of this primitive, that gives it its name, is to make\n+   declarations visible again after reentering a function scope,\n+   because when a function is entered with push_function, that does\n+   NOT make any of the declarations nested in it visible for name\n+   lookup.\n+\n+   There is a reason/excuse for that: unlike namespaces and classes,\n+   G++ doesn't ever have to reenter function scopes, so its name\n+   resolution infrastructure is not prepared to do that.  But wait,\n+   there is also a good use for this apparent limitation: a function\n+   may contain multiple scopes (blocks), and the name may be bound to\n+   different symbols in each of these scopes.  With this interface, as\n+   we reenter a function scope, we may choose which symbols to make\n+   visible for the code snippet, or, if there could be template\n+   functions in local scopes, for unresolved names in nested template\n+   class default arguments, or in nested template function signatures.\n+\n+   As for making a local declaration visible for the code snippet,\n+   there are two possibilities: a) introduce it upfront, while\n+   entering the scope for the user expression (see the enter_scope\n+   callback, called by g++ when encountering the push_user_expression\n+   pragma), which might save some scope switching and reactivate_decl\n+   (though this can't be helped if some declarations have to be\n+   introduced and discarded, because of multiple definitions of the\n+   same name in different scopes within a function: they have to be\n+   defined in discriminator order); or b) introduce it when its name\n+   is looked up, entering the scope, introducing the declaration,\n+   leaving the scope, and then reactivating the declaration in its\n+   local scope.\n+\n+   Here's some more detail on how reactivate_decl works.  Say there's\n+   a function foo whose body looks like this:\n+\n+   {\n+     {\n+// point 1\n+       class c {} o __attribute__ ((__used__)); // c  , o\n+     }\n+     struct c {\n+       void f() {\n+// point 2\n+       }\n+     } o __attribute__ ((__used__));            // c_0, o_0\n+     {\n+       class c {} p __attribute__ ((__used__)); // c_1, p\n+// point 3\n+       o.f();\n+     }\n+   }\n+\n+   When we are about to define class c at point 1, we enter the\n+   function foo scope, and since no symbols are visible at point 1, we\n+   proceed to declare class c.  We may then define the class right\n+   away, or, if we leave the function scope, and we later wish to\n+   define it, or to define object o, we can reenter the scope and just\n+   use the previously-obtained gcc_decl to define the class, without\n+   having to reactivate the declaration.\n+\n+   Now, if we are to set up the binding context for point 2, we have\n+   to define c_0::f, and in order to do so, we have to declare and\n+   define c_0.  Before we can declare c_0, we MUST at least declare c.\n+\n+     As a general rule, before we can declare or define any local name\n+     with a discriminator, we have to at least declare any other\n+     occurrences of the same name in the same enclosing entity with\n+     lower or absent discriminator.\n+\n+   So, we declare c, then we leave the function scope and reenter it\n+   so as to declare c_0 (also with name \"c\", which is why we have to\n+   leave and reenter the function scope, otherwise we would get an\n+   error because of the duplicate definition; g++ will assign a\n+   discriminator because it still remembers there was an earlier\n+   declaration of c_0 within the function, it's just no longer in\n+   scope), then we can define c_0, including its member function f.\n+\n+   Likewise, if we wish to define o_0, we have to define o first.  If\n+   we wish to declare (and maybe then define) c_1, we have to at least\n+   declare (c and then) c_0 first.\n+\n+   Then, as we set up the binding context to compile a code snippet at\n+   point 3, we may choose to activate c_1, o_0 and p upfront,\n+   declaring and discarding c, c_0 and o, and then reentering the\n+   funciton scope to declare c_1, o_0 and p; or we can wait for oracle\n+   lookups of c, o or p.  If c is looked up, and the debugger resolves\n+   c in the scope to c_1, it is expected to enter the function scope\n+   from the top level, declare c, leave it, reenter it, declare c_0,\n+   leave it, reenter it, declare c_1, leave it, and then reactivate\n+   c_1 in the function scope.  If c_1 is needed as a complete type,\n+   the definition may be given right after the declaration, or the\n+   scope will have to be reentered in order to define the class.\n+\n+.  If the code snippet is at point 2, we don't need to (re)activate\n+   any declaration: nothing from any local scope is visible.  Just\n+   entering the scope of the class containing member function f\n+   reactivates the names of its members, including the class name\n+   itself.  */\n+\n+GCC_METHOD2 (int /* bool */, reactivate_decl,\n+\t     gcc_decl,\t\t/* Argument DECL.  */\n+\t     gcc_decl)\t\t/* Argument SCOPE.  */\n+\n+/* Pop the namespace last entered with push_namespace, or class last\n+   entered with push_class, or function last entered with\n+   push_function, restoring the binding level in effect before the\n+   matching push_* call.  */\n+\n+GCC_METHOD0 (int /* bool */, pop_binding_level)\n+\n+/* Return the NAMESPACE_DECL, TYPE_DECL or FUNCTION_DECL of the\n+   binding level that would be popped by pop_scope.  */\n+\n+GCC_METHOD0 (gcc_decl, get_current_binding_level_decl)\n+\n+/* Make the current binding level an inline namespace.  It must be a\n+   namespace to begin with.  It is safe to call this more than once\n+   for the same namespace, but after the first call, subsequent ones\n+   will not return a success status.  */\n+\n+GCC_METHOD0 (int /* bool */, make_namespace_inline)\n+\n+/* Add USED_NS to the namespaces used by the current binding level.\n+   Use get_current_binding_level_decl to obtain USED_NS's\n+   gcc_decl.  */\n+\n+GCC_METHOD1 (int /* bool */, add_using_namespace,\n+\t     gcc_decl)\t\t\t/* Argument USED_NS.  */\n+\n+/* Introduce a namespace alias declaration, as in:\n+\n+   namespace foo = [... ::] bar;\n+\n+   After this call, namespace TARGET will be visible as ALIAS within\n+   the current namespace.  Get the declaration for TARGET by calling\n+   get_current_binding_level_decl after pushing into it.  */\n+\n+GCC_METHOD2 (int /* bool */, add_namespace_alias,\n+\t     const char *,\t\t/* Argument ALIAS.  */\n+\t     gcc_decl)\t\t\t/* Argument TARGET.  */\n+\n+/* Introduce a using declaration, as in:\n+\n+   using foo::bar;\n+\n+   The TARGET decl names the qualifying scope (foo:: above) and the\n+   identifier (bar), but that does not mean that only TARGET will be\n+   brought into the current scope: all bindings of TARGET's identifier\n+   in the qualifying scope will be brought in.\n+\n+   FLAGS should specify GCC_CP_SYMBOL_USING.  If the current scope is\n+   a class scope, visibility flags must be supplied.\n+\n+   Even when TARGET is template dependent, we don't need to specify\n+   whether or not it is a typename: the supplied declaration (that\n+   could be a template-dependent type converted to declaration by\n+   get_type_decl) indicates so.  */\n+\n+GCC_METHOD2 (int /* bool */, add_using_decl,\n+\t     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */\n+\t     gcc_decl)\t\t      /* Argument TARGET.  */\n+\n+/* Create a new \"decl\" in GCC, and bind it in the current binding\n+   level.  A decl is a declaration, basically a kind of symbol.\n+\n+   NAME is the name of the new symbol.  SYM_KIND is the kind of\n+   symbol being requested.  SYM_TYPE is the new symbol's C++ type;\n+   except for labels, where this is not meaningful and should be\n+   zero.  If SUBSTITUTION_NAME is not NULL, then a reference to this\n+   decl in the source will later be substituted with a dereference\n+   of a variable of the given name.  Otherwise, for symbols having\n+   an address (e.g., functions), ADDRESS is the address.  FILENAME\n+   and LINE_NUMBER refer to the symbol's source location.  If this\n+   is not known, FILENAME can be NULL and LINE_NUMBER can be 0.\n+   This function returns the new decl.\n+\n+   Use this function to register typedefs, functions and variables to\n+   namespace and local binding levels, and typedefs, member functions\n+   (static or not), and static data members to class binding levels.\n+   Class members must have their access controls specified with\n+   GCC_CP_ACCESS_* flags in SYM_KIND.\n+\n+   Note that, since access controls are disabled, we have no means to\n+   express private, protected and public.\n+\n+   There are various flags that can be set in SYM_KIND to specify\n+   additional semantics.  Look for GCC_CP_FLAGs in the definition of\n+   enum gcc_cp_symbol_kind in gcc-cp-interface.h.\n+\n+   In order to define member functions, pass GCC_CP_SYMBOL_FUNCTION in\n+   SYM_KIND, and a function_type for static member functions or a\n+   method type for non-static member functions, including constructors\n+   and destructors.  Use build_function_type to create a function\n+   type; for a method type, start by creating a function type without\n+   any compiler-introduced artificial arguments (the implicit this\n+   pointer, and the __in_chrg added to constructors and destructors,\n+   and __vtt_parm added to the former), and then use build_method_type\n+   to create the method type out of the class type and the function\n+   type.\n+\n+   For operator functions, set GCC_CP_FLAG_SPECIAL_FUNCTION in\n+   SYM_KIND, in addition to any other applicable flags, and pass as\n+   NAME a string starting with the two-character mangling for operator\n+   name: \"ps\" for unary plus, \"mL\" for multiply and assign, *=; etc.\n+   Use \"cv\" for type converstion operators (the target type portion\n+   may be omitted, as it is taken from the return type in SYM_TYPE).\n+   For operator\"\", use \"li\" followed by the identifier (the mangled\n+   name mandates digits specifying the length of the identifier; if\n+   present, they determine the end of the identifier, otherwise, the\n+   identifier extents to the end of the string, so that \"li3_Kme\" and\n+   \"li_Km\" are equivalent).\n+\n+   Constructors and destructors need special care, because for each\n+   constructor and destructor there may be multiple clones defined\n+   internally by the compiler.  With build_decl, you can introduce the\n+   base declaration of a constructor or a destructor, setting\n+   GCC_CP_FLAG_SPECIAL_FUNCTION the flag and using names starting with\n+   capital \"C\" or \"D\", respectively, followed by a digit (see below),\n+   a blank, or NUL ('\\0').  DO NOT supply an ADDRESS or a\n+   SUBSTITUTION_NAME to build_decl, it would be meaningless (and\n+   rejected) for the base declaration; use define_cdtor_clone to\n+   introduce the address of each clone.  For constructor templates,\n+   declare the template with build_decl, and then, for each\n+   specialization, introduce it with\n+   build_function_template_specialization, and then define the\n+   addresses of each of its clones with define_cdtor_clone.\n+\n+   NAMEs for GCC_CP_FLAG_SPECIAL_FUNCTION:\n+\n+     NAME    meaning\n+     C?      constructor base declaration (? may be 1, 2, 4, blank or NUL)\n+     D?      destructor base declaration (? may be 0, 1, 2, 4, blank or NUL)\n+     nw      operator new\n+     na      operator new[]\n+     dl      operator delete\n+     da      operator delete[]\n+     ps      operator + (unary)\n+     ng      operator - (unary)\n+     ad      operator & (unary)\n+     de      operator * (unary)\n+     co      operator ~\n+     pl      operator +\n+     mi      operator -\n+     ml      operator *\n+     dv      operator /\n+     rm      operator %\n+     an      operator &\n+     or      operator |\n+     eo      operator ^\n+     aS      operator =\n+     pL      operator +=\n+     mI      operator -=\n+     mL      operator *=\n+     dV      operator /=\n+     rM      operator %=\n+     aN      operator &=\n+     oR      operator |=\n+     eO      operator ^=\n+     ls      operator <<\n+     rs      operator >>\n+     lS      operator <<=\n+     rS      operator >>=\n+     eq      operator ==\n+     ne      operator !=\n+     lt      operator <\n+     gt      operator >\n+     le      operator <=\n+     ge      operator >=\n+     nt      operator !\n+     aa      operator &&\n+     oo      operator ||\n+     pp      operator ++\n+     mm      operator --\n+     cm      operator ,\n+     pm      operator ->*\n+     pt      operator ->\n+     cl      operator ()\n+     ix      operator []\n+     qu      operator ?\n+     cv      operator <T> (conversion operator)\n+     li<id>  operator \"\" <id>\n+\n+   FIXME: How about attributes?  */\n+\n+GCC_METHOD7 (gcc_decl, build_decl,\n+\t     const char *,\t      /* Argument NAME.  */\n+\t     enum gcc_cp_symbol_kind, /* Argument SYM_KIND.  */\n+\t     gcc_type,\t\t      /* Argument SYM_TYPE.  */\n+\t     const char *,\t      /* Argument SUBSTITUTION_NAME.  */\n+\t     gcc_address,\t      /* Argument ADDRESS.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Supply the ADDRESS of one of the multiple clones of constructor or\n+   destructor CDTOR.  The clone is specified by NAME, using the\n+   following name mangling conventions:\n+\n+     C1      in-charge constructor\n+     C2      not-in-charge constructor\n+     C4      unified constructor\n+     D0      deleting destructor\n+     D1      in-charge destructor\n+     D2      not-in-charge destructor\n+     D4      unified destructor\n+\n+   The following information is not necessary to use the API.\n+\n+   C1 initializes an instance of the class (rather than of derived\n+   classes), including virtual base classes, whereas C2 initializes a\n+   sub-object (of the given class type) of an instance of some derived\n+   class (or a full object that doesn't have any virtual base\n+   classes).\n+\n+   D0 and D1 destruct an instance of the class, including virtual base\n+   classes, but only the former calls operator delete to release the\n+   object's storage at the end; D2 destructs a sub-object (of the\n+   given class type) of an instance of a derived class (or a full\n+   object that doesn't have any virtual base classes).\n+\n+   The [CD]4 manglings (and symbol definitions) are non-standard, but\n+   GCC uses them in some cases: rather than assuming they are\n+   in-charge or not-in-charge, they test the implicit argument that\n+   the others ignore to tell how to behave.  These are used instead of\n+   cloning when we just can't use aliases.  */\n+\n+GCC_METHOD3 (gcc_decl, define_cdtor_clone,\n+\t     const char *,\t      /* Argument NAME.  */\n+\t     gcc_decl,\t\t      /* Argument CDTOR.  */\n+\t     gcc_address)\t      /* Argument ADDRESS.  */\n+\n+/* Return the type associated with the given declaration.  This is\n+   most useful to obtain the type associated with a forward-declared\n+   class, because it is the gcc_type, rather than the gcc_decl, that\n+   has to be used to build other types, but build_decl returns a\n+   gcc_decl rather than a gcc_type.  This call can in theory be used\n+   to obtain the type from any other declaration; it is supposed to\n+   return the same type that was supplied when the declaration was\n+   created.  */\n+\n+GCC_METHOD1 (gcc_type, get_decl_type,\n+\t     gcc_decl)            /* Argument DECL.  */\n+\n+/* Return the declaration for a type.  */\n+\n+GCC_METHOD1 (gcc_decl, get_type_decl,\n+\t     gcc_type)            /* Argument TYPE.  */\n+\n+/* Declare DECL as a friend of the current class scope, if TYPE is\n+   NULL, or of TYPE itself otherwise.  DECL may be a function or a\n+   class, be they template generics, template specializations or not\n+   templates.  TYPE must be a class type (not a template generic).\n+\n+   The add_friend call cannot introduce a declaration; even if the\n+   friend is first declared as a friend in the source code, the\n+   declaration belongs in the enclosing namespace, so it must be\n+   introduced in that namespace, and the resulting declaration can\n+   then be made a friend.\n+\n+   DECL cannot, however, be a member of a template class generic,\n+   because we have no means to introduce their declarations.  This\n+   interface has no notion of definitions for template generics.  As a\n+   consequence, users of this interface must introduce each friend\n+   template member specialization separately, i.e., instead of:\n+\n+     template <typename T> friend struct X<T>::M;\n+\n+   they must be declared as if they were:\n+\n+     friend struct X<onetype>::M;\n+     friend struct X<anothertype>::M;\n+     ... for each specialization of X.\n+\n+\n+   Specializations of a template can have each others' members as\n+   friends:\n+\n+     template <typename T> class foo {\n+       int f();\n+       template <typename U> friend int foo<U>::f();\n+     };\n+\n+   It wouldn't always be possible to define all specializations of a\n+   template class before introducing the friend declarations in their\n+   expanded, per-specialization form.\n+\n+   In order to simplify such friend declarations, and to enable\n+   incremental friend declarations as template specializations are\n+   introduced, add_friend can be called after the befriending class is\n+   fully defined, passing it a non-NULL TYPE argument naming the\n+   befriending class type.  */\n+\n+GCC_METHOD2 (int /* bool */, add_friend,\n+\t     gcc_decl,\t\t      /* Argument DECL.  */\n+\t     gcc_type)\t\t      /* Argument TYPE.  */\n+\n+/* Return the type of a pointer to a given base type.  */\n+\n+GCC_METHOD1 (gcc_type, build_pointer_type,\n+\t     gcc_type)\t\t\t/* Argument BASE_TYPE.  */\n+\n+/* Return the type of a reference to a given base type.  */\n+\n+GCC_METHOD2 (gcc_type, build_reference_type,\n+\t     gcc_type,\t\t\t/* Argument BASE_TYPE.  */\n+\t     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */\n+\n+/* Create a new pointer-to-member type.  MEMBER_TYPE is the data\n+   member type, while CLASS_TYPE is the class type containing the data\n+   member.  For pointers to member functions, MEMBER_TYPE must be a\n+   method type, and CLASS_TYPE must be specified even though it might\n+   be possible to extract it from the method type.  */\n+\n+GCC_METHOD2 (gcc_type, build_pointer_to_member_type,\n+\t     gcc_type,\t\t\t   /* Argument CLASS_TYPE.  */\n+\t     gcc_type) \t\t\t   /* Argument MEMBER_TYPE.  */\n+\n+/* Start a template parameter list scope and enters it, so that\n+   subsequent build_type_template_parameter and\n+   build_value_template_parameter calls create template parameters in\n+   the list.  The list is closed by a build_decl call with\n+   GCC_CP_SYMBOL_FUNCTION or GCC_CP_SYMBOL_CLASS, that, when the scope\n+   is a template parameter list, declares a template function or a\n+   template class with the then-closed parameter list.  The scope in\n+   which the new declaration is to be introduced by build_decl must be\n+   entered before calling start_template_decl, and build_decl returns\n+   to that scope, from the template parameter list scope, before\n+   introducing the declaration.  */\n+\n+GCC_METHOD0 (int /* bool */, start_template_decl)\n+\n+/* Build a typename template-parameter (e.g., the T in template\n+   <typename T = X>).  Either PACK_P should be nonzero, to indicate an\n+   argument pack (the last argument in a variadic template argument\n+   list, as in template <typename... T>), or DEFAULT_TYPE may be\n+   non-NULL to set the default type argument (e.g. X) for the template\n+   parameter.  FILENAME and LINE_NUMBER may specify the source\n+   location in which the template parameter was declared.  */\n+\n+GCC_METHOD5 (gcc_type, build_type_template_parameter,\n+\t     const char *,\t\t\t      /* Argument ID.  */\n+\t     int /* bool */,\t\t\t  /* Argument PACK_P.  */\n+\t     gcc_type,\t\t\t    /* Argument DEFAULT_TYPE.  */\n+\t     const char *,\t\t\t/* Argument FILENAME.  */\n+\t     unsigned int)\t\t     /* Argument LINE_NUMBER.  */\n+\n+/* Build a template template-parameter (e.g., the T in template\n+   <template <[...]> class T = X>).  DEFAULT_TEMPL may be non-NULL to\n+   set the default type-template argument (e.g. X) for the template\n+   template parameter.  FILENAME and LINE_NUMBER may specify the\n+   source location in which the template parameter was declared.  */\n+\n+GCC_METHOD5 (gcc_utempl, build_template_template_parameter,\n+\t     const char *,\t\t\t      /* Argument ID.  */\n+\t     int /* bool */,\t\t\t  /* Argument PACK_P.  */\n+\t     gcc_utempl,\t\t   /* Argument DEFAULT_TEMPL.  */\n+\t     const char *,\t\t\t/* Argument FILENAME.  */\n+\t     unsigned int)\t\t     /* Argument LINE_NUMBER.  */\n+\n+/* Build a value template-parameter (e.g., the V in template <typename\n+   T, T V> or in template <int V = X>).  DEFAULT_VALUE may be non-NULL\n+   to set the default value argument for the template parameter (e.g.,\n+   X).  FILENAME and LINE_NUMBER may specify the source location in\n+   which the template parameter was declared.  */\n+\n+GCC_METHOD5 (gcc_decl, build_value_template_parameter,\n+\t     gcc_type,\t\t\t  \t    /* Argument TYPE.  */\n+\t     const char *,\t\t\t      /* Argument ID.  */\n+\t     gcc_expr,\t\t\t   /* Argument DEFAULT_VALUE.  */\n+\t     const char *,\t\t\t/* Argument FILENAME.  */\n+\t     unsigned int)\t\t     /* Argument LINE_NUMBER.  */\n+\n+/* Build a template-dependent typename (e.g., typename T::bar or\n+   typename T::template bart<X>).  ENCLOSING_TYPE should be the\n+   template-dependent nested name specifier (e.g., T), ID should be\n+   the name of the member of the ENCLOSING_TYPE (e.g., bar or bart),\n+   and TARGS should be non-NULL and specify the template arguments\n+   (e.g. <X>) iff ID is to name a class template.\n+\n+   In this and other calls, a template-dependent nested name specifier\n+   may be a template class parameter (build_type_template_parameter),\n+   a specialization (returned by build_dependent_type_template_id) of\n+   a template template parameter (returned by\n+   build_template_template_parameter) or a member type thereof\n+   (returned by build_dependent_typename itself).  */\n+\n+GCC_METHOD3 (gcc_type, build_dependent_typename,\n+\t     gcc_type,\t\t\t  /* Argument ENCLOSING_TYPE.  */\n+\t     const char *,\t\t\t      /* Argument ID.  */\n+\t     const struct gcc_cp_template_args *)  /* Argument TARGS.  */\n+\n+/* Build a template-dependent class template (e.g., T::template bart).\n+   ENCLOSING_TYPE should be the template-dependent nested name\n+   specifier (e.g., T), ID should be the name of the class template\n+   member of the ENCLOSING_TYPE (e.g., bart).  */\n+\n+GCC_METHOD2 (gcc_utempl, build_dependent_class_template,\n+\t     gcc_type,\t\t\t  /* Argument ENCLOSING_TYPE.  */\n+\t     const char *)\t\t\t      /* Argument ID.  */\n+\n+/* Build a template-dependent type template-id (e.g., T<A>).\n+   TEMPLATE_DECL should be a template template parameter (e.g., the T\n+   in template <template <[...]> class T = X>), and TARGS should\n+   specify the template arguments (e.g. <A>).  */\n+\n+GCC_METHOD2 (gcc_type, build_dependent_type_template_id,\n+\t     gcc_utempl,\t\t   /* Argument TEMPLATE_DECL.  */\n+\t     const struct gcc_cp_template_args *)  /* Argument TARGS.  */\n+\n+/* Build a template-dependent expression (e.g., S::val or S::template\n+   mtf<X>, or unqualified f or template tf<X>).\n+\n+   ENCLOSING_SCOPE should be a template-dependent nested name\n+   specifier (e.g., T), a resolved namespace or class decl, or NULL\n+   for unqualified names; ID should be the name of the member of the\n+   ENCLOSING_SCOPE (e.g., val or mtf) or unqualified overloaded\n+   function; and TARGS should list template arguments (e.g. <X>) when\n+   mtf or tf are to name a template function, or be NULL otherwise.\n+\n+   Unqualified names and namespace- or class-qualified names can only\n+   resolve to overloaded functions, to be used in contexts that\n+   involve overload resolution that cannot be resolved because of\n+   template-dependent argument or return types, such as call\n+   expressions with template-dependent arguments, conversion\n+   expressions to function types with template-dependent argument\n+   types or the like.  Other cases of unqualified or\n+   non-template-dependent-qualified names should NOT use this\n+   function, and use decl_expr to convert the appropriate function or\n+   object declaration to an expression.\n+\n+   If ID is the name of a special member function, FLAGS should be\n+   GCC_CP_SYMBOL_FUNCTION|GCC_CP_FLAG_SPECIAL_FUNCTION, and ID should\n+   be one of the encodings for special member functions documented in\n+   build_decl.  Otherwise, FLAGS should be GCC_CP_SYMBOL_MASK, which\n+   suggests the symbol kind is not known (though we know it is not a\n+   type).\n+\n+   If ID denotes a conversion operator, CONV_TYPE should name the\n+   target type of the conversion.  Otherwise, CONV_TYPE must be\n+   NULL.  */\n+\n+GCC_METHOD5 (gcc_expr, build_dependent_expr,\n+\t     gcc_decl,\t\t\t /* Argument ENCLOSING_SCOPE.  */\n+\t     enum gcc_cp_symbol_kind,\t\t   /* Argument FLAGS.  */\n+\t     const char *,\t\t\t    /* Argument NAME.  */\n+\t     gcc_type,\t\t\t       /* Argument CONV_TYPE.  */\n+\t     const struct gcc_cp_template_args *)  /* Argument TARGS.  */\n+\n+/* Build a gcc_expr for the value VALUE in type TYPE.  */\n+\n+GCC_METHOD2 (gcc_expr, build_literal_expr,\n+\t     gcc_type,\t\t  /* Argument TYPE.  */\n+\t     unsigned long)\t  /* Argument VALUE.  */\n+\n+/* Build a gcc_expr that denotes DECL, the declaration of a variable\n+   or function in namespace scope, or of a static member variable or\n+   function.  Use QUALIFIED_P to build the operand of unary & so as to\n+   compute a pointer-to-member, rather than a regular pointer.  */\n+\n+GCC_METHOD2 (gcc_expr, build_decl_expr,\n+\t     gcc_decl,\t\t\t/* Argument DECL.  */\n+\t     int /* bool */)\t\t/* Argument QUALIFIED_P.  */\n+\n+/* Build a gcc_expr that denotes the unary operation UNARY_OP applied\n+   to the gcc_expr OPERAND.  For non-expr operands, see\n+   unary_type_expr.  Besides the UNARY_OP encodings used for operator\n+   names, we support \"pp_\" for preincrement, and \"mm_\" for\n+   predecrement, \"nx\" for noexcept, \"tw\" for throw, \"tr\" for rethrow\n+   (pass NULL as the operand), \"te\" for typeid, \"sz\" for sizeof, \"az\"\n+   for alignof, \"dl\" for delete, \"gsdl\" for ::delete, \"da\" for\n+   delete[], \"gsda\" for ::delete[], \"sp\" for pack expansion, \"sZ\" for\n+   sizeof...(function argument pack).  */\n+\n+GCC_METHOD2 (gcc_expr, build_unary_expr,\n+\t     const char *,\t  /* Argument UNARY_OP.  */\n+\t     gcc_expr)\t\t  /* Argument OPERAND.  */\n+\n+/* Build a gcc_expr that denotes the binary operation BINARY_OP\n+   applied to gcc_exprs OPERAND1 and OPERAND2.  Besides the BINARY_OP\n+   encodings used for operator names, we support \"ds\" for the operator\n+   token \".*\" and \"dt\" for the operator token \".\".  When using\n+   operators that take a name as their second operand (\".\" and \"->\")\n+   use decl_expr to convert the gcc_decl of the member name to a\n+   gcc_expr, if the member name wasn't created with\n+   e.g. build_dependent_expr.  */\n+\n+GCC_METHOD3 (gcc_expr, build_binary_expr,\n+\t     const char *,\t  /* Argument BINARY_OP.  */\n+\t     gcc_expr,\t\t  /* Argument OPERAND1.  */\n+\t     gcc_expr)\t\t  /* Argument OPERAND2.  */\n+\n+/* Build a gcc_expr that denotes the ternary operation TERNARY_OP\n+   applied to gcc_exprs OPERAND1, OPERAND2 and OPERAND3.  The only\n+   supported TERNARY_OP is \"qu\", for the \"?:\" operator.  */\n+\n+GCC_METHOD4 (gcc_expr, build_ternary_expr,\n+\t     const char *,\t  /* Argument TERNARY_OP.  */\n+\t     gcc_expr,\t\t  /* Argument OPERAND1.  */\n+\t     gcc_expr,\t\t  /* Argument OPERAND2.  */\n+\t     gcc_expr)\t\t  /* Argument OPERAND3.  */\n+\n+/* Build a gcc_expr that denotes the unary operation UNARY_OP applied\n+   to the gcc_type OPERAND.  Supported unary operations taking types\n+   are \"ti\" for typeid, \"st\" for sizeof, \"at\" for alignof, and \"sZ\"\n+   for sizeof...(template argument pack).  */\n+\n+GCC_METHOD2 (gcc_expr, build_unary_type_expr,\n+\t     const char *,\t  /* Argument UNARY_OP.  */\n+\t     gcc_type)\t\t  /* Argument OPERAND.  */\n+\n+/* Build a gcc_expr that denotes the binary operation BINARY_OP\n+   applied to gcc_type OPERAND1 and gcc_expr OPERAND2.  Use this for\n+   all kinds of (single-argument) type casts (\"dc\", \"sc\", \"cc\", \"rc\"\n+   for dynamic, static, const and reinterpret casts, respectively;\n+   \"cv\" for functional or C-style casts).  */\n+\n+GCC_METHOD3 (gcc_expr, build_cast_expr,\n+\t     const char *,\t  /* Argument BINARY_OP.  */\n+\t     gcc_type,\t\t  /* Argument OPERAND1.  */\n+\t     gcc_expr)\t\t  /* Argument OPERAND2.  */\n+\n+/* Build a gcc_expr that denotes the conversion of an expression list\n+   VALUES to TYPE, with (\"tl\") or without (\"cv\") braces, or a braced\n+   initializer list of unspecified type (e.g., a component of another\n+   braced initializer list; pass \"il\" for CONV_OP, and NULL for\n+   TYPE).  */\n+\n+GCC_METHOD3 (gcc_expr, build_expression_list_expr,\n+\t     const char *,\t\t\t /* Argument CONV_OP.  */\n+\t     gcc_type,\t\t\t\t    /* Argument TYPE.  */\n+\t     const struct gcc_cp_function_args *) /* Argument VALUES.  */\n+\n+/* Build a gcc_expr that denotes a new (\"nw\") or new[] (\"na\")\n+   expression of TYPE, with or without a GLOBAL_NS qualifier (prefix\n+   the NEW_OP with \"gs\"), with or without PLACEMENT, with or without\n+   INITIALIZER.  If it's not a placement new, PLACEMENT must be NULL\n+   (rather than a zero-length placement arg list).  If there's no\n+   specified initializer, INITIALIZER must be NULL; a zero-length arg\n+   list stands for a default initializer.  */\n+\n+GCC_METHOD4 (gcc_expr, build_new_expr,\n+\t     const char *,\t\t\t       /* Argument NEW_OP.  */\n+\t     const struct gcc_cp_function_args *,   /* Argument PLACEMENT.  */\n+\t     gcc_type,\t\t\t\t\t /* Argument TYPE.  */\n+\t     const struct gcc_cp_function_args *) /* Argument INITIALIZER.  */\n+\n+/* Return a call expression that calls CALLABLE with arguments ARGS.\n+   CALLABLE may be a function, a callable object, a pointer to\n+   function, an unresolved expression, an unresolved overload set, an\n+   object expression combined with a member function overload set or a\n+   pointer-to-member.  If QUALIFIED_P, CALLABLE will be interpreted as\n+   a qualified name, preventing virtual function dispatch.  */\n+\n+GCC_METHOD3 (gcc_expr, build_call_expr,\n+\t     gcc_expr,\t\t\t      /* Argument CALLABLE.  */\n+\t     int /* bool */,\t\t   /* Argument QUALIFIED_P.  */\n+\t     const struct gcc_cp_function_args *) /* Argument ARGS.  */\n+\n+/* Return the type of the gcc_expr OPERAND.\n+   Use this for decltype.\n+   For decltype (auto), pass a NULL OPERAND.\n+\n+   Note: for template-dependent expressions, the result is NULL,\n+   because the type is only computed when template argument\n+   substitution is performed.  */\n+\n+GCC_METHOD1 (gcc_type, get_expr_type,\n+\t     gcc_expr)\t\t  /* Argument OPERAND.  */\n+\n+/* Introduce a specialization of a template function.\n+\n+   TEMPLATE_DECL is the template function, and TARGS are the arguments\n+   for the specialization.  ADDRESS is the address of the\n+   specialization.  FILENAME and LINE_NUMBER specify the source\n+   location associated with the template function specialization.  */\n+\n+GCC_METHOD5 (gcc_decl, build_function_template_specialization,\n+\t     gcc_decl,\t\t\t   /* Argument TEMPLATE_DECL.  */\n+\t     const struct gcc_cp_template_args *,  /* Argument TARGS.  */\n+\t     gcc_address,\t\t\t /* Argument ADDRESS.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Specialize a template class as an incomplete type.  A definition\n+   can be supplied later, with start_class_type.\n+\n+   TEMPLATE_DECL is the template class, and TARGS are the arguments\n+   for the specialization.  FILENAME and LINE_NUMBER specify the\n+   source location associated with the template class\n+   specialization.  */\n+\n+GCC_METHOD4 (gcc_decl, build_class_template_specialization,\n+\t     gcc_decl,\t\t\t   /* Argument TEMPLATE_DECL.  */\n+\t     const struct gcc_cp_template_args *,  /* Argument TARGS.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Start defining a 'class', 'struct' or 'union' type, entering its\n+   own binding level.  Initially it has no fields.\n+\n+   TYPEDECL is the forward-declaration of the type, returned by\n+   build_decl.  BASE_CLASSES indicate the base classes of class NAME.\n+   FILENAME and LINE_NUMBER specify the source location associated\n+   with the class definition, should they be different from those of\n+   the forward declaration.  */\n+\n+GCC_METHOD4 (gcc_type, start_class_type,\n+\t     gcc_decl,\t\t      /* Argument TYPEDECL.  */\n+\t     const struct gcc_vbase_array *,/* Argument BASE_CLASSES.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Create a new closure class type, record it as the\n+   DISCRIMINATOR-numbered closure type in the current scope (or\n+   associated with EXTRA_SCOPE, if non-NULL), and enter the closure\n+   type's own binding level.  This primitive would sort of combine\n+   build_decl and start_class_type, if they could be used to introduce\n+   a closure type.  Initially it has no fields.\n+\n+   FILENAME and LINE_NUMBER specify the source location associated\n+   with the class.  EXTRA_SCOPE, if non-NULL, must be a PARM_DECL of\n+   the current function, or a FIELD_DECL of the current class.  If it\n+   is NULL, the current scope must be a function.  */\n+\n+GCC_METHOD5 (gcc_type, start_closure_class_type,\n+\t     int,\t\t      /* Argument DISCRIMINATOR.  */\n+\t     gcc_decl,\t\t      /* Argument EXTRA_SCOPE.  */\n+\t     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Add a non-static data member to the most-recently-started\n+   unfinished struct or union type.  FIELD_NAME is the field's name.\n+   FIELD_TYPE is the type of the field.  BITSIZE and BITPOS indicate\n+   where in the struct the field occurs.  */\n+\n+GCC_METHOD5 (gcc_decl, build_field,\n+\t     const char *,\t\t   /* Argument FIELD_NAME.  */\n+\t     gcc_type,\t\t\t   /* Argument FIELD_TYPE.  */\n+\t     enum gcc_cp_symbol_kind,\t   /* Argument FIELD_FLAGS.  */\n+\t     unsigned long,\t\t   /* Argument BITSIZE.  */\n+\t     unsigned long)\t\t   /* Argument BITPOS.  */\n+\n+/* After all the fields have been added to a struct, class or union,\n+   the struct or union type must be \"finished\".  This does some final\n+   cleanups in GCC, and pops to the binding level that was in effect\n+   before the matching start_class_type or\n+   start_closure_class_type.  */\n+\n+GCC_METHOD1 (int /* bool */, finish_class_type,\n+\t     unsigned long)\t\t   /* Argument SIZE_IN_BYTES.  */\n+\n+/* Create a new 'enum' type, and record it in the current binding\n+   level.  The new type initially has no associated constants.\n+\n+   NAME is the enum name.  FILENAME and LINE_NUMBER specify its source\n+   location.  */\n+\n+GCC_METHOD5 (gcc_type, start_enum_type,\n+\t     const char *,\t      /* Argument NAME.  */\n+\t     gcc_type,\t\t      /* Argument UNDERLYING_INT_TYPE. */\n+\t     enum gcc_cp_symbol_kind, /* Argument FLAGS.  */\n+\t     const char *,\t      /* Argument FILENAME.  */\n+\t     unsigned int)\t      /* Argument LINE_NUMBER.  */\n+\n+/* Add a new constant to an enum type.  NAME is the constant's name\n+   and VALUE is its value.  Returns a gcc_decl for the constant.  */\n+\n+GCC_METHOD3 (gcc_decl, build_enum_constant,\n+\t     gcc_type,\t\t       /* Argument ENUM_TYPE.  */\n+\t     const char *,\t       /* Argument NAME.  */\n+\t     unsigned long)\t       /* Argument VALUE.  */\n+\n+/* After all the constants have been added to an enum, the type must\n+   be \"finished\".  This does some final cleanups in GCC.  */\n+\n+GCC_METHOD1 (int /* bool */, finish_enum_type,\n+\t     gcc_type)\t\t       /* Argument ENUM_TYPE.  */\n+\n+/* Create a new function type.  RETURN_TYPE is the type returned by\n+   the function, and ARGUMENT_TYPES is a vector, of length NARGS, of\n+   the argument types.  IS_VARARGS is true if the function is\n+   varargs.  */\n+\n+GCC_METHOD3 (gcc_type, build_function_type,\n+\t     gcc_type,\t\t\t   /* Argument RETURN_TYPE.  */\n+\t     const struct gcc_type_array *,/* Argument ARGUMENT_TYPES.  */\n+\t     int /* bool */)\t\t   /* Argument IS_VARARGS.  */\n+\n+/* Create a variant of a function type with an exception\n+   specification.  FUNCTION_TYPE is a function or method type.\n+   EXCEPT_TYPES is an array with the list of exception types.  Zero as\n+   the array length implies throw() AKA noexcept(true); NULL as the\n+   pointer to gcc_type_array implies noexcept(false), which is almost\n+   equivalent (but distinguishable by the compiler) to an unspecified\n+   exception list.  */\n+\n+GCC_METHOD2 (gcc_type, build_exception_spec_variant,\n+\t     gcc_type,\t\t\t   /* Argument FUNCTION_TYPE.  */\n+\t     const struct gcc_type_array *)/* Argument EXCEPT_TYPES.  */\n+\n+/* Create a new non-static member function type.  FUNC_TYPE is the\n+   method prototype, without the implicit THIS pointer, added as a\n+   pointer to the QUALS-qualified CLASS_TYPE.  If CLASS_TYPE is NULL,\n+   this creates a cv-qualified (member) function type not associated\n+   with any specific class, as needed to support \"typedef void f(int)\n+   const;\", which can later be used to declare member functions and\n+   pointers to member functions.  */\n+\n+GCC_METHOD4 (gcc_type, build_method_type,\n+\t     gcc_type,\t\t\t   /* Argument CLASS_TYPE.  */\n+\t     gcc_type, \t\t\t   /* Argument FUNC_TYPE.  */\n+\t     enum gcc_cp_qualifiers,\t   /* Argument QUALS.  */\n+\t     enum gcc_cp_ref_qualifiers)   /* Argument RQUALS.  */\n+\n+/* Return a declaration for the (INDEX - 1)th argument of\n+   FUNCTION_DECL, i.e., for the first argument, use zero as the index.\n+   If FUNCTION_DECL is a non-static member function, use -1 to get the\n+   implicit THIS parameter.  */\n+\n+GCC_METHOD2 (gcc_decl, get_function_parameter_decl,\n+\t     gcc_decl,\t\t\t     /* Argument FUNCTION_DECL.  */\n+\t     int)\t\t\t\t     /* Argument INDEX.  */\n+\n+/* Return a lambda expr that constructs an instance of CLOSURE_TYPE.\n+   Only lambda exprs without any captures can be correctly created\n+   through these mechanisms; that's all we need to support lambdas\n+   expressions in default parameters, the only kind that may have to\n+   be introduced through this interface.  */\n+\n+GCC_METHOD1 (gcc_expr, build_lambda_expr,\n+\t     gcc_type)\t\t\t      /* Argument CLOSURE_TYPE.  */\n+\n+/* Return an integer type with the given properties.  If BUILTIN_NAME\n+   is non-NULL, it must name a builtin integral type with the given\n+   signedness and size, and that is the type that will be returned.  */\n+\n+GCC_METHOD3 (gcc_type, get_int_type,\n+\t     int /* bool */,\t\t   /* Argument IS_UNSIGNED.  */\n+\t     unsigned long,                /* Argument SIZE_IN_BYTES.  */\n+\t     const char *)\t\t   /* Argument BUILTIN_NAME.  */\n+\n+/* Return the 'char' type, a distinct type from both 'signed char' and\n+   'unsigned char' returned by int_type.  */\n+\n+GCC_METHOD0 (gcc_type, get_char_type)\n+\n+/* Return a floating point type with the given properties.  If BUILTIN_NAME\n+   is non-NULL, it must name a builtin integral type with the given\n+   signedness and size, and that is the type that will be returned.  */\n+\n+GCC_METHOD2 (gcc_type, get_float_type,\n+\t     unsigned long,                /* Argument SIZE_IN_BYTES.  */\n+\t     const char *)\t\t   /* Argument BUILTIN_NAME.  */\n+\n+/* Return the 'void' type.  */\n+\n+GCC_METHOD0 (gcc_type, get_void_type)\n+\n+/* Return the 'bool' type.  */\n+\n+GCC_METHOD0 (gcc_type, get_bool_type)\n+\n+/* Return the std::nullptr_t type.  */\n+\n+GCC_METHOD0 (gcc_type, get_nullptr_type)\n+\n+/* Return the nullptr constant.  */\n+\n+GCC_METHOD0 (gcc_expr, get_nullptr_constant)\n+\n+/* Create a new array type.  If NUM_ELEMENTS is -1, then the array\n+   is assumed to have an unknown length.  */\n+\n+GCC_METHOD2 (gcc_type, build_array_type,\n+\t     gcc_type,\t\t\t  /* Argument ELEMENT_TYPE.  */\n+\t     int)\t\t\t  /* Argument NUM_ELEMENTS.  */\n+\n+/* Create a new array type.  NUM_ELEMENTS is a template-dependent\n+   expression.  */\n+\n+GCC_METHOD2 (gcc_type, build_dependent_array_type,\n+\t     gcc_type,\t\t\t  /* Argument ELEMENT_TYPE.  */\n+\t     gcc_expr)\t\t\t  /* Argument NUM_ELEMENTS.  */\n+\n+/* Create a new variably-sized array type.  UPPER_BOUND_NAME is the\n+   name of a local variable that holds the upper bound of the array;\n+   it is one less than the array size.  */\n+\n+GCC_METHOD2 (gcc_type, build_vla_array_type,\n+\t     gcc_type,\t\t\t  /* Argument ELEMENT_TYPE.  */\n+\t     const char *)\t\t  /* Argument UPPER_BOUND_NAME.  */\n+\n+/* Return a qualified variant of a given base type.  QUALIFIERS says\n+   which qualifiers to use; it is composed of or'd together\n+   constants from 'enum gcc_cp_qualifiers'.  */\n+\n+GCC_METHOD2 (gcc_type, build_qualified_type,\n+\t     gcc_type,\t\t\t      /* Argument UNQUALIFIED_TYPE.  */\n+\t     enum gcc_cp_qualifiers)\t      /* Argument QUALIFIERS.  */\n+\n+/* Build a complex type given its element type.  */\n+\n+GCC_METHOD1 (gcc_type, build_complex_type,\n+\t     gcc_type)\t\t\t  /* Argument ELEMENT_TYPE.  */\n+\n+/* Build a vector type given its element type and number of\n+   elements.  */\n+\n+GCC_METHOD2 (gcc_type, build_vector_type,\n+\t     gcc_type,\t\t\t  /* Argument ELEMENT_TYPE.  */\n+\t     int)\t\t\t  /* Argument NUM_ELEMENTS.  */\n+\n+/* Build a constant.  NAME is the constant's name and VALUE is its\n+   value.  FILENAME and LINE_NUMBER refer to the type's source\n+   location.  If this is not known, FILENAME can be NULL and\n+   LINE_NUMBER can be 0.  */\n+\n+GCC_METHOD5 (int /* bool */, build_constant,\n+\t     gcc_type,\t\t  /* Argument TYPE.  */\n+\t     const char *,\t  /* Argument NAME.  */\n+\t     unsigned long,\t  /* Argument VALUE.  */\n+\t     const char *,\t  /* Argument FILENAME.  */\n+\t     unsigned int)\t  /* Argument LINE_NUMBER.  */\n+\n+/* Emit an error and return an error type object.  */\n+\n+GCC_METHOD1 (gcc_type, error,\n+\t     const char *)\t\t /* Argument MESSAGE.  */\n+\n+/* Declare a static_assert with the given CONDITION and ERRORMSG at\n+   FILENAME:LINE_NUMBER.  */\n+\n+GCC_METHOD4 (int /* bool */, add_static_assert,\n+\t     gcc_expr,     /* Argument CONDITION.  */\n+\t     const char *, /* Argument ERRORMSG.  */\n+\t     const char *, /* Argument FILENAME.  */\n+\t     unsigned int) /* Argument LINE_NUMBER.  */\n+\n+#if 0\n+\n+/* FIXME: We don't want to expose the internal implementation detail\n+   that default parms are stored in function types, and it's not clear\n+   how this or other approaches would interact with the type sharing\n+   of e.g. ctor clones, so we're leaving this out, since default args\n+   are not even present in debug information anyway.  Besides, the set\n+   of default args for a function may grow within its scope, and vary\n+   independently in other scopes.  */\n+\n+/* Create a modified version of a function type that has default\n+   values for some of its arguments.  The returned type should ONLY be\n+   used to define functions or methods, never to declare parameters,\n+   variables, types or the like.\n+\n+   DEFAULTS must have at most as many N_ELEMENTS as there are\n+   arguments without default values in FUNCTION_TYPE.  Say, if\n+   FUNCTION_TYPE has an argument list such as (T1, T2, T3, T4 = V0)\n+   and DEFAULTS has 2 elements (V1, V2), the returned type will have\n+   the following argument list: (T1, T2 = V1, T3 = V2, T4 = V0).\n+\n+   Any NULL expressions in DEFAULTS will be marked as deferred, and\n+   they should be filled in with set_deferred_function_default_args.  */\n+\n+GCC_METHOD2 (gcc_type, add_function_default_args,\n+\t     gcc_type,\t\t\t     /* Argument FUNCTION_TYPE.  */\n+\t     const struct gcc_cp_function_args *) /* Argument DEFAULTS.  */\n+\n+/* Fill in the first deferred default args in FUNCTION_DECL with the\n+   expressions given in DEFAULTS.  This can be used when the\n+   declaration of a parameter is needed to create a default\n+   expression, such as taking the size of an earlier parameter, or\n+   building a lambda expression in the parameter's context.  */\n+\n+GCC_METHOD2 (int /* bool */, set_deferred_function_default_args,\n+\t     gcc_decl,\t\t\t     /* Argument FUNCTION_DECL.  */\n+\t     const struct gcc_cp_function_args *) /* Argument DEFAULTS.  */\n+\n+#endif\n+\n+\n+/* When you add entry points, add them at the end, so that the new API\n+   version remains compatible with the old version.\n+\n+   The following conventions have been observed as to naming entry points:\n+\n+   - build_* creates (and maybe records) something and returns it;\n+   - add_* creates and records something, but doesn't return it;\n+   - get_* obtains something without creating it;\n+   - start_* marks the beginning of a compound (type, list, ...);\n+   - finish_* completes the compound when needed.\n+\n+  Entry points that return an int (bool) and don't have a return value\n+  specification return nonzero (true) on success and zero (false) on\n+  failure.  This is in line with libcc1's conventions of returning a\n+  zero-initialized value in case of e.g. a transport error.  */"}, {"sha": "6ef9e22f50c9829529f521969d5ffbc75447d5e8", "filename": "include/gcc-cp-interface.h", "status": "added", "additions": 496, "deletions": 0, "changes": 496, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-cp-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-cp-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgcc-cp-interface.h?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,496 @@\n+/* Interface between GCC C++ FE and GDB\n+\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+   This file is part of GCC.\n+\n+   This program is free software; you can redistribute it and/or modify\n+   it under the terms of the GNU General Public License as published by\n+   the Free Software Foundation; either version 3 of the License, or\n+   (at your option) any later version.\n+\n+   This program is distributed in the hope that it will be useful,\n+   but WITHOUT ANY WARRANTY; without even the implied warranty of\n+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n+   GNU General Public License for more details.\n+\n+   You should have received a copy of the GNU General Public License\n+   along with this program.  If not, see <http://www.gnu.org/licenses/>.  */\n+\n+#ifndef GCC_CP_INTERFACE_H\n+#define GCC_CP_INTERFACE_H\n+\n+#include \"gcc-interface.h\"\n+\n+/* This header defines the interface to the GCC API.  It must be both\n+   valid C and valid C++, because it is included by both programs.  */\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* Forward declaration.  */\n+\n+struct gcc_cp_context;\n+\n+/*\n+ * Definitions and declarations for the C++ front end.\n+ */\n+\n+/* Defined versions of the C++ front-end API.  */\n+\n+enum gcc_cp_api_version\n+{\n+  GCC_CP_FE_VERSION_0 = 0\n+};\n+\n+/* Qualifiers.  */\n+\n+enum gcc_cp_qualifiers\n+{\n+  GCC_CP_QUALIFIER_CONST = 1,\n+  GCC_CP_QUALIFIER_VOLATILE = 2,\n+  GCC_CP_QUALIFIER_RESTRICT = 4\n+};\n+\n+/* Ref qualifiers.  */\n+\n+enum gcc_cp_ref_qualifiers {\n+  GCC_CP_REF_QUAL_NONE = 0,\n+  GCC_CP_REF_QUAL_LVALUE = 1,\n+  GCC_CP_REF_QUAL_RVALUE = 2\n+};\n+\n+/* Opaque typedef for unbound class templates.  They are used for\n+   template arguments, and defaults for template template\n+   parameters.  */\n+\n+typedef unsigned long long gcc_utempl;\n+\n+/* Opaque typedef for expressions.  They are used for template\n+   arguments, defaults for non-type template parameters, and defaults\n+   for function arguments.  */\n+\n+typedef unsigned long long gcc_expr;\n+\n+typedef enum\n+  { GCC_CP_TPARG_VALUE, GCC_CP_TPARG_CLASS,\n+    GCC_CP_TPARG_TEMPL, GCC_CP_TPARG_PACK }\n+gcc_cp_template_arg_kind;\n+\n+typedef union\n+{ gcc_expr value; gcc_type type; gcc_utempl templ; gcc_type pack; }\n+gcc_cp_template_arg;\n+\n+/* An array of template arguments.  */\n+\n+struct gcc_cp_template_args\n+{\n+  /* Number of elements.  */\n+\n+  int n_elements;\n+\n+  /* kind[i] indicates what kind of template argument type[i] is.  */\n+\n+  char /* gcc_cp_template_arg_kind */ *kinds;\n+\n+  /* The template arguments.  */\n+\n+  gcc_cp_template_arg *elements;\n+};\n+\n+/* An array of (default) function arguments.  */\n+\n+struct gcc_cp_function_args\n+{\n+  /* Number of elements.  */\n+\n+  int n_elements;\n+\n+  /* The (default) values for each argument.  */\n+\n+  gcc_expr *elements;\n+};\n+\n+/* This enumerates the kinds of decls that GDB can create.  */\n+\n+enum gcc_cp_symbol_kind\n+{\n+  /* A function.  */\n+\n+  GCC_CP_SYMBOL_FUNCTION,\n+\n+  /* A variable.  */\n+\n+  GCC_CP_SYMBOL_VARIABLE,\n+\n+  /* A typedef, or an alias declaration (including template ones).  */\n+\n+  GCC_CP_SYMBOL_TYPEDEF,\n+\n+  /* A label.  */\n+\n+  GCC_CP_SYMBOL_LABEL,\n+\n+  /* A class, forward declared in build_decl (to be later defined in\n+     start_class_definition), or, in a template parameter list scope,\n+     a declaration of a template class, closing the parameter\n+     list.  */\n+\n+  GCC_CP_SYMBOL_CLASS,\n+\n+  /* A union, forward declared in build_decl (to be later defined in\n+     start_class_definition).  */\n+\n+  GCC_CP_SYMBOL_UNION,\n+\n+  /* An enumeration type being introduced with start_new_enum_type.  */\n+\n+  GCC_CP_SYMBOL_ENUM,\n+\n+  /* A nonstatic data member being introduced with new_field.  */\n+\n+  GCC_CP_SYMBOL_FIELD,\n+\n+  /* A base class in a gcc_vbase_array.  */\n+\n+  GCC_CP_SYMBOL_BASECLASS,\n+\n+  /* A using declaration in new_using_decl.  */\n+\n+  GCC_CP_SYMBOL_USING,\n+\n+  /* A (lambda) closure class type.  In many regards this is just like\n+     a regular class, but it's not supposed to have base classes, some\n+     of the member functions that are usually implicitly-defined are\n+     deleted, and it should have an operator() member function that\n+     holds the lambda body.  We can't instantiate objects of lambda\n+     types from the snippet, but we can interact with them in such\n+     ways as passing them to functions that take their types, and\n+     calling their body.  */\n+\n+  GCC_CP_SYMBOL_LAMBDA_CLOSURE,\n+\n+  /* Marker to check that we haven't exceeded GCC_CP_SYMBOL_MASK.  */\n+  GCC_CP_SYMBOL_END,\n+\n+  GCC_CP_SYMBOL_MASK = 15,\n+\n+  /* When defining a class member, at least one of the\n+     GCC_CP_ACCESS_MASK bits must be set; when defining a namespace-\n+     or union-scoped symbol, none of them must be set.  */\n+\n+  GCC_CP_ACCESS_PRIVATE,\n+  GCC_CP_ACCESS_PUBLIC = GCC_CP_ACCESS_PRIVATE << 1,\n+  GCC_CP_ACCESS_MASK = (GCC_CP_ACCESS_PUBLIC\n+\t\t\t       | GCC_CP_ACCESS_PRIVATE),\n+  GCC_CP_ACCESS_PROTECTED = GCC_CP_ACCESS_MASK,\n+  GCC_CP_ACCESS_NONE = 0,\n+\n+  GCC_CP_FLAG_BASE = GCC_CP_ACCESS_PRIVATE << 2,\n+\n+  /* Flags to be used along with GCC_CP_SYMBOL_FUNCTION:  */\n+\n+  /* This flag should be set for constructors, destructors and\n+     operators.  */\n+  GCC_CP_FLAG_SPECIAL_FUNCTION = GCC_CP_FLAG_BASE,\n+\n+  /* We intentionally cannot express inline, constexpr, or virtual\n+     override for functions.  We can't inline or constexpr-replace\n+     without a source-level body.  The override keyword is only\n+     meaningful within the definition of the containing class.  */\n+\n+  /* This indicates a \"virtual\" member function, explicitly or\n+     implicitly (due to a virtual function with the same name and\n+     prototype in a base class) declared as such.  */\n+  GCC_CP_FLAG_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 1,\n+\n+  /* The following two flags should only be set when the flag above is\n+     set.  */\n+\n+  /* This indicates a pure virtual member function, i.e., one that is\n+     declared with \"= 0\", even if a body is provided in the\n+     definition.  */\n+  GCC_CP_FLAG_PURE_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 2,\n+\n+  /* This indicates a \"final\" virtual member function.  */\n+  GCC_CP_FLAG_FINAL_VIRTUAL_FUNCTION = GCC_CP_FLAG_BASE << 3,\n+\n+  /* This indicates a special member function should have its default\n+     implementation.  This either means the function declaration\n+     contains the \"= default\" tokens, or that the member function was\n+     implicitly generated by the compiler, although the latter use is\n+     discouraged: just let the compiler implicitly introduce it.\n+\n+     A member function defaulted after its first declaration has\n+     slightly different ABI implications from one implicitly generated\n+     or explicitly defaulted at the declaration (and definition)\n+     point.  To avoid silent (possibly harmless) violation of the one\n+     definition rule, it is recommended that this flag not be used for\n+     such functions, and that the address of the definition be\n+     supplied instead.  */\n+  GCC_CP_FLAG_DEFAULTED_FUNCTION = GCC_CP_FLAG_BASE << 4,\n+\n+  /* This indicates a deleted member function, i.e., one that has been\n+     defined as \"= delete\" at its declaration point, or one that has\n+     been implicitly defined as deleted (with or without an explicit\n+     \"= default\" definition).\n+\n+     This should not be used for implicitly-declared member functions\n+     that resolve to deleted definitions, as it may affect the\n+     implicit declaration of other member functions.  */\n+  GCC_CP_FLAG_DELETED_FUNCTION = GCC_CP_FLAG_BASE << 5,\n+\n+  /* This indicates a constructor or type-conversion operator declared\n+     as \"explicit\".  */\n+\n+  GCC_CP_FLAG_EXPLICIT_FUNCTION = GCC_CP_FLAG_BASE << 6,\n+\n+  GCC_CP_FLAG_END_FUNCTION,\n+  GCC_CP_FLAG_MASK_FUNCTION = (((GCC_CP_FLAG_END_FUNCTION - 1) << 1)\n+\t\t\t       - GCC_CP_FLAG_BASE),\n+\n+  /* Flags to be used along with GCC_CP_SYMBOL_VARIABLE:  */\n+\n+  /* This indicates a variable declared as \"constexpr\".  */\n+\n+  GCC_CP_FLAG_CONSTEXPR_VARIABLE = GCC_CP_FLAG_BASE,\n+\n+  /* This indicates a variable declared as \"thread_local\".  ??? What\n+     should the ADDRESS be?  */\n+\n+  GCC_CP_FLAG_THREAD_LOCAL_VARIABLE = GCC_CP_FLAG_BASE << 1,\n+\n+  GCC_CP_FLAG_END_VARIABLE,\n+  GCC_CP_FLAG_MASK_VARIABLE = (((GCC_CP_FLAG_END_VARIABLE - 1) << 1)\n+\t\t\t       - GCC_CP_FLAG_BASE),\n+\n+  /* Flags to be used when defining nonstatic data members of classes\n+     with new_field.  */\n+\n+  /* Use this when no flags are present.  */\n+  GCC_CP_FLAG_FIELD_NOFLAG = 0,\n+\n+  /* This indicates the field is declared as mutable.  */\n+  GCC_CP_FLAG_FIELD_MUTABLE = GCC_CP_FLAG_BASE,\n+\n+  GCC_CP_FLAG_END_FIELD,\n+  GCC_CP_FLAG_MASK_FIELD = (((GCC_CP_FLAG_END_FIELD - 1) << 1)\n+\t\t\t    - GCC_CP_FLAG_BASE),\n+\n+  /* Flags to be used when defining an enum with\n+     start_new_enum_type.  */\n+\n+  /* This indicates an enum type without any flags.  */\n+  GCC_CP_FLAG_ENUM_NOFLAG = 0,\n+\n+  /* This indicates a scoped enum type.  */\n+  GCC_CP_FLAG_ENUM_SCOPED = GCC_CP_FLAG_BASE,\n+\n+  GCC_CP_FLAG_END_ENUM,\n+  GCC_CP_FLAG_MASK_ENUM = (((GCC_CP_FLAG_END_ENUM - 1) << 1)\n+\t\t\t       - GCC_CP_FLAG_BASE),\n+\n+\n+  /* Flags to be used when introducing a class or a class template\n+     with build_decl.  */\n+\n+  /* This indicates an enum type without any flags.  */\n+  GCC_CP_FLAG_CLASS_NOFLAG = 0,\n+\n+  /* This indicates the class is actually a struct.  This has no\n+     effect whatsoever on access control in this interface, since all\n+     class members must have explicit access control bits set, but it\n+     may affect error messages.  */\n+  GCC_CP_FLAG_CLASS_IS_STRUCT = GCC_CP_FLAG_BASE,\n+\n+  GCC_CP_FLAG_END_CLASS,\n+  GCC_CP_FLAG_MASK_CLASS = (((GCC_CP_FLAG_END_CLASS - 1) << 1)\n+\t\t\t       - GCC_CP_FLAG_BASE),\n+\n+\n+  /* Flags to be used when introducing a virtual base class in a\n+     gcc_vbase_array.  */\n+\n+  /* This indicates an enum type without any flags.  */\n+  GCC_CP_FLAG_BASECLASS_NOFLAG = 0,\n+\n+  /* This indicates the class is actually a struct.  This has no\n+     effect whatsoever on access control in this interface, since all\n+     class members must have explicit access control bits set, but it\n+     may affect error messages.  */\n+  GCC_CP_FLAG_BASECLASS_VIRTUAL = GCC_CP_FLAG_BASE,\n+\n+  GCC_CP_FLAG_END_BASECLASS,\n+  GCC_CP_FLAG_MASK_BASECLASS = (((GCC_CP_FLAG_END_BASECLASS - 1) << 1)\n+\t\t\t\t- GCC_CP_FLAG_BASE),\n+\n+\n+  GCC_CP_FLAG_MASK = (GCC_CP_FLAG_MASK_FUNCTION\n+\t\t      | GCC_CP_FLAG_MASK_VARIABLE\n+\t\t      | GCC_CP_FLAG_MASK_FIELD\n+\t\t      | GCC_CP_FLAG_MASK_ENUM\n+\t\t      | GCC_CP_FLAG_MASK_CLASS\n+\t\t      | GCC_CP_FLAG_MASK_BASECLASS\n+\t\t      )\n+};\n+\n+\n+/* An array of types used for creating lists of base classes.  */\n+\n+struct gcc_vbase_array\n+{\n+  /* Number of elements.  */\n+\n+  int n_elements;\n+\n+  /* The base classes.  */\n+\n+  gcc_type *elements;\n+\n+  /* Flags for each base class.  Used to indicate access control and\n+     virtualness.  */\n+\n+  enum gcc_cp_symbol_kind *flags;\n+};\n+\n+\n+/* This enumerates the types of symbols that GCC might request from\n+   GDB.  */\n+\n+enum gcc_cp_oracle_request\n+{\n+  /* An identifier in namespace scope -- type, variable, function,\n+     namespace, template.  All namespace-scoped symbols with the\n+     requested name, in any namespace (including the global\n+     namespace), should be defined in response to this request.  */\n+\n+  GCC_CP_ORACLE_IDENTIFIER\n+};\n+\n+/* The type of the function called by GCC to ask GDB for a symbol's\n+   definition.  DATUM is an arbitrary value supplied when the oracle\n+   function is registered.  CONTEXT is the GCC context in which the\n+   request is being made.  REQUEST specifies what sort of symbol is\n+   being requested, and IDENTIFIER is the name of the symbol.  */\n+\n+typedef void gcc_cp_oracle_function (void *datum,\n+\t\t\t\t     struct gcc_cp_context *context,\n+\t\t\t\t     enum gcc_cp_oracle_request request,\n+\t\t\t\t     const char *identifier);\n+\n+/* The type of the function called by GCC to ask GDB for a symbol's\n+   address.  This should return 0 if the address is not known.  */\n+\n+typedef gcc_address gcc_cp_symbol_address_function (void *datum,\n+\t\t\t\t\t\t    struct gcc_cp_context *ctxt,\n+\t\t\t\t\t\t    const char *identifier);\n+\n+/* The type of the function called by GCC to ask GDB to enter or leave\n+   the user expression scope.  */\n+\n+typedef void gcc_cp_enter_leave_user_expr_scope_function (void *datum,\n+\t\t\t\t\t\t\t  struct gcc_cp_context\n+\t\t\t\t\t\t\t  *context);\n+\n+/* The vtable used by the C front end.  */\n+\n+struct gcc_cp_fe_vtable\n+{\n+  /* The version of the C interface.  The value is one of the\n+     gcc_cp_api_version constants.  */\n+\n+  unsigned int cp_version;\n+\n+  /* Set the callbacks for this context.\n+\n+     The binding oracle is called whenever the C++ parser needs to\n+     look up a symbol.  This gives the caller a chance to lazily\n+     instantiate symbols using other parts of the gcc_cp_fe_interface\n+     API.  The symbol is looked up without a scope, and the oracle\n+     must supply a definition for ALL namespace-scoped definitions\n+     bound to the symbol.\n+\n+     The address oracle is called whenever the C++ parser needs to\n+     look up a symbol.  This may be called for symbols not provided by\n+     the symbol oracle, such as built-in functions where GCC provides\n+     the declaration; other internal symbols, such as those related\n+     with thunks, rtti, and virtual tables are likely to be queried\n+     through this interface too.  The identifier is a mangled symbol\n+     name.\n+\n+     DATUM is an arbitrary piece of data that is passed back verbatim\n+     to the callbacks in requests.  */\n+\n+  void (*set_callbacks) (struct gcc_cp_context *self,\n+\t\t\t gcc_cp_oracle_function *binding_oracle,\n+\t\t\t gcc_cp_symbol_address_function *address_oracle,\n+\t\t\t gcc_cp_enter_leave_user_expr_scope_function *enter_scope,\n+\t\t\t gcc_cp_enter_leave_user_expr_scope_function *leave_scope,\n+\t\t\t void *datum);\n+\n+#define GCC_METHOD0(R, N) \\\n+  R (*N) (struct gcc_cp_context *);\n+#define GCC_METHOD1(R, N, A) \\\n+  R (*N) (struct gcc_cp_context *, A);\n+#define GCC_METHOD2(R, N, A, B) \\\n+  R (*N) (struct gcc_cp_context *, A, B);\n+#define GCC_METHOD3(R, N, A, B, C) \\\n+  R (*N) (struct gcc_cp_context *, A, B, C);\n+#define GCC_METHOD4(R, N, A, B, C, D) \\\n+  R (*N) (struct gcc_cp_context *, A, B, C, D);\n+#define GCC_METHOD5(R, N, A, B, C, D, E) \\\n+  R (*N) (struct gcc_cp_context *, A, B, C, D, E);\n+#define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n+  R (*N) (struct gcc_cp_context *, A, B, C, D, E, F, G);\n+\n+#include \"gcc-cp-fe.def\"\n+\n+#undef GCC_METHOD0\n+#undef GCC_METHOD1\n+#undef GCC_METHOD2\n+#undef GCC_METHOD3\n+#undef GCC_METHOD4\n+#undef GCC_METHOD5\n+#undef GCC_METHOD7\n+\n+};\n+\n+/* The C front end object.  */\n+\n+struct gcc_cp_context\n+{\n+  /* Base class.  */\n+\n+  struct gcc_base_context base;\n+\n+  /* Our vtable.  This is a separate field because this is simpler\n+     than implementing a vtable inheritance scheme in C.  */\n+\n+  const struct gcc_cp_fe_vtable *cp_ops;\n+};\n+\n+/* The name of the .so that the compiler builds.  We dlopen this\n+   later.  */\n+\n+#define GCC_CP_FE_LIBCC libcc1.so\n+\n+/* The compiler exports a single initialization function.  This macro\n+   holds its name as a symbol.  */\n+\n+#define GCC_CP_FE_CONTEXT gcc_cp_fe_context\n+\n+/* The type of the initialization function.  The caller passes in the\n+   desired base version and desired C-specific version.  If the\n+   request can be satisfied, a compatible gcc_context object will be\n+   returned.  Otherwise, the function returns NULL.  */\n+\n+typedef struct gcc_cp_context *gcc_cp_fe_context_function\n+    (enum gcc_base_api_version,\n+     enum gcc_cp_api_version);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* GCC_CP_INTERFACE_H */"}, {"sha": "1dc3498e877b765e9e94862ce6bc14e407d81b99", "filename": "include/gcc-interface.h", "status": "modified", "additions": 14, "deletions": 0, "changes": 14, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-interface.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/include%2Fgcc-interface.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/include%2Fgcc-interface.h?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -169,6 +169,20 @@ struct gcc_base_context\n   const struct gcc_base_vtable *ops;\n };\n \n+/* An array of types used for creating function types in multiple\n+   languages.  */\n+\n+struct gcc_type_array\n+{\n+  /* Number of elements.  */\n+\n+  int n_elements;\n+\n+  /* The elements.  */\n+\n+  gcc_type *elements;\n+};\n+\n /* The name of the dummy wrapper function generated by gdb.  */\n \n #define GCC_FE_WRAPPER_FUNCTION \"_gdb_expr\""}, {"sha": "5db05c58ba720d54d4896d4d3bf7a0553e70844a", "filename": "libcc1/ChangeLog", "status": "modified", "additions": 79, "deletions": 0, "changes": 79, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FChangeLog?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -1,3 +1,82 @@\n+2017-01-30  Alexandre Oliva <aoliva@redhat.com>\n+\n+\tIntroduce C++ support.\n+\t* Makefile.am (AM_CPPFLAGS): Move some -I flags to...\n+\t(CPPFLAGS_FOR_C_FAMILY, CPPFLAGS_FOR_C, CPPFLAGS_FOR_CXX): ...\n+\tnew macros.\n+\t(plugin_LTLIBRARIES): Add libcp1plugin.la.\n+\t(BUILT_SOURCES, MOSTLYCLEANFILES): Add...\n+\t(cp-compiler-name.h): ... this.  New.\n+\t(c-compiler-name.h): Rename all over from...\n+\t(compiler-name.h): ... this.  Create it atomically.\n+\t(marshall_c_source, marshall_cxx_source): New macros.\n+\t(libcc1plugin_la_SOURCES): Rename plugin.cc to libcc1plugin.cc.\n+\tAdd marshall_c_source expansion.\n+\t(libcc1plugin.lo_CPPFLAGS): New macro.\n+\t(libcp1plugin_la_LDFLAGS): Likewise.\n+\t(libcp1plugin_la_SOURCES): Likewise.\n+\t(libcp1plugin.lo_CPPFLAGS): Likewise.\n+\t(libcp1plugin_la_LIBADD): Likewise.\n+\t(libcp1plugin_la_DEPENDENCIES): Likewise.\n+\t(libcp1plugin_la_LINK): Likewise.\n+\t(libcc1_la_SOURCES): Added marshall_c_source and\n+\tmarshall_cxx_source expansions.\n+\t* Makefile.in: Rebuild.\n+\t* compiler-name.h: Rename all over to...\n+\t* c-compiler-name.h: ... this.  Define C_COMPILER_NAME instead\n+\tof COMPILER_NAME.\n+\t* plugin.cc: Rename all over to...\n+\t* libcc1plugin.cc: ... this.  Include marshall-c.hh.\n+\t(address_rewriter): Drop cleaning up of VLA sizes.\n+\t(plugin_build_decl): Mark decls as external.\n+\t(plugin_tagbind): Propagate name to all variants.\n+\t(build_anonymous_node): New.\n+\t(plugin_build_record_type): Use it instead of make_node.\n+\t(plugin_build_union_type): Likewise.\n+\t(plugin_build_enum_type): Likewise.\n+\t(plugin_finish_record_or_union): Update all type variants.\n+\t(safe_lookup_builtin_type): New.\n+\t(plugin_int_check): Factor out of, and add checks to, ...\n+\t(plugin_int_type): ... this.  Rename to...\n+\t(plugin_int_type_v0): ... this.\n+\t(plugin_int_type): New interface, new implementation.\n+\t(plugin_char_type): New.\n+\t(plugin_float_type_v0): Rename from...\n+\t(plugin_float_type): ... this.  New interface, new implementation.\n+\t(plugin_init): Bump handshake version.\n+\t* libcc1.cc: Include marshall-c.hh.  Drop gcc-interface.h.\n+\t(call_binding_oracle): Rename to...\n+\t(c_call_binding_oracle): ... this, into anonymous namespace.\n+\t(call_symbol_address): Rename to...\n+\t(c_call_symbol_address): ... this, likewise.\n+\t(GCC_METHOD#): Move methods into cc1plugin::c:: namespace.\n+\t(libcc1::compiler::find): Refer to C_COMPILER_NAME.\n+\t(fork_exec): Bump to GCC_C_FE_VERSION_1.\n+\t(libcc1_compile): Prefix callbacks with c_.\n+\t(gcc_c_fe_context): Accept GCC_C_FE_VERSION_1.\n+\t* libcc1.sym: Export gcc_cp_fe_context.\n+\t* libcp1.cc: New, mostly copied and adjusted from libcc1.cc.\n+\t* libcp1plugin.cc: New, initially copied from libcc1plugin.cc.\n+\t* libcp1plugin.sym: New.\n+\t* marshall-c.hh: New.  Move C-specific types from...\n+\t* marshall.cc: ... this.\n+\t(cc1_plugin::marshall_array_start): New.\n+\t(cc1_plugin::marshall_array_elmts): New.\n+\t(cc1_plugin::marshall for gcc_type_array): Use the above.\n+\t(cc1_plugin::unmarshall_array_start): New.\n+\t(cc1_plugin::unmarshall_array_elmts): New.\n+\t(cc1_plugin::unmarshall for gcc_type_array): Use the above.\n+\t* marshall.hh: Declare the new array building blocks.\n+\tDrop C-specific unmarshall declarations.\n+\t* marshall-cp.hh: New.\n+\t* names.cc (GCC_METHOD#): Add LANG:: to method names.\n+\t(LANG): Define while including gcc-c-fe.def and gcc-cp-fe.def.\n+\t* names.hh: Include gcc-c-fe.def and gcc-cp-fe.def in the\n+\tcorresponding namespaces.\n+\t* rpc.hh: Don't include marshall.hh.\n+\t[GCC_CP_INTERFACE_H] (argument_wrapper): Specialize for\n+\tgcc_vbase_array, gcc_cp_template_args, gcc_cp_function_args.\n+\n 2017-01-30  Jan Kratochvil <jan.kratochvil@redhat.com>\n \n \t* findcomp.cc: Include system.h."}, {"sha": "5e61a92a26b05ed756a44c74262b843e01a3c045", "filename": "libcc1/Makefile.am", "status": "modified", "additions": 36, "deletions": 10, "changes": 46, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FMakefile.am", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FMakefile.am", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FMakefile.am?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -19,9 +19,11 @@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n gcc_build_dir = ../gcc\n AM_CPPFLAGS = -I $(srcdir)/../include -I $(srcdir)/../libgcc \\\n-\t-I $(gcc_build_dir) -I$(srcdir)/../gcc \\\n-\t-I $(srcdir)/../gcc/c -I $(srcdir)/../gcc/c-family \\\n-\t-I $(srcdir)/../libcpp/include $(GMPINC)\n+\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC)\n+CPPFLAGS_FOR_C_FAMILY = -I $(srcdir)/../gcc/c-family \\\n+\t-I $(srcdir)/../libcpp/include\n+CPPFLAGS_FOR_C = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/c\n+CPPFLAGS_FOR_CXX = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/cp\n AM_CXXFLAGS = $(WARN_FLAGS) $(WERROR) $(visibility)\n override CXXFLAGS := $(filter-out -fsanitize=address,$(CXXFLAGS))\n override LDFLAGS := $(filter-out -fsanitize=address,$(LDFLAGS))\n@@ -39,33 +41,57 @@ plugindir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/plugin\n cc1libdir = $(libdir)/$(libsuffix)\n \n if ENABLE_PLUGIN\n-plugin_LTLIBRARIES = libcc1plugin.la\n+plugin_LTLIBRARIES = libcc1plugin.la libcp1plugin.la\n cc1lib_LTLIBRARIES = libcc1.la\n endif\n \n-BUILT_SOURCES = compiler-name.h\n-MOSTLYCLEANFILES = compiler-name.h\n+BUILT_SOURCES = c-compiler-name.h cp-compiler-name.h\n+MOSTLYCLEANFILES = c-compiler-name.h cp-compiler-name.h\n \n # Put this in a header so we don't run sed for each compilation.  This\n # is also simpler to debug as one can easily see the constant.\n-compiler-name.h: Makefile\n-\techo \"#define COMPILER_NAME \\\"`echo gcc | sed '$(transform)'`\\\"\" > $@\n+# FIXME: compute it in configure.ac and output it in config.status, or\n+# introduce timestamp files for some indirection to avoid rebuilding it\n+# every time.\n+c-compiler-name.h: Makefile\n+\t-rm -f $@T\n+\techo \"#define C_COMPILER_NAME \\\"`echo gcc | sed '$(transform)'`\\\"\" > $@T\n+\tmv $@T $@ # $(SHELL) $(srcdir)/../move-if-change $@T $@\n \n+cp-compiler-name.h: Makefile\n+\t-rm -f $@T\n+\techo \"#define CP_COMPILER_NAME \\\"`echo g++ | sed '$(transform)'`\\\"\" > $@T\n+\tmv $@T $@ # $(SHELL) $(srcdir)/../move-if-change $@T $@\n \n shared_source = callbacks.cc callbacks.hh connection.cc connection.hh \\\n     marshall.cc marshall.hh rpc.hh status.hh\n \n+marshall_c_source = marshall-c.hh\n+marshall_cxx_source = marshall-cp.hh\n+\n libcc1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1plugin.sym\n-libcc1plugin_la_SOURCES = plugin.cc $(shared_source)\n+libcc1plugin_la_SOURCES = libcc1plugin.cc $(shared_source) $(marshall_c_source)\n+libcc1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_C)\n libcc1plugin_la_LIBADD = $(libiberty)\n libcc1plugin_la_DEPENDENCIES = $(libiberty_dep)\n libcc1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n \t$(CXXFLAGS) $(libcc1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n \n+libcp1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcp1plugin.sym\n+libcp1plugin_la_SOURCES = libcp1plugin.cc $(shared_source) $(marshall_cxx_source)\n+libcp1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_CXX)\n+libcp1plugin_la_LIBADD = $(libiberty)\n+libcp1plugin_la_DEPENDENCIES = $(libiberty_dep)\n+libcp1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libcp1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n+\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n libcc1_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1.sym\n-libcc1_la_SOURCES = findcomp.cc libcc1.cc names.cc names.hh $(shared_source)\n+libcc1_la_SOURCES = findcomp.cc libcc1.cc libcp1.cc \\\n+\t\tnames.cc names.hh $(shared_source) \\\n+\t\t$(marshall_c_source) $(marshall_cxx_source)\n libcc1_la_LIBADD = $(libiberty)\n libcc1_la_DEPENDENCIES = $(libiberty_dep)\n libcc1_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\"}, {"sha": "54babb02a49c7c24ba18c5b9e623b428aef59620", "filename": "libcc1/Makefile.in", "status": "modified", "additions": 54, "deletions": 14, "changes": 68, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FMakefile.in", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2FMakefile.in", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2FMakefile.in?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -105,12 +105,19 @@ am__uninstall_files_from_dir = { \\\n am__installdirs = \"$(DESTDIR)$(cc1libdir)\" \"$(DESTDIR)$(plugindir)\"\n LTLIBRARIES = $(cc1lib_LTLIBRARIES) $(plugin_LTLIBRARIES)\n am__objects_1 = callbacks.lo connection.lo marshall.lo\n-am_libcc1_la_OBJECTS = findcomp.lo libcc1.lo names.lo $(am__objects_1)\n+am__objects_2 =\n+am_libcc1_la_OBJECTS = findcomp.lo libcc1.lo libcp1.lo names.lo \\\n+\t$(am__objects_1) $(am__objects_2) $(am__objects_2)\n libcc1_la_OBJECTS = $(am_libcc1_la_OBJECTS)\n @ENABLE_PLUGIN_TRUE@am_libcc1_la_rpath = -rpath $(cc1libdir)\n-am_libcc1plugin_la_OBJECTS = plugin.lo $(am__objects_1)\n+am_libcc1plugin_la_OBJECTS = libcc1plugin.lo $(am__objects_1) \\\n+\t$(am__objects_2)\n libcc1plugin_la_OBJECTS = $(am_libcc1plugin_la_OBJECTS)\n @ENABLE_PLUGIN_TRUE@am_libcc1plugin_la_rpath = -rpath $(plugindir)\n+am_libcp1plugin_la_OBJECTS = libcp1plugin.lo $(am__objects_1) \\\n+\t$(am__objects_2)\n+libcp1plugin_la_OBJECTS = $(am_libcp1plugin_la_OBJECTS)\n+@ENABLE_PLUGIN_TRUE@am_libcp1plugin_la_rpath = -rpath $(plugindir)\n DEFAULT_INCLUDES = -I.@am__isrc@\n depcomp = $(SHELL) $(top_srcdir)/../depcomp\n am__depfiles_maybe = depfiles\n@@ -133,7 +140,8 @@ CCLD = $(CC)\n LINK = $(LIBTOOL) --tag=CC $(AM_LIBTOOLFLAGS) $(LIBTOOLFLAGS) \\\n \t--mode=link $(CCLD) $(AM_CFLAGS) $(CFLAGS) $(AM_LDFLAGS) \\\n \t$(LDFLAGS) -o $@\n-SOURCES = $(libcc1_la_SOURCES) $(libcc1plugin_la_SOURCES)\n+SOURCES = $(libcc1_la_SOURCES) $(libcc1plugin_la_SOURCES) \\\n+\t$(libcp1plugin_la_SOURCES)\n am__can_run_installinfo = \\\n   case $$AM_UPDATE_INFO_DIR in \\\n     n|no|NO) false;; \\\n@@ -277,10 +285,13 @@ visibility = @visibility@\n ACLOCAL_AMFLAGS = -I .. -I ../config\n gcc_build_dir = ../gcc\n AM_CPPFLAGS = -I $(srcdir)/../include -I $(srcdir)/../libgcc \\\n-\t-I $(gcc_build_dir) -I$(srcdir)/../gcc \\\n-\t-I $(srcdir)/../gcc/c -I $(srcdir)/../gcc/c-family \\\n-\t-I $(srcdir)/../libcpp/include $(GMPINC)\n+\t-I $(gcc_build_dir) -I$(srcdir)/../gcc $($@_CPPFLAGS) $(GMPINC)\n \n+CPPFLAGS_FOR_C_FAMILY = -I $(srcdir)/../gcc/c-family \\\n+\t-I $(srcdir)/../libcpp/include\n+\n+CPPFLAGS_FOR_C = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/c\n+CPPFLAGS_FOR_CXX = $(CPPFLAGS_FOR_C_FAMILY) -I $(srcdir)/../gcc/cp\n AM_CXXFLAGS = $(WARN_FLAGS) $(WERROR) $(visibility)\n # Can be simplified when libiberty becomes a normal convenience library.\n libiberty_normal = ../libiberty/libiberty.a\n@@ -294,24 +305,39 @@ libiberty = $(if $(wildcard $(libiberty_noasan)),$(Wc)$(libiberty_noasan), \\\n libiberty_dep = $(patsubst $(Wc)%,%,$(libiberty))\n plugindir = $(libdir)/gcc/$(target_noncanonical)/$(gcc_version)/plugin\n cc1libdir = $(libdir)/$(libsuffix)\n-@ENABLE_PLUGIN_TRUE@plugin_LTLIBRARIES = libcc1plugin.la\n+@ENABLE_PLUGIN_TRUE@plugin_LTLIBRARIES = libcc1plugin.la libcp1plugin.la\n @ENABLE_PLUGIN_TRUE@cc1lib_LTLIBRARIES = libcc1.la\n-BUILT_SOURCES = compiler-name.h\n-MOSTLYCLEANFILES = compiler-name.h\n+BUILT_SOURCES = c-compiler-name.h cp-compiler-name.h\n+MOSTLYCLEANFILES = c-compiler-name.h cp-compiler-name.h\n shared_source = callbacks.cc callbacks.hh connection.cc connection.hh \\\n     marshall.cc marshall.hh rpc.hh status.hh\n \n+marshall_c_source = marshall-c.hh\n+marshall_cxx_source = marshall-cp.hh\n libcc1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1plugin.sym\n-libcc1plugin_la_SOURCES = plugin.cc $(shared_source)\n+libcc1plugin_la_SOURCES = libcc1plugin.cc $(shared_source) $(marshall_c_source)\n+libcc1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_C)\n libcc1plugin_la_LIBADD = $(libiberty)\n libcc1plugin_la_DEPENDENCIES = $(libiberty_dep)\n libcc1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n \t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n \t$(CXXFLAGS) $(libcc1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n \n+libcp1plugin_la_LDFLAGS = -module -export-symbols $(srcdir)/libcp1plugin.sym\n+libcp1plugin_la_SOURCES = libcp1plugin.cc $(shared_source) $(marshall_cxx_source)\n+libcp1plugin.lo_CPPFLAGS = $(CPPFLAGS_FOR_CXX)\n+libcp1plugin_la_LIBADD = $(libiberty)\n+libcp1plugin_la_DEPENDENCIES = $(libiberty_dep)\n+libcp1plugin_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n+\t$(LIBTOOLFLAGS) --mode=link $(CXXLD) $(AM_CXXFLAGS) \\\n+\t$(CXXFLAGS) $(libcp1plugin_la_LDFLAGS) $(LTLDFLAGS) -o $@\n+\n LTLDFLAGS = $(shell $(SHELL) $(top_srcdir)/../libtool-ldflags $(LDFLAGS))\n libcc1_la_LDFLAGS = -module -export-symbols $(srcdir)/libcc1.sym\n-libcc1_la_SOURCES = findcomp.cc libcc1.cc names.cc names.hh $(shared_source)\n+libcc1_la_SOURCES = findcomp.cc libcc1.cc libcp1.cc \\\n+\t\tnames.cc names.hh $(shared_source) \\\n+\t\t$(marshall_c_source) $(marshall_cxx_source)\n+\n libcc1_la_LIBADD = $(libiberty)\n libcc1_la_DEPENDENCIES = $(libiberty_dep)\n libcc1_la_LINK = $(LIBTOOL) --tag=CXX $(AM_LIBTOOLFLAGS) \\\n@@ -440,6 +466,8 @@ libcc1.la: $(libcc1_la_OBJECTS) $(libcc1_la_DEPENDENCIES) $(EXTRA_libcc1_la_DEPE\n \t$(libcc1_la_LINK) $(am_libcc1_la_rpath) $(libcc1_la_OBJECTS) $(libcc1_la_LIBADD) $(LIBS)\n libcc1plugin.la: $(libcc1plugin_la_OBJECTS) $(libcc1plugin_la_DEPENDENCIES) $(EXTRA_libcc1plugin_la_DEPENDENCIES) \n \t$(libcc1plugin_la_LINK) $(am_libcc1plugin_la_rpath) $(libcc1plugin_la_OBJECTS) $(libcc1plugin_la_LIBADD) $(LIBS)\n+libcp1plugin.la: $(libcp1plugin_la_OBJECTS) $(libcp1plugin_la_DEPENDENCIES) $(EXTRA_libcp1plugin_la_DEPENDENCIES) \n+\t$(libcp1plugin_la_LINK) $(am_libcp1plugin_la_rpath) $(libcp1plugin_la_OBJECTS) $(libcp1plugin_la_LIBADD) $(LIBS)\n \n mostlyclean-compile:\n \t-rm -f *.$(OBJEXT)\n@@ -451,9 +479,11 @@ distclean-compile:\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/connection.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/findcomp.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcc1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcc1plugin.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcp1.Plo@am__quote@\n+@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/libcp1plugin.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/marshall.Plo@am__quote@\n @AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/names.Plo@am__quote@\n-@AMDEP_TRUE@@am__include@ @am__quote@./$(DEPDIR)/plugin.Plo@am__quote@\n \n .cc.o:\n @am__fastdepCXX_TRUE@\t$(CXXCOMPILE) -MT $@ -MD -MP -MF $(DEPDIR)/$*.Tpo -c -o $@ $<\n@@ -674,8 +704,18 @@ override LDFLAGS := $(filter-out -fsanitize=address,$(LDFLAGS))\n \n # Put this in a header so we don't run sed for each compilation.  This\n # is also simpler to debug as one can easily see the constant.\n-compiler-name.h: Makefile\n-\techo \"#define COMPILER_NAME \\\"`echo gcc | sed '$(transform)'`\\\"\" > $@\n+# FIXME: compute it in configure.ac and output it in config.status, or\n+# introduce timestamp files for some indirection to avoid rebuilding it\n+# every time.\n+c-compiler-name.h: Makefile\n+\t-rm -f $@T\n+\techo \"#define C_COMPILER_NAME \\\"`echo gcc | sed '$(transform)'`\\\"\" > $@T\n+\tmv $@T $@ # $(SHELL) $(srcdir)/../move-if-change $@T $@\n+\n+cp-compiler-name.h: Makefile\n+\t-rm -f $@T\n+\techo \"#define CP_COMPILER_NAME \\\"`echo g++ | sed '$(transform)'`\\\"\" > $@T\n+\tmv $@T $@ # $(SHELL) $(srcdir)/../move-if-change $@T $@\n \n # Tell versions [3.59,3.63) of GNU make to not export all variables.\n # Otherwise a system limit (for SysV at least) may be exceeded."}, {"sha": "0ef6c112dae20f46872310446202b20376828f9a", "filename": "libcc1/libcc1.cc", "status": "modified", "additions": 41, "deletions": 37, "changes": 78, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -29,15 +29,15 @@ along with GCC; see the file COPYING3.  If not see\n #include <sys/stat.h>\n #include <stdlib.h>\n #include <sstream>\n+#include \"marshall-c.hh\"\n #include \"rpc.hh\"\n #include \"connection.hh\"\n #include \"names.hh\"\n #include \"callbacks.hh\"\n-#include \"gcc-interface.h\"\n #include \"libiberty.h\"\n #include \"xregex.h\"\n #include \"findcomp.hh\"\n-#include \"compiler-name.h\"\n+#include \"c-compiler-name.h\"\n #include \"intl.h\"\n \n struct libcc1;\n@@ -164,30 +164,35 @@ libcc1::~libcc1 ()\n \n \f\n \n-// This is a wrapper function that is called by the RPC system and\n-// that then forwards the call to the library user.  Note that the\n-// return value is not used; the type cannot be 'void' due to\n-// limitations in our simple RPC.\n-int\n-call_binding_oracle (cc1_plugin::connection *conn,\n-\t\t     enum gcc_c_oracle_request request,\n-\t\t     const char *identifier)\n-{\n-  libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n+// Enclose these functions in an anonymous namespace because they\n+// shouldn't be exported, but they can't be static because they're\n+// used as template arguments.\n+namespace {\n+  // This is a wrapper function that is called by the RPC system and\n+  // that then forwards the call to the library user.  Note that the\n+  // return value is not used; the type cannot be 'void' due to\n+  // limitations in our simple RPC.\n+  int\n+  c_call_binding_oracle (cc1_plugin::connection *conn,\n+\t\t\t enum gcc_c_oracle_request request,\n+\t\t\t const char *identifier)\n+  {\n+    libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n \n-  self->binding_oracle (self->oracle_datum, self, request, identifier);\n-  return 1;\n-}\n+    self->binding_oracle (self->oracle_datum, self, request, identifier);\n+    return 1;\n+  }\n \n-// This is a wrapper function that is called by the RPC system and\n-// that then forwards the call to the library user.\n-gcc_address\n-call_symbol_address (cc1_plugin::connection *conn, const char *identifier)\n-{\n-  libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n+  // This is a wrapper function that is called by the RPC system and\n+  // that then forwards the call to the library user.\n+  gcc_address\n+  c_call_symbol_address (cc1_plugin::connection *conn, const char *identifier)\n+  {\n+    libcc1 *self = ((libcc1_connection *) conn)->back_ptr;\n \n-  return self->address_oracle (self->oracle_datum, self, identifier);\n-}\n+    return self->address_oracle (self->oracle_datum, self, identifier);\n+  }\n+} /* anonymous namespace */\n \n \f\n \n@@ -298,19 +303,19 @@ static const struct gcc_c_fe_vtable c_vtable =\n   set_callbacks,\n \n #define GCC_METHOD0(R, N) \\\n-  rpc<R, cc1_plugin::N>,\n+  rpc<R, cc1_plugin::c::N>,\n #define GCC_METHOD1(R, N, A) \\\n-  rpc<R, cc1_plugin::N, A>,\n+  rpc<R, cc1_plugin::c::N, A>,\n #define GCC_METHOD2(R, N, A, B) \\\n-  rpc<R, cc1_plugin::N, A, B>,\n+  rpc<R, cc1_plugin::c::N, A, B>,\n #define GCC_METHOD3(R, N, A, B, C) \\\n-  rpc<R, cc1_plugin::N, A, B, C>,\n+  rpc<R, cc1_plugin::c::N, A, B, C>,\n #define GCC_METHOD4(R, N, A, B, C, D) \\\n-  rpc<R, cc1_plugin::N, A, B, C, D>,\n+  rpc<R, cc1_plugin::c::N, A, B, C, D>,\n #define GCC_METHOD5(R, N, A, B, C, D, E) \\\n-  rpc<R, cc1_plugin::N, A, B, C, D, E>,\n+  rpc<R, cc1_plugin::c::N, A, B, C, D, E>,\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n-  rpc<R, cc1_plugin::N, A, B, C, D, E, F, G>,\n+  rpc<R, cc1_plugin::c::N, A, B, C, D, E, F, G>,\n \n #include \"gcc-c-fe.def\"\n \n@@ -377,13 +382,12 @@ libcc1::compiler::find (std::string &compiler ATTRIBUTE_UNUSED) const\n char *\n libcc1::compiler_triplet_regexp::find (std::string &compiler) const\n {\n-  std::string rx = make_regexp (triplet_regexp_.c_str (), COMPILER_NAME);\n+  std::string rx = make_regexp (triplet_regexp_.c_str (), C_COMPILER_NAME);\n   if (self_->verbose)\n     fprintf (stderr, _(\"searching for compiler matching regex %s\\n\"),\n \t     rx.c_str());\n   regex_t triplet;\n-  int code;\n-  code = regcomp (&triplet, rx.c_str (), REG_EXTENDED | REG_NOSUB);\n+  int code = regcomp (&triplet, rx.c_str (), REG_EXTENDED | REG_NOSUB);\n   if (code != 0)\n     {\n       size_t len = regerror (code, &triplet, NULL, 0);\n@@ -532,7 +536,7 @@ fork_exec (libcc1 *self, char **argv, int spair_fds[2], int stderr_fds[2])\n \n       cc1_plugin::status result = cc1_plugin::FAIL;\n       if (self->connection->send ('H')\n-\t  && ::cc1_plugin::marshall (self->connection, GCC_C_FE_VERSION_0))\n+\t  && ::cc1_plugin::marshall (self->connection, GCC_C_FE_VERSION_1))\n \tresult = self->connection->wait_for_query ();\n \n       close (spair_fds[0]);\n@@ -601,12 +605,12 @@ libcc1_compile (struct gcc_base_context *s,\n     = cc1_plugin::callback<int,\n \t\t\t   enum gcc_c_oracle_request,\n \t\t\t   const char *,\n-\t\t\t   call_binding_oracle>;\n+\t\t\t   c_call_binding_oracle>;\n   self->connection->add_callback (\"binding_oracle\", fun);\n \n   fun = cc1_plugin::callback<gcc_address,\n \t\t\t     const char *,\n-\t\t\t     call_symbol_address>;\n+\t\t\t     c_call_symbol_address>;\n   self->connection->add_callback (\"address_oracle\", fun);\n \n   char **argv = new (std::nothrow) char *[self->args.size () + 1];\n@@ -663,7 +667,7 @@ gcc_c_fe_context (enum gcc_base_api_version base_version,\n \t\t  enum gcc_c_api_version c_version)\n {\n   if ((base_version != GCC_FE_VERSION_0 && base_version != GCC_FE_VERSION_1)\n-      || c_version != GCC_C_FE_VERSION_0)\n+      || (c_version != GCC_C_FE_VERSION_0 && c_version != GCC_C_FE_VERSION_1))\n     return NULL;\n \n   return new libcc1 (&vtable, &c_vtable);"}, {"sha": "9d46f263b562a5ef5c5a6617142df621bfffd9e1", "filename": "libcc1/libcc1.sym", "status": "modified", "additions": 1, "deletions": 0, "changes": 1, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1.sym", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1.sym", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1.sym?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -1 +1,2 @@\n gcc_c_fe_context\n+gcc_cp_fe_context"}, {"sha": "bd05c8ddb10c6f93d5449bc7f607ab3989bdd9eb", "filename": "libcc1/libcc1plugin.cc", "status": "renamed", "additions": 122, "deletions": 23, "changes": 145, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcc1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcc1plugin.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -63,6 +63,7 @@\n \n #include \"callbacks.hh\"\n #include \"connection.hh\"\n+#include \"marshall-c.hh\"\n #include \"rpc.hh\"\n \n #ifdef __GNUC__\n@@ -298,18 +299,7 @@ address_rewriter (tree *in, int *walk_subtrees, void *arg)\n   value.decl = *in;\n   decl_addr_value *found_value = ctx->address_map.find (&value);\n   if (found_value != NULL)\n-    {\n-      // At this point we don't need VLA sizes for gdb-supplied\n-      // variables, and having them here confuses later passes, so we\n-      // drop them.\n-      if (C_TYPE_VARIABLE_SIZE (TREE_TYPE (*in)))\n-\t{\n-\t  TREE_TYPE (*in)\n-\t    = build_array_type_nelts (TREE_TYPE (TREE_TYPE (*in)), 1);\n-\t  DECL_SIZE (*in) = TYPE_SIZE (TREE_TYPE (*in));\n-\t  DECL_SIZE_UNIT (*in) = TYPE_SIZE_UNIT (TREE_TYPE (*in));\n-\t}\n-    }\n+    ;\n   else if (DECL_IS_BUILTIN (*in))\n     {\n       gcc_address address;\n@@ -417,6 +407,7 @@ plugin_build_decl (cc1_plugin::connection *self,\n     {\n       decl_addr_value value;\n \n+      DECL_EXTERNAL (decl) = 1;\n       value.decl = decl;\n       if (substitution_name != NULL)\n \t{\n@@ -456,8 +447,15 @@ plugin_tagbind (cc1_plugin::connection *self,\n \t\tconst char *filename, unsigned int line_number)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n+  tree t = convert_in (tagged_type), x;\n   c_pushtag (ctx->get_source_location (filename, line_number),\n-\t     get_identifier (name), convert_in (tagged_type));\n+\t     get_identifier (name), t);\n+\n+  /* Propagate the newly-added type name so that previously-created\n+     variant types are not disconnected from their main variants.  */\n+  for (x = TYPE_MAIN_VARIANT (t); x; x = TYPE_NEXT_VARIANT (x))\n+    TYPE_NAME (x) = TYPE_NAME (t);\n+\n   return 1;\n }\n \n@@ -469,18 +467,30 @@ plugin_build_pointer_type (cc1_plugin::connection *,\n   return convert_out (build_pointer_type (convert_in (base_type)));\n }\n \n+// TYPE_NAME needs to be a valid pointer, even if there is no name available.\n+\n+static tree\n+build_anonymous_node (enum tree_code code)\n+{\n+  tree node = make_node (code);\n+  tree type_decl = build_decl (input_location, TYPE_DECL, NULL_TREE, node);\n+  TYPE_NAME (node) = type_decl;\n+  TYPE_STUB_DECL (node) = type_decl;\n+  return node;\n+}\n+\n gcc_type\n plugin_build_record_type (cc1_plugin::connection *self)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  return convert_out (ctx->preserve (make_node (RECORD_TYPE)));\n+  return convert_out (ctx->preserve (build_anonymous_node (RECORD_TYPE)));\n }\n \n gcc_type\n plugin_build_union_type (cc1_plugin::connection *self)\n {\n   plugin_context *ctx = static_cast<plugin_context *> (self);\n-  return convert_out (ctx->preserve (make_node (UNION_TYPE)));\n+  return convert_out (ctx->preserve (build_anonymous_node (UNION_TYPE)));\n }\n \n int\n@@ -565,6 +575,23 @@ plugin_finish_record_or_union (cc1_plugin::connection *,\n       // FIXME we have no idea about TYPE_PACKED\n     }\n \n+  tree t = record_or_union_type, x;\n+  for (x = TYPE_MAIN_VARIANT (t); x; x = TYPE_NEXT_VARIANT (x))\n+    {\n+      /* Like finish_struct, update the qualified variant types.  */\n+      TYPE_FIELDS (x) = TYPE_FIELDS (t);\n+      TYPE_LANG_SPECIFIC (x) = TYPE_LANG_SPECIFIC (t);\n+      C_TYPE_FIELDS_READONLY (x) = C_TYPE_FIELDS_READONLY (t);\n+      C_TYPE_FIELDS_VOLATILE (x) = C_TYPE_FIELDS_VOLATILE (t);\n+      C_TYPE_VARIABLE_SIZE (x) = C_TYPE_VARIABLE_SIZE (t);\n+      /* We copy these fields too.  */\n+      SET_TYPE_ALIGN (x, TYPE_ALIGN (t));\n+      TYPE_SIZE (x) = TYPE_SIZE (t);\n+      TYPE_SIZE_UNIT (x) = TYPE_SIZE_UNIT (t);\n+      if (x != record_or_union_type)\n+\tcompute_record_mode (x);\n+    }\n+\n   return 1;\n }\n \n@@ -577,7 +604,7 @@ plugin_build_enum_type (cc1_plugin::connection *self,\n   if (underlying_int_type == error_mark_node)\n     return convert_out (error_mark_node);\n \n-  tree result = make_node (ENUMERAL_TYPE);\n+  tree result = build_anonymous_node (ENUMERAL_TYPE);\n \n   TYPE_PRECISION (result) = TYPE_PRECISION (underlying_int_type);\n   TYPE_UNSIGNED (result) = TYPE_UNSIGNED (underlying_int_type);\n@@ -667,24 +694,77 @@ plugin_build_function_type (cc1_plugin::connection *self,\n   return convert_out (ctx->preserve (result));\n }\n \n-gcc_type\n-plugin_int_type (cc1_plugin::connection *self,\n-\t\t int is_unsigned, unsigned long size_in_bytes)\n+/* Return a builtin type associated with BUILTIN_NAME.  */\n+\n+static tree\n+safe_lookup_builtin_type (const char *builtin_name)\n+{\n+  tree result = NULL_TREE;\n+\n+  if (!builtin_name)\n+    return result;\n+\n+  result = identifier_global_value (get_identifier (builtin_name));\n+\n+  if (!result)\n+    return result;\n+\n+  gcc_assert (TREE_CODE (result) == TYPE_DECL);\n+  result = TREE_TYPE (result);\n+  return result;\n+}\n+\n+static gcc_type\n+plugin_int_check (cc1_plugin::connection *self,\n+\t\t  int is_unsigned, unsigned long size_in_bytes,\n+\t\t  tree result)\n {\n-  tree result = c_common_type_for_size (BITS_PER_UNIT * size_in_bytes,\n-\t\t\t\t\tis_unsigned);\n   if (result == NULL_TREE)\n     result = error_mark_node;\n   else\n     {\n+      gcc_assert (!TYPE_UNSIGNED (result) == !is_unsigned);\n+      gcc_assert (TREE_CODE (TYPE_SIZE (result)) == INTEGER_CST);\n+      gcc_assert (TYPE_PRECISION (result) == BITS_PER_UNIT * size_in_bytes);\n+\n       plugin_context *ctx = static_cast<plugin_context *> (self);\n       ctx->preserve (result);\n     }\n   return convert_out (result);\n }\n \n gcc_type\n-plugin_float_type (cc1_plugin::connection *,\n+plugin_int_type_v0 (cc1_plugin::connection *self,\n+\t\t    int is_unsigned, unsigned long size_in_bytes)\n+{\n+  tree result = c_common_type_for_size (BITS_PER_UNIT * size_in_bytes,\n+\t\t\t\t\tis_unsigned);\n+\n+  return plugin_int_check (self, is_unsigned, size_in_bytes, result);\n+}\n+\n+gcc_type\n+plugin_int_type (cc1_plugin::connection *self,\n+\t\t int is_unsigned, unsigned long size_in_bytes,\n+\t\t const char *builtin_name)\n+{\n+  if (!builtin_name)\n+    return plugin_int_type_v0 (self, is_unsigned, size_in_bytes);\n+\n+  tree result = safe_lookup_builtin_type (builtin_name);\n+  gcc_assert (!result || TREE_CODE (result) == INTEGER_TYPE);\n+\n+  return plugin_int_check (self, is_unsigned, size_in_bytes, result);\n+}\n+\n+gcc_type\n+plugin_char_type (cc1_plugin::connection *)\n+{\n+  return convert_out (char_type_node);\n+}\n+\n+gcc_type\n+plugin_float_type_v0 (cc1_plugin::connection *,\n \t\t   unsigned long size_in_bytes)\n {\n   if (BITS_PER_UNIT * size_in_bytes == TYPE_PRECISION (float_type_node))\n@@ -696,6 +776,25 @@ plugin_float_type (cc1_plugin::connection *,\n   return convert_out (error_mark_node);\n }\n \n+gcc_type\n+plugin_float_type (cc1_plugin::connection *self,\n+\t\t   unsigned long size_in_bytes,\n+\t\t   const char *builtin_name)\n+{\n+  if (!builtin_name)\n+    return plugin_float_type_v0 (self, size_in_bytes);\n+\n+  tree result = safe_lookup_builtin_type (builtin_name);\n+\n+  if (!result)\n+    return convert_out (error_mark_node);\n+\n+  gcc_assert (TREE_CODE (result) == REAL_TYPE);\n+  gcc_assert (BITS_PER_UNIT * size_in_bytes == TYPE_PRECISION (result));\n+\n+  return convert_out (result);\n+}\n+\n gcc_type\n plugin_void_type (cc1_plugin::connection *)\n {\n@@ -848,7 +947,7 @@ plugin_init (struct plugin_name_args *plugin_info,\n       || ! ::cc1_plugin::unmarshall (current_context, &version))\n     fatal_error (input_location,\n \t\t \"%s: handshake failed\", plugin_info->base_name);\n-  if (version != GCC_C_FE_VERSION_0)\n+  if (version != GCC_C_FE_VERSION_1)\n     fatal_error (input_location,\n \t\t \"%s: unknown version in handshake\", plugin_info->base_name);\n ", "previous_filename": "libcc1/plugin.cc"}, {"sha": "bbd8488af9356b05c578290aabd81634e635e6d7", "filename": "libcc1/libcp1.cc", "status": "added", "additions": 706, "deletions": 0, "changes": 706, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,706 @@\n+/* The library used by gdb.\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#include <cc1plugin-config.h>\n+#include <vector>\n+#include <string>\n+#include <sys/socket.h>\n+#include <sys/types.h>\n+#include <unistd.h>\n+#include <sys/wait.h>\n+#include <stdio.h>\n+#include <errno.h>\n+#include <sys/stat.h>\n+#include <stdlib.h>\n+#include <sstream>\n+#include \"marshall-cp.hh\"\n+#include \"rpc.hh\"\n+#include \"connection.hh\"\n+#include \"names.hh\"\n+#include \"callbacks.hh\"\n+#include \"libiberty.h\"\n+#include \"xregex.h\"\n+#include \"findcomp.hh\"\n+#include \"cp-compiler-name.h\"\n+#include \"intl.h\"\n+\n+struct libcp1;\n+\n+class libcp1_connection;\n+\n+// The C compiler context that we hand back to our caller.\n+struct libcp1 : public gcc_cp_context\n+{\n+  libcp1 (const gcc_base_vtable *, const gcc_cp_fe_vtable *);\n+  ~libcp1 ();\n+\n+  // A convenience function to print something.\n+  void print (const char *str)\n+  {\n+    this->print_function (this->print_datum, str);\n+  }\n+\n+  libcp1_connection *connection;\n+\n+  gcc_cp_oracle_function *binding_oracle;\n+  gcc_cp_symbol_address_function *address_oracle;\n+  gcc_cp_enter_leave_user_expr_scope_function *enter_scope;\n+  gcc_cp_enter_leave_user_expr_scope_function *leave_scope;\n+  void *oracle_datum;\n+\n+  void (*print_function) (void *datum, const char *message);\n+  void *print_datum;\n+\n+  std::vector<std::string> args;\n+  std::string source_file;\n+\n+  /* Non-zero as an equivalent to gcc driver option \"-v\".  */\n+  bool verbose;\n+\n+  /* Compiler to set by set_triplet_regexp or set_driver_filename.  */\n+  class compiler\n+  {\n+  protected:\n+    libcp1 *self_;\n+  public:\n+    compiler (libcp1 *self) : self_ (self)\n+    {\n+    }\n+    virtual char *find (std::string &compiler) const;\n+    virtual ~compiler ()\n+    {\n+    }\n+  } *compilerp;\n+\n+  /* Compiler to set by set_triplet_regexp.  */\n+  class compiler_triplet_regexp : public compiler\n+  {\n+  private:\n+    std::string triplet_regexp_;\n+  public:\n+    virtual char *find (std::string &compiler) const;\n+    compiler_triplet_regexp (libcp1 *self, std::string triplet_regexp)\n+      : compiler (self), triplet_regexp_ (triplet_regexp)\n+    {\n+    }\n+    virtual ~compiler_triplet_regexp ()\n+    {\n+    }\n+  };\n+\n+  /* Compiler to set by set_driver_filename.  */\n+  class compiler_driver_filename : public compiler\n+  {\n+  private:\n+    std::string driver_filename_;\n+  public:\n+    virtual char *find (std::string &compiler) const;\n+    compiler_driver_filename (libcp1 *self, std::string driver_filename)\n+      : compiler (self), driver_filename_ (driver_filename)\n+    {\n+    }\n+    virtual ~compiler_driver_filename ()\n+    {\n+    }\n+  };\n+};\n+\n+// A local subclass of connection that holds a back-pointer to the\n+// gcc_c_context object that we provide to our caller.\n+class libcp1_connection : public cc1_plugin::connection\n+{\n+public:\n+\n+  libcp1_connection (int fd, int aux_fd, libcp1 *b)\n+    : connection (fd, aux_fd),\n+      back_ptr (b)\n+  {\n+  }\n+\n+  virtual void print (const char *buf)\n+  {\n+    back_ptr->print (buf);\n+  }\n+\n+  libcp1 *back_ptr;\n+};\n+\n+libcp1::libcp1 (const gcc_base_vtable *v,\n+\t\t  const gcc_cp_fe_vtable *cv)\n+  : connection (NULL),\n+    binding_oracle (NULL),\n+    address_oracle (NULL),\n+    oracle_datum (NULL),\n+    print_function (NULL),\n+    print_datum (NULL),\n+    args (),\n+    source_file (),\n+    verbose (false),\n+    compilerp (new libcp1::compiler (this))\n+{\n+  base.ops = v;\n+  cp_ops = cv;\n+}\n+\n+libcp1::~libcp1 ()\n+{\n+  delete connection;\n+  delete compilerp;\n+}\n+\n+\f\n+\n+// Enclose these functions in an anonymous namespace because they\n+// shouldn't be exported, but they can't be static because they're\n+// used as template arguments.\n+namespace {\n+  // This is a wrapper function that is called by the RPC system and\n+  // that then forwards the call to the library user.  Note that the\n+  // return value is not used; the type cannot be 'void' due to\n+  // limitations in our simple RPC.\n+  int\n+  cp_call_binding_oracle (cc1_plugin::connection *conn,\n+\t\t       enum gcc_cp_oracle_request request,\n+\t\t       const char *identifier)\n+  {\n+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+\n+    self->binding_oracle (self->oracle_datum, self, request, identifier);\n+    return 1;\n+  }\n+\n+  // This is a wrapper function that is called by the RPC system and\n+  // that then forwards the call to the library user.\n+  gcc_address\n+  cp_call_symbol_address (cc1_plugin::connection *conn, const char *identifier)\n+  {\n+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+\n+    return self->address_oracle (self->oracle_datum, self, identifier);\n+  }\n+\n+  int\n+  cp_call_enter_scope (cc1_plugin::connection *conn)\n+  {\n+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+\n+    self->enter_scope (self->oracle_datum, self);\n+    return 1;\n+  }\n+\n+  int\n+  cp_call_leave_scope (cc1_plugin::connection *conn)\n+  {\n+    libcp1 *self = ((libcp1_connection *) conn)->back_ptr;\n+\n+    self->leave_scope (self->oracle_datum, self);\n+    return 1;\n+  }\n+} /* anonymous namespace */\n+\n+\f\n+\n+static void\n+set_callbacks (struct gcc_cp_context *s,\n+\t       gcc_cp_oracle_function *binding_oracle,\n+\t       gcc_cp_symbol_address_function *address_oracle,\n+\t       gcc_cp_enter_leave_user_expr_scope_function *enter_scope,\n+\t       gcc_cp_enter_leave_user_expr_scope_function *leave_scope,\n+\t       void *datum)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  self->binding_oracle = binding_oracle;\n+  self->address_oracle = address_oracle;\n+  self->enter_scope = enter_scope;\n+  self->leave_scope = leave_scope;\n+  self->oracle_datum = datum;\n+}\n+\n+// Instances of these rpc<> template functions are installed into the\n+// \"cp_vtable\".  These functions are parameterized by type and method\n+// name and forward the call via the connection.\n+\n+template<typename R, const char *&NAME>\n+R rpc (struct gcc_cp_context *s)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A>\n+R rpc (struct gcc_cp_context *s, A arg)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A1, typename A2>\n+R rpc (struct gcc_cp_context *s, A1 arg1, A2 arg2)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg1, arg2))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A1, typename A2, typename A3>\n+R rpc (struct gcc_cp_context *s, A1 arg1, A2 arg2, A3 arg3)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg1, arg2, arg3))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A1, typename A2, typename A3,\n+\t typename A4>\n+R rpc (struct gcc_cp_context *s, A1 arg1, A2 arg2, A3 arg3, A4 arg4)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg1, arg2, arg3,\n+\t\t\t arg4))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A1, typename A2, typename A3,\n+\t typename A4, typename A5>\n+R rpc (struct gcc_cp_context *s, A1 arg1, A2 arg2, A3 arg3, A4 arg4, A5 arg5)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg1, arg2, arg3,\n+\t\t\t arg4, arg5))\n+    return 0;\n+  return result;\n+}\n+\n+template<typename R, const char *&NAME, typename A1, typename A2, typename A3,\n+\t typename A4, typename A5, typename A6, typename A7>\n+R rpc (struct gcc_cp_context *s, A1 arg1, A2 arg2, A3 arg3, A4 arg4, A5 arg5,\n+       A6 arg6, A7 arg7)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+  R result;\n+\n+  if (!cc1_plugin::call (self->connection, NAME, &result, arg1, arg2, arg3,\n+\t\t\t arg4, arg5, arg6, arg7))\n+    return 0;\n+  return result;\n+}\n+\n+static const struct gcc_cp_fe_vtable cp_vtable =\n+{\n+  GCC_CP_FE_VERSION_0,\n+  set_callbacks,\n+\n+#define GCC_METHOD0(R, N) \\\n+  rpc<R, cc1_plugin::cp::N>,\n+#define GCC_METHOD1(R, N, A) \\\n+  rpc<R, cc1_plugin::cp::N, A>,\n+#define GCC_METHOD2(R, N, A, B) \\\n+  rpc<R, cc1_plugin::cp::N, A, B>,\n+#define GCC_METHOD3(R, N, A, B, C) \\\n+  rpc<R, cc1_plugin::cp::N, A, B, C>,\n+#define GCC_METHOD4(R, N, A, B, C, D) \\\n+  rpc<R, cc1_plugin::cp::N, A, B, C, D>,\n+#define GCC_METHOD5(R, N, A, B, C, D, E) \\\n+  rpc<R, cc1_plugin::cp::N, A, B, C, D, E>,\n+#define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n+  rpc<R, cc1_plugin::cp::N, A, B, C, D, E, F, G>,\n+\n+#include \"gcc-cp-fe.def\"\n+\n+#undef GCC_METHOD0\n+#undef GCC_METHOD1\n+#undef GCC_METHOD2\n+#undef GCC_METHOD3\n+#undef GCC_METHOD4\n+#undef GCC_METHOD5\n+#undef GCC_METHOD7\n+};\n+\n+\f\n+\n+// Construct an appropriate regexp to match the compiler name.\n+static std::string\n+make_regexp (const char *triplet_regexp, const char *compiler)\n+{\n+  std::stringstream buf;\n+\n+  buf << \"^\" << triplet_regexp << \"-\";\n+\n+  // Quote the compiler name in case it has something funny in it.\n+  for (const char *p = compiler; *p; ++p)\n+    {\n+      switch (*p)\n+\t{\n+\tcase '.':\n+\tcase '^':\n+\tcase '$':\n+\tcase '*':\n+\tcase '+':\n+\tcase '?':\n+\tcase '(':\n+\tcase ')':\n+\tcase '[':\n+\tcase '{':\n+\tcase '\\\\':\n+\tcase '|':\n+\t  buf << '\\\\';\n+\t  break;\n+\t}\n+      buf << *p;\n+    }\n+  buf << \"$\";\n+\n+  return buf.str ();\n+}\n+\n+static void\n+libcp1_set_verbose (struct gcc_base_context *s, int /* bool */ verbose)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  self->verbose = verbose != 0;\n+}\n+\n+char *\n+libcp1::compiler::find (std::string &compiler ATTRIBUTE_UNUSED) const\n+{\n+  return xstrdup (_(\"Compiler has not been specified\"));\n+}\n+\n+char *\n+libcp1::compiler_triplet_regexp::find (std::string &compiler) const\n+{\n+  std::string rx = make_regexp (triplet_regexp_.c_str (), CP_COMPILER_NAME);\n+  if (self_->verbose)\n+    fprintf (stderr, _(\"searching for compiler matching regex %s\\n\"),\n+\t     rx.c_str());\n+  regex_t triplet;\n+  int code = regcomp (&triplet, rx.c_str (), REG_EXTENDED | REG_NOSUB);\n+  if (code != 0)\n+    {\n+      size_t len = regerror (code, &triplet, NULL, 0);\n+      char err[len];\n+\n+      regerror (code, &triplet, err, len);\n+\n+      return concat (\"Could not compile regexp \\\"\",\n+\t\t     rx.c_str (),\n+\t\t     \"\\\": \",\n+\t\t     err,\n+\t\t     (char *) NULL);\n+    }\n+\n+  if (!find_compiler (triplet, &compiler))\n+    {\n+      regfree (&triplet);\n+      return concat (\"Could not find a compiler matching \\\"\",\n+\t\t     rx.c_str (),\n+\t\t     \"\\\"\",\n+\t\t     (char *) NULL);\n+    }\n+  regfree (&triplet);\n+  if (self_->verbose)\n+    fprintf (stderr, _(\"found compiler %s\\n\"), compiler.c_str());\n+  return NULL;\n+}\n+\n+char *\n+libcp1::compiler_driver_filename::find (std::string &compiler) const\n+{\n+  // Simulate fnotice by fprintf.\n+  if (self_->verbose)\n+    fprintf (stderr, _(\"using explicit compiler filename %s\\n\"),\n+\t     driver_filename_.c_str());\n+  compiler = driver_filename_;\n+  return NULL;\n+}\n+\n+static char *\n+libcp1_set_arguments (struct gcc_base_context *s,\n+\t\t      int argc, char **argv)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  std::string compiler;\n+  char *errmsg = self->compilerp->find (compiler);\n+  if (errmsg != NULL)\n+    return errmsg;\n+\n+  self->args.push_back (compiler);\n+\n+  for (int i = 0; i < argc; ++i)\n+    self->args.push_back (argv[i]);\n+\n+  return NULL;\n+}\n+\n+static char *\n+libcp1_set_triplet_regexp (struct gcc_base_context *s,\n+\t\t\t   const char *triplet_regexp)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  delete self->compilerp;\n+  self->compilerp = new libcp1::compiler_triplet_regexp (self, triplet_regexp);\n+  return NULL;\n+}\n+\n+static char *\n+libcp1_set_driver_filename (struct gcc_base_context *s,\n+\t\t\t    const char *driver_filename)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  delete self->compilerp;\n+  self->compilerp = new libcp1::compiler_driver_filename (self,\n+\t\t\t\t\t\t\t  driver_filename);\n+  return NULL;\n+}\n+\n+static char *\n+libcp1_set_arguments_v0 (struct gcc_base_context *s,\n+\t\t\t const char *triplet_regexp,\n+\t\t\t int argc, char **argv)\n+{\n+  char *errmsg = libcp1_set_triplet_regexp (s, triplet_regexp);\n+  if (errmsg != NULL)\n+    return errmsg;\n+\n+  return libcp1_set_arguments (s, argc, argv);\n+}\n+\n+static void\n+libcp1_set_source_file (struct gcc_base_context *s,\n+\t\t\t const char *file)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  self->source_file = file;\n+}\n+\n+static void\n+libcp1_set_print_callback (struct gcc_base_context *s,\n+\t\t\t    void (*print_function) (void *datum,\n+\t\t\t\t\t\t    const char *message),\n+\t\t\t    void *datum)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  self->print_function = print_function;\n+  self->print_datum = datum;\n+}\n+\n+static int\n+fork_exec (libcp1 *self, char **argv, int spair_fds[2], int stderr_fds[2])\n+{\n+  pid_t child_pid = fork ();\n+\n+  if (child_pid == -1)\n+    {\n+      close (spair_fds[0]);\n+      close (spair_fds[1]);\n+      close (stderr_fds[0]);\n+      close (stderr_fds[1]);\n+      return 0;\n+    }\n+\n+  if (child_pid == 0)\n+    {\n+      // Child.\n+      dup2 (stderr_fds[1], 1);\n+      dup2 (stderr_fds[1], 2);\n+      close (stderr_fds[0]);\n+      close (stderr_fds[1]);\n+      close (spair_fds[0]);\n+\n+      execvp (argv[0], argv);\n+      _exit (127);\n+    }\n+  else\n+    {\n+      // Parent.\n+      close (spair_fds[1]);\n+      close (stderr_fds[1]);\n+\n+      cc1_plugin::status result = cc1_plugin::FAIL;\n+      if (self->connection->send ('H')\n+\t  && ::cc1_plugin::marshall (self->connection, GCC_CP_FE_VERSION_0))\n+\tresult = self->connection->wait_for_query ();\n+\n+      close (spair_fds[0]);\n+      close (stderr_fds[0]);\n+\n+      while (true)\n+\t{\n+\t  int status;\n+\n+\t  if (waitpid (child_pid, &status, 0) == -1)\n+\t    {\n+\t      if (errno != EINTR)\n+\t\treturn 0;\n+\t    }\n+\n+\t  if (!WIFEXITED (status) || WEXITSTATUS (status) != 0)\n+\t    return 0;\n+\t  break;\n+\t}\n+\n+      if (!result)\n+\treturn 0;\n+      return 1;\n+    }\n+}\n+\n+static int\n+libcp1_compile (struct gcc_base_context *s,\n+\t\tconst char *filename)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  int fds[2];\n+  if (socketpair (AF_UNIX, SOCK_STREAM, 0, fds) != 0)\n+    {\n+      self->print (\"could not create socketpair\\n\");\n+      return 0;\n+    }\n+\n+  int stderr_fds[2];\n+  if (pipe (stderr_fds) != 0)\n+    {\n+      self->print (\"could not create pipe\\n\");\n+      close (fds[0]);\n+      close (fds[1]);\n+      return 0;\n+    }\n+\n+  self->args.push_back (\"-fplugin=libcp1plugin\");\n+  char buf[100];\n+  if (snprintf (buf, sizeof (buf), \"-fplugin-arg-libcp1plugin-fd=%d\", fds[1])\n+      >= (long) sizeof (buf))\n+    abort ();\n+  self->args.push_back (buf);\n+\n+  self->args.push_back (self->source_file);\n+  self->args.push_back (\"-c\");\n+  self->args.push_back (\"-o\");\n+  self->args.push_back (filename);\n+  if (self->verbose)\n+    self->args.push_back (\"-v\");\n+\n+  self->connection = new libcp1_connection (fds[0], stderr_fds[0], self);\n+\n+  cc1_plugin::callback_ftype *fun\n+    = cc1_plugin::callback<int,\n+\t\t\t   enum gcc_cp_oracle_request,\n+\t\t\t   const char *,\n+\t\t\t   cp_call_binding_oracle>;\n+  self->connection->add_callback (\"binding_oracle\", fun);\n+\n+  fun = cc1_plugin::callback<gcc_address,\n+\t\t\t     const char *,\n+\t\t\t     cp_call_symbol_address>;\n+  self->connection->add_callback (\"address_oracle\", fun);\n+\n+  fun = cc1_plugin::callback<int,\n+\t\t\t     cp_call_enter_scope>;\n+  self->connection->add_callback (\"enter_scope\", fun);\n+\n+  fun = cc1_plugin::callback<int,\n+\t\t\t     cp_call_leave_scope>;\n+  self->connection->add_callback (\"leave_scope\", fun);\n+\n+  char **argv = new (std::nothrow) char *[self->args.size () + 1];\n+  if (argv == NULL)\n+    return 0;\n+\n+  for (unsigned int i = 0; i < self->args.size (); ++i)\n+    argv[i] = const_cast<char *> (self->args[i].c_str ());\n+  argv[self->args.size ()] = NULL;\n+\n+  return fork_exec (self, argv, fds, stderr_fds);\n+}\n+\n+static int\n+libcp1_compile_v0 (struct gcc_base_context *s, const char *filename,\n+\t\t   int verbose)\n+{\n+  libcp1_set_verbose (s, verbose);\n+  return libcp1_compile (s, filename);\n+}\n+\n+static void\n+libcp1_destroy (struct gcc_base_context *s)\n+{\n+  libcp1 *self = (libcp1 *) s;\n+\n+  delete self;\n+}\n+\n+static const struct gcc_base_vtable vtable =\n+{\n+  GCC_FE_VERSION_0,\n+  libcp1_set_arguments_v0,\n+  libcp1_set_source_file,\n+  libcp1_set_print_callback,\n+  libcp1_compile_v0,\n+  libcp1_destroy,\n+  libcp1_set_verbose,\n+  libcp1_compile,\n+  libcp1_set_arguments,\n+  libcp1_set_triplet_regexp,\n+  libcp1_set_driver_filename,\n+};\n+\n+extern \"C\" gcc_cp_fe_context_function gcc_cp_fe_context;\n+\n+#ifdef __GNUC__\n+#pragma GCC visibility push(default)\n+#endif\n+\n+extern \"C\"\n+struct gcc_cp_context *\n+gcc_cp_fe_context (enum gcc_base_api_version base_version,\n+\t\t    enum gcc_cp_api_version cp_version)\n+{\n+  if ((base_version != GCC_FE_VERSION_0 && base_version != GCC_FE_VERSION_1)\n+      || cp_version != GCC_CP_FE_VERSION_0)\n+    return NULL;\n+\n+  return new libcp1 (&vtable, &cp_vtable);\n+}"}, {"sha": "545f28b98617ebd84c666312e525b2d7b3afdfe6", "filename": "libcc1/libcp1plugin.cc", "status": "added", "additions": 3789, "deletions": 0, "changes": 3789, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1plugin.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1plugin.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1"}, {"sha": "05d0f7b520fbd3ae1638b4286ccab4ec5d52e825", "filename": "libcc1/libcp1plugin.sym", "status": "added", "additions": 2, "deletions": 0, "changes": 2, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1plugin.sym", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Flibcp1plugin.sym", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Flibcp1plugin.sym?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,2 @@\n+plugin_init\n+plugin_is_GPL_compatible"}, {"sha": "8120c1505393e8a04250fd48d2b7ef7813ed5f6c", "filename": "libcc1/marshall-c.hh", "status": "added", "additions": 59, "deletions": 0, "changes": 59, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall-c.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall-c.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fmarshall-c.hh?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,59 @@\n+/* Marshalling and unmarshalling of C-specific types.\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CC1_PLUGIN_MARSHALL_C_HH\n+#define CC1_PLUGIN_MARSHALL_C_HH\n+\n+#include \"marshall.hh\"\n+#include \"gcc-c-interface.h\"\n+\n+namespace cc1_plugin\n+{\n+  status\n+  unmarshall (connection *conn, enum gcc_c_symbol_kind *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_c_symbol_kind) p;\n+    return OK;\n+  }\n+\n+  status\n+  unmarshall (connection *conn, enum gcc_c_oracle_request *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_c_oracle_request) p;\n+    return OK;\n+  }\n+\n+  status\n+  unmarshall (connection *conn, enum gcc_qualifiers *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_qualifiers) p;\n+    return OK;\n+  }\n+}\n+\n+#endif // CC1_PLUGIN_MARSHALL_C_HH"}, {"sha": "eec80f359a6c4e6527c894c0847910e8810cbb38", "filename": "libcc1/marshall-cp.hh", "status": "added", "additions": 271, "deletions": 0, "changes": 271, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall-cp.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall-cp.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fmarshall-cp.hh?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -0,0 +1,271 @@\n+/* Marshalling and unmarshalling of C++-specific types.\n+   Copyright (C) 2014-2017 Free Software Foundation, Inc.\n+\n+This file is part of GCC.\n+\n+GCC is free software; you can redistribute it and/or modify it under\n+the terms of the GNU General Public License as published by the Free\n+Software Foundation; either version 3, or (at your option) any later\n+version.\n+\n+GCC is distributed in the hope that it will be useful, but WITHOUT ANY\n+WARRANTY; without even the implied warranty of MERCHANTABILITY or\n+FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License\n+for more details.\n+\n+You should have received a copy of the GNU General Public License\n+along with GCC; see the file COPYING3.  If not see\n+<http://www.gnu.org/licenses/>.  */\n+\n+#ifndef CC1_PLUGIN_MARSHALL_CXX_HH\n+#define CC1_PLUGIN_MARSHALL_CXX_HH\n+\n+#include \"marshall.hh\"\n+#include \"gcc-cp-interface.h\"\n+\n+namespace cc1_plugin\n+{\n+  status\n+  unmarshall (connection *conn, enum gcc_cp_symbol_kind *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_cp_symbol_kind) p;\n+    return OK;\n+  }\n+\n+  status\n+  unmarshall (connection *conn, enum gcc_cp_oracle_request *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_cp_oracle_request) p;\n+    return OK;\n+  }\n+\n+  status\n+  unmarshall (connection *conn, enum gcc_cp_qualifiers *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_cp_qualifiers) p;\n+    return OK;\n+  }\n+\n+  status\n+  unmarshall (connection *conn, enum gcc_cp_ref_qualifiers *result)\n+  {\n+    protocol_int p;\n+    if (!unmarshall_intlike (conn, &p))\n+      return FAIL;\n+    *result = (enum gcc_cp_ref_qualifiers) p;\n+    return OK;\n+  }\n+\n+  // Send a gcc_vbase_array marker followed by the array.\n+  status\n+  marshall (connection *conn, const gcc_vbase_array *a)\n+  {\n+    size_t len;\n+\n+    if (a)\n+      len = a->n_elements;\n+    else\n+      len = (size_t)-1;\n+\n+    if (!marshall_array_start (conn, 'v', len))\n+      return FAIL;\n+\n+    if (!a)\n+      return OK;\n+\n+    if (!marshall_array_elmts (conn, len * sizeof (a->elements[0]),\n+\t\t\t       a->elements))\n+      return FAIL;\n+\n+    return marshall_array_elmts (conn, len * sizeof (a->flags[0]),\n+\t\t\t\t a->flags);\n+  }\n+\n+  // Read a gcc_vbase_array marker, followed by a gcc_vbase_array.  The\n+  // resulting array must be freed by the caller, using 'delete[]' on\n+  // elements and virtualp, and 'delete' on the array object itself.\n+  status\n+  unmarshall (connection *conn, struct gcc_vbase_array **result)\n+  {\n+    size_t len;\n+\n+    if (!unmarshall_array_start (conn, 'v', &len))\n+      return FAIL;\n+\n+    if (len == (size_t)-1)\n+      {\n+\t*result = NULL;\n+\treturn OK;\n+      }\n+\n+    struct gcc_vbase_array *gva = new gcc_vbase_array;\n+\n+    gva->n_elements = len;\n+    gva->elements = new gcc_type[len];\n+\n+    if (!unmarshall_array_elmts (conn,\n+\t\t\t\t len * sizeof (gva->elements[0]),\n+\t\t\t\t gva->elements))\n+      {\n+\tdelete[] gva->elements;\n+\tdelete gva;\n+\treturn FAIL;\n+      }\n+\n+    gva->flags = new enum gcc_cp_symbol_kind[len];\n+\n+    if (!unmarshall_array_elmts (conn,\n+\t\t\t\t len * sizeof (gva->flags[0]),\n+\t\t\t\t gva->flags))\n+      {\n+\tdelete[] gva->flags;\n+\tdelete[] gva->elements;\n+\tdelete gva;\n+\treturn FAIL;\n+      }\n+\n+    *result = gva;\n+    return OK;\n+  }\n+\n+  // Send a gcc_cp_template_args marker followed by the array.\n+  status\n+  marshall (connection *conn, const gcc_cp_template_args *a)\n+  {\n+    size_t len;\n+\n+    if (a)\n+      len = a->n_elements;\n+    else\n+      len = (size_t)-1;\n+\n+    if (!marshall_array_start (conn, 't', len))\n+      return FAIL;\n+\n+    if (!a)\n+      return OK;\n+\n+    if (!marshall_array_elmts (conn, len * sizeof (a->kinds[0]),\n+\t\t\t       a->kinds))\n+      return FAIL;\n+\n+    return marshall_array_elmts (conn, len * sizeof (a->elements[0]),\n+\t\t\t\t a->elements);\n+  }\n+\n+  // Read a gcc_vbase_array marker, followed by a gcc_vbase_array.  The\n+  // resulting array must be freed by the caller, using 'delete[]' on\n+  // elements and virtualp, and 'delete' on the array object itself.\n+  status\n+  unmarshall (connection *conn, struct gcc_cp_template_args **result)\n+  {\n+    size_t len;\n+\n+    if (!unmarshall_array_start (conn, 't', &len))\n+      return FAIL;\n+\n+    if (len == (size_t)-1)\n+      {\n+\t*result = NULL;\n+\treturn OK;\n+      }\n+\n+    struct gcc_cp_template_args *gva = new gcc_cp_template_args;\n+\n+    gva->n_elements = len;\n+    gva->kinds = new char[len];\n+\n+    if (!unmarshall_array_elmts (conn,\n+\t\t\t\t len * sizeof (gva->kinds[0]),\n+\t\t\t\t gva->kinds))\n+      {\n+\tdelete[] gva->kinds;\n+\tdelete gva;\n+\treturn FAIL;\n+      }\n+\n+    gva->elements = new gcc_cp_template_arg[len];\n+\n+    if (!unmarshall_array_elmts (conn,\n+\t\t\t\t len * sizeof (gva->elements[0]),\n+\t\t\t\t gva->elements))\n+      {\n+\tdelete[] gva->elements;\n+\tdelete[] gva->kinds;\n+\tdelete gva;\n+\treturn FAIL;\n+      }\n+\n+    *result = gva;\n+    return OK;\n+  }\n+\n+  // Send a gcc_cp_function_args marker followed by the array.\n+  status\n+  marshall (connection *conn, const gcc_cp_function_args *a)\n+  {\n+    size_t len;\n+\n+    if (a)\n+      len = a->n_elements;\n+    else\n+      len = (size_t)-1;\n+\n+    if (!marshall_array_start (conn, 'd', len))\n+      return FAIL;\n+\n+    if (!a)\n+      return OK;\n+\n+    return marshall_array_elmts (conn, len * sizeof (a->elements[0]),\n+\t\t\t\t a->elements);\n+  }\n+\n+  // Read a gcc_cp_function_args marker, followed by a\n+  // gcc_cp_function_args.  The resulting array must be freed\n+  // by the caller, using 'delete[]' on elements and virtualp, and\n+  // 'delete' on the array object itself.\n+  status\n+  unmarshall (connection *conn, struct gcc_cp_function_args **result)\n+  {\n+    size_t len;\n+\n+    if (!unmarshall_array_start (conn, 'd', &len))\n+      return FAIL;\n+\n+    if (len == (size_t)-1)\n+      {\n+\t*result = NULL;\n+\treturn OK;\n+      }\n+\n+    struct gcc_cp_function_args *gva = new gcc_cp_function_args;\n+\n+    gva->n_elements = len;\n+    gva->elements = new gcc_expr[len];\n+\n+    if (!unmarshall_array_elmts (conn,\n+\t\t\t\t len * sizeof (gva->elements[0]),\n+\t\t\t\t gva->elements))\n+      {\n+\tdelete[] gva->elements;\n+\tdelete gva;\n+\treturn FAIL;\n+      }\n+\n+    *result = gva;\n+\n+    return OK;\n+  }\n+}\n+\n+#endif // CC1_PLUGIN_MARSHALL_CP_HH"}, {"sha": "cf53cf7c4f2da4deb7c20c0eb69f0af43cd052e6", "filename": "libcc1/marshall.cc", "status": "modified", "additions": 70, "deletions": 41, "changes": 111, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fmarshall.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -49,36 +49,6 @@ cc1_plugin::unmarshall_intlike (connection *conn, unsigned long long *result)\n   return conn->get (result, sizeof (*result));\n }\n \n-cc1_plugin::status\n-cc1_plugin::unmarshall (connection *conn, enum gcc_c_symbol_kind *result)\n-{\n-  protocol_int p;\n-  if (!unmarshall_intlike (conn, &p))\n-    return FAIL;\n-  *result = (enum gcc_c_symbol_kind) p;\n-  return OK;\n-}\n-\n-cc1_plugin::status\n-cc1_plugin::unmarshall (connection *conn, enum gcc_c_oracle_request *result)\n-{\n-  protocol_int p;\n-  if (!unmarshall_intlike (conn, &p))\n-    return FAIL;\n-  *result = (enum gcc_c_oracle_request) p;\n-  return OK;\n-}\n-\n-cc1_plugin::status\n-cc1_plugin::unmarshall (connection *conn, enum gcc_qualifiers *result)\n-{\n-  protocol_int p;\n-  if (!unmarshall_intlike (conn, &p))\n-    return FAIL;\n-  *result = (enum gcc_qualifiers) p;\n-  return OK;\n-}\n-\n cc1_plugin::status\n cc1_plugin::marshall (connection *conn, const char *str)\n {\n@@ -128,39 +98,98 @@ cc1_plugin::unmarshall (connection *conn, char **result)\n }\n \n cc1_plugin::status\n-cc1_plugin::marshall (connection *conn, const gcc_type_array *a)\n+cc1_plugin::marshall_array_start (connection *conn, char id,\n+\t\t\t\t  size_t n_elements)\n {\n-  if (!conn->send ('a'))\n+  if (!conn->send (id))\n     return FAIL;\n \n-  unsigned long long r = a->n_elements;\n+  unsigned long long r = n_elements;\n   if (!conn->send (&r, sizeof (r)))\n     return FAIL;\n \n-  return conn->send (a->elements, r * sizeof (a->elements[0]));\n+  return OK;\n }\n \n cc1_plugin::status\n-cc1_plugin::unmarshall (connection *conn, gcc_type_array **result)\n+cc1_plugin::marshall_array_elmts (connection *conn, size_t n_bytes,\n+\t\t\t\t  void *elements)\n+{\n+  return conn->send (elements, n_bytes);\n+}\n+\n+cc1_plugin::status\n+cc1_plugin::unmarshall_array_start (connection *conn, char id,\n+\t\t\t\t    size_t *n_elements)\n {\n   unsigned long long len;\n \n-  if (!conn->require ('a'))\n+  if (!conn->require (id))\n     return FAIL;\n   if (!conn->get (&len, sizeof (len)))\n     return FAIL;\n \n-  *result = new gcc_type_array;\n+  *n_elements = len;\n+\n+  return OK;\n+}\n+\n+cc1_plugin::status\n+cc1_plugin::unmarshall_array_elmts (connection *conn, size_t n_bytes,\n+\t\t\t\t    void *elements)\n+{\n+  return conn->get (elements, n_bytes);\n+}\n+\n+cc1_plugin::status\n+cc1_plugin::marshall (connection *conn, const gcc_type_array *a)\n+{\n+  size_t len;\n+\n+  if (a)\n+    len = a->n_elements;\n+  else\n+    len = (size_t)-1;\n+\n+  if (!marshall_array_start (conn, 'a', len))\n+    return FAIL;\n+\n+  if (!a)\n+    return OK;\n+\n+  return marshall_array_elmts (conn, len * sizeof (a->elements[0]),\n+\t\t\t       a->elements);\n+}\n+\n+cc1_plugin::status\n+cc1_plugin::unmarshall (connection *conn, gcc_type_array **result)\n+{\n+  size_t len;\n+\n+  if (!unmarshall_array_start (conn, 'a', &len))\n+    return FAIL;\n+\n+  if (len == (size_t)-1)\n+    {\n+      *result = NULL;\n+      return OK;\n+    }\n+\n+  gcc_type_array *gta = new gcc_type_array;\n \n-  (*result)->n_elements = len;\n-  (*result)->elements = new gcc_type[len];\n+  gta->n_elements = len;\n+  gta->elements = new gcc_type[len];\n \n-  if (!conn->get ((*result)->elements, len * sizeof ((*result)->elements[0])))\n+  if (!unmarshall_array_elmts (conn,\n+\t\t\t       len * sizeof (gta->elements[0]),\n+\t\t\t       gta->elements))\n     {\n-      delete[] (*result)->elements;\n+      delete[] gta->elements;\n       delete *result;\n       return FAIL;\n     }\n \n+  *result = gta;\n+\n   return OK;\n }"}, {"sha": "d238f3a75f223a98293709a8dda34521983f30d3", "filename": "libcc1/marshall.hh", "status": "modified", "additions": 7, "deletions": 8, "changes": 15, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fmarshall.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fmarshall.hh?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -21,7 +21,7 @@ along with GCC; see the file COPYING3.  If not see\n #define CC1_PLUGIN_MARSHALL_HH\n \n #include \"status.hh\"\n-#include \"gcc-c-interface.h\"\n+#include \"gcc-interface.h\"\n \n namespace cc1_plugin\n {\n@@ -44,6 +44,12 @@ namespace cc1_plugin\n   // integer store it in the out argument.\n   status unmarshall_intlike (connection *, protocol_int *);\n \n+  status marshall_array_start (connection *, char, size_t);\n+  status marshall_array_elmts (connection *, size_t, void *);\n+\n+  status unmarshall_array_start (connection *, char, size_t *);\n+  status unmarshall_array_elmts (connection *, size_t, void *);\n+\n   // A template function that can handle marshalling various integer\n   // objects to the connection.\n   template<typename T>\n@@ -67,13 +73,6 @@ namespace cc1_plugin\n     return OK;\n   }\n \n-  // Unmarshallers for some specific enum types.  With C++11 we\n-  // wouldn't need these, as we could add type traits to the scalar\n-  // unmarshaller.\n-  status unmarshall (connection *, enum gcc_c_symbol_kind *);\n-  status unmarshall (connection *, enum gcc_qualifiers *);\n-  status unmarshall (connection *, enum gcc_c_oracle_request *);\n-\n   // Send a string type marker followed by a string.\n   status marshall (connection *, const char *);\n "}, {"sha": "3cd1a1b761db5d0a04ef0f54ea047a0e493333b8", "filename": "libcc1/names.cc", "status": "modified", "additions": 13, "deletions": 7, "changes": 20, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fnames.cc", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fnames.cc", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fnames.cc?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -21,21 +21,27 @@ along with GCC; see the file COPYING3.  If not see\n #include \"names.hh\"\n \n #define GCC_METHOD0(R, N) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD1(R, N, A) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD2(R, N, A, B) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD3(R, N, A, B, C) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD4(R, N, A, B, C, D) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD5(R, N, A, B, C, D, E) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n-  const char *cc1_plugin::N = # N;\n+  const char *cc1_plugin::LANG::N = # N;\n \n+#define LANG c\n #include \"gcc-c-fe.def\"\n+#undef LANG\n+\n+#define LANG cp\n+#include \"gcc-cp-fe.def\"\n+#undef LANG\n \n #undef GCC_METHOD0\n #undef GCC_METHOD1"}, {"sha": "d358e697c7edf390d01007c89835ad7e4177260d", "filename": "libcc1/names.hh", "status": "modified", "additions": 14, "deletions": 4, "changes": 18, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fnames.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Fnames.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Fnames.hh?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -22,10 +22,6 @@ along with GCC; see the file COPYING3.  If not see\n \n namespace cc1_plugin\n {\n-  // This code defines global string constants, one for each method in\n-  // gcc-c-fe.def.  This is needed so that they can be used as\n-  // template arguments elsewhere.\n-\n #define GCC_METHOD0(R, N) \\\n   extern const char *N;\n #define GCC_METHOD1(R, N, A) \\\n@@ -41,7 +37,21 @@ namespace cc1_plugin\n #define GCC_METHOD7(R, N, A, B, C, D, E, F, G) \\\n   extern const char *N;\n \n+  namespace c\n+  {\n+  // This code defines global string constants, one for each method in\n+  // gcc-c-fe.def.  This is needed so that they can be used as\n+  // template arguments elsewhere.\n #include \"gcc-c-fe.def\"\n+  }\n+\n+  namespace cp\n+  {\n+  // This code defines global string constants, one for each method in\n+  // gcc-cp-fe.def.  This is needed so that they can be used as\n+  // template arguments elsewhere.\n+#include \"gcc-cp-fe.def\"\n+  }\n \n #undef GCC_METHOD0\n #undef GCC_METHOD1"}, {"sha": "56a07c2b9de5aac089081f0d4e713bc37afa2e14", "filename": "libcc1/rpc.hh", "status": "modified", "additions": 112, "deletions": 1, "changes": 113, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Frpc.hh", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1/libcc1%2Frpc.hh", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libcc1%2Frpc.hh?ref=8db29d88f3e8d5fc43b25d9e0049c25f6bfb74d1", "patch": "@@ -21,7 +21,6 @@ along with GCC; see the file COPYING3.  If not see\n #define CC1_PLUGIN_RPC_HH\n \n #include \"status.hh\"\n-#include \"marshall.hh\"\n #include \"connection.hh\"\n \n namespace cc1_plugin\n@@ -126,6 +125,118 @@ namespace cc1_plugin\n     argument_wrapper &operator= (const argument_wrapper &);\n   };\n \n+#ifdef GCC_CP_INTERFACE_H\n+  // Specialization for gcc_vbase_array.\n+  template<>\n+  class argument_wrapper<const gcc_vbase_array *>\n+  {\n+  public:\n+    argument_wrapper () : m_object (NULL) { }\n+    ~argument_wrapper ()\n+    {\n+      // It would be nicer if gcc_type_array could have a destructor.\n+      // But, it is in code shared with gdb and cannot.\n+      if (m_object != NULL)\n+\t{\n+\t  delete[] m_object->flags;\n+\t  delete[] m_object->elements;\n+\t}\n+      delete m_object;\n+    }\n+\n+    operator const gcc_vbase_array * () const\n+    {\n+      return m_object;\n+    }\n+\n+    status unmarshall (connection *conn)\n+    {\n+      return ::cc1_plugin::unmarshall (conn, &m_object);\n+    }\n+\n+  private:\n+\n+    gcc_vbase_array *m_object;\n+\n+    // No copying or assignment allowed.\n+    argument_wrapper (const argument_wrapper &);\n+    argument_wrapper &operator= (const argument_wrapper &);\n+  };\n+\n+  // Specialization for gcc_cp_template_args.\n+  template<>\n+  class argument_wrapper<const gcc_cp_template_args *>\n+  {\n+  public:\n+    argument_wrapper () : m_object (NULL) { }\n+    ~argument_wrapper ()\n+    {\n+      // It would be nicer if gcc_type_array could have a destructor.\n+      // But, it is in code shared with gdb and cannot.\n+      if (m_object != NULL)\n+\t{\n+\t  delete[] m_object->elements;\n+\t  delete[] m_object->kinds;\n+\t}\n+      delete m_object;\n+    }\n+\n+    operator const gcc_cp_template_args * () const\n+    {\n+      return m_object;\n+    }\n+\n+    status unmarshall (connection *conn)\n+    {\n+      return ::cc1_plugin::unmarshall (conn, &m_object);\n+    }\n+\n+  private:\n+\n+    gcc_cp_template_args *m_object;\n+\n+    // No copying or assignment allowed.\n+    argument_wrapper (const argument_wrapper &);\n+    argument_wrapper &operator= (const argument_wrapper &);\n+  };\n+\n+  // Specialization for gcc_cp_function_args.\n+  template<>\n+  class argument_wrapper<const gcc_cp_function_args *>\n+  {\n+  public:\n+    argument_wrapper () : m_object (NULL) { }\n+    ~argument_wrapper ()\n+    {\n+      // It would be nicer if gcc_type_array could have a destructor.\n+      // But, it is in code shared with gdb and cannot.\n+      if (m_object != NULL)\n+\t{\n+\t  delete[] m_object->elements;\n+\t}\n+      delete m_object;\n+    }\n+\n+    operator const gcc_cp_function_args * () const\n+    {\n+      return m_object;\n+    }\n+\n+    status unmarshall (connection *conn)\n+    {\n+      return ::cc1_plugin::unmarshall (conn, &m_object);\n+    }\n+\n+  private:\n+\n+    gcc_cp_function_args *m_object;\n+\n+    // No copying or assignment allowed.\n+    argument_wrapper (const argument_wrapper &);\n+    argument_wrapper &operator= (const argument_wrapper &);\n+  };\n+#endif /* GCC_CP_INTERFACE_H */\n+\n   // There are two kinds of template functions here: \"call\" and\n   // \"callback\".  They are each repeated multiple times to handle\n   // different numbers of arguments.  (This would be improved with"}]}