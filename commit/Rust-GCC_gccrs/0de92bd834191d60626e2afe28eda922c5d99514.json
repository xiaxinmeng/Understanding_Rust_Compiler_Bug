{"sha": "0de92bd834191d60626e2afe28eda922c5d99514", "node_id": "MDY6Q29tbWl0MTM2NTMxMDA6MGRlOTJiZDgzNDE5MWQ2MDYyNmUyYWZlMjhlZGE5MjJjNWQ5OTUxNA==", "commit": {"author": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-12-31T14:53:47Z"}, "committer": {"name": "Phil Edwards", "email": "pme@gcc.gnu.org", "date": "2001-12-31T14:53:47Z"}, "message": "stl_deque.h: Doxygenate with initial/example hooks.\n\n2001-12-31  Phil Edwards  <pme@gcc.gnu.org>\n\n\t* include/bits/stl_deque.h:  Doxygenate with initial/example hooks.\n\tClean up spacing and indentation.\n\nFrom-SVN: r48426", "tree": {"sha": "84d36f0de654260ee6128f4d3400ad4cef383f56", "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/trees/84d36f0de654260ee6128f4d3400ad4cef383f56"}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/git/commits/0de92bd834191d60626e2afe28eda922c5d99514", "comment_count": 0, "verification": {"verified": false, "reason": "unsigned", "signature": null, "payload": null}}, "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de92bd834191d60626e2afe28eda922c5d99514", "html_url": "https://github.com/Rust-GCC/gccrs/commit/0de92bd834191d60626e2afe28eda922c5d99514", "comments_url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/0de92bd834191d60626e2afe28eda922c5d99514/comments", "author": null, "committer": null, "parents": [{"sha": "63fea34ee3fec5b5cb65898d8c448a69a9ee38ee", "url": "https://api.github.com/repos/Rust-GCC/gccrs/commits/63fea34ee3fec5b5cb65898d8c448a69a9ee38ee", "html_url": "https://github.com/Rust-GCC/gccrs/commit/63fea34ee3fec5b5cb65898d8c448a69a9ee38ee"}], "stats": {"total": 293, "additions": 211, "deletions": 82}, "files": [{"sha": "4745cbe2216d70becaa7f7f2a3633e5afd2c071d", "filename": "libstdc++-v3/ChangeLog", "status": "modified", "additions": 5, "deletions": 0, "changes": 5, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de92bd834191d60626e2afe28eda922c5d99514/libstdc%2B%2B-v3%2FChangeLog", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de92bd834191d60626e2afe28eda922c5d99514/libstdc%2B%2B-v3%2FChangeLog", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2FChangeLog?ref=0de92bd834191d60626e2afe28eda922c5d99514", "patch": "@@ -1,3 +1,8 @@\n+2001-12-31  Phil Edwards  <pme@gcc.gnu.org>\n+\n+\t* include/bits/stl_deque.h:  Doxygenate with initial/example hooks.\n+\tClean up spacing and indentation.\n+\n 2001-12-31  Paolo Carlini  <pcarlini@unitus.it>\n \n \t* include/ext/slist:  Move into __gnu_cxx,"}, {"sha": "c812027dca86085cadf651e32027d17699a7d84f", "filename": "libstdc++-v3/include/bits/stl_deque.h", "status": "modified", "additions": 206, "deletions": 82, "changes": 288, "blob_url": "https://github.com/Rust-GCC/gccrs/blob/0de92bd834191d60626e2afe28eda922c5d99514/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "raw_url": "https://github.com/Rust-GCC/gccrs/raw/0de92bd834191d60626e2afe28eda922c5d99514/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h", "contents_url": "https://api.github.com/repos/Rust-GCC/gccrs/contents/libstdc%2B%2B-v3%2Finclude%2Fbits%2Fstl_deque.h?ref=0de92bd834191d60626e2afe28eda922c5d99514", "patch": "@@ -65,63 +65,54 @@\n #ifndef __GLIBCPP_INTERNAL_DEQUE_H\n #define __GLIBCPP_INTERNAL_DEQUE_H\n \n-/* Class invariants:\n- *  For any nonsingular iterator i:\n- *    i.node is the address of an element in the map array.  The\n- *      contents of i.node is a pointer to the beginning of a node.\n- *    i.first == *(i.node) \n- *    i.last  == i.first + node_size\n- *    i.cur is a pointer in the range [i.first, i.last).  NOTE:\n- *      the implication of this is that i.cur is always a dereferenceable\n- *      pointer, even if i is a past-the-end iterator.\n- *  Start and Finish are always nonsingular iterators.  NOTE: this means\n- *    that an empty deque must have one node, and that a deque\n- *    with N elements, where N is the buffer size, must have two nodes.\n- *  For every node other than start.node and finish.node, every element\n- *    in the node is an initialized object.  If start.node == finish.node,\n- *    then [start.cur, finish.cur) are initialized objects, and\n- *    the elements outside that range are uninitialized storage.  Otherwise,\n- *    [start.cur, start.last) and [finish.first, finish.cur) are initialized\n- *    objects, and [start.first, start.cur) and [finish.cur, finish.last)\n- *    are uninitialized storage.\n- *  [map, map + map_size) is a valid, non-empty range.  \n- *  [start.node, finish.node] is a valid range contained within \n- *    [map, map + map_size).  \n- *  A pointer in the range [map, map + map_size) points to an allocated node\n- *    if and only if the pointer is in the range [start.node, finish.node].\n- */\n-\n-\n-/*\n- * In previous versions of deque, there was an extra template \n- * parameter so users could control the node size.  This extension\n- * turns out to violate the C++ standard (it can be detected using\n- * template template parameters), and it has been removed.\n- */\n \n+// Since this entire file is within namespace std, there's no reason to\n+// waste two spaces along the left column.  Thus the leading indentation is\n+// slightly violated from here on.\n namespace std\n { \n-  // Note: this function is simply a kludge to work around several compilers'\n-  //  bugs in handling constant expressions.\n-  inline size_t \n-  __deque_buf_size(size_t __size) \n-  { return __size < 512 ? size_t(512 / __size) : size_t(1); }\n-\n-  template <class _Tp, class _Ref, class _Ptr>\n-  struct _Deque_iterator {\n+\n+/**\n+ *  @maint\n+ *  @brief This function controls the size of memory nodes.\n+ *  @param  size  The size of an element.\n+ *  @return   The number (not bytesize) of elements per node.\n+ *\n+ *  This function started off as a compiler kludge from SGI, but seems to\n+ *  be a useful wrapper around a repeated constant expression.\n+ *  @endmaint\n+*/\n+inline size_t \n+__deque_buf_size(size_t __size) \n+{ return __size < 512 ? size_t(512 / __size) : size_t(1); }\n+\n+\n+/// A deque::iterator.\n+/**\n+ *  Quite a bit of intelligence here.  Much of the functionality of deque is\n+ *  actually passed off to this class.  A deque holds two of these internally,\n+ *  marking its valid range.  Access to elements is done as offsets of either\n+ *  of those two, relying on operator overloading in this class.\n+ *\n+ *  @maint\n+ *  All the functions are op overloads except for _M_set_node.\n+ *  @endmaint\n+*/\n+template <class _Tp, class _Ref, class _Ptr>\n+struct _Deque_iterator\n+{\n   typedef _Deque_iterator<_Tp, _Tp&, _Tp*>             iterator;\n   typedef _Deque_iterator<_Tp, const _Tp&, const _Tp*> const_iterator;\n   static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n   typedef random_access_iterator_tag iterator_category;\n-  typedef _Tp value_type;\n-  typedef _Ptr pointer;\n-  typedef _Ref reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n-  typedef _Tp** _Map_pointer;\n-\n-  typedef _Deque_iterator _Self;\n+  typedef _Tp                        value_type;\n+  typedef _Ptr                       pointer;\n+  typedef _Ref                       reference;\n+  typedef size_t                     size_type;\n+  typedef ptrdiff_t                  difference_type;\n+  typedef _Tp**                      _Map_pointer;\n+  typedef _Deque_iterator            _Self;\n \n   _Tp* _M_cur;\n   _Tp* _M_first;\n@@ -213,6 +204,12 @@ namespace std\n   bool operator<=(const _Self& __x) const { return !(__x < *this); }\n   bool operator>=(const _Self& __x) const { return !(*this < __x); }\n \n+  /** @maint\n+   *  Prepares to traverse new_node.  Sets everything except _M_cur, which\n+   *  should therefore be set by the caller immediately afterwards, based on\n+   *  _M_first and _M_last.\n+   *  @endmaint\n+  */\n   void _M_set_node(_Map_pointer __new_node) {\n     _M_node = __new_node;\n     _M_first = *__new_node;\n@@ -228,15 +225,20 @@ operator+(ptrdiff_t __n, const _Deque_iterator<_Tp, _Ref, _Ptr>& __x)\n }\n \n \n-// Deque base class.  It has two purposes.  First, its constructor\n-//  and destructor allocate (but don't initialize) storage.  This makes\n-//  exception safety easier.  Second, the base class encapsulates all of\n-//  the differences between SGI-style allocators and standard-conforming\n-//  allocators.\n-\n-// Base class for ordinary allocators.\n+/// @maint Primary default version.  @endmaint\n+/**\n+ *  @maint\n+ *  Deque base class.  It has two purposes.  First, its constructor\n+ *  and destructor allocate (but don't initialize) storage.  This makes\n+ *  exception safety easier.  Second, the base class encapsulates all of\n+ *  the differences between SGI-style allocators and standard-conforming\n+ *  allocators.  There are two versions:  this ordinary one, and the\n+ *  space-saving specialization for instanceless allocators.\n+ *  @endmaint\n+*/\n template <class _Tp, class _Alloc, bool __is_static>\n-class _Deque_alloc_base {\n+class _Deque_alloc_base\n+{\n public:\n   typedef typename _Alloc_traits<_Tp,_Alloc>::allocator_type allocator_type;\n   allocator_type get_allocator() const { return _M_node_allocator; }\n@@ -268,7 +270,7 @@ class _Deque_alloc_base {\n   size_t _M_map_size;\n };\n \n-// Specialization for instanceless allocators.\n+/// Specialization for instanceless allocators.\n template <class _Tp, class _Alloc>\n class _Deque_alloc_base<_Tp, _Alloc, true>\n {\n@@ -297,6 +299,17 @@ class _Deque_alloc_base<_Tp, _Alloc, true>\n   size_t _M_map_size;\n };\n \n+\n+/**\n+ *  @maint\n+ *  Deque base class.  Using _Alloc_traits in the instantiation of the parent\n+ *  class provides the compile-time dispatching mentioned in the parent's docs.\n+ *  This class provides the unified face for deque's allocation.\n+ *\n+ *  Nothing in this class ever constructs or destroys an actual Tp element.\n+ *  (Deque handles that itself.)  Only/All memory management is performed here.\n+ *  @endmaint\n+*/\n template <class _Tp, class _Alloc>\n class _Deque_base\n   : public _Deque_alloc_base<_Tp,_Alloc,\n@@ -306,7 +319,7 @@ class _Deque_base\n   typedef _Deque_alloc_base<_Tp,_Alloc,\n                              _Alloc_traits<_Tp, _Alloc>::_S_instanceless>\n           _Base;\n-  typedef typename _Base::allocator_type allocator_type;\n+  typedef typename _Base::allocator_type             allocator_type;\n   typedef _Deque_iterator<_Tp,_Tp&,_Tp*>             iterator;\n   typedef _Deque_iterator<_Tp,const _Tp&,const _Tp*> const_iterator;\n \n@@ -328,16 +341,25 @@ class _Deque_base\n   iterator _M_finish;\n };\n \n-// Non-inline member functions from _Deque_base.\n \n template <class _Tp, class _Alloc>\n-_Deque_base<_Tp,_Alloc>::~_Deque_base() {\n+_Deque_base<_Tp,_Alloc>::~_Deque_base()\n+{\n   if (_M_map) {\n     _M_destroy_nodes(_M_start._M_node, _M_finish._M_node + 1);\n     _M_deallocate_map(_M_map, _M_map_size);\n   }\n }\n \n+/**\n+ *  @maint\n+ *  @brief Layout storage.\n+ *  @param  num_elements  The count of T's for which to allocate space at first.\n+ *  @return   Nothing.\n+ *\n+ *  The initial underlying memory layout is a bit complicated...\n+ *  @endmaint\n+*/\n template <class _Tp, class _Alloc>\n void\n _Deque_base<_Tp,_Alloc>::_M_initialize_map(size_t __num_elements)\n@@ -391,37 +413,109 @@ _Deque_base<_Tp,_Alloc>::_M_destroy_nodes(_Tp** __nstart, _Tp** __nfinish)\n     _M_deallocate_node(*__n);\n }\n \n-template <class _Tp, class _Alloc = allocator<_Tp> >\n-class deque : protected _Deque_base<_Tp, _Alloc> {\n \n+/**\n+ *  Placeholder:  see http://www.sgi.com/tech/stl/Deque.html for now.\n+ *\n+ *  In previous HP/SGI versions of deque, there was an extra template parameter\n+ *  so users could control the node size.  This extension turned out to violate\n+ *  the C++ standard (it can be detected using template template parameters),\n+ *  and it was removed.\n+ *\n+ *  @maint\n+ *  Here's how a deque<Tp> manages memory.  Each deque has 4 members:\n+ *  \n+ *  - Tp**        _M_map\n+ *  - size_t      _M_map_size\n+ *  - iterator    _M_start, _M_finish\n+ *  \n+ *  map_size is at least 8.  map is an array of map_size pointers-to-\"nodes\".\n+ *  \n+ *  A \"node\" has no specific type name as such, but it is referred to as\n+ *  \"node\" in this file.  It is a simple array-of-Tp.  If Tp is very large,\n+ *  there will be one Tp element per node (i.e., an \"array\" of one).\n+ *  For non-huge Tp's, node size is inversely related to Tp size:  the\n+ *  larger the Tp, the fewer Tp's will fit in a node.  The goal here is to\n+ *  keep the total size of a node relatively small and constant over different\n+ *  Tp's, to improve allocator efficiency.\n+ *  \n+ *  **** As I write this, the nodes are /not/ allocated using the high-speed\n+ *  memory pool.  There are 20 hours left in the year; perhaps I can fix\n+ *  this before 2002.\n+ *  \n+ *  Not every pointer in the map array will point to a node.  If the initial\n+ *  number of elements in the deque is small, the /middle/ map pointers will\n+ *  be valid, and the ones at the edges will be unused.  This same situation\n+ *  will arise as the map grows:  available map pointers, if any, will be on\n+ *  the ends.  As new nodes are created, only a subset of the map's pointers\n+ *  need to be copied \"outward\".\n+ *\n+ *  Class invariants:\n+ * - For any nonsingular iterator i:\n+ *    - i.node points to a member of the map array.  (Yes, you read that\n+ *      correctly:  i.node does not actually point to a node.)  The member of\n+ *      the map array is what actually points to the node.\n+ *    - i.first == *(i.node)    (This points to the node (first Tp element).)\n+ *    - i.last  == i.first + node_size\n+ *    - i.cur is a pointer in the range [i.first, i.last).  NOTE:\n+ *      the implication of this is that i.cur is always a dereferenceable\n+ *      pointer, even if i is a past-the-end iterator.\n+ * - Start and Finish are always nonsingular iterators.  NOTE: this means that\n+ *   an empty deque must have one node, a deque with <N elements (where N is\n+ *   the node buffer size) must have one node, a deque with N through (2N-1)\n+ *   elements must have two nodes, etc.\n+ * - For every node other than start.node and finish.node, every element in the\n+ *   node is an initialized object.  If start.node == finish.node, then\n+ *   [start.cur, finish.cur) are initialized objects, and the elements outside\n+ *   that range are uninitialized storage.  Otherwise, [start.cur, start.last)\n+ *   and [finish.first, finish.cur) are initialized objects, and [start.first,\n+ *   start.cur) and [finish.cur, finish.last) are uninitialized storage.\n+ * - [map, map + map_size) is a valid, non-empty range.  \n+ * - [start.node, finish.node] is a valid range contained within \n+ *   [map, map + map_size).  \n+ * - A pointer in the range [map, map + map_size) points to an allocated node\n+ *   if and only if the pointer is in the range [start.node, finish.node].\n+ *\n+ *  Here's the magic:  nothing in deque is \"aware\" of the discontiguous storage!\n+ *\n+ *  The memory setup and layout occurs in the parent, _Base, and the iterator\n+ *  class is entirely responsible for \"leaping\" from one node to the next.  All\n+ *  the implementation routines for deque itself work only through the start\n+ *  and finish iterators.  This keeps the routines simple and sane, and we can\n+ *  use other standard algorithms as well.\n+ *\n+ *  @endmaint\n+*/\n+template <class _Tp, class _Alloc = allocator<_Tp> >\n+class deque : protected _Deque_base<_Tp, _Alloc>\n+{\n   // concept requirements\n   __glibcpp_class_requires(_Tp, _SGIAssignableConcept)\n \n   typedef _Deque_base<_Tp, _Alloc> _Base;\n-public:                         // Basic types\n-  typedef _Tp value_type;\n-  typedef value_type* pointer;\n-  typedef const value_type* const_pointer;\n-  typedef value_type& reference;\n-  typedef const value_type& const_reference;\n-  typedef size_t size_type;\n-  typedef ptrdiff_t difference_type;\n+\n+public:\n+  typedef _Tp                                value_type;\n+  typedef value_type*                        pointer;\n+  typedef const value_type*                  const_pointer;\n+  typedef value_type&                        reference;\n+  typedef const value_type&                  const_reference;\n+  typedef size_t                             size_type;\n+  typedef ptrdiff_t                          difference_type;\n \n   typedef typename _Base::allocator_type allocator_type;\n   allocator_type get_allocator() const { return _Base::get_allocator(); }\n \n-public:                         // Iterators\n-  typedef typename _Base::iterator       iterator;\n-  typedef typename _Base::const_iterator const_iterator;\n+  typedef typename _Base::iterator           iterator;\n+  typedef typename _Base::const_iterator     const_iterator;\n+  typedef reverse_iterator<const_iterator>   const_reverse_iterator;\n+  typedef reverse_iterator<iterator>         reverse_iterator;\n \n-  typedef reverse_iterator<const_iterator> const_reverse_iterator;\n-  typedef reverse_iterator<iterator> reverse_iterator;\n-\n-protected:                      // Internal typedefs\n+protected:\n   typedef pointer* _Map_pointer;\n   static size_t _S_buffer_size() { return __deque_buf_size(sizeof(_Tp)); }\n \n-protected:\n+  // Functions controlling memory layout, and nothing else.\n   using _Base::_M_initialize_map;\n   using _Base::_M_create_nodes;\n   using _Base::_M_destroy_nodes;\n@@ -430,6 +524,12 @@ class deque : protected _Deque_base<_Tp, _Alloc> {\n   using _Base::_M_allocate_map;\n   using _Base::_M_deallocate_map;\n \n+  /** @maint\n+   *  A total of four data members accumulated down the heirarchy.  If the\n+   *  _Alloc type requires separate instances, then two of them will also be\n+   *  included in each deque.\n+   *  @endmaint\n+  */\n   using _Base::_M_map;\n   using _Base::_M_map_size;\n   using _Base::_M_start;\n@@ -935,10 +1035,21 @@ void deque<_Tp,_Alloc>::clear()\n   _M_finish = _M_start;\n }\n \n-// Precondition: _M_start and _M_finish have already been initialized,\n-// but none of the deque's elements have yet been constructed.\n+/**\n+ *  @maint\n+ *  @brief Fills the deque with copies of value.\n+ *  @param  value  Initial value.\n+ *  @return   Nothing.\n+ *  @pre _M_start and _M_finish have already been initialized, but none of the\n+ *       deque's elements have yet been constructed.\n+ *\n+ *  This function is called only when the user provides an explicit size (with\n+ *  or without an explicit exemplar value).\n+ *  @endmaint\n+*/\n template <class _Tp, class _Alloc>\n-void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n+void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value)\n+{\n   _Map_pointer __cur;\n   try {\n     for (__cur = _M_start._M_node; __cur < _M_finish._M_node; ++__cur)\n@@ -952,6 +1063,18 @@ void deque<_Tp,_Alloc>::_M_fill_initialize(const value_type& __value) {\n     }\n }\n \n+/** @{\n+ *  @maint\n+ *  @brief Fills the deque with whatever is in [first,last).\n+ *  @param  first  An input iterator.\n+ *  @param  last  An input iterator.\n+ *  @return   Nothing.\n+ *\n+ *  If the iterators are actually forward iterators (or better), then the\n+ *  memory layout can be done all at once.  Else we move forward using\n+ *  push_back on each value from the iterator.\n+ *  @endmaint\n+*/\n template <class _Tp, class _Alloc> template <class _InputIterator>\n void deque<_Tp,_Alloc>::_M_range_initialize(_InputIterator __first,\n                                             _InputIterator __last,\n@@ -996,6 +1119,7 @@ void deque<_Tp,_Alloc>::_M_range_initialize(_ForwardIterator __first,\n       __throw_exception_again;\n     }\n }\n+/** @} */\n \n // Called only if _M_finish._M_cur == _M_finish._M_last - 1.\n template <class _Tp, class _Alloc>"}]}